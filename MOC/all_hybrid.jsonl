{"filename":"cryptol\/examples\/splitAt.cry","filetype":"cry","content":"x = [1,2,3,4] : [_][8]\n\ny = (splitAt x) : ([2][8],[2][8])\n\na = y.0 @ 0\nb = y.0 @ 1\nc = y.1 @ 0\nd = y.1 @ 1\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/AE.cry","filetype":"cry","content":"\/*\nImplementation of the algorithms from the paper\n  \"Automated Analysis and Synthesis of Authenticated Encryption Schemes\"\n  by Viet Tung Hoang, Jonathan Katz, and Alex J. Malozemoff\n*\/\nmodule AE where\n\nparameter\n  type A : *            type K : *            type n : #            type p : #            type tagAmount : #\n\n  type constraint (fin p, fin n, n >= tagAmount)\n\n  \/\/ Process a single block using this key and tweak\n  tweak_cipher : K -> { nonce : [n], state : A, z : [64] } -> [n] -> [n]\n\n  \/\/ Cost for using the tweak\n  Cost : [64]\n\n  Enc : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Dec : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Tag : K -> { nonce : [n], state : A, z : [64] } -> [p*n] -> [n]\n\n\/\/ The unit at which `Enc` operates\ntype Node       = { message : WorkBlock, state : State }\n\n\/\/ Some encryption schemes process multiple blocks at once\ntype WorkBlock  = [p*n]\n\ntype State      = [p*n]  \/\/ The state for `p` blocks\n\ntype Tweak      = { nonce : Nonce, state : A, z : Int }\ntype Nonce      = [n]\n\n\/*\nproperty\n\n  \/\/ The tweak in the `i`th query to the tweak_cipher\n  tweak_prop i { nonce = n, state = a, z = v } =\n               { nonce = n, state = a, z = v + i - 1 }\n\n\n  \/\/ Property of decrypt\n  Dec_prop : Tweak -> Node -> Bit\n  Dec_prop t { message = m, state = x } =\n       Dec t { message = c, state = x } == { message = m, state = y }\n       where { message = c, state = y } = Enc t x m\n*\/\n\ntype Int = [64]\n\nencrypt :\n  {m} fin m => K -> Nonce -> A -> [m * (p * n)] -> [m * (p * n) + tagAmount]\nencrypt key nonce state inputMsg = encMsg # tag\n\n  where\n  encMsg = join rest.0.message\n\n  tag = take (Tag key (tweak (1 - final.1)) final.0.state)\n\n  final = steps ! 0\n\n  steps = [ ({ message = undefined, state = zero }, 1) ] # rest\n  rest  = [ (Enc key (tweak v) { message = m, state = prev.state }, v + Cost)\n          | (prev,v) <- steps\n          | m        <- chunks\n          ]\n\n  \/\/ XXX: isn't v i  just 1 + i * Cost\n\n  chunks : [m] [p * n]\n  chunks = split inputMsg\n\n  tweak : Int -> Tweak\n  tweak v = { nonce = nonce, state = state, z = v }\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/xor_cipher.cry","filetype":"cry","content":"encrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\nencrypt key plaintext = [pt ^ key | pt <- plaintext ]\n\ndecrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\ndecrypt key ciphertext = [ct ^ key | ct <- ciphertext ]\n\nproperty roundtrip k ip = decrypt k (encrypt k ip) == ip","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/examples\/zero_weird.cry","filetype":"cry","content":"x : {a}() => a -> [16]\nx v = zero v \n\nproperty xprop v = x v == 0\n\ny : [12] -> [4] -> [17]\ny a b = zero a b\n\nproperty yprop v w = y v w == 0\n\nt1 = x 13\nt2 = y 2 3\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/builtin_lifting.cry","filetype":"cry","content":"\/\/builtins lift over tuples, seqs, and records\n\n\/\/this file uses addition to model a builtin\n\/\/but this should work for any builtin operators\n\nx = [True,False]\ny = [False,True]\n\n\/\/make sure bitvectors are numbers\nproperty p1 = x == (2 : [2])\n\n\/\/same thing written 2 different ways\nproperty p2 = x + y == 3\nproperty p3 = x + y == [True,True]\n\n\nxx = [[True,False]]\nyy = [[False,True]]\n\n\/\/addition lifts pointwise over sequences\nproperty p4 = xx + yy == [3]\n\n\/\/negation is a unary operator that also lifts over sequences\nproperty p5 = ~ xx == yy\n\n\nxinf = [2 ... ]\nyinf = [3 ... ]\n\n\/\/addition lifts pointwise over infinite lists\nproperty p6 = (xinf + yinf) @ (0 : [0]) == (1 : [2])\n\n\/\/negation lifts pointwise over an infinite list\nproperty p7 = (~ xinf) @ (0 : [0]) == (1 : [2])\n\nxrec = { x = 2 : [2], y = 2 : [2] } : {x : [2], y : [2]}\n\nproperty p8 = xrec + xrec + xrec == xrec\n\n\/\/lift over tuples and records at the same time\nproperty p9 = (2,2,xrec) + (2,2,xrec) + (2,2,xrec) == (2:[2],2:[2],xrec) \n\n\/\/lift unary over tuples and lists\nproperty p10 = (~ { x = (1,2), y = [3,4,5] }) == {x = (0:[1],1:[2]), y = [4, 3, 2] : [3][3] }\n\n\n\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/inflist.cry","filetype":"cry","content":"a = [1 ... ]\nb = [1,2 ... ]\nc = [1 .. 5]\nd = [1,3 .. 9]\n\nproperty t1 = a @ 3 == 1\nproperty t2 = b @ 3 == 1\nproperty t3 = c @ 3 == 4\nproperty t4 = d @ 3 == 4\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/Karatsuba.cry","filetype":"cry","content":"\/*\n * Copyright (c) 2017 Galois, Inc.\n * Distributed under the terms of the BSD3 license (see LICENSE file)\n *\n * This module defines a Karatsuba multiplier, which is polymorphic over the\n * bitwidth of the constituent limbs and the size of the inputs.\n *\n * Note the trick of using `make_atleast` in the recursive case to teach the\n * typecheker that the current bitwidth is long enough for the split multiplier\n * to be sensible.  The minimum width for which the splitting recursive case\n * works out happens to be 6.  This is the smallest width for which the\n * divide-in-half strategy leaves enough bits left over for the additions\n * steps not to overflow.\n *\n * Note that if one wishes to simulate using a standard CPU to perform Karatsuba\n * multiplies, the limb width should be set to ONE LESS THAN the standard\n * machine word size, e.g. 63 bits for a 64 bit machine.  This ensures that\n * the intermediate additions will fit into a machine word.  Note that the the\n * final `2*(limb+1)`-width additions will also have to be assembled manually\n * using \"add with carry\" operations or similar.\n *\/\n\nmodule Karatsuba where\n\n\/\/ The divide-and-conquer Karatsuba multiplier.  If the argument width\n\/\/ is greater than the limb width, then the recursive `splitmult` multiplier\n\/\/ is called; otherwise, a standard multiply is used.\n\nkmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 1) => [n] -> [n] -> [2*n]\n\nkmult x y =\n if `n >= (`limb : [max (width limb) (width n)]) then\n   take (splitmult`{limb} (make_atleast`{limb} x) (make_atleast`{limb} y))\n else\n   (zero#x)*(zero#y)\n\n\n\/\/ Force a bitvector to be at least `n` bits long.  As used above, this operation\n\/\/ should always be a no-op, but teaches the typechecker a necessary inequality\n\/\/ to call the `splitmult` operation.\n\nmake_atleast : {n, m, a} (fin n, fin m, Zero a) => [m]a -> [max n m]a\nmake_atleast x = zero#x\n\n\n\n\/\/ Execute the recursive step of Karatsuba's multiplication. Split the\n\/\/ input words into high and low bit portions; then perform three\n\/\/ recursive multiplies using these intermediate, shorter bitsequences.\n\nsplitmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 6)\n         => [n] -> [n] -> [2*n]\n\nsplitmult x y = (ac # bd) + (zero # ad_bc # (zero:[low]))\n  where\n   type hi  = n\/2\n   type low = n - hi\n\n   (a,b) = splitAt`{hi} x\n   (c,d) = splitAt`{hi} y\n\n   ac : [2*hi]\n   ac = kmult`{limb,hi} a c\n\n   bd : [2*low]\n   bd = kmult`{limb,low} b d\n\n   a_b = (zext a) + (zext b)\n   c_d = (zext c) + (zext d)\n\n   ad_bc : [2*(low+1)]\n   ad_bc = (kmult`{limb,low+1} a_b c_d) - (zext ac) - (zext bd)\n\n\n\/\/ Verify Karatsuba's algorithm computes the correct answer\n\/\/ for some fixed settings of the parameters.\n\/\/\n\/\/ SMT solvers have great difficutly with these proofs, and I have\n\/\/ only gotten small bit sizes to return with successful proofs.\n\nproperty splitmult_correct_tiny (x:[9]) (y:[9]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_small (x:[11]) (y:[11]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_medium(x:[17]) (y:[17]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_large (x:[59]) (y:[59]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_huge (x:[511]) (y:[511]) =\n  zext x * zext y == splitmult`{limb=63} x y\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/examples\/comp.cry","filetype":"cry","content":"x : [_]([2],[3],[3],[4])\nx = [(a,b,c,d) | a <- [1,2], b <- [3,4] | c <- [5,6], d <- [7,8,9] ]\n\nproperty t1 = x @ 0 == (1,3,5,7)\nproperty t2 = x @ 2 == (2,3,5,9)\nproperty t3 = x @ 3 == (2,4,6,7)\n\ny = [(a,b,c) | a <- [1,2,3], b <- [1,2] | c <- [1 ... ] ]\n\nproperty t4 = y @ 3 == (2,2,0)\n","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/examples\/Test.cry","filetype":"cry","content":"\/\/ Don't load this on its own -- it gets pulled in by, e.g., DEStest.cry\n\nmodule Test where\nimport Cipher\n\nevktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\nevktest (cipher, vkeysCTs, PT) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, CT) <- vkeysCTs ]\n\nevttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\nevttest (cipher, Key, vtextPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (PT, CT) <- vtextPCTs ]\n\nekatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\nekatest (cipher, kaKPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, PT, CT) <- kaKPCTs ]\n\ndvktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\ndvktest (cipher, vkeysCTs, PT) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, CT) <- vkeysCTs ]\n\ndvttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\ndvttest (cipher, Key, vtextPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (PT, CT) <- vtextPCTs ]\n\ndkatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\ndkatest (cipher, kaKPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, PT, CT) <- kaKPCTs ]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/examples\/builtins.cry","filetype":"cry","content":"\/\/Here's a test of some builtin operators\n\/\/nothing too deep, just making sure they all work out\n\nt : [8]\nt = if True then 5 else 4 f : [8]\nf = if False then 3 else 5 times : [8]\ntimes = 5 * 1 * 2 * 3 div : [8]\ndiv = (((30\/1)\/2)\/3) mod : [8]\nmod = 205%10 exp : [8]\nexp = 2^^7 lgtest : [8]\nlgtest = lg2 128 p : [8]\np = 3+2 m : [8]\nm = 8-3 neg : [8]\nneg = -(-5) comp : [8]\ncomp = ~250 ","variant":"hybrid","set":"supervised"}
{"filename":"cryptol\/examples\/props.cry","filetype":"cry","content":"x = [True, False]\ny = [False, True]\nz = x + y\n\nproperty p1 = z == 3\n\nxx = [[True,False]]\nyy = [[False, True]]\nzz = xx + yy\n\n\n\nt : {a} [a*3] -> [a*3][a*3]\nt d = zero\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/lib\/Array.cry","filetype":"cry","content":"module Array where\n\nprimitive type Array : * -> * -> *\n\nprimitive arrayConstant : {a, b} b -> (Array a b)\nprimitive arrayLookup : {a, b} (Array a b) -> a -> b\nprimitive arrayUpdate : {a, b} (Array a b) -> a -> b -> (Array a b)\nprimitive arrayEq : {n, a} (Array [n] a) -> (Array [n] a) -> Bool\n\n\/**\n * Copy elements from the source array to the destination array.\n *\n * 'arrayCopy dest_arr dest_idx src_arr src_idx len' copies the\n * elements from 'src_arr' at indices '[src_idx ..< (src_idx + len)]' into\n * 'dest_arr' at indices '[dest_idx ..< (dest_idx + len)]'.\n *\n * The result is undefined if either 'dest_idx + len' or 'src_idx + len'\n * wraps around.\n *\/\nprimitive arrayCopy : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> (Array [n] a)\n\/**\n * Set elements of the given array.\n *\n * 'arraySet' arr idx val len' sets the elements of 'arr' at indices\n * '[idx ..< (idx + len)]' to 'val'.\n *\n * The result is undefined if 'idx + len' wraps around.\n *\/\nprimitive arraySet : {n, a} (Array [n] a) -> [n] -> a -> [n] -> (Array [n] a)\n\/**\n * Check whether the lhs array and rhs array are equal at a range of\n * indices.\n *\n * 'arrayRangeEq sym lhs_arr lhs_idx rhs_arr rhs_idx len' checks whether\n * the elements of 'lhs_arr' at indices '[lhs_idx ..< (lhs_idx + len)]' and\n * the elements of 'rhs_arr' at indices '[rhs_idx ..< (rhs_idx + len)]' are\n * equal.\n *\n * The result is undefined if either 'lhs_idx + len' or 'rhs_idx + len'\n * wraps around.\n *\/\nprimitive arrayRangeEqual : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> Bool\n\narrayRangeLookup : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b\narrayRangeLookup arr idx = res\n  where\n    res @ i = arrayLookup arr (idx + i)\n\narrayRangeUpdate : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b -> (Array a b)\narrayRangeUpdate arr idx vals = arrs ! 0\n  where\n    arrs = [arr] # [ arrayUpdate acc (idx + i) val | acc <- arrs | i <- [0 ..< n] | val <- vals ]\n\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/lib\/SuiteB.cry","filetype":"cry","content":"module SuiteB where\n\n\/***** AES ******\/\n\n\/**\n * Key schedule parameter setting for AES-128\n *\/\ntype AES128 = 4\n\n\/**\n * Key schedule parameter setting for AES-192\n *\/\ntype AES192 = 6\n\n\/**\n * Key schedule parameter setting for AES-256\n *\/\ntype AES256 = 8\n\n\/**\n * Element of an AES key schedule for use in a particular round\n *\/\ntype AESRoundKey = [4][32]\n\n\/**\n * Expanded encryption key schedule for AES\n *\/\ntype AESEncryptKeySchedule k =\n  { aesEncInitialKey : AESRoundKey\n  , aesEncRoundKeys  : [k+5]AESRoundKey\n  , aesEncFinalKey   : AESRoundKey\n  }\n\n\/**\n * Expanded decryption key schedule for AES\n *\/\ntype AESDecryptKeySchedule k =\n  { aesDecInitialKey : AESRoundKey\n  , aesDecRoundKeys  : [k+5]AESRoundKey\n  , aesDecFinalKey   : AESRoundKey\n  }\n\n\/**\n * Encryption key expansion for AES-128.\n *   See FIPS 197, section 5.2.\n *\/\naes128EncryptSchedule : [128] -> AESEncryptKeySchedule AES128\naes128EncryptSchedule = aesExpandEncryptSchedule\n\n\/**\n * Decryption key expansion for AES-128, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes128DecryptSchedule : [128] -> AESDecryptKeySchedule AES128\naes128DecryptSchedule = aesExpandDecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-128.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes128Schedules : [128] -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\naes128Schedules = aesExpandSchedules\n\n\/**\n * Encryption key expansion for AES-192.\n *   See FIPS 197, section 5.2.\n *\/\naes192EncryptSchedule : [192] -> AESEncryptKeySchedule AES192\naes192EncryptSchedule = aesExpandEncryptSchedule\n\n\/**\n * Decryption key expansion for AES-192, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes192DecryptSchedule : [192] -> AESDecryptKeySchedule AES192\naes192DecryptSchedule = aesExpandDecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-192.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes192Schedules : [192] -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\naes192Schedules = aesExpandSchedules\n\n\n\/**\n * Encryption key expansion for AES-256.\n *   See FIPS 197, section 5.2\n *\/\naes256EncryptSchedule : [256] -> AESEncryptKeySchedule AES256\naes256EncryptSchedule = aesExpandEncryptSchedule\n\n\/**\n * Decryption key expansion for AES-256, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes256DecryptSchedule : [256] -> AESDecryptKeySchedule AES256\naes256DecryptSchedule = aesExpandDecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-256.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes256Schedules : [256] -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\naes256Schedules = aesExpandSchedules\n\n\/**\n * AES block encryption algorithm.\n *   See FIPS 197, section 5.1.\n *\/\naesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]\naesEncryptBlock schedule plaintext = rnf (join final)\n  where\n  final = (AESEncFinalRound (rds!0)) ^ schedule.aesEncFinalKey\n\n  rds = [ schedule.aesEncInitialKey ^ split plaintext ] #\n        [ AESEncRound r ^ rdk\n        | rdk <- schedule.aesEncRoundKeys\n        | r   <- rds\n        ]\n\n\/**\n * AES block decryption algorithm, via the \"equivalent inverse cypher\".\n *   See FIPS 197, section 5.3.5.\n *\/\naesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]\naesDecryptBlock schedule cyphertext = rnf (join final)\n  where\n  final = (AESDecFinalRound (rds!0)) ^ schedule.aesDecFinalKey\n\n  rds = [ split cyphertext ^ schedule.aesDecInitialKey ] #\n        [ AESDecRound r ^ rdk\n        | rdk <- schedule.aesDecRoundKeys\n        | r   <- rds\n        ]\n\nprivate\n    aesExpandEncryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESEncryptKeySchedule k\n    aesExpandEncryptSchedule key = rnf\n         { aesEncInitialKey = ks @  0\n         , aesEncRoundKeys  = ks @@ [ 1 .. k+5 ]\n         , aesEncFinalKey   = ks @  `(k+6)\n         }\n      where\n      ks : [k+7]AESRoundKey\n      ks = groupBy`{4} (AESKeyExpand`{k} (split key))\n\n    aesEncToDecSchedule : {k} (fin k) => AESEncryptKeySchedule k -> AESDecryptKeySchedule k\n    aesEncToDecSchedule enc = rnf\n       { aesDecInitialKey = enc.aesEncFinalKey\n       , aesDecRoundKeys  = map AESInvMixColumns (reverse (enc.aesEncRoundKeys))\n       , aesDecFinalKey   = enc.aesEncInitialKey\n       }\n\n    aesExpandDecryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESDecryptKeySchedule k\n    aesExpandDecryptSchedule key = aesEncToDecSchedule (aesExpandEncryptSchedule key)\n\n    aesExpandSchedules : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> (AESEncryptKeySchedule k, AESDecryptKeySchedule k)\n    aesExpandSchedules key = (encS, aesEncToDecSchedule encS)\n      where encS = aesExpandEncryptSchedule key\n\n    primitive AESEncRound      : [4][32] -> [4][32]\n    primitive AESEncFinalRound : [4][32] -> [4][32]\n    primitive AESDecRound      : [4][32] -> [4][32]\n    primitive AESDecFinalRound : [4][32] -> [4][32]\n    primitive AESInvMixColumns : [4][32] -> [4][32]\n    primitive AESKeyExpand     : {k} (fin k, k >= 4, 8 >= k) => [k][32] -> [4*(k+7)][32]\n\n\n\/***** SHA2 *****\/\n\n\/**\n * The SHA-224 secure hash algorithm.  See FIPS 180-4, section 6.3.\n *\/\nsha224 : {L} (fin L) => [L] -> [224]\nsha224 msg = join (processSHA2_224 (sha2blocks`{32} msg))\n\n\/**\n * The SHA-256 secure hash algorithm.  See FIPS 180-4, section 6.2.2.\n *\/\nsha256 : {L} (fin L) => [L] -> [256]\nsha256 msg = join (processSHA2_256 (sha2blocks`{32} msg))\n\n\/**\n * The SHA-384 secure hash algorithm.  See FIPS 180-4, section 6.5.\n *\/\nsha384 : {L} (fin L) => [L] -> [384]\nsha384 msg = join (processSHA2_384 (sha2blocks`{64} msg))\n\n\/**\n * The SHA-512 secure hash algorithm.  See FIPS 180-4, section 6.4.\n *\/\nsha512 : {L} (fin L) => [L] -> [512]\nsha512 msg = join (processSHA2_512 (sha2blocks`{64} msg))\n\nprivate\n    type sha2_block_size w = 16 * w\n    type sha2_num_blocks w L = (L+1+2*w) \/^ sha2_block_size w\n    type sha2_padded_size w L = sha2_num_blocks w L * sha2_block_size w\n\n    sha2pad : {w, L} (fin w, fin L, w >= 1) => [L] -> [sha2_padded_size w L]\n    sha2pad M = rnf (M # 0b1 # zero # ((fromInteger `L) : [2*w]))\n\n    sha2blocks : {w, L} (fin w, fin L, w >= 1) =>\n      [L] -> [sha2_num_blocks w L][16][w]\n    sha2blocks msg = [ split x | x <- split (sha2pad`{w} msg) ]\n\n    \/**\n     * Apply the SHA224 hash algorithm to a sequence of SHA256-size blocks,\n     * which are assumed to already be correctly padded.\n     *\/\n    primitive processSHA2_224 : {n} (fin n) => [n][16][32] -> [7][32]\n\n    \/**\n     * Apply the SHA256 hash algorithm to a sequence of SHA256-size blocks,\n     * which are assumed to already be correctly padded.\n     *\/\n    primitive processSHA2_256 : {n} (fin n) => [n][16][32] -> [8][32]\n\n    \/**\n     * Apply the SHA384 hash algorithm to a sequence of SHA512-size blocks,\n     * which are assumed to already be correctly padded.\n     *\/\n    primitive processSHA2_384 : {n} (fin n) => [n][16][64] -> [6][64]\n\n    \/**\n     * Apply the SHA512 hash algorithm to a sequence of SHA512-size blocks,\n     * which are assumed to already be correctly padded.\n     *\/\n    primitive processSHA2_512 : {n} (fin n) => [n][16][64] -> [8][64]\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/lib\/Float.cry","filetype":"cry","content":"module Float where\n\nprimitive type ValidFloat : # -> # -> Prop\n\n\/** IEEE-754 floating point numbers. *\/\nprimitive type { exponent : #, precision : #}\n  ValidFloat exponent precision => Float exponent precision : *\n\n\/** An abbreviation for common 16-bit floating point numbers. *\/\ntype Float16  = Float 5 11\n\n\/** An abbreviation for common 32-bit floating point numbers. *\/\ntype Float32  = Float 8 24\n\n\/** An abbreviation for common 64-bit floating point numbers. *\/\ntype Float64  = Float 11 53\n\n\/** An abbreviation for common 128-bit floating point numbers. *\/\ntype Float128 = Float 15 113\n\n\/** An abbreviation for common 256-bit floating point numbers. *\/\ntype Float256 = Float 19 237\n\n\n\n\/* ----------------------------------------------------------------------\n * Rounding modes (this should be an enumeration type, when we add these)\n *---------------------------------------------------------------------- *\/\n\n\/**\n * A 'RoundingMode' is used to specify the precise behavior of some\n * floating point primitives.\n *\n * There are five valid 'RoundingMode' values:\n *  * roundNearestEven\n *  * roundNearestAway\n *  * roundPositive\n *  * roundNegative\n *  * roundZero\n *\/\ntype RoundingMode = [3]\n\n\/** Round toward nearest, ties go to even. *\/\nroundNearestEven, rne : RoundingMode\nroundNearestEven = 0\nrne              = roundNearestEven\n\n\/** Round toward nearest, ties away from zero. *\/\nroundNearestAway, rna : RoundingMode\nroundNearestAway  = 1\nrna               = roundNearestAway\n\n\/** Round toward positive infinity. *\/\nroundPositive, rtp : RoundingMode\nroundPositive     = 2\nrtp               = roundPositive\n\n\/** Round toward negative infinity. *\/\nroundNegative, rtn : RoundingMode\nroundNegative     = 3\nrtn               = roundNegative\n\n\/** Round toward zero. *\/\nroundZero, rtz : RoundingMode\nroundZero         = 4\nrtz               = roundZero\n\n\n\n\/** Not a number. *\/\nprimitive\n  fpNaN : {e,p} ValidFloat e p => Float e p\n\n\/** Positive infinity. *\/\nprimitive\n  fpPosInf : {e,p} ValidFloat e p => Float e p\n\n\/** Negative infinity. *\/\nfpNegInf : {e,p} ValidFloat e p => Float e p\nfpNegInf = - fpPosInf\n\n\/** Positive zero. *\/\nfpPosZero : {e,p} ValidFloat e p => Float e p\nfpPosZero = zero\n\n\/** Negative zero. *\/\nfpNegZero : {e,p} ValidFloat e p => Float e p\nfpNegZero = - fpPosZero\n\n\n\/** A floating point number using the exact bit pattern,\nin IEEE interchange format with layout:\n\n  (sign : [1]) # (biased_exponent : [e]) # (significand : [p-1])\n*\/\nprimitive\n  fpFromBits : {e,p} ValidFloat e p => [e + p] -> Float e p\n\n\/** Export a floating point number in IEEE interchange format with layout:\n\n  (sign : [1]) # (biased_exponent : [e]) # (significand : [p-1])\n\nNaN is represented as:\n  * positive:           sign        == 0\n  * quiet with no info: significand == 0b1 # 0\n*\/\nprimitive\n  fpToBits : {e,p} ValidFloat e p => Float e p -> [e + p]\n\n\n\n\n\n\/\/ Operations in `Cmp` use IEEE reasoning.\n\n\/** Check if two floating point numbers are representationally the same.\nIn particular, the following hold:\n    *    NaN       =.= NaN\n    * ~ (pfNegZero =.= fpPosZero)\n*\/\nprimitive\n  (=.=) : {e,p} ValidFloat e p => Float e p -> Float e p -> Bool\n\ninfix 20 =.=\n\n\/** Test if this value is not-a-number (NaN). *\/\nprimitive fpIsNaN : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/** Test if this value is positive or negative infinity. *\/\nprimitive fpIsInf : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/** Test if this value is positive or negative zero. *\/\nprimitive fpIsZero : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/** Test if this value is negative. *\/\nprimitive fpIsNeg : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/** Test if this value is normal (not NaN, not infinite, not zero, and not subnormal). *\/\nprimitive fpIsNormal : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/**\n * Test if this value is subnormal.  Subnormal values are nonzero\n * values with magnitudes smaller than can be represented with the\n * normal implicit leading bit convention.\n *\/\nprimitive fpIsSubnormal : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/* Returns true for numbers that are not an infinity or NaN. *\/\nfpIsFinite : {e,p} ValidFloat e p => Float e p -> Bool\nfpIsFinite f = ~ (fpIsNaN f \\\/ fpIsInf f )\n\n\n\/** Add floating point numbers using the given rounding mode. *\/\nprimitive\n  fpAdd : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\n\/** Subtract floating point numbers using the given rounding mode. *\/\nprimitive\n  fpSub : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\n\/** Multiply floating point numbers using the given rounding mode. *\/\nprimitive\n  fpMul : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\n\/** Divide floating point numbers using the given rounding mode. *\/\nprimitive\n  fpDiv : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\n\/**\n * Fused-multiply-add.  'fpFMA r x y z' computes the value '(x*y)+z',\n * rounding the result according to mode 'r' only after performing both\n * operations.\n *\/\nprimitive\n  fpFMA : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p -> Float e p\n\n\/**\n * Absolute value of a floating-point value.\n *\/\nprimitive\n  fpAbs : {e,p} ValidFloat e p =>\n    Float e p -> Float e p\n\n\/**\n * Square root of a floating-point value.  The square root of\n * a negative value yiels NaN, except that the sqaure root of\n * '-0.0' is '-0.0'.\n *\/\nprimitive\n  fpSqrt : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p\n\n\/** Convert a floating point number to a rational.\nIt is an error to use this with infinity or NaN **\/\nprimitive\n  fpToRational : {e,p} ValidFloat e p =>\n    Float e p -> Rational\n\n\/** Convert a rational to a floating point number, using the\ngiven rounding mode, if the number cannot be represented exactly. *\/\nprimitive\n  fpFromRational : {e,p} ValidFloat e p =>\n    RoundingMode -> Rational -> Float e p\n","variant":"hybrid","set":"unsupervised"}
{"filename":"cryptol\/lib\/PrimeEC.cry","filetype":"cry","content":"module PrimeEC where\n\n\/**\n * The type of points of an elliptic curve in affine coordinates.\n * The coefficients are taken from the prime field 'Z p' with 'p > 3'.\n * This is intended to represent all the \"normal\" points\n * on the curve, which satisfy 'x^^3 == y^^2 - 3x + b', \n * for some curve parameter 'b'.  This type cannot represent\n * the special projective \"point at infinity\".\n *\/\ntype AffinePoint p =\n  { x : Z p\n  , y : Z p\n  }\n\n\/**\n * The type of points of an elliptic curve in (homogeneous)\n * projective coordinates.  The coefficients are taken from the\n * prime field 'Z p' with 'p > 3'. These points should be understood as\n * representatives of equivalence classes of points, where two representatives\n * 'S' and 'T' are equivalent iff one is a scalar multiple of the other. That\n * is, 'S' and 'T' are equivalent iff there exists some 'k' where\n * 'S.x == k*T.x \/\\ S.y == k*T.y \/\\ S.z == k*T.z'.  Finally, the\n * vector with all coordinates equal to 0 is excluded and does not\n * represent any point.\n *\n * Note that all the affine points are easily embedded into projective\n * coordinates by simply setting the `z` coordinate to 1, and the \"point at\n * infinity\" is represented by any point with 'z == 0'.  Further, for any\n * projective point with 'z != 0', we can compute the corresponding affine\n * point by simply multiplying the x and y coordinates by the inverse of z.\n *\/\ntype ProjectivePoint p =\n  { x : Z p\n  , y : Z p\n  , z : Z p\n  }\n\n\/**\n * 'ec_is_point_affine b S' checks that the supposed affine elliptic curve\n * point 'S' in fact lies on the curve defined by the curve parameter 'b'.  Here,\n * and throughout this module, we assume the curve parameter 'a' is equal to\n * '-3'.  Precisely, this function checks the following condition:\n *\n *     S.y^^2 == S.x^^3 - 3*S.x + b\n *\/\nec_is_point_affine : {p} (prime p, p > 3) => Z p -> AffinePoint p -> Bit\nec_is_point_affine b S = S.y^^2 == S.x^^3 - (3*S.x) + b\n\n\n\/**\n * 'ec_is_nonsingular' checks that the given curve parameter 'b' gives rise to\n * a non-singular elliptic curve, appropriate for use in ECC.\n *\n * Precisely, this checks that '4*a^^3 + 27*b^^2 != 0 mod p'.  Here, and\n * throughout this module, we assume 'a = -3'.\n *\/\nec_is_nonsingular : {p} (prime p, p > 3) => Z p -> Bit\nec_is_nonsingular b = (fromInteger 4) * a^^3 + (fromInteger 27) * b^^2 != 0\n  where a = -3 : Z p\n\n\/**\n * Returns true if the given point is the identity \"point at infinity.\"\n * This is true whenever the 'z' coordinate is 0, but one of the 'x' or\n * 'y' coordinates is nonzero.\n *\/\nec_is_identity : {p} (prime p, p > 3) => ProjectivePoint p -> Bit\nec_is_identity S = S.z == 0 \/\\ ~(S.x == 0 \/\\ S.y == 0)\n\n\/**\n * Test two projective points for equality, up to the equivalence relation\n * on projective points.\n *\/\nec_equal : {p} (prime p, p > 3) => ProjectivePoint p -> ProjectivePoint p -> Bit\nec_equal S T =\n  (S.z == 0 \/\\ T.z == 0) \\\/\n  (S.z != 0 \/\\ T.z != 0 \/\\ ec_affinify S == ec_affinify T)\n\n\/**\n * Compute a projective representative for the given affine point.\n *\/\nec_projectify : {p} (prime p, p > 3) => AffinePoint p -> ProjectivePoint p\nec_projectify R = { x = R.x, y = R.y, z = 1 }\n\n\/**\n * Compute the affine point corresponding to the given projective point.\n * This results in an error if the 'z' component of the given point is 0,\n * in which case there is no corresponding affine point.\n *\/\nec_affinify : {p} (prime p, p > 3) => ProjectivePoint p -> AffinePoint p\nec_affinify S =\n if S.z == 0 then error \"Cannot affinify the point at infinity\" else R\n    where\n      R = {x = lambda^^2 * S.x, y = lambda^^3 * S.y }\n      lambda = recip S.z\n\n\/**\n * Coerce an integer modulo 'p' to a bitvector. This will reduce the value\n * modulo '2^^a' if necessary.\n *\/\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = fromInteger (fromZ x)\n\n\/**\n * Coerce a bitvector value to an integer modulo 'p'.  This will\n * reduce the value modulo 'p' if necessary.\n *\/\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = fromInteger (toInteger x)\n\n\/**\n * Given a projective point 'S', compute '2S = S+S'.\n *\/\nprimitive ec_double : {p} (prime p, p > 3) =>\n  ProjectivePoint p -> ProjectivePoint p\n\n\/**\n * Given two projective points 'S' and 'T' where neither is the identity,\n * compute 'S+T'. If the points are not known to be distinct from the point\n * at infinity, use 'ec_add' instead.\n *\/\nprimitive ec_add_nonzero : {p} (prime p, p > 3) =>\n  ProjectivePoint p -> ProjectivePoint p -> ProjectivePoint p\n\n\/**\n * Given a projective point 'S', compute its negation, '-S'\n *\/\nec_negate : {p} (prime p, p > 3) => ProjectivePoint p -> ProjectivePoint p\nec_negate S = { x = S.x, y = -S.y, z = S.z }\n\n\/**\n * Given two projective points 'S' and 'T' compute 'S+T'.\n *\/\nec_add : {p} (prime p, p > 3) =>\n  ProjectivePoint p -> ProjectivePoint p -> ProjectivePoint p\nec_add S T =\n  if S.z == 0 then T\n   | T.z == 0 then S\n   else R\n where R = ec_add_nonzero S T\n\n\/**\n * Given two projective points 'S' and 'T' compute 'S-T'.\n *\/\nec_sub : {p} (prime p, p > 3) =>\n  ProjectivePoint p -> ProjectivePoint p -> ProjectivePoint p\nec_sub S T = ec_add S U\n where U = { x = T.x, y = -T.y, z = T.z }\n\n\/**\n * Given a scalar value 'k' and a projective point 'S', compute the\n * scalar multiplication 'kS'.\n *\/\nprimitive ec_mult : {p} (prime p, p > 3) =>\n  Z p -> ProjectivePoint p -> ProjectivePoint p\n\n\/**\n * Given a scalar value 'j' and a projective point 'S', and another scalar\n * value 'k' and point 'T', compute the \"twin\" scalar multiplication 'jS + kT'.\n *\/\nprimitive ec_twin_mult : {p} (prime p, p > 3) =>\n  Z p -> ProjectivePoint p -> Z p -> ProjectivePoint p -> ProjectivePoint p\n","variant":"hybrid","set":"holdout"}
