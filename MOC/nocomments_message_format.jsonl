{"filename":"cryptol\/examples\/splitAt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the following with explicit types and a verification: (1) a constant x as a 4-element sequence of 8-bit values containing 1, 2, 3, and 4 in order; (2) a constant y as the pair produced by splitting x at index 2 into two sequences, each of length 2 and element width 8; (3) constants a, b, c, and d as 8-bit values equal to the first and second elements of the first component of y, and the first and second elements of the second component of y, respectively (use zero-based indexing). Provide type signatures for x, y, a, b, c, and d that reflect these sizes. Also define a property that checks both that concatenating the two parts of y reconstructs x, and that a == 1, b == 2, c == 3, and d == 4. Do not include any implementations beyond these definitions and the property."},{"role":"assistant","content":"```cryptol\nx = [1,2,3,4] : [_][8]\n\ny = (splitAt x) : ([2][8],[2][8])\n\na = y.0 @ 0\nb = y.0 @ 1\nc = y.1 @ 0\nd = y.1 @ 1\n```"}]}
{"filename":"cryptol\/examples\/AE.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named AE that contains the following definitions and specifications: (1) A parameter section declaring abstract value types A and K, numeric types n, p, and tagAmount, with constraints that p and n are finite and n is at least tagAmount. Also declare the following module parameters with the given roles and shapes: a tweakable permutation over n-bit blocks keyed by K that consumes a record containing a nonce, an abstract state, and a 64-bit counter; a 64-bit cost increment; a block encryption transform that maps a record of one p\u00b7n-bit block and the running p\u00b7n-bit state to the next record of the same shape; a corresponding decryption transform; and a tag function that maps a key, a tweak record, and a p\u00b7n\u00b7p-length message stream to an n-bit tag. (2) Type synonyms: Node as a record of a work block and running state, WorkBlock as p\u00b7n bits, State as p\u00b7n bits, Tweak as a record of nonce [n], state A, and counter [64], Nonce as [n], and Int as [64]. (3) A function encrypt with type: for any finite m, takes a key, a nonce, an initial abstract state A, and a message of m blocks of size p\u00b7n, and returns m\u00b7(p\u00b7n) bits followed by tagAmount bits. Specify that it: splits the message into m blocks; iteratively applies the encryption transform to each block using a tweak whose counter is the running cost (starting at 1 and increased by the cost increment per block) and threading the p\u00b7n-bit state; concatenates the resulting per-block ciphertexts; derives the authentication tag by applying the tag function to the key, a tweak whose counter is one less than the final accumulated cost, and the final p\u00b7n-bit state; and returns ciphertext concatenated with the tag truncated to tagAmount bits. (4) Properties to check: output length matches the result type size; the ciphertext prefix equals the concatenation of per-block encryption results; the tag suffix equals the specified tag derivation."},{"role":"assistant","content":"```cryptol\nmodule AE where\n\nparameter\n  type A : *            type K : *            type n : #            type p : #            type tagAmount : #\n\n  type constraint (fin p, fin n, n >= tagAmount)\n\n    tweak_cipher : K -> { nonce : [n], state : A, z : [64] } -> [n] -> [n]\n\n    Cost : [64]\n\n  Enc : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Dec : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Tag : K -> { nonce : [n], state : A, z : [64] } -> [p*n] -> [n]\n\ntype Node       = { message : WorkBlock, state : State }\n\ntype WorkBlock  = [p*n]\n\ntype State      = [p*n]  \ntype Tweak      = { nonce : Nonce, state : A, z : Int }\ntype Nonce      = [n]\n\ntype Int = [64]\n\nencrypt :\n  {m} fin m => K -> Nonce -> A -> [m * (p * n)] -> [m * (p * n) + tagAmount]\nencrypt key nonce state inputMsg = encMsg # tag\n\n  where\n  encMsg = join rest.0.message\n\n  tag = take (Tag key (tweak (1 - final.1)) final.0.state)\n\n  final = steps ! 0\n\n  steps = [ ({ message = undefined, state = zero }, 1) ] # rest\n  rest  = [ (Enc key (tweak v) { message = m, state = prev.state }, v + Cost)\n          | (prev,v) <- steps\n          | m        <- chunks\n          ]\n\n  chunks : [m] [p * n]\n  chunks = split inputMsg\n\n  tweak : Int -> Tweak\n  tweak v = { nonce = nonce, state = state, z = v }\n```"}]}
{"filename":"cryptol\/examples\/xor_cipher.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define type signatures for encrypt and decrypt parameterized by a finite size a: each takes an 8-bit key and a sequence of a 8-bit values, returning a sequence of a 8-bit values. Implement encrypt by XORing each input byte with the key elementwise, and implement decrypt identically (bytewise XOR with the same key). Define a property named roundtrip that, for all finite a, any 8-bit key, and any sequence of a 8-bit values, asserts that applying decrypt with the key to the result of encrypt with the same key yields the original input. State the fin a constraint explicitly, keep all expressions total, and use elementwise operations over the sequence without introducing padding or state."},{"role":"assistant","content":"```cryptol\nencrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\nencrypt key plaintext = [pt ^ key | pt <- plaintext ]\n\ndecrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\ndecrypt key ciphertext = [ct ^ key | ct <- ciphertext ]\n\nproperty roundtrip k ip = decrypt k (encrypt k ip) == ip\n```"}]}
{"filename":"cryptol\/examples\/zero_weird.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) a polymorphic function named x with a single type parameter and no constraints, taking one argument of that type and returning a 16-bit sequence whose value is all zeros; implement x so it ignores its input. (2) a property named xprop that universally quantifies over the input and asserts that applying x to any value yields the 16-bit zero value. (3) a function named y that takes two arguments, the first a 12-bit sequence and the second a 4-bit sequence, and returns a 17-bit sequence whose value is all zeros; implement y so it ignores both inputs. (4) a property named yprop that universally quantifies over both inputs and asserts that applying y to any valid pair yields the 17-bit zero value. (5) two constants named t1 and t2 that are example applications: t1 is x applied to a literal argument, producing the 16-bit zero result; t2 is y applied to two literal arguments, producing the 17-bit zero result. Include precise type signatures for x and y, and ensure the properties are written using the Cryptol property keyword so they can be checked by a solver."},{"role":"assistant","content":"```cryptol\nx : {a}() => a -> [16]\nx v = zero v \n\nproperty xprop v = x v == 0\n\ny : [12] -> [4] -> [17]\ny a b = zero a b\n\nproperty yprop v w = y v w == 0\n\nt1 = x 13\nt2 = y 2 3\n```"}]}
{"filename":"cryptol\/examples\/builtin_lifting.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that demonstrates built-in lifting across sequences, tuples, and records by defining the following and proving the listed properties. Define x and y as two-bit words whose most-significant bit patterns are 10 and 01, respectively. Provide properties: p1 asserts x equals the two-bit numeral 2; p2 asserts x+y equals the two-bit numeral 3; p3 asserts x+y equals the two-bit pattern with both bits set. Define xx and yy as singleton sequences containing x and y, respectively; p4 asserts their elementwise sum is the singleton containing 3; p5 asserts the bitwise complement of xx equals yy. Define infinite arithmetic sequences xinf and yinf of two-bit words starting at 2 and 3, respectively; p6 asserts the first element of their pointwise sum equals the two-bit numeral 1; p7 asserts the first element of the bitwise complement of xinf equals the two-bit numeral 1. Define a record xrec with fields x and y, both two-bit words equal to 2, with an explicit record type; p8 asserts xrec added to itself three times equals xrec (fieldwise modular addition). Define a tuple whose first two components are the two-bit numeral 2 and whose third component is xrec; p9 asserts adding this tuple to itself three times yields the same tuple (componentwise lifting). Finally, p10 asserts that bitwise complement distributes over a record whose first field is a tuple of a 1-bit and a 2-bit word and whose second field is a three-element sequence of three-bit words, and that the complemented record matches the elementwise complements with explicit width annotations. Use property declarations for p1\u2013p10 and fully annotate widths and shapes to disambiguate types."},{"role":"assistant","content":"```cryptol\nx = [True,False]\ny = [False,True]\n\nproperty p1 = x == (2 : [2])\n\nproperty p2 = x + y == 3\nproperty p3 = x + y == [True,True]\n\nxx = [[True,False]]\nyy = [[False,True]]\n\nproperty p4 = xx + yy == [3]\n\nproperty p5 = ~ xx == yy\n\nxinf = [2 ... ]\nyinf = [3 ... ]\n\nproperty p6 = (xinf + yinf) @ (0 : [0]) == (1 : [2])\n\nproperty p7 = (~ xinf) @ (0 : [0]) == (1 : [2])\n\nxrec = { x = 2 : [2], y = 2 : [2] } : {x : [2], y : [2]}\n\nproperty p8 = xrec + xrec + xrec == xrec\n\nproperty p9 = (2,2,xrec) + (2,2,xrec) + (2,2,xrec) == (2:[2],2:[2],xrec) \n\nproperty p10 = (~ { x = (1,2), y = [3,4,5] }) == {x = (0:[1],1:[2]), y = [4, 3, 2] : [3][3] }\n```"}]}
{"filename":"cryptol\/examples\/inflist.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares four sequence constants and four properties. Define: (1) an infinite sequence a that repeats the value 1; (2) an infinite arithmetic sequence b determined by the first two elements 1 then 2 (unit step); (3) a finite inclusive range c from 1 to 5; and (4) a finite arithmetic range d that starts at 1, has next element 3, and ends at 9. Use appropriate numeric types for these sequences (0-based indexing is assumed). Then define properties t1, t2, t3, and t4 asserting, respectively, that the element at index 3 of a equals 1, the element at index 3 of b equals 1, the element at index 3 of c equals 4, and the element at index 3 of d equals 4. Ensure the properties are expressed as boolean equalities suitable for solver checking."},{"role":"assistant","content":"```cryptol\na = [1 ... ]\nb = [1,2 ... ]\nc = [1 .. 5]\nd = [1,3 .. 9]\n\nproperty t1 = a @ 3 == 1\nproperty t2 = b @ 3 == 1\nproperty t3 = c @ 3 == 4\nproperty t4 = d @ 3 == 4\n```"}]}
{"filename":"cryptol\/examples\/Karatsuba.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Karatsuba that contains the following definitions: kmult, make_atleast, splitmult, splitmult_correct_tiny, splitmult_correct_small, splitmult_correct_medium, splitmult_correct_large, and splitmult_correct_huge. Specify kmult as a polymorphic function over size parameters limb and n with constraints fin limb, fin n, limb >= 6, n >= 1; it takes two n-bit sequences and returns their 2n-bit product. It must use a conditional: when n is at least limb, first widen both operands to be at least limb bits by prefixing zeros and then call splitmult; otherwise, perform a direct multiplication on zero-extended operands. Specify make_atleast as a polymorphic helper over sizes n, m and element type a with constraints fin n, fin m, Zero a; it takes an m-length sequence and returns a max(n,m)-length sequence by prefixing zeros. Specify splitmult as Karatsuba multiplication over sizes limb and n with constraints fin limb, fin n, limb >= 6, n >= 6; split each operand at hi = n\/2 (low = n - hi), recursively compute products of high and low halves, compute the cross term via sum-of-halves multiplication minus the partial products, and recombine by appropriate zero-padding and concatenation to yield a 2n-bit result. Include property declarations asserting that, for operand widths 9, 11, 17, and 59 with limb 7, and width 511 with limb 63, the result of splitmult equals the product of the zero-extended operands. Provide precise type signatures with all size constraints and quantify variables as needed."},{"role":"assistant","content":"```cryptol\nmodule Karatsuba where\n\nkmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 1) => [n] -> [n] -> [2*n]\n\nkmult x y =\n if `n >= (`limb : [max (width limb) (width n)]) then\n   take (splitmult`{limb} (make_atleast`{limb} x) (make_atleast`{limb} y))\n else\n   (zero#x)*(zero#y)\n\nmake_atleast : {n, m, a} (fin n, fin m, Zero a) => [m]a -> [max n m]a\nmake_atleast x = zero#x\n\nsplitmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 6)\n         => [n] -> [n] -> [2*n]\n\nsplitmult x y = (ac # bd) + (zero # ad_bc # (zero:[low]))\n  where\n   type hi  = n\/2\n   type low = n - hi\n\n   (a,b) = splitAt`{hi} x\n   (c,d) = splitAt`{hi} y\n\n   ac : [2*hi]\n   ac = kmult`{limb,hi} a c\n\n   bd : [2*low]\n   bd = kmult`{limb,low} b d\n\n   a_b = (zext a) + (zext b)\n   c_d = (zext c) + (zext d)\n\n   ad_bc : [2*(low+1)]\n   ad_bc = (kmult`{limb,low+1} a_b c_d) - (zext ac) - (zext bd)\n\nproperty splitmult_correct_tiny (x:[9]) (y:[9]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_small (x:[11]) (y:[11]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_medium(x:[17]) (y:[17]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_large (x:[59]) (y:[59]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_huge (x:[511]) (y:[511]) =\n  zext x * zext y == splitmult`{limb=63} x y\n```"}]}
{"filename":"cryptol\/examples\/comp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) a constant x with an explicit type signature as a finite sequence of 4-tuples of fixed-width bitvectors, where each field\u2019s width is the minimal width sufficient for the values it ranges over; construct x using a parallel list comprehension where the left side enumerates all pairs from two finite ranges, the right side enumerates all pairs from two other finite ranges, the two sides are zipped elementwise (length equals the minimum of the two sides), and within each side the rightmost generator varies fastest; (2) properties t1, t2, and t3 that assert that the first, third, and fourth elements of x, respectively, equal the tuples produced by this construction at those positions; (3) a constant y built by a parallel comprehension where the left side enumerates all pairs from two finite ranges and the right side is an increasing arithmetic progression, with the zipped result truncated to the left side; ensure the third component of the tuples in y uses a small fixed width so its values wrap modulo its word size; and (4) property t4 that asserts that the fourth element of y matches the tuple produced at that position, including the wrapped third component. Provide any necessary type signatures and constraints, and ensure tuple fields are not implicitly widened."},{"role":"assistant","content":"```cryptol\nx : [_]([2],[3],[3],[4])\nx = [(a,b,c,d) | a <- [1,2], b <- [3,4] | c <- [5,6], d <- [7,8,9] ]\n\nproperty t1 = x @ 0 == (1,3,5,7)\nproperty t2 = x @ 2 == (2,3,5,9)\nproperty t3 = x @ 3 == (2,4,6,7)\n\ny = [(a,b,c) | a <- [1,2,3], b <- [1,2] | c <- [1 ... ] ]\n\nproperty t4 = y @ 3 == (2,2,0)\n```"}]}
{"filename":"cryptol\/examples\/mini.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that reproduces the following definitions and types: (1) a function named id with type 32-bit word to 32-bit word, implemented by a helper recursive function that returns zero when given zero and otherwise returns one plus its result on the predecessor, using modular 32-bit arithmetic; (2) an infinite increasing stream of 8-bit words starting at one; (3) a record named rc with two 8-bit fields x and y set to specific literals, and a constant that equals the x field; (4) a 4-tuple of four 8-bit literals and a constant that equals its third element; (5) a constant defined via a local binding to an 8-bit literal; (6) a polymorphic function named gf28Add with a size parameter n and a fin n constraint that takes a sequence of n 8-bit words and returns an 8-bit word computed as the head of a running XOR prefix-sum stream that begins with zero and is formed by zipping the input with the previously computed prefix values; also define a constant produced by applying this function to a two-element 8-bit sequence; (7) a function named sum with type from a sequence of 8-bit words to a sequence of 8-bit words that zips its input with the fixed sequence [1,2,3,4] and returns their elementwise 8-bit sums. Provide explicit type signatures for id, gf28Add (with its constraint), and sum, and ensure all literals and field\/tuple selections match these behaviors. Do not include proofs; just the definitions with correct typing and semantics."},{"role":"assistant","content":"```cryptol\nid : [32] -> [32]\nid x = rec x\n  where rec k = if (k == 0) then 0 else 1 + rec (k + (-1))\n\ninflist = [1 ... ] : [_][8]\n\nrc = {x = 3 : [8], y = 5 : [8]}\n\nmy_true = rc.x\n\ntup = (1 : [8], 2 : [8], 3 : [8], 4 : [8])\n\nmy_3 = tup.2\n\nsup = y where y = 3 : [8]\n\ngf28Add : {n} (fin n) => [n][8] -> [8]\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\ngex = gf28Add [1,2]\n\nsum : [_][8] -> [_][8]\nsum x = rec\n  where rec = [ p + q | p <- x | q <- [1,2,3,4] ]\n```"}]}
{"filename":"cryptol\/examples\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Test that imports Cipher and contains the following definitions: evktest, evttest, ekatest, dvktest, dvttest, dkatest. For each function, provide a type signature quantified over size variables ks, bs, n with the constraint that bs is finite. Each returns a sequence of length n of pairs (a bs-bit value and a Bit flag). The Bit flag indicates whether the computed result equals the provided expected value. Specify inputs and behavior precisely: (1) evktest takes a cipher instance, a length\u2011n sequence of (key: ks bits, expected ciphertext: bs bits) pairs, and a fixed plaintext (bs bits); for each pair, encrypt the fixed plaintext under the key and pair the produced ciphertext with its equality against the expected ciphertext. (2) evttest takes a cipher instance, a fixed key (ks bits), and a length\u2011n sequence of (plaintext: bs bits, expected ciphertext: bs bits) pairs; for each pair, encrypt the plaintext under the fixed key and compare to the expected ciphertext. (3) ekatest takes a cipher instance and a length\u2011n sequence of (key: ks bits, plaintext: bs bits, expected ciphertext: bs bits) triples; for each triple, encrypt and compare to the expected ciphertext. (4) dvktest takes a cipher instance, a length\u2011n sequence of (key: ks bits, ciphertext: bs bits) pairs, and a fixed plaintext (bs bits); for each pair, decrypt the ciphertext under the key and compare to the fixed plaintext. (5) dvttest takes a cipher instance, a fixed key (ks bits), and a length\u2011n sequence of (plaintext: bs bits, ciphertext: bs bits) pairs; for each pair, decrypt the ciphertext under the fixed key and compare to the plaintext. (6) dkatest takes a cipher instance and a length\u2011n sequence of (key: ks bits, plaintext: bs bits, ciphertext: bs bits) triples; for each triple, decrypt and compare to the plaintext."},{"role":"assistant","content":"```cryptol\nmodule Test where\nimport Cipher\n\nevktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\nevktest (cipher, vkeysCTs, PT) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, CT) <- vkeysCTs ]\n\nevttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\nevttest (cipher, Key, vtextPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (PT, CT) <- vtextPCTs ]\n\nekatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\nekatest (cipher, kaKPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, PT, CT) <- kaKPCTs ]\n\ndvktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\ndvktest (cipher, vkeysCTs, PT) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, CT) <- vkeysCTs ]\n\ndvttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\ndvttest (cipher, Key, vtextPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (PT, CT) <- vtextPCTs ]\n\ndkatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\ndkatest (cipher, kaKPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, PT, CT) <- kaKPCTs ]\n```"}]}
{"filename":"cryptol\/examples\/builtins.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define constants t, f, times, div, mod, exp, lgtest, p, m, neg, and comp, each explicitly typed as an 8-bit sequence. Specify: t as the value chosen by a conditional with a true condition selecting 5; f as the value from a conditional with a false condition selecting 5 over 3; times as the product of 5, 1, 2, and 3; div as 30 divided successively by 1, then 2, then 3 using integer division; mod as 205 modulo 10; exp as 2 raised to the 7th power using the integer exponentiation operator; lgtest as the base-2 logarithm (integer result) of 128 using the built-in log2 function; p as the sum of 3 and 2; m as 8 minus 3; neg as the arithmetic double negation of 5; comp as the bitwise complement of 250 evaluated within 8-bit width. Ensure all arithmetic and bitwise operations are performed in the 8-bit domain and include type annotations for each constant."},{"role":"assistant","content":"```cryptol\nt : [8]\nt = if True then 5 else 4 \nf : [8]\nf = if False then 3 else 5 \ntimes : [8]\ntimes = 5 * 1 * 2 * 3 \ndiv : [8]\ndiv = (((30\/1)\/2)\/3) \nmod : [8]\nmod = 205%10 \nexp : [8]\nexp = 2^^7 \nlgtest : [8]\nlgtest = lg2 128 \np : [8]\np = 3+2 \nm : [8]\nm = 8-3 \nneg : [8]\nneg = -(-5) \ncomp : [8]\ncomp = ~250\n```"}]}
{"filename":"cryptol\/examples\/props.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) defines two 2-bit words, one with the most-significant bit set and the least-significant bit clear, and the other with the most-significant bit clear and the least-significant bit set; defines a third constant as their modular sum in the 2-bit word domain; (2) defines a property named p1 that asserts this sum equals the integer value 3 when represented as a 2-bit word; (3) defines two one-element sequences whose sole elements are the two 2-bit words above, and defines a third one-element sequence as their pointwise (element-wise) sum; (4) defines a polymorphic function t with an explicit type signature universally quantified over a finite natural a, taking a word of length 3\u00b7a and returning a square matrix of bits of size (3\u00b7a) by (3\u00b7a); the function must ignore its input and return an all-zero matrix of the specified size. Clearly specify all types, including that the 2-bit quantities are words of bits, the one-element sequences are sequences of 2-bit words, and the matrix result is a nested sequence. Use the Cryptol property mechanism for p1 and modular arithmetic semantics for word addition."},{"role":"assistant","content":"```cryptol\nx = [True, False]\ny = [False, True]\nz = x + y\n\nproperty p1 = z == 3\n\nxx = [[True,False]]\nyy = [[False, True]]\nzz = xx + yy\n\nt : {a} [a*3] -> [a*3][a*3]\nt d = zero\n```"}]}
{"filename":"cryptol\/examples\/demote.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol specification that introduces: (1) a polymorphic function named x with a numeric type parameter a constrained to be finite; x takes a bitvector of length a and returns a bitvector of length (2*a)+3. The implementation must ignore its input and produce the constant result of adding zero and one, sized to the output width. Provide the full type signature and definition for x. (2) a constant named y defined by applying x to the 3-bit numeric literal whose value is two; give y an explicit type consistent with the instantiated width computed from a = 3. Ensure all size arithmetic and type constraints are explicit and checkable."},{"role":"assistant","content":"```cryptol\nx : {a}(fin a) => [a] -> [(a*2)+3]\nx v = 0 + 1\n\ny = x (2 : [3])\n```"}]}
{"filename":"cryptol\/examples\/append.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares two finite sequences of 8-bit words with explicit type annotations and concrete literal contents, declares a third sequence as the append of the first two, and then declares four additional constants selecting elements from the concatenated sequence at indices 0, 2, 10, and 11. Provide type signatures for all top-level definitions. For the element at index 0, demonstrate indexing using an explicitly typed 1-bit zero; for the others, use natural-number indices. Ensure the index expressions have the correct bit widths implied by the concatenated length so the specification typechecks without defaulting or ambiguity. Clearly state any necessary finiteness and numeric constraints."},{"role":"assistant","content":"```cryptol\nx : [_][8]\nx = [1,2,3,4,5,19,12,38,5,3]\n\ny : [_][8]\ny = [19,3,27,5,12]\n\nz = x # y\n\nm = z @ (0 : [1]) w = z @ 2 \nt = z @ 10 v = z @ 11\n```"}]}
{"filename":"cryptol\/examples\/split.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define constants and properties as follows: create a constant sequence of four 8-bit words holding the values 1, 2, 3, and 4; create a second constant by applying the built-in splitting operation to partition that sequence into two chunks of length two, producing a 2-by-2 nested sequence of 8-bit words; define four constants that extract the elements of the nested sequence by first selecting the outer index (0 or 1) and then the inner index (0 or 1), yielding the first, second, third, and fourth 8-bit values, respectively. Provide explicit type annotations so the first constant is a length-4 sequence of 8-bit words, the split result is a 2-by-2 nested sequence of 8-bit words, and each extracted element is an 8-bit word. Define properties that assert the extracted elements equal 1, 2, 3, and 4 in order, matching the original sequence positions."},{"role":"assistant","content":"```cryptol\nx = [1,2,3,4] : [_][8]\n\ny = (split x) : [2][2][8]\n\na = (y@0) @ 0\nb = (y@0) @ 1\nc = (y@1) @ 0\nd = (y@1) @ 1\n```"}]}
{"filename":"cryptol\/lib\/Array.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Array that contains the following definitions: a primitive two-parameter type constructor representing an indexed array; primitive functions to construct a constant-filled array, read an element by index, write an element at an index producing a new array, test equality of two fixed-size arrays, copy a contiguous range from a source array to a destination array, set a contiguous range in an array to a single value, and test equality of two ranges from two arrays. Provide precise polymorphic type signatures for each, using bitvector index types of width n for fixed-size arrays and appropriate constraints ensuring n is finite and fits within the index type, and that the index type supports integral addition. Implement two total functions: one that returns a length-n sequence of elements starting at a given index by reading successive indices offset by 0..n-1, and one that updates an array with a length-n sequence of values starting at a given index by iteratively applying single-index updates from left to right. Add properties that: (1) the range-read function\u2019s i-th element equals a single read at the base index plus i; (2) the range-update result equals the left-to-right fold of single-index updates at successive offsets with corresponding values; (3) array equality is equivalent to pointwise equality over all indices; (4) range copy equals reading a slice from the source and writing it into the destination at the given start indices for the given length; (5) range set equals writing the same value across the specified contiguous indices; and (6) range equality equals pointwise equality of the corresponding slices. Use universally quantified variables for element type, index type, and length, and clearly state all required class constraints. Do not provide implementations for the primitives beyond their type signatures."},{"role":"assistant","content":"```cryptol\nmodule Array where\n\nprimitive type Array : * -> * -> *\n\nprimitive arrayConstant : {a, b} b -> (Array a b)\nprimitive arrayLookup : {a, b} (Array a b) -> a -> b\nprimitive arrayUpdate : {a, b} (Array a b) -> a -> b -> (Array a b)\nprimitive arrayEq : {n, a} (Array [n] a) -> (Array [n] a) -> Bool\n\nprimitive arrayCopy : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> (Array [n] a)\n\nprimitive arraySet : {n, a} (Array [n] a) -> [n] -> a -> [n] -> (Array [n] a)\n\nprimitive arrayRangeEqual : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> Bool\n\narrayRangeLookup : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b\narrayRangeLookup arr idx = res\n  where\n    res @ i = arrayLookup arr (idx + i)\n\narrayRangeUpdate : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b -> (Array a b)\narrayRangeUpdate arr idx vals = arrs ! 0\n  where\n    arrs = [arr] # [ arrayUpdate acc (idx + i) val | acc <- arrs | i <- [0 ..< n] | val <- vals ]\n```"}]}
{"filename":"cryptol\/lib\/SuiteB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named SuiteB that contains the following definitions, types, and constraints, preserving names and arities: (1) Type synonyms for AES key-size parameters representing the number of 32-bit words for 128-, 192-, and 256-bit keys; a type alias for a 4-by-32-bit AES round key; record types for parameterized encrypt\/decrypt key schedules with fields for initial key, an array of k+5 round keys, and a final key. (2) Public functions that produce encryption\/decryption schedules and paired schedules for each supported key size (128, 192, 256) by delegating to generic expansion helpers. (3) A block encryption function over 128-bit blocks parameterized by k that iteratively applies a primitive AES encryption round across the round keys starting from the initial key addition, then applies a primitive final round and a final key addition; similarly, a block decryption function that uses the corresponding decrypt primitives and round-key order. (4) Private helpers: a generic encrypt-schedule expansion from a k\u00b732-bit key using a primitive key expansion and grouping into round keys; a conversion from encrypt to decrypt schedule that reverses round keys and applies inverse mix-columns; a generic decrypt-schedule expansion and a pair-producing expansion. Include constraints that k is finite and between 4 and 8 inclusive. (5) Primitive declarations for AES round, final round, inverse mix-columns, and key expansion with appropriate types over 4\u00d732-bit states and k-parameterized key material. (6) Public SHA-2 hash functions producing 224-, 256-, 384-, and 512-bit digests that pad an arbitrary-length bitvector, split into 16-word blocks of 32 or 64 bits, and invoke corresponding primitive processors. (7) Private SHA-2 helpers for block size, number of blocks, padded size, a padding function that appends a single \u20181\u2019 bit, zeros, and the length field, a block-splitting function, and primitive processors with sizes matching their digests. Ensure all type signatures, size arithmetic, and constraints match these descriptions."},{"role":"assistant","content":"```cryptol\nmodule SuiteB where\n\ntype AES128 = 4\n\ntype AES192 = 6\n\ntype AES256 = 8\n\ntype AESRoundKey = [4][32]\n\ntype AESEncryptKeySchedule k =\n  { aesEncInitialKey : AESRoundKey\n  , aesEncRoundKeys  : [k+5]AESRoundKey\n  , aesEncFinalKey   : AESRoundKey\n  }\n\ntype AESDecryptKeySchedule k =\n  { aesDecInitialKey : AESRoundKey\n  , aesDecRoundKeys  : [k+5]AESRoundKey\n  , aesDecFinalKey   : AESRoundKey\n  }\n\naes128EncryptSchedule : [128] -> AESEncryptKeySchedule AES128\naes128EncryptSchedule = aesExpandEncryptSchedule\n\naes128DecryptSchedule : [128] -> AESDecryptKeySchedule AES128\naes128DecryptSchedule = aesExpandDecryptSchedule\n\naes128Schedules : [128] -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\naes128Schedules = aesExpandSchedules\n\naes192EncryptSchedule : [192] -> AESEncryptKeySchedule AES192\naes192EncryptSchedule = aesExpandEncryptSchedule\n\naes192DecryptSchedule : [192] -> AESDecryptKeySchedule AES192\naes192DecryptSchedule = aesExpandDecryptSchedule\n\naes192Schedules : [192] -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\naes192Schedules = aesExpandSchedules\n\naes256EncryptSchedule : [256] -> AESEncryptKeySchedule AES256\naes256EncryptSchedule = aesExpandEncryptSchedule\n\naes256DecryptSchedule : [256] -> AESDecryptKeySchedule AES256\naes256DecryptSchedule = aesExpandDecryptSchedule\n\naes256Schedules : [256] -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\naes256Schedules = aesExpandSchedules\n\naesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]\naesEncryptBlock schedule plaintext = rnf (join final)\n  where\n  final = (AESEncFinalRound (rds!0)) ^ schedule.aesEncFinalKey\n\n  rds = [ schedule.aesEncInitialKey ^ split plaintext ] #\n        [ AESEncRound r ^ rdk\n        | rdk <- schedule.aesEncRoundKeys\n        | r   <- rds\n        ]\n\naesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]\naesDecryptBlock schedule cyphertext = rnf (join final)\n  where\n  final = (AESDecFinalRound (rds!0)) ^ schedule.aesDecFinalKey\n\n  rds = [ split cyphertext ^ schedule.aesDecInitialKey ] #\n        [ AESDecRound r ^ rdk\n        | rdk <- schedule.aesDecRoundKeys\n        | r   <- rds\n        ]\n\nprivate\n    aesExpandEncryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESEncryptKeySchedule k\n    aesExpandEncryptSchedule key = rnf\n         { aesEncInitialKey = ks @  0\n         , aesEncRoundKeys  = ks @@ [ 1 .. k+5 ]\n         , aesEncFinalKey   = ks @  `(k+6)\n         }\n      where\n      ks : [k+7]AESRoundKey\n      ks = groupBy`{4} (AESKeyExpand`{k} (split key))\n\n    aesEncToDecSchedule : {k} (fin k) => AESEncryptKeySchedule k -> AESDecryptKeySchedule k\n    aesEncToDecSchedule enc = rnf\n       { aesDecInitialKey = enc.aesEncFinalKey\n       , aesDecRoundKeys  = map AESInvMixColumns (reverse (enc.aesEncRoundKeys))\n       , aesDecFinalKey   = enc.aesEncInitialKey\n       }\n\n    aesExpandDecryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESDecryptKeySchedule k\n    aesExpandDecryptSchedule key = aesEncToDecSchedule (aesExpandEncryptSchedule key)\n\n    aesExpandSchedules : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> (AESEncryptKeySchedule k, AESDecryptKeySchedule k)\n    aesExpandSchedules key = (encS, aesEncToDecSchedule encS)\n      where encS = aesExpandEncryptSchedule key\n\n    primitive AESEncRound      : [4][32] -> [4][32]\n    primitive AESEncFinalRound : [4][32] -> [4][32]\n    primitive AESDecRound      : [4][32] -> [4][32]\n    primitive AESDecFinalRound : [4][32] -> [4][32]\n    primitive AESInvMixColumns : [4][32] -> [4][32]\n    primitive AESKeyExpand     : {k} (fin k, k >= 4, 8 >= k) => [k][32] -> [4*(k+7)][32]\n\nsha224 : {L} (fin L) => [L] -> [224]\nsha224 msg = join (processSHA2_224 (sha2blocks`{32} msg))\n\nsha256 : {L} (fin L) => [L] -> [256]\nsha256 msg = join (processSHA2_256 (sha2blocks`{32} msg))\n\nsha384 : {L} (fin L) => [L] -> [384]\nsha384 msg = join (processSHA2_384 (sha2blocks`{64} msg))\n\nsha512 : {L} (fin L) => [L] -> [512]\nsha512 msg = join (processSHA2_512 (sha2blocks`{64} msg))\n\nprivate\n    type sha2_block_size w = 16 * w\n    type sha2_num_blocks w L = (L+1+2*w) \/^ sha2_block_size w\n    type sha2_padded_size w L = sha2_num_blocks w L * sha2_block_size w\n\n    sha2pad : {w, L} (fin w, fin L, w >= 1) => [L] -> [sha2_padded_size w L]\n    sha2pad M = rnf (M # 0b1 # zero # ((fromInteger `L) : [2*w]))\n\n    sha2blocks : {w, L} (fin w, fin L, w >= 1) =>\n      [L] -> [sha2_num_blocks w L][16][w]\n    sha2blocks msg = [ split x | x <- split (sha2pad`{w} msg) ]\n\n    primitive processSHA2_224 : {n} (fin n) => [n][16][32] -> [7][32]\n\n    primitive processSHA2_256 : {n} (fin n) => [n][16][32] -> [8][32]\n\n    primitive processSHA2_384 : {n} (fin n) => [n][16][64] -> [6][64]\n\n    primitive processSHA2_512 : {n} (fin n) => [n][16][64] -> [8][64]\n```"}]}
{"filename":"cryptol\/lib\/Float.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Float that contains the following definitions: (1) a primitive proposition ValidFloat taking two numeric kinds (exponent size and precision size); (2) a type constructor Float parameterized by exponent and precision, available only when ValidFloat holds; (3) type aliases for common formats with specific exponent\/precision sizes (16, 32, 64, 128, 256); (4) a 3-bit type RoundingMode and five constants for rounding to nearest-even, nearest-away, toward +\u221e, toward \u2212\u221e, and toward zero, each with a short alias, mapped respectively to 0, 1, 2, 3, and 4; (5) primitive values for NaN and +\u221e; derived values \u2212\u221e as the negation of +\u221e, +0 as zero, and \u22120 as the negation of +0; (6) primitives to convert between a bit vector of length exponent+precision and Float, both directions; (7) a primitive float equivalence operator returning Bool, declared infix with precedence 20; (8) primitive predicates to detect NaN, infinity, zero, negative sign, normal, and subnormal; a derived predicate finite defined as not (NaN or infinity); (9) primitive arithmetic operations add, subtract, multiply, divide, and fused multiply-add, each taking a rounding mode; (10) primitive absolute value; (11) primitive square root taking a rounding mode; (12) conversions to Rational and from Rational (the latter taking a rounding mode). All functions must be polymorphic in exponent and precision and require the ValidFloat constraint; use bit-vector lengths computed as exponent+precision. Do not implement bodies for primitives; provide exact type signatures and constants."},{"role":"assistant","content":"```cryptol\nmodule Float where\n\nprimitive type ValidFloat : # -> # -> Prop\n\nprimitive type { exponent : #, precision : #}\n  ValidFloat exponent precision => Float exponent precision : *\n\ntype Float16  = Float 5 11\n\ntype Float32  = Float 8 24\n\ntype Float64  = Float 11 53\n\ntype Float128 = Float 15 113\n\ntype Float256 = Float 19 237\n\ntype RoundingMode = [3]\n\nroundNearestEven, rne : RoundingMode\nroundNearestEven = 0\nrne              = roundNearestEven\n\nroundNearestAway, rna : RoundingMode\nroundNearestAway  = 1\nrna               = roundNearestAway\n\nroundPositive, rtp : RoundingMode\nroundPositive     = 2\nrtp               = roundPositive\n\nroundNegative, rtn : RoundingMode\nroundNegative     = 3\nrtn               = roundNegative\n\nroundZero, rtz : RoundingMode\nroundZero         = 4\nrtz               = roundZero\n\nprimitive\n  fpNaN : {e,p} ValidFloat e p => Float e p\n\nprimitive\n  fpPosInf : {e,p} ValidFloat e p => Float e p\n\nfpNegInf : {e,p} ValidFloat e p => Float e p\nfpNegInf = - fpPosInf\n\nfpPosZero : {e,p} ValidFloat e p => Float e p\nfpPosZero = zero\n\nfpNegZero : {e,p} ValidFloat e p => Float e p\nfpNegZero = - fpPosZero\n\nprimitive\n  fpFromBits : {e,p} ValidFloat e p => [e + p] -> Float e p\n\nprimitive\n  fpToBits : {e,p} ValidFloat e p => Float e p -> [e + p]\n\nprimitive\n  (=.=) : {e,p} ValidFloat e p => Float e p -> Float e p -> Bool\n\ninfix 20 =.=\n\nprimitive fpIsNaN : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsInf : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsZero : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsNeg : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsNormal : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsSubnormal : {e,p} ValidFloat e p => Float e p -> Bool\n\nfpIsFinite : {e,p} ValidFloat e p => Float e p -> Bool\nfpIsFinite f = ~ (fpIsNaN f \\\/ fpIsInf f )\n\nprimitive\n  fpAdd : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpSub : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpMul : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpDiv : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpFMA : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpAbs : {e,p} ValidFloat e p =>\n    Float e p -> Float e p\n\nprimitive\n  fpSqrt : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p\n\nprimitive\n  fpToRational : {e,p} ValidFloat e p =>\n    Float e p -> Rational\n\nprimitive\n  fpFromRational : {e,p} ValidFloat e p =>\n    RoundingMode -> Rational -> Float e p\n```"}]}
{"filename":"cryptol\/lib\/Cryptol.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Cryptol that contains the following definitions, with precise type signatures and constraints over type-level naturals and classes: (1) Operator fixities and precedences for logical, comparison, arithmetic, bit-shift\/rotate, indexing, and concatenation operators. (2) Primitive type-level and value-level entities: bits, unbounded integer, bounded signed integers parameterized by a positive finite width, rational, the infinite length kind, type-level predicates (type equality\/inequality, finiteness, primality, ordering), and type-level arithmetic\/combinators (+, *, -, \/, %, exponentiation, width, min, max, division\/modulo variants, and a length computation for arithmetic progressions). Provide constraint synonyms for natural comparisons. (3) Type synonyms for booleans, words, characters, strings, and a logarithm-of-2 width helper at the type level. (4) Literal predicate classes for numbers and bounded ranges, with constructors\/demoters for literals; finite range constructors for increasing\/decreasing and stride-based sequences, plus from-then-to with a length constraint. (5) Numeric and logical classes (zero, logic, ring, integral, field, rounding, equality, comparison, signed comparison) and their associated operations with required constraints. (6) Algebraic enums for optional and result values; boolean constants and connectives including implication; helpers for absolute value, min\/max, signed\/unsigned comparisons, and pointwise function equality\/inequality. (7) Bitvector\/sequence utilities: carry\/overflow checks, zero\/sign extension, shifts\/rotates by integer indices, integer conversions (signed and Z-based), rational construction, concatenation\/splitting, reversing\/transposition, slicing, head\/tail\/last, grouping, indexing (random and bounds-checked) and bulk\/single updates, generator, sorting (by comparator and default), polynomial arithmetic over bit polynomials, parallel map, strictness utilities, error\/undefined, assertions, randomness, tracing. (8) Higher-order utilities: map, folds (left\/right, strict and non-strict), sum\/product, scans, repeat, membership, zipping, currying\/uncurrying, iteration, predicates all\/any\/and\/or. Ensure all parameters and guards match finiteness and ordering bounds as described."},{"role":"assistant","content":"```cryptol\nmodule Cryptol where\n\ninfixr  5 ==>\ninfixr 10 \\\/\ninfixr 15 \/\\\ninfix  20 ==, ===, !=, !==\ninfix  30 >, >=, <, <=, <$, >$, <=$, >=$\ninfixr 40 ||\ninfixl 45 ^\ninfixr 50 &&\ninfixr 60 #\ninfixl 70 <<, <<<, >>, >>>, >>$\ninfixl 80 +, -\ninfixl 90 *, \/, %, \/$, %$, %^, \/^\ninfixr 95 ^^\ninfixl 100 @, @@, !, !!\n\nprimitive type Bit : *\n\nprimitive type Integer : *\n\nprimitive type {n : #} (fin n, n >= 1) => Z n : *\n\nprimitive type Rational : *\n\ntype Bool = Bit\ntype Word n = [n]\ntype Char = [8]\ntype String n = [n]Char\n\nprimitive type inf : #\n\nprimitive type (==) : # -> # -> Prop\n\nprimitive type (!=) : # -> # -> Prop\n\nprimitive type (>=) : # -> # -> Prop\n\nprimitive type fin : # -> Prop\n\nprimitive type prime : # -> Prop\n\nprimitive type (+) : # -> # -> #\n\nprimitive type (*) : # -> # -> #\n\nprimitive type\n  {m : #, n : # }\n  (fin n, m >= n) =>\n  m - n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin m, n >= 1) =>\n  m \/ n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin m, n >= 1) =>\n  m % n : #\n\nprimitive type (^^) : # -> # -> #\n\nprimitive type width : # -> #\n\ntype lg2 n = width (max n 1 - 1)\n\nprimitive type min : # -> # -> #\n\nprimitive type max : # -> # -> #\n\nprimitive type\n  { m : #, n : # }\n  (fin n, n >= 1) =>\n  m \/^ n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin n, n >= 1) =>\n  m %^ n : #\n\nprimitive type\n  { start : #, next : #, last : # }\n  (fin start, fin next, fin last, start != next) =>\n  lengthFromThenTo start next last : #\n\ntype constraint i <= j = (j >= i)\n\ntype constraint i > j = i >= j + 1\n\ntype constraint i < j = j >= i + 1\n\nprimitive type Literal : # -> * -> Prop\n\nprimitive type LiteralLessThan : # -> * -> Prop\n\nprimitive number : {val, rep} Literal val rep => rep\n\ndemote : {val, rep} Literal val rep => rep\ndemote = number`{val}\n\nlength : {n, a, b} (fin n, Literal n b) => [n]a -> b\nlength _ = `n\n\nprimitive fromTo : {first, last, a}\n  (fin last, last >= first, Literal last a) =>\n  [1 + (last - first)]a\n\nprimitive fromToLessThan :\n  {first, bound, a} (fin first, bound >= first, LiteralLessThan bound a) =>\n  [bound - first]a\n\nprimitive fromToBy : {first, last, stride, a}\n  (fin last, fin stride, stride >= 1, last >= first, Literal last a) =>\n  [1 + (last - first)\/stride]a\n\nprimitive fromToByLessThan : {first, bound, stride, a}\n  (fin first, fin stride, stride >= 1, bound >= first, LiteralLessThan bound a) =>\n  [(bound - first)\/^stride]a\n\nprimitive fromToDownBy : {first, last, stride, a}\n  (fin first, fin stride, stride >= 1, first >= last, Literal first a) =>\n  [1 + (first - last)\/stride]a\n\nprimitive fromToDownByGreaterThan : {first, bound, stride, a}\n  (fin first, fin stride, stride >= 1, first >= bound, Literal first a) =>\n  [(first - bound)\/^stride]a\n\nprimitive fromThenTo : {first, next, last, a, len}\n                       ( fin first, fin next, fin last\n                       , Literal first a, Literal next a, Literal last a\n                       , first != next\n                       , lengthFromThenTo first next last == len) => [len]a\n\nprimitive type FLiteral : # -> # -> # -> * -> Prop\n\nprimitive\n  fraction : { m, n, r, a } FLiteral m n r a => a\n\nprimitive type Zero : * -> Prop\n\nprimitive zero : {a} (Zero a) => a\n\nprimitive type Logic : * -> Prop\n\nprimitive (&&) : {a} (Logic a) => a -> a -> a\n\nprimitive (||) : {a} (Logic a) => a -> a -> a\n\nprimitive (^) : {a} (Logic a) => a -> a -> a\n\nprimitive complement : {a} (Logic a) => a -> a\n\nprimitive type Ring : * -> Prop\n\nprimitive fromInteger : {a} (Ring a) => Integer -> a\n\nprimitive (+) : {a} (Ring a) => a -> a -> a\n\nprimitive (-) : {a} (Ring a) => a -> a -> a\n\nprimitive (*) : {a} (Ring a) => a -> a -> a\n\nprimitive negate : {a} (Ring a) => a -> a\n\nprimitive type Integral : * -> Prop\n\nprimitive (\/) : {a} (Integral a) => a -> a -> a\n\nprimitive (%) : {a} (Integral a) => a -> a -> a\n\nprimitive toInteger : {a} (Integral a) => a -> Integer\n\nprimitive (^^) : {a, e} (Ring a, Integral e) => a -> e -> a\n\nprimitive infFrom : {a} (Integral a) => a -> [inf]a\n\nprimitive infFromThen : {a} (Integral a) => a -> a -> [inf]a\n\nprimitive type Field : * -> Prop\n\nprimitive recip : {a} (Field a) => a -> a\n\nprimitive (\/.) : {a} (Field a) => a -> a -> a\n\nprimitive type Round : * -> Prop\n\nprimitive ceiling : {a} (Round a) => a -> Integer\n\nprimitive floor : {a} (Round a) => a -> Integer\n\nprimitive trunc : {a} (Round a) => a -> Integer\n\nprimitive roundAway : {a} (Round a) => a -> Integer\n\nprimitive roundToEven : {a} (Round a) => a -> Integer\n\nprimitive type Eq : * -> Prop\n\nprimitive (==) : {a} (Eq a) => a -> a -> Bit\n\nprimitive (!=) : {a} (Eq a) => a -> a -> Bit\n\n(===) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\nf === g = \\ x -> f x == g x\n\n(!==) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\nf !== g = \\x -> f x != g x\n\nprimitive type Cmp : * -> Prop\n\nprimitive (<) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (>) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (<=) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (>=) : {a} (Cmp a) => a -> a -> Bit\n\nmin : {a} (Cmp a) => a -> a -> a\nmin x y = if x < y then x else y\n\nmax : {a} (Cmp a) => a -> a -> a\nmax x y = if x > y then x else y\n\nabs : {a} (Cmp a, Ring a) => a -> a\nabs x = if x < fromInteger 0 then negate x else x\n\nprimitive type SignedCmp : * -> Prop\n\nprimitive (<$) : {a} (SignedCmp a) => a -> a -> Bit\n\n(>$) : {a} (SignedCmp a) => a -> a -> Bit\nx >$ y = y <$ x\n\n(<=$) : {a} (SignedCmp a) => a -> a -> Bit\nx <=$ y = ~(y <$ x)\n\n(>=$) : {a} (SignedCmp a) => a -> a -> Bit\nx >=$ y = ~(x <$ y)\n\nenum Option a = None | Some a\n\nenum Result t e = Ok t | Err e\n\nprimitive True  : Bit\n\nprimitive False : Bit\n\n(\/\\) : Bit -> Bit -> Bit\nx \/\\ y = if x then y else False\n\n(\\\/) : Bit -> Bit -> Bit\nx \\\/ y = if x then True else y\n\n(==>) : Bit -> Bit -> Bit\na ==> b = if a then b else True\n\nprimitive (\/$) : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\n\nprimitive (%$) : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\n\ncarry : {n} (fin n) => [n] -> [n] -> Bit\ncarry x y = (x + y) < x\n\nscarry : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nscarry x y = (sx == sy) && (sx != sz)\n  where\n    z  = x + y\n    sx = head x\n    sy = head y\n    sz = head z\n\nsborrow : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsborrow x y = ( x <$ (x-y) ) ^ head y\n\nzext : {m, n} (fin m, m >= n) => [n] -> [m]\nzext x = zero # x\n\nsext : {m, n} (fin m, m >= n, n >= 1) => [n] -> [m]\nsext x = newbits # x\n  where newbits = if head x then ~zero else zero\n\nprimitive (>>$) : {n, ix} (fin n, n >= 1, Integral ix) => [n] -> ix -> [n]\n\nprimitive lg2 : {n} (fin n) => [n] -> [n]\n\nprimitive toSignedInteger : {n} (fin n, n >= 1) => [n] -> Integer\n\nprimitive ratio : Integer -> Integer -> Rational\n\nprimitive fromZ : {n} (fin n, n >= 1) => Z n -> Integer\n\nprimitive (#) : {front, back, a} (fin front) => [front]a -> [back]a\n                                             -> [front + back] a\n\nsplitAt : {front, back, a} (fin front) => [front + back]a\n                                       -> ([front]a, [back]a)\nsplitAt xs = (take`{front,back} xs, drop`{front,back} xs)\n\nprimitive join : {parts, each, a} (fin each) => [parts][each]a\n                                             -> [parts * each]a\n\nprimitive split : {parts, each, a} (fin each) => [parts * each]a\n                                              -> [parts][each]a\n\nprimitive reverse : {n, a} (fin n) => [n]a -> [n]a\n\nprimitive transpose : {rows, cols, a} [rows][cols]a -> [cols][rows]a\n\nprimitive take : {front, back, a} [front + back]a -> [front]a\n\nprimitive drop : {front, back, a} (fin front) => [front + back]a -> [back]a\n\ntail : {n, a} [1 + n]a -> [n]a\ntail xs = drop`{1} xs\n\nhead : {n, a} [1 + n]a -> a\nhead xs = xs @ (0 : Integer)\n\nlast : {n, a} (fin n) => [1 + n]a -> a\nlast xs = xs ! (0 : Integer)\n\ngroupBy : {each, parts, a} (fin each) => [parts * each]a -> [parts][each]a\ngroupBy = split`{parts=parts}\n\nprimitive (<<) : {n, ix, a} (Integral ix, Zero a) => [n]a -> ix -> [n]a\n\nprimitive (>>) : {n, ix, a} (Integral ix, Zero a) => [n]a -> ix -> [n]a\n\nprimitive (<<<) : {n, ix, a} (fin n, Integral ix) => [n]a -> ix -> [n]a\n\nprimitive (>>>) : {n, ix, a} (fin n, Integral ix) => [n]a -> ix -> [n]a\n\nprimitive (@) : {n, a, ix} (Integral ix) => [n]a -> ix -> a\n\n(@@) : {n, k, ix, a} (Integral ix) => [n]a -> [k]ix -> [k]a\nxs @@ is = [ xs @ i | i <- is ]\n\nprimitive (!) : {n, a, ix} (fin n, Integral ix) => [n]a -> ix -> a\n\n(!!) : {n, k, ix, a} (fin n, Integral ix) => [n]a -> [k]ix -> [k]a\nxs !! is = [ xs ! i | i <- is ]\n\nprimitive update : {n, a, ix} (Integral ix) => [n]a -> ix -> a -> [n]a\n\nprimitive updateEnd : {n, a, ix} (fin n, Integral ix) => [n]a -> ix -> a -> [n]a\n\nupdates : {n, k, ix, a} (Integral ix, fin k) => [n]a -> [k]ix -> [k]a -> [n]a\nupdates xs0 idxs vals = foldl upd xs0 (zip idxs vals)\n  where\n    upd xs (i,b) = update xs i b\n\nupdatesEnd : {n, k, ix, a} (fin n, Integral ix, fin k) => [n]a -> [k]ix -> [k]a -> [n]a\nupdatesEnd xs0 idxs vals = foldl upd xs0 (zip idxs vals)\n  where\n    upd xs (i,b) = updateEnd xs i b\n\ngenerate : {n, a, ix} (Integral ix, LiteralLessThan n ix) => (ix -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. <n] ]\n\nsort : {a, n} (Cmp a, fin n) => [n]a -> [n]a\nsort = sortBy (<=)\n\nsortBy : {a, n} (fin n) => (a -> a -> Bit) -> [n]a -> [n]a\nsortBy le ((xs : [n\/2]a) # (ys : [n\/^2]a)) = take zs.0\n  where\n    xs' = if `(n\/2)  == (1 : Integer) then xs else sortBy le xs\n    ys' = if `(n\/^2) == (1 : Integer) then ys else sortBy le ys\n    zs  = [ if i == `(n\/2)        then (ys'@j, i  , j+1)\n             | j == `(n\/^2)       then (xs'@i, i+1, j  )\n             | le (xs'@i) (ys'@j) then (xs'@i, i+1, j  )\n            else                       (ys'@j, i  , j+1)\n          | (_, i , j) <- [ (undefined, 0 : Integer, 0 : Integer) ] # zs\n          ]\n\nprimitive pmult : {u, v} (fin u, fin v) => [1 + u] -> [1 + v] -> [1 + u + v]\n\nprimitive pdiv : {u, v} (fin u, fin v) => [u] -> [v] -> [u]\n\nprimitive pmod : {u, v} (fin u, fin v) => [u] -> [1 + v] -> [v]\n\nprimitive parmap : {a, b, n} (Eq b, fin n) => (a -> b) -> [n]a -> [n]b\n\nprimitive deepseq : {a, b} Eq a => a -> b -> b\n\nrnf : {a} Eq a => a -> a\nrnf x = deepseq x x\n\nprimitive error : {a, n} (fin n) => String n -> a\n\nundefined : {a} a\nundefined = error \"undefined\"\n\nassert : {a, n} (fin n) => Bit -> String n -> a -> a\nassert pred msg x = if pred then x else error msg\n\nprimitive random : {a} [256] -> a\n\nprimitive trace : {n, a, b} (fin n) => String n -> a -> b -> b\n\ntraceVal : {n, a} (fin n) => String n -> a -> a\ntraceVal msg x = trace msg x x\n\nand : {n} (fin n) => [n]Bit -> Bit\nand xs = ~zero == xs\n\nor : {n} (fin n) => [n]Bit -> Bit\nor xs = zero != xs\n\nall : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nall f xs = foldl' (\/\\) True (map f xs)\n\n\/**\n * Disjunction after applying a predicate to all elements.\n *\/\nany : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nany f xs = foldl' (\\\/) False (map f xs)\n\nmap : {n, a, b} (a -> b) -> [n]a -> [n]b\nmap f xs = [f x | x <- xs]\n\nprimitive foldl : {n, a, b} (fin n) => (a -> b -> a) -> a -> [n]b -> a\n\nprimitive foldl' : {n, a, b} (fin n, Eq a) => (a -> b -> a) -> a -> [n]b -> a\n\n\/**\n * Functional right fold.\n *\n * foldr (-) 0 [1,2,3] = 0 - (1 - (2 - 3))\n *\/\nfoldr : {n, a, b} (fin n) => (a -> b -> b) -> b -> [n]a -> b\nfoldr f acc xs = foldl g acc (reverse xs)\n  where g b a = f a b\n\n\/**\n * Functional right fold, with strict evaluation of the accumulator value.\n * The accumulator is reduced to weak head normal form at each step.\n *\n * foldr' (-) 0 [1,2,3] = 0 - (1 - (2 - 3))\n *\/\nfoldr' : {n, a, b} (fin n, Eq b) => (a -> b -> b) -> b -> [n]a -> b\nfoldr' f acc xs = foldl' g acc (reverse xs)\n  where g b a = f a b\n\n\/**\n * Compute the sum of the values in the sequence.\n *\/\nsum : {n, a} (fin n, Eq a, Ring a) => [n]a -> a\nsum xs = foldl' (+) (fromInteger 0) xs\n\nproduct : {n, a} (fin n, Eq a, Ring a) => [n]a -> a\nproduct xs = foldl' (*) (fromInteger 1) xs\n\n\/**\n * Scan left is like a foldl that also emits the intermediate values.\n *\/\nprimitive scanl : {n, a, b}  (a -> b -> a) -> a -> [n]b -> [1+n]a\n\n\/**\n * Scan right is like a foldr that also emits the intermediate values.\n *\/\nscanr : {n, a, b} (fin n) => (a -> b -> b) -> b -> [n]a -> [1+n]b\nscanr f acc xs = reverse (scanl (\\a b -> f b a) acc (reverse xs))\n\n\/**\n * Repeat a value.\n *\/\nrepeat : {n, a} a -> [n]a\nrepeat x = [ x | _ <- zero : [n] ]\n\n\/**\n * 'elem x xs' returns true if x is equal to a value in xs.\n *\/\nelem : {n, a} (fin n, Eq a) => a -> [n]a -> Bit\nelem a xs = any (\\x -> x == a) xs\n\n\/**\n * Create a list of tuples from two lists.\n *\/\nzip : {n, a, b} [n]a -> [n]b -> [n](a, b)\nzip xs ys = [(x,y) | x <- xs | y <- ys]\n\n\/**\n * Create a list by applying the function to each pair of elements in the input.\n *\/\nzipWith : {n, a, b, c} (a -> b -> c) -> [n]a -> [n]b -> [n]c\nzipWith f xs ys = [f x y | x <- xs | y <- ys]\n\n\/**\n * Transform a function into uncurried form.\n *\/\nuncurry : {a, b, c} (a -> b -> c) -> (a, b) -> c\nuncurry f = \\(a, b) -> f a b\n\n\/**\n * Transform a function into curried form.\n *\/\ncurry : {a, b, c} ((a, b) -> c) -> a -> b -> c\ncurry f = \\a b -> f (a, b)\n\n\/**\n * Map a function iteratively over a seed value, producing an infinite\n * list of successive function applications.\n *\/\niterate : {a} (a -> a) -> a -> [inf]a\niterate f z = scanl (\\x _ -> f x) z (zero:[inf]())\n```"}]}
{"filename":"cryptol\/bench\/data\/SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named SHA512 that contains the following definitions: (1) A top-level function sha512 with a precise type signature mapping a finite-length bit sequence to a 512-bit digest. It must pad the message per SHA-512 (append a single 1 bit, then zero bits, then a 128-bit big-endian length) so that the total length is a multiple of 1024, with the usual bound that the original length fits in 128 bits. After padding, split into 1024-bit blocks, iteratively apply a compression function starting from an 8-word 64-bit initial vector, and return the final chaining value concatenated into 512 bits. (2) A function processBlock with type [1024] -> [8][64] -> [8][64] that builds an 80-word schedule from the 16 input words and performs 80 rounds of the SHA-512 step, then adds the result to the incoming state word-wise modulo 2^64. (3) A function step with type [8][64] -> [64] -> [8] -> [8][64] that takes the state, a 64-bit schedule word, and a round index in [0..79], computes T1 and T2 using the SHA-512 Ch, Maj, and big-sigma functions, and returns the next state. (4) A function messageSch with type [16][64] -> [80][64] that defines words 16..79 using the small-sigma recurrences. (5) A polymorphic pad with constraints capturing the SHA-512 padding length arithmetic and output length multiple-of-1024 requirement. (6) Bitwise helpers Ch, Maj, SIGMA0, SIGMA1, sigma0, sigma1 on 64-bit words using rotates and shifts. (7) Constants H0 : [8][64] and K : [80][64] with standard SHA-512 initialization and round constants. (8) A property named testVector1 that checks the hash of a specific hexadecimal message equals a specific 512-bit hexadecimal digest (the property may ignore its argument). Provide all necessary type signatures and ensure 64-bit modular arithmetic."},{"role":"assistant","content":"```cryptol\nmodule SHA512 where\n\nsha512 M = result\n  where\n    M' = (pad M)\n    blocks = (groupBy`{1024} M')\n    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]\n    result = (join (hash!0))\n\nprocessBlock : [1024] -> [8][64] -> [8][64]\nprocessBlock block Hprev = Hs\n  where\n    Mi = split block : [16][64]\n    Ws = (messageSch Mi)\n    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]\n    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]\n\nstep : [8][64] -> [64] -> [8] -> [8][64]\nstep [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']\n  where\n    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt\n    T2 = (SIGMA0 a) + (Maj a b c)\n    h' = g\n    g' = f\n    f' = e\n    e' = d + T1\n    d' = c\n    c' = b\n    b' = a\n    a' = T1 + T2\n\nmessageSch : [16][64] -> [80][64]\nmessageSch Mi = W\n  where\n    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]\n\npad : {l, k} (fin l,\n              l <= ((2^^128) - 1),\n              l >= 0,\n              fin k,\n              k - l >= 129,\n              k == 128 + l + 1 + 1024 - ((l+129)%1024),\n              k%1024 == 0) => [l] -> [k]\npad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])\n\nCh : [64] -> [64] -> [64] -> [64]\nCh x y z = (x && y) ^ ((~x) && z)\n\nMaj : [64] -> [64] -> [64] -> [64]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nSIGMA0 : [64] -> [64]\nSIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)\n\nSIGMA1 : [64] -> [64]\nSIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)\n\nsigma0 : [64] -> [64]\nsigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)\n\nsigma1 : [64] -> [64]\nsigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)\n\nH0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]\n\nK = [\n0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n]\n\nproperty testVector1 x = sha512 0xfd2203e467574e834ab07c9097ae164532f24be1eb5d88f1af7748ceff0d2c67a21f4e4097f9d3bb4e9fbf97186e0db6db0100230a52b453d421f8ab9c9a6043aa3295ea20d2f06a2f37470d8a99075f1b8a8336f6228cf08b5942fc1fb4299c7d2480e8e82bce175540bdfad7752bc95b577f229515394f3ae5cec870a4b2f8 == 0xa21b1077d52b27ac545af63b32746c6e3c51cb0cb9f281eb9f3580a6d4996d5c9917d2a6e484627a9d5a06fa1b25327a9d710e027387fc3e07d7c4d14c6086cc\n```"}]}
{"filename":"cryptol\/rust\/cry-ffi\/Example.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Example that imports the Float module and contains only declarations (no implementations) for the following: (1) a newtype N wrapping a record with one field unN that is an 8-bit sequence; (2) foreign abstract symbols with explicit types: a function Bit -> Bit; functions over fixed-width sequences mapping each width to itself for 8, 16, 32, 64, and 128 bits (two sets named for unsigned and signed but all typed as the corresponding [n]); a function Integer -> Integer; a function Rational -> Rational; a function Float32 -> Float32; a function Float64 -> Float64; a function mapping an array of length 16 of 8-bit sequences to the same; functions over records: empty record -> empty record, a record with field x of 8 bits to itself, and a record with fields x (8 bits) and y (16 bits) to itself; functions over tuples: unit -> unit and a pair (8-bit, 16-bit) to itself; a function N -> N; a function Option [8] -> Option [8]; a function Result [16] [32] -> Result [16] [32]; a curried function taking two 8-bit sequences and returning an 8-bit sequence; a function taking a 128-bit sequence and returning a pair of 128-bit sequences; a function Z 7 -> Z 7; and a polymorphic value with implicit numeric parameter n, constrained to be finite and at least 1, returning Z n. Mark each declared symbol as foreign abstract and give precise Cryptol type signatures matching these descriptions."},{"role":"assistant","content":"```cryptol\nmodule Example where\n\nimport Float\n\nnewtype N = { unN : [8] }\n\nforeign abstract test_bool : Bit -> Bit\nforeign abstract test_u8 : [8] -> [8]\nforeign abstract test_u16 : [16] -> [16]\nforeign abstract test_u32 : [32] -> [32]\nforeign abstract test_u64 : [64] -> [64]\nforeign abstract test_u128 : [128] -> [128]\nforeign abstract test_i8 : [8] -> [8]\nforeign abstract test_i16 : [16] -> [16]\nforeign abstract test_i32 : [32] -> [32]\nforeign abstract test_i64 : [64] -> [64]\nforeign abstract test_i128 : [128] -> [128]\nforeign abstract test_integer : Integer -> Integer\nforeign abstract test_rational : Rational -> Rational\nforeign abstract test_float : Float32 -> Float32\nforeign abstract test_double : Float64 -> Float64\nforeign abstract test_array_16_u8 : [16][8] -> [16][8]\nforeign abstract test_record0 : {} -> {}\nforeign abstract test_record1_u8 : { x : [8] } -> { x : [8] }\nforeign abstract test_record2_u8_u16 : { x : [8], y : [16] } -> { x : [8], y : [16] }\nforeign abstract test_tuple0 : () -> ()\nforeign abstract test_tuple2_u8_u16 : ([8], [16]) -> ([8], [16])\nforeign abstract test_newtype_u8 : N -> N\nforeign abstract test_option_u8 : Option [8] -> Option [8]\nforeign abstract test_result_u16_u32 : Result [16] [32] -> Result [16] [32]\nforeign abstract test_two_u8_args : [8] -> [8] -> [8]\nforeign abstract test_two_u128_res : [128] -> ([128], [128])\nforeign abstract test_z7 : Z 7 -> Z 7\nforeign abstract test_param : {n} (fin n, n >= 1) => Z n\n```"}]}
{"filename":"cryptol\/tests\/modsys\/T007.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a parameterized submodule named F that accepts a numeric type parameter n and a value parameter x of type [n], with constraints that n is finite and at least 4. Inside F, declare y with type [n] and define it as the modular sum of x and the literal 11 (addition modulo 2^n). Next, define a concrete submodule I that fixes n to 8 and assigns x the literal 2 with type [8]. Instantiate F using the parameters from I to create a submodule named M. Finally, import the instantiated submodule under the alias M."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type n : #\n    x      : [n]\n    type constraint (fin n, n >= 4)\n\n  y : [n]\n  y = x + 11\n\nsubmodule I where\n  type n = 8\n  x = 2\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/enum\/CheckEnumPartialError.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an algebraic data type parameterized by an element type to represent an optional value with two constructors: one for absence and one wrapping a present value. Then define two polymorphic functions with type parameters a and b that each take a unary function from a to b and an optional a, and return an optional b. Make both definitions intentionally non-exhaustive via case analysis: the first handles only the present-value constructor and returns a present transformed value; the second handles only the absence constructor and returns absence. Next, define an enumeration type with exactly three distinct nullary constructors. Provide one function from this enum to the unit type that matches only the first constructor (intentionally non-exhaustive). Finally, provide a second function from the same enum to unit that is total by matching the first constructor explicitly and using a wildcard branch to handle all remaining constructors. Use appropriate Cryptol type signatures and case expressions to illustrate the partial and total pattern matches."},{"role":"assistant","content":"```cryptol\nenum Maybe a = Nothing | Just a\n\nmaybeMapBad1 : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMapBad1 f m =\n  case m of\n    Just x -> Just (f x)\n\nmaybeMapBad2 : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMapBad2 f m =\n  case m of\n    Nothing -> Nothing\n\nenum Foo = A | B | C\n\nfooBad1 : Foo -> ()\nfooBad1 f =\n  case f of\n    A -> ()\n\nfooGood : Foo -> ()\nfooGood f =\n  case f of\n    A -> ()\n    _ -> ()\n```"}]}
{"filename":"cryptol\/tests\/enum\/CheckProveEnum.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define enumerations for Maybe a (with absence or a value), Either a b (with left or right value), Foo a (three nullary variants and one carrying an 8-bit word and a value), and Letter (three symbols). Provide equality predicates maybeEqual, eitherEqual, fooEqual with types returning Bit and using Eq constraints where needed to compare only when constructors match and, for parameterized cases, using the underlying equality. Define mapping functions: maybeMap to apply a function only to a present value; eitherMapLeft and eitherMapRight to map over left or right, and eitherMapBoth to map both in one pass; fooMap to map only the value field of the binary Foo constructor, leaving the 8-bit field and other variants unchanged; letterRotate to cycle the three letters. Define a property that for Maybe [8], mapping (+1) twice equals mapping (+2) once, compared via maybeEqual. Define a property that for Either [8] [8], applying (+1) to the right then to the left equals mapping both once, compared via eitherEqual. Define a property that for Foo [8], mapping (+1) twice equals mapping (+2) once, compared via fooEqual. Define a property that for Letter, rotating three times yields the original value, checked by letterEqual."},{"role":"assistant","content":"```cryptol\nenum Maybe a = Nothing | Just a\n\nmaybeEqual : {a} (Eq a) => Maybe a -> Maybe a -> Bit\nmaybeEqual m1 m2 =\n  case m1 of\n    Just x1 ->\n      case m2 of\n        Just x2 -> x1 == x2\n        Nothing -> False\n    Nothing ->\n      case m2 of\n        Just x2 -> False\n        Nothing -> True\n\nmaybeMap : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMap f m =\n  case m of\n    Just x  -> Just (f x)\n    Nothing -> Nothing\n\nmaybeMapProp : Maybe [8] -> Bit\nproperty maybeMapProp m =\n  maybeEqual\n    (maybeMap (\\x -> x + 1) (maybeMap (\\x -> x + 1) m))\n    (maybeMap (\\x -> x + 2) m)\n\nenum Either a b = Left a | Right b\n\neitherEqual : {a, b} (Eq a, Eq b) => Either a b -> Either a b -> Bit\neitherEqual e1 e2 =\n  case e1 of\n    Left x1 ->\n      case e2 of\n        Left x2  -> x1 == x2\n        Right y2 -> False\n    Right y1 ->\n      case e2 of\n        Left x2  -> False\n        Right y2 -> y1 == y2\n\neitherMapLeft : {a, a', b} (a -> a') -> Either a b -> Either a' b\neitherMapLeft f e =\n  case e of\n    Left x  -> Left (f x)\n    Right y -> Right y\n\neitherMapRight : {a, b, b'} (b -> b') -> Either a b -> Either a b'\neitherMapRight g e =\n  case e of\n    Left x  -> Left x\n    Right y -> Right (g y)\n\neitherMapBoth : {a, a', b, b'} (a -> a') -> (b -> b') -> Either a b -> Either a' b'\neitherMapBoth f g e =\n  case e of\n    Left x  -> Left (f x)\n    Right y -> Right (g y)\n\neitherMapProp : Either [8] [8] -> Bit\nproperty eitherMapProp e =\n  eitherEqual\n    (eitherMapLeft (\\x -> x + 1) (eitherMapRight (\\y -> y + 1) e))\n    (eitherMapBoth (\\x -> x + 1) (\\y -> y + 1) e)\n\nenum Foo a = Bar | Baz | Quux | Fred [8] a\n\nfooEqual : {a} (Eq a) => Foo a -> Foo a -> Bit\nfooEqual f1 f2 =\n  case f1 of\n    Bar ->\n      case f2 of\n        Bar        -> True\n        Baz        -> False\n        Quux       -> False\n        Fred y1 y2 -> False\n    Baz ->\n      case f2 of\n        Bar        -> False\n        Baz        -> True\n        Quux       -> False\n        Fred y1 y2 -> False\n    Quux ->\n      case f2 of\n        Bar        -> False\n        Baz        -> False\n        Quux       -> True\n        Fred y1 y2 -> False\n    Fred x1 x2 ->\n      case f2 of\n        Bar        -> False\n        Baz        -> False\n        Quux       -> False\n        Fred y1 y2 -> (x1 == y1) \/\\ (x2 == y2)\n\nfooMap : {a, b} (a -> b) -> Foo a -> Foo b\nfooMap f ff =\n  case ff of\n    Bar      -> Bar\n    Baz      -> Baz\n    Quux     -> Quux\n    Fred x y -> Fred x (f y)\n\nfooMapProp : Foo [8] -> Bit\nproperty fooMapProp f =\n  fooEqual\n    (fooMap (\\x -> x + 1) (fooMap (\\x -> x + 1) f))\n    (fooMap (\\x -> x + 2) f)\n\nenum Letter = A | B | C\n\nletterEqual : Letter -> Letter -> Bit\nletterEqual l1 l2 =\n  case l1 of\n    A ->\n      case l2 of\n        A -> True\n        B -> False\n        C -> False\n    B ->\n      case l2 of\n        A -> False\n        B -> True\n        C -> False\n    C ->\n      case l2 of\n        A -> False\n        B -> False\n        C -> True\n\nletterRotate : Letter -> Letter\nletterRotate l =\n  case l of\n    A -> B\n    B -> C\n    C -> A\n\nletterRotateProp : Letter -> Bit\nproperty letterRotateProp l =\n  letterEqual l (letterRotate (letterRotate (letterRotate l)))\n```"}]}
{"filename":"cryptol\/tests\/parser\/tuples-records.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define constants with explicit type annotations for: (1) a pair named tuple containing two 8-bit values equal to 0xFF; (2) a pair named nested_tuple1 whose first element is an 8-bit 0xFF and whose second element is a pair of two 8-bit 0xFF values; (3) a pair named nested_tupel2 whose first element is a pair of two 8-bit 0xFF values and whose second element is an 8-bit 0xFF; (4) an empty tuple named empty_tuple with unit type; (5) a record named record with fields x and y, each an 8-bit 0xFF; (6) a record named nested_record with field x as an 8-bit 0xFF and field y as a record with fields x and y each an 8-bit 0xFF; and (7) an empty record named empty_records. Ensure all literals use the 8-bit word type and that each definition\u2019s type precisely matches its structure (e.g., pairs vs nested pairs, flat record vs nested record, and empty tuple\/record types). Do not provide implementations beyond these annotated constant declarations."},{"role":"assistant","content":"```cryptol\ntuple           = (0xFF, 0xFF)\nnested_tuple1   = (0xFF, (0xFF,0xFF))\nnested_tupel2   = ((0xFF,0xFF), 0xFF)\nempty_tuple     = ()\n\nrecord          = { x = 0xFF, y = 0xFF }\nnested_record   = { x = 0xFF, y = { x = 0xFF, y = 0xFF }}\nempty_records   = {}\n```"}]}
{"filename":"cryptol\/tests\/parser\/docs.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the following:\n- A constant named test1 with an explicit type of a single-bit boolean and value true.\n- A constant named test2 with value true, relying on type inference (no explicit type signature).\n- A unary function named test3 that returns its input unchanged and is fully polymorphic over its argument type.\n- Define a property named test4 that takes one argument, constrains it to be a single-bit boolean via a type annotation, and uses that annotated value as the property\u2019s boolean result.\n- Declare an infix operator named ++ with left associativity and precedence 5; give it the polymorphic type for all types a: a -> a -> a; define it to return its first operand, ignoring the second.\n- A private constant named test5 whose value is the unit value.\n- A type synonym named Foo that is equal to the unit type.\nInclude the necessary type signatures where specified and ensure the visibility and fixity declarations match the description. Do not provide any proofs or evaluations; only the specification elements described above."},{"role":"assistant","content":"```cryptol\ntest1 : Bit\ntest1 = True\n\ntest2 = True\n\ntest3 x = x\n\nproperty test4 x = (x : Bit)\n\ninfixl 5 ++\n\n(++) : {a} a -> a -> a\nx ++ _ = x\n\nprivate test5 = ()\n\ntype Foo = ()\n```"}]}
{"filename":"cryptol\/tests\/parser\/T437.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the following artifacts mirroring the described behaviors and types: (1) A polymorphic function mk_buggy_fib_no_init with a size parameter a constrained to be finite and at least 1. It takes: (i) a counter target value of a bits (magic), and (ii) a pair whose first element is a single-bit input (ignored) and whose second element is a state triple (x, y, k) where x and y are 8-bit words and k is an a-bit counter. It returns a pair of: an 8-bit output and an updated state triple. The next state is (y, x+y, k+1), with arithmetic modulo the respective widths. The output equals x plus 1 precisely when k equals magic; otherwise it equals x. Provide the corresponding type signature. (2) A generic function generate parameterized by n, ix, and element type a, with constraints that ix and n are finite, n \u2265 1, and ix is at least the bit-width of n\u22121. It takes a function from an ix-bit index to an element and returns a sequence of length n computed by enumerating indices 0..n\u22121. Provide its type signature and definition. (3) A left-associative infix operator $ with precedence level 1 that performs simple function application (apply a unary function to its argument). (4) Two constants foo and bar, each a sequence of length 10 of 4-bit elements. Each is produced by the generator applied to a lambda over an 8-bit index i, yielding 1 at index 0 and otherwise the previous element at index i\u22121. Define foo using the $ operator and bar using direct application; both must have identical behavior and type."},{"role":"assistant","content":"```cryptol\nmk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n  \/\/ Change output when state has magic value.\n  fn' = fn + if k == magic then 1 else 0\n\ngenerate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. n-1] ]\n\ninfixl 1 $\nf $ x = f x\n\nfoo : [10][4]\nfoo = generate $ \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n\nbar : [10][4]\nbar = generate \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n```"}]}
{"filename":"cryptol\/tests\/parser\/unary.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two properties that verify unary operator precedence over addition for 8-bit words. For the first property, assert that for the 8-bit value 5, applying the bitwise complement and then adding 2 is equal to explicitly parenthesizing the complemented value and then adding 2. For the second property, assert the analogous equivalence for unary arithmetic negation and addition by 2. Annotate the literal 5 as an 8-bit word so both sides of each equality have type [8], and ensure each property returns a Boolean result by comparing the two [8]-typed expressions for equality."},{"role":"assistant","content":"```cryptol\ntest1 = (~ (5 : [8]) + 2) == (~ (5 : [8])) + 2\ntest2 = (- (5 : [8]) + 2) == (- (5 : [8])) + 2\n```"}]}
{"filename":"cryptol\/tests\/parser\/pat1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines seven functions using pattern matching with complete, generalized type signatures and necessary size parameters and constraints: (1) a function that takes a 2-tuple and returns its first component (fully polymorphic over element types); (2) a function that, given a sequence known to be the concatenation of two subsequences, returns the left subsequence (polymorphic over element type and lengths m and n, with input length m+n and result length m); (3) a function that consumes a sequence of exactly three elements of an arithmetic type and returns the sum of its three elements; (4) a function that takes a record with exactly two fields, binds both fields to new names in the pattern, and returns the value of the first field; (5) a function that destructures an input formed by concatenating an 8-element left segment with a 10-element right segment and returns their concatenation, ensuring the right segment is explicitly annotated as length 10 in the result; (6) a function that, given an input that is a concatenation whose right segment has length 10, returns the left segment (left length is size-polymorphic); (7) a function identical in behavior to (6) but written so the right segment\u2019s length-10 annotation is parenthesized in the pattern. Use tuple, sequence, list, and record patterns as appropriate. Provide explicit type signatures with size parameters in braces, and include any required arithmetic constraints for addition. Do not include tests; only the definitions."},{"role":"assistant","content":"```cryptol\nf1 (x,y) = x\nf2 (x # y) = x\nf3 [x,y,z] = x + y + z\nf4 {x = a, y = b } = a\nf5 ((x : [8]) # (y : [10])) = x # y : [10]\nf6 (x # y : [10]) = x\nf7 (x # (y : [10])) = x\n```"}]}
{"filename":"cryptol\/tests\/parser\/infix-1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two infix operators named ++ and ** with left associativity. Assign precedence levels 4 for ++ and 5 for ** so that ** binds tighter than ++. Provide a type signature for ++ that takes two 8-bit sequences and returns an 8-bit sequence, and define it to compute their sum using 8-bit addition. Provide a polymorphic type signature for ** with a single type variable constrained by the Ring type class; it takes two values of that type and returns their product, implemented via ring multiplication. Include the infix declarations, type signatures, and definitions."},{"role":"assistant","content":"```cryptol\ninfixl 4 ++\ninfixl 5 **\n\n(++) : [8] -> [8] -> [8]\nx ++ y = x + y\n\n(**) : {a} (Ring a) => a -> a -> a\nx ** y = x * y\n```"}]}
