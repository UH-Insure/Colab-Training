{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/AES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines AES encryption with key expansion and proves a property that encrypting with a raw key equals encrypting with its expanded key schedule for all valid key sizes and plaintexts."},{"role":"assistant","content":"```cryptol\nmodule AES where\n\nimport `Common::AES\n\ntype constraint ValidKey k m = (k == 128 + m * 64, 2 >= m)\n\ntype ExpandedKey m = KeySchedule m\n\nencrypt : {k,m} ValidKey k m => [k] -> [128] -> [128]\nencrypt = aesEncrypt`{Mode = m}\n\nexpandKey : {k,m} ValidKey k m => [k] -> ExpandedKey m\nexpandKey = ExpandKey`{Mode = m}\n\nencryptWithSchedule : {k,m} ValidKey k m => ExpandedKey m -> [128] -> [128]\nencryptWithSchedule = aesEncryptWithSchedule`{Mode = m}\n\nproperty test k pt = encrypt k pt == encryptWithSchedule (expandKey k) pt\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/AES128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module AES128 that defines AES-128-specific type synonyms (State, KeySchedule, RoundKey) and wrapper functions (sub_bytes128, shift_rows128, expand_key128, aes_round128, aes_final_round128, encryptState128) that specialize the generic AES operations for 128-bit keys."},{"role":"assistant","content":"```cryptol\nmodule AES128 where\n\nimport `Common::AES\nimport `Common::AES as AES\nimport AES as AES\n\ntype State         = AES::State 0  \ntype KeySchedule   = AES::KeySchedule 0\ntype RoundKey      = AES::RoundKey 0\n\nsub_bytes128 : State -> State\nsub_bytes128 = SubBytes`{0}\n\nshift_rows128 : State -> State\nshift_rows128 = ShiftRows`{0}\n\nexpand_key128 : [128] -> KeySchedule\nexpand_key128 = AES::expandKey\n\naes_round128 : RoundKey -> State -> State\naes_round128 = AES::aes_round`{0}\n\naes_final_round128 : RoundKey -> State -> State\naes_final_round128 = AES::aes_final_round`{0}\n\nencryptState128 : KeySchedule -> State -> State\nencryptState128 = AES::encryptState`{0}\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/intrinsics.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the Cryptol definitions modeling AES-GCM-SIV intrinsics (128-bit SIMD helpers, H-table initialization, and POLYVAL via table lookup) and the property `polyval_equiv` that proves `polyval_Htable` is equivalent to `AES_GCM_SIV::polyvalFrom` for all inputs."},{"role":"assistant","content":"```cryptol\nmodule Intrinsics where\n\nimport `Common::AES_GCM_SIV as AES_GCM_SIV\n\n_mm_setr_epi32 : [32] -> [32] -> [32] -> [32] -> [128]\n_mm_setr_epi32 a b c d = join [a, b, c, d]\n\n_mm_loadu_si128 : [128] -> [4][32]\n_mm_loadu_si128 v = split v\n\nselect_from_128 : [128] -> Bit -> [128]\nselect_from_128 n b = res\n  where\n    [l,r] = split n\n    res = (if b then l else r) # zero\n\n_mm_clmulepi64_si128 : [128] -> [128] -> [2] -> [128 ]\n_mm_clmulepi64_si128 a b s = AES_GCM_SIV::mult`{0}`{0} l r\n  where\n  l = select_from_128 a (s @ 0)\n  r = select_from_128 b (s @ 1)\n\n_mm_xor_si128 : [128] -> [128] -> [128]\n_mm_xor_si128 a b = a ^ b\n\n_mm_shuffle_epi32_78 : [4][32] -> [4][32]\n_mm_shuffle_epi32_78 l = l >>> 2\n\n_mm_alignr_epi8 : [16][8] -> [16][8] -> [8] -> [128]\n_mm_alignr_epi8 a b ralign = take ((join (a # b)) >> (ralign * 8))\n\nINIT_Htable : {n} (fin n, n>=2) => [128] -> [n][128]\nINIT_Htable H = hs\n  where\n  hs = [H] # [ AES_GCM_SIV::dot`{0}`{0} hn H\n                | hn <- hs\n                | (j : [width n]) <- [0..n-2]]\n\npolyval_Htable : {n} (fin n, n>=2) => [128] -> [n][128] -> [128]\npolyval_Htable H X = sums ! 0\n  where\n    htable = INIT_Htable`{n} H\n    sums = [zero] # [ (AES_GCM_SIV::dot`{0}`{0} (X@i) (htable!i)) ^ sum\n                    | sum <- sums\n                    | (i : [width n]) <- [0..n-1] ]\n\nproperty polyval_equiv H (xs : [4][128]) =\n  AES_GCM_SIV::polyvalFrom`{0}`{0} H xs zero ==\n  polyval_Htable H xs\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/AES256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification in module AES256 that defines AES-256 types and functions (State, KeySchedule, RoundKey, sub_bytes256, shift_rows256, expand_key256, aes_round256, aes_final_round256, encryptState256) as wrappers around the corresponding AES module definitions specialized to 256-bit keys."},{"role":"assistant","content":"```cryptol\nmodule AES256 where\n\nimport `Common::AES\nimport `Common::AES as AES\nimport AES as AES\n\ntype State         = AES::State 2\ntype KeySchedule   = AES::KeySchedule 2\ntype RoundKey      = AES::RoundKey 2\n\nsub_bytes256 : State -> State\nsub_bytes256 = SubBytes`{2}\n\nshift_rows256 : State -> State\nshift_rows256 = ShiftRows`{2}\n\nexpand_key256 : [256] -> KeySchedule\nexpand_key256 = AES::expandKey\n\naes_round256 : RoundKey -> State -> State\naes_round256 = AES::aes_round`{2}\n\naes_final_round256 : RoundKey -> State -> State\naes_final_round256 = AES::aes_final_round`{2}\n\nencryptState256 : KeySchedule -> State -> State\nencryptState256 = AES::encryptState`{2}\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/TBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification implementing the AES S-box and its inverse over GF(2^8), including the finite field operations, state\/message conversions, and constants as in AES, suitable for use in AES-GCM-SIV proofs."},{"role":"assistant","content":"```cryptol\ntype Nb         = 4\ntype State      = [4][Nb]GF28\ntype RoundKey   = State\n\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\ntype GF28        = [8]\n\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\ngf28Mult : GF28 -> GF28 -> GF28\ngf28Mult x y  = pmod (pmult x y) irreducible\n\ngf28Pow : GF28 -> [8] -> GF28\ngf28Pow n k = pow k\n  where   sq x  = gf28Mult x x\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult n (sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow x 254\n\ngf28DotProduct : {n} (fin n) => [n]GF28 -> [n]GF28 -> GF28\ngf28DotProduct xs ys = gf28Add [ gf28Mult x y | x <- xs | y <- ys ]\n\ngf28VectorMult : {n, m} (fin n) => [n]GF28 -> [m][n]GF28 -> [m]GF28\ngf28VectorMult v ms = [ gf28DotProduct v m | m <- ms ]\n\ngf28MatrixMult : {n, m, k} (fin m) => [n][m]GF28 -> [m][k]GF28 -> [n][k]GF28\ngf28MatrixMult xss yss = [ gf28VectorMult xs yss' | xs <- xss ]\n   where yss' = transpose yss\n\nsbox : [256]GF28\nsbox = [\n 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n 0x54, 0xbb, 0x16]\n\nsbox_inverse : [256] GF28\nsbox_inverse = [\n    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,\n    0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,\n    0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,\n    0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,\n    0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,\n    0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,\n    0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,\n    0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,\n    0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,\n    0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,\n    0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,\n    0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,\n    0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,\n    0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,\n    0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,\n    0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,\n    0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D]\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/cryptol\/Asm128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the above AES-GCM-SIV helper functions (Polyval_Horner_*, Polyval_HTable_*, AES_128_ENC_x4_def, AES_KS_ENC_x1_def*, ENC_MSG_def, AES_GMC_SIV_Encrypt_*) and proves the property polyProp for all valid inputs."},{"role":"assistant","content":"```cryptol\nmodule GenAsm128 where\n\nimport X86\nimport AES128\nimport AES128_GCM_SIV\nimport Sizes\n\ndot256 : [256] -> [256] -> [256]\ndot256 (_ # res) (_ # h) = 0 # dot res h\n\ndot512 : [512] -> [512] -> [512]\ndot512 (_ # res) (_ # h) = 0 # dot res h\n\nPolyval_Horner_gen_def :\n  {n} fin n => [1][128] -> [n][8] -> [1][128] -> [1][128]\nPolyval_Horner_gen_def [h] i [t] = [ polyvalFrom h (leLoadBlocks i) t ]\n\nPolyval_Horner_AAD_def : [1][128] -> [AAD_Size][8] -> [1][128] -> [1][128]\nPolyval_Horner_AAD_def = Polyval_Horner_gen_def\n\nPolyval_Horner_MSG_def : [1][128] -> [MSG_Size][8] -> [1][128] -> [1][128]\nPolyval_Horner_MSG_def = Polyval_Horner_gen_def\n\nPolyval_Horner_BLK_def : [1][128] -> [16][8] -> [1][128] -> [1][128]\nPolyval_Horner_BLK_def = Polyval_Horner_gen_def\n\nPolyval_Horner_AAD_MSG_def :\n  [16][8] -> [AAD_Size][8] -> [MSG_Size][8] -> [2][64] -> [16][8] -> [1][128]\nPolyval_Horner_AAD_MSG_def h aad pt lblk t =\n  [ polyvalFrom (leLoad h) work (leLoad t) ]\n  where\n  work = leLoadBlocks aad\n       # leLoadBlocks pt\n       # leLoadBlocks [ b | qword <- lblk, b <- leStore qword ]\n\nINIT_Htable_def: [1][128] -> [8][128]\nINIT_Htable_def [h] = INIT_Htable h\n\nPolyval_HTable_gen_def :\n  {n} (fin n) => [8][128] -> [n][8] -> [1][128] -> [1][128]\nPolyval_HTable_gen_def tbl data [t] =\n  [ polyvalHtableNH tbl (leLoadBlocks data) t ]\n\nPolyval_HTable_AAD_def : [8][128] -> [AAD_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_AAD_def = Polyval_HTable_gen_def\n\nPolyval_HTable_MSG_def : [8][128] -> [MSG_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_MSG_def = Polyval_HTable_gen_def\n\nPolyval_HTable_BLK_def : [8][128] -> [16][8] -> [1][128] -> [1][128]\nPolyval_HTable_BLK_def = Polyval_HTable_gen_def\n\nPolyval_HTable_call_AAD_def : [8][128] -> [AAD_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_call_AAD_def hs = Polyval_Horner_AAD_def (take hs)\n\nPolyval_HTable_call_MSG_def : [8][128] -> [MSG_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_call_MSG_def hs = Polyval_Horner_MSG_def (take hs)\n\nPolyval_HTable_call_BLK_def : [8][128] -> [16][8] -> [1][128] -> [1][128]\nPolyval_HTable_call_BLK_def hs = Polyval_Horner_BLK_def (take hs)\n\npolyProp :\n  {x,y} (fin x, fin y) => [128] -> [x][128] -> [y][128] -> [128] -> Bool\npolyProp h xs ys t =\n  polyvalFrom h ys (polyvalFrom h xs t) == polyvalFrom h (xs # ys) t\n\nAES_128_ENC_x4_def : [16][8] -> [11][128] -> [4][128]\nAES_128_ENC_x4_def iv' keys = [ aesWithKeys keys (iv # i) | i <- [ 0 .. 3 ] ]\n  where\n  _ # (iv : [96]) = leLoad iv'\n\nAES_KS_ENC_x1_def1 : [16][8]  -> [11][128]\nAES_KS_ENC_x1_def1 ikey =\n  aesKeyToBits (ExpandKey (beLoad ikey))\n\nAES_KS_ENC_x1_def2 : [11][128] -> [16][8] -> [1][128]\nAES_KS_ENC_x1_def2 keys pt = [ aesWithKeys keys (leLoad pt) ]\n\nENC_MSG_def :\n  [11][128] -> [16][8] -> [MSG_Size][8] -> [MSG_Size][8]\nENC_MSG_def keys tag pt =\n  leStoreBlocks (counter_mode K2 (0b1 # tUpper, tLower) M)\n  where\n  K2 = aesKeysFromBits keys\n  M  = leLoadBlocks pt\n  _ # tUpper # tLower = leLoad tag\n\nAES_GMC_SIV_Encrypt_pair :\n  [11][128] -> [12][8] -> [AAD_Size][8] -> [MSG_Size][8] ->\n                                                    ([8 * MSG_Size], [128])\nAES_GMC_SIV_Encrypt_pair keys iv aad pt =\n  gcm_siv_plus ks nonce (beLoad aad) (beLoad pt)\n  where\n  ks    = derive_key_expanded (aesKeysFromBits keys) nonce\n  nonce = leLoad iv\n\nAES_GMC_SIV_Encrypt_TAG_def :\n  [11][128] -> [12][8] -> [AAD_Size][8] -> [MSG_Size][8] -> [1][128]\nAES_GMC_SIV_Encrypt_TAG_def keys iv add pt = [ tag ]\n  where (_,tag) = AES_GMC_SIV_Encrypt_pair keys iv add pt\n\nAES_GMC_SIV_Encrypt_CT_def :\n  [11][128] -> [12][8] -> [AAD_Size][8] -> [MSG_Size][8] -> [MSG_Size][8]\nAES_GMC_SIV_Encrypt_CT_def keys iv add pt = beStore ct\n  where (ct,_) = AES_GMC_SIV_Encrypt_pair keys iv add pt\n\naesWithKeys : [11][128] -> [128] -> [128]\naesWithKeys ks pt = aes (aesKeysFromBits ks) pt\n\naesKeysFromBits : [11][128] -> KeySchedule\naesKeysFromBits ks = (k1,kRest,kLast)\n  where [k1] # kRest # [kLast] = [ aesStateFromBits m | m <- ks ]\n\naesKeyToBits : KeySchedule -> [11][128]\naesKeyToBits (k1,kRest,kLast) =\n  [ aesStateToBits k1 ] #\n  [ aesStateToBits x | x <- kRest ] #\n  [ aesStateToBits kLast ]\n\nleLoadBlocks : {n} (fin n) => [n][8] -> [n \/^ 16][128]\nleLoadBlocks bytes = leLoadArray (bytes # zero)\n\nleStoreBlocks : {n} (fin n) => [n \/^ 16][128] -> [n][8]\nleStoreBlocks arr = take (leStoreArray arr)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/cryptol\/AES128_GCM_SIV.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `AES128_GCM_SIV` that specifies the AES-128-GCM-SIV authenticated encryption algorithm (per the referenced Figures 1\u20132), including `aes_gcm_siv`, key derivation, POLYVAL-based authentication, counter-mode encryption, and supporting properties like `pht` for verifying the optimized POLYVAL implementation."},{"role":"assistant","content":"```cryptol\nmodule AES128_GCM_SIV where\n\nimport AES128 as AES\nimport Sizes\n\ntype AAD  = 8 * AAD_Size\n\ntype K  = 128\ntype KS = AES::KeySchedule\n\naes_gcm_siv :\n  {n} ((36 + 8) >= width n) =>\n      { key   : [K]\n      , nonce : [96]\n      , aad   : [AAD]\n      , msg   : [n]\n      } -> [n + 128]\naes_gcm_siv input = c # byteSwap t\n  where\n  (c,t) = gcm_siv_plus (derive_key k' n') n' input.aad input.msg\n  k'    = byteSwap input.key\n  n'    = byteSwap input.nonce\n\naes : KS -> [128] -> [128]\naes ks v = byteSwap (AES::aesEncryptWithSchedule ks (byteSwap v))\n\nexpandKey1 : [K] -> KS\nexpandKey1 k = AES::ExpandKey (byteSwap k)\n\n\/** See Figure 2 in Section 4 *\/\nderive_key : [K] -> [96] -> ([128], KS)\nderive_key K N = derive_key_expanded (expandKey1 1) N\n\n\/** See Figure 2 in Section 4 *\/\nderive_key_expanded : KS -> [96] -> ([128], KS)\nderive_key_expanded ks N = (mkKey parts1, expandKey1 (mkKey parts2))\n  where\n  parts1 # parts2 = [ drop (aes ks (N # i)) | i <- take [ 0 ... ]  ]\n\n  mkKey : {n} (fin n) => [n][64] -> [64 * n]\n  mkKey xs = join (reverse xs)\n\n\/** See Figure 1 in Section 3 *\/\ngcm_siv_plus :\n  {n} (64 >= width n) => ([128], KS) -> [96] -> [AAD] -> [n] -> ([n],[128])\ngcm_siv_plus (K1,K2) N AAD MSG = (unblockify Cs,TAG)\n  where\n\n  TAG     = aes K2 (0b0 # drop (T ^ (0 # N)))\n  T       = polyvalFrom K1 (A # M # [msg_len # aad_len]) 0\n  A       = blockify AAD\n  M       = blockify MSG\n  aad_len = `AAD : [64]\n  msg_len = `n   : [64]\n\n  _ # tUpper # tLower = TAG\n\n  Cs = counter_mode K2 (0b1 # tUpper, tLower) M\n\ncounter_mode : {n} KS -> ([96],[32]) -> [n][128] -> [n][128]\ncounter_mode K2 (tUpper,tLower) M =\n            [ aes K2 (tUpper # lower32 i) ^ m | m <- M | i <- [ 0 ... ] ]\n  where\n  lower32 i = tLower + i\n\n\/** See Section 2.2 *\/\npolyvalFrom : {n} (fin n) => [128] -> [n][128] -> [128] -> [128]\npolyvalFrom H Xs start = psums ! 0\n  where psums = [start] # [ dot (s ^ x) H | s <- psums | x <- Xs ]\n\n\/\/1 is not the identity for dot forcing it in next function instead\npolyvalFromNH : {n, hs} (fin n, fin hs, hs >=n) => [hs][128] -> [n][128] -> [128] -> [128]\npolyvalFromNH Hs Xs start = (sums ! 0) ^ (dot (([1] # Hs) @ (`n : [width n])) start)\n  where sums = [zero] # [ (dot X H) ^ sum'\n                        | sum' <- sums\n                        | X <- reverse Xs\n                        | H <- Hs ]\n\npolyvalHtableNH :\n  {n, hs} (fin n, fin hs, hs >=1) => [hs][128] -> [n][128] -> [128] -> [128]\npolyvalHtableNH Hs Xs start  = result\n  where sums = [start]\n             # [ polyvalFromNH Hs Xchunk sum'\n               | sum'   <- sums\n               | Xchunk <- split (take Xs): [n\/hs][hs][128]\n               ]\n        type W = n % hs\n        remainder = drop Xs : [W][128]\n        result =\n          if `W == (0 : [width (n % hs)]) then\n            sums ! 0\n          else\n            polyvalFromNH Hs remainder (sums!0)\n\npht : {a,size} (fin a,fin size,size>=2) => [128] -> [a][128] -> [128] -> Bit\npht H Xs start =\n  polyvalHtableNH (INIT_Htable`{size} H) Xs start == polyvalFrom H Xs start\n\ndot : [128] -> [128] -> [128]\ndot x y = mult x (mult y x_neg_128)\n  where x_neg_128 = <| 1 + x^^114 + x^^121 + x^^124 + x^^127 |>\n        \/\/ This is x^(-128)\n\nmult : [128] -> [128] -> [128]\nmult x y = pmod (pmult x y) irred\n  where\n  irred = <| 1 + x^^121 + x^^126 + x^^127 + x^^128 |>\n\nINIT_Htable : {n} (fin n, n>=2) => [128] -> [n][128]\nINIT_Htable H = take hs\n  where\n  hs = [H] # [ dot hn H\n                | hn <- hs]\n\n\/*polyval_Htable : {n} (fin n, n>=1) => [128] -> [n][128] -> [128]\npolyval_Htable H X = polyvalHtableNH`{hs=8} htable X\n  where\n    htable = INIT_Htable H\n\n\/\/ -----------------------------------------------------------------------------\n\nprop_poly : {a} (a >= 1, fin a) => [128] -> [a][128] -> Bit\nprop_poly H X = polyval_Htable H X == polyvalFrom H X zero\n*\/\nblockify : {n} (fin n) => [n] -> [n \/^ 128][128]\nblockify x = [ byteSwap b | b <- split (x # zero) ]\n\nunblockify : {n} (fin n) => [n \/^ 128][128] -> [n]\nunblockify xs = take (join [ byteSwap b | b <- xs ])\n\n\/\/ The spec uses byte-oriented little-endian representations.\n\/\/ This function changes back and forth.\nbyteSwap : {n} (fin n) => [8 * n] -> [8 * n]\nbyteSwap xs = join (reverse (split`{each=8} xs))\n\npolnhest1 = polyvalHtableNH`{hs=8,n=1}\n              ([0x551d5202e5be771d5964fbbd1dac89db]#zero)\n              \/\/(INIT_Htable 0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e)\n              [0x189308235800d2810a80a422032144fd]\n              (0x38020aa08800d28bf2fb37d447e1c479)\n\npolnhest2 = polyvalFrom\n                0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e\n                [0x189308235800d2810a80a422032144fd]\n                (0x38020aa08800d28bf2fb37d447e1c479)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/cryptol\/X86.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify a Cryptol module `X86` that defines AES-128 round wrappers (`aesenc`, `aesenclast`), carry-less multiplication `clmul`, and little-\/big-endian load\/store helpers (including array and AES state conversions) with the same types and behavior as in the given description."},{"role":"assistant","content":"```cryptol\nmodule X86 where\n\nimport AES128\n\naesenc : [128] -> [128] -> [128]\naesenc pt key =\n  aesStateToBits (aes_round (aesStateFromBits key)\n                            (aesStateFromBits pt))\n\naesenclast : [128] -> [128] -> [128]\naesenclast pt key =\n  aesStateToBits (aes_final_round (aesStateFromBits key)\n                                  (aesStateFromBits pt))\n\nclmul : [64] -> [64] -> [128]\nclmul x y = 0b0 # pmult x y\n\nleStore : {n} (fin n) => [n * 8] -> [n][8]\nleStore bits = reverse (split bits)\n\nleLoad : {n} (fin n) => [n][8] -> [n*8]\nleLoad bytes = join (reverse bytes)\n\nbeLoad : {n} (fin n) => [n][8] -> [n*8]\nbeLoad bytes = join bytes\n\nbeStore : {n} (fin n) => [n*8] -> [n][8]\nbeStore bits = split bits\n\nleLoadArray : {l,w} (fin l,fin w) => [l * w][8] -> [l][w * 8]\nleLoadArray bytes = [ leLoad mem | mem <- split bytes ]\n\nleStoreArray : {l,w} (fin l,fin w) => [l][w * 8] -> [l * w][8]\nleStoreArray arr = join [ leStore a | a <- arr ]\n\naesStateFromBytes : [16][8] -> State\naesStateFromBytes xs = transpose (split xs)\n\naesStateToBytes : State -> [16][8]\naesStateToBytes s = join (transpose s)\n\naesStateFromBits : [128] -> State\naesStateFromBits xs = aesStateFromBytes (leStore xs)\n\naesStateToBits : State -> [128]\naesStateToBits s = leLoad (aesStateToBytes s)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/doc\/tutorial\/code\/dotprod.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions `zip`, `sum`, and `dotprod` as given, and add a property stating that `dotprod xs ys` equals the summation of pairwise products of `xs` and `ys` for all valid inputs."},{"role":"assistant","content":"```cryptol\nzip : {n, a} (fin n, Arith a) => (a -> a -> a) -> [n]a -> [n]a -> [n]a\nzip f xs ys = [ f x y | x <- xs | y <- ys ]\n\nsum : {n, a} (fin n, fin a) => [n][a] -> [a]\nsum xs = ys!0\n  where ys = [0] # [ x + y | x <- xs | y <- ys ]\n\ndotprod : {n, a} (fin n, fin a) => [n][a] -> [n][a] -> [a]\ndotprod xs ys = sum (zip (*) xs ys)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/doc\/tutorial\/code\/NQueens.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formalizes the N-Queens problem using Board and Position types, the nQueens : {n} (fin n, n >= 1) => Board n -> Bit function, and prove the property nQueensProve x = (nQueens x) == False for all valid boards x."},{"role":"assistant","content":"```cryptol\nall : {n, a} (fin n) => (a -> Bit, [n]a) -> Bit\nall (f, xs) = [ f x | x <- xs ] == ~zero\n\ncontains xs e = [ x == e | x <- xs ] != zero\n\ndistinct : {n,a} (fin n, Cmp a) => [n]a -> Bit\ndistinct xs =\n    [ if n1 < n2 then x != y else True\n    | (x,n1) <- numXs , (y,n2) <- numXs\n    ] == ~zero\n  where\n  numXs = [ (x,n) | x <- xs | n <- [ (0:[width n]) ... ] ]\n\ntype Position n = [width (n - 1)]\n\ntype Board n = [n](Position n)\n\ntype Solution n = Board n -> Bit\n\ncheckDiag : {n} (fin n, n >= 1) => Board n -> (Position n, Position n) -> Bit\ncheckDiag qs (i, j) = (i >= j) || (diffR != diffC)\n  where   qi = qs @ i\n          qj = qs @ j\n          diffR = if qi >= qj then qi-qj else qj-qi\n          diffC = j - i                   \nnQueens : {n} (fin n, n >= 1) => Solution n\nnQueens qs = all (inRange qs, qs) && all (checkDiag qs, ijs `{n}) && distinct qs\n\nijs : {n}(fin n, n>= 1)=> [_](Position n, Position n)\nijs = [ (i, j) | i <- [0 .. (n-1)], j <- [0 .. (n-1)]]\n\ninRange : {n} (fin n, n >= 1) => Board n -> Position n -> Bit\ninRange qs x = x <= `(n - 1)\n\nproperty nQueensProve x = (nQueens x) == False\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/doc\/tutorial\/code\/ffs.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines functions ffs_ref : [32] -> [32] and ffs_imp : [32] -> [32] for finding the first set bit in a 32-bit word, and a property ffs_correct that proves ffs_ref x == ffs_imp x for all x."},{"role":"assistant","content":"```cryptol\nffs_ref: [32] -> [32]\nffs_ref x = ixs!0 where\n    ixs = [0] # [ if (x && (1 << i)) != 0 then (i+1) else prev\n                | prev <- ixs\n                | i <- [31, 30 .. 0]:[32][32]\n                ]\n\nffs_imp: [32] -> [32]\nffs_imp i = if (i'''' > 0) then (n'''' + ((i'''' + 1) && 1)) else 0 where\n    n = 1\n    (n', i') =       if (zero==(i && 0x0000ffff))    then (n + 16, i >> 16) else (n, i)\n    (n'', i'') =     if (zero==(i' && 0x000000ff))   then (n' + 8, i' >> 8) else (n', i')\n    (n''', i''') =   if (zero==(i'' && 0x0000000f))  then (n'' + 4, i'' >> 4) else (n'',i'')\n    (n'''', i'''') = if (zero==(i''' && 0x00000003)) then (n''' + 2, i''' >> 2) else (n''', i''')\n\nproperty ffs_correct x = ffs_ref x == ffs_imp x\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/examples\/sequential_aigs\/fib.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that (1) prove fib1 and fib2 are equivalent on all input streams, and (2) show that each mk_buggy_fib magic-parameterized state machine is not equivalent to fib1 by exhibiting a counterexample input where the outputs differ."},{"role":"assistant","content":"```cryptol\nimport StateMachine\n\nfib1_no_init : ([1], ([8], [8])) -> ([8], ([8], [8]))\nfib1_no_init (_, (fn, fn1)) = (fn, (fn1, fn2))\n  where\n  fn2 = fn + fn1\n\nfib1 = init_with (0, 1) fib1_no_init\nfib1_state_bits = 1 + 8 + 8 : [8]\n\nfib2 : ([1], ([1], [16], [16])) -> ([8], ([1], [16], [16]))\nfib2 (_, (start, fn , fn1)) = (fn', (1, fn1', fn2))\n  where\n    fn1' = (zero # start) * fn1 + (zero # ~start)\n  fn2 = fn + fn1'\n  fn' = drop`{8} fn\n\nfib2_state_bits = 1 + 16 + 16 : [8]\n\n\/\/ Make a buggy version of fib state machine which returns wrong value\n\/\/ when state counter has magic value.\n\/\/\n\/\/ If this were a common pattern for example generation, we could\n\/\/ make a \"magic-value bug\" combinator in the style of 'init_with'.\nmk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n    fn' = fn + (if k == magic then 1 else 0)\n\nmk_buggy_fib magic = init_with (0, 1, 0) (mk_buggy_fib_no_init magic)\ncount_buggy_state_bits : {a} (fin a, width a <= 7) => [a] -> [8]\ncount_buggy_state_bits magic = 1 + 8 + 8 + `a\n\n\/\/ 4-bit counter\nbuggy_fib4_magic = 0xf\nbuggy_fib4 = mk_buggy_fib buggy_fib4_magic\nbuggy_fib4_state_bits = count_buggy_state_bits buggy_fib4_magic\n\n\/\/ 8-bit counter\nbuggy_fib8_magic = 0xff\nbuggy_fib8 = mk_buggy_fib buggy_fib8_magic\nbuggy_fib8_state_bits = count_buggy_state_bits buggy_fib8_magic\n\n\/\/ 12-bit counter\nbuggy_fib12_magic = 0b111111111111\nbuggy_fib12 = mk_buggy_fib buggy_fib12_magic\nbuggy_fib12_state_bits = count_buggy_state_bits buggy_fib12_magic\n\n\/\/ 16-bit counter\nbuggy_fib16_magic = 0xffff\nbuggy_fib16 = mk_buggy_fib buggy_fib16_magic\nbuggy_fib16_state_bits = count_buggy_state_bits buggy_fib16_magic\n\n\/\/ 32-bit counter\nbuggy_fib32_magic = 0xffffffff\nbuggy_fib32 = mk_buggy_fib buggy_fib32_magic\nbuggy_fib32_state_bits = count_buggy_state_bits buggy_fib32_magic\n\n\/\/ 64-bit counter\nbuggy_fib64_magic = 0xffffffffffffffff\nbuggy_fib64 = mk_buggy_fib buggy_fib64_magic\nbuggy_fib64_state_bits = count_buggy_state_bits buggy_fib64_magic\n\n\/\/ Tests.\ninputs : [1000][1]\ninputs = zero\n\ntest = equiv fib1 fib2 inputs\n\n\/\/ The states sequences.\nstates1 = exec fib1 inputs\nstates2 = exec fib2 inputs\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/examples\/sequential_aigs\/CipherMode.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the `CipherMode` module with the given block-cipher type alias `BC` and the state-machine based cipher modes `ecb`, `cbc`, `pcbc`, `cfb`, `ofb`, and `ctr` using `SM` and `init` from `StateMachine` with the same types and behavior."},{"role":"assistant","content":"```cryptol\nmodule CipherMode where\n\nimport StateMachine\n\ntype BC k n = [k] -> [n] -> [n]\n\necb : {k, n} BC k n -> SM ([k], [n]) [n] (Bool, [k])\necb bc = init i sm\n  where\n  sm : SM [n] [n] [k]\n  sm (block, key) = (ct, key)\n    where\n    ct = bc key block\n  i : [k] -> [k]\n  i key = key\n\ncbc : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\ncbc bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key (state ^ block)\n    state' = ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\npcbc : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\npcbc bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key (state ^ block)\n    state' = block ^ ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\ncfb : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\ncfb bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key state ^ block\n    state' = ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\nofb : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\nofb bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    state' = bc key state\n    ct = state' ^ block\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\n\/\/ CounTer Mode.\nctr : {k, n} (fin n, n >= 1) =>\n  BC k (2*n) -> SM (([k], [n]), [2*n]) [2*n] (Bool, ([k], [n], [n]))\nctr bc = init i sm\n  where\n  sm : SM [2*n] [2*n] ([k], [n], [n])\n  sm (block, (key, iv, counter)) = (ct, (key, iv, counter + 1))\n    where\n    ct = bc key (iv # counter) ^ block\n  i : ([k], [n]) -> ([k], [n], [n])\n  i (key, iv) = (key, iv, 0)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/examples\/sequential_aigs\/exp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that proves the optimized exponentiation state machine `exp_opt` is functionally equivalent to the reference exponentiation state machine `exp_ref` for all valid inputs, using the provided `synced_exp` or `mitered_exp` state machines as appropriate."},{"role":"assistant","content":"```cryptol\nimport StateMachine\n\nexp_ref : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) (Bool, [m]) (Bool, ([m], [n], [m]))\nexp_ref = mk_loop (\\(x, p) -> (x, p, 1)) body\n  where\n  body : Body [m] ([m], [n], [m])\n  body (x, p', r) =\n    if p' == 0\n    then ((True, r), (x, p', r))\n    else ((False, zero), (x, p' - 1, r * x))\n\nexp_opt : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) (Bool, [m]) (Bool, ([m], [n], [m]))\nexp_opt = mk_loop (\\(x, p) -> (x, p, 1)) body\n  where\n  body : Body [m] ([m], [n], [m])\n  body (x', p', r) =\n    if p' == 0\n    then ((True, r), (x', p', r))\n    else ((False, zero), (x' * x', p' >> 1, r'))\n      where\n      r' = if (p' && 1) != 0\n           then r * x'\n           else r\n\nsynced_exp : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  [1] -> SM ([m], [n]) (Bool, [m]) ((Bool, ([m], [n], [m])), (Bool, ([m], [n], [m])))\nsynced_exp bias = sync_loops bias exp_ref exp_opt\n\nmitered_exp : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) Bool ((Bool, ([m], [n], [m])), (Bool, ([m], [n], [m])))\nmitered_exp = miter_loops exp_ref exp_opt\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/examples\/sequential_aigs\/StateMachine.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the state-machine combinators `SM`, `run`, `eval`, `exec`, `equiv`, `init_with`, `init`, `miter`, `mk_loop`, `run_loop`, `sync_loops`, and `miter_loops`, including their types and behavior as in a generic sequential state-machine framework."},{"role":"assistant","content":"```cryptol\nmodule StateMachine where\n\ntype SM i o s = (i, s) -> (o, s)\n\nrun : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](o,s)\nrun sm is = oss\n  where\n  states = [zero] # [ os.1 | os <- oss ]\n  oss = [ sm (i, s) | i <- is | s <- states ]\n\neval : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](o)\neval sm is = [ os.0 | os <- run sm is ]\n\nexec : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](s)\nexec sm is = [ os.1 | os <- run sm is ]\n\nequiv : {n, i, s1, s2, o} (Cmp o, fin n, Zero s1, Zero s2)\n     => SM i o s1 -> SM i o s2 -> [n]i -> Bool\nequiv sm1 sm2 is = all [ o1 == o2 | o1 <- eval sm1 is | o2 <- eval sm2 is ]\n  where\n  all : {m} (fin m) => [m]Bool -> Bool\n  all xs = its ! 0\n    where\n    its = [True] # [ x && it | x <- xs | it <- its ]\n\ninit_with : {i, o, s} s -> SM i o s -> SM i o (Bool, s)\ninit_with s_initial sm (i, (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else s_initial\n  (o, s'') = sm (i, s')\n\ninit : {a, i, o, s}\n  (a -> s) -> SM i o s -> SM (a, i) o (Bool, s)\ninit mk_s_initial sm ((a, i), (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else mk_s_initial a\n  (o, s'') = sm (i, s')\n\nmiter : {i, o, s1, s2} (Cmp o) =>\n  SM i o s1 -> SM i o s2 -> SM i Bool (s1, s2)\nmiter sm1 sm2 (i, (s1, s2)) = (o, (s1', s2'))\n  where\n  (o1, s1') = sm1 (i, s1)\n  (o2, s2') = sm2 (i, s2)\n  o = o1 != o2\n\nconst_false : {i} SM i Bool [1]\nconst_false (_, _) = (False, zero)\n\nconst_true : {i} SM i Bool [1]\nconst_true (_, _) = (True, zero)\n\nsat_miter : SM [1] Bool ([1], [1])\nsat_miter = miter const_true const_false\nunsat_miter : SM [1] Bool ([1], [1])\nunsat_miter = miter const_true const_true\n\ntype Body o s = s -> ((Bool, o), s)\n\nmk_loop : {i,o,s} (i -> s) -> Body o s -> SM i (Bool, o) (Bool, s)\nmk_loop initializer body (i, (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else initializer i\n  (o, s'') = body s'\n\nrun_loop : {n, i, o, s} (fin n, n >= 1, Zero i, Zero s) =>\n  SM i o s -> i -> [n](o, s)\nrun_loop loop i = run loop ([i] # zero)\n\nsync_loops : {i, o, s1, s2} (Zero o) =>\n  [1] -> SM i (Bool, o) s1 -> SM i (Bool, o) s2 -> SM i (Bool, o) (s1, s2)\nsync_loops bias l1 l2 (i, (s1, s2)) = ((done, o'), (s1', s2'))\n  where\n  ((done1, o1), s1') = l1 (i, s1)\n  ((done2, o2), s2') = l2 (i, s2)\n  o = [o1, o2] @ bias\n  done = done1 && done2\n  o' = if done then o else zero\n\nmiter_loops : {i, o, s1, s2} (Cmp o) =>\n  SM i (Bool, o) s1 -> SM i (Bool, o) s2 -> SM i Bool (s1, s2)\nmiter_loops l1 l2 (i, (s1, s2)) = (o', (s1', s2'))\n  where\n  ((done1, o1), s1') = l1 (i, s1)\n  ((done2, o2), s2') = l2 (i, s2)\n  done = done1 && done2\n  o' = if done then o1 != o2 else False\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/examples\/openssl_aes\/AES128TBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that implements AES-128 encryption and decryption using T-tables, including key expansion and inverse operations, and define properties showing encryption\/decryption round-trip correctness, S-box\/Inv S-box are inverses, key expansion is injective, and that known-answer test vectors match the FIPS-197 AES-128 example."},{"role":"assistant","content":"```cryptol\nmodule AESTBox where\n\ntype GF28 = [8]\ntype Nk = 4\ntype Nb = 4\ntype Nr = 6 + Nk\n\ntype State = [4][Nb * 8]\ntype Key = [Nk][Nb * 8]\ntype RoundKey = State\ntype KS = (RoundKey, [Nr - 1]RoundKey, RoundKey)\n\ngf28Mult : GF28 -> GF28 -> GF28\ngf28Mult x y = pmod (pmult x y) <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Pow : GF28 -> [8] -> GF28\ngf28Pow n k =\n  if k == 0 then 1\n  else\n    (if (k && 1) == 1 then gf28Mult n w\n     else w\n       where v = gf28Pow n (k >> 1)\n             w = gf28Mult v v)\n\ntoBytes : [32] -> [4]GF28\ntoBytes x = split`{4} x\n\nfromBytes : [4]GF28 -> [32]\nfromBytes xs = join xs\n\nrotR : [4]GF28 -> [2] -> [4]GF28\nrotR xs n = xs >>> n\n\nroundConstants = take`{16} ([0] # [ gf28Pow 2 (k-1) | k <- [1 ... ] ])\n\nsbox = [ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n         0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n         0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n         0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n         0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n         0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n         0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n         0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n         0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n         0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n         0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n         0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n         0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n         0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n         0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n         0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n         0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n         0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n         0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n         0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n         0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n         0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n         0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n         0x54, 0xbb, 0x16]\n\nunsbox = [ unsboxf i sboxit 0 0 | i <- [ 0 .. 255] ]\n  where sboxit = [ (j, i) | i <- [ 0 .. 255] | j <- sbox ]\n        unsboxf n t i d = if i >= (length t) then d\n                          else (if (k == n) then v\n                                else unsboxf n t (i + 1) d\n                                  where (k, v) = t @ i)\n\naddRoundKey : RoundKey -> State -> State\naddRoundKey k s = k ^ s\n\nkeyExpansion : Key -> [inf]RoundKey\nkeyExpansion key = chop4 keys\n  where keys = key # [nextWord i prev old | i <- [ `Nk ... ] | prev <- drop`{Nk-1} keys | old <- keys]\n        chop4 : {a} [inf]a -> [inf][4]a\n        chop4 xs = split xs\n        subWordRcon : [Nb * 8] -> GF28 -> [Nb * 8]\n        subWordRcon w rc = fromBytes [a ^ rc, b, c, d]\n          where [a, b, c, d] = [ sbox @ i | i <- toBytes w ]\n        nextWord : [8] -> [Nb * 8] -> [Nb * 8] -> [Nb * 8]\n        nextWord i prev old = old ^\n          (if (i % `Nk) == 0 then subWordRcon (join (split`{4} prev <<< 1)) (roundConstants @ (i \/ `Nk))\n           else if (i % `Nk) == 4 \/\\ `Nk > 6 then subWordRcon prev 0\n           else prev)\n\nmETable = [ gf28Mult 0x0E i | i <- [ 0 .. 255 ] ]\nmBTable = [ gf28Mult 0x0B i | i <- [ 0 .. 255 ] ]\nmDTable = [ gf28Mult 0x0D i | i <- [ 0 .. 255 ] ]\nm9Table = [ gf28Mult 0x09 i | i <- [ 0 .. 255 ] ]\nmE i = mETable @ i\nmB i = mBTable @ i\nmD i = mDTable @ i\nm9 i = m9Table @ i\ntables = [ [mE, mB, mD, m9],\n           [m9, mE, mB, mD],\n           [mD, m9, mE, mB],\n           [mB, mD, m9, mE] ]\n\ninvMixColumns : State -> State\ninvMixColumns state = [ fromBytes ce | ce <- transpose (mmult [ toBytes se | se <- state ]) ]\n  where dollar f x = f x\n        dot f fs =  foldr1 (^) (zipWith dollar f fs)\n        mmult n = [ [ (dot r) ne | ne <- n ] | r <- tables ]\n\naesEncryptKeySchedule : Key -> KS\naesEncryptKeySchedule key = (rKeys @ 0, m, rKeys @ `Nr)\n  where rKeys = keyExpansion key\n        m = take`{Nr-1}(tail rKeys)\n\naesDecryptKeySchedule : Key -> KS\naesDecryptKeySchedule key = (rKeys @ `Nr, m, rKeys @ 0)\n  where rKeys = keyExpansion key\n        m = [ invMixColumns k | k <- reverse (take`{Nr-1}(tail rKeys)) ]\n\ndoRounds : {a, b} (fin b) => (Bit -> State -> a -> State) -> (RoundKey, [b]a, a) -> State -> State\ndoRounds rnd (ikey, rkeys, fkey) sIn = rnd True (rs ! 0) fkey\n  where s0 = addRoundKey ikey sIn\n        rs = [s0] # [ rnd False s k | s <- rs | k <- rkeys ]\n\nt0Func : GF28 -> [4]GF28\nt0Func a = [gf28Mult s 2, s, s, gf28Mult s 3] where s = sbox @ a\nt0 = [fromBytes (t0Func a) | a <- [0..255]]\nt1 = [fromBytes (rotR (t0Func a) 1) | a <- [0..255]]\nt2 = [fromBytes (rotR (t0Func a) 2) | a <- [0..255]]\nt3 = [fromBytes (rotR (t0Func a) 3) | a <- [0..255]]\n\naesRound : Bit -> State -> RoundKey -> State\naesRound isFinal s key = addRoundKey d key\n  where d = [ f isFinal i | i <- [ 0 .. 3] ]\n        a = [ toBytes se | se <- s ]\n        f b j = if b then\n                  fromBytes [ sbox @ (a @ ((j+0) % 4) @ 0),\n                              sbox @ (a @ ((j+1) % 4) @ 1),\n                              sbox @ (a @ ((j+2) % 4) @ 2),\n                              sbox @ (a @ ((j+3) % 4) @ 3) ]\n                else\n                  e0 ^ e1 ^ e2 ^ e3\n                    where e0 = t0 @ (a @ ((j+0) % 4) @ 0)\n                          e1 = t1 @ (a @ ((j+1) % 4) @ 1)\n                          e2 = t2 @ (a @ ((j+2) % 4) @ 2)\n                          e3 = t3 @ (a @ ((j+3) % 4) @ 3)\n\nu0Func : GF28 -> [4]GF28\nu0Func a = [gf28Mult s 0x0E, gf28Mult s 0x09, gf28Mult s 0x0D, gf28Mult s 0x0B] where s = unsbox @ a\nu0 = [fromBytes (u0Func a) | a <- [0..255]]\nu1 = [fromBytes (rotR (u0Func a) 1) | a <- [0..255]]\nu2 = [fromBytes (rotR (u0Func a) 2) | a <- [0..255]]\nu3 = [fromBytes (rotR (u0Func a) 3) | a <- [0..255]]\n\naesInvRound : Bit -> State -> RoundKey -> State\naesInvRound isFinal s key = addRoundKey d key\n  where d = [ f isFinal i | i <- [ 0 .. 3] ]\n        a = [ toBytes se | se <- s ]\n        f b j = if b then\n                  fromBytes [ unsbox @ (a @ ((j+0) % 4) @ 0),\n                              unsbox @ (a @ ((j+3) % 4) @ 1),\n                              unsbox @ (a @ ((j+2) % 4) @ 2),\n                              unsbox @ (a @ ((j+1) % 4) @ 3) ]\n                else\n                  e0 ^ e1 ^ e2 ^ e3\n                    where e0 = u0 @ (a @ ((j+0) % 4) @ 0)\n                          e1 = u1 @ (a @ ((j+3) % 4) @ 1)\n                          e2 = u2 @ (a @ ((j+2) % 4) @ 2)\n                          e3 = u3 @ (a @ ((j+1) % 4) @ 3)\n\naesEncrypt pt key = doRounds aesRound (aesEncryptKeySchedule key) pt\n\naesDecrypt ct key = doRounds aesInvRound (aesDecryptKeySchedule key) ct\n\nproperty t128EncTest = aesEncrypt pt k == [0x69c4e0d8, 0x6a7b0430, 0xd8cdb780, 0x70b4c55a]\n  where pt = [ 0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff ]\n        k = [ 0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f ]\n\nproperty t128DecTest = aesDecrypt ct k == [0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff]\n  where ct = [ 0x69c4e0d8, 0x6a7b0430, 0xd8cdb780, 0x70b4c55a ]\n        k = [ 0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f ]\n\nproperty AESTests = t128EncTest && t128DecTest\n\nproperty sboxUnsboxInverse (n : [8]) = n == (unsbox @ (sbox @ n))\n\nproperty keyExpansionInjective k1 k2 =\n  if k1 != k2\n  then aesEncryptKeySchedule k1 != aesEncryptKeySchedule k2\n  else True\n\nproperty encDecInverse pt k = (aesDecrypt (aesEncrypt pt k) k) == pt\n\nfoldr : {a,b,n} (fin n) => (a -> b -> b) -> b -> [n]a -> b\nfoldr f acc xs = ys ! 0\n  where ys = [acc] # [f x a | a <- ys | x <- reverse xs]\n\nfoldr1 : {a, b} (fin b) => (a -> a -> a) -> [1 + b]a -> a\nfoldr1 f xs = foldr f (xs @ 0) (tail xs)\n\nzipWith : {a,b,c,n} (a -> b -> c) -> [n]a -> [n]b -> [n]c\nzipWith f xs ys = [f x y | x <- xs | y <- ys]\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/examples\/llvm\/iterative_average\/test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the given incremental averaging state machine (State, init, updatef, digest, avg) and the property imp_correct : {n} (fin n, 32 >= width n) => [n][32] -> Bool asserting avg xs == digest (updatef init xs) for all xs, suitable for formal verification."},{"role":"assistant","content":"```cryptol\ntype State =\n  { sum : [32]\n  , len : [32]\n  }\n\ninit : State\ninit =\n  { sum = 0\n  , len = 0\n  }\n\nupdatef : {n} (fin n, 32 >= width n) => State -> [n][32] -> State\nupdatef st xs =\n  { sum = st.sum + sum\n  , len = st.len + `n\n  }\n  where\n    sum = sums!0\n    sums = [ 0 ] # [ acc + x | acc <- sums | x <- xs ]\n\ndigest : State -> [32]\ndigest st = st.sum \/ st.len\n\navg : {n} (fin n, 32 >= width n) => [n][32] -> [32]\navg xs = sum \/ `n\n  where\n    sum = sums!0\n    sums = [ 0 ] # [ acc + x | acc <- sums | x <- xs ]\n\nimp_correct : {n} (fin n, 32 >= width n) => [n][32] -> Bool\nproperty imp_correct xs = avg xs == digest (updatef init xs)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/examples\/llvm\/union\/test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that verify the union-style state encoding is consistent by proving bits_to_inc_1_st and inc_1_st_to_bits are inverses on the first 32 bits, bits_to_inc_2_st and inc_2_st_to_bits are inverses on all 64 bits, and that inc correctly dispatches to inc_1 or inc_2 based on alg."},{"role":"assistant","content":"```cryptol\ntype Alg = [32]\nINC_1 = 0 : Alg\nINC_2 = 1 : Alg\n\ntype Inc_1_st =\n  { x : [32]\n  }\n\ntype Inc_2_st =\n  { x : [32]\n  , y : [32]\n  }\n\ntype UNION_BITS = 32+32\n\ntype St =\n  { alg : Alg\n  , bits : [UNION_BITS]\n  }\n\nbits_to_inc_1_st : [UNION_BITS] -> Inc_1_st\nbits_to_inc_1_st bits = { x = take`{32} bits }\n\ninc_1_st_to_bits : [UNION_BITS] -> Inc_1_st -> [UNION_BITS]\ninc_1_st_to_bits bits st = st.x # drop`{32} bits\n\nbits_to_inc_2_st : [UNION_BITS] -> Inc_2_st\nbits_to_inc_2_st bits = { x = take`{32} bits, y = drop`{32} bits }\ninc_2_st_to_bits : Inc_2_st -> [UNION_BITS]\ninc_2_st_to_bits st = st.x # st.y\n\ninc : St -> St\ninc st = { alg = st.alg, bits = bits }\n  where\n    bits =\n      if st.alg == INC_1 then\n        inc_1_st_to_bits st.bits\n          (inc_1 (bits_to_inc_1_st st.bits))\n      else\n        inc_2_st_to_bits\n          (inc_2 (bits_to_inc_2_st st.bits))\n\ninc_1 : Inc_1_st -> Inc_1_st\ninc_1 st = { x = st.x + 1 }\n\ninc_2 : Inc_2_st -> Inc_2_st\ninc_2 st = { x = st.x + 1, y = st.y + 1}\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/intTests\/test_FNV_a1_rev\/FNV_a1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the 64-bit FNV-1a hash, including pad, fnv1a, saltHash, and a property testsPass asserting the given known-answer tests and the break predicate over secret1 and saltHashCorrect."},{"role":"assistant","content":"```cryptol\nfnv1a : {n} (fin n) => [n] -> [64]\nfnv1a ws = fnv1a' (pad ws)\n\npad : {msgLen,chunks,padding}\n     ( fin chunks\n     , fin msgLen\n     , chunks     == (msgLen+7) \/ 8\n     , padding    == (8 - msgLen % 8) % 8\n     )\n     => [msgLen] -> [chunks][8]\npad msg = split (msg # (zero:[padding]))\n\nfnv1a' : {chunks} (fin chunks) => [chunks][8] -> [64]\nfnv1a' msg = Ss ! 0\n  where\n   Ss = [fnv1a_offset_basis] #\n           [ block s m\n           | s <- Ss\n           | m <- msg\n           ]\n\nblock : {padding} ( fin padding, padding == 64 - 8) => [64] -> [8] -> [64]\nblock state val = (state ^ ((zero : [padding]) # val)) * fnv1a_prime\n\nfnv1a_offset_basis : [64]\nfnv1a_offset_basis = 14695981039346656037\n\nfnv1a_prime : [64]\nfnv1a_prime = 1099511628211\n\nt1 = fnv1a [] == 0xcbf29ce484222325\nt2 = fnv1a (join \"a\") == 0xaf63dc4c8601ec8c\nt3 = fnv1a (join \"foobar\") == 0x85944171f73967e8\n\nproperty testsPass = [t1, t2, t3] == ~zero\n\nbreak : {n} (fin n) => [4]([64],[64]) -> [n][8] -> Bit\nbreak pairs secret = ~zero == [saltHashCorrect p secret | p <- pairs]\n\nsecret1 : [4]([64],[64])\nsecret1 = [ (`0    , saltHash `0x0   msg)\n          , (`0xF  , saltHash `0xF   msg)\n          , (`0xFF , saltHash `0xFF  msg)\n          , (`0xFFF, saltHash `0xFFF msg)\n          ]\n  where msg = \"Secret Message\"\n\nsaltHashCorrect : {n} (fin n) => ([64],[64]) -> [n][8] -> Bit\nsaltHashCorrect (salt,result) secret = saltHash salt secret == result\n\nsaltHash : {n} (fin n) => [64] -> [n][8] -> [64]\nsaltHash s msg = fnv1a (s # join msg)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/intTests\/test0000\/mutRecTest.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that specify and verify that streamFibs, streamFibsAlt, recFibs, and recFibs2 each produce the same Fibonacci sequence values for all 8-bit inputs, and that zx correctly zero-extends its input to the wider bit-width."},{"role":"assistant","content":"```cryptol\nstreamFibs : [8] -> [32]\nstreamFibs x = fibs0@x\n   where fibs0 = [0]#fibs1\n         fibs1 = [1]#[ a + b | a <- fibs0\n                             | b <- fibs1\n                     ]\n\nstreamFibsAlt : [8] -> [32]\nstreamFibsAlt x = fibs@x\n   where fibs = [0,1]#[ a + b | a <- fibs\n                              | b <- drop`{1} fibs\n                      ]\n\nrecFibs : [8] -> [32]\nrecFibs n = if n > 1  then recFibs (n-1) + recFibs (n-2) else zx n\n\nzx : {a, b} (fin a, fin b) => [b] -> [a+b]\nzx m = zero#m\n\nrecFibs2 : [8] -> [32]\nrecFibs2 n =\n  if n == 0 then 0\n   | n == 1 then 1\n   else recFibs2 (n-1) + recFibs2 (n-2)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/intTests\/test0037_popcount\/spec.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions `popcount : {n} (n >= 1, fin n) => [n] -> [n]`, `clz : {n} fin n => [n] -> [n]`, and `ctz : {n} fin n => [n] -> [n]`, and includes properties formally verifying their expected bit-counting behaviors."},{"role":"assistant","content":"```cryptol\npopcount : {n} (n >= 1, fin n) => [n] -> [n]\npopcount x = foldr (+) zero [ if b then 1 else 0 | b <- x ]\n\nclz : {n} fin n => [n] -> [n]\nclz x = foldr f `n [ (b,i) | i <- [0 ...] | b <- x ]\n where\n f (b,i) r = if b then i else r\n\nctz : {n} fin n => [n] -> [n]\nctz x = clz (reverse x)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/Common\/AES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Common::AES that implements AES encryption over GF(2^8), including key expansion, rounds, S-box, and the top-level function aesEncrypt : [AESKeySize] -> [128] -> [128] parameterized by Mode with 2 >= Mode."},{"role":"assistant","content":"```cryptol\nmodule Common::AES where\n\nparameter\n  type Mode : #\n  type constraint (2 >= Mode)\n\ntype AESKeySize  = 32 * Nk\n\naesEncrypt : [AESKeySize] -> [128] -> [128]\naesEncrypt key pt = aesEncryptWithSchedule (ExpandKey key) pt\n\naes_round : RoundKey -> State -> State\naes_round k s =\n  k ^ transpose\n        [ t 0 ^ t 1 ^ t 2 ^ t 3 where t n = tbox n (s @ n @ (j + n))\n        | j <- [ 0 .. 3 ]\n        ]\n\ntbox : [2] -> GF28 -> [4]GF28\ntbox n x = (T0_table @ x) >>> n\n\nT0_table : [256][4] GF28\nT0_table = [ [gf28Mult (2, s), s, s, gf28Mult (3, s) ] | s <- sbox ]\n\naes_final_round : RoundKey -> State -> State\naes_final_round k s = AESFinalRound (k,s)\n\nencryptState : KeySchedule -> State -> State\nencryptState (kInit, ks, kFinal) pt = aes_final_round kFinal (rounds ! 0)\n  where\n  state0 = AddRoundKey (kInit, pt)\n  rounds = [state0] # [ aes_round rk s | rk <- ks | s <- rounds ]\n\naesEncryptWithSchedule : KeySchedule -> [128] -> [128]\naesEncryptWithSchedule ks pt = stateToMsg (encryptState ks (msgToState pt))\n\ntype Nk = 4 + 2 * Mode\ntype Nb = 4\ntype Nr = 6 + Nk\n\ntype GF28        = [8]\ntype State       = [4][Nb]GF28\ntype RoundKey    = State\ntype KeySchedule = (RoundKey, [Nr-1]RoundKey, RoundKey)\n\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Mult : (GF28, GF28) -> GF28\ngf28Mult (x, y) = pmod(pmult x y) irreducible\n\ngf28Pow : (GF28, [8]) -> GF28\ngf28Pow (n, k) = pow k\n  where   sq x  = gf28Mult (x, x)\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult(n, sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow (x, 254)\n\ngf28DotProduct : {n} (fin n) => ([n]GF28, [n]GF28) -> GF28\ngf28DotProduct (xs, ys) = gf28Add [ gf28Mult (x, y) | x <- xs\n                                                    | y <- ys ]\ngf28VectorMult : {n, m} (fin n) => ([n]GF28, [m][n]GF28) -> [m]GF28\ngf28VectorMult (v, ms) = [ gf28DotProduct(v, m) | m <- ms ]\n\ngf28MatrixMult : {n, m, k} (fin m) => ([n][m]GF28, [m][k]GF28) -> [n][k]GF28\ngf28MatrixMult (xss, yss) = [ gf28VectorMult(xs, yss') | xs <- xss ]\n   where yss' = transpose yss\n\nxformByte : GF28 -> GF28\nxformByte b = gf28Add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n   where c = 0x63\n\nxformByte' : GF28 -> GF28\nxformByte' b = gf28Add [(b >>> 2), (b >>> 5), (b >>> 7), d] where d = 0x05\nSubByte : GF28 -> GF28\nSubByte b = xformByte (gf28Inverse b)\n\nSubByte' : GF28 -> GF28\nSubByte' b = sbox@b\n\nSubBytes : State -> State\nSubBytes state = [ [ SubByte' b | b <- row ] | row <- state ]\n\n\/\/ The ShiftRows transform and its inverse\nShiftRows : State -> State\nShiftRows state = [ row <<< shiftAmount | row <- state\n                                        | shiftAmount : [2] <- [0 .. 3]\n                  ]\n\n\/\/ The MixColumns transform and its inverse\nMixColumns : State -> State\nMixColumns state = gf28MatrixMult (m, state)\n    where m = [[2, 3, 1, 1],\n               [1, 2, 3, 1],\n               [1, 1, 2, 3],\n               [3, 1, 1, 2]]\n\n\/\/ The AddRoundKey transform\nAddRoundKey : (RoundKey, State) -> State\nAddRoundKey (rk, s) = rk ^ s\n\n\/\/ Key expansion\nRcon : [8] -> [4]GF28\nRcon i = [(gf28Pow (<| x |>, i-1)), 0, 0, 0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord bs = [ SubByte' b | b <- bs ]\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nNextWord : ([8],[4][8],[4][8]) -> [4][8]\nNextWord(i, prev, old) = old ^ mask\n   where mask = if i % nk == 0\n                then SubWord(RotWord(prev)) ^ Rcon (i \/ `Nk)\n                else if (nk > 6) && (i % nk == 4)\n                     then SubWord(prev)\n                     else prev\n\n         nk = `Nk : [8]\n\nExpandKeyForever : [Nk][4][8] -> [inf]RoundKey\nExpandKeyForever seed = [ transpose g | g <- groupBy`{4} (keyWS seed) ]\n\nkeyWS : [Nk][4][8] -> [inf][4][8]\nkeyWS seed    = xs\n     where xs = seed # [ NextWord(i, prev, old)\n                       | i    <- [ `Nk ... ]\n                       | prev <- drop`{Nk-1} xs\n                       | old  <- xs\n                       ]\n\nExpandKey : [AESKeySize] -> KeySchedule\nExpandKey key = ( keys @ 0\n                , keys @@ ([1 .. (Nr - 1)] : [_][8])\n                , keys @ (`Nr : [8])\n                )\n  where   seed : [Nk][4][8]\n          seed = split (split key)\n          keys = ExpandKeyForever seed\n\nfromKS : KeySchedule -> [Nr+1][4][32]\nfromKS (f, ms, l) = [ formKeyWords (transpose k) | k <- [f] # ms # [l] ]\n    where formKeyWords bbs = [ join bs | bs <- bbs ]\n\nAESRound : (RoundKey, State) -> State\nAESRound (rk, s) = AddRoundKey (rk, MixColumns (ShiftRows (SubBytes s)))\n\nAESFinalRound : (RoundKey, State) -> State\nAESFinalRound (rk, s) = AddRoundKey (rk, ShiftRows (SubBytes s))\n\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\nsbox : [256]GF28\nsbox = [\n 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n 0x54, 0xbb, 0x16]\n```"}]}
{"filename":"aws-lc-verification\/SAW\/spec\/AES\/AES-GCM-implementation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol that the AES-GCM AVX-based GHASH and cipher functions (including gcm_polyval_mul_pmult3\/4, gcm_polyval_red_pmult, gcm_polyval_avx, gcm_ghash_avx, and aesni_gcm_cipher_block6) are functionally equivalent to the reference AES-256-GCM specification for all valid inputs."},{"role":"assistant","content":"```cryptol\nmodule AES_GCM_Implementation where\n\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM\nimport AES_GCM\n\ngcm_polyval_mul_pmult3 : {n} (fin n) => [2 * (1 + n)] -> [2 * (1 + n)] -> [4 * (1 + n)]\ngcm_polyval_mul_pmult3 X Y = r3 # (r2 ^ r1 ^ r3 ^ m1) # (r1 ^ r0 ^ r2 ^ m0) # r0\n  where\n    [X_hi, X_lo] = split X\n    [Y_hi, Y_lo] = split Y\n    [r1, r0] = split ((0 : [1]) # (pmult X_lo Y_lo))\n    [r3, r2] = split ((0 : [1]) # (pmult X_hi Y_hi))\n    [m1, m0] = split ((0 : [1]) # (pmult (X_lo ^ X_hi) (Y_hi ^ Y_lo)))\n\ngcm_polyval_mul_pmult4 : {n} (fin n) => [2 * (1 + n)] -> [2 * (1 + n)] -> [4 * (1 + n)]\ngcm_polyval_mul_pmult4 X Y = (hi ^ (0 : [1 + n]) # (hi_bits (m0 ^ m1))) # (lo ^ ((lo_bits (m0 ^ m1)) # (0 : [1 + n])))\n  where\n    [X_hi, X_lo] = split X\n    [Y_hi, Y_lo] = split Y\n    lo = (0 : [1]) # (pmult X_lo Y_lo)\n    hi = (0 : [1]) # (pmult X_hi Y_hi)\n    m0 = (0 : [1]) # (pmult X_lo Y_hi)\n    m1 = (0 : [1]) # (pmult X_hi Y_lo)\n\ngcm_polyval_red_pmult : [256] -> [128]\ngcm_polyval_red_pmult X = (d1 ^ x3) # (d0 ^ x2)\n  where\n    [x3, x2, x1, x0] = split X\n    [a1, a0] = split ((0 : [1]) # (pmult <| x^^63 + x^^62 + x^^57 |> x0))\n    b1 = x0 ^ a1\n    b0 = x1 ^ a0\n    [c1, c0] = split ((0 : [1]) # (pmult <| x^^63 + x^^62 + x^^57 |> b0))\n    d1 = b0 ^ c1\n    d0 = b1 ^ c0\n\ngcm_polyval_avx : [128] -> [128] -> [128]\ngcm_polyval_avx H X = x30\n  where\n    [H_hi, H_lo] = split H\n    [X_hi, X_lo] = split X\n    x17 = (0 : [1]) # (pmult H_lo X_lo)\n    x18 = ((0 : [1]) # (pmult H_hi X_hi)) ^ x17\n    x19 = x18 ^ ((0 : [1]) # (pmult (H_lo ^ H_hi) (X_lo ^ X_hi)))\n    x20 = (lo_bits x19) # (0 : [64])\n    x21 = x17 ^ x20\n    x22 = hi_bits x21\n    x23 = lo_bits x21\n    x25 = (take`{8} ((x23 << 57) ^ (x23 << 62) ^ (x23 << 63))) # (0 : [120])\n    x26 = x21 ^ x25\n    x27 = (hi_bits x26) >> 1\n    x28 = (lo_bits x26) >> 1\n    x29 = (x26 ^ (x27 # x28)) ^ ((x27 >> 5) # (x28 >> 5))\n    x30 = ((((x18 ^ x20) ^ ((0 : [64]) # (hi_bits x19))) ^ x25) ^ ((0 : [64]) # (take`{8} ((x22 << 57) ^ (x22 << 62) ^ (x22 << 63))) # (0 : [56]))) ^ (((hi_bits x29) >> 1) # ((lo_bits x29) >> 1))\n\naesni_gcm_cipher : {n} (fin n) => [32] -> AES_GCM_Ctx -> [(1 + n) * 6 * 16][8] -> [16][8]\naesni_gcm_cipher enc ctx in = ctx''.Xi\n  where\n    enc_blks = if enc ! 0\n      then split (aesni_gcm_ctr32_encrypt_block ctx in)\n      else split (map join (split in))\n    ctx' = aesni_gcm_cipher_block6 enc False ctx (enc_blks @ 0)\n    ctx'' = foldl (aesni_gcm_cipher_block6 enc (enc ! 0)) ctx' (drop`{1} enc_blks)\n\naesni_gcm_ctr32_encrypt_block : {n} (fin n) => AES_GCM_Ctx -> [n * 16][8] -> [n][16 * 8]\naesni_gcm_ctr32_encrypt_block ctx in = out\n  where\n    ctr = drop ((ctx.len \/ 16) + 1)\n    in' = split in\n    out = [ swap8 ((join (reverse blk)) ^ (join (reverse (EKi ctx (ctr + i))))) | blk <- in' | i <- [0 ...] ]\n\naesni_gcm_cipher_block6 : [32] -> Bit -> AES_GCM_Ctx -> [6][128] -> AES_GCM_Ctx\naesni_gcm_cipher_block6 enc karatsuba ctx blks = ctx'\n  where\n    gcm_polyval_mul_fun = if karatsuba\n      then gcm_polyval_mul_pmult3\n      else gcm_polyval_mul_pmult4\n    Htable = get_Htable ctx\n    Xi = join ctx.Xi\n    Xi_0 = gcm_polyval_mul_fun (Htable @ 0) (blks @ 5)\n    Xi_1 = gcm_polyval_mul_fun (Htable @ 1) (blks @ 4)\n    Xi_2 = gcm_polyval_mul_fun (Htable @ 3) (blks @ 3)\n    Xi_3 = gcm_polyval_mul_fun (Htable @ 4) (blks @ 2)\n    Xi_4 = gcm_polyval_mul_fun (Htable @ 6) (blks @ 1)\n    Xi_5 = gcm_polyval_mul_fun (Htable @ 7) (Xi ^ (blks @ 0))\n    Xi_6 = gcm_polyval_red_pmult (Xi_0 ^ Xi_1 ^ Xi_2 ^ Xi_3 ^ Xi_4 ^ Xi_5)\n    Xi' = split Xi_6\n    ctx' =\n      { key = ctx.key\n      , iv = ctx.iv\n      , Xi = Xi'\n      , len = ctx.len + 6 * 16\n      }\n\ngcm_ghash_avx : {n, m} (fin n, 1 <= m, m <= 8) => [128] -> [16][8] -> [(n * 8 + m) * 16][8] -> [16][8]\ngcm_ghash_avx H Xi in = Xi''\n  where\n    bulk # tl = in\n    Xi' = foldl (gcm_ghash_avx_8`{8} H) Xi (split`{n} bulk)\n    Xi'' = gcm_ghash_avx_8`{m} H Xi' tl\n\ngcm_ghash_avx_8 : {n} (1 <= n, n <= 8) => [128] -> [16][8] -> [n * 16][8] -> [16][8]\ngcm_ghash_avx_8 H Xi in = Xi''\n  where\n    [H0, H1, _, H2, H3, _, H4, H5, _, H6, H7, _] = gcm_init_Htable H\n    Htable = [H0, H1, H2, H3, H4, H5, H6, H7]\n    Xi' = join Xi\n    blks = map join (split in)\n    Xi_0 = gcm_polyval_mul_pmult3 (Htable @ (`n - 1)) (Xi' ^ (blks @ 0))\n    Xi_1 = gcm_polyval_mul_pmult3 (Htable @ (`n - 2)) (blks @ 1)\n    Xi_2 = gcm_polyval_mul_pmult3 (Htable @ (`n - 3)) (blks @ 2)\n    Xi_3 = gcm_polyval_mul_pmult3 (Htable @ (`n - 4)) (blks @ 3)\n    Xi_4 = gcm_polyval_mul_pmult3 (Htable @ (`n - 5)) (blks @ 4)\n    Xi_5 = gcm_polyval_mul_pmult3 (Htable @ (`n - 6)) (blks @ 5)\n    Xi_6 = gcm_polyval_mul_pmult3 (Htable @ (`n - 7)) (blks @ 6)\n    Xi_7 = gcm_polyval_mul_pmult3 (Htable @ (`n - 8)) (blks @ 7)\n    T1 = if `n == 8\n      then Xi_7 ^ Xi_6 ^ Xi_5 ^ Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n      else if `n == 7\n        then Xi_6 ^ Xi_5 ^ Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n        else if `n == 6\n          then Xi_5 ^ Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n          else if `n == 5\n            then Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n            else if `n == 4\n              then Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n              else if `n == 3\n                then Xi_2 ^ Xi_1 ^ Xi_0\n                else if `n == 2\n                  then Xi_1 ^ Xi_0\n                  else Xi_0\n    Xi_n = gcm_polyval_red_pmult T1\n    Xi'' = split Xi_n\n```"}]}
{"filename":"aws-lc-verification\/SAW\/spec\/AES\/X86.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `X86` that specifies X86-style AES helper functions `clmul`, `aesenc`, `aesenclast`, `aesdec`, `aesdeclast`, and `aeskeygenassist`, using AES round\/ final-round\/ inverse-round primitives and state\/message conversion functions consistent with standard AES-128."},{"role":"assistant","content":"```cryptol\nmodule X86 where\n\nimport Primitive::Symmetric::Cipher::Block::AES\n\nclmul : [64] -> [64] -> [128]\nclmul x y = 0b0 # pmult x y\n\naesenc : [128] -> [128] -> [128]\naesenc pt key =\n  stateToMsg_x86 (AESRound (msgToState_x86 key, msgToState_x86 pt))\n\naesenclast : [128] -> [128] -> [128]\naesenclast pt key =\n  stateToMsg_x86 (AESFinalRound (msgToState_x86 key, msgToState_x86 pt))\n\naesdec : [128] -> [128] -> [128]\naesdec pt key =\n  stateToMsg_x86 (AESInvRound (msgToState_x86 key, msgToState_x86 pt))\n\naesdeclast : [128] -> [128] -> [128]\naesdeclast pt key =\n  stateToMsg_x86 (AESFinalInvRound (msgToState_x86 key, msgToState_x86 pt))\n\naeskeygenassist : [128] -> [8] -> [128]\naeskeygenassist src imm = join\n  ( (RotWord_x86 (SubWord x3) ^ rcon)\n  # SubWord x3\n  # (RotWord_x86 (SubWord x1) ^ rcon)\n  # SubWord x1\n  )\n  where\n    [x3, x2, x1, x0] = [split x | x <- split src]\n    rcon = [0, 0, 0, imm]\n\nRotWord_x86 : [4]GF28 -> [4]GF28\nRotWord_x86 x = reverse (RotWord (reverse x))\n\nmsgToState_x86 : [128] -> State\nmsgToState_x86 msg = transpose (split (reverse (split msg)))\n\nstateToMsg_x86 : State -> [128]\nstateToMsg_x86 st = join (reverse (join (transpose st)))\n```"}]}
{"filename":"aws-lc-verification\/SAW\/spec\/AES\/AES-GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module AES_GCM that specifies AES-256-GCM operations (including key schedule conversions, AES-CTR encryption, GCM initialization, GHASH, and context-derived values like H-table, counters, and EK blocks) suitable for verification of an AES-GCM implementation."},{"role":"assistant","content":"```cryptol\nmodule AES_GCM where\n\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM\nimport X86\n\nswap8 : {parts, a} (fin parts) => [parts * 8]a -> [parts * 8]a\nswap8 x = join`{each=8} (reverse (split`{each=8} x))\n\nswap128 : {parts, a} (fin parts) => [parts * 128]a -> [parts * 128]a\nswap128 x = join`{each=128} (reverse (split`{each=128} x))\n\nhi_bits : {n} (fin n) => [2 * n] -> [n]\nhi_bits = take\n\nlo_bits : {n} (fin n) => [2 * n] -> [n]\nlo_bits = drop\n\naes_key_to_schedule : [Nr + 1][128] -> KeySchedule\naes_key_to_schedule key = (key' @ 0, key' @@ [1 .. (Nr - 1)], key' @ `Nr)\n  where\n    key' = map msgToState_x86 key\n\naes_key_from_schedule : KeySchedule -> [4 * (Nr - 1)][32]\naes_key_from_schedule (init_key, middle_keys, final_key) = join (map reverse (map split (key' @@ [2 .. Nr])))\n  where\n    key' = map stateToMsg_x86 ([init_key] # middle_keys # [final_key])\n\ninv_aes_key_from_schedule : KeySchedule -> [4 * (Nr - 1)][32]\ninv_aes_key_from_schedule (init_key, middle_keys, final_key) = join (map reverse (map split (reverse (key' @@ [2 .. Nr]))))\n  where\n    key' = map stateToMsg_x86 ([init_key] # middle_keys # [final_key])\n\naes_hw_decrypt : [16][8] -> [32][8] -> [16][8]\naes_hw_decrypt in key = split (aesDecrypt ((join in), (join key)))\n\naes_hw_ctr32_encrypt_blocks : {n} (fin n) => [16*n][8] -> [32][8] -> [16][8] -> [16*n][8]\naes_hw_ctr32_encrypt_blocks in key (iv # ctr) =\n  join [ blk ^ (aes_hw_encrypt (iv # (split ((join ctr) + i))) key) | blk <- split in | i <- [(0 : [32]) ...]]\n\ngcm_init : [2][64] -> [12][128]\ngcm_init Xi = gcm_init_Htable (gcm_init_H (join Xi))\n\ngcm_init_Htable : [128] -> [12][128]\ngcm_init_Htable h0 = [h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11]\n  where\n    h1 = gcm_polyval h0 h0\n    h2 = ((hi_bits h1) ^ (lo_bits h1)) # ((hi_bits h0) ^ (lo_bits h0))\n    h3 = gcm_polyval h0 h1\n    h4 = gcm_polyval h0 h3\n    h5 = ((hi_bits h4) ^ (lo_bits h4)) # ((hi_bits h3) ^ (lo_bits h3))\n    h6 = gcm_polyval h0 h4\n    h7 = gcm_polyval h0 h6\n    h8 = ((hi_bits h7) ^ (lo_bits h7)) # ((hi_bits h6) ^ (lo_bits h6))\n    h9 = gcm_polyval h0 h7\n    h10 = gcm_polyval h0 h9\n    h11 = ((hi_bits h9) ^ (lo_bits h9)) # ((hi_bits h10) ^ (lo_bits h10))\n\ngcm_gmult : [128] -> [16][8] -> [16][8]\ngcm_gmult H Xi = split (gcm_polyval H (join Xi))\n\ngcm_ghash : {n} (fin n) => [128] -> [16][8] -> [n * 16][8] -> [16][8]\ngcm_ghash H Xi inp = foldl (gcm_ghash_block H) Xi (split inp)\n\ngcm_ghash_block : [128] -> [16][8] -> [16][8] -> [16][8]\ngcm_ghash_block H Xi inp = split (gcm_polyval H ((join Xi) ^ (join inp)))\n\nget_Htable : AES_GCM_Ctx -> [12][128]\nget_Htable ctx = gcm_init (get_H ctx)\n\nget_i : AES_GCM_Ctx -> [32]\nget_i ctx = drop ((ctx.len + 15) \/ 16)\n\nget_Yi : AES_GCM_Ctx -> [16][8]\nget_Yi ctx = ctx.iv # (split ((get_i ctx) + 2))\n\nget_EKi : AES_GCM_Ctx -> [16][8]\nget_EKi ctx = EKi ctx (get_i ctx)\n\nget_EK0 : AES_GCM_Ctx -> [16][8]\nget_EK0 ctx = EKi ctx 0\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/ModDivZ.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the function `moddiv : {p}(fin p, p >= 3) => Z p -> Z p -> Z p` implementing modular division using an extended GCD algorithm, including helper functions `even`, `egcd`, `half`, and the infix operator `(%\/)` as an alias for `moddiv`."},{"role":"assistant","content":"```cryptol\nmodule Common::ModDivZ where\n\neven k = k % 2 == 0\n\nmoddiv : {p}(fin p, p >= 3) => Z p -> Z p -> Z p  moddiv x y = if y == 0 then error \"division by 0\"                         else fromInteger (egcd `p 0 (fromZ y) (fromZ x))\n    where\n\n    egcd : Integer -> Integer -> Integer -> Integer -> Integer\n    egcd a ra b rb =          if b == 0 then ra\n         | even b then egcd a ra (   b    \/ 2) (half rb)\n         | a < b  then egcd a ra ((b - a) \/ 2) (half ((rb - ra) % `p))\n                  else egcd b rb ((a - b) \/ 2) (half ((ra - rb) % `p))\n\n    half : Integer -> Integer\n    half k = (if even k then k else (k + `p)) \/ 2\n\n(%\/) = moddiv\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/mul_java.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify Cryptol functions and properties that model the Java-style 12-limb big-integer multiplication, squaring, and P-384 group multiplication\/reduction implemented in mul_java, and verify they are equivalent to ideal big-integer arithmetic modulo the P-384 group order."},{"role":"assistant","content":"```cryptol\nmodule Common::mul_java where\n\nimport Common::bv\n\nmul_java_inner : (Bit, [24][32], [32], [32], [32], [64]) -> { mji_a : [24][32], mji_d : [64]}\nmul_java_inner (azero, a, ij, xi, yj, d) = { mji_a = a', mji_d = d' >> 32 }\n  where\n    m        = zext(xi) * zext(yj)\n    d'       = d + m + zext(aij)\n    a'       = update a ij (drop(d'))\n    aij      = if ~azero then a @ ij else 0\n\n\/*\naset : {n, is} (fin n, fin is, n >= is, is >= lg2 n, n >= 32, is >= max(lg2 n, 6)) =>\n          ([n], [is], [is]) -> [n]\n*\/\naset (a, i, x) = (a && imask) || x'\n  where\n    imask = ~(zext(0xFFFFFFFF : [32]) << (i*32))\n    x' = zext(x) << (i*32)\n\naset_768 : ([768], [32], [32]) -> [768]\naset_768 = aset\n\ntoJavaArray : [384] -> [12][32]\ntoJavaArray x = reverse (split x)\n\nfromJavaArray : [12][32] -> [384]\nfromJavaArray x = join (reverse x)\n\n\/\/ Matches java implementation; computes safe_product.\nmul_java : ([768], [384], [384]) -> [768]\nmul_java (a0, x, y) = join (reverse (a_final!0))\n  where\n    l   = 12 : [32]\n    x'  = toJavaArray x\n    y'  = toJavaArray y\n    a0' = reverse (split a0) : [24][32]\n\n    a_first : [13]([64],[24][32])\n    a_first = [ (zero : [64], a0' : [24][32]) ]\n            # [ (res.mji_d, res.mji_a)\n                   where res = mul_java_inner(True, a, j, x'@0, y'@j, d)\n              | (d, a) <- a_first\n              | j      <- [0..11]\n              ]\n    (d_first_final, a_first_final) = a_first!0\n    ad_first_final = update a_first_final l (drop(d_first_final):[32])\n\n    \/* Second loop in Java implementation *\/\n    a_final : [12][24][32]\n    a_final = [ ad_first_final ]\n            # [ ad_inner_final\n                 where\n                   \/* Inner loop in Java implementation *\/\n                   a_inner : [13]([64],[24][32],[32])\n                   a_inner = [ ( zero : [64] \/* d *\/, a, i) ]\n                           # [ (res.mji_d, res.mji_a, ij+1)\n                                where\n                                  res = mul_java_inner(False, ai, ij, x'@i, y'@j, d)\n                             | (d, ai, ij) <- a_inner\n                             | j          <- [0..(12-1)]:[12][32]\n                             ]\n\n                   (d_inner_final, a_inner_final, ij_final) = a_inner!0\n                   ad_inner_final = update a_inner_final ij_final (drop(d_inner_final))\n              | a <- a_final\n              | i <- [1..11]\n              ]\n\nsq_java_inner1 : ([24][32], [32], [64]) -> { mji_a : [24][32], mji_d : [64]}\nsq_java_inner1 (a, ij, c) = { mji_a = a' , mji_d = c'' }\n  where\n    aij = a @ ij\n    c' = c + (zext(aij) << 1)\n    a' = update a ij (drop(c'))\n    c'' = c' >> 32\n\nsq_java_inner2 : ([24][32], [32], [32], [64]) ->\n                 { mji_a : [24][32], mji_d : [64]}\nsq_java_inner2 (a, ij, xati, c) = { mji_a = a' , mji_d = c'' }\n  where\n    aij = a @ ij\n    xi = zext(xati) : [64]\n    m = xi * xi\n    c' = c + (m && 0x00000000FFFFFFFF) + (zext(aij) << 1)\n    a' = update a ij (drop(c'))\n    c'' = (c' >> 32) + (m >> 32)\n\nsq_java_loop : ([24][32], [384]) -> [24][32]\nsq_java_loop(a0, x) = a_mid!0\n  where\n    \/* Second loop in Java implementation *\/\n    l = 12 : [32]\n    x'  = toJavaArray x\n    a_mid   = [ a0 ]\n            # [ ad_inner_final\n                 where\n\n                   a_inner = [ ( zero : [64] , a, i+i+1) ]\n                           # [ (res.mji_d, res.mji_a, ij+1)\n                                where\n                                  res = if j+i < l then\n                                          mul_java_inner(False, ai, ij, x'@i, x'@(j+i), d)\n                                        else zero\n                             | (d, ai, ij) <- a_inner\n                             | j          <- [1..(12-1)]\n                             ]\n                   (d_inner_final, a_inner_final, ij_final) = a_inner!i\n                   ad_inner_final = update a_inner_final ij_final (drop(d_inner_final))\n              | a <- a_mid\n              | i <- [1..(12-2)]\n              ]\n\nsq_java : ([768], [384]) -> [768]\nsq_java (a0, x) = join (reverse ad_final_final)\n  where\n    l   = 12 : [32]\n    x'  = toJavaArray x\n    a0' = reverse (split a0) : [24][32]\n    x0 = x'@0\n    \/* First loop in Java implementation *\/\n    a_first = [ (zero : [64], a0' : [24][32]) ]\n            # [ (res.mji_d, res.mji_a)\n                 where res = mul_java_inner(True, a, j, x0, x'@j, d)\n              | (d, a) <- a_first\n              | j      <- [1..11]\n              ]\n    (d_first_final, a_first_final) = a_first!0\n    ad_first_final = update a_first_final l (drop(d_first_final))\n\n    mid_res = mul_java_inner(True, sq_java_loop(ad_first_final, x), 0, x0, x0, 0)\n\n    \/* Third loop in Java implementation *\/\n    a_final : [12]([64],[24][32],[32])\n    a_final = [ (mid_res.mji_d, mid_res.mji_a, 1) ]\n            # [ (res'.mji_d, res'.mji_a, ij+2)\n                where\n                   res = sq_java_inner1(a, ij, c)\n                   res' = sq_java_inner2(res.mji_a, ij+1, x'@(i:[32]), res.mji_d)\n              | (c, a, ij) <- a_final\n              | i      <- [1..11]\n              ]\n    (d_final_final, a_final_final, ij_final) = a_final!0\n    ad_final_final = update a_final_final ((l << 1) - 1) (drop(d_final_final))\n\naset_384 : ([384], [32], [32]) -> [384]\naset_384(a, i, x) = fromJavaArray (update (toJavaArray a) i x)\n\njava_lashr32 : [64] -> [64]\njava_lashr32 x = take(sext(x) : [96])\n\ngroup_red_aux_java : ([384], [32], [32], [64], [64]) ->\n                     { gra_r: [384] , gra_b : [64] }\ngroup_red_aux_java(r, aj, j, c, b) = { gra_r = r' , gra_b = b'' }\n  where\n    rj, m, b' : [64]\n    rj = zext(toJavaArray r @ j)\n    m = c * zext(aj)\n    b' = b + rj - zext(drop(m):[32])\n    r' = aset_384(r, j, drop(b'))\n    b'' = java_lashr32(b') - (m >> 32)\n\ngroup_mul_aux_java : ([384], [32], [32], [32], [64]) ->\n                     { gra_r: [384] , gra_b : [64] }\ngroup_mul_aux_java(r, yj, j, xi, c) = { gra_r = r' , gra_b = c'' }\n  where\n    rj, m, c' : [64]\n    rj = zext(toJavaArray r @ j)\n    m = zext(xi) * zext(yj)\n    c' = c + rj + zext(drop(m):[32])\n    r' = aset_384(r, j, drop(c'))\n    c'' = (c' >> 32) + (m >> 32)\n\np384_group_red : ([384], [384], [64]) -> [384]\np384_group_red(order, r, c) = r'''\n  where\n    order' = toJavaArray order\n    loop : [13]([384],[64])\n    loop = [ (r, zero : [64]) ] #\n           [ (res.gra_r, res.gra_b)\n              where res = group_red_aux_java(rj, order'@j, j, c, bi)\n           | (rj, bi) <- loop\n           | j <- [0..11]\n           ]\n    (r', b) = loop!0\n    c' = c + b\n    (r'', c'') = if c' != 0 then\n                   (r' - order, c' + (if r' >= order then 0 else -1))\n                 else (r', c')\n    r''' = if c'' != 0 then r'' - order else r''\n\np384_group_mul : ([384], [384], [384]) -> [384]\np384_group_mul(order, x, y) = r'\n  where\n    xa = toJavaArray x\n    ya = toJavaArray y\n    outer : [13][384]\n    outer = [ (zero : [384]) ] #\n            [ p384_group_red(order, rn, cn)\n               where\n                 r0 : [384]\n                 r0 = p384_group_red(order,\n                                     ro << (32 : [9]),\n                                     zext(take(ro):[32]))\n                 inner : [13]([384], [64])\n                 inner = [ (r0, 0) ] #\n                         [ (res.gra_r, res.gra_b)\n                            where\n                              res = group_mul_aux_java(rj, ya@j, j, xa@(i:[32]), cj)\n                         | j <- [0..11]\n                         | (rj, cj) <- inner\n                         ]\n                 (rn, cn) = inner!0\n            | i <- reverse [0..11]\n            | ro <- outer\n            ]\n    r = outer!0\n    r' = if order <= r then r - order else r\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/Set.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module Common::Set that represents sets as indicator functions (Set a = a -> Bit) and implements the functions implies, intersect, union, subset, and ProdSet with the same types and logical behavior as in the given specification."},{"role":"assistant","content":"```cryptol\nmodule Common::Set where\n\nimplies : Bit -> Bit -> Bit\nimplies P = \\Q -> if P then Q else True\n\ntype Set a = (a -> Bit)\n\nintersect : {a} Set a -> Set a -> Set a\nintersect P = \\Q -> \\x -> P x && Q x\n\nunion : {a} Set a -> Set a -> Set a\nunion P = \\Q -> \\x -> P x || Q x\n\nsubset : {a} Set a -> Set a -> Set a\nsubset P = \\Q -> \\x -> implies (P x) (Q x)\n\nProdSet : {a, b} Set a -> Set b -> Set ((a,b))\nProdSet A = \\B -> \\(a,b) -> A a && B b\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/Morphism.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the morphism combinators in Common::Morphism (Mor, Mor_OP, id_mor, comp_mor, Hom_mor, Pair_mor, Diag_mor, Set_mor, Set2_mor) and states properties characterizing them as categorical identities, composition, product, diagonal, and induced set morphisms."},{"role":"assistant","content":"```cryptol\nmodule Common::Morphism where\n\nimport Common::Set\n\ntype Mor a b = a -> b\n\ntype Mor_OP a b = Mor b a\n\nid_mor : {a} Mor a a\nid_mor x = x\n\ncomp_mor : {a, b, c} Mor b c -> Mor a b -> Mor a c\ncomp_mor f g x = f (g x)\n\nHom_mor : {a, b, c, d} Mor_OP a b -> Mor c d -> Mor (a -> c) (b -> d)\nHom_mor f g h = comp_mor g (comp_mor h f)\n\nPair_mor : {a, b, c, d} Mor a c -> Mor b d -> Mor (a,b) (c,d)\nPair_mor f g (a,b) = (f a, g b)\n\nDiag_mor : {a, b} Mor a b -> Mor (a,a) (b,b)\nDiag_mor f = Pair_mor f f\n\nSet_mor : {a, b} Mor_OP a b -> Mor (Set a) (Set b)\nSet_mor m = Hom_mor m id_mor\n\nSet2_mor : {a, b} Mor_OP a b -> Mor (Set (a,a)) (Set (b,b))\nSet2_mor = comp_mor Set_mor Diag_mor\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/utils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Common::utils that defines the given utility functions (loops, integer\/bitvector\/Z conversions, parity, abs, unzip, small multipliers, half, mp_mod_inv) along with the properties half_correct and mp_mod_inv_correct as specified, preserving their types and semantics."},{"role":"assistant","content":"```cryptol\nmodule Common::utils where\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = (fromInteger (fromZ x))\n\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = (fromInteger (toInteger x))\n\nZtoZ : {p, q} (fin p, fin q, p >= 1, q >= 1) => Z p -> Z q\nZtoZ x = (fromInteger (fromZ x))\n\nintegerToBV : {m} (fin m) => Integer -> [m]\nintegerToBV x = fromInteger x\n\nintegerFromBV : {m} (fin m) => [m] -> Integer\nintegerFromBV x = toInteger x\n\nintegerModulusFromBV : {m} (fin m) => [m] -> Integer\nintegerModulusFromBV x = if (integerFromBV x) < 3 then 3 else (integerFromBV x)\n\nisEven : Integer -> Bit\nisEven x = ~((fromInteger x) : [1]) ! 0\n\nabs : Integer -> Integer\nabs x = if x >= zero then x else zero-x\n\nunzip : {a,f,s} [a](f,s) -> ([a]f,[a]s)\nunzip tuples = (map (\\x -> x.0) tuples , map (\\x -> x.1) tuples)\n\nmul2 x = x + x\nmul3 x = x + mul2 x\nmul4 x = mul2(mul2 x)\nmul8 x = mul2(mul4 x)\n\ntype constraint isOdd a = (a \/ 2) * 2 == a - 1\n\nhalf : {p} (fin p, p >= 3, isOdd p) => Z p -> Z p\nhalf x = fromInteger (if isEven xint then xint\/2 else ((xint + `p) \/ 2))\n  where\n    xint = fromZ x\n\nhalf_correct : {p} (fin p, p >= 3, isOdd p) => Z p -> Bit\nproperty half_correct x = half x + half x == x\n\nmp_mod_inv : {n} (fin n, n >= 1) => Z n -> Z n\nmp_mod_inv c = if c == 0 then error \"Zero does not have a multiplicative inverse\"\n               else fromInteger (if u'' == 1 then x1'' else x2'')\n  where\n    innercond (a, x) = isEven a\n    innerbody (a, x) = (a \/ 2, if isEven x then x \/ 2 else (x + `n) \/ 2)\n\n    outtercond (u, v, x1, x2) = (u != 1) \/\\ (v != 1)\n    outterbody (u, v, x1, x2) = if(u' >= v') then (u' - v', v', x1' - x2' % `n, x2')\n                                             else (u', v' - u', x1', x2' - x1' % `n)\n      where\n        (u', x1') = while innercond innerbody (u, x1)\n        (v', x2') = while innercond innerbody (v, x2)\n\n    (u'', _, x1'', x2'') = while outtercond outterbody (fromZ c, `n, 1, 0)\n\nmp_mod_inv_correct : {a} (fin a, a >=2) => Z a -> Bit\nproperty mp_mod_inv_correct x = x != 0 ==> x * mp_mod_inv x == 1\n```"}]}
