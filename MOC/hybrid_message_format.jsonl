{"filename":"cryptol\/examples\/splitAt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the behavior of the 'splitAt' function when applied to the sequence 'x'. Ensure the properties check that the output tuple correctly splits 'x' into two subsequences of equal length, and that concatenating these subsequences reconstructs the original sequence 'x'."},{"role":"assistant","content":"```cryptol\nx = [1,2,3,4] : [_][8]\n\ny = (splitAt x) : ([2][8],[2][8])\n\na = y.0 @ 0\nb = y.0 @ 1\nc = y.1 @ 0\nd = y.1 @ 1\n```"}]}
{"filename":"cryptol\/examples\/AE.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that specify and verify the correctness of the AE module's encryption and decryption functions. In particular, formalize and prove that for any key, nonce, state, and message, decrypting the ciphertext produced by encrypting the message returns the original message and state, as suggested by the Dec_prop property. Include properties that capture the behavior of the tweak_cipher and the relationship between the tweak values across encryption steps."},{"role":"assistant","content":"```cryptol\n\/*\nImplementation of the algorithms from the paper\n  \"Automated Analysis and Synthesis of Authenticated Encryption Schemes\"\n  by Viet Tung Hoang, Jonathan Katz, and Alex J. Malozemoff\n*\/\nmodule AE where\n\nparameter\n  type A : *            type K : *            type n : #            type p : #            type tagAmount : #\n\n  type constraint (fin p, fin n, n >= tagAmount)\n\n  \/\/ Process a single block using this key and tweak\n  tweak_cipher : K -> { nonce : [n], state : A, z : [64] } -> [n] -> [n]\n\n  \/\/ Cost for using the tweak\n  Cost : [64]\n\n  Enc : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Dec : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Tag : K -> { nonce : [n], state : A, z : [64] } -> [p*n] -> [n]\n\n\/\/ The unit at which `Enc` operates\ntype Node       = { message : WorkBlock, state : State }\n\n\/\/ Some encryption schemes process multiple blocks at once\ntype WorkBlock  = [p*n]\n\ntype State      = [p*n]  \/\/ The state for `p` blocks\n\ntype Tweak      = { nonce : Nonce, state : A, z : Int }\ntype Nonce      = [n]\n\n\/*\nproperty\n\n  \/\/ The tweak in the `i`th query to the tweak_cipher\n  tweak_prop i { nonce = n, state = a, z = v } =\n               { nonce = n, state = a, z = v + i - 1 }\n\n\n  \/\/ Property of decrypt\n  Dec_prop : Tweak -> Node -> Bit\n  Dec_prop t { message = m, state = x } =\n       Dec t { message = c, state = x } == { message = m, state = y }\n       where { message = c, state = y } = Enc t x m\n*\/\n\ntype Int = [64]\n\nencrypt :\n  {m} fin m => K -> Nonce -> A -> [m * (p * n)] -> [m * (p * n) + tagAmount]\nencrypt key nonce state inputMsg = encMsg # tag\n\n  where\n  encMsg = join rest.0.message\n\n  tag = take (Tag key (tweak (1 - final.1)) final.0.state)\n\n  final = steps ! 0\n\n  steps = [ ({ message = undefined, state = zero }, 1) ] # rest\n  rest  = [ (Enc key (tweak v) { message = m, state = prev.state }, v + Cost)\n          | (prev,v) <- steps\n          | m        <- chunks\n          ]\n\n  \/\/ XXX: isn't v i  just 1 + i * Cost\n\n  chunks : [m] [p * n]\n  chunks = split inputMsg\n\n  tweak : Int -> Tweak\n  tweak v = { nonce = nonce, state = state, z = v }\n```"}]}
{"filename":"cryptol\/examples\/xor_cipher.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the 'encrypt' and 'decrypt' functions in the xor_cipher module are inverses of each other for all valid keys and plaintexts. Include properties that check the roundtrip correctness and any relevant invariants for the XOR cipher."},{"role":"assistant","content":"```cryptol\nencrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\nencrypt key plaintext = [pt ^ key | pt <- plaintext ]\n\ndecrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\ndecrypt key ciphertext = [ct ^ key | ct <- ciphertext ]\n\nproperty roundtrip k ip = decrypt k (encrypt k ip) == ip\n```"}]}
{"filename":"cryptol\/examples\/zero_weird.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify that the functions `x` and `y` always return zero values of the appropriate bit-widths for all valid inputs. Include properties that can be used with Cryptol's :check or :prove commands to confirm these behaviors."},{"role":"assistant","content":"```cryptol\nx : {a}() => a -> [16]\nx v = zero v \n\nproperty xprop v = x v == 0\n\ny : [12] -> [4] -> [17]\ny a b = zero a b\n\nproperty yprop v w = y v w == 0\n\nt1 = x 13\nt2 = y 2 3\n```"}]}
{"filename":"cryptol\/examples\/builtin_lifting.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally verifies the lifting behavior of built-in operators over tuples, sequences (including infinite sequences), and records as demonstrated in the given code. Include properties that check pointwise addition and negation lifting, and ensure these properties hold for finite and infinite data structures as well as nested combinations of tuples and records."},{"role":"assistant","content":"```cryptol\n\/\/builtins lift over tuples, seqs, and records\n\n\/\/this file uses addition to model a builtin\n\/\/but this should work for any builtin operators\n\nx = [True,False]\ny = [False,True]\n\n\/\/make sure bitvectors are numbers\nproperty p1 = x == (2 : [2])\n\n\/\/same thing written 2 different ways\nproperty p2 = x + y == 3\nproperty p3 = x + y == [True,True]\n\n\nxx = [[True,False]]\nyy = [[False,True]]\n\n\/\/addition lifts pointwise over sequences\nproperty p4 = xx + yy == [3]\n\n\/\/negation is a unary operator that also lifts over sequences\nproperty p5 = ~ xx == yy\n\n\nxinf = [2 ... ]\nyinf = [3 ... ]\n\n\/\/addition lifts pointwise over infinite lists\nproperty p6 = (xinf + yinf) @ (0 : [0]) == (1 : [2])\n\n\/\/negation lifts pointwise over an infinite list\nproperty p7 = (~ xinf) @ (0 : [0]) == (1 : [2])\n\nxrec = { x = 2 : [2], y = 2 : [2] } : {x : [2], y : [2]}\n\nproperty p8 = xrec + xrec + xrec == xrec\n\n\/\/lift over tuples and records at the same time\nproperty p9 = (2,2,xrec) + (2,2,xrec) + (2,2,xrec) == (2:[2],2:[2],xrec) \n\n\/\/lift unary over tuples and lists\nproperty p10 = (~ { x = (1,2), y = [3,4,5] }) == {x = (0:[1],1:[2]), y = [4, 3, 2] : [3][3] }\n```"}]}
{"filename":"cryptol\/examples\/inflist.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the infinite and finite sequences 'a', 'b', 'c', and 'd' defined in the code. Ensure the properties check the expected values at specific indices as indicated, and include properties that confirm the sequences behave as intended according to their definitions."},{"role":"assistant","content":"```cryptol\na = [1 ... ]\nb = [1,2 ... ]\nc = [1 .. 5]\nd = [1,3 .. 9]\n\nproperty t1 = a @ 3 == 1\nproperty t2 = b @ 3 == 1\nproperty t3 = c @ 3 == 4\nproperty t4 = d @ 3 == 4\n```"}]}
{"filename":"cryptol\/examples\/Karatsuba.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the `kmult` function correctly implements multiplication for all valid input sizes and limb widths, extending the existing `splitmult_correct_*` properties to cover the polymorphic behavior of `kmult`. Include properties that prove equivalence between `kmult` and the built-in multiplication operator for various parameter settings."},{"role":"assistant","content":"```cryptol\n\/*\n * Copyright (c) 2017 Galois, Inc.\n * Distributed under the terms of the BSD3 license (see LICENSE file)\n *\n * This module defines a Karatsuba multiplier, which is polymorphic over the\n * bitwidth of the constituent limbs and the size of the inputs.\n *\n * Note the trick of using `make_atleast` in the recursive case to teach the\n * typecheker that the current bitwidth is long enough for the split multiplier\n * to be sensible.  The minimum width for which the splitting recursive case\n * works out happens to be 6.  This is the smallest width for which the\n * divide-in-half strategy leaves enough bits left over for the additions\n * steps not to overflow.\n *\n * Note that if one wishes to simulate using a standard CPU to perform Karatsuba\n * multiplies, the limb width should be set to ONE LESS THAN the standard\n * machine word size, e.g. 63 bits for a 64 bit machine.  This ensures that\n * the intermediate additions will fit into a machine word.  Note that the the\n * final `2*(limb+1)`-width additions will also have to be assembled manually\n * using \"add with carry\" operations or similar.\n *\/\n\nmodule Karatsuba where\n\n\/\/ The divide-and-conquer Karatsuba multiplier.  If the argument width\n\/\/ is greater than the limb width, then the recursive `splitmult` multiplier\n\/\/ is called; otherwise, a standard multiply is used.\n\nkmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 1) => [n] -> [n] -> [2*n]\n\nkmult x y =\n if `n >= (`limb : [max (width limb) (width n)]) then\n   take (splitmult`{limb} (make_atleast`{limb} x) (make_atleast`{limb} y))\n else\n   (zero#x)*(zero#y)\n\n\n\/\/ Force a bitvector to be at least `n` bits long.  As used above, this operation\n\/\/ should always be a no-op, but teaches the typechecker a necessary inequality\n\/\/ to call the `splitmult` operation.\n\nmake_atleast : {n, m, a} (fin n, fin m, Zero a) => [m]a -> [max n m]a\nmake_atleast x = zero#x\n\n\n\n\/\/ Execute the recursive step of Karatsuba's multiplication. Split the\n\/\/ input words into high and low bit portions; then perform three\n\/\/ recursive multiplies using these intermediate, shorter bitsequences.\n\nsplitmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 6)\n         => [n] -> [n] -> [2*n]\n\nsplitmult x y = (ac # bd) + (zero # ad_bc # (zero:[low]))\n  where\n   type hi  = n\/2\n   type low = n - hi\n\n   (a,b) = splitAt`{hi} x\n   (c,d) = splitAt`{hi} y\n\n   ac : [2*hi]\n   ac = kmult`{limb,hi} a c\n\n   bd : [2*low]\n   bd = kmult`{limb,low} b d\n\n   a_b = (zext a) + (zext b)\n   c_d = (zext c) + (zext d)\n\n   ad_bc : [2*(low+1)]\n   ad_bc = (kmult`{limb,low+1} a_b c_d) - (zext ac) - (zext bd)\n\n\n\/\/ Verify Karatsuba's algorithm computes the correct answer\n\/\/ for some fixed settings of the parameters.\n\/\/\n\/\/ SMT solvers have great difficutly with these proofs, and I have\n\/\/ only gotten small bit sizes to return with successful proofs.\n\nproperty splitmult_correct_tiny (x:[9]) (y:[9]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_small (x:[11]) (y:[11]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_medium(x:[17]) (y:[17]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_large (x:[59]) (y:[59]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_huge (x:[511]) (y:[511]) =\n  zext x * zext y == splitmult`{limb=63} x y\n```"}]}
{"filename":"cryptol\/examples\/comp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the list comprehensions 'x' and 'y' defined in the given code. Ensure that the properties capture the expected values at specific indices as indicated by the existing properties t1 through t4, and extend these properties to comprehensively cover the behavior of 'x' and 'y'."},{"role":"assistant","content":"```cryptol\nx : [_]([2],[3],[3],[4])\nx = [(a,b,c,d) | a <- [1,2], b <- [3,4] | c <- [5,6], d <- [7,8,9] ]\n\nproperty t1 = x @ 0 == (1,3,5,7)\nproperty t2 = x @ 2 == (2,3,5,9)\nproperty t3 = x @ 3 == (2,4,6,7)\n\ny = [(a,b,c) | a <- [1,2,3], b <- [1,2] | c <- [1 ... ] ]\n\nproperty t4 = y @ 3 == (2,2,0)\n```"}]}
{"filename":"cryptol\/examples\/mini.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the function `gf28Add`. Then, write properties to verify that `gf28Add` correctly computes the cumulative XOR sums as described, and that it behaves correctly for various input lengths and values. Include tests or properties that check the correctness of the recursive definition and the base case."},{"role":"assistant","content":"```cryptol\nid : [32] -> [32]\nid x = rec x\n  where rec k = if (k == 0) then 0 else 1 + rec (k + (-1))\n\n\ninflist = [1 ... ] : [_][8]\n\nrc = {x = 3 : [8], y = 5 : [8]}\n\nmy_true = rc.x\n\ntup = (1 : [8], 2 : [8], 3 : [8], 4 : [8])\n\nmy_3 = tup.2\n\nsup = y where y = 3 : [8]\n\n\ngf28Add : {n} (fin n) => [n][8] -> [8]\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\ngex = gf28Add [1,2]\n\nsum : [_][8] -> [_][8]\nsum x = rec\n  where rec = [ p + q | p <- x | q <- [1,2,3,4] ]\n```"}]}
{"filename":"cryptol\/examples\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the encryption and decryption functions of any Cipher instance satisfy correctness tests as defined by the evktest, evttest, ekatest, dvktest, dvttest, and dkatest functions in the Test module. These properties should check that encrypting plaintext with a key produces the expected ciphertext, and decrypting ciphertext with a key recovers the original plaintext."},{"role":"assistant","content":"```cryptol\n\/\/ Don't load this on its own -- it gets pulled in by, e.g., DEStest.cry\n\nmodule Test where\nimport Cipher\n\nevktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\nevktest (cipher, vkeysCTs, PT) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, CT) <- vkeysCTs ]\n\nevttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\nevttest (cipher, Key, vtextPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (PT, CT) <- vtextPCTs ]\n\nekatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\nekatest (cipher, kaKPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, PT, CT) <- kaKPCTs ]\n\ndvktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\ndvktest (cipher, vkeysCTs, PT) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, CT) <- vkeysCTs ]\n\ndvttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\ndvttest (cipher, Key, vtextPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (PT, CT) <- vtextPCTs ]\n\ndkatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\ndkatest (cipher, kaKPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, PT, CT) <- kaKPCTs ]\n```"}]}
{"filename":"cryptol\/examples\/builtins.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of each builtin operator tested in the given code snippet. Then, write Cryptol properties to verify that the computed values (t, f, times, div, mod, exp, lgtest, p, m, neg, comp) conform to these specifications."},{"role":"assistant","content":"```cryptol\n\/\/Here's a test of some builtin operators\n\/\/nothing too deep, just making sure they all work out\n\nt : [8]\nt = if True then 5 else 4 f : [8]\nf = if False then 3 else 5 times : [8]\ntimes = 5 * 1 * 2 * 3 div : [8]\ndiv = (((30\/1)\/2)\/3) mod : [8]\nmod = 205%10 exp : [8]\nexp = 2^^7 lgtest : [8]\nlgtest = lg2 128 p : [8]\np = 3+2 m : [8]\nm = 8-3 neg : [8]\nneg = -(-5) comp : [8]\ncomp = ~250\n```"}]}
{"filename":"cryptol\/examples\/props.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the list concatenation operations and the behavior of the function 't' defined in the code snippet. Ensure the properties check that the concatenations produce expected results and that 't' returns a zero matrix of the specified size."},{"role":"assistant","content":"```cryptol\nx = [True, False]\ny = [False, True]\nz = x + y\n\nproperty p1 = z == 3\n\nxx = [[True,False]]\nyy = [[False, True]]\nzz = xx + yy\n\n\n\nt : {a} [a*3] -> [a*3][a*3]\nt d = zero\n```"}]}
{"filename":"cryptol\/examples\/demote.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property specification that verifies the function 'x' correctly transforms an input sequence of length 'a' into an output sequence of length '(a*2)+3'. Ensure the property checks the output length for various input lengths and that the function's behavior matches the intended type signature."},{"role":"assistant","content":"```cryptol\nx : {a}(fin a) => [a] -> [(a*2)+3]\nx v = 0 + 1\n\ny = x (2 : [3])\n```"}]}
{"filename":"cryptol\/examples\/append.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the behavior of the list append operation (#) as used in the given code. Then, write Cryptol properties to verify that the concatenated sequence z equals the sequence x followed by y, and that indexing into z returns the correct elements from x or y accordingly."},{"role":"assistant","content":"```cryptol\nx : [_][8]\nx = [1,2,3,4,5,19,12,38,5,3]\n\ny : [_][8]\ny = [19,3,27,5,12]\n\nz = x # y\n\nm = z @ (0 : [1]) w = z @ 2 t = z @ 10 v = z @ 11\n```"}]}
{"filename":"cryptol\/examples\/split.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the function 'split' correctly partitions a sequence into equal-sized chunks, preserving the order of elements. Specifically, ensure that concatenating the chunks produced by 'split' reconstructs the original sequence, and that indexing into the nested sequence matches the expected elements from the original sequence."},{"role":"assistant","content":"```cryptol\nx = [1,2,3,4] : [_][8]\n\ny = (split x) : [2][2][8]\n\na = (y@0) @ 0\nb = (y@0) @ 1\nc = (y@1) @ 0\nd = (y@1) @ 1\n```"}]}
{"filename":"cryptol\/lib\/Array.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the arrayRangeLookup and arrayRangeUpdate functions in the Array module. The properties should ensure that arrayRangeLookup returns the exact sequence of elements starting at the given index, and that arrayRangeUpdate correctly updates the array elements at the specified index range with the provided values. Include boundary conditions and ensure no wrap-around occurs."},{"role":"assistant","content":"```cryptol\nmodule Array where\n\nprimitive type Array : * -> * -> *\n\nprimitive arrayConstant : {a, b} b -> (Array a b)\nprimitive arrayLookup : {a, b} (Array a b) -> a -> b\nprimitive arrayUpdate : {a, b} (Array a b) -> a -> b -> (Array a b)\nprimitive arrayEq : {n, a} (Array [n] a) -> (Array [n] a) -> Bool\n\n\/**\n * Copy elements from the source array to the destination array.\n *\n * 'arrayCopy dest_arr dest_idx src_arr src_idx len' copies the\n * elements from 'src_arr' at indices '[src_idx ..< (src_idx + len)]' into\n * 'dest_arr' at indices '[dest_idx ..< (dest_idx + len)]'.\n *\n * The result is undefined if either 'dest_idx + len' or 'src_idx + len'\n * wraps around.\n *\/\nprimitive arrayCopy : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> (Array [n] a)\n\/**\n * Set elements of the given array.\n *\n * 'arraySet' arr idx val len' sets the elements of 'arr' at indices\n * '[idx ..< (idx + len)]' to 'val'.\n *\n * The result is undefined if 'idx + len' wraps around.\n *\/\nprimitive arraySet : {n, a} (Array [n] a) -> [n] -> a -> [n] -> (Array [n] a)\n\/**\n * Check whether the lhs array and rhs array are equal at a range of\n * indices.\n *\n * 'arrayRangeEq sym lhs_arr lhs_idx rhs_arr rhs_idx len' checks whether\n * the elements of 'lhs_arr' at indices '[lhs_idx ..< (lhs_idx + len)]' and\n * the elements of 'rhs_arr' at indices '[rhs_idx ..< (rhs_idx + len)]' are\n * equal.\n *\n * The result is undefined if either 'lhs_idx + len' or 'rhs_idx + len'\n * wraps around.\n *\/\nprimitive arrayRangeEqual : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> Bool\n\narrayRangeLookup : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b\narrayRangeLookup arr idx = res\n  where\n    res @ i = arrayLookup arr (idx + i)\n\narrayRangeUpdate : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b -> (Array a b)\narrayRangeUpdate arr idx vals = arrs ! 0\n  where\n    arrs = [arr] # [ arrayUpdate acc (idx + i) val | acc <- arrs | i <- [0 ..< n] | val <- vals ]\n```"}]}
{"filename":"saw-script\/examples\/partial-spec\/partial-spec.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from source.bc, defines let-bound specs inc_spec and use_inc_spec for the functions inc and use_inc respectively. Use llvm_fresh_var to create symbolic inputs for the struct my_struct pointer in inc_spec, set minimal preconditions to ensure safety, and verify that inc increments the counter field by one. In use_inc_spec, verify that use_inc returns 1. Then verify both functions using llvm_verify with the loaded module and the defined specs.\n\n# Source code:\nsource.c\n```C\nstruct my_nested {\n        int counter1;\n        int counter2;\n};\n\nstruct my_struct {\n    unsigned int counter;\n    char *p;\n};\n\nvoid inc(struct my_struct *s) {\n        s->counter++;\n}\n\nunsigned int use_inc(void) {\n        struct my_struct m = { .counter = 0 };\n        inc(&m);\n        return m.counter;\n}\n\n```"},{"role":"assistant","content":"```saw\nlet inc_spec : CrucibleSetup () = do {\n  m <- llvm_alloc (llvm_alias \"struct.my_struct\");\n  counter <- llvm_fresh_var \"counter\" (llvm_int 32);\n  llvm_points_to (llvm_field m \"counter\") (llvm_term counter);\n  llvm_execute_func [m];\n  llvm_points_to (llvm_field m \"counter\") (llvm_term {{counter+1}});\n};\n\nlet use_inc_spec : CrucibleSetup () = do {\n  llvm_execute_func [];\n  llvm_return (llvm_term {{1:[32]}});\n};\n\nlet main : TopLevel () = do {\n    m <- llvm_load_module \"source.bc\";\n    inc <- llvm_verify m \"inc\" [] false inc_spec abc;\n    llvm_verify m \"use_inc\" [inc] false use_inc_spec abc;\n    print \"done\";\n};\n```"}]}
{"filename":"saw-script\/examples\/multi-override\/multi-override.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from source.bc and verifies the following C functions with let-bound specs: (1) identity_spec verifying int identity(int x) with a symbolic int input; (2) example_spec verifying int example(void) with no inputs; (3) sum_spec verifying unsigned int sum(unsigned int *arr, int n) with a symbolic array and symbolic length n, adding preconditions to ensure n is within array bounds; (4) example_sums_spec verifying unsigned int example_sums(void) with no inputs; (5) set_myglobal_spec verifying void add_myglobal(int x) with a symbolic int input and proper global allocation and initialization; (6) myglobal_example_spec verifying int myglobal_example(void) with no inputs. Use llvm_fresh_var for symbolic inputs, llvm_alloc_global for globals, and llvm_points_to for memory state. Do not inline specs; bind each spec to a let variable before use. Reference exact function names as in source.c.\n\n# Source code:\nsource.c\n```C\nint identity(int x) { return x; }\nint example(void) { return identity(1) + identity(2); }\nint bad_example(void) { return identity(3); }\n\nunsigned int sum (unsigned int *arr, int n) {\n        unsigned int acc = 0;\n        for (int i = 0; i < n; i++) {\n            acc += arr[i];\n        }\n        return acc;\n}\nunsigned int example_sums(void) {\n        unsigned int nums[10] = {0,1,2,3,4,6,7,8,9};\n        return sum(nums, 10) + sum(nums+2,6);\n}\n\nint myglobal;\n\nvoid add_myglobal(int x) { myglobal = myglobal * myglobal; myglobal += x; }\nint myglobal_example(void) {\n  myglobal = 0;\n  add_myglobal(10);\n  add_myglobal(20);\n  return myglobal;\n}\n\n```"},{"role":"assistant","content":"```saw\nimport \"imports.cry\";\n\nlet identity_spec n : CrucibleSetup () = do {\n  llvm_execute_func [llvm_term n];\n  llvm_return (llvm_term n);\n};\n\nlet example_spec : CrucibleSetup () = do {\n  llvm_execute_func [];\n  llvm_return (llvm_term {{3:[32]}});\n};\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet sum_spec n : CrucibleSetup() = do {\n  (arr,arrp) <- ptr_to_fresh \"arr\" (llvm_array n (llvm_int 32));\n\n  llvm_execute_func[arrp, llvm_term {{ `n:[32]}}];\n  llvm_return (llvm_term {{ mysum arr }});\n  llvm_points_to arrp (llvm_term arr);\n};\n\nlet example_sums : CrucibleSetup() = do {\n  llvm_execute_func[];\n  llvm_return (llvm_term {{ 70:[32] }});\n};\n\nlet set_myglobal n : CrucibleSetup() = do {\n  llvm_alloc_global \"myglobal\";\n  old <- llvm_fresh_var \"old\" (llvm_int 32);\n  llvm_precond {{ old < 1000 }};\n  llvm_points_to (llvm_global \"myglobal\") (llvm_term old);\n  llvm_execute_func[llvm_term {{ `n : [32] }}];\n  llvm_points_to (llvm_global \"myglobal\")\n                     (llvm_term {{ `n + old*old : [32] }});\n};\n\nlet myglobal_example : CrucibleSetup() = do {\n  llvm_alloc_global \"myglobal\";\n  llvm_execute_func[];\n  llvm_return (llvm_term {{ 120 : [32] }});\n  llvm_points_to (llvm_global \"myglobal\")\n                 (llvm_term {{ 120 : [32] }});\n};\n\nlet main : TopLevel () = do {\n\n    m <- llvm_load_module \"source.bc\";\n    id1 <- llvm_verify m \"identity\" [] false (identity_spec {{1:[32]}}) abc;\n    id2 <- llvm_verify m \"identity\" [] false (identity_spec {{2:[32]}}) abc;\n    llvm_verify m \"example\"     [id1,id2] false example_spec z3;\n    \/\/llvm_verify \"bad_example\" [id1,id2] false example_spec (do { print_goal; assume_unsat; });\n\n    sum3  <- llvm_verify m \"sum\" [] false (sum_spec  3) z3;\n    sum6  <- llvm_verify m \"sum\" [] false (sum_spec  6) z3;\n    sum10 <- llvm_verify m \"sum\" [] false (sum_spec 10) z3;\n    sum12 <- llvm_verify m \"sum\" [] false (sum_spec 12) z3;\n    llvm_verify m \"example_sums\" [sum3,sum12, sum6,sum10] false example_sums z3;\n\n    set10 <- llvm_verify m \"add_myglobal\" [] false (set_myglobal 10) z3;\n    set20 <- llvm_verify m \"add_myglobal\" [] false (set_myglobal 20) z3;\n    set30 <- llvm_verify m \"add_myglobal\" [] false (set_myglobal 30) z3;\n    llvm_verify m \"myglobal_example\" [set10,set20,set30] false myglobal_example z3;\n    llvm_verify m \"myglobal_example\" [set20,set30,set10] false myglobal_example z3;\n    llvm_verify m \"myglobal_example\" [set30,set10,set20] false myglobal_example z3;\n    print \"done\";\n};\n```"}]}
{"filename":"saw-script\/examples\/llvm\/ptr.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module ptr.bc that verifies the functions add, clear, and copy defined in ptr.c. Define let-bound specs named add_spec, clear_spec, and copy_spec respectively. For add_spec, create two fresh 32-bit integer pointers x and y, allocate and initialize them symbolically, execute the add function with these pointers, and verify the return value equals the sum of the pointed-to values. For clear_spec, create a fresh array of 10 32-bit integers, allocate and initialize it symbolically, execute clear with this array pointer, and verify the array is zeroed. For copy_spec, create two fresh arrays of 10 32-bit integers a and b, allocate and initialize them symbolically, execute copy with their pointers, and verify that a equals b after execution. Use llvm_fresh_var and llvm_alloc as needed and include minimal preconditions for safety. Do not inline specs in calls; bind them with let. Use llvm_execute_func and llvm_points_to accordingly.\n\n# Source code:\nptr.c\n```C\nunsigned int add(unsigned int *x, unsigned int *y) {\n    return *x + *y;\n}\n\nvoid clear(int a[10]) {\n    for(int i = 0; i < 10; i++) {\n        a[i] = 0;\n    }\n}\n\nvoid copy(int a[10], int b[10]) {\n    for(int i = 0; i < 10; i++) {\n        a[i] = b[i];\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet add_setup = do {\n    (x, xp) <- ptr_to_fresh \"x\" (llvm_int 32);\n    (y, yp) <- ptr_to_fresh \"y\" (llvm_int 32);\n    llvm_execute_func [xp, yp];\n    llvm_return (llvm_term {{ x + y : [32] }});\n};\n\nlet clear_setup = do {\n    (a, ap) <- ptr_to_fresh \"a\" (llvm_array 10 (llvm_int 32));\n    llvm_execute_func [ap];\n    llvm_points_to ap (llvm_term {{ zero : [10][32] }});\n};\n\nlet copy_setup = do {\n    (a, ap) <- ptr_to_fresh \"a\" (llvm_array 10 (llvm_int 32));\n    (b, bp) <- ptr_to_fresh \"b\" (llvm_array 10 (llvm_int 32));\n    llvm_execute_func [ap, bp];\n    llvm_points_to ap (llvm_term b);\n};\n\nlet main : TopLevel () = do {\n    m <- llvm_load_module \"ptr.bc\";\n    add_ms <- llvm_verify m \"add\" [] false add_setup abc;\n    clear_ms <- llvm_verify m \"clear\" [] false clear_setup abc;\n    copy_ms <- llvm_verify m \"copy\" [] false copy_setup abc;\n    print \"Done.\";\n};\n```"}]}
{"filename":"saw-script\/examples\/llvm\/ptrcheck.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"ptrcheck.bc\" that verifies the function \"f\" with signature \"uint32_t f(s*)\". Define a let-bound spec named f_spec that uses llvm_fresh_var to create a symbolic pointer of type \"struct.s*\", allocates and initializes memory for it, and includes minimal preconditions ensuring the pointer is non-null to avoid undefined behavior. Then call llvm_execute_func with the symbolic pointer and verify the function returns the expected result. Do not inline the spec; bind it with let before use.\n\n# Source code:\nptrcheck.c\n```C\n#include <stdint.h>\n#include <stdlib.h>\n\ntypedef struct {\n    uint32_t x;\n    uint32_t y;\n    uint32_t z;\n    uint32_t w;\n} s;\n\nuint32_t f(s* sp) {\n    if(sp == NULL) {\n        return 1;\n    } else if(&(sp->x) == NULL) {\n        return 2;\n    } else if(&(sp->y) == NULL) {\n        return 3;\n    } else if(&(sp->z) == NULL) {\n        return 4;\n    } else if(&(sp->w) == NULL) {\n        return 5;\n    } else {\n        return 0;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"ptrcheck.bc\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nllvm_verify m \"f\" [] false do {\n    (s, sp) <- ptr_to_fresh \"s\" (llvm_alias \"struct.s\");\n    llvm_execute_func [sp];\n    llvm_return (llvm_term {{ 0 : [32] }});\n} abc;\n```"}]}
{"filename":"saw-script\/examples\/llvm\/global.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from global.bc that verifies the functions clear(), set(uint32_t), and get() defined in global.c. Define let-bound specs named clear_spec, set_spec, and get_spec using llvm_fresh_var to create symbolic inputs where needed. For set_spec, create a symbolic 32-bit integer input x and verify that after calling set(x), the global variable g points to x. For clear_spec, verify that after calling clear(), g is zero. For get_spec, initialize g to a symbolic 32-bit integer x, call get(), and verify the returned value equals x. Use llvm_alloc_global and llvm_points_to to model the global variable g. Do not inline the specs in the verify calls; instead, pass the let-bound specs as arguments to llvm_verify.\n\n# Source code:\nglobal.c\n```C\n#include <stdint.h>\n\nuint32_t g;\n\nvoid clear() {\n    g = 0;\n}\n\nvoid set(uint32_t x) {\n    g = x;\n}\n\nuint32_t get() {\n    return g;\n}\n\n```"},{"role":"assistant","content":"```saw\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet clear_setup = do {\n    llvm_alloc_global \"g\";\n    llvm_execute_func [];\n    llvm_points_to (llvm_global \"g\") (llvm_term {{ 0 : [32] }});\n};\n\nlet set_setup = do {\n    llvm_alloc_global \"g\";\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_execute_func [llvm_term x];\n    llvm_points_to (llvm_global \"g\") (llvm_term x);\n};\n\nlet get_setup = do {\n    llvm_alloc_global \"g\";\n    let g = llvm_global \"g\";\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_points_to g (llvm_term x);\n    llvm_execute_func [llvm_term x];\n    llvm_points_to g (llvm_term x);\n    llvm_return (llvm_term x);\n};\n\nlet main : TopLevel () = do {\n    m <- llvm_load_module \"global.bc\";\n    llvm_verify m \"clear\" [] false clear_setup abc;\n    llvm_verify m \"set\" [] false set_setup abc;\n    llvm_verify m \"get\" [] false get_setup abc;\n    print \"Done.\";\n};\n```"}]}
{"filename":"saw-script\/examples\/llvm\/nested.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function 'f' defined in 'nested.bc' compiled from 'nested.c'. Define a let-bound specification 'f_spec' that allocates a symbolic pointer to the struct 't_t', uses symbolic 32-bit integer variables for the nested field 'n.b', sets the appropriate memory points-to conditions for 'p->n.b', executes the function 'f' with the symbolic pointer as input, and returns the symbolic value corresponding to 'p->n.b'. Use 'llvm_fresh_var' for symbolic inputs and ensure the spec matches the exact function signature 'uint32_t f(t_t *)'.\n\n# Source code:\nnested.c\n```C\n#include <stdint.h>\n\ntypedef struct s {\n    uint32_t a;\n    uint32_t b;\n} s_t;\n\ntypedef struct t {\n    uint32_t x;\n    s_t n;\n    uint32_t z;\n} t_t;\n\nuint32_t f(t_t *p) {\n    return (p->n).b;\n}\n\n```"},{"role":"assistant","content":"```saw\nlet f_spec = do {\n    tp <- llvm_alloc (llvm_alias \"struct.t\");\n    b <- llvm_fresh_var \"b\" (llvm_int 32);\n\n    \/\/ The following will work if nested.bc is compiled with debug info\n    \/\/ with Clang 3.7 or greater\n    llvm_points_to (llvm_field (llvm_field tp \"n\") \"b\") (llvm_term b);\n\n    \/\/ The following can be a workaround if debug info is not available\n    \/\/llvm_points_to (llvm_elem (llvm_elem tp 1) 1) (llvm_term b);\n\n    llvm_execute_func [tp];\n    llvm_return (llvm_term b);\n};\n\nm <- llvm_load_module \"nested.bc\";\n\nllvm_verify m \"f\" [] false f_spec abc;\n```"}]}
{"filename":"saw-script\/examples\/llvm\/struct.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from struct.bc and defines let-bound specs named set_spec, add_spec, and id_spec for the functions set_indirect, add_indirect, and s_id respectively. Each spec should use llvm_fresh_var to create symbolic inputs matching the function parameters, allocate and initialize memory for the struct s and its unsigned int pointer member x as needed, execute the corresponding function with llvm_execute_func, and specify the expected postconditions using llvm_points_to and llvm_return. Include minimal preconditions to ensure safety and termination, such as valid pointer allocations and array bounds for the two-element unsigned int array pointed to by x.\n\n# Source code:\nstruct.c\n```C\ntypedef struct {\n    unsigned int *x;\n} s;\n\nint add_indirect(s *o) {\n    return (o->x)[0] + (o->x)[1];\n}\n\nvoid set_indirect(s *o) {\n    (o->x)[0] = 0;\n    (o->x)[1] = 0;\n}\n\ns *s_id(s *o) {\n    return o;\n}\n\n```"},{"role":"assistant","content":"```saw\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet set_spec = do {\n    (x, px) <- ptr_to_fresh \"x\" (llvm_array 2 (llvm_int 32));\n    po <- alloc_init (llvm_alias \"struct.s\") (llvm_struct_value [px]);\n    llvm_execute_func [po];\n    llvm_points_to po (llvm_struct_value [px]);\n    llvm_points_to px (llvm_term {{ [0, 0] : [2][32] }});\n};\n\nlet add_spec = do {\n    (x, px) <- ptr_to_fresh \"x\" (llvm_array 2 (llvm_int 32));\n    po <- alloc_init (llvm_alias \"struct.s\") (llvm_struct_value [px]);\n    llvm_execute_func [po];\n    llvm_return (llvm_term {{ x@0 + x@1 }});\n};\n\nlet id_spec = do {\n    (x, px) <- ptr_to_fresh \"x\" (llvm_array 2 (llvm_int 32));\n    po <- alloc_init (llvm_alias \"struct.s\") (llvm_struct_value [px]);\n    llvm_execute_func [po];\n    llvm_return po;\n};\n\nm <- llvm_load_module \"struct.bc\";\nllvm_verify m \"set_indirect\" [] false set_spec abc;\nllvm_verify m \"add_indirect\" [] false add_spec abc;\nllvm_verify m \"s_id\" [] false id_spec abc;\n```"}]}
{"filename":"saw-script\/examples\/llvm\/assert-null.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'assert-null.bc' and defines a let-bound specification named 'f_spec' for the function 'f' with signature 'int f(int *x)'. Use 'llvm_fresh_var' to create a symbolic pointer input for 'x'. Include minimal preconditions to ensure safety. The spec should execute 'f' with the symbolic input and return the expected result based on whether 'x' is null or not. Then verify 'f' against this specification using 'llvm_verify'.\n\n# Source code:\nassert-null.c\n```C\nint f(int *x) {\n    return (x == (int*)0);\n}\n\n```"},{"role":"assistant","content":"```saw\nlet f_spec1 = do {\n    p <- llvm_alloc (llvm_int 32);\n    llvm_execute_func [p];\n    llvm_return (llvm_term {{ 0 : [32] }});\n};\n\nlet f_spec2 = do {\n    llvm_execute_func [llvm_null];\n    llvm_return (llvm_term {{ 1 : [32] }});\n};\n\nm <- llvm_load_module \"assert-null.bc\";\nllvm_verify m \"f\" [] false f_spec1 abc;\nllvm_verify m \"f\" [] false f_spec2 abc;\n```"}]}
{"filename":"saw-script\/examples\/llvm\/basic.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'basic.bc' and defines let-bound specs for verifying the functions 'first', 'second', 'add', and 'dbl' as defined in 'basic.c'. Use llvm_fresh_var to create symbolic 32-bit integer inputs for each function. For 'first' and 'second', specify that 'first(x,y)' returns 'x' and 'second(x,y)' returns 'y'. For 'add(x,y)', specify it returns the sum of 'x' and 'y'. For 'dbl(x)', specify it returns the result of calling 'add(x,x)'. Use llvm_execute_func to execute each function with symbolic inputs and llvm_return to specify expected outputs. Include minimal preconditions if needed for safety or termination. Do not inline specs; bind each spec to a let variable before verification calls.\n\n# Source code:\nbasic.c\n```C\n#include <stdint.h>\nuint32_t first(uint32_t x, uint32_t y) {\n    return x;\n}\n\nuint32_t second(uint32_t x, uint32_t y) {\n    return y;\n}\n\nuint32_t add(uint32_t x, uint32_t y) {\n    return x + y;\n}\n\nuint32_t dbl(uint32_t x) {\n    return add(x, x);\n}\n\n```"},{"role":"assistant","content":"```saw\nlet add_setup = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    llvm_execute_func [llvm_term x, llvm_term y];\n    llvm_return (llvm_term {{ x + y : [32] }});\n};\n\nlet dbl_setup = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_execute_func [llvm_term x];\n    llvm_return (llvm_term {{ x + x : [32] }});\n};\n\nm <- llvm_load_module \"basic.bc\";\nadd_ms <- llvm_verify m \"add\" [] false add_setup abc;\nllvm_verify m \"dbl\" [add_ms] false dbl_setup abc;\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/examples\/llvm\/assert.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from \"assert.bc\" and defines a let-bound specification named f_spec. The spec should symbolically create a 32-bit integer variable x with a precondition x != 0 to ensure safety of the function f(int x). Then execute the function f with this symbolic input. Finally, verify the function f against f_spec using llvm_verify.\n\n# Source code:\nassert.c\n```C\n#include <assert.h>\n\nvoid f(int x) {\n    assert(x != 0);\n}\n\n```"},{"role":"assistant","content":"```saw\nlet f_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_precond {{ x > 0 }};\n  llvm_execute_func [llvm_term x];\n};\n\nm <- llvm_load_module \"assert.bc\";\nllvm_verify m \"f\" [] true f_spec abc;\n```"}]}
{"filename":"saw-script\/examples\/llvm\/nested-full.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'nested.bc' and defines a let-bound specification named 'f_spec'. The specification should create symbolic 32-bit integer variables for the fields 'x', 'a', 'b', and 'z' of the struct 't_t' and its nested struct 's_t' as defined in 'nested.c'. Initialize a pointer to a 't_t' struct with these symbolic values, then execute the function 'f' with this pointer as argument. Finally, assert that the function returns the symbolic variable corresponding to the nested field 'b' of the struct 's_t'. Include any minimal preconditions necessary for safety. Do not inline the specification in the call to 'llvm_verify'.\n\n# Source code:\nnested.c\n```C\n#include <stdint.h>\n\ntypedef struct s {\n    uint32_t a;\n    uint32_t b;\n} s_t;\n\ntypedef struct t {\n    uint32_t x;\n    s_t n;\n    uint32_t z;\n} t_t;\n\nuint32_t f(t_t *p) {\n    return (p->n).b;\n}\n\n```"},{"role":"assistant","content":"```saw\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet f_spec = do {\n    a <- llvm_fresh_var \"a\" (llvm_int 32);\n    b <- llvm_fresh_var \"b\" (llvm_int 32);\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    z <- llvm_fresh_var \"z\" (llvm_int 32);\n    let s = (llvm_term {{ (x, (a, b), z) }});\n    p <- alloc_init (llvm_alias \"struct.t\") s;\n    llvm_execute_func [p];\n    llvm_return (llvm_term {{ b }});\n};\n\nm <- llvm_load_module \"nested.bc\";\nllvm_verify m \"f\" [] false f_spec abc;\n```"}]}
{"filename":"saw-script\/examples\/java\/branchsat.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java class BranchTest that defines a let-bound specification named f_spec. The spec should symbolically verify the static method BranchTest.f(int) by using jvm_fresh_var to create a symbolic 32-bit integer input x with a precondition that x is non-negative and less than 10 to ensure termination of the loop. The spec should execute the method with this symbolic input and verify that the return value equals x*(x-1)\/2. Use jvm_load_class to load BranchTest and jvm_verify to verify the method against f_spec.\n\n# Source code:\nBranchTest.java\n```java\nclass BranchTest {\n    static int f(int x) {\n        int r = 0;\n        for(int i = 0; i < x; i++) {\n            r = r + i;\n        }\n        return r;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"BranchTest\";\n\n\/\/ FIXME: make this terminate with the symbolic precondition\n\/\/ The following will not terminate if the last parameter is `false`\njvm_verify c \"f\" [] true\n  do {\n    let x = {{ 6 : [32] }}; \/\/ FIXME\n    \/\/ x <- jvm_fresh_var \"x\" java_int;\n    \/\/ jvm_precond {{ x < 10 }};\n    jvm_execute_func [jvm_term x];\n    jvm_return (jvm_term {{ x * (x - 1) \/ 2 }});\n  }\n  abc;\n```"}]}
{"filename":"saw-script\/examples\/java\/arrays.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java class ArrayTest that defines a let-bound spec for each method: unit_spec, copy_spec, clear_spec, sum_spec, comp_spec, and arr_id_spec. Each spec should use jvm_fresh_var to create symbolic input arrays of length 10 of type java_int, allocate necessary objects and arrays with jvm_alloc_object and jvm_alloc_array, and call the corresponding method (e.g., ArrayTest.unit, ArrayTest.copy) with appropriate arguments. Include minimal preconditions ensuring array lengths are 10 for safe iteration. Use jvm_array_is to assert expected array states after execution, and jvm_return to specify return values where applicable. Do not inline specs; bind them with let. Reference exact method signatures from ArrayTest.java.\n\n# Source code:\nArrayTest.java\n```java\nimport java.util.Arrays;\n\nclass ArrayTest {\n    void unit(int a[]) {\n        for(int i = 0; i < a.length; i++) a[i] = 0;\n        a[0] = 1;\n    }\n\n    void copy(int a[], int b[]) {\n        for(int i = 0; i < a.length; i++) b[i] = a[i];\n    }\n\n    void clear(int a[]) {\n        Arrays.fill(a, 0);\n    }\n\n    int sum(int a[]) {\n        int sum = 0;\n        for(int i = 0; i < a.length; i++) sum += a[i];\n        return sum;\n    }\n\n    void comp(int a[]) {\n        unit(a);\n    }\n\n    int[] arr_id(int a[]) {\n        return a;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"ArrayTest\";\n\ncopy_ms <-\njvm_verify c \"copy\" [] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    b_ref <- jvm_alloc_array 10 java_int;\n    a <- jvm_fresh_var \"a\" (java_array 10 java_int);\n    jvm_array_is a_ref a;\n    jvm_execute_func [this, a_ref, b_ref];\n    jvm_array_is b_ref a;\n  }\n  abc;\n\nunit_ms <-\njvm_verify c \"unit\" [] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    jvm_execute_func [this, a_ref];\n    jvm_array_is a_ref {{ [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] : [10][32] }};\n  }\n  abc;\n\nclear_ms <-\njvm_verify c \"clear\" [] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    jvm_execute_func [this, a_ref];\n    jvm_array_is a_ref {{ zero : [10][32] }};\n  }\n  abc;\n\nsum_ms <-\njvm_verify c \"sum\" [] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    a <- jvm_fresh_var \"a\" (java_array 10 java_int);\n    jvm_array_is a_ref a;\n    jvm_execute_func [this, a_ref];\n    jvm_return (jvm_term {{ sum a }});\n  }\n  abc;\n\ncomp_ms <-\njvm_verify c \"comp\" [unit_ms] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    jvm_execute_func [this, a_ref];\n    jvm_array_is a_ref {{ [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] : [10][32] }};\n  }\n  abc;\n```"}]}
