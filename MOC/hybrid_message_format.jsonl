{"filename":"cryptol\/examples\/splitAt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Implement the task using the Cryptol specification language. Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Assign 4 8-bit integers to a variable named x. Do not define the length of the list when instantiating x. Next apply the splitAt method to x and to split x into 2 equal length list and assign the result to y. Next assign the integers in the variable y to the variables a, b, c, d. Use the dot operator to access the list in the tuple and then use the @ operator to extract each integer from the list."},{"role":"assistant","content":"```cryptol\nx = [1,2,3,4] : [_][8]\n\ny = (splitAt x) : ([2][8],[2][8])\n\na = y.0 @ 0\nb = y.0 @ 1\nc = y.1 @ 0\nd = y.1 @ 1\n```"}]}
{"filename":"cryptol\/examples\/AE.cry","filetype":"cryptol","messages":[{"role":"system","content":"Implement the task using the Cryptol specification language. Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named AE that defines a generic authenticated encryption interface modeled after the Hoang–Katz–Malozemoff paper. In particular, define functions and type signatures needs to implement the encryption algorithm. Define a function and type signature name `encrypt` that accepts the parameters	 `key nonce state inputMsg = encMsg # tag` that splits the input message into m chunks, each of p blocks. Iteratively calls Enc on each chunk with a tweak derived from a growing integer (v, incremented by Cost). Accumulates the resulting ciphertext chunks into encMsg. Uses the final state plus a tweak derived from the final v to compute an n-bit tag, then truncates to tagAmount bits and returns Uses the final state plus a tweak derived from the final v to compute an n-bit tag, then truncates to tagAmount bits. Inside a comment supply a decrypt property."},{"role":"assistant","content":"```cryptol\n\/*\nImplementation of the algorithms from the paper\n  \"Automated Analysis and Synthesis of Authenticated Encryption Schemes\"\n  by Viet Tung Hoang, Jonathan Katz, and Alex J. Malozemoff\n*\/\nmodule AE where\n\nparameter\n  type A : *            type K : *            type n : #            type p : #            type tagAmount : #\n\n  type constraint (fin p, fin n, n >= tagAmount)\n\n  \/\/ Process a single block using this key and tweak\n  tweak_cipher : K -> { nonce : [n], state : A, z : [64] } -> [n] -> [n]\n\n  \/\/ Cost for using the tweak\n  Cost : [64]\n\n  Enc : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Dec : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Tag : K -> { nonce : [n], state : A, z : [64] } -> [p*n] -> [n]\n\n\/\/ The unit at which `Enc` operates\ntype Node       = { message : WorkBlock, state : State }\n\n\/\/ Some encryption schemes process multiple blocks at once\ntype WorkBlock  = [p*n]\n\ntype State      = [p*n]  \/\/ The state for `p` blocks\n\ntype Tweak      = { nonce : Nonce, state : A, z : Int }\ntype Nonce      = [n]\n\n\/*\nproperty\n\n  \/\/ The tweak in the `i`th query to the tweak_cipher\n  tweak_prop i { nonce = n, state = a, z = v } =\n               { nonce = n, state = a, z = v + i - 1 }\n\n\n  \/\/ Property of decrypt\n  Dec_prop : Tweak -> Node -> Bit\n  Dec_prop t { message = m, state = x } =\n       Dec t { message = c, state = x } == { message = m, state = y }\n       where { message = c, state = y } = Enc t x m\n*\/\n\ntype Int = [64]\n\nencrypt :\n  {m} fin m => K -> Nonce -> A -> [m * (p * n)] -> [m * (p * n) + tagAmount]\nencrypt key nonce state inputMsg = encMsg # tag\n\n  where\n  encMsg = join rest.0.message\n\n  tag = take (Tag key (tweak (1 - final.1)) final.0.state)\n\n  final = steps ! 0\n\n  steps = [ ({ message = undefined, state = zero }, 1) ] # rest\n  rest  = [ (Enc key (tweak v) { message = m, state = prev.state }, v + Cost)\n          | (prev,v) <- steps\n          | m        <- chunks\n          ]\n\n  \/\/ XXX: isn't v i  just 1 + i * Cost\n\n  chunks : [m] [p * n]\n  chunks = split inputMsg\n\n  tweak : Int -> Tweak\n  tweak v = { nonce = nonce, state = state, z = v }\n```"}]}
{"filename":"cryptol\/examples\/xor_cipher.cry","filetype":"cryptol","messages":[{"role":"system","content":"Implement the task using the Cryptol specification language. Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the functions and type signatures 'encrypt' and 'decrypt'. The functions should perform encryption and decryption using the xor cipher algorithm. Each should take an 8-bit integer and finite 8-bit string as input. Define the property roundtrip that verifies for every key and plaintext input, decrypt inverts encrypt back to the original plaintext."},{"role":"assistant","content":"```cryptol\nencrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\nencrypt key plaintext = [pt ^ key | pt <- plaintext ]\n\ndecrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\ndecrypt key ciphertext = [ct ^ key | ct <- ciphertext ]\n\nproperty roundtrip k ip = decrypt k (encrypt k ip) == ip\n```"}]}
{"filename":"cryptol\/examples\/zero_weird.cry","filetype":"cryptol","messages":[{"role":"system","content":"Implement the task using the Cryptol specification language. Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a function x that takes an argument of type a, and returns a 16-bit word equal to zero. Define a function y that takes a 12-bit word and 4-bit word as arguments and returns a 17-bit word. The function y should always return zero represented as 17 bits. Define a property `xprop` that proves for every input v, x v equals 0. Define a property `yprop` that proves for every input v w, y v w equals 0. Call the functions x and y and assign the results to the variables t1 and t2."},{"role":"assistant","content":"```cryptol\nx : {a}() => a -> [16]\nx v = zero v \n\nproperty xprop v = x v == 0\n\ny : [12] -> [4] -> [17]\ny a b = zero a b\n\nproperty yprop v w = y v w == 0\n\nt1 = x 13\nt2 = y 2 3\n```"}]}
