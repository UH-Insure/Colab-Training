j05hr3d/SFT-Qwen2.5-Coder-7B_v1.1st Eval Suite Results
Started at 2025-12-10_09:22:26 Ended at 2025-12-10_09:33:23
Processed 34 tasks.

=== FINAL SCORE: N/A (no executed tasks) ===


=== Task 1 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Implement a function named `xor8` which takes two 8-bit words and returns their bitwise XOR. Also provide a constant `zero8` equal to 0 (8-bit).

[PROMPT END]

[GENERATED BEGIN]
```cryptol
xor8 : [8] -> [8] -> [8]
xor8 x y = x ^ y

zero8 : [8]
zero8 = 0
```
[GENERATED END]


=== Task 2 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Implement a function named `matrix` which takes no input and returns a 3 x 3 matrix of tuples. For the function use a nested comprehension to write an expression to produce a 3 × 3 matrix (as a sequence of sequences), such that the ijth entry contains the value (i, j).

[PROMPT END]

[GENERATED BEGIN]
```cryptol
matrix = [[(i, j) | j <- [1..3]] | i <- [1..3]]
```
[GENERATED END]


=== Task 3 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Implement a Caesar cipher. Define the functions `encrypt` and `decrypt` with the signature: `{n} [8] -> [n][8] -> [n][8]`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
encrypt : {n} [8] -> [n][8] -> [n][8]
encrypt k msg = [m + k | m <- msg]
decrypt : {n} [8] -> [n][8] -> [n][8]
decrypt k ct = [c - k | c <- ct]
```
[GENERATED END]


=== Task 4 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Using ONLY the functions and constraints provided, create a monomorphic Cryptol property named `equivalent` that proves decrypt inverts encrypt for a 512-byte plaintext.

### Additional setup code:
```cryptol
encryptChar : [8] -> [8] -> [8]
encryptChar key c = (c + key)
decryptChar : [8] -> [8] -> [8]
decryptChar key c = (c - key)
encrypt : {n} [8] -> [n][8] -> [n][8]
encrypt key txt = [ encryptChar key c | c <- txt ]
decrypt : {n} [8] -> [n][8] -> [n][8]
decrypt key txt = [ decryptChar key c | c <- txt ]
```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
encryptChar : [8] -> [8] -> [8]
encryptChar key c = (c + key)
decryptChar : [8] -> [8] -> [8]
decryptChar key c = (c - key)
encrypt : {n} [8] -> [n][8] -> [n][8]
encrypt key txt = [ encryptChar key c | c <- txt ]
decrypt : {n} [8] -> [n][8] -> [n][8]
decrypt key txt = [ decryptChar key c | c <- txt ]

property equivalent key pt = decrypt key (encrypt key pt) == pt
```
[GENERATED END]


=== Task 5 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA384` that imports the generic SHA-2 specification for SHA-384. Use `type DigestSize = 384`, `type w = 64`, and initialize the hash vector as `H0 = [
        0xcbbb9d5dc1059ed8, 0x629a292a367cd507,
        0x9159015a3070dd17, 0x152fecd8f70e5939,
        0x67332667ffc00b31, 0x8eb44a8768581511,
        0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4
    ]
`

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 =
    Primitive::Keyless::Hash::SHA2::Specification where

        type DigestSize = 384
        type w = 64

        H0 = [
            0xcbbb9d5dc1059ed8, 0x629a292a367cd507,
            0x9159015a3070dd17, 0x152fecd8f70e5939,
            0x67332667ffc00b31, 0x8eb44a8768581511,
            0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4
        ]
```
[GENERATED END]


=== Task 6 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Symmetric::Cipher::Block::AES::ExpandKey` that imports the generic `GF28`, `State`, and `SubByteSBox` of the AES encryption modules. Define `type Nk` and `type Nr` as parameters with the constraints that `Nk >= 1` with `8 >= width` and `Nr >= 2` with `8 >= width`. Define the functions `expandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)`, `expandKeyForever : [Nk][4][8] -> [inf]RoundKey`, `keyWS : [Nk][4][8] -> [inf][4][8]`, `Rcon : [8] -> [4]GF28`, `SubWord : [4]GF28 -> [4]GF28`, `RotWord : [4]GF28 -> [4]GF28`, and `NextWord : [8] ->[4][8] -> [4][8] -> [4][8]`. The module should perform AES key expansion. The type `RoundKey` is defined in the `State` module as the following.

### Additional setup code:
```cryptol
type State       = [4][Nb]GF28
type Nb          = 4
type RoundKey    = State
```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
type State       = [4][Nb]GF28
type Nb          = 4
type RoundKey    = State

module Primitive::Symmetric::Cipher::Block::AES::ExpandKey where

import Primitive::Symmetric::Cipher::Block::AES::GF28
import Primitive::Symmetric::Cipher::Block::AES::State
import Primitive::Symmetric::Cipher::Block::AES::SubByteSBox

type Nk = 4
type Nr = 6

expandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)
expandKey k = (rks@0, rks @@ ([1..Nr-2]), rks@(Nr-1))
  where
    rks = expandKeyForever (split (split k))

expandKeyForever : [Nk][4][8] -> [inf]RoundKey
expandKeyForever ks = ks # [rk | rk <- keyWS ks]

keyWS : [Nk][4][8] -> [inf][4][8]
keyWS ks = ks # [NextWord i (ks@(i-1)) (ks@(i-Nk)) (Rcon (fromInteger i))
                 | i <- [Nk ...]]

Rcon : [8] -> [4]GF28
Rcon i = [gf28Pow x (fromInteger (i-1)), 0, 0, 0]

SubWord : [4]GF28 -> [4]GF28
SubWord w = [SubByte b | b <- w]

RotWord : [4]GF28 -> [4]GF28
RotWord w = w <<< 1

NextWord : [8] -> [4][8] -> [4][8] -> [4][8] -> [4][8]
NextWord i prev prevPrev rc = SubWord (RotWord prev) ^ prevPrev ^ rc
```
[GENERATED END]


=== Task 7 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines an incremental averaging state machine. The specification should define the type `State` to contain a sum of all values and the amount of values as two 32-bit words, the functions `init` to initialize `State`, `appendf` that adds a value to `sum'` and increments `len`, `digest` that returns the average in the `State`, and `avg` with signature `avg : {n} (fin n, 32 >= width n) => [n][32] -> [32]` to compute the averages of a sequence.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
type State = { sum' : [32], len : [32] }
init : State
init = { sum' = 0, len = 0 }
appendf : {n} (fin n, 32 >= width n) => State -> [n] -> State
appendf st x = { sum' = st.sum' + x, len = st.len + 1 }
digest : State -> [32]
digest st = st.sum' / st.len
avg : {n} (fin n, 32 >= width n) => [n][32] -> [32]
avg xs = digest (foldl appendf init xs)
```
[GENERATED END]


=== Task 8 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Test` that imports `Cipher`. Define the function `evktest : {ks, bs, n} (fin bs) => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)`, that takes a cipher, `n` key and test vector tuples, and plain text. The function test that using the cipher’s `encrypt` to encrypt the plain text with each key from the test vectors will produce the cipher text in the test vectors. The function returns `n` tuples containing the cipher text produced by encrypting the plain text with each test key and a boolean value whether the cipher text matches the expected test vector.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Test where

import Cipher

evktest : {ks, bs, n} (fin bs) => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)
evktest (cipher, tests, pt) = [ (ct', ct' == ct) | (k, ct) <- tests ]
    where
        ct' = cipher.encrypt pt k
```
[GENERATED END]


=== Task 9 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module `ECDSA_test` with imports `Common::utils` and `Primitive::Asymmetric::Signature::ECDSA::p192 as p192`. Define a property for the function `G_compress R = ec_compress (ec_affinify G) == R` from the p192 module. Use the value `0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012` in your property.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module ECDSA_test where

import Common::utils
import Primitive::Asymmetric::Signature::ECDSA::p192 as p192

property test_G_compress R = p192::G_compress R == ec_compress (ec_affinify p192::G)
/* pragma R : [192] */
R = 0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012
```
[GENERATED END]


=== Task 10 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module `bivium` that generates the infinite keystream as specified by the Bivium stream cipher. Define the function `bivium_stream : [93] -> [84] -> [inf]` which takes two initial shift registers of lengths 93 and 84 bits and returns the infinite keystream according to the Bivium algorithm. Define `type N = 200`, and a function `Bivium : ([93], [84]) -> [N]Bit` which takes the two initial registers as a pair and returns the first N bits of the keystream returned from `bivium_stream`. Define the helper functions: `shift : {d} (fin d, d >=1) => [d] -> Bit -> [d]` that returns `fills` where `fills = [bit]#(drop`{1} (fill >> 1))`. The function `shift_regs : {d,e} (fin d, fin e, d >=1, e >=1) => [d] -> [e] -> ([inf],[inf][d],[inf][e])` that, given 2 initial registers, returns a tuple containing the infinite keystream, the infinite stream of `r1`, and the infinite stream of `r2`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module bivium where

type N = 200

bivium_stream : [93] -> [84] -> [inf]
bivium_stream r1 r2 =
    take`{N} (shift_regs r1 r2).0

Bivium : ([93], [84]) -> [N]Bit
Bivium (r1,r2) = bivium_stream r1 r2

shift : {d} (fin d, d >=1) => [d] -> Bit -> [d]
shift fill bit = fills
    where fills = [bit]#(drop`{1} (fill >> 1))

shift_regs : {d,e} (fin d, fin e, d >=1, e >=1) => [d] -> [e] -> ([inf],[inf][d],[inf][e])
shift_regs r1 r2 =
    (keystream, r1s, r2s)
    where
        r1s = [r1]#[shift r x | r <- r1s | x <- r2s ]
        r2s = [r2]#[shift r x | r <- r2s | x <- r1s ]
        keystream = [ (r@67) ^ (r'@83) | r <- r1s | r' <- r2s ]
```
[GENERATED END]


=== Task 11 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512` that imports the generic `ECDSA::UnconstrainedSpec`. Instantiate it with the  `EC = Common::EC::PrimeField::Instantiations::P521` and `Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512 =
    Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec {
        EC = Common::EC::PrimeField::Instantiations::P521,
        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512
    }
```
[GENERATED END]


=== Task 12 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96` that imports the generic Simon specification for Simon96_96. Use `type n = 48`, `type m = 2`, `type T = 52`, and `type j = 2`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96 =
    Primitive::Symmetric::Cipher::Block::Simon::Specification where
        type n = 48
        type m = 2
        type T = 52
        type j = 2
```
[GENERATED END]


=== Task 13 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification for a parameterized SHA-2 style hash function over word size w, defining sha : {L} (2 * w >= width L) => [L] -> [digest_size] and all supporting types, constants (H0, K), and functions (padding, parsing, message schedule, compression, and block processing).

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Keyless::Hash::SHA2 where

parameter
  type w : #
  type constraint (fin w, w >= 1)

type digest_size = 8 * w

type H0 = [8][w]
type K  = [64][w]

sha : {L} (2 * w >= width L) => [L] -> [digest_size]
sha M = take (join (reverse (foldl process_block (split (H0 # (parse (pad M)))) K)))

pad : {L} (2 * w >= width L) => [L] -> [L + 1 + w]
pad M = M # [True] # zero

parse : {n} (fin n) => [n] -> [n /^ w][w]
parse M = split M

process_block : {i} (fin i) => [i + 8][w] -> [64][w] -> [i + 8][w]
process_block block k = compress block (k @ i)

compress : {i} (fin i) => [i + 8][w] -> [w] -> [i + 8][w]
compress block k = foldl round (block @@ [0...]) (k @@ [0...])

round : {i} (fin i) => [w] -> [w] -> [w]
round acc x = acc + x

message_schedule : {i} (fin i) => [i + 8][w] -> [64][w]
message_schedule block = take (block # schedule)
  where
    schedule = [x | x <- block] # [sigma1 x | x <- schedule @@ [0...63]] # [sigma0 x | x <- schedule @@ [0...59]] # [sigma0 x ^ x ^ sigma1 (schedule @ (i - 2)) ^ schedule @ (i - 7) ^ schedule @ (i - 15) | x <- schedule @@ [0...55]]
      sigma0 x = (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)
      sigma1 x = (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)

block_processing : {i} (fin i) => [i + 8][w] -> [64][w] -> [i + 8][w]
block_processing block k = compress block (k @ i)
```
[GENERATED END]


=== Task 14 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Using the existing type `Cipher` and value `toyCipher` provided in the test setup, define a single polymorphic Cryptol function named `evktest` with the following type:

evktest : {ks, bs, n} (fin bs)
       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)

The function should take a cipher implementation, a sequence of (Key, Ciphertext) test vectors, and a single plaintext block. For each (Key, CT) in the list, it must iterate over that list using a single generator in a list comprehension (no parallel generators or multiple `|` arms), compute CT' = cipher.encrypt Key PT for that entry, and produce an output list of pairs (CT', CT' == CT).

The code for `Cipher` and `toyCipher` is ALREADY present in the file from the test setup code. In your answer, you MUST NOT repeat, modify, or redefine `Cipher` or `toyCipher`, and you MUST NOT add any other top-level declarations.

Your entire answer must consist of exactly two top-level lines: (1) the type signature for `evktest` exactly as given above, and (2) the definition of `evktest`. Do not wrap these in a module declaration, and do not include any setup code.

### Additional setup code:
```cryptol
type Cipher ks bs =
  { encrypt : [ks] -> [bs] -> [bs]
  , decrypt : [ks] -> [bs] -> [bs]
  }

toyCipher : Cipher 8 8
toyCipher = {
  encrypt = \k pt -> k ^ pt,
  decrypt = \k ct -> k ^ ct
}

```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Cipher ks bs =
  { encrypt : [ks] -> [bs] -> [bs]
  , decrypt : [ks] -> [bs] -> [bs]
  }

toyCipher : Cipher 8 8
toyCipher = {
  encrypt = \k pt -> k ^ pt,
  decrypt = \k ct -> k ^ ct
}


evktest : {ks, bs, n} (fin bs)
       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)
evktest(c,vs,pt) = [(c.encrypt k pt, ct') == (ct, True) | (k, ct) <- vs | ct' <- cts]
  where cts = [c.encrypt k pt | (k, ct) <- vs]
```
[GENERATED END]


=== Task 15 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Using ONLY the SHA-512 specification provided in the test setup (which defines a function `sha512` and all supporting constants), define a Cryptol property named `testVector1` with no arguments that checks `sha512` against the following fixed known-answer test vector:

- Message (as a hex literal): 0x616263
- Expected digest (as a hex literal): 0xddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f

The property must *exactly* assert that `sha512` of this message equals this digest.

The full definition of `sha512` (and all helper functions and constants) is ALREADY present in the file from the test setup code. In your answer, you MUST NOT repeat, modify, or redefine `sha512` or any of its helpers, and you MUST NOT add any other top-level declarations.

Your entire answer must be a single top-level declaration starting with:

property testVector1 =

and it must directly assert that `sha512 0x616263` equals the given digest, using those exact hex constants. Do not introduce any arguments, do not wrap it in a module, and do not include any setup code.

### Additional setup code:
```cryptol
sha512 M = result
  where
    M' = (pad M)
    blocks = (groupBy`{1024} M')
    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]
    result = (join (hash!0))

processBlock : [1024] -> [8][64] -> [8][64]
processBlock block Hprev = Hs
  where
    Mi = split block : [16][64]
    Ws = (messageSch Mi)
    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]
    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]

step : [8][64] -> [64] -> [8] -> [8][64]
step [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']
  where
    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt
    T2 = (SIGMA0 a) + (Maj a b c)
    h' = g
    g' = f
    f' = e
    e' = d + T1
    d' = c
    c' = b
    b' = a
    a' = T1 + T2

messageSch : [16][64] -> [80][64]
messageSch Mi = W
  where
    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]

pad : {l, k} (fin l,
              l <= ((2^^128) - 1),
              l >= 0,
              fin k,
              k - l >= 129,
              k == 128 + l + 1 + 1024 - ((l+129)%1024),
              k%1024 == 0) => [l] -> [k]
pad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])

Ch : [64] -> [64] -> [64] -> [64]
Ch x y z = (x && y) ^ ((~x) && z)

Maj : [64] -> [64] -> [64] -> [64]
Maj x y z = (x && y) ^ (x && z) ^ (y && z)

SIGMA0 : [64] -> [64]
SIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)

SIGMA1 : [64] -> [64]
SIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)

sigma0 : [64] -> [64]
sigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)

sigma1 : [64] -> [64]
sigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)

H0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]

K = [
0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
]

```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
sha512 M = result
  where
    M' = (pad M)
    blocks = (groupBy`{1024} M')
    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]
    result = (join (hash!0))

processBlock : [1024] -> [8][64] -> [8][64]
processBlock block Hprev = Hs
  where
    Mi = split block : [16][64]
    Ws = (messageSch Mi)
    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]
    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]

step : [8][64] -> [64] -> [8] -> [8][64]
step [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']
  where
    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt
    T2 = (SIGMA0 a) + (Maj a b c)
    h' = g
    g' = f
    f' = e
    e' = d + T1
    d' = c
    c' = b
    b' = a
    a' = T1 + T2

messageSch : [16][64] -> [80][64]
messageSch Mi = W
  where
    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]

pad : {l, k} (fin l,
              l <= ((2^^128) - 1),
              l >= 0,
              fin k,
              k - l >= 129,
              k == 128 + l + 1 + 1024 - ((l+129)%1024),
              k%1024 == 0) => [l] -> [k]
pad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])

Ch : [64] -> [64] -> [64] -> [64]
Ch x y z = (x && y) ^ ((~x) && z)

Maj : [64] -> [64] -> [64] -> [64]
Maj x y z = (x && y) ^ (x && z) ^ (y && z)

SIGMA0 : [64] -> [64]
SIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)

SIGMA1 : [64] -> [64]
SIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)

sigma0 : [64] -> [64]
sigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)

sigma1 : [64] -> [64]
sigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)

H0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]

K = [
0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
]


property testVector1 =
  sha512 0x616263 ==
  0xddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f
```
[GENERATED END]


=== Task 16 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Using ONLY the definitions `mk_buggy_fib_no_init`, `generate`, the infix operator `$`, and the sequences `foo` and `bar` provided in the test setup, define a Cryptol property named `fooEqualsBar` with no arguments that asserts that `foo` and `bar` are exactly equal. Do not redefine any of these functions or values; only provide the definition of `property fooEqualsBar`.

### Additional setup code:
```cryptol
mk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->
  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))
mk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))
  where
  fn2 = fn + fn1
  // Change output when state has magic value.
  fn' = fn + if k == magic then 1 else 0

generate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a
generate f = [ f i | i <- [0 .. n-1] ]

infixl 1 $
f $ x = f x

foo : [10][4]
foo = generate $ \(i:[8]) -> if i == 0 then 1 else foo@(i-1)

bar : [10][4]
bar = generate \(i:[8]) -> if i == 0 then 1 else foo@(i-1)

```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
mk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->
  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))
mk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))
  where
  fn2 = fn + fn1
  // Change output when state has magic value.
  fn' = fn + if k == magic then 1 else 0

generate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a
generate f = [ f i | i <- [0 .. n-1] ]

infixl 1 $
f $ x = f x

foo : [10][4]
foo = generate $ \(i:[8]) -> if i == 0 then 1 else foo@(i-1)

bar : [10][4]
bar = generate \(i:[8]) -> if i == 0 then 1 else foo@(i-1)


property fooEqualsBar = foo == bar
```
[GENERATED END]


=== Task 17 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the function `unflatten : {r,w} (fin r, 5 * w >= r, fin w) => [r] -> [w][5]` that pads its input with zeros and groups it into `w` blocks of 5 elements using `groupBy` in Cryptol. DO NOT include import statements, module declarations, or any other code.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
unflatten : {r, w}
  (fin r, 5 * w >= r, fin w) =>
    [r] -> [w][5]
unflatten p = groupBy`{5} (p # zero)
```
[GENERATED END]


=== Task 18 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol file that defines the functions `mk_curve_ops`, `ec_v1`, and `ec_v2`. The definition must follow the exact structure shown in the prompt: `mk_curve_ops` must construct a record containing fields `field`, `v1`, and `v2`, where `v1` calls `ec_v1` on the input parameter and `v2` calls `ec_v2` on the record being constructed. The functions must use the polymorphic types exactly as shown and must access `p.field.v0` correctly in `ec_v2`. The file must contain no module declaration and must consist only of the three definitions.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
mk_curve_ops p =
  { field = p
  , v1 = ec_v1 p
  , v2 = ec_v2 `{t = p}
  }

ec_v1 p =
  { v0 = p.field.v0 + 1
  , v1 = p.field.v0 + 2
  }

ec_v2 p =
  { v0 = p.v0 + 1
  , v1 = p.v0 + 2
  }
```
[GENERATED END]


=== Task 19 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module named `T038` that declares an interface submodule `I` providing `x : [8]`, a submodule `F` that imports interface submodule `I` and defines `y = x + 1`, a submodule `P` that imports submodule `F` while exposing submodule `Q`, a submodule `Q` that defines `x = 11`, and finally an interface submodule `J` that imports submodule `F` through `P`. The structure must match the Cryptol module system rules exactly.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module T038 where

interface submodule I where
  x : [8]

submodule F where
  import interface submodule I

  y = x + 1

submodule P where
  import submodule F
  export submodule Q

submodule Q where
  x = 11

interface submodule J where
  import submodule F via submodule P
```
[GENERATED END]


=== Task 20 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Reproduce exactly the four foreign function declarations `foreignAndCryptol`, `foreignAndNoCryptol`, `noForeignAndCryptol`, and `noForeignAndNoCryptol`, each using the C calling convention. Implement `foreignAndCryptol` to return its argument unchanged, leave `foreignAndNoCryptol` unimplemented, implement `noForeignAndCryptol` to return `x + 3`, and leave `noForeignAndNoCryptol` unimplemented. The file must contain only these four declarations.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
foreign foreignAndCryptol : [64] -> [64]
foreignAndCryptol x = x

foreign foreignAndNoCryptol : [64] -> [64]

noForeignAndCryptol : [64] -> [64]
noForeignAndCryptol x = x + 3

foreign noForeignAndNoCryptol : [64] -> [64]
```
[GENERATED END]


=== Task 21 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Write a Cryptol module implementing parameterized AES encryption and decryption for key sizes 128, 192, and 256 bits. The module must import the AES algorithm, key expansion, and T-box modules exactly as specified, define `encrypt` and `decrypt` in terms of expanded keys, and include a property named `test` verifying that `decrypt k (encrypt k pt) == pt` for all valid keys and all 128-bit plaintexts.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::AES::Tests::Parameterized where

import Primitive::Symmetric::Cipher::Block::AES::Algorithm
import Primitive::Symmetric::Cipher::Block::AES::KeySchedule
import Primitive::Symmetric::Cipher::Block::AES::TBox

parameter

  type KeySize : #
  type constraint (fin KeySize, KeySize % 32 == 0, 4 <= KeySize / 32 <= 6)

type Key = [KeySize]
type Pt  = [128]
type Ct  = [128]

encrypt : Key -> Pt -> Ct
encrypt k = aesEncrypt (expandKey k)

decrypt : Key -> Ct -> Pt
decrypt k = aesDecrypt (expandKey k)

property test k pt = decrypt k (encrypt k pt) == pt
```
[GENERATED END]


=== Task 22 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Write a complete Cryptol module implementing the Bivium stream cipher. The module must define `Bivium_stream`, `Bivium`, `Bivium_alt`, and all cycle-testing helpers. It must also define the four properties: `Bivium_correct`, `Bivium_search`, `Bivium_search_with_suffix`, and `Bivium_alt_equivalent`, using the exact IVs, suffix, and test keystream provided. The file must match the structure and behavior of the Bivium specification.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Stream::Bivium where

type LFSR = [16][8]
type RFSR = [16][8]
type Key = [128]
type IV = [128]
type Keystream = [128]

Bivium : Key -> IV -> Keystream
Bivium key iv = take (Bivium_stream key iv)

Bivium_alt : Key -> IV -> Keystream
Bivium_alt key iv = take (Bivium_stream_alt key iv)

Bivium_correct : Bit
property Bivium_correct = Bivium key iv == keystream
  where
    key = 0x0000000000000000000000000000000000000000000000000000000000000000
    iv = 0x0000000000000000000000000000000000000000000000000000000000000000
    keystream = 0x0000000000000000000000000000000000000000000000000000000000000000

Bivium_search : Bit
property Bivium_search = Bivium key iv == keystream
  where
    key = 0x0000000000000000000000000000000000000000000000000000000000000000
    iv = 0x0000000000000000000000000000000000000000000000000000000000000000
    keystream = 0x0000000000000000000000000000000000000000000000000000000000000000

Bivium_search_with_suffix : Bit
property Bivium_search_with_suffix = Bivium key iv == keystream
  where
    key = 0x0000000000000000000000000000000000000000000000000000000000000000
    iv = 0x0000000000000000000000000000000000000000000000000000000000000000
    keystream = 0x0000000000000000000000000000000000000000000000000000000000000000

Bivium_alt_equivalent : Bit
property Bivium_alt_equivalent = Bivium key iv == Bivium_alt key iv
  where
    key = 0x0000000000000000000000000000000000000000000000000000000000000000
    iv = 0x0000000000000000000000000000000000000000000000000000000000000000

Bivium_stream : Key -> IV -> [inf]
Bivium_stream key iv = keystream
  where
    lfsr = init_lfsr key
    rfsr = init_rfsr iv
    keystream = [ (lfsr@0) ^ (rfsr@0) | _ <- [1...]
             | lfsr <- lfsrs lfsr rfsr
             | rfsr <- rfsrs rfsr lfsr ]

Bivium_stream_alt : Key -> IV -> [inf]
Bivium_stream_alt key iv = keystream
  where
    lfsr = init_lfsr key
    rfsr = init_rfsr iv
    keystream = [ (lfsr@0) ^ (rfsr@0) | _ <- [1...]
             | lfsr <- lfsrs_alt lfsr rfsr
             | rfsr <- rfsrs_alt rfsr lfsr ]

init_lfsr : Key -> LFSR
init_lfsr key = take`{16} (split key)

init_rfsr : IV -> RFSR
init_rfsr iv = take`{16} (split iv)

lfsrs : LFSR -> RFSR -> [inf]LFSR
lfsrs lfsr rfsr =
  [ next_lfsr lfsr rfsr | _ <- [1...]
                       | lfsr <- lfsrs
                       | rfsr <- rfsrs ]

lfsrs_alt : LFSR -> RFSR -> [inf]LFSR
lfsrs_alt lfsr rfsr =
  [ next_lfsr_alt lfsr rfsr | _ <- [1...]
                           | lfsr <- lfsrs_alt
                           | rfsr <- rfsrs_alt ]

next_lfsr : LFSR -> RFSR -> LFSR
next_lfsr lfsr rfsr =
  lfsr # [ feedback lfsr rfsr ]

next_lfsr_alt : LFSR -> RFSR -> LFSR
next_lfsr_alt lfsr rfsr =
  lfsr # [ feedback_alt lfsr rfsr ]

feedback : LFSR -> RFSR -> Bit
feedback lfsr rfsr =
  (lfsr@0) && (lfsr@3) && (lfsr@4) && (lfsr@5) && (lfsr@6) &&
  (lfsr@7) && (lfsr@8) && (lfsr@9) && (lfsr@10) && (lfsr@11) &&
  (lfsr@12) && (lfsr@13) && (lfsr@14) && (lfsr@15) ^
  (rfsr@0) && (rfsr@1) && (rfsr@2) && (rfsr@3) && (rfsr@4) &&
  (rfsr@5) && (rfsr@6) && (rfsr@7) && (rfsr@8) && (rfsr@9) &&
  (rfsr@10) && (rfsr@11) && (rfsr@12) && (rfsr@13) && (rfsr@14) &&
  (rfsr@15)

feedback_alt : LFSR -> RFSR -> Bit
feedback_alt lfsr rfsr =
  (lfsr@0) && (lfsr@3) && (lfsr@4) && (lfsr@5) && (lfsr@6) &&
  (lfsr@7) && (lfsr@8) && (lfsr@9) && (lfsr@10) && (lfsr@11) &&
  (lfsr@12) && (lfsr@13) && (lfsr@14) && (lfsr@15) ^
  (rfsr@0) && (rfsr@1) && (rfsr@2) && (rfsr@3) && (rfsr@4) &&
  (rfsr@5) && (rfsr@6) && (rfsr@7) && (rfsr@8) && (rfsr@9) &&
  (rfsr@10) && (rfsr@11) && (rfsr@12) && (rfsr@13) && (rfsr@14) &&
  (rfsr@15)

rfsrs : RFSR -> LFSR -> [inf]RFSR
rfsrs rfsr lfsr =
  [ next_rfsr rfsr lfsr | _ <- [1...]
                       | rfsr <- rfsrs
                       | lfsr <- lfsrs ]

rfsrs_alt : RFSR -> LFSR -> [inf]RFSR
rfsrs_alt rfsr lfsr =
  [ next_rfsr_alt rfsr lfsr | _ <- [1...]
                           | rfsr <- rfsrs_alt
                           | lfsr <- lfsrs_alt ]

next_rfsr : RFSR -> LFSR -> RFSR
next_rfsr rfsr lfsr =
  rfsr # [ feedback rfsr lfsr ]

next_rfsr_alt : RFSR -> LFSR -> RFSR
next_rfsr_alt rfsr lfsr =
  rfsr # [ feedback_alt rfsr lfsr ]
```
[GENERATED END]


=== Task 24 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Write a Cryptol module implementing the FNV-1a 64-bit hash function, including padding, the FNV offset basis, prime constant, the block-processing logic, and a property `testsPass` that verifies the hash of the empty string, "a", and "foobar" equals the known answer test vectors provided.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
fnv1a : {n} (fin n) => [n] -> [64]
fnv1a bytes = foldl processBlock fnvOffset bytes
  where
    type FnvPrime = 1099511628211
    fnvOffset : [64]
    fnvOffset = 14695981039346656037

    pad : {m} (fin m) => [m] -> [n + m]
    pad msg = msg # zero

    processBlock : [64] -> [8] -> [64]
    processBlock h byte = (h ^ (zero # byte)) * FnvPrime

property testsPass =
  fnv1a [] == 0xcbf29ce484222325 &&
  fnv1a (pad "a") == 0xaf63dc4c540a0ecb &&
  fnv1a (pad "foobar") == 0x84281a419e1240a8
```
[GENERATED END]


=== Task 26 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA384` that instantiates the generic SHA-2 specification for SHA-384 with 64-bit words, 384-bit digest size, and the given 8-word initial hash vector `H0`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 =
    Primitive::Keyless::Hash::SHA2::SHA2 where

        type w = 64
        type DigestSize = 384
        H0 = [
            0x9DDF7A51, 0x8E4C6B7B,
            0x5D07A43E, 0x4A0BA362,
            0x28DF6F16, 0x24B1CF6F,
            0xC5DB0C9E, 0xF70E5939
        ]
```
[GENERATED END]


=== Task 27 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 with an xof function imported from the SHAKE256 instantiation and properties k5–k8 that assert xof applied to [], 0b0, 0b11, and 0b110 equals the given 512-bit expected_result constants.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
module Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 where

import Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO
import Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256

property k5 = xof [] == expected_result where
    expected_result = join [
        0x4797d160, 0x419c7a65, 0x988e1591, 0x65716769,
        0x44724765, 0x7988666f, 0x65647465, 0x64697469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657469,
        0x6f6e6574, 0x69666665, 0x72656465, 0x64657
```
[GENERATED END]


=== Task 28 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module that instantiates SHA3-224 and defines properties t1, t5, t72, and t512 that check the hash and hashBytes functions against the given known-answer test vectors.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Keyless::Hash::SHA2::Tests::SHA3_224 where

import Primitive::Keyless::Hash::SHA2::Instantiations::SHA3_224

property t1 = hash [] == 0x6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d4cd6acb3076fad2c02

property t5 = hash "abc" == 0xba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad

property t72 = hash "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" ==
    0x204a8fc6dda82a411fc2d3d2a24999b84e98ec0ba0f2b5e62373692c3fa7213d

property t512 = hash "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu" ==
    0x953244c7104f45de6077d778c27c95939169859066eb73bbd6b8a4a01ec0d22c
```
[GENERATED END]


=== Task 30 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that models the Kalotan logic puzzle with parents and child as Bits, defines the given constraints (heterosexual parents, kid lying, parents’ statements), and includes properties equivalent to people_types, checkit1, and checkit2 capturing the valid/invalid configurations.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
type P = Bit
type C = Bit

heterosexual : P -> P -> C -> Bit
heterosexual mom dad kid = ~(mom && dad) == kid

kid_lies : P -> P -> C -> Bit
kid_lies mom dad kid = kid ==> ~(homosexual mom dad kid)

mom_says : P -> P -> C -> Bit
mom_says mom dad kid = kid ==> ~(mom && ~dad)

dad_says : P -> P -> C -> Bit
dad_says mom dad kid = kid ==> ~(dad && ~mom)

people_types : P -> P -> C -> Bit
property people_types mom dad kid =
  (heterosexual mom dad kid) /\ (kid_lies mom dad kid) /\
  (mom_says mom dad kid) /\ (dad_says mom dad kid)

checkit1 : P -> P -> C -> Bit
property checkit1 mom dad kid =
  (heterosexual mom dad kid) /\ (kid_lies mom dad kid) /\
  (mom_says mom dad kid) /\ (dad_says mom dad kid) ==>
  (mom == ~kid) /\ (dad == kid)

checkit2 : P -> P -> C -> Bit
property checkit2 mom dad kid =
  (heterosexual mom dad kid) /\ (kid_lies mom dad kid) /\
  (mom_says mom dad kid) /\ (dad_says mom dad kid) ==>
  (mom == kid) /\ (dad == ~kid)
```
[GENERATED END]


=== Task 31 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification for a parameterized SHA-2 style hash function over word size w, defining sha : {L} (2 * w >= width L) => [L] -> [digest_size] and all supporting types, constants (H0, K), and functions (padding, parsing, message schedule, compression, and block processing).

### Additional setup code:
```cryptol
Ch_Alternate : {w} (fin w, w >= 1) => [w] -> [w] -> [w] -> [w]
Ch_Alternate x y z = (x /\ y) \/ (~x /\ z)
```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
Ch_Alternate : {w} (fin w, w >= 1) => [w] -> [w] -> [w] -> [w]
Ch_Alternate x y z = (x /\ y) \/ (~x /\ z)

```cryptol
module Primitive::Keyless::Hash::SHA2::SHA2 where

import Common::ModDivZ

parameter

  type w : #
  type constraint (fin w, w >= 1)

type digest_size = 8 * w

type n = 16 / w

type L = 1 + digest_size + 64 + 64 * w

type M = [n][w]

H0 : [8][w]
H0 =
  [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f,
   0x9b05688c, 0x1f83d9ab, 0x5be0cd19]

K : [64][w]
K =
  [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
   0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
   0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
   0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
   0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
   0xa831c66d, 0xb00327c8, 0xbf59eb67, 0xc6e00bf3, 0xd5a79147,
   0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
   0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
   0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
   0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
   0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
   0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]

sha : {L} (2 * w >= width L) => [L] -> [digest_size]
sha M = take (join (reverse (hash_blocks (parse M))))

parse : {L} (2 * w >= width L) => [L] -> [L / (8 * w)][8 * w]
parse M = split (split M)

padding : {L} (2 * w >= width L) => [L] -> [L + 1 + 64][1]
padding M =
  M # [True] # zero # [False] # (split (fromInteger (length M)))

hash_blocks : {L} (2 * w >= width L) => [L / (8 * w)][8 * w] -> [8][w]
hash_blocks ms = foldl compress H0 (map parse_block ms)

parse_block : [8 * w] -> M
parse_block m = split (split m)

compress : {i} (fin i, i >= 1) => [8][w] -> M -> [8][w]
compress H M =
  H'
  where
    W = expand_message M
    T1 = map (T1') ([0 .. 79] : [80][8])
    T2 = map (T2') ([0 .. 79] : [80][8])
    H' = foldl (round i) H (zip T1 T2)

round : {i} (fin i, i >= 1) => [8][w] -> ([w], [w]) -> [8][w]
round H (T1, T2) =
  [(H @ 0) + T1 + (H @ 7) + T2,
  (H @ 1) + (H @ 0),
  (H @ 2) + (H @ 1),
  (H @ 3) + (H @ 2),
  (H @ 4) + (H @ 3),
  (H @ 5) + (H @ 4),
  (H @ 6) + (H @ 5),
  (H @ 7) + (H @ 6)]

T1' : {i} (fin i, i >= 1) => [8] -> [w]
T1' i =
  T1 @ i
  where
    T1 = [T1_0, T1_1, T1_2, T1_3, T1_4, T1_5, T1_6, T1_7, T1_8, T1_9,
          T1_10, T1_11, T1_12, T1_13, T1_14, T1_15, T1_16, T1_17,
          T1_18, T1_19, T1_20, T1_21, T1_22, T1_23, T1_24, T1_25,
          T1_26, T1_27, T1_28, T1_29, T1_30, T1_31, T1_32, T1_33,
          T1_34, T1_35, T1_36, T1_37, T1_38, T1_39, T1_40, T1_41,
          T1_42, T1_43, T1_44, T1_45, T1_46, T1_47, T1_48, T1_49,
          T1_50, T1_51, T1_52, T1_53, T1_54, T1_55, T1_56, T1_57,
          T1_58, T1_59, T1_60, T1_61, T1_62, T1_63, T1_64, T1_65,
          T1_66, T1_67, T1_68, T1_69, T1_70, T1_71, T1_72, T1_73,
          T1_74, T1_75, T1_76, T1_77, T1_78, T1_79]
    T1_0 = K @ 0 + W @ 0 + Ch_Alternate (W @ 15) (W @ 6) (W @ 7)
    T1_1 = T1_0 + T1 @ 63 + S1 (W @ 6) + W @ 14
    T1_2 = T1_1 + T1 @ 62 + S1 (W @ 14) + W @ 13
    T1_3 = T1_2 + T1 @ 61 + S1 (W @ 13) + W @ 12
    T1_4 = T1_3 + T1 @ 60 + S1 (W @ 12) + W @ 11
    T1_5 = T1_4 + T1 @ 59 + S1 (W @ 11) + W @ 10
    T1_6 = T1_5 + T1 @ 58 + S1 (W @ 10) + W @ 9
    T1_7 = T1_6 + T1 @ 57 + S1 (W @ 9) + W @ 8
    T1_8 = T1_7 + T1 @ 56 + S1 (W @ 8) + W @ 7
    T1_9 = T1_8 + T1 @ 55 + S1 (W @ 7) + W @ 6
    T1_10 = T1_9 + T1 @ 54 + S1 (W @ 6) + W @ 5
    T1_11 = T1_10 + T1 @ 53 + S1 (W @ 5) + W @ 4
    T1_12 = T1_11 + T1 @ 52 + S1 (W @ 4) + W @ 3
    T1_13 = T1_12 + T1 @ 51 + S1 (W @ 3) + W @ 2
    T1_14 = T1_13 + T1 @ 50 + S1 (W @ 2) + W @ 1
    T1_15 = T1_14 + T1 @ 49 + S1 (W @ 1) + W @ 0
    T1_16 = T1_15 + T1 @ 48 + S1 (W @ 0) + W @ 15
    T1_17 = T1_16 + T1 @ 47 + S1 (W @ 15) + W @ 14
    T1_18 = T1_17 + T1 @ 46 + S1 (W @ 14) + W @ 13
    T1_19 = T1_18 + T1 @ 45 + S1 (W @ 13) + W @ 12
    T1_20 = T1_19 + T1 @ 44 + S1 (W @ 12) + W @ 11
    T1_21 = T1_20 + T1 @ 43 + S1 (W @ 11) + W @ 10
    T1_22 = T1_21 + T1 @ 42 + S1 (W @ 10) + W @ 9
    T1_23 = T1_22 + T1 @ 41 + S1 (W @ 9) + W @ 8
    T1_24 = T1_23 + T1 @ 40 + S1 (W @ 8) + W @ 7
    T1_25 = T1_24 + T1 @ 39 + S1 (W @ 7) + W @ 6
    T1_26 = T1_25 + T1 @ 38 + S1 (W @ 6) + W @ 5
    T1_27 = T1_26 + T1 @ 37 + S1 (W @ 5) + W @ 4
    T1_28 = T1_27 + T1 @ 36 + S1 (W @ 4) + W @ 3
    T1_29 = T1_28 + T1 @ 35 + S1 (W @ 3) + W @ 2
    T1_30 = T1_29 + T1 @ 34 + S1 (W @ 2) + W @ 1
    T1_31 = T1_30 + T1 @ 33 + S1 (W @ 1) + W @ 0
    T1_32 = T1_31 + T1 @ 32 + S1 (W @ 0) + W @ 15
    T1_33 = T1_32 + T1 @ 31 + S1 (W @ 15) + W @ 14
    T1_34 = T1_33 + T1 @ 30 + S1 (W @ 14) + W @ 13
    T1_35 = T1_34 + T1 @ 29 + S1 (W @ 13) + W @ 12
    T1_36 = T1_35 + T1 @ 28 + S1 (W @ 12) + W @ 11
    T1_37 = T1_36 + T1 @ 27 + S1 (W @ 11) + W @ 10
    T1_38 = T1_37 + T1 @ 26 + S1 (W @ 10) + W @ 9
    T1_39 = T1_38 + T1 @ 25 + S1 (W @ 9) + W @ 8
    T1_40 = T1_39 + T1 @ 24 + S1 (W @ 8) + W @ 7
    T1_41 = T1_40 + T1 @ 23 + S1 (W @ 7) + W @ 6
    T1_42 = T1_41 + T1 @ 22 + S1 (W @ 6) + W @ 5
    T1_43 = T1_42 + T1 @ 21 + S1 (W @ 5) + W @ 4
    T1_44 = T1_43 + T1 @ 20 + S1 (W @ 4) + W @ 3
    T1_45 = T1_44 + T1 @ 19 + S1 (W @ 3) + W @ 2
    T1_46 = T1_45 + T1 @ 18 + S1 (W @ 2) + W @ 1
    T1_47 = T1_46 + T1 @ 17 + S1 (W @ 1) + W @ 0
    T1_48 = T1_47 + T1 @ 16 + S1 (W @ 0) + W @ 15
    T1_49 = T1_48 + T1 @ 15 + S1 (W @ 15) + W @ 14
    T1_50 = T1_49 + T1 @ 14 + S1 (W @ 14) + W @ 13
    T1_51 = T1_50 + T1 @ 13 + S1 (W @ 13) + W @ 12
    T1_52 = T1_51 + T1 @ 12 + S1 (W @ 12) + W @ 11
    T1_53 = T1_52 + T1 @ 11 + S1 (W @ 11) + W @ 10
    T1_54 = T1_53 + T1 @ 10 + S1 (W @ 10) + W @ 9
    T1_55 = T1_54 + T1 @ 9 + S1 (W @ 9) + W @ 8
    T1_56 = T1_55 + T1 @ 8 + S1 (W @ 8) + W @ 7
    T1_57 = T1_56 + T1 @ 7 + S1 (W @ 7) + W @ 6
    T1_58 = T1_57 + T1 @ 6 + S1 (W @ 6) + W @ 5
    T1_59 = T1_58 + T1 @ 5 + S1 (W @ 5) + W @ 4
    T1_60 = T1_59 + T1 @ 4 + S1 (W @ 4) + W @ 3
    T1_61 = T1_60 + T1 @ 3 + S1 (W @ 3) + W @ 2
    T1_62 = T1_61 + T1 @ 2 + S1 (W @ 2) + W @ 1
    T1_63 = T1_62 + T1 @ 1 + S1 (W @ 1) + W
```
[GENERATED END]


=== Task 32 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Create a function that performs modulo addition with the signature `mod_add_Z : (Integer, Integer, Integer) -> Integer`. The first parameter is the modulo base.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
mod_add_Z : (Integer, Integer, Integer) -> Integer
mod_add_Z (n, x, y) = (x + y) % n
```
[GENERATED END]


=== Task 33 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Create a function that multiplies a number with itself using modulo multiplication. Define the following functions `mod_mul_Z : (Integer, Integer, Integer) -> Integer` and `mod_sq_Z : (Integer, Integer) -> Integer`. The first parameter should be the modulo base for both functions. `mod_sq_Z` should call `mod_mul_Z` to perform the modulo multiplication.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
mod_mul_Z : (Integer, Integer, Integer) -> Integer
mod_mul_Z (m, x, y) = (x * y) % m

mod_sq_Z : (Integer, Integer) -> Integer
mod_sq_Z (m, x) = mod_mul_Z (m, x, x)
```
[GENERATED END]


=== Task 34 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the function `mod_div_Z : (Integer, Integer, Integer) -> Integer` that performs modulo division between two integers. The modulo base is the first parameter. You should implement Stein's algorithm and call `mod_half_Z` to perform modulo division by 2. The resulting file should only have two functions and be standalone.

### Additional setup code:
```cryptol
mod_half_Z : (Integer, Integer) -> Integer
mod_half_Z (p, x) = if (x % 2 == 0) then x / 2 else (x + p) / 2

```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
mod_half_Z : (Integer, Integer) -> Integer
mod_half_Z (p, x) = if (x % 2 == 0) then x / 2 else (x + p) / 2


mod_div_Z : (Integer, Integer, Integer) -> Integer
mod_div_Z (p, x, y) =
  if y == 0 then error "division by zero" else
    if y == 1 then x else
      if y == -1 then negate x else
        if y > 0 then go (p, x, y, 0) else go (p, x, negate y, 1)
  where
    go (p', x', y', k') =
      if y' == 0 then error "division by zero" else
        if y' == 1 then x' * (if k' == 0 then 1 else 2 ^^ k') else
          if y' == -1 then negate x' * (if k' == 0 then 1 else 2 ^^ k') else
            if y' > 0 then
              if y' % 2 == 0 then go (p', x', mod_half_Z (p', y'), k')
              else go (p', x', mod_half_Z (p', y'), k' + 1)
            else
              if y' % 2 == 0 then go (p', x', mod_half_Z (p', y'), k')
              else go (p', x', mod_half_Z (p', y'), k' + 1)

mod_half_Z : (Integer, Integer) -> Integer
mod_half_Z (p, x) = if (x % 2 == 0) then x / 2 else (x + p) / 2
```
[GENERATED END]


=== Task 35 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Create a Cryptol specification that performs the SHA-512 message schedule expansion. Define the functions `messageSch : [16][64] -> [80][64]`, `sigma0 : [64] -> [64]`, and `sigma1 : [64] -> [64]` to perform the message expansion.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
messageSch : [16][64] -> [80][64]
messageSch M = M # [ (sigma1 (W @ (i - 2)) ^ sigma0 (W @ (i - 7)) ^ (W @ (i - 15)) ^ (W @ (i - 16))) <<< r | W <- M | i <- [16, 17 .. 79] | r <- R ]
sigma0 : [64] -> [64]
sigma0 X = (X >>> 28) ^ (X >>> 34) ^ (X >>> 39)
sigma1 : [64] -> [64]
sigma1 X = (X >>> 14) ^ (X >>> 18) ^ (X >>> 41)
R =
  [1, 32, 1, 43, 1, 7, 1, 46, 1, 58, 1, 15, 1, 61, 1, 28,
  2, 3, 2, 10, 2, 62, 2, 55, 2, 21, 2, 50, 2, 42, 2, 6, 2, 25,
  3, 9, 3, 29, 3, 24, 3, 20, 3, 11, 3, 56, 3, 2, 3, 60, 4, 14,
  4, 27, 4, 0, 4, 63, 4, 48, 4, 5, 4, 64, 4, 35, 4, 17, 4, 71,
  5, 23, 5, 13, 5, 31, 5, 47, 5, 1, 5, 65, 5, 76, 5, 37, 5, 22,
  6, 18, 6, 9, 6, 49, 6, 39, 6, 54, 6, 41, 6, 33, 6, 10, 6, 52,
  7, 51, 7, 26, 7, 20, 7, 34, 7, 59, 7, 45, 7, 28, 7, 8, 7, 57]
```
[GENERATED END]


=== Task 36 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the property `tcId1080` that checks, for AES-256 Key Wrap with padding in AE mode, that encrypting the plaintext `0x06` under the key `0x3ea9325069ed93a96c331bdd6dd766ec64bbba83a72c69ed75df55043fb0bfd1` with `KWP_AE` produces the expected ciphertext `0x40a9c42012ba38211b800e6e313b6876`, using the helper `check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap


check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct
/* pragma tcId1080 : property */
tcId1080 =
  testPassed == check_KWP_AE key pt ct
  where
    testPassed = True
    key =
      0x3ea9325069ed93a96c331bdd6dd766ec64bbba83a72c69ed75df55043fb0bfd1
    pt = 0x06
    ct = 0x40a9c42012ba38211b800e6e313b6876
```
[GENERATED END]


=== Task 37 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the Cryptol module `Primitive::Symmetric::Cipher::Block::AES::SubByteSBox` implementing the AES SubBytes and InvSubBytes transformations with functions `SubByte : GF28 -> GF28` and `InvSubByte : GF28 -> GF28`, using `sbox` and `sboxInv` over `GF28` elements.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
module Primitive::Symmetric::Cipher::Block::AES::SubByteSBox where

import Primitive::Symmetric::Cipher::Block::AES::GF28

SubByte : GF28 -> GF28
SubByte x = sbox @ x

InvSubByte : GF28 -> GF28
InvSubByte x = sboxInv @ x

sbox : [256]GF28
sbox =
  [0x63,
  0x7c,
  0x77,
  0x7b,
  0xf2,
  0x6b,
  0x6f,
  0xc5,
  0x30,
  0x01,
  0x67,
  0x2b,
  0xfe,
  0xd7,
  0xab,
  0x76,
  0xca,
  0x82,
  0xc9,
  0x7d,
  0xfa,
  0x59,
  0x47,
  0xf0,
  0xad,
  0xd4,
  0xa2,
  0xaf,
  0x9c,
  0xa4,
  0x72,
  0xc0,
  0xb7,
  0xfd,
  0x93,
  0x26,
  0x36,
  0x3f,
  0xf7,
  0xcc,
  0x34,
  0xa5,
  0xe5,
  0xf1,
  0x71,
  0xd8,
  0x31,
  0x15,
  0x04,
  0xc7,
  0x23,
  0xc3,
  0x18,
  0x96,
  0x05,
  0x9a,
  0x07,
  0x12,
  0x80,
  0xe2,
  0xeb,
  0x27,
  0xb2,
  0x75,
  0x09,
  0x83,
  0x2c,
  0x1a,
  0x1b,
  0x6e,
  0x5a,
  0xa0,
  0x52,
  0x3b,
  0xd6,
  0xb3,
  0x29,
  0xe3,
  0x2f,
  0x84,
  0x53,
  0xd1,
  0x00,
  0xed,
  0x20,
  0xfc,
  0xb1,
  0x5b,
  0x6a,
  0xcb,
  0xbe,
  0x39,
  0x4a,
  0x4c,
  0x58,
  0xcf,
  0xd0,
  0xef,
  0xaa,
  0xfb,
  0x43,
  0x4d,
  0x33,
  0x85,
  0x45,
  0xf9,
  0x02,
  0x7f,
  0x50,
  0x3c,
  0x9f,
  0xa8,
  0x51,
  0xa3,
  0x40,
  0x8f,
  0x92,
  0x9d,
  0x38,
  0xf5,
  0xbc,
  0xb6,
  0xda,
  0x21,
  0x10,
  0xff,
  0xf3,
  0xd2,
  0xcd,
  0x0c,
  0x13,
  0xec,
  0x5f,
  0x97,
  0x44,
  0x17,
  0xc4,
  0xa7,
  0x7e,
  0x3d,
  0x64,
  0x5d,
  0x19,
  0x73,
  0x60,
  0x81,
  0x4f,
  0xdc,
  0x22,
  0x2a,
  0x90,
  0x88,
  0x46,
  0xee,
  0xb8,
  0x14,
  0xde,
  0x5e,
  0x0b,
  0xdb,
  0xe0,
  0x32,
  0x3a,
  0x0a,
  0x49,
  0x06,
  0x24,
  0x5c,
  0xc2,
  0xd3,
  0xac,
  0x62,
  0x91,
  0x95,
  0xe4,
  0x79,
  0xe7,
  0xc8,
  0x37,
  0x6d,
  0x8d,
  0xd5,
  0x4e,
  0xa9,
  0x6c,
  0x56,
  0xf4,
  0xea,
  0x65,
  0x7a,
  0xae,
  0x08,
  0xba,
  0x78,
  0x25,
  0x2e,
  0x1c,
  0xa6,
  0xb4,
  0xc6,
  0xe8,
  0xdd,
  0x74,
  0x1f,
  0x4b,
  0xbd,
  0x8b,
  0x8a,
  0x70,
  0x3e,
  0xb5,
  0x66,
  0x48,
  0x03,
  0xf6,
  0x0e,
  0x61,
  0x35,
  0x57,
  0xb9,
  0x86,
  0xc1,
  0x1d,
  0x9e,
  0xe1,
  0xf8,
  0x98,
  0x11,
  0x69,
  0xd9,
  0x8e,
  0x94,
  0x9b,
  0x1e,
  0x87,
  0xe9,
  0xce,
  0x55,
  0x28,
  0xdf,
  0x8c,
  0xa1,
  0x89,
  0x0d,
  0xbf,
  0xe6,
  0x42,
  0x68,
  0x41,
  0x99,
  0x2d,
  0x0f,
  0xb0,
  0x54,
  0xbb,
  0x16]

sboxInv : [256]GF28
sboxInv =
  [0x52,
  0x09,
  0x6a,
  0xd5,
  0x30,
  0x36,
  0xa5,
  0x38,
  0xbf,
  0x40,
  0xa3,
  0x9e,
  0x81,
  0xf3,
  0xd7,
  0xfb,
  0x7c,
  0xe3,
  0x39,
  0x82,
  0x9b,
  0x2f,
  0xff,
  0x87,
  0x34,
  0x8e,
  0x43,
  0x44,
  0xc4,
  0xde,
  0xe9,
  0xcb,
  0x54,
  0x7b,
  0x94,
  0x32,
  0xa6,
  0xc2,
  0x23,
  0x3d,
  0xee,
  0x4c,
  0x95,
  0x0b,
  0x42,
  0xfa,
  0xc3,
  0x4e,
  0x08,
  0x2e,
  0xa1,
  0x66,
  0x28,
  0xd9,
  0x24,
  0xb2,
  0x76,
  0x5b,
  0xa2,
  0x49,
  0x6d,
  0x8b,
  0xd1,
  0x25,
  0x72,
  0xf8,
  0xf6,
  0x64,
  0x86,
  0x68,
  0x98,
  0x16,
  0xd4,
  0xa4,
  0x5c,
  0xcc,
  0x5d,
  0x65,
  0xb6,
  0x92,
  0x6c,
  0x70,
  0x48,
  0x50,
  0xfd,
  0xed,
  0xb9,
  0xda,
  0x5e,
  0x15,
  0x46,
  0x57,
  0xa7,
  0x8d,
  0x9d,
  0x84,
  0x90,
  0xd8,
  0xab,
  0x00,
  0x8c,
  0xbc,
  0xd3,
  0x0a,
  0xf7,
  0xe4,
  0x58,
  0x05,
  0xb8,
  0xb3,
  0x45,
  0x06,
  0xd0,
  0x2c,
  0x1e,
  0x8f,
  0xca,
  0x3f,
  0x0f,
  0x02,
  0xc1,
  0xaf,
  0xbd,
  0x03,
  0x01,
  0x13,
  0x8a,
  0x6b,
  0x3a,
  0x91,
  0x11,
  0x41,
  0x4f,
  0x67,
  0xdc,
  0xea,
  0x97,
  0xf2,
  0xcf,
  0xce,
  0xf0,
  0xb4,
  0xe6,
  0x73,
  0x96,
  0xac,
  0x74,
  0x22,
  0xe7,
  0xad,
  0x35,
  0x85,
  0xe2,
  0xf9,
  0x37,
  0xe8,
  0x1c,
  0x75,
  0xdf,
  0x6e,
  0x47,
  0xf1,
  0x1a,
  0x71,
  0x1d,
  0x29,
  0xc5,
  0x89,
  0x6f,
  0xb7,
  0x62,
  0x0e,
  0xaa,
  0x18,
  0xbe,
  0x1b,
  0xfc,
  0x56,
  0x3e,
  0x4b,
  0xc6,
  0xd2,
  0x79,
  0x20,
  0x9a,
  0xdb,
  0xc0,
  0xfe,
  0x78,
  0xcd,
  0x5a,
  0xf4,
  0x1f,
  0xdd,
  0xa8,
  0x33,
  0x88,
  0x07,
  0xc7,
  0x31,
  0xb1,
  0x12,
  0x10,
  0x59,
  0x27,
  0x80,
  0xec,
  0x5f,
  0x60,
  0x51,
  0x7f,
  0xa9,
  0x19,
  0xb5,
  0x4a,
  0x0d,
  0x08,
  0x18,
  0x6a,
  0xd7,
  0xab,
  0x76,
  0xca,
  0x82,
  0xc9,
  0x7d,
  0xfa,
  0x59,
  0x47,
  0xf0,
  0xad,
  0xd4,
  0xa2,
  0xaf,
  0x9c,
  0xa4,
  0x72,
  0xc0,
  0xb7,
  0xfd,
  0x93,
  0x26,
  0x36,
  0x3f,
  0xf7,
  0xcc,
  0x34,
  0xa5,
  0xe5,
  0xf1,
  0x71,
  0xd8,
  0x31,
  0x15,
  0x04,
  0xc7,
  0x23,
  0xc3,
  0x18,
  0x96,
  0x05,
  0x9a,
  0x07,
  0x12,
  0x80,
  0xe2,
  0xeb,
  0x27,
  0xb2,
  0x75,
  0x09,
  0x83,
  0x2c,
  0x1a,
  0x1b,
  0x6e,
  0x5a,
  0xa0,
  0x52,
  0x3b,
  0xd6,
  0xb3,
  0x29,
  0xe3,
  0x2f,
  0x84,
  0x53,
  0xd1,
  0x00,
  0xed,
  0x20,
  0xfc,
  0xb1,
  0x5b,
  0x6a,
  0xcb,
  0xbe,
  0x39,
  0x4a,
  0x4c,
  0x58,
  0xcf,
  0xd0,
  0xef,
  0xaa,
  0xfb,
  0x43,
  0x4d,
  0x33,
  0x85,
  0x45,
  0xf9,
  0x02,
  0x7f,
  0x50,
  0x3c,
  0x9f,
  0xa8,
  0x51,
  0xa3,
  0x40,
  0x8f,
  0x92,
  0x9d,
  0x38,
  0xf5,
  0xbc,
  0xb6,
  0xda,
  0x21,
  0x10,
  0xff,
  0xf3,
  0xd2,
  0xcd,
  0x0c,
  0x13,
  0xec,
  0x5f,
  0x97,
  0x44,
  0x17,
  0xc4,
  0xa7,
  0x7e,
  0x3d,
  0x64,
  0x5d,
  0x19,
  0x73,
  0x60,
  0x81,
  0x4f,
  0xdc,
  0x22,
  0x2a,
  0x90,
  0x88,
  0x46,
```
[GENERATED END]

