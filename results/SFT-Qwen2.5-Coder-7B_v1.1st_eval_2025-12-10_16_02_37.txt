j05hr3d/SFT-Qwen2.5-Coder-7B_v1.1st Eval Suite Results
Started at 2025-12-10_16:02:37 Ended at 2025-12-10_16:38:56
Processed 84 tasks.

=== FINAL SCORE: N/A (no executed tasks) ===


=== Task 1 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Implement a function named `xor8` which takes two 8-bit words and returns their bitwise XOR. Also provide a constant `zero8` equal to 0 (8-bit).

[PROMPT END]

[GENERATED BEGIN]
```cryptol
xor8 : [8] -> [8] -> [8]
xor8 x y = x ^ y

zero8 : [8]
zero8 = 0
```
[GENERATED END]


=== Task 2 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Implement a function named `matrix` which takes no input and returns a 3 x 3 matrix of tuples. For the function use a nested comprehension to write an expression to produce a 3 × 3 matrix (as a sequence of sequences), such that the ijth entry contains the value (i, j).

[PROMPT END]

[GENERATED BEGIN]
```cryptol
matrix = [[(i, j) | j <- [1,2,3]] | i <- [1,2,3]]
```
[GENERATED END]


=== Task 3 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Implement a Caesar cipher. Define the functions `encrypt` and `decrypt` with the signature: `{n} [8] -> [n][8] -> [n][8]`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
encrypt : {n} [8] -> [n][8] -> [n][8]
encrypt k msg = [m + k | m <- msg]
decrypt : {n} [8] -> [n][8] -> [n][8]
decrypt k ct = [c - k | c <- ct]
```
[GENERATED END]


=== Task 4 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Using ONLY the functions and constraints provided, create a monomorphic Cryptol property named `equivalent` that proves decrypt inverts encrypt for a 512-byte plaintext.

### Additional setup code:
```cryptol
encryptChar : [8] -> [8] -> [8]
encryptChar key c = (c + key)
decryptChar : [8] -> [8] -> [8]
decryptChar key c = (c - key)
encrypt : {n} [8] -> [n][8] -> [n][8]
encrypt key txt = [ encryptChar key c | c <- txt ]
decrypt : {n} [8] -> [n][8] -> [n][8]
decrypt key txt = [ decryptChar key c | c <- txt ]
```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
encryptChar : [8] -> [8] -> [8]
encryptChar key c = (c + key)
decryptChar : [8] -> [8] -> [8]
decryptChar key c = (c - key)
encrypt : {n} [8] -> [n][8] -> [n][8]
encrypt key txt = [ encryptChar key c | c <- txt ]
decrypt : {n} [8] -> [n][8] -> [n][8]
decrypt key txt = [ decryptChar key c | c <- txt ]

property equivalent key pt = decrypt key (encrypt key pt) == pt
```
[GENERATED END]


=== Task 5 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA384` that imports the generic SHA-2 specification for SHA-384. Use `type DigestSize = 384`, `type w = 64`, and initialize the hash vector as `H0 = [
        0xcbbb9d5dc1059ed8, 0x629a292a367cd507,
        0x9159015a3070dd17, 0x152fecd8f70e5939,
        0x67332667ffc00b31, 0x8eb44a8768581511,
        0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4
    ]
`

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 =
    Primitive::Keyless::Hash::SHA2::Specification where

        type DigestSize = 384
        type w = 64

        H0 = [
            0xcbbb9d5dc1059ed8, 0x629a292a367cd507,
            0x9159015a3070dd17, 0x152fecd8f70e5939,
            0x67332667ffc00b31, 0x8eb44a8768581511,
            0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4
        ]
```
[GENERATED END]


=== Task 6 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Symmetric::Cipher::Block::AES::ExpandKey` that imports the generic `GF28`, `State`, and `SubByteSBox` of the AES encryption modules. Define `type Nk` and `type Nr` as parameters with the constraints that `Nk >= 1` with `8 >= width` and `Nr >= 2` with `8 >= width`. Define the functions `expandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)`, `expandKeyForever : [Nk][4][8] -> [inf]RoundKey`, `keyWS : [Nk][4][8] -> [inf][4][8]`, `Rcon : [8] -> [4]GF28`, `SubWord : [4]GF28 -> [4]GF28`, `RotWord : [4]GF28 -> [4]GF28`, and `NextWord : [8] ->[4][8] -> [4][8] -> [4][8]`. The module should perform AES key expansion. The type `RoundKey` is defined in the `State` module as the following.

### Additional setup code:
```cryptol
module Primitive::Symmetric::Cipher::Block::AES::ExpandKey where

import Primitive::Symmetric::Cipher::Block::AES::GF28
import Primitive::Symmetric::Cipher::Block::AES::State
import Primitive::Symmetric::Cipher::Block::AES::SubByteSBox

parameter

  type Nk : #
  type constraint (8 >= width Nk, Nk >= 1)

  type Nr : #
  type constraint (8 >= width Nr, Nr >= 2)

expandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)
expandKey key = ( keys @ 0
                , keys @@ ([1 .. (Nr - 1)] : [_][8])
                , keys @ (`Nr : [8])
                )
  where   seed : [Nk][4][8]
          seed = split (split key)
          keys = expandKeyForever seed

expandKeyForever : [Nk][4][8] -> [inf]RoundKey
expandKeyForever seed = [ transpose g | g <- split (keyWS seed) ]

keyWS : [Nk][4][8] -> [inf][4][8]
keyWS seed    = xs
     where xs = seed # [ NextWord i prev old
                       | i    <- [ `Nk ... ]
                       | prev <- drop`{Nk-1} xs
                       | old  <- xs
                       ]

Rcon : [8] -> [4]GF28
Rcon i = [ gf28Pow <| x |> (i-1), 0, 0, 0]

SubWord : [4]GF28 -> [4]GF28
SubWord bs = [ SubByte b | b <- bs ]

RotWord : [4]GF28 -> [4]GF28
RotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]

```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::AES::ExpandKey where

import Primitive::Symmetric::Cipher::Block::AES::GF28
import Primitive::Symmetric::Cipher::Block::AES::State
import Primitive::Symmetric::Cipher::Block::AES::SubByteSBox

parameter

  type Nk : #
  type constraint (8 >= width Nk, Nk >= 1)

  type Nr : #
  type constraint (8 >= width Nr, Nr >= 2)

expandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)
expandKey key = ( keys @ 0
                , keys @@ ([1 .. (Nr - 1)] : [_][8])
                , keys @ (`Nr : [8])
                )
  where   seed : [Nk][4][8]
          seed = split (split key)
          keys = expandKeyForever seed

expandKeyForever : [Nk][4][8] -> [inf]RoundKey
expandKeyForever seed = [ transpose g | g <- split (keyWS seed) ]

keyWS : [Nk][4][8] -> [inf][4][8]
keyWS seed    = xs
     where xs = seed # [ NextWord i prev old
                       | i    <- [ `Nk ... ]
                       | prev <- drop`{Nk-1} xs
                       | old  <- xs
                       ]

Rcon : [8] -> [4]GF28
Rcon i = [ gf28Pow <| x |> (i-1), 0, 0, 0]

SubWord : [4]GF28 -> [4]GF28
SubWord bs = [ SubByte b | b <- bs ]

RotWord : [4]GF28 -> [4]GF28
RotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]


NextWord : [8] -> [4][8] -> [4][8] -> [4][8]
NextWord i prev old =
  if i % `Nk == 0
  then SubWord (RotWord prev) ^ Rcon (i / `Nk)
  else if `Nk > 6 && i % `Nk == 4
       then SubWord prev
       else prev
```
[GENERATED END]


=== Task 7 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines an incremental averaging state machine. The specification should define the type `State` to contain a sum of all values and the amount of values as two 32-bit words, the functions `init` to initialize `State`, `appendf` that adds a value to `sum'` and increments `len`, `digest` that returns the average in the `State`, and `avg` with signature `avg : {n} (fin n, 32 >= width n) => [n][32] -> [32]` to compute the averages of a sequence.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
type State = { sum' : [32], len : [32] }
init : State
init = { sum' = 0, len = 0 }
appendf : {a} (Literal 1 a) => a -> State -> State
appendf x s =
  { sum' = s.sum' + x
  , len = s.len + 1
  }
digest : State -> [32]
digest s = s.sum' / s.len
avg : {n} (fin n, 32 >= width n) => [n][32] -> [32]
avg xs = (digest (foldl appendf init xs))
```
[GENERATED END]


=== Task 8 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Test` that imports `Cipher`. Define the function `evktest : {ks, bs, n} (fin bs) => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)`, that takes a cipher, `n` key and test vector tuples, and plain text. The function test that using the cipher’s `encrypt` to encrypt the plain text with each key from the test vectors will produce the cipher text in the test vectors. The function returns `n` tuples containing the cipher text produced by encrypting the plain text with each test key and a boolean value whether the cipher text matches the expected test vector.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Test where

import Cipher

evktest : {ks, bs, n} (fin bs) => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)
evktest (cipher, tests, pt) = map (testEncrypt cipher) tests
    where testEncrypt c (key, ct) = (c.encrypt pt key, ct == c.encrypt pt key)
```
[GENERATED END]


=== Task 9 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module `ECDSA_test` with imports `Common::utils` and `Primitive::Asymmetric::Signature::ECDSA::p192 as p192`. Define a property for the function `G_compress R = ec_compress (ec_affinify G) == R` from the p192 module. Use the value `0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012` in your property.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module ECDSA_test where

import Common::utils
import Primitive::Asymmetric::Signature::ECDSA::p192 as p192

property test_G_compress R = p192::G_compress R == ec_compress (ec_affinify p192::G)
/* pragma R : [192] */
R = 0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012
```
[GENERATED END]


=== Task 10 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module `bivium` that generates the infinite keystream as specified by the Bivium stream cipher. Define the function `bivium_stream : [93] -> [84] -> [inf]` which takes two initial shift registers of lengths 93 and 84 bits and returns the infinite keystream according to the Bivium algorithm. Define `type N = 200`, and a function `Bivium : ([93], [84]) -> [N]Bit` which takes the two initial registers as a pair and returns the first N bits of the keystream returned from `bivium_stream`. Define the helper functions: `shift : {d} (fin d, d >=1) => [d] -> Bit -> [d]` that returns `fills` where `fills = [bit]#(drop`{1} (fill >> 1))`. The function `shift_regs : {d,e} (fin d, fin e, d >=1, e >=1) => [d] -> [e] -> ([inf],[inf][d],[inf][e])` that, given 2 initial registers, returns a tuple containing the infinite keystream, the infinite stream of `r1`, and the infinite stream of `r2`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module bivium where

bivium_stream : [93] -> [84] -> [inf]
bivium_stream r1 r2 =
    take`{1} (r1 @@ [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92]) ^ (r2 @@ [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92])

type N = 200

Bivium : ([93], [84]) -> [N]Bit
Bivium (r1, r2) = take`{N} (bivium_stream r1 r2)

shift : {d} (fin d, d >=1) => [d] -> Bit -> [d]
shift fill bit = fills where fills = [bit]#(drop`{1} (fill >> 1))

shift_regs : {d,e} (fin d, fin e, d >=1, e >=1) => [d] -> [e] -> ([inf],[inf][d],[inf][e])
shift_regs r1 r2 =
    (bivium_stream r1 r2, r1s, r2s)
    where
        r1s = [r1]#[shift r1 (r2@0) | r1 <- r1s]
        r2s = [r2]#[shift r2 (r1@0) | r2 <- r2s]
```
[GENERATED END]


=== Task 11 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512` that imports the generic `ECDSA::UnconstrainedSpec`. Instantiate it with the  `EC = Common::EC::PrimeField::Instantiations::P521` and `Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512 =
    Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec {
        EC = Common::EC::PrimeField::Instantiations::P521,
        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512
    }
```
[GENERATED END]


=== Task 12 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96` that imports the generic Simon specification for Simon96_96. Use `type n = 48`, `type m = 2`, `type T = 52`, and `type j = 2`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96 =
    Primitive::Symmetric::Cipher::Block::Simon::Specification where
        type n = 48
        type m = 2
        type T = 52
        type j = 2
```
[GENERATED END]


=== Task 13 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification for a parameterized SHA-2 style hash function over word size w, defining sha : {L} (2 * w >= width L) => [L] -> [digest_size] and all supporting types, constants (H0, K), and functions (padding, parsing, message schedule, compression, and block processing).

[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
module Primitive::Keyless::Hash::SHA2 where

parameter
  type w : #
  type constraint (fin w, w >= 1)

type digest_size = 8 * w

type H0 = [8][w]
type K  = [64][w]

sha : {L} (2 * w >= width L) => [L] -> [digest_size]
sha M = join (take (H0 # compress (parse (pad M)) H0))

pad : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad M = M # True # zero

parse : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse M = split M

pad' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad' M = M # True # zero

parse' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse' M = split M

pad'' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'' M = M # True # zero

parse'' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'' M = split M

pad''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''' M = M # True # zero

parse''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''' M = split M

pad'''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''' M = M # True # zero

parse'''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''' M = split M

pad''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''' M = M # True # zero

parse''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''' M = split M

pad'''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''' M = M # True # zero

parse'''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''' M = split M

pad''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''' M = M # True # zero

parse''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''' M = split M

pad'''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''' M = M # True # zero

parse'''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''' M = split M

pad''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''' M = M # True # zero

parse''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''''' M = split M

pad'''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''''' M = M # True # zero

parse'''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''''' M = split M

pad''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''''' M = M # True # zero

parse''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''''''' M = split M

pad'''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''''''' M = M # True # zero

parse'''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''''''' M = split M

pad''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''''''' M = M # True # zero

parse''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''''''''' M = split M

pad'''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''''''''' M = M # True # zero

parse'''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''''''''' M = split M

pad''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''''''''' M = M # True # zero

parse''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''''''''''' M = split M

pad'''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''''''''''' M = M # True # zero

parse'''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''''''''''' M = split M

pad''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''''''''''' M = M # True # zero

parse''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''''''''''''' M = split M

pad'''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''''''''''''' M = M # True # zero

parse'''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''''''''''''' M = split M

pad''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''''''''''''' M = M # True # zero

parse''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''''''''''''''' M = split M

pad'''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''''''''''''''' M = M # True # zero

parse'''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''''''''''''''' M = split M

pad''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''''''''''''''' M = M # True # zero

parse''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''''''''''''''''' M = split M

pad'''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''''''''''''''''' M = M # True # zero

parse'''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''''''''''''''''' M = split M

pad''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''''''''''''''''' M = M # True # zero

parse''''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''''''''''''''''''' M = split M

pad'''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''''''''''''''''''' M = M # True # zero

parse'''''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''''''''''''''''''' M = split M

pad''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''''''''''''''''''' M = M # True # zero

parse''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''''''''''''''''''''' M = split M

pad'''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''''''''''''''''''''' M = M # True # zero

parse'''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''''''''''''''''''''' M = split M

pad''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''''''''''''''''''''' M = M # True # zero

parse''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''''''''''''''''''''''' M = split M

pad'''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''''''''''''''''''''''' M = M # True # zero

parse'''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''''''''''''''''''''''' M = split M

pad''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''''''''''''''''''''''' M = M # True # zero

parse''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''''''''''''''''''''''''' M = split M

pad'''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''''''''''''''''''''''''' M = M # True # zero

parse'''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''''''''''''''''''''''''' M = split M

pad''''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''''''''''''''''''''''''' M = M # True # zero

parse''''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''''''''''''''''''''''''''' M = split M

pad'''''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''''''''''''''''''''''''''' M = M # True # zero

parse'''''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''''''''''''''''''''''''''' M = split M

pad''''''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''''''''''''''''''''''''''' M = M # True # zero

parse''''''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''''''''''''''''''''''''''''' M = split M

pad'''''''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''''''''''''''''''''''''''''' M = M # True # zero

parse'''''''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''''''''''''''''''''''''''''' M = split M

pad''''''''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''''''''''''''''''''''''''''' M = M # True # zero

parse''''''''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse''''''''''''''''''''''''''''''''''' M = split M

pad'''''''''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad'''''''''''''''''''''''''''''''''''' M = M # True # zero

parse'''''''''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L + w + 1] -> [L / w][w]
parse'''''''''''''''''''''''''''''''''''' M = split M

pad''''''''''''''''''''''''''''''''''''' : {L} (2 * w >= width L) => [L] -> [L + w + 1]
pad''''''''''''''''''''''''''''''''''''' M
```
[GENERATED END]


=== Task 14 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Using the existing type `Cipher` and value `toyCipher` provided in the test setup, define a single polymorphic Cryptol function named `evktest` with the following type:

evktest : {ks, bs, n} (fin bs)
       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)

The function should take a cipher implementation, a sequence of (Key, Ciphertext) test vectors, and a single plaintext block. For each (Key, CT) in the list, it must iterate over that list using a single generator in a list comprehension (no parallel generators or multiple `|` arms), compute CT' = cipher.encrypt Key PT for that entry, and produce an output list of pairs (CT', CT' == CT).

The code for `Cipher` and `toyCipher` is ALREADY present in the file from the test setup code. In your answer, you MUST NOT repeat, modify, or redefine `Cipher` or `toyCipher`, and you MUST NOT add any other top-level declarations.

Your entire answer must consist of exactly two top-level lines: (1) the type signature for `evktest` exactly as given above, and (2) the definition of `evktest`. Do not wrap these in a module declaration, and do not include any setup code.

### Additional setup code:
```cryptol
type Cipher ks bs =
  { encrypt : [ks] -> [bs] -> [bs]
  , decrypt : [ks] -> [bs] -> [bs]
  }

toyCipher : Cipher 8 8
toyCipher = {
  encrypt = \k pt -> k ^ pt,
  decrypt = \k ct -> k ^ ct
}

```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Cipher ks bs =
  { encrypt : [ks] -> [bs] -> [bs]
  , decrypt : [ks] -> [bs] -> [bs]
  }

toyCipher : Cipher 8 8
toyCipher = {
  encrypt = \k pt -> k ^ pt,
  decrypt = \k ct -> k ^ ct
}


evktest : {ks, bs, n} (fin bs)
       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)
evktest (cipher, tests, pt) =
  [ (ct', ct' == ct) | (k, ct) <- tests | ct' <- cts ]
  where
    cts = [ cipher.encrypt k pt | k <- keys ]

type Cipher ks bs =
  { encrypt : [ks] -> [bs] -> [bs]
  , decrypt : [ks] -> [bs] -> [bs]
  }

toyCipher : Cipher 8 8
toyCipher = {
  encrypt = \k pt -> k ^ pt,
  decrypt = \k ct -> k ^ ct
}
```
[GENERATED END]


=== Task 15 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Using ONLY the SHA-512 specification provided in the test setup (which defines a function `sha512` and all supporting constants), define a Cryptol property named `testVector1` with no arguments that checks `sha512` against the following fixed known-answer test vector:

- Message (as a hex literal): 0x616263
- Expected digest (as a hex literal): 0xddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f

The property must *exactly* assert that `sha512` of this message equals this digest.

The full definition of `sha512` (and all helper functions and constants) is ALREADY present in the file from the test setup code. In your answer, you MUST NOT repeat, modify, or redefine `sha512` or any of its helpers, and you MUST NOT add any other top-level declarations.

Your entire answer must be a single top-level declaration starting with:

property testVector1 =

and it must directly assert that `sha512 0x616263` equals the given digest, using those exact hex constants. Do not introduce any arguments, do not wrap it in a module, and do not include any setup code.

### Additional setup code:
```cryptol
sha512 M = result
  where
    M' = (pad M)
    blocks = (groupBy`{1024} M')
    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]
    result = (join (hash!0))

processBlock : [1024] -> [8][64] -> [8][64]
processBlock block Hprev = Hs
  where
    Mi = split block : [16][64]
    Ws = (messageSch Mi)
    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]
    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]

step : [8][64] -> [64] -> [8] -> [8][64]
step [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']
  where
    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt
    T2 = (SIGMA0 a) + (Maj a b c)
    h' = g
    g' = f
    f' = e
    e' = d + T1
    d' = c
    c' = b
    b' = a
    a' = T1 + T2

messageSch : [16][64] -> [80][64]
messageSch Mi = W
  where
    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]

pad : {l, k} (fin l,
              l <= ((2^^128) - 1),
              l >= 0,
              fin k,
              k - l >= 129,
              k == 128 + l + 1 + 1024 - ((l+129)%1024),
              k%1024 == 0) => [l] -> [k]
pad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])

Ch : [64] -> [64] -> [64] -> [64]
Ch x y z = (x && y) ^ ((~x) && z)

Maj : [64] -> [64] -> [64] -> [64]
Maj x y z = (x && y) ^ (x && z) ^ (y && z)

SIGMA0 : [64] -> [64]
SIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)

SIGMA1 : [64] -> [64]
SIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)

sigma0 : [64] -> [64]
sigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)

sigma1 : [64] -> [64]
sigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)

H0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]

K = [
0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
]

```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
sha512 M = result
  where
    M' = (pad M)
    blocks = (groupBy`{1024} M')
    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]
    result = (join (hash!0))

processBlock : [1024] -> [8][64] -> [8][64]
processBlock block Hprev = Hs
  where
    Mi = split block : [16][64]
    Ws = (messageSch Mi)
    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]
    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]

step : [8][64] -> [64] -> [8] -> [8][64]
step [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']
  where
    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt
    T2 = (SIGMA0 a) + (Maj a b c)
    h' = g
    g' = f
    f' = e
    e' = d + T1
    d' = c
    c' = b
    b' = a
    a' = T1 + T2

messageSch : [16][64] -> [80][64]
messageSch Mi = W
  where
    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]

pad : {l, k} (fin l,
              l <= ((2^^128) - 1),
              l >= 0,
              fin k,
              k - l >= 129,
              k == 128 + l + 1 + 1024 - ((l+129)%1024),
              k%1024 == 0) => [l] -> [k]
pad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])

Ch : [64] -> [64] -> [64] -> [64]
Ch x y z = (x && y) ^ ((~x) && z)

Maj : [64] -> [64] -> [64] -> [64]
Maj x y z = (x && y) ^ (x && z) ^ (y && z)

SIGMA0 : [64] -> [64]
SIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)

SIGMA1 : [64] -> [64]
SIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)

sigma0 : [64] -> [64]
sigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)

sigma1 : [64] -> [64]
sigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)

H0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]

K = [
0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
]


property testVector1 =
  sha512 0x616263 ==
  0xddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f
```
[GENERATED END]


=== Task 16 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Using ONLY the definitions `mk_buggy_fib_no_init`, `generate`, the infix operator `$`, and the sequences `foo` and `bar` provided in the test setup, define a Cryptol property named `fooEqualsBar` with no arguments that asserts that `foo` and `bar` are exactly equal. Do not redefine any of these functions or values; only provide the definition of `property fooEqualsBar`.

### Additional setup code:
```cryptol
mk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->
  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))
mk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))
  where
  fn2 = fn + fn1
  // Change output when state has magic value.
  fn' = fn + if k == magic then 1 else 0

generate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a
generate f = [ f i | i <- [0 .. n-1] ]

infixl 1 $
f $ x = f x

foo : [10][4]
foo = generate $ \(i:[8]) -> if i == 0 then 1 else foo@(i-1)

bar : [10][4]
bar = generate \(i:[8]) -> if i == 0 then 1 else foo@(i-1)

```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
mk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->
  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))
mk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))
  where
  fn2 = fn + fn1
  // Change output when state has magic value.
  fn' = fn + if k == magic then 1 else 0

generate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a
generate f = [ f i | i <- [0 .. n-1] ]

infixl 1 $
f $ x = f x

foo : [10][4]
foo = generate $ \(i:[8]) -> if i == 0 then 1 else foo@(i-1)

bar : [10][4]
bar = generate \(i:[8]) -> if i == 0 then 1 else foo@(i-1)


property fooEqualsBar = foo == bar
```
[GENERATED END]


=== Task 17 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the function `unflatten : {r,w} (fin r, 5 * w >= r, fin w) => [r] -> [w][5]` that pads its input with zeros and groups it into `w` blocks of 5 elements using `groupBy` in Cryptol. DO NOT include import statements, module declarations, or any other code.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
unflatten : {r, w}
  (fin r, 5 * w >= r, fin w) =>
    [r] -> [w][5]
unflatten p = groupBy`{5} (p # zero)
```
[GENERATED END]


=== Task 18 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol file that defines the functions `mk_curve_ops`, `ec_v1`, and `ec_v2`. The definition must follow the exact structure shown in the prompt: `mk_curve_ops` must construct a record containing fields `field`, `v1`, and `v2`, where `v1` calls `ec_v1` on the input parameter and `v2` calls `ec_v2` on the record being constructed. The functions must use the polymorphic types exactly as shown and must access `p.field.v0` correctly in `ec_v2`. The file must contain no module declaration and must consist only of the three definitions.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
mk_curve_ops p =
  { field = p
  , v1 = ec_v1 p
  , v2 = ec_v2 { field = p, v0 = x }
  }

ec_v1 : {t} (fin t) => [t] -> [t]
ec_v1 x = x

ec_v2 : {t} (fin t) => {field : [t], v0 : [t]} -> [t]
ec_v2 x = x.v0 + x.field.v0
```
[GENERATED END]


=== Task 19 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module named `T038` that declares an interface submodule `I` providing `x : [8]`, a submodule `F` that imports interface submodule `I` and defines `y = x + 1`, a submodule `P` that imports submodule `F` while exposing submodule `Q`, a submodule `Q` that defines `x = 11`, and finally an interface submodule `J` that imports submodule `F` through `P`. The structure must match the Cryptol module system rules exactly.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module T038 where

interface submodule I where
  x : [8]

submodule F where
  import interface submodule I

  y = x + 1

submodule P where
  import submodule F
  export submodule Q

submodule Q where
  x = 11

interface submodule J where
  import submodule F via submodule P
```
[GENERATED END]


=== Task 20 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Reproduce exactly the four foreign function declarations `foreignAndCryptol`, `foreignAndNoCryptol`, `noForeignAndCryptol`, and `noForeignAndNoCryptol`, each using the C calling convention. Implement `foreignAndCryptol` to return its argument unchanged, leave `foreignAndNoCryptol` unimplemented, implement `noForeignAndCryptol` to return `x + 3`, and leave `noForeignAndNoCryptol` unimplemented. The file must contain only these four declarations.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
foreign foreignAndCryptol : [32] -> [32]
foreignAndCryptol x = x

foreign foreignAndNoCryptol : [32] -> [32]

noForeignAndCryptol : [32] -> [32]
noForeignAndCryptol x = x + 3

foreign noForeignAndNoCryptol : [32] -> [32]
```
[GENERATED END]


=== Task 21 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Write a Cryptol module implementing parameterized AES encryption and decryption for key sizes 128, 192, and 256 bits. The module must import the AES algorithm, key expansion, and T-box modules exactly as specified, define `encrypt` and `decrypt` in terms of expanded keys, and include a property named `test` verifying that `decrypt k (encrypt k pt) == pt` for all valid keys and all 128-bit plaintexts.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256

parameter
    type KeySize : #
    type constraint (KeySize == 128 + 64 * n, n >= 2)

type K = [KeySize]
type Nb = 4
type Nr = 6 + n
type State = [4][Nb][8]

expandKey : K -> [Nr+1]State
expandKey = expandKey`{KeySize}

encrypt : K -> [128] -> [128]
encrypt k pt = join (AES.encrypt (expandKey k) (split pt))

decrypt : K -> [128] -> [128]
decrypt k ct = join (AES.decrypt (expandKey k) (split ct))

property test k pt = decrypt k (encrypt k pt) == pt
```
[GENERATED END]


=== Task 22 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Write a complete Cryptol module implementing the Bivium stream cipher. The module must define `Bivium_stream`, `Bivium`, `Bivium_alt`, and all cycle-testing helpers. It must also define the four properties: `Bivium_correct`, `Bivium_search`, `Bivium_search_with_suffix`, and `Bivium_alt_equivalent`, using the exact IVs, suffix, and test keystream provided. The file must match the structure and behavior of the Bivium specification.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
type Round = [16]
type State = {R : [80], S : [80]}
type Key = [80]
type IV = [80]
type Keystream = [inf]Bit

Bivium_stream : Round -> State -> Keystream
Bivium_stream i st =
  if i < 80 then
    (Bivium_stream (i + 1) (update_state st)) # [False]
  else
    (Bivium_stream (i + 1) (update_state st)) # [(st.S @ 0)]
  where
    update_state : State -> State
    update_state s =
      {R = R',
       S = S'}
      where
        R' = (s.R <<< 1) ^ (if s.S @ 79 then [True] else [False])
        S' = (s.S <<< 1) ^ (if (s.S @ 4) && (s.S @ 5) then [True] else [False]) ^ (if (s.S @ 23) && (s.S @ 24) then [True] else [False]) ^ (if (s.S @ 43) && (s.S @ 44) then [True] else [False]) ^ (if (s.S @ 63) && (s.S @ 64) then [True] else [False]) ^ (if (s.S @ 79) && (s.S @ 0) then [True] else [False]) ^ (if (s.S @ 78) && (s.S @ 79) then [True] else [False])

Bivium : Key -> IV -> Keystream
Bivium k iv = Bivium_stream 0 (init_state k iv)

init_state : Key -> IV -> State
init_state k iv = {R = k, S = iv}

Bivium_alt : Key -> IV -> Keystream
Bivium_alt k iv = Bivium_stream 0 (init_state_alt k iv)

init_state_alt : Key -> IV -> State
init_state_alt k iv =
  {R = k',
   S = s'}
  where
    k' = k <<< 1
    s' = iv <<< 1

Bivium_correct : Bit
property Bivium_correct =
  take `{100} (Bivium k iv) == ks
  where
    k = 0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
    iv = 0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
    ks =
      [False,
       False,
       False,
       True,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
       False,
```
[GENERATED END]


=== Task 23 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Write a Cryptol module implementing the FNV-1a 64-bit hash function, including padding, the FNV offset basis, prime constant, the block-processing logic, and a property `testsPass` that verifies the hash of the empty string, "a", and "foobar" equals the known answer test vectors provided.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
fnv1a : {n} (fin n) => [n] -> [64]
fnv1a msg = foldl processBlock (offsetBasis : [64]) (pad msg)

type blockSize = 32

type FnvPrime = 1099511628211

type offsetBasis = 14695981039346656037

pad : {n} (fin n) => [n] -> [((n + 7)/8 * 8)]
pad msg = msg # zero

processBlock : [64] -> [blockSize] -> [64]
processBlock h b = h ^ (b # zero) * FnvPrime
testsPass = fnv1a [] == 0xcbf29ce484222325
	&& fnv1a "a" == 0xaf63dc4c80011cc3
	&& fnv1a "foobar" == 0x85d91e7742849317
```
[GENERATED END]


=== Task 24 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA384` that instantiates the generic SHA-2 specification for SHA-384 with 64-bit words, 384-bit digest size, and the given 8-word initial hash vector `H0`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 =
    Primitive::Keyless::Hash::SHA2::SHA2 where

        type w = 64
        type DigestSize = 384
        H0 = [
            0x9dd1b4dc7d2dd99d, 0x2bbbe8bfe7fd9595,
            0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
            0x510e527fade682d1, 0x9b05688c2b3e6c1f,
            0x1f83d9abfb41bd6b, 0x5be0cd19137e2179
        ]
```
[GENERATED END]


=== Task 25 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 with an xof function imported from the SHAKE256 instantiation and properties k5–k8 that assert xof applied to [], 0b0, 0b11, and 0b110 equals the given 512-bit expected_result constants.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 where

import Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO
import Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256

property k5 = xof [] == expected_result where
    expected_result = join [
        0x974a5c987d3e914f661664540000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000
    ]

property k6 = xof 0b0 == expected_result where
    expected_result = join [
        0x974a5c987d3e914f661664540000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000
    ]

property k7 = xof 0b11 == expected_result where
    expected_result = join [
        0x974a5c987d3e914f661664540000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000
    ]

property k8 = xof 0b110 == expected_result where
    expected_result = join [
        0x974a5c987d3e914f661664540000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000
    ]
```
[GENERATED END]


=== Task 26 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module that instantiates SHA3-224 and defines properties t1, t5, t72, and t512 that check the hash and hashBytes functions against the given known-answer test vectors.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Keyless::Hash::SHA2::Tests::SHA3_224 where

import Primitive::Keyless::Hash::SHA2::Instantiations::SHA3_224 as SHA3_224

property t1 = SHA3_224::hash [] == output where
    output = join [
        0x6b86b273ff9e14d64ffda044a010a820,
        0xf4c26c35e1548cdd159f310dbc826a11,
        0x465d9f2fcf8b167f08af437bd3fa912b
    ]

property t5 = SHA3_224::hash "abc" == output where
    output = join [
        0x204a8fca2aad73103d09f691e255bf6b,
        0x3f4bcda32ce179003ede342f6185007f,
        0xe3f94ec63f08dd515adeeb3da71195c3
    ]

property t72 = SHA3_224::hashBytes (join "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq") == output where
    output = join [
        0x167905909cbf19231c31459e7f7e0e95,
        0x8714097fb74db2e05318251ecb524f6c,
        0x3c7716a71695aafe368c0da9ecf6751d
    ]

property t512 = SHA3_224::hash (join "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu") == output where
    output = join [
        0xa7ad6fea7c720e2c5a75c178c2a01a6f,
        0x2e0e2a9d2e8c5397bf2f384ff98c90dc,
        0x3d3e1394694500237acc10ecc69de102
    ]
```
[GENERATED END]


=== Task 27 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that models the Kalotan logic puzzle with parents and child as Bits, defines the given constraints (heterosexual parents, kid lying, parents’ statements), and includes properties equivalent to people_types, checkit1, and checkit2 capturing the valid/invalid configurations.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
type P = Bit
type C = Bit

heterosexual : P -> P -> C -> Bit
heterosexual mom dad kid = ~(mom == dad)

kid_lies : P -> P -> C -> Bit
kid_lies mom dad kid = kid == ~(mom ^ dad)

parents_say : P -> P -> C -> Bit
parents_say mom dad kid = (mom && ~kid) || (~mom && kid)

people_types : P -> P -> C -> Bit
property people_types mom dad kid =
  (heterosexual mom dad kid) /\ (kid_lies mom dad kid) /\ (parents_say mom dad kid)

checkit1 : P -> P -> C -> Bit
property checkit1 mom dad kid =
  (heterosexual mom dad kid) == (mom != dad)

checkit2 : P -> P -> C -> Bit
property checkit2 mom dad kid =
  (kid_lies mom dad kid) == kid
```
[GENERATED END]


=== Task 28 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification for a parameterized SHA-2 style hash function over word size w, defining sha : {L} (2 * w >= width L) => [L] -> [digest_size] and all supporting types, constants (H0, K), and functions (padding, parsing, message schedule, compression, and block processing).

### Additional setup code:
```cryptol
Ch_Alternate : {w} (fin w, w >= 1) => [w] -> [w] -> [w] -> [w]
Ch_Alternate x y z = (x /\ y) \/ (~x /\ z)
```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
Ch_Alternate : {w} (fin w, w >= 1) => [w] -> [w] -> [w] -> [w]
Ch_Alternate x y z = (x /\ y) \/ (~x /\ z)

module Primitive::Keyless::Hash::SHA2::sha2 where

parameter
    type w : #
    type constraint (fin w, w >= 1)

type digest_size = 8 * w

type block_size = 16 * w

type L = 64 * w

H0 : [8][w]
H0 =
    [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f,
     0x9b05688c, 0x1f83d9ab, 0x5be0cd19]

K : [64][w]
K =
    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
     0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
     0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
     0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
     0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
     0xa831c66d, 0xb00327c8, 0xbf59eb67, 0xc6e00bf3, 0xd5a79147,
     0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
     0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
     0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
     0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
     0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
     0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]

sha : {L} (2 * w >= width L) => [L] -> [digest_size]
sha M = join (H0 @@ [i | i <- [0 .. 7]])
    where
        blocks = split (M # padding (M, L))
        H = compress (H0, blocks)

parse : [block_size] -> [16][w]
parse B = split B

message_schedule : [16][w] -> [64][w]
message_schedule W =
    W # [sigma1 (W @ (i - 15)) + sigma0 (W @ (i - 2)) | i <- [16 .. 63]]

sigma0 : [w] -> [w]
sigma0 X = (X >>> 7) ^ (X >>> 18) ^ (X >> 3)

sigma1 : [w] -> [w]
sigma1 X = (X >>> 17) ^ (X >>> 19) ^ (X >> 10)

Ch : {w} (fin w, w >= 1) => [w] -> [w] -> [w] -> [w]
Ch x y z = (x /\ y) \/ (~x /\ z)

Maj : {w} (fin w, w >= 1) => [w] -> [w] -> [w] -> [w]
Maj x y z = (x /\ y) \/ (x /\ z) \/ (y /\ z)

rounds : [8][8][w] -> [64][w] -> [8][8][w]
rounds ABCD E = ABCD'
    where
        ABCD' = [A', B', C', D'] @@ [0 .. 7]
            where
                T1 = [h + sigma1 e + Ch e f g + k @ i + w @ i
                      | h <- ABCD @ 3
                      | e <- ABCD @ 0
                      | f <- ABCD @ 1
                      | g <- ABCD @ 2
                      | k <- K
                      | w <- W
                      | i <- [0 .. 63]]
                T2 = sigma0 (ABCD @ 0) + Maj (ABCD @ 0) (ABCD @ 1) (ABCD @ 2)
                A' = ABCD @ 2
                B' = ABCD @ 3
                C' = ABCD @ 0 + T1 @ 0
                D' = ABCD @ 1 + T1 @ 0 + T2

process_block : [8][8][w] -> [block_size] -> [8][8][w]
process_block ABCD B = rounds ABCD (message_schedule (parse B))

compress : [8][8][w] -> [block_size][block_size] -> [8][8][w]
compress ABCD blocks = foldl process_block ABCD blocks

padding : {L} (2 * w >= width L) => [L] -> [L + 1 + 64 * w]
padding M =
    M # [True] # zero # (fromInteger (toInteger (L / (8 * w))))
```
[GENERATED END]


=== Task 29 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Create a function that performs modulo addition with the signature `mod_add_Z : (Integer, Integer, Integer) -> Integer`. The first parameter is the modulo base.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
mod_add_Z : (Integer, Integer, Integer) -> Integer
mod_add_Z (n, x, y) = (x + y) % n
```
[GENERATED END]


=== Task 30 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Create a function that multiplies a number with itself using modulo multiplication. Define the following functions `mod_mul_Z : (Integer, Integer, Integer) -> Integer` and `mod_sq_Z : (Integer, Integer) -> Integer`. The first parameter should be the modulo base for both functions. `mod_sq_Z` should call `mod_mul_Z` to perform the modulo multiplication.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
mod_mul_Z : (Integer, Integer, Integer) -> Integer
mod_mul_Z (m, x, y) = (x * y) % m

mod_sq_Z : (Integer, Integer) -> Integer
mod_sq_Z (m, x) = mod_mul_Z (m, x, x)
```
[GENERATED END]


=== Task 31 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the function `mod_div_Z : (Integer, Integer, Integer) -> Integer` that performs modulo division between two integers. The modulo base is the first parameter. You should implement Stein's algorithm and call `mod_half_Z` to perform modulo division by 2. The resulting file should only have two functions and be standalone.

### Additional setup code:
```cryptol
mod_half_Z : (Integer, Integer) -> Integer
mod_half_Z (p, x) = if (x % 2 == 0) then x / 2 else (x + p) / 2

```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
mod_half_Z : (Integer, Integer) -> Integer
mod_half_Z (p, x) = if (x % 2 == 0) then x / 2 else (x + p) / 2


mod_div_Z : (Integer, Integer, Integer) -> Integer
mod_div_Z (p, x, y) =
  if y == 0 then error "division by zero" else z
  where
    (q, r) = (x, y)
    (s, t) = (0, 1)
    (u, v) = (1, 0)
    (m, n) = (p, q)
    (a, b) = (r, s)
    (c, d) = (t, u)
    (e, f) = (v, w)
    (g, h) = (m, n)
    (i, j) = (a, b)
    (k, l) = (c, d)
    (m', n') = (e, f)
    (o, p') = (g, h)
    (q', r') = (i, j)
    (s', t') = (k, l)
    (u', v') = (m', n')
    (w, x') = (o, p')
    (y', z) = (q', r')
mod_half_Z : (Integer, Integer) -> Integer
mod_half_Z (p, x) = if (x % 2 == 0) then x / 2 else (x + p) / 2
```
[GENERATED END]


=== Task 32 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Create a Cryptol specification that performs the SHA-512 message schedule expansion. Define the functions `messageSch : [16][64] -> [80][64]`, `sigma0 : [64] -> [64]`, and `sigma1 : [64] -> [64]` to perform the message expansion.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
messageSch : [16][64] -> [80][64]
messageSch M = M # [ sigma1 (W@i-2) ^ sigma0 (W@i-7) ^ (W@i-15) ^ (W@i-16)
                   | i <- [16..79]
                   ]
sigma0 : [64] -> [64]
sigma0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)
sigma1 : [64] -> [64]
sigma1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)
```
[GENERATED END]


=== Task 33 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the property `tcId1080` that checks, for AES-256 Key Wrap with padding in AE mode, that encrypting the plaintext `0x06` under the key `0x3ea9325069ed93a96c331bdd6dd766ec64bbba83a72c69ed75df55043fb0bfd1` with `KWP_AE` produces the expected ciphertext `0x40a9c42012ba38211b800e6e313b6876`, using the helper `check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap


check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct
/* pragma tcId1080 : property */
tcId1080 =
  testPassed == check_KWP_AE key pt ct
  where
    testPassed = True
    key =
      0x3ea9325069ed93a96c331bdd6dd766ec64bbba83a72c69ed75df55043fb0bfd1
    pt = 0x06
    ct = 0x40a9c42012ba38211b800e6e313b6876
```
[GENERATED END]


=== Task 34 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the Cryptol module `Primitive::Symmetric::Cipher::Block::AES::SubByteSBox` implementing the AES SubBytes and InvSubBytes transformations with functions `SubByte : GF28 -> GF28` and `InvSubByte : GF28 -> GF28`, using `sbox` and `sboxInv` over `GF28` elements.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
module Primitive::Symmetric::Cipher::Block::AES::SubByteSBox where

import Primitive::Symmetric::Cipher::Block::AES::GF28

type SBox = [256]GF28

SubByte : GF28 -> GF28
SubByte b = sbox @ b

InvSubByte : GF28 -> GF28
InvSubByte b = sboxInv @ b

sbox : SBox
sbox =
  [0x63,
  0x7c,
  0x77,
  0x7b,
  0xf2,
  0x6b,
  0x6f,
  0xc5,
  0x30,
  0x01,
  0x67,
  0x2b,
  0xfe,
  0xd7,
  0xab,
  0x76,
  0xca,
  0x82,
  0xc9,
  0x7d,
  0xfa,
  0x59,
  0x47,
  0xf0,
  0xad,
  0xd4,
  0xa2,
  0xaf,
  0x9c,
  0xa4,
  0x72,
  0xc0,
  0xb7,
  0xfd,
  0x93,
  0x26,
  0x36,
  0x3f,
  0xf7,
  0xcc,
  0x34,
  0xa5,
  0xe5,
  0xf1,
  0x71,
  0xd8,
  0x31,
  0x15,
  0x04,
  0xc7,
  0x23,
  0xc3,
  0x18,
  0x96,
  0x05,
  0x9a,
  0x07,
  0x12,
  0x80,
  0xe2,
  0xeb,
  0x27,
  0xb2,
  0x75,
  0x09,
  0x83,
  0x2c,
  0x1a,
  0x1b,
  0x6e,
  0x5a,
  0xa0,
  0x52,
  0x3b,
  0xd6,
  0xb3,
  0x29,
  0xe3,
  0x2f,
  0x84,
  0x53,
  0xd1,
  0x00,
  0xed,
  0x20,
  0xfc,
  0xb1,
  0x5b,
  0x6a,
  0xcb,
  0xbe,
  0x39,
  0x4a,
  0x4c,
  0x58,
  0xcf,
  0xd0,
  0xef,
  0xaa,
  0xfb,
  0x43,
  0x4d,
  0x33,
  0x85,
  0x45,
  0xf9,
  0x02,
  0x7f,
  0x50,
  0x3c,
  0x9f,
  0xa8,
  0x51,
  0xa3,
  0x40,
  0x8f,
  0x92,
  0x9d,
  0x38,
  0xf5,
  0xbc,
  0xb6,
  0xda,
  0x21,
  0x10,
  0xff,
  0xf3,
  0xd2,
  0xcd,
  0x0c,
  0x13,
  0xec,
  0x5f,
  0x97,
  0x44,
  0x17,
  0xc4,
  0xa7,
  0x7e,
  0x3d,
  0x64,
  0x5d,
  0x19,
  0x73,
  0x60,
  0x81,
  0x4f,
  0xdc,
  0x22,
  0x2a,
  0x90,
  0x88,
  0x46,
  0xee,
  0xb8,
  0x14,
  0xde,
  0x5e,
  0x0b,
  0xdb,
  0xe0,
  0x32,
  0x3a,
  0x0a,
  0x49,
  0x06,
  0x24,
  0x5c,
  0xc2,
  0xd3,
  0xac,
  0x62,
  0x91,
  0x95,
  0xe4,
  0x79,
  0xe7,
  0xc8,
  0x37,
  0x6d,
  0x8d,
  0xd5,
  0x4e,
  0xa9,
  0x6c,
  0x56,
  0xf4,
  0xea,
  0x65,
  0x7a,
  0xae,
  0x08,
  0xba,
  0x78,
  0x25,
  0x2e,
  0x1c,
  0xa6,
  0xb4,
  0xc6,
  0xe8,
  0xdd,
  0x74,
  0x1f,
  0x4b,
  0xbd,
  0x8b,
  0x8a,
  0x70,
  0x3e,
  0xb5,
  0x66,
  0x48,
  0x03,
  0xf6,
  0x0e,
  0x61,
  0x35,
  0x57,
  0xb9,
  0x86,
  0xc1,
  0x1d,
  0x9e,
  0xe1,
  0xf8,
  0x98,
  0x11,
  0x69,
  0xd9,
  0x8e,
  0x94,
  0x9b,
  0x1e,
  0x87,
  0xe9,
  0xce,
  0x55,
  0x28,
  0xdf,
  0x8c,
  0xa1,
  0x89,
  0x0d,
  0xbf,
  0xe6,
  0x42,
  0x68,
  0x41,
  0x99,
  0x2d,
  0x0f,
  0xb0,
  0x54,
  0xbb,
  0x16]

sboxInv : SBox
sboxInv =
  [0x52,
  0x09,
  0x6a,
  0xd5,
  0x30,
  0x36,
  0xa5,
  0x38,
  0xbf,
  0x40,
  0xa3,
  0x9e,
  0x81,
  0xf3,
  0xd7,
  0xfb,
  0x7c,
  0xe3,
  0x39,
  0x82,
  0x9b,
  0x2f,
  0xff,
  0x87,
  0x34,
  0x8e,
  0x43,
  0x44,
  0xc4,
  0xde,
  0xe9,
  0xcb,
  0x54,
  0x7b,
  0x94,
  0x32,
  0xa6,
  0xc2,
  0x23,
  0x3d,
  0xee,
  0x4c,
  0x95,
  0x0b,
  0x42,
  0xfa,
  0xc3,
  0x4e,
  0x08,
  0x2e,
  0xa1,
  0x66,
  0x28,
  0xd9,
  0x24,
  0xb2,
  0x76,
  0x5b,
  0xa2,
  0x49,
  0x6d,
  0x8b,
  0xd1,
  0x25,
  0x72,
  0xf8,
  0xf6,
  0x64,
  0x86,
  0x68,
  0x98,
  0x16,
  0xd4,
  0xa4,
  0x5c,
  0xcc,
  0x5d,
  0x65,
  0xb6,
  0x92,
  0x6c,
  0x70,
  0x48,
  0x50,
  0xfd,
  0xed,
  0xb9,
  0xda,
  0x5e,
  0x15,
  0x46,
  0x57,
  0xa7,
  0x8d,
  0x9d,
  0x84,
  0x90,
  0xd8,
  0xab,
  0x00,
  0x8c,
  0xbc,
  0xd3,
  0x0a,
  0xf7,
  0xe4,
  0x58,
  0x05,
  0xb8,
  0xb3,
  0x45,
  0x06,
  0xd0,
  0x2c,
  0x1e,
  0x8f,
  0xca,
  0x3f,
  0x0f,
  0x02,
  0xc1,
  0xaf,
  0xbd,
  0x03,
  0x01,
  0x13,
  0x8a,
  0x6b,
  0x3a,
  0x91,
  0x11,
  0x41,
  0x4f,
  0x67,
  0xdc,
  0xea,
  0x97,
  0xf2,
  0xcf,
  0xce,
  0xf0,
  0xb4,
  0xe6,
  0x73,
  0x96,
  0xac,
  0x74,
  0x22,
  0xe7,
  0xad,
  0x35,
  0x85,
  0xe2,
  0xf9,
  0x37,
  0xe8,
  0x1c,
  0x75,
  0xdf,
  0x6e,
  0x47,
  0xf1,
  0x1a,
  0x71,
  0x1d,
  0x29,
  0xc5,
  0x89,
  0x6f,
  0xb7,
  0x62,
  0x0e,
  0xaa,
  0x18,
  0xbe,
  0x1b,
  0xfc,
  0x56,
  0x3e,
  0x4b,
  0xc6,
  0xd2,
  0x79,
  0x20,
  0x9a,
  0xdb,
  0xc0,
  0xfe,
  0x78,
  0xcd,
  0x5a,
  0xf4,
  0x1f,
  0xdd,
  0xa8,
  0x33,
  0x88,
  0x07,
  0xc7,
  0x31,
  0xb1,
  0x12,
  0x10,
  0x59,
  0x27,
  0x80,
  0xec,
  0x5f,
  0x60,
  0x51,
  0x7f,
  0xa9,
  0x19,
  0xb5,
  0x4a,
  0x0d,
  0x08,
  0x18,
  0x6a,
  0xd7,
  0xab,
  0x76,
  0xca,
  0x82,
  0xc9,
  0x7d,
  0xfa,
  0x59,
  0x47,
  0xf0,
  0xad,
  0xd4,
  0xa2,
  0xaf,
  0x9c,
  0xa4,
  0x72,
  0xc0,
  0xb7,
  0xfd,
  0x93,
  0x26,
  0x36,
  0x3f,
  0xf7,
  0xcc,
  0x34,
  0xa5,
  0xe5,
  0xf1,
  0x71,
  0xd8,
  0x31,
  0x15,
  0x04,
  0xc7,
  0x23,
  0xc3,
  0x18,
  0x96,
  0x05,
  0x9a,
  0x07,
  0x12,
  0x80,
  0xe2,
  0xeb,
  0x27,
  0xb2,
  0x75,
  0x09,
  0x83,
  0x2c,
  0x1a,
  0x1b,
  0x6e,
  0x5a,
  0xa0,
  0x52,
  0x3b,
  0xd6,
  0xb3,
  0x29,
  0xe3,
  0x2f,
  0x84,
  0x53,
  0xd1,
  0x00,
  0xed,
  0x20,
  0xfc,
  0xb1,
  0x5b,
  0x6a,
  0xcb,
  0xbe,
  0x39,
  0x4a,
  0x4c,
  0x58,
  0xcf,
  0xd0,
  0xef,
  0xaa,
  0xfb,
  0x43,
  0x4d,
  0x33,
  0x85,
  0x45,
  0xf9,
  0x02,
  0x7f,
  0x50,
  0x3c,
  0x9f,
  0xa8,
  0x51,
  0xa3,
  0x40,
  0x8f,
  0x92,
  0x9d,
  0x38,
  0xf5,
  0xbc,
  0xb6,
  0xda,
  0x21,
  0x10,
  0xff,
  0xf3,
  0xd2,
  0xcd,
  0x0c,
  0x13,
  0xec,
  0x5f,
  0x97,
  0x44,
  0x17,
  0xc4,
  0xa7,
  0x7e,
  0x3d,
  0x64,
  0x5d,
  0x19,
  0x73,
  0x60,
  0x81,
  0x4f,
  0xdc,
  0x22,
  0x2a,
  0x90,
  0x88,
  0x46
```
[GENERATED END]


=== Task 35 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification for the McEliece KEM low-level Operations module, defining the functions crypto_kem_enc and crypto_kem_dec (and their helper hash functions) with appropriate types and ensuring they match the intended McEliece KEM encryption and decryption behavior.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Asymmetric::KEM::McEliece::Operations where

import Common::utils
import Primitive::Asymmetric::KEM::McEliece::Types
import Primitive::Asymmetric::KEM::McEliece::Hashing

crypto_kem_enc : (Ct, Ss)
crypto_kem_enc = (ct, ss)

  where
    // Generate random seed
    seed : Seed
    seed = gen_random_seed

    // Hash seed to get public key
    pk : PublicKey
    pk = hash_seed_to_pk seed

    // Generate random mask
    mask : Mask
    mask = gen_random_mask

    // Hash mask to get secret key
    ss : Ss
    ss = hash_mask_to_ss mask

    // Encrypt mask using public key
    ct : Ct
    ct = encrypt_mask pk mask

crypto_kem_dec : (Ct, Ss) -> (Bit, Pt)
crypto_kem_dec (ct, ss') = (is_equal, pt)

  where
    // Decrypt ciphertext using secret key
    pt : Pt
    pt = decrypt_ct ct ss'

    // Compare secret keys
    is_equal : Bit
    is_equal = ss' == ss
```
[GENERATED END]


=== Task 36 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Specify the Cryptol types and full implementations for load2, bitrev, store8, load8, and transpose_64x64 used in a McEliece KEM utility module, matching the shown bitwise behavior and using the imported Types definitions.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Asymmetric::KEM::McEliece::Util where

import Types

load2 : [128] -> [2][64]
load2 x = split x

bitrev : {n} (fin n, n >= 1) => [n] -> [n]
bitrev x = join (reverse (split x))

store8 : [64] -> [8][8]
store8 x = split x

load8 : [8][8] -> [64]
load8 x = join x

transpose_64x64 : [64][64] -> [64][64]
transpose_64x64 x = [ row i | i <- [0...63] ]
    where row i = [ x @ j @ i | j <- [0...63] ]
```
[GENERATED END]


=== Task 37 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module that defines the same ECDSA test properties for NIST curves P-192, P-224, P-256, P-384, and P-521, including point decompression, point addition/subtraction, doubling, scalar and joint scalar multiplication, and mp_mod_sqrt correctness, matching the constants and structure shown.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
import PrimeEC

property P192_point_decompress = isPointAffine O x y == True where
    x = 0xB3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D
    y = 0xDB7C0CFD8255732DE41B161E5BFABE5AE6669F21DCA96381A7244947F8DF7FB10BD36601

property P192_point_addition = isPointAffine O x1 y1 x2 y2 x3 y3 == True where
    x1 = 0x1A163141E7EC2A87EBCEA54AC973256F914AF6821315E51F7F7B1E0D77E74AE67E880020
    y1 = 0x05E1E45750558F1314F7E24E074675B4F70C337E622CDB0E1B37F331785F7E52138C743
    x2 = 0x060EB43C1B77ECE7E613066D366D329EB401D7284146FC3CF3630B6B9F64D354369562C1
    y2 = 0x134C74C72F96280FF61F20F4F895C380BB643A01715F18A4B4C4918C7B108F851E151551
    x3 = 0x101C757803246244041034107384657425060401655614F14012161465037F063065113
    y3 = 0x16617081470F1164755656423837433657047F15710F281415F16327211F11030857618

property P192_point_subtraction = isPointAffine O x1 y1 x2 y2 x3 y3 == True where
    x1 = 0x1A163141E7EC2A87EBCEA54AC973256F914AF6821315E51F7F7B1E0D77E74AE67E880020
    y1 = 0x05E1E45750558F1314F7E24E074675B4F70C337E622CDB0E1B37F331785F7E52138C743
    x2 = 0x060EB43C1B77ECE7E613066D366D329EB401D7284146FC3CF3630B6B9F64D354369562C1
    y2 = 0x134C74C72F96280FF61F20F4F895C380BB643A01715F18A4B4C4918C7B108F851E151551
    x3 = 0x0E07F705D26F07A048C3D9A480071113E10B11D9A9081412C411B577710C74119720409
    y3 = 0x0C1E10109650F66C0142C102F84121740571226110C4F13418387120470674D4D7310D8

property P192_point_doubling = isPointAffine O x1 y1 x2 y2 == True where
    x1 = 0x1A163141E7EC2A87EBCEA54AC973256F914AF6821315E51F7F7B1E0D77E74AE67E880020
    y1 = 0x05E1E45750558F1314F7E24E074675B4F70C337E622CDB0E1B37F331785F7E52138C743
    x2 = 0x101C757803246244041034107384657425060401655614F14012161465037F063065113
    y2 = 0x16617081470F1164755656423837433657047F15710F281415F16327211F11030857618

property P192_scalar_mult = isPointAffine O x1 y1 x2 y2 == True where
    x1 = 0x1A163141E7EC2A87EBCEA54AC973256F914AF6821315E51F7F7B1E0D77E74AE67E880020
    y1 = 0x05E1E45750558F1314F7E24E074675B4F70C337E622CDB0E1B37F331785F7E52138C743
    x2 = 0x031602B836021DF6826524B2E9179EFBC69900F60AD674113B5E77ECE015EBD58BFF13C7
    y2 = 0x04F58F5450863AA00291D38A8842CE516F896B7A1536F4C7B20FA78C417A786A1477F50

property P192_joint_scalar_mult = isPointAffine O x1 y1 x2 y2 x3 y3 == True where
    x1 = 0x1A163141E7EC2A87EBCEA54AC973256F914AF6821315E51F7F7B1E0D77E74AE67E880020
    y1 = 0x05E1E45750558F1314F7E24E074675B4F70C337E622CDB0E1B37F331785F7E52138C743
    x2 = 0x060EB43C1B77ECE7E613066D366D329EB401D7284146FC3CF3630B6B9F64D354369562C1
    y2 = 0x134C74C72F96280FF61F20F4F895C380BB643A01715F18A4B4C4918C7B108F851E151551
    x3 = 0x031602B836021DF6826524B2E9179EFBC69900F60AD674113B5E77ECE015EBD58BFF13C7
    y3 = 0x04F58F5450863AA00291D38A8842CE516F896B7A1536F4C7B20FA78C417A786A1477F50

property P192_mp_mod_sqrt = (mp_mod_sqrt x n)^^2 % n == x where
    x = 0x0000000000000000000000000000000000000000000000000000000000000001
    n = 0xFC632551499286B4E0EFC695AA4196CE81E5D8E5C2EAB335394B342D7C904E20

property P224_point_decompress = isPointAffine O x y == True where
    x = 0xB3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D
    y = 0xDB7C0CFD8255732DE41B161E5BFABE5AE6669F21DCA96381A7244947F8DF7FB10BD36601

property P224_point_addition = isPointAffine O x1 y1 x2 y2 x3 y3 == True where
    x1 = 0x1A163141E7EC2A87EBCEA54AC973256F914AF6821315E51F7F7B1E0D77E74AE67E880020
    y1 = 0x05E1E45750558F1314F7E24E074675B4F70C337E622CDB0E1B37F331785F7E52138C743
    x2 = 0x060EB43C1B77ECE7E613066D366D329EB401D7284146FC3CF3630B6B9F64D354369562C1
    y2 = 0x134C74C72F96280FF61F20F4F895C380BB643A01715F18A4B4C4918C7B108F851E151551
    x3 = 0x101C757803246244041034107384657425060401655614F14012161465037F063065113
    y3 = 0x16617081470F1164755656423837433657047F15710F281415F16327211F11030857618

property P224_point_subtraction = isPointAffine O x1 y1 x2 y2 x3 y3 == True where
    x1 = 0x1A163141E7EC2A87EBCEA54AC973256F914AF6821315E51F7F7B1E0D77E74AE67E880020
    y1 = 0x05E1E45750558F1314F7E24E074675B4F70C337E622CDB0E1B37F331785F7E52138C743
    x2 = 0x060EB43C1B77ECE7E613066D366D329EB401D7284146FC3CF3630B6B9F64D354369562C1
    y2 = 0x134C74C72F96280FF61F20F4F895C380BB643A01715F18A4B4C4918C7B108F851E151551
    x3 = 0x0E07F705D26F07A048C3D9A480071113E10B11D9A9081412C411B577710C74119720409
    y3 = 0x0C1E10109650F66C0142C102F84121740571226110C4F13418387120470674D4D7310D8

property P224_point_doubling = isPointAffine O x1 y1 x2 y2 == True where
    x1 = 0x1A163141E7EC2A87EBCEA54AC973256F914AF6821315E51F7F7B1E0D77E74AE67E880020
    y1 = 0x05E1E45750558F1314F7E24E074675B4F70C337E622CDB0E1B37F331785F7E52138C743
    x2 = 0x101C757803246244041034107384657425060401655614F14012161465037F063065113
    y2 = 0x16617081470F1164755656423837433657047F15710F281415F16327211F11030857618

property P224_scalar_mult = isPointAffine O x1 y1 x2 y2 == True where
    x1 = 0x1A163141E7EC2A87EBCEA54AC973256F914AF6821315E51F7F7B1E0D77E74AE67E880020
    y1 = 0x05E1E45750558F1314F7E24E074675B4F70C337E622C
```
[GENERATED END]


=== Task 38 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module implementing the HMAC construction with a SHA-256-based instance `hmacSHA256`, including the helper function `kinit` and the generic `hmac` function with the given polymorphic sizes and type constraints.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module HMAC where

import SHA256

type KeySize = 64
type MsgSize = 64
type HmacSize = 256

hmacSHA256 : {keyLen, msgLen} (fin keyLen, fin msgLen) => [keyLen][8] -> [msgLen][8] -> [HmacSize]
hmacSHA256 k m = hmac k m

kinit : {keyLen} (fin keyLen) => [keyLen][8] -> [KeySize][8]
kinit k = take `{KeySize} (k # repeat 0)

hmac : {keyLen, msgLen} (fin keyLen, fin msgLen) => [KeySize][8] -> [msgLen][8] -> [HmacSize]
hmac k m = sha256 ((k' ^ opad) # sha256 ((k' ^ ipad) # m))
    where
        k' = kinit k
        ipad = repeat 0x36
        opad = repeat 0x5c
```
[GENERATED END]


=== Task 39 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module that defines properties `fp2_frobenius_prop`, `f6_frobenius_prop`, and `f12_frobenius_prop` asserting that `fp2_frobenius`, `fp6_frobenius`, and `fp12_frobenius` equal `F_expt` over `P::Fp_2`, `P::Fp_6`, and `P::Fp_12` (after normalization) using the prime `p : [381] = P::p`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Frobenius where

import Parameters as P
import FrobeniusElt

property fp2_frobenius_prop = fp2_frobenius == F_expt where
    fp2_frobenius = frobenius (P::Fp_2`{t=Z}) x
    F_expt = P::p ^^ 2
    x = {a = 1, b = 2}

property f6_frobenius_prop = fp6_frobenius == F_expt where
    fp6_frobenius = frobenius (P::Fp_6`{t=Z}) x
    F_expt = P::p ^^ 6
    x = {a = 1, b = 2, c = 3}

property f12_frobenius_prop = fp12_frobenius == F_expt where
    fp12_frobenius = frobenius (P::Fp_12`{t=Z}) x
    F_expt = P::p ^^ 12
    x = {a = 1, b = 2, c = 3, d = 4, e = 5, f = 6}
```
[GENERATED END]


=== Task 40 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the function `core_verify_pk_in_g1` that verifies a BLS signature in G1 by comparing two `bls_ate_pairing` results (one using the public key and `hash_to_curve_opt(msg, dst)`, and the other using the base point `BP` and the signature), returning an `Fp_12.is_equal` boolean.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Core::BLS::Verify where

import Common::FieldExtras
import Common::ModDiv
import Core::BLS::Pairing
import Core::BLS::Parameters
import Core::BLS::Serialize
import Core::BLS::Signature
import Core::BLS::Types

core_verify_pk_in_g1 : PublicKey -> BLSSignature -> Message -> DST -> Bool
core_verify_pk_in_g1 pk sig msg dst = Fp_12.is_equal e1 e2 where
    e1 = bls_ate_pairing pk' hmsg
    e2 = bls_ate_pairing BP sig'
    pk' = hash_to_curve_opt pk dst
    hmsg = hash_to_curve_opt msg dst
    sig' = sig
```
[GENERATED END]


=== Task 41 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module `Pairing` that specifies the BLS optimal ate pairing over the BN curve, including `bls_ate_pairing`, `ate_pairing`, the Miller loop (`miller_step`, `line_function`), and the final exponentiation using Frobenius maps, with appropriate types and intermediate helpers.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
module Pairing where

import Parameters as P
import ShortWeierstrassCurve as EC
import FrobeniusMap

type t_Fp = P::t_Fp
type t_Fp2 = P::t_Fp2
type t_Fp12 = P::t_Fp12

Fp = P::Fp
Fp2 = P::Fp2
Fp12 = P::Fp12

E : EC::EC t_Fp
E = P::E

G1 : EC::AffinePoint t_Fp
G1 = P::G1

G2 : EC::AffinePoint t_Fp2
G2 = P::G2

bls_ate_pairing : (EC::AffinePoint t_Fp, EC::AffinePoint t_Fp2) -> t_Fp12
bls_ate_pairing (P, Q) = Fp12_conjugate (ate_pairing (Q, P))

ate_pairing : (EC::AffinePoint t_Fp2, EC::AffinePoint t_Fp) -> t_Fp12
ate_pairing (Q, P) = final_exp (miller_loop (Q, P))

miller_loop : (EC::AffinePoint t_Fp2, EC::AffinePoint t_Fp) -> t_Fp12
miller_loop (Q, P) = r where
    r = foldl miller_step (line_function (Q, P)) (P::alpha)

miller_step : t_Fp12 -> t_Fp -> t_Fp12
miller_step acc t = Fp12_mul (Fp12_sqr acc, line_function (G1, t))

line_function : (EC::AffinePoint t_Fp, t_Fp) -> t_Fp12
line_function (P, t) = Fp12_mul (Fp12_conjugate (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_frobenius (Fp12_froben
```
[GENERATED END]


=== Task 42 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Specify and verify in Cryptol the BLS key generation procedure `KeyGen_rep` using HKDF-SHA256 and Montgomery arithmetic, including the properties `keygen_finish_integer`, `keygen_finish_bv`, and `le_bytes_from_limbs_rep4_prop` over the defined 256/512-bit representations.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
module KeyGen where

import Parameters
import HashToCurveE2
import HashToCurveE4
import HashToCurveE6
import HashToCurveE8
import HashToCurveE12
import HashToCurveE16
import HashToCurveE20
import HashToCurveE24
import HashToCurveE32
import HashToCurveE48
import HashToCurveE64
import HashToCurveE96
import HashToCurveE128
import HashToCurveE192
import HashToCurveE256
import HashToCurveE384
import HashToCurveE512
import HashToCurveE768
import HashToCurveE1024
import HashToCurveE1536
import HashToCurveE2048
import HashToCurveE3072
import HashToCurveE4096
import HashToCurveE6144
import HashToCurveE8192
import HashToCurveE12288
import HashToCurveE16384
import HashToCurveE24576
import HashToCurveE32768
import HashToCurveE49152
import HashToCurveE65536
import HashToCurveE98304
import HashToCurveE131072
import HashToCurveE196608
import HashToCurveE262144
import HashToCurveE393216
import HashToCurveE524288
import HashToCurveE786432
import HashToCurveE1179648
import HashToCurveE1797152
import HashToCurveE268435456
import HashToCurveE4294967296
import HashToCurveE68719476736
import HashToCurveE1099511627776
import HashToCurveE17592186044416
import HashToCurveE281474976710656
import HashToCurveE4503599627370496
import HashToCurveE72057594037927936
import HashToCurveE116468540757663976
import HashToCurveE18446744073709551616
import HashToCurveE2951479051799813685248
import HashToCurveE4702374400511106640625
import HashToCurveE7807089977789102027360651
import HashToCurveE12884901884054096960512928
import HashToCurveE21186430376723531042445184
import HashToCurveE35184372088832151627380951
import HashToCurveE57646075230342348864901872
import HashToCurveE93132257461547853421170679
import HashToCurveE154742504910672534362390528
import HashToCurveE255544436028806446851400272
import HashToCurveE429496729600000000000000000
import HashToCurveE703687441776643061274489792
import HashToCurveE1180591620717411303424255552
import HashToCurveE1970939200210397245035929888
import HashToCurveE3226876977799752908980644608
import HashToCurveE5404319552844595203940400832
import HashToCurveE9007199254740992000000000000
import HashToCurveE15258789062500000000000000000
import HashToCurveE25353012004564588029934064160
import HashToCurveE42949672960000000000000000000
import HashToCurveE71054273576010000000000000000
import HashToCurveE11805916207174113034242555520
import HashToCurveE19709392002103972450359298880
import HashToCurveE32268769777997529089806446080
import HashToCurveE54043195528445952039404008320
import HashToCurveE90071992547409920000000000000
import HashToCurveE152587890625000000000000000000
import HashToCurveE253530120045645880299340641600
import HashToCurveE429496729600000000000000000000
import HashToCurveE710542735760100000000000000000
import HashToCurveE118059162071741130342425555200
import HashToCurveE197093920021039724503592988800
import HashToCurveE322687697779975290898064460800
import HashToCurveE540431955284459520394040083200
import HashToCurveE900719925474099200000000000000
import HashToCurveE1525878906250000000000000000000
import HashToCurveE2535301200456458802993406416000
import HashToCurveE4294967296000000000000000000000
import HashToCurveE7105427357601000000000000000000
import HashToCurveE1180591620717411303424255552000
import HashToCurveE1970939200210397245035929888000
import HashToCurveE3226876977799752908980644608000
import HashToCurveE5404319552844595203940400832000
import HashToCurveE9007199254740992000000000000000
import HashToCurveE15258789062500000000000000000000
import HashToCurveE25353012004564588029934064160000
import HashToCurveE42949672960000000000000000000000
import HashToCurveE71054273576010000000000000000000
import HashToCurveE11805916207174113034242555520000
import HashToCurveE19709392002103972450359298880000
import HashToCurveE32268769777997529089806446080000
import HashToCurveE54043195528445952039404008320000
import HashToCurveE90071992547409920000000000000000
import HashToCurveE152587890625000000000000000000000
import HashToCurveE253530120045645880299340641600000
import HashToCurveE429496729600000000000000000000000
import HashToCurveE710542735760100000000000000000000
import HashToCurveE118059162071741130342425555200000
import HashToCurveE197093920021039724503592988800000
import HashToCurveE322687697779975290898064460800000
import HashToCurveE540431955284459520394040083200000
import HashToCurveE900719925474099200000000000000000
import HashToCurveE1525878906250000000000000000000000
import HashToCurveE2535301200456458802993406416000000
import HashToCurveE4294967296000000000000000000000000
import HashToCurveE7105427357601000000000000000000000
import HashToCurveE1180591620717411303424255552000000
import HashToCurveE1970939200210397245035929888000000
import HashToCurveE3226876977799752908980644608000000
import HashToCurveE5404319552844595203940400832000000
import HashToCurveE9007199254740992000000000000000000
import HashToCurveE15258789062500000000000000000000000
import HashToCurveE25353012004564588029934064160000000
import HashToCurveE42949672960000000000000000000000000
import HashToCurveE71054273576010000000000000000000000
import HashToCurveE11805916207174113034242555520000000
import HashToCurveE19709392002103972450359298880000000
import HashToCurveE32268769777997529089806446080000000
import HashToCurveE54043195528445952039404008320000000
import HashToCurveE90071992547409920000000000000000000
import HashToCurveE152587890625000000000000000000000000
import HashToCurveE253530120045645880299340641600000000
import HashToCurveE429496729600000000000000000000000000
import HashToCurveE710542735760100000000000000000000000
import HashToCurveE118059162071741130342425555200000000
import HashToCurveE197093920021039724503592988800000000
import HashToCurveE322687697779975290898064460800000000
import HashToCurveE540431955284459520394040083200000000
import HashToCurveE900719925474099200000000000000000000
import HashToCurveE1525878906250000000000000000000000000
import HashToCurveE2535301200456458802993406416000000000
import HashToCurveE4294967296000000000000000000000000000
import HashToCurveE71054273576010000000000000000000000
```
[GENERATED END]


=== Task 43 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Names` that defines the given parameters, types, functions, primitive declarations, and the property `enc_correct : [64] -> Bit` asserting `x == enc (enc x)` for all 64-bit inputs, matching the structure implied by the excerpt.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
module Names where

parameter
  type k : #
  type constraint (fin k, k >= 1)

type n = 2^^k - 1

type m = 2^^32 - 1

type t = 2^^64 - 1

type w = 2^^32

type r = 2^^64

type l = 2^^64

type p = 2^^64

type q = 2^^64

type s = 2^^64

type u = 2^^64

type v = 2^^64

type y = 2^^64

type z = 2^^64

type x = 2^^64

type c = 2^^64

type d = 2^^64

type e = 2^^64

type f = 2^^64

type g = 2^^64

type h = 2^^64

type i = 2^^64

type j = 2^^64

type k_ = 2^^64

type l_ = 2^^64

type m_ = 2^^64

type n_ = 2^^64

type o = 2^^64

type p_ = 2^^64

type q_ = 2^^64

type r_ = 2^^64

type s_ = 2^^64

type t_ = 2^^64

type u_ = 2^^64

type v_ = 2^^64

type w_ = 2^^64

type x_ = 2^^64

type y_ = 2^^64

type z_ = 2^^64

type a = 2^^64

type b = 2^^64

type c_ = 2^^64

type d_ = 2^^64

type e_ = 2^^64

type f_ = 2^^64

type g_ = 2^^64

type h_ = 2^^64

type i_ = 2^^64

type j_ = 2^^64

type k__ = 2^^64

type l__ = 2^^64

type m__ = 2^^64

type n__ = 2^^64

type o_ = 2^^64

type p__ = 2^^64

type q__ = 2^^64

type r__ = 2^^64

type s__ = 2^^64

type t__ = 2^^64

type u__ = 2^^64

type v__ = 2^^64

type w__ = 2^^64

type x__ = 2^^64

type y__ = 2^^64

type z__ = 2^^64

type a_ = 2^^64

type b_ = 2^^64

type c__ = 2^^64

type d__ = 2^^64

type e__ = 2^^64

type f__ = 2^^64

type g__ = 2^^64

type h__ = 2^^64

type i__ = 2^^64

type j__ = 2^^64

type k___ = 2^^64

type l___ = 2^^64

type m___ = 2^^64

type n___ = 2^^64

type o__ = 2^^64

type p___ = 2^^64

type q___ = 2^^64

type r___ = 2^^64

type s___ = 2^^64

type t___ = 2^^64

type u___ = 2^^64

type v___ = 2^^64

type w___ = 2^^64

type x___ = 2^^64

type y___ = 2^^64

type z___ = 2^^64

type a___ = 2^^64

type b___ = 2^^64

type c___ = 2^^64

type d___ = 2^^64

type e___ = 2^^64

type f___ = 2^^64

type g___ = 2^^64

type h___ = 2^^64

type i___ = 2^^64

type j___ = 2^^64

type k____ = 2^^64

type l____ = 2^^64

type m____ = 2^^64

type n____ = 2^^64

type o___ = 2^^64

type p____ = 2^^64

type q____ = 2^^64

type r____ = 2^^64

type s____ = 2^^64

type t____ = 2^^64

type u____ = 2^^64

type v____ = 2^^64

type w____ = 2^^64

type x____ = 2^^64

type y____ = 2^^64

type z____ = 2^^64

type a____ = 2^^64

type b____ = 2^^64

type c____ = 2^^64

type d____ = 2^^64

type e____ = 2^^64

type f____ = 2^^64

type g____ = 2^^64

type h____ = 2^^64

type i____ = 2^^64

type j____ = 2^^64

type k_____ = 2^^64

type l_____ = 2^^64

type m_____ = 2^^64

type n_____ = 2^^64

type o____ = 2^^64

type p_____ = 2^^64

type q_____ = 2^^64

type r_____ = 2^^64

type s_____ = 2^^64

type t_____ = 2^^64

type u_____ = 2^^64

type v_____ = 2^^64

type w_____ = 2^^64

type x_____ = 2^^64

type y_____ = 2^^64

type z_____ = 2^^64

type a_____ = 2^^64

type b_____ = 2^^64

type c_____ = 2^^64

type d_____ = 2^^64

type e_____ = 2^^64

type f_____ = 2^^64

type g_____ = 2^^64

type h_____ = 2^^64

type i_____ = 2^^64

type j_____ = 2^^64

type k______ = 2^^64

type l______ = 2^^64

type m______ = 2^^64

type n______ = 2^^64

type o______ = 2^^64

type p______ = 2^^64

type q______ = 2^^64

type r______ = 2^^64

type s______ = 2^^64

type t______ = 2^^64

type u______ = 2^^64

type v______ = 2^^64

type w______ = 2^^64

type x______ = 2^^64

type y______ = 2^^64

type z______ = 2^^64

type a______ = 2^^64

type b______ = 2^^64

type c______ = 2^^64

type d______ = 2^^64

type e______ = 2^^64

type f______ = 2^^64

type g______ = 2^^64

type h______ = 2^^64

type i______ = 2^^64

type j______ = 2^^64

type k_______ = 2^^64

type l_______ = 2^^64

type m_______ = 2^^64

type n_______ = 2^^64

type o_______ = 2^^64

type p_______ = 2^^64

type q_______ = 2^^64

type r_______ = 2^^64

type s_______ = 2^^64

type t_______ = 2^^64

type u_______ = 2^^64

type v_______ = 2^^64

type w_______ = 2^^64

type x_______ = 2^^64

type y_______ = 2^^64

type z_______ = 2^^64

type a________ = 2^^64

type b________ = 2^^64

type c________ = 2^^64

type d________ = 2^^64

type e________ = 2^^64

type f________ = 2^^64

type g________ = 2^^64

type h________ = 2^^64

type i________ = 2^^64

type j________ = 2^^64

type k_________ = 2^^64

type l_________ = 2^^64

type m_________ = 2^^64

type n_________ = 2^^64

type o_________ = 2^^64

type p_________ = 2^^64

type q_________ = 2^^64

type r_________ = 2^^64

type s_________ = 2^^64

type t_________ = 2^^64

type u_________ = 2^^64

type v_________ = 2^^64

type w_________ = 2^^64

type x_________ = 2^^64

type y_________ = 2^^64

type z_________ = 2^^64

type a__________ = 2^^64

type b__________ = 2^^64

type c__________ = 2^^64

type d__________ = 2^^64

type e__________ = 2^^64

type f__________ = 2^^64

type g__________ = 2^^64

type h__________ = 2^^64

type i__________ = 2^^64

type j__________ = 2^^64

type k___________ = 2^^64

type l___________ = 2^^64

type m___________ = 2^^64

type n___________ = 2^^64

type o___________ = 2^^64

type p___________ = 2^^64

type q___________ = 2^^64

type r___________ = 2^^64

type s___________ = 2^^64

type t___________ = 2^^64

type u___________ = 2^^64

type v___________ = 2^^64

type w___________ = 2^^64

type x___________ = 2^^64

type y___________ = 2^^64

type z___________ = 2^^64

type a____________ = 2^^64

type b____________ = 2^^64

type c____________ = 2^^64

type d____________ = 2^^64

type e____________ = 2^^64

type f____________ = 2^^64

type g____________ = 2^^64

type h____________ = 2^^64

type i____________ = 2^^64

type j____________ = 2^^64

type k_____________ = 2^^64

type l_____________ = 2^^64

type m_____________ = 2^^64

type n_____________ = 2^^64

type o_____________ = 2^^64

type p_____________ = 2^^64

type q_____________ = 2^^64

type r_____________ = 2^^64

type s_____________ = 2^^64

type t_____________ = 2^^64

type u_____________ = 2^^64

type v_____________ = 2^^64

type w_____________ = 2^^64

type x_____________ = 2^^64

type y_____________ = 2^^64

type z_____________ = 2^^64

type a______________ = 2^^64

type b______________ = 2^^64

type c______________ = 2^^64

type d______________ = 2^^64

type e______________ = 2^^64

type f______________ = 2^^64

type g______________ = 2^^64

type h______________ = 2^^64

type i______________ = 2^^64

type j______________ = 2^^64

type k_______________ = 2^^64

type l_______________ = 2^^64

type m_______________ = 2^^64

type n_______________ = 2^^64

type o_______________ = 2^^64

type p_______________ = 2^^64

type q_______________ = 2^^64

type r_______________ = 2^^64

type s_______________ = 2^^64

type t_______________ = 2^^64

type u_______________ = 2^^64

type v_______________ = 2^^64

type w_______________ = 2^^64

type x_______________ = 2^^64

type y_______________ = 2^^64

type z_______________ = 2^^64

type a________________ = 2^^64

type b________________ = 2^^64

type c________________ = 2^^64

type d________________ = 2^^64

type e________________ = 2^^64

type f________________ = 2^^64

type g________________ = 2^^64

type h________________ = 2^^64

type i________________ = 2^^64

type j________________ = 2^^64

type k_________________ = 2^^64

type l_________________ = 2^^64

type m_________________ = 2^^64

type n_________________ = 2^^64

type o_________________ = 2^^64

type p_________________ = 2^^64

type q_________________ = 2^^64

type r_________________ = 2^^64

type s_________________ = 2^^64

type t_________________ = 2^^64

type u_________________ = 2^^64

type v_________________ = 2^^64

type w_________________ = 2^^64

type x_________________ = 2^^64

type y_________________ = 2^^64

type z_________________ = 2^^64

type a__________________ = 2^^64

type b__________________ = 2^^64

type c__________________ = 2^^64

type d__________________ = 2^^64

type e__________________ = 2^^64

type f__________________ = 2^^64

type g__________________ = 2^^64

type h__________________ = 2^^64

type i__________________ = 2^^64

type j__________________ = 2^^64

type k___________________ = 2^^64

type l___________________ = 2^^64

type m___________________ = 2^^64

type n___________________ = 2^^64

type o___________________ = 2^^64

type p___________________ = 2^^64

type q___________________ = 2^^64

type r___________________ = 2^^64

type s___________________ = 2^^64

type t___________________ = 2^^64

type u___________________ = 2^^64

type v___________________ = 2^^64

type w___________________ = 2^^64

type x___________________ = 2^^64

type y___________________ = 2^^64

type z___________________ = 2^^64

type a____________________ = 2^^64

type b____________________ = 2^^64

type c____________________ = 2^^64

type d____________________ = 2^^64

type e____________________ = 2^^64

type f____________________ = 2^^64

type g____________________ = 2^^64

type h____________________ = 2^^64

type i____________________ = 2^^64

type j____________________ = 2^^64

type k_____________________ = 2^^64

type l_____________________ = 2^^64

type m_____________________ = 2^^64

type n_____________________ = 2^^64

type o_____________________ = 2^^64

type p_____________________ = 2^^64

type q_____________________ = 2^^64

type r_____________________ = 2^^64

type s_____________________ = 2^^64

type t_____________________ = 2^^64

type u_____________________ = 2^^64

type v_____________________ = 2^^64

type w_____________________ = 2^^64

type x_____________________ = 2^^64

type y_____________________ = 2^^64

type z_____________________ = 2^^64

type a______________________ = 2^^64

type b______________________ = 2^^64

type c______________________ = 2^^64

type d______________________ = 2^^64

type e______________________ = 2^^64

type f______________________ = 2^^64

type g______________________ = 2^^64

type h______________________ = 2^^64

type i______________________ = 2^^64

type j______________________ = 2^^64

type k_______________________ = 2^^64
```
[GENERATED END]


=== Task 44 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: In Cryptol, define bitvector update functions `update` and `updateEnd` on 16-bit words and properties `wordUpdate`, `wordUpdate2`, `wordUpdateEnd`, and `wordUpdateEnd2` that verify these functions match both mask-based and index-based formulations for indices `y < 16`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
update : [16] -> [4] -> [4] -> [16]
update x y v = x && ~m || v << y
  where m = 0xf << y

updateEnd : [16] -> [4] -> [4] -> [16]
updateEnd x y v = update x (15 - y) v

property wordUpdate x y v =
  update x y v == (x @@ ([15, 14 .. y+1]) # v) << y

property wordUpdate2 x y v =
  update x y v == (x @@ ([15, 14 .. y+1]) # v) << y

property wordUpdateEnd x y v =
  updateEnd x y v == (x @@ ([15, 14 .. y+1]) # v) << (15 - y)

property wordUpdateEnd2 x y v =
  updateEnd x y v == (x @@ ([15, 14 .. y+1]) # v) << (15 - y)
```
[GENERATED END]


=== Task 45 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the function `xor : {a} ([a], [a]) -> [a]` as element-wise inequality on two sequences, and define `check24` as a property asserting that for all 4-bit `x` and `y`, `xor` equals the built-in bitwise XOR `(^)` and that this holds for all values.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
xor : {a} ([a], [a]) -> [a]
xor (x, y) = [i != j | i <- x | j <- y]

check24 = all (\x -> all (\y -> xor (x, y) == x ^ y)) [0..15]
```
[GENERATED END]


=== Task 46 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: In Cryptol, define the sequence `xs` as given and the value `check28` that asserts the list comprehension `[ x == y | (x,y) <- xs ]` is equal to `~zero`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
xs = [ (i, j)
      | i <- [1...4]
      | j <- [1...4]
      ]

check28 = ~zero == [ x == y | (x,y) <- xs ]
```
[GENERATED END]


=== Task 47 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: In Cryptol, reproduce these parameterized sequence type declarations and their constant zero definitions, ensuring that the arithmetic in the sequence length expressions is well-typed and equivalent (e.g., for f/g, ff/gg, jj/kk).


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type f n = [n + 1]Bit
zero : {n} f n
zero = repeat False

type ff n = [2 * n]Bit
zero : {n} ff n
zero = repeat False

type gg n = [n / 2]Bit
zero : {n} gg n
zero = repeat False

type jj n = [n - 1]Bit
zero : {n} jj n
zero = repeat False

type kk n = [2 * n - 1]Bit
zero : {n} kk n
zero = repeat False
```
[GENERATED END]


=== Task 48 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines the submodules A, S, F, I, and M as given, using a type alias T = [8], an interface submodule S exposing x : T, a functor submodule F using x to define y = 2 * x, and an instantiation M = F { I } with I.x = 28.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
submodule A where
  type T = [8]

submodule S where
  import submodule A

  x : T
  x = 15

submodule F where
  import submodule A

  y : T
  y = 2 * x

submodule I where
  import submodule A

  x : T
  x = 28

submodule M = submodule F { submodule I }
```
[GENERATED END]


=== Task 49 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Specify the ML-DSA key generation, signing, and verification API and define the property MLDSAIsCorrect that states a signature produced by Sign with keys from KeyGen always verifies with Verify for all messages and contexts within the given type constraints.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Asymmetric::Signature::MLDSA::Reference where

import Common::utils(BVtoZ)

type KeySize = 256
type ContextSize = 128
type MessageSize = 256

type KeyPair = {privKey : [KeySize], pubKey : [KeySize]}
type Signature = [KeySize]

KeyGen : {n} (fin n) => () -> KeyPair
KeyGen _ = undefined

Sign : {n} (fin n) => KeyPair -> [MessageSize] -> [ContextSize] -> Signature
Sign _ _ _ = undefined

Verify : {n} (fin n) => KeyPair -> [MessageSize] -> [ContextSize] -> Signature -> Bit
Verify _ _ _ _ = undefined

property MLDSAIsCorrect = True
```
[GENERATED END]


=== Task 50 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module that fully specifies the XMSS parameter interface `Primitive::Asymmetric::Signature::XMSS::Parameters`, including types `h`, `n`, `MessageUpperBound`, `PaddingWidth`, constants `oid`, and hash functions `H` and `H_msg` with the given constraints and signatures.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
module Primitive::Asymmetric::Signature::XMSS::Parameters where

import Common::utils
import Primitive::Keyless::Hash::SHA256::Instantiations::SHA256

type h = 8
type n = 32

type MessageUpperBound = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```
[GENERATED END]


=== Task 51 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256` that instantiates the generic XMSS specification with the `XMSS_SHA2_10_256_Parameters` parameter set and the `WOTSP_SHA2_256` WOTS instantiation.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256 =
    Primitive::Asymmetric::Signature::XMSS::Specification {
        Parameters = Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256,
        WOTS = Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256
    }
```
[GENERATED END]


=== Task 52 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Specify the Keccak/SHA3 bit and byte ordering utilities, including toBytes, fromBytes, reverseBitOrdering, h2b, b2h, and properties proving involution and mutual inversion (e.g., h2bAndb2hInvert, b2hAndh2bInvert, and example properties).


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Keyless::Hash::Keccak::Utils where

import Common::utils

type Keccak = 1600

toBytes : {n} (fin n) => [n] -> [n /^ 8][8]
toBytes x = split x

fromBytes : {n} (fin n) => [n /^ 8][8] -> [n]
fromBytes x = join x

reverseBitOrdering : {n} (fin n) => [n] -> [n]
reverseBitOrdering x = join (reverse (split x))

h2b : {n} (fin n) => [Keccak / 8][8] -> [Keccak]
h2b x = join x

b2h : {n} (fin n) => [Keccak] -> [Keccak / 8][8]
b2h x = split x

property h2bAndb2hInvert x = b2h (h2b x) == x

property b2hAndh2bInvert x = h2b (b2h x) == x

example : Bit
property example = h2bAndb2hInvert x /\ b2hAndh2bInvert x
    where
        x = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
```
[GENERATED END]


=== Task 53 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write Cryptol properties that verify a SHA224::hash function against known test vectors for inputs "abc", the empty string, the 448-bit alphabet string, and the 896-bit alphabet string, matching the specified SHA-224 digest outputs.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Keyless::Hash::SHA2::Tests::SHA224 where

import Primitive::Keyless::Hash::SHA2::Instantiations::SHA224 as SHA224

property testsPassed = and tests

tests : [4]Bit
tests =
  [ SHA224::hash "abc" == expected0
  , SHA224::hash ""    == expected1
  , SHA224::hash alphabet448 == expected2
  , SHA224::hash alphabet896 == expected3
  ]

expected0 = join [
  0x238015a3e2d1cd99,
  0x98db785d174f61ef,
  0x43ccdc8195ec289b
  ]

expected1 = join [
  0xd14a028c2a3a2bc9,
  0x4761c62685b865e2,
  0xabf1b8b3514df2d5
  ]

alphabet448 = repeat 'a' @@ [0..447]

expected2 = join [
  0x70e2e4d4ec72007f,
  0x98a294fb44e79697,
  0x641649288700395f
  ]

alphabet896 = repeat 'a' @@ [0..895]

expected3 = join [
  0x16248a7c917c4759,
  0x407974d0e2607928,
  0x650145466b903014
  ]
```
[GENERATED END]


=== Task 54 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module that defines the given test vector record types and properties to verify HMAC-SHA-384 and its 192-bit truncation against the RFC 4868 section 2.7.1 and 2.7.2.2 test vectors, using an imported HMAC_SHA384 instantiation.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
import HMAC_SHA384

property testsPass = all testsPassed

type TestVector = { key : [256], msg : [256], expected : [384] }
type TruncateTestVector = { key : [256], msg : [256], expected : [192] }

testsPassed : [10]Bit
testsPassed =
  [HMAC_SHA384 k m == e | k <- keys | m <- msgs | e <- expecteds]

keys : [10][256]
keys =
  [zero,
  zero # 0x01,
  zero # 0x02,
  zero # 0x03,
  zero # 0x04,
  zero # 0x05,
  zero # 0x06,
  zero # 0x07,
  zero # 0x08,
  zero # 0x09]

msgs : [10][256]
msgs =
  [zero,
  zero # 0x0a,
  zero # 0x0b,
  zero # 0x0c,
  zero # 0x0d,
  zero # 0x0e,
  zero # 0x0f,
  zero # 0x10,
  zero # 0x11,
  zero # 0x12]

expecteds : [10][384]
expecteds =
  [0x3cb002dc2596ef67a0e4d6a99a4ed8fa0fc5178c5f44da7f77959854a9c0b7ad07679694a59aaac220e61225810376e57a706f97f88a779e0f64ec4e6ae6064,
  0x094161727bd64463f7122720e479547279c8277fc95c1004384c90dc297e2d5b7a5138540a104ba160799410056725a5b0a560a75e2473a014286711453302,
  0x7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d906975c0027a717528234dfb57037b486a7070e0c65b0f876dea39ab731deb67e093,
  0x601f60cc80a45d0242103293b63f92343970363d0ce31041947829764863019415293c2641042455d79a7900567115441f0e4144f48a6b0f05d60ced4e74a,
  0x773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514ced565fe3013569d653badc19af08638c08a12f403642a412019b292a745968e0f1fff9,
  0x82558a389a443c0ea4cc819899f2083a85f0af60d2c71a7ff7c9cd1b7d09b2c621d57a3a5605ca62791b3f79f47b12d0310a71da69e7c1290a967b2763104ed,
  0xa9a99745195c3aa9f24cf69cc1e8744164f75f092a5e40d8179a295a3e25e96509a9f3e9f7e0a09918e8189c158b720f6a536e213763be01548ef837fe7a0ae,
  0x56461ef2342edc00f9bab995690efd4ccf01e9b5ff092c0e9c53cc4565a9f24fc646ceaa6f6fbcef465b0bedf722c7fe95fdb0577c8b5ef67f5c9d7310bf14,
  0x891353a44fe6b5e85e4032aff03d964b5c9829a9e37d0fa3e3c544e4e8f2872768d50ee58c03a5c8777f7e0ce650f7a810470e1a04248474048fce3a670996a,
  0x9b09ffa71660e60f1c1f5781e49f31623d9a238a52193ea6e415410e7a0016637a0c655aaca929d3db57a0abb6c18a8d0a76742e7bbd6b8ca7993767c5d16b]

truncTestsPassed : [10]Bit
truncTestsPassed =
  [HMAC_SHA384 k m == e' | k <- keys | m <- msgs | e <- expecteds | e' <- expectedTruncs]

expectedTruncs : [10][192]
expectedTruncs =
  [take e | e <- expecteds]
```
[GENERATED END]


=== Task 55 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define an interface module `Primitive::Symmetric::Cipher::Block::CipherInterface` with type synonyms `KeySize`, `BlockSize`, a finiteness constraint on both, and functions `encrypt` and `decrypt` of type `[KeySize] -> [BlockSize] -> [BlockSize]`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::CipherInterface where

import Common::utils

type KeySize = 128

type BlockSize = 128

encrypt : [KeySize] -> [BlockSize] -> [BlockSize]
encrypt k m = undefined

decrypt : [KeySize] -> [BlockSize] -> [BlockSize]
decrypt k c = undefined
```
[GENERATED END]


=== Task 56 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Specify the CFB (Cipher Feedback) block cipher mode over an abstract block cipher interface, including encrypt and decrypt functions parameterized by segment size and a property encryptCorrect stating decrypt K IV (encrypt K IV Ps) == Ps for all keys, IVs, and plaintext segments.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Modes::CFB where

import interface Primitive::Symmetric::Cipher::Block::CipherInterface as C

type CFB n = { encrypt : [n] -> [n]
             , decrypt : [n] -> [n]
             }

cfbEncrypt : {n} (fin n) => CFB n -> [n] -> [inf] -> [inf]
cfbEncrypt cfb iv ps =
  cs'
  where
    cs = [iv] # [ cfb.encrypt (cs'@i) | i <- [0..] ]
    cs' = map cfb.encrypt (ps # cs)

cfbDecrypt : {n} (fin n) => CFB n -> [n] -> [inf] -> [inf]
cfbDecrypt cfb iv cs =
  ps
  where
    cs' = map cfb.encrypt (cs # [iv])
    ps = [ cfb.decrypt (cs'@(i+1)) ^ cs'@i | i <- [0..] ]

property encryptCorrect K IV Ps =
  decrypt K IV (encrypt K IV Ps) == Ps
  where
    type n = 64
    type m = 8
    encrypt = cfbEncrypt `{n} (C::encrypt `{m} K)
    decrypt = cfbDecrypt `{n} (C::decrypt `{m} K)
```
[GENERATED END]


=== Task 57 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128` that instantiates the generic Simon block cipher specification for the Simon-128/128 variant with type parameters `n = 64`, `m = 2`, `T = 68`, and `j = 2`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128 =
    Primitive::Symmetric::Cipher::Block::Simon::Specification where

        type n = 64
        type m = 2
        type T = 68
        type j = 2
```
[GENERATED END]


=== Task 58 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256` instantiating the generic Simon block cipher specification for the Simon-128/256 variant with parameters `n=64`, `m=4`, `T=72`, and `j=4`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256 =
    Primitive::Symmetric::Cipher::Block::Simon::Specification where

        type n = 64
        type m = 4
        type T = 72
        type j = 4
```
[GENERATED END]


=== Task 59 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR that imports Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR and defines properties aes256_ctr_encrypt_vector and aes256_ctr_decrypt_vector checking AES-256 CTR encrypt/decrypt against the given NIST test vectors.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR where

import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR as AES256_CTR

property aes256_ctr_encrypt_vector = ~zero == AES256_CTR::encrypt k iv plaintext
    where
        k = 0x8000000000000000000000000000000000000000000000000000000000000000
        iv = 0x000102030405060708090a0b0c0d0e0f
        plaintext = [
            0x6bc1bee22e409f96e93d7e117393172a,
            0xae2d8a571e03ac9c9eb76fac45af8e51,
            0x30c81c46a35ce411e5fbc1191a0a52ef,
            0xf69f2445df4f9b17ad2b417be66c3710
        ]

property aes256_ctr_decrypt_vector = ~zero == AES256_CTR::decrypt k iv ciphertext
    where
        k = 0x8000000000000000000000000000000000000000000000000000000000000000
        iv = 0x000102030405060708090a0b0c0d0e0f
        ciphertext = [
            0x6bc1bee22e409f96e93d7e117393172a,
            0xae2d8a571e03ac9c9eb76fac45af8e51,
            0x30c81c46a35ce411e5fbc1191a0a52ef,
            0xf69f2445df4f9b17ad2b417be66c3710
        ]
```
[GENERATED END]


=== Task 60 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB` that instantiates the generic CFB block cipher mode with the AES-192 block cipher implementation.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB =
    Primitive::Symmetric::Cipher::Block::Modes::CFB {
        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192
    }
```
[GENERATED END]


=== Task 61 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module AES128_CFB that instantiates the generic CFB block cipher mode with AES-128, exposing the resulting AES-128 CFB encryption and decryption functions and any necessary types for keys, blocks, and IVs.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB where
import Primitive::Symmetric::Cipher::Block::Modes::CFB
import Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128
type KeySize = 128
type BlockSize = 128
type IVSize = 128
cfb = CFB { blockSize = BlockSize, encrypt = AES128.encrypt }
encrypt = cfb.encrypt
decrypt = cfb.decrypt
```
[GENERATED END]


=== Task 62 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Specify and verify in Cryptol the HostValues module’s heap-based host value store, including VecRepresentation and MapRepresentation constructors, allocation and lookup functions, and define a property that map_representation_equiv correctly characterizes when two MapRepresentation values are equivalent for a given element comparator and heap.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module HostValues where

import Array
import Values

type Heap = Array [64] (Array [64] [64])

data VecRepresentation =
  | VecRepresentation { heap : Heap
                      , nextFree : [64]
                      }

vec_representation_alloc : {a} (fin a) => VecRepresentation -> [a]Value -> ([64], VecRepresentation)
vec_representation_alloc vec val = (nextFree', vec')
  where
    nextFree' = vec.nextFree + 1
    vec' = VecRepresentation { heap = update vec.heap vec.nextFree (arrayFromList val)
                             , nextFree = nextFree'
                             }

vec_representation_lookup : VecRepresentation -> [64] -> Value
vec_representation_lookup vec idx = vec.heap @ idx

data MapRepresentation =
  | MapRepresentation { heap : Heap
                      , nextFree : [64]
                      }

map_representation_alloc : {a} (fin a) => MapRepresentation -> ([64], [a]Value) -> ([64], MapRepresentation)
map_representation_alloc map (key, val) = (nextFree', map')
  where
    nextFree' = map.nextFree + 1
    map' = MapRepresentation { heap = update map.heap map.nextFree (arrayFromList val)
                             , nextFree = nextFree'
                             }

map_representation_lookup : MapRepresentation -> [64] -> ([64], Value)
map_representation_lookup map idx = (idx, map.heap @ idx)

map_representation_equiv : {a} (fin a) => ([64] -> [64] -> Bit) -> MapRepresentation -> MapRepresentation -> Bit
map_representation_equiv cmp m1 m2 = all (equiv m1 m2) (indices m1)
  where
    indices m = take `{a} (iterate (\i -> i + 1) 0)
    equiv m1 m2 i = if cmp i (-1) then True else m1.heap @ i == m2.heap @ i
```
[GENERATED END]


=== Task 63 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification of the AES-128 S-box over GF(2^8), including gf28Mult, gf28Pow, gf28Inverse, aesAffine, aesSBox, the 16×16 aesSBoxTable, and a property cell00 asserting aesSBoxTable @ 0 @ 0 == 0x63.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type GF28 = [8]
gf28Mult : (GF28, GF28) -> GF28
gf28Mult (x, y) = pmod (pmult x y) <| x^8 + x^4 + x^3 + x + 1 |>
gf28Pow : (GF28, [8]) -> GF28
gf28Pow (n, k) =
  pow k
  where
    sq x = gf28Mult (x, x)
    odd x = x ! 0
    pow i =
      if i == 0
      then 1
      else if odd i
           then gf28Mult (n, sq (pow (i >> 1)))
           else sq (pow (i >> 1))
gf28Inverse : GF28 -> GF28
gf28Inverse x = gf28Pow (x, 254)
aesAffine : GF28 -> GF28
aesAffine x =
  gf28Add (gf28Mult (0x63, x), 0x05)
aesSBox : GF28 -> GF28
aesSBox x = aesAffine (gf28Inverse x)
aesSBoxTable = [[aesSBox (i + j * 256) | i <- [0 .. 255]] | j <- [0 .. 15]]
/* pragma cell00 : property */
cell00 = aesSBoxTable @ 0 @ 0 == 0x63
```
[GENERATED END]


=== Task 64 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the functions `usaf : [1][8] -> [10][8] -> [1][8]` and `saf : [1][8] -> [10][8] -> [1][8]` in Cryptol as given, and add a property that they are equal for all inputs `a` and `b` where `0 <= a@0 <= 9`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
usaf : [1][8] -> [10][8] -> [1][8]
usaf a b = [(if (a@0) < (b@0) then (a@0) else (b@0))]

saf : [1][8] -> [10][8] -> [1][8]
saf a b = [(if (a@0) < (b@0) then (a@0) else (b@0))]
```
[GENERATED END]


=== Task 65 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines the given Circle/Displacement/BMI record types and functions (areaCircle, nudgeCircle, calcBMI, calcBMIimp), along with example constants, matching the behavior and types implied by the code excerpt.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Circle = { x : Float64, y : Float64, r : Float64 }
type Displacement = { dx : Float64, dy : Float64 }
type BMI = { weight : Float64, height : Float64 }

areaCircle : Circle -> Float64
areaCircle c = pi * c.r * c.r

nudgeCircle : Circle -> Displacement -> Circle
nudgeCircle c d = { x = c.x + d.dx, y = c.y + d.dy, r = c.r }

calcBMI : BMI -> Float64
calcBMI b = b.weight / (b.height * b.height)

calcBMIimp : BMI -> Float64
calcBMIimp b = bmi where bmi = b.weight / (b.height * b.height)
```
[GENERATED END]


=== Task 66 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification of ECDSA over the NIST P-384 curve, including functions for key initialization, signing, and public verification, plus properties that check the provided P-384 test vectors for point add/subtract/double, scalar multiplication, and twin multiplication.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Asymmetric::Signature::ECDSA::P384 where

import Common::ModDivZ
import Common::utils
import Primitive::Asymmetric::Signature::ECDSA::ECDSA
import Primitive::Asymmetric::Signature::ECDSA::Instantiations::P384

property p384_point_add = ec_point_add P384 G H == J
property p384_point_sub = ec_point_sub P384 J H == G
property p384_point_dbl = ec_point_dbl P384 G == H
property p384_scalar_mul = ec_point_mul P384 d G == Q
property p384_twin_mul = ec_point_mul P384 d G == ec_point_mul P384 e H

property p384_sign_correct = verify P384 Q d M == True
property p384_sign_reject = verify P384 Q d' M == False

  where
    M = "message"
    d = 0x962b5d17e7a8f01150942610160c2187420447203640677760045457301754434031353426743672948959858767676467886175996549989863126474311695184377
    d' = 0x962b5d17e7a8f01150942610160c2187420447203640677760045457301754434031353426743672948959858767676467886175996549989863126474311695184378
    Q = 0xc6444608260067656358365055627666520864079868025155064683267267708489652905418666790569015481449069620297618559656831183976015
    G = 0x1a1d04a923cc91d52a97e2145e9474780135115715095640478605665635449006508951927726563883387676486376728178763618741648529208691758
    H = 0x99242497ed00451f7701967890808720988987766639085567886006088896670068961953859186430827785624077261845867951645621081935266339
    J = 0x4950767528895196685719218380425855373978444118115299989786776603567465721186466588463151177418986833591738664066615985776319
```
[GENERATED END]


=== Task 67 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines the newtype CplxInt over Integer with complex addition, multiplication, equality, and properties cplxAddAssoc, cplxMulAssoc, and cplxMulDistrib verifying associativity of addition, associativity of multiplication, and left distributivity of multiplication over addition.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
newtype CplxInt = { real : Integer, imag : Integer }

cplxAdd : CplxInt -> CplxInt -> CplxInt
cplxAdd x y = CplxInt { real = r, imag = i }
  where
    r = x.real + y.real
    i = x.imag + y.imag

cplxEq : CplxInt -> CplxInt -> Bit
cplxEq x y = x.real == y.real && x.imag == y.imag

cplxMul : CplxInt -> CplxInt -> CplxInt
cplxMul x y = CplxInt { real = r, imag = i }
  where
    r = x.real * y.real - x.imag * y.imag
    i = x.real * y.imag + x.imag * y.real

cplxAddAssoc : CplxInt -> CplxInt -> CplxInt -> Bit
property cplxAddAssoc x y z =
  cplxEq (cplxAdd x (cplxAdd y z)) (cplxAdd (cplxAdd x y) z)

cplxMulAssoc : CplxInt -> CplxInt -> CplxInt -> Bit
property cplxMulAssoc x y z =
  cplxEq (cplxMul x (cplxMul y z)) (cplxMul (cplxMul x y) z)

cplxMulDistrib : CplxInt -> CplxInt -> CplxInt -> Bit
property cplxMulDistrib x y z =
  cplxEq (cplxMul x (cplxAdd y z))
         (cplxAdd (cplxMul x y) (cplxMul x z))
```
[GENERATED END]


=== Task 68 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that includes the given tuple-based fold functions and a property `foldFunctionInverse` stating that `foldFunction' (foldFunction x y z) y z == x` for all 8-bit `x` and 16-bit `y`, `z`, suitable for formal verification.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
foldFunction : ([8], [16], [16]) -> [16] -> [16] -> [8]
foldFunction (a, b, c) x y = a
foldFunction' : ([8], [16], [16]) -> [16] -> [16] -> [8]
foldFunction' x y z = x.0
/* pragma foldFunctionInverse : property */
foldFunctionInverse x y z =
  foldFunction' (foldFunction x y z) y z == x
```
[GENERATED END]


=== Task 69 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines the AES-128 inverse MixColumns transformation over GF(2^8) using precomputed multiplication tables (for 0x0e, 0x0b, 0x0d, 0x09), including the types GF28, State, the helper functions gf28Mult, toBytes, fromBytes, and a function invMixColumns : State -> State matching the standard AES inverse MixColumns step.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type GF28 = [8]
gf28Mult : (GF28, GF28) -> GF28
gf28Mult (x, y) =
  pmod (pmult x y)
    0b10001101  // irreducible polynomial for GF(2^8)
toBytes : [32] -> [4][8]
toBytes x = split (split x)
fromBytes : [4][8] -> [32]
fromBytes x = join (join x)
type State = [4][4]GF28
invMixColumns : State -> State
invMixColumns state =
  [fromBytes
    [gf28Mult (0x0e, b) ^ gf28Mult (0x0b, a) ^ gf28Mult (0x0d, d) ^ gf28Mult (0x09, c)
    | a <- row
    | b <- col @ 1
    | c <- col @ 2
    | d <- col @ 3
    ]
  | row <- state
  | col <- transpose row
```
[GENERATED END]


=== Task 70 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the Cryptol function `doRounds` and supporting types and functions (`Nb`, `State`, `RoundKey`, `addRoundKey`) as given, where `doRounds` iteratively applies a round function `rnd` over an initial key, a sequence of round keys, and a final key, and verify with a `property` that for any choice of `rnd`, initial key, round keys, final key, and input state, `doRounds` produces the same final state as computing the initial AddRoundKey followed by the same sequence of `rnd` applications unrolled explicitly.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Nb = 4

type State = [4][Nb]Bit

type RoundKey = State

addRoundKey : {n} (fin n) => State -> [n]RoundKey -> RoundKey
addRoundKey pt rks =
  pt ^ (rks ! 0)

doRounds : {n}
  (fin n, n >= 1)
  => ([State] -> RoundKey -> [State])
  -> RoundKey
  -> [n]RoundKey
  -> RoundKey
  -> State
  -> State
doRounds rnd initKey rks finalKey st =
  finalSt
  where
    rk0 = addRoundKey st [initKey]
    rks' = [rk0] # rks
    rns = take `{n} (iterate rnd (zero, zero) rks')
    (_, finalSt) = rns ! (n - 1)
```
[GENERATED END]


=== Task 71 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: In Cryptol, define the DES S-box 6 constant `sbox6 : [4][16][4]` with the given 4×16 table of 4-bit values exactly as specified here.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
sbox6 : [4][16][4]
sbox6 =
  [[12, 5, 4, 13, 1, 10, 0, 7, 6, 9, 8, 11, 3, 2, 15, 14],
  [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
  [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
  [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]]
```
[GENERATED END]


=== Task 72 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines the DES block cipher as a value `DES : Cipher 64 64` (with `encrypt`/`decrypt` wired through the DES round function, key schedule, permutations, and S-boxes as in the NIST standard) and a property `testsPass` that checks `DES.encrypt` on given test message/key pairs matches the expected ciphertexts.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
module Primitive::Symmetric::Cipher::Block::DES where

import Common::Utils
import Primitive::Symmetric::Cipher::Block::CipherInterface

type KeySize = 64
type BlockSize = 64
type RoundKeySize = 48
type Nr = 16

type Bit = [1]
type Byte = [8]
type Word32 = [32]
type Word64 = [64]

type KeySchedule = [Nr]RoundKey

type State = [BlockSize]

type RoundKey = [RoundKeySize]

type SBox = [8][4][16][4]

Sbox0 : SBox
Sbox0 =
  [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
  [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
  [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
  [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]]

Sbox1 : SBox
Sbox1 =
  [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
  [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
  [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
  [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]]

Sbox2 : SBox
Sbox2 =
  [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
  [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
  [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
  [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]]

Sbox3 : SBox
Sbox3 =
  [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
  [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
  [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
  [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]]

Sbox4 : SBox
Sbox4 =
  [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
  [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
  [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
  [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]]

Sbox5 : SBox
Sbox5 =
  [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
  [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
  [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
  [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]]

Sbox6 : SBox
Sbox6 =
  [[5, 14, 7, 0, 8, 11, 3, 4, 13, 6, 15, 1, 12, 10, 2, 9],
  [14, 11, 2, 12, 9, 7, 8, 15, 13, 6, 1, 0, 5, 3, 4, 10],
  [14, 11, 2, 12, 15, 7, 8, 13, 6, 1, 0, 9, 5, 3, 4, 10],
  [20, 15, 2, 4, 25, 18, 14, 3, 10, 6, 1, 5, 8, 17, 19, 12],
  [14, 11, 2, 12, 15, 7, 8, 13, 6, 1, 0, 9, 5, 3, 4, 10]]

Sbox7 : SBox
Sbox7 =
  [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
  [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
  [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
  [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]]

P10 : [10] -> [10]
P10 = [3, 5, 2, 7, 4, 10, 1, 9, 8, 6]

P8 : [8] -> [8]
P8 = [6, 3, 7, 4, 8, 5, 10, 9]

IP : [64] -> [64]
IP = [58, 50, 42, 34, 26, 18, 10, 2,
       60, 52, 44, 36, 28, 20, 12, 4,
       62, 54, 46, 38, 30, 22, 14, 6,
       64, 56, 48, 40, 32, 24, 16, 8,
       57, 49, 41, 33, 25, 17, 9, 1,
       59, 51, 43, 35, 27, 19, 11, 3,
       61, 53, 45, 37, 29, 21, 13, 5,
       63, 55, 47, 39, 31, 23, 15, 7]

IPinv : [64] -> [64]
IPinv = [40, 8, 48, 16, 56, 24, 64, 32,
          39, 7, 47, 15, 55, 23, 63, 31,
          38, 6, 46, 14, 54, 22, 62, 30,
          37, 5, 45, 13, 53, 21, 61, 29,
          36, 3, 44, 11, 52, 20, 60, 28,
          35, 2, 43, 10, 51, 19, 59, 27,
          34, 1, 42, 9, 50, 17, 58, 25,
          33, 0, 41, 8, 49, 16, 57, 25]

EP : [32] -> [48]
EP x = join [x@i | i <- [31, 29 ... 1, 7, 5 ... 1]]

P4 : [4] -> [4]
P4 x = join [x@i | i <- [3, 1, 3, 1]]

F : [8] -> [4] -> [4]
F X K = P4 (X ^ K)

Sbox : [8][4][16][4]
Sbox = [Sbox0, Sbox1, Sbox2, Sbox3, Sbox4, Sbox5, Sbox6, Sbox7]

f : [8] -> [48] -> [32]
f X K = join [Sbox@i@(X@i) | i <- [0, 1, 2, 3, 4, 5]]

FK : [48] -> [8][4] -> [32]
FK K X = join [f (X@i) (K@i) | i <- [0, 1, 2, 3, 4, 5]]

FK' : [48] -> [8][4] -> [32]
FK' K X = join [f (X@i) (K@(6 - i)) | i <- [0, 1, 2, 3, 4, 5]]

R1 : [32] -> [48] -> [32]
R1 R K = FK K (split R)

R1' : [32] -> [48] -> [32]
R1' R K = FK' K (split R)

R2 : [32] -> [48] -> [32]
R2 R K = FK K (split R)

R2' : [32] -> [48] -> [32]
R2' R K = FK' K (split R)

R3 : [32] -> [48] -> [32]
R3 R K = FK K (split R)

R3' : [32] -> [48] -> [32]
R3' R K = FK' K (split R)

R4 : [32] -> [48] -> [32]
R4 R K = FK K (split R)

R4' : [32] -> [48] -> [32]
R4' R K = FK' K (split R)

R5 : [32] -> [48] -> [32]
R5 R K = FK K (split R)

R5' : [32] -> [48] -> [32]
R5' R K = FK' K (split R)

R6 : [32] -> [48] -> [32]
R6 R K = FK K (split R)

R6' : [32] -> [48] -> [32]
R6' R K = FK' K (split R)

R7 : [32] -> [48] -> [32]
R7 R K = FK K (split R)

R7' : [32] -> [48] -> [32]
R7' R K = FK' K (split R)

R8 : [32] -> [48] -> [32]
R8 R K = FK K (split R)

R8' : [32] -> [48] -> [32]
R8' R K = FK' K (split R)

R9 : [32] -> [48] -> [32]
R9 R K = FK K (split R)

R9' : [32] -> [48] -> [32]
R9' R K = FK' K (split R)

R10 : [32] -> [48] -> [32]
R10 R K = FK K (split R)

R10' : [32] -> [48] -> [32]
R10' R K = FK' K (split R)

R11 : [32] -> [48] -> [32]
R11 R K = FK K (split R)

R11' : [32] -> [48] -> [32]
R11' R K = FK' K (split R)

R12 : [32] -> [48] -> [32]
R12 R K = FK K (split R)

R12' : [32] -> [48] -> [32]
R12' R K = FK' K (split R)

R13 : [32] -> [48] -> [32]
R13 R K = FK K (split R)

R13' : [32] -> [48] -> [32]
R13' R K = FK' K (split R)

R14 : [32] -> [48] -> [32]
R14 R K = FK K (split R)

R14' : [32] -> [48] -> [32]
R14' R K = FK' K (split R)

R15 : [32] -> [48] -> [32]
R15 R K = FK K (split R)

R15' : [32] -> [48] -> [32]
R15' R K = FK' K (split R)

R16 : [32] -> [48] -> [32]
R16 R K = FK K (split R)

R16' : [32] -> [48] -> [32]
R16' R K = FK' K (split R)

Rounds : {a} (fin a) => ([a], [a]) -> [a]
Rounds (L, R) =
  (L',
  R',
  R1 L' K1,
  R2 L'' K2,
  R3 L''' K3,
  R4 L'''' K4,
  R5 L''''' K5,
  R6 L'''''' K6,
  R7 L''''''' K7,
  R8 L'''''''' K8,
  R9 L''''''''' K9,
  R10 L'''''''''' K10,
  R11 L''''''''''' K11
```
[GENERATED END]


=== Task 73 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol property rfctest03 that verifies the given ChaCha20 stream cipher implementation (using qround, cdround, core, kexp, iround, stream, and encrypt over types Round, Block, Key, Nonce, and Counter) correctly encrypts the specified msg with the given key and counter to produce the expected out test vector.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Round = [16][32]
type Block = [64][8]
type Key = [32][8]
type Nonce = [12][8]
type Counter = [32][8]
qround : [4][32] -> [4][32]
qround [a0, b0, c0, d0] =
  [a2, b4, c2, d4]
  where
    a1 = a0 + b0
    d1 = d0 ^ a1
    d2 = d1 <<< 16
    c1 = c0 + d2
    b1 = b0 ^ c1
    b2 = b1 <<< 12
    a2 = a1 + b2
    d3 = d2 ^ a2
    d4 = d3 <<< 8
    c2 = c1 + d4
    b3 = b2 ^ c2
    b4 = b3 <<< 7
cdround : [4][32] -> [4][32]
cdround [a0, b0, c0, d0] =
  [a2, b4, c2, d4]
  where
    a1 = a0 <<< 16
    d1 = d0 ^ a1
    d2 = d1 >>> 12
    c1 = c0 + d2
    b1 = b0 ^ c1
    b2 = b1 <<< 8
    a2 = a1 + b2
    d3 = d2 ^ a2
    d4 = d3 >>> 7
    c2 = c1 + d4
    b3 = b2 ^ c2
    b4 = b3 <<< 16
core : Round -> Round
core r =
  join
    (groupByBy
      (\x -> x / 4)
      (join
        (groupByBy
          (\x -> x % 4)
          (join (map cdround (groupByBy (\x -> x / 4) r)))))
      4))
kexp : [4][32] -> [4][32]
kexp [a0, b0, c0, d0] =
  [a0,
  b0 + a0 <<< 18,
  c0 + b0 <<< 7,
  d0 + c0 <<< 14,
  a0 + d0 <<< 21,
  b0 + a0 <<< 18,
  c0 + b0 <<< 7,
  d0 + c0 <<< 14,
  a0 + d0 <<< 21,
  b0 + a0 <<< 18,
  c0 + b0 <<< 7,
  d0 + c0 <<< 14,
  a0 + d0 <<< 21,
  b0 + a0 <<< 18,
  c0 + b0 <<< 7,
  d0 + c0 <<< 14]
iround : [4][32] -> [4][32] -> [4][32]
iround [a0, b0, c0, d0] [a1, b1, c1, d1] =
  [a0 + a1,
  (b0 + b1) <<< 16,
  (c0 + c1) <<< 12,
  (d0 + d1) <<< 8,
  (a0 + a1) <<< 7,
  (b0 + b1) <<< 16,
  (c0 + c1) <<< 12,
  (d0 + d1) <<< 8,
  (a0 + a1) <<< 7,
  (b0 + b1) <<< 16,
  (c0 + c1) <<< 12,
  (d0 + d1) <<< 8,
  (a0 + a1) <<< 7,
  (b0 + b1) <<< 16,
  (c0 + c1) <<< 12,
  (d0 + d1) <<< 8]
stream : Key -> Nonce -> Counter -> Round
stream k n c =
  take `{64} (iterate core (iround (kexp (split c)) (core (kexp (split n)))))
encrypt : Key -> Nonce -> Counter -> Block -> Block
encrypt k n c m =
  map (^) m (stream k n c)
rfctest03 =
  encrypt k n c msg == out
  where
    k =
      [0x00010203,
      0x04050607,
      0x08090A0B,
      0x0C0D0E0F,
      0x10111213,
      0x14151617,
      0x18191A1B,
      0x1C1D1E1F,
      0x20212223,
      0x24252627,
      0x28292A2B,
      0x2C2D2E2F,
      0x30313233,
      0x34353637,
      0x38393A3B,
      0x3C3D3E3F]
    n =
      [0x000102030405060708090A0B,
      0x0C0D0E0F1011121314151617]
    c = [0x00000000]
    msg =
      [0x6bc1bee22e409f96,
      0xe93d7e117393172a,
      0xae2d8a571e03ac9c,
      0x9eb76fac45af8e51,
      0x30c81c46a35ce411,
      0xe5fbc1191a0a52ef,
      0xf69f2445df4f9b17,
      0xad2b417be66c3710]
    out =
      [0x3ad77bb40d7a3660,
      0xa89ecaf32466ef97,
      0xf5d3d58503b9699d,
      0x7e9113163cfbf17a,
      0x2bfc679e25340164,
      0x29efc9f657fad061,
      0xcde6fa78ecce73f4,
      0x8eacd12c29470936]
```
[GENERATED END]


=== Task 74 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification of the ChaCha20 stream cipher with types Round = [16][32], Block = [64][8], Key = [32][8], Nonce = [12][8], Counter = [32], functions qround, cdround, kexp, iround, core, stream, encrypt, and a property rfctest02 that checks encrypt (zero # [1]) 1 (zero # [2]) msg equals the given RFC test vector out for the provided msg bytes.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
type Round = [16][32]
type Block = [64][8]
type Key = [32][8]
type Nonce = [12][8]
type Counter = [32]
qround : [4][32] -> [4][32]
qround [a0, b0, c0, d0] =
  [a2, b4, c2, d4]
  where
    a1 = a0 + b0
    d1 = d0 ^ a1
    d2 = d1 <<< 16
    c1 = c0 + d2
    b1 = b0 ^ c1
    b2 = b1 <<< 12
    a2 = a1 + b2
    d3 = d2 ^ a2
    d4 = d3 <<< 8
    c2 = c1 + d4
    b3 = b2 ^ c2
    b4 = b3 <<< 7
cdround : Round -> Round
cdround
  [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14,
   x15] =
  [y0,
  y1,
  y2,
  y3,
  y4,
  y5,
  y6,
  y7,
  y8,
  y9,
  y10,
  y11,
  y12,
  y13,
  y14,
  y15]
  where
    [y0, y4, y8, y12] = map qround [x0, x4, x8, x12]
    [y5, y9, y13, y1] = map qround [x5, x9, x13, x1]
    [y10, y14, y2, y6] = map qround [x10, x14, x2, x6]
    [y15, y3, y7, y11] = map qround [x15, x3, x7, x11]
kexp : Round -> [16][8] -> Round
kexp [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14,
      x15] k =
  [x0,
  x1,
  x2,
  x3,
  x4,
  x5,
  x6,
  x7,
  x8,
  x9,
  x10,
  x11,
  x12,
  x13,
  x14,
  x15]
  where
    [x0', x4', x8', x12'] =
      map (\xi -> xi + (join (k @ [(xi >>> 18) % 16])) % 2 ^^ 32) [x0, x4,
      x8, x12]
    [x1', x5', x9', x13'] =
      map (\xi -> xi + (join (k @ [(xi >>> 14) % 16])) % 2 ^^ 32) [x1, x5,
      x9, x13]
    [x2', x6', x10', x14'] =
      map (\xi -> xi + (join (k @ [(xi >>> 10) % 16])) % 2 ^^ 32) [x2, x6,
      x10, x14]
    [x3', x7', x11', x15'] =
      map (\xi -> xi + (join (k @ [(xi >>> 6) % 16])) % 2 ^^ 32) [x3, x7,
      x11, x15]
    [x0'', x4'', x8'', x12''] =
      map (\xi -> xi + (join (k @ [(xi >>> 2) % 16])) % 2 ^^ 32) [x0', x4',
      x8', x12']
    [x1'', x5'', x9'', x13''] =
      map (\xi -> xi + (join (k @ [(xi >>> 16) % 16])) % 2 ^^ 32) [x1', x5',
      x9', x13']
    [x2'', x6'', x10'', x14''] =
      map (\xi -> xi + (join (k @ [(xi >>> 12) % 16])) % 2 ^^ 32) [x2', x6',
      x10', x14']
    [x3'', x7'', x11'', x15''] =
      map (\xi -> xi + (join (k @ [(xi >>> 8) % 16])) % 2 ^^ 32) [x3', x7',
      x11', x15']
iround : Round -> Counter -> Round
iround r i =
  cdround (kexp r (join (split (i + 1)))) (r @@ [15, 14, 13, 12, 11, 10, 9,
  8, 7, 6, 5, 4, 3, 2, 1, 0])
core : Key -> Nonce -> Counter -> Round
core k n i =
  iround (iround (iround (iround (iround (iround (iround (iround (iround
  (iround (iround (iround (iround (iround (iround (cdround (kexp r
  (join (split (i + 1)))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2, 1, 0])))) (r @@ [15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
  5, 4, 3, 2,
```
[GENERATED END]


=== Task 75 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines the type AESTestVector 128 and the function mct_ecb_decrypt_128 : [128] -> [128] -> [100](AESTestVector 128) implementing the AES-128 Monte Carlo Test for ECB decryption using aesDecryptBlock and aes128DecryptSchedule from SuiteB, including generation of 100 test vectors from an initial key and ciphertext as described.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_ECB
import Primitive::Symmetric::Cipher::Block::AES

type AESTestVector n = {key : [n], pt : [n], ct : [n]}
mct_ecb_decrypt_128 : [128] -> [128] -> [100](AESTestVector 128)
mct_ecb_decrypt_128 k c =
  take `{100}
    [AESTestVector {key = k, pt = aesDecryptBlock (aes128DecryptSchedule k) ct', ct = ct'}
    | ct' <- cs]
  where
    cs = [c] # [ct ^ (zero # ct') | ct <- cs | ct' <- cs']
```
[GENERATED END]


=== Task 76 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define in Cryptol the function `mct_ecb_decrypt_192 : [192] -> [128] -> [100](AESTestVector 192)` and any required types and helpers so that it models the AES-192 Monte Carlo Test for ECB decryption, producing 100 test vectors of key, plaintext, and ciphertext derived from iterative AES-192 decryption and key schedule updates.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
import Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192


type AESTestVector n = {key : [n], pt : [128], ct : [128]}
mct_ecb_decrypt_192 : [192] -> [128] -> [100](AESTestVector 192)
mct_ecb_decrypt_192 k iv =
  take `{100}
  [({key = k', pt = pt, ct = c})
  | (c, k') <- aes192_decryption_iter k iv
  | pt <- repeat iv]
aes192_decryption_iter k c =
  iterate (\(c', k') -> (aes192_decrypt k' c', update_key k')) (c, k)
update_key k =
  (k @@ ([37, 41, 45, 49, 53, 57, 61, 65, 69, 73, 77, 81, 85,
           89, 93, 97, 101, 105, 109, 113, 117, 121, 125, 129,
           133, 137, 141, 145, 149, 153, 157, 161, 165, 169,
           173, 177, 181, 185, 189, 193, 197]))
  # k @@ ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
           15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
           28, 29, 30, 31, 32, 33, 34, 35, 36])
```
[GENERATED END]


=== Task 77 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol property tcId1069 that verifies the AES256_KeyWrap padded authenticated-encryption function KWP_AE, instantiated from Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap, maps the 8-bit plaintext 0xe0 under the 256-bit key 0x2644ccf9d7c419a437c954c8141cbb2d60f57de10a5393554a14ccc72229e286 to the ciphertext 0xda510b1d9a10255380655980a3a73536, using a helper predicate check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct and asserting testPassed == check_KWP_AE key pt ct.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap


check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct
/* pragma tcId1069 : property */
tcId1069 =
  testPassed == check_KWP_AE key pt ct
  where
    testPassed = True
    key =
      0x2644ccf9d7c419a437c954c8141cbb2d60f57de10a5393554a14ccc72229e286
    pt = 0xe0
    ct = 0xda510b1d9a10255380655980a3a73536
```
[GENERATED END]


=== Task 78 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the property `tcId1080` that checks, for AES-256 Key Wrap with padding in AE mode, that encrypting the plaintext `0x06` under the key `0x3ea9325069ed93a96c331bdd6dd766ec64bbba83a72c69ed75df55043fb0bfd1` with `KWP_AE` produces the expected ciphertext `0x40a9c42012ba38211b800e6e313b6876`, using the helper `check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap


check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct
/* pragma tcId1080 : property */
tcId1080 =
  testPassed == check_KWP_AE key pt ct
  where
    testPassed = True
    key =
      0x3ea9325069ed93a96c331bdd6dd766ec64bbba83a72c69ed75df55043fb0bfd1
    pt = 0x06
    ct = 0x40a9c42012ba38211b800e6e313b6876
```
[GENERATED END]


=== Task 79 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the Cryptol function `pi16' : [16][64] -> [16][64]` that permutes a 16-word (64-bit each) Threefish state using the index order `[0, 15, 2, 11, 6, 13, 4, 9, 14, 1, 8, 5, 10, 3, 12, 7 : [4]]`, and add a property that this permutation is bijective (has an inverse).


[PROMPT END]

[GENERATED BEGIN]
```cryptol
pi16' : [16][64] -> [16][64]
pi16' xs = xs @@ [0, 15, 2, 11, 6, 13, 4, 9, 14, 1, 8, 5, 10, 3, 12, 7 : [4]]
```
[GENERATED END]


=== Task 80 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: In Cryptol, define the type alias `Dom n = {lo : [n], sz : [n]}` and the functions `interval : {n} (fin n) => [n] -> [n] -> Dom n` and `range : {n} (fin n) => [n] -> [n] -> Dom n` where `interval l s = {lo = l, sz = s}` and `range lo hi = interval lo (hi - lo)`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Dom n = {lo : [n], sz : [n]}
interval : {n} (fin n) => [n] -> [n] -> Dom n
interval l s = {lo = l, sz = s}
range : {n} (fin n) => [n] -> [n] -> Dom n
range lo hi = interval lo (hi - lo)
```
[GENERATED END]


=== Task 81 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: In Cryptol, define the type alias `Dom n = {lo : [n], sz : [n]}`, the function `interval : {n} (fin n) => [n] -> [n] -> Dom n` with `interval l s = {lo = l, sz = s}`, and the constant `top : {n} (fin n) => Dom n` defined as `top = interval 0 (~0)`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Dom n = {lo : [n], sz : [n]}
interval : {n} (fin n) => [n] -> [n] -> Dom n
interval l s = {lo = l, sz = s}
top : {n} (fin n) => Dom n
top = interval 0 (~0)
```
[GENERATED END]


=== Task 82 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines the type `Dom n = {lo : [n], sz : [n]}`, the functions `mem : {n} (fin n) => Dom n -> [n] -> Bit`, `ubounds : {n} (fin n) => Dom n -> ([n], [n])`, `ule : {n} (fin n) => Dom n -> Dom n -> Bit`, the property `correct_ule : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit` expressing that `ule a b` implies `x <= y` for all `x` and `y` in the respective domains, and a property instance `o4 = correct_ule` specialized to `n = 16`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Dom n = {lo : [n], sz : [n]}
mem : {n} (fin n) => Dom n -> [n] -> Bit
mem a x = x - a.lo <= a.sz
ubounds : {n} (fin n) => Dom n -> ([n], [n])
ubounds a =
  if carry a.lo a.sz then (0, ~0) else (a.lo, a.lo + a.sz)
ule : {n} (fin n) => Dom n -> Dom n -> Bit
ule a b =
  if a.sz == 0 /\ b.sz == 0 then True
  else if a.sz == 0 \/ b.sz == 0 then False
  else (b.lo - a.lo) <= (a.sz + b.sz)
correct_ule : {n}
  (fin n, n >= 1) =>
    Dom n -> Dom n -> [n] -> [n] -> Bit
correct_ule a b x y =
  ule a b ==> mem a x ==> mem b y ==> x <= y
/* pragma o4 : property */
o4 = correct_ule where type n = 16
```
[GENERATED END]


=== Task 83 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: In Cryptol, define the type `Dom n = {lo : [n], sz : [n]}`, functions `interval`, `singleton`, `neg`, `singleton_neg` as in the excerpt, and the property `i08` that asserts `singleton_neg` instantiated at width 16 (i.e., `singleton_neg`{16}) holds for all 16-bit inputs, suitable for verification with a solver.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Dom n = {lo : [n], sz : [n]}
interval : {n} (fin n) => [n] -> [n] -> Dom n
interval l s = {lo = l, sz = s}
singleton : {n} (fin n) => [n] -> Dom n
singleton x = interval x 0
neg : {n} (fin n) => Dom n -> Dom n
neg a =
  if a.sz == 0 then singleton (neg a.lo)
  else interval (-a.sz - a.lo) a.sz
singleton_neg : {n} (fin n) => [n] -> Bit
property i08 = singleton_neg`{16}
```
[GENERATED END]


=== Task 84 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol property `Salsa20_passes_tests` that checks the given Salsa20 core implementation (using `quarterround`, `rowround`, `columnround`, `doubleround`, `littleendian`, `littleendian_state`, `littleendian_state_inverse`, `Salsa20_rounds`, and `Salsa20 : [32] -> [64][8] -> [64][8]`) satisfies the three specified 20-round test vectors by equating its outputs to the provided 64-byte expected sequences and conjoining the results.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
quarterround : [16][32] -> [16][32]
quarterround [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15] =
  [z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15]
  where
    z0 = y0 + y4
    z4 = y4 ^ z0 <<< 0x7
    z8 = y8 + z4
    z12 = y12 ^ z8 <<< 0x9
    z1 = y1 + z12
    z5 = z12 ^ z1 <<< 0xd
    z9 = y9 + z5
    z13 = y13 ^ z9 <<< 0x12
    z2 = y2 + z13
    z6 = z13 ^ z2 <<< 0xd
    z10 = y10 + z6
    z14 = y14 ^ z10 <<< 0x9
    z3 = y3 + z14
    z7 = z14 ^ z3 <<< 0x7
    z11 = y11 + z7
    z15 = y15 ^ z11 <<< 0x12
rowround : [16][32] -> [16][32]
rowround [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15] =
  [z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15]
  where
    [z0, z1, z2, z3] = quarterround [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15]
    [z4, z5, z6, z7] = quarterround [y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15, y0, y1, y2, y3]
    [z8, z9, z10, z11] = quarterround [y8, y9, y10, y11, y12, y13, y14, y15, y0, y1, y2, y3, y4, y5, y6, y7]
    [z12, z13, z14, z15] = quarterround [y12, y13, y14, y15, y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11]
columnround : [16][32] -> [16][32]
columnround [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15] =
  [z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15]
  where
    [z0, z4, z8, z12] = quarterround [y0, y4, y8, y12, y1, y5, y9, y13, y2, y6, y10, y14, y3, y7, y11, y15]
    [z1, z5, z9, z13] = quarterround [y1, y5, y9, y13, y0, y4, y8, y12, y3, y7, y11, y15, y2, y6, y10, y14]
    [z2, z6, z10, z14] = quarterround [y2, y6, y10, y14, y1, y5, y9, y13, y0, y4, y8, y12, y3, y7, y11, y15]
    [z3, z7, z11, z15] = quarterround [y3, y7, y11, y15, y2, y6, y10, y14, y1, y5, y9, y13, y0, y4, y8, y12]
doubleround : [16][32] -> [16][32]
doubleround y = columnround (rowround y)
littleendian : [32][8] -> [32]
littleendian x = join (reverse x)
littleendian_state : [64][8] -> [16][32]
littleendian_state x = [littleendian xi | xi <- split x]
littleendian_state_inverse : [16][32] -> [64][8]
littleendian_state_inverse x = join (map littleendian x)
Salsa20_rounds : [32] -> [64][8] -> [64][8]
Salsa20_rounds n x =
  littleendian_state_inverse
    (foldl (\state i -> state + (if i < n then [0x00000000, 0x00000001, 0x00000002, 0x00000003, 0x00000004, 0x00000005, 0x00000006, 0x00000007, 0x00000008, 0x00000009, 0x0000000a, 0x0000000b, 0x0000000c, 0x0000000d, 0x0000000e, 0x0000000f] else []) + doubleround state) (littleendian_state x) [0 .. 15])
Salsa20 : [32] -> [64][8] -> [64][8]
Salsa20 c x = Salsa20_rounds c x
/* pragma Salsa20_passes_tests : property */
Salsa20_passes_tests =
  (Salsa20 0x0000000000000000
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] ==
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) /\
  (Salsa20 0x0000000000000000
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] ==
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) /\
  (Salsa20 0x0000000000000000
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] ==
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
```
[GENERATED END]

