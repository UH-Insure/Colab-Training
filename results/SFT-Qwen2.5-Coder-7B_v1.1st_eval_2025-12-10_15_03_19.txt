j05hr3d/SFT-Qwen2.5-Coder-7B_v1.1st Eval Suite Results
Started at 2025-12-10_15:03:20 Ended at 2025-12-10_15:18:49
Processed 84 tasks.

=== FINAL SCORE: N/A (no executed tasks) ===


=== Task 1 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Implement a function named `xor8` which takes two 8-bit words and returns their bitwise XOR. Also provide a constant `zero8` equal to 0 (8-bit).

[PROMPT END]

[GENERATED BEGIN]
```cryptol
xor8 : [8] -> [8] -> [8]
xor8 = (^)

zero8 : [8]
zero8 = 0
```
[GENERATED END]


=== Task 2 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Implement a function named `matrix` which takes no input and returns a 3 x 3 matrix of tuples. For the function use a nested comprehension to write an expression to produce a 3 × 3 matrix (as a sequence of sequences), such that the ijth entry contains the value (i, j).

[PROMPT END]

[GENERATED BEGIN]
```cryptol
matrix = [[(i, j) | j <- [1..3]] | i <- [1..3]]
```
[GENERATED END]


=== Task 3 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Implement a Caesar cipher. Define the functions `encrypt` and `decrypt` with the signature: `{n} [8] -> [n][8] -> [n][8]`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
encrypt : {n} [8] -> [n][8] -> [n][8]
encrypt k msg = [m + k | m <- msg]

decrypt : {n} [8] -> [n][8] -> [n][8]
decrypt k ct = [c - k | c <- ct]
```
[GENERATED END]


=== Task 4 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Using ONLY the functions and constraints provided, create a monomorphic Cryptol property named `equivalent` that proves decrypt inverts encrypt for a 512-byte plaintext.

### Additional setup code:
```cryptol
encryptChar : [8] -> [8] -> [8]
encryptChar key c = (c + key)
decryptChar : [8] -> [8] -> [8]
decryptChar key c = (c - key)
encrypt : {n} [8] -> [n][8] -> [n][8]
encrypt key txt = [ encryptChar key c | c <- txt ]
decrypt : {n} [8] -> [n][8] -> [n][8]
decrypt key txt = [ decryptChar key c | c <- txt ]
```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
encryptChar : [8] -> [8] -> [8]
encryptChar key c = (c + key)
decryptChar : [8] -> [8] -> [8]
decryptChar key c = (c - key)
encrypt : {n} [8] -> [n][8] -> [n][8]
encrypt key txt = [ encryptChar key c | c <- txt ]
decrypt : {n} [8] -> [n][8] -> [n][8]
decrypt key txt = [ decryptChar key c | c <- txt ]

property equivalent key msg = (decrypt key (encrypt key msg)) == msg
```
[GENERATED END]


=== Task 5 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA384` that imports the generic SHA-2 specification for SHA-384. Use `type DigestSize = 384`, `type w = 64`, and initialize the hash vector as `H0 = [
        0xcbbb9d5dc1059ed8, 0x629a292a367cd507,
        0x9159015a3070dd17, 0x152fecd8f70e5939,
        0x67332667ffc00b31, 0x8eb44a8768581511,
        0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4
    ]
`

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 =
    Primitive::Keyless::Hash::SHA2::SHA2 where

        type DigestSize = 384
        type w = 64

        H0 = [
            0xcbbb9d5dc1059ed8, 0x629a292a367cd507,
            0x9159015a3070dd17, 0x152fecd8f70e5939,
            0x67332667ffc00b31, 0x8eb44a8768581511,
            0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4
        ]
```
[GENERATED END]


=== Task 6 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Symmetric::Cipher::Block::AES::ExpandKey` that imports the generic `GF28`, `State`, and `SubByteSBox` of the AES encryption modules. Define `type Nk` and `type Nr` as parameters with the constraints that `Nk >= 1` with `8 >= width` and `Nr >= 2` with `8 >= width`. Define the functions `expandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)`, `expandKeyForever : [Nk][4][8] -> [inf]RoundKey`, `keyWS : [Nk][4][8] -> [inf][4][8]`, `Rcon : [8] -> [4]GF28`, `SubWord : [4]GF28 -> [4]GF28`, `RotWord : [4]GF28 -> [4]GF28`, and `NextWord : [8] ->[4][8] -> [4][8] -> [4][8]`. The module should perform AES key expansion. The type `RoundKey` is defined in the `State` module as the following.

### Additional setup code:
```cryptol
module Primitive::Symmetric::Cipher::Block::AES::ExpandKey where

import Primitive::Symmetric::Cipher::Block::AES::GF28
import Primitive::Symmetric::Cipher::Block::AES::State
import Primitive::Symmetric::Cipher::Block::AES::SubByteSBox

parameter

  type Nk : #
  type constraint (8 >= width Nk, Nk >= 1)

  type Nr : #
  type constraint (8 >= width Nr, Nr >= 2)

expandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)
expandKey key = ( keys @ 0
                , keys @@ ([1 .. (Nr - 1)] : [_][8])
                , keys @ (`Nr : [8])
                )
  where   seed : [Nk][4][8]
          seed = split (split key)
          keys = expandKeyForever seed

expandKeyForever : [Nk][4][8] -> [inf]RoundKey
expandKeyForever seed = [ transpose g | g <- split (keyWS seed) ]

keyWS : [Nk][4][8] -> [inf][4][8]
keyWS seed    = xs
     where xs = seed # [ NextWord i prev old
                       | i    <- [ `Nk ... ]
                       | prev <- drop`{Nk-1} xs
                       | old  <- xs
                       ]

Rcon : [8] -> [4]GF28
Rcon i = [ gf28Pow <| x |> (i-1), 0, 0, 0]

SubWord : [4]GF28 -> [4]GF28
SubWord bs = [ SubByte b | b <- bs ]

RotWord : [4]GF28 -> [4]GF28
RotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]

```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::AES::ExpandKey where

import Primitive::Symmetric::Cipher::Block::AES::GF28
import Primitive::Symmetric::Cipher::Block::AES::State
import Primitive::Symmetric::Cipher::Block::AES::SubByteSBox

parameter

  type Nk : #
  type constraint (8 >= width Nk, Nk >= 1)

  type Nr : #
  type constraint (8 >= width Nr, Nr >= 2)

expandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)
expandKey key = ( keys @ 0
                , keys @@ ([1 .. (Nr - 1)] : [_][8])
                , keys @ (`Nr : [8])
                )
  where   seed : [Nk][4][8]
          seed = split (split key)
          keys = expandKeyForever seed

expandKeyForever : [Nk][4][8] -> [inf]RoundKey
expandKeyForever seed = [ transpose g | g <- split (keyWS seed) ]

keyWS : [Nk][4][8] -> [inf][4][8]
keyWS seed    = xs
     where xs = seed # [ NextWord i prev old
                       | i    <- [ `Nk ... ]
                       | prev <- drop`{Nk-1} xs
                       | old  <- xs
                       ]

Rcon : [8] -> [4]GF28
Rcon i = [ gf28Pow <| x |> (i-1), 0, 0, 0]

SubWord : [4]GF28 -> [4]GF28
SubWord bs = [ SubByte b | b <- bs ]

RotWord : [4]GF28 -> [4]GF28
RotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]


NextWord : [8] -> [4][8] -> [4][8] -> [4][8]
NextWord i prev old =
  if (i % `Nk) == 0 then SubWord (RotWord prev) ^ Rcon (i / `Nk)
  else if `Nk > 6 && (i % `Nk) == 4 then SubWord prev
  else prev
```
[GENERATED END]


=== Task 7 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines an incremental averaging state machine. The specification should define the type `State` to contain a sum of all values and the amount of values as two 32-bit words, the functions `init` to initialize `State`, `appendf` that adds a value to `sum'` and increments `len`, `digest` that returns the average in the `State`, and `avg` with signature `avg : {n} (fin n, 32 >= width n) => [n][32] -> [32]` to compute the averages of a sequence.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
type State =
  { sum : [32]
  , len : [32]
  }

init : State
init = { sum = 0, len = 0 }

appendf : State -> [32] -> State
appendf st v =
  { sum = st.sum + v
  , len = st.len + 1
  }

digest : State -> [32]
digest st =
  if st.len == 0 then 0 else st.sum / st.len

avg : {n} (fin n, 32 >= width n) => [n][32] -> [32]
avg vs = digest (foldl appendf init vs)
```
[GENERATED END]


=== Task 8 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Test` that imports `Cipher`. Define the function `evktest : {ks, bs, n} (fin bs) => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)`, that takes a cipher, `n` key and test vector tuples, and plain text. The function test that using the cipher’s `encrypt` to encrypt the plain text with each key from the test vectors will produce the cipher text in the test vectors. The function returns `n` tuples containing the cipher text produced by encrypting the plain text with each test key and a boolean value whether the cipher text matches the expected test vector.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Test where

import Cipher

evktest : {ks, bs, n} (fin bs) => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)
evktest (cipher, kvs, pt) =
  [ (ct, ct == kv.1)
  | kv <- kvs
  ]
  where
    ct = cipher.encrypt pt kv.0
```
[GENERATED END]


=== Task 9 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module `ECDSA_test` with imports `Common::utils` and `Primitive::Asymmetric::Signature::ECDSA::p192 as p192`. Define a property for the function `G_compress R = ec_compress (ec_affinify G) == R` from the p192 module. Use the value `0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012` in your property.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module ECDSA_test where

import Common::utils
import Primitive::Asymmetric::Signature::ECDSA::p192 as p192

property test_G_compress R = p192::G_compress R
    where R = 0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012
```
[GENERATED END]


=== Task 10 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module `bivium` that generates the infinite keystream as specified by the Bivium stream cipher. Define the function `bivium_stream : [93] -> [84] -> [inf]` which takes two initial shift registers of lengths 93 and 84 bits and returns the infinite keystream according to the Bivium algorithm. Define `type N = 200`, and a function `Bivium : ([93], [84]) -> [N]Bit` which takes the two initial registers as a pair and returns the first N bits of the keystream returned from `bivium_stream`. Define the helper functions: `shift : {d} (fin d, d >=1) => [d] -> Bit -> [d]` that returns `fills` where `fills = [bit]#(drop`{1} (fill >> 1))`. The function `shift_regs : {d,e} (fin d, fin e, d >=1, e >=1) => [d] -> [e] -> ([inf],[inf][d],[inf][e])` that, given 2 initial registers, returns a tuple containing the infinite keystream, the infinite stream of `r1`, and the infinite stream of `r2`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
type N = 200

bivium_stream : [93] -> [84] -> [inf]
bivium_stream r1 r2 =
  (take`{1} r1) # (bivium_stream (shift r1 True) (shift r2 (r1 ! 0)))
shift : {d} (fin d, d >= 1) => [d] -> Bit -> [d]
shift fill bit = fills
  where
    fills = [bit] # (drop`{1} (fill >> 1))
shift_regs : {d, e}
  (fin d,
    fin e,
    d >= 1,
    e >= 1) =>
    [d] ->
      [e] ->
        ([inf],
         [inf][d],
         [inf][e])
shift_regs r1 r2 =
  (bivium_stream (shift r1 True) (shift r2 (r1 ! 0)),
   (iterate shift r1),
   (iterate shift r2))
Bivium (r1, r2) =
  take`{N} (bivium_stream r1 r2)
```
[GENERATED END]


=== Task 11 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512` that imports the generic `ECDSA::UnconstrainedSpec`. Instantiate it with the  `EC = Common::EC::PrimeField::Instantiations::P521` and `Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512 =
    Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec {
        EC = Common::EC::PrimeField::Instantiations::P521,
        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512
    }
```
[GENERATED END]


=== Task 12 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96` that imports the generic Simon specification for Simon96_96. Use `type n = 48`, `type m = 2`, `type T = 52`, and `type j = 2`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96 =
    Primitive::Symmetric::Cipher::Block::Simon::Specification where
        type n = 48
        type m = 2
        type T = 52
        type j = 2
```
[GENERATED END]


=== Task 13 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification for a parameterized SHA-2 style hash function over word size w, defining sha : {L} (2 * w >= width L) => [L] -> [digest_size] and all supporting types, constants (H0, K), and functions (padding, parsing, message schedule, compression, and block processing).

[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
module Primitive::Keyless::Hash::SHA2::SHA2 where

import Common::ModArith

parameter

  type w : #
  type constraint (fin w, w >= 1)

type digest_size = 8*w

sha : {L} (2 * w >= width L) => [L] -> [digest_size]
sha M = join (sha' (parse M))

sha' : {n} (fin n, n >= 1) => [n][w] -> [8][w]
sha' M = H1 where
  type L = length M + 1 + 64 + 64
  M' = M # [True] # zero # (fromInteger (toInteger (`L):[64]))
  M'' = split (M' : [L * w])
  H0 = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
         0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]
  H1 = compress H0 (messageSchedule M'')

parse : {L} (2 * w >= width L) => [L] -> [L / w][w]
parse M = split M

padded : {L} (fin L, 2 * w >= width L) => [L] -> [L + w][w]
padded M = M # zero

padding : {L} (fin L, 2 * w >= width L) => [L] -> [L + w]
padding M = M # zero

split : {n, k} (fin k, n >= 1, n % k == 0) => [n * k] -> [n][k]
split M = [ take `{k} x | x <- splitAt `{k} M ]

join : {n, k} (fin k, n >= 1, n % k == 0) => [n][k] -> [n * k]
join Ms = joinWith (zero : [k]) Ms

joinWith : {k} (fin k) => [k] -> [n][k] -> [n * k]
joinWith _ [] = zero
joinWith sep [x] = x
joinWith sep (x : xs) = x # sep # joinWith sep xs

take : {n, m} (fin m) => [m+n] -> [n]
take M = M'

  where
    M' = zero
    M'@i = M@i

messageSchedule : {n} (fin n) => [n][w] -> [64][w]
messageSchedule M = W where
  W = M # [ ch (W@(i-15)) (W@(i-2)) (W@(i-7)) + s0 (W@(i-16)) + W@(i-7) + s1 (W@(i-14)) (W@(i-3)) | i <- [64 .. 127] ]

ch : {k} (fin k) => [k] -> [k] -> [k] -> [k]
ch x y z = (x && y) ^ (~x && z)

s0 : {k} (fin k) => [k] -> [k]
s0 x = rotr `{1} x ^ rotr `{8} x ^ rotr `{7}

s1 : {k} (fin k) => [k] -> [k]
s1 x = rotr `{19} x ^ rotr `{61} x ^ rotr `{6} x

rotr : {n, k} (fin n, fin k) => [n] -> [k]
rotr x = x @@ reverse [ i % `n | i <- [0 ... k-1]]

compression : {n} (fin n, n >= 1) => [8][w] -> [64][w] -> [8][w]
compression H W = H'
  where
    T1 = H ! [0, 1, 2, 3, 4, 5, 6, 7]
    T2 = [ h + s1 t1 + ch t1 t2 t3 + k + w
          | h <- T1
          | t1 <- T1 @@ [7, 0, 1, 2, 3, 4, 5, 6]
          | t2 <- T1 @@ [4, 5, 6,
```
[GENERATED END]


=== Task 14 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Using the existing type `Cipher` and value `toyCipher` provided in the test setup, define a single polymorphic Cryptol function named `evktest` with the following type:

evktest : {ks, bs, n} (fin bs)
       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)

The function should take a cipher implementation, a sequence of (Key, Ciphertext) test vectors, and a single plaintext block. For each (Key, CT) in the list, it must iterate over that list using a single generator in a list comprehension (no parallel generators or multiple `|` arms), compute CT' = cipher.encrypt Key PT for that entry, and produce an output list of pairs (CT', CT' == CT).

The code for `Cipher` and `toyCipher` is ALREADY present in the file from the test setup code. In your answer, you MUST NOT repeat, modify, or redefine `Cipher` or `toyCipher`, and you MUST NOT add any other top-level declarations.

Your entire answer must consist of exactly two top-level lines: (1) the type signature for `evktest` exactly as given above, and (2) the definition of `evktest`. Do not wrap these in a module declaration, and do not include any setup code.

### Additional setup code:
```cryptol
type Cipher ks bs =
  { encrypt : [ks] -> [bs] -> [bs]
  , decrypt : [ks] -> [bs] -> [bs]
  }

toyCipher : Cipher 8 8
toyCipher = {
  encrypt = \k pt -> k ^ pt,
  decrypt = \k ct -> k ^ ct
}

```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Cipher ks bs =
  { encrypt : [ks] -> [bs] -> [bs]
  , decrypt : [ks] -> [bs] -> [bs]
  }

toyCipher : Cipher 8 8
toyCipher = {
  encrypt = \k pt -> k ^ pt,
  decrypt = \k ct -> k ^ ct
}


evktest : {ks, bs, n} (fin bs)
       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)
evktest(c,vs,pt) = [(c.encrypt k pt, ct')|(k,ct) <- vs | ct' <- cs]
  where cs = [ct]#[ ct ^ c.encrypt k pt | k <- vs | ct <- cs]
```
[GENERATED END]


=== Task 15 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Using ONLY the SHA-512 specification provided in the test setup (which defines a function `sha512` and all supporting constants), define a Cryptol property named `testVector1` with no arguments that checks `sha512` against the following fixed known-answer test vector:

- Message (as a hex literal): 0x616263
- Expected digest (as a hex literal): 0xddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f

The property must *exactly* assert that `sha512` of this message equals this digest.

The full definition of `sha512` (and all helper functions and constants) is ALREADY present in the file from the test setup code. In your answer, you MUST NOT repeat, modify, or redefine `sha512` or any of its helpers, and you MUST NOT add any other top-level declarations.

Your entire answer must be a single top-level declaration starting with:

property testVector1 =

and it must directly assert that `sha512 0x616263` equals the given digest, using those exact hex constants. Do not introduce any arguments, do not wrap it in a module, and do not include any setup code.

### Additional setup code:
```cryptol
sha512 M = result
  where
    M' = (pad M)
    blocks = (groupBy`{1024} M')
    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]
    result = (join (hash!0))

processBlock : [1024] -> [8][64] -> [8][64]
processBlock block Hprev = Hs
  where
    Mi = split block : [16][64]
    Ws = (messageSch Mi)
    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]
    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]

step : [8][64] -> [64] -> [8] -> [8][64]
step [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']
  where
    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt
    T2 = (SIGMA0 a) + (Maj a b c)
    h' = g
    g' = f
    f' = e
    e' = d + T1
    d' = c
    c' = b
    b' = a
    a' = T1 + T2

messageSch : [16][64] -> [80][64]
messageSch Mi = W
  where
    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]

pad : {l, k} (fin l,
              l <= ((2^^128) - 1),
              l >= 0,
              fin k,
              k - l >= 129,
              k == 128 + l + 1 + 1024 - ((l+129)%1024),
              k%1024 == 0) => [l] -> [k]
pad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])

Ch : [64] -> [64] -> [64] -> [64]
Ch x y z = (x && y) ^ ((~x) && z)

Maj : [64] -> [64] -> [64] -> [64]
Maj x y z = (x && y) ^ (x && z) ^ (y && z)

SIGMA0 : [64] -> [64]
SIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)

SIGMA1 : [64] -> [64]
SIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)

sigma0 : [64] -> [64]
sigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)

sigma1 : [64] -> [64]
sigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)

H0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]

K = [
0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
]

```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
sha512 M = result
  where
    M' = (pad M)
    blocks = (groupBy`{1024} M')
    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]
    result = (join (hash!0))

processBlock : [1024] -> [8][64] -> [8][64]
processBlock block Hprev = Hs
  where
    Mi = split block : [16][64]
    Ws = (messageSch Mi)
    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]
    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]

step : [8][64] -> [64] -> [8] -> [8][64]
step [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']
  where
    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt
    T2 = (SIGMA0 a) + (Maj a b c)
    h' = g
    g' = f
    f' = e
    e' = d + T1
    d' = c
    c' = b
    b' = a
    a' = T1 + T2

messageSch : [16][64] -> [80][64]
messageSch Mi = W
  where
    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]

pad : {l, k} (fin l,
              l <= ((2^^128) - 1),
              l >= 0,
              fin k,
              k - l >= 129,
              k == 128 + l + 1 + 1024 - ((l+129)%1024),
              k%1024 == 0) => [l] -> [k]
pad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])

Ch : [64] -> [64] -> [64] -> [64]
Ch x y z = (x && y) ^ ((~x) && z)

Maj : [64] -> [64] -> [64] -> [64]
Maj x y z = (x && y) ^ (x && z) ^ (y && z)

SIGMA0 : [64] -> [64]
SIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)

SIGMA1 : [64] -> [64]
SIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)

sigma0 : [64] -> [64]
sigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)

sigma1 : [64] -> [64]
sigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)

H0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]

K = [
0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
]


property testVector1 =
  sha512 0x616263 ==
    0xddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f
```
[GENERATED END]


=== Task 16 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Using ONLY the definitions `mk_buggy_fib_no_init`, `generate`, the infix operator `$`, and the sequences `foo` and `bar` provided in the test setup, define a Cryptol property named `fooEqualsBar` with no arguments that asserts that `foo` and `bar` are exactly equal. Do not redefine any of these functions or values; only provide the definition of `property fooEqualsBar`.

### Additional setup code:
```cryptol
mk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->
  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))
mk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))
  where
  fn2 = fn + fn1
  // Change output when state has magic value.
  fn' = fn + if k == magic then 1 else 0

generate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a
generate f = [ f i | i <- [0 .. n-1] ]

infixl 1 $
f $ x = f x

foo : [10][4]
foo = generate $ \(i:[8]) -> if i == 0 then 1 else foo@(i-1)

bar : [10][4]
bar = generate \(i:[8]) -> if i == 0 then 1 else foo@(i-1)

```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
mk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->
  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))
mk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))
  where
  fn2 = fn + fn1
  // Change output when state has magic value.
  fn' = fn + if k == magic then 1 else 0

generate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a
generate f = [ f i | i <- [0 .. n-1] ]

infixl 1 $
f $ x = f x

foo : [10][4]
foo = generate $ \(i:[8]) -> if i == 0 then 1 else foo@(i-1)

bar : [10][4]
bar = generate \(i:[8]) -> if i == 0 then 1 else foo@(i-1)


property fooEqualsBar = foo == bar
```
[GENERATED END]


=== Task 17 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the function `unflatten : {r,w} (fin r, 5 * w >= r, fin w) => [r] -> [w][5]` that pads its input with zeros and groups it into `w` blocks of 5 elements using `groupBy` in Cryptol. DO NOT include import statements, module declarations, or any other code.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
unflatten : {r, w}
  (fin r, 5 * w >= r, fin w) =>
    [r] -> [w][5]
unflatten p = groupBy`{5} (p # zero)
```
[GENERATED END]


=== Task 18 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol file that defines the functions `mk_curve_ops`, `ec_v1`, and `ec_v2`. The definition must follow the exact structure shown in the prompt: `mk_curve_ops` must construct a record containing fields `field`, `v1`, and `v2`, where `v1` calls `ec_v1` on the input parameter and `v2` calls `ec_v2` on the record being constructed. The functions must use the polymorphic types exactly as shown and must access `p.field.v0` correctly in `ec_v2`. The file must contain no module declaration and must consist only of the three definitions.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
mk_curve_ops p =
  { field = p.field,
    v1 = ec_v1 p,
    v2 = ec_v2 { field = p.field, v0 = 123 }
  }

ec_v1 p = "ec_v1 " # p.v0

ec_v2 p = "ec_v2 " # p.v0
```
[GENERATED END]


=== Task 19 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module named `T038` that declares an interface submodule `I` providing `x : [8]`, a submodule `F` that imports interface submodule `I` and defines `y = x + 1`, a submodule `P` that imports submodule `F` while exposing submodule `Q`, a submodule `Q` that defines `x = 11`, and finally an interface submodule `J` that imports submodule `F` through `P`. The structure must match the Cryptol module system rules exactly.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module T038 where

interface submodule I where
  x : [8]

submodule F where
  import interface submodule I

  y = x + 1

submodule P where
  import submodule F
  export submodule Q

submodule Q where
  x = 11

interface submodule J where
  import submodule F via submodule P
```
[GENERATED END]


=== Task 20 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Reproduce exactly the four foreign function declarations `foreignAndCryptol`, `foreignAndNoCryptol`, `noForeignAndCryptol`, and `noForeignAndNoCryptol`, each using the C calling convention. Implement `foreignAndCryptol` to return its argument unchanged, leave `foreignAndNoCryptol` unimplemented, implement `noForeignAndCryptol` to return `x + 3`, and leave `noForeignAndNoCryptol` unimplemented. The file must contain only these four declarations.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
foreign foreignAndCryptol : [32] -> [32]
foreignAndCryptol x = x

foreign foreignAndNoCryptol : [32] -> [32]

noForeignAndCryptol : [32] -> [32]
noForeignAndCryptol x = x + 3

foreign noForeignAndNoCryptol : [32] -> [32]
```
[GENERATED END]


=== Task 21 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Write a Cryptol module implementing parameterized AES encryption and decryption for key sizes 128, 192, and 256 bits. The module must import the AES algorithm, key expansion, and T-box modules exactly as specified, define `encrypt` and `decrypt` in terms of expanded keys, and include a property named `test` verifying that `decrypt k (encrypt k pt) == pt` for all valid keys and all 128-bit plaintexts.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128 where
    type KeySize = 128
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192 where
    type KeySize = 192
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256 where
    type KeySize = 256

import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128::KeySchedule
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192::KeySchedule
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256::KeySchedule

import Primitive::Symmetric::Cipher::Block::AES::TBox

encrypt : {k} (fin k, 128 <= k, k % 64 == 0) => [k] -> [128] -> [128]
encrypt k = encryptWithExpandedKey (expandKey k)

decrypt : {k} (fin k, 128 <= k, k % 64 == 0) => [k] -> [128] -> [128]
decrypt k = decryptWithExpandedKey (expandKey k)

property test k pt = decrypt k (encrypt k pt) == pt
```
[GENERATED END]


=== Task 22 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Write a complete Cryptol module implementing the Bivium stream cipher. The module must define `Bivium_stream`, `Bivium`, `Bivium_alt`, and all cycle-testing helpers. It must also define the four properties: `Bivium_correct`, `Bivium_search`, `Bivium_search_with_suffix`, and `Bivium_alt_equivalent`, using the exact IVs, suffix, and test keystream provided. The file must match the structure and behavior of the Bivium specification.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
type t = 128

type n = 64

type m = 32

type k = 10

type l = 12

type m1 = 4

type m2 = 28

type m3 = 28

type m4 = 32

type m5 = 32

type m6 = 32

type m7 = 64

type m8 = 64

type m9 = 64

type m10 = 128

type m11 = 128

type m12 = 128

type m13 = 128

type m14 = 128

type m15 = 128

type m16 = 128

type m17 = 128

type m18 = 128

type m19 = 128

type m20 = 128

type m21 = 128

type m22 = 128

type m23 = 128

type m24 = 128

type m25 = 128

type m26 = 128

type m27 = 128

type m28 = 128

type m29 = 128

type m30 = 128

type m31 = 128

type m32 = 128

type m33 = 128

type m34 = 128

type m35 = 128

type m36 = 128

type m37 = 128

type m38 = 128

type m39 = 128

type m40 = 128

type m41 = 128

type m42 = 128

type m43 = 128

type m44 = 128

type m45 = 128

type m46 = 128

type m47 = 128

type m48 = 128

type m49 = 128

type m50 = 128

type m51 = 128

type m52 = 128

type m53 = 128

type m54 = 128

type m55 = 128

type m56 = 128

type m57 = 128

type m58 = 128

type m59 = 128

type m60 = 128

type m61 = 128

type m62 = 128

type m63 = 128

type m64 = 128

type m65 = 128

type m66 = 128

type m67 = 128

type m68 = 128

type m69 = 128

type m70 = 128

type m71 = 128

type m72 = 128

type m73 = 128

type m74 = 128

type m75 = 128

type m76 = 128

type m77 = 128

type m78 = 128

type m79 = 128

type m80 = 128

type m81 = 128

type m82 = 128

type m83 = 128

type m84 = 128

type m85 = 128

type m86 = 128

type m87 = 128

type m88 = 128

type m89 = 128

type m90 = 128

type m91 = 128

type m92 = 128

type m93 = 128

type m94 = 128

type m95 = 128

type m96 = 128

type m97 = 128

type m98 = 128

type m99 = 128

type m100 = 128

type m
```
[GENERATED END]


=== Task 23 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol property that tests the function described below.

### Request:
Task: Write a Cryptol module implementing the FNV-1a 64-bit hash function, including padding, the FNV offset basis, prime constant, the block-processing logic, and a property `testsPass` that verifies the hash of the empty string, "a", and "foobar" equals the known answer test vectors provided.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
fnv1a : {n} (fin n) => [n] -> [64]
fnv1a msg =
  foldl (\state b -> state ^ b ^ fnv1a_prime) fnv1a_offset_basis (msg # pad)
  where
    type R = 8
    type M = 64
    pad : [((M + R - 1) / R) * R]
    pad = zero

    fnv1a_offset_basis : [64]
    fnv1a_offset_basis = 0xcbf29ce484222325

    fnv1a_prime : [64]
    fnv1a_prime = 1099511628211

property testsPass =
  ~zero == fnv1a [] /\
  0x8cb18eb96fb0a30e == fnv1a "a" /\
  0x842831b67c7eae6b == fnv1a "foobar"
```
[GENERATED END]


=== Task 24 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA384` that instantiates the generic SHA-2 specification for SHA-384 with 64-bit words, 384-bit digest size, and the given 8-word initial hash vector `H0`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 =
    Primitive::Keyless::Hash::SHA2::SHA2 where

        type w = 64
        type DigestSize = 384
        H0 = [
            0x9dd1b4dc6d179ebc,
            0x9480e59d9f24b90b,
            0x1f83d9abfb41bd6b,
            0x5be0cd191f618a05,
            0x1fa27cf883126026,
            0xc33bfe9ceb5ae858,
            0xfd987192a4b12643,
            0x198baee54f98137e
        ]
```
[GENERATED END]


=== Task 25 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 with an xof function imported from the SHAKE256 instantiation and properties k5–k8 that assert xof applied to [], 0b0, 0b11, and 0b110 equals the given 512-bit expected_result constants.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 where

import Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO
import Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256

property k5 = xof [] == expected_result
property k6 = xof 0b0 == expected_result
property k7 = xof 0b11 == expected_result
property k8 = xof 0b110 == expected_result

expected_result =
  join
    [KBO::fromInteger 0x51a8691640f6c7d4,
    KBO::fromInteger 0x7270472385696399,
    KBO::fromInteger 0x47840426285e4109,
    KBO::fromInteger 0x6613834a94651632]
```
[GENERATED END]


=== Task 26 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module that instantiates SHA3-224 and defines properties t1, t5, t72, and t512 that check the hash and hashBytes functions against the given known-answer test vectors.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
import Hash::SHA3

property t1 = hash [] == take `{224} 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
property t5 = hash "abc" == take `{224} 0xba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad
property t72 = hash "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" == take `{224} 0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1
property t512 = hash "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu" == take `{224} 0xfd4401c830638068517384741f2d624ea6047c4027439703649b295670290251
```
[GENERATED END]


=== Task 27 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that models the Kalotan logic puzzle with parents and child as Bits, defines the given constraints (heterosexual parents, kid lying, parents’ statements), and includes properties equivalent to people_types, checkit1, and checkit2 capturing the valid/invalid configurations.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
heterosexual : Bit -> Bit -> Bit
heterosexual parent child = ~(parent == child)

parents_say : Bit -> Bit -> Bit
parents_say p c = ~p

kid_says : Bit -> Bit
kid_says c = c

people_types : Bit -> Bit -> Bit -> Bit
property people_types p c k = (heterosexual p c) /\ (parents_say p c) /\ (kid_says k)

checkit1 : Bit -> Bit -> Bit -> Bit
property checkit1 p c k = ~((heterosexual p c) /\ (parents_say p c) /\ (kid_says k))

checkit2 : Bit -> Bit -> Bit -> Bit
property checkit2 p c k = (heterosexual p c) /\ (parents_say p c) /\ (kid_says k)
```
[GENERATED END]


=== Task 28 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification for a parameterized SHA-2 style hash function over word size w, defining sha : {L} (2 * w >= width L) => [L] -> [digest_size] and all supporting types, constants (H0, K), and functions (padding, parsing, message schedule, compression, and block processing).

### Additional setup code:
```cryptol
Ch_Alternate : {w} (fin w, w >= 1) => [w] -> [w] -> [w] -> [w]
Ch_Alternate x y z = (x /\ y) \/ (~x /\ z)
```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
Ch_Alternate : {w} (fin w, w >= 1) => [w] -> [w] -> [w] -> [w]
Ch_Alternate x y z = (x /\ y) \/ (~x /\ z)

```cryptol
module Primitive::Keyless::Hash::SHA2::SHA2 where

import Common::ModArith

parameter

  type w : #
  type constraint (fin w, w >= 1)

type digest_size = 8*w

sha : {L} (2 * w >= width L) => [L] -> [digest_size]
sha M = take`{digest_size} (join (reverse (foldl blocks H0 (parse (pad M)))))

private

  pad : {L} (2 * w >= width L) => [L] -> [L + w + 1]
  pad M = M # zero # True

  type block_size = 16*w

  type nb = (L + w + 1)/block_size

  parse : {L} (2 * w >= width L) => [L + w + 1] -> [nb][block_size]
  parse M = split M

  H0 : [8][w]
  H0 =
    [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
      0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ]

  K : [64][w]
  K =
    [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
      0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
      0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
      0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf59eb67,
      0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
      0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
      0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
      0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
      0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc6
```
[GENERATED END]


=== Task 29 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Create a function that performs modulo addition with the signature `mod_add_Z : (Integer, Integer, Integer) -> Integer`. The first parameter is the modulo base.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
mod_add_Z : (Integer, Integer, Integer) -> Integer
mod_add_Z (n, x, y) = (x + y) % n
```
[GENERATED END]


=== Task 30 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Create a function that multiplies a number with itself using modulo multiplication. Define the following functions `mod_mul_Z : (Integer, Integer, Integer) -> Integer` and `mod_sq_Z : (Integer, Integer) -> Integer`. The first parameter should be the modulo base for both functions. `mod_sq_Z` should call `mod_mul_Z` to perform the modulo multiplication.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
mod_mul_Z : (Integer, Integer, Integer) -> Integer
mod_mul_Z (m, x, y) = (x * y) % m

mod_sq_Z : (Integer, Integer) -> Integer
mod_sq_Z (m, x) = mod_mul_Z (m, x, x)
```
[GENERATED END]


=== Task 31 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the function `mod_div_Z : (Integer, Integer, Integer) -> Integer` that performs modulo division between two integers. The modulo base is the first parameter. You should implement Stein's algorithm and call `mod_half_Z` to perform modulo division by 2. The resulting file should only have two functions and be standalone.

### Additional setup code:
```cryptol
mod_half_Z : (Integer, Integer) -> Integer
mod_half_Z (p, x) = if (x % 2 == 0) then x / 2 else (x + p) / 2

```
[PROMPT END]

[GENERATED BEGIN]
```cryptol
mod_half_Z : (Integer, Integer) -> Integer
mod_half_Z (p, x) = if (x % 2 == 0) then x / 2 else (x + p) / 2


mod_div_Z : (Integer, Integer, Integer) -> Integer
mod_div_Z (p, y, x) =
  if y == 1 then x
           else if y % 2 == 0 then mod_div_Z (p, y / 2, mod_half_Z (p, x))
                            else mod_div_Z (p, (y - 1) / 2, mod_half_Z (p, mod_half_Z (p, x)))

mod_half_Z : (Integer, Integer) -> Integer
mod_half_Z (p, x) = if (x % 2 == 0) then x / 2 else (x + p) / 2
```
[GENERATED END]


=== Task 32 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Create a Cryptol specification that performs the SHA-512 message schedule expansion. Define the functions `messageSch : [16][64] -> [80][64]`, `sigma0 : [64] -> [64]`, and `sigma1 : [64] -> [64]` to perform the message expansion.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
type MessageBlock = [16][64]
type ExpandedMessage = [80][64]
type Word64 = [64]

sigma0 : Word64 -> Word64
sigma0 x =
  ((x >>> 28) ^ (x >>> 34) ^ (x >>> 39))

sigma1 : Word64 -> Word64
sigma1 x =
  ((x >>> 14) ^ (x >>> 18) ^ (x >>> 41))

messageSch : MessageBlock -> ExpandedMessage
messageSch M =
  M # [ (sigma1 (M @ (i - 2)) + M @ (i - 7) + sigma0 (M @ (i - 15)) + M @ (i - 16))
       | i <- [16 .. 79]]
```
[GENERATED END]


=== Task 33 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the property `tcId1080` that checks, for AES-256 Key Wrap with padding in AE mode, that encrypting the plaintext `0x06` under the key `0x3ea9325069ed93a96c331bdd6dd766ec64bbba83a72c69ed75df55043fb0bfd1` with `KWP_AE` produces the expected ciphertext `0x40a9c42012ba38211b800e6e313b6876`, using the helper `check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct`.

[PROMPT END]

[GENERATED BEGIN]
```cryptol
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap


check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct
/* pragma tcId1080 : property */
tcId1080 =
  testPassed == check_KWP_AE key pt ct
  where
    testPassed = True
    key =
      0x3ea9325069ed93a96c331bdd6dd766ec64bbba83a72c69ed75df55043fb0bfd1
    pt = 0x06
    ct = 0x40a9c42012ba38211b800e6e313b6876
```
[GENERATED END]


=== Task 34 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the Cryptol module `Primitive::Symmetric::Cipher::Block::AES::SubByteSBox` implementing the AES SubBytes and InvSubBytes transformations with functions `SubByte : GF28 -> GF28` and `InvSubByte : GF28 -> GF28`, using `sbox` and `sboxInv` over `GF28` elements.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
module Primitive::Symmetric::Cipher::Block::AES::SubByteSBox where

import Primitive::Symmetric::Cipher::Block::AES::GF28

type sbox = [256]GF28
type sboxInv = [256]GF28

SubByte : GF28 -> GF28
SubByte x = sbox @ x

InvSubByte : GF28 -> GF28
InvSubByte x = sboxInv @ x

sbox = [
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,
    0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,
    0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,
    0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,
    0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,
    0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,
    0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,
    0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,
    0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,
    0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,
    0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,
    0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,
    0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,
    0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0
```
[GENERATED END]


=== Task 35 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification for the McEliece KEM low-level Operations module, defining the functions crypto_kem_enc and crypto_kem_dec (and their helper hash functions) with appropriate types and ensuring they match the intended McEliece KEM encryption and decryption behavior.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Asymmetric::KEM::McEliece::Operations where

import Primitive::Symmetric::Hash::SHA256 as SHA256
import Primitive::Asymmetric::KEM::McEliece::Common as Common
import Primitive::Asymmetric::KEM::McEliece::GoppaCode as GoppaCode
import Primitive::Asymmetric::KEM::McEliece::HuffmanCoding as HuffmanCoding

crypto_kem_enc : [1024][8] -> [32][8] -> [32][8] -> [64][8] -> [1024][8]
crypto_kem_enc h s m seed = c # r # e'
    where
        (c, e') = GoppaCode::encode c' e
        c'      = GoppaCode::encrypt c e s
        e       = generate_e h m seed
        r       = generate_r e
        c'      = c'

generate_e : [1024][8] -> [32][8] -> [64][8] -> [64][8]
generate_e h m seed = e
    where
        e = SHA256::hashBytes (h # m # seed)

generate_r : [64][8] -> [32][8]
generate_r e = take e

crypto_kem_dec : [32][8] -> [1024][8] -> ([64][8], Bit)
crypto_kem_dec s c = (e', f)
    where
        (e', f) = GoppaCode::decode c s
```
[GENERATED END]


=== Task 36 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Specify the Cryptol types and full implementations for load2, bitrev, store8, load8, and transpose_64x64 used in a McEliece KEM utility module, matching the shown bitwise behavior and using the imported Types definitions.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Asymmetric::KEM::McEliece::Util where

import Common::Types
import Types

load2 : [16] -> [2][8]
load2 x = split x

bitrev : [8] -> [8]
bitrev x = join (reverse (split x))

store8 : [8] -> [8][8]
store8 x = reverse (split x)

load8 : [8][8] -> [8]
load8 x = join (reverse x)

transpose_64x64 : [64][64]a -> [64][64]a
transpose_64x64 x =
  transpose `{n=64} x
```
[GENERATED END]


=== Task 37 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module that defines the same ECDSA test properties for NIST curves P-192, P-224, P-256, P-384, and P-521, including point decompression, point addition/subtraction, doubling, scalar and joint scalar multiplication, and mp_mod_sqrt correctness, matching the constants and structure shown.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
import Parameters
import ShortWeierstrassCurve
import FieldExtras
import HashToCurveEcdsa

property ecdsaP192PointDecompressionWorks = decompressECDSAPoint' P192 gxB gxA == (gxA, gxB)

property ecdsaP224PointDecompressionWorks = decompressECDSAPoint' P224 gxB gxA == (gxA, gxB)

property ecdsaP256PointDecompressionWorks = decompressECDSAPoint' P256 gxB gxA == (gxA, gxB)

property ecdsaP384PointDecompressionWorks = decompressECDSAPoint' P384 gxB gxA == (gxA, gxB)

property ecdsaP521PointDecompressionWorks = decompressECDSAPoint' P521 gxB gxA == (gxA, gxB)

property ecdsaP192PointAdditionWorks = addPoints' P192 (x,y) (x',y') == (x'',y'')
property ecdsaP224PointAdditionWorks = addPoints' P224 (x,y) (x',y') == (x'',y'')
property ecdsaP256PointAdditionWorks = addPoints' P256 (x,y) (x',y') == (x'',y'')
property ecdsaP384PointAdditionWorks = addPoints' P384 (x,y) (x',y') == (x'',y'')
property ecdsaP521PointAdditionWorks = addPoints' P521 (x,y) (x',y') == (x'',y'')

property ecdsaP192PointSubtractionWorks = subtractPoints' P192 (x,y) (x',y') == (x'',y'')
property ecdsaP224PointSubtractionWorks = subtractPoints' P224 (x,y) (x',y') == (x'',y'')
property ecdsaP256PointSubtractionWorks = subtractPoints' P256 (x,y) (x',y') == (x'',y'')
property ecdsaP384PointSubtractionWorks = subtractPoints' P384 (x,y) (x',y') == (x'',y'')
property ecdsaP521PointSubtractionWorks = subtractPoints' P521 (x,y) (x',y') == (x'',y'')

property ecdsaP192PointDoublingWorks = doublePoint' P192 (x,y) == (x'',y'')
property ecdsaP224PointDoublingWorks = doublePoint' P224 (x,y) == (x'',y'')
property ecdsaP256PointDoublingWorks = doublePoint' P256 (x,y) == (x'',y'')
property ecdsaP384PointDoublingWorks = doublePoint' P384 (x,y) == (x'',y'')
property ecdsaP521PointDoublingWorks = doublePoint' P521 (x,y) == (x'',y'')

property ecdsaP192ScalarMultWorks = ecdsaScalarMult' P192 d x y == (x'',y'')
property ecdsaP224ScalarMultWorks = ecdsaScalarMult' P224 d x y == (x'',y'')
property ecdsaP256ScalarMultWorks = ecdsaScalarMult' P256 d x y == (x'',y'')
property ecdsaP384ScalarMultWorks = ecdsaScalarMult' P384 d x y == (x'',y'')
property ecdsaP521ScalarMultWorks = ecdsaScalarMult' P521 d x y == (x'',y'')

property ecdsaP192JointScalarMultWorks = jointECDSAScalarMult' P192 d x y d' x' y' == (x'',y'')
property ecdsaP224JointScalarMultWorks = jointECDSAScalarMult' P224 d x y d' x' y' == (x'',y'')
property ecdsaP256JointScalarMultWorks = jointECDSAScalarMult' P256 d x y d' x' y' == (x'',y'')
property ecdsaP384JointScalarMultWorks = jointECDSAS
```
[GENERATED END]


=== Task 38 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module implementing the HMAC construction with a SHA-256-based instance `hmacSHA256`, including the helper function `kinit` and the generic `hmac` function with the given polymorphic sizes and type constraints.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA256 where
import Primitive::Symmetric::MAC::HMAC::HMAC
import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256

type KInitLen = 64
type BlockLen = 64
type HLen = 32

kinit : {keyLen} (fin keyLen, 64 >= width keyLen) => [keyLen] -> [KInitLen]
kinit k = take `{64} (k0 # zero)
    where
        type L = 8 * keyLen
        k0 : [L]
        k0 = join k

hmacSHA256 : {msgLen}
    ( fin msgLen
    , 64 >= width msgLen
    ) => [64][8] -> [msgLen][8] -> [HLen][8]
hmacSHA256 = hmac `{BlockLen,Bit} sha256
```
[GENERATED END]


=== Task 39 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module that defines properties `fp2_frobenius_prop`, `f6_frobenius_prop`, and `f12_frobenius_prop` asserting that `fp2_frobenius`, `fp6_frobenius`, and `fp12_frobenius` equal `F_expt` over `P::Fp_2`, `P::Fp_6`, and `P::Fp_12` (after normalization) using the prime `p : [381] = P::p`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
import Common::FieldExtras

module Frobenius where

import Parameters as P

import FrobeniusImpl

fp2_frobenius_prop = fp2_frobenius x == F_expt x
  where
    x = fp2_normalize (P::Fp_2::fromInteger 0x3597763e96043065976d9548457951108417639761572578564545358538357936839661913431557894413839555578751647147143786571315716856584485984874686908938577517358436731578731557188857189666417768171677111868946685111655373936813588358733667866484375383398776143374687116948954579518036981955786416351561184771734941311114673917773617367976167336958589744886359837949596687811595743839117885845353653338999961535167311488968635545874771533618989759987931137618678673641759243461535163958766933171197343453844177768188716581847316457979345567717756535555186583787145993874710139995857188571941555143718381798941613866388361615437587411179975480578751673113777691891141851793358995649797487145187963384755677759978664555936796564604674786793969399156437644544445949566553969598364648519916514659135597348790869694544334141989135761576831435944161749355479666373119753146614984998676164845187585768675967948693887749797449933610537183818588860569958105861578396517634
```
[GENERATED END]


=== Task 40 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the function `core_verify_pk_in_g1` that verifies a BLS signature in G1 by comparing two `bls_ate_pairing` results (one using the public key and `hash_to_curve_opt(msg, dst)`, and the other using the base point `BP` and the signature), returning an `Fp_12.is_equal` boolean.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module implementation::CoreVerify where

import Parameters
import ShortWeierstrassCurve
import implementation::Pairing
import HashToG1Optimized

core_verify_pk_in_g1 : {msg_len,dst_len}
    ( fin msg_len
    , fin dst_len
    , fp_is_val (hash_to_curve_opt' msg_len dst_len)
    ) =>  (FP_12, BP_G1, [msg_len][8], [dst_len][8]) -> Bit
core_verify_pk_in_g1 (pk, sig, msg, dst) =
    Fp_12.is_equal r1 r2
    where
        r1 = bls_ate_pairing pk h
        r2 = bls_ate_pairing BP sig
        h = hash_to_curve_opt' msg dst
```
[GENERATED END]


=== Task 41 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module `Pairing` that specifies the BLS optimal ate pairing over the BN curve, including `bls_ate_pairing`, `ate_pairing`, the Miller loop (`miller_step`, `line_function`), and the final exponentiation using Frobenius maps, with appropriate types and intermediate helpers.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
module Pairing where

import Parameters
import ShortWeierstrassCurve as EC
import Frobenius

type t_Fp = Z p
type t_Fp2 = (t_Fp, t_Fp)
type t_Fp12 = (t_Fp2, t_Fp2, t_Fp2)

type t_E = EC::EC t_Fp
type t_E' = EC::EC t_Fp2

type t_G1 = EC::AffinePoint t_E
type t_G2 = EC::AffinePoint t_E'

G1 = { x = 0x543e34c8627b2d415691c6079e885456920523244710414a08972253743112a8f10e698769591804957d45468e0567114270396611702892961926764007873735580397841495426595231087978055790299768517853535117763652738084515366481368967535338663753441596431577591163728064981946707356695048730667042818665257568694819963561391789573956936582577756549486145138471618777683419779453461445496097434355837351775178574731834518373455599919148864330987653579868768113776567554987951995861140841518561491554837034577605539366445694495786219667747188749831483331837445895755837131574566754339775543437988719587378866543341397176593886673767943013708877598900718262600880482577094746561333637691891545375348693869369378245604668175547987064413176486893879893588442645850673399582552103715493663575776169488114397135411331774375413486368719866635818615998511005756179193455783387631576447675569629952781074634314641431471447371571
```
[GENERATED END]


=== Task 42 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Specify and verify in Cryptol the BLS key generation procedure `KeyGen_rep` using HKDF-SHA256 and Montgomery arithmetic, including the properties `keygen_finish_integer`, `keygen_finish_bv`, and `le_bytes_from_limbs_rep4_prop` over the defined 256/512-bit representations.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
import Parameters as P
import ShortWeierstrassCurve as EC
import HashToCurveE2 as H2C
import HashToCurveE2Rep4 as H2CRep4
import KeyPair as K
import Pairing as BP
import ShortWeierstrassCurveRep4 as ECRep4
import ShortWeierstrassCurveRep4EC as ECRep4EC
import ShortWeierstrassCurveRep4ECRep4 as ECRep4ECRep4
import ShortWeierstrassCurveRep4Rep4 as ECRep4Rep4
import Spec_BLS_KeyGen
import Spec_BLS_KeyGen_HKDF
import Spec_BLS_KeyGen_Rep4
import Spec_BLS_KeyGen_Rep4EC
import Spec_BLS_KeyGen_Rep4ECRep4
import Spec_BLS_KeyGen_Rep4Rep4
import Spec_BLS_KeyGen_HKDF_Rep4
import Spec_BLS_KeyGen_HKDF_Rep4EC
import Spec_BLS_KeyGen_HKDF_Rep4ECRep4
import Spec_BLS_KeyGen_HKDF_Rep4Rep4
import Spec_BLS_KeyGen_HKDF_Rep4ECRep4

type t_Fp = P::t_Fp
type t_Fp' = P::t_Fp'
type t_Fq = P::t_Fq
type t_Fq' = P::t_Fq'
type t_Fq'' = P::t_Fq''
type t_Fq''' = P::t_Fq'''
type t_Fq'''' = P::t_Fq''''

type t_Fp_384 = P::t_Fp_384
type t_Fp_384' = P::t_Fp_384'
type t_Fq_384 = P::t_Fq_384
type t_Fq_384' = P::t_Fq_384'
type t_Fq_384'' = P::t_Fq_384''
type t_Fq_384''' = P::t_Fq_384'''
type t_Fq_384'''' = P::t_Fq_384''''

type t_Fp_512 = P::t_Fp_512
type t_Fp_512' = P::t_Fp_512'
type t_Fq_512 = P::t_Fq_512
type t_Fq_512' = P::t_Fq_512'
type t_Fq_512'' = P::t_Fq_512''
type t_Fq_512''' = P::t_Fq_512'''
type t_Fq_512'''' = P::t_Fq_512''''

type n = P::n
type n' = P::n'
type s = P::s
type s' = P::s'
type s'' = P::s''
type s''' = P::s'''

type t_Fp_n = P::t_Fp_n
type t_Fp_n' = P::t_Fp_n'
type t_Fq_n = P::t_Fq_n
type t_Fq_n' = P::t_Fq_n'
type t_Fq_n'' = P::t_Fq_n''
type t_Fq_n''' = P::t_Fq_n'''
type t_Fq_n'''' = P::t_Fq_n''''

type t_Fp_s = P::t_Fp_s
type t_Fp_s' = P::t_Fp_s'
type t_Fq_s = P::t_Fq_s
type t_Fq_s' = P::t_Fq_s'
type t_Fq_s'' = P::t_Fq_s''
type t_Fq_s''' = P::t_Fq_s'''
type t_Fq_s'''' = P::t_Fq_s''''

type t_Fp_s_512 = P::t_Fp_s_512
type t_Fp_s_512' = P::t_Fp_s_512'
type t_Fq_s_512 = P::t_Fq_s_512
type t_Fq_s_512' = P::t_Fq_s_512'
type t_Fq_s_512'' = P::t_Fq_s_512''
type t_Fq_s_512''' = P::t_Fq_s_512'''
type t_Fq_s_512'''' = P::t_Fq_s_512''''

type t
```
[GENERATED END]


=== Task 43 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Names` that defines the given parameters, types, functions, primitive declarations, and the property `enc_correct : [64] -> Bit` asserting `x == enc (enc x)` for all 64-bit inputs, matching the structure implied by the excerpt.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
module Names where

parameter

  type n : #
  type constraint (fin n)

  type m : #
  type constraint (fin m)

  type t : #

  type u : #

  type v : #

  type w : #

  type x : #

  type y : #

  type z : #

  type a : #

  type b : #

  type c : #

  type d : #

  type e : #

  type f : #

  type g : #

  type h : #

  type i : #

  type j : #

  type k : #

  type l : #

  type m' : #

  type n' : #

  type o : #

  type p : #

  type q : #

  type r : #

  type s : #

  type t' : #

  type u' : #

  type v' : #

  type w' : #

  type x' : #

  type y' : #

  type z' : #

  type a' : #

  type b' : #

  type c' : #

  type d' : #

  type e' : #

  type f' : #

  type g' : #

  type h' : #

  type i' : #

  type j' : #

  type k' : #

  type l' : #

  type m'' : #

  type n'' : #

  type o' : #

  type p' : #

  type q' : #

  type r' : #

  type s' : #

  type t'' : #

  type u'' : #

  type v'' : #

  type w'' : #

  type x'' : #

  type y'' : #

  type z'' : #

  type a'' : #

  type b'' : #

  type c'' : #

  type d'' : #

  type e'' : #

  type f'' : #

  type g'' : #

  type h'' : #

  type i'' : #

  type j'' : #

  type k'' : #

  type l'' : #

  type m''' : #

  type n''' : #

  type o'' : #

  type p'' : #

  type q'' : #

  type r'' : #

  type s'' : #

  type t''' : #

  type u''' : #

  type v''' : #

  type w''' : #

  type x''' : #

  type y''' : #

  type z''' : #

  type a''' : #

  type b''' : #

  type c''' : #

  type d''' : #

  type e''' : #

  type f''' : #

  type g''' : #

  type h''' : #

  type i''' : #

  type j''' : #

  type k''' : #

  type l''' : #

  type m'''' : #

  type n'''' : #

  type o''' : #

  type p''' : #

  type q''' : #

  type r''' : #

  type s''' : #

  type t'''': #

  type u'''': #

  type v'''': #

  type w'''': #

  type x'''': #

  type y'''': #

  type z'''': #

  type a'''': #

  type b'''': #

  type c'''': #

  type d'''': #

  type e'''': #

  type f'''': #

  type g'''': #

  type h'''': #

  type i'''': #

  type j'''': #

  type k'''': #

  type l'''': #

  type m''''' : #

  type n''''' : #

  type o'''': #

  type p'''': #

  type q'''': #

  type r'''': #

  type s'''': #

  type t'''': #

  type u'''': #

  type v'''': #

  type w'''': #

  type x'''': #

  type y'''': #

  type z'''': #

  type a'''': #

  type b'''': #

  type c'''': #

  type d'''': #

  type e'''': #

  type f'''': #

  type g'''': #

  type h'''': #

  type i'''': #

  type j'''': #

  type k'''': #

  type l'''': #

  type m'''''' : #

  type n'''''' : #

  type o'''': #

  type p'''': #

  type q'''': #

  type r'''': #

  type s'''': #

  type t'''': #

  type u'''': #

  type v'''': #

  type w'''': #

  type x'''': #

  type y'''': #

  type z'''': #

  type a'''': #

  type b'''': #

  type c'''': #

  type d'''': #

  type e'''
```
[GENERATED END]


=== Task 44 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: In Cryptol, define bitvector update functions `update` and `updateEnd` on 16-bit words and properties `wordUpdate`, `wordUpdate2`, `wordUpdateEnd`, and `wordUpdateEnd2` that verify these functions match both mask-based and index-based formulations for indices `y < 16`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
update : [16] -> [4] -> [16] -> [16]
update x y v = x || ((v && m) << y)
    where m = 0xFFFF >> y

updateEnd : [16] -> [4] -> [16] -> [16]
updateEnd x y v = x || ((v && m) >> (15 - y))
    where m = 0xFFFF >> y

property wordUpdate y =
    y < 16 ==> update (1 << 15) y (1 << (y + 3)) == (1 << 15) + (1 << (y + 3))

property wordUpdate2 y =
    y < 16 ==> update (1 << 15) y (1 << y) == (1 << 15) + (1 << y)

property wordUpdateEnd y =
    y < 16 ==> updateEnd (1 << 15) y (1 << (y + 3)) == (1 << 15) + (1 << (y + 3))

property wordUpdateEnd2 y =
    y < 16 ==> updateEnd (1 << 15) y (1 << y) == (1 << 15) + (1 << y)
```
[GENERATED END]


=== Task 45 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the function `xor : {a} ([a], [a]) -> [a]` as element-wise inequality on two sequences, and define `check24` as a property asserting that for all 4-bit `x` and `y`, `xor` equals the built-in bitwise XOR `(^)` and that this holds for all values.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
xor : {a} ([a], [a]) -> [a]
xor (x, y) = x ^ y

property check24 = all (\x -> all (\y -> xor (x, y) == x ^ y)) [0..15]
```
[GENERATED END]


=== Task 46 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: In Cryptol, define the sequence `xs` as given and the value `check28` that asserts the list comprehension `[ x == y | (x,y) <- xs ]` is equal to `~zero`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
import Float

xs = [ 0x123456789abcde00, 0x123456789abcde01 .. 0x123456789abcdeff ]

check28 = [ x == y | (x,y) <- xs ]
```
[GENERATED END]


=== Task 47 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: In Cryptol, reproduce these parameterized sequence type declarations and their constant zero definitions, ensuring that the arithmetic in the sequence length expressions is well-typed and equivalent (e.g., for f/g, ff/gg, jj/kk).


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type f n = [n - 1]Bit
zero : {n} (fin n) => f n
zero = take `{(n-1)} (zero : [n]Bit)

type ff n = [n - 2 * (n >= 1)]Bit
zero : {n} (fin n) => ff n
zero = take `{(n-2*(n>=1))} (zero : [n]Bit)

type gg n = [n - 2 * (n >= 1)]Bit
zero : {n} (fin n) => gg n
zero = take `{(n-2*(n>=1))} (zero : [n]Bit)

type jj n = [n - 3 * (n >= 1)]Bit
zero : {n} (fin n) => jj n
zero = take `{(n-3*(n>=1))} (zero : [n]Bit)

type kk n = [n - 3 * (n >= 1)]Bit
zero : {n} (fin n) => kk n
zero = take `{(n-3*(n>=1))} (zero : [n]Bit)
```
[GENERATED END]


=== Task 48 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines the submodules A, S, F, I, and M as given, using a type alias T = [8], an interface submodule S exposing x : T, a functor submodule F using x to define y = 2 * x, and an instantiation M = F { I } with I.x = 28.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
submodule A where
  type T = [8]

  submodule S where
    x : T

  submodule F where
    import interface submodule S

    y = 2 * x

  submodule I where
    x : T
    x = 28

  submodule M = submodule F { submodule I }
```
[GENERATED END]


=== Task 49 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Specify the ML-DSA key generation, signing, and verification API and define the property MLDSAIsCorrect that states a signature produced by Sign with keys from KeyGen always verifies with Verify for all messages and contexts within the given type constraints.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module MLDsa where

import Hashing
import Keccak
import Parameters

KeyGen : {m, n} (fin m, fin n) => ([m], [n]) -> ([m], [n])
KeyGen (sk, pk) = (sk', pk')
  where
    sk' = randomBytes m
    pk' = hashKeccak256 (sk')

Sign : {m, n} (fin m, fin n) => ([m], [m]) -> ([n])
Sign (sk, msg) = sig
  where
    h = hashKeccak256 (msg)
    sig = hashKeccak256 (sk # h)

Verify : {m, n} (fin m, fin n) => ([m], [m], [n]) -> Bit
Verify (pk, msg, sig) = verify
  where
    h = hashKeccak256 (msg)
    verify = hashKeccak256 (pk # h) == sig

MLDSAIsCorrect : {m, n} (fin m, fin n) => ([m], [n], [m]) -> Bit
property MLDSPAIsCorrect sk msg = verify
  where
    (pk, _) = KeyGen (sk, zero)
    sig     = Sign (sk, msg)
    verify  = Verify (pk, msg, sig)
```
[GENERATED END]


=== Task 50 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module that fully specifies the XMSS parameter interface `Primitive::Asymmetric::Signature::XMSS::Parameters`, including types `h`, `n`, `MessageUpperBound`, `PaddingWidth`, constants `oid`, and hash functions `H` and `H_msg` with the given constraints and signatures.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Asymmetric::Signature::XMSS::Parameters where

import Primitive::Keyless::Hash::KeccakBitOrdering as KBO
import Primitive::Keyless::Hash::KeccakInstantiations::SHA3_256 as SHA3_256

type h = 8

type n = 43

type MessageUpperBound = 1000000000

type PaddingWidth = 1 + 2 * lg2 (MessageUpperBound)

type oid = [10][8]

H : {a} (fin a, 32 >= width (8 * a)) => [a][8] -> [32]
H M = SHA3_256::hashBytes M

H_msg : {m}
       ( fin m
       , 32 >= width (8 * m)
       , 32 >= width (8 * (m + 32))
       )
       => [m][8] -> [32]
H_msg M = SHA3_256::hashBytes (M # (split (SHA3_256::hashBytes M)))
```
[GENERATED END]


=== Task 51 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256` that instantiates the generic XMSS specification with the `XMSS_SHA2_10_256_Parameters` parameter set and the `WOTSP_SHA2_256` WOTS instantiation.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256 =
    Primitive::Asymmetric::Signature::XMSS::Specification {
        Parameters = Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256,
        WOTS = Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256
    }
```
[GENERATED END]


=== Task 52 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Specify the Keccak/SHA3 bit and byte ordering utilities, including toBytes, fromBytes, reverseBitOrdering, h2b, b2h, and properties proving involution and mutual inversion (e.g., h2bAndb2hInvert, b2hAndh2bInvert, and example properties).


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Keyless::Hash::Keccak::KeccakUtils where

import Common::Utils (splitAt)

type Keccak = 1600
type BitOrdering = [1600]
type ByteOrdering = [4][400]

fromBytes : {n} (fin n) => [n] -> BitOrdering
fromBytes xs = join (map reverse (splitAt`{4} xs))

toBytes : {n} (fin n) => BitOrdering -> [n]
toBytes bs = join (map reverse (splitAt`{4} bs))

reverseBitOrdering : {n} (fin n) => BitOrdering -> BitOrdering
reverseBitOrdering bs = bs @@ (`n-1, -1)

h2b : {n} (fin n) => BitOrdering -> ByteOrdering
h2b bs = splitAt`{4} (bs @@ (`n-1, -1))

b2h : {n} (fin n) => ByteOrdering -> BitOrdering
b2h bs = join (map reverse bs)

property h2bAndb2hInvert : {n} (fin n) => BitOrdering -> Bool
property h2bAndb2hInvert bs = h2b (b2h bs) == bs

property b2hAndh2bInvert : {n} (fin n) => BitOrdering -> Bool
property b2hAndh2bInvert bs = b2h (h2b bs) == bs

example : [8][8]
example = h2b bs
  where
    bs : BitOrdering
    bs = reverseBitOrdering (take`{1600} (repeat True))
```
[GENERATED END]


=== Task 53 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write Cryptol properties that verify a SHA224::hash function against known test vectors for inputs "abc", the empty string, the 448-bit alphabet string, and the 896-bit alphabet string, matching the specified SHA-224 digest outputs.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
import SHA224

property hashTests =
    (SHA224::hash 0x616263 == 0x23ef65cd755e7f7a90f2973c9597429505d80939b56564712876c9340a715e06) &&
    (SHA224::hash 0x00 == 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855) &&
    (SHA224::hash 0x6162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263206162632061626320616263
```
[GENERATED END]


=== Task 54 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module that defines the given test vector record types and properties to verify HMAC-SHA-384 and its 192-bit truncation against the RFC 4868 section 2.7.1 and 2.7.2.2 test vectors, using an imported HMAC_SHA384 instantiation.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::MAC::HMAC::Tests::hmac_sha384 where

import Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA384

property testsPass = and testsPassed

type TestVector = {key : [256], data : [1024], expected : [384]}
type TruncatedTestVector = {key : [256], data : [1024], expected : [192]}

testVectors : [2]TestVector
testVectors =
  [{key = zero,
    data = "Hi There",
    expected = 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7a21ad364118b9b25bfe2c6daa5210d1},
   {key = repeat `0x0b,
    data = repeat `0xdd,
    expected = 0x9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f51535c3a35e2ee908e532c86381f6e79c0dbe3563a26231579b01122e2cebd8553557c5ccb1036}]

truncatedTestVectors : [2]TruncatedTestVector
truncatedTestVectors =
  [{key = zero,
    data = "Hi There",
    expected = 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7a},
   {key = repeat `0x0b,
    data = repeat `0xdd,
    expected = 0x9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f51535c3a35e2ee908e532c86381f6e79c0dbe3563a26231579b01122e2cebd8553557c5ccb1036}]

testsPassed : [2]Bit
testsPassed = [HMAC_SHA384 tv.key tv.data == tv.expected | tv <- testVectors]
```
[GENERATED END]


=== Task 55 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define an interface module `Primitive::Symmetric::Cipher::Block::CipherInterface` with type synonyms `KeySize`, `BlockSize`, a finiteness constraint on both, and functions `encrypt` and `decrypt` of type `[KeySize] -> [BlockSize] -> [BlockSize]`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::CipherInterface where

type KeySize = 128
type BlockSize = 128

encrypt : [KeySize] -> [BlockSize] -> [BlockSize]
encrypt k pt = zero

decrypt : [KeySize] -> [BlockSize] -> [BlockSize]
decrypt k ct = zero
```
[GENERATED END]


=== Task 56 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Specify the CFB (Cipher Feedback) block cipher mode over an abstract block cipher interface, including encrypt and decrypt functions parameterized by segment size and a property encryptCorrect stating decrypt K IV (encrypt K IV Ps) == Ps for all keys, IVs, and plaintext segments.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Modes::CFB where

import Primitive::Symmetric::Cipher::Block::Interface

type CFB b c = { blockEncrypt : [b] -> [b]
               , blockDecrypt : [b] -> [b]
               }

encrypt : {n, m, b, c}
         ( fin n
         , fin m
         , fin b
         , fin c
         , n >= 1
         , m >= 1
         )
         => CFB b c
         -> [m][b]
         -> [n][b]
         -> [m][b]
encrypt cfb iv ps = cs
    where
        ks = [iv] # [ cfb.blockEncrypt k | k <- ks ]
        cs = [ (p ^ k) | p <- ps | k <- ks ]

decrypt : {n, m, b, c}
         ( fin n
         , fin m
         , fin b
         , fin c
         , n >= 1
         , m >= 1
         )
         => CFB b c
         -> [m][b]
         -> [n][b]
         -> [m][b]
decrypt cfb iv cs = ps
    where
        ks = [iv] # [ cfb.blockEncrypt k | k <- ks ]
        ps = [ (c ^ k) | c <- cs | k <- ks ]

property encryptCorrect cfb iv ps =
    decrypt cfb iv (encrypt cfb iv ps) == ps
```
[GENERATED END]


=== Task 57 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128` that instantiates the generic Simon block cipher specification for the Simon-128/128 variant with type parameters `n = 64`, `m = 2`, `T = 68`, and `j = 2`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128 =
    Primitive::Symmetric::Cipher::Block::Simon::Specification where

        type n = 64
        type m = 2
        type T = 68
        type j = 2
```
[GENERATED END]


=== Task 58 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256` instantiating the generic Simon block cipher specification for the Simon-128/256 variant with parameters `n=64`, `m=4`, `T=72`, and `j=4`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256 =
    Primitive::Symmetric::Cipher::Block::Simon::Specification where

        type n = 64
        type m = 4
        type T = 72
        type j = 4
```
[GENERATED END]


=== Task 59 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR that imports Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR and defines properties aes256_ctr_encrypt_vector and aes256_ctr_decrypt_vector checking AES-256 CTR encrypt/decrypt against the given NIST test vectors.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR where

import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR as AES256_CTR

property aes256_ctr_encrypt_vector = zero == AES256_CTR::encrypt k iv plaintext
  where
    k         = 0x8000000000000000000000000000000000000000000000000000000000000000
    iv        = 0x000102030405060708090a0b0c0d0e0f
    plaintext = [
      0x6bc1bee22e409f96e93d7e117393172a,
      0xae2d8a571e03ac9c9eb76fac45af8e51,
      0x30c81c46a35ce411e5fbc1191a0a52ef,
      0xf69f2445df4f9b17ad2b417be66c3710
    ]

property aes256_ctr_decrypt_vector = zero == AES256_CTR::decrypt k iv ciphertext
  where
    k         = 0x8000000000000000000000000000000000000000000000000000000000000000
    iv        = 0x000102030405060708090a0b0c0d0e0f
    ciphertext = [
      0x6bc1bee22e409f96e93d7e117393172a,
      0xae2d8a571e03ac9c9eb76fac45af8e51,
      0x30c81c46a35ce411e5fbc1191a0a52ef,
      0xf69f2445df4f9b17ad2b417be66c3710
    ]
```
[GENERATED END]


=== Task 60 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB` that instantiates the generic CFB block cipher mode with the AES-192 block cipher implementation.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB =
    Primitive::Symmetric::Cipher::Block::Modes::CFB {
        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192
    }
```
[GENERATED END]


=== Task 61 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol module AES128_CFB that instantiates the generic CFB block cipher mode with AES-128, exposing the resulting AES-128 CFB encryption and decryption functions and any necessary types for keys, blocks, and IVs.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB where
import Primitive::Symmetric::Cipher::Block::Modes::CFB
import Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128
```
[GENERATED END]


=== Task 62 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Specify and verify in Cryptol the HostValues module’s heap-based host value store, including VecRepresentation and MapRepresentation constructors, allocation and lookup functions, and define a property that map_representation_equiv correctly characterizes when two MapRepresentation values are equivalent for a given element comparator and heap.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module HostValues where

import Array
import Values

type Allocator = {alloc : [64] -> [64]}

newtype Heap a = {heap : Array [64] a}

newtype VecRepresentation a = {vec : [64], heap : Heap a}

newtype MapRepresentation a = {map : [64], heap : Heap a}

vec_representation_alloc : {a} (Literal 1 a) => Allocator -> a -> VecRepresentation a
vec_representation_alloc allocator val =
    {vec = vec, heap = heap}
    where
        vec = allocator.alloc (zero : [64])
        heap = Heap {heap = array_from_val allocator val}

vec_representation_lookup : {a} (Literal 1 a) => VecRepresentation a -> [64] -> a
vec_representation_lookup rep addr = heap.heap @ addr
    where
        heap = rep.heap

map_representation_alloc : {a} (Literal 1 a, Literal 2 [64]) => Allocator -> a -> MapRepresentation a
map_representation_alloc allocator val =
    {map = map, heap = heap}
    where
        map = allocator.alloc (zero : [64])
        heap = Heap {heap = array_from_val allocator val}

map_representation_lookup : {a} (Literal 1 a, Literal 2 [64]) => MapRepresentation a -> [64] -> a
map_representation_lookup rep addr = heap.heap @ addr
    where
        heap = rep.heap

map_representation_equiv : {a} (Literal 1 a, Literal 2 [64]) =>
    (a -> a -> Bit) -> Heap a -> MapRepresentation a -> MapRepresentation a -> Bit
map_representation_equiv eq heap rep1 rep2 =
    (rep1.map == rep2.map) /\ (all_tests_passed tests)
    where
        tests = [eq v1 v2 | v1 <- heap_values rep1
                         | v2 <- heap_values rep2]

        heap_values rep = [heap.heap @ i | i <- [0..7]]

        all_tests_passed tests = foldl (&&) True tests
```
[GENERATED END]


=== Task 63 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification of the AES-128 S-box over GF(2^8), including gf28Mult, gf28Pow, gf28Inverse, aesAffine, aesSBox, the 16×16 aesSBoxTable, and a property cell00 asserting aesSBoxTable @ 0 @ 0 == 0x63.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type GF28 = [8]
gf28Mult : (GF28, GF28) -> GF28
gf28Mult (x, y) = pmod (pmult x y) <| x^^8 + x^^4 + x^^3 + x + 1 |>
gf28Pow : (GF28, [8]) -> GF28
gf28Pow (n, k) =
  pow k
  where
    sq x = gf28Mult (x, x)
    odd x = x ! 0
    pow i =
      if i == 0
      then 1
      else if odd i
      then gf28Mult (n, sq (pow (i >> 1)))
      else sq (pow (i >> 1))
gf28Inverse : GF28 -> GF28
gf28Inverse x = gf28Pow (x, 254)
aesAffine : (GF28, GF28) -> GF28
aesAffine (x, c) = gf28Mult ((x + c), 0x63)
aesSBox : GF28 -> GF28
aesSBox x = aesAffine (x, 0x63) ^ 0x05
aesSBoxTable = [[aesSBox (i + j * 256) | i <- [0 .. 255]] | j <- [0 .. 15]]
/* pragma cell00 : property */
cell00 = aesSBoxTable @ 0 @ 0 == 0x63
```
[GENERATED END]


=== Task 64 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the functions `usaf : [1][8] -> [10][8] -> [1][8]` and `saf : [1][8] -> [10][8] -> [1][8]` in Cryptol as given, and add a property that they are equal for all inputs `a` and `b` where `0 <= a@0 <= 9`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
usaf : [1][8] -> [10][8] -> [1][8]
usaf a b = [(a@0) + (b@(a@0))]

saf : [1][8] -> [10][8] -> [1][8]
saf a b = [(a@0) + (b@(a@0))]
```
[GENERATED END]


=== Task 65 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines the given Circle/Displacement/BMI record types and functions (areaCircle, nudgeCircle, calcBMI, calcBMIimp), along with example constants, matching the behavior and types implied by the code excerpt.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Circle = { x : Float64, y : Float64, r : Float64 }
type Displacement = { dx : Float64, dy : Float64 }
type BMI = { weight : Float64, height : Float64 }

areaCircle : Circle -> Float64
areaCircle c = pi * r * r where r = c.r

nudgeCircle : Circle -> Displacement -> Circle
nudgeCircle c d = { x = c.x + d.dx, y = c.y + d.dy, r = c.r }

calcBMI : BMI -> Float64
calcBMI b = w / h / h where w = b.weight; h = b.height

calcBMIimp : Float64 -> Float64 -> Float64
calcBMIimp w h = w / h / h
```
[GENERATED END]


=== Task 66 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification of ECDSA over the NIST P-384 curve, including functions for key initialization, signing, and public verification, plus properties that check the provided P-384 test vectors for point add/subtract/double, scalar multiplication, and twin multiplication.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
module Primitive::Asymmetric::Signature::ECDSA::P384 where

import Common::ModDivZ
import Primitive::Asymmetric::Signature::ECDSA::ECDSA

parameter

  type q : #
  type constraint (fin q)

  type t : #
  type constraint (fin t)

  type m : #
  type constraint (fin m)

  type n : #
  type constraint (fin n)

  type k : #
  type constraint (fin k)

  type p : #
  type constraint (fin p)

  type x : #
  type constraint (fin x)

  type y : #
  type constraint (fin y)

  type d : #
  type constraint (fin d)

  type g : #
  type constraint (fin g)

  type h : #
  type constraint (fin h)

  type r : #
  type constraint (fin r)

  type s : #
  type constraint (fin s)

type Q = {x : [x], y : [y]}

type D = [d]

type G = [g]

type H = [h]

type R = [r]

type S = [s]

type F = Z k

type E = Z p

F2E : {n} (fin n) => [n] -> E
F2E x = fromInteger (toInteger x)

E2F : {n} (fin n) => E -> [n]
E2F x = fromInteger (toInteger x)

k1 = F2E 0x75968e8848b3605846037a79901622221803912956684993512618955824077687744094674679134049138589440796646883678950575889339515395188181849411813773717167595710162719466465611941441846788335818788456664469545578876021973954906881679188614456966343579136753018699690334860747806497184879764691391073774775641055806313046036704481595094305561164939143694431576394789373966438961144596957995765373871039771653315113699671593671481310067951755660608744395345018961787845543157007414439158675417147079141776947174341593596601579997931965570564155596561759955957108739911194949008966606914575366055880483198404184146706057976886875750314187768451034863841851613699746374369951089487637669187369554549917035710047
```
[GENERATED END]


=== Task 67 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines the newtype CplxInt over Integer with complex addition, multiplication, equality, and properties cplxAddAssoc, cplxMulAssoc, and cplxMulDistrib verifying associativity of addition, associativity of multiplication, and left distributivity of multiplication over addition.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
newtype CplxInt = { real : Integer, imag : Integer }

cplxAdd : CplxInt -> CplxInt -> CplxInt
cplxAdd x y = CplxInt { real = x.real + y.real, imag = x.imag + y.imag }

cplxMul : CplxInt -> CplxInt -> CplxInt
cplxMul x y =
  CplxInt { real = x.real * y.real - x.imag * y.imag,
            imag = x.real * y.imag + x.imag * y.real }

cplxEq : CplxInt -> CplxInt -> Bit
cplxEq x y = x.real == y.real && x.imag == y.imag

cplxAddAssoc : CplxInt -> CplxInt -> CplxInt -> Bit
cplxAddAssoc x y z = cplxEq (cplxAdd x (cplxAdd y z)) (cplxAdd (cplxAdd x y) z)

cplxMulAssoc : CplxInt -> CplxInt -> CplxInt -> Bit
cplxMulAssoc x y z = cplxEq (cplxMul x (cplxMul y z)) (cplxMul (cplxMul x y) z)

cplxMulDistrib : CplxInt -> CplxInt -> CplxInt -> Bit
cplxMulDistrib x y z = cplxEq (cplxMul x (cplxAdd y z))
                               (cplxAdd (cplxMul x y) (cplxMul x z))
```
[GENERATED END]


=== Task 68 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that includes the given tuple-based fold functions and a property `foldFunctionInverse` stating that `foldFunction' (foldFunction x y z) y z == x` for all 8-bit `x` and 16-bit `y`, `z`, suitable for formal verification.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
foldFunction : ([8], [16], [16]) -> [16] -> [16] -> [16]
foldFunction (x, y, z) a b = y + z - x

foldFunction' : ([16], [16], [16]) -> [16] -> [16] -> [16]
foldFunction' (x, y, z) a b = x

property foldFunctionInverse x y z =
    foldFunction' (foldFunction x y z) y z == x
```
[GENERATED END]


=== Task 69 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines the AES-128 inverse MixColumns transformation over GF(2^8) using precomputed multiplication tables (for 0x0e, 0x0b, 0x0d, 0x09), including the types GF28, State, the helper functions gf28Mult, toBytes, fromBytes, and a function invMixColumns : State -> State matching the standard AES inverse MixColumns step.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type GF28 = [8]
gf28Mult x y = pmod (pmult x y) <| x^^8 + x^^4 + x^^3 + x + 1 |>
toBytes : {n} (fin n) => [n * 8] -> [n][8]
toBytes bits = split`{each=8} bits
fromBytes : {n} (fin n) => [n][8] -> [n*8]
fromBytes bytes = join bytes
type State = [4][4]GF28
invMixColumns state =
  fromBytes
    [gf28Mult 0x0e (bytesAt i)
    | i <- [0, 1, 2, 3]
    ]
  where
    bytesAt i = toBytes (state @ i)
```
[GENERATED END]


=== Task 70 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the Cryptol function `doRounds` and supporting types and functions (`Nb`, `State`, `RoundKey`, `addRoundKey`) as given, where `doRounds` iteratively applies a round function `rnd` over an initial key, a sequence of round keys, and a final key, and verify with a `property` that for any choice of `rnd`, initial key, round keys, final key, and input state, `doRounds` produces the same final state as computing the initial AddRoundKey followed by the same sequence of `rnd` applications unrolled explicitly.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
type Nb = 4

type State = [4][Nb]Bit

type RoundKey = State

addRoundKey : {a} (fin a) => ([a]Bit, [a]Bit) -> [a]Bit
addRoundKey (x, y) = x ^ y

doRounds : {n}
          (fin n, n >= 1)
          => RoundKey
          -> [n]RoundKey
          -> RoundKey
          -> State
          -> State
doRounds initKey rndKeys finalKey state =
  finalKey ^ (rounds ! 0)
  where rounds = [state ^ initKey]
        rounds' = [rnd k s | k <- rndKeys | s <- rounds]
        rounds'' = [s ^ finalKey | s <- rounds']
        rounds''' = [rnd k s | k <- reverse rndKeys | s <- reverse rounds'']
        rounds'''' = [s ^ finalKey | s <- rounds'''']
        rounds''''' = [rnd k s | k <- rndKeys | s <- rounds'''']
        rounds'''''' = [s ^ finalKey | s <- rounds'''''']
        rounds''''''' = [rnd k s | k <- reverse rndKeys | s <- reverse rounds''''']
        rounds'''''''' = [s ^ finalKey | s <- rounds'''''''
        rounds''''''''' = [rnd k s | k <- rndKeys | s <- rounds''''''']
        rounds'''''''''' = [s ^ finalKey | s <- rounds''''''''']
        rounds''''''''''' = [rnd k s | k <- reverse rndKeys | s <- reverse rounds''''''''']
        rounds'''''''''''' = [s ^ finalKey | s <- rounds'''''''''''
        rounds''''''''''''' = [rnd k s | k <- rndKeys | s <- rounds''''''''''']
        rounds'''''''''''''' = [s ^ finalKey | s <- rounds''''''''''''']
        rounds''''''''''''''' = [rnd k s | k <- reverse rndKeys | s <- reverse rounds''''''''''']
        rounds'''''''''''''''' = [s ^ finalKey | s <- rounds'''''''''''''''
        rounds''''''''''''''''' = [rnd k s | k <- rndKeys | s <- rounds''''''''''''''']
        rounds'''''''''''''''''' = [s ^ finalKey | s <- rounds''''''''''''''''']
        rounds''''''''''''''''''' = [rnd k s | k <- reverse rndKeys | s <- reverse rounds''''''''''''''']
        rounds'''''''''''''''''''' = [s ^ finalKey | s <- rounds'''''''''''''''''''
        rounds''''''''''''''''''''' = [rnd k s | k <- rndKeys | s <- rounds''''''''''''''''''']
        rounds'''''''''''''''''''''' = [s ^ finalKey | s <- rounds''''''''''''''''''''']
        rounds''''''''''''''''''''''' = [rnd k s | k <- reverse rndKeys | s <- reverse rounds''''''''''''''''''']
        rounds'''''''''''''''''''''''' = [s ^ finalKey | s <- rounds'''''''''''''''''''''''
        rounds''''''''''''''''''''''''' = [rnd k s | k <- rndKeys | s <- rounds''''''''''''''''''''''']
        rounds'''''''''''''''''''''''''' = [s ^ finalKey | s <- rounds''''''''''''''''''''''''']
        rounds''''''''''''''''''''''''''' = [rnd k s | k <- reverse rndKeys | s <- reverse rounds''''''''''''''''''''''']
        rounds'''''''''''''''''''''''''''' = [s ^ finalKey | s <- rounds'''''''''''''''''''''''''''
        rounds''''''''''''''''''''''''''''' = [rnd k s | k <- rndKeys | s <- rounds''''''''''''''''''''''''''']
        rounds'''''''''''''''''''''''''''''' = [s ^ finalKey | s <- rounds''''''''''''''''''''''''''''']
        rounds''''
```
[GENERATED END]


=== Task 71 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: In Cryptol, define the DES S-box 6 constant `sbox6 : [4][16][4]` with the given 4×16 table of 4-bit values exactly as specified here.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
sbox6 : [4][16][4]
sbox6 =
  [[7, 13, 14, 22, 28, 18, 31, 30, 5, 21, 10, 23, 15, 26, 8, 19],
  [3, 20, 11, 10, 27, 24, 13, 17, 4, 15, 9, 1, 29, 22, 12, 4],
  [24, 14, 25, 7, 26, 5, 18, 6, 16, 9, 27, 20, 8, 15, 1, 10],
  [3, 25, 7, 16, 11, 5, 28, 15, 6, 21, 12, 2, 14, 23, 19, 18]]
```
[GENERATED END]


=== Task 72 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines the DES block cipher as a value `DES : Cipher 64 64` (with `encrypt`/`decrypt` wired through the DES round function, key schedule, permutations, and S-boxes as in the NIST standard) and a property `testsPass` that checks `DES.encrypt` on given test message/key pairs matches the expected ciphertexts.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
module Primitive::Symmetric::Cipher::Block::DES where

import Common::utils
import Primitive::Symmetric::Cipher::Block::DES::RoundFunction
import Primitive::Symmetric::Cipher::Block::DES::Schedule
import Primitive::Symmetric::Cipher::Block::DES::Permutations
import Primitive::Symmetric::Cipher::Block::DES::Sbox

type KeySize = 64
type BlockSize = 64

type RoundKeySize = 48

type NRounds = 16

type KeySchedule = [NRounds][RoundKeySize]

type State = [BlockSize]

type Message = State

type Cipher K M = { encrypt : ([K], [M]) -> [M]
                 , decrypt : ([K], [M]) -> [M]
                 }

DES : Cipher KeySize BlockSize
DES = { encrypt = encrypionImpl
      , decrypt = decryptionImpl
      }
    where
        encrypionImpl (key, msg) = join (rounds (msg, expandKey key))
        decryptionImpl (key, ct) = join (rounds (ct, reverse (expandKey key)))

property testsPass = and [ DES.encrypt (key, msg) == ct | (key, msg, ct) <- tests ]

tests = [ (0x13198a2e03707344, 0x68c5bf2d1616515f, 0x58342211596b2595)
        , (0x13198a2e03707344, 0x9083a59148889887, 0x6784453047007346)
        , (0x13198a2e03707344, 0x1598417641587152, 0x3319a45080583887)
        , (0x13198a2e03707344, 0x707736810008414e, 0x2597755810e8234e)
        ]
```
[GENERATED END]


=== Task 73 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol property rfctest03 that verifies the given ChaCha20 stream cipher implementation (using qround, cdround, core, kexp, iround, stream, and encrypt over types Round, Block, Key, Nonce, and Counter) correctly encrypts the specified msg with the given key and counter to produce the expected out test vector.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
type Round = [16][32]
type Block = [64][8]
type Key = [32][8]
type Nonce = [96][8]
type Counter = [64][8]
qround : [4][32] -> [4][32]
qround [a0, b0, c0, d0] =
  [a2, b4, c2, d4]
  where
    a1 = a0 + b0
    d1 = d0 ^ a1
    d2 = d1 <<< 16
    c1 = c0 + d2
    b1 = b0 ^ c1
    b2 = b1 <<< 12
    a2 = a1 + b2
    d3 = d2 ^ a2
    d4 = d3 <<< 8
    c2 = c1 + d4
    b3 = b2 ^ c2
    b4 = b3 <<< 7
cdround : [4][32] -> [4][32]
cdround [a0, b0, c0, d0] =
  [a2, b4, c2, d4]
  where
    a1 = a0 <<< 16
    d1 = d0 ^ a1
    d2 = d1 >>> 12
    c1 = c0 + d2
    b1 = b0 ^ c1
    b2 = b1 <<< 8
    a2 = a1 + b2
    d3 = d2 ^ a2
    d4 = d3 >>> 7
    c2 = c1 + d4
    b3 = b2 ^ c2
    b4 = b3 <<< 16
core : Round -> Round
core r =
  (iround (cdround (iround (cdround (iround (cdround r))))))
kexp : Key -> Round
kexp k =
  [(k @ 0), (k @ 1), (k @ 2), (k @ 3),
  (k @ 4), (k @ 5), (k @ 6), (k @ 7),
  (k @ 8), (k @ 9), (k @ 10), (k @ 11),
  (k @ 12), (k @ 13), (k @ 14), (k @ 15)]
iround : Round -> Round
iround r =
  [r ! 0,
  r ! 15 + (r ! 13),
  r ! 6 + (r ! 14),
  r ! 11 + (r ! 15),
  r ! 0 + (r ! 5),
  r ! 10 + (r ! 0),
  r ! 7 + (r ! 5),
  r ! 4 + (r ! 7),
  r ! 12 + (r ! 12),
  r ! 2 + (r ! 12),
  r ! 9 + (r ! 2),
  r ! 5 + (r ! 9),
  r ! 14 + (r ! 5),
  r ! 3 + (r ! 14),
  r ! 13 + (r ! 3),
  r ! 1 + (r ! 13)]
stream : Key -> Nonce -> Counter -> Block
stream k n c =
  map (join . reverse)
  (groupByBy (join (reverse (kexp k))) (\x -> x % 4 == 3))
  where
    n' = split (join n)
    c' = split (join c)
    groupByBy xs p =
      foldl
        (\acc x ->
          if p x then (x : [1]) # acc else x # head acc # tail acc)
        ([] : [100][1])
        (reverse xs)
encrypt : Key -> Nonce -> Counter -> Block -> Block
encrypt k n c m =
  map (^) m (stream k n c)
msg =
  [0x6bc1bee2, 0x2e409f96, 0xe93d7e11, 0x7393172a,
  0xae2d8a57, 0x1e03ac9c, 0x9eb76fac, 0x45af8e51]
key =
  [0x63a9f0aa, 0xad0becfb, 0x915902fe
```
[GENERATED END]


=== Task 74 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification of the ChaCha20 stream cipher with types Round = [16][32], Block = [64][8], Key = [32][8], Nonce = [12][8], Counter = [32], functions qround, cdround, kexp, iround, core, stream, encrypt, and a property rfctest02 that checks encrypt (zero # [1]) 1 (zero # [2]) msg equals the given RFC test vector out for the provided msg bytes.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
type Round = [16][32]
type Block = [64][8]
type Key = [32][8]
type Nonce = [12][8]
type Counter = [32]
qround : [4][32] -> [4][32]
qround [a, b, c, d] =
  [a + b,
  (a + b) <<< 16,
  (a + b) <<< 12,
  (a + b) <<< 8,
  c ^ a,
  (c ^ a) <<< 16,
  (c ^ a) <<< 12,
  (c ^ a) <<< 8,
  d ^ c,
  (d ^ c) <<< 16,
  (d ^ c) <<< 12,
  (d ^ c) <<< 8,
  b ^ d,
  (b ^ d) <<< 16,
  (b ^ d) <<< 12,
  (b ^ d) <<< 8,
  a ^ b,
  (a ^ b) <<< 16,
  (a ^ b) <<< 12,
  (a ^ b) <<< 8]
cdround : [8][32] -> [8][32]
cdround
  [x0,
  x1,
  x2,
  x3,
  x4,
  x5,
  x6,
  x7] =
  [y0,
  y1,
  y2,
  y3,
  y4,
  y5,
  y6,
  y7]
  where
    [y0, y1, y2, y3] = qround [x0, x1, x2, x3]
    [y4, y5, y6, y7] = qround [x4, x5, x6, x7]
kexp : ([32], [32]) -> [32]
kexp (x, i) = x + i
iround : [16][32] -> [16][32]
iround xs =
  [kexp (xs @ 0, 0x6D616E),
  kexp (xs @ 1, 0x93DC9467),
  kexp (xs @ 2, 0x7DB14963),
  kexp (xs @ 3, 0x163FA83E),
  kexp (xs @ 4, 0x31C3FB0F),
  kexp (xs @ 5, 0x5A1003B6),
  kexp (xs @ 6, 0x7D581006),
  kexp (xs @ 7, 0x92516152),
  kexp (xs @ 8, 0xA8C6632C),
  kexp (xs @ 9, 0xC4AC6617),
  kexp (xs @ 10, 0xDC31D677),
  kexp (xs @ 11, 0xF7E4F7B6),
  kexp (xs @ 12, 0x1472814C),
  kexp (xs @ 13, 0x2A0619D1),
  kexp (xs @ 14, 0x3EDD5B4F),
  kexp (xs @ 15, 0x48A1483A)]
core : Round -> Counter -> Nonce -> Block
core k i n =
  take `{64} (join (reverse (take `{16} (join (reverse (cdround (iround (k # [i] # n)))))))))
stream : Key -> Counter -> Nonce -> [inf]Block
stream k i n = map (core k i) (iterate (`0x1 : Counter) (`0x1 : Counter))
encrypt : Key -> Counter -> Nonce -> [inf]Block -> [inf]Block -> [inf]Block
encrypt k i n plaintext ciphertext =
  [if p == zero then c else p | p <- plaintext | c <- ciphertext]
rfctest02 msg =
  encrypt (zero # [1]) 1 (zero # [2]) msg
    (zero # [0x8e2c9474, 0x3b06f16e, 0x90244241, 0x226963fd, 0x17a217e8, 0
```
[GENERATED END]


=== Task 75 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines the type AESTestVector 128 and the function mct_ecb_decrypt_128 : [128] -> [128] -> [100](AESTestVector 128) implementing the AES-128 Monte Carlo Test for ECB decryption using aesDecryptBlock and aes128DecryptSchedule from SuiteB, including generation of 100 test vectors from an initial key and ciphertext as described.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
import SuiteB


type AESTestVector n = { iv : [n], ct : [n], pt : [n] }
mct_ecb_decrypt_128 : [128] -> [128] -> [100](AESTestVector 128)
mct_ecb_decrypt_128 k c =
  testVectors
  where
    schedule = aes128DecryptSchedule k
    testVectors =
      take `{100}
      (iterate nextTestVector
       ({iv = zero, ct = c, pt = aesDecryptBlock schedule c}))
    nextTestVector tv =
      { iv = tv.pt,
        ct = tv.ct,
        pt = aesDecryptBlock schedule tv.ct
      }
```
[GENERATED END]


=== Task 76 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define in Cryptol the function `mct_ecb_decrypt_192 : [192] -> [128] -> [100](AESTestVector 192)` and any required types and helpers so that it models the AES-192 Monte Carlo Test for ECB decryption, producing 100 test vectors of key, plaintext, and ciphertext derived from iterative AES-192 decryption and key schedule updates.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
import Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192

type AESTestVector n = {key : [n], pt : [128], ct : [128]}
mct_ecb_decrypt_192 : [192] -> [128] -> [100](AESTestVector 192)
mct_ecb_decrypt_192 k iv =
  vs @@ ([0 .. 99])
  where
    vs =
      [init] #
      [if i < 99 then next v else undefined | v <- vs | i <- [0 ...]]
    init =
      {key = k,
      pt = aes192_decrypt (subkey (k, 0)) iv,
      ct = iv}
    next prev =
      {key = updateKey (prev.key, prev.ct),
      pt = aes192_decrypt (subkey (prev.key, 0)) prev.pt,
      ct = prev.pt}
subkey : ([192], [4]) -> [128]
subkey (k, i) = sk
  where
    [rcon0, rcon1, rcon2, rcon3] =
      [0x01, 0x02, 0x04, 0x08] # zero
    sk = take`{128} (drop`{16 * i} (k # rcon0))
updateKey : ([192], [128]) -> [192]
updateKey (k, c) =
  drop`{64} (c # k)
```
[GENERATED END]


=== Task 77 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define a Cryptol property tcId1069 that verifies the AES256_KeyWrap padded authenticated-encryption function KWP_AE, instantiated from Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap, maps the 8-bit plaintext 0xe0 under the 256-bit key 0x2644ccf9d7c419a437c954c8141cbb2d60f57de10a5393554a14ccc72229e286 to the ciphertext 0xda510b1d9a10255380655980a3a73536, using a helper predicate check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct and asserting testPassed == check_KWP_AE key pt ct.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap


check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct
/* pragma tcId1069 : property */
tcId1069 =
  testPassed == check_KWP_AE key pt ct
  where
    testPassed = True
    key =
      0x2644ccf9d7c419a437c954c8141cbb2d60f57de10a5393554a14ccc72229e286
    pt = 0xe0
    ct = 0xda510b1d9a10255380655980a3a73536
```
[GENERATED END]


=== Task 78 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the property `tcId1080` that checks, for AES-256 Key Wrap with padding in AE mode, that encrypting the plaintext `0x06` under the key `0x3ea9325069ed93a96c331bdd6dd766ec64bbba83a72c69ed75df55043fb0bfd1` with `KWP_AE` produces the expected ciphertext `0x40a9c42012ba38211b800e6e313b6876`, using the helper `check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap


check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct
/* pragma tcId1080 : property */
tcId1080 =
  testPassed == check_KWP_AE key pt ct
  where
    testPassed = True
    key =
      0x3ea9325069ed93a96c331bdd6dd766ec64bbba83a72c69ed75df55043fb0bfd1
    pt = 0x06
    ct = 0x40a9c42012ba38211b800e6e313b6876
```
[GENERATED END]


=== Task 79 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Define the Cryptol function `pi16' : [16][64] -> [16][64]` that permutes a 16-word (64-bit each) Threefish state using the index order `[0, 15, 2, 11, 6, 13, 4, 9, 14, 1, 8, 5, 10, 3, 12, 7 : [4]]`, and add a property that this permutation is bijective (has an inverse).


[PROMPT END]

[GENERATED BEGIN]
```cryptol
pi16' : [16][64] -> [16][64]
pi16' xs =
  [xs @ i | i <- [0, 15, 2, 11, 6, 13, 4, 9, 14, 1, 8, 5, 10, 3, 12, 7]]
```
[GENERATED END]


=== Task 80 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: In Cryptol, define the type alias `Dom n = {lo : [n], sz : [n]}` and the functions `interval : {n} (fin n) => [n] -> [n] -> Dom n` and `range : {n} (fin n) => [n] -> [n] -> Dom n` where `interval l s = {lo = l, sz = s}` and `range lo hi = interval lo (hi - lo)`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Dom n = {lo : [n], sz : [n]}
interval : {n} (fin n) => [n] -> [n] -> Dom n
interval l s = {lo = l, sz = s}
range : {n} (fin n) => [n] -> [n] -> Dom n
range lo hi = interval lo (hi - lo)
```
[GENERATED END]


=== Task 81 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: In Cryptol, define the type alias `Dom n = {lo : [n], sz : [n]}`, the function `interval : {n} (fin n) => [n] -> [n] -> Dom n` with `interval l s = {lo = l, sz = s}`, and the constant `top : {n} (fin n) => Dom n` defined as `top = interval 0 (~0)`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Dom n = {lo : [n], sz : [n]}
interval : {n} (fin n) => [n] -> [n] -> Dom n
interval l s = {lo = l, sz = s}
top : {n} (fin n) => Dom n
top = interval 0 (~0)
```
[GENERATED END]


=== Task 82 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol specification that defines the type `Dom n = {lo : [n], sz : [n]}`, the functions `mem : {n} (fin n) => Dom n -> [n] -> Bit`, `ubounds : {n} (fin n) => Dom n -> ([n], [n])`, `ule : {n} (fin n) => Dom n -> Dom n -> Bit`, the property `correct_ule : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit` expressing that `ule a b` implies `x <= y` for all `x` and `y` in the respective domains, and a property instance `o4 = correct_ule` specialized to `n = 16`.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Dom n = {lo : [n], sz : [n]}
mem : {n} (fin n) => Dom n -> [n] -> Bit
mem a x = x - a.lo <= a.sz
ubounds : {n} (fin n) => Dom n -> ([n], [n])
ubounds a =
  if carry a.lo a.sz then (0, ~0) else (a.lo, a.lo + a.sz)
ule : {n} (fin n) => Dom n -> Dom n -> Bit
ule a b =
  (b.sz == 0) \/ (a.sz == 0) \/ (diff <= b.sz)
  where
    (_, a_hi) = ubounds a
    (_, b_hi) = ubounds b
    diff = b_hi - a_hi
correct_ule : {n}
  (fin n, n >= 1) =>
    Dom n -> Dom n -> [n] -> [n] -> Bit
correct_ule a b x y =
  ule a b ==> mem a x ==> mem b y ==> x <= y
/* pragma o4 : property */
o4 = correct_ule
```
[GENERATED END]


=== Task 83 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: In Cryptol, define the type `Dom n = {lo : [n], sz : [n]}`, functions `interval`, `singleton`, `neg`, `singleton_neg` as in the excerpt, and the property `i08` that asserts `singleton_neg` instantiated at width 16 (i.e., `singleton_neg`{16}) holds for all 16-bit inputs, suitable for verification with a solver.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
type Dom n = {lo : [n], sz : [n]}
interval : {n} (fin n) => [n] -> [n] -> Dom n
interval l s = {lo = l, sz = s}
singleton : {n} (fin n) => [n] -> Dom n
singleton x = interval x 0
neg : {n} (fin n) => Dom n -> Dom n
neg a =
  if a.sz == 0
  then singleton (~a.lo)
  else interval (~a.lo - a.sz) a.sz
singleton_neg : {n} (fin n) => [n] -> Bit
property i08 = singleton_neg`{16}
```
[GENERATED END]


=== Task 84 ===

[PROMPT BEGIN]
[SYSTEM]
Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before/after).

[USER]
### Instruction:
Write a Cryptol function that implements the tasks described below.

### Request:
Task: Write a Cryptol property `Salsa20_passes_tests` that checks the given Salsa20 core implementation (using `quarterround`, `rowround`, `columnround`, `doubleround`, `littleendian`, `littleendian_state`, `littleendian_state_inverse`, `Salsa20_rounds`, and `Salsa20 : [32] -> [64][8] -> [64][8]`) satisfies the three specified 20-round test vectors by equating its outputs to the provided 64-byte expected sequences and conjoining the results.


[PROMPT END]

[GENERATED BEGIN]
```cryptol
```cryptol
quarterround : [4][32] -> [4][32]
quarterround [a, b, c, d] =
  [a + b,
  (a + b) <<< 13,
  ((a + b) <<< 13) ^ c,
  (((a + b) <<< 13) ^ c) <<< 16,
  d + (((a + b) <<< 13) ^ c) <<< 16,
  d + (((a + b) <<< 13) ^ c) <<< 16 ^ d,
  (d + (((a + b) <<< 13) ^ c) <<< 16 ^ d) <<< 23,
  (d + (((a + b) <<< 13) ^ c) <<< 16 ^ d) <<< 23 ^ a]
rowround : [4][4][32] -> [4][4][32]
rowround x =
  transpose
    [quarterround (x @ i)
    | i <- [0, 1, 2, 3]]
columnround : [4][4][32] -> [4][4][32]
columnround x =
  transpose
    [quarterround (x @ i)
    | i <- [0, 1, 2, 3]]
doubleround : [4][4][32] -> [4][4][32]
doubleround x = columnround (rowround x)
littleendian : [32][8] -> [32]
littleendian x = join (reverse x)
littleendian_state : [64][8] -> [16][4][32]
littleendian_state x =
  groupBy`{4} (groupBy`{8} (map littleendian x))
littleendian_state_inverse : [16][4][32] -> [64][8]
littleendian_state_inverse x =
  join (map reverse (map reverse (map littleendian (join x))))
Salsa20_rounds : [32] -> [16][4][32] -> [16][4][32]
Salsa20_rounds n state =
  state @@ [i | i <- [0 .. 99] : [_][5] | (i % 16) == n]
Salsa20 : [32] -> [64][8] -> [64][8]
Salsa20 n input =
  littleendian_state_inverse
    (Salsa20_rounds (n + 20) (littleendian_state input))
property Salsa20_passes_tests =
  (Salsa20 0 expected_0 == output_0) /\ (Salsa20 1 expected_1 == output_1) /\
    (Salsa20 2 expected_2 == output_2)
  where
    output_0 =
      [0x95, 0x7f, 0x1c, 0x04, 0x24, 0x21, 0x3b, 0x14,
      0xc4, 0x84, 0xd3, 0x89, 0x5e, 0x63, 0x71, 0x6d,
      0x53, 0x7a, 0x4a, 0x13, 0x6e, 0x3f, 0x4e, 0x1d,
      0x7b, 0x51, 0x16, 0x07, 0x27, 0x26, 0x39, 0x1a,
      0x64, 0x4d, 0x41, 0x37, 0x75, 0x6c, 0x52, 0x3f,
      0x71, 0x56, 0x4a, 0x32, 0x69, 0x4e, 0x46, 0x38,
      0x78, 0x5b, 0x4f, 0x34, 0x66, 0x4c, 0x43, 0x37,
      0x7a, 0x5d, 0x41, 0x36, 0x6c, 0x4d, 0x45,
```
[GENERATED END]

