{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/examples\/llvm\/iterative_average\/test.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the given incremental averaging state machine (State, init, updatef, digest, avg) and the property imp_correct : {n} (fin n, 32 >= width n) => [n][32] -> Bool asserting avg xs == digest (updatef init xs) for all xs, suitable for formal verification."},{"role":"assistant","content":"```cryptol\ntype State =\n  { sum : [32]\n  , len : [32]\n  }\n\ninit : State\ninit =\n  { sum = 0\n  , len = 0\n  }\n\nupdatef : {n} (fin n, 32 >= width n) => State -> [n][32] -> State\nupdatef st xs =\n  { sum = st.sum + sum\n  , len = st.len + `n\n  }\n  where\n    sum = sums!0\n    sums = [ 0 ] # [ acc + x | acc <- sums | x <- xs ]\n\ndigest : State -> [32]\ndigest st = st.sum \/ st.len\n\navg : {n} (fin n, 32 >= width n) => [n][32] -> [32]\navg xs = sum \/ `n\n  where\n    sum = sums!0\n    sums = [ 0 ] # [ acc + x | acc <- sums | x <- xs ]\n\nimp_correct : {n} (fin n, 32 >= width n) => [n][32] -> Bool\nproperty imp_correct xs = avg xs == digest (updatef init xs)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/ExpandKey.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the AES key expansion (ExpandKey) for parameterized Nk and Nr, including functions expandKey, expandKeyForever, keyWS, Rcon, SubWord, RotWord, NextWord, and appropriate RoundKey typing, suitable for use in formal verification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::ExpandKey where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::State\nimport Primitive::Symmetric::Cipher::Block::AES::SubByteSBox\n\nparameter\n\n  type Nk : #\n  type constraint (8 >= width Nk, Nk >= 1)\n\n  type Nr : #\n  type constraint (8 >= width Nr, Nr >= 2)\n\nexpandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)\nexpandKey key = ( keys @ 0\n                , keys @@ ([1 .. (Nr - 1)] : [_][8])\n                , keys @ (`Nr : [8])\n                )\n  where   seed : [Nk][4][8]\n          seed = split (split key)\n          keys = expandKeyForever seed\n\nexpandKeyForever : [Nk][4][8] -> [inf]RoundKey\nexpandKeyForever seed = [ transpose g | g <- split (keyWS seed) ]\n\nkeyWS : [Nk][4][8] -> [inf][4][8]\nkeyWS seed    = xs\n     where xs = seed # [ NextWord i prev old\n                       | i    <- [ `Nk ... ]\n                       | prev <- drop`{Nk-1} xs\n                       | old  <- xs\n                       ]\n\nRcon : [8] -> [4]GF28\nRcon i = [ gf28Pow <| x |> (i-1), 0, 0, 0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord bs = [ SubByte b | b <- bs ]\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nNextWord : [8] ->[4][8] -> [4][8] -> [4][8]\nNextWord i prev old = old ^ mask\n   where mask = if i % nk == 0\n                then SubWord (RotWord(prev)) ^ Rcon (i \/ `Nk)\n                else if (nk > 6) && (i % nk == 4)\n                     then SubWord prev\n                     else prev\n\n         nk = `Nk : [8]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/ECDSA_tests.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the same ECDSA test properties for NIST curves P-192, P-224, P-256, P-384, and P-521, including point decompression, point addition\/subtraction, doubling, scalar and joint scalar multiplication, and mp_mod_sqrt correctness, matching the constants and structure shown."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::ECDSA_tests where\n\nimport Common::utils\n\nimport Primitive::Asymmetric::Signature::ECDSA::p192 as p192\nimport Primitive::Asymmetric::Signature::ECDSA::p224 as p224\nimport Primitive::Asymmetric::Signature::ECDSA::p256 as p256\nimport Primitive::Asymmetric::Signature::ECDSA::p384 as p384\nimport Primitive::Asymmetric::Signature::ECDSA::p521 as p521\n\nproperty p192_G_compress = p192::G_compress 0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\n\np192_S = {x = BVtoZ 0xd458e7d127ae671b0c330266d246769353a012073e97acf8,\n          y = BVtoZ 0x325930500d851f336bddc050cf7fb11b5673a1645086df3b}\n\np192_T = {x = BVtoZ 0xf22c4395213e9ebe67ddecdd87fdbd01be16fb059b9753a4,\n          y = BVtoZ 0x264424096af2b3597796db48f8dfb41fa9cecc97691a9c79}\n\nproperty p192_decompress_S = p192::affine_decompress_correct p192_S\nproperty p192_decompress_T = p192::affine_decompress_correct p192_T\n\nproperty p192_full_add_example =\n  p192::full_add_example R p192_S p192_T\n  where R = {x = BVtoZ 0x48e1e4096b9b8e5ca9d0f1f077b8abf58e843894de4d0290,\n             y = BVtoZ 0x408fa77c797cd7dbfb16aa48a3648d3d63c94117d7b6aa4b}\n\nproperty p192_full_subtract_example =\n  p192::full_subtract_example R p192_S p192_T\n  where R = {x = BVtoZ 0xfc9683cc5abfb4fe0cc8cc3bc9f61eabc4688f11e9f64a2e,\n             y = BVtoZ 0x093e31d00fb78269732b1bd2a73c23cdd31745d0523d816b}\n\nproperty p192_double_example =\n  p192::double_example R p192_S\n  where R = {x = BVtoZ 0x30c5bc6b8c7da25354b373dc14dd8a0eba42d25a3f6e6962,\n             y = BVtoZ 0x0dde14bc4249a721c407aedbf011e2ddbbcb2968c9d889cf}\n\nproperty p192_scalar_multiply_example0 =\n  p192::scalar_multiply_example R p192_S d\n  where d = BVtoZ 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        R = {x = BVtoZ 0x1faee4205a4f669d2d0a8f25e3bcec9a62a6952965bf6d31,\n             y = BVtoZ 0x5ff2cdfa508a2581892367087c696f179e7a4d7e8260fb06}\n\np192_S' = {x = BVtoZ 0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012,\n           y = BVtoZ 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811}\n\nproperty p192_scalar_multiply_example1=\n    p192::scalar_multiply_example R p192_S' d\n    where d = BVtoZ 0xe14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3\n          R = {x = BVtoZ 0x07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6,\n               y = BVtoZ 0x76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477}\n\nproperty p192_joint_scalar_multiply_example =\n  p192::joint_scalar_multiply_example R p192_S p192_T d e\n  where d = BVtoZ 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        e = BVtoZ 0xc4be3d53ec3089e71e4de8ceab7cce889bc393cd85b972bc\n        R = {x = BVtoZ 0x019f64eed8fa9b72b7dfea82c17c9bfa60ecb9e1778b5bde,\n             y = BVtoZ 0x16590c5fcd8655fa4ced33fb800e2a7e3c61f35d83503644}\n\nproperty mp_mod_sqrt_192_correct = p192::mp_mod_sqrt_correct\n\nproperty p224_G_compress = p224::G_compress 0x00000002b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\n\np224_S = {x = BVtoZ 0x6eca814ba59a930843dc814edd6c97da95518df3c6fdf16e9a10bb5b,\n          y = BVtoZ 0xef4b497f0963bc8b6aec0ca0f259b89cd80994147e05dc6b64d7bf22}\n\np224_T = {x = BVtoZ 0xb72b25aea5cb03fb88d7e842002969648e6ef23c5d39ac903826bd6d,\n          y = BVtoZ 0xc42a8a4d34984f0b71b5b4091af7dceb33ea729c1a2dc8b434f10c34}\n\nproperty p224_full_add_example =\n  p224::full_add_example R p224_S p224_T\n  where R = {x = BVtoZ 0x236f26d9e84c2f7d776b107bd478ee0a6d2bcfcaa2162afae8d2fd15,\n             y = BVtoZ 0xe53cc0a7904ce6c3746f6a97471297a0b7d5cdf8d536ae25bb0fda70}\n\nproperty p224_full_subtract_example =\n  p224::full_subtract_example R p224_S p224_T\n  where R = {x = BVtoZ 0xdb4112bcc8f34d4f0b36047bca1054f3615413852a7931335210b332,\n             y = BVtoZ 0x90c6e8304da4813878c1540b2396f411facf787a520a0ffb55a8d961}\n\nproperty p224_double_example =\n  p224::double_example R p224_S\n  where R = {x = BVtoZ 0xa9c96f2117dee0f27ca56850ebb46efad8ee26852f165e29cb5cdfc7,\n             y = BVtoZ 0xadf18c84cf77ced4d76d4930417d9579207840bf49bfbf5837dfdd7d}\n\nproperty p224_scalar_multiply_example =\n  p224::scalar_multiply_example R p224_S d\n  where d = BVtoZ 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        R = {x = BVtoZ 0x96a7625e92a8d72bff1113abdb95777e736a14c6fdaacc392702bca4,\n             y = BVtoZ 0x0f8e5702942a3c5e13cd2fd5801915258b43dfadc70d15dbada3ed10}\n\nproperty p224_joint_scalar_multiply_example =\n  p224::joint_scalar_multiply_example R p224_S p224_T d e\n  where d = BVtoZ 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        e = BVtoZ 0x54d549ffc08c96592519d73e71e8e0703fc8177fa88aa77a6ed35736\n        R = {x = BVtoZ 0xdbfe2958c7b2cda1302a67ea3ffd94c918c5b350ab838d52e288c83e,\n             y = BVtoZ 0x2f521b83ac3b0549ff4895abcc7f0c5a861aacb87acbc5b8147bb18b}\n\nproperty mp_mod_sqrt_224_correct = p224::mp_mod_sqrt_correct\n\nproperty p256_G_compress = p256::G_compress 0x000000036b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\n\np256_S = {x = BVtoZ 0xde2444bebc8d36e682edd27e0f271508617519b3221a8fa0b77cab3989da97c9,\n          y = BVtoZ 0xc093ae7ff36e5380fc01a5aad1e66659702de80f53cec576b6350b243042a256}\n\np256_T = {x = BVtoZ 0x55a8b00f8da1d44e62f6b3b25316212e39540dc861c89575bb8cf92e35e0986b,\n          y = BVtoZ 0x5421c3209c2d6c704835d82ac4c3dd90f61a8a52598b9e7ab656e9d8c8b24316}\n\nproperty p256_full_add_example =\n  p256::full_add_example R p256_S p256_T\n  where R = {x = BVtoZ 0x72b13dd4354b6b81745195e98cc5ba6970349191ac476bd4553cf35a545a067e,\n             y = BVtoZ 0x8d585cbb2e1327d75241a8a122d7620dc33b13315aa5c9d46d013011744ac264}\n\nproperty p256_full_subtract_example =\n  p256::full_subtract_example R p256_S p256_T\n  where R = {x = BVtoZ 0xc09ce680b251bb1d2aad1dbf6129deab837419f8f1c73ea13e7dc64ad6be6021,\n             y = BVtoZ 0x1a815bf700bd88336b2f9bad4edab1723414a022fdf6c3f4ce30675fb1975ef3}\n\nproperty p256_double_example =\n  p256::double_example R p256_S\n  where R = {x = BVtoZ 0x7669e6901606ee3ba1a8eef1e0024c33df6c22f3b17481b82a860ffcdb6127b0,\n             y = BVtoZ 0xfa878162187a54f6c39f6ee0072f33de389ef3eecd03023de10ca2c1db61d0c7}\n\nproperty p256_scalar_multiply_example =\n  p256::scalar_multiply_example R p256_S d\n  where d = BVtoZ 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        R = {x = BVtoZ 0x51d08d5f2d4278882946d88d83c97d11e62becc3cfc18bedacc89ba34eeca03f,\n             y = BVtoZ 0x75ee68eb8bf626aa5b673ab51f6e744e06f8fcf8a6c0cf3035beca956a7b41d5}\n\nproperty p256_joint_scalar_multiply_example =\n  p256::joint_scalar_multiply_example R p256_S p256_T d e\n  where d = BVtoZ 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        e = BVtoZ 0xd37f628ece72a462f0145cbefe3f0b355ee8332d37acdd83a358016aea029db7\n        R = {x = BVtoZ 0xd867b4679221009234939221b8046245efcf58413daacbeff857b8588341f6b8,\n             y = BVtoZ 0xf2504055c03cede12d22720dad69c745106b6607ec7e50dd35d54bd80f615275}\n\nproperty mp_mod_sqrt_256_correct = p256::mp_mod_sqrt_correct\n\nproperty p384_G_compress = p384::G_compress 0x00000003aa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\n\np384_S = {x = BVtoZ 0xfba203b81bbd23f2b3be971cc23997e1ae4d89e69cb6f92385dda82768ada415ebab4167459da98e62b1332d1e73cb0e,\n          y = BVtoZ 0x5ffedbaefdeba603e7923e06cdb5d0c65b22301429293376d5c6944e3fa6259f162b4788de6987fd59aed5e4b5285e45}\n\np384_T = {x = BVtoZ 0xaacc05202e7fda6fc73d82f0a66220527da8117ee8f8330ead7d20ee6f255f582d8bd38c5a7f2b40bcdb68ba13d81051,\n          y = BVtoZ 0x84009a263fefba7c2c57cffa5db3634d286131afc0fca8d25afa22a7b5dce0d9470da89233cee178592f49b6fecb5092}\n\nproperty p384_full_add_example =\n  p384::full_add_example R p384_S p384_T\n  where R = {x = BVtoZ 0x12dc5ce7acdfc5844d939f40b4df012e68f865b89c3213ba97090a247a2fc009075cf471cd2e85c489979b65ee0b5eed,\n             y = BVtoZ 0x167312e58fe0c0afa248f2854e3cddcb557f983b3189b67f21eee01341e7e9fe67f6ee81b36988efa406945c8804a4b0}\n\nproperty p384_full_subtract_example =\n  p384::full_subtract_example R p384_S p384_T\n  where R = {x = BVtoZ 0x6afdaf8da8b11c984cf177e551cee542cda4ac2f25cd522d0cd710f88059c6565aef78f6b5ed6cc05a6666def2a2fb59,\n             y = BVtoZ 0x7bed0e158ae8cc70e847a60347ca1548c348decc6309f48b59bd5afc9a9b804e7f7876178cb5a7eb4f6940a9c73e8e5e}\n\nproperty p384_double_example =\n  p384::double_example R p384_S\n  where R = {x = BVtoZ 0x2a2111b1e0aa8b2fc5a1975516bc4d58017ff96b25e1bdff3c229d5fac3bacc319dcbec29f9478f42dee597b4641504c,\n             y = BVtoZ 0xfa2e3d9dc84db8954ce8085ef28d7184fddfd1344b4d4797343af9b5f9d837520b450f726443e4114bd4e5bdb2f65ddd}\n\nproperty p384_scalar_multiply_example =\n  p384::scalar_multiply_example R p384_S d\n  where d = BVtoZ 0xa4ebcae5a665983493ab3e626085a24c104311a761b5a8fdac052ed1f111a5c44f76f45659d2d111a61b5fdd97583480\n        R = {x = BVtoZ 0xe4f77e7ffeb7f0958910e3a680d677a477191df166160ff7ef6bb5261f791aa7b45e3e653d151b95dad3d93ca0290ef2,\n             y = BVtoZ 0xac7dee41d8c5f4a7d5836960a773cfc1376289d3373f8cf7417b0c6207ac32e913856612fc9ff2e357eb2ee05cf9667f}\n\nproperty p384_joint_scalar_multiply_example =\n  p384::joint_scalar_multiply_example R p384_S p384_T d e\n  where d = BVtoZ 0xa4ebcae5a665983493ab3e626085a24c104311a761b5a8fdac052ed1f111a5c44f76f45659d2d111a61b5fdd97583480\n        e = BVtoZ 0xafcf88119a3a76c87acbd6008e1349b29f4ba9aa0e12ce89bcfcae2180b38d81ab8cf15095301a182afbc6893e75385d\n        R = {x = BVtoZ 0x917ea28bcd641741ae5d18c2f1bd917ba68d34f0f0577387dc81260462aea60e2417b8bdc5d954fc729d211db23a02dc,\n             y = BVtoZ 0x1a29f7ce6d074654d77b40888c73e92546c8f16a5ff6bcbd307f758d4aee684beff26f6742f597e2585c86da908f7186}\n\nproperty mp_mod_sqrt_384_correct = p384::mp_mod_sqrt_correct\n\nproperty p521_G_compress = p521::G_compress 0x04c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\n\np521_S = {x = BVtoZ 0x000001d5c693f66c08ed03ad0f031f937443458f601fd098d3d0227b4bf62873af50740b0bb84aa157fc847bcf8dc16a8b2b8bfd8e2d0a7d39af04b089930ef6dad5c1b4,\n          y = BVtoZ 0x00000144b7770963c63a39248865ff36b074151eac33549b224af5c8664c54012b818ed037b2b7c1a63ac89ebaa11e07db89fcee5b556e49764ee3fa66ea7ae61ac01823}\n\np521_T = {x = BVtoZ 0x000000f411f2ac2eb971a267b80297ba67c322dba4bb21cec8b70073bf88fc1ca5fde3ba09e5df6d39acb2c0762c03d7bc224a3e197feaf760d6324006fe3be9a548c7d5,\n          y = BVtoZ 0x000001fdf842769c707c93c630df6d02eff399a06f1b36fb9684f0b373ed064889629abb92b1ae328fdb45534268384943f0e9222afe03259b32274d35d1b9584c65e305}\n\nproperty p521_full_add_example =\n  p521::full_add_example R p521_S p521_T\n  where R = {x = BVtoZ 0x000001264ae115ba9cbc2ee56e6f0059e24b52c8046321602c59a339cfb757c89a59c358a9a8e1f86d384b3f3b255ea3f73670c6dc9f45d46b6a196dc37bbe0f6b2dd9e9,\n             y = BVtoZ 0x00000062a9c72b8f9f88a271690bfa017a6466c31b9cadc2fc544744aeb817072349cfddc5ad0e81b03f1897bd9c8c6efbdf68237dc3bb00445979fb373b20c9a967ac55}\n\nproperty p521_full_subtract_example =\n  p521::full_subtract_example R p521_S p521_T\n  where R = {x = BVtoZ 0x000001292cb58b1795ba477063fef7cd22e42c20f57ae94ceaad86e0d21ff22918b0dd3b076d63be253de24bc20c6da290fa54d83771a225deecf9149f79a8e614c3c4cd,\n             y = BVtoZ 0x000001695e3821e72c7cacaadcf62909cd83463a21c6d03393c527c643b36239c46af117ab7c7ad19a4c8cf0ae95ed51729885461aa2ce2700a6365bca3733d2920b2267}\n\nproperty p521_double_example =\n  p521::double_example R p521_S\n  where R = {x = BVtoZ 0x0000012879442f2450c119e7119a5f738be1f1eba9e9d7c6cf41b325d9ce6d643106e9d61124a91a96bcf201305a9dee55fa79136dc700831e54c3ca4ff2646bd3c36bc6,\n             y = BVtoZ 0x0000019864a8b8855c2479cbefe375ae553e2393271ed36fadfc4494fc0583f6bd03598896f39854abeae5f9a6515a021e2c0eef139e71de610143f53382f4104dccb543}\n\nproperty p521_scalar_multiply_example =\n  p521::scalar_multiply_example R p521_S d\n  where d = BVtoZ 0x000001eb7f81785c9629f136a7e8f8c674957109735554111a2a866fa5a166699419bfa9936c78b62653964df0d6da940a695c7294d41b2d6600de6dfcf0edcfc89fdcb1\n        R = {x = BVtoZ 0x00000091b15d09d0ca0353f8f96b93cdb13497b0a4bb582ae9ebefa35eee61bf7b7d041b8ec34c6c00c0c0671c4ae063318fb75be87af4fe859608c95f0ab4774f8c95bb,\n             y = BVtoZ 0x00000130f8f8b5e1abb4dd94f6baaf654a2d5810411e77b7423965e0c7fd79ec1ae563c207bd255ee9828eb7a03fed565240d2cc80ddd2cecbb2eb50f0951f75ad87977f}\n\nproperty p521_joint_scalar_multiply_example =\n  p521::joint_scalar_multiply_example R p521_S p521_T d e\n  where d = BVtoZ 0x000001eb7f81785c9629f136a7e8f8c674957109735554111a2a866fa5a166699419bfa9936c78b62653964df0d6da940a695c7294d41b2d6600de6dfcf0edcfc89fdcb1\n        e = BVtoZ 0x00000137e6b73d38f153c3a7575615812608f2bab3229c92e21c0d1c83cfad9261dbb17bb77a63682000031b9122c2f0cdab2af72314be95254de4291a8f85f7c70412e3\n        R = {x = BVtoZ 0x0000009d3802642b3bea152beb9e05fba247790f7fc168072d363340133402f2585588dc1385d40ebcb8552f8db02b23d687cae46185b27528adb1bf9729716e4eba653d,\n             y = BVtoZ 0x0000000fe44344e79da6f49d87c1063744e5957d9ac0a505bafa8281c9ce9ff25ad53f8da084a2deb0923e46501de5797850c61b229023dd9cf7fc7f04cd35ebb026d89d}\n\nproperty mp_mod_sqrt_521_correct = p521::mp_mod_sqrt_correct\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/gf.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the finite-field arithmetic module GF for the McEliece KEM by defining the types and functions gf_iszero, gf_add, gf_mul, gf_sqmul, gf_sq2mul, gf_sq2, gf_frac, and gf_inv over gf_t\/base_t with appropriate Cryptol types but without providing implementations."},{"role":"assistant","content":"```cryptol\nmodule GF where\n\nimport Types\n\ngf_iszero : base_t  -> base_t\ngf_iszero a = t_3 where\n    (t_1 : uint32t ) = cvt_16_to_32 a\n    (t_2 : uint32t ) = (t_1-1)>> 19\n    (t_3 : base_t) = cvt_32_to_16 t_2\n\ngf_add : base_t -> base_t -> base_t\ngf_add a b = a^b\n\ngf_mul : gf_t  -> gf_t  -> gf_t\ngf_mul a b = rtn  where\n    (t0:base_64t) = cvt_16_to_64 a\n    (t1:base_64t) = cvt_16_to_64 b\n    loop_i i tmp =\n        if (i>= GFBITS) then tmp\n        else loop_i (i+1) tmp' where\n            tmp' = t0 * (t1 && (1 << i))\n    (tmp_0 : base_64t) = t0 * (t1 && 1)\n    (tmp_1 : base_64t) = loop_i 0 tmp_0\n        (k_0: base_64t) =  cvt_20_to_64 0x1FF0000\n    (k_1: base_64t) =  cvt_20_to_64 0x000E000\n    (t_0: base_64t) = tmp_1 && k_0\n    (t_1: base_64t) = tmp_2 && k_1\n    (tmp_2 : base_64t) = tmp_1 ^ ((t_0 >> 9) ^ (t_0 >> 10) ^ (t_0 >> 12) ^ (t_0 >> 13))\n    (tmp_3 : base_64t) = tmp_2 ^ ((t_1 >> 9) ^ (t_1 >> 10) ^ (t_1 >> 12) ^ (t_1 >> 13))\n    (rtn : gf_t ) = cvt_64_to_16 (tmp_3 && GFMASK)\n\nloop_i i x limit M =\n    if(i<limit) then loop_i i' x' limit M where\n        t = x && (M@i)\n        x'= x^ (t >> 9) ^ (t >> 10) ^ (t >> 12) ^ (t >> 13)\n        i' = i+1\n    else  cvt_64_to_16 (x&& GFMASK)\n\ngf_sqmul : gf_t -> gf_t -> gf_t\ngf_sqmul a b = rtn where\n    M = [0x0000001FF0000000, 0x000000000FF80000, 0x000000000007E000]\n    (t0:uint64t) = cvt_16_to_64  a\n    (t1:uint64t) = cvt_16_to_64  b\n    (x1:uint64t) = (t1 << 6) * (t0 && (1 << 6))\n    (t2:uint64t) = t0^(t0 << 7)\n    (x2:uint64t) = x1^ (t1 * (t2 && (cvt_20_to_64 0x04001)))\n    (x3:uint64t) = x2^ (t1 * (t2 && (cvt_20_to_64 0x08002))) << 1\n    (x4:uint64t) = x3^ (t1 * (t2 && (cvt_20_to_64 0x10004))) << 2\n    (x5:uint64t) = x4^ (t1 * (t2 && (cvt_20_to_64 0x20008))) << 3\n    (x6:uint64t) = x5^ (t1 * (t2 && (cvt_20_to_64 0x40010))) << 4\n    (x7:uint64t) = x6^ (t1 * (t2 && (cvt_20_to_64 0x80020))) << 5\n    rtn = loop_i 0 x7 3 M\n\ngf_sq2mul : gf_t -> gf_t -> gf_t\ngf_sq2mul a b = rtn where\n    (M:[6][64]) = [0x1FF0000000000000,\n        0x000FF80000000000,\n        0x000007FC00000000,\n        0x00000003FE000000,\n        0x0000000001FE0000,\n        0x000000000001E000]\n    (t0:uint64t) = cvt_16_to_64 a\n    (t1:uint64t) = cvt_16_to_64 b\n    (x_1:uint64t) = (t1 << 18) * (t0 && (1 << 6))\n    t2 = t0^(t0 << 21)\n    (x_2:uint64t) = x_1^(t1 * (t0 && (cvt_36_to_64 0x010000001)))\n    (x_3:uint64t) = x_2^(t1 * (t0 && (cvt_36_to_64 0x020000002))) << 3\n    (x_4:uint64t) = x_3^(t1 * (t0 && (cvt_36_to_64 0x040000004))) << 6\n    (x_5:uint64t) = x_4^(t1 * (t0 && (cvt_36_to_64 0x080000008))) << 9\n    (x_6:uint64t) = x_5^(t1 * (t0 && (cvt_36_to_64 0x100000010))) << 12\n    (x_7:uint64t) = x_6^(t1 * (t0 && (cvt_36_to_64 0x200000020))) << 15\n    rtn = loop_i 0 x_7 6 M\n\ngf_sq2 : gf_t -> gf_t\ngf_sq2 in = rtn where\n    (B:[4][64]) = [0x1111111111111111,\n        0x0303030303030303,\n        0x000F000F000F000F,\n        0x000000FF000000FF]\n    (M:[4][64]) = [0x0001FF0000000000,\n        0x000000FF80000000,\n        0x000000007FC00000,\n        0x00000000003FE000]\n    (x_1:uint64t) = cvt_16_to_64 in\n    (x_2:uint64t) = (x_1 || (x_1 << 24)) && (B@3)\n    (x_3:uint64t) = (x_2 || (x_2 << 12)) && (B@2)\n    (x_4:uint64t) = (x_3 || (x_3 << 6)) && (B@1)\n    (x_5:uint64t) = (x_4 || (x_3 << 3)) && (B@0)\n    rtn = loop_i 0 x_5 4 M\n\ngf_frac : gf_t -> gf_t -> gf_t\ngf_frac d n = t7 where\n    t1 = gf_sqmul d d\n    t2 = gf_sq2mul t1 t1\n    t3 = gf_sq2 t2\n    t4 = gf_sq2mul t3 t2\n    t5 = gf_sq2 t4\n    t6 = gf_sq2mul t5 t2\n    t7 = gf_sqmul t7 n\n\ngf_inv : gf_t -> gf_t\ngf_inv d = gf_frac d 1\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/types.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Types` for the McEliece KEM low-level specification, including all given constants, type aliases, and conversion functions with the same names, types, and values as in the original file."},{"role":"assistant","content":"```cryptol\nmodule Types where\n\nSYS_T = 119\nSYS_N = 6960\nSYS_Nd8 = SYS_N\/8 \nGFBITS =  13\ntype GFBITS_t =  13\nCOND_BYTES  = (((1:[32]) << (GFBITS-(4:[32])))*(2*GFBITS - (1:[32])))\nIRR_BYTES = (SYS_T * 2)\nPK_NROWS  =  (SYS_T*GFBITS)\nPK_NCOLS  =  (SYS_N - PK_NROWS)\nPK_ROW_BYTES  =  ((PK_NCOLS + 7)\/8)\ntype PK_ROW_BYTES_t = [677]\nSK_BYTES  =  (SYS_Nd8 + IRR_BYTES + COND_BYTES)\nSYND_BYTES  =  ((PK_NROWS + 7)\/8)\ntype SYND_BYTES_t = [194]\nGFMASK  =  (((1:[32]) << GFBITS) - 1)\ntype j_size_t =  1024 \n\ntype base_16t = [16]\ntype base_32t = [32]\ntype base_64t = [64]\ntype uint16t = [16]\ntype uint64t = [64]\ntype uint32t = [32]\ntype base_t = base_16t\ntype gf_t = base_t\n\ntype ciphertext_t = [226] base_t    type keybytes_t = [32] base_t type publickey_t = [1047319]base_t type secretkey_t = [13908] base_t \ntype g_s_t =   ciphertext_t\ntype g_ct_t =  ciphertext_t\ntype g_key_t = keybytes_t\ntype g_pk_t =  publickey_t\ntype g_sk_t = secretkey_t\n\ntype SYS_N8_t = [870] base_t\ntype SYS_N8_plus1_t = [871] base_t\ntype SYS_N8_plus2_t = [872]base_t\n\nSYS_T_double = 238type SYS_T_double_t = [238]base_t\ntype SYS_N_t = [6960]base_t\ntype SYS_T_plus1 = [120]base_t\n\ntype L_t = SYS_N_t type f_t = SYS_N8_t\ntype r_t = SYS_N8_t\ntype g_t = SYS_T_plus1\ntype s_t = SYS_T_double_t \ntype e_t = SYS_N8_plus2_t\ntype ind_t = SYS_T_double_t\ntype e_int_t = [109]base_t\ntype val_t = [119] base_t\ntype e_pieces_t = [109][8]base_t\n\ntype pm_t =  [1097]base_t \n\ncvt_16 e = fromInteger `{[16]} (toInteger e)\ncvt_32 e = fromInteger `{[32]} (toInteger e)\ncvt_64 e = fromInteger `{[64]} (toInteger e)\ncvt_32_to_16 e = cvt_16 e\ncvt_64_to_16 e = cvt_16 e\ncvt_16_to_32 e = cvt_32 e\ncvt_20_to_64 e = cvt_64 e\ncvt_16_to_64 e = cvt_64 e\ncvt_36_to_64 e = cvt_64 e\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/Encapsulation.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the McEliece KEM encapsulation algorithm in Cryptol by fully defining all missing types and functions (including compute_hash_1e, compute_hash_2e, step_1, and step_2) so that encapsulation correctly produces a session key and ciphertext from a public key and error vector."},{"role":"assistant","content":"```cryptol\nmodule Encapsulation where\n\nparameter\n    type t : #\n    type constraint (fin t, t>=1, t-1>=1)\n    type n : #\n    type constraint (fin n, n>=1)\n    type m : #\n    type constraint (fin m, m>=1, t * n == min t n)\n    type d : #\n\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [(n-m*t)]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [m*t]f2_T  type H_T = [t][n]field_element_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                    , a : alphas_T                  }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                       , g : gamma_T\n    }\ntype public_key_T = [m*t][(n-m*t)]f2_T\ntype C0_T = mt_T\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\n\ntype weighted_T = n_T\n\nstep_1 : mt_T -> public_key_T -> H_T\nstep_1 I A = zero\n\nstep_2 : H_T -> weighted_T -> C0_T\nstep_2 H e = zero\n\nencoding_subroutine : weighted_T -> public_key_T -> C0_T\nencoding_subroutine e T = C0 where\n    (I: mt_T) = zero\n    (H:H_T) = step_1 I T         (C0:C0_T) = step_2 H e\n\ntype session_key_t = [32] compute_hash_2e e = undefined\ncompute_hash_1e e C = undefined\n\nencapsulation\n    : public_key_T ->  weighted_T\n    -> (session_key_t, cipher_text_T)\nencapsulation T e =  (K, C) where\n            (C0 : C0_T) = encoding_subroutine e T\n        (C1: C1_T) = compute_hash_2e e\n    (C: cipher_text_T) = {C0 = C0, C1 = C1}\n    (K: session_key_t) = compute_hash_1e e C\n```"}]}
{"filename":"BLST-Verification\/tests\/FrobeniusTests.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines properties `fp2_frobenius_prop`, `f6_frobenius_prop`, and `f12_frobenius_prop` asserting that `fp2_frobenius`, `fp6_frobenius`, and `fp12_frobenius` equal `F_expt` over `P::Fp_2`, `P::Fp_6`, and `P::Fp_12` (after normalization) using the prime `p : [381] = P::p`."},{"role":"assistant","content":"```cryptol\nimport Parameters as P\nimport Frobenius\nimport FieldExtras\n\np: [381]\np = `P::p\n\nproperty fp2_frobenius_prop x =\n  fp2_frobenius x' == F_expt P::Fp_2 x' p where x' = P::Fp_2.normalize x\n\nproperty f6_frobenius_prop x =\n  fp6_frobenius x' == F_expt P::Fp_6 x' p where x' = P::Fp_6.normalize x\n\nproperty f12_frobenius_prop x =\n  fp12_frobenius x' == F_expt P::Fp_12 x' p where x' = P::Fp_12.normalize x\n```"}]}
{"filename":"BLST-Verification\/spec\/PrimeField.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module PrimeField that defines prime_field_integer, prime_field, and prime_field_bv as FieldRep instances implementing modular field arithmetic over Integers, Z k, and [n], respectively, matching the given operations and interfaces."},{"role":"assistant","content":"```cryptol\nmodule PrimeField where\n\nimport Common::Field\nimport Common::ModDivZ\nimport Common::mod_arith\n\nprime_field_integer: Integer -> FieldRep Integer\nprime_field_integer p =\n    { is_val x = 0 <= x \/\\ x < p\n    , normalize x = x % p\n    , add (x, y) =  mod_add_Z (p,x,y)\n    , sub (x, y) = mod_sub_Z (p,x,y)\n    , neg x = mod_neg_Z (p,x)\n    , mul (x,y) = mod_mul_Z (p,x,y)\n    , sq x = mod_sq_Z (p, x)\n    , half x = mod_half_Z (p,x)\n    , div (x,y) = mod_div_Z (p,x,y)\n    , field_zero = 0\n    , field_unit = 1\n    , is_equal (x, y) = x==y\n    }\n\nmod_add_Z: (Integer,Integer,Integer) -> Integer\nmod_add_Z (p,x,y) = (x + y) % p\n\nmod_sub_Z: (Integer,Integer,Integer) -> Integer\nmod_sub_Z (p,x,y) = (x - y) % p\n\nmod_mul_Z: (Integer,Integer,Integer) -> Integer\nmod_mul_Z (p,x,y) = (x * y) % p\n\nmod_neg_Z: (Integer,Integer) -> Integer\nmod_neg_Z (p, x) = (-x)%p\n\nmod_sq_Z: (Integer,Integer) -> Integer\nmod_sq_Z (p,x) = mod_mul_Z (p, x, x)\n\nmod_half_Z: (Integer,Integer)-> Integer\nmod_half_Z (p, x) = if (x%2==0) then x\/2 else (x+p)\/2\n\nmod_div_Z : (Integer,Integer,Integer) -> Integer\nmod_div_Z (p,x,y) = egcd(p,0,y%p,x%p)\n  where\n\n    egcd(a,ra,b,rb) =\n      if b == 0 then\n        ra\n      else if (b % 2) == 0 then \n        egcd(a, ra, b \/ 2, mod_half_Z(p, rb))\n      else if a < b then\n        egcd(a, ra, (b - a) \/ 2, mod_half_Z (p, (rb-ra)%p))\n      else\n        egcd(b, rb, (a - b) \/ 2, mod_half_Z (p, (ra-rb)%p))\n\nprime_field: {k} (fin k, k >= 3, k > 2*(k\/2)) =>  FieldRep (Z k)\nprime_field =\n    { is_val x = True\n    , normalize x = x\n    , add (x, y) = x + y\n    , sub (x, y) = x - y\n    , neg x = -x\n    , mul (x,y) = x*y\n    , sq x = x*x\n    , half x = moddiv x 2\n    , div (x,y) = moddiv x y\n    , field_zero = 0\n    , field_unit = 1\n    , is_equal (x, y) = x==y\n    }\n\nprime_field_bv: {n} (fin n, n >= 1) => [n] -> FieldRep [n]\nprime_field_bv m =\n    { is_val x = x < m\n    , normalize x = (x % m)\n    , add (x, y) = mod_add (m,x,y)\n    , sub (x, y) = mod_sub (m,x,y)\n    , neg x = mod_neg (m, x)\n    , mul (x,y) = mod_mul (m, x, y)\n    , sq x = mod_mul (m, x, x)\n    , half x = mod_half (m, x)\n    , div (x,y) = mod_div (m, x, y)\n    , field_zero = 0\n    , field_unit = 1\n    , is_equal (x, y) = x==y     }\n```"}]}
{"filename":"cryptol\/examples\/Test.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Test` that, given a generic `Cipher ks bs`, defines the functions `evktest`, `evttest`, `ekatest`, `dvktest`, `dvttest`, and `dkatest` to batch-check correctness of encryption and decryption against provided key\/plaintext\/ciphertext test vectors."},{"role":"assistant","content":"```cryptol\nmodule Test where\nimport Cipher\n\nevktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\nevktest (cipher, vkeysCTs, PT) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, CT) <- vkeysCTs ]\n\nevttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\nevttest (cipher, Key, vtextPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (PT, CT) <- vtextPCTs ]\n\nekatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\nekatest (cipher, kaKPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, PT, CT) <- kaKPCTs ]\n\ndvktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\ndvktest (cipher, vkeysCTs, PT) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, CT) <- vkeysCTs ]\n\ndvttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\ndvttest (cipher, Key, vtextPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (PT, CT) <- vtextPCTs ]\n\ndkatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\ndkatest (cipher, kaKPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, PT, CT) <- kaKPCTs ]\n```"}]}
{"filename":"cryptol\/bench\/data\/SHA512.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the SHA-512 hash function with function sha512 and supporting constants, and include a property testVector1 that checks sha512 against the given known-answer test vector."},{"role":"assistant","content":"```cryptol\nmodule SHA512 where\n\nsha512 M = result\n  where\n    M' = (pad M)\n    blocks = (groupBy`{1024} M')\n    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]\n    result = (join (hash!0))\n\nprocessBlock : [1024] -> [8][64] -> [8][64]\nprocessBlock block Hprev = Hs\n  where\n    Mi = split block : [16][64]\n    Ws = (messageSch Mi)\n    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]\n    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]\n\nstep : [8][64] -> [64] -> [8] -> [8][64]\nstep [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']\n  where\n    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt\n    T2 = (SIGMA0 a) + (Maj a b c)\n    h' = g\n    g' = f\n    f' = e\n    e' = d + T1\n    d' = c\n    c' = b\n    b' = a\n    a' = T1 + T2\n\nmessageSch : [16][64] -> [80][64]\nmessageSch Mi = W\n  where\n    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]\n\npad : {l, k} (fin l,\n              l <= ((2^^128) - 1),\n              l >= 0,\n              fin k,\n              k - l >= 129,\n              k == 128 + l + 1 + 1024 - ((l+129)%1024),\n              k%1024 == 0) => [l] -> [k]\npad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])\n\nCh : [64] -> [64] -> [64] -> [64]\nCh x y z = (x && y) ^ ((~x) && z)\n\nMaj : [64] -> [64] -> [64] -> [64]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nSIGMA0 : [64] -> [64]\nSIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)\n\nSIGMA1 : [64] -> [64]\nSIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)\n\nsigma0 : [64] -> [64]\nsigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)\n\nsigma1 : [64] -> [64]\nsigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)\n\nH0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]\n\nK = [\n0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n]\n\nproperty testVector1 x = sha512 0xfd2203e467574e834ab07c9097ae164532f24be1eb5d88f1af7748ceff0d2c67a21f4e4097f9d3bb4e9fbf97186e0db6db0100230a52b453d421f8ab9c9a6043aa3295ea20d2f06a2f37470d8a99075f1b8a8336f6228cf08b5942fc1fb4299c7d2480e8e82bce175540bdfad7752bc95b577f229515394f3ae5cec870a4b2f8 == 0xa21b1077d52b27ac545af63b32746c6e3c51cb0cb9f281eb9f3580a6d4996d5c9917d2a6e484627a9d5a06fa1b25327a9d710e027387fc3e07d7c4d14c6086cc\n```"}]}
{"filename":"cryptol\/tests\/parser\/T437.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the functions `mk_buggy_fib_no_init`, `generate`, the infix operator `$`, and the sequences `foo` and `bar` with the given types and recursive\/indexing behavior in a Cryptol module."},{"role":"assistant","content":"```cryptol\nmk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n  \/\/ Change output when state has magic value.\n  fn' = fn + if k == magic then 1 else 0\n\ngenerate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. n-1] ]\n\ninfixl 1 $\nf $ x = f x\n\nfoo : [10][4]\nfoo = generate $ \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n\nbar : [10][4]\nbar = generate \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n```"}]}
{"filename":"cryptol\/tests\/regression\/f2polytest.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol specifications for polynomial multiplication, division, and modulus over GF(2) (pmult, pdiv, pmod) and properties showing they are equivalent to corresponding reference implementations Ref::pmult, Ref::pdiv, and Ref::pmod for several fixed input sizes."},{"role":"assistant","content":"```cryptol\nimport Cryptol::Reference as Ref\n\npmult_equiv : {u, v} (fin u, fin v) => [1+u] -> [1+v] -> Bit\npmult_equiv x y = pmult x y == Ref::pmult x y\n\npdiv_equiv : {u, v} (fin u, fin v) => [u] -> [v] -> Bit\npdiv_equiv x y = y == 0 \\\/ pdiv x y == Ref::pdiv x y\n\npmod_equiv : {u, v} (fin u, fin v) => [u] -> [1+v] -> Bit\npmod_equiv x y = y == 0 \\\/ pmod x y == Ref::pmod x y\n\nproperty mult3_9   = pmult_equiv`{3,9}\nproperty mult9_3   = pmult_equiv`{9,3}\nproperty mult8_8   = pmult_equiv`{8,8}\nproperty mult28_11 = pmult_equiv`{28,11}\nproperty mult32_32 = pmult_equiv`{32,32}\nproperty mult64_64 = pmult_equiv`{64,64}\n\nproperty div3_9   = pdiv_equiv`{3,9}\nproperty div9_3   = pdiv_equiv`{9,3}\nproperty div8_8   = pdiv_equiv`{8,8}\nproperty div28_11 = pdiv_equiv`{28,11}\nproperty div32_32 = pdiv_equiv`{32,32}\nproperty div64_64 = pdiv_equiv`{64,64}\n\nproperty mod3_9   = pmod_equiv`{3,9}\nproperty mod9_3   = pmod_equiv`{9,3}\nproperty mod8_8   = pmod_equiv`{8,8}\nproperty mod28_11 = pmod_equiv`{28,11}\nproperty mod32_32 = pmod_equiv`{32,32}\nproperty mod64_64 = pmod_equiv`{64,64}\n```"}]}
{"filename":"cryptol\/tests\/regression\/r05.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `unflatten : {r,w} (fin r, 5 * w >= r, fin w) => [r] -> [w][5]` that pads its input with zeros and groups it into `w` blocks of 5 elements using `groupBy` in Cryptol."},{"role":"assistant","content":"```cryptol\nunflatten : {r, w}\n            (fin r, 5 * w >= r, fin w)\n            => [r] -> [w][5]\nunflatten p = groupBy`{5}(p # zero)\n```"}]}
{"filename":"cryptol\/tests\/regression\/check09.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines streams ss and ls and a function keyX : [4][8] -> [7][32] as given, and a property check9 asserting that ss, ls, and keyX produce the specified constant test vectors."},{"role":"assistant","content":"```cryptol\ninitS : [1][32]\ninitL : [1][32]\ninitS = [0]\ninitL = [0]\nss = [ (s + a + b) <<< 3   | s <- initS # ss\n\t                       | a <- [1] # ss\n\t                       | b <- [0] # ls ]\nls = [ (l + a + b) <<< (a + b)\n                        | l <- initL # ls\n\t\t                | a <- ss\n\t\t                | b <- [0] # ls ]\n\ncheck9a = (ss @@ [0 .. 3] == [ 0x00000008, 0x00004080, 0x00068c00, 0x00a22800 ])\n       && (ls @@ [0 .. 3] == [ 0x00000800, 0x00005080, 0x00072d00, 0x00b08200 ])\n\nkeyX : [4][8] -> [7][32]\nkeyX key = ss @@ [ 0 .. 6 ]\n  where\n    initS : [1][32]\n    initL : [1][32]\n    initS = [0]\n    initL = split (join key)\n    ss = [ (s + a + b) <<< 3\n                    | s <- initS # ss\n\t\t\t\t    | a <- [1] # ss\n\t\t\t\t    | b <- [0] # ls ]\n    ls = [ (l + a + b) <<< (a + b)\n                    | l <- initL # ls\n\t\t\t\t    | a <- ss\n\t\t\t\t    | b <- [0] # ls ]\n\ncheck9b = keyX (reverse \"abcd\") ==\n\t    [0x00000008, 0x1b134ba3, 0x11ae69b1, 0xb7b3f42f,\n             0xc9eb1fdc, 0x008b5f36, 0x8991bc8c]\n\ncheck9 = check9a && check9b\n```"}]}
{"filename":"cryptol\/tests\/regression\/primes.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines primes p as modular integer types Z p, implements modular reciprocal and division operations, and includes properties recip_correct and moddiv_eq that verify multiplicative inverses and division correctness for primes 17, 1021, and the primes p192, p224, p256, p384, and p521."},{"role":"assistant","content":"```cryptol\nz1prime : {n} (prime n) => Z n\nz1prime = 1\n\nz1_2 = z1prime`{2}\nz1_3 = z1prime`{3}\nz1_17 = z1prime`{17}\nz1_2_17m1 = z1prime`{2^^17 - 1}\n\ntype p192 = 6277101735386680763835789423207666416083908700390324961279\ntype p224 = 26959946667150639794667015087019630673557916260026308143510066298881\ntype p256 = 115792089210356248762697446949407573530086143415290314195533631308867097853951\ntype p384 = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\ntype p521 = 6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151\n\nrecip_correct : {p} (prime p) => Z p -> Bool\nrecip_correct x = x == 0 \\\/ x * recip x == 1\n\nproperty recip_correct_17   = recip_correct`{17}\nproperty recip_correct_1021 = recip_correct`{1021}\nproperty recip_correct_p192 = recip_correct`{p192}\nproperty recip_correct_p224 = recip_correct`{p224}\nproperty recip_correct_p256 = recip_correct`{p256}\nproperty recip_correct_p384 = recip_correct`{p384}\nproperty recip_correct_p521 = recip_correct`{p521}\n\nmoddiv_eq : {p} (prime p, p >= 3) => Z p -> Z p -> Bool\nmoddiv_eq x y = y == 0 \\\/ (x \/. y) * y == x\n\nproperty moddiv_eq17   = moddiv_eq`{17}\nproperty moddiv_eq1021 = moddiv_eq`{1021}\n\nproperty moddiv_eq_p192 = moddiv_eq`{p192}\nproperty moddiv_eq_p224 = moddiv_eq`{p224}\nproperty moddiv_eq_p256 = moddiv_eq`{p256}\nproperty moddiv_eq_p384 = moddiv_eq`{p384}\nproperty moddiv_eq_p521 = moddiv_eq`{p521}\n```"}]}
{"filename":"cryptol\/tests\/regression\/check07.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the given shift expressions and boolean checks (check7a, check7b, check7c), and a property check7 that verifies all these shift-related equalities hold for the specified bit-vector values and ranges."},{"role":"assistant","content":"```cryptol\nshiftls1 = [ 0x12345678 << i | i <- [ 0 .. 32 ] ]\nshiftls2 = [ 0x12345678 << i | i <- [ 32 .. 64 ] ]\nshiftls3 = [ 0x12345678 << i | i <- [ 0x80000000 .. 0x8000000f ] ]\nshiftrs1 = [ 0x12345678 >> i | i <- [ 0 .. 32 ] ]\nshiftrs2 = [ 0x12345678 >> i | i <- [ 32 .. 64 ] ]\nshiftlbig1 : [48][48]\nshiftlbig1 = [ 0x12345678abcd << i | i <- [ 0 .. 47 ] ]\nshiftlbig1' : [48][48]\nshiftlbig1' = [ 0x12345678abcd * 2^^i | i <- [ 0 .. 47 ] ]\n\ncheck7a = shiftls3 == [ 0, 0 ... ] @@ [ 0 .. 0xf ]\ncheck7b = shiftlbig1 == shiftlbig1'\ncheck7c = (1:[1]) << 1 == 0\ncheck7 = check7a && check7b && check7c\n```"}]}
{"filename":"cryptol\/tests\/issues\/T146.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the record-based curve-operations constructor mk_curve_ops, the functions ec_v1 and ec_v2 with the given polymorphic types and record-field accesses, ensuring type-correct use of the field and v0 components."},{"role":"assistant","content":"```cryptol\nmk_curve_ops f = undefined\n  where\n    c = { field = f\n        , v1    = ec_v1 f\n        , v2    = ec_v2 c\n        }\n\nec_v1 : {fv} { v0: fv } -> fv\nec_v1 = undefined\n\nec_v2 : {fv} _ -> fv\nec_v2 p = p.field.v0\n  where _ = p.field.v0\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T038.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the submodules and interfaces I, F, P, Q, and J exactly as specified, using interface and submodule imports to expose x : [8] and define y = x + 1 with the given structure."},{"role":"assistant","content":"```cryptol\nmodule T038 where\n\ninterface submodule I where\n  x : [8]\n\nsubmodule F where\n  import interface submodule I\n  y = x + 1\n\nsubmodule P where\n  import submodule F { submodule Q }\n  x = 11\n\nsubmodule Q where\n  x = 11\n\ninterface submodule J where\n  import submodule F { submodule P }\n  x : [8]\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/ffi-fallback.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, reproduce these foreign function declarations and definitions, ensuring they use the C calling convention and the given behaviors for 8-bit inputs, suitable for FFI fallback testing."},{"role":"assistant","content":"```cryptol\nforeign foreignAndCryptol : [8] -> [8]\nforeignAndCryptol x = x\n\nforeign foreignAndNoCryptol : [8] -> [8]\n\nforeign noForeignAndCryptol : [8] -> [8]\nnoForeignAndCryptol x = x + 3\n\nforeign noForeignAndNoCryptol : [8] -> [8]\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for a parameterized AES module that defines encrypt\/decrypt for key sizes 128, 192, and 256 bits, includes key expansion, and a property test k pt = decrypt k (encrypt k pt) == pt for all valid keys and 128-bit plaintexts."},{"role":"assistant","content":"```cryptol\nmodule AES where\n\nimport AES::Algorithm as AES where\n  type Mode = m\n  encRound = AESRound\n  decRound = AESInvRound\n\nimport AES::ExpandKey where\n  type Nk = AES::Nk\n  type Nr = AES::Nr\n\nimport AES::TBox\n\nparameter\n\n  type m : #\n  type k : #\n  type constraint (k == 128 + m * 64, 2 >= m)\n\ntype EncKey = AES::KeySchedule\ntype DecKey = AES::KeySchedule\n\nencrypt : [k] -> [128] -> [128]\nencrypt k = encryptWithSchedule (expandKeyEnc k)\n\ndecrypt : [k] -> [128] -> [128]\ndecrypt k = decryptWithSchedule (expandKeyDec k)\n\nexpandKeyEnc : [k] -> EncKey\nexpandKeyEnc = expandKey\n\nencryptWithSchedule : EncKey -> [128] -> [128]\nencryptWithSchedule = AES::encrypt\n\nexpandKeyDec : [k] -> EncKey\nexpandKeyDec k = makeDecKey (expandKey k)\n\ndecryptWithSchedule : DecKey -> [128] -> [128]\ndecryptWithSchedule = AES::decrypt\n\nproperty test k pt = decrypt k (encrypt k pt) == pt\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/bivium.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that specifies the Bivium stream cipher with Bivium_stream, Bivium, Bivium_alt, and cycle functions, and includes properties Bivium_correct, Bivium_search, Bivium_search_with_suffix, and Bivium_alt_equivalent as given, using the provided IVs, suffix, and test_keystream."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::bivium where\n\nBivium_stream : [93] -> [84] -> [inf]\nBivium_stream R1 R2 = stream\n\twhere\n\t(stream, ra, rb) = shift_regs R1 R2\n\ntype N = 200\nBivium : ([93], [84]) -> [N]Bit\nBivium (reg1, reg2) = keystream\n  where\n    keystream =  take`{N} (Bivium_stream reg1 reg2)\n\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n\t\tfills = [bit]#(drop`{1} (fill >> 1))\n\nshift_regs : {d,e} (fin d, fin e, d >=1, e >=1) => [d] -> [e] -> ([inf],[inf][d],[inf][e])\nshift_regs r1 r2 = (stream, regA, regB)\n\twhere\n\t\ts1 = [(f1 @ 65) ^ (f1 @ 92) | f1 <- regA]\n\t\ts2 = [(f2 @ 68) ^ (f2 @ 83) | f2 <- regB]\n\n\t\tstream = s1 ^ s2\n\t\tt1 = [(f1 @ 65) ^ ((f1 @ 90) && (f1 @ 91)) ^ (f1 @ 92) ^ (f2 @ 77) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf1 <- regA ]\n\t\tt2 = [(f2 @ 68) ^ ((f2 @ 81) && (f2 @ 82)) ^ (f2 @ 83) ^ (f1 @ 68) |\n\t\t\t\tf1 <- regA |\n\t\t\t\tf2 <- regB ]\n\n\t\tregA = [r1] # [shift f b| f <- regA | b <- t2]\n\t\tregB = [r2] # [shift f b| f <- regB | b <- t1]\n\nBivium_alt : ([93], [84]) -> [N]Bit\nBivium_alt (r1, r2) = take`{N} (s1 ^ s2)\n  where\n    a_65 = drop`{27} a_92\n    a_68 = drop`{24} a_92\n    a_90 = drop`{2} a_92\n    a_91 = drop`{1} a_92\n    a_92 = reverse r1 # t2\n\n    b_68 = drop`{15} b_83\n    b_77 = drop`{6} b_83\n    b_81 = drop`{2} b_83\n    b_82 = drop`{1} b_83\n    b_83 = reverse r2 # t1\n\n    s1 = a_65 ^ a_92\n    s2 = b_68 ^ b_83\n\n    t1 = s1 ^ (a_90 && a_91) ^ b_77\n    t2 = s2 ^ (b_81 && b_82) ^ a_68\n\niv1 = 0b111110000000101010100100010001000000101010100001011111111111111100100100111111111011111111111\niv2 = 0b000000000000000000001000000000000000000001000000000000000000001000000000000000000001\n\ntest_keystream = 0b01000010000100000101110001100011111101110101110111111110100001111111100110101001000010101100100010000100001100011100000010001001100101101001011101110100000001011010001101000011001000110011111010100110\n\nsuffix = 0b000000001000000000000000000001\nproperty Bivium_correct = (Bivium(iv1, iv2)) == test_keystream\nproperty Bivium_search (x, y) = (Bivium(x, y)) == test_keystream\nproperty Bivium_search_with_suffix (x, y) = (Bivium(x, y#suffix)) == test_keystream\nproperty Bivium_alt_equivalent r = Bivium_alt r == Bivium r\n\ncycle : {n} (fin n) => [n] -> [93] -> [84] -> Bit\ncycle n rA rB =\n  (rA == regAs @ n) \/\\ (rB == regBs @ n) \/\\ rA != 0 \/\\ rB != 0\n    where\n      (_, regAs, regBs) = shift_regs rA rB\n\ncycle0 rA rB = cycle (0 : [8]) rA rB\ncycle1 rA rB = cycle (1 : [8]) rA rB\ncycle2 rA rB = cycle (2 : [8]) rA rB\ncycle3 rA rB = cycle (3 : [8]) rA rB\ncycle4 rA rB = cycle (4 : [8]) rA rB\ncycle5 rA rB = cycle (5 : [8]) rA rB\ncycle10 rA rB = cycle (10 : [8]) rA rB\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon96_96.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96` that instantiates the Simon block cipher specification for the 96-bit block and 96-bit key variant using types `n = 48`, `m = 2`, `T = 52`, and `j = 2`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 48\n    type m = 2\n    type T = 52\n    type j = 2\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/FNV.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the 64-bit FNV-1a hash function in Cryptol, including fnv1a, its internal helpers and constants, and a property testsPass that checks the given known-answer test vectors for empty, \"a\", and \"foobar\" inputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::FNV where\n\nfnv1a : {n} (fin n) => [n] -> [64]\nfnv1a ws = fnv1a' (pad ws)\n\npad : {msgLen} (fin msgLen) => [msgLen] -> [msgLen \/^ 8][8]\npad msg = split (msg # (zero:[msgLen %^ 8]))\n\nfnv1a' : {chunks} (fin chunks) => [chunks][8] -> [64]\nfnv1a' msg = Ss ! 0\n  where\n   Ss = [fnv1a_offset_basis] #\n           [ block s m\n           | s <- Ss\n           | m <- msg\n           ]\n\nblock : {padLen} ( padLen == 64 - 8) => [64] -> [8] -> [64]\nblock state val = (state ^ ((zero : [padLen]) # val)) * fnv1a_prime\n\nfnv1a_offset_basis : [64]\nfnv1a_offset_basis = 14695981039346656037\n\nfnv1a_prime : [64]\nfnv1a_prime = 1099511628211\n\nt1 = fnv1a [] == 0xcbf29ce484222325\nt2 = fnv1a (join \"a\") == 0xaf63dc4c8601ec8c\nt3 = fnv1a (join \"foobar\") == 0x85944171f73967e8\n\nproperty testsPass = and [t1, t2, t3]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Tests\/SHA224.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that verify a SHA224::hash function against known test vectors for inputs \"abc\", the empty string, the 448-bit alphabet string, and the 896-bit alphabet string, matching the specified SHA-224 digest outputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Tests::SHA224 where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA224 as SHA224\n\nproperty abcWorks = SHA224::hash (join \"abc\") == output where\n    output = join [\n        0x23097d22, 0x3405d822, 0x8642a477, 0xbda255b3,\n        0x2aadbce4, 0xbda0b3f7, 0xe36c9da7\n    ]\n\nproperty emptyStringWorks = SHA224::hash [] == output where\n    output = join [\n        0xd14a028c, 0x2a3a2bc9, 0x476102bb, 0x288234c4,\n        0x15a2b01f, 0x828ea62a, 0xc5b3e42f\n    ]\n\nproperty alphabet448 = SHA224::hash input == output where\n    input = join \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    output = join [\n        0x75388b16, 0x512776cc, 0x5dba5da1, 0xfd890150,\n        0xb0c6455c, 0xb4f58b19, 0x52522525\n    ]\n\nproperty alphabet896 = SHA224::hash input == output where\n    input = join \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n    output = join [\n        0xc97ca9a5, 0x59850ce9, 0x7a04a96d, 0xef6d99a9,\n        0xe0e0e2ab, 0x14e6b8df, 0x265fc0b3\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA384.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA384` that instantiates the generic SHA-2 specification for SHA-384 with 64-bit words, 384-bit digest size, and the given 8-word initial hash vector `H0`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 384\n\n            H0 = [\n        0xcbbb9d5dc1059ed8, 0x629a292a367cd507,\n        0x9159015a3070dd17, 0x152fecd8f70e5939,\n        0x67332667ffc00b31, 0x8eb44a8768581511,\n        0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHAKE256.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 with an xof function imported from the SHAKE256 instantiation and properties k5\u2013k8 that assert xof applied to [], 0b0, 0b11, and 0b110 equals the given 512-bit expected_result constants."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256\n\nproperty k5 = xof [] == expected_result where\n    expected_result = join [\n        0x46b9dd2b0ba88d13233b3feb743eeb24,\n        0x3fcd52ea62b81b82b50c27646ed5762f,\n        0xd75dc4ddd8c0f200cb05019d67b592f6,\n        0xfc821c49479ab48640292eacb3b7c4be\n    ]\n\nproperty k6 = xof 0b0 == expected_result where\n    expected_result = join [\n        0x1e20b13f3bdb730d286913335c092bce,\n        0xc0eb1aff2798c05736faa93bd665807a,\n        0x48ed7652aefd600427e9f797d647b9b3,\n        0x55d30410d71b8e275a676545600f1c35\n    ]\n\nproperty k7 = xof 0b11 == expected_result where\n    expected_result = join [\n        0x4f86b0eb85f7a9f6dc38b622706948ad,\n        0xb2beb6dd6911b5e9d865fd1f9667b5c0,\n        0x2a0dbb39c488b040a18ff3885f04ef95,\n        0x7c98f3948e6b7959a9b8950ffd6345d5\n    ]\n\nproperty k8 = xof 0b110 == expected_result where\n    expected_result = join [\n        0x27b5f40b3645215e370472ebb06817ae,\n        0xbddbe2cbd3a9a3ba3914da88e5853e70,\n        0x83630e6d51d7a009017d8176c3067329,\n        0xbec8e5f65591d65c5894c40132f1a2ab\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_224.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that instantiates SHA3-224 and defines properties t1, t5, t72, and t512 that check the hash and hashBytes functions against the given known-answer test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_224 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224 as SHA3_224\n\nproperty t1 = SHA3_224::hash [] ==\n    0x6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7\n\nproperty t5 = SHA3_224::hash (KBO::truncate`{5} 0x1f) ==\n    0x65ad282dcf9642a2facc1e7545c58f3b17523e795fee58e4d21b10bf\n\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_224::hash input == output\n    hashBytesWorks = SHA3_224::hashBytes (split input) == split output\n    input = 0xb29373f6f8839bd498\n    output = 0xe02a13fa4770f824bcd69799284878f19bfdc833ac6d865f28b757d0\n\nproperty t512 = SHA3_224::hash input == output where\n    input = join [\n        0xfc286db63e69d24c6962bb515cc32c86,\n        0x67ed0c08ba9f331d1dd2c42de2e1bd0f,\n        0x18edcc870280650cc87011ce6b0709f7,\n        0xfe60033114144c69751717d315dc152f\n    ]\n    output = 0x157fd9f423a498868e233d9d64631f61aa5e8fbc23df413f7826c962\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/WOTS\/Specification.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the WOTS+ one-time signature scheme from RFC-8391, including types for keys, addresses, and signatures, functions genPK, sign, pkFromSig, and a property WOTSisCorrect stating that verification reconstructs the original public key."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::WOTS::Specification where\n\nparameter\n\n    type n' : #\n    type constraint (fin n')\n\n    type w' : #\n    type constraint (fin w', w' % 4 == 0, w' % 3 == 1, w' <= 16)\n\n    \/**\n     * A keyed cryptographic hash function that takes a key and a message.\n     * [RFC-8391] Section 3.1.1.1.\n     *\/\n    F' : [n'][8] -> [n'][8] -> [n'][8]\n\n    \/**\n     * A pseudorandom function that takes a key and an index.\n     * [RFC-8391] Section 3.1.1.1.\n     *\/\n    PRF' : [n'][8] -> [32][8] -> [n'][8]\n\n    type len_1 = (8 * n') \/^ (lg2 w')\n    type constraint (width (len_1 * (w' - 1) * 2^^8) <= 32)\n\n    \/**\n     * A length value (fixed with respect to `n` and `w`).\n     * [RFC-8391] Section 3.1.1.\n     *\/\n\n    type len_2 = lg2 (len_1 * (w' - 1)) \/ lg2 w' + 1\n\n    \/**\n     * The number of `n`-byte string elements in a WOTS+ private key, public key,\n     * and signature.\n     * [RFC-8391] Section 3.1.1.\n     *\/\n    type len = len_1 + len_2\n\n    \/**\n     * The `len` parameter fits in 32 bits.\n     *\n     * This implicit fact about our inputs is hard for Cryptol to infer, so we\n     * state it explicitly.\n     *\n     * It is implied by the `genPK` function, which sets the chain address\n     * of an OTS hash address to an iterator that varies from 0 to `len-1`.\n     * The chain address is restricted to one 32-bit word. See [RFC-8391]\n     * Algorithm 4.\n     *\n     * This can also be observed from the computed `len` values from the valid\n     * parameter sets in Section 5.2.\n     *\/\n    type constraint (32 >= width len)\n\ntype n = n'\ntype w = w'\nF = F'\nPRF = PRF'\n\n\/**\n * A byte is a sequence of 8 bits using big-endian representation.\n * [RFC-8391] Section 2.1.\n *\/\ntype Byte = [8]\n\n\/**\n * Convert a non-negative integer to a binary representation in big-endian\n * byte order.\n * [RFC-8391] Section 2.4.\n *\n * Note: the spec is not explicit about what to do when `m < 8y` -- e.g. when\n * converting to `y` bytes means truncating the integer representation,\n * rather than padding it with 0s. We chose this behavior based on the\n * reference implementation that accompanies the spec.\n * @see https:\/\/github.com\/XMSS\/xmss-reference\/blob\/master\/utils.c#L6\n * [RFC-8391] Section 7.\n *\n * Essentially, we pad with zeros if needed (using `zext`), then `drop` any\n * unnecessary padding (and potentially also drop some bits of the original\n * integer).\n *\/\ntoByte : {y, m} (fin y, fin m) => [m] -> [y]Byte\ntoByte x = split (drop (zext`{max m (y * 8)} x))\n\n\/**\n * Ensure that `toByte`{32} 0 == zero`.\n * ```repl\n * :check toByteZeroIsZero`{32}\n * ```\n *\/\ntoByteZeroIsZero : {m} fin m => Bit\ntoByteZeroIsZero = zero == toByte`{32, m} 0\n\n\/**\n * An n-byte value used as the key to a PRF.\n *\n * This type is not formally defined in the spec but is defined here for\n * clarity.\n *\n * [RFC-8391] Section 2.5.\n *\/\ntype Seed = [n]Byte\n\n\/**\n * A word is a 32-bit sequence used to define hash addresses.\n * [RFC-8391] Section 2.5.\n *\/\ntype Word = [32]\n\n\/**\n * Address scheme for randomizing hash function calls in the OTS scheme.\n * [RFC-8391] Section 2.5.\n *\n * The address breaks down 7 components, each 1 word long unless specified.\n * 1. Layer address\n * 2-3. Tree address (2 Words)\n * 4. Type (fixed at 0)\n * 5. OTS address\n * 6. Chain address\n * 7. Hash address\n * 8. keyAndMask\n *\n * Note that this isn't defined in terms of the `Word` type because it's\n * operated on by things that require arrays of bytes.\n *\/\ntype OTSHashAddress = [8 * 4]Byte\n\n\/**\n * A private, or secret, key in WOTS+ is a length `len` array of `n`-byte\n * strings.\n *\n * It represents the start nodes in a set of hash chains.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: A private key MUST be selected randomly from the uniform\n * distribution or selected using a cryptographically secure pseudorandom\n * process! Cryptol cannot verify that a `PrivateKey` was chosen suitably!\n * Implementors must independently audit private key generation!\n *\n * [RFC-8391] Section 3.1.3.\n *\n * An implementation may also use a cryptographically secure pseudorandom\n * method to generate the private key from a single `n`-byte value. See\n * [RFC-8391] Section 3.1.7 for a sample method.\n *\/\ntype PrivateKey = [len][n]Byte\n\n\/**\n * A WOTS+ public key is a length `len` array of `n`-byte strings.\n *\n * It represents the end nodes i a set of length-`w` hash chains, where the\n * start nodes are defined in the corresponding `PrivateKey`.\n *\/\ntype PublicKey = [len][n]Byte\n\n\/**\n * Generate a WOTS+ public key from a private key.\n * [RFC-8391] Section 3.1.4, Algorithm 4 (called `WOTS_genPK` in the spec).\n * [Errata-8382] @see https:\/\/www.rfc-editor.org\/errata\/eid8382\n *\/\ngenPK : PrivateKey -> [n]Byte -> OTSHashAddress -> PublicKey\ngenPK sk SEED ADRS = pk where\n    pk = [ pki where\n            ADRSi = setChainAddress ADRS i\n            pki = chain ski 0 (`w - 1) SEED ADRSi\n        | i <- [0..len-1]\n        | ski <- sk]\n\nprivate\n    \/**\n     * Set the chain address word (in the 6th position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setChainAddress : OTSHashAddress -> Word -> OTSHashAddress\n    setChainAddress address value =\n        take`{5 * 4} address # (split value) # drop`{6 * 4} address\n\n    \/**\n     * Set the hash address word (in the 7th position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setHashAddress : OTSHashAddress -> Word -> OTSHashAddress\n    setHashAddress address value =\n        take`{6 * 4} address # (split value) # drop`{7 * 4} address\n\n    \/**\n     * Set the `keyAndMask` word (the last position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setKeyAndMask : OTSHashAddress -> Word -> OTSHashAddress\n    setKeyAndMask address value = take`{7 * 4} address # split value\n\n    \/**\n     * Chaining function that iterates `F` on the input `X`, `s` times.\n     * [RFC-8391] Section 3.1.2, Algorithm 2.\n     *\/\n    chain : [n]Byte -> Word -> Word -> [n]Byte -> OTSHashAddress -> [n]Byte\n    chain X i s SEED ADRS = return where\n        return = if s == 0 then\n                X\n            else if i + s > `w - 1 then\n                error \"Invalid `s` and `i` parameters passed to `chain`\"\n            else\n                tmp'\n        tmp = chain X i (s - 1) SEED ADRS\n\n        ADRS' = setHashAddress ADRS (i + s - 1)\n        ADRS'' = setKeyAndMask ADRS' 0\n        KEY = PRF SEED ADRS''\n        ADRS''' = setKeyAndMask ADRS'' 1\n        BM = PRF SEED ADRS'''\n\n        tmp' = F KEY (tmp ^ BM)\n\n    \/**\n     * Convert a byte string into a set of base-`w` numbers.\n     *\n     * This uses the manual bit-shifting algorithm described in the spec. The\n     * spec is not very particular about bit widths of the helper variables or\n     * the output; we made the following choices:\n     * - `total`: holds each byte of the input, so `[8]`\n     * - `in`: holds the index showing where we are in the input. We use an\n     *   `Integer`, although this could also be `[width len_X]`.\n     * - `bits`: holds the number of bits processed in the current byte. This is\n     *   never larger than 8, but due to the way we've defined the type\n     *   constraint on `w`, it's easier to leave some extra space, so `[8]`.\n     * - `basew`: The output of this function is eventually used as a parameter\n     *   to `chain`, so we pad each base-`w` number to be a `Word` (`[32]`).\n     *\n     * [RFC-8391] Section 2.6, Algorithm 1.\n     *\/\n    base_w_spec : {out_len, len_X} (\n            fin len_X,\n            out_len <= 8 * len_X \/ lg2 w)\n        => [len_X]Byte -> [out_len]Word\n    base_w_spec X = basew where\n        \/\/ Steps 8 - 13. Define how the helper variables (`total`, `in`, `bits`)\n        \/\/ are updated in each round.\n        update_helpers : ([8], Integer, [8]) -> ([8], Integer, [8])\n        update_helpers (total, in, bits) =\n            if bits == 0 then (\n                X@in,\n                in + 1,\n                8 - lg2 `w )\n            else (total, in, bits - lg2 `w)\n\n        \/\/ Step 7. Define the number of iterations we need.\n        type consumed = out_len\n\n        \/\/ Step 14. Compute the set of base-`w` numbers. `zext` converts an\n        \/\/ 8-bit value to a `Word`.\n        basew = take`{consumed} [ zext ((total >> bits) && (`w - 1))\n            \/\/ Steps 1-5. Initialize helper variables (and update them for each\n            \/\/ round). The first element is dropped because the first variable\n            \/\/ update happens before computing any output values.\n            | (total, in, bits) <- drop`{1} (iterate update_helpers (0, 0, 0))]\n\n    \/**\n     * Convert a byte string into a set of base-`w` numbers.\n     *\n     * This uses standard built-in Cryptol functions to achieve the same\n     * functionality as the spec version; rather than manually bit shifting, it\n     * regroups the bits into the desired arrangement. This is about 5x faster\n     * than the spec version.\n     *\n     * Note that this depends on the top-level type constraint restricting `w`\n     * to either 4 or 16. I am not sure the grouping would work as well if we\n     * were working in a base that was not a power of 2.\n     *\/\n    base_w : {out_len, len_X} (\n        fin len_X,\n        out_len <= 8 * len_X \/ lg2 w)\n        => [len_X]Byte -> [out_len]Word\n    base_w X = map zext (groupBy`{lg2 w} (take (join X)))\n\n    \/**\n     * Proof that the Cryptol-ish version of `base_w` matches the spec version.\n     *\n     * Parameter for the following tests are chosen based on the instantiations\n     * that appear in the spec (Algorithms 5 and 6).\n     * ```repl\n     * :prove base_wsMatch`{len_1, n * 8}\n     * type len_2_bytes = len_2 * lg2 w \/^ 8\n     * :prove base_wsMatch`{len_2, len_2_bytes}\n     * ```\n     *\/\n    base_wsMatch : {O, L} (fin L, O <= 8 * L \/ lg2 w) => [L]Byte -> Bit\n    property base_wsMatch X = base_w_spec`{O, L} X == base_w X\n\n    \/**\n     * The spec provides several examples when `w = 16`.\n     * [RFC-8391] Section 2.6.\n     * ```repl\n     * :prove base_wExamplesWork`{}\n     * ```\n     *\/\n    base_wExamplesWork : (w == 16) => Bit\n    property base_wExamplesWork = test4 && test3 && test2 where\n        test4 = base_w`{4} [0x12, 0x34] == [1, 2, 3, 4]\n        test3 = base_w`{3} [0x12, 0x34] == [1, 2, 3]\n        test2 = base_w`{2} [0x12, 0x34] == [1, 2]\n\n\/**\n * A WOTS+ signature.\n * [RFC-8391] Section 3.1.5.\n *\/\ntype Signature = [len][n]Byte\n\n\/**\n * Generate a signature from a private key and a message.\n * [RFC-8391] Section 3.1.5, Algorithm 5 (called `WOTS_sign` in the spec).\n *\n * The checksum in the signature algorithm must fit in 32 bits; we enforce this\n * using a constraint in the type signature; it will always be true for the\n * approved parameter sets.\n *\/\nsign : [n]Byte -> PrivateKey -> OTSHashAddress -> [n]Byte -> Signature\nsign M sk ADRS SEED = sig where\n    \/\/ Convert message to base `w`.\n    msg = base_w`{len_1} M\n\n    \/\/ Compute checksum.\n    csum = sum [ `w - 1 - msg_i | msg_i <- msg ]\n\n    \/\/ Convert `csum` to base `w`.\n    csum' = csum << (8 - (`(len_2 * lg2 w) % 8))\n    type len_2_bytes = (len_2 * lg2 w) \/^ 8\n    msg' = msg # base_w`{len_2} (toByte`{len_2_bytes} csum')\n    sig = [sig_i where\n            ADRS_i = setChainAddress ADRS i\n            sig_i = chain sk_i 0 msg_i SEED ADRS_i\n        | i <- [0..len-1]\n        | sk_i <- sk\n        | msg_i <- msg' ]\n\n\/**\n * Compute a WOTS+ public key from a message and its signature.\n * [RFC-8391] Section 3.1.6, Algorithm 6 (called `WOTS_pkFromSig` in the spec).\n *\n * The result of this function must be compared to the given public key. If\n * the values are not equal, the signature MUST be rejected. This algorithm\n * does not actually reject any signatures!!\n *\/\npkFromSig : [n]Byte -> Signature -> OTSHashAddress -> [n]Byte -> PublicKey\npkFromSig M sig ADRS SEED = tmp_pk where\n    \/\/ Convert message to base `w`.\n    msg = base_w`{len_1} M\n\n    \/\/ Compute checksum.\n    csum = sum [ `w - 1 - msg_i | msg_i <- msg ]\n\n    \/\/ Convert `csum` to base `w`.\n    csum' = csum << (8 - (`(len_2 * lg2 w) % 8))\n    type len_2_bytes = (len_2 * lg2 w) \/^ 8\n    msg' = msg # base_w`{len_2} (toByte`{len_2_bytes} csum')\n    tmp_pk = [tmp_pk_i where\n            ADRS_i = setChainAddress ADRS i\n            tmp_pk_i = chain sig_i msg_i (`w - 1 - msg_i) SEED ADRS_i\n        | i <- [0..len-1]\n        | sig_i <- sig\n        | msg_i <- msg' ]\n\n\/**\n * A single execution of this property takes ~2 minutes.\n * ```repl\n * :set tests = 1\n * :check WOTSisCorrect\n * ```\n *\/\nproperty WOTSisCorrect M sk ADRS SEED = tmp_pk == pk where\n    pk = genPK sk SEED ADRS\n    sig = sign M sk ADRS SEED\n    tmp_pk = pkFromSig M sig ADRS SEED\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P521_SHA3_512.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512` that instantiates the generic ECDSA specification using the NIST P-521 elliptic curve and the SHA3-512 hash function."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512 =\n    Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec {\n        EC = Common::EC::PrimeField::Instantiations::P521,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512\n    }\n```"}]}
{"filename":"SAW-course\/src\/intr\/kalotan.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models the Kalotan logic puzzle with parents and child as Bits, defines the given constraints (heterosexual parents, kid lying, parents\u2019 statements), and includes properties equivalent to people_types, checkit1, and checkit2 capturing the valid\/invalid configurations."},{"role":"assistant","content":"```cryptol\nxor : Bit -> Bit -> Bit\nxor a b = a ^ b\n\nheterosexual_parents : Bit -> Bit -> Bit\nheterosexual_parents parent1 parent2 = ~(parent1 == parent2)\n\nmeaning_of_kid_lied : Bit -> Bit -> Bit -> Bit\nmeaning_of_kid_lied kid_said kid kid_lied = xor (kid_said == kid) kid_lied\n\nparents_said : Bit -> Bit -> Bit -> Bit -> Bit\nparents_said parent1 kid_said kid kid_lied =\n  if ~parent1 then (~kid_said \/\\ (xor kid kid_lied)) else (kid \/\\ kid_lied)\n\npeople_types : Bit -> Bit -> Bit -> Bit -> Bit -> Bit\nproperty people_types parent1 parent2 kid_said kid kid_lied =\n (heterosexual_parents parent1 parent2 \/\\\n  meaning_of_kid_lied kid_said kid kid_lied \/\\\n  parents_said parent1 kid_said kid kid_lied)\n\nproperty checkit1 parent1 parent2 kid kid_said kid_lied =\n  ~(parent1 \/\\ ~parent2 \/\\ ~kid_said \/\\ kid \/\\ kid_lied) \/\\\n  (people_types parent1 parent2 kid_said kid kid_lied)\n\nproperty checkit2 parent1 parent2 kid kid_said kid_lied =\n  ~(people_types parent1 parent2 kid_said kid kid_lied) \\\/\n  (parent1 \/\\ ~parent2 \/\\ ~kid_said \/\\ kid \/\\ kid_lied)\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Primitive\/Keyless\/Hash\/SHA.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for a parameterized SHA-2 style hash function over word size w, defining sha : {L} (2 * w >= width L) => [L] -> [digest_size] and all supporting types, constants (H0, K), and functions (padding, parsing, message schedule, compression, and block processing)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA where\n\nsha : {L} (2 * w >= width L) => [L] -> [digest_size]\nsha M = take (join (SHA_2_Common' [ split x | x <- parse`{num_blocks L} (pad`{L} M) ]))\n\nparameter\n\n  \/** Word size\n    Specifications are based on word size w, rather than digest size (8 * w)\n    or block size (m == 16 * w), in order to avoid confusing Cryptol's type\n    constraint verifier with integer division.\n  *\/\n\n  type w : #\n  type constraint (fin w, w >= 1)\n\n  type digest_size : #\n  type constraint (fin digest_size, 8*w >= digest_size)\n\n  type j : #\n  type constraint (fin j, j >= 17)\n\n  H0 : [8][w]\n  K  : [j][w]\n\n  SIGMA_0 : [w] -> [w]\n  SIGMA_1 : [w] -> [w]\n  sigma_0 : [w] -> [w]\n  sigma_1 : [w] -> [w]\n\nprivate\n\n  type block_size = 16 * w\n\n  type num_blocks L     = (L+1+2*w) \/^ block_size\n  type padded_size L    = num_blocks L * block_size\n\n  Ch : [w] -> [w] -> [w] -> [w]\n  Ch x y z = (x && y) ^ (~x && z)\n\n  Maj : [w] -> [w] -> [w] -> [w]\n  Maj x y z = (x && y) ^ (x && z) ^ (y && z)\n\n  pad : {L} (2 * w >= width L) => [L] -> [padded_size L]\n  pad M = M # 0b1 # zero # (`L : [2*w])\n\n  parse : {m} [m * block_size] -> [m][block_size]\n  parse = split\n\n  messageSchedule_Common : [16][w] -> [j][w]\n  messageSchedule_Common Mi = take W\n    where\n    W : [inf][_]\n    W = Mi # [ w1 + sigma_0 w2 + w3 + sigma_1 w4\n             | w1 <- W\n             | w2 <- drop`{1} W\n             | w3 <- drop`{9} W\n             | w4 <- drop`{14} W\n             ]\n\n  compress_Common : [8][w] -> [j][w] -> [8][w]\n  compress_Common H W =\n        [ (as ! 0) + (H @ 0),\n      (bs ! 0) + (H @ 1),\n      (cs ! 0) + (H @ 2),\n      (ds ! 0) + (H @ 3),\n      (es ! 0) + (H @ 4),\n      (fs ! 0) + (H @ 5),\n      (gs ! 0) + (H @ 6),\n      (hs ! 0) + (H @ 7)\n    ]\n    where\n      T1 = [h + SIGMA_1 e + Ch e f g + k_t + w_t\n                | h <- hs | e <- es | f <- fs | g <- gs | k_t <- K | w_t <- W]\n      T2 = [ SIGMA_0 a + Maj a b c | a <- as | b <- bs | c <- cs]\n      hs = take`{j + 1}([H @ 7] # gs)\n      gs = take`{j + 1}([H @ 6] # fs)\n      fs = take`{j + 1}([H @ 5] # es)\n      es = take`{j + 1}([H @ 4] # [d + t1 | d <- ds | t1 <- T1])\n      ds = take`{j + 1}([H @ 3] # cs)\n      cs = take`{j + 1}([H @ 2] # bs)\n      bs = take`{j + 1}([H @ 1] # as)\n      as = take`{j + 1}([H @ 0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\n  processBlock_Common : [8][w] -> [16][w] -> [8][w]\n  processBlock_Common H Mi = compress_Common H (messageSchedule_Common Mi)\n\n  SHA_2_Common' : {L} (fin L) => [L][16][w] -> [8][w]\n  SHA_2_Common' blocks = hash ! 0\n    where\n    hash = [H0] # [ processBlock_Common h b | h <- hash | b <- blocks]\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/DilithiumR2BV.cry","filetype":"cryptol","set":"holdout","variant":"without_comments","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification module for the Dilithium round-2 lattice-based signature scheme, including key generation Gen, signing Sign, verification Verify, serialization\/deserialization for keys and signatures, and a property test_key_gen that checks the known-answer test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::DilithiumR2BV where\n\nimport Primitive::Keyless::Hash::keccak as SHA3\nimport Common::utils\nimport Common::mod_arith\nimport Primitive::Asymmetric::Cipher::RSA\nimport Primitive::Asymmetric::Signature::testDilithium\nimport Primitive::Asymmetric::Signature::test_latest\n\ntype qbits = 23\ntype uint32_t = 32\ntype q = 0x7fe001 type n = 0x100 type d = 0xe\nwc= 0x3c gamma1 = ((`q) - 1) \/ 16:[_]\ngamma2 = ( gamma1 \/ 2 ):[_]\nalpha = (2*gamma2):[_]\nqinv  = 0x00000000fc7fdfff\ntype POLT1_SIZE_PACKED = 288\n\nrootOfUnity    = 1753 : [qbits]\nrootOfUnityInv = 731434 : [qbits]\nninv           = 8347681 : [qbits]\n\ntype k = 4\ntype l = 3\n\neta = 6\nbeta = 325\ntype omega = 80\n\ntype intPoly        = [n][qbits]\ntype intPolyVec dim = [dim]intPoly\n\ntype poly        = [n][qbits] type polyVec dim = [dim]poly\n\ntype nttPoly          = [n][qbits]\ntype nttVec dim       = [dim]nttPoly\ntype nttMat dim1 dim2 = [dim1](nttVec dim2)\n\ntype PublicKey = {rho : [256], t1 : intPolyVec k}\ntype SecretKey = {rho : [256]\n                    , K  : [256]\n                    , tr : [384]\n                    , s1 : polyVec l\n                    , s2 : polyVec k\n                    , t0 : intPolyVec k}\ntype SEEDBYTES = 32\ntype CRYPTO_PUBLICKEYBYTES = SEEDBYTES + (POLT1_SIZE_PACKED * k)\n\nGen : [3*SEEDBYTES*8] -> (PublicKey,SecretKey)\nGen s = (pk, sk)\n    where\n      [rho, rho', K] = split`{3} s \/\/rho <- {0, 1}^256, K <- {0,1}^256\n      A       = ExpandA (split rho) \/\/A \u2208 R^(k\u00d7l)_q := ExpandA(rho)\n      s1      = PolyUniformEtaV`{dim=l} rho' zero       s2      = PolyUniformEtaV`{dim=k} rho' `l \/\/ s2<-s^k_\u03b7\n      s1ntt   = map ntt s1\n      As1     = map nttinv (nttMatMul A s1ntt)\n      t       = paddV As1 s2     \/\/t:= As1 + s2\n      (t1,t0) = Power2RoundV t  \/\/(t1, t0):= Power2Round_q(t, d=4)\n      tr      = CRH (rho#(pack_t1 t1)) \/\/tr \u2208 {0,1}^384 := CRH(rho||t1)\n      pk      = { rho = rho, t1 = t1}\n      sk      = { rho = rho, K = K, tr = tr, s1 = s1, s2 = s2, t0 = t0}\n\n\/\/ Known Answer Test\n\/\/ To check this property, it is necessary to import testDilithium\n\ntest_key_gen = (pk.rho#(pack_t1 pk.t1) == testCase1.pk) \/\\\n    ((sk.rho#sk.K#sk.tr#(pack_polyeta sk.s1)#(pack_polyeta sk.s2)#(pack_t0 sk.t0)) == testCase1.sk)\n    where\n    (pk, sk) = Gen (join testCase1.seed)\n\n\/* Generate signature for message M *\/\nSign : {mbytes} (fin mbytes, mbytes>=1) => SecretKey -> [mbytes*8] -> (polyVec l, polyVec k, poly)\nSign sk M = (final_state.z, h, nttinv final_state.c')\n     where\n      A     = ExpandA (split sk.rho)       mu    = CRH`{b=48+mbytes} (sk.tr#M)       kappa = zero       s1'   = map ntt sk.s1\n      s2'   = map ntt sk.s2\n      t0'   = map ntt (sk.t0)\n      \/\/TODO: check t0' back later\n\n      init : sign_var_types\n      init = {z=zero,r0=zero,r1=zero,t0'=t0',c'=zero,w=zero,w1=zero\n             ,s1'=s1',s2'=s2',cs2=zero,K=sk.K,mu=mu,A=A,kappa=kappa}\n\n      final_state = dowhile sign_condition sign_body init\n      ct0         = map nttinv (nttVecConstMul final_state.c' final_state.t0')\n      h           = MakeHintV (psubV zero ct0\n                              ,paddV (psubV final_state.w final_state.cs2) (ct0))\n\ntype sign_var_types = { z : polyVec l\n                          , r0  : intPolyVec k\n                          , r1  : intPolyVec k\n                          , t0' : nttVec k\n                          , c'  : nttPoly\n                          , w   : polyVec k\n                          , w1  : intPolyVec k\n                          , s1' : nttVec l\n                          , s2' : nttVec k\n                          , cs2 : polyVec k\n                          , K   : [256]\n                          , mu  : [384]\n                          , A   : nttMat k l\n                          , kappa: [16]}\n\nsign_condition : sign_var_types -> Bit\nsign_condition sv = fail1 \\\/ fail2\n                   where\n                    fail1 = ((infNormPolyVec (sv.z)) >= (gamma1-beta)) \/\/ ||z||_\u221e \u2265 \u03b31 - \u03b2\n                            \\\/ ((infNormPolyVec sv.r0) >= (gamma2-beta)) \/\/ ||r0||_\u221e \u2265 \u03b32 - \u03b2\n                            \\\/ (sv.r1 != sv.w1) \/\/ r1 \u2242\u0338 w1\n                    fail2 = ((infNormPolyVec (ct0)) >= gamma2) \/\/ ||ct0||_\u221e \u2265 \u03b32\n                            \\\/ ( (foldl (+) 0 cones) > `omega ) \/\/ number of ones in h > \u03c9\n                    cones = sum (map (\\x -> (map onesBV x)) h)\n                    ct0   = map nttinv (nttVecConstMul sv.c' sv.t0')\n                    h     = MakeHintV (psubV zero ct0\n                                      ,paddV (psubV sv.w sv.cs2) (ct0))\n                                      \/\/ h := MakeHintV(-ct0, w-cs2+ct0, 2\u03b32)\n\nsign_body : sign_var_types -> sign_var_types\nsign_body sv = {z=z,r0=r0,r1=r1,t0'=sv.t0',c'=c',w=w,w1=w1,s1'=sv.s1',s2'=sv.s2',\n                   cs2=cs2,K=sv.K,mu=sv.mu,A=sv.A,kappa=(sv.kappa+1)}\n              where\n                \u03c1'  = CRH`{b=48+32} (sv.K#sv.mu)                 y   = ExpandMask((split \u03c1'), sv.kappa)\/\/ y \u2208 S^l_(\u03b31-1) := ExpandMask(\u03c1',\u03ba)\n                y'  = map ntt y \/\/ checked\n                w   = map nttinv (nttMatMul sv.A y')                 w1  = HighBitsV w                 c'  = ntt ( H (sv.mu,w1) ) \/\/ c \u2208 B_(60) := H(\u03bc||w1)\n                cs1 = map nttinv (nttVecConstMul c' sv.s1') \/\/ cs1 := c'.s1'\n                cs2 = map nttinv (nttVecConstMul c' sv.s2') \/\/ cs2 := c'.s2'\n                z   = paddV y cs1 \/\/ z:= y+cs1\n                (r1, r0) = DecomposeV (psubV w cs2) \/\/ Decompose_q(w-cs2, 2\u03b32)\n\nVerify : {mbytes} (fin mbytes, mbytes>=1) => PublicKey -> [mbytes*8] -> (polyVec l, polyVec k, poly) -> Bit\nVerify pk M (z, h, c) = crit1 && crit2 && crit3\n       where\n        A        = ExpandA (split pk.rho) \/\/ A \u2208 R^(k\u00d7l)_q := ExpandA(\u03c1)\n        mu       = CRH`{b=48+mbytes} ((CRH (pk.rho#(pack_t1 pk.t1)))#M) \/\/ \u03bc \u2208{0,1}^384 := CRH(CRH(\u03c1||t1)||M)\n        zntt     = map ntt z \/\/ NTT(z)\n        t1dot2d  = map ntt (map (\\p -> map (\\x ->  mod_mul(`q, x, (2^^14))) p) pk.t1) \/\/ t1.2^^d where d=14\n        nttt1dot2d = map ntt t1dot2d\n        ct1ntt   = nttVecConstMul (psub zero c) nttt1dot2d   \/\/ -ct1\n        Az       = nttMatMul A zntt\n        w1'      = UseHintV (h, paddV Az ct1ntt)\n        zint     = z\n        zinf     = infNormPolyVec zint         crit1    = zinf < gamma1 - beta\n        crit2    = c == H(mu,w1')\n        cones    = sum (map (\\x -> (map onesBV x)) h)\n        crit3    = ( (foldl (+) 0 cones) > `omega ) \/\/ number of 1's in h \u2264 \u03c9 \n\nonesBV : {n} (fin n, n>=1)=> [n] -> [n]\nonesBV xs =  l!0\n    where l = [0]#[ (if (xs@i) then j+1 else j):[n] | i <- [0..n-1] | j<- l]\n\npack_w : intPolyVec k -> [4*n*k]\npack_w w = join [pack_poly p | p <- wBV ]\n    where\n    wBV = map (\\p -> map (\\x -> drop`{15} x:[8]) p) w\n    pack2 : [2][8] -> [8]\n    pack2 xs = xs@0 || (xs@1 << 4)\n    pack_poly p = join [ pack2 xs | xs <- split p : [128][2][_] ]\n\npack_polyeta : {m} (fin m, m >= 1) =>  polyVec m -> [4*n*m]\npack_polyeta s = join [ join [elt p i | i <- [0..(n\/2)-1]:[_][8] ] | p <- s ]\n    where\n    elt : poly -> [8] -> [8]\n    elt p i = (c (((p@(2*i+0))) % `q)) || ((c (((p@(2*i+1))) % `q)) << 4)\n    c : [qbits] -> [8]\n    c num = drop (if num > eta then `q + eta - num else eta - num)\n\ntype POLETA_SIZE_PACKED = 128\nunpack_polyeta :  {m} (fin m, m>=1) => [POLETA_SIZE_PACKED*m][8] -> polyVec m\nunpack_polyeta t = [ elt a | a <- (split t):[m][128][8]]\n      where\n      elt : [128][8] -> poly\n      elt a = (join coeffs)\n            where coeffs = [ [ (`q+eta)- (zext (a@i&&0x0F)), (`q+eta)- (zext (a@(i+1)>>4))] |i <- [0..(n\/2)-1]:[_][8] ]\n\npack_t0 : intPolyVec k -> [k*3584]\npack_t0 t0 = join [ polyt0_pack p | p <- t0 ]\n\npolyt0_pack : intPoly -> [3584]\npolyt0_pack p = join [ join [drop`{15} (tmp p i 0),\n                       drop`{15} (((tmp p i 0) >> 8) || ((tmp p i 1) << 6)),\n                       drop`{15} ((tmp p i 1) >> 2),\n                       drop`{15} (((tmp p i 1) >> 10) || ((tmp p i 2) << 4)),\n                       drop`{15} ((tmp p i 2) >> 4),\n                       drop`{15} (((tmp p i 2) >> 12) || ((tmp p i 3) << 2)),\n                       drop`{15} ((tmp p i 3) >> 6)\n                     ] | i <- [0..(n\/4-1)] ]\n        where\n          tmp : intPoly -> [8] -> [8] -> [23]\n          tmp p i j =  (2^^13 - p@(4*i+j))\ntype POLT0_SIZE_PACKED = 448\npolyt0_unpack : [POLT0_SIZE_PACKED][8] -> intPoly\npolyt0_unpack p = join[ [ (tmp p i 0) || (zext ((tmp p i 1) && zext 0x3F)) << 8,\n                          (zext ((tmp p i 1) >> 6)) || (zext (tmp p i 2)) << 2 || (zext ((tmp p i 3) && zext 0x0F)) << 10,\n                          (zext ((tmp p i 3) >> 4)) || (zext (tmp p i 4)) << 4 || (zext ((tmp p i 5) && zext 0x03)) << 12,\n                          (zext ((tmp p i 5) >> 2)) || (zext (tmp p i 6)) << 6\n                        ] | i <- [0..(n\/4-1)]\n                      ]\n          where\n            tmp :[POLT0_SIZE_PACKED][8] -> [8] -> [8] -> [23]\n            tmp p i j =  zext (2^^13 - p@(7*i+j))\n\nunpack_t0 : [k][POLT0_SIZE_PACKED][8] -> intPolyVec k\nunpack_t0 pv = [ (polyt0_unpack pv') | pv' <- pv]\n\npoly_pack : poly -> [POLT1_SIZE_PACKED*8]\npoly_pack p = join [ join (pack8 xs) | xs <- split (map (drop`{14}) p) : [32][8][_]]\n\npack8 : [8][9] -> [9][8]\npack8 xs = map drop`{1} [ xs@0\n                        , xs@0 >> 8 || xs@1 << 1\n                        , xs@1 >> 7 || xs@2 << 2\n                        , xs@2 >> 6 || xs@3 << 3\n                        , xs@3 >> 5 || xs@4 << 4\n                        , xs@4 >> 4 || xs@5 << 5\n                        , xs@5 >> 3 || xs@6 << 6\n                        , xs@6 >> 2 || xs@7 << 7\n                        , xs@7 >> 1\n                        ]\n\npack_t1 : polyVec k -> [k*POLT1_SIZE_PACKED*8]\npack_t1 pvk = (join [ poly_pack p | p <- pvk])\n\npolyt1_unpack : [POLT1_SIZE_PACKED][8] -> poly\npolyt1_unpack p = map (\\x -> zero#x) (join [unpack8 xs | xs <- (split p): [32][9][_] ])\n    where unpack8: [9][8] -> [8][12]\n          unpack8 xs = [ zero#xs@0 || ((zero#xs@1 << 8) && 0x1FF)\n                        , zero#xs@1 >> 1 || ((zero#xs@2 << 7) && 0x1FF)\n                        , zero#xs@2 >> 2 || ((zero#xs@3 << 6) && 0x1FF)\n                        , zero#xs@3 >> 3 || ((zero#xs@4 << 5) && 0x1FF)\n                        , zero#xs@4 >> 4 || ((zero#xs@5 << 4) && 0x1FF)\n                        , zero#xs@5 >> 5 || ((zero#xs@6 << 3) && 0x1FF)\n                        , zero#xs@6 >> 6 || ((zero#xs@7 << 2) && 0x1FF)\n                        , zero#xs@7 >> 7 || ((zero#xs@8 << 1) && 0x1FF)\n                        ]\n\nunpack_t1 : [k][POLT1_SIZE_PACKED][8] -> polyVec k\nunpack_t1  pv = [ (polyt1_unpack p) |  p <- pv]\n\npack_pk :  [32][8] -> polyVec k -> [CRYPTO_PUBLICKEYBYTES*8]\npack_pk rho t1 = (join rho) # (pack_t1 t1)\n\nunpack_pk : [CRYPTO_PUBLICKEYBYTES][8] -> ([SEEDBYTES][8], polyVec k)\nunpack_pk pk = (take`{32} pk, [polyt1_unpack p | p <- (split (drop`{32} pk):[k][288][_])])\n\ntype CRHBYTES = 48\ntype CRYPTO_SECRETKEYBYTES = 2800\n\npack_sk : [SEEDBYTES][8] -> [SEEDBYTES][8] -> [CRHBYTES][8] -> polyVec l -> polyVec k -> polyVec k -> [CRYPTO_SECRETKEYBYTES*8]\npack_sk rho key tr s1 s2 t0 = (join rho) # (join key) # (join tr)# (pack_polyeta s1)#(pack_polyeta s2) # (pack_t0 t0)\n\nunpack_sk : [CRYPTO_SECRETKEYBYTES][8] -> ([SEEDBYTES][8], [SEEDBYTES][8], [CRHBYTES][8], polyVec l, polyVec k, intPolyVec k)\nunpack_sk sk = (rho, key, tr, s1, s2, t0)\n        where rho = (take`{32} sk)\n              key = (take`{32}(drop`{32} sk))\n              tr = (take`{48}(drop`{32} sk))\n              s1 = unpack_polyeta`{m=l} (take`{128*l}(drop`{48} sk))\n              s2 = unpack_polyeta`{m=k} (take`{128*k}(drop`{48+(128*l)} sk))\n              t0 = unpack_t0 (split (drop`{48+(128*l)+(128*k)+64} sk):[k][POLT0_SIZE_PACKED][8])\n\ntype POLZ_SIZE_PACKED = 640\n\npolyz_pack : poly -> [POLZ_SIZE_PACKED][8]\npolyz_pack p =  join [ (tmp p i) | i<- [0..(n\/2)-1]]\n      where tmp: poly -> [8] -> [5][8]\n            tmp p i  = [r0, r1, r2, r3, r4]\n              where\n                    t x = gamma1-1-p@(2*i+x)\n                    t0 = (t 0) + ((zext (t 0))>>31) && `q\n                    t1 = (t 1) + ((zext (t 1))>>31) && `q\n                    r0 = drop t0\n                    r1 = drop (t0>>8)\n                    r2 = drop (t0>>16) || drop (t1 << 4)\n                    r3 = drop (t1 >> 4)\n                    r4 = drop (t1 >> 12)\n\npolyz_unpack : [POLZ_SIZE_PACKED][8] -> poly\npolyz_unpack pp =  (join [ (tmp pp i) | i<-[0..(n\/2)-1]])\n    where tmp : [POLZ_SIZE_PACKED][8] -> [8]-> [2][23]\n          tmp pp i = [rcoeff0, rcoeff1]\n                where\n                  coeff0 = (zero#pp@(5*i+0):[32]) || (((zero#pp@(5*i+1)):[32]) << 8) || (zero#(((zero#pp@(5*i+2)):[8]) && 0x0F):[32]) << 16\n                  coeff1 = ((zero#(pp@(5*i+2) >> 4)):[32]) || ((zero#pp@(5*i+3):[32]) << 4) || ((zero#pp@(5*i+4):[32]) << 12)\n                  rcoeff0 = drop`{9}((gamma1 - 1 - coeff0) + ((zext coeff0:[32]) >> 31) && `q):[23]\n                  rcoeff1 = drop`{9}((gamma1 - 1 - coeff1) + ((zext coeff1:[32]) >> 31) && `q):[23]\n\ntype SIG_SIZE_PACKED = l*POLZ_SIZE_PACKED+omega+k+n\/8+8\n\nencodec : poly -> [(n\/8+8)*8]\nencodec p = (join [ [ p@(8*i+j)!=0 | j <- [0..7] ] | i<- [0..(n\/8)-1]])# (join sigSigns)\n      where\n        signs =[0]# [(if (join qm1coeffsIndcs)@i then s||m else s) | s <- signs | m<- masks| i<-[0..255]]\n        masks = [1]# [(if (join nzcoeffsIndcs)@i then (m << 1) else m) | m<-masks | i<-[0..255] ]\n        nzcoeffsIndcs =  [ [ p@(8*i+j)!=0 | j <- [0..7] ] | i<- [0..(n\/8)-1]]\n        qm1coeffsIndcs = [ [ p@(8*i+j)==(`q-1) | j <- [0..7] ] | i<- [0..(n\/8)-1]]\n        sig = zero:[n\/8+8][8]\n        sigSigns = [ (signs!0) >>(8*i) | i<-[0..7]]:[8][8]\n\npack_sig : (polyVec l, polyVec k, poly) -> [SIG_SIZE_PACKED*8]\npack_sig (z, h, c) = s0#s1#s2\n        where s0 = join [join (polyz_pack z') | z' <- z ]\n              s2 = encodec c\n              s1 = encodeh h\n                where\n                encodeh : polyVec k -> [(omega+k)*8]\n                encodeh h = join omegaUpdates\n                  where nzcoeffsIndcs = [ [ (p@j)!=0 | j<-[0..255]]| p<- h]\n                        cones = sum (map onesBV nzcoeffsIndcs)\n                        sig = zero:[84][8]\n                        kUpdates0=[sig]#[(if (nzcoeffsIndcs@0)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates0]\n                        kUpdates1=[kUpdates0!0]#[(if (nzcoeffsIndcs@1)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates1]\n                        kUpdates2=[kUpdates1!0]#[(if (nzcoeffsIndcs@2)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates2]\n                        kUpdates3=[kUpdates2!0]#[(if (nzcoeffsIndcs@3)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates3]\n                        omegaUpdates = (updates (kUpdates3!0) [`omega+0, `omega+1, `omega+2, `omega+3] [0, 1, 2, 3])\n\ndecodec : [(n\/8+8)][8] -> poly\ndecodec xs = coeffs'!0\n  where coeffs = zero:poly\n        signs = [0]#[ ((sext s) || ((sext (xs@(`n\/8+i))):[64]) << (8*i)) | i<-[0..7] | s<-signs] :[9][64]\n        signs' = [signs!0]#[ (if ((((xs@i) >> j) && 0x01) == 1) then (s >> 1) else s) | j<- [0..255] | s <- signs' | i<- [0..3]]\n        coeffs' = [coeffs]#[(if ((((xs@i) >> j) && 0x01)==1) then (update coeff (8*i+j) (1^(-((drop s)&&1))&&(1^(`q-1)))) else coeff) | i<- [0..7] | j<- [0..255] | s <- signs' | coeff <-coeffs' ]\n\ndecodeh: [(omega+k)][8] -> polyVec k\ndecodeh xs = pv       where\n        pv = zero : polyVec k\n        ks = [0]#[xs@(`omega+i) | i<- [0..3]]\n\nunpack_sig : [SIG_SIZE_PACKED][8] -> (polyVec l, polyVec k, poly)\nunpack_sig sig = (z, h, c)\n        where z = [ (polyz_unpack p) | p<- (split (take`{l*POLZ_SIZE_PACKED} sig):[l][_][_])]\n              c = decodec sig''               sig' = take`{84}(drop`{l*POLZ_SIZE_PACKED} sig)\n              sig'' = drop`{84}(drop`{l*POLZ_SIZE_PACKED} sig)\n              h = decodeh sig'\n\nupdateCoeffs :  polyVec n -> [k] -> [8] -> [qbits] -> polyVec n\nupdateCoeffs pv i j a =  upv\n      where  upv = (update pv i up)\n             up = (update p j a)\n             p = pv@i\n\nPolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [16] -> polyVec dim\nPolyUniformEtaV r nonce = [PolyUniformEta (split r) (nonce + j) | j <- [0..(dim-1)]:[dim][16]]\n\ngenS : [8] -> [2][4]\ngenS byte = [t0, t1]\n    where\n    t0 = drop`{4} (byte && 0x0F)\n    t1 = drop`{4} (byte >> 4)\n\nPolyUniformEta : [SEEDBYTES][8] -> [16] -> poly\nPolyUniformEta rho nonce = map (\\x -> if ((toInteger eta) - (toInteger x)) < 0 then (fromInteger  (((toInteger eta) - (toInteger x))+`q):[23]) else (fromInteger ((toInteger eta) - (toInteger x)):[23])) (take`{n} withinEta)\n    where\n        seed = (join rho)#(drop`{8} nonce)# (take`{8} nonce)\n        randoms = ((join (SHA3::toBytes (take`{2*8*168} (SHA3::SHAKE128 (join (SHA3::toBytes seed))))))#zero)\n        withinEta = randomsInRangeDouble genS (2*eta) randoms\n\nH : ([384],intPolyVec k) -> poly\nH (mu,w) = (SampleInBall ss samples)\n  where\n    w_packed = pack_w w\n    randoms  = join (SHA3::toBytes (take`{4352} (SHA3::SHAKE256 (join (SHA3::toBytes (mu#w_packed))))))\n    ss       = take`{60}(reverse (join (reverse (split (take`{64} randoms):[8][8]))))\n\n    extByte : [8] -> [8]\n    extByte x = x\n\n    samples : [60][8]\n    samples = take`{60} (randomsInRanges extByte [196..255] (drop`{64} randoms#zero))\n\nSampleInBall : [60] -> [60][8] -> [256][qbits]\nSampleInBall signs jsamples = ys ! 0\n              where\n              ys = [ zero:[256][qbits]]\n                    # [ if i==j then (if [s]==1 then (update y i (`q-1)) else (update y i 1))                          else (if [s]==1 then (updates y [j,i] [`q-1,y@j]) else (updates y [j,i] [1,y@j]))  | i <- [196..255]\n                                                                  | j <- jsamples\n                                                                  | s <- signs\n                                                                  | y <- ys\n                      ]\n\nExpandMask : ([CRHBYTES][8], [16]) -> polyVec l\nExpandMask  ( \u03c1', kappa) = [samplePoly \u03c1' kappa i `l | i <- [0..(l-1)] ]\n\nsamplePoly : [CRHBYTES][8] -> [16] -> [2] -> [2] -> poly\nsamplePoly \u03c1' kappa i dim = (map (\\x -> mod_sub(`q, mod_sub(`q, gamma1, 1), zero#x)) coeffs)\n    where\n        (upper:[20])      =  drop`{4}(2*gamma1-2):[20]\n        kappaBytes = join (reverse (split ((zext dim)*kappa+(zext i)):[2][8])) \/\/ LEB order\n        s          = join (SHA3::toBytes (take`{5*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes ((join \u03c1')#kappaBytes))))))         (coeffs:[n][20])   = take`{n} (randomsInRangeDouble extractPolyElt upper (s#zero))\n\nextractPolyElt : [40] -> [2][20]\nextractPolyElt bits = [zero#int1, zero#int2]\n                where\n                [b0,b1,b2,b3,b4] = [(zero#b):[20] | b <- split bits : [5][8]]\n                int1 = b2'*2^^16 + b1*2^^8 +  b0\n                int2 = b4*2^^12 + b3*2^^4 +  b2''\n                b2'  = b2 && 15\n                                b2'' = b2\/16\nCRH : {b} (fin b, b>=1) => [b*8] -> [384]\nCRH seed = join (SHA3::toBytes (take`{48*8} (SHA3::SHAKE256 (join (SHA3::toBytes seed)))))\n\nExpandA : [SEEDBYTES][8] -> [k][l]nttPoly\nExpandA rho = [ [ (matrixPoly (join rho) i j) | j <- [0..(l-1)] ] |  i <- [0..(k-1)] ]\n\nmatrixPoly : [SEEDBYTES*8] -> [width k] -> [width l] -> nttPoly\nmatrixPoly rho i j = take`{n} [drop`{1} elt | elt <- randomElts ]\n            where\n            randomElts = randomsInRange extractMatElt ((>=) (`q)) (s#zero)\n            s          = join (SHA3::toBytes (take`{6720} (SHA3::SHAKE128 (join (SHA3::toBytes (rho#b))))))\n                        b          =  drop`{16}(((zero#j:[32]) << 8) + (zero#i:[32]))\n\nextractMatElt : [24] -> [24]\nextractMatElt rands = zero#(2^^16 * b2' + 2^^8 * b1 + b0):[24]\n                where\n                  [b0, b1, b2] = [(zero#b):[23] | b <- split`{3} rands]\n                  b2' = (2^^23-1) && b2 \n\nPower2Round : [qbits] -> ([qbits],[qbits]) -> ([qbits],[qbits])\nPower2Round q (r,d') = ((r'-r0)\/2^^d',r0)\n            where r' = mod_pow (zero#q, r, 1)\n                  r0 = centered_mod r' (2^^d')\n\npolyPower2Round : {m} [m][qbits] -> ([m][qbits], [m][qbits])\npolyPower2Round p = unzip [ Power2Round `q (zero#r, zero#0xe)\n                          | r <- p\n                          ]\n\nPower2RoundV : {dim} (fin dim, dim >= 1) => polyVec dim -> ([dim]intPoly,[dim]intPoly)\nPower2RoundV v = unzip (map polyPower2Round v)\n\nALPHA = 2*gamma2\n\nDecompose : [qbits] -> ([qbits],[qbits])\nDecompose r = if (r' - r0) == (`q - 1) then (0, r0 - 1)\n                    else ((r' - r0) \/ ALPHA, r0)\n          where r' =  mod_pow (`q, r, 1)\n                r0 = centered_mod r' ALPHA\n\nDecomposePoly : {m} [m][qbits] -> ([m][qbits], [m][qbits])\nDecomposePoly p = unzip [Decompose (zero#x) | x <- p]\n\nDecomposeV : {n} (fin n, n>=1) => polyVec n  -> (polyVec n, polyVec n)\nDecomposeV r = unzip [ DecomposePoly p | p <- r ]\n\nHighBits : [qbits] -> [qbits]\nHighBits r = (Decompose r).0\n\nHighBitsV : {n} (fin n, n>=1) => polyVec n  -> polyVec n\nHighBitsV rv = r1\n          where\n            (r1,r0) = DecomposeV rv\n\nLowBits : [qbits] -> [qbits]\nLowBits r = (Decompose r).1\n\nMakeHint : ([qbits],[qbits]) -> [qbits]\nMakeHint (z,r) = zero#[r1 != v1]\n          where r1 = HighBits r\n                v1 = HighBits r+z\nMakeHintP: (poly, poly) -> poly\nMakeHintP (zp, rp) = [MakeHint (z, r) | z <- zp | r <- rp]\n\nMakeHintV : {k} (fin k, k>=1) => (polyVec k, polyVec k) -> polyVec k\nMakeHintV (zv, rv) =  [MakeHintP (zp, rp) | zp <- zv | rp <- rv ]\n\nUseHint : ([qbits],[qbits]) -> [qbits]\nUseHint  (r,h) = (if h==1 then r1' else r1):[23]\n        where\n          m = ((`q - 1) \/ ALPHA)\n          (r1, r0) = Decompose r\n          r1'      = if (r0 > 0) then mod_pow (m, (r1 + 1), 1) else mod_pow (m, (r1 - 1), 1)\nUseHintPoly : poly -> poly -> poly\nUseHintPoly rp hp = [ UseHint (r, h) | r <- rp | h <- hp ]\n\nUseHintV : {k}(fin k, k>=1) => (polyVec k, polyVec k) -> polyVec k\nUseHintV (rv, hv) = [UseHintPoly hpoly rpoly\n                              | hpoly <- hv\n                              | rpoly <- rv\n                              ]\n\nones : {a} (fin a, a >= 1) => [a] -> Integer\nones bv = foldl (+) 0 bva\n      where\n      bva = map toInteger (split bv:[_][1])\n\ncentered_mod : [qbits] -> [qbits] -> [qbits]\ncentered_mod x n = if r > (n\/2) then r - n\n                    else r\n              where r = x % n\n\nrandomsInRange : {a} (fin a) => ([a]-> [a]) -> ([a] -> Bit) -> [inf] -> [inf][a]\nrandomsInRange createElt upperCrit randoms = if (upperCrit elt )\n                                then  [ elt ]#(randomsInRange createElt upperCrit randomTail)\n                                else randomsInRange createElt upperCrit randomTail\n                                where\n                                elt        = createElt (take`{a} randoms)\n                                randomTail = drop`{a} randoms\n\nrandomsInRanges : {a,m} (fin a,fin m, m>=1) => ([a]-> [a]) -> [m][a] -> [inf] -> [inf][a]\nrandomsInRanges createElt uppers randoms =\n                if elt <= head uppers\n                then  [ elt ]#(randomsInRanges createElt uppersRotate randomTail)\n                else randomsInRanges createElt uppers randomTail\n                where\n                  elt          = createElt (take`{a} randoms)\n                  randomTail   = drop`{a} randoms\n                  uppersRotate = uppers <<< 1\n\nrandomsInRangeDouble : {a} (fin a) => ([2*a]-> [2][a]) -> [a] -> [inf] -> [inf][a]\nrandomsInRangeDouble createElt upper randoms =\n                if (elts@0 <= upper) \/\\ (elts@1 <= upper)\n                then  elts#(randomsInRangeDouble createElt upper randomTail)\n                else\n                  if (elts@0 <= upper)\n                  then [ elts@0 ]#(randomsInRangeDouble createElt upper randomTail)\n                  else\n                    if (elts@1 <= upper)\n                    then [ elts@1 ]#(randomsInRangeDouble createElt upper randomTail)\n                    else randomsInRangeDouble createElt upper randomTail\n                where\n                  elts       = createElt (take`{2*a} randoms)\n                  randomTail = drop`{2*a} randoms\n\nmod_sum : {s, m} (fin s, fin m) => ([s], [m][s]) -> [s]\nmod_sum (p, l) = sums!0\n    where\n    sums = [zero]#[mod_add`{s}(p, x, y) | x <- l | y <- sums]\n\nntt : poly -> nttPoly\nntt p = nttp\n    where\n    r k = mod_pow(`q, rootOfUnity, k)\n    exponents = join [ [zext i, (256+(zext i))] | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n    nttp = [(mod_sum (`q, [ (mod_mul(`q, (p@idx), (mod_pow (`q, (r k), i)))) | idx<-[0..(n-1)]:[n][width n] | i<-[0..(n-1)]:[n][23]]))\n           | k <- exponents\n           ]\n\nnttinv : nttPoly -> poly\nnttinv p' = p\n    where\n        pu = reorder p'\n        r' i = mod_pow (`q, rootOfUnityInv, (i*2))\n        p = [ mod_mul(`q, ninv, mod_mul(`q, mod_pow(`q, rootOfUnityInv, i), (mod_sum (`q, [mod_mul(`q, (pu@jdx), (r' ((i*j))))\n            | jdx<-[0..(n-1)]:[n][width n]\n            | j<-[0..(n-1)]:[n][qbits]\n            ]))))\n            | i <- [0..255]:[n][qbits]\n            ]\n\nreorder : nttPoly -> nttPoly\nreorder a = join [ [a1 @ i, a2 @ i] | i <- [0..127]:[_][8] ]\n        where\n          a1 = a @@ [ (i-1)\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n          a2 = reverse (a @@ [ (511 - (zero#i):[9])\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ])\n\nnttMatMul : {dim1,dim2} (fin dim1,fin dim2) => nttMat dim1 dim2 -> nttVec dim2 -> nttVec dim1\nnttMatMul mat vec = [ nttDotProduct v vec | v <- mat ]\n\nnttDotProduct : {dim} (fin dim) => nttVec dim -> nttVec dim -> nttPoly\nnttDotProduct v1 v2 = foldl padd (zero:nttPoly) [ nttPolyMult p1 p2 | p1 <- v1 | p2 <- v2 ]\n\nnttPolyMult : nttPoly -> nttPoly -> nttPoly\nnttPolyMult p1 p2 = [ mod_mul(`q, x, y) | x <- p1 | y <- p2]\n\nnttVecConstMul : {dim} (fin dim) => nttPoly -> nttVec dim -> nttVec dim\nnttVecConstMul c v = map (nttPolyMult c) v\n\npolyVecSum :  {dim} (fin dim) => polyVec dim -> polyVec dim -> polyVec dim\npolyVecSum v1 v2 = map nttinv (paddV v1' v2')\n        where\n        v1' = map ntt v1\n        v2' = map ntt v2\n\npadd : [n][qbits] -> [n][qbits] -> [n][qbits]\npadd p1 p2 = [ mod_add(`q, x, y) | x <- p1 | y <- p2 ]\n\npsub : [n][qbits] -> [n][qbits] -> [n][qbits]\npsub p1 p2 = [ mod_sub(`q, x, y) | x <- p1 | y <- p2 ]\n\npsubV : {dim} (fin dim) => [dim][n][qbits] -> [dim][n][qbits] -> [dim][n][qbits]\npsubV v1 v2 = zipWith psub v1 v2\n\npaddV : {dim} (fin dim) => [dim][n][qbits] -> [dim][n][qbits] -> [dim][n][qbits]\npaddV v1 v2 = zipWith padd v1 v2\n\ninfNorm : [qbits] -> [qbits]\ninfNorm x =  (centered_mod x `q)\n\ninfNormPoly : intPoly -> [qbits]\ninfNormPoly p = foldl max 0 p_centered\n            where\n              p_centered = map infNorm p\n\ninfNormPolyVec : {dim} (fin dim, dim>=1) => intPolyVec dim -> [qbits]\ninfNormPolyVec v = foldl max 0 (map infNormPoly v)\n\nBVtoIntPoly : poly -> [n]Integer\nBVtoIntPoly p = map (\\x -> toInteger x) p\n\nBVtoIntPolyVec : {dim} (fin dim, dim >= 1) => polyVec dim -> [dim][n]Integer\nBVtoIntPolyVec pvec = map (\\x -> BVtoIntPoly x) pvec\n\nBVtoIntNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => nttMat dim1 dim2 -> [dim1][dim2][n]Integer\nBVtoIntNttMat nttmat = map (\\x -> BVtoIntPolyVec x) nttmat\n\nBVtoZPoly : poly -> [n](Z q)\nBVtoZPoly p = map (\\x -> BVtoZ`{q} x) p\n\nBVtoZPolyVec : {dim} (fin dim, dim >= 1) => polyVec dim -> [dim][n](Z q)\nBVtoZPolyVec pvec = map (\\x -> BVtoZPoly x) pvec\n\nBVtoZNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => nttMat dim1 dim2 -> [dim1][dim2][n](Z q)\nBVtoZNttMat nttmat = map (\\x -> BVtoZPolyVec x) nttmat\n\nInttoZPoly : [n]Integer -> [n](Z q)\nInttoZPoly p = map (\\x -> fromInteger x:(Z q)) p\n\nInttoZPolyVec : {dim} (fin dim, dim >= 1) => [dim][n]Integer -> [dim][n](Z q)\nInttoZPolyVec pvec = map (\\x -> InttoZPoly x) pvec\n\nInttoZNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => [dim1][dim2][n]Integer -> [dim1][dim2][n](Z q)\nInttoZNttMat nttmat = map (\\x -> InttoZPolyVec x) nttmat\n\nfromZPoly : [n](Z q) -> [n]Integer\nfromZPoly p = map (\\x -> fromZ x) p\n\nfromZPolyVec : {dim} (fin dim, dim >= 1) => [dim][n](Z q) -> [dim][n]Integer\nfromZPolyVec pvec = map (\\x -> fromZPoly x) pvec\n\nfromZNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => [dim1][dim2][n](Z q) -> [dim1][dim2][n]Integer\nfromZNttMat nttmat = map (\\x -> fromZPolyVec x) nttmat\n```"}]}
