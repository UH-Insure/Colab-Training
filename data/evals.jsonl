{"task_id": 1, "type": "function", "task": "Implement a function named `xor8` which takes two 8-bit words and returns their bitwise XOR. Also provide a constant `zero8` equal to 0 (8-bit).", "test_setup_code": "", "test_list": ["assert cry.eval_f('xor8 0x00 0xFF').result() == BV(8,0xff)"], "challenge_test_list": []}
{"task_id": 2, "type": "function", "task": "Implement a function named `matrix` which takes no input and returns a 3 x 3 matrix of tuples. For the function use a nested comprehension to write an expression to produce a 3 × 3 matrix (as a sequence of sequences), such that the ijth entry contains the value (i, j).", "test_setup_code": "", "test_list": ["assert cry.eval_f('matrix').result() == [[(0, 0), (0, 1), (0, 2)], [(1, 0), (1, 1), (1, 2)], [(2, 0), (2, 1), (2, 2)]]"], "challenge_test_list": []}
{"task_id": 3, "type": "function", "task": "Implement a Caesar cipher. Provide a functions `encrypt` that takes an integer and string, `decrypt` that accepts an integer and string, and all other types neccessary for the functions to execute. Do NOT use explicit modulo operators (such as `mod` or `%`). In Cryptol, arithmetic on `[8]` values is already modulo `2^8`, so rely on that built-in overflow behaviour instead of writing your own modulo.", "test_setup_code": "", "test_list": ["assert ''.join(chr(int(b)) for b in cry.eval_f('encrypt 3 \"hello\"').result()) == 'khoor'"], "challenge_test_list": []}
{"task_id": 4, "type": "property", "task": "Using ONLY the functions and constraints provided, create a monomorphic Cryptol property named `equivalent` that proves decrypt inverts encrypt for a 512-byte plaintext.", "test_setup_code": "encryptChar : [8] -> [8] -> [8]\nencryptChar key c = (c + key)\ndecryptChar : [8] -> [8] -> [8]\ndecryptChar key c = (c - key)\nencrypt : {n} [8] -> [n][8] -> [n][8]\nencrypt key txt = [ encryptChar key c | c <- txt ]\ndecrypt : {n} [8] -> [n][8] -> [n][8]\ndecrypt key txt = [ decryptChar key c | c <- txt ]", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 5, "type": "function", "task": "Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA384` that imports the generic SHA-2 specification for SHA-384. Use `type DigestSize = 384`, `type w = 64`, and initialize the hash vector as `H0 = [\n        0xcbbb9d5dc1059ed8, 0x629a292a367cd507,\n        0x9159015a3070dd17, 0x152fecd8f70e5939,\n        0x67332667ffc00b31, 0x8eb44a8768581511,\n        0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4\n    ]\n`", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 6, "type": "function", "task": "Write a Cryptol module `Primitive::Symmetric::Cipher::Block::AES::ExpandKey` that imports the generic `GF28`, `State`, and `SubByteSBox` of the AES encryption modules. Define `type Nk` and `type Nr` as parameters with the constraints that `Nk >= 1` with `8 >= width` and `Nr >= 2` with `8 >= width`. Define the functions `expandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)`, `expandKeyForever : [Nk][4][8] -> [inf]RoundKey`, `keyWS : [Nk][4][8] -> [inf][4][8]`, `keyWS : [Nk][4][8] -> [inf][4][8]`, `Rcon : [8] -> [4]GF28`, `SubWord : [4]GF28 -> [4]GF28`, `RotWord : [4]GF28 -> [4]GF28`, `RotWord : [4]GF28 -> [4]GF28`, and `NextWord : [8] ->[4][8] -> [4][8] -> [4][8]`. The module should perform AES key expansion. The type `RoundKey` is defined in the `State` module as the following.", "test_setup_code": "type State       = [4][Nb]GF28\ntype Nb          = 4\ntype RoundKey    = State", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 7, "type": "function", "task": "Write a Cryptol specification that defines an incremental averaging state machine. The specification should define the type `State` to contain a sum of all values and the amount of values as two 32-bit words, the functions `init` to initialize `State`, `appendf` that adds a value to `sum'` and increments `len`, `digest` that returns the average in the `State`, and `avg` with signature `avg : {n} (fin n, 32 >= width n) => [n][32] -> [32]` to compute the averages of a sequence.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 8, "type": "function", "task": "Write a Cryptol module `Test` that imports `Cipher`. Define the function `evktest : {ks, bs, n} (fin bs) => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)`, that takes a cipher, `n` key and test vector tuples, and plain text. The function test that using the cipher’s `encrypt` to encrypt the plain text with each key from the test vectors will produce the cipher text in the test vectors. The function returns `n` tuples containing the cipher text produced by encrypting the plain text with each test key and a boolean value whether the cipher text matches the expected test vector.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}