{"task_id": 1, "type": "function", "task": "Implement a function named `xor8` which takes two 8-bit words and returns their bitwise XOR. Also provide a constant `zero8` equal to 0 (8-bit).", "test_setup_code": "", "test_list": ["assert cry.eval_f('xor8 0x00 0xFF').result() == BV(8,0xff)"], "challenge_test_list": []}
{"task_id": 2, "type": "function", "task": "Implement a function named `matrix` which takes no input and returns a 3 x 3 matrix of tuples. For the function use a nested comprehension to write an expression to produce a 3 × 3 matrix (as a sequence of sequences), such that the ijth entry contains the value (i, j).", "test_setup_code": "", "test_list": ["assert cry.eval_f('matrix').result() == [[(0, 0), (0, 1), (0, 2)], [(1, 0), (1, 1), (1, 2)], [(2, 0), (2, 1), (2, 2)]]"], "challenge_test_list": []}
{"task_id": 3, "type": "function", "task": "Implement a Caesar cipher. Define the functions `encrypt` and `decrypt` with the signature: `{n} [8] -> [n][8] -> [n][8]`.", "test_setup_code": "", "test_list": ["assert ''.join(chr(int(b)) for b in cry.eval_f('encrypt 3 \"hello\"').result()) == 'khoor'"], "challenge_test_list": []}
{"task_id": 4, "type": "property", "task": "Using ONLY the functions and constraints provided, create a monomorphic Cryptol property named `equivalent` that proves decrypt inverts encrypt for a 512-byte plaintext.", "test_setup_code": "encryptChar : [8] -> [8] -> [8]\nencryptChar key c = (c + key)\ndecryptChar : [8] -> [8] -> [8]\ndecryptChar key c = (c - key)\nencrypt : {n} [8] -> [n][8] -> [n][8]\nencrypt key txt = [ encryptChar key c | c <- txt ]\ndecrypt : {n} [8] -> [n][8] -> [n][8]\ndecrypt key txt = [ decryptChar key c | c <- txt ]", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 5, "type": "function", "task": "Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA384` that imports the generic SHA-2 specification for SHA-384. Use `type DigestSize = 384`, `type w = 64`, and initialize the hash vector as `H0 = [\n        0xcbbb9d5dc1059ed8, 0x629a292a367cd507,\n        0x9159015a3070dd17, 0x152fecd8f70e5939,\n        0x67332667ffc00b31, 0x8eb44a8768581511,\n        0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4\n    ]\n`", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 6, "type": "function", "task": "Write a Cryptol module `Primitive::Symmetric::Cipher::Block::AES::ExpandKey` that imports the generic `GF28`, `State`, and `SubByteSBox` of the AES encryption modules. Define `type Nk` and `type Nr` as parameters with the constraints that `Nk >= 1` with `8 >= width` and `Nr >= 2` with `8 >= width`. Define the functions `expandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)`, `expandKeyForever : [Nk][4][8] -> [inf]RoundKey`, `keyWS : [Nk][4][8] -> [inf][4][8]`, `Rcon : [8] -> [4]GF28`, `SubWord : [4]GF28 -> [4]GF28`, `RotWord : [4]GF28 -> [4]GF28`, and `NextWord : [8] ->[4][8] -> [4][8] -> [4][8]`. The module should perform AES key expansion. The type `RoundKey` is defined in the `State` module as the following.", "test_setup_code": "type State       = [4][Nb]GF28\ntype Nb          = 4\ntype RoundKey    = State", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 7, "type": "function", "task": "Write a Cryptol specification that defines an incremental averaging state machine. The specification should define the type `State` to contain a sum of all values and the amount of values as two 32-bit words, the functions `init` to initialize `State`, `appendf` that adds a value to `sum'` and increments `len`, `digest` that returns the average in the `State`, and `avg` with signature `avg : {n} (fin n, 32 >= width n) => [n][32] -> [32]` to compute the averages of a sequence.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 8, "type": "function", "task": "Write a Cryptol module `Test` that imports `Cipher`. Define the function `evktest : {ks, bs, n} (fin bs) => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)`, that takes a cipher, `n` key and test vector tuples, and plain text. The function test that using the cipher’s `encrypt` to encrypt the plain text with each key from the test vectors will produce the cipher text in the test vectors. The function returns `n` tuples containing the cipher text produced by encrypting the plain text with each test key and a boolean value whether the cipher text matches the expected test vector.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 9, "type": "function", "task": "Define a Cryptol module `ECDSA_test` with imports `Common::utils` and `Primitive::Asymmetric::Signature::ECDSA::p192 as p192`. Define a property for the function `G_compress R = ec_compress (ec_affinify G) == R` from the p192 module. Use the value `0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012` in your property.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 10, "type": "function", "task": "Define a Cryptol module `bivium` that generates the infinite keystream as specified by the Bivium stream cipher. Define the function `bivium_stream : [93] -> [84] -> [inf]` which takes two initial shift registers of lengths 93 and 84 bits and returns the infinite keystream according to the Bivium algorithm. Define `type N = 200`, and a function `Bivium : ([93], [84]) -> [N]Bit` which takes the two initial registers as a pair and returns the first N bits of the keystream returned from `bivium_stream`. Define the helper functions: `shift : {d} (fin d, d >=1) => [d] -> Bit -> [d]` that returns `fills` where `fills = [bit]#(drop`{1} (fill >> 1))`. The function `shift_regs : {d,e} (fin d, fin e, d >=1, e >=1) => [d] -> [e] -> ([inf],[inf][d],[inf][e])` that, given 2 initial registers, returns a tuple containing the infinite keystream, the infinite stream of `r1`, and the infinite stream of `r2`.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 11, "type": "function", "task": "Write a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512` that imports the generic `ECDSA::UnconstrainedSpec`. Instantiate it with the  `EC = Common::EC::PrimeField::Instantiations::P521` and `Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512`.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 12, "type": "function", "task": "Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96` that imports the generic Simon specification for Simon96_96. Use `type n = 48`, `type m = 2`, `type T = 52`, and `type j = 2`.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 13, "type": "function", "task": "Write a Cryptol specification for a parameterized SHA-2 style hash function over word size w, defining sha : {L} (2 * w >= width L) => [L] -> [digest_size] and all supporting types, constants (H0, K), and functions (padding, parsing, message schedule, compression, and block processing).", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 14, "type": "function", "task": "Using the existing type `Cipher` and value `toyCipher` provided in the test setup, define a single polymorphic Cryptol function named `evktest` with the following type:\n\nevktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\n\nThe function should take a cipher implementation, a sequence of (Key, Ciphertext) test vectors, and a single plaintext block. For each (Key, CT) in the list, it must iterate over that list using a single generator in a list comprehension (no parallel generators or multiple `|` arms), compute CT' = cipher.encrypt Key PT for that entry, and produce an output list of pairs (CT', CT' == CT).\n\nThe code for `Cipher` and `toyCipher` is ALREADY present in the file from the test setup code. In your answer, you MUST NOT repeat, modify, or redefine `Cipher` or `toyCipher`, and you MUST NOT add any other top-level declarations.\n\nYour entire answer must consist of exactly two top-level lines: (1) the type signature for `evktest` exactly as given above, and (2) the definition of `evktest`. Do not wrap these in a module declaration, and do not include any setup code.", "test_setup_code": "type Cipher ks bs =\n  { encrypt : [ks] -> [bs] -> [bs]\n  , decrypt : [ks] -> [bs] -> [bs]\n  }\n\ntoyCipher : Cipher 8 8\ntoyCipher = {\n  encrypt = \\k pt -> k ^ pt,\n  decrypt = \\k ct -> k ^ ct\n}\n", "test_list": ["assert cry.eval_f('evktest (toyCipher, [(0x00, 0x55), (0xff, 0xbb)], 0x55)').result() == [(BV(8,0x55), True), (BV(8,0xaa), False)]"], "challenge_test_list": []}
{"task_id": 15, "type": "property", "task": "Using ONLY the SHA-512 specification provided in the test setup (which defines a function `sha512` and all supporting constants), define a Cryptol property named `testVector1` with no arguments that checks `sha512` against the following fixed known-answer test vector:\n\n- Message (as a hex literal): 0x616263\n- Expected digest (as a hex literal): 0xddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f\n\nThe property must *exactly* assert that `sha512` of this message equals this digest.\n\nThe full definition of `sha512` (and all helper functions and constants) is ALREADY present in the file from the test setup code. In your answer, you MUST NOT repeat, modify, or redefine `sha512` or any of its helpers, and you MUST NOT add any other top-level declarations.\n\nYour entire answer must be a single top-level declaration starting with:\n\nproperty testVector1 =\n\nand it must directly assert that `sha512 0x616263` equals the given digest, using those exact hex constants. Do not introduce any arguments, do not wrap it in a module, and do not include any setup code.", "test_setup_code": "sha512 M = result\n  where\n    M' = (pad M)\n    blocks = (groupBy`{1024} M')\n    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]\n    result = (join (hash!0))\n\nprocessBlock : [1024] -> [8][64] -> [8][64]\nprocessBlock block Hprev = Hs\n  where\n    Mi = split block : [16][64]\n    Ws = (messageSch Mi)\n    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]\n    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]\n\nstep : [8][64] -> [64] -> [8] -> [8][64]\nstep [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']\n  where\n    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt\n    T2 = (SIGMA0 a) + (Maj a b c)\n    h' = g\n    g' = f\n    f' = e\n    e' = d + T1\n    d' = c\n    c' = b\n    b' = a\n    a' = T1 + T2\n\nmessageSch : [16][64] -> [80][64]\nmessageSch Mi = W\n  where\n    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]\n\npad : {l, k} (fin l,\n              l <= ((2^^128) - 1),\n              l >= 0,\n              fin k,\n              k - l >= 129,\n              k == 128 + l + 1 + 1024 - ((l+129)%1024),\n              k%1024 == 0) => [l] -> [k]\npad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])\n\nCh : [64] -> [64] -> [64] -> [64]\nCh x y z = (x && y) ^ ((~x) && z)\n\nMaj : [64] -> [64] -> [64] -> [64]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nSIGMA0 : [64] -> [64]\nSIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)\n\nSIGMA1 : [64] -> [64]\nSIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)\n\nsigma0 : [64] -> [64]\nsigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)\n\nsigma1 : [64] -> [64]\nsigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)\n\nH0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]\n\nK = [\n0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n]\n", "test_list": ["assert cry.eval_f(':prove testVector1')"], "challenge_test_list": []}
{"task_id": 16, "type": "property", "task": "Using ONLY the definitions `mk_buggy_fib_no_init`, `generate`, the infix operator `$`, and the sequences `foo` and `bar` provided in the test setup, define a Cryptol property named `fooEqualsBar` with no arguments that asserts that `foo` and `bar` are exactly equal. Do not redefine any of these functions or values; only provide the definition of `property fooEqualsBar`.", "test_setup_code": "mk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n  // Change output when state has magic value.\n  fn' = fn + if k == magic then 1 else 0\n\ngenerate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. n-1] ]\n\ninfixl 1 $\nf $ x = f x\n\nfoo : [10][4]\nfoo = generate $ \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n\nbar : [10][4]\nbar = generate \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n", "test_list": ["assert cry.eval_f(':prove fooEqualsBar')"], "challenge_test_list": []}
{"task_id": 17, "type": "function", "task": "Define the function `unflatten : {r,w} (fin r, 5 * w >= r, fin w) => [r] -> [w][5]` that pads its input with zeros and groups it into `w` blocks of 5 elements using `groupBy` in Cryptol. DO NOT include import statements, module declarations, or any other code.", "test_setup_code": "", "test_list": ["assert cry.eval_f('unflatten`{7,2} 0b1011011').result() == [BV(5,0x16), BV(5,0x18)]"], "challenge_test_list": []}
{"task_id": 18, "type": "function", "task": "Write a Cryptol file that defines the functions `mk_curve_ops`, `ec_v1`, and `ec_v2`. The definition must follow the exact structure shown in the prompt: `mk_curve_ops` must construct a record containing fields `field`, `v1`, and `v2`, where `v1` calls `ec_v1` on the input parameter and `v2` calls `ec_v2` on the record being constructed. The functions must use the polymorphic types exactly as shown and must access `p.field.v0` correctly in `ec_v2`. The file must contain no module declaration and must consist only of the three definitions.", "test_setup_code": "", "test_list": ["assert cry.load_file('T146.cry').ok()"], "challenge_test_list": []}
{"task_id": 19, "type": "function", "task": "Write a Cryptol module named `T038` that declares an interface submodule `I` providing `x : [8]`, a submodule `F` that imports interface submodule `I` and defines `y = x + 1`, a submodule `P` that imports submodule `F` while exposing submodule `Q`, a submodule `Q` that defines `x = 11`, and finally an interface submodule `J` that imports submodule `F` through `P`. The structure must match the Cryptol module system rules exactly.", "test_setup_code": "", "test_list": ["assert cry.load_file('T038.cry').ok()"], "challenge_test_list": []}
{"task_id": 20, "type": "function", "task": "Reproduce exactly the four foreign function declarations `foreignAndCryptol`, `foreignAndNoCryptol`, `noForeignAndCryptol`, and `noForeignAndNoCryptol`, each using the C calling convention. Implement `foreignAndCryptol` to return its argument unchanged, leave `foreignAndNoCryptol` unimplemented, implement `noForeignAndCryptol` to return `x + 3`, and leave `noForeignAndNoCryptol` unimplemented. The file must contain only these four declarations.", "test_setup_code": "", "test_list": ["assert cry.eval_f('foreignAndCryptol 0x12').result() == BV(8,0x12)", "assert cry.eval_f('noForeignAndCryptol 0x01').result() == BV(8,0x04)"], "challenge_test_list": []}
{"task_id": 21, "type": "property", "task": "Write a Cryptol module implementing parameterized AES encryption and decryption for key sizes 128, 192, and 256 bits. The module must import the AES algorithm, key expansion, and T-box modules exactly as specified, define `encrypt` and `decrypt` in terms of expanded keys, and include a property named `test` verifying that `decrypt k (encrypt k pt) == pt` for all valid keys and all 128-bit plaintexts.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove test').is_success()"], "challenge_test_list": []}
{"task_id": 22, "type": "property", "task": "Write a complete Cryptol module implementing the Bivium stream cipher. The module must define `Bivium_stream`, `Bivium`, `Bivium_alt`, and all cycle-testing helpers. It must also define the four properties: `Bivium_correct`, `Bivium_search`, `Bivium_search_with_suffix`, and `Bivium_alt_equivalent`, using the exact IVs, suffix, and test keystream provided. The file must match the structure and behavior of the Bivium specification.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove Bivium_correct').is_success()"], "challenge_test_list": []}
{"task_id": 24, "type": "property", "task": "Write a Cryptol module implementing the FNV-1a 64-bit hash function, including padding, the FNV offset basis, prime constant, the block-processing logic, and a property `testsPass` that verifies the hash of the empty string, \"a\", and \"foobar\" equals the known answer test vectors provided.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove testsPass').is_success()"], "challenge_test_list": []}
{"task_id": 26,"type": "function","task": "Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA384` that instantiates the generic SHA-2 specification for SHA-384 with 64-bit words, 384-bit digest size, and the given 8-word initial hash vector `H0`.","test_setup_code": "","test_list": ["assert hash [0x61, 0x62, 0x63] == 0xcb00753f45a35e8b5bb52e86599a1741ac10a60e43bbbee757598cd17aa7968e71cba1192519e53027b490f2387b4588"],"challenge_test_list": []}
{"task_id": 27,"type": "function","task": "Define a Cryptol module Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 with an xof function imported from the SHAKE256 instantiation and properties k5\u2013k8 that assert xof applied to [], 0b0, 0b11, and 0b110 equals the given 512-bit expected_result constants.","test_setup_code": "","test_list": ["assert cry.eval_f('k5')","assert cry.eval_f('k6')","assert cry.eval_f('k7')","assert cry.eval_f('k8')"],"challenge_test_list": []}
{"task_id": 28,"type": "function","task": "Write a Cryptol module that instantiates SHA3-224 and defines properties t1, t5, t72, and t512 that check the hash and hashBytes functions against the given known-answer test vectors.","test_setup_code": "","test_list": ["assert cry.eval_f('t1')","assert cry.eval_f('t5')","assert cry.eval_f('t72')","assert cry.eval_f('t512')"],"challenge_test_list": []}
{"task_id": 30,"type": "function","task": "Write a Cryptol specification that models the Kalotan logic puzzle with parents and child as Bits, defines the given constraints (heterosexual parents, kid lying, parents\u2019 statements), and includes properties equivalent to people_types, checkit1, and checkit2 capturing the valid/invalid configurations.","test_setup_code": "","test_list": ["assert cry.eval_f(':check people_types')","assert cry.eval_f(':check checkit1')","assert cry.eval_f(':check checkit2')"],"challenge_test_list": ["assert cry.eval_f(':prove people_types')","assert cry.eval_f(':prove checkit1')","assert cry.eval_f(':prove checkit2')"]}
{"task_id": 31,"type": "function","task": "Write a Cryptol specification for a parameterized SHA-2 style hash function over word size w, defining sha : {L} (2 * w >= width L) => [L] -> [digest_size] and all supporting types, constants (H0, K), and functions (padding, parsing, message schedule, compression, and block processing).","test_setup_code": "Ch_Alternate : {w} (fin w, w >= 1) => [w] -> [w] -> [w] -> [w]\nCh_Alternate x y z = (x /\\ y) \\/ (~x /\\ z)","test_list": ["assert cry.eval_f(':prove (\\x -> Maj x x x == x)')","assert cry.eval_f(':prove equivalent cry::Ch Ch_Alternate')"],"challenge_test_list": ["assert cry.eval_f(':prove (\\x -> Ch x x x == x)')","assert cry.eval_f(':prove (\\M -> parse (pad M) == split (pad M))')"]}
{"task_id": 32,"type": "function","task": "Create a function that performs modulo addition with the signature `mod_add_Z : (Integer, Integer, Integer) -> Integer`. The first parameter is the modulo base.","test_setup_code": "","test_list": ["assert cry.eval_f(':prove (\\x -> Maj x x x == x)')","assert cry.eval_f(':prove equivalent cry::Ch Ch_Alternate')"],"challenge_test_list": ["assert cry.eval_f(':prove (\\x -> Ch x x x == x)')","assert cry.eval_f(':prove (\\M -> parse (pad M) == split (pad M))')"]}
{"task_id": 33,"type": "function","task": "Create a function that multiplies a number with itself using modulo multiplication. Define the following functions `mod_mul_Z : (Integer, Integer, Integer) -> Integer` and `mod_sq_Z : (Integer, Integer) -> Integer`. The first parameter should be the modulo base for both functions. `mod_sq_Z` should call `mod_mul_Z` to perform the modulo multiplication.","test_setup_code": "","test_list": ["assert cry.eval_f(':prove (\\x -> Maj x x x == x)')","assert cry.eval_f(':prove equivalent cry::Ch Ch_Alternate')"],"challenge_test_list": ["assert cry.eval_f(':prove (\\x -> Ch x x x == x)')","assert cry.eval_f(':prove (\\M -> parse (pad M) == split (pad M))')"]}
{"task_id": 34,"type": "function","task": "Define the function `mod_div_Z : (Integer, Integer, Integer) -> Integer` that performs modulo division between two integers. The modulo base is the first parameter. You should implement Stein's algorithm and call `mod_half_Z` to perform modulo division by 2.","test_setup_code": "mod_half_Z : (Integer, Integer) -> Integer\nmod_half_Z (p, x) = if (x % 2 == 0) then x / 2 else (x + p) / 2\n","test_list": ["assert cry.eval_f(':prove (\\x -> Maj x x x == x)')","assert cry.eval_f(':prove equivalent cry::Ch Ch_Alternate')"],"challenge_test_list": ["assert cry.eval_f(':prove (\\x -> Ch x x x == x)')","assert cry.eval_f(':prove (\\M -> parse (pad M) == split (pad M))')"]}
{"task_id": 35,"type": "function","task": "Create a Cryptol specification that performs the SHA-512 message schedule expansion. Define the functions `messageSch : [16][64] -> [80][64]`, `sigma0 : [64] -> [64]`, and `sigma1 : [64] -> [64]` to perform the message expansion.","test_setup_code": "","test_list": ["assert cry.eval_f(':prove (\\x -> Maj x x x == x)')","assert cry.eval_f(':prove equivalent cry::Ch Ch_Alternate')"],"challenge_test_list": ["assert cry.eval_f(':prove (\\x -> Ch x x x == x)')","assert cry.eval_f(':prove (\\M -> parse (pad M) == split (pad M))')"]}
