{"task_id": 1, "type": "function", "task": "Implement a function named `xor8` which takes two 8-bit words and returns their bitwise XOR. Also provide a constant `zero8` equal to 0 (8-bit).", "test_setup_code": "", "test_list": ["assert cry.eval_f('xor8 0x00 0xFF').result() == BV(8,0xff)"], "challenge_test_list": []}
{"task_id": 2, "type": "function", "task": "Implement a function named `matrix` which takes no input and returns a 3 x 3 matrix of tuples. For the function use a nested comprehension to write an expression to produce a 3 × 3 matrix (as a sequence of sequences), such that the ijth entry contains the value (i, j).", "test_setup_code": "", "test_list": ["assert cry.eval_f('matrix').result() == [[(0, 0), (0, 1), (0, 2)], [(1, 0), (1, 1), (1, 2)], [(2, 0), (2, 1), (2, 2)]]"], "challenge_test_list": []}
{"task_id": 3, "type": "function", "task": "Implement a Caesar cipher. Define the functions `encrypt` and `decrypt` with the signature: `{n} [8] -> [n][8] -> [n][8]`.", "test_setup_code": "", "test_list": ["assert ''.join(chr(int(b)) for b in cry.eval_f('encrypt 3 \"hello\"').result()) == 'khoor'"], "challenge_test_list": []}
{"task_id": 4, "type": "property", "task": "Using ONLY the functions and constraints provided, create a monomorphic Cryptol property named `equivalent` that proves decrypt inverts encrypt for a 512-byte plaintext.", "test_setup_code": "encryptChar : [8] -> [8] -> [8]\nencryptChar key c = (c + key)\ndecryptChar : [8] -> [8] -> [8]\ndecryptChar key c = (c - key)\nencrypt : {n} [8] -> [n][8] -> [n][8]\nencrypt key txt = [ encryptChar key c | c <- txt ]\ndecrypt : {n} [8] -> [n][8] -> [n][8]\ndecrypt key txt = [ decryptChar key c | c <- txt ]", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 5, "type": "function", "task": "Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA384` that imports the generic SHA-2 specification for SHA-384. Use `type DigestSize = 384`, `type w = 64`, and initialize the hash vector as `H0 = [\n        0xcbbb9d5dc1059ed8, 0x629a292a367cd507,\n        0x9159015a3070dd17, 0x152fecd8f70e5939,\n        0x67332667ffc00b31, 0x8eb44a8768581511,\n        0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4\n    ]\n`", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 6, "type": "function", "task": "Write a Cryptol module `Primitive::Symmetric::Cipher::Block::AES::ExpandKey` that imports the generic `GF28`, `State`, and `SubByteSBox` of the AES encryption modules. Define `type Nk` and `type Nr` as parameters with the constraints that `Nk >= 1` with `8 >= width` and `Nr >= 2` with `8 >= width`. Define the functions `expandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)`, `expandKeyForever : [Nk][4][8] -> [inf]RoundKey`, `keyWS : [Nk][4][8] -> [inf][4][8]`, `Rcon : [8] -> [4]GF28`, `SubWord : [4]GF28 -> [4]GF28`, `RotWord : [4]GF28 -> [4]GF28`, and `NextWord : [8] ->[4][8] -> [4][8] -> [4][8]`. The module should perform AES key expansion. The type `RoundKey` is defined in the `State` module as the following.", "test_setup_code": "type State       = [4][Nb]GF28\ntype Nb          = 4\ntype RoundKey    = State", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 7, "type": "function", "task": "Write a Cryptol specification that defines an incremental averaging state machine. The specification should define the type `State` to contain a sum of all values and the amount of values as two 32-bit words, the functions `init` to initialize `State`, `appendf` that adds a value to `sum'` and increments `len`, `digest` that returns the average in the `State`, and `avg` with signature `avg : {n} (fin n, 32 >= width n) => [n][32] -> [32]` to compute the averages of a sequence.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 8, "type": "function", "task": "Write a Cryptol module `Test` that imports `Cipher`. Define the function `evktest : {ks, bs, n} (fin bs) => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)`, that takes a cipher, `n` key and test vector tuples, and plain text. The function test that using the cipher’s `encrypt` to encrypt the plain text with each key from the test vectors will produce the cipher text in the test vectors. The function returns `n` tuples containing the cipher text produced by encrypting the plain text with each test key and a boolean value whether the cipher text matches the expected test vector.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 9, "type": "function", "task": "Define a Cryptol module `ECDSA_test` with imports `Common::utils` and `Primitive::Asymmetric::Signature::ECDSA::p192 as p192`. Define a property for the function `G_compress R = ec_compress (ec_affinify G) == R` from the p192 module. Use the value `0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012` in your property.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 10, "type": "function", "task": "Define a Cryptol module `bivium` that generates the infinite keystream as specified by the Bivium stream cipher. Define the function `bivium_stream : [93] -> [84] -> [inf]` which takes two initial shift registers of lengths 93 and 84 bits and returns the infinite keystream according to the Bivium algorithm. Define `type N = 200`, and a function `Bivium : ([93], [84]) -> [N]Bit` which takes the two initial registers as a pair and returns the first N bits of the keystream returned from `bivium_stream`. Define the helper functions: `shift : {d} (fin d, d >=1) => [d] -> Bit -> [d]` that returns `fills` where `fills = [bit]#(drop`{1} (fill >> 1))`. The function `shift_regs : {d,e} (fin d, fin e, d >=1, e >=1) => [d] -> [e] -> ([inf],[inf][d],[inf][e])` that, given 2 initial registers, returns a tuple containing the infinite keystream, the infinite stream of `r1`, and the infinite stream of `r2`.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}
{"task_id": 11, "type": "function", "task": "Write a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512` that imports the the generic `ECDSA::UnconstrainedSpec`. Use `Common::EC::PrimeField::Instantiations::P521` and `Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512`.", "test_setup_code": "", "test_list": ["assert cry.eval_f(':prove equivalent')"], "challenge_test_list": []}