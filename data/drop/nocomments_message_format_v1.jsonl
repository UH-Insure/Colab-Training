{"filename":"cryptol\/lib\/Array.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Array` that introduces a primitive `Array` type and its primitive operations (constant, lookup, update, equality, copy, set, rangeEqual), and specifies the derived functions `arrayRangeLookup` and `arrayRangeUpdate` with appropriate type constraints and behavior as in the given interface."},{"role":"assistant","content":"```cryptol\nmodule Array where\n\nprimitive type Array : * -> * -> *\n\nprimitive arrayConstant : {a, b} b -> (Array a b)\nprimitive arrayLookup : {a, b} (Array a b) -> a -> b\nprimitive arrayUpdate : {a, b} (Array a b) -> a -> b -> (Array a b)\nprimitive arrayEq : {n, a} (Array [n] a) -> (Array [n] a) -> Bool\n\nprimitive arrayCopy : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> (Array [n] a)\n\nprimitive arraySet : {n, a} (Array [n] a) -> [n] -> a -> [n] -> (Array [n] a)\n\nprimitive arrayRangeEqual : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> Bool\n\narrayRangeLookup : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b\narrayRangeLookup arr idx = res\n  where\n    res @ i = arrayLookup arr (idx + i)\n\narrayRangeUpdate : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b -> (Array a b)\narrayRangeUpdate arr idx vals = arrs ! 0\n  where\n    arrs = [arr] # [ arrayUpdate acc (idx + i) val | acc <- arrs | i <- [0 ..< n] | val <- vals ]\n```"}]}
{"filename":"cryptol\/lib\/SuiteB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `SuiteB` that specifies AES-128\/192\/256 key schedules and block encryption\/decryption plus SHA-224\/256\/384\/512 functions, and include any necessary types, primitives, and helper functions as in the snippet."},{"role":"assistant","content":"```cryptol\nmodule SuiteB where\n\ntype AES128 = 4\n\ntype AES192 = 6\n\ntype AES256 = 8\n\ntype AESRoundKey = [4][32]\n\ntype AESEncryptKeySchedule k =\n  { aesEncInitialKey : AESRoundKey\n  , aesEncRoundKeys  : [k+5]AESRoundKey\n  , aesEncFinalKey   : AESRoundKey\n  }\n\ntype AESDecryptKeySchedule k =\n  { aesDecInitialKey : AESRoundKey\n  , aesDecRoundKeys  : [k+5]AESRoundKey\n  , aesDecFinalKey   : AESRoundKey\n  }\n\naes128EncryptSchedule : [128] -> AESEncryptKeySchedule AES128\naes128EncryptSchedule = aesExpandEncryptSchedule\n\naes128DecryptSchedule : [128] -> AESDecryptKeySchedule AES128\naes128DecryptSchedule = aesExpandDecryptSchedule\n\naes128Schedules : [128] -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\naes128Schedules = aesExpandSchedules\n\naes192EncryptSchedule : [192] -> AESEncryptKeySchedule AES192\naes192EncryptSchedule = aesExpandEncryptSchedule\n\naes192DecryptSchedule : [192] -> AESDecryptKeySchedule AES192\naes192DecryptSchedule = aesExpandDecryptSchedule\n\naes192Schedules : [192] -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\naes192Schedules = aesExpandSchedules\n\naes256EncryptSchedule : [256] -> AESEncryptKeySchedule AES256\naes256EncryptSchedule = aesExpandEncryptSchedule\n\naes256DecryptSchedule : [256] -> AESDecryptKeySchedule AES256\naes256DecryptSchedule = aesExpandDecryptSchedule\n\naes256Schedules : [256] -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\naes256Schedules = aesExpandSchedules\n\naesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]\naesEncryptBlock schedule plaintext = rnf (join final)\n  where\n  final = (AESEncFinalRound (rds!0)) ^ schedule.aesEncFinalKey\n\n  rds = [ schedule.aesEncInitialKey ^ split plaintext ] #\n        [ AESEncRound r ^ rdk\n        | rdk <- schedule.aesEncRoundKeys\n        | r   <- rds\n        ]\n\naesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]\naesDecryptBlock schedule cyphertext = rnf (join final)\n  where\n  final = (AESDecFinalRound (rds!0)) ^ schedule.aesDecFinalKey\n\n  rds = [ split cyphertext ^ schedule.aesDecInitialKey ] #\n        [ AESDecRound r ^ rdk\n        | rdk <- schedule.aesDecRoundKeys\n        | r   <- rds\n        ]\n\nprivate\n    aesExpandEncryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESEncryptKeySchedule k\n    aesExpandEncryptSchedule key = rnf\n         { aesEncInitialKey = ks @  0\n         , aesEncRoundKeys  = ks @@ [ 1 .. k+5 ]\n         , aesEncFinalKey   = ks @  `(k+6)\n         }\n      where\n      ks : [k+7]AESRoundKey\n      ks = groupBy`{4} (AESKeyExpand`{k} (split key))\n\n    aesEncToDecSchedule : {k} (fin k) => AESEncryptKeySchedule k -> AESDecryptKeySchedule k\n    aesEncToDecSchedule enc = rnf\n       { aesDecInitialKey = enc.aesEncFinalKey\n       , aesDecRoundKeys  = map AESInvMixColumns (reverse (enc.aesEncRoundKeys))\n       , aesDecFinalKey   = enc.aesEncInitialKey\n       }\n\n    aesExpandDecryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESDecryptKeySchedule k\n    aesExpandDecryptSchedule key = aesEncToDecSchedule (aesExpandEncryptSchedule key)\n\n    aesExpandSchedules : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> (AESEncryptKeySchedule k, AESDecryptKeySchedule k)\n    aesExpandSchedules key = (encS, aesEncToDecSchedule encS)\n      where encS = aesExpandEncryptSchedule key\n\n    primitive AESEncRound      : [4][32] -> [4][32]\n    primitive AESEncFinalRound : [4][32] -> [4][32]\n    primitive AESDecRound      : [4][32] -> [4][32]\n    primitive AESDecFinalRound : [4][32] -> [4][32]\n    primitive AESInvMixColumns : [4][32] -> [4][32]\n    primitive AESKeyExpand     : {k} (fin k, k >= 4, 8 >= k) => [k][32] -> [4*(k+7)][32]\n\nsha224 : {L} (fin L) => [L] -> [224]\nsha224 msg = join (processSHA2_224 (sha2blocks`{32} msg))\n\nsha256 : {L} (fin L) => [L] -> [256]\nsha256 msg = join (processSHA2_256 (sha2blocks`{32} msg))\n\nsha384 : {L} (fin L) => [L] -> [384]\nsha384 msg = join (processSHA2_384 (sha2blocks`{64} msg))\n\nsha512 : {L} (fin L) => [L] -> [512]\nsha512 msg = join (processSHA2_512 (sha2blocks`{64} msg))\n\nprivate\n    type sha2_block_size w = 16 * w\n    type sha2_num_blocks w L = (L+1+2*w) \/^ sha2_block_size w\n    type sha2_padded_size w L = sha2_num_blocks w L * sha2_block_size w\n\n    sha2pad : {w, L} (fin w, fin L, w >= 1) => [L] -> [sha2_padded_size w L]\n    sha2pad M = rnf (M # 0b1 # zero # ((fromInteger `L) : [2*w]))\n\n    sha2blocks : {w, L} (fin w, fin L, w >= 1) =>\n      [L] -> [sha2_num_blocks w L][16][w]\n    sha2blocks msg = [ split x | x <- split (sha2pad`{w} msg) ]\n\n    primitive processSHA2_224 : {n} (fin n) => [n][16][32] -> [7][32]\n\n    primitive processSHA2_256 : {n} (fin n) => [n][16][32] -> [8][32]\n\n    primitive processSHA2_384 : {n} (fin n) => [n][16][64] -> [6][64]\n\n    primitive processSHA2_512 : {n} (fin n) => [n][16][64] -> [8][64]\n```"}]}
{"filename":"cryptol\/lib\/Float.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines IEEE-754 style floating-point types Float16\/32\/64\/128\/256, rounding modes, and primitives (e.g., fpAdd, fpSub, fpMul, fpDiv, fpFMA, fpSqrt, fpFromBits, fpToBits, fpIsNaN\/Inf\/Zero\/Normal\/Subnormal, fpFromRational, fpToRational) with the same interfaces."},{"role":"assistant","content":"```cryptol\nmodule Float where\n\nprimitive type ValidFloat : # -> # -> Prop\n\nprimitive type { exponent : #, precision : #}\n  ValidFloat exponent precision => Float exponent precision : *\n\ntype Float16  = Float 5 11\n\ntype Float32  = Float 8 24\n\ntype Float64  = Float 11 53\n\ntype Float128 = Float 15 113\n\ntype Float256 = Float 19 237\n\ntype RoundingMode = [3]\n\nroundNearestEven, rne : RoundingMode\nroundNearestEven = 0\nrne              = roundNearestEven\n\nroundNearestAway, rna : RoundingMode\nroundNearestAway  = 1\nrna               = roundNearestAway\n\nroundPositive, rtp : RoundingMode\nroundPositive     = 2\nrtp               = roundPositive\n\nroundNegative, rtn : RoundingMode\nroundNegative     = 3\nrtn               = roundNegative\n\nroundZero, rtz : RoundingMode\nroundZero         = 4\nrtz               = roundZero\n\nprimitive\n  fpNaN : {e,p} ValidFloat e p => Float e p\n\nprimitive\n  fpPosInf : {e,p} ValidFloat e p => Float e p\n\nfpNegInf : {e,p} ValidFloat e p => Float e p\nfpNegInf = - fpPosInf\n\nfpPosZero : {e,p} ValidFloat e p => Float e p\nfpPosZero = zero\n\nfpNegZero : {e,p} ValidFloat e p => Float e p\nfpNegZero = - fpPosZero\n\nprimitive\n  fpFromBits : {e,p} ValidFloat e p => [e + p] -> Float e p\n\nprimitive\n  fpToBits : {e,p} ValidFloat e p => Float e p -> [e + p]\n\nprimitive\n  (=.=) : {e,p} ValidFloat e p => Float e p -> Float e p -> Bool\n\ninfix 20 =.=\n\nprimitive fpIsNaN : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsInf : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsZero : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsNeg : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsNormal : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsSubnormal : {e,p} ValidFloat e p => Float e p -> Bool\n\nfpIsFinite : {e,p} ValidFloat e p => Float e p -> Bool\nfpIsFinite f = ~ (fpIsNaN f \\\/ fpIsInf f )\n\nprimitive\n  fpAdd : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpSub : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpMul : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpDiv : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpFMA : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpAbs : {e,p} ValidFloat e p =>\n    Float e p -> Float e p\n\nprimitive\n  fpSqrt : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p\n\nprimitive\n  fpToRational : {e,p} ValidFloat e p =>\n    Float e p -> Rational\n\nprimitive\n  fpFromRational : {e,p} ValidFloat e p =>\n    RoundingMode -> Rational -> Float e p\n```"}]}
{"filename":"cryptol\/lib\/Cryptol.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Cryptol` that provides the core prelude: primitive numeric and logical types, bitvector and sequence operations, comparison and arithmetic classes, folds\/maps\/zips, sorting, and utility functions, with the same names, types, infix declarations, and properties as in the standard Cryptol prelude."},{"role":"assistant","content":"```cryptol\nmodule Cryptol where\n\ninfixr  5 ==>\ninfixr 10 \\\/\ninfixr 15 \/\\\ninfix  20 ==, ===, !=, !==\ninfix  30 >, >=, <, <=, <$, >$, <=$, >=$\ninfixr 40 ||\ninfixl 45 ^\ninfixr 50 &&\ninfixr 60 #\ninfixl 70 <<, <<<, >>, >>>, >>$\ninfixl 80 +, -\ninfixl 90 *, \/, %, \/$, %$, %^, \/^\ninfixr 95 ^^\ninfixl 100 @, @@, !, !!\n\nprimitive type Bit : *\n\nprimitive type Integer : *\n\nprimitive type {n : #} (fin n, n >= 1) => Z n : *\n\nprimitive type Rational : *\n\ntype Bool = Bit\ntype Word n = [n]\ntype Char = [8]\ntype String n = [n]Char\n\nprimitive type inf : #\n\nprimitive type (==) : # -> # -> Prop\n\nprimitive type (!=) : # -> # -> Prop\n\nprimitive type (>=) : # -> # -> Prop\n\nprimitive type fin : # -> Prop\n\nprimitive type prime : # -> Prop\n\nprimitive type (+) : # -> # -> #\n\nprimitive type (*) : # -> # -> #\n\nprimitive type\n  {m : #, n : # }\n  (fin n, m >= n) =>\n  m - n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin m, n >= 1) =>\n  m \/ n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin m, n >= 1) =>\n  m % n : #\n\nprimitive type (^^) : # -> # -> #\n\nprimitive type width : # -> #\n\ntype lg2 n = width (max n 1 - 1)\n\nprimitive type min : # -> # -> #\n\nprimitive type max : # -> # -> #\n\nprimitive type\n  { m : #, n : # }\n  (fin n, n >= 1) =>\n  m \/^ n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin n, n >= 1) =>\n  m %^ n : #\n\nprimitive type\n  { start : #, next : #, last : # }\n  (fin start, fin next, fin last, start != next) =>\n  lengthFromThenTo start next last : #\n\ntype constraint i <= j = (j >= i)\n\ntype constraint i > j = i >= j + 1\n\ntype constraint i < j = j >= i + 1\n\nprimitive type Literal : # -> * -> Prop\n\nprimitive type LiteralLessThan : # -> * -> Prop\n\nprimitive number : {val, rep} Literal val rep => rep\n\ndemote : {val, rep} Literal val rep => rep\ndemote = number`{val}\n\nlength : {n, a, b} (fin n, Literal n b) => [n]a -> b\nlength _ = `n\n\nprimitive fromTo : {first, last, a}\n  (fin last, last >= first, Literal last a) =>\n  [1 + (last - first)]a\n\nprimitive fromToLessThan :\n  {first, bound, a} (fin first, bound >= first, LiteralLessThan bound a) =>\n  [bound - first]a\n\nprimitive fromToBy : {first, last, stride, a}\n  (fin last, fin stride, stride >= 1, last >= first, Literal last a) =>\n  [1 + (last - first)\/stride]a\n\nprimitive fromToByLessThan : {first, bound, stride, a}\n  (fin first, fin stride, stride >= 1, bound >= first, LiteralLessThan bound a) =>\n  [(bound - first)\/^stride]a\n\nprimitive fromToDownBy : {first, last, stride, a}\n  (fin first, fin stride, stride >= 1, first >= last, Literal first a) =>\n  [1 + (first - last)\/stride]a\n\nprimitive fromToDownByGreaterThan : {first, bound, stride, a}\n  (fin first, fin stride, stride >= 1, first >= bound, Literal first a) =>\n  [(first - bound)\/^stride]a\n\nprimitive fromThenTo : {first, next, last, a, len}\n                       ( fin first, fin next, fin last\n                       , Literal first a, Literal next a, Literal last a\n                       , first != next\n                       , lengthFromThenTo first next last == len) => [len]a\n\nprimitive type FLiteral : # -> # -> # -> * -> Prop\n\nprimitive\n  fraction : { m, n, r, a } FLiteral m n r a => a\n\nprimitive type Zero : * -> Prop\n\nprimitive zero : {a} (Zero a) => a\n\nprimitive type Logic : * -> Prop\n\nprimitive (&&) : {a} (Logic a) => a -> a -> a\n\nprimitive (||) : {a} (Logic a) => a -> a -> a\n\nprimitive (^) : {a} (Logic a) => a -> a -> a\n\nprimitive complement : {a} (Logic a) => a -> a\n\nprimitive type Ring : * -> Prop\n\nprimitive fromInteger : {a} (Ring a) => Integer -> a\n\nprimitive (+) : {a} (Ring a) => a -> a -> a\n\nprimitive (-) : {a} (Ring a) => a -> a -> a\n\nprimitive (*) : {a} (Ring a) => a -> a -> a\n\nprimitive negate : {a} (Ring a) => a -> a\n\nprimitive type Integral : * -> Prop\n\nprimitive (\/) : {a} (Integral a) => a -> a -> a\n\nprimitive (%) : {a} (Integral a) => a -> a -> a\n\nprimitive toInteger : {a} (Integral a) => a -> Integer\n\nprimitive (^^) : {a, e} (Ring a, Integral e) => a -> e -> a\n\nprimitive infFrom : {a} (Integral a) => a -> [inf]a\n\nprimitive infFromThen : {a} (Integral a) => a -> a -> [inf]a\n\nprimitive type Field : * -> Prop\n\nprimitive recip : {a} (Field a) => a -> a\n\nprimitive (\/.) : {a} (Field a) => a -> a -> a\n\nprimitive type Round : * -> Prop\n\nprimitive ceiling : {a} (Round a) => a -> Integer\n\nprimitive floor : {a} (Round a) => a -> Integer\n\nprimitive trunc : {a} (Round a) => a -> Integer\n\nprimitive roundAway : {a} (Round a) => a -> Integer\n\nprimitive roundToEven : {a} (Round a) => a -> Integer\n\nprimitive type Eq : * -> Prop\n\nprimitive (==) : {a} (Eq a) => a -> a -> Bit\n\nprimitive (!=) : {a} (Eq a) => a -> a -> Bit\n\n(===) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\nf === g = \\ x -> f x == g x\n\n(!==) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\nf !== g = \\x -> f x != g x\n\nprimitive type Cmp : * -> Prop\n\nprimitive (<) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (>) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (<=) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (>=) : {a} (Cmp a) => a -> a -> Bit\n\nmin : {a} (Cmp a) => a -> a -> a\nmin x y = if x < y then x else y\n\nmax : {a} (Cmp a) => a -> a -> a\nmax x y = if x > y then x else y\n\nabs : {a} (Cmp a, Ring a) => a -> a\nabs x = if x < fromInteger 0 then negate x else x\n\nprimitive type SignedCmp : * -> Prop\n\nprimitive (<$) : {a} (SignedCmp a) => a -> a -> Bit\n\n(>$) : {a} (SignedCmp a) => a -> a -> Bit\nx >$ y = y <$ x\n\n(<=$) : {a} (SignedCmp a) => a -> a -> Bit\nx <=$ y = ~(y <$ x)\n\n(>=$) : {a} (SignedCmp a) => a -> a -> Bit\nx >=$ y = ~(x <$ y)\n\nenum Option a = None | Some a\n\nenum Result t e = Ok t | Err e\n\nprimitive True  : Bit\n\nprimitive False : Bit\n\n(\/\\) : Bit -> Bit -> Bit\nx \/\\ y = if x then y else False\n\n(\\\/) : Bit -> Bit -> Bit\nx \\\/ y = if x then True else y\n\n(==>) : Bit -> Bit -> Bit\na ==> b = if a then b else True\n\nprimitive (\/$) : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\n\nprimitive (%$) : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\n\ncarry : {n} (fin n) => [n] -> [n] -> Bit\ncarry x y = (x + y) < x\n\nscarry : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nscarry x y = (sx == sy) && (sx != sz)\n  where\n    z  = x + y\n    sx = head x\n    sy = head y\n    sz = head z\n\nsborrow : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsborrow x y = ( x <$ (x-y) ) ^ head y\n\nzext : {m, n} (fin m, m >= n) => [n] -> [m]\nzext x = zero # x\n\nsext : {m, n} (fin m, m >= n, n >= 1) => [n] -> [m]\nsext x = newbits # x\n  where newbits = if head x then ~zero else zero\n\nprimitive (>>$) : {n, ix} (fin n, n >= 1, Integral ix) => [n] -> ix -> [n]\n\nprimitive lg2 : {n} (fin n) => [n] -> [n]\n\nprimitive toSignedInteger : {n} (fin n, n >= 1) => [n] -> Integer\n\nprimitive ratio : Integer -> Integer -> Rational\n\nprimitive fromZ : {n} (fin n, n >= 1) => Z n -> Integer\n\nprimitive (#) : {front, back, a} (fin front) => [front]a -> [back]a\n                                             -> [front + back] a\n\nsplitAt : {front, back, a} (fin front) => [front + back]a\n                                       -> ([front]a, [back]a)\nsplitAt xs = (take`{front,back} xs, drop`{front,back} xs)\n\nprimitive join : {parts, each, a} (fin each) => [parts][each]a\n                                             -> [parts * each]a\n\nprimitive split : {parts, each, a} (fin each) => [parts * each]a\n                                              -> [parts][each]a\n\nprimitive reverse : {n, a} (fin n) => [n]a -> [n]a\n\nprimitive transpose : {rows, cols, a} [rows][cols]a -> [cols][rows]a\n\nprimitive take : {front, back, a} [front + back]a -> [front]a\n\nprimitive drop : {front, back, a} (fin front) => [front + back]a -> [back]a\n\ntail : {n, a} [1 + n]a -> [n]a\ntail xs = drop`{1} xs\n\nhead : {n, a} [1 + n]a -> a\nhead xs = xs @ (0 : Integer)\n\nlast : {n, a} (fin n) => [1 + n]a -> a\nlast xs = xs ! (0 : Integer)\n\ngroupBy : {each, parts, a} (fin each) => [parts * each]a -> [parts][each]a\ngroupBy = split`{parts=parts}\n\nprimitive (<<) : {n, ix, a} (Integral ix, Zero a) => [n]a -> ix -> [n]a\n\nprimitive (>>) : {n, ix, a} (Integral ix, Zero a) => [n]a -> ix -> [n]a\n\nprimitive (<<<) : {n, ix, a} (fin n, Integral ix) => [n]a -> ix -> [n]a\n\nprimitive (>>>) : {n, ix, a} (fin n, Integral ix) => [n]a -> ix -> [n]a\n\nprimitive (@) : {n, a, ix} (Integral ix) => [n]a -> ix -> a\n\n(@@) : {n, k, ix, a} (Integral ix) => [n]a -> [k]ix -> [k]a\nxs @@ is = [ xs @ i | i <- is ]\n\nprimitive (!) : {n, a, ix} (fin n, Integral ix) => [n]a -> ix -> a\n\n(!!) : {n, k, ix, a} (fin n, Integral ix) => [n]a -> [k]ix -> [k]a\nxs !! is = [ xs ! i | i <- is ]\n\nprimitive update : {n, a, ix} (Integral ix) => [n]a -> ix -> a -> [n]a\n\nprimitive updateEnd : {n, a, ix} (fin n, Integral ix) => [n]a -> ix -> a -> [n]a\n\nupdates : {n, k, ix, a} (Integral ix, fin k) => [n]a -> [k]ix -> [k]a -> [n]a\nupdates xs0 idxs vals = foldl upd xs0 (zip idxs vals)\n  where\n    upd xs (i,b) = update xs i b\n\nupdatesEnd : {n, k, ix, a} (fin n, Integral ix, fin k) => [n]a -> [k]ix -> [k]a -> [n]a\nupdatesEnd xs0 idxs vals = foldl upd xs0 (zip idxs vals)\n  where\n    upd xs (i,b) = updateEnd xs i b\n\ngenerate : {n, a, ix} (Integral ix, LiteralLessThan n ix) => (ix -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. <n] ]\n\nsort : {a, n} (Cmp a, fin n) => [n]a -> [n]a\nsort = sortBy (<=)\n\nsortBy : {a, n} (fin n) => (a -> a -> Bit) -> [n]a -> [n]a\nsortBy le ((xs : [n\/2]a) # (ys : [n\/^2]a)) = take zs.0\n  where\n    xs' = if `(n\/2)  == (1 : Integer) then xs else sortBy le xs\n    ys' = if `(n\/^2) == (1 : Integer) then ys else sortBy le ys\n    zs  = [ if i == `(n\/2)        then (ys'@j, i  , j+1)\n             | j == `(n\/^2)       then (xs'@i, i+1, j  )\n             | le (xs'@i) (ys'@j) then (xs'@i, i+1, j  )\n            else                       (ys'@j, i  , j+1)\n          | (_, i , j) <- [ (undefined, 0 : Integer, 0 : Integer) ] # zs\n          ]\n\nprimitive pmult : {u, v} (fin u, fin v) => [1 + u] -> [1 + v] -> [1 + u + v]\n\nprimitive pdiv : {u, v} (fin u, fin v) => [u] -> [v] -> [u]\n\nprimitive pmod : {u, v} (fin u, fin v) => [u] -> [1 + v] -> [v]\n\nprimitive parmap : {a, b, n} (Eq b, fin n) => (a -> b) -> [n]a -> [n]b\n\nprimitive deepseq : {a, b} Eq a => a -> b -> b\n\nrnf : {a} Eq a => a -> a\nrnf x = deepseq x x\n\nprimitive error : {a, n} (fin n) => String n -> a\n\nundefined : {a} a\nundefined = error \"undefined\"\n\nassert : {a, n} (fin n) => Bit -> String n -> a -> a\nassert pred msg x = if pred then x else error msg\n\nprimitive random : {a} [256] -> a\n\nprimitive trace : {n, a, b} (fin n) => String n -> a -> b -> b\n\ntraceVal : {n, a} (fin n) => String n -> a -> a\ntraceVal msg x = trace msg x x\n\nand : {n} (fin n) => [n]Bit -> Bit\nand xs = ~zero == xs\n\nor : {n} (fin n) => [n]Bit -> Bit\nor xs = zero != xs\n\nall : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nall f xs = foldl' (\/\\) True (map f xs)\n\n\/**\n * Disjunction after applying a predicate to all elements.\n *\/\nany : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nany f xs = foldl' (\\\/) False (map f xs)\n\nmap : {n, a, b} (a -> b) -> [n]a -> [n]b\nmap f xs = [f x | x <- xs]\n\nprimitive foldl : {n, a, b} (fin n) => (a -> b -> a) -> a -> [n]b -> a\n\nprimitive foldl' : {n, a, b} (fin n, Eq a) => (a -> b -> a) -> a -> [n]b -> a\n\n\/**\n * Functional right fold.\n *\n * foldr (-) 0 [1,2,3] = 0 - (1 - (2 - 3))\n *\/\nfoldr : {n, a, b} (fin n) => (a -> b -> b) -> b -> [n]a -> b\nfoldr f acc xs = foldl g acc (reverse xs)\n  where g b a = f a b\n\n\/**\n * Functional right fold, with strict evaluation of the accumulator value.\n * The accumulator is reduced to weak head normal form at each step.\n *\n * foldr' (-) 0 [1,2,3] = 0 - (1 - (2 - 3))\n *\/\nfoldr' : {n, a, b} (fin n, Eq b) => (a -> b -> b) -> b -> [n]a -> b\nfoldr' f acc xs = foldl' g acc (reverse xs)\n  where g b a = f a b\n\n\/**\n * Compute the sum of the values in the sequence.\n *\/\nsum : {n, a} (fin n, Eq a, Ring a) => [n]a -> a\nsum xs = foldl' (+) (fromInteger 0) xs\n\nproduct : {n, a} (fin n, Eq a, Ring a) => [n]a -> a\nproduct xs = foldl' (*) (fromInteger 1) xs\n\n\/**\n * Scan left is like a foldl that also emits the intermediate values.\n *\/\nprimitive scanl : {n, a, b}  (a -> b -> a) -> a -> [n]b -> [1+n]a\n\n\/**\n * Scan right is like a foldr that also emits the intermediate values.\n *\/\nscanr : {n, a, b} (fin n) => (a -> b -> b) -> b -> [n]a -> [1+n]b\nscanr f acc xs = reverse (scanl (\\a b -> f b a) acc (reverse xs))\n\n\/**\n * Repeat a value.\n *\/\nrepeat : {n, a} a -> [n]a\nrepeat x = [ x | _ <- zero : [n] ]\n\n\/**\n * 'elem x xs' returns true if x is equal to a value in xs.\n *\/\nelem : {n, a} (fin n, Eq a) => a -> [n]a -> Bit\nelem a xs = any (\\x -> x == a) xs\n\n\/**\n * Create a list of tuples from two lists.\n *\/\nzip : {n, a, b} [n]a -> [n]b -> [n](a, b)\nzip xs ys = [(x,y) | x <- xs | y <- ys]\n\n\/**\n * Create a list by applying the function to each pair of elements in the input.\n *\/\nzipWith : {n, a, b, c} (a -> b -> c) -> [n]a -> [n]b -> [n]c\nzipWith f xs ys = [f x y | x <- xs | y <- ys]\n\n\/**\n * Transform a function into uncurried form.\n *\/\nuncurry : {a, b, c} (a -> b -> c) -> (a, b) -> c\nuncurry f = \\(a, b) -> f a b\n\n\/**\n * Transform a function into curried form.\n *\/\ncurry : {a, b, c} ((a, b) -> c) -> a -> b -> c\ncurry f = \\a b -> f (a, b)\n\n\/**\n * Map a function iteratively over a seed value, producing an infinite\n * list of successive function applications.\n *\/\niterate : {a} (a -> a) -> a -> [inf]a\niterate f z = scanl (\\x _ -> f x) z (zero:[inf]())\n```"}]}
{"filename":"cryptol\/lib\/Cryptol\/Reference.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Cryptol::Reference` that implements polynomial multiplication `pmult`, division `pdiv`, and modulus `pmod` over GF(2), plus generic higher-order functions `foldl`, `scanl`, and `iterate`, with the same polymorphic types and behaviors as described."},{"role":"assistant","content":"```cryptol\nmodule Cryptol::Reference where\n\npmult : {u, v} (fin u, fin v) => [1 + u] -> [1 + v] -> [1 + u + v]\npmult x y = last zs\n  where\n    zs = [0] # [ (z << 1) ^ (if yi then 0 # x else 0) | yi <- y | z <- zs ]\n\npdiv : {u, v} (fin u, fin v) => [u] -> [v] -> [u]\npdiv x y = [ z ! degree | z <- zs ]\n  where\n    degree : [width v]\n    degree = last (ds : [1 + v]_)\n      where ds = [0\/0] # [if yi then i else d | yi <- reverse y | i <- [0..v] | d <- ds ]\n\n    reduce : [v] -> [v]\n    reduce u = if u ! degree then u ^ y else u\n\n    zs : [u][v]\n    zs = [ tail (reduce z # [xi]) | z <- [0] # zs | xi <- x ]\n\npmod : {u, v} (fin u, fin v) => [u] -> [1 + v] -> [v]\npmod x y = if y == 0 then 0\/0 else last zs\n  where\n    degree : [width v]\n    degree = last (ds : [2 + v]_)\n      where ds = [0\/0] # [if yi then i else d | yi <- reverse y | i <- [0..v] | d <- ds ]\n\n    reduce : [1 + v] -> [1 + v]\n    reduce u = if u ! degree then u ^ y else u\n\n    powers : [inf][1 + v]\n    powers = [reduce 1] # [ reduce (p << 1) | p <- powers ]\n\n    zs = [0] # [ z ^ (if xi then tail p else 0) | xi <- reverse x | p <- powers | z <- zs ]\n\nfoldl : {n, a, b} (fin n) => (a -> b -> a) -> a -> [n]b -> a\nfoldl f z bs = last (scanl f z bs)\n\nscanl : {n, a, b}  (a -> b -> a) -> a -> [n]b -> [1+n]a\nscanl f z bs = as\n  where\n    as = [z] # [ f a b | a <- as | b <- bs ]\n\niterate : {a} (a -> a) -> a -> [inf]a\niterate f z = xs\n  where xs = [z] # [ f x | x <- xs ]\n```"}]}
{"filename":"cryptol\/tests\/modsys\/T007.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines submodule F parameterized over a finite type n and value x, defines submodule I instantiating n = 8 and x = 2, and then defines and imports submodule M as F instantiated with I, including y = x + 11."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type n : #\n    x      : [n]\n    type constraint (fin n, n >= 4)\n\n  y : [n]\n  y = x + 11\n\nsubmodule I where\n  type n = 8\n  x = 2\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/enum\/CheckEnumPartialError.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the enums `Maybe a` and `Foo`, the functions `maybeMapBad1`, `maybeMapBad2`, `fooBad1`, and `fooGood`, and includes properties or checks that demonstrate the incomplete pattern matches in the `Bad` functions cause partiality or non-exhaustive pattern errors."},{"role":"assistant","content":"```cryptol\nenum Maybe a = Nothing | Just a\n\nmaybeMapBad1 : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMapBad1 f m =\n  case m of\n    Just x -> Just (f x)\n\nmaybeMapBad2 : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMapBad2 f m =\n  case m of\n    Nothing -> Nothing\n\nenum Foo = A | B | C\n\nfooBad1 : Foo -> ()\nfooBad1 f =\n  case f of\n    A -> ()\n\nfooGood : Foo -> ()\nfooGood f =\n  case f of\n    A -> ()\n    _ -> ()\n```"}]}
{"filename":"cryptol\/tests\/enum\/CheckProveEnum.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module defining the enums Maybe, Either, Foo, and Letter, with their map and equality functions, and properties maybeMapProp, eitherMapProp, fooMapProp, and letterRotateProp that verify the given composition\/rotation equalities for all inputs."},{"role":"assistant","content":"```cryptol\nenum Maybe a = Nothing | Just a\n\nmaybeEqual : {a} (Eq a) => Maybe a -> Maybe a -> Bit\nmaybeEqual m1 m2 =\n  case m1 of\n    Just x1 ->\n      case m2 of\n        Just x2 -> x1 == x2\n        Nothing -> False\n    Nothing ->\n      case m2 of\n        Just x2 -> False\n        Nothing -> True\n\nmaybeMap : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMap f m =\n  case m of\n    Just x  -> Just (f x)\n    Nothing -> Nothing\n\nmaybeMapProp : Maybe [8] -> Bit\nproperty maybeMapProp m =\n  maybeEqual\n    (maybeMap (\\x -> x + 1) (maybeMap (\\x -> x + 1) m))\n    (maybeMap (\\x -> x + 2) m)\n\nenum Either a b = Left a | Right b\n\neitherEqual : {a, b} (Eq a, Eq b) => Either a b -> Either a b -> Bit\neitherEqual e1 e2 =\n  case e1 of\n    Left x1 ->\n      case e2 of\n        Left x2  -> x1 == x2\n        Right y2 -> False\n    Right y1 ->\n      case e2 of\n        Left x2  -> False\n        Right y2 -> y1 == y2\n\neitherMapLeft : {a, a', b} (a -> a') -> Either a b -> Either a' b\neitherMapLeft f e =\n  case e of\n    Left x  -> Left (f x)\n    Right y -> Right y\n\neitherMapRight : {a, b, b'} (b -> b') -> Either a b -> Either a b'\neitherMapRight g e =\n  case e of\n    Left x  -> Left x\n    Right y -> Right (g y)\n\neitherMapBoth : {a, a', b, b'} (a -> a') -> (b -> b') -> Either a b -> Either a' b'\neitherMapBoth f g e =\n  case e of\n    Left x  -> Left (f x)\n    Right y -> Right (g y)\n\neitherMapProp : Either [8] [8] -> Bit\nproperty eitherMapProp e =\n  eitherEqual\n    (eitherMapLeft (\\x -> x + 1) (eitherMapRight (\\y -> y + 1) e))\n    (eitherMapBoth (\\x -> x + 1) (\\y -> y + 1) e)\n\nenum Foo a = Bar | Baz | Quux | Fred [8] a\n\nfooEqual : {a} (Eq a) => Foo a -> Foo a -> Bit\nfooEqual f1 f2 =\n  case f1 of\n    Bar ->\n      case f2 of\n        Bar        -> True\n        Baz        -> False\n        Quux       -> False\n        Fred y1 y2 -> False\n    Baz ->\n      case f2 of\n        Bar        -> False\n        Baz        -> True\n        Quux       -> False\n        Fred y1 y2 -> False\n    Quux ->\n      case f2 of\n        Bar        -> False\n        Baz        -> False\n        Quux       -> True\n        Fred y1 y2 -> False\n    Fred x1 x2 ->\n      case f2 of\n        Bar        -> False\n        Baz        -> False\n        Quux       -> False\n        Fred y1 y2 -> (x1 == y1) \/\\ (x2 == y2)\n\nfooMap : {a, b} (a -> b) -> Foo a -> Foo b\nfooMap f ff =\n  case ff of\n    Bar      -> Bar\n    Baz      -> Baz\n    Quux     -> Quux\n    Fred x y -> Fred x (f y)\n\nfooMapProp : Foo [8] -> Bit\nproperty fooMapProp f =\n  fooEqual\n    (fooMap (\\x -> x + 1) (fooMap (\\x -> x + 1) f))\n    (fooMap (\\x -> x + 2) f)\n\nenum Letter = A | B | C\n\nletterEqual : Letter -> Letter -> Bit\nletterEqual l1 l2 =\n  case l1 of\n    A ->\n      case l2 of\n        A -> True\n        B -> False\n        C -> False\n    B ->\n      case l2 of\n        A -> False\n        B -> True\n        C -> False\n    C ->\n      case l2 of\n        A -> False\n        B -> False\n        C -> True\n\nletterRotate : Letter -> Letter\nletterRotate l =\n  case l of\n    A -> B\n    B -> C\n    C -> A\n\nletterRotateProp : Letter -> Bit\nproperty letterRotateProp l =\n  letterEqual l (letterRotate (letterRotate (letterRotate l)))\n```"}]}
{"filename":"cryptol\/tests\/parser\/tuples-records.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the same tuple and record constants (including nested and empty variants) in a Cryptol module, preserving their structure and values exactly as given."},{"role":"assistant","content":"```cryptol\ntuple           = (0xFF, 0xFF)\nnested_tuple1   = (0xFF, (0xFF,0xFF))\nnested_tupel2   = ((0xFF,0xFF), 0xFF)\nempty_tuple     = ()\n\nrecord          = { x = 0xFF, y = 0xFF }\nnested_record   = { x = 0xFF, y = { x = 0xFF, y = 0xFF }}\nempty_records   = {}\n```"}]}
{"filename":"cryptol\/tests\/parser\/docs.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the same values, type synonym, infix operator, and property as in the given snippet, ensuring `property test4 x = (x : Bit)` type-checks for all `x` and that the operator `(++)` has the specified behavior and associativity."},{"role":"assistant","content":"```cryptol\ntest1 : Bit\ntest1 = True\n\ntest2 = True\n\ntest3 x = x\n\nproperty test4 x = (x : Bit)\n\ninfixl 5 ++\n\n(++) : {a} a -> a -> a\nx ++ _ = x\n\nprivate test5 = ()\n\ntype Foo = ()\n```"}]}
{"filename":"cryptol\/tests\/parser\/T437.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the functions `mk_buggy_fib_no_init`, `generate`, the infix operator `$`, and the sequences `foo` and `bar` with the given types and behaviors, including the self-referential definition of `foo` using `generate` and function application."},{"role":"assistant","content":"```cryptol\nmk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n  \/\/ Change output when state has magic value.\n  fn' = fn + if k == magic then 1 else 0\n\ngenerate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. n-1] ]\n\ninfixl 1 $\nf $ x = f x\n\nfoo : [10][4]\nfoo = generate $ \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n\nbar : [10][4]\nbar = generate \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n```"}]}
{"filename":"cryptol\/tests\/parser\/unary.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the expressions test1 and test2 as given, and add properties that assert each of these equalities holds for the 8-bit interpretations of bitwise complement (~) and arithmetic negation (-)."},{"role":"assistant","content":"```cryptol\ntest1 = (~ (5 : [8]) + 2) == (~ (5 : [8])) + 2\ntest2 = (- (5 : [8]) + 2) == (- (5 : [8])) + 2\n```"}]}
{"filename":"cryptol\/tests\/parser\/pat1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions f1 through f7 with the same pattern-matching behavior and types as below, ensuring they type-check correctly: f1 (x,y)=x; f2 (x # y)=x; f3 [x,y,z]=x+y+z; f4 {x=a,y=b}=a; f5 ((x:[8])#(y:[10]))=x#y:[10]; f6 (x#y:[10])=x; f7 (x#(y:[10]))=x."},{"role":"assistant","content":"```cryptol\nf1 (x,y) = x\nf2 (x # y) = x\nf3 [x,y,z] = x + y + z\nf4 {x = a, y = b } = a\nf5 ((x : [8]) # (y : [10])) = x # y : [10]\nf6 (x # y : [10]) = x\nf7 (x # (y : [10])) = x\n```"}]}
{"filename":"cryptol\/tests\/parser\/infix-1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the infix operators (++) and (**) in Cryptol with the given fixities and types, implementing (++) as byte-wise addition on [8] and (**) as ring multiplication for any Ring a, matching the provided semantics."},{"role":"assistant","content":"```cryptol\ninfixl 4 ++\ninfixl 5 **\n\n(++) : [8] -> [8] -> [8]\nx ++ y = x + y\n\n(**) : {a} (Ring a) => a -> a -> a\nx ** y = x * y\n```"}]}
{"filename":"cryptol\/tests\/parser\/applications.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the functions g, f and the constants app1 through app9 exactly as given, preserving their arithmetic expressions and applications so they can be typechecked and evaluated."},{"role":"assistant","content":"```cryptol\ng x   = x\nf x y = y\n\napp1 = g 0xFF\napp2 = f 0xFF 0xFF\napp3 = 0xFF + 0xFF\napp4 = 0x01 + 0x02 + 0x03\napp5 = 0x01 + 0x02 * 0x03\napp6 = 0x01 * 0x02 + 0x03\napp7 = 0x01 * g 0xFF + 0x02\napp8 = f (0x01 * g 0xFF + 0x02) 0xFF\napp9 = g (g 0xFF)\n```"}]}
{"filename":"cryptol\/tests\/regression\/twinmult.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In a Cryptol module that imports PrimeEC, define the projective point constant zro and the properties twin_mult_zro, twin_mult_zro1, twin_mult_zro2, twin_mult_same, and twin_mult_neg that specify correctness of ec_twin_mult against ec_mult, ec_add, ec_sub, and ec_negate on curve parameter 7."},{"role":"assistant","content":"```cryptol\nimport PrimeEC\n\nzro : ProjectivePoint 7\nzro = { x = 1, y = 1, z = 0 }\n\nproperty twin_mult_zro j k =\n  ec_equal`{7} (ec_twin_mult j zro k zro) zro\n\nproperty twin_mult_zro1 j k S =\n  ec_equal`{7} (ec_twin_mult j zro k S) (ec_mult k S)\n\nproperty twin_mult_zro2 j k S =\n  ec_equal`{7} (ec_twin_mult j S k zro) (ec_mult j S)\n\nproperty twin_mult_same j k S =\n  ec_equal`{7} (ec_twin_mult j S k S) (ec_add (ec_mult j S) (ec_mult k S))\n\nproperty twin_mult_neg j k S =\n  ec_equal`{7} (ec_twin_mult j S k (ec_negate S)) (ec_sub (ec_mult j S) (ec_mult k S))\n```"}]}
{"filename":"cryptol\/tests\/regression\/word-update.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines bit-update functions `update` and `updateEnd` on 16-bit words and properties `wordUpdate`, `wordUpdate2`, `wordUpdateEnd`, and `wordUpdateEnd2` that verify these functions match equivalent mask-based and index-based specifications for all `x:[16]`, `y:[8]`, and `b:Bit`."},{"role":"assistant","content":"```cryptol\nproperty wordUpdate (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> update x y b == if b then x || msk else x && ~msk\n\n where\n msk = 0b1000000000000000 >> y\n\nproperty wordUpdate2 (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> update x y b == x'\n\n where\n x' = [ if i == y then b else x@i | i <- [0 .. 15] ]\n\nproperty wordUpdateEnd (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> updateEnd x y b == if b then x || msk else x && ~msk\n\n where\n msk = 0b0000000000000001 << y\n\nproperty wordUpdateEnd2 (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> updateEnd x y b == x'\n\n where\n x' = [ if i == y then b else x!i | i <- reverse [0 .. 15] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/f2polytest.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines polynomial multiplication, division, and modulus over finite fields (pmult, pdiv, pmod) and properties asserting their equivalence to reference implementations Ref::pmult, Ref::pdiv, and Ref::pmod for several bit-width pairs."},{"role":"assistant","content":"```cryptol\nimport Cryptol::Reference as Ref\n\npmult_equiv : {u, v} (fin u, fin v) => [1+u] -> [1+v] -> Bit\npmult_equiv x y = pmult x y == Ref::pmult x y\n\npdiv_equiv : {u, v} (fin u, fin v) => [u] -> [v] -> Bit\npdiv_equiv x y = y == 0 \\\/ pdiv x y == Ref::pdiv x y\n\npmod_equiv : {u, v} (fin u, fin v) => [u] -> [1+v] -> Bit\npmod_equiv x y = y == 0 \\\/ pmod x y == Ref::pmod x y\n\nproperty mult3_9   = pmult_equiv`{3,9}\nproperty mult9_3   = pmult_equiv`{9,3}\nproperty mult8_8   = pmult_equiv`{8,8}\nproperty mult28_11 = pmult_equiv`{28,11}\nproperty mult32_32 = pmult_equiv`{32,32}\nproperty mult64_64 = pmult_equiv`{64,64}\n\nproperty div3_9   = pdiv_equiv`{3,9}\nproperty div9_3   = pdiv_equiv`{9,3}\nproperty div8_8   = pdiv_equiv`{8,8}\nproperty div28_11 = pdiv_equiv`{28,11}\nproperty div32_32 = pdiv_equiv`{32,32}\nproperty div64_64 = pdiv_equiv`{64,64}\n\nproperty mod3_9   = pmod_equiv`{3,9}\nproperty mod9_3   = pmod_equiv`{9,3}\nproperty mod8_8   = pmod_equiv`{8,8}\nproperty mod28_11 = pmod_equiv`{28,11}\nproperty mod32_32 = pmod_equiv`{32,32}\nproperty mod64_64 = pmod_equiv`{64,64}\n```"}]}
{"filename":"cryptol\/tests\/regression\/r01.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the polymorphic functions `any` and `all` in Cryptol, with the given types and list-comprehension-based implementations using bit-vector comparisons against `zero` and `~zero`, respectively."},{"role":"assistant","content":"```cryptol\nany : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nany f xs = [ f x | x <- xs ] != zero\n\nall : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nall f xs = [ f x | x <- xs ] == ~zero\n```"}]}
{"filename":"cryptol\/tests\/regression\/r05.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `unflatten : {r, w} (fin r, 5 * w >= r, fin w) => [r] -> [w][5]` in Cryptol so that it pads its input with zeros and groups it into `w` blocks of 5 bits using `groupBy` and concatenation with `zero`."},{"role":"assistant","content":"```cryptol\nunflatten : {r, w}\n            (fin r, 5 * w >= r, fin w)\n            => [r] -> [w][5]\nunflatten p = groupBy`{5}(p # zero)\n```"}]}
{"filename":"cryptol\/tests\/regression\/check22.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the functions `xtimes` and `gtimes` over 8-bit words using the AES Rijndael finite field with irreducible polynomial 0x1b, and a property `check22` that asserts [ gtimes (13, x) | x <- [1, 12, 192] ] == [13, 92, 183 ]."},{"role":"assistant","content":"```cryptol\nirred : [8]\nirred = 0x1b\nxtimes a = (if a ! (length a - 1) then a' ^ irred else a')\n  where a' = a << 1\n\ngtimes : ([8], [8]) -> [8]\ngtimes (a, b)\n  = (if b == 0 then 0 else xtimes (gtimes (a, b >> 1)) ^ a')\n      where a' = if b ! 0 then a else 0\n\ncheck22 = [ gtimes (13, x) | x <- [ 1, 12, 192 ] ] == [ 13, 92, 183 ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check23.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the function `pad` with the given constraints and constants `tmsg` and `out`, and includes the property `check23` that asserts `pad tmsg == out` holds."},{"role":"assistant","content":"```cryptol\npad : {msgLen, padding, contentLen, chunks}\n    ( fin msgLen\n    , fin padding\n    , contentLen == msgLen + 65\n    , chunks == (contentLen + 511) \/ 512\n    , 64 >= width msgLen\n    , padding == (512 - contentLen % 512) % 512\n    ) => [msgLen] -> [chunks * 512]\npad msg = msg # [True] # (zero:[padding]) # sz        where  sz : [64]\n             sz = (length msg):[64]\n\ntmsg : [4]\ntmsg = 13\nout : [512]\nout = 0xd8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004\ncheck23 = pad tmsg == out\n```"}]}
{"filename":"cryptol\/tests\/regression\/check09.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the mutually recursive streams ss and ls and the function keyX : [4][8] -> [7][32] as given, and a property check9 asserting check9a && check9b holds with the specified constant test vectors."},{"role":"assistant","content":"```cryptol\ninitS : [1][32]\ninitL : [1][32]\ninitS = [0]\ninitL = [0]\nss = [ (s + a + b) <<< 3   | s <- initS # ss\n\t                       | a <- [1] # ss\n\t                       | b <- [0] # ls ]\nls = [ (l + a + b) <<< (a + b)\n                        | l <- initL # ls\n\t\t                | a <- ss\n\t\t                | b <- [0] # ls ]\n\ncheck9a = (ss @@ [0 .. 3] == [ 0x00000008, 0x00004080, 0x00068c00, 0x00a22800 ])\n       && (ls @@ [0 .. 3] == [ 0x00000800, 0x00005080, 0x00072d00, 0x00b08200 ])\n\nkeyX : [4][8] -> [7][32]\nkeyX key = ss @@ [ 0 .. 6 ]\n  where\n    initS : [1][32]\n    initL : [1][32]\n    initS = [0]\n    initL = split (join key)\n    ss = [ (s + a + b) <<< 3\n                    | s <- initS # ss\n\t\t\t\t    | a <- [1] # ss\n\t\t\t\t    | b <- [0] # ls ]\n    ls = [ (l + a + b) <<< (a + b)\n                    | l <- initL # ls\n\t\t\t\t    | a <- ss\n\t\t\t\t    | b <- [0] # ls ]\n\ncheck9b = keyX (reverse \"abcd\") ==\n\t    [0x00000008, 0x1b134ba3, 0x11ae69b1, 0xb7b3f42f,\n             0xc9eb1fdc, 0x008b5f36, 0x8991bc8c]\n\ncheck9 = check9a && check9b\n```"}]}
{"filename":"cryptol\/tests\/regression\/check21.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `xtimes` over 8-bit values using the irreducible polynomial 0x1b and a property `check21` that asserts `[ xtimes y | y <- [1, 12, 192] ] == [2, 24, 155 ]` holds."},{"role":"assistant","content":"```cryptol\nirred : [8]\nirred = 0x1b\nxtimes a = (if a ! (length a - 1) then a' ^ irred else a')\n  where a' = a << 1\n\ncheck21 = [ xtimes y | y <- [ 1, 12, 192 ] ] == [ 2, 24, 155 ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the constant `check20` that evaluates to the Boolean result of adding two nested lists `[[[1,2],[3,4]]]` and `[[[5,6],[7,8]]]` and comparing the sum to `[[[6,8],[10,12]]]` using `==`."},{"role":"assistant","content":"```cryptol\ncheck20 = [ [ [ 1, 2 ], [ 3, 4 ] ] ]\n        + [ [ [ 5, 6 ], [ 7, 8 ] ] ]\n       == [ [ [ 6, 8 ], [ 10, 12 ] ] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check08.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the infinite sequences `qq` and `zs` as given, the value `check8`, and the property `prefix` asserting `qq @@ [0 .. 4] == [1, 2, 5, 12, 27]`, so that the property can be checked by a solver."},{"role":"assistant","content":"```cryptol\nqq = [ s + a + b | s <- [0] # qq\n\t          | a <- [1] # qq\n\t          | b <- [0] # zs ]\nzs : [inf][32]\nzs = [0...]\n\ncheck8 = qq @@ [0 .. 4] == [1, 2, 5, 12, 27]\n\nproperty prefix = qq @@ [0 .. 4] == [1, 2, 5, 12, 27]\n```"}]}
{"filename":"cryptol\/tests\/regression\/reference.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In a Cryptol module, import `Cryptol::Reference` as `Ref` and define the three properties `foldl_eq`, `scanl_eq`, and `iterate_eq` exactly as given so they can be checked for all valid inputs."},{"role":"assistant","content":"```cryptol\nimport Cryptol::Reference as Ref\n\nproperty foldl_eq (z:Integer) (xs:[10]Integer) =\n  foldl (-) z xs == Ref::foldl (-) z xs\n\nproperty scanl_eq (z:Integer) (xs:[10]Integer) =\n  scanl (-) z xs == Ref::scanl (-) z xs\n\nproperty iterate_eq (z:Integer) (i:[8]) =\n  (iterate (\\x -> x + 1) z)@i == (Ref::iterate (\\x -> x + 1) z)@i\n```"}]}
{"filename":"cryptol\/tests\/regression\/rec-update.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the record type T and the values f1 through f6 using record and sequence update syntax exactly as shown, ensuring type correctness and evaluating to the same resulting values."},{"role":"assistant","content":"```cryptol\ntype T = { x : [8], y : Bool }\n\nf1 = { x = 2, y = True } : T\nf2 = { f1 | x = 3 }\nf3 = { f2 | x = 4, y = False }\nf4 = { f3 | x -> x + 1 }\nf5 = [f1,f2,f3,f4]\nf6 = { f5 | x = [7,8,9,10] }\n```"}]}
{"filename":"cryptol\/tests\/regression\/check24.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `xor : {a} ([a], [a]) -> [a]` as bitwise inequality over two bitvectors and a constant `check24` that verifies for all 4-bit `x` and `y` that `xor` equals the built-in `(^)` operator, returning `~zero` when all comparisons hold."},{"role":"assistant","content":"```cryptol\nxor : {a} ([a], [a]) -> [a]\nxor (xs, ys) = [ x != y | x <- xs | y <- ys ]\n\ncheck24 = [ xor`{4} (x, y) == (x ^ y) | x <- [ 0 .. 15 ], y <- [ 0 .. 15 ] ] == ~zero\n```"}]}
{"filename":"cryptol\/tests\/regression\/primes.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the prime-modulus types p192, p224, p256, p384, p521, the functions z1prime, recip_correct, moddiv_eq over Z p, and properties verifying recip_correct and moddiv_eq for primes 17, 1021, and these NIST prime moduli."},{"role":"assistant","content":"```cryptol\nz1prime : {n} (prime n) => Z n\nz1prime = 1\n\nz1_2 = z1prime`{2}\nz1_3 = z1prime`{3}\nz1_17 = z1prime`{17}\nz1_2_17m1 = z1prime`{2^^17 - 1}\n\ntype p192 = 6277101735386680763835789423207666416083908700390324961279\ntype p224 = 26959946667150639794667015087019630673557916260026308143510066298881\ntype p256 = 115792089210356248762697446949407573530086143415290314195533631308867097853951\ntype p384 = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\ntype p521 = 6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151\n\nrecip_correct : {p} (prime p) => Z p -> Bool\nrecip_correct x = x == 0 \\\/ x * recip x == 1\n\nproperty recip_correct_17   = recip_correct`{17}\nproperty recip_correct_1021 = recip_correct`{1021}\nproperty recip_correct_p192 = recip_correct`{p192}\nproperty recip_correct_p224 = recip_correct`{p224}\nproperty recip_correct_p256 = recip_correct`{p256}\nproperty recip_correct_p384 = recip_correct`{p384}\nproperty recip_correct_p521 = recip_correct`{p521}\n\nmoddiv_eq : {p} (prime p, p >= 3) => Z p -> Z p -> Bool\nmoddiv_eq x y = y == 0 \\\/ (x \/. y) * y == x\n\nproperty moddiv_eq17   = moddiv_eq`{17}\nproperty moddiv_eq1021 = moddiv_eq`{1021}\n\nproperty moddiv_eq_p192 = moddiv_eq`{p192}\nproperty moddiv_eq_p224 = moddiv_eq`{p224}\nproperty moddiv_eq_p256 = moddiv_eq`{p256}\nproperty moddiv_eq_p384 = moddiv_eq`{p384}\nproperty moddiv_eq_p521 = moddiv_eq`{p521}\n```"}]}
{"filename":"cryptol\/tests\/regression\/bitshift.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the functions `shift`, `shift_alt`, the infinite zero stream `infZero`, and the property `shift_eq` asserting these two shift implementations are equivalent on 10-bit prefixes of an infinite zero-extended stream."},{"role":"assistant","content":"```cryptol\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n          fills = [bit]#(take fill)\n\nshift_alt : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift_alt fill bit = fills\n\twhere\n\t  fills = [bit]#(drop`{1} (fill >> 1))\n\ninfZero : [inf]Bit\ninfZero = [False] # infZero\n\nproperty shift_eq a b c d e = shift (take`{10} ([a,b,c,d]#infZero)) e\n                           == shift_alt (take`{10} ([a,b,c,d]#infZero)) e\n```"}]}
{"filename":"cryptol\/tests\/regression\/check27.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the constants and function `zeroBit`, `zeroTuple`, `zeroTuple3`, `zeroFun` and the property `check27` that checks they are all equal to the appropriate zero values as shown, so that `check27` holds for all inputs."},{"role":"assistant","content":"```cryptol\nzeroBit : Bit\nzeroBit = zero\n\nzeroTuple : ([8], [32])\nzeroTuple = zero\nzeroTuple3 : ([8], [32], [256])\nzeroTuple3 = zero\n\nzeroFun : [8] -> [16]\nzeroFun = zero\n\ncheck27 = (zeroBit == False)\n\t&& (zeroTuple == (0, 0)) && (zeroTuple3 == (0, 0, 0))\n\t&& ((0, 0) == zeroTuple) && ((0, 0, 0) == zeroTuple3)\n\t&& (zeroFun 13 == 0)\n```"}]}
{"filename":"cryptol\/tests\/regression\/check26.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions fst and snd for pairs and the values xy and xys, and then define the boolean properties check26a, check26b, check26c, and check26 that verify tuple projection and list-comprehension behavior as described."},{"role":"assistant","content":"```cryptol\nfst (x, y) = x\nsnd (x, y) = y\nxy = (13, 21)\ncheck26a = (fst xy == xy.0) && (snd xy == xy.1) &&\n\t   (fst xy == 13) && (snd xy == 21)\n\nxys = [ (x, y) | x <- [ 1 .. 10 ], y <- [ 2 .. 5 ] ]\ncheck26b = [ fst ixy | ixy <- xys ] ==\n\t   [ x | x <- [ 1 .. 10 ], y <- [ 2 .. 5 ] ]\ncheck26c = [ fst ixy == snd ixy | ixy <- xys ] == reverse 0x0000084210\n\ncheck26 = check26a && check26b && check26c\n```"}]}
{"filename":"cryptol\/tests\/regression\/check03.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `nats : [32] -> [inf][32]` as an infinite stream starting from a given 32-bit value, and define\/check the property `check3` that `(nats 0 @ 45 == 45) && (nats 45 @ 0 == 45)`."},{"role":"assistant","content":"```cryptol\nnats : [32] -> [inf][32]\nnats n = [n] # nats (n + 1)\n\ncheck3 = (nats 0 @ 45 == 45) && (nats 45 @ 0 == 45)\n```"}]}
{"filename":"cryptol\/tests\/regression\/rational_properties.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines a Rational type and proves the listed algebraic, order, and floor\/ceiling properties (QaddUnit, QaddComm, QaddAssoc, Qneg, QmulUnit, QmulComm, QmulAssoc, Qdistrib, Qrecip, QdivisionEquiv, QordEquiv1, QordEquiv2, QordTrans, QordIrreflexive, QordExclusive, Qtrichotomy, QordCompatible, QordPositive, Qdense, intDivDown, floorCorrect1, floorCorrect2, ceilingCorrect1, ceilingCorrect2) for all inputs."},{"role":"assistant","content":"```cryptol\nproperty QaddUnit (x : Rational) =\n  x + 0 == x\n\nproperty QaddComm (x:Rational) (y:Rational) =\n  x + y == y + x\n\nproperty QaddAssoc (x:Rational) (y:Rational) (z:Rational) =\n  x + (y + z) == (x + y) + z\n\nproperty Qneg (x: Rational) = x + negate x == 0\n\nproperty QmulUnit (x : Rational) =\n  x * 1 == x\n\nproperty QmulComm (x:Rational) (y:Rational) =\n  x * y == y * x\n\nproperty QmulAssoc (x:Rational) (y:Rational) (z:Rational) =\n  x * (y * z) == (x * y) * z\n\nproperty Qdistrib (x:Rational) (y:Rational) (z:Rational) =\n  x * (y + z) == x*y + x*z\n\nproperty Qrecip (x: Rational) = x == 0 \\\/ x * recip x == 1\n\nproperty QdivisionEquiv (x : Rational) (y : Rational) =\n  y == 0 \\\/ x \/. y == x * (recip y)\n\nproperty QordEquiv1 (x : Rational) (y : Rational) =\n  (x <= y) == ~(y < x)\n\nproperty QordEquiv2 (x : Rational) (y : Rational) =\n  (x <= y) == (x == y \\\/ x < y)\n\nproperty QordTrans (x : Rational) (y : Rational) (z : Rational) =\n  x < y ==> y < z ==> x < z\n\nproperty QordIrreflexive (x : Rational) =\n  ~(x < x)\n\nproperty QordExclusive (x : Rational) (y:Rational) =\n  ~(x < y) || ~(y < x) \n\nproperty Qtrichotomy (x : Rational) (y : Rational) =\n  x < y \\\/ x == y \\\/ x > y\n\nproperty QordCompatible (x : Rational) (y : Rational) (z:Rational) =\n  x < y ==> x+z < y+z\n\nproperty QordPositive (x : Rational) (y : Rational) =\n  0 < x ==> 0 < y ==> 0 < x*y\n\nproperty Qdense (x : Rational) (y : Rational) = x < y ==> x < mid \/\\ mid < y\n  where\n  mid = (x + y) \/. 2\n\nproperty intDivDown (x : Integer) (y:Integer) =\n  y == 0 \\\/ fromInteger (x \/ y) <= ratio x y\n\nproperty floorCorrect1 (x:Rational) =\n  fromInteger (floor x) <= x\n\nproperty floorCorrect2 (x:Rational) (y:Integer) =\n  fromInteger y <= x ==>\n  y <= floor x\n\nproperty ceilingCorrect1 (x:Rational) =\n  fromInteger (ceiling x) >= x\n\nproperty ceilingCorrect2 (x:Rational) (y:Integer) =\n  fromInteger y >= x ==>\n  y >= ceiling x\n```"}]}
{"filename":"cryptol\/tests\/regression\/check28.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the list `xs` of pairs and the value `check28` as a property-like boolean expression `[ x == y | (x,y) <- xs ] == ~zero` that can be checked by the solver."},{"role":"assistant","content":"```cryptol\nxs = [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7)]\ncheck28 = [ x==y | (x,y) <- xs ] == ~zero\n```"}]}
{"filename":"cryptol\/tests\/regression\/check14.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `swab` that reverses each 4-element sequence in a list, and a property `check14` asserting that `swab [[0, 1, 2, 3], [4, 5, 6, 7]] == [[3, 2, 1, 0], [7, 6, 5, 4]]` holds."},{"role":"assistant","content":"```cryptol\nswab xxs = [ [d, c, b, a]\n           | [a, b, c, d] <- xxs\n           ]\n\ncheck14 = swab [[0, 1, 2, 3], [4, 5, 6, 7]] == [[3, 2, 1, 0], [7, 6, 5, 4]]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check11.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `check11` that constructs a sequence `zz = [0 .. 99]`, forms `qq = zz @@ ([0 .. 0xffffffff] : [_][32])`, then `ww = qq @@ [0 .. 99]`, and returns the boolean result `zz == ww`."},{"role":"assistant","content":"```cryptol\ncheck11 = zz == ww\n  where\n    zz = [0 .. 99]\n    qq = zz @@ ([0 .. 0xffffffff] : [_][32])\n    ww = qq @@ [0 .. 99]\n```"}]}
{"filename":"cryptol\/tests\/regression\/FloatTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that imports `Float` and defines the Small, Medium, and Large floating-point types, along with the given floating-point round-trip, equality, ordering, and rational-conversion properties, so they can be checked by a SAT\/SMT solver."},{"role":"assistant","content":"```cryptol\nmodule FloatTests where\n\nimport Float\n\nsection : {n} fin n => [n][8] -> [78][8]\nsection x = \"-- \" # take`{min 60 n} x # repeat '-'\n\ntype Small  = Float 3 2\ntype Medium = Float64\ntype Large  = Float 60 5000\n\nproperty roundTrip x  = fpFromBits (fpToBits x) =.= x\n\nroundTrip2 : {e : #, p : #} (fin e, fin p, ValidFloat e p) => [e + p] -> Bool\nproperty roundTrip2 x = fpToBits num == x \\\/ num =.= fpNaN\n                          where num = fpFromBits x : Float e p\nproperty eqRefl1 x    = x =.= x\nproperty eqRefl2 x    = x == x \\\/ x =.= fpNaN\nproperty eqProp x y   = ~(x == y) \\\/\n                         (x =.= y \\\/ x =.= fpNaN\n                                  \\\/ y =.= fpNaN\n                                  \\\/ (x =.=  0.0 \/\\ y =.= -0.0)\n                                  \\\/ (x =.= -0.0 \/\\ y =.=  0.0)\n                         )\nproperty leqRefl x    = x <= x \\\/ x =.= fpNaN\n\nroundTripRational : {e,p} (fin e, fin p, ValidFloat e p) => Float e p -> Bool\nproperty roundTripRational x =\n  ~(fpIsFinite x) \\\/\n  (fpFromRational rne (fpToRational x) =.= x) \\\/\n  (x =.= fpNegZero)\n```"}]}
{"filename":"cryptol\/tests\/regression\/specialize.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define module `specialize` with a polymorphic function `f : {a, b} (a, b) -> (a, b)` and a function `top` that specializes `f` to `{Bit, Bit}` and applies it to a pair of bits."},{"role":"assistant","content":"```cryptol\nmodule specialize where\n\ntop (x, y) = f`{Bit,Bit} (x, y)\n\nf : {a, b} (a, b) -> (a, b)\nf (x, y) = (x, y)\n```"}]}
{"filename":"cryptol\/tests\/regression\/poly.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module defining a polymorphic polynomial type `Poly n a`, functions `evalPoly`, `polyConst`, `polyAdd`, `polyMul`, and properties `polySquare`, `polyAddEval`, and `polyMulEval` that verify polynomial evaluation, addition, and multiplication behave as expected over `Integer` and any `Ring a`."},{"role":"assistant","content":"```cryptol\nnewtype Poly n a = { coeffs : [n+1]a }\n\nevalPoly : {n, a} (fin n, Ring a) => Poly n a -> a -> a\nevalPoly p x = foldl (+) zero terms\n  where\n    terms = [ c*a | c <- p.coeffs | a <- xs ]\n    xs    = [fromInteger 1]#[ x*a | a <- xs ]\n\npolyConst : {n, a} (fin n, Ring a) => a -> Poly n a\npolyConst a = Poly { coeffs = [a]#zero }\n\npolyAdd : {n, a} (fin n, Ring a) => Poly n a -> Poly n a -> Poly n a\npolyAdd p1 p2 = Poly { coeffs = zipWith (+) p1.coeffs p2.coeffs }\n\npolyMul : {n1, n2, a} (fin n1, fin n2, Ring a) =>\n  Poly n1 a -> Poly n2 a -> Poly (n1+n2) a\npolyMul p1 p2 = foldl polyAdd (polyConst zero) ps\n  where\n    ps : [n1+1](Poly (n1+n2) a)\n    ps@i = Poly{ coeffs = scaleAndShift i }\n\n    scaleAndShift i =\n      ([ p1.coeffs@i * c | c <- p2.coeffs ] # zero) >> i\n\nproperty polySquare (x:Integer) =\n  evalPoly (Poly { coeffs = [0,0,1] }) x == x * x\n\nproperty polyAddEval x (p1:Poly 5 Integer) (p2:Poly 5 Integer) =\n  evalPoly (polyAdd p1 p2) x == evalPoly p1 x + evalPoly p2 x\n\nproperty polyMulEval x (p1:Poly 5 Integer) (p2:Poly 5 Integer) =\n  evalPoly (polyMul p1 p2) x == evalPoly p1 x * evalPoly p2 x\n```"}]}
{"filename":"cryptol\/tests\/regression\/check12.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `sums` implementing the recursive cumulative sum as given, and define the property `check12` that asserts `sums ([0 .. 9] : [_][32])` equals `[0, 1, 3, 6, 10, 15, 21, 28, 36, 45]`."},{"role":"assistant","content":"```cryptol\nsums xs = ys\n  where ys = [ x + y | x <- xs | y <- [0] # ys ]\n\ncheck12 = sums ([0 .. 9] : [_][32]) == [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check06.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the sequences `onetwos`, `twoones`, `onesytwosy`, and the property `check6` which asserts that `onesytwosy @@ [0 .. 3]` equals `[[1,2],[2,1],[1,2],[2,1]]` for all valid indices."},{"role":"assistant","content":"```cryptol\nonetwos = [1] # twoones\ntwoones = [2] # onetwos\nonesytwosy = [ [one, two] | one <- onetwos | two <- twoones ]\n\ncheck6 = onesytwosy @@ [0 .. 3] == [ [1, 2], [2, 1], [1, 2], [2, 1] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check13.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions `ick : [1][8] -> [8]` and `uck : [8][1] -> [8]`, and a property `check13` asserting `(ick (split 150) == 150) && (uck (split 150) == 150)`."},{"role":"assistant","content":"```cryptol\nick : [1][8] -> [8]\nick [x] = x\n\nuck : [8][1] -> [8]\nuck [a, b, c, d, e, f, g, h] = a # b # c # d # e # f # g # h\n\ncheck13 = (ick (split 150) == 150) && (uck (split 150) == 150)\n```"}]}
{"filename":"cryptol\/tests\/regression\/allsat.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the function `f : (Integer, Integer, Integer) -> Bit` which returns `True` exactly when all three integer arguments are in the inclusive range 1 to 15."},{"role":"assistant","content":"```cryptol\nf : (Integer, Integer, Integer) -> Bit\nf (x, y, z) =  inRange x && inRange y && inRange z\n  where inRange v = (1 <= v) && (v <= 15)\n```"}]}
{"filename":"cryptol\/tests\/regression\/negshift.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions negLeftShift, negRightShift, negLeftRotate, negRightRotate, and negSshr as given, and properties nls1\u20134, nrs1\u20134, nlr1\u20134, nrr1\u20134, and nsshr1\u20132 that verify these shift\/rotate identities for the specified type instantiations."},{"role":"assistant","content":"```cryptol\nnegLeftShift : {n, a} (fin n, Zero a, Cmp a) => [n]a -> Integer -> Bit\nnegLeftShift xs i = xs << i == xs >> (negate i)\n\nnegRightShift : {n, a} (fin n, Zero a, Cmp a) => [n]a -> Integer -> Bit\nnegRightShift xs i = xs >> i == xs << (negate i)\n\nnegLeftRotate : {n, a} (fin n, Cmp a) => [n]a -> Integer -> Bit\nnegLeftRotate xs i = xs <<< i == xs >>> (negate i)\n\nnegRightRotate : {n, a} (fin n, Cmp a) => [n]a -> Integer -> Bit\nnegRightRotate xs i = xs >>> i == xs <<< (negate i)\n\nnegSshr : {n} (fin n, n >= 1) => [n] -> Integer -> Bit\nnegSshr xs i = i < 0 ==> xs >>$ i == xs << (negate i)\n\nproperty nls1 = negLeftShift`{8, Bit}\nproperty nls2 = negLeftShift`{32, Bit}\nproperty nls3 = negLeftShift`{8, Integer}\nproperty nls4 = negLeftShift`{8, [32]}\n\nproperty nrs1 = negRightShift`{8, Bit}\nproperty nrs2 = negRightShift`{32, Bit}\nproperty nrs3 = negRightShift`{8, Integer}\nproperty nrs4 = negRightShift`{8, [32]}\n\nproperty nlr1 = negLeftRotate`{8, Bit}\nproperty nlr2 = negLeftRotate`{32, Bit}\nproperty nlr3 = negLeftRotate`{8, Integer}\nproperty nlr4 = negLeftRotate`{8, [32]}\n\nproperty nrr1 = negRightRotate`{8, Bit}\nproperty nrr2 = negRightRotate`{32, Bit}\nproperty nrr3 = negRightRotate`{8, Integer}\nproperty nrr4 = negRightRotate`{8, [32]}\n\nproperty nsshr1 = negSshr`{8}\nproperty nsshr2 = negSshr`{32}\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T06.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `T06` that uses an interface submodule `I` with a numeric type `N`, defines submodules `N1`, `C`, `B`, and `A` with the same structure as given, ensuring that submodule instantiation and interface imports type-check correctly."},{"role":"assistant","content":"```cryptol\nmodule T06 where\n\ninterface submodule I where\n  type N : #\n\nsubmodule N1 where\n  type N = 1\n\nsubmodule C where\n  import interface submodule I\n\n  lost = ()\n\nsubmodule B where\n  import interface submodule I\n  submodule C_ = submodule C { submodule N1 }\n\nsubmodule A = submodule B { submodule N1 }\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T10.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `T10` that defines public and private properties `p`, `q`, `r`, `s`, `t` of type `Bit` in nested submodules, including a parameterized submodule `F` with type parameter `N` and an instantiated submodule `F1` where `N = 1`, all properties equal to `True`."},{"role":"assistant","content":"```cryptol\nmodule T10 where\n\np : Bit\nproperty p = True\n\nsubmodule M where\n  q : Bit\n  property q = True\n\n  private\n    r : Bit\n    property r = True\n\nsubmodule F where\n  parameter\n    type N : #\n\n  s : Bit\n  property s = True\n\n  private\n    t : Bit\n    property t = True\n\nsubmodule F1 = submodule F where type N = 1\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T02.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module equivalent to `T02` with submodule `F` parameterized by a finite type `n >= 2`, a private constant `c : Z n = 1`, a property `p x = c + x == x + c`, its instantiation `F7` with `n = 7`, and function `f : Integer -> Integer` defined as `x + x`."},{"role":"assistant","content":"```cryptol\nmodule T02 where\n\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n, n >= 2)\n\n  private\n    c : Z n\n    c = 1\n\n  p x = c + x == x + c\n\nsubmodule F7 = submodule F where\n  type n = 7\n\nf : Integer -> Integer\nf x = x + x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue314.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `f : {a} (fin a, a >= 2) => [a][8] -> [8]` that returns the first element of a zero-initialized array `ys : [a\/2][8]`, as in the given snippet."},{"role":"assistant","content":"```cryptol\nf : {a} (fin a, a>=2) => [a][8] -> [8]\nf xs = ys!0\n where\n  ys : [a\/2][8]\n  ys = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1796.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define properties that prove the functions exhaustive1, exhaustive1Reordered1, exhaustive1Reordered2, exhaustive2, and exhaustive3 are total and that all the reordered exhaustive1 variants are extensionally equal for all type parameters w and inputs x."},{"role":"assistant","content":"```cryptol\nexhaustive1 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1 x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n\nexhaustive1Reordered1: {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1Reordered1 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n\nexhaustive1Reordered2 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1Reordered2 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n\nexhaustive2 : {w} [2 ^^ w] -> [2 ^^ w]\nexhaustive2 x\n  | (2 ^^ w) == 1 => ~ x\n  | (2 ^^ w) > 1 => x\n\nexhaustive3 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive3 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue670.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the custom infix type operator `(+++ )` as `x +++ y = x - y` and write the type signatures and definitions for the constants `g` and `h` so that the expressions `[6 +++ 2 +++ 1]` and `[6 +++ (2 +++ 1)]` type-check correctly."},{"role":"assistant","content":"```cryptol\ntype x +++ y = x-y\n\ng : [6 +++ 2 +++ 1]\ng = 2\n\nh : [6 +++ (2 +++ 1)]\nh = 9\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue116.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the tuple `t` and the property `bug116fixed` that checks `(t.1.value == t.1.value) \/\n(t.1.key == t.1.key)` holds, matching the given structure and field names."},{"role":"assistant","content":"```cryptol\nt = (0x1, { key = 4, value = \"goodbye\"})\n\nbug116fixed = (t.1.value == t.1.value) \/\\ (t.1.key == t.1.key)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `copy : [inf] -> [inf]` as specified, and define the property `ok` asserting that `copy ([True] # zero) @ 0` holds."},{"role":"assistant","content":"```cryptol\ncopy : [inf] -> [inf]\ncopy ([b] # x) = if b then [True] # copy x else [False] # copy x\n\nproperty ok = copy ([True] # zero) @ 0\n```"}]}
{"filename":"cryptol\/tests\/issues\/T1439.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module equivalent to `T` that defines polymorphic functions over 1-element sequences and pairs, an interface submodule with a type parameter `n`, a submodule `F` using that type, a concrete instantiation `P1` with `n = 1`, and a submodule alias `S` importing `F` with `P1`."},{"role":"assistant","content":"```cryptol\nmodule T where\n    f : {n} [1][n] -> [n]\n  f [x] = x\n\n  p : {a,b} (a,b) -> a\n  p (x,_) = x\n\n  interface submodule I where\n    type n : #\n\n  submodule F where\n    import interface submodule I\n\n    h : [1][n] -> [n]\n    h [x] = x\n\n    g : {m} [1][m] -> [m]\n    g [x] = x\n\n    q, q1, q2 : {b} (b,_) -> b\n    q (x,_) = x\n\n    q1 x = x.0\n    q2 x = y\n      where\n      (y,z) = x\n\n  submodule P1 where\n    type n = 1\n\n  submodule S = submodule F { submodule P1 }\n\n  import submodule S\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue058.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions `some : {n} [n] -> Bit`, `last : {n, a} (n >= 1) => [n]a -> a`, and `pad : {n} [n] -> [inf]` with the given semantics, matching these exact types and behaviors."},{"role":"assistant","content":"```cryptol\nsome : {n} [n] -> Bit\nsome x = x != 0\n\nlast : {n, a} (n >= 1) => [n]a -> a\nlast xs = xs ! 0\n\npad : {n} [n] -> [inf]\npad x = x # zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue312.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define functions `f : [16] -> [16]` and `g : [16] -> [16]` as `f x = 3 * x` and `g x = x + x + x`, and a property `f_g` asserting `(f === g)` for all 16-bit inputs."},{"role":"assistant","content":"```cryptol\nf : [16] -> [16]\nf x = 3 * x\n\ng : [16] -> [16]\ng x = x + x + x\n\nproperty f_g = (f === g)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue662.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification defining rational numbers as integer pairs and prove the integer division properties `divRoundsDown`, `divEuclidean`, and `modAbs` as given, ensuring they hold for all integer inputs `x` and `y`."},{"role":"assistant","content":"```cryptol\ntype Q = (Integer, Integer)\n\ntoQ : Integer -> Integer -> Q\ntoQ a b =\n  if b == 0 then error \"divide by 0\" else\n  if b < 0 then (negate a, negate b) else (a, b)\n\nleQ : Q -> Q -> Bit\nleQ (a,b) (c,d) = a*d <= b*c\n\nintToQ : Integer -> Q\nintToQ x = (x, 1)\n\nabs : Integer -> Integer\nabs x = if x < 0 then negate x else x\n\nproperty divRoundsDown (x : Integer) (y : Integer) =\n  y == 0 \\\/ leQ (intToQ ( x \/ y )) (toQ x y)\n\nproperty divEuclidean (x : Integer) (y : Integer) =\n  y == 0 \\\/ y * (x \/ y) + x % y == x\n\nproperty modAbs (x : Integer) (y : Integer) =\n  y == 0 \\\/ abs (x % y) < abs y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue78.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `unique : {a,b} (fin a, fin b, a>=1) => [a][b] -> Bit` that returns True iff all elements in the input sequence are distinct, matching the recursive definition using `exist` as given."},{"role":"assistant","content":"```cryptol\nunique : {a,b} (fin a, fin b, a>=1) => [a][b] -> Bit\nunique xs = [ exist x (i+1) | x <- xs | i <- [0..(a-1)] ] == 0\n  where exist : [b] -> [width a] -> Bit\n        exist x i = if(i>=`a) then False\n                    else if(x==(xs@i)) then True\n                    else exist x (i+1)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue138.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the constants `dwn` and `dwn'` of type `[16][4]` and the function `take_some : {n,k,t} (n >= k) => [n]t -> [k]t` with the same recursive list-comprehension behavior as described, suitable for testing termination and type-checking."},{"role":"assistant","content":"```cryptol\ndwn: [16][4]\ndwn = [ 1+d | d <- tail dwn ] # [0]\n\ndwn': [16][4]\ndwn' = [ 1+(dwn' @ i) | i <- [1 .. 15] ] # [0]\n\ntake_some: {n,k,t} (n>=k) => [n]t -> [k]t\ntake_some xs = takes where takes = [ x | x <- xs | _ <- takes ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue851.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the types, functions, and property shown, and verify that property `problem` holds for all inputs `p`."},{"role":"assistant","content":"```cryptol\ntype base t = { zero: t }\n\nB: base Bool\nB = { zero = False }\n\nfoo: {t,k} (fin k) => base t -> [k]t\nfoo b = repeat b.zero\n\nbar: {t,k} (fin k, k>=1) => [k]t -> [k]t -> [k]t -> [k]t\nbar p q m = p\n\nbaz: {k,t} (fin k, k >= 1) => [k]t -> [k]t -> [k]t\nbaz p q = q\n\nproperty problem p =\n  p != foo B ==> bar p (baz p 0x03) 0x03 == foo B\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1590.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a module hierarchy with a parameterized submodule `F`, a constrained submodule `M = submodule F where x = False`, import `M`, and define `foo : U` where `U` is a type alias for `F::T`, ensuring the `newtype` and import resolution behave as in the code."},{"role":"assistant","content":"```cryptol\nmodule Main where\n\nsubmodule F where\n  parameter\n    x : Bit\n  newtype T = { bit : Bit }\n  type U = T\n\nsubmodule M = submodule F where x = False\n\nimport submodule M\n\nfoo : U\nfoo = T { bit = True }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1802.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the parameterized types `loglogw`, `logw`, `w` and the function `csum : [32][logw] -> [logw+5]` computing `sum [`w - 1 - zext msgi | msgi <- msg]` under the constraint 1 <= loglogw <= 3."},{"role":"assistant","content":"```cryptol\nmodule T1802 where\n\nparameter\n  type loglogw : #\n  type constraint (loglogw >= 1, loglogw <= 3)\n\ntype logw = 2^^loglogw\ntype w = 2^^logw\n\ncsum : [32][logw] -> [logw+5]\ncsum msg = sum [`w - 1 - zext msgi | msgi <- msg]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue962a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the polymorphic functions `f`, `g`, `h`, `i`, and `j` with the given type constraints and expressions, ensuring that type applications and record field selections are correctly typed and accepted by the type checker."},{"role":"assistant","content":"```cryptol\nf : {a, b} (fin a) => [a]b -> (Bit, [a]b)\nf x = (True, x)\n\ng : {a,b} (fin a) => [a]b -> [a]b\ng x = (f`{a=a} x).1\n\nh = f.1\n\ni : {a} (fin a) => [a] -> [a]\ni = f`{a=a}.1\n\nj : {a} (fin a) => [a]{ fld : Integer } -> [a]Integer\nj = f`{a=a,b={fld : Integer}}.1.fld\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue160.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the rotation and shift operations used here and includes properties thm1\u2013thm6 exactly as stated, so they can be checked\/proved by Cryptol\u2019s solvers."},{"role":"assistant","content":"```cryptol\nthm1 : [16] -> Bit\nproperty thm1 x = (x <<< 16 == x) && (x >>> 16 == x)\n\nthm2 : [16] -> [16] -> Bit\nproperty thm2 x i = x >>> i == x >>> (i && 0x000f)\n\nthm3 : [15] -> [8] -> Bit\nproperty thm3 x i = x <<< i == x <<< (i % 15)\n\nthm4 : [15] -> [15] -> Bit\nproperty thm4 x i = x <<< i >>> i == x\n\nthm5 : [15] -> [3] -> Bit\nproperty thm5 x i = x <<< i >>> i == x\n\nthm6 : [8] -> [4] -> [4] -> Bit\nproperty thm6 x i j = x <<< i >>> j == x <<< (i - j)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue148.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that specifies the Salsa20 key expansion function `Salsa20_expansion : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]`, handling both 16-byte and 32-byte keys using the appropriate \"expand 16-byte k\" and \"expand 32-byte k\" constants."},{"role":"assistant","content":"```cryptol\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(k, n) = z\n  where\n    [s0, s1, s2, s3] = if (`a == 2) then split(\"expand 32-byte k\")\n                                    else split(\"expand 16-byte k\")\n    k1 = take`{16}(k#zero)\n    k2 = drop`{16}(zero#k)\n    x = s0 # k1 # s1 # n # s2 # k2 # s3\n    z = x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue389.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the Cryptol function `pad : {n, m, b} (64>=width(n), b==512-((n+65)%512), m==65+n+b) => [n] -> [m]` that appends a '1' bit, zero padding, and a 64-bit length field, and export `test = pad` for testing."},{"role":"assistant","content":"```cryptol\npad : {n, m, b} (64>=width(n), b==512-((n+65)%512), m==65+n+b) => [n]->[m]\npad message = (message#[True])#(0:[b])#sz\n     where\n                sz : [64]\n                sz = length message\n\ntest = pad\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue177.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `issue177` that imports `issue177A`, `issue177B` as `B`, and `issue177C` as `C`, declares `type Byte = [8]`, and defines constants `w : Byte = zero`, `x : Word16 = zero`, `y : B::Word32 = zero`, and `z = C::z`."},{"role":"assistant","content":"```cryptol\nmodule issue177 where\n\nimport issue177A\nimport issue177B as B\nimport issue177C as C\n\ntype Byte = [8]\n\nw : Byte\nw = zero\n\nx : Word16\nx = zero\n\ny : B::Word32\ny = zero\n\nz = C::z\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1744-2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the types Widget = [3], Wombat = [4], Key = [5], the newtype Info with field stuff : Array [5] [6], and the functions once, iter, and process with the same type signatures and behavior as in the given code."},{"role":"assistant","content":"```cryptol\nmodule Bug where\n\nimport Array\n\ntype Widget = [3]\ntype Wombat = [4]\ntype Key = [5]\nnewtype Info = {\n   stuff: Array [5] [6]\n}\n\nonce: Info -> Key -> Widget -> Wombat -> Info\nonce info key widget = info'\n   where\n      info' = Info {\n         stuff = arrayUpdate info.stuff key 0\n      }\n\niter: {n} n < 10 => Info -> Key -> [n] (Widget, Wombat) -> Info\niter info key entries = infos ! 0\n   where\n      infos = [info] # [once info' key widget wombat\n                           | info' <- infos\n                           | (widget, wombat) <- entries]\n\nprocess: {n} n < 10 => Info -> [n] (Widget, Wombat) -> Info\nprocess info entries = iter info 0 entries\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue485a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, recreate a module `issue485a` that defines the private types `A = [8] -> [8]` and `ByteFun t = [8] -> t`, a constant `foo : RoundingMode = 0`, a function `bar : A` returning its input, and `baz : ByteFun (ByteFun [8]) = (+)`."},{"role":"assistant","content":"```cryptol\nmodule issue485a where\n\nimport Float\n\nprivate type A = [8] -> [8]\n\nprivate type ByteFun t = [8] -> t\n\nfoo : RoundingMode\nfoo = 0\n\nbar : A\nbar x = x\n\nbaz : ByteFun (ByteFun [8])\nbaz = (+)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1324.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define records `T = { a: [8] }` and `S = { a: [16] }`, implement `f : T -> ()` as `f _ = ()`, and define `g : S -> ()` by assigning `g = f`, ensuring the specification type-checks correctly."},{"role":"assistant","content":"```cryptol\ntype T = { a: [8] }\ntype S = { a: [16] }\n\nf : T -> ()\nf _ = ()\n\ng : S -> ()\ng = f\n```"}]}
{"filename":"cryptol\/tests\/issues\/trac289.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines five 32-bit integer average functions (average1\u2013average5 and a reference average33) and properties av1\u2013av5 and applesOranges that verify their equivalence for all 32-bit inputs."},{"role":"assistant","content":"```cryptol\naverage33 : [32] -> [32] -> [32]\naverage33 x y = drop`{1}(z'\/2)\n    where\n          z' : [33]\n          z' = (0b0 # x) + (0b0 # y)\n\naverage1 : [32] -> [32] -> [32]\naverage1 x y = (x + y)\/2\n\naverage2 : [32] -> [32] -> [32]\naverage2 x y = x\/2 + y\/2 + (x%2 && y%2)\n\naverage3 : [32] -> [32] -> [32]\naverage3 x y = (x + y) >> 1\n\naverage4 : [32] -> [32] -> [32]\naverage4 x y =    (x >> 1) + (y >> 1) + (x && y && 1)\n\naverage5 : [32] -> [32] -> [32]\naverage5 x y = lo + ((hi - lo)>>1) where\n    lo = min x y\n    hi = max x y\n\nproperty av1 x y = average33 x y == average1 x y\nproperty av2 x y = average33 x y == average2 x y\nproperty av3 x y = average33 x y == average3 x y\nproperty av4 x y = average33 x y == average4 x y\nproperty av5 x y = average33 x y == average5 x y\n\nproperty applesOranges x y = average4 x y == average5 x y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue214.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `bm : {r} (fin r, r >= 1) => [2*r] -> [2*r]` such that `bm B = (B @@ [0,2..2*r-2]) # (B @@ [1,3..2*r-1])`, preserving exactly this type and behavior."},{"role":"assistant","content":"```cryptol\nbm : {r} (fin r, r >= 1) => [2*r] -> [2*r]\nbm B = (B @@ [0,2..2*r-2]) # (B @@ [1,3..2*r-1])\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue614.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the functions `f` and `g` with the given polymorphic types and constraints, where `f : {m, n, k} (n == max 2 m k == m + 1) => [m] -> [k][n]` and `g : {n, k} (fin n, fin k, 0 < n <= k) => [n] -> [k]`."},{"role":"assistant","content":"```cryptol\nf : {m, n, k} (n == max 2 m k == m + 1) => [m] -> [k][n]\nf x = zero\n\ng : {n, k} (fin n, fin k, 0 < n <= k) => [n] -> [k]\ng x = sext x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue416.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the polymorphic functions `f` and `g` with the given constraints and sequence comprehensions, ensuring `f` has type `{n} (fin n, 3 >= width n) => [lengthFromThenTo 1 n 7][3]` and `g` has type `{n} (fin n, 3 >= width n) => [_][3]`."},{"role":"assistant","content":"```cryptol\nf : {n} (fin n, 3 >= width n) => [lengthFromThenTo 1 n 7][3]\nf = [1, n .. 7]\n\ng : {n} (fin n, 3 >= width n) => [_][3]\ng = [1, n .. 7]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue364.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the constant x : [64], the constant x_val : [64], and the properties x_eval, x_distinct, and moderately_bogus_property so they match the given random-based specification and verify that these properties hold."},{"role":"assistant","content":"```cryptol\nx : [64]\nx = random 123\n\nx_val : [64]\nx_val = 0xe4f7c1740def67df\n\nproperty x_eval = x == x_val\nproperty x_distinct = ~ (x == zero)\n\nproperty moderately_bogus_property (seed:[8]) =\n  ~(random (zero#seed) == (0:[64]))\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue826.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `WStep` in Cryptol with polymorphic size parameter `n` (where `fin n` and `n >= 2`), taking a block cipher `CIPHk : [128] -> [128]`, a state `[n][64]`, and a tweak `[64]`, and returning the updated state `[n][64]` as in the given transformation."},{"role":"assistant","content":"```cryptol\nWStep:\n    {n}\n    (fin n, n >= 2) ->\n    ([128] -> [128]) -> [n][64] -> [64] -> [n][64]\nWStep CIPHk ([A] # Rs) t = [A'] # Rs'\n  where\n    [MSB, LSB] = split (CIPHk (A # head Rs))\n    A'         = MSB ^ t\n    Rs'        = tail Rs # [LSB]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue212.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the functions `width_eq_geq`, `can_not_width`, and `take_knows_no_bounds` with the given polymorphic type constraints, ensuring the width constraints are respected and the definitions type-check correctly."},{"role":"assistant","content":"```cryptol\nwidth_eq_geq : {n} (32 == width n, n >= 1) => [n]Bit\nwidth_eq_geq = [True | _ <- [1..n] : [_][32] ]\n\ncan_not_width : {n} (64 >= width (8*(n+1))) => [64]\ncan_not_width = zero # (`n : [width n])\n\ntake_knows_no_bounds : {n} (fin n, n >= 4) => [n][8] -> [4 - (n%4)][8]\ntake_knows_no_bounds ns = foo\n where\n foo = take `{4 - (n%4)} ns\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1024b.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the type synonym constraint `PredSyn (a : *) (p : Prop) = (Zero a, Cmp a, p)` and the function `someFunc : {a} (PredSyn a (Logic a)) => a` with definition `someFunc = ~zero` exactly as specified."},{"role":"assistant","content":"```cryptol\ntype constraint PredSyn (a : *) (p:Prop) = (Zero a, Cmp a, p)\n\nsomeFunc : {a} (PredSyn a (Logic a)) => a\nsomeFunc = ~zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/T1440.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module T1440 that declares interface and non-interface submodules (X, Y, I, M, N, M1, M2) with the same structure as described, ensuring correct use of `import interface submodule` and submodule instantiation syntax."},{"role":"assistant","content":"```cryptol\nmodule T1440 where\n\nimport interface submodule X\n\nimport submodule Y\n\ninterface submodule I where\n  type n : #\n\nsubmodule M where\n  import interface submodule I\n\nsubmodule N where\n  x = 2\n\nsubmodule M1 = submodule M { submodule U1 }\nsubmodule M2 = submodule U2 { submodule N }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue368.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module that declares the function `myFun : [8] -> [8] -> [8]` returning 0 and introduces infix operator aliases (e.g., `+`, `*`, `-`, `~`, `^^`, `++`, `.+`, `+.`) all equal to `myFun`, ensuring the syntax is valid and type-correct."},{"role":"assistant","content":"```cryptol\nmyFun : [8] -> [8] -> [8]\nmyFun a b = 0\n\nx + y = myFun x y\nx * y = myFun x y\nx - y = myFun x y\nx ~ y = myFun x y\nx ^^ y = myFun x y\nx ++ y = myFun x y\nx .+ y = myFun x y\nx +. y = myFun x y\nx !+ y = myFun x y\nx +! y = myFun x y\nx .! y = myFun x y\nx :+ y = myFun x y\nx =+ y = myFun x y\nx .: y = myFun x y\nx :+: y = myFun x y\nx +:: y = myFun x y\nx ^^^ y = myFun x y\nx .... y = myFun x y\nx +x .\n```"}]}
{"filename":"cryptol\/tests\/issues\/T146.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the functions `mk_curve_ops`, `ec_v1`, and `ec_v2` with appropriate types so that `mk_curve_ops` constructs a record `c` with a `field` component `f` and components `v1` and `v2` derived from `ec_v1` and `ec_v2` without causing recursive type or record definition issues."},{"role":"assistant","content":"```cryptol\nmk_curve_ops f = undefined\n  where\n    c = { field = f\n        , v1    = ec_v1 f\n        , v2    = ec_v2 c\n        }\n\nec_v1 : {fv} { v0: fv } -> fv\nec_v1 = undefined\n\nec_v2 : {fv} _ -> fv\nec_v2 p = p.field.v0\n  where _ = p.field.v0\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1024a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the type synonyms `Funny` and `Strange` as given, and the polymorphic function `funnyFunc : { i : #, f : # -> *, g : * } Integer` with value `zero` in a Cryptol module."},{"role":"assistant","content":"```cryptol\ntype Funny (f : # -> *) = Integer\ntype Strange (f : Prop) = Integer\n\nfunnyFunc : { i : #, f : # -> *, g : * } Integer\nfunnyFunc = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue225.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `EnigmaBroke` that models an Enigma-style rotor machine, including the types `Rotor`, functions `mkRotor`, `scramble`, and `joinRotors`, with `scramble` and `mkRotor` fully specified so that `joinRotors` correctly processes a character through a sequence of rotors."},{"role":"assistant","content":"```cryptol\nmodule EnigmaBroke where\n\ntype Rotor       = [26](Char, Bit)\n\nmkRotor : {a} (fin a) => ([26]Char,[a]) -> Rotor\nmkRotor (_,_) = zero\n\nscramble : (Bit, Char, Rotor) -> (Bit, Char, Rotor)\nscramble (_,_,_) = zero\n\njoinRotors : {n} (fin n) => ([n]Rotor, Char) -> ([n]Rotor, Char)\njoinRotors (rotors, inputChar) = (rotors', outputChar)\n  where\n    initRotor = mkRotor (['A' .. 'Z'], [])\n    \/\/ ncrs : [n+1](Bit, [8], Rotor)\n    ncrs = [(True, inputChar, initRotor)]\n               # [ scramble (notch, char, r)\n                 | r <- rotors\n                 | (notch, char, rotor') <- ncrs\n                 ]\n    rotors' = tail [ r | (_, _, r) <- ncrs ]\n    (_, outputChar, _) = ncrs ! 0\n```"}]}
{"filename":"cryptol\/tests\/issues\/Issue796.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Issue796` parameterized by a numeric type `_k` that declares types `Key = [8 * _k]`, `Block = [64]`, `RoundKey = [64]`, and implements `aux`, `key_schedule`, and `encrypt_block` consistent with this interface, including use of `groupBy` in `key_schedule`."},{"role":"assistant","content":"```cryptol\nmodule Issue796 = Issue796_Sig where\n\nparameter\n  type _k: #\n\ntype Key = [8 * _k]\ntype Block = [64]\ntype RoundKey = [64]\n\naux : RoundKey -> Block -> Block\naux RK P = zero\n\nkey_schedule K = zero\n  where\n    _ = [ groupBy`{4} K ]\n\nencrypt_block key pt = aux (key_schedule key) pt\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue581.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions `foo` and `bar` with the given polymorphic signatures using `(\/^ )` and `(%^)` size operators and `take`, ensuring the types `[i \/^ j][32]` and `[i %^ j][32]` are well-formed under constraints `fin i`, `fin j`, and `j >= 1`."},{"role":"assistant","content":"```cryptol\nfoo : {i, j} (fin i, fin j, j >= 1) => [i \/^ j][32]\nfoo = take [0...]\n\nbar : {i, j} (fin i, fin j, j >= 1) => [i %^ j][32]\nbar = take [0...]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue185.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `group : {perGroup,a,b,c} (fin perGroup, c == perGroup * a) => [c]b -> [a][perGroup]b` using `split` to partition an input sequence into `a` groups of length `perGroup`."},{"role":"assistant","content":"```cryptol\ngroup : {perGroup, a, b, c} (fin perGroup, c == perGroup * a)\n    => [c]b -> [a][perGroup]b\ngroup xs = split`{each=perGroup}xs\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue187.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `enigmaLoop : {n} (fin n) => [n]` and verify that `enigma : {n, m} (fin n, fin m) => ([n], [m]) -> [m]` typechecks and behaves consistently with the recursive construction of `rcs` shown, using `tail [ True | _ <- rcs ]` as specified."},{"role":"assistant","content":"```cryptol\nmodule Enigma where\n\nenigmaLoop : {n}(fin n) => [n]\nenigmaLoop = undefined\n\nenigma : {n, m} (fin n, fin m) => ([n], [m]) -> [m]\nenigma (m, pt) = tail [ True | _ <- rcs ]\n  where rcs = [ (m, True)] #\n              [ (enigmaLoop, True)\n              | _     <- pt\n              | (_,_) <- rcs\n              ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1511.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `M` with a 1-bit newtype `MOOD_t`, a record `MOOD` containing `HAPPY` and `SAD` constructors with values 0b1 and 0b0, and a constant `v : [1]` equal to `MOOD.SAD.value`."},{"role":"assistant","content":"```cryptol\nmodule M where\n\nv: [1]\nv = MOOD.SAD.value\n\nnewtype MOOD_t = { value: [1] }\n\nMOOD = { HAPPY = MOOD_t { value = 0b1 }\n       , SAD   = MOOD_t { value = 0b0 }\n       }\n```"}]}
{"filename":"cryptol\/tests\/issues\/trac133.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the polymorphic functions `example1` and `example2` with type `{a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8]` such that `example1 k = drop`{16} ((zero : [16*(2 - a)][8]) # k)` and `example2 k = drop`{16} (zero # k)`."},{"role":"assistant","content":"```cryptol\nexample1 : {a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8]\nexample1 k = drop`{16} ((zero : [16*(2 - a)][8]) #k)\n\nexample2 : {a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8]\nexample2 k = drop`{16} (zero # k)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue877.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the list `xs : [_] Integer = [1,2,3]` and verify that the expressions `xs @@ []`, `xs @@ (map trunc [])`, and `xs @@ (map (\\x -> [x]) [])` all typecheck and are well-formed."},{"role":"assistant","content":"```cryptol\na = []\n\nxs : [_] Integer\nxs = [1,2,3]\n\nb = xs @@ []\nc = xs @@ (map trunc [])\nd = xs @@ (map (\\x -> [x]) [])\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue_1812.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the polymorphic functions f, g, ff, gg, jj, and kk with the given parametric size expressions in their types, ensuring all arithmetic on sequence lengths is well-typed under the fin h constraint and any necessary numeric constraints."},{"role":"assistant","content":"```cryptol\nf : {h} (fin h) => [2^^h + (2^^h - 2^^h)]\nf = g`{h}\n\ng : {h} (fin h) => [2^^h]\ng = zero\n\nff : {h} (fin h) => [(2^^h + 2^^h) - 2^^h]\nff = gg`{h}\n\ngg : {h} (fin h) => [2^^h]\ngg = zero\n\njj : {h} (fin h) => [2 ^^ (1 + h) - 1]\njj = kk`{h}\n\nkk : {h} (fin h, 2 ^^ (1 + h) - 1 >= 2 ^^ h - 1) => [2 ^^ h - 1 + 2 ^^ h]\nkk = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue268.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the infinite stream `zs : [inf]([8],[8])` recursively as shown and the finite sequences `xs` and `vs` of length 10 using `take` and list comprehensions with self-referential `zs`, matching the given definitions exactly."},{"role":"assistant","content":"```cryptol\nxs : [10]([8],[8])\nxs = take `{10} zs\n  where\n  zs : [inf]([8],[8])\n  zs = [(0,0)] # [ (0, z) | (z,_) <- drop `{1} zs]\n\nvs : [10]([8],[8])\nvs = take `{10} zs where zs = [ (0, z) | (z,_) <- zs]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue731.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the type constraints `T`, `Both`, `Fin2`, and `(<=>)` exactly as in the description, preserving their intended meanings and relationships between numeric type variables."},{"role":"assistant","content":"```cryptol\nmodule issue731 where\n\ntype constraint T n = (fin n, n >= 1)\n\ntype constraint Both p q = (p, q)\n\ntype constraint Fin2 i j = Both (fin i) (fin j)\n\ntype constraint i <=> j = (i <= j, i >= j)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1562.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the given submodule interface `I` with type `Zp = [8]`, imports it in submodule `F`, defines submodule `M` with type `Empty = Bit`, and creates submodules `F1` and `F2` as `F { submodule M }` instances."},{"role":"assistant","content":"```cryptol\ninterface submodule I where\n  type Zp = [8]\n\nsubmodule F where\n  import interface submodule I\n\nsubmodule M where\n      type Empty = Bit\n\nsubmodule F1 = submodule F { submodule M }\nsubmodule F2 = submodule F { submodule M }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1210.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the functions and properties `mwe`, `mwe'`, `mwe''`, and `bitget` exactly as specified, ensuring they type-check and can be checked by Cryptol\u2019s property checking tools."},{"role":"assistant","content":"```cryptol\nmwe : [2] -> [2][1] -> Bit\nproperty mwe i r = r@0 == (r@0) << 0*i\n\nmwe' : [2] -> [1] -> Bit\nproperty mwe' i r = r == (r << 0*i)\n\nmwe'' : Bit\nproperty mwe'' = r == (r << i)\n where r = 1:[1]\n       i = 0:[2]\n\nbitget : [12] -> [436][8] -> Bit\nproperty bitget i r = i < 3488 ==> bit_gf == if bit_bit then 0x0001 else 0x0000\n  where bit_gf = (zext (((r@(i\/8)) >> (i%8) ) && 1))\n        bit_bit = (join (map reverse r))@i\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue108.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `sum : {a,b} (fin a, fin b) => [a][b] -> [b]` using the prefix-scan style definition with a self-referential sequence `ss = [0] # [ s + x | x <- xs | s <- ss ]` and `sum xs = ss ! 0`."},{"role":"assistant","content":"```cryptol\nsum : {a,b} (fin a, fin b) => [a][b] -> [b]\nsum xs = ss ! 0\n  where\n    ss = [0] # [ s + x | x <- xs | s <- ss ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue130.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions parity, foldl1, par, and the property parOK : {n} (fin n) => [n+1] -> Bit, where parOK asserts par x == parity x for all inputs x."},{"role":"assistant","content":"```cryptol\nparity xs = ys!0\n  where ys = [False] # [y ^ x | x <- xs | y <- ys ]\n\nfoldl1 f xs = ys!0\n  where ys = [xs@0] # [ f y x | y <- ys | x <- tail xs ]\n\npar = foldl1 (^)\n\nparOK : {n} (fin n) => [n+1] -> Bit\nproperty parOK x = par x == parity x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1798.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the polymorphic functions exhaustive1 and exhaustive2 with the given types and guarded definitions, ensuring the guards are exhaustive and type-correct for all widths w."},{"role":"assistant","content":"```cryptol\nexhaustive1 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1 x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n\nexhaustive2 : {w} [2 ^^ w] -> [2 ^^ w]\nexhaustive2 x\n  | (2 ^^ w) == 1 => ~ x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue093.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the given properties `t0`, `t1`, `t2`, `f0`, and the non-property `not_a_prop`, preserving their exact meanings and types so that only the `property`-prefixed names are treated as properties."},{"role":"assistant","content":"```cryptol\nproperty t0 = True\nproperty t1 x = x == (x : [32])\nproperty t2 x y = if (x : [32]) < (y : [32]) then y != zero else True\nnot_a_prop = True\nproperty f0 = False\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue723.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions `f` and `g` with the given polymorphic types, where `f x = g x` and `g m0 = m0 ^ m1` using the captured outer variable `m1 = x`, preserving the scoping and type constraints."},{"role":"assistant","content":"```cryptol\nf : {n} (fin n) => [n] -> [n]\nf x = g x\n  where\n    m1 = x\n\n    g : {k} (fin k) => [k] -> [k]\n    g m0 = m0 ^ m1\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue494.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions `gt_words` and `gt_words'` with type `{a} (fin a) => [a][32] -> [a][32] -> Bit` that compute whether the first word-vector is greater than the second using the given recursive list-comprehension pattern."},{"role":"assistant","content":"```cryptol\ngt_words : {a} (fin a) => [a][32] -> [a][32] -> Bit\ngt_words l0 l1 = ss!0\n  where\n    ss = [ False ] # [ s \\\/ (i > j) | i <- l0 | j <- l1 | s <- ss ]\n\ngt_words' l0 l1 = ss!0\n  where\n    ss = [ False ] # [ s \\\/ (i > j) | i <- l0 | j <- l1 | s <- ss ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue734.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module defining the functions and constants `f`, `asdf1`, and `asdf2` with the given polymorphic type constraints and bit-width equalities, matching the specified types and behaviors exactly."},{"role":"assistant","content":"```cryptol\nf : {a} (fin a) => [2^^a - 1] -> [3*(2^^a - 1)]\nf x = x # x # x\n\nasdf1 : {r} (fin r, width (2^^r)==r+1) => [r+1]\nasdf1 = `(2^^r)\n\nasdf2 : {r} (fin r, width(2^^r-1)==r) => [r]\nasdf2 = `(2^^r-1)\n```"}]}
{"filename":"cryptol\/tests\/issues\/Issue883_A.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, write a module `Issue883_A` that defines a type parameter `c` with constraint `(fin c, c >= 1, 64 >= width (c-1))`, a function `dumbHash : {n} (fin n, 64 >= width n) => [n] -> [128]`, and a function `asdf : {n} (64 >= width (n+192), 64 >= width (128 * c), fin n) => [n] -> [128]` implemented as `dumbHash (join (drop`{1} ys))` where `ys : [c+1][128]` is `zero`."},{"role":"assistant","content":"```cryptol\nmodule Issue883_A where\nparameter\n    type c : #\n    type constraint ( fin c, c >= 1, 64 >= width (c-1) )\n\ndumbHash : {n} (fin n, 64 >= width n) => [n] -> [128]\ndumbHash msg = zero\n\nasdf : {n} (64 >= width (n+192), 64 >= width (128 * c), fin n) => [n] -> [128]\nasdf msg = dumbHash (join (drop`{1} ys))\n where\n   ys : [c+1][128]\n   ys = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue640.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions `f`, `g`, and `h` with the given types so that each uses a recursively defined `out` where `out` is built from its input and `out` (or `take out`) as in the snippet, preserving the original recursive structure."},{"role":"assistant","content":"```cryptol\nf : [1] -> [2]\nf x = out\n  where out = x # [out@0]\n\ng : [1] -> [2]\ng x = out\n  where out = x # (take out)\n\nh : [1] [8] -> [2] [8]\nh x = out\n  where out = x # take out\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/mergesort.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of a mergesort algorithm with functions `sort` and `merge` as given, and a property `sort_correct` that checks `sort` returns the expected sorted results on the listed concrete test vectors."},{"role":"assistant","content":"```cryptol\nsort : {n,a} Cmp a => (fin n) => [n]a -> [n]a\nsort xs\n  | n <= 1 => xs\n  | ()     => merge (sort left) (sort right)\n              where (left : [n\/2] _) # right = xs\n\nmerge : {m,n,a} Cmp a => [m]a -> [n]a -> [m+n]a\nmerge xs ys\n  | m == 0  => ys\n  | n == 0  => xs\n  | (m > 0, n > 0) => if x <= y \n                        then [x] # merge restX ys\n                        else [y] # merge xs restY\n                      where\n                      [x] # restX = xs\n                      [y] # restY = ys\n\nproperty sort_correct =\n  (sort [] == []) &&\n  (sort [0] == [0]) &&\n  (sort [-6, 1, 9, -3, -9, 2, 4] == [-9, -6, -3, 1, 2, 4, 9]) &&\n  (sort [4, -8, -1, -7, -5, 9, 8, 8] == [-8, -7, -5, -1, 4, 8, 8, 9]) &&\n  (sort [1, -1, -2, -3, -2, 7, 5] == [-3, -2, -2, -1, 1, 5, 7]) &&\n  (sort [9, 9, 8, -3, 1, 1, -6, -6, -8] == [-8, -6, -6, -3, 1, 1, 8, 9, 9]) &&\n  (sort [9, 1, 5, 0] == [0, 1, 5, 9]) &&\n  (sort [8, 3, 3] == [3, 3, 8]) &&\n  (sort [-7, 8] == [-7, 8])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/nestFun.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines submodule `A` with a numeric type parameter `n`, function `f : Bool` guarded by `n == 0` and `n > 0`, and imports `A` twice as `Two` (with `type n = 2`) and `Zero` (with `type n = 0`)."},{"role":"assistant","content":"```cryptol\nsubmodule A where\n\n  parameter\n    type n : #\n\n  f : Bool\n  f | n == 0 => True\n    | n > 0  => False\n\nimport submodule A as Two where\n  type n = 2\n\nimport submodule A as Zero where\n  type n = 0\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/constant.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the functions isZero, isFin, and idTypeNum using constraint guards on the type parameter n, and includes properties isZero_correct, isFin_correct, and idTypeNum_correct that verify their expected behavior for finite and infinite type sizes."},{"role":"assistant","content":"```cryptol\nisZero : {n : #} Bit\nisZero | n == 0 => True\n       | ()     => False\n\nproperty isZero_correct =\n  ~isZero `{inf} &&\n   isZero `{  0}   &&\n  ~isZero `{  1}   &&\n  ~isZero `{  2}   &&\n  ~isZero `{  4}   &&\n  ~isZero `{  8}   &&\n  ~isZero `{ 16}\n\nisFin : {n : #} Bit\nisFin | fin n => True\n      | ()    => False\n\nproperty isFin_correct =\n  ~isFin `{inf} &&\n   isFin `{  0}   &&\n   isFin `{  1}   &&\n   isFin `{  2}   &&\n   isFin `{  4}   &&\n   isFin `{  8}   &&\n   isFin `{ 16}\n\nidTypeNum : {n : #} Integer \nidTypeNum | fin n => `n\n\nproperty idTypeNum_correct =\n  (idTypeNum `{ 0}  ==  0) &&\n  (idTypeNum `{ 1}  ==  1) &&\n  (idTypeNum `{ 2}  ==  2) &&\n  (idTypeNum `{ 4}  ==  4) &&\n  (idTypeNum `{ 8}  ==  8) &&\n  (idTypeNum `{16}  == 16)\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/insert.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the function `insert : {n, a} (fin n, Cmp a) => a -> [n]a -> [n+1]a` inserting an element into a sorted sequence, and the property `insert_correct` that checks the given example insertions yield `[0,1,2,3,4,5,6,7,8,9]`."},{"role":"assistant","content":"```cryptol\ninsert : {n, a} (fin n, Cmp a) => a -> [n]a -> [n+1]a\ninsert x' xs \n  | n == 0         => [x']\n  | n == 1         => if x' <= x then [x', x] else [x, x']\n                      where [x] = xs\n  | ( n % 2 == 0\n    , n     >  1 ) => if x' <= x \n                        then insert x' (xs1 # [x]) # xs2 \n                        else xs1 # [x] # insert x' xs2\n                      where (xs1 : [n\/2 - 1]_) # [x] # (xs2 : [n\/2]_) = xs\n  | ( n % 2 == 1\n    , n     >  1 ) => if x' <= x \n                        then insert x' (xs1 # [x]) # xs2\n                        else xs1 # [x] # insert x' xs2\n                      where (xs1 : [n\/2]_) # [x] # (xs2 : [n\/2]_) = xs\n\nproperty insert_correct =\n  (insert 0 [  1,2,3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 1 [0,  2,3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 2 [0,1,  3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 3 [0,1,2,  4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 4 [0,1,2,3,  5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 5 [0,1,2,3,4,  6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 6 [0,1,2,3,4,5,  7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 7 [0,1,2,3,4,5,6,  8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 8 [0,1,2,3,4,5,6,7,  9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 9 [0,1,2,3,4,5,6,7,8  ] == [0,1,2,3,4,5,6,7,8,9])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/len.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a recursive function len : {n,a} (fin n) => [n] a -> Integer using constraint guards to compute a list\u2019s length, and a property len_correct that checks len equals Cryptol\u2019s built-in length for several concrete example lists."},{"role":"assistant","content":"```cryptol\nlen : {n,a} (fin n) => [n] a -> Integer\nlen x\n  | (n == 0) => 0\n  | (n >  0) => 1 + len (drop`{1} x)\n\nproperty \n  len_correct = and\n    [ len l == length l where l = []\n    , len l == length l where l = [1]\n    , len l == length l where l = [1,2]\n    , len l == length l where l = [1,2,3]\n    , len l == length l where l = [1,2,3,4,5]\n    , len l == length l where l = [1,2,3,4,5,6]\n    , len l == length l where l = [1,2,3,4,5,6,7]\n    , len l == length l where l = [1,2,3,4,5,6,7,8]\n    ]\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/tail.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `tail : {n, a} (fin n) => [n]a -> [(max n 1) - 1]a` with guarded equations for the `n == 0` and `n >= 1` cases, and the property `tail_correct` capturing the listed test cases."},{"role":"assistant","content":"```cryptol\ntail : {n, a} (fin n) => [n]a -> [(max n 1) - 1]a\ntail xs | n == 0 => xs\n        | n >= 1 => drop `{1} xs\n\nproperty tail_correct =\n  (tail [] == []) &&\n  (tail [1] == []) &&\n  (tail [1,2] == [2]) &&\n  (tail [1,2,3] == [2,3]) &&\n  (tail [1,2,3,4] == [2,3,4])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/inits.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions inits and initsLoop as given, and a property inits_correct that checks inits produces the concatenation of all non-empty prefixes for several example lists."},{"role":"assistant","content":"```cryptol\ninits : {n, a} (fin n) => [n]a -> [(n * (n+1))\/2]a\ninits xs\n  | n == 0 => []\n  | n >  0 => initsLoop xs' x []\n    where\n      (x : [1]_) # xs' = xs\n\ninitsLoop : {n, l, m, a} (fin l, fin m, l + m == n, m >= 1) =>\n        [l]a -> [m]a ->\n        [((m-1) * ((m-1)+1))\/2]a ->\n        [(n * (n+1))\/2]a\ninitsLoop ys zs acc\n  | l == 0 => acc # zs\n  | l >  0 => initsLoop ys' (zs # y) (acc # zs)\n   where (y : [1]_) # ys' = ys\n\nproperty inits_correct =\n  (inits [] == []) &&\n  (inits [1] == [1]) &&\n  (inits [1,2] == [1,1,2]) &&\n  (inits [1,2,3] == [1,1,2,1,2,3]) &&\n  (inits [1,2,3,4] == [1,1,2,1,2,3,1,2,3,4]) &&\n  (inits [1,2,3,4,5] == [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5])\n```"}]}
{"filename":"cryptol\/tests\/modsys\/T11\/A.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the module `T11::A` parameterized by types `X` and `Y`, introduce the type synonym `T = ([X],[Y])`, and implement the function `f : T -> [X]` that returns the first component of a `T` pair."},{"role":"assistant","content":"```cryptol\nmodule T11::A where\n\nparameter\n  type X : #\n  type Y : #\n\ntype T = ([X],[Y])\n\nf : T -> [X]\nf (x,_) = x\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T038.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that reproduces the submodule\/interface structure of T038, including interfaces I and J, submodules F, P, Q, their imports, and the definition y = x + 1, with x and y having appropriate 8-bit types."},{"role":"assistant","content":"```cryptol\nmodule T038 where\n\ninterface submodule I where\n  x : [8]\n\nsubmodule F where\n  import interface submodule I\n  y = x + 1\n\nsubmodule P where\n  import submodule F { submodule Q }\n  x = 11\n\nsubmodule Q where\n  x = 11\n\ninterface submodule J where\n  import submodule F { submodule P }\n  x : [8]\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T011.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that mirrors the given submodule\/interface structure (A, S, F, I, M), where type T = [8], S exposes x:T, F defines y=2*x, I provides x=28, and M is F instantiated with I, then import M as M."},{"role":"assistant","content":"```cryptol\nsubmodule A where\n  type T = [8]\n\ninterface submodule S where\n  import submodule A\n  x : T\n\nsubmodule F where\n  import interface submodule S\n\n  y = 2 * x\n\nsubmodule I where\n  x = 28\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T005.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines functor-style submodules A, F, I, J, and M as in the description, and include a property that demonstrates the interface constraint (X::n == Y::n) fails for M when instantiated with I (n=8) and J (n=9)."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A as X\n  import interface submodule A as Y\n\n  interface constraint (X::n == Y::n)\n\n  y : [X::n]\n  y = X::x + Y::x\n\nsubmodule I where\n  type n = 8\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule J where\n  type n = 9\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule M = submodule F { X = submodule I, Y = submodule J }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T006.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines these submodules, interfaces, and constraints (A, F, G, I, M, N) using functor-style submodule instantiation, ensuring that type constraints (e.g., X::n >= 3, X::n == n) and expressions for x and y are correctly typed and well-formed."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A as X\n\n  interface constraint (X::n >= 3)\n\n  submodule G where\n    import interface submodule A\n    interface constraint (X::n == n)\n\n    y : [n]\n    y = 5 * X::x + x\n\n  y : [X::n]\n  y = 5 * X::x\n\nsubmodule I where\n  type n = 8\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n\nsubmodule N = submodule M::G { submodule I }\n\nimport submodule N as N\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T012.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines interface submodule S with type T and value x, submodule F importing S and defining y = 2 * x, submodule I defining x = 28, and submodule M as submodule F instantiated with I, then import M as M."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  import T012_M\n  x : T\n\nsubmodule F where\n  import interface submodule S\n\n  y = 2 * x\n\nsubmodule I where\n  x = 28\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T002.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines interface submodule A with parameter n and x:[n], functor submodule F depending on A with y = 1 + x, instance submodule I with n = 8 and x = 2:[n], and submodule M = F{I}, then imports M as M."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 8\n  x = 2 : [n]\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T003.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that uses submodule functors and interfaces to instantiate submodule F with implementation I, where type n = 8 and x is a literal 42, and export the resulting submodule M with value y = 1 + x."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 8\n\n  x : {a} Literal 42 a => a\n  x = 42\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T001.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module using submodule functors that matches this structure: an interface submodule A with a numeric type n and value x:[n], a functor submodule F importing A and defining y = 1 + x, an implementation I fixing n=0 and x:[n], and a submodule M = F{I}."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 0\n  x = x : [n]\n\nsubmodule M = submodule F { submodule I }\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T028.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines interfaces and submodules S, G, and F as in the code, wires the imports correctly, and exposes a top-level binding x = 5 and derived values y = x + 1 and z = x + y."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  x : [8]\n\nsubmodule G where\n  import interface submodule S\n  y = x + 1\n\nsubmodule F where\n  import interface submodule S\n  import submodule G { interface S }\n  z = x + y\n\nimport submodule F where\n  x = 5\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T027.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the submodules S, G, F, and H using interface imports and submodule parameters as in the code, ensuring that name resolution and interface sharing work so that z = A::x + y type-checks correctly and the final imports of F and H override x appropriately."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  x : [8]\n\nsubmodule G where\n  import interface submodule S\n  y = x + 1\n\nsubmodule F where\n  import interface submodule S as A\n\n  submodule H where\n    import interface submodule S as A\n    import submodule G { interface A }\n    z = A::x + y\n\nimport submodule F where\n  x = 5\n\nimport submodule H where\n  x = 6\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T037.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module equivalent to T037 that defines interface submodule I with x:[8], functor submodule F importing I and defining y = x + 1, submodule P with x = 11, submodule X instantiating F with P, and exports z = y from X."},{"role":"assistant","content":"```cryptol\nmodule T037 where\n\ninterface submodule I where\n  x : [8]\n\nsubmodule F where\n  import interface submodule I\n  y = x + 1\n\nsubmodule P where\n  x = 11\n\nsubmodule X where\n  submodule M = submodule F { submodule P }\n  import submodule M\n\n  z = y\n\nimport submodule X\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T012_M.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the type synonym `T` as an 8-bit wide sequence (`[8]`) in a Cryptol module named `T012_M`."},{"role":"assistant","content":"```cryptol\nmodule T012_M where\n\ntype T = [8]\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T022.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines an interface submodule `S` with a finite size type parameter `n` and value `x : [n]`, a submodule `F` that imports `S` as `A` and defines `z = A::x + A::x`, and then instantiates `F` with `n = 8` and `x = 2`."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  type n : #\n  type constraint (fin n)\n  x : [n]\n\nsubmodule F where\n  import interface submodule S as A\n\n  z = A::x + A::x\n\nimport submodule F where\n  type n = 8\n  x = 2\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T008.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a module using a submodule parameterized by a type `n` with constraints `fin n` and `n >= 2`, set a value `x : [n] = 2`, then instantiate it with `n = 2` as submodule `M` and import it as `M`."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n, n >= 2)\n\n  x : [n]\n  x = 2\n\nsubmodule M = submodule F where\n  type n = 2\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T035.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines submodules with parameterized types and newtypes, instantiates the same functor-like submodule twice, imports both instances, and defines a value using a function from one instance applied to a value from the other, matching the structure described."},{"role":"assistant","content":"```cryptol\nsubmodule A where\n  newtype T = { x : Integer }\n\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n)\n\n  newtype X = { x : [n] }\n  f : X -> X\n  f x = x\n\nsubmodule M = submodule F { _ }\nsubmodule N = submodule F { _ }\n\nimport submodule M as M\nimport submodule N as N\n\nx = M::f (N::X { x = 0 })\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T040.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines a submodule `F` parameterized by a type `T`, introduces a `newtype NT = { field : T -> () }` with a value `nt`, imports `F` with `T = [32]`, and defines `x = nt.field 10`."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type T : *\n\n  newtype NT = { field : T -> () }\n\n  nt : NT\n  nt = NT { field = \\_ -> () }\n\nimport submodule F where\n  type T = [32]\n\nx = nt.field 10\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/ffi-type-errors.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that declares the given foreign imports and adds appropriate type-correctness properties (or comments) that capture why each of these FFI declarations is ill-typed or invalid under Cryptol\u2019s C calling convention rules."},{"role":"assistant","content":"```cryptol\nimport Float\n\nforeign badWordSizes : [65] -> [128]\nforeign badFloatSizes : Float16 -> Float128\nforeign badArrayTypes : {n} (fin n) =>\n  [n]Bit -> [n]([16], [16]) -> [n][4][8]{a : [n], b : [2]}\nforeign notFunction : [32]\nforeign badKind : {t} t -> [32]\nforeign noFin : {n} [n][32] -> [n * 2][32]\nforeign infSeq : [inf][32] -> Bit\nforeign wildcard : { x : [8], y : Float32 } -> _\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/ffi-fallback.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module that declares and, where present, implements the four foreign functions `foreignAndCryptol`, `foreignAndNoCryptol`, `noForeignAndCryptol`, and `noForeignAndNoCryptol`, each with type `[8] -> [8]`, matching the given bodies for the two defined functions and leaving the others foreign-only."},{"role":"assistant","content":"```cryptol\nforeign foreignAndCryptol : [8] -> [8]\nforeignAndCryptol x = x\n\nforeign foreignAndNoCryptol : [8] -> [8]\n\nforeign noForeignAndCryptol : [8] -> [8]\nnoForeignAndCryptol x = x + 3\n\nforeign noForeignAndNoCryptol : [8] -> [8]\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/test-ffi.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that declares the same set of `foreign` functions and types as this FFI calling-convention test (integer, word, float, rational, sequence, polymorphic, and submodule `A` signatures) so they can be linked to external C implementations."},{"role":"assistant","content":"```cryptol\nimport Float\n\nforeign add8 : [8] -> [8] -> [8]\nforeign sub16 : [16] -> [16] -> [16]\nforeign mul32 : [32] -> [32] -> [32]\nforeign div64 : [64] -> [64] -> [64]\n\nforeign extendInput : [3] -> [8]\nforeign maskOutput : [8] -> [3]\nforeign noBits : [0] -> [0]\n\nforeign not : Bit -> Bit\n\nforeign addFloat32 : Float32 -> Float32 -> Float32\nforeign subFloat64 : Float64 -> Float64 -> Float64\nforeign specialFloats : [2] -> Float32\n\ntype Word32 = [32]\ntype MyFunc = Word32 -> Float32 -> Bit\nforeign usesTypeSynonym : MyFunc\n\nforeign sum10 : [10]Word32 -> Word32\nforeign reverse5 : [5]Float64 -> [5]Float64\n\nforeign compoundTypes : ([32], { x : [10], y : [3][20] }) -> { z : [5][20] }\n  -> { a : ([16], [16]), b : { c : [8][20], d : [5], e : [5] } }\n\nforeign typeToValue : {n} (fin n) => () -> [64]\nforeign sumPoly : {n} (fin n) => [n]Word32 -> Word32\nforeign inits : {n} (fin n) => [n][8] -> [n * (n + 1) \/ 2][8]\nforeign zipMul3 : {n, m, p} (fin n, fin m, fin p) =>\n  [n]Float32 -> [m]Float32 -> [p]Float32 -> [min n (min m p)]Float32\n\nforeign nestedSeq : {n, m, p} (fin n, fin m, fin p, n * m * p == 4 * 3 * 2) =>\n  [n][m][p][8] -> [4][3][2][8]\n\nforeign i2Q   : Integer -> Rational\nforeign i2Qs  : Integer -> [2]Rational\nforeign iQ2Qi : (Integer,Rational) -> (Rational,Integer)\nforeign i2Z5  : Integer -> Z 5\nforeign i2Z   : {n} (fin n, n >= 1) => Integer -> Z n\n\nsubmodule A where\n  foreign nested : () -> [8]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1489\/issue1489.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the types, constants, and functions `id`, `q`, `ct_butterfly`, `zeta_expc`, and `fast_nttl` exactly as specified, preserving their polymorphic constraints, modular arithmetic, and vector operations."},{"role":"assistant","content":"```cryptol\nmodule ID where\n\nid : {k} (fin k, k > 0) => [2^^k] -> [2^^k]\nid x = join(split`{2,2^^(k-1)}x)\n\ntype q = 3329\n\nct_butterfly :\n    {m, hm}\n    (m >= 2, m <= 8, hm >= 1, hm <= 7, hm == m - 1) =>\n    [2^^m](Z q) -> (Z q) -> [2^^m](Z q)\nct_butterfly v z = new_v\n  where\n    halflen = 2^^`hm\n    lower, upper : [2^^hm](Z q)\n    lower@x = v@x + z * v@(x + halflen)\n    upper@x = v@x - z * v@(x + halflen)\n    new_v = lower # upper\n\nzeta_expc  : [128](Z q)\nzeta_expc = [ 1, 1729, 2580, 3289, 2642, 630, 1897, 848,\n              1062, 1919, 193, 797, 2786, 3260, 569, 1746,\n              296, 2447, 1339, 1476, 3046, 56, 2240, 1333,\n              1426, 2094, 535, 2882, 2393, 2879, 1974, 821,\n              289, 331, 3253, 1756, 1197, 2304, 2277, 2055,\n              650, 1977, 2513, 632, 2865, 33, 1320, 1915,\n              2319, 1435, 807, 452, 1438, 2868, 1534, 2402,\n              2647, 2617, 1481, 648, 2474, 3110, 1227, 910,\n              17, 2761, 583, 2649, 1637, 723, 2288, 1100,\n              1409, 2662, 3281, 233, 756, 2156, 3015, 3050,\n              1703, 1651, 2789, 1789, 1847, 952, 1461, 2687,\n              939, 2308, 2437, 2388, 733, 2337, 268, 641,\n              1584, 2298, 2037, 3220, 375, 2549, 2090, 1645,\n              1063, 319, 2773, 757, 2099, 561, 2466, 2594,\n              2804, 1092, 403, 1026, 1143, 2150, 2775, 886,\n              1722, 1212, 1874, 1029, 2110, 2935, 885, 2154 ]\n\nfast_nttl :\n    {lv}      (lv >= 2, lv <= 8) =>\n    [2^^lv](Z q) -> [8] -> [2^^lv](Z q)\nfast_nttl v k\n    | lv == 2 => ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n\n        | lv  > 2 => (fast_nttl`{lv-1} s0 (k * 2)) #\n                           (fast_nttl`{lv-1} s1 (k * 2 + 1))\n                where\n                  t = ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n                                    [s0, s1] = split t\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1561\/G.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `G` that imports the same interface `I` twice under different names (`J` and `K`) and defines `ja`, `jb`, `ka`, and `kb` using fields `x` and `y` from each interface instance as shown, preserving the qualified-name usage."},{"role":"assistant","content":"```cryptol\nmodule G where\n\nimport interface I as J\nimport interface I as K\n\nja = J::x + 1\njb = J::y + 2\n\nka = K::x + 1\nkb = K::y + 2\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1560\/T4.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module equivalent to T3 that defines the submodule interfaces I1 and I2 with constrained type x, submodules F and F::G, and the values y and csum with the given type dependencies, ensuring it type-checks under these interface constraints."},{"role":"assistant","content":"```cryptol\nmodule T3 where\n\ninterface submodule I1 where\n  type x: #\n  type constraint (x >= 1, x <= 3)\n\ninterface submodule I2 where\n  type x: #\n  type constraint (x >= 1, x <= 4)\n\nsubmodule F where\n  import interface submodule I1 as I\n\n  y: [I::x]\n  y = 1\n\n  submodule G where\n    import interface submodule I2 as I\n    import interface submodule I2 as J\n\n    csum : [I::x]\n    csum = y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1560\/T2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `T2` with parameterized type `n`, a finite-size constraint on `n`, a self-referential constant `a : [n]`, and a submodule `F` with its own type parameter `n` and a polymorphic function `b : {m} [n] -> [m]` returning `a`."},{"role":"assistant","content":"```cryptol\nmodule T2 where\n\nparameter\n  type n: #\n  type constraint (fin n)\n\na:[n]\na = a\n\nsubmodule F where\n  parameter\n    type n: #\n\n  b: {m} [n] -> [m]\n  b _ = a\n```"}]}
