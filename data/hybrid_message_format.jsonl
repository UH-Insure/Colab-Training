{"filename":"cryptol\/examples\/splitAt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the behavior of the 'splitAt' function when applied to the sequence 'x'. Ensure the properties check that the output tuple correctly splits 'x' into two subsequences of equal length, and that concatenating these subsequences reconstructs the original sequence 'x'."},{"role":"assistant","content":"```cryptol\nx = [1,2,3,4] : [_][8]\n\ny = (splitAt x) : ([2][8],[2][8])\n\na = y.0 @ 0\nb = y.0 @ 1\nc = y.1 @ 0\nd = y.1 @ 1\n```"}]}
{"filename":"cryptol\/examples\/AE.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that specify and verify the correctness of the AE module's encryption and decryption functions. In particular, formalize and prove that for any key, nonce, state, and message, decrypting the ciphertext produced by encrypting the message returns the original message and state, as suggested by the Dec_prop property. Include properties that capture the behavior of the tweak_cipher and the relationship between the tweak values across encryption steps."},{"role":"assistant","content":"```cryptol\n\/*\nImplementation of the algorithms from the paper\n  \"Automated Analysis and Synthesis of Authenticated Encryption Schemes\"\n  by Viet Tung Hoang, Jonathan Katz, and Alex J. Malozemoff\n*\/\nmodule AE where\n\nparameter\n  type A : *            type K : *            type n : #            type p : #            type tagAmount : #\n\n  type constraint (fin p, fin n, n >= tagAmount)\n\n  \/\/ Process a single block using this key and tweak\n  tweak_cipher : K -> { nonce : [n], state : A, z : [64] } -> [n] -> [n]\n\n  \/\/ Cost for using the tweak\n  Cost : [64]\n\n  Enc : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Dec : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Tag : K -> { nonce : [n], state : A, z : [64] } -> [p*n] -> [n]\n\n\/\/ The unit at which `Enc` operates\ntype Node       = { message : WorkBlock, state : State }\n\n\/\/ Some encryption schemes process multiple blocks at once\ntype WorkBlock  = [p*n]\n\ntype State      = [p*n]  \/\/ The state for `p` blocks\n\ntype Tweak      = { nonce : Nonce, state : A, z : Int }\ntype Nonce      = [n]\n\n\/*\nproperty\n\n  \/\/ The tweak in the `i`th query to the tweak_cipher\n  tweak_prop i { nonce = n, state = a, z = v } =\n               { nonce = n, state = a, z = v + i - 1 }\n\n\n  \/\/ Property of decrypt\n  Dec_prop : Tweak -> Node -> Bit\n  Dec_prop t { message = m, state = x } =\n       Dec t { message = c, state = x } == { message = m, state = y }\n       where { message = c, state = y } = Enc t x m\n*\/\n\ntype Int = [64]\n\nencrypt :\n  {m} fin m => K -> Nonce -> A -> [m * (p * n)] -> [m * (p * n) + tagAmount]\nencrypt key nonce state inputMsg = encMsg # tag\n\n  where\n  encMsg = join rest.0.message\n\n  tag = take (Tag key (tweak (1 - final.1)) final.0.state)\n\n  final = steps ! 0\n\n  steps = [ ({ message = undefined, state = zero }, 1) ] # rest\n  rest  = [ (Enc key (tweak v) { message = m, state = prev.state }, v + Cost)\n          | (prev,v) <- steps\n          | m        <- chunks\n          ]\n\n  \/\/ XXX: isn't v i  just 1 + i * Cost\n\n  chunks : [m] [p * n]\n  chunks = split inputMsg\n\n  tweak : Int -> Tweak\n  tweak v = { nonce = nonce, state = state, z = v }\n```"}]}
{"filename":"cryptol\/examples\/xor_cipher.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the 'encrypt' and 'decrypt' functions in the xor_cipher module are inverses of each other for all valid keys and plaintexts. Include properties that check the roundtrip correctness and any relevant invariants for the XOR cipher."},{"role":"assistant","content":"```cryptol\nencrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\nencrypt key plaintext = [pt ^ key | pt <- plaintext ]\n\ndecrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\ndecrypt key ciphertext = [ct ^ key | ct <- ciphertext ]\n\nproperty roundtrip k ip = decrypt k (encrypt k ip) == ip\n```"}]}
{"filename":"cryptol\/examples\/zero_weird.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify that the functions `x` and `y` always return zero values of the appropriate bit-widths for all valid inputs. Include properties that can be used with Cryptol's :check or :prove commands to confirm these behaviors."},{"role":"assistant","content":"```cryptol\nx : {a}() => a -> [16]\nx v = zero v \n\nproperty xprop v = x v == 0\n\ny : [12] -> [4] -> [17]\ny a b = zero a b\n\nproperty yprop v w = y v w == 0\n\nt1 = x 13\nt2 = y 2 3\n```"}]}
{"filename":"cryptol\/examples\/builtin_lifting.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally verifies the lifting behavior of built-in operators over tuples, sequences (including infinite sequences), and records as demonstrated in the given code. Include properties that check pointwise addition and negation lifting, and ensure these properties hold for finite and infinite data structures as well as nested combinations of tuples and records."},{"role":"assistant","content":"```cryptol\n\/\/builtins lift over tuples, seqs, and records\n\n\/\/this file uses addition to model a builtin\n\/\/but this should work for any builtin operators\n\nx = [True,False]\ny = [False,True]\n\n\/\/make sure bitvectors are numbers\nproperty p1 = x == (2 : [2])\n\n\/\/same thing written 2 different ways\nproperty p2 = x + y == 3\nproperty p3 = x + y == [True,True]\n\n\nxx = [[True,False]]\nyy = [[False,True]]\n\n\/\/addition lifts pointwise over sequences\nproperty p4 = xx + yy == [3]\n\n\/\/negation is a unary operator that also lifts over sequences\nproperty p5 = ~ xx == yy\n\n\nxinf = [2 ... ]\nyinf = [3 ... ]\n\n\/\/addition lifts pointwise over infinite lists\nproperty p6 = (xinf + yinf) @ (0 : [0]) == (1 : [2])\n\n\/\/negation lifts pointwise over an infinite list\nproperty p7 = (~ xinf) @ (0 : [0]) == (1 : [2])\n\nxrec = { x = 2 : [2], y = 2 : [2] } : {x : [2], y : [2]}\n\nproperty p8 = xrec + xrec + xrec == xrec\n\n\/\/lift over tuples and records at the same time\nproperty p9 = (2,2,xrec) + (2,2,xrec) + (2,2,xrec) == (2:[2],2:[2],xrec) \n\n\/\/lift unary over tuples and lists\nproperty p10 = (~ { x = (1,2), y = [3,4,5] }) == {x = (0:[1],1:[2]), y = [4, 3, 2] : [3][3] }\n```"}]}
{"filename":"cryptol\/examples\/inflist.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the infinite and finite sequences 'a', 'b', 'c', and 'd' defined in the code. Ensure the properties check the expected values at specific indices as indicated, and include properties that confirm the sequences behave as intended according to their definitions."},{"role":"assistant","content":"```cryptol\na = [1 ... ]\nb = [1,2 ... ]\nc = [1 .. 5]\nd = [1,3 .. 9]\n\nproperty t1 = a @ 3 == 1\nproperty t2 = b @ 3 == 1\nproperty t3 = c @ 3 == 4\nproperty t4 = d @ 3 == 4\n```"}]}
{"filename":"cryptol\/examples\/Karatsuba.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the `kmult` function correctly implements multiplication for all valid input sizes and limb widths, extending the existing `splitmult_correct_*` properties to cover the polymorphic behavior of `kmult`. Include properties that prove equivalence between `kmult` and the built-in multiplication operator for various parameter settings."},{"role":"assistant","content":"```cryptol\n\/*\n * Copyright (c) 2017 Galois, Inc.\n * Distributed under the terms of the BSD3 license (see LICENSE file)\n *\n * This module defines a Karatsuba multiplier, which is polymorphic over the\n * bitwidth of the constituent limbs and the size of the inputs.\n *\n * Note the trick of using `make_atleast` in the recursive case to teach the\n * typecheker that the current bitwidth is long enough for the split multiplier\n * to be sensible.  The minimum width for which the splitting recursive case\n * works out happens to be 6.  This is the smallest width for which the\n * divide-in-half strategy leaves enough bits left over for the additions\n * steps not to overflow.\n *\n * Note that if one wishes to simulate using a standard CPU to perform Karatsuba\n * multiplies, the limb width should be set to ONE LESS THAN the standard\n * machine word size, e.g. 63 bits for a 64 bit machine.  This ensures that\n * the intermediate additions will fit into a machine word.  Note that the the\n * final `2*(limb+1)`-width additions will also have to be assembled manually\n * using \"add with carry\" operations or similar.\n *\/\n\nmodule Karatsuba where\n\n\/\/ The divide-and-conquer Karatsuba multiplier.  If the argument width\n\/\/ is greater than the limb width, then the recursive `splitmult` multiplier\n\/\/ is called; otherwise, a standard multiply is used.\n\nkmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 1) => [n] -> [n] -> [2*n]\n\nkmult x y =\n if `n >= (`limb : [max (width limb) (width n)]) then\n   take (splitmult`{limb} (make_atleast`{limb} x) (make_atleast`{limb} y))\n else\n   (zero#x)*(zero#y)\n\n\n\/\/ Force a bitvector to be at least `n` bits long.  As used above, this operation\n\/\/ should always be a no-op, but teaches the typechecker a necessary inequality\n\/\/ to call the `splitmult` operation.\n\nmake_atleast : {n, m, a} (fin n, fin m, Zero a) => [m]a -> [max n m]a\nmake_atleast x = zero#x\n\n\n\n\/\/ Execute the recursive step of Karatsuba's multiplication. Split the\n\/\/ input words into high and low bit portions; then perform three\n\/\/ recursive multiplies using these intermediate, shorter bitsequences.\n\nsplitmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 6)\n         => [n] -> [n] -> [2*n]\n\nsplitmult x y = (ac # bd) + (zero # ad_bc # (zero:[low]))\n  where\n   type hi  = n\/2\n   type low = n - hi\n\n   (a,b) = splitAt`{hi} x\n   (c,d) = splitAt`{hi} y\n\n   ac : [2*hi]\n   ac = kmult`{limb,hi} a c\n\n   bd : [2*low]\n   bd = kmult`{limb,low} b d\n\n   a_b = (zext a) + (zext b)\n   c_d = (zext c) + (zext d)\n\n   ad_bc : [2*(low+1)]\n   ad_bc = (kmult`{limb,low+1} a_b c_d) - (zext ac) - (zext bd)\n\n\n\/\/ Verify Karatsuba's algorithm computes the correct answer\n\/\/ for some fixed settings of the parameters.\n\/\/\n\/\/ SMT solvers have great difficutly with these proofs, and I have\n\/\/ only gotten small bit sizes to return with successful proofs.\n\nproperty splitmult_correct_tiny (x:[9]) (y:[9]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_small (x:[11]) (y:[11]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_medium(x:[17]) (y:[17]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_large (x:[59]) (y:[59]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_huge (x:[511]) (y:[511]) =\n  zext x * zext y == splitmult`{limb=63} x y\n```"}]}
{"filename":"cryptol\/examples\/comp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the list comprehensions 'x' and 'y' defined in the given code. Ensure that the properties capture the expected values at specific indices as indicated by the existing properties t1 through t4, and extend these properties to comprehensively cover the behavior of 'x' and 'y'."},{"role":"assistant","content":"```cryptol\nx : [_]([2],[3],[3],[4])\nx = [(a,b,c,d) | a <- [1,2], b <- [3,4] | c <- [5,6], d <- [7,8,9] ]\n\nproperty t1 = x @ 0 == (1,3,5,7)\nproperty t2 = x @ 2 == (2,3,5,9)\nproperty t3 = x @ 3 == (2,4,6,7)\n\ny = [(a,b,c) | a <- [1,2,3], b <- [1,2] | c <- [1 ... ] ]\n\nproperty t4 = y @ 3 == (2,2,0)\n```"}]}
{"filename":"cryptol\/examples\/mini.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the function `gf28Add`. Then, write properties to verify that `gf28Add` correctly computes the cumulative XOR sums as described, and that it behaves correctly for various input lengths and values. Include tests or properties that check the correctness of the recursive definition and the base case."},{"role":"assistant","content":"```cryptol\nid : [32] -> [32]\nid x = rec x\n  where rec k = if (k == 0) then 0 else 1 + rec (k + (-1))\n\n\ninflist = [1 ... ] : [_][8]\n\nrc = {x = 3 : [8], y = 5 : [8]}\n\nmy_true = rc.x\n\ntup = (1 : [8], 2 : [8], 3 : [8], 4 : [8])\n\nmy_3 = tup.2\n\nsup = y where y = 3 : [8]\n\n\ngf28Add : {n} (fin n) => [n][8] -> [8]\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\ngex = gf28Add [1,2]\n\nsum : [_][8] -> [_][8]\nsum x = rec\n  where rec = [ p + q | p <- x | q <- [1,2,3,4] ]\n```"}]}
{"filename":"cryptol\/examples\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the encryption and decryption functions of any Cipher instance satisfy correctness tests as defined by the evktest, evttest, ekatest, dvktest, dvttest, and dkatest functions in the Test module. These properties should check that encrypting plaintext with a key produces the expected ciphertext, and decrypting ciphertext with a key recovers the original plaintext."},{"role":"assistant","content":"```cryptol\n\/\/ Don't load this on its own -- it gets pulled in by, e.g., DEStest.cry\n\nmodule Test where\nimport Cipher\n\nevktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\nevktest (cipher, vkeysCTs, PT) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, CT) <- vkeysCTs ]\n\nevttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\nevttest (cipher, Key, vtextPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (PT, CT) <- vtextPCTs ]\n\nekatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\nekatest (cipher, kaKPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, PT, CT) <- kaKPCTs ]\n\ndvktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\ndvktest (cipher, vkeysCTs, PT) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, CT) <- vkeysCTs ]\n\ndvttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\ndvttest (cipher, Key, vtextPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (PT, CT) <- vtextPCTs ]\n\ndkatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\ndkatest (cipher, kaKPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, PT, CT) <- kaKPCTs ]\n```"}]}
{"filename":"cryptol\/examples\/builtins.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of each builtin operator tested in the given code snippet. Then, write Cryptol properties to verify that the computed values (t, f, times, div, mod, exp, lgtest, p, m, neg, comp) conform to these specifications."},{"role":"assistant","content":"```cryptol\n\/\/Here's a test of some builtin operators\n\/\/nothing too deep, just making sure they all work out\n\nt : [8]\nt = if True then 5 else 4 f : [8]\nf = if False then 3 else 5 times : [8]\ntimes = 5 * 1 * 2 * 3 div : [8]\ndiv = (((30\/1)\/2)\/3) mod : [8]\nmod = 205%10 exp : [8]\nexp = 2^^7 lgtest : [8]\nlgtest = lg2 128 p : [8]\np = 3+2 m : [8]\nm = 8-3 neg : [8]\nneg = -(-5) comp : [8]\ncomp = ~250\n```"}]}
{"filename":"cryptol\/examples\/props.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the list concatenation operations and the behavior of the function 't' defined in the code snippet. Ensure the properties check that the concatenations produce expected results and that 't' returns a zero matrix of the specified size."},{"role":"assistant","content":"```cryptol\nx = [True, False]\ny = [False, True]\nz = x + y\n\nproperty p1 = z == 3\n\nxx = [[True,False]]\nyy = [[False, True]]\nzz = xx + yy\n\n\n\nt : {a} [a*3] -> [a*3][a*3]\nt d = zero\n```"}]}
{"filename":"cryptol\/examples\/demote.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property specification that verifies the function 'x' correctly transforms an input sequence of length 'a' into an output sequence of length '(a*2)+3'. Ensure the property checks the output length for various input lengths and that the function's behavior matches the intended type signature."},{"role":"assistant","content":"```cryptol\nx : {a}(fin a) => [a] -> [(a*2)+3]\nx v = 0 + 1\n\ny = x (2 : [3])\n```"}]}
{"filename":"cryptol\/examples\/append.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the behavior of the list append operation (#) as used in the given code. Then, write Cryptol properties to verify that the concatenated sequence z equals the sequence x followed by y, and that indexing into z returns the correct elements from x or y accordingly."},{"role":"assistant","content":"```cryptol\nx : [_][8]\nx = [1,2,3,4,5,19,12,38,5,3]\n\ny : [_][8]\ny = [19,3,27,5,12]\n\nz = x # y\n\nm = z @ (0 : [1]) w = z @ 2 t = z @ 10 v = z @ 11\n```"}]}
{"filename":"cryptol\/examples\/split.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the function 'split' correctly partitions a sequence into equal-sized chunks, preserving the order of elements. Specifically, ensure that concatenating the chunks produced by 'split' reconstructs the original sequence, and that indexing into the nested sequence matches the expected elements from the original sequence."},{"role":"assistant","content":"```cryptol\nx = [1,2,3,4] : [_][8]\n\ny = (split x) : [2][2][8]\n\na = (y@0) @ 0\nb = (y@0) @ 1\nc = (y@1) @ 0\nd = (y@1) @ 1\n```"}]}
{"filename":"cryptol\/lib\/Array.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the arrayRangeLookup and arrayRangeUpdate functions in the Array module. The properties should ensure that arrayRangeLookup returns the exact sequence of elements starting at the given index, and that arrayRangeUpdate correctly updates the array elements at the specified index range with the provided values. Include boundary conditions and ensure no wrap-around occurs."},{"role":"assistant","content":"```cryptol\nmodule Array where\n\nprimitive type Array : * -> * -> *\n\nprimitive arrayConstant : {a, b} b -> (Array a b)\nprimitive arrayLookup : {a, b} (Array a b) -> a -> b\nprimitive arrayUpdate : {a, b} (Array a b) -> a -> b -> (Array a b)\nprimitive arrayEq : {n, a} (Array [n] a) -> (Array [n] a) -> Bool\n\n\/**\n * Copy elements from the source array to the destination array.\n *\n * 'arrayCopy dest_arr dest_idx src_arr src_idx len' copies the\n * elements from 'src_arr' at indices '[src_idx ..< (src_idx + len)]' into\n * 'dest_arr' at indices '[dest_idx ..< (dest_idx + len)]'.\n *\n * The result is undefined if either 'dest_idx + len' or 'src_idx + len'\n * wraps around.\n *\/\nprimitive arrayCopy : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> (Array [n] a)\n\/**\n * Set elements of the given array.\n *\n * 'arraySet' arr idx val len' sets the elements of 'arr' at indices\n * '[idx ..< (idx + len)]' to 'val'.\n *\n * The result is undefined if 'idx + len' wraps around.\n *\/\nprimitive arraySet : {n, a} (Array [n] a) -> [n] -> a -> [n] -> (Array [n] a)\n\/**\n * Check whether the lhs array and rhs array are equal at a range of\n * indices.\n *\n * 'arrayRangeEq sym lhs_arr lhs_idx rhs_arr rhs_idx len' checks whether\n * the elements of 'lhs_arr' at indices '[lhs_idx ..< (lhs_idx + len)]' and\n * the elements of 'rhs_arr' at indices '[rhs_idx ..< (rhs_idx + len)]' are\n * equal.\n *\n * The result is undefined if either 'lhs_idx + len' or 'rhs_idx + len'\n * wraps around.\n *\/\nprimitive arrayRangeEqual : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> Bool\n\narrayRangeLookup : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b\narrayRangeLookup arr idx = res\n  where\n    res @ i = arrayLookup arr (idx + i)\n\narrayRangeUpdate : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b -> (Array a b)\narrayRangeUpdate arr idx vals = arrs ! 0\n  where\n    arrs = [arr] # [ arrayUpdate acc (idx + i) val | acc <- arrs | i <- [0 ..< n] | val <- vals ]\n```"}]}
{"filename":"cryptol\/lib\/SuiteB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the AES key schedule expansions and block encryption\/decryption functions defined in the SuiteB module. Include properties that check the consistency between encryption and decryption schedules for AES-128, AES-192, and AES-256, and verify that encrypting and then decrypting a plaintext block returns the original plaintext. Also, specify properties to validate the SHA2 hash functions produce outputs of correct length and behave consistently with respect to input padding and block processing."},{"role":"assistant","content":"```cryptol\nmodule SuiteB where\n\n\/***** AES ******\/\n\n\/**\n * Key schedule parameter setting for AES-128\n *\/\ntype AES128 = 4\n\n\/**\n * Key schedule parameter setting for AES-192\n *\/\ntype AES192 = 6\n\n\/**\n * Key schedule parameter setting for AES-256\n *\/\ntype AES256 = 8\n\n\/**\n * Element of an AES key schedule for use in a particular round\n *\/\ntype AESRoundKey = [4][32]\n\n\/**\n * Expanded encryption key schedule for AES\n *\/\ntype AESEncryptKeySchedule k =\n  { aesEncInitialKey : AESRoundKey\n  , aesEncRoundKeys  : [k+5]AESRoundKey\n  , aesEncFinalKey   : AESRoundKey\n  }\n\n\/**\n * Expanded decryption key schedule for AES\n *\/\ntype AESDecryptKeySchedule k =\n  { aesDecInitialKey : AESRoundKey\n  , aesDecRoundKeys  : [k+5]AESRoundKey\n  , aesDecFinalKey   : AESRoundKey\n  }\n\n\/**\n * Encryption key expansion for AES-128.\n *   See FIPS 197, section 5.2.\n *\/\naes128EncryptSchedule : [128] -> AESEncryptKeySchedule AES128\naes128EncryptSchedule = aesExpandEncryptSchedule\n\n\/**\n * Decryption key expansion for AES-128, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes128DecryptSchedule : [128] -> AESDecryptKeySchedule AES128\naes128DecryptSchedule = aesExpandDecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-128.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes128Schedules : [128] -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\naes128Schedules = aesExpandSchedules\n\n\/**\n * Encryption key expansion for AES-192.\n *   See FIPS 197, section 5.2.\n *\/\naes192EncryptSchedule : [192] -> AESEncryptKeySchedule AES192\naes192EncryptSchedule = aesExpandEncryptSchedule\n\n\/**\n * Decryption key expansion for AES-192, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes192DecryptSchedule : [192] -> AESDecryptKeySchedule AES192\naes192DecryptSchedule = aesExpandDecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-192.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes192Schedules : [192] -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\naes192Schedules = aesExpandSchedules\n\n\n\/**\n * Encryption key expansion for AES-256.\n *   See FIPS 197, section 5.2\n *\/\naes256EncryptSchedule : [256] -> AESEncryptKeySchedule AES256\naes256EncryptSchedule = aesExpandEncryptSchedule\n\n\/**\n * Decryption key expansion for AES-256, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes256DecryptSchedule : [256] -> AESDecryptKeySchedule AES256\naes256DecryptSchedule = aesExpandDecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-256.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes256Schedules : [256] -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\naes256Schedules = aesExpandSchedules\n\n\/**\n * AES block encryption algorithm.\n *   See FIPS 197, section 5.1.\n *\/\naesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]\naesEncryptBlock schedule plaintext = rnf (join final)\n  where\n  final = (AESEncFinalRound (rds!0)) ^ schedule.aesEncFinalKey\n\n  rds = [ schedule.aesEncInitialKey ^ split plaintext ] #\n        [ AESEncRound r ^ rdk\n        | rdk <- schedule.aesEncRoundKeys\n        | r   <- rds\n        ]\n\n\/**\n * AES block decryption algorithm, via the \"equivalent inverse cypher\".\n *   See FIPS 197, section 5.3.5.\n *\/\naesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]\naesDecryptBlock schedule cyphertext = rnf (join final)\n  where\n  final = (AESDecFinalRound (rds!0)) ^ schedule.aesDecFinalKey\n\n  rds = [ split cyphertext ^ schedule.aesDecInitialKey ] #\n        [ AESDecRound r ^ rdk\n        | rdk <- schedule.aesDecRoundKeys\n        | r   <- rds\n        ]\n\nprivate\n    aesExpandEncryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESEncryptKeySchedule k\n    aesExpandEncryptSchedule key = rnf\n         { aesEncInitialKey = ks @  0\n         , aesEncRoundKeys  = ks @@ [ 1 .. k+5 ]\n         , aesEncFinalKey   = ks @  `(k+6)\n         }\n      where\n      ks : [k+7]AESRoundKey\n      ks = groupBy`{4} (AESKeyExpand`{k} (split key))\n\n    aesEncToDecSchedule : {k} (fin k) => AESEncryptKeySchedule k -> AESDecryptKeySchedule k\n    aesEncToDecSchedule enc = rnf\n       { aesDecInitialKey = enc.aesEncFinalKey\n       , aesDecRoundKeys  = map AESInvMixColumns (reverse (enc.aesEncRoundKeys))\n       , aesDecFinalKey   = enc.aesEncInitialKey\n       }\n\n    aesExpandDecryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESDecryptKeySchedule k\n    aesExpandDecryptSchedule key = aesEncToDecSchedule (aesExpandEncryptSchedule key)\n\n    aesExpandSchedules : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> (AESEncryptKeySchedule k, AESDecryptKeySchedule k)\n    aesExpandSchedules key = (encS, aesEncToDecSchedule encS)\n      where encS = aesExpandEncryptSchedule key\n\n    primitive AESEncRound      : [4][32] -> [4][32]\n    primitive AESEncFinalRound : [4][32] -> [4][32]\n    primitive AESDecRound      : [4][32] -> [4][32]\n    primitive AESDecFinalRound : [4][32] -> [4][32]\n    primitive AESInvMixColumns : [4][32] -> [4][32]\n    primitive AESKeyExpand     : {k} (fin k, k >= 4, 8 >= k) => [k][32] -> [4*(k+7)][32]\n\n\n\/***** SHA2 *****\/\n\n\/**\n * The SHA-224 secure hash algorithm.  See FIPS 180-4, section 6.3.\n *\/\nsha224 : {L} (fin L) => [L] -> [224]\nsha224 msg = join (processSHA2_224 (sha2blocks`{32} msg))\n\n\/**\n * The SHA-256 secure hash algorithm.  See FIPS 180-4, section 6.2.2.\n *\/\nsha256 : {L} (fin L) => [L] -> [256]\nsha256 msg = join (processSHA2_256 (sha2blocks`{32} msg))\n\n\/**\n * The SHA-384 secure hash algorithm.  See FIPS 180-4, section 6.5.\n *\/\nsha384 : {L} (fin L) => [L] -> [384]\nsha384 msg = join (processSHA2_384 (sha2blocks`{64} msg))\n\n\/**\n * The SHA-512 secure hash algorithm.  See FIPS 180-4, section 6.4.\n *\/\nsha512 : {L} (fin L) => [L] -> [512]\nsha512 msg = join (processSHA2_512 (sha2blocks`{64} msg))\n\nprivate\n    type sha2_block_size w = 16 * w\n    type sha2_num_blocks w L = (L+1+2*w) \/^ sha2_block_size w\n    type sha2_padded_size w L = sha2_num_blocks w L * sha2_block_size w\n\n    sha2pad : {w, L} (fin w, fin L, w >= 1) => [L] -> [sha2_padded_size w L]\n    sha2pad M = rnf (M # 0b1 # zero # ((fromInteger `L) : [2*w]))\n\n    sha2blocks : {w, L} (fin w, fin L, w >= 1) =>\n      [L] -> [sha2_num_blocks w L][16][w]\n    sha2blocks msg = [ split x | x <- split (sha2pad`{w} msg) ]\n\n    \/**\n     * Apply the SHA224 hash algorithm to a sequence of SHA256-size blocks,\n     * which are assumed to already be correctly padded.\n     *\/\n    primitive processSHA2_224 : {n} (fin n) => [n][16][32] -> [7][32]\n\n    \/**\n     * Apply the SHA256 hash algorithm to a sequence of SHA256-size blocks,\n     * which are assumed to already be correctly padded.\n     *\/\n    primitive processSHA2_256 : {n} (fin n) => [n][16][32] -> [8][32]\n\n    \/**\n     * Apply the SHA384 hash algorithm to a sequence of SHA512-size blocks,\n     * which are assumed to already be correctly padded.\n     *\/\n    primitive processSHA2_384 : {n} (fin n) => [n][16][64] -> [6][64]\n\n    \/**\n     * Apply the SHA512 hash algorithm to a sequence of SHA512-size blocks,\n     * which are assumed to already be correctly padded.\n     *\/\n    primitive processSHA2_512 : {n} (fin n) => [n][16][64] -> [8][64]\n```"}]}
{"filename":"cryptol\/lib\/Float.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and IEEE-754 compliance of the floating point operations defined in the Float module, including fpAdd, fpSub, fpMul, fpDiv, fpFMA, fpAbs, and fpSqrt. The properties should check behavior for special values such as NaN, infinities, zeros, and subnormal numbers, and ensure that rounding modes are correctly implemented."},{"role":"assistant","content":"```cryptol\nmodule Float where\n\nprimitive type ValidFloat : # -> # -> Prop\n\n\/** IEEE-754 floating point numbers. *\/\nprimitive type { exponent : #, precision : #}\n  ValidFloat exponent precision => Float exponent precision : *\n\n\/** An abbreviation for common 16-bit floating point numbers. *\/\ntype Float16  = Float 5 11\n\n\/** An abbreviation for common 32-bit floating point numbers. *\/\ntype Float32  = Float 8 24\n\n\/** An abbreviation for common 64-bit floating point numbers. *\/\ntype Float64  = Float 11 53\n\n\/** An abbreviation for common 128-bit floating point numbers. *\/\ntype Float128 = Float 15 113\n\n\/** An abbreviation for common 256-bit floating point numbers. *\/\ntype Float256 = Float 19 237\n\n\n\n\/* ----------------------------------------------------------------------\n * Rounding modes (this should be an enumeration type, when we add these)\n *---------------------------------------------------------------------- *\/\n\n\/**\n * A 'RoundingMode' is used to specify the precise behavior of some\n * floating point primitives.\n *\n * There are five valid 'RoundingMode' values:\n *  * roundNearestEven\n *  * roundNearestAway\n *  * roundPositive\n *  * roundNegative\n *  * roundZero\n *\/\ntype RoundingMode = [3]\n\n\/** Round toward nearest, ties go to even. *\/\nroundNearestEven, rne : RoundingMode\nroundNearestEven = 0\nrne              = roundNearestEven\n\n\/** Round toward nearest, ties away from zero. *\/\nroundNearestAway, rna : RoundingMode\nroundNearestAway  = 1\nrna               = roundNearestAway\n\n\/** Round toward positive infinity. *\/\nroundPositive, rtp : RoundingMode\nroundPositive     = 2\nrtp               = roundPositive\n\n\/** Round toward negative infinity. *\/\nroundNegative, rtn : RoundingMode\nroundNegative     = 3\nrtn               = roundNegative\n\n\/** Round toward zero. *\/\nroundZero, rtz : RoundingMode\nroundZero         = 4\nrtz               = roundZero\n\n\n\n\/** Not a number. *\/\nprimitive\n  fpNaN : {e,p} ValidFloat e p => Float e p\n\n\/** Positive infinity. *\/\nprimitive\n  fpPosInf : {e,p} ValidFloat e p => Float e p\n\n\/** Negative infinity. *\/\nfpNegInf : {e,p} ValidFloat e p => Float e p\nfpNegInf = - fpPosInf\n\n\/** Positive zero. *\/\nfpPosZero : {e,p} ValidFloat e p => Float e p\nfpPosZero = zero\n\n\/** Negative zero. *\/\nfpNegZero : {e,p} ValidFloat e p => Float e p\nfpNegZero = - fpPosZero\n\n\n\/** A floating point number using the exact bit pattern,\nin IEEE interchange format with layout:\n\n  (sign : [1]) # (biased_exponent : [e]) # (significand : [p-1])\n*\/\nprimitive\n  fpFromBits : {e,p} ValidFloat e p => [e + p] -> Float e p\n\n\/** Export a floating point number in IEEE interchange format with layout:\n\n  (sign : [1]) # (biased_exponent : [e]) # (significand : [p-1])\n\nNaN is represented as:\n  * positive:           sign        == 0\n  * quiet with no info: significand == 0b1 # 0\n*\/\nprimitive\n  fpToBits : {e,p} ValidFloat e p => Float e p -> [e + p]\n\n\n\n\n\n\/\/ Operations in `Cmp` use IEEE reasoning.\n\n\/** Check if two floating point numbers are representationally the same.\nIn particular, the following hold:\n    *    NaN       =.= NaN\n    * ~ (pfNegZero =.= fpPosZero)\n*\/\nprimitive\n  (=.=) : {e,p} ValidFloat e p => Float e p -> Float e p -> Bool\n\ninfix 20 =.=\n\n\/** Test if this value is not-a-number (NaN). *\/\nprimitive fpIsNaN : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/** Test if this value is positive or negative infinity. *\/\nprimitive fpIsInf : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/** Test if this value is positive or negative zero. *\/\nprimitive fpIsZero : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/** Test if this value is negative. *\/\nprimitive fpIsNeg : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/** Test if this value is normal (not NaN, not infinite, not zero, and not subnormal). *\/\nprimitive fpIsNormal : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/**\n * Test if this value is subnormal.  Subnormal values are nonzero\n * values with magnitudes smaller than can be represented with the\n * normal implicit leading bit convention.\n *\/\nprimitive fpIsSubnormal : {e,p} ValidFloat e p => Float e p -> Bool\n\n\/* Returns true for numbers that are not an infinity or NaN. *\/\nfpIsFinite : {e,p} ValidFloat e p => Float e p -> Bool\nfpIsFinite f = ~ (fpIsNaN f \\\/ fpIsInf f )\n\n\n\/** Add floating point numbers using the given rounding mode. *\/\nprimitive\n  fpAdd : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\n\/** Subtract floating point numbers using the given rounding mode. *\/\nprimitive\n  fpSub : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\n\/** Multiply floating point numbers using the given rounding mode. *\/\nprimitive\n  fpMul : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\n\/** Divide floating point numbers using the given rounding mode. *\/\nprimitive\n  fpDiv : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\n\/**\n * Fused-multiply-add.  'fpFMA r x y z' computes the value '(x*y)+z',\n * rounding the result according to mode 'r' only after performing both\n * operations.\n *\/\nprimitive\n  fpFMA : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p -> Float e p\n\n\/**\n * Absolute value of a floating-point value.\n *\/\nprimitive\n  fpAbs : {e,p} ValidFloat e p =>\n    Float e p -> Float e p\n\n\/**\n * Square root of a floating-point value.  The square root of\n * a negative value yiels NaN, except that the sqaure root of\n * '-0.0' is '-0.0'.\n *\/\nprimitive\n  fpSqrt : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p\n\n\/** Convert a floating point number to a rational.\nIt is an error to use this with infinity or NaN **\/\nprimitive\n  fpToRational : {e,p} ValidFloat e p =>\n    Float e p -> Rational\n\n\/** Convert a rational to a floating point number, using the\ngiven rounding mode, if the number cannot be represented exactly. *\/\nprimitive\n  fpFromRational : {e,p} ValidFloat e p =>\n    RoundingMode -> Rational -> Float e p\n```"}]}
{"filename":"cryptol\/lib\/Cryptol.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the core numeric and sequence operations defined in the Cryptol module, such as addition, multiplication, sequence concatenation, splitting, and indexing. Include properties that check algebraic laws (e.g., associativity, distributivity) for Ring and Field instances, correctness of sequence operations (e.g., splitAt and join are inverses), and consistency of numeric constraints (e.g., fin, prime)."},{"role":"assistant","content":"```cryptol\nmodule Cryptol where\n\ninfixr  5 ==>\ninfixr 10 \\\/\ninfixr 15 \/\\\ninfix  20 ==, ===, !=, !==\ninfix  30 >, >=, <, <=, <$, >$, <=$, >=$\ninfixr 40 ||\ninfixl 45 ^\ninfixr 50 &&\ninfixr 60 #\ninfixl 70 <<, <<<, >>, >>>, >>$\ninfixl 80 +, -\ninfixl 90 *, \/, %, \/$, %$, %^, \/^\ninfixr 95 ^^\ninfixl 100 @, @@, !, !!\n\n\n\/\/ Base types -----------------------------------------------------------------------\n\n\/** The type of boolean values. *\/\nprimitive type Bit : *\n\n\/** The type of unbounded integers. *\/\nprimitive type Integer : *\n\n\/**\n * 'Z n' is the type of integers, modulo 'n'.\n *\n * The values of 'Z n' may be thought of as equivalence\n * classes of integers according to the equivalence\n * 'x ~ y' iff 'n' divides 'x - y'.  'Z n' naturally\n * forms a ring, but does not support integral division\n * or indexing.\n *\n * However, you may use the 'fromZ' operation\n * to project values in 'Z n' into the integers if such operations\n * are required.  This will compute the reduced representative\n * of the equivalence class. In other words, 'fromZ' computes\n * the (unique) integer value 'i'  where '0 <= i < n' and\n * 'i' is in the given equivalence class.\n *\n * If the modulus 'n' is prime, 'Z n' also\n * supports computing inverses and forms a field.\n *\/\nprimitive type {n : #} (fin n, n >= 1) => Z n : *\n\n\/**\n * 'Rational' is the type of rational numbers.\n * Rational numbers form a Field (and thus a Ring).\n *\n * The 'ratio' operation may be used to directly create\n * rational values from as a ratio of integers, or\n * the 'fromInteger' method and the field operations\n * can be used.\n *\/\nprimitive type Rational : *\n\ntype Bool = Bit\ntype Word n = [n]\ntype Char = [8]\ntype String n = [n]Char\n\n\/\/ Numeric operators and constraints ----------------------------------------------\n\n\/** A numeric type representing infinity. *\/\nprimitive type inf : #\n\n\/** Assert that two numeric types are equal. *\/\nprimitive type (==) : # -> # -> Prop\n\n\/** Assert that two numeric types are different. *\/\nprimitive type (!=) : # -> # -> Prop\n\n\/** Assert that the first numeric type is larger than, or equal to the second.*\/\nprimitive type (>=) : # -> # -> Prop\n\n\/** Assert that a numeric type is a proper natural number (not 'inf'). *\/\nprimitive type fin : # -> Prop\n\n\/** Assert that a numeric type is a prime number. *\/\nprimitive type prime : # -> Prop\n\n\/** Add numeric types. *\/\nprimitive type (+) : # -> # -> #\n\n\/** Multiply numeric types. *\/\nprimitive type (*) : # -> # -> #\n\n\/** Subtract numeric types. *\/\nprimitive type\n  {m : #, n : # }\n  (fin n, m >= n) =>\n  m - n : #\n\n\/** Divide numeric types, rounding down. *\/\nprimitive type\n  { m : #, n : # }\n  (fin m, n >= 1) =>\n  m \/ n : #\n\n\/** Remainder of numeric type division. *\/\nprimitive type\n  { m : #, n : # }\n  (fin m, n >= 1) =>\n  m % n : #\n\n\/** Exponentiate numeric types. *\/\nprimitive type (^^) : # -> # -> #\n\n\/** The number of bits required to represent the value of a numeric type. *\/\nprimitive type width : # -> #\n\n\/**\n * The ceiling of the base-2 logarithm of a numeric type.\n * We define 'lg2 n = width (n - 1)' for nonzero n, and 'lg2 0 = 0'.\n *\/\ntype lg2 n = width (max n 1 - 1)\n\n\/** The smaller of two numeric types. *\/\nprimitive type min : # -> # -> #\n\n\/** The larger of two numeric types. *\/\nprimitive type max : # -> # -> #\n\n\/** Divide numeric types, rounding up. *\/\nprimitive type\n  { m : #, n : # }\n  (fin n, n >= 1) =>\n  m \/^ n : #\n\n\/** How much we need to add to make a proper multiple of the second argument. *\/\nprimitive type\n  { m : #, n : # }\n  (fin n, n >= 1) =>\n  m %^ n : #\n\n\/** The length of an enumeration. *\/\nprimitive type\n  { start : #, next : #, last : # }\n  (fin start, fin next, fin last, start != next) =>\n  lengthFromThenTo start next last : #\n\n\/**\n * Assert that the first numeric type is less than or equal to the second.\n *\/\ntype constraint i <= j = (j >= i)\n\n\/**\n * Assert that the first numeric type is greater than the second.\n *\/\ntype constraint i > j = i >= j + 1\n\n\/**\n * Assert that the first numeric type is less than the second.\n *\/\ntype constraint i < j = j >= i + 1\n\n\n\/\/ The Literal class ----------------------------------------------------\n\n\/** 'Literal n a' asserts that type 'a' contains the number 'n'. *\/\nprimitive type Literal : # -> * -> Prop\n\n\/**\n * 'LiteralLessThan n a' asserts that the type 'a' contains all the\n * natural numbers strictly below 'n'.  Note that we may have 'n = inf',\n * in which case the type 'a' must be unbounded.\n *\/\nprimitive type LiteralLessThan : # -> * -> Prop\n\n\/**\n * The value corresponding to a numeric type.\n *\/\nprimitive number : {val, rep} Literal val rep => rep\n\n\/**\n * An alternative name for 'number', present for backward compatibility.\n *\/\ndemote : {val, rep} Literal val rep => rep\ndemote = number`{val}\n\n\/**\n * Return the length of a sequence.  Note that the result depends only\n * on the type of the argument, not its value.\n *\/\nlength : {n, a, b} (fin n, Literal n b) => [n]a -> b\nlength _ = `n\n\n\/**\n * A finite sequence counting up from 'first' to 'last'.\n *\n * '[x .. y]' is syntactic sugar for 'fromTo`{first=x,last=y}'.\n *\/\nprimitive fromTo : {first, last, a}\n  (fin last, last >= first, Literal last a) =>\n  [1 + (last - first)]a\n\n\/**\n * A possibly infinite sequence counting up from 'first' up to (but not including) 'bound'.\n *\n * '[ x ..< y ]' is syntactic sugar for 'fromToLessThan`{first=x,bound=y}'.\n *\n * Note that if 'first' = 'bound' then the sequence will be empty.  If 'bound = inf'\n * then the sequence will be infinite, and will eventually wrap around for bounded types.\n *\/\nprimitive fromToLessThan :\n  {first, bound, a} (fin first, bound >= first, LiteralLessThan bound a) =>\n  [bound - first]a\n\n\/**\n * A finite sequence counting up from 'first' to 'last' by 'stride'.\n * Note that 'last' will only be an element of the enumeration if\n * 'stride' divides 'last - first' evenly.\n *\n * '[x .. y by n]' is syntactic sugar for 'fromToBy`{first=x,last=y,stride=n}'.\n *\/\nprimitive fromToBy : {first, last, stride, a}\n  (fin last, fin stride, stride >= 1, last >= first, Literal last a) =>\n  [1 + (last - first)\/stride]a\n\n\/**\n * A finite sequence counting from 'first' up to (but not including) 'bound'\n * by 'stride'.  Note that if 'first = bound' then the sequence will\n * be empty.  If 'bound = inf' then the sequence will be infinite, and will\n * eventually wrap around for bounded types.\n *\n * '[x ..< y by n]' is syntactic sugar for 'fromToByLessThan`{first=x,bound=y,stride=n}'.\n *\/\nprimitive fromToByLessThan : {first, bound, stride, a}\n  (fin first, fin stride, stride >= 1, bound >= first, LiteralLessThan bound a) =>\n  [(bound - first)\/^stride]a\n\n\/**\n * A finite sequence counting from 'first' down to 'last' by 'stride'.\n * Note that 'last' will only be an element of the enumeration if\n * 'stride' divides 'first - last' evenly.\n *\n * '[x .. y down by n]' is syntactic sugar for 'fromToDownBy`{first=x,last=y,stride=n}'.\n *\/\nprimitive fromToDownBy : {first, last, stride, a}\n  (fin first, fin stride, stride >= 1, first >= last, Literal first a) =>\n  [1 + (first - last)\/stride]a\n\n\/**\n * A finite sequence counting from 'first' down to (but not including)\n * 'bound' by 'stride'.\n *\n * '[x ..> y down by n]' is syntactic sugar for\n * 'fromToDownByGreaterThan`{first=x,bound=y,stride=n}'.\n *\n * Note that if 'first = bound' the sequence will be empty.\n *\/\nprimitive fromToDownByGreaterThan : {first, bound, stride, a}\n  (fin first, fin stride, stride >= 1, first >= bound, Literal first a) =>\n  [(first - bound)\/^stride]a\n\n\/**\n * A finite arithmetic sequence starting with 'first' and 'next',\n * stopping when the values reach or would skip over 'last'.\n *\n * '[x,y..z]' is syntactic sugar for 'fromThenTo`{first=x,next=y,last=z}'.\n *\/\nprimitive fromThenTo : {first, next, last, a, len}\n                       ( fin first, fin next, fin last\n                       , Literal first a, Literal next a, Literal last a\n                       , first != next\n                       , lengthFromThenTo first next last == len) => [len]a\n\n\/\/ Fractional Literals ---------------------\n\n\/** 'FLiteral m n r a' asserts that the type 'a' contains the\nfraction 'm\/n'.  The flag 'r' indicates if we should round ('r >= 1')\nor report an error if the number can't be represented exactly. *\/\nprimitive type FLiteral : # -> # -> # -> * -> Prop\n\n\/** A fractional literal corresponding to 'm\/n' *\/\nprimitive\n  fraction : { m, n, r, a } FLiteral m n r a => a\n\n\n\n\n\n\n\n\/\/ The Zero class -------------------------------------------------------\n\n\/** Value types that have a notion of 'zero'. *\/\nprimitive type Zero : * -> Prop\n\n\/**\n * Gives an arbitrary shaped value whose bits are all False.\n * ~zero likewise gives an arbitrary shaped value whose bits are all True.\n *\/\nprimitive zero : {a} (Zero a) => a\n\n\n\/\/ The Logic class ------------------------------------------------------\n\n\/** Value types that support logical operations. *\/\nprimitive type Logic : * -> Prop\n\n\/**\n * Logical 'and' over bits. Extends element-wise over sequences, tuples.\n *\/\nprimitive (&&) : {a} (Logic a) => a -> a -> a\n\n\/**\n * Logical 'or' over bits. Extends element-wise over sequences, tuples.\n *\/\nprimitive (||) : {a} (Logic a) => a -> a -> a\n\n\/**\n * Logical 'exclusive or' over bits. Extends element-wise over sequences, tuples.\n *\/\nprimitive (^) : {a} (Logic a) => a -> a -> a\n\n\/**\n * Bitwise complement. The prefix notation '~ x'\n * is syntactic sugar for 'complement x'.\n *\/\nprimitive complement : {a} (Logic a) => a -> a\n\n\n\/\/ The Ring class -------------------------------------------------------\n\n\/**\n * Value types that support ring addition and multiplication.\n *\n * Floating-point values are only approximately a ring, but\n * nonetheless inhabit this class.\n *\/\nprimitive type Ring : * -> Prop\n\n\/**\n * Converts an unbounded integer to a value in a Ring using the following rules:\n *   * to bitvector type [n]:\n *     the value is reduced modulo 2^^n,\n *   * to Z n:\n *     the value is reduced modulo n,\n *   * floating point types:\n *     the value is rounded to the nearest representable value,\n *   * sequences other than bitvectors:\n *     elements are computed by using `fromInteger` pointwise\n *     Example: (fromInteger 2 : [3][8]) === [ 0x02, 0x02, 0x02 ]\n *   * tuples and records:\n *     elements are computed by using `fromInteger` pointwise\n *     Example: (fromInteger 2 : (Integer,[3][8])) === (2, [ 0x2, 0x2, 0x2 ])\n *   * functions:\n *     a constant function returning `fromInteger` on the result type\n *\/\nprimitive fromInteger : {a} (Ring a) => Integer -> a\n\n\/**\n * Add two values.\n *  * For type [n], addition is modulo 2^^n.\n *  * Structured values are added element-wise.\n *\/\nprimitive (+) : {a} (Ring a) => a -> a -> a\n\n\/**\n * Subtract two values.\n *  * For type [n], subtraction is modulo 2^^n.\n *  * Structured values are subtracted element-wise.\n *  * Satisfies 'a - b = a + negate b'.\n * See also: 'negate'.\n *\/\nprimitive (-) : {a} (Ring a) => a -> a -> a\n\n\/**\n * Multiply two values.\n *  * For type [n], multiplication is modulo 2^^n.\n *  * Structured values are multiplied element-wise.\n *\/\nprimitive (*) : {a} (Ring a) => a -> a -> a\n\n\/**\n * Returns the additive inverse of its argument.\n * Over structured values, operates element-wise.\n * The prefix notation '- x' is syntactic sugar\n * for 'negate x'.\n *\n * Satisfies 'a + negate a = 0'.\n * Satisfies 'negate a = ~a + 1' for bitvector values.\n *\/\nprimitive negate : {a} (Ring a) => a -> a\n\n\n\/**\n * Value types that correspond to a segment of the\n * integers. These types support integer division and\n * modulus, indexing into sequences, and enumeration.\n *\/\nprimitive type Integral : * -> Prop\n\n\/**\n * Divide two values, rounding down (toward negative infinity).\n *  * For type [n], the arguments are treated as unsigned.\n *  * Division by zero is undefined.\n *\/\nprimitive (\/) : {a} (Integral a) => a -> a -> a\n\n\/**\n * Compute the remainder from dividing two values.\n *  * For type [n], the arguments are treated as unsigned.\n *  * Remainder of division by zero is undefined.\n *  * Satisfies 'x % y == x - (x \/ y) * y'.\n *\/\nprimitive (%) : {a} (Integral a) => a -> a -> a\n\n\/**\n * Converts a value of an integral type to an integer.\n *\/\nprimitive toInteger : {a} (Integral a) => a -> Integer\n\n\/**\n * Compute the exponentiation of a value in a ring.\n *  * For type [n], the exponent is treated as unsigned.\n *  * It is an error to raise a value to a negative integer exponent.\n *  * Satisfies: 'x ^^ 0 == fromInteger 1'\n *  * Satisfies: 'x ^^ e == x * x ^^ (e-1)' when 'e > 0'.\n *\/\nprimitive (^^) : {a, e} (Ring a, Integral e) => a -> e -> a\n\n\/**\n * An infinite sequence counting up from the given starting value.\n * '[x...]' is syntactic sugar for 'infFrom x'.\n *\/\nprimitive infFrom : {a} (Integral a) => a -> [inf]a\n\n\/**\n * An infinite arithmetic sequence starting with the given two values.\n * '[x,y...]' is syntactic sugar for 'infFromThen x y'.\n *\/\nprimitive infFromThen : {a} (Integral a) => a -> a -> [inf]a\n\n\n\/**\n * Value types that correspond to a field; that is,\n * a ring also possessing multiplicative inverses for\n * non-zero elements.\n *\n * Floating-point values are only approximately a field,\n * but nonetheless inhabit this class.\n *\/\nprimitive type Field : * -> Prop\n\n\/**\n * Reciprocal\n *\n * Compute the multiplicative inverse of an element of a field.\n * The reciprocal of 0 is undefined.\n *\/\nprimitive recip : {a} (Field a) => a -> a\n\n\/**\n * Field division\n *\n * The division operation in a field.\n * Satisfies 'x \/. y == x * (recip y)'\n *\n * Field division by 0 is undefined.\n *\/\nprimitive (\/.) : {a} (Field a) => a -> a -> a\n\n\n\/** Value types that can be rounded to integer values. *\/\nprimitive type Round : * -> Prop\n\n\/**\n * Ceiling function.\n *\n * Given 'x', compute the smallest integer 'i'\n * such that 'x <= i'.\n *\/\nprimitive ceiling : {a} (Round a) => a -> Integer\n\n\/**\n * Floor function.\n *\n * Given 'x', compute the largest integer 'i'\n * such that 'i <= x'.\n *\/\nprimitive floor : {a} (Round a) => a -> Integer\n\n\/**\n * Truncate the value toward 0.\n *\n * Given 'x' compute the nearest integer between\n * 'x' and 0.  For nonnegative 'x', this is floor,\n * and for negative 'x' this is ceiling.\n *\/\nprimitive trunc : {a} (Round a) => a -> Integer\n\n\/**\n * Round to the nearest integer, ties away from 0.\n *\n * Ties are broken away from 0.  For nonnegative 'x'\n * this is 'floor (x + 0.5)'.  For negative 'x' this\n * is 'ceiling (x - 0.5)'.\n *\/\nprimitive roundAway : {a} (Round a) => a -> Integer\n\n\/**\n * Round to the nearest integer, ties to even.\n *\n * Ties are broken to the nearest even integer.\n *\/\nprimitive roundToEven : {a} (Round a) => a -> Integer\n\n\n\/** Value types that support equality comparisons. *\/\nprimitive type Eq : * -> Prop\n\n\/**\n * Compares any two values of the same type for equality.\n *\/\nprimitive (==) : {a} (Eq a) => a -> a -> Bit\n\n\/**\n * Compares any two values of the same type for inequality.\n *\/\nprimitive (!=) : {a} (Eq a) => a -> a -> Bit\n\n\/**\n * Compare the outputs of two functions for equality.\n *\/\n(===) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\nf === g = \\ x -> f x == g x\n\n\/**\n * Compare the outputs of two functions for inequality.\n *\/\n(!==) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\nf !== g = \\x -> f x != g x\n\n\n\/** Value types that support equality and ordering comparisons. *\/\nprimitive type Cmp : * -> Prop\n\n\/**\n * Less-than. Only works on comparable arguments.\n *\n * Bitvectors are compared using unsigned arithmetic.\n *\/\nprimitive (<) : {a} (Cmp a) => a -> a -> Bit\n\n\/**\n * Greater-than of two comparable arguments.\n *\n * Bitvectors are compared using unsigned arithmetic.\n *\/\nprimitive (>) : {a} (Cmp a) => a -> a -> Bit\n\n\/**\n * Less-than or equal of two comparable arguments.\n *\n * Bitvectors are compared using unsigned arithmetic.\n *\/\nprimitive (<=) : {a} (Cmp a) => a -> a -> Bit\n\n\/**\n * Greater-than or equal of two comparable arguments.\n *\n * Bitvectors are compared using unsigned arithmetic.\n *\/\nprimitive (>=) : {a} (Cmp a) => a -> a -> Bit\n\n\/**\n * Returns the smaller of two comparable arguments.\n * Bitvectors are compared using unsigned arithmetic.\n *\/\nmin : {a} (Cmp a) => a -> a -> a\nmin x y = if x < y then x else y\n\n\/**\n * Returns the greater of two comparable arguments.\n * Bitvectors are compared using unsigned arithmetic.\n *\/\nmax : {a} (Cmp a) => a -> a -> a\nmax x y = if x > y then x else y\n\n\/**\n * Compute the absolute value of a value from an ordered ring.\n * Bitvector values are considered unsigned, so this is\n * the identity function on [n].\n *\/\nabs : {a} (Cmp a, Ring a) => a -> a\nabs x = if x < fromInteger 0 then negate x else x\n\n\n\/** Value types that support signed comparisons. *\/\nprimitive type SignedCmp : * -> Prop\n\n\/**\n * 2's complement signed less-than.\n *\/\nprimitive (<$) : {a} (SignedCmp a) => a -> a -> Bit\n\n\/**\n * 2's complement signed greater-than.\n *\/\n(>$) : {a} (SignedCmp a) => a -> a -> Bit\nx >$ y = y <$ x\n\n\/**\n * 2's complement signed less-than-or-equal.\n *\/\n(<=$) : {a} (SignedCmp a) => a -> a -> Bit\nx <=$ y = ~(y <$ x)\n\n\/**\n * 2's complement signed greater-than-or-equal.\n *\/\n(>=$) : {a} (SignedCmp a) => a -> a -> Bit\nx >=$ y = ~(x <$ y)\n\n\/**\n * The 'Option a' type represents an optional value. Every 'Option a' value is\n * either 'Some' and contains a value of type 'a', or 'None' and does not. Among\n * other uses, optional values are useful for modeling return values for partial\n * functions, i.e., functions that are not defined over their entire input\n * range. In these situations, 'None' can be used as a placeholder return value.\n *\/\nenum Option a = None | Some a\n\n\/**\n * Values of the 'Result t e' type can either be 'Ok', representing success and\n * containing a value of type 't', or 'Err', representing error and containing\n * an error value of type 'e'. Functions can return 'Result' whenever errors are\n * expected and recoverable. For instance, 'e' might be a 'String' with an error\n * message, or it might be an 'Integer' with an error code.\n *\/\nenum Result t e = Ok t | Err e\n\n\/**\n * The constant True. Corresponds to the bit value 1.\n *\/\nprimitive True  : Bit\n\n\/**\n * The constant False. Corresponds to the bit value 0.\n *\/\nprimitive False : Bit\n\n\/**\n * Short-cutting boolean conjunction function.\n * If the first argument is False, the second argument\n * is not evaluated.\n *\/\n(\/\\) : Bit -> Bit -> Bit\nx \/\\ y = if x then y else False\n\n\/**\n * Short-cutting boolean disjunction function.\n * If the first argument is True, the second argument\n * is not evaluated.\n *\/\n(\\\/) : Bit -> Bit -> Bit\nx \\\/ y = if x then True else y\n\n\/**\n * Short-cutting logical implication.\n * If the first argument is False, the second argument is\n * not evaluated.\n *\/\n(==>) : Bit -> Bit -> Bit\na ==> b = if a then b else True\n\n\n\/\/ Bitvector specific operations ----------------------------------\n\n\/**\n * 2's complement signed division.  Division rounds toward 0.\n *  Division by 0 is undefined.\n *\n *  * Satisfies 'x == x %$ y + (x \/$ y) * y' for 'y != 0'.\n *\/\nprimitive (\/$) : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\n\n\/**\n * 2's complement signed remainder.  Division rounds toward 0.\n * Division by 0 is undefined.  Satisfies the following for 'y != 0'\n *\n *  * 'x %$ y == x - (x \/$ y) * y'.\n *  * 'x >=$ 0 ==> x %$ y >=$ 0'\n *  * 'x <=$ 0 ==> x %$ y <=$ 0'\n *\/\nprimitive (%$) : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\n\n\/**\n * Unsigned carry.  Returns true if the unsigned addition of the given\n * bitvector arguments would result in an unsigned overflow.\n *\/\ncarry : {n} (fin n) => [n] -> [n] -> Bit\ncarry x y = (x + y) < x\n\n\/**\n * Signed carry.  Returns true if the 2's complement signed addition of the\n * given bitvector arguments would result in a signed overflow.\n *\/\nscarry : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nscarry x y = (sx == sy) && (sx != sz)\n  where\n    z  = x + y\n    sx = head x\n    sy = head y\n    sz = head z\n\n\/**\n * Signed borrow.  Returns true if the 2's complement signed subtraction of the\n * given bitvector arguments would result in a signed overflow.\n *\/\nsborrow : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsborrow x y = ( x <$ (x-y) ) ^ head y\n\n\/**\n * Zero extension of a bitvector.\n *\/\nzext : {m, n} (fin m, m >= n) => [n] -> [m]\nzext x = zero # x\n\n\/**\n * Sign extension of a bitvector.\n *\/\nsext : {m, n} (fin m, m >= n, n >= 1) => [n] -> [m]\nsext x = newbits # x\n  where newbits = if head x then ~zero else zero\n\n\/**\n * 2's complement signed (arithmetic) right shift.  The first argument\n * is the sequence to shift (considered as a signed value),\n * the second argument is the number of positions to shift\n * by (considered as an unsigned value).\n *\/\nprimitive (>>$) : {n, ix} (fin n, n >= 1, Integral ix) => [n] -> ix -> [n]\n\n\/**\n * The ceiling of the base-2 logarithm of an unsigned bitvector.\n * We set 'lg2 0 = 0'.\n *\/\nprimitive lg2 : {n} (fin n) => [n] -> [n]\n\n\/**\n * Convert a signed 2's complement bitvector to an integer.\n *\/\nprimitive toSignedInteger : {n} (fin n, n >= 1) => [n] -> Integer\n\n\n\/\/ Rational specific operations ----------------------------------------------\n\n\/**\n * Compute the ratio of two integers as a rational.\n * Ratio is undefined if the denominator is 0.\n *\n * 'ratio x y = (fromInteger x \/. fromInteger y) : Rational'\n *\/\nprimitive ratio : Integer -> Integer -> Rational\n\n\n\/\/ Zn specific operations ----------------------------------------------------\n\n\/**\n * Converts an integer modulo n to an unbounded integer in the range 0 to n-1.\n *\/\nprimitive fromZ : {n} (fin n, n >= 1) => Z n -> Integer\n\n\n\/\/ Sequence operations -------------------------------------------------------\n\n\/**\n * Concatenates two sequences.  On bitvectors, the most-significant bits\n * are in the left argument, and the least-significant bits are in the right.\n *\/\nprimitive (#) : {front, back, a} (fin front) => [front]a -> [back]a\n                                             -> [front + back] a\n\n\/**\n * Splits a sequence into a pair of sequences.\n * 'splitAt z = (x, y)' iff 'x # y = z'.\n *\/\nsplitAt : {front, back, a} (fin front) => [front + back]a\n                                       -> ([front]a, [back]a)\nsplitAt xs = (take`{front,back} xs, drop`{front,back} xs)\n\n\/**\n * Concatenates a list of sequences.\n * 'join' is the inverse function to 'split'.\n *\/\nprimitive join : {parts, each, a} (fin each) => [parts][each]a\n                                             -> [parts * each]a\n\n\/**\n * Splits a sequence into 'parts' groups with 'each' elements.\n * 'split' is the inverse function to 'join'.\n *\/\nprimitive split : {parts, each, a} (fin each) => [parts * each]a\n                                              -> [parts][each]a\n\n\/**\n * Reverses the elements in a sequence.\n *\/\nprimitive reverse : {n, a} (fin n) => [n]a -> [n]a\n\n\/**\n * Transposes a matrix.\n * Satisfies the property 'transpose m @ i @ j == m @ j @ i'.\n *\/\nprimitive transpose : {rows, cols, a} [rows][cols]a -> [cols][rows]a\n\n\/**\n * Select the first (left-most) 'front' elements of a sequence.\n *\/\nprimitive take : {front, back, a} [front + back]a -> [front]a\n\n\/**\n * Select all the elements after (to the right of) the 'front' elements of a sequence.\n *\/\nprimitive drop : {front, back, a} (fin front) => [front + back]a -> [back]a\n\n\/**\n * Drop the first (left-most) element of a sequence.\n *\/\ntail : {n, a} [1 + n]a -> [n]a\ntail xs = drop`{1} xs\n\n\/**\n * Return the first (left-most) element of a sequence.\n *\/\nhead : {n, a} [1 + n]a -> a\nhead xs = xs @ (0 : Integer)\n\n\/**\n * Return the right-most element of a sequence.\n *\/\nlast : {n, a} (fin n) => [1 + n]a -> a\nlast xs = xs ! (0 : Integer)\n\n\/**\n * Same as 'split', but with a different type argument order.\n * Take a sequence of elements and break it into 'parts' sequences\n * of 'each' elements.\n *\/\ngroupBy : {each, parts, a} (fin each) => [parts * each]a -> [parts][each]a\ngroupBy = split`{parts=parts}\n\n\/**\n * Left shift.  The first argument is the sequence to shift, the second is the\n * number of positions to shift by.\n *\/\nprimitive (<<) : {n, ix, a} (Integral ix, Zero a) => [n]a -> ix -> [n]a\n\n\/**\n * Right shift.  The first argument is the sequence to shift, the second is the\n * number of positions to shift by.\n *\/\nprimitive (>>) : {n, ix, a} (Integral ix, Zero a) => [n]a -> ix -> [n]a\n\n\/**\n * Left rotate.  The first argument is the sequence to rotate, the second is the\n * number of positions to rotate by.\n *\/\nprimitive (<<<) : {n, ix, a} (fin n, Integral ix) => [n]a -> ix -> [n]a\n\n\/**\n * Right rotate.  The first argument is the sequence to rotate, the second is\n * the number of positions to rotate by.\n *\/\nprimitive (>>>) : {n, ix, a} (fin n, Integral ix) => [n]a -> ix -> [n]a\n\n\/**\n * Index operator.  The first argument is a sequence.  The second argument is\n * the zero-based index of the element to select from the sequence.\n *\/\nprimitive (@) : {n, a, ix} (Integral ix) => [n]a -> ix -> a\n\n\/**\n * Bulk index operator.  The first argument is a sequence.  The second argument\n * is a sequence of the zero-based indices of the elements to select.\n *\/\n(@@) : {n, k, ix, a} (Integral ix) => [n]a -> [k]ix -> [k]a\nxs @@ is = [ xs @ i | i <- is ]\n\n\/**\n * Reverse index operator.  The first argument is a finite sequence.  The second\n * argument is the zero-based index of the element to select, starting from the\n * end of the sequence.\n *\/\nprimitive (!) : {n, a, ix} (fin n, Integral ix) => [n]a -> ix -> a\n\n\/**\n * Bulk reverse index operator.  The first argument is a finite sequence.  The\n * second argument is a sequence of the zero-based indices of the elements to\n * select, starting from the end of the sequence.\n *\/\n(!!) : {n, k, ix, a} (fin n, Integral ix) => [n]a -> [k]ix -> [k]a\nxs !! is = [ xs ! i | i <- is ]\n\n\/**\n * Update the given sequence with new value at the given index position.\n * The first argument is a sequence. The second argument is the zero-based\n * index of the element to update, starting from the front of the sequence.\n * The third argument is the new element.  The return value is the\n * initial sequence updated so that the indicated index has the given value.\n *\/\nprimitive update : {n, a, ix} (Integral ix) => [n]a -> ix -> a -> [n]a\n\n\/**\n * Update the given sequence with new value at the given index position.\n * The first argument is a sequence. The second argument is the zero-based\n * index of the element to update, starting from the end of the sequence.\n * The third argument is the new element.  The return value is the\n * initial sequence updated so that the indicated index has the given value.\n *\/\nprimitive updateEnd : {n, a, ix} (fin n, Integral ix) => [n]a -> ix -> a -> [n]a\n\n\/**\n * Perform a series of updates to a sequence.  The first argument is\n * the initial sequence to update.  The second argument is a sequence\n * of indices, and the third argument is a sequence of values.\n * This function applies the 'update' function in sequence with the\n * given update pairs.\n *\/\nupdates : {n, k, ix, a} (Integral ix, fin k) => [n]a -> [k]ix -> [k]a -> [n]a\nupdates xs0 idxs vals = foldl upd xs0 (zip idxs vals)\n  where\n    upd xs (i,b) = update xs i b\n\n\/**\n * Perform a series of updates to a sequence.  The first argument is\n * the initial sequence to update.  The second argument is a sequence\n * of indices, and the third argument is a sequence of values.\n * This function applies the 'updateEnd' function in sequence with the\n * given update pairs.\n *\/\nupdatesEnd : {n, k, ix, a} (fin n, Integral ix, fin k) => [n]a -> [k]ix -> [k]a -> [n]a\nupdatesEnd xs0 idxs vals = foldl upd xs0 (zip idxs vals)\n  where\n    upd xs (i,b) = updateEnd xs i b\n\n\/**\n * Produce a sequence using a generating function.\n * Satisfies 'generate f @ i == f i' for all 'i' between '0' and 'n-1'.\n *\n * Declarations of the form 'x @ i = e' are syntactic sugar for\n * 'x = generate (\\i -> e)'.\n *\/\ngenerate : {n, a, ix} (Integral ix, LiteralLessThan n ix) => (ix -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. <n] ]\n\n\n\/**\n * Sort a sequence of elements. Equivalent to 'sortBy (<=)'.\n *\/\nsort : {a, n} (Cmp a, fin n) => [n]a -> [n]a\nsort = sortBy (<=)\n\n\/**\n * Sort a sequence according to the given less-than-or-equal relation.\n * The sorting is stable, so it preserves the relative position of any\n * pair of elements that are equivalent according to the order relation.\n *\/\nsortBy : {a, n} (fin n) => (a -> a -> Bit) -> [n]a -> [n]a\nsortBy le ((xs : [n\/2]a) # (ys : [n\/^2]a)) = take zs.0\n  where\n    xs' = if `(n\/2)  == (1 : Integer) then xs else sortBy le xs\n    ys' = if `(n\/^2) == (1 : Integer) then ys else sortBy le ys\n    zs  = [ if i == `(n\/2)        then (ys'@j, i  , j+1)\n             | j == `(n\/^2)       then (xs'@i, i+1, j  )\n             | le (xs'@i) (ys'@j) then (xs'@i, i+1, j  )\n            else                       (ys'@j, i  , j+1)\n          | (_, i , j) <- [ (undefined, 0 : Integer, 0 : Integer) ] # zs\n          ]\n\n\/\/ GF_2^n polynomial computations -------------------------------------------\n\n\/**\n * Performs multiplication of polynomials over GF(2).\n *\/\nprimitive pmult : {u, v} (fin u, fin v) => [1 + u] -> [1 + v] -> [1 + u + v]\n\n\/**\n * Performs division of polynomials over GF(2).\n *\/\nprimitive pdiv : {u, v} (fin u, fin v) => [u] -> [v] -> [u]\n\n\/**\n * Performs modulus of polynomials over GF(2).\n *\/\nprimitive pmod : {u, v} (fin u, fin v) => [u] -> [1 + v] -> [v]\n\n\/\/ Experimental primitives ------------------------------------------------------------\n\n\/**\n * Parallel map.  The given function is applied to each element in the\n * given finite sequence, and the results are computed in parallel.\n * The values in the resulting sequence are reduced to normal form,\n * as is done with the deepseq operation.\n *\n * The Eq constraint restricts this operation to types\n * where reduction to normal form makes sense.\n *\n * This function is experimental.\n *\/\nprimitive parmap : {a, b, n} (Eq b, fin n) => (a -> b) -> [n]a -> [n]b\n\n\n\/\/ Utility operations -----------------------------------------------------------------\n\n\/**\n * A strictness-increasing operation.  The first operand\n * is reduced to normal form before evaluating the second\n * argument.\n *\n * The Eq constraint restricts this operation to types\n * where reduction to normal form makes sense.\n *\/\nprimitive deepseq : {a, b} Eq a => a -> b -> b\n\n\/**\n * Reduce to normal form.\n *\n * The Eq constraint restricts this operation to types\n * where reduction to normal form makes sense.\n *\/\nrnf : {a} Eq a => a -> a\nrnf x = deepseq x x\n\n\/**\n * Raise a run-time error with the given message.\n * This function can be called at any type.\n *\/\nprimitive error : {a, n} (fin n) => String n -> a\n\n\/**\n * Raise a run-time error with a generic message.\n * This function can be called at any type.\n *\/\nundefined : {a} a\nundefined = error \"undefined\"\n\n\/**\n * Assert that the given condition holds, and raise an error\n * with the given message if it does not.  If the condition\n * holds, return the third argument unchanged.\n *\/\nassert : {a, n} (fin n) => Bit -> String n -> a -> a\nassert pred msg x = if pred then x else error msg\n\n\/**\n * Generates random values from a seed.  When called with a function, currently\n * generates a function that always returns zero.\n *\/\nprimitive random : {a} [256] -> a\n\n\/**\n * Debugging function for tracing.  The first argument is a string,\n * which is prepended to the printed value of the second argument.\n * This combined string is then printed when the trace function is\n * evaluated.  The return value is equal to the third argument.\n *\n * The exact timing and number of times the trace message is printed\n * depend on the internal details of the Cryptol evaluation order,\n * which are unspecified.  Thus, the output produced by this\n * operation may be difficult to predict.\n *\/\nprimitive trace : {n, a, b} (fin n) => String n -> a -> b -> b\n\n\/**\n * Debugging function for tracing values.  The first argument is a string,\n * which is prepended to the printed value of the second argument.\n * This combined string is then printed when the trace function is\n * evaluated.  The return value is equal to the second argument.\n *\n * The exact timing and number of times the trace message is printed\n * depend on the internal details of the Cryptol evaluation order,\n * which are unspecified.  Thus, the output produced by this\n * operation may be difficult to predict.\n *\/\ntraceVal : {n, a} (fin n) => String n -> a -> a\ntraceVal msg x = trace msg x x\n\n\n\/* Functions previously in Cryptol::Extras *\/\n\n\/**\n * Conjunction of all bits in a sequence.\n *\/\nand : {n} (fin n) => [n]Bit -> Bit\nand xs = ~zero == xs\n\n\/**\n * Disjunction of all bits in a sequence.\n *\/\nor : {n} (fin n) => [n]Bit -> Bit\nor xs = zero != xs\n\n\/**\n * Conjunction after applying a predicate to all elements.\n *\/\nall : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nall f xs = foldl' (\/\\) True (map f xs)\n\n\/**\n * Disjunction after applying a predicate to all elements.\n *\/\nany : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nany f xs = foldl' (\\\/) False (map f xs)\n\n\/**\n * Map a function over a sequence.\n *\/\nmap : {n, a, b} (a -> b) -> [n]a -> [n]b\nmap f xs = [f x | x <- xs]\n\n\/**\n * Functional left fold.\n *\n * foldl (+) 0 [1,2,3] = ((0 + 1) + 2) + 3\n *\/\nprimitive foldl : {n, a, b} (fin n) => (a -> b -> a) -> a -> [n]b -> a\n\n\/**\n * Functional left fold, with strict evaluation of the accumulator value.\n * The accumulator is reduced to normal form at each step.  The Eq constraint\n * restricts the accumulator to types where reduction to normal form makes sense.\n *\n * foldl' (+) 0 [1,2,3] = ((0 + 1) + 2) + 3\n *\/\nprimitive foldl' : {n, a, b} (fin n, Eq a) => (a -> b -> a) -> a -> [n]b -> a\n\n\/**\n * Functional right fold.\n *\n * foldr (-) 0 [1,2,3] = 0 - (1 - (2 - 3))\n *\/\nfoldr : {n, a, b} (fin n) => (a -> b -> b) -> b -> [n]a -> b\nfoldr f acc xs = foldl g acc (reverse xs)\n  where g b a = f a b\n\n\/**\n * Functional right fold, with strict evaluation of the accumulator value.\n * The accumulator is reduced to weak head normal form at each step.\n *\n * foldr' (-) 0 [1,2,3] = 0 - (1 - (2 - 3))\n *\/\nfoldr' : {n, a, b} (fin n, Eq b) => (a -> b -> b) -> b -> [n]a -> b\nfoldr' f acc xs = foldl' g acc (reverse xs)\n  where g b a = f a b\n\n\/**\n * Compute the sum of the values in the sequence.\n *\/\nsum : {n, a} (fin n, Eq a, Ring a) => [n]a -> a\nsum xs = foldl' (+) (fromInteger 0) xs\n\n\/**\n * Compute the product of the values in the sequence.\n *\/\nproduct : {n, a} (fin n, Eq a, Ring a) => [n]a -> a\nproduct xs = foldl' (*) (fromInteger 1) xs\n\n\/**\n * Scan left is like a foldl that also emits the intermediate values.\n *\/\nprimitive scanl : {n, a, b}  (a -> b -> a) -> a -> [n]b -> [1+n]a\n\n\/**\n * Scan right is like a foldr that also emits the intermediate values.\n *\/\nscanr : {n, a, b} (fin n) => (a -> b -> b) -> b -> [n]a -> [1+n]b\nscanr f acc xs = reverse (scanl (\\a b -> f b a) acc (reverse xs))\n\n\/**\n * Repeat a value.\n *\/\nrepeat : {n, a} a -> [n]a\nrepeat x = [ x | _ <- zero : [n] ]\n\n\/**\n * 'elem x xs' returns true if x is equal to a value in xs.\n *\/\nelem : {n, a} (fin n, Eq a) => a -> [n]a -> Bit\nelem a xs = any (\\x -> x == a) xs\n\n\/**\n * Create a list of tuples from two lists.\n *\/\nzip : {n, a, b} [n]a -> [n]b -> [n](a, b)\nzip xs ys = [(x,y) | x <- xs | y <- ys]\n\n\/**\n * Create a list by applying the function to each pair of elements in the input.\n *\/\nzipWith : {n, a, b, c} (a -> b -> c) -> [n]a -> [n]b -> [n]c\nzipWith f xs ys = [f x y | x <- xs | y <- ys]\n\n\/**\n * Transform a function into uncurried form.\n *\/\nuncurry : {a, b, c} (a -> b -> c) -> (a, b) -> c\nuncurry f = \\(a, b) -> f a b\n\n\/**\n * Transform a function into curried form.\n *\/\ncurry : {a, b, c} ((a, b) -> c) -> a -> b -> c\ncurry f = \\a b -> f (a, b)\n\n\/**\n * Map a function iteratively over a seed value, producing an infinite\n * list of successive function applications.\n *\/\niterate : {a} (a -> a) -> a -> [inf]a\niterate f z = scanl (\\x _ -> f x) z (zero:[inf]())\n```"}]}
{"filename":"cryptol\/bench\/data\/SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the SHA-512 hash function implementation in the provided SHA512.cry module. Include test vectors and properties that check the output hash against known correct SHA-512 hash values for given inputs, ensuring the implementation matches the SHA-512 specification."},{"role":"assistant","content":"```cryptol\n\/\/ Provided by @sdwelle as a performance regression in issue #269\n\nmodule SHA512 where\n\n\/*\nsha512 : {b, a} (a*1024 == 128 + b + 1 + 1024 - (b+129) % 1024,\n                 a*1024 % 1024 == 0,\n                 a * 1024 - b >= 129,\n                 2^^128 - 1 >= b,\n                 fin (a + 1)) => [b] -> [512]\n\n                 *\/\nsha512 M = result\n  where\n    M' = (pad M)\n    blocks = (groupBy`{1024} M')\n    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]\n    result = (join (hash!0))\n\nprocessBlock : [1024] -> [8][64] -> [8][64]\nprocessBlock block Hprev = Hs\n  where\n    Mi = split block : [16][64]\n    Ws = (messageSch Mi)\n    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]\n    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]\n\nstep : [8][64] -> [64] -> [8] -> [8][64]\nstep [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']\n  where\n    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt\n    T2 = (SIGMA0 a) + (Maj a b c)\n    h' = g\n    g' = f\n    f' = e\n    e' = d + T1\n    d' = c\n    c' = b\n    b' = a\n    a' = T1 + T2\n\nmessageSch : [16][64] -> [80][64]\nmessageSch Mi = W\n  where\n    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]\n\npad : {l, k} (fin l,\n              l <= ((2^^128) - 1),\n              l >= 0,\n              fin k,\n              k - l >= 129,\n              k == 128 + l + 1 + 1024 - ((l+129)%1024),\n              k%1024 == 0) => [l] -> [k]\npad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])\n\nCh : [64] -> [64] -> [64] -> [64]\nCh x y z = (x && y) ^ ((~x) && z)\n\nMaj : [64] -> [64] -> [64] -> [64]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nSIGMA0 : [64] -> [64]\nSIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)\n\nSIGMA1 : [64] -> [64]\nSIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)\n\nsigma0 : [64] -> [64]\nsigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)\n\nsigma1 : [64] -> [64]\nsigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)\n\nH0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]\n\nK = [\n0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n]\n\n\nproperty testVector1 x = sha512 0xfd2203e467574e834ab07c9097ae164532f24be1eb5d88f1af7748ceff0d2c67a21f4e4097f9d3bb4e9fbf97186e0db6db0100230a52b453d421f8ab9c9a6043aa3295ea20d2f06a2f37470d8a99075f1b8a8336f6228cf08b5942fc1fb4299c7d2480e8e82bce175540bdfad7752bc95b577f229515394f3ae5cec870a4b2f8 == 0xa21b1077d52b27ac545af63b32746c6e3c51cb0cb9f281eb9f3580a6d4996d5c9917d2a6e484627a9d5a06fa1b25327a9d710e027387fc3e07d7c4d14c6086cc\n```"}]}
{"filename":"cryptol\/rust\/cry-ffi\/Example.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that each foreign abstract function in the Example module behaves as an identity function on its input type, ensuring that the output matches the input for all valid inputs."},{"role":"assistant","content":"```cryptol\nmodule Example where\n\nimport Float\n\nnewtype N = { unN : [8] }\n\nforeign abstract test_bool : Bit -> Bit\nforeign abstract test_u8 : [8] -> [8]\nforeign abstract test_u16 : [16] -> [16]\nforeign abstract test_u32 : [32] -> [32]\nforeign abstract test_u64 : [64] -> [64]\nforeign abstract test_u128 : [128] -> [128]\nforeign abstract test_i8 : [8] -> [8]\nforeign abstract test_i16 : [16] -> [16]\nforeign abstract test_i32 : [32] -> [32]\nforeign abstract test_i64 : [64] -> [64]\nforeign abstract test_i128 : [128] -> [128]\nforeign abstract test_integer : Integer -> Integer\nforeign abstract test_rational : Rational -> Rational\nforeign abstract test_float : Float32 -> Float32\nforeign abstract test_double : Float64 -> Float64\nforeign abstract test_array_16_u8 : [16][8] -> [16][8]\nforeign abstract test_record0 : {} -> {}\nforeign abstract test_record1_u8 : { x : [8] } -> { x : [8] }\nforeign abstract test_record2_u8_u16 : { x : [8], y : [16] } -> { x : [8], y : [16] }\nforeign abstract test_tuple0 : () -> ()\nforeign abstract test_tuple2_u8_u16 : ([8], [16]) -> ([8], [16])\nforeign abstract test_newtype_u8 : N -> N\nforeign abstract test_option_u8 : Option [8] -> Option [8]\nforeign abstract test_result_u16_u32 : Result [16] [32] -> Result [16] [32]\nforeign abstract test_two_u8_args : [8] -> [8] -> [8]\nforeign abstract test_two_u128_res : [128] -> ([128], [128])\nforeign abstract test_z7 : Z 7 -> Z 7\nforeign abstract test_param : {n} (fin n, n >= 1) => Z n\n```"}]}
{"filename":"cryptol\/tests\/modsys\/T007.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property to verify that the submodule M correctly instantiates submodule F with the parameters from submodule I, ensuring that the output y equals x + 11 for the given x and n."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type n : #\n    x      : [n]\n    type constraint (fin n, n >= 4)\n\n  y : [n]\n  y = x + 11\n\n\nsubmodule I where\n  type n = 8\n  x = 2\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/enum\/CheckEnumPartialError.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that verify whether the functions 'maybeMapBad1', 'maybeMapBad2', 'fooBad1', and 'fooGood' handle all possible cases of their input types correctly, ensuring totality and absence of partial pattern match errors."},{"role":"assistant","content":"```cryptol\nenum Maybe a = Nothing | Just a\n\nmaybeMapBad1 : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMapBad1 f m =\n  case m of\n    Just x -> Just (f x)\n\nmaybeMapBad2 : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMapBad2 f m =\n  case m of\n    Nothing -> Nothing\n\nenum Foo = A | B | C\n\nfooBad1 : Foo -> ()\nfooBad1 f =\n  case f of\n    A -> ()\n\nfooGood : Foo -> ()\nfooGood f =\n  case f of\n    A -> ()\n    _ -> ()\n```"}]}
{"filename":"cryptol\/tests\/enum\/CheckProveEnum.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the equality and mapping functions defined for the enumerated types Maybe, Either, Foo, and Letter. Specifically, create properties that check the equivalence relations for equality functions and the compositional behavior of the mapping functions (e.g., that mapping with two successive functions is equivalent to mapping with their composition). Also, verify that the letterRotate function cycles through all Letter values correctly. Use the existing equality functions to express these properties and ensure they hold for all inputs."},{"role":"assistant","content":"```cryptol\nenum Maybe a = Nothing | Just a\n\nmaybeEqual : {a} (Eq a) => Maybe a -> Maybe a -> Bit\nmaybeEqual m1 m2 =\n  case m1 of\n    Just x1 ->\n      case m2 of\n        Just x2 -> x1 == x2\n        Nothing -> False\n    Nothing ->\n      case m2 of\n        Just x2 -> False\n        Nothing -> True\n\nmaybeMap : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMap f m =\n  case m of\n    Just x  -> Just (f x)\n    Nothing -> Nothing\n\nmaybeMapProp : Maybe [8] -> Bit\nproperty maybeMapProp m =\n  maybeEqual\n    (maybeMap (\\x -> x + 1) (maybeMap (\\x -> x + 1) m))\n    (maybeMap (\\x -> x + 2) m)\n\nenum Either a b = Left a | Right b\n\neitherEqual : {a, b} (Eq a, Eq b) => Either a b -> Either a b -> Bit\neitherEqual e1 e2 =\n  case e1 of\n    Left x1 ->\n      case e2 of\n        Left x2  -> x1 == x2\n        Right y2 -> False\n    Right y1 ->\n      case e2 of\n        Left x2  -> False\n        Right y2 -> y1 == y2\n\neitherMapLeft : {a, a', b} (a -> a') -> Either a b -> Either a' b\neitherMapLeft f e =\n  case e of\n    Left x  -> Left (f x)\n    Right y -> Right y\n\neitherMapRight : {a, b, b'} (b -> b') -> Either a b -> Either a b'\neitherMapRight g e =\n  case e of\n    Left x  -> Left x\n    Right y -> Right (g y)\n\neitherMapBoth : {a, a', b, b'} (a -> a') -> (b -> b') -> Either a b -> Either a' b'\neitherMapBoth f g e =\n  case e of\n    Left x  -> Left (f x)\n    Right y -> Right (g y)\n\neitherMapProp : Either [8] [8] -> Bit\nproperty eitherMapProp e =\n  eitherEqual\n    (eitherMapLeft (\\x -> x + 1) (eitherMapRight (\\y -> y + 1) e))\n    (eitherMapBoth (\\x -> x + 1) (\\y -> y + 1) e)\n\nenum Foo a = Bar | Baz | Quux | Fred [8] a\n\nfooEqual : {a} (Eq a) => Foo a -> Foo a -> Bit\nfooEqual f1 f2 =\n  case f1 of\n    Bar ->\n      case f2 of\n        Bar        -> True\n        Baz        -> False\n        Quux       -> False\n        Fred y1 y2 -> False\n    Baz ->\n      case f2 of\n        Bar        -> False\n        Baz        -> True\n        Quux       -> False\n        Fred y1 y2 -> False\n    Quux ->\n      case f2 of\n        Bar        -> False\n        Baz        -> False\n        Quux       -> True\n        Fred y1 y2 -> False\n    Fred x1 x2 ->\n      case f2 of\n        Bar        -> False\n        Baz        -> False\n        Quux       -> False\n        Fred y1 y2 -> (x1 == y1) \/\\ (x2 == y2)\n\nfooMap : {a, b} (a -> b) -> Foo a -> Foo b\nfooMap f ff =\n  case ff of\n    Bar      -> Bar\n    Baz      -> Baz\n    Quux     -> Quux\n    Fred x y -> Fred x (f y)\n\nfooMapProp : Foo [8] -> Bit\nproperty fooMapProp f =\n  fooEqual\n    (fooMap (\\x -> x + 1) (fooMap (\\x -> x + 1) f))\n    (fooMap (\\x -> x + 2) f)\n\nenum Letter = A | B | C\n\nletterEqual : Letter -> Letter -> Bit\nletterEqual l1 l2 =\n  case l1 of\n    A ->\n      case l2 of\n        A -> True\n        B -> False\n        C -> False\n    B ->\n      case l2 of\n        A -> False\n        B -> True\n        C -> False\n    C ->\n      case l2 of\n        A -> False\n        B -> False\n        C -> True\n\nletterRotate : Letter -> Letter\nletterRotate l =\n  case l of\n    A -> B\n    B -> C\n    C -> A\n\nletterRotateProp : Letter -> Bit\nproperty letterRotateProp l =\n  letterEqual l (letterRotate (letterRotate (letterRotate l)))\n```"}]}
{"filename":"cryptol\/tests\/parser\/tuples-records.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and structural integrity of tuples and records defined in the given code snippet. Include checks for element values, nesting correctness, and handling of empty tuples and records."},{"role":"assistant","content":"```cryptol\n\/\/ Tuples\ntuple           = (0xFF, 0xFF)\nnested_tuple1   = (0xFF, (0xFF,0xFF))\nnested_tupel2   = ((0xFF,0xFF), 0xFF)\nempty_tuple     = ()\n\n\/\/ Records\nrecord          = { x = 0xFF, y = 0xFF }\nnested_record   = { x = 0xFF, y = { x = 0xFF, y = 0xFF }}\nempty_records   = {}\n```"}]}
{"filename":"cryptol\/tests\/parser\/docs.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that verify the correctness and expected behavior of the functions and properties defined in the given Cryptol code, ensuring that the documented signatures and bindings behave as specified."},{"role":"assistant","content":"```cryptol\n\/**\n * Test that doc strings work on signatures\n *\/\ntest1 : Bit\ntest1 = True\n\n\/**\n * Test that doc strings work on value bindings\n *\/\ntest2 = True\n\n\/**\n * Test that doc strings work on function bindings\n *\/\ntest3 x = x\n\n\/**\n * Test that doc strings work on property declarations\n *\/\nproperty test4 x = (x : Bit)\n\n\/**\n * Test that doc strings work on fixity declarations\n *\/\ninfixl 5 ++\n\n(++) : {a} a -> a -> a\nx ++ _ = x\n\n\/**\n * Test that doc strings are preserved on private declarations\n *\/\nprivate test5 = ()\n\n\n\/**\n * Test that doc strings are preserved on type synonyms\n *\/\ntype Foo = ()\n```"}]}
{"filename":"cryptol\/tests\/parser\/T437.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the 'mk_buggy_fib_no_init' function, ensuring it computes Fibonacci numbers correctly except for the intentional bug triggered by the 'magic' value. Additionally, specify properties to check that 'generate' produces sequences consistent with the expected Fibonacci sequence for 'foo' and 'bar'."},{"role":"assistant","content":"```cryptol\nmk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n  \/\/ Change output when state has magic value.\n  fn' = fn + if k == magic then 1 else 0\n\ngenerate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. n-1] ]\n\ninfixl 1 $\nf $ x = f x\n\nfoo : [10][4]\nfoo = generate $ \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n\nbar : [10][4]\nbar = generate \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n```"}]}
{"filename":"cryptol\/tests\/parser\/unary.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the unary operators '~' (bitwise complement) and '-' (negation) are parsed and evaluated correctly in expressions, ensuring that operator precedence and associativity behave as expected."},{"role":"assistant","content":"```cryptol\n\/\/ test that the unary operators parse correctly\ntest1 = (~ (5 : [8]) + 2) == (~ (5 : [8])) + 2\ntest2 = (- (5 : [8]) + 2) == (- (5 : [8])) + 2\n```"}]}
{"filename":"cryptol\/tests\/parser\/pat1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of pattern matching in functions f1 through f7. Ensure that each function correctly extracts or manipulates components of tuples, sequences, and records as intended by their pattern definitions. The properties should cover various input cases to confirm that the pattern matching behaves as specified."},{"role":"assistant","content":"```cryptol\nf1 (x,y) = x\nf2 (x # y) = x\nf3 [x,y,z] = x + y + z\nf4 {x = a, y = b } = a\nf5 ((x : [8]) # (y : [10])) = x # y : [10]\nf6 (x # y : [10]) = x\nf7 (x # (y : [10])) = x\n```"}]}
{"filename":"cryptol\/tests\/parser\/infix-1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the custom infix operators '++' and '**' behave as expected. Specifically, ensure that '++' correctly implements addition on 8-bit words, and '**' correctly implements multiplication for any type 'a' that satisfies the Ring interface. Include tests for associativity and precedence according to their declared fixity."},{"role":"assistant","content":"```cryptol\ninfixl 4 ++\ninfixl 5 **\n\n(++) : [8] -> [8] -> [8]\nx ++ y = x + y\n\n(**) : {a} (Ring a) => a -> a -> a\nx ** y = x * y\n```"}]}
{"filename":"cryptol\/tests\/parser\/applications.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the functions 'g' and 'f' and the arithmetic expressions 'app1' through 'app9'. The properties should check that 'g' returns its input unchanged, 'f' returns its second argument, and that the arithmetic expressions evaluate to the expected values according to Cryptol's semantics."},{"role":"assistant","content":"```cryptol\ng x   = x\nf x y = y\n\napp1 = g 0xFF\napp2 = f 0xFF 0xFF\napp3 = 0xFF + 0xFF\napp4 = 0x01 + 0x02 + 0x03\napp5 = 0x01 + 0x02 * 0x03\napp6 = 0x01 * 0x02 + 0x03\napp7 = 0x01 * g 0xFF + 0x02\napp8 = f (0x01 * g 0xFF + 0x02) 0xFF\napp9 = g (g 0xFF)\n```"}]}
{"filename":"cryptol\/tests\/suiteb\/aes-mct-ecb.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the AES Monte Carlo Test (MCT) ECB mode encryption and decryption functions for 128-bit, 192-bit, and 256-bit keys produce outputs matching the provided test vectors. Specifically, create properties that assert the correctness of `mct_ecb_encrypt_128`, `mct_ecb_decrypt_128`, `mct_ecb_encrypt_192`, `mct_ecb_decrypt_192`, `mct_ecb_encrypt_256`, and `mct_ecb_decrypt_256` against their corresponding known test vectors."},{"role":"assistant","content":"```cryptol\nimport SuiteB\n\n\n\/\/ ***********************************************************************\n\/\/ ** Additional pseudorandom sample test vectors, using the ECB MCT test\n\/\/ ** https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/aes\/aesmct.zip\n\/\/ **\n\/\/ ** See AESAVS Section 6.4.1 for a description of the test algorithm\n\/\/ ***********************************************************************\n\ntype AESTestVector n =\n  { key        : [n]\n  , plaintext  : [128]\n  , ciphertext : [128]\n  }\n\n\nmct_ecb_encrypt_128 : [128] -> [128] -> [100](AESTestVector 128)\nmct_ecb_encrypt_128 initialKey initialPt = vs\n  where\n  vs@i = { key = keys@i, plaintext=pts@(i*1000), ciphertext=cts@(i*1000 + 999) }\n\n  pts : [100*1000][128]\n  pts = [initialPt] # take cts\n\n  cts : [100*1000][128]\n  cts@i = aesEncryptBlock (schedules@(i\/1000)) (pts@i)\n\n  keys : [100][128]\n  keys = [initialKey] # [ k ^ (xs!0)\n                        | xs <- take`{99} (groupBy`{1000} cts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESEncryptKeySchedule AES128)\n  schedules = map aes128EncryptSchedule keys\n\n\nmct_ecb_decrypt_128 : [128] -> [128] -> [100](AESTestVector 128)\nmct_ecb_decrypt_128 initialKey initialCt = vs\n  where\n  vs@i = { key = keys@i, ciphertext=cts@(i*1000), plaintext=pts@(i*1000 + 999) }\n\n  cts : [100*1000][128]\n  cts = [initialCt] # take pts\n\n  pts : [100*1000][128]\n  pts@i = aesDecryptBlock (schedules@(i\/1000)) (cts@i)\n\n  keys : [100][128]\n  keys = [initialKey] # [ k ^ (xs!0)\n                        | xs <- take`{99} (groupBy`{1000} pts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESDecryptKeySchedule AES128)\n  schedules = map aes128DecryptSchedule keys\n\nproperty aes128_MCT_vectors_encrypt_correct =\n  aes128_MCT_encrypt_test_vectors ==\n  mct_ecb_encrypt_128 0x139a35422f1d61de3c91787fe0507afd 0xb9145a768b7dc489a096b546f43b231f\n\nproperty aes128_MCT_vectors_decrypt_correct =\n  aes128_MCT_decrypt_test_vectors ==\n  mct_ecb_decrypt_128 0x0c60e7bf20ada9baa9e1ddf0d1540726 0xb08a29b11a500ea3aca42c36675b9785\n\naes128_MCT_encrypt_test_vectors : [100](AESTestVector 128)\naes128_MCT_encrypt_test_vectors =\n [{ key = 0x139a35422f1d61de3c91787fe0507afd\n  , plaintext = 0xb9145a768b7dc489a096b546f43b231f\n  , ciphertext = 0xd7c3ffac9031238650901e157364c386\n  },\n\n  { key = 0xc459caeebf2c42586c01666a9334b97b\n  , plaintext = 0xd7c3ffac9031238650901e157364c386\n  , ciphertext = 0xbc3637da2daf8fcf7c68bb28c143a0a4\n  },\n\n  { key = 0x786ffd349283cd971069dd42527719df\n  , plaintext = 0xbc3637da2daf8fcf7c68bb28c143a0a4\n  , ciphertext = 0x9c88a8db798f48df1ac4936afa959eac\n  },\n\n  { key = 0xe4e755efeb0c85480aad4e28a8e28773\n  , plaintext = 0x9c88a8db798f48df1ac4936afa959eac\n  , ciphertext = 0xb87aaa1c76a775d94c2ddf82abe5c66e\n  },\n\n  { key = 0x5c9dfff39dabf091468091aa0307411d\n  , plaintext = 0xb87aaa1c76a775d94c2ddf82abe5c66e\n  , ciphertext = 0x79ee212734f14d1bf5a59d46e8c2fa34\n  },\n\n  { key = 0x2573ded4a95abd8ab3250cecebc5bb29\n  , plaintext = 0x79ee212734f14d1bf5a59d46e8c2fa34\n  , ciphertext = 0x09df49135aeb8e373a19fa457ab280a0\n  },\n\n  { key = 0x2cac97c7f3b133bd893cf6a991773b89\n  , plaintext = 0x09df49135aeb8e373a19fa457ab280a0\n  , ciphertext = 0xc52263efa6379209d17e87ac250615cb\n  },\n\n  { key = 0xe98ef4285586a1b458427105b4712e42\n  , plaintext = 0xc52263efa6379209d17e87ac250615cb\n  , ciphertext = 0x336bed017e10a247ee92989862431163\n  },\n\n  { key = 0xdae519292b9603f3b6d0e99dd6323f21\n  , plaintext = 0x336bed017e10a247ee92989862431163\n  , ciphertext = 0xb13310581ffe5b10aaefdeb8992aec18\n  },\n\n  { key = 0x6bd60971346858e31c3f37254f18d339\n  , plaintext = 0xb13310581ffe5b10aaefdeb8992aec18\n  , ciphertext = 0xb0eaede3f3eebfef88822a6ede1950b1\n  },\n\n  { key = 0xdb3ce492c786e70c94bd1d4b91018388\n  , plaintext = 0xb0eaede3f3eebfef88822a6ede1950b1\n  , ciphertext = 0x37891fc253b00de13155d5517e1b7890\n  },\n\n  { key = 0xecb5fb509436eaeda5e8c81aef1afb18\n  , plaintext = 0x37891fc253b00de13155d5517e1b7890\n  , ciphertext = 0x8f574c85fa44af2d43c95ee5f627fc9d\n  },\n\n  { key = 0x63e2b7d56e7245c0e62196ff193d0785\n  , plaintext = 0x8f574c85fa44af2d43c95ee5f627fc9d\n  , ciphertext = 0x6c0af6709225f328a0225b2280efa3e3\n  },\n\n  { key = 0x0fe841a5fc57b6e84603cddd99d2a466\n  , plaintext = 0x6c0af6709225f328a0225b2280efa3e3\n  , ciphertext = 0xe2dc36073fe192e712373a8702e8adce\n  },\n\n  { key = 0xed3477a2c3b6240f5434f75a9b3a09a8\n  , plaintext = 0xe2dc36073fe192e712373a8702e8adce\n  , ciphertext = 0x1e91d1e1f82f1d320186210a792f7ba1\n  },\n\n  { key = 0xf3a5a6433b99393d55b2d650e2157209\n  , plaintext = 0x1e91d1e1f82f1d320186210a792f7ba1\n  , ciphertext = 0x228eac74166da261d7fa83f43d9ddd2f\n  },\n\n  { key = 0xd12b0a372df49b5c824855a4df88af26\n  , plaintext = 0x228eac74166da261d7fa83f43d9ddd2f\n  , ciphertext = 0x25d0de6a894361a1b83d5fa2fd607f26\n  },\n\n  { key = 0xf4fbd45da4b7fafd3a750a0622e8d000\n  , plaintext = 0x25d0de6a894361a1b83d5fa2fd607f26\n  , ciphertext = 0x36095dc3e659ec50ca7f6f8207d20031\n  },\n\n  { key = 0xc2f2899e42ee16adf00a6584253ad031\n  , plaintext = 0x36095dc3e659ec50ca7f6f8207d20031\n  , ciphertext = 0x8dbfe965078468875d86145164c4ab4f\n  },\n\n  { key = 0x4f4d60fb456a7e2aad8c71d541fe7b7e\n  , plaintext = 0x8dbfe965078468875d86145164c4ab4f\n  , ciphertext = 0x4032bb8137d4b9eb93644359a995bb4e\n  },\n\n  { key = 0x0f7fdb7a72bec7c13ee8328ce86bc030\n  , plaintext = 0x4032bb8137d4b9eb93644359a995bb4e\n  , ciphertext = 0x85308aa92c625a25bd5f4a40375c6baa\n  },\n\n  { key = 0x8a4f51d35edc9de483b778ccdf37ab9a\n  , plaintext = 0x85308aa92c625a25bd5f4a40375c6baa\n  , ciphertext = 0x73283fc59e04e80a867e478d97a3f388\n  },\n\n  { key = 0xf9676e16c0d875ee05c93f4148945812\n  , plaintext = 0x73283fc59e04e80a867e478d97a3f388\n  , ciphertext = 0x418c1fe377e4ef9832f20286b167f916\n  },\n\n  { key = 0xb8eb71f5b73c9a76373b3dc7f9f3a104\n  , plaintext = 0x418c1fe377e4ef9832f20286b167f916\n  , ciphertext = 0x60ad1341525e67cffdd68ff671253c77\n  },\n\n  { key = 0xd84662b4e562fdb9caedb23188d69d73\n  , plaintext = 0x60ad1341525e67cffdd68ff671253c77\n  , ciphertext = 0x4edf6e01a76de6153d17713a49d5b028\n  },\n\n  { key = 0x96990cb5420f1bacf7fac30bc1032d5b\n  , plaintext = 0x4edf6e01a76de6153d17713a49d5b028\n  , ciphertext = 0x2c85ebf9e3d80596f78712df56ac77cd\n  },\n\n  { key = 0xba1ce74ca1d71e3a007dd1d497af5a96\n  , plaintext = 0x2c85ebf9e3d80596f78712df56ac77cd\n  , ciphertext = 0x8fc8ef9ab7462712977e87c741795ece\n  },\n\n  { key = 0x35d408d61691392897035613d6d60458\n  , plaintext = 0x8fc8ef9ab7462712977e87c741795ece\n  , ciphertext = 0x37e9ac800cfb19133b4e9b0c418ca098\n  },\n\n  { key = 0x023da4561a6a203bac4dcd1f975aa4c0\n  , plaintext = 0x37e9ac800cfb19133b4e9b0c418ca098\n  , ciphertext = 0xcb7cd7619caa605e45f95f5b31a85495\n  },\n\n  { key = 0xc941733786c04065e9b49244a6f2f055\n  , plaintext = 0xcb7cd7619caa605e45f95f5b31a85495\n  , ciphertext = 0x6e265e5fd030847b8841bf6652996392\n  },\n\n  { key = 0xa7672d6856f0c41e61f52d22f46b93c7\n  , plaintext = 0x6e265e5fd030847b8841bf6652996392\n  , ciphertext = 0x5c9a7d2ce1c86f0b3425b3b6aae108e0\n  },\n\n  { key = 0xfbfd5044b738ab1555d09e945e8a9b27\n  , plaintext = 0x5c9a7d2ce1c86f0b3425b3b6aae108e0\n  , ciphertext = 0xc911dee5ff318a7e799f92daadcb3d9a\n  },\n\n  { key = 0x32ec8ea14809216b2c4f0c4ef341a6bd\n  , plaintext = 0xc911dee5ff318a7e799f92daadcb3d9a\n  , ciphertext = 0x7a3afdf10410f1c47c7d928d4a8d432a\n  },\n\n  { key = 0x48d673504c19d0af50329ec3b9cce597\n  , plaintext = 0x7a3afdf10410f1c47c7d928d4a8d432a\n  , ciphertext = 0xc681b7b6d3ec9dc91012e3b7427c67ad\n  },\n\n  { key = 0x8e57c4e69ff54d6640207d74fbb0823a\n  , plaintext = 0xc681b7b6d3ec9dc91012e3b7427c67ad\n  , ciphertext = 0xcd3f84bbe958536d502065eb37ae10b4\n  },\n\n  { key = 0x4368405d76ad1e0b1000189fcc1e928e\n  , plaintext = 0xcd3f84bbe958536d502065eb37ae10b4\n  , ciphertext = 0x879db797e686b9116c25c07f4ae67593\n  },\n\n  { key = 0xc4f5f7ca902ba71a7c25d8e086f8e71d\n  , plaintext = 0x879db797e686b9116c25c07f4ae67593\n  , ciphertext = 0x5959ebd7a1167713429eda69538c536b\n  },\n\n  { key = 0x9dac1c1d313dd0093ebb0289d574b476\n  , plaintext = 0x5959ebd7a1167713429eda69538c536b\n  , ciphertext = 0xf57101d7fa19f97a31d60b276312717c\n  },\n\n  { key = 0x68dd1dcacb2429730f6d09aeb666c50a\n  , plaintext = 0xf57101d7fa19f97a31d60b276312717c\n  , ciphertext = 0x6dfbbc2b147568c55adbfdc3c706edb0\n  },\n\n  { key = 0x0526a1e1df5141b655b6f46d716028ba\n  , plaintext = 0x6dfbbc2b147568c55adbfdc3c706edb0\n  , ciphertext = 0x9c4ea9002306d75e7b0f03e2a72b7a1d\n  },\n\n  { key = 0x996808e1fc5796e82eb9f78fd64b52a7\n  , plaintext = 0x9c4ea9002306d75e7b0f03e2a72b7a1d\n  , ciphertext = 0xcb9975336cc05f0114f26bde4cc84f8d\n  },\n\n  { key = 0x52f17dd29097c9e93a4b9c519a831d2a\n  , plaintext = 0xcb9975336cc05f0114f26bde4cc84f8d\n  , ciphertext = 0x902c4250cff110d792938e8dcd534cf0\n  },\n\n  { key = 0xc2dd3f825f66d93ea8d812dc57d051da\n  , plaintext = 0x902c4250cff110d792938e8dcd534cf0\n  , ciphertext = 0x140242f195ef2ef7f6ee23574c071311\n  },\n\n  { key = 0xd6df7d73ca89f7c95e36318b1bd742cb\n  , plaintext = 0x140242f195ef2ef7f6ee23574c071311\n  , ciphertext = 0x3c6d4ffafde866f1e994480c47d20a04\n  },\n\n  { key = 0xeab2328937619138b7a279875c0548cf\n  , plaintext = 0x3c6d4ffafde866f1e994480c47d20a04\n  , ciphertext = 0x1ca04a21addc38ef8bfc8989d3d6b33b\n  },\n\n  { key = 0xf61278a89abda9d73c5ef00e8fd3fbf4\n  , plaintext = 0x1ca04a21addc38ef8bfc8989d3d6b33b\n  , ciphertext = 0xbb8875ee3c3c8c0987b1c20f999028e9\n  },\n\n  { key = 0x4d9a0d46a68125debbef32011643d31d\n  , plaintext = 0xbb8875ee3c3c8c0987b1c20f999028e9\n  , ciphertext = 0x9d33724d80a76f2033a37a851403ef28\n  },\n\n  { key = 0xd0a97f0b26264afe884c488402403c35\n  , plaintext = 0x9d33724d80a76f2033a37a851403ef28\n  , ciphertext = 0x4c92fe152d16da8ea59b9f29c75f20ff\n  },\n\n  { key = 0x9c3b811e0b3090702dd7d7adc51f1cca\n  , plaintext = 0x4c92fe152d16da8ea59b9f29c75f20ff\n  , ciphertext = 0x659c76f73032b0192b281034b6a99a3f\n  },\n\n  { key = 0xf9a7f7e93b02206906ffc79973b686f5\n  , plaintext = 0x659c76f73032b0192b281034b6a99a3f\n  , ciphertext = 0x5d296637697ccad84fc77936a31c2655\n  },\n\n  { key = 0xa48e91de527eeab14938beafd0aaa0a0\n  , plaintext = 0x5d296637697ccad84fc77936a31c2655\n  , ciphertext = 0xa72a596a030d5541bc4d0fc739491d5b\n  },\n\n  { key = 0x03a4c8b45173bff0f575b168e9e3bdfb\n  , plaintext = 0xa72a596a030d5541bc4d0fc739491d5b\n  , ciphertext = 0x5f5ec53c91225717fcba470688dfa364\n  },\n\n  { key = 0x5cfa0d88c051e8e709cff66e613c1e9f\n  , plaintext = 0x5f5ec53c91225717fcba470688dfa364\n  , ciphertext = 0x5719cb14eba820c0d51109a0c7a4154f\n  },\n\n  { key = 0x0be3c69c2bf9c827dcdeffcea6980bd0\n  , plaintext = 0x5719cb14eba820c0d51109a0c7a4154f\n  , ciphertext = 0x3abd186712a9def73b6312b5300f02af\n  },\n\n  { key = 0x315edefb395016d0e7bded7b9697097f\n  , plaintext = 0x3abd186712a9def73b6312b5300f02af\n  , ciphertext = 0xb1e90c8c0d4c9651a6de7f52a63ac456\n  },\n\n  { key = 0x80b7d277341c80814163922930adcd29\n  , plaintext = 0xb1e90c8c0d4c9651a6de7f52a63ac456\n  , ciphertext = 0x5d26e33aae1441554034c77bde451679\n  },\n\n  { key = 0xdd91314d9a08c1d401575552eee8db50\n  , plaintext = 0x5d26e33aae1441554034c77bde451679\n  , ciphertext = 0x93e44cdce14803544a53bc5b520c156f\n  },\n\n  { key = 0x4e757d917b40c2804b04e909bce4ce3f\n  , plaintext = 0x93e44cdce14803544a53bc5b520c156f\n  , ciphertext = 0x8ee3b6fd953b441043f69f3747e4cf63\n  },\n\n  { key = 0xc096cb6cee7b869008f2763efb00015c\n  , plaintext = 0x8ee3b6fd953b441043f69f3747e4cf63\n  , ciphertext = 0xcb2f545970200630e5145f817a013807\n  },\n\n  { key = 0x0bb99f359e5b80a0ede629bf8101395b\n  , plaintext = 0xcb2f545970200630e5145f817a013807\n  , ciphertext = 0x50047276451ce19cb14d8d2ef0b3851b\n  },\n\n  { key = 0x5bbded43db47613c5caba49171b2bc40\n  , plaintext = 0x50047276451ce19cb14d8d2ef0b3851b\n  , ciphertext = 0xd243791dde33c2a4333ef4dcbcadbd3a\n  },\n\n  { key = 0x89fe945e0574a3986f95504dcd1f017a\n  , plaintext = 0xd243791dde33c2a4333ef4dcbcadbd3a\n  , ciphertext = 0x343181860092a5e33c2e1c441a9f6804\n  },\n\n  { key = 0xbdcf15d805e6067b53bb4c09d780697e\n  , plaintext = 0x343181860092a5e33c2e1c441a9f6804\n  , ciphertext = 0x4e7cdd553d732909e25a13a521e04078\n  },\n\n  { key = 0xf3b3c88d38952f72b1e15facf6602906\n  , plaintext = 0x4e7cdd553d732909e25a13a521e04078\n  , ciphertext = 0x9c16f3fda49bb6a2b6d76a6696bd768f\n  },\n\n  { key = 0x6fa53b709c0e99d0073635ca60dd5f89\n  , plaintext = 0x9c16f3fda49bb6a2b6d76a6696bd768f\n  , ciphertext = 0x9eb63f9099123591a4ca7aa0fff55a49\n  },\n\n  { key = 0xf11304e0051cac41a3fc4f6a9f2805c0\n  , plaintext = 0x9eb63f9099123591a4ca7aa0fff55a49\n  , ciphertext = 0xaa6a9e40aad692550b7c87b92b205af0\n  },\n\n  { key = 0x5b799aa0afca3e14a880c8d3b4085f30\n  , plaintext = 0xaa6a9e40aad692550b7c87b92b205af0\n  , ciphertext = 0xae92c267f38b9b4623df36523bb739b6\n  },\n\n  { key = 0xf5eb58c75c41a5528b5ffe818fbf6686\n  , plaintext = 0xae92c267f38b9b4623df36523bb739b6\n  , ciphertext = 0x39c0de843767dfa2d563c0632405d595\n  },\n\n  { key = 0xcc2b86436b267af05e3c3ee2abbab313\n  , plaintext = 0x39c0de843767dfa2d563c0632405d595\n  , ciphertext = 0x80a9445be75373b07476608feb1f1c7b\n  },\n\n  { key = 0x4c82c2188c7509402a4a5e6d40a5af68\n  , plaintext = 0x80a9445be75373b07476608feb1f1c7b\n  , ciphertext = 0x5306f5a77e42d9f4cee8f134ba1448c6\n  },\n\n  { key = 0x1f8437bff237d0b4e4a2af59fab1e7ae\n  , plaintext = 0x5306f5a77e42d9f4cee8f134ba1448c6\n  , ciphertext = 0x8db0c3fba7dc797cd175d97503759260\n  },\n\n  { key = 0x9234f44455eba9c835d7762cf9c475ce\n  , plaintext = 0x8db0c3fba7dc797cd175d97503759260\n  , ciphertext = 0x04fcb0c77ae0c98d2afb178ab2c2b02d\n  },\n\n  { key = 0x96c844832f0b60451f2c61a64b06c5e3\n  , plaintext = 0x04fcb0c77ae0c98d2afb178ab2c2b02d\n  , ciphertext = 0x1a156581b3557078971cc6877a3d9339\n  },\n\n  { key = 0x8cdd21029c5e103d8830a721313b56da\n  , plaintext = 0x1a156581b3557078971cc6877a3d9339\n  , ciphertext = 0xe47087289290fa2b6734eeaab2fc815d\n  },\n\n  { key = 0x68ada62a0eceea16ef04498b83c7d787\n  , plaintext = 0xe47087289290fa2b6734eeaab2fc815d\n  , ciphertext = 0x00ce641525020d35244e2227287b2a20\n  },\n\n  { key = 0x6863c23f2bcce723cb4a6bacabbcfda7\n  , plaintext = 0x00ce641525020d35244e2227287b2a20\n  , ciphertext = 0xecf623cef1e420d0994070c078592c97\n  },\n\n  { key = 0x8495e1f1da28c7f3520a1b6cd3e5d130\n  , plaintext = 0xecf623cef1e420d0994070c078592c97\n  , ciphertext = 0x256c8f28df4a286fb05514fcfa8cbcaf\n  },\n\n  { key = 0xa1f96ed90562ef9ce25f0f9029696d9f\n  , plaintext = 0x256c8f28df4a286fb05514fcfa8cbcaf\n  , ciphertext = 0xfd4aed4b5a2b8edefe3cc2aef6ecd298\n  },\n\n  { key = 0x5cb383925f4961421c63cd3edf85bf07\n  , plaintext = 0xfd4aed4b5a2b8edefe3cc2aef6ecd298\n  , ciphertext = 0xdfe0e571f77f0b46c52f003e774918ac\n  },\n\n  { key = 0x835366e3a8366a04d94ccd00a8cca7ab\n  , plaintext = 0xdfe0e571f77f0b46c52f003e774918ac\n  , ciphertext = 0xe421fbeb4c23745b97578162f89e68fc\n  },\n\n  { key = 0x67729d08e4151e5f4e1b4c625052cf57\n  , plaintext = 0xe421fbeb4c23745b97578162f89e68fc\n  , ciphertext = 0xc38c0bbde031d1a79438f79ff7cc68a5\n  },\n\n  { key = 0xa4fe96b50424cff8da23bbfda79ea7f2\n  , plaintext = 0xc38c0bbde031d1a79438f79ff7cc68a5\n  , ciphertext = 0x86113133968aa3052709875bf033d804\n  },\n\n  { key = 0x22efa78692ae6cfdfd2a3ca657ad7ff6\n  , plaintext = 0x86113133968aa3052709875bf033d804\n  , ciphertext = 0xfd706bef1bf30c8d1e95543b75629e02\n  },\n\n  { key = 0xdf9fcc69895d6070e3bf689d22cfe1f4\n  , plaintext = 0xfd706bef1bf30c8d1e95543b75629e02\n  , ciphertext = 0x9a5bbb6125152f1352b10e1c1a172aa6\n  },\n\n  { key = 0x45c47708ac484f63b10e668138d8cb52\n  , plaintext = 0x9a5bbb6125152f1352b10e1c1a172aa6\n  , ciphertext = 0x3ee69736488c51fa72784aa263618f45\n  },\n\n  { key = 0x7b22e03ee4c41e99c3762c235bb94417\n  , plaintext = 0x3ee69736488c51fa72784aa263618f45\n  , ciphertext = 0xfc66daa246ebcc320c7c89b599014633\n  },\n\n  { key = 0x87443a9ca22fd2abcf0aa596c2b80224\n  , plaintext = 0xfc66daa246ebcc320c7c89b599014633\n  , ciphertext = 0x35645885ed205d67e5caeff26646c38c\n  },\n\n  { key = 0xb22062194f0f8fcc2ac04a64a4fec1a8\n  , plaintext = 0x35645885ed205d67e5caeff26646c38c\n  , ciphertext = 0xdaeaa866aa4eacdb752caccb2c0ae6c1\n  },\n\n  { key = 0x68caca7fe54123175fece6af88f42769\n  , plaintext = 0xdaeaa866aa4eacdb752caccb2c0ae6c1\n  , ciphertext = 0x29e88b1ae615fcd06b09e767459d6089\n  },\n\n  { key = 0x412241650354dfc734e501c8cd6947e0\n  , plaintext = 0x29e88b1ae615fcd06b09e767459d6089\n  , ciphertext = 0x63470bff052e7f5c7a735cc2e6eb61ac\n  },\n\n  { key = 0x22654a9a067aa09b4e965d0a2b82264c\n  , plaintext = 0x63470bff052e7f5c7a735cc2e6eb61ac\n  , ciphertext = 0xf4fa6a3549cd2b33af9cac134d7b1402\n  },\n\n  { key = 0xd69f20af4fb78ba8e10af11966f9324e\n  , plaintext = 0xf4fa6a3549cd2b33af9cac134d7b1402\n  , ciphertext = 0x5b22a82ccbae9b9c75f797e74e6da53d\n  },\n\n  { key = 0x8dbd88838419103494fd66fe28949773\n  , plaintext = 0x5b22a82ccbae9b9c75f797e74e6da53d\n  , ciphertext = 0x87b51692f8f28743bd8dc843276f351a\n  },\n\n  { key = 0x0a089e117ceb97772970aebd0ffba269\n  , plaintext = 0x87b51692f8f28743bd8dc843276f351a\n  , ciphertext = 0x150fb2180704a7623a1fab8bf17fba18\n  },\n\n  { key = 0x1f072c097bef3015136f0536fe841871\n  , plaintext = 0x150fb2180704a7623a1fab8bf17fba18\n  , ciphertext = 0x8088874e7f3f09a98fd3f0a59f2a0b4b\n  },\n\n  { key = 0x9f8fab4704d039bc9cbcf59361ae133a\n  , plaintext = 0x8088874e7f3f09a98fd3f0a59f2a0b4b\n  , ciphertext = 0x08e02c091057d81c05d917ea5c07cdd0\n  },\n\n  { key = 0x976f874e1487e1a09965e2793da9deea\n  , plaintext = 0x08e02c091057d81c05d917ea5c07cdd0\n  , ciphertext = 0xb9636b3e2752694c3685872fd0a9a0ea\n  },\n\n  { key = 0x2e0cec7033d588ecafe06556ed007e00\n  , plaintext = 0xb9636b3e2752694c3685872fd0a9a0ea\n  , ciphertext = 0x2610dae2b64d74a8cbb4f43fa2d0a603\n  },\n\n  { key = 0x081c36928598fc44645491694fd0d803\n  , plaintext = 0x2610dae2b64d74a8cbb4f43fa2d0a603\n  , ciphertext = 0x9cc994eda697fb5545eaa502b2a30fd3\n  },\n\n  { key = 0x94d5a27f230f071121be346bfd73d7d0\n  , plaintext = 0x9cc994eda697fb5545eaa502b2a30fd3\n  , ciphertext = 0xfb2649694783b551eacd9d5db6126d47\n  }]\n\n\naes128_MCT_decrypt_test_vectors : [100](AESTestVector 128)\naes128_MCT_decrypt_test_vectors =\n [{ key = 0x0c60e7bf20ada9baa9e1ddf0d1540726\n  , ciphertext = 0xb08a29b11a500ea3aca42c36675b9785\n  , plaintext = 0xb613b87085fed1bb87f07a574e6d2879\n  },\n\n  { key = 0xba735fcfa55378012e11a7a79f392f5f\n  , ciphertext = 0xb613b87085fed1bb87f07a574e6d2879\n  , plaintext = 0x5541d7bf6d25c55c0c2296acba756e9e\n  },\n\n  { key = 0xef328870c876bd5d2233310b254c41c1\n  , ciphertext = 0x5541d7bf6d25c55c0c2296acba756e9e\n  , plaintext = 0x4c138198d55d0d87d43cdb92fb0b5fc0\n  },\n\n  { key = 0xa32109e81d2bb0daf60fea99de471e01\n  , ciphertext = 0x4c138198d55d0d87d43cdb92fb0b5fc0\n  , plaintext = 0x257c07bdcba57aff1643de90b63c0a88\n  },\n\n  { key = 0x865d0e55d68eca25e04c3409687b1489\n  , ciphertext = 0x257c07bdcba57aff1643de90b63c0a88\n  , plaintext = 0x8039be4e65d218d3e640f88309d01c6f\n  },\n\n  { key = 0x0664b01bb35cd2f6060ccc8a61ab08e6\n  , ciphertext = 0x8039be4e65d218d3e640f88309d01c6f\n  , plaintext = 0x0115dcd390855bf5ce32e946a6d5ad38\n  },\n\n  { key = 0x07716cc823d98903c83e25ccc77ea5de\n  , ciphertext = 0x0115dcd390855bf5ce32e946a6d5ad38\n  , plaintext = 0x71741ccb723348c7f3f9e4a397977bdb\n  },\n\n  { key = 0x7605700351eac1c43bc7c16f50e9de05\n  , ciphertext = 0x71741ccb723348c7f3f9e4a397977bdb\n  , plaintext = 0x668c9f3dc9e154bd16d61364a99f635d\n  },\n\n  { key = 0x1089ef3e980b95792d11d20bf976bd58\n  , ciphertext = 0x668c9f3dc9e154bd16d61364a99f635d\n  , plaintext = 0x124b19b2501a540066ddf7943417cba3\n  },\n\n  { key = 0x02c2f68cc811c1794bcc259fcd6176fb\n  , ciphertext = 0x124b19b2501a540066ddf7943417cba3\n  , plaintext = 0x23e7c95f7ed9017af339c234b7a8fcc4\n  },\n\n  { key = 0x21253fd3b6c8c003b8f5e7ab7ac98a3f\n  , ciphertext = 0x23e7c95f7ed9017af339c234b7a8fcc4\n  , plaintext = 0x7b0e1e1afe46c1e50785efb939f8ade3\n  },\n\n  { key = 0x5a2b21c9488e01e6bf700812433127dc\n  , ciphertext = 0x7b0e1e1afe46c1e50785efb939f8ade3\n  , plaintext = 0xc166aeebf5182c96d1f3c92cece9d714\n  },\n\n  { key = 0x9b4d8f22bd962d706e83c13eafd8f0c8\n  , ciphertext = 0xc166aeebf5182c96d1f3c92cece9d714\n  , plaintext = 0x71968762dc1b41bebd9ee8b2396b87be\n  },\n\n  { key = 0xeadb0840618d6cced31d298c96b37776\n  , ciphertext = 0x71968762dc1b41bebd9ee8b2396b87be\n  , plaintext = 0x77b0aa88222a785282352bb861ea0cd2\n  },\n\n  { key = 0x9d6ba2c843a7149c51280234f7597ba4\n  , ciphertext = 0x77b0aa88222a785282352bb861ea0cd2\n  , plaintext = 0xe65c461cba6957fe5b5ee5014c899e65\n  },\n\n  { key = 0x7b37e4d4f9ce43620a76e735bbd0e5c1\n  , ciphertext = 0xe65c461cba6957fe5b5ee5014c899e65\n  , plaintext = 0xa799870cee001551f3494bdf3c27bd94\n  },\n\n  { key = 0xdcae63d817ce5633f93facea87f75855\n  , ciphertext = 0xa799870cee001551f3494bdf3c27bd94\n  , plaintext = 0xf54697576153f97d9fb1a4d164a8538e\n  },\n\n  { key = 0x29e8f48f769daf4e668e083be35f0bdb\n  , ciphertext = 0xf54697576153f97d9fb1a4d164a8538e\n  , plaintext = 0xf3f1f964b98b3498898c3032e44a308c\n  },\n\n  { key = 0xda190debcf169bd6ef02380907153b57\n  , ciphertext = 0xf3f1f964b98b3498898c3032e44a308c\n  , plaintext = 0x40ccc3a26141900280a3a7b62d4ed8b6\n  },\n\n  { key = 0x9ad5ce49ae570bd46fa19fbf2a5be3e1\n  , ciphertext = 0x40ccc3a26141900280a3a7b62d4ed8b6\n  , plaintext = 0x7fcf64bd75808be6199f3fac0881d4d4\n  },\n\n  { key = 0xe51aaaf4dbd78032763ea01322da3735\n  , ciphertext = 0x7fcf64bd75808be6199f3fac0881d4d4\n  , plaintext = 0x11ca970c169315ff0b54ecdb00ba4547\n  },\n\n  { key = 0xf4d03df8cd4495cd7d6a4cc822607272\n  , ciphertext = 0x11ca970c169315ff0b54ecdb00ba4547\n  , plaintext = 0xbc02615754b58eb975c26190a3583d28\n  },\n\n  { key = 0x48d25caf99f11b7408a82d5881384f5a\n  , ciphertext = 0xbc02615754b58eb975c26190a3583d28\n  , plaintext = 0x5b12925c7f72aaafbae6834a6e9d5af9\n  },\n\n  { key = 0x13c0cef3e683b1dbb24eae12efa515a3\n  , ciphertext = 0x5b12925c7f72aaafbae6834a6e9d5af9\n  , plaintext = 0x7950ffe2537235bfaa38101c2a9e6d42\n  },\n\n  { key = 0x6a903111b5f184641876be0ec53b78e1\n  , ciphertext = 0x7950ffe2537235bfaa38101c2a9e6d42\n  , plaintext = 0xcdf5c997d8ddcc1de7cc47ecc47d0819\n  },\n\n  { key = 0xa765f8866d2c4879ffbaf9e2014670f8\n  , ciphertext = 0xcdf5c997d8ddcc1de7cc47ecc47d0819\n  , plaintext = 0x8f4d77bccc4858016b28c2e8f84dd9a3\n  },\n\n  { key = 0x28288f3aa164107894923b0af90ba95b\n  , ciphertext = 0x8f4d77bccc4858016b28c2e8f84dd9a3\n  , plaintext = 0x561d95847869cccc81df7df65d70808d\n  },\n\n  { key = 0x7e351abed90ddcb4154d46fca47b29d6\n  , ciphertext = 0x561d95847869cccc81df7df65d70808d\n  , plaintext = 0x17b9e6f86ec1cff22cc6f8e14072bb0f\n  },\n\n  { key = 0x698cfc46b7cc1346398bbe1de40992d9\n  , ciphertext = 0x17b9e6f86ec1cff22cc6f8e14072bb0f\n  , plaintext = 0x8f959f24fae93418c2262ec73c6c8e1d\n  },\n\n  { key = 0xe61963624d25275efbad90dad8651cc4\n  , ciphertext = 0x8f959f24fae93418c2262ec73c6c8e1d\n  , plaintext = 0x2876f3a90b7a60168869d9de1e455836\n  },\n\n  { key = 0xce6f90cb465f474873c44904c62044f2\n  , ciphertext = 0x2876f3a90b7a60168869d9de1e455836\n  , plaintext = 0x5c609c0acdf2e389f19b3e0657706c9c\n  },\n\n  { key = 0x920f0cc18bada4c1825f77029150286e\n  , ciphertext = 0x5c609c0acdf2e389f19b3e0657706c9c\n  , plaintext = 0x88f537f67481490d20b713ff48b079e5\n  },\n\n  { key = 0x1afa3b37ff2cedcca2e864fdd9e0518b\n  , ciphertext = 0x88f537f67481490d20b713ff48b079e5\n  , plaintext = 0x0b1878fc9406b6c5f2c0085e8c9e0dd9\n  },\n\n  { key = 0x11e243cb6b2a5b0950286ca3557e5c52\n  , ciphertext = 0x0b1878fc9406b6c5f2c0085e8c9e0dd9\n  , plaintext = 0x594b9df3bad040afa14e63298945068d\n  },\n\n  { key = 0x48a9de38d1fa1ba6f1660f8adc3b5adf\n  , ciphertext = 0x594b9df3bad040afa14e63298945068d\n  , plaintext = 0xfcf5ffafacc372e641b1520fe76d16c7\n  },\n\n  { key = 0xb45c21977d396940b0d75d853b564c18\n  , ciphertext = 0xfcf5ffafacc372e641b1520fe76d16c7\n  , plaintext = 0x67319b7ab394937244b93977ba06c1ee\n  },\n\n  { key = 0xd36dbaedceadfa32f46e64f281508df6\n  , ciphertext = 0x67319b7ab394937244b93977ba06c1ee\n  , plaintext = 0xd956a31188a667eea44c93582d6aed6f\n  },\n\n  { key = 0x0a3b19fc460b9ddc5022f7aaac3a6099\n  , ciphertext = 0xd956a31188a667eea44c93582d6aed6f\n  , plaintext = 0x04f18289308787f3d936dd2a45c49e22\n  },\n\n  { key = 0x0eca9b75768c1a2f89142a80e9fefebb\n  , ciphertext = 0x04f18289308787f3d936dd2a45c49e22\n  , plaintext = 0xc925df60f455b0e27852efcf9fddc3d0\n  },\n\n  { key = 0xc7ef441582d9aacdf146c54f76233d6b\n  , ciphertext = 0xc925df60f455b0e27852efcf9fddc3d0\n  , plaintext = 0x14c3bcf83483de973d975dbf249c505e\n  },\n\n  { key = 0xd32cf8edb65a745accd198f052bf6d35\n  , ciphertext = 0x14c3bcf83483de973d975dbf249c505e\n  , plaintext = 0xa5f3f4afd0d01b9f4999d27e6386e925\n  },\n\n  { key = 0x76df0c42668a6fc585484a8e31398410\n  , ciphertext = 0xa5f3f4afd0d01b9f4999d27e6386e925\n  , plaintext = 0xd94451374478c1bdb4b94eb6908a205e\n  },\n\n  { key = 0xaf9b5d7522f2ae7831f10438a1b3a44e\n  , ciphertext = 0xd94451374478c1bdb4b94eb6908a205e\n  , plaintext = 0x9f3c6ed40a32c89d4ee8d4b87c8298c7\n  },\n\n  { key = 0x30a733a128c066e57f19d080dd313c89\n  , ciphertext = 0x9f3c6ed40a32c89d4ee8d4b87c8298c7\n  , plaintext = 0x54aa57cf75650cf6b7ccbd7202469bf7\n  },\n\n  { key = 0x640d646e5da56a13c8d56df2df77a77e\n  , ciphertext = 0x54aa57cf75650cf6b7ccbd7202469bf7\n  , plaintext = 0x11bc0be20465848934c0fd7d7ced8bd1\n  },\n\n  { key = 0x75b16f8c59c0ee9afc15908fa39a2caf\n  , ciphertext = 0x11bc0be20465848934c0fd7d7ced8bd1\n  , plaintext = 0x69d48f1ca39977f1c05f8cabd5f7e4ac\n  },\n\n  { key = 0x1c65e090fa59996b3c4a1c24766dc803\n  , ciphertext = 0x69d48f1ca39977f1c05f8cabd5f7e4ac\n  , plaintext = 0x2e447e6121162382c182b3efb27b2d5a\n  },\n\n  { key = 0x32219ef1db4fbae9fdc8afcbc416e559\n  , ciphertext = 0x2e447e6121162382c182b3efb27b2d5a\n  , plaintext = 0x3d99d0dff0891c38bec01551b4040e55\n  },\n\n  { key = 0x0fb84e2e2bc6a6d14308ba9a7012eb0c\n  , ciphertext = 0x3d99d0dff0891c38bec01551b4040e55\n  , plaintext = 0x92294ba363ed5b750c066cb6708620ee\n  },\n\n  { key = 0x9d91058d482bfda44f0ed62c0094cbe2\n  , ciphertext = 0x92294ba363ed5b750c066cb6708620ee\n  , plaintext = 0xcb674decffaae472d3d0710935b02aae\n  },\n\n  { key = 0x56f64861b78119d69cdea7253524e14c\n  , ciphertext = 0xcb674decffaae472d3d0710935b02aae\n  , plaintext = 0x47cd6a4b2f9b3d610d2bd3fe39feec91\n  },\n\n  { key = 0x113b222a981a24b791f574db0cda0ddd\n  , ciphertext = 0x47cd6a4b2f9b3d610d2bd3fe39feec91\n  , plaintext = 0x65b0b926a5b5b67f6895af42441f106b\n  },\n\n  { key = 0x748b9b0c3daf92c8f960db9948c51db6\n  , ciphertext = 0x65b0b926a5b5b67f6895af42441f106b\n  , plaintext = 0x3642fd59024efb3dc4e5bb268dd9de04\n  },\n\n  { key = 0x42c966553fe169f53d8560bfc51cc3b2\n  , ciphertext = 0x3642fd59024efb3dc4e5bb268dd9de04\n  , plaintext = 0x4e5d32a0e40dd9b830af0c2904518906\n  },\n\n  { key = 0x0c9454f5dbecb04d0d2a6c96c14d4ab4\n  , ciphertext = 0x4e5d32a0e40dd9b830af0c2904518906\n  , plaintext = 0x40a7ff6a6d0ea135245d5b24a0004466\n  },\n\n  { key = 0x4c33ab9fb6e21178297737b2614d0ed2\n  , ciphertext = 0x40a7ff6a6d0ea135245d5b24a0004466\n  , plaintext = 0xb18e6d37f5292acd1eaeee742930952a\n  },\n\n  { key = 0xfdbdc6a843cb3bb537d9d9c6487d9bf8\n  , ciphertext = 0xb18e6d37f5292acd1eaeee742930952a\n  , plaintext = 0x42df9c23bfbc90b787c5cb0dc08e80dc\n  },\n\n  { key = 0xbf625a8bfc77ab02b01c12cb88f31b24\n  , ciphertext = 0x42df9c23bfbc90b787c5cb0dc08e80dc\n  , plaintext = 0x589af99abbba45318106d2c1ca7b82b0\n  },\n\n  { key = 0xe7f8a31147cdee33311ac00a42889994\n  , ciphertext = 0x589af99abbba45318106d2c1ca7b82b0\n  , plaintext = 0x96f54a5bacec995c0263226cd443f2c6\n  },\n\n  { key = 0x710de94aeb21776f3379e26696cb6b52\n  , ciphertext = 0x96f54a5bacec995c0263226cd443f2c6\n  , plaintext = 0x84e07ce717c747cb924e42cdf6ec6524\n  },\n\n  { key = 0xf5ed95adfce630a4a137a0ab60270e76\n  , ciphertext = 0x84e07ce717c747cb924e42cdf6ec6524\n  , plaintext = 0x5140a66d02867ddfa8bb014f75d53b83\n  },\n\n  { key = 0xa4ad33c0fe604d7b098ca1e415f235f5\n  , ciphertext = 0x5140a66d02867ddfa8bb014f75d53b83\n  , plaintext = 0xa1570dc8605d7d68f0a2416aa2c3536a\n  },\n\n  { key = 0x05fa3e089e3d3013f92ee08eb731669f\n  , ciphertext = 0xa1570dc8605d7d68f0a2416aa2c3536a\n  , plaintext = 0x96ab8bd9091a703a6e6d1a2190f0b5c9\n  },\n\n  { key = 0x9351b5d1972740299743faaf27c1d356\n  , ciphertext = 0x96ab8bd9091a703a6e6d1a2190f0b5c9\n  , plaintext = 0x8418c2cec9d7cc3825152790f120488f\n  },\n\n  { key = 0x1749771f5ef08c11b256dd3fd6e19bd9\n  , ciphertext = 0x8418c2cec9d7cc3825152790f120488f\n  , plaintext = 0x7973673755c8201ec52bdec30a86191f\n  },\n\n  { key = 0x6e3a10280b38ac0f777d03fcdc6782c6\n  , ciphertext = 0x7973673755c8201ec52bdec30a86191f\n  , plaintext = 0x2a92ba991755f3c6ad1ef58681ac3a12\n  },\n\n  { key = 0x44a8aab11c6d5fc9da63f67a5dcbb8d4\n  , ciphertext = 0x2a92ba991755f3c6ad1ef58681ac3a12\n  , plaintext = 0xe3daa0cfe79594311762ca0d39985da2\n  },\n\n  { key = 0xa7720a7efbf8cbf8cd013c776453e576\n  , ciphertext = 0xe3daa0cfe79594311762ca0d39985da2\n  , plaintext = 0x5c2ea8b0b4bd7b50b48abd7df8e716f2\n  },\n\n  { key = 0xfb5ca2ce4f45b0a8798b810a9cb4f384\n  , ciphertext = 0x5c2ea8b0b4bd7b50b48abd7df8e716f2\n  , plaintext = 0xf15e39a11ed397378b6de3d62bde10c2\n  },\n\n  { key = 0x0a029b6f5196279ff2e662dcb76ae346\n  , ciphertext = 0xf15e39a11ed397378b6de3d62bde10c2\n  , plaintext = 0xd16879ee2fe2c07703e7eba3e093e911\n  },\n\n  { key = 0xdb6ae2817e74e7e8f101897f57f90a57\n  , ciphertext = 0xd16879ee2fe2c07703e7eba3e093e911\n  , plaintext = 0x57aac9d12da681f1ef4fc3d07269e159\n  },\n\n  { key = 0x8cc02b5053d266191e4e4aaf2590eb0e\n  , ciphertext = 0x57aac9d12da681f1ef4fc3d07269e159\n  , plaintext = 0xf6472d8a7d288db2262d826ff2f806ee\n  },\n\n  { key = 0x7a8706da2efaebab3863c8c0d768ede0\n  , ciphertext = 0xf6472d8a7d288db2262d826ff2f806ee\n  , plaintext = 0xd3ec20ae3257192d51f2ce4e73f87e53\n  },\n\n  { key = 0xa96b26741cadf2866991068ea49093b3\n  , ciphertext = 0xd3ec20ae3257192d51f2ce4e73f87e53\n  , plaintext = 0xd99891b245282641fb9e91681fce7ee1\n  },\n\n  { key = 0x70f3b7c65985d4c7920f97e6bb5eed52\n  , ciphertext = 0xd99891b245282641fb9e91681fce7ee1\n  , plaintext = 0x8f2fa0031baacb388ed7da3e7fd62828\n  },\n\n  { key = 0xffdc17c5422f1fff1cd84dd8c488c57a\n  , ciphertext = 0x8f2fa0031baacb388ed7da3e7fd62828\n  , plaintext = 0x80bed13ad5aebb0783629b03af2f6897\n  },\n\n  { key = 0x7f62c6ff9781a4f89fbad6db6ba7aded\n  , ciphertext = 0x80bed13ad5aebb0783629b03af2f6897\n  , plaintext = 0xfac43dfa16d393580f130b8a955339a6\n  },\n\n  { key = 0x85a6fb05815237a090a9dd51fef4944b\n  , ciphertext = 0xfac43dfa16d393580f130b8a955339a6\n  , plaintext = 0x60aa3f3683346b09466f1c4c11b376f5\n  },\n\n  { key = 0xe50cc43302665ca9d6c6c11def47e2be\n  , ciphertext = 0x60aa3f3683346b09466f1c4c11b376f5\n  , plaintext = 0xe93ac158da113797bce2472240c4d7bb\n  },\n\n  { key = 0x0c36056bd8776b3e6a24863faf833505\n  , ciphertext = 0xe93ac158da113797bce2472240c4d7bb\n  , plaintext = 0xe96e8432e2eea1de7e0cceadfe5e1623\n  },\n\n  { key = 0xe55881593a99cae01428489251dd2326\n  , ciphertext = 0xe96e8432e2eea1de7e0cceadfe5e1623\n  , plaintext = 0xd99630cb34f06a3a02e9803a029980a2\n  },\n\n  { key = 0x3cceb1920e69a0da16c1c8a85344a384\n  , ciphertext = 0xd99630cb34f06a3a02e9803a029980a2\n  , plaintext = 0xe5a14b334430768edf5dd7863ee30678\n  },\n\n  { key = 0xd96ffaa14a59d654c99c1f2e6da7a5fc\n  , ciphertext = 0xe5a14b334430768edf5dd7863ee30678\n  , plaintext = 0x49dab0bc5fb8c387ea9c557d3a35e659\n  },\n\n  { key = 0x90b54a1d15e115d323004a53579243a5\n  , ciphertext = 0x49dab0bc5fb8c387ea9c557d3a35e659\n  , plaintext = 0x6867e956763a7377a15a4248ab91c829\n  },\n\n  { key = 0xf8d2a34b63db66a4825a081bfc038b8c\n  , ciphertext = 0x6867e956763a7377a15a4248ab91c829\n  , plaintext = 0x4f536383ba4e258dd3ab764027a66e39\n  },\n\n  { key = 0xb781c0c8d995432951f17e5bdba5e5b5\n  , ciphertext = 0x4f536383ba4e258dd3ab764027a66e39\n  , plaintext = 0xe9b6abc089286834eb9421e71fe98517\n  },\n\n  { key = 0x5e376b0850bd2b1dba655fbcc44c60a2\n  , ciphertext = 0xe9b6abc089286834eb9421e71fe98517\n  , plaintext = 0x256121dead70e6675ad631dd0527fb1a\n  },\n\n  { key = 0x7b564ad6fdcdcd7ae0b36e61c16b9bb8\n  , ciphertext = 0x256121dead70e6675ad631dd0527fb1a\n  , plaintext = 0x6bdbcc94ec6497445e4024acb601741b\n  },\n\n  { key = 0x108d864211a95a3ebef34acd776aefa3\n  , ciphertext = 0x6bdbcc94ec6497445e4024acb601741b\n  , plaintext = 0x44e86f9d48c6699554a3538eb6f55479\n  },\n\n  { key = 0x5465e9df596f33abea501943c19fbbda\n  , ciphertext = 0x44e86f9d48c6699554a3538eb6f55479\n  , plaintext = 0xc7c622fee00a180f3131a57a82acf7a9\n  },\n\n  { key = 0x93a3cb21b9652ba4db61bc3943334c73\n  , ciphertext = 0xc7c622fee00a180f3131a57a82acf7a9\n  , plaintext = 0xe096b0406e6e8abb6ced353f1be40693\n  },\n\n  { key = 0x73357b61d70ba11fb78c890658d74ae0\n  , ciphertext = 0xe096b0406e6e8abb6ced353f1be40693\n  , plaintext = 0x73326251dbd89c23b37caee2ee6d2d9e\n  },\n\n  { key = 0x000719300cd33d3c04f027e4b6ba677e\n  , ciphertext = 0x73326251dbd89c23b37caee2ee6d2d9e\n  , plaintext = 0x7b2c687d460054af03709645056407c6\n  },\n\n  { key = 0x7b2b714d4ad369930780b1a1b3de60b8\n  , ciphertext = 0x7b2c687d460054af03709645056407c6\n  , plaintext = 0x8bb9f381438145a96714e238a8864e0b\n  },\n\n  { key = 0xf09282cc09522c3a609453991b582eb3\n  , ciphertext = 0x8bb9f381438145a96714e238a8864e0b\n  , plaintext = 0xd59509d08bcfc30e20344b1c4c53f726\n  },\n\n  { key = 0x25078b1c829def3440a01885570bd995\n  , ciphertext = 0xd59509d08bcfc30e20344b1c4c53f726\n  , plaintext = 0x02e6077d01a352637899d6ce626782ac\n  },\n\n  { key = 0x27e18c61833ebd573839ce4b356c5b39\n  , ciphertext = 0x02e6077d01a352637899d6ce626782ac\n  , plaintext = 0xed01d9601145c11662986b0827e403ec\n  },\n\n  { key = 0xcae05501927b7c415aa1a543128858d5\n  , ciphertext = 0xed01d9601145c11662986b0827e403ec\n  , plaintext = 0x7d5b1ca06884b5a55e9035fe7d77d4a7\n  },\n\n  { key = 0xb7bb49a1faffc9e4043190bd6fff8c72\n  , ciphertext = 0x7d5b1ca06884b5a55e9035fe7d77d4a7\n  , plaintext = 0x1a23d371b97e1056e8bc9545c56cab9e\n  },\n\n  { key = 0xad989ad04381d9b2ec8d05f8aa9327ec\n  , ciphertext = 0x1a23d371b97e1056e8bc9545c56cab9e\n  , plaintext = 0xd1d2bfdc58ffcad2341b095bce55221e\n  }]\n\n\nmct_ecb_encrypt_192 : [192] -> [128] -> [100](AESTestVector 192)\nmct_ecb_encrypt_192 initialKey initialPt = vs\n  where\n  vs@i = { key = keys@i, plaintext=pts@(i*1000), ciphertext=cts@(i*1000 + 999) }\n\n  pts : [100*1000][128]\n  pts = [initialPt] # take cts\n\n  cts : [100*1000][128]\n  cts@i = aesEncryptBlock (schedules@(i\/1000)) (pts@i)\n\n  keys : [100][192]\n  keys = [initialKey] # [ k ^ ((drop`{64} (xs!1)) # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} cts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESEncryptKeySchedule AES192)\n  schedules = map aes192EncryptSchedule keys\n\nmct_ecb_decrypt_192 : [192] -> [128] -> [100](AESTestVector 192)\nmct_ecb_decrypt_192 initialKey initialCt = vs\n  where\n  vs@i = { key = keys@i, ciphertext=cts@(i*1000), plaintext=pts@(i*1000 + 999) }\n\n  cts : [100*1000][128]\n  cts = [initialCt] # take pts\n\n  pts : [100*1000][128]\n  pts@i = aesDecryptBlock (schedules@(i\/1000)) (cts@i)\n\n  keys : [100][192]\n  keys = [initialKey] # [ k ^ ((drop`{64} (xs!1)) # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} pts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESDecryptKeySchedule AES192)\n  schedules = map aes192DecryptSchedule keys\n\nmct_ecb_encrypt_256 : [256] -> [128] -> [100](AESTestVector 256)\nmct_ecb_encrypt_256 initialKey initialPt = vs\n  where\n  vs@i = { key = keys@i, plaintext=pts@(i*1000), ciphertext=cts@(i*1000 + 999) }\n\n  pts : [100*1000][128]\n  pts = [initialPt] # take cts\n\n  cts : [100*1000][128]\n  cts@i = aesEncryptBlock (schedules@(i\/1000)) (pts@i)\n\n  keys : [100][256]\n  keys = [initialKey] # [ k ^ (xs!1 # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} cts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESEncryptKeySchedule AES256)\n  schedules = map aes256EncryptSchedule keys\n\nmct_ecb_decrypt_256 : [256] -> [128] -> [100](AESTestVector 256)\nmct_ecb_decrypt_256 initialKey initialCt = vs\n  where\n  vs@i = { key = keys@i, ciphertext=cts@(i*1000), plaintext=pts@(i*1000 + 999) }\n\n  cts : [100*1000][128]\n  cts = [initialCt] # take pts\n\n  pts : [100*1000][128]\n  pts@i = aesDecryptBlock (schedules@(i\/1000)) (cts@i)\n\n  keys : [100][256]\n  keys = [initialKey] # [ k ^ (xs!1 # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} pts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESDecryptKeySchedule AES256)\n  schedules = map aes256DecryptSchedule keys\n\n\n\nproperty aes192_MCT_vectors_encrypt_correct =\n aes192_MCT_encrypt_test_vectors ==\n mct_ecb_encrypt_192\n   0xb9a63e09e1dfc42e93a90d9bad739e5967aef672eedd5da9 \n   0x85a1f7a58167b389cddc8a9ff175ee26\n\nproperty aes192_MCT_vectors_decrypt_correct =\n aes192_MCT_decrypt_test_vectors ==\n mct_ecb_decrypt_192\n   0x4b97585701c03fbebdfa8555024f589f1482c58a00fdd9fd\n   0xd0bd0e02ded155e4516be83f42d347a4\n\naes192_MCT_encrypt_test_vectors : [100](AESTestVector 192)\naes192_MCT_encrypt_test_vectors =\n \/\/ Vectors from ECBMCT192.rsp\n [{ key = 0xb9a63e09e1dfc42e93a90d9bad739e5967aef672eedd5da9\n  , plaintext = 0x85a1f7a58167b389cddc8a9ff175ee26\n  , ciphertext = 0xee83d85279e022d2048031abeefbc4a4\n  },\n\n  { key = 0x3aaa458160ee54c97d2ad5c9d493bc8b632ec7d90026990d\n  , plaintext = 0xee83d85279e022d2048031abeefbc4a4\n  , ciphertext = 0xa8f99517b4bd14a16c26bae901417498\n  },\n\n  { key = 0x1d17d1bcc74a8584d5d340de602ea82a0f087d300167ed95\n  , plaintext = 0xa8f99517b4bd14a16c26bae901417498\n  , ciphertext = 0x80286e71937334fd6e90c706abbaf0ff\n  },\n\n  { key = 0xc0025cd0eb1f23c055fb2eaff35d9cd76198ba36aadd1d6a\n  , plaintext = 0x80286e71937334fd6e90c706abbaf0ff\n  , ciphertext = 0xc8b8c153bcb231e9424d65f37bff75b8\n  },\n\n  { key = 0xafb45c1097553d589d43effc4fefad3e23d5dfc5d12268d2\n  , plaintext = 0xc8b8c153bcb231e9424d65f37bff75b8\n  , ciphertext = 0x8108fbfde1cff0d94b88b1073114c657\n  },\n\n  { key = 0x8b81e2418f676a5b1c4b1401ae205de7685d6ec2e036ae85\n  , plaintext = 0x8108fbfde1cff0d94b88b1073114c657\n  , ciphertext = 0x79af44f2490efc90d217af55dd10fd2e\n  },\n\n  { key = 0x43463bbf9528c3bc65e450f3e72ea177ba4ac1973d2653ab\n  , plaintext = 0x79af44f2490efc90d217af55dd10fd2e\n  , ciphertext = 0xd0c2da3860c367e1fd68cf04bb6b41cd\n  },\n\n  { key = 0x0e3efca8ca3fd45bb5268acb87edc69647220e93864d1266\n  , plaintext = 0xd0c2da3860c367e1fd68cf04bb6b41cd\n  , ciphertext = 0xe5d39a5d7ca8c4f4aafd3d851c40c016\n  },\n\n  { key = 0x2908445968d0a18f50f51096fb450262eddf33169a0dd270\n  , plaintext = 0xe5d39a5d7ca8c4f4aafd3d851c40c016\n  , ciphertext = 0x98657051b23c69741b2ab506f818fd3f\n  },\n\n  { key = 0x00feb8bffd6b4bcbc89060c749796b16f6f5861062152f4f\n  , plaintext = 0x98657051b23c69741b2ab506f818fd3f\n  , ciphertext = 0xc9b6e95fb54b540adc1faa8cece00286\n  },\n\n  { key = 0xbe96e16fffe0a2db01268998fc323f1c2aea2c9c8ef52dc9\n  , plaintext = 0xc9b6e95fb54b540adc1faa8cece00286\n  , ciphertext = 0x5cf9f61a3dd3a2f76d571384c831ae88\n  },\n\n  { key = 0x41baf817490bf49c5ddf7f82c1e19deb47bd3f1846c48341\n  , plaintext = 0x5cf9f61a3dd3a2f76d571384c831ae88\n  , ciphertext = 0xdc6e6c13679958963b8648457eb8a415\n  },\n\n  { key = 0xa4afa1ac957b31fe81b11391a678c57d7c3b775d387c2754\n  , plaintext = 0xdc6e6c13679958963b8648457eb8a415\n  , ciphertext = 0x033f2b7189ec7f2ef0c496a83f5c5051\n  },\n\n  { key = 0x6a5b44860a26a4ff828e38e02f94ba538cffe1f507207705\n  , plaintext = 0x033f2b7189ec7f2ef0c496a83f5c5051\n  , ciphertext = 0x032727204d9b169679eff2ffe5f71efb\n  },\n\n  { key = 0xc80d5ebc48693fdc81a91fc0620facc5f510130ae2d769fe\n  , plaintext = 0x032727204d9b169679eff2ffe5f71efb\n  , ciphertext = 0xd19884aaae710c5861fff7251ea143c8\n  },\n\n  { key = 0xb9d36290d5324a8350319b6acc7ea09d94efe42ffc762a36\n  , plaintext = 0xd19884aaae710c5861fff7251ea143c8\n  , ciphertext = 0x3097d32245163fcf4c578e5a7dd2349a\n  },\n\n  { key = 0x3d00403bc3a0ff5b60a6484889689f52d8b86a7581a41eac\n  , plaintext = 0x3097d32245163fcf4c578e5a7dd2349a\n  , ciphertext = 0x39b6615b1e047b9469b3cfd7251987c9\n  },\n\n  { key = 0xbb85f657f0d5241659102913976ce4c6b10ba5a2a4bd9965\n  , plaintext = 0x39b6615b1e047b9469b3cfd7251987c9\n  , ciphertext = 0x868194c44a68d8b48e0ed4dbacded128\n  },\n\n  { key = 0x7db3635bf7d52f66df91bdd7dd043c723f0571790863484d\n  , plaintext = 0x868194c44a68d8b48e0ed4dbacded128\n  , ciphertext = 0xd324fd7db1cfaa86511280dafa5340e6\n  },\n\n  { key = 0x1449e32d51b3680f0cb540aa6ccb96f46e17f1a3f23008ab\n  , plaintext = 0xd324fd7db1cfaa86511280dafa5340e6\n  , ciphertext = 0x409aa25dcb51d8831a2f5627746c2bc9\n  },\n\n  { key = 0x63d4b33e24bf3f7c4c2fe2f7a79a4e777438a784865c2362\n  , plaintext = 0x409aa25dcb51d8831a2f5627746c2bc9\n  , ciphertext = 0xbfa0348398b9bc4e07eb1739c589b225\n  },\n\n  { key = 0x03f21169aad21af3f38fd6743f23f23973d3b0bd43d59147\n  , plaintext = 0xbfa0348398b9bc4e07eb1739c589b225\n  , ciphertext = 0x13582b4881e6b7f6398f41b57d617201\n  },\n\n  { key = 0x541879f8770ad35de0d7fd3cbec545cf4a5cf1083eb4e346\n  , plaintext = 0x13582b4881e6b7f6398f41b57d617201\n  , ciphertext = 0xd9d58082c3a976852a350ba551862362\n  },\n\n  { key = 0xd0c6100d7f8fdd8739027dbe7d6c334a6069faad6f32c024\n  , plaintext = 0xd9d58082c3a976852a350ba551862362\n  , ciphertext = 0x3cafa17506a92359c23600404ad61513\n  },\n\n  { key = 0x05345651ac0d23b305addccb7bc51013a25ffaed25e4d537\n  , plaintext = 0x3cafa17506a92359c23600404ad61513\n  , ciphertext = 0xa4a3041803fe9bf7d355b34d21293ecf\n  },\n\n  { key = 0x4ce9e1102ccba488a10ed8d3783b8be4710a49a004cdebf8\n  , plaintext = 0xa4a3041803fe9bf7d355b34d21293ecf\n  , ciphertext = 0xcfa674aba22c17036da437832c635b30\n  },\n\n  { key = 0x08fed0e9350ac7386ea8ac78da179ce71cae7e2328aeb0c8\n  , plaintext = 0xcfa674aba22c17036da437832c635b30\n  , ciphertext = 0xf4de164a6ca93e96dfc91426d636e481\n  },\n\n  { key = 0xcc5643ba704f961c9a76ba32b6bea271c3676a05fe985449\n  , plaintext = 0xf4de164a6ca93e96dfc91426d636e481\n  , ciphertext = 0x1deb553ac91ec346201154dbbdac9b14\n  },\n\n  { key = 0xd413a379439b2caf879def087fa06137e3763ede4334cf5d\n  , plaintext = 0x1deb553ac91ec346201154dbbdac9b14\n  , ciphertext = 0x52372415208849a222acf6f27e145f75\n  },\n\n  { key = 0x575a3e57736fe96dd5aacb1d5f282895c1dac82c3d209028\n  , plaintext = 0x52372415208849a222acf6f27e145f75\n  , ciphertext = 0x710f708e402325c6763ca461f6f855e0\n  },\n\n  { key = 0x7d593f399f198b9da4a5bb931f0b0d53b7e66c4dcbd8c5c8\n  , plaintext = 0x710f708e402325c6763ca461f6f855e0\n  , ciphertext = 0x8fae56699e3af53b86d484be2463b602\n  },\n\n  { key = 0x401e3d459d7254a82b0bedfa8131f8683132e8f3efbb73ca\n  , plaintext = 0x8fae56699e3af53b86d484be2463b602\n  , ciphertext = 0xaa44678efb43326727d5204edc942fe2\n  },\n\n  { key = 0x996d36de694dc3cb814f8a747a72ca0f16e7c8bd332f5c28\n  , plaintext = 0xaa44678efb43326727d5204edc942fe2\n  , ciphertext = 0xfb04caba312e387528a355d39db15db6\n  },\n\n  { key = 0xbba2ddbf7cc063957a4b40ce4b5cf27a3e449d6eae9e019e\n  , plaintext = 0xfb04caba312e387528a355d39db15db6\n  , ciphertext = 0x5d8156335210cc39885ab652d8ccfd33\n  },\n\n  { key = 0x5fdbf5f7b3b389c727ca16fd194c3e43b61e2b3c7652fcad\n  , plaintext = 0x5d8156335210cc39885ab652d8ccfd33\n  , ciphertext = 0x8b8d3455188ad9615a2c3a34c4bfb8df\n  },\n\n  { key = 0xfa876ec64e22b16bac4722a801c6e722ec321108b2ed4472\n  , plaintext = 0x8b8d3455188ad9615a2c3a34c4bfb8df\n  , ciphertext = 0x1c5bab7b91032ffac3a8e4d41a3a5338\n  },\n\n  { key = 0xceeda64221ae37d3b01c89d390c5c8d82f9af5dca8d7174a\n  , plaintext = 0x1c5bab7b91032ffac3a8e4d41a3a5338\n  , ciphertext = 0xad98def9c24e9d0de0e6a9541c86c34c\n  },\n\n  { key = 0xb2b6b9074795f6501d84572a528b55d5cf7c5c88b451d406\n  , plaintext = 0xad98def9c24e9d0de0e6a9541c86c34c\n  , ciphertext = 0xee54a410d2e410e721bf9b12f9a8bb04\n  },\n\n  { key = 0x42e6927395e5d3dbf3d0f33a806f4532eec3c79a4df96f02\n  , plaintext = 0xee54a410d2e410e721bf9b12f9a8bb04\n  , ciphertext = 0x7b894a4e5514249029af1118576093cc\n  },\n\n  { key = 0x07373c871002daaf8859b974d57b61a2c76cd6821a99fcce\n  , plaintext = 0x7b894a4e5514249029af1118576093cc\n  , ciphertext = 0xf555d93e38137c9b931b4583de367ff2\n  },\n\n  { key = 0x8eebc322f66630687d0c604aed681d3954779301c4af833c\n  , plaintext = 0xf555d93e38137c9b931b4583de367ff2\n  , ciphertext = 0xf5adbb37c99646913d1670ccd8203c04\n  },\n\n  { key = 0x56d70f07f90e11ab88a1db7d24fe5ba86961e3cd1c8fbf38\n  , plaintext = 0xf5adbb37c99646913d1670ccd8203c04\n  , ciphertext = 0x122f214900ffcfd59652c1af64b10c71\n  },\n\n  { key = 0xcf4ec9b7f52cd2d99a8efa342401947dff332262783eb349\n  , plaintext = 0x122f214900ffcfd59652c1af64b10c71\n  , ciphertext = 0xbe1b5d5ac7b61b73c479d7b1fc65ea35\n  },\n\n  { key = 0x8ca5b0fe1053b3982495a76ee3b78f0e3b4af5d3845b597c\n  , plaintext = 0xbe1b5d5ac7b61b73c479d7b1fc65ea35\n  , ciphertext = 0xf9868b44c1ce21b040b8fff3716b011a\n  },\n\n  { key = 0x34f2ce0dbb3fa2d2dd132c2a2279aebe7bf20a20f5305866\n  , plaintext = 0xf9868b44c1ce21b040b8fff3716b011a\n  , ciphertext = 0x9cac4efb170dc8ded3fc6a309fd7aca7\n  },\n\n  { key = 0x603bbb7bf54b365d41bf62d135746660a80e60106ae7f4c1\n  , plaintext = 0x9cac4efb170dc8ded3fc6a309fd7aca7\n  , ciphertext = 0xe52a42e78048c6dda63f98fc6c5f47f9\n  },\n\n  { key = 0xa146ac000cb1f14ba4952036b53ca0bd0e31f8ec06b8b338\n  , plaintext = 0xe52a42e78048c6dda63f98fc6c5f47f9\n  , ciphertext = 0x826af473c60d61bd746a8d8bda3b410c\n  },\n\n  { key = 0x979e0246f75d08e226ffd4457331c1007a5b7567dc83f234\n  , plaintext = 0x826af473c60d61bd746a8d8bda3b410c\n  , ciphertext = 0x9fa4ebdccace9033a56e3a5aace74dba\n  },\n\n  { key = 0x3c34cf05821c9d17b95b3f99b9ff5133df354f3d7064bf8e\n  , plaintext = 0x9fa4ebdccace9033a56e3a5aace74dba\n  , ciphertext = 0xe0ac5dee9d6247d50b379589c2415444\n  },\n\n  { key = 0x3e42ac26f6c0977a59f76277249d16e6d402dab4b225ebca\n  , plaintext = 0xe0ac5dee9d6247d50b379589c2415444\n  , ciphertext = 0x462562da72ea6b5c371530c716879dcd\n  },\n\n  { key = 0xed7edff15890f7841fd200ad56777dbae317ea73a4a27607\n  , plaintext = 0x462562da72ea6b5c371530c716879dcd\n  , ciphertext = 0x78a040009e18ef207253ef992e7e2c91\n  },\n\n  { key = 0x4140882041912162677240adc86f929a914405ea8adc5a96\n  , plaintext = 0x78a040009e18ef207253ef992e7e2c91\n  , ciphertext = 0xf8c7a79f10c92ec49e1ec59b08498d64\n  },\n\n  { key = 0x2cbc00f60f66695a9fb5e732d8a6bc5e0f5ac0718295d7f2\n  , plaintext = 0xf8c7a79f10c92ec49e1ec59b08498d64\n  , ciphertext = 0x2f9a5f2cfd515a6878ecd923c36b1b4e\n  },\n\n  { key = 0xce9854aa7b6e184ab02fb81e25f7e63677b6195241feccbc\n  , plaintext = 0x2f9a5f2cfd515a6878ecd923c36b1b4e\n  , ciphertext = 0xf7d3b3758ecf5359ab523beaa17a0306\n  },\n\n  { key = 0x93163ae28f22570b47fc0b6bab38b56fdce422b8e084cfba\n  , plaintext = 0xf7d3b3758ecf5359ab523beaa17a0306\n  , ciphertext = 0x6c9dd076750bd1d2c0b8f203ca14ee1e\n  },\n\n  { key = 0xca2a7882db1cb3b52b61db1dde3364bd1c5cd0bb2a9021a4\n  , plaintext = 0x6c9dd076750bd1d2c0b8f203ca14ee1e\n  , ciphertext = 0x289cf1ab3b9eac26cdd02df244412d4e\n  },\n\n  { key = 0x90dc3a02ba5b5f2b03fd2ab6e5adc89bd18cfd496ed10cea\n  , plaintext = 0x289cf1ab3b9eac26cdd02df244412d4e\n  , ciphertext = 0x8ee4ca3c6c9cc5f27ddb79ae7cfcc47e\n  },\n\n  { key = 0x11b26d4f3eb77d218d19e08a89310d69ac5784e7122dc894\n  , plaintext = 0x8ee4ca3c6c9cc5f27ddb79ae7cfcc47e\n  , ciphertext = 0x6cbf94fcdcadfd9a39d4c4f702d7b101\n  },\n\n  { key = 0x7159cd8684c28039e1a67476559cf0f39583401010fa7995\n  , plaintext = 0x6cbf94fcdcadfd9a39d4c4f702d7b101\n  , ciphertext = 0x5047270db233f75e84c734b5cb56f765\n  },\n\n  { key = 0x76bbdc75f530ec0ab1e1537be7af07ad114474a5dbac8ef0\n  , plaintext = 0x5047270db233f75e84c734b5cb56f765\n  , ciphertext = 0xb82602cd22e7821be62e5ff67cb193c6\n  },\n\n  { key = 0x306a4720867eca7009c751b6c54885b6f76a2b53a71d1d36\n  , plaintext = 0xb82602cd22e7821be62e5ff67cb193c6\n  , ciphertext = 0x5a241fbcb4a0f769c37408abe658da25\n  },\n\n  { key = 0x306323bbf53bd84f53e34e0a71e872df341e23f84145c713\n  , plaintext = 0x5a241fbcb4a0f769c37408abe658da25\n  , ciphertext = 0x9a63d956a9c719465e30cdc160991042\n  },\n\n  { key = 0x897b6f11ecb97862c980975cd82f6b996a2eee3921dcd751\n  , plaintext = 0x9a63d956a9c719465e30cdc160991042\n  , ciphertext = 0x2a733f407d8080470c5f22a6cf8358cd\n  },\n\n  { key = 0x14fa0e9978672ad5e3f3a81ca5afebde6671cc9fee5f8f9c\n  , plaintext = 0x2a733f407d8080470c5f22a6cf8358cd\n  , ciphertext = 0x24db9f77f61060accf6d41e7639c1ec6\n  },\n\n  { key = 0xc1125a27a85e3826c728376b53bf8b72a91c8d788dc3915a\n  , plaintext = 0x24db9f77f61060accf6d41e7639c1ec6\n  , ciphertext = 0xa89eccce6ee8c9d4d34cf5ba8b29cba7\n  },\n\n  { key = 0x1ce385ac9c70d4e26fb6fba53d5742a67a5078c206ea5afd\n  , plaintext = 0xa89eccce6ee8c9d4d34cf5ba8b29cba7\n  , ciphertext = 0xe4ef08e86141940ef87d6b385d19108c\n  },\n\n  { key = 0x9a3967a8ff01d35f8b59f34d5c16d6a8822d13fa5bf34a71\n  , plaintext = 0xe4ef08e86141940ef87d6b385d19108c\n  , ciphertext = 0x1039c441007d6805551a87e820c63dca\n  },\n\n  { key = 0x7d0af1cd0d641f209b60370c5c6bbeadd73794127b3577bb\n  , plaintext = 0x1039c441007d6805551a87e820c63dca\n  , ciphertext = 0x2584b55b214a94ee9894b104178a6dd5\n  },\n\n  { key = 0x3f78d295449908e6bee482577d212a434fa325166cbf1a6e\n  , plaintext = 0x2584b55b214a94ee9894b104178a6dd5\n  , ciphertext = 0x9d32bd6357551091ca659f7bd4509fc2\n  },\n\n  { key = 0x9cd28f265a13556123d63f342a743ad285c6ba6db8ef85ac\n  , plaintext = 0x9d32bd6357551091ca659f7bd4509fc2\n  , ciphertext = 0x9ac46eb8e253bb37304394ff0042d306\n  },\n\n  { key = 0x34caf580014164d4b912518cc82781e5b5852e92b8ad56aa\n  , plaintext = 0x9ac46eb8e253bb37304394ff0042d306\n  , ciphertext = 0x3b899f1f2d93e3890418763fdd35943a\n  },\n\n  { key = 0x7c19a50fa9360041829bce93e5b4626cb19d58ad6598c290\n  , plaintext = 0x3b899f1f2d93e3890418763fdd35943a\n  , ciphertext = 0xea89d4537784f253eae2d6cebdd63a4c\n  },\n\n  { key = 0x2109b2880479bb4f68121ac09230903f5b7f8e63d84ef8dc\n  , plaintext = 0xea89d4537784f253eae2d6cebdd63a4c\n  , ciphertext = 0x80711a42f6687a62590a8a0d165b2fb8\n  },\n\n  { key = 0x83fe682b1fcdb57be86300826458ea5d0275046ece15d764\n  , plaintext = 0x80711a42f6687a62590a8a0d165b2fb8\n  , ciphertext = 0xb2174ffab755e3e0c666cecb075256ec\n  },\n\n  { key = 0x63434f6c69c041735a744f78d30d09bdc413caa5c9478188\n  , plaintext = 0xb2174ffab755e3e0c666cecb075256ec\n  , ciphertext = 0x57120386bd566d31807a6fe7b0e78041\n  },\n\n  { key = 0xdfa4b3f99eda96420d664cfe6e5b648c4469a54279a001c9\n  , plaintext = 0x57120386bd566d31807a6fe7b0e78041\n  , ciphertext = 0x3b128fcdb7bb4252b5e5e00df5629508\n  },\n\n  { key = 0x24fa37bb6d70bd943674c333d9e026def18c454f8cc294c1\n  , plaintext = 0x3b128fcdb7bb4252b5e5e00df5629508\n  , ciphertext = 0x4826cf69d83c7f475230679b61ca8e0a\n  },\n\n  { key = 0x246a7408f739d1d37e520c5a01dc5999a3bc22d4ed081acb\n  , plaintext = 0x4826cf69d83c7f475230679b61ca8e0a\n  , ciphertext = 0x25a23c7fb798a50f5929e90e743da11c\n  },\n\n  { key = 0x9f1827be83518dbc5bf03025b644fc96fa95cbda9935bbd7\n  , plaintext = 0x25a23c7fb798a50f5929e90e743da11c\n  , ciphertext = 0x7639e9f902d65feb6bc5cbc44b5e12ed\n  },\n\n  { key = 0xfda6b0d164b7fd982dc9d9dcb492a37d9150001ed26ba93a\n  , plaintext = 0x7639e9f902d65feb6bc5cbc44b5e12ed\n  , ciphertext = 0x85a71ee457e94fc85cb9ac461fff1c4f\n  },\n\n  { key = 0x0755b86a470bb93aa86ec738e37becb5cde9ac58cd94b575\n  , plaintext = 0x85a71ee457e94fc85cb9ac461fff1c4f\n  , ciphertext = 0xc9ef84a268877ecef88bb554ea63c336\n  },\n\n  { key = 0x8f13f2d9085091816181439a8bfc927b3562190c27f77643\n  , plaintext = 0xc9ef84a268877ecef88bb554ea63c336\n  , ciphertext = 0x260dd6bf1366c029b5fd64e72853d2d7\n  },\n\n  { key = 0xfdd71c524c374345478c9525989a5252809f7deb0fa4a494\n  , plaintext = 0x260dd6bf1366c029b5fd64e72853d2d7\n  , ciphertext = 0x39cc3e224738efaaf45fab525fc13127\n  },\n\n  { key = 0x8bd43e3f448778ea7e40ab07dfa2bdf874c0d6b9506595b3\n  , plaintext = 0x39cc3e224738efaaf45fab525fc13127\n  , ciphertext = 0x4d5ac8506c0a13b1c2092731c6fe5fbc\n  },\n\n  { key = 0x69b7449dc811b19c331a6357b3a8ae49b6c9f188969bca0f\n  , plaintext = 0x4d5ac8506c0a13b1c2092731c6fe5fbc\n  , ciphertext = 0xede69bd80f879d57640c77bc1312f064\n  },\n\n  { key = 0x40e1692d44e3b441defcf88fbc2f331ed2c5863485893a6b\n  , plaintext = 0xede69bd80f879d57640c77bc1312f064\n  , ciphertext = 0x31dc854d8552e6684904bc6502682434\n  },\n\n  { key = 0xc1de7d9285751138ef207dc2397dd5769bc13a5187e11e5f\n  , plaintext = 0x31dc854d8552e6684904bc6502682434\n  , ciphertext = 0xc7bdc57aaa445e489655154b25d3906d\n  },\n\n  { key = 0xd8689fdcc9b77227289db8b893398b3e0d942f1aa2328e32\n  , plaintext = 0xc7bdc57aaa445e489655154b25d3906d\n  , ciphertext = 0xc4b498470a24113b6b182674c0366131\n  },\n\n  { key = 0x8293a998633a405dec2920ff991d9a05668c096e6204ef03\n  , plaintext = 0xc4b498470a24113b6b182674c0366131\n  , ciphertext = 0x7575104da6d5b4e0fb21d682f93d0d24\n  },\n\n  { key = 0xe71e9c0918c908ae995c30b23fc82ee59daddfec9b39e227\n  , plaintext = 0x7575104da6d5b4e0fb21d682f93d0d24\n  , ciphertext = 0xc5acdc318353c4ef3f6f45bf4a84c659\n  },\n\n  { key = 0xa5f19f392eb2afd15cf0ec83bc9bea0aa2c29a53d1bd247e\n  , plaintext = 0xc5acdc318353c4ef3f6f45bf4a84c659\n  , ciphertext = 0xaf6a60f60fc085656e305a4c050cc9c3\n  },\n\n  { key = 0x180b05bff13a1ad3f39a8c75b35b6f6fccf2c01fd4b1edbd\n  , plaintext = 0xaf6a60f60fc085656e305a4c050cc9c3\n  , ciphertext = 0x9d5f30e488c3243ad20767b39ec9ee4e\n  },\n\n  { key = 0x1fb7ff20cab8a5186ec5bc913b984b551ef5a7ac4a7803f3\n  , plaintext = 0x9d5f30e488c3243ad20767b39ec9ee4e\n  , ciphertext = 0x5c3a1d144e5efe7cede88e21dcbc2777\n  },\n\n  { key = 0x3e999761c9d15f3932ffa18575c6b529f31d298d96c42484\n  , plaintext = 0x5c3a1d144e5efe7cede88e21dcbc2777\n  , ciphertext = 0x4f163c25a6d545ccffc54511b2a5605d\n  },\n\n  { key = 0x8bc1e531e9d3f84f7de99da0d313f0e50cd86c9c246144d9\n  , plaintext = 0x4f163c25a6d545ccffc54511b2a5605d\n  , ciphertext = 0x3eed65dab0bd7ae8c8b115fa185e310a\n  },\n\n  { key = 0x4efaae2e7ecadcd24304f87a63ae8a0dc46979663c3f75d3\n  , plaintext = 0x3eed65dab0bd7ae8c8b115fa185e310a\n  , ciphertext = 0xfefce0da5af3885d022636f19adab9b8\n  },\n\n  { key = 0x44e1224d08476e9cbdf818a0395d0250c64f4f97a6e5cc6b\n  , plaintext = 0xfefce0da5af3885d022636f19adab9b8\n  , ciphertext = 0x3a0c3d806aff32fde868343b0b58c77a\n  },\n\n  { key = 0xef93ffb9eb0b9f1787f4252053a230ad2e277bacadbd0b11\n  , plaintext = 0x3a0c3d806aff32fde868343b0b58c77a\n  , ciphertext = 0x6610ee19970ee606083968e523af2370\n  },\n\n  { key = 0xfc7c2c3d27519036e1e4cb39c4acd6ab261e13498e122861\n  , plaintext = 0x6610ee19970ee606083968e523af2370\n  , ciphertext = 0x2f714ddbd4adf8327dc93c723aebfffa\n  },\n\n  { key = 0xf2f8a8247724e289ce9586e210012e995bd72f3bb4f9d79b\n  , plaintext = 0x2f714ddbd4adf8327dc93c723aebfffa\n  , ciphertext = 0x5d1196da8f184975e240949a25104554\n  }]\n\n\naes192_MCT_decrypt_test_vectors : [100](AESTestVector 192)\naes192_MCT_decrypt_test_vectors =\n [{ key = 0x4b97585701c03fbebdfa8555024f589f1482c58a00fdd9fd\n  , ciphertext = 0xd0bd0e02ded155e4516be83f42d347a4\n  , plaintext = 0xc7b6581ccc88f7fc26d15d2731e7251b\n  },\n\n  { key = 0x3c98c80336e0f13f7a4cdd49cec7af63325398ad311afce6\n  , ciphertext = 0xc7b6581ccc88f7fc26d15d2731e7251b\n  , plaintext = 0x01aa957b12c596511484ed7705766c67\n  },\n\n  { key = 0x825349971b370dc47be64832dc02393226d775da346c9081\n  , ciphertext = 0x01aa957b12c596511484ed7705766c67\n  , plaintext = 0xf98c15d93f5daef6047c2760c5df5540\n  },\n\n  { key = 0xebb9611cf25685c3826a5debe35f97c422ab52baf1b3c5c1\n  , ciphertext = 0xf98c15d93f5daef6047c2760c5df5540\n  , plaintext = 0x5c86395c6b3ed7d30d5e3ce3331fb3ed\n  },\n\n  { key = 0xd8d6d591e30f4e77deec64b7886140172ff56e59c2ac762c\n  , ciphertext = 0x5c86395c6b3ed7d30d5e3ce3331fb3ed\n  , plaintext = 0x8e8cb768b31e65d054e9db8d19862084\n  },\n\n  { key = 0x775a6f9a0e4733e45060d3df3b7f25c77b1cb5d4db2a56a8\n  , ciphertext = 0x8e8cb768b31e65d054e9db8d19862084\n  , plaintext = 0x96cab38070ea8e37c3d437a091e9e74c\n  },\n\n  { key = 0x511e536ea113429bc6aa605f4b95abf0b8c882744ac3b1e4\n  , ciphertext = 0x96cab38070ea8e37c3d437a091e9e74c\n  , plaintext = 0xf8356cfe486b2375c2e2e4138b285ce7\n  },\n\n  { key = 0xc3f94c74f86b59723e9f0ca103fe88857a2a6667c1ebed03\n  , ciphertext = 0xf8356cfe486b2375c2e2e4138b285ce7\n  , plaintext = 0x6a15770b29960c063395a70dc3cf7575\n  },\n\n  { key = 0xa220f197ee7db5a2548a7baa2a68848349bfc16a02249876\n  , ciphertext = 0x6a15770b29960c063395a70dc3cf7575\n  , plaintext = 0xd16463745da38ef8997e20e102fb8573\n  },\n\n  { key = 0x187bc771e567fb1285ee18de77cb0a7bd0c1e18b00df1d05\n  , ciphertext = 0xd16463745da38ef8997e20e102fb8573\n  , plaintext = 0x98ea16875a9e3006de150e93be9585b8\n  },\n\n  { key = 0x432ab1057033bb041d040e592d553a7d0ed4ef18be4a98bd\n  , ciphertext = 0x98ea16875a9e3006de150e93be9585b8\n  , plaintext = 0x9d4c05cb0c5cb543515cfd05a4b90004\n  },\n\n  { key = 0x64a7f543e2e2a60780480b9221098f3e5f88121d1af398b9\n  , ciphertext = 0x9d4c05cb0c5cb543515cfd05a4b90004\n  , plaintext = 0x93c4638f0f76b0a42481c030314ca594\n  },\n\n  { key = 0x755c48e6e44a956f138c681d2e7f3f9a7b09d22d2bbf3d2d\n  , ciphertext = 0x93c4638f0f76b0a42481c030314ca594\n  , plaintext = 0x8ad1d144144c8530218c0edf3119aa82\n  },\n\n  { key = 0x4ff1466b9e9939af995db9593a33baaa5a85dcf21aa697af\n  , ciphertext = 0x8ad1d144144c8530218c0edf3119aa82\n  , plaintext = 0xa46e11cca3b2f98e9f7360d33d236189\n  },\n\n  { key = 0xb2e265f13266035a3d33a89599814324c5f6bc212785f626\n  , ciphertext = 0xa46e11cca3b2f98e9f7360d33d236189\n  , plaintext = 0x9ece35fb84957574fd353cfac1608943\n  },\n\n  { key = 0x102d9afa0e70b1daa3fd9d6e1d14365038c380dbe6e57f65\n  , ciphertext = 0x9ece35fb84957574fd353cfac1608943\n  , plaintext = 0x225ce2f6987392afd1921c5eecd6ba17\n  },\n\n  { key = 0xc772081227697cc081a17f988567a4ffe9519c850a33c572\n  , ciphertext = 0x225ce2f6987392afd1921c5eecd6ba17\n  , plaintext = 0x85fd494bfd5127cff96088e0b130ef04\n  },\n\n  { key = 0xc306028aea2e8f1c045c36d37836833010311465bb032a76\n  , ciphertext = 0x85fd494bfd5127cff96088e0b130ef04\n  , plaintext = 0x1e693009be7a868db9e6a495c2e238f3\n  },\n\n  { key = 0x7a646ea7ab6a11101a3506dac64c05bda9d7b0f079e11285\n  , ciphertext = 0x1e693009be7a868db9e6a495c2e238f3\n  , plaintext = 0x49f55237f9a66050b7e04e66a0b4bf24\n  },\n\n  { key = 0xddbe30e84a14077953c054ed3fea65ed1e37fe96d955ada1\n  , ciphertext = 0x49f55237f9a66050b7e04e66a0b4bf24\n  , plaintext = 0xb966ec6748bd876046be2be11abff82a\n  },\n\n  { key = 0x55e1472be2e1739aeaa6b88a7757e28d5889d577c3ea558b\n  , ciphertext = 0xb966ec6748bd876046be2be11abff82a\n  , plaintext = 0x0f6a78ac23e6ea2d9f4232e8568cea97\n  },\n\n  { key = 0x38750e9c7a729e09e5ccc02654b108a0c7cbe79f9566bf1c\n  , ciphertext = 0x0f6a78ac23e6ea2d9f4232e8568cea97\n  , plaintext = 0xc80bfbe58fb9b00cd4858fd769e3cd1d\n  },\n\n  { key = 0xe45ace33a0f7494c2dc73bc3db08b8ac134e6848fc857201\n  , ciphertext = 0xc80bfbe58fb9b00cd4858fd769e3cd1d\n  , plaintext = 0x918e28b7a7ad8a370d2f260f9f7a5fec\n  },\n\n  { key = 0xd2a3b2ca9419501abc4913747ca5329b1e614e4763ff2ded\n  , ciphertext = 0x918e28b7a7ad8a370d2f260f9f7a5fec\n  , plaintext = 0x59d1732fc2452e53eeda0790b80a244a\n  },\n\n  { key = 0x9dae1b9eaa53bdfce598605bbee01cc8f0bb49d7dbf509a7\n  , ciphertext = 0x59d1732fc2452e53eeda0790b80a244a\n  , plaintext = 0xe74d820249410cd1a39287dc536ed5fc\n  },\n\n  { key = 0xe74268a3d42edb8702d5e259f7a110195329ce0b889bdc5b\n  , ciphertext = 0xe74d820249410cd1a39287dc536ed5fc\n  , plaintext = 0x27ca67828485be98a6cd22d724af53b9\n  },\n\n  { key = 0x0d793e8f7e0ea82d251f85db7324ae81f5e4ecdcac348fe2\n  , ciphertext = 0x27ca67828485be98a6cd22d724af53b9\n  , plaintext = 0x4927ab19552102414e39126b8a91c675\n  },\n\n  { key = 0xc99788fd8dc7a7246c382ec22605acc0bbddfeb726a54997\n  , ciphertext = 0x4927ab19552102414e39126b8a91c675\n  , plaintext = 0x99ea6ccf100d06243b45998d68c9b6bc\n  },\n\n  { key = 0x733425872bb717edf5d2420d3608aae48098673a4e6cff2b\n  , ciphertext = 0x99ea6ccf100d06243b45998d68c9b6bc\n  , plaintext = 0xf029e59925e67de178b5cb9fd187f2c6\n  },\n\n  { key = 0xfc02106517299a1e05fba79413eed705f82daca59feb0ded\n  , ciphertext = 0xf029e59925e67de178b5cb9fd187f2c6\n  , plaintext = 0x5f9da95aa424d5a65f1ff3d99769522d\n  },\n\n  { key = 0x9b0efe0e5f4f4e395a660eceb7ca02a3a7325f7c08825fc0\n  , ciphertext = 0x5f9da95aa424d5a65f1ff3d99769522d\n  , plaintext = 0xa20f232bb355370df27f55bb53469b40\n  },\n\n  { key = 0x502b270205133d51f8692de5049f35ae554d0ac75bc4c480\n  , ciphertext = 0xa20f232bb355370df27f55bb53469b40\n  , plaintext = 0x32e5d13e44b2e67952d8ef98af19a4d3\n  },\n\n  { key = 0xd1cac8a82a2e3ab3ca8cfcdb402dd3d70795e55ff4dd6053\n  , ciphertext = 0x32e5d13e44b2e67952d8ef98af19a4d3\n  , plaintext = 0x688ab3ed2b373467bc547be2bf519846\n  },\n\n  { key = 0x7e4af6629efd55dfa2064f366b1ae7b0bbc19ebd4b8cf815\n  , ciphertext = 0x688ab3ed2b373467bc547be2bf519846\n  , plaintext = 0x1a88d45de26cab118e86fe7089d818d0\n  },\n\n  { key = 0x216cd4ed3d38e68cb88e9b6b89764ca1354760cdc254e0c5\n  , ciphertext = 0x1a88d45de26cab118e86fe7089d818d0\n  , plaintext = 0x8d154a7ebc0e6fd2d6d7686d9b9492ad\n  },\n\n  { key = 0xedf6f3e4f323dc91359bd11535782373e39008a059c07268\n  , ciphertext = 0x8d154a7ebc0e6fd2d6d7686d9b9492ad\n  , plaintext = 0xbe46ead5f431ee2c6d1795f852558ed7\n  },\n\n  { key = 0x94afb2de656daf688bdd3bc0c149cd5f8e879d580b95fcbf\n  , ciphertext = 0xbe46ead5f431ee2c6d1795f852558ed7\n  , plaintext = 0x9f1ecd9839abd6abbecba89a71405c76\n  },\n\n  { key = 0x70bea40807c903c714c3f658f8e21bf4304c35c27ad5a0c9\n  , ciphertext = 0x9f1ecd9839abd6abbecba89a71405c76\n  , plaintext = 0xf5f335142d71d35a4723bbece7a39c43\n  },\n\n  { key = 0xb32369cb5a1611d7e130c34cd593c8ae776f8e2e9d763c8a\n  , ciphertext = 0xf5f335142d71d35a4723bbece7a39c43\n  , plaintext = 0x55ace2aa461af10d10436e529a2d8d85\n  },\n\n  { key = 0xf6412cbd1f98e445b49c21e6938939a3672ce07c075bb10f\n  , ciphertext = 0x55ace2aa461af10d10436e529a2d8d85\n  , plaintext = 0xf6670a6576aa2d20b63482aab26f7c82\n  },\n\n  { key = 0xea7cf55a9e0fcb0d42fb2b83e5231483d11862d6b534cd8d\n  , ciphertext = 0xf6670a6576aa2d20b63482aab26f7c82\n  , plaintext = 0x93e81b9866979a0adc573d380065f18e\n  },\n\n  { key = 0x1a5d1de4468ed5e5d113301b83b48e890d4f5feeb5513c03\n  , ciphertext = 0x93e81b9866979a0adc573d380065f18e\n  , plaintext = 0x324024007edad9a3e4b435b212bfec88\n  },\n\n  { key = 0x8ed3c18837593af6e353141bfd6e572ae9fb6a5ca7eed08b\n  , ciphertext = 0x324024007edad9a3e4b435b212bfec88\n  , plaintext = 0x5eb5e71f06992c1998ae0cf03dbc9dce\n  },\n\n  { key = 0xe5d6d1566d3c9a17bde6f304fbf77b33715566ac9a524d45\n  , ciphertext = 0x5eb5e71f06992c1998ae0cf03dbc9dce\n  , plaintext = 0xa83fe8f226ad5ee5b358fac03a092882\n  },\n\n  { key = 0xd5ec4f5df302bfa515d91bf6dd5a25d6c20d9c6ca05b65c7\n  , ciphertext = 0xa83fe8f226ad5ee5b358fac03a092882\n  , plaintext = 0x72360b4fcd1293a36ed0bb44213da8b9\n  },\n\n  { key = 0x50257306e757d76567ef10b91048b675acdd27288166cd7e\n  , ciphertext = 0x72360b4fcd1293a36ed0bb44213da8b9\n  , plaintext = 0x982119600a3e73dff33583558134bcf0\n  },\n\n  { key = 0x64b394f798415fbcffce09d91a76c5aa5fe8a47d0052718e\n  , ciphertext = 0x982119600a3e73dff33583558134bcf0\n  , plaintext = 0x0c33669b84d714959785b37d586bb355\n  },\n\n  { key = 0xcbaf8d92f18efe87f3fd6f429ea1d13fc86d17005839c2db\n  , ciphertext = 0x0c33669b84d714959785b37d586bb355\n  , plaintext = 0x9fc2fd51bbefd70fe7ce0c13af3d2ace\n  },\n\n  { key = 0x80bb745fb5b9cb616c3f9213254e06302fa31b13f704e815\n  , ciphertext = 0x9fc2fd51bbefd70fe7ce0c13af3d2ace\n  , plaintext = 0xaf4a4566e556a7f2dd3477a53c094498\n  },\n\n  { key = 0xb5d94340d5852f04c375d775c018a1c2f2976cb6cb0dac8d\n  , ciphertext = 0xaf4a4566e556a7f2dd3477a53c094498\n  , plaintext = 0x8107ca3fc833fee74501f2a42f088401\n  },\n\n  { key = 0x23341a3b649010c942721d4a082b5f25b7969e12e405288c\n  , ciphertext = 0x8107ca3fc833fee74501f2a42f088401\n  , plaintext = 0x714341183a67b95abcf9bc992d1aa290\n  },\n\n  { key = 0x955075d16664498333315c52324ce67f0b6f228bc91f8a1c\n  , ciphertext = 0x714341183a67b95abcf9bc992d1aa290\n  , plaintext = 0x564289f3ac30d6e27dde4308ee5637ab\n  },\n\n  { key = 0x9e5493cf59a7d0e76573d5a19e7c309d76b161832749bdb7\n  , ciphertext = 0x564289f3ac30d6e27dde4308ee5637ab\n  , plaintext = 0x805424be37b7f0b5498ab5bf8904f468\n  },\n\n  { key = 0x0e8dd0538bcfa448e527f11fa9cbc0283f3bd43cae4d49df\n  , ciphertext = 0x805424be37b7f0b5498ab5bf8904f468\n  , plaintext = 0x793554c1cc565f00f9f2122bd06672aa\n  },\n\n  { key = 0xf253723471590c249c12a5de659d9f28c6c9c6177e2b3b75\n  , ciphertext = 0x793554c1cc565f00f9f2122bd06672aa\n  , plaintext = 0xb89feee17d71a452b46e4683cfddc0ba\n  },\n\n  { key = 0x14781c9f73227825248d4b3f18ec3b7a72a78094b1f6fbcf\n  , ciphertext = 0xb89feee17d71a452b46e4683cfddc0ba\n  , plaintext = 0x737c418d35812556f6d26ebf91028ad7\n  },\n\n  { key = 0xc4706d6414a3594657f10ab22d6d1e2c8475ee2b20f47118\n  , ciphertext = 0x737c418d35812556f6d26ebf91028ad7\n  , plaintext = 0xc2e352ec712b84fa74f98254740d0847\n  },\n\n  { key = 0x74fabaf96545e7199512585e5c469ad6f08c6c7f54f9795f\n  , ciphertext = 0xc2e352ec712b84fa74f98254740d0847\n  , plaintext = 0xe09f8d7cc0e4d7f4efb65e10529592e5\n  },\n\n  { key = 0xdbfa75aad7f1ad19758dd5229ca24d221f3a326f066cebba\n  , ciphertext = 0xe09f8d7cc0e4d7f4efb65e10529592e5\n  , plaintext = 0x8a8911579e11d858bd4e336b8125fa6f\n  },\n\n  { key = 0xad8ea306bb3eb77bff04c47502b3957aa2740104874911d5\n  , ciphertext = 0x8a8911579e11d858bd4e336b8125fa6f\n  , plaintext = 0x3b1f396eae6ae53926e9607fb4b6e1d6\n  },\n\n  { key = 0x2b204520b1389d5bc41bfd1bacd97043849d617b33fff003\n  , ciphertext = 0x3b1f396eae6ae53926e9607fb4b6e1d6\n  , plaintext = 0x6d06fe256d84ab0112119425d70d5aa6\n  },\n\n  { key = 0x86d761e020a46b76a91d033ec15ddb42968cf55ee4f2aaa5\n  , ciphertext = 0x6d06fe256d84ab0112119425d70d5aa6\n  , plaintext = 0x537dd3000fdff67107362da65c95f101\n  },\n\n  { key = 0xbee0861f51136bd0fa60d03ece822d3391bad8f8b8675ba4\n  , ciphertext = 0x537dd3000fdff67107362da65c95f101\n  , plaintext = 0x2843b7b7107b1390be393137e3e266c9\n  },\n\n  { key = 0x8706a8a8fab02e3dd2236789def93ea32f83e9cf5b853d6d\n  , ciphertext = 0x2843b7b7107b1390be393137e3e266c9\n  , plaintext = 0xd5fae73a8940ec3c1bebe8a5e4fa0423\n  },\n\n  { key = 0x43ab0c1509505c7407d980b357b9d29f3468016abf7f394e\n  , ciphertext = 0xd5fae73a8940ec3c1bebe8a5e4fa0423\n  , plaintext = 0x63a9a8c99a6a8984dc6975772dd0beac\n  },\n\n  { key = 0xfb0dbb8cab3b89b16470287acdd35b1be801741d92af87e2\n  , ciphertext = 0x63a9a8c99a6a8984dc6975772dd0beac\n  , plaintext = 0x4c7b28c69c39c7eea1359ba2c167266a\n  },\n\n  { key = 0x1abc6031a84a5908280b00bc51ea9cf54934efbf53c8a188\n  , ciphertext = 0x4c7b28c69c39c7eea1359ba2c167266a\n  , plaintext = 0x076024c11bf696874d791813887685e7\n  },\n\n  { key = 0x746718f146cad3d92f6b247d4a1c0a72044df7acdbbe246f\n  , ciphertext = 0x076024c11bf696874d791813887685e7\n  , plaintext = 0xb413f148dc94e0525ad4800fb53dfc64\n  },\n\n  { key = 0x65a422dccc0f07779b78d5359688ea205e9977a36e83d80b\n  , ciphertext = 0xb413f148dc94e0525ad4800fb53dfc64\n  , plaintext = 0xbd94776297b168e862d3afd0669a2668\n  },\n\n  { key = 0x6d9fc6a3839c401426eca257013982c83c4ad8730819fe63\n  , ciphertext = 0xbd94776297b168e862d3afd0669a2668\n  , plaintext = 0xa383eb812e9d2ad7d04ef05beebc663c\n  },\n\n  { key = 0x31e8ba40171be0cc856f49d62fa4a81fec042828e6a5985f\n  , ciphertext = 0xa383eb812e9d2ad7d04ef05beebc663c\n  , plaintext = 0x125833c5a964733d24ca84ae573e537e\n  },\n\n  { key = 0xa1bd656677244e3597377a1386c0db22c8ceac86b19bcb21\n  , ciphertext = 0x125833c5a964733d24ca84ae573e537e\n  , plaintext = 0xd6597fe3687c9dc2f6087ad48bb2ab18\n  },\n\n  { key = 0x9467df27c2b90ca7416e05f0eebc46e03ec6d6523a296039\n  , ciphertext = 0xd6597fe3687c9dc2f6087ad48bb2ab18\n  , plaintext = 0xfd6abdb2793f849bedea160e34ab1a9d\n  },\n\n  { key = 0x1ee8f6b4187a87f0bc04b8429783c27bd32cc05c0e827aa4\n  , ciphertext = 0xfd6abdb2793f849bedea160e34ab1a9d\n  , plaintext = 0xfd2ccba255e74b16864ac2ff80894ebb\n  },\n\n  { key = 0x3f23c25c52d6454c412873e0c264896d556602a38e0b341f\n  , ciphertext = 0xfd2ccba255e74b16864ac2ff80894ebb\n  , plaintext = 0x4571abacb8faa74007702258220b3e19\n  },\n\n  { key = 0x4eedfc725f3901b80459d84c7a9e2e2d521620fbac000a06\n  , ciphertext = 0x4571abacb8faa74007702258220b3e19\n  , plaintext = 0x941b069f7545d16d24e69a309794a259\n  },\n\n  { key = 0xad8b4cd042b874d09042ded30fdbff4076f0bacb3b94a85f\n  , ciphertext = 0x941b069f7545d16d24e69a309794a259\n  , plaintext = 0x515ab9b50447ea30e5ab92ddd1498d69\n  },\n\n  { key = 0xc085e9fde0a60664c11867660b9c1570935b2816eadd2536\n  , ciphertext = 0x515ab9b50447ea30e5ab92ddd1498d69\n  , plaintext = 0x872c0d54b1382c095b1a475fee114cd5\n  },\n\n  { key = 0x4790a2b2ee108fbb46346a32baa43979c8416f4904cc69e3\n  , ciphertext = 0x872c0d54b1382c095b1a475fee114cd5\n  , plaintext = 0x6aa4b9e4559d2c1de4f59dafbaf0909e\n  },\n\n  { key = 0x56880340e6eaf2472c90d3d6ef3915642cb4f2e6be3cf97d\n  , ciphertext = 0x6aa4b9e4559d2c1de4f59dafbaf0909e\n  , plaintext = 0xc4ce24dd760b44799d00ce4c5ffdb8c5\n  },\n\n  { key = 0xd321a216923e2c1de85ef70b9932511db1b43caae1c141b8\n  , ciphertext = 0xc4ce24dd760b44799d00ce4c5ffdb8c5\n  , plaintext = 0xd73e44ee7f75c2fb6696aaba64af9925\n  },\n\n  { key = 0xa80125606ef3f3953f60b3e5e64793e6d7229610856ed89d\n  , ciphertext = 0xd73e44ee7f75c2fb6696aaba64af9925\n  , plaintext = 0x1add98acb3a31733b3e0a32da14a71cf\n  },\n\n  { key = 0xfd54730799c76e1e25bd2b4955e484d564c2353d2424a952\n  , ciphertext = 0x1add98acb3a31733b3e0a32da14a71cf\n  , plaintext = 0x6d2201f6268f7c126e4d57375f5ac97b\n  },\n\n  { key = 0xb07e344619df38e5489f2abf736bf8c70a8f620a7b7e6029\n  , ciphertext = 0x6d2201f6268f7c126e4d57375f5ac97b\n  , plaintext = 0x349daafd5a9676a0bf5e015319a5083b\n  },\n\n  { key = 0xf66e7702379bbeac7c02804229fd8e67b5d1635962db6812\n  , ciphertext = 0x349daafd5a9676a0bf5e015319a5083b\n  , plaintext = 0xfd6cd698388a46f696da48543a327e10\n  },\n\n  { key = 0x1aab1a249cb5fa91816e56da1177c891230b2b0d58e91602\n  , ciphertext = 0xfd6cd698388a46f696da48543a327e10\n  , plaintext = 0xbaa9b8a3f9ffa86241bb5abe04b7eea5\n  },\n\n  { key = 0xdd881f3432073d253bc7ee79e88860f362b071b35c5ef8a7\n  , ciphertext = 0xbaa9b8a3f9ffa86241bb5abe04b7eea5\n  , plaintext = 0x19ad5a0619f1b5eed38fb5fbbbbe1247\n  },\n\n  { key = 0xd4088261dda8dfc1226ab47ff179d51db13fc448e7e0eae0\n  , ciphertext = 0x19ad5a0619f1b5eed38fb5fbbbbe1247\n  , plaintext = 0x832e01274c6a59b148dc6de3e6ccc037\n  },\n\n  { key = 0x0ff97f22bdef4005a144b558bd138cacf9e3a9ab012c2ad7\n  , ciphertext = 0x832e01274c6a59b148dc6de3e6ccc037\n  , plaintext = 0x9853ba4a0880449a6344fd0dabfc9e74\n  },\n\n  { key = 0xa2f2351138f53ed639170f12b593c8369aa754a6aad0b4a3\n  , ciphertext = 0x9853ba4a0880449a6344fd0dabfc9e74\n  , plaintext = 0x89ebc090e07d36670f48a32074c9ca18\n  },\n\n  { key = 0xb7c564161c5e5061b0fccf8255eefe5195eff786de197ebb\n  , ciphertext = 0x89ebc090e07d36670f48a32074c9ca18\n  , plaintext = 0x5695154c14aeb5d09a516ca802d7fb21\n  },\n\n  { key = 0x95aa68a5ba0d346be669dace41404b810fbe9b2edcce859a\n  , ciphertext = 0x5695154c14aeb5d09a516ca802d7fb21\n  , plaintext = 0xf49c9100c165c22f16661c23bf46520e\n  },\n\n  { key = 0x028f06458b3a50ce12f54bce802589ae19d8870d6388d794\n  , ciphertext = 0xf49c9100c165c22f16661c23bf46520e\n  , plaintext = 0x1aec4f3ade3b41dd3d5448dc7e577e67\n  },\n\n  { key = 0xe0b75db3cfb1e3f6081904f45e1ec873248ccfd11ddfa9f3\n  , ciphertext = 0x1aec4f3ade3b41dd3d5448dc7e577e67\n  , plaintext = 0x5c75fbcaa893326641aa343f40f6ee31\n  },\n\n  { key = 0xe51161c0ee3bf4fe546cff3ef68dfa156526fbee5d2947c2\n  , ciphertext = 0x5c75fbcaa893326641aa343f40f6ee31\n  , plaintext = 0xa2c953d404212d5da4e98f31d8cc0a5b\n  },\n\n  { key = 0x1f13dd6e77477337f6a5aceaf2acd748c1cf74df85e54d99\n  , ciphertext = 0xa2c953d404212d5da4e98f31d8cc0a5b\n  , plaintext = 0x17ea5bd0c139ce391240ff701085b060\n  },\n\n  { key = 0x547e1d3ba5988327e14ff73a33951971d38f8baf9560fdf9\n  , ciphertext = 0x17ea5bd0c139ce391240ff701085b060\n  , plaintext = 0x98d87acaeb843ccf7b6e92a1889ff129\n  },\n\n  { key = 0xd140d82958fb4d8979978df0d81125bea8e1190e1dff0cd0\n  , ciphertext = 0x98d87acaeb843ccf7b6e92a1889ff129\n  , plaintext = 0x0c2132942034442ea6eb14d23ccdf868\n  },\n\n  { key = 0xf311ab46bba28f9a75b6bf64f82561900e0a0ddc2132f4b8\n  , ciphertext = 0x0c2132942034442ea6eb14d23ccdf868\n  , plaintext = 0x91341b217d521168251ad3778171e5ba\n  },\n\n  { key = 0x0abea37884946aa1e482a445857770f82b10deaba0431102\n  , ciphertext = 0x91341b217d521168251ad3778171e5ba\n  , plaintext = 0xb63ef1b79507a62eba3dafcec54a6328\n  }]\n\n\nproperty aes256_MCT_vectors_encrypt_correct =\n  aes256_MCT_encrypt_test_vectors ==\n  mct_ecb_encrypt_256\n    0xf9e8389f5b80712e3886cc1fa2d28a3b8c9cd88a2d4a54c6aa86ce0fef944be0\n    0xb379777f9050e2a818f2940cbbd9aba4\n\n\nproperty aes256_MCT_vectors_decrypt_correct =\n  aes256_MCT_decrypt_test_vectors ==\n  mct_ecb_decrypt_256\n    0x2b09ba39b834062b9e93f48373b8dd018dedf1e5ba1b8af831ebbacbc92a2643\n    0x89649bd0115f30bd878567610223a59d\n\n\naes256_MCT_encrypt_test_vectors : [100](AESTestVector 256)\naes256_MCT_encrypt_test_vectors =\n \/\/ Vectors from ECBMCT256.rsp\n [{ key = 0xf9e8389f5b80712e3886cc1fa2d28a3b8c9cd88a2d4a54c6aa86ce0fef944be0\n  , plaintext = 0xb379777f9050e2a818f2940cbbd9aba4\n  , ciphertext = 0x6893ebaf0a1fccc704326529fdfb60db\n  },\n\n  { key = 0xdb9ea5a2284fa17fb63e13bf891c8e42e40f332527559801aeb4ab26126f2b3b\n  , plaintext = 0x6893ebaf0a1fccc704326529fdfb60db\n  , ciphertext = 0xf3c78a5e85e5439bf26d5818718157d6\n  },\n\n  { key = 0x7099ed88e82744228a5303ae2ef6c0d017c8b97ba2b0db9a5cd9f33e63ee7ced\n  , plaintext = 0xf3c78a5e85e5439bf26d5818718157d6\n  , ciphertext = 0x2326b958b00b3050697eedb08cc20504\n  },\n\n  { key = 0x5e9e65ea96e78dd4fb78ea1184f6ebde34ee002312bbebca35a71e8eef2c79e9\n  , plaintext = 0x2326b958b00b3050697eedb08cc20504\n  , ciphertext = 0xec4332d5e3cebd3e0f5fc51452f4560d\n  },\n\n  { key = 0x33acf1cafc822646dc869e905bd26f9ad8ad32f6f17556f43af8db9abdd82fe4\n  , plaintext = 0xec4332d5e3cebd3e0f5fc51452f4560d\n  , ciphertext = 0x5da58b5ef2076340d555f861c3449a77\n  },\n\n  { key = 0xeb0ae85c1b44d5db4729d268f49be2a08508b9a8037235b4efad23fb7e9cb593\n  , plaintext = 0x5da58b5ef2076340d555f861c3449a77\n  , ciphertext = 0x307d50c18a0b6a08402ff131d72cb7ec\n  },\n\n  { key = 0xfac93b561a9b6a0e809d71ecdb980afab575e96989795fbcaf82d2caa9b0027f\n  , plaintext = 0x307d50c18a0b6a08402ff131d72cb7ec\n  , ciphertext = 0x92c34165a2963e77e05e2d6fc2d931d5\n  },\n\n  { key = 0xa0559e41d58af36174a67246df87541b27b6a80c2bef61cb4fdcffa56b6933aa\n  , plaintext = 0x92c34165a2963e77e05e2d6fc2d931d5\n  , ciphertext = 0xcb33d519a1fdb1d5fbb185c47870c1ed\n  },\n\n  { key = 0xe48824d6c2251d3a27f38fb543c31fc1ec857d158a12d01eb46d7a611319f247\n  , plaintext = 0xcb33d519a1fdb1d5fbb185c47870c1ed\n  , ciphertext = 0x78fb452f384c8f870e572890588f3728\n  },\n\n  { key = 0x7a33440ad7c69d583355c745e5c88c47947e383ab25e5f99ba3a52f14b96c56f\n  , plaintext = 0x78fb452f384c8f870e572890588f3728\n  , ciphertext = 0x12375e02a8bbc84b00feaab54a66db43\n  },\n\n  { key = 0x0e6877c7fdc234efb9afcd96b4ebdb83864966381ae597d2bac4f84401f01e2c\n  , plaintext = 0x12375e02a8bbc84b00feaab54a66db43\n  , ciphertext = 0xeab1606610b55c857f2b4bf1cf3feba0\n  },\n\n  { key = 0xec91d3550c79ab4914a26987725ab1396cf8065e0a50cb57c5efb3b5cecff58c\n  , plaintext = 0xeab1606610b55c857f2b4bf1cf3feba0\n  , ciphertext = 0x6c73381147de97961cc26ad26602a45a\n  },\n\n  { key = 0x83caed5a49579b3a55a71e5ece5966e5008b3e4f4d8e5cc1d92dd967a8cd51d6\n  , plaintext = 0x6c73381147de97961cc26ad26602a45a\n  , ciphertext = 0xe76c08fd29bf015352003c636fee5ff9\n  },\n\n  { key = 0x91b9b50908968361dcd8f4ba236fa199e7e736b264315d928b2de504c7230e2f\n  , plaintext = 0xe76c08fd29bf015352003c636fee5ff9\n  , ciphertext = 0x6f26b8191a2b059dcdeb3dbabc437c29\n  },\n\n  { key = 0x94fc46213c870f7965b88773afe93b1388c18eab7e1a580f46c6d8be7b607206\n  , plaintext = 0x6f26b8191a2b059dcdeb3dbabc437c29\n  , ciphertext = 0xe91e2fcef14dd4251caec97c45223fef\n  },\n\n  { key = 0xb0deff009aff61f65763b0b9fdd39a9061dfa1658f578c2a5a6811c23e424de9\n  , plaintext = 0xe91e2fcef14dd4251caec97c45223fef\n  , ciphertext = 0x98fb2122912360f07916e4802c0ea1e5\n  },\n\n  { key = 0x968f3c88d27f1be8decb00c4d464d369f92480471e74ecda237ef542124cec0c\n  , plaintext = 0x98fb2122912360f07916e4802c0ea1e5\n  , ciphertext = 0xb4a15c59976b39da50da8ed393f27a62\n  },\n\n  { key = 0x35fe06a60309581565a97232140668464d85dc1e891fd50073a47b9181be966e\n  , plaintext = 0xb4a15c59976b39da50da8ed393f27a62\n  , ciphertext = 0xd8b57d7a72ef92409c51d40bb8c4cbc5\n  },\n\n  { key = 0x4739043d7750bcf4a6f269a3d54083ca9530a164fbf04740eff5af9a397a5dab\n  , plaintext = 0xd8b57d7a72ef92409c51d40bb8c4cbc5\n  , ciphertext = 0x548cc893e80caf5a601c2381517f8c5b\n  },\n\n  { key = 0x4b065b5195f2ddf6f5d0aed72ff7a1e3c1bc69f713fce81a8fe98c1b6805d1f0\n  , plaintext = 0x548cc893e80caf5a601c2381517f8c5b\n  , ciphertext = 0x1c2238c560d678d40b48cc8034add0c4\n  },\n\n  { key = 0x1a949129e14c5963d997c86a6352ea53dd9e5132732a90ce84a1409b5ca80134\n  , plaintext = 0x1c2238c560d678d40b48cc8034add0c4\n  , ciphertext = 0x2771ff806e061df8ad4aa877717bf309\n  },\n\n  { key = 0x91cd3e48f4b42c432bed9848583e6dc7faefaeb21d2c8d3629ebe8ec2dd3f23d\n  , plaintext = 0x2771ff806e061df8ad4aa877717bf309\n  , ciphertext = 0x065593fa1fcdb481bb27f334505543f5\n  },\n\n  { key = 0x42d6f7b585a0a0d356c59be3d07d4d41fcba3d4802e139b792cc1bd87d86b1c8\n  , plaintext = 0x065593fa1fcdb481bb27f334505543f5\n  , ciphertext = 0xd3f309c0039b15d14eb8b739a94b94fa\n  },\n\n  { key = 0x72900f0ecbf90fa058805deb430815072f493488017a2c66dc74ace1d4cd2532\n  , plaintext = 0xd3f309c0039b15d14eb8b739a94b94fa\n  , ciphertext = 0x4e441a3fb277d6fbe0ed7c6e080d9a9f\n  },\n\n  { key = 0x12ef8789b91a8e35fd0ac79457a906f0610d2eb7b30dfa9d3c99d08fdcc0bfad\n  , plaintext = 0x4e441a3fb277d6fbe0ed7c6e080d9a9f\n  , ciphertext = 0xcb9241bc964cbc9823531f68e3a03b7c\n  },\n\n  { key = 0x2cbe5980ad54c5dbf2ee3db1e9875733aa9f6f0b254146051fcacfe73f6084d1\n  , plaintext = 0xcb9241bc964cbc9823531f68e3a03b7c\n  , ciphertext = 0x70b17c3e869aca6076617a2cf75e9f4a\n  },\n\n  { key = 0xdc4da3812736a2a603bcc6390763c5c5da2e1335a3db8c6569abb5cbc83e1b9b\n  , plaintext = 0x70b17c3e869aca6076617a2cf75e9f4a\n  , ciphertext = 0xf4b8a6ed6d6d72aff59484314f210bb9\n  },\n\n  { key = 0x2e4e21a6eb77bb39a1cb5cd20cc5fd3b2e96b5d8ceb6feca9c3f31fa871f1022\n  , plaintext = 0xf4b8a6ed6d6d72aff59484314f210bb9\n  , ciphertext = 0xf56a4597beaeafc0c14ee73988bcbee8\n  },\n\n  { key = 0x54d5c037e61fd09e5cf57fd34c5e0192dbfcf04f7018510a5d71d6c30fa3aeca\n  , plaintext = 0xf56a4597beaeafc0c14ee73988bcbee8\n  , ciphertext = 0x04333079d5352236e1c79213f3f38dbe\n  },\n\n  { key = 0x3a5da203e03fa399caeb1fac63679b56dfcfc036a52d733cbcb644d0fc502374\n  , plaintext = 0x04333079d5352236e1c79213f3f38dbe\n  , ciphertext = 0x22c97ecdf4af830f94b11951f41e4d29\n  },\n\n  { key = 0x5c84147d6ab2051b56b0993a7cbfa306fd06befb5182f03328075d81084e6e5d\n  , plaintext = 0x22c97ecdf4af830f94b11951f41e4d29\n  , ciphertext = 0xdef46a3b39c8048431d2491d97daa6ea\n  },\n\n  { key = 0x7af77aa155a33f658283ebc3e9eb708923f2d4c0684af4b719d5149c9f94c8b7\n  , plaintext = 0xdef46a3b39c8048431d2491d97daa6ea\n  , ciphertext = 0x4c6367ad8a2190366c3d730fe5eeb6ee\n  },\n\n  { key = 0xedabba9dc9d87357bb91da6931c743e16f91b36de26b648175e867937a7a7e59\n  , plaintext = 0x4c6367ad8a2190366c3d730fe5eeb6ee\n  , ciphertext = 0x90bd09b4eb0f7d8397c0026cefea8fb3\n  },\n\n  { key = 0xab7ef1b4a1e43771de88e158ad26a419ff2cbad909641902e22865ff9590f1ea\n  , plaintext = 0x90bd09b4eb0f7d8397c0026cefea8fb3\n  , ciphertext = 0x25aefcfa6ec98fae81b93afad7761711\n  },\n\n  { key = 0x6b0145c6cbeaae320be86c2909c8d643da82462367ad96ac63915f0542e6e6fb\n  , plaintext = 0x25aefcfa6ec98fae81b93afad7761711\n  , ciphertext = 0x607b26f4eb3585e3e886e75c0f3a01cf\n  },\n\n  { key = 0xb46d28c20a614b6d986e92795258631cbaf960d78c98134f8b17b8594ddce734\n  , plaintext = 0x607b26f4eb3585e3e886e75c0f3a01cf\n  , ciphertext = 0xfe35fe16a3290042c28c021ee9ede73f\n  },\n\n  { key = 0x93c5c8403410764717e547e3d07b0ec344cc9ec12fb1130d499bba47a431000b\n  , plaintext = 0xfe35fe16a3290042c28c021ee9ede73f\n  , ciphertext = 0x0141871c357a00ad37ae65597830cac8\n  },\n\n  { key = 0xcf85ea60e0c94e611fedba48e19e9693458d19dd1acb13a07e35df1edc01cac3\n  , plaintext = 0x0141871c357a00ad37ae65597830cac8\n  , ciphertext = 0xdf8bc7782ae10eb2c1bdfdc8887e4907\n  },\n\n  { key = 0xd40735932ea269aeb51fa3caf0c176d89a06dea5302a1d12bf8822d6547f83c4\n  , plaintext = 0xdf8bc7782ae10eb2c1bdfdc8887e4907\n  , ciphertext = 0x1ac65c65b6cd8ab751f1d908ebd962ab\n  },\n\n  { key = 0x9a7120341819fe54fc8a750d17ecf20f80c082c086e797a5ee79fbdebfa6e16f\n  , plaintext = 0x1ac65c65b6cd8ab751f1d908ebd962ab\n  , ciphertext = 0x9f10b53fb6adf7189e277d04e351aa9d\n  },\n\n  { key = 0x8c19642c172cdb804059f751b3f25cff1fd037ff304a60bd705e86da5cf74bf2\n  , plaintext = 0x9f10b53fb6adf7189e277d04e351aa9d\n  , ciphertext = 0xc94ecc943ddc8d1eeafadd173cf73fdc\n  },\n\n  { key = 0xe1cc9575e51d6a8240e6f3cd8958e1a6d69efb6b0d96eda39aa45bcd6000742e\n  , plaintext = 0xc94ecc943ddc8d1eeafadd173cf73fdc\n  , ciphertext = 0x5dd513d74b72f9d46b06b4b96a94c3bd\n  },\n\n  { key = 0xce41ff2d70b2169fad6a5f9ead4471e88b4be8bc46e41477f1a2ef740a94b793\n  , plaintext = 0x5dd513d74b72f9d46b06b4b96a94c3bd\n  , ciphertext = 0x1594a31cc22cdbaf2011a9a317538608\n  },\n\n  { key = 0x7b467b87180772677903a043bc63c3ef9edf4ba084c8cfd8d1b346d71dc7319b\n  , plaintext = 0x1594a31cc22cdbaf2011a9a317538608\n  , ciphertext = 0x4d5e8d6fa3e2ea343b5afb77124529aa\n  },\n\n  { key = 0xca068b3afc717d1f6e8dc7e4eca0f56fd381c6cf272a25eceae9bda00f821831\n  , plaintext = 0x4d5e8d6fa3e2ea343b5afb77124529aa\n  , ciphertext = 0x1bbf651cf61c295c96e73a210483d7a1\n  },\n\n  { key = 0xd04d80998a971ec52d5390fa7eaf78eac83ea3d3d1360cb07c0e87810b01cf90\n  , plaintext = 0x1bbf651cf61c295c96e73a210483d7a1\n  , ciphertext = 0x84b42f75c3b62bbf21707ba66cca399f\n  },\n\n  { key = 0x2cfb1c71e8cac872e6a6dc90b0195acf4c8a8ca61280270f5d7efc2767cbf60f\n  , plaintext = 0x84b42f75c3b62bbf21707ba66cca399f\n  , ciphertext = 0xa0c514e1e6a9c659f605eff4cf4951a0\n  },\n\n  { key = 0x405bc450a19e6dae76847b8eac858c8bec4f9847f429e156ab7b13d3a882a7af\n  , plaintext = 0xa0c514e1e6a9c659f605eff4cf4951a0\n  , ciphertext = 0x1dcc38307c6b3c31e25f868b279b3711\n  },\n\n  { key = 0x35755fe97d9aeb1e67c1f4ca5a40ce1ff183a0778842dd67492495588f1990be\n  , plaintext = 0x1dcc38307c6b3c31e25f868b279b3711\n  , ciphertext = 0xcdd744574664be7b221d7a2921b4f0b2\n  },\n\n  { key = 0x7e9d8b4bbd2aad70d229247d5880a0cb3c54e420ce26631c6b39ef71aead600c\n  , plaintext = 0xcdd744574664be7b221d7a2921b4f0b2\n  , ciphertext = 0xe602ef85184ad4a86ed339e9403f541c\n  },\n\n  { key = 0x73be0bb5b74a8f6324f8a5f0acbf5faada560ba5d66cb7b405ead698ee923410\n  , plaintext = 0xe602ef85184ad4a86ed339e9403f541c\n  , ciphertext = 0x7c227f03e605ff14c42fb9f8e8786e84\n  },\n\n  { key = 0xc82e22faeca51a38045f2a3a04a0e6e2a67474a6306948a0c1c56f6006ea5a94\n  , plaintext = 0x7c227f03e605ff14c42fb9f8e8786e84\n  , ciphertext = 0x94c0466b27aa4d361b19c250329c14a0\n  },\n\n  { key = 0x7c1dd42bdff414e3733b846cbb00c43432b432cd17c30596dadcad3034764e34\n  , plaintext = 0x94c0466b27aa4d361b19c250329c14a0\n  , ciphertext = 0xfd6b281c93c1fd8e9b83b69ecf722f3b\n  },\n\n  { key = 0xaa7ec003efbca86fe5ad028d0571cf3acfdf1ad18402f818415f1baefb04610f\n  , plaintext = 0xfd6b281c93c1fd8e9b83b69ecf722f3b\n  , ciphertext = 0xa75b28be92dc53de9d44714918e3c541\n  },\n\n  { key = 0x14ba26bafb6c8410104d70ec23876db56884326f16deabc6dc1b6ae7e3e7a44e\n  , plaintext = 0xa75b28be92dc53de9d44714918e3c541\n  , ciphertext = 0x48693025ba68f3fa3515e7112b6e32aa\n  },\n\n  { key = 0x33b40738b39ebe39118938c6461ebd7820ed024aacb6583ce90e8df6c88996e4\n  , plaintext = 0x48693025ba68f3fa3515e7112b6e32aa\n  , ciphertext = 0x6bfa37cc5ed6e5d4ddf40b1301957f73\n  },\n\n  { key = 0x0d16eab1b56e2a468bf1ba1035129d574b173586f260bde834fa86e5c91ce997\n  , plaintext = 0x6bfa37cc5ed6e5d4ddf40b1301957f73\n  , ciphertext = 0xca18b89c3225877e02e21042af9836a8\n  },\n\n  { key = 0x44b55514a5b4a5a4294f3cf8e75ff73c810f8d1ac0453a96361896a76684df3f\n  , plaintext = 0xca18b89c3225877e02e21042af9836a8\n  , ciphertext = 0xc3ebc08368be58f8f514cfbd5f98ed52\n  },\n\n  { key = 0x265f1a7a53151bc51526fe476e8c63ad42e44d99a8fb626ec30c591a391c326d\n  , plaintext = 0xc3ebc08368be58f8f514cfbd5f98ed52\n  , ciphertext = 0x788552397ddf2d5841dbc0e73dd11150\n  },\n\n  { key = 0x23fa4630937015585ac065e6a7bd93023a611fa0d5244f3682d799fd04cd233d\n  , plaintext = 0x788552397ddf2d5841dbc0e73dd11150\n  , ciphertext = 0xe9d728bc19b50809bc1245552091d0b2\n  },\n\n  { key = 0x9dd3a2408e5694fced28964c7f442e6ed3b6371ccc91473f3ec5dca8245cf38f\n  , plaintext = 0xe9d728bc19b50809bc1245552091d0b2\n  , ciphertext = 0xce08d78b58179b7957eeab6f74ddb10f\n  },\n\n  { key = 0x055d53ef574a63f77c0b3a88e7e7cdb01dbee0979486dc46692b77c750814280\n  , plaintext = 0xce08d78b58179b7957eeab6f74ddb10f\n  , ciphertext = 0x33ce33e80fcc262e9e862f5ac50c14df\n  },\n\n  { key = 0xc1a90cdef5d5daaf7b182d6b409940e62e70d37f9b4afa68f7ad589d958d565f\n  , plaintext = 0x33ce33e80fcc262e9e862f5ac50c14df\n  , ciphertext = 0x5c4d21e6045f11f9f91a8cef130304e0\n  },\n\n  { key = 0x6a257a4f65bdd7d882ff45ffbb9541e5723df2999f15eb910eb7d472868e52bf\n  , plaintext = 0x5c4d21e6045f11f9f91a8cef130304e0\n  , ciphertext = 0x4f50679c2dbfa63b5e55d031afacd44b\n  },\n\n  { key = 0x5843bf4d6afc64273d328e1baf7821b03d6d9505b2aa4daa50e20443292286f4\n  , plaintext = 0x4f50679c2dbfa63b5e55d031afacd44b\n  , ciphertext = 0x29f64e79de48f3d3d5dff92aa0b1783b\n  },\n\n  { key = 0x8915060a33758a300c053d365c304d4e149bdb7c6ce2be79853dfd698993fecf\n  , plaintext = 0x29f64e79de48f3d3d5dff92aa0b1783b\n  , ciphertext = 0x8c5bf92515a92449846593a3bdbe521b\n  },\n\n  { key = 0xbe2b2a41b3491511c181508b66ec96f798c02259794b9a3001586eca342dacd4\n  , plaintext = 0x8c5bf92515a92449846593a3bdbe521b\n  , ciphertext = 0x5511fef7a2238277aaa9e25f1d097c19\n  },\n\n  { key = 0x4d6f38935317ffa0cb29bdfa8a43cd19cdd1dcaedb681847abf18c952924d0cd\n  , plaintext = 0x5511fef7a2238277aaa9e25f1d097c19\n  , ciphertext = 0x2ecd75c6a5eace1c541e12db150a2143\n  },\n\n  { key = 0x1549ea3d167152c85223b0a603d1fa61e31ca9687e82d65bffef9e4e3c2ef18e\n  , plaintext = 0x2ecd75c6a5eace1c541e12db150a2143\n  , ciphertext = 0x6a4cfcb9e8dae9610df99509daac7be0\n  },\n\n  { key = 0xba593f6731f70edab83f5cdf02527436895055d196583f3af2160b47e6828a6e\n  , plaintext = 0x6a4cfcb9e8dae9610df99509daac7be0\n  , ciphertext = 0x185772deff51807147ac5350249b3e1a\n  },\n\n  { key = 0x7126a05712f987f1c9249bf9a7c17b4f9107270f6909bf4bb5ba5817c219b474\n  , plaintext = 0x185772deff51807147ac5350249b3e1a\n  , ciphertext = 0xbfb1ce7df706bc972e1b8306d44aa135\n  },\n\n  { key = 0x3d0fa3983ebc8a3f64c4135d7cd3195e2eb6e9729e0f03dc9ba1db1116531541\n  , plaintext = 0xbfb1ce7df706bc972e1b8306d44aa135\n  , ciphertext = 0xf21df1e99a781dba4a68ff3491848f99\n  },\n\n  { key = 0x88c88ec4d63eb481cd8d6e8e8d2e2715dcab189b04771e66d1c9242587d79ad8\n  , plaintext = 0xf21df1e99a781dba4a68ff3491848f99\n  , ciphertext = 0xe4e8c9e4963a44f5cf27767e4e42fa61\n  },\n\n  { key = 0x989b9545625a4025f7725d63847213883843d17f924d5a931eee525bc99560b9\n  , plaintext = 0xe4e8c9e4963a44f5cf27767e4e42fa61\n  , ciphertext = 0x27475121d0e3367d0e0c2d9fb39cfe95\n  },\n\n  { key = 0xf49b61f190f982aa866d5c8f2e5749781f04805e42ae6cee10e27fc47a099e2c\n  , plaintext = 0x27475121d0e3367d0e0c2d9fb39cfe95\n  , ciphertext = 0xc2990626cb34c5d7fafe0430650ed907\n  },\n\n  { key = 0x101537d5f633ad8dc7e8cc058ce7fe20dd9d8678899aa939ea1c7bf41f07472b\n  , plaintext = 0xc2990626cb34c5d7fafe0430650ed907\n  , ciphertext = 0x1c5d0cca2845b66c371c1760f81e024a\n  },\n\n  { key = 0x1f6acaa66674733d28dfec92c43c7e76c1c08ab2a1df1f55dd006c94e7194561\n  , plaintext = 0x1c5d0cca2845b66c371c1760f81e024a\n  , ciphertext = 0x6f5a53addd93c9a136401a804a710419\n  },\n\n  { key = 0xb55bdefe370646699012062df748b6aaae9ad91f7c4cd6f4eb407614ad684178\n  , plaintext = 0x6f5a53addd93c9a136401a804a710419\n  , ciphertext = 0x8e0c070be7109ead0e8cc0aa0bf95e61\n  },\n\n  { key = 0xde09c34a85d56a2748559c309f04eb722096de149b5c4859e5ccb6bea6911f19\n  , plaintext = 0x8e0c070be7109ead0e8cc0aa0bf95e61\n  , ciphertext = 0xdb53b5306561db899a635a56c56e7239\n  },\n\n  { key = 0x2650ecd133a5df3825072a4df2d95d15fbc56b24fe3d93d07fafece863ff6d20\n  , plaintext = 0xdb53b5306561db899a635a56c56e7239\n  , ciphertext = 0x72e5ac05990d3f5508295f95f8973313\n  },\n\n  { key = 0xa8599f0edd6446b4bb9371e380bf33488920c7216730ac857786b37d9b685e33\n  , plaintext = 0x72e5ac05990d3f5508295f95f8973313\n  , ciphertext = 0x86a8332f16f997bc02af5271c64e7e0f\n  },\n\n  { key = 0x672e7b0d497458e260084662c566394e0f88f40e71c93b397529e10c5d26203c\n  , plaintext = 0x86a8332f16f997bc02af5271c64e7e0f\n  , ciphertext = 0x8e53858ce7ad0d25410f886eeeca1e0e\n  },\n\n  { key = 0x73ea41a50cdd5a98644e6f8d974af21381db71829664361c34266962b3ec3e32\n  , plaintext = 0x8e53858ce7ad0d25410f886eeeca1e0e\n  , ciphertext = 0xc6a1d493d607d2cef6aef29ee878c434\n  },\n\n  { key = 0x14969b3ff78ccdd66c53b8027a79563e477aa5114063e4d2c2889bfc5b94fa06\n  , plaintext = 0xc6a1d493d607d2cef6aef29ee878c434\n  , ciphertext = 0xa4973e0cfaf8d6ac6758615fc81e06df\n  },\n\n  { key = 0xd09e2741b9480c2166c9c1832654763de3ed9b1dba9b327ea5d0faa3938afcd9\n  , plaintext = 0xa4973e0cfaf8d6ac6758615fc81e06df\n  , ciphertext = 0x67e3243d8bc81887517708a29a5d9ae5\n  },\n\n  { key = 0x22c65ead303a0395cc9c065ada930ddd840ebf2031532af9f4a7f20109d7663c\n  , plaintext = 0x67e3243d8bc81887517708a29a5d9ae5\n  , ciphertext = 0xde2f35df51644cf5d79984be6c17c14c\n  },\n\n  { key = 0x8679ef0357516245ec489386419646bc5a218aff6037660c233e76bf65c0a770\n  , plaintext = 0xde2f35df51644cf5d79984be6c17c14c\n  , ciphertext = 0x9eaedabb3bd046ec27a2bdafabdbc861\n  },\n\n  { key = 0x6043902c115f107639e7c92ba4952301c48f50445be720e0049ccb10ce1b6f11\n  , plaintext = 0x9eaedabb3bd046ec27a2bdafabdbc861\n  , ciphertext = 0x0cde7e6c1aecbbe996865bf30b178de7\n  },\n\n  { key = 0xaca443a9e31033ea73b1eeda6e7d6ca1c8512e28410b9b09921a90e3c50ce2f6\n  , plaintext = 0x0cde7e6c1aecbbe996865bf30b178de7\n  , ciphertext = 0xba25bf5be1e4c099b9e45eedd7369cb5\n  },\n\n  { key = 0x60362e2b0bf998c875c087c370c4ca4772749173a0ef5b902bfece0e123a7e43\n  , plaintext = 0xba25bf5be1e4c099b9e45eedd7369cb5\n  , ciphertext = 0x805be62789549ce6af74966467f41135\n  },\n\n  { key = 0x6d7f0f7584162a1fa4dd6764548f355af22f775429bbc776848a586a75ce6f76\n  , plaintext = 0x805be62789549ce6af74966467f41135\n  , ciphertext = 0xab6001c6c4c56e8ca393c5fd173505ba\n  },\n\n  { key = 0xd8ecc39ac1d00c53216f6e64e826a7a9594f7692ed7ea9fa27199d9762fb6acc\n  , plaintext = 0xab6001c6c4c56e8ca393c5fd173505ba\n  , ciphertext = 0x3ba3673f4f495dd1541d47c22b7921c5\n  },\n\n  { key = 0x493108f91caedf714652149a2b2030fe62ec11ada237f42b7304da5549824b09\n  , plaintext = 0x3ba3673f4f495dd1541d47c22b7921c5\n  , ciphertext = 0xb24fe17cdc5c8cfa4260c38691b57bfa\n  },\n\n  { key = 0x446af6dd5f58755aeaa0a1226d8c584fd0a3f0d17e6b78d1316419d3d83730f3\n  , plaintext = 0xb24fe17cdc5c8cfa4260c38691b57bfa\n  , ciphertext = 0x86d999a63b96f6c9d9aaf3be6202977b\n  },\n\n  { key = 0x65f92d4e1723d5e58aeb350c79df28de567a697745fd8e18e8ceea6dba35a788\n  , plaintext = 0x86d999a63b96f6c9d9aaf3be6202977b\n  , ciphertext = 0xc4712aa733f9737f91e4ed61609e02f1\n  },\n\n  { key = 0x915cee6af4ea95623f7122acda5e9040920b43d07604fd67792a070cdaaba579\n  , plaintext = 0xc4712aa733f9737f91e4ed61609e02f1\n  , ciphertext = 0x0e8c1a77b280f4c753682768fd6f3b23\n  },\n\n  { key = 0x8e9bb2887fe60d42db4d827f00ba68ff9c8759a7c48409a02a42206427c49e5a\n  , plaintext = 0x0e8c1a77b280f4c753682768fd6f3b23\n  , ciphertext = 0xdccb684d47c480cc1317dcaa451234c0\n  },\n\n  { key = 0xcbf85a6645469e5df882fe840776b6aa404c31ea8340896c3955fcce62d6aa9a\n  , plaintext = 0xdccb684d47c480cc1317dcaa451234c0\n  , ciphertext = 0x9a2c4f07489c14265e33ac031d02b3d8\n  },\n\n  { key = 0x3ea3c33d7439ab3c478c01907f13cda7da607eedcbdc9d4a676650cd7fd41942\n  , plaintext = 0x9a2c4f07489c14265e33ac031d02b3d8\n  , ciphertext = 0x5c8e622ddbd32ee79c17572e8b3ee61c\n  },\n\n  { key = 0x312c5b43263c1af8d1e35c0f24d1004386ee1cc0100fb3adfb7107e3f4eaff5e\n  , plaintext = 0x5c8e622ddbd32ee79c17572e8b3ee61c\n  , ciphertext = 0xc5d2cb3d5b7ff0e23e308967ee074825\n  }]\n\n\naes256_MCT_decrypt_test_vectors : [100](AESTestVector 256)\naes256_MCT_decrypt_test_vectors =\n \/\/ Vectors from ECBMCT256.rsp\n [{ key = 0x2b09ba39b834062b9e93f48373b8dd018dedf1e5ba1b8af831ebbacbc92a2643\n  , ciphertext = 0x89649bd0115f30bd878567610223a59d\n  , plaintext = 0x1f9b9b213f1884fa98b62dd6639fd33b\n  },\n\n  { key = 0x58ac71619fdc3ac73a17f285319e1cd492766ac485030e02a95d971daab5f578\n  , ciphertext = 0x1f9b9b213f1884fa98b62dd6639fd33b\n  , plaintext = 0xaecd334ef8fb0c51b6896ae065d8be28\n  },\n\n  { key = 0xf6e3cca2cd628c10625c62cf08b385743cbb598a7df802531fd4fdfdcf6d4b50\n  , ciphertext = 0xaecd334ef8fb0c51b6896ae065d8be28\n  , plaintext = 0xf1938dd245c055e9c380336ff8450d9d\n  },\n\n  { key = 0xa9ae3bd7d454f19d69289875ff009d16cd28d458383857badc54ce92372846cd\n  , ciphertext = 0xf1938dd245c055e9c380336ff8450d9d\n  , plaintext = 0x42d5c4a13b748800ebfe0f67781dcff1\n  },\n\n  { key = 0xe3bc6232865f0476149be7162ef8fc4b8ffd10f9034cdfba37aac1f54f35893c\n  , ciphertext = 0x42d5c4a13b748800ebfe0f67781dcff1\n  , plaintext = 0x469968a00226f0aae7acfda02b2ce0ae\n  },\n\n  { key = 0x451fbfba7f09b625540822fac8c8e30bc9647859016a2f10d0063c5564196992\n  , ciphertext = 0x469968a00226f0aae7acfda02b2ce0ae\n  , plaintext = 0xeab144d6f80ccfd2fae95d16784718ac\n  },\n\n  { key = 0xf53e21e46a0ec97c980d49d6f4b81ec423d53c8ff966e0c22aef61431c5e713e\n  , ciphertext = 0xeab144d6f80ccfd2fae95d16784718ac\n  , plaintext = 0xe04b91c3f084d733d3d0c1c7c152695a\n  },\n\n  { key = 0x5fb3a2cbdbe6971fcd345961bdcba5f6c39ead4c09e237f1f93fa084dd0c1864\n  , ciphertext = 0xe04b91c3f084d733d3d0c1c7c152695a\n  , plaintext = 0xe47db9b8c7fcc9459fa0a7fc84047b5b\n  },\n\n  { key = 0x6b145436c5ae0dcb2477f94f5bdb037927e314f4ce1efeb4669f07785908633f\n  , ciphertext = 0xe47db9b8c7fcc9459fa0a7fc84047b5b\n  , plaintext = 0xf617d26b55da999d65b2d236358b2e60\n  },\n\n  { key = 0x126752da3d7f9a0ffc1a46ccaa8a3925d1f4c69f9bc46729032dd54e6c834d5f\n  , ciphertext = 0xf617d26b55da999d65b2d236358b2e60\n  , plaintext = 0x066ffea799ad5f09d03cb868deb1591e\n  },\n\n  { key = 0xaa3daafbcd647f0a9eaa027146ab7aded79b383802693820d3116d26b2321441\n  , ciphertext = 0x066ffea799ad5f09d03cb868deb1591e\n  , plaintext = 0x6d28dbb55fb10c1c3226609997a4fb38\n  },\n\n  { key = 0xfed7b5c1f84d3dc185222da3fffac7a1bab3e38d5dd8343ce1370dbf2596ef79\n  , ciphertext = 0x6d28dbb55fb10c1c3226609997a4fb38\n  , plaintext = 0x9dd78987562c9c099d67ccc927fcec13\n  },\n\n  { key = 0xc36db4af0bee11dad6ea59679cfb988c27646a0a0bf4a8357c50c176026a036a\n  , ciphertext = 0x9dd78987562c9c099d67ccc927fcec13\n  , plaintext = 0xb5cc780ec75b8d8c5128c4d26fa520ea\n  },\n\n  { key = 0x7b5aebe66f96867504ee9efd2bd56bda92a81204ccaf25b92d7805a46dcf2380\n  , ciphertext = 0xb5cc780ec75b8d8c5128c4d26fa520ea\n  , plaintext = 0xc715bd2f23b98c66bf56e5680c6037f7\n  },\n\n  { key = 0x81a73bfcacc994f47aeec0d655e0485055bdaf2bef16a9df922ee0cc61af1477\n  , ciphertext = 0xc715bd2f23b98c66bf56e5680c6037f7\n  , plaintext = 0xe00984f9d93551e95ae85cfe4a829b82\n  },\n\n  { key = 0x2678e4ccda2eb6ad7f0e2843020da2d8b5b42bd23623f836c8c6bc322b2d8ff5\n  , ciphertext = 0xe00984f9d93551e95ae85cfe4a829b82\n  , plaintext = 0xbfa487fcb2331afe3ad82e59064b4aae\n  },\n\n  { key = 0x03565af5c267a62e0d2500ead06bc7d90a10ac2e8410e2c8f21e926b2d66c55b\n  , ciphertext = 0xbfa487fcb2331afe3ad82e59064b4aae\n  , plaintext = 0x4c278ca418fd1c5718883da0ba4a066f\n  },\n\n  { key = 0xec719a4ed851c36f806fbc78183026cc4637208a9cedfe9fea96afcb972cc334\n  , ciphertext = 0x4c278ca418fd1c5718883da0ba4a066f\n  , plaintext = 0xceed1c8b96d84951cadf809d3ea1b397\n  },\n\n  { key = 0xf138ad912201beecd15ebe2049f980e588da3c010a35b7ce20492f56a98d70a3\n  , ciphertext = 0xceed1c8b96d84951cadf809d3ea1b397\n  , plaintext = 0xf88aed84bca42a06647d6504a5c48379\n  },\n\n  { key = 0x8da22644e1267212742200dbf6b0ba947050d185b6919dc844344a520c49f3da\n  , ciphertext = 0xf88aed84bca42a06647d6504a5c48379\n  , plaintext = 0xc451b75375d0fec1cc1825eefbcc1372\n  },\n\n  { key = 0x5104213aabaccafe44129632f67cf2dab40166d6c3416309882c6fbcf785e0a8\n  , ciphertext = 0xc451b75375d0fec1cc1825eefbcc1372\n  , plaintext = 0x9a54dfd56bff41ea17bcf08d3761e95b\n  },\n\n  { key = 0x4c7c62be3f5a9d09934940284565e9c92e55b903a8be22e39f909f31c0e409f3\n  , ciphertext = 0x9a54dfd56bff41ea17bcf08d3761e95b\n  , plaintext = 0x76e074c587f112f3ffd17b390fa8cffc\n  },\n\n  { key = 0x9871765871b1dae363fca3961224414a58b5cdc62f4f30106041e408cf4cc60f\n  , ciphertext = 0x76e074c587f112f3ffd17b390fa8cffc\n  , plaintext = 0x5b14fd4c40a127733c20cd84648ec287\n  },\n\n  { key = 0x58e044758e5e4f300eb08f8b6ccd967203a1308a6fee17635c61298cabc20488\n  , ciphertext = 0x5b14fd4c40a127733c20cd84648ec287\n  , plaintext = 0x01c234e2392f42831b1172352f322286\n  },\n\n  { key = 0xffbb7104e110fdfe689f68ffa48b79590263046856c155e047705bb984f0260e\n  , ciphertext = 0x01c234e2392f42831b1172352f322286\n  , plaintext = 0xab142165cb093648938660fd800d8896\n  },\n\n  { key = 0x91aefec30a79b2524b19a611c0c4952da977250d9dc863a8d4f63b4404fdae98\n  , ciphertext = 0xab142165cb093648938660fd800d8896\n  , plaintext = 0x5c28ad9b5721edadc30e09b4541fd724\n  },\n\n  { key = 0x00d0f69c36671a9efeb7b8637e22af38f55f8896cae98e0517f832f050e279bc\n  , ciphertext = 0x5c28ad9b5721edadc30e09b4541fd724\n  , plaintext = 0x5a9ad24fe456f4f766e839a8101373c3\n  },\n\n  { key = 0xb22571c62ee4e0b4ebd7d776703c1345afc55ad92ebf7af271100b5840f10a7f\n  , ciphertext = 0x5a9ad24fe456f4f766e839a8101373c3\n  , plaintext = 0xa30e9a7730628b560c71967bdb35efce\n  },\n\n  { key = 0x1431d01006510179dd13e2a83e1b8b7b0ccbc0ae1eddf1a47d619d239bc4e5b1\n  , ciphertext = 0xa30e9a7730628b560c71967bdb35efce\n  , plaintext = 0x7118cc8a057df7ea9b7fb096decf05d9\n  },\n\n  { key = 0x06104531e2d000fff0cc8336b62e9bb87dd30c241ba0064ee61e2db5450be068\n  , ciphertext = 0x7118cc8a057df7ea9b7fb096decf05d9\n  , plaintext = 0xc550ff93a36fbb8e9a505682e07fb981\n  },\n\n  { key = 0x8e5ebd5c9bf858f3379bfb88c7c75319b883f3b7b8cfbdc07c4e7b37a57459e9\n  , ciphertext = 0xc550ff93a36fbb8e9a505682e07fb981\n  , plaintext = 0x1375e7b4164adc861bbb77c50aba445c\n  },\n\n  { key = 0xccc9445c3aab1c03ec8027593d370664abf61403ae85614667f50cf2afce1db5\n  , ciphertext = 0x1375e7b4164adc861bbb77c50aba445c\n  , plaintext = 0x5bc8b411c0fae92bad54b4e5c3a8826e\n  },\n\n  { key = 0xb804994228d618a9b7a3e0c3d8d2d373f03ea0126e7f886dcaa1b8176c669fdb\n  , ciphertext = 0x5bc8b411c0fae92bad54b4e5c3a8826e\n  , plaintext = 0x36c9de7c01298ff06c5e3ecf12507cd6\n  },\n\n  { key = 0x8a784f32cdd7e2ed19e85faf04de2015c6f77e6e6f56079da6ff86d87e36e30d\n  , ciphertext = 0x36c9de7c01298ff06c5e3ecf12507cd6\n  , plaintext = 0x35d814c0f6c07ae72bbe7cd1751d7527\n  },\n\n  { key = 0x71e3cc0f60a2eafd83c3a455eefc4c9cf32f6aae99967d7a8d41fa090b2b962a\n  , ciphertext = 0x35d814c0f6c07ae72bbe7cd1751d7527\n  , plaintext = 0x73c39ce5ea1b5eab18c9c15221e258d1\n  },\n\n  { key = 0x71bef3d2beffa17d37c6c3b28ef2928280ecf64b738d23d195883b5b2ac9cefb\n  , ciphertext = 0x73c39ce5ea1b5eab18c9c15221e258d1\n  , plaintext = 0xac67508a8bcab69f96ead29121718cd7\n  },\n\n  { key = 0x9aa1ffa9e175f03a6bcc71fc2aea3a522c8ba6c1f847954e0362e9ca0bb8422c\n  , ciphertext = 0xac67508a8bcab69f96ead29121718cd7\n  , plaintext = 0x49d2cac2ca39a3b66302e5f3650e71d7\n  },\n\n  { key = 0x4e480b73ab5c659538354b2474c9367b65596c03327e36f860600c396eb633fb\n  , ciphertext = 0x49d2cac2ca39a3b66302e5f3650e71d7\n  , plaintext = 0xe54638674ea0b3e837772a2866723753\n  },\n\n  { key = 0xaeecd55c38bef76367a21469d08721d2801f54647cde85105717261108c404a8\n  , ciphertext = 0xe54638674ea0b3e837772a2866723753\n  , plaintext = 0x074d933018e9e0558b416e39548994ff\n  },\n\n  { key = 0xe36c6a30f734a679ab7af2f9ff767cfe8752c75464376545dc5648285c4d9057\n  , ciphertext = 0x074d933018e9e0558b416e39548994ff\n  , plaintext = 0x04825a9ba20646acadb2cbdbd23530c0\n  },\n\n  { key = 0x124806708fc5fc73a1e50c61e5a76b8783d09dcfc63123e971e483f38e78a097\n  , ciphertext = 0x04825a9ba20646acadb2cbdbd23530c0\n  , plaintext = 0x25b98d2837580f9f3da8f2593f7b1d72\n  },\n\n  { key = 0x560afb5529a8b433738348a296408cada66910e7f1692c764c4c71aab103bde5\n  , ciphertext = 0x25b98d2837580f9f3da8f2593f7b1d72\n  , plaintext = 0x048b220c70d875cad6901e40f45c5b03\n  },\n\n  { key = 0x8b7c61dd007d9d0d1937cfc69b63c114a2e232eb81b159bc9adc6fea455fe6e6\n  , ciphertext = 0x048b220c70d875cad6901e40f45c5b03\n  , plaintext = 0x34e2a33412c0e682b29b26d5409d015f\n  },\n\n  { key = 0x30560ca0a31d8145228d34fbf8415683960091df9371bf3e2847493f05c2e7b9\n  , ciphertext = 0x34e2a33412c0e682b29b26d5409d015f\n  , plaintext = 0x942c057914f3b88fa0a40bb41d02b051\n  },\n\n  { key = 0x20c7e6e45c08ba0756c379b6cd4d6886022c94a6878207b188e3428b18c057e8\n  , ciphertext = 0x942c057914f3b88fa0a40bb41d02b051\n  , plaintext = 0x6f4e5c40e4135abfdf294b4d8c9304b3\n  },\n\n  { key = 0x2a6c928bf8c2b32ce82ed0be1bc954b96d62c8e663915d0e57ca09c69453535b\n  , ciphertext = 0x6f4e5c40e4135abfdf294b4d8c9304b3\n  , plaintext = 0xcac032ddc2b27443d70d0f2dfb1a1d87\n  },\n\n  { key = 0x74994d46526b2e9d5470a0a687f726f2a7a2fa3ba123294d80c706eb6f494edc\n  , ciphertext = 0xcac032ddc2b27443d70d0f2dfb1a1d87\n  , plaintext = 0x6aec33b2c1ae39237b13e86555722d1a\n  },\n\n  { key = 0x5aaec28d079eef5f1c42df377c7e80accd4ec989608d106efbd4ee8e3a3b63c6\n  , ciphertext = 0x6aec33b2c1ae39237b13e86555722d1a\n  , plaintext = 0x2df34173bbff331488b23687c755f617\n  },\n\n  { key = 0x9bfa3c08b8f8b8758f0a1f4b0ef86be4e0bd88fadb72237a7366d809fd6e95d1\n  , ciphertext = 0x2df34173bbff331488b23687c755f617\n  , plaintext = 0x07649dd5c1c7b38810cbecbad9c037ed\n  },\n\n  { key = 0x188e3a027b75fede978c76e70a853f95e7d9152f1ab590f263ad34b324aea23c\n  , ciphertext = 0x07649dd5c1c7b38810cbecbad9c037ed\n  , plaintext = 0xef3d9092321649d9bbb88f6448e3847b\n  },\n\n  { key = 0xaae2c6363be3dbb71c21f3a2d9f123f108e485bd28a3d92bd815bbd76c4d2647\n  , ciphertext = 0xef3d9092321649d9bbb88f6448e3847b\n  , plaintext = 0x1e5058b3e986d4aad80a11f909af1cca\n  },\n\n  { key = 0x85a51c6d62ba97564ac955a5409c362916b4dd0ec1250d81001faa2e65e23a8d\n  , ciphertext = 0x1e5058b3e986d4aad80a11f909af1cca\n  , plaintext = 0x9bf81052596b786b50b3f3506c009169\n  },\n\n  { key = 0x0d09600f108a86cfd58f3c211a40c38d8d4ccd5c984e75ea50ac597e09e2abe4\n  , ciphertext = 0x9bf81052596b786b50b3f3506c009169\n  , plaintext = 0x81bdaf86cf4255e5826294a51d2f9992\n  },\n\n  { key = 0x14ab478866e1d160311aa8820df354fb0cf162da570c200fd2cecddb14cd3276\n  , ciphertext = 0x81bdaf86cf4255e5826294a51d2f9992\n  , plaintext = 0x1fdc5fee9eb640ff547a98d9e1601b52\n  },\n\n  { key = 0x39f18405f0b1da647f99479e87d4d153132d3d34c9ba60f086b45502f5ad2924\n  , ciphertext = 0x1fdc5fee9eb640ff547a98d9e1601b52\n  , plaintext = 0x936609876cd6eebf31db5a6af7839844\n  },\n\n  { key = 0x85a900bc1563b16e01481e45d1125734804b34b3a56c8e4fb76f0f68022eb160\n  , ciphertext = 0x936609876cd6eebf31db5a6af7839844\n  , plaintext = 0x9ea8b6942287f470e9866a48f4dc661a\n  },\n\n  { key = 0xc43d677fc0a1becbb0214221b866f0be1ee3822787eb7a3f5ee96520f6f2d77a\n  , ciphertext = 0x9ea8b6942287f470e9866a48f4dc661a\n  , plaintext = 0x1dfc2cf82bfaa2732eb525916ef9ef13\n  },\n\n  { key = 0x584f10659c2d3c41f6a1926de4595eb2031faedfac11d84c705c40b1980b3869\n  , ciphertext = 0x1dfc2cf82bfaa2732eb525916ef9ef13\n  , plaintext = 0xa5d8d1d60281a152b9b76142e3e5a512\n  },\n\n  { key = 0x8eba336927e18b13eb3858a89709768ba6c77f09ae90791ec9eb21f37bee9d7b\n  , ciphertext = 0xa5d8d1d60281a152b9b76142e3e5a512\n  , plaintext = 0x8ac0278f2ab100a5964173d76934d732\n  },\n\n  { key = 0x13f1558dcae09062bfdccdd0037e5c432c075886842179bb5faa522412da4a49\n  , ciphertext = 0x8ac0278f2ab100a5964173d76934d732\n  , plaintext = 0x30233b70c4d6fd31b23cc77bc73559ea\n  },\n\n  { key = 0xd736669842aa88f43f1de421d38f391f1c2463f640f7848aed96955fd5ef13a3\n  , ciphertext = 0x30233b70c4d6fd31b23cc77bc73559ea\n  , plaintext = 0x766630dfd41e4146a827f55cba745b6a\n  },\n\n  { key = 0x0ca8353df90e73606588a11675bd37a76a42532994e9c5cc45b160036f9b48c9\n  , ciphertext = 0x766630dfd41e4146a827f55cba745b6a\n  , plaintext = 0x177f22d98f009c214a44b08cf40b790d\n  },\n\n  { key = 0x136ec3a1a65ee7bb0fd09af7364b66607d3d71f01be959ed0ff5d08f9b9031c4\n  , ciphertext = 0x177f22d98f009c214a44b08cf40b790d\n  , plaintext = 0xe9c916a21dec9662bdd91a0f865f8b47\n  },\n\n  { key = 0xba5c2bd413daca7866de11c11db2926694f467520605cf8fb22cca801dcfba83\n  , ciphertext = 0xe9c916a21dec9662bdd91a0f865f8b47\n  , plaintext = 0x92b3ab3e28f6c606508706e0c3d76d28\n  },\n\n  { key = 0x0fab4768fa7f104a3579f534508182920647cc6c2ef30989e2abcc60de18d7ab\n  , ciphertext = 0x92b3ab3e28f6c606508706e0c3d76d28\n  , plaintext = 0x3652053dcba591f101944fb1a5eb2b99\n  },\n\n  { key = 0xe766aa23c075deaa6fae68384f5b205e3015c951e5569878e33f83d17bf3fc32\n  , ciphertext = 0x3652053dcba591f101944fb1a5eb2b99\n  , plaintext = 0x242260d2387c6f1a415834b34e300a7e\n  },\n\n  { key = 0x9f1941442336bfffa1d6b27dce7845971437a983dd2af762a267b76235c3f64c\n  , ciphertext = 0x242260d2387c6f1a415834b34e300a7e\n  , plaintext = 0xa2a58ed050231b0d15f8cd99f5e171fb\n  },\n\n  { key = 0x429a3cdc98124fafe33156a66b4e8c2ab69227538d09ec6fb79f7afbc02287b7\n  , ciphertext = 0xa2a58ed050231b0d15f8cd99f5e171fb\n  , plaintext = 0xec6631b17e5c97193fd9651b64feffe7\n  },\n\n  { key = 0x92764a89e0de63823b9d9a5a001868035af416e2f3557b7688461fe0a4dc7850\n  , ciphertext = 0xec6631b17e5c97193fd9651b64feffe7\n  , plaintext = 0x1eef8afa419a9341085a2d611185e42c\n  },\n\n  { key = 0x0c0bf13d79d1297e137e6f5995cb0a2c441b9c18b2cfe837801c3281b5599c7c\n  , ciphertext = 0x1eef8afa419a9341085a2d611185e42c\n  , plaintext = 0xd4eb4e591cf856b816e2207264e426e4\n  },\n\n  { key = 0xde31f995867bb45813d369349cb7434290f0d241ae37be8f96fe12f3d1bdba98\n  , ciphertext = 0xd4eb4e591cf856b816e2207264e426e4\n  , plaintext = 0x401e14b126348e1aedd13662a19c23fb\n  },\n\n  { key = 0x3b1a02b5600444db09118e99765fa61dd0eec6f0880330957b2f249170219963\n  , ciphertext = 0x401e14b126348e1aedd13662a19c23fb\n  , plaintext = 0x38bfea7e1eece741eb6a9601605129dd\n  },\n\n  { key = 0x1fbcf4ffb36f76b88323f745b3152947e8512c8e96efd7d49045b2901070b0be\n  , ciphertext = 0x38bfea7e1eece741eb6a9601605129dd\n  , plaintext = 0x71cd66b3b3553b6aa632c338a307e11a\n  },\n\n  { key = 0xb963bfe1c513f0dba7e24b5cfa1535a3999c4a3d25baecbe367771a8b37751a4\n  , ciphertext = 0x71cd66b3b3553b6aa632c338a307e11a\n  , plaintext = 0x34c2972d43e59eb0c44b7b69a540e7de\n  },\n\n  { key = 0x23458e2a4332ce00e7967a438cd86448ad5edd10665f720ef23c0ac11637b67a\n  , ciphertext = 0x34c2972d43e59eb0c44b7b69a540e7de\n  , plaintext = 0x8988b878d0c6a84b6262351e033fb1b7\n  },\n\n  { key = 0xe552b8a0f474a8da502e749e3f0639b124d66568b699da45905e3fdf150807cd\n  , ciphertext = 0x8988b878d0c6a84b6262351e033fb1b7\n  , plaintext = 0x010e24d01c37edca127484c8d8137772\n  },\n\n  { key = 0x65a0645dd971bdb3b0d3a079ef96f3a925d841b8aaae378f822abb17cd1b70bf\n  , ciphertext = 0x010e24d01c37edca127484c8d8137772\n  , plaintext = 0x6c7b2e83630a8c8b6219839297d7c647\n  },\n\n  { key = 0x9867d55ae9f56a03c435f4b25f2eee2c49a36f3bc9a4bb04e03338855accb6f8\n  , ciphertext = 0x6c7b2e83630a8c8b6219839297d7c647\n  , plaintext = 0xccba81435ecf162f70d30b3163cb3858\n  },\n\n  { key = 0xe4a3addb683bbe85ed84b3ce044bcc538519ee78976bad2b90e033b439078ea0\n  , ciphertext = 0xccba81435ecf162f70d30b3163cb3858\n  , plaintext = 0xa0575bc9b8931f34cd6072e2015e7331\n  },\n\n  { key = 0x6f543088bf24577d55a685e3637d85e8254eb5b12ff8b21f5d8041563859fd91\n  , ciphertext = 0xa0575bc9b8931f34cd6072e2015e7331\n  , plaintext = 0xa44046a87574e6d3e6c6446fb3c324bc\n  },\n\n  { key = 0x5fff671ca24c3b241ddb92761f02dfe3810ef3195a8c54ccbb4605398b9ad92d\n  , ciphertext = 0xa44046a87574e6d3e6c6446fb3c324bc\n  , plaintext = 0xef6abb8ae007b730be45aa85e39f362d\n  },\n\n  { key = 0xdb897d48a317f66412a8c52111c3f3b06e644893ba8be3fc0503afbc6805ef00\n  , ciphertext = 0xef6abb8ae007b730be45aa85e39f362d\n  , plaintext = 0xe5bd2edfb7e563f6cd86da757c4c370f\n  },\n\n  { key = 0x78aec1da8e8e79007af12c05d800a18d8bd9664c0d6e800ac88575c91449d80f\n  , ciphertext = 0xe5bd2edfb7e563f6cd86da757c4c370f\n  , plaintext = 0x33caa267a64fb3cac210271bb8f25369\n  },\n\n  { key = 0x2c3e5387a51addb0b7789ef0289109b3b813c42bab2133c00a9552d2acbb8b66\n  , ciphertext = 0x33caa267a64fb3cac210271bb8f25369\n  , plaintext = 0x27bb26990ca5e12d387bd659cb7e7860\n  },\n\n  { key = 0x85685fe6996d514e5928d7196f41b5d29fa8e2b2a784d2ed32ee848b67c5f306\n  , ciphertext = 0x27bb26990ca5e12d387bd659cb7e7860\n  , plaintext = 0xd866ace71916e00c1559bba4149380a0\n  },\n\n  { key = 0x82abcc9a00bae55087cf5d87413f095547ce4e55be9232e127b73f2f735673a6\n  , ciphertext = 0xd866ace71916e00c1559bba4149380a0\n  , plaintext = 0x8a4d6a0af8488a82a0c31332db3e36de\n  },\n\n  { key = 0x81d983ce59413e84d7af4558d2e3941ccd83245f46dab86387742c1da8684578\n  , ciphertext = 0x8a4d6a0af8488a82a0c31332db3e36de\n  , plaintext = 0x05f6ff378b837cd375cddfae79ec2a9d\n  },\n\n  { key = 0xbbe6d0d13a6b146bb23db6885ba66487c875db68cd59c4b0f2b9f3b3d1846fe5\n  , ciphertext = 0x05f6ff378b837cd375cddfae79ec2a9d\n  , plaintext = 0xb706bdb4019d604cc35faa07197c318d\n  },\n\n  { key = 0x8092df6673b2b77783f2ba73c22e8d3c7f7366dcccc4a4fc31e659b4c8f85e68\n  , ciphertext = 0xb706bdb4019d604cc35faa07197c318d\n  , plaintext = 0xb26354bc77d3ce16909ca505d2381e4c\n  },\n\n  { key = 0x3118fc57b93677af8e14c1b5961b76f3cd103260bb176aeaa17afcb11ac04024\n  , ciphertext = 0xb26354bc77d3ce16909ca505d2381e4c\n  , plaintext = 0x1515ef6a25cf3943eadadc36a029194a\n  },\n\n  { key = 0xc4bde4a0c5f80329be6dd515f5bf6dabd805dd0a9ed853a94ba02087bae9596e\n  , ciphertext = 0x1515ef6a25cf3943eadadc36a029194a\n  , plaintext = 0x7b4ad946dfb59c80b1dc5cedb2fa87a0\n  },\n\n  { key = 0x80b47f9126b0b1f5ab408bb9ea5f349aa34f044c416dcf29fa7c7c6a0813dece\n  , ciphertext = 0x7b4ad946dfb59c80b1dc5cedb2fa87a0\n  , plaintext = 0xfa10a53e14cde5ef1e9a8a5692847aa5\n  },\n\n  { key = 0x86a43939c8cd243f7ff2a9658524373b595fa17255a02ac6e4e6f63c9a97a46b\n  , ciphertext = 0xfa10a53e14cde5ef1e9a8a5692847aa5\n  , plaintext = 0x4c9bed07308abcd0b09265b5efbe301c\n  },\n\n  { key = 0x74a8f02a15285153e0ae160fbddcf6bf15c44c75652a96165474938975299477\n  , ciphertext = 0x4c9bed07308abcd0b09265b5efbe301c\n  , plaintext = 0x75b7496c42809a3a592acbd8e069269e\n  },\n\n  { key = 0x293b40a2f70cc2c4262554663fb6f0986073051927aa0c2c0d5e58519540b2e9\n  , ciphertext = 0x75b7496c42809a3a592acbd8e069269e\n  , plaintext = 0x2dbc01185af7e084d90578468b6b10ef\n  },\n\n  { key = 0xb04d4f4eb708eef86c5b6b8e08a665084dcf04017d5deca8d45b20171e2ba206\n  , ciphertext = 0x2dbc01185af7e084d90578468b6b10ef\n  , plaintext = 0xc95b3a9f689c9dce4995c24f72dd5162\n  },\n\n  { key = 0x7cb9f7211815e0cb48b71286f84f80a184943e9e15c171669dcee2586cf6f364\n  , ciphertext = 0xc95b3a9f689c9dce4995c24f72dd5162\n  , plaintext = 0x616e55c3bf113e2c18cae3c61b7eb7d1\n  },\n\n  { key = 0xb3cdb46cf92aa0b96e87212bc650d5e5e5fa6b5daad04f4a8504019e778844b5\n  , ciphertext = 0x616e55c3bf113e2c18cae3c61b7eb7d1\n  , plaintext = 0x87e8b80767ebbdbad75cb94f4cb54f3b\n  },\n\n  { key = 0x512c2a3821eb53af613141c71e1076656212d35acd3bf2f05258b8d13b3d0b8e\n  , ciphertext = 0x87e8b80767ebbdbad75cb94f4cb54f3b\n  , plaintext = 0xc83e20e18f2b1457788954b49fd84307\n  },\n\n  { key = 0x9977c985745bc33954a2ce898bc8febdaa2cf3bb4210e6a72ad1ec65a4e54889\n  , ciphertext = 0xc83e20e18f2b1457788954b49fd84307\n  , plaintext = 0xe3d3868f578caf34e36445bf14cefc68\n  }]\n```"}]}
{"filename":"cryptol\/tests\/regression\/twinmult.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the ec_twin_mult function for elliptic curve points, ensuring it behaves correctly when one or both points are the zero point, matches single scalar multiplications when appropriate, and satisfies expected algebraic identities such as addition and subtraction of scalar multiples."},{"role":"assistant","content":"```cryptol\nimport PrimeEC\n\nzro : ProjectivePoint 7\nzro = { x = 1, y = 1, z = 0 }\n\nproperty twin_mult_zro j k =\n  ec_equal`{7} (ec_twin_mult j zro k zro) zro\n\nproperty twin_mult_zro1 j k S =\n  ec_equal`{7} (ec_twin_mult j zro k S) (ec_mult k S)\n\nproperty twin_mult_zro2 j k S =\n  ec_equal`{7} (ec_twin_mult j S k zro) (ec_mult j S)\n\nproperty twin_mult_same j k S =\n  ec_equal`{7} (ec_twin_mult j S k S) (ec_add (ec_mult j S) (ec_mult k S))\n\nproperty twin_mult_neg j k S =\n  ec_equal`{7} (ec_twin_mult j S k (ec_negate S)) (ec_sub (ec_mult j S) (ec_mult k S))\n```"}]}
{"filename":"cryptol\/tests\/regression\/word-update.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the functions 'update' and 'updateEnd' correctly modify a 16-bit word by setting or clearing the bit at position 'y' according to the input bit 'b'. Ensure the properties cover both direct bitmask operations and list-based bit updates, and prove their equivalence."},{"role":"assistant","content":"```cryptol\nproperty wordUpdate (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> update x y b == if b then x || msk else x && ~msk\n\n where\n msk = 0b1000000000000000 >> y\n\nproperty wordUpdate2 (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> update x y b == x'\n\n where\n x' = [ if i == y then b else x@i | i <- [0 .. 15] ]\n\nproperty wordUpdateEnd (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> updateEnd x y b == if b then x || msk else x && ~msk\n\n where\n msk = 0b0000000000000001 << y\n\nproperty wordUpdateEnd2 (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> updateEnd x y b == x'\n\n where\n x' = [ if i == y then b else x!i | i <- reverse [0 .. 15] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/f2polytest.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the polynomial multiplication, division, and modulo functions (pmult, pdiv, pmod) are equivalent to their reference implementations in Cryptol::Reference for various input sizes. Include properties that handle edge cases such as division or modulo by zero."},{"role":"assistant","content":"```cryptol\nimport Cryptol::Reference as Ref\n\npmult_equiv : {u, v} (fin u, fin v) => [1+u] -> [1+v] -> Bit\npmult_equiv x y = pmult x y == Ref::pmult x y\n\npdiv_equiv : {u, v} (fin u, fin v) => [u] -> [v] -> Bit\npdiv_equiv x y = y == 0 \\\/ pdiv x y == Ref::pdiv x y\n\npmod_equiv : {u, v} (fin u, fin v) => [u] -> [1+v] -> Bit\npmod_equiv x y = y == 0 \\\/ pmod x y == Ref::pmod x y\n\n\/\/ an arbitrary collection of test sizes\n\nproperty mult3_9   = pmult_equiv`{3,9}\nproperty mult9_3   = pmult_equiv`{9,3}\nproperty mult8_8   = pmult_equiv`{8,8}\nproperty mult28_11 = pmult_equiv`{28,11}\nproperty mult32_32 = pmult_equiv`{32,32}\nproperty mult64_64 = pmult_equiv`{64,64}\n\nproperty div3_9   = pdiv_equiv`{3,9}\nproperty div9_3   = pdiv_equiv`{9,3}\nproperty div8_8   = pdiv_equiv`{8,8}\nproperty div28_11 = pdiv_equiv`{28,11}\nproperty div32_32 = pdiv_equiv`{32,32}\nproperty div64_64 = pdiv_equiv`{64,64}\n\nproperty mod3_9   = pmod_equiv`{3,9}\nproperty mod9_3   = pmod_equiv`{9,3}\nproperty mod8_8   = pmod_equiv`{8,8}\nproperty mod28_11 = pmod_equiv`{28,11}\nproperty mod32_32 = pmod_equiv`{32,32}\nproperty mod64_64 = pmod_equiv`{64,64}\n```"}]}
{"filename":"cryptol\/tests\/regression\/r01.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the 'any' and 'all' functions defined in the given code. The properties should check that 'any f xs' returns true if and only if there exists at least one element in 'xs' for which 'f' returns true, and that 'all f xs' returns true if and only if 'f' returns true for every element in 'xs'. Include test cases similar to those in the comments to validate these properties."},{"role":"assistant","content":"```cryptol\nany : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nany f xs = [ f x | x <- xs ] != zero\n\nall : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nall f xs = [ f x | x <- xs ] == ~zero\n\n\/\/ all ltTen [0 .. 9] where ltTen x = x < 10\n\/\/ all ltTen [0 .. 10] where ltTen x = x < 10\n\/\/ any ltTen [100 .. 10] where ltTen x = x < 10\n\/\/ any ltTen [100 .. 9] where ltTen x = x < 10\n```"}]}
{"filename":"cryptol\/tests\/regression\/r05.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the correctness of the 'unflatten' function, ensuring that for any input sequence 'p', the output is a sequence of 5-bit words whose concatenation equals 'p' padded with zeros if necessary."},{"role":"assistant","content":"```cryptol\nunflatten : {r, w}\n            (fin r, 5 * w >= r, fin w)\n            => [r] -> [w][5]\nunflatten p = groupBy`{5}(p # zero)\n```"}]}
{"filename":"cryptol\/tests\/regression\/check22.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that specifies and verifies the correctness of the 'gtimes' function, ensuring it correctly implements multiplication in GF(2^8) using the given irreducible polynomial 'irred'. The property should check that for all inputs 'a' and 'b' in [8], 'gtimes(a, b)' produces the expected field multiplication result, and it should include tests similar to 'check22' to validate specific cases."},{"role":"assistant","content":"```cryptol\nirred : [8]\nirred = 0x1b\nxtimes a = (if a ! (length a - 1) then a' ^ irred else a')\n  where a' = a << 1\n\ngtimes : ([8], [8]) -> [8]\ngtimes (a, b)\n  = (if b == 0 then 0 else xtimes (gtimes (a, b >> 1)) ^ a')\n    \/\/ endianness difference from Cryptol-1 test:\n  where a' = if b ! 0 then a else 0\n\ncheck22 = [ gtimes (13, x) | x <- [ 1, 12, 192 ] ] == [ 13, 92, 183 ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check23.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the correctness of the 'pad' function by checking that for the given test message 'tmsg', the output of 'pad tmsg' matches the expected output 'out'. Ensure the property is suitable for automated checking with Cryptol's :check command."},{"role":"assistant","content":"```cryptol\npad : {msgLen, padding, contentLen, chunks}\n    ( fin msgLen\n    , fin padding\n    , contentLen == msgLen + 65\n    , chunks == (contentLen + 511) \/ 512\n    , 64 >= width msgLen\n    , padding == (512 - contentLen % 512) % 512\n    ) => [msgLen] -> [chunks * 512]\npad msg = msg # [True] # (zero:[padding]) # sz  \/\/or: (`msgLen:[64])\n      where  sz : [64]\n             sz = (length msg):[64]\n\ntmsg : [4]\ntmsg = 13\nout : [512]\nout = 0xd8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004\ncheck23 = pad tmsg == out\n```"}]}
{"filename":"cryptol\/tests\/regression\/check09.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the sequences 'ss' and 'ls' as defined by their recursive equations, and the function 'keyX' that derives a sequence of 7 32-bit words from a 4x8-bit key. The properties should check that the computed sequences match the expected values given in 'check9a', 'check9b', and 'check9'. Ensure the specifications can be used with :check or :prove commands to validate the implementation."},{"role":"assistant","content":"```cryptol\ninitS : [1][32]\ninitL : [1][32]\ninitS = [0]\ninitL = [0]\nss = [ (s + a + b) <<< 3   | s <- initS # ss\n\t                       | a <- [1] # ss\n\t                       | b <- [0] # ls ]\nls = [ (l + a + b) <<< (a + b)\n                        | l <- initL # ls\n\t\t                | a <- ss\n\t\t                | b <- [0] # ls ]\n\ncheck9a = (ss @@ [0 .. 3] == [ 0x00000008, 0x00004080, 0x00068c00, 0x00a22800 ])\n       && (ls @@ [0 .. 3] == [ 0x00000800, 0x00005080, 0x00072d00, 0x00b08200 ])\n\nkeyX : [4][8] -> [7][32]\nkeyX key = ss @@ [ 0 .. 6 ]\n  where\n    initS : [1][32]\n    initL : [1][32]\n    initS = [0]\n    initL = split (join key)\n    ss = [ (s + a + b) <<< 3\n                    | s <- initS # ss\n\t\t\t\t    | a <- [1] # ss\n\t\t\t\t    | b <- [0] # ls ]\n    ls = [ (l + a + b) <<< (a + b)\n                    | l <- initL # ls\n\t\t\t\t    | a <- ss\n\t\t\t\t    | b <- [0] # ls ]\n\n\/\/ NOTE different endianness from Cryptol 1 test\ncheck9b = keyX (reverse \"abcd\") ==\n\t    [0x00000008, 0x1b134ba3, 0x11ae69b1, 0xb7b3f42f,\n             0xc9eb1fdc, 0x008b5f36, 0x8991bc8c]\n\ncheck9 = check9a && check9b\n```"}]}
{"filename":"cryptol\/tests\/regression\/check21.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that formally verifies the correctness of the function 'xtimes' with respect to the given irreducible polynomial 'irred'. The property should check that for all 8-bit inputs, 'xtimes' correctly performs the multiplication by x in GF(2^8) modulo 'irred'. Additionally, include a test property that confirms the 'check21' list matches the expected results for the sample inputs [1, 12, 192]."},{"role":"assistant","content":"```cryptol\nirred : [8]\nirred = 0x1b\n\/\/ endianness difference from Cryptol-1 test\nxtimes a = (if a ! (length a - 1) then a' ^ irred else a')\n  where a' = a << 1\n\ncheck21 = [ xtimes y | y <- [ 1, 12, 192 ] ] == [ 2, 24, 155 ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the element-wise addition of two 3-dimensional arrays as demonstrated in the given code snippet, ensuring the result matches the expected summed array."},{"role":"assistant","content":"```cryptol\ncheck20 = [ [ [ 1, 2 ], [ 3, 4 ] ] ]\n        + [ [ [ 5, 6 ], [ 7, 8 ] ] ]\n       == [ [ [ 6, 8 ], [ 10, 12 ] ] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check08.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the correctness of the infinite sequence 'qq' by checking that its first five elements match the expected list [1, 2, 5, 12, 27]. Ensure the property can be used for formal verification or testing within Cryptol."},{"role":"assistant","content":"```cryptol\nqq = [ s + a + b | s <- [0] # qq\n\t          | a <- [1] # qq\n\t          | b <- [0] # zs ]\nzs : [inf][32]\nzs = [0...]\n\ncheck8 = qq @@ [0 .. 4] == [1, 2, 5, 12, 27]\n\nproperty prefix = qq @@ [0 .. 4] == [1, 2, 5, 12, 27]\n```"}]}
{"filename":"cryptol\/tests\/regression\/reference.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the local implementations of foldl, scanl, and iterate functions behave identically to their corresponding reference implementations in the Cryptol::Reference module, using subtraction and addition as shown."},{"role":"assistant","content":"```cryptol\nimport Cryptol::Reference as Ref\n\n\/\/ NB, using subtraction here because is is not commutative or associative\n\nproperty foldl_eq (z:Integer) (xs:[10]Integer) =\n  foldl (-) z xs == Ref::foldl (-) z xs\n\nproperty scanl_eq (z:Integer) (xs:[10]Integer) =\n  scanl (-) z xs == Ref::scanl (-) z xs\n\nproperty iterate_eq (z:Integer) (i:[8]) =\n  (iterate (\\x -> x + 1) z)@i == (Ref::iterate (\\x -> x + 1) z)@i\n```"}]}
{"filename":"cryptol\/tests\/regression\/rec-update.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that record updates in the given code correctly modify the fields as intended, including single-field updates, multiple-field updates, and updates using functions over fields and sequences."},{"role":"assistant","content":"```cryptol\ntype T = { x : [8], y : Bool }\n\nf1 = { x = 2, y = True } : T\nf2 = { f1 | x = 3 }\nf3 = { f2 | x = 4, y = False }\nf4 = { f3 | x -> x + 1 }\nf5 = [f1,f2,f3,f4]\nf6 = { f5 | x = [7,8,9,10] }\n```"}]}
{"filename":"cryptol\/tests\/regression\/check24.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property specification that verifies the correctness of the 'xor' function by checking that for all 4-bit inputs x and y, the function 'xor' produces the same result as the built-in bitwise XOR operator (^). The property should confirm that the equality holds for all input pairs."},{"role":"assistant","content":"```cryptol\nxor : {a} ([a], [a]) -> [a]\nxor (xs, ys) = [ x != y | x <- xs | y <- ys ]\n\ncheck24 = [ xor`{4} (x, y) == (x ^ y) | x <- [ 0 .. 15 ], y <- [ 0 .. 15 ] ] == ~zero\n```"}]}
{"filename":"cryptol\/tests\/regression\/primes.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of modular arithmetic operations defined in the file, specifically ensuring that the reciprocal function satisfies the property x * recip x == 1 modulo prime p, and that modular division satisfies (x \/. y) * y == x for various prime moduli, including large primes like p192, p224, p256, p384, and p521."},{"role":"assistant","content":"```cryptol\nz1prime : {n} (prime n) => Z n\nz1prime = 1\n\nz1_2 = z1prime`{2}\nz1_3 = z1prime`{3}\nz1_17 = z1prime`{17}\nz1_2_17m1 = z1prime`{2^^17 - 1}\n\n\ntype p192 = 6277101735386680763835789423207666416083908700390324961279\ntype p224 = 26959946667150639794667015087019630673557916260026308143510066298881\ntype p256 = 115792089210356248762697446949407573530086143415290314195533631308867097853951\ntype p384 = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\ntype p521 = 6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151\n\nrecip_correct : {p} (prime p) => Z p -> Bool\nrecip_correct x = x == 0 \\\/ x * recip x == 1\n\nproperty recip_correct_17   = recip_correct`{17}\nproperty recip_correct_1021 = recip_correct`{1021}\nproperty recip_correct_p192 = recip_correct`{p192}\nproperty recip_correct_p224 = recip_correct`{p224}\nproperty recip_correct_p256 = recip_correct`{p256}\nproperty recip_correct_p384 = recip_correct`{p384}\nproperty recip_correct_p521 = recip_correct`{p521}\n\nmoddiv_eq : {p} (prime p, p >= 3) => Z p -> Z p -> Bool\nmoddiv_eq x y = y == 0 \\\/ (x \/. y) * y == x\n\nproperty moddiv_eq17   = moddiv_eq`{17}\nproperty moddiv_eq1021 = moddiv_eq`{1021}\n\nproperty moddiv_eq_p192 = moddiv_eq`{p192}\nproperty moddiv_eq_p224 = moddiv_eq`{p224}\nproperty moddiv_eq_p256 = moddiv_eq`{p256}\nproperty moddiv_eq_p384 = moddiv_eq`{p384}\nproperty moddiv_eq_p521 = moddiv_eq`{p521}\n```"}]}
{"filename":"cryptol\/tests\/regression\/bitshift.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the two implementations of the 'shift' function, namely 'shift' and 'shift_alt', produce identical outputs for all valid inputs. Include properties that test the behavior of these functions with various bit vectors and fill bits, ensuring correctness of the bit-shifting logic."},{"role":"assistant","content":"```cryptol\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n          fills = [bit]#(take fill)\n\nshift_alt : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift_alt fill bit = fills\n\twhere\n\t  fills = [bit]#(drop`{1} (fill >> 1))\n\ninfZero : [inf]Bit\ninfZero = [False] # infZero\n\nproperty shift_eq a b c d e = shift (take`{10} ([a,b,c,d]#infZero)) e\n                           == shift_alt (take`{10} ([a,b,c,d]#infZero)) e\n```"}]}
{"filename":"cryptol\/tests\/regression\/check27.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the 'zero' value correctly initializes various types, including Bit, tuples of different sizes, and functions, ensuring they equal the expected zero values as demonstrated in the 'check27' expression."},{"role":"assistant","content":"```cryptol\nzeroBit : Bit\nzeroBit = zero\n\nzeroTuple : ([8], [32])\nzeroTuple = zero\nzeroTuple3 : ([8], [32], [256])\nzeroTuple3 = zero\n\nzeroFun : [8] -> [16]\nzeroFun = zero\n\ncheck27 = (zeroBit == False)\n\t&& (zeroTuple == (0, 0)) && (zeroTuple3 == (0, 0, 0))\n\t&& ((0, 0) == zeroTuple) && ((0, 0, 0) == zeroTuple3)\n\t&& (zeroFun 13 == 0)\n```"}]}
{"filename":"cryptol\/tests\/regression\/check26.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the fst and snd functions for tuple extraction, ensuring they behave as expected on example tuples and lists of tuples as given in the code snippet."},{"role":"assistant","content":"```cryptol\nfst (x, y) = x\nsnd (x, y) = y\nxy = (13, 21)\ncheck26a = (fst xy == xy.0) && (snd xy == xy.1) &&\n\t   (fst xy == 13) && (snd xy == 21)\n\nxys = [ (x, y) | x <- [ 1 .. 10 ], y <- [ 2 .. 5 ] ]\ncheck26b = [ fst ixy | ixy <- xys ] ==\n\t   [ x | x <- [ 1 .. 10 ], y <- [ 2 .. 5 ] ]\n\/\/ endianness difference\ncheck26c = [ fst ixy == snd ixy | ixy <- xys ] == reverse 0x0000084210\n\ncheck26 = check26a && check26b && check26c\n```"}]}
{"filename":"cryptol\/tests\/regression\/check03.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the 'nats' function, ensuring that accessing the infinite sequence at any index returns the expected natural number starting from the initial value."},{"role":"assistant","content":"```cryptol\nnats : [32] -> [inf][32]\nnats n = [n] # nats (n + 1)\n\ncheck3 = (nats 0 @ 45 == 45) && (nats 45 @ 0 == 45)\n```"}]}
{"filename":"cryptol\/tests\/regression\/rational_properties.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the algebraic and order-theoretic properties of the Rational type as a commutative ring, field, total order, ordered field, and dense total order. Include properties for addition, multiplication, negation, reciprocal, division, ordering relations, density, integer division rounding, and correctness of floor and ceiling functions."},{"role":"assistant","content":"```cryptol\n\/\/ == Q is a commutative ring ==\n\nproperty QaddUnit (x : Rational) =\n  x + 0 == x\n\nproperty QaddComm (x:Rational) (y:Rational) =\n  x + y == y + x\n\nproperty QaddAssoc (x:Rational) (y:Rational) (z:Rational) =\n  x + (y + z) == (x + y) + z\n\nproperty Qneg (x: Rational) = x + negate x == 0\n\nproperty QmulUnit (x : Rational) =\n  x * 1 == x\n\nproperty QmulComm (x:Rational) (y:Rational) =\n  x * y == y * x\n\nproperty QmulAssoc (x:Rational) (y:Rational) (z:Rational) =\n  x * (y * z) == (x * y) * z\n\n\/\/ Distributivity in Q\nproperty Qdistrib (x:Rational) (y:Rational) (z:Rational) =\n  x * (y + z) == x*y + x*z\n\n\/\/ == Q is a field ==\n\nproperty Qrecip (x: Rational) = x == 0 \\\/ x * recip x == 1\n\nproperty QdivisionEquiv (x : Rational) (y : Rational) =\n  y == 0 \\\/ x \/. y == x * (recip y)\n\n\/\/ == Q is a total order ==\n\nproperty QordEquiv1 (x : Rational) (y : Rational) =\n  (x <= y) == ~(y < x)\n\nproperty QordEquiv2 (x : Rational) (y : Rational) =\n  (x <= y) == (x == y \\\/ x < y)\n\nproperty QordTrans (x : Rational) (y : Rational) (z : Rational) =\n  x < y ==> y < z ==> x < z\n\nproperty QordIrreflexive (x : Rational) =\n  ~(x < x)\n\nproperty QordExclusive (x : Rational) (y:Rational) =\n  ~(x < y) || ~(y < x) \n\nproperty Qtrichotomy (x : Rational) (y : Rational) =\n  x < y \\\/ x == y \\\/ x > y\n\n\n\/\/  == Q is an ordered field\n\nproperty QordCompatible (x : Rational) (y : Rational) (z:Rational) =\n  x < y ==> x+z < y+z\n\nproperty QordPositive (x : Rational) (y : Rational) =\n  0 < x ==> 0 < y ==> 0 < x*y\n\n\/\/ == Q is a dense total order ==\nproperty Qdense (x : Rational) (y : Rational) = x < y ==> x < mid \/\\ mid < y\n  where\n  mid = (x + y) \/. 2\n\n\n\/\/ == Integer division rounds down ==\nproperty intDivDown (x : Integer) (y:Integer) =\n  y == 0 \\\/ fromInteger (x \/ y) <= ratio x y\n\n\n\/\/ == correctness of floor and ceiling\n\n\/\/ floor(x) is an integer below x\nproperty floorCorrect1 (x:Rational) =\n  fromInteger (floor x) <= x\n\n\/\/ floor(x) is the largest integer below x\nproperty floorCorrect2 (x:Rational) (y:Integer) =\n  fromInteger y <= x ==>\n  y <= floor x\n  \n\/\/ ceiling(x) is an integer above x\nproperty ceilingCorrect1 (x:Rational) =\n  fromInteger (ceiling x) >= x\n\n\/\/ ceiling(x) is the smallest integer above x\nproperty ceilingCorrect2 (x:Rational) (y:Integer) =\n  fromInteger y >= x ==>\n  y >= ceiling x\n```"}]}
{"filename":"cryptol\/tests\/regression\/check28.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that specifies and verifies the correctness of the 'check28' expression, ensuring that the list comprehension comparing pairs in 'xs' against zero behaves as intended."},{"role":"assistant","content":"```cryptol\nxs = [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7)]\ncheck28 = [ x==y | (x,y) <- xs ] == ~zero\n```"}]}
{"filename":"cryptol\/tests\/regression\/check14.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that formally specifies the behavior of the 'swab' function, ensuring that it reverses each 4-element list within a list of lists. Then, write a Cryptol test or verification script to check that 'check14' holds true according to this specification."},{"role":"assistant","content":"```cryptol\nswab xxs = [ [d, c, b, a]\n           | [a, b, c, d] <- xxs\n           ]\n\ncheck14 = swab [[0, 1, 2, 3], [4, 5, 6, 7]] == [[3, 2, 1, 0], [7, 6, 5, 4]]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check11.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the equality check11, ensuring that the concatenation and slicing operations on sequences zz, qq, and ww behave as expected, preserving the original sequence zz after the operations."},{"role":"assistant","content":"```cryptol\ncheck11 = zz == ww\n  where\n    zz = [0 .. 99]\n    qq = zz @@ ([0 .. 0xffffffff] : [_][32])\n    ww = qq @@ [0 .. 99]\n```"}]}
{"filename":"cryptol\/tests\/regression\/FloatTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of floating-point serialization and deserialization functions in the FloatTests module. Specifically, specify properties that check round-trip conversions between floating-point values and their bit representations, equality reflexivity including NaN and zero edge cases, and the preservation of values through rational conversions. Ensure the properties cover various floating-point sizes and handle special cases like NaN and signed zero correctly."},{"role":"assistant","content":"```cryptol\nmodule FloatTests where\n\nimport Float\n\nsection : {n} fin n => [n][8] -> [78][8]\nsection x = \"-- \" # take`{min 60 n} x # repeat '-'\n\ntype Small  = Float 3 2\ntype Medium = Float64\ntype Large  = Float 60 5000\n\nproperty roundTrip x  = fpFromBits (fpToBits x) =.= x\n\nroundTrip2 : {e : #, p : #} (fin e, fin p, ValidFloat e p) => [e + p] -> Bool\nproperty roundTrip2 x = fpToBits num == x \\\/ num =.= fpNaN\n                          where num = fpFromBits x : Float e p\nproperty eqRefl1 x    = x =.= x\nproperty eqRefl2 x    = x == x \\\/ x =.= fpNaN\nproperty eqProp x y   = ~(x == y) \\\/\n                         (x =.= y \\\/ x =.= fpNaN\n                                  \\\/ y =.= fpNaN\n                                  \\\/ (x =.=  0.0 \/\\ y =.= -0.0)\n                                  \\\/ (x =.= -0.0 \/\\ y =.=  0.0)\n                         )\nproperty leqRefl x    = x <= x \\\/ x =.= fpNaN\n\n\nroundTripRational : {e,p} (fin e, fin p, ValidFloat e p) => Float e p -> Bool\nproperty roundTripRational x =\n  ~(fpIsFinite x) \\\/\n  (fpFromRational rne (fpToRational x) =.= x) \\\/\n  (x =.= fpNegZero)\n```"}]}
{"filename":"cryptol\/tests\/regression\/specialize.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the function `f` in the `specialize` module returns its input tuple unchanged for any types `a` and `b`. Ensure the property is suitable for automated checking with Cryptol's `:check` command."},{"role":"assistant","content":"```cryptol\nmodule specialize where\n\ntop (x, y) = f`{Bit,Bit} (x, y)\n\nf : {a, b} (a, b) -> (a, b)\nf (x, y) = (x, y)\n```"}]}
{"filename":"cryptol\/tests\/regression\/poly.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the polynomial operations polyAdd and polyMul correctly correspond to addition and multiplication of polynomial evaluations, ensuring that for all polynomials p1 and p2 and all inputs x, evalPoly (polyAdd p1 p2) x equals evalPoly p1 x plus evalPoly p2 x, and evalPoly (polyMul p1 p2) x equals evalPoly p1 x times evalPoly p2 x. Also, specify a property confirming that evaluating the polynomial representing x squared yields x*x."},{"role":"assistant","content":"```cryptol\n\/\/ n-degree polynomials over a\nnewtype Poly n a = { coeffs : [n+1]a }\n\nevalPoly : {n, a} (fin n, Ring a) => Poly n a -> a -> a\nevalPoly p x = foldl (+) zero terms\n  where\n    terms = [ c*a | c <- p.coeffs | a <- xs ]\n    xs    = [fromInteger 1]#[ x*a | a <- xs ]\n\npolyConst : {n, a} (fin n, Ring a) => a -> Poly n a\npolyConst a = Poly { coeffs = [a]#zero }\n\npolyAdd : {n, a} (fin n, Ring a) => Poly n a -> Poly n a -> Poly n a\npolyAdd p1 p2 = Poly { coeffs = zipWith (+) p1.coeffs p2.coeffs }\n\npolyMul : {n1, n2, a} (fin n1, fin n2, Ring a) =>\n  Poly n1 a -> Poly n2 a -> Poly (n1+n2) a\npolyMul p1 p2 = foldl polyAdd (polyConst zero) ps\n  where\n    ps : [n1+1](Poly (n1+n2) a)\n    ps@i = Poly{ coeffs = scaleAndShift i }\n\n    scaleAndShift i =\n      ([ p1.coeffs@i * c | c <- p2.coeffs ] # zero) >> i\n\nproperty polySquare (x:Integer) =\n  evalPoly (Poly { coeffs = [0,0,1] }) x == x * x\n\nproperty polyAddEval x (p1:Poly 5 Integer) (p2:Poly 5 Integer) =\n  evalPoly (polyAdd p1 p2) x == evalPoly p1 x + evalPoly p2 x\n\nproperty polyMulEval x (p1:Poly 5 Integer) (p2:Poly 5 Integer) =\n  evalPoly (polyMul p1 p2) x == evalPoly p1 x * evalPoly p2 x\n```"}]}
{"filename":"cryptol\/tests\/regression\/check12.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the correctness of the 'sums' function, ensuring it produces the expected cumulative sums sequence for the input list [0 .. 9]."},{"role":"assistant","content":"```cryptol\nsums xs = ys\n  where ys = [ x + y | x <- xs | y <- [0] # ys ]\n\ncheck12 = sums ([0 .. 9] : [_][32]) == [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check06.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the correctness of the 'check6' expression, ensuring that the sequence 'onesytwosy' indexed by [0 .. 3] produces the expected alternating pattern [[1, 2], [2, 1], [1, 2], [2, 1]]. Include properties that confirm the definitions of 'onetwos' and 'twoones' and their recursive relationship."},{"role":"assistant","content":"```cryptol\nonetwos = [1] # twoones\ntwoones = [2] # onetwos\nonesytwosy = [ [one, two] | one <- onetwos | two <- twoones ]\n\ncheck6 = onesytwosy @@ [0 .. 3] == [ [1, 2], [2, 1], [1, 2], [2, 1] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check13.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the correctness of the functions 'ick' and 'uck' by checking that applying 'ick' to the result of 'split' on a value returns the original value, and similarly for 'uck'. Ensure the property can be used to prove equivalence between the original value and the reconstructed value from the split representation."},{"role":"assistant","content":"```cryptol\nick : [1][8] -> [8]\nick [x] = x\n\nuck : [8][1] -> [8]\nuck [a, b, c, d, e, f, g, h] = a # b # c # d # e # f # g # h\n\ncheck13 = (ick (split 150) == 150) && (uck (split 150) == 150)\n```"}]}
{"filename":"cryptol\/tests\/regression\/allsat.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the function 'f' correctly returns True if and only if all three input integers are within the range 1 to 15 inclusive, and False otherwise. Include test cases to check boundary conditions and out-of-range values."},{"role":"assistant","content":"```cryptol\nf : (Integer, Integer, Integer) -> Bit\nf (x, y, z) =  inRange x && inRange y && inRange z\n  where inRange v = (1 <= v) && (v <= 15)\n```"}]}
{"filename":"cryptol\/tests\/regression\/negshift.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that left and right shifts and rotates with negative shift amounts behave as specified by the negLeftShift, negRightShift, negLeftRotate, negRightRotate, and negSshr functions. Ensure the properties cover various bit widths and element types as in the provided code."},{"role":"assistant","content":"```cryptol\nnegLeftShift : {n, a} (fin n, Zero a, Cmp a) => [n]a -> Integer -> Bit\nnegLeftShift xs i = xs << i == xs >> (negate i)\n\nnegRightShift : {n, a} (fin n, Zero a, Cmp a) => [n]a -> Integer -> Bit\nnegRightShift xs i = xs >> i == xs << (negate i)\n\nnegLeftRotate : {n, a} (fin n, Cmp a) => [n]a -> Integer -> Bit\nnegLeftRotate xs i = xs <<< i == xs >>> (negate i)\n\nnegRightRotate : {n, a} (fin n, Cmp a) => [n]a -> Integer -> Bit\nnegRightRotate xs i = xs >>> i == xs <<< (negate i)\n\nnegSshr : {n} (fin n, n >= 1) => [n] -> Integer -> Bit\nnegSshr xs i = i < 0 ==> xs >>$ i == xs << (negate i)\n\nproperty nls1 = negLeftShift`{8, Bit}\nproperty nls2 = negLeftShift`{32, Bit}\nproperty nls3 = negLeftShift`{8, Integer}\nproperty nls4 = negLeftShift`{8, [32]}\n\nproperty nrs1 = negRightShift`{8, Bit}\nproperty nrs2 = negRightShift`{32, Bit}\nproperty nrs3 = negRightShift`{8, Integer}\nproperty nrs4 = negRightShift`{8, [32]}\n\nproperty nlr1 = negLeftRotate`{8, Bit}\nproperty nlr2 = negLeftRotate`{32, Bit}\nproperty nlr3 = negLeftRotate`{8, Integer}\nproperty nlr4 = negLeftRotate`{8, [32]}\n\nproperty nrr1 = negRightRotate`{8, Bit}\nproperty nrr2 = negRightRotate`{32, Bit}\nproperty nrr3 = negRightRotate`{8, Integer}\nproperty nrr4 = negRightRotate`{8, [32]}\n\nproperty nsshr1 = negSshr`{8}\nproperty nsshr2 = negSshr`{32}\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T06.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the submodule instantiations in module T06 correctly implement the interface submodule I, ensuring that the type N is consistently defined and that the submodules C, B, and A behave as expected according to their definitions and imports."},{"role":"assistant","content":"```cryptol\nmodule T06 where\n\ninterface submodule I where\n  type N : #\n\nsubmodule N1 where\n  type N = 1\n\nsubmodule C where\n  import interface submodule I\n\n  \/**\n   * ```repl\n   * let x = lost\n   * ```\n   *\/\n  lost = ()\n\nsubmodule B where\n  import interface submodule I\n  submodule C_ = submodule C { submodule N1 }\n\nsubmodule A = submodule B { submodule N1 }\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T10.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties and verification scripts to formally verify that all properties (p, q, r, s, t) in the module T10 and its submodules M, F, and F1 hold as specified. Include checks for parameterized submodules and private declarations."},{"role":"assistant","content":"```cryptol\n\/**\n```\n:check\n```\n*\/\nmodule T10 where\n\np : Bit\nproperty p = True\n\nsubmodule M where\n  q : Bit\n  property q = True\n\n  private\n    r : Bit\n    property r = True\n\nsubmodule F where\n  parameter\n    type N : #\n\n  s : Bit\n  property s = True\n\n  private\n    t : Bit\n    property t = True\n\nsubmodule F1 = submodule F where type N = 1\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T02.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the functions and parameters defined in the T02 module and its submodules. Specifically, create properties to check that the parameter 'c' equals 1 for all valid 'n', verify the commutativity property 'p x' holds for all inputs, and confirm that the function 'f' behaves as expected (e.g., f 10 == 20). Include properties suitable for :check or :prove commands to ensure these behaviors are correctly specified and verified."},{"role":"assistant","content":"```cryptol\nmodule T02 where\n\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n, n >= 2)\n\n  \/**\n    * ```\n    * :check c == 1\n    * ```\n    *\/\n  private\n    c : Z n\n    c = 1\n\n    \/**\n   Longer code block delimiters are supported\n   ````repl\n   :exhaust p\n   ````\n   *\/\n  p x = c + x == x + c\n\nsubmodule F7 = submodule F where\n  type n = 7\n\n\/**\n ** ```repl\n ** let y = 20\n **\n ** :check f 10 \\\n **          == 20\n ** ``` *\/\nf : Integer -> Integer\nf x = x + x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue314.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property to verify that the function 'f' correctly returns the first element of the zero-initialized sequence 'ys', where 'ys' is defined as a zero vector of length 'a\/2' with elements of type [8]. Ensure the property holds for all valid inputs satisfying the constraints."},{"role":"assistant","content":"```cryptol\nf : {a} (fin a, a>=2) => [a][8] -> [8]\nf xs = ys!0\n where\n  ys : [a\/2][8]\n  ys = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1796.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the functions exhaustive1, exhaustive1Reordered1, exhaustive1Reordered2, exhaustive2, and exhaustive3 behave equivalently for all valid inputs and that their pattern matching covers all cases correctly without overlap or omission."},{"role":"assistant","content":"```cryptol\nexhaustive1 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1 x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n\nexhaustive1Reordered1: {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1Reordered1 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n\nexhaustive1Reordered2 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1Reordered2 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n\n\/\/ Note that `(2 ^^ w) >= 1`, which means that there is no need for a\n\/\/ `(2 ^^ w) < 1` guard below.\nexhaustive2 : {w} [2 ^^ w] -> [2 ^^ w]\nexhaustive2 x\n  | (2 ^^ w) == 1 => ~ x\n  | (2 ^^ w) > 1 => x\n\nexhaustive3 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive3 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue670.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the custom type operator (+++) correctly computes the subtraction of type-level natural numbers, and that the values 'g' and 'h' conform to their specified types using this operator."},{"role":"assistant","content":"```cryptol\ntype x +++ y = x-y\n\ng : [6 +++ 2 +++ 1]\ng = 2\n\nh : [6 +++ (2 +++ 1)]\nh = 9\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue116.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the equality comparisons used in the tuple 't' from the given code snippet, ensuring that the fields 'key' and 'value' are correctly compared for equality as shown in 'bug116fixed'."},{"role":"assistant","content":"```cryptol\nt = (0x1, { key = 4, value = \"goodbye\"})\n\nbug116fixed = (t.1.value == t.1.value) \/\\ (t.1.key == t.1.key)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the behavior of the 'copy' function, ensuring it correctly replicates the input sequence of bits. The property should check that for any input sequence, the output matches the input exactly at every position."},{"role":"assistant","content":"```cryptol\ncopy : [inf] -> [inf]\ncopy ([b] # x) = if b then [True] # copy x else [False] # copy x\n\nproperty ok = copy ([True] # zero) @ 0\n```"}]}
{"filename":"cryptol\/tests\/issues\/T1439.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the functions f, p, h, g, q, q1, and q2 correctly extract elements from their input tuples or sequences as specified in the module T. Ensure that the properties hold for all valid inputs and that the submodule instantiations preserve the expected behavior."},{"role":"assistant","content":"```cryptol\nmodule T where\n  \/\/ sanity check: functions outside submodule each load\n  f : {n} [1][n] -> [n]\n  f [x] = x\n\n  p : {a,b} (a,b) -> a\n  p (x,_) = x\n\n  interface submodule I where\n    type n : #\n\n  submodule F where\n    import interface submodule I\n\n    h : [1][n] -> [n]\n    h [x] = x\n\n    g : {m} [1][m] -> [m]\n    g [x] = x\n\n    q, q1, q2 : {b} (b,_) -> b\n    q (x,_) = x\n\n    q1 x = x.0\n    q2 x = y\n      where\n      (y,z) = x\n\n  submodule P1 where\n    type n = 1\n\n  submodule S = submodule F { submodule P1 }\n\n  import submodule S\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue058.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that verify the type constraints and correctness of the functions 'some', 'last', and 'pad' in the given code snippet. Specifically, ensure that 'some' requires finite length constraints to typecheck, 'last' requires a length of at least 1, and 'pad' produces an infinite sequence by appending zeros. Include properties to check the behavior of these functions on representative inputs."},{"role":"assistant","content":"```cryptol\n\/\/ None of these should typecheck without fin constraints.\n\nsome : {n} [n] -> Bit\nsome x = x != 0\n\nlast : {n, a} (n >= 1) => [n]a -> a\nlast xs = xs ! 0\n\npad : {n} [n] -> [inf]\npad x = x # zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue312.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the equivalence of the two functions f and g, ensuring that for all 16-bit inputs, f(x) equals g(x)."},{"role":"assistant","content":"```cryptol\nf : [16] -> [16]\nf x = 3 * x\n\ng : [16] -> [16]\ng x = x + x + x\n\nproperty f_g = (f === g)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue662.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the division and modulus operations defined in the given code. Specifically, create properties that check the behavior of division rounding down, the Euclidean division identity, and the modulus absolute value constraints for all integer inputs, handling division by zero appropriately."},{"role":"assistant","content":"```cryptol\ntype Q = (Integer, Integer)\n\ntoQ : Integer -> Integer -> Q\ntoQ a b =\n  if b == 0 then error \"divide by 0\" else\n  if b < 0 then (negate a, negate b) else (a, b)\n\nleQ : Q -> Q -> Bit\nleQ (a,b) (c,d) = a*d <= b*c\n\nintToQ : Integer -> Q\nintToQ x = (x, 1)\n\nabs : Integer -> Integer\nabs x = if x < 0 then negate x else x\n\nproperty divRoundsDown (x : Integer) (y : Integer) =\n  y == 0 \\\/ leQ (intToQ ( x \/ y )) (toQ x y)\n\nproperty divEuclidean (x : Integer) (y : Integer) =\n  y == 0 \\\/ y * (x \/ y) + x % y == x\n\nproperty modAbs (x : Integer) (y : Integer) =\n  y == 0 \\\/ abs (x % y) < abs y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue78.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the correctness of the 'unique' function, ensuring it returns True if and only if all elements in the input sequence are unique. The property should be suitable for automated checking or proving within Cryptol's verification framework."},{"role":"assistant","content":"```cryptol\nunique : {a,b} (fin a, fin b, a>=1) => [a][b] -> Bit\nunique xs = [ exist x (i+1) | x <- xs | i <- [0..(a-1)] ] == 0\n  where exist : [b] -> [width a] -> Bit\n        exist x i = if(i>=`a) then False\n                    else if(x==(xs@i)) then True\n                    else exist x (i+1)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue138.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and equivalence of the recursive definitions 'dwn' and 'dwn'' as infinite sequences of 4-bit vectors, ensuring that both produce the same sequence. Additionally, specify properties to verify that 'take_some' correctly extracts the first 'k' elements from a sequence of length 'n' for all valid 'n', 'k', and element types 't'."},{"role":"assistant","content":"```cryptol\ndwn: [16][4]\ndwn = [ 1+d | d <- tail dwn ] # [0]\n\ndwn': [16][4]\ndwn' = [ 1+(dwn' @ i) | i <- [1 .. 15] ] # [0]\n\ntake_some: {n,k,t} (n>=k) => [n]t -> [k]t\ntake_some xs = takes where takes = [ x | x <- xs | _ <- takes ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue851.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the functions foo, bar, and baz, ensuring that the property 'problem' holds for all valid inputs p. The specification should capture the intended behavior of these functions and prove that if p differs from foo B, then bar p (baz p 0x03) 0x03 equals foo B."},{"role":"assistant","content":"```cryptol\ntype base t = { zero: t }\n\nB: base Bool\nB = { zero = False }\n\nfoo: {t,k} (fin k) => base t -> [k]t\nfoo b = repeat b.zero\n\nbar: {t,k} (fin k, k>=1) => [k]t -> [k]t -> [k]t -> [k]t\nbar p q m = p\n\nbaz: {k,t} (fin k, k >= 1) => [k]t -> [k]t -> [k]t\nbaz p q = q\n\nproperty problem p =\n  p != foo B ==> bar p (baz p 0x03) 0x03 == foo B\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1590.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property or specification that verifies the behavior of the submodules and parameters in the given code. Specifically, ensure that the instantiation of submodule M with parameter x = False correctly defines type U and that the value foo of type U has the expected field bit set to True."},{"role":"assistant","content":"```cryptol\nmodule Main where\n\nsubmodule F where\n  parameter\n    x : Bit\n  newtype T = { bit : Bit }\n  type U = T\n\nsubmodule M = submodule F where x = False\n\nimport submodule M\n\nfoo : U\nfoo = T { bit = True }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1802.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the function `csum` in the given module. The properties should check that `csum` correctly computes the sum of the transformed input list elements as specified, for all valid parameter values of `loglogw` within the given constraints."},{"role":"assistant","content":"```cryptol\n\/\/ A regression test for #1802.\nmodule T1802 where\n\nparameter\n  type loglogw : #\n  type constraint (loglogw >= 1, loglogw <= 3)\n\ntype logw = 2^^loglogw\ntype w = 2^^logw\n\ncsum : [32][logw] -> [logw+5]\ncsum msg = sum [`w - 1 - zext msgi | msgi <- msg]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue962a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and type consistency of the functions f, g, h, i, and j defined in the given Cryptol code snippet. Ensure that the properties check the expected output types and values, particularly focusing on the projections and field accesses used in the functions."},{"role":"assistant","content":"```cryptol\nf : {a, b} (fin a) => [a]b -> (Bit, [a]b)\nf x = (True, x)\n\ng : {a,b} (fin a) => [a]b -> [a]b\ng x = (f`{a=a} x).1\n\nh = f.1\n\ni : {a} (fin a) => [a] -> [a]\ni = f`{a=a}.1\n\nj : {a} (fin a) => [a]{ fld : Integer } -> [a]Integer\nj = f`{a=a,b={fld : Integer}}.1.fld\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue160.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that verify the correctness of bitwise rotation operations on fixed-size bit vectors, ensuring that left and right rotations behave as expected with respect to bit widths and rotation amounts. Specifically, formalize properties that check rotation equivalences, masking of rotation indices, and the reversibility of rotations for various bit widths."},{"role":"assistant","content":"```cryptol\nthm1 : [16] -> Bit\nproperty thm1 x = (x <<< 16 == x) && (x >>> 16 == x)\n\nthm2 : [16] -> [16] -> Bit\nproperty thm2 x i = x >>> i == x >>> (i && 0x000f)\n\nthm3 : [15] -> [8] -> Bit\nproperty thm3 x i = x <<< i == x <<< (i % 15)\n\nthm4 : [15] -> [15] -> Bit\nproperty thm4 x i = x <<< i >>> i == x\n\nthm5 : [15] -> [3] -> Bit\nproperty thm5 x i = x <<< i >>> i == x\n\nthm6 : [8] -> [4] -> [4] -> Bit\nproperty thm6 x i j = x <<< i >>> j == x <<< (i - j)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue148.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property specification to verify that the Salsa20_expansion function correctly constructs the 64-byte output from the given key and nonce inputs, ensuring that the constants, key parts, and nonce are placed in the expected positions according to the Salsa20 specification."},{"role":"assistant","content":"```cryptol\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(k, n) = z\n  where\n    [s0, s1, s2, s3] = if (`a == 2) then split(\"expand 32-byte k\")\n                                    else split(\"expand 16-byte k\")\n    k1 = take`{16}(k#zero)\n    k2 = drop`{16}(zero#k)\n    x = s0 # k1 # s1 # n # s2 # k2 # s3\n    z = x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue389.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property specification to verify that the function 'pad' correctly pads an input message of length 'n' to a length 'm' as defined, ensuring the output length matches 'm', the appended bit is True, the padding bits are zero, and the original message is preserved at the start."},{"role":"assistant","content":"```cryptol\npad : {n, m, b} (64>=width(n), b==512-((n+65)%512), m==65+n+b) => [n]->[m]\npad message = (message#[True])#(0:[b])#sz\n     where\n                sz : [64]\n                sz = length message\n\ntest = pad\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue177.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the imported values w, x, y, and z are correctly defined as zero in their respective types, ensuring consistency across the modules issue177A, issue177B, and issue177C."},{"role":"assistant","content":"```cryptol\nmodule issue177 where\n\nimport issue177A\nimport issue177B as B\nimport issue177C as C\n\ntype Byte = [8]\n\nw : Byte\nw = zero\n\nx : Word16\nx = zero\n\ny : B::Word32\ny = zero\n\nz = C::z\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1744-2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the 'once', 'iter', and 'process' functions correctly update the 'stuff' array within the 'Info' type. Specifically, ensure that 'once' updates the array at the given 'Key' index to zero, 'iter' applies 'once' sequentially over a list of entries, and 'process' behaves equivalently to 'iter' with a fixed key of zero. Include properties that check array bounds and preservation of unchanged elements."},{"role":"assistant","content":"```cryptol\nmodule Bug where\n\nimport Array\n\ntype Widget = [3]\ntype Wombat = [4]\ntype Key = [5]\nnewtype Info = {\n   stuff: Array [5] [6]\n}\n\nonce: Info -> Key -> Widget -> Wombat -> Info\nonce info key widget = info'\n   where\n      info' = Info {\n         stuff = arrayUpdate info.stuff key 0\n      }\n\niter: {n} n < 10 => Info -> Key -> [n] (Widget, Wombat) -> Info\niter info key entries = infos ! 0\n   where\n      infos = [info] # [once info' key widget wombat\n                           | info' <- infos\n                           | (widget, wombat) <- entries]\n\nprocess: {n} n < 10 => Info -> [n] (Widget, Wombat) -> Info\nprocess info entries = iter info 0 entries\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue485a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the functions 'foo', 'bar', and 'baz' defined in the module 'issue485a'. Specifically, specify properties that check 'foo' returns a valid RoundingMode, 'bar' acts as the identity function on 8-bit vectors, and 'baz' correctly implements byte-wise addition as a function returning another function."},{"role":"assistant","content":"```cryptol\nmodule issue485a where\n\nimport Float\n\nprivate type A = [8] -> [8]\n\nprivate type ByteFun t = [8] -> t\n\nfoo : RoundingMode\nfoo = 0\n\nbar : A\nbar x = x\n\nbaz : ByteFun (ByteFun [8])\nbaz = (+)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1324.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification and verification script to prove that the function 'g' of type 'S -> ()' is equivalent to the function 'f' of type 'T -> ()', given that 'g' is defined as 'f'. Ensure the verification checks type compatibility and function behavior consistency between 'f' and 'g'."},{"role":"assistant","content":"```cryptol\ntype T = { a: [8] }\ntype S = { a: [16] }\n\nf : T -> ()\nf _ = ()\n\ng : S -> ()\ng = f\n```"}]}
{"filename":"cryptol\/tests\/issues\/trac289.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that all the average functions (average1 through average5) produce the same result as average33 for all 32-bit inputs x and y. Additionally, write properties to check the equivalence between average4 and average5. Ensure the properties cover all input cases and can be used with Cryptol's :prove command."},{"role":"assistant","content":"```cryptol\naverage33 : [32] -> [32] -> [32]\naverage33 x y = drop`{1}(z'\/2)\n    where\n          z' : [33]\n          z' = (0b0 # x) + (0b0 # y)\n\naverage1 : [32] -> [32] -> [32]\naverage1 x y = (x + y)\/2\n\naverage2 : [32] -> [32] -> [32]\naverage2 x y = x\/2 + y\/2 + (x%2 && y%2)\n\naverage3 : [32] -> [32] -> [32]\naverage3 x y = (x + y) >> 1\n\naverage4 : [32] -> [32] -> [32]\naverage4 x y =    (x >> 1) + (y >> 1) + (x && y && 1)\n\naverage5 : [32] -> [32] -> [32]\naverage5 x y = lo + ((hi - lo)>>1) where\n    lo = min x y\n    hi = max x y\n\nproperty av1 x y = average33 x y == average1 x y\nproperty av2 x y = average33 x y == average2 x y\nproperty av3 x y = average33 x y == average3 x y\nproperty av4 x y = average33 x y == average4 x y\nproperty av5 x y = average33 x y == average5 x y\n\nproperty applesOranges x y = average4 x y == average5 x y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue214.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the function 'bm' correctly splits a bit vector of length 2*r into two interleaved halves, each of length r, and then concatenates them. The properties should check that for any input vector B, the output preserves all bits of B rearranged as specified."},{"role":"assistant","content":"```cryptol\nbm : {r} (fin r, r >= 1) => [2*r] -> [2*r]\nbm B = (B @@ [0,2..2*r-2]) # (B @@ [1,3..2*r-1])\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue614.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the function `f` produces a zero matrix of dimensions `[k][n]` given an input vector of length `[m]` under the constraint `n == max 2 m k == m + 1`. Also, write properties to verify that the function `g` correctly sign-extends an input vector of length `[n]` to length `[k]` when `0 < n <= k`. Ensure the properties check the output types and values conform to the specified behavior."},{"role":"assistant","content":"```cryptol\nf : {m, n, k} (n == max 2 m k == m + 1) => [m] -> [k][n]\nf x = zero\n\n\ng : {n, k} (fin n, fin k, 0 < n <= k) => [n] -> [k]\ng x = sext x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue416.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the functions 'f' and 'g' produce sequences of 3-bit words starting at 1 and incrementing by 'n' up to 7, ensuring that both functions generate equivalent sequences for all valid 'n'."},{"role":"assistant","content":"```cryptol\nf : {n} (fin n, 3 >= width n) => [lengthFromThenTo 1 n 7][3]\nf = [1, n .. 7]\n\ng : {n} (fin n, 3 >= width n) => [_][3]\ng = [1, n .. 7]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue364.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and expected behavior of the 'random' function as used in the given code snippet. Include properties that check the deterministic output for a fixed seed, ensure the output is not zero, and validate that different seeds produce different outputs. Provide these properties in a form suitable for :check or :prove commands in Cryptol."},{"role":"assistant","content":"```cryptol\nx : [64]\nx = random 123\n\nx_val : [64]\nx_val = 0xe4f7c1740def67df\n\nproperty x_eval = x == x_val\nproperty x_distinct = ~ (x == zero)\n\nproperty moderately_bogus_property (seed:[8]) =\n  ~(random (zero#seed) == (0:[64]))\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue826.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that specifies the expected behavior of the function WStep, ensuring that for any valid inputs, the output list is correctly computed according to the given transformation involving the cipher function CIPHk, the input list, and the value t. The property should verify the correctness of the splitting, XOR operation, and list manipulation steps in WStep."},{"role":"assistant","content":"```cryptol\nWStep:\n    {n}\n    (fin n, n >= 2) ->\n    ([128] -> [128]) -> [n][64] -> [64] -> [n][64]\nWStep CIPHk ([A] # Rs) t = [A'] # Rs'\n  where\n    [MSB, LSB] = split (CIPHk (A # head Rs))\n    A'         = MSB ^ t\n    Rs'        = tail Rs # [LSB]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue212.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties or verification scripts that check the correctness and consistency of the type constraints and width-related properties in the given Cryptol code. Specifically, verify that the width equalities and inequalities hold as intended, and that the finiteness constraints are properly enforced. Also, verify the behavior of the 'take_knows_no_bounds' function with respect to its type constraints and slicing logic."},{"role":"assistant","content":"```cryptol\n\/\/ TMD: I am using this issue for a range of regressions or short-comings with the new type checker.\n\/\/ Let me know if you'd like separate github issue numbers.\n\n\/\/ Want: exact width values is nice (width x == const ==> width x >= const)\n\/\/ Issue: Cryptol wants 'width x >= const'\n\/\/ width_eq_geq : {n} (32 == width n, n >= 1, 32 >= width n, fin n) => [n]Bit\nwidth_eq_geq : {n} (32 == width n, n >= 1) => [n]Bit\nwidth_eq_geq = [True | _ <- [1..n] : [_][32] ]\n\n\/\/ Want: const >= width (x+1) ==> const > width x\n\/\/ or any monotonic function, not just addition.\n\/\/\n\/\/ Also Want: const >= width n     ==> fin n\n\/\/\n\/\/ Issue: Cryptol wants '64 >= width n' and 'fin n'\n\/\/ can_not_width : {n} (64 >= width (8*(n+1)), 64 >= width n, fin n) => [64]\ncan_not_width : {n} (64 >= width (8*(n+1))) => [64]\ncan_not_width = zero # (`n : [width n])\n\n\/\/ Want: Honestly, I don't know what's going on here.  It seems to relate to some of our regressions though.\n\/\/ Tell me if there should be another ticket - probably one that already exists. -TMD\n\/\/ Issue: Cryptol 2.3 wants 'n == 4 + (?a3 - n % 4)'\ntake_knows_no_bounds : {n} (fin n, n >= 4) => [n][8] -> [4 - (n%4)][8]\ntake_knows_no_bounds ns = foo\n where\n foo = take `{4 - (n%4)} ns\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1024b.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that specifies and verifies the behavior of the function `someFunc` defined with the type constraint `PredSyn a (Logic a)`. The property should check that `someFunc` returns the bitwise negation of zero for any type `a` satisfying the constraints."},{"role":"assistant","content":"```cryptol\ntype constraint PredSyn (a : *) (p:Prop) = (Zero a, Cmp a, p)\n\nsomeFunc : {a} (PredSyn a (Logic a)) => a\nsomeFunc = ~zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/T1440.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that captures the expected behavior and type constraints of the submodules and interface submodules defined in the given Cryptol file, including the relationships between submodules M, N, M1, and M2, and the interface submodule I. Then, write verification properties or tests to ensure that the submodule imports and overrides conform to the specified interfaces and expected values."},{"role":"assistant","content":"```cryptol\nmodule T1440 where\n\nimport interface submodule X\n\nimport submodule Y\n\ninterface submodule I where\n  type n : #\n\nsubmodule M where\n  import interface submodule I\n\nsubmodule N where\n  x = 2\n\nsubmodule M1 = submodule M { submodule U1 }\nsubmodule M2 = submodule U2 { submodule N }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue368.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the function `myFun` consistently returns 0 for all possible 8-bit inputs, and that all the custom operators defined as `x <op> y = myFun x y` behave equivalently by always producing 0. Include tests to check that these operators do not deviate from this specification."},{"role":"assistant","content":"```cryptol\nmyFun : [8] -> [8] -> [8]\nmyFun a b = 0\n\nx + y = myFun x y\nx * y = myFun x y\nx - y = myFun x y\nx ~ y = myFun x y\nx ^^ y = myFun x y\nx ++ y = myFun x y\nx .+ y = myFun x y\nx +. y = myFun x y\nx !+ y = myFun x y\nx +! y = myFun x y\nx .! y = myFun x y\nx :+ y = myFun x y\nx =+ y = myFun x y\nx .: y = myFun x y\nx :+: y = myFun x y\nx +:: y = myFun x y\nx ^^^ y = myFun x y\nx .... y = myFun x y\nx +\/\/+ y = myFun x y\nx .\n```"}]}
{"filename":"cryptol\/tests\/issues\/T146.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the functions mk_curve_ops, ec_v1, and ec_v2, including their relationships and constraints on the field parameter. Then, write Cryptol properties suitable for verification to ensure that ec_v2 correctly accesses the v0 element of the field, and that mk_curve_ops constructs the curve operations consistently with ec_v1 and ec_v2."},{"role":"assistant","content":"```cryptol\nmk_curve_ops f = undefined\n  where\n    c = { field = f\n        , v1    = ec_v1 f\n        , v2    = ec_v2 c\n        }\n\nec_v1 : {fv} { v0: fv } -> fv\nec_v1 = undefined\n\nec_v2 : {fv} _ -> fv\nec_v2 p = p.field.v0\n  where _ = p.field.v0\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1024a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the function `funnyFunc` correctly returns zero for all valid type parameters `i`, `f`, and `g` as specified in the given Cryptol code."},{"role":"assistant","content":"```cryptol\ntype Funny (f : # -> *) = Integer\ntype Strange (f : Prop) = Integer\n\nfunnyFunc : { i : #, f : # -> *, g : * } Integer\nfunnyFunc = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue225.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to specify and verify the behavior of the EnigmaBroke module's functions: mkRotor, scramble, and joinRotors. The properties should capture the expected transformations on rotors and characters, ensuring that joinRotors correctly processes a sequence of rotors and an input character to produce updated rotors and an output character consistent with the Enigma machine logic."},{"role":"assistant","content":"```cryptol\nmodule EnigmaBroke where\n\ntype Rotor       = [26](Char, Bit)\n\nmkRotor : {a} (fin a) => ([26]Char,[a]) -> Rotor\nmkRotor (_,_) = zero\n\nscramble : (Bit, Char, Rotor) -> (Bit, Char, Rotor)\nscramble (_,_,_) = zero\n\njoinRotors : {n} (fin n) => ([n]Rotor, Char) -> ([n]Rotor, Char)\njoinRotors (rotors, inputChar) = (rotors', outputChar)\n  where\n    initRotor = mkRotor (['A' .. 'Z'], [])\n    \/\/ ncrs : [n+1](Bit, [8], Rotor)\n    ncrs = [(True, inputChar, initRotor)]\n               # [ scramble (notch, char, r)\n                 | r <- rotors\n                 | (notch, char, rotor') <- ncrs\n                 ]\n    rotors' = tail [ r | (_, _, r) <- ncrs ]\n    (_, outputChar, _) = ncrs ! 0\n```"}]}
{"filename":"cryptol\/tests\/issues\/Issue796.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the 'key_schedule' and 'encrypt_block' functions in the given module. The properties should check that 'key_schedule' produces a RoundKey of the expected size and that 'encrypt_block' produces a Block output when given a valid Key and Block input. Additionally, specify properties that ensure the types and sizes conform to the parameterized type '_k'."},{"role":"assistant","content":"```cryptol\nmodule Issue796 = Issue796_Sig where\n\nparameter\n  type _k: #\n\ntype Key = [8 * _k]\ntype Block = [64]\ntype RoundKey = [64]\n\naux : RoundKey -> Block -> Block\naux RK P = zero\n\n\/\/ key_schedule : Key -> RoundKey\nkey_schedule K = zero\n  where\n    _ = [ groupBy`{4} K ]\n\n\/\/ encrypt_block : Key -> Block -> Block\nencrypt_block key pt = aux (key_schedule key) pt\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue581.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the functions 'foo' and 'bar' correctly produce sequences of 32-bit words with lengths equal to 'i' divided by 'j' (using '\/' and '%' exponentiation operators respectively), ensuring that the length constraints and type signatures hold for all valid finite 'i' and 'j' with 'j >= 1'."},{"role":"assistant","content":"```cryptol\nfoo : {i, j} (fin i, fin j, j >= 1) => [i \/^ j][32]\nfoo = take [0...]\n\nbar : {i, j} (fin i, fin j, j >= 1) => [i %^ j][32]\nbar = take [0...]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue185.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the correctness of the 'group' function, ensuring that it correctly splits a sequence of length 'c' into 'a' groups each containing 'perGroup' elements, and that the total length matches the expected size."},{"role":"assistant","content":"```cryptol\ngroup : {perGroup, a, b, c} (fin perGroup, c == perGroup * a)\n    => [c]b -> [a][perGroup]b\ngroup xs = split`{each=perGroup}xs\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue187.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the 'enigma' function, including properties that verify its correctness as an encryption\/decryption function. The specification should capture the relationship between inputs and outputs and enable formal verification of the 'enigma' implementation."},{"role":"assistant","content":"```cryptol\n\/\/ Helper synonyms:\n\/\/ type Char        = [8]\nmodule Enigma where\n\nenigmaLoop : {n}(fin n) => [n]\nenigmaLoop = undefined\n\n\/\/ Encryption\/Decryption\nenigma : {n, m} (fin n, fin m) => ([n], [m]) -> [m]\nenigma (m, pt) = tail [ True | _ <- rcs ]\n  where rcs = [ (m, True)] #\n              [ (enigmaLoop, True)\n              | _     <- pt\n              | (_,_) <- rcs\n              ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1511.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the value of the constant 'v' matches the 'value' field of the 'SAD' constructor in the 'MOOD' record, ensuring the correct assignment of the mood state."},{"role":"assistant","content":"```cryptol\nmodule M where\n\nv: [1]\nv = MOOD.SAD.value\n\nnewtype MOOD_t = { value: [1] }\n\nMOOD = { HAPPY = MOOD_t { value = 0b1 }\n       , SAD   = MOOD_t { value = 0b0 }\n       }\n```"}]}
{"filename":"cryptol\/tests\/issues\/trac133.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that for all valid 'a' (1 <= a <= 2) and inputs 'k' of type [16*a][8], the functions 'example1' and 'example2' produce the same output of type [16][8]. Additionally, specify properties to check that the output length and content conform to the expected behavior defined by the drop and concatenation operations in both functions."},{"role":"assistant","content":"```cryptol\nexample1 : {a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8]\nexample1 k = drop`{16} ((zero : [16*(2 - a)][8]) #k)\n\nexample2 : {a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8]\nexample2 k = drop`{16} (zero # k)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue877.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the behavior of list concatenation (@@) in the given code snippet, ensuring that concatenating with empty lists and mapped empty lists behaves as expected."},{"role":"assistant","content":"```cryptol\na = []\n\nxs : [_] Integer\nxs = [1,2,3]\n\nb = xs @@ []\nc = xs @@ (map trunc [])\nd = xs @@ (map (\\x -> [x]) [])\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue_1812.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the arithmetic identities and type equalities used in the definitions of functions f, ff, jj, and kk, specifically confirming that (2^^h + 2^^h) - 2^^h equals 2^^h and that the type constraints hold as expected for all finite h."},{"role":"assistant","content":"```cryptol\nf : {h} (fin h) => [2^^h + (2^^h - 2^^h)]\nf = g`{h}\n\ng : {h} (fin h) => [2^^h]\ng = zero\n\n\/\/ See if Cryptol knows that (2^^h + 2^^h) - 2^^h == 2^^h\n\nff : {h} (fin h) => [(2^^h + 2^^h) - 2^^h]\nff = gg`{h}\n\ngg : {h} (fin h) => [2^^h]\ngg = zero\n\njj : {h} (fin h) => [2 ^^ (1 + h) - 1]\njj = kk`{h}\n\nkk : {h} (fin h, 2 ^^ (1 + h) - 1 >= 2 ^^ h - 1) => [2 ^^ h - 1 + 2 ^^ h]\nkk = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue268.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and termination behavior of the recursive sequence definitions 'xs' and 'vs' in the given code. Ensure the properties check that the sequences are well-defined, finite where expected, and conform to their intended recursive patterns."},{"role":"assistant","content":"```cryptol\nxs : [10]([8],[8])\nxs = take `{10} zs\n  where\n  zs : [inf]([8],[8])\n  zs = [(0,0)] # [ (0, z) | (z,_) <- drop `{1} zs]\n\nvs : [10]([8],[8])\nvs = take `{10} zs where zs = [ (0, z) | (z,_) <- zs]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue731.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol type-level properties or constraints that verify the correctness and consistency of the type constraints defined in the module 'issue731', including 'T', 'Both', 'Fin2', and the equivalence constraint '<=>'. Ensure these properties check that the constraints behave as intended for various type parameters."},{"role":"assistant","content":"```cryptol\nmodule issue731 where\n\ntype constraint T n = (fin n, n >= 1)\n\ntype constraint Both p q = (p, q)\n\ntype constraint Fin2 i j = Both (fin i) (fin j)\n\ntype constraint i <=> j = (i <= j, i >= j)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1562.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the submodules F1 and F2 correctly instantiate the interface submodule I and that their internal submodule M is consistent with the definition in F. Ensure that the type definitions and module compositions conform to the expected interface specifications."},{"role":"assistant","content":"```cryptol\ninterface submodule I where\n  type Zp = [8]\n\nsubmodule F where\n  import interface submodule I\n\nsubmodule M where\n  \/\/ this is unused, but just here because syntactically we cannot have an empty\n  \/\/ module\n  type Empty = Bit\n\nsubmodule F1 = submodule F { submodule M }\nsubmodule F2 = submodule F { submodule M }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1210.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the bit-shift operations and bit extraction logic in the given functions `mwe`, `mwe'`, `mwe''`, and `bitget`. Ensure that the properties capture the intended behavior of shifting bits by zero times the index and correctly extracting bits from a large bit vector."},{"role":"assistant","content":"```cryptol\nmwe : [2] -> [2][1] -> Bit\nproperty mwe i r = r@0 == (r@0) << 0*i\n\nmwe' : [2] -> [1] -> Bit\nproperty mwe' i r = r == (r << 0*i)\n\nmwe'' : Bit\nproperty mwe'' = r == (r << i)\n where r = 1:[1]\n       i = 0:[2]\n\nbitget : [12] -> [436][8] -> Bit\nproperty bitget i r = i < 3488 ==> bit_gf == if bit_bit then 0x0001 else 0x0000\n  where bit_gf = (zext (((r@(i\/8)) >> (i%8) ) && 1))\n        bit_bit = (join (map reverse r))@i\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue108.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the 'sum' function defined in the given code snippet. The properties should check that the function correctly computes the element-wise sum of a sequence of vectors and that the output length matches the expected dimension."},{"role":"assistant","content":"```cryptol\nsum : {a,b} (fin a, fin b) => [a][b] -> [b]\nsum xs = ss ! 0\n  where\n    ss = [0] # [ s + x | x <- xs | s <- ss ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue130.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property-based specification to verify that the function 'par' (which computes the parity of a bit sequence using foldl1 with XOR) is equivalent to the function 'parity' (which computes parity using a recursive definition). Include a property that can be checked for all input sequences of length n+1, where n is a finite size parameter."},{"role":"assistant","content":"```cryptol\nparity xs = ys!0\n  where ys = [False] # [y ^ x | x <- xs | y <- ys ]\n\nfoldl1 f xs = ys!0\n  where ys = [xs@0] # [ f y x | y <- ys | x <- tail xs ]\n\npar = foldl1 (^)\n\nparOK : {n} (fin n) => [n+1] -> Bit\nproperty parOK x = par x == parity x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1798.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the functions `exhaustive1` and `exhaustive2` with respect to their intended behavior on inputs of size `2 ^^ (2 ^^ w)` and `2 ^^ w` respectively. The properties should be suitable for automated checking or proving within Cryptol's verification framework."},{"role":"assistant","content":"```cryptol\nexhaustive1 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1 x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n\nexhaustive2 : {w} [2 ^^ w] -> [2 ^^ w]\nexhaustive2 x\n  | (2 ^^ w) == 1 => ~ x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue093.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the given code snippet, ensuring that the type conversions and comparisons behave as expected. Include properties that check the behavior of the functions t0, t1, t2, and f0, and explain any expected failures or contradictions in the properties."},{"role":"assistant","content":"```cryptol\nproperty t0 = True\nproperty t1 x = x == (x : [32])\nproperty t2 x y = if (x : [32]) < (y : [32]) then y != zero else True\nnot_a_prop = True\nproperty f0 = False\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue723.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the function `f` correctly computes the bitwise XOR of its input with itself, ensuring that for any input sequence `x`, `f x` equals the XOR of `x` with `x` as defined by the local function `g`."},{"role":"assistant","content":"```cryptol\nf : {n} (fin n) => [n] -> [n]\nf x = g x\n  where\n    m1 = x\n\n    g : {k} (fin k) => [k] -> [k]\n    g m0 = m0 ^ m1\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue494.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the two functions gt_words and gt_words' are equivalent for all inputs. The properties should check that for any two sequences of 32-bit words, both functions return the same Bit result."},{"role":"assistant","content":"```cryptol\ngt_words : {a} (fin a) => [a][32] -> [a][32] -> Bit\ngt_words l0 l1 = ss!0\n  where\n    ss = [ False ] # [ s \\\/ (i > j) | i <- l0 | j <- l1 | s <- ss ]\n\ngt_words' l0 l1 = ss!0\n  where\n    ss = [ False ] # [ s \\\/ (i > j) | i <- l0 | j <- l1 | s <- ss ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue734.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the functions 'f', 'asdf1', and 'asdf2' in the given Cryptol code. Specifically, ensure that 'f' correctly triples the input sequence, and that 'asdf1' and 'asdf2' produce values with the expected widths and values as per their type constraints."},{"role":"assistant","content":"```cryptol\nf : {a} (fin a) => [2^^a - 1] -> [3*(2^^a - 1)]\nf x = x # x # x\n\nasdf1 : {r} (fin r, width (2^^r)==r+1) => [r+1]\nasdf1 = `(2^^r)\n\nasdf2 : {r} (fin r, width(2^^r-1)==r) => [r]\nasdf2 = `(2^^r-1)\n```"}]}
{"filename":"cryptol\/tests\/issues\/Issue883_A.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property or specification to verify that the function `asdf` correctly processes its input message and produces a 128-bit output consistent with the behavior of `dumbHash` applied to the joined and dropped segments of `ys`. Include type and size constraints in your specification to ensure correctness across all valid inputs."},{"role":"assistant","content":"```cryptol\nmodule Issue883_A where\nparameter\n    type c : #\n    type constraint ( fin c, c >= 1, 64 >= width (c-1) )\n\ndumbHash : {n} (fin n, 64 >= width n) => [n] -> [128]\ndumbHash msg = zero\n\nasdf : {n} (64 >= width (n+192), 64 >= width (128 * c), fin n) => [n] -> [128]\nasdf msg = dumbHash (join (drop`{1} ys))\n where\n   ys : [c+1][128]\n   ys = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue640.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and equivalence of the functions f, g, and h defined in the given Cryptol code. Ensure the properties check that each function produces outputs consistent with their recursive definitions and that f and g behave equivalently on inputs of type [1], while h extends this behavior to sequences of length 8."},{"role":"assistant","content":"```cryptol\nf : [1] -> [2]\nf x = out\n  where out = x # [out@0]\n\ng : [1] -> [2]\ng x = out\n  where out = x # (take out)\n\nh : [1] [8] -> [2] [8]\nh x = out\n  where out = x # take out\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/mergesort.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property or specification that formally verifies the correctness of the mergesort implementation in the given code. The specification should ensure that the output list is sorted and is a permutation of the input list, preserving all elements without loss or duplication."},{"role":"assistant","content":"```cryptol\nsort : {n,a} Cmp a => (fin n) => [n]a -> [n]a\nsort xs\n  | n <= 1 => xs\n  | ()     => merge (sort left) (sort right)\n              where (left : [n\/2] _) # right = xs\n\nmerge : {m,n,a} Cmp a => [m]a -> [n]a -> [m+n]a\nmerge xs ys\n  | m == 0  => ys\n  | n == 0  => xs\n  | (m > 0, n > 0) => if x <= y \n                        then [x] # merge restX ys\n                        else [y] # merge xs restY\n                      where\n                      [x] # restX = xs\n                      [y] # restY = ys\n\n\nproperty sort_correct =\n  (sort [] == []) &&\n  (sort [0] == [0]) &&\n  (sort [-6, 1, 9, -3, -9, 2, 4] == [-9, -6, -3, 1, 2, 4, 9]) &&\n  (sort [4, -8, -1, -7, -5, 9, 8, 8] == [-8, -7, -5, -1, 4, 8, 8, 9]) &&\n  (sort [1, -1, -2, -3, -2, 7, 5] == [-3, -2, -2, -1, 1, 5, 7]) &&\n  (sort [9, 9, 8, -3, 1, 1, -6, -6, -8] == [-8, -6, -6, -3, 1, 1, 8, 9, 9]) &&\n  (sort [9, 1, 5, 0] == [0, 1, 5, 9]) &&\n  (sort [8, 3, 3] == [3, 3, 8]) &&\n  (sort [-7, 8] == [-7, 8])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/nestFun.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the function `f` in submodule `A` returns `True` when the parameter `n` is 0, and `False` when `n` is greater than 0. Then, write a Cryptol test that checks this property for the imported instances `Two` (where `n = 2`) and `Zero` (where `n = 0`)."},{"role":"assistant","content":"```cryptol\nsubmodule A where\n\n  parameter\n    type n : #\n\n  f : Bool\n  f | n == 0 => True\n    | n > 0  => False\n\nimport submodule A as Two where\n  type n = 2\n\nimport submodule A as Zero where\n  type n = 0\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/constant.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the functions isZero, isFin, and idTypeNum with respect to their intended behavior on various type-level natural numbers, including finite and infinite cases. Ensure the properties cover boundary conditions and typical values, and can be used with :check or :prove commands."},{"role":"assistant","content":"```cryptol\nisZero : {n : #} Bit\nisZero | n == 0 => True\n       | ()     => False\n\nproperty isZero_correct =\n  ~isZero `{inf} &&\n   isZero `{  0}   &&\n  ~isZero `{  1}   &&\n  ~isZero `{  2}   &&\n  ~isZero `{  4}   &&\n  ~isZero `{  8}   &&\n  ~isZero `{ 16}\n\nisFin : {n : #} Bit\nisFin | fin n => True\n      | ()    => False\n\nproperty isFin_correct =\n  ~isFin `{inf} &&\n   isFin `{  0}   &&\n   isFin `{  1}   &&\n   isFin `{  2}   &&\n   isFin `{  4}   &&\n   isFin `{  8}   &&\n   isFin `{ 16}\n\nidTypeNum : {n : #} Integer \nidTypeNum | fin n => `n\n\nproperty idTypeNum_correct =\n  (idTypeNum `{ 0}  ==  0) &&\n  (idTypeNum `{ 1}  ==  1) &&\n  (idTypeNum `{ 2}  ==  2) &&\n  (idTypeNum `{ 4}  ==  4) &&\n  (idTypeNum `{ 8}  ==  8) &&\n  (idTypeNum `{16}  == 16)\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/insert.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property specification that verifies the correctness of the `insert` function, ensuring that inserting an element into a sorted list results in a new sorted list containing all original elements plus the inserted element, preserving order and length constraints."},{"role":"assistant","content":"```cryptol\n\/\/ assumes that `xs` is sorted\ninsert : {n, a} (fin n, Cmp a) => a -> [n]a -> [n+1]a\ninsert x' xs \n  | n == 0         => [x']\n  | n == 1         => if x' <= x then [x', x] else [x, x']\n                      where [x] = xs\n  | ( n % 2 == 0\n    , n     >  1 ) => if x' <= x \n                        then insert x' (xs1 # [x]) # xs2 \n                        else xs1 # [x] # insert x' xs2\n                      where (xs1 : [n\/2 - 1]_) # [x] # (xs2 : [n\/2]_) = xs\n  | ( n % 2 == 1\n    , n     >  1 ) => if x' <= x \n                        then insert x' (xs1 # [x]) # xs2\n                        else xs1 # [x] # insert x' xs2\n                      where (xs1 : [n\/2]_) # [x] # (xs2 : [n\/2]_) = xs\n\nproperty insert_correct =\n  (insert 0 [  1,2,3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 1 [0,  2,3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 2 [0,1,  3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 3 [0,1,2,  4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 4 [0,1,2,3,  5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 5 [0,1,2,3,4,  6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 6 [0,1,2,3,4,5,  7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 7 [0,1,2,3,4,5,6,  8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 8 [0,1,2,3,4,5,6,7,  9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 9 [0,1,2,3,4,5,6,7,8  ] == [0,1,2,3,4,5,6,7,8,9])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/len.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that formally verifies the correctness of the 'len' function by proving that for any finite sequence 'x', 'len x' equals the built-in 'length x'. Ensure the property covers all possible input lengths and can be used with Cryptol's :prove command."},{"role":"assistant","content":"```cryptol\nlen : {n,a} (fin n) => [n] a -> Integer\nlen x\n  | (n == 0) => 0\n  | (n >  0) => 1 + len (drop`{1} x)\n\n\nproperty \n  len_correct = and\n    [ len l == length l where l = []\n    , len l == length l where l = [1]\n    , len l == length l where l = [1,2]\n    , len l == length l where l = [1,2,3]\n    , len l == length l where l = [1,2,3,4,5]\n    , len l == length l where l = [1,2,3,4,5,6]\n    , len l == length l where l = [1,2,3,4,5,6,7]\n    , len l == length l where l = [1,2,3,4,5,6,7,8]\n    ]\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/tail.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the 'tail' function correctly returns the input list without its first element for all finite sequences, including edge cases such as empty lists and single-element lists. Ensure the properties cover the behavior specified in the provided 'tail_correct' property and extend them to general inputs."},{"role":"assistant","content":"```cryptol\ntail : {n, a} (fin n) => [n]a -> [(max n 1) - 1]a\ntail xs | n == 0 => xs\n        | n >= 1 => drop `{1} xs\n\nproperty tail_correct =\n  (tail [] == []) &&\n  (tail [1] == []) &&\n  (tail [1,2] == [2]) &&\n  (tail [1,2,3] == [2,3]) &&\n  (tail [1,2,3,4] == [2,3,4])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/inits.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the function 'inits' correctly produces the concatenation of all initial segments of the input sequence, matching the expected output lengths and values as demonstrated in the provided examples."},{"role":"assistant","content":"```cryptol\n\/\/ ys      | zs      | acc\n\/\/ \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013+\u2013-\u2013\u2013\u2013\u2013\u2013\u2013\u2013+\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\n\/\/ [1,2,3] | []      | []\n\/\/ [2,3]   | [1]     | [1]\n\/\/ [3]     | [1,2]   | [1,1,2]\n\/\/ []      | [1,2,3] | [1,1,2,1,2,3]\n\ninits : {n, a} (fin n) => [n]a -> [(n * (n+1))\/2]a\ninits xs\n  | n == 0 => []\n  | n >  0 => initsLoop xs' x []\n    where\n      (x : [1]_) # xs' = xs\n\ninitsLoop : {n, l, m, a} (fin l, fin m, l + m == n, m >= 1) =>\n        [l]a -> [m]a ->\n        [((m-1) * ((m-1)+1))\/2]a ->\n        [(n * (n+1))\/2]a\ninitsLoop ys zs acc\n  | l == 0 => acc # zs\n  | l >  0 => initsLoop ys' (zs # y) (acc # zs)\n   where (y : [1]_) # ys' = ys\n\n\nproperty inits_correct =\n  (inits [] == []) &&\n  (inits [1] == [1]) &&\n  (inits [1,2] == [1,1,2]) &&\n  (inits [1,2,3] == [1,1,2,1,2,3]) &&\n  (inits [1,2,3,4] == [1,1,2,1,2,3,1,2,3,4]) &&\n  (inits [1,2,3,4,5] == [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5])\n```"}]}
{"filename":"cryptol\/tests\/modsys\/T11\/A.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the function `f` correctly extracts the first element of the tuple `T` (which is a sequence of type `[X]`) and ignores the second element. Include properties that check the length and content of the output relative to the input tuple."},{"role":"assistant","content":"```cryptol\nmodule T11::A where\n\nparameter\n  type X : #\n  type Y : #\n\ntype T = ([X],[Y])\n\nf : T -> [X]\nf (x,_) = x\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T038.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally verifies the correctness of the submodule imports and value bindings in the given module T038. Specifically, ensure that the values of 'x' and 'y' in submodules F, P, and Q conform to the expected relationships defined by the interface submodules I and J, and that the import hierarchy is correctly respected."},{"role":"assistant","content":"```cryptol\nmodule T038 where\n\ninterface submodule I where\n  x : [8]\n\nsubmodule F where\n  import interface submodule I\n  y = x + 1\n\nsubmodule P where\n  import submodule F { submodule Q }\n  x = 11\n\nsubmodule Q where\n  x = 11\n\ninterface submodule J where\n  import submodule F { submodule P }\n  x : [8]\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T011.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the submodules and interfaces in the given code, including the relationship between the imported types and values, and the computation of 'y' in submodule F. Then, write Cryptol properties to verify that 'y' in submodule M equals twice the value of 'x' defined in submodule I, ensuring correct import and substitution behavior."},{"role":"assistant","content":"```cryptol\n\/\/ Test importing in a signature\n\n\nsubmodule A where\n  type T = [8]\n\ninterface submodule S where\n  import submodule A\n  x : T\n\nsubmodule F where\n  import interface submodule S\n\n  y = 2 * x\n\nsubmodule I where\n  x = 28\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T005.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification and verification script that proves the submodule M, instantiated from functor F with submodules I and J, satisfies the constraint that X::n == Y::n. Specifically, verify that the addition operation y = X::x + Y::x is well-defined and type-safe under the given constraints, and that the types and values conform to the interface submodule A requirements."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A as X\n  import interface submodule A as Y\n\n  interface constraint (X::n == Y::n)\n\n  y : [X::n]\n  y = X::x + Y::x\n\n\nsubmodule I where\n  type n = 8\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule J where\n  type n = 9\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule M = submodule F { X = submodule I, Y = submodule J }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T006.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that captures the expected properties and constraints of the functor-based submodules defined in the file, including the relationships between types and values in submodules A, F, G, I, M, and N. Then, write Cryptol properties to verify that the arithmetic definitions (such as y = 5 * X::x + x) hold under the given constraints and that the type-level constraints (like n >= 3 and n == X::n) are enforced correctly."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A as X\n\n  interface constraint (X::n >= 3)\n\n  submodule G where\n    import interface submodule A\n    interface constraint (X::n == n)\n\n    y : [n]\n    y = 5 * X::x + x\n\n  y : [X::n]\n  y = 5 * X::x\n\n\nsubmodule I where\n  type n = 8\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n\nsubmodule N = submodule M::G { submodule I }\n\nimport submodule N as N\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T012.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property or specification that verifies the correctness of the value 'y' in submodule 'F' when instantiated with submodule 'I' in submodule 'M'. Ensure that 'y' correctly computes as twice the value of 'x' imported from 'I'."},{"role":"assistant","content":"```cryptol\n\/\/ Test importing in a signature\n\ninterface submodule S where\n  import T012_M\n  x : T\n\nsubmodule F where\n  import interface submodule S\n\n  y = 2 * x\n\nsubmodule I where\n  x = 28\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T002.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property or specification that verifies the correctness of the submodule instantiation and composition in the given code. Specifically, ensure that the value 'y' in submodule M correctly computes '1 + x' where 'x' is defined in submodule I with type size 8 and value 2. The specification should confirm that the types and constraints are respected and that the final value of 'y' in M is as expected."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 8\n  x = 2 : [n]\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T003.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally verifies the correctness of submodule M, ensuring that the value y in submodule F, instantiated with submodule I, correctly computes 1 + x where x is 42. The specification should include properties that check the type constraints and the arithmetic correctness of y."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 8\n\n  x : {a} Literal 42 a => a\n  x = 42\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T001.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally captures the behavior of the functor submodule F when instantiated with a submodule conforming to interface A. Then, write a verification script to prove that the submodule M, instantiated as F applied to I, satisfies the specification or identify any inconsistencies due to the zero-length vector in I."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 0\n  x = x : [n]\n\nsubmodule M = submodule F { submodule I }\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T028.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the submodules S, G, and F, including the relationships between x, y, and z. Then, write Cryptol properties to verify that the values computed in submodules G and F correctly reflect the imports and interface constraints, ensuring that z equals x plus y and y equals x plus 1 when x is instantiated as 5."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  x : [8]\n\nsubmodule G where\n  import interface submodule S\n  y = x + 1\n\nsubmodule F where\n  import interface submodule S\n  import submodule G { interface S }\n  z = x + y\n\nimport submodule F where\n  x = 5\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T027.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally verifies the correct resolution and usage of interface submodules and their imports in the given code. The specification should check that the values of 'x', 'y', and 'z' in the nested submodules correspond to the expected arithmetic based on the imported interfaces and submodules."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  x : [8]\n\nsubmodule G where\n  import interface submodule S\n  y = x + 1\n\nsubmodule F where\n  import interface submodule S as A\n\n  submodule H where\n    import interface submodule S as A\n    import submodule G { interface A }\n    z = A::x + y\n\nimport submodule F where\n  x = 5\n\nimport submodule H where\n  x = 6\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T037.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that verifies the value of 'z' in the top-level module 'T037' matches the expected computation based on the submodule hierarchy and interface constraints. Include properties that check the correct overriding of 'x' in submodules and the resulting value of 'y' and 'z'."},{"role":"assistant","content":"```cryptol\nmodule T037 where\n\ninterface submodule I where\n  x : [8]\n\nsubmodule F where\n  import interface submodule I\n  y = x + 1\n\nsubmodule P where\n  x = 11\n\nsubmodule X where\n  submodule M = submodule F { submodule P }\n  import submodule M\n\n  z = y\n\nimport submodule X\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T012_M.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines properties or invariants for the type alias 'T' defined as an 8-bit vector ([8]). Include properties that verify the behavior and constraints of values of type 'T'."},{"role":"assistant","content":"```cryptol\nmodule T012_M where\n\ntype T = [8]\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T022.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the correctness of the submodule F's definition of z, ensuring that z is always twice the value of x from the imported interface submodule S, for any valid n satisfying the fin n constraint."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  type n : #\n  type constraint (fin n)\n  x : [n]\n\nsubmodule F where\n  import interface submodule S as A\n\n  z = A::x + A::x\n\nimport submodule F where\n  type n = 8\n  x = 2\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T008.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property or specification that verifies the submodule M correctly instantiates the parameter n as 2 and that the value x in M is equal to 2, ensuring the constraints on n are satisfied."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n, n >= 2)\n\n  x : [n]\n  x = 2\n\n\nsubmodule M = submodule F where\n  type n = 2\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T035.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification and verification script that checks the behavior of the functor submodule F when instantiated twice as M and N. Specifically, verify that the function f in M and N operates correctly on their respective types X, and demonstrate the type error arising from the generative instantiation of F. Include properties or proofs that illustrate the difference between generative and applicative instantiation in this context."},{"role":"assistant","content":"```cryptol\nsubmodule A where\n  newtype T = { x : Integer }\n\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n)\n\n  newtype X = { x : [n] }\n  f : X -> X\n  f x = x\n\nsubmodule M = submodule F { _ }\nsubmodule N = submodule F { _ }\n\nimport submodule M as M\nimport submodule N as N\n\n\/\/ This is a type error because currently F's instantiation is generative\n\/\/ If we make it applicative, then we should change this test\nx = M::f (N::X { x = 0 })\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T040.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property or specification that verifies the behavior of the 'nt' function and the 'NT' newtype in the given module. Ensure that the 'field' function correctly maps any input of type 'T' to the unit value '()' as intended, and that the instantiation with 'T = [32]' behaves consistently."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type T : *\n\n  newtype NT = { field : T -> () }\n\n  nt : NT\n  nt = NT { field = \\_ -> () }\n\nimport submodule F where\n  type T = [32]\n\n\nx = nt.field 10\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/ffi-type-errors.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that captures the expected type constraints and calling conventions for the foreign function interfaces declared in the given file. The specification should define valid type signatures and constraints for foreign imports, and include properties or type-level checks that detect and reject the invalid or ill-formed foreign declarations shown, such as incorrect word sizes, unsupported float sizes, improper array types, missing fin constraints, infinite sequences, and wildcard types. This will enable automated verification that foreign function declarations conform to the Cryptol FFI type system rules."},{"role":"assistant","content":"```cryptol\nimport Float\n\nforeign badWordSizes : [65] -> [128]\nforeign badFloatSizes : Float16 -> Float128\nforeign badArrayTypes : {n} (fin n) =>\n  [n]Bit -> [n]([16], [16]) -> [n][4][8]{a : [n], b : [2]}\nforeign notFunction : [32]\nforeign badKind : {t} t -> [32]\nforeign noFin : {n} [n][32] -> [n * 2][32]\nforeign infSeq : [inf][32] -> Bit\nforeign wildcard : { x : [8], y : Float32 } -> _\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/ffi-fallback.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the behavior of the foreign functions declared in the given code snippet. Specifically, specify properties that distinguish between functions with and without Cryptol implementations, ensuring the correct function is used when both foreign and Cryptol definitions exist, and that functions without Cryptol implementations behave as expected."},{"role":"assistant","content":"```cryptol\nforeign foreignAndCryptol : [8] -> [8]\n\/\/ cryptol implementation is intentionally different,\n\/\/ so we can test which is being used\nforeignAndCryptol x = x\n\nforeign foreignAndNoCryptol : [8] -> [8]\n\nforeign noForeignAndCryptol : [8] -> [8]\nnoForeignAndCryptol x = x + 3\n\nforeign noForeignAndNoCryptol : [8] -> [8]\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/test-ffi.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the foreign function interfaces declared in the given Cryptol file. The properties should check that the foreign functions behave as expected for various input sizes and types, including integral types, floating-point operations, sequences, tuples, records, polymorphic sizes, nested sequences, and custom integer types. Ensure that type synonyms and nested modules are properly handled in the specifications."},{"role":"assistant","content":"```cryptol\nimport Float\n\n\/\/ Basic integral types\nforeign add8 : [8] -> [8] -> [8]\nforeign sub16 : [16] -> [16] -> [16]\nforeign mul32 : [32] -> [32] -> [32]\nforeign div64 : [64] -> [64] -> [64]\n\n\/\/ Non-machine integer sizes\nforeign extendInput : [3] -> [8]\nforeign maskOutput : [8] -> [3]\nforeign noBits : [0] -> [0]\n\n\/\/ Bit\nforeign not : Bit -> Bit\n\n\/\/ Float\nforeign addFloat32 : Float32 -> Float32 -> Float32\nforeign subFloat64 : Float64 -> Float64 -> Float64\nforeign specialFloats : [2] -> Float32\n\n\/\/ Type synonyms\ntype Word32 = [32]\ntype MyFunc = Word32 -> Float32 -> Bit\nforeign usesTypeSynonym : MyFunc\n\n\/\/ Sequences\nforeign sum10 : [10]Word32 -> Word32\nforeign reverse5 : [5]Float64 -> [5]Float64\n\n\/\/ Tuples and records\nforeign compoundTypes : ([32], { x : [10], y : [3][20] }) -> { z : [5][20] }\n  -> { a : ([16], [16]), b : { c : [8][20], d : [5], e : [5] } }\n\n\/\/ Polymorphic sizes\nforeign typeToValue : {n} (fin n) => () -> [64]\nforeign sumPoly : {n} (fin n) => [n]Word32 -> Word32\nforeign inits : {n} (fin n) => [n][8] -> [n * (n + 1) \/ 2][8]\nforeign zipMul3 : {n, m, p} (fin n, fin m, fin p) =>\n  [n]Float32 -> [m]Float32 -> [p]Float32 -> [min n (min m p)]Float32\n\n\/\/ Nested sequences\nforeign nestedSeq : {n, m, p} (fin n, fin m, fin p, n * m * p == 4 * 3 * 2) =>\n  [n][m][p][8] -> [4][3][2][8]\n\n\/\/ Integers, Rationals, Z\nforeign i2Q   : Integer -> Rational\nforeign i2Qs  : Integer -> [2]Rational\nforeign iQ2Qi : (Integer,Rational) -> (Rational,Integer)\nforeign i2Z5  : Integer -> Z 5\nforeign i2Z   : {n} (fin n, n >= 1) => Integer -> Z n\n\n\/\/ In a nested module\nsubmodule A where\n  foreign nested : () -> [8]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1489\/issue1489.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the 'fast_nttl' function in the given module. The properties should check that 'fast_nttl' correctly computes the number-theoretic transform using the 'ct_butterfly' operation and the 'zeta_expc' constants, ensuring that the output length matches the input length and that the recursive decomposition behaves as expected. Include properties that validate the base case (lv == 2) and the recursive case (lv > 2) for all valid input sizes."},{"role":"assistant","content":"```cryptol\nmodule ID where\n\nid : {k} (fin k, k > 0) => [2^^k] -> [2^^k]\nid x = join(split`{2,2^^(k-1)}x)\n\ntype q = 3329\n\nct_butterfly :\n    {m, hm}\n    (m >= 2, m <= 8, hm >= 1, hm <= 7, hm == m - 1) =>\n    [2^^m](Z q) -> (Z q) -> [2^^m](Z q)\nct_butterfly v z = new_v\n  where\n    halflen = 2^^`hm\n    lower, upper : [2^^hm](Z q)\n    lower@x = v@x + z * v@(x + halflen)\n    upper@x = v@x - z * v@(x + halflen)\n    new_v = lower # upper\n\nzeta_expc  : [128](Z q)\nzeta_expc = [ 1, 1729, 2580, 3289, 2642, 630, 1897, 848,\n              1062, 1919, 193, 797, 2786, 3260, 569, 1746,\n              296, 2447, 1339, 1476, 3046, 56, 2240, 1333,\n              1426, 2094, 535, 2882, 2393, 2879, 1974, 821,\n              289, 331, 3253, 1756, 1197, 2304, 2277, 2055,\n              650, 1977, 2513, 632, 2865, 33, 1320, 1915,\n              2319, 1435, 807, 452, 1438, 2868, 1534, 2402,\n              2647, 2617, 1481, 648, 2474, 3110, 1227, 910,\n              17, 2761, 583, 2649, 1637, 723, 2288, 1100,\n              1409, 2662, 3281, 233, 756, 2156, 3015, 3050,\n              1703, 1651, 2789, 1789, 1847, 952, 1461, 2687,\n              939, 2308, 2437, 2388, 733, 2337, 268, 641,\n              1584, 2298, 2037, 3220, 375, 2549, 2090, 1645,\n              1063, 319, 2773, 757, 2099, 561, 2466, 2594,\n              2804, 1092, 403, 1026, 1143, 2150, 2775, 886,\n              1722, 1212, 1874, 1029, 2110, 2935, 885, 2154 ]\n\nfast_nttl :\n    {lv}  \/\/ Length of v is a member of {256,128,64,32,16,8,4}\n    (lv >= 2, lv <= 8) =>\n    [2^^lv](Z q) -> [8] -> [2^^lv](Z q)\nfast_nttl v k\n  \/\/ Base case. lv==2 so just compute the butterfly and return\n  | lv == 2 => ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n\n  \/\/ Recursive case. Butterfly what we have, then recurse on each half,\n  \/\/ concatenate the results and return. As above, we need coerceSize\n  \/\/ here (twice) to satisfy the type checker.\n  | lv  > 2 => (fast_nttl`{lv-1} s0 (k * 2)) #\n                           (fast_nttl`{lv-1} s1 (k * 2 + 1))\n                where\n                  t = ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n                                    [s0, s1] = split t\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1561\/G.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the values ja, jb, ka, and kb in module G correctly correspond to the imported interface values J::x, J::y, K::x, and K::y plus their respective increments as defined in the code."},{"role":"assistant","content":"```cryptol\nmodule G where\n\nimport interface I as J\nimport interface I as K\n\nja = J::x + 1\njb = J::y + 2\n\nka = K::x + 1\nkb = K::y + 2\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1560\/T4.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally verifies the type constraints and value assignments within the nested submodules in the given Cryptol code. Specifically, ensure that the types 'x' in interfaces I1 and I2 satisfy their respective constraints, and verify that the value 'y' assigned in submodule F and the value 'csum' in submodule G conform to these constraints and types as imported from the interfaces."},{"role":"assistant","content":"```cryptol\nmodule T3 where\n\ninterface submodule I1 where\n  type x: #\n  type constraint (x >= 1, x <= 3)\n\ninterface submodule I2 where\n  type x: #\n  type constraint (x >= 1, x <= 4)\n\n\n\nsubmodule F where\n  import interface submodule I1 as I\n\n  y: [I::x]\n  y = 1\n\n  submodule G where\n    import interface submodule I2 as I\n    import interface submodule I2 as J\n\n    csum : [I::x]\n    csum = y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1560\/T2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property or specification that verifies the behavior and type correctness of the function 'b' in the submodule 'F', ensuring that it properly returns the parameter 'a' of type '[n]' regardless of the input argument."},{"role":"assistant","content":"```cryptol\nmodule T2 where\n\nparameter\n  type n: #\n  type constraint (fin n)\n\na:[n]\na = a\n\nsubmodule F where\n  parameter\n    type n: #\n\n  b: {m} [n] -> [m]\n  b _ = a\n```"}]}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Finite.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and expected behavior of the 'sumInf' function defined in the given code snippet. The properties should check that 'sumInf' produces an infinite sequence of sums consistent with the iterative summation logic and that it aligns with the initial finite sums generated from the input list 'xs'."},{"role":"assistant","content":"```cryptol\nxs = [ 1 .. 100 ]\n\nsumInf xs = iterSums\n    where\n        sums = [ 0 ] # [ x + y | x <- xs\n                               | y <- sums ]\n        iterSums = [ x + y | x <- sums\n                           | y <- [ 1 ...] ]\n```"}]}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Enigma.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the Enigma machine implementation in the provided code. Specifically, include properties that check: 1) the reflector is an involution (i.e., substFwd and substBwd are inverses for all characters), 2) encryption and decryption are inverses (i.e., decrypting an encrypted string returns the original string), and 3) rotor stepping behaves as expected during the scrambling process. Ensure the properties are suitable for Cryptol's :check or :prove commands."},{"role":"assistant","content":"```cryptol\n\/\/ Helper synonyms:\n\/\/ type Char        = [8]\nmodule Enigma where\n\ntype Permutation = String 26\n\n\/\/ Enigma components:\ntype Plugboard   = Permutation\ntype Rotor       = [26](Char, Bit)\ntype Reflector   = Permutation\n\n\/\/ An enigma machine with n rotors:\ntype Enigma n    = { plugboard : Plugboard,\n                     rotors    : [n]Rotor,\n                     reflector : Reflector\n                   }\n\n\/\/ Check membership in a sequence:\nelem : {a, b} (fin 0, fin a, Cmp b) => (b, [a]b) -> Bit\nelem (x, xs) = matches ! 0\n  where matches = [False] # [ m || (x == e)  | e <- xs\n                                             | m <- matches\n                            ]\n\/\/ Inverting a permutation lookup:\nprivate\n  invSubst : (Permutation, Char) -> Char\n  invSubst (key, c) = candidates ! 0\n    where candidates = [0] # [ if c == k then a else p\n                             | k <- key\n                             | a <- ['A' .. 'Z']\n                             | p <- candidates\n                             ]\n\n\/\/ Constructing a rotor\nmkRotor : {n} (fin n) => (Permutation, String n) -> Rotor\nmkRotor (perm, notchLocations) = [ (p, elem (p, notchLocations))\n                                 | p <- perm\n                                 ]\n\n\/\/ Action of a single rotor on a character\n\/\/ Note that we encrypt and then rotate, if necessary\nscramble : (Bit, Char, Rotor) -> (Bit, Char, Rotor)\nscramble (rotate, c, rotor) = (notch, c', rotor')\n  where \n    (c', _)    = rotor @ (c - 'A')\n    (_, notch) = rotor @ 0\n    rotor'     = if rotate then rotor <<< 1 else rotor\n\n\/\/ Connecting rotors in a sequence\njoinRotors : {n} (fin n) => ([n]Rotor, Char) -> ([n]Rotor, Char)\njoinRotors (rotors, inputChar) = (rotors', outputChar)\n  where \n    initRotor = mkRotor (['A' .. 'Z'], [])\n    ncrs : [n+1](Bit, [8], Rotor)\n    ncrs = [(True, inputChar, initRotor)] \n               # [ scramble (notch, char, r)\n                 | r <- rotors\n                 | (notch, char, rotor') <- ncrs\n                 ]\n    rotors' = tail [ r | (_, _, r) <- ncrs ]\n    (_, outputChar, _) = ncrs ! 0\n\n\/\/ Following the signal through a single rotor, forward and backward\nsubstFwd, substBwd : (Permutation, Char) -> Char\nsubstFwd (perm, c) = perm @ (c - 'A')\nsubstBwd (perm, c) = invSubst (perm, c)\n\n\/\/ Route the signal back from the reflector, chase through rotors\nbackSignal : {n} (fin n) => ([n]Rotor, Char) -> Char\nbackSignal (rotors, inputChar) = cs ! 0\n  where   cs = [inputChar] # [ substBwd ([ p | (p, _) <- r ], c)\n                             | r <- reverse rotors\n                             | c <- cs\n                             ]\n\n\/\/ The full enigma loop, from keyboard to lamps:\n\/\/ The signal goes through the plugboard, rotors, and the reflector,\n\/\/ then goes back through the sequence in reverse, out of the\n\/\/ plugboard and to the lamps\nenigmaLoop : {n} (fin n) => (Plugboard, [n]Rotor, Reflector, Char) -> ([n]Rotor, Char)\nenigmaLoop (pboard, rotors, refl, c0) = (rotors', c5)\n  where\n    c1 = substFwd (pboard, c0)\n    (rotors', c2) = joinRotors (rotors, c1)\n    c3 = substFwd (refl, c2)\n    c4 = backSignal(rotors, c3)\n    c5 = substBwd (pboard, c4)\n\n\/\/ Construct a machine out of parts\nmkEnigma : {n} (Plugboard, [n]Rotor, Reflector, [n]Char) -> Enigma n\nmkEnigma (pboard, rs, refl, startingPositions) =\n    { plugboard  = pboard\n    , rotors     = [ r <<< (s - 'A')\n                   | r <- rs\n                   | s <- startingPositions\n                   ]\n    , reflector  = refl\n    }\n\n\/\/ Encryption\/Decryption\nenigma : {n, m} (fin n, fin m) => (Enigma n, String m) -> String m\nenigma (m, pt) = tail [ c | (_, c) <- rcs ]\n  where rcs = [(m.rotors, '*')] # \n              [ enigmaLoop (m.plugboard, r, m.reflector, c)\n              | c      <- pt\n              | (r, _) <- rcs\n              ]\n\n\/\/ Decryption is the same as encryption:\n\/\/ dEnigma : {n, m} (fin n, fin m) => (Enigma n, String m) -> String m\ndEnigma = enigma\n\n\n\/\/ Build an example enigma machine:\nplugboard : Plugboard\nplugboard = \"HBGDEFCAIJKOWNLPXRSVYTMQUZ\"\n\nrotor1, rotor2, rotor3 : Rotor\nrotor1 = mkRotor (\"RJICAWVQZODLUPYFEHXSMTKNGB\", \"IO\")\nrotor2 = mkRotor (\"DWYOLETKNVQPHURZJMSFIGXCBA\", \"B\")\nrotor3 = mkRotor (\"FGKMAJWUOVNRYIZETDPSHBLCQX\", \"CK\")\n\nreflector : Reflector\nreflector = \"FEIPBATSCYVUWZQDOXHGLKMRJN\"\n\nmodelEnigma : Enigma 3\nmodelEnigma = mkEnigma (plugboard, [rotor1, rotor2, rotor3], reflector, \"GCR\")\n\n\/* Example run:\n\n   cryptol> :set ascii=on\n   cryptol> enigma  (modelEnigma, \"ENIGMAWASAREALLYCOOLMACHINE\")\n   UPEKTBSDROBVTUJGNCEHHGBXGTF\n   cryptol> dEnigma (modelEnigma, \"UPEKTBSDROBVTUJGNCEHHGBXGTF\")\n   ENIGMAWASAREALLYCOOLMACHINE\n*\/\n\nall: {a, n} (fin n) => (a->Bit) -> [n]a -> Bit\nall fn xs = folds ! 0 where\n    folds = [True] # [ fn x && p | x <- xs\n                                 | p <- folds]\ncheckReflectorFwdBwd : Reflector -> Bit\ncheckReflectorFwdBwd refl = all check ['A' .. 'Z']\n    where check c = substFwd (refl, c) == substBwd (refl, c)\n```"}]}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Simple.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the 'invSubst' function in the given Enigma cipher implementation. The properties should check that 'invSubst' correctly inverts the substitution defined by the given permutation key for all valid input characters. Additionally, specify properties to verify the behavior of 'myrev' as a list reversal function and 'sumAll' as a summation function over sequences. Ensure the properties are suitable for automated checking with Cryptol's :check command."},{"role":"assistant","content":"```cryptol\ntype Char = [8]\ntype Permutation = String 26\n\ninvSubst : (Permutation, Char) -> Char\ninvSubst (key, c) = candidates ! 0\n  where candidates = [0] # [ if c == k then a else p\n                           | k <- key\n                           | a <- ['A' .. 'Z']\n                           | p <- candidates\n                           ]\n\nmyrev : {n,a} (fin n) => [n+1][a] -> [n+1][a]\nmyrev xs = [ xs!i | i <- [ 0 .. n] ]\n\nsumAll xs = ys ! 0\n    where ys = [0] # [x+y | x <- xs | y <- ys]\n\n\/*\nsimpleRec : {n,a} (fin n) => [n]a -> a\nsimpleRec xs = ret\n    where\n        (_,ret) = iters ! 0\n        iters = [ (1,xs@0) ] #\n                    [ (i,x) | x <- xs\n                            | (i, _) <- iters ]\n\njoinRotors : {n} (fin n) => [n]() -> [n]()\njoinRotors rotors = rotors'\n  where\n    ncrs = [(True, ())]\n               # [ (notch, r)\n                 | r <- rotors\n                 | (notch, _) <- ncrs\n                 ]\n    rotors' = tail [ r | (_, r) <- ncrs ]\n\n*\/\n```"}]}
{"filename":"cryptol\/examples\/funstuff\/FoxChickenCorn.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that any sequence of BankState transitions starting from 'startState' and ending at 'doneState' represents a valid solution to the Fox, Chicken, and Corn river crossing puzzle. The properties should ensure that each move is valid according to the puzzle rules (no carnage, farmer moves correctly, and conservation of items) and that the entire sequence constitutes a valid move sequence from start to finish."},{"role":"assistant","content":"```cryptol\nmodule FoxChickenCorn where\n\ntype OneBank = [4]\ntype BankState =\n    {left : OneBank\n    ,right: OneBank\n    }\n\nstartState      = { left = farmer || chicken || corn || fox, right = 0x0}\ndoneState       = { left = 0x0, right = farmer || chicken || corn || fox}\n\nfarmer  = 0x1\nchicken = 0x2\ncorn    = 0x4\nfox     = 0x8\n\n\/\/ To see this work, try:\n\/\/ :sat solutionInNmoves : [6]BankState -> Bit\n\nsolutionInNmoves : {n} (fin n) => [n] BankState -> Bit\nproperty solutionInNmoves states = validMoveSequence ([startState] # states # [doneState])\n\nvalidMoveSequence : {n} (fin n, n >= 1) => [n] BankState -> Bit\nvalidMoveSequence states = all [validMove a b\n                               | a <- states\n                               | b <- drop`{1} states]\n\n\/\/ Two states represent a valid move if they are both valid states (no carnage)\n\/\/ and that whatever moved followed the rules\nvalidMove : BankState -> BankState -> Bit\nvalidMove b b' = validState b && validState b'\n                 && stuffOnlyMovedWithFarmer b b'\n\nstuffOnlyMovedWithFarmer : BankState -> BankState -> Bit\nstuffOnlyMovedWithFarmer b b' =\n    if farmerHere b.left\n    then farmerHere b'.right && moveFollowsRules b.left b'.right (b'.right - b.right)\n    else farmerHere b'.left  && moveFollowsRules b.right b'.left (b'.left - b.left)\n\n\/\/ things can't move without the farmer, and the farmer can carry at most one thing\nmoveFollowsRules fromBank toBank whatMoved = farmerMoved && atMostOneObjectMoved where\n    farmerMoved = (whatMoved && farmer) == farmer\n    atMostOneObjectMoved = popCount (whatMoved && ~farmer) <= 1\n\n\/\/ \"conservation of items\" rule - nothing spontaneously disappears\ncompleteState : BankState -> Bit\ncompleteState b = (b.left ^ b.right) == 0xf\n\n\/\/ both banks are \"carnage-free\"\nvalidState : BankState -> Bit\nvalidState bs = completeState bs && validBank bs.left\n                && validBank bs.right && completeState bs\n\nvalidBank : OneBank -> Bit\nvalidBank b = farmerHere b || (~(foxWithChicken b) && ~(chickenWithCorn b))\n\nfarmerHere : OneBank -> Bit\nfarmerHere b = (b && farmer) > 0\n\nchickenWithCorn : OneBank -> Bit\nchickenWithCorn b = (b && (corn || chicken)) == (corn || chicken)\n\nfoxWithChicken : OneBank -> Bit\nfoxWithChicken b = (b && (fox || chicken)) == (fox || chicken)\n\nall : {n} (fin n) => [n] -> Bit\nall xs = xs == ~zero\n\n\/\/ \"population count\" - how many bits are on\npopCount : {a} (fin a, a >= 1) => [a] -> [width a]\npopCount bs = ic ! 0 where\n    ic = [0] # [ if elt then prev + 1 else prev | elt <- bs | prev <- ic]\n\ntype StringRep = [7][8]\ntype DirRep = [5][8]\nfarmerString  = \"farmer \"\nchickenString = \"chicken\"\ncornString    = \"corn   \"\nfoxString     = \"fox    \"\nnoString      = \"       \"\n\nppArray = [farmerString, chickenString, cornString, foxString]\n\nppBits : [4] -> [4]StringRep\nppBits s =  [ if b then ppArray!i else noString\n            | b <- s\n            | i <- [0 ...]:[_][4] ]\n\n\/\/ takes a sequence of states and derives what moved, and in which direction for each transition\nextractMoves : {a} [a+1]BankState -> [a](DirRep, [4]StringRep)\nextractMoves bankStates = [ getMove b b' | b <- bankStates | b' <- drop`{1} bankStates ] where\n    getMove start end = ( dirString, thingsString thingsMoved ) where\n        dirString = if farmerHere start.left then \" --> \" else \" <-- \"\n        thingsMoved = if farmerHere start.left\n                      then end.right - start.right\n                      else end.left - start.left\n        thingsString bits = ppBits bits\n\n\/\/ fcc> :sat solutionInNmoves : [6]BankState -> Bit\n\/\/ solutionInNmoves : [6]BankState -> Bit [{left = 12, right = 3},\n\/\/                                      {left = 13, right = 2}, {left = 4, right = 11},\n\/\/                                      {left = 7, right = 8}, {left = 2, right = 13},\n\/\/                                      {left = 3, right = 12}] = True\n\n\/\/ pretty printing: extractMoves ([startState] # [{left = 12, right = 3},{left = 13, right = 2}, {left = 4, right = 11}, {left =     7, right = 8}, {left = 2, right = 13}, {left = 3, right = 12}] # [doneState])\n\/\/ [(\" --> \", [\"       \", \"       \", \"chicken\", \"farmer \"]), \/\/ the farmer takes the chicken right\n\/\/  (\" <-- \", [\"       \", \"       \", \"       \", \"farmer \"]), \/\/ farmer goes back alone\n\/\/  (\" --> \", [\"fox    \", \"       \", \"       \", \"farmer \"]), \/\/ farmer takes the fox across\n\/\/  (\" <-- \", [\"       \", \"       \", \"chicken\", \"farmer \"]), \/\/ brings the chicken back\n\/\/  (\" --> \", [\"       \", \"corn   \", \"       \", \"farmer \"]), \/\/ takes the corn over\n\/\/  (\" <-- \", [\"       \", \"       \", \"       \", \"farmer \"]), \/\/ goes back alone\n\/\/  (\" --> \", [\"       \", \"       \", \"chicken\", \"farmer \"])] \/\/ brings the chicken over, all done\n```"}]}
{"filename":"cryptol\/examples\/funstuff\/Coins.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the coinPuzzle function. The properties should check that the total number of coins is exactly 30 and that their combined value equals 109 cents, using the coinCount and coinSum functions. Include properties that ensure the inputs are within valid bounds and that the puzzle constraints hold true for all valid inputs."},{"role":"assistant","content":"```cryptol\n\/\/ The puzzle goes like this:\n\/\/ You've got 30 coins that add up to $1.09 - what are they?\ncoinPuzzle : [10] -> [10] -> [10] -> [10] -> Bit\ncoinPuzzle a b c d = (coinCount a b c d 30) \/\\ (coinSum a b c d 109)\n\ncoinSum : [10] -> [10] -> [10] -> [10] -> [10] -> Bit\ncoinSum   a b c d s = (a + 5 * b + 10 * c + 25 * d) == s\n\ncoinCount : [10] -> [10] -> [10] -> [10] -> [10] -> Bit\ncoinCount a b c d s = (((a + b + c + d) == s) \/\\                        (a <= s \/\\ b <= s \/\\ c <= s \/\\ d <= s)) \/\/ run it like this:\n\/\/ :set satNum = all\n\/\/ :sat coinPuzzle\n\/\/ coinPuzzle 19 7 3 1 = True\n\/\/ coinPuzzle 24 1 3 2 = True\n\/\/ coinPuzzle 14 13 3 0 = True\n\/\/ coinPuzzle 19 4 7 0 = True\n```"}]}
{"filename":"cryptol\/examples\/funstuff\/marble.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that any sequence of moves starting from the 'start' board state and ending at the 'second' board state consists only of valid moves according to the 'validMove' predicate, and that the board states remain valid throughout the sequence. Include properties that check the correctness of 'validRowJump', 'validColJump', and 'validMoveSequence' functions as defined in the marble solitaire puzzle specification."},{"role":"assistant","content":"```cryptol\n\/\/ The classic \"marble jumping\" puzzle\n\/\/ see: http:\/\/en.wikipedia.org\/wiki\/Peg_solitaire\n\/\/ this is the \"European\" variation\n\ntype Board = [7][7]Bit\n\nall : {n} (fin n) => [n] -> Bit\nall xs = xs == ~zero\n\npopCount : {a} (fin a, a >= 1) => [a] -> [width a]\npopCount bs = ic ! 0 where\n    ic = [0] # [ if elt then prev + 1 else prev | elt <- bs | prev <- ic]\n\nposns : Board\nposns = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nstart : Board\nstart = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,False,True,True,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nfirst : Board\nfirst = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,False,False,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nsecond : Board\nsecond = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,False,True],\n         [True,True,True,True,False,True,True],\n         [False,True,True,True,False,True,False],\n         [False,False,True,True,True,False,False]]\n\ngoal : Board\ngoal = [[False,False,False,False,False,False,False],\n        [False,False,False,True,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False]]\n\nvalidBoard : Board -> Bit\nvalidBoard b = join (b && ~posns) == zero\n\nvalidRowJump : Board -> Board -> Bit\nvalidRowJump a a' = validBoard a\n                 \/\\ validBoard a'\n                 \/\\ validRowMove (differentRow a a')\n\ndifferentRow : Board -> Board -> ([7], [7])\ndifferentRow a a' = rows ! 0\n    where rows = [(0b0000000,0b0000000)]\n               # [ if row != row' then (row,row') else old\n                 | row <- a\n                 | row' <- a'\n                 | old <- rows ]\n\nvalidRowMove : ([7], [7]) -> Bit\nvalidRowMove (r, r') = (xors == 0b0000111 \\\/\n                        xors == 0b0001110 \\\/\n                        xors == 0b0011100 \\\/\n                        xors == 0b0111000 \\\/\n                        xors == 0b1110000)\n                      \/\\ (\n                        rxors == 0b0000011 \\\/\n                        rxors == 0b0000110 \\\/\n                        rxors == 0b0001100 \\\/\n                        rxors == 0b0011000 \\\/\n                        rxors == 0b0110000 \\\/\n                        rxors == 0b1100000)\n    where xors = r ^ r'\n          rxors = r && rxors\n\nvalidColJump : Board -> Board -> Bit\nvalidColJump a a' = validRowJump (transpose a) (transpose a')\n\nvalidMove : Board -> Board -> Bit\nvalidMove a a' = validRowJump a a' \\\/ validColJump a a'\n\nvalidMoveSequence : {n} (fin n, n >= 1) => [n] Board -> Bit\nvalidMoveSequence moves = all [validMove a b | a <- moves | b <- drop`{1} moves]\n\nsolutionInNmoves : {n} (fin n) => [n] Board -> Bit\nproperty solutionInNmoves ms = validMoveSequence ([start] # ms # [second])\n```"}]}
{"filename":"cryptol\/examples\/SuiteB_FFI\/SuiteB_FFI.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the AES key schedule functions (aes128EncryptSchedule, aes128DecryptSchedule, aes192EncryptSchedule, aes192DecryptSchedule, aes256EncryptSchedule, aes256DecryptSchedule) correctly implement the key expansion as specified in FIPS 197. Include properties that check the equivalence of encryption and decryption schedules where applicable, and verify that the aesEncryptBlock and aesDecryptBlock functions correctly invert each other for all valid keys and plaintext inputs."},{"role":"assistant","content":"```cryptol\nmodule SuiteB_FFI where\n\nimport SuiteB as SB\n\n\/***** AES ******\/\n\n\/**\n * Key schedule parameter setting for AES-128\n *\/\ntype AES128 = SB::AES128\n\n\/**\n * Key schedule parameter setting for AES-192\n *\/\ntype AES192 = SB::AES192\n\n\/**\n * Key schedule parameter setting for AES-256\n *\/\ntype AES256 = SB::AES256\n\n\/**\n * Element of an AES key schedule for use in a particular round\n *\/\ntype AESRoundKey = SB::AESRoundKey\n\n\/**\n * Expanded encryption key schedule for AES\n *\/\ntype AESEncryptKeySchedule k = SB::AESEncryptKeySchedule k\n\n\/**\n * Expanded decryption key schedule for AES\n *\/\ntype AESDecryptKeySchedule k = SB::AESDecryptKeySchedule k\n\n\/**\n * Encryption key expansion for AES-128.\n *   See FIPS 197, section 5.2.\n *\/\naes128EncryptSchedule : [128] -> AESEncryptKeySchedule AES128\naes128EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt128 (split key)\n    else SB::aes128EncryptSchedule\n\n\/**\n * Decryption key expansion for AES-128, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes128DecryptSchedule : [128] -> AESDecryptKeySchedule AES128\naes128DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt128 (split key)\n    else SB::aes128DecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-128.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes128Schedules : [128] -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\naes128Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt128 (split key)\n    else SB::aes128Schedules\n\n\/**\n * Encryption key expansion for AES-192.\n *   See FIPS 197, section 5.2.\n *\/\naes192EncryptSchedule : [192] -> AESEncryptKeySchedule AES192\naes192EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt192 (split key)\n    else SB::aes192EncryptSchedule\n\n\/**\n * Decryption key expansion for AES-192, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes192DecryptSchedule : [192] -> AESDecryptKeySchedule AES192\naes192DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt192 (split key)\n    else SB::aes192DecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-192.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes192Schedules : [192] -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\naes192Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt192 (split key)\n    else SB::aes192Schedules\n\n\n\/**\n * Encryption key expansion for AES-256.\n *   See FIPS 197, section 5.2\n *\/\naes256EncryptSchedule : [256] -> AESEncryptKeySchedule AES256\naes256EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt256 (split key)\n    else SB::aes256EncryptSchedule\n\n\/**\n * Decryption key expansion for AES-256, for use in the \"equivalent inverse cypher\".\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes256DecryptSchedule : [256] -> AESDecryptKeySchedule AES256\naes256DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt256 (split key)\n    else SB::aes256DecryptSchedule\n\n\/**\n * Encryption and decryption key schedules for AES-256.\n * If you will need both schedules, it is slightly more efficient\n * to call this function than to compute the two schedules separately.\n *   See FIPS 197, sections 5.2 and 5.3.5.\n *\/\naes256Schedules : [256] -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\naes256Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt256 (split key)\n    else SB::aes256Schedules\n\n\/**\n * AES block encryption algorithm.\n *   See FIPS 197, section 5.1.\n *\/\naesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]\naesEncryptBlock =\n  if aesniSupported\n    then \\schedule plaintext -> join (aesniEncryptBlock schedule (split plaintext))\n    else SB::aesEncryptBlock\n\n\/**\n * AES block decryption algorithm, via the \"equivalent inverse cypher\".\n *   See FIPS 197, section 5.3.5.\n *\/\naesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]\naesDecryptBlock =\n  if aesniSupported\n    then \\schedule ciphertext -> join (aesniDecryptBlock schedule (split ciphertext))\n    else SB::aesDecryptBlock\n\nprivate\n  foreign checkAESNISupported : () -> Bit\n  foreign aesniExpandEncrypt128 : [16][8] -> AESEncryptKeySchedule AES128\n  foreign aesniExpandDecrypt128 : [16][8] -> AESDecryptKeySchedule AES128\n  foreign aesniExpandEncryptDecrypt128 : [16][8]\n    -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\n  foreign aesniExpandEncrypt192 : [24][8] -> AESEncryptKeySchedule AES192\n  foreign aesniExpandDecrypt192 : [24][8] -> AESDecryptKeySchedule AES192\n  foreign aesniExpandEncryptDecrypt192 : [24][8]\n    -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\n  foreign aesniExpandEncrypt256 : [32][8] -> AESEncryptKeySchedule AES256\n  foreign aesniExpandDecrypt256 : [32][8] -> AESDecryptKeySchedule AES256\n  foreign aesniExpandEncryptDecrypt256 : [32][8]\n    -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\n  foreign aesniEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [16][8] -> [16][8]\n  foreign aesniDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [16][8] -> [16][8]\n\n  aesniSupported = checkAESNISupported ()\n\n\n\/***** SHA2 *****\/\n\n\/**\n * The SHA-224 secure hash algorithm.  See FIPS 180-4, section 6.3.\n *\/\nsha224 = SB::sha224\n\n\/**\n * The SHA-256 secure hash algorithm.  See FIPS 180-4, section 6.2.2.\n *\/\nsha256 = SB::sha256\n\n\/**\n * The SHA-384 secure hash algorithm.  See FIPS 180-4, section 6.5.\n *\/\nsha384 = SB::sha384\n\n\/**\n * The SHA-512 secure hash algorithm.  See FIPS 180-4, section 6.4.\n *\/\nsha512 = SB::sha512\n```"}]}
{"filename":"cryptol\/examples\/contrib\/mkrand.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and involutive nature of the randXOR function in the MKRAND module. Specifically, specify properties that confirm randXOR with the canonical seed encrypts and decrypts a message correctly (as in otp_encdec), and that applying randXOR twice with the same seed returns the original message for arbitrary message lengths (as in otp_involutive)."},{"role":"assistant","content":"```cryptol\nmodule MKRAND where\n\ntype Seg   = [0x80]\ntype Field = [0x80]Seg\n\n\/* Canonical seed - a segment with a single True bit in the center *\/\nseedUnit:Seg\nseedUnit = (0 :[63]) # (1:[1]) # (0:[64])\n\n\n\/*\n *  Field - Unfold an application of Rule 30 to a seed\n *\/\nfield: Seg -> [inf]Seg\nfield s = new\n  where\n    new = [s] # [ rule30 row | row <- new]\n    rule30 r = [ a ^ (b || c) | a <- r >>> 1\n                              | b <- r\n                              | c <- r <<< 1\n               ]\n\n\n\/* SHA30 - Use the input segment as the seed, generate two square fields,\n * keep the center column of the second.\n *\/\nsha30: Seg -> Seg\nsha30 s = take`{0x80} (drop`{0x80} [ r @ ((((length r) \/ 2)-1):[8]) | r <- field s])\n\n\n\/*\n * RAND - Seed XOR (SHA30 Seed)\n *\/\nrands : Seg -> [inf]Seg\nrands s = rest\n  where\n     rand p = p ^ (sha30 p)\n     rest = [rand s] # [rand x | x <- rest]\n\n\n\/* Break segments into bytes *\/\nrandBytes : Seg -> [inf][8]\nrandBytes s = groupBy`{8} (join (rands s))\n\n\n\/* XOR a byte string into a random byte string, using the given seed *\/\nrandXOR : {n} Seg ->  String n -> String n\nrandXOR seed src = [s ^ r | s <- src\n                          | r <- randBytes seed\n                   ]\n\n\/* OTP example *\/\n\nproperty otp_encdec =\n     randXOR seedUnit \"Deus Ex Machina\" == c\n  \/\\ randXOR seedUnit c == \"Deus Ex Machina\"\n  where c = [ 0x28, 0x2b, 0x2c, 0xfa\n            , 0x92, 0xca, 0xb3, 0xcb\n            , 0xed, 0x50, 0xc2, 0x1b\n            , 0x11, 0x0e, 0x70]\n\notp_involutive : {len} (fin len) => String len -> Bit\notp_involutive msg = randXOR seedUnit (randXOR seedUnit msg) == msg\n\nproperty otp_involutive_32 msg = otp_involutive (msg : String 32)\n```"}]}
{"filename":"cryptol\/examples\/contrib\/EvenMansour.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the Even-Mansour encryption and decryption functions are inverses of each other for all valid keys and messages. Include properties that confirm the permutation F is valid and that F' is its correct inverse. Also, specify properties to check the uniqueness and correctness of the generated permutation."},{"role":"assistant","content":"```cryptol\n\/*\n  Author : Sean Weaver <saweave@tycho.ncsc.mil>\n  This is a rough Cryptol specification of Even-Mansour:\n\n  Even, S., Mansour, Y.: A Construction of a Cipher from a Single\n  Pseudorandom Permutation. J. Cryptology 10 (3) (1997) 151\u2013162\n*\/\n\n\/** Pick some permutation F (here we select one at random) *\/\nF = (generate_random_permutation 1942611697)\n\nproperty is_a_permutation a = (unique a) \/\\ (leq a (length(a)-1))\n\/\/ Main> is_a_permutation (F:[10][4])\n\/\/ True\n\n\/** Calculate F inverse *\/\nF' = inverse_permutation F\n\nproperty is_inverse_permutation x a a' = ((x@@a)@@a') == x\n\/\/ Main> is_inverse_permutation ([0..9]:[_][4]) (F:[10]_) (F':[10]_)\n\/\/ True\n\n\/**\n * The encryption (or cryptogram) E_K(M) of a message M in {0,1}^n by\n * the key K = <K_1, K_2>, is performed by E\n *\/\nE : {n} (fin n, n >= 1, width n >= width(n-1)) => ([n], [n]) -> [n] -> [n]\nE (K1, K2) M =  (M^K1)@@F ^ K2\n\n\/**\n * The decryption of a cryptogram C in {0,1}^n, is performed by D\n *\/\nD : {n} (fin n, n >= 1, width n >= width(n-1)) => ([n], [n]) -> [n] -> [n]\nD (K1, K2) C =  (C^K2)@@F' ^ K1\n\n\/**\n * It is easy to verify that for every M in {0,1}^n and K in {0,1}^2n,\n * the following identity holds D_K(E_K(M)) = M, i.e. D_K decrypts\n * messages that were encrypted using E_K.\n *\/\nproperty E_and_D_are_inverses K M = (D K (E K M)) == M\n\n\n\/******* Utilities *******\/\n\nswap : {a, b} (fin a, a >= 1) => [a]b -> [width(a-1)] -> [width(a-1)] -> [a]b\nswap xs a b = [ if(i == a) then xs@b\n                 |(i == b) then xs@a\n                else xs@i\n              | i <- [0 .. a-1] ]\n\ngenerate_random_permutation : {a} (fin a, a >= 1, width a >= width(a-1)) => [256] -> [a][width(a-1)]\ngenerate_random_permutation seed = pss!0\n  where\n    indices = [ take `{width(a-1)} (b % `a) | b <- (random seed) : [a][width a] ]\n    pss = [ [0 .. a-1] ] # [ swap ps a b | ps <- pss | a <- [0 .. a-1] | b <- indices ]\n\nunique : {a, b} (fin a, fin b, a>=1) => [a][b] -> Bit\nunique xs = [ exist x (i+1) | x <- xs | i <- [0...] ] == 0\n  where exist : [b] -> [width a] -> Bit\n        exist x i = if(i>=`a) then False\n                    else if(x==(xs@i)) then True\n                    else exist x (i+1)\n\nleq xs a = [ x <= a | x <- xs ] == ~0\n\nindex_of : {a, b} (fin a, a>=1, Cmp b) => [a]b -> b -> [width(a-1)]\nindex_of xs a = (ret!0).1\n  where ret = [(False, 0)] # [ if(xs@i == a) then (True, i) else r\n                             | i <- [0 .. a-1 ]\n                             | r <- ret ]\n\ninverse_permutation : {a} (fin a, a >= 1) => [a][width(a-1)] -> [a][width(a-1)]\ninverse_permutation perm = [ index_of perm i | i <- [0 .. a-1 ] ]\n```"}]}
{"filename":"cryptol\/examples\/contrib\/A51.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the A51 stream cipher implementation in the given code. Specifically, write properties that check the keystream output against known test vectors and verify the behavior of the LFSR step functions. Include properties that ensure the majority function and conditional clocking logic are correctly implemented according to the A5\/1 specification."},{"role":"assistant","content":"```cryptol\nA51_stream : [19] -> [22] -> [23] -> [inf]\nA51_stream R1 R2 R3 = R1s ^ R2s ^ R3s\n  where\n    (R1s, R1f) = lfsrki <| x^^19 + x^^18 + x^^17 + x^^14 + 1 |>  R1c R1\n    (R2s, R2f) = lfsrki <| x^^22 + x^^21 + 1 |>                  R2c R2\n    (R3s, R3f) = lfsrki <| x^^23 + x^^22 + x^^21 + x^^8 + 1 |>   R3c R3\n    majvs = [ majv (r1@8) (r2@10) (r3@10) | r1 <- R1f | r2 <- R2f | r3 <- R3f ]\n    R1c = [ r1@8 == m | r1 <- R1f | m <- majvs ]\n    R2c = [ r2@10 == m | r2 <- R2f | m <- majvs ]\n    R3c = [ r3@10 == m | r3 <- R3f | m <- majvs ]\n\ntype N = 128\nA51 : ([19], [22], [23]) -> [N]Bit\nA51(reg1, reg2, reg3) = keystream\n  where\n    keystream = take`{N} (A51_stream reg1 reg2 reg3)\n\nlfsrki_step : {d} (fin d, d >=1) => [d+1] -> Bit -> [d] -> [d]\nlfsrki_step poly cond fill = fill'\n where\n   feedback_bit = if(poly@0) then prefix (^) (reverse([False]#fill) && poly)\n                             else error \"polynomial does not have high-bit set.\"\n   fill' = if cond then [feedback_bit]#(take fill) else fill\n\nlfsrki : {d} (fin d, d >=1) => [d+1] -> [inf] -> [d] -> ([inf], [inf][d])\nlfsrki poly conds init = (stream, fills)\n  where\n    lfsrki' = lfsrki_step poly\n    fills = [init] # [ lfsrki' c f | c <- conds | f <- fills]\n    stream = [ f!0 | f <- fills ]\n\n\nprefix f xs = ys!0\n  where ys = [xs@0] # [ f y x | y <- ys | x <- tail xs ]\n\nmajv a b c = (a && b) || (a && c) || (b && c)\n\n\/***********************************************************************\/\n\niv1 = 0b1010111011101011101\niv2 = 0b1010111011101010101110\niv3 = 0b10100000111100110011011\n\ntest_keystream = 0b00100100111010001110101110101100010100110111110101000101110000011101000111110101010000010011001111110101110001011010100000010001\n\nproperty A51_correct = (A51(iv1, iv2, iv3)) == test_keystream\nproperty A51_search x y z = A51(x,y,z) == test_keystream\n```"}]}
{"filename":"cryptol\/examples\/contrib\/RC4.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the RC4 key scheduling algorithm (ksa) and keystream generation (ks) produce outputs matching the given test vectors for the keys \"Key\", \"Wiki\", and \"Secret\". Include properties that check the correctness of the swap function and the iterative steps in ksa_step and ks_step, ensuring the internal state transformations conform to the RC4 specification."},{"role":"assistant","content":"```cryptol\nswap : [256][8] -> [8] -> [8] -> [256][8]\nswap s i j = [ s @ (if n == i then j else\n                    if n == j then i else\n                    n)\n             | n <- [0..255]\n             ]\n\nksa_step : [inf][8] -> [8] -> [8] -> [256][8] -> ([8],[256][8])\nksa_step key i j s = (j', swap s i j')\n where j' = j + s@i + key@i\n\nksa : [inf][8] -> [256][8]\nksa key = (go ! 0).1 where\n go : [257]([8],[256][8])\n go = [(0,[0..255])] # [ ksa_step key i j s\n                       | i <- [0..255]\n                       | (j,s) <- go\n                       ]\n\nks_step : [8] -> [8] -> [256][8] -> ([8],[256][8],[8])\nks_step i j s = (j',s',s@(s@i + s@j'))\n where j' = j + s@i\n       s' = swap s i j'\n\nks key = [ k | (_,_,k) <- drop`{1} go ] where\n go = [(0,ksa key',0)] # [ ks_step i j s\n                         | i <- loop\n                         | (j,s,k) <- go\n                         ]\n key' = key # key'\n loop = [1..255] # [0] # loop\n\n\/\/\/\/\/\/\/\n\/\/ \"Test vectors\" from wikipedia\n\nproperty test1 = take (ks \"Key\") == [0xEB,0x9F,0x77,0x81,0xB7,0x34,0xCA,0x72,0xA7,0x19]\nproperty test2 = take (ks \"Wiki\") == [0x60,0x44,0xDB,0x6D,0x41,0xB7]\nproperty test3 = take (ks \"Secret\") == [0x04,0xD4,0x6B,0x05,0x3C,0xA8,0x7B,0x59]\n```"}]}
{"filename":"cryptol\/examples\/contrib\/MISTY1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the MISTY1 cipher implementation satisfies the correctness property: for any plaintext and key, decrypting the ciphertext produced by encryption returns the original plaintext. Include properties that check the key schedule correctness and the invertibility of the encryption and decryption functions."},{"role":"assistant","content":"```cryptol\n\/*\n * Cryptol spec of the MISTY1 cipher. Based on RFC 2994, available at\n * https:\/\/tools.ietf.org\/rfc\/rfc2994.txt\n *\n * Author: Adrian Herrera\n *\/\n\nmodule MISTY1 where\n\n\/\/\n\/\/ Key scheduling part\n\/\/\n\nkeySchedule : [16][8] -> [32][16]\nkeySchedule K = EK_1 # EK_2 # EK_3 # EK_4\n    where EK_1 = split (join K)\n          EK_2 = [ FI ek_1 ek_1_shifted\n                 | ek_1         <- EK_1\n                 | ek_1_shifted <- EK_1 <<< 1\n                 ]\n          EK_3 = [extend (drop`{7} ek_2) | ek_2 <- EK_2]\n          EK_4 = [extend (take`{7} ek_2) | ek_2 <- EK_2]\n\n\/\/\n\/\/ Data randomizing part\n\/\/\n\nFO : [32] -> [8] -> [32][16] -> [32]\nFO FO_IN k EK = (FO_OUT ! 0).1 # (FO_OUT ! 0).0\n    where FO_OUT = [(take FO_IN, drop FO_IN)] # [ f t0 t1\n                                                | f        <- funcs\n                                                | (t0, t1) <- FO_OUT\n                                                ]\n          \/\/ t0, t1 as 16-bit integers\n          funcs : [_]([16] -> [16] -> ([16], [16]))\n          funcs = [\\t0 t1 -> (t0 ^ (EK @ k), t1),\n                   \\t0 t1 -> (FI t0 (EK @ ((k + 5) % 8 + 8)), t1),\n                   \\t0 t1 -> (t0 ^ t1, t1),\n                   \\t0 t1 -> (t0, t1 ^ (EK @ ((k + 2) % 8))),\n                   \\t0 t1 -> (t0, FI t1 (EK @ ((k + 1) % 8 + 8))),\n                   \\t0 t1 -> (t0, t1 ^ t0),\n                   \\t0 t1 -> (t0 ^ EK @ ((k + 7) % 8), t1),\n                   \\t0 t1 -> (FI t0 (EK @ ((k + 3) % 8 + 8)), t1),\n                   \\t0 t1 -> (t0 ^ t1, t1),\n                   \\t0 t1 -> (t0, t1 ^ EK @ ((k + 4) % 8))\n                  ]\n\nFI : [16] -> [16] -> [16]\nFI FI_IN FI_KEY = (FI_OUT ! 0).1 # (FI_OUT ! 0).0\n    where FI_OUT = [(take FI_IN, drop FI_IN)] # [ f d9 d7\n                                                | f        <- funcs\n                                                | (d9, d7) <- FI_OUT\n                                                ]\n          \/\/ d9 as 9-bit integer\n          \/\/ d7 as 7-bit integer\n          funcs : [_]([9] -> [7] -> ([9], [7]))\n          funcs = [\\d9 d7 -> ((S9 @ d9) ^ (extend d7), d7),\n                   \\d9 d7 -> (d9, drop (extend (S7 @ d7) ^ d9)),\n                   \\d9 d7 -> (d9, d7 ^ drop (FI_KEY >> 9)),\n                   \\d9 d7 -> (d9 ^ drop FI_KEY, d7),\n                   \\d9 d7 -> ((S9 @ d9) ^ (extend d7), d7)\n                  ]\n\nS7 : [_][7]\nS7 = [27,  50,  51,  90,  59,  16,  23,  84,  91,  26, 114, 115, 107,\n      44, 102,  73,  31,  36,  19, 108,  55,  46,  63,  74,  93,  15,\n      64,  86,  37,  81,  28,   4,  11,  70,  32,  13, 123,  53,  68,\n      66,  43,  30,  65,  20,  75, 121,  21, 111,  14,  85,   9,  54,\n     116,  12, 103,  83,  40,  10, 126,  56,   2,   7,  96,  41,  25,\n      18, 101,  47,  48,  57,   8, 104,  95, 120,  42,  76, 100,  69,\n     117,  61,  89,  72,   3,  87, 124,  79,  98,  60,  29,  33,  94,\n      39, 106, 112,  77,  58,   1, 109, 110,  99,  24, 119,  35,   5,\n      38, 118,   0,  49,  45, 122, 127,  97,  80,  34,  17,   6,  71,\n      22,  82,  78, 113,  62, 105,  67,  52,  92,  88, 125]\n\nS9 : [_][9]\nS9 = [451, 203, 339, 415, 483, 233, 251,  53, 385, 185, 279, 491, 307,\n        9,  45, 211, 199, 330,  55, 126, 235, 356, 403, 472, 163, 286,\n       85,  44,  29, 418, 355, 280, 331, 338, 466,  15,  43,  48, 314,\n      229, 273, 312, 398,  99, 227, 200, 500,  27,   1, 157, 248, 416,\n      365, 499,  28, 326, 125, 209, 130, 490, 387, 301, 244, 414, 467,\n      221, 482, 296, 480, 236,  89, 145,  17, 303,  38, 220, 176, 396,\n      271, 503, 231, 364, 182, 249, 216, 337, 257, 332, 259, 184, 340,\n      299, 430,  23, 113,  12,  71,  88, 127, 420, 308, 297, 132, 349,\n      413, 434, 419,  72, 124,  81, 458,  35, 317, 423, 357,  59,  66,\n      218, 402, 206, 193, 107, 159, 497, 300, 388, 250, 406, 481, 361,\n      381,  49, 384, 266, 148, 474, 390, 318, 284,  96, 373, 463, 103,\n      281, 101, 104, 153, 336,   8,   7, 380, 183,  36,  25, 222, 295,\n      219, 228, 425,  82, 265, 144, 412, 449,  40, 435, 309, 362, 374,\n      223, 485, 392, 197, 366, 478, 433, 195, 479,  54, 238, 494, 240,\n      147,  73, 154, 438, 105, 129, 293,  11,  94, 180, 329, 455, 372,\n       62, 315, 439, 142, 454, 174,  16, 149, 495,  78, 242, 509, 133,\n      253, 246, 160, 367, 131, 138, 342, 155, 316, 263, 359, 152, 464,\n      489,   3, 510, 189, 290, 137, 210, 399,  18,  51, 106, 322, 237,\n      368, 283, 226, 335, 344, 305, 327,  93, 275, 461, 121, 353, 421,\n      377, 158, 436, 204,  34, 306,  26, 232,   4, 391, 493, 407,  57,\n      447, 471,  39, 395, 198, 156, 208, 334, 108,  52, 498, 110, 202,\n       37, 186, 401, 254,  19, 262,  47, 429, 370, 475, 192, 267, 470,\n      245, 492, 269, 118, 276, 427, 117, 268, 484, 345,  84, 287,  75,\n      196, 446, 247,  41, 164,  14, 496, 119,  77, 378, 134, 139, 179,\n      369, 191, 270, 260, 151, 347, 352, 360, 215, 187, 102, 462, 252,\n      146, 453, 111,  22,  74, 161, 313, 175, 241, 400,  10, 426, 323,\n      379,  86, 397, 358, 212, 507, 333, 404, 410, 135, 504, 291, 167,\n      440, 321,  60, 505, 320,  42, 341, 282, 417, 408, 213, 294, 431,\n       97, 302, 343, 476, 114, 394, 170, 150, 277, 239,  69, 123, 141,\n      325,  83,  95, 376, 178,  46,  32, 469,  63, 457, 487, 428,  68,\n       56,  20, 177, 363, 171, 181,  90, 386, 456, 468,  24, 375, 100,\n      207, 109, 256, 409, 304, 346,   5, 288, 443, 445, 224,  79, 214,\n      319, 452, 298,  21,   6, 255, 411, 166,  67, 136,  80, 351, 488,\n      289, 115, 382, 188, 194, 201, 371, 393, 501, 116, 460, 486, 424,\n      405,  31,  65,  13, 442,  50,  61, 465, 128, 168,  87, 441, 354,\n      328, 217, 261,  98, 122,  33, 511, 274, 264, 448, 169, 285, 432,\n      422, 205, 243,  92, 258,  91, 473, 324, 502, 173, 165,  58, 459,\n      310, 383,  70, 225,  30, 477, 230, 311, 506, 389, 140, 143,  64,\n      437, 190, 120,   0, 172, 272, 350, 292,   2, 444, 162, 234, 112,\n      508, 278, 348,  76, 450]\n\nFL : [32] -> [8] -> [32][16] -> [32]\nFL FL_IN k EK =\n    if isEven k then\n        d0_even # d1_even\n        where d1_even = d1 ^ (d0 && (EK @ (k \/ 2)))\n              d0_even = d0 ^ (d1_even || (EK @ ((k \/ 2 + 6) % 8 + 8)))\n    else\n        d0_odd # d1_odd\n        where d1_odd = d1 ^ (d0 && (EK @ (((k - 1) \/ 2 + 2) % 8 + 8)))\n              d0_odd = d0 ^ (d1_odd || (EK @ (((k - 1) \/ 2 + 4) % 8)))\n    where \/\/ d0 as 16-bit integer\n        d0 : [16]\n        d0 = take FL_IN\n        \/\/ d1 as 16-bit integer\n        d1 : [16]\n        d1 = drop FL_IN\n\nFLINV : [32] -> [8] -> [32][16] -> [32]\nFLINV FL_IN k EK =\n    if isEven k then\n        d0_even # d1_even\n        where d0_even = d0 ^ (d1 || (EK @ ((k \/ 2 + 6) % 8 + 8)))\n              d1_even = d1 ^ (d0_even && (EK @ (k \/ 2)))\n    else\n        d0_odd # d1_odd\n        where d0_odd = d0 ^ (d1 || (EK @ (((k - 1) \/ 2 + 4) % 8)))\n              d1_odd = d1 ^ (d0_odd && (EK @ (((k - 1) \/ 2 + 2) % 8 + 8)))\n    where \/\/ d0 as 16-bit integer\n        d0 : [16]\n        d0 = take FL_IN\n        \/\/ d1 as 16-bit integer\n        d1 : [16]\n        d1 = drop FL_IN\n\n\/\/\n\/\/ Encrypt\/decrypt\n\/\/\n\nmisty1Encrypt : [64] -> [32][16] -> [64]\nmisty1Encrypt P EK = (C ! 0).1 # (C ! 0).0\n    where\n        \/\/ 64-bit plaintext P is divided into the leftmost 32-bit D0 and the\n        \/\/ rightmost 32-bit D1\n        C = [(take P, drop P)] # [ f D0 D1\n                                 | f        <- funcs\n                                 | (D0, D1) <- C\n                                 ]\n        funcs : [_]([32] -> [32] -> ([32], [32]))\n        funcs = [                 \\D0 D1 -> (FL D0 0 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 1 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 0 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 1 EK), D1),\n                                  \\D0 D1 -> (FL D0 2 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 3 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 2 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 3 EK), D1),\n                                  \\D0 D1 -> (FL D0 4 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 5 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 4 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 5 EK), D1),\n                 \/\/ 6 round\n                 \\D0 D1 -> (FL D0 6 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 7 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 6 EK)),\n                 \/\/ 7 round\n                 \\D0 D1 -> (D0 ^ (FO D1 7 EK), D1),\n                 \/\/ final\n                 \\D0 D1 -> (FL D0 8 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 9 EK)\n                ]\n\nmisty1Decrypt : [64] -> [32][16] -> [64]\nmisty1Decrypt C EK = (P ! 0).0 # (P ! 0).1\n    where P = [(drop C, take C)] # [ f D0 D1\n                                   | f        <- funcs\n                                   | (D0, D1) <- P\n                                   ]\n          funcs : [_]([32] -> [32] -> ([32], [32]))\n          funcs = [\\D0 D1 -> (FLINV D0 8 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 9 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 7 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 6 EK)),\n                   \\D0 D1 -> (FLINV D0 6 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 7 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 5 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 4 EK)),\n                   \\D0 D1 -> (FLINV D0 4 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 5 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 3 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 2 EK)),\n                   \\D0 D1 -> (FLINV D0 2 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 3 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 1 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 0 EK)),\n                   \\D0 D1 -> (FLINV D0 0 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 1 EK)\n                  ]\n\n\/\/\n\/\/ Helper functions\n\/\/\n\nextend : {total, n} (fin total, fin n, total >= n) => [n] -> [total]\nextend n = zero # n\n\nisEven : {a} (fin a) => [a] -> Bool\nisEven n = ~(n ! 0)\n\n\/\/\n\/\/ Examples\n\/\/\n\nproperty testMisty1Encrypt = [ misty1Encrypt block EK\n                             | block <- plaintext\n                             ] == ciphertext\n    where EK         = keySchedule key\n          key        = [0x00, 0x11 .. 0xff]\n          plaintext  = [0x0123456789abcdef, 0xfedcba9876543210]\n          ciphertext = [0x8b1da5f56ab3d07c, 0x04b68240b13be95d]\n\nproperty misty1Correct pt key = misty1Decrypt (misty1Encrypt pt EK) EK == pt\n    where EK = keySchedule key\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/Keys.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the Minilock key encoding and decoding functions in the Keys module. Specifically, specify properties that ensure: (1) encoding a public key with encodeID and then decoding it with decodeID returns the original public key and a valid hash check, (2) mkFullLengthID correctly pads or truncates input keys to the fixed MinilockID length, and (3) mkID produces consistent public\/private key pairs matching the expected test vectors. Include properties that relate the testID, testPriv, and testPub values to their computed counterparts to validate known-answer tests."},{"role":"assistant","content":"```cryptol\nmodule Keys where\n\nimport CfrgCurves\nimport Blake2s\nimport SCrypt\nimport Base58\n\ntype MinilockID = [46][8]\n\n\/\/ Given a public key compute the ASCII ID\nencodeID : Public25519 -> MinilockID\nencodeID pub = base58enc (join (pub # [h]))\n  where\n  h = blake2s `{nn=1} pub : [8]\n\ndecodeID : MinilockID -> (Bit,Public25519)\ndecodeID ident = (hComp == hRecv, key)\n where\n  bs    = split (base58dec ident)  : [33][8]\n  hRecv = bs ! 0\n  hComp = blake2s `{nn=1} key      : [8]\n  key   = take bs                  : [32][8]\n\n\/\/ Accept a possibly-short key (base58 is value dependent encoding)\n\/\/ and expand it to the full, fixed, size.\nmkFullLengthID : {n} (46 >= n, n>= 1) => [n][8] -> MinilockID\nmkFullLengthID n = drop (['1' | _ <- [0..45] : [_][8]]  # n)\n\nmkID : {passBytes, saltBytes}\n       ( fin passBytes, fin saltBytes\n       , 64 >= width passBytes\n       , 32 >= width (4*saltBytes)\n       )\n    => [passBytes][8] -> [saltBytes][8] -> (MinilockID,Private25519)\nmkID pw email = (encodeID pub,priv)\n  where\n  \/\/ XXX wait for cryptol 2.3: priv = SCrypt `{N=2^^17,r=8} (split (blake2s `{nn=32} pw)) email\n  priv : Private25519\n  priv = SCrypt `{N=2^^1,r=8} (split (blake2s `{nn=32} pw)) email\n  \/\/ XXX we can't interpret N=2^^17 so this N value is a place holder...\n  pub  = Curve25519 priv basePoint25519\n\n\/\/ XXX we can not run these tests in the cryptol interpreter, SCrypt is too expensive.\ntestPass = \"some bears eat all the honey in the jar\"\ntestEmail = \"example@example.com\"\n\ntestID : MinilockID\ntestID = mkFullLengthID \"28ZvW9rqRqvqpFTtHnusUntRqrxb4qqZAaNAd3QsqjSsXq\"\n\ntestID_computed = \"28ZvW9rqRqvqpFTtHnusUntRqrxb4qqZAaNAd3QsqjSsXq\"  \/\/ Computed on deathstar\ntestPriv_computed =\n  [0x12, 0x86, 0xe0, 0x18, 0xc6, 0x68, 0x34, 0x96, 0x09, 0x2e, 0x53,\n   0x32, 0x37, 0x76, 0x80, 0x3c, 0x30, 0xb4, 0x75, 0x2d, 0xd7, 0x70,\n   0xea, 0xa9, 0x6f, 0x0d, 0xda, 0x25, 0xc7, 0xfe, 0x28, 0x1f]\n\n\/\/ Deathstar results:\n\/\/ ([0x32, 0x38, 0x5a, 0x76, 0x57, 0x39, 0x72, 0x71, 0x52, 0x71, 0x76,\n\/\/   0x71, 0x70, 0x46, 0x54, 0x74, 0x48, 0x6e, 0x75, 0x73, 0x55, 0x6e,\n\/\/   0x74, 0x52, 0x71, 0x72, 0x78, 0x62, 0x34, 0x71, 0x71, 0x5a, 0x41,\n\/\/   0x61, 0x4e, 0x41, 0x64, 0x33, 0x51, 0x73, 0x71, 0x6a, 0x53, 0x73,\n\/\/   0x58, 0x71],\n\/\/  [0x12, 0x86, 0xe0, 0x18, 0xc6, 0x68, 0x34, 0x96, 0x09, 0x2e, 0x53,\n\/\/   0x32, 0x37, 0x76, 0x80, 0x3c, 0x30, 0xb4, 0x75, 0x2d, 0xd7, 0x70,\n\/\/   0xea, 0xa9, 0x6f, 0x0d, 0xda, 0x25, 0xc7, 0xfe, 0x28, 0x1f])\n\n\ntestPriv = [0x12, 0x86, 0xe0, 0x18, 0xc6, 0x68, 0x34, 0x96, 0x09, 0x2e, 0x53, 0x32, 0x37, 0x76, 0x80, 0x3c, 0x30, 0xb4, 0x75, 0x2d, 0xd7, 0x70,0xea, 0xa9, 0x6f, 0x0d, 0xda, 0x25, 0xc7, 0xfe, 0x28, 0x1f]\n\ntestPub = Curve25519 testPriv basePoint25519\nproperty kat_pub_id_eq = testPub == (decodeID testID).1 \/\\ encodeID testPub == testID \/\\ testID == testID_computed \/\\ testPriv == testPriv_computed\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the AES module's encryption and decryption functions. Specifically, specify properties that ensure decrypting an encrypted plaintext with the same key returns the original plaintext, and properties that validate the key expansion functions produce consistent keys for encryption and decryption. Include properties suitable for :check or :prove commands."},{"role":"assistant","content":"```cryptol\nmodule AES where\n\nimport AES::Algorithm as AES where\n  type Mode = m\n  encRound = AESRound\n  decRound = AESInvRound\n\nimport AES::ExpandKey where\n  type Nk = AES::Nk\n  type Nr = AES::Nr\n\nimport AES::TBox\n\nparameter\n  \/** 0: AES128, 1: AES192, 2: AES256 *\/\n  type m : #\n  type k : #\n  type constraint (k == 128 + m * 64, 2 >= m)\n\ntype EncKey = AES::KeySchedule\ntype DecKey = AES::KeySchedule\n\n\nencrypt : [k] -> [128] -> [128]\nencrypt k = encryptWithSchedule (expandKeyEnc k)\n\ndecrypt : [k] -> [128] -> [128]\ndecrypt k = decryptWithSchedule (expandKeyDec k)\n\n\nexpandKeyEnc : [k] -> EncKey\nexpandKeyEnc = expandKey\n\nencryptWithSchedule : EncKey -> [128] -> [128]\nencryptWithSchedule = AES::encrypt\n\n\n\nexpandKeyDec : [k] -> EncKey\nexpandKeyDec k = makeDecKey (expandKey k)\n\ndecryptWithSchedule : DecKey -> [128] -> [128]\ndecryptWithSchedule = AES::decrypt\n\n\nproperty test k pt = decrypt k (encrypt k pt) == pt\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES_GCM_SIV_Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that formally specify and verify the correctness of the AES-GCM-SIV encryption function as used in the AES_GCM_SIV_Test.cry file. Your properties should cover various parameterizations of the AES_GCM_SIV module (different Mode and AAD sizes) and test vectors, ensuring that the aes_gcm_siv function produces the expected ciphertext and authentication tag outputs for given keys, nonces, additional authenticated data (AAD), and plaintext messages. Include properties that check the function's behavior on empty inputs, varying message lengths, and different AAD lengths, matching the test cases provided in the file."},{"role":"assistant","content":"```cryptol\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_56 where\n  type Mode = 0\n  type AAD = 56\n\nproperty test0 =\n  AES_GCM_SIV_0_56::aes_gcm_siv\n    { key   = 0xee8e1ed9ff2540ae8f2ba9f50bc2f27c\n    , nonce = 0x752abad3e0afb5f434dc4310\n    , aad   = join \"example\"\n    , msg   = join \"Hello world\"\n    }\n  ==\n  0x5d349ead175ef6b1def6fd #\n  0x4fbcdeb7e4793f4a1d7e4faa70100af1\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_0 where\n  type Mode = 0\n  type AAD = 0\n\nproperty test1 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = []\n    }\n  ==\n  0xdc20e2d83f25705bb49e439eca56de25\n\nproperty test2 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x0100000000000000\n    }\n  ==\n  0xb5d839330ac7b786578782fff6013b81 #\n  0x5b287c22493a364c\n\nproperty test3 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x010000000000000000000000\n    }\n  ==\n  0x7323ea61d05932260047d942a4978db3 #\n  0x57391a0bc4fdec8b0d106639\n\nproperty test4 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000\n    }\n  ==\n  0x743f7c8077ab25f8624e2e948579cf77 #\n  0x303aaf90f6fe21199c6068577437a0c4\n\nproperty test5 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000\n    }\n  ==\n  0x84e07e62ba83a6585417245d7ec413a9 #\n  0xfe427d6315c09b57ce45f2e3936a9445 #\n  0x1a8e45dcd4578c667cd86847bf6155ff\n\nproperty test6 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000\n    }\n  ==\n  0x3fd24ce1f5a67b75bf2351f181a475c7 #\n  0xb800a5b4d3dcf70106b1eea82fa1d64d #\n  0xf42bf7226122fa92e17a40eeaac1201b #\n  0x5e6e311dbf395d35b0fe39c2714388f8\n\nproperty test7 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000\n    }\n  ==\n  0x2433668f1058190f6d43e360f4f35cd8 #\n  0xe475127cfca7028ea8ab5c20f7ab2af0 #\n  0x2516a2bdcbc08d521be37ff28c152bba #\n  0x36697f25b4cd169c6590d1dd39566d3f #\n  0x8a263dd317aa88d56bdf3936dba75bb8\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_8 where\n  type Mode = 0\n  type AAD = 8\n\nproperty test8 =\n AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x0200000000000000\n    }\n  ==\n  0x1e6daba35669f4273b0a1a2560969cdf #\n  0x790d99759abd1508\n\nproperty test9 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x020000000000000000000000\n    }\n  ==\n  0x296c7889fd99f41917f4462008299c51 #\n  0x02745aaa3a0c469fad9e075a\n\nproperty test10 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000\n    }\n  ==\n  0xe2b0c5da79a901c1745f700525cb335b #\n  0x8f8936ec039e4e4bb97ebd8c4457441f\n\nproperty test11 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000\n    }\n  ==\n  0x620048ef3c1e73e57e02bb8562c416a3 #\n  0x19e73e4caac8e96a1ecb2933145a1d71 #\n  0xe6af6a7f87287da059a71684ed3498e1\n\nproperty test12 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000\n    }\n  ==\n  0x50c8303ea93925d64090d07bd109dfd9 #\n  0x515a5a33431019c17d93465999a8b005 #\n  0x3201d723120a8562b838cdff25bf9d1e #\n  0x6a8cc3865f76897c2e4b245cf31c51f2\n\nproperty test13 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000 #\n              0x05000000000000000000000000000000\n    }\n  ==\n  0x2f5c64059db55ee0fb847ed513003746 #\n  0xaca4e61c711b5de2e7a77ffd02da42fe #\n  0xec601910d3467bb8b36ebbaebce5fba3 #\n  0x0d36c95f48a3e7980f0e7ac299332a80 #\n  0xcdc46ae475563de037001ef84ae21744\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_96 where\n  type Mode = 0\n  type AAD = 96\n\nproperty test14 =\n  AES_GCM_SIV_0_96::aes_gcm_siv\n    { msg = 0x02000000\n    , aad = 0x010000000000000000000000\n    , key = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0xa8fe3e8707eb1f84fb28f8cb73de8e99 #\n  0xe2f48a14\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_144 where\n  type Mode = 0\n  type AAD = 144\n\nproperty test15 =\n  AES_GCM_SIV_0_144::aes_gcm_siv\n    { msg = 0x03000000000000000000000000000000 #\n            0x04000000\n    , aad = 0x01000000000000000000000000000000 #\n            0x0200\n    , key = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0x6bb0fecf5ded9b77f902c7d5da236a43 #\n  0x91dd029724afc9805e976f451e6d87f6 #\n  0xfe106514\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_160 where\n  type Mode = 0\n  type AAD = 160\n\nproperty test16 =\n  AES_GCM_SIV_0_160::aes_gcm_siv\n    { msg =   0x03000000000000000000000000000000 #\n              0x0400\n    , aad   = 0x01000000000000000000000000000000 #\n              0x02000000\n    , key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0x44d0aaf6fb2f1f34add5e8064e83e12a #\n  0x2adabff9b2ef00fb47920cc72a0c0f13 #\n  0xb9fd\n\n\nproperty test16' =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0xe66021d5eb8e4f4066d4adb9c33560e4\n   , nonce = 0xf46e44bb3da0015c94f70887\n   }\n   == 0xa4194b79071b01a87d65f706e3949578\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_40 where\n  type Mode = 0\n  type AAD = 40\n\nproperty test17 =\n  AES_GCM_SIV_0_40::aes_gcm_siv\n   { msg = 0x7a806c\n   , aad = 0x46bb91c3c5\n   , key = 0x36864200e0eaf5284d884a0e77d31646\n   , nonce = 0xbae8e37fc83441b16034566b\n   }\n   == 0xaf60eb711bd85bc1e4d3e0a462e074ee #\n      0xa428a8\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_80 where\n  type Mode = 0\n  type AAD = 80\n\nproperty test18 =\n  AES_GCM_SIV_0_80::aes_gcm_siv\n   { msg = 0xbdc66f146545\n   , aad = 0xfc880c94a95198874296\n   , key = 0xaedb64a6c590bc84d1a5e269e4b47801\n   , nonce = 0xafc0577e34699b9e671fdd4f\n   }\n   == 0xbb93a3e34d3cd6a9c45545cfc11f03ad #\n      0x743dba20f966\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_120 where\n  type Mode = 0\n  type AAD = 120\n\nproperty test19 =\n  AES_GCM_SIV_0_120::aes_gcm_siv\n   { msg = 0x1177441f195495860f\n   , aad = 0x046787f3ea22c127aaf195d1894728\n   , key = 0xd5cc1fd161320b6920ce07787f86743b\n   , nonce = 0x275d1ab32f6d1f0434d8848c\n   }\n   == 0x4f37281f7ad12949d01d02fd0cd174c8 #\n      0x4fc5dae2f60f52fd2b\n\n\nproperty test20 =\n  AES_GCM_SIV_0_160::aes_gcm_siv\n   { msg = 0x9f572c614b4745914474e7c7\n   , aad = 0xc9882e5386fd9f92ec489c8fde2be2cf #\n           0x97e74e93\n   , key = 0xb3fed1473c528b8426a582995929a149\n   , nonce = 0x9e9ad8780c8d63d0ab4149c0\n   }\n   == 0xf54673c5ddf710c745641c8bc1dc2f87 #\n      0x1fb7561da1286e655e24b7b0\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_200 where\n  type Mode = 0\n  type AAD = 200\n\nproperty test21 =\n  AES_GCM_SIV_0_200::aes_gcm_siv\n   { msg = 0x0d8c8451178082355c9e940fea2f58\n   , aad = 0x2950a70d5a1db2316fd568378da107b5 #\n           0x2b0da55210cc1c1b0a\n   , key = 0x2d4ed87da44102952ef94b02b805249b\n   , nonce = 0xac80e6f61455bfac8308a2d4\n   }\n   == 0xc9ff545e07b88a015f05b274540aa183 #\n           0xb3449b9f39552de99dc214a1190b0b\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_240 where\n  type Mode = 0\n  type AAD = 240\n\nproperty test22 =\n  AES_GCM_SIV_0_240::aes_gcm_siv\n   { msg = 0x6b3db4da3d57aa94842b9803a96e07fb #\n           0x6de7\n   , aad = 0x1860f762ebfbd08284e421702de0de18 #\n           0xbaa9c9596291b08466f37de21c7f\n   , key = 0xbde3b2f204d1e9f8b06bc47f9745b3d1\n   , nonce = 0xae06556fb6aa7890bebc18fe\n   }\n   == 0x6298b296e24e8cc35dce0bed484b7f30 #\n           0xd5803e377094f04709f64d7b985310a4 #\n           0xdb84\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_280 where\n  type Mode = 0\n  type AAD = 280\n\nproperty test23 =\n  AES_GCM_SIV_0_280::aes_gcm_siv\n   { msg = 0xe42a3c02c25b64869e146d7b233987bd #\n           0xdfc240871d\n   , aad = 0x7576f7028ec6eb5ea7e298342a94d4b2 #\n           0x02b370ef9768ec6561c4fe6b7e7296fa #\n           0x859c21\n   , key = 0xf901cfe8a69615a93fdf7a98cad48179\n   , nonce = 0x6245709fb18853f68d833640\n   }\n   == 0x391cc328d484a4f46406181bcd62efd9 #\n      0xb3ee197d052d15506c84a9edd65e13e9 #\n      0xd24a2a6e70\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_0 where\n  type Mode = 1\n  type AAD = 0\n\nproperty test24 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x07f5f4169bbf55a8400cd47ea6fd400f\n\nproperty test25 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x0100000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc2ef328e5c71c83b843122130f7364b7 #\n      0x61e0b97427e3df28\n\nproperty test26 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x010000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x9aab2aeb3faa0a34aea8e2b18ca50da9 #\n      0xae6559e48fd10f6e5c9ca17e\n\nproperty test27 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x85a01b63025ba19b7fd3ddfc033b3e76 #\n      0xc9eac6fa700942702e90862383c6c366\n\nproperty test28 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x4a6a9db4c8c6549201b9edb53006cba8 #\n      0x21ec9cf850948a7c86c68ac7539d027f #\n      0xe819e63abcd020b006a976397632eb5d\n\nproperty test29 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n\n   == 0xc00d121893a9fa603f48ccc1ca3c57ce #\n      0x7499245ea0046db16c53c7c66fe717e3 #\n      0x9cf6c748837b61f6ee3adcee17534ed5 #\n      0x790bc96880a99ba804bd12c0e6a22cc4\n\nproperty test30 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc2d5160a1f8683834910acdafc41fbb1 #\n      0x632d4a353e8b905ec9a5499ac34f96c7 #\n      0xe1049eb080883891a4db8caaa1f99dd0 #\n      0x04d80487540735234e3744512c6f90ce #\n      0x112864c269fc0d9d88c61fa47e39aa08\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_8 where\n  type Mode = 1\n  type AAD = 8\n\nproperty test31 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x0200000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x1de22967237a813291213f267e3b452f #\n      0x02d01ae33e4ec854\n\nproperty test32 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x020000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x163d6f9cc1b346cd453a2e4cc1a4a19a #\n      0xe800941ccdc57cc8413c277f\n\nproperty test33 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc91545823cc24f17dbb0e9e807d5ec17 #\n      0xb292d28ff61189e8e49f3875ef91aff7\n\nproperty test34 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x07dad364bfc2b9da89116d7bef6daaaf #\n      0x6f255510aa654f920ac81b94e8bad365 #\n      0xaea1bad12702e1965604374aab96dbbc\n\nproperty test35 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc67a1f0f567a5198aa1fcc8e3f213143 #\n      0x36f7f51ca8b1af61feac35a86416fa47 #\n      0xfbca3b5f749cdf564527f2314f42fe25 #\n      0x03332742b228c647173616cfd44c54eb\n\nproperty test36 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000 #\n           0x05000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x67fd45e126bfb9a79930c43aad2d3696 #\n      0x7d3f0e4d217c1e551f59727870beefc9 #\n      0x8cb933a8fce9de887b1e40799988db1f #\n      0xc3f91880ed405b2dd298318858467c89 #\n      0x5bde0285037c5de81e5b570a049b62a0\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_96 where\n  type Mode = 1\n  type AAD = 96\n\nproperty test37 =\n  AES_GCM_SIV_1_96::aes_gcm_siv\n   { msg = 0x02000000\n   , aad = 0x010000000000000000000000\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x22b3f4cd1835e517741dfddccfa07fa4 #\n      0x661b74cf\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_144 where\n  type Mode = 1\n  type AAD = 144\n\nproperty test38 =\n  AES_GCM_SIV_1_144::aes_gcm_siv\n   { msg = 0x03000000000000000000000000000000 #\n           0x04000000\n   , aad = 0x01000000000000000000000000000000 #\n           0x0200\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x43dd0163cdb48f9fe3212bf61b201976 #\n      0x067f342bb879ad976d8242acc188ab59 #\n      0xcabfe307\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_160 where\n  type Mode = 1\n  type AAD = 160\n\nproperty test39 =\n  AES_GCM_SIV_1_160::aes_gcm_siv\n   { msg = 0x03000000000000000000000000000000 #\n           0x0400\n   , aad = 0x01000000000000000000000000000000 #\n           0x02000000\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x462401724b5ce6588d5a54aae5375513 #\n      0xa075cfcdf5042112aa29685c912fc205 #\n      0x6543\n\n\nproperty test40 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0xe66021d5eb8e4f4066d4adb9c33560e4 #\n           0xf46e44bb3da0015c94f7088736864200\n   , nonce = 0xe0eaf5284d884a0e77d31646\n   }\n   == 0x169fbb2fbf389a995f6390af22228a62\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_40 where\n  type Mode = 1\n  type AAD = 40\n\nproperty test41 =\n  AES_GCM_SIV_1_40::aes_gcm_siv\n   { msg = 0x671fdd\n   , aad = 0x4fbdc66f14\n   , key = 0xbae8e37fc83441b16034566b7a806c46 #\n           0xbb91c3c5aedb64a6c590bc84d1a5e269\n   , nonce = 0xe4b47801afc0577e34699b9e\n   }\n   == 0x0eaccb93da9bb81333aee0c785b240d3 #\n      0x19719d\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_80 where\n  type Mode = 1\n  type AAD = 80\n\nproperty test42 =\n  AES_GCM_SIV_1_80::aes_gcm_siv\n   { msg = 0x195495860f04\n   , aad = 0x6787f3ea22c127aaf195\n   , key = 0x6545fc880c94a95198874296d5cc1fd1 #\n           0x61320b6920ce07787f86743b275d1ab3\n   , nonce = 0x2f6d1f0434d8848c1177441f\n   }\n   == 0xa254dad4f3f96b62b84dc40c84636a5e #\n      0xc12020ec8c2c\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_120 where\n  type Mode = 1\n  type AAD = 120\n\nproperty test43 =\n  AES_GCM_SIV_1_120::aes_gcm_siv\n   { msg = 0xc9882e5386fd9f92ec\n   , aad = 0x489c8fde2be2cf97e74e932d4ed87d\n   , key = 0xd1894728b3fed1473c528b8426a58299 #\n           0x5929a1499e9ad8780c8d63d0ab4149c0\n   , nonce = 0x9f572c614b4745914474e7c7\n   }\n   == 0x0df9e308678244c44bc0fd3dc6628dfe #\n      0x55ebb0b9fb2295c8c2\n\n\nproperty test44 =\n  AES_GCM_SIV_1_160::aes_gcm_siv\n   { msg = 0x1db2316fd568378da107b52b\n   , aad = 0x0da55210cc1c1b0abde3b2f204d1e9f8 #\n           0xb06bc47f\n   , key = 0xa44102952ef94b02b805249bac80e6f6 #\n           0x1455bfac8308a2d40d8c845117808235\n   , nonce = 0x5c9e940fea2f582950a70d5a\n   }\n   == 0x8dbeb9f7255bf5769dd56692404099c2 #\n      0x587f64979f21826706d497d5\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_200 where\n  type Mode = 1\n  type AAD = 200\n\nproperty test45 =\n  AES_GCM_SIV_1_200::aes_gcm_siv\n   { msg = 0x21702de0de18baa9c9596291b08466\n   , aad = 0xf37de21c7ff901cfe8a69615a93fdf7a #\n           0x98cad481796245709f\n   , key = 0x9745b3d1ae06556fb6aa7890bebc18fe #\n           0x6b3db4da3d57aa94842b9803a96e07fb\n   , nonce = 0x6de71860f762ebfbd08284e4\n   }\n   == 0x793576dfa5c0f88729a7ed3c2f1bffb3 #\n      0x080d28f6ebb5d3648ce97bd5ba67fd\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_240 where\n  type Mode = 1\n  type AAD = 240\n\nproperty test46 =\n  AES_GCM_SIV_1_240::aes_gcm_siv\n   { msg = 0xb202b370ef9768ec6561c4fe6b7e7296 #\n           0xfa85\n   , aad = 0x9c2159058b1f0fe91433a5bdc20e214e #\n           0xab7fecef4454a10ef0657df21ac7\n   , key = 0xb18853f68d833640e42a3c02c25b6486 #\n           0x9e146d7b233987bddfc240871d7576f7\n   , nonce = 0x028ec6eb5ea7e298342a94d4\n   }\n   == 0x857e16a64915a787637687db4a951963 #\n      0x5cdd454fc2a154fea91f8363a39fec7d #\n      0x0a49\n\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_280 where\n  type Mode = 1\n  type AAD = 280\n\nproperty test47 =\n  AES_GCM_SIV_1_280::aes_gcm_siv\n   { msg = 0xced532ce4159b035277d4dfbb7db6296 #\n           0x8b13cd4eec\n   , aad = 0x734320ccc9d9bbbb19cb81b2af4ecbc3 #\n           0xe72834321f7aa0f70b7282b4f33df23f #\n           0x167541\n   , key = 0x3c535de192eaed3822a2fbbe2ca9dfc8 #\n           0x8255e14a661b8aa82cc54236093bbc23\n   , nonce = 0x688089e55540db1872504e1c\n   }\n   == 0x626660c26ea6612fb17ad91e8e767639 #\n      0xedd6c9faee9d6c7029675b89eaf4ba1d #\n      0xed1a286594\n\n\nproperty test48 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x00000000000000000000000000000000 #\n           0x4db923dc793ee6497c76dcc03a98e108\n   , aad = []\n   , key = 0x00000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x000000000000000000000000\n   }\n   == 0xf3f80f2cf0cb2dd9c5984fcda908456c #\n      0xc537703b5ba70324a6793a7bf218d3ea #\n      0xffffffff000000000000000000000000\n\nproperty test49 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0xeb3640277c7ffd1303c7a542d02d3e4c #\n           0x0000000000000000\n   , aad = []\n   , key = 0x00000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x000000000000000000000000\n   }\n   == 0x18ce4f0b8cb4d0cac65fea8f79257b20 #\n      0x888e53e72299e56dffffffff00000000 #\n      0x0000000000000000\n\n\n\nproperty test50 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { msg = 0x01000000000000000000000000000000 #\n            0x02000000000000000000000000000000 #\n            0x03000000000000000000000000000000 #\n            0x04000000000000000000000000000000 #\n            0x05000000000000000000000000000000 #\n            0x06000000000000000000000000000000 #\n            0x07000000000000000000000000000000 #\n            0x08000000000000000000000000000000 #\n            0x09000000000000000000000000000000 #\n            0x0a000000000000000000000000000000 #\n            0x0b000000000000000000000000000000 #\n            0x0c000000000000000000000000000000 #\n            0x0d000000000000000000000000000000 #\n            0x0e000000000000000000000000000000 #\n            0x0f000000000000000000000000000000 #\n            0x10000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , key = 0x01000000000000000000000000000000\n    , aad = []\n    }\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/GCM_AES_Tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the GCM encryption implementations for AES-128, AES-192, and AES-256 in the GCM_AES_Tests module produce the expected ciphertext and authentication tag outputs for the given test vectors. Include properties that check correctness for different key sizes, IV lengths, AAD lengths, and plaintext inputs as specified in the test cases."},{"role":"assistant","content":"```cryptol\nmodule GCM_AES_Tests where\n\nimport AES as AES128 where\n  type m = 0\n  type k = 128\n\nimport AES as AES192 where\n  type m = 1\n  type k = 192\n\nimport AES as AES256 where\n  type m = 2\n  type k = 256\n\n\nimport Common::GCM as GCM_128_96_0_128 where\n  type K = 128\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES128::encrypt\n\nproperty test1 =\n  GCM_128_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000\n    , pt  = []\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = []\n  , tag = 0x58e2fccefa7e3061367f1d57a4e7455a\n  }\n\nproperty test2 =\n  GCM_128_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = 0x0388dace60b6a392f328c2b971b2fe78\n  , tag = 0xab6e47d42cec13bdf53a67b21257bddf\n  }\n\nproperty test3 =\n  GCM_128_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct = 0x42831ec2217774244b7221b784d0d49c #\n         0xe3aa212f2c02a4e035c17e2329aca12e #\n         0x21d514b25466931c7d8f6a5aac84aa05 #\n         0x1ba30b396a0aac973d58e091473f5985\n  , tag = 0x4d5c2af327cd64a62cf35abd2ba6fab4\n  }\n\n\nimport Common::GCM as GCM_128_96_160_128 where\n  type K = 128\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test4 =\n  GCM_128_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct = 0x42831ec2217774244b7221b784d0d49c #\n         0xe3aa212f2c02a4e035c17e2329aca12e #\n         0x21d514b25466931c7d8f6a5aac84aa05 #\n         0x1ba30b396a0aac973d58e091\n  , tag = 0x5bc94fbc3221a5db94fae95ae7121a47\n  }\n\n\nimport Common::GCM as GCM_128_64_160_128 where\n  type K = 128\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test5 =\n  GCM_128_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbad\n    }\n  ==\n  { ct = 0x61353b4c2806934a777ff51fa22a4755 #\n         0x699b2a714fcdc6f83766e5f97b6c7423 #\n         0x73806900e49f24b22b097544d4896b42 #\n         0x4989b5e1ebac0f07c23f4598\n  , tag = 0x3612d2e79e3b0785561be14aaca2fccb\n  }\n\n\nimport Common::GCM as GCM_128_480_160_128 where\n  type K = 128\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test6 =\n  GCM_128_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0x9313225df88406e555909c5aff5269aa #\n            0x6a7a9538534f7da1e4c303d2a318a728 #\n            0xc3c0c95156809539fcf0e2429a6b5254 #\n            0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct = 0x8ce24998625615b603a033aca13fb894 #\n         0xbe9112a5c3a211a8ba262a3cca7e2ca7 #\n         0x01e4a9a4fba43c90ccdcb281d48c7c6f #\n         0xd62875d2aca417034c34aee5\n  , tag = 0x619cc5aefffe0bfa462af43c1699d050\n  }\n\n\nimport Common::GCM as GCM_192_96_0_128 where\n  type K = 192\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES192::encrypt\n\nproperty test7 =\n  GCM_192_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x0000000000000000\n    , pt  = []\n    , aad = []\n    , iv  = 0x000000000000000000000000\n    }\n  ==\n  { ct = []\n  , tag = 0xcd33b28ac773f74ba00ed1f312572435\n  }\n\nproperty test8 =\n  GCM_192_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x0000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct = 0x98e7247c07f0fe411c267e4384b0f600\n  , tag = 0x2ff58d80033927ab8ef4d4587514f0fb\n  }\n\nproperty test9 =\n  GCM_192_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv  = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct =  0x3980ca0b3c00e841eb06fac4872a2757 #\n          0x859e1ceaa6efd984628593b40ca1e19c #\n          0x7d773d00c144c525ac619d18c84a3f47 #\n          0x18e2448b2fe324d9ccda2710acade256\n  , tag = 0x9924a7c8587336bfb118024db8674a14\n  }\n\n\nimport Common::GCM as GCM_192_96_160_128 where\n  type K = 192\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test10 =\n  GCM_192_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct  = 0x3980ca0b3c00e841eb06fac4872a2757 #\n          0x859e1ceaa6efd984628593b40ca1e19c #\n          0x7d773d00c144c525ac619d18c84a3f47 #\n          0x18e2448b2fe324d9ccda2710\n  , tag = 0x2519498e80f1478f37ba55bd6d27618c\n  }\n\n\nimport Common::GCM as GCM_192_64_160_128 where\n  type K = 192\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test11 =\n  GCM_192_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbad\n    }\n  ==\n  { ct  = 0x0f10f599ae14a154ed24b36e25324db8 #\n          0xc566632ef2bbb34f8347280fc4507057 #\n          0xfddc29df9a471f75c66541d4d4dad1c9 #\n          0xe93a19a58e8b473fa0f062f7\n  , tag = 0x65dcc57fcf623a24094fcca40d3533f8\n  }\n\n\nimport Common::GCM as GCM_192_480_160_128 where\n  type K = 192\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test12 =\n  GCM_192_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0x9313225df88406e555909c5aff5269aa #\n            0x6a7a9538534f7da1e4c303d2a318a728 #\n            0xc3c0c95156809539fcf0e2429a6b5254 #\n            0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct  = 0xd27e88681ce3243c4830165a8fdcf9ff #\n          0x1de9a1d8e6b447ef6ef7b79828666e45 #\n          0x81e79012af34ddd9e2f037589b292db3 #\n          0xe67c036745fa22e7e9b7373b\n  , tag = 0xdcf566ff291c25bbb8568fc3d376a6d9\n  }\n\n\nimport Common::GCM as GCM_256_96_0_128 where\n  type K = 256\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES256::encrypt\n\nproperty test13 =\n  GCM_256_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x00000000000000000000000000000000\n    , pt  = []\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = []\n  , tag = 0x530f8afbc74536b9a963b4f1c4cb738b\n  }\n\nproperty test14 =\n  GCM_256_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x00000000000000000000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = 0xcea7403d4d606b6e074ec5d3baf39d18\n  , tag = 0xd0d1c8a799996bf0265b98b5d48ab919\n  }\n\nproperty test15 =\n  GCM_256_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct  = 0x522dc1f099567d07f47f37a32a84427d #\n          0x643a8cdcbfe5c0c97598a2bd2555d1aa #\n          0x8cb08e48590dbb3da7b08b1056828838 #\n          0xc5f61e6393ba7a0abcc9f662898015ad\n  , tag = 0xb094dac5d93471bdec1a502270e3cc6c\n  }\n\n\nimport Common::GCM as GCM_256_96_160_128 where\n  type K = 256\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test16 =\n  GCM_256_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct  = 0x522dc1f099567d07f47f37a32a84427d #\n          0x643a8cdcbfe5c0c97598a2bd2555d1aa #\n          0x8cb08e48590dbb3da7b08b1056828838 #\n          0xc5f61e6393ba7a0abcc9f662\n  , tag = 0x76fc6ece0f4e1768cddf8853bb2d551b\n  }\n\n\nimport Common::GCM as GCM_256_64_160_128 where\n  type K = 256\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test17 =\n  GCM_256_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0xcafebabefacedbad\n    }\n  ==\n  { ct  = 0xc3762df1ca787d32ae47c13bf19844cb #\n          0xaf1ae14d0b976afac52ff7d79bba9de0 #\n          0xfeb582d33934a4f0954cc2363bc73f78 #\n          0x62ac430e64abe499f47c9b1f\n  , tag = 0x3a337dbf46a792c45e454913fe2ea8f2\n  }\n\n\nimport Common::GCM as GCM_256_480_160_128 where\n  type K = 256\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test18 =\n  GCM_256_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0x9313225df88406e555909c5aff5269aa #\n           0x6a7a9538534f7da1e4c303d2a318a728 #\n           0xc3c0c95156809539fcf0e2429a6b5254 #\n           0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct  = 0x5a8def2f0c9e53f1f75d7853659e2a20 #\n          0xeeb2b22aafde6419a058ab4f6f746bf4 #\n          0x0fc0c3b780f244452da3ebf1c5d82cde #\n          0xa2418997200ef82e44ae7e3f\n  , tag = 0xa44a8266ee1c8eb0c8b5d4cf5ae9f19a\n  }\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/SHA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the `sha256` function in the SHA module correctly computes the SHA-256 hash for all inputs, using the provided `sha256tests` as test vectors. Ensure the properties check that the output matches the expected hash values for each test case and that the function behaves consistently for inputs of varying lengths."},{"role":"assistant","content":"```cryptol\nmodule SHA where\n\nimport SHA256 as SHA256\n\nsha256 : {n} (64 >= width n) => [n] -> [256]\nsha256 = SHA256::sha\n\n\nproperty katsPass = ~zero == [test == kat | (test,kat) <- sha256tests ]\n\n\nsha256tests =\n  [ (go \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    ,   0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1\n    )\n\n  , (go \"\"\n    ,   0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n    )\n\n    , (go \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n      , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1\n      )\n\n    ]\n\n  where\n  go : {n} (64 >= width (8 * n)) => [n][8] -> [256]\n  go x = sha256 (join x)\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/SCrypt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the SCrypt key derivation function implementation in the provided SCrypt.cry module. Include properties that check the expected output for known test vectors (KATs) and verify the internal consistency of the BlockMix, SMix, and MFcrypt functions according to the SCrypt specification."},{"role":"assistant","content":"```cryptol\nmodule SCrypt where\n\nimport Salsa20\nimport PBKDF2\n\n\/\/ SCrypt paper page 10: BlockMix specialized to Salsa20\nBlockMix : {r} (fin r, r >= 1) =>  [2*r][64*8] -> [2*r][64*8]\nBlockMix B = ys @@ ([0,2..2*r-2] # [1,3..2*r-1])\n where\n  rs = [B!0] # [ join (Salsa20 `{r=8} (split (X ^ bi))) | X <- rs | bi <- B ]\n  ys = drop `{1} rs\n\n\/\/ SMix with the ROMix algorithm (section 5) inlined (specialized to BlockMix)\n\/\/ N = 2^^17\nSMix : {N,r} ( fin r\n             , r >= 1\n             , N >= 1\n             , 512 >= width N\n             , 1 + width N >= width (N-1)\n             ) => [128 * 8 * r] -> [128 * 8 * r]\nSMix B = join (Xs ! 0)\n where\n  Vs = [split B] # [ BlockMix x | x <- Vs | _ <- [0..N-1] : [_][width N + 1]]\n  V  = take `{front=N} Vs\n\n  Xs : [N+1][2*r][64*8]\n  Xs = [Vs!0]    # [ (x' where\n                            j  = integerify x\n                            T  = x ^ (V@j)\n                            x' = BlockMix T)\n                        | x <- Xs | _ <- [0..N-1] : [_][width N + 1] ]\n\n  integerify w = (join (reverse (split `{each=8} (w!0)))) % `N\n\n\/\/ SCrypt paper, page 11: MFCrypt specialized to sha256 (see the 'pbkdf2' function)\n\/\/ p = 1\nMFcrypt : { pwBytes, saltBytes, dkLen, r, N }\n          ( fin dkLen\n          , 4*r >= 1\n          , 8 * dkLen >= 1\n          , 64 >= width (8 * pwBytes)\n          , 32 >= width (4 + saltBytes)\n          ,  512 >= width N, 1+width N >= width (N-1)\n          , 32 >= width ((255 + 8 * dkLen) \/ 256)\n          , 32 >= width (4 + 128 * r)\n          , N >= 1\n          )\n        => [pwBytes][8] -> [saltBytes][8] -> [dkLen][8]\nMFcrypt P S = split DK\n where\n  B  = pbkdf2 `{C=1} P S\n  B' = SMix `{N=N,r=r} B\n  DK = pbkdf2 `{dkLenBits=dkLen*8, C=1} P (split B')\n\nSCrypt : {pwBytes, saltBytes, dkBytes, r, N}\n         ( fin dkBytes, 4*r >= 1\n         , 8 * dkBytes >= 1\n         , 32 >= width ((255 + 8 * dkBytes) \/ 256)\n         , 64 >= width (8 * pwBytes)\n         , 512 >= width N, 1+width N >= width (N-1)\n         , 32 >= width (4 + saltBytes)\n         , 32 >= width (4 + 128 * r)\n         , N >= 1\n         )\n      => [pwBytes][8] -> [saltBytes][8] -> [dkBytes][8]\nSCrypt P S = MFcrypt `{r=r,N=N} P S\n\nproperty kats_pass = ~zero ==\n    [ SCrypt `{N=2^^4,r=1} \"\" \"\" ==\n            [ 0x77, 0xd6, 0x57, 0x62, 0x38, 0x65, 0x7b, 0x20\n            , 0x3b, 0x19, 0xca, 0x42, 0xc1, 0x8a, 0x04, 0x97\n            , 0xf1, 0x6b, 0x48, 0x44, 0xe3, 0x07, 0x4a, 0xe8\n            , 0xdf, 0xdf, 0xfa, 0x3f, 0xed, 0xe2, 0x14, 0x42\n            , 0xfc, 0xd0, 0x06, 0x9d, 0xed, 0x09, 0x48, 0xf8\n            , 0x32, 0x6a, 0x75, 0x3a, 0x0f, 0xc8, 0x1f, 0x17\n            , 0xe8, 0xd3, 0xe0, 0xfb, 0x2e, 0x0d, 0x36, 0x28\n            , 0xcf, 0x35, 0xe2, 0x0c, 0x38, 0xd1, 0x89, 0x06\n            ]\n    ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the SHA256 implementation in the given module. Specifically, create properties that check the SHA256 function against the provided known-answer tests (KATs) to ensure it produces the expected hash outputs for the given inputs. Additionally, write properties to verify the correctness of the internal functions such as Ch, Maj, S0, S1, s0, s1, SHA256MessageSchedule, and SHA256Compress according to the SHA256 specification."},{"role":"assistant","content":"```cryptol\nmodule SHA256 where\n\n\/*\n * SHA256 Functions : Section 4.1.2\n *\/\n\nCh : [32] -> [32] -> [32] -> [32]\nCh x y z = (x && y) ^ (~x && z)\n\nMaj : [32] -> [32] -> [32] -> [32]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nS0 : [32] -> [32]\nS0 x = (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)\n\nS1 : [32] -> [32]\nS1 x = (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)\n\ns0 : [32] -> [32]\ns0 x = (x >>> 7) ^ (x >>> 18) ^ (x >> 3)\n\ns1 : [32] -> [32]\ns1 x = (x >>> 17) ^ (x >>> 19) ^ (x >> 10)\n\n\/*\n * SHA256 Constants : Section 4.2.2\n *\/\n\nK : [64][32]\nK = [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n     ]\n\n\/*\n * Preprocessing (padding and parsing) for SHA256 : Section 5.1.1 and 5.2.1\n *\/\npreprocess : {msgLen}\n     ( fin msgLen\n     , 64 >= width msgLen                              \/\/ message width fits in a word\n     )\n     => [msgLen] -> [(msgLen + 65) \/^ 512][512]\npreprocess msg = split (msg # [True] # (zero:[(msgLen + 65) %^ 512]) # (`msgLen:[64]))\n\n\/*\n * SHA256 Initial Hash Value :  Section 5.3.3\n *\/\n\nH0 : [8][32]\nH0 = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n       0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]\n\n\/*\n * The SHA256 Hash computation : Section 6.2.2\n *\n * We have split the computation into a message scheduling function, corresponding\n * to step 1 in the documents loop, and a compression function, corresponding to steps 2-4.\n *\/\n\nSHA256MessageSchedule : [16][32] -> [64][32]\nSHA256MessageSchedule M = W where\n    W = M # [ s1 (W@(j-2)) + (W@(j-7)) + s0 (W@(j-15)) + (W@(j-16)) | j <- [16 .. 63]:[_][8] ]\n\nSHA256Compress : [8][32] -> [64][32] -> [8][32]\nSHA256Compress H W = [as!0 + H@0, bs!0 + H@1, cs!0 + H@2, ds!0 + H@3, es!0 + H@4, fs!0 + H@5, gs!0 + H@6, hs!0 + H@7] where\n    T1 = [h + S1 e + Ch e f g  + k + w | h <- hs | e <- es | f <- fs | g <- gs | k <- K | w <- W]\n    T2 = [S0 a  + Maj a b c  | a <- as | b <- bs | c <- cs]\n    hs = take `{65} ([H@7] # gs)\n    gs = take `{65} ([H@6] # fs)\n    fs = take `{65} ([H@5] # es)\n    es = take `{65} ([H@4] # [d + t1 | d <- ds | t1 <- T1])\n    ds = take `{65} ([H@3] # cs)\n    cs = take `{65} ([H@2] # bs)\n    bs = take `{65} ([H@1] # as)\n    as = take `{65} ([H@0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\n\/*\n * The SHA256' function hashes a preprocessed sequence of blocks with the\n * compression function.  The SHA256 function hashes a sequence of bytes, and\n * is more likely the function that will be similar to those see in in an\n * implementation to be verified.\n *\/\n\nSHA256' : {a} (fin a) => [a][16][32] -> [8][32]\nSHA256' blocks = hash!0 where\n    hash = [H0] # [SHA256Compress h (SHA256MessageSchedule b) | h <- hash | b <- blocks]\n\nSHA256 : {a} (fin a, 64 >= width (8*a)) => [a][8] -> [256]\nSHA256 msg = join (SHA256' [ split x | x <- preprocess(join msg)])\n\nproperty katsPass = ~zero == [test == kat | (test,kat) <- kats ]\n\nkats = [ (SHA256 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n         , 0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1)\n       , (SHA256 \"\"\n         ,0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855)\n       , (SHA256 \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n         , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1)\n       \/\/ , (SHA256 [0x61 | i <- [1..1000000] : [_][32]]\n       \/\/   , 0xcdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0)\n       ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/HMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the hmacSHA256 function against known HMAC-SHA256 test vectors provided in the code. Include properties that check the output of hmacSHA256 for given inputs matches the expected digest values, ensuring the implementation conforms to the HMAC specification using SHA256."},{"role":"assistant","content":"```cryptol\nmodule HMAC where\n\nimport SHA256\n\nhmacSHA256 : {pwBytes, msgBytes}\n             (fin pwBytes, fin msgBytes\n             , 32 >= width msgBytes\n             , 64 >= width (8*pwBytes)\n             ) => [pwBytes][8] -> [msgBytes][8] -> [256]\nhmacSHA256 = hmac `{blockLength=64} SHA256 SHA256 SHA256\n\n\/\/ Due to limitations of the type system we must accept two\n\/\/ separate arguments (both aledgedly the same) for two\n\/\/ separate length inputs.\nhmac : { msgBytes, pwBytes, digest, blockLength }\n       ( fin pwBytes, fin digest, fin blockLength\n       )\n    => ([blockLength + msgBytes][8] -> [8*digest])\n    -> ([blockLength + digest][8] -> [8*digest])\n    -> ([pwBytes][8] -> [8*digest])\n    -> [pwBytes][8]\n    -> [msgBytes][8]\n    -> [digest*8]\nhmac hash hash2 hash3 key message = hash2 (okey # internal)\n where\n ks : [blockLength][8]\n ks   = if `pwBytes > (`blockLength : [max (width pwBytes) (width blockLength)])\n            then take `{blockLength} (split (hash3 key) # (zero : [blockLength][8]))\n            else take `{blockLength} (key # (zero : [blockLength][8]))\n okey = [k ^ 0x5C | k <- ks]\n ikey = [k ^ 0x36 | k <- ks]\n internal = split (hash (ikey # message))\n\nproperty pass =\n    ~zero ==\n    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] \"Hi There\" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\n    , hmacSHA256 \"Jefe\" \"what do ya want for nothing?\" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\n    ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Blake2s.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the blake2s hash function implementation in the given Blake2s.cry module. Include properties that check the function against known answer tests (KATs) provided in the module, ensuring that the output hash matches the expected values for given inputs. Also, specify properties that validate the internal compression function F and the mixing function G behave as intended according to the Blake2s specification."},{"role":"assistant","content":"```cryptol\nmodule Blake2s where\n\ntype Block   = [16][32]\ntype State   = [8][32]\ntype LocalState = [16][32]\ntype BCounter = [64]\n\ntype Context = { state : State, counter : BCounter }\n\nbbVal : [64]\nbbVal = 64\n\n\nIV : [8][32]\nIV = [ 0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,\n       0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\n     ]\n\nSIGMA_TABLE : [10][16][4]\nSIGMA_TABLE =\n    [  [  0, 1,   2, 3,   4, 5,   6, 7,   8, 9,  10, 11, 12, 13, 14, 15 ]\n    ,  [ 14, 10,  4, 8,   9, 15, 13, 6,   1, 12,  0, 2,  11, 7,   5, 3  ]\n    ,  [ 11, 8,  12, 0,   5, 2,  15, 13, 10, 14,  3, 6,   7, 1,   9, 4  ]\n    ,  [  7, 9,   3, 1,  13, 12, 11, 14,  2, 6,   5, 10,  4, 0,  15, 8  ]\n    ,  [  9, 0,   5, 7,   2, 4,  10, 15, 14, 1,  11, 12,  6, 8,   3, 13 ]\n    ,  [  2, 12,  6, 10,  0, 11,  8, 3,   4, 13,  7, 5,  15, 14,  1, 9  ]\n    ,  [ 12, 5,   1, 15, 14, 13,  4, 10,  0, 7,   6, 3,   9, 2,   8, 11 ]\n    ,  [ 13, 11,  7, 14, 12, 1,   3, 9,   5, 0,  15, 4,   8, 6,   2, 10 ]\n    ,  [  6, 15, 14, 9,  11, 3,   0, 8,  12, 2,  13, 7,   1, 4,  10, 5  ]\n    ,  [ 10, 2,   8, 4,   7, 6,   1, 5,  15, 11,  9, 14,  3, 12, 13, 0  ]\n    ]\n\n\/\/ Section 2.1 constants\nR1,R2,R3,R4 : [6]\nR1 = 16\nR2 = 12\nR3 = 08\nR4 = 07\n\n\/\/ Section 3.1: Mixing function 'G'\nG : [4] -> [4] -> LocalState -> [4][6] -> Block -> [16][32]\nG r i vec abcd ms = foldl updateVector vec (zip abcd new)\n  where\n  new  = G' r i (vec @@ abcd) ms\n\nG' : [4] -> [4] -> [4][32] -> Block -> [4][32]\nG' r i vals ms = [a2, b2, c2, d2]\n  where\n  x = ms @ (SIGMA_TABLE @ r @ (2*i))\n  y = ms @ (SIGMA_TABLE @ r @ (2*i+1))\n  [a,b,c,d] = vals\n  a1 =  a + b + x\n  d1 = (d ^ a1) >>> R1\n  c1 =  c + d1\n  b1 = (b ^ c1) >>> R2\n  a2 =  a1 + b1 + y\n  d2 = (d1 ^ a2) >>> R3\n  c2 =  c1 + d2\n  b2 = (b1 ^ c2) >>> R4\n\n\/\/ Section 3.2: Compression function\nF : State -> Block -> BCounter -> Bit -> State\nF h ms t f =  h ^ (take (vs!0)) ^ (drop (vs!0))\n where\n  v   = h # IV ^ (zero # [t0,t1,f0,zero])\n  [t1,t0] = split t      : [2][32]\n  f0 = [f | _ <- [0..31] : [_][6]]\n  vs = [v] # [ round i ms v' | v' <- vs | i <- [0..9] ]\n\n\/\/ Sub-function of F (first for loop)\nround : [4] -> Block -> LocalState -> LocalState\nround r ms v = vs ! 0\n  where\n  vs = [v] # [ G r i v' ix ms\n                | v'   <- vs\n                | i    <- [0..7]\n                | ix   <- [ [0,4,8,12],  [1,5,9,13]\n                          , [2,6,10,14], [3,7,11,15]\n                          , [0,5,10,15], [1,6,11,12]\n                          , [2,7,8,13],  [3,4,9,14] ]\n              ]\n\n\/\/ Section 3.3: Padding\n\/\/ Recall kk == key bytes  (0)\n\/\/        nn == hash bytes (32)\n\/\/        ll == input bytes (ceiling $ len \/ 8)\n\/\/        bb == block bytes (64, 1024 bits)\n\/\/        dd == nr Blocks\n\nblake2s : {ll,nn} (fin ll, 32 >= nn, 64 >= width ll)\n      => [ll][8] -> [nn*8]\nblake2s m = blake2s' `{ll=ll,nn=nn} m\n\nblake2s' : {ll,dd,nn}\n         (fin ll\n         , 32  >= nn\n         , dd  == (max 1 ((ll+63)\/64)) - 1\n         , 64 >= width ll\n         )\n          => [ll][8]\n          -> [nn*8]\nblake2s' m = take `{nn*8} (blake2sFinish ({ state = (hs!0).state, counter = `ll}) lastBlock)\n where\n\n fullBlocks : [dd]Block\n fullBlocks = [mkBlock b | b <- split (join (take  `{front=64*dd,back=ll-64*dd} m))]\n\n partialBlock = drop `{front=64*dd,back=ll-64*dd} m\n\n lastBlock : Block\n lastBlock  =\n    if (`ll == (zero:[64]))\n        then zero \/\/ Special case full zero block for empty messages\n        else mkBlock ((split (join (partialBlock # (zero : [inf][8]))))@0)\n\n h : Context\n h  = { state = [IV@0 ^ `0x01010000 ^ `nn] # drop `{1} IV, counter = 0 }\n\n hs : [dd+1]Context\n hs = [h] # [blake2Update h' dX |  h' <- hs | dX <- fullBlocks]\n\nblake2Update : Context -> Block -> Context\nblake2Update ctx d = { state = newState, counter = newCount }\n  where newState = F ctx.state d newCount False\n        newCount = ctx.counter + (64 : [64])\n\npostprocess : {ll} (64 >= ll, 64 >= width ll) => BCounter -> [ll][8] -> Block\npostprocess c m =\n    if c == 0 \/\\ `ll == (zero:[64])\n        then zero\n        else split (join m # zero)\n\n\/\/ The final round of blake\nblake2sFinish : Context -> Block -> [256]\nblake2sFinish ctx b = join [ reverseBytes w | w <- F ctx.state b ctx.counter True ]\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/  Utilities\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nmkBlock x = reverse (split (reverseBytes x))\n\nreverseBytes x = join (reverse (bytes x))\n\nbytes x = split x : [_] [8]\n\n\n\/\/ XXX can probably do a cleaner merge-sort style update.\nupdateVector : {a, b, c} (c >= width (a-1), a >= 1, fin a, fin c) => [a]b -> ([c], b) -> [a]b\nupdateVector orig idxNew = vs\n where\n idx = idxNew.0\n new = idxNew.1\n vs = [if i == idx then new else orig@i | i <- [0..a-1]]\n\n\nproperty katsPass = ~zero ==\n                        [ nthKat `{0}\n                        , nthKat `{1}\n                        , nthKat `{2}\n                        , nthKat `{3}\n                        , nthKat `{4}\n                        , nthKat `{5}\n                        , nthKat `{6}\n                        , nthKat `{7}\n                        , nthKat `{8}\n                        , nthKat `{9}\n                        , nthKat `{10}\n                        , nthKat `{11}\n                        , nthKat `{12}\n                        , nthKat `{13}\n                        , nthKat `{14}\n                        , nthKat `{15}\n                        , nthKat `{16}\n                        , nthKat `{17}\n                        , nthKat `{18}\n                        , nthKat `{19}\n                        , nthKat `{20}\n                        , nthKat `{21}\n                        , nthKat `{22}\n                        , nthKat `{23}\n                        , nthKat `{24}\n                        , nthKat `{25}\n                        , nthKat `{26}\n                        , nthKat `{27}\n                        , nthKat `{28}\n                        , nthKat `{29}\n                        , nthKat `{30}\n                        , nthKat `{31}\n                        , nthKat `{32}\n                        , nthKat `{33}\n                        , nthKat `{34}\n                        , nthKat `{35}\n                        , nthKat `{36}\n                        , nthKat `{37}\n                        , nthKat `{38}\n                        , nthKat `{39}\n                        , nthKat `{40}\n                        , nthKat `{41}\n                        , nthKat `{42}\n                        , nthKat `{43}\n                        , nthKat `{44}\n                        , nthKat `{45}\n                        , nthKat `{46}\n                        , nthKat `{47}\n                        , nthKat `{48}\n                        , nthKat `{49}\n                        , nthKat `{50}\n                        , nthKat `{51}\n                        , nthKat `{52}\n                        , nthKat `{53}\n                        , nthKat `{54}\n                        , nthKat `{55}\n                        , nthKat `{56}\n                        , nthKat `{57}\n                        , nthKat `{58}\n                        , nthKat `{59}\n                        , nthKat `{60}\n                        , nthKat `{61}\n                        , nthKat `{62}\n                        , nthKat `{63}\n                        , nthKat `{64}\n                        , nthKat `{65}\n                        , nthKat `{66}\n                        , nthKat `{67}\n                        , nthKat `{68}\n                        , nthKat `{69}\n                        , nthKat `{70}\n                        , nthKat `{71}\n                        , nthKat `{72}\n                        , nthKat `{73}\n                        , nthKat `{74}\n                        , nthKat `{75}\n                        , nthKat `{76}\n                        , nthKat `{77}\n                        , nthKat `{78}\n                        , nthKat `{79}\n                        , nthKat `{80}\n                        , nthKat `{81}\n                        , nthKat `{82}\n                        , nthKat `{83}\n                        , nthKat `{84}\n                        , nthKat `{85}\n                        , nthKat `{86}\n                        , nthKat `{87}\n                        , nthKat `{88}\n                        , nthKat `{89}\n                        , nthKat `{90}\n                        , nthKat `{91}\n                        , nthKat `{92}\n                        , nthKat `{93}\n                        , nthKat `{94}\n                        , nthKat `{95}\n                        , nthKat `{96}\n                        , nthKat `{97}\n                        , nthKat `{98}\n                        , nthKat `{99}\n                        , nthKat `{100}\n                        , nthKat `{101}\n                        , nthKat `{102}\n                        , nthKat `{103}\n                        , nthKat `{104}\n                        , nthKat `{105}\n                        , nthKat `{106}\n                        , nthKat `{107}\n                        , nthKat `{108}\n                        , nthKat `{109}\n                        , nthKat `{110}\n                        , nthKat `{111}\n                        , nthKat `{112}\n                        , nthKat `{113}\n                        , nthKat `{114}\n                        , nthKat `{115}\n                        , nthKat `{116}\n                        , nthKat `{117}\n                        , nthKat `{118}\n                        , nthKat `{119}\n                        , nthKat `{120}\n                        , nthKat `{121}\n                        , nthKat `{122}\n                        , nthKat `{123}\n                        , nthKat `{124}\n                        , nthKat `{125}\n                        , nthKat `{126}\n                        , nthKat `{127}\n                        , nthKat `{128}\n                        , nthKat `{129}\n                        , nthKat `{130}\n                        , nthKat `{131}\n                        , nthKat `{132}\n                        , nthKat `{133}\n                        , nthKat `{134}\n                        , nthKat `{135}\n                        , nthKat `{136}\n                        , nthKat `{137}\n                        , nthKat `{138}\n                        , nthKat `{139}\n                        , nthKat `{140}\n                        , nthKat `{141}\n                        , nthKat `{142}\n                        , nthKat `{143}\n                        , nthKat `{144}\n                        , nthKat `{145}\n                        , nthKat `{146}\n                        , nthKat `{147}\n                        , nthKat `{148}\n                        , nthKat `{149}\n                        , nthKat `{150}\n                        , nthKat `{151}\n                        , nthKat `{152}\n                        , nthKat `{153}\n                        , nthKat `{154}\n                        , nthKat `{155}\n                        , nthKat `{156}\n                        , nthKat `{157}\n                        , nthKat `{158}\n                        , nthKat `{159}\n                        , nthKat `{160}\n                        , nthKat `{161}\n                        , nthKat `{162}\n                        , nthKat `{163}\n                        , nthKat `{164}\n                        , nthKat `{165}\n                        , nthKat `{166}\n                        , nthKat `{167}\n                        , nthKat `{168}\n                        , nthKat `{169}\n                        , nthKat `{170}\n                        , nthKat `{171}\n                        , nthKat `{172}\n                        , nthKat `{173}\n                        , nthKat `{174}\n                        , nthKat `{175}\n                        , nthKat `{176}\n                        , nthKat `{177}\n                        , nthKat `{178}\n                        , nthKat `{179}\n                        , nthKat `{180}\n                        , nthKat `{181}\n                        , nthKat `{182}\n                        , nthKat `{183}\n                        , nthKat `{184}\n                        , nthKat `{185}\n                        , nthKat `{186}\n                        , nthKat `{187}\n                        , nthKat `{188}\n                        , nthKat `{189}\n                        , nthKat `{190}\n                        , nthKat `{191}\n                        , nthKat `{192}\n                        , nthKat `{193}\n                        , nthKat `{194}\n                        , nthKat `{195}\n                        , nthKat `{196}\n                        , nthKat `{197}\n                        , nthKat `{198}\n                        , nthKat `{199}\n                        , nthKat `{200}\n                        , nthKat `{201}\n                        , nthKat `{202}\n                        , nthKat `{203}\n                        , nthKat `{204}\n                        , nthKat `{205}\n                        , nthKat `{206}\n                        , nthKat `{207}\n                        , nthKat `{208}\n                        , nthKat `{209}\n                        , nthKat `{210}\n                        , nthKat `{211}\n                        , nthKat `{212}\n                        , nthKat `{213}\n                        , nthKat `{214}\n                        , nthKat `{215}\n                        , nthKat `{216}\n                        , nthKat `{217}\n                        , nthKat `{218}\n                        , nthKat `{219}\n                        , nthKat `{220}\n                        , nthKat `{221}\n                        , nthKat `{222}\n                        , nthKat `{223}\n                        , nthKat `{224}\n                        , nthKat `{225}\n                        , nthKat `{226}\n                        , nthKat `{227}\n                        , nthKat `{228}\n                        , nthKat `{229}\n                        , nthKat `{230}\n                        , nthKat `{231}\n                        , nthKat `{232}\n                        , nthKat `{233}\n                        , nthKat `{234}\n                        , nthKat `{235}\n                        , nthKat `{236}\n                        , nthKat `{237}\n                        , nthKat `{238}\n                        , nthKat `{239}\n                        , nthKat `{240}\n                        , nthKat `{241}\n                        , nthKat `{242}\n                        , nthKat `{243}\n                        , nthKat `{244}\n                        , nthKat `{245}\n                        , nthKat `{246}\n                        , nthKat `{247}\n                        , nthKat `{248}\n                        , nthKat `{249}\n                        , nthKat `{250}\n                        , nthKat `{251}\n                        , nthKat `{252}\n                        , nthKat `{253}\n                        , nthKat `{254}\n                        , nthKat `{255}\n                        ]\n\n\nnthKat : {n} (fin n, 8 >= width n) => Bit\nnthKat = blake2s (nthKatInput `{n}) == kats @ (`n : [8])\n\nnthKatInput : {n} (fin n) => [n][8]\nnthKatInput = take ([0 ... ] : [inf][8])\n\nkats = [ 0x69217a3079908094e11121d042354a7c1f55b6482ca1a51e1b250dfd1ed0eef9\n       , 0xe34d74dbaf4ff4c6abd871cc220451d2ea2648846c7757fbaac82fe51ad64bea\n       , 0xddad9ab15dac4549ba42f49d262496bef6c0bae1dd342a8808f8ea267c6e210c\n       , 0xe8f91c6ef232a041452ab0e149070cdd7dd1769e75b3a5921be37876c45c9900\n       , 0x0cc70e00348b86ba2944d0c32038b25c55584f90df2304f55fa332af5fb01e20\n       , 0xec1964191087a4fe9df1c795342a02ffc191a5b251764856ae5b8b5769f0c6cd\n       , 0xe1fa51618d7df4eb70cf0d5a9e906f806e9d19f7f4f01e3b621288e4120405d6\n       , 0x598001fafbe8f94ec66dc827d012cfcbba2228569f448e89ea2208c8bf769293\n       , 0xc7e887b546623635e93e0495598f1726821996c2377705b93a1f636f872bfa2d\n       , 0xc315a437dd28062a770d481967136b1b5eb88b21ee53d0329c5897126e9db02c\n       , 0xbb473deddc055fea6228f207da575347bb00404cd349d38c18026307a224cbff\n       , 0x687e1873a8277591bb33d9adf9a13912efefe557cafc39a7952623e47255f16d\n       , 0x1ac7ba754d6e2f94e0e86c46bfb262abbb74f450ef456d6b4d97aa80ce6da767\n       , 0x012c97809614816b5d9494477d4b687d15b96eb69c0e8074a8516f31224b5c98\n       , 0x91ffd26cfa4da5134c7ea262f7889c329f61f6a657225cc212f40056d986b3f4\n       , 0xd97c828d8182a72180a06a78268330673f7c4e0635947c04c02323fd45c0a52d\n       , 0xefc04cdc391c7e9119bd38668a534e65fe31036d6a62112e44ebeb11f9c57080\n       , 0x992cf5c053442a5fbc4faf583e04e50bb70d2f39fbb6a503f89e56a63e18578a\n       , 0x38640e9f21983e67b539caccae5ecf615ae2764f75a09c9c59b76483c1fbc735\n       , 0x213dd34c7efe4fb27a6b35f6b4000d1fe03281af3c723e5c9f94747a5f31cd3b\n       , 0xec246eeeb9ced3f7ad33ed28660dd9bb0732513db4e2fa278b60cde3682a4ccd\n       , 0xac9b61d446648c3005d7892bf3a8719f4c8181cfdcbc2b79fef10a279b911095\n       , 0x7bf8b22959e34e3a43f7079223e83a9754617d391e213dfd808e41b9bead4ce7\n       , 0x68d4b5d4fa0e302b64ccc5af792913ac4c88ec95c07ddf40694256eb88ce9f3d\n       , 0xb2c2420f05f9abe36315919336b37e4e0fa33ff7e76a492767006fdb5d935462\n       , 0x134f61bbd0bbb69aed5343904551a3e6c1aa7dcdd77e903e7023eb7c60320aa7\n       , 0x4693f9bff7d4f3986a7d176e6e06f72ad1490d805c99e25347b8de77b4db6d9b\n       , 0x853e26f741953b0fd5bdb424e8ab9e8b3750eaa8ef61e47902c91e554e9c73b9\n       , 0xf7de536361abaa0e158156cf0ea4f63a99b5e4054f8fa4c9d45f6285cad55694\n       , 0x4c230608860a99ae8d7bd5c2cc17fa52096b9a61bedb17cb7617864ad29ca7a6\n       , 0xaeb920ea87952dadb1fb759291e3388139a872865001886ed84752e93c250c2a\n       , 0xaba4ad9b480b9df3d08ca5e87b0c2440d4e4ea21224c2eb42cbae469d089b931\n       , 0x05825607d7fdf2d82ef4c3c8c2aea961ad98d60edff7d018983e21204c0d93d1\n       , 0xa742f8b6af82d8a6ca2357c5f1cf91defbd066267d75c048b352366585025962\n       , 0x2bcac89599000b42c95ae23835a713704ed79789c84fef149a874ff733f017a2\n       , 0xac1ed07d048f105a9e5b7ab85b09a492d5baff14b8bfb0e9fd789486eea2b974\n       , 0xe48d0ecfaf497d5b27c25d99e156cb0579d440d6e31fb62473696dbf95e010e4\n       , 0x12a91fadf8b21644fd0f934f3c4a8f62ba862ffd20e8e961154c15c13884ed3d\n       , 0x7cbee96e139897dc98fbef3be81ad4d964d235cb12141fb66727e6e5df73a878\n       , 0xebf66abb597ae572a7297cb0871e355accafad8377b8e78bf164ce2a18de4baf\n       , 0x71b933b07e4ff7818ce059d008829e453c6ff02ec0a7db393fc2d870f37a7286\n       , 0x7cf7c51331220b8d3ebaed9c29398a16d98156e2613cb088f2b0e08a1be4cf4f\n       , 0x3e41a108e0f64ad276b979e1ce068279e16f7bc7e4aa1d211e17b81161df1602\n       , 0x886502a82ab47ba8d86710aa9de3d46ea65c47af6ee8de450cceb8b11b045f50\n       , 0xc021bc5f0954fee94f46ea09487e10a84840d02f64810bc08d9e551f7d416814\n       , 0x2030516e8a5fe19ae79c336fce26382a749d3fd0ec91e537d4bd2358c12dfb22\n       , 0x556698dac8317fd36dfbdf25a79cb112d5425860605cbaf507f23bf7e9f42afe\n       , 0x2f867ba67773fdc3e92fced99a6409ad39d0b880fde8f109a81730c4451d0178\n       , 0x172ec218f119dfae98896dff29dd9876c94af87417f9ae4c7014bb4e4b96afc7\n       , 0x3f85814a18195f879aa962f95d26bd82a278f2b82320218f6b3bd6f7f667a6d9\n       , 0x1b618fbaa566b3d498c12e982c9ec52e4da85a8c54f38f34c090394f23c184c1\n       , 0x0c758fb5692ffd41a3575d0af00cc7fbf2cbe5905a58323a88ae4244f6e4c993\n       , 0xa931360cad628c7f12a6c1c4b753b0f4062aef3ce65a1ae3f19369dadf3ae23d\n       , 0xcbac7d773b1e3b3c6691d7abb7e9df045c8ba19268ded153207f5e804352ec5d\n       , 0x23a196d3802ed3c1b384019a82325840d32f71950c4580b03445e0898e14053c\n       , 0xf4495470f226c8c214be08fdfad4bc4a2a9dbea9136a210df0d4b64929e6fc14\n       , 0xe290dd270b467f34ab1c002d340fa016257ff19e5833fdbbf2cb401c3b2817de\n       , 0x9fc7b5ded3c15042b2a6582dc39be016d24a682d5e61ad1eff9c63309848f706\n       , 0x8cca67a36d17d5e6341cb592fd7bef9926c9e3aa1027ea11a7d8bd260b576e04\n       , 0x409392f560f86831da4373ee5e0074260595d7bc24183b60ed700d4583d3f6f0\n       , 0x2802165de090915546f3398cd849164a19f92adbc361adc99b0f20c8ea071054\n       , 0xad839168d9f8a4be95ba9ef9a692f07256ae43fe6f9864e290691b0256ce50a9\n       , 0x75fdaa5038c284b86d6e8affe8b2807e467b86600e79af3689fbc06328cbf894\n       , 0xe57cb79487dd57902432b250733813bd96a84efce59f650fac26e6696aefafc3\n       , 0x56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e\n       , 0x1b53ee94aaf34e4b159d48de352c7f0661d0a40edff95a0b1639b4090e974472\n       , 0x05705e2a81757c14bd383ea98dda544eb10e6bc07bae435e2518dbe133525375\n       , 0xd8b2866e8a309db53e529ec32911d82f5ca16cff76216891a9676aa31aaa6c42\n       , 0xf5041c241270eb04c71ec2c95d4c38d803b1237b0f29fd4db3eb397669e88699\n       , 0x9a4ce077c349322f595e0ee79ed0da5fab66752cbfef8f87d0e9d0723c7530dd\n       , 0x657b09f3d0f52b5b8f2f97163a0edf0c04f075408a07bbeb3a4101a891990d62\n       , 0x1e3f7bd5a58fa533344aa8ed3ac122bb9e70d4ef50d004530821948f5fe6315a\n       , 0x80dccf3fd83dfd0d35aa28585922ab89d5313997673eaf905cea9c0b225c7b5f\n       , 0x8a0d0fbf6377d83bb08b514b4b1c43acc95d751714f8925645cb6bc856ca150a\n       , 0x9fa5b487738ad2844cc6348a901918f659a3b89e9c0dfeead30dd94bcf42ef8e\n       , 0x80832c4a1677f5ea2560f668e9354dd36997f03728cfa55e1b38337c0c9ef818\n       , 0xab37ddb683137e74080d026b590b96ae9bb447722f305a5ac570ec1df9b1743c\n       , 0x3ee735a694c2559b693aa68629361e15d12265ad6a3dedf488b0b00fac9754ba\n       , 0xd6fcd23219b647e4cbd5eb2d0ad01ec8838a4b2901fc325cc3701981ca6c888b\n       , 0x0520ec2f5bf7a755dacb50c6bf233e3515434763db0139ccd9faefbb8207612d\n       , 0xaff3b75f3f581264d7661662b92f5ad37c1d32bd45ff81a4ed8adc9ef30dd989\n       , 0xd0dd650befd3ba63dc25102c627c921b9cbeb0b130686935b5c927cb7ccd5e3b\n       , 0xe1149816b10a8514fb3e2cab2c08bee9f73ce76221701246a589bbb67302d8a9\n       , 0x7da3f441de9054317e72b5dbf979da01e6bceebb8478eae6a22849d90292635c\n       , 0x1230b1fc8a7d9215edc2d4a2decbdd0a6e216c924278c91fc5d10e7d60192d94\n       , 0x5750d716b4808f751febc38806ba170bf6d5199a7816be514e3f932fbe0cb871\n       , 0x6fc59b2f10feba954aa6820b3ca987ee81d5cc1da3c63ce827301c569dfb39ce\n       , 0xc7c3fe1eebdc7b5a939326e8ddb83e8bf2b780b65678cb62f208b040abdd35e2\n       , 0x0c75c1a15cf34a314ee478f4a5ce0b8a6b36528ef7a820696c3e4246c5a15864\n       , 0x216dc12a108569a3c7cdde4aed43a6c330139dda3ccc4a108905db3861899050\n       , 0xa57be6ae6756f28b02f59dadf7e0d7d8807f10fa15ced1ad3585521a1d995a89\n       , 0x816aef875953716cd7a581f732f53dd435dab66d09c361d2d6592de17755d8a8\n       , 0x9a76893226693b6ea97e6a738f9d10fb3d0b43ae0e8b7d8123ea76ce97989c7e\n       , 0x8daedb9a271529dbb7dc3b607fe5eb2d3211770758dd3b0a3593d2d7954e2d5b\n       , 0x16dbc0aa5dd2c774f505100f733786d8a175fcbbb59c43e1fbff3e1eaf31cb4a\n       , 0x8606cb899c6aeaf51b9db0fe4924a9fd5dabc19f8826f2bc1c1d7da14d2c2c99\n       , 0x8479731aeda57bd37eadb51a507e307f3bd95e69dbca94f3bc21726066ad6dfd\n       , 0x58473a9ea82efa3f3b3d8fc83ed8863127b33ae8deae6307201edb6dde61de29\n       , 0x9a9255d53af116de8ba27ce35b4c7e15640657a0fcb888c70d95431dacd8f830\n       , 0x9eb05ffba39fd8596a45493e18d2510bf3ef065c51d6e13abe66aa57e05cfdb7\n       , 0x81dcc3a505eace3f879d8f702776770f9df50e521d1428a85daf04f9ad2150e0\n       , 0xe3e3c4aa3acbbc85332af9d564bc24165e1687f6b1adcbfae77a8f03c72ac28c\n       , 0x6746c80b4eb56aea45e64e7289bba3edbf45ecf8206481ff6302122984cd526a\n       , 0x2b628e52764d7d62c0868b212357cdd12d9149822f4e9845d918a08d1ae990c0\n       , 0xe4bfe80d58c91994613909dc4b1a12496896c004af7b5701483de45d2823d78e\n       , 0xebb4ba150cef2734345b5d641bbed03a21eafae933c99e009212ef04574a8530\n       , 0x3966ec73b154acc697ac5cf5b24b40bdb0db9e398836d76d4b880e3b2af1aa27\n       , 0xef7e4831b3a84636518d6e4bfce64a43db2a5dda9cca2b44f39033bdc40d6243\n       , 0x7abf6acf5c8e549ddbb15ae8d8b388c1c197e698737c9785501ed1f94930b7d9\n       , 0x88018ded66813f0ca95def474c630692019967b9e36888dadd94124719b682f6\n       , 0x3930876b9fc7529036b008b1b8bb997522a441635a0c25ec02fb6d9026e55a97\n       , 0x0a4049d57e833b5695fac93dd1fbef3166b44b12ad11248662383ae051e15827\n       , 0x81dcc0678bb6a765e48c3209654fe90089ce44ff5618477e39ab286476df052b\n       , 0xe69b3a36a4461912dc08346b11ddcb9db796f885fd01936e662fe29297b099a4\n       , 0x5ac6503b0d8da6917646e6dcc87edc58e94245324cc204f4dd4af01563acd427\n       , 0xdf6dda21359a30bc271780971c1abd56a6ef167e480887888e73a86d3bf605e9\n       , 0xe8e6e47071e7b7df2580f225cfbbedf84ce67746626628d33097e4b7dc571107\n       , 0x53e40ead62051e19cb9ba8133e3e5c1ce00ddcad8acf342a224360b0acc14777\n       , 0x9ccd53fe80be786aa984638462fb28afdf122b34d78f4687ec632bb19de2371a\n       , 0xcbd48052c48d788466a3e8118c56c97fe146e5546faaf93e2bc3c47e45939753\n       , 0x256883b14e2af44dadb28e1b34b2ac0f0f4c91c34ec9169e29036158acaa95b9\n       , 0x4471b91ab42db7c4dd8490ab95a2ee8d04e3ef5c3d6fc71ac74b2b26914d1641\n       , 0xa5eb08038f8f1155ed86e631906fc13095f6bba41de5d4e795758ec8c8df8af1\n       , 0xdc1db64ed8b48a910e060a6b866374c578784e9ac49ab2774092ac71501934ac\n       , 0x285413b2f2ee873d34319ee0bbfbb90f32da434cc87e3db5ed121bb398ed964b\n       , 0x0216e0f81f750f26f1998bc3934e3e124c9945e685a60b25e8fbd9625ab6b599\n       , 0x38c410f5b9d4072050755b31dca89fd5395c6785eeb3d790f320ff941c5a93bf\n       , 0xf18417b39d617ab1c18fdf91ebd0fc6d5516bb34cf39364037bce81fa04cecb1\n       , 0x1fa877de67259d19863a2a34bcc6962a2b25fcbf5cbecd7ede8f1fa36688a796\n       , 0x5bd169e67c82c2c2e98ef7008bdf261f2ddf30b1c00f9e7f275bb3e8a28dc9a2\n       , 0xc80abeebb669ad5deeb5f5ec8ea6b7a05ddf7d31ec4c0a2ee20b0b98caec6746\n       , 0xe76d3fbda5ba374e6bf8e50fadc3bbb9ba5c206ebdec89a3a54cf3dd84a07016\n       , 0x7bba9dc5b5db2071d17752b1044c1eced96aaf2dd46e9b433750e8ea0dcc1870\n       , 0xf29b1b1ab9bab163018ee3da15232cca78ec52dbc34eda5b822ec1d80fc21bd0\n       , 0x9ee3e3e7e900f1e11d308c4b2b3076d272cf70124f9f51e1da60f37846cdd2f4\n       , 0x70ea3b0176927d9096a18508cd123a290325920a9d00a89b5de04273fbc76b85\n       , 0x67de25c02a4aaba23bdc973c8bb0b5796d47cc0659d43dff1f97de174963b68e\n       , 0xb2168e4e0f18b0e64100b517ed95257d73f0620df885c13d2ecf79367b384cee\n       , 0x2e7dec2428853b2c71760745541f7afe9825b5dd77df06511d8441a94bacc927\n       , 0xca9ffac4c43f0b48461dc5c263bea3f6f00611ceacabf6f895ba2b0101dbb68d\n       , 0x7410d42d8fd1d5e9d2f5815cb93417998828ef3c4230bfbd412df0a4a7a2507a\n       , 0x5010f684516dccd0b6ee0852c2512b4dc0066cf0d56f35302978db8ae32c6a81\n       , 0xacaab585f7b79b719935ceb89523ddc54827f75c56883856154a56cdcd5ee988\n       , 0x666de5d1440fee7331aaf0123a62ef2d8ba57453a0769635ac6cd01e633f7712\n       , 0xa6f98658f6eabaf902d8b3871a4b101d16196e8a4b241e1558fe29966e103e8d\n       , 0x891546a8b29f3047ddcfe5b00e45fd55756373105ea8637dfcff547b6ea9535f\n       , 0x18dfbc1ac5d25b0761137dbd22c17c829d0f0ef1d82344e9c89c286694da24e8\n       , 0xb54b9b67f8fed54bbf5a2666dbdf4b23cff1d1b6f4afc985b2e6d3305a9ff80f\n       , 0x7db442e132ba59bc1289aa98b0d3e806004f8ec12811af1e2e33c69bfde729e1\n       , 0x250f37cdc15e817d2f160d9956c71fe3eb5db74556e4adf9a4ffafba74010396\n       , 0x4ab8a3dd1ddf8ad43dab13a27f66a6544f290597fa96040e0e1db9263aa479f8\n       , 0xee61727a0766df939ccdc860334044c79a3c9b156200bc3aa32973483d8341ae\n       , 0x3f68c7ec63ac11ebb98f94b339b05c104984fda50103060144e5a2bfccc9da95\n       , 0x056f29816b8af8f56682bc4d7cf094111da7733e726cd13d6b3e8ea03e92a0d5\n       , 0xf5ec43a28acbeff1f3318a5bcac7c66ddb5230b79db2d105bcbe15f3c1148d69\n       , 0x2a6960ad1d8dd547555cfbd5e4600f1eaa1c8eda34de0374ec4a26eaaaa33b4e\n       , 0xdcc1ea7baab93384f76b796866199754742f7b96d6b4c120165c04a6c4f5ce10\n       , 0x13d5df179221379c6a78c07c793ff53487cae6bf9fe882541ab0e735e3eada3b\n       , 0x8c59e4407641a01e8ff91f9980dc236f4ecd6fcf52589a099a961633967714e1\n       , 0x833b1ac6a251fd08fd6d908fea2a4ee1e040bca93fc1a38ec3820e0c10bd82ea\n       , 0xa244f927f3b40b8f6c391570c765418f2f6e708eac9006c51a7feff4af3b2b9e\n       , 0x3d99ed9550cf1196e6c4d20c259620f858c3d703374c128ce7b590310c83046d\n       , 0x2b35c47d7b87761f0ae43ac56ac27b9f25830367b595be8c240e94600c6e3312\n       , 0x5d11ed37d24dc767305cb7e1467d87c065ac4bc8a426de38991ff59aa8735d02\n       , 0xb836478e1ca0640dce6fd910a5096272c8330990cd97864ac2bf14ef6b23914a\n       , 0x9100f946d6ccde3a597f90d39fc1215baddc7413643d85c21c3eee5d2dd32894\n       , 0xda70eedd23e663aa1a74b9766935b479222a72afba5c795158dad41a3bd77e40\n       , 0xf067ed6a0dbd43aa0a9254e69fd66bdd8acb87de936c258cfb02285f2c11fa79\n       , 0x715c99c7d57580cf9753b4c1d795e45a83fbb228c0d36fbe20faf39bdd6d4e85\n       , 0xe457d6ad1e67cb9bbd17cbd698fa6d7dae0c9b7ad6cbd6539634e32a719c8492\n       , 0xece3ea8103e02483c64a70a4bdcee8ceb6278f2533f3f48dbeedfba94531d4ae\n       , 0x388aa5d3667a97c68d3d56f8f3ee8d3d36091f17fe5d1b0d5d84c93b2ffe40bd\n       , 0x8b6b31b9ad7c3d5cd84bf98947b9cdb59df8a25ff738101013be4fd65e1dd1a3\n       , 0x066291f6bbd25f3c853db7d8b95c9a1cfb9bf1c1c99fb95a9b7869d90f1c2903\n       , 0xa707efbccdceed42967a66f5539b93ed7560d467304016c4780d7755a565d4c4\n       , 0x38c53dfb70be7e792b07a6a35b8a6a0aba02c5c5f38baf5c823fdfd9e42d657e\n       , 0xf2911386501d9ab9d720cf8ad10503d5634bf4b7d12b56dfb74fecc6e4093f68\n       , 0xc6f2bdd52b81e6e4f6595abd4d7fb31f651169d00ff326926b34947b28a83959\n       , 0x293d94b18c98bb3223366b8ce74c28fbdf28e1f84a3350b0eb2d1804a577579b\n       , 0x2c2fa5c0b51533165bc375c22e2781768270a383985d13bd6b67b6fd67f889eb\n       , 0xcaa09b82b72562e43f4b2275c091918e624d911661cc811bb5faec51f6088ef7\n       , 0x24761e45e674395379fb17729c78cb939e6f74c5dffb9c961f495982c3ed1fe3\n       , 0x55b70a82131ec94888d7ab54a7c515255c3938bb10bc784dc9b67f076e341a73\n       , 0x6ab9057b977ebc3ca4d4ce74506c25cccdc566497c450b5415a39486f8657a03\n       , 0x24066deee0ecee15a45f0a326d0f8dbc79761ebb93cf8c0377af440978fcf994\n       , 0x20000d3f66ba76860d5a950688b9aa0d76cfea59b005d859914b1a46653a939b\n       , 0xb92daa79603e3bdbc3bfe0f419e409b2ea10dc435beefe2959da16895d5dca1c\n       , 0xe947948705b206d572b0e8f62f66a6551cbd6bc305d26ce7539a12f9aadf7571\n       , 0x3d67c1b3f9b23910e3d35e6b0f2ccf44a0b540a45c18ba3c36264dd48e96af6a\n       , 0xc7558babda04bccb764d0bbf3358425141902d22391d9f8c59159fec9e49b151\n       , 0x0b732bb035675a50ff58f2c242e4710aece64670079c13044c79c9b7491f7000\n       , 0xd120b5ef6d57ebf06eaf96bc933c967b16cbe6e2bf00741c30aa1c54ba64801f\n       , 0x58d212ad6f58aef0f80116b441e57f6195bfef26b61463edec1183cdb04fe76d\n       , 0xb8836f51d1e29bdfdba325565360268b8fad627473edecef7eaefee837c74003\n       , 0xc547a3c124ae5685ffa7b8edaf96ec86f8b2d0d50cee8be3b1f0c76763069d9c\n       , 0x5d168b769a2f67853d6295f7568be40bb7a16b8d65ba87635d1978d2ab11ba2a\n       , 0xa2f675dc7302638cb60201064ca55077714d71fe096a315f2fe7401277caa5af\n       , 0xc8aab5cd0160ae78cd2e8ac5fb0e093cdb5c4b6052a0a97bb04216826fa7a437\n       , 0xff68ca4035bfeb43fbf145fddd5e43f1cea54f11f7bee13058f027329a4a5fa4\n       , 0x1d4e5487ae3c740f2ba6e541ac91bc2bfcd2999c518d807b426748803a350fd4\n       , 0x6d244e1a06ce4ef578dd0f63aff0936706735119ca9c8d22d86c801414ab9741\n       , 0xdecf7329dbcc827b8fc524c9431e8998029ece12ce93b7b2f3e769a941fb8cea\n       , 0x2fafcc0f2e63cbd07755be7b75ecea0adff9aa5ede2a52fdab4dfd0374cd483f\n       , 0xaa85010dd46a546b535ef4cf5f07d65161e89828f3a77db7b9b56f0df59aae45\n       , 0x07e8e1ee732cb0d356c9c0d1069c89d17adf6a9a334f745ec7867332548ca8e9\n       , 0x0e01e81cada8162bfd5f8a8c818a6c69fedf02ceb5208523cbe5313b89ca1053\n       , 0x6bb6c6472655084399852e00249f8cb247896d392b02d73b7f0dd818e1e29b07\n       , 0x42d4636e2060f08f41c882e76b396b112ef627cc24c43dd5f83a1d1a7ead711a\n       , 0x4858c9a188b0234fb9a8d47d0b4133650a030bd0611b87c3892e94951f8df852\n       , 0x3fab3e36988d445a51c8783e531be3a02be40cd04796cfb61d40347442d3f794\n       , 0xebabc49636bd433d2ec8f0e518732ef8fa21d4d071cc3bc46cd79fa38a28b810\n       , 0xa1d0343523b893fca84f47feb4a64d350a17d8eef5497ece697d02d79178b591\n       , 0x262ebfd9130b7d28760d08ef8bfd3b86cdd3b2113d2caef7ea951a303dfa3846\n       , 0xf76158edd50a154fa78203ed2362932fcb8253aae378903eded1e03f7021a257\n       , 0x26178e950ac722f67ae56e571b284c0207684a6334a17748a94d260bc5f55274\n       , 0xc378d1e493b40ef11fe6a15d9c2737a37809634c5abad5b33d7e393b4ae05d03\n       , 0x984bd8379101be8fd80612d8ea2959a7865ec9718523550107ae3938df32011b\n       , 0xc6f25a812a144858ac5ced37a93a9f4759ba0b1c0fdc431dce35f9ec1f1f4a99\n       , 0x924c75c94424ff75e74b8b4e94358958b027b171df5e57899ad0d4dac37353b6\n       , 0x0af35892a63f45931f6846ed190361cd073089e077165714b50b81a2e3dd9ba1\n       , 0xcc80cefb26c3b2b0daef233e606d5ffc80fa17427d18e30489673e06ef4b87f7\n       , 0xc2f8c8117447f3978b0818dcf6f70116ac56fd184dd1278494e103fc6d74a887\n       , 0xbdecf6bfc1ba0df6e862c831992207796acc797968358828c06e7a51e090098f\n       , 0x24d1a26e3dab02fe4572d2aa7dbd3ec30f0693db26f273d0ab2cb0c13b5e6451\n       , 0xec56f58b09299a300b140565d7d3e68782b6e2fbeb4b7ea97ac057989061dd3f\n       , 0x11a437c1aba3c119ddfab31b3e8c841deeeb913ef57f7e48f2c9cf5a28fa42bc\n       , 0x53c7e6114b850a2cb496c9b3c69a623eaea2cb1d33dd817e4765edaa6823c228\n       , 0x154c3e96fee5db14f8773e18af14857913509da999b46cdd3d4c169760c83ad2\n       , 0x40b9916f093e027a8786641818920620472fbcf68f701d1b680632e6996bded3\n       , 0x24c4cbba07119831a726b05305d96da02ff8b148f0da440fe233bcaa32c72f6f\n       , 0x5d201510250020b783689688abbf8ecf2594a96a08f2bfec6ce0574465dded71\n       , 0x043b97e336ee6fdbbe2b50f22af83275a4084805d2d5645962454b6c9b8053a0\n       , 0x564835cbaea774948568be36cf52fcdd83934eb0a27512dbe3e2db47b9e6635a\n       , 0xf21c33f47bde40a2a101c9cde8027aaf61a3137de2422b30035a04c270894183\n       , 0x9db0ef74e66cbb842eb0e07343a03c5c567e372b3f23b943c788a4f250f67891\n       , 0xab8d08655ff1d3fe8758d562235fd23e7cf9dcaad658872a49e5d3183b6ccebd\n       , 0x6f27f77e7bcf46a1e963ade0309733543031dccdd47caac174d7d27ce8077e8b\n       , 0xe3cd54da7e444caa6207569525a670ebae1278de4e3fe2684b3e33f5ef90cc1b\n       , 0xb2c3e33a51d22c4c08fc0989c873c9cc4150579b1e6163fa694ad51d53d712dc\n       , 0xbe7fda983e13189b4c77e0a80920b6e0e0ea80c3b84dbe7e7117d253f48112f4\n       , 0xb6008c28fae08aa427e5bd3aad36f10021f16c77cfeabed07f97cc7dc1f1284a\n       , 0x6e4e6760c538f2e97b3adbfbbcde57f8966b7ea8fcb5bf7efec913fd2a2b0c55\n       , 0x4ae51fd1834aa5bd9a6f7ec39fc663338dc5d2e20761566d90cc68b1cb875ed8\n       , 0xb673aad75ab1fdb5401abfa1bf89f3add2ebc468df3624a478f4fe859d8d55e2\n       , 0x13c9471a9855913539836660398da0f3f99ada08479c69d1b7fcaa3461dd7e59\n       , 0x2c11f4a7f99a1d23a58bb636350fe849f29cbac1b2a1112d9f1ed5bc5b313ccd\n       , 0xc7d3c0706b11ae741c05a1ef150dd65b5494d6d54c9a86e2617854e6aeeebbd9\n       , 0x194e10c93893afa064c3ac04c0dd808d791c3d4b7556e89d8d9cb225c4b33339\n       , 0x6fc4988b8f78546b1688991845908f134b6a482e6994b3d48317bf08db292185\n       , 0x5665beb8b0955525813b5981cd142ed4d03fba38a6f3e5ad268e0cc270d1cd11\n       , 0xb883d68f5fe51936431ba4256738053b1d0426d4cb64b16e83badc5e9fbe3b81\n       , 0x53e7b27ea59c2f6dbb50769e43554df35af89f4822d0466b007dd6f6deafff02\n       , 0x1f1a0229d4640f01901588d9dec22d13fc3eb34a61b32938efbf5334b2800afa\n       , 0xc2b405afa0fa6668852aee4d88040853fab800e72b57581418e5506f214c7d1f\n       , 0xc08aa1c286d709fdc7473744977188c895ba011014247e4efa8d07e78fec695c\n       , 0xf03f5789d3336b80d002d59fdf918bdb775b00956ed5528e86aa994acb38fe2d\n       ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/TestHMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the HMAC-SHA256 implementation in the TestHMAC module, ensuring that the computed HMAC values match the expected test vectors provided in the 'pass' property."},{"role":"assistant","content":"```cryptol\nmodule TestHMAC where\n\nimport HMAC\nimport SHA256\n\nproperty pass =\n    ~zero ==\n    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] \"Hi There\" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\n    , hmacSHA256 \"Jefe\" \"what do ya want for nothing?\" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\n    ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/CryptoBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness and security properties of the `crypto_box` and `crypto_box_open` functions in the CryptoBox module. Specifically, ensure that decrypting an encrypted message with the correct keys and nonce recovers the original message, and that authentication tags are correctly validated. Include properties that test the equivalence of encryption and decryption, and verify known answer tests (KATs) for the implemented cryptographic primitives."},{"role":"assistant","content":"```cryptol\nmodule CryptoBox where\n\nimport Salsa20\nimport Poly1305\nimport CfrgCurves\n\ncrypto_box : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes)) => [msgBytes][8] -> [24][8] -> Public25519 -> Private25519 -> [msgBytes + 16][8]\ncrypto_box m n pub priv = crypto_secretbox m k n\n where\n  s          = Curve25519 priv pub\n  k          = HSalsa20_bytes `{r=20} s zero\n\ncrypto_box_open : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes)) => [msgBytes+16][8] -> [24][8] -> Public25519 -> Private25519 -> (Bit,[msgBytes][8])\ncrypto_box_open box n pub priv = crypto_secretbox_open box k n\n where\n  (tag,ct)  = splitAt `{16} box\n  s         = Curve25519 priv pub\n  k         = HSalsa20_bytes `{r=20} s zero\n\ncrypto_secretbox : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes))\n                => [msgBytes][8] -> [32][8] -> [24][8] -> [msgBytes + 16][8]\ncrypto_secretbox m k n = box\n where\n  blob       = XSalsa20_encrypt `{r=20} k n ((zero : [32][8]) # m)\n  authKey    = join (take `{32} blob)\n  ciphertext = drop `{32} blob\n  authTag    = Poly1305 authKey ciphertext\n  box        = authTag # ciphertext\n\ncrypto_secretbox_open : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes))\n                     => [msgBytes + 16][8] -> [32][8] -> [24][8] -> (Bit,[msgBytes][8])\ncrypto_secretbox_open box k n = (valid,pt)\n where\n  (tag,ct)  = splitAt `{16} box\n  blob      = XSalsa20_encrypt `{r=20} k n ((zero : [32][8]) # ct)\n  authKey   = join (take `{32} blob)\n  plaintext = drop blob                  : [msgBytes][8]\n  cTag      = Poly1305 authKey ct\n  valid     = cTag == tag\n  pt        = if valid then plaintext else zero\n\nproperty cat_in_a_box priv1 priv2 msg nonce = open == msg\n  where pub1 = Curve25519 priv1 basePoint25519\n        pub2 = Curve25519 priv2 basePoint25519\n        box  = crypto_box (msg : [100][8]) nonce pub2 priv1\n        open = (crypto_box_open box nonce pub1 priv2).1\n\nproperty hat_in_a_box k msg nonce = open == msg\n  where box  = crypto_secretbox (msg : [88][8]) k nonce\n        open = (crypto_secretbox_open box k nonce).1\n\nproperty crypto_box_kats = zero != [ katTest1 ]\n\n\/\/ KAT generated from sodium\nkatTest1 = crypto_secretbox \"hello\" zero zero == split 0xc769f9d535dc338e99ac93440502c7ceae5bd79391\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Salsa20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties and verification scripts to formally verify the correctness and security properties of the Salsa20 cipher implementation in the given file. This should include proving that the quarterround, rowround, columnround, and doubleround functions behave as specified by their test vectors, that the Salsa20 function is bijective and collision-resistant, and that the Salsa20_expansion and XSalsa20_encrypt functions correctly implement the key expansion and encryption steps. Additionally, verify the equivalence of optimized and original versions of rowround and columnround, and prove any stated theorems about the cipher's internal transformations."},{"role":"assistant","content":"```cryptol\n\/\/ see http:\/\/cr.yp.to\/snuffle\/spec.pdf\n\nmodule Salsa20 where\n\nimport LittleEndian\n\nquarterround : [4][32] -> [4][32]\nquarterround [y0, y1, y2, y3] = [z0, z1, z2, z3]\n  where\n    z1 = y1 ^ ((y0 + y3) <<< 0x7)\n    z2 = y2 ^ ((z1 + y0) <<< 0x9)\n    z3 = y3 ^ ((z2 + z1) <<< 0xd)\n    z0 = y0 ^ ((z3 + z2) <<< 0x12)\n\nproperty quarterround_passes_tests =\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000000] == [0x00000000, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (quarterround [0x00000001, 0x00000000, 0x00000000, 0x00000000] == [0x08008145, 0x00000080, 0x00010200, 0x20500000]) \/\\\n  (quarterround [0x00000000, 0x00000001, 0x00000000, 0x00000000] == [0x88000100, 0x00000001, 0x00000200, 0x00402000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000001, 0x00000000] == [0x80040000, 0x00000000, 0x00000001, 0x00002000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000001] == [0x00048044, 0x00000080, 0x00010000, 0x20100001]) \/\\\n  (quarterround [0xe7e8c006, 0xc4f9417d, 0x6479b4b2, 0x68c67137] == [0xe876d72b, 0x9361dfd5, 0xf1460244, 0x948541a3]) \/\\\n  (quarterround [0xd3917c5b, 0x55f1c407, 0x52a58a7a, 0x8f887a3b] == [0x3e2f308c, 0xd90a8f36, 0x6ab2a923, 0x2883524c])\n\nrowround : [16][32] -> [16][32]\nrowround [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15] =\n    [z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15]\n  where\n    [ z0,  z1,  z2,  z3] = quarterround [ y0,  y1,  y2,  y3]\n    [ z5,  z6,  z7,  z4] = quarterround [ y5,  y6,  y7,  y4]\n    [z10, z11,  z8,  z9] = quarterround [y10, y11,  y8,  y9]\n    [z15, z12, z13, z14] = quarterround [y15, y12, y13, y14]\n\nproperty rowround_passes_tests =\n  (rowround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n            [0x08008145, 0x00000080, 0x00010200, 0x20500000,\n             0x20100001, 0x00048044, 0x00000080, 0x00010000,\n             0x00000001, 0x00002000, 0x80040000, 0x00000000,\n             0x00000001, 0x00000200, 0x00402000, 0x88000100]) \/\\\n  (rowround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n             0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n             0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n             0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n            [0xa890d39d, 0x65d71596, 0xe9487daa, 0xc8ca6a86,\n             0x949d2192, 0x764b7754, 0xe408d9b9, 0x7a41b4d1,\n             0x3402e183, 0x3c3af432, 0x50669f96, 0xd89ef0a8,\n             0x0040ede5, 0xb545fbce, 0xd257ed4f, 0x1818882d])\n\n\nrowround_opt : [16][32] -> [16][32]\nrowround_opt ys = join [ (quarterround (yi<<<i))>>>i | yi <- split ys | i <- [0 .. 3] : [_][8] ]\n\nproperty rowround_opt_is_rowround ys = rowround ys == rowround_opt ys\n\ncolumnround : [16][32] -> [16][32]\ncolumnround [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15] =\n    [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15]\n  where\n    [ y0,  y4,  y8, y12] = quarterround [ x0,  x4,  x8, x12]\n    [ y5,  y9, y13,  y1] = quarterround [ x5,  x9, x13,  x1]\n    [y10, y14,  y2,  y6] = quarterround [x10, x14,  x2,  x6]\n    [y15,  y3,  y7, y11] = quarterround [x15,  x3,  x7, x11]\n\nproperty columnround_passes_tests =\n  (columnround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x10090288, 0x00000000, 0x00000000, 0x00000000,\n                0x00000101, 0x00000000, 0x00000000, 0x00000000,\n                0x00020401, 0x00000000, 0x00000000, 0x00000000,\n                0x40a04001, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (columnround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n                0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n                0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n                0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n               [0x8c9d190a, 0xce8e4c90, 0x1ef8e9d3, 0x1326a71a,\n                0x90a20123, 0xead3c4f3, 0x63a091a0, 0xf0708d69,\n                0x789b010c, 0xd195a681, 0xeb7d5504, 0xa774135c,\n                0x481c2027, 0x53a8e4b5, 0x4c1f89c5, 0x3f78c9c8])\n\n\ncolumnround_opt : [16][32] -> [16][32]\ncolumnround_opt xs = join (transpose [ (quarterround (xi<<<i))>>>i | xi <- transpose(split xs) | i <- [0 .. 3] : [_][8] ])\n\ncolumnround_opt_is_columnround xs = columnround xs == columnround_opt xs\n\nproperty columnround_is_transpose_of_rowround ys =\n  rowround ys == join(transpose(split`{4}(columnround xs)))\n  where xs = join(transpose(split`{4} ys))\n\ndoubleround : [16][32] -> [16][32]\ndoubleround(xs) = rowround(columnround(xs))\n\nproperty doubleround_passes_tests =\n  (doubleround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x8186a22d, 0x0040a284, 0x82479210, 0x06929051,\n                0x08000090, 0x02402200, 0x00004000, 0x00800000,\n                0x00010200, 0x20400000, 0x08008104, 0x00000000,\n                0x20500000, 0xa0000040, 0x0008180a, 0x612a8020]) \/\\\n  (doubleround [0xde501066, 0x6f9eb8f7, 0xe4fbbd9b, 0x454e3f57,\n                0xb75540d3, 0x43e93a4c, 0x3a6f2aa0, 0x726d6b36,\n                0x9243f484, 0x9145d1e8, 0x4fa9d247, 0xdc8dee11,\n                0x054bf545, 0x254dd653, 0xd9421b6d, 0x67b276c1] ==\n               [0xccaaf672, 0x23d960f7, 0x9153e63a, 0xcd9a60d0,\n                0x50440492, 0xf07cad19, 0xae344aa0, 0xdf4cfdfc,\n                0xca531c29, 0x8e7943db, 0xac1680cd, 0xd503ca00,\n                0xa74b2ad6, 0xbc331c5c, 0x1dda24c7, 0xee928277])\n\nSalsa20 : {r} (8 >= width r) => [64][8] -> [64][8]\nSalsa20 xs = join ar\n  where\n    ar = [ littleendian_inverse words | words <- xw + zs@(`r\/2 : [8]) ]\n    xw = [ littleendian xi | xi <- split xs ]\n    zs = [xw] # [ doubleround zi | zi <- zs ]\n\nproperty Salsa20_bijective a b = (a == b) || (Salsa20 `{r=20} a != Salsa20 `{r=20} b)\nproperty Salsa20_passes_tests =\n  (Salsa20 `{r=20}\n           [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0] ==\n           [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]) \/\\\n  (Salsa20 `{r=20}\n            [211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37, 191, 187, 234, 136,\n             49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,  86,  16, 179, 207,\n             31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113, 238,  55, 204,  36,\n             79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,  88, 118, 104,  54] ==\n           [109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,  26, 110, 170, 154,\n             29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,  69, 144,  51,  57,\n            118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35,  27, 111, 114, 114,\n            219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158, 179,  19,  48, 202]) \/\\\n  (Salsa20 `{r=20}\n           [ 88, 118, 104,  54,  79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,\n            191, 187, 234, 136, 211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37,\n             86,  16, 179, 207,  49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,\n            238,  55, 204,  36,  31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113] ==\n           [179,  19,  48, 202, 219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158,\n             26, 110, 170, 154, 109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,\n             69, 144,  51,  57,  29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,\n             27, 111, 114, 114, 118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35])\n\nproperty Salsa20_has_no_collisions x1 x2 =\n    x1 == x2 \\\/ doubleround x1 != doubleround x2\n\/\/   if(x1 != x2) then (doubleround x1) != (doubleround x2) else True\n\nproperty Salsa20_passes_scrypt_tests =\n  Salsa20 `{r=8}\n          [ 0x7e, 0x87, 0x9a, 0x21, 0x4f, 0x3e, 0xc9, 0x86, 0x7c, 0xa9, 0x40, 0xe6, 0x41, 0x71, 0x8f, 0x26\n          , 0xba, 0xee, 0x55, 0x5b, 0x8c, 0x61, 0xc1, 0xb5, 0x0d, 0xf8, 0x46, 0x11, 0x6d, 0xcd, 0x3b, 0x1d\n          , 0xee, 0x24, 0xf3, 0x19, 0xdf, 0x9b, 0x3d, 0x85, 0x14, 0x12, 0x1e, 0x4b, 0x5a, 0xc5, 0xaa, 0x32\n          , 0x76, 0x02, 0x1d, 0x29, 0x09, 0xc7, 0x48, 0x29, 0xed, 0xeb, 0xc6, 0x8d, 0xb8, 0xb8, 0xc2, 0x5e\n          ]\n   == [ 0xa4, 0x1f, 0x85, 0x9c, 0x66, 0x08, 0xcc, 0x99, 0x3b, 0x81, 0xca, 0xcb, 0x02, 0x0c, 0xef, 0x05\n      , 0x04, 0x4b, 0x21, 0x81, 0xa2, 0xfd, 0x33, 0x7d, 0xfd, 0x7b, 0x1c, 0x63, 0x96, 0x68, 0x2f, 0x29\n      , 0xb4, 0x39, 0x31, 0x68, 0xe3, 0xc9, 0xe6, 0xbc, 0xfe, 0x6b, 0xc5, 0xb7, 0xa0, 0x6d, 0x96, 0xba\n      , 0xe4, 0x24, 0xcc, 0x10, 0x2c, 0x91, 0x74, 0x5c, 0x24, 0xad, 0x67, 0x3d, 0xc7, 0x61, 0x8f, 0x81\n      ]\n\n\/\/ Salsa 20 supports two key sizes, [16][8] and [32][8]\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(k, n) = z\n  where\n    [s0, s1, s2, s3] = split \"expand 32-byte k\" : [4][4][8]\n    [t0, t1, t2, t3] = split \"expand 16-byte k\" : [4][4][8]\n    x = if(`a == (2 : [8])) then s0 # k0 # s1 # n # s2 # k1 # s3\n                            else t0 # k0 # t1 # n # t2 # k0 # t3\n    z = Salsa20 `{r=20} x\n    [k0, k1] = (split(k#zero)):[2][16][8]\n\nSalsa20_encrypt : {a, l} (a >= 1, 2 >= a, l <= 2^^70) => ([16*a][8], [8][8], [l][8]) -> [l][8]\nSalsa20_encrypt(k, v, m) = c\n  where\n    salsa = take (join [ Salsa20_expansion(k, v#(split i)) | i <- [0, 1 ... ] ])\n    c     = m ^ salsa\n\nHSalsa20 : {r} (8 >= width r) => Key -> Nonce -> [8][32]\nHSalsa20 key0 nonce0 = zs @@ ([0,5,10,15,6,7,8,9] : [_][8])\n  where\n  zs    = infZs @ (`r\/2 :[8])\n  infZs = [xs] # [ doubleround x | x <- infZs ]\n\n  nonce                         = [ littleendian (split n) | n <- split (join nonce0)]\n  [x0,x5,x10,x15]               = Salsa20_Constant\n  [x1,x2,x3,x4,x11,x12,x13,x14] = [ littleendian (split k) | k <- split (join key0)]\n  [x6,x7,x8,x9]                 = nonce @@ ([0..3] : [_][8])\n\n  xs : [16][32]\n  xs     = [x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15]\n\nHSalsa20_bytes : {r} (8 >= width r) => Key -> Nonce -> [32][8]\nHSalsa20_bytes key0 nonce0 = join [littleendian_inverse x | x <- HSalsa20 `{r=r} key0 nonce0]\n\ntype Key      = [256\/8][8]\ntype Nonce    = [192\/8][8]\ntype Counter  = [64]\n\nSalsa20_Constant : [4][32]\nSalsa20_Constant = [littleendian (split x) | x <- split (join \"expand 32-byte k\") : [4][32]]\n\nXSalsa20 : {r} (8 >= width r) => Key -> Nonce -> Counter -> [64][8]\nXSalsa20 key0 nonce0 ctr =\n    split (join [littleendian (split (x' + z')) | x' <- xs' | z' <- zs'])\n  where\n  nonce                         = [ littleendian (split n) | n <- split (join nonce0)]\n\n  subKey = HSalsa20 `{r=r} key0 nonce0 \/\/ 'zs' in the literature\n\n  [x'0,x'5,x'10,x'15]                   = Salsa20_Constant\n  [x'1,x'2,x'3,x'4,x'11,x'12,x'13,x'14] = subKey\n  [x'6,x'7]                             = nonce @@ ([4,5] : [_][8])\n  [x'8,x'9]                             = reverse (split ctr)\n\n  xs', zs' : [16][32]\n  xs'       = [ x'0 ,x'1 ,x'2 ,x'3 ,x'4 ,x'5 ,x'6 ,x'7 ,x'8\n              , x'9 ,x'10 ,x'11 ,x'12 ,x'13 ,x'14 ,x'15\n              ]\n  infZs'    = [xs'] # [ doubleround x | x <- infZs' ]\n  zs'       = infZs' @ (`r\/2 : [8])\n\nXSalsa20_expansion : {n,r} (8 >= width r, 64 >= width n) => Key -> Nonce -> [n][8]\nXSalsa20_expansion k n = take (join ks)\n   where\n   ks = [XSalsa20 `{r=r} k n i | i <- [0...]]\n\nXSalsa20_encrypt : {n,r} (8 >= width r, 64 >= width n) => Key -> Nonce -> [n][8] -> [n][8]\nXSalsa20_encrypt k n msg = ks ^ msg\n where ks = XSalsa20_expansion `{r=r} k n\n\nproperty test =\n    ct == [0x00, 0x2d, 0x45, 0x13, 0x84, 0x3f, 0xc2, 0x40, 0xc4, 0x01, 0xe5, 0x41]\n  where\n   ct    = XSalsa20_encrypt `{r=20} key nonce \"Hello world!\"\n   key   = \"this is 32-byte key for xsalsa20\"\n   nonce = \"24-byte nonce for xsalsa\"\n\nproperty theorem1 a = quarterround [a, -a, a, -a] == [a,-a,a,-a]\nproperty theorem2 a b c d = rowround val == val\n    where val    = [a,-a,a,-a\n                   ,b,-b,b,-b\n                   ,c,-c,c,-c\n                   ,d,-d,d,-d]\nproperty theorem3 a b c d = columnround val == val\n    where val    = [a,-b,c,-d\n                   ,-a,b,-c,d\n                   ,a,-b,c,-d\n                   ,-a,b,-c,d]\nproperty theorem4 a = doubleround val == val\n    where val    = [a,-a,a,-a\n                   ,-a,a,-a,a\n                   ,a,-a,a,-a\n                   ,-a,a,-a,a]\nproperty theorem7 a b =\n    a ^ b != diff \\\/ Salsa20Words a == Salsa20Words b\n where\n  diff = [ 0x80000000 | _ <- [0..15]:[_][4] ]\n\nSalsa20Words : [16][32] -> [16][32]\nSalsa20Words x = [join (reverse r) | r <- split `{each=4} (Salsa20 `{r=20} (join [reverse (split `{4} v) | v <- x]))]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/PBKDF2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the PBKDF2 implementation specialized to HMAC_SHA256 in the given module. Include properties that check the consistency of the iterative function F, the inner function, and the overall pbkdf2 output against known test vectors or expected cryptographic properties such as determinism, output length, and resistance to trivial collisions."},{"role":"assistant","content":"```cryptol\nmodule PBKDF2 where\n\nimport SHA256\nimport HMAC\n\n\/\/ PBKDF2 specialized to HMAC_SHA256 to avoid monomorphic type issues.\npbkdf2 : {pwBytes, saltBytes, dkLenBits, C}\n         ( 64 >= width (8 * pwBytes)\n         , dkLenBits >= 1\n         , fin dkLenBits\n         , C >= 1\n         , 16 >= width C\n         , 32 >= width (4 + saltBytes)\n         , 32 >= width ((dkLenBits + 255)\/256)\n         )\n      => [pwBytes][8] -> [saltBytes][8] -> [dkLenBits]\npbkdf2 P S = take `{dkLenBits} (join Ts)\n where\n Ts : [_][256]\n Ts = [ inner `{C=C} P (split (hmacSHA256 P (S # split i))) | i <- [1..len] : [_][32] ]\n type len = (dkLenBits + 255)\/256\n\ninner : {pwBytes, C}\n         ( 64 >= width (8 * pwBytes)\n         , C >= 1, 16 >= width C\n         )\n     =>  [pwBytes][8] -> [32][8] -> [256]\ninner P U0 = (Ts @ 0).0  where\n  \/\/ Ts : [_][([256],[32][8])]\n  Ts = [(join U0, U0)] # [ F P t u  | _ <- [1..C] : [_][16] | (t,u) <- Ts ]\n\nF : {pwBytes} ( 64 >= width (8 * pwBytes)\n              ) => [pwBytes][8] -> [256] -> [32][8] -> ([256],[32][8])\nF P Tprev Uprev = (Tnext,Unext)\n  where\n  Unext = split (hmacSHA256 P Uprev)\n  Tnext = Tprev ^ join Unext\n\n\ntest1 : Bit\nproperty test1 = pbkdf2 `{C=1,dkLenBits=64*8} \"passwd\" \"salt\" == 0x55ac046e56e3089fec1691c22544b605f94185216dde0465e68b9d57c20dacbc49ca9cccf179b645991664b39d77ef317c71b845b1e30bd509112041d3a19783\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Base64.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the Base64 encoding and decoding functions in the given module. Specifically, create properties that check: 1) encoding followed by decoding returns the original input (round-trip property), 2) the output of base64enc conforms to the expected length and padding rules, and 3) base64dec correctly counts the number of padding characters. Ensure the properties are suitable for :check or :prove commands in Cryptol."},{"role":"assistant","content":"```cryptol\nmodule Base64 where\n\ntype Enc64 n = 4*(((3-(n%3))%3) + n)\/3\n\nbase64enc : {n,m,padZ} (4*(padZ + n)\/3 == m, fin n, fin m, padZ == (3-(n%3))%3, 2>=padZ)\n          => [n][8] -> [Enc64 n][8]\nbase64enc ns = take `{m} (chunks # padEq)\n where\n  chunks      = take `{(4*n+2)\/3} (base64chunks `{(n+2)\/3} (ns # padZero))\n  padZero     = take `{padZ} [zero | _ <- [1..2] : [_][2]]\n  padEq       = \"==\"\n\nalphabet = ['A'..'Z'] # ['a'..'z'] # ['0'..'9'] # \"+\/\"\n\n\nbase64chunks : {n} (fin n) => [n*3][8] -> [n*4][8]\nbase64chunks m = [basify x |  x <- ns]\n where\n  ns = split (join m) : [_][6]\n  basify : [6] -> [8]\n  basify x = alphabet @ x\n\n\/\/ Base64 strings are always in 4n byte chunks, the final chunk might be\n\/\/ padded. We can not give a proper cryptol implementation that strips the\n\/\/ padding because that would require the type, n, to depend on the value\n\/\/ (dependant types). Instead we return possibly excess bytes and, separetely,\n\/\/ the number of pad bytes (0,1 or 2) as a value.\nbase64dec : {n,m} (fin m, 4*n == 3*m, fin n) => [m][8] -> ([n][8],[2])\nbase64dec ms = (split (join [debase x | x <- ms]), nrEq)\n where\n nrEq : [2]\n nrEq = sum [ zero # [x == '='] | x <- take `{2} (reverse ms # [zero,zero]) ]\n\n debase : [8] -> [6]\n debase x = drop `{2} (debase' x)\n\n debase' : [8] -> [8]\n debase' x =\n    if x >= 'A' \/\\ x <= 'Z'\n        then x - 'A'\n        else if x >= 'a' \/\\ x <= 'z'\n              then x - 'a' + 26\n              else if x >= '0' \/\\ x <= '9'\n                    then x - '0' + 52\n                    else if x == '+'\n                        then 62\n                        else if x == '\/'\n                                then 63\n                                else zero \/\/ Pad bytes are decoded as NUL\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Base58.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the Base58 encoding and decoding functions in the provided module. Specifically, specify properties that check that encoding followed by decoding returns the original input, and that the character mapping used in encoding and decoding is consistent and valid for all inputs within the specified bounds."},{"role":"assistant","content":"```cryptol\nmodule Base58 where\n\n\/\/ Base 58 is a dependent format - the length of the encoded value depends on\n\/\/ the value being encoded This does not play well with Cryptol, which expects\n\/\/ a static type.   Thus we must consume the worst-case number of bytes and\n\/\/ produce a length value which we return to the callee.\n\n\/\/ Convert an N bit number (33 bytes for minilock) into a big endian base 58 representation (46 byte max for minilock).\nbase58enc : {n,m} (fin n, fin m, n >= 6 ) => [n] -> [m][8]\nbase58enc ns = [ x.1 | x <- reverse (take `{m} (drop `{1} enc))]\n where\n  enc      = [(ns,zero)] # [ (n\/58,charOf (n%58)) | (n,_) <- enc ]\n  charOf x = charMap @ x\n\ncharMap : [58][8]\ncharMap = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\nbase58dec : {n,m} (fin n, fin m, n >= 1, n >= width m, n >= 8) => [m][8] -> [n]\nbase58dec ms = sum [ (dec m) * 58 ^^ i | m <- reverse ms | i <- [0..m] ]\n where\n  dec : [8] -> [n]\n  dec x = zero # dec' x\n\n  dec' : [8] -> [8]\n  dec' x =\n    if x >= 'm'\n     then x - 'm' + 44\n     else if x >= 'a'\n            then x - 'a' + 33\n            else if x >= 'P'\n                  then x - 'P' + 22\n                  else if x > 'I'\n                        then x - 'J' + 17\n                        else if x >= 'A'\n                              then x - 'A' + 9\n                              else x - '1'\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/bv.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the arithmetic functions defined in the bv module, including uext, iext, safe_add, safe_sub, safe_product, safe_mod, adc, and sbb. The properties should check that unsigned and signed extensions behave as expected, that safe_add and safe_sub produce correct n+1-bit results, that safe_product computes the correct product, that safe_mod correctly reduces modulo p, and that adc and sbb correctly compute sum\/difference along with carry\/borrow bits."},{"role":"assistant","content":"```cryptol\nmodule bv where\n\n\/* Unsigned word extension. *\/\nuext : {a, b} (fin b,fin a) => [a] -> [a+b]\nuext(x) = zero # x\n\niext : {a, b} (fin b,fin a) => [a] -> [a+b]\niext(x) = (if x@0 then ~zero else zero) # x\n\n\/* Returns the (n+1)-bit sum of two n-bit numbers. *\/\nsafe_add : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_add(x,y) = uext(x) + uext(y)\n\n\/* returns the (n+1)-bit subtraction of two n-bit numbers. *\/\nsafe_sub : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_sub(x,y) = uext(x) - uext(y)\n\n\/* Is x in normalized form (relative to prime p)? *\/\nis_normal : {a} (fin a) => [a] -> [a] -> Bit\nis_normal p x = (x < p)\n\n\/* Returns the product of two inputs. *\/\nsafe_product : {a} (fin a) => ([a],[a]) -> [2*a]\nsafe_product(x,y) = uext(x) * uext(y)\n\n\/* Returns module reduction on input. *\/\nsafe_mod : {a, b} (fin a, fin b) => ([b],[a+b]) -> [b]\nsafe_mod(p,x) = drop `{a} (x % uext(p))\n\n\/* Add two n-bit numbers and input carry to obtain a n bit number and output carry. *\/\nadc : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nadc(x,y) = (drop(sm), sm@0)\n  where sm = safe_add(x,y)\n\n\/* sbb(x,y) subtracts y from x, and returns result along with output borrow bit. *\/\nsbb : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nsbb(x,y) = (drop(r), r@0)\n  where r = ([False] # x) - ([False] # y)\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/LittleEndian.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the function 'littleendian' correctly converts a sequence of bytes into a little-endian word, and that 'littleendian_inverse' is the inverse of 'littleendian'. Include properties that check correctness on example inputs and prove that applying 'littleendian' followed by 'littleendian_inverse' returns the original byte sequence for all valid inputs."},{"role":"assistant","content":"```cryptol\nmodule LittleEndian where\n\n\n\/\/ Takes a finite sequence of bytes, and turns them into a word via\n\/\/ a little-endian interpretation\nlittleendian : {a}(fin a) => [a][8] -> [a*8]\nlittleendian b = join(reverse b)\n\nproperty littleendian_passes_tests =\n  (littleendian [  0,   0,   0,   0] == 0x00000000) &&\n  (littleendian [ 86,  75,  30,   9] == 0x091e4b56) &&\n  (littleendian [255, 255, 255, 250] == 0xfaffffff)\n\nlittleendian_inverse : [32] -> [4][8]\nlittleendian_inverse b = reverse(split b)\n\nproperty littleendian_is_invertable b = littleendian_inverse(littleendian b) == b\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES\/SBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the AES SBox and its inverse (sboxInv) are correct inverses of each other. Specifically, write properties that check for every byte input that applying sbox followed by sboxInv returns the original byte, and vice versa. Also, include properties that ensure all elements of sbox and sboxInv are valid GF28 elements."},{"role":"assistant","content":"```cryptol\nmodule AES::SBox where\n\nimport AES::GF28\nimport AES::SubBytePlain\n\ntype SBox = [256] GF28\n\nsbox : SBox\nsbox = [ SubByte x | x <- [0 .. 255] ]\n\nsboxInv : SBox\nsboxInv = [ InvSubByte x | x <- [0 .. 255] ]\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES\/SubByteSBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the SubByte and InvSubByte functions are inverses of each other for all inputs in GF28, ensuring that InvSubByte(SubByte(b)) == b and SubByte(InvSubByte(b)) == b."},{"role":"assistant","content":"```cryptol\nmodule AES::SubByteSBox where\n\nimport AES::GF28\nimport AES::SBox\n\nSubByte : GF28 -> GF28\nSubByte b = sbox @ b\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = sboxInv @ b\n```"}]}
{"filename":"cryptol\/lib\/Cryptol\/Reference.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the polynomial arithmetic functions pmult, pdiv, and pmod defined over GF(2). The properties should check algebraic identities such as distributivity, associativity, and the relationship between division and modulus. Additionally, specify properties to verify that foldl, scanl, and iterate behave as expected for functional iteration and folding over sequences."},{"role":"assistant","content":"```cryptol\nmodule Cryptol::Reference where\n\n\/**\n * Performs multiplication of polynomials over GF(2).\n * Reference implementation.\n *\/\npmult : {u, v} (fin u, fin v) => [1 + u] -> [1 + v] -> [1 + u + v]\npmult x y = last zs\n  where\n    zs = [0] # [ (z << 1) ^ (if yi then 0 # x else 0) | yi <- y | z <- zs ]\n\n\/**\n * Performs division of polynomials over GF(2).\n * Reference implementation.\n *\/\npdiv : {u, v} (fin u, fin v) => [u] -> [v] -> [u]\npdiv x y = [ z ! degree | z <- zs ]\n  where\n    degree : [width v]\n    degree = last (ds : [1 + v]_)\n      where ds = [0\/0] # [if yi then i else d | yi <- reverse y | i <- [0..v] | d <- ds ]\n\n    reduce : [v] -> [v]\n    reduce u = if u ! degree then u ^ y else u\n\n    zs : [u][v]\n    zs = [ tail (reduce z # [xi]) | z <- [0] # zs | xi <- x ]\n\n\/**\n * Performs modulus of polynomials over GF(2).\n * Reference implementation.\n *\/\npmod : {u, v} (fin u, fin v) => [u] -> [1 + v] -> [v]\npmod x y = if y == 0 then 0\/0 else last zs\n  where\n    degree : [width v]\n    degree = last (ds : [2 + v]_)\n      where ds = [0\/0] # [if yi then i else d | yi <- reverse y | i <- [0..v] | d <- ds ]\n\n    reduce : [1 + v] -> [1 + v]\n    reduce u = if u ! degree then u ^ y else u\n\n    powers : [inf][1 + v]\n    powers = [reduce 1] # [ reduce (p << 1) | p <- powers ]\n\n    zs = [0] # [ z ^ (if xi then tail p else 0) | xi <- reverse x | p <- powers | z <- zs ]\n\n\/**\n * Functional left fold.\n *\n * foldl (+) 0 [1,2,3] = ((0 + 1) + 2) + 3\n *\n * Reference implementation.\n *\/\nfoldl : {n, a, b} (fin n) => (a -> b -> a) -> a -> [n]b -> a\nfoldl f z bs = last (scanl f z bs)\n\n\/**\n * Scan left is like a foldl that also emits the intermediate values.\n *\n * Reference implementation.\n *\/\nscanl : {n, a, b}  (a -> b -> a) -> a -> [n]b -> [1+n]a\nscanl f z bs = as\n  where\n    as = [z] # [ f a b | a <- as | b <- bs ]\n\n\/**\n * Map a function iteratively over a seed value, producing an infinite\n * list of successive function applications.\n *\n * Reference implementation.\n *\/\niterate : {a} (a -> a) -> a -> [inf]a\niterate f z = xs\n  where xs = [z] # [ f x | x <- xs ]\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol_eval\/test-files\/M.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the functions f, g, and h in module M. Specifically, specify that f and g produce the same output for any input x, that h acts as the identity function on its input, and that the function isSqrtOf9 correctly identifies whether an 8-bit input squared equals 9. Also, write properties to check that the polymorphic identity function id behaves as expected for various types."},{"role":"assistant","content":"```cryptol\nmodule M where\nf : [8] -> [2][8]\nf x = repeat x\n\ng : [8] -> [2][8]\ng x = [x, x]\n\nh : [2][8] -> [2][8]\nh x = x\n\nm : {a} (fin a, a > 42) => Z a\nm = 42\n\n\ntwo : [15]\ntwo = 2\n\nthree : [16]\nthree = 3\n\nfour : [17]\nfour = 4\n\nid : {a} a -> a\nid x = x\n\ntype Word8 = [8]\ntype Twenty a = [20]a\n\nisSqrtOf9 : [8] -> Bit\nisSqrtOf9 x = x*x == 9\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Names.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the function `enc` defined as `enc x = x ^ key`, including proving that applying `enc` twice returns the original input (i.e., `enc_correct`). Also, specify properties or verification scripts to check the behavior of the custom subtraction operator `(-!)` and ensure it behaves as defined."},{"role":"assistant","content":"```cryptol\nmodule Names where\n\n\/\/ Examples of names included in `names()` (term names)\n\nparameter\n  key : [64]\n\nenc : [64] -> [64]\nenc x = x ^ key\n\nenc_correct : [64] -> Bit\nproperty enc_correct x =\n  x == enc (enc x)\n\nprimitive prim : [64] -> [64]\n\n(-!) : [64] -> [64] -> [64]\nx -! y = if y > x then 0 else x - y\n\n\/\/ Examples of names not included in `names()` (type and module names)\n\nparameter\n  type a : #\n\ntype b = a\n\ntype constraint fin_b = fin b\n\nprimitive type c : *\n\nnewtype d = { un_d : c }\n\nsubmodule M where\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Id.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property to verify that the function 'id' behaves as the identity function for all input sequences of any finite length 'n'. The property should confirm that for any input 'a', 'id a' equals 'a'."},{"role":"assistant","content":"```cryptol\nmodule Id where\n\nid : {n} (fin n) => [n] -> [n]\nid a = a\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/CplxQNewtype.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the algebraic laws of complex rational numbers defined in the file, including associativity of addition and multiplication, distributivity of multiplication over addition, and equality correctness for the CplxQ newtype."},{"role":"assistant","content":"```cryptol\n\/\/ This is a development of rational complex numbers\n\ntype Q = Rational\n\nfortyTwo : Q\nfortyTwo = 42\n\n\/\/ Complex rational numbers in rectangular coordinates\nnewtype CplxQ =\n  { real : Q, imag : Q }\n\nembedQ : Q -> CplxQ\nembedQ x = CplxQ{ real = x, imag = 0 }\n\ncplxTwo : CplxQ\ncplxTwo = embedQ 2\n\ncplxForty : CplxQ\ncplxForty = embedQ 40\n\ncplxFortyTwo : CplxQ\ncplxFortyTwo = embedQ 42\n\n\ncplxAdd : CplxQ -> CplxQ -> CplxQ\ncplxAdd x y = CplxQ { real = r, imag = i }\n  where\n  r = x.real + y.real\n  i = x.imag + y.imag\n\ncplxMul : CplxQ -> CplxQ -> CplxQ\ncplxMul x y = CplxQ { real = r, imag = i }\n  where\n  r = x.real * y.real - x.imag * y.imag\n  i = x.real * y.imag + x.imag * y.real\n\ncplxEq : CplxQ -> CplxQ -> Bit\ncplxEq x y = (x.real == y.real) && (x.imag == y.imag)\n\nproperty cplxAddAssoc x y z =\n  cplxEq (cplxAdd (cplxAdd x y) z)\n         (cplxAdd x (cplxAdd y z))\n\nproperty cplxMulAssoc x y z =\n  cplxEq (cplxMul (cplxMul x y) z)\n         (cplxMul x (cplxMul y z))\n\nproperty cplxMulDistrib x y z =\n  cplxEq (cplxMul x (cplxAdd y z))\n         (cplxAdd (cplxMul x y) (cplxMul x z))\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Foo.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the functions defined in the Foo module. These properties should check that 'id' behaves as the identity function, 'add' correctly adds two sequences element-wise, 'getFoo' extracts the 'foo' field from the record, and that each 'op' function produces an output sequence of the expected length as indicated by its type-level arithmetic. Additionally, write a property to verify that 'isSqrtOf9' returns true if and only if the input squared equals 9."},{"role":"assistant","content":"```cryptol\nmodule Foo where\n\nimport Id as Id\n\nid : {a} a -> a\nid x = x\n\nx : [8]\nx = 255\n\nadd : {a} (fin a) => [a] -> [a] -> [a]\nadd = (+)\n\nfoo : {foo : [32], bar : [32]} \nfoo = {foo = 23, bar = 99}\n\ngetFoo : {foo : [32], bar : [32]}  -> [32]\ngetFoo x = x.foo\n\nop1 : {n} (fin n) => [n] -> [n + 1]\nop1 a = 0\n\nop2 : {n} (fin n) => [n] -> [n - n]\nop2 a = 0\n\nop3 : {n} (fin n) => [n] -> [n * 1]\nop3 a = 0\n\nop4 : {n} (fin n) => [n] -> [n \/ 1]\nop4 a = 0\n\nop5 : {n} (fin n) => [n] -> [n % 1]\nop5 a = 0\n\nop6 : {n} (fin n) => [n] -> [n ^^ 1]\nop6 a = 0\n\nop7 : {n} (fin n) => [n] -> [n \/^ 1]\nop7 a = 0\n\nop8 : {n} (fin n) => [n] -> [width n]\nop8 a = 0\n\nop9 : {n} (fin n) => [n] -> [max n 1]\nop9 a = 0\n\nop10 : {n} (fin n) => [n] -> [min 1 n]\nop10 a = 0\n\nop11 : {n} (fin n) => [n] -> [lg2 n]\nop11 a = 0\n\nisSqrtOf9 : [8] -> Bit\nisSqrtOf9 x = x*x == 9\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Types.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that verify the correctness of each top-level definition in the Types module. For example, specify properties that check the values and types of 'b', 'w', 'z', 'm', 'q', 't', 's', and 'r', and verify that the 'id' function behaves as the identity function for all finite-length sequences."},{"role":"assistant","content":"```cryptol\nmodule Types where\n\nb : Bit\nb = True\n\nw : [16]\nw = 42\n\nz : Integer\nz = 420000\n\nm : Z 12\nm = 6\n\nq : Rational\nq = ratio 5 4\n\nt : (Bit, Integer)\nt = (False, 7)\n\ns : [3][3][8]\ns = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nr : {xCoord : [32], yCoord : [32]}\nr = {xCoord = 12 : [32], yCoord = 21 : [32]}\n\nid : {n} (fin n) => [n] -> [n]\nid a = a\n```"}]}
{"filename":"cryptol-specs\/Common\/ntt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the recursive NTT and inverse NTT implementations in the provided module. Specifically, create properties that prove the inverse NTT is the inverse function of the NTT (i.e., ivntt (ntt a) == a), and that the optimized versions fntt and fivntt are equivalent to their naive counterparts. Include properties for ntt_correct, fntt_correct, fivntt_correct, and ffivntt_correct, suitable for use with Cryptol's :prove command."},{"role":"assistant","content":"```cryptol\n\/* It type checks, and it succeeds in meeting the ntt_correct property\n   below which says that the inverse ntt applied to the ntt is the\n   identity function.  It also shows a way to use fast algorithms to\n   compute the naive ntt. *\/\n\nmodule Common::ntt where\n\n\/*\n * Dilithium parameters:\n * q = 8380417\n * n = 256\n * r = 1753\n *\/\n\ntype q = 8380417\n\ntype Fld = Z q\n\ntype nn = 256\n\n\/**\n * Primitive 512-th root of unity r mod q\n *\/\nr : Fld\nr = 1753\n\n\/* Naive NTT *\/\n\nall_powers : {n} (fin n) => Fld -> [n]Fld\nall_powers w = take`{n} (iterate ((*) w) 1)\n\nodd_powers : {n} (fin n) => Fld -> [n]Fld\nodd_powers w = take`{n} (iterate ((*) (w * w)) w)\n\nnaive_ntt : {n} (fin n) => [n]Fld -> [n]Fld\nnaive_ntt xs = map (polyeval xs) (odd_powers r)\n\n\/\/ Little endian\npolyeval : {n} (fin n) => [n]Fld -> Fld -> Fld\npolyeval p x = foldl (\\y pi -> (x * y) + pi) 0 (reverse p)\n\n\/**\n * n = 256 and ivn is the inverse of n in the field.\n *\/\nivn : Fld\nivn = recip (`nn : Fld)\n\n\/**\n * Inverse of the root of unity\n *\/\nivr : Fld\nivr = recip r\n\nnaive_ivntt : {n} (fin n) => [n]Fld -> [n]Fld\nnaive_ivntt xs = map ((*) ivn) ys\n  where\n    ys = [ foldl (+) 0 (zipWith (*) (reverse xs) (odd_powers wi))\n         | wi <- all_powers r ]\n\n\/**\n * ```repl\n * :check naive_ntt_correct\n * ```\n *\/\nnaive_ntt_correct : [nn]Fld -> Bool\nproperty naive_ntt_correct a = naive_ivntt (naive_ntt a) == a\n\n\/**\n * Unit vectors\n *\/\nunit : {n} (n < nn) => [nn]Fld\nunit =\n  [ if `n == i then 1 else 0 | i <- [0 .. <nn]]\n\n\/* Recursive NTT *\/\n\n\/**\n * Powers of the squares of the primitive root of unity\n *\/\nroots : [inf]Fld\nroots = iterate ((*) (r * r)) 1\n\n\/**\n * An O(n log n) number theortic transform for Dilithium.\n *\/\nntt : [nn]Fld -> [nn]Fld\nntt a = ntt_r`{lg2 nn} 0 a\n\nntt_r : {n} (fin n) => Integer -> [2 ^^ n]Fld -> [2 ^^ n]Fld\nntt_r depth a\n  | n == 0 =>  a\n  | n > 0 => butterfly depth even odd\n    where\n      (lft, rht) = shuffle a\n      even = ntt_r`{n - 1} (depth + 1) lft\n      odd = ntt_r`{n - 1} (depth + 1) rht\n\n\/**\n * Group even indices in first half and odd indices in second half.\n * This implementation uses list comprehension to make the code\n * obviously correct.\n *\/\nshuffle : {n, a} (fin n, n > 0) => [2 * n]a -> ([n]a, [n]a)\nshuffle a =\n  ([ a @ (i * 2) | i <- [0 .. <n]], [ a @ (i * 2 + 1) | i <- [0 .. <n]])\n\n\/**\n * Perform the butterfly operation.\n *\/\nbutterfly : {n} (fin n, n > 0) => Integer -> [n]Fld -> [n]Fld -> [2*n]Fld\nbutterfly depth even odd =\n  lft # rht\n  where\n    j = 2 ^^ depth\n    lft = [ even @ i + roots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n    rht = [ even @ i - roots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n\n\/* INVERSE NTT *\/\n\n\/**\n * Powers of the inverse squares of the root of unity\n *\/\nivroots : [inf]Fld\nivroots = iterate ((*) (ivr * ivr)) 1\n\n\/**\n * An O(n log n) inverse number theortic transform for Dilithium.\n *\/\nivntt : [nn]Fld -> [nn]Fld\nivntt a =\n  map ((*) ivn) (ivntt_r`{lg2 nn} 0 a)\n\nivntt_r : {n} (fin n) => Integer -> [2 ^^ n]Fld -> [2 ^^ n]Fld\nivntt_r depth a\n  | n == 0 => a\n  | n > 0 => ivbutterfly depth even odd\n    where\n      (lft, rht) = shuffle a\n      even = ivntt_r`{n - 1} (depth + 1) lft\n      odd = ivntt_r`{n - 1} (depth + 1) rht\n\n\/**\n * Perform the butterfly operation with inverse roots.\n *\/\nivbutterfly : {n} (fin n, n > 0) => Integer -> [n]Fld -> [n]Fld -> [2 * n]Fld\nivbutterfly depth even odd =\n  lft # rht\n  where\n    j = 2 ^^ depth\n    lft = [ even @ i + ivroots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n    rht = [ even @ i - ivroots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n\n\/**\n * Takes ~20s to prove.\n * ```repl\n * :prove ntt_correct\n * ```\n *\/\nntt_correct : [nn]Fld -> Bool\nproperty ntt_correct a = ivntt (ntt a) == a\n\n\/* Connection with naive ntt and recursive ntt *\/\n\nfntt : [nn]Fld -> [nn]Fld\nfntt xs = ntt (zipWith (*) xs (all_powers r))\n\n\/**\n * Takes ~40s to prove.\n * ```repl\n * :prove fntt_correct\n * ```\n *\/\nfntt_correct : [nn]Fld -> Bool\nproperty fntt_correct a = naive_ntt a == fntt a\n\nfivntt : [nn]Fld -> [nn]Fld\nfivntt xs = zipWith (*) (all_powers ivr) (ivntt xs)\n\n\/**\n * Takes ~10s to prove.\n * ```repl\n * :prove fivntt_correct\n * ```\n *\/\nfivntt_correct : [nn]Fld -> Bool\nproperty fivntt_correct a = fivntt a == naive_ivntt a\n\n\/**\n * Takes ~30s to prove.\n * ```repl\n * :prove ffivntt_correct\n * ```\n *\/\nffivntt_correct : [nn]Fld -> Bool\nproperty ffivntt_correct a = fivntt (fntt a) == a\n```"}]}
{"filename":"cryptol-specs\/Common\/LUP.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the LUPDecompose, LUPSolve, and LUPInvert functions in the Common::LUP module. The properties should check that LUPDecompose produces a valid LU decomposition with partial pivoting, that LUPSolve correctly solves linear systems using the LU decomposition, and that LUPInvert returns the correct inverse matrix when the input is non-singular. Include checks for matrix multiplication identities and pivot correctness."},{"role":"assistant","content":"```cryptol\n\/* Solve linear equations over a field using LU decomposition\n *\n * John D. Ramsdell -- The MITRE Corporation -- December 2020\n *\/\n\nmodule Common::LUP where\n\nparameter\n\n  \/**\n   * Fld is the type of a field element.\n   * It must implement equality.\n   *\/\n  type Fld : *\n\n  type constraint (Eq Fld)\n\n  \/**\n   * The additive identity of the field\n   *\/\n  fzero : Fld\n\n  \/**\n   * Addition in the field\n   *\/\n  fadd : Fld -> Fld -> Fld\n\n  \/**\n   * The additive inverse of the field\n   *\/\n  fminus : Fld -> Fld\n\n  \/**\n   * The multiplicative identity of the field\n   *\/\n  fone : Fld\n\n  \/**\n   * Multiplication in the field\n   *\/\n  fmul : Fld -> Fld -> Fld\n\n  \/**\n   * The multiplicative inverse of the field\n   *\/\n  finv : Fld -> Fld\n\n\/**\n * Return x divided by y.\n *\/\nfdiv : Fld -> Fld -> Fld\nfdiv x y =\n  fmul x (finv y)\n\n\/**\n * Return the sequence of the natural numbers less that n.\n *\/\nnats : {n} (fin n) => [n][width n]\nnats = take`{n} [0 .. n]\n\n\/**\n * Map a function over a finite sequence and provide the function\n * with the position at which each element occurs.\n *\/\nmap_at : {n, a} (fin n) => ([width n] -> a -> a) -> [n]a  -> [n]a\nmap_at f m = [ f i (m @ i) | i <- nats ]\n\n\/**\n * Vectors of field elements\n *\/\ntype FldVec n = [n]Fld\n\n\/**\n * The dot product\n *\/\ndot : {n} (fin n) => FldVec n -> FldVec n -> Fld\ndot x y =\n  str ! 0\n  where\n    str = [ fzero ] # [ fadd acc (fmul xi yi)\n                      | xi <- x\n                      | yi <- y\n                      | acc <- str ]\n\n\/**\n * Vector addition\n *\/\nvecAdd : {n} (fin n) => FldVec n -> FldVec n -> FldVec n\nvecAdd x y = [ fadd xi yi | xi <- x | yi <- y ]\n\n\/**\n * Scalar multiplication of a vector\n *\/\nscalMul : {n} (fin n) => Fld -> FldVec n -> FldVec n\nscalMul c x = [ fmul c xi | xi <- x ]\n\n\/**\n * Square matrices\n *\/\ntype FldMat n = [n](FldVec n)\n\n\/**\n * The identity matrix\n *\/\nidMat : {n} (fin n) => FldMat n\nidMat = [ unitVec i | i <- nats ]\n\n\/**\n * The unit vector\n *\/\nunitVec : {n} (fin n) => [width n] -> FldVec n\nunitVec i =\n  [ if i == j then fone else fzero | j <- nats ]\n\n\/**\n * Matrix mulitplication\n *\/\nmatMul : {n} (fin n) => FldMat n -> FldMat n -> FldMat n\nmatMul x y =\n  [ [ dot (x @ i) (transpose y @ j) | j <- nats ] | i <- nats]\n\n\/**\n * Matrix vector multiplication\n *\/\nmatVec : {n} (fin n) => FldMat n -> FldVec n -> FldVec n\nmatVec x y =\n  [ dot (x @ i) y  | i <- nats]\n\n\/**\n * Swap two rows in a matrix.\n *\/\nswap : {n, a} (fin n) => [width n] -> [width n] -> [n]a -> [n]a\nswap i j x =\n  [ x @ perm k | k <- nats ]\n  where\n    perm k =\n      if (i >= `n) || (j >= `n)\n      then k\n      else if k == i\n           then j\n           else if k == j\n                then i\n                else k\n\n\/**\n * LU Decomposition with Partial Pivoting\n *\n * Decompose square matrix A as P*A = L*U where\n * P is a permutation matrix\n * L is unit lower triangular, and\n * U is upper triangular.\n * This is a Doolittle decomposition.\n *\n * L and U are stored in one matrix.\n *\/\n\n\/\/ The algorithm is from the Wikipedia page on LU Decomposition.\n\/\/ The algorithm follows.\n\n\/\/     \/\/ Pivot here\n\nLUPDecompose : {n} (fin n) => FldMat n -> (Bit, FldMat n, [n][width n])\nLUPDecompose a = str ! 0\n  where\n  perm = [ i | i <- nats ]\n  str = [(True, a, perm)] #\n        [ row i non_sing lu p\n        | (non_sing, lu, p) <- str\n        | i <- nats`{n=n}\n        ]\n\nprivate\n  \/**\n   * Perform partial pivoting and then elimination of matrix a and\n   * pivot p at i.  When ns = False, matrix a is known to be singular.\n   *\/\n  row : {n} (fin n) => [width n] -> Bit -> FldMat n -> [n][width n] ->\n                       (Bit, FldMat n, [n][width n])\n  row i ns a p =\n    if ns\n    then if ns'\n         then (ns', elim i a', p') \/\/ Perform elimination at row i\n         else (ns', a', p')        \/\/ a is singular, pivoting failed\n         where\n           (ns', a', p') = pivot i a p\n    else (ns, a, p)             \/\/ a is known to be singular\n\n  \/**\n   * Pivot rows when a[i][i] == 0.  The first element of the\n   * output is True when the matrix is non-singular.\n   *\/\n  pivot : {n} (fin n) => [width n] -> FldMat n -> [n][width n] ->\n                         (Bit, FldMat n, [n][width n])\n  pivot i a perm = str ! 0\n    where\n    str = [(False, a, perm)] #\n          [ f done lu p j | (done, lu, p) <- str | j <- nats`{n=n} ]\n    f done lu p j =\n      if j < i then (done, lu, p)\n       | j == i then (lu @ i @ i != fzero, lu, p)\n       | done then (done, lu, p)\n       | lu @ j @ i == fzero then (done, lu, p)\n      else (True, swap i j lu, swap i j p) \/\/ Pivot\n\n\/\/ for (j = i + 1; j < N; j++) {\n\/\/     A[j][i] \/= A[i][i];\n\/\/\n\/\/     for (k = i + 1; k < N; k++)\n\/\/         A[j][k] -= A[j][i] * A[i][k];\n\/\/ }\n\n  \/**\n   * Perform elimination in row i.\n   *\/\n  elim : {n} (fin n) => [width n] -> FldMat n -> FldMat n\n  elim i a = map_at f a\n    where\n      invA_i_i = finv (a @ i @ i)\n      f j v =\n        if i < j then\n          map_at g v\n          where\n            a_j_i = fmul (v @ i) invA_i_i\n            g k x =\n              if k < i then x\n               | k == i then a_j_i\n              else\n                fadd x (fminus (fmul a_j_i (a @ i @ k)))\n        else\n          v\n\n\/\/ Solving linear equations\n\n\/*\nvoid LUPSolve(double **A, int *P, double *b, int N, double *x) {\n\n    for (int i = 0; i < N; i++) {\n        x[i] = b[P[i]];\n\n        for (int k = 0; k < i; k++)\n            x[i] -= A[i][k] * x[k];\n    }\n\n    for (int i = N - 1; i >= 0; i--) {\n        for (int k = i + 1; k < N; k++)\n            x[i] -= A[i][k] * x[k];\n\n        x[i] \/= A[i][i];\n    }\n}\n*\/\n\n\/**\n * Solve a set of linear equations given an LUP decomposition of a\n * matrix.  That is, find x such that a * x = b, where lu and p are the\n * decomposition of matrix a.  This function assumes a is non-singular.\n *\/\nLUPSolve : {n} (fin n) => FldMat n -> [n][width n] ->\n                          FldVec n -> FldVec n\nLUPSolve lu p b =\n  bb\n  where\n    \/\/ Apply the pivot to b\n    pb = map_at pf b\n    pf i x = b @ (p @ i)\n    \/\/ Perform a forward subsitution on pb\n    fb = [ ff i x | x <- pb | i <- nats`{n=n} ]\n    ff i x = str ! 0\n      where\n        str = [ x ] # [ h j y | y <- str | j <- nats`{n=n} ]\n        h j y =\n          if j < i\n          then fadd y (fminus (fmul (lu @ i @ j) (fb @ j)))\n          else y\n    \/\/ Perform a backward subsitution on fb\n    bb = [ bf i x | x <- fb | i <- nats`{n=n} ]\n    bf i x = fdiv (str ! 0) (lu @ i @ i)\n      where\n        str = [ x ] # [ h j y | y <- str | j <- nats`{n=n} ]\n        h j y =\n          if i < j\n          then fadd y (fminus (fmul (lu @ i @ j) (bb @ j)))\n          else y\n\n\/**\n * Invert a matrix.\n * Return false if the matrix is singular.\n *\/\nLUPInvert : {n} (fin n) => FldMat n -> (Bit, FldMat n)\nLUPInvert a =\n  if ns then\n    (True, transpose [ LUPSolve lu p (unitVec i) | i <- nats ])\n  else\n    (False, a)\n  where\n    (ns, lu, p) = LUPDecompose a\n```"}]}
{"filename":"cryptol-specs\/Common\/ByteArray.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the properties and behaviors of the ByteArray type as defined in the Common::ByteArray module. Include properties that verify the correct indexing, length, and byte-level operations on the ByteArray type, ensuring it behaves as a fixed-size array of 64 bytes, each 8 bits wide."},{"role":"assistant","content":"```cryptol\nmodule Common::ByteArray where\n\nimport Array\n\ntype ByteArray = Array[64][8]\n```"}]}
{"filename":"cryptol-specs\/Common\/pick.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the functions pickItem, pickSeq, pickVec, pickMat, and pickTri correctly consume elements from an infinite stream and produce outputs of the expected sizes and shapes, preserving the remainder of the stream appropriately. Include checks for boundary conditions and correctness of the upper triangular matrix construction in pickTri."},{"role":"assistant","content":"```cryptol\n\/* Generate random vectors and matrices\n *\n * This module provides functions that create random vectors,\n * matrices, and upper triangular matrices.\n *\n * John D. Ramsdell -- The MITRE Corporation -- March 2021\n *\/\n\nmodule Common::pick where\n\n\/**\n * Return the sequence of the natural numbers less that n.\n *\/\nnats : {n} (fin n) => [n][width n]\nnats = take`{n} [0 .. n]\n\n\/\/ The following routines are meant to be used with the output of the\n\/\/ random function.  The infinite stream is always the first item\n\/\/ returned.\n\n\/**\n * Pick one item from an infinite stream.\n * Return the remainder of the stream with the item.\n *\/\npickItem : {a} [inf]a -> ([inf]a, a)\npickItem g = (tail g, head g)\n\n\/**\n * Pick a sequence of values from an infinite stream.\n * Return the remainder of the stream with the sequence.\n *\/\npickSeq : {n, a, b} (fin n, n > 0) =>\n          ([inf]a -> ([inf]a, b)) -> [inf]a -> ([inf]a, [n]b)\npickSeq f vals =\n  (str, map snd vec)\n  where\n    vec = [f vals] # [f g | (g, _) <- vec | i <- nats`{n=n-1}]\n    snd (_, x) = x\n    (str, _) = vec ! 0            \/**\n * Pick a vector of values from an infinite stream.\n * Return the remainder of the stream with the vector.\n *\/\npickVec : {n, a} (fin n, n > 0) => [inf]a -> ([inf]a, [n]a)\npickVec = pickSeq pickItem\n\n\/**\n * Pick a matrix of values from an infinite stream.\n * Return the remainder of the stream with the matrix.\n *\/\npickMat : {n, m, a} (fin n, n > 0, fin m, m > 0) =>\n          [inf]a -> ([inf]a, [n][m]a)\npickMat = pickSeq pickVec\n\n\/**\n * Pick an upper trianglar matrix of values from an infinite stream.\n * Variable pick contains the item picker.  Variable nil is the zero\n * for type a.  Return the remainder of the stream with the matrix.\n *\/\npickTri : {n, a} (fin n, n > 0) =>\n          ([inf]a -> ([inf]a, a)) -> a -> [inf]a -> ([inf]a, [n][n]a)\npickTri pick nil s =\n  (str, map snd vec)\n  where\n    vec = [pickSeq pick s] # [pickTriRow pick nil g i\n                             | (g, _) <- vec\n                             | i <- nats`{n=n-1}\n                             ]\n    snd (_, x) = x\n    (str, _) = vec ! 0          private\n\n  \/**\n   * Pick one row of an upper triangular matrix.\n   *\/\n  pickTriRow : {n, a} (fin n, n > 0) => ([inf]a -> ([inf]a, a)) ->\n               a -> [inf]a -> [width (n - 1)] -> ([inf]a, [n]a)\n  pickTriRow pick nil s j =\n    (str, map snd vec)\n    where\n      vec = [pick s] # [f g i\n                       | (g, _) <- vec\n                       | i <- nats`{n=n-1}\n                       ]\n      f g i =\n        if i < j\n        then (g, nil)\n        else pick g\n      snd (_, x) = x\n      (str, _) = vec ! 0\n```"}]}
{"filename":"cryptol-specs\/Common\/Field.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to specify and verify the algebraic field laws (associativity, commutativity, distributivity, existence of additive and multiplicative identities and inverses, etc.) for the FieldRep type defined in the Common::Field module."},{"role":"assistant","content":"```cryptol\nmodule Common::Field where\n\nimport Common::Morphism\nimport Common::Set\n\n\/\/ Field representations\ntype FieldRep fv =\n  { is_val : Set fv         \/\/ carrier set\n  , normalize : fv -> fv\n  , add : (fv,fv) -> fv\n  , sub : (fv,fv) -> fv\n  , neg : fv -> fv\n  , mul : (fv,fv) -> fv\n  , sq : fv -> fv\n  , half : fv -> fv\n  , div : (fv,fv) -> fv\n  \/* Zero value for field. *\/\n  , field_zero : fv\n    \/* Unit value for field. *\/\n  , field_unit : fv\n  \/* Return true if two field elements are equal. *\/\n  , is_equal : (fv, fv) -> Bit\n  }\n```"}]}
{"filename":"cryptol-specs\/Common\/mod_arith.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the modular arithmetic functions defined in the module Common::mod_arith. Specifically, include properties that check: 1) mod_add and mod_sub correctly perform addition and subtraction modulo p; 2) mod_neg computes the modular negation; 3) mod_half computes the modular half correctly for even and odd inputs; 4) mod_mul computes the modular product; 5) mod_div computes the modular division using Euler's binary gcd algorithm; and 6) mod_pow computes modular exponentiation correctly. Ensure the properties cover boundary cases and the functions preserve modular arithmetic laws."},{"role":"assistant","content":"```cryptol\nmodule Common::mod_arith where\n\nimport Common::bv\n\n\/* Add two numbers in normalized form. *\/\nmod_add : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_add(p,x,y) = if c1 || ~c2 then r2 else r1\n  where\n    (r1,c1) = adc( x, y)\n    (r2,c2) = sbb(r1, p)\n\n\/* Subtract two numbers in normalized form. *\/\nmod_sub : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_sub(p,x,y) = if b then r2 else r1\n  where\n    (r1,b) = sbb( x, y)\n    (r2,_) = adc(r1, p)\n\nmod_neg : {n} (fin n) => ([n],[n]) -> [n]\nmod_neg(p,x) = if x == 0 then 0 else (p - x)\n\nmod_half : {n} (fin n, n >= 1) => ([n],[n]) -> [n]\nmod_half(p, x) = if even(x) then x >> 1\n                 else take(safe_add(x, p))\n  where even y = (y && 1) == 0\n\n\/* Definition of modular multiplication. *\/\nmod_mul : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_mul(p,x,y) = safe_mod(p, safe_product(x, y))\n\n\/* Returns x\/y in F_p using Euler's binary gcd algorithm. *\/\n\/* Taken from [HMV] *\/\nmod_div : {a} (fin a, a >= 1) => ([a],[a],[a]) -> [a]\nmod_div(p,x,y) = egcd(p,0,y,x)\n  where\n    \/* In code below, a is always odd. *\/\n    egcd(a,ra,b,rb) =\n      if b == 0 then\n        ra\n      else if (b && 1) == 0 then \/* b is even. *\/\n        egcd(a, ra, b >> 1, mod_half(p, rb))\n      else if a < b then\n        egcd(a, ra, (b - a) >> 1, mod_half(p, mod_sub(p, rb, ra)))\n      else\n        egcd(b, rb, (a - b) >> 1, mod_half(p, mod_sub(p, ra, rb)))\n\nmod_pow : {a} (fin a, a >= 1) => ([a] , [a] , [a]) -> [a]\nmod_pow (p,x0,e0) = (results ! 0).2\n where\n results = [(x0,e0,1)] # [ (mod_mul (p,x,x), e>>1, if(e!0) then mod_mul(p,result,x) else result)\n                                | (x,e,result) <- results | _ <- [0..a] :[_][width a] ]\n```"}]}
{"filename":"cryptol-specs\/Common\/OptionUtils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the functions defined in the Common::OptionUtils module. These properties should capture the expected behavior of isSome, isNone, optApply, optFold, optTest, optFlatten, and optFlatApply, ensuring they handle all Option cases correctly and maintain the intended semantics."},{"role":"assistant","content":"```cryptol\n\/**\n * Convenience functions for working with `Option`s.\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n * @author Ryan Scott <rscott@galois.com>\n *\/\nmodule Common::OptionUtils where\n\nisSome : {a} Option a -> Bit\nisSome opt = case opt of\n    Some _ -> True\n    None -> False\n\nisNone : {a} Option a -> Bit\nisNone opt = ~ isSome opt\n\n\/**\n * Map an `Option a` to an `Option b` by applying a function to a contained\n * value (if `Some`) or returns `None` (if `None`).\n *\/\noptApply : {a, b} (a -> b) -> Option a -> Option b\noptApply f opt = case opt of\n    Some x -> Some (f x)\n    None -> None\n\n\/**\n * The `optFold` function takes a default value, a function, and an `Option`\n * value. If the `Option` value is `None`, then return the default value.\n * Otherwise, apply the function to the value inside the `Some` and return the\n * result.\n *\/\noptFold : {a, b} b -> (a -> b) -> Option a -> b\noptFold def f opt =\n  case opt of\n    Some x -> f x\n    None   -> def\n\n\/**\n * Takes a function outputting a `Bit` and an `Option` value. If the `Option`\n * value is `None`, return `False`. Otherwise, output the function applied\n * to the value inside the `Some` and return the result.\n *\/\noptTest : {a} (a -> Bit) -> Option a -> Bit\noptTest f opt = optFold False f opt\n\n\/**\n * Flatten a nested `Option` into a single `Option` that is `Some` only if\n * both original `Option`s are `Some`.\n *\/\noptFlatten : {a} Option (Option a) -> Option a\noptFlatten opt = case opt of\n    Some opt' -> opt'\n    None -> None\n\n\/**\n * Map an `Option a` to an `Option b` by calling `optApply` on a function that\n * produces an `Option b`, then `optFlatten`ing the result.\n *\/\noptFlatApply: {a, b} (a -> Option b) -> Option a -> Option b\noptFlatApply f opt = optFlatten (optApply f opt)\n```"}]}
{"filename":"cryptol-specs\/Common\/GF24.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the GF24 field operations defined in the module Common::GF24. Include properties that check the associativity and commutativity of addition and multiplication, the correctness of the multiplicative inverse, and the distributive law of multiplication over addition. Also, specify properties to verify that polynomial multiplication modulo the irreducible polynomial behaves as expected, and that vector and matrix multiplication functions satisfy standard algebraic properties."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc\n * @author Nichole Schimanski <nls@galois.com>\n * @author Alannah Carr\n * @editor Marcella Hastings <marcella@galois.com>\n *\/\nmodule Common::GF24 where\n\ntype GF24 = [4]\n\nirreducible = <| x^^4 + x + 1 |>\n\n\/\/ Addition in GF24\ngf24Add : {n} (fin n) => [n]GF24 -> GF24\ngf24Add ps = foldl (^) zero ps\n\n\/\/ Polynomial multiplication in GF24\ngf24Mult : GF24 -> GF24 -> GF24\ngf24Mult x y = pmod (pmult x y) irreducible\n\n\/\/ Define a power of an element in GF24\ngf24Pow : GF24 -> GF24 -> GF24\ngf24Pow n k = vals ! 0 where\n    sq x = gf24Mult x x\n    vals = [1] # [ if i then gf24Mult n (sq acc) else sq acc\n        | acc <- vals\n        | i   <- k]\n\n\/\/ Self adding gives zero\npolySelfAdd' : GF24 -> Bit\nproperty polySelfAdd' x = x ^ x == zero\n\n\/\/ Inverse of an element in GF24\ngf24Inverse : GF24 -> GF24\ngf24Inverse x = gf24Pow x 14\n\nproperty gf24InverseCorrect x = gf24Inverse (gf24Inverse x) == x\n\n\/\/ Dot product in GF24\ngf24DotProduct : {n} (fin n) => [n]GF24 -> [n]GF24 -> GF24\ngf24DotProduct xs ys = gf24Add [ gf24Mult x y | x <- xs | y <- ys ]\n\n\/\/ Vector multiplication in GF24\ngf24VectorMult : {n, m} (fin n) => [n]GF24 -> [m][n]GF24 -> [m]GF24\ngf24VectorMult v ms = [ gf24DotProduct v m | m <- ms ]\n\n\/\/ Matrix multiplication in GF24\ngf24MatrixMult : {n, m, k} (fin m) => [n][m]GF24 -> [m][k]GF24 -> [n][k]GF24\ngf24MatrixMult xss yss = [ gf24VectorMult xs yss' | xs <- xss ]\n    where\n        yss' = transpose yss\n```"}]}
{"filename":"cryptol-specs\/Common\/bv.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the arithmetic functions defined in the Common::bv module. Specifically, create properties that check: 1) safe_add correctly computes the (n+1)-bit sum of two n-bit inputs; 2) safe_sub correctly computes the (n+1)-bit subtraction; 3) safe_product returns the correct 2*n-bit product; 4) safe_mod correctly computes modular reduction; 5) adc correctly adds two n-bit numbers with carry-in and produces the correct sum and carry-out; and 6) sbb correctly subtracts with borrow and returns the correct result and borrow bit. Ensure the properties cover boundary cases and type constraints."},{"role":"assistant","content":"```cryptol\nmodule Common::bv where\n\n\/* Returns the (n+1)-bit sum of two n-bit numbers. *\/\nsafe_add : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_add(x,y) = zext(x) + zext(y)\n\n\/* returns the (n+1)-bit subtraction of two n-bit numbers. *\/\nsafe_sub : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_sub(x,y) = zext(x) - zext(y)\n\n\/* Is x in normalized form (relative to prime p)? *\/\nis_normal : {a} (fin a) => [a] -> [a] -> Bit\nis_normal p x = (x < p)\n\n\/* Returns the product of two inputs. *\/\nsafe_product : {a} (fin a) => ([a],[a]) -> [2*a]\nsafe_product(x,y) = zext(x) * zext(y)\n\n\/* Returns module reduction on input. *\/\nsafe_mod : {a, b} (fin a, fin b) => ([b],[a+b]) -> [b]\nsafe_mod(p,x) = drop `{a} (x % zext(p))\n\n\/* Add two n-bit numbers and input carry to obtain a n bit number and output carry. *\/\nadc : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nadc(x,y) = (drop(sm), sm@0)\n  where sm = safe_add(x,y)\n\n\/* sbb(x,y) subtracts y from x, and returns result along with output borrow bit. *\/\nsbb : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nsbb(x,y) = (drop(r), r@0)\n  where r = ([False] # x) - ([False] # y)\n```"}]}
{"filename":"cryptol-specs\/Common\/utils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the 'half' function defined in the 'Common::utils' module. Specifically, prove that for all inputs 'x' of type 'Z p' where 'p' is an odd modulus greater or equal to 3, the property 'half x + half x == x' holds. Additionally, write properties to verify the behavior of the 'while' and 'dowhile' functional loops, ensuring they terminate correctly and produce expected results given appropriate conditions and bodies. Include properties that test the correctness of the conversion functions 'ZtoBV', 'BVtoZ', 'ZtoZ', 'integerToBV', and 'integerFromBV' to ensure round-trip conversions preserve values."},{"role":"assistant","content":"```cryptol\nmodule Common::utils where\n\n\/**\n * A functional view of the while loop.\n * `condition` and `body` are functions applied to `initial_state`.\n * `body` is applied to the state if `condition initial_state` is `True`.\n *\/\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\n\/**\n * A functional view of the do-while loop.\n * Like the `while` function, except `body` is guaranteed to be applied\n * on the first iteration.\n *\/\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\n\/**\n * Convert a `Z` type to a bitvector.\n *\/\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = (fromInteger (fromZ x))\n\n\/**\n * Convert a bitvector to a `Z` type.\n *\/\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = (fromInteger (toInteger x))\n\n\/**\n * Convert between `Z` types defined over different moduli.\n *\/\nZtoZ : {p, q} (fin p, fin q, p >= 1, q >= 1) => Z p -> Z q\nZtoZ x = (fromInteger (fromZ x))\n\n\/**\n * Convert an integer to a bitvector.\n *\/\nintegerToBV : {m} (fin m) => Integer -> [m]\nintegerToBV x = fromInteger x\n\n\/**\n * Convert a bitvector to an integer.\n *\/\nintegerFromBV : {m} (fin m) => [m] -> Integer\nintegerFromBV x = toInteger x\n\n\/**\n * Convert an integer to a bitvector.\n * If the result of the conversion is less than 3,\n * return 3 instead of the conversion result.\n *\/\nintegerModulusFromBV : {m} (fin m) => [m] -> Integer\nintegerModulusFromBV x = if (integerFromBV x) < 3 then 3 else (integerFromBV x)\n\n\/**\n * Check if an integer is even.\n *\/\nisEven : Integer -> Bit\nisEven x = ~((fromInteger x) : [1]) ! 0\n\n\/**\n * Calculate the absolute value of an integer.\n *\/\nabs : Integer -> Integer\nabs x = if x >= zero then x else zero-x\n\n\/**\n * Unzip a sequence of tuples into a tuple of sequences.\n *\/\nunzip : {a,f,s} [a](f,s) -> ([a]f,[a]s)\nunzip tuples = (map (\\x -> x.0) tuples , map (\\x -> x.1) tuples)\n\n\/**\n * \"Multiply\" `x` by `2` in an additive group.\n *\/\nmul2 x = x + x\n\n\/**\n * \"Multiply\" `x` by `3` in an additive group.\n *\/\nmul3 x = x + mul2 x\n\n\/**\n * \"Multiply\" `x` by `4` in an additive group.\n *\/\nmul4 x = mul2(mul2 x)\n\n\/**\n * \"Multiply\" `x` by `8` in an additive group.\n *\/\nmul8 x = mul2(mul4 x)\n\ntype constraint isOdd a = (a \/ 2) * 2 == a - 1\n\n\/**\n * Calculate \"half\" of a quantity in a mod `p` context.\n * I.e., `half x + half x == x`.\n *\/\nhalf : {p} (fin p, p >= 3, isOdd p) => Z p -> Z p\nhalf x = fromInteger (if isEven xint then xint\/2 else ((xint + `p) \/ 2))\n  where\n    xint = fromZ x\n\n\/**\n * Verify that `half` is correct.\n * ```repl\n * :prove half_correct `{7}\n * ```\n *\/\nhalf_correct : {p} (fin p, p >= 3, isOdd p) => Z p -> Bit\nproperty half_correct x = half x + half x == x\n\n\/**\n * Function composition, specialized to functions from `(a -> a)`.\n * In particular, `(compose f g) x == g (f x)`.\n *\/\ncompose : {a} () => (a -> a) -> (a -> a) -> a -> a\ncompose f g = \\x -> g (f x)\n\n\/**\n * Composition of many functions from `(a -> a)`.\n * In particular, `(composeMany [a, b, c]) x == c (b (a x))`.\n *\/\ncomposeMany : {nf, a} () => [nf](a -> a) -> a -> a\ncomposeMany fcns\n    | nf == 0 => \\x -> x\n    | nf == 1 => fcns@0\n    | nf == 2 => compose (fcns@0) (fcns@1)\n    | nf > 2  => compose (fcns@0) (composeMany (drop `{1} fcns))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/KDF\/HKDF256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to specify and verify the correctness of the `hmacBytes` function in the HKDF256 module, ensuring it correctly implements HMAC-SHA256 behavior as defined by the imported HMAC_SHA256 instantiation."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc\n * @author Aaron Tomb\n *\/\nmodule Primitive::Symmetric::KDF::HKDF256 = Primitive::Symmetric::KDF::HKDF where\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA256 as HMAC_SHA256\n\ntype HashLen = 32\nHMAC = hmacBytes\n\nhmacBytes : {n, m} (64 >= width (8 * (64 + m)),\n                    64 >= width (8 * n), 32 >= width m, fin m, fin n) =>\n            [n][8] -> [m][8] -> [32][8]\nhmacBytes key msg = HMAC_SHA256::hmac key msg\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/AES_GCM_SIV.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the AES-GCM-SIV authenticated encryption implementation in the given module. Include properties that check the correctness of key derivation, encryption and decryption consistency, tag generation, and the behavior of the polynomial multiplication and counter mode functions. Ensure the properties capture the expected relationships between inputs and outputs according to the AES-GCM-SIV specification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::AES_GCM_SIV where\n\nparameter\n  \/\/ This constraint enforces the standard key sizes of 128 and\n  \/\/ 256-bits recommended in the draft RFC.\n  type KeySize : #\n  type constraint (fin KeySize, KeySize % 128 == 0, KeySize \/ 128 >= 1, KeySize \/ 128 <= 2)\n\n  type AAD : #\n  type constraint ( (36 + 8) >= width AAD )\n\n\n\/** This bit of algebra is here to satisfy the constraint solver.\n * `K` should be the same as `KeySize`, but the type inference doesn't work\n * if you set it directly equal.\n * `Mode` is 0 for AES-128 and 1 for AES-256.\n *\/\ntype Mode = KeySize \/ 128 - 1\ntype K  = 128 + 128 * Mode\nimport Primitive::Symmetric::Cipher::Block::AES::Specification as AES where\n  type KeySize' = KeySize\ntype KS = AES::KeySchedule\n\n\n\/** Note the weird byte-swapping business (also in `blockify` and `unblockify`)\n * It is not quite clear in what format we want the inputs\/outputs, but we\n * do the swapping so that inputs\/ouputs match the test vectors at\n * https:\/\/tools.ietf.org\/html\/draft-irtf-cfrg-gcmsiv-06\n *\/\naes_gcm_siv :\n  {n} ((36 + 8) >= width n) =>\n      { key   : [K]\n      , nonce : [96]\n      , aad   : [AAD]\n      , msg   : [n]\n      } -> [n + 128]\naes_gcm_siv input = c # byteSwap t\n  where\n  (c,t) = gcm_siv_plus (derive_key k' n') n' input.aad input.msg\n  k'    = byteSwap input.key\n  n'    = byteSwap input.nonce\n\naes : KS -> [128] -> [128]\naes ks v = byteSwap (AES::cipher ks (byteSwap v))\n\nexpandKey : [K] -> KS\nexpandKey k = AES::keyExpansion (byteSwap k)\n\n\/** See Figure 2 in Section 4 *\/\nderive_key : [K] -> [96] -> ([128], KS)\nderive_key K N = (mkKey parts1, expandKey (mkKey parts2))\n  where\n  parts1 # parts2 = [ drop (aes (expandKey K) (N # i)) | i <- take [ 0 ... ]  ]\n\n  mkKey : {n} (fin n) => [n][64] -> [64 * n]\n  mkKey xs = join (reverse xs)\n\n\n\/** See Figure 1 in Section 3 *\/\ngcm_siv_plus :\n  {n} (64 >= width n) => ([128], KS) -> [96] -> [AAD] -> [n] -> ([n],[128])\ngcm_siv_plus (K1,K2) N AAD MSG = (unblockify Cs,TAG)\n  where\n\n  TAG     = aes K2 (0b0 # drop (T ^ (0 # N)))\n  T       = polyvalFrom K1 (A # M # [msg_len # aad_len]) 0\n  A       = blockify AAD\n  M       = blockify MSG\n  aad_len = `AAD: [64]\n  msg_len = `n   : [64]\n\n  _ # tUpper # tLower = TAG\n\n  Cs = counter_mode K2 (0b1 # tUpper, tLower) M\n\ncounter_mode : {n} KS -> ([96],[32]) -> [n][128] -> [n][128]\ncounter_mode K2 (tUpper,tLower) M =\n            [ aes K2 (tUpper # lower32 i) ^ m | m <- M | i <- [ 0 ... ] ]\n  where\n  lower32 i = tLower + i\n\n\n\/** See Section 2.2 *\/\npolyvalFrom : {n} (fin n) => [128] -> [n][128] -> [128] -> [128]\npolyvalFrom H Xs start = psums ! 0\n  where psums = [start] # [ dot (s ^ x) H | s <- psums | x <- Xs ]\n\ndot : [128] -> [128] -> [128]\ndot x y = mult x (mult y x_neg_128)\n  where x_neg_128 = <| 1 + x^^114 + x^^121 + x^^124 + x^^127 |>\n        \/\/ This is x^(-128)\n\n\nmult : [128] -> [128] -> [128]\nmult x y = pmod (pmult x y) irred\n  where\n  irred = <| 1 + x^^121 + x^^126 + x^^127 + x^^128 |>\n\nblockify : {n} (fin n) => [n] -> [n \/^ 128][128]\nblockify x = [ byteSwap b | b <- split (x # zero) ]\n\nunblockify : {n} (fin n) => [n \/^ 128][128] -> [n]\nunblockify xs = take (join [ byteSwap b | b <- xs ])\n\n\/\/ The spec uses byte-oriented little-endian representations.\n\/\/ This function changes back and forth.\nbyteSwap : {n} (fin n) => [8 * n] -> [8 * n]\nbyteSwap xs = join (reverse (split`{each=8} xs))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/MEE_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the MEE_CBC authenticated encryption scheme defined in the given module. Specifically, create properties that check: 1) the correctness of the padding and unpadding functions (pad and unpad), ensuring that unpad(pad(msg, tag)) returns the original message and tag with a valid padding indicator; 2) the correctness of the mee_enc and mee_dec functions, ensuring that decrypting an encrypted message returns the original message and a valid authentication tag; and 3) any necessary invariants or security properties implied by the CBC mode and authentication tag usage. Use the existing type constraints and definitions in the module to guide your specifications."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::MEE_CBC where\n\n\n\/\/ Fixing block size for simplicity.\ntype blkBytes = 16\n\/\/ Using blocks of bytes for greatest compatibility with both EasyCrypt\n\/\/ and other external descriptions of these algorithms\ntype Blk = [blkBytes][8]\n\/\/ Fixing encryption key size for simplicity.\ntype EKey = [blkBytes][8]\n\n\/\/ Fixing tag size for simplicity.\ntype tagBytes = 32\ntype Tag = [tagBytes][8]\n\n\/\/ Fixing signing key size for simplicity.\ntype skeyBytes = 64\ntype SKey = [skeyBytes][8]\n\ncbc_enc : {n} (fin n) => (EKey -> Blk -> Blk) -> EKey -> Blk -> [n]Blk -> [n]Blk\ncbc_enc enc k iv ps = cs\n where cs = [ enc k (p ^ c') | p <- ps | c' <- [iv] # cs ]\n\ncbc_dec : {n} (fin n) => (EKey -> Blk -> Blk) -> EKey -> Blk -> [n]Blk -> [n]Blk\ncbc_dec dec k iv cs = [ (dec k c) ^ c' | c <- cs | c' <- [iv] # cs ]\n\npad : {n, p, b}\n      (fin n, 8 >= width p, p == blkBytes*b - n, blkBytes*b >= n) =>\n      [n][8] -> Tag -> [b+2]Blk\npad msg tag = split `{each=blkBytes} (msg # tag # padding)\n  where\n    padding = (repeat `p) : [p][8]\n\nunpad : {n, p, b}\n        (fin n, 8 >= width p, p == blkBytes*b - n, blkBytes*b >= n) =>\n        [b+2]Blk -> ([n][8], Tag, Bit)\nunpad ct = (m, t, good)\n  where\n    padded = join ct\n    m = take `{n} padded\n    t = take `{tagBytes} (drop `{n} padded)\n    p = drop `{n + tagBytes} padded\n    good = p == ((repeat `p) : [p][8]) \/* \/\\ 1 <= p \/\\ p <= 16 *\/\n\nproperty unpad_pad_good_1000_256 msg tag =\n  unpad (pad `{n=1000,p=104} msg tag) == (msg, tag, True)\n\nmee_enc : {n, p, b}\n          (fin n, p == blkBytes*b - n, 8 >= width p, b >= 1, 16*b >= n) =>\n          (Blk -> Blk -> Blk)\n       -> (SKey -> [n][8] -> Tag)\n       -> EKey -> SKey -> Blk -> [n][8] -> [b+2]Blk\nmee_enc enc sign ekey skey iv msg =\n  cbc_enc enc ekey iv (pad msg (sign skey msg))\n\nmee_dec : {n, p, b}\n          (fin n, p == blkBytes*b - n, 8 >= width (32 + p), b >= 1, 16*b >= n)\n       => (EKey -> Blk -> Blk)\n       -> (SKey -> [n][8] -> Tag)\n       -> EKey -> SKey -> Blk -> [b+2]Blk -> ([n][8], Bit)\nmee_dec dec sign ekey skey iv ct = (m, good \/\\ sign skey m == t)\n  where\n    (m, t, good) = unpad (cbc_dec dec ekey iv ct)\n\nproperty mee_enc_dec_good_1000 enc dec sign ekey skey iv msg =\n  mee_dec `{n=1000,p=104} dec sign ekey skey iv ct == (msg, True)\n    where ct = mee_enc `{n=1000,p=104} enc sign ekey skey iv msg\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/trivium.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the two implementations Trivium and Trivium_alt produce equivalent keystream outputs for all valid initial states, and that the shift_regs function correctly updates the internal registers according to the Trivium stream cipher specification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::trivium where\n\nTrivium_stream : [93] -> [84] -> [111] -> [inf]\nTrivium_stream R1 R2 R3 = stream\n\twhere\n\t(stream, ra, rb, rc) = shift_regs R1 R2 R3\n\ntype N = 300\nTrivium : ([93], [84], [111]) -> [N]Bit\nTrivium (reg1, reg2, reg3) = keystream\n  where\n    keystream =  take`{N} (Trivium_stream reg1 reg2 reg3)\n\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n\t\tfills = [bit]#(drop`{1} (fill >> 1))\n\n\nshift_regs : {d,e,f} (fin d, fin e, fin f, d >=1, e >=1, f>=1) => [d] -> [e] -> [f] -> ([inf],[inf][d],[inf][e],[inf][f])\nshift_regs r1 r2 r3 = (stream, regA, regB, regC)\n\twhere\n\n\t\ts1 = [(f1 @ 65) ^ (f1 @ 92)  | f1 <- regA]\n\t\ts2 = [(f2 @ 68) ^ (f2 @ 83)  | f2 <- regB]\n\t\ts3 = [(f3 @ 65) ^ (f3 @ 110) | f3 <- regC]\n\n\t\tstream = s1 ^ s2 ^ s3\n\t\tt1 = [(f1 @ 65) ^ ((f1 @ 90) && (f1 @ 91)) ^ (f1 @ 92) ^ (f2 @ 77) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf1 <- regA ]\n\t\tt2 = [(f2 @ 68) ^ ((f2 @ 81) && (f2 @ 82)) ^ (f2 @ 83) ^ (f3 @ 86) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf3 <- regC ]\n\t\tt3 = [(f3 @ 65) ^ ((f3 @ 108) && (f3 @ 109)) ^ (f3 @ 110) ^ (f1 @ 68)|\n\t\t\t\tf1 <- regA |\n\t\t\t\tf3 <- regC ]\n\n\t\tregA = [r1] # [shift f b| f <- regA | b <- t3]\n\t\tregB = [r2] # [shift f b| f <- regB | b <- t1]\n\t\tregC = [r3] # [shift f b| f <- regC | b <- t2]\n\nTrivium_alt : ([93], [84], [111]) -> [N]Bit\nTrivium_alt (r1, r2, r3) = take`{N} (s1 ^ s2 ^ s3)\n  where\n    a_65 = drop`{27} a_92\n    a_68 = drop`{24} a_92\n    a_90 = drop`{2} a_92\n    a_91 = drop`{1} a_92\n    a_92 = reverse r1 # t3\n\n    b_68 = drop`{15} b_83\n    b_77 = drop`{6} b_83\n    b_81 = drop`{2} b_83\n    b_82 = drop`{1} b_83\n    b_83 = reverse r2 # t1\n\n    c_65 = drop`{45} c_110\n    c_86 = drop`{24} c_110\n    c_108 = drop`{2} c_110\n    c_109 = drop`{1} c_110\n    c_110 = reverse r3 # t2\n\n    s1 = a_65 ^ a_92\n    s2 = b_68 ^ b_83\n    s3 = c_65 ^ c_110\n\n    t1 = s1 ^ (a_90 && a_91) ^ b_77\n    t2 = s2 ^ (b_81 && b_82) ^ c_86\n    t3 = s3 ^ (c_108 && c_109) ^ a_68\n\n\/*********************************************************\/\n\niv1 = 0b111111111111111111101111111111111111111011111111111111111110111111111111111111101111111111111\niv2 = 0b000000000000000000001000000000000000000001000000000000000000001000000000000000000001\niv3 = 0b111111111111111110111111111111111111101111111111111111111011111111111111111110111111111111100000000000000000000\n\ntest_keystream = 0b011111110111101111110100001110000000000000100010000000000000000100011000101100001110001011011010101010000100101110001111100011000110000101001011001111011101110110111010011011010110001000111101101111101100101001000111010001010011111110011100100011101010011110101001001000011100001111111100000001110001\n\nproperty Trivium_correct = (Trivium(iv1, iv2, iv3)) == test_keystream\nproperty Trivium_search (x, y, z) = (Trivium(x, y, z)) == test_keystream\nproperty Trivium_alt_correct = (Trivium_alt(iv1, iv2, iv3)) == test_keystream\nproperty Trivium_alt_equivalent x = take`{200}(Trivium_alt x) == take (Trivium x)\n\ncycle : {n} (fin n) => [n] -> ([93], [84], [111]) -> Bit\ncycle n (rA, rB, rC) =\n  (rA == regAs @ n) \/\\ (rB == regBs @ n) \/\\ (rC == regCs @ n) \/\\ rA != 0 \/\\ rB != 0 \/\\ rC != 0\n    where\n      (_, regAs, regBs, regCs) = shift_regs rA rB rC\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/bivium.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the equivalence between the two implementations of the Bivium stream cipher, Bivium and Bivium_alt, and to check that the keystream output matches the known test vector. Include properties that test the correctness of the shift_regs function and the cycle functions for various cycle counts."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::bivium where\n\nBivium_stream : [93] -> [84] -> [inf]\nBivium_stream R1 R2 = stream\n\twhere\n\t(stream, ra, rb) = shift_regs R1 R2\n\ntype N = 200\nBivium : ([93], [84]) -> [N]Bit\nBivium (reg1, reg2) = keystream\n  where\n    keystream =  take`{N} (Bivium_stream reg1 reg2)\n\n\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n\t\tfills = [bit]#(drop`{1} (fill >> 1))\n\n\nshift_regs : {d,e} (fin d, fin e, d >=1, e >=1) => [d] -> [e] -> ([inf],[inf][d],[inf][e])\nshift_regs r1 r2 = (stream, regA, regB)\n\twhere\n\t\ts1 = [(f1 @ 65) ^ (f1 @ 92) | f1 <- regA]\n\t\ts2 = [(f2 @ 68) ^ (f2 @ 83) | f2 <- regB]\n\n\t\tstream = s1 ^ s2\n\t\tt1 = [(f1 @ 65) ^ ((f1 @ 90) && (f1 @ 91)) ^ (f1 @ 92) ^ (f2 @ 77) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf1 <- regA ]\n\t\tt2 = [(f2 @ 68) ^ ((f2 @ 81) && (f2 @ 82)) ^ (f2 @ 83) ^ (f1 @ 68) |\n\t\t\t\tf1 <- regA |\n\t\t\t\tf2 <- regB ]\n\n\t\tregA = [r1] # [shift f b| f <- regA | b <- t2]\n\t\tregB = [r2] # [shift f b| f <- regB | b <- t1]\n\nBivium_alt : ([93], [84]) -> [N]Bit\nBivium_alt (r1, r2) = take`{N} (s1 ^ s2)\n  where\n    a_65 = drop`{27} a_92\n    a_68 = drop`{24} a_92\n    a_90 = drop`{2} a_92\n    a_91 = drop`{1} a_92\n    a_92 = reverse r1 # t2\n\n    b_68 = drop`{15} b_83\n    b_77 = drop`{6} b_83\n    b_81 = drop`{2} b_83\n    b_82 = drop`{1} b_83\n    b_83 = reverse r2 # t1\n\n    s1 = a_65 ^ a_92\n    s2 = b_68 ^ b_83\n\n    t1 = s1 ^ (a_90 && a_91) ^ b_77\n    t2 = s2 ^ (b_81 && b_82) ^ a_68\n\n\/*************************************************************\/\n\niv1 = 0b111110000000101010100100010001000000101010100001011111111111111100100100111111111011111111111\niv2 = 0b000000000000000000001000000000000000000001000000000000000000001000000000000000000001\n\ntest_keystream = 0b01000010000100000101110001100011111101110101110111111110100001111111100110101001000010101100100010000100001100011100000010001001100101101001011101110100000001011010001101000011001000110011111010100110\n\n\nsuffix = 0b000000001000000000000000000001\nproperty Bivium_correct = (Bivium(iv1, iv2)) == test_keystream\nproperty Bivium_search (x, y) = (Bivium(x, y)) == test_keystream\nproperty Bivium_search_with_suffix (x, y) = (Bivium(x, y#suffix)) == test_keystream\nproperty Bivium_alt_equivalent r = Bivium_alt r == Bivium r\n\ncycle : {n} (fin n) => [n] -> [93] -> [84] -> Bit\ncycle n rA rB =\n  (rA == regAs @ n) \/\\ (rB == regBs @ n) \/\\ rA != 0 \/\\ rB != 0\n    where\n      (_, regAs, regBs) = shift_regs rA rB\n\ncycle0 rA rB = cycle (0 : [8]) rA rB\ncycle1 rA rB = cycle (1 : [8]) rA rB\ncycle2 rA rB = cycle (2 : [8]) rA rB\ncycle3 rA rB = cycle (3 : [8]) rA rB\ncycle4 rA rB = cycle (4 : [8]) rA rB\ncycle5 rA rB = cycle (5 : [8]) rA rB\ncycle10 rA rB = cycle (10 : [8]) rA rB\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/chacha20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the ChaCha20 stream cipher implementation in the given module. Include properties that check the correctness of the quarter round function, the combined column and diagonal rounds, the core block function, key expansion, and the encryption function. Also, write properties that validate the implementation against the provided RFC test vectors to ensure compliance with the ChaCha20 specification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::chacha20 where\n\ntype Round   = [16][32] \/\/ An input to the ChaCha20 core function\ntype Block   = [64][8]  \/\/ An output block from the ChaCha20 core function.\ntype Key     = [32][8]  \/\/ A 32-byte input key\ntype Nonce   = [12][8]  \/\/ A 12-byte nonce\ntype Counter = [32]     \/\/ Starting block counter. Usually 1 or 0.\n\n\/* -- Quarter Round ----------------- *\/\n\n\/\/ The quarter round. This takes 4 32-bit integers and diffuses them\n\/\/ appropriately, and is the core of the column and diagonal round.\nqround : [4][32] -> [4][32]\nqround [ a0, b0, c0, d0 ] = [ a2, b4, c2, d4 ]\n  where\n    a1 = a0 + b0   \/* a += b; d ^= a; d <<<= 16 *\/\n    d1 = d0 ^ a1\n    d2 = d1 <<< 16\n\n    c1 = c0 + d2   \/* c += d; b ^= c; b <<<= 12 *\/\n    b1 = b0 ^ c1\n    b2 = b1 <<< 12\n\n    a2 = a1 + b2   \/* a += b; d ^= a; d <<<= 8 *\/\n    d3 = d2 ^ a2\n    d4 = d3 <<< 8\n\n    c2 = c1 + d4   \/* c += d; b ^= c; b <<<= 7 *\/\n    b3 = b2 ^ c2\n    b4 = b3 <<< 7\n\n\n\/* -- Column and diagonal rounds ---- *\/\n\n\/\/ Perform the column round, followed by the diagonal round on the\n\/\/ input state, which are both defined in terms of the quarter\n\/\/ round. ChaCha20 requires 20 total rounds of interleaving\n\/\/ column\/diagonal passes on the state, and therefore `cdround` actually\n\/\/ does two passes at once (mostly for simplicity).\ncdround : Round -> Round\ncdround [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 ]\n      = [ z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15 ]\n  where\n    \/\/ Column round\n    [ y0, y4, y8,  y12 ] = qround [ x0, x4, x8,  x12 ]\n    [ y1, y5, y9,  y13 ] = qround [ x1, x5, x9,  x13 ]\n    [ y2, y6, y10, y14 ] = qround [ x2, x6, x10, x14 ]\n    [ y3, y7, y11, y15 ] = qround [ x3, x7, x11, x15 ]\n\n    \/\/ Diagonal round\n    [ z0, z5, z10, z15 ] = qround [ y0, y5, y10, y15 ]\n    [ z1, z6, z11, z12 ] = qround [ y1, y6, y11, y12 ]\n    [ z2, z7, z8,  z13 ] = qround [ y2, y7, y8,  y13 ]\n    [ z3, z4, z9,  z14 ] = qround [ y3, y4, y9,  y14 ]\n\n\n\/* -- Block encryption -------------- *\/\n\n\/\/ Given an input round, calculate the core ChaCha20 algorithm over\n\/\/ the round and return an output block. These output blocks form the\n\/\/ stream which you XOR your plaintext with, and successive iterations of\n\/\/ the core algorithm result in an infinite stream you can use as a\n\/\/ cipher.\ncore : Round -> Block\ncore x = block\n  where\n    rounds = iterate cdround x    \/\/ Do a bunch of column\/diagonal passes...\n    result = rounds @ 10          \/\/ And grab the 10th result (20 total passes)\n    block  = blocked (x + result) \/\/ Add to input, convert to output block\n\n\n\/* -- Key Expansion ----------------- *\/\n\n\/\/ Key expansion. Given a nonce and a key, compute a round (which is\n\/\/ fed to the core algorithm above) by taking the initial round state and\n\/\/ mixing in the key and nonce appropriately.\nkexp : Key -> Counter -> Nonce -> Round\nkexp k c n = [ c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15 ]\n  where\n    \/\/ The following describes the layout of the output round, which\n    \/\/ is fed into the core algorithm successively.\n\n    \/\/ Bytes 0-3: Constants\n    [ c0, c1, c2, c3 ] = [ 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574 ]\n\n    \/\/ Bytes 4-11: Key\n    [ c4, c5, c6,  c7 ]  = map rjoin (groupBy`{4} kslice1 : [4][4][8]) : [4][32]\n    [ c8, c9, c10, c11 ] = map rjoin (groupBy`{4} kslice2 : [4][4][8]) : [4][32]\n    kslice1 = k @@ ([ 0  .. 15 ] : [16][32]) \/\/ Top half\n    kslice2 = k @@ ([ 16 .. 31 ] : [16][32]) \/\/ Bottom half\n\n    \/\/ Bytes 12: Counter, starts off with whatever the user specified\n    \/\/ (usually 0 or 1)\n    [ c12 ] = [ c ]\n\n    \/\/ Bytes 14-15: Nonce\n    [ c13, c14, c15 ] = map rjoin (groupBy`{4} n)\n\n\n\/* -- Round increments -------------- *\/\n\n\/\/ Take a given number of iterations and the input round (after key\n\/\/ expansion!), and calculate the input round for the core algorithm\n\/\/ function. This allows you to index into a particular Round which\n\/\/ can be passed to the 'core' function.\niround : [64] -> Round -> Round\niround n r = (iterate once r) @ n where\n  \/\/ Given a round, increment the counter inside (index no 12)\n  once [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12,    x13, x14, x15 ]\n     = [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12+1,  x13, x14, x15 ]\n\n\/\/ Produce a psuedo-random stream given a nonce and a key, which can\n\/\/ be XOR'd with your data to encrypt it.\nstream : {n} (fin n) => Key -> Counter -> Nonce -> [n][8]\nstream k c n = take`{n} (join rounds) \/\/ Take n bytes from the final result\n  where\n    \/\/ Expand key\n    key    = kexp k c n\n\n    \/\/ Produce the stream by successively incrementing the input round\n    \/\/ by `i`, and running the core algorithm to get the resulting\n    \/\/ stream for the `i`th input. Once these are concatenated, you have\n    \/\/ an infinite list representing the ChaCha20 stream.\n    rounds = [ core (iround i key) | i <- [ 0, 1 ... ] ]\n\n\n\/\/ Given an message, a nonce, and a key, produce an encrypted\n\/\/ message. This is simply defined as the XOR of the message and the\n\/\/ corresponding encryption stream.\nencrypt : {n} (fin n) => Key -> Counter -> Nonce -> [n][8] -> [n][8]\nencrypt k c n m = m ^ (stream k c n)\n\n\/* -- Theorems, tests ------------------------------------------------------- *\/\n\n\/\/ Tests are private\nprivate\n  qround01 = qround in == out\n    where\n      in  = [ 0x11111111, 0x01020304, 0x9b8d6f43, 0x01234567 ]\n      out = [ 0xea2a92f4, 0xcb1cf8ce, 0x4581472e, 0x5881c4bb ]\n\n  core01 = kexp k 1 n == out\n    where\n      n = [ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x4a,\n            0x00, 0x00, 0x00, 0x00 ]\n      k = [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f ]\n      out = [ 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,\n              0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,\n              0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c,\n              0x00000001, 0x09000000, 0x4a000000, 0x00000000 ]\n\n  core02 = core (kexp k 1 n) == out\n    where\n      n = [ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x4a,\n            0x00, 0x00, 0x00, 0x00 ]\n      k = [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f ]\n      out = [ 0x10, 0xf1, 0xe7, 0xe4, 0xd1, 0x3b, 0x59, 0x15,\n              0x50, 0x0f, 0xdd, 0x1f, 0xa3, 0x20, 0x71, 0xc4,\n              0xc7, 0xd1, 0xf4, 0xc7, 0x33, 0xc0, 0x68, 0x03,\n              0x04, 0x22, 0xaa, 0x9a, 0xc3, 0xd4, 0x6c, 0x4e,\n              0xd2, 0x82, 0x64, 0x46, 0x07, 0x9f, 0xaa, 0x09,\n              0x14, 0xc2, 0xd7, 0x05, 0xd9, 0x8b, 0x02, 0xa2,\n              0xb5, 0x12, 0x9c, 0xd1, 0xde, 0x16, 0x4e, 0xb9,\n              0xcb, 0xd0, 0x83, 0xe8, 0xa2, 0x50, 0x3c, 0x4e ]\n\n  rfctest01 = encrypt zero zero zero zero\n       == [ 0x76, 0xb8, 0xe0, 0xad, 0xa0, 0xf1, 0x3d, 0x90, 0x40, 0x5d,\n            0x6a, 0xe5, 0x53, 0x86, 0xbd, 0x28, 0xbd, 0xd2, 0x19, 0xb8,\n            0xa0, 0x8d, 0xed, 0x1a, 0xa8, 0x36, 0xef, 0xcc, 0x8b, 0x77,\n            0x0d, 0xc7, 0xda, 0x41, 0x59, 0x7c, 0x51, 0x57, 0x48, 0x8d,\n            0x77, 0x24, 0xe0, 0x3f, 0xb8, 0xd8, 0x4a, 0x37, 0x6a, 0x43,\n            0xb8, 0xf4, 0x15, 0x18, 0xa1, 0x1c, 0xc3, 0x87, 0xb6, 0x69,\n            0xb2, 0xee, 0x65, 0x86 ]\n\n  rfctest02 = encrypt (zero # [1]) 1 (zero # [2]) msg == out\n    where\n      out = [ 0xa3, 0xfb, 0xf0, 0x7d, 0xf3, 0xfa, 0x2f, 0xde, 0x4f, 0x37,\n              0x6c, 0xa2, 0x3e, 0x82, 0x73, 0x70, 0x41, 0x60, 0x5d, 0x9f,\n              0x4f, 0x4f, 0x57, 0xbd, 0x8c, 0xff, 0x2c, 0x1d, 0x4b, 0x79,\n              0x55, 0xec, 0x2a, 0x97, 0x94, 0x8b, 0xd3, 0x72, 0x29, 0x15,\n              0xc8, 0xf3, 0xd3, 0x37, 0xf7, 0xd3, 0x70, 0x05, 0x0e, 0x9e,\n              0x96, 0xd6, 0x47, 0xb7, 0xc3, 0x9f, 0x56, 0xe0, 0x31, 0xca,\n              0x5e, 0xb6, 0x25, 0x0d, 0x40, 0x42, 0xe0, 0x27, 0x85, 0xec,\n              0xec, 0xfa, 0x4b, 0x4b, 0xb5, 0xe8, 0xea, 0xd0, 0x44, 0x0e,\n              0x20, 0xb6, 0xe8, 0xdb, 0x09, 0xd8, 0x81, 0xa7, 0xc6, 0x13,\n              0x2f, 0x42, 0x0e, 0x52, 0x79, 0x50, 0x42, 0xbd, 0xfa, 0x77,\n              0x73, 0xd8, 0xa9, 0x05, 0x14, 0x47, 0xb3, 0x29, 0x1c, 0xe1,\n              0x41, 0x1c, 0x68, 0x04, 0x65, 0x55, 0x2a, 0xa6, 0xc4, 0x05,\n              0xb7, 0x76, 0x4d, 0x5e, 0x87, 0xbe, 0xa8, 0x5a, 0xd0, 0x0f,\n              0x84, 0x49, 0xed, 0x8f, 0x72, 0xd0, 0xd6, 0x62, 0xab, 0x05,\n              0x26, 0x91, 0xca, 0x66, 0x42, 0x4b, 0xc8, 0x6d, 0x2d, 0xf8,\n              0x0e, 0xa4, 0x1f, 0x43, 0xab, 0xf9, 0x37, 0xd3, 0x25, 0x9d,\n              0xc4, 0xb2, 0xd0, 0xdf, 0xb4, 0x8a, 0x6c, 0x91, 0x39, 0xdd,\n              0xd7, 0xf7, 0x69, 0x66, 0xe9, 0x28, 0xe6, 0x35, 0x55, 0x3b,\n              0xa7, 0x6c, 0x5c, 0x87, 0x9d, 0x7b, 0x35, 0xd4, 0x9e, 0xb2,\n              0xe6, 0x2b, 0x08, 0x71, 0xcd, 0xac, 0x63, 0x89, 0x39, 0xe2,\n              0x5e, 0x8a, 0x1e, 0x0e, 0xf9, 0xd5, 0x28, 0x0f, 0xa8, 0xca,\n              0x32, 0x8b, 0x35, 0x1c, 0x3c, 0x76, 0x59, 0x89, 0xcb, 0xcf,\n              0x3d, 0xaa, 0x8b, 0x6c, 0xcc, 0x3a, 0xaf, 0x9f, 0x39, 0x79,\n              0xc9, 0x2b, 0x37, 0x20, 0xfc, 0x88, 0xdc, 0x95, 0xed, 0x84,\n              0xa1, 0xbe, 0x05, 0x9c, 0x64, 0x99, 0xb9, 0xfd, 0xa2, 0x36,\n              0xe7, 0xe8, 0x18, 0xb0, 0x4b, 0x0b, 0xc3, 0x9c, 0x1e, 0x87,\n              0x6b, 0x19, 0x3b, 0xfe, 0x55, 0x69, 0x75, 0x3f, 0x88, 0x12,\n              0x8c, 0xc0, 0x8a, 0xaa, 0x9b, 0x63, 0xd1, 0xa1, 0x6f, 0x80,\n              0xef, 0x25, 0x54, 0xd7, 0x18, 0x9c, 0x41, 0x1f, 0x58, 0x69,\n              0xca, 0x52, 0xc5, 0xb8, 0x3f, 0xa3, 0x6f, 0xf2, 0x16, 0xb9,\n              0xc1, 0xd3, 0x00, 0x62, 0xbe, 0xbc, 0xfd, 0x2d, 0xc5, 0xbc,\n              0xe0, 0x91, 0x19, 0x34, 0xfd, 0xa7, 0x9a, 0x86, 0xf6, 0xe6,\n              0x98, 0xce, 0xd7, 0x59, 0xc3, 0xff, 0x9b, 0x64, 0x77, 0x33,\n              0x8f, 0x3d, 0xa4, 0xf9, 0xcd, 0x85, 0x14, 0xea, 0x99, 0x82,\n              0xcc, 0xaf, 0xb3, 0x41, 0xb2, 0x38, 0x4d, 0xd9, 0x02, 0xf3,\n              0xd1, 0xab, 0x7a, 0xc6, 0x1d, 0xd2, 0x9c, 0x6f, 0x21, 0xba,\n              0x5b, 0x86, 0x2f, 0x37, 0x30, 0xe3, 0x7c, 0xfd, 0xc4, 0xfd,\n              0x80, 0x6c, 0x22, 0xf2, 0x21 ]\n\n      msg = [ 0x41, 0x6e, 0x79, 0x20, 0x73, 0x75, 0x62, 0x6d, 0x69, 0x73,\n              0x73, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68,\n              0x65, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x69, 0x6e, 0x74,\n              0x65, 0x6e, 0x64, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62,\n              0x75, 0x74, 0x6f, 0x72, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x70,\n              0x75, 0x62, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n              0x20, 0x61, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6f, 0x72,\n              0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61,\n              0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x49, 0x6e, 0x74,\n              0x65, 0x72, 0x6e, 0x65, 0x74, 0x2d, 0x44, 0x72, 0x61, 0x66,\n              0x74, 0x20, 0x6f, 0x72, 0x20, 0x52, 0x46, 0x43, 0x20, 0x61,\n              0x6e, 0x64, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x73, 0x74, 0x61,\n              0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x61, 0x64,\n              0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74,\n              0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x20, 0x49, 0x45, 0x54,\n              0x46, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79,\n              0x20, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64,\n              0x65, 0x72, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x20, 0x22, 0x49,\n              0x45, 0x54, 0x46, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69,\n              0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x2e, 0x20, 0x53,\n              0x75, 0x63, 0x68, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6d,\n              0x65, 0x6e, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75,\n              0x64, 0x65, 0x20, 0x6f, 0x72, 0x61, 0x6c, 0x20, 0x73, 0x74,\n              0x61, 0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x69,\n              0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x73, 0x65, 0x73,\n              0x73, 0x69, 0x6f, 0x6e, 0x73, 0x2c, 0x20, 0x61, 0x73, 0x20,\n              0x77, 0x65, 0x6c, 0x6c, 0x20, 0x61, 0x73, 0x20, 0x77, 0x72,\n              0x69, 0x74, 0x74, 0x65, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20,\n              0x65, 0x6c, 0x65, 0x63, 0x74, 0x72, 0x6f, 0x6e, 0x69, 0x63,\n              0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61,\n              0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x6d, 0x61, 0x64, 0x65,\n              0x20, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x69,\n              0x6d, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x70, 0x6c, 0x61, 0x63,\n              0x65, 0x2c, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61,\n              0x72, 0x65, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,\n              0x65, 0x64, 0x20, 0x74, 0x6f ]\n\n  rfctest03 = encrypt key 42 (zero # [2]) msg == out\n    where\n      key = [ 0x1c, 0x92, 0x40, 0xa5, 0xeb, 0x55, 0xd3, 0x8a, 0xf3, 0x33,\n              0x88, 0x86, 0x04, 0xf6, 0xb5, 0xf0, 0x47, 0x39, 0x17, 0xc1,\n              0x40, 0x2b, 0x80, 0x09, 0x9d, 0xca, 0x5c, 0xbc, 0x20, 0x70,\n              0x75, 0xc0 ]\n      out = [ 0x27, 0x54, 0x77, 0x61, 0x73, 0x20, 0x62, 0x72, 0x69, 0x6c,\n              0x6c, 0x69, 0x67, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x73, 0x6c, 0x69, 0x74, 0x68, 0x79, 0x20,\n              0x74, 0x6f, 0x76, 0x65, 0x73, 0x0a, 0x44, 0x69, 0x64, 0x20,\n              0x67, 0x79, 0x72, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x67,\n              0x69, 0x6d, 0x62, 0x6c, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x77, 0x61, 0x62, 0x65, 0x3a, 0x0a, 0x41,\n              0x6c, 0x6c, 0x20, 0x6d, 0x69, 0x6d, 0x73, 0x79, 0x20, 0x77,\n              0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6f,\n              0x72, 0x6f, 0x67, 0x6f, 0x76, 0x65, 0x73, 0x2c, 0x0a, 0x41,\n              0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x6f, 0x6d,\n              0x65, 0x20, 0x72, 0x61, 0x74, 0x68, 0x73, 0x20, 0x6f, 0x75,\n              0x74, 0x67, 0x72, 0x61, 0x62, 0x65, 0x2e ]\n\n      msg = [ 0x62, 0xe6, 0x34, 0x7f, 0x95, 0xed, 0x87, 0xa4, 0x5f, 0xfa,\n              0xe7, 0x42, 0x6f, 0x27, 0xa1, 0xdf, 0x5f, 0xb6, 0x91, 0x10,\n              0x04, 0x4c, 0x0d, 0x73, 0x11, 0x8e, 0xff, 0xa9, 0x5b, 0x01,\n              0xe5, 0xcf, 0x16, 0x6d, 0x3d, 0xf2, 0xd7, 0x21, 0xca, 0xf9,\n              0xb2, 0x1e, 0x5f, 0xb1, 0x4c, 0x61, 0x68, 0x71, 0xfd, 0x84,\n              0xc5, 0x4f, 0x9d, 0x65, 0xb2, 0x83, 0x19, 0x6c, 0x7f, 0xe4,\n              0xf6, 0x05, 0x53, 0xeb, 0xf3, 0x9c, 0x64, 0x02, 0xc4, 0x22,\n              0x34, 0xe3, 0x2a, 0x35, 0x6b, 0x3e, 0x76, 0x43, 0x12, 0xa6,\n              0x1a, 0x55, 0x32, 0x05, 0x57, 0x16, 0xea, 0xd6, 0x96, 0x25,\n              0x68, 0xf8, 0x7d, 0x3f, 0x3f, 0x77, 0x04, 0xc6, 0xa8, 0xd1,\n              0xbc, 0xd1, 0xbf, 0x4d, 0x50, 0xd6, 0x15, 0x4b, 0x6d, 0xa7,\n              0x31, 0xb1, 0x87, 0xb5, 0x8d, 0xfd, 0x72, 0x8a, 0xfa, 0x36,\n              0x75, 0x7a, 0x79, 0x7a, 0xc1, 0x88, 0xd1 ]\n\nproperty allTestsPass =\n  and\n  [ \/\/ Basic tests\n    qround01, core01, core02\n    \/\/ Full RFC test vectors\n  , rfctest01, rfctest02, rfctest03\n  ]\n\n\/* -- Private utilities ----------------------------------------------------- *\/\n\nprivate\n  \/\/ Convert a round into a block, by splitting every 32-bit round entry\n  \/\/ into 4 bytes, and then serialize those values into a full block.\n  blocked : Round -> Block\n  blocked x = join (map toBytes x)\n    where\n      \/\/ This essentially splits a 32-bit number into 4-byte\n      \/\/ little-endian form, where 'rjoin' is the inverse and would merge\n      \/\/ 4 bytes as a 32-bit little endian number.\n      toBytes : [32] -> [4][8]\n      toBytes v = reverse (groupBy`{8} v)\n\n  \/\/ Map a function over a finite list.\n  map : { a, b, c }\n        (a -> b) -> [c]a -> [c]b\n  map f xs = [ f x | x <- xs ]\n\n  \/\/ Map a function iteratively over a seed value, producing an infinite\n  \/\/ list of successive function applications:\n  \/\/\n  \/\/ iterate f 0 == [ 0, f 0, f (f 0), f (f (f 0)), ... ]\n  iterate : { a } (a -> a) -> a -> [inf]a\n  iterate f x = [x] # [ f v | v <- iterate f x ]\n    where\n      \/\/ NB: Needs a binded name in order to tie the recursive knot.\n      xs = [x] # [ f v | v <- xs ]\n\n  \/\/ rjoin = join . reverse\n  \/\/ This encodes a sequence of values as a little endian number\n  \/\/ e.g. [ 0xaa, 0xbb, 0xcc, 0xdd ] is serialized as \\xdd\\xcc\\xbb\\xaa\n  rjoin : {a, b, c}\n        ( fin a, fin c\n        ) => [c][a]b -> [a * c]b\n  rjoin x = join (reverse x)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/ZUC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the ZUC stream cipher implementation in the provided file. Include properties that check the correctness of the GF(2^31-1) addition, the LFSR initialization and work modes, the bit reorganization function, the F function and its components (S-boxes, L1, L2), and the overall ZUC keystream generation against the provided test vectors. Additionally, specify a property to verify resistance to collision attacks for version 1.5 as indicated in the code comments."},{"role":"assistant","content":"```cryptol\n\/\/ Version info: If the following variable is set to True, then we implement\n\/\/ Version 1.5 of ZUC. Otherwise, version 1.4 is implemented. There are\n\/\/ precisely two points in the implementation where the difference matters,\n\/\/ search for occurrences of version1_5 to spot them.\n\n\/\/ Note that the ZUC test vectors below will not work for version 1.4, as the\n\/\/ old test vectors are no longer published.\n\nmodule Primitive::Symmetric::Cipher::Stream::ZUC where\n\nversion1_5 : Bit\nversion1_5 = True\n\n\/\/ addition in GF(2^31-1) over a list of terms\nadd : {a} (fin a) => [a][31] -> [31]\nadd xs =\n    sums ! 0\n    where\n      sums =\n          [0] #\n          [plus (s, x) | s <- sums\n                       | x <- xs]\n      \/\/ the binary addition specified in the note at the end of section 3.2\n      plus : ([31], [31]) -> [31]\n      plus (a, b) =\n          if sab @ 0 then sab' + 1 else sab'\n          where\n            sab : [32]\n            sab = ((zero : [1]) # a) + ((zero : [1]) # b)\n            sab' : [31]\n            sab' = drop sab\n\n\/\/ The ZUC LFSR is 16 31-bit words\ntype LFSR = [16][31]\n\n\/\/ Section 3.2\nLFSRWithInitializationMode : ([31], LFSR) -> LFSR\nLFSRWithInitializationMode (u, ss) =\n    ss @@ [1 .. 15] # [s16]\n    where\n      v = add [s <<< c | s <- ss @@ [15, 13, 10, 4, 0, 0]\n                       | c <- [15, 17, 21, 20, 8, 0]]\n      vu = if version1_5 then add [v, u] else v ^ u\n      s16 = if vu == 0 then `0x7FFFFFFF else vu\n\n\/\/ Section 3.2\nLFSRWithWorkMode : LFSR -> LFSR\nLFSRWithWorkMode ss =\n    ss @@ [1 .. 15] # [s16]\n    where\n      v = add [s <<< c | s <- ss @@ [15, 13, 10, 4, 0, 0]\n                       | c <- [15, 17, 21, 20, 8, 0]]\n      s16 = if v == 0 then `0x7FFFFFFF else v\n\n\/\/ Section 3.3\nBitReorganization : LFSR -> [4][32]\nBitReorganization ss =\n    [ hi s15 # lo s14\n    , lo s11 # hi s9\n    , lo s7  # hi s5\n    , lo s2  # hi s0]\n    where\n      lo : [31] -> [16]\n      hi : [31] -> [16]\n      lo x = x @@ [15 .. 30]\n      hi x = x @@ [0  .. 15]\n      [s0, s2, s5, s7, s9, s11, s14, s15] = ss @@ [0, 2, 5, 7, 9, 11, 14, 15]\n\n\/\/ Section 3.4\nF : ([3][32], [2][32]) -> ([32], [2][32])\nF ([X0, X1, X2], [R1, R2]) =\n    (W, [R1', R2'])\n    where\n      W = (X0 ^ R1) + R2\n      W1 = R1 + X1\n      W2 = R2 ^ X2\n      [W1H, W1L] = split W1\n      [W2H, W2L] = split W2\n      R1' = S (L1 (W1L # W2H))\n      R2' = S (L2 (W2L # W1H))\n\n\/\/ Section 3.4.1\nS : [32] -> [32]\nS X =\n    Y0 # Y1 # Y2 # Y3\n    where\n      [X0, X1, X2, X3] = split X\n      [Y0, Y1, Y2, Y3] = [S0 X0, S1 X1, S2 X2, S3 X3]\n\n\/\/ Example 8\nproperty example8 = S(0x12345678) == 0xF9C05A4E\n\nS0 : [8] -> [8]\nS1 : [8] -> [8]\nS2 : [8] -> [8]\nS3 : [8] -> [8]\nS0 x = S0Table @ x\nS1 x = S1Table @ x\nS2 = S0\nS3 = S1\n\n\/\/ Table 3.1\nS0Table : [256][8]\nS0Table =\n    [0x3E, 0x72, 0x5B, 0x47, 0xCA, 0xE0, 0x00, 0x33, 0x04, 0xD1, 0x54,\n     0x98, 0x09, 0xB9, 0x6D, 0xCB, 0x7B, 0x1B, 0xF9, 0x32, 0xAF, 0x9D,\n     0x6A, 0xA5, 0xB8, 0x2D, 0xFC, 0x1D, 0x08, 0x53, 0x03, 0x90, 0x4D,\n     0x4E, 0x84, 0x99, 0xE4, 0xCE, 0xD9, 0x91, 0xDD, 0xB6, 0x85, 0x48,\n     0x8B, 0x29, 0x6E, 0xAC, 0xCD, 0xC1, 0xF8, 0x1E, 0x73, 0x43, 0x69,\n     0xC6, 0xB5, 0xBD, 0xFD, 0x39, 0x63, 0x20, 0xD4, 0x38, 0x76, 0x7D,\n     0xB2, 0xA7, 0xCF, 0xED, 0x57, 0xC5, 0xF3, 0x2C, 0xBB, 0x14, 0x21,\n     0x06, 0x55, 0x9B, 0xE3, 0xEF, 0x5E, 0x31, 0x4F, 0x7F, 0x5A, 0xA4,\n     0x0D, 0x82, 0x51, 0x49, 0x5F, 0xBA, 0x58, 0x1C, 0x4A, 0x16, 0xD5,\n     0x17, 0xA8, 0x92, 0x24, 0x1F, 0x8C, 0xFF, 0xD8, 0xAE, 0x2E, 0x01,\n     0xD3, 0xAD, 0x3B, 0x4B, 0xDA, 0x46, 0xEB, 0xC9, 0xDE, 0x9A, 0x8F,\n     0x87, 0xD7, 0x3A, 0x80, 0x6F, 0x2F, 0xC8, 0xB1, 0xB4, 0x37, 0xF7,\n     0x0A, 0x22, 0x13, 0x28, 0x7C, 0xCC, 0x3C, 0x89, 0xC7, 0xC3, 0x96,\n     0x56, 0x07, 0xBF, 0x7E, 0xF0, 0x0B, 0x2B, 0x97, 0x52, 0x35, 0x41,\n     0x79, 0x61, 0xA6, 0x4C, 0x10, 0xFE, 0xBC, 0x26, 0x95, 0x88, 0x8A,\n     0xB0, 0xA3, 0xFB, 0xC0, 0x18, 0x94, 0xF2, 0xE1, 0xE5, 0xE9, 0x5D,\n     0xD0, 0xDC, 0x11, 0x66, 0x64, 0x5C, 0xEC, 0x59, 0x42, 0x75, 0x12,\n     0xF5, 0x74, 0x9C, 0xAA, 0x23, 0x0E, 0x86, 0xAB, 0xBE, 0x2A, 0x02,\n     0xE7, 0x67, 0xE6, 0x44, 0xA2, 0x6C, 0xC2, 0x93, 0x9F, 0xF1, 0xF6,\n     0xFA, 0x36, 0xD2, 0x50, 0x68, 0x9E, 0x62, 0x71, 0x15, 0x3D, 0xD6,\n     0x40, 0xC4, 0xE2, 0x0F, 0x8E, 0x83, 0x77, 0x6B, 0x25, 0x05, 0x3F,\n     0x0C, 0x30, 0xEA, 0x70, 0xB7, 0xA1, 0xE8, 0xA9, 0x65, 0x8D, 0x27,\n     0x1A, 0xDB, 0x81, 0xB3, 0xA0, 0xF4, 0x45, 0x7A, 0x19, 0xDF, 0xEE,\n     0x78, 0x34, 0x60]\n\n\/\/ Table 3.2\nS1Table : [256][8]\nS1Table =\n    [0x55, 0xC2, 0x63, 0x71, 0x3B, 0xC8, 0x47, 0x86, 0x9F, 0x3C, 0xDA,\n     0x5B, 0x29, 0xAA, 0xFD, 0x77, 0x8C, 0xC5, 0x94, 0x0C, 0xA6, 0x1A,\n     0x13, 0x00, 0xE3, 0xA8, 0x16, 0x72, 0x40, 0xF9, 0xF8, 0x42, 0x44,\n     0x26, 0x68, 0x96, 0x81, 0xD9, 0x45, 0x3E, 0x10, 0x76, 0xC6, 0xA7,\n     0x8B, 0x39, 0x43, 0xE1, 0x3A, 0xB5, 0x56, 0x2A, 0xC0, 0x6D, 0xB3,\n     0x05, 0x22, 0x66, 0xBF, 0xDC, 0x0B, 0xFA, 0x62, 0x48, 0xDD, 0x20,\n     0x11, 0x06, 0x36, 0xC9, 0xC1, 0xCF, 0xF6, 0x27, 0x52, 0xBB, 0x69,\n     0xF5, 0xD4, 0x87, 0x7F, 0x84, 0x4C, 0xD2, 0x9C, 0x57, 0xA4, 0xBC,\n     0x4F, 0x9A, 0xDF, 0xFE, 0xD6, 0x8D, 0x7A, 0xEB, 0x2B, 0x53, 0xD8,\n     0x5C, 0xA1, 0x14, 0x17, 0xFB, 0x23, 0xD5, 0x7D, 0x30, 0x67, 0x73,\n     0x08, 0x09, 0xEE, 0xB7, 0x70, 0x3F, 0x61, 0xB2, 0x19, 0x8E, 0x4E,\n     0xE5, 0x4B, 0x93, 0x8F, 0x5D, 0xDB, 0xA9, 0xAD, 0xF1, 0xAE, 0x2E,\n     0xCB, 0x0D, 0xFC, 0xF4, 0x2D, 0x46, 0x6E, 0x1D, 0x97, 0xE8, 0xD1,\n     0xE9, 0x4D, 0x37, 0xA5, 0x75, 0x5E, 0x83, 0x9E, 0xAB, 0x82, 0x9D,\n     0xB9, 0x1C, 0xE0, 0xCD, 0x49, 0x89, 0x01, 0xB6, 0xBD, 0x58, 0x24,\n     0xA2, 0x5F, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xB8, 0x95, 0xE4,\n     0xD0, 0x91, 0xC7, 0xCE, 0xED, 0x0F, 0xB4, 0x6F, 0xA0, 0xCC, 0xF0,\n     0x02, 0x4A, 0x79, 0xC3, 0xDE, 0xA3, 0xEF, 0xEA, 0x51, 0xE6, 0x6B,\n     0x18, 0xEC, 0x1B, 0x2C, 0x80, 0xF7, 0x74, 0xE7, 0xFF, 0x21, 0x5A,\n     0x6A, 0x54, 0x1E, 0x41, 0x31, 0x92, 0x35, 0xC4, 0x33, 0x07, 0x0A,\n     0xBA, 0x7E, 0x0E, 0x34, 0x88, 0xB1, 0x98, 0x7C, 0xF3, 0x3D, 0x60,\n     0x6C, 0x7B, 0xCA, 0xD3, 0x1F, 0x32, 0x65, 0x04, 0x28, 0x64, 0xBE,\n     0x85, 0x9B, 0x2F, 0x59, 0x8A, 0xD7, 0xB0, 0x25, 0xAC, 0xAF, 0x12,\n     0x03, 0xE2, 0xF2]\n\n\/\/ Section 3.4.2\nL1 : [32] -> [32]\nL1 X = X ^ X <<< 2 ^ X <<< 10 ^ X <<< 18 ^ X <<< 24\n\n\/\/ Section 3.4.2\nL2 : [32] -> [32]\nL2 X = X ^ X <<< 8 ^ X <<< 14 ^ X <<< 22 ^ X <<< 30\n\n\/\/ Section 3.5\nLoadKey : ([128], [128]) -> LFSR\nLoadKey (key, iv) =\n    [k # d # i | k <- ks\n               | i <- is\n               | d <- ds]\n    where\n      ks : [16][8]\n      ks = split key\n      is : [16][8]\n      is = split iv\n      ds : [16][15]\n      ds =\n          [ 0b100010011010111, 0b010011010111100\n          , 0b110001001101011, 0b001001101011110\n          , 0b101011110001001, 0b011010111100010\n          , 0b111000100110101, 0b000100110101111\n          , 0b100110101111000, 0b010111100010011\n          , 0b110101111000100, 0b001101011110001\n          , 0b101111000100110, 0b011110001001101\n          , 0b111100010011010, 0b100011110101100\n          ]\n\ntype ZUC = (LFSR, [32], [32])\n\n\/\/ Return an infinite sequence of ZUC states by applying the initialization step\n\/\/ repeatedly. This is a generalization of section 3.6.1\nInitializeZUC : ([128], [128]) -> [inf]ZUC\nInitializeZUC (key, iv) =\n    outs\n    where\n      initLFSR = LoadKey (key, iv)\n      outs = [(initLFSR, 0, 0)] # [step out | out <- outs]\n      step (lfsr, R1, R2) =\n          (LFSRWithInitializationMode (drop (w >> 1), lfsr), R1', R2')\n          where\n            [X0, X1, X2, X3] = BitReorganization lfsr\n            (w', [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n            w = if version1_5 then w' else w' ^ X3\n\n\/\/ Section 3.6.2\nWorkingStage : ZUC -> ZUC\nWorkingStage (lfsr, R1, R2) =\n    (lfsr', R1', R2')\n    where\n      [X0, X1, X2, _] = BitReorganization lfsr\n      (_, [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n      lfsr' = LFSRWithWorkMode lfsr\n\n\/\/ Section 3.6.2\nProductionStage : ZUC -> ([32], ZUC)\nProductionStage (lfsr, R1, R2) =\n    (w ^ X3, (lfsr', R1', R2'))\n    where\n      [X0, X1, X2, X3] = BitReorganization lfsr\n      (w, [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n      lfsr' = LFSRWithWorkMode lfsr\n\n\/\/ ZUC API\nZUC : [128] -> [128] -> [inf][32]\nZUC key iv =\n    tail [w | (w, _) <- zucs]\n    where\n      initZuc = WorkingStage (InitializeZUC (key, iv) @ 32)\n      zucs = [(zero, initZuc)] # [ProductionStage zuc | (_, zuc) <- zucs]\n\n\/\/ Test vectors\nproperty ZUC_TestVectors =\n    t1 \/\\ t2 \/\\ t3 \/\\ t4\n    where\n      t1 = take (ZUC zero    zero   ) == [0x27BEDE74, 0x018082DA]\n      t2 = take (ZUC (~zero) (~zero)) == [0x0657CFA0, 0x7096398B]\n      t3 = take (ZUC (join [ 0x3D, 0x4C, 0x4B, 0xE9, 0x6A, 0x82, 0xFD, 0xAE\n                           , 0xB5, 0x8F, 0x64, 0x1D, 0xB1, 0x7B, 0x45, 0x5B\n                           ])\n                     (join [ 0x84, 0x31, 0x9A, 0xA8, 0xDE, 0x69, 0x15, 0xCA\n                           , 0x1F, 0x6B, 0xDA, 0x6B, 0xFB, 0xD8, 0xC7, 0x66\n                           ])) == [0x14F1C272, 0x3279C419]\n      t4 = take ks # [ks @ 1999] == [0xED4400E7, 0x0633E5C5, 0x7A574CDB]\n        where\n          ks = ZUC (join [ 0x4D, 0x32, 0x0B, 0xFA, 0xD4, 0xC2, 0x85, 0xBF\n                         , 0xD6, 0xB8, 0xBD, 0x00, 0xF3, 0x9D, 0x8B, 0x41\n                         ])\n                   (join [ 0x52, 0x95, 0x9D, 0xAB, 0xA0, 0xBF, 0x17, 0x6E\n                         , 0xCE, 0x2D, 0xC3, 0x15, 0x04, 0x9E, 0xB5, 0x74\n                         ])\n\n\/\/ 3.3-3.6 of the implementor's test data document lists \"LFSR-state at the\n\/\/ beginning\", which is immediately after running LoadKey.\nproperty LoadKey_TestVectors =\n    [ LoadKey(k, iv) == lfsr0\n    | k <- ks\n    | iv <- ivs\n    | lfsr0 <- lfsr0s\n    ] == ~0\n  where\n    ks = [ 0\n         , ~0\n         , 0x3d4c4be96a82fdaeb58f641db17b455b\n         , 0x4d320bfad4c285bfd6b8bd00f39d8b41\n         ]\n    ivs = [ 0\n          , ~0\n          , 0x84319aa8de6915ca1f6bda6bfbd8c766\n          , 0x52959daba0bf176ece2dc315049eb574\n          ]\n    lfsr0s = [ [ `0x0044d700, `0x0026bc00, `0x00626b00, `0x00135e00\n               , `0x00578900, `0x0035e200, `0x00713500, `0x0009af00\n               , `0x004d7800, `0x002f1300, `0x006bc400, `0x001af100\n               , `0x005e2600, `0x003c4d00, `0x00789a00, `0x0047ac00\n               ]\n             , [ `0x7fc4d7ff, `0x7fa6bcff, `0x7fe26bff, `0x7f935eff\n               , `0x7fd789ff, `0x7fb5e2ff, `0x7ff135ff, `0x7f89afff\n               , `0x7fcd78ff, `0x7faf13ff, `0x7febc4ff, `0x7f9af1ff\n               , `0x7fde26ff, `0x7fbc4dff, `0x7ff89aff, `0x7fc7acff\n               ]\n             , [ `0x1ec4d784, `0x2626bc31, `0x25e26b9a, `0x74935ea8\n               , `0x355789de, `0x4135e269, `0x7ef13515, `0x5709afca\n               , `0x5acd781f, `0x47af136b, `0x326bc4da, `0x0e9af16b\n               , `0x58de26fb, `0x3dbc4dd8, `0x22f89ac7, `0x2dc7ac66\n               ]\n             , [ `0x26c4d752, `0x1926bc95, `0x05e26b9d, `0x7d135eab\n               , `0x6a5789a0, `0x6135e2bf, `0x42f13517, `0x5f89af6e\n               , `0x6b4d78ce, `0x5c2f132d, `0x5eebc4c3, `0x001af115\n               , `0x79de2604, `0x4ebc4d9e, `0x45f89ab5, `0x20c7ac74\n               ]\n             ]\n\n\n\/\/ Collision attack on ZUC. Only version1.5 is resistant to it. Thus, the\n\/\/ following theorem holds only when version1_5 is set to True.\n\/\/\n\/\/ NB. We only compare the first output of the InitializeZUC sequence, as it\n\/\/ cuts down on the problem size and is sufficient to ensure the iv's will be\n\/\/ the same. That is, if this theorem fails, then so would the final iv's used\n\/\/ by ZUC.\n\/\/\n\/\/ Use a solver other than CVC4; Z3 and Boolector do it quickly.\nproperty ZUC_isResistantToCollisionAttack k iv1 iv2 =\n    if iv1 != iv2\n    then InitializeZUC (k, iv1) @ 1 != InitializeZUC (k, iv2) @ 1\n    else True\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/McMambo.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and equivalence of the McMambo block cipher implementation, including proofs that the transformations T, Q, D, D', and K are bijective and inverses where applicable, that the byte conversion functions from_bytes and to_bytes are inverses, and that the encryption functions C and C' are equivalent and invertible. Also, specify properties to verify the correctness of the Mambo and Mambo_bytes functions against known test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::McMambo where\n\ntype word = [32]\ntype state = [4][4]word\ntype key = [8]word\ntype tweak = [16]word\ntype block = [16]word\n\nnand : {a} [a] -> [a] -> [a]\nnand x y = ~(x && y)\n\nnor : {a} [a] -> [a] -> [a]\nnor x y = ~(x || y)\n\n(\u2191) = nand\n(\u2193) = nor\n(\u2295) = (^)\n(\u2227) = (&&)\n(\u2228) = (||)\n\nR : (word, word) -> word\nR (x, c) = x <<< c\n\nT : word -> tweak -> state -> state\nT n t s = s \u2295 (if n == 5 then split t else zero)\n\n\n\/**\n * ```repl\n * :prove T_bijective\n * ```\n *\/\nproperty T_bijective t n s s' =\n  (s != s') == (T n t s != T n t s')\n\n\/**\n * ```repl\n * :prove T_inverse\n * ```\n *\/\nproperty T_inverse n t s =\n  T n t (T n t s) == s\n\nQ : [4]word -> [4]word\nQ [x0, x1, x2, x3] = [y0, y1, y2, y3]\n  where\n    y1 = x1 \u2295 R (x0 \u2227 x2, 7)\n    y2 = x2 \u2295 R (x0 \u2228 x3, 9)\n    y3 = x3 \u2295 R (y1 \u2191 x0, 13)\n    y0 = x0 \u2295 R (y1 \u2193 y2, 18)\n\n\/**\n * ```repl\n * :prove Q_bijective\n * ```\n *\/\nproperty Q_bijective x x' =\n  (x != x') == (Q x != Q x')\n\nD : state -> state\nD X = Z\n  where\n    Y = transpose [ Q xs | xs <- X ]\n    Z = transpose [ Q ys | ys <- Y ]\n\nD' : state -> state\nD' X = Z\n  where\n    Y = [ Q xs | xs <- transpose X ]\n    Z = [ Q ys | ys <- transpose Y ]\n\nD_verbose : state -> state\nD_verbose [ [ x0,  x1,  x2,  x3]\n          , [ x4,  x5,  x6,  x7]\n          , [ x8,  x9, x10, x11]\n          , [x12, x13, x14, x15] ] = Z\n  where\n    [ y0,  y1,  y2,  y3] = Q [ x0,  x1,  x2,  x3]\n    [ y4,  y5,  y6,  y7] = Q [ x4,  x5,  x6,  x7]\n    [ y8,  y9, y10, y11] = Q [ x8,  x9, x10, x11]\n    [y12, y13, y14, y15] = Q [x12, x13, x14, x15]\n    [ z0,  z4,  z8, z12] = Q [ y0,  y4,  y8, y12]\n    [ z1,  z5,  z9, z13] = Q [ y1,  y5,  y9, y13]\n    [ z2,  z6, z10, z14] = Q [ y2,  y6, y10, y14]\n    [ z3,  z7, z11, z15] = Q [ y3,  y7, y11, y15]\n    Z = [ [ z0,  z1,  z2,  z3]\n        , [ z4,  z5,  z6,  z7]\n        , [ z8,  z9, z10, z11]\n        , [z12, z13, z14, z15] ]\n\nD'_verbose : state -> state\nD'_verbose [ [ x0,  x1,  x2,  x3]\n           , [ x4,  x5,  x6,  x7]\n           , [ x8,  x9, x10, x11]\n           , [x12, x13, x14, x15] ] = Z\n  where\n    [ y0,  y4,  y8, y12] = Q [ x0,  x4,  x8, x12]\n    [ y1,  y5,  y9, y13] = Q [ x1,  x5,  x9, x13]\n    [ y2,  y6, y10, y14] = Q [ x2,  x6, x10, x14]\n    [ y3,  y7, y11, y15] = Q [ x3,  x7, x11, x15]\n    [ z0,  z1,  z2,  z3] = Q [ y0,  y1,  y2,  y3]\n    [ z4,  z5,  z6,  z7] = Q [ y4,  y5,  y6,  y7]\n    [ z8,  z9, z10, z11] = Q [ y8,  y9, y10, y11]\n    [z12, z13, z14, z15] = Q [y12, y13, y14, y15]\n    Z = [ [ z0,  z1,  z2,  z3]\n        , [ z4,  z5,  z6,  z7]\n        , [ z8,  z9, z10, z11]\n        , [z12, z13, z14, z15] ]\n\n\/**\n * ```repl\n * :prove D_matches\n * ```\n *\/\nproperty D_matches =\n  D === D_verbose\n\n\/**\n * ```repl\n * :prove D'_matches\n * ```\n *\/\nproperty D'_matches =\n  D' === D'_verbose\n\nD_D'_correct s =\n  D' (D s) == s\n\nK : key -> word -> state -> state\nK [k0, k1, k2, k3, k4, k5, k6, k7] j x =\n  x \u2295 [ [  j, k0,  0, k1 ]\n      , [ k2,  j, k3,  0 ]\n      , [  0, k4,  j, k5 ]\n      , [ k6,  0, k7,  j ]\n      ]\n\n\/**\n * ```repl\n * :prove K_inverse\n * ```\n *\/\nproperty K_inverse k j s =\n  K k j (K k j s) == s\n\nC1 : key -> tweak -> state -> state\nC1 k t s0 = K k 0 (T 1 t (D (K k 1 (T 0 t (D (K k 0 s0))))))\n\nC : key -> tweak -> state -> state\nC k t s0 = K k 0 (ss!0)\n  where\n    ss : [13]state\n    ss = [s0] # [ T n t (D (K k n s)) | s <- ss | n <- [0..11] ]\n\nC' : key -> tweak -> state -> state\nC' k t s0 = ss!0\n  where\n    ss : [13]state\n    ss = [K k 0 s0] # [ K k n (D' (T n t s)) | s <- ss | n <- reverse [0..11] ]\n\nfrom_bytes : {a} [a*4][8] -> [a][32]\nfrom_bytes bytes = [ join (reverse xs) | (xs : [4][8]) <- blocks ]\n  where blocks : [a][4][8]\n        blocks = split bytes\n\nto_bytes : {a} [a][32] -> [a*4][8]\nto_bytes words = join [ reverse (split word : [4][8]) | word <- words ]\n\n\/**\n * ```repl\n * :prove from_to_bytes\n * ```\n *\/\nproperty from_to_bytes (words : [16][32]) =\n  from_bytes (to_bytes words) == words\n\n\/**\n * ```repl\n * :prove to_from_bytes\n * ```\n *\/\nproperty to_from_bytes (bytes : [64][8]) =\n  to_bytes (from_bytes bytes) == bytes\n\nC_C'_correct k t s0 =\n  C' k t (C k t s0) == s0\n\npad : {n, b} (fin n, b == (n+8) \/^ 512) => [n] -> [b][512]\npad m = split (m # 0x01 # zero)\n\npad_bytes : {n, b} (fin n, b == (n+1) \/^ 64) => [n][8] -> [b*64][8]\npad_bytes m = m # [0x01] # zero\n\nMambo : key -> tweak -> block -> block\nMambo k t m = join (C k t (split m))\n\nMambo' : key -> tweak -> block -> block\nMambo' k t m = join (C' k t (split m))\n\nMambo_bytes : [_][8] -> [_][8] -> [_][8] -> _\nMambo_bytes k t m = to_bytes (Mambo (from_bytes k) (from_bytes t) (from_bytes m))\n\nMambo_bytes' : [_][8] -> [_][8] -> [_][8] -> _\nMambo_bytes' k t m = to_bytes (Mambo' (from_bytes k) (from_bytes t) (from_bytes m))\n\n\/**\n * ```repl\n * :prove Mambo_test\n * ```\n *\/\nproperty Mambo_test =\n  join (Mambo_bytes (\"Me\" # zero) (\"Try\" # zero) (\"Test\" # zero)) ==\n  0xeb514a1ff2609f3a81ccfdd5e5342dba332d7b159a1571cee66d14bb6fd48ceb1ae956a91d3f54c8a545262c26611245a917d0a1582ecbc1d397b612baf7a62d\n\nMcMambo k ad npub M = undefined\n  where\n    Us = [zero] # [ u ^ Mambo_bytes k u a | u <- Us | a <- split (pad_bytes ad) ]\n    \u03c4 = Mambo_bytes k (Us!0) npub\n    u' = (Us!0) ^ \u03c4\n    Cs = [ Mambo_bytes k u m | u <- undefined | m <- split (pad_bytes M # \u03c4)]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/PRESENT.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the PRESENT block cipher implementation in this module. Specifically, create properties that prove the decryption function is the inverse of the encryption function for both 80-bit and 128-bit keys, ensuring that decrypt(encrypt(m)) == m holds for all valid messages and keys. Additionally, write properties to verify the correctness of the key schedule and round functions, and include test vectors as properties to validate the implementation against known ciphertext outputs."},{"role":"assistant","content":"```cryptol\n\/**\n * Cryptol PRESENT Implementation\n * @copyright Galois Inc. 2018\n * www.cryptol.net\n *\n * Source: \"PRESENT: An Ultra-Lightweight Block Cipher\" by Bogdanov et. al\n * @author Ajay Kumar Eeralla\n * Block size: 64 bits, key size:80, 128 bits\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::PRESENT where\n\ntype PrBlockSize = 64\ntype State = [4][4][4]\ntype StdBlockSize = 32\ntype PrKeySize = 80\ntype PrRkeySize = 64\ntype PrKeySize128 = 128\n\n\n\/\/S-box\n\nsbox = [0xc, 0x5, 0x6, 0xb, 0x9, 0x0, 0xa, 0xd, 0x3, 0xe, 0xf, 0x8, 0x4, 0x7, 0x1, 0x2]\n\nSbox_inv = [0x5, 0xe, 0xf, 0x8, 0xc, 0x1, 0x2, 0xd, 0xb, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xa]\n\n\/\/pLayer\n\npbox = [0x00, 0x10, 0x20, 0x30, 0x01, 0x11, 0x21, 0x31, 0x02, 0x12, 0x22,\n        0x32, 0x03, 0x13, 0x23, 0x33, 0x04, 0x14, 0x24, 0x34, 0x05, 0x15,\n        0x25, 0x35, 0x06, 0x16, 0x26, 0x36, 0x07, 0x17, 0x27, 0x37, 0x08,\n        0x18, 0x28, 0x38, 0x09, 0x19, 0x29, 0x39, 0x0a, 0x1a, 0x2a, 0x3a,\n        0x0b, 0x1b, 0x2b, 0x3b, 0x0c, 0x1c, 0x2c, 0x3c, 0x0d, 0x1d, 0x2d,\n        0x3d, 0x0e, 0x1e, 0x2e, 0x3e, 0x0f, 0x1f, 0x2f, 0x3f]\n\npbox_inv = [0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c, 0x20, 0x24, 0x28,\n          0x2c, 0x30, 0x34, 0x38, 0x3c, 0x01, 0x05, 0x09, 0x0d, 0x11, 0x15,\n          0x19, 0x1d, 0x21, 0x25, 0x29, 0x2d, 0x31, 0x35, 0x39, 0x3d, 0x02,\n          0x06, 0x0a, 0x0e, 0x12, 0x16, 0x1a, 0x1e, 0x22, 0x26, 0x2a, 0x2e,\n          0x32, 0x36, 0x3a, 0x3e, 0x03, 0x07, 0x0b, 0x0f, 0x13, 0x17, 0x1b,\n          0x1f, 0x23, 0x27, 0x2b, 0x2f, 0x33, 0x37, 0x3b, 0x3f]\n\n\/\/ Key schedule - 80bits\n\nupdateKey : [PrKeySize] -> [5] -> _\nupdateKey key i =  (rkey, shift, res,  key'')\n            where rkey = key !![79,78..16]\n                  shift =  (key !! [18,17..0]) # (key !! [79,78..19])\n                  res = sbox@((shift) !! [79,78,77, 76]) # (shift !! [75,74..0])\n                  key'' =  (res !! [79,78..20]) # ((res!![19,18..15])^(i+1)) # (res!![14,13..0])\n\n\/\/Round key List\n\nRoundKeyList : [PrKeySize] -> _\n\nRoundKeyList key = hs\n             where hs = [ (updateKey key 0) ] # [(updateKey (key'.3) i)\n                                                | i<- [1,2..31]\n                                                | key' <- hs\n                                                 ]\n\n\/\/ Add round key\n\naddRoundKey : State -> State -> State\naddRoundKey pt key = pt ^ key\n\n\/\/Substitute Sbox\n\nSubCell : [4] -> [4]\nSubCell st = sbox@st\n\nSubCells : State -> State\nSubCells st = [ [ SubCell b | b<- row ] | row <- st ]\n\n\/\/Sbox Layer for decryption\n\nSubCell_dec : [4] -> [4]\nSubCell_dec st = Sbox_inv@st\n\nSubCells_dec : State -> State\nSubCells_dec st = [ [ SubCell_dec b | b<- row ] | row <- st ]\n\n\/\/ Message to state\n\nmsgToState : [PrBlockSize] -> State\nmsgToState msg = split (split msg)\n\nstateToMsg : State -> [PrBlockSize]\nstateToMsg st = join (join st)\n\n\/\/pemutation Layer\n\nSubpLayer: [PrBlockSize] -> [PrBlockSize]\nSubpLayer pt =  hs\n          where hs = [ pt!(pbox_inv ! i) | i <- [0,1..63] ]\n\n\/\/pLayer for decryption\n\nSubpLayer_dec: [PrBlockSize] -> [PrBlockSize]\nSubpLayer_dec pt =  hs\n          where hs = [ pt!(pbox ! i) | i <- [0,1..63] ]\n\n\/\/round encryption\n\nroundEncrypt:  (State, State) -> State\nroundEncrypt (pt, key) = msgToState(SubpLayer(stateToMsg(SubCells (addRoundKey pt key))))\n\n\/\/round Decryption\n\nroundDecrypt:  (State, State) -> State\nroundDecrypt (pt, key) = SubCells_dec (msgToState(SubpLayer_dec (stateToMsg (addRoundKey pt key))))\n\n\/\/ Encryption-80bits\n\nPrEncrypt : ([PrKeySize], [PrBlockSize]) -> [PrBlockSize]\nPrEncrypt (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                where hs = [ roundEncrypt (msgToState(pt), msgToState((key'@0).0)) ] # [ roundEncrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [1,2..30]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList key)\n\n\/\/ Decryption\n\nPrDecrypt : ([PrKeySize], [PrBlockSize]) -> _\nPrDecrypt (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@0).0))\n                where hs = [ roundDecrypt (msgToState(pt), msgToState((key'@31).0)) ] # [ roundDecrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [30,29..1]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList key)\n\n\n\n\n\n\n\/\/Correctness\n\nproperty PresentCorrectnes key m = PrDecrypt( key, PrEncrypt(key, m)) == m\n\n\n\/*********128-bit key ********\/\n\n\/\/keyschedule -128bit\n\n\nupdateKey_128 : [PrKeySize128] -> [5] -> _\nupdateKey_128 key i =  (rkey, key'')\n            where rkey = key !![127,126..64]\n                  shift =  (key !! [66,65..0]) # (key !! [127,126..67])\n                  res = sbox@((shift) !! [127,126,125, 124]) # sbox@((shift) !! [123,122,121, 120]) # (shift !! [119,118..0])\n                  key'' =  (res !! [127,126..67]) # ((res!![66,65,64,63,62])^(i+1)) # (res!![61,60..0])\n\n\nRoundKeyList_128: [PrKeySize128] -> _\n\nRoundKeyList_128 key = hs\n             where hs = [ (updateKey_128 key 0)] # [ (updateKey_128 (key'.1) i)\n                                                   | i <- [1,2..31]\n                                                   | key' <- hs ]\n\/\/Encryption-128bit\n\nPrEncrypt_128 : ([PrKeySize128], [PrBlockSize]) -> _\nPrEncrypt_128 (key , pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                         \/\/stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                where hs = [ roundEncrypt (msgToState(pt), msgToState((key'@0).0)) ] # [ roundEncrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [1,2..30]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList_128 key)\n\n\/\/Decryption-128bit\n\nPrDecrypt_128 : ([PrKeySize128], [PrBlockSize]) -> _\nPrDecrypt_128 (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@0).0))\n                where hs = [ roundDecrypt (msgToState(pt), msgToState((key'@31).0)) ] # [ roundDecrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [30,29..1]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList_128 key)\n\n\/\/Correctness\n\nproperty PresentCorrectnes128 key m = PrDecrypt_128(key, PrEncrypt_128(key, m)) == m\n\n\/\/ Heleper function to perform analaysis\n\nprEncrypt64 : ([PrBlockSize], [PrBlockSize]) -> [PrBlockSize]\nprEncrypt64 (key, pt)  = PrEncrypt_128 (key#zero, pt)\n\nprDecrypt64 : ([PrBlockSize], [PrBlockSize]) -> [PrBlockSize]\nprDecrypt64 (key, ct)  = PrDecrypt_128(key#zero , ct)\n\nproperty PrCorrect64 key m = prDecrypt64 (key, (prEncrypt64(key, m))) == m\n\n\nprEncrypt128 : ([PrKeySize128], [PrKeySize128]) -> [PrKeySize128]\nprEncrypt128 (key, pt)  = PrEncrypt_128(key, (take`{64} pt)) # zero\n\n\/\/ Testing\ntests = [test80_1, test80_2, test80_3, test80_4, test80_5, test128_1]\nproperty testsPass = and tests\n\/\/keysize: 80bits\n\ntest80_1 =  PrEncrypt (zero, zero) == 0x5579c1387b228445\ntest80_2 =  PrEncrypt (zero, zero) == 0x5579c1387b228445\ntest80_3 =  PrEncrypt (0xffffffffffffffffffff, zero) == 0xe72c46c0f5945049\ntest80_4 =  PrEncrypt (0xffffffffffffffffffff, 0xffffffffffffffff) == 0x3333dcd3213210d2\ntest80_5 =  PrEncrypt (zero, 0xffffffffffffffff) == 0xa112ffc72f68417b\n\n\n\/\/keysize: 128bits\n\n\ntest128_1 = PrEncrypt_128 ( 0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0x0e9d28685e671dd6\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Cipher.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that for any key and block, decrypting the encrypted block returns the original block, i.e., decrypt(key, encrypt(key, block)) == block, for the Cipher type defined in the given module."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Cipher where\n\ntype Cipher KeySize BlockSize =\n  { encrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  , decrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/GOST.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the GOST block cipher implementation. Specifically, create properties that check that decrypting an encrypted message with the same key returns the original message, for both the standard 64-bit block size and the 256-bit key size variants. Include properties that validate the key schedule and round functions behave as expected according to the GOST specification."},{"role":"assistant","content":"```cryptol\n\/**\n * Cryptol GOST Implementation\n * @copyright Galois Inc. 2018\n * @author Ajay Kumar Eeralla\n * www.cryptol.net\n * Block size: 64 bits, key size: 256 bits\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::GOST where\n\ntype BlockSize = 64\ntype StdBlockSize = 32\ntype KeySize = 256\n\n\/\/S-box used by Central Bank of Russian Federation\n\nsbox = [\n    [0x4, 0xa, 0x9, 0x2, 0xd, 0x8, 0x0, 0xe, 0x6, 0xb, 0x1, 0xc, 0x7, 0xf, 0x5, 0x3],\n    [0xe, 0xb, 0x4, 0xc, 0x6, 0xd, 0xf, 0xa, 0x2, 0x3, 0x8, 0x1, 0x0, 0x7, 0x5, 0x9],\n    [0x5, 0x8, 0x1, 0xd, 0xa, 0x3, 0x4, 0x2, 0xe, 0xf, 0xc, 0x7, 0x6, 0x0, 0x9, 0xb],\n    [0x7, 0xd, 0xa, 0x1, 0x0, 0x8, 0x9, 0xf, 0xe, 0x4, 0x6, 0xc, 0xb, 0x2, 0x5, 0x3],\n    [0x6, 0xc, 0x7, 0x1, 0x5, 0xf, 0xd, 0x8, 0x4, 0xa, 0x9, 0xe, 0x0, 0x3, 0xb, 0x2],\n    [0x4, 0xb, 0xa, 0x0, 0x7, 0x2, 0x1, 0xd, 0x3, 0x6, 0x8, 0x5, 0x9, 0xc, 0xf, 0xe],\n    [0xd, 0xb, 0x4, 0x1, 0x3, 0xf, 0x5, 0x9, 0x0, 0xa, 0xe, 0x7, 0x6, 0x8, 0x2, 0xc],\n    [0x1, 0xf, 0xd, 0x0, 0x5, 0x7, 0xa, 0x4, 0x9, 0x2, 0x3, 0xe, 0x6, 0xb, 0x8, 0xc]\n    ]\n\/\/Most recent S-box: GOST R 34.12-2015\n\nsbox_rec = [\n         [0xc, 0x4, 0x6, 0x2, 0xa, 0x5, 0xb, 0x9, 0xe, 0x8, 0xd, 0x7, 0x0, 0x3, 0xf, 0x1],\n         [0x6, 0x8, 0x2, 0x3, 0x9, 0xa, 0x5, 0xc, 0x1, 0xe, 0x4, 0x7, 0xb, 0xd, 0x0, 0xf],\n         [0xb, 0x3, 0x5, 0x8, 0x2, 0xf, 0xa, 0xd, 0xe, 0x1, 0x7, 0x4, 0xc, 0x9, 0x6, 0x0],\n         [0xc, 0x8, 0x2, 0x1, 0xd, 0x4, 0xf, 0x6, 0x7, 0x0, 0xa, 0x5, 0x3, 0xe, 0x9, 0xb],\n         [0x7, 0xf, 0x5, 0xa, 0x8, 0x1, 0x6, 0xd, 0x0, 0x9, 0x3, 0xe, 0xb, 0x4, 0x2, 0xc],\n         [0x5, 0xd, 0xf, 0x6, 0x9, 0x2, 0xc, 0xa, 0xb, 0x7, 0x8, 0x1, 0x4, 0x3, 0xe, 0x0],\n         [0x8, 0xe, 0x2, 0x5, 0x6, 0x9, 0x1, 0xc, 0xf, 0x4, 0xb, 0x0, 0xd, 0xa, 0x3, 0x7],\n         [0x1, 0x7, 0xe, 0xd, 0x0, 0x5, 0x8, 0x3, 0x4, 0xf, 0xa, 0x6, 0x9, 0xc, 0xb, 0x2]\n         ]\n\n\/\/ Split the plain text two blocks of 32bits each\n\nsplitPt: [BlockSize] -> [2][StdBlockSize]\nsplitPt pt = split pt:[2][StdBlockSize]\n\n\/\/ Key schedule: split the key into 8 blocks each with 32bit subkey\n\nkeySchedule : [KeySize] -> [8][StdBlockSize]\nkeySchedule key = split key : [8][StdBlockSize]\n\nroundKey:[KeySize] ->  _\nroundKey key = [ rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0\n                 ]\n         where rk = (keySchedule key)\nroundKey':[KeySize] ->  _\nroundKey' key = [ rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0\n                 ]\n         where rk = (keySchedule key)\nroundFun : [StdBlockSize]-> [StdBlockSize] -> [StdBlockSize]\nroundFun subpt subkey = roundRes\n            where res = subpt + subkey\n                  splitRes = split res: [8][4]\n                  subSboxRes = [ (sbox@i)@(splitRes@i) | i<- [0..7] ]\n                  roundRes = (join subSboxRes) <<< 11\n\nroundEncryption: [StdBlockSize] -> [StdBlockSize] -> [StdBlockSize] -> [BlockSize]\nroundEncryption lpt rpt rkey =  rpt # (lpt ^ (roundFun rpt rkey))\n\n\n\/\/Encryption\n\ngostEncrypt: ([KeySize], [BlockSize]) ->  [BlockSize]\ngostEncrypt (key, pt) = hs'\n            where hs = [(roundEncryption left right (round_key@0))]  # [ (roundEncryption ((splitPt pT)@0) ((splitPt pT)@1) (round_key@i))\n                                                  | i <- [1,2..31]\n                                                  | pT <- hs\n                                                  ]\n                  splt_pt = (splitPt pt)\n                  left = splt_pt@0\n                  right = splt_pt@1\n                  round_key = (roundKey key)\n                  hs' = hs!0\n\n\/\/One round decryption\n\nroundDecryption: [StdBlockSize] -> [StdBlockSize] -> [StdBlockSize] -> [BlockSize]\nroundDecryption lpt rpt rkey =  (rpt ^ (roundFun lpt rkey)) # lpt\n\n\n\/\/ Decryption\n\ngostDecrypt: ([KeySize], [BlockSize]) ->  [BlockSize]\ngostDecrypt (key, ct) = hs'\n            where hs = [(roundDecryption left right (round_key@0))]  # [ (roundDecryption ((splitPt pT)@0) ((splitPt pT)@1) (round_key@i))\n                                                  | i <- [1,2..31]\n                                                  | pT <- hs\n                                                  ]\n                  splt_pt = (splitPt ct)\n                  left = splt_pt@0\n                  right = splt_pt@1\n                  round_key = (roundKey' key)\n                  hs' = hs!0\n\n\/\/ Correctness\n\nproperty gostCorrect key m = gostDecrypt(key, gostEncrypt(key, m)) == m\n\n\n\/\/ Helper functions to perform analysis\n\ngostEncrypt64: ([BlockSize],[BlockSize]) -> [BlockSize]\ngostEncrypt64 (pt, key)  = gostEncrypt(key', pt)\n             where key' = key # zero\n\ngostDecrypt64 : ([BlockSize], [BlockSize]) -> [BlockSize]\ngostDecrypt64 (ct, key)  = gostDecrypt(key', ct)\n             where key' = key #zero\n\n\nproperty gostCorrect64 key m = gostDecrypt64( key, gostEncrypt64(key, m)) == m\n\n\n\/\/ To analyze the schemes from 5 through 20, we take |mi| = k  where k > n (block size)\n\ngostEncrypt256 : ([KeySize], [KeySize]) -> [KeySize]\ngostEncrypt256 (pt, key) = gostEncrypt(key, (take`{64} pt))# zero\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Threefish.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the Threefish encryption and decryption functions are inverses of each other for all valid keys, tweaks, and plaintexts. Specifically, specify properties that check decrypting an encrypted plaintext returns the original plaintext for the 256, 512, and 1024-bit variants. Also, verify that the key schedule and permutation functions behave as inverses where applicable."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Threefish where\n\n\/\/ This implementation is based on Skein version 1.3:\n\/\/ http:\/\/www.skein-hash.info\/sites\/default\/files\/skein1.3.pdf\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.2: Bit and Byte Order\n\n\/\/ \"To convert from a sequence of bytes to an integer, we use the\n\/\/ least-significant-byte-first convention.\"\n\nToInt : {n} (fin n) => [n][8] -> [8 * n]\nToInt bytes = join (reverse bytes)\n\nToBytes : {n} (fin n) => [8 * n] -> [n][8]\nToBytes bits = reverse (split`{each = 8} bits)\n\nBytesToWords : {n} (fin n) => [8 * n][8] -> [n][64]\nBytesToWords bytes = [ ToInt bs | bs <- split`{each = 8} bytes ]\n\nWordsToBytes : {n} (fin n) => [n][64] -> [8 * n][8]\nWordsToBytes words = join [ ToBytes w | w <- words ]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3: A Full Specification of Threefish\n\nenc256 : [32][8] -> [16][8] -> [32][8] -> [32][8]\nenc256 = encrypt`{Nr=72} R4 pi4\n\nenc512 : [64][8] -> [16][8] -> [64][8] -> [64][8]\nenc512 = encrypt`{Nr=72} R8 pi8\n\nenc1024 : [128][8] -> [16][8] -> [128][8] -> [128][8]\nenc1024 = encrypt`{Nr=80} R16 pi16\n\nencrypt :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 4 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot ->\n  ([Nw][64] -> [Nw][64]) ->\n  [8 * Nw][8] -> [16][8] -> [8 * Nw][8] -> [8 * Nw][8]\nencrypt R pi key tweak plaintext = WordsToBytes (encrypt'`{Nr=Nr} R pi K T P)\n  where\n    K = BytesToWords key\n    T = BytesToWords tweak\n    P = BytesToWords plaintext\n\n\/\/ Encryption in terms of 64-bit words.\nencrypt' :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 4 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot -> ([Nw][64] -> [Nw][64]) ->\n  [Nw][64] -> [2][64] -> [Nw][64] -> [Nw][64]\nencrypt' R pi key tweak plaintext = last v + last ks\n  where\n    ks : [Nr\/4 + 1][Nw][64]\n    ks = KeySchedule key tweak\n\n    \/\/ Add a subkey from the key schedule once every four rounds.\n    e : [Nr][Nw][64]\n    e = [ vd + kd\n        | vd <- v\n        | subkey <- take`{Nr\/4} ks, kd <- [subkey, zero, zero, zero] ]\n\n    \/\/ Cycle over the eight lists of rotation amounts for the mixing function.\n    f : [Nr][Nw][64]\n    f = [ mixing Rd ed | Rd <- join (repeat`{inf} R) | ed <- e ]\n\n    \/\/ Permute the words every round.\n    v : [Nr+1][Nw][64]\n    v = [plaintext] # [ pi fd | fd <- f ]\n\n\/\/ One round of mixing.\nmixing : {w} (fin w) => [w]Rot -> [2 * w][64] -> [2 * w][64]\nmixing Rd e = join [ MIX R x | R <- Rd | x <- split`{each=2} e ]\n\n\/\/ Table 3: Values for the word permutation \u03c0(i).\n\npi4 : [4][64] -> [4][64]\npi4 xs = xs @@ [0, 3, 2, 1:[2]]\n\npi8 : [8][64] -> [8][64]\npi8 xs = xs @@ [2, 1, 4, 7, 6, 5, 0, 3:[3]]\n\npi16 : [16][64] -> [16][64]\npi16 xs = xs @@ [0, 9, 2, 13, 6, 11, 4, 15, 10, 7, 12, 3, 14, 5, 8, 1:[4]]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.1: MIX Functions\n\n\/\/ Rotation amount for a 64-bit word\ntype Rot = [6]\n\nMIX : Rot -> [2][64] -> [2][64]\nMIX R [x0, x1] = [y0, y1]\n  where\n    y0 = x0 + x1\n    y1 = (x1 <<< R) ^ y0\n\n\/\/ Table 4: Rotation constants\n\nR4 : [8][2]Rot\nR4 =\n  [[14, 16],\n   [52, 57],\n   [23, 40],\n   [ 5, 37],\n   [25, 33],\n   [46, 12],\n   [58, 22],\n   [32, 32]]\n\nR8 : [8][4]Rot\nR8 =\n  [[46, 36, 19, 37],\n   [33, 27, 14, 42],\n   [17, 49, 36, 39],\n   [44,  9, 54, 56],\n   [39, 30, 34, 24],\n   [13, 50, 10, 17],\n   [25, 29, 39, 43],\n   [ 8, 35, 56, 22]]\n\nR16 : [8][8]Rot\nR16 =\n  [[24, 13,  8, 47,  8, 17, 22, 37],\n   [38, 19, 10, 55, 49, 18, 23, 52],\n   [33,  4, 51, 13, 34, 41, 59, 17],\n   [ 5, 20, 48, 41, 47, 28, 16, 25],\n   [41,  9, 37, 31, 12, 47, 44, 30],\n   [16, 34, 56, 51,  4, 53, 42, 41],\n   [31, 44, 47, 46, 19, 42, 44, 25],\n   [ 9, 48, 35, 52, 23, 31, 37, 20]]\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.2: The Key Schedule\n\n\/\/ \"The key schedule turns the key and tweak into a sequence of Nr\/4+1\n\/\/ subkeys, each of which consists of Nw words.\"\n\nKeySchedule :\n  {Nw, r} (fin Nw, fin r, Nw >= 3) =>\n  [Nw][64] -> [2][64] -> [r][Nw][64]\nKeySchedule k [t0,t1] = take`{r} [ subkey s | s <- [0...] ]\n  where\n    k' = k # [foldl (^) C240 k]\n    t' = [t0, t1, t0 ^ t1]\n\n    subkey : [64] -> [Nw][64]\n    subkey s = take`{Nw} (k' <<< s) + tweak s\n\n    tweak : [64] -> [Nw][64]\n    tweak s = zero # take`{2} (t' <<< s) # [s]\n\nC240 : [64]\nC240 = 0x1BD11BDAA9FC1A22\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.3: Decryption\n\n\/\/ \"The Threefish decryption operation is the obvious inverse of the\n\/\/ encryption operation. Subkeys are used in reverse order and each\n\/\/ round consists of applying the inverse word permutation followed by\n\/\/ the inverse MIX functions.\"\n\ndec256 : [32][8] -> [16][8] -> [32][8] -> [32][8]\ndec256 = decrypt`{Nr=72} R4 pi4'\n\ndec512 : [64][8] -> [16][8] -> [64][8] -> [64][8]\ndec512 = decrypt`{Nr=72} R8 pi8'\n\ndec1024 : [128][8] -> [16][8] -> [128][8] -> [128][8]\ndec1024 = decrypt`{Nr=80} R16 pi16'\n\ndecrypt :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 8 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot ->\n  ([Nw][64] -> [Nw][64]) ->\n  [8 * Nw][8] -> [16][8] -> [8 * Nw][8] -> [8 * Nw][8]\ndecrypt R pi key tweak ciphertext = WordsToBytes (decrypt'`{Nr=Nr} R pi K T P)\n  where\n    K = BytesToWords key\n    T = BytesToWords tweak\n    P = BytesToWords ciphertext\n\n\/\/ Decryption in terms of 64-bit words.\ndecrypt' :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 8 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot -> ([Nw][64] -> [Nw][64]) ->\n  [Nw][64] -> [2][64] -> [Nw][64] -> [Nw][64]\ndecrypt' R pi key tweak ciphertext = last e - last ks\n  where\n    ks : [Nr\/4 + 1][Nw][64]\n    ks = reverse (KeySchedule key tweak)\n\n    \/\/ Add a subkey from the key schedule once every four rounds.\n    v : [Nr][Nw][64]\n    v = [ ed - kd\n        | ed <- e\n        | subkey <- take`{Nr\/4} ks, kd <- [subkey, zero, zero, zero] ]\n\n    \/\/ Cycle over the eight lists of rotation amounts for the mixing function.\n    e : [Nr+1][Nw][64]\n    e = [ciphertext] # [ mixing' Rd fd | Rd <- reverse (join (repeat`{Nr\/8} R)) | fd <- f ]\n\n    \/\/ Permute the words every round.\n    f : [Nr][Nw][64]\n    f = [ pi vd | vd <- v ]\n\n\n\/\/ Inverse MIX function\nMIX' : Rot -> [2][64] -> [2][64]\nMIX' R [y0, y1] = [x0, x1]\n  where\n    x0 = y0 - x1\n    x1 = (y0 ^ y1) >>> R\n\n\/\/ One round of inverse mixing.\nmixing' : {w} (fin w) => [w]Rot -> [2 * w][64] -> [2 * w][64]\nmixing' Rd e = join [ MIX' R x | R <- Rd | x <- split`{each=2} e ]\n\n\/\/ Inverse permutations.\n\npi4' : [4][64] -> [4][64]\npi4' xs = xs @@ [0, 3, 2, 1:[2]]\n\npi8' : [8][64] -> [8][64]\npi8' xs = xs @@ [6, 1, 0, 7, 2, 5, 4, 3:[3]]\n\npi16' : [16][64] -> [16][64]\npi16' xs = xs @@ [0, 15, 2, 11, 6, 13, 4, 9, 14, 1, 8, 5, 10, 3, 12, 7:[4]]\n\nproperty MIX_inv R x = MIX' R (MIX R x) == x\nproperty pi4_inv xs = pi4' (pi4 xs) == xs\nproperty pi8_inv xs = pi8' (pi8 xs) == xs\nproperty pi16_inv xs = pi16' (pi16 xs) == xs\n\n\n\/\/ https:\/\/sites.google.com\/site\/bartoszmalkowski\/threefish\n\nproperty test256a =\n  enc256 zero zero zero ==\n  split 0x84da2a1f8beaee947066ae3e3103f1ad536db1f4a1192495116b9f3ce6133fd8\n\nproperty test256b =\n  enc256\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xFFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0)\n  ==\n  split 0xe0d091ff0eea8fdfc98192e62ed80ad59d865d08588df476657056b5955e97df\n\nproperty test512a =\n  enc512 zero zero zero ==\n  split 0xb1a2bbc6ef6025bc40eb3822161f36e375d1bb0aee3186fbd19e47c5d479947b #\n  split 0x7bc2f8586e35f0cff7e7f03084b0b7b1f1ab3961a580a3e97eb41ea14a6d7bbe\n\nproperty test512b =\n  enc512\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f #\n     split 0x303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xfffefdfcfbfaf9f8f7f6f5f4f3f2f1f0efeeedecebeae9e8e7e6e5e4e3e2e1e0 #\n     split 0xdfdedddcdbdad9d8d7d6d5d4d3d2d1d0cfcecdcccbcac9c8c7c6c5c4c3c2c1c0)\n  ==\n  split 0xe304439626d45a2cb401cad8d636249a6338330eb06d45dd8b36b90e97254779 #\n  split 0x272a0a8d99463504784420ea18c9a725af11dffea10162348927673d5c1caf3d\n\nproperty test1024a =\n  enc1024 zero zero zero ==\n  split 0xf05c3d0a3d05b304f785ddc7d1e036015c8aa76e2f217b06c6e1544c0bc1a90d #\n  split 0xf0accb9473c24e0fd54fea68057f43329cb454761d6df5cf7b2e9b3614fbd5a2 #\n  split 0x0b2e4760b40603540d82eabc5482c171c832afbe68406bc39500367a592943fa #\n  split 0x9a5b4a43286ca3c4cf46104b443143d560a4b230488311df4feef7e1dfe8391e\n\nproperty test1024b =\n  enc1024\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f #\n     split 0x303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f #\n     split 0x505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f #\n     split 0x707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xfffefdfcfbfaf9f8f7f6f5f4f3f2f1f0efeeedecebeae9e8e7e6e5e4e3e2e1e0 #\n     split 0xdfdedddcdbdad9d8d7d6d5d4d3d2d1d0cfcecdcccbcac9c8c7c6c5c4c3c2c1c0 #\n     split 0xbfbebdbcbbbab9b8b7b6b5b4b3b2b1b0afaeadacabaaa9a8a7a6a5a4a3a2a1a0 #\n     split 0x9f9e9d9c9b9a999897969594939291908f8e8d8c8b8a89888786858483828180)\n  ==\n  split 0xa6654ddbd73cc3b05dd777105aa849bce49372eaaffc5568d254771bab85531c #\n  split 0x94f780e7ffaae430d5d8af8c70eebbe1760f3b42b737a89cb363490d670314bd #\n  split 0x8aa41ee63c2e1f45fbd477922f8360b388d6125ea6c7af0ad7056d01796e90c8 #\n  split 0x3313f4150a5716b30ed5f569288ae974ce2b4347926fce57de44512177dd7cde\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/SHACAL.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the `shacal1Encrypt` and `shacal2Encrypt` functions correctly implement the SHACAL-1 and SHACAL-2 block cipher encryption algorithms, respectively, by checking their outputs against the provided test vectors `tVector1` and `tVector2`. Include properties that validate the correctness of the internal `block` and `processBlock_Common` functions used in the encryption process."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::SHACAL where\n\nimport Primitive::Keyless::Hash::SHA2Internal::SHA256\n\n\/**SHACAL1**\/\n\n\ntype shacal1Block = 160\ntype shacal1Key = 512\n\n\n\nshacal1Encrypt : ([shacal1Key], [shacal1Block]) -> [shacal1Block]\nshacal1Encrypt (key, pt) = join (block (pt', key'))\n              where pt' = split pt : [5][32]\n                    key' = split key : [16][32]\n\n\/\/ Helper function to analyse the PGV hash function constructions\n\nshacal1Encrypt160 : ([shacal1Block], [shacal1Block]) -> [shacal1Block]\nshacal1Encrypt160 (key, pt) = shacal1Encrypt(key#zero, pt)\n\nshacal1Encrypt512 : ([shacal1Key], [shacal1Key]) -> [shacal1Key]\nshacal1Encrypt512 (key, pt) = shacal1Encrypt(key, (take`{160} pt))#zero\n\n\n\/\/ \/\/Added 10 test vectors for more vectors, please visit:  https:\/\/www.cosic.esat.kuleuven.be\/nessie\/tweaks.html\n\nproperty shacal1TestsPass = and [shacal1Encrypt(key, plain) == cipher | (key, plain, cipher) <- tVector1]\n\ntVector1 = [ (0x8#zero, zero, 0x0FFD8D43B4E33C7C53461BD10F27A5461050D90D)\n           , (0x4#zero, zero, 0xB9C60AA972B49CA04D5A0D9B9E08B2A2BA138C93)\n           , (0x2#zero, zero, 0x3FA618501A3D10E3CAEB3CA06B8B47A16F8E3D9E)\n           , (0x1#zero, zero, 0x2B4AFB3268C32F86B89BB745EC85F24702B38498)\n           , (0x08#zero, zero, 0x58E782A1D205E53DD2901F0F302F8894D0A3B05B)\n           , (0x04#zero, zero, 0xB345AD4DC877D0BFCF760EE25056D21C7DB2F868)\n           , (0x02#zero, zero, 0x334C5A595919EA33E5EB467657AAE3ED825207D3)\n           , (0x01#zero, zero, 0x5F686F27819DF939F877099A222D01EE955F6E66)\n           , (0x008#zero, zero, 0x62BE68D266A28F7E6B44A83E62A476FFD627AF0E)\n           , (0x004#zero, zero, 0x2D5265CD2E72B52B6477F341816F2BB554428BC5)]\n\n\n\/**SHACAL2**\/\n\n\n\ntype shacal2Block = 256\ntype shacal2Key = 512\n\nshacal2Encrypt : ([shacal2Key], [shacal2Block]) -> [shacal2Block]\nshacal2Encrypt (key, pt) = join (processBlock_Common pt' key')\n              where pt' = split pt : [8][32]\n                    key' = split key : [16][32]\n\n\/\/ Helper function to analyse the PGV hash function constructions\n\nshacal2Encrypt256 : ([shacal2Block], [shacal2Block]) -> [shacal2Block]\nshacal2Encrypt256 (key, pt) = shacal2Encrypt(key#zero, pt)\n\nshacal2Encrypt512 : ([shacal2Key], [shacal2Key]) -> [shacal2Key]\nshacal2Encrypt512 (key, pt) = shacal2Encrypt(key, (take`{256} pt))#zero\n\n\/\/Testing\n\/\/Added 10 test vectors for more vectors, please visit:  https:\/\/www.cosic.esat.kuleuven.be\/nessie\/tweaks.html\n\nproperty shacal2TestsPass = and [shacal2Encrypt(key, plain) == cipher | (key, plain, cipher) <- tVector2]\n\ntVector2 = [ (0x8#zero, zero, 0x361AB6322FA9E7A7BB23818D839E01BDDAFDF47305426EDD297AEDB9F6202BAE)\n           , (0x4#zero, zero, 0xF3BAF53E5301E08813F8BE6F651BB19E9722151FF15063BA42A6FEF7CF3BF3D7)\n           , (0x1#zero, zero, 0xAE70E355CB7E26FF12421F46CDAD5CB98367FE0E86CC234EDF97481765CD1AD9)\n           , (0x08#zero, zero, 0x00CECD0B01311F881018E7A20BCE169766C089D91FF161346C4E1BD122EA199F)\n           , (0x08#zero, zero, 0x00CECD0B01311F881018E7A20BCE169766C089D91FF161346C4E1BD122EA199F)\n           , (0x04#zero, zero, 0x47A879CB6785AD37119C450CD50E9A36FE318FA8E7B6C6E0FA963430122F33CD)\n           , (0x02#zero, zero, 0xCF3D53B9F9F7CA2C66738A4C09CEA9212C056F525BDC26F263FBA1B482EDF503)\n           , (0x01#zero, zero, 0xA274D404E83E82817389A2CB7B528C792A0E80DE879A5A67DE633B0B7DD57B7B)\n           , (0x008#zero, zero, 0x09B3AB9332301D4E3C239D192A4221AFD43F6829A705D396FA96BDE1E716BC38)\n           , (0x004#zero, zero, 0xD3B9AB867A6868C4400D200979055C8F9E3A6BFB40D1F9E376B9EC89223D7050)]\n\nf : ([8], [32], [32], [32]) -> [32]\nf (t, x, y, z) =\n       if (0 <= t)  \/\\ (t <= 19) then (x && y) ^ (~x && z)\n        | (20 <= t) \/\\ (t <= 39) then x ^ y ^ z\n        | (40 <= t) \/\\ (t <= 59) then (x && y) ^ (x && z) ^ (y && z)\n        | (60 <= t) \/\\ (t <= 79) then x ^ y ^ z\n        else error \"f: t out of range\"\n\nKs : [80][32]\nKs = [ 0x5a827999 | t <- [0..19]  ]\n   # [ 0x6ed9eba1 | t <- [20..39] ]\n   # [ 0x8f1bbcdc | t <- [40..59] ]\n   # [ 0xca62c1d6 | t <- [60..79] ]\n\nblock : ([5][32], [16][32]) -> [5][32]\nblock ([H0, H1, H2, H3, H4], M) =\n [(H0+As@80), (H1+Bs@80), (H2+Cs@80), (H3+Ds@80), (H4+Es@80)]\n  where\n    Ws : [80][32]\n    Ws = M # [ (W3 ^ W8 ^ W14 ^ W16) <<< 1\n             | W16 <- drop`{16 - 16} Ws\n             | W14 <- drop`{16 - 14} Ws\n             | W8  <- drop`{16 - 8}  Ws\n             | W3  <- drop`{16 - 3}  Ws\n             | t <- [16..79]\n             ]\n    As = [H0] # TEMP\n    Bs = [H1] # As\n    Cs = [H2] # [ B <<< 30 | B <- Bs ]\n    Ds = [H3] # Cs\n    Es = [H4] # Ds\n    TEMP : [80][32]\n    TEMP = [ (A <<< 5) + f(t, B, C, D) + E + W + K\n           | A <- As | B <- Bs | C <- Cs | D <- Ds | E <- Es\n           | W <- Ws | K <- Ks\n           | t <- [0..79]\n           ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/CipherInterface.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally verifies the correctness of the encrypt and decrypt functions in the Primitive::Symmetric::Cipher::Block::CipherInterface module. The specification should include properties ensuring that decrypting an encrypted block with the same key returns the original block, and that the key and block sizes conform to the specified type constraints."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Symmetric::Cipher::Block::CipherInterface where\n  type KeySize : #\n  type BlockSize : #\n  type constraint (fin BlockSize, fin KeySize)\n  encrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  decrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/KATAN.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the KATAN and KTANTAN block cipher implementations in the given module. Specifically, create properties that check that decrypting an encrypted plaintext with the same key returns the original plaintext for both ciphers, and include test vectors for 32-bit, 48-bit, and 64-bit block sizes as indicated in the code comments."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::KATAN where\n\ntype Katan32 = 32\ntype Katan48 = 48\ntype Katan64 = 64\ntype KatanBlock = Katan64\ntype KatanKeySize = 80\ntype Round = 8\ntype xSize = 5\ntype ySize = 6\n\n\/\/Number of rounds\n\ntype Nr = 254\n\n\/\/Sizes of the registers\n\n\/\/32-bit\n\n\/\/48-bit\n\n\/\/64-bit\n\ntype L1Size = 25\ntype L2Size = 39\n\n\/\/ x, y values\n\n\/\/32-bit\n\n\/\/x = [12, 7, 8, 5, 3]\n\/\/y = [18, 7, 12, 10, 8, 3]\n\n\/\/48-bit\n\n\/\/x = [18, 12, 15, 7, 6]\n\/\/y = [28, 19, 21, 13, 15, 6]\n\n\/\/64-bit\n\nx = [24, 15, 20, 11, 9]\ny = [38, 25, 33, 21, 14, 9]\n\n\/\/ Split and load the plaintext into two registers L1||L2\n\nsplitBlock: [KatanBlock] -> ([L1Size], [L2Size])\n\nsplitBlock pt = (l1, l2)\n            where l1 = take`{L1Size} pt\n                  l2 = drop`{L1Size} pt\n\n\n\/\/Irregular round update\n\niR: [1][Nr]\n\niR = [0b11111110001101010101111011001100101001000100011000111100001000010100000111110011111101010001010100110000110011101111101110100101011010011100110110001011101101111001011011010111001001001101000111000100111101000011101011000001011001000000110111000000010010]\n\n\/\/Key Schedule-recursively extend the key\n\nkS: {a} (fin a) => ([a], [12]) -> [a+1]\nkS (key, i ) = key # [((key@(i-80))^ (key@(i-61)) ^ (key@(i-50)) ^ (key@(i-13)))]\n\nkS10 : {a} (fin a) => ([a], [12]) -> [a + 10]\nkS10 (key, i) = key9\n           where key0 = kS (key, i)\n                 key1 = kS (key0, i+1)\n                 key2 = kS (key1, i+2)\n                 key3 = kS (key2, i+3)\n                 key4 = kS (key3, i+4)\n                 key5 = kS (key4, i+5)\n                 key6 = kS (key5, i+6)\n                 key7 = kS (key6, i+7)\n                 key8 = kS (key7, i+8)\n                 key9 = kS (key8, i+9)\n\nkS100 : {a} (fin a) => ([a], [12]) -> [a + 100]\nkS100 (key, i) = key9\n            where key0 = kS10 (key, i)\n                  key1 = kS10 (key0, i+10)\n                  key2 = kS10 (key1, i+20)\n                  key3 = kS10 (key2, i+30)\n                  key4 = kS10 (key3, i+40)\n                  key5 = kS10 (key4, i+50)\n                  key6 = kS10 (key5, i+60)\n                  key7 = kS10 (key6, i+70)\n                  key8 = kS10 (key7, i+80)\n                  key9 = kS10 (key8, i+90)\n\nkeySchedule' :[80] -> [508]\nkeySchedule' key = key13\n            where key0 = kS100 (key, 80)\n                  key1= kS100 (key0, 180)\n                  key2 = kS100 (key1, 280)\n                  key3 = kS100 (key2, 380)\n                  key4 = kS10(key3, 480)\n                  key5 = kS10 (key4, 490)\n                  key6 = kS (key5, 500)\n                  key7 = kS (key6, 501)\n                  key8 = kS (key7, 502)\n                  key9 = kS (key8, 503)\n                  key10 = kS (key9, 504)\n                  key11 = kS (key10, 505)\n                  key12 = kS (key11, 506)\n                  key13 = kS (key12, 507)\n\/\/ functions fa and fb\n\nfunFa : [L1Size]-> [xSize][xSize] -> [508] -> [Round] -> Bit\n\nfunFa L1 x k i = (L1!(x@0)) ^ (L1!(x@1)) ^ ((L1!(x@2)) && (L1!(x@3))) ^ ((L1!(x@4)) && ((iR@0)@i)) ^ (k@(pmult (2:[2]) i))\n\nfunFb : [L2Size]-> [ySize][ySize] -> [508] -> [Round] -> Bit\n\nfunFb L2 y k i = (L2!(y@0)) ^ (L2!(y@1)) ^ (L2!(y@2) && L2!(y@3)) ^ (L2!(y@4) && L2!(y@5)) ^ (k@((pmult (2:[2]) i)+1))\n\n\/\/left shift L1 and L2 and replace LSBs of them with fb and fa respectively\n\n\naply_fb : [L1Size] -> [L2Size]->  [ySize][ySize] ->[KatanKeySize] -> [Round] -> [L1Size]\naply_fb l1 l2 y key i = (l1 !! [(L1Size-2),(L1Size-3)..0]) # [(funFb l2 y (keySchedule' key) i)]\n\naply_fa : [L1Size] -> [L2Size]-> [xSize][xSize]->[KatanKeySize] -> [Round] -> [L2Size]\naply_fa l1 l2 x key i = (l2 !! [(L2Size-2),(L2Size-3)..0]) # [(funFa l1 x (keySchedule' key) i)]\n\n\/\/Update LFSR for encryption\n\nupdateLfsr : [L1Size] -> [L2Size]-> [xSize][xSize] -> [ySize][ySize]->[KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\nupdateLfsr l1 l2 x y key i = if `(L1Size) == 13\n                             then (l1', l2')\n                             else if `(L1Size) == 19\n                                  then (l1'', l2'')\n                                  else (l1''', l2''')\n\n                 where pt = (aply_fb l1 l2 y key i) # (aply_fa l1 l2 x key i)\n                       l1' = (splitBlock pt).0\n                       l2' = (splitBlock pt).1\n                       pt' = (aply_fb l1' l2' y key i) # (aply_fa l1' l2' x key i)\n                       l1'' = (splitBlock pt').0\n                       l2'' =  (splitBlock pt').1\n                       pt'' = (aply_fb l1'' l2'' y key i) # (aply_fa l1'' l2'' x key i)\n                       l1''' = (splitBlock pt'').0\n                       l2''' =  (splitBlock pt'').1\n\n\/\/Encryption\n\nkatanEncrypt : ( [KatanKeySize], [KatanBlock]) -> _ katanEncrypt (key, pt) =  (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] # [ ( (updateLfsr pT.0 pT.1 x y key i).0, (updateLfsr pT.0 pT.1 x y key i).1)  | i<- [0,1..253] | pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\n\/\/ wrapper to do experiments\n\nkatanEncrypt64 : ([KatanBlock], [KatanBlock]) -> [KatanBlock]\nkatanEncrypt64 (key, pt) = katanEncrypt(key#zero, pt)\n\n\nkatanEncrypt80 : ([KatanKeySize], [KatanKeySize]) -> [KatanKeySize]\nkatanEncrypt80 (key, pt) = katanEncrypt(key, (take`{64} pt)) # zero\n\n\/\/Auxiliary functions for decryption\n\n\/\/ fa and fb\n\ndecFunFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ndecFunFa L1 L2 x k i = fa ^ (L1!((x@1)+1)) ^ (L1!((x@2)+1) && L1!((x@3)+1)) ^ (L1!((x@4)+1) && ((iR@0)@i)) ^ k@(2*i)\n         where fa = L2!0\n\ndecFunFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [508] -> [Round] -> Bit\ndecFunFb L2 L1 y k i =  fb ^ (L2!((y@1)+1)) ^ ((L2!((y@2)+1)) && L2!((y@3)+1)) ^ ((L2!((y@4)+1)) && L2!((y@5)+1)) ^ k@(2*i+1)\n         where fb = L1!0\n\n\/\/Left shifting L1, L2 and appending fa, fb values\n\naply_decFa_once : [L1Size] -> [L2Size] -> [xSize][xSize] -> [KatanKeySize] -> [Round] -> [L1Size]\n\naply_decFa_once  l1 l2 x k i = [(decFunFa l1 l2 x (keySchedule' k) i)] # (l1!![(L1Size-1),(L1Size-2)..1])\n\n\naply_decFb_once : [L2Size] -> [L1Size] -> [ySize][ySize] -> [KatanKeySize] -> [Round] -> [L2Size]\naply_decFb_once  l2 l1 y k i =  [(decFunFb l2 l1 y (keySchedule' k) i)] # (l2!![(L2Size-1),(L2Size-2)..1])\n\n\/\/ Updating LFSR for decryption\n\ndecUpdateLfsr: [L1Size] -> [L2Size] -> [xSize][xSize]-> [ySize][ySize] -> [KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\ndecUpdateLfsr  l1 l2 x y key i = if `(L1Size) == 13\n                                 then (l1', l2')\n                                 else if `(L1Size) == 19\n                                      then (l1'', l2'')\n                                      else (l1''', l2''')\n                               where ct = (aply_decFa_once l1 l2 x key i) # (aply_decFb_once l2 l1 y key i)\n                                     l1' = (splitBlock ct).0\n                                     l2' = (splitBlock ct).1\n                                     ct' = (aply_decFa_once l1' l2' x key i) # (aply_decFb_once l2' l1' y key i)\n                                     l1'' = (splitBlock ct').0\n                                     l2'' = (splitBlock ct').1\n                                     ct'' = (aply_decFa_once l1'' l2'' x key i) # (aply_decFb_once l2'' l1'' y key i)\n                                     l1''' = (splitBlock ct'').0\n                                     l2''' = (splitBlock ct'').1\n\/\/Decryption\n\nkatanDecrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\nkatanDecrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] #[ ((decUpdateLfsr pT.0 pT.1 x y key i).0 , (decUpdateLfsr pT.0 pT.1 x y key i).1)  | i <-[253,252..0] |pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\n\n\/\/ Correctness\n\nproperty katanCorrect key m = katanEncrypt( key, katanDecrypt(key, m)) == m\n\n\n\n\/*******KTANTAN*******************************************\/\n\/**********************************************************\/\n\nk_a_index = [0x3f, 0x1f, 0x1f, 0x0f, 0x0e, 0x3c, 0x28, 0x31, 0x23, 0x36, 0x2d,\n             0x3a, 0x25, 0x4a, 0x45, 0x4a, 0x35, 0x2b, 0x47, 0x3f, 0x1e, 0x2d,\n             0x0b, 0x36, 0x1c, 0x29, 0x03, 0x26, 0x3c, 0x19, 0x22, 0x05, 0x1a,\n             0x14, 0x09, 0x02, 0x14, 0x18, 0x01, 0x02, 0x34, 0x18, 0x11, 0x03,\n             0x06, 0x4c, 0x48, 0x31, 0x13, 0x17, 0x0f, 0x0e, 0x0c, 0x18, 0x10,\n             0x01, 0x02, 0x04, 0x28, 0x30, 0x11, 0x12, 0x05, 0x0a, 0x04, 0x08,\n             0x40, 0x40, 0x41, 0x33, 0x17, 0x2f, 0x0f, 0x4e, 0x4c, 0x49, 0x43,\n             0x37, 0x2f, 0x3f, 0x2f, 0x3e, 0x1d, 0x1a, 0x05, 0x0a, 0x24, 0x38,\n             0x21, 0x32, 0x15, 0x2a, 0x05, 0x3a, 0x14, 0x19, 0x03, 0x06, 0x0c,\n             0x38, 0x10, 0x21, 0x03, 0x46, 0x3c, 0x29, 0x43, 0x47, 0x4e, 0x4d,\n             0x3b, 0x27, 0x4f, 0x4f, 0x3e, 0x2d, 0x3b, 0x17, 0x2e, 0x0d, 0x2a,\n             0x34, 0x29, 0x42, 0x35, 0x2a, 0x35, 0x1b, 0x26, 0x0d, 0x4a, 0x34,\n             0x19, 0x23, 0x07, 0x3e, 0x2c, 0x49, 0x33, 0x16, 0x1d, 0x0b, 0x06,\n             0x2c, 0x48, 0x41, 0x32, 0x25, 0x4b, 0x37, 0x2e, 0x4d, 0x4b, 0x46,\n             0x3d, 0x1b, 0x27, 0x0f, 0x2e, 0x4c, 0x39, 0x22, 0x45, 0x3b, 0x26,\n             0x3d, 0x2b, 0x46, 0x4d, 0x3a, 0x15, 0x2b, 0x07, 0x1e, 0x2c, 0x09,\n             0x12, 0x24, 0x09, 0x32, 0x24, 0x39, 0x13, 0x16, 0x0d, 0x0a, 0x44,\n             0x38, 0x11, 0x13, 0x07, 0x0e, 0x1c, 0x28, 0x01, 0x42, 0x44, 0x39,\n             0x23, 0x37, 0x1f, 0x1e, 0x0d, 0x0a, 0x04, 0x48, 0x30, 0x21, 0x33,\n             0x27, 0x4e, 0x3d, 0x1a, 0x15, 0x0b, 0x06, 0x0c, 0x08, 0x20, 0x40,\n             0x31, 0x12, 0x25, 0x0b, 0x16, 0x1c, 0x09, 0x02, 0x04, 0x08, 0x00,\n             0x30, 0x20, 0x41, 0x43, 0x36, 0x1d, 0x1b, 0x07, 0x0e, 0x0c, 0x08,\n             0x00, 0x00, 0x10, 0x20, 0x01, 0x22, 0x44, 0x49, 0x42, 0x45, 0x4b,\n             0x47]\n\n\nk_b_index = [0x1f, 0x3f, 0x3f, 0x2f, 0x0e, 0x4c, 0x28, 0x11, 0x43, 0x16, 0x4d,\n             0x1a, 0x45, 0x0a, 0x45, 0x0a, 0x15, 0x2b, 0x07, 0x4f, 0x3e, 0x2d,\n             0x0b, 0x46, 0x3c, 0x29, 0x13, 0x46, 0x1c, 0x49, 0x22, 0x15, 0x4a,\n             0x34, 0x29, 0x12, 0x44, 0x38, 0x21, 0x02, 0x44, 0x38, 0x31, 0x23,\n             0x06, 0x4c, 0x08, 0x11, 0x33, 0x37, 0x3f, 0x2e, 0x1c, 0x48, 0x30,\n             0x31, 0x22, 0x14, 0x48, 0x10, 0x41, 0x32, 0x35, 0x3a, 0x24, 0x08,\n             0x40, 0x00, 0x01, 0x13, 0x37, 0x2f, 0x0f, 0x4e, 0x0c, 0x09, 0x03,\n             0x17, 0x2f, 0x1f, 0x4f, 0x1e, 0x4d, 0x3a, 0x25, 0x1a, 0x44, 0x18,\n             0x41, 0x12, 0x45, 0x2a, 0x05, 0x4a, 0x34, 0x39, 0x33, 0x26, 0x0c,\n             0x48, 0x30, 0x21, 0x03, 0x46, 0x1c, 0x29, 0x03, 0x47, 0x0e, 0x0d,\n             0x1b, 0x27, 0x0f, 0x4f, 0x1e, 0x2d, 0x1b, 0x47, 0x2e, 0x1d, 0x4a,\n             0x14, 0x49, 0x02, 0x45, 0x2a, 0x15, 0x4b, 0x26, 0x0d, 0x4a, 0x14,\n             0x39, 0x23, 0x07, 0x4e, 0x2c, 0x09, 0x43, 0x36, 0x3d, 0x2b, 0x16,\n             0x4c, 0x08, 0x41, 0x12, 0x25, 0x0b, 0x47, 0x2e, 0x0d, 0x4b, 0x06,\n             0x1d, 0x3b, 0x27, 0x1f, 0x4e, 0x0c, 0x49, 0x22, 0x05, 0x4b, 0x26,\n             0x1d, 0x4b, 0x06, 0x4d, 0x1a, 0x35, 0x2b, 0x17, 0x4e, 0x2c, 0x19,\n             0x42, 0x24, 0x09, 0x42, 0x24, 0x19, 0x43, 0x36, 0x2d, 0x0a, 0x44,\n             0x18, 0x31, 0x33, 0x27, 0x1e, 0x4c, 0x28, 0x01, 0x42, 0x04, 0x19,\n             0x23, 0x17, 0x4f, 0x3e, 0x3d, 0x2a, 0x04, 0x48, 0x10, 0x21, 0x13,\n             0x47, 0x0e, 0x4d, 0x3a, 0x35, 0x3b, 0x36, 0x2c, 0x18, 0x40, 0x00,\n             0x41, 0x32, 0x25, 0x1b, 0x46, 0x3c, 0x39, 0x32, 0x34, 0x28, 0x00,\n             0x40, 0x20, 0x01, 0x43, 0x16, 0x3d, 0x3b, 0x37, 0x3e, 0x3c, 0x38,\n             0x20, 0x10, 0x40, 0x20, 0x11, 0x42, 0x04, 0x49, 0x02, 0x05, 0x0b,\n             0x07]\n\n\/\/ functions fa and fb\n\ntanFa : [L1Size]-> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ntanFa L1 x k i = (L1!(x@0)) ^ (L1!(x@1)) ^ ((L1!(x@2)) && (L1!(x@3))) ^ ((L1!(x@4)) && ((iR@0)@i)) ^ (k@(k_a_index @i))\n\ntanFb : [L2Size]-> [ySize][ySize] -> [508] -> [Round] -> Bit\n\ntanFb L2 y k i = (L2!(y@0)) ^ (L2!(y@1)) ^ (L2!(y@2) && L2!(y@3)) ^ (L2!(y@4) && L2!(y@5)) ^ (k@(k_b_index @i))\n\n\/\/left shift L1 and L2 and replace LSBs of them with fb and fa respectively\n\n\ntanAplyFb : [L1Size] -> [L2Size]->  [ySize][ySize] ->[KatanKeySize] -> [Round] -> [L1Size]\ntanAplyFb l1 l2 y key i = (l1 !! [(L1Size-2),(L1Size-3)..0]) # [(tanFb l2 y (keySchedule' key) i)]\n\ntanAplyFa : [L1Size] -> [L2Size]-> [xSize][xSize]->[KatanKeySize] -> [Round] -> [L2Size]\ntanAplyFa l1 l2 x key i = (l2 !! [(L2Size-2),(L2Size-3)..0]) # [(tanFa l1 x (keySchedule' key) i)]\n\n\n\/\/Update LFSR KTANTAN\n\n\nupdateLfsrTan : [L1Size] -> [L2Size]-> [xSize][xSize] -> [ySize][ySize]->[KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\nupdateLfsrTan l1 l2 x y key i = if `(L1Size) == 13\n                             then (l1', l2')\n                             else if `(L1Size) == 19\n                                  then (l1'', l2'')\n                                  else (l1''', l2''')\n\n                 where pt = (tanAplyFb l1 l2 y key i) # (tanAplyFa l1 l2 x key i)\n                       l1' = (splitBlock pt).0\n                       l2' = (splitBlock pt).1\n                       pt' = (tanAplyFb l1' l2' y key i) # (tanAplyFa l1' l2' x key i)\n                       l1'' = (splitBlock pt').0\n                       l2'' =  (splitBlock pt').1\n                       pt'' = (tanAplyFb l1'' l2'' y key i) # (tanAplyFa l1'' l2'' x key i)\n                       l1''' = (splitBlock pt'').0\n                       l2''' =  (splitBlock pt'').1\n\n\/\/Encryption\n\nkatantanEncrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\n\nkatantanEncrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] # [((updateLfsrTan pT.0 pT.1 x y key i).0, (updateLfsrTan pT.0 pT.1 x y key i).1) | i<- [0,1..253] | pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\/\/ Wrapper to do experiments\n\nkatantanEncrypt64 : ([KatanBlock], [KatanBlock]) -> [KatanBlock]\nkatantanEncrypt64  (key, pt) = katantanEncrypt( key#zero, pt)\n\n\nkatantanEncrypt80 : ([KatanKeySize], [KatanKeySize]) -> [KatanKeySize]\nkatantanEncrypt80  (key, pt) = katantanEncrypt( key, (take`{64} pt)) # zero\n\n\n\/\/KTANTAN-Decryption\n\n\ndecTanFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ndecTanFa L1 L2 x k i = fa ^ (L1!((x@1)+1)) ^ (L1!((x@2)+1) && L1!((x@3)+1)) ^ (L1!((x@4)+1) && ((iR@0)@i)) ^ k@(k_a_index@i)\n         where fa = L2!0\n\ndecTanFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [508] -> [Round] -> Bit\ndecTanFb L2 L1 y k i =  fb ^ (L2!((y@1)+1)) ^ ((L2!((y@2)+1)) && L2!((y@3)+1)) ^ ((L2!((y@4)+1)) && L2!((y@5)+1)) ^ k@(k_b_index@i)\n         where fb = L1!0\n\n\/\/Left shifting L1, L2 and appending fa, fb values\n\ntanAplydecFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [KatanKeySize] -> [Round] -> [L1Size]\n\ntanAplydecFa  l1 l2 x k i = [(decTanFa l1 l2 x (keySchedule' k) i)] # (l1!![(L1Size-1),(L1Size-2)..1])\n\n\ntanAplydecFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [KatanKeySize] -> [Round] -> [L2Size]\ntanAplydecFb  l2 l1 y k i =  [(decTanFb l2 l1 y (keySchedule' k) i)] # (l2!![(L2Size-1),(L2Size-2)..1])\n\n\/\/ Updating LFSR for decryption\n\ndecUpdateLfsrTan: [L1Size] -> [L2Size] -> [xSize][xSize]-> [ySize][ySize] -> [KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\ndecUpdateLfsrTan  l1 l2 x y key i = if `(L1Size) == 13\n                                 then (l1', l2')\n                                 else if `(L1Size) == 19\n                                      then (l1'', l2'')\n                                      else (l1''', l2''')\n                               where ct = (tanAplydecFa l1 l2 x key i) # (tanAplydecFb l2 l1 y key i)\n                                     l1' = (splitBlock ct).0\n                                     l2' = (splitBlock ct).1\n                                     ct' = (tanAplydecFa l1' l2' x key i) # (tanAplydecFb l2' l1' y key i)\n                                     l1'' = (splitBlock ct').0\n                                     l2'' = (splitBlock ct').1\n                                     ct'' = (tanAplydecFa l1'' l2'' x key i) # (tanAplydecFb l2'' l1'' y key i)\n                                     l1''' = (splitBlock ct'').0\n                                     l2''' = (splitBlock ct'').1\n\/\/Decryption\n\nkatantanDecrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\nkatantanDecrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] #[ ((decUpdateLfsrTan pT.0 pT.1 x y key i).0 , (decUpdateLfsrTan pT.0 pT.1 x y key i).1)  | i <-[253,252..0] |pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\/\/ Correcteness\n\nproperty katantanCorrect key m = katantanDecrypt(key, katantanEncrypt(key, m)) == m\n\n\/\/ Testing\n\n\/\/32bit block size\n\n\/\/tests32 = [ katan32_2, katantan32_1, katantan32_2]\n\/\/property testsPass = and tests32\n\n\/\/katan32_1 = katanEncrypt(0x00000000, 0xffffffffffffffffffff) == 0x7e1ff945\n\/\/katan32_2 = katanEncrypt(0xffffffff, 0x00000000000000000000) == 0x432e61da\n\n\/\/katantan32_1 = katantanEncrypt(0x00000000, 0xffffffffffffffffffff) == 0x22ea3988\n\/\/katantan32_2 = katantanEncrypt(0xffffffff, 0x00000000000000000000) == 0x432e61da\n\n\n\/\/48bit block size\n\/*\ntests48 = [katan48_1, katan48_2, katantan48_1, katantan48_2]\nproperty testsPass = and tests48\n\nkatan48_1 = katanEncrypt(0x000000000000, 0xffffffffffffffffffff) == 0x4b7efcfb8659\nkatan48_2 = katanEncrypt(0xffffffffffff, 0x00000000000000000000) == 0xa4bd196d0b85\n\nkatantan48_1 = katantanEncrypt(0x000000000000, 0xffffffffffffffffffff) == 0x936d0fa33a05\nkatantan48_2 = katantanEncrypt(0xffffffffffff, 0x00000000000000000000) == 0xa4bd196d0b85\n*\/\n\n\/\/64bit block size\n\ntests64 = [katan64_1, katan64_2, katantan64_1, katantan64_2]\nproperty testsPass = and tests64\n\nkatan64_1 = katanEncrypt( 0xffffffffffffffffffff, zero) == 0x21f2e99c0fab828a\nkatan64_2 = katanEncrypt(zero, 0xffffffffffffffff) == 0xc956100dbeb64ba8\n\nkatantan64_1 = katantanEncrypt(0xffffffffffffffffffff, zero) == 0xc02de05bfa194b16\nkatantan64_2 = katantanEncrypt(zero, 0xffffffffffffffff) == 0xc956100dbeb64ba8\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/TEA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the TEA, XTEA, and XXTEA encryption and decryption functions defined in the module Primitive::Symmetric::Cipher::Block::TEA. Specifically, specify properties that prove that decrypting an encrypted plaintext with the same key returns the original plaintext for each cipher variant, and include tests that validate the expected ciphertext outputs for given inputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::TEA where\n\ntype Nb = 2\ntype Nkb = 4\ntype Nr = 2\ntype TeaBlockSize = 64\ntype TeaKeySize = 128\ntype stdBlock = 32\ntype keyInd = 2\n\n\/\/ Splitting plain text\n\nsplitPT: [TeaBlockSize] -> [Nb][stdBlock]\nsplitPT pt = split(pt):[Nb][stdBlock]\n\n\/\/Splitting key\n\nsplitKey: [TeaKeySize] -> [Nkb][stdBlock]\nsplitKey key = split(key):[Nkb][stdBlock]\n\n\/\/A constant derived from golden number\n\ndlta : [stdBlock]\ndlta = 0x9e3779b9\n\nsum = 0xc6ef3720\n\n\/\/ Round function for TEA\n\nteaRoundFun : [stdBlock] -> [stdBlock] -> [stdBlock] -> [stdBlock] -> [stdBlock]\nteaRoundFun pt k1 k2 delta = (pt << 4 + k1) ^ (pt + delta) ^ ((pt>>5)+k2)\n\n\/\/ TEA encryption cycle contains two Feistel rounds\n\nteaEncCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nteaEncCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          k0 = (splitKey key)@0\n          k1 = (splitKey key)@1\n          k2 = (splitKey key)@2\n          k3 = (splitKey key)@3\n          fiestr1 = rpt# roundf1\n          roundf1 = lpt + (teaRoundFun rpt k0 k1 sum)\n          fiestr2 = roundf1 # roundf2\n          roundf2 = rpt + (teaRoundFun roundf1 k2 k3 sum)\n\n\/\/ TEA decryption cycle with two Feistel rounds\n\nteaDecCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nteaDecCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          k0 = (splitKey key)@0\n          k1 = (splitKey key)@1\n          k2 = (splitKey key)@2\n          k3 = (splitKey key)@3\n          roundf2 = rpt - (teaRoundFun lpt k2 k3 sum)\n          roundf1 = lpt - (teaRoundFun roundf2 k0 k1 sum)\n          fiestr2 = roundf1 # roundf2\n\n\n\/\/Encryption: 32 TEA cycles are recommended\n\/\/We change the blocksize as the key size\n\/\/teaEncrypt encrypts actually half of the given plaintext\n\nteaEncrypt : ([TeaKeySize], [TeaBlockSize]) -> [TeaBlockSize]\nteaEncrypt (key, pt) = (hs!0)\n    where hs = [pt] # [ teaEncCycle(m, key, i*dlta) | i <- [1,2..32] | m <- hs ]\n\n\n\n\/\/Decryption\n\nteaDecrypt : ([TeaKeySize], [TeaBlockSize]) -> [TeaBlockSize]\nteaDecrypt (key, ct) = (hs!0)\n    where hs = [ct] # [ teaDecCycle(cT, key, sum-i*dlta) | i <- [0,1..31] | cT <- hs ]\n\n\n\n\nproperty teaCorrect key m = teaDecrypt(key, teaEncrypt (key, m)) == m\n\n\/\/ Helper to run the experiments\n\nteaEncrypt' : ([TeaBlockSize], [TeaBlockSize]) -> [TeaBlockSize]\nteaEncrypt' (key, pt) = (hs!0)\n    where hs = [pt] # [ teaEncCycle(m, key', i*dlta) | i <- [1,2..32] | m <- hs ]\n          key' = key # zero\n\nteaDecrypt' : ([TeaBlockSize], [TeaBlockSize]) -> [TeaBlockSize]\nteaDecrypt' (key, ct) = (hs!0)\n    where hs = [ct] # [ teaDecCycle(cT, key', sum-i*dlta) | i<- [0,1..31] | cT <- hs ]\n          key' = key #zero\n\n\nproperty teaCorrect' key m = teaDecrypt'(key, teaEncrypt'(key, m)) == m\n\n\/************************************************************************\/\n\/************************************************************************\/\n\/* eXtended TEA *\/\n\n\/\/Round function for XTEA\n\nxTeaRoundFun : [stdBlock] -> [TeaKeySize] -> [stdBlock] -> [stdBlock] -> [stdBlock]\nxTeaRoundFun pt key sum1 sum2 = (((pt << 4) ^ (pt >> 5)) + pt) ^ (sum1 + k)\n    where k = (splitKey key)@(sum2 !![1,0])\n\n\/\/ XTEA cycle contains two Feistel rounds\n\nxTeaEncCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nxTeaEncCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          roundf1 = lpt +(xTeaRoundFun rpt key sum sum)\n          fiestr2 = roundf1 # roundf2\n          roundf2 = rpt+(xTeaRoundFun roundf1 key (sum+dlta) ((sum+dlta)>>11))\n\n\/\/XTEA decryption cycle contains two Feistel rounds\n\nxTeaDecCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nxTeaDecCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          roundf2 = rpt - (xTeaRoundFun lpt key sum (sum>>11))\n          roundf1 = lpt - (xTeaRoundFun roundf2 key (sum-dlta) (sum-dlta))\n          fiestr2 = roundf1 # roundf2\n\n\n\/\/Encryption: 32 XTEA cycles are recommended\n\/\/I change the signatures to run the experiments\n\ntype PTSize = TeaBlockSize\ntype CTSize = TeaBlockSize\n\nxTeaEncrypt : ([TeaKeySize], [PTSize]) -> [CTSize]\nxTeaEncrypt (key, pt) = (hs!0)\n    where hs = [pt] # [ xTeaEncCycle (m, key, i*dlta) | i <- [0,1..31] | m <- hs ]\n\n\/\/Decryption\n\nxTeaDecrypt : ([TeaKeySize], [CTSize]) -> [PTSize]\nxTeaDecrypt (key, ct) = (hs!0)\n    where hs = [ct] # [ xTeaDecCycle (pT, key, i*dlta) | i <- [32,31..1] | pT <- hs ]\n\nproperty xTeaCorrect key m = xTeaDecrypt(key, xTeaEncrypt(key, m)) == m\n\n\/\/ Helper function to run experiments\n\nxTeaEncrypt64 : ([PTSize], [PTSize]) -> [CTSize]\nxTeaEncrypt64 (key, pt) = (hs!0)\n    where hs = [pt] # [ xTeaEncCycle (m, key', i*dlta) | i <- [0,1..31] | m <- hs ]\n          key' = key # zero\n\nxTeaDecrypt64 : ([CTSize], [PTSize]) -> [PTSize]\nxTeaDecrypt64 (key, ct) = (hs!0)\n    where hs = [ct] # [ xTeaDecCycle (pT, key', i*dlta) | i <- [32,31..1] | pT <- hs ]\n          key' = key # zero\n\nproperty xTeaCorrect64 key m = xTeaDecrypt64 (key, xTeaEncrypt64(key,m)) == m\n\n\nxTeaEncrypt128 : ([TeaKeySize], [TeaKeySize]) -> [TeaKeySize]\nxTeaEncrypt128 (key, pt) = xTeaEncrypt (key, (take`{64} pt)) # zero\n\n\/************************************************************************\/\n\/************************************************************************\/\n\/* Corrected Block TEA or XXTEA*\/\n\/* XTEA modified to cater larger block sizes*\/\n\ntype NB = 2\nNr = 6 + 52\/`NB\ntype bTeaPtSize= NB*stdBlock\n\n\/\/Splitting text into number of words\n\nsplitPtN: [bTeaPtSize] -> [NB][stdBlock]\nsplitPtN pt = split(pt) : [NB][stdBlock]\n\n\/\/Round Function\n\nbTeaRoundFun: [stdBlock]-> [stdBlock]-> [TeaKeySize]-> [6]-> [stdBlock]->[stdBlock]\nbTeaRoundFun y z key p sum = ((z>>5) ^ (y<<2)) + ((y>>3) ^ (z<<4)) ^ (sum ^ y) + ((ki @ ((p!![1,0]) ^ e)) ^ z)\n    where ki = (splitKey key)\n          e = (sum >> 2) !![1,0]\n\n\/\/Mixing in encryption\n\nbTeaEncMixing : ([bTeaPtSize], [TeaKeySize], [stdBlock]) -> [bTeaPtSize]\n\nbTeaEncMixing (pt, key, sum) = join hs'\n    where pt' = splitPtN pt\n          hs = [ (pt'@0)+(bTeaRoundFun (pt'@1) (pt'@(`NB-1)) key 0 sum) ] # [ (pt'@p)+(bTeaRoundFun (pt'@(p+1)) h key p sum) | p <- [1,2..NB-2] | h <- hs ]\n          hs' = hs # [ (pt'@(`NB-1)) + (bTeaRoundFun (hs@0) (hs!0) key (`NB-1) sum) ]\n\n\n\n\/\/Encryption\n\nbTeaEncrypt : ([TeaKeySize], [bTeaPtSize]) -> [bTeaPtSize]\nbTeaEncrypt (key, pt) = hs!0\n    where hs = [bTeaEncMixing (pt, key, dlta)] # [ bTeaEncMixing (pT, key, i*dlta) | i <- [2,3..Nr] | pT <- hs ]\n\n\n\/\/Mixing in decryption\n\n\nbTeaDecMixing : ([bTeaPtSize], [TeaKeySize], [stdBlock]) -> [bTeaPtSize]\n\nbTeaDecMixing (pt, key, sum) = join hs''\n    where pt' = splitPtN pt\n          hs= [(pt'@(`NB-1)) - (bTeaRoundFun (pt'@0) (pt'@(`NB-2)) key  1 sum)] # [ pt'@(`NB-1-p)-(bTeaRoundFun h (pt'@ (`NB-2-p)) key p sum) | p <- [1,2..(NB-2)] | h <- hs ]\n          hs' =  hs # [ pt'@0 - (bTeaRoundFun (hs!0) (hs@0) key  0 sum)]\n          hs'' = [hs'!0] # [hs'!i | i<- [1,2..NB-1] ]\n          \/\/e = (sum >> 2) !![1,0]\n          \/\/hs'' = [(hs'!0).2]# [((hs'!i).2) | i<-[1,2..`NB-1]]\n\n\/\/ Decryption\n\nbTeaDecrypt : ([TeaKeySize], [bTeaPtSize]) -> [bTeaPtSize]\nbTeaDecrypt (key, pt) =  hs!0\n    where hs = [bTeaDecMixing (pt, key, `Nr*dlta)] # [ bTeaDecMixing (pT, key, (`Nr-i)*dlta) | i <- [1,2..(Nr-1)] | pT <- hs ]\n\n\/\/ correctness\n\nproperty bTeaCorrect key m = bTeaDecrypt(key, bTeaEncrypt (key, m)) == m\n\n\ntests = [teaTest, xteaTest, xxteaTest]\nproperty testsPass = and tests\n\n\/\/ TEA\nteaTest = teaEncrypt(0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0xce674a7575034065\n\/\/XTEA\nxteaTest = xTeaEncrypt(0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0x27e795e076b2b537\n\/\/XXTEA or bTEA\nxxteaTest = bTeaEncrypt(0x0123456789abcdef0123456789abcdef,0x0123456789abcdef) == 0x2b98de778c9b788c\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness and security properties of the GCM_AE and GCM_AD functions defined in the given GCM specification module. Include properties that check the symmetry of encryption and decryption, the validity of tag generation, and the correctness of the GHASH and multiplication operations as per NIST-SP-800-38D. Also, write properties to ensure that GCTR produces empty output for empty input and that the multiplication operations (mult and \u2022) are equivalent."},{"role":"assistant","content":"```cryptol\n\/*\nGalois Counter Mode in Cryptol\n\n@copyright Galois, Inc.\n@author Sean Weaver\n@author Marcella Hastings <marcella@galois.com>\n\nThis implementation follows NIST special publication 800-38D:\n[NIST-SP-800-38D] Morris Dworkin. Recommendation for Block Cipher Modes\nof Operation: Galois\/Counter Mode (GCM) and GMAC. NIST Special\nPublication 800-38D. November 2007.\n\nThis implementation deviates from the original spec in the following ways:\n- The original spec allows tag lengths 96, 104, 112, 120, and 128 in all\n  settings, and allows length 64 or 32 in certain applications. This\n  implementation does not allow short tags (32 or 64) at all.\n\n\u26a0\ufe0f Warning \u26a0\ufe0f: There are several properties of GCM mode that Cryptol cannot\nenforce! These include:\n- GCM mode will fail catastrophically if a (key, IV) pair is ever reused\n  to encrypt different pieces of data.\n  Implementors must manually verify that keys and IVs are chosen in such\n  a way that they will not be reused. See [NIST-SP-800-38D] Section 8.\n- The total number of invocations of `GCM_AE` with a given key must not\n  exceed 2^{32}. This is to prevent the catastrophic failure in the previous\n  point. Cryptol cannot evaluate the \"global\" use of the encryption function.\n- The intermediate values used in the execution of GCM functions must be\n  secret, and not reused or recomputed for any other purpose.\n- The original spec requires an implementation with `GCM_AE` and `GCM_AD`\n  must support the same ciphertext, associated data, and IV lengths for\n  both algorithms.\n*\/\n\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Specification where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\/**\n * GCM mode is only defined for ciphers that operate over 128-bit blocks.\n * [NIST-SP-800-38D] Section 5.1\n *\/\ninterface constraint (C::BlockSize == 128)\n\/**\n * GCM mode is only defined for ciphers with a key size of at least 128 bits.\n * [NIST-SP-800-38D] Section 5.1\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: GCM mode has other requirements on the key that cannot be\n * enforced by Cryptol (for example, that it is generated uniformly at random).\n * See Section 8.1 of [NIST-SP-800-38D].\n *\/\n interface constraint (128 <= C::KeySize)\n\n\/**\n * The IV has bit length `1 \u2264 IV \u2264 2^64 - 1` and is a multiple of 8.\n * [NIST-SP-800-38D] Section 5.2.1.1\n *\/\ntype constraint ValidIV IV = (width IV <= 64, IV >= 1, IV % 8 == 0)\n\/**\n * The associated data has bit length `AAD \u2264 2^64 - 1` and is a multiple of 8.\n * [NIST-SP-800-38D] Section 5.2.1.1\n *\/\ntype constraint ValidAAD AAD = (width AAD <= 64, AAD % 8 == 0)\n\/**\n * The tag T can be of length 96, 104, 112, 120, or 128.\n * [NIST-SP-800-38D] Section 5.2.1.2\n *\/\ntype constraint ValidTag T = (fin T, T % 8 == 0, T \/ 8 >= 12, T \/ 8 <= 16)\n\/**\n * The plaintext (for encryption) and ciphertext (for decryption) must not\n * be too large and is a multiple of 8.\n * [NIST-SP-800-38D] Section 5.2.1.1 (for plaintexts) and Section 5.2.2\n * (for ciphertexts).\n *\/\ntype constraint ValidText P = (fin P, P <= 2^^39 - 256, P % 8 == 0)\n\n\/**\n * GCM-AE Function, [NIST-SP-800-38D] Section 7.1, Algorithm 4. This provides\n * authenticated encryption.\n *\/\nGCM_AE : { len_C, len_IV, len_A, T } (ValidText len_C, ValidIV len_IV, ValidAAD len_A, ValidTag T)\n => [C::KeySize] -> [len_IV] -> [len_C] -> [len_A] -> ([len_C], [T])\nGCM_AE k iv p a = (C, T)\n  where\n    CIPHk = C::encrypt k\n\n    H = CIPHk 0\n    J0 = define_J0 k iv H\n    C = GCTR CIPHk (inc`{32} J0) p\n    type u = len_C %^ 128 \/\/ Equivalently: 128 * len_C \/^ 128 - len_C\n    type v = len_A %^ 128 \/\/ Equivalently: 128 * len_A \/^ 128 - len_A\n    S = GHASH`{len_A\/^ 128 + len_C \/^ 128 + 1}\n            H (a # (0 : [v]) # C # (0 : [u]) # (`len_A : [64]) # (`len_C : [64]))\n    T = MSB`{T} (GCTR CIPHk J0 S)\n\n\/**\n * GCM-AD Function, [NIST-SP-800-38D] Section 7.2, Algorithm 5. This provides\n * authenticated decryption.\n *\/\nGCM_AD : { len_C, len_IV, len_A, T } (ValidText len_C, ValidIV len_IV, ValidAAD len_A, ValidTag T)\n => [C::KeySize] -> [len_IV] -> [len_C] -> [len_A] -> [T] -> Option [len_C]\nGCM_AD key iv ct aad tag =\n  if tag == T'\n  then Some P\n  else None\n  where\n    CIPHk = C::encrypt key\n\n    H = CIPHk 0\n    J0 = define_J0 key iv H\n    P = GCTR CIPHk (inc`{32} J0) ct\n    type u = len_C %^ 128 \/\/ Equivalently: 128 * len_C \/^ 128 - len_C\n    type v = len_A %^ 128 \/\/ Equivalently: 128 * len_A \/^ 128 - len_A\n    S = GHASH`{len_A \/^ 128 + len_C \/^ 128 + 1}\n            H (aad # (0 : [v]) # ct # (0 : [u]) # (`len_A : [64]) # (`len_C : [64]))\n    T' = MSB`{T} (GCTR CIPHk J0 S)\n\n\/**\n * Property demonstrating equivalence between `mult` and `\u2022`.\n * This takes more than 25 minutes to `:prove`.\n * ```repl\n * :check dotAndMultAreEquivalent\n * ```\n *\/\nproperty dotAndMultAreEquivalent X Y = mult X Y == X \u2022 Y\n\n\/**\n * Property demonstrating that decryption is the inverse of encryption.\n *\n * This property takes more than 20 minutes to `:prove`.\n * It's spot-checked in the test vectors.\n * Here we pick a fixed set of parameters, but it should be true\n * for all valid tag, aad, and plaintext lengths.\n * - P = 256 because we want to test the block chaining, so we need at least 2\n * - IV = 96 because it's the shortest allowable value\n * - AAD = 8 because we want to make sure it's incorporated\n *\n * ```repl\n * :check gcmIsSymmetric `{AAD=8, P=256, IV=96}\n * ```\n *\/\ngcmIsSymmetric : { P, IV, AAD } ( ValidText P, ValidIV IV, ValidAAD AAD )\n  => [C::KeySize] -> [IV] -> [P] -> [AAD] -> Bool\nproperty gcmIsSymmetric key iv pt aad = is_symmetric\n    where\n        (ct, tag : [96]) = GCM_AE key iv pt aad\n        dec = GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nprivate\n  \/**\n  * A helper function used in GCM_AE and GCM_AD. We must define this at the top\n  * level due to its use of Cryptol's numeric constraint guards feature, which\n  * currently only works in top-level definitions.\n  *\n  * See [NIST-SP-800-38D] Algorithm 4, Step 2 and Algorithm 5, Step 3.\n  *\/\n  define_J0 : { len_IV } ( ValidIV len_IV ) => [C::KeySize] -> [len_IV] -> [128] -> [128]\n  define_J0 k iv H\n    | len_IV == 96 => iv # (0 : [31]) # (1 : [1])\n    | len_IV != 96 => GHASH`{len_IV \/^ 128 + 1} H (iv # (0 : [s + 64]) # (`len_IV: [64]))\n    where\n      type s = len_IV %^ 128  \/\/ Equivalently: 128 * len_IV \/^ 128 - len_IV\n\n  \/**\n  * Multiplication Operation on Blocks, [NIST-SP-800-38D] Section\n  * 6.3, Algorithm 1. This is optimized to use Cryptol's built-in `pmult` and\n  * `pmod` functions. This operation is described using little-endian\n  * notation, hence the `reverse`s.\n  *\/\n\n  (\u2022) : [128] -> [128] -> [128]\n  (\u2022) X Y = reverse (pmod (pmult (reverse X) (reverse Y))\n                          <| 1 + x + x^^2 + x^^7 + x^^128|>)\n\n  \/**\n  * Multiplication Operation on Blocks, [NIST-SP-800-38D] Section\n  * 6.3. This matches the spec very closely.\n  *\/\n\n  mult : [128] -> [128] -> [128]\n  mult X Y = last Z\n    where\n      R = 0b11100001 # (0 : [120])\n      Z = [0] # [ if [xi] == 0 then Zi else Zi ^ Vi\n                | Zi <- Z\n                | xi <- X\n                | Vi <- V ]\n      V = [Y] # [ if LSB`{1} Vi == 0 then Vi >> 1 else (Vi >> 1) ^ R\n                | Vi <- V ]\n\n  \/**\n  * GHASH Function, [NIST-SP-800-38D] Section 6.4, Algorithm 2.\n  *\/\n\n  GHASH : {m} (fin m) => [128] -> [m * 128] -> [128]\n  GHASH H X = last Y\n    where Y = [0] # [ (Yi ^ Xi) \u2022 H | Yi <- Y | Xi <- groupBy`{128} X ]\n\n  \/**\n  * The output of incrementing the right-most s bits of the bit\n  * string X, regarded as the binary representation of an integer, by\n  * 1 modulo 2s, [NIST-SP-800-38D] Sections 4.2.2 and 6.2. Care was\n  * taken here to ensure `s` could be zero.\n  *\/\n\n  inc : {s, a} (fin s, fin a, a >= s) => [a] -> [a]\n  inc X = MSB`{a-s} X # (LSB`{s} X + take (1 : [max s 1]))\n\n\n  \/**\n  * The bit string consisting of the s right-most bits\n  * of the bit string X, [NIST-SP-800-38D] Section 4.2.2.\n  *\/\n\n  LSB : {s, a} (fin s, fin a, a >= s) => [a] -> [s]\n  LSB X = drop X\n\n  \/**\n  * The bit string consisting of the s left-most bits of\n  * the bit string X, [NIST-SP-800-38D] Section 4.2.2.\n  *\/\n\n  MSB : {s, a} (fin s, a >= s) => [a] -> [s]\n  MSB X = take X\n\n  \/**\n  * GCTR Function, [NIST-SP-800-38D] Section 6.5, Algorithm 3.\n  *\/\n\n  GCTR : {a} (fin a) => ([128] -> [128]) -> [128] -> [a] -> [a]\n  GCTR CIPHk ICB X = Y\n    where\n      Y = X ^ take`{a} (join (map CIPHk CB))\n      CB = iterate inc`{32} ICB\n\n  \/**\n   * GCTR should return an empty output when given an empty input.\n   * This property is described in [NIST-SP-800-38D], Algorithm 3.\n   *\n   * ```repl\n   * :prove emptyInputProducesEmptyOutputGCTR\n   * ```\n   *\/\n  emptyInputProducesEmptyOutputGCTR : [C::KeySize] -> [128] -> Bool\n  property emptyInputProducesEmptyOutputGCTR key icb =\n   zero == (GCTR CIPHk icb (zero : [0]))\n    where\n      CIPHk = C::encrypt key\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Tests\/AES128_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that verify the correctness of the AES128 GCM authenticated encryption and decryption implementation. The properties should check that for given test vectors, the ciphertext and authentication tag match expected values, and that decryption recovers the original plaintext, ensuring the encryption and decryption functions are symmetric and correct."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES128_GCM where\nimport Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES128_GCM as AES_GCM\n\n\/**\n * Source: [GCM Submission]\n * ```repl\n * :prove aes128_vector_0\n * ```\n *\/\nproperty aes128_vector_0 = ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        pt = []\n        key = zero : [128]\n        iv = zero : [96]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt []\n        dec = AES_GCM::GCM_AD key iv ct [] tag\n        expected_ct = [] : [0]\n        expected_tag = 0x58e2fccefa7e3061367f1d57a4e7455a : [128]\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\n\/**\n * Source: [GCM Submission]\n * ```repl\n * :prove aes128_vector_1\n * ```\n *\/\nproperty aes128_vector_1 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = zero\n        iv = zero : [96]\n        pt = zero\n        aad = []\n        expected_ct = 0x0388dace60b6a392f328c2b971b2fe78 : [128]\n        expected_tag = 0xab6e47d42cec13bdf53a67b21257bddf : [128]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\n\n\/**\n * Source: [GCM Submission]\n * ```repl\n * :prove aes128_vector_2\n * ```\n *\/\nproperty aes128_vector_2 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = 0xfeffe9928665731c6d6a8f9467308308\n        iv = 0xcafebabefacedbaddecaf888 : [96]\n        pt = 0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b391aafd255\n        aad = []\n        expected_ct = 0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091473f5985\n        expected_tag = 0x4d5c2af327cd64a62cf35abd2ba6fab4 : [128]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\n\n\/**\n * Source: [GCM Submission]\n * ```repl\n * :prove aes128_vector_3\n * ```\n *\/\nproperty aes128_vector_3 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = 0xfeffe9928665731c6d6a8f9467308308\n        pt  = 0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b39\n        iv  = 0xcafebabefacedbaddecaf888\n        aad = 0xfeedfacedeadbeeffeedfacedeadbeefabaddad2\n        expected_ct  = 0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091\n        expected_tag = 0x5bc94fbc3221a5db94fae95ae7121a47\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Tests\/AES256_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and security of the AES256 GCM authenticated encryption implementation, including tests for encryption-decryption symmetry with valid tags and failure on invalid tags, as exemplified in the given AES256_GCM test module."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES256_GCM where\nimport Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES256_GCM as AES_GCM\n\n\/**\n * Source: [OPENSSL]\n * ```repl\n * :prove aes256_vector_0\n * ```\n *\/\nproperty aes256_vector_0 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key   = 0xeebc1f57487f51921c0465665f8ae6d1658bb26de6f8a069a3520293a572078f : [256]\n        iv    = 0x99aa3e68ed8173a0eed06684 : [96]\n        pt    = 0xf56e87055bc32d0eeb31b2eacc2bf2a5 : [128]\n        aad   = 0x4d23c3cec334b49bdb370c437fec78de : [128]\n        expected_ct   = 0xf7264413a84c0e7cd536867eb9f21736\n        expected_tag  = 0x67ba0510262ae487d737ee6298f77e0c\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\n\/**\n * Source: Modified from [OPENSSL]. I just borked the tag to make sure decryption fails if\n * the tag is wrong.\n * ```repl\n * :prove aes256_invalid_vector_1\n * ```\n *\/\nproperty aes256_invalid_vector_1 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ requires_symmetry\n    where\n        key   = 0xeebc1f57487f51921c0465665f8ae6d1658bb26de6f8a069a3520293a572078f : [256]\n        iv    = 0x99aa3e68ed8173a0eed06684 : [96]\n        pt    = 0xf56e87055bc32d0eeb31b2eacc2bf2a5 : [128]\n        aad   = 0x4d23c3cec334b49bdb370c437fec78de : [128]\n        expected_ct   = 0xf7264413a84c0e7cd536867eb9f21736\n        expected_tag  = 0x67ba0510262ae487d737ee6298f77e0c\n        invalid_tag  = 0x67ba0510262ae487d737ee6298f77888\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        requires_symmetry = case (AES_GCM::GCM_AD key iv ct aad invalid_tag) of\n            Some _ -> False\n            None -> True\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Instantiations\/AES128_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and properties of the AES128_GCM authenticated encryption module, including correctness of encryption and decryption, authentication tag verification, and compliance with the GCM mode specification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES128_GCM =\n    Primitive::Symmetric::Cipher::Authenticated::GCM::Specification {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Instantiations\/AES256_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and security properties of the AES-256 GCM authenticated encryption module as instantiated in the given file. The specification should include the correctness of encryption and decryption, authentication tag verification, and resistance to forgery under the GCM mode using AES-256 as the block cipher."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES256_GCM =\n    Primitive::Symmetric::Cipher::Authenticated::GCM::Specification {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the TDES CBC mode implementation in the given module. Specifically, include properties that check: (1) encryption followed by decryption returns the original plaintext for any input blocks and keys; (2) the implementation matches the provided test vectors exactly; and (3) any other relevant invariants or correctness conditions for CBC mode encryption and decryption using Triple DES."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::TDES_CBC where\n\nimport Primitive::Symmetric::Cipher::Block::TripleDES (encrypt, decrypt)\n\n\/\/ Test vectors from https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Standards-and-Guidelines\/documents\/examples\/TDES_CBC.pdf\ntype iv = [64]\ntype block = [64]\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncbcTDesEnc : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncbcTDesEnc k1 k2 k3 iv ps = cs\n    where\n        ks = [ k1, k2, k3 ]\n        cs = [ encrypt ks (p ^ c') | p <- ps | c' <- [iv] # cs ]\n\ncbcTDesDec : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncbcTDesDec k1 k2 k3 iv cts = pts\n    where\n        ks  = [ k1, k2, k3 ]\n        pts = [ (decrypt ks ct) ^ fb |  ct <- cts | fb <- [iv] # cts  ]\n\ncbcTDESEncryptDecryptInverts : k1 -> k2 -> k3 -> iv -> [3]block -> Bit\nproperty cbcTDESEncryptDecryptInverts k1 k2 k3 iv pt = pt == pt'\n    where\n        ct  = cbcTDesEnc k1 k2 k3 iv pt\n        pt' = cbcTDesDec k1 k2 k3 iv ct\n\n\/\/ Number of blocks := 2\n\ntestKey = { k1=0x0123456789ABCDEF\n          , k2=0x23456789ABCDEF01\n          , k3=0x456789ABCDEF0123\n          , iv=0xF69F2445DF4F9B17\n          }\ntestPt  = [0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]\ntestCt  = [0x2079C3D53AA763E1, 0x93B79E2569AB5262, 0x516570481F25B50F, 0x73C0BDA85C8E0DA7]\n\nproperty testsPass = pt == testPt\n                  \/\\ ct == testCt\n    where\n        ct = cbcTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv testPt\n        pt = cbcTDesDec testKey.k1 testKey.k2 testKey.k3 testKey.iv testCt\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property or verification script that formally proves the correctness of the CBC mode implementation by showing that decrypting the ciphertext produced by encrypting a plaintext with the same key and IV returns the original plaintext, as expressed by the encryptCorrect property in the CBC module."},{"role":"assistant","content":"```cryptol\n\/*\n * Cipher Block Chaining mode of operation, as defined in [NIST-SP-800-38A], Section 6.2.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: To ensure confidentiality, CBC mode requires that the initialization vector (IV) is generated \"unpredictably\".\n * This specification does not verify IV generation;\n * implementors must manually verify that their IVs were chosen appropriately.\n *\n * For guidelines on generating IVs, see Appendix C of [NIST-SP-800-38A].\n * For information on the importance of protecting IV integrity, see Appendix D of [NIST-SP-800-38A].\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Marcella Hastings <marcella@galois.com>\n * @author Stanislav Lyakhov <stan@galois.com>\n * www.cryptol.net\n *\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n *     Modes of Operation: Methods and Techniques. NIST Special Publication\n *     800-38A. December 2001.\n *     @see https:\/\/doi.org\/10.6028\/NIST.SP.800-38A\n *\n *\/\n\n\nmodule Primitive::Symmetric::Cipher::Block::Modes::CBC where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\n\/**\n * CBC encryption: [NIST-SP-800-38A] Section 6.2.\n *\n * Parameters: key, initialization vector, plaintext\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: To ensure confidentiality, CBC mode requires that the initialization vector (IV) is generated \"unpredictably\".\n * This specification does not verify IV generation;\n * implementors must manually verify that their IVs were chosen appropriately.\n *\/\nencrypt : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\nencrypt K IV Ps = Cs\n    where\n        CIPH_K = C::encrypt K\n        Cs = [ CIPH_K (P_j ^ C_j_1) | P_j <- Ps | C_j_1 <- [IV] # Cs]\n\n\/**\n * CBC decryption: [NIST-SP-800-38A] Section 6.2.\n *\n * Parameters: key, initialization vector, ciphertext\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: To ensure confidentiality, CBC mode requires that the initialization vector (IV) is generated \"unpredictably\".\n * This specification does not verify IV generation;\n * implementors must manually verify that their IVs were chosen appropriately.\n *\/\ndecrypt : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\ndecrypt K IV Cs = Ps\n    where\n        CIPH_K_inv = C::decrypt K\n        Ps = [ (CIPH_K_inv C_j) ^ C_j_1 | C_j <- Cs | C_j_1 <- [IV] # Cs]\n\n\/**\n * Decryption must be the inverse of encryption.\n * With high probability, this will be incredibly slow to prove.\n * ```repl\n * :check encryptCorrect`{n=5}\n * ```\n *\/\nencryptCorrect : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> Bool\nproperty encryptCorrect K IV Ps = (decrypt K IV (encrypt K IV Ps)) == Ps\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the CTR mode encryption and decryption functions are inverses of each other for all valid inputs, ensuring that decrypt(k, t, encrypt(k, t, ps)) == ps holds. Include checks for the counter increment behavior and constraints preventing counter reuse within a single encryption."},{"role":"assistant","content":"```cryptol\n\/*\n * Counter mode of operation, as defined in [NIST-SP-800-38A], Section 6.5.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: CTR mode will fail catastrophically if a (key, counter) pair is ever reused.\n * Cryptol cannot detect such failures! Please audit your implementations separately for\n * this issue.\n *\n *\n * This deviates from the original NIST spec in several ways:\n * - The spec allows arbitrary length plaintexts. This implementation fixes\n *   the plaintext to be an exact multiple of the block length.\n * - The spec allows any incrementing function that generates `n` unique strings\n *   of `m` bits in succession, where `n` is the plaintext length and `m` is the\n *   number of bits to be updated in the counter block (n <= C::BlockSize).\n *   This implementation fixes the incrementing function to be the standard\n *   incrementing function: `[x]_m -> [x + 1 mod 2^m]_m` for `m = C::BlockSize`.\n *   See Appendix B of [NIST-SP-800-38A] for discussion.\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Marcella Hastings <marcella@galois.com>\n * www.cryptol.net\n *\n * References:\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n * Modes of Operation: Methods and Techniques. NIST Special Publication\n * 800-38A. December 2001.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Modes::CTR where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\n\/**\n * CTR encryption: [NIST-SP-800-38A] Section 6.5.\n *\n * Parameters: key, initial counter, plaintext\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: CTR mode will fail catastrophically if a (key, counter) pair is ever reused.\n * Cryptol cannot detect such failures!\n * The type constraint on `n` prevents counter reuse within a single encryption, but\n * implementors must manually verify that counter reuse will not happen across multiple\n * calls to `encrypt`.\n *\/\nencrypt : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\nencrypt k t_1 ps = cs\n    where\n        ciph_k = C::encrypt k\n        \/\/ `ciph_k t_j` is called `O_j` in the original spec\n        cs = [p_j ^ (ciph_k t_j) | p_j <- ps | t_j <- ctrs]\n        \/\/ Counters are called `T_1, ..., T_n` in the original spec\n        ctrs = [t_1 + i | i<- [0...]]\n\n\/**\n * CTR decryption: [NIST-SP-800-38A] Section 6.5.\n *\n * Parameters: key, initial counter, ciphertext\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: CTR mode will fail catastrophically if a (key, counter) pair is ever reused.\n * Cryptol cannot detect such failures!\n *\/\ndecrypt : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\ndecrypt k t_1 cs = ps\n    where\n        ciph_k = C::encrypt k\n        \/\/ (ciph_k t_j) is called O_j in the original spec\n        ps = [c_j ^ (ciph_k t_j) | c_j <- cs | t_j <- ctrs]\n        \/\/ Counters are called T_1, ..., T_n in the original spec\n        ctrs = [t_1 + i | i<- [0...]]\n\n\/**\n * Decryption must be the inverse of encryption.\n * With high probability, this will be incredibly slow to prove.\n * ```repl\n * :check encryptCorrect`{n=5}\n * ```\n *\/\nencryptCorrect : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> Bool\nproperty encryptCorrect k c ps = (decrypt k c (encrypt k c ps)) == ps\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/XTS.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the XTS mode implementation in the given module. Specifically, include properties that check the involutiveness of the endian flip function, the correctness of the data unit sequence number to IV conversion, the correctness of the GF(2^128) multiplication by alpha, and the fundamental property that decryption inverts encryption for valid inputs. Ensure these properties can be used with Cryptol's :prove or :check commands to validate the implementation against the XTS-AES standard."},{"role":"assistant","content":"```cryptol\n\/**\n * Implementation of the XTS Tweakable Block Cipher mode.\n *\n * This version implements the specification as defined in [IEEE2007].\n * The primary difference in [IEEE2018] constraints the overall\n * size of a data stream in a way that isn't constrained by this\n * implementation and would need to be enforced by the application.\n *\n * This implementation does not define key scopes or key export as described\n * in sections 6 and 7.\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n * @author John Christensen <jchristensen@galois.com>\n *\n * References:\n * [NIST]: NIST SP 800-38E: Recommendation for Block Cipher Modes of Operation:\n *   The XTS-AES Mode for Confidentiality on Storage Devices.\n * [IEEE2007]: IEEE Std 1619-2007, The XTS-AES Tweakable Block Cipher, Institute of\n *   Electrical and Electronics Engineers, Inc., Apr. 18, 2008.\n * [IEEE2018]: IEEE Std 1619-2018, The XTS-AES Tweakable Block Cipher, Institute of\n *   Electrical and Electronics Engineers, Inc., Oct. 23 2018.\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::XTS where\n\n\/\/ [IEEE2007] only defines XTS-AES-128 and XTS-AES-256. Other instantiations\n\/\/ of this functor are not permitted by [NIST].\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\n\/*\n * XTS encrypts a `data stream` that is divided into consecutive equal size\n * `data units`.\n *\n * References:\n *   [IEEE2007] Section 5.1\n *   [IEEE2018] Section 5.1\n *\/\n\n\/**\n * In particular, the result of AES encryption and decryption (a 16-byte value) is\n * multiplied by a primitive element of GF(2^128) during the encryption and decryption\n * procedures.\n *\n * References:\n *   [IEEE2007] Section 5.2\n *   [IEEE2018] Section 5.2\n *\/\ninterface constraint (C::BlockSize == 128)\n\n\/**\n * Cryptol treats all bitvectors in big-endian numbers.\n * The specification treats byte arrays as little-endian numbers\n * for the purposes of encrypting the tweak.\n *\n * References:\n *   [IEEE2007] Section 5.2\n *   [IEEE2018] Section 5.2\n *\/\nflipEndian : [128] -> [128]\nflipEndian x = join (reverse (groupBy`{8} x))\n\n\/**\n * The `flipEndian` procedure is its own inverse.\n *\n * ```repl\n * :prove flipEndianInvolutive\n * ```\n *\/\nproperty flipEndianInvolutive x = flipEndian (flipEndian x) == x\n\n\/**\n * NIST SP 800-38E states: The length of the data unit for any instance of\n * an implementation of XTS-AES shall not exceed 2^20 AES blocks.\n *\n * This restriction of _within a data unit_ is consistent with both\n * [IEEE2007] and [IEEE2018].\n *\n * [IEEE2007] and [IEEE2018] Section 5.3.2 imply the data unit must be\n * at least the length of the block size. The final block, presuming there\n * is at least one full block, can be extended with ciphertext stealing,\n * but there is no such scheme if the plaintext length is too short.\n *\n * [IEEE2007] and [IEEE2018] Section 5.1:\n * - The data unit size shall be at least 128 bits.\n * - The number of 128-bit blocks should not exceed 2^20.\n *\/\ntype constraint ValidLength n = (n \/^ C::BlockSize <= 2^^20, n >= C::BlockSize, fin n)\n\n\/**\n * 5.1 Computing initial tweak from a data unit number.\n *\n * The initialization vector is defined to be a little-endian, zero-padded\n * representation of the data unit sequence number.\n *\n * Technically, per 5.1 the tweak is a non-negative integer.\n * When it is encrypted, it is converted to a little-endian byte array.\n * It must be the correct block size for AES encryption\/decryption, hence,\n * the padding.\n *\n * Per section 5.3.1, the tweak is a 128 bit value.\n *\n * References:\n *   [IEEE2007] Section 5.1, 5.3.1\n *   [IEEE2018] Section 5.1, 5.3.1\n *\/\ndataUnitSeqNoToIV : {n} (n <= 128) => [n] -> [128]\ndataUnitSeqNoToIV S = flipEndian (zext S)\n\n\/**\n * Example found in 5.1\n *\n * ```repl\n * :prove dataUnitSeqNoExample\n * ```\n *\/\nproperty dataUnitSeqNoExample = dataUnitSeqNoToIV 0x123456789a == 0x9a785634120000000000000000000000\n\n\/**\n * 5.2 Multiplication by a primitive element \u0251\n *\n *  The next tweak value is computed by performing a GF128 multiplication of\n *  \u03b1 modulo an irreducible polynomial. This arithmetic is defined to be\n *  performed using a little-endian byte order.\n *\n * This is a single iteration of the formula in Section 5.2.\n *\/\nmultAlphaLE : [128] -> [128]\nmultAlphaLE x = flipEndian (multAlpha (flipEndian x))\n  where\n    multAlpha p = pmod (pmult p alpha) irreducible\n\n\/**\n * The IEEE standard `\u03b1` to be the polynomial `x` in GF(2^128).\n * This is a primitive polynomial in this field, which means taking\n * powers of `\u03b1` generate all non-zero elements of the field.\n *\n * References:\n *  [IEEE2007] Section 4.2\n *  [IEEE2018] Section 4.2\n *\/\nalpha : [2]\nalpha = <| x |>\n\n\/**\n * Irreducible polynomial defining GF(2^128).\n *\n * References:\n *  [IEEE2007] Section 4.2\n *  [IEEE2018] Section 4.2\n *\/\nirreducible : [129]\nirreducible = <| x^^128 + x^^7 + x^^2 + x + 1 |>\n\n\/**\n * Generates an infinite stream of tweak blocks to be used in encryption and\n * decryption given an initialization vector. This can be thought of as\n * multiplication by successive powers of \u03b1, starting with the zeroth power,\n * with an initial value of the encryption of the first tweak.\n *\n * Each element of the resulting stream at index `j` has the value\n * `AES-enc(Key\u2082, i) \u2297 \u03b1^j`\n * (using the notation from [IEEE2007]).\n *\n * Here, the tweak has already been converted to a 128 bit value,\n * per Section 5.3.1 of the IEEE standards.\n *\n * The iteration is defined in [IEEE2007] Section 5.2.\n * The initial value is defined in [IEEE2007] Section 5.3.1, Step 1.\n *\/\ngenerateTweaks : [C::KeySize] -> [128] -> [inf][128]\ngenerateTweaks K2 i = iterate multAlphaLE (C::encrypt K2 i)\n\n\/**\n * 5.3.1 encryption of a single 128-bit block\n *\/\nencryptBlock : [C::KeySize] -> [128] -> [128] -> [128]\nencryptBlock K T P = C\n  where\n    \/\/ `T` is computed externally using the\n    \/\/ `generateTweaks` function in this implementation.\n    PP = T ^ P     CC = C::encrypt K PP     C  = CC ^ T \/**\n *  5.3.2 encryption of a data unit.\n *\n * Here, the sequence number `j` is implicit, and\n * is handled by `generateTweaks`.\n *\n * This implementation separates out the case where the plaintext is a\n * multiple of the blocksize.\n *\n *\/\nencrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> [n]\nencrypt (K1 # K2) i P\n  | 0 == n % 128 =>\n    join\n      [ encryptBlock K1 T blk\n      | T <- generateTweaks K2 i\n      | blk <- split`{n \/ 128} P ]\n  | otherwise => C\n    where\n      \/\/ Number of full blocks of plaintext\n      \/\/ Section 5.3.2 calls `M` `m`.\n      type M = n \/ 128\n\n      \/\/ Generate `M + 1` tweaks.\n      \/\/ If `Pm`, the final block, is empty,\n      \/\/ we will not need this tweak.\n      T_0_m1 # [Tm1, Tm] = take`{M + 1} (generateTweaks K2 i)\n\n      \/\/ Partition `P` into `M + 1` blocks.\n      \/\/ The first `m` blocks are all 128 bits long.\n      \/\/ The final block, `Pm`, is between `1` and `127` bits long.\n      P_0_m2 # Pm1 # Pm = P\n\n      \/\/ Step 1.\n      C_0_m2 = join [encryptBlock K1 T blk | T <- T_0_m1 | blk <- split`{M - 1} P_0_m2]\n\n      \/\/ Step 4a.\n      CC = encryptBlock K1 Tm1 Pm1\n\n      \/\/ Step 4b - 4c.\n      Cm # CP = CC\n\n      \/\/ Step 4d.\n      PP = Pm # CP\n\n      \/\/ Step 4e.\n      Cm1 = encryptBlock K1 Tm PP\n\n      \/\/ Step 5.\n      C = C_0_m2 # Cm1 # Cm\n\n\/**\n * Convenience type-constraint that is always satisified.\n * The name is inspired by the Haskell `otherwise` guard.\n *\/\ntype constraint otherwise = ()\n\n\/**\n * 5.4.1 decryption of a single 128-bit block\n *\/\ndecryptBlock : [C::KeySize] -> [128] -> [128] -> [128]\ndecryptBlock K T C = P\n  where\n    \/\/ Like `encryptBlock`, `T` is computed externally to\n    \/\/ this procedure in this implementation.\n    CC = C ^ T     PP = C::decrypt K CC     P = PP ^ T \/**\n * 5.4.2 decryption of a data unit\n *\/\ndecrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> [n]\ndecrypt (K1 # K2) i C\n  | 0 == n % 128 =>\n    join\n      [ decryptBlock K1 T blk\n      | T <- generateTweaks K2 i\n      | blk <- split`{n \/ 128} C ]\n  | otherwise => P\n    where\n      \/\/ Number of full blocks of ciphertext\n      type M = n \/ 128\n\n      \/\/ Generate tweaks.\n      T_0_m2 # [Tm1, Tm] = take`{M + 1} (generateTweaks K2 i)\n\n      \/\/ Partition the ciphertext into `M` full blocks and a partial final block.\n      C_0_m2 # Cm1 # Cm = C\n\n      \/\/ Step 1.\n      P_0_m2 = join [decryptBlock K1 T blk | T <- T_0_m2 | blk <- split`{M - 1} C_0_m2]\n\n      \/\/ Steps 4d - 4f.\n      Pm # CP = decryptBlock K1 Tm Cm1\n\n      \/\/ Step 4g.\n      CC = Cm # CP\n\n      \/\/ Step 4h.\n      Pm1 = decryptBlock K1 Tm1 (Cm # CP)\n\n      \/\/ Step 5.\n      P = P_0_m2 # Pm1 # Pm\n\n\n\/**\n * Decryption inverts encryption.\n * This is a fundamental correctness property.\n *\n * ```repl\n * :check decryptInvertsEncrypt `{192}\n * ```\n *\/\ndecryptInvertsEncrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> Bool\nproperty decryptInvertsEncrypt K i P = decrypt K i (encrypt K i P) == P\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the cfbTDesEnc and cfbTDesDec functions for Triple DES in CFB mode are correct. Include properties that check the invertibility of encryption and decryption (i.e., decrypting an encrypted plaintext returns the original plaintext) and that the implementation matches the provided test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::TDES_CFB where\n\nimport Primitive::Symmetric::Cipher::Block::TripleDES (encrypt)\n\n\/\/ Test vectors from https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Standards-and-Guidelines\/documents\/examples\/TDES_CFB.pdf\n\ntype iv = [64]\ntype block = [64]\n\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncfbTDesEnc : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncfbTDesEnc k1 k2 k3 iv ps = cs\n    where\n        ks = [ k1, k2, k3 ]\n        cs = [ (encrypt ks c') ^ p | p <- ps | c' <- [iv] # cs ]\n\ncfbTDesDec : {n} (fin n) => k1 -> k1 -> k3 -> iv -> [n]block -> [n]block\ncfbTDesDec k1 k2 k3 iv cts = pts\n    where\n        ks  = [ k1, k2, k3 ]\n        pts = [ (encrypt ks fb) ^ ct | ct <- cts | fb <- [iv] # cts ]\n\ncfbTDESEncryptDecryptInverts : k1 -> k2 -> k3 -> iv -> [3]block -> Bit\nproperty cfbTDESEncryptDecryptInverts k1 k2 k3 iv pt = pt == pt'\n    where\n        ct = cfbTDesEnc k1 k2 k3 iv pt\n        pt' = cfbTDesDec k1 k2 k3 iv ct\n\n\/\/ Number of blocks := 4\n\ntestKey = { k1=0x0123456789ABCDEF\n          , k2=0x23456789ABCDEF01\n          , k3=0x456789ABCDEF0123\n          , iv=0xF69F2445DF4F9B17\n          }\ntestPt = [0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]\ntestCt = [0x078BB74E59CE7ED6, 0x7666DE9CF95EAF3F, 0xE9ED6BB460F45152, 0x8A5F9FE4ED710918]\n\nproperty testsPass = ct == testCt\n                  \/\\ pt == testPt\n    where\n        ct = cfbTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv testPt\n        pt = cfbTDesDec testKey.k1 testKey.k2 testKey.k3 testKey.iv testCt\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AESKeyWrap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the authenticated encryption and decryption functions for AES key wrap (KW_AE and KW_AD) and AES key wrap with padding (KWP_AE and KWP_AD) are inverses of each other, ensuring correctness of the key wrapping and unwrapping algorithms as specified in NIST SP-800-38F."},{"role":"assistant","content":"```cryptol\n\/**\n * This specification describes algorithms that are approved for\n * \"key wrapping:\" protecting the confidentiality and integrity of\n * cryptographic keys.\n *\n * These modes of operation are approved to be used to protect both\n * cryptographic keys and general data.\n *\n * This specification is based on [SP-800-38F]. The schemes are\n * essentially equivalent to [RFC-3394] and [RFC-5649], but use\n * different naming and have some additional restrictions. See\n * [SP-800-38F], Appendix B.1.\n *\n * This executable specification has some minor differences relative to\n * the NIST specification [SP-800-38F].\n * - [SP-800-38F] allows implementations of the authenticated-encryption and\n *   authenticated-decryption functions to further restrict the lengths of\n *   the plaintext and ciphertext (Section 8). This executable specification\n *   requires exactly the maximum allowable lengths.\n * - [SP-800-38F] also defines a key wrap method based on a different\n *   block cipher, TDEA. This executable specification does not include\n *   those algorithms.\n * - This executable specification adds an additional input to the KWP-AD\n *   function. See the notes on that algorithm.\n * - In [SP-800-38F], all the functions (`W`, `W^{-1}`, `KW-AE`, `KW-AD`,\n *   `KWP-AE`, `KWP-AD`) take the keyed cipher functions (`CIPH_K` and\n *   `CIPH_K^{-1}`) as prerequisites, rather than explicitly passing the\n *   cipher function and key as parameters. This executable specification\n *   takes the key as an explicit parameter.\n *\n * References:\n * [SP-800-38F]: Morris Dworkin. Recommendations for Block Cipher Modes of\n *     Operation: Methods for Key Wrapping. (National Institute of Standards\n *     and Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST\n *     SP 800-38F. December 2012.\n *     @see https:\/\/doi.org\/10.6028\/NIST.SP.800-38F\n *\n * [RFC-3394]: J. Schaad, R. Housley. Advanced Encryption Standard (AES) Key\n *     Wrap Algorithm. Internet Request for Comments (RFC) 3394. September\n *     2002.\n *     @see https:\/\/datatracker.ietf.org\/doc\/rfc3394\n *\n * [RFC-5649]: R. Housley, M. Dworkin. Advanced Encryption Standard (AES) Key\n *     Wrap with Padding Algorithm. Internet Request for Comments (RFC) 5649.\n *     August 2009.\n *     @see https:\/\/datatracker.ietf.org\/doc\/rfc5649\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::AESKeyWrap where\n\n\/*\n * This algorithm is only approved for instantiation with AES.\n * [SP-800-38F] Section 3.1.\n *\/\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\ninterface constraint (C::KeySize >= 64)\ninterface constraint (C::BlockSize == 128)\n\n\/**\n * A byte.\n * [SP-800-38F] Section 4.1.\n *\/\ntype Octet = 8\n\n\/**\n * Given a block cipher `C`, a bit string whose length is half of the block\n * size.\n * [SP-800-38F] Section 4.1.\n *\n * Note: the term \"`n` semiblocks\" can mean a bit string that\n * can be represented as `n` semiblocks (`[n * Semiblock]`) or a semiblock\n * string of length `n` (`[n][Semiblock]`). [SP-800-38F] Section 5.2.\n *\/\ntype Semiblock = C::BlockSize \/ 2\n\n\/**\n * The 64-bit default ICV (integrity check value) for AES key wrap (KW).\n * [SP-800-38F] Section 4.3.\n *\/\nICV1 = 0xA6A6A6A6A6A6A6A6\n\n\/**\n * The 32-bit default ICV (integrity check value) for AES key wrap with\n * padding (KWP).\n * [SP-800-38F] Section 4.3.\n *\/\nICV2 = 0xA65959A6\n\n\/**\n * The output of the cipher function of the block cipher under the key `K`\n * applied to the block `X`.\n * [SP-800-38F] Section 4.4.\n *\/\nCIPHK K X = C::encrypt K X\n\n\/**\n * The output of the inverse of the cipher function of the block cipher under\n * the key `K` applied to the block `X`.\n * [SP-800-38F] Section 4.4.\n *\/\nCIPHInvK K X = C::decrypt K X\n\n\/**\n * The integer for which the bit string passed as a parameter is the binary\n * representation.\n * [SP-800-38F] Section 4.4.\n *\/\nint = toInteger\n\n\/**\n * The bit length of the bit string `_X`.\n * [SP-800-38F] Section 4.4.\n *\n * Note: This demotes the Cryptol type to a value. In practice, we use the\n * type representation of the value (e.g. using `n` directly, rather than\n * calling this function). See `KWP_AE`, below.\n *\/\nlen : {n} (fin n) => [n] -> Integer\nlen _X = `n\n\n\/**\n * Get the `s` right-most bits of the input.\n * [SP-800-38F] Section 4.4.\n *\/\nLSB : {s, n} (fin s, fin n, n >= s) => [n] -> [s]\nLSB = drop`{n - s}\n\n\/**\n * Get the `s` left-most bits of the input.\n * [SP-800-38F] Section 4.4.\n *\/\nMSB : {s, n} (fin s, fin n, n >= s) => [n] -> [s]\nMSB = take`{s}\n\n\/**\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove hexRepresentation\n * ```\n *\/\nproperty hexRepresentation = 0xA659 == 0b1010011001011001\n\n\/**\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove zeroRepresentation\n * ```\n *\/\nproperty zeroRepresentation = (zero : [8]) == 0b00000000\n\n\/**\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove concatRepresentation\n * ```\n *\/\nproperty concatRepresentation = 0b001 # 0b10111 == 0b00110111\n\n\/**\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove xorRepresentation\n * ```\n *\/\nproperty xorRepresentation = 0b10011 ^ 0b10101 == 0b00110\n\n\/**\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove lenRepresentation\n * ```\n *\/\nproperty lenRepresentation = len 0b00010 == 5\n\n\/**\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove signficanceWorks\n * ```\n *\/\nproperty signficanceWorks = lsb && msb where\n    X = 0b111011010\n    lsb = LSB`{3} X == 0b010\n    msb = MSB`{4} X == 0b1110\n\n\/**\n * The instances of the `[x]_s` notation in the spec are all used to convert\n * base-10 literal values into bit strings. We can handle these instances using\n * explicit typing in Cryptol. This property shows the expected notation and\n * demonstrates that the endianness of this conversion aligns with the\n * requirement in the specification.\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove integerToString\n * ```\n *\/\nproperty integerToString = (39 == 0b00100111) && ((39 : [8]) == 0b00100111)\n\n\/**\n * [SP-800-38F] Section 4.5.\n * ```repl\n * :prove stringToInteger\n * ```\n *\/\nproperty stringToInteger = int 0b00011010 == 26\n\n\/**\n * The plaintext for AES key wrap (KW) shall be a semiblock string with fewer\n * than 2^54 semiblocks.\n * Note: the Cryptol expression `width n < X` is equivalent to `n < 2^^X - 1`.\n * [SP-800-38F] Section 5.3.1 and Table 1.\n *\/\ntype constraint KW_Plaintext n = (2 <= n, width n <= 54)\n\n\/**\n * The ciphertext for AES key wrap (KW) is a semiblock string with length one\n * semiblock longer than the corresponding ciphertext.\n * [SP-800-38F] Section 5.3.1 and Table 1.\n *\/\ntype constraint KW_Ciphertext n = (3 <= n, n <= 2^^54)\n\n\/**\n * The plaintext for AES key wrap with padding (KWP) shall be an octet string\n * with fewer than 2^32 octets.\n * Note: the Cryptol expression `width n < X` is equivalent to `n < 2^^X - 1`.\n * [SP-800-38F] Section 5.3.1 and Table 1.\n *\/\ntype constraint KWP_Plaintext n = (1 <= n, width n <= 32)\n\n\/**\n * The ciphertext for AES key wrap with padding (KWP) is a semiblock string\n * with length one semiblock longer than the corresponding ciphertext.\n * [SP-800-38F] Section 5.3.1 and Table 1.\n *\/\ntype constraint KWP_Ciphertext n = (2 <= n, n <= 2^^29)\n\n\/**\n * Wrapping function for the encryption functions in AES key wrap and AES key\n * wrap with padding.\n * [SP-800-38F] Section 6.1, Algorithm 1.\n *\n * There is an additional explicit constraint here that the variable\n * `s = 6(n - 1)` must fit into a semiblock (64 bits). This is implied by the\n * conversion in step 2a: `[t]_64` gives the binary representation of `t` in\n * 64 bits; it requires that `t` is less than `2^64`. The maximum value of `t`\n * is `s`. This constraint will always be satisfied in an approved\n * instantiation due to the plaintext length restrictions. See:\n * - the definition of `[]` in Section 4.4;\n * - Plaintext length descriptions in Section 5.3.1; and\n * - Discussion on plaintext length descriptions in Appendix A.4.\n *\n * This function is not approved for use independently of the KW_AE and KWP_AE\n * functions. [SP-800-38F] Section 8.\n *\/\nW : {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n][Semiblock] -> [n * Semiblock]\nW K S = C where\n    \/\/ Step 1. Note that the input string is 1-indexed in the spec and\n    \/\/ 0-indexed here.\n    type s = 6 * (n - 1)\n    A0 = S@0\n    R0 = drop`{1} S\n\n    \/\/ Step 2.\n    \/\/ `At1` corresponds to `A^{t-1}` in the text. Likewise for `Rt1`.\n    \/\/ In the spec, `R^t` is indexed from 2 to `n`. Here, it is indexed\n    \/\/ from 0 to `n - 2`.\n    update_variables : ([Semiblock], [n-1][Semiblock]) -> [Semiblock]\n        -> ([Semiblock], [n-1][Semiblock])\n    update_variables (At1, Rt1) t = (At, Rt) where\n        At = MSB`{64} (CIPHK K (At1 # Rt1@0)) ^ t\n        Rnt = LSB`{64} (CIPHK K (At1 # Rt1@0))\n        Rt = drop`{1} Rt1 # [Rnt]\n\n    (As, Rs) = foldl update_variables (A0, R0) [1..s]\n\n    \/\/ Step 3.\n    C1 = As\n    Cis = Rs\n    C = C1 # (join Cis)\n\n\/**\n * Unwrapping function for the decryption functions in AES key wrap and AES key\n * wrap with padding. This is denoted `W^{-1}` in the spec.\n * [SP-800-38F] Section 6.1, Algorithm 2.\n *\n * There is an additional explicit constraint here that the variable `s` must\n * fit into a semiblock. See note on `W`.\n *\n * This function is not approved for use independently of the KW_AD and KWP_AD\n * functions. [SP-800-38F] Section 8.\n *\/\nWInv : {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n][Semiblock] -> [n * Semiblock]\nWInv K C = S where\n    \/\/ Step 1. Note that the input string is 1-indexed in the spec and\n    \/\/ 0-indexed here.\n    type s = 6 * (n - 1)\n    As = C@0\n    Rs = drop`{1} C\n\n    \/\/ Step 2.\n    \/\/ `At1` corresponds to `A^{t-1}` in the text. Likewise for `Rt1`.\n    \/\/ In the spec, `R^t` is indexed from 2 to `n`. Here, it is indexed\n    \/\/ from 0 to `n - 2`.\n    update_variables : ([Semiblock], [n-1][Semiblock]) -> [Semiblock]\n        -> ([Semiblock], [n-1][Semiblock])\n    update_variables (At, Rt) t = (At1, Rt1) where\n        At1 = MSB`{64} (CIPHInvK K ((At ^ t) # Rt@`(n-2)))\n        R2t1 = LSB`{64} (CIPHInvK K ((At ^ t) # Rt@`(n-2)))\n        Rt1 = [R2t1] # take`{n-2} Rt\n\n    (A0, R0) = foldl update_variables (As, Rs) [s, s-1..1]\n\n    \/\/ Step 3.\n    S1 = A0\n    Sis = R0\n    S = S1 # (join Sis)\n\n\/**\n * The unwrapping function `WInv` must be the inverse of the wrapping function\n * `W`.\n * [SP-800-38F] Section 5.2.\n * ```repl\n * :check wrappingInverts`{3}\n * :check wrappingInverts`{6}\n * ```\n *\/\nwrappingInverts :\n    {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n * Semiblock] -> Bit\nproperty wrappingInverts K S = S == S' where\n    C = W K (split S)\n    S' = WInv K (split C)\n\n\/**\n * Authenticated encryption function for AES key wrap.\n * [SP-800-38F] Section 6.2, Algorithm 3.\n *\/\nKW_AE : {n} (KW_Plaintext n)\n    => [C::KeySize] -> [n * Semiblock] -> [(n + 1) * Semiblock]\nKW_AE K P = C where\n    S = ICV1 # P\n    C = W K (split S)\n\n\/**\n * Authenticated decryption function for AES key wrap.\n * [SP-800-38F] Section 6.2, Algorithm 4.\n *\/\nKW_AD : {n} (KW_Ciphertext n)\n    => [C::KeySize] -> [n * Semiblock] -> Option [(n - 1) * Semiblock]\nKW_AD K C = if MSB`{64} S != ICV1 then None\n    else Some (LSB`{64 * (n - 1)} S)\n    where\n        S = WInv K (split C)\n\n\/**\n * Authenticated decryption must be the inverse of authenticated encryption for\n * AES key wrap.\n * ```repl\n * :check keyWrapInverts`{3}\n * ```\n *\/\nkeyWrapInverts : {n} (KW_Plaintext n) => [C::KeySize] -> [n * Semiblock] -> Bit\nproperty keyWrapInverts K P = inverts where\n    C = KW_AE K P\n    inverts = case (KW_AD K C) of\n        Some maybeP -> maybeP == P\n        None -> False\n\n\/**\n * The authenticated encryption function for AES key wrap with padding (KWP).\n * [SP-800-38F] Section 6.3, Algorithm 5.\n *\/\nKWP_AE : {n} (KWP_Plaintext n, KWP_Ciphertext (n \/^ 8 + 1))\n    => [C::KeySize] -> [n * Octet] -> [(n \/^ 8 + 1) * Semiblock]\nKWP_AE K P = C where\n    \/\/ The type signature checks the validity of the plaintext `P` against `n`:\n    \/\/ the number of octets. `len(P)` in the spec is the number of _bits_.\n    type lenP = 8 * n\n\n    \/\/ Step 2.\n    type padlen = 8 * (lenP \/^ 64) - (lenP \/ 8)\n\n    \/\/ Step 3.\n    PAD = zero : [8 * padlen]\n\n        S = ICV2 # (`(lenP \/ 8) : [32]) # P # PAD\n\n    \/\/ Step 5.\n    C = KWP_AE_Step5`{n} K S\n\n\/**\n * This is step 5 of the KWP_AE algorithm.\n * [SP-800-38F] Section 6.3, Algorithm 5, Step 5.\n *\n * It's separated into its own function to use the numeric constraint guard,\n * which is only permitted in a top-level function.\n *\/\nKWP_AE_Step5: {n} (KWP_Plaintext n)\n    => [C::KeySize] -> [(n \/^ 8 + 1) * Semiblock] -> [(n \/^ 8 + 1) * Semiblock]\nKWP_AE_Step5 K S\n    | 8 * n <= 64 => CIPHK K S\n    | 8 * n > 64 => W K (split S)\n\n\/**\n * The authenticated decryption function for AES key wrap with padding (KWP).\n * [SP-800-38F] Section 6.3, Algorithm 6.\n *\n * This algorithm differs from the specification in that it requires the output\n * length (`m`, the length of the unpadded plaintext in octets) to be specified\n * at the top level; the specification determines the length dynamically, based\n * on the ciphertext.\n * The additional type parameter is necessary in Cryptol to allow stripping the\n * padding off the plaintext, but it introduces two concrete changes:\n *\n * 1. There is an additional type constraint, which restricts the ciphertext and\n *    plaintext lengths to be within the range of allowable padding of each\n *    other.\n *\n * 2. There are two additional failure checks, to make sure that `m` is correct\n *    with respect to the values (`Plen`, `padlen`) derived from the ciphertext:\n *    - `Plen` must be the same as `m`.\n *    - `padlen == m %^ 8`. `padlen` is the number of octets of padding needed\n *      to fill out the plaintext to the nearest semiblock (8 bytes) and `m` is\n *      the number of octets in the plaintext. We use the ceiling modulus to\n *      compute the expected amount of padding for `m`.\n *\n * Thanks to Sean Weaver for assistance with formulating this definition.\n *\/\nKWP_AD : {m, n} (KWP_Ciphertext n, KWP_Plaintext m, n == 1 + m \/^ 8)\n    => [C::KeySize] -> [n * Semiblock] -> Option [m * Octet]\nKWP_AD K C =\n    if (ICV2 != MSB`{32} S)                         || (padlen < 0)                     \/\/ Step 7.\n        || (padlen > 7)                     \/\/ Step 7.\n        || (zero   != LSB`{8 * m %^ 64} S)  \/\/ Step 8.\n        || (Plen   != `m)                   \/\/ Cryptol-specific.\n        || (padlen != `(m %^ 8))            \/\/ Cryptol-specific.\n    then None\n    else Some P\n    where\n        S = KWP_AD_Step3 K C\n\n        \/\/ Step 5 - 6.\n        Plen = int (LSB`{32} (MSB`{64} S))\n        padlen = 8 * (`n - 1) - Plen\n\n        \/\/ Step 9. The conditional above restricts `m = Plen`.\n        P = MSB`{8 * m} (LSB`{64 * (n - 1)} S)\n\n\/**\n * This is step 3 of the KWP_AD algorithm.\n * [SP-800-38F] Section 6.3, Algorithm 6.\n *\n * It is separated into its own function to support the numeric constraint\n * guard, which is only permitted in a top-level function.\n *\/\nKWP_AD_Step3 : {n} (KWP_Ciphertext n)\n    => [C::KeySize] -> [n * Semiblock] -> [n * 64]\nKWP_AD_Step3 K C\n    | n == 2 => CIPHInvK K C\n    | n > 2 => WInv K (split C)\n\n\/**\n * Authenticated decryption must be the inverse of authenticated encryption for\n * AES key wrap with padding.\n *\n * The lengths below are chosen to check various amounts of padding.\n * ```repl\n * :check keyWrapInverts`{1}\n * :check keyWrapInverts`{3}\n * :check keyWrapInverts`{7}\n * :check keyWrapInverts`{8}\n * ```\n *\/\nkeyWrapPaddedInverts : {n} (KWP_Ciphertext (n \/^ 8 + 1), KWP_Plaintext n)\n    => [C::KeySize] -> [n * Octet] -> Bit\nproperty keyWrapPaddedInverts K P = inverts where\n    C = KWP_AE K P\n    inverts = case (KWP_AD K C) of\n        Some maybeP -> maybeP == P\n        None -> False\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the CFB mode implementation in the given module. Specifically, write properties that check that decrypting the ciphertext produced by encrypting any plaintext with the same key and IV returns the original plaintext, for various valid parameters s and n. Include properties suitable for Cryptol's :check command to validate the encryptCorrect property for different block sizes and plaintext lengths."},{"role":"assistant","content":"```cryptol\n\/*\n * Cipher Feedback (CFB) mode of operation, as defined in [NIST-SP-800-38A],\n * Section 6.3.\n *\n * CFB mode utilizes an integer parameter, denoted by `s`, such that\n * `1 \u2264 s \u2264 BlockSize`. The parameter `s` specifies the plaintext \/ ciphertext\n * block length; that is, each plaintext \/ ciphertext block is `s` bits long.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: To ensure confidentiality, CFB mode requires that the\n * initialization vector (IV) must be \"unpredictable\". This specification does\n * not verify IV generation; implementors must manually verify that their IVs\n * are chosen appropriately.\n *\n * For guidelines on generating IVs, see Appendix C of [NIST-SP-800-38A].\n * For information on the importance of protecting IV integrity, see Appendix D\n * of [NIST-SP-800-38A].\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Alex J. Malozemoff <amaloz@galois.com>\n * www.cryptol.net\n *\n * Sources:\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n *     Modes of Operation: Methods and Techniques. NIST Special Publication\n *     800-38A. December 2001.\n *     @see https:\/\/doi.org\/10.6028\/NIST.SP.800-38A\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Modes::CFB where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\n\/**\n * CFB encryption: [NIST-SP-800-38A] Section 6.3.\n *\n * Parameters: key, initialization vector, plaintext\n *\n * NIST Specification (Section 6.3):\n *\n *   I_1 = IV;\n *   I_j = LSB_{b-s}(I_{j-1}) | C_{j-1}  for j = 2 ... n;\n *   O_j = CIPH_K(I_j)                   for j = 1 ... n;\n *   C_j = P_j \u2295 MSB_s(O_j)             for j = 1 ... n.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: To ensure confidentiality, CFB mode requires that the\n * initialization vector (IV) must be \"unpredictable\". This specification does\n * not verify IV generation; implementors must manually verify that their IVs\n * are chosen appropriately.\n *\/\nencrypt : {s, n} (fin s, fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> [n][s]\nencrypt K IV Ps = Cs\n    where\n        CIPH_K = C::encrypt K\n        Is = [ (drop`{s} I_j_1) # C_j_1\n             | I_j_1 <- [IV] # Is\n             | C_j_1 <- Cs\n             ]\n        Cs = [ P_j ^ (take`{s} (CIPH_K I_j))\n             | P_j <- Ps\n             | I_j <- [IV] # Is\n             ]\n\n\/**\n * CFB decryption: [NIST-SP-800-38A] Section 6.3.\n *\n * Parameters: key, initialization vector, ciphertext\n *\n * NIST Specification (Section 6.3):\n *\n *  I_1 = IV;\n *  I_j = LSB_{b-s}(I_{j-1}) | C_{j-1}  for j = 2 ... n;\n *  O_j = CIPH_K(I_j)                   for j = 1 ... n;\n *  P_j = C_j \u2295 MSB_s(O_j)             for j = 1 ... n.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: To ensure confidentiality, CFB mode requires that the\n * initialization vector (IV) must be \"unpredictable\". This specification does\n * not verify IV generation; implementors must manually verify that their IVs\n * are chosen appropriately.\n *\/\ndecrypt : {s, n} (fin s, fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> [n][s]\ndecrypt K IV Cs = Ps\n    where\n        CIPH_K = C::encrypt K\n        Is = [ (drop`{s} I_j_1) # C_j_1\n             | I_j_1 <- [IV] # Is\n             | C_j_1 <- Cs\n             ]\n        Ps = [ C_j ^ (take`{s} (CIPH_K I_j))\n             | C_j <- Cs\n             | I_j <- [IV] # Is\n             ]\n\n\/**\n * Decryption must be the inverse of encryption.\n * With high probability, this will be incredibly slow to prove.\n * ```repl\n * :check encryptCorrect`{s=1, n=5}\n * :check encryptCorrect`{s=8, n=5}\n * :check encryptCorrect`{s=128, n=5}\n * ```\n *\/\nencryptCorrect : {s, n} (fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> Bool\nproperty encryptCorrect K IV Ps = (decrypt K IV (encrypt K IV Ps)) == Ps\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the Simon block cipher specification. Include properties that prove the equivalence between the two encryption implementations (`encrypt` and `encrypt'`), the equivalence between the two decryption implementations (`decrypt` and `decrypt'`), and that decryption inverts encryption. Additionally, write properties to verify the invertibility of the round functions (`R` and `R_Inv`), the injectivity of the key schedule, and the equivalence of the two key schedule formulations (`keySchedule` and `keySchedule'`). Also include properties to check the equivalence of the informal and formal definitions of the sequences `u`, `v`, and `w`. Ensure all properties are suitable for Cryptol's `:check` or `:prove` commands."},{"role":"assistant","content":"```cryptol\n\/**\n *\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n * @author David Lazar\n * www.cryptol.net\n *\n * This provides the basic Simon block cipher, abstracted over the key length,\n * plaintext size, number of rounds, and constant sequence.\n *\n * Simon is presented in two ways in the reference documentation.\n * Firstly, it is presented as a mathematical function derived from a root key.\n * Secondly, it is presented as an imperative algorithm.\n * This specification prefers the former presentation, but encodes both.\n *\n * Test vectors for particular instances of this parameterized specification\n * are located in a bespoke test file.\n *\n * References\n * [SIMON]: Beaulieu, Shors, Smith, Treatman-Clark, Weeks, Wingers\n *   The Simon and Speck Families of Lightweight Block Ciphers\n *   19 June 2013\n *   @see https:\/\/eprint.iacr.org\/2013\/404.pdf\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Specification where\n\nparameter\n\n  \/*\n   * The Simon block cipher is parameterized by two integers `n` and `m`,\n   * a sequence `z_j`, and a number of rounds, `T`.\n   *\/\n\n  \/**\n   * `n` is the word length in bits.\n   * A Simon block is two words.\n   *\/\n  type n : #\n\n  \/**\n   * `m` is the number of `n`-bit words in a Simon key.\n   * `m` takes the value4 2, 3, or 4.\n   *\/\n  type m : #\n\n  \/**\n   * This type contraint satifies Cryptol's type checker, and\n   * admits all valid parameterizations of Simon. It does not\n   * exclude all invalid parameterizations of Simon.\n   *\/\n  type constraint (fin n, fin m, n >= 4, m >= 2, m <= 4)\n\n  \/**\n   * There are five possible constant sequences `z_j`.\n   *\/\n  type j : #\n  type constraint (j >= 0, j < 5)\n\n  \/**\n   * `T` is the number of rounds.\n   * `T` may take on the values specified in Table 3.1 of [SIMON].\n   *\/\n  type T : #\n\n  \/**\n   * This type constraint satifies Cryptol's type checker, but\n   * does not exclude invalid numbers of rounds.\n   *\/\n  type constraint (fin T, T > 4)\n\n\/**\n * The Simon encryption function.\n * Described in Section 3.1 of [SIMON].\n * Simon encryption is the composition of T round functions\n * derived from the key schedule applied to the plaintext.\n * Simon keys are length `m * n` bits for appropriate choices of `m` and `n`.\n * Simon plaintexts are length `2 * n` bits for appropriate choice of `n`.\n *\/\nencrypt : [m * n] -> [2 * n] -> [2 * n]\nencrypt key plaintext = ciphertext\n  where\n    Simon_k = composeMany Rks\n    \/\/ The Simon specification parses the key LSB first.\n    \/\/ Cryptol takes a MSB first convention, so the key is reversed.\n    Rks = map R (keySchedule (reverse (split key)))\n    ciphertext = join (Simon_k (split plaintext))\n\n\/**\n * The Simon decryption function. Simon decryption is the same as Simon\n * encryption from a structural point of view, except that the inverse\n * round function is used rather than the round function.\n *\/\ndecrypt : [m * n] -> [2 * n] -> [2 * n]\ndecrypt key ciphertext = plaintext\n  where\n    Simon_k = composeMany (reverse Rks)\n    \/\/ The Simon specification parses the key LSB first.\n    \/\/ Cryptol takes a MSB first convention, so the key is reversed.\n    Rks = map R_Inv (keySchedule (reverse (split key)))\n    plaintext = join (Simon_k (split ciphertext))\n\nprivate\n\n  \/**\n   * This property encodes the fact that Simon decryption is the inverse of\n   * Simon encryption.\n   *\n   * ```repl\n   * :check decryptInvertsEncrypt\n   * ```\n   *\/\n  property decryptInvertsEncrypt k pt = pt == decrypt k (encrypt k pt)\n\n  \/**\n   * Simon is described in psuedocode.\n   *\n   * Reference: [SIMON] Figure 3.3.\n   *\/\n  encrypt' : [m * n] -> [2 * n] -> [2 * n]\n  encrypt' key plaintext = join (rounds ! 0)\n    where\n      [x, y] = split plaintext\n      ks     = keySchedule' (reverse (split key))\n      \/\/ there are T round keys\n      \/\/ So, the following list comprehension runs over i = 0..T-1\n      rounds = [[x, y]] # [R k p | k <- ks | p <- rounds]\n\n  \/**\n   * Likewise, the decryption can be calculated in a more imperative fashion.\n   *\/\n  decrypt' : [m * n] -> [2 * n] -> [2 * n]\n  decrypt' key ciphertext = join (rounds ! 0)\n    where\n      [x, y] = split ciphertext\n      ks = keySchedule' (reverse (split key))\n      rounds = [[x, y]] # [R_Inv k ct | k <- (reverse ks) | ct <- rounds]\n\n  \/**\n   * The two formulations of encryption are functionally equiavalent.\n   *\n   * ```repl\n   * :check encryptsEquivalent\n   * ```\n   *\/\n  property encryptsEquivalent k p = encrypt k p == encrypt' k p\n\n  \/**\n   * The two formulations of decryption are functionally equiavalent.\n   *\n   * ```repl\n   * :check decryptsEquivalent\n   * ```\n   *\/\n  property decryptsEquivalent k p = decrypt k p == decrypt' k p\n\n  \/**\n   * Left circular shift by `i` bits.\n   * `i` is chosen over `j`, which the specification uses, to avoid shadowing.\n   * Although this is built-in, we choose the name `S`\n   * since this notation is used in Section 3.1 of [SIMON].\n   *\/\n  S : {i} (fin i) => [n] -> [n]\n  S x = x <<< `i\n\n  \/**\n   * Right circular shift by `i` bits.\n   * `i` is chosen over `j`, which the specification uses, to avoid shadowing.\n   * Although this is built-in, we choose the name `S_Inv`.\n   * This is chosen to avoid arithmetic strangeness with signed bitvectors.\n   *\/\n  S_Inv : {i} (fin i) => [n] -> [n]\n  S_Inv x = x >>> `i\n\n  \/**\n   * The specification uses the notation `S^(-i)` to notate\n   * right circular shift by `i` bits, the inverse of left\n   * circular shift. This property verifies that\n   * `S` is the inverse of `S_Inv`.\n   *\n   * ```repl\n   * :prove SInvertible `{8}\n   * :prove SInvertible `{3}\n   * :prove SInvertible `{2}\n   * :prove SInvertible `{1}\n   * ```\n   *\/\n  SInvertible : {i} (fin i) => [n] -> Bit\n  property SInvertible x = S_Inv `{i} (S `{i} x) == x\n\n  \/**\n   * The function `f` is a constituent function of the encryption and decryption\n   * round functions.\n   *\n   * Reference: [SIMON] Section 3.1.\n   *\/\n  f : [n] -> [n]\n  f x = (S `{1} x && S `{8} x) ^ S `{2} x\n\n  \/**\n   * The Simon (encryption) round function is defined in Section 3.1 of [SIMON].\n   * It is defined on `n`-bit words, which can be thought of as \"halves\" of\n   * the plaintext block being processed.\n   * The round function is parameterized by the choice of round key, `k`.\n   *\/\n  R : [n] -> [2][n] -> [2][n]\n  R k [x, y] = [y ^ f x ^ k, x]\n\n  \/**\n   * The Simon (decryption) round function is defined in Section 3.1 of [SIMON].\n   * It is defined on `n`-bit words, which can be thought of as \"halves\" of\n   * the ciphertext block being processed.\n   * The round function is parameterized by the choice of round key, `k`.\n   *\/\n  R_Inv : [n] -> [2][n] -> [2][n]\n  R_Inv k [x, y] = [y, x ^ f y ^ k]\n\n  \/**\n   * This property encodes the fact that `R_Inv` is the inverse of `R`\n   * for corresponding choices of round key.\n   *\n   * ```repl\n   * :prove RInvertible\n   * ```\n   *\/\n  property RInvertible k x = x == R_Inv k (R k x)\n\n  \/**\n   * `u` is a periodic sequence with period 31.\n   * `u` is used in the definition of the Simon key schedule, and\n   * is decribed in Section 3.2 of [SIMON].\n   *\/\n  u : [inf]\n  u = 0b1111101000100101011000011100110 # u\n\n  \/**\n   * `v` is a periodic sequence with period 31\n   * `v` is used in the definition of the Simon key schedule, and\n   * is decribed in Section 3.2 of [SIMON].\n   *\/\n  v : [inf]\n  v = 0b1000111011111001001100001011010 # v\n\n  \/**\n   * `w` is a periodic sequence with period 31\n   * `w` is used in the definition of the Simon key schedule, and\n   * is decribed in Section 3.2 of [SIMON].\n   *\/\n  w : [inf]\n  w = 0b1000010010110011111000110111010 # w\n\n  \/**\n   * `t` is a periodic sequence with period 2.\n   *\n   * Reference: [SIMON] Section 3.2.\n   *\/\n  t : [inf]\n  t = 0b01 # t\n\n  \/**\n   * The sequence `z0` is an alternative name of the sequence `u`.\n   *\n   * Reference: [SIMON] Section 3.2.\n   *\/\n  z0 = u\n\n  \/**\n   * The sequence `z1` is an alternative name of the sequence `v`.\n   *\n   * Reference: [SIMON] Section 3.2.\n   *\/\n  z1 = v\n\n  \/**\n   * The sequence `z2` is the bitwise XOR of `u` and `t`.\n   *\n   * Reference: [SIMON] Section 3.2.\n   *\/\n  z2 = u ^ t\n\n  \/**\n   * The sequence `z3` is the bitwise XOR of `v` and `t`.\n   *\n   * Reference: [SIMON] Section 3.2.\n   *\/\n  z3 = v ^ t\n\n  \/**\n   * The sequence `z4` is the bitwise XOR of `w` and `t`.\n   *\n   * Reference: [SIMON] Section 3.2.\n   *\/\n  z4 = w ^ t\n\n  \/**\n   * Convert an infinite sequence of bits into an infinite sequence of `n`-bit\n   * vectors, where the `i`th vector has the same value as the `i`th bit.\n   *\n   * This does not appear explicitly in [SIMON]. Cryptol only supports bitwise\n   * XOR between bit vectors of the same length, but the round key formulae in\n   * [SIMON] computes the XOR of an individual bit from an infinite sequence\n   * with an n-bit word. We apply this function to the relevant infinite\n   * sequences to support the XOR.\n   *\/\n  extend : [inf] -> [inf][n]\n  extend s = map (zext `{n}) (split `{inf, 1} s)\n\n  \/**\n   * The list of sequences `zj` with the zero-extension applied.\n   *\/\n  zjs = map extend [z0, z1, z2, z3, z4]\n\n  \/**\n   * The particular sequence `zj` of the instance.\n   * These indices are the same as [SIMON].\n   *\/\n  zj = zjs@`j\n\n  \/**\n   * `c` is a bitvector of length `n`.\n   * It's length is implied by the shift register diagrams\n   * in Figure 3.2 of [SIMON] and usage in the key schedule\n   * recursive formulae.\n   *\/\n  c : [n]\n  c = fromInteger (2 ^^ `n - 4)\n\n  \/**\n   * `IS_Inv` is a function defined for convenience of this specification.\n   * The recursive formulae defining the key schedule include a\n   * quantity that is bitwise XORed with a right shift of itself.\n   * This is notated distributively in the original specification.\n   *\/\n  IS_Inv : [n] -> [n]\n  IS_Inv x = x ^ S_Inv `{1} x\n\n  \/**\n   * The Simon key schedule is defined by recursively expanding\n   * the initial key material according to the formulae in Section 3.2\n   * of [SIMON]. There is a different formula depending on how many\n   * words, `m`, make up the key.\n   *\/\n  keySchedule : [m][n] -> [T][n]\n  keySchedule k0\n    | m == 2 => k where\n      k = k0 # [\n      c ^ zji ^ (k @ i) ^ IS_Inv (S_Inv `{3} (k @ (i+1)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n    | m == 3 => k where\n      k = k0 # [\n      c ^ zji ^ (k@i) ^ IS_Inv (S_Inv `{3} (k@(i+2)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n    | m == 4 => k where\n      k  = k0 # [\n      c ^ zji ^ (k@i) ^ IS_Inv (S_Inv `{3} (k@(i+3)) ^ (k@(i+1)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n\n  \/**\n   * The Simon key schedule is described in pseudo-code in [SIMON].\n   * This formulation might be preferred by some implementers. It is\n   * included here for documentary purposes, as well as for property checking.\n   *\/\n  keySchedule' : [m][n] -> [T][n]\n  keySchedule' k0 = k\n    where\n      k = k0 # [ ki where\n                  tmp0 = k @ (i - 1) >>> 3\n                  tmp1 = if `m == 4 then tmp0 ^ k @ (i - 3) else tmp0\n                  tmp2 = tmp1 ^ tmp1 >>> 1\n                  ki = ~ k @ (i - `m) ^ tmp2 ^ z ^ 3\n                  z = zj @ ((i - `m) % 62)\n            | i <- [m .. T - 1]\n            ]\n\n  \/**\n   * This property encodes the fact that the key schedule is injective.\n   * That is, different round keys are produced for every choice of key.\n   *\n   * ```repl\n   * :prove keyScheduleInjective\n   * ```\n   *\/\n  property keyScheduleInjective k p = k != p ==> keySchedule k != keySchedule p\n\n  \/**\n   * This property encodes the fact that the psuedocode formulation of the\n   * key schedule is functionally equivalent to formulaic definition.\n   *\n   * ```repl\n   * :check keySchedulesEquivalent\n   * ```\n   *\/\n  property keySchedulesEquivalent k = keySchedule k == keySchedule' k\n\n  \/**\n   * Composition of functions `g` and `h`\n   * specialized to functions from `(a -> a)`.\n   *\/\n  compose : {a} () => (a -> a) -> (a -> a) -> a -> a\n  compose g h = \\x -> h (g x)\n\n  \/**\n   * Composition of many functions from `(a -> a)`\n   *\/\n  composeMany : {nf, a} (fin n) => [nf](a -> a) -> a -> a\n  composeMany fcns\n    | nf == 0 => \\x -> x\n    | nf == 1 => fcns@0\n    | nf == 2 => compose (fcns@0) (fcns@1)\n    | nf > 2  => compose (fcns@0) (composeMany (drop `{1} fcns))\n\n\n  \/**\n   * Multiplication of a row vector by a matrix\n   * This is not defined in the Simon specification.\n   * We take the straightforward approach of treating\n   * this as a linear combination of a subset of the\n   * matrix rows depending on which bits of the row vector are set.\n   *\/\n  linearMap : {rows, cols} (fin rows, fin cols) =>\n    [rows][cols] -> [rows] -> [cols]\n  linearMap matrix vector = foldl (^) zero matrix'\n    where\n      matrix' = map (\\(i, vi) -> if i then vi else zero) (zip vector matrix)\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `u`\n   * if the initial fill `0b00001` is used.\n   *\/\n  U = [ 0b01000\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10001\n      ]\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `v`\n   * if the initial fill `0b00001` is used.\n   *\/\n  V = [ 0b01100\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10000\n      ]\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `w`\n   * if the initial fill `0b00001` is used.\n   *\/\n  W = [ 0b01000\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10000\n      ]\n\n  \/**\n   * A function that treats row vector - matrix multiplication\n   * as a shift register, generating the sequence of shift\n   * register outputs for a given initial fill.\n   *\/\n  seqn : [5][5] -> [inf]\n  seqn matrix = map (\\x -> x@4) steps\n    where\n      steps     = iterate (\\x -> linearMap matrix x) 0b00001\n\n  \/**\n   * A formal definition of the sequence `u`,\n   * given in Section 3.2 of [SIMON].\n   *\/\n  u' = seqn U\n\n  \/**\n   * A formal definition of the sequence `v`,\n   * given in Section 3.2 of [SIMON].\n   *\/\n  v' = seqn V\n\n  \/**\n   * A formal definition of the sequence `w`,\n   * given in Section 3.2 of [SIMON].\n   *\/\n  w' = seqn W\n\n  \/**\n   * A property encoding that the formal and informal definitions of `u`\n   * are equivalent.\n   *\n   * ```repl\n   * :check uDefinitionEquivalence\n   * ```\n   *\/\n  property uDefinitionEquivalence = take `{100} u == take `{100} u'\n\n  \/**\n   * A property encoding that the formal and informal definitions of `v`\n   * are equivalent.\n   *\n   * ```repl\n   * :check vDefinitionEquivalence\n   * ```\n   *\/\n  property vDefinitionEquivalence = take `{100} v == take `{100} v'\n\n  \/**\n   * A property encoding that the formal and informal definitions of `w`\n   * are equivalent.\n   *\n   * ```repl\n   * :check wDefinitionEquivalence\n   * ```\n   *\/\n  property wDefinitionEquivalence = take `{100} w == take `{100} w'\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the Speck block cipher specification. Include properties that prove the invertibility of the encryption and decryption functions, the invertibility of the round function, the equivalence of alternative round function formulations, the injectivity of the key schedule, and the equivalence of different key schedule formulations. Use :prove commands where appropriate to enable automated checking of these properties."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n *\n * This module provides a Cryptol specification of the Speck block cipher.\n * Speck is abstracted over the key size, the block size, the number of\n * rounds, and two rotation constants.\n *\n * @author John Christensen <jchristensen@galois.com>\n * @author David Lazar\n *\n * References\n * [SPECK]: Beaulieu, Shors, Smith, Treatman-Clark, Weeks, Wingers\n *          The Simon and Speck Families of Lightweight Block Ciphers\n *          19 June 2013\n * @see https:\/\/eprint.iacr.org\/2013\/404.pdf\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\nimport Common::utils (composeMany, compose)\n\nparameter\n\n    \/**\n     * `n` is the Speck word size in bits.\n     * `2 * n` is the Speck block size.\n     *\/\n    type n : #\n\n    \/**\n     * `m` is the number of words in the Speck key.\n     * Thus, the length of the Speck key is `n * m` bits.\n     *\/\n    type m : #\n\n    \/**\n     * `T` is the number of rounds.\n     *\/\n    type T : #\n\n    \/**\n     * The following type constraints satisfy Cryptol's type checker.\n     * They admit all valid Speck instantiations.\n     * They do not exclude all invalid instantiations.\n     *\/\n    type constraint (fin n, fin T, fin m)\n    type constraint (m >= 2, m <= 4, T >= 2, n >= width T)\n    type constraint (n >= 16)\n\n\/**\n * The Speck encryption function is the composition of `T` round functions.\n * Each of the `T` round function is derived from the key by the key schedule.\n *\n * Reference: [SPECK], Section 4.1\n *\/\nencrypt : [m * n] -> [2 * n] -> [2 * n]\nencrypt key plaintext = join (Speck_k (split plaintext))\n    where\n        \/\/ The Speck specification document parses the key LSB first.\n        \/\/ Cryptol parses all bitvectors MSB first.\n        \/\/ Thus, we reverse the key to match the\n        \/\/ convention of the specification.\n        Rks = map R (keySchedule (reverse (split key)))\n        Speck_k = composeMany Rks\n\n\/**\n * The Speck decryption function is the inverse of the encryption function.\n * To derive the inverse, the round functions are composed in reverse order.\n *\n * Reference: [SPECK], Section 4.1.\n *\/\ndecrypt : [m * n] -> [2 * n] -> [2 * n]\ndecrypt key ciphertext = join (Speck_k (split ciphertext))\n    where\n        \/\/ As in `encrypt`, we reverse the key.\n        Rks = map R_Inv (keySchedule (reverse (split key)))\n        Speck_k = composeMany (reverse Rks)\n\nprivate\n\n    \/**\n     * The encryption and decryption functions are inverses of each other.\n     *\n     * ```repl\n     * :check decryptInvertsEncrypt\n     * ```\n     *\/\n    property decryptInvertsEncrypt k x = decrypt k (encrypt k x) == x\n\n    \/**\n     * Left circular shift.\n     * The notation `S` is used because it appears in the specification.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    S : {j} (fin j) => [n] -> [n]\n    S x = x <<< `j\n\n    \/**\n     * Right circular shift.\n     * The notation `S_Inv` is used rather than using 'negative exponents'\n     * to avoid arithmetic strangeness with negative bitvectors.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    S_Inv : {j} (fin j) => [n] -> [n]\n    S_Inv x = x >>> `j\n\n    \/**\n     * Left circular shift by the rotation constant \u03b1.\n     * The rotation constant can be derived from the word size.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    S\u03b1: [n] -> [n]\n    S\u03b1 x | n == 16 => S `{7} x\n         | n >= 16 => S `{8} x\n\n    \/**\n     * Left circular shift by the rotation constant \u03b2.\n     * The rotation constant can be derived from the word size.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    S\u03b2 : [n] -> [n]\n    S\u03b2 x | n == 16 => S `{2} x\n         | n >= 16 => S `{3} x\n\n    \/**\n     * Right circular shift by the rotation constant \u03b1.\n     * The rotation constant can be derived from the word size.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    S\u03b1_Inv : [n] -> [n]\n    S\u03b1_Inv x | n == 16 => S_Inv `{7} x\n             | n >= 16 => S_Inv `{8} x\n\n    \/**\n     * Right circular shift by the rotation constant \u03b2.\n     * The rotation constant can be derived from the word size.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    S\u03b2_Inv : [n] -> [n]\n    S\u03b2_Inv x | n == 16 => S_Inv `{2} x\n             | n >= 16 => S_Inv `{3} x\n\n    \/**\n     * The Speck round function. This function is parameterized by a key.\n     * This function is a composition of shifts and modular additions.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    R : [n] -> [2][n] -> [2][n]\n    R k [x, y] = [(S\u03b1_Inv x + y) ^ k, S\u03b2 y ^ (S\u03b1_Inv x + y) ^ k]\n\n    \/**\n     * The inverse Speck round function.\n     *\n     * Reference: [SPECK], Section 4.1.\n     *\/\n    R_Inv : [n] -> [2][n] -> [2][n]\n    R_Inv k [x, y] = [S\u03b1 ((x ^ k) - S\u03b2_Inv (x ^ y)), S\u03b2_Inv (x ^ y)]\n\n    \/**\n     * `R_Inv` is the inverse of `R`.\n     *\n     * ```repl\n     * :prove RInvertible\n     * ```\n     *\/\n    property RInvertible k x = R_Inv k (R k x) == x\n\n    \/**\n     * `R` can be decomposed as two Feistel-like maps\n     * with respect to modular addition. This is the\n     * map with addition modulo `2^n`. Part of this function's\n     * output is used in the key schedule.\n     *\n     * Reference: [SPECK], Section 4.1, 4.2.\n     *\/\n    Rf1 : [n] -> [2][n] -> [2][n]\n    Rf1 k [x, y] = [y, (S\u03b1_Inv x + y) ^ k]\n\n    \/**\n     * `R` can be decomposed as two Feistel-like maps\n     * with respect to modular addition. This is the\n     * map with addition modulo `2` (i.e., XOR). Part of\n     * this function's output is used in the key schedule.\n     *\n     * Note that this function has no key dependence.\n     *\n     * Reference: [SPECK], Section 4.1, 4.2.\n     *\/\n    Rf2 : [2][n] -> [2][n]\n    Rf2 [x, y] = [y, S\u03b2 x ^ y]\n\n    \/**\n     * Composition of the Feistel-like maps.\n     * An alternative formulation of `R`.\n     *\/\n    Rf : [n] -> [2][n] -> [2][n]\n    Rf k s = f s\n        where\n            f = compose (Rf1 k) Rf2\n\n    \/**\n     * `Rf` is functionally equiavalent to `R`.\n     *\n     * ```repl\n     * :prove REquivalent\n     * ```\n     *\/\n    property REquivalent k s = Rf k s == R k s\n\n    \/**\n     * The Speck key schedule.\n     * This procedure generates the round keys from which\n     * each round function is derived. This procedure relies\n     * on the constituent functions that make up the round\n     * function.\n     *\n     * Reference: [Speck], Section 4.2.\n     *\/\n    keySchedule : [m][n] -> [T][n]\n    keySchedule K = ks\n        where\n            \/\/ write key K as (k0, l0, ... l_m-2)\n            [k0] # li = K\n            \/\/ define mutual recursion of sequences ki and li\n            ks = [k0] # [S\u03b2 (ks @ i) ^ (ls @ (i + `m - 1)) | i <- [0..T - 2]]\n            ls = li # [(k + S\u03b1_Inv (ls @ i)) ^ i | k <- ks | i <- [0..T - 2] ]\n\n    \/**\n     * The key schedule is injective.\n     *\n     * ```repl\n     * :prove keyScheduleInjective\n     * ```\n     *\/\n    property keyScheduleInjective k v = k != v ==> result\n        where\n            result = keySchedule k != keySchedule v\n\n    \/**\n     * The Speck key schedule, formulated in terms of the Speck round function.\n     * The formula in the specification explicitly unfolds these definitions;\n     * this formula leaves the definitions folded to illuminate the usage of\n     * the constituent functions.\n     *\n     * Reference: [SPECK], Section 4.2.\n     *\/\n    keySchedule' : [m][n] -> [T][n]\n    keySchedule' K = ks\n        where\n            \/\/ write key K as (k0, l0, ... l_m-2)\n            [k0] # li = K\n            \/\/ define mutual recursion of sequences ki and li\n            ks = [k0] # [f2 [(ks @ i), (ls @ (i + `m - 1))] | i <- [0..T - 2]]\n            ls = li # [f1 i [ls @ i, k] | k <- ks | i <- [0..T - 2] ]\n            \/\/ the key schedule uses the half of the output of the Speck round\n            \/\/ functions, discarding the half that isn't transformed by the\n            \/\/ Feistel-like map. The \"key\" for f1, in this case, is a counter.\n            f1 k s = (Rf1 k s) @ 1\n            f2 s = (Rf2 s) @ 1\n\n    \/**\n     * The key schedule formulations are equiavalent.\n     *\n     * ```repl\n     * :prove keySchedulesEquivalent\n     * ```\n     *\/\n    property keySchedulesEquivalent K = keySchedule K == keySchedule' K\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and invertibility of the AES block cipher implementation in the given specification. Include properties that check that decrypt is the inverse of encrypt, that the SBox and its inverse correctly invert each other, and that the transformations SubBytes, ShiftRows, and MixColumns are invertible as specified. Also include properties verifying the correctness of key expansion constants like Rcon."},{"role":"assistant","content":"```cryptol\n\/**\n * Cryptol AES Implementation.\n *\n * Intended use for this is that users interact with the `encrypt` and `decrypt`\n * functions. In practice, most users should use a mode of operation like\n * AES-GCM or AES-CTR, instead of using this directly.\n *\n * @copyright Galois Inc.\n * @author Nichole Schimanski <nls@galois.com>\n * @editor Brian Huffman\n * @author Marcella Hastings <marcella@galois.com>\n * @editor Lee Newcomb <newcomb@galois.com>\n * www.cryptol.net\n *\n *\n * References\n * [FIPS-197u1]: Morris J. Dworkin, Elaine B. Barker, James R. Nechvatal,\n *     James Foti, Lawrence E. Bassham, E. Roback, and James F. Dray Jr.\n *     Advanced Encryption Standard (AES). Federal Inf. Process. Stds. (NIST FIPS)\n *     197, update 1. May 2023.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.197-upd1\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::AES::Specification where\n\nimport Common::GF28 as GF28\nprivate type GF28 = GF28::GF28\n\nparameter\n  \/\/ This constraint enforces the standard key sizes of 128, 192, and\n  \/\/ 256-bits. [FIPS-197u1] Sections 1, 5, and 6.1.\n  type KeySize' : #\n  type constraint (fin KeySize', KeySize' % 64 == 0, KeySize' \/ 64 >= 2,\n    KeySize' \/ 64 <= 4)\n\n\/**\n * The AES implementation uses the `Mode` type to compute other parameters.\n * The mode corresponds directly to the key size:\n * Mode 0 = 128 bits; Mode 1 = 192 bits; Mode 2 = 256 bits\n *\/\ntype Mode = (KeySize \/ 64) - 2\n\n\/**\n * Key length: number of 32 bit words in the key.\n * [FIPS-197u1] Section 5, Table 3\n *\/\ntype Nk = 4 + 2 * Mode\n\n\/**\n * Number of rounds\n * [FIPS-197u1] Section 5, Table 3\n *\/\ntype Nr = 6 + Nk\n\n\/**\n * The number of words in the state is generic for the underlying Rijndael\n * algorithm, but in the standard it is fixed to 4.\n * [FIPS-197u1] Section 5.\n *\/\ntype Nb = 4\n\n\/\/ Make `KeySize` and `BlockSize` accessible outside the module.\n\/\/ This also lets us use AES as an instantiation of `CipherInterface`\ntype KeySize = KeySize'\ntype BlockSize = 128\n\n\/**\n * AES encryption.\n * [FIPS-197u1], Section 5, Equation 5.1.\n * This differs slightly from the spec:\n * - The spec calls this `AES-<Keysize>` instead of `encrypt`.\n * - The spec passes parameters in the opposite order `(in, key)`\n *   where `in` is the data input block and `key` is the key. Here\n *   we pass the key `k` first and the input block second.\n *\/\nencrypt : [KeySize] -> [BlockSize] -> [BlockSize]\nencrypt k = cipher (keyExpansion k)\n\n\/**\n * AES decryption.\n * [FIPS-197u1], Section 5.\n * The spec does not give this an explicit name.\n *\/\ndecrypt : [KeySize] -> [BlockSize] -> [BlockSize]\ndecrypt k = invCipher (keyExpansion k)\n\n\/**\n * `decrypt` must be the inverse of `encrypt`.\n * With high probability, this will be extremely slow to prove.\n * [FIPS-197u1], Section 5.\n * ```repl\n * :check aesIsCorrect\n * ```\n *\/\nproperty aesIsCorrect k pt = decrypt k (encrypt k pt) == pt\n\n\/**\n * The algorithms for AES block ciphers are performed on a 4x4 array of bytes.\n * [FIPS-197u1] Section 3.4.\n *\/\ntype State = [4][Nb]GF28\n\n\/**\n * In the specifications for AES, the first step is to copy the input array\n * of 16 bytes into the state array.\n *\n * [FIPS-197u1] Section 3.4, Equation 3.6.\n *\/\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\n\/**\n * After the state array is transformed, its final value is copied to the\n * output array of bytes.\n *\n * [FIPS-197u1] Section 3.4, Equation 3.7.\n *\/\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\n\/**\n * This demonstrates the property in [FIPS-197u1] Section 3.4, Figure 1.\n * Note that we don't ever need this property in the execution of AES,\n * but it should hold true anyway.\n *\n * ```repl\n * :prove ioInverts\n * ```\n *\/\nproperty ioInverts msg = stateToMsg (msgToState msg) == msg\n\n\/**\n * The substitution table as given in Table 4. The table is pulled out here\n * for efficiency, letting us compute the table once per access in AES.\n *\n * `GF28::inverse b` corresponds to Equation 5.2.\n *\/\nsboxTable : [256]GF28\nprivate sboxTable = [ transform (GF28::inverse b) | b <- [0 .. 255] ] where\n    \/\/ Equation 5.3.\n    transform b = GF28::add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n    \/\/ The constant byte {01100011}.\n    c = 0x63\n\n\/**\n * SBox: A non-linear substitution table for AES.\n * [FIPS-197u1] Section 5.1.1.\n *\/\nSBox : GF28 -> GF28\nSBox b = sboxTable @ b\n\n\/**\n * SBox example from [FIPS-197u1] Section 5.1.1 (page 14).\n * ```repl\n *  :prove SBox53\n * ```\n *\/\nproperty SBox53 = SBox 0x53 == 0xed\n\n\/**\n * The substitution table as given in Table 6. The table is pulled out here\n * for efficiency, letting us compute the table once per access in AES.\n *\/\nsboxInvTable : [256]GF28\nprivate sboxInvTable = [ GF28::inverse (transformInv b) | b <- [0 .. 255] ] where\n    transformInv b = GF28::add [(b >>> 2), (b >>> 5), (b >>> 7), d]\n    d = 0x05\n\n\/**\n * Inverted substitution table for AES.\n * [FIPS-197u1] Section 5.3.2.\n *\/\nSBoxInv : GF28 -> GF28\nSBoxInv b = sboxInvTable @ b\n\n\/**\n * S-box inversion must be correctly defined.\n * ```repl\n * :prove SBoxInverts\n * ```\n *\/\nproperty SBoxInverts b = SBoxInv (SBox b) == b\n\n\/**\n * The round key is a block that is usually represented as a sequence of four words.\n * [FIPS-197u1] Section 5.\n *\n * A word is a sequence of four bytes. [FIPS-197u1] Section 3.5.\n *\/\ntype RoundKey = [4][4]GF28\n\n\/** The keys for all the rounds *\/\ntype KeySchedule = [Nr+1]RoundKey\n\/**\n * The general function for executing AES with 128-, 192-, or 256-bit keys.\n *\n * Corresponds to [FIPS-197u1] Section 5.1, Algorithm 1.\n *\n * In the spec, the three inputs to `Cipher` are the input data, the number of\n * rounds `Nr`, and the round keys `w`. In this implementation, we don't explicitly\n * pass `Nr` as a parameter; instead it's defined as a type above. We also\n * switch the order of the input and keys.\n *\/\ncipher: KeySchedule -> [128] -> [128]\ncipher w pt = stateToMsg final_state   where\n        state0 = AddRoundKey (w @ 0) (msgToState pt)\n        state4 = foldl transform state0 (w @@ [1 .. (Nr - 1)])\n        transform state word = AddRoundKey word (MixColumns (ShiftRows (SubBytes state)))\n        final_state = AddRoundKey (w @ `Nr) (ShiftRows (SubBytes (state4)))\n\n\/**\n * SubBytes applies an invertible, non-linear transformation to the state.\n * [FIPS-197u1] Section 5.1.1.\n *\n * It does so by applying the AES S-box independently to each byte in the state.\n *\/\nSubBytes : State -> State\nSubBytes state = [ [ SBox b | b <- row ] | row <- state ]\n\n\/**\n * ShiftRows transforms the state by cycling the last three rows.\n * [FIPS-197u1] Section 5.1.2.\n *\/\nShiftRows : State -> State\nShiftRows state = [ row <<< i | row <- state | i : [2] <- [0 .. 3] ]\n\n\/**\n * MixColumns multiplies the state columns by a fixed matrix.\n * [FIPS-197u1] Section 5.1.3.\n *\/\nMixColumns : State -> State\nMixColumns state = GF28::matrixMult m state\n    where m = [ [2,3,1,1] >>> i | i : [2] <- [0 .. 3] ]\n\n\/**\n * AddRoundKey combines the state with a round key via the\n * bitwise XOR operator\n * [FIPS-197u1] Section 5.1.4\n *\/\nAddRoundKey : RoundKey -> State -> State\nAddRoundKey w state = w ^ state\n\n\/**\n * Key expansion depends on 10 fixed words denoted by `Rcon`.\n * [FIPS-197u1] Section 5.2, Table 5.\n *\n * This function requires `1 <= j <= 10`.\n *\/\nRcon : [8] -> [4]GF28\nRcon j = constants @ (j - 1) where\n    constants = [\n        [0x01, 0x00, 0x00, 0x00],\n        [0x02, 0x00, 0x00, 0x00],\n        [0x04, 0x00, 0x00, 0x00],\n        [0x08, 0x00, 0x00, 0x00],\n        [0x10, 0x00, 0x00, 0x00],\n        [0x20, 0x00, 0x00, 0x00],\n        [0x40, 0x00, 0x00, 0x00],\n        [0x80, 0x00, 0x00, 0x00],\n        [0x1b, 0x00, 0x00, 0x00],\n        [0x36, 0x00, 0x00, 0x00]\n    ]\n\n\/**\n * The value of the left-most byte of `Rcon[j]` in polynomial form is `x^(j-1)`.\n * [FIPS-197u1] Section 5.2.\n * ```repl\n * :prove RconIsExponentiation\n * ```\n *\/\nRconIsExponentiation : [8] -> Bit\nproperty RconIsExponentiation j = (1 <= j) && (j <= 10) ==>\n    (Rcon j)@0 == GF28::pow <| x |> (j-1)\n\n\/**\n * Transformation on words for key expansion.\n * [FIPS-197u1] Equation 5.10.\n *\/\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\n\/**\n * Transformation on words for key expansion.\n * [FIPS-197u1] Equation 5.11.\n *\/\nSubWord : [4]GF28 -> [4]GF28\nSubWord [a0, a1, a2, a3] = [ SBox a0, SBox a1, SBox a2, SBox a3 ]\n\n\/**\n * KeyExpansion() routine.\n * [FIPS-197u1] Algorithm 2.\n *\n * The algorithm in the spec returns the key as a single object `w`. For\n * convenience at the point of use, we split it into three parts, separating\n * the first and last keys from the main set of round keys:\n * `w_0, [w_1, ..., w_{Nr-1}], w_{Nr}`.\n *\n * In generating the key stream, we use slightly different notation compared\n * to the original spec in an attempt at readability.\n * `w_{i-1}` is denoted `w_1`, and `w_{i-Nk}` is denoted `w_nk`.\n *\/\nkeyExpansion : [32 * Nk] -> [Nr+1]RoundKey\nkeyExpansion key = keys\n  where\n    \/\/ Lines 2-6: The first `Nk` words of the expanded key are the key itself\n    seed : [Nk][4]GF28\n    seed = split (split key)\n\n    \/\/ Lines 7-16: A loop to recursively generate the key stream\n    ws : [inf][4]GF28\n    ws = seed # [ nextWord i w_1 w_nk\n       | i    <- [ `Nk ... ]\n       | w_1  <- drop`{Nk-1} ws\n       | w_nk <- ws\n       ]\n\n    \/\/ Generate a single word `w_i` in the key stream.\n    \/\/ Each word `w_i` is a function of the previous word `w_{i-1}`\n    \/\/ and the word `Nk` positions earlier `w_{i-Nk}`.\n    nextWord : [8] ->[4]GF28 -> [4]GF28 -> [4]GF28\n    nextWord i w_1 w_nk = w_i where\n      \/\/ Lines 8 - 13: Derive the mask `temp`.\n      temp =\n        \/\/ If `i` is a multiple of `Nk`:\n        if i % `Nk == 0 then\n          SubWord (RotWord w_1) ^ Rcon (i \/ `Nk)\n        \/\/ For AES-256 (Nk == 8), if `i + 4` is a multiple of 8:\n        else if (`Nk > 6) && (i % `Nk == 4) then\n          SubWord w_1\n        \/\/ For all other cases:\n        else w_1\n\n      \/\/ Line 14: Apply the mask to the `i-Nk`th word to get the `i`th word.\n      w_i = w_nk ^ temp\n\n    \/\/ Line 17: Return the resulting key stream\n    \/\/ This breaks the stream into correctly-shaped words\n    keys = take `{Nr+1} [ transpose g | g <- split ws ]\n\n\/**\n * The general function for inverting AES with 128-, 192-, or 256-bit keys.\n *\n * This inverts and reverses the order of the transformations in `cipher`.\n * Corresponds to [FIPS-197u1] Section 5.3, Algorithm 3.\n *\n * In the spec, the three inputs to `InvCipher` are the input data, the number of\n * rounds `Nr`, and the round keys `w`. In this implementation, we don't explicitly\n * pass `Nr` as a parameter; instead it's defined as a type above. We also\n * switch the order of the input and keys.\n *\/\ninvCipher: KeySchedule -> [128] -> [128]\ninvCipher w ct = stateToMsg final_state   where\n        state0 = AddRoundKey (w @ `Nr) ( msgToState ct)\n        state4 = foldl transform state0 (reverse (w @@ [1 .. (Nr - 1)]))\n        transform state word = InvMixColumns (AddRoundKey word (InvSubBytes (InvShiftRows state)))\n        final_state = AddRoundKey (w @ 0) (InvSubBytes (InvShiftRows (state4)))\n\n\/**\n * Inverts the `ShiftRows` function.\n * [FIPS-197u1] Section 5.3.1.\n *\/\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> i | row <- state | i : [2] <- [0 .. 3] ]\n\n\/**\n * Inverts the `SubBytes` function.\n * [FIPS-197u1] Section 5.3.2\n *\/\nInvSubBytes : State -> State\nInvSubBytes state = [ [ SBoxInv b | b <- row ] | row <- state ]\n\n\/**\n * Inverts the `MixColumns` function.\n * [FIPS-197u1] Section 5.3.3.\n *\/\nInvMixColumns : State -> State\nInvMixColumns state = GF28::matrixMult m state\n    where m = [[0x0e, 0x0b, 0x0d, 0x09] >>> i | i : [2] <- [0 .. 3] ]\n\n\/**\n * SubBytes inversion must be correctly defined.\n * ```repl\n * :prove subBytesInverts\n * ```\n *\/\nsubBytesInverts : State -> Bool\nproperty subBytesInverts s = InvSubBytes (SubBytes s) == s\n\n\/**\n * ShiftRows inversion must be correctly defined.\n * ```repl\n * :prove shiftRowsInverts\n * ```\n *\/\nshiftRowsInverts : State -> Bool\nproperty shiftRowsInverts s = InvShiftRows (ShiftRows s) == s\n\n\/**\n * MixColumns inversion must be correctly defined.\n * ```repl\n * :check mixColumnsInverts\n * ```\n *\/\nmixColumnsInverts : State -> Bool\nproperty mixColumnsInverts s = InvMixColumns (MixColumns s) == s\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the AES256 CTR mode encryption and decryption functions correctly transform the given plaintext and ciphertext test vectors as specified in the AES256_CTR module. Include properties to prove that encrypting the plaintext yields the ciphertext and decrypting the ciphertext yields the plaintext, using the provided key and initial counter values."},{"role":"assistant","content":"```cryptol\n\/*\n * Test vectors for AES256 in CTR mode.\n * These are taken from [NIST-SP-800-38A] Appendix F.5\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Marcella Hastings <marcella@galois.com>\n *  www.cryptol.net\n *\n * References:\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n * Modes of Operation: Methods and Techniques. NIST Special Publication\n * 800-38A. December 2001.\n *\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR as AES256_CTR\n\n\/**\n * ```repl\n * :prove aes256_ctr_encrypt_vector\n * ```\n *\/\nproperty aes256_ctr_encrypt_vector = (AES256_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x601ec313775789a5b7a7f504bbf3d228,\n        0xf443e3ca4d62b59aca84e990cacaf5c5,\n        0x2b0930daa23de94ce87017ba2d84988d,\n        0xdfc9c58db67aada613c2dd08457941a6]\n\n\/**\n * ```repl\n * :prove aes256_ctr_decrypt_vector\n * ```\n *\/\nproperty aes256_ctr_decrypt_vector = (AES256_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x601ec313775789a5b7a7f504bbf3d228,\n        0xf443e3ca4d62b59aca84e990cacaf5c5,\n        0x2b0930daa23de94ce87017ba2d84988d,\n        0xdfc9c58db67aada613c2dd08457941a6]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of AES-192 CFB mode encryption and decryption for CFB1, CFB8, and CFB128 variants using the provided test vectors. Ensure that the properties prove that encrypting the plaintext with the given key and IV produces the expected ciphertext, and decrypting the ciphertext recovers the original plaintext."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB as AES192_CFB\n\n\/**\n * Section F.3.3: CFB1-AES192.Encrypt\n *\n * ```repl\n * :prove aes192_cfb1_encrypt_vector\n * ```\n *\/\nproperty aes192_cfb1_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b1, 0b1,\n            0b0, 0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1\n        ]\n\n\/**\n * Section F.3.4: CFB1-AES192.Decrypt\n *\n * ```repl\n * :prove aes192_cfb1_decrypt_vector\n * ```\n *\/\nproperty aes192_cfb1_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b1, 0b1,\n            0b0, 0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\n\/**\n * Section F.3.9: CFB8-AES192.Encrypt\n *\n * ```repl\n * :prove aes192_cfb8_encrypt_vector\n * ```\n *\/\nproperty aes192_cfb8_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0xcd, 0xa2, 0x52, 0x1e, 0xf0, 0xa9, 0x05, 0xca, 0x44,\n            0xcd, 0x05, 0x7c, 0xbf, 0x0d, 0x47, 0xa0, 0x67, 0x8a\n        ]\n\n\/**\n * Section F.3.10: CFB8-AES192.Decrypt\n *\n * ```repl\n * :prove aes192_cfb8_decrypt_vector\n * ```\n *\/\nproperty aes192_cfb8_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xcd, 0xa2, 0x52, 0x1e, 0xf0, 0xa9, 0x05, 0xca, 0x44,\n            0xcd, 0x05, 0x7c, 0xbf, 0x0d, 0x47, 0xa0, 0x67, 0x8a\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\n\/**\n * Section F.3.15: CFB128-AES192.Encrypt\n *\n * ```repl\n * :prove aes192_cfb128_encrypt_vector\n * ```\n *\/\nproperty aes192_cfb128_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0xcdc80d6fddf18cab34c25909c99a4174,\n            0x67ce7f7f81173621961a2b70171d3d7a,\n            0x2e1e8a1dd59b88b1c8e60fed1efac4c9,\n            0xc05f9f9ca9834fa042ae8fba584b09ff\n        ]\n\n\/**\n * Section F.3.16: CFB128-AES192.Decrypt\n *\n * ```repl\n * :prove aes192_cfb128_decrypt_vector\n * ```\n *\/\nproperty aes192_cfb128_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv =  0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xcdc80d6fddf18cab34c25909c99a4174,\n            0x67ce7f7f81173621961a2b70171d3d7a,\n            0x2e1e8a1dd59b88b1c8e60fed1efac4c9,\n            0xc05f9f9ca9834fa042ae8fba584b09ff\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the AES128_CTR encryption and decryption functions are correct by proving that encrypting the given plaintext with the specified key and initial counter produces the expected ciphertext, and that decrypting the ciphertext with the same key and initial counter recovers the original plaintext."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CTR as AES128_CTR\n\n\/**\n * ```repl\n * :prove aes128_ctr_encrypt_vector\n * ```\n *\/\nproperty aes128_ctr_encrypt_vector = (AES128_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x874d6191b620e3261bef6864990db6ce,\n        0x9806f66b7970fdff8617187bb9fffdff,\n        0x5ae4df3edbd5d35e5b4f09020db03eab,\n        0x1e031dda2fbe03d1792170a0f3009cee]\n\n\/**\n * ```repl\n * :prove aes128_ctr_decrypt_vector\n * ```\n *\/\nproperty aes128_ctr_decrypt_vector = (AES128_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x874d6191b620e3261bef6864990db6ce,\n        0x9806f66b7970fdff8617187bb9fffdff,\n        0x5ae4df3edbd5d35e5b4f09020db03eab,\n        0x1e031dda2fbe03d1792170a0f3009cee]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of AES256 CFB mode encryption and decryption functions for different segment sizes (CFB1, CFB8, CFB128) using the provided test vectors. Ensure that the properties prove that encrypting the plaintext with the given key and IV produces the expected ciphertext, and decrypting the ciphertext recovers the original plaintext."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CFB as AES256_CFB\n\n\/**\n * Section F.3.5: CFB1-AES256.Encrypt\n *\n * ```repl\n * :prove aes256_cfb1_encrypt_vector\n * ```\n *\/\nproperty aes256_cfb1_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b0, 0b0,\n            0b0, 0b0, 0b1, 0b0, 0b1, 0b0, 0b0, 0b1\n        ]\n\n\/**\n * Section F.3.6: CFB1-AES256.Decrypt\n *\n * ```repl\n * :prove aes256_cfb1_decrypt_vector\n * ```\n *\/\nproperty aes256_cfb1_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b0, 0b0,\n            0b0, 0b0, 0b1, 0b0, 0b1, 0b0, 0b0, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\n\/**\n * Section F.3.11: CFB8-AES256.Encrypt\n *\n * ```repl\n * :prove aes256_cfb8_encrypt_vector\n * ```\n *\/\nproperty aes256_cfb8_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0xdc, 0x1f, 0x1a, 0x85, 0x20, 0xa6, 0x4d, 0xb5, 0x5f,\n            0xcc, 0x8a, 0xc5, 0x54, 0x84, 0x4e, 0x88, 0x97, 0x00\n        ]\n\n\/**\n * Section F.3.12: CFB8-AES256.Decrypt\n *\n * ```repl\n * :prove aes256_cfb8_decrypt_vector\n * ```\n *\/\nproperty aes256_cfb8_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xdc, 0x1f, 0x1a, 0x85, 0x20, 0xa6, 0x4d, 0xb5, 0x5f,\n            0xcc, 0x8a, 0xc5, 0x54, 0x84, 0x4e, 0x88, 0x97, 0x00\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\n\/**\n * Section F.3.17: CFB128-AES256.Encrypt\n *\n * ```repl\n * :prove aes256_cfb128_encrypt_vector\n * ```\n *\/\nproperty aes256_cfb128_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0xdc7e84bfda79164b7ecd8486985d3860,\n            0x39ffed143b28b1c832113c6331e5407b,\n            0xdf10132415e54b92a13ed0a8267ae2f9,\n            0x75a385741ab9cef82031623d55b1e471\n        ]\n\n\/**\n * Section F.3.18: CFB256-AES192.Decrypt\n *\n * ```repl\n * :prove aes256_cfb128_decrypt_vector\n * ```\n *\/\nproperty aes256_cfb128_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv =  0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xdc7e84bfda79164b7ecd8486985d3860,\n            0x39ffed143b28b1c832113c6331e5407b,\n            0xdf10132415e54b92a13ed0a8267ae2f9,\n            0x75a385741ab9cef82031623d55b1e471\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of AES192 encryption and decryption in CTR mode using the provided NIST test vectors. Specifically, write properties that prove encrypting the given plaintext with the specified key and initial counter produces the expected ciphertext, and that decrypting the ciphertext recovers the original plaintext."},{"role":"assistant","content":"```cryptol\n\/*\n * Test vectors for AES192 in CTR mode.\n * These are taken from [NIST-SP-800-38A] Appendix F.5\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Marcella Hastings <marcella@galois.com>\n *  www.cryptol.net\n *\n * References:\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n * Modes of Operation: Methods and Techniques. NIST Special Publication\n * 800-38A. December 2001.\n *\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CTR as AES192_CTR\n\n\/**\n * ```repl\n * :prove aes192_ctr_encrypt_vector\n * ```\n *\/\nproperty aes192_ctr_encrypt_vector = (AES192_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x1abc932417521ca24f2b0459fe7e6e0b,\n        0x090339ec0aa6faefd5ccc2c6f4ce8e94,\n        0x1e36b26bd1ebc670d1bd1d665620abf7,\n        0x4f78a7f6d29809585a97daec58c6b050]\n\n\/**\n * ```repl\n * :prove aes192_ctr_decrypt_vector\n * ```\n *\/\nproperty aes192_ctr_decrypt_vector = (AES192_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x1abc932417521ca24f2b0459fe7e6e0b,\n        0x090339ec0aa6faefd5ccc2c6f4ce8e94,\n        0x1e36b26bd1ebc670d1bd1d665620abf7,\n        0x4f78a7f6d29809585a97daec58c6b050]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the AES128_CFB module correctly implements the AES-128 cipher in CFB mode by proving that encryption and decryption produce expected outputs for the provided NIST test vectors in sections F.3.1, F.3.2, F.3.7, F.3.8, F.3.13, and F.3.14."},{"role":"assistant","content":"```cryptol\n\/*\n * Test vectors for AES128 in CFB mode.\n *\n * These are taken from [NIST-SP-800-38A], Appendix F.3.\n *\n * @copyright Galois, Inc.\n * @author Alex J Malozemoff <amaloz@galois.com>\n * www.cryptol.net\n *\n * Sources:\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n *     Modes of Operation: Methods and Techniques. NIST Special Publication\n *     800-38A. December 2001.\n *     @see https:\/\/doi.org\/10.6028\/NIST.SP.800-38A\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB as AES128_CFB\n\n\/**\n * Section F.3.1: CFB1-AES128.Encrypt\n *\n * ```repl\n * :prove aes128_cfb1_encrypt_vector\n * ```\n *\/\nproperty aes128_cfb1_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b0, 0b0,\n            0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1, 0b1\n        ]\n\n\/**\n * Section F.3.2: CFB1-AES128.Decrypt\n *\n * ```repl\n * :prove aes128_cfb1_decrypt_vector\n * ```\n *\/\nproperty aes128_cfb1_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b0, 0b0,\n            0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\n\/**\n * Section F.3.7: CFB8-AES128.Encrypt\n *\n * ```repl\n * :prove aes128_cfb8_encrypt_vector\n * ```\n *\/\nproperty aes128_cfb8_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0x3b, 0x79, 0x42, 0x4c, 0x9c, 0x0d, 0xd4, 0x36, 0xba,\n            0xce, 0x9e, 0x0e, 0xd4, 0x58, 0x6a, 0x4f, 0x32, 0xb9\n        ]\n\n\/**\n * Section F.3.8: CFB8-AES128.Decrypt\n *\n * ```repl\n * :prove aes128_cfb8_decrypt_vector\n * ```\n *\/\nproperty aes128_cfb8_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0x3b, 0x79, 0x42, 0x4c, 0x9c, 0x0d, 0xd4, 0x36, 0xba,\n            0xce, 0x9e, 0x0e, 0xd4, 0x58, 0x6a, 0x4f, 0x32, 0xb9\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\n\/**\n * Section F.3.13: CFB128-AES128.Encrypt\n *\n * ```repl\n * :prove aes128_cfb128_encrypt_vector\n * ```\n *\/\nproperty aes128_cfb128_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0x3b3fd92eb72dad20333449f8e83cfb4a,\n            0xc8a64537a0b3a93fcde3cdad9f1ce58b,\n            0x26751f67a3cbb140b1808cf187a4f4df,\n            0xc04b05357c5d1c0eeac4c66f9ff7f2e6\n        ]\n\n\/**\n * Section F.3.14: CFB128-AES128.Decrypt\n *\n * ```repl\n * :prove aes128_cfb128_decrypt_vector\n * ```\n *\/\nproperty aes128_cfb128_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0x3b3fd92eb72dad20333449f8e83cfb4a,\n            0xc8a64537a0b3a93fcde3cdad9f1ce58b,\n            0x26751f67a3cbb140b1808cf187a4f4df,\n            0xc04b05357c5d1c0eeac4c66f9ff7f2e6\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of AES192 encryption and decryption in CBC mode using the provided test vectors from NIST SP 800-38A. Specifically, create properties that prove the encryption of the given plaintext with the specified key and IV equals the expected ciphertext, and that decrypting the ciphertext with the same key and IV recovers the original plaintext."},{"role":"assistant","content":"```cryptol\n\/*\n * Test vectors for AES192 in CBC mode.\n * These are taken from [NIST-SP-800-38A] Appendix F.2\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Marcella Hastings <marcella@galois.com>\n * @author Stanislav Lyakhov <stan@galois.com>\n *  www.cryptol.net\n *\n * References:\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n * Modes of Operation: Methods and Techniques. NIST Special Publication\n * 800-38A. December 2001.\n *\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CBC as AES192_CBC\n\n\/**\n * ```repl\n * :prove aes192_cbc_encrypt_vector\n * ```\n *\/\nproperty aes192_cbc_encrypt_vector = (AES192_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x4f021db243bc633d7178183a9fa071e8,\n        0xb4d9ada9ad7dedf4e5e738763f69145a,\n        0x571b242012fb7ae07fa9baac3df102e0,\n        0x08b0e27988598881d920a9e64f5615cd]\n\n\/**\n * ```repl\n * :prove aes192_cbc_decrypt_vector\n * ```\n *\/\nproperty aes192_cbc_decrypt_vector = (AES192_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0x4f021db243bc633d7178183a9fa071e8,\n        0xb4d9ada9ad7dedf4e5e738763f69145a,\n        0x571b242012fb7ae07fa9baac3df102e0,\n        0x08b0e27988598881d920a9e64f5615cd]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of AES256 CBC mode encryption and decryption using the provided NIST test vectors. Specifically, create properties that prove the encryption of the given plaintext with the specified key and IV equals the expected ciphertext, and that decrypting the ciphertext with the same key and IV recovers the original plaintext."},{"role":"assistant","content":"```cryptol\n\/*\n * Test vectors for AES256 in CBC mode.\n * These are taken from [NIST-SP-800-38A] Appendix F.2\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Marcella Hastings <marcella@galois.com>\n * @author Stanislav Lyakhov <stan@galois.com>\n *  www.cryptol.net\n *\n * References:\n * [NIST-SP-800-38A]: Morris Dworkin. Recommendation for Block Cipher\n * Modes of Operation: Methods and Techniques. NIST Special Publication\n * 800-38A. December 2001.\n *\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CBC as AES256_CBC\n\n\/**\n * ```repl\n * :prove aes256_cbc_encrypt_vector\n * ```\n *\/\nproperty aes256_cbc_encrypt_vector = (AES256_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0xf58c4c04d6e5f1ba779eabfb5f7bfbd6,\n        0x9cfc4e967edb808d679f777bc6702c7d,\n        0x39f23369a9d9bacfa530e26304231461,\n        0xb2eb05e2c39be9fcda6c19078c6a9d1b]\n\n\/**\n * ```repl\n * :prove aes256_cbc_decrypt_vector\n * ```\n *\/\nproperty aes256_cbc_decrypt_vector = (AES256_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0xf58c4c04d6e5f1ba779eabfb5f7bfbd6,\n        0x9cfc4e967edb808d679f777bc6702c7d,\n        0x39f23369a9d9bacfa530e26304231461,\n        0xb2eb05e2c39be9fcda6c19078c6a9d1b]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_KeyWrapPadded_AE.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that formally specify and verify the correctness of the AES-256 Key Wrap with Padding authenticated encryption function using the provided test vectors. The properties should check that for each given key and plaintext pair, the encryption function produces the expected ciphertext as specified in the test vectors."},{"role":"assistant","content":"```cryptol\n\/**\n * Test vectors for AES key wrap with padding's authenticated encryption\n * function from NIST's ACVP cryptographic validation program.\n *\n * These values are specifically drawn from the `internalProjection.json` file,\n * specifically the section with group ID `\"tgId\" : 11`.\n *\n * [ACVP]: NIST. usnistgov. GitHub repo \"ACVP-Server\".\n *     @see https:\/\/github.com\/usnistgov\/ACVP-Server\/tree\/master\/gen-val\/json-files\/ACVP-AES-KWP-1.0\n *\n * Rather than decorate every property, we use a single docstring up here:\n * ```repl\n * :exhaust\n * ```\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_KeyWrapPadded_AE where\n\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap\n\ncheck_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct\n\nproperty tcId1001 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x39FA276B26B762599AA1070192987D0CF8184DDB1C98EEA23F06FF81B63481E0\n    pt = 0x8D\n    ct = 0x35A739A8A322805B94DEB3CB1A56A008\n\nproperty tcId1002 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF80E0BDD0D1B3407F241522045574E3C80CA99D3A6854706047942EB694CDBF3\n    pt = 0xC5\n    ct = 0x9581CB7E06C38D57C5262A7BD4BD8840\n\nproperty tcId1003 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC93821958B2A3AC969FFCA59EF5623E609F38585A6C9A9ADE41D546578DE141D\n    pt = 0x1E\n    ct = 0xDD6DC03E825F2E77480F998902FA6BE8\n\nproperty tcId1004 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF6C4018216BC7EAB22D57893BE5E9E3A2A7189813E37D26BFD8A866BADE775F8\n    pt = 0xE3\n    ct = 0x56F07FA0F5512B159F5E70A50C442B0B\n\nproperty tcId1005 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDC426450A27CCAD9B7890661B13480D2225918AAC7C03829512492865763ABDC\n    pt = 0x3F\n    ct = 0x686DE8ABFFBEDF79AAFD4432ECD4CF50\n\nproperty tcId1006 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x44F2DE705C848A3448FF6FFCBD221C0DC2119351D384CE21D5AC2606FE21B6F8\n    pt = 0xDA\n    ct = 0xE4B9BC2CE14293EAF05955A42627269D\n\nproperty tcId1007 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC933E2E4EE7D519FA406AA70EAC833CCD50FBB044427B1D25624254A555EDC43\n    pt = 0x1E\n    ct = 0x901B3CE56E12F8C188039535EBA61996\n\nproperty tcId1008 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x6E0627242E7C51B204DB46A58D6A411B96514555CF8C21DD8B2DC37CDA95F9CD\n    pt = 0x15\n    ct = 0x2AD76F428813B950D099C10105A29FB5\n\nproperty tcId1009 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1FD3508E9533EC697E4B8F59FFFE4B98857919A4DEF918426D068F70F3B2948E\n    pt = 0x02\n    ct = 0x530967E906FD940C887A6AD9F37AC42D\n\nproperty tcId1010 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x85BFD16F7B562AD251329106A3D7A184C5C96CCE489B2DD797A084A72404376D\n    pt = 0x94\n    ct = 0xEFC758A879A703D39B7B85F7BB7B2D44\n\nproperty tcId1011 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDDD6FAB4C49DD7FF2985AE928BD5EA87CC70A31163074F1FB1BC02F7F969D418\n    pt = 0x86\n    ct = 0xBD96D9C865A87BE05A306AB3D6BBA3A5\n\nproperty tcId1012 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDA37F25B6EBE88C9DB9E03A5E126D5AE55F632B1686115C956228326A0DBC789\n    pt = 0xA9\n    ct = 0xAC58CFA83697E911CD09BEA23CA4CD45\n\nproperty tcId1013 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1BB566FE462A27901D86EEF8558F53E505E47D81A66F2918AADE08EA347201B3\n    pt = 0x1D\n    ct = 0x8A51E6B709CB04F59981F7FFDB783D0B\n\nproperty tcId1014 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x73B2AB98DDC2A3557AC51C1976D43F2997D4305D6C1D8DE38B393161DE44A1BA\n    pt = 0x54\n    ct = 0x281900A08220B5F74CF06D739F7C5DC6\n\nproperty tcId1015 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCACF12AE11477B1254437CA92D329F1C7EE6B2C022E4F12C3EAC649621AB0137\n    pt = 0xE2\n    ct = 0x6DCC8657EC2A2443DD056EF73DBBFB7B\n\nproperty tcId1016 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3E7517AE08DA6B2B027AC829D0D96FB0D2B27C611D217174FFF385EEA51ABC9F\n    pt = 0x7E\n    ct = 0x542A995D5BEB0FEF0CA3B56DB914E0DF\n\nproperty tcId1017 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x636062EAF492C67B4E98DC4653031942CE29FB1B81462A31FCA2A40DF760ED1F\n    pt = 0x9C\n    ct = 0x9F24ED46467485D4ED54D232E50E8885\n\nproperty tcId1018 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x86CF07CC35A7624129A9390B14EE6FA8B8D7A9F613050E7CE3E3AF3CAD54ABB3\n    pt = 0x75\n    ct = 0x76A00B69214577BAD18CCDC983C8BAFD\n\nproperty tcId1019 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC4C825E849AE1C195748979D8821711590403E3AC47984C526DF896D120E7396\n    pt = 0x9E\n    ct = 0x5808672A0F4EEDD81328D99819993EB7\n\nproperty tcId1020 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFF84BC98909D273B28F0AC9D0C44386533BFE6A0586294D57DF370FFECCDDB3F\n    pt = 0xC9\n    ct = 0xDA9785C2ADC2CE92EFF5E3523D469235\n\nproperty tcId1021 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x8670FB10B54781839B56C7A14C660412FE2E48F3655ACC55553B794D9FFA32B7\n    pt = 0xF0\n    ct = 0x8850EF6CB7396E775D4F330C6E01EDCE\n\nproperty tcId1022 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x211A909A1C1B0F56BEBBF3362DC2CD75AB14BB2CB4EB191557B5ABAC7EF9E4E4\n    pt = 0x19\n    ct = 0xC76400B498AEB0023E266AFF9EE30FE8\n\nproperty tcId1023 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xB77EBA3E4E1FD9D5989A233E66BFC9CBB8CF245C9DCF7C59AF1D5FDD4811D76A\n    pt = 0xC0\n    ct = 0xC8869A194252053D69CB3700B519B400\n\nproperty tcId1024 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x96A325D96DF23193F21C409B20B83B157E4BC00E7B872A96D57EA7791575B797\n    pt = 0x60\n    ct = 0x9C5C1DCBFE8CEA38DED462DC2268D090\n\nproperty tcId1025 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x67BA246D02CBBBEDDE0B24C8DD8EE9ECF80DC34ECF0A211B1967BC141265F099\n    pt = 0x00\n    ct = 0x38AE876F1E45933C75D8B57531B59075\n\nproperty tcId1026 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x81C3403F359326663B025C16865E245808C4848A54011F6B88385A1A64FBECBC\n    pt = 0xC2\n    ct = 0x8C0DEC2FD4B6AB0231EC56BD50852D84\n\nproperty tcId1027 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x428666365FFAE2B604A71E3EA61D1AB85CFCDEDEF5D40CFE8E53FDB96AC27630\n    pt = 0x1D\n    ct = 0x48D46E384AE3AA2BDCEC10399A82BE37\n\nproperty tcId1028 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x859857F302D7B4BECF1220B55857A1DF064355AB306E9E9C3FEC3DC86FAFCC3A\n    pt = 0x91\n    ct = 0x7E0CF4C530ED36B947CA4C5D7DE0097A\n\nproperty tcId1029 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFC304BE2EBA8E1CD41680F2228E150718D829821F99994AC44D59C7494BDB6A8\n    pt = 0xC2\n    ct = 0xF125384DEE677C7923697F5A3BFC6184\n\nproperty tcId1030 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5D124C781D08A9A1EF74B9BFC5B92C093F47B6C20E566B12ECBC361813688F01\n    pt = 0x3D\n    ct = 0x8435A5CB88740BADEC2C57FE0BBA0DA8\n\nproperty tcId1031 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xAA5AB62D3DF457E141F244ECB7A1B02B7C849535F6114EE43FE5474FA7934D3E\n    pt = 0x19\n    ct = 0xF3E526B2D27DCAE85E3B603219079B17\n\nproperty tcId1032 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B2B4903C7F4FEBFE9600D357C043E891BC2659AA21694810AD9DF8DE2C5D87B\n    pt = 0x7F\n    ct = 0x9AE5B26B28514B2E02866F655689D8A2\n\nproperty tcId1033 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B7572593C032234A0047A9D2A92E9F7323226FD9879B8F8BF73631C16560922\n    pt = 0x5E\n    ct = 0x2E94CB8DFFCDA2399BC422B24928A91A\n\nproperty tcId1034 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x68380612EB8E22DC776E8D05BE01B619D0C1CB99EBC7947C8444CB26FEAC0E91\n    pt = 0xBB\n    ct = 0xAA6ABD32EA59851AFE3AD836727E5DC6\n\nproperty tcId1035 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xED0580C7DAB265D63DCCFEB165778BA3ADCC9C92D807B0DA7D08F05A2D1E0EF1\n    pt = 0xAB\n    ct = 0xC3DC9EA6773BA6B254156BCA2D6CCDC4\n\nproperty tcId1036 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x512E2D54D84820280EFEC1286247D6A17DC5A23F33FC1C32D5A023D38EE43B8E\n    pt = 0xF5\n    ct = 0x4E50FAEF7FEDF00A97744D1E50180D29\n\nproperty tcId1037 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCDDD9A61EE554E27E75D9D2A6905763363ABFDA1A2E0D1351CFAC3B870E72AB7\n    pt = 0x9C\n    ct = 0x13865E5DA697B608016326560370FC34\n\nproperty tcId1038 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xBCDA299791DF47EFEFA436000A4234F9F1DDB2959F7F5CECD7D114DA1555DF39\n    pt = 0x23\n    ct = 0x957A898CF5CA014FA0BC445FA0411B8E\n\nproperty tcId1039 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x14AC4E2D21736EDCC6D423E3AF1E2BC4E8115A9C190AFD7C5A764CB7FDEFE222\n    pt = 0x27\n    ct = 0x47F8738AE025CB323AA904BB8FC94D5A\n\nproperty tcId1040 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD780739A8A8F203E593DFA988C4BEDDAD17EC65E32FF9420E8B7B094AD3504CE\n    pt = 0xA4\n    ct = 0x0ACA7980AA5D91E7CF8A7FF32ACFB820\n\nproperty tcId1041 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFE9E71CE3F0372783D47D1219919A9176DBBA7E1E7BB0E6BD94599DA51F616EA\n    pt = 0x18\n    ct = 0x4BEF98A1A912C5CCFB44398501393A5B\n\nproperty tcId1042 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD067989158B5C486D6CB2317DC4A1F174EDA232A5D0572313666B602F80FAA82\n    pt = 0x87\n    ct = 0x1622F42C6EB932C9C3BA6EE528F5EE2E\n\nproperty tcId1043 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF08EAD0CDBBCC69EF06549FAED6989E5177678A31CDE24081E962C06F80DFFF1\n    pt = 0xB6\n    ct = 0xA164FE1AAC233A7B292190106242BC35\n\nproperty tcId1044 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x6FFA0B069567D8B8CF189E1E651126E16432F4B1DF14D28C7930F167D90E71DC\n    pt = 0xBC\n    ct = 0x81AF399406890408830494067B975DC3\n\nproperty tcId1045 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF0D9A00431BFC37776632DCE8392FB668738B8E7E87B32FE6970AEDE141DBB12\n    pt = 0x15\n    ct = 0x21A2E83460738D67E274DE0231F5DB08\n\nproperty tcId1046 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x8758E274D03DE0037EB638671BF7A5762262CD81FA4710612F0F8C00DD544FD2\n    pt = 0x10\n    ct = 0xB58EF1C43EF4FB8D25C53D673C074A9F\n\nproperty tcId1047 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x611CB910E6F3554891709BE3269311CAEEA4167646770C93B1EB24150B08E7FF\n    pt = 0xAE\n    ct = 0xC4D38071B0325A7DBAE7B8C97E140567\n\nproperty tcId1048 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x595D643FEE1B9DA657E5E0DD89BEA95FBA9D60A9F569E5BD2263ECDA865B6397\n    pt = 0x8A\n    ct = 0x291C122B76FF48EB7A9B1A25C20FF3E9\n\nproperty tcId1049 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF66827A982352FB10D7BD294A6DA6661B9593E850D9AEE8C7E2C2F0662B66609\n    pt = 0x1A\n    ct = 0x8320E7CDE94090DDB0AFA279F71CF86C\n\nproperty tcId1050 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x927B27D5B50BA9D198E9EECD1317FD659A80F9E061A2703E797B61D420C7164D\n    pt = 0x62\n    ct = 0xEF84DE1F6C508958F7ADC6D11C606DB8\n\nproperty tcId1051 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF416A4C6552B4E2E2D5F88C6AF5494C4EA1D04BB22A377C0806611418475F1F8\n    pt = 0x10\n    ct = 0x562ADB01EA14439CE1D8A6FBA46515F4\n\nproperty tcId1052 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x42EE175CB7A7F28620500AE8856C7CDE3C4052FBA5ABF91C9E91E20857AF5066\n    pt = 0x29\n    ct = 0xB5465699DD3DC2969DCF8B1DA3C0DFCC\n\nproperty tcId1053 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD9C652FA5E6A16E51DC513B53AFBC7E6624B8C3E4E3C58CD223320228EEE5DFD\n    pt = 0x55\n    ct = 0x0AD61A07DB5EC915C16F1A320BF0EAED\n\nproperty tcId1054 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x070FDEE3C8E60C382E9EFB3E61AD9B84620F2513F25DE9A535C344774F14BBC0\n    pt = 0xA4\n    ct = 0x906B0FA922E825B9375863FCA511B446\n\nproperty tcId1055 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x965B12BA6F405A1C99A702AC08084090FD80854BF5C09D00D1CBF8020E1FC853\n    pt = 0xEE\n    ct = 0x338C2D6EF2A4F0215F32117A6999E2FE\n\nproperty tcId1056 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x16E8974B487171A030AB25FE03E5789772A2A91E4FBBEFA62A2C3957AC69DAC3\n    pt = 0x51\n    ct = 0xFE89DB7AB88A6A50DBC7B4BBFD7C7D19\n\nproperty tcId1057 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9A729225A773F82968D4E4A61F67F7FEFA1C1EB951506220D2B44FB4EF06C54A\n    pt = 0xFD\n    ct = 0xBC7ED8E326F929CD1CF2939519972DB5\n\nproperty tcId1058 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x41472533F605B84462AD4C8FD062FC9B24B9EE7EBA935D0ECA424D2AB503DEF8\n    pt = 0xF9\n    ct = 0x32746F33EC7A049B4A3C48BD0ED21CE8\n\nproperty tcId1059 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x80F14DD8F5F9EF689A6840363AD88F58DE0EDCDB74700BA33A7DD923FDCB5DAD\n    pt = 0x29\n    ct = 0xF34CACF3816972C90A4AF0E67E7AED85\n\nproperty tcId1060 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xBD62F4F0449F892825008928D877A7543FADFAD05D3877033FFBD343EB83E622\n    pt = 0xD7\n    ct = 0x54F7EF87C184A81009EBF9BF6688CD7C\n\nproperty tcId1061 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x44D2B78F5FD38A5F681DA45F2FD177AFC122B7E780BB516AF29D928F3A17DAF5\n    pt = 0xD2\n    ct = 0x286F752B981CE6847661E0DCDD4D5F49\n\nproperty tcId1062 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x19556188E0349531F56D4144DAD2E5E0F6FFD349E017EFD31A05DB09291ED515\n    pt = 0xEF\n    ct = 0xE6DFA16F00FA7241F84E614649045B40\n\nproperty tcId1063 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC2DF0F8EC128AC630349FA9E452A2A8A10B500E00B9524E146518780EE62B117\n    pt = 0x81\n    ct = 0xDF68CB42ED2761D74BEBCE73E590A4DF\n\nproperty tcId1064 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x4E88503C08AD7EF21832B200F39489D3C5457CDB45912DAA380A6DF414B125C8\n    pt = 0x2D\n    ct = 0x52D5A548C2E4D287DCAAFE03E016AD79\n\nproperty tcId1065 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xA45AFB02BF762298F315E033B04325127E9DC8F237261DDB114D384B44571929\n    pt = 0x42\n    ct = 0xCD487595DFE7F933FEF5B10587AC8981\n\nproperty tcId1066 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x7FB2623EBF05DBAEBD5122920E97DFFF06F57C838DA933538C97FAD59E25EB8A\n    pt = 0x77\n    ct = 0x8A5F782FBED1132D0636F53A51CDBF79\n\nproperty tcId1067 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x150F4FB634BAC25DE6992583F54DD734173E93AB43F63594832D9287778AD0EE\n    pt = 0x7A\n    ct = 0x799C8243EF5EF87891E005B506BF2F64\n\nproperty tcId1068 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B6CF52B74C43964097B6E38D37E01D673FB71F23C3329581F6409D8ED32A16E\n    pt = 0x4D\n    ct = 0xF293CE2D1F9C6725E1F9F107421AC396\n\nproperty tcId1069 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2644CCF9D7C419A437C954C8141CBB2D60F57DE10A5393554A14CCC72229E286\n    pt = 0xE0\n    ct = 0xDA510B1D9A10255380655980A3A73536\n\nproperty tcId1070 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5A2BF1A5098964EEC4D82F7E7C2D5723A5777F202E5CF729B506A5DC9775F1DE\n    pt = 0x11\n    ct = 0x19B164EFC41F5FFF402A1097CD89259C\n\nproperty tcId1071 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9B35B7F2AB8EEBA30101BC8D0BF94B09C8EA02114ED9912F7659967DC3C7D841\n    pt = 0x71\n    ct = 0xC788AB3CE96444554BBA805A1E3A8F91\n\nproperty tcId1072 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B7783AD07911FC6D685E60FCB1213EDFF5DCD7EAC1D73DA2685585AE4C39177\n    pt = 0x3E\n    ct = 0x0EA7AB3B26CDA9612A508EF9B41DB7C8\n\nproperty tcId1073 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFB56787EC73A1EED0C9061D023A305AC301E2455E349B2E573F2AFE326709ADD\n    pt = 0xC1\n    ct = 0x2C713F375FDD12469E753C68BAEAC6D4\n\nproperty tcId1074 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1AC45D1DB5E960DECD86AEA2507F1CD51EAC9BD3EA8B6093D4A795EFCA7187B0\n    pt = 0x73\n    ct = 0x24B65C239B23D8C8F44EC2721ED03B15\n\nproperty tcId1075 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDE8A1521277486D6FCDA3A24031DEE8647344F88A051A4DA7F452A7036DAA8C0\n    pt = 0x5E\n    ct = 0x708D55D92DB692A62CBA3CA4D009C8CE\n\nproperty tcId1076 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xA66E6DA21D52FC24733C303A121AD10626A5194884054CF8B73E7A71AA49380B\n    pt = 0xD3\n    ct = 0x7AD507B5FA5CD4A98C797A8DD824923F\n\nproperty tcId1077 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCC3710FD1C78A8B019AE0E8608E5C60F614D1F043196A3D87A67074A267B5542\n    pt = 0x02\n    ct = 0xF02A71952C7F74D6F509D0DA905B5E44\n\nproperty tcId1078 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x371EEFF5ACEC4E980CA59E9D91BEBF9B1B8013B3340BC45D624F0AA0943118DA\n    pt = 0x74\n    ct = 0x7BD179C985A426CD4FF9BFBEF858436E\n\nproperty tcId1079 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x54D9324535DAC6090439406626141312CB4A61ADC61189947D5572FBD326CB57\n    pt = 0x7F\n    ct = 0xFF0061FC09D685215C4B22BE822405FD\n\nproperty tcId1080 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3EA9325069ED93A96C331BDD6DD766EC64BBBA83A72C69ED75DF55043FB0BFD1\n    pt = 0x06\n    ct = 0x40A9C42012BA38211B800E6E313B6876\n\nproperty tcId1081 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2C0CD8480E0768FB9E33A9929F3991A0DE0B0AC1F35D0CB7E58757A9D28D49D4\n    pt = 0x06\n    ct = 0xCADAD5CFD536F7BA6897EF398483F38F\n\nproperty tcId1082 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2BB319F216DBBA31EB4BB3265FF85D13ABD8B12083DC0CD48C40372C946F70D5\n    pt = 0xE5\n    ct = 0x85427703FBC3BE25BE88765DC8791554\n\nproperty tcId1083 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD393149C58FDB23C4ABDF43EE03D603DEB1FD06CD625F821FF93B27376458C9E\n    pt = 0x1B\n    ct = 0x3D737A3A014ABDDA0BE2696C8097EE95\n\nproperty tcId1084 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x03353DEAB5D9CD40338E8ECC8D810DE4E29B6D34CF158F68DB5AE356A4225266\n    pt = 0x8D\n    ct = 0x9313D7D59E08024181C2146F9123A78F\n\nproperty tcId1085 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x0CFD3A3B0540E5B3F044EB60050FEAFC80BAC758DB99016F79F0F5BF80307779\n    pt = 0xFC\n    ct = 0x02EC669FB26BDCDCC398545D7BDBDEC7\n\nproperty tcId1086 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x4CBC12CEE939C4F915DAE23A4B6F30B8B45734686067B27BF592BCF929C7E75E\n    pt = 0x34\n    ct = 0x5965D7F3EE0A4940BADDDFFA05A30BF4\n\nproperty tcId1087 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1BAD340ABB934070C9B7662815BB7BAA652A056CCF246A375B6D959ADD5D7DEC\n    pt = 0x2A\n    ct = 0xEED916D3195F9C39406802285CA665D3\n\nproperty tcId1088 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xB0D6764B9B604A44D6A201A07E1F3CFCD0DA1A322DAA1251EFA19C12A8488D0E\n    pt = 0x8A\n    ct = 0xFE2A001CB35F00EAF85614EC594E2D9F\n\nproperty tcId1089 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x59BB9A295C7263842521D5F1EDD2DB92D9F09A607F758E2E3EF8CA6137616C93\n    pt = 0xB0\n    ct = 0x4AE1CF2A3BBD5BC2573D8A13212E445A\n\nproperty tcId1090 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x07E0C27A362DFB87EDE1B5E0A1790FA3FB09A99E12A6A71EB0A41B6356C9CC92\n    pt = 0xAC\n    ct = 0x70D749E0C9C77A0EDD98F8BCE3753733\n\nproperty tcId1091 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x50E530EF3EB1A1BAE45B8263BA7E30F6F5A7D2418F3611E30830C87D741647CD\n    pt = 0xFB\n    ct = 0x4FAA8357F2F3EF340A5E8B7AA74DD290\n\nproperty tcId1092 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xE1DE28540953AAF2AFB9EEF0DDBD08B5A1AAB73EECDD2F0E85F8915C94699E4A\n    pt = 0x17\n    ct = 0xC686DC8FE198F9D36374F5C56B99E3DF\n\nproperty tcId1093 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFBDCABF978959C69724C63165A17DB5F1FA7FC2871F9BDFC799391C908F78F6C\n    pt = 0xC8\n    ct = 0xB6B5D8288DAFE8F8584514B5193EEEFE\n\nproperty tcId1094 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x417887E598A05E102E6C651F6900C22412DEB49140585A650DECA9B1BA211B1E\n    pt = 0x72\n    ct = 0x5B0B9FAB5479528F87EB3C91225BB64D\n\nproperty tcId1095 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3BDBA3053CC76471EA0D78531BBA04A9584995BE194A348185698FE4D1338BBE\n    pt = 0xFA\n    ct = 0xF56924CE90ED7C0A79B8CAA4101D1DBC\n\nproperty tcId1096 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9DDFEA3DA8FF9F5401D5BDBBE520E4D47263E5B268BB15DC6FD62939FFA49377\n    pt = 0x58\n    ct = 0x01F0962438250AAEEDF8069D7CFD1F95\n\nproperty tcId1097 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x59DE802DC7805F487E4537941C71A24317B585BD58CC1FF9B5AC18FFA78E74A3\n    pt = 0x0E\n    ct = 0x2B7E6ACDA4967F644662A58CE8077917\n\nproperty tcId1098 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x35F2322E2999AAA3BEBA5E33A237E9D84DF0DA5BB732370AAEF97316F78DD413\n    pt = 0x1E\n    ct = 0x8A4DBD736974C2E73DD27C5E47955D94\n\nproperty tcId1099 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x45D780CFD96B54CF1AB425FAA701645B0FC5F84AA385B1372771BD7AD6109F0F\n    pt = 0xFC\n    ct = 0xA2E47585D0D8F81BA155324417EC2571\n\nproperty tcId1100 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDF9F0529DBBABA0D2A925AD2E0B81E01A0386DFC2033D3D6D446845957C02A15\n    pt = 0x0A\n    ct = 0xF6B6398CA55ACE0222A9391FD81CD276\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of AES128 CBC mode encryption and decryption using the provided test vectors. Ensure the properties prove that encrypting the plaintext with the given key and IV produces the expected ciphertext, and that decrypting the ciphertext with the same key and IV recovers the original plaintext."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CBC as AES128_CBC\n\n\/**\n * ```repl\n * :prove aes128_cbc_encrypt_vector\n * ```\n *\/\nproperty aes128_cbc_encrypt_vector = (AES128_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x7649abac8119b246cee98e9b12e9197d,\n        0x5086cb9b507219ee95db113a917678b2,\n        0x73bed6b8e3c1743b7116e69e22229516,\n        0x3ff1caa1681fac09120eca307586e1a7]\n\n\/**\n * ```repl\n * :prove aes128_cbc_decrypt_vector\n * ```\n *\/\nproperty aes128_cbc_decrypt_vector = (AES128_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0x7649abac8119b246cee98e9b12e9197d,\n        0x5086cb9b507219ee95db113a917678b2,\n        0x73bed6b8e3c1743b7116e69e22229516,\n        0x3ff1caa1681fac09120eca307586e1a7]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_KeyWrapPadded_AD.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that verify the correctness of the AES-256 Key Wrap with Padding authenticated decryption function (KWP_AD) using the provided test vectors. Each property should check that decrypting the given ciphertext with the specified key yields the expected plaintext when decryption succeeds, and correctly fails otherwise. Include properties that correspond to each test case in the file, reflecting both passing and failing cases."},{"role":"assistant","content":"```cryptol\n\/**\n * Test vectors for AES key wrap with padding's authenticated decryption\n * function from NIST's ACVP cryptographic validation program.\n *\n * These values are specifically drawn from the `internalProjection.json` file,\n * specifically the section with group ID `\"tgId\" : 35`.\n *\n * [ACVP]: NIST. usnistgov. GitHub repo \"ACVP-Server\".\n *     @see https:\/\/github.com\/usnistgov\/ACVP-Server\/tree\/master\/gen-val\/json-files\/ACVP-AES-KWP-1.0\n *\n * Rather than decorate every property, we use a single docstring up here:\n * ```repl\n * :exhaust\n * ```\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_KeyWrapPadded_AD where\n\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap\n\ncheck_KWP_AD key pt ct = case KWP_AD key ct of\n    Some pt' -> pt == pt'\n    None -> False\n\nproperty tcId3401 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1C8AB00037582D4E850D92E4244B6229D1FA54D6A0B1D1B71D43C0E45C544A18\n    pt = 0x3E\n    ct = 0x4358AA665202E40D725B01FEB065AABF\n\nproperty tcId3402 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA2423B2160857B73A2ED23C995F8374B7DFB2BA458B781131CF7DC4A5B370669\n    pt = 0x44\n    ct = 0x581BA83958B7528436CF9EA163E4873F\n\nproperty tcId3403 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x084D092899BC5F76288CFD7C45C336380BD2D768C98C5144B20D5612CA9CF598\n    pt = 0x59\n    ct = 0xC1B83872E7B0FC48156A06154219A608\n\nproperty tcId3404 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x518594C8D42412C9EDFB1E17E821B37DA0A020CAF4620FF2298AF4254EA0CFB3\n    pt = 0xB8\n    ct = 0x74C938C320B03451ED58DE73BFCAEE25\n\nproperty tcId3405 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x7F45132EE8CD57D9EADB90F15506D716311F2A226CB38D545F5BA4A76E065C90\n    pt = 0xAF\n    ct = 0x43AD1FAC8D9A4878414BC5D224856FC2\n\nproperty tcId3406 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x37839C73459186707F2C53440AA3E7A294A52481C6A8E72BF8FF44A61DC3C94A\n    pt = 0x3B\n    ct = 0x670DDA784A6F7B8629CC487125D83D82\n\nproperty tcId3407 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x699A20B3FED880092AC54A072D0F1944E5AC618E89BF6D82D85B8149409E0A69\n    pt = 0xC7\n    ct = 0xDA945A1E4ADD229EA2628BD2CBF648C5\n\nproperty tcId3408 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF39BBB0C6D6A48FFCD19A8E4FF8EC4D18DB342984D56204A72CC79EA4D331527\n    pt = 0x13\n    ct = 0x731375F0AAAE126D698A3A35C1B59BB4\n\nproperty tcId3409 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x2CC17C155EAED98EE7C5C988A4652BBC1E548D83E355EF2B9CAAB553E33248D1\n    pt = 0xE8\n    ct = 0x9ACE37E97BF83606F87F2C37F2DD0495\n\nproperty tcId3410 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x6EC1F03FE2E913911497B56C997AA18573FADAF5D3D40B5C3AE20C122D57CA26\n    pt = 0x0F\n    ct = 0x9EA3A713894A9A60EC886F994F6E6964\n\nproperty tcId3411 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x222373119D81095C1EA6BC266B7BAC7CC5338B183491E464517F6A1CEE323D72\n    pt = 0x24\n    ct = 0xC4684B34339464E99D38883F4E218D43\n\nproperty tcId3412 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x0E16E4ED5AE9010E977FC718B0A196D05C4EC8CC03881E9498798221CEEF4F60\n    pt = 0x59\n    ct = 0x45E26A81F2A3F3B36F6A1DFD5794339E\n\nproperty tcId3413 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF7C0B2E09007A87A2C6C02F547AE13D315D9F40E8432E2883EBAAD360AE58154\n    pt = 0x28\n    ct = 0xC6EADFAE6689D612BD7720A5FFDF6917\n\nproperty tcId3414 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1E094BFD3FD9FA39528B0A041943F26A146E1B6FFA9B89DBB3F3629E248786B3\n    pt = 0xD9\n    ct = 0x5900AC3014005CD4CB5B58D464D77851\n\nproperty tcId3415 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x2D72DDE845897E8DD914977D23B9C53A3C682F5322923F609786C0DEC4B9B391\n    pt = 0xF7\n    ct = 0x6F26295442B138B9B8559BDF24559292\n\nproperty tcId3416 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD4E74B1FB2D1B8A3A96D69484A3C14D6DAADCAAE26CF0D8C69FE1FF48FFCE55B\n    pt = 0x50\n    ct = 0x8E584B2DE61B3A7408E9CA039A5A2D3F\n\nproperty tcId3417 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8D2E8DC1019C058E0120F7BD454FEB9D2A0CF49C476215D9E1B36EBE31AA8E60\n    pt = 0xF6\n    ct = 0x89EE6AD335AB813F688EA34856C6CC62\n\nproperty tcId3418 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9EF5DA6F8AFEE4EC25A39C0BF3B4661CE1E60F4A08562803F9DAF43C1F5D901C\n    pt = 0x9D\n    ct = 0xF0B50CF34D7E9846BF0C63BC22C132C9\n\nproperty tcId3419 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x163668F7B7DEF32970EB681A9D9CBA20DD3612E48272C7F4ABB2BF32A6F07EC2\n    pt = 0x67\n    ct = 0x1CD75C122ECFBE1519FCC8266FD5BFBA\n\nproperty tcId3420 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8AAC75606AE5DD234EA1D037B220F89AE202BD465CC96CDC629D3AAF663D1811\n    pt = 0xFA\n    ct = 0x62845E954748CE3D22BC3DD347FCFF34\n\nproperty tcId3421 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xE46BBE8227B15C9F7EBC941D324D61A6D4539EE8557989F5D2B05F6EC9247238\n    pt = 0xBE\n    ct = 0xB26924971CA3A0593AD2D41330728677\n\nproperty tcId3422 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD541DD6C55C182DAE396180557E1527405E64C76072491162AEF584C3A723B8E\n    pt = 0x93\n    ct = 0x0ECF1EB9E9FC1A1B1F4061A2C6D8CB5E\n\nproperty tcId3423 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x448042C7E69DE6CD177324D07AA2B074F4914CCADF38E9BA241B847BFBE6A048\n    pt = 0xF8\n    ct = 0x5B16E3D2E4EB040700929EB1F3293826\n\nproperty tcId3424 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xE2FF9378361B637A9C7AB7991232E5C4E450F3F1884B99B32B35F3E483C63F02\n    pt = 0xC1\n    ct = 0x9694370FC567B3CCA1BF96BBC77F2924\n\nproperty tcId3425 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x71F1B8D033B2763D24C824BBC5C7B90F7465312EE68499AEB13936C6820D2DB8\n    pt = 0x41\n    ct = 0xEB1742979FF0D05DDA7A9AA4BC44A3DC\n\nproperty tcId3426 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x5B5D5403DC5F79CD612CE5BE434CDCB0CEF22A431BFFA8DFD03A40496867F36F\n    pt = 0x2A\n    ct = 0xEEF7F7FBA12F09C0E000D7DF78C3B7A7\n\nproperty tcId3427 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x4B6860891760551B1796F7EA2867B5F72CD55158751CECCDD07466B358E5DC2C\n    pt = 0x37\n    ct = 0xFC4728851CB09569B9C09F0DD974FC46\n\nproperty tcId3428 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8CC592A0827016D33FAC7046043CBA05F0F6D52360A131B68BB5CF3473D493E2\n    pt = 0xE9\n    ct = 0x6C4DA849D0312D2C1969F763FB0717EE\n\nproperty tcId3429 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA822410F60C3155AA4612A0A3D69FB6ABAE9CCCE764C45F0715167D4A29F92CC\n    pt = 0x60\n    ct = 0xFD4C6C336BF8189A6578C5D18755332D\n\nproperty tcId3430 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x4887BDA1567FA98C9E6C54A4C40ED9910888F0BB2F3092A990DD15A9FAF514E4\n    pt = 0xA1\n    ct = 0x6E8E313899901A660F45BE923325B3A0\n\nproperty tcId3431 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA34A8ACD5DE1D09B06C68A4BA6B26AD8849A96D097F7234CD87D0B22A77F64A1\n    pt = 0xF0\n    ct = 0x51A1D5CBBE044436F8E30F5EB9760A99\n\nproperty tcId3432 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA91FB46F7AE95553194F72BDE2DEC9C75CBE6F5D5CDA19CAE8DFEF10D2091878\n    pt = 0x49\n    ct = 0xAD8B08BC99A15AD1F61A534E6A6FD912\n\nproperty tcId3433 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBD31DE22B62709C3ADAE6A22C110AF041692A2EFF5AFD94D6F084A5AF7A10BA1\n    pt = 0x12\n    ct = 0xEA18D84DDEACDBFE6308356BD337389E\n\nproperty tcId3434 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xAAA495706CD217702F6589F3A7DCF77796EB9AD9301DACB70679353895821116\n    pt = 0x98\n    ct = 0x570F464452070AB993FDBA098413FA2E\n\nproperty tcId3435 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA6D1836D8FC15DC6655A6AF3C9908D1A458115DE813874DA2A31BAF535F4B898\n    pt = 0xC4\n    ct = 0x52BDFE3157F7E5320FA33902FFE86D9C\n\nproperty tcId3436 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9A372C3FE4AA3D244D7A31F26BE0DC94321AE6A9D399A3024DF1D2FAE01F5D5A\n    pt = 0xA3\n    ct = 0x74785BCEB51BB5BBBF237D204DF5DC3D\n\nproperty tcId3437 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x18EDF67DCED65DB1106F9E95F6E9CA0BCCDDB9C1B0704800E79288B4348D5ED8\n    pt = 0x97\n    ct = 0x53A16352DC6466B129B98EB20E871CB2\n\nproperty tcId3438 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xCA6909990051E5A00B321DB36E9EDC37C21517D05412C27308FA6230B194F3D6\n    pt = 0x8C\n    ct = 0xFA3388CC18FE4DB12B286D78A88F43CE\n\nproperty tcId3439 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x53D9C10A1F2A520C799E17CA84A9F37B7E41C8A8366A0999E6C640B9084F8D89\n    pt = 0xA7\n    ct = 0xCD7DA687F90A8E5B5A8D752383E2A921\n\nproperty tcId3440 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x40DA3BF159117B28AF81C41329BEA2446B47BBA5AA3CFED9C9B6D0FCAC447A26\n    pt = 0xBB\n    ct = 0xB3EB65346F8509E074B4340B225748AF\n\nproperty tcId3441 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xCFD6EACDFE41A0716399AAD812A5904F43E46E94C8F33551244107CBD4454630\n    pt = 0x86\n    ct = 0xEF426FD61C094CB99E553FA242B35BC5\n\nproperty tcId3442 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFEEACB41470DF0A95D4D17413575ECBE4473501166E2B253AC69B769D1DE6EE4\n    pt = 0xD5\n    ct = 0x3B6CE49140A31C29E2B57082556D4655\n\nproperty tcId3443 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC37E571FA0B30A4C320000E46DE47D739D71E958E6D9B5BF165891FD76A2EB69\n    pt = 0x7F\n    ct = 0xCA0BD69463B6FE257339A6F352C383B7\n\nproperty tcId3444 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0xBF4D98E63641C3B0C6C87F94FFADD24E9447DAE3C8179057B992F3E87ABB9371\n    pt = 0x77\n    ct = 0x8C309F22B1A69A82FC959024D9A41055\n\nproperty tcId3445 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xB340E2147C24AA9245D32B44D81932486162078E04E8D604C3BEC77E80D00587\n    pt = 0x9F\n    ct = 0x08E763DE0E9BDB77652BE9F239E76C3A\n\nproperty tcId3446 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x64CC83AE40375F36DF9EFA92623952D9B921C193A303BA44EAF249173E75346A\n    pt = 0x2B\n    ct = 0x96249FF04AE658C774BB76543946F1A7\n\nproperty tcId3447 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xDBB7B9A24F84518CDF7BE4204966A4A82C14F1DF9D3EED53B85BAF4110D2E5A7\n    pt = 0x00\n    ct = 0xBED6EBF099BF397B9CEEE98862B02A82\n\nproperty tcId3448 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x7A07B0AA1E991FC058CF99123C3797A5088331724452A8E6C866456B88700E4E\n    pt = 0xAA\n    ct = 0x0D8879321C745BC971154AE83455FEBF\n\nproperty tcId3449 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x7F9D0A3C5A5778247C91729D9067A522DCBC440B40EABF50E2501C55AD2924F8\n    pt = 0x72\n    ct = 0x22FD8008FA349050267F2C690218E766\n\nproperty tcId3450 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x5E804B2481BC5FBE520F8039375C018037E3BBAECB2249700CCA6A7BD7AA5717\n    pt = 0x2C\n    ct = 0xA75D5317E32EC6AE64F52BDEDF66DF44\n\nproperty tcId3451 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x5C7BA7305D3B4F81FEC1C53743F8C303CB060E9F8CCE92F33653485C1AEF6DB6\n    pt = 0xD2\n    ct = 0x0BEDF4F707D2D7B9703934FDAAD3FEFD\n\nproperty tcId3452 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFB590D85CC2E6666135A6317F8464F3BE2657532F9CD34823C8F9CDD22547223\n    pt = 0xAB\n    ct = 0xB0CBDD6BF81C0518EFAC69E74A5BAEF3\n\nproperty tcId3453 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9FEDC13CB212B80795956FDE94F420032F24C8EAEAD55A5293316FADFCC633C5\n    pt = 0x77\n    ct = 0x7DD4C22110BFE0530FC441F53518F9D1\n\nproperty tcId3454 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x95AC358D0BB126E90D6F604B30129A2B7D830F479C759F3D53CF4C6F998D2117\n    pt = 0x2E\n    ct = 0xCC42D7BD7EC583B5CA43C0BB3B449144\n\nproperty tcId3455 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF7D14A80AA1CB08AEA6CF77961555983FD09F50FE37E3E99F9B521AB0742840F\n    pt = 0x0A\n    ct = 0xF5A1CC956791996B6D0273D8E206E59D\n\nproperty tcId3456 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBDD2F02BD33BE2B9B035B0D7CC3A284979AF20C8DD4FE8EE60DCEFDEF4381813\n    pt = 0xEE\n    ct = 0xECF28482AA1214D6880CB5A909D2C9BF\n\nproperty tcId3457 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xAE2F98FD07E2AAB3E0F790AA523C8B36C4063C22A60AE5FC2D2B54C8D46DF7EF\n    pt = 0xF2\n    ct = 0x4677BCCC99567C44FC8C7326AD57F4F9\n\nproperty tcId3458 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x3530B064609EA0F443877A7070CFFF076741C8374FA72268349450173167509F\n    pt = 0x0E\n    ct = 0xCF30EA838A02E16758F641463221386B\n\nproperty tcId3459 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xDFF4C1198259942F942B1F3525E34D091AFE20A84948FFD6C5ABF1887C2E7324\n    pt = 0x84\n    ct = 0xB73B2D548186990CF25BBC4133344B6E\n\nproperty tcId3460 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x4D2A4B5B3C0F1D90D51B48E72926D1FC584FCDDDCE5971B522E96D9CB10F88EA\n    pt = 0xA6\n    ct = 0x64A8CB69731FDD89376C06309DF26460\n\nproperty tcId3461 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBB3670D9C9E461428A80595F716E091B9F5DBF92228ABB1CD0DFB8596B2F69DA\n    pt = 0x9A\n    ct = 0xC552F589E5D11EFCA42051369F008785\n\nproperty tcId3462 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC4633D8B4A999ED5A664EA02DBC047ABDE3041905A0D06726D7D5C2C2651B3AA\n    pt = 0x36\n    ct = 0x0425D5CD3FE9666B0CCE3C98E280C205\n\nproperty tcId3463 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xEDDD75B989E10681C4AA0D8C6418EB981B69C894FD804D06DDE643D7F53582EB\n    pt = 0xC3\n    ct = 0x3A205767FC5EF65D8CB70E8725B836EA\n\nproperty tcId3464 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x374D48822E30895944C18518E02156238707664276D5A599BF2C390E5C840D91\n    pt = 0xE2\n    ct = 0x26C2CD7AF348C457B5D816182803EA92\n\nproperty tcId3465 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x2795AF727A53461AC2B969CE61708DEEB395DCE6FF17923AEFD57E6E0D4BF308\n    pt = 0x47\n    ct = 0x25F38BC30E500B77ABF0D5B6CB038AEB\n\nproperty tcId3466 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9689C4C49E152D4A554A69BB926A945AC737C6D191D1FA3EF65331D501689383\n    pt = 0x5A\n    ct = 0xA47247E3631B1648EF30CDA790B98B96\n\nproperty tcId3467 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1D3C20DB2B0DE8AB0F9597E1FD3448B80F571EFF3F327F6095614AAA9CAC9811\n    pt = 0xFE\n    ct = 0xF27A4B12E93D2DEB7697C85DA15B92E2\n\nproperty tcId3468 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x9F3AB283C68BC9F03EB9743F816683595FC3C8D71E738422240F473399768437\n    pt = 0x3A\n    ct = 0xC5E6F5DC654A03FE5577FBA06A22DAB7\n\nproperty tcId3469 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x74A9D44D89694D93A1B61BDD02A81E7966118603BDED187D6E1BC4B06894744A\n    pt = 0x66\n    ct = 0xCEEDBDB7D9FD68D8A77DDD7F1C77F8C1\n\nproperty tcId3470 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC3C6ECBA08443278A12A21A390802A3081BFFC3BEC67600F52FF7CA367885A98\n    pt = 0x65\n    ct = 0x2F266F5CE092FFC3F36F8614FDC20C83\n\nproperty tcId3471 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFA610A36F2ADBBE68D460C13ECEABF708F56796EA820915B63D4F3BE2FD984EE\n    pt = 0x8A\n    ct = 0x85469A8A8A8957547CEFD17E5ECFC85D\n\nproperty tcId3472 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD6611F782D10A57647974D5C656B7F7506E37535416326B219AF81BC4A8743BD\n    pt = 0x58\n    ct = 0xE64D8579FE6BB20D0AFE72488E1F3CD7\n\nproperty tcId3473 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x34FCB48486EF3B0ED9EC197F55EC38F291CC68B1F0F68DABEBBB2787E8756303\n    pt = 0xC4\n    ct = 0x936AFF79592C2759AF94E5B48B6C130C\n\nproperty tcId3474 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8CFF7404B9BE4A6E3122654AB28EB3C1A773BC4887192D02C6BB5B50FC33435C\n    pt = 0x90\n    ct = 0x799292C2391C29826E6FE4A48289A37F\n\nproperty tcId3475 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xB6FF2FBAE349BC523847288225C94A3B4B1FCD53947524929BE5198045F81F03\n    pt = 0x4C\n    ct = 0x93C4EBC6F811C7E5025BFB48439C002D\n\nproperty tcId3476 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x730721960D62212552AC8CA2F135A07E884DD33209FD5397EC4CC162D8547BDE\n    pt = 0x98\n    ct = 0x46E634181EFE6254399D78F25549D1D9\n\nproperty tcId3477 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFF2F2B2DC1C3ABFB36C5C2A67EB8FF4E9B2746D43FBE675AD19D15FA782F419C\n    pt = 0x92\n    ct = 0xEB7FC5493BB24DEE35746090C5337BC3\n\nproperty tcId3478 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x575A096AC3B257827DEE39BE44DB62C0B8C8993A0B058AA268CB9401365EE6CA\n    pt = 0x19\n    ct = 0xA36764DF638074D2DB73BA3C73311152\n\nproperty tcId3479 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF61E5A48BFC7142E210405A0063FD24005549DFC3D0CC426C9707D0E3F62EAB4\n    pt = 0x9A\n    ct = 0xEB6575503055566BFC4694FE71A7821F\n\nproperty tcId3480 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBD3D9ECC1F178756F685C94D82E322860C0080471948B1B3B7FFC7A4B0D32D8A\n    pt = 0xCE\n    ct = 0x7D98C641A46D8701F468347EAE06B222\n\nproperty tcId3481 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x44934AB4E3104CFD6BBF02FE2FBEFA40301DA33CD1383728A93D5C772CAAB2D0\n    pt = 0x67\n    ct = 0xC1A236A91FCEB0D4B673934F650B8164\n\nproperty tcId3482 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0xE0695B4D76C38ADF1699088111D2C119B8B3EADAD9D4A62CE6FEAC789BD99048\n    pt = 0x47\n    ct = 0x6F5B8A798E1C44DA653C50AF8B8E96E5\n\nproperty tcId3483 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xE37B904A857C891114209A80CDBAA6B9C372EACB9065D95FC4CE2593E81D6F14\n    pt = 0x4A\n    ct = 0x62A104566D84A2A6F0BD3759EB95B079\n\nproperty tcId3484 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x72A2CA6161F22236DDB39B345F72656ACE5FD1745F6185C839C51509444AE9B3\n    pt = 0x82\n    ct = 0x8EA924155A8F514C73C62250BD742EF4\n\nproperty tcId3485 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1F2801EE032D01D052CDE826C494EA5A5C5CAB39DC871E9B57F8E040D3982E2F\n    pt = 0x16\n    ct = 0xA238DCE4AF87DBB8D4244AEDB9A42CA1\n\nproperty tcId3486 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x70638F85B9B31FAC449DF6AA19FB451960B5EE5CEC6FF3C473AEF8C71615DF65\n    pt = 0x8A\n    ct = 0x21E951E1DEC5BC71F2FA4B0AA90C0ED0\n\nproperty tcId3487 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF64D02392D650E0865F0C18B62772F1C890798E22A1871754ACAE6176583967E\n    pt = 0x05\n    ct = 0x903545EF6A52EC670DD793F78A50B23A\n\nproperty tcId3488 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x629F665A6786B5BC6A604B9306FC7F9B9390B28DA404C1082939DB657D16E280\n    pt = 0x40\n    ct = 0x10067350D2DC09942720CEF27CB6EB9D\n\nproperty tcId3489 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x43C453F9A65CBCF3BCA65BDFC94EFB6DF647391E821ACFBB62DE786890FB8649\n    pt = 0x56\n    ct = 0x9228F1AFED0E44378E1CA3B60005DCC4\n\nproperty tcId3490 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC77DEADC06B1F73C13AADC4EB8E5571EA6BFE3F89600C1FB0EB005A4F96ADB85\n    pt = 0x54\n    ct = 0xEE488F48CC2248482856D2056385A722\n\nproperty tcId3491 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x41FF08CAFC5580110B07360491752DC4654A6CFA0023FF9B423370E48BA881EE\n    pt = 0x3F\n    ct = 0x149D9466A536B0E1C4CB5616D3626845\n\nproperty tcId3492 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x6563A6A6707CCB4CA7CA9AD828F0F94860B932502EA9E3E86E561AB219BF3EBE\n    pt = 0x36\n    ct = 0x9F934514BDCC514DDCBC77510CE6F05E\n\nproperty tcId3493 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x56D362245CA9C93774451E5193D3E54E928ABAD5F1DD0C34C1B6B19C8346458A\n    pt = 0xC2\n    ct = 0x31ACBD193BE3BDF7E4D398BA4F5CCF81\n\nproperty tcId3494 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x01BEA442DFCAE33FE752FCD7F029C0E48A2FEC00CD124FB99A777BA9D43EFADF\n    pt = 0xCA\n    ct = 0xF1F01B25DB56D08FF63B95F9A8320873\n\nproperty tcId3495 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x91B234088667FAD2E005E9791DB57B7E2E65D09442C4396A284ADBD18D58294A\n    pt = 0x51\n    ct = 0xF6501E880ACC1AD562C1589BA3DAE3B2\n\nproperty tcId3496 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD0846D465C055E3CCD45343B6BD9DC549DA718FE62842AA7C0E3D915DE176B14\n    pt = 0x3D\n    ct = 0x5F836DC239426A8AE06D5A40FA8FFE5A\n\nproperty tcId3497 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA9803E483158D203A22C48F9BABCBA8B4E25328A11BA1D310E57F0D7226EC355\n    pt = 0xD9\n    ct = 0x6AACCBB9DBD4B319E50898EB21BA7470\n\nproperty tcId3498 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x063726D0EB03547D726E9D10ACCCB3CFF01006209D7FB39C05211EC88EE37C7F\n    pt = 0x16\n    ct = 0x341CEB90D234A324941D12B2024EBC1E\n\nproperty tcId3499 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x245F675642C52A62E1AD864EDA33FA65006C8BCD3D360D5A3E54D3F0982E2A01\n    pt = 0x42\n    ct = 0x5424035C2260598A200029E0F7533CA4\n\nproperty tcId3500 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x63FEA6C364B3A9C7813472E289513ADC0631493A7C9014FFB395560F7C767E11\n    pt = 0x57\n    ct = 0x92AA71DCDE68A0DA1CDFC86DABF331AA\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_XTS.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and properties of the AES256_XTS block cipher mode as instantiated in the given module. Include properties that verify correct encryption and decryption, key handling, and compliance with the XTS mode standard using AES-256 as the underlying block cipher."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_XTS =\n    Primitive::Symmetric::Cipher::Block::Modes::XTS {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property specification that verifies the correctness of the AES256_CTR mode implementation by checking that encryption followed by decryption returns the original plaintext for arbitrary inputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR =\n    Primitive::Symmetric::Cipher::Block::Modes::CTR {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES192_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the AES-192 CFB mode encryption as instantiated in the given module. Include properties that verify the correctness of encryption and decryption, ensuring that decrypting an encrypted message with the same key and IV returns the original plaintext."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB =\n    Primitive::Symmetric::Cipher::Block::Modes::CFB {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_XTS.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the AES128_XTS block cipher mode as instantiated in the given module. Include properties that verify the correctness of encryption and decryption operations, ensuring that decryption is the inverse of encryption under the AES128 key and XTS mode parameters."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_XTS =\n    Primitive::Symmetric::Cipher::Block::Modes::XTS {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the AES128_CTR mode implementation in the given module. The properties should check that the CTR mode encryption and decryption behave as expected when instantiated with AES128, ensuring that decrypt(encrypt(plaintext, key, nonce), key, nonce) == plaintext for various inputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CTR =\n    Primitive::Symmetric::Cipher::Block::Modes::CTR {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the AES-256 CFB mode encryption and decryption as instantiated in the given module. Include properties that verify the correctness of encryption and decryption operations, ensuring that decrypting an encrypted message with the same key and IV returns the original plaintext."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CFB =\n    Primitive::Symmetric::Cipher::Block::Modes::CFB {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_KeyWrap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the AES-256 Key Wrap mode as instantiated in the given module. Include properties that verify the correctness of the key wrapping and unwrapping functions, ensuring that unwrapping the wrapped key returns the original key. Also, specify properties that check compliance with the AES Key Wrap standard using AES-256 as the underlying block cipher."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap =\n    Primitive::Symmetric::Cipher::Block::Modes::AESKeyWrap {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES192_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the AES-192 CTR mode implementation in the given module. Include properties that verify the correctness of encryption and decryption operations, ensuring that decrypting an encrypted message returns the original plaintext. Also, specify properties that confirm the CTR mode's counter increments correctly and that the implementation conforms to the AES-192 block cipher instantiation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CTR =\n    Primitive::Symmetric::Cipher::Block::Modes::CTR {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the AES128_CFB mode implementation defined in the module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB. Ensure the properties check that encryption followed by decryption returns the original plaintext and that the mode behaves as expected under various inputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB =\n    Primitive::Symmetric::Cipher::Block::Modes::CFB {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES192_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property specification that verifies the correctness of the AES192 CBC mode implementation in the module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CBC. The specification should check that encryption followed by decryption returns the original plaintext for arbitrary inputs and keys."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CBC =\n    Primitive::Symmetric::Cipher::Block::Modes::CBC {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the AES-256 CBC mode encryption and decryption functions as instantiated in the AES256_CBC module. Include properties that verify the correctness of encryption and decryption (i.e., decrypt(encrypt(plaintext, key, iv), key, iv) == plaintext) and ensure compliance with the CBC mode semantics using the AES-256 block cipher."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CBC =\n    Primitive::Symmetric::Cipher::Block::Modes::CBC {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the AES-128 CBC mode encryption and decryption operations as instantiated in the given module. Include properties that verify the correctness of encryption and decryption, such as that decrypting an encrypted message with the same key and IV returns the original plaintext."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CBC =\n    Primitive::Symmetric::Cipher::Block::Modes::CBC {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Tests\/tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the Simon block cipher encryption for all the given instantiations (Simon32_64, Simon48_72, Simon48_96, Simon64_96, Simon64_128, Simon96_96, Simon96_144, Simon128_128, Simon128_192, Simon128_256). The specification should capture the relationship between the key, plaintext, and ciphertext as demonstrated by the provided test vectors, enabling automated verification that the encrypt function produces the correct ciphertext for each key and plaintext pair."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Tests::tests where\n\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon32_64 as Simon32_64\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_72 as Simon48_72\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_96 as Simon48_96\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_96 as Simon64_96\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_128 as Simon64_128\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96 as Simon96_96\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_144 as Simon96_144\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128 as Simon128_128\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_192 as Simon128_192\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256 as Simon128_256\n\n\n\/**\n * A test vector for Simon32_64\n *\n * ```repl\n * :check t0\n * ```\n *\/\nproperty t0 = Simon32_64::encrypt k pt == ct\n  where\n    k = 0x1918_1110_0908_0100\n    pt = 0x6565_6877\n    ct = 0xc69b_e9bb\n\n\/**\n * A test vector for Simon48_72\n *\n * ```repl\n * :check t1\n * ```\n *\/\nproperty t1 = Simon48_72::encrypt k pt == ct\n  where\n    k = 0x121110_0a0908_020100\n    pt = 0x612067_6e696c\n    ct = 0xdae5ac_292cac\n\n\/**\n * A test vector for Simon48_96\n *\n * ```repl\n * :check t2\n * ```\n *\/\nproperty t2 = Simon48_96::encrypt k pt == ct\n  where\n    k = 0x1a1918_121110_0a0908_020100\n    pt = 0x726963_20646e\n    ct = 0x6e06a5_acf156\n\n\/**\n * A test vector for Simon64_96\n *\n * ```repl\n * :check t3\n * ```\n *\/\nproperty t3 = Simon64_96::encrypt k pt == ct\n  where\n    k = 0x13121110_0b0a0908_03020100\n    pt = 0x6f722067_6e696c63\n    ct = 0x5ca2e27f_111a8fc8\n\n\/**\n * A test vector for Simon64_128\n *\n * ```repl\n * :check t4\n * ```\n *\/\nproperty t4 = Simon64_128::encrypt k pt == ct\n  where\n    k = 0x1b1a1918_13121110_0b0a0908_03020100\n    pt = 0x656b696c_20646e75\n    ct = 0x44c8fc20_b9dfa07a\n\n\/**\n * A test vector for Simon96_96\n *\n * ```repl\n * :check t5\n * ```\n *\/\nproperty t5 = Simon96_96::encrypt k pt == ct\n  where\n    k = 0x0d0c0b0a0908_050403020100\n    pt = 0x2072616c6c69_702065687420\n    ct = 0x602807a462b4_69063d8ff082\n\n\/**\n * A test vector for Simon96_144\n *\n * ```repl\n * :check t6\n * ```\n *\/\nproperty t6 = Simon96_144::encrypt k pt == ct\n  where\n    k = 0x151413121110_0d0c0b0a0908_050403020100\n    pt = 0x746168742074_73756420666f\n    ct = 0xecad1c6c451e_3f59c5db1ae9\n\n\/**\n * A test vector for Simon128_128\n *\n * ```repl\n * :check t7\n * ```\n *\/\nproperty t7 = Simon128_128::encrypt k pt == ct\n  where\n    k = 0x0f0e0d0c0b0a0908_0706050403020100\n    pt = 0x6373656420737265_6c6c657661727420\n    ct = 0x49681b1e1e54fe3f_65aa832af84e0bbc\n\n\/**\n * A test vector for Simon128_128\n *\n * ```repl\n * :check t8\n * ```\n *\/\nproperty t8 = Simon128_192::encrypt k pt == ct\n  where\n    k = 0x1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n    pt = 0x206572656874206e_6568772065626972\n    ct = 0xc4ac61effcdc0d4f_6c9c8d6e2597b85b\n\n\/**\n * A test vector for Simon128_256\n *\n * ```repl\n * :check t9\n * ```\n *\/\nproperty t9 = Simon128_256::encrypt k pt == ct\n  where\n    k = 0x1f1e1d1c1b1a1918_1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n    pt = 0x74206e69206d6f6f_6d69732061207369\n    ct = 0x8d2b5579afc8a3a0_3bf72a87efe7b868\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon96_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Simon96_96 block cipher parameters and its encryption function based on the provided module. Then, create Cryptol properties to verify the correctness of the encryption and decryption operations, ensuring that decryption is the inverse of encryption for all valid inputs."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 48\n    type m = 2\n    type T = 52\n    type j = 2\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon96_144.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Simon96_144 block cipher parameters and its encryption function, ensuring that the implementation adheres to the Simon cipher specification for n=48, m=3, T=54, and j=3 as given in the module Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_144. Include properties to verify correct round transformations and key schedule behavior."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_144 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 48\n    type m = 3\n    type T = 54\n    type j = 3\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon64_128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Simon64\/128 block cipher parameters and behavior as given in the module Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_128. Include properties that verify the correctness of the key schedule and encryption rounds according to the Simon cipher specification."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_128 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 32\n    type m = 4\n    type T = 44\n    type j = 3\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon48_72.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Simon48\/72 block cipher parameters and operations as given in the Simon48_72 module. Include type definitions for block size, key size, number of rounds, and the round function. Then, write Cryptol properties to verify the correctness of the encryption and decryption functions, ensuring that decrypt(encrypt(plaintext, key), key) == plaintext for all valid inputs."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_72 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 24\n    type m = 3\n    type T = 36\n    type j = 0\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon128_128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Simon128_128 block cipher parameters and behavior as given in the module Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128. Include type definitions and constants for n, m, T, and j, and specify the encryption and decryption functions according to the Simon cipher specification."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 64\n    type m = 2\n    type T = 68\n    type j = 2\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon64_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Simon64\/96 block cipher parameters and operations as given in the module Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_96. Include properties to verify the correctness of the key schedule and encryption rounds according to the Simon cipher specification."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_96 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 32\n    type m = 3\n    type T = 42\n    type j = 2\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon128_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Simon128_256 block cipher instance using the given parameters (n=64, m=4, T=72, j=4). Then, create Cryptol properties to verify the correctness of the encryption and decryption functions, ensuring that decryption is the inverse of encryption for all valid inputs."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 64\n    type m = 4\n    type T = 72\n    type j = 4\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon128_192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Simon128_192 block cipher parameters and behavior as given in the module Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_192. Include type definitions and constants, and specify the encryption and decryption functions according to the Simon cipher specification referenced (Table 3.1). Ensure the specification is suitable for subsequent verification tasks."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_192 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 64\n    type m = 3\n    type T = 69\n    type j = 3\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon48_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Simon48\/96 block cipher parameters and its encryption function, including type definitions for block size, key size, number of rounds, and the round function. Then, write Cryptol properties to verify that the encryption and decryption functions are inverses of each other for all valid inputs."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Parameters are taken from Table 3.1 of the Simon documentation.\n *\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_96 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 24\n    type m = 4\n    type T = 36\n    type j = 1\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Tests\/tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that verify the correctness of the Speck block cipher encryption implementations (Speck32_64, Speck48_72, Speck48_96, Speck64_96, Speck64_128, Speck96_96, Speck96_144, Speck128_128, Speck128_192, Speck128_256) against their respective test vectors provided in the file. Each property should assert that encrypting the given plaintext with the specified key produces the expected ciphertext. Format the properties so they can be checked or proved using Cryptol's :check or :prove commands."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * Test vectors for Speck.\n * These test vectors were taken Appendix C of:\n *\n * [SPECK]: Beaulieu, Shors, Smith, Treatman-Clark, Weeks, Wingers\n *          The Simon and Speck Families of Lightweight Block Ciphers\n *          19 June 2013\n * @see https:\/\/eprint.iacr.org\/2013\/404.pdf\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Tests::tests where\n\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck32_64 as Speck32_64\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_72 as Speck48_72\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_96 as Speck48_96\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_96 as Speck64_96\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_128 as Speck64_128\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_96 as Speck96_96\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_144 as Speck96_144\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_128 as Speck128_128\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_192 as Speck128_192\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_256 as Speck128_256\n\n\/**\n * Test vector for Speck32_64\n *\n * ```repl\n * :prove t0\n * ```\n *\/\nproperty t0 = Speck32_64::encrypt k p == c\n    where\n        k = 0x1918_1110_0908_0100\n        p = 0x6574_694c\n        c = 0xa868_42f2\n\n\/**\n * Test vector for Speck48_72\n *\n * ```repl\n * :prove t1\n * ```\n *\/\nproperty t1 = Speck48_72::encrypt k p == c\n    where\n        k = 0x121110_0a0908_020100\n        p = 0x20796c_6c6172\n        c = 0xc049a5_385adc\n\n\/**\n * Test vector for Speck48_96\n *\n * ```repl\n * :prove t2\n * ```\n *\/\nproperty t2 = Speck48_96::encrypt k p == c\n    where\n        k = 0x1a1918_121110_0a0908_020100\n        p = 0x6d2073_696874\n        c = 0x735e10_b6445d\n\n\/**\n * Test vector for Speck64_96\n *\n * ```repl\n * :prove t3\n * ```\n *\/\nproperty t3 = Speck64_96::encrypt k p == c\n    where\n        k = 0x13121110_0b0a0908_03020100\n        p = 0x74614620_736e6165\n        c = 0x9f7952ec_4175946c\n\n\/**\n * Test vector for Speck64_128\n *\n * ```repl\n * :prove t4\n * ```\n *\/\nproperty t4 = Speck64_128::encrypt k p == c\n    where\n        k = 0x1b1a1918_13121110_0b0a0908_03020100\n        p = 0x3b726574_7475432d\n        c = 0x8c6fa548_454e028b\n\n\/**\n * Test vector for Speck96_96\n *\n * ```repl\n * :prove t5\n * ```\n *\/\nproperty t5 = Speck96_96::encrypt k p == c\n    where\n        k = 0x0d0c0b0a0908_050403020100\n        p = 0x65776f68202c_656761737520\n        c = 0x9e4d09ab7178_62bdde8f79aa\n\n\/**\n * Test vector for Speck96_144\n *\n * ```repl\n * :prove t6\n * ```\n *\/\nproperty t6 = Speck96_144::encrypt k p == c\n    where\n        k = 0x151413121110_0d0c0b0a0908_050403020100\n        p = 0x656d6974206e_69202c726576\n        c = 0x2bf31072228a_7ae440252ee6\n\n\/**\n * Test vector for Speck128_128\n *\n * ```repl\n * :prove t7\n * ```\n *\/\nproperty t7 = Speck128_128::encrypt k p == c\n    where\n        k = 0x0f0e0d0c0b0a0908_0706050403020100\n        p = 0x6c61766975716520_7469206564616d20\n        c = 0xa65d985179783265_7860fedf5c570d18\n\n\/**\n * Test vector for Speck128_192\n *\n * ```repl\n * :prove t8\n * ```\n *\/\nproperty t8 = Speck128_192::encrypt k p == c\n    where\n        k = 0x1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n        p = 0x7261482066656968_43206f7420746e65\n        c = 0x1be4cf3a13135566_f9bc185de03c1886\n\n\/**\n * Test vector for Speck128_256\n *\n * ```repl\n * :prove t9\n * ```\n *\/\nproperty t9 = Speck128_256::encrypt k p == c\n    where\n        k = 0x1f1e1d1c1b1a1918_1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n        p = 0x65736f6874206e49_202e72656e6f6f70\n        c = 0x4109010405c0f53e_4eeeb48d9c188f43\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck48_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Speck48_96 block cipher parameters and operations as given in the module Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_96. Include type definitions, key schedule, encryption, and decryption functions, ensuring they conform to the Speck cipher specification from the official documentation. The specification should be suitable for subsequent formal verification or property testing."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_96 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 24\ntype m = 4\ntype T = 23\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck32_64.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Speck32\/64 block cipher parameters and its encryption and decryption functions, based on the given module. Include properties to verify correctness of encryption and decryption (i.e., decrypt(encrypt(plaintext, key), key) == plaintext) and any relevant invariants for the cipher rounds."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck32_64 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 16\ntype m = 4\ntype T = 22\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck128_128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Speck128_128 block cipher using the given parameters (n=64, m=2, T=32) from the Speck documentation. Include properties that capture the expected behavior of the encryption and decryption functions, ensuring correctness and reversibility of the cipher operations."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_128 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 64\ntype m = 2\ntype T = 32\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck64_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Speck64\/96 block cipher parameters and its encryption and decryption functions, based on the given module. Then, write Cryptol properties to verify the correctness of the encryption and decryption operations, ensuring that decrypt(encrypt(plaintext, key), key) == plaintext for all valid inputs."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_96 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 32\ntype m = 3\ntype T = 26\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck128_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Speck128_256 block cipher using the parameters n=64, m=4, and T=34 as given. Include properties that verify the correctness of the encryption and decryption functions, ensuring that decrypt(encrypt(plaintext, key), key) == plaintext for all valid inputs."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_256 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 64\ntype m = 4\ntype T = 34\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck96_144.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Speck96_144 block cipher parameters and behavior as given in the module Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_144. Include type definitions for block size, key size, and number of rounds, and specify the encryption and decryption functions according to the Speck cipher specification."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_144 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 48\ntype m = 3\ntype T = 29\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck64_128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Speck64\/128 block cipher using the parameters n=32, m=4, and T=27 as given. Include properties that verify the correctness of the encryption and decryption functions, ensuring that decryption is the inverse of encryption for all valid keys and plaintexts."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_128 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 32\ntype m = 4\ntype T = 27\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck96_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Speck96_96 block cipher parameters and its encryption and decryption functions, ensuring they conform to the Speck cipher specification with block size 96 bits, key size 96 bits, and 28 rounds."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_96 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 48\ntype m = 2\ntype T = 28\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck48_72.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Speck48_72 block cipher parameters and its encryption and decryption functions, based on the given module. Include properties to verify the correctness of encryption and decryption (e.g., that decrypt(encrypt(plaintext, key), key) == plaintext) and any relevant invariants from the Speck cipher specification."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_72 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 24\ntype m = 3\ntype T = 22\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck128_192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the Speck128_192 block cipher parameters and its encryption and decryption functions, ensuring they conform to the Speck cipher specification for n=64, m=3, and T=33 rounds. Include properties to verify correctness such as encryption-decryption inverse and key schedule consistency."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\n * These parameters are taken from table 4.1 of the Speck documentation.\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_192 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 64\ntype m = 3\ntype T = 33\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Verifications\/AES256.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for AES256 that loads the LLVM module containing the AES256 encrypt and decrypt functions. Define a let-bound spec named aes256_encrypt_decrypt_spec that uses llvm_fresh_var to create symbolic inputs for the key and plaintext. The spec should call the encrypt function with the symbolic key and plaintext, then call the decrypt function on the ciphertext, and assert that the decrypted output equals the original plaintext. Include minimal preconditions to ensure valid input sizes and memory safety. Use llvm_verify to prove this spec against the corresponding LLVM functions. Reference exact function names as defined in the associated LLVM source files."},{"role":"assistant","content":"```saw\n\/**\n * Cryptol AES property verification.\n *\n * This module efficiently checks that decrypt is the inverse of encrypt.\n *\n * @copyright Galois Inc.\n * @author Eric Mertens <emertens@galois.com>\n *\/\n\nimport \"..\/Instantiations\/AES256.cry\";\nimport \"..\/..\/..\/..\/..\/..\/Common\/GF28.cry\" as GF28;\n\nlet ss0 = cryptol_ss ();\n\nprint \"Verifying that cipher unrolls\";\nunroll_cipher <- prove_print\n    (w4_unint_z3 [\"AddRoundKey\", \"MixColumns\", \"SubBytes\", \"ShiftRows\"])\n    {{ \\w pt -> cipher w pt ==\n    (stateToMsg (AddRoundKey (w@14) (ShiftRows (SubBytes (t 13 (t 12 (t 11 (t 10 (t 9 (t 8 (t 7 (t 6 (t 5 (t 4 (t 3 (t 2 (t 1 (AddRoundKey (w@0) (msgToState pt))))))))))))))))))\n        where\n        t i state = AddRoundKey (w@i) (MixColumns (ShiftRows (SubBytes state))))\n    }};\n\nprint \"Verifying that invCipher unrolls\";\nunroll_invCipher <- prove_print\n    (w4_unint_z3 [\"AddRoundKey\", \"InvMixColumns\", \"InvSubBytes\", \"InvShiftRows\"])\n    {{ \\w ct -> invCipher w ct ==\n    (stateToMsg (AddRoundKey (w@0) (InvSubBytes (InvShiftRows (t 1 (t 2 (t 3 (t 4 (t 5 (t 6 (t 7 (t 8 (t 9 (t 10 (t 11 (t 12 (t 13 (AddRoundKey (w@14) ( msgToState ct))))))))))))))))))\n        where\n        t i state = InvMixColumns (AddRoundKey (w@i) (InvSubBytes (InvShiftRows state))))\n    }};\n\ninclude \"Common.saw\";\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Tests\/AES256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the correctness of AES256 encryption and decryption against the provided NIST test vectors. The property should confirm that encrypting each plaintext with the given key produces the expected ciphertexts, and that decrypting each ciphertext returns the original plaintexts. Ensure the property can be used with Cryptol's :prove command to formally verify the AES256 implementation."},{"role":"assistant","content":"```cryptol\n\/**\n * Test vectors for AES256\n * These are drawn from the NIST Cryptographic Standards and Guidelines\n * project.\n *\n * [AES256]: AES Core 256. Block Cipher Modes of Operation Electronic Codebook\n *    (ECB). https:\/\/csrc.nist.rip\/CSRC\/media\/Projects\/Cryptographic-Standards-and-Guidelines\/documents\/examples\/AES_Core256.pdf\n *\n *  @copyright Galois Inc.\n *  @author Nichole Schimanski <nls@galois.com>\n *  @author Marcella Hastings <marcella@galois.com>\n *  www.cryptol.net\n *\/\nmodule Primitive::Symmetric::Cipher::Block::AES::Tests::AES256 where\nimport Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256 as AES256\n\n\/**\n * ```repl\n * :prove aes256TestVectorsPass\n * ```\n *\/\nproperty aes256TestVectorsPass = and encryptions \/\\ and decryptions\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        pts = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        expected_cts = [\n            0xf3eed1bdb5d2a03c064b5a7e3db181f8,\n            0x591ccb10d410ed26dc5ba74a31362870,\n            0xb6ed21b99ca6f4f9f153e7b1beafed1d,\n            0x23304b7a39f9f3ff067d8d8f9e24ecc7\n        ]\n        encryptions = [ AES256::encrypt key msg == ct | msg <- pts | ct <- expected_cts ]\n        decryptions = [ AES256::decrypt key ct == pt | pt <- pts | ct <- expected_cts ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Tests\/AES192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the AES192 encryption and decryption functions using the provided NIST test vectors. The properties should check that encrypting each plaintext with the given key produces the expected ciphertext, and that decrypting each ciphertext returns the original plaintext."},{"role":"assistant","content":"```cryptol\n\/**\n * Test vectors for AES192\n * These are drawn from the NIST Cryptographic Standards and Guidelines\n * project.\n *\n * [AES192]: AES Core 192. Block Cipher Modes of Operation Electronic Codebook\n *    (ECB).\n *    @see https:\/\/csrc.nist.rip\/CSRC\/media\/Projects\/Cryptographic-Standards-and-Guidelines\/documents\/examples\/AES_Core192.pdf\n *\n *  @copyright Galois Inc.\n *  @author Nichole Schimanski <nls@galois.com>\n *  @author Marcella Hastings <marcella@galois.com>\n *  www.cryptol.net\n *\/\nmodule Primitive::Symmetric::Cipher::Block::AES::Tests::AES192 where\nimport Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192 as AES192\n\n\/**\n * ```repl\n * :prove aes192TestVectorsPass\n * ```\n *\/\nproperty aes192TestVectorsPass = and encryptions \/\\ and decryptions\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        pts = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        expected_cts = [\n            0xbd334f1d6e45f25ff712a214571fa5cc,\n            0x974104846d0ad3ad7734ecb3ecee4eef,\n            0xef7afd2270e2e60adce0ba2face6444e,\n            0x9a4b41ba738d6c72fb16691603c18e0e\n        ]\n        encryptions = [ AES192::encrypt key msg == ct | msg <- pts | ct <- expected_cts ]\n        decryptions = [ AES192::decrypt key ct == pt | pt <- pts | ct <- expected_cts ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Instantiations\/AES128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the AES128 block cipher as instantiated in the given module. Include properties that verify the correctness of encryption and decryption functions, ensuring that decrypt(encrypt(plaintext, key), key) == plaintext holds for all valid inputs. Also specify the key size and any relevant constraints from the AES128 standard."},{"role":"assistant","content":"```cryptol\n\/**\n * AES128.\n * @copyright Galois Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128 =\n    Primitive::Symmetric::Cipher::Block::AES::Specification where\n    type KeySize' = 128\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Instantiations\/AES256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the AES-256 block cipher, including its key size, block size, and core encryption and decryption functions, suitable for use in verification tasks."},{"role":"assistant","content":"```cryptol\n\/**\n * AES256.\n * @copyright Galois Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256 =\n    Primitive::Symmetric::Cipher::Block::AES::Specification where\n    type KeySize' = 256\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Instantiations\/AES192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the AES-192 block cipher, including its key size, encryption, and decryption functions, based on the given AES192 module. Ensure the specification captures the expected behavior and properties of AES-192 as per the AES standard."},{"role":"assistant","content":"```cryptol\n\/**\n * AES192.\n * @copyright Galois Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192 =\n    Primitive::Symmetric::Cipher::Block::AES::Specification where\n    type KeySize' = 192\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the HMAC and hmac_truncate functions as defined in the given module. Your properties should check that the HMAC implementation conforms to the FIPS-198-1 standard, including correct key expansion, inner and outer padding, and output truncation behavior. Include properties that validate the length constraints and the relationship between the full HMAC output and its truncated version."},{"role":"assistant","content":"```cryptol\n\/**\n * Implementation of Keyed-Hash Message Authentication Code (HMAC)\n * as specified in [FIPS-198-1], Section 4.\n *\n * @copyright Galois, Inc.\n * @author Eric Mertens <emertens@galois.com>\n * @author Alex J Malozemoff <amaloz@galois.com>\n * www.cryptol.net\n *\n * For discussion on security considerations while using HMAC, please see\n * [NIST-SP-800-107]. This has important security notes about choosing key\n * lengths, truncation, and the overall security strength of the algorithm.\n *\n * Sources:\n *\n * [FIPS-198-1]: National Institute of Standards and Technology.\n *     The Keyed-Hash Message Authentication Code (HMAC).\n *     (Department of Commerce, Washington, D.C.),\n *     Federal Information Processing Standards Publication (FIPS) NIST FIPS 198-1.\n *     July 2008.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.198-1\n *\n * [NIST-SP-800-107]: Quynh Dang. Recommendations for Applications Using\n *     Approved Hash Algorithms. NIST Special Publication 800-107 Revision 1.\n *     August 2012.\n *     @see https:\/\/doi.org\/10.6028\/NIST.SP.800-107r1\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Specification where\n\nparameter\n  \/** Block size (in bytes) of the input to the Approved hash function. *\/\n  type B : #\n\n  \/** Block size (in bytes) of the output of the Approved hash function. *\/\n  type L : #\n\n  type constraint (fin B, L <= B, width (8 * L) <= B, width (8 * (B + L)) <= B)\n\n  \/** An Approved hash function. *\/\n  H : {T} (width (8 * T) <= B) => [T][8] -> [L][8]\n\n\/**\n * Compute a pseudorandom block using the HMAC construction as\n * specified in [FIPS-198-1], Section 4.\n *\n * # Type parameters\n * - k: Length of secret key (in bytes)\n * - n: Length of input text (in bytes)\n *\n * # Parameters\n * - K: Secret key shared between the originator and the intended receiver(s).\n * - text: The data on which the HMAC is calculated. text does *not* include\n *         the padded key. The length of text is n bits, where 0 \u2264 n < 2^B - 8B.\n *\/\nhmac : {k, n} (width (8 * k) <= B, width (8 * (n + B)) <= B) => [k][8] -> [n][8] -> [L][8]\nhmac K text = H ((K\u2080 ^ opad) # H ((K\u2080 ^ ipad) # text)) where\n  \/* K\u2080: The key K after any necessary pre-processing to form a B byte key. *\/\n  K\u2080 = expand_key K\n\n\/**\n * Compute a truncated HMAC output.\n *\n * Truncation is implemented as defined in [FIPS-198-1], Section 5 and\n * [NIST-SP-800-107], Section 5.1.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: If collision resistance is required, \u03bb needs to be at least\n * twice the required collision resistence strength s (in bits) for the\n * truncated message digest (i.e., \u03bb \u2265 2s). See [NIST-SP-800-107], Section 5.1\n * for more details.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: If used within a digital signature, \u03bb needs to be at least\n * twice the desired security strength (in bits) required for the digital\n * signature. See [NIST-SP-800-107], Section 5.2.2 for more details.\n *\n * # Type parameters\n * - \u03bb: Length of truncated output (in bytes). \u03bb must be less than L\n *      ([NIST-SP-800-107], Section 5.1) and no less than 32 bits\n *      ([NIST-SP-800-107], Section 5.3.4).\n * - k: Length of secret key (in bytes)\n * - n: Length of input text (in bytes)\n *\n * # Parameters\n * - K: Secret key shared between the originator and the intended receiver(s).\n * - text: The data on which the HMAC is calculated. text does *not* include\n *         the padded key. The length of text is n bits, where 0 \u2264 n < 2^B - 8B.\n  *\/\nhmac_truncate : {\u03bb, k, n} (\u03bb < L, \u03bb >= 4, width (8 * k) <= B, width (8 * (n + B)) <= B)\n  => [k][8] -> [n][8] -> [\u03bb][8]\nhmac_truncate K text = take output where\n  output = hmac K text\n\nprivate\n  \/** Inner pad; the byte x\u201836\u2019 repeated B times. *\/\n  ipad : [B][8]\n  ipad = repeat 0x36\n\n  \/** Outer pad; the byte x\u20185c\u2019 repeated B times. *\/\n  opad : [B][8]\n  opad = repeat 0x5c\n\n  \/** Key expansion as defined in [FIPS-198-1], Section 3. *\/\n  expand_key : {k} (width (8 * k) <= B) => [k][8] -> [B][8]\n  expand_key K\n    | k <= B => K # zero\n    \/*\n     * When an application uses a K longer than B-bytes, then it shall first\n     * hash the K using H and then use the resultant L-byte string as the key\n     * K\u2080.\n     *\/\n    | k > B => H K # zero\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Tests\/HMAC_SHA2_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that verify the correctness of the HMAC-SHA-512 implementation against the RFC-4868 test vectors provided in the file. Ensure the properties check both the full 512-bit HMAC output and the truncated 256-bit variant, using the given test cases as specifications."},{"role":"assistant","content":"```cryptol\n\/**\n * Test vectors for HMAC-SHA-512 found in [RFC-4868], Section 2.7.\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n *\n * Sources:\n *\n * [RFC-4868] S. Kelly, S. Frankel. Using HMAC-SHA-256, HMAC-SHA-384, and\n *     HMAC-SHA-512 with IPsec. Request for Comments: 4868. May 2007.\n *     @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc4868\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA2_512 where\n\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA512 as H512\n\ntype PrfParams K D =\n  { Key : [K][8]\n  , Data: [D][8]\n  , PRF_HMAC_SHA_512 : [512]\n  }\n\nprf_test : {K, D} (K < 256, D < 256) => PrfParams K D -> Bit\nprf_test params =\n  H512::hmac params.Key params.Data == split params.PRF_HMAC_SHA_512\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_1\n * ```\n *\/\nproperty rfc_4868_2_7_1_1 = prf_test\n  { Key = repeat`{20} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_512 =\n      0x87aa7cdea5ef619d4ff0b4241a1d6cb0 #\n      0x2379f4e2ce4ec2787ad0b30545e17cde #\n      0xdaa833b7d6b8a702038b274eaea3f4e4 #\n      0xbe9d914eeb61f1702e696c203a126854\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_2\n * ```\n *\/\nproperty rfc_4868_2_7_1_2 = prf_test\n  { Key = \"Jefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_512 =\n      0x164b7a7bfcf819e2e395fbe73b56e0a3 #\n      0x87bd64222e831fd610270cd7ea250554 #\n      0x9758bf75c05a994a6d034f65f8f0e6fd #\n      0xcaeab1a34d4a6b4b636e070a38bce737\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_3\n * ```\n *\/\nproperty rfc_4868_2_7_1_3 = prf_test\n  { Key = repeat`{20} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_512 =\n      0xfa73b0089d56a284efb0f0756c890be9 #\n      0xb1b5dbdd8ee81a3655f83e33b2279d39 #\n      0xbf3e848279a722c806b485a47e67c807 #\n      0xb946a337bee8942674278859e13292fb\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_4\n * ```\n *\/\nproperty rfc_4868_2_7_1_4 = prf_test\n  { Key = split 0x0102030405060708090a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_512 =\n      0xb0ba465637458c6990e5a8c5f61d4af7 #\n      0xe576d97ff94b872de76f8050361ee3db #\n      0xa91ca5c11aa25eb4d679275cc5788063 #\n      0xa5f19741120c4f2de2adebeb10a298dd\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_5\n * ```\n *\/\nproperty rfc_4868_2_7_1_5 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  , PRF_HMAC_SHA_512 =\n      0x80b24263c7c1a3ebb71493c1dd7be8b4 #\n      0x9b46d1f41b4aeec1121b013783f8f352 #\n      0x6b56d037e05f2598bd0fd2215d6a1e52 #\n      0x95e64f73f63f0aec8b915a985d786598\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_6\n * ```\n *\/\nproperty rfc_4868_2_7_1_6 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.\"\n  , PRF_HMAC_SHA_512 =\n      0xe37b6a775dc87dbaa4dfa9f96e5e3ffd #\n      0xdebd71f8867289865df5a32d20cdc944 #\n      0xb6022cac3c4982b10d5eeb55c3e4de15 #\n      0x134676fb6de0446065c97440fa8c6a58\n  }\n\ntype AuthTest512 T =\n  { Key : [64][8]\n  , Data : [T][8]\n  , PRF_HMAC_SHA_512 : [512]\n  , HMAC_SHA_512_256 : [256]\n  }\n\nsha2_512_auth_test : {T} (T < 256) => AuthTest512 T -> Bit\nsha2_512_auth_test params =\n  H512::hmac params.Key params.Data == split params.PRF_HMAC_SHA_512 \/\\\n  H512::hmac_truncate params.Key params.Data == split params.HMAC_SHA_512_256\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_3_1\n * ```\n *\/\nproperty rfc_4868_2_7_2_3_1 = sha2_512_auth_test\n  { Key = repeat`{64} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_512 =\n      0x637edc6e01dce7e6742a99451aae82df #\n      0x23da3e92439e590e43e761b33e910fb8 #\n      0xac2878ebd5803f6f0b61dbce5e251ff8 #\n      0x789a4722c1be65aea45fd464e89f8f5b\n  , HMAC_SHA_512_256 =\n      0x637edc6e01dce7e6742a99451aae82df #\n      0x23da3e92439e590e43e761b33e910fb8\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_3_2\n * ```\n *\/\nproperty rfc_4868_2_7_2_3_2 = sha2_512_auth_test\n  { Key = \"JefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_512 =\n      0xcb370917ae8a7ce28cfd1d8f4705d614 #\n      0x1c173b2a9362c15df235dfb251b15454 #\n      0x6aa334ae9fb9afc2184932d8695e397b #\n      0xfa0ffb93466cfcceaae38c833b7dba38\n  , HMAC_SHA_512_256 =\n      0xcb370917ae8a7ce28cfd1d8f4705d614 #\n      0x1c173b2a9362c15df235dfb251b15454\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_3_3\n * ```\n *\/\nproperty rfc_4868_2_7_2_3_3 = sha2_512_auth_test\n  { Key = repeat`{64} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_512 =\n      0x2ee7acd783624ca9398710f3ee05ae41 #\n      0xb9f9b0510c87e49e586cc9bf961733d8 #\n      0x623c7b55cebefccf02d5581acc1c9d5f #\n      0xb1ff68a1de45509fbe4da9a433922655\n  , HMAC_SHA_512_256 =\n      0x2ee7acd783624ca9398710f3ee05ae41 #\n      0xb9f9b0510c87e49e586cc9bf961733d8\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_3_4\n * ```\n *\/\nproperty rfc_4868_2_7_2_3_4 = sha2_512_auth_test\n  { Key =\n      \/\/ Corrected example from RFC\n      split 0x0102030405060708090a0b0c0d0e0f10 #\n      split 0x1112131415161718191a1b1c1d1e1f20 #\n      split 0x2122232425262728292a2b2c2d2e2f30 #\n      split 0x3132333435363738393a3b3c3d3e3f40\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_512 =\n      0x5e6688e5a3daec826ca32eaea224eff5 #\n      0xe700628947470e13ad01302561bab108 #\n      0xb8c48cbc6b807dcfbd850521a685babc #\n      0x7eae4a2a2e660dc0e86b931d65503fd2\n  , HMAC_SHA_512_256 =\n      0x5e6688e5a3daec826ca32eaea224eff5 #\n      0xe700628947470e13ad01302561bab108\n  }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Tests\/HMAC_SHA1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the HMAC-SHA-1 implementation produces correct outputs for the test vectors specified in RFC-2202 Section 3, including both full-length and truncated HMAC outputs."},{"role":"assistant","content":"```cryptol\n\/**\n * Test vectors for HMAC-SHA-1 found in [RFC-2202], Section 3.\n *\n * @copyright Galois, Inc.\n * @author Eric Mertens <emertens@galois.com>\n *\n * Sources:\n *\n * [RFC-2202] P. Cheng, R. Glenn. Test Cases for HMAC-MD5 and HMAC-SHA-1.\n *     Request for Comments: 2202. September 1997.\n *     @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc2202\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA1 where\n\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA1\n\ntype PrfParams K D =\n  { Key : [K][8]\n  , Data: [D][8]\n  , PRF_HMAC_SHA_1 : [160]\n  }\n\nprf_test : {K, D} (K < 256, D < 256) => PrfParams K D -> Bit\nprf_test params = hmac params.Key params.Data == split params.PRF_HMAC_SHA_1\n\ntype AuthTest T =\n  { Key : [20][8]\n  , Data : [T][8]\n  , PRF_HMAC_SHA_1 : [160]\n  , HMAC_SHA_1_96 : [96]\n  }\n\nsha1_auth_test : {T} (T < 256) => AuthTest T -> Bit\nsha1_auth_test params =\n  hmac params.Key params.Data == split params.PRF_HMAC_SHA_1 \/\\\n  hmac_truncate params.Key params.Data == split params.HMAC_SHA_1_96\n\n\/**\n * ```repl\n * :check rfc_2202_3_1\n * ```\n *\/\nproperty rfc_2202_3_1 = prf_test\n  { Key = repeat`{20} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_1 = 0xb617318655057264e28bc0b6fb378c8ef146be00\n  }\n\n\/**\n * ```repl\n * :check rfc_2202_3_2\n * ```\n *\/\nproperty rfc_2202_3_2 = prf_test\n  { Key = \"Jefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_1 = 0xeffcdf6ae5eb2fa2d27416d5f184df9c259a7c79\n  }\n\n\/**\n * ```repl\n * :check rfc_2202_3_3\n * ```\n *\/\nproperty rfc_2202_3_3 = prf_test\n  { Key = repeat`{20} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_1 = 0x125d7342b9ac11cd91a39af48aa17b4f63f175d3\n  }\n\n\/**\n * ```repl\n * :check rfc_2202_3_4\n * ```\n *\/\nproperty rfc_2202_3_4 = prf_test\n  { Key = split 0x0102030405060708090a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_1 = 0x4c9007f4026250c6bc8414f9bf50c86c2d7235da\n  }\n\n\/**\n * ```repl\n * :check rfc_2202_3_5\n * ```\n *\/\nproperty rfc_2202_3_5 = sha1_auth_test\n  { Key = repeat`{20} 0x0c\n  , Data = \"Test With Truncation\"\n  , PRF_HMAC_SHA_1 = 0x4c1a03424b55e07fe7f27be1d58bb9324a9a5a04\n  , HMAC_SHA_1_96 = 0x4c1a03424b55e07fe7f27be1\n  }\n\n\/**\n * ```repl\n * :check rfc_2202_3_6\n * ```\n *\/\nproperty rfc_2202_3_6 = prf_test\n  { Key = repeat`{80} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  , PRF_HMAC_SHA_1 = 0xaa4ae5e15272d00e95705637ce8a3b55ed402112\n  }\n\n\/**\n * ```repl\n * :check rfc_2202_3_7\n * ```\n *\/\nproperty rfc_2202_3_7 = prf_test\n  { Key = repeat`{80} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data\"\n  , PRF_HMAC_SHA_1 = 0xe8e99d0f45237d786d6bbaa7965c7808bbff1a91\n  }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Tests\/HMAC_SHA2_384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that verify the correctness of the HMAC-SHA-384 implementation against the provided RFC-4868 test vectors. Ensure the properties check both the full 384-bit HMAC output and the truncated 192-bit output for all given test cases."},{"role":"assistant","content":"```cryptol\n\/**\n * Test vectors for HMAC-SHA-384 found in [RFC-4868], Section 2.7.\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n *\n * Sources:\n *\n * [RFC-4868] S. Kelly, S. Frankel. Using HMAC-SHA-256, HMAC-SHA-384, and\n *     HMAC-SHA-512 with IPsec. Request for Comments: 4868. May 2007.\n *     @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc4868\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA2_384 where\n\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA384 as H384\n\ntype PrfParams K D =\n  { Key : [K][8]\n  , Data: [D][8]\n  , PRF_HMAC_SHA_384 : [384]\n  }\n\nprf_test : {K, D} (K < 256, D < 256) => PrfParams K D -> Bit\nprf_test params =\n  H384::hmac params.Key params.Data == split params.PRF_HMAC_SHA_384\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_1\n * ```\n *\/\nproperty rfc_4868_2_7_1_1 = prf_test\n  { Key = repeat`{20} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_384 =\n      0xafd03944d84895626b0825f4ab46907f #\n      0x15f9dadbe4101ec682aa034c7cebc59c #\n      0xfaea9ea9076ede7f4af152e8b2fa9cb6\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_2\n * ```\n *\/\nproperty rfc_4868_2_7_1_2 = prf_test\n  { Key = \"Jefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_384 =\n      0xaf45d2e376484031617f78d2b58a6b1b #\n      0x9c7ef464f5a01b47e42ec3736322445e #\n      0x8e2240ca5e69e2c78b3239ecfab21649\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_3\n * ```\n *\/\nproperty rfc_4868_2_7_1_3 = prf_test\n  { Key = repeat`{20} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_384 =\n      0x88062608d3e6ad8a0aa2ace014c8a86f #\n      0x0aa635d947ac9febe83ef4e55966144b #\n      0x2a5ab39dc13814b94e3ab6e101a34f27\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_4\n * ```\n *\/\nproperty rfc_4868_2_7_1_4 = prf_test\n  { Key = split 0x0102030405060708090a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_384 =\n      0x3e8a69b7783c25851933ab6290af6ca7 #\n      0x7a9981480850009cc5577c6e1f573b4e #\n      0x6801dd23c4a7d679ccf8a386c674cffb\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_5\n * ```\n *\/\nproperty rfc_4868_2_7_1_5 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  , PRF_HMAC_SHA_384 =\n      0x4ece084485813e9088d2c63a041bc5b4 #\n      0x4f9ef1012a2b588f3cd11f05033ac4c6 #\n      0x0c2ef6ab4030fe8296248df163f44952\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_1_6\n * ```\n *\/\nproperty rfc_4868_2_7_1_6 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.\"\n  , PRF_HMAC_SHA_384 =\n      0x6617178e941f020d351e2f254e8fd32c #\n      0x602420feb0b8fb9adccebb82461e99c5 #\n      0xa678cc31e799176d3860e6110c46523e\n  }\n\ntype AuthTest384 T =\n  { Key : [48][8]\n  , Data : [T][8]\n  , PRF_HMAC_SHA_384 : [384]\n  , HMAC_SHA_384_192 : [192]\n  }\n\nsha2_384_auth_test : {T} (T < 256) => AuthTest384 T -> Bit\nsha2_384_auth_test params =\n  H384::hmac params.Key params.Data == split params.PRF_HMAC_SHA_384 \/\\\n  H384::hmac_truncate params.Key params.Data == split params.HMAC_SHA_384_192\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_2_1\n * ```\n *\/\nproperty rfc_4868_2_7_2_2_1 = sha2_384_auth_test\n  { Key = repeat`{48} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_384 =\n      0xb6a8d5636f5c6a7224f9977dcf7ee6c7 #\n      0xfb6d0c48cbdee9737a959796489bddbc #\n      0x4c5df61d5b3297b4fb68dab9f1b582c2\n  , HMAC_SHA_384_192 =\n      0xb6a8d5636f5c6a7224f9977dcf7ee6c7 #\n      0xfb6d0c48cbdee973\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_2_2\n * ```\n *\/\nproperty rfc_4868_2_7_2_2_2 = sha2_384_auth_test\n  { Key = \"JefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_384 =\n      0x2c7353974f1842fd66d53c452ca42122 #\n      0xb28c0b594cfb184da86a368e9b8e16f5 #\n      0x349524ca4e82400cbde0686d403371c9\n  , HMAC_SHA_384_192 =\n      0x2c7353974f1842fd66d53c452ca42122 #\n      0xb28c0b594cfb184d\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_2_3\n * ```\n *\/\nproperty rfc_4868_2_7_2_2_3 = sha2_384_auth_test\n  { Key = repeat`{48} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_384 =\n      0x809f439be00274321d4a538652164b53 #\n      0x554a508184a0c3160353e3428597003d #\n      0x35914a18770f9443987054944b7c4b4a\n  , HMAC_SHA_384_192 =\n      0x809f439be00274321d4a538652164b53 #\n      0x554a508184a0c316\n  }\n\n\/**\n * ```repl\n * :check rfc_4868_2_7_2_2_4\n * ```\n *\/\nproperty rfc_4868_2_7_2_2_4 = sha2_384_auth_test\n  { Key =\n      split 0x0102030405060708090a0b0c0d0e0f10 #\n      split 0x1112131415161718191a1b1c1d1e1f20 #\n      split 0x0a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_384 =\n      0x5b540085c6e6358096532b2493609ed1 #\n      0xcb298f774f87bb5c2ebf182c83cc7428 #\n      0x707fb92eab2536a5812258228bc96687\n  , HMAC_SHA_384_192 =\n      0x5b540085c6e6358096532b2493609ed1 #\n      0xcb298f774f87bb5c\n  }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the HMAC_SHA512 module, including properties that verify the correctness of the HMAC construction instantiated with SHA2-512 as per RFC-4868."},{"role":"assistant","content":"```cryptol\n\/**\n * HMAC instantiated with SHA2-512 as defined in [RFC-4868].\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n *\n * [RFC-4868] @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc4868\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA512 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA2::Instantiations::SHA512\n  type B = 128\n  type L = 64\n  H = hashBytes\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the HMAC construction instantiated with SHA1 as given in the module Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA1. The specification should capture the expected behavior of the HMAC_SHA1 function, including its input-output relationship and properties such as correctness with respect to the underlying SHA1 hash function. Ensure the specification is suitable for formal verification or property checking."},{"role":"assistant","content":"```cryptol\n\/**\n * HMAC instantiated with SHA1.\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA1 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA1::Specification as SHA1\n  type B = 64\n  type L = 20\n  H text = SHA1::hashBytes text\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the HMAC_SHA256 module, including properties that verify the correctness of the HMAC construction instantiated with SHA-256 according to RFC-4868."},{"role":"assistant","content":"```cryptol\n\/**\n * HMAC instantiated with SHA2-256 as defined in [RFC-4868].\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n *\n * [RFC-4868] @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc4868\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA256 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256\n  type B = 64\n  type L = 32\n  H = hashBytes\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the HMAC_SHA384 module, including properties that verify the correctness of the HMAC construction instantiated with the SHA-384 hash function as per RFC-4868."},{"role":"assistant","content":"```cryptol\n\/**\n * HMAC instantiated with SHA2-384 as defined in [RFC-4868].\n *\n * @copyright Galois, Inc\n * @author Eric Mertens <emertens@galois.com>\n *\n * [RFC-4868] @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc4868\n *\/\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA384 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA2::Instantiations::SHA384\n  type B = 128\n  type L = 48\n  H = hashBytes\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/FNV.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the FNV-1a hash function implementation in the given module. Include properties that check the hash output for known inputs against expected constants, verify the padding behavior, and ensure the block function correctly updates the hash state. The properties should be suitable for use with Cryptol's :check or :prove commands to validate the implementation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::FNV where\n\nfnv1a : {n} (fin n) => [n] -> [64]\nfnv1a ws = fnv1a' (pad ws)\n\npad : {msgLen} (fin msgLen) => [msgLen] -> [msgLen \/^ 8][8]\npad msg = split (msg # (zero:[msgLen %^ 8]))\n\nfnv1a' : {chunks} (fin chunks) => [chunks][8] -> [64]\nfnv1a' msg = Ss ! 0\n  where\n   Ss = [fnv1a_offset_basis] #\n           [ block s m\n           | s <- Ss\n           | m <- msg\n           ]\n\nblock : {padLen} ( padLen == 64 - 8) => [64] -> [8] -> [64]\nblock state val = (state ^ ((zero : [padLen]) # val)) * fnv1a_prime\n\nfnv1a_offset_basis : [64]\nfnv1a_offset_basis = 14695981039346656037\n\nfnv1a_prime : [64]\nfnv1a_prime = 1099511628211\n\nt1 = fnv1a [] == 0xcbf29ce484222325\nt2 = fnv1a (join \"a\") == 0xaf63dc4c8601ec8c\nt3 = fnv1a (join \"foobar\") == 0x85944171f73967e8\n\nproperty testsPass = and [t1, t2, t3]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/HashInterface.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that specify the expected behavior and security guarantees of the hash function defined in the Primitive::Keyless::Hash::HashInterface module. Include properties that verify the digest length, message length constraints, and basic collision resistance assumptions based on the SecurityStrength parameter."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Keyless::Hash::HashInterface where\n    \/**\n     * Upper bound on the length of messages that can be hashed with this\n     * hash function.\n     *\n     * This can be set to `inf` for hash functions that do not have a\n     * restriction on message length.\n     *\/\n    type MessageUpperBound : #\n\n    \/**\n     * Length of the hash digest, in bits.\n     *\/\n    type DigestLength : #\n\n    \/**\n     * Security strength (in bits) of the hash function.\n     *\n     * This is assumed to be the minimum of the collision resistance strength,\n     * the preimage resistance strength, and the second preimage resistance\n     * strength. For most NIST-standardized hash functions, the security\n     * strength is half the digest length. The exception is SHA-1, which is\n     * largely deprecated.\n     * @see https:\/\/csrc.nist.gov\/projects\/hash-functions#security-strengths\n     *\/\n    type SecurityStrength : #\n\n    \/**\n     * Hash function, mapping an arbitrary-length message to a fixed-length\n     * message digest.\n     *\/\n    hash: {m} (fin m, width m < MessageUpperBound) => [m] -> [DigestLength]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/Blake2b.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the blake2b hash function implementation in the given module. Include properties that check the function against known answer tests (KATs), verify the behavior on zero inputs of various lengths, and ensure the compression function F maintains expected invariants. The properties should be suitable for use with Cryptol's :check or :prove commands."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::Blake2b where\n\ntype Block   = [16][64]\ntype State   = [8][64]\ntype LocalState = [16][64]\ntype Counter = [128]\n\ntype Context = { state : State, counter : Counter }\n\nbbVal : [128]\nbbVal = 128\n\n\nIV : [8][64]\nIV = [ 0x6A09E667F3BCC908, 0xBB67AE8584CAA73B,\n       0x3C6EF372FE94F82B, 0xA54FF53A5F1D36F1,\n       0x510E527FADE682D1, 0x9B05688C2B3E6C1F,\n       0x1F83D9ABFB41BD6B, 0x5BE0CD19137E2179\n     ]\n\nSIGMA_TABLE : [12][16][4]\nSIGMA_TABLE =\n    [  [  0, 1,   2, 3,   4, 5,   6, 7,   8, 9,  10, 11, 12, 13, 14, 15 ]\n    ,  [ 14, 10,  4, 8,   9, 15, 13, 6,   1, 12,  0, 2,  11, 7,   5, 3  ]\n    ,  [ 11, 8,  12, 0,   5, 2,  15, 13, 10, 14,  3, 6,   7, 1,   9, 4  ]\n    ,  [  7, 9,   3, 1,  13, 12, 11, 14,  2, 6,   5, 10,  4, 0,  15, 8  ]\n    ,  [  9, 0,   5, 7,   2, 4,  10, 15, 14, 1,  11, 12,  6, 8,   3, 13 ]\n    ,  [  2, 12,  6, 10,  0, 11,  8, 3,   4, 13,  7, 5,  15, 14,  1, 9  ]\n    ,  [ 12, 5,   1, 15, 14, 13,  4, 10,  0, 7,   6, 3,   9, 2,   8, 11 ]\n    ,  [ 13, 11,  7, 14, 12, 1,   3, 9,   5, 0,  15, 4,   8, 6,   2, 10 ]\n    ,  [  6, 15, 14, 9,  11, 3,   0, 8,  12, 2,  13, 7,   1, 4,  10, 5  ]\n    ,  [ 10, 2,   8, 4,   7, 6,   1, 5,  15, 11,  9, 14,  3, 12, 13, 0  ]\n    ,  [  0, 1,   2, 3,   4, 5,   6, 7,   8, 9,  10, 11, 12, 13, 14, 15 ]\n    ,  [ 14, 10,  4, 8,   9, 15, 13, 6,   1, 12,  0, 2,  11, 7,   5, 3  ]\n    ]\n\n\/\/ Section 2.1 constants\nR1,R2,R3,R4 : [6]\nR1 = 32\nR2 = 24\nR3 = 16\nR4 = 63\n\n\/\/ Section 3.1: Mixing function 'G'\nG : [4] -> [4] -> LocalState -> [4][6] -> Block -> [16][64]\nG r i vec abcd ms = updates vec abcd new\n  where\n  new  = G' r i (vec @@ abcd) ms\n\nG' : [4] -> [4] -> [4][64] -> Block -> [4][64]\nG' r i vals ms = [a2, b2, c2, d2]\n  where\n  x = ms @ (SIGMA_TABLE @ r @ (2*i))\n  y = ms @ (SIGMA_TABLE @ r @ (2*i+1))\n  [a,b,c,d] = vals\n  a1 =  a + b + x\n  d1 = (d ^ a1) >>> R1\n  c1 =  c + d1\n  b1 = (b ^ c1) >>> R2\n  a2 =  a1 + b1 + y\n  d2 = (d1 ^ a2) >>> R3\n  c2 =  c1 + d2\n  b2 = (b1 ^ c2) >>> R4\n\n\/\/ Section 3.2: Compression function\nF : State -> Block -> Counter -> Bit -> State\nF h ms t f =  h ^ (take (vs!0)) ^ (drop (vs!0))\n where\n  v   = h # IV ^ (zero # [t0,t1,f0,zero])\n  [t1,t0] = split t : [2][64]\n  f0 = [f | _ <- [0..63] : [_][6]]\n  vs = [v] # [ round i ms v' | v' <- vs | i <- [0..11] ]\n\n\/\/ Sub-function of F (first for loop)\nround : [4] -> Block -> LocalState -> LocalState\nround r ms v = vs ! 0\n  where\n  vs = [v] # [ G r i v' ix ms\n                | v'   <- vs\n                | i    <- [0..7]\n                | ix   <- [ [0,4,8,12],  [1,5,9,13]\n                          , [2,6,10,14], [3,7,11,15]\n                          , [0,5,10,15], [1,6,11,12]\n                          , [2,7,8,13],  [3,4,9,14] ]\n              ]\n \/\/ ix (ms @ (s @ sIx1)) (ms @ (s @ sIx2))\n \/\/               | sIx1 <- [0,2,4,6,8,10,12,14] : [8][4]\n \/\/               | sIx2 <- [1,3,5,7,9,11,13,15] : [8][4]\n \/\/             ]\n\n\/\/ Section 3.3: Padding\n\/\/ Recall kk == key bytes  (0)\n\/\/        nn == hash bytes (64)\n\/\/        ll == input bytes (ceiling $ len \/ 8)\n\/\/        bb == block bytes (128, 1024 bits)\n\/\/        dd == nr Blocks\n\nblake2b : {ll,dd}\n         (fin ll, fin dd\n         , dd == (max 1 ((ll+127)\/128)) - 1\n         \/\/ ^^^ ugly  We'd like , dd == (ll-1)\/128  but then we can't hash the empty string\n         , 128 >= width ll\n         )\n          => [ll][8]\n          -> [512]\nblake2b m = blake2Finish ({ state = (hs!0).state, counter = `ll}) lastBlock\n where\n\n fullBlocks : [dd]Block\n fullBlocks = [mkBlock b | b <- split (take (join m))]\n\n partialBlock = drop `{128*dd} m\n\n lastBlock : Block\n lastBlock  =\n    if (`ll == (zero:[128]))\n        then zero \/\/ Special case full zero block for empty messages\n        else mkBlock ((split (join (partialBlock # (zero : [inf][8]))))@0)\n\n h : Context\n h  = { state = [IV@0 ^ `0x01010040] # drop `{1} IV, counter = 0 }\n\n hs : [dd+1]Context\n hs = [h] # [blake2Update h' dX |  h' <- hs | dX <- fullBlocks]\n\nblake2Update : Context -> Block -> Context\nblake2Update ctx d = { state = newState, counter = newCount }\n  where newState = F ctx.state d newCount False\n        newCount = ctx.counter + (128 : [128])\n\npostprocess : {ll} (128 >= ll, 128 >= width ll) => Counter -> [ll][8] -> Block\npostprocess c m =\n    if c == 0 \/\\ `ll == (zero:[128])\n        then zero\n        else split (join m # zero)\n\n\/\/ The final round of blake\nblake2Finish : Context -> Block -> [512]\n\/\/ blake2Finish ctx b = ctx.state@0 # zero\nblake2Finish ctx b = join [ reverseBytes w | w <- F ctx.state b ctx.counter True ]\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/  Utilities\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nmkBlock x = reverse (split (reverseBytes x))\n\nreverseBytes x = join (reverse (bytes x))\n\nbytes x = split x : [_] [8]\n\n\ntestZeros =\n  and [ blake2b (zero : [128][8]) == 0x865939e120e6805438478841afb739ae4250cf372653078a065cdcfffca4caf798e6d462b65d658fc165782640eded70963449ae1500fb0f24981d7727e22c41\n      , blake2b (zero : [0][8]) == 0x786A02F742015903C6C6FD852552D272912F4740E15847618A86E217F71F5419D25E1031AFEE585313896444934EB04B903A685B1448B755D56F701AFE9BE2CE ]\n\ntestZerosLarge =\n  and [ blake2b (zero : [129][8]) == 0xa60edba343e7a6933c14d203d2e535f35e6deb6c8a4f8e624c1a6f6e2612860447cb4c37e5aa11bcf03b7c3eea7228eb8b998f922794f2d1b8f2dc63f03bd3fa\n      ]\n\ntestKATs =\n  and [ blake2b \"The quick brown fox jumps over the lazy dog\" == 0xA8ADD4BDDDFD93E4877D2746E62817B116364A1FA7BC148D95090BC7333B3673F82401CF7AA2E4CB1ECD90296E3F14CB5413F8ED77BE73045B13914CDCD6A918\n      ]\n\nproperty katsPass = and [ testZeros, testZerosLarge, testKATs ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Generator\/DRBG.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the DRBG module's core functions: drbg_instantiate, drbg_reseed, drbg_generate, and drbg_update. Include properties that check state consistency, reseed behavior, output length correctness, and conformity to the provided test vectors."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois Inc.\n * @author Nichole Schimanski <nls@galois.com>\n * @author Marcella Hastings <marcella@galois.com>\n * @author Ryan Scott <rscott@galois.com>\n * www.cryptol.net\n*\/\n\nmodule Primitive::Keyless::Generator::DRBG where\n\nimport Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256 as AES256\n\ntype keylen   = AES256::KeySize type blocklen = 128 type seedlen  = 384 \/\/ bits, 384 bits fixed by table 3 for AES-256\ntype reseed_limit = 2 ^^ 35 \/\/ max number of bytes to generate before reseeding\n\ntype blocksize = 16 \/\/ blocklen \/ 8\ntype keysize = 32 \/\/ keylen \/ 8\ntype seedsize = 48\n\ntype cipher_ctx = { key : [keylen] }\n\nblock_encrypt : [keylen] -> [blocklen] -> [blocklen]\nblock_encrypt key data = AES256::encrypt key data\n\ntype s2n_drbg =\n  { bytes_used : [64]\n  , ctx : cipher_ctx\n  , v : [blocklen]\n  }\n\ndrbg_generate_internal : {n, blocks}\n                         ( fin n, fin blocks, n >= 1, n <= 8192\n                         , n == blocklen * blocks)\n                      => s2n_drbg\n                      -> ([n], s2n_drbg)\ndrbg_generate_internal drbg =\n  (join [ block_encrypt drbg.ctx.key (drbg.v + i) | i <- [1 .. blocks]], drbg')\n    where drbg' = { bytes_used = drbg.bytes_used + `(blocks * blocksize)\n                  , ctx = drbg.ctx\n                  , v = drbg.v + `blocks\n                  }\n\ndrbg_instantiate : {ps_size}\n                   (fin ps_size)\n                => [seedlen]\n                -> [ps_size]\n                -> s2n_drbg\ndrbg_instantiate entropy ps = drbg_reseed zero entropy ps'\n  where\n    \/* pad ps with zeros if needed to reach seedlen\n       otherwise truncate to seedlen *\/\n    ps' = take `{seedlen} (ps # (zero : [seedlen]))\n\n\/* Should bytes used be reset before the update? s2n doesn't\n   it seems like the NIST spec counts that update as the first\n\n   we limit ps_size to a maximum of seedlen because this is an\n   implementation specific choice made by s2n*\/\ndrbg_reseed : {ps_size}\n              (ps_size <= seedlen)\n           => s2n_drbg\n           -> [seedlen]\n           -> [ps_size]\n\t   -> s2n_drbg\ndrbg_reseed drbg entropy ps = drbg''\n  where\n    drbg' = drbg_update (entropy ^ (ps # zero)) drbg\n    drbg'' = { v = drbg'.v, ctx = drbg'.ctx, bytes_used = 0}\n\ndrbg_uninstantiate : s2n_drbg -> s2n_drbg\ndrbg_uninstantiate drbg = zero\n\n\/* This is the spec of the s2n code, in that it reseeds automatically\n   if reseed is required. This is in opposition to the spec, which\n   requires an error code.\n\n   We are curious about why s2n_drbg counts a number of bytes used,\n   while the spec tracks a number of calls to generate. We don't\n   belive that this is buggy behavior, since if we call the maximum\n   size with generate each time, we will reseed before the spec would\n   require it. *\/\ndrbg_generate : {n, blocks} (fin n, fin blocks, n >= 1, n <= 8192,\n                             blocks * blocklen >= n,\n                             (blocks - 1) * blocklen <= n - 1) =>\n                s2n_drbg -> [seedlen] -> Bit ->\n                ([n], s2n_drbg)\ndrbg_generate drbg entropy reseed_p = (take enc_result, drbg_out)\n  where\n    \/\/ Re-seed if we have exceeded the limit, or if reseed_p is set\n    drbg_r =\n      if reseed_p \\\/ drbg.bytes_used + `n * 8 + `blocklen * 8 >= `reseed_limit then\n        drbg_reseed drbg entropy (zero : [256])\n      else drbg\n    \/\/ Encrypt v+1, v+2, ..., v + ceil (n \/ blocklen)\n    (enc_result, drbg_v) = drbg_generate_internal `{blocks=blocks} drbg_r\n    \/\/ Update the drbg state\n    drbg_out = drbg_update zero drbg_v\n\n\/* What is ctr_len? We think it is >= blocklen, so\n   we go to the else branch of 2.1 every time *\/\ndrbg_update : [seedlen] -> s2n_drbg -> s2n_drbg\ndrbg_update data drbg = result\n  where\n    \/\/ NOTE: blocklen * seedlen \/ blocklen is seedlen in our case, but might be\n    \/\/ different if seedlen isn't a multiple of blocklen\n    type blocks = (seedlen + blocklen -1)\/blocklen\n    \/\/ Encrypt v+1, v+2, ..., v + ceil (seedlen \/ blocklen)\n    (enc_result, _) = drbg_generate_internal `{blocks=blocks} drbg\n    \/\/ XOR the additional input data with the first bits of enc_result\n    data_xor = (take enc_result) ^ data\n    \/\/ Return the first half of data_xor as the new key, and the last half of it\n    \/\/ as the new value for v\n    result = { bytes_used = drbg.bytes_used + (`blocks * `blocksize)\n             , ctx = { key = take data_xor }\n             , v = drop data_xor\n             }\n\n\n\/* Example test vectors from\n\n   https:\/\/csrc.nist.gov\/Projects\/Cryptographic-Algorithm-Validation-Program\/Random-Number-Generators\n\n   for CTR_DRBG.\n*\/\n\n\/* [AES-256 no df]\n   [PredictionResistance = False]\n   [EntropyInputLen = 384]\n   [NonceLen = 0]\n   [PersonalizationStringLen = 0]\n   [AdditionalInputLen = 0]\n   [ReturnedBitsLen = 512] <- value of type parameter n\n*\/\n\n\n\ntestInstantiate0 = {entropy = 0xe4bc23c5089a19d86f4119cb3fa08c0a4991e0a1def17e101e4c14d9c323460a7c2fb58e0b086c6c57b55f56cae25bad,\n                    pString = zero : [0],\n                        Key = 0xb7b3a93ecfdf2f61c622ad3afb6bff818736a09c9391157e1902d10a79d0db12,\n                               V = 0x0e4fb6443cae46188617aad8bfe46e23}\n\ntestInstantiatedrbg0 = drbg_instantiate`{ps_size=0} testInstantiate0.entropy testInstantiate0.pString\n\ntestInstantiate0Pass = testInstantiatedrbg0.v == testInstantiate0.V \/\\ testInstantiatedrbg0.ctx.key == testInstantiate0.Key\n\ntestReseed0 = {entropyReseed = 0xfd85a836bba85019881e8c6bad23c9061adc75477659acaea8e4a01dfe07a1832dad1c136f59d70f8653a5dc118663d6,\n                          Key = 0xd230044c2594510d195ffe9923de8848bdbd19f24d0e7558b28e55b2d4de7841,\n                                V = 0xe18637ff12f514f37adc2013a40f38c1}\n\ntestReseed0Pass = drbgreseed.v == testReseed0.V \/\\ drbgreseed.ctx.key == testReseed0.Key\n                where drbgreseed = drbg_reseed`{ps_size=0} testInstantiatedrbg0 testReseed0.entropyReseed zero\n\ntestGenerate0 = {      Key = 0xec871bb7a4f2c45dccdd0e514a21628959aa21e9643934f619b2709b3e38697c,\n                       V   = 0xd8bbe7bfc60bfb710f39acd1088c9f41}\n\ntestGeneratedrbg0 = (drbg_generate`{n=512} testInstantiatedrbg0 testReseed0.entropyReseed True).1\n\ntestGenerate0Pass = testGeneratedrbg0.v == testGenerate0.V testGenerateSnd0 = {returnedBits = 0xb2cb8905c05e5950ca31895096be29ea3d5a3b82b269495554eb80fe07de43e193b9e7c3ece73b80e062b1c1f68202fbb1c52a040ea2478864295282234aaada,\n                       Key = 0xe728308a0e92cbacb269d12246d8e2d24cf5fcc678aa09564132e4972c456eda,\n                       V   = 0xc95f38da34ecb65ebf8b34c32bc215a5}\n\ntestGenerateSnd0Pass = and [ result == testGenerateSnd0.returnedBits\n                           , drbg.ctx.key == testGenerateSnd0.Key\n                           , drbg.v == testGenerateSnd0.V ]\n                     where (result,drbg) = drbg_generate`{n=512} testGeneratedrbg0 zero False\n\n\nproperty testsPass = and [testInstantiate0Pass, testReseed0Pass, testGenerate0Pass, testGenerateSnd0Pass]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the SHA2 hash function implementation in the given specification file. Include properties that check the correctness of padding, message schedule generation, logical functions (Ch, Maj, Sigma0, Sigma1, sigma0, sigma1), and the overall hash computation against the FIPS-180-4 standard. Ensure to prove key properties such as rotation equivalences, padding correctness, and that the hash output length matches the specified digest size."},{"role":"assistant","content":"```cryptol\n\/*\n * Implementation of the secure hash algorithms known as SHA2 from [FIPS-180-4].\n *\n * This implementation does not support SHA-1. It does support:\n * - SHA-224\n * - SHA-256\n * - SHA-384\n * - SHA-512\n * - SHA-512\/224\n * - SHA-512\/256\n *\n * References\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Specification where\n\nparameter\n    \/**\n     * Length of words, in bits, that are used during hashing.\n     *\n     * The specification defines words to be either 32 bits (for\n     * SHA-224 and SHA-256) or 64 bits (for SHA-384, SHA-512, and\n     * SHA-512\/t for any valid `t`).\n     * [FIPS-180-4] Section 1, Figure 1.\n     *\/\n    type w : #\n    type constraint (w % 32 == 0, 32 <= w, 64 >= w)\n\n    \/**\n     * Length of the message digest produced by the hash algorithm.\n     *\n     * Allowable values for each word size `w` are defined in [FIPS-180-4]\n     * Section 1, Figure 1.\n     *\n     * The spec does not explicitly require that the digest size is a multiple\n     * of 8, but all the allowable sizes are; adding this explicit constraint\n     * allows us to define a hash function that operates over bytes.\n     *\/\n    type DigestSize : #\n    type constraint (8 * w >= DigestSize, DigestSize % 8 == 0)\n\n    \/**\n     * Initial hash value.\n     * These are defined in [FIPS-180-4] Section 5.3.\n     *\/\n    H0 : [8][w]\n\n\/**\n * Upper bound on the width of messages that can be processed.\n * [FIPS-180-4] Section 1, Figure 1, \"Message Size (bits)\"\n *\/\ntype MessageUpperBound = 2 * w\ntype constraint ValidMessageLength L = width L <= MessageUpperBound\n\n\/**\n * Length of the hash digest.\n *\n * This is made public to instantiate the `HashInterface`.\n *\/\ntype DigestLength = DigestSize\n\n\/**\n * Security strength (in bits) of the hash function.\n * @see NIST SP 800-107 (to be withdrawn): https:\/\/csrc.nist.gov\/pubs\/sp\/800\/107\/r1\/final\n * @see Hash functions webpage: https:\/\/csrc.nist.gov\/projects\/hash-functions\n *\n * This is made public to instantiate the `HashInterface`.\n *\/\ntype SecurityStrength = DigestSize \/ 2\n\nprivate\n    \/**\n     * Size of blocks of data used in hashing, measured in bits.\n     *\n     * This is denoted `m` in the spec. [FIPS-180-4] Section 1, Figure 1.\n     *\/\n    type BlockSize = 16 * w\n\n    \/**\n     * `ScheduleLength` is fixed based on `w`: 64 when `w = 32` and 80 when `w = 64`.\n     * We encode this using the relation `48 + w\/2`.\n     *\n     * It is not explicitly defined with this name in the spec. You can see it used\n     * in several places:\n     * - The constant `K` has `ScheduleLength` words ([FIPS-180-4] Section\n     *   4.2.2 and 4.2.3)\n     * - The message schedule `W` has length `ScheduleLength` ([FIPS-180-4]\n     *   Section 6.2.2 #1 and Section 6.4.2 #1)\n     *\/\n    type ScheduleLength = 48 + w \/ 2\n\n    \/**\n     * Circular rotate left operation.\n     * [FIPS-180-4] Section 2.2.2 and Section 3.2 #5.\n     *\/\n    ROTL : {n} (n < w) => [w] -> [w]\n    ROTL x = x <<< `n\n\n    \/**\n     * Circular rotate right operation.\n     * [FIPS-180-4] Section 2.2.2 and Section 3.2 #4.\n     *\/\n    ROTR : {n} (n < w) => [w] -> [w]\n    ROTR x = x >>> `n\n\n    \/**\n     * Circular rotations have a specific kind of circularity.\n     * [FIPS-180-4] Section 3.2 #6.\n     *\n     * We check this for a sampling of `n`s.\n     * ```repl\n     * :prove rotationEquivalenceRelationsHold`{0}\n     * :prove rotationEquivalenceRelationsHold`{1}\n     * :prove rotationEquivalenceRelationsHold`{w-1}\n     * :prove rotationEquivalenceRelationsHold`{w\/2}\n     * ```\n     *\/\n    rotationEquivalenceRelationsHold : {n} (n < w) => [w] -> Bool\n    property rotationEquivalenceRelationsHold x = left && right where\n        left = ROTL`{n} x == ROTR`{(w - n) % w} x\n        right = ROTR`{n} x == ROTL`{(w - n) % w} x\n\n    \/**\n     * Right shift operation.\n     * [FIPS-180-4] Section 2.2.2 and Section 3.2 #3\n     *\/\n    SHR : {n} (n < w) => [w] -> [w]\n    SHR x = x >> `n\n\n    \/**\n     * The default Cryptol representation of hex digits and bit strings matches\n     * the requirements of the spec.\n     * [FIPS-180-4] Section 3.1, #1.\n     * ```repl\n     * :prove hexDigitsEncodeCorrectly\n     * ```\n     *\/\n    property hexDigitsEncodeCorrectly = (0x7 == 0b0111) && (0xa == 0b1010)\n\n    \/**\n     * The default Cryptol representation of hex words and bit strings matches\n     * the requirements of the spec.\n     * [FIPS-180-4] Section 3.1, #2.\n     * ```repl\n     * :prove wordsEncodeCorrectly\n     * ```\n     *\/\n    property wordsEncodeCorrectly = short && long where\n        short = 0xa103fe23 == 0b10100001000000111111111000100011\n        long = 0xa103fe2332ef301a == 0b1010000100000011111111100010001100110010111011110011000000011010\n\n    \/**\n     * The default Cryptol representation of integers and hex words matches\n     * the requirements of the spec.\n     * [FIPS-180-4] Section 3.1, #3.\n     * ```repl\n     * :prove integersEncodeCorrectly\n     * ```\n     *\/\n    property integersEncodeCorrectly = 291 == 0x00000123\n\n    \/**\n     * The first logical function for the SHA family.\n     * [FIPS-180-4] Section 4.1.2, Equation 4.2 and Section 4.1.3, Equation 4.8.\n     *\/\n    Ch : [w] -> [w] -> [w] -> [w]\n    Ch x y z = (x && y) ^ (~x && z)\n\n    \/**\n     * The second logical function for the SHA family.\n     * [FIPS-180-4] Section 4.1.2, Equation 4.3 and Section 4.1.3, Equation 4.9.\n     *\/\n    Maj : [w] -> [w] -> [w] -> [w]\n    Maj x y z = (x && y) ^ (x && z) ^ (y && z)\n\n    \/**\n     * The third logical function for the SHA family.\n     * [FIPS-180-4] Section 4.1.2, Equation 4.4 and Section 4.1.3, Equation 4.10.\n     *\/\n    Sigma0: [w] -> [w]\n    Sigma0 x\n        | w == 32 => ROTR`{ 2} x ^ ROTR`{13} x ^ ROTR`{22} x\n        | w == 64 => ROTR`{28} x ^ ROTR`{34} x ^ ROTR`{39} x\n\n    \/**\n     * The fourth logical function for the SHA family.\n     * [FIPS-180-4] Section 4.1.2, Equation 4.5 and Section 4.1.3, Equation 4.11.\n     *\/\n    Sigma1: [w] -> [w]\n    Sigma1 x\n        | w == 32 => ROTR`{ 6} x ^ ROTR`{11} x ^ ROTR`{25} x\n        | w == 64 => ROTR`{14} x ^ ROTR`{18} x ^ ROTR`{41} x\n\n    \/**\n     * The fifth logical function for the SHA family.\n     * [FIPS-180-4] Section 4.1.2, Equation 4.6 and Section 4.1.3, Equation 4.12.\n     *\/\n    sigma0: [w] -> [w]\n    sigma0 x\n        | w == 32 => ROTR`{7} x ^ ROTR`{18} x ^ SHR`{3} x\n        | w == 64 => ROTR`{1} x ^ ROTR`{ 8} x ^ SHR`{7} x\n\n    \/**\n     * The sixth logical function for the SHA family.\n     * [FIPS-180-4] Section 4.1.2, Equation 4.7 and Section 4.1.3, Equation 4.13.\n     *\/\n    sigma1: [w] -> [w]\n    sigma1 x\n        | w == 32 => ROTR`{17} x ^ ROTR`{19} x ^ SHR`{10} x\n        | w == 64 => ROTR`{19} x ^ ROTR`{61} x ^ SHR`{ 6} x\n\n    \/**\n     * The SHA family uses a sequence of constant `w`-bit words, which represent\n     * the first `w` bits of the fractional parts of the cube roots of the first\n     * `ScheduleLength` prime numbers.\n     *\n     * [FIPS-180-4] Section 4.2.2 and 4.2.3.\n     *\/\n    K : [ScheduleLength][w]\n    K | w == 32 => [\n        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]\n      | w == 64 => [\n        0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n        0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n        0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n        0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n        0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n        0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n        0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n        0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n        0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n        0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n        0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n        0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n        0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n        0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n        0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n        0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n        0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n        0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n        0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n        0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817]\n\n\n    \/**\n     * Number of bits used to encode the length of the message for padding.\n     * [FIPS-180-4] Section 5.1.\n     *\/\n    type LengthBits = 2 * w\n    \/**\n     * Number of blocks needed to hold the padded version of a message of length L.\n     * [FIPS-180-4] Section 5.1.\n     *\/\n    type NumBlocks L = (L + 1 + LengthBits) \/^ BlockSize\n\n    \/**\n     * Deterministically pad a message to a multiple of the block size.\n     *\n     * [FIPS-180-4] Section 5.1.1 and 5.1.2.\n     *\n     * The constraint is not explicitly noted in Section 5.1, but all\n     * messages to be hashed must not exceed the valid message length.\n     *\/\n    pad : {L} (ValidMessageLength L) => [L] -> [NumBlocks L * BlockSize]\n    pad M = M # 0b1 # zero # (`L : [LengthBits])\n\n    \/**\n     * The example used to demonstrate padding in the spec works.\n     * [FIPS-180-4] Section 5.1.1 and Section 5.1.2.\n     * ```repl\n     * :prove paddingExampleWorks\n     * ```\n     *\/\n    paddingExampleWorks : Bool\n    paddingExampleWorks\n        | w == 32 => pad (join \"abc\") == (0b01100001 # 0b01100010 # 0b01100011\n            # 0b1 # (zero : [423]) # (zero : [59]) # 0b11000)\n        | w == 64 => pad (join \"abc\") == (0b01100001 # 0b01100010 # 0b01100011\n            # 0b1 # (zero : [871]) # (zero : [123]) # 0b11000)\n\n    \/**\n     * The message and its padding must be parsed into `N` blocks.\n     * [FIPS-180-4] Section 5.2.\n     *\/\n    parse : {N} () => [N * BlockSize] -> [N][BlockSize]\n    parse M = split M\n\n\n\/**\n * Secure hash function.\n *\n * All the SHA functions (excluding SHA-1) share the same structure.\n * The primary differences can be handled through Cryptol's built-in\n * polymorphism:\n * - The word sizes are different;\n * - The length of the message schedule and subsequent number of iterations\n *   over the working variables are different; and\n * - The digest length is different.\n *\n * [FIPS-180-4] Section 6.2 - 6.7.\n * The hash functionality itself is primarily described in Sections 6.2 and\n * 6.4. The correct truncation for other bit lengths is in the other sections.\n *\/\nhash: {l} (ValidMessageLength l) => [l] -> [DigestSize]\nhash M = take (join (digest ! 0)) where\n    digest = [H0] # [Hi'\n        where\n            \/\/ Step 1. Prepare the message schedule.\n            Ws = messageSchedule (split Mi)\n\n            \/\/ Step 2. Initialize the eight working variables with the\n            \/\/ previous hash value.\n            letters = [(Hi0, Hi1, Hi2, Hi3, Hi4, Hi5, Hi6, Hi7)] # [\n                \/\/ Step 3. Update temporary and working variables...\n                variableUpdate l Kt Wt\n                | l <- letters\n\n                \/\/ ...for t=0 to `ScheduleLength`.\n                | Wt <- Ws\n                | Kt <- K\n            ]\n            (a, b, c, d, e, f, g, h) = letters ! 0\n\n            \/\/ Step 4. Compute the next intermediate hash value.\n            \/\/ Note that in the spec, this is denoted H^(i).\n            Hi' = [a + Hi0, b + Hi1, c + Hi2, d + Hi3, e + Hi4, f + Hi5, g + Hi6, h + Hi7]\n\n        \/\/ Each message block is processed in order.\n        | Mi <- parse (pad M)\n\n        \/\/ An intermediate hash digest is computed at each iteration.\n        \/\/ Note that in the spec, these are denoted H^(i-1)_j for j = 0..7.\n        | [Hi0, Hi1, Hi2, Hi3, Hi4, Hi5, Hi6, Hi7] <- digest\n    ]\n\n    \/\/ Step 1. Prepare the message schedule.\n    messageSchedule : [16][w] -> [ScheduleLength][w]\n    messageSchedule Mi = take W where\n        W : [inf][w]\n        W = Mi # [ sigma1 w2 + w7 + sigma0 w15 + w16\n            \/\/ The spec indexes these by counting from the other direction.\n            \/\/ We can't do that here because it's an infinite sequence.\n            \/\/ Note that 15 - the drop parameter is the index in the spec.\n            | w16 <- W\n            | w15 <- drop`{1} W\n            | w7  <- drop`{9} W\n            | w2  <- drop`{14} W\n        ]\n\n    \/\/ Convenience type to describe the set of working variables a - h.\n    type LetterVars = ([w], [w], [w], [w], [w], [w], [w], [w])\n\n    \/\/ Step 3. Update temporary and working variables (one iteration).\n    variableUpdate : LetterVars -> [w] -> [w] -> LetterVars\n    variableUpdate (a, b, c, d, e, f, g, h) Kt Wt =\n        (a', b', c', d', e', f', g', h')\n        where\n            T1 = h + Sigma1 e + Ch e f g + Kt + Wt\n            T2 = Sigma0 a + Maj a b c\n            h' = g\n            g' = f\n            f' = e\n            e' = d + T1\n            d' = c\n            c' = b\n            b' = a\n            a' = T1 + T2\n\n\/**\n * Secure hash function, computed over bytes.\n *\n * This is not explicitly part of the spec, but many applications represent\n * their input and output over byte strings (rather than bit strings as used\n * in the spec itself).\n *\/\nhashBytes: {l} (ValidMessageLength (8 * l)) => [l][8] -> [DigestSize \/ 8][8]\nhashBytes M = groupBy`{8} (hash (join M))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/KeccakBitOrdering.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the functions `reverseBitOrdering`, `h2b`, and `b2h` correctly convert between the standard Cryptol bit ordering and the Keccak SHA-3 bit ordering. Include proofs that `reverseBitOrdering` is an involution (its own inverse), and that `h2b` and `b2h` are inverses of each other for both full-length and padded inputs, as described in the module comments and existing properties."},{"role":"assistant","content":"```cryptol\n\/**\n * Functions for converting bit string representations used in Keccak.\n *\n * This has methods for converting between the standard bit ordering in Cryptol\n * (big endian, or most significant bit first (MSB)) and the bit ordering\n * used in Keccak (bytes in MSB order, but the bits in each byte are in\n * least significant bit first (LSB) order).\n *\n * @copyright Galois, Inc.\n * @author Ajay Kumar Eeralla\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA3::KeccakBitOrdering where\n\/**\n * Deprecated!!\n * Splits a list of bits into bytes, using little-endian bit order.\n *\/\ntoBytes : {n} (fin n) => [8*n] -> [n][8]\ntoBytes s = reverse (split (reverse s))\n\n\/**\n * Deprecated!!\n * Joins a list of bytes into a list of bits, using little-endian bit order.\n *\/\nfromBytes : {n} (fin n) => [n][8] -> [8*n]\nfromBytes bs = reverse (join (reverse bs))\n\n\/**\n * This converts between a bit vector in MSB order and a bit vector in SHA-3\n * bit ordering (the bytes are in MSB order; the bits in each byte are in LSB\n * order).\n *\n * For arbitrary-length strings, the conversion is symmetric. This can be used\n * to convert from SHA-3 strings into MSB strings, or from MSB strings into\n * SHA-3 strings.\n *\n * This function does not have an explicit equivalent in the [FIPS-202]. It\n * differs from the conversion functions in Appendix B.1 in several ways:\n * - The h2b and b2h functions expect the non-SHA-3 bit vector to be a\n *   hexadecimal string with an even number of digits. This function\n *   can handle a non-SHA-3 bit vector of any length (including infinite\n *   length).\n * - The h2b and b2h functions take a separate parameter `n` specifying the\n *   \"actual\" length of the non-SHA-3 bit vector. `h2b` truncates the SHA-3 bit\n *   vector to exactly `n` bits; `b2h` pads the non-SHA-3 bit vector to a\n *   multiple of 8 bits. This function assumes the input bit vector\n *   has no padding and that the output bit vector is exactly the same length\n *   as the input bit vector.\n * - `b2h` and `h2b` require finite input. This function allows infinite input.\n *   This isn't relevant for `h2b` since all the SHA3 functions take finite\n *   input, but it allows callers of the extendable output SHAKE functions to\n *   interact lazily with an infinite stream instead of specifying the output\n *   length at call time.\n *\n * [FIPS-202] does not specify when these conversion functions are expected to\n * be used. The CAVP test vectors provided by NIST use the format consumed by\n * `h2b` and `b2h` of hexadecimal strings with an even number of digits.\n * However, we anticipate that many applications will produce exact-length\n * messages to use with SHA-3 functions (e.g. they will not pad their inputs\n * to a multiple of 8 bits).\n *\n * Sources:\n * A blog post with some references to other versions of the spec, explaining\n * the overall bit ordering scheme:\n * @see https:\/\/cryptologie.net\/article\/387\/byte-ordering-and-bit-numbering-in-keccak-and-sha-3\/\n * The CAVP test vectors from NIST:\n * @see https:\/\/csrc.nist.gov\/projects\/cryptographic-algorithm-validation-program\/secure-hashing#sha3vsha3vss\n * The CSAG examples and intermediate values from NIST:\n * @see https:\/\/csrc.nist.gov\/projects\/cryptographic-standards-and-guidelines\/example-values#Hashing\n *\/\nreverseBitOrdering : {m} [m] -> [m]\nreverseBitOrdering msg\n    | m == inf => join (map reverse (groupBy`{8} msg))\n    | fin m => (flipped_full_bytes # flipped_remainder) where\n        \/\/ This is number of bits in the set of \"complete\" bytes in the input\n        \/\/ There are `m % 8` bits remaining.\n        type Bytes = 8 * (m \/ 8)\n        flipped_full_bytes = join (map reverse (groupBy`{each=8, parts=m \/ 8} (take`{Bytes} msg)))\n        flipped_remainder = reverse (drop`{Bytes} msg)\n\n\/**\n * The conversion between SHA-3 strings and MSB strings is its own inverse.\n * ```repl\n * :prove reverseBitOrderingInvolutes`{100}\n * ```\n *\/\nreverseBitOrderingInvolutes : {m} (fin m) => [m] -> Bit\nproperty reverseBitOrderingInvolutes msg = reReverse == msg where\n    reReverse = reverseBitOrdering (reverseBitOrdering msg)\n\n\/**\n * This computes the truncation step from `h2b`.\n *\n * This is designed to be used in applications where the input for a SHA-3\n * function is provided in the even-number-of-hex-digits format described in\n * [FIPS-202] Appendix B.1.\n *\/\ntruncate : {n, m} (fin m, fin n, m >= n, m % (2 * HexDigit) == 0) => [m] -> [n]\ntruncate msg = reverseBitOrdering (take (reverseBitOrdering msg))\n\n\/**\n * The `reverseBitOrdering` function is the same as `h2b` when:\n * - there's no padding on the message (e.g. in `h2b`, the output length `n` is\n *   the same as the input length `2 * m * HexDigit`); and\n * - the input length is finite.\n *\n * ```repl\n * :prove reverseMatchesh2b`{10}\n * :prove reverseMatchesh2b`{100}\n * ```\n *\/\nreverseMatchesh2b : {m} (fin m, m > 0) => [2 * m * HexDigit] -> Bool\nproperty reverseMatchesh2b msg = h2b msg == reverseBitOrdering msg\n\n\/**\n * If there is padding on the message passed to `h2b`, truncating that input\n * and passing to `reverseBitOrdering` is the same as passing directly to `h2b`.\n *\n * ```repl\n * :prove truncateAndReverseMatchesh2b`{3, 17}\n * :prove truncateAndReverseMatchesh2b`{3, 18}\n * :prove truncateAndReverseMatchesh2b`{3, 19}\n * :prove truncateAndReverseMatchesh2b`{3, 20}\n * :prove truncateAndReverseMatchesh2b`{3, 21}\n * :prove truncateAndReverseMatchesh2b`{3, 22}\n * :prove truncateAndReverseMatchesh2b`{3, 23}\n * :prove truncateAndReverseMatchesh2b`{3, 24}\n *\/\ntruncateAndReverseMatchesh2b : {m, n} (fin m, m > 0, n > 0, 2 * HexDigit * m >= n) => [2 * m * HexDigit] -> Bool\nproperty truncateAndReverseMatchesh2b msg = h2b_result == rt_result where\n    h2b_result = h2b`{n} msg\n    rt_result = reverseBitOrdering (truncate`{n} msg)\n\n\/**\n * The `reverseBitOrdering` function is the same as `b2h` if:\n * - there's no padding needed on the message (e.g. the message length `n`\n *   divides evenly by 8 (an even number of hex digits)); and\n * - the output length is finite.\n * ```repl\n * :prove reverseMatchesb2h`{10}\n * :prove reverseMatchesb2h`{100}\n * ```\n *\/\nreverseMatchesb2h : {n} (fin n, n > 0) => [2 * n * HexDigit] -> Bool\nreverseMatchesb2h msg = b2h msg == reverseBitOrdering msg\n\n\/**\n * If there is padding needed for the message produced by `b2h`, calling the\n * `truncate` function on that output is the same as calling\n * `reverseBitOrdering`.\n *\n * ```repl\n * :prove reverseAndTruncateMatchesb2h`{17}\n * :prove reverseAndTruncateMatchesb2h`{18}\n * :prove reverseAndTruncateMatchesb2h`{19}\n * :prove reverseAndTruncateMatchesb2h`{20}\n * :prove reverseAndTruncateMatchesb2h`{21}\n * :prove reverseAndTruncateMatchesb2h`{22}\n * :prove reverseAndTruncateMatchesb2h`{23}\n * :prove reverseAndTruncateMatchesb2h`{24}\n *\/\nreverseAndTruncateMatchesb2h : {n} (fin n, n > 0) => [n] -> Bool\nproperty reverseAndTruncateMatchesb2h bits = b2h_result == rev_result where\n    b2h_result = truncate`{n} (b2h bits)\n    rev_result = reverseBitOrdering bits\n\n\/*\n * A hex digit is represented in Cryptol as a 4-bit vector.\n *\/\ntype HexDigit = 4\n\n\/**\n * Converts a hexadecimal string with an even number of digits into a SHA-3\n * string.\n *\n * The bit ordering expected by Keccak has bytes in MSB order, and the bits in\n * each byte in LSB order. (Cryptol's default interprets both bits and bytes\n * in MSB order).\n *\n * [FIPS-202] Appendix B.1, Algorithm 10.\n *\/\nh2b: {n, m} (fin m, m > 0, n > 0, n <= 8 * m) => [2 * m * HexDigit] -> [n]\nh2b msg = S where\n    \/\/ Step 1.\n    H = groupBy`{HexDigit} msg\n    \/\/ Type conversion: expand each 4-bit digit into an 8-bit vector to support\n    \/\/ subsequent operations.\n    H8 = map zext H : [2 * m][8]\n    \/\/ Step 2a.\n    hs = [16 * H8 @ (2 * i) + H8 @ (2 * i + 1) | i <- [0..m-1]]\n    \/\/ Step 2b.\n    \/\/ Cryptol defaults to MSB order; this step arranges the bits in LSB order.\n    bs = map reverse hs\n    \/\/ Step 3.\n    T = join bs\n        S = take`{n} T\n\n\/**\n * This is the example in [FIPS-202] Appendix B, Table 5.\n * ```repl\n * :prove h2bExampleWorks\n * ```\n *\/\nproperty h2bExampleWorks = h2b`{14} H == S where\n    H = 0xA32E\n    S = 0b11000101011101\n\n\/**\n * Converts a SHA-3 string into a hexadecimal string with an even number of\n * digits.\n *\n * [FIPS-202] Appendix B.1, Algorithm 11.\n *\n * Note that this is not a particularly efficient way to do this in Cryptol.\n * Cryptol does not distinguish between bit vectors and hexadecimal strings,\n * so some of the transformations in this function are a little arbitrary.\n *\/\nb2h : {n} (fin n, n > 0) => [n] -> [2 * (n \/^ 8) * HexDigit]\nb2h S = H where\n    \/\/ Step 1: we use Cryptol's `n syntax to get the value of the type.\n    \/\/ Step 2. See `zero_length_is_correct` for an explanation of the type.\n    T = S # (zero : [(8 - (n % 8)) % 8]) \/\/ Equivalently, -n % 8.\n    type m = n \/^ 8\n    \/\/ Step 3.\n    b = [[ T@(8 * i + j) | j <- [0..7]] | i <- [0..m-1]]\n    \/\/ Step 4a.\n    h = [reverse bs | bs <- b]\n    \/\/ Step 4b.\n    Hs = [split`{2, HexDigit} hi | hi <- h]\n    H = join (join Hs)\n\n\/**\n * Helper property to prove the equivalence from b2h is correct.\n * This exists because we can't use negative numbers in types.\n * ```repl\n * :prove zero_length_is_correct\n * ```\n *\/\nzero_length_is_correct : Integer -> Bool\nproperty zero_length_is_correct n = (-n) % 8 == (8 - (n % 8)) % 8\n\n\/**\n * Prove these things invert each other for inputs that \"fill\" the hex string.\n * ```repl\n * :prove h2bAndb2hInvert`{1}\n * :prove h2bAndb2hInvert`{10}\n * :prove h2bAndb2hInvert`{100}\n * :prove h2bAndb2hInvert`{1000}\n * ```\n *\/\nh2bAndb2hInvert : {m} (fin m, m > 0) => [2 * m * HexDigit] -> Bool\nproperty h2bAndb2hInvert msg = b2h (h2b`{2 * m * HexDigit} msg) == msg\n\n\/**\n * Prove these things invert each other for inputs that are padded.\n * In fact, they're not guaranteed to invert each other because there's no\n * standard for the padding on h2b -- the \"extra\" bytes that are between `n`\n * and `8m` get truncated in h2b, and are replaced specifically with 0s in b2h.\n * So it's possible to have different hexadecimal strings that parse as the\n * same SHA-3 strings.\n *\n * That said, it still seems useful to demonstrate that if the padding is all\n * zeros, the input itself is still preserved between the two functions.\n * So, we take inputs of a \"short\" length (e.g. a length that is not divisible\n * by 8), then pad them to the correct length (`hexMsg`), then convert to bits\n * and back.\n *\n * We pad the strings using our `reverseBitOrdering` function; the padding goes\n * to the \"inside\" of the last byte. This matches the convention in the CAVP\n * test vectors. E.g. if `-` is the actual message and `P` is the padding, a\n * vector with 3 bits of padding looks like:\n * `-------- -------- -------- PPP-----`\n *\n * The type parameters are:\n * - `m`: the number of pairs of hex digits in the input string\n * - `n`: the number of actual bits in the input string\n *\n * So, there are 8 potential padding lengths (0 through 7 bits of padding).\n * Here's a set of tests checking all the padding lengths for a string of\n * 3 pairs of hex digits; it will work for any number of pairs.\n * ```repl\n * type pairs = 3\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 7}\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 6}\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 5}\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 4}\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 3}\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 2}\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 1}\n * :prove h2bAndb2hInvertForShortStrings`{pairs, 8 * pairs - 0}\n * ```\n *\/\nh2bAndb2hInvertForShortStrings : {m, n} (fin m, m > 0, n > 0, n \/^ (2 * HexDigit) == m) => [n] -> Bool\nproperty h2bAndb2hInvertForShortStrings msg = b2h (h2b`{n} hexMsg) == hexMsg where\n    hexMsg = reverseBitOrdering ((reverseBitOrdering msg) # zero) : [2 * m * HexDigit]\n\n\/**\n * This is the arguably simpler version of `h2bAndb2hInvertForShortStrings`\n * where we start on the bits side instead of the hex side...\n *\n * ```repl\n * type pairs = 3\n * :prove b2hAndh2bInvert`{8 * pairs - 7}\n * :prove b2hAndh2bInvert`{8 * pairs - 6}\n * :prove b2hAndh2bInvert`{8 * pairs - 5}\n * :prove b2hAndh2bInvert`{8 * pairs - 4}\n * :prove b2hAndh2bInvert`{8 * pairs - 3}\n * :prove b2hAndh2bInvert`{8 * pairs - 2}\n * :prove b2hAndh2bInvert`{8 * pairs - 1}\n * :prove b2hAndh2bInvert`{8 * pairs - 0}\n * ```\n *\/\nb2hAndh2bInvert: {n} (fin n, n > 0) => [n] -> Bool\nproperty b2hAndh2bInvert msg = h2b (b2h msg) == msg\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the Keccak-p permutation implementation in the given SHA-3 specification. Include proofs that the hardcoded rotation offsets in `\u03c1_hardcoded` match the general `\u03c1` function, that the round constants in `rc_hardcoded` are equivalent to those computed by `rc`, and that the `flatten` and `unflatten` functions are inverses of each other. Additionally, specify properties to confirm the correctness of the padding function and the overall Keccak sponge construction as defined in the module."},{"role":"assistant","content":"```cryptol\n\/**\n * Specification of the Keccak (SHA-3) hash function.\n *\n * [FIPS-202]: National Institute of Standards and Technology. SHA-3 Standard:\n *     Permutation-Based Hash and Extendable-Output Functions. (Department of\n *     Commerce, Washington, D.C.), Federal Information Processing Standards\n *     Publication (FIPS) NIST FIPS 202. August 2015.\n *     @see https:\/\/dx.doi.org\/10.6028\/NIST.FIPS.202\n *\n * @copyright Galois, Inc. 2013 - 2024\n * @author David Lazar <lazard@galois.com>\n * @author Marcella Hastings <marcella@galois.com>\n *\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Specification where\n\nparameter\n    \/**\n     * Width: the fixed length of the strings that are permuted.\n     *\n     * The type constraint restricts `b` to the valid permutation widths:\n     * 25, 50, 100, 200, 400, 800, and 1600.\n     * In particular, the final constraint enforces that `b \/ 25` is exactly a\n     * power of two, so 0 and any other multiple of 25 are invalid.\n     *\n     * [FIPS-202] Section 3 (intro).\n     *\/\n    type b : #\n    type constraint (fin b, b % 25 == 0, b <= 1600, (2 ^^ (lg2 (b \/ 25))) * 25 == b)\n\n    \/**\n     * Rounds: the number of iterations of an internal transformation (any\n     * positive integer).\n     * [FIPS-202] Section 3 (intro).\n     *\/\n    type nr : #\n    type constraint (fin nr, nr > 0)\n\n    \/**\n     * Capacity parameter for the sponge construction.\n     * [FIPS-202] Section 4.\n     *\/\n    type c : #\n    type constraint (fin c, c < b, c > 0)\n\n\/**\n * Keccak family of sponge functions.\n *\n * At this time, the implementation is not generic with respect to the sponge\n * construction; this implementation \"inlines\" the sponge algorithm (Alg 8)\n * with the specific functions for Keccak (Sec 5.2).\n * [FIPS-202] Section 4, Algorithm 8; instantiated as in Section 5.2.\n *\/\nKeccak : {d, m} (fin m) => [m] -> [d]\nKeccak M = digest where\n    \/\/ Step 1.\n    P = M # pad `{x = r, m = m}\n    \/\/ Step 2. Note than `len(P)` is not necessarily _exactly_ `m + 2`; that's\n    \/\/ the minimum length of `P`. We use round-up division `\/^` to compute the\n    \/\/ correct number of `r`-length strings.\n    type n = (m + 2) \/^ r\n    \/\/ Step 3. `c` is a parameter for this module.\n    \/\/ Step 4. Ps = P_0, ..., P_{n-1}.\n    Ps = split P : [n][r]\n    \/\/ Step 5.\n    S = zero : [b]\n    \/\/ Step 6. We create a list `Ss` instead of overwriting the variable `S`.\n    Ss = [S] # [Keccak_p (S' ^ (Pi # (zero : [c]))) | Pi <- Ps | S' <- Ss]\n    \/\/ Steps 7 - 10. This step is sometimes known as \"squeeze\".\n    \/\/ The truncation in Step 8 is handled here with `take`{r}`\n    \/\/ The truncation in Step 9 is below with `take`{front=d, back=inf}`.\n    extend : [b] -> [inf]\n    extend Z = (take`{r} Z) # extend (Keccak_p Z)\n    digest = take`{front=d, back=inf} (extend (Ss ! 0))\n\nprivate\n    \/**\n     * Rate parameter for the sponge construction.\n     * [FIPS-202] Section 4.\n     *\/\n    type r = b - c\n\n    \/**\n     * State width of the permutation.\n     * [FIPS-202] Section 3.1.\n     *\/\n    type w = b \/ 25\n\n    \/**\n     * The binary logarithm of the lane size; used to determine the size of\n     * the round constant.\n     * [FIPS-202] Section 3.1.\n     *\/\n    type ell = lg2 w\n\n    \/**\n     * State for Keccak-p[b, nr], represented as an array.\n     * [FIPS-202] Section 3.1.\n     *\/\n    type State = [5][5][w]\n\n    \/**\n     * Convert a string into a state array.\n     * [FIPS-202] Section 3.1.2.\n     *\n     * Note: The spec describes this in terms of all three coordinates\n     * `(x, y, z)`. Since the lanes determined by a pair `(x, y)` are composed\n     * of consecutive bits, we don't index into them separately; instead, we\n     * separate `S` into 25 lanes of length `w` and then place those lanes in\n     * the correct order according to the `(x, y)` coordinates.\n     * For ease of implementation of the subsequent step mappings, the bits of\n     * each lane are reversed.\n     *\/\n    unflatten : [b] -> State\n    unflatten S = [[ Lanes@((5 * y + x))\n        | y <- [0..4]]\n        | x <- [0..4]] where\n        Lanes = map reverse (split`{25} S)\n\n    \/**\n     * Convert a string into a state array, but without indexing.\n     * Equivalent to [FIPS-202] Section 3.1.2.\n     *\/\n    unflatten_noindex : [b] -> State\n    unflatten_noindex S = transpose (groupBy (reverse (groupBy`{w} (reverse S))))\n\n    \/**\n     * ```repl\n     * :prove unflattens_match\n     * ```\n     *\/\n    property unflattens_match S = unflatten S == unflatten_noindex S\n\n    \/**\n     * Convert a state array into a string.\n     * [FIPS-202] Section 3.1.3.\n     *\/\n    flatten : State -> [b]\n    flatten A = S where\n        \/\/ No explicit appending or joining is needed to compute the Lanes.\n        \/\/ But we do need to accomodate the lane reversal that happened in the\n        \/\/ inverse `unflatten` function.\n        Lanes = [[ reverse (A@i@j)\n            | j <- [0..4]]\n            | i <- [0..4]]\n        Planes = [ Lanes@0@j # Lanes@1@j # Lanes@2@j # Lanes@3@j # Lanes@4@j\n            | j <- [0..4]]\n        S = join Planes\n\n    \/**\n     * Convert a state array into a string, but without indexing.\n     * Equivalent to [FIPS-202] Section 3.1.3.\n     *\/\n    flatten_noindex : State -> [b]\n    flatten_noindex A = reverse (join (reverse (join (transpose A))))\n\n    \/**\n     * ```repl\n     * :prove flattens_match\n     * ```\n     *\/\n    property flattens_match A = flatten A == flatten_noindex A\n\n    \/**\n     * One of the step mappings that's part of a round of Keccak-p.\n     *\n     * The effect of this mapping is to XOR each bit in the state with the\n     * parity of two columns in the array. `C` computes the parities, `D`\n     * combines two of the parities for each column, and `A'` completes the\n     * transformation.\n     * [FIPS-202] Section 3.2.1.\n     *\/\n    \u03b8 : State -> State\n    \u03b8 A = A' where\n        C = [ A@x@0 ^ A@x@1 ^ A@x@2 ^ A@x@3 ^ A@x@4\n            | x <- [0..4]]\n        D = [ C @ ((x - 1) % 5) ^ (C @ ((x + 1) % 5) <<< 1)\n            | x <- [0..4]]\n        A' = [[ A@x@y ^ D@x\n            | y <- [0..4]]\n            | x <- [0..4] ]\n\n    \/**\n     * One of the step mappings that's part of a round of Keccak-p.\n     *\n     * The effect of this mapping is to rotate the bits of each lane by a\n     * an _offset_ (computed in `set_lane`) that depends on the `x` and `y`\n     * coordinates of that lane.\n     * [FIPS-202] Section 3.2.2.\n     *\/\n    \u03c1 : State -> State\n    \u03c1 A = A' where\n        \/\/ Step 1.\n        A1 = [[ if (x == 0) && (y == 0) then A@0@0 else zero\n            | y <- [0..4]]\n            | x <- [0..4]]\n                As = [((1,0), A1)] #\n            [ ((y, (2*x + 3*y) % 5), set_lane x y t Ai)\n            | ((x, y), Ai) <- As\n            | t <- [0..23]]\n        (_, A') = As ! 0\n\n        \/\/ Step 3a. Update the lane defined by x' and y'.\n        set_lane x' y' t Ai = [[\n            if (x' == x) && (y' == y) then A@x@y <<< ((t+1)*(t+2)\/2)\n            else Ai@x@y\n            | y <- [0..4]]\n            | x <- [0..4]]\n\n    \/**\n     * Optimized and hard-coded version of `\u03c1`.\n     *\n     * This optimizes the hard-codable parts of `\u03c1` in the following ways:\n     * - Pre-computes the offsets `(t+1)*(t+2) \/ 2`\n     * - Pre-computes the corresponding sequence of lane indexes (e.g. the\n     *   series defined by `(y, (2x + 3y) % 5))`\n     * - Re-orders the offsets and the lane indexes to be in the same order\n     *   that we get if we iterate over the lanes generated by `join A` (e.g.\n     *   (0,0), (0,1), (0,2), ...)\n     * - Maps directly over A, rotating each lane by the expected offset,\n     *   instead of iteratively updating the lanes\n     *\n     * This provides a 2x speedup.\n     *\n     * Equivalent to [FIPS-202] Section 3.2.2, Algorithm 2.\n     *\/\n    \u03c1_hardcoded : State -> State\n    \u03c1_hardcoded A = A' where\n        A' = groupBy [ a <<< offset | a <- join A | offset <- t_offsets]\n\n        \/\/ This is technically equivalent to Table 2, but we index in the\n        \/\/ \"normal\" way e.g. the top-left corner is (0, 0) and the bottom-right\n        \/\/ is (4, 4), unlike the the table.\n        \/\/ We also write these in hex instead of base-10.\n        t_offsets = [\n            0x000, 0x024, 0x003, 0x069, 0x0d2,\n            0x001, 0x12c, 0x00a, 0x02d, 0x042,\n            0x0be, 0x006, 0x0ab, 0x00f, 0x0fd,\n            0x01c, 0x037, 0x099, 0x015, 0x078,\n            0x05b, 0x114, 0x0e7, 0x088, 0x04e\n        ]\n\n    \/**\n     * Prove that the hardcoded version of `\u03c1` is correct.\n     * ```repl\n     * :prove hardcoded_rho_is_correct\n     * ```\n     *\/\n    property hardcoded_rho_is_correct A = \u03c1 A == \u03c1_hardcoded A\n\n    \/**\n     * One of the step mappings that's part of a round of Keccak-p.\n     *\n     * The effect of this mapping is to rearrange the position of the lanes,\n     * based on an offset of the `x` and `y` coordinates.\n     * [FIPS-202] Section 3.2.3.\n     *\/\n    \u03c0 : State -> State\n    \u03c0 A = [[ A @((x + 3 * y) % 5) @x\n        | y <- [0..4]]\n        | x <- [0..4]]\n\n    \/**\n     * One of the step mappings that's part of a round of Keccak-p.\n     *\n     * The effect of this mapping is to XOR each bit with a non-linear function\n     * of two other bits in its row.\n     * [FIPS-202] Section 3.2.4.\n     *\n     * Note: in the first line, XOR 1 on a single bit is equivalent to bitwise\n     * NOT. Since we operate over the whole slice defined by each z-coordinate,\n     * it's nicer to use `~`. You can see the NOT gates in Figure 6.\n     *\/\n    \u03c7 : State -> State\n    \u03c7 A = [[ A @x @y ^ (~A @((x + 1) % 5) @y && A @((x + 2) % 5) @y)\n        | y <- [0..4]]\n        | x <- [0..4]]\n\n    \/**\n     * Compute the round constant for the `t`th lane.\n     *\n     * [FIPS-202] Section 3.2.5, Algorithm 5.\n     *\/\n    rc : Integer -> Bit\n    rc t = if (t % 255) == 0 then 1 \/\/ Step 1.\n         else Rs @ (t') @0          where\n                          Rs = [0b10000000] # [lfsr R | R <- Rs ]\n             \/\/ Step 3. Linear feedback shift register.\n             \/\/ The truncation in step f is done manually in the return value.\n             lfsr : [8] -> [8]\n             lfsr Rin = [R0, R@1, R@2, R@3, R4, R5, R6, R@7]\n                 where\n                     R = 0b0 # Rin\n                     R0 = R@0 ^ R@8\n                     R4 = R@4 ^ R@8\n                     R5 = R@5 ^ R@8\n                     R6 = R@6 ^ R@8\n             \/\/ Cryptol's SMT interface disallows index by symbolic `Integer`.\n             \/\/ To faciliate proofs, we convert to a bitvector.\n             \/\/ Justification: for all integers i,\n             \/\/ (i % 255) % 256 == (i % 255)\n             t' = fromInteger (t % 255) : [8]\n\n    \/**\n     * Hardcode the round constant values.\n     *\n     * Since the `rc` function doesn't depend on any of the functor parameters,\n     * this hardcoded value is correct for all instantiations.\n     * We computed the value `constants` with:\n     * ```cryptol\n     * [rc i | i <- [0..255]]\n     * ```\n     *\n     * This provides a 4x speedup.\n     *\n     * Equivalent to [FIPS-202] Section 3.2.5, Algorithm 5.\n     *\/\n    rc_hardcoded : Integer -> Bit\n    rc_hardcoded t = constants @ (t') where\n        constants = join [\n            0x80b1e87f90a7d57062b32fde6ee54a25,\n            0xa339e361175edf0d35b504ec9303a471\n        ]\n        \/\/ Cryptol's SMT interface disallows index by symbolic `Integer`.\n        \/\/ To faciliate proofs, we convert to a bitvector.\n        \/\/ Justification: for all integers i,\n        \/\/ (i % 255) % 256 == (i % 255)\n        t' = fromInteger (t % 255) : [8]\n\n    \/*\n     * Some properties justifying the conversion of `Integer -> [8]`\n     * in `rc` and `rc_hardcoded`\n     *\/\n    private\n        \/**\n        * A fact about modular arithmetic:\n        *   For any integers `i`, `m`, `n`, such that `m > 0` and `m < n`,\n        *   `i mod m mod n == i mod m`\n        *   I.e., the modular reduction is equivalent to the smaller modulus.\n        *\/\n        index_eq: {ix} (Integral ix, Cmp ix, Literal 0 ix) => ix -> ix -> ix -> Bit\n        index_eq i m n = m > 0 ==> m <= n ==> (i % m) % n == (i % m)\n\n        \/**\n        * An instance of the fact above for Cryptol `Integer`.\n        * ```repl\n        * :prove index_eq_int\n        * ```\n        *\/\n        property index_eq_int = index_eq `{Integer}\n\n        \/**\n        * A consequence of the property above is that reducing an integer\n        * mod 255 and then converting it to an `[8]` is always in `Z 255`.\n        * ```repl\n        * :prove value_bound\n        * ```\n        *\/\n        value_bound: Integer -> Bit\n        property value_bound i = (fromInteger (i % 255) : [8]) < 255\n\n    \/**\n     * Prove that the hardcoded round constants are correct.\n     * ```repl\n     * :prove round_constants_correctly_hardcoded\n     * ```\n     *\/\n    property round_constants_correctly_hardcoded t = rc_hardcoded t == rc t\n\n    \/**\n     * One of the step mappings that's part of a round of Keccak-p.\n     *\n     * The effect is to modify some of the bits of the Lane defined by\n     * `(0, 0)` according to the round index.\n     * [FIPS-202] Section 3.2.5, Algorithm 6.\n     *\/\n    \u03b9 : State -> Integer -> State\n    \u03b9 A ir = A'' where\n        \/\/ Step 1.\n        A' = A\n        \/\/ Step 2.\n        RC0 = zero : [w]\n        \/\/ Step 3. 0 is the identity for XOR, so we iteratively set the\n        \/\/ `2^j-1`th element by XORing the previously-set bits of RC with the\n        \/\/ correct value at the desired index.\n        RCs = [RC0] # [RC' ^ (zext`{w} [rc_hardcoded (toInteger j + 7 * ir)] << (2^^j - 1))\n            | RC' <- RCs\n            | j <- [0..ell] ]\n        RC = (RCs ! 0) : [w]\n                A'' = [[ if (x == 0) && (y == 0) then A'@0@0 ^ RC else A'@x@y\n            | y <- [0..4]]\n            | x <- [0..4]]\n\n    \/**\n     * Padding rule `pad10*1`.\n     *\n     * This function produces padding e.g. a string with an appropriate length\n     * to append to another string.\n     * [FIPS-202] Section 5.1.\n     *\n     * Note: The spec says the output length is a positive multiple of `x` and\n     * defines it to be, basically: `(- m - 2) mod x + 2`. We can't encode this\n     * exactly as-is in the type signature because Cryptol doesn't support\n     * negative numbers in types (`-m`). Instead, we do the following:\n     *      (m + 2)           : The minimum length of the original message and\n     *                        : the padding\n     *      (m + 2) \/^ x      : The multiplier of `x` that determines the\n     *                        : ultimate length of the message + padding\n     * x * ((m + 2) \/^ x)     : The total length of the message + padding\n     * x * ((m + 2) \/^ x) - m : The total length of the padding alone\n     *\/\n    pad : {x, m} (fin x, fin m, x >= 1) => [x * ((m + 2) \/^ x) - m]\n    pad = [1] # zero # [1]\n\n    \/**\n     * The Keccak-p[b, nr] permutation.\n     * [FIPS-202] Section 3.3, Algorithm 7.\n     *\/\n    Keccak_p : [b] -> [b]\n    Keccak_p S = S' where\n        \/\/ The round transformation is defined in [FIPS-202] Section 3.3.\n        Rnd A ir = \u03b9 (\u03c7 (\u03c0 (\u03c1_hardcoded (\u03b8 A)))) ir\n\n        \/\/ Step 1.\n        A0 = unflatten_noindex S\n        \/\/ Step 2.\n        \/\/ The round index `ir` is allowed to be negative, but Cryptol types\n        \/\/ must be non-negative. Thus we iterate over the number of rounds and\n        \/\/ compute the round index as a value, rather than a type.\n        As = [A0] # [ Rnd A ir where\n                ir = 12 + 2 * `ell - r\n            | A <- As\n            | r <- [nr, nr - 1 .. 1]]\n        \/\/ Step 3.\n        S' = flatten_noindex (As ! 0)\n\n    \/**\n     * Keccak-f family of permutations.\n     *\n     * This specializes `Keccak-p` to the case where `nr = 12 + 2*ell`; we\n     * enforce this in the type constraint on this function.\n     * [FIPS-202] Section 3.4.\n     *\/\n    Keccak_f : (nr == 12 + 2 * ell) => [b] -> [b]\n    Keccak_f = Keccak_p\n\n\/**\n * See https:\/\/keccak.team\/files\/Keccak-reference-3.0.pdf, Section 1.2\n * ```repl\n * :prove unflatten_correct\n * ```\n *\/\nunflatten_correct : [12] -> [12] -> [12] -> [b] -> Bit\nproperty unflatten_correct x y z p =\n    x < 5 ==> y < 5 ==> z < (`w:[12]) ==>\n    p@((5*y + x)*`w + z) == unflatten p @ x @ y ! z\n\n\/**\n * Flatten and unflatten must be each other's inverses.\n * ```repl\n * :prove flatten_correct\n * ```\n *\/\nproperty flatten_correct s = unflatten (flatten s) == s\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/SHA3.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the SHA-3 hash function implementations (`sha3`, `hash`, and `hashBytes`) against the SHA-3 specification as defined in FIPS-202. Include properties that check the output digest length, the correct handling of input bit ordering, and the relationship between the different interface functions. Ensure the properties can be used with Cryptol's :check or :prove commands."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::SHA3 where\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\nimport Primitive::Keyless::Hash::SHA3::Specification where\n    type b = 1600\n    type nr = 24\n    type c = 2 * digest\n\nparameter\n    \/**\n     * Digest length -- that is, the length of the output of the hash function.\n     *\n     * The spec allows the 5 FIPS-approved digest lengths : 160, 224, 256, 384,\n     * and 512 bits. The constraint here is looser than that requirement; the\n     * restriction that 8 divides the digest length is to allow the byte-wise\n     * `hashBytes` function.\n     *\/\n    type digest : #\n    type constraint (fin digest, digest % 8 == 0, digest >= 224, digest <= 512)\n\n\/**\n * Length of the hash digest.\n *\n * This is made public to instantiate the `HashInterface`.\n *\/\ntype DigestLength = digest\n\n\/**\n * There is no upper bound on the message length for SHA3 hashes.\n *\/\ntype MessageUpperBound = inf\n\n\/**\n * Security strength (in bits) of the hash function.\n * [FIPS-202] Appendix A.1, Table 4.\n * @see Hash functions webpage: https:\/\/csrc.nist.gov\/projects\/hash-functions#security-strengths\n *\n * This is made public to instantiate the `HashInterface`.\n *\/\ntype SecurityStrength = DigestLength \/ 2\n\n\/**\n * SHA-3 hash function specification.\n * [FIPS-202] Section 6.1.\n *\n * Note that the specification of `c` is above, in the instantiation of the\n * `Keccak` module.\n *\n * This expects input and produces output in the bit ordering used by the\n * `Keccak` spec, where bytes are in MSB order and the bits in each byte are\n * in LSB order. Use the `KeccakBitOrdering::toBytes` function to transform\n * the input and output to Cryptol-standard MSB order\n *\/\nsha3 : {n} (fin n) => [n] -> [digest]\nsha3 M = Keccak`{d=digest} (M # 0b01)\n\n\/**\n * SHA-3 hash function specification.\n * [FIPS-202] Section 6.1.\n *\n * Note that the specification of `c` is above, in the instantiation of the\n * `keccak` module.\n *\n * This expects input and output in MSB order. It handles conversion to and\n * from the bit ordering expected by `Keccak`. If input is provided in the\n * format described in [FIPS-202] Appendix B (a hex string with an even\n * number of digits and an actual length `n`), use the `KOB::truncate` function\n * to get the correct input.\n *\/\nhash : {n} (fin n) => [n] -> [digest]\nhash M = KBO::reverseBitOrdering (Keccak`{d=digest} ((KBO::reverseBitOrdering M) # 0b01))\n\n\/**\n * SHA-3 hash function specification over byte-delimited inputs.\n *\n * This expects input and output in MSB order. It handles conversion to and\n * from the bit ordering expected by `Keccak`. If input is provided in the\n * format described in [FIPS-202] Appendix B (a hex string with an even\n * number of digits and an actual length `n`), use the `KOB::truncate` function\n * to get the correct input.\n *\/\nhashBytes : {m} (fin m) => [m][8] -> [digest \/ 8][8]\nhashBytes M = split (hash (join M))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify the correctness of the SHA-384 internal hash functions and constants defined in the module Primitive::Keyless::Hash::SHA2Internal::SHA384. These properties should verify that the initial hash values (H0), the round constants (K), and the bitwise rotation and shift functions (SIGMA_0, SIGMA_1, sigma_0, sigma_1) conform to the SHA-384 standard as defined in FIPS PUB 180-4."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2Internal::SHA384 = Primitive::Keyless::Hash::SHA2Internal::SHA where\n\ntype wp = 64\n\ntype digest_size = 384\n\ntype j = 80\n\nH0 = [ 0xcbbb9d5dc1059ed8, 0x629a292a367cd507, 0x9159015a3070dd17, 0x152fecd8f70e5939,\n       0x67332667ffc00b31, 0x8eb44a8768581511, 0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4]\n\nK = [ 0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n      0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n      0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n      0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n      0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n      0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n      0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n      0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n      0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n      0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n      0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n      0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n      0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n      0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n      0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n      0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n      0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n      0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n      0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n      0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817]\n\nSIGMA_0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)\n\nSIGMA_1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)\n\nsigma_0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)\n\nsigma_1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify the correctness of the SHA-256 internal compression function as defined in the module Primitive::Keyless::Hash::SHA2Internal::SHA256. These properties should verify that the function correctly updates the hash state according to the SHA-256 algorithm, using the constants H0 and K, and the bitwise operations SIGMA_0, SIGMA_1, sigma_0, and sigma_1. Include properties that check the preservation of digest size and the expected transformations on input blocks."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2Internal::SHA256 = Primitive::Keyless::Hash::SHA2Internal::SHA where\n\ntype wp = 32\n\ntype digest_size = 256\n\ntype j = 64\n\nH0 = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n       0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]\n\nK = [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]\n\nSIGMA_0 x = (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)\n\nSIGMA_1 x = (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)\n\nsigma_0 x = (x >>> 7) ^ (x >>> 18) ^ (x >> 3)\n\nsigma_1 x = (x >>> 17) ^ (x >>> 19) ^ (x >> 10)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/Equivalence.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the equivalence between the spec-adherent SHA2 implementations and their corresponding internal SHA2 implementations for both SHA256 and SHA384. Include properties that compare the hash outputs for bit-vector inputs as well as byte-wise inputs, ensuring that the internal implementations produce identical results to the spec-adherent versions. Use appropriate type constraints and provide properties suitable for :check and :exhaust commands."},{"role":"assistant","content":"```cryptol\n\/**\n * Properties demonstrating equivalence of the spec-adherent `SHA2`\n * implementation and the alternative `SHA2Internal` implementation.\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA2Internal::Equivalence where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA_256\nimport Primitive::Keyless::Hash::SHA2Internal::SHA256 as SHAI_256\n\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 as SHA_384\nimport Primitive::Keyless::Hash::SHA2Internal::SHA384 as SHAI_384\n\n\/**\n * The `internal` version of SHA256 matches the spec-adherent version.\n * ```repl\n * :exhaust sha256ImplsAreEquivalent`{10}\n * :check sha256ImplsAreEquivalent`{256}\n * ```\n *\/\nsha256ImplsAreEquivalent : {m} (fin m, width m <= SHA_256::MessageUpperBound) => [m] -> Bit\nproperty sha256ImplsAreEquivalent m = SHA_256::hash m == SHAI_256::sha m\n\n\/**\n * The byte-wise APIs for the two SHA256 implementations match.\n * ```repl\n * :exhaust sha256BytewiseImplsAreEquivalent`{1}\n * :check sha256BytewiseImplsAreEquivalent`{256}\n * ```\n *\/\nsha256BytewiseImplsAreEquivalent : {m} (fin m, width (8 * m) <= SHA_256::MessageUpperBound) => [m][8] -> Bit\nproperty sha256BytewiseImplsAreEquivalent m = join (SHA_256::hashBytes m) == SHAI_256::SHAImp m\n\n\/**\n * The `internal` version of SHA384 matches the spec-adherent version.\n * ```repl\n * :exhaust sha384ImplsAreEquivalent`{10}\n * :check sha384ImplsAreEquivalent`{256}\n * ```\n *\/\nsha384ImplsAreEquivalent : {m} (fin m, width m <= SHA_384::MessageUpperBound) => [m] -> Bit\nproperty sha384ImplsAreEquivalent m = SHA_384::hash m == SHAI_384::sha m\n\n\/**\n * The byte-wise APIs for the two SHA384 implementations match.\n * ```repl\n * :exhaust sha384BytewiseImplsAreEquivalent`{1}\n * :check sha384BytewiseImplsAreEquivalent`{256}\n * ```\n *\/\nsha384BytewiseImplsAreEquivalent : {m} (fin m, width (8 * m) <= SHA_384::MessageUpperBound) => [m][8] -> Bit\nproperty sha384BytewiseImplsAreEquivalent m = join (SHA_384::hashBytes m) == SHAI_384::SHAImp m\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/SHA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the SHA2Internal::SHA module's imperative implementation (SHAImp and SHAImp_Array) against its functional specification (sha). Include properties that check equivalence of hash outputs for arbitrary input messages, and verify that the internal state transitions (SHAUpdate, SHAFinal) maintain consistency with the functional model. Also specify properties for the correctness of the compression and message schedule functions (compress_Common, messageSchedule_Common) according to the SHA-2 standard."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2Internal::SHA where\n\nimport Array\nimport Common::ByteArray\n\nsha : {L} (2 * w >= width L) => [L] -> [digest_size]\nsha M = take (join (SHA_2_Common' [ split x | x <- parse`{num_blocks L} (pad`{L} M) ]))\n\nparameter\n\n  \/** Word size\n    Specifications are based on word size w, rather than digest size (8 * w)\n    or block size (m == 16 * w), in order to avoid confusing Cryptol's type\n    constraint verifier with integer division.\n  *\/\n\n  type wp : #\n  type constraint (fin wp, wp >= 2, 32 >= width wp)\n\n  type digest_size : #\n  type constraint (fin digest_size, 8*wp >= digest_size)\n\n  \/** The number of iterations in the hash computation\n  (i.e. the number of words in K) *\/\n\n  type j : #\n  type constraint (fin j, j >= 17)\n\n  H0 : [8][wp]\n  K  : [j][wp]\n\n  \/* FIPS 180-4 defines lowercase and uppercase\n      (respective to the Greek alphabet) sigma functions for SHA-256 and SHA-512.\n      (4.4)-(4.7) SHA-224, SHA-256 (w==32)\n      (4.10)-(4.13) SHA-384, SHA-512, SHA-512\/224, SHA-512\/256 (w==64) *\/\n\n  SIGMA_0 : [wp] -> [wp]\n  SIGMA_1 : [wp] -> [wp]\n  sigma_0 : [wp] -> [wp]\n  sigma_1 : [wp] -> [wp]\n\n\/\/ Export some of the parameters\nSHAH0 = H0\nS0 = SIGMA_0\nS1 = SIGMA_1\ns0 = sigma_0\ns1 = sigma_1\ntype digestSize = digest_size\n\n\/**\n * The security strength of a hash function is the minimum of its collision\n * resistance strength, preimage resistance strength, and second preimage\n * resistance strength. For the SHA2 family of hash functions, the smallest\n * of these is the collision resistance strength.\n *\n * [SP-800-107r1] Section 4.2, Table 1.\n *\/\ntype securityStrength = digest_size \/ 2\n\n\/\/ Export Ch, Maj and the block function to be used in SAW proofs\n\/** (4.1) (w==32), (4.2) (w==32), (4.8) (w==64) *\/\nCh : [wp] -> [wp] -> [wp] -> [wp]\nCh x y z = (x && y) ^ (~x && z)\n\n\n\/** (4.1) (w==32), (4.3) (w==32), (4.9) (w==64) *\/\nMaj : [wp] -> [wp] -> [wp] -> [wp]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nprocessBlock_Common : [8][wp] -> [16][wp] -> [8][wp]\nprocessBlock_Common H Mi = compress_Common H (messageSchedule_Common Mi)\n\n\nprivate\n  type w = wp\n\n  \/** block size corresponding to word size for all SHA algorithms in\n      FIPS 180-4 *\/\n  type block_size = 16 * w\n\n  type num_blocks L     = (L+1+2*w) \/^ block_size\n  type padded_size L    = num_blocks L * block_size\n\n\n  \/**\n    5.1 Padding the Message\n    5.1.1 SHA-1, SHA-224 and SHA-256 (w==32)\n    5.1.2 SHA-384, SHA-512, SHA-512\/224 and SHA-512\/256 (w==64)\n\n  The constraint ensure that the message size, `L`, fits within a\n  (2 * w)-bit word (consistent w\/ Figure 1)\n  *\/\n  pad : {L} (2 * w >= width L) => [L] -> [padded_size L]\n  pad M = M # 0b1 # zero # (`L : [2*w])\n\n  \/**\n    5.2 Parsing the Message\n    5.2.1 SHA-1, SHA-224 and SHA-256 (w==32)\n    5.2.2 SHA-384, SHA-512, SHA-512\/224 and SHA-512\/256 (w==64)\n  *\/\n  parse : {m} [m * block_size] -> [m][block_size]\n  parse = split\n\n  \/**\n  SHA-256 and SHA-512 (and their respective derivatives) use a similar\n  message schedule that can be expressed in the same way relative to their\n  respective sigma functions.\n\n    6.2.2 SHA-256 Hash Computation (w==32, j=64)\n    6.4.2 SHA-512 Hash Computation (w==64, j=80)\n  *\/\n  messageSchedule_Common : [16][w] -> [j][w]\n  messageSchedule_Common Mi = take W\n    where\n    W : [inf][_]\n    W = Mi # [ w1 + s0 w2 + w3 + s1 w4\n             | w1 <- W\n             | w2 <- drop`{1} W\n             | w3 <- drop`{9} W\n             | w4 <- drop`{14} W\n             ]\n\n\n  \/**\n  Amazon S2N's SHA-256 specification includes a compression routine intended\n  to reflect typical implementations.  This same compression routine applies\n  to SHA-512, modulo respective constants, sigma functions,\n  and message schedules.\n  *\/\n\n  compress_Common : [8][w] -> [j][w] -> [8][w]\n  compress_Common H W =\n        [ (as ! 0) + (H @ 0),\n      (bs ! 0) + (H @ 1),\n      (cs ! 0) + (H @ 2),\n      (ds ! 0) + (H @ 3),\n      (es ! 0) + (H @ 4),\n      (fs ! 0) + (H @ 5),\n      (gs ! 0) + (H @ 6),\n      (hs ! 0) + (H @ 7)\n    ]\n    where\n      T1 = [h + S1 e + Ch e f g + k_t + w_t\n                | h <- hs | e <- es | f <- fs | g <- gs | k_t <- K | w_t <- W]\n      T2 = [ S0 a + Maj a b c | a <- as | b <- bs | c <- cs]\n      hs = take`{j + 1}([H @ 7] # gs)\n      gs = take`{j + 1}([H @ 6] # fs)\n      fs = take`{j + 1}([H @ 5] # es)\n      es = take`{j + 1}([H @ 4] # [d + t1 | d <- ds | t1 <- T1])\n      ds = take`{j + 1}([H @ 3] # cs)\n      cs = take`{j + 1}([H @ 2] # bs)\n      bs = take`{j + 1}([H @ 1] # as)\n      as = take`{j + 1}([H @ 0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\n\n  SHA_2_Common' : {L} (fin L) => [L][16][w] -> [8][w]\n  SHA_2_Common' blocks = hash ! 0\n    where\n    hash = [H0] # [ processBlock_Common h b | h <- hash | b <- blocks]\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ SHA imperative specification\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/*\n * This section contains an SHA specification that more closely matches the\n * BoringSSL C implementation to simplify SAW correctness proofs of the\n * implementation.\n *\/\n\n\/\/\/\/\/\/\/\/ Imperative top level \/\/\/\/\/\/\/\/\n\ntype SHAState = { h : [8][w]\n                , block : [w * 2][8]\n                , n : [32]\n                , sz : [w * 2]\n                }\n\n\/\/ Initial state for SHA\nSHAInit : SHAState\nSHAInit = { h = H0\n          , block = zero\n          , n = 0\n          , sz = 0\n          }\n\n\/\/ Process message being hashed, iteratively updating the SHA state with the\n\/\/ input message.\nSHAUpdate : {n} (fin n) => SHAState -> [n][8] -> SHAState\nSHAUpdate sinit bs = ss!0\n  where ss = [sinit] # [ SHAUpdate1 s b | s <- ss | b <- bs ]\n\n\/\/ Add padding and size and process the final block.\nSHAFinal : SHAState -> [digest_size]\nSHAFinal s = take (join (processBlock_Common h b'))\n  \/\/ Because the message is always made up of bytes, and the size is a\n  \/\/ fixed number of bytes, the 1 pad will always be at least a byte.\n  where s' = SHAUpdate1 s 0x80\n        \/\/ Don't need to add zeros. They're already there. Just update\n        \/\/ the count of bytes in this block. After adding the 1 pad, there\n        \/\/ are two possible cases: the size will fit in the current block,\n        \/\/ or it won't.\n        (h, b) = if s'.n <= (`w*2 - (`w\/4)) then (s'.h, s'.block)\n                 else (processBlock_Common s'.h (split (join s'.block)), zero)\n        b' = split (join b || (zero # s.sz))\n\n\/\/ Imperative SHA implementation\nSHAImp : {n} (fin n) => [n][8] -> [digest_size]\nSHAImp msg = SHAFinal (SHAUpdate SHAInit msg)\n\n\nprivate\n\n  \/\/ SHAUpdate1 updates a single byte at position s.n in s.block and return a\n  \/\/ new state to pass to subsequent updates.  If s.n is 128, updates position 0\n  \/\/ to b and zeros the remainder of the block, setting s.n to 1 for the next\n  \/\/ update.\n  SHAUpdate1 : SHAState -> [8] -> SHAState\n  SHAUpdate1 s b =\n    if s.n == (2 * `w - 1)\n      then { h = processBlock_Common s.h (split (join (update s.block s.n b)))\n           , block = zero\n           , n = 0\n           , sz = s.sz + 8\n           }\n      else { h = s.h\n           , block = update s.block s.n b\n           , n = s.n + 1\n           , sz = s.sz + 8\n           }\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ SHA imperative specification - SMT Array\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\ntype SHAState_Array =\n  { h : [8][w]\n  , block : ByteArray\n  , n : [32]\n  , sz : [w * 2]\n  }\n\nSHAInit_Array : SHAState_Array\nSHAInit_Array =\n  { h = H0\n  , block = arrayConstant 0\n  , n = 0\n  , sz = 0\n  }\n\nSHAUpdate_Array : (w >= 32) => SHAState_Array -> ByteArray -> [64] -> SHAState_Array\nSHAUpdate_Array state data len =\n  if state.n != 0\n    then if len < 2 * `w - n\n      then state'\n      else state''\n    else state'''\n where\n   n = 0 # state.n\n   state' = { h = state.h, block = block', n = drop n', sz = state.sz + (0 # len) * 8 }\n    where\n      block' = arrayCopy state.block n data 0 len\n      n' = n + len\n   state'' = { h = h'', block = block''', n = drop n''', sz = state.sz + (0 # len) * 8 }\n    where\n      h' = processBlock state.h (arrayCopy state.block n data 0 (2 * `w - n)) 0\n      block' = arrayCopy state.block n data 0 (2 * `w - n)\n      index' = 2 * `w - n\n      len' = len - (2 * `w - n)\n      (h'', index'', len'') = if len' >= 2 * `w\n        then\n          ( (processBlocks h' (arrayCopy (arrayConstant 0) 0 data index' ((len' \/ (2 * `w)) * (2 * `w))) 0 (len' \/ (2 * `w)))\n          , index' + len' - (len' % (2 * `w))\n          , len' % (2 * `w)\n          )\n        else (h', index', len')\n      (block''', n''') = if len'' != 0\n        then ((arrayCopy block' 0 data index'' len''), len'')\n        else (block', 0)\n   state''' = { h = h'', block = block''', n = drop n''', sz = state.sz + (0 # len) * 8 }\n    where\n      (h'', index'', len'') = if len >= 2 * `w\n        then\n          ( (processBlocks state.h data 0 (len \/ (2 * `w)))\n          , len - (len % (2 * `w))\n          , len % (2 * `w)\n          )\n        else (state.h, 0, len)\n      (block''', n''') = if len'' != 0\n        then ((arrayCopy state.block 0 data index'' len''), len'')\n        else (state.block, n)\n\nSHAFinal_Array : (w >= 32) => SHAState_Array -> [digest_size]\nSHAFinal_Array state = take (join h''')\n  where\n    n = 0 # state.n\n    block' = arrayUpdate state.block n 0x80\n    n' = n + 1\n    (h'', block'', n'') = if n' > 2 * `w - `w \/ 4\n      then ((processBlock state.h (arraySet block' n' 0 (2 * `w - n')) 0), (arraySet block' n' 0 (2 * `w - n')), 0)\n      else (state.h, block', n')\n    h''' = processBlock\n      h''\n      (arrayRangeUpdate\n        (arraySet block'' n'' 0 (2 * `w - `w \/ 4 - n''))\n        (2 * `w - `w \/ 4)\n        (split`{parts=(w+3)\/4} (0 # state.sz)))\n      0\n\n\/\/ Imperative SHA implementation\nSHAImp_Array : (w >= 32) => ByteArray -> [64] -> [digest_size]\nSHAImp_Array msg len = SHAFinal_Array (SHAUpdate_Array SHAInit_Array msg len)\n\n\nprocessBlocks : [8][w] -> ByteArray -> [64] -> [64] -> [8][w]\nprocessBlocks [a, b, c, d, e, f, g, h] data index n = processBlock [a', b', c', d', e', f', g', h'] data index'\n  where\n    (a', b', c', d', e', f', g', h', index') = processBlocksLoop n data a b c d e f g h index\n\nprocessBlock : [8][w] -> ByteArray -> [64] -> [8][w]\nprocessBlock h block index =\n  processBlock_Common h (split (join (arrayRangeLookup block index)))\n\nprocessBlocksLoop : [64] -> ByteArray -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [64] -> ([w], [w], [w], [w], [w], [w], [w], [w], [64])\nprocessBlocksLoop num data a b c d e f g h index = if (index + 2 * `w) < (num * 2 * `w)\n  then processBlocksLoop num data a' b' c' d' e' f' g' h' (index + 2 * `w)\n  else (a, b, c, d, e, f, g, h, index)\n  where\n    [a', b', c', d', e', f', g', h'] = (processBlock [a, b, c, d, e, f, g, h] data index)\n\narrayRangeEqual_arrayRangeLookup_lemma : {n} (fin n, n >= 1, n <= 1000) => ByteArray -> ByteArray -> Bit\narrayRangeEqual_arrayRangeLookup_lemma a b = arrayRangeEqual a 0 b 0 `n == (arrayRangeLookup`{n=n} a 0 == arrayRangeLookup b 0)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Tests\/SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the SHA384 hash function implementation against the provided test vectors in the file. Each property should prove that hashing the given input string produces the expected output digest as specified in the test vectors."},{"role":"assistant","content":"```cryptol\n\/**\n * Test vectors for SHA384 as specified in [FIPS-180-4].\n *\n * These vectors were originally specified in [CSG-SHA], but we also used the\n * convenient collected test vectors page from David Ireland.\n * @see DI Management https:\/\/www.di-mgt.com.au\/sha_testvectors.html\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\n * [CSG-SHA]: National Institute of Standards and Technology. Example\n *     algorithms - Secure hashing.\n *     @see http:\/\/csrc.nist.gov\/groups\/ST\/toolkit\/examples.html\n *     @see https:\/\/csrc.nist.gov\/csrc\/media\/projects\/cryptographic-standards-and-guidelines\/documents\/examples\/sha_all.pdf\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Tests::SHA384 where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 as SHA384\n\n\/**\n * ```repl\n * :prove abcWorks\n * ```\n *\/\nproperty abcWorks = SHA384::hash (join \"abc\") == output where\n    output = join [\n        0xcb00753f45a35e8b, 0xb5a03d699ac65007, 0x272c32ab0eded163,\n        0x1a8b605a43ff5bed, 0x8086072ba1e7cc23, 0x58baeca134c825a7\n    ]\n\n\n\/**\n * ```repl\n * :prove emptyStringWorks\n * ```\n *\/\nproperty emptyStringWorks = SHA384::hash [] == output where\n    output = join [\n        0x38b060a751ac9638, 0x4cd9327eb1b1e36a, 0x21fdb71114be0743,\n        0x4c0cc7bf63f6e1da, 0x274edebfe76f65fb, 0xd51ad2f14898b95b\n    ]\n\n\/**\n * ```repl\n * :prove alphabet448\n * ```\n *\/\nproperty alphabet448 = SHA384::hash input == output where\n    input = join \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    output = join [\n        0x3391fdddfc8dc739, 0x3707a65b1b470939, 0x7cf8b1d162af05ab,\n        0xfe8f450de5f36bc6, 0xb0455a8520bc4e6f, 0x5fe95b1fe3c8452b\n    ]\n\n\/**\n * ```repl\n * :prove alphabet896\n * ```\n *\/\nproperty alphabet896 = SHA384::hash input == output where\n    input = join \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n    output = join [\n        0x09330c33f71147e8, 0x3d192fc782cd1b47, 0x53111b173b3b05d2,\n        0x2fa08086e3b0f712, 0xfcc7c71a557e2db9, 0x66c3e9fa91746039\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Tests\/SHA224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the SHA224 hash function implementation using the provided test vectors from the SHA224.cry file. Each property should assert that hashing the given input string produces the expected output digest as specified in the test vectors. Include properties for inputs such as \"abc\", the empty string, and the specified alphabet strings."},{"role":"assistant","content":"```cryptol\n\/**\n * Test vectors for SHA224 as specified in [FIPS-180-4].\n *\n * These vectors were originally specified in [CSG-SHA], but we also used the\n * convenient collected test vectors page from David Ireland.\n * @see DI Management https:\/\/www.di-mgt.com.au\/sha_testvectors.html\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\n * [CSG-SHA]: National Institute of Standards and Technology. Example\n *     algorithms - Secure hashing.\n *     @see http:\/\/csrc.nist.gov\/groups\/ST\/toolkit\/examples.html\n *     @see https:\/\/csrc.nist.gov\/csrc\/media\/projects\/cryptographic-standards-and-guidelines\/documents\/examples\/sha_all.pdf\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Tests::SHA224 where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA224 as SHA224\n\n\/**\n * ```repl\n * :prove abcWorks\n * ```\n *\/\nproperty abcWorks = SHA224::hash (join \"abc\") == output where\n    output = join [\n        0x23097d22, 0x3405d822, 0x8642a477, 0xbda255b3,\n        0x2aadbce4, 0xbda0b3f7, 0xe36c9da7\n    ]\n\n\/**\n * ```repl\n * :prove emptyStringWorks\n * ```\n *\/\nproperty emptyStringWorks = SHA224::hash [] == output where\n    output = join [\n        0xd14a028c, 0x2a3a2bc9, 0x476102bb, 0x288234c4,\n        0x15a2b01f, 0x828ea62a, 0xc5b3e42f\n    ]\n\n\/**\n * ```repl\n * :prove alphabet448\n * ```\n *\/\nproperty alphabet448 = SHA224::hash input == output where\n    input = join \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    output = join [\n        0x75388b16, 0x512776cc, 0x5dba5da1, 0xfd890150,\n        0xb0c6455c, 0xb4f58b19, 0x52522525\n    ]\n\n\/**\n * ```repl\n * :prove alphabet896\n * ```\n *\/\nproperty alphabet896 = SHA224::hash input == output where\n    input = join \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n    output = join [\n        0xc97ca9a5, 0x59850ce9, 0x7a04a96d, 0xef6d99a9,\n        0xe0e0e2ab, 0x14e6b8df, 0x265fc0b3\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Tests\/SHA256_FFI.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that verifies the equivalence between the SHA256 hash computed by the FFI implementation and the native Cryptol implementation for all valid input message lengths. The property should compare the outputs of both implementations on the same input and return true if they match."},{"role":"assistant","content":"```cryptol\n\/**\n * Test for SHA256 FFI implementation.\n *\n * We test the SHA256 FFI implementation by comparing its output to the Cryptol\n * implementation's output.\n *\n * @copyright Galois, Inc\n * @author Alex J. Malozemoff <amaloz@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Tests::SHA256 where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA256_FFI as SHA256_FFI\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\n\/**\n * ```repl\n * :check FFIAndCryptolAreEqual`{l=1000}\n * ```\n *\/\nFFIAndCryptolAreEqual : {l} (SHA256::ValidMessageLength (8 * l))\n    => [l][8] -> Bool\nproperty FFIAndCryptolAreEqual M = ffi == cryptol where\n    ffi = SHA256_FFI::hashBytes M\n    cryptol = SHA256::hashBytes M\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA512_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the SHA-512\/256 hash function implementation in the given module. The properties should check that the hash output matches the expected digest size of 256 bits and conforms to the SHA-512\/t IV generation as per FIPS-180-4 Section 5.3.6.2. Include tests for known input-output pairs to validate compliance with the standard."},{"role":"assistant","content":"```cryptol\n\/**\n * Instantiation of the secure hash algorithm SHA-512\/256 as specified in\n * [FIPS-180-4], Section 6.7.\n *\n * @copyright Galois, Inc\n * @author John Christensen <jchristensen@galois.com>\n *\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\n\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA512_256 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 256\n\n    \/\/ Per [FIPS-180-4], are the results of executing the SHA-512\/t IV\n    \/\/ Generation function with `t=256`.\n    \/\/ Ref: Section 5.3.6.2\n    H0 = [\n        0x22312194FC2BF72C\n      , 0x9F555FA3C84C64C2\n      , 0x2393B86B6F53B151\n      , 0x963877195940EABD\n      , 0x96283EE2A88EFFE3\n      , 0xBE5E1E2553863992\n      , 0x2B0199FC2C85B8AA\n      , 0x0EB72DDC81C52CA2\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the SHA-384 hash function as instantiated in the given module, including its initial hash values, word size, and digest size, and specify properties that verify compliance with the FIPS-180-4 standard, such as correct initialization, message padding, and output digest length."},{"role":"assistant","content":"```cryptol\n\/**\n * Instantiation of the secure hash algorithm SHA-384 as specified in\n * [FIPS-180-4], Section 5.3.4.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 384\n\n    \/\/ Per [FIPS-180-4], these are the the first sixty-four bits of the\n    \/\/ fractional parts of the square roots of the 9th - 16th prime numbers.\n    H0 = [\n        0xcbbb9d5dc1059ed8, 0x629a292a367cd507,\n        0x9159015a3070dd17, 0x152fecd8f70e5939,\n        0x67332667ffc00b31, 0x8eb44a8768581511,\n        0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the SHA-224 hash function as instantiated in the given module, including the initial hash values (H0), word size, and digest size. Then, write Cryptol properties to verify that the implementation conforms to the FIPS-180-4 standard, such as checking the correct initialization vector, correct digest size, and that the hash function produces expected outputs for known test vectors."},{"role":"assistant","content":"```cryptol\n\/**\n * Instantiation of the secure hash algorithm SHA-224 as specified in\n * [FIPS-180-4], Section 5.3.3.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA224 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 32\n\n    type DigestSize = 224\n\n    \/\/ Per [FIPS-180-4], these are the first 32 bits of the fractional\n    \/\/ parts of the square roots of the first 8 prime numbers.\n    H0 = [\n        0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n        0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the SHA-256 hash function as instantiated in the given module, including its initial hash values, block processing, and final digest output, suitable for property-based verification or equivalence checking."},{"role":"assistant","content":"```cryptol\n\/**\n * Instantiation of the secure hash algorithm SHA-256 as specified in\n * [FIPS-180-4], Section 5.3.3.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 32\n\n    type DigestSize = 256\n\n    \/\/ Per [FIPS-180-4], these are the first 32 bits of the fractional\n    \/\/ parts of the square roots of the first 8 prime numbers.\n    H0 = [\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA512_224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the SHA-512\/224 hash function implementation in the given module. The properties should check that the initial hash values (H0) conform to the FIPS-180-4 standard, and that the hash function produces outputs of the correct digest size (224 bits). Additionally, include properties to verify that the hash function behaves consistently with the SHA-512\/t IV generation process as described in Section 5.3.6.1 of the standard."},{"role":"assistant","content":"```cryptol\n\/**\n * Instantiation of the secure hash algorithm SHA-512\/224 as specified in\n * [FIPS-180-4], Section 6.6.\n *\n * @copyright Galois, Inc\n * @author John Christensen <jchristensen@galois.com>\n *\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\n\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA512_224 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 224\n\n    \/\/ Per [FIPS-180-4], are the results of executing the SHA-512\/t IV\n    \/\/ Generation function with `t=224`.\n    \/\/ Ref: Section 5.3.6.1.\n    H0 = [\n       0x8C3D37C819544DA2\n     , 0x73E1996689DCD4D6\n     , 0x1DFAB7AE32FF9C82\n     , 0x679DD514582F9FCF\n     , 0x0F6D2B697BD44DA8\n     , 0x77E36F7304C48942\n     , 0x3F9D85A86A1D36C8\n     , 0x1112E6AD91D692A1\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the SHA-512 hash function as instantiated in the given module, including its initial hash values (H0), word size, and digest size, and then write Cryptol properties to verify that the implementation conforms to the FIPS-180-4 standard for SHA-512."},{"role":"assistant","content":"```cryptol\n\/**\n * Instantiation of the secure hash algorithm SHA-512 as specified in\n * [FIPS-180-4], Section 5.3.5.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA512 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 512\n\n    \/\/ Per [FIPS-180-4], these are the the first sixty-four bits of the\n    \/\/ fractional parts of the square roots of the first 8 prime numbers.\n    H0 = [\n        0x6a09e667f3bcc908, 0xbb67ae8584caa73b,\n        0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n        0x510e527fade682d1, 0x9b05688c2b3e6c1f,\n        0x1f83d9abfb41bd6b, 0x5be0cd19137e2179\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA256_FFI.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the SHA256_FFI module's `hashBytes` function, ensuring it correctly implements the SHA-256 hash as specified in FIPS-180-4. Then, write a verification script using SAWScript or Cryptol's built-in verification tools to prove that the FFI implementation matches the Cryptol SHA256 specification for all valid input lengths."},{"role":"assistant","content":"```cryptol\n\/**\n * FFI instantiation of the secure hash algorithm SHA-256 as specified in\n * [FIPS-180-4], Section 5.3.3.\n *\n * The FFI implementation is taken from\n * https: * domain free of any restrictions.\n *\n * To use, you must compile the associated `SHA256_FFI.c` file according to your\n * operating system:\n *\n * \u2022 Linux: cc -fPIC -shared SHA256_FFI.c -o SHA256_FFI.so\n * \u2022 macOS: cc -dynamiclib SHA256_FFI.c -o SHA256_FFI.dylib\n * \u2022 Windows: cc -fPIC -shared SHA256_FFI.c -o SHA256_FFI.dll\n *\n * In addition, you need to be using Cryptol with FFI enabled.\n *\n * @copyright Galois, Inc.\n * @author Alex J Malozemoff <amaloz@galois.com>\n *\n * [FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n *     Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n *     Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n *     August 2015.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n *\/\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA256_FFI where\n    import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\n    \/**\n     * Re-export of `SHA256::MessageUpperBound`.\n     *\/\n    type MessageUpperBound = SHA256::MessageUpperBound\n\n    \/\/ Cryptol FFI does not support bit respresentation types, and hence\n    \/\/ the below `hash` function is not supported in FFI.\n    \/\/\n    \/\/ foreign hash : {l} (SHA256::ValidMessageLength l)\n    \/\/     => [l] -> [SHA256::DigestLength]\n\n    \/**\n     * Secure hash function, computed over bytes.\n     *\n     * This is not explicitly part of the spec, but many applications represent\n     * their input and output over byte strings (rather than bit strings as used\n     * in the spec itself).\n     *\/\n    foreign hashBytes : {l} (SHA256::ValidMessageLength (8 * l))\n        => [l][8] -> [SHA256::DigestLength \/ 8][8]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the SHA3_512 hash function implementation against the provided NIST CAVP test vectors. Include properties that prove the hash output matches expected values for both bitwise and bytewise inputs, using the given test cases t1, t72, and t100 as examples."},{"role":"assistant","content":"```cryptol\n\/**\n * Tests of the SHA3_512 hash function.\n *\n * Test vectors drawn from the NIST Cryptographic Algorithm Validation Program.\n * This program includes test vectors that can be used to spot-check an\n * implementation. It includes tests for bitwise inputs (where the input length\n * is any nonnegative integer) and for bytewise inputs (where the input length\n * is a multiple of 8).\n * @see CAVP. https:\/\/csrc.nist.gov\/projects\/cryptographic-algorithm-validation-program\/secure-hashing#sha3vsha3vss\n * @see SHA3 bitwise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bittestvectors.zip\n * @see SHA3 bytewise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bytetestvectors.zip\n *\n * Some of the bitwise tests in this file use the `KOP::truncate` function. The\n * CAVP vectors use the format described in [FIPS-202] Appendix B, where inputs\n * to SHA3 are provided as hex strings with an even number of digits and a\n * length parameter. The `h2b` function for processing such inputs has an\n * implicit truncation step. We've written the SHA3 spec to take arbitrary bit\n * vectors, but this assumes that the length of the input is its actual length.\n * The `truncate` function is written to support the even-hex-digit format and\n * must be called on an input before passing it to SHA3.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n * @editor Iavor Diatchki <diatchki@galois.com>\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_512 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512 as SHA3_512\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t1\n * ```\n *\/\nproperty t1 = SHA3_512::hash [] == output where\n    output = join [\n        0xa69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a6,\n        0x15b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26\n    ]\n\n\/**\n * This is from the bytewise tests.\n * ```repl\n * :prove t72\n * ```\n *\/\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_512::hash input == output\n    hashBytesWorks = SHA3_512::hashBytes (split input) == split output\n    input = 0x3d6093966950abd846\n    output = join [\n        0x53e30da8b74ae76abf1f65761653ebfbe87882e9ea0ea564addd7cfd5a652457,\n        0x8ad6be014d7799799ef5e15c679582b791159add823b95c91e26de62dcb74cfa\n    ]\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t100\n * ```\n *\/\nproperty t100 = SHA3_512::hash input == output where\n    input = KBO::truncate`{100} 0xd404d8e31f8091709122025a0c\n    output = join [\n        0xa5ce9e2523788040eab94f0a2467efc2a1e6d4ea74e9248f97f94ce1407f0c88,\n        0x2e6b0578d98a7067d98c79b2b1dd2cb76393e6356061146637e5240d34ed6955\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHAKE128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the SHAKE128 implementation correctly computes the CAVP test vectors provided in the SHAKE128.cry file. Ensure each property uses the computeCavpTestVector function with the given inputs and expected outputs, and prove these properties to confirm the implementation's correctness."},{"role":"assistant","content":"```cryptol\n\/**\n * CAVP test vectors for SHAKE128, and a demonstration on how to use\n * the `KeccakBitOrdering` module.\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHAKE128 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE128\n\n\/**\n * The CAVP test vectors provide input in MSB order as hex strings with an\n * even number of digits; each test is for a specific bit-length input.\n * This aligns with the encoding scheme described in [FIPS-202] Appendix B.\n *\n * The SHAKE-128 API does not require inputs to be encoded in that\n * format. In order to use the `xof` function, we need to truncate the \"padding\"\n * bits that are used to extend the input into an even number of hex digits\n * (e.g. a multiple of 8 bits).\n *\n * @see https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/shakebittestvectors.zip\n *\/\ncomputeCavpTestVector : {k, l} (fin k, fin l) => [8 * (k \/^ 8)] -> [l] -> Bool\ncomputeCavpTestVector msg expectedResult = result == expectedResult where\n    result = xof (KBO::truncate`{k, 8 * (k \/^ 8)} msg)\n\n\/**\n * ```repl\n * :prove k0\n * ```\n *\/\nproperty k0 = computeCavpTestVector`{0} [] expected_result where\n    expected_result = join [\n        0x7f9c2ba4e88f827d616045507605853e,\n        0xd73b8093f6efbc88eb1a6eacfa66ef26,\n        0x3cb1eea988004b93103cfb0aeefd2a68,\n        0x6e01fa4a58e8a3639ca8a1e3f9ae57e2\n    ]\n\n\/**\n * ```repl\n * :prove k1\n * ```\n *\/\nproperty k1 = computeCavpTestVector`{1} 0x00 expected_result where\n    expected_result = join [\n        0xe78b86559a9ccdc72288bf7bcf8e11d5,\n        0x74543a2922978913a02be149e89d03ca,\n        0xe63d2c36e2cf6906791b187d7e371d4f,\n        0x21ebe59dcfc249a510b82255a18250dd\n    ]\n\/**\n * ```repl\n * :prove k2\n * ```\n *\/\nproperty k2 = computeCavpTestVector`{2} 0x03 expected_result where\n    expected_result = join [\n        0xf6b6c4093f0a2ceba61b9f2c2fea2ca2,\n        0x38ce9005edcd588c380405070532ddd0,\n        0x0cbd3a3a7448017d874c52c9e383fa3d,\n        0xb1c184e023181fcc8550f53ac92feca5\n    ]\n\n\/**\n * ```repl\n * :prove k3\n * ```\n *\/\nproperty k3 = computeCavpTestVector`{3} 0x06 expected_result where\n    expected_result = join [\n        0x178afb3be00c33b682f0c920520699e3,\n        0xb7e4c360274fd8b41cdeaa8d3c675bdc,\n        0x079be55d4513e7479aa903169430f0a0,\n        0xbf60169becd0ff9ff3ff6be24bc6fd83\n    ]\n\n\/**\n * This is one of the CAVP test vectors from `SHAKE128ShortMsg.rsp`.\n * ```repl\n * :prove k265\n * ```\n *\/\nproperty k265 = computeCavpTestVector`{265} msg expected_output where\n    msg = 0xa4fb52a45c1e49e1805ccbe419ef3c57b773d84eaa478ed07536129480572e080d01\n    expected_output = 0xf5e3f9934cfa817d75e8db5dce000977\n\n\/**\n * This is one of the CAVP test vectors from `SHAKE128ShortMsg.rsp`.\n * ```repl\n * :prove k266\n * ```\n *\/\nproperty k266 = computeCavpTestVector`{266} msg expectedResult where\n    msg = 0x01de90ca986e1abd50d28ad9f82cc77b45ebd99d19fa4bab0437d3930c27351ca900\n    expectedResult = 0xc47bb657d4f474cd5fa0f29537b85a7a\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the SHA3_384 hash function implementation against the provided NIST CAVP test vectors. Include properties that prove the hash output for both bitwise and bytewise inputs matches the expected outputs as specified in the test file SHA3_384.cry."},{"role":"assistant","content":"```cryptol\n\/**\n * Tests of the SHA3_384 hash function.\n *\n * Test vectors drawn from the NIST Cryptographic Algorithm Validation Program.\n * This program includes test vectors that can be used to spot-check an\n * implementation. It includes tests for bitwise inputs (where the input length\n * is any nonnegative integer) and for bytewise inputs (where the input length\n * is a multiple of 8).\n * @see CAVP. https:\/\/csrc.nist.gov\/projects\/cryptographic-algorithm-validation-program\/secure-hashing#sha3vsha3vss\n * @see SHA3 bitwise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bittestvectors.zip\n * @see SHA3 bytewise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bytetestvectors.zip\n *\n * Some of the bitwise tests in this file use the `KOP::truncate` function. The\n * CAVP vectors use the format described in [FIPS-202] Appendix B, where inputs\n * to SHA3 are provided as hex strings with an even number of digits and a\n * length parameter. The `h2b` function for processing such inputs has an\n * implicit truncation step. We've written the SHA3 spec to take arbitrary bit\n * vectors, but this assumes that the length of the input is its actual length.\n * The `truncate` function is written to support the even-hex-digit format and\n * must be called on an input before passing it to SHA3.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n * @editor Iavor Diatchki <diatchki@galois.com>\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_384 where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384 as SHA3_384\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t1\n * ```\n *\/\nproperty t1 = SHA3_384::hash [] == output where\n    output = join [\n        0x0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61,\n        0x995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004\n    ]\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t64\n * ```\n *\/\nproperty t64 = SHA3_384::hash 0x72189b5f18121fb7 == output where\n    output = join [\n        0xb5be454e64fb00d8ebf23cece42fdcf20e88bb5067ab17c2,\n        0x19068b1533eb485341a84a933f837d9abd65b62604936469\n    ]\n\n\/**\n * This is from the bytewise tests.\n * ```repl\n * :prove t72\n * ```\n *\/\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_384::hash input == output\n    hashBytesWorks = SHA3_384::hashBytes (split input) == split output\n    input = 0xa36e5a59043b6333d7\n    output = join [\n        0xbd045661663436d07720ff3c8b6f922066dfe244456a56ca,\n        0x46dfb3f7e271116d932107c7b04cc7c60173e08d0c2e107c\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHAKE256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the SHAKE256 extendable-output function (XOF) implementation against the provided CAVP test vectors. Ensure each property corresponds to a test vector, proving that the output of the XOF for given inputs matches the expected hexadecimal results exactly."},{"role":"assistant","content":"```cryptol\n\/**\n * CAVP test vectors for SHAKE256.\n *\n * These can be downloaded from:\n * @see https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/shakebittestvectors.zip\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\n\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256\n\n\/**\n * ```repl\n * :prove k5\n * ```\n *\/\nproperty k5 = xof [] == expected_result where\n    expected_result = join [\n        0x46b9dd2b0ba88d13233b3feb743eeb24,\n        0x3fcd52ea62b81b82b50c27646ed5762f,\n        0xd75dc4ddd8c0f200cb05019d67b592f6,\n        0xfc821c49479ab48640292eacb3b7c4be\n    ]\n\n\/**\n * ```repl\n * :prove k6\n * ```\n *\/\nproperty k6 = xof 0b0 == expected_result where\n    expected_result = join [\n        0x1e20b13f3bdb730d286913335c092bce,\n        0xc0eb1aff2798c05736faa93bd665807a,\n        0x48ed7652aefd600427e9f797d647b9b3,\n        0x55d30410d71b8e275a676545600f1c35\n    ]\n\n\/**\n * ```repl\n * :prove k7\n * ```\n *\/\nproperty k7 = xof 0b11 == expected_result where\n    expected_result = join [\n        0x4f86b0eb85f7a9f6dc38b622706948ad,\n        0xb2beb6dd6911b5e9d865fd1f9667b5c0,\n        0x2a0dbb39c488b040a18ff3885f04ef95,\n        0x7c98f3948e6b7959a9b8950ffd6345d5\n    ]\n\n\/**\n * ```repl\n * :prove k8\n * ```\n *\/\nproperty k8 = xof 0b110 == expected_result where\n    expected_result = join [\n        0x27b5f40b3645215e370472ebb06817ae,\n        0xbddbe2cbd3a9a3ba3914da88e5853e70,\n        0x83630e6d51d7a009017d8176c3067329,\n        0xbec8e5f65591d65c5894c40132f1a2ab\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the SHA3_224 hash function implementation against the provided NIST CAVP test vectors. Include properties that check both bitwise and bytewise input handling, ensuring the hash outputs match the expected values exactly. Use the existing test vectors as references and prove these properties using Cryptol's :prove command."},{"role":"assistant","content":"```cryptol\n\/**\n * Tests of the SHA3_224 hash function.\n *\n * Test vectors drawn from the NIST Cryptographic Algorithm Validation Program.\n * This program includes test vectors that can be used to spot-check an\n * implementation. It includes tests for bitwise inputs (where the input length\n * is any nonnegative integer) and for bytewise inputs (where the input length\n * is a multiple of 8).\n * @see CAVP. https:\/\/csrc.nist.gov\/projects\/cryptographic-algorithm-validation-program\/secure-hashing#sha3vsha3vss\n * @see SHA3 bitwise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bittestvectors.zip\n * @see SHA3 bytewise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bytetestvectors.zip\n *\n * Some of the bitwise tests in this file use the `KOP::truncate` function. The\n * CAVP vectors use the format described in [FIPS-202] Appendix B, where inputs\n * to SHA3 are provided as hex strings with an even number of digits and a\n * length parameter. The `h2b` function for processing such inputs has an\n * implicit truncation step. We've written the SHA3 spec to take arbitrary bit\n * vectors, but this assumes that the length of the input is its actual length.\n * The `truncate` function is written to support the even-hex-digit format and\n * must be called on an input before passing it to SHA3.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n * @editor Iavor Diatchki <diatchki@galois.com>\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_224 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224 as SHA3_224\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t1\n * ```\n *\/\nproperty t1 = SHA3_224::hash [] ==\n    0x6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t5\n * ```\n *\/\nproperty t5 = SHA3_224::hash (KBO::truncate`{5} 0x1f) ==\n    0x65ad282dcf9642a2facc1e7545c58f3b17523e795fee58e4d21b10bf\n\n\/**\n * This is from the bytewise tests.\n * ```repl\n * :prove t72\n * ```\n *\/\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_224::hash input == output\n    hashBytesWorks = SHA3_224::hashBytes (split input) == split output\n    input = 0xb29373f6f8839bd498\n    output = 0xe02a13fa4770f824bcd69799284878f19bfdc833ac6d865f28b757d0\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t512\n * ```\n *\/\nproperty t512 = SHA3_224::hash input == output where\n    input = join [\n        0xfc286db63e69d24c6962bb515cc32c86,\n        0x67ed0c08ba9f331d1dd2c42de2e1bd0f,\n        0x18edcc870280650cc87011ce6b0709f7,\n        0xfe60033114144c69751717d315dc152f\n    ]\n    output = 0x157fd9f423a498868e233d9d64631f61aa5e8fbc23df413f7826c962\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the SHA3_256 hash function implementation against the provided NIST CAVP test vectors in the file SHA3_256.cry. Include properties that check the hash output for both bitwise and bytewise inputs, using the given test vectors and the KBO::truncate function where applicable. Ensure the properties can be used with the Cryptol prover to validate the implementation's compliance with the SHA3_256 specification."},{"role":"assistant","content":"```cryptol\n\/**\n * Tests of the SHA3_256 hash function.\n *\n * Test vectors drawn from the NIST Cryptographic Algorithm Validation Program.\n * This program includes test vectors that can be used to spot-check an\n * implementation. It includes tests for bitwise inputs (where the input length\n * is any nonnegative integer) and for bytewise inputs (where the input length\n * is a multiple of 8).\n * @see CAVP. https:\/\/csrc.nist.gov\/projects\/cryptographic-algorithm-validation-program\/secure-hashing#sha3vsha3vss\n * @see SHA3 bitwise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bittestvectors.zip\n * @see SHA3 bytewise test vectors. https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Algorithm-Validation-Program\/documents\/sha3\/sha-3bytetestvectors.zip\n *\n * Some of the bitwise tests in this file use the `KOP::truncate` function. The\n * CAVP vectors use the format described in [FIPS-202] Appendix B, where inputs\n * to SHA3 are provided as hex strings with an even number of digits and a\n * length parameter. The `h2b` function for processing such inputs has an\n * implicit truncation step. We've written the SHA3 spec to take arbitrary bit\n * vectors, but this assumes that the length of the input is its actual length.\n * The `truncate` function is written to support the even-hex-digit format and\n * must be called on an input before passing it to SHA3.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n * @editor Iavor Diatchki <diatchki@galois.com>\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_256 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256 as SHA3_256\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t1\n * ```\n *\/\nproperty t1 = SHA3_256::hash [] ==\n    0xa7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t7\n * ```\n *\/\nproperty t7 = SHA3_256::hash (KBO::truncate`{7} 0x0b) ==\n    0x9e5f8c800689fa5168fc5fbfeca8bd5b3668ffd6f08143e2e396b9ae0f9b443e\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t8\n * ```\n *\/\nproperty t8 = SHA3_256::hash 0x6a ==\n    0xf35e560e05de779f2669b9f513c2a7ab81dfeb100e2f4ee1fb17354bfa2740ca\n\n\/**\n * This is from the bytewise tests.\n * ```repl\n * :prove t72\n * ```\n *\/\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_256::hash input == output\n    hashBytesWorks = SHA3_256::hashBytes (split input) == split output\n    input = 0xfb8dfa3a132f9813ac\n    output = 0xfd09b3501888445ffc8c3bb95d106440ceee469415fce1474743273094306e2e\n\n\/**\n * This is from the bitwise tests.\n * ```repl\n * :prove t235\n * ```\n *\/\nproperty t235 = SHA3_256::hash input == output where\n    input = KBO::truncate`{235} (join [\n        0xd03d466ab65db8e5131a414637174b,\n        0x646d0612977d194dcb75b910d2a903\n    ])\n    output = join [\n        0x06413eb50e238e09843aa51b0b5fb7ca,\n        0x52b87db7d71f384b5b93f57843c89f37\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and properties of the SHA3-512 hash function as instantiated in the given module. Include properties such as output length correctness, collision resistance assumptions, and any relevant functional correctness criteria for the SHA3-512 digest type."},{"role":"assistant","content":"```cryptol\n\/**\n * Instantiation of SHA3-512.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 512\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and properties of the SHA3-384 hash function as instantiated in the given module. Include properties such as output length correctness, collision resistance assumptions, and consistency of the hash output for identical inputs."},{"role":"assistant","content":"```cryptol\n\/**\n * Instantiation of SHA3-384.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 384\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and properties of the SHA3-224 hash function as instantiated in the given module. Include properties such as output length correctness, determinism, and collision resistance assumptions suitable for formal verification."},{"role":"assistant","content":"```cryptol\n\/**\n * Instantiation of SHA3-224.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 224\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and properties of the SHA3-256 hash function as instantiated in this module. Include properties such as output length correctness, collision resistance assumptions, and consistency of the digest output for given inputs."},{"role":"assistant","content":"```cryptol\n\/**\n * Instantiation of SHA3-256.\n *\n * @copyright Galois Inc.\n * @author Ajay Kumar Eeralla\n *\/\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 256\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA1\/Tests\/CAVPShortByte.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the SHA1 hash function implementation produces the expected message digests for the given test vectors in the CAVPShortByte test suite. Each property should assert that hashing the specified message yields the corresponding known digest, suitable for use with :prove commands."},{"role":"assistant","content":"```cryptol\n\/**\n * Tests for SHA-1.\n * These test vectors are taken from the Cryptographic Algorithm Validation\n * Program (CAVP) sample files.\n * @see https:\/\/csrc.nist.gov\/Projects\/Cryptographic-Algorithm-Validation-Program\/Secure-Hashing#shavs\n *\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\/\n\nmodule Primitive::Keyless::Hash::SHA1::Tests::CAVPShortByte where\n\nimport Primitive::Keyless::Hash::SHA1::Specification as SHA1\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase0\n * ```\n *\/\nproperty testCase0 = SHA1::hash `{ l = 0 } msg == md\n  where\n    msg = take 0x00\n    md = 0xda39a3ee5e6b4b0d3255bfef95601890afd80709\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase1\n * ```\n *\/\nproperty testCase1 = SHA1::hash `{ l = 8 } msg == md\n  where\n    msg = take 0x36\n    md = 0xc1dfd96eea8cc2b62785275bca38ac261256e278\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase2\n * ```\n *\/\nproperty testCase2 = SHA1::hash `{ l = 16 } msg == md\n  where\n    msg = take 0x195a\n    md = 0x0a1c2d555bbe431ad6288af5a54f93e0449c9232\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase3\n * ```\n *\/\nproperty testCase3 = SHA1::hash `{ l = 24 } msg == md\n  where\n    msg = take 0xdf4bd2\n    md = 0xbf36ed5d74727dfd5d7854ec6b1d49468d8ee8aa\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase4\n * ```\n *\/\nproperty testCase4 = SHA1::hash `{ l = 32 } msg == md\n  where\n    msg = take 0x549e959e\n    md = 0xb78bae6d14338ffccfd5d5b5674a275f6ef9c717\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase5\n * ```\n *\/\nproperty testCase5 = SHA1::hash `{ l = 40 } msg == md\n  where\n    msg = take 0xf7fb1be205\n    md = 0x60b7d5bb560a1acf6fa45721bd0abb419a841a89\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase6\n * ```\n *\/\nproperty testCase6 = SHA1::hash `{ l = 48 } msg == md\n  where\n    msg = take 0xc0e5abeaea63\n    md = 0xa6d338459780c08363090fd8fc7d28dc80e8e01f\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase7\n * ```\n *\/\nproperty testCase7 = SHA1::hash `{ l = 56 } msg == md\n  where\n    msg = take 0x63bfc1ed7f78ab\n    md = 0x860328d80509500c1783169ebf0ba0c4b94da5e5\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase8\n * ```\n *\/\nproperty testCase8 = SHA1::hash `{ l = 64 } msg == md\n  where\n    msg = take 0x7e3d7b3eada98866\n    md = 0x24a2c34b976305277ce58c2f42d5092031572520\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase9\n * ```\n *\/\nproperty testCase9 = SHA1::hash `{ l = 72 } msg == md\n  where\n    msg = take 0x9e61e55d9ed37b1c20\n    md = 0x411ccee1f6e3677df12698411eb09d3ff580af97\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase10\n * ```\n *\/\nproperty testCase10 = SHA1::hash `{ l = 80 } msg == md\n  where\n    msg = take 0x9777cf90dd7c7e863506\n    md = 0x05c915b5ed4e4c4afffc202961f3174371e90b5c\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase11\n * ```\n *\/\nproperty testCase11 = SHA1::hash `{ l = 88 } msg == md\n  where\n    msg = take 0x4eb08c9e683c94bea00dfa\n    md = 0xaf320b42d7785ca6c8dd220463be23a2d2cb5afc\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase12\n * ```\n *\/\nproperty testCase12 = SHA1::hash `{ l = 96 } msg == md\n  where\n    msg = take 0x0938f2e2ebb64f8af8bbfc91\n    md = 0x9f4e66b6ceea40dcf4b9166c28f1c88474141da9\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase13\n * ```\n *\/\nproperty testCase13 = SHA1::hash `{ l = 104 } msg == md\n  where\n    msg = take 0x74c9996d14e87d3e6cbea7029d\n    md = 0xe6c4363c0852951991057f40de27ec0890466f01\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase14\n * ```\n *\/\nproperty testCase14 = SHA1::hash `{ l = 112 } msg == md\n  where\n    msg = take 0x51dca5c0f8e5d49596f32d3eb874\n    md = 0x046a7b396c01379a684a894558779b07d8c7da20\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase15\n * ```\n *\/\nproperty testCase15 = SHA1::hash `{ l = 120 } msg == md\n  where\n    msg = take 0x3a36ea49684820a2adc7fc4175ba78\n    md = 0xd58a262ee7b6577c07228e71ae9b3e04c8abcda9\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase16\n * ```\n *\/\nproperty testCase16 = SHA1::hash `{ l = 128 } msg == md\n  where\n    msg = take 0x3552694cdf663fd94b224747ac406aaf\n    md = 0xa150de927454202d94e656de4c7c0ca691de955d\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase17\n * ```\n *\/\nproperty testCase17 = SHA1::hash `{ l = 136 } msg == md\n  where\n    msg = take 0xf216a1cbde2446b1edf41e93481d33e2ed\n    md = 0x35a4b39fef560e7ea61246676e1b7e13d587be30\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase18\n * ```\n *\/\nproperty testCase18 = SHA1::hash `{ l = 144 } msg == md\n  where\n    msg = take 0xa3cf714bf112647e727e8cfd46499acd35a6\n    md = 0x7ce69b1acdce52ea7dbd382531fa1a83df13cae7\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase19\n * ```\n *\/\nproperty testCase19 = SHA1::hash `{ l = 152 } msg == md\n  where\n    msg = take 0x148de640f3c11591a6f8c5c48632c5fb79d3b7\n    md = 0xb47be2c64124fa9a124a887af9551a74354ca411\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase20\n * ```\n *\/\nproperty testCase20 = SHA1::hash `{ l = 160 } msg == md\n  where\n    msg = take 0x63a3cc83fd1ec1b6680e9974a0514e1a9ecebb6a\n    md = 0x8bb8c0d815a9c68a1d2910f39d942603d807fbcc\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase21\n * ```\n *\/\nproperty testCase21 = SHA1::hash `{ l = 168 } msg == md\n  where\n    msg = take 0x875a90909a8afc92fb7070047e9d081ec92f3d08b8\n    md = 0xb486f87fb833ebf0328393128646a6f6e660fcb1\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase22\n * ```\n *\/\nproperty testCase22 = SHA1::hash `{ l = 176 } msg == md\n  where\n    msg = take 0x444b25f9c9259dc217772cc4478c44b6feff62353673\n    md = 0x76159368f99dece30aadcfb9b7b41dab33688858\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase23\n * ```\n *\/\nproperty testCase23 = SHA1::hash `{ l = 184 } msg == md\n  where\n    msg = take 0x487351c8a5f440e4d03386483d5fe7bb669d41adcbfdb7\n    md = 0xdbc1cb575ce6aeb9dc4ebf0f843ba8aeb1451e89\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase24\n * ```\n *\/\nproperty testCase24 = SHA1::hash `{ l = 192 } msg == md\n  where\n    msg = take 0x46b061ef132b87f6d3b0ee2462f67d910977da20aed13705\n    md = 0xd7a98289679005eb930ab75efd8f650f991ee952\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase25\n * ```\n *\/\nproperty testCase25 = SHA1::hash `{ l = 200 } msg == md\n  where\n    msg = take 0x3842b6137bb9d27f3ca5bafe5bbb62858344fe4ba5c41589a5\n    md = 0xfda26fa9b4874ab701ed0bb64d134f89b9c4cc50\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase26\n * ```\n *\/\nproperty testCase26 = SHA1::hash `{ l = 208 } msg == md\n  where\n    msg = take 0x44d91d3d465a4111462ba0c7ec223da6735f4f5200453cf132c3\n    md = 0xc2ff7ccde143c8f0601f6974b1903eb8d5741b6e\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase27\n * ```\n *\/\nproperty testCase27 = SHA1::hash `{ l = 216 } msg == md\n  where\n    msg = take 0xcce73f2eabcb52f785d5a6df63c0a105f34a91ca237fe534ee399d\n    md = 0x643c9dc20a929608f6caa9709d843ca6fa7a76f4\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase28\n * ```\n *\/\nproperty testCase28 = SHA1::hash `{ l = 224 } msg == md\n  where\n    msg = take 0x664e6e7946839203037a65a12174b244de8cbc6ec3f578967a84f9ce\n    md = 0x509ef787343d5b5a269229b961b96241864a3d74\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase29\n * ```\n *\/\nproperty testCase29 = SHA1::hash `{ l = 232 } msg == md\n  where\n    msg = take 0x9597f714b2e45e3399a7f02aec44921bd78be0fefee0c5e9b499488f6e\n    md = 0xb61ce538f1a1e6c90432b233d7af5b6524ebfbe3\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase30\n * ```\n *\/\nproperty testCase30 = SHA1::hash `{ l = 240 } msg == md\n  where\n    msg = take 0x75c5ad1f3cbd22e8a95fc3b089526788fb4ebceed3e7d4443da6e081a35e\n    md = 0x5b7b94076b2fc20d6adb82479e6b28d07c902b75\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase31\n * ```\n *\/\nproperty testCase31 = SHA1::hash `{ l = 248 } msg == md\n  where\n    msg = take 0xdd245bffe6a638806667768360a95d0574e1a0bd0d18329fdb915ca484ac0d\n    md = 0x6066db99fc358952cf7fb0ec4d89cb0158ed91d7\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase32\n * ```\n *\/\nproperty testCase32 = SHA1::hash `{ l = 256 } msg == md\n  where\n    msg = take 0x0321794b739418c24e7c2e565274791c4be749752ad234ed56cb0a6347430c6b\n    md = 0xb89962c94d60f6a332fd60f6f07d4f032a586b76\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase33\n * ```\n *\/\nproperty testCase33 = SHA1::hash `{ l = 264 } msg == md\n  where\n    msg = take 0x4c3dcf95c2f0b5258c651fcd1d51bd10425d6203067d0748d37d1340d9ddda7db3\n    md = 0x17bda899c13d35413d2546212bcd8a93ceb0657b\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase34\n * ```\n *\/\nproperty testCase34 = SHA1::hash `{ l = 272 } msg == md\n  where\n    msg = take 0xb8d12582d25b45290a6e1bb95da429befcfdbf5b4dd41cdf3311d6988fa17cec0723\n    md = 0xbadcdd53fdc144b8bf2cc1e64d10f676eebe66ed\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase35\n * ```\n *\/\nproperty testCase35 = SHA1::hash `{ l = 280 } msg == md\n  where\n    msg = take 0x6fda97527a662552be15efaeba32a3aea4ed449abb5c1ed8d9bfff544708a425d69b72\n    md = 0x01b4646180f1f6d2e06bbe22c20e50030322673a\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase36\n * ```\n *\/\nproperty testCase36 = SHA1::hash `{ l = 288 } msg == md\n  where\n    msg = take 0x09fa2792acbb2417e8ed269041cc03c77006466e6e7ae002cf3f1af551e8ce0bb506d705\n    md = 0x10016dc3a2719f9034ffcc689426d28292c42fc9\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase37\n * ```\n *\/\nproperty testCase37 = SHA1::hash `{ l = 296 } msg == md\n  where\n    msg = take 0x5efa2987da0baf0a54d8d728792bcfa707a15798dc66743754406914d1cfe3709b1374eaeb\n    md = 0x9f42fa2bce6ef021d93c6b2d902273797e426535\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase38\n * ```\n *\/\nproperty testCase38 = SHA1::hash `{ l = 304 } msg == md\n  where\n    msg = take 0x2836de99c0f641cd55e89f5af76638947b8227377ef88bfba662e5682babc1ec96c6992bc9a0\n    md = 0xcdf48bacbff6f6152515323f9b43a286e0cb8113\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase39\n * ```\n *\/\nproperty testCase39 = SHA1::hash `{ l = 312 } msg == md\n  where\n    msg = take 0x42143a2b9e1d0b354df3264d08f7b602f54aad922a3d63006d097f683dc11b90178423bff2f7fe\n    md = 0xb88fb75274b9b0fd57c0045988cfcef6c3ce6554\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase40\n * ```\n *\/\nproperty testCase40 = SHA1::hash `{ l = 320 } msg == md\n  where\n    msg = take 0xeb60c28ad8aeda807d69ebc87552024ad8aca68204f1bcd29dc5a81dd228b591e2efb7c4df75ef03\n    md = 0xc06d3a6a12d9e8db62e8cff40ca23820d61d8aa7\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase41\n * ```\n *\/\nproperty testCase41 = SHA1::hash `{ l = 328 } msg == md\n  where\n    msg = take 0x7de4ba85ec54747cdc42b1f23546b7e490e31280f066e52fac117fd3b0792e4de62d5843ee98c72015\n    md = 0x6e40f9e83a4be93874bc97cdebb8da6889ae2c7a\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase42\n * ```\n *\/\nproperty testCase42 = SHA1::hash `{ l = 336 } msg == md\n  where\n    msg = take 0xe70653637bc5e388ccd8dc44e5eace36f7398f2bac993042b9bc2f4fb3b0ee7e23a96439dc01134b8c7d\n    md = 0x3efc940c312ef0dfd4e1143812248db89542f6a5\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase43\n * ```\n *\/\nproperty testCase43 = SHA1::hash `{ l = 344 } msg == md\n  where\n    msg = take 0xdd37bc9f0b3a4788f9b54966f252174c8ce487cbe59c53c22b81bf77621a7ce7616dcb5b1e2ee63c2c309b\n    md = 0xa0cf03f7badd0c3c3c4ea3717f5a4fb7e67b2e56\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase44\n * ```\n *\/\nproperty testCase44 = SHA1::hash `{ l = 352 } msg == md\n  where\n    msg = take 0x5f485c637ae30b1e30497f0fb7ec364e13c906e2813daa34161b7ac4a4fd7a1bddd79601bbd22cef1f57cbc7\n    md = 0xa544e06f1a07ceb175a51d6d9c0111b3e15e9859\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase45\n * ```\n *\/\nproperty testCase45 = SHA1::hash `{ l = 360 } msg == md\n  where\n    msg = take 0xf6c237fb3cfe95ec8414cc16d203b4874e644cc9a543465cad2dc563488a659e8a2e7c981e2a9f22e5e868ffe1\n    md = 0x199d986ed991b99a071f450c6b1121a727e8c735\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase46\n * ```\n *\/\nproperty testCase46 = SHA1::hash `{ l = 368 } msg == md\n  where\n    msg = take 0xda7ab3291553c659873c95913768953c6e526d3a26590898c0ade89ff56fbd110f1436af590b17fed49f8c4b2b1e\n    md = 0x33bac6104b0ad6128d091b5d5e2999099c9f05de\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase47\n * ```\n *\/\nproperty testCase47 = SHA1::hash `{ l = 376 } msg == md\n  where\n    msg = take 0x8cfa5fd56ee239ca47737591cba103e41a18acf8e8d257b0dbe8851134a81ff6b2e97104b39b76e19da256a17ce52d\n    md = 0x76d7db6e18c1f4ae225ce8ccc93c8f9a0dfeb969\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase48\n * ```\n *\/\nproperty testCase48 = SHA1::hash `{ l = 384 } msg == md\n  where\n    msg = take 0x57e89659d878f360af6de45a9a5e372ef40c384988e82640a3d5e4b76d2ef181780b9a099ac06ef0f8a7f3f764209720\n    md = 0xf652f3b1549f16710c7402895911e2b86a9b2aee\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase49\n * ```\n *\/\nproperty testCase49 = SHA1::hash `{ l = 392 } msg == md\n  where\n    msg = take 0xb91e64235dbd234eea2ae14a92a173ebe835347239cff8b02074416f55c6b60dc6ced06ae9f8d705505f0d617e4b29aef9\n    md = 0x63faebb807f32be708cf00fc35519991dc4e7f68\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase50\n * ```\n *\/\nproperty testCase50 = SHA1::hash `{ l = 400 } msg == md\n  where\n    msg = take 0xe42a67362a581e8cf3d847502215755d7ad425ca030c4360b0f7ef513e6980265f61c9fa18dd9ce668f38dbc2a1ef8f83cd6\n    md = 0x0e6730bc4a0e9322ea205f4edfff1fffda26af0a\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase51\n * ```\n *\/\nproperty testCase51 = SHA1::hash `{ l = 408 } msg == md\n  where\n    msg = take 0x634db92c22010e1cbf1e1623923180406c515272209a8acc42de05cc2e96a1e94c1f9f6b93234b7f4c55de8b1961a3bf352259\n    md = 0xb61a3a6f42e8e6604b93196c43c9e84d5359e6fe\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase52\n * ```\n *\/\nproperty testCase52 = SHA1::hash `{ l = 416 } msg == md\n  where\n    msg = take 0xcc6ca3a8cb391cd8a5aff1faa7b3ffbdd21a5a3ce66cfaddbfe8b179e4c860be5ec66bd2c6de6a39a25622f9f2fcb3fc05af12b5\n    md = 0x32d979ca1b3ed0ed8c890d99ec6dd85e6c16abf4\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase53\n * ```\n *\/\nproperty testCase53 = SHA1::hash `{ l = 424 } msg == md\n  where\n    msg = take 0x7c0e6a0d35f8ac854c7245ebc73693731bbbc3e6fab644466de27bb522fcb99307126ae718fe8f00742e6e5cb7a687c88447cbc961\n    md = 0x6f18190bd2d02fc93bce64756575cea36d08b1c3\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase54\n * ```\n *\/\nproperty testCase54 = SHA1::hash `{ l = 432 } msg == md\n  where\n    msg = take 0xc5581d40b331e24003901bd6bf244aca9e9601b9d81252bb38048642731f1146b8a4c69f88e148b2c8f8c14f15e1d6da57b2daa9991e\n    md = 0x68f525feea1d8dbe0117e417ca46708d18d7629a\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase55\n * ```\n *\/\nproperty testCase55 = SHA1::hash `{ l = 440 } msg == md\n  where\n    msg = take 0xec6b4a88713df27c0f2d02e738b69db43abda3921317259c864c1c386e9a5a3f533dc05f3beeb2bec2aac8e06db4c6cb3cddcf697e03d5\n    md = 0xa7272e2308622ff7a339460adc61efd0ea8dabdc\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase56\n * ```\n *\/\nproperty testCase56 = SHA1::hash `{ l = 448 } msg == md\n  where\n    msg = take 0x0321736beba578e90abc1a90aa56157d871618f6de0d764cc8c91e06c68ecd3b9de3824064503384db67beb7fe012232dacaef93a000fba7\n    md = 0xaef843b86916c16f66c84d83a6005d23fd005c9e\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase57\n * ```\n *\/\nproperty testCase57 = SHA1::hash `{ l = 456 } msg == md\n  where\n    msg = take 0xd0a249a97b5f1486721a50d4c4ab3f5d674a0e29925d5bf2678ef6d8d521e456bd84aa755328c83fc890837726a8e7877b570dba39579aabdd\n    md = 0xbe2cd6f380969be59cde2dff5e848a44e7880bd6\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase58\n * ```\n *\/\nproperty testCase58 = SHA1::hash `{ l = 464 } msg == md\n  where\n    msg = take 0xc32138531118f08c7dcc292428ad20b45ab27d9517a18445f38b8f0c2795bcdfe3ffe384e65ecbf74d2c9d0da88398575326074904c1709ba072\n    md = 0xe5eb4543deee8f6a5287845af8b593a95a9749a1\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase59\n * ```\n *\/\nproperty testCase59 = SHA1::hash `{ l = 472 } msg == md\n  where\n    msg = take 0xb0f4cfb939ea785eabb7e7ca7c476cdd9b227f015d905368ba00ae96b9aaf720297491b3921267576b72c8f58d577617e844f9f0759b399c6b064c\n    md = 0x534c850448dd486787b62bdec2d4a0b140a1b170\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase60\n * ```\n *\/\nproperty testCase60 = SHA1::hash `{ l = 480 } msg == md\n  where\n    msg = take 0xbd02e51b0cf2c2b8d204a026b41a66fbfc2ac37ee9411fc449c8d1194a0792a28ee731407dfc89b6dfc2b10faa27723a184afef8fd83def858a32d3f\n    md = 0x6fbfa6e4edce4cc85a845bf0d228dc39acefc2fa\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase61\n * ```\n *\/\nproperty testCase61 = SHA1::hash `{ l = 488 } msg == md\n  where\n    msg = take 0xe33146b83e4bb671392218da9a77f8d9f5974147182fb95ba662cb66011989c16d9af104735d6f79841aa4d1df276615b50108df8a29dbc9de31f4260d\n    md = 0x018872691d9b04e8220e09187df5bc5fa6257cd9\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase62\n * ```\n *\/\nproperty testCase62 = SHA1::hash `{ l = 496 } msg == md\n  where\n    msg = take 0x411c13c75073c1e2d4b1ecf13139ba9656cd35c14201f1c7c6f0eeb58d2dbfe35bfdeccc92c3961cfabb590bc1eb77eac15732fb0275798680e0c7292e50\n    md = 0xd98d512a35572f8bd20de62e9510cc21145c5bf4\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase63\n * ```\n *\/\nproperty testCase63 = SHA1::hash `{ l = 504 } msg == md\n  where\n    msg = take 0xf2c76ef617fa2bfc8a4d6bcbb15fe88436fdc2165d3074629579079d4d5b86f5081ab177b4c3f530376c9c924cbd421a8daf8830d0940c4fb7589865830699\n    md = 0x9f3ea255f6af95c5454e55d7354cabb45352ea0b\n\n\/**\n * This property was automatically generated from a NIST KAT file.\n * ```repl\n * :prove testCase64\n * ```\n *\/\nproperty testCase64 = SHA1::hash `{ l = 512 } msg == md\n  where\n    msg = take 0x45927e32ddf801caf35e18e7b5078b7f5435278212ec6bb99df884f49b327c6486feae46ba187dc1cc9145121e1492e6b06e9007394dc33b7748f86ac3207cfe\n    md = 0xa70cfbfe7563dd0e665c7c6715a96a8d756950c0\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Scheme\/RSAES_OAEP.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property or verification script that formally proves the correctness of the RSAES_OAEP encryption and decryption functions defined in the RSAES_OAEP module. The specification should verify that decrypting an encrypted message with the same label returns the original message, capturing the RSAES_OAEP_Correct property. Include necessary assumptions and constraints on parameters such as key size, hash length, and message length to ensure the property holds."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Scheme::RSAES_OAEP where\n\nimport Primitive::Asymmetric::Cipher::RSA\n\nparameter\n  type k : #\n  type constraint (fin k, k >= 1)\n\n  type hLen : # \/\/ Number of octets returned by chosen hash function\n  type constraint (fin hLen, hLen >= 1)\n\n  hash : {a} (2 * hLen >= width (8 * a) ) => [a][8] -> [8 * hLen]\n\n  type KeySize = k * 8\n  n : [KeySize]\n  e : [KeySize]\n  d : [KeySize]\n\n\n\nRSAES_OAEP_ENCRYPT : {l,mLen}\n                   (fin l, fin mLen\n                   , l>=0\n                   , 2 * hLen >= width (8 * l)                    , 2 * hLen >= width (8 * ( k - hLen + 3))                    , k >= mLen+2*hLen+2\n                   , 2^^32*hLen >= k - hLen - 1                    )\n                   => [256] \/\/ Seed for random number\n                   -> [mLen][8]\n                   -> [l][8]\n                   -> [k][8]\nRSAES_OAEP_ENCRYPT rand M L = I2OSP`{k} c \/\/ Return k-octet cipher text\n                   where\n                    EM = EME_OAEP_encode rand (M, L)   \/\/ Pad message M with optional label L to k octets\n                    m  = (zero # OS2IP EM) : [KeySize]  \/\/ Take k-octet padded message EM to int of width KeySize\n                    c  = RSAEP ((n, e), m)   \/\/ Encrypt integer m\n\n\n\n\nRSAES_OAEP_DECRYPT : {l}\n                   (fin l\n                   , l>=0\n                   , 2 * hLen >= width (8 * l)                    , 2 * hLen >= width (8 * (k - hLen + 3))                    , k >= 2 * hLen + 2\n                   , 2^^32*hLen >= k - hLen - 1 \/\/ Required for use of MGF1\n                   ) => [k][8] -> [l][8] -> ([k - hLen - 1][8], [width (k - hLen - 1)])\nRSAES_OAEP_DECRYPT C L = if c < 0 \\\/ c >= n then error \"decryption error\"\n                         else M\n                   where\n                    c  = OS2IP C\n                    m  = RSADP ((n,d),c)\n                    EM = I2OSP`{k} m\n                    M  = EME_OAEP_decode (EM, L)\n\n\nRSAES_OAEP_Correct : {l,mLen}\n                   (fin l, fin mLen\n                   , 2 * hLen >= width (8 * l)                    , 2 * hLen >= width (8 * (k - hLen + 3))                    , k >= mLen+2*hLen+2\n                   , 2^^32*hLen >= k - hLen - 1 \/\/ Required for use of MGF1\n                   )\n                   => [256] \/\/ Seed for random number\n                   -> [l][8]\n                   -> [mLen][8]\n                   -> Bit\nproperty RSAES_OAEP_Correct r l m = (RSAES_OAEP_DECRYPT (RSAES_OAEP_ENCRYPT r m l) l).0 == m#(zero:[_][8])\n\n\n\nEME_OAEP_encode : {l,mLen}\n         (fin l,fin mLen\n         , l >= 0\n         , 2 * hLen >= width (8 * l) \/\/ Required for using hash\n         , 2 * hLen >= width (8 * ( k - hLen + 3)) \/\/ Required for using hash in MGF\n         , k >= mLen + 2 * hLen + 2\n         , 2^^32*hLen >= k - hLen - 1 \/\/ Required use of MGF1\n         )\n         => [256] \/\/ Seed for random number\n         -> ([mLen][8], [l][8])\n         -> [k][8]\nEME_OAEP_encode rseed (M,L) = (zero : [1][8]) # maskedSeed # maskedDB \/\/ value of EM\n         where\n          lHash      = split (hash L) : [hLen][8]\n          PS         = (zero:[(k-mLen-2*hLen-2)][8]) \/\/ This may be (zero:[0][8])\n          DB         = lHash # PS # [(1:[8])] # M\n          seed       = random rseed : [hLen][8]\n          dbMask     = MGF1`{maskLen=(k-hLen-1)} seed\n          maskedDB   = DB ^ dbMask\n          seedMask   = MGF1`{maskLen=hLen} maskedDB\n          maskedSeed = seed ^ seedMask\n\n\n\n\nEME_OAEP_decode : {l}\n         (fin l\n         , l>=0\n         , 2*hLen >= width (8 * l) \/\/ Required for using hash\n         , 2*hLen >= width (8 * ( k - hLen + 3)) \/\/ Required for using hash in MGF\n         , k >= 2 * hLen + 2\n         , 2^^32*hLen >= k - hLen - 1 \/\/ Required for using MGF1\n         ) => ([k][8], [l][8]) -> ([k - hLen - 1][8], [width (k - hLen - 1)])\nEME_OAEP_decode (EM,L) = if Y != zero then error \"decryption error\"\n                         | lHash' != lHash then error \"decryption error\"\n                         else (Mpadded,mLen)\n                where\n                  Y          = head EM\n                  maskedSeed = take`{hLen} (drop`{1} EM)\n                  maskedDB   = drop`{hLen+1} EM\n                  seedMask   = MGF1`{maskLen=hLen} maskedDB\n                  seed       = seedMask ^ maskedSeed\n                  dbMask     = MGF1`{maskLen=k-hLen-1} seed\n                  DB         = maskedDB ^ dbMask \/\/ lHash' # (zero:[_][8]) # [(1:[8])] # M\n                  lHash'     = take`{hLen} DB \/\/ This should equal hash L\n                  lHash      = split (hash L) : [_][8]\n                  (Mpadded,mLen) = extractMsg DB \/\/ Original msg is take`{mLen} Mpadded\n\nprivate\n    extractMsg : {a} (fin a, a >= 1) =>  [a][8] -> ([a][8],[width a])\n    extractMsg DB = (Mpadded, mLen)\n                where\n                 init    = {removedPad = False,\n                            padMsg     = DB,\n                            idx        = (`a:[width a])}\n                 ys      = [init] # [ if (~y.removedPad \/\\ x==(1:[8]) )\n                                          then {removedPad = True,\n                                                padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                idx        = y.idx - 1}\n                                          | y.removedPad\n                                          then y\n                                          else {removedPad = False,\n                                                padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                idx        = y.idx - 1}\n                                    | x <- DB\n                                    | y <- ys ]\n                 Mpadded = (ys!0).padMsg\n                 mLen    = (ys!0).idx\n\n\n\n\nMGF1 : {maskLen,l,counterMax}\n       (fin hLen, fin l, fin maskLen\n       , hLen >= 1\n       , maskLen >= 1\n       , 2*hLen >= width (8 * (4 + l))\n       , 2^^32 * hLen >= maskLen\n       , counterMax == maskLen\/^hLen - 1 \/\/ (ceiling maskLen\/hLen) - 1\n       )\n       => [l][8] \/\/ MGF Seed\n       -> [maskLen][8]\nMGF1 mgfSeed = take`{maskLen} Ts\n     where\n\n      Cs = map (\\counter -> I2OSP`{xLen=4} counter) ([0..counterMax]:[_][32])\n      Ts = join [ split (hash (mgfSeed # c)) : [_][8] | c <- Cs]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Scheme\/RSAES_PKCS1_v1_5.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness and security properties of the RSAES_PKCS1_v1_5 encryption and decryption functions defined in the given module. Include properties that check the correctness of encryption followed by decryption (i.e., decryption of an encrypted message returns the original message), and properties that validate the proper formatting and decoding of the encoded message as per PKCS #1 v1.5 specification."},{"role":"assistant","content":"```cryptol\n\/*\n * This module implements an RSA encryption scheme\n * with the EME-PCKS1-v1_5 encoding method desribed in\n * section 7.2 of\n *\n * PKCS #1: RSA Cryptography Specifications Version 2.2\n *\n * See also:\n * https:\/\/tools.ietf.org\/html\/rfc8017\n *\n * @copyright Galois Inc. 2018\n * @author Nichole Schimanski <nls@galois.com>\n * www.cryptol.net\n *\/\n\nmodule Primitive::Asymmetric::Scheme::RSAES_PKCS1_v1_5 where\n\nimport Primitive::Asymmetric::Cipher::RSA\n\nparameter\n\n  type k : #\n  type constraint (fin k, k >= 11)\n\n\n  type KeySize = k * 8\n  n : [KeySize]\n  e : [KeySize]\n  d : [KeySize]\n\n\n\n\n\n\n\nRSAES_PKCS1_v1_5_Encrypt : {mLen} (mLen <= k - 11, mLen >= 1)\n                         => [k-mLen-3][8] -> [mLen][8] -> [k][8]\nRSAES_PKCS1_v1_5_Encrypt rand M = I2OSP`{k} c\n                         where\n                          PS = rand \/\/ Needs to be random _nonzero_ octets\n                          EM = ( zero : [1][8] ) # [( 1 : [8])] # PS # ( zero : [1][8] ) # M\n                          m  = OS2IP EM\n                          c  = RSAEP ((n,e),m)\n\n\nRSAES_PKCS1_v1_5_Decrypt : [k][8] -> ([k][8],[width k])\nRSAES_PKCS1_v1_5_Decrypt C = if c >= n then error \"decryption error\" else (Mp,idx)                          where\n                          c        = OS2IP C\n                          m        = RSADP ((n,d),c)\n                          EM       = I2OSP`{k} m\n                          (Mp,idx) = EME_PKCS1_v1_5_decode EM\n\n\n\n\nRSAES_PKCS1_Correct : {mLen} (mLen <= k - 11, mLen >= 1) =>\n                    [k-mLen-3][8] -> [mLen][8] -> Bit\nproperty RSAES_PKCS1_Correct rand M = take`{mLen} ((D ( E rand M ) ).0) == M\n         where\n          D = RSAES_PKCS1_v1_5_Decrypt\n          E = RSAES_PKCS1_v1_5_Encrypt\n\n\n\n\nprivate\n\n        EME_PKCS1_v1_5_decode : [k][8] -> ([k][8],[width k])\n        EME_PKCS1_v1_5_decode EM = if (ys!0).removedPad == False then error \"decryption error\"\n                                    | firstOctet != zero then error \"decryption error\"\n                                    | secondOctet != (1:[8]) then error \"decryption error\"\n                                    | mLen + 11 > `k then error \"decryption error\"\n                                   else (Mpadded, mLen)\n                   where\n                    firstOctet  = EM@0\n                    secondOctet = EM@1\n                    init        = {removedPad = False,\n                                   padMsg     = (tail EM)#(zero:[1][8]),\n                                   idx        = (`k-1):[width k]}\n                    ys          = [init] # [ if (~y.removedPad \/\\ x==zero)\n                                             then {removedPad = True,\n                                                   padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                   idx        = y.idx - 1}\n                                             | y.removedPad\n                                             then y\n                                             else {removedPad = False,\n                                                   padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                   idx        = y.idx - 1}\n                                       | x <- tail EM\n                                       | y <- ys ]\n                    Mpadded     = (ys!0).padMsg\n                    mLen        = (ys!0).idx\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/RSA_PSS.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the RSA_PSS module's signature generation and verification functions. Include properties that check the consistency between RSA_sign and RSA_verify for valid signatures, and verify that PSS_mgf1_encode and PSS_mgf1_verify behave as inverses under correct inputs. Also, specify bounds and constraints on parameters such as emLen and hLen to ensure type safety and correctness."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::RSA_PSS where\n\nimport Common::utils\n\nparameter\n  type hLen : # \/\/ Number of octets returned by chosen hash function\n  type constraint (fin hLen, hLen >= 1)\n\n  \/**\n   * Some hash functions have an upper bound on the message length they support.\n   *\n   * Most uses of `hash` here are on a fixed input made of 8 bytes of padding\n   * an `hLen`-byte hashed message, and an `hLen`-byte salt. The type constraint\n   * enforces that all such calls are on valid-length inputs.\n   *\/\n  type MessageUpperBound : #\n  type constraint (width (8 * (hLen + hLen + 8)) <= MessageUpperBound)\n\n  hash : {n} (fin n, width (8 * n) <= MessageUpperBound) => [n][8] -> [8 * hLen]\n\nMGF1 : {seedLen, maskLen} (fin seedLen, fin maskLen, width (8 * seedLen + 32) <= MessageUpperBound) => [seedLen][8] -> [maskLen][8]\nMGF1 seed = take (join [ split (hash (seed # (split c))) | c <- [(0 : [32]) ...] ])\n\n\nPSS_mgf1_encode : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> [hLen][8] -> [emLen][8]\nPSS_mgf1_encode mHash salt = EM'\n  where\n    M' = (zero : [8][8]) # mHash # salt\n    H = split (hash M')\n    DB = (zero : [emLen - 2 * hLen - 2][8]) # [0x01] # salt\n    dbMask = MGF1 H\n    maskedDB = DB ^ dbMask\n    EM = maskedDB # H # [0xbc]\n    EM' = update EM 0 ((EM @ 0) && 0x7f)\n\nPSS_mgf1_verify : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> [emLen][8] -> Bit\nPSS_mgf1_verify mHash EM = 0xbc == byte_0xbc \/\\ 0 == (maskedDB @ 0) && 0x80 \/\\ (zero : [emLen - 2 * hLen - 2][8]) == padding \/\\ 0x01 == byte_0x01 \/\\ H == H'\n  where\n    (maskedDB # H # [byte_0xbc]) = EM\n    dbMask = MGF1 H\n    DB = maskedDB ^ dbMask\n    DB' = update DB 0 ((DB @ 0) && 0x7f)\n    padding # [byte_0x01] # salt = DB'\n    M' = (zero : [8][8]) # mHash # salt\n    H' = split (hash M')\n\n\nRSA_sign : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> [hLen][8] -> Integer -> Integer -> Integer\nRSA_sign mHash salt d n = (exp (integerFromBV (join (PSS_mgf1_encode`{emLen} mHash salt))) d) % n\n\nRSA_verify : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> Integer -> Integer -> Integer -> Bit\nRSA_verify mHash sig e n = sig < n \/\\ PSS_mgf1_verify`{emLen} mHash (split (integerToBV ((exp sig e) % n)))\n\n\nexp : Integer -> Integer -> Integer\nexp = (^^)\n\nphi : Integer -> Integer\nphi = undefined\n\nrad : Integer -> Integer\nrad = undefined\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/RSA_PSS_SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the RSA-PSS signature scheme instantiated with the SHA-384 hash function as shown in the module Primitive::Asymmetric::Signature::RSA_PSS_SHA384. The specification should include the type definitions, the hash function behavior, and the message length bounds, ensuring that the RSA-PSS scheme correctly integrates the SHA-384 hash according to the given module."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::RSA_PSS_SHA384 = Primitive::Asymmetric::Signature::RSA_PSS where\n\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 as SHA384\n\ntype hLen = 48\nhash m = join (SHA384::hashBytes m)\ntype MessageUpperBound = SHA384::MessageUpperBound\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Cipher\/RSA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the RSA encryption and decryption primitives defined in the module Primitive::Asymmetric::Cipher::RSA. Specifically, create properties that prove the correctness of RSAEP and RSADP functions, ensuring that decrypting an encrypted message yields the original message, and verify the correctness of the integer-based RSA key generation and encryption\/decryption functions. Include properties suitable for Cryptol's :prove or :check commands to validate these behaviors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Cipher::RSA where\n\nimport Common::mod_arith\n\n\/\/ Integer-to-Octet-String primitive\nI2OSP : {xLen,int} (fin int, fin xLen, int<=xLen*8, xLen>=1) =>\n      [int] -> [xLen][8]\nI2OSP x = split ((zero # x):[xLen*8]) : [xLen][8]\n\n\/\/ Octet-String-to-Integer primitive\nOS2IP : {xLen} (fin xLen) => [xLen][8] -> [xLen*8]\nOS2IP xs = join xs\n\nI2OSConversionCorrect : {xLen} (fin xLen, xLen>=1) => [xLen][8] -> Bit\nproperty I2OSConversionCorrect xs = I2OSP (OS2IP xs) == xs\n\n\n\/\/ RSA encryption primitive\nRSAEP : {K} (fin K, K >= 1) => (([K],[K]),[K]) -> [K]\nRSAEP ((n, e), m) = if (m < zero \\\/ m > (n-1)) then error \"message representative out of range\"\n                    else c\n      where c = mod_pow (n,m,e)\n\n\/\/ RSA decryption primitive\nRSADP : {K} (fin K, K >= 1) => (([K],[K]),[K]) -> [K]\nRSADP ((n, d), c) = if (c < 0 \\\/ c > (n-1)) then error \"ciphertext representative out of range\"\n                    else m\n      where m = mod_pow (n,c,d)\n\n\nRSACorrect : {K} (fin K, K >= 1) => [K] -> [K] -> [K] -> [K] -> Bit\nproperty RSACorrect e d n msg = ( msg >= zero \/\\ msg < n ) ==> RSADP ((n,d), RSAEP ((n,e), msg)) == msg\n\nrsaTest = {n = 0xbad47a84c1782e4dbdd913f2a261fc8b65838412c6e45a2068ed6d7f16e9cdf4462b39119563cafb74b9cbf25cfd544bdae23bff0ebe7f6441042b7e109b9a8afaa056821ef8efaab219d21d6763484785622d918d395a2a31f2ece8385a8131e5ff143314a82e21afd713bae817cc0ee3514d4839007ccb55d68409c97a18ab62fa6f9f89b3f94a2777c47d6136775a56a9a0127f682470bef831fbec4bcd7b5095a7823fd70745d37d1bf72b63c4b1b4a3d0581e74bf9ade93cc46148617553931a79d92e9e488ef47223ee6f6c061884b13c9065b591139de13c1ea2927491ed00fb793cd68f463f5f64baa53916b46c818ab99706557a1c2d50d232577d1 : [2048]\n           , d = 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010001 : [2048]\n           , e = 0x40d60f24b61d76783d3bb1dc00b55f96a2a686f59b3750fdb15c40251c370c65cada222673811bc6b305ed7c90ffcb3abdddc8336612ff13b42a75cb7c88fb936291b523d80acce5a0842c724ed85a1393faf3d470bda8083fa84dc5f31499844f0c7c1e93fb1f734a5a29fb31a35c8a0822455f1c850a49e8629714ec6a2657efe75ec1ca6e62f9a3756c9b20b4855bdc9a3ab58c43d8af85b837a7fd15aa1149c119cfe960c05a9d4cea69c9fb6a897145674882bf57241d77c054dc4c94e8349d376296137eb421686159cb878d15d171eda8692834afc871988f203fc822c5dcee7f6c48df663ea3dc755e7dc06aebd41d05f1ca2891e2679783244d068f : [2048]\n           , M = 0x70992c9d95a4908d2a94b3ab9fa1cd643f120e326f9d7808af50cac42c4b0b4eeb7f0d4df303a568fbfb82b0f58300d25357645721bb71861caf81b27a56082c80a146499fb4eab5bde4493f5d00f1a437bbc360dfcd8056fe6be10e608adb30b6c2f7652428b8d32d362945982a46585d2102ef7995a8ba6e8ad8fd16bd7ae8f53c3d7fcfba290b57ce7f8f09c828d6f2d3ce56f131bd9461e5667e5b73edac77f504dac4f202a9570eb4515b2bf516407db831518db8a2083ec701e8fd387c430bb1a72deca5b49d429cf9deb09cc4518dc5f57c089aa2d3420e567e732102c2c92b88a07c69d70917140ab3823c63f312d3f11fa87ba29da3c7224b4fb4bc : [2048]\n           , C = 0x7e65b998a05f626b028c75dc3fbf98963dce66d0f4c3ae4237cff304d84d8836cb6bad9ac86f9d1b8a28dd70404788b869d2429f1ec0663e51b753f7451c6b4645d99126e457c1dac49551d86a8a974a3131e9b371d5c214cc9ff240c299bd0e62dbc7a9a2dad9fa5404adb00632d36332d5be6106e9e6ec81cac45cd339cc87abbe7f89430800e16e032a66210b25e926eda243d9f09955496ddbc77ef74f17fee41c4435e78b46965b713d72ce8a31af641538add387fedfd88bb22a42eb3bda40f72ecad941dbffdd47b3e77737da741553a45b630d070bcc5205804bf80ee2d51612875dbc4796960052f1687e0074007e6a33ab8b2085c033f9892b6f74 : [2048] }\n\nproperty testsPass = rsaTest.M == RSADP ((rsaTest.n, rsaTest.d), rsaTest.C)\n\n\/\/Integer-based implementation\n\ngenRSAKeys : (Integer,Integer) -> (Integer,Integer,Integer) \/\/ (n,e,d)\ngenRSAKeys (p,q) = (p*q,e,d)\n           where nTotient = lcm (p-1) (q-1)\n                 e        = 65537 \/\/ 2^16+1, commonly used public key exponent\n                 d        = inv e nTotient\n\nprivate\n    gcd : Integer -> Integer -> Integer\n    gcd x y =  gcd' x y\n        where gcd' a b = if b == zero then a else gcd' b (a%b)\n\n\n    lcm : Integer -> Integer -> Integer\n    lcm x y =  if (x == zero \\\/ y == zero) then zero else (x \/ (gcd x y)) * y\n\n\n    inv : Integer -> Integer -> Integer \/\/ Note, k and m MUST be coprime\n    inv k m = (inv' m k).1 % m\n      where\n        inv' n x = if x==1 then (zero, 1) else (r', q' - r' * q)\n          where\n            (q,  r)  = (n\/x, n%x)\n            (q', r') = inv' x r\n\n\nrsaEncrypt : (Integer,Integer,Integer) -> Integer\nrsaEncrypt (msg,e,n) = (msg^^e)%n\n\nrsaDecrypt : (Integer,Integer,Integer) -> Integer\nrsaDecrypt (ct,d,n) = (ct^^d)%n\n\n\/\/ :prove IntegerRSACorrectKeyGen 49979693 67867967\n\/\/ :check IntegerRSACorrectKeyGen 49979693 67867967\nIntegerRSACorrectKeyGen : Integer -> Integer -> Integer -> Bit\nproperty IntegerRSACorrectKeyGen p q msg = ( msg >= zero \/\\ msg < n ) ==>\n         rsaDecrypt (rsaEncrypt (msg,e,n),d,n) == msg\n         where (n,e,d) = genRSAKeys (p,q)\n\n\/\/ :prove IntegerRSACorrect 7 103 143\n\/\/ :check IntegerRSACorrect 7 103 143\n\/\/ :check IntegerRSACorrect (toInteger e) (toInteger d) (toInteger n)\nIntegerRSACorrect : Integer -> Integer -> Integer -> Integer -> Bit\nproperty IntegerRSACorrect e d n msg = ( msg >= zero \/\\ msg < n ) ==>\n         rsaDecrypt (rsaEncrypt (msg,e,n),d,n) == msg\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/ML_DSA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the ML-DSA signature scheme as implemented in the ML_DSA.cry module. Specifically, create properties that ensure: (1) signatures generated by the Sign function using a valid key pair from KeyGen always verify successfully with Verify; (2) invalid signatures fail verification; and (3) key generation produces keys of the correct format and length. Include test cases or checks that can be run with Cryptol's :check command to validate these properties."},{"role":"assistant","content":"```cryptol\n\/**\n * ML-DSA (CRYSTALS-Dilithium) signature scheme.\n *\n * This provides an algorithm for digital signatures with non-repudiation,\n * designed to be secure against an adversary with a large-scale quantum\n * computer.\n *\n * This module implements the ML-DSA family of external functions in [FIPS-204]\n * Section 5.\n *\n * There are some requirements around the use of this algorithm that cannot be\n * enforced by Cryptol! See [FIPS-204] Section 3.6 for further details.\n * - The seed `\u03be` used in `KeyGen` must be fresh (i.e. not previously used) and\n *   must be  generated with an approved RBG with suitable security strength!\n * - The value `rnd` used in the hedged variant of `Sign` should be generated\n *   by an approved RBG, but could be generated with an alternative method\n *   to maintain some protection against side-channel attacks and fault attacks\n *   on deterministic signatures.\n * - Potentially sensitive intermediate values computed in key generation and\n *   signing must be destroyed as soon as it is no longer needed.\n *\n * Other requirements from Section 3.6 can be enforced using Cryptol (this\n * implementation enforces public-key and signature length checks, and does not\n * use floating-point arithmetic).\n *\n * References:\n * [FIPS-204]: National Institute of Standards and Technology. Module-Lattice-\n *     Based Digital Signature Standard. (Department of Commerce, Washington,\n *     D.C.), Federal Information Processing Standards Publication (FIPS) NIST\n *     FIPS 204. August 2024.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.204\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ML_DSA::ML_DSA where\n\nimport interface Primitive::Asymmetric::Signature::ML_DSA::Parameters as P\nimport Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification { interface P }\n\n\/**\n * Generate a public-private key pair.\n * [FIPS-204] Section 5.1, Algorithm 1.\n *\n * This diverges from the spec: since Cryptol does not support random number\n * generation, this function takes the randomness `\u03be` as a parameter. This value\n * must be generated in a cryptographic module using an approved random bit\n * generator (RBG).\n *\/\nKeyGen : Option ([32]Byte) -> Option (PublicKey, PrivateKey)\nKeyGen maybe_\u03be = case maybe_\u03be of\n    None -> None\n    Some \u03be -> Some (KeyGen_internal \u03be)\n\n\/**\n * Generate an ML-DSA signature.\n * [FIPS-204] Section 5.2, Algorithm 2.\n *\n * This diverges from the spec: since Cryptol does not support random number\n * generation, this function takes the randomness `rnd` as a parameter. This\n * value must be generated in a cryptographic module using an approved random\n * bit generator (RBG).\n *\n * Note: The type parameter `c` is equivalent to `|ctx|` in the spec.\n *\/\nSign : {m, c} (fin m, fin c) =>\n    PrivateKey -> [m] -> [c]Byte -> Option ([32]Byte) -> Option (Signature)\nSign sk M ctx maybe_rnd\n    \/\/ Steps 1 - 3.\n    | c > 255 => None\n    \/\/ Steps 5 - 8.\n    | c <= 255 => case maybe_rnd of\n        None -> None\n        Some rnd -> sigma where\n            \/\/ Step 10. We use `join` instead of `BytesToBits`, which produces\n            \/\/ the same byte string, but with the bits in each byte reversed.\n            \/\/ I think we have to do this to support the later call to `HBits`,\n            \/\/ which expects the bit-order and byte-order to be the same.\n            M' = join (IntegerToBytes`{1} 0 # IntegerToBytes`{1} `c # ctx) # M\n            \/\/ Step 11.\n            sigma = Some (Sign_internal sk M' rnd)\n\n\/**\n * Verify a signature for a message.\n * [FIPS-204] Section 5.3, Algorithm 3.\n *\/\nVerify : {m, c} (fin m, fin c) =>\n    PublicKey -> [m] -> Signature -> [c]Byte -> Option Bool\nVerify pk M sigma ctx\n    | c > 255 => None\n    | c <= 255 => Some (Verify_internal pk M' sigma) where\n        \/\/ Step 10. We use `join` instead of `BytesToBits`, which produces\n        \/\/ the same byte string, but with the bits in each byte reversed.\n        \/\/ I think we have to do this to support the later call to `HBits`,\n        \/\/ which expects the bit-order and byte-order to be the same.\n        M' = join (IntegerToBytes`{1} 0 # IntegerToBytes`{1} `c # ctx) # M\n\n\n\/\/ We expose the internal functions for testing purposes only.\nsubmodule TestAPI where\n    import Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification { interface P } as Spec\n\n    KeyGen_internal = Spec::KeyGen_internal\n    Sign_internal = Spec::Sign_internal\n    Verify_internal = Spec::Verify_internal\n\n\/**\n * Correctness property for MLDSA: A signature on a message generated under a\n * valid keypair must be valid.\n * This takes about 6 minutes.\n * ```repl\n * :set tests=3\n * :check MLDSAIsCorrect`{10}\n * ```\n * Note: This correctness property should also be covered by the KATs in the\n * `Tests\/` directory.\n *\/\nMLDSAIsCorrect : {m} (fin m) => [32]Byte -> [32]Byte -> [m] -> [255]Byte -> Bit\nproperty MLDSAIsCorrect \u03be rnd M ctx = sigVerifies where\n    maybe_keys = KeyGen (Some \u03be)\n    maybe_sigVerifies = case maybe_keys of\n        None -> None\n        Some keys -> case (Sign sk M ctx (Some rnd)) of\n                None -> None\n                Some sig -> Verify pk M sig ctx\n            where (pk, sk) = keys\n    sigVerifies = case maybe_sigVerifies of\n        None -> False\n        Some v -> v\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness and invertibility of the encoding and decoding functions for public keys, secret keys, and signatures in the ML-DSA specification. Include properties that check that encoding followed by decoding returns the original data, and that the mathematical operations such as NTT and its inverse are inverses of each other. Also, specify properties to verify that the norm bounds and range constraints on polynomials and vectors are maintained throughout the transformations."},{"role":"assistant","content":"```cryptol\n\/**\n * ML-DSA (CRYSTALS-Dilithium) signature scheme components.\n *\n * This provides an algorithm for digital signatures with non-repudiation,\n * designed to be secure against an adversary with a large-scale quantum\n * computer.\n *\n * This executable specification matches the final version of [FIPS-204].\n * This file _excludes_ the external functions in Section 5.\n *\n * References:\n * [FIPS-204]: National Institute of Standards and Technology. Module-Lattice-\n *     Based Digital Signature Standard. (Department of Commerce, Washington,\n *     D.C.), Federal Information Processing Standards Publication (FIPS) NIST\n *     FIPS 204. August 2024.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.204\n * [NTT-Guide]: Ardianto Satriawan, Rella Mareta, and Hanho Lee. A Complete\n *     Beginner Guide to the Number Theoretic Transform (NTT). Cryptology\n *     ePrint Archive. 2024.\n *     @see https:\/\/eprint.iacr.org\/2024\/585.pdf\n *\n * @copyright Galois Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ML_DSA::Specification where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE128 as SHAKE128\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256 as SHAKE256\n\n\/**\n * The set {0, 1, ..., 255} of integers represented by a byte, denoted \ud835\udd39 in\n * the spec.\n * [FIPS-204] Section 2.3, \"\ud835\udd39\".\n *\/\ntype Byte = [8]\n\n\/**\n * The `bitlen` function defined in the spec is equivalent to the Cryptol\n * built-in `width` function on types. We use `width` throughout this\n * executable spec so that we can operate over types.\n * [FIPS-204] Section 2.3, \"bitlen a\".\n * ```repl\n * :prove bitlenIsWidth\n * ```\n *\/\nproperty bitlenIsWidth = (`(width 32) == 6) && (`(width 31) == 5)\n\n\/**\n * Ring defined as the product of 256 elements in `Z q`, used for NTT.\n * [FIPS-204] Section 2.3 and Section 2.4.1.\n *\/\ntype Tq = [256](Z q)\n\n\/**\n * Ring of single-variable polynomials over the integers mod `X^256 + 1`.\n * [FIPS-204] Section 2.3 and Section 2.4.1.\n *\n * The `i`th element of this list represents the coefficient for the degree-`i`\n * term.\n *\/\ntype R = [256]Integer\n\n\/**\n * The ring of single-variable polynomials over the integers mod 2, modulo\n * `X^256 + 1`.\n * [FIPS-204] Section 2.3 and Section 2.4.1.\n *\n * We represent individual elements in `\u2124_2` as bits, so this is just a bit\n * array.\n *\/\ntype R2 = [256]\n\n\/**\n * The ring of single-variable polynomials over the integers mod `q`, modulo\n * `X^256 + 1`.\n * [FIPS-204] Section 2.3 and Section 2.4.1.\n *\/\ntype Rq = [256](Z q)\n\n\/**\n * Compute the centered-mod function (denoted `mod\u00b1` in the spec).\n * [FIPS-204] Section 2.3, \"mod\u00b1\".\n *\/\nmodPlusMinus : {\u03b1} (fin \u03b1) => Z q -> Integer\nmodPlusMinus m = m' where\n    m_int = (fromZ m) % `\u03b1\n    m' = if m_int > (`\u03b1 \/ 2) then m_int - `\u03b1\n        else m_int\n\n\/**\n * The `mod\u00b1` function satisfies the functionality described in the spec.\n * [FIPS-204] Section 2.3, \"mod\u00b1\".\n *\n * The lower bound computes `\u2212\u2308\ud835\udefc\/2\u2309` by simplifying the ceiling division\n * equation `\u2308a \/ b\u2309 = (a + b - 1) \/ b`.\n *\n * The parameters chosen here are all the values of `\u03b1` used in the spec.\n * ```repl\n * :prove modPlusMinusWorks`{2^^d}\n * :prove modPlusMinusWorks`{q}\n * :prove modPlusMinusWorks`{2 * \u03b32}\n * ```\n *\/\nmodPlusMinusWorks : {\u03b1} (fin \u03b1) => Z q -> Bit\nproperty modPlusMinusWorks m = inRange && congruent where\n    m' = modPlusMinus`{\u03b1} m\n    lower_bound = - ((`\u03b1 + 1) \/ 2)\n    inRange = (lower_bound < m') && (m' <= (`\u03b1 \/ 2))\n    congruent = ((fromZ m) % `\u03b1) == (m' % `\u03b1)\n\n\/**\n * Compute the infinity norm over a list of elements in `Rq`.\n * [FIPS-204] Section 2.3, \"\u2016\u22c5\u2016\u221e\".\n *\/\ninfNormRq : {m} (fin m) => [m]Rq -> Integer\ninfNormRq w = maxList [ maxList [ abs (modPlusMinus`{q} wij)\n    | wij <- wi]\n    | wi <- w]\n\n\/**\n * Compute the infinity norm over a list of elements in `R`.\n * [FIPS-204] Section 2.3, \"\u2016\u22c5\u2016\u221e\".\n *\/\ninfNormR : {m} (fin m) => [m]R -> Integer\ninfNormR w = maxList [ maxList [ abs wij | wij <- wi] | wi <- w]\n\n\/**\n * Typecasts elements in `R` to `Rq` by taking the unique congruence class\n * modulo `q` tht contains each coefficient.\n * [FIPS-204] Section 2.4.1.\n *\/\ncastToRq : {m} (fin m) => [m]R -> [m]Rq\ncastToRq v = [map fromInteger vi | vi <- v]\n\nprivate\n    \/**\n     * Compute the max of a list of non-negative elements, as in\n     * [FIPS-204] Section 2.3, \"\u2016\u22c5\u2016\u221e\".\n     *\/\n    maxList : {n, a} (fin n, Literal 0 a, Cmp a) => [n]a -> a\n    maxList list = foldl max 0 list\n\n\/**\n * Apply `NTT` and `NTTInv` entry-wise over a vector of polynomials.\n * [FIPS-204] Section 2.5.\n *\n * The spec overloads the names `NTT` and `NTTInv` for both the single\n * application to a polynomial in `Rq` and the vector application to every\n * entry in a vector. Since Cryptol does not support user-defined overloaded\n * names, we define the following functions.\n *\/\nNTT_Vec = map NTT\nNTTInv_Vec = map NTTInv\n\n\/**\n * Wrapper function around SHAKE256, specifying the length `l` in bytes.\n * [FIPS-204] Section 3.7.\n *\n * The spec also defines a 3-part API for interacting with `H` (`Init`,\n * `Absorb`, `Squeeze`); we simulate this by generating an infinite output\n * and lazily taking things from it for each call to `Squeeze`, as described\n * in the same section.\n *\/\nH : {l, m} (fin m) => [m][8] -> [l][8]\nH str = SHAKE256::xofBytes`{8 * l} str\n\n\/**\n * Wrapper function around SHAKE256 that takes bit strings as input.\n * [FIPS-204] Section 3.7.\n *\n *\n *\/\nHBits : {l, m} (fin m) => [m] -> [l][8]\nHBits str = split (SHAKE256::xof`{8 * l} (str))\n\n\/**\n * Wrapper function around SHAKE128, specifying the length `l` in bytes.\n * [FIPS-204] Section 3.7.\n *\n * The spec also defines a 3-part API for interacting with `G` (`Init`,\n * `Absorb`, `Squeeze`); we simulate this by generating an infinite output\n * and lazily taking things from it for each call to `Squeeze`, as described\n * in the same section.\n *\/\nG : {l, m} (fin m) => [m][8] -> [l][8]\nG str = SHAKE128::xofBytes`{8 * l} str\n\n\/\/ [FIPS-204] Section 4 is largely defined in this interface.\nimport interface Primitive::Asymmetric::Signature::ML_DSA::Parameters\n\n\/**\n * A 512th root of unity in `Z_q`.\n * [FIPS-204] Section 4, Table 1.\n *\/\n\u03b6 : Z q\n\u03b6 = 1753\n\n\/**\n * Number of dropped bits from `t` (this compresses the public key for\n * a performance optimization).\n * [FIPS-204] Section 4, Table 1.\n *\/\ntype d = 13\n\n\/**\n * Allowable error range for signature components. In signing, this is used to\n * determine if a candidate signature is valid.\n * [FIPS-204] Section 4, Table 1.\n *\/\n\u03b2 = `(\u03b7 * \u03c4) : Integer\n\n\/**\n * Public key for the ML-DSA scheme.\n * [FIPS-204] Section 5.1, Algorithm 1 (and throughout).\n *\/\ntype PublicKey = [32 + 32 * k * (width (q - 1) - d)]Byte\n\n\/**\n * Private key for the ML-DSA scheme.\n * [FIPS-204] Section 5.1, Algorithm 1 (and throughout).\n *\/\ntype PrivateKey = [32 + 32 + 64 + 32 * ((k + ell) * width (2 * \u03b7) + d * k)]Byte\n\n\/**\n * Signature generated by the ML-DSA scheme.\n * [FIPS-204] Section 5.2, Algorithm 2 (and throughout).\n *\/\ntype Signature = [\u03bb \/ 4 + ell * 32 * (1 + width (\u03b31 - 1)) + \u03c9 + k]Byte\n\n\/**\n * Generate a public-private key pair from a seed.\n * [FIPS-204] Section 6.1, Algorithm 6.\n *\n * Warning: This interface must not be made available to applications (other\n * than for testing purposes)! Implementations must manually verify that this\n * interface is not public.\n * The randomness `\u03be` passed to this function should be generated by a\n * cryptographic module.\n *\/\nKeyGen_internal : [32]Byte -> (PublicKey, PrivateKey)\nKeyGen_internal \u03be = (pk, sk) where\n    \/\/ Step 1.\n    (\u03c1 # \u03c1' # K) = H`{128} (\u03be # IntegerToBytes`{1} `k # IntegerToBytes`{1} `ell)\n\n    \/\/ Step 3.\n    A_hat = ExpandA \u03c1\n        (s1, s2) = ExpandS \u03c1'\n\n    \/\/ Explicitly typecast vectors in `R` to `Rq`.\n    s1' = castToRq s1\n    s2' = castToRq s2\n\n    \/\/ Step 5.\n    t = NTTInv_Vec (A_hat \u2218\u2218 NTT_Vec s1') + s2'\n    \/\/ Step 6.\n    (t1, t0) = Power2Round t\n\n    \/\/ Step 8.\n    pk = pkEncode \u03c1 t1\n    \/\/ Step 9.\n    tr = H`{64} pk\n    \/\/ Step 10.\n    sk = skEncode \u03c1 K tr s1 s2 t0\n\n\n\/**\n * Deterministic algorithm to generate a signature for a formatted message `M'`.\n * [FIPS-204] Section 6.2, Algorithm 7.\n *\n * Warning: This interface must not be made available to applications (other\n * than for testing purposes)! Implementations must manually verify that this\n * interface is not public.\n * The randomness `rnd` passed to this function should be generated by a\n * cryptographic module.\n *\/\nSign_internal : {m} (fin m) => PrivateKey -> [m] -> [32]Byte -> Signature\nSign_internal sk M' rnd = \u03c3 where\n    \/\/ Step 1.\n    (\u03c1, K, tr, s1, s2, t0) = skDecode sk\n\n    \/\/ Steps 2 - 5.\n    s1_hat = NTT_Vec (castToRq s1)\n    s2_hat = NTT_Vec (castToRq s2)\n    t0_hat = NTT_Vec (castToRq t0)\n    A_hat = ExpandA \u03c1\n\n    \/\/ Step 6. We use `join` instead of `BytesToBits`, which produces the same\n    \/\/ byte string, but with the bits in each byte reversed. I think we have to\n    \/\/ do this to support the call to `HBits`, which expects the bit-order and\n    \/\/ byte-order to be the same.\n    \u03bc = HBits`{64} (join tr # M')\n\n    \/\/ Step 7.\n    \u03c1''= H`{64} (K # rnd # \u03bc)\n\n    \/\/ Steps 10 - 32. The rejection sampling loop in the spec is implemented\n    \/\/ here using recursion.\n    rejection_sample: Integer -> ([\u03bb \/ 4]Byte, ([ell]Rq, [k]R2))\n    rejection_sample \u03ba = case maybe_zh of\n            Some zh -> (c_til, zh)\n            None -> rejection_sample (\u03ba + `ell)\n        where\n            y = castToRq (ExpandMask \u03c1'' \u03ba)\n            w = NTTInv_Vec (A_hat \u2218\u2218 (NTT_Vec y))\n            w1 = HighBits w\n            c_til = H`{\u03bb \/ 4} (\u03bc # w1Encode w1)\n            [c] = castToRq [(SampleInBall c_til)]\n            c_hat = NTT c\n            cs1 = NTTInv_Vec (c_hat \u2218 s1_hat)\n            cs2 = NTTInv_Vec (c_hat \u2218 s2_hat)\n            z = y + cs1\n            r0 = LowBits (w - cs2)\n            maybe_zh = if (infNormRq z >= `\u03b31 - \u03b2) || (infNormR r0 >= `\u03b32 - \u03b2)\n                then None\n                else maybe_zh' where\n                    ct0 = NTTInv_Vec (c_hat \u2218 t0_hat)\n                    h = MakeHint (-ct0) (w - cs2 + ct0)\n                    maybe_zh' =\n                        if (infNormRq ct0 >= `\u03b32) || (numberOf1sInh > `\u03c9)\n                        then None\n                        else Some (z, h)\n\n                    \/\/ Compute the number of 1s in the hint by converting each\n                    \/\/ bit to an integer and summing them.\n                    numberOf1sInh = sum [if b then 1 else 0 | b <- join h]\n\n        (c_tilFinal, (zFinal, hFinal)) = rejection_sample 0\n\n    \/\/ In Step 33, `modPlusMinus` is applied componentwise to the vector `z`.\n    modPlusMinus_Vec v = [map modPlusMinus`{q} vi | vi <- v]\n\n        \u03c3 = sigEncode c_tilFinal (modPlusMinus_Vec zFinal) hFinal\n\n\/**\n * Internal function to verify a signature for a formatted message.\n * [FIPS-204] Section 6.3, Algorithm 8.\n *\n * This interface should not be provided to applications (other than for\n * testing purposes).\n *\n * If an implementation accepts inputs for the public key or the signature of\n * any length other than those defined by `PublicKey` and `Signature`, this\n * function should reject them.\n *\/\nVerify_internal : {m} (fin m) => PublicKey -> [m] -> Signature -> Bool\nVerify_internal pk M' \u03c3 = isValid where\n        (rho, t1) = pkDecode pk\n    (c_til, z, h) = sigDecode \u03c3\n\n    \/\/ Step 5.\n    A_hat = ExpandA rho\n    \/\/ Step 6.\n    tr = H`{64} pk\n    \/\/ Step 7. We use `join` instead of `BytesToBits`, which produces the same\n    \/\/ byte string, but with the bits in each byte reversed. I think we have to\n    \/\/ do this to support the call to `HBits`, which expects the bit-order and\n    \/\/ byte-order to be the same.\n    mu = HBits`{64} (join tr # M')\n\n    \/\/ Step 8.\n    [c] = castToRq [(SampleInBall c_til)]\n\n    \/\/ These casts are implicit in Step 9 in the sepc.\n    t1' = castToRq t1\n    z' = castToRq z\n    \/\/ The spec uses the shorthand `t1 * 2^d`; in Cryptol, we need to create\n    \/\/ a matrix with the same dimensions as `t1` where every element is `2^d`.\n    two_d = repeat (repeat (2^^`d))\n\n    \/\/ Step 9.\n    wApprox' = NTTInv_Vec (A_hat \u2218\u2218 NTT_Vec z' - (NTT c \u2218 NTT_Vec (t1' * two_d)))\n\n    \/\/ Steps 3 - 4, 10 - 13.\n    isValid = case h of\n        None -> False\n        Some h' -> (infNormR z < `\u03b31 - \u03b2) && (c_til == c_til') where\n            w1' = UseHint h' wApprox'\n            c_til' = H`{\u03bb \/ 4} (mu # w1Encode w1')\n\n\/**\n * Compute a base-2 representation of the input mod `2^\u03b1` using little-endian\n * order.\n * [FIPS-204] Section 7.1, Algorithm 9.\n *\/\nIntegerToBits : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]\nIntegerToBits x = y' where\n    \/\/ Step 3. Compute the value of each `y_i`.\n    y = [x' % 2 | x' <- xs' | i <- [0..\u03b1 - 1]]\n\n    \/\/ Step 4. Compute value of `x'` at each iteration of the loop.\n    \/\/ In Cryptol, integer division takes the floor by default.\n    xs' = [x] # [x' \/ 2 | x' <- xs']\n\n    \/\/ Cryptol-specific conversion: convert each Integer-typed bit to an actual\n    \/\/ bit and join into a single vector.\n    y' = join [(fromInteger yi) : [1] | yi <- y]\n\n\/**\n * Compute the integer value expressed by a bit string using little-endian\n * order.\n * [FIPS-204] Section 7.1, Algorithm 10.\n *\/\nBitsToInteger : {\u03b1} (fin \u03b1, \u03b1 > 0) => [\u03b1] -> Integer\nBitsToInteger y = xs ! 0 where\n    \/\/ Cryptol-specific conversion: separate the input into \u03b1 1-bit vectors,\n    \/\/ then convert each to an integer.\n    y' = map toInteger (split`{\u03b1} y)\n\n    \/\/ Steps 1 - 4. Compute the value of `x` at each iteration of the loop.\n    xs = [0] # [2 * x + y' @ (`\u03b1 - i)\n        | x <- xs\n        | i <- [1..\u03b1]]\n\n\/**\n * The integer \/ bit conversion functions must invert each other.\n * This is not explicit in the spec, but we define the property anyway.\n * The parameter choices are approximately the same as some of the use cases\n * in the spec.\n * ```repl\n * :check BitsToIntegersInverts`{44}\n * :exhaust BitsToIntegersInverts`{10}\n * ```\n *\/\nBitsToIntegersInverts : {\u03b1} (fin \u03b1, \u03b1 > 0) => [\u03b1] -> Bit\nproperty BitsToIntegersInverts x = IntegerToBits (BitsToInteger x) == x\n\n\/**\n * Compute a base-256 representation of `x mod 256^\u03b1` using little-endian byte\n * order.\n * [FIPS-204] Section 7.1, Algorithm 11.\n *\/\nIntegerToBytes : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]Byte\nIntegerToBytes x = y where\n        y = [fromInteger (x' % 256) | x' <- xs' | i <- [0..\u03b1 - 1]]\n\n    \/\/ Step 4. Compute the value of `x'` at each iteration of the loop.\n    xs' = [x] # [x' \/ 256 | x' <- xs']\n\n\/**\n * Convert a bit string into a byte string using little-endian order.\n * [FIPS-204] Section 7.1, Algorithm 12.\n *\/\nBitsToBytes : {\u03b1} (fin \u03b1) => [\u03b1]Bit -> [\u03b1 \/^ 8]Byte\nBitsToBytes y\n    \/\/ A zero-length input will produce a zero-length output.\n    | \u03b1 == 0 => zero\n    | \u03b1 > 0 => z where\n        \/\/ Compute the values of `y[i]` and `i` at each iteration of the loop.\n        \/\/ To simplify the next step, this also:\n        \/\/ - Groups the `y[i]` bits into sets of 8 for each `z[\u230ai \/ 8\u230b]`, and\n        \/\/ - Pads each bit of `y[i]` into a byte to support subsequent operations.\n        y' = groupBy`{8} ([(zext [yi], i)\n            | yi <- y\n            | i <- [0..\u03b1 - 1]] # zero)\n\n        \/\/ Steps 2 - 4. We compute the `y` terms separately then `sum` them\n        \/\/ for each byte in `z`.\n        z = [sum [yi * (2 ^^ (i % 8))\n                | (yi, i) <- yi8]\n            | yi8 <- y']\n\n\/**\n * Convert a byte string into a bit string using little-endian order.\n * [FIPS-204] Section 7.1, Algorithm 13.\n *\/\nBytesToBits : {\u03b1} (fin \u03b1) => [\u03b1]Byte -> [8 * \u03b1]Bit\nBytesToBits z\n    | \u03b1 == 0 => []\n    | \u03b1 > 0 => join [[ y8ij where\n            \/\/ Step 4. Taking the last bit is the same as modding by 2. (See\n            \/\/ `mod2IsFinalBit`).\n            y8ij = zi' ! 0\n            \/\/ Step 5. Shifting right is the same as the iterative\n            \/\/ division (see `div2IsShiftR`). This accounts for all the\n            \/\/ divisions \"up to this point\" (e.g. none when `j = 0`), which\n            \/\/ is why we use `zi'` to evaluate `y8ij` above.\n            zi' = zi >> j\n        \/\/ Step 3.\n        | j <- [0..7]]\n        \/\/ Step 2. We iterate over `z` directly instead of indexing into it.\n        | zi <- z ]\n\nprivate\n    \/**\n     * The iterative division by 2 in `BytesToBits` is the same as shifting\n     * right.\n     * ```repl\n     * :prove div2IsShiftR\n     * ```\n     *\/\n    div2IsShiftR : Byte -> Bit\n    div2IsShiftR C = take (d2 C) == shl where\n        \/\/ Note: division here is floor'd by default.\n        d2 c = [c] # d2 (c \/ 2)\n        shl = [C >> j | j <- [0..7]]\n\n\/**\n * The conversions between bits and bytes are each others' inverses, for\n * lengths that are a multiple of 8.\n * This isn't explicit in the spec, but we include the property anyway.\n * This takes ~10 seconds.\n * ```repl\n * :prove B2B2BInverts`{320}\n * :prove B2B2BInverts`{32 * 44}\n * ```\n *\/\nB2B2BInverts : {\u03b1} (fin \u03b1) => [8 * \u03b1] -> Bit\nproperty B2B2BInverts y = BytesToBits (BitsToBytes y) == y\n\n\/**\n * Generate an element in the integers mod `q` or a failure indicator.\n * [FIPS-204] Section 7.1, Algorithm 14.\n *\/\nCoeffFromThreeBytes : Byte -> Byte -> Byte -> Option (Z q)\nCoeffFromThreeBytes b0 b1 b2 = maybe_z where\n        b2' = if b2 > 127 then b2 - 128 else b2\n\n    \/\/ We have to explicitly expand the byte strings to support the\n    \/\/ operations in the next step. 32 bits gives us plenty of space.\n    [bq0, bq1, bq2'] = map zext`{32} [b0, b1, b2']\n\n    \/\/ Step 5.\n    z = 2^^16 * bq2' + 2^^8 * bq1 + bq0\n\n    \/\/ Step 6 - 7. We have to convert `z` into `Z q` manually in the successful\n    \/\/ case -- note that we can't do it sooner because otherwise the condition\n    \/\/ is moot.\n    maybe_z = if z < `q then Some (toZ z) else None\n\n    toZ : [32] -> Z q\n    toZ b = fromInteger (toInteger b)\n\n\/**\n * Generate an element of {-\u03b7, -\u03b7 + 1, ..., \u03b7} or a failure indicator.\n * [FIPS-204] Section 7.1, Algorithm 15.\n *\/\nCoeffFromHalfByte : [4] -> Option Integer\nCoeffFromHalfByte b =\n    if (`\u03b7 == 2) && (b < 15) then Some (2 - (toInteger b % 5))\n    else\n        if (`\u03b7 == 4) && (b < 9) then Some (4 - toInteger b)\n        else None\n\n\/**\n * Encode a polynomial `w` into a byte string.\n * [FIPS-204] Section 7.1, Algorithm 16.\n *\n * This function assumes that all the coefficients of `w` are in the range\n * `[0, b]`.\n *\/\nSimpleBitPack : {b} (fin b, width b > 0) => R -> [32 * width b]Byte\nSimpleBitPack w = BitsToBytes z where\n    z = join [IntegerToBits`{width b} (w@i) | i <- [0..255]]\n\n\/**\n * Encode a polynomial `w` into a byte string.\n * [FIPS-204] Section 7.1, Algorithm 17.\n *\n * This function assumes that all the coefficients of `w` are in the range\n * `[-a, b]`.\n *\/\nBitPack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    R -> [32 * width (a + b)]Byte\nBitPack w = BitsToBytes z where\n    z = join [IntegerToBits`{width (a + b)} (`b - w@i) | i <- [0..255]]\n\n\/**\n * Reverses the procedure `SimpleBitPack`.\n * [FIPS-204] Section 7.1, Algorithm 18.\n *\n * For some choices of `b`, there are inputs that will cause this function to\n * output polynomials whose coefficients are not in the range `[0, b]`.\n *\/\nSimpleBitUnpack : {b} (fin b, width b > 0) => [32 * width b]Byte -> R\nSimpleBitUnpack v = w where\n    type c = width b\n    z = BytesToBits v\n    \/\/ Separate `z` into the sets `[z[ic], z[ic + 1], ... , z[ic + c - 1]]` for\n    \/\/ `i` in the range `[0..255]`.\n    z_ics = split z : [256][c]\n    w = [BitsToInteger`{c} (z_ics@i) | i <- [0..255]]\n\n\/**\n * `SimpleBitUnpack` reverses `SimpleBitPack`.\n * To ensure the precondition for `SimpleBitPack`, we take the input as an set\n * of integers mod `b` and convert to integers.\n * [FIPS-204] Section 7.1, comment on Algorithm 18.\n * ```repl\n * :check SimplePackingInverts`{10}\n * ```\n *\/\nSimplePackingInverts : {b} (fin b, width b > 0) => [256](Z b) -> Bit\nproperty SimplePackingInverts w_inRange = simplePackInverts where\n    w = map fromZ w_inRange\n    simplePackInverts = SimpleBitUnpack`{b} (SimpleBitPack`{b} w) == w\n\n\/**\n * Reverse the procedure `BitPack`.\n * [FIPS-204] Section 7.1, Algorithm 19.\n *\n * For some choices of `a` and `b`, there are malformed byte strings that will\n * cause this function to output polynomials whose coefficients are not in the\n * range `[-a, b]`.\n *\/\nBitUnpack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    [32 * width (a + b)]Byte -> R\nBitUnpack v = w where\n    type c = width (a + b)\n    z = BytesToBits v\n\n    \/\/ Split `z` into the sets `[z[ic], z[ic + 1], ... , z[ic + c - 1]]` for\n    \/\/ `i` in the range `[0..255]`.\n    z_ics = split z : [256][c]\n\n    w = [`b - BitsToInteger`{c} (z_ics@i)| i <- [0..255]]\n\n\/**\n * `BitUnpack` reverses `BitPack`.\n * To ensure the precondition for `BitPack`, we take the input as an set\n * of integers mod `a + b `, convert to integers, then shift them down to the\n * interval `[-a, b]`.\n * [FIPS-204] Section 7.1, comment on Algorithm 19.\n * ```repl\n * :check PackingInverts`{10, 10}\n * ```\n *\/\nPackingInverts : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    [256](Z (a + b)) -> Bit\nproperty PackingInverts w_inRange = packInverts where\n    \/\/ Shift from `[0, a + b]` to `[-a, b]`.\n    w = [(fromZ wi) - `a | wi <- w_inRange]\n    packInverts = BitUnpack`{a, b} (BitPack`{a, b} w) == w\n\n\/**\n * Encode a polynomial vector `h` with binary coefficients into a byte string.\n * [FIPS-204] Section 7.1, Algorithm 20.\n *\/\nHintBitPack : [k]R2 -> [\u03c9 + k]Byte\nHintBitPack h = yFinal where\n    \/\/ Step 1.\n    y0 = zero : [\u03c9 + k]Byte\n    \/\/ Step 2.\n    Index0 = 0\n    \/\/ Steps 3 - 11. This builds a list with all the intermediate values of\n    \/\/ `y` and `Index`...\n    yAndIndex = [(y0, Index0)] # [ (y'', Index') where\n            \/\/ Steps 5 - 8.\n            (y', Index') = if (h @i @j) != 0 then\n                    (update y Index j, Index + 1)\n                else (y, Index)\n\n            \/\/ Step 10.\n            y'' = if j == 255 then\n                    update y' (`\u03c9 + i) Index'\n                else y'\n        | (y, Index) <- yAndIndex\n        \/\/ Step 3 - 4.\n        | i <- [0..k-1], j <- [0..255]\n    ]\n    \/\/ Step 12. ...we return the last `y`.\n    (yFinal, _) = yAndIndex ! 0\n\n\/**\n * Reverses the procedure `HintBitPack`.\n * [FIPS-204] Section 7.1, Algorithm 21.\n *\n * This diverges slightly from the spec:\n * - To simplify updating `h`, we treat it as a single array of size `256k`.\n *   We separate it into the correct `[k]R2` representation in the final step.\n *   We access the array in \"the natural way\" -- that is, in Step 12, the\n *   element `h[i]_y[Index]` is at index `i * 256 + y[Index]` in our array.\n * - We cannot \"return early\" when we encounter an error case. Instead, we use\n *   options to indicate whether a failure has occurred and skip further\n *   computation when the option is `None`.\n * - The for loop in Step 3 is executed with a list comprehension. The while\n *   loop in Step 7 is executed with recursion. The for loop in Step 16 is\n *   executed with recursion.\n *\/\nHintBitUnpack : [\u03c9 + k]Byte -> Option ([k]R2)\nHintBitUnpack y = hFinal where\n    \/\/ Step 1.\n    h0 = zero : [k * 256]\n    \/\/ Step 2.\n    Index0 = 0\n\n    \/\/ Step 3. Construct a list comprising the values of `h` and `Index`\n    \/\/ at the end of each iteration of the loop in Steps 3 - 15.\n    hAndIndexes = [Some (h0, Index0)] # [\n            \/\/ Call Steps 4-5 if we haven't encountered an error yet.\n            case maybe_hAndIndex of\n                Some hAndIndex -> Step4_5 hAndIndex i\n                None -> None\n        | maybe_hAndIndex <- hAndIndexes\n        | i <- [0..k-1]\n    ]\n\n    \/\/ Steps 4 - 5.\n    Step4_5 (h, Index) i = if (y@(`\u03c9 + i) < Index) || (y@(`\u03c9 + i) > `\u03c9) then\n            None\n        else Step6_15 (h, Index) i\n\n    \/\/ Steps 6 - 15.\n    Step6_15 (h, Index) i = Step7_14 (h, Index) where\n        \/\/ Step 6.\n        First = Index\n\n        \/\/ Steps 7 - 14.\n        Step7_14 (h', Index') =\n            \/\/ Step 7 (condition).\n            if Index' < (y@(`\u03c9 + i)) then\n                \/\/ Step 8 - 11.\n                \/\/ The `\/\\` is a short-cutting `and`, equivalent to the nested\n                \/\/ `if` statements in the spec.\n                if ((Index' > First) \/\\ (y@(Index' - 1) >= y@Index')) then None\n                \/\/ Step 7 (recursive call -- equivalent to continuing the loop).\n                else Step7_14\n                    \/\/ Step 12.\n                    (update h' (i*256 + (toInteger (y@Index'))) 1,\n                    \/\/ Step 13.\n                    Index' + 1)\n            \/\/ If the loop condition is no longer true, return the current\n            \/\/ values of `h` and `Index`.\n            else Some (h', Index')\n\n    \/\/ Get the values of `h` and `Index` after the loop in Steps 3 - 15.\n    maybe_hAndIndex' = hAndIndexes ! 0\n\n    \/\/ Step 16 - 20.\n    hFinal = case maybe_hAndIndex' of\n        Some hAndIndex -> if checkLeftoverBytes then\n                \/\/ This `split` converts back to the spec-adherent\n                \/\/ representation of `h`.\n                Some (split`{k} h)\n            else None\n            where\n                (h, Index) = hAndIndex\n                \/\/ This helper reads any \"leftover\" bytes (e.g. beyond `Index`)\n                \/\/ in the first `\u03c9` bytes of `y`; it returns `True` if all of\n                \/\/ them are zero.\n                checkLeftoverBytes = and [i >= Index ==> y@i == 0\n                    | i <- [0..\u03c9 - 1]]\n\n        None -> None\n\n\/**\n * Verify that `HintBitUnpack` is the reverse of `HintBitPack`.\n *\n * This takes a list of indexes indicating the non-zero elements and constructs\n * a valid, sparse `h` -- rejection sampling is not a valid option because\n * sparse-enough `h`s were too rare.\n *\n * We test the case where we have the maximum number of 1s, a medium number, and\n * a case where at least one vector should have no non-zero terms at all.\n * In practice, the hint may fall anywhere in this range.\n * This takes about 1 minute.\n * ```repl\n * :check HintPackingInverts`{\u03c9}\n * :check HintPackingInverts`{\u03c9 \/ 2}\n * :check HintPackingInverts`{3}\n * ```\n *\n * Note that this does not test the error cases for `HintBitUnpack`.\n *\/\nHintPackingInverts : {w} (w <= \u03c9) => [w][lg2 (256 * k)] -> Bit\nproperty HintPackingInverts h_Indexes =\n    case HintBitUnpack (HintBitPack h) of\n        Some h' -> h == h'\n        None -> False\n    where\n        h = buildHint h_Indexes\n\nprivate\n    \/**\n     * Creates a hint with `w` non-zero entries at the indices specified in\n     * the parameter.\n     * This is for testing functions that take a hint as a parameter and assume\n     * it is appropriately sparse.\n     *\/\n    buildHint : {w} (w <= \u03c9) => [w][lg2 (256 * k)] -> [k]R2\n    buildHint h_Indexes = h where\n        h = split`{k} [if elem idx h_Indexes then 1 else 0 | idx <- [0..(256 * k) - 1]]\n\n\/**\n * Encode a public key for ML-DSA into a byte string.\n * [FIPS-204] Section 7.2, Algorithm 22.\n *\n * This assumes that `t1` has coefficients in the range\n * `[0, 2^(bitlen(q-1) - d) - 1]`.\n *\/\npkEncode : [32]Byte -> [k]R -> PublicKey\npkEncode \u03c1 t1 = pk where\n    pk = \u03c1 # join [SimpleBitPack`{2 ^^ (width (q - 1) - d) - 1} (t1@i) | i <- [0..k-1]]\n\n\/**\n * Reverse the procedure `pkEncode`.\n * [FIPS-204] Section 7.2, Algorithm 23.\n *\n * This produces a `t1` with coefficients in the range\n * `[0, 2^(bitlen(q-1) - d) - 1]`.\n *\/\npkDecode : PublicKey -> ([32]Byte, [k]R)\npkDecode pk = (\u03c1, t1) where\n    \/\/ Step 1. We split off the single `\u03c1` byte, then separate the remaining\n    \/\/ bytes into the `k` components as described.\n    (\u03c1 # zBytes) = pk\n    z = split zBytes\n    \/\/ Steps 2 - 4.\n    t1 = [SimpleBitUnpack`{2 ^^ (width (q - 1) - d) - 1} (z@i) | i <- [0..k-1]]\n\nprivate\n    \/**\n     * `pkDecode` must reverse the procedure `pkEncode`.\n     * This takes about 30s.\n     * ```repl\n     * :set tests=20\n     * :check pkCodingInverts\n     * ```\n     *\/\n    pkCodingInverts : [32]Byte -> [k][256][width (q - 1) - d] -> Bit\n    pkCodingInverts \u03c1 t1_inRange = inverts where\n        \/\/ `t1_inRange` is typed to ensure that all the coefficients will be\n        \/\/ in the range `[0, 2^^(width (q-1)-d) - 1]`.\n        t1 = [map toInteger t1_i | t1_i <- t1_inRange]\n        (\u03c1', t1') = pkDecode (pkEncode \u03c1 t1)\n        inverts = (\u03c1 == \u03c1') && (t1 == t1')\n\n\/**\n * Encodes a secret key for ML-DSA into a byte string.\n * [FIPS-204] Secetion 7.2, Algorithm 24.\n *\/\nskEncode : [32]Byte -> [32]Byte -> [64]Byte -> [ell]R -> [k]R -> [k]R\n    -> PrivateKey\nskEncode \u03c1 K tr s1 s2 t0 = sk9 where\n    \/\/ Note: `sk#` indicates the value of `sk` at Step `#`.\n    \/\/ Step 1.\n    sk1 = \u03c1 # K # tr\n    \/\/ Steps 2 - 4.\n    sk3 = sk1 # join [BitPack`{\u03b7, \u03b7} (s1@i) | i <- [0..ell-1]]\n    \/\/ Steps 5 - 7.\n    sk6 = sk3 # join [BitPack`{\u03b7, \u03b7} (s2@i) | i <- [0..k-1]]\n    \/\/ Steps 8 - 10.\n    sk9 = sk6 #\n        join [BitPack`{2^^(d - 1) - 1, 2^^(d - 1)} (t0@i) | i <- [0..k-1]]\n\n\/**\n * Reverse the procedure `skEncode`.\n * [FIPS-204] Section 7.2, Algorithm 25.\n *\n * Warning: there exist malformed inputs that can cause `skDecode` to return\n * values that are not in the correct range! `skDecode` must only be run on\n * inputs that come from trusted sources!\n *\/\nskDecode : PrivateKey -> ([32]Byte, [32]Byte, [64]Byte, [ell]R, [k]R, [k]R)\nskDecode sk = (\u03c1, K, tr, s1, s2, t0) where\n    \/\/ Step 1. We split off the six components, then further separate `y`, `z`,\n    \/\/ and `w` into their two dimensions.\n    (\u03c1 # K # tr # yBytes # zBytes # wBytes) = sk\n    y = split`{ell} yBytes\n    z = split`{k} zBytes\n    w = split`{k} wBytes\n\n    \/\/ Steps 2 - 4.\n    s1 = [BitUnpack`{\u03b7, \u03b7} (y@i) | i <- [0..ell-1]]\n    \/\/ Steps 5 - 7.\n    s2 = [BitUnpack`{\u03b7, \u03b7} (z@i) | i <- [0..k-1]]\n    \/\/ Steps 8 - 10.\n    t0 = [BitUnpack`{2^^(d - 1) - 1, 2^^(d - 1)} (w@i) | i <- [0..k-1]]\n\nprivate\n    \/**\n     * The `skDecode` function must be the inverse of `skEncode`.\n     * [FIPS-204] Section 7.3, comment on Algorithm 25.\n     *\n     * This test enforces the range requirements on the inputs to\n     * `skEncode` by taking parameters in the integers mod groups, then\n     * converting to unbounded integers and shifting to be in the expected\n     * range.\n     *\n     * This takes about 1 minute.\n     * ```repl\n     * :set tests=20\n     * :check skCodingInverts\n     * ```\n     *\/\n    skCodingInverts : [32]Byte -> [32]Byte -> [64]Byte\n        -> [ell][256](Z (2 * \u03b7))\n        -> [k][256](Z (2 * \u03b7))\n        -> [k][256](Z (2 ^^ d - 1))\n        -> Bit\n    skCodingInverts \u03c1 K tr s1_inRange s2_inRange t0_inRange = inverts where\n        \/\/ Adjust to be in the correct range and of the correct type.\n        s1 = [[(fromZ s1_ij) - `\u03b7 | s1_ij <- s1_j ] | s1_j <- s1_inRange]\n        s2 = [[(fromZ s2_ij) - `\u03b7 | s2_ij <- s2_j ] | s2_j <- s2_inRange]\n        t0 = [[(fromZ t0_ij) - (2 ^^ (`d-1) - 1)\n            | t0_ij <- t0_j ]\n            | t0_j <- t0_inRange]\n\n        (\u03c1', K', tr', s1', s2', t0') = skDecode (skEncode \u03c1 K tr s1 s2 t0)\n        inverts = (\u03c1 == \u03c1') && (K == K') && (tr == tr')\n            && (s1 == s1') && (s2 == s2') && (t0 == t0')\n\n\/**\n * Encode a signature into a byte string.\n * [FIPS-204] Section 7.3, Algorithm 26.\n *\n * The parameter `z` must have coefficients in `[-\u03b31 + 1, \u03b31]`.\n *\/\nsigEncode : [\u03bb \/ 4]Byte -> [ell]R -> [k]R2 -> Signature\nsigEncode c_til z h = \u03c3 where\n    \/\/ Note that `\u03c3#` indicates the value of `\u03c3` at Step `#`.\n    \/\/ Step 1.\n    \u03c31 = c_til\n    \/\/ Step 2 - 4.\n    \u03c33 = \u03c31 # join [BitPack`{\u03b31 - 1, \u03b31} (z@i) | i <- [0..ell-1]]\n    \/\/ Step 5.\n    \u03c3 = \u03c33 # HintBitPack h\n\n\/**\n * Reverse the procedure `sigEncode`.\n * [FIPS-204] Section 7.3, Algorithm 27.\n *\/\nsigDecode : Signature -> ([\u03bb \/ 4]Byte, [ell]R, Option ([k]R2))\nsigDecode \u03c3 = (c_til, z, h) where\n    \/\/ Step 1. We separate into bytes, then further split `x` into its two\n    \/\/ dimensions.\n    (c_til # xBytes # y) = \u03c3\n    x = split`{ell} xBytes\n\n    \/\/ Step 2 - 4.\n    z = [BitUnpack`{\u03b31 - 1, \u03b31} (x@i) | i <- [0..ell-1]]\n    \/\/ Step 5.\n    h = HintBitUnpack y\n\nprivate\n    \/**\n     * `sigDecode` must be the reverse of `sigEncode`.\n     * [FIPS-204] Section 7.3, comment on Algorithm 27.\n     *\n     * The parameter `w` defines the number of non-zero entries in the hint.\n     * It can be any number in the range `[0, \u03c9 - 1]`. In practice, it's\n     * dependent on many factors, so we choose the middle of the range for convenience.\n     * This takes about 45 seconds.\n     * ```repl\n     * :set test=20\n     * :check sigCodingInverts`{\u03c9 \/ 2}\n     * ```\n     *\/\n    sigCodingInverts : {w} (w < \u03c9) =>\n        [\u03bb \/ 4]Byte -> [ell][256](Z (2 * \u03b31 - 1)) -> [w][lg2 (256 * k)] -> Bit\n    property sigCodingInverts c_til z_inRange h_Indexes = inverts where\n        \/\/ The coefficients of `z` must be in the range `[-\u03b31 + 1, \u03b31]`.\n        \/\/ Convert to correct type and adjust them to the correct range.\n        z = [[(fromZ zij) - (`\u03b31 - 1) | zij <- zi ] | zi <- z_inRange]\n\n        \/\/ The hint must not have more than `\u03c9` non-zero indexes. `buildHint`\n        \/\/ makes sure this is true.\n        h = buildHint h_Indexes\n\n        (c_til', z', maybe_h') = sigDecode (sigEncode c_til z h)\n        h_matches = case maybe_h' of\n            Some h' -> h == h'\n            None -> False\n        inverts = (c_til == c_til') && (z == z') && h_matches\n\/**\n * Encode a polynomial vector `w1` into a byte string.\n * [FIPS-204] Section 7.3, Algorithm 28.\n *\n * The polynomial coordinates of `w1` must be in the range\n * `[0, (q - 1) \/ (2 * \u03b32) - 1]`.\n *\/\nw1Encode : [k]R -> [32 * k * width ((q - 1) \/ (2 * \u03b32) - 1)]Byte\nw1Encode w1 = w1_til where\n    w1_til = join\n        [SimpleBitPack`{(q - 1) \/ (2 * \u03b32) - 1} (w1@i) | i <- [0..k-1]]\n\n\/**\n * Sample a polynomial in `R` with coefficients from `{-1, 0, 1}` and Hamming\n * weight `\u03c4`.\n * [FIPS-204] Section 7.3, Algorithm 29.\n *\/\nSampleInBall : [\u03bb \/ 4]Byte -> R\nSampleInBall \u03c1 = cFinal where\n    \/\/ Step 1.\n    c0 = zero\n    \/\/ Steps 2 - 3.\n    ctx_0 = H`{inf} \u03c1\n        ((s : [8]Byte) # ctx_1) = ctx_0\n    \/\/ Step 5.\n    h = BytesToBits s\n\n    \/\/ Steps 7 - 10. Uses recursion instead of a loop to sample bytes from the\n    \/\/ hash stream, returning the first one that's in the range `[0, i]`.\n    sample : [inf]Byte -> Byte -> (Byte, [inf]Byte)\n    sample ([j] # ctx) i =\n        if j > i then\n            sample ctx i\n        else (j, ctx)\n\n    \/\/ Steps 6 - 13. Computes the value of `c` and the updated `ctx` at each\n    \/\/ iteration of the loop.\n    cAndCtx = [(c0, ctx_1)] # [(c'', ctx') where\n                        (j, ctx') = sample ctx (fromInteger i)\n            \/\/ Step 11.\n            c' = update c i (c@j)\n            \/\/ Step 12. In Cryptol, we need to manually convert the exponent\n            \/\/ from a `Bit` to a numeric type.\n            hi\u03c4 = if (h @ (i + `\u03c4 - 256)) then 1 else 0 : Integer\n            c'' = update c' j ((-1)^^hi\u03c4)\n\n        | i <- [256 - \u03c4..255]\n        | (c, ctx) <- cAndCtx]\n\n    (cFinal, _) = cAndCtx ! 0\n\n\/**\n * Sample a polynomial in the ring `Tq`.\n * [FIPS-204] Section 7.3, Algorithm 30.\n *\/\nRejNTTPoly : [34]Byte -> Tq\nRejNTTPoly \u03c1 = a_hat where\n        ctx0 = G \u03c1\n\n    \/\/ Step 4, 11. The `take` here replaces the loop condition.\n    a_hat = take`{256} (sample ctx0)\n\n    sample : [inf][8] -> [inf](Z q)\n    sample GSqueeze = a_hat' where\n        \/\/ Step 5. This pops the first 3 bytes off the pseudorandom stream.\n        (s, ctx) = splitAt`{3} GSqueeze\n\n        \/\/ Step 6.\n        a_hat_j = CoeffFromThreeBytes (s@0) (s@1) (s@2)\n\n        \/\/ Step 7 - 9. The recursive call here replaces the `while` loop.\n        a_hat' = case a_hat_j of\n            Some aj -> [aj] # (sample ctx)\n            \/\/ In the spec, the sample `a_hat_j` is always added to the list,\n            \/\/ and `j` is only increased if the sample was not rejected (so a\n            \/\/ rejected value is overwritten in the next iteration). Here,\n            \/\/ we only add `a_hat_j` if it's valid.\n            None -> sample ctx\n\n\/**\n * Sample an element in `R` with coefficients in the range [-\u03b7, \u03b7].\n * [FIPS-204] Section 7.3, Algorithm 31.\n *\/\nRejBoundedPoly: [66]Byte -> R\nRejBoundedPoly \u03c1 = a where\n    \/\/ Steps 2 - 3.\n    ctx0 = H \u03c1\n\n    \/\/ Step 4, 17. The `take` replaces the loop condition.\n    a = take`{256} (sample ctx0)\n\n    sample : [inf][8] -> [inf]Integer\n    sample HSqueeze = a' where\n        \/\/ Step 5. This pops one byte off the pseudorandom stream.\n        ([z] # ctx) = HSqueeze\n\n        \/\/ Step 6 - 8. We use Cryptol-native functions instead of dividing\n        \/\/ and modding `z`. See `TakeAndDropAreDivAndMod` for the equivalence.\n        z0 = CoeffFromHalfByte (drop`{4} z)\n        z1 = CoeffFromHalfByte (take`{4} z)\n\n        \/\/ Step 8 - 15. The recursive calls replace the `while` loop.\n        \/\/ In order to make the types work, we have to mash the two conditions\n        \/\/ together and make exactly one recursive call.\n        a' = case z0 of\n            Some z0' -> case z1 of\n                Some z1' -> [z0', z1'] # (sample ctx)\n                None -> [z0'] # (sample ctx)\n            None -> case z1 of\n                Some z1' -> [z1'] # (sample ctx)\n                None -> sample ctx\n\n\/**\n * Given a byte, the `take` function is equivalent to dividing by 16, and the\n * `drop` function is equivalent to taking the value mod 16.\n *\n * We prefer the Cryptol functions because they automatically convert from a\n * byte to a 4-bit value, which we need to call `CoeffFromHalfByte`. Here, we\n * use `zext` pad the 4-bit-vector, so we can compare it to the byte.\n * ```repl\n * :prove TakeAndDropAreDivAndMod\n * ```\n *\/\nTakeAndDropAreDivAndMod : [8] -> Bool\nproperty TakeAndDropAreDivAndMod z = dropIsMod && takeIsDiv where\n    dropIsMod = z % 16 == zext (drop`{4} z)\n    \/\/ Division of bit vectors in Cryptol automatically takes the floor.\n    takeIsDiv = z \/ 16 == zext (take`{4} z)\n\n\/**\n * Sample a `k x l` matrix of elements of `T_q`.\n * [FIPS-204] Section 7.3, Algorithm 32.\n *\/\nExpandA : [32]Byte -> [k][ell]Tq\nExpandA \u03c1 = A_hat where\n    A_hat = [[RejNTTPoly \u03c1' where\n            \u03c1' = \u03c1 # IntegerToBytes`{1} s # IntegerToBytes`{1} r\n        | s <- [0..ell - 1]]\n        | r <- [0..k - 1]]\n\n\/**\n * Sample vectors in `R^ell` and `R^k`, each with polynomial coordinates whose\n * coefficients are in the interval `[-\u03b7 , \u03b7]`.\n * [FIPS-204] Section 7.3, Algorithm 33.\n *\/\nExpandS : [64]Byte -> ([ell]R, [k]R)\nExpandS \u03c1 = (s1, s2) where\n    s1 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} r) | r <- [0..ell-1]]\n    s2 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} (r + `ell)) | r <- [0..k-1]]\n\n\/**\n * Sample a vector in `R^ell` such that each polynomial in `y` has coefficients\n * in the range `[-\u03b31 + 1, \u03b31]`.\n * [FIPS-204] Section 7.3, Algorithm 34.\n *\n * Note: This function requires that `\u03bc` is non-negative.\n *\/\nExpandMask : [64]Byte -> Integer -> [ell]R\nExpandMask \u03c1 \u03bc = y where\n    type c = 1 + width (\u03b31 - 1)\n\n    y = [BitUnpack`{\u03b31 - 1, \u03b31} v where\n            \u03c1' = \u03c1 # IntegerToBytes`{2} (\u03bc + r)\n            v = H`{32 * c} \u03c1'\n        | r <- [0..ell - 1]]\n\n\/**\n * Decompose a set of integers mod `q` into a pair `(r1, r0)` such that\n * `r === r1 * 2^d + r0 mod q`.\n *\n * This applies the `Power2Round` function (Algorithm 35) coefficientwise to\n * the polynomials in the vectors, per the description at the beginning of\n * [FIPS-204] Section 7.4.\n *\/\nPower2Round : [k]Rq -> ([k]R, [k]R)\nPower2Round r_vec = (r1_vec, r0_vec) where\n    \/\/ [FIPS-204] Section 7.4, Algorithm 35.\n    Power2Round_Single : Z q -> (Integer, Integer)\n    Power2Round_Single r = (r1, r0) where\n        r_plus = r\n        r0 = modPlusMinus`{2^^d} r_plus\n        r1 = ((fromZ r_plus) - r0) \/ (2^^`d)\n\n    \/\/ Apply the function coefficientwise to every polynomial.\n    zipped_r1r0 : [k][256](Integer, Integer)\n    zipped_r1r0 = [map Power2Round_Single r | r <- r_vec]\n\n        r1_vec = [[r1_j | (r1_j, _) <- ri] | ri <- zipped_r1r0]\n    r0_vec = [[r0_j | (_, r0_j) <- ri] | ri <- zipped_r1r0]\n\nprivate\n    \/**\n     * Property demonstrating that `Power2Round` does what it says it's\n     * supposed to do in the definition.\n     * [FIPS-204] Section 7.4, comment on Algorithm 35.\n     * ```repl\n     * :check power2RoundSatisfiesDefinition\n     * ```\n     *\/\n    power2RoundSatisfiesDefinition r_vec = validDecomp where\n        (r1_vec, r0_vec)= Power2Round r_vec\n        isValid (r, (r1, r0)) = (r1 * 2^^`d + r0) % `q == (fromZ r)\n        validDecomp = and [ and (map isValid (zip rs (zip r1s r0s)))\n            | r1s <- r1_vec\n            | r0s <- r0_vec\n            | rs <- r_vec]\n\n\/**\n * Decompose a set of integers mod `q` into a pair `(r1, r0)` such that\n * `r === r1 (2 \u03b32) + r0 mod q`.\n *\n * This applies the `Decompose` function (Algorithm 36) coefficientwise to\n * the polynomials in the vectors, per the description at the beginning of\n * [FIPS-204] Section 7.4.\n *\/\nDecompose : [k]Rq -> ([k]R, [k]R)\nDecompose r_vec = (r1_vec, r0_vec) where\n    \/\/ [FIPS-204] Section 7.4, Algorithm 36.\n    Decompose_Single : Z q -> (Integer, Integer)\n    Decompose_Single r = (r1, r0') where\n        r_plus = r\n        r0 = modPlusMinus`{2 * \u03b32} r_plus\n        (r1, r0') = if (fromZ r_plus) - r0 == `q - 1 then\n                (0, r0 - 1)\n            else\n                (((fromZ r_plus) - r0) \/ (2 * `\u03b32), r0)\n\n    \/\/ Apply the function coefficientwise to every polynomial.\n    zipped_r1r0 : [k][256](Integer, Integer)\n    zipped_r1r0 = [map Decompose_Single r | r <- r_vec]\n\n        r1_vec = [[r1_j | (r1_j, _) <- ri] | ri <- zipped_r1r0]\n    r0_vec = [[r0_j | (_, r0_j) <- ri] | ri <- zipped_r1r0]\n\nprivate\n    \/**\n     * Property demonstrating that `Decompose` does what it says it's\n     * supposed to do in the definition.\n     * [FIPS-204] Section 7.4, comment on Algorithm 36.\n     * ```repl\n     * :check decomposeSatisfiesDefinition\n     * ```\n     *\/\n    decomposeSatisfiesDefinition r_vec = validDecomp where\n        (r1_vec, r0_vec)= Decompose r_vec\n        isValid (r, (r1, r0)) = (r1 * 2 * `\u03b32 + r0) % `q == (fromZ r)\n        validDecomp = and [ and (map isValid (zip rs (zip r1s r0s)))\n            | r1s <- r1_vec\n            | r0s <- r0_vec\n            | rs <- r_vec]\n\n\/**\n * Returns `r1` from the output of `Decompose`.\n * [FIPS-24] Section 7.4, Algorithm 37.\n *\n * This applies the `HighBits` function (Algorithm 37) coefficientwise to\n * the polynomials in the vectors, per the description at the beginning of\n * Section 7.4.\n *\/\nHighBits : [k]Rq -> [k]R\nHighBits r = r1 where\n    (r1, _) = Decompose r\n\n\/**\n * Returns `r0` from the output of `Decompose`.\n * [FIPS-24] Section 7.4, Algorithm 38.\n *\n * This applies the `LowBits` function (Algorithm 38) coefficientwise to\n * the polynomials in the vectors, per the description at the beginning of\n * Section 7.4.\n *\/\nLowBits : [k]Rq -> [k]R\nLowBits r = r0 where\n    (_, r0) = Decompose r\n\n\/**\n * Compute the hint bits indiciating whether adding `z` to `r` alters the high\n * bits of `r`.\n * [FIPS-204] Section 7.4, Algorithm 39.\n *\n * This applies the `MakeHint` function coefficientwise to the polynomials in the\n * vectors, per the description at the beginning of Section 7.4. The `HighBits`\n * function operates over vectors of polynomials; then we compare the vectors of\n * high bits coefficientwise.\n *\/\nMakeHint : [k]Rq -> [k]Rq -> [k]R2\nMakeHint z_vec r_vec = hint where\n    r1_vec = HighBits r_vec\n    v1_vec = HighBits (r_vec + z_vec)\n\n    hint = [[r1 != v1\n        | r1 <- r1s | v1 <- v1s]\n        | r1s <- r1_vec | v1s <- v1_vec]\n\n\/**\n * Return the high bits of `r` adjusted according to hint `h`.\n * [FIPS-204] Section 7.4, Algorithm 40.\n *\n * This applies the `UseHint` function coefficientwise to the polynomials in\n * the vectors, per the description at the beginning of Section 7.4.\n *\/\nUseHint : [k]R2 -> [k]Rq -> [k]R\nUseHint h_vec r_vec = r1'_vec where\n    \/\/ Step 1.\n    m = (`q - 1) \/ (2 * `\u03b32)\n    \/\/ Step 2.\n    (r1_vec, r0_vec) = Decompose r_vec\n\n    \/\/ Steps 3 - 5. This takes the decomposed integers instead of the original\n    \/\/ element in `Z q`.\n    adjustHighBits r1 r0 h =\n        if (h == 1) && (r0 > 0) then (r1 + 1) % m\n        | (h == 1) && (r0 <= 0) then (r1 - 1) % m\n        else r1\n\n    \/\/ Apply the function coefficientwise to the decomposed polynomials.\n    r1'_vec = [[adjustHighBits r1 r0 h\n            | r1 <- r1s | r0 <- r0s | h <- hs]\n        | r1s <- r1_vec | r0s <- r0_vec | hs <- h_vec]\n\nprivate\n    \/**\n     * The output of `UseHint` must be within the range `[0, (q-1) \/ (2*\u03b32)]`.\n     * [FIPS-204] Section 7.4, comment on Algorithm 40.\n     *\n     * ```repl\n     * :check useHintIsInRange\n     * ```\n     * Alternately, this takes about 1 hour to prove.\n     *\/\n    property useHintIsInRange h_vec r_vec = r1InRange where\n        r1_vec = UseHint h_vec r_vec\n        inRange r1 = (0 <= r1) && (r1 <= (`q - 1) \/ (2 * `\u03b32))\n        \/\/ Apply check coefficientwise to the polynomial vector.\n        r1InRange = and [and (map inRange r1s) | r1s <- r1_vec]\n\n\/**\n * Number theoretic transform: compute the \"NTT representation\" in\n * `T_q` of a polynomial in `R_q`.\n *\n * This is equivalent to [FIPS-204] Section 7.5, Algorithm 41. That particular\n * formulation is difficult to implement in Cryptol. Instead, we use the naive\n * NTT implementation described in [NTT-Guide] Section 3.3.2, Equation 16. Note\n * that [NTT-Guide] uses different notation: their `\u03c8` is our `\u03b6`; their `a`\n * is our `f`; and we set their `n = 256`.\n *\n * There is one divergence between [NTT-Guide] and [FIPS-204]: the spec uses\n * bit-reversed indexes for the NTT representation, but the guide does not.\n *\n * @design Marcella Hastings <marcella@galois.com>: This is neither efficient\n * nor obviously spec-adherent. We should aim to make it at least one of those.\n * Ideally we will consolidate all the NTT implementations across the cryptol-\n * specs repo into a single common, validated (by some means...) implementation\n * and import it for use here and elsewhere.\n * @see https: *\/\nNTT : Rq -> Tq\nNTT f = [f_hat_j j | j <- bitrev_indexes] where\n    f_hat_j j = sum [ (\u03b6 ^^ (2 * i * j + i)) * fi | i <- [0..255] | fi <- f]\n\n    \/\/ Rearrange the indexes so that the NTT representation is in\n    \/\/ bit-reversed-index order.\n    bitrev_indexes = map toInteger (map reverse [0..255 : [8]])\n\n\/**\n * Inverse of the number theoretic transform: converts from the \"NTT\n * representation\" in `T_q` to a polynomial in `R_q`.\n *\n * This is equivalent to [FIPS-204] Section 7.5, Algorithm 42. That particular\n * formulation is difficult to implement in Cryptol. Instead, we use the naive\n * NTT implementation described in [NTT-Guide] Section 3.3.3, Equation 18. Note\n * that [NTT-Guide] uses different notation: their `\u03c8` is our `\u03b6`; their `a`\n * is our `f`; and we set their `n = 256`.\n *\n * There is one divergence between [NTT-Guide] and [FIPS-204]: the spec uses\n * bit-reversed indexes for the NTT representation, but the guide does not.\n *\n * @design Marcella Hastings <marcella@galois.com>: This is neither efficient\n * nor obviously spec-adherent. We should aim to make it at least one of those.\n * Ideally we will consolidate all the NTT implementations across the cryptol-\n * specs repo into a single common, validated (by some means...) implementation\n * and import it for use here and elsewhere.\n * @see https: *\/\nNTTInv : Tq -> Rq\nNTTInv f_hat = [f_i j * inv_root | j <- [0..255]] where\n    inv_root = recip 256 : Z q\n    inv_\u03b6 = recip \u03b6\n    f_i j = sum [ (inv_\u03b6 ^^ (2 * i * j + j)) * f_hat_j\n        | i <- [0..255]\n        | f_hat_j <- indexReversedFHat]\n\n    \/\/ Rearrange the NTT representation to bit-reverse the indexes.\n    bitrev_indexes = map reverse [0..255 : [8]]\n    indexReversedFHat = [f_hat@i | i <- bitrev_indexes]\n\nprivate\n    \/**\n     * This property demonstrates that `NTTInv` inverts `NTT`.\n     * This takes about 20s to check.\n     * ```repl\n     * :set tests=20\n     * :check NTT_Inverts\n     * ```\n     * Alternately, this proves in ~8 min with Z3 v4.13.3.\n     *\/\n    NTT_Inverts : Rq -> Bit\n    property NTT_Inverts f =  NTTInv (NTT f) == f\n\n    \/**\n     * This property demonstrates that `NTT` inverts `NTTInv`.\n     * This takes about 20s to check.\n     * ```repl\n     * :set tests=20\n     * :check NTTInv_Inverts\n     * ```\n     *\/\n    NTTInv_Inverts : Tq -> Bit\n    property NTTInv_Inverts f =  NTT (NTTInv f) == f\n\n\/**\n * Compute the sum of two elemetns in `Tq`.\n * [FIPS-204] Section 7.6, Algorithm 44.\n *\/\nAddNTT : Tq -> Tq -> Tq\nAddNTT a b = c where\n    c = [a@i + b@i | i <- [0..255]]\n\n\/**\n * The definition of addition in the spec is the same as the built-in addition\n * operator in Cryptol!\n * ```repl\n * :prove addNTTisPlus\n * ```\n *\/\nproperty addNTTisPlus a b = AddNTT a b == a + b\n\n\/**\n * Compute the product of two elements in `Tq`.\n * [FIPS-204] Section 7.6, Algorithm 45.\n *\/\nMultiplyNTT : Tq -> Tq -> Tq\nMultiplyNTT a b = c where\n    c = [a@i * b@i | i <- [0..255]]\n\n\/**\n * The definition of multiplication in the spec is the same as the built-in\n * multiplication (*) operator in Cryptol!\n * ```repl\n * :prove multiplyNTTisStar\n * ```\n *\/\nproperty multiplyNTTisStar a b = MultiplyNTT a b == a * b\n\n\/**\n * Compute the sum of two vectors over `Tq`\n * [FIPS-204] Section 7.6, Algorithm 46.\n *\/\nAddVectorNTT : {l} (fin l, l > 0) => [l]Tq -> [l]Tq -> [l]Tq\nAddVectorNTT v w = u where\n    u = [AddNTT (v@i) (w@i) | i <- [0..l-1]]\n\n\/**\n * The defintion of vector addition in the spec is the same as the built-in\n * addition operator in Cryptol!\n * There's only one NTT vector addition that I could find in the spec and it's\n * between vectors of length `k`:\n * ```repl\n * :prove addVectorNTTisPlus`{k}\n * ```\n *\/\naddVectorNTTisPlus : {r} (fin r, r > 0) => [r]Tq -> [r]Tq -> Bit\nproperty addVectorNTTisPlus v w = AddVectorNTT v w == v + w\n\n\/**\n * Compute the product of a scalar and a vector over `Tq`.\n * [FIPS-204] Section 7.6, Algorithm 47.\n *\/\nScalarVectorNTT : {l} (fin l, l > 0) => Tq -> [l]Tq -> [l]Tq\nScalarVectorNTT c v = w where\n    w = [MultiplyNTT c (v@i) | i <- [0..l-1]]\n\n\/**\n * Custom operator for computing the product of a scalar and a vector.\n *\n * The spec overloads the ring operator `\u2218` to mean several operations,\n * in `Tq`, including the product of two elements, the product of a scalar\n * and a vector, and the product of a matrix and a vector.\n * Cryptol does not support user-defined overloaded symbols, so we define\n * `\u2218` to be the function with the most usage in the spec.\n *\n * This implements a more efficient version of `ScalarVectorNTT`.\n *\/\n(\u2218) : {l} (fin l, l > 0) => Tq -> [l]Tq -> [l]Tq\n(\u2218) c v = [c * vi | vi <- v]\n\n\/**\n * The optimized scalar vector multiplication operator `\u2218` is equivalent to\n * `ScalarVectorNTT`.\n *\n * These parameters are the only ones used for this operation in the spec:\n * ```repl\n * :prove ringIsScalarVectorNTT`{k}\n * :prove ringIsScalarVectorNTT`{ell}\n * ```\n *\/\nringIsScalarVectorNTT : {l} (fin l, l > 0) => Tq -> [l]Tq -> Bit\nproperty ringIsScalarVectorNTT c v = c \u2218 v == ScalarVectorNTT c v\n\n\/**\n * Compute the product of a matrix and a vector over `Tq`.\n * [FIPS-204] Section 7.6, Algorithm 48.\n *\n * Note: The spec defines this operation for a matrix with dimensions\n * `k x ell`, where `k` and `ell` are natural numbers. This actually overloads\n * those names, since they're also the dimensions that are part of the\n * parameterization of the algorithm. In fact, we only ever use this\n * function for the matrix `A_hat` with dimensions `k x ell` (the parameters).\n * So, this isn't implemented over arbitrary matrix dimensions, although I\n * think it could be.\n *\/\nMatrixVectorNTT : [k][ell]Tq -> [ell]Tq -> [k]Tq\nMatrixVectorNTT M v = w where\n    \/\/ We use the `sum` built-in function instead of iteratively applying\n    \/\/ `AddNTT`. See `addNTTisPlus` property for the equivalence.\n    w = [sum [ MultiplyNTT (M@i@j) (v@j)\n        | j <- [0..ell-1]]\n        | i <- [0..k-1] ]\n\n\/**\n * Custom operator for computing the product of a matrix and a vector.\n *\n * The spec overloads the ring operator `\u2218` to mean several operations in\n * `Tq`. In this executable spec, we define `\u2218` to mean scalar-vector\n * multiplication. Cryptol does not support user-defined overloaded symbols,\n * but for readability, it's nice to have an infix operator for this function.\n *\n * This implements a more efficient verison of `ScalarVectorNTT`.\n *\/\n(\u2218\u2218) : [k][ell]Tq -> [ell]Tq -> [k]Tq\n(\u2218\u2218) M v = [sum [Mij * vj | Mij <- Mi | vj <- v] | Mi <- M]\n\n\/**\n * The optimized matrix vector multiplication operator `\u2218\u2218` is equivalent to\n * `MatrixVectorNTT`.\n * ```repl\n * :prove doubleRingIsMatrixVectorNTT\n * ```\n *\/\ndoubleRingIsMatrixVectorNTT : [k][ell]Tq -> [ell]Tq -> Bit\nproperty doubleRingIsMatrixVectorNTT M v = (M \u2218\u2218 v) == MatrixVectorNTT M v\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/OptimizedSpecification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the optimized ML-DSA signature scheme implementation in the given module is functionally equivalent to the original specification. Include equivalence checks for key generation, signing, verification, encoding and decoding of keys and signatures, and all packing\/unpacking functions. Ensure the properties can be used with :check or :prove commands to validate correctness of the optimized implementation against the specification."},{"role":"assistant","content":"```cryptol\n\/**\n * Optimized implementation of the ML-DSA (CRYSTALS-Dilithium) signature scheme.\n *\n * This implementation deviates from the specification in favor of performance.\n *\n * @copyright Galois Inc\n * @author Marios Georgiou <marios@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification where\n\nimport interface Primitive::Asymmetric::Signature::ML_DSA::Parameters as P\nimport Primitive::Asymmetric::Signature::ML_DSA::Specification { interface P }  as Spec\n\ntype q = P::q\ntype \u03c9 = P::\u03c9\ntype k = P::k\ntype ell = P::ell\ntype \u03b7 = P::\u03b7\ntype \u03bb = P::\u03bb\ntype \u03b31 = P::\u03b31\ntype \u03b32 = P::\u03b32\ntype \u03c4 = P::\u03c4\n\ntype Byte = Spec::Byte\n\ntype Tq = Spec::Tq\ntype R = Spec::R\ntype R2 = Spec::R2\ntype Rq = Spec::Rq\n\nmodPlusMinus : {\u03b1} (fin \u03b1) => Z q -> Integer\nmodPlusMinus = Spec::modPlusMinus`{\u03b1}\n\ninfNormRq = Spec::infNormRq\n\ninfNormR = Spec::infNormR\n\ncastToRq = Spec::castToRq\n\nNTT_Vec = Spec::NTT_Vec\n\nNTTInv_Vec = Spec::NTTInv_Vec\n\nH = Spec::H\n\nHBits = Spec::HBits\n\nG = Spec::G\n\n\u03b6 = Spec::\u03b6\n\ntype d = Spec::d\n\n\u03b2 = Spec::\u03b2\n\ntype PublicKey = Spec::PublicKey\n\ntype PrivateKey = Spec::PrivateKey\n\ntype Signature = Spec::Signature\n\n\/**\n * This is almost identical to `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file but H`{64} is replaced by H to avoid compilation\n * errors.\n *\/\nKeyGen_internal : [32]Byte -> (PublicKey, PrivateKey)\nKeyGen_internal \u03be = (pk, sk) where\n    \/\/ Step 1.\n    (\u03c1 # \u03c1' # K) = H (\u03be # IntegerToBytes`{1} `k # IntegerToBytes`{1} `ell)\n\n    \/\/ Step 3.\n    A_hat = ExpandA \u03c1\n        (s1, s2) = ExpandS \u03c1'\n\n    \/\/ Explicitly typecast vectors in `R` to `Rq`.\n    s1' = castToRq s1\n    s2' = castToRq s2\n\n    \/\/ Step 5.\n    t = NTTInv_Vec (A_hat \u2218\u2218 NTT_Vec s1') + s2'\n    \/\/ Step 6.\n    (t1, t0) = Power2Round t\n\n    \/\/ Step 8.\n    pk = pkEncode \u03c1 t1\n    \/\/ Step 9.\n    tr = H pk\n    \/\/ Step 10.\n    sk = skEncode \u03c1 K tr s1 s2 t0\n\n\/**\n * ```repl\n * :set tests=3\n * :check KeyGen_internalEquivalence\n * ```\n *\/\nKeyGen_internalEquivalence : [32]Byte -> Bit\nproperty KeyGen_internalEquivalence \u03be = Spec::KeyGen_internal \u03be == KeyGen_internal \u03be\n\nSign_internal = Spec::Sign_internal\n\nVerify_internal = Spec::Verify_internal\n\nIntegerToBits : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]\nIntegerToBits x = reverse (fromInteger x)\n\n\/**\n * ```repl\n * :check IntegerToBitsEquivalence`{44}\n * ```\n *\/\nIntegerToBitsEquivalence : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> Bit\nproperty IntegerToBitsEquivalence x = Spec::IntegerToBits`{\u03b1} x == IntegerToBits`{\u03b1} x\n\nBitsToInteger y = toInteger (reverse y)\n\n\/**\n * ```repl\n * :check BitsToIntegerEquivalence`{44}\n * :exhaust BitsToIntegerEquivalence`{10}\n * ```\n *\/\nBitsToIntegerEquivalence : {\u03b1} (fin \u03b1, \u03b1 > 0) => [\u03b1] -> Bit\nproperty BitsToIntegerEquivalence x = Spec::BitsToInteger x == BitsToInteger x\n\nIntegerToBytes : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]Byte\nIntegerToBytes x = reverse (split (fromInteger x))\n\n\/**\n * ```repl\n * :check IntegerToBytesEquivalence`{44}\n * ```\n *\/\nIntegerToBytesEquivalence : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> Bit\nproperty IntegerToBytesEquivalence x = Spec::IntegerToBytes`{\u03b1} x == IntegerToBytes`{\u03b1} x\n\nBitsToBytes : {\u03b1} (fin \u03b1) => [\u03b1]Bit -> [\u03b1 \/^ 8]Byte\nBitsToBytes y = map reverse (split (y # zero))\n\n\/**\n * ```repl\n * :prove BitsToBytesEquivalence`{320 * 8}\n * :prove BitsToBytesEquivalence`{32 * 44 * 8}\n * ```\n *\/\nBitsToBytesEquivalence : {\u03b1} (fin \u03b1) => [\u03b1]Bit -> Bit\nproperty BitsToBytesEquivalence x = Spec::BitsToBytes x == BitsToBytes x\n\nBytesToBits : {\u03b1} (fin \u03b1) => [\u03b1]Byte -> [8 * \u03b1]Bit\nBytesToBits z = join (map reverse z)\n\n\/**\n * ```repl\n * :prove BytesToBitsEquivalence`{320}\n * :prove BytesToBitsEquivalence`{32 * 44}\n * ```\n *\/\nBytesToBitsEquivalence : {\u03b1} (fin \u03b1) => [\u03b1]Byte -> Bit\nproperty BytesToBitsEquivalence x = Spec::BytesToBits x == BytesToBits x\n\nB2B2BInverts = Spec::B2B2BInverts\n\nCoeffFromThreeBytes = Spec::CoeffFromThreeBytes\n\nCoeffFromHalfByte = Spec::CoeffFromHalfByte\n\nSimpleBitPack : {b} (fin b, width b > 0) => R -> [32 * width b]Byte\nSimpleBitPack w = BitsToBytes (join (map IntegerToBits`{width b} w))\n\n\/**\n * ```repl\n * :check SimpleBitPackEquivalence`{10}\n * ```\n *\/\nSimpleBitPackEquivalence : {b} (fin b, width b > 0) => R -> Bit\nproperty SimpleBitPackEquivalence w = Spec::SimpleBitPack`{b} w == SimpleBitPack`{b} w\n\nBitPack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    R -> [32 * width (a + b)]Byte\nBitPack w = BitsToBytes (join (map (\\x -> IntegerToBits`{width (a + b)} (`b - x)) w))\n\n\/**\n * ```repl\n * :check BitPackEquivalence`{10, 10}\n * ```\n *\/\nBitPackEquivalence : {a, b} (fin a, fin b, width (a + b) > 0) => R -> Bit\nproperty BitPackEquivalence w = Spec::BitPack`{a, b} w == BitPack`{a, b} w\n\nSimpleBitUnpack : {b} (fin b, width b > 0) => [32 * width b]Byte -> R\nSimpleBitUnpack v = map BitsToInteger (split (BytesToBits v))\n\n\/**\n * ```repl\n * :check SimpleBitUnpackEquivalence`{10}\n * ```\n *\/\nSimpleBitUnpackEquivalence : {b} (fin b, width b > 0) => [32 * width b]Byte -> Bit\nproperty SimpleBitUnpackEquivalence v = Spec::SimpleBitUnpack`{b} v == SimpleBitUnpack`{b} v\n\nBitUnpack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    [32 * width (a + b)]Byte -> R\nBitUnpack v = map (\\x -> `b - BitsToInteger x) (split (BytesToBits v))\n\n\/**\n * ```repl\n * :check BitUnpackEquivalence`{10, 10}\n * ```\n *\/\nBitUnpackEquivalence : {a, b} (fin a, fin b, width (a + b) > 0) => [32 * width (a + b)]Byte -> Bit\nproperty BitUnpackEquivalence v = Spec::BitUnpack`{a, b} v == BitUnpack`{a, b} v\n\nHintBitPack = Spec::HintBitPack\n\nHintBitUnpack = Spec::HintBitUnpack\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\npkEncode : [32]Byte -> [k]R -> PublicKey\npkEncode \u03c1 t1 = pk where\n    pk = \u03c1 # join [SimpleBitPack`{2 ^^ (width (q - 1) - d) - 1} (t1@i) | i <- [0..k-1]]\n\n\/**\n * ```repl\n * :check pkEncodeEquivalence\n * ```\n *\/\npkEncodeEquivalence : [32]Byte -> [k]R -> Bit\nproperty pkEncodeEquivalence \u03c1 t1 = Spec::pkEncode \u03c1 t1 == pkEncode \u03c1 t1\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\npkDecode : PublicKey -> ([32]Byte, [k]R)\npkDecode pk = (\u03c1, t1) where\n    \/\/ Step 1. We split off the single `\u03c1` byte, then separate the remaining\n    \/\/ bytes into the `k` components as described.\n    (\u03c1 # zBytes) = pk\n    z = split zBytes\n    \/\/ Steps 2 - 4.\n    t1 = [SimpleBitUnpack`{2 ^^ (width (q - 1) - d) - 1} (z@i) | i <- [0..k-1]]\n\n\/**\n * ```repl\n * :check pkDecodeEquivalence\n * ```\n *\/\npkDecodeEquivalence : PublicKey -> Bit\nproperty pkDecodeEquivalence pk = Spec::pkDecode pk == pkDecode pk\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\nskEncode : [32]Byte -> [32]Byte -> [64]Byte -> [ell]R -> [k]R -> [k]R\n    -> PrivateKey\nskEncode \u03c1 K tr s1 s2 t0 = sk9 where\n    \/\/ Note: `sk#` indicates the value of `sk` at Step `#`.\n    \/\/ Step 1.\n    sk1 = \u03c1 # K # tr\n    \/\/ Steps 2 - 4.\n    sk3 = sk1 # join [BitPack`{\u03b7, \u03b7} (s1@i) | i <- [0..ell-1]]\n    \/\/ Steps 5 - 7.\n    sk6 = sk3 # join [BitPack`{\u03b7, \u03b7} (s2@i) | i <- [0..k-1]]\n    \/\/ Steps 8 - 10.\n    sk9 = sk6 #\n        join [BitPack`{2^^(d - 1) - 1, 2^^(d - 1)} (t0@i) | i <- [0..k-1]]\n\n\/**\n * ```repl\n * :check skEncodeEquivalence\n * ```\n *\/\nskEncodeEquivalence : [32]Byte -> [32]Byte -> [64]Byte -> [ell]R -> [k]R -> [k]R -> Bit\nproperty skEncodeEquivalence \u03c1 K tr s1 s2 t0 = Spec::skEncode \u03c1 K tr s1 s2 t0 == skEncode \u03c1 K tr s1 s2 t0\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\nskDecode : PrivateKey -> ([32]Byte, [32]Byte, [64]Byte, [ell]R, [k]R, [k]R)\nskDecode sk = (\u03c1, K, tr, s1, s2, t0) where\n    \/\/ Step 1. We split off the six components, then further separate `y`, `z`,\n    \/\/ and `w` into their two dimensions.\n    (\u03c1 # K # tr # yBytes # zBytes # wBytes) = sk\n    y = split`{ell} yBytes\n    z = split`{k} zBytes\n    w = split`{k} wBytes\n\n    \/\/ Steps 2 - 4.\n    s1 = [BitUnpack`{\u03b7, \u03b7} (y@i) | i <- [0..ell-1]]\n    \/\/ Steps 5 - 7.\n    s2 = [BitUnpack`{\u03b7, \u03b7} (z@i) | i <- [0..k-1]]\n    \/\/ Steps 8 - 10.\n    t0 = [BitUnpack`{2^^(d - 1) - 1, 2^^(d - 1)} (w@i) | i <- [0..k-1]]\n\n\/**\n * ```repl\n * :check skDecodeEquivalence\n * ```\n *\/\nskDecodeEquivalence : PrivateKey -> Bit\nproperty skDecodeEquivalence sk = Spec::skDecode sk == skDecode sk\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\nsigEncode : [\u03bb \/ 4]Byte -> [ell]R -> [k]R2 -> Signature\nsigEncode c_til z h = \u03c3 where\n    \/\/ Note that `\u03c3#` indicates the value of `\u03c3` at Step `#`.\n    \/\/ Step 1.\n    \u03c31 = c_til\n    \/\/ Step 2 - 4.\n    \u03c33 = \u03c31 # join [BitPack`{\u03b31 - 1, \u03b31} (z@i) | i <- [0..ell-1]]\n    \/\/ Step 5.\n    \u03c3 = \u03c33 # HintBitPack h\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\nsigDecode : Signature -> ([\u03bb \/ 4]Byte, [ell]R, Option ([k]R2))\nsigDecode \u03c3 = (c_til, z, h) where\n    \/\/ Step 1. We separate into bytes, then further split `x` into its two\n    \/\/ dimensions.\n    (c_til # xBytes # y) = \u03c3\n    x = split`{ell} xBytes\n\n    \/\/ Step 2 - 4.\n    z = [BitUnpack`{\u03b31 - 1, \u03b31} (x@i) | i <- [0..ell-1]]\n    \/\/ Step 5.\n    h = HintBitUnpack y\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\nw1Encode : [k]R -> [32 * k * width ((q - 1) \/ (2 * \u03b32) - 1)]Byte\nw1Encode w1 = w1_til where\n    w1_til = join\n        [SimpleBitPack`{(q - 1) \/ (2 * \u03b32) - 1} (w1@i) | i <- [0..k-1]]\n\n\/**\n * ```repl\n * :check w1EncodeEquivalence\n * ```\n *\/\nw1EncodeEquivalence : [k]R -> Bit\nproperty w1EncodeEquivalence w1 = Spec::w1Encode w1 == w1Encode w1\n\n\/**\n * This is almost identical to `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file but H`{inf} is replaced by H to avoid compilation\n * errors.\n *\/\nSampleInBall : [\u03bb \/ 4]Byte -> R\nSampleInBall \u03c1 = cFinal where\n    \/\/ Step 1.\n    c0 = zero\n    \/\/ Steps 2 - 3.\n    ctx_0 = H \u03c1\n        ((s : [8]Byte) # ctx_1) = ctx_0\n    \/\/ Step 5.\n    h = BytesToBits s\n\n    \/\/ Steps 7 - 10. Uses recursion instead of a loop to sample bytes from the\n    \/\/ hash stream, returning the first one that's in the range `[0, i]`.\n    sample : [inf]Byte -> Byte -> (Byte, [inf]Byte)\n    sample ([j] # ctx) i =\n        if j > i then\n            sample ctx i\n        else (j, ctx)\n\n    \/\/ Steps 6 - 13. Computes the value of `c` and the updated `ctx` at each\n    \/\/ iteration of the loop.\n    cAndCtx = [(c0, ctx_1)] # [(c'', ctx') where\n                        (j, ctx') = sample ctx (fromInteger i)\n            \/\/ Step 11.\n            c' = update c i (c@j)\n            \/\/ Step 12. In Cryptol, we need to manually convert the exponent\n            \/\/ from a `Bit` to a numeric type.\n            hi\u03c4 = if (h @ (i + `\u03c4 - 256)) then 1 else 0 : Integer\n            c'' = update c' j ((-1)^^hi\u03c4)\n\n        | i <- [256 - \u03c4..255]\n        | (c, ctx) <- cAndCtx]\n\n    (cFinal, _) = cAndCtx ! 0\n\n\/**\n * ```repl\n * :set tests=3\n * :check SampleInBallEquivalence\n * ```\n *\/\nSampleInBallEquivalence : [\u03bb \/ 4]Byte -> Bit\nproperty SampleInBallEquivalence \u03c1 = Spec::SampleInBall \u03c1 == SampleInBall \u03c1\n\nRejNTTPoly = Spec::RejNTTPoly\n\nRejBoundedPoly = Spec::RejBoundedPoly\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\nExpandA : [32]Byte -> [k][ell]Tq\nExpandA \u03c1 = A_hat where\n    A_hat = [[RejNTTPoly \u03c1' where\n            \u03c1' = \u03c1 # IntegerToBytes`{1} s # IntegerToBytes`{1} r\n        | s <- [0..ell - 1]]\n        | r <- [0..k - 1]]\n\n\/**\n * ```repl\n * :set tests=3\n * :check ExpandAEquivalence\n * ```\n *\/\nExpandAEquivalence : [32]Byte -> Bit\nproperty ExpandAEquivalence \u03c1 = Spec::ExpandA \u03c1 == ExpandA \u03c1\n\n\/**\n * This is unchanged from `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file.\n *\/\nExpandS : [64]Byte -> ([ell]R, [k]R)\nExpandS \u03c1 = (s1, s2) where\n    s1 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} r) | r <- [0..ell-1]]\n    s2 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} (r + `ell)) | r <- [0..k-1]]\n\n\/**\n * ```repl\n * :set tests=5\n * :check ExpandSEquivalence\n * ```\n *\/\nExpandSEquivalence : [64]Byte -> Bit\nproperty ExpandSEquivalence \u03c1 = Spec::ExpandS \u03c1 == ExpandS \u03c1\n\n\/**\n * This is almost identical to `Spec`; it's duplicated to pull in the optimized\n * dependencies in this file but H`{32 * c} is replaced by H to avoid compilation\n * errors. Moreover, the type of `c` is not used so it's removed.\n *\/\nExpandMask : [64]Byte -> Integer -> [ell]R\nExpandMask \u03c1 \u03bc = y where\n\n    y = [BitUnpack`{\u03b31 - 1, \u03b31} v where\n            \u03c1' = \u03c1 # IntegerToBytes`{2} (\u03bc + r)\n            v = H \u03c1'\n        | r <- [0..ell - 1]]\n\n\/**\n * ```repl\n * :set tests=5\n * :check ExpandMaskEquivalence\n * ```\n *\/\nExpandMaskEquivalence : [64]Byte -> Integer -> Bit\nproperty ExpandMaskEquivalence \u03c1 \u03bc = Spec::ExpandMask \u03c1 \u03bc == ExpandMask \u03c1 \u03bc\n\nPower2Round = Spec::Power2Round\n\nDecompose = Spec::Decompose\n\nHighBits = Spec::HighBits\n\nLowBits = Spec::LowBits\n\nMakeHint = Spec::MakeHint\n\nUseHint = Spec::UseHint\n\nNTT = Spec::NTT\n\nNTTInv = Spec::NTTInv\n\nAddNTT = Spec::AddNTT\n\nMultiplyNTT = Spec::MultiplyNTT\n\nAddVectorNTT = Spec::AddVectorNTT\n\nScalarVectorNTT = Spec::ScalarVectorNTT\n\nMatrixVectorNTT = Spec::MatrixVectorNTT\n\n(\u2218\u2218) : [k][ell]Tq -> [ell]Tq -> [k]Tq\n(\u2218\u2218) M v = [sum [Mij * vj | Mij <- Mi | vj <- v] | Mi <- M]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify that all type constraints and parameter relationships defined in the ML-DSA Parameters module hold correctly. This includes verifying constraints on q, \u03c4, \u03bb, \u03b31, \u03b32, k, ell, \u03b7, and \u03c9 as per the FIPS-204 standard, ensuring that arithmetic and bit-width constraints are satisfied, and that the parameter invariants such as divisibility, power-of-two conditions, and range bounds are enforced."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Asymmetric::Signature::ML_DSA::Parameters where\n    \/**\n     * Modulus defining the ring used throughout the protocol.\n     * [FIPS-204] Section 4, Table 1.\n     *\/\n    type q = 8380417\n\n    \/**\n     * Hamming weight of the mask sampled in signing.\n     *\n     * The spec describes this as \"number of \u00b11s in polynomial `c`\", where `c`\n     * is the verifier's challenge.\n     * [FIPS-204] Section 4, Table 1.\n     *\n     * The type constraints are drawn from [FIPS-204] Section 7.3, Algorithm\n     * 29; the first is implicit in Step 6, and the second is explicit in the\n     * algorithm description.\n     *\/\n    type \u03c4 : #\n    type constraint (0 < \u03c4, \u03c4 <= 64)\n\n    \/**\n     * Collision strength of the commitment hash `c~` component of a signature.\n     * [FIPS-204] Section 4, Table 1.\n     *\n     * The type constraint is drawn from [FIPS-204] Section 7.3, Algorithm 29;\n     * it's implicit that the hash function `H` requires a finite input, so the\n     * length of the input seed, and thus of `\u03bb`, must be finite.\n     *\/\n    type \u03bb : #\n    type constraint (fin \u03bb)\n\n    \/**\n     * Coefficient range of the commitment mask `y` used in signing.\n     * [FIPS-204] Section 4, Table 1.\n     *\n     * The first type constraint, which claims that `\u03b31` must be a power of 2,\n     * is drawn from [FIPS-203] Section 7.2, Algorithm 27.\n     * The second is a true statement (when `\u03b31` is a power of 2, so for all\n     * valid parameter sets for ML-DSA) that is hard to infer. It's stated\n     * explicitly here because the two expressions are used interchangeably in\n     * the spec. Note that `width x = lg2 (x + 1)`:\n     * ```math\n     *    1 + width (\u03b31 - 1) = 1 + lg2 (\u03b31).\n     *    width (\u03b31 - 1 + \u03b31) = lg2 (2 * \u03b31) = 1 + lg2 (\u03b31).\n     * ```\n     *\/\n    type \u03b31 : #\n    type constraint (fin \u03b31, 2 ^^ (lg2 \u03b31) == \u03b31)\n    type constraint (1 + width (\u03b31 - 1) == width (\u03b31 - 1 + \u03b31))\n\n    \/**\n     * Low-order rounding range; this defines how to round the signer's\n     * commitment `w`.\n     * [FIPS-204] Section 4, Table 1.\n     *\n     * The first type constraint is drawn from [FIPS-204] Section 7.4. The\n     * primary constraint we wish to encode is that `2 * \u03b32` divides `q - 1`;\n     * to express this, we must also require that \u03b32 is non-zero.\n     * The second type constraint is drawn from Algorithm 28 -- the type\n     * argument to `SimpleBitPack` must have positive width.\n     *\/\n    type \u03b32 : #\n    type constraint (\u03b32 > 0, (q - 1) % (2 * \u03b32) == 0)\n    type constraint (width ((q - 1) \/ (2 * \u03b32) - 1) > 0)\n\n    \/**\n     * Dimensions of the matrix `A`, which is part of the public key.\n     * [FIPS-204] Section 4, Table 1.\n     *\/\n    type k : #\n    type ell : #\n    type constraint (fin k, fin ell, k > 0, ell > 0)\n\n    \/**\n     * Private key range; the private key is a polynomial whose coefficients\n     * are all in a range defined by \u03b7.\n     * [FIPS-204] Section 4, Table 1.\n     *\n     * The type constraint (that \u03b7 must be in the set {2, 4}) is drawn from\n     * [FIPS-204] Section 7.1, Algorithm 15.\n     *\/\n    type \u03b7 : #\n    type constraint (\u03b7 % 2 == 0, 2 <= \u03b7, \u03b7 <= 4)\n\n    \/**\n     * Maximum Hamming weight for the hint component of a signature.\n     * [FIPS-204] Section 4, Table 1.\n     *\n     * The constraints are drawn from [FIPS-204] Algorithm 21:\n     * - `\u03c9 > 0`: in Step 16, we have to be able to compute `\u03c9 - 1`.\n     * - `width \u03c9 <= 8`: This is an implementation artifact from Step 4. We\n     *   compare `\u03c9` to an element in `y`, which is a byte. Cryptol will\n     *   default to fitting `\u03c9` into in a byte. This is always true with the\n     *   allowable parameter sets. If a new parameter set is released with a\n     *   much larger `\u03c9`, we can modify the implementation to remove this\n     *   constraint without affecting functionality.\n     *\/\n    type \u03c9 : #\n    type constraint (fin \u03c9, \u03c9 > 0, width \u03c9 <= 8)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/UnconstrainedSpec.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the ECDSA signature generation and verification functions defined in the UnconstrainedSpec module. Include properties that check the validity of signatures produced by `sign` and ensure that `verify` accepts valid signatures and rejects invalid ones, adhering to the constraints and behaviors specified in FIPS-186-5 Section 6. Also, specify properties to confirm that the public key derivation from the private key is consistent with the elliptic curve operations."},{"role":"assistant","content":"```cryptol\n\/*\nECDSA as specified in [FIPS-186-5] Section 6.\n\n\u26a0 This implementation is complete except for constraints on the size of the\ninput parameters ([FIPS-186-5] Section 6.1.1)! Using this implementation will\nallow invalid combinations of parameters. Consider using `Specification.cry`\ninstead.\n\nThis implementation omits some parts of the original specification:\n- The spec makes recommendations for domain parameter management which is out\n  of scope for this implementation. (6.1.2)\n- The spec associates an ECDSA key pair `(d, Q)` with a specific set of domain\n  parameters. This implementation does not include any details of generation,\n  management, or association of private and public keys. (6.2)\n- The spec requires that a new secret random number `k` is generated for each\n  digital signature. This implementation does not handle secure generation or\n  handling of the secret random number. \u26a0 \ufe0f\ufe0f\ufe0f\ufe0fWarning \u26a0: incorrect generation or\n  management of `k` can cause catastrophic failures of the signature scheme,\n  including revealing the private key! Implementors must manually verify that\n  their implementations satisfy this component of the spec. (6.3)\n\n\n[FIPS-180-4]: National Institute of Standards and Technology. Secure Hash\n  Standard (SHS). (Department of Commerce, Washington, D.C.), Federal\n  Information Processing Standards Publication (FIPS) NIST FIPS 180-4.\n  August 2015.\n  @see https:\/\/doi.org\/10.6028\/NIST.FIPS.180-4\n[FIPS-186-5]: National Institute of Standards and Technology. Digital\n  Signature Standard (DSS). (Department of Commerce, Washington, D.C.),\n  Federal Information Processing Standards Publication (FIPS) NIST FIPS 186-5.\n  February 2023.\n  @see https:\/\/doi.org\/10.6028\/NIST.FIPS.186-5\n\n@copyright Galois, Inc\n@author Marcella Hastings <marcella@galois.com>\n*\/\n\nmodule Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec where\n\n\/**\n * ECDSA digital signature generation and verification requires domain\n * parameters that are generated in accordance with [FIPS-186-5] Section 6.1.1.\n * The instantiation of this interface must meet those criteria!\n *\/\nimport interface Common::EC::ECInterface as EC\n\n\/**\n * ECDSA digital signature generation and verification requires an approved\n * hash function or XOF (extendable-output function).\n * This implementation currently fixes the hash function to SHA256, as\n * specified in [FIPS-180-4].\n *\/\nimport interface Primitive::Keyless::Hash::HashInterface as Hash\n\n\/**\n * ECDSA signature generation algorithm.\n * [FIPS-186-5] Section 6.4.1\n *\n * This deviates from the original spec in several ways:\n * 1a. The per-message secret number `k` is passed as a parameter instead of\n *    being generated using an approved procedure.\n *    \u26a0\ufe0f Warning \u26a0\ufe0f: This deviation means that adherence to this spec cannot\n *    detect a catastrophic secret-number-reuse implementation mistake!\n *    Implementors must manually verify that secret numbers are chosen\n *    according to an approved procedure; are protected from unauthorized\n *    disclosure and modification; and are not reused over time.\n * 1b. The spec requires that if `r` or `s` are 0 and `k` is not generated\n *    deterministically, then the computation should repeat until a valid `k`\n *    is found. This implementation fails if either value is 0, because Cryptol\n *    cannot produce a new random value for `k`.\n * 2. The spec requires that `k` and its inverse are securely destroyed in\n *    step 10. Cryptol does not have any way to express this. Implementors\n *    must manually verify that they have removed those values from memory.\n * 3. The spec requires the hash function to be passed as an input. In this\n *    implementation, it is fixed to be SHA256 (from the SHA2 family). This is\n *    due to lack of an appropriate hash-function interface, not for any\n *    technical reason. We also introduce the `width` constraint on `m` that\n *    ensures it is short enough to be processable by SHA256.\n * 4. The spec describes the domain parameters as an input to this function.\n *    In this implementation, we encode the domain parameters in the\n *    `ECInterface` included in this module, so they aren't passed explicitly.\n *\n * Other important notes:\n * - The private key `d` passed as input must be generated as specified in\n *   [FIPS-186-5] Section 6.2.1. Implementors must manually verify that this\n *   is the case.\n *\n * Inputs:\n * M : [m]. Bit string `M` to be signed.\n * d : Z n. Private key in the interval [1, n-1].\n * k : Z n. Per-message secret number in the interval [1, n-1].\n *\n * Outputs:\n * (r, s) : A pair of integers, each in the interval [1, n-1].\n *      or failure (`None`) if:\n *      - the inputs `d` and `k` were not in the correct interval;\n *      - the outputs `r` or `s` were 0 for the given inputs;\n *\n * In all inputs and outputs, `n` is the order of the base point `G` for the\n * elliptic curve specified in the `PFEC` interface.\n *\/\nsign : {m} (fin m, width m < Hash::MessageUpperBound) =>\n    [m] -> Z EC::n -> Z EC::n -> Option (Z EC::n, Z EC::n)\nsign M d k = if inputsInRange then maybe_rs else None\n    where\n                inputsInRange = (0 != d) && (0 != k)\n\n        \/\/ Steps 1 - 2.\n        e = hashAndTruncate M\n\n        \/\/ Step 3. k is passed as a parameter because Cryptol cannot generate\n        \/\/ random numbers.\n\n        \/\/ Step 4.\n        \/\/ This uses a Cryptol-native method to compute the multiplicative\n        \/\/ inverse of `k`.\n        k_inv = recip k\n\n        \/\/ Step 5.\n        R = EC::scmul (fromZ k) EC::G\n\n        \/\/ Step 6 (the case expression).\n        \/\/ This would fail (returns `None`) if `R` is the point at\n        \/\/ infinity. In fact, that case is impossible because `[k]G = 0` if and\n        \/\/ only if `k = n`, which can't happen by definition.\n        maybe_rs = case EC::xCoord R of\n            \/\/ Step 11.\n            \/\/ This fails (returns `None`) if `r` or `s` are invalid.\n            Some xR -> if (r != 0) && (s != 0) then Some (r, s) else None\n                where\n                    \/\/ Step 7.\n                    \/\/ Cryptol's `fromZ` method matches [SP-800-186] Appendix F.1.\n                    r1 = fromZ xR\n                    \/\/ Step 8.\n                    r = fromInteger r1\n                    \/\/ Step 9. The `mod n` is implicit here because these are\n                    \/\/ all of type `Z n`.\n                    s = k_inv * (e + r * d)\n\n            None -> None \/\/ Impossible!\n\n\/**\n * ECDSA signature verification algorithm.\n * [FIPS-186-5] Section 6.4.2.\n *\n * Requirements:\n * - The public key `Q` passed as input must be generated as specified in\n *   [FIPS-186-5] Section 6.2.1. Implementors must manually verify that this\n *   is the case.\n *\n * Inputs:\n * M : [m]. Message `M`.\n * (r, s) : (Z n, Z n). A signature.\n * Q : Point. Purported signature verification key.\n *\n * Outputs:\n * Accept (True) or reject (False) the signature over `M` as originating from\n * the owner of public key `Q`.\n *\n * In all inputs and outputs, `n` is the order of the base point `G` for the\n * elliptic curve specified in the `PFEC` interface.\n *\/\nverify : {m} (fin m, width m < Hash::MessageUpperBound) =>\n    [m] -> (Z EC::n, Z EC::n) -> EC::Point -> Bool\nverify M (r, s) Q = inputsInRange && rMatches\n    where\n        \/\/ Step 1.\n        inputsInRange = (0 != r) && (0 != s)\n\n                e = hashAndTruncate M\n\n        \/\/ Step 4.\n        \/\/ This uses a Cryptol-native method to compute the multiplicative\n        \/\/ inverse of `s`.\n        s_inv = recip s\n\n        \/\/ Step 5.\n        u = e * s_inv\n        v = r * s_inv\n\n        \/\/ Step 6.\n        R_1 = EC::twin_mul (fromZ u) EC::G (fromZ v) Q\n\n        \/\/ Step 7. `xCoord` retrieves the x-coordinate of `R_1`.\n        rMatches = case EC::xCoord R_1 of\n            \/\/ Step 9.\n            Some xR -> r1 == r where\n                \/\/ Step 8.\n                \/\/ This converts to an integer mod `n`.\n                r1 = fromInteger (fromZ xR)\n            None -> False\n\n\/**\n * Evaluates the public key given a private key `d`.\n *\n * This implementation does not describe the method for generating the private\n * key `d`. However, in [FIPS-186-5] Appendix A.2, given a valid private key\n * candidate `d`, Section A.2.1 Process Step 5 and Section A.2.2 Process Step 5\n * define how to evaluate the public key `Q`.\n *\n *\/\npublicKey : Z EC::n -> EC::Point\npublicKey d = EC::scmul (fromZ d) EC::G\n\n\/**\n * A signature over a message created with a private key must verify over\n * the corresponding public key.\n * [FIPS-186-5] Section 3.3.\n * ```repl\n * :check signAndVerifyIsCorrect`{64}\n * ```\n *\/\nsignAndVerifyIsCorrect : {m} (fin m, width m < Hash::MessageUpperBound) =>\n    [m] -> Z EC::n -> Z EC::n -> Bool\nproperty signAndVerifyIsCorrect M d k = verification\n    where\n        Q = publicKey d\n        signature = sign M d k\n        verification = case signature of\n            Some (r, s) -> verify M (r, s) Q\n            None -> False\n\nprivate\n    \/**\n     * Hash a message and convert it to an integer mod `n`.\n     *\/\n    hashAndTruncate : {m} (fin m, width m < Hash::MessageUpperBound) => [m] -> Z EC::n\n    hashAndTruncate M = e\n        where\n            H = Hash::hash M\n            e' = take`{min (width EC::n) Hash::DigestLength} H\n            \/\/ Cryptol's default bitstring-to-integer `toInteger` conversion\n            \/\/ matches the routine specified in [FIPS-186-5] Appendix B.2.1.\n            \/\/ We further convert it to an element in `Z n` to support the modular\n            \/\/ operations later in the protocol.\n            e = fromInteger (toInteger e')\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and consistency of the XMSS signature scheme implementation in the provided specification file. Include properties that check the correctness of key generation, signing, and verification functions, ensuring that signatures generated by `sign` verify successfully with `verify`. Also, write properties to test the correctness of helper functions such as `ltree`, `treeHash`, `buildAuth`, and `rootFromSig` against their expected behaviors as described in RFC-8391. Ensure the properties cover edge cases and maintain the stateful constraints of XMSS keys."},{"role":"assistant","content":"```cryptol\n\/**\n * XMSS: eXtended Merkle Signature Scheme.\n *\n * XMSS is a hash-based stateful digital signature scheme defined in\n * [RFC-8391]. It builds on top of the WOTS+ one-time signature scheme,\n * also defined in [RFC-8391]. XMSS (and WOTS+) provide digital signatures\n * under the security of some underlying cryptographic hash function, and\n * require no additional conjectured hardness assumption. In addition,\n * XMSS (and WOTS+) are side-channel resistant and withstand existing\n * quantum attacks.\n *\n * On the other hand, XMSS is a _stateful_ signature scheme, and thus has\n * an upper bound on the number of signatures able to be produced by a given\n * secret key. In addition, one must be careful not to reuse the secret key\n * state across multiple signing operations.\n *\n * References:\n * [RFC-8391]: Andreas Huelsing, Denis Butin, Stefan-Lukas Gazdag, Joost\n *     Rijneveld, and Aziz Mohaisen. XMSS: eXtended Merkle Signature Scheme.\n *     Internet Requests for Comments (RFC) 8391. May 2018.\n *     @see https:\/\/datatracker.ietf.org\/doc\/rfc8391\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n * @author Alex J Malozemoff <amaloz@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::XMSS::Specification where\n\nimport interface Primitive::Asymmetric::Signature::XMSS::Parameters\nimport interface Primitive::Asymmetric::Signature::WOTS::Interface as WOTS\n\ninterface constraint (n == WOTS::n)\n\n\/**\n * Types defined for WOTS+ that are relevant to XMSS.\n *\/\ntype Address = WOTS::Address\ntype Byte = WOTS::Byte\ntype Seed = WOTS::Seed\n\nprivate\n    \/**\n     * Set the `type` word (in the 4th position) in an `Address`.\n     * This setter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    setType : Address -> Word -> Address\n    setType address value = take`{3 * 4} address # split value # drop`{4 * 4} address\n\n\/**\n * A word is a 32-bit sequence used to define hash addresses.\n * [RFC-8391] Section 2.5.\n *\/\ntype Word = [32]\n\n\/**\n * Address scheme for randomizing hash function calls in the L-tree.\n *\n * The address breaks down 7 components, each 1 word long unless specified.\n * 1. Layer address\n * 2-3. Tree address (2 Words)\n * 4. Type (fixed at 1)\n * 5. L-tree address\n * 6. Tree height\n * 7. Tree index\n * 8. keyAndMask\n *\n * Note that this isn't defined in terms of the `Word` type because it's\n * operated on by things that require arrays of bytes.\n *\n * [RFC-8391] Section 2.5.\n *\/\ntype LTreeAddress = [8 * 4]Byte\n\nprivate\n    \/**\n     * Set the `L-tree address` word (the 5th position) in a `LTreeAddress`.\n     * This setter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    setLTreeAddress : LTreeAddress -> Word -> LTreeAddress\n    setLTreeAddress address value = take`{4 * 4} address # (split value) # drop`{5 * 4} address\n\n    \/**\n     * Set the `tree height` word (in the 6th position) in an `LTreeAddress`.\n     * This setter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    setTreeHeight : LTreeAddress -> Word -> LTreeAddress\n    setTreeHeight address value = take`{5 * 4} address # (split value) # drop`{6 * 4} address\n\n    \/**\n     * Get the `tree height` word (in the 6th position) in an `LTreeAddress`.\n     * This getter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    getTreeHeight : LTreeAddress -> Word\n    getTreeHeight address = value where\n        value = join (take`{1 * 4} (drop`{5 * 4} address))\n\n    \/**\n     * Test `setTreeHeight` and `getTreeHeight`.\n     * ```repl\n     * :prove test_tree_height_getter_setter\n     * ```\n     *\/\n    property test_tree_height_getter_setter ADRS i = i' == i where\n        ADRS' = setTreeHeight ADRS i\n        i' = getTreeHeight ADRS'\n\n    \/**\n     * Set the `tree index` word (in the 7th position) in an `LTreeAddress`.\n     * This setter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    setTreeIndex : LTreeAddress -> Word -> LTreeAddress\n    setTreeIndex address value = take`{6 * 4} address # (split value) # drop`{7 * 4} address\n\n    \/**\n     * Get the `tree index` word (in the 7th position) in an `LTreeAddress`.\n     * This getter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    getTreeIndex : LTreeAddress -> Word\n    getTreeIndex address = join (take`{1 * 4} (drop`{6 * 4} address))\n\n    \/**\n     * Test `setTreeIndex` and `getTreeIndex`.\n     * ```repl\n     * :prove test_tree_index_getter_setter\n     * ```\n     *\/\n    property test_tree_index_getter_setter ADRS i = i' == i where\n        ADRS' = setTreeIndex ADRS i\n        i' = getTreeIndex ADRS'\n\n    \/**\n    * Set the `keyAndMask` word (the 8th position) in an `LTreeAddress`.\n    * This setter is defined implicitly in the spec.\n    *\n    * [RFC-8391] Section 2.7.\n    *\/\n    setKeyAndMask : LTreeAddress -> Word -> LTreeAddress\n    setKeyAndMask address value = take`{7 * 4} address # split value\n\n\/**\n * Address scheme for the main tree hash addresses.\n *\n * The address breaks down 7 components, each 1 word long unless specified.\n * 1. Layer address\n * 2-3. Tree address (2 Words)\n * 4. Type (fixed at 2)\n * 5. Padding (fixed at 0)\n * 6. Tree height\n * 7. Tree index\n * 8. keyAndMask\n *\n * Note that this isn't defined in terms of the `Word` type because it's\n * operated on by things that require arrays of bytes.\n *\n * [RFC-8391] Section 2.5.\n *\/\ntype HashTreeAddress = [8 * 4]Byte\n\n\/**\n * An XMSS private key.\n *\n * An XMSS private key contains an algorithm OID [Errata-8424], `2^^h` WOTS+\n * private keys, the leaf index of the next WOTS+ private key that has not yet\n * been used, an `n`-byte key to generate pseudorandom values for randomized\n * message hashing, the `n`-byte root node of the tree and `SEED`, the n-byte\n * public seed used to pseudorandomly generate bitmasks and hash function keys.\n *\n * [RFC-8391] Section 4.1.3.\n * [Errata-8424] @see https:\/\/www.rfc-editor.org\/errata\/eid8424\n *\/\ntype PrivateKey = {\n    oid: [32],\n    wots_sks: [2^^h]WOTS::PrivateKey,\n    idx: Word,\n    SK_PRF: [n]Byte,\n    root: [n]Byte,\n    seed: Seed\n}\n\nprivate\n    \/**\n     * Set the index in a private key.\n     * This setter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    setIdx : PrivateKey -> Word -> PrivateKey\n    setIdx SK idx = { SK | idx = idx }\n\n    \/**\n     * Take as input an XMSS private key `SK` and an integer `i` and output the\n     * `i`th WOTS+ private key.\n     *\n     * [RFC-8391] Section 4.1.3.\n     *\/\n    getWOTS_SK : PrivateKey -> Word -> WOTS::PrivateKey\n    getWOTS_SK SK i = SK.wots_sks @ i\n\n\/**\n * An XMSS public key.\n *\n * The XMSS public key consists of the root of the binary hash tree and the\n * seed `SEED`, both also stored in the private key. It also includes an\n * object identifier `oid` to identify the specific XMSS instantiation.\n *\n * [RFC-8391] Section 4.1.7.\n *\/\ntype PublicKey = {\n    oid: [32],\n    root: [n]Byte,\n    seed: Seed\n}\n\n\/**\n * An XMSS signature.\n *\n * An XMSS signature is a `(4 + n + (len + h) * n)`-byte string consisting\n * of:\n * -  the index `idx_sig` of the used WOTS+ key pair (4 bytes),\n * -  a byte string `r` used for randomized message hashing (n bytes),\n * -  a WOTS+ signature `sig_ots` (len * n bytes), and\n * -  the so-called authentication path `auth` for the leaf associated\n *    with the used WOTS+ key pair (h * n bytes).\n *\n * [RFC-8391] Section 4.1.8.\n *\/\ntype Signature = {\n    idx_sig: Word,\n    r: [n]Byte,\n    sig_ots: WOTS::Signature,\n    auth: [h][n]Byte\n}\n\nprivate\n    \/**\n     * Set the `OTS address` word (the 5th position) in a `WOTS::OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     *\n     * [RFC-8391] Section 2.7.\n     *\/\n    setOTSAddress : WOTS::OTSHashAddress -> Word -> WOTS::OTSHashAddress\n    setOTSAddress address value = take`{4 * 4} address # (split value) # drop`{5 * 4} address\n\n    \/**\n     * `RAND_HASH` - Randomized tree hashing.\n     *\n     * `RAND_HASH` takes as input two n-byte values `LEFT` and `RIGHT` that\n     * represent the left and the right halves of the hash function input, the\n     * seed `SEED` used as key for `PRF`, and the address `ADRS` of this hash\n     * function call.  `RAND_HASH` first uses `PRF` with `SEED` and `ADRS` to\n     * generate a key `KEY` and `n`-byte bitmasks `BM_0`, `BM_1`.  Then, it\n     * returns the randomized hash `H(KEY, (LEFT XOR BM_0) || (RIGHT XOR\n     * BM_1))`.\n     *\n     *   Input:  n-byte value LEFT, n-byte value RIGHT, seed SEED,\n     *           address ADRS\n     *   Output: n-byte randomized hash\n     *\n     *   ADRS.setKeyAndMask(0);\n     *   KEY = PRF(SEED, ADRS);\n     *   ADRS.setKeyAndMask(1);\n     *   BM_0 = PRF(SEED, ADRS);\n     *   ADRS.setKeyAndMask(2);\n     *   BM_1 = PRF(SEED, ADRS);\n     *\n     *   return H(KEY, (LEFT XOR BM_0) || (RIGHT XOR BM_1));\n     *\n     * [RFC-8391] Section 4.1.4, Algorithm 7.\n     *\/\n    RAND_HASH : [n]Byte -> [n]Byte -> Seed -> LTreeAddress -> [n]Byte\n    RAND_HASH LEFT RIGHT SEED ADRS = hash where\n        ADRS' = setKeyAndMask ADRS 0\n        KEY = WOTS::PRF SEED ADRS'\n        ADRS'' = setKeyAndMask ADRS' 1\n        BM_0 = WOTS::PRF SEED ADRS''\n        ADRS''' = setKeyAndMask ADRS'' 2\n        BM_1 = WOTS::PRF SEED ADRS'''\n        hash = H KEY ((LEFT ^ BM_0) # (RIGHT ^ BM_1))\n\n    \/**\n     * Helper function for `ltree` for computing `pk`.\n     *\n     * This corresponds to the `for`-loop in Algorithm 8:\n     *\n     *   for ( i = 0; i < floor(len' \/ 2); i++ ) {\n     *     ADRS.setTreeIndex(i);\n     *     pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n     *   }\n     *\n     * [RFC-8391] Section 4.1.5, Algorithm 8.\n     *\/\n    ltree_pk : {len', half_floor} (\n            fin len',\n            \/*\n             * We iterate over `i \u2208 [0..floor(len' \/ 2) - 1]`, so we need `len'\n             * > 1`.\n             *\/\n            len' > 1,\n            half_floor == len' \/ 2, \/\/ Equivalent to `floor(len' \/ 2)`\n            \/*\n             * The `tree index` is a word in `LTreeAddress`, so since we call\n             * `setTreeIndex` on `i \u2208 [0 .. half_floor - 1]` we need that the\n             * width of `half_floor - 1` fits in a word.\n             *\/\n            width (half_floor - 1) <= 32\n\n        ) => [len'][n]Byte -> Seed -> LTreeAddress -> [half_floor][n]Byte\n    ltree_pk pk SEED ADRS = pk' where\n        pk' = [ pk_i where\n                ADRS' = setTreeIndex ADRS i\n                pk_i = RAND_HASH (pk @ (2 * i)) (pk @ (2 * i + 1)) SEED ADRS'\n              | i <- [0..half_floor - 1]\n              ]\n\n    \/**\n     * Recursive version of `ltree`.\n     *\n     * This corresponds to the `while`-loop in Algorithm 8:\n     *\n     *   while ( len' > 1 ) {\n     *     \/\/ This `for`-loop is implemented by `ltree_pk`.\n     *     for ( i = 0; i < floor(len' \/ 2); i++ ) {\n     *       ADRS.setTreeIndex(i);\n     *       pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n     *     }\n     *     if ( len' % 2 == 1 ) {\n     *       pk[floor(len' \/ 2)] = pk[len' - 1];\n     *     }\n     *    len' = ceil(len' \/ 2);\n     *    ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     *  }\n     *\n     * [RFC-8391] Section 4.1.5, Algorithm 8.\n     *\/\n    ltree' : {len', half_floor, half_ceil} (\n            fin len',\n            len' >= 1,\n            half_floor == len' \/ 2, \/\/ Equivalent to `floor(len' \/ 2)`\n            width half_floor <= 32,\n            half_ceil == len' \/^ 2  \/\/ Equivalent to `ceil(len' \/ 2)`\n        ) => [len'][n]Byte -> Seed -> LTreeAddress -> [n]Byte\n    ltree' pk SEED ADRS\n        \/*\n         * The base case. Return the only value in `pk`.\n         *\/\n        | len' == 1 => pk @ 0\n        \/*\n         * The `while`-loop condition for when `len' % 2 == 0`.\n         *\n         * In this case, we do not need to append `pk[len' - 1]` to the end of\n         * `pk`.\n         *\/\n        | (len' > 1, len' % 2 == 0) => result where\n            pk' = ltree_pk pk SEED ADRS\n            ADRS' = setTreeHeight ADRS ((getTreeHeight ADRS) + 1)\n            result = ltree'`{half_ceil} pk' SEED ADRS'\n        \/*\n         * The `while`-loop condition for when `len' % 2 == 1`.\n         *\n         * In this case, we need to append `pk[len' - 1]` to the end of `pk`.\n         *\/\n        | (len' > 1, len' % 2 == 1) => result where\n            pk' = (ltree_pk pk SEED ADRS) # split (pk ! 0)\n            ADRS' = setTreeHeight ADRS ((getTreeHeight ADRS) + 1)\n            result = ltree'`{half_ceil} pk' SEED ADRS'\n\n    \/**\n     * `ltree` - unbalanced binary hash tree.\n     *\n     * To compute the leaves of the binary hash tree, a so-called L-tree is\n     * used.  An L-tree is an unbalanced binary hash tree, distinct but similar\n     * to the main XMSS binary hash tree.  The algorithm `ltree` takes as input\n     * a WOTS+ public key pk and compresses it to a single n-byte value pk[0].\n     * It also takes as input an L-tree address ADRS that encodes the address of\n     * the L-tree and the seed SEED.\n     *\n     * Note: We implement `ltree` using recursion instead of the `while`-loop as\n     * specified in Algorithm 8.\n     *\n     *   Input: WOTS+ public key pk, seed SEED, address ADRS (Note: [Errata-5572])\n     *   Output: n-byte compressed public key value pk[0]\n     *\n     *   unsigned int len' = len;\n     *   ADRS.setTreeHeight(0);\n     *   while ( len' > 1 ) {\n     *     for ( i = 0; i < floor(len' \/ 2); i++ ) {\n     *       ADRS.setTreeIndex(i);\n     *       pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n     *     }\n     *     if ( len' % 2 == 1 ) {\n     *       pk[floor(len' \/ 2)] = pk[len' - 1];\n     *     }\n     *     len' = ceil(len' \/ 2);\n     *     ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     *   }\n     *   return pk[0];\n     *\n     * [RFC-8391] Section 4.1.5, Algorithm 8.\n     * [Errata-5572] @see https:     *\/\n    ltree : WOTS::PublicKey -> Seed -> LTreeAddress -> [n]Byte\n    ltree pk SEED ADRS = result where\n        ADRS' = setTreeHeight ADRS 0\n        result = ltree'`{WOTS::len} pk SEED ADRS'\n\n    \/**\n     * The \"base case\" for `treeHash`.\n     *\n     * This computes the nodes for all entries in the tree corresponding to the\n     * level associated with the start index `s`. That is, if `s` corresponds to\n     * the leftmost leaf of a sub-tree, `treeHash_base` returns a list of all\n     * the nodes (and corresponding addresses) at the same level as `s`.\n     *\n     * This roughly corresponds to the `for`-loop in `treeHash`.\n     *\n     * [RFC-8391] Section 4.1.6, Algorithm 9.\n     *\/\n    treeHash_base : {t} (\n            \/\/ The target node height.\n            fin t,\n            \/\/ The target height must be less than or equal the height of the\n            \/\/ XMSS tree itself.\n            t <= h\n        ) => PrivateKey -> Word -> Address -> [2^^t]([n]Byte, Address)\n    treeHash_base SK s ADRS = if s % (2^^`t) != 0\n        then error \"Invalid `s`: `s % (1 << t) == 0` must hold\"\n        else base where\n            SEED = SK.seed\n            base = [ (node, ADRS''') where\n                     ADRS' = setOTSAddress (setType ADRS 0) (s + i)\n                     pk = WOTS::genPK (getWOTS_SK SK (s + i)) SEED ADRS'\n                     ADRS'' = setLTreeAddress (setType ADRS' 1) (s + i)\n                     node = ltree pk SEED ADRS''\n                     ADRS''' = setTreeIndex (setTreeHeight (setType ADRS'' 2) 0) (i + s)\n                   | i <- [0..2^^t - 1]\n                   ]\n\n    \/**\n     * The \"induction step\" for `treeHash`.\n     *\n     * This takes a list of `2^^t` elements and combines them to produce a\n     * single element by pairwise hashing elements using `RAND_HASH`.\n     *\n     * This roughly corresponds to the `while`-loop in `treeHash`.\n     *\n     * [RFC-8391] Section 4.1.6, Algorithm 9.\n     *\/\n    treeHash_combine : {t} (\n            fin t\n        ) => [2^^t]([n]Byte, Address) -> Seed -> ([n]Byte, Address)\n    treeHash_combine list SEED\n        | t == 0 => list @ 0\n        | t >= 1 => treeHash_combine list' SEED where\n            list' = [ (node, ADRS') where\n                      ADRS = setTreeIndex a.1 ((getTreeIndex b.1 - 1) \/ 2)\n                      node = RAND_HASH a.0 b.0 SEED ADRS\n                      ADRS' = setTreeHeight ADRS (getTreeHeight ADRS + 1)\n                    | [a, b] <- groupBy`{2} list\n                    ]\n\n    \/**\n     * The `treeHash` algorithm.\n     *\n     * This implementation does not closely mimic the algorithm in [RFC-8391].\n     * That algorithm utilizes a stack which is difficult to implement in\n     * Cryptol. Instead, we implement `treeHash` \"level-by-level\". To explain\n     * this, we first step back and explain the goal of `treeHash`.\n     *\n     * At a high level, `treeHash` takes a leftmost leaf of a sub-tree of height\n     * `t`, and computes the root node of that sub-tree. This can be done in two\n     * ways, which essentially boils down to a breadth-first versus depth-first\n     * approach. The breadth-first way is to first compute all the nodes at the\n     * same level as the leftmost leaf, use those nodes to compute the parent\n     * nodes at the next level, etc., until the root is reached. The depth-first\n     * way is to use a stack to store nodes as they are computed so we can\n     * continually complete sub-trees as we process all the nodes on the same\n     * level as `s`.\n     *\n     * The `treeHash` algorithm in [RFC-8391] does the computation in a\n     * depth-first manner, using a stack to store state. In this implementation,\n     * we use the breadth-first approach.\n     *\n     *   Input: XMSS private key SK, start index s, target node height t,\n     *          address ADRS\n     *   Output: n-byte root node - top node on Stack\n     *\n     *   if( s % (1 << t) != 0 ) return -1;\n     *   for ( i = 0; i < 2^t; i++ ) {\n     *     SEED = getSEED(SK);\n     *     ADRS.setType(0);   \/\/ Type = OTS hash address\n     *     ADRS.setOTSAddress(s + i);\n     *     pk = WOTS_genPK (getWOTS_SK(SK, s + i), SEED, ADRS);\n     *     ADRS.setType(1);   \/\/ Type = L-tree address\n     *     ADRS.setLTreeAddress(s + i);\n     *     node = ltree(pk, SEED, ADRS);\n     *     ADRS.setType(2);   \/\/ Type = hash tree address\n     *     ADRS.setTreeHeight(0);\n     *     ADRS.setTreeIndex(i + s);\n     *     while ( Top node on Stack has same height t' as node ) {\n     *        ADRS.setTreeIndex((ADRS.getTreeIndex() - 1) \/ 2);\n     *        node = RAND_HASH(Stack.pop(), node, SEED, ADRS);\n     *        ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     *     }\n     *     Stack.push(node);\n     *   }\n     *   return Stack.pop();\n     *\n     * [RFC-8391] Section 4.1.6, Algorithm 9.\n     *\/\n    treeHash : {t} (\n            \/\/ The target node height.\n            fin t,\n            \/\/ The target height must be less than or equal the height of the\n            \/\/ XMSS tree itself.\n            t <= h\n        ) => PrivateKey -> Word -> Address -> [n]Byte\n    treeHash SK s ADRS = if s % (2^^`t) != 0\n        then error \"Invalid `s`: `s % (1 << t) == 0` must hold\"\n        else node.0 where\n            list = treeHash_base`{t} SK s ADRS\n            node = treeHash_combine list SK.seed\n\n\/**\n * `keyGen` - Generate an XMSS key pair.\n *\n * This differs from the algorithm in [RFC-8391] in several ways.\n *\n * - We do not do any randomness generation, but rather require all random\n *   values to be inputs to key generation. This includes the 2^^h WOTS+\n *   private keys `wots_sks`, the secret key to the PRF `SK_PRF`, and the\n *   seed `SEED`.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: To ensure security, XMSS requires that the WOTS+ private\n * keys, PRF secret key, and seed are generated uniformly at random. This\n * specification does not verify the generation of those values;\n * implementors must manually verify that the values are chosen\n * appropriately.\n *\n *   Input: No input\n *   Output: XMSS private key SK, XMSS public key PK\n *\n *   \/\/ Example initialization for SK-specific contents\n *   idx = 0;\n *   for ( i = 0; i < 2^h; i++ ) {\n *     wots_sk[i] = WOTS_genSK();\n *   }\n *   initialize SK_PRF with a uniformly random n-byte string;\n *   setSK_PRF(SK, SK_PRF);\n *\n *   \/\/ Initialization for common contents\n *   initialize SEED with a uniformly random n-byte string;\n *   setSEED(SK, SEED);\n *   setWOTS_SK(SK, wots_sk));\n *   ADRS = toByte(0, 32);\n *   root = treeHash(SK, 0, h, ADRS);\n *\n *   SK = idx || wots_sk || SK_PRF || root || SEED;\n *   PK = OID || root || SEED;\n *   return (SK || PK);\n *\n * [RFC-8391] Section 4.1.7, Algorithm 10 (called `XMSS_keyGen` in the\n * spec).\n *\/\nkeyGen : [2^^h]WOTS::PrivateKey -> [n]Byte -> Seed -> (PrivateKey, PublicKey)\nkeyGen wots_sks SK_PRF SEED = (SK, PK) where\n    SK_no_root = { oid = oid, idx = 0 : Word, wots_sks = wots_sks, SK_PRF = SK_PRF, root = zero : [n]Byte, seed = SEED }\n    ADRS = zero \/\/ Equivalent to `WOTS::toByte`{32} 0`.\n    root = treeHash`{h} SK_no_root 0 ADRS\n    SK = { SK_no_root | root = root }\n    PK = { oid = oid, root = root, seed = SEED }\n\nprivate\n    \/**\n     * Helper function for `buildAuth`.\n     *\n     * This computes the `j`th entry in the `auth` list, corresponding to the\n     * body of the `for`-loop in the algorithm in Section 4.1.9:\n     *\n     *   k = floor(i \/ (2^j)) XOR 1;\n     *   auth[j] = treeHash(SK, k * 2^j, j, ADRS);\n     *\n     * [RFC-8391] Section 4.1.9.\n     *\/\n    buildAuth_j : {j} (\n            fin j,\n            \/\/ The `for`-loop body is over values `j \u2208 [0..h-1]`.\n            j >= 0,\n            j <= h - 1\n        ) => PrivateKey -> Word -> Address -> [n]Byte\n    buildAuth_j SK i ADRS = auth_j where\n        k = i \/ 2^^`j ^ 1 \/\/ Equivalent to `floor(i \/ (2^j)) XOR 1`\n        auth_j = treeHash`{j} SK (k * 2^^`j) ADRS\n\n    \/**\n     * Recursive version of `buildAuth`.\n     *\n     * This corresponds to the `for`-loop in the algorithm in Section 4.1.9:\n     *\n     *   for ( j = 0; j < h; j++ ) {\n     *     k = floor(i \/ (2^j)) XOR 1;\n     *     auth[j] = treeHash(SK, k * 2^j, j, ADRS);\n     *   }\n     *\n     * [RFC-8391] Section 4.1.9.\n     *\/\n    buildAuth' : {j} (\n            fin j,\n            j < h\n        ) => PrivateKey -> Word -> Address -> [j + 1][n]Byte\n    buildAuth' SK i ADRS\n        | j == 0 => [ buildAuth_j`{0} SK i ADRS ]\n        | j > 0  => list # [ buildAuth_j`{j} SK i ADRS ] where\n            list = buildAuth'`{j - 1} SK i ADRS\n\n    \/**\n     * `buildAuth` - Compute the authentication path for the i^th WOTS+ key\n     * pair.\n     *\n     * Note: We implement `buildAuth` using recursion instead of the `for`-loop.\n     *\n     *   Input: XMSS private key SK, WOTS+ key pair index i, ADRS\n     *   Output: Authentication path auth\n     *\n     *   for ( j = 0; j < h; j++ ) {\n     *     k = floor(i \/ (2^j)) XOR 1;\n     *     auth[j] = treeHash(SK, k * 2^j, j, ADRS);\n     *   }\n     *\n     * [RFC-8391] Section 4.1.9.\n     *\/\n    buildAuth : PrivateKey -> Word -> Address -> [h][n]Byte\n    buildAuth SK i ADRS = buildAuth'`{h - 1} SK i ADRS\n\n    \/**\n     * `treeSig` - Generate a WOTS+ signature on a message with corresponding\n     * authentication path.\n     *\n     *   Input: n-byte message M', XMSS private key SK,\n     *          signature index idx_sig, ADRS\n     *   Output: Concatenation of WOTS+ signature sig_ots and\n     *           authentication path auth\n     *\n     *   auth = buildAuth(SK, idx_sig, ADRS);\n     *   ADRS.setType(0);   \/\/ Type = OTS hash address\n     *   ADRS.setOTSAddress(idx_sig);\n     *   sig_ots = WOTS_sign(getWOTS_SK(SK, idx_sig),\n     *                       M', getSEED(SK), ADRS);\n     *   Sig = sig_ots || auth;\n     *   return Sig;\n     *\n     * [RFC-8391] Section 4.1.9, Algorithm 11.\n     *\/\n    treeSig : [n]Byte -> PrivateKey -> Word -> Address -> (WOTS::Signature, [h][n]Byte)\n    treeSig M' SK idx_sig ADRS = (sig_ots, auth) where\n        auth = buildAuth SK idx_sig ADRS\n        ADRS' = setOTSAddress (setType ADRS 0) idx_sig\n        \/\/ NOTE: The spec calls `WOTS::sign` with the wrong parameter order. [Errata-8383].\n        sig_ots = WOTS::sign M' (getWOTS_SK SK idx_sig) ADRS' SK.seed\n\n\/**\n * `sign` - Generate an XMSS signature and update the XMSS private key.\n *\n *   Input: Message M, XMSS private key SK\n *   Output: Updated SK, XMSS signature Sig\n *\n *   idx_sig = getIdx(SK);\n *   setIdx(SK, idx_sig + 1);\n *   ADRS = toByte(0, 32);\n *   byte[n] r = PRF(getSK_PRF(SK), toByte(idx_sig, 32));\n *   byte[n] M' = H_msg(r || getRoot(SK) || (toByte(idx_sig, n)), M);\n *   Sig = idx_sig || r || treeSig(M', SK, idx_sig, ADRS);\n *   return (SK || Sig);\n *\n * Note: We index into the `PrivateKey` type rather than using `getIdx`,\n * `getSK_PRF`, and `getRoot`.\n *\n * [RFC-8391] Section 4.1.9, Algorithm 12 (called `XMSS_sign` in the spec).\n *\/\nsign : {m} (\n        fin m,\n        width (PaddingWidth + 8 * m) < MessageUpperBound\n    ) => [m]Byte -> PrivateKey -> (PrivateKey, Signature)\nsign M SK = (SK', Sig) where\n    idx_sig = SK.idx\n    SK' = setIdx SK (idx_sig + 1)\n    ADRS = zero : Address \/\/ Equivalent to `WOTS::toByte`{32} 0`.\n    r = WOTS::PRF SK.SK_PRF (WOTS::toByte`{32} idx_sig)\n    M' = H_msg (r # SK.root # WOTS::toByte`{n} idx_sig) M\n    (sig_ots, auth) = treeSig M' SK idx_sig ADRS\n    Sig = { idx_sig = idx_sig, r = r, sig_ots = sig_ots, auth = auth }\n\n\/**\n * `rootFromSig` - Compute a root node from a tree signature.\n *\n *   Input: index idx_sig, WOTS+ signature sig_ots, authentication path\n *          auth, n-byte message M', seed SEED, address ADRS\n *   Output: n-byte root value node[0]\n *\n *   ADRS.setType(0);   \/\/ Type = OTS hash address\n *   ADRS.setOTSAddress(idx_sig);\n *   pk_ots = WOTS_pkFromSig(sig_ots, M', SEED, ADRS);\n *   ADRS.setType(1);   \/\/ Type = L-tree address\n *   ADRS.setLTreeAddress(idx_sig);\n *   byte[n][2] node;\n *   node[0] = ltree(pk_ots, SEED, ADRS);\n *   ADRS.setType(2);   \/\/ Type = hash tree address\n *   ADRS.setTreeIndex(idx_sig);\n *   for ( k = 0; k < h; k++ ) {\n *     ADRS.setTreeHeight(k);\n *     if ( (floor(idx_sig \/ (2^k)) % 2) == 0 ) {\n *       ADRS.setTreeIndex(ADRS.getTreeIndex() \/ 2);\n *       node[1] = RAND_HASH(node[0], auth[k], SEED, ADRS);\n *     } else {\n *       ADRS.setTreeIndex((ADRS.getTreeIndex() - 1) \/ 2);\n *       node[1] = RAND_HASH(auth[k], node[0], SEED, ADRS);\n *     }\n *     node[0] = node[1];\n *   }\n *   return node[0];\n *\n * [RFC-8391] Section 4.1.10, Algorithm 13 (called `XMSS_rootFromSig` in the\n * spec).\n *\/\nrootFromSig : Word -> WOTS::Signature -> [h][n]Byte -> [n]Byte -> Seed -> Address -> [n]Byte\nrootFromSig idx_sig sig_ots auth M' SEED ADRS = node_0' where\n    ADRS' = setOTSAddress (setType ADRS 0) idx_sig\n    \/\/ NOTE: The spec calls `WOTS_pkFromSig` with the wrong parameter order. [Errata-8396].\n    pk_ots = WOTS::pkFromSig M' sig_ots ADRS' SEED\n    ADRS'' = setLTreeAddress (setType ADRS' 1) idx_sig\n    node_0_initial = ltree pk_ots SEED ADRS''\n    ADRS''' = setTreeIndex (setType ADRS'' 2) idx_sig\n    (node_0', _) = foldl updateNode (node_0_initial, ADRS''') [0..h-1] where\n        updateNode (node_0, adrs) k = (node_1, adrs'') where\n            adrs' = setTreeHeight adrs k\n            treeindex = getTreeIndex adrs'\n            treeindex' = if (idx_sig \/ 2^^k) % 2 == 0\n                then treeindex \/ 2\n                else (treeindex - 1) \/ 2\n            adrs'' = setTreeIndex adrs' treeindex'\n            node_1 = if (idx_sig \/ 2^^k) % 2 == 0\n                then RAND_HASH node_0 (auth @ k) SEED adrs''\n                else RAND_HASH (auth @ k) node_0 SEED adrs''\n\n\/**\n * `verify` - Verify an XMSS signature using the corresponding XMSS public key\n * and a message.\n *\n * Note: We index into the `PrivateKey` type rather than using `getSEED` and\n * index into the `PublicKey` type rather than using `getRoot`. The spec\n * also implicitly indexes into the `Signature` type which we do explicitly\n * here.\n *\n *   Input: XMSS signature Sig, message M, XMSS public key PK\n *   Output: Boolean\n *\n *   ADRS = toByte(0, 32);\n *   byte[n] M' = H_msg(r || getRoot(PK) || (toByte(idx_sig, n)), M);\n *\n *   byte[n] node = XMSS_rootFromSig(idx_sig, sig_ots, auth, M',\n *                                   getSEED(PK), ADRS);\n *   if ( node == getRoot(PK) ) {\n *     return true;\n *   } else {\n *     return false;\n *   }\n *\n * [RFC-8391] Section 4.1.10, Algorithm 14 (called `XMSS_verify` in the\n * spec).\n *\/\nverify : {m} (fin m, width (PaddingWidth + 8 * m) < MessageUpperBound)\n    => Signature -> [m]Byte -> PublicKey -> Bit\nverify Sig M PK = node == PK.root where\n    ADRS = zero \/\/ Equivalent to `WOTS::toByte`{32} 0`.\n    M' = H_msg (Sig.r # PK.root # WOTS::toByte`{n} Sig.idx_sig) M\n    node = rootFromSig Sig.idx_sig Sig.sig_ots Sig.auth M' PK.seed ADRS\n\n\/**\n * ```repl\n * :set tests = 1\n * :check XMSSInverts\n * ```\n *\/\nproperty XMSSInverts M wots_sks SK_PRF SEED = verify sig M pk where\n    (sk, pk) = keyGen wots_sks SK_PRF SEED\n    (sk', sig) = sign M sk\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the constraints and behaviors of the XMSS parameters defined in the module Primitive::Asymmetric::Signature::XMSS::Parameters.cry. These properties should check that the type constraints on the tree height 'h' and message digest length 'n' are enforced, that the hash functions 'H' and 'H_msg' conform to their specified input and output sizes, and that the maximum message width and padding width constraints are respected. Additionally, specify properties to verify that the Object Identifier 'oid' matches expected formats as per RFC-8391."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Asymmetric::Signature::XMSS::Parameters where\n\n\/**\n * Height of the XMSS tree.\n * [RFC-8391] Section 4.1.1.\n *\/\ntype h : #\ntype constraint (fin h)\n\/**\n * This constraint comes from the fact that 2^^h must fit within a word.\n *\n * See `treeHash` for more details.\n *\/\ntype constraint (h <= 32)\n\/**\n * The height of the XMSS tree must be at least 1.\n *\/\ntype constraint (h >= 1)\n\n\/**\n * The length (in bytes) of the message digest, as well as each node.\n * [RFC-8391] Section 4.1.1.\n *\/\ntype n : #\ntype constraint (fin n)\n\n\/**\n * A cryptographic hash function that takes a key and a message.\n * [RFC-8391] Section 4.1.2.\n *\/\nH : [n][8] -> [2 * n][8] -> [n][8]\n\n\/**\n * Maximum width in bits for a message under the hash function used to\n * instantiate `H_msg`.\n *\n * `H_msg` allows arbitrary-length messages, but in practice, the hash\n * functions used to instantiate it may limit their input to some maximum\n * width.\n *\/\ntype MessageUpperBound : #\n\n\/**\n * Width of the non-message bits passed to the hash function in `H_msg`.\n *\n * In the approved instantiations defined in [RFC-8391] and [SP-800-208],\n * this includes domain separation and a fixed-length key.\n * This is used to enforce the max message width constraint.\n *\/\ntype PaddingWidth : #\n\n\/**\n * The Object Identifier (OID) for the XMSS public key.\n *\n * See [RFC-8391] Section 8 for the specific values to set this to for a given\n * instantiation.\n *\n * [RFC-8391] Section 4.1.7.\n *\/\noid : [32]\n\n\/**\n * A cryptographic hash function that takes a key and an arbitrary-length\n * message.\n * [RFC-8391] Section 4.1.2.\n *\n * Note: Some approved instantiations of this function use hash functions that\n * have a maximum width for messages. The type constraint enforces this by\n * limiting the length of the hashed message to the maximum width.\n *\/\nH_msg : {m} (fin m, width (PaddingWidth + 8 * m) < MessageUpperBound)\n    => [3 * n][8] -> [m][8] -> [n][8]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/WOTS\/Interface.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol specifications and properties to verify the correctness of the WOTS+ one-time signature scheme interface defined in the given module. This should include properties that check the consistency between key generation (genPK), signing (sign), and signature verification (pkFromSig) functions according to RFC-8391. Ensure the properties validate that signatures produced by sign can be verified by pkFromSig to recover the corresponding public key generated by genPK for the same message and address parameters."},{"role":"assistant","content":"```cryptol\n\/*\n * Public interface for the WOTS+ one-time signature scheme.\n *\n * We expect that there will only be one implementation of this scheme.\n * However, to support its typical use as a component in a more complex scheme\n * (like XMSS and SPHINCS+), we want to allow other protocols to be\n * defined in terms of the generic WOTS, and then instantiated with both\n * WOTS-specific and scheme-specific parameters (and potentially with\n * additional interface constraints).\n *\n * Some documentation is duplicated between this interface and the\n * specification. This is based on the API in [RFC-8391].\n *\n * [RFC-8391]: Andreas Huelsing, Denis Butin, Stefan-Lukas Gazdag, Joost\n *     Rijneveld, and Aziz Mohaisen. XMSS: eXtended Merkle Signature Scheme.\n *     Internet Requests for Comments (RFC) 8391. May 2018.\n *     @see https:\/\/datatracker.ietf.org\/doc\/rfc8391\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\ninterface module Primitive::Asymmetric::Signature::WOTS::Interface where\n\n\/**\n * Security parameter.\n * This defines the message length, the length of a private key, the length\n * of a public key, and a signature element (in bytes).\n * [RFC-8391] Section 3.1.1.\n *\/\ntype n : #\ntype constraint (fin n)\n\n\/**\n * The Winternitz parameter. This must be either 4 or 16.\n * [RFC-8391] Section 3.1.1.\n *\n * The type constraint is a bit contrived, but it requires that\n * `w` is in the range `[0, 16]`, is divisible by 4 (`{0, 4, 8, 12, 16}`),\n * and is congruent to 1 mod 3 (`{4, 16}`).\n *\/\ntype w : #\ntype constraint (fin w, w % 4 == 0, w % 3 == 1, w <= 16)\n\n\/**\n * A keyed cryptographic hash function that takes a key and a message.\n * [RFC-8391] Section 3.1.1.1.\n *\/\nF : [n][8] -> [n][8] -> [n][8]\n\n\/**\n * A pseudorandom function that takes a key and an index.\n * [RFC-8391] Section 3.1.1.1.\n *\/\nPRF : [n][8] -> [32][8] -> [n][8]\n\n\/**\n * A length value (fixed with respect to `n` and `w`).\n * [RFC-8391] Section 3.1.1.\n *\/\ntype len_1 = (8 * n) \/^ (lg2 w)\n\n\/**\n * A length value (fixed with respect to `n` and `w`).\n * [RFC-8391] Section 3.1.1.\n *\/\n\ntype len_2 = lg2 (len_1 * (w - 1)) \/ lg2 w + 1\n\n\/**\n * The number of `n`-byte string elements in a WOTS+ private key, public key,\n * and signature.\n * [RFC-8391] Section 3.1.1.\n *\/\ntype len = len_1 + len_2\n\/**\n * This constraint comes from the fact that we set locations in `Address` to\n * functions of `len` (in particular, `len \/ 2`). These locations are 32 bits\n * in size, so we require that `width len` is no greater than 32 bits.\n *\/\ntype constraint (width len <= 32)\n\n\/**\n * A byte is a sequence of 8 bits using big-endian representation.\n * [RFC-8391] Section 2.1.\n *\/\ntype Byte = [8]\n\n\/**\n * Convert a non-negative integer to a binary representation in big-endian\n * byte order.\n * [RFC-8391] Section 2.4.\n *\n * Note: the spec is not explicit about what to do when `m < 8y` -- e.g. when\n * converting to `y` bytes means truncating the integer representation,\n * rather than padding it with 0s. We chose this behavior based on the\n * reference implementation that accompanies the spec.\n * @see https:\/\/github.com\/XMSS\/xmss-reference\/blob\/master\/utils.c#L6\n * [RFC-8391] Section 7.\n *\n * Essentially, we pad with zeros if needed (using `zext`), then `drop` any\n * unnecessary padding (and potentially also drop some bits of the original\n * integer).\n *\/\ntoByte : {y, m} (fin y, fin m) => [m] -> [y]Byte\n\n\/**\n * An n-byte value used as the key to a PRF.\n *\n * This type is not formally defined in the spec but is defined here for\n * clarity.\n *\n * [RFC-8391] Section 2.5.\n *\/\ntype Seed = [n]Byte\n\n\/**\n * Address scheme for randomizing hash function calls in the OTS scheme.\n * [RFC-8391] Section 2.5.\n *\/\ntype Address = [8 * 4]Byte\n\n\/**\n * Address scheme for randomizing hash function calls in the OTS scheme.\n * [RFC-8391] Section 2.5.\n *\n * The address breaks down 7 components, each 1 word long unless specified.\n * 1. Layer address\n * 2-3. Tree address (2 Words)\n * 4. Type (fixed at 0)\n * 5. OTS address\n * 6. Chain address\n * 7. Hash address\n * 8. keyAndMask\n *\n * Note that this isn't defined in terms of the `Word` type because it's\n * operated on by things that require arrays of bytes.\n *\/\ntype OTSHashAddress = [8 * 4]Byte\n\n\/**\n * A private, or secret, key in WOTS+ is a length `len` array of `n`-byte\n * strings.\n *\n * It represents the start nodes in a set of hash chains.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: A private key MUST be selected randomly from the uniform\n * distribution or selected using a cryptographically secure pseudorandom\n * process! Cryptol cannot verify that a `PrivateKey` was chosen suitably!\n * Implementors must independently audit private key generation!\n *\n * [RFC-8391] Section 3.1.3.\n *\n * An implementation may also use a cryptographically secure pseudorandom\n * method to generate the private key from a single `n`-byte value. See\n * [RFC-8391] Section 3.1.7 for a sample method.\n *\/\ntype PrivateKey = [len][n]Byte\n\n\/**\n * A WOTS+ public key is a length `len` array of `n`-byte strings.\n *\n * It represents the end nodes i a set of length-`w` hash chains, where the\n * start nodes are defined in the corresponding `PrivateKey`.\n *\/\ntype PublicKey = [len][n]Byte\n\n\/**\n * A WOTS+ signature.\n * [RFC-8391] Section 3.1.5.\n *\/\ntype Signature = [len][n]Byte\n\n\/**\n * Generate a WOTS+ public key from a private key.\n * [RFC-8391] Section 3.1.4, Algorithm 4 (called `WOTS_genPK` in the spec).\n * [Errata-8382] @see https:\/\/www.rfc-editor.org\/errata\/eid8382\n *\/\ngenPK : PrivateKey -> [n]Byte -> Address -> PublicKey\n\n\/**\n * Generate a signature from a private key and a message.\n * [RFC-8391] Section 3.1.5, Algorithm 5 (called `WOTS_sign` in the spec).\n *\/\nsign : [n]Byte -> PrivateKey -> Address -> [n]Byte -> Signature\n\n\/**\n * Compute a WOTS+ public key from a message and its signature.\n * [RFC-8391] Section 3.1.6, Algorithm 6 (called `WOTS_pkFromSig` in the spec).\n *\n * The result of this function must be compared to the given public key. If\n * the values are not equal, the signature MUST be rejected. This algorithm\n * does not actually reject any signatures!!\n *\/\npkFromSig : [n]Byte -> Signature -> Address -> [n]Byte -> PublicKey\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/WOTS\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the WOTS+ signature scheme implementation in the given specification file. Specifically, create properties that check that for any valid private key, message, address, and seed, the public key generated from the private key matches the public key recovered from a signature on the message, ensuring the signature verification process is consistent with the specification. Include properties to verify the correctness of the base_w conversion functions and the chaining function behavior as defined in the WOTS+ scheme."},{"role":"assistant","content":"```cryptol\n\/**\n * WOTS+: One-Time Signatures.\n *\n * WOTS+ is a signature scheme. A notable limitation of WOTS+ is that a given\n * key pair can produce exactly ONE signature; repeated signatures with a\n * single key pair will compromise the private key!!\n *\n * This scheme should typically be used as a component of a less limited\n * signature scheme, like XMSS or SPHINCS+.\n *\n * Warning: If a private key is used to sign two different messages, the scheme\n * becomes insecure! Cryptol cannot protect against this failure mode!\n *\n * Instantiation warnings\n * - The WOTS+ signature scheme includes a checksum. Per [RFC-8391], the\n *   checksum can fit in 32 bits _when instantiated with an approved parameter\n *   set_. This must not be instantiated with any parameter set for which the\n *   checksum does not fit in 32 bits. [RFC-8391] Section 3.1.5.\n *\n * References:\n * [RFC-8391]: Andreas Huelsing, Denis Butin, Stefan-Lukas Gazdag, Joost\n *     Rijneveld, and Aziz Mohaisen. XMSS: eXtended Merkle Signature Scheme.\n *     Internet Requests for Comments (RFC) 8391. May 2018.\n *     @see https:\/\/datatracker.ietf.org\/doc\/rfc8391\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::WOTS::Specification where\n\nparameter\n    \/**\n     * Security parameter.\n     * This defines the message length, the length of a private key, the length\n     * of a public key, and a signature element (in bytes).\n     * [RFC-8391] Section 3.1.1.\n     *\/\n    type n' : #\n    type constraint (fin n')\n\n    \/**\n     * The Winternitz parameter. This must be either 4 or 16.\n     * [RFC-8391] Section 3.1.1.\n     *\n     * The type constraint is a bit contrived, but it requires that\n     * `w` is in the range `[0, 16]`, is divisible by 4 (`{0, 4, 8, 12, 16}`),\n     * and is congruent to 1 mod 3 (`{4, 16}`).\n     *\/\n    type w' : #\n    type constraint (fin w', w' % 4 == 0, w' % 3 == 1, w' <= 16)\n\n    \/**\n     * A keyed cryptographic hash function that takes a key and a message.\n     * [RFC-8391] Section 3.1.1.1.\n     *\/\n    F' : [n'][8] -> [n'][8] -> [n'][8]\n\n    \/**\n     * A pseudorandom function that takes a key and an index.\n     * [RFC-8391] Section 3.1.1.1.\n     *\/\n    PRF' : [n'][8] -> [32][8] -> [n'][8]\n\n    \/**\n     * A length value (fixed with respect to `n` and `w`).\n     * [RFC-8391] Section 3.1.1.\n     *\n     * The type constraint is drawn from Algorithm 5, where a computed checksum\n     * of length `len_1 * (w - 1) * 2^8` must fit in 32 bits for correctness.\n     *\/\n    type len_1 = (8 * n') \/^ (lg2 w')\n    type constraint (width (len_1 * (w' - 1) * 2^^8) <= 32)\n\n    \/**\n     * A length value (fixed with respect to `n` and `w`).\n     * [RFC-8391] Section 3.1.1.\n     *\/\n\n    type len_2 = lg2 (len_1 * (w' - 1)) \/ lg2 w' + 1\n\n    \/**\n     * The number of `n`-byte string elements in a WOTS+ private key, public key,\n     * and signature.\n     * [RFC-8391] Section 3.1.1.\n     *\/\n    type len = len_1 + len_2\n\n    \/**\n     * The `len` parameter fits in 32 bits.\n     *\n     * This implicit fact about our inputs is hard for Cryptol to infer, so we\n     * state it explicitly.\n     *\n     * It is implied by the `genPK` function, which sets the chain address\n     * of an OTS hash address to an iterator that varies from 0 to `len-1`.\n     * The chain address is restricted to one 32-bit word. See [RFC-8391]\n     * Algorithm 4.\n     *\n     * This can also be observed from the computed `len` values from the valid\n     * parameter sets in Section 5.2.\n     *\/\n    type constraint (32 >= width len)\n\ntype n = n'\ntype w = w'\nF = F'\nPRF = PRF'\n\n\/**\n * A byte is a sequence of 8 bits using big-endian representation.\n * [RFC-8391] Section 2.1.\n *\/\ntype Byte = [8]\n\n\/**\n * Convert a non-negative integer to a binary representation in big-endian\n * byte order.\n * [RFC-8391] Section 2.4.\n *\n * Note: the spec is not explicit about what to do when `m < 8y` -- e.g. when\n * converting to `y` bytes means truncating the integer representation,\n * rather than padding it with 0s. We chose this behavior based on the\n * reference implementation that accompanies the spec.\n * @see https:\/\/github.com\/XMSS\/xmss-reference\/blob\/master\/utils.c#L6\n * [RFC-8391] Section 7.\n *\n * Essentially, we pad with zeros if needed (using `zext`), then `drop` any\n * unnecessary padding (and potentially also drop some bits of the original\n * integer).\n *\/\ntoByte : {y, m} (fin y, fin m) => [m] -> [y]Byte\ntoByte x = split (drop (zext`{max m (y * 8)} x))\n\n\/**\n * Ensure that `toByte`{32} 0 == zero`.\n * ```repl\n * :check toByteZeroIsZero`{32}\n * ```\n *\/\ntoByteZeroIsZero : {m} fin m => Bit\ntoByteZeroIsZero = zero == toByte`{32, m} 0\n\n\/**\n * An n-byte value used as the key to a PRF.\n *\n * This type is not formally defined in the spec but is defined here for\n * clarity.\n *\n * [RFC-8391] Section 2.5.\n *\/\ntype Seed = [n]Byte\n\n\/**\n * A word is a 32-bit sequence used to define hash addresses.\n * [RFC-8391] Section 2.5.\n *\/\ntype Word = [32]\n\n\/**\n * Address scheme for randomizing hash function calls in the OTS scheme.\n * [RFC-8391] Section 2.5.\n *\n * The address breaks down 7 components, each 1 word long unless specified.\n * 1. Layer address\n * 2-3. Tree address (2 Words)\n * 4. Type (fixed at 0)\n * 5. OTS address\n * 6. Chain address\n * 7. Hash address\n * 8. keyAndMask\n *\n * Note that this isn't defined in terms of the `Word` type because it's\n * operated on by things that require arrays of bytes.\n *\/\ntype OTSHashAddress = [8 * 4]Byte\n\n\/**\n * A private, or secret, key in WOTS+ is a length `len` array of `n`-byte\n * strings.\n *\n * It represents the start nodes in a set of hash chains.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: A private key MUST be selected randomly from the uniform\n * distribution or selected using a cryptographically secure pseudorandom\n * process! Cryptol cannot verify that a `PrivateKey` was chosen suitably!\n * Implementors must independently audit private key generation!\n *\n * [RFC-8391] Section 3.1.3.\n *\n * An implementation may also use a cryptographically secure pseudorandom\n * method to generate the private key from a single `n`-byte value. See\n * [RFC-8391] Section 3.1.7 for a sample method.\n *\/\ntype PrivateKey = [len][n]Byte\n\n\/**\n * A WOTS+ public key is a length `len` array of `n`-byte strings.\n *\n * It represents the end nodes i a set of length-`w` hash chains, where the\n * start nodes are defined in the corresponding `PrivateKey`.\n *\/\ntype PublicKey = [len][n]Byte\n\n\/**\n * Generate a WOTS+ public key from a private key.\n * [RFC-8391] Section 3.1.4, Algorithm 4 (called `WOTS_genPK` in the spec).\n * [Errata-8382] @see https:\/\/www.rfc-editor.org\/errata\/eid8382\n *\/\ngenPK : PrivateKey -> [n]Byte -> OTSHashAddress -> PublicKey\ngenPK sk SEED ADRS = pk where\n    pk = [ pki where\n            ADRSi = setChainAddress ADRS i\n            pki = chain ski 0 (`w - 1) SEED ADRSi\n        | i <- [0..len-1]\n        | ski <- sk]\n\nprivate\n    \/**\n     * Set the chain address word (in the 6th position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setChainAddress : OTSHashAddress -> Word -> OTSHashAddress\n    setChainAddress address value =\n        take`{5 * 4} address # (split value) # drop`{6 * 4} address\n\n    \/**\n     * Set the hash address word (in the 7th position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setHashAddress : OTSHashAddress -> Word -> OTSHashAddress\n    setHashAddress address value =\n        take`{6 * 4} address # (split value) # drop`{7 * 4} address\n\n    \/**\n     * Set the `keyAndMask` word (the last position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setKeyAndMask : OTSHashAddress -> Word -> OTSHashAddress\n    setKeyAndMask address value = take`{7 * 4} address # split value\n\n    \/**\n     * Chaining function that iterates `F` on the input `X`, `s` times.\n     * [RFC-8391] Section 3.1.2, Algorithm 2.\n     *\/\n    chain : [n]Byte -> Word -> Word -> [n]Byte -> OTSHashAddress -> [n]Byte\n    chain X i s SEED ADRS = return where\n        return = if s == 0 then\n                X\n            else if i + s > `w - 1 then\n                error \"Invalid `s` and `i` parameters passed to `chain`\"\n            else\n                tmp'\n        tmp = chain X i (s - 1) SEED ADRS\n\n        ADRS' = setHashAddress ADRS (i + s - 1)\n        ADRS'' = setKeyAndMask ADRS' 0\n        KEY = PRF SEED ADRS''\n        ADRS''' = setKeyAndMask ADRS'' 1\n        BM = PRF SEED ADRS'''\n\n        tmp' = F KEY (tmp ^ BM)\n\n    \/**\n     * Convert a byte string into a set of base-`w` numbers.\n     *\n     * This uses the manual bit-shifting algorithm described in the spec. The\n     * spec is not very particular about bit widths of the helper variables or\n     * the output; we made the following choices:\n     * - `total`: holds each byte of the input, so `[8]`\n     * - `in`: holds the index showing where we are in the input. We use an\n     *   `Integer`, although this could also be `[width len_X]`.\n     * - `bits`: holds the number of bits processed in the current byte. This is\n     *   never larger than 8, but due to the way we've defined the type\n     *   constraint on `w`, it's easier to leave some extra space, so `[8]`.\n     * - `basew`: The output of this function is eventually used as a parameter\n     *   to `chain`, so we pad each base-`w` number to be a `Word` (`[32]`).\n     *\n     * [RFC-8391] Section 2.6, Algorithm 1.\n     *\/\n    base_w_spec : {out_len, len_X} (\n            fin len_X,\n            out_len <= 8 * len_X \/ lg2 w)\n        => [len_X]Byte -> [out_len]Word\n    base_w_spec X = basew where\n        \/\/ Steps 8 - 13. Define how the helper variables (`total`, `in`, `bits`)\n        \/\/ are updated in each round.\n        update_helpers : ([8], Integer, [8]) -> ([8], Integer, [8])\n        update_helpers (total, in, bits) =\n            if bits == 0 then (\n                X@in,\n                in + 1,\n                8 - lg2 `w )\n            else (total, in, bits - lg2 `w)\n\n        \/\/ Step 7. Define the number of iterations we need.\n        type consumed = out_len\n\n        \/\/ Step 14. Compute the set of base-`w` numbers. `zext` converts an\n        \/\/ 8-bit value to a `Word`.\n        basew = take`{consumed} [ zext ((total >> bits) && (`w - 1))\n            \/\/ Steps 1-5. Initialize helper variables (and update them for each\n            \/\/ round). The first element is dropped because the first variable\n            \/\/ update happens before computing any output values.\n            | (total, in, bits) <- drop`{1} (iterate update_helpers (0, 0, 0))]\n\n    \/**\n     * Convert a byte string into a set of base-`w` numbers.\n     *\n     * This uses standard built-in Cryptol functions to achieve the same\n     * functionality as the spec version; rather than manually bit shifting, it\n     * regroups the bits into the desired arrangement. This is about 5x faster\n     * than the spec version.\n     *\n     * Note that this depends on the top-level type constraint restricting `w`\n     * to either 4 or 16. I am not sure the grouping would work as well if we\n     * were working in a base that was not a power of 2.\n     *\/\n    base_w : {out_len, len_X} (\n        fin len_X,\n        out_len <= 8 * len_X \/ lg2 w)\n        => [len_X]Byte -> [out_len]Word\n    base_w X = map zext (groupBy`{lg2 w} (take (join X)))\n\n    \/**\n     * Proof that the Cryptol-ish version of `base_w` matches the spec version.\n     *\n     * Parameter for the following tests are chosen based on the instantiations\n     * that appear in the spec (Algorithms 5 and 6).\n     * ```repl\n     * :prove base_wsMatch`{len_1, n * 8}\n     * type len_2_bytes = len_2 * lg2 w \/^ 8\n     * :prove base_wsMatch`{len_2, len_2_bytes}\n     * ```\n     *\/\n    base_wsMatch : {O, L} (fin L, O <= 8 * L \/ lg2 w) => [L]Byte -> Bit\n    property base_wsMatch X = base_w_spec`{O, L} X == base_w X\n\n    \/**\n     * The spec provides several examples when `w = 16`.\n     * [RFC-8391] Section 2.6.\n     * ```repl\n     * :prove base_wExamplesWork`{}\n     * ```\n     *\/\n    base_wExamplesWork : (w == 16) => Bit\n    property base_wExamplesWork = test4 && test3 && test2 where\n        test4 = base_w`{4} [0x12, 0x34] == [1, 2, 3, 4]\n        test3 = base_w`{3} [0x12, 0x34] == [1, 2, 3]\n        test2 = base_w`{2} [0x12, 0x34] == [1, 2]\n\n\n\/**\n * A WOTS+ signature.\n * [RFC-8391] Section 3.1.5.\n *\/\ntype Signature = [len][n]Byte\n\n\/**\n * Generate a signature from a private key and a message.\n * [RFC-8391] Section 3.1.5, Algorithm 5 (called `WOTS_sign` in the spec).\n *\n * The checksum in the signature algorithm must fit in 32 bits; we enforce this\n * using a constraint in the type signature; it will always be true for the\n * approved parameter sets.\n *\/\nsign : [n]Byte -> PrivateKey -> OTSHashAddress -> [n]Byte -> Signature\nsign M sk ADRS SEED = sig where\n        msg = base_w`{len_1} M\n\n        csum = sum [ `w - 1 - msg_i | msg_i <- msg ]\n\n    \/\/ Convert `csum` to base `w`.\n    csum' = csum << (8 - (`(len_2 * lg2 w) % 8))\n    type len_2_bytes = (len_2 * lg2 w) \/^ 8\n    msg' = msg # base_w`{len_2} (toByte`{len_2_bytes} csum')\n    sig = [sig_i where\n            ADRS_i = setChainAddress ADRS i\n            sig_i = chain sk_i 0 msg_i SEED ADRS_i\n        | i <- [0..len-1]\n        | sk_i <- sk\n        | msg_i <- msg' ]\n\n\/**\n * Compute a WOTS+ public key from a message and its signature.\n * [RFC-8391] Section 3.1.6, Algorithm 6 (called `WOTS_pkFromSig` in the spec).\n *\n * The result of this function must be compared to the given public key. If\n * the values are not equal, the signature MUST be rejected. This algorithm\n * does not actually reject any signatures!!\n *\/\npkFromSig : [n]Byte -> Signature -> OTSHashAddress -> [n]Byte -> PublicKey\npkFromSig M sig ADRS SEED = tmp_pk where\n        msg = base_w`{len_1} M\n\n        csum = sum [ `w - 1 - msg_i | msg_i <- msg ]\n\n    \/\/ Convert `csum` to base `w`.\n    csum' = csum << (8 - (`(len_2 * lg2 w) % 8))\n    type len_2_bytes = (len_2 * lg2 w) \/^ 8\n    msg' = msg # base_w`{len_2} (toByte`{len_2_bytes} csum')\n    tmp_pk = [tmp_pk_i where\n            ADRS_i = setChainAddress ADRS i\n            tmp_pk_i = chain sig_i msg_i (`w - 1 - msg_i) SEED ADRS_i\n        | i <- [0..len-1]\n        | sig_i <- sig\n        | msg_i <- msg' ]\n\n\/**\n * A single execution of this property takes ~2 minutes.\n * ```repl\n * :set tests = 1\n * :check WOTSisCorrect\n * ```\n *\/\nproperty WOTSisCorrect M sk ADRS SEED = tmp_pk == pk where\n    pk = genPK sk SEED ADRS\n    sig = sign M sk ADRS SEED\n    tmp_pk = pkFromSig M sig ADRS SEED\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Instantiations\/ML_DSA_87.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the ML-DSA-87 parameter set as given in the module Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_87. Then, create Cryptol properties to verify that these parameters satisfy the necessary mathematical constraints and security requirements specified in FIPS-204 Section 4, Table 1, such as the size and relationships between q, \u03c4, \u03bb, \u03b31, \u03b32, k, ell, \u03b7, and \u03c9."},{"role":"assistant","content":"```cryptol\n\/**\n * Instantiation of the ML-DSA-87 parameter set.\n * [FIPS-204] Section 4, Table 1.\n *\n * This is in security strength category 5.\n *\n * @copyright Galois Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_87 =\n    Primitive::Asymmetric::Signature::ML_DSA::ML_DSA where\n\n        type q = 8380417\n        type \u03c4 = 60\n        type \u03bb = 256\n        type \u03b31 = 2 ^^ 19\n        type \u03b32 = (q - 1) \/ 32\n        type k = 8\n        type ell = 7\n        type \u03b7 = 2\n        type \u03c9 = 75\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Instantiations\/ML_DSA_44.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the ML-DSA-44 parameter set as given in the module Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_44, including all type definitions and constants. Then, write properties to verify that these parameters satisfy the constraints required by the ML-DSA signature scheme according to FIPS-204 Section 4, Table 1, such as the size and relationships between q, \u03c4, \u03bb, \u03b31, \u03b32, k, ell, \u03b7, and \u03c9."},{"role":"assistant","content":"```cryptol\n\/**\n * Instantiation of the ML-DSA-44 parameter set.\n * [FIPS-204] Section 4, Table 1.\n *\n * This is in security strength category 2.\n *\n * @copyright Galois Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_44 =\n    Primitive::Asymmetric::Signature::ML_DSA::ML_DSA where\n\n        type q = 8380417\n        type \u03c4 = 39\n        type \u03bb = 128\n        type \u03b31 = 2 ^^ 17\n        type \u03b32 = (q - 1) \/ 88\n        type k = 4\n        type ell = 4\n        type \u03b7 = 2\n        type \u03c9 = 80\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P224_SHA224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the ECDSA signature generation and verification functions for the P-224 curve with SHA-224 hash produce correct and consistent results for the given test vectors. Ensure the properties check that the signature matches expected (r,s) values and that verification succeeds for the corresponding public key."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P224_SHA224 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA224 as ECDSA\nimport Common::utils(BVtoZ)\n\nproperty checkSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\n\/**\n * Test vector for ECDSA with curve P-224 and SHA-224 as the hash.\n * [RFC6979] Appendix A.2.4.\n * ```repl\n * :prove sampleVector\n * ```\n *\/\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0xF220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\n    k = BVtoZ 0xC1D1F2F10881088301880506805FEB4825FE09ACB6816C36991AA06D\n    expected_r = BVtoZ 0x1CDFE6662DDE1E4A1EC4CDEDF6A1F5A2FB7FBD9145C12113E6ABFD3E\n    expected_s = BVtoZ 0xA6694FD7718A21053F225D3F46197CA699D45006C06F871808F43EBC\n\n\/**\n * Test vector for ECDSA with curve P-224 and SHA-224 as the hash.\n * [RFC6979] Appendix A.2.4.\n * ```repl\n * :prove testVector\n * ```\n *\/\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0xF220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\n    k = BVtoZ 0xDF8B38D40DCA3E077D0AC520BF56B6D565134D9B5F2EAE0D34900524\n    expected_r = BVtoZ 0xC441CE8E261DED634E4CF84910E4C5D1D22C5CF3B732BB204DBEF019\n    expected_s = BVtoZ 0x902F42847A63BDC5F6046ADA114953120F99442D76510150F372A3F4\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P384_SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the ECDSA P-384 signature generation and verification functions correctly produce and validate signatures as specified by the given test vectors. Include properties that check the correctness of the signature components (r, s) against expected values and ensure that verification succeeds for these signatures."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P384_SHA384 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA384 as ECDSA\nimport Common::utils(BVtoZ)\n\nproperty checkSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\n\/**\n * Test vector for ECDSA with curve P-384 and SHA-384 as the hash.\n * [RFC6979] Appendix A.2.6.\n * ```repl\n * :prove sampleVector\n * ```\n *\/\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0x6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\n    k = BVtoZ 0x94ED910D1A099DAD3254E9242AE85ABDE4BA15168EAF0CA87A555FD56D10FBCA2907E3E83BA95368623B8C4686915CF9\n    expected_r = BVtoZ 0x94EDBB92A5ECB8AAD4736E56C691916B3F88140666CE9FA73D64C4EA95AD133C81A648152E44ACF96E36DD1E80FABE46\n    expected_s = BVtoZ 0x99EF4AEB15F178CEA1FE40DB2603138F130E740A19624526203B6351D0A3A94FA329C145786E679E7B82C71A38628AC8\n\n\/**\n * Test vector for ECDSA with curve P-384 and SHA-384 as the hash.\n * [RFC6979] Appendix A.2.6.\n * ```repl\n * :prove testVector\n * ```\n *\/\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0x6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\n    k = BVtoZ 0x015EE46A5BF88773ED9123A5AB0807962D193719503C527B031B4C2D225092ADA71F4A459BC0DA98ADB95837DB8312EA\n    expected_r = BVtoZ 0x8203B63D3C853E8D77227FB377BCF7B7B772E97892A80F36AB775D509D7A5FEB0542A7F0812998DA8F1DD3CA3CF023DB\n    expected_s = BVtoZ 0xDDD0760448D42D8A43AF45AF836FCE4DE8BE06B485E9B61B827C2F13173923E06A739F040649A667BF3B828246BAA5A5\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P521_SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the ECDSA signature generation and verification functions for the P-521 curve with SHA-512 hashing, using the provided test vectors from RFC6979 Appendix A.2.7. Ensure the properties check that the signature produced matches the expected (r, s) values and that the verification function confirms the signature's validity for the given message and public key."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P521_SHA512 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA512 as ECDSA\nimport Common::utils(BVtoZ)\n\ncheckSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\n\/**\n * Test vector for ECDSA with curve P-521 and SHA-512 as the hash.\n * [RFC6979] Appendix A.2.7.\n * ```repl\n * :prove sampleVector\n * ```\n *\/\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0x0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\n    k = BVtoZ 0x1DAE2EA071F8110DC26882D4D5EAE0621A3256FC8847FB9022E2B7D28E6F10198B1574FDD03A9053C08A1854A168AA5A57470EC97DD5CE090124EF52A2F7ECBFFD3\n    expected_r = BVtoZ 0x0C328FAFCBD79DD77850370C46325D987CB525569FB63C5D3BC53950E6D4C5F174E25A1EE9017B5D450606ADD152B534931D7D4E8455CC91F9B15BF05EC36E377FA\n    expected_s = BVtoZ 0x0617CCE7CF5064806C467F678D3B4080D6F1CC50AF26CA209417308281B68AF282623EAA63E5B5C0723D8B8C37FF0777B1A20F8CCB1DCCC43997F1EE0E44DA4A67A\n\n\/**\n * Test vector for ECDSA with curve P-521 and SHA-512 as the hash.\n * [RFC6979] Appendix A.2.7.\n * ```repl\n * :prove testVector\n * ```\n *\/\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0x0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\n    k = BVtoZ 0x16200813020EC986863BEDFC1B121F605C1215645018AEA1A7B215A564DE9EB1B38A67AA1128B80CE391C4FB71187654AAA3431027BFC7F395766CA988C964DC56D\n    expected_r = BVtoZ 0x13E99020ABF5CEE7525D16B69B229652AB6BDF2AFFCAEF38773B4B7D08725F10CDB93482FDCC54EDCEE91ECA4166B2A7C6265EF0CE2BD7051B7CEF945BABD47EE6D\n    expected_s = BVtoZ 0x1FBD0013C674AA79CB39849527916CE301C66EA7CE8B80682786AD60F98F7E78A19CA69EFF5C57400E3B3A0AD66CE0978214D13BAF4E9AC60752F7B155E2DE4DCE3\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P256_SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally verifies the correctness of the ECDSA P-256 signature generation and verification process as implemented in the given module. The specification should include properties that check the signature against known test vectors (such as those from RFC6979 Appendix A.2.5) by comparing the generated signature components (r, s) with expected values and ensuring that the verification function accepts the signature. Include properties suitable for use with Cryptol's :prove command to confirm the correctness of the sign and verify functions for these test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P256_SHA256 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA256 as ECDSA\nimport Common::utils(BVtoZ)\n\nproperty checkSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\n\/**\n * Test vector for ECDSA with curve P-256 and SHA-256 as the hash.\n * [RFC6979] Appendix A.2.5.\n * ```repl\n * :prove sampleVector\n * ```\n *\/\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0xC9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\n    k = BVtoZ 0xA6E3C57DD01ABE90086538398355DD4C3B17AA873382B0F24D6129493D8AAD60\n    expected_r = BVtoZ 0xEFD48B2AACB6A8FD1140DD9CD45E81D69D2C877B56AAF991C34D0EA84EAF3716\n    expected_s = BVtoZ 0xF7CB1C942D657C41D436C7A1B6E29F65F3E900DBB9AFF4064DC4AB2F843ACDA8\n\n\/**\n * Test vector for ECDSA with curve P-256 and SHA-256 as the hash.\n * [RFC6979] Appendix A.2.5.\n * ```repl\n * :prove testVector\n * ```\n *\/\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0xC9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\n    k = BVtoZ 0xD16B6AE827F17175E040871A1C7EC3500192C4C92677336EC2537ACAEE0008E0\n    expected_r = BVtoZ 0xF1ABB023518351CD71D881567B1EA663ED3EFCF6C5132B354F28D3B0B7D38367\n    expected_s = BVtoZ 0x019F4113742A2B14BD25926B49C649155F267E60D3814B4C0CC84250E46F0083\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P521_SHA3_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and security properties of the ECDSA signature scheme instantiated with the P-521 elliptic curve and the SHA3-512 hash function, as given in the module Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512. The specification should capture the signing and verification algorithms, and include properties to verify correctness and resistance to forgery under the given instantiation."},{"role":"assistant","content":"```cryptol\n\/*\n * Instantiate ECDSA with curve P-521 (also known as secp521p1) and SHA3-512.\n *\n * Note that this uses `UnconstrainedSpec` because the security strength of the hash\n * function is less than that of the elliptic curve! The overall security strength\n * of this ECDSA instantiation is approximately 256 bits.\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512 =\n    Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec {\n        EC = Common::EC::PrimeField::Instantiations::P521,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P384_SHA3_384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the ECDSA_P384_SHA3_384 signature scheme instantiation. The properties should ensure that the signature generation and verification conform to the ECDSA specification instantiated with the P-384 elliptic curve and the SHA3-384 hash function. Include checks for signature validity, message integrity, and key consistency."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA3_384 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P384,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P224_SHA224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the ECDSA_P224_SHA224 instantiation against the ECDSA specification. The properties should check that signatures generated with the P224 elliptic curve and SHA224 hash function conform to the expected signature verification behavior defined in the ECDSA specification module."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA224 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P224,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA224\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P224_SHA3_224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the correctness properties of the ECDSA signature scheme instantiated with the P-224 elliptic curve and SHA3-224 hash function, as given in the module Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA3_224. The specification should include properties such as signature verification correctness, key validity, and hash function integration."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA3_224 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P224,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P384_SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the ECDSA signature scheme instantiated with the P-384 elliptic curve and SHA-384 hash function as given in the module Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA384. The specification should include the types and properties of key generation, signing, and verification functions, ensuring correctness and security properties consistent with the ECDSA standard."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA384 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P384,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA384\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P521_SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected properties and behavior of the ECDSA signature scheme instantiated with the P-521 elliptic curve and SHA-512 hash function, as given in the ECDSA_P521_SHA512 module. The specification should capture correctness, signature verification, and security assumptions relevant to this instantiation."},{"role":"assistant","content":"```cryptol\n\/*\n * Instantiate ECDSA with curve P-521 (also known as secp521p1) and SHA512.\n *\n * Note that this uses `UnconstrainedSpec` because the security strength of the hash\n * function is less than that of the elliptic curve! The overall security strength\n * of this ECDSA instantiation is approximately 256 bits.\n *\n * @copyright Galois, Inc.\n * @author Eric Mertens <emertens@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA512 =\n    Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec {\n        EC = Common::EC::PrimeField::Instantiations::P521,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA512\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P256_SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the correctness properties of the ECDSA signature scheme instantiated with the P-256 elliptic curve and SHA-256 hash function, as given in the module Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA256. The specification should include properties for signature generation and verification, ensuring that valid signatures verify correctly and invalid signatures do not."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA256 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P256,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P256_SHA3_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the ECDSA_P256_SHA3_256 signature scheme instantiated with the P256 elliptic curve and SHA3-256 hash function. The specification should include properties for key generation, signing, and verification, ensuring correctness and security properties consistent with the ECDSA standard."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA3_256 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P256,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/ParameterSets\/XMSS_SHA2_10_256_Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the XMSS_SHA2_10_256 parameter set defined in the given module. The properties should ensure that the hash functions H and H_msg correctly implement the domain-separated SHA256 hashing as per RFC-8391 Section 5.1, that the types n and h match the expected sizes, and that the padding width and OID constants conform to the specification. Include checks for message bounds and the correct construction of input to the hash functions."},{"role":"assistant","content":"```cryptol\n\/**\n * Definition of the approved parameter set used to instantiate\n * `XMSS_SHA2_10_256`.\n * [RFC-8391] Section 5.1.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_Parameters\nwhere\n    import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\n    type n = 32\n    type h = 10\n\n    H KEY M = split (SHA256::hash ((1 : [32 * 8]) # join (KEY # M)))\n\n    \/\/ The maximum message width is defined by SHA256.\n    type MessageUpperBound = SHA256::MessageUpperBound\n\n    \/\/ The padding in this instantiation includes the domain separator (32\n    \/\/ bytes) and the key (3n bytes).\n    type PaddingWidth = (32 * 8) + (3 * n * 8)\n\n    \/\/ The OID as specified in [RFC-8391] Section 8.\n    oid = 0x00000001\n\n    H_msg KEY M = split (SHA256::hash ((2 : [32 * 8]) # join (KEY # M)))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/ParameterSets\/XMSS_SHA2_10_256_FFI_Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and properties of the XMSS_SHA2_10_256_FFI parameter set module, including the hash functions H and H_msg, the message upper bound, padding width, and OID, ensuring compliance with RFC-8391 Section 5.1. Include properties that verify the correct construction of inputs to the SHA256_FFI hash and the correctness of type definitions."},{"role":"assistant","content":"```cryptol\n\/**\n * Definition of the approved parameter set used to instantiate\n * `XMSS_SHA2_10_256_FFI`.\n * [RFC-8391] Section 5.1.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_FFI_Parameters\nwhere\n    \/\/ Use the FFI version of SHA256.\n    import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256_FFI as SHA256\n\n    type n = 32\n    type h = 10\n\n    H KEY M = SHA256::hashBytes (split (1 : [32 * 8]) # KEY # M)\n\n    \/\/ The maximum message width is defined by SHA256.\n    type MessageUpperBound = SHA256::MessageUpperBound\n\n    \/\/ The padding in this instantiation includes the domain separator (32\n    \/\/ bytes) and the key (3n bytes).\n    type PaddingWidth = (32 * 8) + (3 * n * 8)\n\n    \/\/ The OID as specified in [RFC-8391] Section 8.\n    oid = 0x00000001\n\n    H_msg KEY M = SHA256::hashBytes (split (2 : [32 * 8]) # KEY # M)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Instantiations\/XMSS_SHA2_10_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and security properties of the XMSS_SHA2_10_256 module, including its parameter set and WOTS instantiation, suitable for use in formal verification or property-based testing."},{"role":"assistant","content":"```cryptol\n\/**\n * Instantiation of XMSS with the approved parameter set `XMSS_SHA2_10_256`.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256 =\n    Primitive::Asymmetric::Signature::XMSS::Specification {\n        Parameters = Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_Parameters,\n        WOTS = Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256\n\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Instantiations\/XMSS_SHA2_10_256_FFI.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and security properties of the XMSS_SHA2_10_256_FFI instantiation module, including its parameters and WOTS component, suitable for use in formal verification."},{"role":"assistant","content":"```cryptol\n\/**\n * Instantiation of XMSS with the approved parameter set `XMSS_SHA2_10_256_FFI`.\n *\n * @copyright Galois, Inc\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256_FFI =\n    Primitive::Asymmetric::Signature::XMSS::Specification {\n        Parameters = Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_FFI_Parameters,\n        WOTS = Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256_FFI\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/WOTS\/Instantiations\/WOTSP_SHA2_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and security properties of the WOTSP_SHA2_256 one-time signature scheme instantiation, including the functions F' and PRF' as defined using SHA256, and verify that these functions conform to the WOTS+ specification from NIST SP-800-208 and RFC-8391."},{"role":"assistant","content":"```cryptol\n\/**\n * An instantiation of the WOTS+ one-time signature scheme.\n *\n * These parameters and naming are drawn from [SP-800-208], Section 5 (Table 9\n * and Section 5.1). The same parameters are also defined in [RFC-8391]\n * Section 5.1 (SHA2 with `n = 32`).\n *\n * References:\n * [SP-800-208]: David A. Cooper, Daniel C. Apon, Quynh H. Dang, Michael S.\n *     Davidson, Morris J. Dworkin, and Carl A. Miller. Recommendation for\n *     Stateful Hash-Based Signature Schemes. (National Institute of Standards\n *     and Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST\n *     SP 800-208. October 2020.\n *     @see https:\/\/doi.org\/10.6028\/NIST.SP.800-208\n * [RFC-8391]: Andreas Huelsing, Denis Butin, Stefan-Lukas Gazdag, Joost\n *     Rijneveld, and Aziz Mohaisen. XMSS: eXtended Merkle Signature Scheme.\n *     Internet Requests for Comments (RFC) 8391. May 2018.\n *     @see https:\/\/datatracker.ietf.org\/doc\/rfc8391\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\/\nmodule Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256 =\n    Primitive::Asymmetric::Signature::WOTS::Specification where\n        import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\n        type n' = 32\n        type w' = 16\n\n        F' KEY M = SHA256::hashBytes ((zero : [32][8]) # KEY # M)\n        PRF' KEY M = SHA256::hashBytes ((zero : [31][8]) # [(3 : [8])] # KEY # M)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/SphincsPlus\/3.1\/sphincsplus128f.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and properties of the functions H_msg, PRF, PRF_msg, and T in the sphincsplus128f module. The specification should include type signatures, input-output relationships, and key cryptographic properties such as collision resistance or pseudorandomness assumptions where applicable. Ensure the specification is suitable for subsequent verification or property-based testing of the SPHINCS+ signature scheme components implemented in this file."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author Marios Georgiou <marios@galois.com>\n *\/\nmodule sphincsplus128f=specification where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256\n\ntype n = 16\ntype h = 66\ntype d = 22\ntype a = 6\ntype k = 33\ntype loglogw = 2\ntype m = (k*logt+7)\/8 + (h-h\/d+7)\/8 + (h\/d+7)\/8\ntype t = 2^^a\ntype logt = a\n\nH_msg(R, PKseed, PKroot, M) =\n    groupBy(take(shake256(join R # join PKseed # join PKroot # join M)))\nPRF(Seed, ADRS) =\n    groupBy(take(shake256(join Seed # join ADRS)))\nPRF_msg(SKprf, OptRand, M) =\n    groupBy(take(shake256(join SKprf # join OptRand # join M)))\nT(PKseed, ADRS, M) =\n    groupBy(take(shake256(join PKseed # join ADRS # join M)))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/FALCON\/1.2\/falcon_parameterized.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the Falcon signature scheme implementation in the falcon_parameterized module. Include properties that check the correctness of key generation (Keygen), signing (Sign), and verification (Verify) functions, ensuring that signatures produced by Sign with a valid private key verify successfully with the corresponding public key. Also specify properties for the internal polynomial and FFT operations to ensure mathematical consistency and correctness of transformations used in the scheme."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc.\n * @author Marios Georgiou <marios@galois.com>\n *\/\nmodule falcon_parameterized where\n\nparameter\n    type _k : #\n    type _n : #\n    type constraint (fin _k, _n == 2^^_k, _k > 0)\n    type pkbytelen : #\n    type sbytelen : #\n    type constraint (fin sbytelen)\n    type coeffs_number_of_bits : #\n    sigma : Float64\n    type Q = Rational\n    type C = (Float64,Float64)\n    Omega_phi: [_n]C\n    type constraint (8 * sbytelen >= 328)\n\n\ntype slen = 8 * sbytelen - 328\ntype q = 3 * 2^^12 + 1\n\ntype Byte = [8]Bit\ntype ZZ = Integer\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nCMul : (C, C) -> C\nCMul(x, y) = (x.0*y.0-x.1*y.1, x.0*y.1+x.1*y.0)\n\nCAdd : (C, C) -> C\nCAdd(x, y) = (x.0 + x.1, y.0 + y.1)\n\nCAddList : {n} (fin n) => [n]C -> C\nCAddList(l) = sums ! 0\n    where sums = [zero] # [CAdd(el,sums') | el <- l\n                                          | sums' <- sums\n                          ]\n\nCinv : C -> C\nCinv((a,b)) = (a\/.denominator, -(b\/.denominator)) where\n    denominator = a^^2 + b^^2\n\nConjugate : C -> C\nConjugate((x, y)) = (x, -y)\n\nPolyConj : {k, n} (ispoweroftwo k n) => Poly n C -> Poly n C\nPolyConj(f) = map Conjugate f\n\nNormalize_FFT : {k, n} (ispoweroftwo k n) => (Float64, Poly n C) -> Poly n C\nNormalize_FFT(_q, F) = dot(F, [Cinv(_q,0) | i <- [0 .. (n-1)]])\n\ntype constraint ispoweroftwo a b = (fin a, b == 2^^a)\n\ntype constraint positive_power a = (fin a, a > 0, (2*(2^^(a-1)*a)+2^^a == 2^^a*(1+a)), 2 ^^ a == 2 * 2 ^^ (a - 1))\n\n\/\/ helper function for recursive functions. Will be removed\n\/\/ when Cryptol is updated.\nresize : {m,n,a} (fin m, fin n, Zero a) => [m]a -> [n]a\nresize xs = take`{n} (xs # repeat`{inf} zero)\n\n\n\nFFT : {k, n} (ispoweroftwo k n) => Poly n C -> FFT n\nFFT(x) | k == 0 => x\n       | k >  0 => resize(join([result0,result1])) where\n            even = [x@(2*i  ) | i <- [0 .. (2^^(k-1)-1)]]\n            odd =  [x@(2*i+1) | i <- [0 .. (2^^(k-1)-1)]]\n            left = FFT`{k-1}(even)\n            right = FFT`{k-1}(odd)\n            X = join([left,right])\n            result0 = [X@i + CMul(Omega_phi@(`n*i),(X@(i+`n\/2))) | i <- [0 .. (n\/2-1)]]\n            result1 = [X@i - CMul(Omega_phi@(`n*i),(X@(i+`n\/2))) | i <- [0 .. (n\/2-1)]]\n\nFFTInv  : {k, n} (ispoweroftwo k n) => (FFT n) -> (Poly n C)\nFFTInv(x) = zero\n\n\nFFT' : {k, n} (ispoweroftwo k n) => Poly n ZZ -> FFT n\nFFT'(x) = FFT`{k}(map IntToCmplx x : (Poly n C))\n\nFFT'' : {k, n} (ispoweroftwo k n) => Poly n (Z q) -> FFT n\nFFT''(x) = FFT'`{k}(map fromZ x)\n\n\/\/ Number Theoretic Transform\nNTT : {k, n} (ispoweroftwo k n) => Poly n (Z q) -> Poly n (Z q)\nNTT(f) = zero\n\nNTTInv : {k, n} (ispoweroftwo k n) => Poly n (Z q) -> Poly n (Z q)\nNTTInv(f) = zero\n\nModInv : Z q -> Z q\nModInv(f) =  1\/. f\n\nphi : {k, n} (ispoweroftwo k n) => Poly (n+1) (Z q)\nphi = [1]#zero#[1]\n\nIntToCmplx : ZZ -> C\nIntToCmplx(x) = ((fromInteger x),zero)\n\ndot : {n} (fin n) => (FFT n, FFT n) -> FFT n\ndot(f,g) = [CMul(fi,gi) | fi <- f | gi <- g]\n\nHadamardDivision : {n} (fin n) => (FFT n, FFT n) -> FFT n\nHadamardDivision(f,g) = dot(f, (map Cinv g))\n\nPolyMul : {k, n} (ispoweroftwo k n) => ((Poly n C), (Poly n C)) -> (Poly n C)\nPolyMul(f,g) = FFTInv`{k}(dot(FFT`{k}(f), FFT`{k}(g)))\n\nPolyInv : {k, n} (ispoweroftwo k n) => (Poly n C) -> (Poly n C)\nPolyInv(f) = FFTInv`{k}(map Cinv (FFT`{k}(f)))\n\nPolyMulInZ : {k, n} (ispoweroftwo k n) => ((Poly n ZZ), (Poly n ZZ)) -> (Poly n ZZ)\nPolyMulInZ(f, g) = zero PolyDivInZ : {k, n} (ispoweroftwo k n) => ((Poly n ZZ), (Poly n ZZ)) -> (Poly n Q)\nPolyDivInZ(f, g) = zero innerProduct : {k, n} (ispoweroftwo k n) => ((Poly n C), (Poly n C)) -> C\ninnerProduct(f, g) = zero norm_sq : {k, n} (ispoweroftwo k n) => (Poly n C) -> Float64\nnorm_sq(f) = zero splitfft : {k, n} (ispoweroftwo k n, n > 2) => (FFT n) -> [2](FFT (n\/2))\nsplitfft FFTf = [resize(FFTf0), resize(FFTf1)] where\n    FFTf0 = [FFTf@(2*i  ) | i <- [0 .. (2^^(k-1)-1)]]\n    FFTf1 = [FFTf@(2*i+1) | i <- [0 .. (2^^(k-1)-1)]]\n\nmergefft : {k, n} (ispoweroftwo k n, n>=2) => [2](FFT (n\/2)) -> (FFT n)\nmergefft ([f0, f1]) = resize FFTf where\n    FFTf = join[[f0@i,f1@i] | i <- [0 .. (2^^(k-1)-1)]]\n\ntype Poly degree a = [degree]a\n\ntype FFT degree = Poly degree C\ntype NTT degree = Poly degree (Z q)\n\n\/\/ public key types\ntype publicKey = Poly _n (Z q)\ntype encodedPublicKey = [14 * _n \/^ 8 + 1]Byte\n\n\/\/ private key types\ntype privateKey = ([2][2](FFT _n), falconTree _k)\ntype encodedPrivateKey = [2*((_n+1)*coeffs_number_of_bits) + ((_n+1)*8)]Bit\n\ntype falconTree k = [2^^k*(1+k)]C\n\ngetValue : {k, n} (ispoweroftwo k n) => falconTree k -> Poly n C\ngetValue T = take`{n} T\n\n\/\/ getChildren: {k, n} (ispoweroftwo k n, positive_power k) => falconTree k -> (falconTree (k-1), falconTree (k-1))\n\/\/ getChildren T = children where\n\/\/     children = split`{2,2^^(k-1)*k} (drop`{n} T)\n\nget_leftchild : {k, n} (ispoweroftwo k n, k > 0) => falconTree k -> falconTree (k-1)\nget_leftchild T = left where\n    children = resize (drop`{n} T): [2*2^^(k-1)*k]C\n    [left, right] = split`{2,2^^(k-1)*k} children\n\nget_rightchild : {k, n} (ispoweroftwo k n, k > 0) => falconTree k -> falconTree (k-1)\nget_rightchild T = right where\n    children = resize (drop`{n} T): [2*2^^(k-1)*k]C\n    [left, right] = split`{2,2^^(k-1)*k} children\n\nnewTree : {k, n} (ispoweroftwo k n, k >= 1) => (Poly n C, falconTree (k-1), falconTree (k-1)) -> falconTree k\nnewTree(value, leftchild, rightchild) = T where\n    T = zero\n\n\/\/ The leaves contain real numbers\n\/\/ For consistency their type is C\nnewLeaf : C -> falconTree 0\nnewLeaf sigma_leaf = [sigma_leaf]\n\nget_leaves : {k, n} (ispoweroftwo k n) => falconTree k -> [2^^k]C\nget_leaves T | k == 0 => T\n             | k >  0 => resize leaves where\n                left_child = get_leftchild`{k} T : falconTree (k-1)\n                right_child = get_rightchild`{k} T : falconTree (k-1)\n                left_leaves  = get_leaves`{k-1} left_child : [2^^(k-1)]C\n                right_leaves  = get_leaves`{k-1} right_child : [2^^(k-1)]C\n                leaves = left_leaves # right_leaves : [2*2^^(k-1)]C\n\nset_leaves : {k, n} (ispoweroftwo k n) => (falconTree k, [2^^k]C) -> falconTree k\nset_leaves(T, leaves) | k == 0 => leaves\n                      | k >  0 => newTree`{k}(value, newleftchild, newrightchild) where\n                        value = getValue`{k} T\n                        leftchild = get_leftchild`{k} T\n                        rightchild = get_rightchild`{k} T\n                        [leftleaves, rightleaves] = split`{2,2^^(k-1)} (resize leaves)\n                        newleftchild = set_leaves`{k-1}(leftchild, leftleaves)\n                        newrightchild = set_leaves`{k-1}(rightchild, rightleaves)\n\nCompress : Poly _n ZZ -> [slen]\nCompress s = zero\n\nDecompress : [slen] -> Poly _n ZZ\nDecompress str = zero\n\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256\nHashToPoint : {q', k, n, len} (q' <= 2^^16, q' >= 1, ispoweroftwo k n, fin len) => [len] -> Poly n (Z q')\nHashToPoint str = [c i | i <- [0..(n-1)]] where\n    k = 2^^16 \/ `q\n    c i = fromInteger(t i % `q)\n    t i = zero \/\/ phi and q are fixed so we do not parameterize this algorithm\n\/\/ f and g cannot be sampled in Cryptol so we take them as input\nKeygen : (Poly _n ZZ, Poly _n ZZ) -> (privateKey, publicKey)\nKeygen (f', g') = (sk, pk) where\n    (f, g, F, G) = NTRUGen(f', g'): (Poly _n ZZ, Poly _n ZZ, Poly _n ZZ, Poly _n ZZ)\n    B = [[map IntToCmplx g,map IntToCmplx (-f)],[map IntToCmplx G,map IntToCmplx (-F)]] : [2][2](Poly _n C)\n    Bhat = [[FFT'`{_k}(g),FFT'`{_k}(-f)],[FFT'`{_k}(G),FFT'`{_k}(-F)]] : [2][2](FFT _n)\n    GG = B * Bhat\n    T = ffLDL`{_k}(GG)\n    leaves = get_leaves`{_k} T\n    new_leaves = [(sigma\/.r_leaf,0) | (r_leaf, _) <- leaves]\n    T' = set_leaves`{_k}(T, new_leaves)\n    sk = (Bhat, T')\n    h = NTTInv`{_k}(NTT`{_k}(map fromInteger g)*(map ModInv (NTT`{_k}(map fromInteger f))))\n    pk = h\n\nN : {k, n} (ispoweroftwo k n, k > 0) => (Poly n ZZ) -> (Poly (2^^(k-1)) ZZ)\nN(f) = zero\n\nxSquared : {k, n} (ispoweroftwo k n) => (Poly n ZZ) -> (Poly (2^^(k+1)) ZZ)\nxSquared(F) = resize (join[[c,0] | c <- F])\n\nminusx : {k, n} (ispoweroftwo k n) => (Poly n ZZ) -> (Poly n ZZ)\nminusx(g) = resize (join[ [g@i, -(g@(i+1))] | i <- [0, 2 .. (n-1)]])\n\n\/\/ phi and q are fixed so we do not parameterize this algorithm\n\/\/ f and g cannot be sampled in Cryptol so we take them as input\n\/\/ We assume they pass conditions in lines 7 and 9\nNTRUGen : (Poly _n ZZ, Poly _n ZZ) -> (Poly _n ZZ, Poly _n ZZ, Poly _n ZZ, Poly _n ZZ)\nNTRUGen(f, g) = (f, g, F, G) where\n    (F, G) = NTRUSolve`{_k}(f, g)\n\nNTRUSolve : {k, n} (ispoweroftwo k n) => (Poly n ZZ, Poly n ZZ) -> (Poly n ZZ, Poly n ZZ)\nNTRUSolve(f, g) | k == 0 => ([F], [G]) where\n                                (gcd, u, v) = eGCD(f@0, g@0)\n                                (F, G) = (u*`q, v*`q)\n                | k >  0 => (_F, _G) where\n                                f' = N`{k}(f)\n                                g' = N`{k}(g)\n                                (F', G') = NTRUSolve`{k-1}(f',g')\n                                F = PolyMulInZ`{k}(xSquared`{k-1}(F'), minusx`{k}(g))\n                                G = PolyMulInZ`{k}(xSquared`{k-1}(G'), minusx`{k}(f))\n                                (_F, _G) = Reduce`{k}(f,g,F,G)\n\neGCD : (ZZ, ZZ) -> (ZZ, ZZ, ZZ)\neGCD(a, b) =\n    if a == 0\n    then (b, 0, 1)\n    else (g, t - (b \/ a) * s, s) where\n        (g, s, t) = eGCD((b%a), a)\n\nReduce : {k, n} (ispoweroftwo k n) => (Poly n ZZ, Poly n ZZ, Poly n ZZ, Poly n ZZ) -> (Poly n ZZ, Poly n ZZ)\nReduce(f,g,F,G) = (_F, _G) where\n    numerator = PolyMulInZ`{k}(F, adjoint`{k}(f)) + PolyMulInZ`{k}(G, adjoint`{k}(g))\n    denominator = PolyMulInZ`{k}(f, adjoint`{k}(f)) + PolyMulInZ`{k}(g, adjoint`{k}(g))\n    _k = map roundToEven (PolyDivInZ`{k}(numerator, denominator)): Poly n ZZ\n    F' = F - PolyMulInZ`{k}(_k,f)\n    G' = G - PolyMulInZ`{k}(_k, g)\n    (_F, _G, _) = Reduce'`{k}(_k,f,g,F',G')\n\nadjoint : {k, n} (ispoweroftwo k n) => (Poly n ZZ) -> (Poly n ZZ)\nadjoint(f) = reverse f\n\nReduce' : {k, n} (ispoweroftwo k n) => (Poly n ZZ, Poly n ZZ, Poly n ZZ, Poly n ZZ, Poly n ZZ) -> (Poly n ZZ, Poly n ZZ, Poly n ZZ)\nReduce'(_k,f,g,F,G) =\n    if _k == zero\n    then (F, G, _k)\n    else Reduce'`{k}(_k', f, g, F', G') where\n        numerator = PolyMulInZ`{k}(F, adjoint`{k}(f)) + PolyMulInZ`{k}(G, adjoint`{k}(g))\n        denominator = PolyMulInZ`{k}(f, adjoint`{k}(f)) + PolyMulInZ`{k}(g, adjoint`{k}(g))\n        _k' = map roundToEven (PolyDivInZ`{k}(numerator, denominator)): Poly n ZZ\n        F' = F - PolyMulInZ`{k}(_k',f)\n        G' = G - PolyMulInZ`{k}(_k', g)\n\none : {k, n} (ispoweroftwo k n) => FFT n\none = [(1.0,0.0) | i <- [0 .. (n-1)]]\n\nLDL : {k, n} (ispoweroftwo k n) => [2][2](FFT n) -> (([2][2](FFT n)), ([2][2](FFT n)))\nLDL(G) = (L, D) where\n    D00 = G@0@0\n    L10 = HadamardDivision(G@1@0,G@0@0): FFT n\n    D11 = G@1@1 - dot(L10,dot(PolyConj`{k}(L10),G@0@0))\n    L = [[one`{k}, zero],[L10, one`{k}]]\n    D = [[D00, zero],[zero, D11]]\n\nffLDL : {k, n} (ispoweroftwo k n, n >= 2) => ([2][2](FFT n)) -> (falconTree k)\nffLDL(G) | k == 1 => T where\n            (L, D) = LDL`{k}(G) : ([2][2](FFT n), [2][2](FFT n))\n            left_child = D@0@0 : FFT 2\n            left_leaf = newLeaf(left_child@0)             right_child = D@1@1 : FFT 2\n            right_leaf = newLeaf(right_child@0)             T = newTree`{k}(L@1@0, left_leaf, right_leaf)\n         | k >  1 => T where\n            (L, D) = LDL`{k}(G) : ([2][2](FFT n), [2][2](FFT n))\n            [d00, d01] = splitfft`{k}(D@0@0)\n            [d10, d11] = splitfft`{k}(D@1@1)\n            G0 = [[resize d00,resize d01],[resize d01, resize d00]]             G1 = [[resize d10,resize d11],[resize d11, resize d10]]\n            Tleftchild = ffLDL`{k-1}(G0)\n            Trightchild = ffLDL`{k-1}(G1)\n            T = newTree`{k}(L@1@0, Tleftchild, Trightchild)\n\n\ntype signature = ([320], [slen])\nSign : {len} (fin len) => ([len], privateKey, Integer, [320]) -> signature\nSign(m, sk, beta, r) = zero where\n    (Bhat, T) = sk\n    c = HashToPoint`{q,_k}(r#m)\n    [[FFTg,FFT_f],[FFTG,FFT_F]] = Bhat \/\/ Bhat stores them in FFT representation (some are negated)\n    t0 = Normalize_FFT`{_k}(`q, dot(FFT''`{_k,_n}(c),FFT_F))\n    t1 = Normalize_FFT`{_k}(`q, dot(FFT''`{_k,_n}(c),FFT_F))\n    tt = [t0, t1] : [2](FFT _n)\n    s_init : [slen]\n    s_init = zero\n    is_bot : [slen] -> Bit\n    is_bot(_s) = (_s == zero)\n    body' : [slen] -> [slen]\n    body'(_s) = zero where\n        ss_init = zero : FFT _n\n        norm_greater_than_beta : FFT _n -> Bit\n        norm_greater_than_beta(_ss) = norm_sq`{_k}(_ss) > (fromInteger beta)\n        body'' : FFT _n -> FFT _n\n        body''(_ss) = zero where\n            zz = ffSampling`{_k}(tt, T) : [2](FFT _n)\n            \/\/ _ss' = [ dot`{_n}((tt_ - zz_),Bhat_) | tt_ <- tt | zz_ <- zz | Bhat_ <- Bhat]\n        _ss_final = dowhile norm_greater_than_beta body'' ss_init\n    s_final = dowhile is_bot body' s_init\n\n\n\nffSampling : {k, n} (ispoweroftwo k n) => ([2](FFT n), falconTree k) -> [2](FFT n)\nffSampling(t, T) = z where\n    [t0, t1] = t\n    z = [z0, z1]\n    z0 = zero\n    z1 = zero\n\nRCDT = [\n    3024686241123004913666,\n    1564742784480091954050,\n    636254429462080897535,\n    199560484645026482916,\n    47667343854657281903,\n    8595902006365044063,\n    1163297957344668388,\n    117656387352093658,\n    8867391802663976,\n    496969357462633,\n    20680885154299,\n    638331848991,\n    14602316184,\n    247426747,\n    3104126,\n    28824,\n    198,\n    1,\n    0\n] : [19][72]\n\nBaseSampler : [72] -> ZZ\nBaseSampler(u) = z0 where\n    z0 = zero\n\nimport Float\nApproxExp : (Float64, Float64) -> [64]\nApproxExp(x, ccs) = y'' where\n    C = [\n            0x00000004741183A3,\n            0x00000036548CFC06,\n            0x0000024FDCBF140A,\n            0x0000171D939DE045,\n            0x0000D00CF58F6F84,\n            0x000680681CF796E3,\n            0x002D82D8305B0FEA,\n            0x011111110E066FD0,\n            0x0555555555070F00,\n            0x155555555581FF00,\n            0x400000000002B400,\n            0x7FFFFFFFFFFF4800,\n            0x8000000000000000\n        ]\n    y = C@0\n    z = fromInteger (floor(2^^63 * x))\n    y' = foldl (\\yy -> \\u -> C@u - (z*y)>>63) y [1 .. 12]\n    z' = fromInteger (floor(2^^63 * ccs))\n    y'' = (z'*y')>>63\n\nBerExp : (Float64, Float64) -> Bit\nBerExp(x, ccs) = w < 0 where\n    ln2 = 0.69314718056\n    s = x \/. ln2\n    r = floor(x - s * ln2)\n    s' = min(s, 63)\n        w = zero\n\nSamplerZ : (Float64, Float64) -> ZZ\nSamplerZ(m, sigma') = z where\n    z = zero\n\nVerify : {len} (fin len) => ([len], signature, publicKey, Integer) -> Bit\nVerify(m, sig, pk, beta) = norm^^2 <= beta where\n    norm = zero\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/FALCON\/1.2\/falcon_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the Falcon-512 signature scheme implementation in the provided falcon_512.cry file. Include properties that check key generation, signing, and verification functions for consistency and correctness according to the Falcon-512 specification."},{"role":"assistant","content":"```cryptol\n\/**\n * @copyright Galois, Inc\n * @author Marios Georgiou <marios@galois.com>\n *\/\nmodule falcon_512 where\n\nsubmodule falcon_inst = spec2\n    where\n    type _k = 9\n    type _n = 512\n    type pkbytelen = 897\n    type sbytelen = 666\n    type coeffs_number_of_bits = 6\n    type q = 3 * 2^^12 + 1\n    r = 3\n    sigma = 165.736617183\n    sigma_min = 1.277833697\n    sigma_max = 1.8205\n    beta = 34034726\n\n    Omega_phi = [\n        (1, 0),\n        (0.9999247018391445, 0.012271538285719925),\n        (0.9996988186962042, 0.024541228522912288),\n        (0.9993223845883495, 0.03680722294135883),\n        (0.9987954562051724, 0.049067674327418015),\n        (0.9981181129001492, 0.06132073630220858),\n        (0.9972904566786902, 0.07356456359966743),\n        (0.996312612182778, 0.0857973123444399),\n        (0.9951847266721969, 0.0980171403295606),\n        (0.9939069700023561, 0.11022220729388306),\n        (0.99247953459871, 0.1224106751992162),\n        (0.99090263542778, 0.13458070850712617),\n        (0.989176509964781, 0.14673047445536175),\n        (0.9873014181578584, 0.15885814333386145),\n        (0.9852776423889412, 0.17096188876030122),\n        (0.9831054874312163, 0.18303988795514095),\n        (0.9807852804032304, 0.19509032201612825),\n        (0.9783173707196277, 0.20711137619221856),\n        (0.9757021300385286, 0.2191012401568698),\n        (0.9729399522055602, 0.2310581082806711),\n        (0.970031253194544, 0.24298017990326387),\n        (0.9669764710448521, 0.25486565960451457),\n        (0.9637760657954398, 0.26671275747489837),\n        (0.9604305194155658, 0.27851968938505306),\n        (0.9569403357322088, 0.29028467725446233),\n        (0.9533060403541939, 0.3020059493192281),\n        (0.9495281805930367, 0.3136817403988915),\n        (0.9456073253805213, 0.3253102921622629),\n        (0.9415440651830208, 0.33688985339222005),\n        (0.937339011912575, 0.34841868024943456),\n        (0.932992798834739, 0.3598950365349881),\n        (0.9285060804732156, 0.37131719395183754),\n        (0.9238795325112867, 0.3826834323650898),\n        (0.9191138516900578, 0.3939920400610481),\n        (0.9142097557035307, 0.40524131400498986),\n        (0.9091679830905224, 0.41642956009763715),\n        (0.9039892931234433, 0.4275550934302821),\n        (0.8986744656939538, 0.43861623853852766),\n        (0.8932243011955153, 0.44961132965460654),\n        (0.8876396204028539, 0.46053871095824),\n        (0.881921264348355, 0.47139673682599764),\n        (0.8760700941954066, 0.4821837720791227),\n        (0.8700869911087115, 0.49289819222978404),\n        (0.8639728561215867, 0.5035383837257176),\n        (0.8577286100002721, 0.5141027441932217),\n        (0.8513551931052652, 0.524589682678469),\n        (0.8448535652497071, 0.5349976198870972),\n        (0.838224705554838, 0.5453249884220465),\n        (0.8314696123025452, 0.5555702330196022),\n        (0.8245893027850253, 0.5657318107836131),\n        (0.8175848131515837, 0.5758081914178453),\n        (0.8104571982525948, 0.5857978574564389),\n        (0.8032075314806449, 0.5956993044924334),\n        (0.7958369046088836, 0.6055110414043255),\n        (0.7883464276266063, 0.6152315905806268),\n        (0.7807372285720945, 0.6248594881423863),\n        (0.773010453362737, 0.6343932841636455),\n        (0.765167265622459, 0.6438315428897914),\n        (0.7572088465064846, 0.6531728429537768),\n        (0.7491363945234594, 0.6624157775901718),\n        (0.7409511253549592, 0.6715589548470183),\n        (0.7326542716724128, 0.680600997795453),\n        (0.724247082951467, 0.6895405447370668),\n        (0.7157308252838186, 0.6983762494089729),\n        (0.7071067811865476, 0.7071067811865475),\n        (0.6983762494089729, 0.7157308252838186),\n        (0.6895405447370669, 0.7242470829514669),\n        (0.6806009977954531, 0.7326542716724127),\n        (0.6715589548470184, 0.740951125354959),\n        (0.6624157775901718, 0.7491363945234593),\n        (0.6531728429537769, 0.7572088465064845),\n        (0.6438315428897915, 0.7651672656224588),\n        (0.6343932841636456, 0.7730104533627369),\n        (0.6248594881423865, 0.7807372285720944),\n        (0.6152315905806269, 0.7883464276266062),\n        (0.6055110414043255, 0.7958369046088835),\n        (0.5956993044924335, 0.8032075314806448),\n        (0.5857978574564389, 0.8104571982525948),\n        (0.5758081914178454, 0.8175848131515837),\n        (0.5657318107836132, 0.8245893027850253),\n        (0.5555702330196023, 0.8314696123025451),\n        (0.5453249884220466, 0.838224705554838),\n        (0.5349976198870974, 0.844853565249707),\n        (0.524589682678469, 0.8513551931052652),\n        (0.5141027441932218, 0.8577286100002721),\n        (0.5035383837257176, 0.8639728561215867),\n        (0.49289819222978415, 0.8700869911087113),\n        (0.4821837720791229, 0.8760700941954065),\n        (0.4713967368259978, 0.8819212643483549),\n        (0.46053871095824, 0.8876396204028539),\n        (0.4496113296546066, 0.8932243011955153),\n        (0.4386162385385277, 0.8986744656939538),\n        (0.4275550934302822, 0.9039892931234433),\n        (0.4164295600976373, 0.9091679830905224),\n        (0.4052413140049898, 0.9142097557035307),\n        (0.3939920400610481, 0.9191138516900578),\n        (0.38268343236508984, 0.9238795325112867),\n        (0.3713171939518376, 0.9285060804732155),\n        (0.3598950365349883, 0.9329927988347388),\n        (0.3484186802494345, 0.937339011912575),\n        (0.33688985339222005, 0.9415440651830208),\n        (0.325310292162263, 0.9456073253805213),\n        (0.3136817403988915, 0.9495281805930367),\n        (0.3020059493192282, 0.9533060403541938),\n        (0.2902846772544623, 0.9569403357322089),\n        (0.27851968938505306, 0.9604305194155658),\n        (0.2667127574748984, 0.9637760657954398),\n        (0.2548656596045146, 0.9669764710448521),\n        (0.24298017990326398, 0.970031253194544),\n        (0.23105810828067125, 0.9729399522055601),\n        (0.21910124015686977, 0.9757021300385286),\n        (0.20711137619221856, 0.9783173707196277),\n        (0.1950903220161283, 0.9807852804032304),\n        (0.18303988795514103, 0.9831054874312163),\n        (0.17096188876030136, 0.9852776423889412),\n        (0.1588581433338614, 0.9873014181578584),\n        (0.14673047445536175, 0.989176509964781),\n        (0.13458070850712622, 0.99090263542778),\n        (0.12241067519921628, 0.99247953459871),\n        (0.11022220729388318, 0.9939069700023561),\n        (0.09801714032956077, 0.9951847266721968),\n        (0.08579731234443988, 0.996312612182778),\n        (0.07356456359966745, 0.9972904566786902),\n        (0.061320736302208655, 0.9981181129001492),\n        (0.04906767432741813, 0.9987954562051724),\n        (0.03680722294135899, 0.9993223845883495),\n        (0.024541228522912267, 0.9996988186962042),\n        (0.012271538285719944, 0.9999247018391445),\n        (6.123233995736766e-17, 1.0),\n        (-0.012271538285719823, 0.9999247018391445),\n        (-0.024541228522912142, 0.9996988186962042),\n        (-0.036807222941358866, 0.9993223845883495),\n        (-0.04906767432741801, 0.9987954562051724),\n        (-0.06132073630220853, 0.9981181129001492),\n        (-0.07356456359966734, 0.9972904566786902),\n        (-0.08579731234443977, 0.996312612182778),\n        (-0.09801714032956066, 0.9951847266721969),\n        (-0.11022220729388307, 0.9939069700023561),\n        (-0.12241067519921617, 0.99247953459871),\n        (-0.1345807085071261, 0.99090263542778),\n        (-0.14673047445536164, 0.989176509964781),\n        (-0.15885814333386128, 0.9873014181578584),\n        (-0.17096188876030124, 0.9852776423889412),\n        (-0.18303988795514095, 0.9831054874312163),\n        (-0.1950903220161282, 0.9807852804032304),\n        (-0.20711137619221845, 0.9783173707196277),\n        (-0.21910124015686966, 0.9757021300385286),\n        (-0.23105810828067117, 0.9729399522055602),\n        (-0.24298017990326387, 0.970031253194544),\n        (-0.2548656596045145, 0.9669764710448521),\n        (-0.2667127574748983, 0.9637760657954398),\n        (-0.27851968938505295, 0.9604305194155659),\n        (-0.2902846772544622, 0.9569403357322089),\n        (-0.3020059493192281, 0.9533060403541939),\n        (-0.31368174039889146, 0.9495281805930367),\n        (-0.32531029216226287, 0.9456073253805214),\n        (-0.33688985339221994, 0.9415440651830208),\n        (-0.3484186802494344, 0.937339011912575),\n        (-0.35989503653498817, 0.9329927988347388),\n        (-0.37131719395183754, 0.9285060804732156),\n        (-0.3826834323650897, 0.9238795325112867),\n        (-0.393992040061048, 0.9191138516900578),\n        (-0.40524131400498975, 0.9142097557035307),\n        (-0.416429560097637, 0.9091679830905225),\n        (-0.42755509343028186, 0.9039892931234434),\n        (-0.4386162385385274, 0.8986744656939539),\n        (-0.4496113296546067, 0.8932243011955152),\n        (-0.4605387109582401, 0.8876396204028539),\n        (-0.4713967368259977, 0.881921264348355),\n        (-0.4821837720791227, 0.8760700941954066),\n        (-0.4928981922297839, 0.8700869911087115),\n        (-0.5035383837257175, 0.8639728561215868),\n        (-0.5141027441932216, 0.8577286100002721),\n        (-0.5245896826784687, 0.8513551931052652),\n        (-0.5349976198870969, 0.8448535652497072),\n        (-0.5453249884220461, 0.8382247055548382),\n        (-0.555570233019602, 0.8314696123025455),\n        (-0.5657318107836132, 0.8245893027850253),\n        (-0.5758081914178453, 0.8175848131515837),\n        (-0.5857978574564389, 0.8104571982525948),\n        (-0.5956993044924332, 0.8032075314806449),\n        (-0.6055110414043254, 0.7958369046088836),\n        (-0.6152315905806267, 0.7883464276266063),\n        (-0.6248594881423862, 0.7807372285720946),\n        (-0.6343932841636453, 0.7730104533627371),\n        (-0.6438315428897913, 0.7651672656224591),\n        (-0.6531728429537765, 0.7572088465064848),\n        (-0.6624157775901718, 0.7491363945234593),\n        (-0.6715589548470184, 0.740951125354959),\n        (-0.680600997795453, 0.7326542716724128),\n        (-0.6895405447370668, 0.724247082951467),\n        (-0.6983762494089728, 0.7157308252838187),\n        (-0.7071067811865475, 0.7071067811865476),\n        (-0.7157308252838186, 0.6983762494089729),\n        (-0.7242470829514669, 0.689540544737067),\n        (-0.7326542716724127, 0.6806009977954532),\n        (-0.7409511253549589, 0.6715589548470186),\n        (-0.749136394523459, 0.662415777590172),\n        (-0.7572088465064847, 0.6531728429537766),\n        (-0.765167265622459, 0.6438315428897914),\n        (-0.773010453362737, 0.6343932841636455),\n        (-0.7807372285720945, 0.6248594881423863),\n        (-0.7883464276266062, 0.6152315905806269),\n        (-0.7958369046088835, 0.6055110414043255),\n        (-0.8032075314806448, 0.5956993044924335),\n        (-0.8104571982525947, 0.585797857456439),\n        (-0.8175848131515836, 0.5758081914178454),\n        (-0.8245893027850251, 0.5657318107836135),\n        (-0.8314696123025453, 0.5555702330196022),\n        (-0.8382247055548381, 0.5453249884220464),\n        (-0.8448535652497071, 0.5349976198870972),\n        (-0.8513551931052652, 0.524589682678469),\n        (-0.8577286100002721, 0.5141027441932218),\n        (-0.8639728561215867, 0.5035383837257176),\n        (-0.8700869911087113, 0.49289819222978415),\n        (-0.8760700941954065, 0.4821837720791229),\n        (-0.8819212643483549, 0.4713967368259978),\n        (-0.8876396204028538, 0.4605387109582402),\n        (-0.8932243011955152, 0.4496113296546069),\n        (-0.8986744656939539, 0.43861623853852755),\n        (-0.9039892931234433, 0.42755509343028203),\n        (-0.9091679830905224, 0.41642956009763715),\n        (-0.9142097557035307, 0.40524131400498986),\n        (-0.9191138516900578, 0.39399204006104815),\n        (-0.9238795325112867, 0.38268343236508984),\n        (-0.9285060804732155, 0.37131719395183765),\n        (-0.9329927988347388, 0.35989503653498833),\n        (-0.9373390119125748, 0.3484186802494348),\n        (-0.9415440651830207, 0.3368898533922203),\n        (-0.9456073253805213, 0.3253102921622632),\n        (-0.9495281805930367, 0.3136817403988914),\n        (-0.9533060403541939, 0.30200594931922803),\n        (-0.9569403357322088, 0.29028467725446233),\n        (-0.9604305194155658, 0.2785196893850531),\n        (-0.9637760657954398, 0.2667127574748985),\n        (-0.9669764710448521, 0.2548656596045147),\n        (-0.970031253194544, 0.24298017990326404),\n        (-0.9729399522055601, 0.2310581082806713),\n        (-0.9757021300385285, 0.21910124015687002),\n        (-0.9783173707196275, 0.20711137619221884),\n        (-0.9807852804032304, 0.19509032201612858),\n        (-0.9831054874312164, 0.1830398879551409),\n        (-0.9852776423889412, 0.1709618887603012),\n        (-0.9873014181578584, 0.15885814333386145),\n        (-0.989176509964781, 0.1467304744553618),\n        (-0.99090263542778, 0.13458070850712628),\n        (-0.99247953459871, 0.12241067519921635),\n        (-0.9939069700023561, 0.11022220729388325),\n        (-0.9951847266721968, 0.09801714032956084),\n        (-0.996312612182778, 0.08579731234444016),\n        (-0.9972904566786902, 0.07356456359966775),\n        (-0.9981181129001492, 0.061320736302208495),\n        (-0.9987954562051724, 0.04906767432741797),\n        (-0.9993223845883495, 0.03680722294135883),\n        (-0.9996988186962042, 0.024541228522912326),\n        (-0.9999247018391445, 0.012271538285720007),\n        (-1.0, 1.2246467991473532e-16),\n        (-0.9999247018391445, -0.01227153828571976),\n        (-0.9996988186962042, -0.024541228522912083),\n        (-0.9993223845883495, -0.03680722294135858),\n        (-0.9987954562051724, -0.049067674327417724),\n        (-0.9981181129001492, -0.061320736302208245),\n        (-0.9972904566786902, -0.0735645635996675),\n        (-0.996312612182778, -0.08579731234443992),\n        (-0.9951847266721969, -0.09801714032956059),\n        (-0.9939069700023561, -0.110222207293883),\n        (-0.99247953459871, -0.1224106751992161),\n        (-0.99090263542778, -0.13458070850712606),\n        (-0.989176509964781, -0.14673047445536158),\n        (-0.9873014181578584, -0.15885814333386122),\n        (-0.9852776423889413, -0.17096188876030097),\n        (-0.9831054874312164, -0.18303988795514067),\n        (-0.9807852804032304, -0.19509032201612836),\n        (-0.9783173707196277, -0.20711137619221862),\n        (-0.9757021300385286, -0.21910124015686983),\n        (-0.9729399522055602, -0.2310581082806711),\n        (-0.970031253194544, -0.24298017990326382),\n        (-0.9669764710448522, -0.25486565960451446),\n        (-0.96377606579544, -0.26671275747489825),\n        (-0.9604305194155659, -0.2785196893850529),\n        (-0.9569403357322089, -0.29028467725446216),\n        (-0.953306040354194, -0.3020059493192278),\n        (-0.9495281805930368, -0.3136817403988912),\n        (-0.9456073253805213, -0.32531029216226304),\n        (-0.9415440651830208, -0.3368898533922201),\n        (-0.937339011912575, -0.34841868024943456),\n        (-0.932992798834739, -0.3598950365349881),\n        (-0.9285060804732156, -0.3713171939518375),\n        (-0.9238795325112867, -0.38268343236508967),\n        (-0.9191138516900578, -0.39399204006104793),\n        (-0.9142097557035307, -0.4052413140049897),\n        (-0.9091679830905225, -0.41642956009763693),\n        (-0.9039892931234434, -0.4275550934302818),\n        (-0.898674465693954, -0.4386162385385273),\n        (-0.8932243011955153, -0.44961132965460665),\n        (-0.8876396204028539, -0.46053871095824006),\n        (-0.881921264348355, -0.47139673682599764),\n        (-0.8760700941954066, -0.4821837720791227),\n        (-0.8700869911087115, -0.4928981922297839),\n        (-0.8639728561215868, -0.5035383837257175),\n        (-0.8577286100002721, -0.5141027441932216),\n        (-0.8513551931052652, -0.5245896826784687),\n        (-0.8448535652497072, -0.5349976198870969),\n        (-0.8382247055548382, -0.5453249884220461),\n        (-0.8314696123025455, -0.555570233019602),\n        (-0.8245893027850253, -0.5657318107836132),\n        (-0.8175848131515837, -0.5758081914178453),\n        (-0.8104571982525948, -0.5857978574564389),\n        (-0.8032075314806449, -0.5956993044924332),\n        (-0.7958369046088836, -0.6055110414043254),\n        (-0.7883464276266063, -0.6152315905806267),\n        (-0.7807372285720946, -0.6248594881423862),\n        (-0.7730104533627371, -0.6343932841636453),\n        (-0.7651672656224591, -0.6438315428897913),\n        (-0.7572088465064848, -0.6531728429537765),\n        (-0.7491363945234593, -0.6624157775901718),\n        (-0.740951125354959, -0.6715589548470184),\n        (-0.7326542716724128, -0.680600997795453),\n        (-0.724247082951467, -0.6895405447370668),\n        (-0.7157308252838187, -0.6983762494089728),\n        (-0.7071067811865477, -0.7071067811865475),\n        (-0.698376249408973, -0.7157308252838185),\n        (-0.6895405447370672, -0.7242470829514667),\n        (-0.6806009977954532, -0.7326542716724126),\n        (-0.6715589548470187, -0.7409511253549588),\n        (-0.6624157775901721, -0.749136394523459),\n        (-0.6531728429537771, -0.7572088465064842),\n        (-0.6438315428897915, -0.7651672656224588),\n        (-0.6343932841636459, -0.7730104533627367),\n        (-0.6248594881423865, -0.7807372285720944),\n        (-0.6152315905806274, -0.7883464276266059),\n        (-0.6055110414043257, -0.7958369046088833),\n        (-0.5956993044924332, -0.803207531480645),\n        (-0.5857978574564391, -0.8104571982525947),\n        (-0.5758081914178452, -0.8175848131515837),\n        (-0.5657318107836136, -0.8245893027850251),\n        (-0.5555702330196022, -0.8314696123025452),\n        (-0.5453249884220468, -0.8382247055548377),\n        (-0.5349976198870973, -0.8448535652497071),\n        (-0.5245896826784694, -0.8513551931052649),\n        (-0.5141027441932219, -0.857728610000272),\n        (-0.5035383837257181, -0.8639728561215865),\n        (-0.49289819222978426, -0.8700869911087113),\n        (-0.4821837720791226, -0.8760700941954067),\n        (-0.47139673682599786, -0.8819212643483549),\n        (-0.4605387109582399, -0.887639620402854),\n        (-0.44961132965460693, -0.8932243011955152),\n        (-0.4386162385385276, -0.8986744656939538),\n        (-0.4275550934302825, -0.9039892931234431),\n        (-0.4164295600976372, -0.9091679830905224),\n        (-0.40524131400499036, -0.9142097557035305),\n        (-0.3939920400610482, -0.9191138516900577),\n        (-0.38268343236509034, -0.9238795325112865),\n        (-0.3713171939518377, -0.9285060804732155),\n        (-0.35989503653498794, -0.932992798834739),\n        (-0.34841868024943484, -0.9373390119125748),\n        (-0.33688985339221994, -0.9415440651830208),\n        (-0.32531029216226326, -0.9456073253805212),\n        (-0.31368174039889146, -0.9495281805930367),\n        (-0.3020059493192285, -0.9533060403541938),\n        (-0.2902846772544624, -0.9569403357322088),\n        (-0.2785196893850536, -0.9604305194155657),\n        (-0.26671275747489853, -0.9637760657954398),\n        (-0.2548656596045143, -0.9669764710448522),\n        (-0.24298017990326412, -0.970031253194544),\n        (-0.23105810828067097, -0.9729399522055602),\n        (-0.2191012401568701, -0.9757021300385285),\n        (-0.20711137619221848, -0.9783173707196277),\n        (-0.19509032201612866, -0.9807852804032303),\n        (-0.18303988795514098, -0.9831054874312163),\n        (-0.17096188876030172, -0.9852776423889411),\n        (-0.15885814333386153, -0.9873014181578583),\n        (-0.14673047445536233, -0.9891765099647809),\n        (-0.13458070850712636, -0.99090263542778),\n        (-0.12241067519921596, -0.9924795345987101),\n        (-0.11022220729388331, -0.9939069700023561),\n        (-0.09801714032956045, -0.9951847266721969),\n        (-0.08579731234444021, -0.996312612182778),\n        (-0.07356456359966736, -0.9972904566786902),\n        (-0.06132073630220899, -0.9981181129001492),\n        (-0.04906767432741803, -0.9987954562051724),\n        (-0.03680722294135933, -0.9993223845883494),\n        (-0.02454122852291239, -0.9996988186962042),\n        (-0.012271538285720512, -0.9999247018391445),\n        (-1.8369701987210297e-16, -1.0),\n        (0.012271538285720144, -0.9999247018391445),\n        (0.02454122852291202, -0.9996988186962042),\n        (0.03680722294135897, -0.9993223845883495),\n        (0.04906767432741767, -0.9987954562051724),\n        (0.061320736302208634, -0.9981181129001492),\n        (0.073564563599667, -0.9972904566786902),\n        (0.08579731234443987, -0.996312612182778),\n        (0.09801714032956009, -0.9951847266721969),\n        (0.11022220729388295, -0.9939069700023561),\n        (0.1224106751992156, -0.9924795345987101),\n        (0.13458070850712597, -0.99090263542778),\n        (0.14673047445536194, -0.9891765099647809),\n        (0.15885814333386114, -0.9873014181578584),\n        (0.17096188876030133, -0.9852776423889412),\n        (0.1830398879551406, -0.9831054874312164),\n        (0.19509032201612828, -0.9807852804032304),\n        (0.2071113761922181, -0.9783173707196278),\n        (0.21910124015686974, -0.9757021300385286),\n        (0.23105810828067058, -0.9729399522055603),\n        (0.24298017990326376, -0.970031253194544),\n        (0.25486565960451396, -0.9669764710448523),\n        (0.2667127574748982, -0.96377606579544),\n        (0.2785196893850533, -0.9604305194155658),\n        (0.2902846772544621, -0.9569403357322089),\n        (0.3020059493192282, -0.9533060403541938),\n        (0.31368174039889113, -0.9495281805930368),\n        (0.325310292162263, -0.9456073253805213),\n        (0.3368898533922196, -0.9415440651830209),\n        (0.3484186802494345, -0.937339011912575),\n        (0.35989503653498767, -0.9329927988347391),\n        (0.37131719395183743, -0.9285060804732156),\n        (0.38268343236509, -0.9238795325112866),\n        (0.39399204006104793, -0.9191138516900579),\n        (0.40524131400499, -0.9142097557035306),\n        (0.4164295600976369, -0.9091679830905225),\n        (0.4275550934302822, -0.9039892931234433),\n        (0.43861623853852727, -0.898674465693954),\n        (0.4496113296546066, -0.8932243011955153),\n        (0.4605387109582396, -0.8876396204028542),\n        (0.4713967368259976, -0.881921264348355),\n        (0.4821837720791222, -0.8760700941954069),\n        (0.49289819222978387, -0.8700869911087115),\n        (0.5035383837257177, -0.8639728561215867),\n        (0.5141027441932214, -0.8577286100002722),\n        (0.524589682678469, -0.8513551931052651),\n        (0.5349976198870969, -0.8448535652497073),\n        (0.5453249884220465, -0.838224705554838),\n        (0.5555702330196018, -0.8314696123025456),\n        (0.5657318107836131, -0.8245893027850253),\n        (0.5758081914178449, -0.817584813151584),\n        (0.5857978574564388, -0.8104571982525949),\n        (0.5956993044924328, -0.8032075314806453),\n        (0.6055110414043253, -0.7958369046088837),\n        (0.6152315905806269, -0.7883464276266061),\n        (0.6248594881423861, -0.7807372285720947),\n        (0.6343932841636456, -0.7730104533627369),\n        (0.6438315428897912, -0.7651672656224592),\n        (0.6531728429537768, -0.7572088465064846),\n        (0.6624157775901715, -0.7491363945234597),\n        (0.6715589548470183, -0.7409511253549592),\n        (0.6806009977954527, -0.7326542716724131),\n        (0.6895405447370668, -0.7242470829514671),\n        (0.6983762494089724, -0.715730825283819),\n        (0.7071067811865475, -0.7071067811865477),\n        (0.7157308252838188, -0.6983762494089727),\n        (0.7242470829514667, -0.6895405447370672),\n        (0.7326542716724129, -0.680600997795453),\n        (0.7409511253549588, -0.6715589548470187),\n        (0.7491363945234594, -0.6624157775901718),\n        (0.7572088465064842, -0.6531728429537771),\n        (0.7651672656224588, -0.6438315428897915),\n        (0.7730104533627367, -0.6343932841636459),\n        (0.7807372285720944, -0.6248594881423865),\n        (0.7883464276266059, -0.6152315905806274),\n        (0.7958369046088833, -0.6055110414043257),\n        (0.803207531480645, -0.5956993044924332),\n        (0.8104571982525947, -0.5857978574564391),\n        (0.8175848131515837, -0.5758081914178452),\n        (0.8245893027850251, -0.5657318107836136),\n        (0.8314696123025452, -0.5555702330196022),\n        (0.8382247055548377, -0.5453249884220468),\n        (0.8448535652497071, -0.5349976198870973),\n        (0.8513551931052649, -0.5245896826784694),\n        (0.857728610000272, -0.5141027441932219),\n        (0.8639728561215865, -0.5035383837257181),\n        (0.8700869911087113, -0.49289819222978426),\n        (0.8760700941954067, -0.4821837720791226),\n        (0.8819212643483549, -0.4713967368259979),\n        (0.887639620402854, -0.46053871095823995),\n        (0.8932243011955151, -0.449611329654607),\n        (0.8986744656939538, -0.43861623853852766),\n        (0.9039892931234431, -0.42755509343028253),\n        (0.9091679830905224, -0.41642956009763726),\n        (0.9142097557035305, -0.4052413140049904),\n        (0.9191138516900577, -0.39399204006104827),\n        (0.9238795325112865, -0.3826834323650904),\n        (0.9285060804732155, -0.37131719395183777),\n        (0.932992798834739, -0.359895036534988),\n        (0.9373390119125748, -0.3484186802494349),\n        (0.9415440651830208, -0.33688985339222),\n        (0.9456073253805212, -0.3253102921622633),\n        (0.9495281805930367, -0.3136817403988915),\n        (0.9533060403541936, -0.30200594931922853),\n        (0.9569403357322088, -0.29028467725446244),\n        (0.9604305194155657, -0.27851968938505367),\n        (0.9637760657954398, -0.2667127574748986),\n        (0.9669764710448522, -0.25486565960451435),\n        (0.970031253194544, -0.24298017990326418),\n        (0.9729399522055602, -0.23105810828067103),\n        (0.9757021300385285, -0.21910124015687016),\n        (0.9783173707196277, -0.20711137619221853),\n        (0.9807852804032303, -0.19509032201612872),\n        (0.9831054874312163, -0.18303988795514103),\n        (0.9852776423889411, -0.17096188876030177),\n        (0.9873014181578583, -0.15885814333386158),\n        (0.9891765099647809, -0.1467304744553624),\n        (0.99090263542778, -0.13458070850712642),\n        (0.99247953459871, -0.12241067519921603),\n        (0.9939069700023561, -0.11022220729388338),\n        (0.9951847266721969, -0.09801714032956052),\n        (0.996312612182778, -0.08579731234444028),\n        (0.9972904566786902, -0.07356456359966743),\n        (0.9981181129001492, -0.06132073630220905),\n        (0.9987954562051724, -0.04906767432741809),\n        (0.9993223845883494, -0.036807222941359394),\n        (0.9996988186962042, -0.02454122852291245),\n        (0.9999247018391445, -0.012271538285720572)\n    ]\n\nimport submodule falcon_inst\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and consistency of the ML-KEM key encapsulation mechanism as specified in the provided Cryptol module. Include properties that prove the equivalence of the naive and fast Number-Theoretic Transform (NTT) implementations, correctness of compression and decompression functions, and the correctness of the K-PKE component scheme's key generation, encryption, and decryption algorithms. Also, specify properties to check the validity of encapsulation and decapsulation keys, and the overall correctness of the ML-KEM scheme's encapsulation and decapsulation processes."},{"role":"assistant","content":"```cryptol\n\/**\n * ML-KEM key encapsulation mechanism for establishing a shared secret key\n * between two parties, with a fast NTT implementation.\n *\n * This implements the final version of ML-KEM as standardized in [FIPS-203].\n * The executable spec differs from the spec in several important ways:\n * - In the spec, two ML-KEM functions (`KeyGen` and `Encaps`) require the\n *   generation of randomness. In the exectable spec, this\n *   randomness is passed as input, because Cryptol cannot generate randomness.\n *   Implementors must manually verify that their functions generate randomness\n *   using an approved RBG with a suitable security strength for their chosen\n *   parameter set, and that the sampling of random values is performed by the\n *   cryptographic module.\n * - The spec requires that intermediate values must be destroyed prior to the\n *   termination of each algorithm, with two exceptions (see Section 3.3\n *   \"Destruction of intermediate values.\") Cryptol cannot express this\n *   requirement. Implementors must manually verify that intermediate data is\n *   destroyed as soon as it is no longer needed.\n *\n * The spec defines other requirements that cannot be verified by Cryptol!\n * For full details, see [FIPS-203] Section 3.3.\n * - K-PKE cannot be used as a stand-alone cryptographic scheme. This\n *   executable spec makes the K-PKE module private; implementors must manually\n *   verify that their own implementations do not make the K-PKE API public.\n * - The internal functions `KeyGen_internal`, `Encaps_internal`, and\n *   `Decaps_internal` must not be made available to other applications except\n *   for testing purposes. This executable spec makes the internal functions\n *   private; implementors must manually verify that the same is true in their\n *   implementations.\n * - The shared secret key generated by `Encaps` and `Decaps` can be used\n *   directly as a key for symmetric cryptography. If further key derivation is\n *   needed, it must be done using an approved technique. Cryptol cannot verify\n *   that the shared secret key is used in an appropriate way.\n * - As mentioned, randomness must be generated using an approved RBG, and a\n *   fresh string of random bytes must be generated for each invocation.\n *   Cryptol cannot verify either of these requirements.\n * - The input to `Encaps` and `Decaps` must be checked. Cryptol cannot verify\n *   that the input has been checked.\n * - As mentioned, intermediate values must be destroyeda fter use. Cryptol\n *   cannot verify that this has been done.\n *\n * @copyright Galois, Inc\n * @author Marios Georgiou <marios@galois.com>\n * @editor Marcella Hastings <marcella@galois.com>\n *\n * @copyright Amazon.com or its affiliates.\n * @author Rod Chapman <rodchap@amazon.com>\n *\n * Sources:\n * [FIPS-203]: National Institute of Standards and Technology. Module-Lattice-\n *     Based Key-Encapsulation Mechanism Standard. (Department of Commerce,\n *     Washington, D.C.), Federal Information Processing Standards Publication\n *     (FIPS) NIST FIPS 203. August 2024.\n *     @see https:\/\/doi.org\/10.6028\/NIST.FIPS.203\n *\/\nmodule Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256 as SHAKE256\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE128 as SHAKE128\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256 as SHA3_256\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512 as SHA3_512\n\nprivate\n    \/*\n     * [FIPS-203] Section 2.3.\n     *\/\n    type n = 256\n    \/*\n     * [FIPS-203] Section 2.3.\n     *\/\n    type q = 3329\n    \/**\n     * A primitive n-th root of unity modulo `q`.\n     * [FIPS-203] Section 2.3.\n     *\/\n    zeta = 17 : Z q\n\n\/**\n * Defines the set {0, 1, ..., 255} of unsigned 8-bit integers.\n * [FIPS-203] Section 2.3.\n *\/\ntype Byte = [8]\n\nprivate\n    \/**\n     * An element in the ring `R_q`.\n     *\n     * An element in the ring is a polynomial of degree at most 255 (e.g. with\n     * 256 terms). The `i`th element in this array represents the coefficient\n     * of the degree-`i` term.\n     *\n     * [FIPS-203] Section 2.3 (definition of the ring).\n     * [FIPS-203] Section 2.4.4, Equation 2.5 (definition of the representation\n     *     of elements in the ring).\n     *\/\n    type Rq = [n](Z q)\n\n    \/**\n     * An element in the ring `T_q`.\n     *\n     * An element in this ring (sometimes called the \"NTT representation\") is a\n     * tuple of 128 polynomials, each of degree at most one (e.g. with two\n     * terms). The `2i` and `2i+1`th terms in this array represent the degree-0\n     * and degree-1 coefficients of the `i`th polynomial, respectively.\n     *\n     * [FIPS-203] Section 2.3 (definition of the `T_q`).\n     * [FIPS-203] Section 2.4.4 Equation 2.7 (definition of the representation\n     *     of an element in `T_q`).\n     *\/\n    type Tq = [n](Z q)\n\n    \/**\n     * Pseudorandom function (PRF).\n     * [FIPS-203] Section 4.1, Equations 4.2 and 4.3.\n     *\/\n    PRF : {eta} (2 <= eta, eta <= 3) => [32]Byte -> Byte -> [64 * eta]Byte\n    PRF s b = SHAKE256::xofBytes`{8 * 64 * eta} (s # [b])\n\n    \/**\n     * One of the hash functions used in the protocol.\n     * [FIPS-203] Section 4.1, Equation 4.4.\n     *\/\n    H : {hinl} (fin hinl) => [hinl]Byte -> [32]Byte\n    H s = SHA3_256::hashBytes s\n\n    \/**\n     * One of the hash functions used in the protocol.\n     * [FIPS-203] Section 4.1, Equation 4.4.\n     *\/\n    J : {hinl} (fin hinl) => [hinl]Byte -> [32]Byte\n    J s = SHAKE256::xofBytes`{8 * 32} s\n\n    \/**\n     * One of the hash functions used in the protocol.\n     * [FIPS-203] Section 4.1, Equation 4.5.\n     *\/\n    G : {ginl} (fin ginl) => [ginl]Byte -> ([32]Byte, [32]Byte)\n    G c = (a, b) where\n        [a, b] = split (SHA3_512::hashBytes c)\n\n    \/**\n     * eXtendable-Output Function (XOF) wrapper.\n     * [FIPS-203] Section 4.1, Equation 4.6.\n     *\/\n    XOF : ([34]Byte) -> [inf]Byte\n    XOF = SHAKE128::xofBytes\n\n    \/**\n     * Conversion from little-endian bit arrays to byte arrays.\n     * [FIPS-203] Section 4.2.1, Algorithm 3.\n     *\/\n    BitsToBytes : {ell} (fin ell) => [8 * ell]Bit -> [ell]Byte\n    BitsToBytes b\n        | ell == 0 => zero\n        | ell > 0 => B where\n            \/\/ Group the bits into the B[\u230ai \/ 8\u230b] sets; pad them to support\n            \/\/ subsequent operations, and correlate each bit with its index `i`.\n            b' = groupBy`{8} [(zext [bi], i)\n                | bi <- b\n                | i <- [0..8 * ell - 1]]\n\n            \/\/ Steps 2-4.\n            B = [sum [bi * (2 ^^ (i % 8))\n                    | (bi, i) <- bi8]\n                | bi8 <- b']\n\n    \/**\n     * Conversion from byte arrays to bit arrays.\n     * [FIPS-203] Section 4.2.1, Algorithm 4.\n     *\/\n    BytesToBits : {ell} (fin ell) => [ell]Byte -> [ell*8]Bit\n    BytesToBits C\n        | ell == 0 => []\n        | ell > 0 => join [[ b8ij where\n                \/\/ Step 4. Taking the last bit is the same as modding by 2. (See\n                \/\/ `mod2IsFinalBit`).\n                b8ij = Ci' ! 0\n                \/\/ Step 5. Shifting right is the same as the iterative\n                \/\/ division (see `div2IsShiftR`). This accounts for all the\n                \/\/ divisions \"up to this point\" (e.g. none when `j = 0`), which\n                \/\/ is why we use `Ci'` to evaluate `b8ij` above.\n                Ci' = Ci >> j\n            \/\/ Step 3.\n            | j <- [0..7]]\n            \/\/ Step 2. We iterate over `C` directly instead of indexing into it.\n            | Ci <- C ]\n\n    \/**\n     * The iterative division by 2 in `BytesToBits` is the same as shifting\n     * right.\n     * ```repl\n     * :prove div2IsShiftR\n     * ```\n     *\/\n    div2IsShiftR : Byte -> Bit\n    div2IsShiftR C = take (d2 C) == shl where\n        \/\/ Note: division here is floor'd by default.\n        d2 c = [c] # d2 (c \/ 2)\n        shl = [C >> j | j <- [0..7]]\n\n    \/**\n     * The conversions between bits and bytes are each others' inverses.\n     * [FIPS-203] Section 4.2.1 (see description on Algorithm 4).\n     * The sample `ell` values here are a subset of the possible values in the\n     * spec.\n     * ```repl\n     * :prove B2B2BInverts`{32}\n     * :prove B2B2BInverts`{192}\n     * :prove B2B2BInverts`{384}\n     * ```\n     *\/\n    B2B2BInverts : {ell} (fin ell, ell > 0) => [ell * 8] -> Bit\n    B2B2BInverts bits = bitsWorks && bytesWorks where\n        bitsWorks = BytesToBits (BitsToBytes bits) == bits\n        bytesWorks = BitsToBytes (BytesToBits (split bits)) == split bits\n\n    \/**\n     * Check the example given in the spec for converting between bits and\n     * bytes.\n     * [FIPS-203] Section 4.2.1 \"Converting between bits and bytes.\"\n     * ```repl\n     * :prove B2BExampleWorks\n     * ```\n     *\/\n    B2BExampleWorks = BitsToBytes 0b11010001 == [139]\n\n    \/**\n     * In Cryptol, rounding is computed via the built-in function `roundAway`.\n     * [FIPS-203] Section 2.3.\n     *\/\n    property roundingWorks y = y >= 0 ==> roundUpWorks && roundDownWorks where\n        y' = fromInteger y\n        roundUpWorks = roundAway (y' + 0.5) == (y + 1)\n        roundDownWorks = roundAway (y' + 0.4) == y\n\n    \/**\n     * Compress an integer mod `q` into an integer mod `2^d`.\n     * [FIPS-203] Section 4.2.1, Equation 4.7.\n     *\/\n    Compress : {d} (d < width q) => Z q -> [d]\n    Compress x = y where\n        \/\/ Convert from an integer mod `q` to a rational number.\n        x' = fromInteger (fromZ x) : Rational\n        \/\/ Compress. Note that `\/.` denotes division of rationals.\n        y' = roundAway (((2^^`d) \/. `q) * x')\n        \/\/ mod 2^^d (by converting from an integer to a d-bit vector).\n        y = (fromInteger y') : [d]\n\n    \/**\n     * Decompress an integer mod `2^d` into an integer mod `q`.\n     * [FIPS-203] Section 4.2.1, Equation 4.8.\n     *\/\n    Decompress : {d} (d < width q) => [d] -> Z q\n    Decompress y = x where\n        \/\/ Convert from a d-length bit vector to a rational number.\n        y' = fromInteger (toInteger y) : Rational\n        \/\/ Decompress! As before, `\/.` is division of rationals.\n        x' = roundAway((`q \/. (2^^`d)) * y')\n        \/\/ Convert from an integer to an integer mod `q`.\n        x = (fromInteger x') : Z q\n\n    \/**\n     * Compression inverts decompression for all inputs and bit lengths.\n     * We'll prove it for the bit lengths found in the\n     * ```repl\n     * :prove CompressInvertsDecompress`{1}\n     * :exhaust CompressInvertsDecompress`{d_u}\n     * :exhaust CompressInvertsDecompress`{d_v}\n     * ```\n     *\/\n    CompressInvertsDecompress : {d} (d < width q) => [d] -> Bit\n    property CompressInvertsDecompress y = Compress (Decompress y) == y\n\n    \/**\n     * When `d` is large, compression followed by decompression must not\n     * significantly alter the value.\n     * This sets `d = d_u`, which is the largest value for `d` used in the\n     * spec.\n     * [FIPS-203] Section 4.2.1, \"Compression and Decompression\".\n     * ```repl\n     * :exhaust DecompressMostlyInvertsCompress\n     * ```\n     *\/\n    DecompressMostlyInvertsCompress : Z q -> Bit\n    property DecompressMostlyInvertsCompress x = errIsSmallEnough where\n        x' = Decompress`{d_u} (Compress`{d_u} x)\n        err = abs (modpm (x' - x))\n        errIsSmallEnough = err <= B_q`{d_u}\n\n        \/\/ The spec doesn't describe formally what \"not significantly altered\"\n        \/\/ means; we use this equation.\n        B_q : {d} (d < lg2 q) => Integer\n        B_q = roundAway((`q\/.(2^^(`d+1))))\n\n        \/\/ Convert an integer mod `q` to a representation centered around 0\n        \/\/ (and represented as an `Integer`).\n        modpm : Z q -> Integer\n        modpm r = if r' > (`q \/ 2) then r' - `q else r'\n            where r' = fromZ r\n\n    \/**\n     * Compression applied to a vector is equivalent to applying compression to\n     * each individual element.\n     * [FIPS-203] Section 2.4.8, Equation 2.15.\n     *\/\n    Compress_Vec : {d} (d < lg2 q) => [n](Z q) -> [n][d]\n    Compress_Vec x = map Compress`{d} x\n\n    \/**\n     * Decompression applied to a vector is equivalent to applying\n     * decompression to each individual element.\n     * [FIPS-203] Section 2.4.8.\n     *\/\n    Decompress_Vec : {d} (d < lg2 q) => [n][d] -> [n](Z q)\n    Decompress_Vec x = map Decompress`{d} x\n\n    \/**\n     * Compression applied to a matrix is equivalent to applying compression\n     * to each individual element.\n     * [FIPS-203] Section 2.4.8.\n     *\/\n    Compress_Mat : {d, k1} (d < lg2 q, fin k1) => [k1][n](Z q) -> [k1][n][d]\n    Compress_Mat x = map Compress_Vec`{d} x\n\n    \/**\n     * Decompression applied to a matrix is equivalent to applying\n     * decompression to each individual element.\n     * [FIPS-203] Section 2.4.8.\n     *\/\n    Decompress_Mat : {d, k1} (d < lg2 q, fin k1) => [k1][n][d] -> [k1][n](Z q)\n    Decompress_Mat x = map Decompress_Vec`{d} x\n\n    \/**\n     * Encode an array of `d`-bit integers into a byte array, for `d < 12`.\n     * [FIPS-203] Section 4.2.1 Algorithm 5.\n     *\n     * Note: In this implementation, we treat the `d < 12` case separately from\n     * `d == 12` because it allows us to better express the different integer\n     * types. For `d < 12`, we use the bit vector type.\n     * See `ByteEncode12` for the `d = 12` case.\n     *\/\n    ByteEncode : {d} (1 <= d, d < 12) => [256][d] -> [32 * d]Byte\n    ByteEncode F = B where\n        \/\/ Step 1-3, 5.\n        \/\/ We iterate over `F` directly, instead of indexing into it with `i`.\n        \/\/ In a bit vector, iteratively subtracting the last bit and dividing\n        \/\/ by 2 is the same as bit-shifting to the right (see\n        \/\/ `subAndDivIsShift`).\n        as = [[ a >> j | j <- [0..d-1]] | a <- F]\n        \/\/ Step 4. In a bit vector, taking the value `% 2` is the same as taking\n        \/\/ the final bit. See `mod2IsFinalBit`.\n        b = join [ [ a ! 0 | a <- ajs] | ajs <- as]\n        \/\/ Step 8.\n        B = BitsToBytes b\n\n    \/**\n     * Encode `k` vectors of `d`-bit integers into a byte array.\n     * [FIPS-203] Section 2.4.8.\n     *\/\n    ByteEncode_Vec : {d} (fin d, 1 <= d, d < 12) => [k][256][d] -> [k * 32 * d]Byte\n    ByteEncode_Vec F_vec = join (map ByteEncode F_vec)\n\n    \/**\n     * Encode an array of integers mod `q` into a byte array.\n     * [FIPS-203] Section 4.2.1 Algorithm 5.\n     *\n     * Note: In this implementation, we treat the `d < 12` case separately from\n     * `d == 12` because it allows us to better express the different integer\n     * types. For `d == 12`, we use the integers-mod (`Z`) type.\n     * See `ByteEncode` for the `d < 12` case.\n     *\/\n    ByteEncode12 : [256](Z q) -> [32 * 12]Byte\n    ByteEncode12 F = B where\n        type d = 12\n\n        \/\/ We need to explicitly convert from integers mod `q` to 12-bit\n        \/\/ vectors.\n        toBitVec : Z q -> [d]\n        toBitVec f = fromInteger (fromZ f)\n        F' = map toBitVec F\n\n        \/\/ The following is the same as in `ByteEncode`. See notes above.\n        as = [[ a >> j | j <- [0..d-1]] | a <- F' ]\n        b = join [ [ a ! 0 | a <- ajs] | ajs <- as]\n        B = BitsToBytes b\n\n    \/**\n     * Encode a set of `k` vectors of integers mod `q` into a byte array.\n     * [FIPS-203] Section 2.4.8.\n     *\/\n    ByteEncode12_Vec : [k][256](Z q) -> [k * 32 * 12]Byte\n    ByteEncode12_Vec F_vec = join (map ByteEncode12 F_vec)\n\n    \/**\n     * The subtract-and-divide algorithm applied to `a` in `ByteEncode` is the\n     * same as shifting right.\n     *\n     * This is in reference to [FIPS-203] Section 4.2.1 Algorithm 5, Step 4-5.\n     * That algorithm converts an integer repesentation `a` into a bitwise\n     * representation `b`, and needs to iteratively update `a` to discard each\n     * bit that it has already retrieved for `b`.\n     *\n     * Note: The type constraint for `d` does not allow `1` because `% 2` is\n     * not a legal operation on 1-bit vectors (since 2 cannot be represented\n     * as a 1-bit vector). It remains true, though (with a result of 0).\n     *\n     * These tests use the values of `d` that are actually used in the\n     * algorithm. `d_u` and `d_v` are functor parameters for this module.\n     * ```repl\n     * :prove subAndDivIsShiftR`{d_u}\n     * :prove subAndDivIsShiftR`{d_v}\n     * :prove subAndDivIsShiftR`{12}\n     * ```\n     *\/\n    subAndDivIsShiftR : {d} (fin d, d > 1) => [d] -> Bit\n    property subAndDivIsShiftR a = take (sad a) == shift a where\n        \/\/ Recursive definition of Step 4-5 (step 4 is inline here)\n        sad x = [x] # sad ((x - (x % 2)) \/ 2)\n        shift x = [x >> i | i <- [0..d-1]]\n\n    \/**\n     * Computing a bit vector mod 2 is the same as taking its final (least\n     * significant) bit.\n     *\n     * This is in reference to [FIPS-203] Section 4.2.1 Algorithm 5, Step 4.\n     * That algorithm converts the integer representation of `a` into a bitwise\n     * representation `b` and uses `mod` to iteratively get bits out of `a`.\n     *\n     * Note: The type constraint for `d` does not allow `1` because `% 2` is\n     * not a legal operation on 1-bit vectors (since 2 cannot be represented\n     * as a 1-bit vector.) It's trivially true, though.\n     *\n     * These tests use the values of `d` that are actually used in the\n     * algorithm. `d_u` and `d_v` are functor parameters for this module.\n     * ```repl\n     * :prove mod2IsFinalBit`{d_u}\n     * :prove mod2IsFinalBit`{d_v}\n     * :prove mod2IsFinalBit`{12}\n     * ```\n     *\/\n    mod2IsFinalBit : {d} (fin d, d > 1) => [d] -> Bit\n    property mod2IsFinalBit a = a % 2 == zext [a ! 0]\n\n    \/**\n     * Decode a byte array into an array of `d`-bit integers, for `d < 12`.\n     * [FIPS-203] Section 4.2.1 Algorithm 6.\n     *\n     * Note: In this implementation, we treat the `d < 12` case separately from\n     * `d == 12` because it allows us to better express the different integer\n     * types. For `d < 12`, we use the bit vector type.\n     * See `ByteDecode12` for the `d = 12` case.\n     *\/\n    ByteDecode : {d} (1 <= d, d < 12) => [32 * d]Byte -> [256][d]\n    ByteDecode B = F where\n        \/\/ Step 1.\n        b = BytesToBits B\n        \/\/ Steps 2-4.\n        \/\/ - In FIPS 203, these operations are taken `mod m`, where `m = 2^d`.\n        \/\/   The `mod` is implicit here because computations on the `[d]` type\n        \/\/   are `mod 2^d` by definition.\n        \/\/ - In a bit vector, multiplying by `2^j` is the same as left shift\n        \/\/   (see mul2jIsShiftL`).\n        \/\/ - `bidj` is a single Bit; we use `zext` to convert to a `d`-length\n        \/\/   bit vector (with zeros in the higher-order bits) to support\n        \/\/   subsequentoperations.\n        F = [ sum [ (zext [bidj]) << j\n                | bidj <- bid\n                | j <- [0..d-1]]\n            | bid <- split`{256} b]\n\n    \/**\n     * Decode `k` arrays of `d`-bit integers into a byte array.\n     * [FIPS-203] Section 2.4.8.\n     *\/\n    ByteDecode_Vec : {d} (1 <= d, d < 12) => [k * 32 * d]Byte -> [k][256][d]\n    ByteDecode_Vec B_vec = map ByteDecode (split B_vec)\n\n    \/**\n     * Decode a byte array into an array of integers mod `q`.\n     * [FIPS-203] Section 4.2.1 Algorithm 6.\n     *\n     * Note: In this implementation, we treat the `d < 12` case separately from\n     * `d == 12` because it allows us to better express the different integer\n     * types. For `d = 12`, we use the integers-mod (`Z`) type.\n     * See `ByteDecode` for the `d < 12` case.\n     *\/\n    ByteDecode12 : [32 * 12]Byte -> [256](Z q)\n    ByteDecode12 B = F' where\n        type d = 12\n        \/\/ These steps are the same as in `ByteDecode`. See that function for\n        \/\/ notes.\n        b = BytesToBits B\n        F = [ sum [ (zext`{d} [bidj]) << j\n                | bidj <- bid\n                | j <- [0..d-1]]\n            | bid <- split`{256} b]\n\n        \/\/ In this case, since `m = q` (and not `2^12`), we need to explicitly\n        \/\/ convert each integer from a 12-bit array to an integer mod `q`.\n        toZq f = fromInteger (toInteger f)\n        F' = map toZq F\n\n    \/**\n     * Decode `k` joined byte arrays into `k` arrays of integers mod `q`.\n     *\/\n    ByteDecode12_Vec : [k * 32 * 12]Byte -> [k][256](Z q)\n    ByteDecode12_Vec B = map ByteDecode12 (split B)\n\n    \/**\n     * Multiplying a value by `2^j` is the same as bit-shifting it left by `j`\n     * bits.\n     * Note: The type constraint does not allow `d == 1` because the hard-coded\n     * `2` does not fit in a single bit, but the property is trivial:\n     * `j` can only be 0. On the left, `b * 2^0 == b * 1 == b`. On the right,\n     * `b << 0 == b`.\n     *\n     * These tests use the values of `d` that are actually used in the\n     * algorithm. `d_u` and `d_v` are functor parameters for this module.\n     * ```repl\n     * :prove mul2jIsShiftL`{d_u}\n     * :prove mul2jIsShiftL`{d_v}\n     * :prove mul2jIsShiftL`{12}\n     * ```\n     *\/\n    mul2jIsShiftL : {d} (fin d, 1 < d) => [d] -> Bit\n    property mul2jIsShiftL b = and [( b * (2^^j)) == (b << j) | j <- [0..d-1]]\n\n    \/**\n     * When `d < 12`, the byte encoding and decoding functions should be\n     * one-to-one inverses of each other.\n     * [FIPS-203] Section 4.2.1 \"Encoding and decoding\", first point.\n     *\n     * These tests use the values of `d` that are actually used in the\n     * algorithm. `d_u` and `d_v` are functor parameters for this module.\n     * ```repl\n     * :prove ByteEncodeInvertsByteDecode`{1}\n     * :prove ByteEncodeInvertsByteDecode`{d_u}\n     * :prove ByteEncodeInvertsByteDecode`{d_v}\n     * ```\n     *\/\n    ByteEncodeInvertsByteDecode : {d} (fin d, 1 <= d, d < 12) => [256][d] -> Bit\n    property ByteEncodeInvertsByteDecode bits =\n        decode_encode_works && encode_decode_works where\n        decode_encode_works = ByteDecode (ByteEncode bits) == bits\n        \/\/ Rearrange random input to be valid for the decode function\n        bytes = split (join bits)\n        encode_decode_works = ByteEncode (ByteDecode bytes) == bytes\n\n    \/**\n     * Byte decoding is the inverse of byte decoding for `d = 12`.\n     * [FIPS-203] Section 4.2.1 \"Encoding and decoding\", second point.\n     *\n     * Note that the reverse property (decoding, then encoding) is not true!\n     * ```repl\n     * :check ByteDecode12InvertsByteEncode12\n     * ```\n     *\/\n    ByteDecode12InvertsByteEncode12 : [256](Z q) -> Bit\n    ByteDecode12InvertsByteEncode12 bits =\n        ByteDecode12 (ByteEncode12 bits) == bits\n\n    \/**\n     * Uniformly sample NTT representations.\n     *\n     * This uses a seed `B` to generate a pseudorandom stream, which is parsed into\n     * a polynomial in `T_q` drawn from a distribution indistinguishable from the\n     * uniform distribution.\n     *\n     * [FIPS-203] Section 4.2.2, Algorithm 7.\n     *\/\n    SampleNTT : [34]Byte -> Tq\n    SampleNTT B = a_hat' where\n        \/\/ Steps 1-2, 5.\n        \/\/ We (lazily) take an infinite stream from the XOF and remove only as\n        \/\/ many bytes as are needed to compute the function. See [FIPS-203]\n        \/\/ Section 4.1 Equation 4.6 for a discussion of the equivalence of this\n        \/\/ form to the one in Algorithm 7.\n        ctx0 = XOF B\n\n        \/\/ Step 3. Since Cryptol is not imperative, we implement this loop using\n        \/\/ recursion. The `j` counter is not made explicit; instead we lazily\n        \/\/ generate an infinite stream of coefficients in `T_q` and `take` the\n        \/\/ correct length in the next line.\n\n        \/\/ Step 4-16. `take` fulfills the `j < 256` condition in Steps 4 and 12.\n        a_hat = take`{256} (filter ctx0)\n\n        \/\/ `filter` parses an infinite stream from the XOF, computing\n        \/\/ potential elements `d1` and `d2` from the first 3 bytes in the stream\n        \/\/ and adding them to the output if they are valid elements in `Z q`.\n        filter: [inf]Byte -> [inf][12]\n        filter XOFSqueeze = a_hat_j where\n            \/\/ Step 5.\n            (C # ctx) = XOFSqueeze\n\n            \/\/ The conversion from 8-bit to 12-bit vectors (with the same\n            \/\/ value!) is implicit in the spec -- see notes on Step 5 and 6\/7.\n            \/\/ In Cryptol, we need to convert manually to do the subsequent\n            \/\/ computations.\n            [C0, C1, C2] = map zext`{12} C\n\n            \/\/ Step 6.\n            d1 = C0 + 256 * (C1 % 16)\n\n            \/\/ Step 7. Cryptol uses integer division; it always takes the floor\n            \/\/ of the result.\n            d2 = (C1 \/ 16) + 16 * C2\n\n            \/\/ Steps 4, 8 - 15.\n            \/\/ Add `d1` and\/or `d2` to the sampled vector `a_hat` if they are\n            \/\/ valid elements in `Z q`.\n            \/\/ The `while` loop in Step 4 is equivalent to the recursive call to\n            \/\/ `filter` in each condition.\n            a_hat_j = if (d1 < `q) && (d2 < `q) then\n                    [d1, d2] # filter ctx\n                else if d1 < `q then\n                    [d1] # filter ctx\n                else if d2 < `q then\n                    [d2] # filter ctx\n                else filter ctx\n\n        \/\/ This conversion is implicit in the implementation -- see the notes on\n        \/\/ Step 6\/7 and 9.\n        toZq : [12] -> Z q\n        toZq x = fromInteger (toInteger x)\n\n        a_hat' = map toZq a_hat\n\n    \/**\n     * Sample a special, centered distribution of polynomials in `R_q` with small\n     * coefficients.\n     *\n     * The input stream `B` must be uniformly random bytes!\n     *\n     * [FIPS-203] Section 4.2.2, Algorithm 8.\n     *\/\n    SamplePolyCBD: {eta} (2 <= eta, eta <= 3) => [64 * eta]Byte -> Rq\n    SamplePolyCBD B = f where\n        \/\/ Step 1.\n        b = BytesToBits B\n        \/\/ This conversion is implicit in the implementation. Convert each bit into\n        \/\/ an element of Z q.\n        BitToZ : Bit -> Z q\n        BitToZ bit = if bit then 1 else 0\n        b' = map BitToZ b\n\n        \/\/ Step 3.\n        x i = sum [b'@(2 * i * `eta + j) | j <- [0 .. (eta-1)]]\n                y i = sum [b'@(2 * i * `eta + `eta + j) | j <- [0 .. (eta-1)]]\n\n        \/\/ Steps 2, 5. The `mod q` is not explicit here because `x` and `y`\n        \/\/ return elements of `Z q`.\n        f = [(x i) - (y i) | i <- [0 .. 255]]\n\n    \/**\n     * [FIPS-203] Section 4.3 \"The mathematical structure of the NTT.\"\n     * ```repl\n     * :prove QisCorrectlyDefined\n     * ```\n     *\/\n    QisCorrectlyDefined: Bit\n    property QisCorrectlyDefined = `q == 2^^8 * 13 + 1\n\n    \/**\n     * `zeta` is a primitive 256-th root of unity modulo `q`.\n     * [FIPS-203] Section 4.3 \"The mathematical structure of the NTT.\"\n     *\n     * ```repl\n     * :prove zetaIsPrimitiveRoot\n     * ```\n     *\/\n    property zetaIsPrimitiveRoot = zeta ^^ 128 == -1\n\n    \/**\n     * Proves that `zeta` is correctly set to be the 256th root of `q`.\n     * ```repl\n     * :exhaust Is256thRootOfq\n     * ```\n     *\/\n    Is256thRootOfq : [lg2 q] -> Bit\n    property Is256thRootOfq p = (p == 0) || (p >= 256) || (zeta^^p != 1)\n\n    \/**\n     * Reverse the unsigned 7-bit value corresponding to an input integer in\n     * `[0, ..., 127]`.\n     * [FIPS-203] Section 4.3 \"The mathematical structure of the NTT.\"\n     *\n     * This diverges from the spec by operating over an 8-bit vector;\n     * this is to ease prior and subsequent computations that would overflow a\n     * 7-bit vector, like:\n     * - `2 * (BitRev7 i) + 1`\n     * - `2 * i + 1`\n     *\n     * A \"pure\" implementation of `BitRev7` in Cryptol is the `reverse` function\n     * on 7-bit vectors. This mini-property shows equivalence:\n     * ```repl\n     * :prove \\(x:[7]) -> ([0] # reverse x) == BitRev7 ([0] # x)\n     * ```\n     *\/\n    BitRev7 : [8] -> [8]\n    BitRev7 i = if i > 255 then error \"BitRev7 called with invalid input\"\n        else (reverse i) >> 1\n\n\/**\n * This section specifies the number-theoretic transform (NTT).\n *\n * It includes the version from [FIPS-203] Section 4.3 as well\n * as a faster O(N log N) version, and a proof of their equivalence.\n *\n * This is explicitly allowed by the spec: \"For every computational procedure\n * [...] a conforming implementation may replace the given set of steps with\n * any mathematically equivalent set of steps\". The equivalence properties\n * prove mathematical equivalence.\n * [FIPS-203] Introduction, \"7. Implementations\".\n *\/\nimport submodule NTT\nsubmodule NTT where\n    private\n        \/**\n         * Number theoretic transform: compute the \"NTT representation\" in\n         * `T_q` of a polynomial in `R_q`.\n         *\n         * [FIPS-203] Section 4.3, Algorithm 9.\n         *\/\n        NaiveNTT : Rq -> Tq\n        NaiveNTT f = join [[f2i i, f2iPlus1 i] | i <- [0 .. 127]] where\n            f2i i = sum [f @(2*j) * zeta_term i j | j <- [0 .. 127]]\n            f2iPlus1 i = sum [f @(2*j+1) * zeta_term i j | j <- [0 .. 127]]\n            zeta_term i j = zeta ^^ ((2 * BitRev7 i + 1) * j)\n\n        \/**\n         * Inverse of the number theoretic transform: converts from the \"NTT\n         * representation\" in `T_q` to a polynomial in `R_q`.\n         *\n         * [FIPS-203] Section 4.3, Algorithm 10.\n         *\/\n        NaiveNTTInv : Tq -> Rq\n        NaiveNTTInv f_hat = [f_i * 3303 | f_i <- f] where\n            f = join [[f2i i, f2iPlus1 i] | i <- [0 .. 127]]\n            f2i i = sum [f_hat @(2*j) * zeta_term i j | j <- [0 .. 127]]\n            f2iPlus1 i = sum [f_hat @(2*j+1) * zeta_term i j | j <- [0 .. 127]]\n            zeta_term i j = (recip zeta) ^^ ((2 * BitRev7 j + 1) * i)\n\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/ This section specifies fast O(N log N) NTT and Inverse NTT\n        \/\/\n        \/\/ A readable explanation of the derivation of this form of\n        \/\/ the NTT is in \"A Complete Beginner Guide to the Number\n        \/\/ Theoretic Transform (NTT)\" by Ardianto Satriawan,\n        \/\/ Rella Mareta, and Hanho Lee. Available from:\n        \/\/    https:\/\/eprint.iacr.org\/2024\/585\n        \/\/\n        \/\/ This section Copyright Amazon.com, Inc. or its affiliates.\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n        \/**\n         * Lookup table for `zeta` values computed in `NTT` and `NTTInv`.\n         *\n         * [FIPS-203] Appendix A.\n         *\/\n        zeta_expc  : [128](Z q)\n        zeta_expc = [\n            1, 1729, 2580, 3289, 2642, 630, 1897, 848,\n            1062, 1919, 193, 797, 2786, 3260, 569, 1746,\n            296, 2447, 1339, 1476, 3046, 56, 2240, 1333,\n            1426, 2094, 535, 2882, 2393, 2879, 1974, 821,\n            289, 331, 3253, 1756, 1197, 2304, 2277, 2055,\n            650, 1977, 2513, 632, 2865, 33, 1320, 1915,\n            2319, 1435, 807, 452, 1438, 2868, 1534, 2402,\n            2647, 2617, 1481, 648, 2474, 3110, 1227, 910,\n            17, 2761, 583, 2649, 1637, 723, 2288, 1100,\n            1409, 2662, 3281, 233, 756, 2156, 3015, 3050,\n            1703, 1651, 2789, 1789, 1847, 952, 1461, 2687,\n            939, 2308, 2437, 2388, 733, 2337, 268, 641,\n            1584, 2298, 2037, 3220, 375, 2549, 2090, 1645,\n            1063, 319, 2773, 757, 2099, 561, 2466, 2594,\n            2804, 1092, 403, 1026, 1143, 2150, 2775, 886,\n            1722, 1212, 1874, 1029, 2110, 2935, 885, 2154\n        ]\n\n\n        \/\/ Top level entry point - start with lv=256, k=1\n        fast_ntt : Rq -> Tq\n        fast_ntt v = fast_nttl v 1\n\n        \/\/ Recursive NTT function\n        fast_nttl :\n            {lv}  \/\/ Length of v is a member of {256,128,64,32,16,8,4}\n            (lv >= 2, lv <= 8) =>\n            [2^^lv](Z q) -> [8] -> [2^^lv](Z q)\n        fast_nttl v k\n            \/\/ Base case. lv==2 so just compute the butterfly and return\n            | lv == 2 => ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n\n            \/\/ Recursive case. Butterfly what we have, then recurse on each half,\n            \/\/ concatenate the results and return.\n            | lv  > 2 => (fast_nttl`{lv-1} s0 (k * 2)) #\n                    (fast_nttl`{lv-1} s1 (k * 2 + 1))\n                        where\n                        t = ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n                                                [s0, s1] = split t\n\n        \/\/ Fast recursive CT-NTT\n        ct_butterfly :\n            {m, hm}\n            (m >= 2, m <= 8, hm >= 1, hm <= 7, hm == m - 1) =>\n            [2^^m](Z q) -> (Z q) -> [2^^m](Z q)\n        ct_butterfly v z = new_v where\n            halflen = 2^^`hm\n            lower, upper : [2^^hm](Z q)\n            lower@x = v@x + z * v@(x + halflen)\n            upper@x = v@x - z * v@(x + halflen)\n            new_v = lower # upper\n\n\n        \/\/ Recursive inverse-NTT function\n        fast_invnttl :\n            {lv}  \/\/ Length of v is a member of {256,128,64,32,16,8,4}\n            (lv >= 2, lv <= 8) =>\n            [2^^lv](Z q) -> [8] -> [2^^lv](Z q)\n        fast_invnttl v k\n            \/\/ Base case. lv==2 so just compute the butterfly and return\n            | lv == 2 => gs_butterfly`{lv,lv-1} v (zeta_expc@k)\n\n            \/\/ Recursive case. Recurse on each half,\n            \/\/ concatenate the results, butterfly that, and return.\n            | lv  > 2 => gs_butterfly`{lv,lv-1} t (zeta_expc@k) where\n                                [s0, s1] = split v\n                t = (fast_invnttl`{lv-1} s0 (k * 2 + 1)) #\n                    (fast_invnttl`{lv-1} s1 (k * 2))\n\n        \/\/ Fast recursive GS-Inverse-NTT\n        gs_butterfly :\n            {m, hm}\n            (m >= 2, m <= 8, hm >= 1, hm <= 7, hm == m - 1) =>\n            [2^^m](Z q) -> (Z q) -> [2^^m](Z q)\n        gs_butterfly v z = new_v where\n            halflen = 2^^`hm\n            lower, upper : [2^^hm](Z q)\n            lower@x = v@x  + v@(x + halflen)\n            upper@x = z * (v@(x + halflen) - v@x)\n            new_v = lower # upper\n\n        \/\/ Top level entry point - start with lv=256, k=1\n        fast_invntt : Tq -> Rq\n        fast_invntt v = mul_recip128 (fast_invnttl v 1) where\n\n            \/\/ Multiplicative inverse of 128, mod `q`.\n            recip_128_modq = (recip 128) : (Z q)\n\n            \/\/ Multiply all elements of v' by the reciprocal of 128 (modulo q)\n            mul_recip128 : Tq -> Tq\n            mul_recip128 v' = [ v'@x * recip_128_modq | x <- [0 .. <n] ]\n\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/ Properties and proofs of Naive and Fast NTT\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n        \/**\n         * This property demonstrates that NaiveNTT is self-inverting.\n         * ```repl\n         * :prove NaiveNTT_Inverts\n         * ```\n         *\/\n        NaiveNTT_Inverts : Rq -> Bit\n        property NaiveNTT_Inverts f =  NaiveNTTInv (NaiveNTT f) == f\n\n        \/**\n         * This property demonstrates that NaiveNTTInv is self-inverting.\n         * ```repl\n         * :prove NaiveNTTInv_Inverts\n         * ```\n         *\/\n        NaiveNTTInv_Inverts : Tq -> Bit\n        property NaiveNTTInv_Inverts f =  NaiveNTT (NaiveNTTInv f) == f\n\n        \/**\n         * This property demonstrates that `fast_ntt` is the inverse of `fast_invntt`.\n         * ```repl\n         * :prove fast_ntt_inverts\n         * ```\n         *\/\n        fast_ntt_inverts : Rq -> Bit\n        property fast_ntt_inverts    f =  fast_invntt (fast_ntt f)    == f\n\n        \/**\n         * This property demonstrates that `fast_invntt` is the inverse of `fast_ntt`.\n         * ```repl\n         * :prove fast_invntt_inverts\n         * ```\n         *\/\n        fast_invntt_inverts : Tq -> Bit\n        property fast_invntt_inverts f =  fast_ntt    (fast_invntt f) == f\n\n        \/**\n         * This property demonstrates that `naive_ntt` is equivalent to `fast_ntt`.\n         * ```repl\n         * :prove naive_fast_ntt_equiv\n         * ```\n         *\/\n        naive_fast_ntt_equiv : Rq -> Bit\n        property naive_fast_ntt_equiv f =  NaiveNTT f == fast_ntt f\n\n        \/**\n         * This property demonstrates that `naive_invntt` is equivalent to `fast_invntt`.\n         * ```repl\n         * :prove naive_fast_invntt_equiv\n         * ```\n         *\/\n        naive_fast_invntt_equiv : Tq -> Bit\n        property naive_fast_invntt_equiv f =  NaiveNTTInv f == fast_invntt f\n\n    \/**\n     * The Number-Theoretic Transform (NTT) is used to improve the efficiency\n     * of multiplication in the ring `R_q`. We choose to use the fast version\n     * of NTT, which is equivalent to the version described in the spec.\n     *\/\n    NTT : Rq -> Tq\n    NTT = fast_ntt\n\n    \/**\n     * The inverse of the Number-Theoretic Transform (NTT) is used to improve\n     * the efficiency of multiplication in the ring `R_q`. We choose to use\n     * the fast version of inverse function, which is equivalent to the version\n     * described in the spec.\n     *\/\n    NTTInv : Tq -> Rq\n    NTTInv = fast_invntt\n\n    \/**\n     * The notation `NTT` is overloaded to mean both a single application of `NTT`\n     * to an element of `R_q` and also `k` applications of `NTT` to every element\n     * of a `k`-length vector.\n     * [FIPS-203] Section 2.4.6 Equation 2.9.\n     *\/\n    NTT_Vec v = map NTT v\n\n    \/**\n     * The notation `NTTInv` is overloaded to mean both a single application of\n     * `NTTInv` to an element of `R_q` and also `k` applications of `NTTInv` to\n     * every element of a `k`-length vector.\n     * [FIPS-203] Section 2.4.6.\n     *\/\n    NTTInv_Vec v = map NTTInv v\n\n\n    \/**\n     * Compute the product of two degree-one polynomials with respect to a\n     * quadratic modulus.\n     * [FIPS-203] Section 4.3.1 Algorithm 12.\n     *\/\n    BaseCaseMultiply : (Z q) -> (Z q) -> (Z q) -> (Z q) -> (Z q) -> [2](Z q)\n    BaseCaseMultiply a0 a1 b0 b1 \u03b3 = [c0, c1]\n      where\n        c0 = a0 * b0 + a1 * b1 * \u03b3\n        c1 = a0 * b1 + a1 * b0\n\n    \/**\n     * Compute the product (in the ring `T_q`) of two NTT representations.\n     * [FIPS-203] Section 4.3.1 Algorithm 11.\n     *\/\n    MultiplyNTTs : Tq -> Tq -> Tq\n    MultiplyNTTs f_hat g_hat = join h_hat where\n        h_hat = [ BaseCaseMultiply\n            (f_hat @(2*i))\n            (f_hat @(2*i+1))\n            (g_hat @(2*i))\n            (g_hat @(2*i+1))\n            (zeta ^^(2 * BitRev7 i + 1))\n        | i <- [0 .. 127] ]\n\n    \/**\n     * Testing that (1+x)^2 = 1+2x+x^2.\n     * ```repl\n     * :prove TestMult\n     * ```\n     *\/\n    TestMult : Bit\n    property TestMult = prod f f == fsq where\n      f = [1, 1] # [0 | i <- [3 .. 256]]\n      fsq = [1,2,1] # [0 | i <- [4 .. 256]]\n\n      prod : Rq -> Rq -> Rq\n      prod a b = NTTInv (MultiplyNTTs (NTT a) (NTT b))\n\n    \/**\n     * The cross product notation \u00d7\ud835\udc47\ud835\udc5e is defined as the `MultiplyNTTs` function\n     * (also referred to as `T_q` multiplication).\n     * [FIPS-203] Section 2.4.5 Equation 2.8.\n     *\/\n    (\u00d7) = MultiplyNTTs\n\n    \/**\n     * Overloaded `dot` function between two vectors is a standard dot-product\n     * functionality with `T_q` multiplication as the base operation.\n     * [FIPS-203] Section 2.4.7 Equation 2.14.\n     *\/\n    dotVecVec : {k1} (fin k1) => [k1]Tq -> [k1]Tq -> Tq\n    dotVecVec v1 v2 = sum (zipWith (\u00d7) v1 v2)\n\n    \/**\n     * Overloaded `dot` function between a matrix and a vector is standard\n     * matrix-vector multiplication with `T_q` multiplication as the base\n     * operation.\n     * [FIPS-203] Section 2.4.7 Equation 2.12 and 2.13.\n     *\/\n    dotMatVec : {k1,k2} (fin k1, fin k2) => [k1][k2]Tq -> [k2]Tq -> [k1]Tq\n    dotMatVec matrix vector = [dotVecVec v1 vector | v1 <- matrix]\n\n    \/**\n     * Overloaded `dot` function between two matrices is standard matrix\n     * multiplication with `T_q` multiplication as the base operation.\n     * [FIPS-203] Section 2.4.7.\n     *\/\n    dotMatMat :{k1,k2,k3} (fin k1, fin k2, fin k3) =>\n        [k1][k2]Tq -> [k2][k3]Tq -> [k1][k3]Tq\n    dotMatMat matrix1 matrix2 = transpose [dotMatVec matrix1 vector | vector <- m']\n        where m' = transpose matrix2\n\n\/**\n * The K-PKE component scheme.\n *\n * \u26a0\ufe0f This scheme is not approved for stand-alone use! \u26a0\ufe0f\n * K-PKE is an encryption scheme consisting of three algorithms `(KeyGen,\n * Encrypt, Decrypt)`, which are used to instantiate the approved ML-KEM\n * scheme. It's not secure as a standalone scheme; it doesn't do any input\n * checking.\n * [FIPS-203] Section 5.\n *\/\nprivate submodule K_PKE where\n    \/\/ Encryption key for the K_PKE component scheme.\n    \/\/ [FIPS-203] Section 5 Algorithm 13. See \"Output\".\n    type EncryptionKey = [384 * k + 32]Byte\n\n    \/\/ Decryption key for the K_PKE component scheme.\n    \/\/ [FIPS-203] Section 5 Algorithm 13. See \"Output\".\n    type DecryptionKey = [384 * k]Byte\n\n    \/\/ Ciphertext generated by the K_PKE component scheme.\n    \/\/ [FIPS-203] Section 5 Algorithm 14. See \"Output\".\n    type Ciphertext = [32 * (d_u * k + d_v)]Byte\n\n    \/**\n     * Key generation for the K-PKE component scheme.\n     *\n     * \u26a0\ufe0f Warnings \u26a0\ufe0f\n     * - This scheme is not approved for use in a stand-alone fashion! It does not\n     *   do any input validation and should only be used as a subroutine of ML-KEM.\n     * - The seed `d` passed as input and the decryption key `dkPKE` returned from\n     *   this algorithm must be kept private!\n     *\n     * [FIPS-203] Section 5.1 Algorithm 13.\n     *\/\n    KeyGen: [32]Byte -> (EncryptionKey, DecryptionKey)\n    KeyGen d = (ekPKE, dkPKE) where\n        \/\/ Step 1.\n        (\u03c1, \u03c3) = G (d # [`(k)])\n        \/\/ Steps 3-7.\n        A_hat = [[ SampleNTT (\u03c1 # [j] # [i])\n            | j <- [0 .. k-1]]\n            | i <- [0 .. k-1]]\n        \/\/ Steps 2, 8-11.\n        s = [SamplePolyCBD`{eta_1} (PRF \u03c3 N)\n            | N <- [0 .. k-1]]\n        \/\/ Steps 12 - 15.\n        e = [SamplePolyCBD`{eta_1} (PRF \u03c3 N)\n            | N <- [k .. 2 * k - 1]]\n        \/\/ Step 16.\n        s_hat = NTT_Vec s\n        \/\/ Step 17.\n        e_hat = NTT_Vec e\n        \/\/ Step 18.\n        t_hat = (dotMatVec A_hat s_hat) + e_hat\n        \/\/ Step 19.\n        ekPKE = (ByteEncode12_Vec t_hat) # \u03c1\n        \/\/ Step 20.\n        dkPKE = ByteEncode12_Vec s_hat\n\n    \/**\n     * Encryption algorithm for the K-PKE component scheme.\n     *\n     * \u26a0\ufe0f Warning \u26a0\ufe0f This scheme is not approved for use in a stand-alone fashion!\n     * It does not do any input validation and should only be used as a subroutine\n     * of ML-KEM.\n     *\n     * [FIPS-203] Section 5.2 Algorithm 14.\n     *\/\n    Encrypt : EncryptionKey -> [32]Byte -> [32]Byte -> Ciphertext\n    Encrypt ekPKE m r = c where\n        \/\/ Step 2.\n        t_hat = ByteDecode12_Vec (ekPKE @@[0 .. 384*k - 1])\n        \/\/ Step 3.\n        rho = ekPKE @@[384*k .. 384*k + 32 - 1]\n        \/\/ Steps 4-8.\n        A_hat = [[ SampleNTT (rho # [j] # [i])\n            | j <- [0 .. k-1]]\n            | i <- [0 .. k-1]]\n        \/\/ Steps 1, 9-12.\n        y = [SamplePolyCBD`{eta_1} (PRF r N)\n            | N <- [0 .. k-1]]\n        \/\/ Steps 13-16.\n        e1 = [SamplePolyCBD`{eta_2} (PRF r N)\n            | N <- [k .. 2 * k - 1]]\n        \/\/ Step 17. In the spec, the second parameter is `N = 2k`. In this\n        \/\/ implementation, `N` itself is out of scope, so we use the fixed\n        \/\/ value instead.\n        e2 = SamplePolyCBD`{eta_2} (PRF r (2 * `k))\n        \/\/ Step 18.\n        y_hat = NTT_Vec y\n        \/\/ Step 19.\n        u = NTTInv_Vec (dotMatVec (transpose A_hat) y_hat) + e1\n        \/\/ Step 20.\n        mu = Decompress_Vec`{1} (ByteDecode`{1} m)\n                v = (NTTInv (dotVecVec t_hat y_hat)) + e2 + mu\n                c1 = ByteEncode_Vec`{d_u} (Compress_Mat`{d_u} u)\n                c2 = ByteEncode`{d_v} (Compress_Vec`{d_v} v)\n                c = c1 # c2\n\n    \/**\n     * Decryption algorithm for the K-PKE component scheme.\n     *\n     * \u26a0\ufe0f Warning \u26a0\ufe0f This scheme is not approved for use in a stand-alone fashion!\n     * It does not do any input validation and should only be used as a subroutine\n     * of ML-KEM.\n     *\n     * [FIPS-203] Section 5.3 Algorithm 15.\n     *\/\n    Decrypt : DecryptionKey -> Ciphertext -> [32]Byte\n    Decrypt dkPKE c = m where\n        \/\/ Step 1.\n        c1 = c @@[0 .. 32 * d_u * k - 1]\n        \/\/ Step 2.\n        c2 = c @@[32 * d_u * k .. 32 * (d_u * k + d_v) - 1]\n        \/\/ Step 3.j\n        u' = Decompress_Mat`{d_u} (ByteDecode_Vec`{d_u} c1)\n                v' = Decompress_Vec`{d_v} (ByteDecode`{d_v} c2)\n        \/\/ Step 5.\n        s_hat = ByteDecode12_Vec dkPKE\n        \/\/ Step 6.\n        w = v' - NTTInv (dotVecVec s_hat (NTT_Vec u'))\n        \/\/ Step 7.\n        m = ByteEncode`{1} (Compress_Vec`{1} w)\n\n    \/**\n     * The K-PKE scheme must satisfy the basic properties of an encryption\n     * scheme.\n     * This must be `:check`ed because K-PKE is correct with probability\n     * 1-delta and not 1. It is not provably correct because there is a\n     * (very small!) fraction of seeds `d, r` that don't work.\n     * ```repl\n     * :set tests=3\n     * :check CorrectnessPKE\n     * ```\n     *\/\n    CorrectnessPKE : [32]Byte -> [32]Byte -> [32]Byte -> Bit\n    property CorrectnessPKE d m r = (m' == m) where\n        (pk, sk) = KeyGen d\n        c = Encrypt pk m r\n        m' = Decrypt sk c\n\n\nprivate\n    \/**\n     * Uses randomness to generate an encapsulation key and corresponding\n     * decapsulation key.\n     * [FIPS-203] Section 6.1 Algorithm 16.\n     *\n     * Warning: This function does not validate input and should not be used\n     * externally!\n     *\/\n    KeyGen_internal : [32]Byte -> [32]Byte\n        -> (EncapsulationKey, DecapsulationKey)\n    KeyGen_internal d z = (ek, dk) where\n      (ekPKE, dkPKE) = K_PKE::KeyGen d\n      ek = ekPKE\n      dk = dkPKE # ek # (H ek) # z\n\n    \/**\n     * Uses the encapsulation key and randomness to generate a key and an\n     * associated ciphertext.\n     * [FIPS-203] Section 6.2 Algorithm 17.\n     *\n     * Warning: This function does not validate input and should not be used\n     * externally!\n     *\/\n    Encaps_internal : EncapsulationKey -> [32]Byte\n        -> (SharedSecretKey, Ciphertext)\n    Encaps_internal ek m = (K, c) where\n      (K, r) = G (m # (H ek))\n      c = K_PKE::Encrypt ek m r\n\n    \/**\n     * Uses the decapsulation key to produce a shared secret key from a\n     * ciphertext.\n     * [FIPS-203] Section 6.3 Algorithm 18.\n     *\n     * Warning: This function does not validate input and should not be used\n     * externally!\n     *\/\n    Decaps_internal : DecapsulationKey -> Ciphertext -> SharedSecretKey\n    Decaps_internal dk c = K where\n        \/\/ Step 1. Extract (from KEM decaps key) the PKE decryption key.\n        dkPKE = dk @@ [0 .. 384*k - 1]\n        \/\/ Step 2. Extract PKE encryption key.\n        ekPKE = dk @@ [384*k .. 768*k + 32 - 1]\n        \/\/ Step 3. Extract hash of PKE encryption key.\n        h = dk @@ [768*k + 32 .. 768*k + 64 - 1]\n        \/\/ Step 4. Extract implicit rejection value.\n        z = dk @@ [768*k + 64 .. 768*k + 96 - 1]\n        \/\/ Step 5. Decrypt ciphertext.\n        m' = K_PKE::Decrypt dkPKE c\n        \/\/ Step 6.\n        (K', r') = G (m' # h)\n        \/\/ Step 7.\n        Kbar = J (z # c)\n        \/\/ Step 8. Re-encrypt using the derived randomness `r'`.\n        c' = K_PKE::Encrypt ekPKE m' r'\n        \/\/ Step 9 - 11. If ciphertextx do not match, \"implicitly reject\".\n        K = if (c != c') then\n                Kbar\n            else\n                K'\n\n    \/**\n     * The ML-KEM scheme is correct with probability 1-delta and not 1. As a\n     * result, running `:prove CorrectnessPKE` will not succeed since there is a\n     * fraction delta of seeds `d`, `z`, `m` that do not work.\n     * Cryptol does not currently support counting.\n     * ```repl\n     * :set tests=3\n     * :check CorrectnessKEM\n     * ```\n     *\/\n    CorrectnessKEM : [32]Byte -> [32]Byte -> [32]Byte -> Bit\n    property CorrectnessKEM z d m = (K == K') where\n        (ek, dk) = KeyGen_internal d z\n        (K, c) = Encaps_internal ek m\n        K' = Decaps_internal dk c\n\n\/*\n * Type of an encapsulation key used in the public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 19.\n * See also the paragraph \"Terminology for keys\" in Section 3.2.\n *\/\ntype EncapsulationKey = [384 * k + 32]Byte\n\n\/*\n * Type of an decapsulation key used in the public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 19.\n * See also the paragraph \"Terminology for keys\" in Section 3.2.\n *\/\ntype DecapsulationKey = [768 * k + 96]Byte\n\n\/*\n * Type of the shared secret key material generated by the public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 20.\n * See also the paragraph \"Terminology for keys\" in Section 3.2.\n *\/\ntype SharedSecretKey = [32]Byte\n\n\/*\n * Type of the ciphertext generated by teh public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 20.\n *\n * Usage: This ciphertext is only used in the context of ML-KEM, to derive a\n * shared secret key.\n *\/\ntype Ciphertext = [32 * (d_u * k + d_v)]Byte\n\n\/**\n * Generate an encapsulation key and a corresponding decapsulation key.\n * [FIPS-203] Section 7.1, Algorithm 19.\n *\n * This differs from the spec: it takes the randomness `d` and `z` as\n * parameters instead of generating them internally (because Cryptol\n * cannot generate randomness).\n *\n * The decapsulation key produced from this function MUST remain private. The\n * seed `(d, z)` produced (or in this case, passed as input) is sensitive data\n * and MUST be treated with the same safeguards as the decapsulation key.\n *\/\nKeyGen : Option ([32]Byte) -> Option ([32]Byte)\n    -> (EncapsulationKey, DecapsulationKey)\nKeyGen d z = (ek, dk) where\n    \/\/ Steps 1 and 2 are skipped because Cryptol cannot generate randomness.\n    \/\/ Step 3 - 5.\n    d' = case d of\n        None -> error \"Random bit generation failed; `d` not initialized.\"\n        Some _d -> _d\n    z' = case z of\n        None -> error \"Random bit generation failed; `z` not initialized.\"\n        Some _z -> _z\n    \/\/ Step 6.\n    (ek, dk) = KeyGen_internal d' z'\n\n\/**\n * Perform checks on a key pair.\n *\n * The security of ML-KEM depends on the use of key pairs that were correctly\n * generated using `KeyGen`!\n * This checking process _does not_ guarantee that the input pair is a properly\n * produced output of `KeyGen`. While these checks can detect certain\n * corruptions, they do not guarantee that the key pair was properly generated.\n *\/\nkeyPairCheck : EncapsulationKey\n    -> DecapsulationKey\n    -> Option ([32]Byte, [32]Byte)\n    -> [32]Byte\n    -> Bit\nkeyPairCheck ek dk maybe_seed m =\n    seedConsistency && encapsCheck && decapsCheck && pairwiseConsistency where\n    seedConsistency = case maybe_seed of\n        Some (d, z) -> KeyGen_internal d z == (ek, dk)\n        None -> True\n\n    encapsCheck = encapsulationKeyCheck ek\n    decapsCheck = decapsulationKeyCheck dk\n\n    pairwiseConsistency = K == K'\n    (K, c) = Encaps_internal ek m\n    K' = Decaps_internal dk c\n\n\/**\n * A properly produced output of the `KeyGen` function should always pass the\n * key pair checks.\n * ```repl\n * :set tests=3\n * :check KeyGenProducesValidKeys\n * ```\n *\/\nKeyGenProducesValidKeys d z m = keyPairCheck ek dk (Some (d, z)) m where\n    (ek, dk) = KeyGen (Some d) (Some z)\n\n\/**\n * Perform checks on a candidate encapsulation key.\n *\n * The type check is implicit; if this function compiles with a given `ek`,\n * then it must be of the correct type.\n *\n * This checking process _does not_ gurantee that `ek` is a properly produced\n * output of `KeyGen`.\n *\/\nencapsulationKeyCheck : EncapsulationKey -> Bool\nencapsulationKeyCheck ek = modulusCheck where\n    test = ByteEncode12_Vec (ByteDecode12_Vec (ek @@ [0..384 * k - 1]))\n    modulusCheck = test == (ek @@ [0..384 * k - 1])\n\n\/**\n * Use the encapsulation key to generate a shared secret an an associated\n * ciphertext.\n * [FIPS-203] Section 7.2, Algorithm 20.\n *\n * This differs from the spec: it takes the randomness `m` as a parameter\n * instead of generating it internally (because Cryptol cannot generate\n * randomness).\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f\n * The encapsulation key passed as a parameter MUST be checked before use with\n * `encapsulationKeyCheck`! The caller must have assurance that the\n * encapsulation key is valid.\n * This executable spec (and Cryptol in general) cannot enforce this\n * requirement! Implementors must check it manually.\n *\/\nEncaps : EncapsulationKey -> Option ([32]Byte) -> (SharedSecretKey, Ciphertext)\nEncaps ek m = (K, c) where\n    \/\/ Step 1 is skipped because Cryptol cannot generate randomness.\n    \/\/ Step 2 - 4.\n    m' = case m of\n        None -> error \"Random bit generation failed; `m` not initialized.\"\n        Some _m -> _m\n    \/\/ Step 5.\n    (K, c) = Encaps_internal ek m'\n\n\/**\n * Perform three checks on candidate inputs to decapsulation.\n * [FIPS-203] Section 7.3 \"Decapsulation input check\" #1-3.\n *\n * The type checks are implicit; if this function compiles with a given `dk`\n * and `c`, then they must be of the correct type.\n *\n * This check _does not_ guarantee that `dk` is a propertly produced output\n * of `KeyGen`, or that `c` is a properly produced output of `Encaps`!\n *\/\ndecapsulationInputCheck : DecapsulationKey -> Ciphertext -> Bool\ndecapsulationInputCheck dk c = decapsulationKeyCheck dk\n\nprivate\n    \/**\n     * Perform a type check and a hash check on a candidate decapsulation key.\n     * [FIPS-203] Section 7.3 \"Decapsulation input check\" #2-3.\n     *\n     * The type check is implicit; if this function compiles with a given `dk`,\n     * then it must be the correct type.\n     *\n     * This check _does not_ guarantee that `dk` is a propertly produced output\n     * of `KeyGen`!\n     *\/\n    decapsulationKeyCheck : DecapsulationKey -> Bool\n    decapsulationKeyCheck dk = hash_check where\n        test = H (dk @@ [384*k .. 768*k + 32 - 1])\n        hash_check = test == (dk @@ [768*k + 32 .. 768*k + 64 - 1])\n\n\n\/**\n * Use the decapsulation key to produce a shared secret from a ciphertext.\n * [FIPS-203] Section 7.3, Algorithm 21.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f\n * The decapsulation key and the ciphertext MUST be checked before use with\n * `decapsulationInputCheck`! The caller must have assurance that the\n * decapsulation key and ciphertext are valid.\n * This executable spec (and Cryptol in general) cannot enforce this\n * requirement! Implementors must check it manually.\n *\/\nDecaps : DecapsulationKey -> Ciphertext -> SharedSecretKey\nDecaps = Decaps_internal\n\nparameter\n    \/*\n     * The parameter `k` determines the dimensions of the encryption key matrix\n     * and the secret and noise vectors created and used in key generation and\n     * encryption.\n     * [FIPS-203] Section 8.\n     *\n     * The constraint on the width of `k` is drawn from `K-PKE-KeyGen`. In\n     * that function, the variable `N` varies from 0 to `2k` and is passed as\n     * the second parameter to the `PRF` function. `PRF` restricts the second\n     * parameter to be exactly 1 byte. Therefore, `2k` must fit into a byte.\n     * [FIPS-203] Section 5.1 Algorithm 13 (see lines 2 and 8-15) and Section\n     * 4.1 Equation 4.2.\n     *\/\n    type k : #\n    type constraint (width k > 0, width (2*k) <= 8)\n\n    \/*\n     * The parameter `eta_1` specifies the distribution from which the secret\n     * vectors are drawn in key generation and encryption.\n     * [FIPS-203] Section 8.\n     *\n     * eta_1 must be in the set {2, 3} for use in a PRF and to parameterize\n     * sampling from the centered binomial distribution.\n     * [FIPS-203] Section 4.1 \"Pseudorandom Function\" and Section 4.2.2\n     * \"Sampling from the centered binomial distribution\"\n     *\/\n    type eta_1 : #\n    type constraint (fin eta_1, 2 <= eta_1, eta_1 <= 3)\n\n    \/*\n     * The parameter eta_2 is required to specify the distribution from which\n     * the noise vectors are drawn in encryption.\n     * [FIPS-203] Section 8.\n     *\n     * eta_2 must be in the set {2, 3} for use in a PRF and to parameterize\n     * sampling from the centered binomial distribution.\n     * [FIPS-203] Section 4.1 \"Pseudorandom Function\" and Section 4.2.2\n     * \"Sampling from the centered binomial distribution\"\n     *\/\n    type eta_2 : #\n    type constraint (fin eta_2, 2 <= eta_2, eta_2 <= 3)\n\n    \/*\n     * The parameter `d_u` is a parameter and input for the compression and\n     * encoding functions.\n     * [FIPS-203] Section 8.\n     *\n     * For compression, `d_u` must be smaller than the bit length of `q` (fixed\n     * to 12).\n     * [FIPS-203] Section 4.2.1 \"Compression and decompression\".\n     * For encoding, the valid range of values for `d_u` is `1 \u2264 d_u \u2264 12`.\n     * [FIPS-203] Section 4.2.1 \"Encoding and decoding\".\n     *\/\n    type d_u : #\n    type constraint (fin d_u, d_u < 12, d_u > 0)\n\n    \/*\n     * The parameter `d_v` is a parameter and input for the compression and\n     * encoding functions.\n     * [FIPS-203] Section 8.\n     *\n     * For compression, `d_v` must be smaller than the bit length of `q` (fixed\n     * to 12).\n     * [FIPS-203] Section 4.2.1 \"Compression and decompression\".\n     * For encoding, the valid range of values for `d_v` is `1 \u2264 d_v \u2264 12`.\n     * [FIPS-203] Section 4.2.1 \"Encoding and decoding\".\n     *\/\n    type d_v : #\n    type constraint (fin d_v, d_v < 12, d_v > 0)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ECDH\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and security properties of the ECC_CDH function in the given ECDH specification module. The properties should check that ECC_CDH produces a valid shared secret when given valid SigningKey and VerifyingKey inputs, that the verifying keys are properly validated using verifyingKeyFullyValid, and that keyPairIsConsistent holds for key pairs used. Include checks that invalid keys cause ECC_CDH to return None. Ensure the properties align with the constraints and warnings described in the specification comments, especially regarding key validity and the non-usage of the shared secret as a direct key."},{"role":"assistant","content":"```cryptol\n\/**\n * Specification for some of the cryptographic primitives used in pair-wise key\n * establishment as defined in [SP-800-56Ar3].\n *\n * \u26a0 Warning \u26a0\n * This file DOES NOT implement the complete specification in [SP-800-56Ar3]!\n * It omits many components, including cryptographic elements and the larger\n * key agreement schemes that combine those elements into secure protocols.\n * These missing pieces are _necessary_ for secure key establishment! Use of\n * the `ECC_CDH` primitive in this file does not constitute key agreement!\n * - It DOES NOT enforce use of valid domain parameters! The architecture of\n *   this module requires instantiation with an elliptic curve, but the EC\n *   interface does not enforce that the parameters are valid or consistently\n *   applied. Implementers must ensure that the EC instantiation they choose\n *   is suitable. See [SP-800-56Ar3] Section 5.5.\n * - It DOES NOT contain a complete model of keys! Keys are either static or\n *   ephemeral; keys should be associated with the domain parameters used to\n *   generate them, generated appropriately, protected from compromise (for\n *   private \/ signing keys), and protected with integrity. Static keys must\n *   also be associated with an identifier for the owner and must not be\n *   reused for other applications. None of these requirements are described or\n *   enforced in this file! See [SP-800-56Ar3] Section 5.6.1 (key generation),\n *   Section 5.6.2 (context on calling the validation methods implemented\n *   here), and Section 5.6.3 (key management).\n * - It DOES NOT contain any key derivation methods! A key derivation method\n *   must be used to derive a key from the shared secret; the secret cannot\n *   be used as-is for keying material, nor can it ever be used as a key stream\n *   for a stream cipher. See [SP-800-56Ar3] Section 5.8.\n * - It DOES NOT contain any key confirmation methods! Key confirmation can be\n *   used to provide assurance to one or both parties that both participants\n *   have completed the protocol with the same key. See [SP-800-56Ar3] Section\n *   5.9.\n * - It DOES NOT implement any complete key establishment schemes! A complete\n *   pair-wise key establishment protocol allows two parties to generate\n *   matching keying material. These schemes combine all of the primitives in\n *   [SP-800-56Ar3] into secure protocols. The primitive to compute a shared\n *   secret that's provided in this file is inadequate! See [SP-800-56Ar3]\n *   Section 6 (key establishment schemes) and Section 7 (selecting a key\n *   establishment scheme).\n *\n * It also omits all of the components of [SP-800-56Ar3] that have to do with\n * finite field cryptography and MQV-based schemes for key agreement.\n *\n * References:\n * [SP-800-56Ar3]: Elaine Barker, LilyChen, Allen Roginsky, Apostol Vassilev,\n *    Richard Davis. Recommendation for Pair-Wise Key-Establishment Schemes\n *    Using Discrete Logarithm Cryptography. (National Institute of Standards\n *    and Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST\n *    SP 800-56A Revision 3. April 2018.\n *    @see https:\/\/doi.org\/10.6028\/NIST.SP.800-56Ar3\n * [SP-800-186]: Lily Chen, Dustin Moody, Karen Randall, Andrew Regenscheid,\n *    Angela Robinson. Recommendations for Discrete Logarithm-based Cryptography:\n *    Elliptic Curve Domain Parameters. (National Institute of Standards and\n *    Technology, Gaithersburg, MD), NIST Special Publication (SP) NIST SP\n *    800-186. February 2023.\n *    @see https:\/\/doi.org\/10.6028\/NIST.SP.800-186\n *\n * @copyright Galois, Inc.\n * @author Marcella Hastings <marcella@galois.com>\n *\n *\/\nmodule Primitive::Asymmetric::KEM::ECDH::Specification where\n\nimport Common::utils(ZtoBV)\n\n\/**\n * Secure key establishment depends on the arithmetic validity of the domain\n * parameters used by the parties.\n *\n * \u26a0 Warning \u26a0\n * Instantiation of this interface does not guarantee validity of the domain\n * parameters! Implementors must ensure that they instantiate this interface\n * with an approved curve as specified in [SP-800-186], and must also ensure\n * that the implementation of that curve is correct.\n * [SP-800-56Ar3] Section 5.5.2.\n *\n * Note: The specification [SP-800-56Ar3] uses the term \"identity\" to refer to\n * the additive identity element of the elliptic curve group. For the approved\n * curves, the identity point is always the special \"point at infinity\". These\n * terms are used interchangeably in this documentation.\n *\/\nimport interface Common::EC::ECInterface as EC\n\n\/**\n * An ECC private, or signing, key.\n *\n * A valid private key is an integer that is randomly selected in the\n * interval [1, n-1]. This type can be used to represent either static or\n * ephemeral keys (as defined in [SP-800-56Ar3]).\n *\n * \u26a0 Warning \u26a0\n * This must be generated with an approved method! This specification does\n * not enforce correct generation.\n *\n * [SP-800-56Ar3] Section 5.6.1.2.\n *\/\ntype SigningKey = Z EC::n\n\n\/**\n * An ECC public, or verifying, key.\n *\n * A valid public key is a non-identity point on the curve, in the subgroup\n * generated by the base point `G`. It must form a pair with a corresponding\n * `SigningKey`.\n *\n * \u26a0 Warning \u26a0\n * - This must be generated from a valid `SigningKey`! This specification does\n * not enforce correct generation.\n * - This type alone cannot enforce validity of the `VerifyingKey`.\n * Implementors should use `verifyingKeyFullyValid` to check ensure validity\n * before using a key for any key establishment schemes.\n *\n * [SP-800-56Ar3] Section 5.6.1.2.\n *\/\ntype VerifyingKey = EC::Point\n\n\/**\n * Get assurance of private-key validity.\n *\n * A valid private key is in the interval `[1, n-1]`, where `n` is the order\n * of the base point for the curve.\n * The upper bound is assured by the `SigningKey` type itself: the integer mod\n * group in Cryptol consists of the integers in the range `[0, n-1]`.\n *\n * [SP-800-56Ar3] Section 5.6.2.1.2.\n *\/\nsigningKeyValid : SigningKey -> Bool\nsigningKeyValid d = d != 0\n\n\/**\n * Check whether the verifying key is fully valid:\n * - It must not be the point at infinity;\n * - It must have the expected representation for an element in the underlying\n *   field;\n * - It must be a point on the correct curve; and\n * - It must have the correct order.\n *\n * [SP-800-56Ar3] Section 5.6.2.3.3.\n *\/\nverifyingKeyFullyValid : VerifyingKey -> Bool\nverifyingKeyFullyValid Q = verifyingKeyPartiallyValid Q && correctOrder where\n    correctOrder = EC::isInfinity (EC::scmul `EC::n Q)\n\n\/**\n * Partially check whether the verifying key is valid:\n * - It must not be the point at infinity;\n * - It must have the expected representation for an element in the underlying\n *   field; and\n * - It must be a point on the correct curve.\n *\n * \u26a0 Warning \u26a0\n * This routine omits the validation that the point is in the subgroup\n * generated by the base point `G`; it is usually faster than full validation.\n * This should only be used for _ephemeral_ ECC public keys!\n *\n * [SP-800-56Ar3] Section 5.6.2.3.4.\n *\/\nverifyingKeyPartiallyValid : VerifyingKey -> Bool\nverifyingKeyPartiallyValid Q = EC::isValid Q && ~(EC::isInfinity Q)\n\n\/**\n * The owner of a key pair needs to make sure it's consistent before using it\n * for key establishment.\n * [SP-800-56Ar3] Section 5.6.2.1.4.\n *\/\nkeyPairIsConsistent : SigningKey -> VerifyingKey -> Bool\nkeyPairIsConsistent d Q = EC::pointEq expectedQ Q where\n    expectedQ = EC::scmul (fromZ d) EC::G\n\n\/**\n * Compute a shared secret `Z` using the domain parameters, the other party's\n * public key (`QB`) and one's own private key (`dA`).\n *\n * \u26a0 Warning: Deviation from the spec \u26a0\n * This deviates from the spec in one important way: All intermediate values,\n * including `P` and `z`, should be destroyed (zeroized) before providing\n * output. Cryptol cannot express this; implementors must manually verify that\n * all potentially sensitive local data is destroyed.\n * [SP-800-56Ar3] Section 5.7.1.2.\n *\n * \u26a0 Warning: Usage \u26a0\n * This routine is not secure if used in isolation! It should be\n * used as a component of one of the key agreement schemes described in\n * [SP-800-56Ar3] Section 6. These schemes handle (input) key management and\n * validation, (output) key derivation, and optional key confirmation.\n * There are several obvious failure modes if this primitive is used in\n * isolation:\n * - Failure to use a valid key agreement scheme can compromise the security of\n * the `SigningKey`s used in `ECC_CDH`! This routine does not validate the\n * other party's public key. A malicious party can claim invalid curve points\n * for her public key `QB` and collect residues to derive the honest party's\n * private key!\n * - The output of this method is a _shared secret_, not a key!\n * It _must not_ be used directly as keying material. An approved key\n * derivation method must be used to derive keying material from the shared\n * secret. [SP-800-56Ar3] Section 5.8.\n *\/\nECC_CDH : SigningKey -> VerifyingKey -> Option ([(width EC::n) \/^ 8][8])\nECC_CDH dA QB = maybe_Z where\n    \/\/ Step 1. Compute P = h dA QB\n    P = EC::scmul EC::h (EC::scmul (fromZ dA) QB)\n    maybe_Z = case EC::xCoord P of\n        \/\/ Step 2.\n        \/\/ xCoord returns `None` if `P` is the point at infinity.\n        None -> None\n        \/\/ Step 3.\n        \/\/ The built-in Cryptol conversion methods produce the same output as the\n        \/\/ routine described in [SP-800-56Ar3] Appendix C.2.\n        Some z -> Some (split (ZtoBV z))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Instantiations\/ML_KEM512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the correctness properties and security invariants for the ML_KEM512 instantiation parameters (k=2, eta_1=3, eta_2=2, d_u=10, d_v=4) in the ML_KEM module. The specification should capture the expected behavior of key encapsulation and decapsulation functions, ensuring that encapsulated keys can be correctly decapsulated and that the scheme meets its intended security guarantees."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM512 =\n    Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\ntype k = 2\ntype eta_1 = 3\ntype eta_2 = 2\ntype d_u = 10\ntype d_v = 4\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Instantiations\/ML_KEM1024.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the key encapsulation mechanism (KEM) parameters and operations for the ML_KEM1024 instantiation, including types and constraints for k, eta_1, eta_2, d_u, and d_v, suitable for property-based verification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM1024 =\n    Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\ntype k = 4\ntype eta_1 = 2\ntype eta_2 = 2\ntype d_u = 11\ntype d_v = 5\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Instantiations\/ML_KEM768.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the correctness properties for the ML_KEM768 key encapsulation mechanism, including key generation, encapsulation, and decapsulation functions, based on the parameters k=3, eta_1=2, eta_2=2, d_u=10, and d_v=4 as given in the ML_KEM768 module."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM768 =\n    Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\ntype k = 3\ntype eta_1 = 2\ntype eta_2 = 2\ntype d_u = 10\ntype d_v = 4\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/ECInterface.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol specifications that formally define the expected properties and behaviors of the elliptic curve interface described in the ECInterface module. Include properties to verify correctness of point equality, validity checks, point addition, subtraction, doubling, scalar multiplication, twin multiplication, and coordinate extraction, ensuring they adhere to elliptic curve group laws and field constraints."},{"role":"assistant","content":"```cryptol\ninterface module Common::EC::ECInterface where\n    \/**\n     * Representation of a point on the curve.\n     *\n     * This should be able to represent both concrete points (with an x and y\n     * coordinate) and the point at infinity.\n     *\/\n    type Point : *\n\n    \/**\n     * Order of the base point `G` for the curve.\n     *\/\n    type n : #\n    type constraint (fin n, prime n, n >= 1)\n\n    \/**\n     * Modulus of the field over which the curve is defined.\n     *\n     * The curve must be defined over a Galois fields `GF(q)` for some `q`\n     * (typically an odd prime or 2^m).\n     *\/\n    type q : #\n    type constraint (fin q, q >= 1)\n\n    \/**\n     * Cofactor for the elliptic curve.\n     *\n     * The order of the curve is defined as `h * n`, where `h` is small\n     * and `n`, the order of the base point `G`, is prime. If `h` is not\n     * 1, then the base point does not generate the entire curve.\n     *\/\n    h : Integer\n\n    \/**\n     * Base point for the curve.\n     *\/\n    G : Point\n\n    \/**\n     * Indicate whether a point is the point at infinity (also known as the\n     * identity).\n     *\/\n    isInfinity : Point -> Bool\n\n    \/**\n     * Indicate whether a point is valid: either the point at infinity or\n     * another point on the curve.\n     *\n     * This should check the following:\n     * - The coordinates of the `Point` are correctly formed\n     * - The point is either on the curve (e.g. satisfies the curve equation)\n     *   OR is the point at infinity.\n     *\/\n    isValid : Point -> Bool\n\n    \/**\n     * Indicate whether two points are the same.\n     *\/\n    pointEq : Point -> Point -> Bool\n\n    \/**\n     * Addition of two points.\n     *\/\n    add : Point -> Point -> Point\n\n    \/**\n     * Subtraction of two points.\n     *\/\n    sub : Point -> Point -> Point\n\n    \/**\n     * Doubling of a point (typically, elliptic curves offer optimized\n     * routines for doubling a point compared to adding it to itself).\n     *\/\n    double : Point -> Point\n\n    \/**\n     * Scalar multiplication of a point by an integer.\n     *\/\n    scmul : Integer -> Point -> Point\n\n    \/**\n     * Twin multiplication of two points. This is the operation\n     * [c]P + [d]Q, which sometimes has an optimized routine\n     * compared to doing the scalar multiplications separately.\n     *\/\n    twin_mul : Integer -> Point -> Integer -> Point -> Point\n\n    \/**\n     * Extract the x-coordinate of the affine representation of a `Point`,\n     * or `None` if it's the point at infinity.\n     *\/\n    xCoord: Point -> Option (Z q)\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/Curve25519.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness and consistency of the Curve25519 implementation in the provided file. Include properties that check the encoding and decoding of coordinates, the scalar decoding, the conditional swap functions, and the X25519 key exchange function. Also, specify properties to verify the Diffie-Hellman shared secret agreement and test vectors from RFC 7748. Ensure the properties can be used with Cryptol's :check and :prove commands to validate the cryptographic operations against the RFC specifications."},{"role":"assistant","content":"```cryptol\n\/**\n * Curve 25519 is an elliptic curve commonly used\n * in ECDH, originally created as an alternative\n * to NIST curves. Now, NIST standardizes these curves\n * in NIST SP 800-186.\n *\n * This implementation is based upon RFC 7748.\n *\n * The RFC notes many situations in which side-channels\n * can be exploited in EC cryptography. This executable\n * specification does NOT model all of the constant-time\n * recommendations that the RFC does.\n *\n * The RFC defines a function X448 over Curve448\n * in addition to X25519 and Curve25519. This\n * executable specification includes neither\n * X448 nor Curve448.\n *\n * References:\n *  [rfc 7748]\n *  Elliptic Curves for Security (IRTF RFC 7748)\n *  A. Langley, Google; M. Hamburg, Rambus;\n *  S. Turner, sn3rd.\n *  January 2016\n *  @see https:\/\/datatracker.ietf.org\/doc\/html\/rfc7748\n *\n *  [SP 800-186]\n *  Recommendations for Discrete Logarithm-based Cryptography:\n *  Elliptic Curve Domain Parameters.\n *  L. Chen, D. Moody, K. Randall, A. Regenscheid, A. Robinson.\n *  February 2023\n *  @see https:\/\/doi.org\/10.6028\/NIST.SP.800-186\n *\n *\n * @copyright Galois, Inc.\n * @author John Christensen <jchristensen@galois.com>\n *\/\n\nmodule Common::EC::Curve25519 where\n\nimport Common::utils(ZtoBV, BVtoZ)\n\n\/*\n * Curve 25519 is a Montgomery curve of the form\n * `v^2 = u^3 + A * u^2 + u` over a prime `p`.\n *\n * Reference:\n * [rfc7748] Section 4.1\n *\/\n\n\/**\n * The prime defining the field\n *\/\ntype p = 2^^255 - 19\n\n\/**\n * The coefficient `A`.\n * The multiplication formula in the RFC\n * avoids the direct use of `A`, but it is included\n * for completion.\n *\/\ntype A = 486662\n\n\/**\n * The order of the curve.\n * The multiplication formula in the RFC does not\n * directly use the order of the curve, but it is\n * included for completion.\n *\/\ntype order = 2^^252 + 27742317777372353535851937790883648493\n\n\/**\n * The specification uses hexadecimal notation to define the curve order.\n *\n * ```repl\n * :prove orderOk\n * ```\n *\/\nproperty orderOk = `order == order'\n    where\n        i = toInteger 0x14def9dea2f79cd65812631a5cf5d3ed\n        order' = 2^^252 + i\n\n\/**\n * The `u`-coordinate of the base point `(Gu, Gv)`.\n *\/\ntype Gu = 9\n\n\/**\n * The `v`-coordinate of the base point `(Gu, Gv)`.\n * The multiplication formula in the RFC uses a \"point compressed\"\n * view of elliptic curve points that avoids directly specifying\n * the `v` coordinates. This is included for completion.\n *\/\ntype Gv = 14781619447589544791020593568409986887264606134616475288964881837755586237401\n\n\/**\n * Shorthand for the bytes array of minimum length\n * that can fit some number of bits `b`.\n *\/\ntype Bytes b = [b \/^ 8][8]\n\n\/**\n * Constraint that some number of bits `b` can\n * fit in a byte array of length `n` of finite length.\n *\/\ntype constraint Fit b n = (b \/^ 8 <= n, fin b, fin n)\n\n\/**\n * Take an array of bytes and decode as a little endian number.\n * Follow the specification. Assume that the array is \"already\"\n * little endian.\n *\n * For Curve25519, `bits` is always fixed to be `255`.\n * RFC7748 defines other curves with different bit parameters.\n * To faciliate eventual refactoring, we make this function\n * polymorphic in the parameter `bits`.\n *\n * RFC7748 specifies that the operations work internally\n * with integers, with all operations done `% p`. We use\n * a modular integer type directly, to more closely match\n * the notation in the multiplication formula later.\n *\n * Reference:\n * [rfc7748] Section 5.\n *\/\ndecodeLittleEndian : {bits, n} (Fit bits n) => [n][8] -> Z p\ndecodeLittleEndian x = fromInteger (sum iterates)\n    where\n        lshft y i = y * 256 ^^ i         iterates = [lshft (toInteger b) i | b <- x | i <- [0..bits \/^ 8]]\n\n\/**\n * Test vector for encoding derived\n * from running the Python code provided\n * in Section 5 of [rfc7748].\n *\n * ```repl\n * :prove decodeTest\n * ```\n *\/\nproperty decodeTest = decodeLittleEndian `{88} \"hello world\" == x\n    where\n        x = 121404708502361365413651816\n\n\/**\n * Decode the `u` coordinate.\n * Assume the array is already \"little endian\".\n *\n * Reference:\n * [rfc7748] Section 5.\n *\/\ndecodeUCoordinate : {bits, n} (Fit bits n, bits >= 1) => [n][8] -> Z p\ndecodeUCoordinate u_list = decodeLittleEndian `{bits} u_list''\n    where\n        mask = (1 << (`bits % 8)) - 1 : [8]\n        type m = bits \/^ 8\n        u_list' = take `{m} u_list\n        l = `m - 1\n        u_list'' = if `bits % 8 != 0\n                then update u_list' l (last u_list' && mask)\n                else u_list'\n\n\/**\n * Encode the `u` coordinate from `Z p` as a little endian byte array.\n * Since we use a modular arithmetic type directly, we do not need\n * to reduce the coordinate modulo `p`.\n *\n * We also use Cryptol intrinsics rather than following the specification.\n *\/\nencodeUCoordinate : {bits, n} (Fit bits n, bits >= 1) => Z p -> [n][8]\nencodeUCoordinate u = reverse (split (ZtoBV u))\n\n\/**\n * `encodeUCoordinate` inverts `decodeUCoordinate` if the\n * type parameters are coherent for Curve25519 and the\n * little endian value fits in `255` bits.\n *\n * The final bit affects the correctness of this property\n * because the decoding procedure masks it.\n *\n * ```repl\n * :check encodePartiallyInvertsDecode\n * ```\n *\/\nencodePartiallyInvertsDecode : [32][8] -> Bit\nproperty encodePartiallyInvertsDecode x = ~((x ! 0) @ 0) ==>\n    encodeUCoordinate `{255} (decodeUCoordinate `{255} x) == x\n\n\/**\n * `decodeUCoordinate` inverts `encodeUCoordinate`.\n * Since the `u` coordinates are represented as members of `Z p`,\n * there is no restriction on this property.\n *\n * ```repl\n * :check decodeInvertsEncode\n * ```\n *\/\ndecodeInvertsEncode : Z p -> Bit\nproperty decodeInvertsEncode x =\n    decodeUCoordinate `{255} (encodeUCoordinate `{255, 32} x) == x\n\n\/**\n * Test vector derived from running the Python code\n * in Section 5 of [rfc7748].\n *\n * ```repl\n * :prove decodeUCoordinateTest\n * ```\n *\/\nproperty decodeUCoordinateTest = decodeUCoordinate `{6} \"hello world\" == x\n    where\n        x = 40\n\n\/**\n * Scalars are assumed to be randomly generated bytes.\n * For curve 25519, we need 32 bytes, and we mask\n * the final bit (i.e., assume that it is zero).\n *\n * Assume the array is already little endian.\n *\n * Reference:\n * [rfc7748] Section 5.\n *\/\ndecodeScalar25519 : [32][8] -> Z p\ndecodeScalar25519 k0 = decodeLittleEndian `{255} k3\n    where\n        k1 = update k0 0 ((k0@0) && 248)\n        k2 = update k1 31 ((k1@31) && 127)\n        k3 = update k2 31 ((k2@31) || 64)\n\n\/**\n * Test the scalar decode using a value derived from\n * the Python code in section 5.\n *\n * ```repl\n * :prove decodeScalarOk\n * ```\n *\n * Reference:\n * [rfc7748] Section 5.\n *\/\nproperty decodeScalarOk = decodeScalar25519 (repeat 0x61) == x\n    where\n        x = 44046402572626160612103472728795008085361523578694645928734845681441465000288\n\n\/**\n * The function `X25519(k, u)`, described in Section 5.\n * Assume that the input arrays are already little endian.\n *\n * Reference:\n * [rfc7748] Section 5.\n *\/\nX25519 : [32][8] -> [32][8] -> [32][8]\nX25519 kb ub = result\n    where\n                a24 = 121665\n        \/\/ decode the byte array `ub` as a `Z p` element.\n        \/\/ decode scalar `kb` as a 255-bit bitvector.\n        k = ZtoBV (decodeScalar25519 kb)\n        u = decodeUCoordinate `{255} ub\n                loop (x1, x2, z2, x3, z3, swap) t = (x1', x2', z2', x3', z3', swap')\n            where\n                k_t = (k >> t) && 1\n                swapt = swap ^ k_t\n                (x2s, x3s) = cswap' swapt (x2, x3)\n                (z2s, z3s) = cswap' swapt (z2, z3)\n                swap' = zext [k_t ! 0]\n\n                A = x2s + z2s\n                AA = A^^2\n                B = x2s - z2s\n                BB = B^^2\n                E = AA - BB\n                C = x3s + z3s\n                D = x3s - z3s\n                DA = D * A\n                CB = C * B\n                x1' = x1\n                x3' = (DA + CB) ^^ 2\n                z3' = x1 * (DA - CB) ^^ 2\n                x2' = AA * BB\n                z2' = E * (AA + a24 * E)\n\n                (x1l, x2l, z2l, x3l, z3l, swapl) = foldl loop (u, 1 : Z p, 0 : Z p, u, 1 : Z p, 0 : [255]) (reverse [0..255-1])\n\n                (x2ls, x3ls) = cswap' swapl (x2l, x3l)\n        (z2ls, z3ls) = cswap' swapl (z2l, z3l)\n\n                rzp = x2ls * (z2ls ^^ `(p - 2))\n\n        \/\/ result as byte array\n        result = encodeUCoordinate `{255, 32} rzp\n\n\/**\n * \"Conditional swap\".\n * This function must be constant time in a production implementation.\n * Cryptol cannot enforce this.\n *\/\ncswap : [255] -> (Z p, Z p) -> (Z p, Z p)\ncswap swap (x, y) = (BVtoZ `{p} (dummy ^ x_2), BVtoZ `{p} (dummy ^ x_3))\n    where\n        mask : [255] -> [255]\n        mask z = 0 - z\n\n        (x_2, x_3) = (ZtoBV x, ZtoBV y)\n        dummy = mask swap && (x_2 ^ x_3)\n\n\/**\n * Faster conditional swap that will definitely not\n * be constant time (branches on the bits of the scalar)\n * but faciliates slightly faster test execution.\n *\n * Performance can be improved further by using `Bit` instead `[255]`,\n * but the same constant time issue remains.\n *\/\ncswap' : [255] -> (Z p, Z p) -> (Z p, Z p)\ncswap' swap (x, y) = if swap == 0 then (x, y) else (y, x)\n\n\/**\n * The swap implementations are equivalent.\n * ```\n * :check cswapEq\n * ```\n *\/\ncswapEq s x = elem s [0, 1] ==> cswap s x == cswap' s x\n\n\/**\n * `cswap False` is the identity.\n *\n * ```repl\n * :check cswapFalse\n * ```\n *\/\nproperty cswapFalse x = cswap 0 x == x\n\n\/**\n * `cswap True` is an involution.\n *\n * ```repl\n * :check cswapTrue\n * ```\n *\/\nproperty cswapTrue y x = y > 0 ==> cswap y (cswap y x) == x\n\n\/**\n * Test vector from section 5.2.\n *\n * ```repl\n * :prove testVector1\n * ```\n *\n * Reference:\n * [rfc7748] Section 5.2.\n *\/\nproperty testVector1 = X25519 k u == u'\n    where\n        k = split 0xa546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4\n        u = split 0xe6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c\n        u' = split 0xc3da55379de9c6908e94ea4df28d084f32eccf03491c71f754b4075577a28552\n\n\/**\n * Test vector from Section 5.2.\n *\n * ```repl\n * :prove testVector2\n * ```\n *\n * Reference:\n * [rfc7748] Section 5.2.\n *\/\nproperty testVector2 = X25519 k u == u'\n    where\n        k = split 0x4b66e9d4d1b4673c5ad22691957d6af5c11b6421e0ea01d42ca4169e7918ba0d\n        u = split 0xe5210f12786811d3f4b7959d0538ae2c31dbe7106fc03c3efc4cd549c715a493\n        u' = split 0x95cbde9476e8907d7aade45cb4b873f88b595a68799fa152e6f8f7647aac7957\n\n\/**\n * Iterative testing.\n *\/\niterTest : {n} (fin n) => [32][8] -> [32][8] -> [32][8]\niterTest k u\n    | n == 0 => k\n    | n >= 1 => iterTest `{n-1} (X25519 k u) k\n\n\/**\n * An \"iterative\" test vector.\n *\n * ```repl\n * :prove mcTv1\n * ```\n *\/\nproperty mcTv1 = iterTest `{1} k u == r\n    where\n        k = split 0x0900000000000000000000000000000000000000000000000000000000000000\n        u = k\n        r = split 0x422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079\n\n\/**\n * An \"iterative\" test vector.\n *\n * ```repl\n * :prove mcTv2\n * ```\n *\/\nproperty mcTv2 = iterTest `{1000} k u == r\n    where\n        k = split 0x0900000000000000000000000000000000000000000000000000000000000000\n        u = k\n        r = split 0x684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51\n\n\/*\n * Cryptol is too slow to efficiently\n * execute the \"iterative\" test vector\n * for a million iterations.\n *\n * We include the test vector for\n * documentary purposes, and omit the\n * property keyword so it is not executed\n * by `check`, `prove`, etc...\n *\/\nmcTv3 = iterTest `{1000} k u == r\n    where\n        k = split 0x0900000000000000000000000000000000000000000000000000000000000000\n        u = k\n        r = split 0x7c3911e0ab2586fd864497297e575e6f3bc601c0883c30df5f4dd2d24f665424\n\/**\n * Cryptol uses a big-endian convention when\n * using intrinsics such as `toInteger`.\n * This version of X25519 assumes that the byte-arrays\n * are big-endian, and converts the arguments\n * to little endian.\n *\/\nX25519' k u = reverse (X25519 k' u')\n    where\n        k' = reverse k\n        u' = reverse u\n\n\/**\n * Check that the conversion is okay.\n *\n * ```repl\n * :check bigOk\n * ```\n *\/\nproperty bigOk k u = reverse (X25519 (reverse k) (reverse u)) == X25519' k u\n\n\/**\n * Generate the public key `X25519(a, 9)` where\n * `9` is the `u` coordinate of the base point\n * and `a` is the secret value.\n *\n * Reference:\n * [rfc7748] Section 6.1.\n *\n * ```repl\n * let a = split `{32} 0x77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a\n * let b = split `{32} 0x5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb\n * let Ga = split `{32} 0x8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a\n * let Gb = split `{32} 0xde9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f\n * let K = split `{32} 0x4a5d9d5ba4ce2de1728e3bf480350f25e07e21c947d19e3376f09b3c1e161742\n * :prove DH_sender a == Ga\n * :prove DH_sender b == Gb\n * :prove X25519 a Gb == K\n * :prove X25519 b Ga == K\n * ```\n *\/\nDH_sender : [32][8] -> [32][8]\nDH_sender a = X25519 a (reverse (split Gu'))\n    where\n        \/\/ must be little-endian.\n        \/\/ Cryptol `fromInteger` semantics will\n        \/\/ make a big-endian bitvector.\n        Gu' = (fromInteger `Gu) : [32 * 8]\n\n\/**\n * Generate the shared value `K` given the received value `Gr`\n * and the secret `a`.\n *\/\nDH_receiver : [32][8] -> [32][8] -> [32][8]\nDH_receiver a Gr = X25519 a Gr\n\n\n\/**\n * Diffie-Hellman produces a shared secret.\n *\n * ```repl\n * :check DHSharedSecret\n * ```\n *\/\nproperty DHSharedSecret a b = DH_receiver a Gb == DH_receiver b Ga\n    where\n        Ga = DH_sender a\n        Gb = DH_sender b\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/PFEC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties and verification scripts to formally prove the correctness and closure properties of elliptic curve point operations defined in the PFEC module. This includes verifying that addition, doubling, subtraction, and scalar multiplication preserve point validity on the curve, that the base point G has the correct order n, and that affine and projective addition implementations are equivalent. Also, specify and verify properties related to the curve coefficients validity and the behavior of special points like the point at infinity."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::PFEC where\n\nimport Common::utils(half, mul2, mul3, mul4, mul8, ZtoBV)\n\nparameter\n    \/**\n     * Field size `P`.\n     * P must be an odd prime power and is not divisible by 3.\n     * I don't think there's a way to enforce \"prime power\" in the type\n     * constraint, but for the NIST curves, every `P` itself is prime,\n     * so we use the simpler constraint `prime P`.\n     * [SP-800-186] Section 2.1.1.\n     *\/\n    type P : #\n    type constraint (fin P, prime P, P >= 5, P % 2 == 1, P % 3 != 0)\n\n    \/**\n     * Order of the base point `G = (Gx, Gy)`. This must be prime.\n     * [SP-800-186] Section 2.1.1.\n     *\/\n    type n' : #\n    type constraint (fin n', prime n', n' < P)\n\n    \/**\n     * Coefficients that define the curve.\n     * For a curve in short-Weierstrass form, the equation is\n     * `y^2 = x^3 + ax + b`.\n     * See the `curveCoefficientsAreValid` property.\n     * [SP-800-186] Section 2.1.1.\n     *\/\n    b : Z P\n\n    \/**\n     * Coordinates of the base point `G = (Gx, Gy)`.\n     *\/\n    Gx : Z P\n    Gy : Z P\n\n\/**\n * Order of the base point `G`.\n *\n * This makes the private functor parameter publicly available.\n *\/\ntype n = n'\n\n\/**\n * Modulus of the field over which the curve is defined.\n *\n * This is called `q` for the `ECInterface`, which is designed to support\n * curves that are not necessarily over prime order fields.\n *\/\ntype q = P\n\n\/**\n * Coefficient that defines the curve.\n * For a curve in short-Weierstrass form, the equation is\n * `y^2 = x^3 + ax + b`.\n * See the `curveCoefficientsAreValid` property.\n * [SP-800-186] Section 2.1.1.\n *\n * Due to restrictions on the underlying elliptic curve operations, the\n * a-coordinate must be -3. This is the case for all NIST-standardized\n * prime order fields in short-Weierstrass form.\n *\/\nprivate a = -3 : Z P\n\n\/**\n * Cofactor for the curve.\n *\n * The order of the curve is defined as `h * n`, where `h` is small\n * and `n`, the order of the base point `G`, is prime. If `h` is not\n * 1, then the base point does not generate the entire curve.\n *\n * This is fixed to 1 for all the NIST-standardized prime order fields\n * in short-Weierstrass form. It's not necessarily true for all reasonable\n * elliptic curves.\n *\/\nh = 1 : Integer\n\n\n\/**\n * A point that satisfies the curve equation `y^2 = x^3 + ax + b`.\n * Sometimes this is called an \"affine\" representation.\n * [SP-800-186] Section 2.1.1.\n *\/\nenum Point = Infinity | Affine (Z P) (Z P)\n\n\/**\n * Check equality of two affine points.\n *\n * I don't know if this is explicitly specified anywhere because it's just\n * by definition.\n *\/\naffineEq : Point -> Point -> Bool\naffineEq p1 p2 = case p1 of\n    Infinity -> case p2 of\n        Infinity -> True\n        _ -> False\n    Affine x y -> case p2 of\n        Affine x' y' -> (x == x') && (y == y')\n        _ -> False\n\n\/**\n * The EC interface uses `pointEq` to compare equality on two points, since it\n * isn't prescriptive about what its point type is, exactly.\n *\/\npointEq = affineEq\n\n\/**\n * Check that a given point is on the curve -- either it is the point at\n * infinity or it satisfies the curve equation.\n * [SP-800-186] Section 2.1.1.\n * [SEC1-v2] Section 2.2.1.\n * [MATH-2008] Routine 2.2.5.\n *\n * Note: by definition, the coordinates of an affine point will be correctly\n * formed (e.g. in the range [0, P-1]), because they are of type `Z P`.\n *\/\nisValid : Point -> Bit\nisValid point = case point of\n    Infinity -> True\n    Affine x y -> (y ^^ 2 == x ^^ 3 + a * x + b)\n\n\/**\n * Indicate whether a point is the point at infinity.\n *\/\nisInfinity : Point -> Bool\nisInfinity point = case point of\n    Infinity -> True\n    _ -> False\n\n\/**\n * Convenient `Point` representation of the base point `G`.\n *\/\nG = Affine Gx Gy : Point\n\n\/**\n * For curves in short-Weierstrass form, the following inequality must hold:\n *      4a^3 + 27b^2 != 0\n * [SP-800-186] Section 2.1.1.\n *\n * ```repl\n * :prove curveCoefficientsAreValid\n * ```\n *\/\nproperty curveCoefficientsAreValid = (4 * a^^3 + _27 * b^^2 != 0)\n    where\n        _27 : Z P\n        _27 = fromInteger 27\n\n\/**\n * G must be of order `n`.\n * ```repl\n * :prove gOrderIsN\n * ```\n *\/\nproperty gOrderIsN = affineEq G ((`n + 1) ~* G)\n\n\/**\n * `G` must be a valid point on the curve.\n * ```repl\n * :prove gIsValid\n * ```\n *\/\nproperty gIsValid = isValid G\n\n\/**\n * Add two elliptic curve points together.\n *\n * Assumption: The `Point`s passed as parameters must be valid EC points,\n * otherwise this operation makes no sense. Use `isValid` to make sure\n * the inputs are valid before calling this function.\n *\/\nadd : Point -> Point -> Point\nadd p1 p2 = to_affine (ec_full_add (to_projective p1) (to_projective p2))\n\n\/**\n * Addition is a closed operation: the sum of two valid elliptic curve\n * points is also on the curve.\n * ```repl\n * :check addIsClosed\n * ```\n *\/\nproperty addIsClosed k1 k2 = isValid (add p1 p2)\n    where\n        p1 = validPointFromK k1\n        p2 = validPointFromK k2\n\n\/**\n * Double an elliptic curve point.\n *\n * Assumption: The `Point` passed as a parameter must be a valid EC point,\n * otherwise this operation makes no sense. Use `isValid` to make sure\n * the input is valid before calling this function.\n *\/\ndouble : Point -> Point\ndouble p = to_affine (ec_double (to_projective p))\n\n\/**\n * Doubling is a closed operation: the double of a valid elliptic\n * curve point is also on the curve.\n * ```repl\n * :check doubleIsClosed\n * ```\n *\/\nproperty doubleIsClosed k = isValid (double p)\n    where\n        p = validPointFromK k\n\n\/**\n * Subtract one curve point from another.\n *\n * Assumption: The `Point`s passed as parameters must be valid EC points,\n * otherwise this operation makes no sense. Use `isValid` to make sure\n * the inputs are valid before calling this function.\n *\/\nsub : Point -> Point -> Point\nsub p1 p2 = to_affine (ec_full_sub (to_projective p1) (to_projective p2))\n\n\/**\n * Subtraction is a closed operation: the difference of two valid elliptic\n * curve points is also on the curve.\n * ```repl\n * :check subIsClosed\n * ```\n *\/\nproperty subIsClosed k1 k2 = isValid (sub p1 p2)\n    where\n        p1 = validPointFromK k1\n        p2 = validPointFromK k2\n\n\/**\n * Scalar multiplication of a curve point.\n\n * Scalar multiplication is the process of adding `P` to itself `k` times\n * for an integer `k`.\n *\n * [SEC1-v2] Section 2.2.1 doesn't explicitly specify an algorithm, but it\n * notes that it can be computed efficiently using the addition rule and a\n * variant of the double-and-add algorithm.\n * In this implementation, we use a variant from [MATH-2008] (see `ec_mult`).\n *\n * Assumption: The `Point` passed as a parameter must be a valid EC point,\n * otherwise this operation makes no sense. Use `isValid` to make sure\n * the input is valid before calling this function.\n *\/\nscmul : Integer -> Point -> Point\nscmul k p = to_affine (ec_mult (fromInteger k) (to_projective p))\n\n(~*) = scmul  \/\/ infix form of operator\n\n\/**\n * Scalar multiplication is a closed operation: the result must also be on the\n * curve.\n * ```repl\n * :check scmulIsClosed\n * ```\n *\/\nproperty scmulIsClosed m = isValid (m ~* G)\n\n\/**\n * Scalar multiplication is commutative.\n * ```repl\n * :check scmul_commutes\n * ```\n *\/\nproperty scmul_commutes m m' = affineEq (m ~* (m' ~* G)) (m' ~* (m ~* G))\n\n\/**\n * Compute twin multiplication.\n *\/\ntwin_mul : Integer -> Point -> Integer -> Point -> Point\ntwin_mul c P d Q = to_affine (ec_twin_mult c' P' d' Q')\n    where\n        [c', d'] = [fromInteger   x | x <- [c, d]]\n        [P', Q'] = [to_projective p | p <- [P, Q]]\n\n\/**\n * Extract the x-coordinate `Z P` value, if the point is not the point at\n * infinity.\n *\/\nxCoord: Point -> Option (Z P)\nxCoord p = case p of\n    Infinity -> None\n    Affine x _ -> Some x\n\n\nprivate\n    type ProjectivePoint = { x : Z P, y : Z P, z : Z P }\n    InfinityProjective = { x=1, y=1, z=0 }\n    Zero = { x=0, y=0, z=0 }\n\n    \/**\n     * Convert from an affine to a projective representation.\n     * [MATH-2008] Routine 2.2.1.\n     *\/\n    to_projective : Point -> ProjectivePoint\n    to_projective p = case p of\n        Infinity -> InfinityProjective\n        Affine x y -> { x=x, y=y, z=1 }\n\n    \/**\n     * Convert from a projective to an affine representation.\n     * [MATH-2008] Routine 2.2.2.\n     *\/\n    to_affine : ProjectivePoint -> Point\n    to_affine p =\n        \/\/ The point at infinity does not have an affine representation.\n        if p.z == 0 then Infinity\n        \/\/ Note the parentheses here.\n        \/\/ See Note [Limit scope of recip in where clauses].\n        else (Affine (lambda ^^2 * p.x) (lambda ^^3 * p.y)\n               where\n                 lambda = recip p.z)\n\n\n    \/\/ The twin affine function depends on the set of four points: two\n    \/\/ arbitrary points S and T, their sum SpT, and their difference SmT.\n    type TwinPoints = {\n        A: ProjectivePoint,\n        B: ProjectivePoint,\n        C: ProjectivePoint,\n        D: ProjectivePoint\n    }\n    \/**\n     * Optimized routine to affinify and projectify four points at once\n     * (or do nothing, if any of the points are the point at infinity).\n     *\n     * This optimization is designed for use in `ec_twin_mult` and should not\n     * be used in other settings without checking that its behavior is suitable.\n     * [MATH-2008] Section 2.2, Note 8.\n     *\/\n    twin_normalize: TwinPoints -> TwinPoints\n    twin_normalize { A=A, B=B, C=C, D=D } =\n        \/\/ We can't compute twin normalization on the point at infinity\n        \/\/ because it doesn't have an inverse. Instead, skip the normalization\n        \/\/ step (the algorithm will still work!)\n        if (A.z == 0) || (B.z == 0) || (C.z == 0) || (D.z == 0) then\n            { A=A, B=B, C=C, D=D }\n        else\n          \/\/ Note the parentheses here.\n          \/\/ See Note [Limit scope of recip in where clauses].\n          ({\n             A = normalize_from_inv A a_inv,\n             B = normalize_from_inv B b_inv,\n             C = normalize_from_inv C c_inv,\n             D = normalize_from_inv D d_inv\n           } where\n               ab = A.z * B.z\n               cd = C.z * D.z\n               abc = ab * C.z\n               abd = ab * D.z\n               acd = A.z * cd\n               bcd = B.z * cd\n               abcd = ab * cd\n               e = recip abcd\n               a_inv = e * bcd\n               b_inv = e * acd\n               c_inv = e * abd\n               d_inv = e * abc\n               normalize_from_inv p inv =\n                   to_projective (Affine (inv ^^2 * p.x) (inv ^^3 * p.y)))\n\n\n    \/**\n     * This checks that the normalization function doesn't break on normalized\n     * points. The actual, more interesting check would be to generate random\n     * projective points (in non-normal representation, e.g. where the z coord\n     * is not 1) on the curve and run those through `twin_normalize` but there\n     * is not an obvious efficient way to sample such points.\n     *\n     * ```repl\n     * :set tests=25\n     * :check normalizeWorksOnNormalPoints\n     * :prove normalizeWorksOnNormalPoints 0 0 0 0\n     * ```\n     *\/\n    property normalizeWorksOnNormalPoints k1 k2 k3 k4 = all_are_normal && all_match\n        where\n            p1 = to_projective (validPointFromK k1)\n            p2 = to_projective (validPointFromK k2)\n            p3 = to_projective (validPointFromK k3)\n            p4 = to_projective (validPointFromK k4)\n\n            input = {A=p1, B=p2, C=p3, D=p4}\n            out = twin_normalize input\n\n            \/\/ If any of the multipliers is 0, the resulting point\n            \/\/ will be the point at infinity.\n            \/\/ In this case, `twin_normalize` will do nothing...\n            any_are_infinity = any (\\k -> k == 0) [k1, k2, k3, k4]\n\n            \/\/ ...and the point at infinity always has a z-coordinate of 0.\n            \/\/ So, this check for \"normalcy\" is only relevant if we're not\n            \/\/ dealing with a point at infinity.\n            all_are_normal = any_are_infinity ||\n                all (\\p -> p.z == 1) [out.A, out.B, out.C, out.D]\n\n            \/\/ In either case, our `toProjective` function produces points in normal\n            \/\/ form, so `twin_normalize` shouldn't actually change the representation.\n            all_match = (out.A == p1) && (out.B == p2)\n                && (out.C == p3) && (out.D == p4)\n\n    \/**\n     * Double an elliptic curve point.\n     * [MATH-2008] Routine 2.2.6.\n     *\n     * Requires that curve parameter `a = -3 mod P`\n     *\/\n    ec_double : ProjectivePoint -> ProjectivePoint\n    ec_double S =\n      if S.z == 0 then InfinityProjective \/* 5: r <- (1,1,0) and return *\/\n      else {x = r18, y = r23, z = r13}\n      where\n          r7  = S.z ^^ 2                \/*  7: t4 <- (t3)^2 *\/\n          r8  = S.x - r7                \/*  8: t5 <- t1 - t4 *\/\n          r9  = S.x + r7                \/*  9: t4 <- t1 + t4 *\/\n          r10 = r9 * r8                 \/* 10: t5 <- t4 * t5 *\/\n          r11 = mul3 r10                \/* 11: t4 <- 3 * t5 *\/\n          r12 = S.z * S.y               \/* 12: t3 <- t3 * t2 *\/\n          r13 = mul2 r12                \/* 13: t3 <- 2 * t3 *\/\n          r14 = S.y ^^ 2                \/* 14: t2 <- (t2)^2 *\/\n          r15 = S.x * r14               \/* 15: t5 <- t1 * t2 *\/\n          r16 = mul4 r15                \/* 16: t5 <- 4 * t5 *\/\n          r17 = r11 ^^ 2                \/* 17: t1 <- (t4)^2 *\/\n          r18 = r17 - (mul2 r16)        \/* 18: t1 <- t1 - 2 * t5 *\/\n          r19 = r14 ^^ 2                \/* 19: t2 <- (t2)^2 *\/\n          r20 = mul8 r19                          r21 = r16 - r18                         r22 = r11 * r21                         r23 = r22 - r20                   \/**\n     * Addition of two elliptic curve points.\n     *\n     * This will fail in the case where either of the input points are the\n     * point at infinity or if the two input points are the same (if they\n     * are the same, will return a default value of (0,0,0)).\n     * [MATH-2008] Routine 2.2.7.\n     *\/\n    ec_add : ProjectivePoint -> ProjectivePoint -> ProjectivePoint\n    ec_add S T =\n        if r13 == 0 then\n            if r14 == 0 then Zero                   else InfinityProjective             else\n            {x = r32, y = r37, z = r27} \/* 38: Rx <- t1; Ry <- t2, Rz <- t3 *\/\n        where\n            (t1, t2, t3, t4, t5, t6) = if T.z == 1 then\n                \/\/ 1: set t6 = 1 to make L25 work\n                (S.x, S.y, S.z, T.x, T.y, T.z)\n                else (r5, r7, S.z, T.x, T.y, r3)\n\n            r3 = T.z                \/* 3: t6 <- T_z *\/\n            r4 = r3 ^^ 2            \/* 4: t7 <- t6^2 *\/\n            r5 = S.x * r4           \/* 5: t1 <- t1 * t7 *\/\n            r6 = r3 * r4            \/* 6: t7 <- t6 * t7 *\/\n            r7 = S.y * r6           \/* 7: t2 <- t2 * t7 *\/\n\n            r9  = t3 ^^ 2           \/*  9: t7 <- (t3)^2 *\/\n            r10 = t4 * r9           \/* 10: t4 <- t4 * t7 *\/\n            r11 = t3 * r9           \/* 11: t7 <- t3 * t7 *\/\n            r12 = t5 * r11                      r13 = t1 - r10                      r14 = t2 - r12                      r22 = mul2 t1 - r13                 r23 = mul2 t2 - r14                 r25 = t3 * t6           \/* 25: t3 <- t3 * t6 if Tz =\/= 1.\n                                       If T.z == 1, then t6 == 1 and this is a\n                                       no-op *\/\n\n            r27 = r25 * r13                      r28 = r13 ^^ 2                       r29 = r13 * r28          \/* 29: t4 <- t4 * t7 *\/\n            r30 = r22 * r28          \/* 30: t7 <- t1 * t7 *\/\n            r31 = r14 ^^ 2           \/* 31: t1 <- (t5)^2 *\/\n            r32 = r31 - r30          \/* 32: t1 <- t1 - t7 *\/\n            r33 = r30 - (mul2 r32)   \/* 33: t7 <- t7 - 2*t1 *\/\n            r34 = r14 * r33          \/* 34: t5 <- t5 * t7 *\/\n            r35 = r23 * r29          \/* 35: t4 <- t2 * t4 *\/\n            r36 = r34 - r35          \/* 36: t2 <- t5 - t4 *\/\n            r37 = half r36               \/**\n     * Checked addition of two elliptic curve points.\n     *\n     * This method handles the cases where either of the input points are the\n     * point at infinity or if the input points are the same.\n     * [MATH-2008] Routine 2.2.8.\n     *\/\n    ec_full_add : ProjectivePoint -> ProjectivePoint -> ProjectivePoint\n    ec_full_add S T =\n        if S.z == 0 then T\n        | T.z == 0 then S\n        | R == {x = 0, y = 0, z = 0} then ec_double S\n        else R\n        where R = ec_add S T\n\n    \/**\n     * Checked subtraction of two elliptic curve points.\n     *\n     * This method handles the cases where either of the input points are the\n     * point at infinity or if the input points are the same.\n     * [MATH-2008] Routine 2.2.8.\n     *\/\n    ec_full_sub : ProjectivePoint -> ProjectivePoint -> ProjectivePoint\n    ec_full_sub S T = R\n        where\n            U = {x = T.x, y = -T.y, z = T.z}\n            R = ec_full_add S U\n\n    \/**\n     * Scalar multiplication on projective points\n     * [MATH-2008] Routine 2.2.10.\n     *\n     * The routine requires that 0 <= d < P. We enforce this constraint by\n     * setting the type of `d` to be `Z P`, then converting it to an integer\n     * for all actual uses.\n     *\/\n    ec_mult : Z P -> ProjectivePoint -> ProjectivePoint\n    ec_mult d S =\n        if d == 0 then to_projective Infinity\n        | d == 1 then S\n        | S.z == 0 then to_projective Infinity\n        else Rs ! 1 \/* the iteration stops at 1, not 0 *\/\n        where\n            S' = if S.z != 1 then to_projective (to_affine S) else S\n            \/\/ Get bits of `d` and `3d`. The width of `ks` is set to be large\n            \/\/ enough to hold the full width of `hs`.\n            ks = ZtoBV d : [width P + 2]\n            hs = 3 * ks\n\n            \/\/ The specified routine initializes R = S and skips the first\n            \/\/ high-bit of `hs`, assuming that it's 1. Since we're a little\n            \/\/ floppy with our bitwise conversion, we'll start at 0 and\n            \/\/ iterate over all the bits.\n            Rs = [ InfinityProjective ] #\n                [ if hi && ~ki then ec_full_add doubleR S\n                  | ~hi && ki then ec_full_sub doubleR S\n                  else doubleR\n                  where doubleR = ec_double Ri\n                | ki <- ks | hi <- hs | Ri <- Rs ]\n\n    \/**\n     * Addition of two elliptic curve points on a prime-field curve with\n     * coefficient 'a'. Note 'b' is unused.\n     * [SP-800-186] Appendix A.1.1.\n     * [SEC1-v2] Section 2.2.1.\n     *\n     * This uses the less-efficient affine representation.\n     *\/\n    affine_add : Point -> Point -> Point\n    affine_add point1 point2 = case point1 of\n        Infinity -> point2\n        Affine x1 y1 -> case point2 of\n            Infinity -> point1\n            Affine x2 y2 -> if (x1 == x2) && (y1 == -y2) then Infinity\n                else Affine x y\n                where  \/\/ all arithmetic operations are mod p\n                    x = lambda ^^ 2 - x1 - x2\n                    y = lambda * (x1 - x) - y1\n                    lambda = if x1 == x2 then (3 * x1 ^^ 2 + a) %\/ (2 * y1)\n                        else (y2 - y1) %\/ (x2 - x1)\n\n\n    \/**\n     * Compute a valid curve point from a random `k` and the base point `G`.\n     *\n     * `k` is in the range [0, h * n), where `h * n` is the order of the\n     * elliptic curve.\n     * All the standardized NIST prime-order curves have (as the name suggests)\n     * prime order and cofactor 1.\n     *\n     * NB: If the cofactor `h` is not 1, this function will not derive points\n     * on the curve uniformly. When the cofactor is 1, that means the group is\n     * cyclic and can be generated by a single point. When it's not 1, the group\n     * has a large cyclic subgroup that is generated by `G`, but it's not the\n     * entire group.\n     *\n     * The scalar multiplication specification specifically allows\n     * multiplication by `k` in the range [0, P), hence the conversion.\n     *\/\n    validPointFromK : Z n' -> Point\n    validPointFromK k = to_affine (ec_mult _k (to_projective G))\n        where\n            _k : Z P\n            _k = fromInteger (fromZ k)\n\n    \/**\n     * Proof that the affine and projective versions of addition are equivalent.\n     * This doesn't test the point at infinity.\n     *\n     * ```repl\n     * :check addsAreEquivalent\n     * ```\n     *\/\n    addsAreEquivalent : Z n' -> Z n' -> Bool\n    property addsAreEquivalent k1 k2 =\n        affineEq (affine_add p1 p2) (to_affine full_sum)\n        where\n            p1 = validPointFromK k1\n            p2 = validPointFromK k2\n            full_sum = ec_full_add (to_projective p1) (to_projective p2)\n\n    \/**\n     * Proof that both addition properties work correctly for the point at infinity.\n     *\n     * ```repl\n     * :check addsBehaveCorrectlyAtInfinity\n     * ```\n     *\/\n    addsBehaveCorrectlyAtInfinity : Z n' -> Bool\n    property addsBehaveCorrectlyAtInfinity k =\n        oo && ok && ko && oo' && ok' && ko'\n        where\n            \/\/ Compute infinity identies in affine form.\n            point = validPointFromK k\n            oo = affineEq Infinity (affine_add Infinity Infinity)\n            ok = affineEq point (affine_add Infinity point)\n            ko = affineEq point (affine_add point Infinity)\n\n            \/\/ Compute infinity identies in projective form.\n            point' = to_projective point\n            oo' = InfinityProjective ==\n                ec_full_add InfinityProjective InfinityProjective\n            ok' = point' == ec_full_add InfinityProjective point'\n            ko' = point' == ec_full_add point' InfinityProjective\n\n\n    \/**\n     * Twin multiplication computes `[d0]S + [d1]T`.\n     * [MATH-2008] Routine 2.2.12.\n     *\n     * [MATH-2008] Section 2.2, Note 8 describes an optimization that can be\n     * made by converting the input points between affine and projective\n     * representations. That is not included here.\n     *\/\n    ec_twin_mult : Z P -> ProjectivePoint -> Z P -> ProjectivePoint -> ProjectivePoint\n    ec_twin_mult d0 S d1 T = (states!0).0\n        where\n            SpT = ec_full_add S T                                  SmT = ec_full_sub S T                                  \/\/ [MATH-2008] Section 2.2, Note 8 describes an optimization to\n            \/\/ speed up the arithmetic in L19-26 by normalizing (convert to\n            \/\/ affine and then back to projective) the points.\n            { A=S', B=T', C=SpT', D=SmT' } =\n                twin_normalize { A=S, B=T, C=SpT, D=SmT }\n            e0s = ZtoBV d0 : [max 4 (width P)]                     e1s = ZtoBV d1 : [max 4 (width P)]                     c   = [[False, False] # take e0s,                             [False, False] # take e1s] : [2][6]\n            states = [(InfinityProjective, c)] #                       [ (Rk', [c0', c1'])\n                    where\n                    \/\/ Lines 8-13.\n                    \/\/ `tail ci` uses Cryptol's built-in bit vector\n                    \/\/ representation to reconstruct `hi` as in L9.\n                    h0 = if c0@0 then 31 - tail c0 else tail c0\n                    h1 = if c1@0 then 31 - tail c1 else tail c1\n                                        u0 = if h0 < (F h1) then 0 else if c0@0 then -1 else 1 : [2]\n                    u1 = if h1 < (F h0) then 0 else if c1@0 then -1 else 1 : [2]\n                    \/\/ Line 17.\n                    \/\/ The absolute value on bits is computed as (u_i != 0).\n                    c0' = [(u0!=0) ^ c0@1] # drop c0 # [e0k]\n                    c1' = [(u1!=0) ^ c1@1] # drop c1 # [e1k]\n                                        RkDouble = ec_double Rk\n                                        Rk' = if (u0 == -1) && (u1 == -1) then\n                            ec_full_sub RkDouble SpT'\n                        | (u0 == -1) && (u1 ==  0) then ec_full_sub RkDouble S'\n                        | (u0 == -1) && (u1 ==  1) then\n                            ec_full_sub RkDouble SmT'\n                        | (u0 ==  0) && (u1 == -1) then ec_full_sub RkDouble T'\n                        | (u0 ==  0) && (u1 ==  1) then ec_full_add RkDouble T'\n                        | (u0 ==  1) && (u1 == -1) then\n                            ec_full_add RkDouble SmT'\n                        | (u0 ==  1) && (u1 ==  0) then ec_full_add RkDouble S'\n                        | (u0 ==  1) && (u1 ==  1) then\n                            ec_full_add RkDouble SpT'\n                        else RkDouble\n                | (Rk, [c0, c1]) <- states\n                \/\/ Line 7: Iterate through the eis, after dropping the four\n                \/\/ bits we already used to initialize `c` and padding with 0.\n                | e0k <- drop`{4} e0s # (zero : [5])\n                | e1k <- drop`{4} e1s # (zero : [5]) ]\n\n            \/\/ An auxiliary routine.\n            \/\/ [MATH-2008] Routine 2.2.11.\n            F : [5] -> [5]\n            F t = if (18 <= t) && (t < 22) then 9\n                | (14 <= t) && (t < 18) then 10\n                | (22 <= t) && (t < 24) then 11\n                | (4 <= t)  && (t < 12) then 14\n                else 12\n\n    \/**\n     * Checks that twin multiplication works as expected. Note that a given\n     * point can have multiple projective representations, so we have to\n     * check equality in the affine representation.\n     *\n     * These tests check the general case, the case where the two points `S`\n     * and `T` are the same, and the case where one of the points is the point\n     * at infinity.\n     * ```repl\n     * :check twin_mult_works\n     * :check (\\d0 d1 k -> twin_mult_works d0 k d1 k)\n     * :check (\\d0 d1 k -> twin_mult_works d0 k d1 0)\n     * :check (\\d0 d1 k -> twin_mult_works d0 0 d1 k)\n     * ```\n     *\/\n    property twin_mult_works d0 k0 d1 k1 = affineEq R_plain R_twin\n        where\n            S = to_projective (validPointFromK k0)\n            T = to_projective (validPointFromK k1)\n            R_plain = to_affine (ec_full_add (ec_mult d0 S) (ec_mult d1 T))\n            R_twin = to_affine (ec_twin_mult d0 S d1 T)\n\n    \/**\n    * Calulate x \/ y in a field.\n    * ```repl\n    * :prove  2 %\/ 2 == (1 : Z 3)\n    * ```\n    *\/\n    (%\/) : {a} (Field a) => a -> a -> a\n    (%\/) x y = x * recip y\n\n\/*\nNote [Limit scope of recip in where clauses]\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nThere are a small number of places where we call the `recip` function in a\nlocal definition bound by a `where` clause such that the definition is only ever\nused in the `else` branch of an if-expression. For example, in `to_affine` we\nhave:\n\n  to_affine p =\n      if p.z == 0 then Infinity\n      \/\/ Note the explicit parentheses here, which ensures that `lambda` is in\n      \/\/ scope in the `else` branch but *not* the `then` branch.\n      else (Affine (lambda ^^2 * p.x) (lambda ^^3 * p.y)\n             where\n               lambda = recip p.z)\n\nDoing so is not strictly necessary in Cryptol, as Cryptol's lazy evaluation\nwill only evaluate `lambda` if the `else` branch is evaluated. This is solely\ndone for the benefit of compiling to call-by-value languages (e.g., C or Rust),\nas evaluating `lambda` before the `if`-expression would result in a panic when\n`p.z == 0`.\n*\/\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Tests\/P256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the elliptic curve point operations (addition, subtraction, doubling, scalar multiplication, and twin multiplication) defined in the P256 module. Ensure that each property uses provided test vectors to prove that the implemented operations produce expected affine points and that the points involved are valid on the curve."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Tests::P256 where\nimport Common::EC::PrimeField::Instantiations::P256 as P256\nimport Common::utils(BVtoZ)\n\n\/\/ NB: We haven't implemented the point compression functions yet, but if we\n\/\/ do we can use these test vectors\n\/\/property p256_G_compress = P256::affineEq (P256::compress P256::G)\n\/\/    0x000000036b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\n\/\/property mp_mod_sqrt_256_correct = p256::mp_mod_sqrt_correct\n\nS = P256::Affine (BVtoZ 0xde2444bebc8d36e682edd27e0f271508617519b3221a8fa0b77cab3989da97c9)\n     (BVtoZ 0xc093ae7ff36e5380fc01a5aad1e66659702de80f53cec576b6350b243042a256)\n\nT = P256::Affine (BVtoZ 0x55a8b00f8da1d44e62f6b3b25316212e39540dc861c89575bb8cf92e35e0986b)\n     (BVtoZ 0x5421c3209c2d6c704835d82ac4c3dd90f61a8a52598b9e7ab656e9d8c8b24316)\n\n\/**\n * ```repl\n * :prove sAndTAreValid\n * ```\n *\/\nproperty sAndTAreValid = P256::isValid S && P256::isValid T\n\n\/**\n * ```repl\n * :prove additionVectorPasses\n * ```\n *\/\nproperty additionVectorPasses = P256::affineEq (P256::add S T) R\n  where R = P256::Affine (BVtoZ 0x72b13dd4354b6b81745195e98cc5ba6970349191ac476bd4553cf35a545a067e)\n             (BVtoZ 0x8d585cbb2e1327d75241a8a122d7620dc33b13315aa5c9d46d013011744ac264)\n\n\/**\n * ```repl\n * :prove subtractionVectorPasses\n * ```\n *\/\nproperty subtractionVectorPasses = P256::affineEq (P256::sub S T) R\n  where R = P256::Affine (BVtoZ 0xc09ce680b251bb1d2aad1dbf6129deab837419f8f1c73ea13e7dc64ad6be6021)\n             (BVtoZ 0x1a815bf700bd88336b2f9bad4edab1723414a022fdf6c3f4ce30675fb1975ef3)\n\n\/**\n * ```repl\n * :prove doubleVectorPasses\n * ```\n *\/\nproperty doubleVectorPasses = P256::affineEq (P256::double S) R\n  where R = P256::Affine (BVtoZ 0x7669e6901606ee3ba1a8eef1e0024c33df6c22f3b17481b82a860ffcdb6127b0)\n             (BVtoZ 0xfa878162187a54f6c39f6ee0072f33de389ef3eecd03023de10ca2c1db61d0c7)\n\n\/**\n * ```repl\n * :prove scalarMultVectorPasses\n * ```\n *\/\nproperty scalarMultVectorPasses = P256::affineEq (P256::scmul d S) R\n  where d = toInteger 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        R = P256::Affine (BVtoZ 0x51d08d5f2d4278882946d88d83c97d11e62becc3cfc18bedacc89ba34eeca03f)\n             (BVtoZ 0x75ee68eb8bf626aa5b673ab51f6e744e06f8fcf8a6c0cf3035beca956a7b41d5)\n\n\/**\n * ```repl\n * :prove twinMultVectorPasses\n * ```\n *\/\nproperty twinMultVectorPasses =\n  P256::affineEq R (P256::twin_mul d S e T)\n  where d = toInteger 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        e = toInteger 0xd37f628ece72a462f0145cbefe3f0b355ee8332d37acdd83a358016aea029db7\n        R = P256::Affine (BVtoZ 0xd867b4679221009234939221b8046245efcf58413daacbeff857b8588341f6b8)\n            (BVtoZ 0xf2504055c03cede12d22720dad69c745106b6607ec7e50dd35d54bd80f615275)\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Tests\/P192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the elliptic curve operations defined in the P192 module, including point validity, addition, subtraction, doubling, scalar multiplication, and twin multiplication, using the provided test vectors S, T, and expected results R."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Tests::P192 where\nimport Common::EC::PrimeField::Instantiations::P192 as P192\nimport Common::utils(BVtoZ)\n\n\/\/ NB: We haven't implemented the point compression functions yet, but if we\n\/\/ do we can use these test vectors\n\/*\nproperty p192_G_compress = P192::affineEq (P192::compress P192::G)\n    0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\nproperty mp_mod_sqrt_192_correct = p192::mp_mod_sqrt_correct\n\nproperty p192_decompress_S = p192::affine_decompress_correct S\nproperty p192_decompress_T = p192::affine_decompress_correct T\n*\/\n\nS = P192::Affine (BVtoZ 0xd458e7d127ae671b0c330266d246769353a012073e97acf8)\n     (BVtoZ 0x325930500d851f336bddc050cf7fb11b5673a1645086df3b)\n\nT = P192::Affine (BVtoZ 0xf22c4395213e9ebe67ddecdd87fdbd01be16fb059b9753a4)\n     (BVtoZ 0x264424096af2b3597796db48f8dfb41fa9cecc97691a9c79)\n\n\/**\n * ```repl\n * :prove sAndTAreValid\n * ```\n *\/\nproperty sAndTAreValid = P192::isValid S && P192::isValid T\n\n\/**\n * ```repl\n * :prove additionVectorPasses\n * ```\n *\/\nproperty additionVectorPasses = P192::affineEq (P192::add S T) R\n  where R = P192::Affine (BVtoZ 0x48e1e4096b9b8e5ca9d0f1f077b8abf58e843894de4d0290)\n             (BVtoZ 0x408fa77c797cd7dbfb16aa48a3648d3d63c94117d7b6aa4b)\n\n\/**\n * ```repl\n * :prove subtractionVectorPasses\n * ```\n *\/\nproperty subtractionVectorPasses = P192::affineEq (P192::sub S T) R\n  where R = P192::Affine (BVtoZ 0xfc9683cc5abfb4fe0cc8cc3bc9f61eabc4688f11e9f64a2e)\n             (BVtoZ 0x093e31d00fb78269732b1bd2a73c23cdd31745d0523d816b)\n\n\/**\n * ```repl\n * :prove doubleVectorPasses\n * ```\n *\/\nproperty doubleVectorPasses = P192::affineEq (P192::double S) R\n  where R = P192::Affine (BVtoZ 0x30c5bc6b8c7da25354b373dc14dd8a0eba42d25a3f6e6962)\n             (BVtoZ 0x0dde14bc4249a721c407aedbf011e2ddbbcb2968c9d889cf)\n\n\/**\n * ```repl\n * :prove scalarMultVectorPasses\n * ```\n *\/\nproperty scalarMultVectorPasses = P192::affineEq (P192::scmul d S) R\n  where d = toInteger 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        R = P192::Affine (BVtoZ 0x1faee4205a4f669d2d0a8f25e3bcec9a62a6952965bf6d31)\n             (BVtoZ 0x5ff2cdfa508a2581892367087c696f179e7a4d7e8260fb06)\n\n\/**\n * ```repl\n * :prove scalarMultVectorPasses2\n * ```\n *\/\nproperty scalarMultVectorPasses2 = P192::affineEq (P192::scmul d S') R\n    where\n        S' = P192::Affine (BVtoZ 0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012)\n            (BVtoZ 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811)\n        d = toInteger 0xe14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3\n        R = P192::Affine (BVtoZ 0x07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6)\n            (BVtoZ 0x76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477)\n\n\/**\n * ```repl\n * :prove twinMultVectorPasses\n * ```\n *\/\nproperty twinMultVectorPasses =\n  P192::affineEq R (P192::twin_mul d S e T)\n  where d = toInteger 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        e = toInteger 0xc4be3d53ec3089e71e4de8ceab7cce889bc393cd85b972bc\n        R = P192::Affine (BVtoZ 0x019f64eed8fa9b72b7dfea82c17c9bfa60ecb9e1778b5bde)\n            (BVtoZ 0x16590c5fcd8655fa4ced33fb800e2a7e3c61f35d83503644)\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Tests\/P224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of elliptic curve point operations (addition, subtraction, doubling, scalar multiplication, and twin multiplication) on the P224 prime field curve. Include properties that check the validity of points and use given test vectors to prove equivalence of computed results with expected affine points."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Tests::P224 where\nimport Common::EC::PrimeField::Instantiations::P224 as P224\nimport Common::utils(BVtoZ)\n\n\/\/ NB: We haven't implemented the point compression functions yet, but if we\n\/\/ do we can use these test vectors\n\/\/property p224_G_compress = P224::affineEq (P224::compress P224::G)\n\/\/    0x00000002b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\n\/\/property mp_mod_sqrt_224_correct = p224::mp_mod_sqrt_correct\n\n\nS = P224::Affine (BVtoZ 0x6eca814ba59a930843dc814edd6c97da95518df3c6fdf16e9a10bb5b)\n     (BVtoZ 0xef4b497f0963bc8b6aec0ca0f259b89cd80994147e05dc6b64d7bf22)\n\nT = P224::Affine (BVtoZ 0xb72b25aea5cb03fb88d7e842002969648e6ef23c5d39ac903826bd6d)\n     (BVtoZ 0xc42a8a4d34984f0b71b5b4091af7dceb33ea729c1a2dc8b434f10c34)\n\n\/**\n * ```repl\n * :prove sAndTAreValid\n * ```\n *\/\nproperty sAndTAreValid = P224::isValid S && P224::isValid T\n\n\/**\n * ```repl\n * :prove additionVectorPasses\n * ```\n *\/\nproperty additionVectorPasses = P224::affineEq (P224::add S T) R\n  where R = P224::Affine (BVtoZ 0x236f26d9e84c2f7d776b107bd478ee0a6d2bcfcaa2162afae8d2fd15)\n             (BVtoZ 0xe53cc0a7904ce6c3746f6a97471297a0b7d5cdf8d536ae25bb0fda70)\n\n\/**\n * ```repl\n * :prove subtractionVectorPasses\n * ```\n *\/\nproperty subtractionVectorPasses = P224::affineEq (P224::sub S T) R\n  where R = P224::Affine (BVtoZ 0xdb4112bcc8f34d4f0b36047bca1054f3615413852a7931335210b332)\n             (BVtoZ 0x90c6e8304da4813878c1540b2396f411facf787a520a0ffb55a8d961)\n\n\/**\n * ```repl\n * :prove doubleVectorPasses\n * ```\n *\/\nproperty doubleVectorPasses = P224::affineEq (P224::double S) R\n  where R = P224::Affine (BVtoZ 0xa9c96f2117dee0f27ca56850ebb46efad8ee26852f165e29cb5cdfc7)\n             (BVtoZ 0xadf18c84cf77ced4d76d4930417d9579207840bf49bfbf5837dfdd7d)\n\n\/**\n * ```repl\n * :prove scalarMultVectorPasses\n * ```\n *\/\nproperty scalarMultVectorPasses = P224::affineEq (P224::scmul d S) R\n  where d = toInteger 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        R = P224::Affine (BVtoZ 0x96a7625e92a8d72bff1113abdb95777e736a14c6fdaacc392702bca4)\n             (BVtoZ 0x0f8e5702942a3c5e13cd2fd5801915258b43dfadc70d15dbada3ed10)\n\n\/**\n * ```repl\n * :prove twinMultVectorPasses\n * ```\n *\/\nproperty twinMultVectorPasses =\n  P224::affineEq R (P224::twin_mul d S e T)\n  where d = toInteger 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        e = toInteger 0x54d549ffc08c96592519d73e71e8e0703fc8177fa88aa77a6ed35736\n        R = P224::Affine (BVtoZ 0xdbfe2958c7b2cda1302a67ea3ffd94c918c5b350ab838d52e288c83e)\n            (BVtoZ 0x2f521b83ac3b0549ff4895abcc7f0c5a861aacb87acbc5b8147bb18b)\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Instantiations\/P256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to specify and verify the correctness of the P256 prime field implementation in the given module. Include properties that check the field arithmetic operations (addition, multiplication, inversion) modulo the prime P, and verify that the base point coordinates Gx and Gy lie on the curve defined by the parameters."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Instantiations::P256 =\n       Common::EC::PrimeField::PFEC where\ntype P = 115792089210356248762697446949407573530086143415290314195533631308867097853951\ntype n' = 115792089210356248762697446949407573529996955224135760342422259061068512044369\nb  = `0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\nGx = `0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\nGy = `0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Instantiations\/P192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the NIST P-192 elliptic curve parameters and their properties as given in the module Common::EC::PrimeField::Instantiations::P192. Include specifications for the prime field modulus P, the curve order n', the curve parameter b, and the base point coordinates Gx and Gy. Additionally, write properties to verify that the base point lies on the curve defined by these parameters."},{"role":"assistant","content":"```cryptol\n\/*\n\nNIST P-192 Elliptic Curve defined in [FIPS-186-5].\n\nAlso standardized as \"secp192r1\" in [SEC2-v2] Section 2.2.2.\n\n\u26a0\ufe0f Warning \u26a0\ufe0f: This curve is deprecated and should not be used to proactively\nsecure new data! It should only be used to decrypt or verify previously\nencrypted data.\n\n@copyright Galois, Inc\n@author Max Orhai\n\n*\/\n\nmodule Common::EC::PrimeField::Instantiations::P192 =\n       Common::EC::PrimeField::PFEC where\ntype P = 6277101735386680763835789423207666416083908700390324961279\ntype n' =  6277101735386680763835789423176059013767194773182842284081\nb  = `0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1\nGx = `0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\nGy = `0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Instantiations\/P224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to specify and verify the correctness of the prime field arithmetic operations defined in the P224 instantiation module, including field addition, multiplication, and inversion modulo the prime P. Ensure the properties capture field axioms such as closure, associativity, distributivity, identity elements, and inverses. Also, include properties to verify that the base point coordinates Gx and Gy lie on the elliptic curve defined over this prime field."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Instantiations::P224 =\n       Common::EC::PrimeField::PFEC where\ntype P = 26959946667150639794667015087019630673557916260026308143510066298881\ntype n' = 26959946667150639794667015087019625940457807714424391721682722368061\nb  = `0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\nGx = `0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\nGy = `0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\n```"}]}
{"filename":"saw-script\/intTests\/test1533\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from \"test.bc\" and verifies the function \"get_x2\" with signature \"uint8_t get_x2(struct s *ss)\". Define a let-bound spec named get_x2_spec that allocates a symbolic struct s, creates a fresh symbolic 8-bit integer variable z, sets the field x2 of the struct to z, executes get_x2 with the struct pointer, and asserts the return value equals z. Use llvm_fresh_var and llvm_alloc for symbolic inputs and memory allocation, and llvm_points_to for field initialization. Include minimal preconditions for safe memory access and termination.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n\nstruct s {\n  uint8_t x1;\n  uint8_t x2;\n};\n\nuint8_t get_x2(struct s *ss) {\n  return ss->x2;\n}\n\nint main() {\n  return 0;\n}\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet get_x2_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 8);\n  llvm_points_to (llvm_field ss \"x2\") (llvm_term z);\n  llvm_execute_func [ss];\n  llvm_return (llvm_term z);\n};\n\nm <- llvm_load_module \"test.bc\";\n\nllvm_verify     m            \"get_x2\" [] false get_x2_spec (w4_unint_z3 []);\nllvm_verify_x86 m \"test.exe\" \"get_x2\" [] false get_x2_spec (w4_unint_z3 []);\n```"}]}
{"filename":"saw-script\/intTests\/test_property_as_rewrite_rule\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated Java class using java_load_class, then defines a let-bound specification named xor_involutes_spec that uses jvm_fresh_var to create symbolic byte variables x and y. The spec should invoke the exact method XorInvolutes with these symbolic inputs and assert that (x ^ y) ^ y equals x. Include any minimal preconditions necessary for safe execution. Finally, prove this specification using the appropriate jvm_prove function and add the proof to the simplification set with addsimp."},{"role":"assistant","content":"```saw\nimport \"test.cry\";\n\np1 <- prove_print z3 {{ \\(x: [8]) (y: [8]) -> (x ^ y) ^ y == x }};\nlet r1 = addsimp p1 empty_ss;\n\np2 <- prove_print z3 {{ XorInvolutes }};\nlet r2 = addsimp p2 empty_ss;\n\np3 <- prove_print z3 {{ \\x y -> XorInvolutes x y }};\nlet r3 = addsimp p3 empty_ss;\n```"}]}
{"filename":"saw-script\/intTests\/test2148\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'test.bc', defines a let-bound spec named 'foo_spec' for the function 'foo' with signature 'void foo(uint8_t xs[4])' using symbolic inputs created with llvm_fresh_var or llvm_fresh_expanded_val for the array argument, initializes memory accordingly, executes 'foo' with these symbolic inputs, and asserts the postcondition that the memory points to the symbolic value. Then define a let-bound spec 'bar_spec' for 'bar' with no arguments that executes 'bar'. Finally, verify 'bar' against 'bar_spec' assuming 'foo_spec' as an override, ensuring safety and termination preconditions as needed.\n\n# Source code:\ntest.c\n```C\n#include \"stdint.h\"\n#include \"stdbool.h\"\n\nvoid foo(uint8_t xs[4]);\n\nvoid bar() {\n    uint8_t xs[4] = {0,1,2,3};\n    for (int i = 0; i < 10; ++i) {\n        foo(xs);\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ A regression test that ensures that LLVM overrides will match successfully\n\/\/ when an argument is a string constant (#2148).\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet foo_spec1 = do {\n    (x, p_x) <- ptr_to_fresh \"xs\" (llvm_array 4 (llvm_int 8));\n\n    llvm_execute_func [p_x];\n\n    llvm_points_to p_x (llvm_term x);\n};\n\n\/\/ A slight variation of foo_spec1 that uses `llvm_fresh_expanded_val` instead\n\/\/ of `llvm_fresh_var`. This triggers a different code path in the LLVM override\n\/\/ matching logic.\nlet foo_spec2 = do {\n    let ty = llvm_array 4 (llvm_int 8);\n    x <- llvm_fresh_expanded_val ty;\n    p_x <- alloc_init ty x;\n\n    llvm_execute_func [p_x];\n\n    llvm_points_to p_x x;\n};\n\nlet bar_spec = do {\n    llvm_execute_func [];\n};\n\nm <- llvm_load_module \"test.bc\";\n\nfoo_ov1 <- llvm_unsafe_assume_spec m \"foo\" foo_spec1;\nllvm_verify m \"bar\" [foo_ov1] true bar_spec z3;\n\nfoo_ov2 <- llvm_unsafe_assume_spec m \"foo\" foo_spec2;\nllvm_verify m \"bar\" [foo_ov2] true bar_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_issue642\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from test.bc that verifies the functions foo and bar defined in test.c. Define let-bound specs foo_spec and bar_spec using llvm_verify. For foo_spec, allocate the global variable glob and a fresh 32-bit integer pointer x symbolically, execute foo with x, and return 0. For bar_spec, allocate glob, execute bar with no arguments, and return 1. Use llvm_alloc_global and llvm_fresh_var as needed. Ensure the specs use the exact function names foo and bar from the LLVM module and include minimal preconditions for safety. Do not inline the specs in the verification calls.\n\n# Source code:\ntest.c\n```C\n#include <stdlib.h>\n\nint glob;\n\nint foo (int *x) {\n\treturn (x == &glob);\n}\n\nint bar () {\n\treturn foo(&glob);\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ This test checks whether we can use an override with a pointer\n\/\/ argument that aliases a global. It is a regression test for\n\/\/ saw-script issue #642.\n\/\/ https:\/\/github.com\/GaloisInc\/saw-script\/issues\/642\n\nbc <- llvm_load_module \"test.bc\";\n\nlet i32 = llvm_int 32;\n\nfoo_ov <-\n  llvm_verify bc \"foo\" [] false\n    do {\n      llvm_alloc_global \"glob\";\n      x <- llvm_alloc i32;\n      llvm_execute_func [x];\n      llvm_return (llvm_term {{ 0 : [32] }});\n    }\n    z3;\n\nbar_ov1 <-\n  llvm_verify bc \"bar\" [] false\n    do {\n      llvm_alloc_global \"glob\";\n      llvm_execute_func [];\n      llvm_return (llvm_term {{ 1 : [32] }});\n    }\n    z3;\n\nfails (\n  llvm_verify bc \"bar\" [foo_ov] false\n    do {\n      llvm_alloc_global \"glob\";\n      llvm_execute_func [];\n      llvm_return (llvm_term {{ 0 : [32] }});\n    }\n    z3\n  );\n```"}]}
{"filename":"saw-script\/intTests\/test1132\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'test.bc' and defines a let-bound specification 'f_spec' for the function 'void f(uint8_t **x)'. The spec should allocate a symbolic pointer variable for 'x', execute 'f' with this pointer, and then verify that the memory pointed to by '*x' is allocated and contains the value 42. Use 'llvm_fresh_var' for symbolic inputs and include necessary preconditions for safe memory allocation and pointer dereferencing. Finally, invoke 'llvm_verify' with the module, function name 'f', no extra arguments, the spec 'f_spec', and an appropriate termination flag.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid f(uint8_t **x) {\n  *x = malloc(sizeof(uint8_t));\n  **x = 42;\n}\n\n```"},{"role":"assistant","content":"```saw\nbc <- llvm_load_module \"test.bc\";\n\nlet f_contract = do {\n  x <- llvm_alloc (llvm_pointer (llvm_int 8));\n  llvm_execute_func [x];\n  p <- llvm_alloc (llvm_int 8);\n  llvm_points_to x p;\n  llvm_points_to p (llvm_term {{ 42 : [8] }});\n};\n\nllvm_verify bc \"f\" [] false f_contract abc;\n```"}]}
{"filename":"saw-script\/intTests\/test0036_global\/test-appropriate-overrides.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM modules test-O1.bc and test-O2.bc, then defines let-bound specs f_spec, g_spec, and h_spec with appropriate symbolic inputs using llvm_fresh_var. Include minimal preconditions for safety. Use llvm_verify to verify functions f, g, and h in both modules, passing the corresponding specs and chaining dependencies as shown (e.g., h depends on f and g specs). Do not inline specs in llvm_verify calls; instead, bind them with let. Reference exact function names and signatures from the LLVM modules."},{"role":"assistant","content":"```saw\ninclude \"test-common.saw\";\n\nm_O1 <- llvm_load_module \"test-O1.bc\";\nm_O2 <- llvm_load_module \"test-O2.bc\";\n\nf_O1_spec <- llvm_verify m_O1 \"f\" []                     true (f_spec 0) abc;\ng_O1_spec <- llvm_verify m_O1 \"g\" []                     true (g_spec 1) abc;\nh_O1_spec <- llvm_verify m_O1 \"h\" [f_O1_spec, g_O1_spec] true (h_spec 0) abc;\n\nf_O2_spec <- llvm_verify m_O2 \"f\" []                     true (f_spec 0) abc;\ng_O2_spec <- llvm_verify m_O2 \"g\" []                     true (g_spec 1) abc;\nh_O2_spec <- llvm_verify m_O2 \"h\" [f_O2_spec, g_O2_spec] true (h_spec 0) abc;\n```"}]}
{"filename":"saw-script\/intTests\/test0036_global\/test-signed.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from test-signed.bc that verifies the function f with signature int f(int). Define a let-bound spec named f_spec that uses llvm_fresh_var to create a symbolic 32-bit integer input y, initializes the global variable x to its initial state, adds a precondition ensuring y is less than 2^31 - 1, executes the function f with y as argument, and asserts that the return value equals 1 + y. Do not include comments or Markdown in the SAWScript code.\n\n# Source code:\ntest-signed.c\n```C\nint x = 0;\n\nint f(int y) {\n  x = x + 1;\n  return x + y;\n}\n\nint g(int z) {\n  x = x + 2;\n  return x + z;\n}\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test-signed.bc\";\n\n\nlet init_global name = do {\n  llvm_alloc_global name;\n  llvm_points_to (llvm_global name)\n                 (llvm_global_initializer name);\n};\n\nf_spec <- llvm_verify m \"f\" [] true (do {\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    init_global \"x\";\n    llvm_precond {{ y < 2^^31 - 1 }};\n    llvm_execute_func [llvm_term y];\n    llvm_return (llvm_term {{ 1 + y : [32] }});\n}) abc;\n```"}]}
{"filename":"saw-script\/intTests\/test0036_global\/test-common.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that uses the LLVM backend by loading the LLVM module from saw-script\/intTests\/test0036_global\/test-common.saw. Define let-bound specs named f_spec, g_spec, and h_spec that each allocate and initialize the global variable \"x\" with a symbolic 32-bit integer input. For each spec, create a fresh 32-bit symbolic variable as the function argument, execute the corresponding LLVM function (f, g, h) with this argument, and specify the expected post-state of the global \"x\" and the return value as expressions involving the initial input and the fresh variable. Include minimal preconditions to ensure safety and termination, and do not inline the specs in function calls."},{"role":"assistant","content":"```saw\nlet init_global name val = do {\n  llvm_alloc_global name;\n  llvm_points_to (llvm_global name) val;\n};\n\nlet f_spec (x_pre : Int) = do {\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    init_global \"x\" (llvm_term {{ `(x_pre) : [32] }});\n    llvm_execute_func [llvm_term y];\n    let x_post = {{ `(x_pre) + 1 : [32] }};\n    llvm_points_to (llvm_global \"x\") (llvm_term x_post);\n    llvm_return (llvm_term {{ x_post + y : [32] }});\n};\n\nlet g_spec (x_pre : Int) = do {\n    z <- llvm_fresh_var \"z\" (llvm_int 32);\n    init_global \"x\" (llvm_term {{ `(x_pre) : [32] }});\n    llvm_execute_func [llvm_term z];\n    let x_post = {{ `(x_pre) + 2 : [32] }};\n    llvm_points_to (llvm_global \"x\") (llvm_term x_post);\n    llvm_return (llvm_term {{ x_post + z : [32] }});\n};\n\nlet h_spec (x_pre : Int) = do {\n    w <- llvm_fresh_var \"w\" (llvm_int 32);\n    init_global \"x\" (llvm_term {{ `(x_pre) : [32] }});\n    llvm_execute_func [llvm_term w];\n    let x_post = {{ `(x_pre) + 3 : [32] }};\n    llvm_points_to (llvm_global \"x\") (llvm_term x_post);\n    llvm_return (llvm_term {{ x_post + `(x_pre) + 1 + w : [32] }});\n};\n```"}]}
{"filename":"saw-script\/intTests\/test0036_global\/test-global-initializer.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM modules \"test-O1.bc\" and \"test-O2.bc\" and verifies the functions \"f\", \"g\", and \"h\". Define let-bound specs named f_spec, g_spec, and h_spec using llvm_fresh_var for symbolic 32-bit integer inputs. Initialize the global variable \"x\" appropriately using llvm_alloc_global and llvm_global_initializer or llvm_term. Execute each function with the symbolic input, assert the expected points-to values of the global \"x\", and specify the expected return values as llvm_term expressions. Use llvm_verify to verify each function against its spec, passing dependencies where needed (e.g., h depends on f and g). Ensure all symbol names and signatures match exactly those in the LLVM modules."},{"role":"assistant","content":"```saw\nlet init_global name val = do {\n  llvm_alloc_global name;\n  llvm_points_to (llvm_global name) val;\n};\n\nlet f_spec = do {\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    init_global \"x\" (llvm_global_initializer \"x\");\n    llvm_execute_func [llvm_term y];\n    llvm_points_to (llvm_global \"x\") (llvm_term {{ 1 : [32] }});\n    llvm_return (llvm_term {{ 1 + y : [32] }});\n};\n\nlet g_spec = do {\n    z <- llvm_fresh_var \"z\" (llvm_int 32);\n    init_global \"x\" (llvm_term {{ 1 : [32] }});\n    llvm_execute_func [llvm_term z];\n    llvm_points_to (llvm_global \"x\") (llvm_term {{ 3 : [32] }});\n    llvm_return (llvm_term {{ 3 + z : [32] }});\n};\n\nlet h_spec = do {\n    w <- llvm_fresh_var \"w\" (llvm_int 32);\n    init_global \"x\" (llvm_global_initializer \"x\");\n    llvm_execute_func [llvm_term w];\n    llvm_points_to (llvm_global \"x\") (llvm_term {{ 3 : [32] }});\n    llvm_return (llvm_term {{ 4 + w : [32] }});\n};\n\nm_O1 <- llvm_load_module \"test-O1.bc\";\nm_O2 <- llvm_load_module \"test-O2.bc\";\n\nf_O1_spec <- llvm_verify m_O1 \"f\" []                     true f_spec abc;\ng_O1_spec <- llvm_verify m_O1 \"g\" []                     true g_spec abc;\nh_O1_spec <- llvm_verify m_O1 \"h\" [f_O1_spec, g_O1_spec] true h_spec abc;\n\nf_O2_spec <- llvm_verify m_O2 \"f\" []                     true f_spec abc;\ng_O2_spec <- llvm_verify m_O2 \"g\" []                     true g_spec abc;\nh_O2_spec <- llvm_verify m_O2 \"h\" [f_O2_spec, g_O2_spec] true h_spec abc;\n```"}]}
{"filename":"saw-script\/intTests\/test1938\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"test.bc\" that verifies the function \"test\" with signature \"void test(int *x)\". Define a let-bound spec named test_spec that allocates a fresh symbolic 32-bit integer pointer input using llvm_fresh_var or llvm_alloc, ensures any minimal preconditions for safe memory access, and calls the function \"test\" with this symbolic input. Use llvm_verify to verify the function \"test\" against test_spec with appropriate arguments and a true precondition.\n\n# Source code:\ntest.c\n```C\nvoid test(int *x) {\n    *x = 2;\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ Test that the `abc` and `w4_abc_verilog` proof scripts will report invalid\n\/\/ goals that do not contain any variables. We test this both directly (with the\n\/\/ trivial `False` property) as well as via an LLVM verification involving a\n\/\/ proof goal that evaluates to `False`.\n\nfails (prove_print abc            {{ False }});\nfails (prove_print w4_abc_verilog {{ False }});\n\nm <- llvm_load_module \"test.bc\";\n\n\/\/ This will generate a failing proof goal about `x` being read-only.\nlet setup = do {\n  x <- llvm_alloc_readonly (llvm_int 32);\n  llvm_execute_func [x];\n};\n\nfails (llvm_verify m \"test\" [] true setup abc);\nfails (llvm_verify m \"test\" [] true setup w4_abc_verilog);\n```"}]}
{"filename":"saw-script\/intTests\/test0030_vectors\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module vectortest.bc and defines a let-bound spec named vector_ops_spec. In this spec, symbolically create inputs corresponding to the __m128i vector and vector2 pointers used in the functions _mm_xor_si128, _mm_clmulepi64_si128, _mm_slli_si128, _mm_srli_si128, and _mm_shuffle_epi32. Use llvm_fresh_var to create symbolic 128-bit vector inputs and ensure any pointer dereferences are safe by adding minimal preconditions. Then call these intrinsic functions with the symbolic inputs, mimicking the sequence of operations in main, and verify that the final vector matches the expected final_vector loaded from final_array. Reference exact LLVM symbol names for these intrinsics as defined in vectortest.bc. Do not inline the spec; bind it to vector_ops_spec before passing it to llvm_verify.\n\n# Source code:\nvectortest.c\n```C\n#include <emmintrin.h>\n#include <wmmintrin.h>\n#include <tmmintrin.h>\n#include <stdio.h>\n#include <stdint.h>\n\nvoid printBytes (unsigned char* byte_array, int bytes){\n  int i=0;\n  while (i < bytes)\n  {\n      printf(\"%02X\",(unsigned)byte_array[i]);\n      i++;\n      if(i%2 == 0) printf(\" \");\n      if(i%4== 0) printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n  __m128i vector;\n  __m128i final_vector;\n  __m128i* vector2 = malloc(128);\n  int32_t array[4] = {1442454,2242865,3676852,4486525};\n  int32_t final_array[4] = { 0xED16D184, 0x4CE73AC3, 0x3F672DCC, 0x00002837 };\n\n  vector = _mm_setr_epi32(1442454,2242865,3676852,4486525);\n  final_vector = _mm_loadu_si128( (__m128i*) &final_array );\n\n  \/\/printBytes((unsigned char *)&array, 16);\n  \/\/printBytes((unsigned char *)&vector, 16);\n\n  _mm_storeu_si128(vector2, vector);\n  vector = _mm_loadu_si128(vector2);\n  \/\/printBytes((unsigned char *)&vector, 16);\n\n  *vector2 = _mm_xor_si128 (vector, vector);\n  \/\/printBytes((unsigned char *)vector2, 16);\n\n  *vector2 = vector + vector + vector;\n  \/\/printBytes((unsigned char *)vector2, 16);\n\n  vector = _mm_clmulepi64_si128(vector, *vector2, 0x00);\n  vector = _mm_clmulepi64_si128(vector, *vector2, 0x01);\n  vector = _mm_clmulepi64_si128(vector, *vector2, 0x10);\n  vector = _mm_clmulepi64_si128(vector, *vector2, 0x11);\n  \n  int result = (vector[0] == final_vector[0]) && (vector[1] == final_vector[1]);\n\n  \/\/printBytes((unsigned char *)&vector, 16);\n  \/\/printBytes((unsigned char *)&final_vector, 16);\n\n  vector = _mm_slli_si128(vector, 2);\n  \/\/printBytes((unsigned char *)&vector, 16);\n\n  vector = _mm_srli_si128(vector, 2);\n  \/\/ printBytes((unsigned char *)&vector, 16);\n\n  vector = _mm_shuffle_epi32(vector, 78);\n  \/\/printBytes((unsigned char *)&vector, 16);\n\n  \/\/printBytes((unsigned char *)&vector, 16);\n\n  return !result;\n}\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"vectortest.bc\";\n\nlet setup = do {\n  llvm_execute_func [ llvm_term {{ zero:[32] }}, llvm_null ];\n  llvm_return (llvm_term {{ zero:[32] }});\n};\nllvm_verify m \"main\" [] false setup z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_union\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function 'inc' defined in 'test.c'. Load the LLVM module 'test.bc' using llvm_load_module. Define a let-bound spec 'inc_spec INC' that allocates a symbolic 'struct.st' pointer, sets its 'alg' field to the symbolic enum value INC, and depending on INC being INC_1 or INC_2, initializes symbolic 32-bit integer fields 'x' (and 'y' if INC_2) in the appropriate union member. Execute the 'inc' function with this state and verify that the fields are incremented by 1 accordingly. Use llvm_fresh_var for symbolic inputs and llvm_points_to for memory setup and postconditions. Ensure the spec returns 0 on success. Then verify 'inc' with llvm_verify for both INC_1 and INC_2 cases using the defined spec.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n\ntypedef enum { INC_1 , INC_2 } alg;\n\ntypedef struct {\n  uint32_t x;\n} inc_1_st;\n\ntypedef struct {\n  uint32_t x;\n  uint32_t y;\n} inc_2_st;\n\ntypedef struct {\n  alg alg;\n  union {\n    inc_1_st inc_1_st;\n    inc_2_st inc_2_st;\n  } inc_st;\n} st;\n\nuint32_t inc(st *st) {\n  switch (st->alg) {\n  case INC_1:\n    st->inc_st.inc_1_st.x += 1;\n    break;\n  case INC_2:\n    st->inc_st.inc_2_st.x += 1;\n    st->inc_st.inc_2_st.y += 1;\n    break;\n  default:\n    return 1\/0;\n  }\n  return 0;\n}\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nlet {{\nINC_1 = 0 : [32]\nINC_2 = 1 : [32]\n}};\n\n\n\/\/ The argument 'INC' specifies which 'alg' enum to test.\nlet inc_spec INC = do {\n\n  stp <- llvm_alloc (llvm_alias \"struct.st\");\n  llvm_points_to (llvm_field stp \"alg\") (llvm_term {{ INC }});\n\n  if eval_bool {{ INC == INC_1 }} then\n    do {\n      let p = llvm_cast_pointer (llvm_field stp \"inc_st\") (llvm_alias \"struct.inc_1_st\");\n\n      x0 <- llvm_fresh_var \"x0\" (llvm_int 32);\n      llvm_points_to (llvm_field p \"x\") (llvm_term x0);\n\n      llvm_execute_func [stp];\n\n      llvm_points_to (llvm_field p \"x\") (llvm_term {{ x0 + 1 }});\n    }\n  else if eval_bool {{ INC == INC_2 }} then\n    do {\n      let p = llvm_cast_pointer (llvm_field stp \"inc_st\") (llvm_alias \"struct.inc_2_st\");\n\n      x0 <- llvm_fresh_var \"x0\" (llvm_int 32);\n      y0 <- llvm_fresh_var \"y0\" (llvm_int 32);\n\n      llvm_points_to (llvm_field p \"x\") (llvm_term x0);\n      llvm_points_to (llvm_field p \"y\") (llvm_term y0);\n\n      llvm_execute_func [stp];\n\n      llvm_points_to (llvm_field p \"x\") (llvm_term {{ x0 + 1 }});\n      llvm_points_to (llvm_field p \"y\") (llvm_term {{ y0 + 1 }});\n    }\n  else return (); \/\/ Unknown INC value\n\n  llvm_return (llvm_term {{ 0 : [32] }});\n};\n\nprint \"Verifying 'inc_1' using 'llvm_verify':\";\nllvm_verify m \"inc\" [] true (inc_spec {{ INC_1 }}) abc;\nprint \"\";\n\nprint \"Verifying 'inc_2' using 'llvm_verify':\";\nllvm_verify m \"inc\" [] true (inc_spec {{ INC_2 }}) abc;\nprint \"\";\n```"}]}
{"filename":"saw-script\/intTests\/test_rewrite_int\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated C or Java source files using the appropriate backend (llvm_* if llvm_load_module appears, jvm_* if java_load_class appears). Define a let-bound specification named <name>_spec that uses symbolic inputs created with llvm_fresh_var or jvm_fresh_var corresponding to the exact function or method signatures found in the source files. Include minimal preconditions necessary for safety and termination, such as bounds on inputs for loops or division. Then invoke the verification tactic referencing the loaded symbols and the spec. Do not inline the spec directly in the verification call and do not include solver references or comments."},{"role":"assistant","content":"```saw\n\/\/ This test ensures that rewrite rules using `intEq` and `intModEq` will work.\n\nlet ss0 = add_cryptol_defs [\"ecEq\"] (cryptol_ss ());\n\nlet {{\n  squareInt : Integer -> Integer\n  squareInt x = x * x\n\n  squareZ5 : Z 5 -> Z 5\n  squareZ5 x = x * x\n}};\n\nlet prove_rule t =\n  do {\n    thm <- prove_print z3 (rewrite ss0 t);\n    print thm;\n    return thm;\n  };\n\nsquareInt_plus <-\n  prove_rule {{ \\x y -> squareInt (x + y) == squareInt x + squareInt y + 2 * x * y }};\n\nsquareInt_times <-\n  prove_rule {{ \\x y -> squareInt (x * y) == squareInt x * squareInt y }};\n\nsquareZ5_plus <-\n  prove_rule {{ \\x y -> squareZ5 (x + y) == squareZ5 x + squareZ5 y + 2 * x * y }};\n\nsquareZ5_times <-\n  prove_rule {{ \\x y -> squareZ5 (x * y) == squareZ5 x * squareZ5 y }};\n\nlet ss1 = addsimps [squareInt_plus, squareInt_times, squareZ5_plus, squareZ5_times] ss0;\nlet tac = do { simplify ss1; print_goal; w4_unint_z3 [\"squareInt\", \"squareZ5\"]; };\n\nprove_print tac\n  {{ \\x y z -> squareInt (x * y + z) == squareInt x * squareInt y + squareInt z + 2 * x * y * z }};\n\nprove_print tac\n  {{ \\x y z -> squareZ5 (x * y + z) == squareZ5 x * squareZ5 y + squareZ5 z + 2 * x * y * z }};\n```"}]}
{"filename":"saw-script\/intTests\/test_unfold_fix_once\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated LLVM module using llvm_load_module, then defines a let-bound specification named f_spec that uses llvm_fresh_var to create a symbolic 64-bit integer input x. The spec should call the function f with x as argument, include any minimal preconditions needed for termination or safety, and verify that the returned value is even (i.e., (f x) mod 2 == 0). Use llvm_verify to prove this property against the implementation of f in the LLVM module."},{"role":"assistant","content":"```saw\nlet {{\n  f : [64] -> [64]\n  f x = if x <$ 0 then 0 else 2 * (f (x + 1))\n}};\n\nprove_print\n  (do {\n    unfolding_fix_once [\"f\"];\n    w4_unint_z3 [\"f\"];\n  })\n  {{ \\x -> (f x) % 2 == 0 }};\n```"}]}
{"filename":"saw-script\/intTests\/test1999\/post-test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the function 'post_test::x' defined in the MIR module loaded from 'post-test.linked-mir.json'. Define a let-bound specification named 'x_spec' that uses 'mir_execute_func' with symbolic inputs if needed, and uses 'mir_ref_of' to create a reference to the constant 42 of 32 bits as the return value. Then invoke 'mir_verify' on the module, the function name, an empty argument list, 'false' for the termination flag, and the 'x_spec'. Ensure the spec uses symbolic values and minimal preconditions for safety and termination."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"post-test.linked-mir.json\";\n\n\/\/ Override for x using mir_ref_of in postcondition\nlet x_spec = do {\n  mir_execute_func [];\n\n  ref_42 <- mir_ref_of (mir_term {{ 42 : [32] }});\n  mir_return ref_42;\n};\n\nmir_verify m \"post_test::x\" [] false x_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test1999\/pre-test-override.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given source files and defines a let-bound specification for the function 'pre_test::x' using symbolic inputs with minimal preconditions ensuring safety. Then, override the function 'pre_test::x' with this specification. Next, define a separate let-bound specification for the function 'pre_test::is42' that executes the function and returns a boolean term. Finally, verify 'pre_test::is42' against the overridden specification of 'pre_test::x' using the appropriate LLVM verification commands. Use llvm_fresh_var for symbolic inputs and ensure all references use exact symbol names from the source."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"pre-test.linked-mir.json\";\nlet ty = mir_u32;\n\nlet x_override_spec = do {\n  val <- mir_fresh_var \"val\" ty;\n  ref <- mir_ref_of (mir_term val);\n\n  mir_precond {{ val == 42 }};\n  mir_execute_func [ref];\n  mir_return ref;\n};\n\nx_ov <- mir_unsafe_assume_spec m \"pre_test::x\" x_override_spec;\n\nlet is42_spec = do {\n  mir_execute_func [];\n  mir_return (mir_term {{ True }});\n};\n\nmir_verify m \"pre_test::is42\" [x_ov] false is42_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test1999\/pre-test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from pre-test.linked-mir.json, defines a let-bound specification named x_spec for the function pre_test::x with signature (u32*), uses mir_fresh_var to create a symbolic u32 input val, creates a reference to val, adds a precondition that val equals 42, executes the function with the reference argument, and returns the reference. Then verify the function pre_test::x against x_spec using mir_verify without passing any additional arguments or solvers."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"pre-test.linked-mir.json\";\nlet ty = mir_u32;\n\nlet x_spec = do {\n  val <- mir_fresh_var \"val\" ty;\n  ref <- mir_ref_of (mir_term val);\n\n  mir_precond {{ val == 42 }};\n  mir_execute_func [ref];\n  mir_return ref;\n};\n\nmir_verify m \"pre_test::x\" [] false x_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test1999\/pre-test-mut-override.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given path, defines a let-bound specification named 'x_override_spec' for the function 'pre_test_mut::x' with a 32-bit unsigned integer input variable constrained to 42, creates a mutable reference to this input, executes the function with this reference, asserts the reference points to the input value, and returns the reference. Then assume this spec for 'pre_test_mut::x'. Next, define a let-bound specification 'is42_spec' for 'pre_test_mut::is42' that executes the function with no arguments and returns true. Finally, verify 'pre_test_mut::is42' against 'is42_spec' using the assumed override spec for 'x'. Use symbolic inputs and minimal preconditions as described, and do not include comments or solver references in the SAWScript."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"pre-test-mut.linked-mir.json\";\nlet ty = mir_u32;\n\nlet x_override_spec = do {\n  val <- mir_fresh_var \"val\" ty;\n  ref <- mir_ref_of_mut (mir_term val);\n\n  mir_precond {{ val == 42 }};\n  mir_execute_func [ref];\n  mir_points_to ref (mir_term val);\n  mir_return ref;\n};\n\nx_ov <- mir_unsafe_assume_spec m \"pre_test_mut::x\" x_override_spec;\n\nlet is42_spec = do {\n  mir_execute_func [];\n  mir_return (mir_term {{ True }});\n};\n\nmir_verify m \"pre_test_mut::is42\" [x_ov] false is42_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test1999\/pre-test-mut.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from pre-test-mut.linked-mir.json. Define a let-bound spec named x_spec that uses mir_fresh_var to create a symbolic 32-bit unsigned integer input val, with a precondition that val equals 42. Create a mutable reference to val, execute the function pre_test_mut::x with this reference as argument, assert that the reference points to val after execution, and verify that the function returns the reference. Use mir_verify to verify the function pre_test_mut::x against x_spec without additional overrides or solver references."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"pre-test-mut.linked-mir.json\";\nlet ty = mir_u32;\n\nlet x_spec = do {\n  val <- mir_fresh_var \"val\" ty;\n  ref <- mir_ref_of_mut (mir_term val);\n\n  mir_precond {{ val == 42 }};\n  mir_execute_func [ref];\n  mir_points_to ref (mir_term val);\n  mir_return ref;\n};\n\nmir_verify m \"pre_test_mut::x\" [] false x_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test1999\/post-test-mut-override.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'post-test-mut.linked-mir.json'. Define a let-bound specification named 'get41_override_spec' that executes the function 'post_test_mut::get41' with no arguments, returns a mutable reference to the 32-bit integer 41. Define another let-bound specification 'is42_spec' that executes 'post_test_mut::is42' with no arguments and returns true. Use 'mir_unsafe_assume_spec' to override 'post_test_mut::get41' with 'get41_override_spec'. Finally, verify 'post_test_mut::is42' against 'is42_spec' using the override, without passing the solver explicitly. Use symbolic inputs and minimal preconditions as needed for safety."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"post-test-mut.linked-mir.json\";\n\nlet get41_override_spec = do {\n  mir_execute_func [];\n\n  ref_41 <- mir_ref_of_mut (mir_term {{ 41 : [32] }});\n  mir_return ref_41;\n};\n\nget41_ov <- mir_unsafe_assume_spec m \"post_test_mut::get41\" get41_override_spec;\n\nlet is42_spec = do {\n  mir_execute_func [];\n  mir_return (mir_term {{ True }});\n};\n\nmir_verify m \"post_test_mut::is42\" [get41_ov] false is42_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test1999\/post-test-mut.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'post-test-mut.linked-mir.json' using llvm_load_module. Define a let-bound specification named get41_spec that symbolically executes the function 'post_test_mut::get41' with no inputs, creates a mutable reference initialized to the 32-bit constant 41, and returns this reference. Use llvm_fresh_var for any symbolic inputs if needed, and include minimal preconditions for safety. Then verify the function against this specification using mir_verify with the Z3 solver."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"post-test-mut.linked-mir.json\";\n\nlet get41_spec = do {\n  mir_execute_func [];\n\n  ref_41 <- mir_ref_of_mut (mir_term {{ 41 : [32] }});\n  mir_return ref_41;\n};\n\nmir_verify m \"post_test_mut::get41\" [] false get41_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_verify_tuples\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given path and verifies the functions test::f, test::g, and test::h. Define let-bound specs named f_spec, g_spec, and h_spec respectively. Each spec should use llvm_fresh_var to create symbolic 32-bit unsigned integer inputs, allocate memory as needed, and set up preconditions for safe execution. Use llvm_execute_func to invoke the functions with appropriate arguments and specify expected outputs or memory states using llvm_return or llvm_points_to. Finally, call llvm_verify on each function with the corresponding spec. Do not include solver references or comments."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet f_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  y <- mir_fresh_var \"y\" mir_u32;\n  let s = mir_tuple_value [mir_term x, mir_term y];\n\n  mir_execute_func [s];\n\n  let s' = mir_tuple_value [mir_term {{ y + 1 }}, mir_term {{ x + 2 }}];\n  mir_return s';\n};\n\nlet g_spec = do {\n  s_ptr <- mir_alloc (mir_tuple [mir_u32, mir_u32]);\n  x <- mir_fresh_var \"x\" mir_u32;\n  y <- mir_fresh_var \"y\" mir_u32;\n  let s = mir_tuple_value [mir_term x, mir_term y];\n  mir_points_to s_ptr s;\n\n  mir_execute_func [s_ptr];\n\n  let s' = mir_tuple_value [mir_term {{ y + 1 }}, mir_term {{ x + 2 }}];\n  mir_return s';\n};\n\nlet h_spec = do {\n  s_ptr <- mir_alloc_mut (mir_tuple [mir_u32, mir_u32]);\n  x <- mir_fresh_var \"x\" mir_u32;\n  y <- mir_fresh_var \"y\" mir_u32;\n  let s = mir_tuple_value [mir_term x, mir_term y];\n  mir_points_to s_ptr s;\n\n  mir_execute_func [s_ptr];\n\n  let s' = mir_tuple_value [mir_term {{ y + 1 }}, mir_term {{ x + 2 }}];\n  mir_points_to s_ptr s';\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::f\" [] false f_spec z3;\nmir_verify m \"test::g\" [] false g_spec z3;\nmir_verify m \"test::h\" [] false h_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_refine\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from \"test.bc\" and defines a let-bound specification named f_spec. The spec should symbolically freshen an input variable x of 32-bit integer type, add preconditions that x is one of the values 2, 4, 8, or 16 (to ensure termination and safety), execute the function \"f\" from the module with x as argument, and assert a postcondition that the return value corresponds to the logarithm base 2 of x (i.e., the function returns 1 for 2, 2 for 4, 3 for 8, and 4 for 16, and 0 otherwise). Use llvm_fresh_var, llvm_precond, llvm_execute_func, llvm_return, and llvm_postcond accordingly. Do not inline the spec in the call but bind it with let. Reference the exact function \"f\" with signature unsigned int f(unsigned int).\n\n# Source code:\ntest.c\n```C\n\nunsigned int f(unsigned int i)\n{\n  switch( i ) {\n  case 2:\n    return 1;\n  case 4:\n    return 2;\n  case 8:\n    return 3;\n  case 16:\n    return 4;\n  default:\n    return 0;\n  };\n}\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet {{\n popcount : [32] -> [32]\n popcount x = sum [ zext [b] | b <- x ]\n}};\n\n\/\/ A parameterized spec where the input value is\n\/\/ given as a parameter.\nlet f_concrete_spec (x:Term) : LLVMSetup () =\n  do {\n    llvm_execute_func [ llvm_term x ];\n\n    r <- llvm_fresh_var \"r\" (llvm_int 32);\n    llvm_return (llvm_term r);\n    llvm_postcond {{ 2^^r == x }};\n  };\n\n\/\/ A \"unified\" spec, where the input is taken from the\n\/\/ call site argument.\nlet f_total_spec : LLVMSetup () =\n  do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_precond {{ x <= 16 }};\n    llvm_precond {{ popcount x == 1 }};\n\n    llvm_execute_func [ llvm_term x ];\n\n    r <- llvm_fresh_var \"r\" (llvm_int 32);\n    llvm_return (llvm_term r);\n    llvm_postcond {{ 2^^r == x }};\n  };\n\n\/\/ This spec is incorrect, and should be rejected\nlet f_bogus_spec : LLVMSetup () =\n  do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_precond {{ x <= 32 }};\n    llvm_precond {{ popcount x == 1 }};\n\n    llvm_execute_func [ llvm_term x ];\n\n    r <- llvm_fresh_var \"r\" (llvm_int 32);\n    llvm_return (llvm_term r);\n    llvm_postcond {{ 2^^r == x }};\n  };\n\nm <- llvm_load_module \"test.bc\";\n\nf_concrete_ovrs <-\n  for (eval_list {{ [1,2,4,8,16:[32]] }}) (\\i ->\n    do {\n      print (str_concat \"f lemma: \" (show (eval_int i)));\n      llvm_verify m \"f\" [] false (f_concrete_spec i) yices;\n    });\n\nllvm_refine_spec m \"f\" f_concrete_ovrs f_total_spec yices;\n\nfails (llvm_refine_spec m \"f\" f_concrete_ovrs f_bogus_spec yices);\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_alignment\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from \"test.bc\" and defines a let-bound spec named write_unaligned_spec. This spec should allocate a symbolic 16-byte array of i8, create symbolic variables for the array and a 64-bit integer x, and specify the expected memory state before and after calling the function write_unaligned with arguments (pointer to the array and x). Use llvm_fresh_var for symbolic inputs and llvm_alloc for memory allocation. Then verify the function write_unaligned against this spec using llvm_verify, referencing the exact function signature from test.c.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n\nvoid write (uint64_t *p, uint64_t x) {\n\t*p = x;\n}\n\nvoid write_unaligned (uint8_t *p, uint64_t x) {\n\twrite((uint64_t *)(p + 1), x);\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ This is a regression test for saw-script issue #635.\n\/\/ https:\/\/github.com\/GaloisInc\/saw-script\/issues\/635\n\nbc <- llvm_load_module \"test.bc\";\n\nlet i8 = llvm_int 8;\nlet i64 = llvm_int 64;\n\nwrite_ov <-\n  llvm_verify bc \"write\" [] false\n    do {\n      p <- llvm_alloc i64;\n      x <- llvm_fresh_var \"x\" i64;\n      llvm_execute_func [p, llvm_term x];\n      llvm_points_to p (llvm_term x);\n    }\n    z3;\n\nlet write_unaligned_spec =\n  do {\n    p <- llvm_alloc (llvm_array 16 i8);\n    b <- llvm_fresh_var \"b\" (llvm_array 16 i8);\n    x <- llvm_fresh_var \"x\" i64;\n    llvm_points_to p (llvm_term b);\n    llvm_execute_func [p, llvm_term x];\n    llvm_points_to p (llvm_term {{ take`{1} b # reverse (split x) # drop`{9} b }});\n  };\n\nfails (\n  llvm_verify bc \"write_unaligned\" [] false\n    write_unaligned_spec\n    z3\n  );\n\nfails (\n  llvm_verify bc \"write_unaligned\" [write_ov] false\n    write_unaligned_spec\n    z3\n  );\n```"}]}
{"filename":"saw-script\/intTests\/test1308\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from \"test.bc\" and verifies the function \"zip_with_add\" with signature void zip_with_add(uint64_t c[42], const uint64_t a[42], const uint64_t b[42]). Define a let-bound spec named zip_with_add_spec that allocates three arrays of length 42 of 64-bit integers as symbolic inputs using llvm_fresh_var, initializes readonly pointers to these arrays, executes the function with these pointers, and asserts that the output array c contains the element-wise sum of input arrays a and b. Use llvm_points_to to specify memory contents and ensure the verification uses the z3 solver backend.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n#include <stdlib.h>\n\nconst size_t LEN = 42;\n\nvoid zip_with_add(uint64_t c[LEN], const uint64_t a[LEN], const uint64_t b[LEN]) {\n  for (size_t i = 0; i < LEN; i++) {\n    c[i] = a[i] + b[i];\n  }\n}\n\n```"},{"role":"assistant","content":"```saw\nenable_lax_pointer_ordering;\n\nlet alloc_init_readonly ty v = do {\n  p <- llvm_alloc_readonly ty;\n  llvm_points_to p v;\n  return p;\n};\n\nlet ptr_to_fresh_readonly n ty = do {\n  x <- llvm_fresh_var n ty;\n  p <- alloc_init_readonly ty (llvm_term x);\n  return (x, p);\n};\n\nlet LEN = 42;\n\nlet zip_with_add_spec = do {\n  let array_ty = llvm_array LEN (llvm_int 64);\n  c_ptr <- llvm_alloc array_ty;\n  (a, a_ptr) <- ptr_to_fresh_readonly \"a\" array_ty;\n  (b, b_ptr) <- ptr_to_fresh_readonly \"b\" array_ty;\n\n  llvm_execute_func [c_ptr, a_ptr, b_ptr];\n\n  llvm_points_to c_ptr (llvm_term {{ zipWith`{LEN} (+) a b }});\n};\n\nmod <- llvm_load_module \"test.bc\";\nllvm_verify mod \"zip_with_add\" [] false zip_with_add_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_yosys_compositional\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given source files, then defines let-bound specifications for each target function using llvm_fresh_var for symbolic inputs. The specs should model the exact function signatures and behaviors as per the source, including minimal preconditions for safety. Use llvm_verify to verify each function against its spec, referencing the exact function names from the source. Chain proofs as necessary to compose verification results. Do not include comments or solver references."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet {{\n  cryfull :  {a : [1], b : [1], cin : [1]} -> {cout : [1], s : [1]}\n  cryfull inp = { cout = [cout], s = [s] }\n    where [cout, s] = zext inp.a + zext inp.b + zext inp.cin\n  \n  cryadd4 : {a : [4], b : [4]} -> {res : [4]}\n  cryadd4 inp = { res = inp.a + inp.b }\n  \n  cryfullnocarry :  {a : [1], b : [1], cin : [1]} -> {cout : [1], s : [1]}\n  cryfullnocarry inp = { cout = [cout], s = [s] }\n    where [cout, s] = zext inp.a + zext inp.b\n}};\n\nm <- yosys_import \"test.json\";\n\nfull_spec <- yosys_verify {{ m.full }} [] {{ cryfull }} [] w4;\nyosys_verify {{ m.add4 }} [] {{ cryadd4 }} [full_spec] w4;\nfull_nocarry_spec <- yosys_verify {{ m.full }} [{{\\(inp : {a : [1], b : [1], cin : [1]}) -> inp.cin == 0}}] {{ cryfullnocarry }} [] w4;\nyosys_verify {{ m.add4 }} [] {{ cryadd4 }} [full_nocarry_spec] w4;\n```"}]}
{"filename":"saw-script\/intTests\/test_ghost_branch_00\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'test.bc' compiled from 'test.c'. Define let-bound specs for the functions 'f' and 'g' matching their C signatures: 'unsigned f(unsigned i)' and 'unsigned g(unsigned i)'. Use llvm_fresh_var to create symbolic 32-bit integer inputs with appropriate preconditions reflecting the branch conditions in 'f' (i < 42 and i >= 42 && i < 512) and for 'g' (i < 512). Use llvm_execute_func to execute these functions symbolically, capture ghost state as needed, and specify postconditions such as the return value constraints. Finally, verify 'g' against its spec assuming the specs for 'f'. Do not include comments or solver references in the SAWScript.\n\n# Source code:\ntest.c\n```C\nextern unsigned x;\n\nunsigned f(unsigned i) {\n  if (i < 42) {\n    x = i;\n    return x;\n  }\n  x = 2 * i;\n  return x;\n}\n\nunsigned g(unsigned i) {\n  return f(i);\n}\n\n```"},{"role":"assistant","content":"```saw\nlet f_lt_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{ i < 42 }};\n  llvm_execute_func [llvm_term i];\n  llvm_ghost_value x i;\n  llvm_return (llvm_term i);\n};\n\nlet f_ge_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{ (i >= 42) && (i < 512) }};\n  llvm_execute_func [llvm_term i];\n  let ret = {{ 2 * i }};\n  llvm_ghost_value x ret;\n  llvm_return (llvm_term ret);\n};\n\nlet g_spec : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{i < 512}};\n  llvm_execute_func [llvm_term i];\n  ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n  llvm_return (llvm_term ret);\n  llvm_postcond {{ ret >= i }};\n};\n\nlet main : TopLevel () = do {\n  x <- declare_ghost_state \"x\";\n  m <- llvm_load_module \"test.bc\";\n  f_lt_ov <- llvm_unsafe_assume_spec m \"f\" (f_lt_spec x);\n  f_ge_ov <- llvm_unsafe_assume_spec m \"f\" (f_ge_spec x);\n  llvm_verify m \"g\" [f_lt_ov, f_ge_ov] false g_spec z3;\n  print \"done\";\n};\n```"}]}
{"filename":"saw-script\/intTests\/test0220\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"test.bc\" that verifies the function \"f\" defined in test.c. Define a let-bound spec named \"spec\" that allocates the global variable \"y\" of type 8-bit integer, initializes it symbolically, executes \"f\" with no arguments, and asserts a postcondition that the updated value of \"y\" is greater than zero. Use llvm_fresh_var for symbolic variables and llvm_points_to to model memory. Then invoke llvm_verify on the module, function \"f\", with the spec and no additional arguments.\n\n# Source code:\ntest.c\n```C\nunsigned char y;\n\nvoid f(void) {\n   y = 6;\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ Test an inexact postcondition.\n\nmod <- llvm_load_module \"test.bc\";\n\nlet spec = do {\n   llvm_alloc_global \"y\";\n   y <- llvm_fresh_var \"y\" (llvm_int 8); \n   llvm_points_to (llvm_global \"y\") (llvm_term y); \n   llvm_execute_func [];\n   y_new <- llvm_fresh_var \"y_new\" (llvm_int 8);\n   llvm_points_to (llvm_global \"y\") (llvm_term y_new);\n   llvm_postcond {{ y_new > 0 }};\n};\n\nllvm_verify mod \"f\" [] false spec abc;\n```"}]}
{"filename":"saw-script\/intTests\/test_profiling\/dotprod_struct.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"dotprod_struct.bc\" that verifies the functions \"dotprod_struct\" and \"dotprod_wrap\" against a specification. Define a let-bound spec named dotprod_spec that takes a symbolic 32-bit integer n, allocates two struct vec_t pointers with arrays of length n and size n, initializes them with fresh symbolic values, and calls the target function with these pointers. The spec should return the Cryptol dotprod function applied to the symbolic arrays. Use llvm_fresh_var and llvm_alloc to create symbolic inputs and memory, and include minimal preconditions to ensure safe array access. Then verify both functions using llvm_verify with the spec and the appropriate overrides.\n\n# Source code:\ndotprod_struct.c\n```C\n#include <stdint.h>\n#include <stdlib.h>\n#include <sys\/param.h>\n\ntypedef struct {\n    uint32_t *elts;\n    uint32_t size;\n} vec_t;\n\n\/\/ Computes the dot product of the smaller vector and the\n\/\/ equivalently-sized prefix of the larger vector. This is the normal\n\/\/ dot product if they're the same length.\nuint32_t dotprod_struct(vec_t *x, vec_t *y) {\n    uint32_t size = MIN(x->size, y->size);\n    uint32_t res = 0;\n    for(size_t i = 0; i < size; i++) {\n        res += x->elts[i] * y->elts[i];\n    }\n    return res;\n}\n\nuint32_t dotprod_wrap(vec_t *x, vec_t *y) {\n    return dotprod_struct(x, y);\n}\n\n```"},{"role":"assistant","content":"```saw\nimport \"dotprod.cry\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet dotprod_spec n = do {\n    let nt = llvm_term {{ `n : [32] }};\n    (xs, xsp) <- ptr_to_fresh \"xs\" (llvm_array n (llvm_int 32));\n    (ys, ysp) <- ptr_to_fresh \"ys\" (llvm_array n (llvm_int 32));\n    let xval = llvm_struct_value [ xsp, nt ];\n    let yval = llvm_struct_value [ ysp, nt ];\n    xp <- alloc_init (llvm_alias \"struct.vec_t\") xval;\n    yp <- alloc_init (llvm_alias \"struct.vec_t\") yval;\n    llvm_execute_func [xp, yp];\n    llvm_return (llvm_term {{ dotprod xs ys }});\n};\n\nm <- llvm_load_module \"dotprod_struct.bc\";\n\nenable_crucible_profiling \"prof\";\ndotprod_ov <- llvm_verify m \"dotprod_struct\" [] true (dotprod_spec 2) z3;\nllvm_verify m \"dotprod_wrap\" [dotprod_ov] true (dotprod_spec 2) z3;\ndisable_crucible_profiling;\n```"}]}
{"filename":"saw-script\/intTests\/test_bitfield_basic\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from test.bc that verifies the functions get_x2(struct s *), get_y(struct s *), set_x2(struct s *, uint8_t), set_x2_alt(struct s *, uint8_t), set_y(struct s *, bool), and set_y_alt(struct s *, bool). Define let-bound specs for each function using llvm_fresh_var for symbolic inputs and llvm_alloc for struct s pointers. Use llvm_points_to_bitfield to model bitfield accesses and llvm_execute_func to call the functions with symbolic arguments. Include minimal preconditions to ensure safe execution and termination. Verify each function against its spec using llvm_verify with appropriate arguments and assumptions as needed.\n\n# Source code:\ntest.c\n```C\n#include <stdbool.h>\n#include <stdint.h>\n\nstruct s {\n  int32_t w;\n  uint8_t x1:1;\n  uint8_t x2:2;\n  uint8_t y:1;\n  int32_t z;\n};\n\nuint8_t get_x2(struct s *ss) {\n  return ss->x2;\n}\n\nbool get_y(struct s *ss) {\n  return ss->y;\n}\n\nvoid set_x2(struct s *ss, uint8_t x2) {\n  ss->x2 = x2;\n}\n\nvoid set_y(struct s *ss, bool y) {\n  ss->y = y;\n}\n\nvoid set_x2_alt(struct s *ss, uint8_t x2) {\n  set_x2(ss, x2);\n}\n\nvoid set_y_alt(struct s *ss, bool y) {\n  set_y(ss, y);\n}\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\nenable_lax_loads_and_stores;\n\nlet get_x2_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 2);\n  llvm_points_to_bitfield ss \"x2\" (llvm_term z);\n  llvm_execute_func [ss];\n  llvm_return (llvm_term {{ zext z : [8] }});\n};\n\nlet get_y_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 1);\n  llvm_points_to_bitfield ss \"y\" (llvm_term z);\n  llvm_execute_func [ss];\n  llvm_return (llvm_term z);\n};\n\nlet set_x2_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 8);\n  llvm_execute_func [ss, llvm_term z];\n  llvm_points_to_bitfield ss \"x2\" (llvm_term {{ drop z : [2] }});\n};\n\nlet set_x2_alt_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 2);\n  llvm_execute_func [ss, llvm_term {{ zext z : [8] }}];\n  llvm_points_to_bitfield ss \"x2\" (llvm_term z);\n};\n\nlet set_y_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 1);\n  llvm_execute_func [ss, llvm_term z];\n  llvm_points_to_bitfield ss \"y\" (llvm_term z);\n};\n\nlet set_y_alt_spec = set_y_spec;\n\nm <- llvm_load_module \"test.bc\";\n\nllvm_verify m \"get_x2\" [] false get_x2_spec (w4_unint_z3 []);\nllvm_verify m \"get_y\" [] false get_y_spec (w4_unint_z3 []);\nllvm_verify m \"set_x2\" [] false set_x2_spec (w4_unint_z3 []);\nllvm_verify m \"set_x2_alt\" [] false set_x2_alt_spec (w4_unint_z3 []);\nllvm_verify m \"set_y\" [] false set_y_spec (w4_unint_z3 []);\nllvm_verify m \"set_y_alt\" [] false set_y_alt_spec (w4_unint_z3 []);\n\nset_x2_ov <- llvm_unsafe_assume_spec m \"set_x2\" set_x2_spec;\nllvm_verify m \"set_x2_alt\" [set_x2_ov] false set_x2_alt_spec (w4_unint_z3 []);\nset_y_ov <- llvm_unsafe_assume_spec m \"set_y\" set_y_spec;\nllvm_verify m \"set_y_alt\" [set_y_ov] false set_y_alt_spec (w4_unint_z3 []);\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_verify_structs\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the MIR module loaded from \"test.linked-mir.json\" that defines specs for the functions test::f1, test::f2, test::f3, test::f4, test::g, test::h, and test::bar. For each function, create a let-bound spec (e.g., let f1_spec = do { ... };) using mir_fresh_var to generate symbolic inputs and mir_struct_value or mir_array_value to construct arguments matching the exact ADT types found in the module (e.g., test::S1, test::S2, test::S3, test::S4, test::Foo, core::option::Option). Use mir_execute_func to invoke the function with these symbolic inputs and mir_return or mir_points_to to specify expected outputs or mutated state. Include minimal preconditions for safety. Then verify each function against its spec using mir_verify with the Z3 solver. Also include negative tests that verify mismatched specs fail as expected."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet s1_adt = mir_find_adt m \"test::S1\" [];\nlet s2_adt = mir_find_adt m \"test::S2\" [mir_u32, mir_u32];\nlet s3_adt = mir_find_adt m \"test::S3\" [];\nlet s4_adt = mir_find_adt m \"test::S4\" [];\n\nlet foo_adt_1 = mir_find_adt m \"test::Foo\" [mir_array 4 mir_u8];\nlet foo_adt_2 = mir_find_adt m \"test::Foo\" [mir_adt s2_adt];\n\nlet option_adt = mir_find_adt m \"core::option::Option\" [mir_adt s2_adt];\n\nlet f_spec adt = do {\n    x1 <- mir_fresh_var \"x1\" mir_u32;\n    y1 <- mir_fresh_var \"y1\" mir_u32;\n    let s = mir_struct_value\n              adt\n              [ mir_term x1\n              , mir_term y1\n              ];\n\n    mir_execute_func [s];\n\n    let s' = mir_struct_value\n              adt\n              [ mir_term {{ y1 + 1 }}\n              , mir_term {{ x1 + 2 }}\n              ];\n    mir_return s';\n};\n\n\nlet f1_spec = f_spec s1_adt;\nlet f2_spec = f_spec s2_adt;\nlet f3_spec = f_spec s3_adt;\n\nlet f4_spec = do {\n    x4 <- mir_fresh_var \"x4\" mir_u32;\n    let s = mir_struct_value s4_adt [mir_term x4];\n\n    mir_execute_func [s];\n\n    let s' = mir_struct_value s4_adt [mir_term {{ x4 + 2 }}];\n    mir_return s';\n};\n\nlet g_spec = do {\n    s_ptr <- mir_alloc (mir_adt s1_adt);\n    x1 <- mir_fresh_var \"x1\" mir_u32;\n    y1 <- mir_fresh_var \"y1\" mir_u32;\n    let s = mir_struct_value\n              s1_adt\n              [ mir_term x1\n              , mir_term y1\n              ];\n    mir_points_to s_ptr s;\n\n    mir_execute_func [s_ptr];\n\n    let s' = mir_struct_value\n              s1_adt\n              [ mir_term {{ y1 + 1 }}\n              , mir_term {{ x1 + 2 }}\n              ];\n    mir_return s';\n};\n\nlet h_spec = do {\n    s_ptr <- mir_alloc_mut (mir_adt s1_adt);\n    x1 <- mir_fresh_var \"x1\" mir_u32;\n    y1 <- mir_fresh_var \"y1\" mir_u32;\n    let s = mir_struct_value\n              s1_adt\n              [ mir_term x1\n              , mir_term y1\n              ];\n    mir_points_to s_ptr s;\n\n    mir_execute_func [s_ptr];\n\n    let s' = mir_struct_value\n              s1_adt\n              [ mir_term {{ y1 + 1 }}\n              , mir_term {{ x1 + 2 }}\n              ];\n    mir_points_to s_ptr s';\n};\n\nlet bar_spec = do {\n    f1_ptr <- mir_alloc_mut (mir_adt foo_adt_1);\n    f1_arr_val0 <- mir_fresh_var \"f1_arr_val0\" mir_u8;\n    f1_arr_val1 <- mir_fresh_var \"f1_arr_val1\" mir_u8;\n    f1_arr_val2 <- mir_fresh_var \"f1_arr_val2\" mir_u8;\n    f1_arr_val3 <- mir_fresh_var \"f1_arr_val3\" mir_u8;\n    let f1_arr_val = mir_array_value\n                       mir_u8\n                       [ mir_term f1_arr_val0\n                       , mir_term f1_arr_val1\n                       , mir_term f1_arr_val2\n                       , mir_term f1_arr_val3\n                       ];\n    let f1_foo_val = mir_struct_value foo_adt_1 [f1_arr_val];\n    mir_points_to f1_ptr f1_foo_val;\n\n    f2_ptr <- mir_alloc_mut (mir_adt foo_adt_2);\n    f2_s2_val0 <- mir_fresh_var \"f2_s2_val0\" mir_u32;\n    f2_s2_val1 <- mir_fresh_var \"f2_s2_val1\" mir_u32;\n    let f2_s2_val = mir_struct_value\n                      s2_adt\n                      [ mir_term f2_s2_val0\n                      , mir_term f2_s2_val1\n                      ];\n    let f2_foo_val = mir_struct_value foo_adt_2 [f2_s2_val];\n    mir_points_to f2_ptr f2_foo_val;\n\n    mir_execute_func [f1_ptr, f2_ptr];\n\n    let f1_arr_val' = mir_array_value\n                        mir_u8\n                        [ mir_term f1_arr_val0\n                        , mir_term {{ 42 : [8] }}\n                        , mir_term f1_arr_val2\n                        , mir_term f1_arr_val3\n                        ];\n    let f1_foo_val' = mir_struct_value foo_adt_1 [f1_arr_val'];\n    mir_points_to f1_ptr f1_foo_val';\n\n    let f2_s2_val' = mir_struct_value\n                       s2_adt\n                       [ mir_term f2_s2_val1\n                       , mir_term f2_s2_val1\n                       ];\n    let f2_foo_val' = mir_struct_value foo_adt_2 [f2_s2_val'];\n    mir_points_to f2_ptr f2_foo_val';\n\n    mir_return f2_ptr;\n};\n\nmir_verify m \"test::f1\" [] false f1_spec z3;\nmir_verify m \"test::f2\" [] false f2_spec z3;\nmir_verify m \"test::f3\" [] false f3_spec z3;\nmir_verify m \"test::f4\" [] false f4_spec z3;\nmir_verify m \"test::g\" [] false g_spec z3;\nmir_verify m \"test::h\" [] false h_spec z3;\n\nfails (\n  mir_verify m \"test::f1\" [] false f2_spec z3\n);\nfails (\n  mir_verify m \"test::f2\" [] false f1_spec z3\n);\n\nmir_verify m \"test::bar\" [] false bar_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test0046_memcpy\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from test.bc and defines let-bound specs for verifying the functions f, g, and h from test.c. For each spec, use llvm_fresh_var to create a symbolic pointer argument of type pointer to an array of 4 bytes (llvm_array 4 (llvm_int 8)) and add minimal preconditions ensuring the pointer is valid for writing. Use llvm_execute_func to call the target function with the symbolic argument. Then use llvm_verify to check the correctness of each function against its spec, reflecting the expected success or failure behavior shown in the SAW excerpt.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n#include <string.h>\n\nvoid f(uint8_t *x) {\n  uint8_t y[8];\n  memcpy(x, y, 0);\n};\n\nvoid g(uint8_t *x) {\n  uint8_t y[8];\n  memcpy(x, y, 1);\n};\n\nvoid h(uint8_t *x) {\n  uint8_t y[8];\n  x[0] = y[0];\n};\n\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nlet f_setup = do {\n  xp <- llvm_alloc_readonly (llvm_array 4 (llvm_int 8));\n  llvm_execute_func [xp];\n  };\n\n\/\/ should fail because destination is not mutable,\n\/\/ even though the memcpy is 0 length\nfails (llvm_verify m \"f\" [] false f_setup z3);\n\nlet g_setup = do {\n  xp <- llvm_alloc (llvm_array 4 (llvm_int 8));\n  llvm_execute_func [xp];\n  };\n\n\/\/ should succeed because memcpy is allowed to copy uninitilized bytes\nllvm_verify m \"g\" [] false g_setup z3;\n\n\/\/ fails because direct reading of uninitialized bytes is not allowed\nfails (llvm_verify m \"h\" [] false g_setup z3);\n```"}]}
{"filename":"saw-script\/intTests\/test1998_jvm\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class 'Test' and verifies the static method 'f' with signature '(int,int)boolean'. Define a let-bound spec named 'f_spec' that creates two symbolic integer inputs using 'jvm_fresh_var', adds the minimal precondition that these inputs are equal, executes the method 'f' with these inputs, and returns true. Use 'jvm_execute_func' to call the method and 'jvm_return' to specify the expected result. Do not inline the spec in the verify call; bind it with 'let'.\n\n# Source code:\nTest.java\n```java\nclass Test {\n    static boolean f(int x, int y) {\n        return x == y;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nlet f_spec = do {\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_equal (jvm_term x) (jvm_term y);\n\n    jvm_execute_func [jvm_term x, jvm_term y];\n\n    jvm_return (jvm_term {{ True }});\n};\n\nc <- java_load_class \"Test\";\njvm_verify c \"f\" [] false f_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_x86_01\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module bar.bc that defines a let-bound spec named foo_spec for the function foo with signature void foo(uint64_t *i, uint64_t j). Use llvm_fresh_var to create symbolic 64-bit integer inputs for the pointer argument and the integer argument, set up memory with llvm_points_to for the pointer, and execute foo with these symbolic inputs. Then define a let-bound spec bar_spec for the function bar with no inputs, and verify bar against the module using llvm_verify, passing foo_spec as a prerequisite. Include minimal preconditions to ensure memory safety and termination, and do not include solver references or comments.\n\n# Source code:\nbar.c\n```C\n#include <stdint.h>\n#include <stdio.h>\n\nextern void foo(uint64_t *i, uint64_t j);\n\nvoid bar() {\n\tuint64_t i = 42;\n\tfoo(&i, 1337);\n\tputs(\"bar\");\n\tprintf(\"%lu\\n\", i);\n};\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- llvm_load_module \"bar.bc\";\n\nlet foo_setup = do {\n  ptr <- llvm_alloc (llvm_int 64);\n  val <- llvm_fresh_var \"val\" (llvm_int 64);\n  llvm_points_to ptr (llvm_term val);\n  j <- llvm_fresh_var \"j\" (llvm_int 64);\n  llvm_execute_func [ptr, llvm_term j];\n  val <- llvm_fresh_var \"val'\" (llvm_int 64);\n  llvm_points_to ptr (llvm_term val);\n};\nfoo_method_spec <- llvm_verify_x86 m \".\/foo\" \"foo\" [] false foo_setup w4;\n\nlet bar_setup = do {\n  llvm_execute_func [];\n};\nllvm_verify m \"bar\" [foo_method_spec] false bar_setup z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_x86_06\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"test.bc\" that verifies the function \"discoverytest\" with signature void discoverytest(). Define a let-bound spec named discoverytest_spec that uses llvm_fresh_var to create any necessary symbolic inputs (if applicable) and includes minimal preconditions to ensure safety and termination. The spec should call the \"discoverytest\" function symbolically. Use llvm_verify_x86 to verify the function against discoverytest_spec, and include any required setup similar to discoverytest_setup shown in the excerpt. Do not inline the spec in the verification call.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n#include <stdio.h>\n\nextern void discoverytest();\n\nvoid test() {\n\tdiscoverytest();\n};\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet discoverytest_setup = do {\n  llvm_execute_func [];\n};\n\nfails (llvm_verify_x86 m \".\/discoverytest\" \"discoverytest\" [] false discoverytest_setup w4);\n\nadd_x86_preserved_reg \"rax\";\nllvm_verify_x86 m \".\/discoverytest\" \"discoverytest\" [] false discoverytest_setup w4;\ndefault_x86_preserved_reg;\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_sizeof\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM modules from test1.bc and test2.bc, then defines a let-bound specification named dummy_spec that verifies the function dummy(foo*, bar*) from test1.bc and dummy(baz*) from test2.bc. Use llvm_fresh_var to create symbolic pointer inputs for the function parameters, and include any minimal preconditions necessary for safety. The spec should call the dummy functions symbolically and verify their behavior accordingly.\n\n# Source code:\ntest1.c\n```C\n#include <stdint.h>\n\ntypedef struct {\n    uint32_t x;\n    uint8_t y;\n} foo;\n\ntypedef struct {\n    uint8_t a;\n    foo b[10];\n} bar;\n\nvoid dummy (foo *x, bar *y) {\n    return;\n}\n\n```\ntest2.c\n```C\n#include <stdint.h>\n\ntypedef struct {\n    uint8_t x;\n    uint32_t y;\n} baz;\n\nvoid dummy (baz *x) {\n    return;\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ This test checks that the `llvm_sizeof` function works as expected.\n\nbc1 <- llvm_load_module \"test1.bc\";\nbc2 <- llvm_load_module \"test2.bc\";\n\nlet s1 = llvm_sizeof bc1 (llvm_int 8);\nlet s2 = llvm_sizeof bc1 (llvm_int 16);\nlet s3 = llvm_sizeof bc1 (llvm_int 32);\nlet s4 = llvm_sizeof bc1 (llvm_int 64);\nlet s5 = llvm_sizeof bc1 (llvm_alias \"struct.foo\");\nlet s6 = llvm_sizeof bc1 (llvm_alias \"struct.bar\");\nlet s7 = llvm_sizeof bc1 (llvm_array 2 (llvm_alias \"struct.foo\"));\nlet s8 = llvm_sizeof bc2 (llvm_alias \"struct.baz\");\nlet s9 = llvm_sizeof bc2 (llvm_array 8 (llvm_alias \"struct.baz\"));\nlet s0 = llvm_sizeof bc2 (llvm_type \"void*\");\n\n\/\/ This is a workaround to delay evaluation of a pure function\n\/\/ so that `fails` can catch any errors raised.\nlet apply f x = do { () <- return (); return (f x); };\n\nfails (apply (llvm_sizeof bc1) (llvm_type \"void\"));\nfails (apply (llvm_sizeof bc1) (llvm_alias \"baz\"));\nfails (apply (llvm_sizeof bc2) (llvm_alias \"foo\"));\n\nprove_print z3 {{\n  `s1 == (1 : Integer) \/\\\n  `s2 == (2 : Integer) \/\\\n  `s3 == (4 : Integer) \/\\\n  `s4 == (8 : Integer) \/\\\n  `s5 == (8 : Integer) \/\\\n  `s6 == (84 : Integer) \/\\\n  `s7 == (16 : Integer) \/\\\n  `s8 == (8  : Integer) \/\\\n  `s9 == (64 : Integer) \/\\\n  `s0 == (8  : Integer)\n  }};\n```"}]}
{"filename":"saw-script\/intTests\/test2032\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Rust MIR module loaded from test.linked-mir.json that verifies the functions test::rev_i32 and test::rev_rev_i32. Define let-bound specs named rev_i32_spec and rev_rev_i32_spec that use symbolic inputs for the vector length and contents. Use mir_fresh_var to create symbolic arrays of mir_i32 elements and construct Vec<i32> values using the provided mk_vec_i32 helper. Execute the target functions with mir_execute_func and assert that rev_i32 reverses the input vector and rev_rev_i32 returns the original vector after two reversals. Include necessary preconditions on vector length and capacity to ensure safety. Do not inline specs in calls; bind them with let. Reference exact function names as test::rev_i32 and test::rev_rev_i32. Use the LLVM backend as indicated by mir_load_module."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\n\/\/ We now have the mir_vec_of command for creating Vec values, which is tested\n\/\/ below, but we first test that we are able to construct a Vec using the\n\/\/ mir_alloc_raw_ptr_const_multi and mir_points_to_multi primitives in the same\n\/\/ way that mir_vec_of does internally. If this works but mir_vec_of fails then\n\/\/ we can isolate where the problem is coming from.\n\nlet GlobalAlloc = mir_find_adt m \"alloc::alloc::Global\" [];\nlet Vec_i32 = mir_find_adt m \"alloc::vec::Vec\" [mir_i32, mir_adt GlobalAlloc];\nlet RawVec_i32 = mir_find_adt m \"alloc::raw_vec::RawVec\" [mir_i32, mir_adt GlobalAlloc];\nlet TypedAllocator_i32 = mir_find_adt m \"crucible::alloc::TypedAllocator\" [mir_i32];\nlet RawVecInner_i32 = mir_find_adt m \"alloc::raw_vec::RawVecInner\" [mir_adt TypedAllocator_i32];\nlet Unique_u8 = mir_find_adt m \"core::ptr::unique::Unique\" [mir_u8];\nlet NonNull_u8 = mir_find_adt m \"core::ptr::non_null::NonNull\" [mir_u8];\nlet PhantomData = mir_find_adt m \"core::marker::PhantomData\";\nlet PhantomData_u8 = PhantomData [mir_u8];\nlet PhantomData_i32 = PhantomData [mir_i32]; \nlet UsizeNoHighBit = mir_find_adt m \"core::num::niche_types::UsizeNoHighBit\" [];\n\nlet mk_vec_i32 len contents = do {\n    ptr <- mir_alloc_raw_ptr_const_multi len mir_i32;\n    cap <- mir_fresh_var \"cap\" mir_usize;\n    mir_assert {{ cap <= 0x7fff_ffff_ffff_ffff \/ (32 \/ 8) }};\n    mir_assert {{ cap >= `len }};\n    mir_points_to_multi ptr contents;\n    return (mir_struct_value Vec_i32 [\n        mir_struct_value RawVec_i32 [\n            mir_struct_value RawVecInner_i32 [\n                mir_struct_value Unique_u8 [\n                    mir_struct_value NonNull_u8 [\n                        mir_cast_raw_ptr ptr mir_u8\n                    ],\n                    mir_struct_value PhantomData_u8 []\n                ],\n                mir_struct_value UsizeNoHighBit [\n                    mir_term cap\n                ],\n                mir_struct_value TypedAllocator_i32 [\n                    mir_struct_value PhantomData_i32 []\n                ]\n            ],\n            mir_struct_value GlobalAlloc [],\n            mir_struct_value PhantomData_i32 []\n        ],\n        mir_term {{ `len : [64] }}\n    ]);\n};\n\nlet rev_i32_spec_manual len = do {\n    contents <- mir_fresh_var \"contents\" (mir_array len mir_i32);\n    in_vec <- mk_vec_i32 len (mir_term contents);\n    mir_execute_func [in_vec];\n    out_vec <- mk_vec_i32 len (mir_term {{ reverse contents }});\n    mir_return out_vec;\n};\n\nrev_i32_ov_manual <- mir_verify m \"test::rev_i32\" [] false (rev_i32_spec_manual 10) z3;\n\nlet rev_rev_i32_spec_manual len = do {\n    contents <- mir_fresh_var \"contents\" (mir_array len mir_i32);\n    in_vec <- mk_vec_i32 len (mir_term contents);\n    mir_execute_func [in_vec];\n    out_vec <- mk_vec_i32 len (mir_term contents);\n    mir_return out_vec;\n};\n\nmir_verify m \"test::rev_rev_i32\" [rev_i32_ov_manual] false (rev_rev_i32_spec_manual 10) z3;\n\n\/\/ Test mir_vec_of.\n\nlet rev_spec_auto ty len = do {\n    contents <- mir_fresh_var \"contents\" (mir_array len ty);\n    in_vec <- mir_vec_of \"in_vec\" ty (mir_term contents);\n    mir_execute_func [in_vec];\n    out_vec <- mir_vec_of \"out_vec\" ty (mir_term {{ reverse contents }});\n    mir_return out_vec;\n};\n\nlet rev_rev_spec_auto ty len = do {\n    contents <- mir_fresh_var \"contents\" (mir_array len ty);\n    in_vec <- mir_vec_of \"in_vec\" ty (mir_term contents);\n    mir_execute_func [in_vec];\n    out_vec <- mir_vec_of \"out_vec\" ty (mir_term contents);\n    mir_return out_vec;\n};\n\nrev_i32_ov_auto <- mir_verify m \"test::rev_i32\" [] false (rev_spec_auto mir_i32 10) z3;\nmir_verify m \"test::rev_rev_i32\" [rev_i32_ov_auto] false (rev_rev_spec_auto mir_i32 10) z3;\n\nrev_tuple_ov_auto <- mir_verify m \"test::rev_tuple\" [] false (rev_spec_auto (mir_tuple [mir_u8, mir_i64, mir_u128]) 10) z3;\nmir_verify m \"test::rev_rev_tuple\" [rev_tuple_ov_auto] false (rev_rev_spec_auto (mir_tuple [mir_u8, mir_i64, mir_u128]) 10) z3;\n\n\/\/ Uncomment this when Vec of ZST is supported in crucible (blocked by at least\n\/\/ crucible#1497 and #1504).\n\n\/\/ Test that empty Vecs work.\n\n\/*\nThis test is disabled for now while we work on improving the Vec API in #2666.\n\nlet empty_spec = do {\n    mir_execute_func [];\n    out_vec <- mir_vec_of \"out_vec\" mir_i32 (mir_array_value mir_i32 []);\n    mir_return out_vec;\n};\n\nempty_ov <- mir_verify m \"test::empty\" [] false empty_spec z3;\n\nlet empty_len_spec = do {\n    mir_execute_func [];\n    mir_return (mir_term {{ 0 : [64] }});\n};\n\nmir_verify m \"test::empty_len\" [empty_ov] false empty_len_spec z3;\n*\/\n```"}]}
{"filename":"saw-script\/intTests\/test0044_invariant_4\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the LLVM backend that loads the module from 'test.bc'. Define a let-bound specification named 'inv_spec' that allocates and initializes symbolic variables corresponding to the parameters of the function '__breakpoint__inv' with signature 'uint8_t**', 'size_t*', and 'size_t*'. Add a precondition that the symbolic index variable 'i' satisfies 0 <= i <= len, where len is 100. Define another let-bound specification 'array_inc_spec' that allocates a symbolic array of 100 bytes and a symbolic length variable, then executes the 'array_inc' function with these arguments. Use 'llvm_execute_func' to call the functions with the appropriate pointers and symbolic variables. Finally, create an unsafe assume spec for '__breakpoint__inv#array_inc' using 'inv_spec' and verify both '__breakpoint__inv#array_inc' and 'array_inc' against their respective specs.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n#include <stdlib.h>\n\nextern void __breakpoint__inv(uint8_t**, size_t*, size_t*) __attribute__((noduplicate));\n\nvoid array_inc(uint8_t a[], size_t n) {\n  for (size_t i = 0; __breakpoint__inv(&a, &n, &i), i < n; ++i) {\n    ++a[i];\n  }\n}\n\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nlet ptr_to_fresh n ty = do {\n  p <- llvm_alloc ty;\n  x <- llvm_fresh_var n ty;\n  llvm_points_to p (llvm_term x);\n  return (p, x);\n};\n\nlet len = 100;\n\nlet array_inc_spec = do {\n  (pa, a) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 8));\n  let n = llvm_term {{ `len : [64] }};\n  llvm_execute_func [pa, n];\n};\n\nlet inv_spec = do {\n  (pa, a) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 8));\n  ppa <- llvm_alloc (llvm_int 64);\n  llvm_points_to ppa pa;\n  let n = llvm_term {{ `len : [64] }};\n  pn <- llvm_alloc (llvm_int 64);\n  llvm_points_to pn n;\n  (pi, i) <- ptr_to_fresh \"i\" (llvm_int 64);\n  llvm_precond {{ 0 <= i \/\\ i <= `len }};\n  llvm_execute_func [ppa, pn, pi];\n};\n\ninv <- llvm_unsafe_assume_spec m \"__breakpoint__inv#array_inc\" inv_spec;\nllvm_verify m \"__breakpoint__inv#array_inc\" [inv] false inv_spec abc;\nllvm_verify m \"array_inc\" [inv] false array_inc_spec abc;\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_x86_08\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function 'test' defined in 'test.bc' and sourced from 'test.c'. Define a let-bound specification named 'test_spec' that uses 'llvm_fresh_var' to create symbolic 64-bit integer inputs for all eight unsigned long parameters (a,b,c,d,e,f,g,h). The spec should execute the 'test' function with these symbolic inputs, then assert that the return value equals the symbolic variable for 'g' minus the symbolic variable for 'h'. Include any minimal preconditions necessary for safe execution. Use 'llvm_execute_func' and 'llvm_return' accordingly, and verify the function with 'llvm_verify_x86'.\n\n# Source code:\ntest.c\n```C\nunsigned long test(unsigned long a, unsigned long b, unsigned long c, unsigned long d,unsigned long e, unsigned long f, unsigned long g, unsigned long h) {\n  return g - h;\n}\n\nint main() {\n  return 0;\n}\n\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\n\/\/ Test a function with more than 6 arguments to ensure that the remaining\n\/\/ arguments are spilled to the stack on x86-64.\nlet test_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 64);\n  llvm_execute_func\n    [ llvm_term {{ 0 : [64] }}\n    , llvm_term {{ 1 : [64] }}\n    , llvm_term {{ 2 : [64] }}\n    , llvm_term {{ 3 : [64] }}\n    , llvm_term {{ 4 : [64] }}\n    , llvm_term {{ 5 : [64] }}\n    , llvm_term x\n    , llvm_term {{ 1 : [64] }}\n    ];\n  llvm_return (llvm_term {{ x - 1 }});\n};\n\nllvm_verify_x86 m \".\/test\" \"test\" [] true test_spec w4;\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_points_to_overrides\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the MIR module from test.linked-mir.json and defines let-bound specs named inner_spec and outer_spec. Each spec should create a fresh symbolic 32-bit unsigned integer variable x, allocate mutable memory r for a 32-bit unsigned integer, and set r to point to x. Then execute the corresponding function (test::inner or test::outer) with r as argument, and verify that r still points to x after execution. Use mir_fresh_var, mir_alloc_mut, mir_points_to, and mir_execute_func accordingly. Finally, verify test::inner and test::outer with mir_verify, passing inner_ov as a dependency to outer_ov. Do not include comments or solver references in the SAW code."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nimpl_mir <- mir_load_module \"test.linked-mir.json\";\n\nlet inner_spec = do {\n    x <- mir_fresh_var \"x\" mir_u32;\n    r <- mir_alloc_mut mir_u32;\n    mir_points_to r (mir_term x);\n\n    mir_execute_func [r];\n\n    mir_points_to r (mir_term x);\n};\n\nlet outer_spec = do {\n    x <- mir_fresh_var \"x\" mir_u32;\n    r <- mir_alloc_mut mir_u32;\n    mir_points_to r (mir_term x);\n\n    mir_execute_func [r];\n\n    mir_points_to r (mir_term x);\n};\n\ninner_ov <- mir_verify impl_mir \"test::inner\" []         false inner_spec z3;\nouter_ov <- mir_verify impl_mir \"test::outer\" [inner_ov] false outer_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test0061_path_sat\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module termination.bc that defines a let-bound specification g_spec. The spec should symbolically input a 64-bit integer x using llvm_fresh_var and execute the functions g1 and g2 with x as argument. Include minimal preconditions to ensure safe termination of the loops in g1 and g2. Use llvm_execute_func to run the functions and llvm_verify to verify both functions against g_spec without inlining the spec. Do not include comments or solver references in the SAWScript.\n\n# Source code:\ntermination.c\n```C\n#include <stdint.h>\n\nuint64_t g1(uint64_t x) {\n  int i = 0;\n  uint64_t r = x;\n  do {\n    r = r+1;\n  } while ( i++ < 3 && r == 0 );\n  return r;\n}\n\n\/\/ NB the termination of the following loop\n\/\/ is a bit tricky because of the interaction\n\/\/ between short-cutting '&&' and the 'i++'\n\/\/ expression.\nuint64_t g2(uint64_t x) {\n  int i = 0;\n  uint64_t r = x;\n  do {\n    r = r+1;\n  } while ( r == 0 && i++ < 3 );\n  return r;\n}\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"termination.bc\";\n\nlet g_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 64);\n  llvm_execute_func [llvm_term x];\n  };\n\nllvm_verify m \"g1\" [] false g_spec z3;\n\n\/\/ NB: path sat checking is required for this\n\/\/ to terminate in a reasonable time\nllvm_verify m \"g2\" [] true g_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_external_abc\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated C or Java source files using the appropriate backend inferred from the presence of llvm_load_module or java_load_class. Define a let-bound specification named <name>_spec using a do block that symbolically declares inputs with llvm_fresh_var or jvm_fresh_var, applies minimal necessary preconditions for safety, and calls the exact functions or methods by their symbol names and signatures from the source files. The harness should then verify the correctness of these functions against the specification without inline do blocks or solver references."},{"role":"assistant","content":"```saw\nenable_experimental;\n\n\/\/ A formula that is universally true.\nlet t = {{ \\(x:[8]) (y:[8]) -> x == y ==> x+y == x+x }};\n\nprove_print sbv_abc t;\nprove_print w4_abc_smtlib2 t;\nprove_print w4_abc_verilog t;\nprove_print (offline_verilog \"offline_verilog\") t;\nprove_print (w4_offline_smtlib2 \"w4_offline_smtlib2\") t;\nprove_print (offline_aig_external \"offline_aig\") t;\nprove_print (offline_cnf_external \"offline_cnf\") t;\n\n\/\/ A formula that is unsatisfiable.\nlet q_unsat = {{ \\(x:[8]) -> x != 0 \/\\ x+x == x }};\n\nwrite_verilog \"write_verilog_unsat.v\" q_unsat;\nwrite_smtlib2_w4 \"write_smtlib2_w4_unsat.smt2\" q_unsat;\nwrite_aig_external \".\/write_aig_external_unsat.aig\" q_unsat;\nwrite_cnf_external \".\/write_aig_external_unsat.cnf\" q_unsat;\n\n\/\/ A formula that is satisfiable.\nlet q_sat = {{ \\(x:[8]) -> x+x == x }};\n\nwrite_verilog \"write_verilog_sat.v\" q_sat;\nwrite_smtlib2_w4 \"write_smtlib2_w4_sat.smt2\" q_sat;\nwrite_aig_external \".\/write_aig_external_sat.aig\" q_sat;\nwrite_cnf_external \".\/write_aig_external_sat.cnf\" q_sat;\n\nfails (prove_print sbv_abc q_sat);\nfails (prove_print w4_abc_smtlib2 q_sat);\nfails (prove_print w4_abc_verilog q_sat);\n\n\/\/ A function that returns a sequence\nlet seqt = {{ \\(x:[8]) (y:[8]) -> [x + y, x - y] }};\nwrite_verilog \"write_verilog_seqt.v\" seqt;\n\n\/\/ A function that returns a tuple\nlet tupt = {{ \\(x:[8]) (y:[8]) -> (x + y, x - y) }};\nwrite_verilog \"write_verilog_tupt.v\" tupt;\n\nlet order_term = {{ \\(x:[2][2][8]) -> \\(y:[32]) -> y == 0x81050fff \/\\ x == [[2,3],[4,5]] }};\nlet order_res = {{ ([[0x02,0x03],[0x04,0x05]], 0x81050fff) }};\n\n\/\/ Check that Verilog counterexamples are in the right order\nsr1 <- sat w4_abc_verilog order_term;\ncaseSatResult sr1 (fail \"ABC verilog sat fail\") (\\t -> prove_print yices {{ t == order_res }});\n\n\/\/ Check that AIGER counterexamples are in the right order\nsr2 <- sat w4_abc_aiger order_term;\ncaseSatResult sr2 (fail \"ABC aiger sat fail\") (\\t -> prove_print yices {{ t == order_res }});\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_global_field\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from \"test.bc\" and verifies the function \"set\" with signature \"void set(uint32_t x, uint32_t y)\". Define a let-bound spec named set_spec that allocates the global variable \"the_pair\" of type pair_t, creates symbolic 32-bit integer inputs x and y, executes the function \"set\" with these symbolic inputs, and asserts that the fields \"first\" and \"second\" of the global \"the_pair\" point to x and y respectively. Include any minimal preconditions needed for safety or termination. Use llvm_* commands exclusively and do not inline the spec in the verification call.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n\ntypedef struct {\n\tuint32_t first;\n\tuint32_t second;\n} pair_t;\n\npair_t the_pair;\n\nvoid set (uint32_t x, uint32_t y) {\n\tthe_pair.first = x;\n\tthe_pair.second = y;\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ This test ensures that `llvm_field` can be used in conjunction\n\/\/ with `llvm_global`. It is a regression test for saw-script\n\/\/ issue 742 (https:\/\/github.com\/GaloisInc\/saw-script\/issues\/742).\n\nbc <- llvm_load_module \"test.bc\";\n\nllvm_verify bc \"set\" [] false\n  do {\n    llvm_alloc_global \"the_pair\";\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    llvm_execute_func [llvm_term x, llvm_term y];\n    llvm_points_to (llvm_field (llvm_global \"the_pair\") \"first\") (llvm_term x);\n    llvm_points_to (llvm_field (llvm_global \"the_pair\") \"second\") (llvm_term y);\n  }\n  z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_FNV_a1_rev\/FNV_a1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the fnv1a hash function implementation. Include properties that check the expected hash outputs for given inputs, verify the padding behavior, and confirm the correctness of the saltHash function with various salts and messages. Ensure the properties can be used with :prove or :check commands to validate the implementation against the provided test vectors and specifications."},{"role":"assistant","content":"```cryptol\nfnv1a : {n} (fin n) => [n] -> [64]\nfnv1a ws = fnv1a' (pad ws)\n\npad : {msgLen,chunks,padding}\n     ( fin chunks\n     , fin msgLen\n     , chunks     == (msgLen+7) \/ 8\n     , padding    == (8 - msgLen % 8) % 8\n     )\n     => [msgLen] -> [chunks][8]\npad msg = split (msg # (zero:[padding]))\n\nfnv1a' : {chunks} (fin chunks) => [chunks][8] -> [64]\nfnv1a' msg = Ss ! 0\n  where\n   Ss = [fnv1a_offset_basis] #\n           [ block s m\n           | s <- Ss\n           | m <- msg\n           ]\n\nblock : {padding} ( fin padding, padding == 64 - 8) => [64] -> [8] -> [64]\nblock state val = (state ^ ((zero : [padding]) # val)) * fnv1a_prime\n\nfnv1a_offset_basis : [64]\nfnv1a_offset_basis = 14695981039346656037\n\nfnv1a_prime : [64]\nfnv1a_prime = 1099511628211\n\nt1 = fnv1a [] == 0xcbf29ce484222325\nt2 = fnv1a (join \"a\") == 0xaf63dc4c8601ec8c\nt3 = fnv1a (join \"foobar\") == 0x85944171f73967e8\n\nproperty testsPass = [t1, t2, t3] == ~zero\n\nbreak : {n} (fin n) => [4]([64],[64]) -> [n][8] -> Bit\nbreak pairs secret = ~zero == [saltHashCorrect p secret | p <- pairs]\n\nsecret1 : [4]([64],[64])\nsecret1 = [ (`0    , saltHash `0x0   msg)\n          , (`0xF  , saltHash `0xF   msg)\n          , (`0xFF , saltHash `0xFF  msg)\n          , (`0xFFF, saltHash `0xFFF msg)\n          ]\n  where msg = \"Secret Message\"\n\nsaltHashCorrect : {n} (fin n) => ([64],[64]) -> [n][8] -> Bit\nsaltHashCorrect (salt,result) secret = saltHash salt secret == result\n\nsaltHash : {n} (fin n) => [64] -> [n][8] -> [64]\nsaltHash s msg = fnv1a (s # join msg)\n```"}]}
{"filename":"saw-script\/intTests\/test0040_statics\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from static.bc and defines let-bound specifications for the functions f, f1, and f2. For each spec, use llvm_fresh_var to create a symbolic 32-bit integer input named x, execute the corresponding function with this input, and return the expected output term. Include minimal preconditions if necessary to ensure safety. Then verify each function against its spec using llvm_verify, referencing the exact function names as defined in the module. Do not include comments or solver references in the SAWScript."},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"static.bc\";\n\nf_ov <- llvm_verify m \"f\" [] false do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    let xtm = llvm_term x;\n    llvm_execute_func [xtm];\n    llvm_return xtm;\n} abc;\n\nllvm_verify m \"f1\" [f_ov] false do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_execute_func [llvm_term x];\n    llvm_return (llvm_term {{ x + 1}});\n} abc;\n\nllvm_verify m \"f2\" [f_ov] false do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_execute_func [llvm_term x];\n    llvm_return (llvm_term {{ x - 1}});\n} abc;\n```"}]}
{"filename":"saw-script\/intTests\/test0056_instantiate_match_term\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'test.bc' and defines two let-bound specs: 'foo_spec' and 'bar_spec'. In 'foo_spec', create a fresh 32-bit integer variable 'x', call the function 'foo' with arguments 'x' and 'x + 1', and specify that the function returns 0. In 'bar_spec', call the function 'bar' with no arguments. Then verify 'foo' against 'foo_spec' and 'bar' against 'bar_spec', passing the verification result of 'foo' as a dependency to 'bar'. Use symbolic inputs and ensure the specs directly reference the exact function signatures from 'test.c'.\n\n# Source code:\ntest.c\n```C\nint foo(int x, int y)\n{\n  return x == y;\n}\n\nvoid bar()\n{\n  foo(1, 2);\n}\n\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nlet foo_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [(llvm_term x), (llvm_term {{ x + 1 }})];\n  llvm_return (llvm_term {{ 0 : [32] }});\n};\n\nlet bar_spec = do {\n  llvm_execute_func [];\n};\n\nfoo_ov <- llvm_verify m \"foo\" [] false foo_spec abc;\nllvm_verify m \"bar\" [foo_ov] false bar_spec abc;\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_verify_conds\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given path and defines a let-bound specification named add1_spec. The spec should create a symbolic 32-bit unsigned integer input variable x with a precondition that x is less than 0xffffffff, execute the function test::add1 with x as input, and return the result. Then verify the function test::add1 against add1_spec using mir_verify."},{"role":"assistant","content":"```saw\nenable_experimental;\n\n\/\/ A spec using mir_precond\n\nlet add1_precond_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_precond {{ x < 0xffffffff }};\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term {{ x + 1 }});\n};\n\n\/\/ A spec using mir_assert in a precondition\n\nlet add1_precond_assert_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_assert {{ x < 0xffffffff }};\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term {{ x + 1 }});\n};\n\n\/\/ A spec using mir_postcond\n\nlet add1_postcond_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_precond {{ x < 0xffffffff }};\n\n  mir_execute_func [mir_term x];\n\n  x' <- mir_fresh_var \"x'\" mir_u32;\n  mir_return (mir_term x');\n  mir_postcond {{ x < x' }};\n};\n\n\/\/ A spec using mir_assert in a postcondition\n\nlet add1_postcond_assert_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_precond {{ x < 0xffffffff }};\n\n  mir_execute_func [mir_term x];\n\n  x' <- mir_fresh_var \"x'\" mir_u32;\n  mir_return (mir_term x');\n  mir_assert {{ x < x' }};\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::add1\" [] false add1_precond_spec z3;\nmir_verify m \"test::add1\" [] false add1_precond_assert_spec z3;\nmir_verify m \"test::add1\" [] false add1_postcond_spec z3;\nmir_verify m \"test::add1\" [] false add1_postcond_assert_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_x86_07\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function 'precondtest' defined in 'test.bc' compiled from 'test.c'. Define a let-bound spec named 'precondtest_spec' that uses 'crucible_fresh_var' to create a symbolic 64-bit integer input 'x' with the precondition 'x < 10'. Execute the function with this input and bind the return value to a symbolic variable 'x''. Add a postcondition that 'x'' is less than 10. Use 'llvm_verify_x86' to verify 'precondtest' in module 'm' with this spec, without additional arguments or solver references.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n#include <stdio.h>\n\nextern uint64_t precondtest(uint64_t x);\n\nvoid test() {\n\tprecondtest(1);\n};\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet precondtest_setup = do {\n  x <- crucible_fresh_var \"x\" (llvm_int 64);\n  crucible_precond {{ x < 10 }};\n  llvm_execute_func [crucible_term x];\n  x' <- crucible_fresh_var \"x'\" (llvm_int 64);\n  crucible_return (crucible_term x');\n  crucible_postcond {{ x' < 10 }};\n};\n\nllvm_verify_x86 m \".\/precondtest\" \"precondtest\" [] false precondtest_setup w4;\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_non_fresh\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from test.bc and defines let-bound specs for the functions foo and bar as declared in test.c. Use llvm_fresh_var to create symbolic pointer inputs of type i64 pointer for both functions. For foo_spec, specify that the function returns the same pointer as its input. For bar_spec, specify that the function returns 1 if foo returns the input pointer, else 0. Include minimal preconditions to ensure pointer validity. Then verify foo and bar against their specs using llvm_verify with no solver references.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n#include <stdlib.h>\n\nuint64_t *foo (uint64_t *x) {\n\treturn x;\n}\n\nint bar (uint64_t *x) {\n\treturn (foo(x) == x);\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ This test checks whether we can verify a spec that says a function\n\/\/ returns a fresh pointer, when in actuality the function returns\n\/\/ a pointer from the input. It is a regression test for saw-script\n\/\/ issue #641.\n\/\/ https:\/\/github.com\/GaloisInc\/saw-script\/issues\/641\n\nbc <- llvm_load_module \"test.bc\";\n\nlet i64 = llvm_int 64;\n\nfoo_ov <-\n  llvm_verify bc \"foo\" [] false\n    do {\n      x <- llvm_alloc i64;\n      llvm_execute_func [x];\n      llvm_return x;\n    }\n    z3;\n\nfails (\n  llvm_verify bc \"foo\" [] false\n    do {\n      x <- llvm_alloc i64;\n      llvm_execute_func [x];\n      y <- llvm_alloc i64;\n      llvm_return y;\n    }\n    z3\n  );\n\nfails (\n  llvm_verify bc \"bar\" [foo_ov] false\n    do {\n      x <- llvm_alloc i64;\n      llvm_execute_func [x];\n      llvm_return (llvm_term {{ 0 : [32] }});\n    }\n    z3\n  );\n\nbar_ov1 <-\n  llvm_verify bc \"bar\" [] false\n    do {\n      x <- llvm_alloc i64;\n      llvm_execute_func [x];\n      llvm_return (llvm_term {{ 1 : [32] }});\n    }\n    z3;\n```"}]}
{"filename":"saw-script\/intTests\/test0027_crucible_llvm\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from \"test.bc\" and defines let-bound specifications named add_nums32_spec and add_nums64_spec. Each spec should create symbolic 32-bit and 64-bit integer inputs respectively using llvm_fresh_var, call the corresponding function add_nums32 or add_nums64 with these inputs using llvm_execute_func, and verify that the function returns the sum of the inputs. Use llvm_return to specify the expected return value as the sum of the symbolic inputs. Do not include comments or solver references in the specs.\n\n# Source code:\ntest.c\n```C\n#include <stdlib.h>\n#include <stdio.h>\n\nuint32_t add_nums32( uint32_t x, uint32_t y ) {\n  return (x+y);\n}\n\nuint64_t add_nums64( uint64_t x, uint64_t y ) {\n  return (x+y);\n}\n\nint main() {\n  printf(\"%u + %u = %u\\n\", 12U, 30U, add_nums32( 12U, 30U ) );\n  printf(\"%llu + %llu = %llu\\n\", 12ULL, 30ULL, add_nums64( 12ULL, 30ULL ) );\n  return 0;\n}\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nllvm_verify m \"add_nums32\" [] false\n  do { x <- llvm_fresh_var \"x\" (llvm_int 32);\n       y <- llvm_fresh_var \"y\" (llvm_int 32);\n       llvm_execute_func [ llvm_term x, llvm_term y ];\n       llvm_return (llvm_term {{ x + y }});\n     }\n  z3;\n\n\nllvm_verify m \"add_nums64\" [] false\n  do { x <- llvm_fresh_var \"x\" (llvm_int 64);\n       y <- llvm_fresh_var \"y\" (llvm_int 64);\n       llvm_execute_func [ llvm_term x, llvm_term y ];\n       llvm_return (llvm_term {{ x + y }});\n     }\n  z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_goal_tags_01\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'test.bc' and verifies the function 'f' with signature 'unsigned int f(unsigned int)'. Define a let-bound specification 'f_spec' that creates a symbolic 32-bit integer input 'i' with a precondition 'i < 512', executes 'f' with 'i', and asserts postconditions that the return value 'j' satisfies 'j <= 512' and 'j == i + 1'. Then define a proof tactic 'tac' that dispatches based on goal tags 'post bound' and 'post eq'. Finally, implement a 'main' function that loads the module, runs 'llvm_verify' on 'f' with 'f_spec' and 'tac', and prints 'done'.\n\n# Source code:\ntest.c\n```C\n\nunsigned int f(unsigned int i)\n{\n  return (i+1);\n}\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet f_spec : CrucibleSetup () = llvm_setup_with_tag \"f spec\" do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{i < 512}};\n  llvm_execute_func [llvm_term i];\n\n  j <- llvm_fresh_var \"j\" (llvm_int 32);\n  llvm_return (llvm_term j);\n  llvm_setup_with_tag \"post bound\"\n    (llvm_postcond {{ j <= 512 }});\n  llvm_setup_with_tag \"post eq\"\n    (llvm_postcond {{ j == i+1 }});\n};\n\nlet tac : ProofScript () = do {\n  isBound <- goal_has_tags [\"post bound\", \"f spec\"];\n  isEq    <- goal_has_tags [\"post eq\", \"f spec\"];\n\n  if isBound then do {\n    print_goal_summary;\n    yices;\n  } else if isEq then do {\n    print_goal_summary;\n    z3;\n  } else do {\n    \/\/ empty tactic should fail here if there are any goals\n    \/\/ not handled by the above\n    return ();\n  };\n};\n\nlet main : TopLevel () = do {\n  m <- llvm_load_module \"test.bc\";\n  llvm_verify m \"f\" [] false f_spec tac;\n  print \"done\";\n};\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_fresh_cryptol_var\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the file test.linked-mir.json and defines a let-bound specification named id_spec that takes a Cryptol type argument cty. The spec should create a fresh symbolic variable of type cty using mir_fresh_cryptol_var, execute the function test::id_array, test::id_tuple, and test::id_u32 with the symbolic input, and verify that the function returns the input unchanged. Use mir_execute_func and mir_return accordingly. Then verify each function with mir_verify, passing the appropriate Cryptol type for each function's input: [5][32] for id_array, ([32],[32]) for id_tuple, and [32] for id_u32. Do not include comments or solver references in the SAWScript."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet id_spec cty = do {\n  x <- mir_fresh_cryptol_var \"x\" cty;\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term x);\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::id_array\" [] false (id_spec {| [5][32] |}) z3;\nmir_verify m \"test::id_tuple\" [] false (id_spec {| ([32], [32]) |}) z3;\nmir_verify m \"test::id_u32\" [] false (id_spec {| [32] |}) z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_jvm_static_fields\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads Java classes A, B, and C from the provided source files. Define let-bound specs for each class's static methods: setX(long), setY(long), and getSum() returning long. Use jvm_fresh_var to create symbolic inputs for method parameters and static fields. For each spec, assert initial static field values, execute the method, and verify the updated static field or return value matches expected behavior, handling field shadowing by qualifying static field names as needed. Do not inline specs; bind them with let. Use jvm_verify with these specs to verify each method accordingly."},{"role":"assistant","content":"```saw\na <- java_load_class \"A\";\nprint a;\nb <- java_load_class \"B\";\nc <- java_load_class \"C\";\n\nprint \"Verifying class A\";\n\na_setX <-\n  jvm_verify a \"setX\" [] false\n    do {\n      x <- jvm_fresh_var \"x\" java_long;\n      v <- jvm_fresh_var \"v\" java_long;\n      jvm_static_field_is \"x\" (jvm_term x);\n      jvm_execute_func [jvm_term v];\n      jvm_static_field_is \"x\" (jvm_term v);\n    }\n    z3;\n\na_setY <-\n  jvm_verify a \"setY\" [] false\n    do {\n      y <- jvm_fresh_var \"y\" java_long;\n      v <- jvm_fresh_var \"v\" java_long;\n      jvm_static_field_is \"y\" (jvm_term y);\n      jvm_execute_func [jvm_term v];\n      jvm_static_field_is \"y\" (jvm_term v);\n    }\n    z3;\n\na_getSum <-\n  jvm_verify a \"getSum\" [] false\n    do {\n      x <- jvm_fresh_var \"x\" java_long;\n      y <- jvm_fresh_var \"y\" java_long;\n      jvm_static_field_is \"x\" (jvm_term x);\n      jvm_static_field_is \"y\" (jvm_term y);\n      jvm_execute_func [];\n      jvm_return (jvm_term {{ x + y }});\n    }\n    z3;\n\nprint \"Verifying class B\";\n\nb_setX <-\n  jvm_verify b \"setX\" [] false\n    do {\n      x <- jvm_fresh_var \"x\" java_long;\n      v <- jvm_fresh_var \"v\" java_long;\n      jvm_static_field_is \"x\" (jvm_term x);\n      jvm_execute_func [jvm_term v];\n      jvm_static_field_is \"x\" (jvm_term v);\n    }\n    z3;\n\nb_setY <-\n  jvm_verify b \"setY\" [] false\n    do {\n      y <- jvm_fresh_var \"y\" java_long;\n      v <- jvm_fresh_var \"v\" java_long;\n      jvm_static_field_is \"y\" (jvm_term y);\n      jvm_execute_func [jvm_term v];\n      jvm_static_field_is \"y\" (jvm_term v);\n    }\n    z3;\n\nfails (\n  jvm_verify b \"getSum\" [] false\n    do {\n      x <- jvm_fresh_var \"x\" java_long;\n      y <- jvm_fresh_var \"y\" java_long;\n      jvm_static_field_is \"x\" (jvm_term x);\n      \/\/ This fails because \"getSum\" is inherited from class A,\n      \/\/ which has its own static field called \"y\", which in turn\n      \/\/ is shadowed by field \"y\" from class B.\n      jvm_static_field_is \"y\" (jvm_term y);\n      jvm_execute_func [];\n      jvm_return (jvm_term {{ x + y }});\n    }\n    z3);\n\nb_getSum <-\n  jvm_verify b \"getSum\" [] false\n    do {\n      x <- jvm_fresh_var \"x\" java_long;\n      y <- jvm_fresh_var \"y\" java_long;\n      jvm_static_field_is \"x\" (jvm_term x);\n      \/\/ Because field \"A.y\" is shadowed by another field named \"y\"\n      \/\/ in class \"B\", we must use the qualified field name.\n      jvm_static_field_is \"A.y\" (jvm_term y);\n      jvm_execute_func [];\n      jvm_return (jvm_term {{ x + y }});\n    }\n    z3;\n\nprint \"Verifying class C\";\n\nc_setX <-\n  jvm_verify c \"setX\" [] false\n    do {\n      x <- jvm_fresh_var \"x\" java_long;\n      v <- jvm_fresh_var \"v\" java_long;\n      jvm_static_field_is \"x\" (jvm_term x);\n      jvm_execute_func [jvm_term v];\n      jvm_static_field_is \"x\" (jvm_term v);\n    }\n    z3;\n\nc_setY <-\n  jvm_verify c \"setY\" [] false\n    do {\n      y <- jvm_fresh_var \"y\" java_long;\n      v <- jvm_fresh_var \"v\" java_long;\n      jvm_static_field_is \"y\" (jvm_term y);\n      jvm_execute_func [jvm_term v];\n      jvm_static_field_is \"y\" (jvm_term v);\n    }\n    z3;\n\nc_getSum <-\n  jvm_verify c \"getSum\" [] false\n    do {\n      x <- jvm_fresh_var \"x\" java_long;\n      y <- jvm_fresh_var \"y\" java_long;\n      jvm_static_field_is \"x\" (jvm_term x);\n      jvm_static_field_is \"y\" (jvm_term y);\n      jvm_execute_func [];\n      jvm_return (jvm_term {{ x + y }});\n    }\n    z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_bitfield_duplicate_points_to\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function 'get_y' defined in 'test.bc' compiled from 'test.c'. Define a let-bound spec named 'get_y_spec' that allocates a symbolic struct 's', creates a fresh symbolic 1-bit integer variable 'z', and uses duplicate llvm_points_to_bitfield statements for the 'y' bitfield of the struct. Execute the function with the symbolic struct pointer and return the symbolic variable 'z'. Verify the function 'get_y' against 'get_y_spec' with no arguments and no solver hints.\n\n# Source code:\ntest.c\n```C\n#include <stdbool.h>\n#include <stdint.h>\n\nstruct s {\n  int32_t w;\n  uint8_t x1:1;\n  uint8_t x2:2;\n  uint8_t y:1;\n  int32_t z;\n};\n\nbool get_y(struct s *ss) {\n  return ss->y;\n}\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\nenable_lax_loads_and_stores;\n\nlet get_y_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 1);\n  \/\/ Duplicate llvm_points_to_bitfield statements involving `y`\n  llvm_points_to_bitfield ss \"y\" (llvm_term z);\n  llvm_points_to_bitfield ss \"y\" (llvm_term z);\n  llvm_execute_func [ss];\n  llvm_return (llvm_term z);\n};\n\nm <- llvm_load_module \"test.bc\";\nfails (llvm_verify m \"get_y\" [] false get_y_spec (w4_unint_z3 []));\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_one_past_end\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from \"test.bc\" and defines a let-bound spec named spec_increment_span. The spec should allocate a 16-element array of 32-bit integers, initialize it with a fresh symbolic array variable, and call the function increment_span with pointers to the start and one-past-the-end of the array. Include minimal preconditions to ensure safe pointer usage and verify that after the call, the array elements have been incremented by one. Use llvm_fresh_var for symbolic inputs and llvm_points_to for memory setup and verification.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n\nvoid increment_span(uint32_t *lo, uint32_t *hi) {\n    for (uint32_t * cursor = lo; cursor < hi; cursor++) {\n        (*cursor)++;\n    }\n}\n\nvoid increment(uint32_t *p) {\n    (*p)++;\n}\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nlet t = llvm_array 16 (llvm_int 32);\n\nlet spec_increment = do {\n    a <- llvm_fresh_var \"a\" t;\n    p <- llvm_alloc t;\n    llvm_points_to p (llvm_term a);\n    let ptr_end = llvm_elem p 16;\n    llvm_execute_func [ptr_end];\n};\n\nlet spec_increment_span = do {\n    a <- llvm_fresh_var \"a\" t;\n    p <- llvm_alloc t;\n    llvm_points_to p (llvm_term a);\n    let ptr_start = llvm_elem p 0;\n    let ptr_end = llvm_elem p 16;\n    llvm_execute_func [ptr_start, ptr_end];\n    llvm_points_to p (llvm_term {{ map (\\x -> x+1) a }} );\n};\n\nllvm_verify m \"increment_span\" [] false spec_increment_span rme;\nfails (llvm_verify m \"increment\" [] false spec_increment rme);\n```"}]}
{"filename":"saw-script\/intTests\/test2045\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the provided path, defines a let-bound specification named f_spec that allocates a symbolic array of 5 bytes, initializes it with the values [1,2,3,4,5], and executes the function 'test::f' with this array as input, returning the expected result as a symbolic 8-bit value. Then verify 'test::f' against this specification. Similarly, define and verify a specification for 'test::g' that depends on the verification of 'test::f'. Use llvm_fresh_var for symbolic inputs and include minimal preconditions to ensure safety. Reference exact symbol names 'test::f' and 'test::g' as defined in the LLVM module."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet oneThroughFive = mir_term {{ [1, 2, 3, 4, 5] : [5][8] }};\n\nlet f_spec_1 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_value a];\n\n  mir_return (mir_term {{ 3 : [8] }});\n};\n\nlet f_spec_2 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_range_value a 1 3];\n\n  mir_return (mir_term {{ 5 : [8] }});\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nf_ov_1 <- mir_verify m \"test::f\" [] false f_spec_1 z3;\nmir_verify m \"test::g\" [f_ov_1] false f_spec_1 z3;\n\nf_ov_2 <- mir_verify m \"test::f\" [] false f_spec_2 z3;\nmir_verify m \"test::g\" [f_ov_2] false f_spec_2 z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_newtype\/complex.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the complex number operations defined in the given code satisfy the ring axioms: associativity of addition and multiplication, and distributivity of multiplication over addition. Include properties that check these laws for the CplxInt type using the provided cplxAdd, cplxMul, and cplxEq functions."},{"role":"assistant","content":"```cryptol\n\/\/ This is a development of rational complex numbers\n\ntype Int = Integer\n\n\/\/ Complex rational numbers in rectangular coordinates\nnewtype CplxInt =\n  { real : Int, imag : Int }\n\nembedQ : Int -> CplxInt\nembedQ x = CplxInt{ real = x, imag = 0 }\n\ncplxAdd : CplxInt -> CplxInt -> CplxInt\ncplxAdd x y = CplxInt { real = r, imag = i }\n  where\n  r = x.real + y.real\n  i = x.imag + y.imag\n\ncplxMul : CplxInt -> CplxInt -> CplxInt\ncplxMul x y = CplxInt { real = r, imag = i }\n  where\n  r = x.real * y.real - x.imag * y.imag\n  i = x.real * y.imag + x.imag * y.real\n\ncplxEq : CplxInt -> CplxInt -> Bit\ncplxEq x y = (x.real == y.real) && (x.imag == y.imag)\n\ncplxAddAssoc : CplxInt -> CplxInt -> CplxInt -> Bit\ncplxAddAssoc x y z =\n  cplxEq (cplxAdd (cplxAdd x y) z)\n         (cplxAdd x (cplxAdd y z))\n\ncplxMulAssoc : CplxInt -> CplxInt -> CplxInt -> Bit\ncplxMulAssoc x y z =\n  cplxEq (cplxMul (cplxMul x y) z)\n         (cplxMul x (cplxMul y z))\n\ncplxMulDistrib : CplxInt -> CplxInt -> CplxInt -> Bit\ncplxMulDistrib x y z =\n  cplxEq (cplxMul x (cplxAdd y z))\n         (cplxAdd (cplxMul x y) (cplxMul x z))\n```"}]}
{"filename":"saw-script\/intTests\/test_newtype\/complex_newtype.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test_newtype\/complex_newtype.saw, defines a let-bound specification named complex_add_spec that uses llvm_fresh_var to create symbolic inputs matching the signature of the complex addition function defined in the associated LLVM source, applies minimal preconditions for safety, and verifies the function against the Cryptol property cplxAddAssoc imported from complex.cry. Similarly, define specs and verify for complex multiplication associativity and distributivity functions using the exact LLVM function symbols corresponding to these operations."},{"role":"assistant","content":"```saw\nimport \"complex.cry\";\n\nprove_print cvc4 {{ \\ x y z -> cplxAddAssoc x y z}};\n\nprove_print cvc4 {{ \\ x y z -> cplxMulAssoc x y z}};\n\nprove_print cvc4 {{ \\ x y z -> cplxMulDistrib x y z}};\n```"}]}
{"filename":"saw-script\/intTests\/test0053_crucible_symbolic_alloc\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from test.bc that defines the functions foo and bar as in test.c. Define let-bound specs foo_spec and bar_spec using llvm_fresh_var to create symbolic inputs for the parameters: for foo, an int pointer x, and size_t n and i; for bar, a char pointer x, and size_t n and i. Add minimal preconditions to ensure safe indexing and termination, such as bounds on n and i, and alignment constraints where necessary. Use llvm_symbolic_alloc to allocate symbolic memory for the pointer arguments with sizes derived from n. Use llvm_execute_func to invoke the functions with these symbolic arguments. Do not inline the specs; bind them with let. The harness should be suitable for llvm_verify calls referencing these specs and the exact function names foo and bar.\n\n# Source code:\ntest.c\n```C\n#include <stdlib.h>\n\nvoid foo(int *x, size_t n, size_t i)\n{\n  x[i] = 0;\n}\n\nvoid bar(char *x, size_t n, size_t i)\n{\n  if (i < n)\n  {\n    foo((int*) x, n \/ sizeof(int), i \/ sizeof(int));\n  }\n}\n\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet foo_spec check = do {\n  n <- llvm_fresh_var \"n\" (llvm_int 64);\n  x_ptr <- llvm_symbolic_alloc false 4 {{ n * 4 }};\n  i <- llvm_fresh_var \"i\" (llvm_int 64);\n  llvm_precond {{ n < 2 ^^ 61 }};\n  if check then do {\n    llvm_precond {{ i < n }};\n  } else do {\n    return ();\n  };\n  llvm_execute_func [x_ptr, (llvm_term n), (llvm_term i)];\n};\n\nlet bar_spec = do {\n  n <- llvm_fresh_var \"n\" (llvm_int 64);\n  x_ptr <- llvm_symbolic_alloc false 4 n;\n  i <- llvm_fresh_var \"i\" (llvm_int 64);\n  llvm_precond {{ n < 2 ^^ 63 }};\n  llvm_precond {{ n && 3 == 0 }};\n  llvm_execute_func [x_ptr, (llvm_term n), (llvm_term i)];\n};\n\nfails (llvm_verify m \"foo\" [] false (foo_spec false) yices);\nfoo_ov <- llvm_verify m \"foo\" [] false (foo_spec true) yices;\nllvm_verify m \"bar\" [foo_ov] false bar_spec yices;\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_statics\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given path and defines let-bound specs for each function symbol from the associated source files. Use llvm_fresh_var to create symbolic inputs with minimal preconditions ensuring safety (e.g., valid pointers, non-zero divisors). Reference exact function names and signatures as defined in the source, and call llvm_execute_func with these symbolic inputs. Each spec should conclude with llvm_return specifying the expected output or state. Do not inline specs directly in calls; instead, bind them with let. Ensure the harness verifies each function against its spec using llvm_verify."},{"role":"assistant","content":"```saw\nenable_experimental;\n\n\/\/ A basic spec that uses the initial value of S1.\nlet f1_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_static_initializer \"test::S1\");\n};\n\n\/\/ An alternative spec that uses a different initial value for S1.\nlet f1_alt_spec = do {\n  let s1_static = mir_static \"test::S1\";\n  let init = mir_term {{ 42 : [32] }};\n  mir_points_to s1_static init;\n\n  mir_execute_func [];\n\n  mir_points_to s1_static init;\n  mir_return init;\n};\n\n\/\/ A buggy spec that refers to a non-existent static initializer value.\nlet f1_fail_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_static_initializer \"test::S1_fake\");\n};\n\n\/\/ A buggy spec that refers to a non-existent static value.\nlet f1_fail_alt_spec = do {\n  let s1_static = mir_static \"test::S1_fake\";\n  let init = mir_term {{ 42 : [32] }};\n  mir_points_to s1_static init;\n\n  mir_execute_func [];\n\n  mir_points_to s1_static init;\n  mir_return init;\n};\n\n\/\/ A spec that matches against a static in the return value.\nlet f2_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_static \"test::S2\");\n};\n\n\/\/ A basic spec that uses the initial value of S3.\nlet f3_spec = do {\n  let s3_static = mir_static \"test::S3\";\n  mir_points_to s3_static (mir_static_initializer \"test::S3\");\n\n  mir_execute_func [];\n\n  let ret = mir_term {{ 4 : [32] }};\n  mir_points_to s3_static ret;\n  mir_return ret;\n};\n\n\/\/ An alternative spec that uses a different initial value for S3.\nlet f3_alt_spec = do {\n  let s3_static = mir_static \"test::S3\";\n  let init = {{ 42 : [32] }};\n  mir_points_to s3_static (mir_term init);\n\n  mir_execute_func [];\n\n  let ret = mir_term {{ init + 1 }};\n  mir_points_to s3_static ret;\n  mir_return ret;\n};\n\n\/\/ A buggy spec that does not initialize S3 (a mutable static value).\nlet f3_fail_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_term {{ 4 : [32] }});\n};\n\n\/\/ A spec that ensures that fresh allocations do not alias with static\n\/\/ references.\nlet g_spec = do {\n  r_ref <- mir_alloc mir_u32;\n\n  mir_execute_func [r_ref];\n\n  mir_return (mir_term {{ False }});\n};\n\n\/\/ g(&S1) should return True.\nlet g_alt_spec = do {\n  mir_execute_func [mir_static \"test::S1\"];\n\n  mir_return (mir_term {{ True }});\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::f1\" [] false f1_spec z3;\nmir_verify m \"test::f1\" [] false f1_alt_spec z3;\nmir_verify m \"test::f2\" [] false f2_spec z3;\nmir_verify m \"test::f3\" [] false f3_spec z3;\nmir_verify m \"test::f3\" [] false f3_alt_spec z3;\nmir_verify m \"test::g\" [] false g_spec z3;\nmir_verify m \"test::g\" [] false g_alt_spec z3;\n\nfails (\n  mir_verify m \"test::f1\" [] false f1_fail_spec z3\n);\nfails (\n  mir_verify m \"test::f1\" [] false f1_fail_alt_spec z3\n);\nfails (\n  mir_verify m \"test::f3\" [] false f3_fail_spec z3\n);\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_global_fresh_pointer\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from test.bc that verifies the functions foo and bar defined in test.c. Define a let-bound specification foo_spec that allocates the global variable glb and creates a fresh symbolic pointer of type pointer to 32-bit int. The spec should execute the function foo with this symbolic pointer as argument. Then verify foo against foo_spec and use the resulting verification condition as a prerequisite to verify bar with the same spec. Use llvm_fresh_pointer and llvm_alloc_global as needed, and ensure the spec uses symbolic inputs rather than concrete values.\n\n# Source code:\ntest.c\n```C\nint glb;\n\nvoid foo(const int *x) {}\n\nvoid bar(const int *x) {\n  foo(x);\n}\n\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\n\/\/ test the fact that glb and x_ptr are allowed to alias each other.\nlet foo_spec = do {\n  llvm_alloc_global \"glb\";\n  x_ptr <- llvm_fresh_pointer (llvm_int 32);\n\n  llvm_execute_func [x_ptr];\n};\n  \nfoo_ov <- llvm_verify m \"foo\"\n  []\n  false\n  foo_spec\n  (do {\n    print_goal;\n    w4_unint_z3 [];\n  });\n\nllvm_verify m \"bar\"\n  [foo_ov]\n  false\n  foo_spec\n  (do {\n    print_goal;\n    w4_unint_z3 [];\n  });\n```"}]}
{"filename":"saw-script\/intTests\/test0047_alloc_sized\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from \"test.bc\" and defines a let-bound specification named set_spec. The spec should allocate memory of size 8 bytes (sum of sizeof(A_t) and sizeof(B_t)) for a pointer of type %struct.A, initialize the field 'x' of the allocated struct to 0, symbolically execute the function 'set' with this pointer as input, and then verify that the field 'x' is updated to 10 and the field 'y' in the casted B_t struct is updated to 42. Use llvm_fresh_var for symbolic inputs if needed and include minimal preconditions for safety. Finally, verify the function 'set' against set_spec using llvm_verify.\n\n# Source code:\ntest.c\n```C\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct A {\n  int x;\n} A_t;\n\ntypedef struct B {\n  int y;\n} B_t;\n\ntypedef struct C {\n  A_t a;\n  int z;\n} C_t;\n\nB_t *cast_as_b(A_t *both) {\n  void *v = (void *)both;\n  C_t *c = (C_t *)v; \/\/ cast to a C so we can get the address of the B\n  return (B_t *)(void *)(&c->z);\n}\n\nvoid set(A_t *both) {\n  both->x = 10;\n  B_t *b = cast_as_b(both);\n  b->y = 42;\n}\n\nint main() {\n  size_t size_of_both = sizeof(A_t) + sizeof(B_t);\n  A_t *both = malloc(size_of_both);\n  memset(both, 0, size_of_both);\n  set(both);\n  B_t *b = cast_as_b(both);\n  return b->y; \/\/ echo $? gives 42\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ Ultimately, this spec is unsound when used as an override due to issue #30,\n\/\/ but it demonstrates the llvm_alloc_with_size feature.\nm <- llvm_load_module \"test.bc\";\nenable_experimental;\nlet set_spec = do {\n  \/\/ sizeof(A_t) + sizeof(B_t) = 8\n  both_ptr <- llvm_alloc_with_size 8 (llvm_type \"%struct.A\");\n  llvm_points_to (llvm_field both_ptr \"x\") (llvm_term {{ 0 : [32] }});\n  llvm_execute_func [both_ptr];\n  llvm_points_to (llvm_field both_ptr \"x\") (llvm_term {{ 10 : [32] }});\n};\nllvm_verify m \"set\" [] false set_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_verify_enums\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given source files and defines let-bound specs for each target function: test::f, test::g, test::h_none, test::h_some, test::i42, and test::i43. Use llvm_fresh_var to create symbolic inputs where needed, and include minimal preconditions for safety. Each spec should execute the corresponding function with appropriate symbolic or enum inputs and return the expected enum or integer results matching the function's signature. Then verify each function against its spec using llvm_verify, referencing the exact function names as given."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet option_u32_adt = mir_find_adt m \"core::option::Option\" [mir_u32];\nlet i_adt = mir_find_adt m \"test::I\" [];\n\nlet f_none_spec = do {\n  let x = mir_enum_value option_u32_adt \"None\" [];\n\n  mir_execute_func [x];\n\n  mir_return (mir_term {{ 27 : [32] }});\n};\n\nlet f_some_spec = do {\n  let ret = mir_term {{ 42 : [32] }};\n  let x = mir_enum_value option_u32_adt \"Some\" [ret];\n\n  mir_execute_func [x];\n\n  mir_return ret;\n};\n\nlet g_spec = do {\n  b <- mir_fresh_var \"b\" mir_bool;\n\n  mir_execute_func [mir_term b];\n\n  mir_return (mir_term {{ if b then 27 else 42 : [32] }});\n};\n\nlet h_none_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_enum_value option_u32_adt \"None\" []);\n};\n\nlet h_some_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_enum_value option_u32_adt \"Some\" [mir_term x]);\n};\n\nlet i42_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_enum_value i_adt \"I42\" []);\n};\n\nlet i43_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_enum_value i_adt \"I43\" []);\n};\n\n\/\/ `mir_enum_value` should error if it cannot find a variant name.\nlet i43_bad_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_enum_value i_adt \"I44\" []);\n};\n\nf_none_ov <- mir_verify m \"test::f\" [] false f_none_spec z3;\nf_some_ov <- mir_verify m \"test::f\" [] false f_some_spec z3;\n\nmir_verify m \"test::g\" [f_none_ov, f_some_ov] false g_spec z3;\n\nmir_verify m \"test::h_none\" [] false h_none_spec z3;\nmir_verify m \"test::h_some\" [] false h_some_spec z3;\n\nmir_verify m \"test::i42\" [] false i42_spec z3;\nmir_verify m \"test::i43\" [] false i43_spec z3;\nfails (\n  mir_verify m \"test::i43\" [] false i43_bad_spec z3\n);\n```"}]}
{"filename":"saw-script\/intTests\/test2028_vacuity_detect\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java method Test.fun_jvm defined in Test.java. Define a let-bound spec named fun_jvm_spec that uses jvm_fresh_var to create symbolic inputs as needed, includes minimal preconditions to ensure safety or termination, and calls jvm_execute_func referencing the exact method signature. Then use jvm_verify to verify the method against the spec. Do not include comments or solver references in the SAWScript.\n\n# Source code:\nTest.java\n```java\npublic class Test {\n    public static void fun_jvm() {\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet fun_rs_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_precond {{ x != x }};\n  mir_execute_func [];\n};\nmir_mod <- mir_load_module \"test.linked-mir.json\";\nmir_verify mir_mod \"test::fun_rs\" [] false fun_rs_spec z3;\n\nlet fun_jvm_spec = do {\n  x <- jvm_fresh_var \"x\" java_int;\n  jvm_precond {{ x != x }};  \/\/ Always false\n  jvm_execute_func [];\n};\n\ncls <- java_load_class \"Test\";\njvm_verify cls \"fun_jvm\" [] false fun_jvm_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_unsafe_assume_spec\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the MIR module from \"test.linked-mir.json\" and defines let-bound specs for the functions test::f, test::g, test::h, test::g2, test::p, test::q, test::side_effect, and test::foo. Use mir_fresh_var to create symbolic inputs of type mir_u32 where appropriate, allocate mutable pointers with mir_alloc_mut for pointer arguments, and specify minimal preconditions to ensure safety. Reference the exact function names as \"test::f\", \"test::g\", etc., and use mir_execute_func to invoke these functions with symbolic or allocated arguments. Return the expected results using mir_return with expressions involving the symbolic variables. Do not inline specs directly; bind them to let names like f_spec, g_spec, etc. Do not include solver references or comments in the script."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet f_generic_spec (x : Term) = do {\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term x);\n};\n\nlet f_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n  f_generic_spec x;\n};\n\nlet f2_spec = do {\n  let x = {{ 2 : [32] }};\n  f_generic_spec x;\n};\n\nlet f3_spec = do {\n  let x = {{ 3 : [32] }};\n  f_generic_spec x;\n};\n\nlet g_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term {{ x + 1 }});\n};\n\nlet g2_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_term {{ 3 : [32] }});\n};\n\nlet h_spec = g_spec;\n\nlet p_spec_1 = do {\n  x_ptr <- mir_alloc mir_u32;\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_points_to x_ptr (mir_term x);\n\n  y_ptr <- mir_alloc mir_u32;\n  y <- mir_fresh_var \"y\" mir_u32;\n  mir_points_to y_ptr (mir_term y);\n\n  mir_execute_func [x_ptr, y_ptr];\n\n  mir_return (mir_term {{ x + y }});\n};\n\nlet p_spec_2 = do {\n  x_ptr <- mir_alloc mir_u32;\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_points_to x_ptr (mir_term x);\n\n  mir_execute_func [x_ptr, x_ptr];\n\n  mir_return (mir_term {{ 2 * x }});\n};\n\nlet q_spec = p_spec_1;\n\nlet side_spec_1 = do {\n  a_ptr <- mir_alloc_mut mir_u32;\n  a <- mir_fresh_var \"a\" mir_u32;\n  mir_points_to a_ptr (mir_term a);\n\n  mir_execute_func [a_ptr];\n\n  mir_points_to a_ptr (mir_term {{ 0 : [32] }});\n  mir_return (mir_term a);\n};\n\nlet side_spec_2 = do {\n  a_ptr <- mir_alloc_mut mir_u32;\n  a <- mir_fresh_var \"a\" mir_u32;\n  mir_points_to a_ptr (mir_term a);\n\n  mir_execute_func [a_ptr];\n\n  mir_return (mir_term a);\n};\n\n\/\/ This spec is erroneous. See the comments below in the \"Avoid unsoundness\"\n\/\/ part of the test.\nlet foo_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term {{ x }});\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nf_ov  <- mir_unsafe_assume_spec m \"test::f\" f_spec;\nf2_ov <- mir_unsafe_assume_spec m \"test::f\" f2_spec;\nf3_ov <- mir_unsafe_assume_spec m \"test::f\" f3_spec;\n\n\/\/ `g` should fail without an override for `f`...\nfails (\n  mir_verify m \"test::g\" [] false g_spec z3\n);\n\/\/ ...but should succeed with an `f` override.\nmir_verify m \"test::g\" [f_ov] false g_spec z3;\n\/\/ `h` never calls `f`, but it's still fine to redundantly pass an `f` override\nmir_verify m \"test::h\" [f_ov] false h_spec z3;\n\n\/\/ `g2` will succeed with both a generic `f` override as well as a specialized\n\/\/ one where the argument and result values are concrete.\nmir_verify m \"test::g2\" [f_ov] false g2_spec z3;\nmir_verify m \"test::g2\" [f2_ov] false g2_spec z3;\nmir_verify m \"test::g2\" [f_ov, f2_ov] false g2_spec z3;\n\n\/\/ Overrides that fail to match.\nfails (\n  mir_verify m \"test::g\" [f3_ov] false g_spec z3\n);\nfails (\n  mir_verify m \"test::g2\" [f3_ov] false g2_spec z3\n);\n\np_ov_1 <- mir_unsafe_assume_spec m \"test::p\" p_spec_1;\np_ov_2 <- mir_unsafe_assume_spec m \"test::p\" p_spec_2;\n\nmir_verify m \"test::q\" [p_ov_1] false q_spec z3;\nfails (\n  mir_verify m \"test::q\" [p_ov_2] false q_spec z3\n);\n\nside_ov_1 <- mir_verify m \"test::side_effect\" [] false side_spec_1 z3;\nside_ov_2 <- mir_verify m \"test::side_effect\" [] false side_spec_2 z3;\n\n\/\/ This should not verify, as invoking `side_effect` should cause `foo` to\n\/\/ always return `0` rather than the argument value.\nfails (\n  mir_verify m \"test::foo\" [side_ov_1] false foo_spec z3\n);\n\/\/ This should not verify, as side_spec_2 underspecifies the mutable\n\/\/ allocation `a_ptr` in its postconditions. SAW will catch this when attempting\n\/\/ to use side_ov_2 as an override.\nfails (\n  mir_verify m \"test::foo\" [side_ov_2] false foo_spec z3\n);\n```"}]}
{"filename":"saw-script\/intTests\/test_ghost_types_00\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'test.bc' compiled from 'test.c'. Define let-bound specs for the functions 'f', 'g', and 'h' matching their C signatures: 'unsigned f(unsigned i)', 'unsigned char g(unsigned i)', and 'unsigned h(unsigned i)'. Use llvm_fresh_var to create symbolic 32-bit integer inputs for 'i'. For 'h_spec', add a precondition that 'i < 512' to ensure safety. In each spec, execute the corresponding function with the symbolic input, capture the return value, and return it. Use llvm_ghost_value to associate ghost state variables with the function outputs where appropriate. Finally, set up the top-level verification to assume the specs for 'f' and 'g' and verify 'h' against its spec, referencing the exact function names from the module.\n\n# Source code:\ntest.c\n```C\n#include \"stdlib.h\"\n\nextern unsigned x;\nextern unsigned char y;\n\nunsigned f(unsigned i) {\n  x = i;\n  return x;\n}\n\nunsigned char g(unsigned i) {\n  y = (unsigned char) (i \/ 8);\n  return y;\n}\n\nunsigned h(unsigned i) {\n  f(i);\n  g(i);\n  if (i < 32) {\n    return f(i);\n  }\n  return (unsigned) g(i);\n}\n\n```"},{"role":"assistant","content":"```saw\nlet f_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_execute_func [llvm_term i];\n  llvm_ghost_value x i;\n  llvm_return (llvm_term i);\n};\n\nlet g_spec (y : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_execute_func [llvm_term i];\n  let v = {{ drop (i \/ 8) : [8] }};\n  llvm_ghost_value y v;\n  llvm_return (llvm_term v);\n};\n\nlet h_spec : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{i < 512}};\n  llvm_execute_func [llvm_term i];\n  ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n  llvm_return (llvm_term ret);\n  llvm_postcond {{ ret <= i }};\n};\n\nlet main : TopLevel () = do {\n  x <- declare_ghost_state \"x\";\n  m <- llvm_load_module \"test.bc\";\n  f_ov <- llvm_unsafe_assume_spec m \"f\" (f_spec x);\n  \/\/ This spec should probably use a different variable, but doesn't:\n  g_ov <- llvm_unsafe_assume_spec m \"g\" (g_spec x);\n  fails (llvm_verify m \"h\" [f_ov, g_ov] false h_spec z3);\n  print \"done\";\n};\n```"}]}
{"filename":"saw-script\/intTests\/test_dangling_hoist\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test_dangling_hoist\/test.saw, defines a let-bound specification named test_dangling_hoist_spec using llvm_fresh_var to create symbolic inputs matching the exact function signature(s) found in the associated C source files, includes minimal preconditions necessary for safe execution (such as valid pointer or array bounds if applicable), and calls the target LLVM function(s) by their exact symbol names. The harness should then verify the correctness of the implementation against the specification without inline do blocks or comments."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nprove_extcore do {\n    print_goal;\n    check_goal;\n    hoist_ifs_in_goal;\n    print_goal;\n    check_goal;\n    admit \"sure\";\n  }\n  (parse_core \"(x : Integer) -> (y:Integer) -> (z:Integer) -> (b:Bool) -> EqTrue (intEq z (ite Integer b x y)) -> EqTrue (ite Bool b (intEq z x) (intEq z y))\");\n\n\nprove_extcore do {\n    print_goal;\n    check_goal;\n    goal_eval;\n    print_goal;\n    check_goal;\n    admit \"sure\";\n  }\n  (parse_core \"(x : Integer) -> (y:Integer) -> (z:Integer) -> (b:Bool) -> EqTrue (intEq z (ite Integer b x y)) -> EqTrue (ite Bool b (intEq z x) (intEq z y))\");\n```"}]}
{"filename":"saw-script\/intTests\/test_bisimulation\/Comp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification script that proves the stateful implementations `andImp` and `nandImp` correctly refine their respective specifications `andSpec` and `nandSpec`. The script should verify that for all inputs and states, when the implementations are ready, their outputs match the specification outputs, and that the state relations hold as defined by `andStateRel` and `nandStateRel`. Include lemmas or theorems to establish these refinement properties using the provided output and state relations."},{"role":"assistant","content":"```cryptol\nmodule Comp where\n\n\/\/ Specification for a functional AND gate. First output bit is the ready bit,\n\/\/ second bit is the result\nandSpec : ((), (Bit, Bit)) -> ((), (Bit, Bit))\nandSpec (_, (x, y)) = ((), (True, x && y))\n\n\/\/ Specification for a functional NAND gate. First output bit is the ready bit,\n\/\/ second bit is the result\nnandSpec : ((), (Bit, Bit)) -> ((), (Bit, Bit))\nnandSpec (_, (x, y)) = ((), (True, ~ (andSpec ((), (x, y))).1.1))\n\n\/\/ State for a stateful AND gate that first loads its inputs into memory, then\n\/\/ computes logical AND over them. `loaded` indicates whether the inputs have\n\/\/ been loaded into `origX` and `origY`.\ntype andState = { loaded : Bit, origX : Bit, origY : Bit }\n\n\/\/ A stateful AND gate.  First output bit is the ready bit, second bit is the\n\/\/ result.  This gate takes 2 cycles to compute.  It restarts when the input\n\/\/ changes.\nandImp : (andState, (Bit, Bit)) -> (andState, (Bit, Bit))\nandImp (s, (x, y)) =\n  if s.loaded \/\\ x == s.origX \/\\ y == s.origY\n  then (s, (True, s.origX && s.origY))\n  else ({ loaded = True, origX = x, origY = y }, (False, 0))\n\n\/\/ Output relation between `andImp` and `andSpec`.  Checks that outputs are\n\/\/ equivalent, given that `andImp` is ready to be read.\nandOutputRel : (andState, (Bit, Bit)) -> ((), (Bit, Bit)) -> Bit\nandOutputRel (s, (impReady, impO)) ((), (_, specO)) =\n  if impReady then impO == specO else True\n\n\/\/ State relation between `andImp` and `andSpec`.  Trivial in this case because\n\/\/ `andSpec` is stateless.\nandStateRel : andState -> () -> Bit\nandStateRel _ () = True\n\n\/\/ Stateful NAND gate holds `andState` as well as an unused bit.\ntype nandState = { as : andState, unused : Bit }\n\n\/\/ A stateful NAND gate.  First output bit is the ready bit, second bit is the\n\/\/ result.  This gate takes 2 cycles to compute.  It restarts when the input\n\/\/ changes.\nnandImp : (nandState, (Bit, Bit)) -> (nandState, (Bit, Bit))\nnandImp (s, in) = ({ as = as' , unused = False }, (andReady, ~andRes))\n  where\n    (as', (andReady, andRes)) = andImp (s.as, in)\n\n\/\/ Relation between `nandImp` and `nandSpec`.  Checks that outputs are\n\/\/ equivalent, given that `nandImp` is ready to be read.\nnandOutputRel : (nandState, (Bit, Bit)) -> ((), (Bit, Bit)) -> Bit\nnandOutputRel (s, (impReady, impO)) ((), (_, specO)) =\n  if impReady then impO == specO else True\n\n\/\/ State relation between `nandImp` and `nandSpec`.  Trivial in this case\n\/\/ because `nandSpec` is stateless.\nnandStateRel : nandState -> () -> Bit\nnandStateRel _ () = True\n```"}]}
{"filename":"saw-script\/intTests\/test_bisimulation\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification script that proves the output and state bisimulation relations (orel and srel) hold between the functions f1 and f2, showing that for related states and inputs, their outputs and next states remain related according to these relations."},{"role":"assistant","content":"```cryptol\nmodule Test where\n\n\/\/ State types\ntype S1 = [8]\ntype S2 = [16]\n\n\/\/ f1 and f2 both take a counter as state, as well as an input. They return a\n\/\/ pair containing the incremented counter and the sum of the input and counter.\n\/\/ f1 and f2 differ only their state types.\nf1 : (S1, [8]) -> (S1, [8])\nf1 (ctr, inp) = (ctr+1, inp+ctr)\nf2 : (S2, [8]) -> (S2, [8])\nf2 (ctr, inp) = (ctr+1, inp+(drop ctr))\n\n\/\/ A version of f2 with an input type that differs from f1\nf2_bad_input_type : (S2, [9]) -> (S2, [8])\nf2_bad_input_type (ctr, inp) = (ctr+1, (drop inp)+(drop ctr))\n\n\/\/ A version of f2 with an output type that differs from f1\nf2_bad_output_type : (S2, [8]) -> (S2, [9])\nf2_bad_output_type (ctr, inp) = (ctr+1, zext (inp+(drop ctr)))\n\n\/\/ Output bisimulation relation for f1 and f2\norel : (S1, [8]) -> (S2, [8]) -> Bit\norel (s1, o1) (s2, o2) = s1 == drop s2 \/\\ o1 == o2\n\n\/\/ State bisimulation relation for f1 and f2\nsrel : S1 -> S2 -> Bit\nsrel s1 s2 = s1 == drop s2\n```"}]}
{"filename":"saw-script\/intTests\/test_bisimulation\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the associated source files using llvm_load_module. Define a let-bound specification named my_function_spec that uses llvm_fresh_var to create symbolic inputs matching the exact function signature of the target function. Include minimal preconditions necessary for safety, such as non-zero divisors or valid array indices. Use llvm_verify to verify the implementation against the specification by referencing the exact function name from the source. Do not inline the spec; bind it with let. Do not include comments or solver references in the SAWScript."},{"role":"assistant","content":"```saw\n\/* Test the prove_bisim command with some simple examples *\/\n\nimport \"Test.cry\";\n\nenable_experimental;\n\nres <- prove_bisim z3 [] {{ srel }} {{ orel }} {{ f1 }} {{ f2 }};\n\n\/\/ Test non-named constant in bisimulation term\nfails (prove_bisim z3 [] {{ srel }} {{ orel }} {{ f1 }} {{ \\x -> f2 x }});\n\n\/\/ Test incompatable input types\nfails (prove_bisim z3 [] {{ srel }} {{ orel }} {{ f1 }} {{ f2_bad_input_type }});\n\n\/\/ Test incompatable output types\nfails (prove_bisim z3 [] {{ srel }} {{ orel }} {{ f1 }} {{ f2_bad_output_type }});\n\n\/\/ Test bad output relation type\nfails (prove_bisim z3 [] {{ srel }} {{ True }} {{ f1 }} {{ f2 }});\n\n\/\/ Test bad state relation type\nfails (prove_bisim z3 [] {{ True }} {{ orel }} {{ f1 }} {{ f2 }});\n\n\/\/ Test wrong state type\nfails (prove_bisim z3 [] {{ srel }} {{ orel }} {{ f2 }} {{ f2 }});\n```"}]}
{"filename":"saw-script\/intTests\/test_bisimulation\/comp.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'saw-script\/intTests\/test_bisimulation\/comp.saw' and defines let-bound specifications for the functions 'andImp', 'andSpec', 'nandImp', and 'nandSpec' as declared in the associated source files. Use llvm_fresh_var to create symbolic inputs for these functions, adding minimal preconditions to ensure safety and termination. Then, prove bisimulation between 'andImp' and 'andSpec' using these specs, followed by proving bisimulation between 'nandImp' and 'nandSpec' while referencing the previous proof result. Finally, attempt a bisimulation proof that uses an inapplicable theorem to test failure handling. Do not include solver references or comments."},{"role":"assistant","content":"```saw\n\/* Test the prove_bisim command with a compositional circuit *\/\n\nimport \"Comp.cry\";\n\nenable_experimental;\n\n\/\/ Prove 'andImp' and 'andSpec' simulate each other\nand_res <- prove_bisim z3\n                       []\n                       {{ andStateRel }}\n                       {{ andOutputRel }}\n                       {{ andImp }}\n                       {{ andSpec }};\n\n\/\/ Prove 'nandImp' and 'nandSpec' simulate each other, using 'and_res' in the\n\/\/ process.\nnand_res <- prove_bisim (do {\n    unfolding [\"nandImp\", \"nandSpec\"];\n    w4_unint_z3 [\"andImp\", \"andSpec\" ];\n  })\n  [and_res] {{ \\x -> nandStateRel x }} {{ \\x -> nandOutputRel x }} {{ nandImp }} {{ nandSpec }};\n\n\/\/ Test using theorem that doesn't apply\nprove_bisim z3\n            [nand_res]\n            {{ andStateRel }}\n            {{ andOutputRel }}\n            {{ andImp }}\n            {{ andSpec }};\n```"}]}
{"filename":"saw-script\/intTests\/test2043\/A.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally verifies the behavior of the function `bar` in module `A`. The specification should capture that for any length `n` and any type `a` with a `Zero` instance, `bar` returns a sequence of zeros of length `n`, matching the provided pattern matching cases."},{"role":"assistant","content":"```cryptol\nmodule A where\n\nparameter\n  type N : #\n  foo : [N]\n\nbar : {n, a} (Zero a) => [n]a\nbar | n == 1 => zero\n    | n != 1 => zero\n```"}]}
{"filename":"saw-script\/intTests\/test_hoist_ifs_in_goal\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test_hoist_ifs_in_goal\/test.saw, defines a let-bound specification named f_spec that uses llvm_fresh_var to create symbolic integer inputs, and verifies the function 'f' with signature 'i32 (i32)' against the property that for all booleans c and integers x,y, f(if c then g(x) else g(y)) == if c then x else y, where 'g' is another function with signature 'i32 (i32)'. Include minimal preconditions to ensure termination and safety. Use llvm_prove to prove the specification and do not inline the spec in the call."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet {{\n  f : Integer -> Integer\n  f x = undefined\n  g : Integer -> Integer\n  g x = undefined\n}};\n\nlet prop = {{ \\c x y -> f (if c then g x else g y) == if c then x else y }};\n\nl1 <- prove_print assume_unsat {{ \\x -> f (g x) == x }};\n\nprove_print\n  (do {\n    hoist_ifs_in_goal;\n    simplify (addsimps [l1] empty_ss);\n    w4;\n  })\n  prop;\n\nprint \"Done\";\n```"}]}
{"filename":"saw-script\/intTests\/test0026_bad_pointers\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"test.bc\" that verifies the functions read_after_free, write_after_free, double_free, equals_after_free, equals_null_after_free, le_after_free, le_different_allocs, read_after_stack_free, write_after_stack_free, free_after_stack_free, free_local, free_global, equals_after_stack_free, and lt_after_stack_free. For each function, define a let-bound spec named <function_name>_spec that uses llvm_fresh_var to create symbolic inputs if needed, includes minimal preconditions for safety, and calls llvm_verify with the function symbol and the spec. The specs should model the expected failure or behavior of each function accordingly, using llvm_execute_func and llvm_return as appropriate.\n\n# Source code:\ntest.c\n```C\n#include <stdlib.h>\n#include <stdio.h>\n\nint read_after_free()\n{  \n  volatile int* x = malloc(sizeof(int));\n  *x = 1;\n  free((int*) x);\n  return *x; \/\/ <- error here, read after free\n}\n\nint write_after_free()\n{  \n  volatile int* x = malloc(sizeof(int));\n  *x = 42;\n  free((int*) x);\n  *x = 12;  \/\/ <- error here, write after free\n  return 1;\n}\n\nint double_free()\n{  \n  volatile int* x = malloc(sizeof(int));\n  *x = 12;\n  free((int*) x);\n  free((int*) x); \/\/ <- error here, double free\n  return 1;\n}\n\nint test_equal( void* x, void* y ) {\n  return (x == y);\n}\n\nint test_lt( void* x, void* y ) {\n  return (x < y);\n}\n\nint equals_after_free()\n{\n  volatile int* x = malloc(sizeof(int));\n  *x = 12;\n  free((int*) x);\n  if( test_equal( (void*) x, (void*) x) ) { puts(\"EQ!\"); }\n  return 1;\n}\n\nint le_after_free()\n{\n  volatile char* x = malloc(32);\n  volatile char* y = x + 5;\n  free((void*) x);\n  if( test_lt( (void*) x, (void*) y ) ) { puts(\"LT!\"); }\n  return 1;\n}\n\nint le_different_allocs()\n{\n  volatile int* x = malloc(sizeof(int));\n  volatile int* y = malloc(sizeof(int));\n  *x = 12;\n  *y = 32;\n  if( test_lt( (void*) x, (void*) y ) ) { puts(\"LT!\"); }\n  return 1;\n}\n\n\/\/ Intentionally leak the address of a local variable\nint* leak_pointer()\n{\n  volatile int x;\n  volatile int* y = &x;\n  *y = 1;\n  return (int*) y; \/\/ <- leak a pointer to local variable\n}\n\nint read_after_stack_free()\n{\n  int * x = leak_pointer();\n  return *x; \/\/ <- error here, read an invald local variable pointer\n}\n\nint write_after_stack_free()\n{\n  int * x = leak_pointer();\n  *x = 12; \/\/ <- error here, write an invalid local varible pointer\n  return 1;\n}\n\nint free_after_stack_free()\n{\n  int * x = leak_pointer();\n  free(x); \/\/ <- error here, free an invalid local variable pointer\n  return 1;\n}\n\n\/\/ Wrap `free` in a function, so clang doesn't notice\n\/\/ and optimize away the bogus local free below.\nvoid subfn(void* x) {\n  free(x);\n}\n\nint free_local()\n{\n  volatile int x = 12;\n  subfn((int*) &x);  \/\/ <- error here, free a local variable\n  return 1;\n}\n\nint equals_after_stack_free()\n{\n  int * x = leak_pointer();\n  int * y = malloc(sizeof(int));\n  if( test_equal( x, y ) ) { puts(\"EQ!\"); }\n  return 1;\n}\n\nint lt_after_stack_free()\n{\n  int * x = leak_pointer();\n  int * y = leak_pointer();\n  if( test_lt( x, y ) ) { puts(\"LT!\"); }\n  return 1;\n}\n\nchar global_string[] = \"asdf\\n\";\nint free_global()\n{\n  char* x = global_string;\n  free(x); \/\/ <- error here, free a global variable\n  return 1;\n}\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nlet bad_pointer_no_biscuit nm =\n  do { print \"=======================================\";\n       print (str_concat \"Testing failure case: \" nm);\n       print \"\";\n       fails (llvm_verify m nm [] false\n         do { llvm_execute_func [];\n              llvm_return (llvm_term {{ 1:[32] }});\n            }\n         trivial);\n  };\n\nbad_pointer_no_biscuit \"read_after_free\";\nbad_pointer_no_biscuit \"write_after_free\";\nbad_pointer_no_biscuit \"double_free\";\nbad_pointer_no_biscuit \"equals_after_free\";\nbad_pointer_no_biscuit \"equals_null_after_free\";\nbad_pointer_no_biscuit \"le_after_free\";\nbad_pointer_no_biscuit \"le_different_allocs\";\n\nbad_pointer_no_biscuit \"read_after_stack_free\";\nbad_pointer_no_biscuit \"write_after_stack_free\";\nbad_pointer_no_biscuit \"free_after_stack_free\";\nbad_pointer_no_biscuit \"equals_after_stack_free\";\nbad_pointer_no_biscuit \"lt_after_stack_free\";\n\nbad_pointer_no_biscuit \"free_local\";\nbad_pointer_no_biscuit \"free_global\";\n\nprint \"\";\nprint \"============================================\";\nprint \"Success!\";\n```"}]}
{"filename":"saw-script\/intTests\/test0006\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated C or Java source files using the appropriate backend inferred from the presence of llvm_load_module or java_load_class. Define a let-bound specification named <function>_spec that uses symbolic inputs created with llvm_fresh_var or jvm_fresh_var for the exact functions or methods specified by their symbol names and signatures in the source files. Include minimal preconditions necessary for safe execution such as array bounds or non-zero divisors. Then verify the implementation against this specification using SAWScript commands without inline do blocks or solver references."},{"role":"assistant","content":"```saw\nimport \"..\/..\/deps\/cryptol-specs\/Primitive\/Keyless\/Hash\/MD5.md\";\n\nlet main = do {\n   print \"ref type\";\n   print_type {{ md5_ref }};\n   print \"\";\n\n   print \"ref type, checked\";\n   check_term {{ md5_ref }};\n   print \"\";\n\n   let thm1 = {{ md5_ref zero == [82, 231, 200, 108, 39, 210, 159, 253, 158, 75, 174, 116, 196, 18, 24, 165] }};\n   prove_print abc thm1;\n};\n```"}]}
{"filename":"saw-script\/intTests\/test1983\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the provided source files using llvm_load_module. Define let-bound specs for each target function by creating symbolic inputs with llvm_fresh_var, adding minimal preconditions for safety (e.g., array bounds), executing the function with llvm_execute_func, and returning the expected output. Reference exact function names and signatures from the source. Use let bindings like let <name>_spec = do { ... }; and verify each function with llvm_verify against its spec. Do not inline specs or mention solvers. The harness should directly reference the functions\/methods defined in the associated C source files."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet get_3_spec = do {\n    xs <- mir_fresh_var \"xs\" (mir_array 10 mir_i32);\n    mir_execute_func [mir_term xs];\n    mir_return (mir_elem_value (mir_term xs) 3);\n};\n\nget_3_ov <- mir_verify m \"test::get_3\" [] false get_3_spec z3;\n\nlet get_3_ref_spec = do {\n    xs <- mir_fresh_var \"xs\" (mir_array 10 mir_i32);\n    r <- mir_ref_of (mir_term xs);\n    mir_execute_func [r];\n    mir_return (mir_elem_ref r 3);\n};\n\nget_3_ref_ov <- mir_verify m \"test::get_3_ref\" [] false get_3_ref_spec z3;\n\nlet get_19_3_spec = do {\n    xss <- mir_fresh_var \"xss\" (mir_array 20 (mir_array 10 mir_i32));\n    mir_execute_func [mir_term xss];\n    mir_return (mir_elem_value (mir_elem_value (mir_term xss) 19) 3);\n};\n\nget_19_3_ov <- mir_verify m \"test::get_19_3\" [get_3_ov] false get_19_3_spec z3;\n\nlet get_19_3_ref_spec = do {\n    xss <- mir_fresh_var \"xss\" (mir_array 20 (mir_array 10 mir_i32));\n    r <- mir_ref_of (mir_term xss);\n    mir_execute_func [r];\n    mir_return (mir_elem_ref (mir_elem_ref r 19) 3);\n};\n\nget_19_3_ref_ov <- mir_verify m \"test::get_19_3_ref\" [get_3_ref_ov] false get_19_3_ref_spec z3;\n\nlet get_25_19_3_spec = do {\n    xsss <- mir_fresh_var \"xsss\" (mir_array 30 (mir_array 20 (mir_array 10 mir_i32)));\n    mir_execute_func [mir_term xsss];\n    mir_return (mir_elem_value (mir_elem_value (mir_elem_value (mir_term xsss) 25) 19) 3);\n};\n\nmir_verify m \"test::get_25_19_3\" [get_19_3_ov] false get_25_19_3_spec z3;\n\nlet get_25_19_3_ref_spec = do {\n    xsss <- mir_fresh_var \"xsss\" (mir_array 30 (mir_array 20 (mir_array 10 mir_i32)));\n    r <- mir_ref_of (mir_term xsss);\n    mir_execute_func [r];\n    mir_return (mir_elem_ref (mir_elem_ref (mir_elem_ref r 25) 19) 3);\n};\n\nmir_verify m \"test::get_25_19_3_ref\" [get_19_3_ref_ov] false get_25_19_3_ref_spec z3;\n\nlet get_static_2_spec = do {\n    mir_execute_func [];\n    mir_return (mir_elem_value (mir_static_initializer \"test::ARRAY\") 2);\n};\n\nmir_verify m \"test::get_static_2\" [] false get_static_2_spec z3;\n\nlet get_static_2_ref_spec = do {\n    mir_execute_func [];\n    mir_return (mir_elem_ref (mir_static \"test::ARRAY\") 2);\n};\n\nmir_verify m \"test::get_static_2_ref\" [] false get_static_2_ref_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test0019_jvm_switch_statement\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java classes FFS and Id, extracts the static methods ffs_imp and id_imp respectively, and defines let-bound specs named ffs_imp_spec and id_imp_spec. Each spec should use jvm_fresh_var to create a symbolic 32-bit integer input, call the corresponding method with this input, and assert equivalence against a reference function or expected behavior. Include minimal preconditions if necessary to ensure method termination or safety. Then prove these specs using the appropriate JVM backend commands.\n\n# Source code:\nFFS.java\n```java\npublic class FFS {\n  public static void main(String[] args) {\n    System.out.println(ffs_imp(4));\n  }\n\n  \/\/ Crash.\n  static int ffs_imp(int i) {\n    switch (((~i) + 1) ^ i) {\n    case 0xfffffffe: return 1;\n    case 0xfffffffc: return 2;\n    case 0xfffffff8: return 3;\n    case 0xfffffff0: return 4;\n    case 0xffffffe0: return 5;\n    case 0xffffffc0: return 6;\n    case 0xffffff80: return 7;\n    case 0xffffff00: return 8;\n    case 0xfffffe00: return 9;\n    case 0xfffffc00: return 10;\n    case 0xfffff800: return 11;\n    case 0xfffff000: return 12;\n    case 0xffffe000: return 13;\n    case 0xffffc000: return 14;\n    case 0xffff8000: return 15;\n    case 0xffff0000: return 16;\n    case 0xfffe0000: return 17;\n    case 0xfffc0000: return 18;\n    case 0xfff80000: return 19;\n    case 0xfff00000: return 20;\n    case 0xffe00000: return 21;\n    case 0xffc00000: return 22;\n    case 0xff800000: return 23;\n    case 0xff000000: return 24;\n    case 0xfe000000: return 25;\n    case 0xfc000000: return 26;\n    case 0xf8000000: return 27;\n    case 0xf0000000: return 28;\n    case 0xe0000000: return 29;\n    case 0xc0000000: return 30;\n    case 0x80000000: return 31;\n    case 0x00000000: return i == 0 ? 0 : 32;\n    }\n    return 0; \/\/ Unreachable.\n  }\n}\n\n```\nId.java\n```java\n\/\/ Test fall-through switch.\npublic class Id {\n  static int id_imp(int x) {\n    int z1 = 0, z2 = 0, z3 = 0;\n    switch (x) {\n    case 0: case 2: case 4: case 8: case 16: case 32: case 64:\n      z1 = x;\n      break;\n    case 1: case 3: case 5: case 9: case 17: case 33: case 65:\n      z2 = x;\n      break;\n    default:\n      z3 = x;\n      break;\n    }\n    return z1 + z2 + z3;\n  }\n}\n\n```"},{"role":"assistant","content":"```saw\nimport \"..\/..\/doc\/llvm-java-verification-with-saw\/code\/ffs.cry\";\nFFS <- java_load_class \"FFS\";\njava_ffs_imp <- jvm_extract FFS \"ffs_imp\";\nprove_print abc {{ \\x -> java_ffs_imp x == ffs_ref x }};\n\nId <- java_load_class \"Id\";\njava_id_imp <- jvm_extract Id \"id_imp\";\nprove_print abc {{ \\x -> java_id_imp x == x }};\n```"}]}
{"filename":"saw-script\/intTests\/test1977\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the file test.linked-mir.json and defines let-bound specs for the functions test::raw_assign and test::raw_swap. For each spec, allocate symbolic mutable pointers to 32-bit integers using llvm_fresh_var and llvm_alloc_raw_ptr_mut, set up initial memory points-to conditions, execute the target function with these pointers as arguments, and verify the postconditions that the memory locations contain the expected values after execution. Use llvm_verify to verify test::raw_assign first, then verify test::raw_swap with the verification obligation from raw_assign as a prerequisite. Do not inline specs; bind them with let. Use minimal preconditions to ensure safety and termination."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet raw_assign_spec = do {\n    src <- mir_alloc_raw_ptr_const mir_i32;\n    val <- mir_fresh_var \"val\" mir_i32;\n    mir_points_to src (mir_term val);\n    dest <- mir_alloc_raw_ptr_mut mir_i32;\n    mir_execute_func [src, dest];\n    mir_points_to dest (mir_term val);\n};\n\nraw_assign_ov <- mir_verify m \"test::raw_assign\" [] false raw_assign_spec z3;\n\nlet raw_swap_spec = do {\n    x <- mir_alloc_raw_ptr_mut mir_i32;\n    x_val <- mir_fresh_var \"x_val\" mir_i32;\n    mir_points_to x (mir_term x_val);\n    y <- mir_alloc_raw_ptr_mut mir_i32;\n    y_val <- mir_fresh_var \"y_val\" mir_i32;\n    mir_points_to y (mir_term y_val);\n    mir_execute_func [x, y];\n    mir_points_to x (mir_term y_val);\n    mir_points_to y (mir_term x_val);\n};\n\nmir_verify m \"test::raw_swap\" [raw_assign_ov] false raw_swap_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_cvc5\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated C source module using llvm_load_module, then defines a let-bound specification named add_mul_lemma_spec that uses llvm_fresh_var to create symbolic integer inputs m, n, p, q with preconditions 0 <= m, n, p, q, n < q, and p < m, and asserts that m * n + p < m * q holds. The harness should then prove this specification by invoking the appropriate llvm_verify or prove_print command referencing the exact function symbols from the source as needed."},{"role":"assistant","content":"```saw\nlet\n{{\nadd_mul_lemma : Integer -> Integer -> Integer -> Integer -> Bit\nadd_mul_lemma m n p q =\n  (0 <= m \/\\ 0 <= n \/\\ 0 <= p \/\\ 0 <= q \/\\ n < q \/\\ p < m) ==>\n  (m * n + p < m * q)\n}};\n\nprove_print (w4_unint_cvc5 []) {{ add_mul_lemma }};\n```"}]}
{"filename":"saw-script\/intTests\/test0055\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that uses llvm_load_module to load the associated C source files. Define a let-bound spec named file_read_spec that symbolically models the function reading a file into a byte array, using llvm_fresh_var for inputs such as the file name pointer and length. Include minimal preconditions ensuring the file name pointer is valid and the length is non-negative. Use llvm_verify to prove that the function correctly reads the contents of files matching the test cases \"empty\", \"nonempty\", and \"noise\" as specified by the byte sequences in the SAW file. Reference the exact function name and signature from the C source for reading files, and ensure the spec checks the output byte array against the expected contents."},{"role":"assistant","content":"```saw\n\/\/ read an empty file into byte list\nempty <- read_bytes \"empty\";\nlet actually_empty = {{ empty == [] }};\nprove_print z3 actually_empty;\n\n\/\/ non-empty file; should be ASCII rep. of \"Hello, world!\" (13 bytes)\nnonempty <- read_bytes \"nonempty\";\nlet correct_seq = {{ nonempty == \"Hello, world!\" }};\nprove_print z3 correct_seq;\n\n\/\/ non-empty, but full of 255 bytes of random noise\n\/\/ random data generated at https:\/\/random.org\/bytes\/\nnoise <- read_bytes \"noise\";\nlet length_correct = {{ length noise == 255 }};\nprove_print z3 length_correct;\n\n\/\/ pathological case: empty file name\nfails (read_bytes \"\");\n```"}]}
{"filename":"saw-script\/intTests\/test_smt_array_load_concrete_size\/Mix.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally describes the behavior of the 'mix' function in the given module. The specification should capture how 'mix' combines the input ByteArray 'block', the index 'n', and the data array to produce the resulting ByteArray. Include properties that verify correct copying and updating of array segments as per the function definition."},{"role":"assistant","content":"```cryptol\nmodule Mix where\n\nimport Array\n\ntype ByteArray = Array[64][8]\n\nmix : {l} (width l <= 64) => ByteArray -> [64] -> [l][8] -> ByteArray\nmix block n data = arrayCopy block n (arrayRangeUpdate (arrayConstant 0) 0 data) 0 `(l)\n```"}]}
{"filename":"saw-script\/intTests\/test_smt_array_load_concrete_size\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function 'mix' defined in 'test.c' with signature 'int mix(uint8_t block[128], uint32_t n, uint8_t *data, size_t len)'. Define a let-bound spec 'mix_spec' that uses symbolic inputs for 'block', 'n', 'data', and 'len'. Add a precondition ensuring 'n < 128' and that array accesses are within bounds. The spec should allocate and initialize symbolic memory for 'block' and 'data', execute 'mix' with these inputs, and assert postconditions reflecting the behavior of 'mix' (copying up to 'len' bytes or '128 - n' bytes into 'block + n'). Use 'llvm_fresh_var' and related LLVM symbolic functions to model inputs and memory, and verify the function against 'mix_spec'.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n#include <string.h>\n\nint mix(uint8_t block[128], uint32_t n, uint8_t *data, size_t len) {\n  size_t left = 128 - n;\n\n  if (len < left) {\n    memcpy(block + n, data, len);\n  } else {\n    memcpy(block + n, data, left);\n  }\n  return 1;\n}\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nimport \"Mix.cry\";\nlet arrayRangeEq = parse_core \"arrayRangeEq 64 (Vec 8 Bool)\";\n\nm <- llvm_load_module \"test.bc\";\n\nlet i8 = llvm_int 8;\nlet i32 = llvm_int 32;\n\nlet alloc_init_readonly ty v = do {\n  p <- llvm_alloc_readonly ty;\n  llvm_points_to p v;\n  return p;\n};\n\nlet ptr_to_fresh_readonly n ty = do {\n  x <- llvm_fresh_var n ty;\n  p <- alloc_init_readonly ty (llvm_term x);\n  return (x, p);\n};\n\nlet mix_spec len res_block_len range_eq_len = do {\n  block <- llvm_fresh_cryptol_var \"block\" {| ByteArray |};\n  block_ptr <- llvm_symbolic_alloc false 1 {{ 128:[64] }};\n  llvm_points_to_array_prefix block_ptr block {{ 128:[64] }};\n\n  (data, data_ptr) <- ptr_to_fresh_readonly \"data\" (llvm_array len i8);\n\n  n <- llvm_fresh_var \"n\" i32;\n  llvm_precond({{ n < 128 }});\n\n  llvm_execute_func [block_ptr, (llvm_term n), data_ptr, (llvm_term {{ `len : [64] }})];\n\n  let res = {{ mix block (0 # n) data }};\n  res_block <- llvm_fresh_cryptol_var \"res_block\" {| ByteArray |};\n  llvm_points_to_array_prefix block_ptr res_block {{ `res_block_len:[64] }};\n  llvm_postcond {{ arrayRangeEq res_block 0 res 0 `range_eq_len }};\n\n  llvm_return (llvm_term {{ 1 : [32]}});\n};\n\nllvm_verify m \"mix\"\n  []\n  true\n  (mix_spec 1 128 128)\n  (do {\n    w4_unint_z3 [];\n  });\n\nllvm_verify m \"mix\"\n  []\n  true\n  (mix_spec 1 0 0)\n  (do {\n    w4_unint_z3 [];\n  });\n\nfails (llvm_verify m \"mix\"\n  []\n  true\n  (mix_spec 1 129 0)\n  (do {\n    w4_unint_z3 [];\n  }));\n```"}]}
{"filename":"saw-script\/intTests\/test2162\/test1.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test2162\/test1.saw, defines a let-bound specification named f_spec that symbolically calls the function 'f' with a fresh LLVM variable input, and similarly defines g_spec and h_spec for functions 'g' and 'h' respectively. Each spec should use llvm_fresh_var for inputs, include minimal preconditions if needed for safety, and verify that the functions return the input value unchanged. Then write a top-level verification function that invokes these specs and checks their correctness using llvm_verify."},{"role":"assistant","content":"```saw\n\/\/ Create three monadic functions, one polymorphic in its monad and\n\/\/ the other two bound to TopLevel and LLVMSetup respectively.\nlet f x = return x;\nlet g x = do { disable_crucible_profiling; return x; };\nlet h x = do { llvm_assert {{ True }}; return x; };\n\n\/\/ We should be able to run f and g at the top level, but not h.\na0 <- f 3;\na1 <- g 3;\n\/\/ We should be able to use b0 and b1 together in the same function.\nlet foo () = do {\n   b0 <- f 3;\n   b1 <- g 3;\n   return 0;\n};\n\n\/\/ We should also be able to use b0 and b2 together in the same function.\nlet bar () = do {\n   b0 <- f 3;\n   b2 <- h 3;\n   return 0;\n};\n```"}]}
{"filename":"saw-script\/intTests\/test_yosys_sequential_known_cycles\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Yosys sequential module from 'test.json' as shown, extracts the sequential circuit with 10 cycles, and defines a let-bound spec named 'seqgen_spec'. The spec should use symbolic Bit inputs for signals c, g, and x, construct the input streams clk, reset, C, G, and P as in the example, and verify that the output signal S at index 0 equals 1 after 10 cycles. Use yosys_import_sequential and yosys_extract_sequential functions accordingly, and ensure the spec is let-bound before being passed to any verification commands."},{"role":"assistant","content":"```saw\nenable_experimental;\nm <- yosys_import_sequential \"seqgen\" \"test.json\";\nt <- yosys_extract_sequential m 10;\n\nsat_print w4 {{ \\(c : Bit) (g : Bit) (x : Bit) ->\n  (t {\n    clk = repeat 1,\n    reset = [1] # zero,\n    C = [0, 1, 1, 1, [c]] # zero,\n    G = [0, 0, 0, 0, [g]] # repeat 1,\n    P = [0, 1, 1, 1, [x]] # zero\n  }).S ! 0 == 1\n}};\n```"}]}
{"filename":"saw-script\/intTests\/test0042_invariant_2\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from test.bc and defines two let-bound specs: one named inv_spec that symbolically allocates a pointer to a 64-bit integer, calls the function __breakpoint__inv with this pointer, and returns the incremented value of the pointed integer; and another named zero_inc_spec that symbolically creates a 64-bit integer input x, calls zero_inc with x, and asserts that the return value is greater than zero. Use llvm_fresh_var for symbolic variables and llvm_points_to for pointer initialization. Then verify __breakpoint__inv against inv_spec and zero_inc against zero_inc_spec, passing the inv verification result as a prerequisite to zero_inc verification.\n\n# Source code:\ntest.c\n```C\n#include <stdlib.h>\n\nextern size_t __breakpoint__inv(size_t*);\n\nsize_t zero_inc(size_t x) {\n  if (x == 0) {\n    __breakpoint__inv(&x);\n    ++x;\n  }\n  return x;\n}\n\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nlet ptr_to_fresh n ty = do {\n  p <- llvm_alloc ty;\n  x <- llvm_fresh_var n ty;\n  llvm_points_to p (llvm_term x);\n  return (p, x);\n};\n\nlet zero_inc_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 64);\n  llvm_execute_func [llvm_term x];\n  r <- llvm_fresh_var \"r\" (llvm_int 64);\n  llvm_postcond {{ r > 0 }};\n  llvm_return (llvm_term {{ r }});\n};\n\nlet inv_spec = do {\n  (px, x) <- ptr_to_fresh \"x\" (llvm_int 64);\n  llvm_execute_func [px];\n  llvm_return (llvm_term {{ x + 1 }});\n};\n\ninv <- llvm_verify m \"__breakpoint__inv#zero_inc\" [] false inv_spec abc;\nllvm_verify m \"zero_inc\" [inv] false zero_inc_spec abc;\n```"}]}
{"filename":"saw-script\/intTests\/test0007\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class containing the method java_md5, defines a let-bound spec named java_md5_spec using jvm_fresh_var to create symbolic inputs, adds minimal preconditions for safety, and verifies that invoking the java_md5 method with these inputs satisfies the expected property as indicated by the AIG term java_md5 0 == 0x52e7c86c27d29ffd9e4bae74c41218a5. The harness should use jvm_load_class to load the class, reference the exact method signature, and structure the spec as let java_md5_spec = do { ... }; without inline do blocks or comments."},{"role":"assistant","content":"```saw\nlet main = do {\n   java_md5 <- read_aig \"..\/support\/JavaMD5.aig\";\n\n   print \"AIG type\";\n   print_type java_md5;\n   print \"\";\n   print \"AIG type, checked\";\n   check_term java_md5;\n\n   let thm1 = {{ java_md5 0 == 0x52e7c86c27d29ffd9e4bae74c41218a5 }};\n   prove_print abc thm1;\n};\n```"}]}
{"filename":"saw-script\/intTests\/test0669\/test1.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test0669\/test1.saw, then define a let-bound specification named f_spec that symbolically inputs two 64-bit integers, calls the LLVM function 'f' with these inputs, and returns the pair of outputs. Similarly, define g_spec that takes two pairs of 64-bit integers symbolically, calls the LLVM function 'g' with these inputs, and returns the boolean result. Use llvm_fresh_var for symbolic inputs and include any minimal preconditions necessary for safety. Finally, prove that for all inputs, g called with the output of f satisfies the expected property, referencing the exact LLVM function symbols."},{"role":"assistant","content":"```saw\nlet {{ f (x : Integer, y : Integer) = (x + 1, y + 1) }};\nlet {{ g (a : Integer, b : Integer) (c, d) = (a < c) && (b < d) }};\n\nprove_print (quickcheck 100) {{ \\x -> g x (f x) }};\nprove_print (quickcheck 100) {{ \\(a, b) -> g (a, b) (a + 2, b + 2) }};\n```"}]}
{"filename":"saw-script\/intTests\/test0000\/mutRecTest.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the three Fibonacci number implementations\u2014streamFibs, streamFibsAlt, and recFibs2\u2014produce equivalent outputs for all valid inputs. Include properties that check equality of outputs for each input index within the domain [0..7]."},{"role":"assistant","content":"```cryptol\n\/\/ Test cases for mutually-recursive cryptol definitions\n\n\/\/ Classic stream-equation version of the Fibonocci numbers\n\/\/ broken out into two mutually recursive streams to test\n\/\/ mutual recursion translation into SAWCore\nstreamFibs : [8] -> [32]\nstreamFibs x = fibs0@x\n   where fibs0 = [0]#fibs1\n         fibs1 = [1]#[ a + b | a <- fibs0\n                             | b <- fibs1\n                     ]\n\n\/\/ Single-stream Fibonocci numbers\nstreamFibsAlt : [8] -> [32]\nstreamFibsAlt x = fibs@x\n   where fibs = [0,1]#[ a + b | a <- fibs\n                              | b <- drop`{1} fibs\n                      ]\n\n\/\/ recursive reference implementation of the Fibonocci numbers\nrecFibs : [8] -> [32]\nrecFibs n = if n > 1  then recFibs (n-1) + recFibs (n-2) else zx n\n\n\/\/ zero extend\nzx : {a, b} (fin a, fin b) => [b] -> [a+b]\nzx m = zero#m\n\nrecFibs2 : [8] -> [32]\nrecFibs2 n =\n  if n == 0 then 0\n   | n == 1 then 1\n   else recFibs2 (n-1) + recFibs2 (n-2)\n```"}]}
{"filename":"saw-script\/intTests\/test0070_llvm_alloc_sym_init\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the LLVM backend that loads the module from test.bc and verifies the functions f, test_f_calloc, and test_f_malloc defined in test.c. Define let-bound specs named f_spec, test_f_calloc_spec, and test_f_malloc_spec. For f_spec, allocate a symbolic initialized 32-bit integer pointer and execute f with it, returning a fresh 32-bit symbolic variable. For test_f_calloc_spec and test_f_malloc_spec, execute the respective functions with no arguments and return a fresh 32-bit symbolic variable. Include minimal preconditions to ensure safety and termination. Use llvm_fresh_var and llvm_alloc_sym_init as appropriate. Verify f first, then use its override when verifying the other two functions. Include checks for allocation initialization enabled and disabled as in the example.\n\n# Source code:\ntest.c\n```C\n#include <stdlib.h>\n\nint f(int *x)\n{\n  return *x;\n}\n\nint test_f_calloc()\n{\n  int *x = (int *) calloc(1, sizeof(int));\n  return f(x);\n}\n\nint test_f_malloc()\n{\n  int *x = (int *) malloc(sizeof(int));\n  return f(x);\n}\n\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet f_spec = do {\n  x_ptr <- llvm_alloc_sym_init (llvm_int 32);\n  llvm_execute_func [x_ptr];\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_return (llvm_term x);\n};\n\nlet test_spec = do {\n  llvm_execute_func [];\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_return (llvm_term x);\n};\n\nf_ov <- llvm_verify m \"f\" [] false f_spec trivial;\nllvm_verify m \"test_f_calloc\" [f_ov] false test_spec trivial;\nfails (llvm_verify m \"test_f_malloc\" [f_ov] false test_spec trivial);\ndisable_alloc_sym_init_check;\nllvm_verify m \"test_f_malloc\" [f_ov] false test_spec trivial;\nenable_alloc_sym_init_check;\nfails (llvm_verify m \"test_f_malloc\" [f_ov] false test_spec trivial);\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_verify_slices\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given path and defines a let-bound specification named f_spec. The spec should allocate a symbolic array of five 32-bit unsigned integers, initialize it with values 1 through 5, and then execute the function test::f with a slice of this array as input. The spec should return the expected 32-bit integer result. Use llvm_fresh_var and llvm_alloc as needed, and include minimal preconditions to ensure safety such as valid slice bounds. Finally, invoke mir_verify on the loaded module with the symbol \"test::f\" and the defined spec."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet oneThroughFive = mir_term {{ [1, 2, 3, 4, 5] : [5][32] }};\n\nlet f_spec_1 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_value a];\n\n  mir_return (mir_term {{ 3 : [32] }});\n};\n\nlet f_spec_2 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_range_value a 1 3];\n\n  mir_return (mir_term {{ 5 : [32] }});\n};\n\n\/\/ mir_slice_value must take an array reference as an argument.\n\/\/ Passing a bare array constitutes a type error.\nlet f_fail_spec_1 = do {\n  let arr = mir_array_value mir_u32 [mir_term {{ 1 : [32] }}];\n  mir_execute_func [mir_slice_value arr];\n\n  mir_return (mir_term {{ 0 : [32] }});\n};\n\n\/\/ The end value of the range given to mir_slice_range_value must not\n\/\/ exceed the length of the slice.\nlet f_fail_spec_2 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_range_value a 0 6];\n\n  mir_return (mir_term {{ 3 : [32] }});\n};\n\n\/\/ The start value of the range given to mir_slice_range_value must not\n\/\/ exceed the end value.\nlet f_fail_spec_3 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_range_value a 6 5];\n\n  mir_return (mir_term {{ 0 : [32] }});\n};\n\n\/\/ Indexing into a length-0 slice is disallowed.\nlet f_fail_spec_4 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_range_value a 0 0];\n\n  mir_return (mir_term {{ 0 : [32] }});\n};\n\n\/\/ f requires a slice of length at least two.\nlet f_fail_spec_5 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a oneThroughFive;\n\n  mir_execute_func [mir_slice_range_value a 0 1];\n\n  mir_return (mir_term {{ 0 : [32] }});\n};\n\n\/\/ mir_alloc cannot be used to allocate slice references.\nlet f_fail_spec_6 = do {\n  s <- mir_alloc (mir_slice mir_u32);\n\n  mir_execute_func [s];\n\n  mir_return (mir_term {{ 0 : [32] }});\n};\n\n\/\/ mir_alloc cannot be used to allocate str references.\nlet g_fail_spec = do {\n  s <- mir_alloc mir_str;\n\n  mir_execute_func [s];\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::f\" [] false f_spec_1 z3;\nmir_verify m \"test::f\" [] false f_spec_2 z3;\n\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_1 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_2 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_3 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_4 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_5 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_6 z3\n);\nfails (\n  mir_verify m \"test::g\" [] false g_fail_spec z3\n);\n```"}]}
{"filename":"saw-script\/intTests\/test_fold_rewrite_proof\/tupletest.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the functions foldFunction and foldFunction'. Specifically, write a property that proves foldFunction' is the inverse of foldFunction when applied sequentially with the same parameters y and z, as suggested by the property foldFunctionInverse in the code."},{"role":"assistant","content":"```cryptol\nmodule tupletest where\n\nfoldFunction : [8] -> [16] -> [16] -> [8]\nfoldFunction x y z = output.0\n  where\n    output = foldl fnc (x, y, z) [0 .. 15]\n\nfnc : ([8], [16], [16]) -> [4] -> ([8], [16], [16])\nfnc (x, y, z) i = returnTup\n  where\n    returnTup = (x ^ take y' ^ take z', y', z')\n    y' = y <<< i\n    z' = z >>> i\n\nfoldFunction' : [8] -> [16] -> [16] -> [8]\nfoldFunction' x y z = output.0\n  where\n    output = foldl fnc' (x, y, z) [15, 14 .. 0]\n\nfnc' : ([8], [16], [16]) -> [4] -> ([8], [16], [16])\nfnc' (x, y, z) i = returnTup\n  where\n    returnTup = (x ^ take y ^ take z, y', z')\n    y' = y >>> i\n    z' = z <<< i\n\nproperty foldFunctionInverse x y z =\n    foldFunction' (foldFunction x y z) y z == x\n```"}]}
{"filename":"saw-script\/intTests\/test_fold_rewrite_proof\/tupletest.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'saw-script\/intTests\/test_fold_rewrite_proof\/tupletest.saw', defines a let-bound specification named 'tupletest_spec' which uses llvm_fresh_var to create symbolic inputs matching the exact function signatures found in the associated source files, calls the target LLVM function(s) by their exact symbol names, and includes minimal preconditions for safety such as valid memory bounds or non-zero divisors if applicable. The harness should then verify the function behavior against the specification without inline do blocks, solvers references, or comments."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet use_lemmas lemmas =\n    simplify (addsimps lemmas\n              (add_prelude_eqs [\"foldl_cons\",\"foldl_nil\",\"head_gen\",\"tail_gen\"] (cryptol_ss())));\n\nlet proveit p script =\n  do {\n    print (str_concat \"Proving \" (show_term p));\n    time (prove_print script p);\n  };\n\nimport \"tupletest.cry\";\n\nfnc_lemma <- proveit {{ \\x y z i -> (fnc' (fnc (x, y, z) i) i).0 == x }} z3;\n\nproveit {{ foldFunctionInverse }} do {\n    unfolding [ \"foldFunctionInverse\"\n              , \"foldFunction\"\n              , \"foldFunction'\"\n              ];\n    goal_normalize [\"fnc\", \"fnc'\"];\n    simplify (add_prelude_eqs [\"foldl_cons\",\"foldl_nil\",\n                               \"head_gen\",\"tail_gen\"] (cryptol_ss()));\n    z3;\n};\n```"}]}
{"filename":"saw-script\/intTests\/test_ffi_verify_salsa\/salsa.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM backend that loads the salsa.bc module and verifies the 'cipher' function with signature void cipher(size_t a, size_t w, uint8_t * key, uint8_t * nonce, uint8_t * inbuf, uint8_t * outbuf). Define a let-bound spec named cipher_spec that uses llvm_fresh_var to create symbolic inputs for a, w, key, nonce, inbuf, and outbuf. Add minimal preconditions to ensure safety, such as valid pointer bounds and non-negative sizes. Use llvm_ffi_setup to set up the specification and call llvm_verify with the loaded module and the cipher_spec. Do not inline the spec in the llvm_verify call.\n\n# Source code:\nsalsa.c\n```C\n\/*\nsalsa20-ref.c version 20051118\nD. J. Bernstein\nPublic domain.\n\nModified to add `cipher` function.\n*\/\n\n#include <stddef.h>\n#include <stdint.h>\n#include \"ecrypt-sync.h\"\n\nvoid cipher(size_t a, size_t w, uint8_t * key, uint8_t * nonce, uint8_t * inbuf, uint8_t * outbuf) {\n  ECRYPT_ctx x;\n\n  ECRYPT_keysetup(&x, key, a << 7, 0);\n  ECRYPT_ivsetup(&x, nonce);\n  ECRYPT_encrypt_bytes(&x, inbuf, outbuf, w);\n}\n\n#define ROTATE(v,c) (ROTL32(v,c))\n#define XOR(v,w) ((v) ^ (w))\n#define PLUS(v,w) (U32V((v) + (w)))\n#define PLUSONE(v) (PLUS((v),1))\n\nstatic void salsa20_wordtobyte(u8 output[64],const u32 input[16])\n{\n  u32 x[16];\n  int i;\n\n  for (i = 0;i < 16;++i) x[i] = input[i];\n  for (i = 20;i > 0;i -= 2) {\n    x[ 4] = XOR(x[ 4],ROTATE(PLUS(x[ 0],x[12]), 7));\n    x[ 8] = XOR(x[ 8],ROTATE(PLUS(x[ 4],x[ 0]), 9));\n    x[12] = XOR(x[12],ROTATE(PLUS(x[ 8],x[ 4]),13));\n    x[ 0] = XOR(x[ 0],ROTATE(PLUS(x[12],x[ 8]),18));\n    x[ 9] = XOR(x[ 9],ROTATE(PLUS(x[ 5],x[ 1]), 7));\n    x[13] = XOR(x[13],ROTATE(PLUS(x[ 9],x[ 5]), 9));\n    x[ 1] = XOR(x[ 1],ROTATE(PLUS(x[13],x[ 9]),13));\n    x[ 5] = XOR(x[ 5],ROTATE(PLUS(x[ 1],x[13]),18));\n    x[14] = XOR(x[14],ROTATE(PLUS(x[10],x[ 6]), 7));\n    x[ 2] = XOR(x[ 2],ROTATE(PLUS(x[14],x[10]), 9));\n    x[ 6] = XOR(x[ 6],ROTATE(PLUS(x[ 2],x[14]),13));\n    x[10] = XOR(x[10],ROTATE(PLUS(x[ 6],x[ 2]),18));\n    x[ 3] = XOR(x[ 3],ROTATE(PLUS(x[15],x[11]), 7));\n    x[ 7] = XOR(x[ 7],ROTATE(PLUS(x[ 3],x[15]), 9));\n    x[11] = XOR(x[11],ROTATE(PLUS(x[ 7],x[ 3]),13));\n    x[15] = XOR(x[15],ROTATE(PLUS(x[11],x[ 7]),18));\n    x[ 1] = XOR(x[ 1],ROTATE(PLUS(x[ 0],x[ 3]), 7));\n    x[ 2] = XOR(x[ 2],ROTATE(PLUS(x[ 1],x[ 0]), 9));\n    x[ 3] = XOR(x[ 3],ROTATE(PLUS(x[ 2],x[ 1]),13));\n    x[ 0] = XOR(x[ 0],ROTATE(PLUS(x[ 3],x[ 2]),18));\n    x[ 6] = XOR(x[ 6],ROTATE(PLUS(x[ 5],x[ 4]), 7));\n    x[ 7] = XOR(x[ 7],ROTATE(PLUS(x[ 6],x[ 5]), 9));\n    x[ 4] = XOR(x[ 4],ROTATE(PLUS(x[ 7],x[ 6]),13));\n    x[ 5] = XOR(x[ 5],ROTATE(PLUS(x[ 4],x[ 7]),18));\n    x[11] = XOR(x[11],ROTATE(PLUS(x[10],x[ 9]), 7));\n    x[ 8] = XOR(x[ 8],ROTATE(PLUS(x[11],x[10]), 9));\n    x[ 9] = XOR(x[ 9],ROTATE(PLUS(x[ 8],x[11]),13));\n    x[10] = XOR(x[10],ROTATE(PLUS(x[ 9],x[ 8]),18));\n    x[12] = XOR(x[12],ROTATE(PLUS(x[15],x[14]), 7));\n    x[13] = XOR(x[13],ROTATE(PLUS(x[12],x[15]), 9));\n    x[14] = XOR(x[14],ROTATE(PLUS(x[13],x[12]),13));\n    x[15] = XOR(x[15],ROTATE(PLUS(x[14],x[13]),18));\n  }\n  for (i = 0;i < 16;++i) x[i] = PLUS(x[i],input[i]);\n  for (i = 0;i < 16;++i) U32TO8_LITTLE(output + 4 * i,x[i]);\n}\n\nvoid ECRYPT_init(void)\n{\n  return;\n}\n\nstatic const char sigma[16] = \"expand 32-byte k\";\nstatic const char tau[16] = \"expand 16-byte k\";\n\nvoid ECRYPT_keysetup(ECRYPT_ctx *x,const u8 *k,u32 kbits,u32 ivbits)\n{\n  const char *constants;\n\n  x->input[1] = U8TO32_LITTLE(k + 0);\n  x->input[2] = U8TO32_LITTLE(k + 4);\n  x->input[3] = U8TO32_LITTLE(k + 8);\n  x->input[4] = U8TO32_LITTLE(k + 12);\n  if (kbits == 256) { \/* recommended *\/\n    k += 16;\n    constants = sigma;\n  } else { \/* kbits == 128 *\/\n    constants = tau;\n  }\n  x->input[11] = U8TO32_LITTLE(k + 0);\n  x->input[12] = U8TO32_LITTLE(k + 4);\n  x->input[13] = U8TO32_LITTLE(k + 8);\n  x->input[14] = U8TO32_LITTLE(k + 12);\n  x->input[0] = U8TO32_LITTLE(constants + 0);\n  x->input[5] = U8TO32_LITTLE(constants + 4);\n  x->input[10] = U8TO32_LITTLE(constants + 8);\n  x->input[15] = U8TO32_LITTLE(constants + 12);\n}\n\nvoid ECRYPT_ivsetup(ECRYPT_ctx *x,const u8 *iv)\n{\n  x->input[6] = U8TO32_LITTLE(iv + 0);\n  x->input[7] = U8TO32_LITTLE(iv + 4);\n  x->input[8] = 0;\n  x->input[9] = 0;\n}\n\nvoid ECRYPT_encrypt_bytes(ECRYPT_ctx *x,const u8 *m,u8 *c,u32 bytes)\n{\n  u8 output[64];\n  int i;\n\n  if (!bytes) return;\n  for (;;) {\n    salsa20_wordtobyte(output,x->input);\n    x->input[8] = PLUSONE(x->input[8]);\n    if (!x->input[8]) {\n      x->input[9] = PLUSONE(x->input[9]);\n      \/* stopping at 2^70 bytes per nonce is user's responsibility *\/\n    }\n    if (bytes <= 64) {\n      for (i = 0;i < bytes;++i) c[i] = m[i] ^ output[i];\n      return;\n    }\n    for (i = 0;i < 64;++i) c[i] = m[i] ^ output[i];\n    bytes -= 64;\n    c += 64;\n    m += 64;\n  }\n}\n\nvoid ECRYPT_decrypt_bytes(ECRYPT_ctx *x,const u8 *c,u8 *m,u32 bytes)\n{\n  ECRYPT_encrypt_bytes(x,c,m,bytes);\n}\n\nvoid ECRYPT_keystream_bytes(ECRYPT_ctx *x,u8 *stream,u32 bytes)\n{\n  u32 i;\n  for (i = 0;i < bytes;++i) stream[i] = 0;\n  ECRYPT_encrypt_bytes(x,stream,stream,bytes);\n}\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nimport \"salsa.cry\";\n\nlet cipher_setup (a : Int) (w : Int) = llvm_ffi_setup {{ cipher`{a, w} }};\n\nm <- llvm_load_module \"salsa.bc\";\nfor [1, 2] (\\a ->\n  for [1, 2, 63, 64, 65] (\\w ->\n    llvm_verify m \"cipher\" [] false (cipher_setup a w) z3));\n```"}]}
{"filename":"saw-script\/intTests\/test_ffi_verify_salsa\/salsa.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the Salsa20_encrypt function used in the 'cipher' foreign function. Then, create a SAWScript verification script that verifies the correctness of the 'cipher' implementation against this Cryptol specification."},{"role":"assistant","content":"```cryptol\nimport Primitive::Symmetric::Cipher::Stream::Salsa20 (Salsa20_encrypt)\n\nforeign cipher : {a, w} (a >= 1, 2 >= a, w <= 2^^70) => [16*a][8] -> [8][8] -> [w][8] -> [w][8]\ncipher = Salsa20_encrypt\n```"}]}
{"filename":"saw-script\/intTests\/test0054\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated LLVM module using llvm_load_module, then defines a let-bound specification named <function_name>_spec where <function_name> is the exact C function symbol to verify. Use llvm_fresh_var to create symbolic 32-bit integer inputs corresponding to the function's parameters, adding minimal preconditions to ensure safety (e.g., non-zero divisors, valid array indices). Call the function symbol from the LLVM module with these symbolic inputs and specify expected properties or postconditions to verify. The harness should not include inline do blocks but use let-bound specs, and should not reference solvers explicitly."},{"role":"assistant","content":"```saw\n\/\/ construct some fresh symbolic variables to play with\nx <- fresh_symbolic \"x\" {| [32] |};\ny <- fresh_symbolic \"y\" {| [32] |};\n\nlet t = {{ x + y }};\n\n\/\/ various abstractions over `t` that should be operationally equivalent\nlet f1 = abstract_symbolic t;\nlet f2 = lambda y (lambda x t);\nlet f3 = lambdas [y, x] t;\n\n\/\/ degenerate case of `lambdas`\nlet f4 = lambdas [] t;\n\nlet thm1 = {{ \\z w -> f1 z w == f2 z w}};\nlet thm2 = {{ \\z w -> f2 z w == f3 z w}};\nlet thm3 = {{ t == f4 }};\n\nprove_print z3 thm1;\nprove_print z3 thm2;\nprove_print z3 thm3;\n```"}]}
{"filename":"saw-script\/intTests\/test1985\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that uses llvm_load_module to load the associated C source files. Define a let-bound specification named foo_spec that symbolically inputs an integer argument corresponding to the function 'Foo' (or the exact function name if different) and verifies its behavior. Use llvm_fresh_var for symbolic inputs and include minimal preconditions to ensure safety and termination. Reference exact function signatures from the associated source files and call them accordingly within the spec. Do not include inline do blocks directly; bind the spec to a let variable before use."},{"role":"assistant","content":"```saw\ntypedef Foo = Int;\ntypedef Bar = Foo;\nlet thing : Bar = 2;\n\nlet local = do {\n  typedef LocalFoo = Bar;\n  typedef LocalBar = LocalFoo;\n  let local_thing : LocalBar = 3;\n  return ();\n};\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_points_to_at_type\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function 'f' defined in 'test.bc' compiled from 'test.c'. Define a let-bound spec named 'f_spec' that uses 'llvm_fresh_var' to create a symbolic input array of 2 i32 elements, allocates an array of 4 i32 elements with 'llvm_alloc', and uses 'llvm_points_to_at_type' to assert that the pointer argument points to the first half of the array. Then execute the function 'f' with this pointer and verify that after execution, the memory at the pointer corresponds to the concatenation of the symbolic input array with itself. Include minimal preconditions to ensure safety and termination, and reference the exact function name 'f' as defined in the LLVM module.\n\n# Source code:\ntest.c\n```C\nvoid f (int *p) {\n    p[2] = p[0];\n    p[3] = p[1];\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ This is a test to demonstrate the use of the saw-script LLVM setup\n\/\/ declaration `llvm_points_to_at_type`.\n\nbc <- llvm_load_module \"test.bc\";\n\nlet i32 = llvm_int 32;\n\n\/\/ The function `f` copies the first half of an array into the second\n\/\/ half. So the full array needs to be allocated, but only the first\n\/\/ half needs to be initialized.\n\n\/\/ This first example fails because the types don't match in the first\n\/\/ `llvm_points_to` declaration.\nfails (\n  llvm_verify bc \"f\" [] false\n    do {\n      x <- llvm_fresh_var \"x\" (llvm_array 2 i32);\n      p <- llvm_alloc (llvm_array 4 i32);\n      llvm_points_to p (llvm_term x);\n      llvm_execute_func [p];\n      llvm_points_to p (llvm_term {{ x # x }});\n    }\n    z3);\n\n\/\/ Changing `llvm_points_to` to `llvm_points_to_at_type` will work, as\n\/\/ long as the specified type matches the type of the rhs.\nf_ov <-\n  llvm_verify bc \"f\" [] false\n    do {\n      x <- llvm_fresh_var \"x\" (llvm_array 2 i32);\n      p <- llvm_alloc (llvm_array 4 i32);\n      llvm_points_to_at_type p (llvm_array 2 i32) (llvm_term x);\n      llvm_execute_func [p];\n      llvm_points_to p (llvm_term {{ x # x }});\n    }\n    z3;\n\n\/\/ But if the specified type does not match the rhs, the declaration\n\/\/ will fail with another type mismatch error.\nfails (\n  llvm_verify bc \"f\" [] false\n    do {\n      x <- llvm_fresh_var \"x\" (llvm_array 2 i32);\n      p <- llvm_alloc (llvm_array 4 i32);\n      llvm_points_to_at_type p (llvm_array 3 i32) (llvm_term x);\n      llvm_execute_func [p];\n      llvm_points_to p (llvm_term {{ x # x }});\n    }\n    z3);\n```"}]}
{"filename":"saw-script\/intTests\/test_import_foreign\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the JVM backend that defines a let-bound specification named add_spec. The spec should symbolically represent inputs using jvm_fresh_var and invoke the Java method add from the associated source. Include minimal preconditions necessary for safety and termination. Then prove the specification using prove_print. Do not inline the spec; bind it with let before use."},{"role":"assistant","content":"```saw\nimport \"test.cry\";\n\n\/\/ requires definition of add\nprove_print z3 {{ \\x y -> add x y == x + y }};\n\n\/\/ does not require definition of f\nprove_print (unint_z3 [\"f\"]) {{ \\x -> f x + 1 == 1 + f x }};\n```"}]}
{"filename":"saw-script\/intTests\/test0028\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM backend that loads the module from 'test.bc' and verifies the function 'f' with signature 'void f(struct.BI*)'. Define a let-bound spec named 'f_spec' that allocates a symbolic 2x4 array of 32-bit unsigned integers representing the 'i' field of the struct BI, initializes the struct pointer with this symbolic array, executes 'f' on the pointer, and then asserts that the array is zeroed out. Use 'llvm_fresh_var' for symbolic inputs and 'llvm_alloc' for memory allocation. Include minimal preconditions to ensure safe execution and termination. Do not inline the spec in the verification call.\n\n# Source code:\ntest.c\n```C\n#include <stdio.h>\n\ntypedef struct BI {\n  unsigned int i[2][4];\n} BI_t;\n\nvoid f(BI_t* w) {\n  for( int j=0; j<2; j++) {\n    for (int k=0; k<4; k++) {\n      (w->i)[j][k] = 0;\n    }\n  }\n}\n\nint main() {\n  BI_t x;\n  x.i[1][3] = 42;\n  f(&x);\n  printf( \"%u\\n\", x.i[1][3] );\n}\n\n```"},{"role":"assistant","content":"```saw\n\/** f clears the 2x4 array of 32-bit unsigned ints in the referenced struct *\/\n    let f_spec : CrucibleSetup() = do {\n        i <- llvm_fresh_var \"w.i\" (llvm_array 2 (llvm_array 4 (llvm_int 32)));\n        pw <- llvm_alloc (llvm_alias \"struct.BI\");\n        llvm_points_to pw (llvm_struct_value [llvm_term i]);\n\n        llvm_execute_func [pw];\n        llvm_points_to pw (llvm_struct_value [llvm_term {{ zero:[2][4][32] }} ]);\n    };\n\n    \/\/ A variant of f_spec that uses llvm_struct_type instead of llvm_alias.\n    let f_spec2 : CrucibleSetup() = do {\n        i <- llvm_fresh_var \"w.i\" (llvm_array 2 (llvm_array 4 (llvm_int 32)));\n        pw <- llvm_alloc (llvm_struct_type [llvm_array 2 (llvm_array 4 (llvm_int 32))]);\n        llvm_points_to pw (llvm_struct_value [llvm_term i]);\n\n        llvm_execute_func [pw];\n        llvm_points_to pw (llvm_struct_value [llvm_term {{ zero:[2][4][32] }} ]);\n    };\n\n    let main : TopLevel () = do {\n        structTest <- llvm_load_module \"test.bc\";\n\n        f_result <- llvm_verify structTest \"f\" [] false f_spec z3;\n        f_result2 <- llvm_verify structTest \"f\" [] false f_spec2 z3;\n\n        print \"Done!\";\n    };\n```"}]}
{"filename":"saw-script\/intTests\/test_ghost_branch_02\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'test.bc' corresponding to the C source 'test.c'. Define let-bound specs for the functions 'f' and 'g' matching their signatures 'unsigned f(unsigned i)' and 'unsigned g(unsigned i)'. Use llvm_fresh_var to create symbolic 32-bit integer inputs with appropriate preconditions reflecting the branch conditions in 'f' (i < 42 and 42 <= i < 512). Use llvm_execute_func to call these functions with the symbolic inputs, and llvm_return to return the results. Declare a ghost state to track side effects on the global variable 'x'. Finally, verify 'g' against these specs using llvm_verify with the assumptions on 'f'.\n\n# Source code:\ntest.c\n```C\nextern unsigned x;\n\nunsigned f(unsigned i) {\n  if (i < 42) {\n    return i;\n  }\n  x = i;\n  return i;\n}\n\nunsigned g(unsigned i) {\n  return f(i);\n}\n\n```"},{"role":"assistant","content":"```saw\nlet f_lt_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{ i < 42 }};\n  llvm_execute_func [llvm_term i];\n  llvm_return (llvm_term i);\n};\n\nlet f_ge_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{ (i >= 42) && (i < 512) }};\n  llvm_execute_func [llvm_term i];\n  llvm_ghost_value x i;\n  llvm_return (llvm_term i);\n};\n\nlet g_spec : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{i < 512}};\n  llvm_execute_func [llvm_term i];\n  llvm_return (llvm_term i);\n};\n\nlet main : TopLevel () = do {\n  x <- declare_ghost_state \"x\";\n  m <- llvm_load_module \"test.bc\";\n  f_lt_ov <- llvm_unsafe_assume_spec m \"f\" (f_lt_spec x);\n  f_ge_ov <- llvm_unsafe_assume_spec m \"f\" (f_ge_spec x);\n  fails (llvm_verify m \"g\" [f_lt_ov, f_ge_ov] false g_spec z3);\n  print \"done\";\n};\n```"}]}
{"filename":"saw-script\/intTests\/test_jvm_unsound\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class \"Test\" from Test.java using java_load_class. Define let-bound specs for the method \"set\" with signature (Test,int)->void, and for the methods \"test_a\" and \"test_b\" with signatures (Test,int)->int. Use jvm_fresh_var to create symbolic integer inputs and jvm_alloc_object to allocate \"Test\" instances. Specify minimal preconditions ensuring safe execution. Use jvm_execute_func to invoke these methods and jvm_field_is and jvm_static_field_is to assert field values before and after calls. Verify correctness of \"test_a\" and \"test_b\" against their specs, and verify that incorrect specs for \"set\" fail. Do not include solver references or comments.\n\n# Source code:\nTest.java\n```java\nclass Test\n{\n    static int a;\n    int b;\n\n    public void set(int x) {\n        a = x;\n        b = x;\n    }\n    public int test_a(int x) {\n        set(x);\n        return a;\n    }\n    public int test_b(int x) {\n        set(x);\n        return b;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ This is a regression test for saw-script issue #900; it tests whether\n\/\/ `jvm_verify` will successfully verify a spec that does not specify a\n\/\/ new value for a field, when the method actually does modify that\n\/\/ field. For soundness of compositional verification, it is required\n\/\/ that such a verification will fail.\n\/\/ https:\/\/github.com\/GaloisInc\/saw-script\/issues\/900\n\nc <- java_load_class \"Test\";\n\nlet set_spec_1 =\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this \"b\" (jvm_term x);\n  };\n\nlet set_spec_2 =\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    jvm_execute_func [this, jvm_term x];\n    jvm_static_field_is \"a\" (jvm_term x);\n  };\n\nset_ov_1 <- jvm_unsafe_assume_spec c \"set\" set_spec_1;\nset_ov_2 <- jvm_unsafe_assume_spec c \"set\" set_spec_2;\n\nlet one = jvm_term {{ 1:[32] }};\nlet two = jvm_term {{ 2:[32] }};\n\n\/\/ A correct spec for test_a.\njvm_verify c \"test_a\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    jvm_static_field_is \"a\" one;\n    jvm_execute_func [this, two];\n    jvm_static_field_is \"a\" two;\n    jvm_field_is this \"b\" two;\n    jvm_return two;\n  }\n  z3;\n\n\/\/ An incorrect spec for test_a, which can be proven using the bogus\n\/\/ spec set_ov_1.\njvm_verify c \"test_a\" [set_ov_1] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    jvm_static_field_is \"a\" one;\n    jvm_execute_func [this, two];\n    jvm_static_field_is \"a\" one;\n    jvm_field_is this \"b\" two;\n    jvm_return one;\n  }\n  z3;\n\n\/\/ A correct spec for test_b.\njvm_verify c \"test_b\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    jvm_static_field_is \"a\" one;\n    jvm_field_is this \"b\" one;\n    jvm_execute_func [this, two];\n    jvm_static_field_is \"a\" two;\n    jvm_field_is this \"b\" two;\n    jvm_return two;\n  }\n  z3;\n\n\/\/ An incorrect spec for test_b, which can be proven using the bogus\n\/\/ spec set_ov_2.\njvm_verify c \"test_b\" [set_ov_2] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    jvm_static_field_is \"a\" one;\n    jvm_field_is this \"b\" one;\n    jvm_execute_func [this, two];\n    jvm_static_field_is \"a\" two;\n    jvm_field_is this \"b\" one;\n    jvm_return one;\n  }\n  z3;\n\n\/\/ It should be impossible to verify the bogus set_spec_1.\nfails (jvm_verify c \"set\" [] false set_spec_1 z3);\n\n\/\/ It should be impossible to verify the bogus set_spec_2.\nfails (jvm_verify c \"set\" [] false set_spec_2 z3);\n\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/intTests\/test0045_invariant_5\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from test.bc that verifies the function multiple_array_inc with signature void multiple_array_inc(uint8_t[], size_t, size_t). Define let-bound specs named multiple_array_inc_spec, outer_inv_spec, and inner_inv_spec that use llvm_fresh_var and llvm_alloc to create symbolic inputs for the array and size parameters. Include minimal preconditions ensuring loop indices i and j are within bounds (0 <= j <= m, 0 <= i <= n). Reference the breakpoint functions __breakpoint__outer_inv and __breakpoint__inner_inv by their exact symbol names in the specs. Use llvm_execute_func to invoke these functions with the appropriate symbolic pointers and variables. Do not include comments or solver references in the SAWScript.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n#include <stdlib.h>\n\nextern void __breakpoint__outer_inv(uint8_t**, size_t*, size_t*, size_t*, size_t*) __attribute__((noduplicate));\nextern void __breakpoint__inner_inv(uint8_t**, size_t*, size_t*, size_t*, size_t*) __attribute__((noduplicate));\n\nvoid multiple_array_inc(uint8_t a[], size_t n, size_t m) {\n  size_t i, j;\n  for (j = 0; __breakpoint__outer_inv(&a, &n, &m, &i, &j), j < m; ++j) {\n    for (i = 0; __breakpoint__inner_inv(&a, &n, &m, &i, &j), i < n; ++i) {\n      ++a[i];\n    }\n  }\n}\n\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nlet ptr_to_fresh n ty = do {\n  p <- llvm_alloc ty;\n  x <- llvm_fresh_var n ty;\n  llvm_points_to p (llvm_term x);\n  return (p, x);\n};\n\nlet len = 100;\n\nlet multiple_array_inc_spec = do {\n  (pa, a) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 8));\n  let n = llvm_term {{ `len : [64] }};\n  m <- llvm_fresh_var \"m\" (llvm_int 64);\n  llvm_execute_func [pa, n, llvm_term m];\n};\n\nlet outer_inv_spec = do {\n  (pa, a) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 8));\n  ppa <- llvm_alloc (llvm_int 64);\n  llvm_points_to ppa pa;\n  let n = llvm_term {{ `len : [64] }};\n  pn <- llvm_alloc (llvm_int 64);\n  llvm_points_to pn n;\n  (pm, m) <- ptr_to_fresh \"m\" (llvm_int 64);\n  pi <- llvm_alloc (llvm_int 64);\n  (pj, j) <- ptr_to_fresh \"j\" (llvm_int 64);\n  llvm_precond {{ 0 <= j \/\\ j <= m }};\n  llvm_execute_func [ppa, pn, pm, pi, pj];\n};\n\nlet inner_inv_spec = do {\n  (pa, a) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 8));\n  ppa <- llvm_alloc (llvm_int 64);\n  llvm_points_to ppa pa;\n  let n = llvm_term {{ `len : [64] }};\n  pn <- llvm_alloc (llvm_int 64);\n  llvm_points_to pn n;\n  (pm, m) <- ptr_to_fresh \"m\" (llvm_int 64);\n  (pi, i) <- ptr_to_fresh \"i\" (llvm_int 64);\n  (pj, j) <- ptr_to_fresh \"j\" (llvm_int 64);\n  llvm_precond {{ 0 <= j \/\\ j < m }};\n  llvm_precond {{ 0 <= i \/\\ i <= `len }};\n  llvm_execute_func [ppa, pn, pm, pi, pj];\n};\n\ninner_inv <- llvm_unsafe_assume_spec m \"__breakpoint__inner_inv#multiple_array_inc\" inner_inv_spec;\nouter_inv <- llvm_unsafe_assume_spec m \"__breakpoint__outer_inv#multiple_array_inc\" outer_inv_spec;\n\nllvm_verify m \"__breakpoint__inner_inv#multiple_array_inc\" [inner_inv, outer_inv] false inner_inv_spec abc;\nllvm_verify m \"__breakpoint__outer_inv#multiple_array_inc\" [inner_inv, outer_inv] false outer_inv_spec abc;\nllvm_verify m \"multiple_array_inc\" [inner_inv, outer_inv] false multiple_array_inc_spec abc;\n\nllvm_verify m \"__breakpoint__inner_inv#multiple_array_inc\" [inner_inv] false inner_inv_spec abc;\nllvm_verify m \"multiple_array_inc\" [inner_inv] false multiple_array_inc_spec abc;\n```"}]}
{"filename":"saw-script\/intTests\/test_jvm_small_types\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java class Test that defines let-bound specs for each method: addBoolean(boolean, boolean) returns boolean as x != y; addByte(byte, byte) returns byte as x + y; addChar(char, char) returns char as x + y; addShort(short, short) returns short as x + y; updBoolean(boolean[], boolean) updates array index 0 with x; updByte(byte[], byte) updates array index 0 with x; updChar(char[], char) updates array index 0 with x; updShort(short[], short) updates array index 0 with x. Use jvm_fresh_var for symbolic inputs, allocate arrays where needed, and verify each method by calling jvm_execute_func with appropriate arguments and asserting the expected return or array update. Reference exact method names from Test.java and use jvm_* commands accordingly.\n\n# Source code:\nTest.java\n```java\nclass Test\n{\n    public static boolean addBoolean(boolean x, boolean y) {\n        return x != y;\n    }\n    public static byte addByte(byte x, byte y) {\n        return (byte) (x + y);\n    }\n    public static char addChar(char x, char y) {\n        return (char) (x + y);\n    }\n    public static short addShort(short x, short y) {\n        return (short) (x + y);\n    }\n\n    public static void updBoolean(boolean []a, boolean x) {\n        a[0] = x;\n    }\n    public static void updByte(byte []a, byte x) {\n        a[0] = x;\n    }\n    public static void updChar(char []a, char x) {\n        a[0] = x;\n    }\n    public static void updShort(short []a, short x) {\n        a[0] = x;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"Test\";\n\njvm_verify c \"addBoolean\" [] false\n  do {\n    x <- jvm_fresh_var \"x\" java_bool;\n    y <- jvm_fresh_var \"y\" java_bool;\n    jvm_execute_func [jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ x ^ y }});\n  }\n  do {\n    check_goal;\n    z3;\n  };\n\njvm_verify c \"addByte\" [] false\n  do {\n    x <- jvm_fresh_var \"x\" java_byte;\n    y <- jvm_fresh_var \"y\" java_byte;\n    jvm_execute_func [jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ x + y }});\n  }\n  do {\n    check_goal;\n    z3;\n  };\n\njvm_verify c \"addChar\" [] false\n  do {\n    x <- jvm_fresh_var \"x\" java_char;\n    y <- jvm_fresh_var \"y\" java_char;\n    jvm_execute_func [jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ x + y }});\n  }\n  do {\n    check_goal;\n    z3;\n  };\n\njvm_verify c \"addShort\" [] false\n  do {\n    x <- jvm_fresh_var \"x\" java_short;\n    y <- jvm_fresh_var \"y\" java_short;\n    jvm_execute_func [jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ x + y }});\n  }\n  do {\n    check_goal;\n    z3;\n  };\n\njvm_verify c \"updBoolean\" [] false\n  do {\n    a <- jvm_fresh_var \"x\" (java_array 4 java_bool);\n    x <- jvm_fresh_var \"x\" java_bool;\n    aref <- jvm_alloc_array 4 java_bool;\n    jvm_array_is aref a;\n    jvm_execute_func [aref, jvm_term x];\n    jvm_array_is aref {{ update a 0x0 x }};\n  }\n  do {\n    check_goal;\n    z3;\n  };\n\njvm_verify c \"updByte\" [] false\n  do {\n    a <- jvm_fresh_var \"x\" (java_array 4 java_byte);\n    x <- jvm_fresh_var \"x\" java_byte;\n    aref <- jvm_alloc_array 4 java_byte;\n    jvm_array_is aref a;\n    jvm_execute_func [aref, jvm_term x];\n    jvm_array_is aref {{ update a 0x0 x }};\n  }\n  do {\n    check_goal;\n    z3;\n  };\n\njvm_verify c \"updChar\" [] false\n  do {\n    a <- jvm_fresh_var \"x\" (java_array 4 java_char);\n    x <- jvm_fresh_var \"x\" java_char;\n    aref <- jvm_alloc_array 4 java_char;\n    jvm_array_is aref a;\n    jvm_execute_func [aref, jvm_term x];\n    jvm_array_is aref {{ update a 0x0 x }};\n  }\n  do {\n    check_goal;\n    z3;\n  };\n\njvm_verify c \"updShort\" [] false\n  do {\n    a <- jvm_fresh_var \"x\" (java_array 4 java_short);\n    x <- jvm_fresh_var \"x\" java_short;\n    aref <- jvm_alloc_array 4 java_short;\n    jvm_array_is aref a;\n    jvm_execute_func [aref, jvm_term x];\n    jvm_array_is aref {{ update a 0x0 x }};\n  }\n  do {\n    check_goal;\n    z3;\n  };\n```"}]}
{"filename":"saw-script\/intTests\/test_goal_eval\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test_goal_eval\/test.saw, defines a let-bound specification named test_spec that uses llvm_fresh_var to create symbolic inputs matching the function signature of the target function in the associated source files, applies minimal preconditions for safety such as array bounds or non-zero divisors, and calls llvm_verify to verify the target function against test_spec. The harness should not include inline do blocks directly as arguments but use let-bound specs, and must reference exact function names and signatures from the associated LLVM source."},{"role":"assistant","content":"```saw\n\/\/ This is a regression test for GaloisInc\/saw-script#985.\n\/\/ It uses `goal_eval` and then calls `goal_intro` to enforce\n\/\/ that `goal_eval` has preserved the explicit quantifiers in\n\/\/ the goal.\n\nenable_experimental;\n\nlet prop = {{ \\(xs:[4][8]) (ys:([8],[8])) -> sum xs == ys.0 * ys.1 }};\n\nprove_print\n  do {\n    goal_intro \"z\";\n    assume_unsat;\n  }\n  prop;\n\nprove_print\n  do {\n    goal_eval;\n    goal_intro \"z\";\n    assume_unsat;\n  }\n  prop;\n\nprint \"Done\";\n```"}]}
{"filename":"saw-script\/intTests\/test0041_invariant_1\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'test.bc' and defines let-bound specs for the functions '__breakpoint__inv' and 'add2' as declared in 'test.c'. Use symbolic 64-bit integer inputs created with llvm_fresh_var. For '__breakpoint__inv', allocate a pointer to a fresh variable, execute the function with this pointer, and specify the return value as the input variable incremented by 1. For 'add2', execute the function with a symbolic input and specify the return value as the input plus 2. Verify '__breakpoint__inv' first, then verify 'add2' using the invariant. Include minimal preconditions for safety and termination. Do not include comments or solver references in the SAWScript.\n\n# Source code:\ntest.c\n```C\n#include <stdlib.h>\n\nextern size_t __breakpoint__inv(size_t*);\n\nsize_t add2(size_t x) {\n  ++x;\n  __breakpoint__inv(&x);\n  ++x;\n  return x;\n}\n\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nlet ptr_to_fresh n ty = do {\n  p <- llvm_alloc ty;\n  x <- llvm_fresh_var n ty;\n  llvm_points_to p (llvm_term x);\n  return (p, x);\n};\n\nlet add2_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 64);\n  llvm_execute_func [llvm_term x];\n  llvm_return (llvm_term {{ x + 2 }});\n};\n\nlet inv_spec = do {\n  (px, x) <- ptr_to_fresh \"x\" (llvm_int 64);\n  llvm_execute_func [px];\n  llvm_return (llvm_term {{ x + 1 }});\n};\n\ninv <- llvm_verify m \"__breakpoint__inv#add2\" [] false inv_spec abc;\nllvm_verify m \"add2\" [inv] false add2_spec abc;\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_verify_str_slices\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test_mir_verify_str_slices\/test.saw and verifies the functions test::f and test::g. Define let-bound specs named f_spec_1 and f_spec_2 that allocate symbolic arrays of 5 bytes, initialize them with the string \"hello\", and call test::f with mir_str_slice_value and mir_str_slice_range_value respectively. Use symbolic inputs with llvm_fresh_var for the arrays. Add minimal preconditions ensuring slice ranges are within bounds and start is less than end. Verify test::g using the verification results of test::f as dependencies. Do not include comments or solver references."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet hello = mir_term {{ \"hello\" : [5][8] }};\n\n\/\/ Alternatively we could define it like this:\n\/\/\n\/\/ let hello = mir_term {{ [104, 101, 108, 108, 111] : [5][8] }};\n\nlet f_spec_1 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a hello;\n\n  mir_execute_func [mir_str_slice_value a];\n\n  mir_return (mir_term {{ 205 : [8] }});\n};\n\nlet f_spec_2 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a hello;\n\n  mir_execute_func [mir_str_slice_range_value a 1 3];\n\n  mir_return (mir_term {{ 209 : [8] }});\n};\n\n\/\/ mir_str_slice_value must take an array reference as an argument.\n\/\/ Passing a bare array constitutes a type error.\nlet f_fail_spec_1 = do {\n  let arr = mir_array_value mir_u8 [mir_term {{ 1 : [8] }}];\n  mir_execute_func [mir_str_slice_value arr];\n\n  mir_return (mir_term {{ 0 : [8] }});\n};\n\n\/\/ The end value of the range given to mir_slice_range_value must not\n\/\/ exceed the length of the slice.\nlet f_fail_spec_2 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a hello;\n\n  mir_execute_func [mir_str_slice_range_value a 0 6];\n\n  mir_return (mir_term {{ 205 : [8] }});\n};\n\n\/\/ The start value of the range given to mir_slice_range_value must not\n\/\/ exceed the end value.\nlet f_fail_spec_3 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a hello;\n\n  mir_execute_func [mir_str_slice_range_value a 6 5];\n\n  mir_return (mir_term {{ 0 : [8] }});\n};\n\n\/\/ Indexing into a length-0 slice is disallowed.\nlet f_fail_spec_4 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a hello;\n\n  mir_execute_func [mir_str_slice_range_value a 0 0];\n\n  mir_return (mir_term {{ 0 : [8] }});\n};\n\n\/\/ f requires a slice of length at least two.\nlet f_fail_spec_5 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a hello;\n\n  mir_execute_func [mir_str_slice_range_value a 0 1];\n\n  mir_return (mir_term {{ 0 : [8] }});\n};\n\n\/\/ f specifically requires a value of type &str as an argument. Passing a value\n\/\/ of type &[u8] instead should yield a type error.\nlet f_fail_spec_6 = do {\n  a <- mir_alloc (mir_array 5 mir_u8);\n  mir_points_to a hello;\n\n  mir_execute_func [mir_slice_value a];\n\n  mir_return (mir_term {{ 205 : [8] }});\n};\n\n\/\/ mir_str_slice_value must take a &[u8; N] value as an argument. Passing a\n\/\/ value of another type (e.g., &[u32; N]) constitutes a type error.\nlet f_fail_spec_7 = do {\n  a <- mir_alloc (mir_array 5 mir_u32);\n  mir_points_to a (mir_term {{ map zext`{32,8} \"hello\" }});\n\n  mir_execute_func [mir_str_slice_value a];\n\n  mir_return (mir_term {{ 205 : [8] }});\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nf_ov_1 <- mir_verify m \"test::f\" [] false f_spec_1 z3;\nf_ov_2 <- mir_verify m \"test::f\" [] false f_spec_2 z3;\n\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_1 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_2 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_3 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_4 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_5 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_6 z3\n);\nfails (\n  mir_verify m \"test::f\" [] false f_fail_spec_7 z3\n);\n\nmir_verify m \"test::g\" [f_ov_1] false f_spec_1 z3;\nmir_verify m \"test::g\" [f_ov_2] false f_spec_2 z3;\n```"}]}
{"filename":"saw-script\/intTests\/test0067_term_eqs\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"test.bc\" that verifies the function \"f\" with signature int f(int x, int y, int z) from the C source file \"test.c\". Define a let-bound specification named f_spec that uses llvm_fresh_var to create a symbolic 32-bit integer x and calls llvm_execute_func with arguments (x - 1), x, and (x + 1). The spec should return 3 * x using crucible_return. Also define a test_spec that calls the function \"test_f\" with no arguments. Use llvm_unsafe_assume_spec to associate f_spec with \"f\" and verify \"test_f\" against this spec using llvm_verify. Ensure all symbolic inputs and function references match the exact names and signatures from the source.\n\n# Source code:\ntest.c\n```C\nint f(int x, int y, int z);\n\nint test_f()\n{\n  return f(-1, 0, 1);\n}\n\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nlet f_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [(crucible_term {{ x - 1 }}), (crucible_term x), (crucible_term {{ x + 1 }})];\n  crucible_return (crucible_term {{ 3 * x }});\n};\n\nlet f_false_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [(crucible_term {{ x - 1 }}), (crucible_term {{ x + 0 }}), (crucible_term {{ x + 1 }})];\n  crucible_return (crucible_term {{ 3 * x }});\n};\n\nlet test_spec = do {\n  llvm_execute_func [];\n};\n\nf_ov <- llvm_unsafe_assume_spec m \"f\" f_spec;\nf_false_ov <- llvm_unsafe_assume_spec m \"f\" f_false_spec;\nllvm_verify m \"test_f\" [f_ov] false test_spec trivial;\nfails (llvm_verify m \"test_f\" [f_false_ov] false test_spec trivial);\n```"}]}
{"filename":"saw-script\/intTests\/test0032_clear_void\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from voidTest.bc and defines two let-bound specs: clear_void_spec and clear_uints_spec. Each spec should use llvm_fresh_var to create symbolic inputs matching the function signatures void clear_void(void *arr, unsigned int size) and void clear_uints(unsigned int *uints, unsigned int numUInts). Include minimal preconditions such as size == 12 for clear_void and numUInts == 3 for clear_uints. Use llvm_alloc and llvm_points_to to model memory, llvm_execute_func to call the functions, and verify that the arrays are zeroed after execution. Finally, verify clear_void first, then clear_uints using the result of clear_void verification as a dependency.\n\n# Source code:\nvoidTest.c\n```C\n\/\/ voidTest.c\n\n\/** mockup of subroutine to assume\/override *\/\nvoid clear_void(void *arr, unsigned int size) {\n    unsigned char *cArr = arr;\n    for (int i = 0; i < size; i++) {\n        cArr[i] = 0;\n    }\n}\n\n\/** mockup of caller that passes a pointer to an array of unsigned ints to the void *-based subroutine *\/\nvoid clear_uints(unsigned int *uints, unsigned int numUInts) {\n    clear_void(uints, numUInts * sizeof(unsigned int));\n}\n```"},{"role":"assistant","content":"```saw\n\/\/ saw -d 4 voidTest.saw\n\n\/** \n * spec for mockup of subroutine that clears the given number of bytes from the \n * arbitrary array pointed to by a given void * \n *\/\nlet clear_void_spec : CrucibleSetup() = do {\n    let voidArrayType = (llvm_array 12 (llvm_int 8));\n    \n    arr <- (llvm_fresh_var \"arr\" voidArrayType);\n    p_arr <- (llvm_alloc voidArrayType);\n    let v_arr = (llvm_term arr);\n    \n    size <- (llvm_fresh_var \"size\" (llvm_int 32));\n    let v_size = (llvm_term size);\n    \n    llvm_equal v_size (llvm_term {{ 12:[32] }});\n    llvm_points_to p_arr v_arr;\n    \n    llvm_execute_func [p_arr, v_size];\n    \n    llvm_points_to p_arr (llvm_term {{ zero:[12][8] }});\n};\n\n\/** \n * spec for function that calls the subroutine to clear the given number of \n * unsigned ints from the array pointed to by a specified unsigned int * \n *\/ \nlet clear_uints_spec : CrucibleSetup() = do {\n    let uintsType = (llvm_array 3 (llvm_int 32));\n    \n    uints <- (llvm_fresh_var \"uints\" uintsType);\n    p_uints <- (llvm_alloc uintsType);\n    let v_uints = (llvm_term uints);\n    \n    numUInts <- (llvm_fresh_var \"numUInts\" (llvm_int 32));\n    let v_numUInts = (llvm_term numUInts);\n    \n    llvm_equal v_numUInts (llvm_term {{ 3:[32] }});\n    llvm_points_to p_uints v_uints;\n    \n    llvm_execute_func [p_uints, v_numUInts];\n    \n    llvm_points_to p_uints (llvm_term {{ zero:[3][32] }});\n};\n\nlet main : TopLevel () = do {\n    voidTest <- llvm_load_module \"voidTest.bc\";\n    \n    \/\/ The actual subroutine result would be \"llvm_unsafe_assume_spec ...\"\n    enable_crucible_assert_then_assume;\n    clear_void_12_result <- llvm_verify voidTest \"clear_void\" [] true clear_void_spec z3;\n    disable_crucible_assert_then_assume;\n    clear_uints_3_result <- llvm_verify voidTest \"clear_uints\" [clear_void_12_result] true clear_uints_spec z3;\n    \n    print \"Done!\";\n};\n```"}]}
{"filename":"saw-script\/intTests\/test_cryptol_enums\/test2.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the C\/Java functions referenced in saw-script\/intTests\/test_cryptol_enums\/test2.saw. Define a let-bound specification named cc3_spec that uses symbolic inputs created with llvm_fresh_var or jvm_fresh_var as appropriate. Reference the exact function symbol cc3 from the associated source files. Include minimal preconditions necessary for safety and termination. Use the imported Cryptol module Test2 and its properties as needed. The harness should prove equivalence or correctness properties involving results1 and results2 as indicated in the SAW excerpt, without inline do blocks or comments."},{"role":"assistant","content":"```saw\nimport \"Test2.cry\";\n\nprint \"cc3:\";\ncheck_term {{ cc3 }};\n\nprint \"results1:\";\nprint  {{results1}};\nprove_print abc {{ results1 == ~zero}};\n\nprint \"results2:\";\nprint  {{results2}};\nprove_print abc {{ results2 == ~zero}};\n\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/intTests\/test_cryptol_enums\/Test2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the behavior of the functions f1, f1', f2, f3, and f4 defined over the enum type ETT. The properties should check that each function returns the expected output for all possible constructors of ETT and their contained values, matching the example test cases given in the code. Include properties that verify the correctness of pattern matching and arithmetic computations in these functions."},{"role":"assistant","content":"```cryptol\nmodule Test2 where\n\n\/\/ Our data type, constructors of arity 0, 1, and 2+.\n\/\/ ETT = Enum Type Test\nenum ETT a b = C1\n             | C2 a\n             | C3 Bool b\n\n\n\/*******************************************************\/\n\n\nf1 : {c, d} ETT c d -> [8]\nf1 e1 = case e1 of\n          C1 -> 101\n          _  -> 102\n\nf1' e1 = case e1 of\n           C1 -> 101\n           _  -> 102\n\n\nf2 : ETT Bool () -> [8]\nf2 e = case e of\n         C1     -> 101\n         C3 _ _ -> 103\n         C2 _   -> 102\n\nf3 : ETT Bool () -> [8]\nf3 e = case e of\n         C1      -> 101\n         _       -> 105\n           \/\/ ^ compiles to two default functions but they have different\n           \/\/   types.\n\nt11 = f1 C1\nt12 = f1 (C2 ())\nt13 = f1 (C3 True False)\n\nt31 = f3 C1\nt32 = f3 (C2 False)\nt33 = f3 (C3 True ())\n\nresults1 = [ t11 == 101\n           , t12 == 102\n           , t13 == 102\n           , t31 == 101\n           , t32 == 105\n           , t33 == 105\n           ]\n\n\/* sawcript idioms:\n\nreturn (type {{ f1  }})\nreturn (type {{ f1' }})\n\nreturn (normalize_term {{ t11 }})\nreturn (normalize_term {{ t12 }})\nreturn (normalize_term {{ t13 }})\n\nreturn (eval_int {{ t31 }})\nreturn (eval_int {{ t32 }})\nreturn (eval_int {{ t33 }})\n*\/\n\n\n\/***********************************************************\n * Sanity check on currying constructors.\n *\/\n\ncc3 : {a, b} b -> ETT a b\ncc3 = C3 True\n\n\/***********************************************************\n * tests that we're referencing proper variables when generating code for case expressions\n *\/\n\nx : [16]\nx = 2\n\ny : [16]\ny = 1\n\nf4 : [16] -> ETT [16] [16] -> [16]\nf4 z e = 4 + z + case e of\n                   C3 _ b   ->     b + z + y + 32\n                   C2 a     -> a +     z + y + 16\n                   _        ->         z + x + 8\n\nt43a = f4 64 (C3 False 512) \/\/ 4+64   + 512   + 64+1+32   -- 677\nt42a = f4 64 (C2 128)       \/\/ 4+64 + 128     + 64+ 1+16  -- 277\nt41a = f4 64 C1             \/\/ 4+64          + 64+2+8    -- 142\n\nresults2 = [ t43a == 677\n           , t42a == 277\n           , t41a == 142\n           ]\n\n\/* sawcript idioms:\n\nreturn (eval_int {{ t41a }})\nreturn (eval_int {{ t42a }})\nreturn (eval_int {{ t43a }})\n*\/\n```"}]}
{"filename":"saw-script\/intTests\/test_constraint_guards\/Parameterized.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally captures the behavior of the function `v` in the `Parameterized` module, including the constraint guards dependent on the parameter `gamma`. Then, write a SAWScript verification script that proves the function `v` returns the correct value for each valid instantiation of `gamma` (specifically for `gamma == 2` and `gamma == 3`), ensuring that the constraint guards are correctly enforced and that the function behaves as specified."},{"role":"assistant","content":"```cryptol\nmodule Parameterized where\n\nparameter\n    type gamma : #\n    type constraint (fin gamma, gamma >= 2, 32 >= width gamma)\n\n\/\/ Constraint guard with type dependent on module parameter value\nv : [gamma]\nv | (gamma == 3) => 0\n  \/\/ Cryptol replaces this next constraint with `TError 3 == 2` when\n  \/\/ instantiating `Instantiated.cry`\n  | (gamma == 2) => 1\n  | () => 2\n```"}]}
{"filename":"saw-script\/intTests\/test_constraint_guards\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and exhaustiveness of the constraint guards in the functions 'guard', 'incomplete', and 'dependent' from the given module. Ensure the properties check that the functions behave as expected for all relevant input sizes and that the guards cover all cases where intended."},{"role":"assistant","content":"```cryptol\nmodule Test where\n\n\/\/ Exhaustive constraint guards with some overlapping branches\nguard : {w} [w] -> Integer\nguard x\n  | (w == 32) => 0\n  | (w >= 32) => 1\n  | (w < 8) => 2\n  | (w != 8, w != 9) => 3\n  | () => 4\n\n\/\/ Non-exhaustive constraint guard\nincomplete : {w} [w] -> Bool\nincomplete x\n  | (w == 32) => True\n\n\/\/ More dependently typed case\ndependent : {n} [n]\ndependent\n  | n == 1 => [True]\n  | ()     => repeat False\n```"}]}
{"filename":"saw-script\/intTests\/test_constraint_guards\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated C or Java source files using the appropriate backend inferred from the presence of llvm_load_module or java_load_class. Define a let-bound specification named guard_spec that symbolically inputs a 32-bit integer using llvm_fresh_var or jvm_fresh_var, applies minimal preconditions for safety, and calls the exact function named guard with this input. Similarly, define specifications for incomplete and dependent functions if present, referencing their exact signatures. Use these specs to verify the correctness of these functions against their expected behaviors as indicated in the SAW file, without including any solver references or inline do blocks."},{"role":"assistant","content":"```saw\nimport \"Test.cry\";\n\n\/\/ Test exhaustive constraint guards\nprove_print z3 {{ \\(x : [32])  -> guard x == 0 }};\nprove_print z3 {{ \\(x : [34])  -> guard x == 1 }};\nprove_print z3 {{ \\(x : [4])   -> guard x == 2 }};\nprove_print z3 {{ \\(x : [16])  -> guard x == 3 }};\nprove_print z3 {{ \\(x : [8])   -> guard x == 4}};\nprove_print z3 {{ \\(x : [9])   -> guard x == 4}};\n\n\/\/ Test non-exhaustive constraint guards\nprove_print z3 {{ \\(x : [32]) -> incomplete x }};\nfails (prove_print z3 {{ \\(x : [64]) -> incomplete x }});\n\n\/\/ Test more dependently typed constraint guards\nprove_print z3 {{ dependent`{1} == [True] }};\nprove_print z3 {{ dependent`{3} == [False, False, False] }};\nprove_print z3 {{ dependent`{0} == [] }};\n\n\/\/ Test constraint guards dependently typed on module parameters\nimport \"Instantiated.cry\";\nprove_print z3 {{ v == 0 }};\n```"}]}
{"filename":"saw-script\/intTests\/test_smtlib\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the LLVM backend that defines a let-bound specification named add_spec. The spec should symbolically declare two 8-bit integer inputs using llvm_fresh_var, add a minimal precondition ensuring the inputs are valid for addition, and then verify that the function add (with signature int8_t add(int8_t, int8_t)) from the provided LLVM module satisfies the property that if x == y then add(x, y) == add(x, x). Use prove to verify this specification."},{"role":"assistant","content":"```saw\n\/\/ `offline_smtlib2` takes a formula to prove universally\nprove (offline_smtlib2 \"prove\") {{ \\(x:[8]) (y:[8]) -> x == y ==> x+y == x+x }};\n\n\/\/ `write_smtlib2` takes a formula to prove existentially\nwrite_smtlib2 \"sat.smt2\" {{ \\(x:[8]) -> x != 0 \/\\ x+x == x }};\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_tuple\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function 'swap' defined in 'test.bc' and implemented in 'test.c'. Load the LLVM module from 'test.bc'. Define a let-bound specification 'swap_spec' that models the behavior of 'swap' on a struct triple pointer, where the struct triple consists of a 4-element array of 8-bit integers and two 16-bit integers. Use 'llvm_fresh_var' to create a symbolic input of the struct triple type, allocate memory for it with 'llvm_alloc', and use 'llvm_points_to' to set the initial memory state. Execute the 'swap' function with 'llvm_execute_func' on the allocated pointer. Finally, assert the postcondition that the memory points to the transformed struct as specified by 'swap_spec'. Include minimal preconditions necessary for safe execution and termination. Do not include solver references or comments.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n\nstruct triple {\n    uint8_t first[4];\n    uint16_t second;\n    uint16_t third;\n};\n\nvoid swap (struct triple *p) {\n    uint8_t temp1;\n    uint16_t temp2;\n    temp1 = p->first[0];\n    p->first[0] = p->first[3];\n    p->first[3] = temp1;\n    temp1 = p->first[1];\n    p->first[1] = p->first[2];\n    p->first[2] = temp1;\n    temp2 = p->second;\n    p->second = p->third;\n    p->third = temp2;\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ This is a test demonstrating the use of `llvm_points_to` with a\n\/\/ struct pointer and a single Cryptol term of tuple type.\n\/\/ https:\/\/github.com\/GaloisInc\/saw-script\/issues\/159\n\nbc <- llvm_load_module \"test.bc\";\n\nlet i8 = llvm_int 8;\nlet i16 = llvm_int 16;\n\nlet {{\n  swap_spec : ([4][8], [16], [16]) -> ([4][8], [16], [16])\n  swap_spec (xs, y, z) = (reverse xs, z, y)\n}};\n\nswap_ov <-\n  llvm_verify bc \"swap\" [] false\n    do {\n      let t = llvm_alias \"struct.triple\";\n      p <- llvm_alloc t;\n      x <- llvm_fresh_var \"x\" t;\n      llvm_points_to p (llvm_term x);\n      llvm_execute_func [p];\n      llvm_points_to p (llvm_term {{ swap_spec x }});\n    }\n    z3;\n```"}]}
{"filename":"saw-script\/intTests\/test1768\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test1768\/test.saw, defines a let-bound specification named f_spec that uses llvm_fresh_var to create a symbolic input matching the signature of the function 'f' defined in the module, applies minimal preconditions necessary for safety, and verifies that for all inputs, the function 'f' behaves as specified by the property imported from the Cryptol module 'test.cry'. The harness should invoke the function 'f' symbolically and check equivalence against the Cryptol specification without inline do blocks."},{"role":"assistant","content":"```saw\nimport \"test.cry\";\nprint {{ f 0b11 }};\nprint {{ f 0b10 }};\nprint {{ f 0b00 }};\nsat z3 {{ \\x -> f x == zero }};\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_unsafe_assume_spec_statics\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given path and defines a let-bound spec named foo_spec. The spec should use llvm_fresh_var to create symbolic inputs corresponding to the function's parameters, set up any necessary preconditions for safety, and use llvm_execute_func to call the exact function symbol 'test::foo'. The harness should then verify 'test::foo' against foo_spec using llvm_verify, referencing any required overrides from 'test::side_effect' as needed. Ensure the spec and verification directly reference the exact LLVM function symbols from the provided module path."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet side_spec_1 = do {\n  let a_static = mir_static \"test::A\";\n  a_init <- mir_fresh_var \"A\" mir_u32;\n  mir_points_to a_static (mir_term a_init);\n\n  mir_execute_func [];\n\n  mir_points_to a_static (mir_term {{ 0 : [32] }});\n  mir_return (mir_term a_init);\n};\n\nlet side_spec_2 = do {\n  let a_static = mir_static \"test::A\";\n  a_init <- mir_fresh_var \"A\" mir_u32;\n  mir_points_to a_static (mir_term a_init);\n\n  mir_execute_func [];\n\n  mir_return (mir_term a_init);\n};\n\n\/\/ This spec is erroneous. See the comments below in the \"Avoid unsoundness\"\n\/\/ part of the test.\nlet foo_spec = do {\n  let a_static = mir_static \"test::A\";\n  a_init <- mir_fresh_var \"A\" mir_u32;\n  mir_points_to a_static (mir_term a_init);\n\n  mir_execute_func [];\n\n  mir_return (mir_term a_init);\n};\n\nside_ov_1 <- mir_verify m \"test::side_effect\" [] false side_spec_1 z3;\nside_ov_2 <- mir_verify m \"test::side_effect\" [] false side_spec_2 z3;\n\n\/\/ This should not verify, as invoking `side_effect` should cause `foo` to\n\/\/ always return `0` rather than the original value of A.\nfails (\n  mir_verify m \"test::foo\" [side_ov_1] false foo_spec z3\n);\n\/\/ This should not verify, as side_spec_2 underspecifies the mutable\n\/\/ static `a_ptr` in its postconditions. SAW will catch this when attempting\n\/\/ to use side_ov_2 as an override.\nfails (\n  mir_verify m \"test::foo\" [side_ov_2] false foo_spec z3\n);\n```"}]}
{"filename":"saw-script\/intTests\/test_ghost_branch_03\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from test.bc and defines let-bound specs for the functions get(), f(int), g(int), and h(int) as declared in test.c. Use llvm_fresh_var to create symbolic 32-bit integer inputs where needed. For h_spec, add a precondition that the input integer is less than 512 and a postcondition that the return value equals the input. Use llvm_execute_func and llvm_return to model function calls and returns. Declare a ghost state to track the global variable x. Finally, verify h against its spec assuming the specs for get, f, and g, using llvm_unsafe_assume_spec to bind the specs to the module's functions.\n\n# Source code:\ntest.c\n```C\nextern int x;\n\nint get() {\n  return x;\n}\n\nvoid f(int i) {\n  x = i;\n}\n\nvoid g(int i) {\n  x = i;\n}\n\nint h(int i) {\n  if (i < 42) {\n    f(i);\n  } else {\n    g(i);\n  }\n  return get();\n}\n\n```"},{"role":"assistant","content":"```saw\nlet get_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_ghost_value x i;\n  llvm_execute_func [];\n  llvm_ghost_value x i;\n  llvm_return (llvm_term i);\n};\n\nlet f_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_execute_func [llvm_term i];\n  llvm_ghost_value x i;\n};\n\nlet g_spec (x : Ghost) : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_execute_func [llvm_term i];\n  llvm_ghost_value x {{ True : Bit }}; \/\/ should be [32]\n};\n\nlet h_spec : CrucibleSetup () = do {\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{i < 512}};\n  llvm_execute_func [llvm_term i];\n  ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n  llvm_return (llvm_term ret);\n  llvm_postcond {{ ret == i }};\n};\n\nlet main : TopLevel () = do {\n  x <- declare_ghost_state \"x\";\n  m <- llvm_load_module \"test.bc\";\n  get_ov <- llvm_unsafe_assume_spec m \"get\" (get_spec x);\n  f_ov <- llvm_unsafe_assume_spec m \"f\" (f_spec x);\n  g_ov <- llvm_unsafe_assume_spec m \"g\" (g_spec x);\n  fails (llvm_verify m \"h\" [get_ov, f_ov, g_ov] false h_spec z3);\n  print \"done\";\n};\n```"}]}
{"filename":"saw-script\/intTests\/test_yosys_sequential_sally\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given source files, defines a let-bound specification named 'func_spec' that uses llvm_fresh_var to create symbolic inputs matching the exact function signature, includes minimal preconditions necessary for safety and termination, and calls the target function symbol from the source. The harness should then verify the function against 'func_spec' using appropriate SAW LLVM verification commands without inline specs or solver references."},{"role":"assistant","content":"```saw\nenable_experimental;\nm <- yosys_import_sequential \"seqgen\" \"test.json\";\n\nyosys_verify_sequential_offline_sally m \"test.mcmt\" {{\n  \\(cycles : [8]) (i : {reset : [1], C : [1], G : [1], P : [1]}) (s : {S : [1]}) ->\n    ( (cycles > 1)\n    && (i.G == 0)\n    && (i.C == 1)\n    && (i.P == 1)\n    ) ==>\n      (s.S == 1)\n  }}\n  [\"C\", \"G\", \"P\", \"reset\"];\n```"}]}
{"filename":"saw-script\/intTests\/test1703\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the C function uint32_t weird(uint32_t cv[8], uint8_t i) defined in test.c. Load the LLVM module from test.bc using llvm_load_module. Define a let-bound spec named weird_spec that uses llvm_fresh_var to create symbolic inputs for the array cv (an array of 8 uint32_t) and the index i (uint8_t). Allocate memory for cv and initialize it with the symbolic array. Add minimal preconditions to ensure safe indexing, such as using modulo 8 on i. Execute the weird function with these inputs and return the function's result. Finally, verify the function weird against weird_spec using llvm_verify with no additional overrides or solver options.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n\nuint32_t weird(uint32_t cv[8], uint8_t i) {\n    return cv[i % 8];\n}\n\n```"},{"role":"assistant","content":"```saw\nimport \"test.cry\";\n\nlet weird_spec = do {\n  cv <- llvm_fresh_var \"cv\" (llvm_array 8 (llvm_int 32));\n  cv_p <- llvm_alloc (llvm_array 8 (llvm_int 32));\n  llvm_points_to cv_p (llvm_term {{ cv }});\n  i <- llvm_fresh_var \"i\" (llvm_int 8);\n\n  llvm_execute_func [cv_p, llvm_term i];\n\n  llvm_return (llvm_term {{ weird cv i }});\n};\n\nm <- llvm_load_module \"test.bc\";\nllvm_verify m \"weird\" [] false weird_spec (w4_unint_z3 []);\n```"}]}
{"filename":"saw-script\/intTests\/test_jvm_setup_errors\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java class 'Test' defined in 'Test.java' using the JVM backend. Define let-bound specs for the methods 'get', 'set', 'lessThan', 'lookup', and 'next'. Use 'java_load_class' to load 'Test'. For each spec, allocate symbolic inputs with 'jvm_fresh_var' as needed, ensure minimal preconditions for safety (e.g., array bounds for 'lookup'), and use appropriate JVM setup commands such as 'jvm_alloc_object', 'jvm_alloc_array', 'jvm_field_is', 'jvm_static_field_is', 'jvm_execute_func', and 'jvm_return'. Do not inline the specs; bind them with 'let <name>_spec = do { ... };'. Reference exact method names and signatures from 'Test.java'.\n\n# Source code:\nTest.java\n```java\nclass Test\n{\n    long val;\n    static long counter;\n\n    long get () {\n        return val;\n    }\n    void set (long x) {\n        val = x;\n    }\n    boolean lessThan (Test t) {\n        return val < t.val;\n    }\n    static long lookup (long arr[], int idx) {\n        return arr[idx];\n    }\n    static long next () {\n        counter = counter + 1;\n        return counter;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\n\/*\n\nThis file is intended to test the error checking for ill-formed\n`JVMSetup` blocks. All setup blocks will be tested with\n`jvm_unsafe_assume_spec`, in order to make sure that the errors are\ncaught at the early phase when the setup block is processed, and that\nwe do not rely on run-time errors during symbolic simulation to catch\nproblems.\n\nThis file is necessarily incomplete, and should be extended with new\nadditional tests as we add new checks to the SAW\/JVM code.\n\nAny tests listed as \"KNOWN FALSE POSITIVE\" represent known bugs in\nsaw-script.\n\n*\/\n\ntest <- java_load_class \"Test\";\n\nprint test;\n\nlet check_fails cls name spec =\n  fails (jvm_unsafe_assume_spec cls name spec);\n\nlet KNOWN_FALSE_POSITIVE cls name spec =\n  do {\n    print \"KNOWN FALSE POSITIVE:\";\n    fails (check_fails cls name spec);\n  };\n\nprint \"Working spec for method 'get'\";\njvm_verify test \"get\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  } z3;\n\nprint \"jvm_field_is with non-monomorphic type\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    let val = {{ 0 }};\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_field_is with non-jvm type\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    let val = {{ 0 : Integer }};\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_field_is with wrong type\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    let val = {{ 0 : [32] }};\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_field_is with array reference\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_array 12 java_int;\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_field_is with null reference\";\ncheck_fails test \"get\"\n  do {\n    let this = jvm_null;\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_field_is with non-reference\";\ncheck_fails test \"get\"\n  do {\n    let this = jvm_term {{ 0:[32] }};\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_field_is with non-existent field name\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"var\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_field_is with previous jvm_field_is on same field\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_field_is this \"val\" (jvm_term {{ 0 : [64] }});\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_modifies_field in pre-state section\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_modifies_field this \"val\";\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"Working spec for method 'next'\";\njvm_verify test \"next\" [] false\n  do {\n    ctr <- jvm_fresh_var \"ctr\" java_long;\n    jvm_static_field_is \"counter\" (jvm_term ctr);\n    jvm_execute_func [];\n    let ctr' = {{ ctr + 1 }};\n    jvm_static_field_is \"counter\" (jvm_term ctr');\n    jvm_return (jvm_term ctr');\n  } z3;\n\nprint \"jvm_static_field_is with non-monomorphic type\";\ncheck_fails test \"next\"\n  do {\n    let ctr = {{ 0 }};\n    jvm_static_field_is \"counter\" (jvm_term ctr);\n    jvm_execute_func [];\n    let ctr' = {{ 1 }};\n    jvm_static_field_is \"counter\" (jvm_term ctr');\n    jvm_return (jvm_term ctr');\n  };\n\nprint \"jvm_static_field_is with non-jvm type\";\ncheck_fails test \"next\"\n  do {\n    let ctr = {{ 0 : Integer }};\n    jvm_static_field_is \"counter\" (jvm_term ctr);\n    jvm_execute_func [];\n    let ctr' = {{ ctr + 1 }};\n    jvm_static_field_is \"counter\" (jvm_term ctr');\n    jvm_return (jvm_term ctr');\n  };\n\nprint \"jvm_static_field_is with wrong type\";\ncheck_fails test \"next\"\n  do {\n    let ctr = {{ 0 : [32] }};\n    jvm_static_field_is \"counter\" (jvm_term ctr);\n    jvm_execute_func [];\n    let ctr' = {{ ctr + 1 }};\n    jvm_static_field_is \"counter\" (jvm_term ctr');\n    jvm_return (jvm_term ctr');\n  };\n\nprint \"jvm_static_field_is with non-existent field name\";\ncheck_fails test \"next\"\n  do {\n    ctr <- jvm_fresh_var \"ctr\" java_long;\n    jvm_static_field_is \"count\" (jvm_term ctr);\n    jvm_execute_func [];\n    let ctr' = {{ ctr + 1 }};\n    jvm_static_field_is \"count\" (jvm_term ctr');\n    jvm_return (jvm_term ctr');\n  };\n\nprint \"jvm_static_field_is with previous jvm_static_field_is on same field\";\ncheck_fails test \"next\"\n  do {\n    ctr <- jvm_fresh_var \"ctr\" java_long;\n    jvm_static_field_is \"counter\" (jvm_term ctr);\n    jvm_static_field_is \"counter\" (jvm_term ctr);\n    jvm_execute_func [];\n    let ctr' = {{ ctr + 1 }};\n    jvm_static_field_is \"counter\" (jvm_term ctr');\n    jvm_return (jvm_term ctr');\n  };\n\nprint \"jvm_modifies_static_field in pre-state section\";\ncheck_fails test \"next\"\n  do {\n    ctr <- jvm_fresh_var \"ctr\" java_long;\n    jvm_modifies_static_field \"counter\";\n    jvm_execute_func [];\n    let ctr' = {{ ctr + 1 }};\n    jvm_static_field_is \"counter\" (jvm_term ctr');\n    jvm_return (jvm_term ctr');\n  };\n\nprint \"Working spec for method 'lookup'\";\njvm_verify test \"lookup\" [] false\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  } z3;\n\nprint \"jvm_elem_is with non-monomorphic type\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 2 : [32] }};\n    let x = {{ 0 }};\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with non-jvm type\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 2 : [32] }};\n    let x = {{ zero : ([8], [8]) }};\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with wrong type\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_int;\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with object reference\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_object \"Test\";\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with null reference\";\ncheck_fails test \"lookup\"\n  do {\n    let arr = jvm_null;\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with non-reference\";\ncheck_fails test \"lookup\"\n  do {\n    let arr = jvm_term {{ 5 : [32] }};\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with index out of bounds\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 12 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_elem_is arr 12 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with previous jvm_array_is\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    xs <- jvm_fresh_var \"xs\" (java_array 32 java_long);\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_elem_is with previous jvm_elem_is on same index\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_elem_is arr 2 (jvm_term x);\n    jvm_elem_is arr 2 (jvm_term {{ 0 : [64] }});\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"jvm_modifies_elem in pre-state section\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_modifies_elem arr 2;\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"Working spec for method 'lookup' (jvm_array_is)\";\njvm_verify test \"lookup\" [] false\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    xs <- jvm_fresh_var \"xs\" (java_array 8 java_long);\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  } z3;\n\nprint \"jvm_array_is with non-monomorphic type\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let xs = {{ zero }};\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with non-array type\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let xs = {{ (True, False) }};\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ 0 : [64] }});\n  };\n\nprint \"jvm_array_is with wrong array length\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    xs <- jvm_fresh_var \"xs\" (java_array 4 java_long);\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with non-jvm element type\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let xs = {{ zero : [8]Integer }};\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with wrong array element type\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    xs <- jvm_fresh_var \"xs\" (java_array 8 java_int);\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with object reference\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_object \"Test\";\n    xs <- jvm_fresh_var \"xs\" (java_array 8 java_long);\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with null reference\";\ncheck_fails test \"lookup\"\n  do {\n    let arr = jvm_null;\n    xs <- jvm_fresh_var \"xs\" (java_array 8 java_long);\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with non-reference\";\ncheck_fails test \"lookup\"\n  do {\n    let arr = jvm_term {{ True }};\n    xs <- jvm_fresh_var \"xs\" (java_array 8 java_long);\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with previous jvm_array_is\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    xs <- jvm_fresh_var \"xs\" (java_array 8 java_long);\n    jvm_array_is arr xs;\n    jvm_array_is arr {{ zero : [8][64] }};\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_array_is with previous jvm_elem_is\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    xs <- jvm_fresh_var \"xs\" (java_array 8 java_long);\n    jvm_elem_is arr 2 (jvm_term {{ 0 : [64] }});\n    jvm_array_is arr xs;\n    let idx = {{ 2 : [32] }};\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term {{ xs @ idx }});\n  };\n\nprint \"jvm_modifies_array in pre-state section\";\ncheck_fails test \"lookup\"\n  do {\n    arr <- jvm_alloc_array 8 java_long;\n    let idx = {{ 2 : [32] }};\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_modifies_array arr;\n    jvm_execute_func [arr, jvm_term idx];\n    jvm_return (jvm_term x);\n  };\n\nprint \"Working spec for method 'set'\";\njvm_verify test \"set\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this \"val\" (jvm_term x);\n  } z3;\n\nprint \"jvm_execute_func with non-monomorphic types\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term {{ 0 }}];\n    jvm_field_is this \"val\" (jvm_term x);\n  };\n\nprint \"jvm_execute_func with non-jvm types\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term {{ 0 : Integer }}];\n    jvm_field_is this \"val\" (jvm_term x);\n  };\n\nprint \"jvm_execute_func with wrong types\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term {{ drop`{32} x }} ];\n    jvm_field_is this \"val\" (jvm_term x);\n  };\n\nprint \"jvm_execute_func with reference type when base type was expected\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, this];\n    jvm_field_is this \"val\" (jvm_term x);\n  };\n\nprint \"jvm_execute_func with base type when reference type was expected\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [jvm_term x, jvm_term x];\n    jvm_field_is this \"val\" (jvm_term x);\n  };\n\nprint \"jvm_execute_func with too few arguments\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this];\n    jvm_field_is this \"val\" (jvm_term x);\n  };\n\nprint \"jvm_execute_func with too many arguments\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term x, jvm_null];\n    jvm_field_is this \"val\" (jvm_term x);\n  };\n\n\/\/ (this is issue #946)\nprint \"multiple use of jvm_execute_func\";\nKNOWN_FALSE_POSITIVE test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  };\n\nprint \"jvm_return with non-monomorphic type\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term {{ 0 }});\n  };\n\nprint \"jvm_return with non-jvm type\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term {{ 0 : Integer }});\n  };\n\nprint \"jvm_return with wrong base type\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term {{ 0 : [32] }});\n  };\n\nprint \"jvm_return with reference type when base type was expected\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return this;\n  };\n\nprint \"jvm_return missing when one was expected\";\nKNOWN_FALSE_POSITIVE test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n  };\n\nprint \"jvm_return when none was expected\";\ncheck_fails test \"set\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this \"val\" (jvm_term x);\n    jvm_return (jvm_term x);\n  };\n\nprint \"multiple use of jvm_return\";\ncheck_fails test \"get\"\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term {{ val }});\n    jvm_return (jvm_term {{ val }});\n  };\n\n\nprint \"DONE!\";\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_x86_05\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"test.bc\" that verifies the function \"test\" with signature \"uint32_t test()\". Define a let-bound specification named \"test_spec\" that uses symbolic inputs if needed, calls the \"test\" function via llvm_execute_func, and asserts the expected behavior based on the \"returntest\" function it calls. Include any minimal preconditions required for safety or termination. Then invoke llvm_verify_x86 with the module, the symbol \".\/test\", the function name \"test\", an empty argument list, no optimization, the defined \"test_spec\", and the 4-byte word width.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n#include <stdio.h>\n\nextern uint32_t returntest();\n\nuint32_t test() {\n\treturn returntest();\n};\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet returntest_setup = do {\n  llvm_execute_func [];\n\n  llvm_return (llvm_term {{ 42 : [32] }});\n};\nllvm_verify_x86 m \".\/returntest\" \"returntest\" [] false returntest_setup w4;\n```"}]}
{"filename":"saw-script\/intTests\/test0048_alloc_post\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from test.bc and verifies the function make_A with signature (struct.B) -> struct.A*. Define a let-bound spec named make_A_spec that creates a symbolic variable b of type struct.B, executes make_A with b as input, allocates memory for struct.A, asserts that the field b of the returned pointer equals the input b, and returns the pointer. Use llvm_fresh_var for symbolic inputs and llvm_points_to for memory assertions. Then call llvm_verify with the module, function name \"make_A\", no extra arguments, false for optimization, the spec make_A_spec, and the solver z3.\n\n# Source code:\ntest.c\n```C\n#include <stdlib.h>\n\ntypedef struct B {\n  int x;\n} B_t;\n\ntypedef struct A {\n  B_t b;\n} A_t;\n\nA_t* make_A(B_t b) {\n  A_t* ptr = malloc(sizeof(A_t));\n  ptr->b = b;\n  return ptr;\n}\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\nlet make_A_spec = do {\n  b <- llvm_fresh_var \"b\" (llvm_type \"%struct.B\");\n  llvm_execute_func [llvm_term b];\n  a_ptr <- llvm_alloc (llvm_type \"%struct.A\");\n  llvm_points_to (llvm_field a_ptr \"b\") (llvm_term b);\n  llvm_return a_ptr;\n};\nllvm_verify m \"make_A\" [] false make_A_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test1998_mir\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from test.linked-mir.json and verifies the function test::f. Define a let-bound spec named f_spec that uses llvm_fresh_var to create two symbolic 32-element arrays of 16-bit unsigned integers as inputs, adds any necessary preconditions for safety, executes test::f with these inputs, and returns true. Use llvm_load_module and llvm_verify accordingly."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet f_spec = do {\n    x <- mir_fresh_expanded_value \"x\" (mir_array 32 mir_u16);\n    y <- mir_fresh_expanded_value \"y\" (mir_array 32 mir_u16);\n    mir_equal x y;\n\n    mir_execute_func [x, y];\n\n    mir_return (mir_term {{ True }});\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\nmir_verify m \"test::f\" [] false f_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test0052_smt_array_1\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the behavior of array update and lookup operations as defined in the given module. Ensure the properties capture that updating an array at index i with element e results in the lookup at i returning e, and that updating at a different index j does not affect the lookup at i."},{"role":"assistant","content":"```cryptol\nmodule ArrayTest where\n\nimport Array\n\nlookup_update_axiom_1 : Array [64] [64] -> [64] -> [64] -> Bit\nlookup_update_axiom_1 a i e = arrayLookup (arrayUpdate a i e) i == e\n\nlookup_update_axiom_2 : Array [64] [64] -> [64] -> [64] -> [64] -> Bit\nlookup_update_axiom_2 a i j e = i != j ==> arrayLookup (arrayUpdate a j e) i == arrayLookup a i\n```"}]}
{"filename":"saw-script\/intTests\/test_hash_table\/ht_simplified.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"ht_simplified.bc\" that verifies the functions hash(uint64_t), get_bucket(uint64_t), init_table(void), and increment_value(uint64_t). Define let-bound specs named hash_spec, get_bucket_spec, init_table_spec, and increment_value_spec respectively. Use llvm_fresh_var to create symbolic inputs of type uint64_t for the functions taking arguments. Add necessary preconditions such as NUMBUCKETS >= 1 for get_bucket and is_valid_state for increment_value to ensure safety and termination. Use llvm_execute_func with the symbolic inputs and check postconditions including return values and state invariants referencing the exact C function signatures. Do not inline specs; bind them with let. Do not reference solvers or add comments.\n\n# Source code:\nht_simplified.c\n```C\n\/**\n * pure C hash table for call path throttling.\n *\n * constraints:\n *   - static pool of memory\n *   - uint64_t key\n *   - uint32_t value\n *\n * notes:\n *   - error when pool exhausted : no eviction or reuse policy\n *   - fixed number of buckets: we don't rebalance if some buckets get long\n *     entry chains\n *\n * Author: Matthew Sottile\n *         sottile2@llnl.gov \n * \n * June 2023\n *\/\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\/* global assumptions\n\n   POOLSIZE never changes\n   NUMBUCKETS never changes\n   CAP never changes\n*\/\n\ntypedef struct Entry {\n  uint64_t key;\n  uint32_t value;\n  uint32_t next;\n} Entry;\n\n#define POOLSIZE   5\n#define NUMBUCKETS 2\n#define NULLINDEX UINT32_MAX\n#define CAP 5\n\n\/* statically allocated pool of slots *\/\nEntry entry_pool[POOLSIZE];\n\ntypedef struct PooledHashTable {\n  uint32_t buckets[NUMBUCKETS];\n  uint32_t cur_entry;\n} PooledHashTable;\n\nPooledHashTable ptable;\n\nvoid init_table() {\n  ptable.cur_entry = 0;\n  for (int i = 0; i < NUMBUCKETS; i++) {\n    ptable.buckets[i] = NULLINDEX;\n  }\n}\n\n\/*\n * djb2 hash function\n *\/\nuint32_t hash(uint64_t v) {\n  uint32_t h = 5381;\n  uint8_t c;\n  for (int i = 0; i < 64; i+=8) {\n    c = (v >> i) & 0xff;\n    h = 33 * h + c;\n  }\n  return h;\n}\n\nuint32_t get_bucket(uint64_t key) {\n  return hash(key) % NUMBUCKETS;\n}\n\nuint32_t increment_value(uint64_t key) {\n  uint32_t bucket = get_bucket(key);\n  uint32_t cur_index = ptable.buckets[bucket];\n  uint32_t prev_index = NULLINDEX;\n\n  while (cur_index != NULLINDEX) {\n    Entry *cur_entry = &entry_pool[cur_index];\n    \/\/ key has a slot: increment and return value\n    if (cur_entry->key == key) {\n      if (cur_entry->value < CAP) {\n        cur_entry->value++;\n      }\n      return cur_entry->value;\n    } else {\n      prev_index = cur_index;\n      cur_index = cur_entry->next;\n    }\n  }\n\n  if (ptable.cur_entry < POOLSIZE) {\n    cur_index = ptable.cur_entry;\n    Entry *cur_entry = &entry_pool[cur_index];\n    if(prev_index != NULLINDEX)\n    {\n      Entry *prev_entry =  &entry_pool[prev_index];\n      prev_entry->next = ptable.cur_entry;\n    }\n    else\n    {\n      ptable.buckets[bucket] = cur_index;\n    }\n    ptable.cur_entry++;\n    cur_entry->key = key;\n    cur_entry->next = NULLINDEX;\n    cur_entry->value = 1;\n    \n    return 1;\n  }\n\n  return 0;\n}\n\nint main(int argc, char **argv) {\n  init_table();\n  for (int i = 0; i < 2000; i++) {\n    uint64_t v = random() % 104;\n    uint32_t c = increment_value(v);\n    if (c == 0) {\n      printf(\"Could not track %ld: at capacity (%d iterations).\\n\", v, i);\n      break;\n    }\n    printf(\"V=%ld C=%d\", v, c);\n    if (c == CAP) {\n      printf(\" [CAPPED]\");\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nimport \"ht_simplified.cry\";\n\nlet uint32_t = llvm_int 32;\nlet uint64_t = llvm_int 64;\n\nlet setup_tuple (type : LLVMType) (name : String) = do {\n  cfvTerm <- llvm_fresh_var name type;\n  let setupVal = llvm_term cfvTerm;\n  return (setupVal, cfvTerm);\n};\n\nlet global_setup name = do {\n    llvm_alloc_global name;\n    let p = (llvm_global name);\n    return p;\n};\n\nlet check_ptable ptable table = do {\n    llvm_points_to ptable (llvm_term {{pooledHashTableToTuple table}});\n};\n\nlet check_entry_pool entry_pool_p ep = do\n{\n    llvm_points_to entry_pool_p (llvm_term {{map entryToTuple ep}});\n};\n\nlet check_state ptable_p entry_pool_p state = do\n{\n    check_entry_pool entry_pool_p ({{state.ep}});\n    check_ptable ptable_p ({{state.pht}});\n};\n\nm  <- llvm_load_module \"ht_simplified.bc\";\n\nlet hash_ok = do {\n    (ve,vc) <- (setup_tuple uint64_t \"v\");\n    llvm_execute_func[ve];\n    llvm_return (llvm_term {{ hash (vc) }});\n};\n\nlet get_bucket_ok = do {   \n    (ke,kv) <- (setup_tuple uint64_t \"key\");\n    llvm_precond {{`NUMBUCKETS >= 1}};\n    llvm_execute_func[ke];\n    let return_spec = {{ getBucket (kv) }};\n    llvm_return (llvm_term return_spec);\n    llvm_postcond {{return_spec < `NUMBUCKETS }};\n};\n\n\n\n\/\/ Initialize function holds invariant.\nlet init_table_spec = do {\n    llvm_alloc_global \"entry_pool\";\n    entry_pool <- llvm_fresh_var \"entry_pool\" (llvm_array (eval_size {| POOLSIZE |}) (llvm_alias \"struct.Entry\"));\n    llvm_points_to (llvm_global \"entry_pool\") (llvm_term entry_pool);\n    llvm_alloc_global \"ptable\";\n\n    llvm_execute_func [];\n\n    let res = {{ pooledHashTableToTuple initTable }};\n    llvm_points_to (llvm_global \"ptable\") (llvm_term res);\n    let initState = {{ {ep = (tupleToEntryPool entry_pool), pht = initTable} }};\n    llvm_postcond {{ is_valid_state initState }};\n};\n\nlet increment_value_spec = do {\n    llvm_alloc_global \"entry_pool\";\n    entry_pool <- llvm_fresh_var \"entry_pool\" (llvm_array (eval_size {| POOLSIZE |}) (llvm_alias \"struct.Entry\"));\n    llvm_points_to (llvm_global \"entry_pool\") (llvm_term entry_pool);\n    llvm_alloc_global \"ptable\";\n    ptable <- llvm_fresh_var \"ptable\" (llvm_alias \"struct.PooledHashTable\");\n    llvm_points_to (llvm_global \"ptable\") (llvm_term ptable);\n\n    key <- llvm_fresh_var \"key\" uint64_t;\n\n    \/\/ Assume invariant holds on initial state.\n    let initialState = {{tupleToState (entry_pool, ptable)}};\n    llvm_precond (normalize_term {{ is_valid_state initialState }});\n\n    let initialCurrentEntry = {{initialState.pht.cur_entry}};\n\n    llvm_execute_func [llvm_term key];\n    let return_spec = {{ incrementValueFull key initialState}};\n\n    entry_pool' <- llvm_fresh_var \"entry_pool'\" (llvm_array (eval_size {| POOLSIZE |}) (llvm_alias \"struct.Entry\"));\n    llvm_points_to (llvm_global \"entry_pool\") (llvm_term entry_pool');\n    ptable' <- llvm_fresh_var \"ptable\" (llvm_alias \"struct.PooledHashTable\");\n    llvm_points_to (llvm_global \"ptable\") (llvm_term ptable');\n    let finalState = {{tupleToState (entry_pool', ptable')}};\n\n    \/\/ Invariant holds on end state\n    llvm_postcond {{ is_valid_state finalState }};\n\n    \/\/ Check if function is equivalent to cryptol spec\n    llvm_return (llvm_term {{ return_spec.value }});\n    check_state (llvm_global \"ptable\") (llvm_global \"entry_pool\") {{return_spec.state}};\n\n    \/\/Check if cryptol spec holds post conditions.\n\n    \/\/If modified slot is null then we weren't able to find a spot in entry pool value should be zero.\n    llvm_postcond {{(return_spec.slot == NULL) ==> return_spec.value == 0}};\n\n    \/\/Entry that was modified\n    let modifiedEntry = {{return_spec.state.ep@(return_spec.slot)}};\n\n    \/\/Otherwise key should be == key given\n    llvm_postcond {{(return_spec.slot != NULL) ==> modifiedEntry.key == key }};\n\n    \/\/Value should be equivalent of what is was returned\n    llvm_postcond {{(return_spec.slot != NULL) ==> ((modifiedEntry.value == return_spec.value) \/\\ (modifiedEntry.value > 0) \/\\ (modifiedEntry.value <= CAP)) }};\n\n    \/\/If we grabed from the entry pool.\n    llvm_postcond {{(return_spec.slot == initialCurrentEntry) ==> ((modifiedEntry.next == NULL) \/\\ (modifiedEntry.value == 1))}};\n    llvm_postcond {{(return_spec.slot == initialCurrentEntry) ==> return_spec.state.pht.cur_entry == initialCurrentEntry + 1}};\n\n    \n};\n\n\nlet main : TopLevel () = do {\n    hash <- llvm_verify m \"hash\" [] true hash_ok (w4_unint_z3 []);\n    get_bucket <- llvm_verify m \"get_bucket\" [hash] true get_bucket_ok (w4_unint_z3 []);\n    init <- llvm_verify m \"init_table\" [] true init_table_spec (w4_unint_z3 []);\n\n    enable_what4_eval;\n    llvm_verify m \"increment_value\" [] true increment_value_spec (w4_unint_z3 []);\n    print \"Done!\";\n};\n```"}]}
{"filename":"saw-script\/intTests\/test_hash_table\/ht_simplified.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the `incrementValueFull` function in the given simplified hash table module. The properties should ensure that the function correctly increments the value associated with a given key in the hash table state, respects the capacity limits, maintains the validity of the state, and properly updates the entry pool and bucket pointers. Include properties that check termination conditions, preservation of invariants such as valid indices and value caps, and correct behavior when keys are present or absent in the table."},{"role":"assistant","content":"```cryptol\nmodule HT where\n\ntype Entry =   \n    { key    : [64]\n    , value  : [32]\n    , next   : [32]\n    }\n\ntype EntryTuple = ([64],[32],[32])\n\nentryToTuple : Entry -> EntryTuple\nentryToTuple e = (e.key, e.value, e.next)\n\ntupleToEntry : EntryTuple -> Entry\ntupleToEntry (key_t, value_t, next_t) = {key = key_t, value = value_t, next = next_t}\n\ntype NUMBUCKETS = 2\n\ntype POOLSIZE = 5\n\nNULL : [32]\nNULL = 0xffffffff\n\nCAP : [32]\nCAP = 5\n\ntype PooledHashTable =   \n    { buckets    : [NUMBUCKETS][32]\n    , cur_entry  : [32]\n    }\n\ntype PooledHashTableTuple = ([NUMBUCKETS][32],[32])\n\npooledHashTableToTuple : PooledHashTable -> PooledHashTableTuple\npooledHashTableToTuple pt = (pt.buckets, pt.cur_entry)\n\ntupleToPooledHashTable : PooledHashTableTuple -> PooledHashTable\ntupleToPooledHashTable (bucket_tuple,cur_entry_tuple) = {buckets = bucket_tuple, cur_entry = cur_entry_tuple}\n\ntype EntryPool = [POOLSIZE] Entry\n\ntype EntryPoolTuple = [POOLSIZE]([64], [32], [32])\n\nentryPoolToTuple : EntryPool -> EntryPoolTuple\nentryPoolToTuple ep = map entryToTuple ep\n\ntupleToEntryPool : EntryPoolTuple -> EntryPool\ntupleToEntryPool ep = map tupleToEntry ep\n\ninitTable : PooledHashTable\ninitTable = {cur_entry = 0, buckets = repeat NULL}\n\ninitEntry : Entry\ninitEntry = {key = 0, value = 0, next = NULL}\n\ninitEntryPool : EntryPool\ninitEntryPool = zero\n\nhash : [64] -> [32]\nhash v = foldr (\\c h -> 33 * h + (0 # c)) 5381 ((split v):[8][8])\n\ngetBucket : [64] -> [32]\ngetBucket key = hash(key) % `NUMBUCKETS\n\ntype State = { ep : EntryPool\n             , pht : PooledHashTable\n             }\n\nerrorState : State\nerrorState = zero:State\n\nstateToTuple : State -> ([POOLSIZE]([64], [32], [32]), ([NUMBUCKETS][32], [32]))\nstateToTuple state = (entryPoolToTuple state.ep, pooledHashTableToTuple state.pht)\n\ntupleToState : ([POOLSIZE]([64], [32], [32]), ([NUMBUCKETS][32], [32])) -> State\ntupleToState (entryPoolTuple, phtTuple) = {ep = tupleToEntryPool entryPoolTuple, pht = tupleToPooledHashTable phtTuple}\n\ninitState : State\ninitState = {ep = initEntryPool, pht = initTable}\n\ntype IncrementValueRet = { value : [32]\n                         , slot : [32]\n                         , state : State\n                         }\n\nis_valid_index : [32] -> [32] -> Bool\nis_valid_index n i = i < n \\\/ i == NULL\n\n\/\/ Entry Pool and Pooled Hash Table\nis_valid_state : State -> Bool\nis_valid_state state =\n  state.pht.cur_entry <= `POOLSIZE\n  \/\/ All of the buckets are <= cur_entry or NULL\n  \/\\ all (is_valid_index state.pht.cur_entry) state.pht.buckets\n  \/\/ for all entries at index i, next <= cur_entry or NULL, i < next, value <= cap.\n  \/\\ all (\\(i, e) -> i < state.pht.cur_entry ==> ((is_valid_index state.pht.cur_entry e.next) \/\\ i < e.next \/\\ e.value <= CAP)) (zip (take [0 ...]) state.ep)\n\nupdatePrev : EntryPool -> [32] -> [32] -> EntryPool\nupdatePrev epIn cur_index prev_index = ret where\n    prevEntry = epIn@prev_index\n    ret = update epIn prev_index {key = prevEntry.key, value = prevEntry.value, next = cur_index }\n\nincrementNextValue1 : [64] -> [32] -> [32] -> State -> IncrementValueRet\nincrementNextValue1 key prev_index bucket state = ret where\n    cur_index = state.pht.cur_entry\n    newEp = update state.ep cur_index {key = key, value = 1, next = NULL}\n    ret = if(prev_index != NULL) \n        then \n            { value = 1\n            , slot = cur_index \n            , state = \n              { ep = updatePrev newEp cur_index prev_index \n              , pht = {cur_entry = cur_index + 1, buckets = state.pht.buckets}\n              }\n            }\n        else \n            { value = 1\n            , slot = cur_index\n            , state = \n              { ep = newEp\n              , pht = {cur_entry = cur_index + 1, buckets = update state.pht.buckets bucket cur_index}\n              }\n            }\n\nincrementNextValue : [64] -> [32] -> [32] -> State -> IncrementValueRet\nincrementNextValue key prev_index bucket state = \n    if (state.pht.cur_entry < `POOLSIZE) \n        then incrementNextValue1 key prev_index bucket state\n        else {value = 0, slot = NULL, state = state}\n\n\nincrementValueLoop : [64] -> [64] -> [32] -> [32] -> State -> (Bool, [32], [32], ([32], State))\nincrementValueLoop count key cur_index prev_index state = \n    \/\/ Need something obviously terminating errorState is never reached as it is not a valid_state. \n    if (count <= 0) then (False, NULL, NULL, (0, errorState))\n    else \n        if (cur_index == NULL)\n            then (True, cur_index, prev_index, (0, state))\n            else checkCurEntry count key cur_index prev_index state\n\ncheckCurEntry : [64] -> [64] -> [32] -> [32] -> State -> (Bool, [32], [32], ([32], State))\ncheckCurEntry count key cur_index prev_index state = ret where\n    cur_entry = state.ep@cur_index\n    ret = if(cur_entry.key == key)\n        then keyHit key cur_index prev_index cur_entry state\n        else incrementValueLoop (count - 1) key cur_entry.next cur_index state\n\nkeyHit : [64] -> [32] -> [32] -> Entry -> State -> (Bool, [32], [32], ([32], State))\nkeyHit key cur_index prev_index cur_entry state = ret where\n    curValue = cur_entry.value\n    ret = if (curValue < CAP) \n        then (False, cur_index, prev_index, (curValue + 1, {ep = (update state.ep cur_index {key = cur_entry.key, value = curValue + 1, next = cur_entry.next}), pht = state.pht}))\n        else (False, cur_index, prev_index, (curValue, state))\n     \nincrementValueFull : [64] -> State -> IncrementValueRet\nincrementValueFull key state = ret where\n    bucket = getBucket(key)\n    cur_index = state.pht.buckets@bucket\n    prev_index = NULL\n    (continue, n_cur_index, n_prev_index, (value, nstate)) = incrementValueLoop (`POOLSIZE + 1) key cur_index prev_index state\n    ret = if continue then incrementNextValue key n_prev_index bucket nstate else {value = value, slot = n_cur_index, state = nstate}\n```"}]}
{"filename":"saw-script\/intTests\/test2204\/test1.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated source files using the appropriate backend inferred from the presence of 'llvm_load_module' or 'java_load_class'. Define a let-bound specification named 'f_spec' that symbolically verifies the function 'f' with a fresh symbolic input and checks that the output equals the input. Similarly, define 'g_spec' for the function 'g' taking two symbolic inputs and verifying the output tuple matches the inputs. Define 'h_spec' for the function 'h' that returns a monadic value, verifying it returns the input wrapped appropriately. Use 'llvm_fresh_var' or 'jvm_fresh_var' for symbolic inputs, include minimal preconditions for safety, and invoke the verification commands referencing these specs and exact function signatures from the source files."},{"role":"assistant","content":"```saw\nlet f (x : a) : a = x;\nlet g (x : a) (y : b) : (a, b) = (x, y);\n\nlet h (x : a) : m a = do {\n   return x;\n};\n```"}]}
{"filename":"saw-script\/intTests\/test2009\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the provided source files using llvm_load_module. Define a let-bound specification named pairEq_spec that symbolically inputs two 32-bit vectors of booleans and uses the parsed core expression pairEq with bvEq 32 for equality checks. Use llvm_fresh_var to create symbolic inputs representing 32-bit vectors, and include minimal preconditions to ensure safety. Prove the property that for any input x, pairEq applied to (x, x + 1) and (x, 1 + x) holds, referencing the exact function pairEq as defined in the LLVM module. Do not include comments or solver references in the SAWScript."},{"role":"assistant","content":"```saw\nlet pairEq = parse_core \"pairEq (Vec 32 Bool) (Vec 32 Bool) (bvEq 32) (bvEq 32)\";\nt <- prove_print w4 {{ \\x -> pairEq (x, x + 1) (x, 1 + x) }};\nprint_term (rewrite (addsimp t empty_ss) {{ (0 : [32], 0 + 1 : [32]) }});\n```"}]}
{"filename":"saw-script\/intTests\/test_univ_assert\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated C or Java source files using the appropriate backend inferred from the presence of llvm_load_module or java_load_class. Define a let-bound specification named <function>_spec that uses symbolic inputs created with llvm_fresh_var or jvm_fresh_var matching the exact function or method signatures from the source. Include minimal preconditions necessary for safety such as array bounds or nonzero divisors. Then verify the implementation against the specification by invoking the loaded function symbolically. Do not inline the spec or reference solvers explicitly. The SAWScript must directly reference the exact symbol names and signatures from the source files and contain no comments or markdown."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet {{\n  type vec_t = [384]\n  mul : vec_t -> vec_t -> vec_t\n  mul x y = undefined \/\/ this would be e.g. multiplication modulo p\n  add : vec_t -> vec_t -> vec_t\n  add x y = undefined\n\n  term1 x y z1 z2 z3 = add (mul (add (mul (add (mul x y) z1) x) z2) x) z3\n  term2 x y z1 z2 z3 = add (mul y (mul x (mul x x))) (add (mul z1 (mul x x)) (add (mul z2 x) z3))\n}};\n\n\/\/ Assume some of the ring axioms\nlemmas <- for\n  [ {{ \\x y -> mul x y == mul y x }}\n  , {{ \\x y -> add x y == add y x }}\n  , {{ \\x y z -> mul (mul x y) z == mul x (mul y z) }}\n  , {{ \\x y z -> add (add x y) z == add x (add y z) }}\n  , {{ \\x y z -> mul (add x y) z == add (mul x z) (mul y z) }}\n  ]\n  (prove_print assume_unsat);\n\n\/\/ Use those axioms to prove a nontrivial equality\nthm <- prove_print\n  (do {\n    unfolding [\"term1\",\"term2\"];\n    for lemmas goal_insert;\n    w4_unint_z3 [\"mul\",\"add\"];\n  })\n  {{ \\x y z1 z2 z3 -> term1 x y z1 z2 z3 == term2 x y z1 z2 z3 }};\n\nprint thm;\n```"}]}
{"filename":"saw-script\/intTests\/test0037_popcount\/spec.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the 'popcount', 'clz', and 'ctz' functions. The properties should check that 'popcount' correctly counts the number of set bits in a bitvector, 'clz' returns the count of leading zeros, and 'ctz' returns the count of trailing zeros by leveraging 'clz' on the reversed input. Include tests for various input sizes and edge cases to ensure the functions behave as expected."},{"role":"assistant","content":"```cryptol\npopcount : {n} (n >= 1, fin n) => [n] -> [n]\npopcount x = foldr (+) zero [ if b then 1 else 0 | b <- x ]\n\nclz : {n} fin n => [n] -> [n]\nclz x = foldr f `n [ (b,i) | i <- [0 ...] | b <- x ]\n where\n f (b,i) r = if b then i else r\n\nctz : {n} fin n => [n] -> [n]\nctz x = clz (reverse x)\n```"}]}
{"filename":"saw-script\/intTests\/test0037_popcount\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from '.\/test.bc' that verifies the correctness of the functions 'popcount', 'clz', and 'ctz' defined in 'test.c'. Define a let-bound specification for each function (e.g., let popcount_spec = do { ... };) that uses llvm_fresh_var to create a symbolic 32-bit integer input 'x'. For 'clz' and 'ctz', add preconditions ensuring 'x' is either zero or non-zero to handle their defined behavior safely. Use llvm_execute_func to call the target function with the symbolic input and llvm_return to return the expected result using the corresponding built-in behavior. Then, use llvm_verify to verify each function against its spec with no additional assumptions or arguments.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n\nuint32_t popcount( uint32_t x ) {\n  return __builtin_popcount( x );\n}\n\nuint32_t clz( uint32_t x ) {\n  return x ? __builtin_clz( x ) : 32;\n}\n\nuint32_t ctz( uint32_t x ) {\n  return x ? __builtin_ctz( x ) : 32;\n}\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \".\/test.bc\";\nimport \".\/spec.cry\";\n\nlet solver = z3;\nlet sz = 32;\n\nllvm_verify m \"popcount\" [] true (do {\n  x <- llvm_fresh_var \"x\" (llvm_int sz);\n  llvm_execute_func [llvm_term {{ (zero # x):[32] }}];\n  llvm_return (llvm_term {{ popcount ((zero # x):[32]) }});\n}) solver;\n\nllvm_verify m \"clz\" [] true (do {\n  x <- llvm_fresh_var \"x\" (llvm_int sz);\n  llvm_execute_func [llvm_term {{ (zero # x):[32] }}];\n  llvm_return (llvm_term {{ clz ((zero # x):[32]) }});\n}) solver;\n\nllvm_verify m \"ctz\" [] true (do {\n  x <- llvm_fresh_var \"x\" (llvm_int sz);\n  llvm_execute_func [llvm_term {{ (zero # x):[32] }}];\n  llvm_return (llvm_term {{ ctz ((zero # x):[32]) }});\n}) solver;\n```"}]}
{"filename":"saw-script\/intTests\/test_issue108\/refarray.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java class RefArray that defines two let-bound specs: test1_spec and test2_spec. For test1_spec, symbolically create an integer variable x, execute the static method RefArray.test1 with x as argument, and return x. For test2_spec, symbolically create an integer x, allocate a RefArray object, execute the instance method test2 on that object with x as argument, and return x. Use jvm_fresh_var for symbolic inputs, jvm_alloc_object for object allocation, and jvm_execute_func to call methods by their exact names. Include minimal preconditions to ensure safe execution. Then verify both methods against their specs using jvm_verify with the loaded RefArray class.\n\n# Source code:\nRefArray.java\n```java\npublic class RefArray {\n    public static int test1(int x) {\n        Object[] arr = new Object[20];\n        return x;\n    }\n\n    public int test2(int x) {\n        Object[] arr = new Object[20];\n        return x;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nTest_class <- java_load_class \"RefArray\";\nlet test1_spec : JVMSetup() = do {\n  x <- jvm_fresh_var \"x\" java_int;\n  jvm_execute_func [jvm_term x];\n  jvm_return (jvm_term x);\n};\nlet test2_spec : JVMSetup() = do {\n  x <- jvm_fresh_var \"x\" java_int;\n  r <- jvm_alloc_object \"RefArray\";\n  jvm_execute_func [r, jvm_term x];\n  jvm_return (jvm_term x);\n};\njvm_verify Test_class \"test1\" [] false test1_spec abc;\njvm_verify Test_class \"test2\" [] false test2_spec abc;\n```"}]}
{"filename":"saw-script\/intTests\/test2257\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'test.linked-mir.json' and verifies the function 'test::f'. Define a let-bound specification named 'f_spec' that uses 'mir_fresh_var' to create a symbolic 32-bit unsigned integer input named 'arg'. Execute the function with this symbolic input and specify the expected return value as the bitvector reverse of 'arg'. Use 'mir_verify' to verify 'test::f' against 'f_spec' without additional preconditions."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nmod <- mir_load_module \"test.linked-mir.json\";\n\nlet f_spec = do {\n  arg <- mir_fresh_var \"arg\" mir_u32;\n\n  mir_execute_func [mir_term arg];\n\n  mir_return (mir_term {{ reverse arg }});\n};\n\nmir_verify mod \"test::f\" [] true f_spec w4;\n```"}]}
{"filename":"saw-script\/intTests\/test_solver_cache\/test_ops.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the JVM backend that loads the Java class from saw-script\/intTests\/test_solver_cache\/test_ops.saw. Define a let-bound specification named test_ops_spec that uses jvm_fresh_var to create symbolic 64-bit integer inputs. Reference the exact Java methods found in the associated source files, invoking them with these symbolic inputs. Include minimal preconditions necessary for method termination and safety, such as ensuring array bounds or valid input ranges if applicable. Use prove commands to verify properties about these methods, ensuring the spec is let-bound and not inline."},{"role":"assistant","content":"```saw\nprove_print z3 {{ \\(x:[64]) -> x == x }};\nprove_print z3 {{ \\(new_name:[64]) -> new_name == new_name }};\nprove_print (w4_unint_z3 []) {{ \\(x:[64]) -> x == x }};\nprove_print (w4_unint_z3_using \"qfnia\" []) {{ \\(x:[64]) -> x == x }};\nfails (prove_print z3 {{ \\(x:[64])(y:[64]) -> x == y }});\nfails (prove_print z3 {{ \\(new_name_1:[64])(new_name_2:[64]) -> new_name_1 == new_name_2 }});\nfails (prove_print w4 {{ \\(x:[64])(y:[64]) -> x == y }});\nfails (prove_print (w4_unint_z3_using \"qfnia\" []) {{ \\(x:[64])(y:[64]) -> x == y }});\n```"}]}
{"filename":"saw-script\/intTests\/test_ghost\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from test.bc and declares a ghost state counter. Define a let-bound specification get_and_increment_spec that uses a symbolic 32-bit integer n with precondition n < 128, sets the ghost counter to n, executes the function get_and_increment with no arguments, and returns n, updating the ghost counter to n+1. Define another let-bound spec f_spec that takes a symbolic 32-bit integer i with precondition i < 512, executes the function f with argument i, and returns i*n where n is from the ghost counter. Use llvm_unsafe_assume_spec to associate get_and_increment_spec with get_and_increment, then verify f against f_spec using the get_and_increment override. Do not include comments or markdown in the SAWScript.\n\n# Source code:\ntest.c\n```C\nextern int get_and_increment();\n\nint f(int i) { return i * get_and_increment(); }\n\n```"},{"role":"assistant","content":"```saw\nlet pre_counter (counter : Ghost) = do {\n  n <- llvm_fresh_var \"n\" (llvm_int 32);\n  llvm_precond {{n < 128}};\n  llvm_ghost_value counter n;\n  return n;\n};\n\nlet post_counter (counter : Ghost) n = do {\n  llvm_ghost_value counter {{n+1}};\n};\n\nlet get_and_increment_spec (counter : Ghost) : CrucibleSetup () = do {\n  n <- pre_counter counter;\n  llvm_execute_func [];\n  post_counter counter n;\n  llvm_return (llvm_term {{n}});\n};\n\nlet f_spec (counter : Ghost) : CrucibleSetup () = do {\n  n <- pre_counter counter;\n  i <- llvm_fresh_var \"i\" (llvm_int 32);\n  llvm_precond {{i < 512}};\n  llvm_execute_func [llvm_term i];\n  post_counter counter n;\n  llvm_return (llvm_term {{i*n}});\n};\n\nlet main : TopLevel () = do {\n  counter <- declare_ghost_state \"counter\";\n  m <- llvm_load_module \"test.bc\";\n  get_and_increment_ov <-\n    llvm_unsafe_assume_spec m \"get_and_increment\" (get_and_increment_spec counter);\n  llvm_verify m \"f\" [get_and_increment_ov] false (f_spec counter) z3;\n  print \"done\";\n};\n```"}]}
{"filename":"saw-script\/intTests\/test_w4_unint_rme\/Code.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the Ascon_p permutation function defined in the provided Cryptol module. The properties should check that Ascon_p maintains the expected state transformations for valid round counts (rnd <= 16), including the behavior of the round function and its components pC, pS, and pL. Ensure the properties cover the application of constants, the SBox substitution, and the linear diffusion layer sigma. Use :check or :prove commands to validate these properties."},{"role":"assistant","content":"```cryptol\nmodule Code where\n\ntype constraint ValidRnd rnd = rnd <= 16\n\nAscon_p : {rnd} (ValidRnd rnd) => State -> State\nAscon_p S = foldl round S (drop`{back=rnd} Const)\n\nround : State -> [64] -> State\nround S ci = pL (pS (pC S ci))\n\ntype State = [5][64]\n\npC : State -> [64] -> State\npC [S0, S1, S2, S3, S4] ci = [S0, S1, S2 ^ ci, S3, S4]\n\nConst : [16][64]\nConst =\n    [ 0x000000000000003c\n    , 0x000000000000002d\n    , 0x000000000000001e\n    , 0x000000000000000f\n    , 0x00000000000000f0\n    , 0x00000000000000e1\n    , 0x00000000000000d2\n    , 0x00000000000000c3\n    , 0x00000000000000b4\n    , 0x00000000000000a5\n    , 0x0000000000000096\n    , 0x0000000000000087\n    , 0x0000000000000078\n    , 0x0000000000000069\n    , 0x000000000000005a\n    , 0x000000000000004b\n    ]\n\npS : State -> State\npS S = transpose (map SBox (transpose S))\n\nSBox : [5] -> [5]\nSBox i = SBoxTable@i\n\nSBoxTable : [32][5]\nSBoxTable =\n    map drop\n    [ 0x04, 0x0b, 0x1f, 0x14, 0x1a, 0x15, 0x09, 0x02\n    , 0x1b, 0x05, 0x08, 0x12, 0x1d, 0x03, 0x06, 0x1c\n    , 0x1e, 0x13, 0x07, 0x0e, 0x00, 0x0d, 0x11, 0x18\n    , 0x10, 0x0c, 0x01, 0x19, 0x16, 0x0a, 0x0f, 0x17\n    ]\n\npL : State -> State\npL [S0, S1, S2, S3, S4] =\n    [ sigma S0 19 28\n    , sigma S1 61 39\n    , sigma S2  1  6\n    , sigma S3 10 17\n    , sigma S4  7 41\n    ]\n    where\n        sigma : [64] -> [6] -> [6] -> [64]\n        sigma x i j = x ^ x>>>i ^ x>>>j\n```"}]}
{"filename":"saw-script\/intTests\/test2005_mir_lifetime\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given path, defines a let-bound specification named f_spec that uses llvm_fresh_var to create symbolic inputs matching the signature of the function test::f, applies minimal preconditions to ensure safety, calls the function test::f via llvm_execute_func with these symbolic inputs, and verifies the function against the specification using llvm_verify. The harness should directly reference the exact function symbol test::f from the LLVM module and use let-binding for the specification as shown in the example."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet s_adt = mir_find_adt m \"test::S\" [mir_lifetime];\n\nlet f_spec = do {\n  y_ref <- mir_alloc mir_u32;\n  y_val <- mir_fresh_var \"y\" mir_u32;\n  mir_points_to y_ref (mir_term y_val);\n\n  mir_execute_func [y_ref];\n\n  let s = mir_struct_value s_adt [y_ref];\n  mir_return s;\n};\n\nmir_verify m \"test::f\" [] false f_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test0062_resolve_pred\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from test.bc that verifies the functions 'f' and 'g' defined in test.c. Define let-bound specs 'f_spec' and 'g_spec' that allocate a 32-bit integer pointer, invoke the respective function with this pointer and a symbolic 32-bit integer input, and assert that the memory pointed to by the pointer equals the input value after execution. Use llvm_fresh_var for symbolic inputs and minimal preconditions to ensure safety. Then verify 'f' with example inputs 0 and 1, collecting the overrides, and verify 'g' using these overrides and the 'g_spec'.\n\n# Source code:\ntest.c\n```C\nvoid f(int* x, int y)\n{\n  *x = y;\n}\n\nvoid g(int* x, int y)\n{\n  f(x, y);\n}\n\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nlet f_spec y = do {\n  x_p <- llvm_alloc (llvm_int 32);\n  llvm_execute_func [x_p, (llvm_term {{ `y : [32] }})];\n  llvm_points_to x_p (llvm_term {{ `y : [32] }});\n};\n\nlet g_spec y = do {\n  x_p <- llvm_alloc (llvm_int 32);\n  llvm_execute_func [x_p, (llvm_term {{ `y : [32] }})];\n  llvm_points_to x_p (llvm_term {{ `y : [32] }});\n};\n\nf_0_ov <- llvm_verify m \"f\" [] false (f_spec 0) (w4_unint_z3 []);\nf_1_ov <- llvm_verify m \"f\" [] false (f_spec 1) (w4_unint_z3 []);\nlet f_ovs =\n  [ f_0_ov\n  , f_1_ov\n  ];\ng_ov <- llvm_verify m \"g\" f_ovs false (g_spec 0) trivial;\n```"}]}
{"filename":"saw-script\/intTests\/test1646\/test4.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that uses jvm_load_class to load the associated Java class containing the methods g() and f(). Define a let-bound spec named g_spec that creates symbolic inputs as needed, calls the method g(), and verifies its behavior matches the expected output sequence including calls to f() printing 'x=a' and 'x=b'. Use jvm_fresh_var for symbolic variables and include minimal preconditions to ensure method calls are safe and terminate properly."},{"role":"assistant","content":"```saw\n\/\/ The second f call will print x=a.\n\nlet g () = do {\n   let x = \"a\";\n\n   let f () = print (str_concat \"x=\" x);\n   f ();\n\n   let x = \"b\";\n   f ();\n};\n\ng ();\n```"}]}
{"filename":"saw-script\/intTests\/test_congruence\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated C or Java source files using the appropriate backend (llvm_load_module or java_load_class). Define a let-bound specification named <function>_spec that symbolically inputs all parameters of the target function using llvm_fresh_var or jvm_fresh_var. Include minimal preconditions to ensure safety and termination, such as array bounds or non-zero divisors if applicable. Then, use the congruence_for combinator to generate a congruence lemma for the function, and prove it with prove_extcore. Finally, prove a property involving the function using goal_intro, unfolding, simplify, and goal_apply steps referencing the congruence lemma, without any inline do blocks or solver references."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet {{\n  f : [32] -> [100][12] -> Integer\n  f x ys = foldl (\\i y -> i + toInteger y) (toInteger x) ys\n\n}};\n\nf_cong_term <- congruence_for {{ f }};\nf_cong_thm  <- prove_extcore (w4_unint_z3 [\"f\"]) f_cong_term;\n\nthm <- prove_print\n       do {\n         goal_intro \"x\";\n\t goal_intro \"y\";\n\t unfolding [\"ecEq\"];\n\t simplify (cryptol_ss ());\n\t goal_apply f_cong_thm;\n\t z3;\n\t z3;\n       }\n       {{ \\x y -> f (x+y) zero == f (y+x) zero }};\n\nprint thm;\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_x86_03\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from bar.bc and defines a let-bound spec named foo_spec. The spec should symbolically execute the function foo with no arguments, returning a 64-bit value. Then verify the function foo in the module against foo_spec using llvm_verify_x86. Use llvm_fresh_var for any symbolic inputs if needed, and include minimal preconditions for safety or termination. Reference the exact symbol \"foo\" as defined in bar.c.\n\n# Source code:\nbar.c\n```C\n#include <stdint.h>\n#include <stdio.h>\n\nextern uint64_t foo();\n\nvoid bar() {\n\tfoo();\n};\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- llvm_load_module \"bar.bc\";\n\nlet foo_setup = do {\n  llvm_execute_func [];\n  llvm_return (llvm_term {{ 1 : [64] }});\n};\nfails (llvm_verify_x86 m \".\/foo\" \"foo\" [] false foo_setup w4);\n```"}]}
{"filename":"saw-script\/intTests\/test_w4\/prims.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the associated C source files using llvm_load_module. Define a let-bound specification named prims_spec that uses llvm_fresh_var to create symbolic inputs matching the function signatures of the bitwise and arithmetic primitives defined in the source. Include minimal preconditions to ensure safety, such as non-zero divisors for division and modulo operations. Use llvm_verify to verify each primitive function against its specification by invoking the corresponding LLVM function symbol. The harness should not contain any comments or Markdown and must directly reference the exact function names and signatures from the associated source files."},{"role":"assistant","content":"```saw\nprint \"Bitwise operations &&\";\nprove_print w4 {{ (0x0F && 131) == 3 }};\nprint \".\";\nprove_print w4 {{ (0x0F || 131) == 143 }};\nprint \".\";\nprove_print w4 {{ (0x0F ^ 0xFF) == 240 }};\nprint \"this is a bug\";\nprove_print w4 {{ ~0x0F == 240 }};\n\n\nprint \"Arithmetic +\";\nprove_print w4 {{ (12:[8]) + 32 == 44 }};\nprint \".\";\nprove_print w4 {{ (252:[8]) + 32 == 28 }};\n\nprint \"Arithmetic -\";\nprove_print w4 {{ (12:[8]) - 3 == 9 }};\nprint \".\";\nprove_print w4 {{ (12:[8]) - 32 == 236 }};\n\nprint \"Arithmetic *\";\nprove_print w4 {{ (12:[8]) * 3 == 36 }};\nprint \".\";\nprove_print w4 {{ (12:[8]) * 200 == 96 }};\n\nprint \"Arithmetic \/\";\nprove_print w4 {{ (12:[4]) \/ 3 == 4 }};\nprint \".\";\nprove_print w4 {{ (12:[4]) \/ -3 == 0 }};\n\nprint \"Arithmetic %\";\nprove_print w4 {{ (19:[8]) % 3 == 1 }};\nprint \".\";\nprove_print w4 {{ (-19:[8]) % 3 == 0 }};\n\nprint \"Arithmetic lg2\";\nprove_print w4 {{ lg2 (8:[8]) == 3 }};\nprint \".\";\nprove_print w4 {{ lg2 (-8:[8]) == 8 }};\n\nprint \"Sequences\";\n\nprove_print w4 {{ (4:[4]) # (4:[4]) == (68:[8]) }};\nprint \".\";\nprove_print w4 {{ \\(x:[2]) (y:[3]) -> take (x # y) == x }};\nprint \".\";\nprove_print w4 {{ \\(x:[2]) (y:[3]) -> drop (x # y) == y }};\nprint \".\";\nprove_print w4 {{ \\(x:[4]) (y:[1]) -> tail (y # x) == x }};\nprint \".\";\nprove_print w4 {{ join [2:[2],3:[2]] == 11 }};\nprint \".\";\nprove_print w4 {{ split 0xFFFF == [15, 15, 15, 15] }};\nprint \".\";\nprove_print w4 {{ \\(x:[7]) -> reverse (reverse x) == x }};\n\nprint \"Sequences @\";\n\nprove_print w4 {{ [1,2,3:[8]]@ 0 == 1 }};\nprint \".\";\nprove_print w4 {{ [1,2,3:[8]]@ 1 == 2 }};\nprint \".\";\nprove_print w4 {{ [1,2,3:[8]]@ (2:[2]) == 3 }};\nprint \".\";\nprove_print w4 {{ [1,2,3:[8]]@ (2:[8]) == 3 }};\nprint \".\";\nfails (prove_print w4 {{ [1,2,3:[8]]@ 5 == 3 }});\n\nprint \"Sequences !\";\n\nprove_print w4 {{ [1,2,3:[8]]! 0 == 3 }};\nprint \".\";\nprove_print w4 {{ [1,2,3:[8]]! 1 == 2 }};\nprint \".\";\nprove_print w4 {{ [1,2,3:[8]]! (2:[2]) == 1 }};\nprint \".\";\nprove_print w4 {{ [1,2,3:[8]]! (2:[8]) == 1 }};\nprint \".\";\nfails (prove_print w4 {{ [1,2,3:[8]]! 5 == 1 }});\n\nprint \"Shifting, rotating\";\n\nprove_print w4 {{ (16:[8]) >> 3 == 2 }};\nprint \".\";\nprove_print w4 {{ (15:[8]) >> 3 == 1 }};\nprint \".\";\nprove_print w4 {{ 0xF0 >> 4 == 15 }};\nprint \".\";\nprove_print w4 {{ 0xF0 >> 8 == 0 }};\n\nprove_print w4 {{ (15:[8]) << 3 == 120 }};\nprint \".\";\nprove_print w4 {{ (15:[8]) << 7 == 128 }};\nprint \".\";\nprove_print w4 {{ (1:[8]) << 8 == 0 }};\nprint \".\";\nprove_print w4 {{ (128:[8]) <<< 2 == 2 }};\nprint \".\";\nprove_print w4 {{ (2:[8]) >>> 2 == 128 }};\nprint \".\";\nprove_print w4 {{ (4:[8]) >>> 3 == 128 }};\n\n\nprint \"Misc\";\nprove_print w4 {{ min (4:[8]) 5 == 4 }};\nprint \".\";\nprove_print w4 {{ max (4:[8]) 5 == 5 }};\n\n\nprint \"Done\";\n```"}]}
{"filename":"saw-script\/intTests\/test1684\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function 'f' defined in 'test.bc' corresponding to 'void f(struct b *bb)'. Define a let-bound spec 'f_spec' that creates a fresh symbolic variable of type 'struct a' for the field 'aa' inside 'struct b', allocates memory for 'struct b', sets the 'aa' field to the symbolic variable, and then executes the function 'f' with the pointer to 'struct b'. Use llvm_fresh_var, llvm_alloc, llvm_points_to, and llvm_execute_func accordingly, ensuring the spec is suitable for llvm_verify.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n\nstruct a {\n  uint16_t x;\n  uint32_t y;\n};\n\nstruct b {\n  struct a aa;\n};\n\nvoid f(struct b *bb) {}\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\nenable_lax_loads_and_stores;\n\nlet f_spec = do {\n  aa <- llvm_fresh_var \"aa\" (llvm_alias \"struct.a\");\n  bb <- llvm_alloc (llvm_alias \"struct.b\");\n  llvm_points_to (llvm_field bb \"aa\") (llvm_term aa);\n\n  llvm_execute_func [bb];\n};\n\nm <- llvm_load_module \"test.bc\";\nllvm_verify m \"f\" [] false f_spec (w4_unint_yices []);\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_ghost\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test_mir_ghost\/test.linked-mir.json, declares a ghost state 'counter', and defines a let-bound specification 'next_spec' for the function 'test::next' with signature 'void test::next(uint32_t& counter)'. Use llvm_fresh_var to create symbolic inputs and add minimal preconditions for safety. Then define 'example_spec' for 'test::example' with signature 'uint32_t test::example(uint32_t& counter)', referencing 'next_spec' as an assumption. The harness should execute the functions symbolically, update ghost states accordingly, and verify 'test::example' against 'example_spec' using llvm_verify without inline specs or comments."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet next_spec counter = do {\n  n <- mir_fresh_var \"n\" mir_u32;\n  mir_ghost_value counter n;\n\n  mir_execute_func [];\n\n  mir_ghost_value counter {{n+1}};\n  mir_return (mir_term {{n}});\n};\n\nlet example_spec counter = do {\n  n <- mir_fresh_var \"nm\" mir_u32;\n  mir_precond {{n < 2}};\n  mir_ghost_value counter n;\n\n  mir_execute_func [];\n\n  mir_ghost_value counter {{n+3}};\n  mir_return (mir_term {{n+2}});\n};\n\ncounter <- declare_ghost_state \"ctr\";\nm <- mir_load_module \"test.linked-mir.json\";\n\nnext <- mir_unsafe_assume_spec m \"test::next\" (next_spec counter);\nmir_verify m \"test::example\" [next] false (example_spec counter) z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_points_to\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given path and verifies the functions 'test::read_from_ref' and 'test::write_to_ref'. Define let-bound specs named 'read_from_ref_spec' and 'write_to_ref_spec' respectively. Use 'llvm_fresh_var' to create symbolic inputs and 'llvm_alloc' or 'llvm_alloc_mut' for pointer allocations as needed. Use 'llvm_points_to' to specify memory state and 'llvm_execute_func' to call the functions with symbolic arguments. Include minimal preconditions to ensure safety and termination. Finally, invoke 'llvm_verify' on the module and each spec without inline specs or solver references."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet read_from_ref_spec = do {\n  ptr <- mir_alloc mir_u32;\n  x <- mir_fresh_var \"x\" mir_u32;\n  mir_points_to ptr (mir_term x);\n\n  mir_execute_func [ptr];\n\n  mir_return (mir_term x);\n};\n\n\/\/ This spec will cause SAW to read from uninitialized memory.\n\nlet read_from_ref_spec_bad = do {\n  ptr <- mir_alloc mir_u32;\n\n  mir_execute_func [ptr];\n\n  mir_return (mir_term {{ 42 : [32] }});\n};\n\nlet write_to_ref_spec = do {\n  ptr <- mir_alloc_mut mir_u32;\n  y <- mir_fresh_var \"y\" mir_u32;\n\n  mir_execute_func [ptr, mir_term y];\n\n  mir_points_to ptr (mir_term y);\n};\n\n\/\/ This spec contains a type error, as `write_to_ref` expects a mutable\n\/\/ reference, but the spec allocates an immutable reference.\n\nlet write_to_ref_spec_bad = do {\n  ptr <- mir_alloc mir_u32;\n  y <- mir_fresh_var \"y\" mir_u32;\n\n  mir_execute_func [ptr, mir_term y];\n\n  mir_points_to ptr (mir_term y);\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::read_from_ref\" [] false read_from_ref_spec z3;\nmir_verify m \"test::write_to_ref\" [] false write_to_ref_spec z3;\n\nfails (\n  mir_verify m \"test::read_from_ref\" [] false read_from_ref_spec_bad z3\n);\nfails (\n  mir_verify m \"test::write_to_ref\" [] false write_to_ref_spec_bad z3\n);\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_x86_04\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from test.bc and verifies the function addvar with signature void addvar(uint64_t *). Define a let-bound spec named addvar_spec that allocates a global variable var of type i64 initialized to 2, allocates a fresh pointer and a fresh i64 variable val, sets the pointer to point to val, executes addvar with the pointer as argument, then allocates a fresh i64 valprime and asserts the pointer points to valprime. Use llvm_fresh_var for symbolic inputs and llvm_points_to for memory setup. Do not inline the spec in the verify call.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n#include <stdio.h>\n\nextern uint64_t var;\n\nextern void addvar(uint64_t *i);\n\nvoid test() {\n\t(void) var;\n\tuint64_t i = 42;\n\taddvar(&i);\n};\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet addvar_setup = do {\n  llvm_alloc_global \"var\";\n  var <- llvm_fresh_var \"var\" (llvm_int 64);\n  llvm_points_to (llvm_global \"var\") (llvm_term {{ 2 : [64] }});\n\n  ptr <- llvm_alloc (llvm_int 64);\n  val <- llvm_fresh_var \"val\" (llvm_int 64);\n  llvm_points_to ptr (llvm_term val);\n\n  llvm_execute_func [ptr];\n\n  valprime <- llvm_fresh_var \"_val\" (llvm_int 64);\n  llvm_points_to ptr (llvm_term valprime);\n};\nllvm_verify_x86 m \".\/addvar\" \"addvar\" [] false addvar_setup w4;\n```"}]}
{"filename":"saw-script\/intTests\/test_bitfield_wrong_type\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM backend that loads the module from \"test.bc\" and verifies the function \"set_y\" with signature \"void set_y(struct s *ss, bool y)\". Define a let-bound spec named set_y_spec that allocates a fresh symbolic struct s pointer, creates a fresh symbolic boolean variable y, executes the function with these symbolic inputs, and asserts that the bitfield \"y\" in the struct points to the symbolic boolean value. Use llvm_fresh_var for symbolic inputs and llvm_alloc for memory allocation. Include minimal preconditions to ensure safety and termination.\n\n# Source code:\ntest.c\n```C\n#include <stdbool.h>\n#include <stdint.h>\n\nstruct s {\n  int32_t w;\n  uint8_t x1:1;\n  uint8_t x2:2;\n  uint8_t y:1;\n  int32_t z;\n};\n\nvoid set_y(struct s *ss, bool y) {\n  ss->y = y;\n}\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\nenable_lax_loads_and_stores;\n\nlet set_y_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  \/\/ Note that the type is 8 bits, which is a different number of bits than\n  \/\/ what is specified in the bitfield.\n  z <- llvm_fresh_var \"z\" (llvm_int 8);\n  llvm_execute_func [ss, llvm_term z];\n  llvm_points_to_bitfield ss \"y\" (llvm_term z);\n};\n\nm <- llvm_load_module \"test.bc\";\nfails (llvm_verify m \"set_y\" [] false set_y_spec (w4_unint_z3 []));\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_ghost_symbolic_branch\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'test.linked-mir.json', declares a ghost state 'g', and defines let-bound specs named 'f_spec' and 'g_spec' for the functions 'test::f' and 'test::g' respectively. Use 'llvm_fresh_var' to create symbolic inputs matching the function parameter types (e.g., 32-bit unsigned integers for 'f', booleans for 'g'). In each spec, execute the corresponding function with the symbolic input, then assert the ghost state 'g' holds the expected value (the input for 'f', and a conditional value for 'g'). Use 'mir_unsafe_assume_spec' to associate 'f_spec' with 'test::f', then verify 'test::g' against 'g_spec' using the assumed spec. Do not include comments or solver references."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\ng <- declare_ghost_state \"g\";\n\nlet f_spec = do {\n    x <- mir_fresh_var \"x\" mir_u32;\n\n    mir_execute_func [mir_term x];\n\n    mir_ghost_value g x;\n};\n\nlet g_spec = do {\n    b <- mir_fresh_var \"b\" mir_bool;\n\n    mir_execute_func [mir_term b];\n\n    mir_ghost_value g ({{ if b then 27 else 42 : [32] }});\n};\n\nf_ov <- mir_unsafe_assume_spec m \"test::f\" f_spec;\nmir_verify m \"test::g\" [f_ov] false g_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_yosys_verilog\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given path and defines a let-bound specification named fulladd_spec. The spec should use llvm_fresh_var to create symbolic 4-bit inputs a and b and 1-bit input c_in, call the function fulladd with these inputs, and specify the expected output as a record with c_out and sum fields matching the function's return. Include minimal preconditions to ensure safe addition without overflow. Then prove equivalence between the LLVM fulladd function and the specification using prove_print."},{"role":"assistant","content":"```saw\nenable_experimental;\nm <- yosys_import \"test.json\";\n\nlet {{\n  cryfull :  {a : [4], b : [4], c_in : [1]} -> {c_out : [1], sum : [4]}\n  cryfull inp = { c_out = cout, sum = s }\n    where (cout, s) = splitAt (zext inp.a + zext inp.b + zext inp.c_in)\n}};\n\nprove_print w4 {{ m.fulladd === cryfull }};\n```"}]}
{"filename":"saw-script\/intTests\/test2064\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the MIR module from 'test.linked-mir.json' and verifies the functions 'test::f' and 'test::g'. Define let-bound specs 'f_spec' and 'g_spec' using symbolic inputs allocated as 4-element arrays of 32-bit unsigned integers. Use 'mir_fresh_var' to create symbolic variables and 'mir_points_to' to initialize memory. Execute the functions with 'mir_execute_func' passing appropriate arguments. For 'f_spec', specify the postcondition that the first element of the input array equals the first element of the output array. For 'g_spec', specify a postcondition that always returns false. Perform verification with 'mir_verify' referencing the verification result of 'f' when verifying 'g'."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet f_spec = do {\n  x_ref <- mir_alloc (mir_array 4 mir_u32);\n  x_val <- mir_fresh_var \"x\" (mir_array 4 mir_u32);\n  mir_points_to x_ref (mir_term x_val);\n\n  y_ref <- mir_alloc (mir_array 4 mir_u32);\n  y_val <- mir_fresh_var \"y\" (mir_array 4 mir_u32);\n  mir_points_to y_ref (mir_term y_val);\n\n  mir_execute_func [mir_slice_value x_ref, mir_slice_value y_ref];\n\n  mir_return (mir_term {{ x_val@0 == y_val@0 }});\n};\n\nlet g_spec = do {\n  mir_execute_func [];\n\n  mir_return (mir_term {{ False }});\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nf_ov <- mir_verify m \"test::f\" [] false f_spec z3;\nmir_verify m \"test::g\" [f_ov] false g_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_bitwuzla\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test_bitwuzla\/test.saw, defines a let-bound specification named add_mul_spec that symbolically inputs three 64-bit variables m, n, and p using llvm_fresh_var, and verifies the property that m * (n + p) equals (m * n) + (m * p). Use llvm_verify to prove that the function named add_mul in the LLVM module satisfies add_mul_spec, ensuring any necessary preconditions for safe arithmetic are included."},{"role":"assistant","content":"```saw\nlet\n{{\nadd_mul_lemma : [64] -> [64] -> [64] -> Bit\nadd_mul_lemma m n p =\n  m * (n + p) == (m * n) + (m * p)\n}};\n\nprove_print bitwuzla               {{ add_mul_lemma }};\nprove_print sbv_bitwuzla           {{ add_mul_lemma }};\nprove_print (w4_unint_bitwuzla []) {{ add_mul_lemma }};\n```"}]}
{"filename":"saw-script\/intTests\/test_saw_submodule_access1\/F.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally verifies the correctness of the submodule access and arithmetic computations in the module F. Specifically, specify properties that check the values of top0, topd2, topd3, and the nested submodule fields d2, d3D2, d2', d3P, and d3 within D3 and D4, ensuring that all references to imported modules B and C and internal submodules are correctly resolved and computed."},{"role":"assistant","content":"```cryptol\nmodule F where\nimport B\nimport C\n\ntop0  = 2000 + b + c\ntopd2 = 5  + D3::d2\ntopd3 = 10 + D3::D4::d3\n\nd00 : [32]\nd00 = 1 submodule D3 where\n  d2   = 10000 + top0\n  d3D2 =     1 + D4::d3\n  d2'  =     1 + d3P\n\n  private\n    d3P = 1 + d2\n\n  submodule D4 where\n    d3 = 20000 + top0 + d2\n```"}]}
{"filename":"saw-script\/intTests\/test_saw_submodule_access1\/D.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the computations in module D and its submodules D2 and D3, ensuring that the values d00, d2, and d3 are computed as specified and consistent with the imported values b and c from modules B and C."},{"role":"assistant","content":"```cryptol\nmodule D where\nimport B\nimport C\n\nd00 = 2000 + b + c\nd01 = 5 + D2::d2\n\ntype DTySy = [32]\n\nsubmodule D2 where\n  d2 = d00 + 10000\n\n  type D2TySy = [32]\n\n  submodule D3 where\n  d3 = d00 + d2 + 1\n\n  type D3TySy = [32]\n```"}]}
{"filename":"saw-script\/intTests\/test_saw_submodule_access1\/UseFunctors.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally verifies the correct scoping and accessibility of submodules and parameters in the given nested submodule structure. Specifically, ensure that the values ex1 and ex2 compute as expected based on the implicit imports and parameter bindings, and that access to non-visible submodules like I::FM::z is disallowed. Include properties that check the correctness of the functor instantiation and the visibility rules for submodules."},{"role":"assistant","content":"```cryptol\nmodule UseFunctors where\n\nsubmodule M where\n    x = 0x02\n\n    submodule M1 where\n      x = 0x03\n\nex1 = M::x + M::M1::x  \/\/ This is OK because of implicit imports of M and M1\n\n\/\/ This is a functor\nsubmodule F where\n  parameter\n    p: [8]\n\n  submodule FM where\n    z = 0x03 + p\n\n  f = 2 * p\n\nsubmodule I = submodule F where\n  p = 11\n\nex2 = I::f + 2  \/\/ This is OK because of implicit import of I\n\n\/\/ ex3 = I::FM::z  This is not OK, becase FM is not syntactically visible in I, so we can't add an implicit import\n```"}]}
{"filename":"saw-script\/intTests\/test0023_java_assert_false\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class Test0023 and defines a let-bound specification named id_spec. The spec should allocate a fresh object of Test0023, create a symbolic integer variable x with the precondition x > 5, execute the method id with this and x as arguments, and assert that the method returns the constant integer 6. Use jvm_load_class, jvm_alloc_object, jvm_fresh_var, jvm_precond, jvm_execute_func, and jvm_return accordingly, referencing the method signature Test0023.id(int) and ensuring the spec is let-bound before passing it to jvm_verify.\n\n# Source code:\nTest0023.java\n```java\nclass Test0023 {\n    int id(int x) {\n        return x;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"Test0023\";\nfails (\n  jvm_verify c \"id\" [] false\n    do {\n      this <- jvm_alloc_object \"Test0023\";\n      x <- jvm_fresh_var \"x\" java_int;\n      jvm_precond {{ x > 5 }};\n      jvm_execute_func [this, jvm_term x];\n      jvm_return (jvm_term {{ 6 : [32] }});\n    }\n    abc\n  );\n```"}]}
{"filename":"saw-script\/intTests\/test0050_compositional_extract_1\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"test.bc\" that verifies the functions foo and bar defined in test.c. Define let-bound specs foo_spec and bar_spec using llvm_fresh_var and llvm_alloc to create symbolic inputs: for foo_spec, create a fresh pointer p_p to an unsigned 32-bit integer and a fresh unsigned 32-bit integer x, then execute foo with these arguments, require llvm_points_to to model memory updates, and specify the return value symbolically. For bar_spec, create a fresh pointer p_p and execute bar with it, modeling memory updates similarly. Use llvm_compositional_extract to extract foo and bar with these specs, then prove properties about foo and bar using the extracted functions, referencing exact symbol names foo and bar and their signatures from test.c. Include minimal preconditions for safety and termination, and do not include comments or solver references.\n\n# Source code:\ntest.c\n```C\nunsigned foo(unsigned *p, unsigned x)\n{\n  *p += x;\n  return *p;\n}\n\nvoid bar(unsigned *p)\n{\n  foo(p, foo(p, 1));\n}\n\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet ptr_to_fresh nm ty = do {\n    x <- llvm_fresh_var nm ty;\n    p <- llvm_alloc ty;\n    llvm_points_to p (llvm_term x);\n    return (x, p);\n};\n\nlet foo_spec = do {\n  (_, p_p) <- ptr_to_fresh \"p\" (llvm_int 32);\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [p_p, llvm_term x];\n  p <- llvm_fresh_var \"p\" (llvm_int 32);\n  llvm_points_to p_p (llvm_term p);\n  r <- llvm_fresh_var \"r\" (llvm_int 32);\n  llvm_return (llvm_term r);\n};\n\nlet bar_spec = do {\n  (_, p_p) <- ptr_to_fresh \"p\" (llvm_int 32);\n  llvm_execute_func [p_p];\n  p <- llvm_fresh_var \"p\" (llvm_int 32);\n  llvm_points_to p_p (llvm_term p);\n};\n\nfoo_ov <- llvm_compositional_extract m \"foo\" \"f\" [] false foo_spec abc;\n_ <- llvm_compositional_extract m \"bar\" \"g\" [foo_ov] false bar_spec abc;\n\nf_thm <- prove_print abc {{ \\x p -> f x p == (p + x, p + x) }};\nfails (prove_print (do { unfolding [\"g\"]; w4_unint_yices [\"f\"]; }) {{ \\p -> g p == 2 * (p + 1) }});\nprove_print (do { unfolding [\"g\"]; simplify (addsimp f_thm empty_ss); w4_unint_yices [\"f\"]; })\n  {{ \\p -> g p == 2 * (p + 1) }};\n```"}]}
{"filename":"saw-script\/intTests\/test0071_w4_unint_z3_using\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test0071_w4_unint_z3_using\/test.saw, defines a let-bound specification named w4_unint_z3_using_spec that uses llvm_fresh_var to create a symbolic 1024-bit input variable x, and verifies the equivalence of the given property involving bvToInteger and bvFromInteger functions as defined in the SAW file. The spec should encode the conditional expression comparing bvToInteger x and bvToInteger (x * x) and assert the equality of the two bvFromInteger expressions accordingly, without hard-coded constants and with minimal preconditions for safety."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet {{\nbvToInteger : [1024] -> Integer\nbvToInteger = toInteger\nbvFromInteger : Integer  -> [1024]\nbvFromInteger = fromInteger\n}};\n\nprove_print\n  (w4_unint_z3_using \"qfnia\" [\"bvToInteger\", \"bvFromInteger\"])\n  {{ \\(x : [1024]) -> bvFromInteger ((if (bvToInteger x) <= (bvToInteger (x * x)) then 1 else (bvToInteger x)) * (bvToInteger x)) == bvFromInteger ((if (bvToInteger x) <= (bvToInteger (x * x)) then (bvToInteger x) else (bvToInteger x) * (bvToInteger x))) }};\n```"}]}
{"filename":"saw-script\/intTests\/test_intro_examples\/rewrite.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the provided source files, defines a let-bound specification named 'h_spec' that symbolically inputs two 8-bit integers using llvm_fresh_var, calls the function 'h' with these inputs, and proves that 'h(x,y)' equals twice the result of 'f(x,y)'. Also define 'f_spec' and 'g_spec' similarly for functions 'f' and 'g', and prove that 'f(x,y)' equals 'g(x,y)'. Include minimal preconditions for safe addition if necessary. Use llvm_load_module and llvm_verify accordingly."},{"role":"assistant","content":"```saw\nlet {{\n    f x y = (x : [8]) + y\n    g x y = (y : [8]) + x\n    h x y = (f x y) + (g x y)\n}};\nf_eq_g <- prove_print abc {{ \\x y -> f x y == g x y }};\nprint f_eq_g;\nlet t1 = unfold_term [\"h\"] {{ \\x y -> h x y == 2*(f x y) }};\nprint_term t1;\nlet t2 = rewrite (addsimp f_eq_g empty_ss) t1;\nprint_term t2;\nprove_print (unint_yices [\"g\"]) t2;\n```"}]}
{"filename":"saw-script\/intTests\/test_intro_examples\/ffs_eq.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from \"ffs.bc\" and defines a let-bound specification named ffs_spec. This spec should symbolically declare a 32-bit input variable using llvm_fresh_var, then call and compare the functions ffs_ref and ffs_imp from the module, asserting their equivalence for all inputs. Include any minimal preconditions necessary for safe execution. Finally, prove the equivalence of these two functions using the defined spec.\n\n# Source code:\nffs.c\n```C\n#include <stdint.h>\n\nuint32_t ffs_ref(uint32_t word) {\n  if(!word) return 0;\n  for(int c = 0, i = 0; c < 32; c++)\n    if(((1 << i++) & word) != 0)\n      return i;\n  return 0;\n}\n\nuint32_t ffs_imp(uint32_t i) {\n  char n = 1;\n  if (!(i & 0xffff)) { n += 16; i >>= 16; }\n  if (!(i & 0x00ff)) { n +=  8; i >>=  8; }\n  if (!(i & 0x000f)) { n +=  4; i >>=  4; }\n  if (!(i & 0x0003)) { n +=  2; i >>=  2; }\n  return (i) ? (n+((i+1) & 0x01)) : 0;\n}\n\nuint32_t ffs_imp_nobranch(uint32_t i) {\n  char n = 1;\n  int s1 = !(i & 0xffff) << 4;\n  n += s1; i >>= s1;\n  int s2 = !(i & 0x00ff) << 3;\n  n += s2;  i >>= s2;\n  int s3 = !(i & 0x000f) << 2;\n  n += s3;  i >>= s3;\n  int s4 = !(i & 0x0003) << 1;\n  n += s4;  i >>= s4;\n  \/\/ Still does have one branch...\n  return (i) ? (n+((i+1) & 0x01)) : 0;\n}\n\n\/\/ and now a buggy one\nuint32_t ffs_bug(uint32_t word) {\n    \/\/ injected bug:\n    if(word == 0x101010) return 4; \/\/ instead of 5\n    return ffs_ref(word);\n}\n\n\/\/ Creative optimized version based on musl libc:\n\/\/ http:\/\/www.musl-libc.org\/.\n\/\/\n\/\/ Apparently this is a well known approach:\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Find_first_set#CTZ. The DeBruijn\n\/\/ (https:\/\/en.wikipedia.org\/wiki\/De_Bruijn_sequence) sequence here is\n\/\/ different from the one in the Wikipedia article on 'ffs'.\nuint32_t ffs_musl (uint32_t x)\n{\n  static const char debruijn32[32] = {\n    0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,\n    31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14\n  };\n  return x ? debruijn32[(x&-x)*0x076be629 >> 27]+1 : 0;\n}\n\nint ffs_imp_correct(uint32_t x) {\n    return ffs_imp(x) == ffs_ref(x);\n}\n\nint ffs_bug_correct(uint32_t x) {\n    return ffs_bug(x) == ffs_ref(x);\n}\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"ffs.bc\";\nprint \"Extracting functional models...\";\nref <- llvm_extract m \"ffs_ref\";\nimp <- llvm_extract m \"ffs_imp\";\nprint \"Comparing reference and implementation...\";\nr <- time (prove abc {{ ref === imp }});\nprint r;\n```"}]}
{"filename":"saw-script\/intTests\/test_intro_examples\/swap-simpler.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function swap_xor defined in xor-swap.c. Load the LLVM module xor-swap.bc using llvm_load_module. Define a let-bound specification swap_spec that creates two symbolic 32-bit integer pointers with llvm_fresh_var and llvm_alloc, initializes their memory with llvm_points_to, executes swap_xor with llvm_execute_func, and verifies that after execution the values pointed to by the pointers are swapped. Include minimal preconditions to ensure memory safety and termination. Use llvm_verify to verify the function against swap_spec with no additional overrides or assumptions.\n\n# Source code:\nxor-swap.c\n```C\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid swap_xor(uint32_t *x, uint32_t *y) {\n    *x = *x ^ *y;\n    *y = *x ^ *y;\n    *x = *x ^ *y;\n}\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"xor-swap.bc\";\nlet ptr_to_fresh nm ty = do {\n    x <- llvm_fresh_var nm ty;\n    p <- llvm_alloc ty;\n    llvm_points_to p (llvm_term x);\n    return (x, p);\n};\nlet swap_spec = do {\n    (x, xp) <- ptr_to_fresh \"x\" (llvm_int 32);\n    (y, yp) <- ptr_to_fresh \"y\" (llvm_int 32);\n    llvm_execute_func [xp, yp];\n    llvm_points_to xp (llvm_term y);\n    llvm_points_to yp (llvm_term x);\n};\nllvm_verify m \"swap_xor\" [] true swap_spec abc;\n```"}]}
{"filename":"saw-script\/intTests\/test_intro_examples\/write_cnf.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the associated source files, defines a let-bound specification named mulcomm_spec that uses llvm_fresh_var to create symbolic 8-bit integer inputs x and y, and verifies the commutativity property of multiplication by calling the exact LLVM function implementing multiplication from the source. Include any minimal preconditions necessary for safety and termination, and use the prove command to verify the specification against the loaded LLVM function."},{"role":"assistant","content":"```saw\nlet {{ mulcomm (x:[8]) y = x * y == y * x }};\nwrite_cnf \"mulcomm1.cnf\" {{ \\x y -> ~(mulcomm x y) }};\nprove (offline_cnf \"mulcomm2\") {{ mulcomm }};\n```"}]}
{"filename":"saw-script\/intTests\/test_intro_examples\/ffs_bug.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'ffs.bc' and defines a let-bound specification named 'ffs_bug_spec'. This spec should symbolically declare a 32-bit input variable representing the argument to the function 'uint32_t ffs_bug(uint32_t)'. The spec must call 'ffs_bug' and 'ffs_ref' with this symbolic input and assert their equivalence. Include any minimal preconditions necessary for safe execution. Then invoke an equivalence proof between 'ffs_bug' and 'ffs_ref' using this spec.\n\n# Source code:\nffs.c\n```C\n#include <stdint.h>\n\nuint32_t ffs_ref(uint32_t word) {\n  if(!word) return 0;\n  for(int c = 0, i = 0; c < 32; c++)\n    if(((1 << i++) & word) != 0)\n      return i;\n  return 0;\n}\n\nuint32_t ffs_imp(uint32_t i) {\n  char n = 1;\n  if (!(i & 0xffff)) { n += 16; i >>= 16; }\n  if (!(i & 0x00ff)) { n +=  8; i >>=  8; }\n  if (!(i & 0x000f)) { n +=  4; i >>=  4; }\n  if (!(i & 0x0003)) { n +=  2; i >>=  2; }\n  return (i) ? (n+((i+1) & 0x01)) : 0;\n}\n\nuint32_t ffs_imp_nobranch(uint32_t i) {\n  char n = 1;\n  int s1 = !(i & 0xffff) << 4;\n  n += s1; i >>= s1;\n  int s2 = !(i & 0x00ff) << 3;\n  n += s2;  i >>= s2;\n  int s3 = !(i & 0x000f) << 2;\n  n += s3;  i >>= s3;\n  int s4 = !(i & 0x0003) << 1;\n  n += s4;  i >>= s4;\n  \/\/ Still does have one branch...\n  return (i) ? (n+((i+1) & 0x01)) : 0;\n}\n\n\/\/ and now a buggy one\nuint32_t ffs_bug(uint32_t word) {\n    \/\/ injected bug:\n    if(word == 0x101010) return 4; \/\/ instead of 5\n    return ffs_ref(word);\n}\n\n\/\/ Creative optimized version based on musl libc:\n\/\/ http:\/\/www.musl-libc.org\/.\n\/\/\n\/\/ Apparently this is a well known approach:\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Find_first_set#CTZ. The DeBruijn\n\/\/ (https:\/\/en.wikipedia.org\/wiki\/De_Bruijn_sequence) sequence here is\n\/\/ different from the one in the Wikipedia article on 'ffs'.\nuint32_t ffs_musl (uint32_t x)\n{\n  static const char debruijn32[32] = {\n    0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,\n    31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14\n  };\n  return x ? debruijn32[(x&-x)*0x076be629 >> 27]+1 : 0;\n}\n\nint ffs_imp_correct(uint32_t x) {\n    return ffs_imp(x) == ffs_ref(x);\n}\n\nint ffs_bug_correct(uint32_t x) {\n    return ffs_bug(x) == ffs_ref(x);\n}\n\n```"},{"role":"assistant","content":"```saw\nset_base 16;\nm <- llvm_load_module \"ffs.bc\";\nprint \"Extracting functional models...\";\nref <- llvm_extract m \"ffs_ref\";\nbug <- llvm_extract m \"ffs_bug\";\nprint \"Trying to prove equivalence...\";\nr <- time (prove abc {{ ref === bug }});\nprint r;\n```"}]}
{"filename":"saw-script\/intTests\/test_intro_examples\/ffs_sat.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the LLVM backend that loads the module from 'ffs.bc'. Define a let-bound specification named 'ffs_imp_spec' that creates a fresh symbolic 32-bit variable 'x' as input to the function 'ffs_imp'. Add any minimal preconditions needed for safe execution. Then verify the function 'ffs_imp' against its expected behavior or properties as defined in the source. Reference the exact symbol 'ffs_imp' from the LLVM module and use 'llvm_fresh_var' for symbolic input generation.\n\n# Source code:\nffs.c\n```C\n#include <stdint.h>\n\nuint32_t ffs_ref(uint32_t word) {\n  if(!word) return 0;\n  for(int c = 0, i = 0; c < 32; c++)\n    if(((1 << i++) & word) != 0)\n      return i;\n  return 0;\n}\n\nuint32_t ffs_imp(uint32_t i) {\n  char n = 1;\n  if (!(i & 0xffff)) { n += 16; i >>= 16; }\n  if (!(i & 0x00ff)) { n +=  8; i >>=  8; }\n  if (!(i & 0x000f)) { n +=  4; i >>=  4; }\n  if (!(i & 0x0003)) { n +=  2; i >>=  2; }\n  return (i) ? (n+((i+1) & 0x01)) : 0;\n}\n\nuint32_t ffs_imp_nobranch(uint32_t i) {\n  char n = 1;\n  int s1 = !(i & 0xffff) << 4;\n  n += s1; i >>= s1;\n  int s2 = !(i & 0x00ff) << 3;\n  n += s2;  i >>= s2;\n  int s3 = !(i & 0x000f) << 2;\n  n += s3;  i >>= s3;\n  int s4 = !(i & 0x0003) << 1;\n  n += s4;  i >>= s4;\n  \/\/ Still does have one branch...\n  return (i) ? (n+((i+1) & 0x01)) : 0;\n}\n\n\/\/ and now a buggy one\nuint32_t ffs_bug(uint32_t word) {\n    \/\/ injected bug:\n    if(word == 0x101010) return 4; \/\/ instead of 5\n    return ffs_ref(word);\n}\n\n\/\/ Creative optimized version based on musl libc:\n\/\/ http:\/\/www.musl-libc.org\/.\n\/\/\n\/\/ Apparently this is a well known approach:\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Find_first_set#CTZ. The DeBruijn\n\/\/ (https:\/\/en.wikipedia.org\/wiki\/De_Bruijn_sequence) sequence here is\n\/\/ different from the one in the Wikipedia article on 'ffs'.\nuint32_t ffs_musl (uint32_t x)\n{\n  static const char debruijn32[32] = {\n    0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,\n    31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14\n  };\n  return x ? debruijn32[(x&-x)*0x076be629 >> 27]+1 : 0;\n}\n\nint ffs_imp_correct(uint32_t x) {\n    return ffs_imp(x) == ffs_ref(x);\n}\n\nint ffs_bug_correct(uint32_t x) {\n    return ffs_bug(x) == ffs_ref(x);\n}\n\n```"},{"role":"assistant","content":"```saw\nset_base 2;\nm <- llvm_load_module \"ffs.bc\";\nprint \"Extracting functional model...\";\nimp <- llvm_extract m \"ffs_imp\";\nprint \"Finding input for implementation that yields result of 4...\";\nr <- time (sat abc {{ \\x -> imp x == 4 }});\nprint r;\n```"}]}
{"filename":"saw-script\/intTests\/test_intro_examples\/unfold.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test_intro_examples\/unfold.saw, defines a let-bound specification named unfold_spec that symbolically inputs two 8-bit integers x and y using llvm_fresh_var, calls the function f with these inputs, then calls g and h with the same inputs, and verifies that g(x,y) equals h(x,y) using an appropriate LLVM verification command. Include minimal preconditions to ensure safe execution if needed, and reference the exact function names f, g, and h as defined in the LLVM module."},{"role":"assistant","content":"```saw\nlet {{ f x y = (x : [8]) + y }};\nlet {{ g x y = 2 * (f x y) }};\nlet {{ h x y = (f x y) + (f x y) }};\nlet {{ prop x y = g x y == h x y }};\nprint \"Original f:\";\nprint_term {{ f }};\nprint \"Unfolded f:\";\nlet t = unfold_term [\"f\"] {{ f }};\nprint_term t;\nprint \"Simplified f:\";\nprint_term (rewrite (cryptol_ss ()) t);\n```"}]}
{"filename":"saw-script\/intTests\/test_intro_examples\/ffs_bug_fail.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"ffs.bc\" that defines the functions ffs_ref and ffs_bug with signature uint32_t(uint32_t). Define a let-bound specification named ffs_bug_spec that creates a symbolic 32-bit input variable using llvm_fresh_var, with no additional preconditions. The spec should call both ffs_ref and ffs_bug on the symbolic input and assert their outputs are equal. Then prove the equivalence of ffs_ref and ffs_bug using this spec.\n\n# Source code:\nffs.c\n```C\n#include <stdint.h>\n\nuint32_t ffs_ref(uint32_t word) {\n  if(!word) return 0;\n  for(int c = 0, i = 0; c < 32; c++)\n    if(((1 << i++) & word) != 0)\n      return i;\n  return 0;\n}\n\nuint32_t ffs_imp(uint32_t i) {\n  char n = 1;\n  if (!(i & 0xffff)) { n += 16; i >>= 16; }\n  if (!(i & 0x00ff)) { n +=  8; i >>=  8; }\n  if (!(i & 0x000f)) { n +=  4; i >>=  4; }\n  if (!(i & 0x0003)) { n +=  2; i >>=  2; }\n  return (i) ? (n+((i+1) & 0x01)) : 0;\n}\n\nuint32_t ffs_imp_nobranch(uint32_t i) {\n  char n = 1;\n  int s1 = !(i & 0xffff) << 4;\n  n += s1; i >>= s1;\n  int s2 = !(i & 0x00ff) << 3;\n  n += s2;  i >>= s2;\n  int s3 = !(i & 0x000f) << 2;\n  n += s3;  i >>= s3;\n  int s4 = !(i & 0x0003) << 1;\n  n += s4;  i >>= s4;\n  \/\/ Still does have one branch...\n  return (i) ? (n+((i+1) & 0x01)) : 0;\n}\n\n\/\/ and now a buggy one\nuint32_t ffs_bug(uint32_t word) {\n    \/\/ injected bug:\n    if(word == 0x101010) return 4; \/\/ instead of 5\n    return ffs_ref(word);\n}\n\n\/\/ Creative optimized version based on musl libc:\n\/\/ http:\/\/www.musl-libc.org\/.\n\/\/\n\/\/ Apparently this is a well known approach:\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Find_first_set#CTZ. The DeBruijn\n\/\/ (https:\/\/en.wikipedia.org\/wiki\/De_Bruijn_sequence) sequence here is\n\/\/ different from the one in the Wikipedia article on 'ffs'.\nuint32_t ffs_musl (uint32_t x)\n{\n  static const char debruijn32[32] = {\n    0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,\n    31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14\n  };\n  return x ? debruijn32[(x&-x)*0x076be629 >> 27]+1 : 0;\n}\n\nint ffs_imp_correct(uint32_t x) {\n    return ffs_imp(x) == ffs_ref(x);\n}\n\nint ffs_bug_correct(uint32_t x) {\n    return ffs_bug(x) == ffs_ref(x);\n}\n\n```"},{"role":"assistant","content":"```saw\nset_base 16;\nm <- llvm_load_module \"ffs.bc\";\nprint \"Extracting functional models...\";\nref <- llvm_extract m \"ffs_ref\";\nbug <- llvm_extract m \"ffs_bug\";\nprint \"Checking for bug via random testing...\";\nr <- time (prove (quickcheck 1000) {{ ref === bug }});\nprint r;\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_fresh_expanded_value\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the provided source files and defines let-bound specs for each target function using llvm_fresh_var or llvm_fresh_expanded_value as symbolic inputs. Each spec should call llvm_execute_func with these symbolic inputs matching the exact function signatures from the source. Include minimal preconditions for safety such as array bounds or valid ADT constructions. Then verify each function against its spec using llvm_verify, referencing the exact function names as given. Do not inline specs directly in verify calls and do not include solver references in the specs."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\nlet s1_adt = mir_find_adt m \"test::S1\" [];\nlet s2_adt = mir_find_adt m \"test::S2\" [];\n\nlet f_spec = do {\n  s <- mir_fresh_expanded_value \"s\" (mir_adt s1_adt);\n\n  mir_execute_func [s];\n};\n\nlet g_spec = do {\n  a <- mir_fresh_expanded_value \"a\" (mir_array 2 mir_u32);\n\n  mir_execute_func [a];\n};\n\nlet h_spec = do {\n  t <- mir_fresh_expanded_value \"t\" (mir_tuple [mir_u32, mir_u32]);\n\n  mir_execute_func [t];\n};\n\nlet i_spec = do {\n  s <- mir_fresh_expanded_value \"s\" (mir_adt s2_adt);\n\n  mir_execute_func [s];\n};\n\nmir_verify m \"test::f\" [] false f_spec z3;\nmir_verify m \"test::g\" [] false g_spec z3;\nmir_verify m \"test::h\" [] false h_spec z3;\nfails (\n  mir_verify m \"test::i\" [] false i_spec z3\n);\n```"}]}
{"filename":"saw-script\/intTests\/test_sanitize\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM modules add-normal.bc and add-sanitized.bc, defines a let-bound specification named f_spec which creates two fresh 32-bit integer variables x and y, and symbolically executes the function f with these inputs. The harness should then verify the function f in both modules against f_spec without additional preconditions or solver references."},{"role":"assistant","content":"```saw\nm_norm <- llvm_load_module \"add-normal.bc\";\nm_san <- llvm_load_module \"add-sanitized.bc\";\n\nlet f_spec = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    llvm_execute_func [llvm_term x, llvm_term y];\n};\n\nllvm_verify m_norm \"f\" [] false f_spec z3;\nfails (llvm_verify m_san \"f\" [] false f_spec z3);\n```"}]}
{"filename":"saw-script\/intTests\/test_goal_num_ite\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the LLVM backend that loads the module from \"test.bc\" and defines let-bound specs for the functions f, g, and h as declared in test.c. For each spec, allocate a 64-bit integer pointer, create a fresh symbolic 64-bit variable, and set the pointer to point to this variable. For h_spec, add the precondition that the symbolic variable is greater than 1. Execute the corresponding LLVM function with the pointer argument. Specify the expected postcondition for g as doubling the input value, for h as tripling the input value, and for f as applying both transformations sequentially (i.e., six times the input). Then verify g and h individually, capturing their verification overrides, and finally verify f using these overrides. Do not include comments or solver references in the SAWScript code.\n\n# Source code:\ntest.c\n```C\n#include<stdint.h>\n\nvoid g(uint64_t* a) {\n  *a = 2*(*a);\n};\n\nvoid h(uint64_t* a) {\n  *a = 3*(*a);\n};\n\nvoid f(uint64_t* x) {\n  g(x);\n  h(x);\n};\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nlet f_spec = do {\n  xp <- llvm_alloc (llvm_int 64);\n  x <- llvm_fresh_var \"x\" (llvm_int 64);\n  llvm_points_to xp (crucible_term x);\n  llvm_execute_func [xp];\n  llvm_points_to xp (crucible_term {{ 6*x }});\n};\n\nlet g_spec = do {\n  xp <- llvm_alloc (llvm_int 64);\n  x <- llvm_fresh_var \"x\" (llvm_int 64);\n  llvm_points_to xp (crucible_term x);\n  llvm_execute_func [xp];\n  llvm_points_to xp (crucible_term {{(2*x):[64]}});\n};\n\nlet h_spec = do {\n  xp <- llvm_alloc (llvm_int 64);\n  x <- llvm_fresh_var \"x\" (llvm_int 64);\n  llvm_points_to xp (crucible_term {{x}});\n  llvm_precond {{ x > 1 }};\n  llvm_execute_func [xp];\n  llvm_points_to xp (crucible_term {{(3*x):[64]}});\n};\n\ng_ov <- llvm_verify m \"g\" [] false g_spec z3;\nh_ov <- llvm_verify m \"h\" [] false h_spec z3;\n\nenable_experimental;\n\n\/\/ we get two verification conditions: on for the precondition of h, and one for the postcondition of f\n\/\/ the override precondition of h is violated, but if we assume it's unsat then verification succeeds:\nllvm_verify m \"f\" [g_ov, h_ov] false f_spec\n  (goal_num_ite 0\n    assume_unsat\n    w4);\n\n\/\/ on the other hand, if we provide the wrong goal number, then it fails.\nfails (\n  llvm_verify m \"f\" [g_ov, h_ov] false f_spec\n    (goal_num_ite 1\n      assume_unsat\n      w4)\n);\n```"}]}
{"filename":"saw-script\/intTests\/test2415\/test2.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated LLVM module using llvm_load_module, then defines a let-bound specification named divmod_spec that symbolically inputs two 32-bit integers using llvm_fresh_var, adds preconditions to ensure the divisor is non-zero, and calls the exact division and modulo functions from the source with their correct LLVM symbol names. The spec should verify that the division and modulo operations conform to the expected mathematical properties as illustrated in the SAW excerpt, using the prove function to check correctness."},{"role":"assistant","content":"```saw\nlet prove_print_sbv = prove_print z3;\nlet prove_print_w4 = prove_print w4;\n\nlet props =\n      [ {{ (  5  \/   4)  ==  1 }}\n      , {{ ((-5) \/   4)  == -2 }}\n      , {{ (  5  \/ (-4)) == -2 }}\n      , {{ ((-5) \/ (-4)) ==  1 }}\n\n      , {{ (  5  %   4)  ==  1 }}\n      , {{ ((-5) %   4)  ==  3 }}\n      , {{ (  5  % (-4)) == -3 }}\n      , {{ ((-5) % (-4)) == -1 }}\n      ];\nfor props prove_print_sbv;\nfor props prove_print_w4;\n```"}]}
{"filename":"saw-script\/intTests\/test_stack_traces\/trace009.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java method print_stack defined in the associated source files. Use jvm_load_class to load the relevant class and jvm_fresh_var to create symbolic inputs as needed. Define a let-bound specification named print_stack_spec that sets up the method call with appropriate symbolic arguments and minimal preconditions to ensure safe execution. Then invoke jvm_verify to verify the method against this specification. The SAWScript must directly reference the exact class and method names from the source and avoid inline do blocks in argument positions."},{"role":"assistant","content":"```saw\nenable_experimental;\n\n\/\/ Arguments to SAWScript functions that are monadic callbacks should\n\/\/ behave the same way as arguments to builtins. Alas, not for now...\nprint \"------------------------------------------------------------\";\nprint \"monadic callback argument\";\nlet f1 m = do { m; return (); };\nf1 print_stack;\n\n\/\/ A bind\/return pair should produce the same trace behavior as a let.\nprint \"------------------------------------------------------------\";\nprint \"bind\/return\";\nf2 <- return print_stack;\nf2;\n\n\/\/ If you cons a tuple of actions and push it around, ideally that\n\/\/ should also result in trace frames. Currently, though, it does\n\/\/ not.\nprint \"------------------------------------------------------------\";\nprint \"tuple with let\";\nlet pair1 = (print_stack, print_stack);\nlet pair2 = pair1;\nlet (f3, _) = pair2;\nf3;\n\nprint \"------------------------------------------------------------\";\nprint \"tuple with bind\";\nlet pair3 = (print_stack, print_stack);\nlet pair4 = pair3;\n(f4, _) <- return pair4;\nf4;\n\n\/\/ Things are simpler for tuples that don't get pushed around.\nprint \"------------------------------------------------------------\";\nprint \"one-step tuple with let\";\nlet (f5, _) = (print_stack, print_stack);\nf5;\n\nprint \"------------------------------------------------------------\";\nprint \"one-step tuple with bind\";\n(f6, _) <- return (print_stack, print_stack);\nf6;\n\n\/\/ Repeat the tuple cases inside a do-block.\ndo {\n   print \"------------------------------------------------------------\";\n   print \"tuple with let, in do-block\";\n   let pair5 = (print_stack, print_stack);\n   let pair6 = pair5;\n   let (f7, _) = pair6;\n   f7;\n\n   print \"------------------------------------------------------------\";\n   print \"tuple with bind, in do-block\";\n   let pair7 = (print_stack, print_stack);\n   let pair8 = pair7;\n   (f8, _) <- return pair8;\n   f8;\n\n   print \"------------------------------------------------------------\";\n   print \"one-step tuple with let, in do-block\";\n   let (f9, _) = (print_stack, print_stack);\n   f9;\n\n   print \"------------------------------------------------------------\";\n   print \"one-step tuple with bind\";\n   (f10, _) <- return (print_stack, print_stack);\n   f10;\n\n   return ();\n};\n```"}]}
{"filename":"saw-script\/intTests\/test_stack_traces\/trace003.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the C\/Java functions specified in the input, using the appropriate backend inferred from the source files (jvm_* if java_load_class is present, llvm_* if llvm_load_module is present). Define a let-bound specification named <function>_spec using a do-block. Use symbolic inputs created with jvm_fresh_var or llvm_fresh_var for all function arguments. Include minimal preconditions necessary for safe execution, such as array bounds or non-zero divisors. Reference the exact function or method names and signatures from the associated source files when invoking them in the spec. The harness should be suitable for direct verification without inline do-blocks or comments."},{"role":"assistant","content":"```saw\nenable_experimental;\nprint \"\";\n\n\/\/ calls in ProofScript\n\/\/\n\/\/ This could just replicate all the cases in trace002, but does not;\n\/\/ the expectation is that most of the logic (especially for SAWScript\n\/\/ execution) is shared and doesn't need to be tested twice. Instead\n\/\/ we just make sure that (a) it works at all from inside the\n\/\/ ProofScript monad and (b) the transition calling back into the\n\/\/ interpreter for the proof script comes out in a reasonable way.\n\n\n\/\/ Test just proof_stack by itself.\n\/\/ This does not actually solve the goal so wrap in \"fails\".\nprint \"------------------------------------------------------------\";\nprint \"just proof_stack\";\nfails (prove_print proof_stack {{ True }});\nprint \"\";\n\n\/\/ Test proof_stack via a let-binding.\n\/\/ This does not actually solve the goal so wrap in \"fails\".\nprint \"------------------------------------------------------------\";\nprint \"proof_stack via let\";\nlet pf = proof_stack;\nfails (prove_print pf {{ True }});\nprint \"\";\n\n\/\/ Test with an inline do-block.\nprint \"------------------------------------------------------------\";\nprint \"do-block\";\nprove_print (do { proof_stack; z3; }) {{ True }};\nprove_print (do { z3; proof_stack; }) {{ True }};\nprint \"\";\n\n\/\/ Test with an action that doesn't take arguments.\nprint \"------------------------------------------------------------\";\nprint \"action\";\nlet prove1 = do { proof_stack; z3; };\nlet prove2 = do { z3; proof_stack; };\nprove_print prove1 {{ True }};\nprove_print prove2 {{ True }};\nprint \"\";\n\n\/\/ Test with an action that does take arguments.\nprint \"------------------------------------------------------------\";\nprint \"function\";\nlet prove3 () = do { proof_stack; z3; };\nlet prove4 () = do { z3; proof_stack; };\nprove_print (prove3 ()) {{ True }};\nprove_print (prove4 ()) {{ True }};\nprint \"\";\n```"}]}
{"filename":"saw-script\/intTests\/test_stack_traces\/trace002.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the JVM backend that loads the Java class containing the methods p1, p2, p3, p22, m1a through m1d, m2a through m2l, m22a through m22d, m1p1a through m1p1d, and ma1a through ma2h. Define a let-bound specification named stack_trace_spec that uses jvm_fresh_var to create symbolic inputs as needed, invokes these methods by their exact Java method signatures, and includes minimal preconditions to ensure safe execution. The spec should verify the behavior of these methods with respect to stack trace printing and monadic action sequencing, referencing the exact Java method names and signatures from the associated source files."},{"role":"assistant","content":"```saw\nenable_experimental;\n\n\/\/ call chains within SAWScript\n\n\/\/ pure functions\nlet p1 () = run (print_stack);\nlet p2 () = p1 ();\nlet p3 () = p2 ();\nlet p22 () = let () = p1 () in p1 ();\n\n\/\/ monadic actions (in TopLevel)\n\/\/\n\/\/ Note that the last position of a do-block is different, so be sure\n\/\/ to check that explicitly.\n\nlet m1a = print_stack;\nlet m1b = do { print_stack; };\nlet m1c = do { print_stack; return (); };\nlet m1d = do { let x = 5; print_stack; };\n\nlet m2a = m1a;\nlet m2b = do { m1a; };\nlet m2c = do { m1a; return (); };\nlet m2d = do { let x = 5; m1a; };\nlet m2e = m1b;\nlet m2f = do { m1b; };\nlet m2g = do { m1b; return (); };\nlet m2h = do { let x = 5; m1b; };\nlet m2i = m1c;\nlet m2j = do { m1c; };\nlet m2k = do { m1c; return (); };\nlet m2l = do { let x = 5; m1c; };\n\nlet m22a = do { m1a; m1a; };\nlet m22b = do { m1a; m1a; return (); };\nlet m22c = do { m1b; m1b; };\nlet m22d = do { m1c; m1c; return (); };\n\nlet m1p1a = do { m1a; return (p1 ()); };\nlet m1p1b = do { let _ = p1 (); m1a; };\nlet m1p1c = do { m1a; let _ = p1 (); return (); };\nlet m1p1d = do { let _ = p1 (); m1a; return (); };\n\n\/\/ monadic actions that take arguments\n\nlet ma1a () = print_stack;\nlet ma1b () = do { print_stack; };\nlet ma1c () = do { print_stack; return (); };\nlet ma1d () = do { let x = 5; print_stack; };\n\nlet ma2a () = ma1a ();\nlet ma2b () = do { ma1a (); };\nlet ma2c () = do { ma1a (); return (); };\nlet ma2d () = do { let x = 5; ma1a (); };\nlet ma2e () = ma1b ();\nlet ma2f () = do { ma1b (); };\nlet ma2g () = do { ma1b (); return (); };\nlet ma2h () = do { let x = 5; ma1b (); };\n\n\/\/ now run them\n\nprint \"p1\"; let _ = p1 ();\nprint \"p2\"; let _ = p2 ();\nprint \"p3\"; let _ = p3 ();\nprint \"p22\"; let _ = p22 ();\n\nprint \"m1a\"; m1a;\nprint \"m1b\"; m1b;\nprint \"m1c\"; m1c;\nprint \"m1d\"; m1d;\n\nprint \"m2a\"; m2a;\nprint \"m2b\"; m2b;\nprint \"m2c\"; m2c;\nprint \"m2d\"; m2d;\nprint \"m2e\"; m2e;\nprint \"m2f\"; m2f;\nprint \"m2g\"; m2g;\nprint \"m2h\"; m2h;\nprint \"m2i\"; m2i;\nprint \"m2j\"; m2j;\nprint \"m2k\"; m2k;\nprint \"m2l\"; m2l;\n\nprint \"m22a\"; m22a;\nprint \"m22b\"; m22b;\nprint \"m22c\"; m22c;\nprint \"m22d\"; m22d;\n\nprint \"m1p1a\"; m1p1a;\nprint \"m1p1b\"; m1p1b;\nprint \"m1p1c\"; m1p1c;\nprint \"m1p1d\"; m1p1d;\n\nprint \"ma1a\"; ma1a ();\nprint \"ma1b\"; ma1b ();\nprint \"ma1c\"; ma1c ();\nprint \"ma1d\"; ma1d ();\n\nprint \"ma2a\"; ma2a ();\nprint \"ma2b\"; ma2b ();\nprint \"ma2c\"; ma2c ();\nprint \"ma2d\"; ma2d ();\nprint \"ma2e\"; ma2e ();\nprint \"ma2f\"; ma2f ();\nprint \"ma2g\"; ma2g ();\nprint \"ma2h\"; ma2h ();\n```"}]}
{"filename":"saw-script\/intTests\/test_stack_traces\/trace004.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"test.bc\" that verifies the function \"foo\" defined in \"test.c\". Define a let-bound spec named foo_spec that uses llvm_fresh_var to create any necessary symbolic inputs (if applicable) and includes minimal preconditions to ensure safety and termination. The spec should call the function \"foo\" via llvm_execute_func and incorporate llvm_stack to capture stack traces. Then use llvm_verify to verify \"foo\" against foo_spec with no additional arguments and no solver references.\n\n# Source code:\ntest.c\n```C\nvoid foo(void) { }\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\nmod <- llvm_load_module \"test.bc\";\nprint \"\";\n\n\/\/ calls in LLVMSetup\n\/\/\n\/\/ This is basically like trace003, for the same reasons, except in\n\/\/ LLVMSetup.\n\n\n\/\/ Test just llvm_stack by itself.\n\/\/ This probably should not actually verify, but it does...\nprint \"------------------------------------------------------------\";\nprint \"just llvm_stack\";\nllvm_verify mod \"foo\" [] false llvm_stack z3;\nprint \"\";\n\n\/\/ Test just llvm_stack via a let-binding.\n\/\/ This probably should not actually verify, but it does...\nprint \"------------------------------------------------------------\";\nprint \"llvm_stack via let\";\nlet spec0 = llvm_stack;\nllvm_verify mod \"foo\" [] false spec0 z3;\nprint \"\";\n\n\/\/ Test with an inline do-block.\nprint \"------------------------------------------------------------\";\nprint \"do-block\";\nllvm_verify mod \"foo\" [] false (do { llvm_stack; llvm_execute_func []; }) z3;\nllvm_verify mod \"foo\" [] false (do { llvm_execute_func []; llvm_stack; }) z3;\nprint \"\";\n\n\/\/ Test with an action that doesn't take arguments.\nprint \"------------------------------------------------------------\";\nprint \"action\";\nlet spec1 = do { llvm_stack; llvm_execute_func []; };\nlet spec2 = do { llvm_execute_func []; llvm_stack; };\nllvm_verify mod \"foo\" [] false spec1 z3;\nllvm_verify mod \"foo\" [] false spec2 z3;\nprint \"\";\n\n\/\/ Test with an action that does take arguments.\nprint \"------------------------------------------------------------\";\nprint \"function\";\nlet spec3 () = do { llvm_stack; llvm_execute_func []; };\nlet spec4 () = do { llvm_execute_func []; llvm_stack; };\nllvm_verify mod \"foo\" [] false (spec3 ()) z3;\nllvm_verify mod \"foo\" [] false (spec4 ()) z3;\nprint \"\";\n```"}]}
{"filename":"saw-script\/intTests\/test_stack_traces\/trace010.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test_stack_traces\/trace010.saw, defines a let-bound specification named foo_spec that symbolically calls the function foo with appropriate fresh variables, ensuring any necessary preconditions for safe execution, and then verifies foo against foo_spec using llvm_verify. Similarly, define and verify a spec for baz if it corresponds to a function symbol in the LLVM module. Use llvm_fresh_var for symbolic inputs and reference exact function names as defined in the LLVM module."},{"role":"assistant","content":"```saw\nenable_experimental;\n\n\/\/ See what happens if we return a monadic value out of the tail of a\n\/\/ do-block and then execute it.\n\/\/\n\/\/ Currently this does not trace the flow of the monadic value;\n\/\/ arguably it shouldn't. What's flowing is not print_stack but\n\/\/ a separate monadic value that contains print_stack.\nlet get_print_stack = do { return print_stack; };\nlet foo = do { let x = 3; get_print_stack; };\nbar <- foo;\nbar;\n\n\/\/ Similarly if you pass around a pure function that returns a monadic\n\/\/ value, that doesn't get tracked.\nlet get_print_stack' () = print_stack;\nlet baz = get_print_stack';\nbaz ();\n```"}]}
{"filename":"saw-script\/intTests\/test_stack_traces\/trace006.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test_stack_traces\/trace006.saw, defines a let-bound specification named stack_trace_spec that symbolically calls the exact function(s) defined in the associated LLVM source files, using llvm_fresh_var to create symbolic inputs with minimal preconditions to ensure safety and termination, and then verifies the function(s) against this specification using llvm_verify."},{"role":"assistant","content":"```saw\nenable_experimental;\n\n\/\/ see what happens with for, because it has its own private\n\/\/ implementation of a number of things\n\nlet p1 _ = print_stack;\nlet p2 _ = do { print_stack; return (); };\n\nfor [1,2,3] p1;\nfor [1,2,3] p2;\n```"}]}
{"filename":"saw-script\/intTests\/test_stack_traces\/trace007.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the provided source files using llvm_load_module. Define a let-bound specification named foo_spec that symbolically inputs four integer variables using llvm_fresh_var, calls the function foo with these variables, and verifies its behavior including the stack trace output. Similarly, define a let-bound specification bar_spec that symbolically inputs four integer variables, calls the function bar, and verifies its behavior including the stack trace. Include minimal preconditions to ensure safe execution. Then, verify both foo and bar functions against their respective specs using llvm_verify."},{"role":"assistant","content":"```saw\nenable_experimental;\n\n\/\/ Try with lots of arguments, just in case there's anything funny\n\/\/ in the argument handling.\n\nlet foo a b c d = (a, b, c, d, run print_stack);\nreturn (foo 1 2 3 4);\n\nlet bar a b c d = do { print_stack; return (a, b, c, d); };\nbar 1 2 3 4;\n```"}]}
{"filename":"saw-script\/intTests\/test0065_match_llvm_elem\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from test.bc and defines let-bound specs for the functions f, g, and h as declared in test.c. For each spec, allocate appropriate LLVM memory for the parameters (e.g., llvm_array or llvm_alias for struct s), use llvm_fresh_var or llvm_alloc to create symbolic inputs, and call llvm_execute_func with llvm_elem or llvm_field to reference the exact parameters by pointer. Add minimal preconditions to ensure safety (e.g., array bounds). Then use llvm_unsafe_assume_spec to associate each spec with its function symbol and verify the test_f, test_g, and test_h functions accordingly.\n\n# Source code:\ntest.c\n```C\nstruct s { int x; int y; };\n\nvoid f(int* x, int* y);\nvoid g(int* x);\nvoid h(int* y, struct s* sp);\n\nvoid test_f()\n{\n  int a[2];\n  f(a + 1, a);\n}\n\nvoid test_g()\n{\n  int a[2];\n  g(a + 1);\n}\n\nvoid test_h()\n{\n  struct s s0;\n  h(&s0.y, &s0);\n}\n\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nlet f_spec = do {\n  x_p <- llvm_alloc (llvm_array 2 (llvm_int 32));\n  llvm_execute_func [(llvm_elem x_p 1), x_p];\n};\n\nlet f_false_spec = do {\n  x_p <- llvm_alloc (llvm_array 2 (llvm_int 32));\n  llvm_execute_func [(llvm_elem x_p 1), (llvm_elem x_p 1)];\n};\n\nlet g_spec = do {\n  x_p <- llvm_alloc (llvm_array 2 (llvm_int 32));\n  llvm_execute_func [(llvm_elem x_p 1)];\n};\n\nlet g_false_spec = do {\n  x_p <- llvm_alloc (llvm_array 3 (llvm_int 32));\n  llvm_execute_func [(llvm_elem x_p 1)];\n};\n\nlet h_spec = do {\n  s_p <- llvm_alloc (llvm_alias \"struct.s\");\n  llvm_execute_func [(llvm_field s_p \"y\"), s_p];\n};\n\nlet test_spec = do {\n  llvm_execute_func [];\n};\n\nf_ov <- llvm_unsafe_assume_spec m \"f\" f_spec;\nf_false_ov <- llvm_unsafe_assume_spec m \"f\" f_false_spec;\ng_ov <- llvm_unsafe_assume_spec m \"g\" g_spec;\ng_false_ov <- llvm_unsafe_assume_spec m \"g\" g_false_spec;\nh_ov <- llvm_unsafe_assume_spec m \"h\" h_spec;\nllvm_verify m \"test_f\" [f_ov] false test_spec trivial;\nfails (llvm_verify m \"test_f\" [f_false_ov] false test_spec trivial);\nllvm_verify m \"test_g\" [g_ov] false test_spec trivial;\nfails (llvm_verify m \"test_g\" [g_false_ov] false test_spec trivial);\nllvm_verify m \"test_h\" [h_ov] false test_spec trivial;\n```"}]}
{"filename":"saw-script\/intTests\/test_bitfield_x86\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from test.bc that verifies the functions get_x2, get_y, set_x2, set_x2_alt, set_y, and set_y_alt defined in test.c. For each function, define a let-bound spec (e.g., let get_x2_spec = do { ... };) that allocates a struct s, creates symbolic inputs using llvm_fresh_var with appropriate bit widths matching the bitfield sizes, sets or checks the bitfield values using llvm_points_to_bitfield, executes the function with llvm_execute_func, and returns or asserts the expected results. Use symbolic inputs rather than constants and include minimal preconditions necessary for safety. Reference the exact function names as in the source and verify each function against its spec using llvm_verify_x86.\n\n# Source code:\ntest.c\n```C\n#include <stdbool.h>\n#include <stdint.h>\n\nstruct s {\n  int32_t w;\n  uint8_t x1:1;\n  uint8_t x2:2;\n  uint8_t y:1;\n  int32_t z;\n};\n\nuint8_t get_x2(struct s *ss) {\n  return ss->x2;\n}\n\nbool get_y(struct s *ss) {\n  return ss->y;\n}\n\nvoid set_x2(struct s *ss, uint8_t x2) {\n  ss->x2 = x2;\n}\n\nvoid set_y(struct s *ss, bool y) {\n  ss->y = y;\n}\n\nvoid set_x2_alt(struct s *ss, uint8_t x2) {\n  set_x2(ss, x2);\n}\n\nvoid set_y_alt(struct s *ss, bool y) {\n  set_y(ss, y);\n}\n\nint main() {\n  return 0;\n}\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\nenable_lax_loads_and_stores;\n\nlet get_x2_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 2);\n  llvm_points_to_bitfield ss \"x2\" (llvm_term z);\n  llvm_execute_func [ss];\n  llvm_return (llvm_term {{ zext z : [8] }});\n};\n\nlet get_y_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 1);\n  llvm_points_to_bitfield ss \"y\" (llvm_term z);\n  llvm_execute_func [ss];\n  llvm_return (llvm_term z);\n};\n\nlet set_x2_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 8);\n  llvm_execute_func [ss, llvm_term z];\n  llvm_points_to_bitfield ss \"x2\" (llvm_term {{ drop z : [2] }});\n};\n\nlet set_x2_alt_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 2);\n  llvm_execute_func [ss, llvm_term {{ zext z : [8] }}];\n  llvm_points_to_bitfield ss \"x2\" (llvm_term z);\n};\n\nlet set_y_spec = do {\n  ss <- llvm_alloc (llvm_alias \"struct.s\");\n  z <- llvm_fresh_var \"z\" (llvm_int 1);\n  llvm_execute_func [ss, llvm_term z];\n  llvm_points_to_bitfield ss \"y\" (llvm_term z);\n};\n\nlet set_y_alt_spec = set_y_spec;\n\nm <- llvm_load_module \"test.bc\";\n\nllvm_verify_x86 m \"test.exe\" \"get_x2\" [] false get_x2_spec (w4_unint_z3 []);\nllvm_verify_x86 m \"test.exe\" \"get_y\" [] false get_y_spec (w4_unint_z3 []);\nllvm_verify_x86 m \"test.exe\" \"set_x2\" [] false set_x2_spec (w4_unint_z3 []);\nllvm_verify_x86 m \"test.exe\" \"set_x2_alt\" [] false set_x2_alt_spec (w4_unint_z3 []);\nllvm_verify_x86 m \"test.exe\" \"set_y\" [] false set_y_spec (w4_unint_z3 []);\nllvm_verify_x86 m \"test.exe\" \"set_y_alt\" [] false set_y_alt_spec (w4_unint_z3 []);\n```"}]}
{"filename":"saw-script\/intTests\/test_jvm_modifies\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java class Test defined in Test.java. Load the class using java_load_class \"Test\". Define let-bound specs named spec_add1, spec_add2, and spec_add3 that allocate a Test object, create fresh symbolic int variables x and y, execute the methods add1, add2, and add3 respectively with these arguments, and specify the expected side effects on fields a, static field b, and array element c[1]. Also define specs for wrap1, wrap2, and wrap3 that call the corresponding add methods. Use jvm_modifies_field, jvm_modifies_static_field, and jvm_modifies_elem as appropriate for partial specifications. Use symbolic inputs with jvm_fresh_var and ensure the specs include jvm_return with the sum x + y. Do not inline the specs in jvm_verify calls; bind them with let. Reference exact method names as in the source.\n\n# Source code:\nTest.java\n```java\nclass Test\n{\n    int a;\n    static int b;\n    int[] c;\n\n    int add1 (int x, int y) {\n        a = x;\n        return x + y;\n    }\n\n    int add2 (int x, int y) {\n        b = x;\n        return x + y;\n    }\n\n    int add3 (int x, int y) {\n        c[1] = x;\n        return x + y;\n    }\n\n    int wrap1 (int x, int y) {\n        return add1 (x, y);\n    }\n    int wrap2 (int x, int y) {\n        return add2 (x, y);\n    }\n    int wrap3 (int x, int y) {\n        return add3 (x, y);\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"Test\";\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Specs with missing side effects\n\nprint \"Verification fails for add1 spec with missing side effect.\";\nfails (\n  jvm_verify c \"add1\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ x + y }});\n  } z3\n  );\n\nprint \"Verification fails for add2 spec with missing side effect.\";\nfails (\n  jvm_verify c \"add2\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ x + y }});\n  } z3\n  );\n\nprint \"Verification fails for add3 spec with missing side effect.\";\nfails (\n  jvm_verify c \"add3\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    arr <- jvm_alloc_array 2 java_int;\n    jvm_field_is this \"c\" arr;\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ x + y }});\n  } z3\n  );\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Full specifications with side effects\n\nlet spec1 =\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_field_is this \"a\" (jvm_term x);\n    jvm_return (jvm_term {{ x + y }});\n  };\n\nlet spec2 =\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_static_field_is \"b\" (jvm_term x);\n    jvm_return (jvm_term {{ x + y }});\n  };\n\nlet spec3 =\n  do {\n    this <- jvm_alloc_object \"Test\";\n    arr <- jvm_alloc_array 2 java_int;\n    jvm_field_is this \"c\" arr;\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_elem_is arr 1 (jvm_term x);\n    jvm_return (jvm_term {{ x + y }});\n  };\n\nprint \"Verification succeeds for complete add1 spec.\";\nadd1_full <- jvm_verify c \"add1\" [] false spec1 z3;\n\nprint \"Verification succeeds for complete add2 spec.\";\nadd2_full <- jvm_verify c \"add2\" [] false spec2 z3;\n\nprint \"Verification succeeds for complete add3 spec.\";\nadd3_full <- jvm_verify c \"add3\" [] false spec3 z3;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Partial specifications with jvm_modifies\n\nprint \"Verification succeeds for partial add1 spec (jvm_modifies_field).\";\nadd1_part <-\n  jvm_verify c \"add1\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_modifies_field this \"a\";\n    jvm_return (jvm_term {{ x + y }});\n  } z3;\n\nprint \"Verification succeeds for partial add2 spec (jvm_modifies_static_field).\";\nadd2_part <-\n  jvm_verify c \"add2\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_modifies_static_field \"b\";\n    jvm_return (jvm_term {{ x + y }});\n  } z3;\n\nprint \"Verification succeeds for partial add3 spec (jvm_modifies_elem).\";\nadd3_part <-\n  jvm_verify c \"add3\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    arr <- jvm_alloc_array 2 java_int;\n    jvm_field_is this \"c\" arr;\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_modifies_elem arr 1;\n    jvm_return (jvm_term {{ x + y }});\n  } z3;\n\nprint \"Verification succeeds for partial add3 spec (jvm_modifies_array).\";\nadd3_part_a <-\n  jvm_verify c \"add3\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    arr <- jvm_alloc_array 2 java_int;\n    jvm_field_is this \"c\" arr;\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [this, jvm_term x, jvm_term y];\n    jvm_modifies_array arr;\n    jvm_return (jvm_term {{ x + y }});\n  } z3;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Compositional verification with full specs\n\nprint \"Compositional verification succeeds with full add1 spec.\";\nwrap1_full <- jvm_verify c \"wrap1\" [add1_full] false spec1 z3;\n\nprint \"Compositional verification succeeds with full add1 spec.\";\nwrap2_full <- jvm_verify c \"wrap2\" [add2_full] false spec2 z3;\n\nprint \"Compositional verification succeeds with full add1 spec.\";\nwrap3_full <- jvm_verify c \"wrap3\" [add3_full] false spec3 z3;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Compositional verification with partial specs\n\nprint \"Compositional verification fails with partial add1 spec.\";\nfails (jvm_verify c \"wrap1\" [add1_part] false spec1 z3);\n\nprint \"Compositional verification fails with partial add2 spec.\";\nfails (jvm_verify c \"wrap2\" [add2_part] false spec2 z3);\n\nprint \"Compositional verification fails with partial add3 spec.\";\nfails (jvm_verify c \"wrap3\" [add3_part] false spec3 z3);\n\nprint \"DONE!\";\n```"}]}
{"filename":"saw-script\/intTests\/test0031_unit_test\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"test.bc\" that verifies the function \"foo\" with signature \"uint32_t foo(a_t*)\". Define a let-bound spec named foo_spec that allocates a symbolic 32-bit integer x, allocates a pointer p_a to a struct a_t, initializes p_a to point to x, executes foo with p_a as argument, returns the constant 3, and asserts that p_a points to 3 after execution. Use llvm_fresh_var and llvm_alloc for symbolic inputs and memory allocation. Then invoke llvm_verify on the module, function \"foo\", with foo_spec as the setup, and no additional preconditions.\n\n# Source code:\ntest.c\n```C\n#include <stdio.h>\n#include <stdint.h>\n\ntypedef struct {\n  uint32_t x;\n} a_t;\n\nuint32_t foo( a_t* s ) {\n  return s->x = 3;\n}\n\nuint32_t bar() {\n  a_t s[] = { { 1 }, {2}, {3}, {4} };\n\n  return foo( s );\n}\n\nint main() {\n  printf(\"%d\\n\", bar() );\n  return 0;\n}\n\n```"},{"role":"assistant","content":"```saw\nlet setup = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n\n  p_a <- llvm_alloc (llvm_alias \"struct.a_t\");\n  llvm_points_to p_a ( llvm_term {{ x }} );\n\n  llvm_execute_func [ p_a ];\n  llvm_return (llvm_term {{ 3:[32] }});\n\n  llvm_points_to p_a ( llvm_term {{ 3:[32] }} );\n};\n\nm <- llvm_load_module \"test.bc\";\nllvm_verify m \"foo\" [] false setup z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_verify_pop_count\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the function test::pop_count defined in the MIR module loaded from test.linked-mir.json. Define a let-bound specification named pop_count_spec that uses mir_fresh_var to create a symbolic 32-bit unsigned integer input x. Execute the function test::pop_count with this input using mir_execute_func, and specify that the function's return value equals the result of the provided popCount Cryptol function applied to x. Ensure the spec uses mir_return to return this value. Then verify the function against this spec using mir_verify with no additional arguments and no solver references."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet\n{{\npopCount : [32] -> [32]\npopCount bs = zext`{32,6} (ic ! 0) where\n    ic = [0] # [ if elt then prev + 1 else prev | elt <- bs | prev <- ic]\n}};\n\nlet pop_count_spec = do {\n  x <- mir_fresh_var \"x\" mir_u32;\n\n  mir_execute_func [mir_term x];\n\n  mir_return (mir_term {{ popCount x }});\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\nmir_verify m \"test::pop_count\" [] false pop_count_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test1691\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function 'f' defined in 'test.bc' corresponding to the C function 'int f(const struct s *ss)'. Define a let-bound spec named 'f_spec' that allocates a readonly 'struct s', creates symbolic 1-bit integer variables 'x' and 'y', assigns them to the bitfields 'x' and 'y' of the struct, executes 'f' with this struct, and returns 1 if x equals y, else 0. Use 'llvm_fresh_var' for symbolic inputs and ensure the spec matches the function signature. Then verify 'f' against 'f_spec' using 'llvm_verify'.\n\n# Source code:\ntest.c\n```C\nstruct s {\n  unsigned x:1;\n  unsigned y:1;\n};\n\nint f(const struct s *ss) {\n  return ss->x == ss->y;\n}\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\nenable_lax_loads_and_stores;\n\nlet f_spec = do {\n  ss <- llvm_alloc_readonly (llvm_alias \"struct.s\");\n  x <- llvm_fresh_var \"x\" (llvm_int 1);\n  y <- llvm_fresh_var \"y\" (llvm_int 1);\n  llvm_points_to_bitfield ss \"x\" (llvm_term x);\n  llvm_points_to_bitfield ss \"y\" (llvm_term y);\n\n  llvm_execute_func [ss];\n\n  llvm_return (llvm_term {{ if x == y then 1 else 0 : [32] }});\n};\n\nm <- llvm_load_module \"test.bc\";\nov <- llvm_verify m \"f\" [] false f_spec (w4_unint_yices []);\n```"}]}
{"filename":"saw-script\/intTests\/test_llvm_return_global\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'test.bc' and defines a let-bound specification 'foo_spec' for the function 'foo' with signature 'uint64_t *foo()'. The spec should allocate the global variable 'glob' symbolically, execute 'foo' with no arguments, and verify that the returned pointer equals the address of 'glob'. Similarly, define a let-bound specification 'bar_spec' for the function 'bar' with signature 'int bar()' that calls 'bar' with no arguments and verifies its return value is 1, indicating 'foo() == &glob'. Use symbolic inputs where necessary and minimal preconditions for safety. Use the llvm_* backend functions accordingly.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n#include <stdlib.h>\n\nuint64_t glob;\n\nuint64_t *foo () {\n\treturn &glob;\n}\n\nint bar () {\n\treturn (foo() == &glob);\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ This test checks whether we can verify a spec that says a function\n\/\/ returns a fresh pointer, when in actuality the function returns\n\/\/ a global. It is a regression test for saw-script issue #641.\n\/\/ https:\/\/github.com\/GaloisInc\/saw-script\/issues\/641\n\nbc <- llvm_load_module \"test.bc\";\n\nlet i64 = llvm_int 64;\n\nfails (\n  llvm_verify bc \"foo\" [] false\n    do {\n      llvm_alloc_global \"glob\";\n      llvm_execute_func [];\n      x <- llvm_alloc i64;\n      llvm_return x;\n    }\n    z3\n  );\n\nbar_ov1 <-\n  llvm_verify bc \"bar\" [] false\n    do {\n      llvm_alloc_global \"glob\";\n      llvm_execute_func [];\n      llvm_return (llvm_term {{ 1 : [32] }});\n    }\n    z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_sawscript_builtins\/eval.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated C or Java source files using the appropriate backend inferred from the presence of 'llvm_load_module' or 'java_load_class'. Define a let-bound specification named '<target>_spec' that symbolically models the target function or method signatures exactly as defined in the source. Use 'llvm_fresh_var' or 'jvm_fresh_var' to create symbolic inputs, adding minimal necessary preconditions for safe execution such as bounds checks or non-zero divisors. Invoke the target functions\/methods within the spec and set up verification goals accordingly. Do not include solver references or inline 'do' blocks; all specs must be let-bound."},{"role":"assistant","content":"```saw\nprint true;\nprint (eval_bool {{ True }});\n\nprint 33;\nprint (eval_int {{ 33 : [8] }});\n\nprint 10;\nprint (eval_size {| 10 |});\n\nprint \"[True, False]\";\nprint (eval_list {{ [True, False] }});\n\nprint \"[34, 35]\";\nprint (list_term [ {{ 34 : [8] }}, {{ 35 : [8] }} ]);\n\n\/\/ Note that because a list of bools is a bitvector this should\n\/\/ (and does) print a number:\nlet t = {{ True }};\nlet f = {{ False }};\nprint 42;\nprint (list_term [ t, f, t, f, t, f ]);\n```"}]}
{"filename":"saw-script\/intTests\/test_sawscript_builtins\/undefined6.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the LLVM backend that loads the module from saw-script\/intTests\/test_sawscript_builtins\/undefined6.saw. Define a let-bound specification named undefined6_spec that symbolically invokes the exact functions or methods defined in the associated source files, using llvm_fresh_var for inputs and adding minimal preconditions to ensure safety and termination. The harness should directly reference the exact symbol names and signatures from the associated source, and verify their behavior accordingly."},{"role":"assistant","content":"```saw\n\/\/ As of 20250707, we no longer execute partway into do-blocks at the\n\/\/ time they're let-bound. So these cases should not crash.\n\nlet m1 = do { undefined; return (); };\nprint \"not dead yet\";\nlet m2 = do { _ <- return 3; let x = undefined; return (); };\nprint \"still not dead\";\nlet m3 = do { let x = undefined; return (); };\nprint \"still still not dead\";\n```"}]}
{"filename":"saw-script\/intTests\/test_sawscript_builtins\/run.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test_sawscript_builtins\/run.saw, then define a let-bound specification named run_spec that uses llvm_fresh_var to create symbolic inputs as needed, calls the exact function symbol run with these inputs, and includes minimal preconditions to ensure safety and termination. The spec should be structured as let run_spec = do { ... }; and should not include inline do blocks or comments."},{"role":"assistant","content":"```saw\n\/\/ Test that run works.\n\nenable_experimental;\n\n\/\/ first give summarize_verification something to say\n\/\/ (otherwise it just prints a bunch of blank lines)\nprove_print z3 {{ True == True }};\n\n\/\/ this should not do anything\nprint \"nothing should happen:\";\nlet x = summarize_verification;\nprint \"hopefully nothing happened\";\n\n\/\/ this should print (see #2343)\nprint \"this should print:\";\nlet () = run x;\nprint \"that should have printed\";\n\n\/\/ this should also print (see #2343)\nprint \"this should also print:\";\nreturn (run x);\nprint \"that should also have printed\";\n```"}]}
{"filename":"saw-script\/intTests\/test_sawscript_builtins\/match.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test_sawscript_builtins\/match.saw, defines a let-bound specification named match_spec that symbolically inputs parameters using llvm_fresh_var for the function match defined in the associated LLVM source, applies minimal preconditions to ensure safety, and verifies the function's correctness by invoking llvm_verify with match_spec."},{"role":"assistant","content":"```saw\n\/\/ Tests for the workarounds for there being no match in SAWScript\n\n\/\/ caseSatResult\n\/\/\n\/\/ There is no way to directly generate values of type SatResult,\n\/\/ so we have to run some sat queries to get them.\n\/\/\n\/\/ There are three possible results -- sat, unsat, and unknown. I\n\/\/ don't know offhand how to get a solver to reliably and quickly\n\/\/ produce an unknown, and I suspect there isn't a good way, so we'll\n\/\/ leave that case off for now.\n\nprint \"caseSatResult:\";\n\nresultSat <- sat z3 {{ \\x -> x == True }};\nresultUnsat <- sat z3 {{ \\x -> (x == True) && (x == False) }};\n\ndo {\n   let no = print \"unsat\";\n   let yes t = print (\"sat\", t);\n   caseSatResult resultSat no yes;\n   caseSatResult resultUnsat no yes;\n};\n\n\/\/ caseProofResult\n\/\/\n\/\/ There is likewise no way to directly generate values of type\n\/\/ ProofResult, so we need to run some proofs.\n\nprint \"caseProofResult:\";\n\nresultValid <- prove z3 {{ \\(x : [8]) -> x == x }};\nresultInvalid <- prove z3 {{ \\(x : [8]) -> x < x }};\n\ndo {\n   let yes thm = print (\"Theorem\", thm);\n   let no cex = print (\"Counterexample\", cex);\n   caseProofResult resultValid yes no;\n   caseProofResult resultInvalid yes no;\n};\n```"}]}
{"filename":"saw-script\/intTests\/test_ffi_verify\/test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the foreign functions defined in the given Cryptol module. The properties should check that the arithmetic operations (add8, sub16, mul32, div64) behave as expected, including edge cases like division by zero. Additionally, specify properties for the bitwise and sequence manipulation functions (not, sum10, reverse5, zipMul3, reshape) to ensure they conform to their intended semantics. Include properties that validate the handling of polymorphic sizes and type synonyms, and verify that compoundTypes correctly manipulates tuples and records as specified."},{"role":"assistant","content":"```cryptol\n\/\/ Basic integral types\n\nforeign add8 : [8] -> [8] -> [8]\nadd8 = (+)\n\nforeign sub16 : [16] -> [16] -> [16]\nsub16 = (-)\n\nforeign mul32 : [32] -> [32] -> [32]\nmul32 = (*)\n\nforeign div64 : [64] -> [64] -> [64]\ndiv64 x y = if y == 0 then 0 else x \/ y\n\n\/\/ Non-machine integer sizes\n\nforeign extendInput : [3] -> [8]\nextendInput = zext\n\nforeign maskOutput : [8] -> [3]\nmaskOutput = drop\n\nforeign noBits : [0] -> [0]\nnoBits x = x\n\n\/\/ Bit\n\nforeign not : Bit -> Bit\nnot x = ~ x\n\n\/\/ Type synonyms\n\ntype Word32 = [32]\ntype Word64 = [64]\ntype MyFunc = Word32 -> [64] -> Bit\n\nforeign usesTypeSynonym : MyFunc\nusesTypeSynonym x y = zext x == y\n\n\/\/ Sequences\n\nforeign sum10 : [10]Word32 -> Word32\nsum10 = sum\n\nforeign reverse5 : [5]Word64 -> [5]Word64\nreverse5 = reverse\n\n\/\/ Tuples and records\n\nforeign compoundTypes : ([32], { x : [10], y : [3][20] }) -> { z : [5][20] }\n  -> { a : ([16], [16]), b : { c : [8][20], d : [5], e : [5] } }\ncompoundTypes (n, { x = x, y = y }) { z = z } =\n  { a = splitAt `{16} n\n  , b = { c = y # z, d = take `{5} x, e = drop `{5} x }\n  }\n\n\/\/ Polymorphic sizes\n\nforeign typeToValue : {n} (fin n, width n <= 64) => () -> [64]\ntypeToValue () = `n\n\nforeign sumPoly : {n} (fin n) => [n]Word32 -> Word32\nsumPoly = sum\n\nforeign inits : {n} (fin n) => [n][8] -> [n * (n + 1) \/ 2][8]\n\/\/ Cryptol implementation copied from constraint guards inits test case\ninits xs\n  | n == 0 => []\n  | n >  0 => initsLoop xs' x []\n    where\n      (x : [1]_) # xs' = xs\n\ninitsLoop : {n, l, m, a} (fin l, fin m, l + m == n, m >= 1) =>\n        [l]a -> [m]a ->\n        [((m - 1) * ((m - 1) + 1)) \/ 2]a ->\n        [(n * (n + 1)) \/ 2]a\ninitsLoop ys zs acc\n  | l == 0 => acc # zs\n  | l >  0 => initsLoop ys' (zs # y) (acc # zs)\n   where (y : [1]_) # ys' = ys\n\nforeign zipMul3 : {n, m, p} (fin n, fin m, fin p) =>\n  [n][27] -> [m][27] -> [p][27] -> [min n (min m p)][27]\nzipMul3 xs ys zs = [x * y * z | x <- xs | y <- ys | z <- zs]\n\n\/\/ Nested sequences\n\nforeign reshape : {a, b, c, d} (fin a, fin b, fin c, fin d) =>\n  [a][b][c][d][32] -> { dcba : [d][c][b][a][32], acbd : [a][c][b][d][32] }\nreshape x =\n  { dcba = split (split (split (join (join (join x)))))\n  , acbd = split (split (split (join (join (join x)))))\n  }\n\n\/\/ Test overrides\n\nforeign same : ([32], [10], [8][20]) -> ([32], [10], [8][20])\nsame x = x\n\nforeign notnot : Bit -> Bit\nnotnot x = not (not x)\n```"}]}
{"filename":"saw-script\/intTests\/test_ffi_verify\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from test.bc that verifies the correctness of the C functions add8(uint8_t,uint8_t), sub16(uint16_t,uint16_t), mul32(uint32_t,uint32_t), div64(uint64_t,uint64_t), sum10(uint32_t*), reverse5(uint64_t*,uint64_t*), and compoundTypes(uint32_t,uint16_t,uint32_t*,uint32_t*,uint16_t*,uint16_t*,uint32_t*,uint8_t*,uint8_t*). Define let-bound specs for each function using llvm_fresh_var for symbolic inputs, include necessary preconditions such as nonzero divisor for div64 and valid array bounds for pointer arguments, and use llvm_ffi_setup to reference the exact function symbols. Do not inline specs or reference solvers explicitly.\n\n# Source code:\ntest.c\n```C\n#include <assert.h>\n#include <stdint.h>\n#include <stddef.h>\n\nuint8_t add8(uint8_t x, uint8_t y) {\n  return x + y;\n}\n\nuint16_t sub16(uint16_t x, uint16_t y) {\n  return x - y;\n}\n\nuint32_t mul32(uint32_t x, uint32_t y) {\n  return x * y;\n}\n\nuint64_t div64(uint64_t x, uint64_t y) {\n  if (y == 0) {\n    return 0;\n  }\n  return x \/ y;\n}\n\nuint8_t extendInput(uint8_t x) {\n  return x;\n}\n\nuint8_t maskOutput(uint8_t x) {\n  return x;\n}\n\nuint8_t noBits(uint8_t zero) {\n  assert(zero == 0);\n  return 1;\n}\n\nuint8_t not(uint8_t x) {\n  return !x;\n}\n\nuint8_t usesTypeSynonym(uint32_t x, uint64_t y) {\n  return x == y;\n}\n\nuint32_t sum10(uint32_t *xs) {\n  uint32_t sum = 0;\n  for (unsigned i = 0; i < 10; ++i) {\n    sum += xs[i];\n  }\n  return sum;\n}\n\nvoid reverse5(uint64_t *in, uint64_t *out) {\n  for (unsigned i = 0; i < 5; ++i) {\n    out[i] = in[4 - i];\n  }\n}\n\nvoid compoundTypes(uint32_t n, uint16_t x, uint32_t *y, uint32_t *z,\n    uint16_t *a_0, uint16_t *a_1, uint32_t *c, uint8_t *d, uint8_t *e) {\n  *a_0 = n >> 16;\n  *a_1 = n;\n  for (unsigned i = 0; i < 3; ++i) {\n    c[i] = y[i];\n  }\n  for (unsigned i = 0; i < 5; ++i) {\n    c[i + 3] = z[i];\n  }\n  *d = x >> 5;\n  *e = x;\n}\n\nuint64_t typeToValue(size_t n) {\n  return n;\n}\n\nuint32_t sumPoly(size_t n, uint32_t *xs) {\n  uint32_t sum = 0;\n  for (size_t i = 0; i < n; ++i) {\n    sum += xs[i];\n  }\n  return sum;\n}\n\nvoid inits(size_t n, uint8_t *in, uint8_t *out) {\n  for (unsigned i = 1; i <= n; ++i) {\n    for (unsigned j = 0; j < i; ++j) {\n      *out++ = in[j];\n    }\n  }\n}\n\nvoid zipMul3(size_t n, size_t m, size_t p,\n    uint32_t *xs, uint32_t *ys, uint32_t *zs, uint32_t *out) {\n  for (size_t i = 0; i < n && i < m && i < p; ++i) {\n    out[i] = xs[i] * ys[i] * zs[i];\n  }\n}\n\nvoid reshape(size_t a, size_t b, size_t c, size_t d,\n    uint32_t *abcd, uint32_t *dcba, uint32_t *acbd) {\n  for (size_t i = 0; i < a * b * c * d; ++i) {\n    dcba[i] = acbd[i] = abcd[i];\n  }\n}\n\nvoid same(uint32_t n, uint16_t x, uint32_t *yz,\\\n    uint32_t *n1, uint16_t *x1, uint32_t *yz1) {\n  uint16_t a_0, a_1;\n  uint8_t d, e;\n  compoundTypes(n, x, yz, yz + 3, &a_0, &a_1, yz1, &d, &e);\n  *n1 = a_0 << 16 | a_1;\n  *x1 = d << 5 | (e & 0x1f);\n}\n\nuint8_t notnot(uint8_t x) {\n    return x;\n}\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nimport \"test.cry\";\nmod <- llvm_load_module \"test.bc\";\n\nllvm_verify mod \"add8\" [] true (llvm_ffi_setup {{ add8 }}) z3;\nllvm_verify mod \"sub16\" [] true (llvm_ffi_setup {{ sub16 }}) z3;\nllvm_verify mod \"mul32\" [] true (llvm_ffi_setup {{ mul32 }}) z3;\nllvm_verify mod \"div64\" [] true (llvm_ffi_setup {{ div64 }}) z3;\n\nllvm_verify mod \"extendInput\" [] true (llvm_ffi_setup {{ extendInput }}) z3;\nllvm_verify mod \"maskOutput\" [] true (llvm_ffi_setup {{ maskOutput }}) z3;\nllvm_verify mod \"noBits\" [] true (llvm_ffi_setup {{ noBits }}) z3;\n\nnot_ov <- llvm_verify mod \"not\" [] true (llvm_ffi_setup {{ not }}) z3;\n\nllvm_verify mod \"usesTypeSynonym\" [] true (llvm_ffi_setup {{ usesTypeSynonym }}) z3;\n\nllvm_verify mod \"sum10\" [] true (llvm_ffi_setup {{ sum10 }}) z3;\nllvm_verify mod \"reverse5\" [] true (llvm_ffi_setup {{ reverse5 }}) z3;\n\ncompoundTypes_ov <- llvm_verify mod \"compoundTypes\" [] true (llvm_ffi_setup {{ compoundTypes }}) z3;\n\nfor [0, 12345, 4294967297] (\\n ->\n  llvm_verify mod \"typeToValue\" [] true (llvm_ffi_setup {{ typeToValue`{n} }}) z3);\nfor [0, 1, 5, 42, 100] (\\n ->\n  llvm_verify mod \"sumPoly\" [] true (llvm_ffi_setup {{ sumPoly`{n} }}) z3);\nfor [1, 3, 72] (\\n ->\n  llvm_verify mod \"inits\" [] true (llvm_ffi_setup {{ inits`{n} }}) z3);\nlet dims = [1, 2, 3];\nfor dims (\\n ->\n  for dims (\\m ->\n    for dims (\\p ->\n      llvm_verify mod \"zipMul3\" [] true (llvm_ffi_setup {{ zipMul3`{n, m, p} }}) z3)));\n\nfor dims (\\a ->\n  for dims (\\b ->\n    for dims (\\c ->\n      for dims (\\d ->\n        llvm_verify mod \"reshape\" [] true (llvm_ffi_setup {{ reshape`{a, b, c, d} }}) z3))));\n\nlet same_setup = llvm_ffi_setup {{ same }};\nllvm_verify mod \"same\" [] true same_setup z3;\nllvm_verify mod \"same\" [compoundTypes_ov] true same_setup z3;\nlet notnot_setup = llvm_ffi_setup {{ notnot }};\nllvm_verify mod \"notnot\" [] true notnot_setup z3;\nllvm_verify mod \"notnot\" [not_ov] true notnot_setup z3;\n```"}]}
{"filename":"saw-script\/intTests\/test1973\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from 'test.linked-mir.json'. Define a let-bound specification named 'f_spec' that allocates an instance of the struct type 'test::S', creates a fresh symbolic value of this type, sets up a points-to predicate for the allocated reference, executes the function 'test::f' with the allocated reference as argument, and returns the reference. Use 'llvm_fresh_var' or equivalent for symbolic inputs and include minimal preconditions for safety. Then verify 'test::f' against 'f_spec' using 'mir_verify'."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet s_adt = mir_find_adt m \"test::S\" [];\n\nlet f_spec = do {\n  s_ref <- mir_alloc (mir_adt s_adt);\n  s <- mir_fresh_expanded_value \"s\" (mir_adt s_adt);\n  mir_points_to s_ref s;\n\n  mir_execute_func [s_ref];\n\n  mir_return s_ref;\n};\n\nmir_verify m \"test::f\" [] false f_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_crucible_jvm\/ffs_crucible.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class FFS and defines a let-bound specification named ffs_equiv_spec. In this spec, create a symbolic 32-bit integer input using jvm_fresh_var, add any necessary preconditions for safe execution, and then assert the equivalence of the methods FFS.ffs_ref and FFS.ffs_imp when applied to this input. Use jvm_extract to obtain the terms for these methods and prove their equivalence within the spec.\n\n# Source code:\nFFS.java\n```java\nclass FFS {\n    static int ffs_ref(int word) {\n        int i = 0;\n        if(word == 0)\n            return 0;\n        for(int cnt = 0; cnt < 32; cnt++)\n            if(((1 << i++) & word) != 0)\n                return i;\n        return 0;\n    }\n\n    static int ffs_imp(int i) {\n        byte n = 1;\n        if ((i & 0xffff) == 0) { n += 16; i >>= 16; }\n        if ((i & 0x00ff) == 0) { n +=  8; i >>=  8; }\n        if ((i & 0x000f) == 0) { n +=  4; i >>=  4; }\n        if ((i & 0x0003) == 0) { n +=  2; i >>=  2; }\n        if (i != 0) { return (n+((i+1) & 0x01)); } else { return 0; }\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nprint \"Extracting reference term\";\nj <- java_load_class \"FFS\";\nffs_ref <- jvm_extract j \"ffs_ref\";\n\nprint \"Extracting implementation term\";\nffs_imp <- jvm_extract j \"ffs_imp\";\n\nprint \"Proving equivalence\";\nlet thm1 = {{ \\x -> ffs_ref x == ffs_imp x }};\nprove_print abc thm1;\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/intTests\/test_crucible_jvm\/statdyn_crucible.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the JVM backend that loads the classes Dyn and Stat. Define let-bound specs for the static methods Dyn.f_ref(int), Dyn.f_imp(int), Dyn.f_virt(int), Dyn.h_ref(int), Dyn.h_imp(int), and Stat.g_imp(int). Use jvm_fresh_var to create symbolic integer inputs for these methods. Add minimal preconditions to ensure safe execution. For each spec, call the corresponding method symbolically and specify properties to prove equivalences such as Dyn.f_ref(x) == Dyn.f_imp(x), Dyn.f_ref(x) == Dyn.f_virt(x), Dyn.h_ref(x) == Stat.g_imp(x). Do not inline the specs; bind them with let. Do not include solver references or comments.\n\n# Source code:\nDyn.java\n```java\nclass Dyn implements Iface {\n    int x;\n    Dyn d;\n\n    public int g (int y) {\n\treturn this.x + y;\n    }\n\n    public int binary (int y, boolean b) {\n\tif (b) { return y + x; }\n\telse { return x;      }\n    }\n\n    static int b (int y) {\n\tDyn d = new Dyn();\n\treturn d.binary(y, true);\n    }\n    \n    \/\/ instance variable access\n    static int f_imp (int y) {\n\tDyn d = new Dyn();\n\treturn d.x + y;\n    }\n\n    static int f_virt (int y) {\n\tDyn d = new Dyn();\n\treturn d.g(y);\n    }\n\n    \n    static int f_ref (int y) { return y + 2; }\n\n\n    Dyn() {\n\tthis.x = 2;\n\tthis.d = null;\n    }\n\n    \n    Dyn(int y, Dyn b0) {\n\tthis.x = y;\n\tthis.d = new Dyn();\n    }\n\n    static int h_imp (int y) {\n\tDyn d1 = new Dyn ();\n\td1.d = new Dyn(y,null);\n\treturn d1.d.g(4);\n    }\n\n    static int h_ref (int y) {\n\treturn y+4;\n    }\n\n\n    static int i_imp (int y) {\n\tIface d = new Dyn ();\n\n\treturn d.g(y);\n\n    }\n   \n    \n}\n\n```\nStat.java\n```java\nclass Stat {\n    static int y = 1+3;\n\n    static int g_imp (int x) { return x+y; }\n    \n    static int f_imp (int x) { return y + 1; }\n\n    static int f_ref (int x) { return 5; }\n\n    \/\/public Stat () {} \n}\n\t\n\n```"},{"role":"assistant","content":"```saw\njdyn <- java_load_class \"Dyn\";\njstat <- java_load_class \"Stat\";\n\nprint \"**Extracting f_ref\";\nf_ref <- jvm_extract jdyn \"f_ref\";\n\nprint \"**Extracting f_imp\";\nf_imp <- jvm_extract jdyn \"f_imp\";\n\nprint \"**Extracting f_virt\";\nf_virt <- jvm_extract jdyn \"f_virt\";\n\nprint \"**Extracting h_ref\";\nh_ref <- jvm_extract jdyn \"h_ref\";\n\nprint \"**Extracting h_imp\";\nh_imp <- jvm_extract jdyn \"h_imp\";\n\nprint \"**Extracting g_imp\";\ng_imp <- jvm_extract jstat \"g_imp\";\n\n\n\nprint \"**Proving equivalence: instance variable\";\nprove_print abc {{ \\x -> f_ref x == f_imp x }};\n\nprint \"**Proving equivalence: dynamic method\";\nprove_print abc {{ \\x -> f_ref x == f_virt x }};\n\n\/* print \"**Proving equivalence: dynamic method\";\nprove_print abc {{ \\x -> h_ref x == h_imp x }}; *\/\n\nprint \"**Proving equivalence: methods two different classes\";\nprove_print abc {{ \\x -> h_ref x == g_imp x }};\n\n\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/intTests\/test_crucible_jvm\/sub_crucible.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the JVM backend that loads the classes Dyn, Iface, and Sub from the provided Java sources. Define let-bound specs for the static methods Sub.dyn(int), Sub.sub(int), Dyn.f_virt(int), and Dyn.i_imp(int). Use jvm_fresh_var to create symbolic 32-bit integer inputs for these methods. For each spec, call the corresponding static method with the symbolic input and specify the expected output as a symbolic variable. Include minimal preconditions if needed to ensure method termination and safety. Do not inline the specs; bind them to let names before use.\n\n# Source code:\nDyn.java\n```java\nclass Dyn implements Iface {\n    int x;\n    Dyn d;\n\n    public int g (int y) {\n\treturn this.x + y;\n    }\n\n    public int binary (int y, boolean b) {\n\tif (b) { return y + x; }\n\telse { return x;      }\n    }\n\n    static int b (int y) {\n\tDyn d = new Dyn();\n\treturn d.binary(y, true);\n    }\n    \n    \/\/ instance variable access\n    static int f_imp (int y) {\n\tDyn d = new Dyn();\n\treturn d.x + y;\n    }\n\n    static int f_virt (int y) {\n\tDyn d = new Dyn();\n\treturn d.g(y);\n    }\n\n    \n    static int f_ref (int y) { return y + 2; }\n\n\n    Dyn() {\n\tthis.x = 2;\n\tthis.d = null;\n    }\n\n    \n    Dyn(int y, Dyn b0) {\n\tthis.x = y;\n\tthis.d = new Dyn();\n    }\n\n    static int h_imp (int y) {\n\tDyn d1 = new Dyn ();\n\td1.d = new Dyn(y,null);\n\treturn d1.d.g(4);\n    }\n\n    static int h_ref (int y) {\n\treturn y+4;\n    }\n\n\n    static int i_imp (int y) {\n\tIface d = new Dyn ();\n\n\treturn d.g(y);\n\n    }\n   \n    \n}\n\n```\nIface.java\n```java\ninterface Iface {\n    public int g (int x);\n}\n\n```\nSub.java\n```java\nclass Sub extends Dyn {\n\n    public int g (int x) {\n\treturn x + 17;\n    }\n\n    public static int dyn(int x) {\n        Dyn s = new Sub();\n        return s.g(x);\n    }\n\n    public static int sub(int x) {\n\tSub s = new Sub();\n\treturn s.g(x);\n    }\n\n}\n\n```"},{"role":"assistant","content":"```saw\nobj <- java_load_class \"java.lang.Object\";\ndyn <- java_load_class \"Dyn\";\nifc <- java_load_class \"Iface\";\nsub <- java_load_class \"Sub\";\n\nprint \"**Extracting Dyn.f_virt\";\nf_virt <- jvm_extract dyn \"f_virt\";\nprint \"**Extracting Dyn.i_imp\";\ni_imp <- jvm_extract dyn \"i_imp\";\nprint \"**Extracting Sub.dyn\";\ndyn_g <- jvm_extract sub \"dyn\";\nprint \"**Extracting Sub.sub\";\nsub_g <- jvm_extract sub \"sub\";\n\nprint \"**Evaluating: dyn (12) \";\nsat_print abc {{ \\(x:[32]) -> dyn_g 12 == x }};\n\nprint \"**Evaluating: sub (12) \";\nsat_print abc {{ \\(x:[32]) -> sub_g 12 == x }};\n\nprint \"**Evaluating: f_virt (12) \";\nsat_print abc {{ \\(x:[32]) -> f_virt 12 == x }};\n\nprint \"**Evaluating: i_imp (12) \";\nsat_print abc {{ \\(x:[32]) -> i_imp 12 == x }};\n```"}]}
{"filename":"saw-script\/intTests\/test_crucible_jvm\/arr_crucible.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the JVM backend that loads classes Dyn and Arr. Define let-bound specs named single_spec, doub_spec, and obj_spec that symbolically verify the methods Arr.single(int), Arr.doub(int), and Arr.obj(int) respectively. Use jvm_fresh_var to create symbolic integer inputs for the array indices, adding minimal preconditions to ensure indices are within array bounds. Each spec should call the corresponding extracted method (single, doub, obj) with the symbolic input and specify expected behaviors consistent with the Java source. Do not inline the specs; bind them with let before use.\n\n# Source code:\nDyn.java\n```java\nclass Dyn implements Iface {\n    int x;\n    Dyn d;\n\n    public int g (int y) {\n\treturn this.x + y;\n    }\n\n    public int binary (int y, boolean b) {\n\tif (b) { return y + x; }\n\telse { return x;      }\n    }\n\n    static int b (int y) {\n\tDyn d = new Dyn();\n\treturn d.binary(y, true);\n    }\n    \n    \/\/ instance variable access\n    static int f_imp (int y) {\n\tDyn d = new Dyn();\n\treturn d.x + y;\n    }\n\n    static int f_virt (int y) {\n\tDyn d = new Dyn();\n\treturn d.g(y);\n    }\n\n    \n    static int f_ref (int y) { return y + 2; }\n\n\n    Dyn() {\n\tthis.x = 2;\n\tthis.d = null;\n    }\n\n    \n    Dyn(int y, Dyn b0) {\n\tthis.x = y;\n\tthis.d = new Dyn();\n    }\n\n    static int h_imp (int y) {\n\tDyn d1 = new Dyn ();\n\td1.d = new Dyn(y,null);\n\treturn d1.d.g(4);\n    }\n\n    static int h_ref (int y) {\n\treturn y+4;\n    }\n\n\n    static int i_imp (int y) {\n\tIface d = new Dyn ();\n\n\treturn d.g(y);\n\n    }\n   \n    \n}\n\n```\nArr.java\n```java\nclass Arr {\n\n    public static int[] one = { 1, 2, 3 };\n    public static int[] onea = { 0, 0, 0 };\n    \n    public static int[][] two = { { 1, 2 } };\n\t\n    public static Dyn[] dyns = { new Dyn() };\n\n    static int main(int x) {\n\treturn single(x) + doub(x) + obj(x) + cp (x);\n    }\n\n    static int single(int x) {\n\treturn one[x];\n    }\n\n    static int doub(int x) {\n\treturn two[x][x];\n    }\n\n    static int obj(int y) {\n\treturn dyns[y].x;\n    }\n\n    static int cp (int y) {\n\tSystem.arraycopy (one, 0, onea, 0, 3 );\n\treturn onea[y];\n    }\n\n\t \n}\n\n```"},{"role":"assistant","content":"```saw\nj <- java_load_class \"Dyn\";\na <- java_load_class \"Arr\";\n\nprint \"**Extracting f_ref\";\nf_ref <- jvm_extract j \"f_ref\";\n\nprint \"**Extracting single\";\nsingle <- jvm_extract a \"single\";\n\nprint \"**Extracting doub\";\ndoub <- jvm_extract a \"doub\";\n\nprint \"**Extracting obj\";\nh_ref <- jvm_extract j \"h_ref\";\n\nprint \"**Evaluating: single array ref\";\nsat_print abc {{ \\(x:[32]) -> single 0 == x }};\n\nprint \"**Evaluating: double array ref\";\nsat_print abc {{ \\(x:[32]) -> doub 0 == x }};\n\nprint \"**Evaluating: obj array ref\";\nsat_print abc {{ \\(x:[32]) -> h_ref 0 == x }};\n\n\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/intTests\/test_crucible_jvm\/stat_crucible.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class Stat and defines a let-bound specification named f_imp_spec. In this spec, create a fresh symbolic integer variable x using jvm_fresh_var, then call the method Stat.f_imp with x as argument. Add any minimal preconditions needed for safe execution. The spec should return the result of calling Stat.f_imp on x. Then prove equivalence between Stat.f_imp and Stat.f_ref by extracting both methods and comparing their outputs for all symbolic inputs x.\n\n# Source code:\nStat.java\n```java\nclass Stat {\n    static int y = 1+3;\n\n    static int g_imp (int x) { return x+y; }\n    \n    static int f_imp (int x) { return y + 1; }\n\n    static int f_ref (int x) { return 5; }\n\n    \/\/public Stat () {} \n}\n\t\n\n```"},{"role":"assistant","content":"```saw\nprint \"**Extracting reference term\";\nj <- java_load_class \"Stat\";\nf_ref <- jvm_extract j \"f_ref\";\n\nprint \"**Extracting implementation term\";\nf_imp <- jvm_extract j \"f_imp\";\n\nprint \"**Proving equivalence\";\nlet thm1 = {{ \\x -> f_ref x == f_imp x }};\nprove_print abc thm1;\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/intTests\/test_crucible_jvm\/dyn_crucible.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the JVM backend that loads the Dyn class and defines let-bound specs for the static methods Dyn.f_ref(int), Dyn.f_imp(int), Dyn.f_virt(int), Dyn.h_ref(int), Dyn.h_imp(int), Dyn.i_imp(int), and Dyn.b(int). Use jvm_fresh_var to create symbolic integer inputs for these methods. Include minimal preconditions to ensure safe execution. For each spec, invoke the corresponding method symbolically and specify properties to verify equivalences such as Dyn.f_ref(x) == Dyn.f_imp(x), Dyn.f_ref(x) == Dyn.f_virt(x), Dyn.h_ref(x) == Dyn.h_imp(x), and evaluate Dyn.i_imp(x) and Dyn.b(x) accordingly. Bind each spec with let <name>_spec = do { ... }; and reference exact method signatures from Dyn.java.\n\n# Source code:\nIface.java\n```java\ninterface Iface {\n    public int g (int x);\n}\n\n```\nDyn.java\n```java\nclass Dyn implements Iface {\n    int x;\n    Dyn d;\n\n    public int g (int y) {\n\treturn this.x + y;\n    }\n\n    public int binary (int y, boolean b) {\n\tif (b) { return y + x; }\n\telse { return x;      }\n    }\n\n    static int b (int y) {\n\tDyn d = new Dyn();\n\treturn d.binary(y, true);\n    }\n    \n    \/\/ instance variable access\n    static int f_imp (int y) {\n\tDyn d = new Dyn();\n\treturn d.x + y;\n    }\n\n    static int f_virt (int y) {\n\tDyn d = new Dyn();\n\treturn d.g(y);\n    }\n\n    \n    static int f_ref (int y) { return y + 2; }\n\n\n    Dyn() {\n\tthis.x = 2;\n\tthis.d = null;\n    }\n\n    \n    Dyn(int y, Dyn b0) {\n\tthis.x = y;\n\tthis.d = new Dyn();\n    }\n\n    static int h_imp (int y) {\n\tDyn d1 = new Dyn ();\n\td1.d = new Dyn(y,null);\n\treturn d1.d.g(4);\n    }\n\n    static int h_ref (int y) {\n\treturn y+4;\n    }\n\n\n    static int i_imp (int y) {\n\tIface d = new Dyn ();\n\n\treturn d.g(y);\n\n    }\n   \n    \n}\n\n```"},{"role":"assistant","content":"```saw\nobj   <- java_load_class \"java.lang.Object\";\niface <- java_load_class \"Iface\";\n\nj <- java_load_class \"Dyn\";\n\nprint \"**Extracting f_ref\";\nf_ref <- jvm_extract j \"f_ref\";\n\nprint \"**Extracting f_imp\";\nf_imp <- jvm_extract j \"f_imp\";\n\nprint \"**Extracting f_virt\";\nf_virt <- jvm_extract j \"f_virt\";\n\nprint \"**Extracting h_ref\";\nh_ref <- jvm_extract j \"h_ref\";\n\nprint \"**Extracting h_imp\";\nh_imp <- jvm_extract j \"h_imp\";\n\nprint \"**Extracting i_imp\";\ni_imp <- jvm_extract j \"i_imp\";\n\nprint \"**Extracting b\";\nb <- jvm_extract j \"b\";\n\n\nprint \"**Evaluating: instance variable\";\nsat_print abc {{ \\(x:[32]) -> f_imp 3 == x }};\n\n\nprint \"**Proving equivalence: instance variable\";\nprove_print abc {{ \\x -> f_ref x == f_imp x }};\n\nprint \"**Evaluating: dynamic method (f_virt 3)\";\nsat_print abc {{ \\(x:[32]) -> f_virt 3 == x }};\n\nprint \"**Proving equivalence: dynamic method \";\nprove_print abc {{ \\x -> f_ref x == f_virt x }};\n\nprint \"**Evaluating: alternative constructor (h_imp 3)\";\nsat_print abc {{ \\(x:[32]) -> h_imp 3 == x }};\n\nprint \"**Proving equivalence: dynamic method\";\nprove_print abc {{ \\x -> h_ref x == h_imp x }};\n\nprint \"**Evaluating: invoke interface (i_imp 3)\";\nsat_print abc {{ \\(x:[32]) -> i_imp 3 == x }};\n\nprint \"**Evaluating: two-argument dynamic method (b 3)\";\nsat_print abc {{ \\(x:[32]) -> b 3 == x }};\n\n\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/intTests\/test_sawcore_prelude\/testDrop.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module corresponding to the C source files associated with testDrop.saw. Define a let-bound specification named drop_spec that uses llvm_fresh_var to create symbolic inputs matching the signature of the drop function defined in the source. Include minimal preconditions to ensure safety, such as valid pointer bounds or non-negative lengths if applicable. Use llvm_verify to prove that the implementation of drop meets the specification. Reference exact function names and signatures from the associated C source files, and do not inline the spec directly in the verification call."},{"role":"assistant","content":"```saw\nprint \"starting\";\n\nenable_experimental;\n\nload_sawcore_from_file \"testDrop.sawcore\";\nlet mod = \"testDrop\"; \/\/ SAWCore module name\n\nlet printNorm e =\n  print (show_term (normalize_term (parse_core_mod mod e)));\n\nlet runTest e c = do {\n  print e;\n  printNorm e;\n  prove_print abc (parse_core_mod mod c);\n  print \"Success\";\n  print \"\";\n};\n\nrunTest \"test1a\" \"check1a\";\nrunTest \"test1b\" \"check1b\";\nrunTest \"test1c\" \"check1c\";\nrunTest \"test1d\" \"check1d\";\nrunTest \"test1e\" \"check1e\";\n\nprint \"done\";\n```"}]}
{"filename":"saw-script\/intTests\/test0069_unfinished\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'saw-script\/intTests\/test0069_unfinished\/test.saw', defines a let-bound specification named 'test_spec' using llvm_fresh_var to create symbolic inputs matching the function signatures in the associated source files, applies minimal preconditions for safety such as non-zero divisors or valid array indices, and then uses llvm_verify to prove correctness of the target function(s) by referencing their exact LLVM symbol names."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet andI = core_axiom \"(a b : Bool) -> EqTrue a -> EqTrue b -> EqTrue (and a b)\";\nlet script = do { simplify (cryptol_ss()); goal_apply andI; trivial; };\n\nb <- fresh_symbolic \"b\" {| Bit |};\n\nprint \"The following proof should fail because the proof is incomplete.\";\nfails (prove_print script {{ True && b }});\n\nprint \"Now we check that the 'prove' command also does the correct thing.\";\nr <- prove script {{ True && b }};\ncaseProofResult r (\\_ -> fails (print \"We should not get a theorem!\"))\n                  (\\x -> do { prove_print z3 {{ x == () }}; return ();} );\n```"}]}
{"filename":"saw-script\/intTests\/test0058\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated LLVM module using llvm_load_module, then defines a let-bound specification named test_spec that uses llvm_fresh_var to create symbolic inputs matching the exact function signature(s) from the associated source files. The spec should call the target LLVM function(s) with these symbolic inputs, include minimal preconditions necessary for safety (such as non-zero divisors or valid array indices), and verify expected properties or postconditions of the function(s). Do not inline the spec; bind it with let. Use only SAWScript commands relevant to LLVM verification and reference the exact function names and types from the source."},{"role":"assistant","content":"```saw\n\/\/ `Bit`s\nlet tru = {{ True }};\nlet fls = {{ False }};\n\nprint (eval_bool tru); print (eval_bool fls); \/\/ Bit vectors\n\/\/ Note: To prevent inference of the infinite numeric type `Integer`, type\n\/\/ annotations are necessary on decimal literals\nlet zero  = {{ 0 : [0] }};\nlet zero' = {{ 0 : [1] }};\nlet x     = {{ 17 : [5] }};\nlet neg_x = {{ -x }};\n\nprint (eval_int zero);  print (eval_int zero'); print (eval_int x);     print (eval_int neg_x); \/\/ [..] 15 (which has the same base-2 representation as\n                        \/\/          the two's complement negation of 17)\n\n\/\/ Sequences more generally\n\n\/\/ empty sequence\nlet l0 = {{ [] : [0]Bit }};\nprint (eval_list l0);\n\n\/\/ nonempty sequences\nlet l1   = {{ [0x01, 0x02, 0x03 ]}};\nlet l1'  = eval_list l1;\nprint l1'; \/\/ [..] ... List of Cryptol terms representing 1, 2, and 3 ...\n\nlet l2   = {{ [\"the\", \"and\", \"for\", \"not\"] }};\nlet l2'  = eval_list l2;\nprint l2'; \/\/ [..] ... List of Cryptol terms representing \"the\", \"and\", \"for\", \"not\" ...\n\n\/\/ eval_list and list_term should be inverses\nlet l1'' = list_term l1';\nlet thm1 = {{ l1 == l1'' }};\nprove_print z3 thm1;\n\nlet l2'' = list_term l2';\nlet thm2 = {{ l2 == l2'' }};\nprove_print z3 thm2;\n```"}]}
{"filename":"saw-script\/intTests\/test0060\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from '.\/test.bc' and defines let-bound specs for the functions id_p, incr_p, add_two, array_swap, and struct_swap as declared in test.c. Use llvm_fresh_var and llvm_fresh_pointer to create symbolic inputs of appropriate LLVM types (e.g., llvm_int 32, llvm_pointer to llvm_int 32, llvm_array 2 (llvm_int 32), llvm_alias \"struct.foo\"). For add_two, ensure the pointer is treated as llvm_int 64 pointer before dereferencing. For struct_swap, allocate a packed struct foo with fields x and y as llvm_int 32. Include minimal preconditions to ensure safety and termination. Use llvm_execute_func to call each function with symbolic inputs and verify expected postconditions by checking memory contents with llvm_points_to or llvm_points_to_untyped. Do not inline specs; bind each spec to a let variable before verification. Use llvm_verify with the loaded module and the corresponding function names.\n\n# Source code:\ntest.c\n```C\n#include <inttypes.h>\n\nuint32_t *id_p(uint32_t *p) {\n    return p;\n}\n\nuint32_t *incr_p(uint32_t *p) {\n    return p + 1;\n}\n\nvoid add_two(uint32_t *p) {\n    p = (uint64_t *)p;\n    *p = *p + 2;\n}\n\nvoid array_swap(uint32_t a[2]) {\n    uint32_t tmp = a[0];\n    a[0] = a[1];\n    a[1] = tmp;\n}\n\n\/* packed attribute to get LLVM to not pad the struct *\/\ntypedef struct __attribute__((packed)) {\n    uint32_t x;\n    uint32_t y;\n} foo;\n\nvoid struct_swap(foo *f) {\n    uint32_t tmp = f->x;\n    f->x = f->y;\n    f->y = tmp;\n}\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \".\/test.bc\";\n\nlet id_spec = do {\n    p <- llvm_fresh_pointer (llvm_int 32);\n    llvm_execute_func [p];\n    llvm_return p;\n};\n\nllvm_verify m \"id_p\" [] false id_spec z3;\n\nlet add_two_spec = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    xp <- llvm_alloc (llvm_int 64);\n    llvm_points_to_untyped xp (llvm_term x);\n\n    llvm_execute_func [xp];\n\n    llvm_points_to_untyped xp (llvm_term {{ x + 2 }});\n};\n\nllvm_verify m \"add_two\" [] false add_two_spec z3;\n\nlet array_swap_spec = do {\n    a0 <- llvm_fresh_var \"a0\" (llvm_int 32);\n    a1 <- llvm_fresh_var \"a1\" (llvm_int 32);\n    a  <- llvm_alloc (llvm_array 2 (llvm_int 32));\n    llvm_points_to a (llvm_array_value [llvm_term a0, llvm_term a1]);\n\n    llvm_execute_func [a];\n\n    llvm_points_to (llvm_elem a 0) (llvm_term a1);\n    llvm_points_to (llvm_elem a 1) (llvm_term a0);\n};\n\nllvm_verify m \"array_swap\" [] false array_swap_spec z3;\n\nlet struct_swap_spec = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    s <- llvm_alloc (llvm_alias \"struct.foo\");\n    llvm_points_to s (llvm_packed_struct_value [llvm_term x, llvm_term y]);\n\n    llvm_execute_func [s];\n\n    llvm_points_to (llvm_field s \"x\") (llvm_term y);\n    llvm_points_to (llvm_field s \"y\") (llvm_term x);\n};\n\n\/\/ A variant of struct_swap_spec that uses llvm_struct_type instead of llvm_alias.\nlet struct_swap_spec2 = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    s <- llvm_alloc (llvm_packed_struct_type [llvm_int 32, llvm_int 32]);\n    llvm_points_to s (llvm_packed_struct_value [llvm_term x, llvm_term y]);\n\n    llvm_execute_func [s];\n\n    llvm_points_to (llvm_elem s 0) (llvm_term y);\n    llvm_points_to (llvm_elem s 1) (llvm_term x);\n};\n\nllvm_verify m \"struct_swap\" [] false struct_swap_spec z3;\nllvm_verify m \"struct_swap\" [] false struct_swap_spec2 z3;\n```"}]}
{"filename":"saw-script\/intTests\/test1945\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from test.bc and verifies the function 'test' with signature 'void test(uint8_t *)'. Define a let-bound spec named 'test_spec' that allocates an 8-bit integer pointer, creates a fresh symbolic 8-bit variable 'x', sets the pointer to point to 'x', executes the function with the pointer as argument, and uses llvm_conditional_points_to with the condition 'x == 1' to assert the pointer points to the value 1. Use symbolic inputs and minimal preconditions for safety.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n\nvoid test(uint8_t *x) {}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ Test a use of `llvm_conditional_points_to` where the value that the pointer\n\/\/ points to will fail to match against the right-hand side value unless the\n\/\/ condition is properly incorporated into the path condition. This serves as\n\/\/ a regression test for https:\/\/github.com\/GaloisInc\/saw-script\/issues\/1945.\n\nlet test_spec = do {\n  p <- llvm_alloc (llvm_int 8);\n  x <- llvm_fresh_var \"x\" (llvm_int 8);\n  llvm_points_to p (llvm_term x);\n\n  llvm_execute_func [p];\n\n  llvm_conditional_points_to {{ x == 1 }} p (llvm_term {{ 1 : [8] }});\n};\n\nm <- llvm_load_module \"test.bc\";\nllvm_verify m \"test\" [] false test_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test2398\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given path and defines let-bound specifications for the functions exactly as named in the source files. Use llvm_fresh_var to create symbolic inputs where applicable, and include minimal preconditions to ensure safety and termination. Each specification should use llvm_execute_func with appropriate arguments and llvm_return with expected symbolic or concrete values matching the function's return type. Then invoke llvm_verify on each function with its corresponding specification and any required overrides. Do not inline specifications; bind them with let. Do not include comments or solver references."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet thing = mir_find_adt m \"test::Thing\" [];\n\nlet get_thing_spec = do {\n    mir_execute_func [];\n    mir_return (mir_struct_value thing [\n        mir_tuple_value [],\n        mir_term {{ 1 : [32] }},\n        mir_term {{ [] : [0][8] }}\n    ]);\n};\n\nget_thing_ov <- mir_verify m \"test::get_thing\" [] false get_thing_spec z3;\n\nlet get_thing_b_spec = do {\n    mir_execute_func [];\n    mir_return (mir_term {{ 1 : [32] }});\n};\n\nmir_verify m \"test::get_thing_b\" [get_thing_ov] false get_thing_b_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test_unint_extcore\/test_unint.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated LLVM module using llvm_load_module, defines a let-bound specification named f_spec that uses llvm_fresh_var to create symbolic inputs matching the function signature of 'f', includes minimal preconditions ensuring termination and safety, and then calls llvm_verify to verify 'f' against f_spec."},{"role":"assistant","content":"```saw\nimport \"unint.cry\";\n\nfails (prove_print (w4_unint_yices [\"g\"]) {{ \\x -> f x > 0 }});\n\nwrite_core \"unint.core\" {{ \\x -> f x > 0 }};\n\nprop <- read_core \"unint.core\";\n\nfails (prove_print (w4_unint_yices [\"g\"]) {{ \\x -> prop x }});\n```"}]}
{"filename":"saw-script\/intTests\/test1788\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from \"test.bc\", extracts the function \"mult\" with signature (uint32_t) -> uint32_t, and defines a let-bound specification named mult_spec. The spec should use llvm_fresh_var to create a symbolic 32-bit input variable x, and assert that the LLVM \"mult\" function's output equals the Cryptol multiplication of x by 0x85EBCA77. Include any minimal preconditions needed for safety or termination. Then prove equivalence between the LLVM implementation and the Cryptol specification using ABC.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n\nuint32_t mult(uint32_t x) {\n  return x * 0x85EBCA77U;\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ This test case ensures that ABC can prove that a C implementation of the\n\/\/ `mult` function is equivalent to a direct Cryptol implementation of the\n\/\/ same function.\n\nlet\n{{\ncryptol_mult : [32] -> [32]\ncryptol_mult x = x * 0x85EBCA77\n}};\n\nm <- llvm_load_module \"test.bc\";\nllvm_mult <- llvm_extract m \"mult\";\nprove_print abc {{ \\x -> llvm_mult x == cryptol_mult x }};\n```"}]}
{"filename":"saw-script\/intTests\/test0005\/test2.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class containing the method java_md5, defines a let-bound specification named java_md5_spec which uses jvm_fresh_var to create symbolic inputs for the method's parameters, includes any necessary preconditions for safe execution, and then verifies that the implementation of java_md5 matches the specification using jvm_verify or an equivalent JVM backend command. Reference the exact method signature as defined in the associated Java source files."},{"role":"assistant","content":"```saw\nlet main = do {\n   java_md5 <- read_aig \"..\/support\/JavaMD5.aig\";\n\n   print \"AIG type\";\n   print_type java_md5;\n\n   print \"AIG type, checked\";\n   ty2 <- check_term java_md5;\n\n   let thm1 = {{ java_md5 0 == 0x52e7c86c27d29ffd9e4bae74c41218a5 }};\n   prove_print abc thm1;\n};\n```"}]}
{"filename":"saw-script\/intTests\/test0005\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class containing the method 'java_md5', defines a let-bound specification named 'java_md5_spec' which uses symbolic inputs created with 'jvm_fresh_var' to represent the method's input, applies any minimal necessary preconditions for safety or termination, and then verifies that invoking 'java_md5' with the symbolic input produces the expected output as given in the AIG term. The harness should use 'jvm_load_class' to load the Java class and 'jvm_verify' to perform the verification against the specification."},{"role":"assistant","content":"```saw\nlet main = do {\n   java_md5 <- read_aig \"..\/support\/JavaMD5.aig\";\n\n   print \"AIG type\";\n   print_type java_md5;\n\n   print \"AIG type, checked\";\n   check_term java_md5;\n\n   let thm1 = {{ java_md5 zero ==\n                 join [82, 231, 200, 108, 39, 210, 159, 253, 158, 75, 174, 116, 196, 18, 24, 165] }};\n   prove_print abc thm1;\n};\n```"}]}
{"filename":"saw-script\/intTests\/test0063_polyarith\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test0063_polyarith\/test.saw, defines a let-bound specification named thm_spec corresponding to the polymorphic theorem thm with parameters n and m, and uses llvm_fresh_var to create symbolic inputs for arrays of sizes n and m. Include necessary preconditions such as n > m and m >= 1 to ensure termination and safety. The spec should verify that for inputs x and y, if y is not zero, then pmult y (pdiv x y) xor (zero concatenated with pmod x y) equals zero concatenated with x truncated appropriately. Reference the exact symbol names pmult, pdiv, pmod, and zero as defined in the LLVM module. Do not include solver references or comments."},{"role":"assistant","content":"```saw\nlet {{\n\nthm : {n,m} (fin n, fin m, n > m, m >= 1) => [n] -> [m] -> Bit\nthm x y = y != 0 ==> \n    pmult y (pdiv x y) ^ (zero # pmod x y) == zero`{[m-1]}#x\n\n}};\n\nprint_term (rewrite (cryptol_ss ())\n  (unfold_term [\"thm\"] {{ thm`{16,4} }}));\n\nprove_print rme {{ thm`{16,8} }};\nprove_print rme {{ thm`{20,10} }};\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_fresh_expanded_value_enum\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given source files and defines let-bound specifications for the functions test::f, test::g, and test::gg. For test::f, write two separate specs: one where the input is the enum variant None of core::option::Option<u32> returning 27, and another where the input is Some with a fresh symbolic u32 variable, returning that variable. For test::g and test::gg, define specs that take a fresh expanded value of the Option<u32> ADT as input and execute the corresponding function. Use llvm_fresh_var and llvm_fresh_expanded_value for symbolic inputs, and call llvm_verify with these specs referencing the exact function names. Include minimal preconditions if necessary for safety and termination."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet option_u32_adt = mir_find_adt m \"core::option::Option\" [mir_u32];\n\nlet f_none_spec = do {\n  let x = mir_enum_value option_u32_adt \"None\" [];\n\n  mir_execute_func [x];\n\n  mir_return (mir_term {{ 27 : [32] }});\n};\n\nlet f_some_spec = do {\n  ret <- mir_fresh_var \"ret\" mir_u32;\n  let x = mir_enum_value option_u32_adt \"Some\" [mir_term ret];\n\n  mir_execute_func [x];\n\n  mir_return (mir_term ret);\n};\n\nlet g_spec = do {\n  x <- mir_fresh_expanded_value \"x\" (mir_adt option_u32_adt);\n\n  mir_execute_func [x];\n};\n\nlet gg_spec = do {\n  xx <- mir_fresh_expanded_value \"xx\" (mir_adt option_u32_adt);\n\n  mir_execute_func [xx];\n};\n\nf_none_ov <- mir_verify m \"test::f\" [] false f_none_spec z3;\nf_some_ov <- mir_verify m \"test::f\" [] false f_some_spec z3;\n\nmir_verify m \"test::g\" [] false g_spec z3;\ng_ov <- mir_verify m \"test::g\" [f_none_ov, f_some_ov] false g_spec z3;\n\nmir_verify m \"test::gg\" [] false gg_spec z3;\nmir_verify m \"test::gg\" [g_ov] false gg_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test0002\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class containing the md5_ref method and the JavaMD5.aig file. Define a let-bound specification named md5_spec that uses jvm_fresh_var to create a symbolic input array of 16 bytes, applies md5_ref and the JavaMD5 method to the input, and asserts their outputs are equal. Include any necessary preconditions for safe execution. Use jvm_load_class and jvm_fresh_var accordingly, referencing the exact Java method signatures."},{"role":"assistant","content":"```saw\nimport \"..\/..\/deps\/cryptol-specs\/Primitive\/Keyless\/Hash\/MD5.md\";\n\nlet main = do {\n   java_md5 <- read_aig \"..\/support\/JavaMD5.aig\";\n\n   print \"ref type\";\n   print_type {{ md5_ref }};\n   print \"\";\n\n   check_term {{ md5_ref }};\n   print \"\";\n\n   print \"AIG type\";\n   print_type java_md5;\n   print \"\";\n\n   print \"AIG type, checked\";\n   check_term java_md5;\n   print \"\";\n\n   let thm = {{ \\x -> join (md5_ref x) == java_md5 (join x) }};\n   write_aig \"md5_ref.aig\" {{ \\(x:[16][8]) -> join (md5_ref x) }};\n   write_aig \"java_md5.aig\" {{ \\(x:[16][8]) -> java_md5 (join x) }};\n};\n```"}]}
{"filename":"saw-script\/intTests\/test_jvm_method_names\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java class Test defined in Test.java using the JVM backend. Define let-bound specs for the methods get:()J, all constructors <init>:()V, <init>:(J)V, <init>:(I)V, and the increment methods increment:()V, increment:(J)V, increment:(I)V, increment:(LTest;)V. Use jvm_fresh_var to create symbolic inputs for method parameters and jvm_alloc_object to allocate 'this' and any object arguments. Add minimal preconditions such as initializing fields with symbolic values and ensure field updates reflect the method semantics. Use jvm_field_is and jvm_execute_func to specify and verify method behavior. Do not inline specs; bind each spec to a let name before verification calls.\n\n# Source code:\nTest.java\n```java\nclass Test\n{\n    long val;\n\n    public Test() {\n        val = 0;\n    }\n    public Test(long x) {\n        val = x;\n    }\n    public Test(int x) {\n        val = x;\n    }\n    public long get() {\n        return val;\n    }\n    public void increment() {\n        val = val + 1;\n    }\n    public void increment(long x) {\n        val = val + x;\n    }\n    public void increment(int x) {\n        val = val + (long)x;\n    }\n    public void increment(Test x) {\n        val = val + x.val;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"Test\";\nprint c;\n\njvm_verify c \"get\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"Test.val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_return (jvm_term val);\n  }\n  z3;\n\n\nprint \"********************************************************************************\";\nprint \"<init>\";\nfails (\njvm_verify c \"<init>\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    jvm_execute_func [this];\n    jvm_field_is this \"Test.val\" (jvm_term {{ 0 : [64] }});\n  }\n  z3);\n\nprint \"********************************************************************************\";\nprint \"<init>:(J)V\";\njvm_verify c \"<init>:(J)V\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this \"Test.val\" (jvm_term x);\n  }\n  z3;\n\nprint \"********************************************************************************\";\nprint \"<init>:(I)V\";\njvm_verify c \"<init>:(I)V\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    x <- jvm_fresh_var \"x\" java_int;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this \"Test.val\" (jvm_term {{ sext x : [64] }});\n  }\n  z3;\n\nprint \"********************************************************************************\";\nprint \"<init>:()V\";\njvm_verify c \"<init>:()V\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    jvm_execute_func [this];\n    jvm_field_is this \"Test.val\" (jvm_term {{ 0 : [64] }});\n  }\n  z3;\n\nprint \"********************************************************************************\";\nprint \"increment\";\nfails (\njvm_verify c \"increment\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"Test.val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_field_is this \"Test.val\" (jvm_term {{ val + 1 }});\n  }\n  z3);\n\nprint \"********************************************************************************\";\nprint \"increment:()V\";\njvm_verify c \"increment:()V\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"Test.val\" (jvm_term val);\n    jvm_execute_func [this];\n    jvm_field_is this \"Test.val\" (jvm_term {{ val + 1 }});\n  }\n  z3;\n\nprint \"********************************************************************************\";\nprint \"increment:(J)V\";\njvm_verify c \"increment:(J)V\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"Test.val\" (jvm_term val);\n    x <- jvm_fresh_var \"x\" java_long;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this \"Test.val\" (jvm_term {{ val + x }});\n  }\n  z3;\n\nprint \"********************************************************************************\";\nprint \"increment:(I)V\";\njvm_verify c \"increment:(I)V\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"Test.val\" (jvm_term val);\n    x <- jvm_fresh_var \"x\" java_int;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this \"Test.val\" (jvm_term {{ val + sext x }});\n  }\n  z3;\n\nprint \"********************************************************************************\";\nprint \"increment:(LTest;)V\";\njvm_verify c \"increment:(LTest;)V\" [] false\n  do {\n    this <- jvm_alloc_object \"Test\";\n    val <- jvm_fresh_var \"val\" java_long;\n    jvm_field_is this \"Test.val\" (jvm_term val);\n\n    x <- jvm_alloc_object \"Test\";\n    x_val <- jvm_fresh_var \"x_val\" java_long;\n    jvm_field_is x \"Test.val\" (jvm_term x_val);\n\n    jvm_execute_func [this, x];\n    jvm_field_is this \"Test.val\" (jvm_term {{ val + x_val }});\n  }\n  z3;\n```"}]}
{"filename":"saw-script\/intTests\/test0051_compositional_extract_2\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from \"test.bc\" and defines let-bound specs for the functions add and sum as declared in test.c. The add_spec should allocate pointers for r, a, and b of type struct.uint128_t, use llvm_fresh_var for symbolic inputs, and call llvm_execute_func with these pointers. The sum_spec should allocate pointers for s and an array a of length n of struct.uint128_t, use llvm_fresh_var for symbolic inputs, and call llvm_execute_func with s, a, and n as a symbolic 64-bit integer. Include minimal preconditions to ensure safe execution. Use llvm_compositional_extract to extract and verify these functions from the module, referencing their exact names and signatures from test.c.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct uint128_t {\n  union {\n    uint8_t bytes[16];\n    uint32_t dw[4];\n    uint64_t qw[2];\n  } u;\n};\n\nuint32_t get_lo(const uint64_t x)\n{\n  return (uint32_t) x;\n}\n\nuint32_t get_hi(const uint64_t x)\n{\n  return (uint32_t) (x >> 32);\n}\n\nvoid add(struct uint128_t *r, const struct uint128_t *a, const struct uint128_t *b)\n{ \n  uint32_t c = 0;\n  for (int i = 0; i < 4; ++i)\n  {\n    uint64_t acc = ((uint64_t) a->u.dw[i]) + ((uint64_t) b->u.dw[i]) + ((uint64_t) c);\n    r->u.dw[i] = get_lo(acc);\n    c = get_hi(acc);\n  }\n}\n\nvoid sum(struct uint128_t *s, const struct uint128_t *a, size_t n)\n{\n  memset(s, 0, sizeof(*s));\n  for (int i = 0; i < n; ++i)\n  {\n    struct uint128_t tmp = *s;\n    add(s, &tmp, &a[i]);\n  }\n}\n\n\n```"},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet ptr_to_fresh nm ty = do {\n    x <- llvm_fresh_var nm ty;\n    p <- llvm_alloc ty;\n    llvm_points_to p (llvm_term x);\n    return (x, p);\n};\n\nlet add_spec = do {\n  r_p <- llvm_alloc (llvm_alias \"struct.uint128_t\");\n  (_, a_p) <- ptr_to_fresh \"a\" (llvm_alias \"struct.uint128_t\");\n  (_, b_p) <- ptr_to_fresh \"b\" (llvm_alias \"struct.uint128_t\");\n  llvm_execute_func [r_p, a_p, b_p];\n  r <- llvm_fresh_var \"r\" (llvm_alias \"struct.uint128_t\");\n  llvm_points_to r_p (llvm_term r);\n};\n\nlet sum_spec n = do {\n  s_p <- llvm_alloc (llvm_alias \"struct.uint128_t\");\n  (_, a_p) <- ptr_to_fresh \"a\" (llvm_array n (llvm_alias \"struct.uint128_t\"));\n  llvm_execute_func [s_p, a_p, (llvm_term {{ `n:[64] }})];\n  s <- llvm_fresh_var \"s\" (llvm_alias \"struct.uint128_t\");\n  llvm_points_to s_p (llvm_term s);\n};\n\nadd_ov <- llvm_compositional_extract m \"add\" \"add\" [] false add_spec yices;\n_ <- llvm_compositional_extract m \"sum\" \"sum\" [add_ov] false (sum_spec 10) yices;\n\nadd_thm <- prove_print yices\n  {{ \\a b -> add a b == reverse (split ((join (reverse a)) + (join (reverse b)))) }};\nprove_print (do { simplify (addsimps [add_thm] empty_ss); simplify (cryptol_ss ()); yices; })\n  {{ \\a -> sum a == reverse (split (foldl (+) (0:[128]) (map join (map reverse a)))) }};\n```"}]}
{"filename":"saw-script\/intTests\/test0068_zerobv\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/intTests\/test0068_zerobv\/test.saw, defines a let-bound specification named zero_bv_spec using llvm_fresh_var to create symbolic bitvector inputs matching the function's signature, and proves the correctness of the function zero_bv against this specification. Include minimal preconditions necessary for safety and termination, and invoke llvm_verify with zero_bv_spec and the exact function symbol name from the LLVM module."},{"role":"assistant","content":"```saw\n\/\/ test case for github issue https:\/\/github.com\/GaloisInc\/saw-script\/issues\/872\n\nprove_print z3 {{ \\(x:[0]) y z -> x * (y + z) == x*y + x*z }};\nprint \"z3 OK\";\n\nprove_print w4 {{ \\(x:[0]) y z -> x * (y + z) == x*y + x*z }};\nprint \"w4 OK\";\n```"}]}
{"filename":"saw-script\/intTests\/test2363\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated C or Java source files using the appropriate backend (llvm_load_module for C or java_load_class for Java). Define let-bound specifications for each target function or method by creating symbolic inputs with llvm_fresh_var or jvm_fresh_var as appropriate. Include minimal necessary preconditions to ensure safety and termination, such as valid pointer allocations or input bounds. Use mir_execute_func or the corresponding execution command to invoke the functions\/methods with these symbolic inputs, and specify expected return values with mir_return or equivalent. Reference exact symbol names and signatures from the source files in the verification commands. Do not inline the specifications directly in the verify calls; instead, bind them to let variables. Do not include solver references or comments in the SAWScript code."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nlet Stuff = mir_find_adt m \"test::Stuff\" [];\n\nlet mk_stuff_spec = do {\n    p <- mir_alloc_raw_ptr_const mir_u8;\n    mir_execute_func [p];\n    mir_return (mir_struct_value Stuff [mir_cast_raw_ptr p mir_i32]);\n};\n\nmk_stuff_ov <- mir_verify m \"test::mk_stuff\" [] false mk_stuff_spec z3;\n\nlet do_stuff_spec = do {\n    x <- mir_fresh_var \"x\" mir_u8;\n    p <- mir_alloc_raw_ptr_const mir_u8;\n    mir_points_to p (mir_term x);\n    mir_execute_func [mir_struct_value Stuff [mir_cast_raw_ptr p mir_i32]];\n    mir_return (mir_term {{ x + 1 }});\n};\n\ndo_stuff_ov <- mir_verify m \"test::do_stuff\" [] false do_stuff_spec z3;\n\nlet weird_add_spec = do {\n    x <- mir_fresh_var \"x\" mir_u8;\n    mir_execute_func [mir_term x];\n    mir_return (mir_term {{ x + 1 }});\n};\n\nmir_verify m \"test::weird_add\" [mk_stuff_ov, do_stuff_ov] false weird_add_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test0057\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the llvm backend that loads the LLVM module from saw-script\/intTests\/test0057\/test.saw. Define a let-bound specification named test_spec that uses llvm_fresh_var to create symbolic 64-bit inputs x and y. Reference the exact LLVM function symbols present in the associated source files and call them accordingly within the spec. Include minimal preconditions necessary for safe execution, such as ensuring no division by zero or out-of-bounds memory access. The spec should verify the correctness of the functions by comparing their outputs against expected results using SAW's prove or verify commands, without inline do blocks or solver references."},{"role":"assistant","content":"```saw\n\/\/ a variety of Cryptol terms\nlet c = {{ 17 : [8] }};\nx <- fresh_symbolic \"x\" {| [64] |};\ny <- fresh_symbolic \"y\" {| [64] |};\nlet t1 = {{ x + y }};\nlet t2 = {{ \\z -> z }};\nlet t3 = {{ \\(z : [32]) -> z }};\nlet t4 = {{ [1 .. 10] }};\nlet t5 = {{ [1 .. 10] : [10][32] }};\n\n\/\/ reading\/writing is consistent, i.e. writing a term to file and immediately\n\/\/ reading it back into memory does not change the term\nwrite_core \"c.out\" c;\nc_in <- read_core \"c.out\";\nlet thm_c = {{ c_in == c }};\nprove_print z3 thm_c;\n\n\/\/ NB. reading\/writing open terms will generate new fresh variables\nwrite_core \"x.out\" x;\nx_in <- read_core \"x.out\";\nlet thm_x = {{ x_in == x }};\nfails (prove_print z3 thm_x);\n\n\/\/ NB. reading\/writing open terms will generate new fresh variables\nwrite_core \"t1.out\" t1;\nt1_in<- read_core \"t1.out\";\nlet thm_t1 = {{ t1_in == t1 }};\nfails (prove_print z3 thm_t1);\n\n\/\/ N.B. This test currently crashes SAW due to bug #780\n\/\/ write_core \"t2.out\" t2;\n\/\/ t2_in <- read_core \"t2.out\";\n\/\/ let thm_t2 = {{ \\x -> t2_in x == t2 x }};\n\/\/ prove z3 thm_t2;\n\nwrite_core \"t3.out\" t3;\nt3_in <- read_core \"t3.out\";\nlet thm_t3 = {{ \\x -> t3_in x == t3 x }};\nprove_print z3 thm_t3;\n\n\/\/ N.B. This test currently crashes SAW due to bug #780\n\/\/ write_core \"t4.out\" t4;\n\/\/ t4_in <- read_core \"t4.out\";\n\/\/ let thm_t4 = {{ t4_in == t4 }};\n\/\/ prove_print z3 thm_t4;\n\nwrite_core \"t5.out\" t5;\nt5_in <- read_core \"t5.out\";\nlet thm_t5 = {{ t5_in == t5 }};\nprove_print z3 thm_t5;\n```"}]}
{"filename":"saw-script\/intTests\/test_mir_verify_arrays\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from test.linked-mir.json that verifies the functions test::f, test::g, test::h, and test::i. Define let-bound specs named f_spec, g_spec, h_spec, and i_spec respectively. Each spec should use llvm_fresh_var to create symbolic inputs and llvm_alloc to allocate memory as needed, with minimal preconditions for safety such as array bounds. Use llvm_execute_func to call the target functions with appropriate arguments referencing the exact function signatures. Use llvm_points_to and llvm_return to specify expected memory states and return values. Do not inline specs in the verify calls; instead, pass the let-bound specs as arguments to llvm_verify."},{"role":"assistant","content":"```saw\nenable_experimental;\n\nlet f_spec = do {\n  x0_ref <- mir_alloc mir_u32;\n  x0 <- mir_fresh_var \"x0\" mir_u32;\n  mir_points_to x0_ref (mir_term x0);\n\n  x1_ref <- mir_alloc mir_u32;\n  x1 <- mir_fresh_var \"x1\" mir_u32;\n  mir_points_to x1_ref (mir_term x1);\n\n  let x = mir_array_value (mir_ref mir_u32) [x0_ref, x1_ref];\n\n  mir_execute_func [x];\n\n  mir_return (mir_term {{ x0 + x1 }});\n};\n\nlet g_spec = do {\n  x0_ref <- mir_alloc_mut mir_u32;\n\n  x1_ref <- mir_alloc_mut mir_u32;\n  x1 <- mir_fresh_var \"x1\" mir_u32;\n  mir_points_to x1_ref (mir_term x1);\n\n  let x = mir_array_value (mir_ref_mut mir_u32) [x0_ref, x1_ref];\n\n  mir_execute_func [x];\n\n  mir_points_to x0_ref (mir_term {{ 42 : [32] }});\n  mir_points_to x1_ref (mir_term {{ x1 + 1 }});\n};\n\nlet h_spec = do {\n  mir_execute_func [];\n\n  x0_ref <- mir_alloc mir_u32;\n  mir_points_to x0_ref (mir_term {{ 27 : [32] }});\n\n  x1_ref <- mir_alloc mir_u32;\n  mir_points_to x1_ref (mir_term {{ 42 : [32] }});\n\n  let x = mir_array_value (mir_ref mir_u32) [x0_ref, x1_ref];\n  mir_return x;\n};\n\nlet i_spec = do {\n  let x = mir_term {{ [] : [0][32] }};\n  mir_execute_func [x];\n\n  mir_return (mir_array_value mir_u64 []);\n};\n\nlet i_spec_bad1 = do {\n  let x = mir_term {{ [42] : [1][32] }};\n  mir_execute_func [x];\n\n  mir_return (mir_array_value mir_u64 []);\n};\n\nlet i_spec_bad2 = do {\n  let x = mir_term {{ [] : [0][32] }};\n  mir_execute_func [x];\n\n  mir_return (mir_array_value mir_u64 [mir_term {{ 42 : [64] }}]);\n};\n\nm <- mir_load_module \"test.linked-mir.json\";\n\nmir_verify m \"test::f\" [] false f_spec z3;\nmir_verify m \"test::g\" [] false g_spec z3;\nmir_verify m \"test::h\" [] false h_spec z3;\nmir_verify m \"test::i\" [] false i_spec z3;\n\nfails (\n  mir_verify m \"test::i\" [] false i_spec_bad1 z3\n);\nfails (\n  mir_verify m \"test::i\" [] false i_spec_bad2 z3\n);\n```"}]}
{"filename":"saw-script\/intTests\/test0049_conditional_points_to\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from test.bc that verifies the functions get_val_impl(int *p, int x), get_val(int *p, int x), and get_val_default(int x) defined in test.c. Define let-bound specs named get_val_impl_spec, get_val_spec, and get_val_default_spec respectively. Use llvm_fresh_var to create symbolic inputs for pointer and integer arguments, allocate memory as needed with llvm_alloc, and execute the functions with llvm_execute_func. Include appropriate llvm_conditional_points_to and llvm_postcond calls to specify the behavior, ensuring minimal preconditions for safety and termination. Do not inline specs; bind them with let. Reference the exact function names as in the source. Do not include solver references or comments.\n\n# Source code:\ntest.c\n```C\nint get_val_impl(int *p, int x)\n{\n  if (x > 0)\n  {\n    *p = x;\n    return 0;\n  }\n  return 1;\n}\n\nint get_val(int *p, int x)\n{\n  return get_val_impl(p, x);\n}\n\nint get_val_default(int x)\n{\n  int res;\n  if (0 == get_val(&res, x))\n  {\n    return res;\n  }\n  return 0;\n}\n\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"test.bc\";\n\nlet get_val_impl_spec = do {\n  p <- llvm_alloc (llvm_int 32);\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [p, llvm_term x];\n  llvm_conditional_points_to {{ x >$ 0 }} p (llvm_term x);\n  llvm_return (llvm_term {{ (if x >$ 0 then 0 else 1) : [32] }});\n};\n\nlet get_val_impl_failure_spec = do {\n  p <- llvm_alloc (llvm_int 32);\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [p, llvm_term x];\n  \/\/ incorrect spec: {{ x > 0 }} instead of {{ x >$ 0 }}\n  llvm_conditional_points_to {{ x > 0 }} p (llvm_term x);\n};\n\nlet get_val_spec = do {\n  p <- llvm_alloc (llvm_int 32);\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [p, llvm_term x];\n  ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n  y <- llvm_fresh_var \"y\" (llvm_int 32);\n  llvm_conditional_points_to {{ ret == 0 }} p (llvm_term y);\n  llvm_postcond {{ ret == 0 ==> y >$ 0 }};\n  llvm_return (llvm_term ret);\n};\n\nlet get_val_failure0_spec = do {\n  p <- llvm_alloc (llvm_int 32);\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [p, llvm_term x];\n  ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n  y <- llvm_fresh_var \"y\" (llvm_int 32);\n  llvm_conditional_points_to {{ ret == 0 }} p (llvm_term y);\n  \/\/ incorrect spec: {{ y >$ 0 }} instead of {{ ret == 0 ==> y >$ 0 }}\n  llvm_postcond {{ y >$ 0 }};\n  llvm_return (llvm_term ret);\n};\n\nlet get_val_failure1_spec = do {\n  p <- llvm_alloc (llvm_int 32);\n  v <- llvm_fresh_var \"v\" (llvm_int 32);\n  llvm_points_to p (llvm_term v);\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [p, llvm_term x];\n  y <- llvm_fresh_var \"y\" (llvm_int 32);\n  \/\/ incorrect spec: p is invalidated by get_val_impl_spec\n  llvm_points_to p (llvm_term y);\n};\n\nlet get_val_default_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_execute_func [llvm_term x];\n  ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n  llvm_postcond {{ ret >= 0 }};\n  llvm_return (llvm_term ret);\n};\n\nget_val_imp_ov <- llvm_verify m \"get_val_impl\" [] false get_val_impl_spec (w4_unint_yices []);\nfails (llvm_verify m \"get_val_impl\" [] false get_val_impl_failure_spec (w4_unint_yices []));\nget_val_ov <- llvm_verify m \"get_val\" [get_val_imp_ov] false get_val_spec (w4_unint_yices []);\nfails (llvm_verify m \"get_val\" [get_val_imp_ov] false get_val_failure0_spec (w4_unint_yices []));\nfails (llvm_verify m \"get_val\" [get_val_imp_ov] false get_val_failure1_spec (w4_unint_yices []));\nllvm_verify m \"get_val_default\" [get_val_ov] false get_val_default_spec (w4_unint_yices []);\n```"}]}
{"filename":"saw-script\/intTests\/test0064_detect_vacuity\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'test.bc' and defines a let-bound specification named 'double_imp_spec'. In this spec, create a symbolic 32-bit integer input variable 'a' using llvm_fresh_var. Add minimal preconditions to ensure safety and termination if needed. Execute the function 'double_imp' with 'a' as input using llvm_execute_func. Add a postcondition expressing the expected behavior of 'double_imp' (i.e., output equals input shifted left by one). Finally, verify the function 'double_imp' against 'double_imp_spec' using llvm_verify.\n\n# Source code:\ntest.c\n```C\nint double_imp(int x) {\n    return x << 1;\n}\n\n```"},{"role":"assistant","content":"```saw\n\/\/ NOTE: in the current design, contradictions are indicated as a warning\n\/\/ message, so the following script should succeed, but contain a message about\n\/\/ the detected contradiction in its output.\n\nlet bad_spec = do {\n    a <- llvm_fresh_var \"a\" (llvm_int 32);\n    llvm_precond {{ a == 0 }};\n    llvm_precond {{ a == 1 }};\n    llvm_execute_func [llvm_term a];\n    llvm_postcond {{ a == 2 }};\n};\n\nm <- llvm_load_module \"test.bc\";\n\nllvm_verify m \"double_imp\" [] true bad_spec z3;\n```"}]}
{"filename":"saw-script\/intTests\/test2337\/test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the eqLetter function, ensuring it behaves as an equality operator for the Letter enum type. Also, specify properties that relate letterA to eqLetter, confirming that letterA produces the correct Letter value based on the input Boolean."},{"role":"assistant","content":"```cryptol\nenum Letter = A | B\n\neqLetter : Letter -> Letter -> Bit\neqLetter l1 l2 =\n  case l1 of\n    A ->\n      case l2 of\n        A -> True\n        B -> False\n    B ->\n      case l2 of\n        A -> False\n        B -> True\n\nletterA : Bool -> Letter\nletterA x =\n  if x then A else B\n```"}]}
{"filename":"saw-script\/intTests\/test0059_smt_array_2\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"test.bc\" that verifies the functions foo and bar defined in test.c. Define let-bound specs foo_spec and bar_spec using llvm_fresh_var to create symbolic inputs for size and len respectively, and llvm_symbolic_alloc to allocate memory for pointers. For foo_spec, allocate symbolic arrays for dest and src of length size (llvm_int 64), use llvm_points_to_array_prefix to initialize src, execute foo with these arguments, and verify dest matches src after execution. For bar_spec, allocate symbolic arrays a and b of length len * 8 bytes (llvm_int 64), initialize b, execute bar with these arguments, and verify a matches the expected transformation of b. Include minimal preconditions ensuring safety of memory operations. Use llvm_execute_func to call the functions and llvm_verify to verify bar against foo's specification. Do not inline specs; bind them with let. Reference exact function names foo and bar from test.c.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid foo(uint8_t *dest, uint8_t *src, size_t size)\n{\n  memcpy(dest, src, size);\n}\n\nvoid bar(uint64_t *a, uint64_t *b, size_t len)\n{\n  foo((uint8_t*) a, (uint8_t*) b, len * sizeof(uint64_t));\n}\n\n\n```"},{"role":"assistant","content":"```saw\nimport \"Test.cry\";\n\nenable_experimental;\n\nm <- llvm_load_module \"test.bc\";\n\nlet foo_spec = do {\n  size <- llvm_fresh_var \"size\" (llvm_int 64);\n  dest_ptr <- llvm_symbolic_alloc false 1 size;\n  src_ptr <- llvm_symbolic_alloc false 1 size;\n  src <- llvm_fresh_cryptol_var \"src\" {| ByteArray |};\n  llvm_points_to_array_prefix src_ptr src size;\n  llvm_execute_func [dest_ptr, src_ptr, (llvm_term size)];\n  llvm_points_to_array_prefix dest_ptr {{ f size src }} size;\n};\n\nlet foo_failure_spec = do {\n  size <- llvm_fresh_var \"size\" (llvm_int 64);\n  dest_ptr <- llvm_symbolic_alloc false 1 size;\n  src_ptr <- llvm_symbolic_alloc false 1 size;\n  src <- llvm_fresh_cryptol_var \"src\" {| ByteArray |};\n  llvm_points_to_array_prefix src_ptr src {{ drop`{32} size }};\n  llvm_execute_func [dest_ptr, src_ptr, (llvm_term size)];\n};\n\nlet bar_spec = do {\n  len <- llvm_fresh_var \"len\" (llvm_int 64);\n  let byte_len = rewrite (cryptol_ss ()) {{ 8 * len }};\n  a_ptr <- llvm_symbolic_alloc false 8 byte_len;\n  b_ptr <- llvm_symbolic_alloc false 8 byte_len;\n  b <- llvm_fresh_cryptol_var \"b\" {| ByteArray |};\n  llvm_points_to_array_prefix b_ptr b byte_len;\n  llvm_execute_func [a_ptr, b_ptr, (llvm_term len)];\n  llvm_points_to_array_prefix a_ptr {{ f byte_len b }} byte_len;\n};\n\nfoo_ov <- llvm_unsafe_assume_spec m \"foo\" foo_spec;\nfails (llvm_unsafe_assume_spec m \"foo\" foo_failure_spec);\nllvm_verify m \"bar\" [foo_ov] false bar_spec (w4_unint_z3 [\"f\"]);\n```"}]}
{"filename":"saw-script\/intTests\/test1094_2464\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated C\/Java source files using the appropriate backend inferred from the presence of java_load_class or llvm_load_module. Define a let-bound specification named <name>_spec that uses symbolic inputs created with jvm_fresh_var or llvm_fresh_var corresponding to the exact function or method signatures from the source. Include minimal preconditions necessary for safe execution, such as loop bounds or array size constraints. The harness should invoke the target functions\/methods by their exact symbol names and verify their correctness against the specification. Do not include inline do blocks directly as arguments; instead, bind them to let names. Do not reference solvers explicitly and produce SAW code without comments or Markdown."},{"role":"assistant","content":"```saw\n\/\/ A regression test for #1094 and #2464. This ensures that we can successfully\n\/\/ use sat-related commands to produce models for Vec values in SAWCore, in both\n\/\/ the SBV and What4 backends.\n\nlet test_prop (prover : ProofScript ()) (prop : Term) = do {\n    \/\/ Test both sat_print...\n    sat_print prover prop;\n\n    \/\/ ...and sat\/caseSatResult, as these commands exercise slightly different\n    \/\/ code paths.\n    r_sbv <- sat prover prop;\n    caseSatResult r_sbv (print \"Unsat\") print;\n};\n\nlet prop1 = {{ \\(x : [2][8]) -> x == reverse x }};\ntest_prop (sbv_unint_z3 []) prop1;\ntest_prop (w4_unint_z3 []) prop1;\n\nlet prop2 = {{ \\(x : [0][8]) -> x == reverse x }};\ntest_prop (sbv_unint_z3 []) prop2;\ntest_prop (w4_unint_z3 []) prop2;\n```"}]}
{"filename":"saw-script\/crux-mir-comp\/test\/symb_eval\/cryptol\/uninterp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to specify and verify the behavior of the 'pow' function defined in the module 'test::symb_eval::cryptol::uninterp'. The properties should check correctness of exponentiation by repeated squaring over 64-bit words, ensuring that 'pow n 0' equals 1 and that 'pow n (k+1)' equals 'mult n (pow n k)'. Additionally, write properties that characterize the 'mult' function as multiplication in GF(2^64) modulo the given irreducible polynomial, assuming 'mult' is properly defined. These properties should be suitable for use with Cryptol's :check and :prove commands."},{"role":"assistant","content":"```cryptol\nmodule test::symb_eval::cryptol::uninterp where\n\ntype U64 = [64]\n\npow : U64 -> U64 -> U64\npow n k = last vals where\n    sq x = mult x x\n    vals = [1]\n         # [ if i then mult n acc else acc\n           | acc <- map sq vals\n           | i   <- k ]\n\nirreducible : [65]\nirreducible = <| x^^64 + x^^4 + x^^3 + x + 1 |>\n\n\/**\n * Multiply two elements in GF28. [FIPS-197u1] Section 4.2.\n *\/\nmult : U64 -> U64 -> U64\n\/\/ mult x y = pmod (pmult x y) irreducible\nmult = undefined \/\/ definition replaced to check that uninterp is doing something in the test\n```"}]}
{"filename":"saw-script\/crux-mir-comp\/test\/symb_eval\/cryptol\/basic.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of each function in the given module. For example, specify that addByte returns the sum modulo 256 of its inputs, tupleArg returns the sum of the tuple elements, tupleRet returns a tuple of sum and difference, arrayArg sums the two elements of the input array, arrayRet returns an array with sum and difference, and xorBits performs bitwise XOR on inputs of arbitrary length. Include properties suitable for automated checking or proving."},{"role":"assistant","content":"```cryptol\nmodule test::symb_eval::cryptol::basic where\n\naddByte : [8] -> [8] -> [8]\naddByte x y = x + y\n\ntupleArg : ([8], [8]) -> [8]\ntupleArg (x, y) = x + y\n\ntupleRet : [8] -> [8] -> ([8], [8])\ntupleRet x y = (x + y, x - y)\n\narrayArg : [2][8] -> [8]\narrayArg [x, y] = x + y\n\narrayRet : [8] -> [8] -> [2][8]\narrayRet x y = [x + y, x - y]\n\nxorBits : {n} (fin n) => [n] -> [n] -> [n]\nxorBits x y = x ^ y\n```"}]}
{"filename":"saw-script\/crux-mir-comp\/test\/symb_eval\/cryptol\/size_poly_nested.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the function `f` correctly computes the sum of all elements in a nested sequence of bytes, ensuring it handles arbitrary finite dimensions `m` and `n`. Include properties suitable for symbolic evaluation and automated checking."},{"role":"assistant","content":"```cryptol\nmodule test::symb_eval::cryptol::size_poly_nested where\n\nf: {m,n} (fin m, fin n) => [m][n][8] -> [8]\nf xs = sum (join xs)\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw\/test-files\/Foo.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the functions defined in the Foo module. Specifically, write properties to check that 'id' behaves as the identity function for any input, 'add' correctly adds two sequences element-wise, and 'getFoo' correctly extracts the 'foo' field from a record. Include type annotations and ensure the properties are suitable for automated checking or proving."},{"role":"assistant","content":"```cryptol\nmodule Foo where\n\nid : {a} a -> a\nid x = x\n\nx : [8]\nx = 255\n\nadd : {a} (fin a) => [a] -> [a] -> [a]\nadd = (+)\n\nfoo : {foo : [32], bar : [32]} \nfoo = {foo = 23, bar = 99}\n\ngetFoo : {foo : [32], bar : [32]}  -> [32]\ngetFoo x = x.foo\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/drbg\/drbg-helpers.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to specify and verify the correctness of the DRBG helper functions defined in the file, including `drbg_generate_seedlen` and `encrypt_128`. The properties should check that `encrypt_128` correctly implements AES block encryption with a 128-bit key and that `drbg_generate_seedlen` produces outputs consistent with the DRBG specification. Include boundary cases such as maximum sequence numbers and key sizes."},{"role":"assistant","content":"```cryptol\nimport DRBG\nimport AES\n\n\/\/ TODO: the original version of this, keysize = 32 conflicted\n\/\/ in the definition of encrypt_128\ntype keysize = 16 \/\/ keylen \/ 8\n\nmax_seq_number : [blocksize*8]\nmax_seq_number = ~zero\n\ndrbg_generate_seedlen : s2n_drbg -> [seedlen] -> Bit -> ([seedlen], s2n_drbg)\ndrbg_generate_seedlen = drbg_generate `{n=seedlen,blocks=2}\n\nencrypt_128 : [keysize][8] -> [blocksize][8] -> [blocksize][8]\nencrypt_128 key msg =\n  split (block_encrypt (join key) (join msg))\n\nmode_128 = 0\nmode_256 = 1\n\n\/\/ TODO: Tried to simulate the top-level symbolic variable from the\n\/\/ saw script version using undefined below, but in the end\n\/\/ this trick did not work.\n\/\/ Note: I changed this. Originally it was seedsize, but\n\/\/ that appears to be 48 here which prevents some proofs\n\/\/ from going through.\n\/\/type entropy_len = 32\n\/\/fake_entropy : [entropy_len*8]\n\/\/fake_entropy = undefined\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/SHA256.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the SHA256 HMAC implementation using the LLVM backend. Define a let-bound specification named sha256_hmac_spec that symbolically models the input parameters with llvm_fresh_var, ensuring any necessary preconditions for safe memory access and termination. Reference the exact LLVM function symbol for the SHA256 HMAC computation as defined in the associated C source files, and invoke it within the spec. The harness should prove correctness properties imported from the SHA256.cry Cryptol module, such as imp_correct, for a range of input sizes. Do not include solver configurations or comments in the SAWScript."},{"role":"assistant","content":"```saw\nimport \"SHA256.cry\";\n\nlet check_sha n = do {\n    print (str_concat \"Checking imp_correct for byte count \" (show n));\n    time (prove_print abc {{ imp_correct : [n][8] -> Bit }});\n};\n\nfor [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] check_sha;\nfor [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32] check_sha;\nfor [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48] check_sha;\nfor [49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64] check_sha;\nfor [65, 127, 128, 129, 1000] check_sha;\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/Hashing.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the hash state translation functions between SHA512_c_state and SHA256_c_state defined in the Hashing.cry module. Specifically, specify properties that prove the round-trip conversions (sha512_c_state_to_sha256_c_state followed by sha256_c_state_to_sha512_c_state) preserve the original SHA512_c_state, and that the composed functions sha512_c_state_to_sha256_state and sha256_state_to_sha512_c_state correctly correspond to the expected SHA256State transformations. Include properties that validate the sha256_init_sha512_c_state, sha256_update_sha512_c_state, and sha256_digest_sha512_c_state functions behave consistently with the SHA256 specification imported from SHA256.cry."},{"role":"assistant","content":"```cryptol\nmodule Hashing where\n\nimport SHA256\n\n\n\/*\ntypedef enum { S2N_HASH_NONE, S2N_HASH_MD5, S2N_HASH_SHA1, S2N_HASH_SHA224, S2N_HASH_SHA256, S2N_HASH_SHA384,\n    S2N_HASH_SHA512, S2N_HASH_MD5_SHA1\n} s2n_hash_algorithm;\n*\/\nS2N_HASH_NONE     = 0:[32]\nS2N_HASH_MD5      = 1:[32]\nS2N_HASH_SHA1     = 2:[32]\nS2N_HASH_SHA224   = 3:[32]\nS2N_HASH_SHA256   = 4:[32]\nS2N_HASH_SHA384   = 5:[32]\nS2N_HASH_SHA512   = 6:[32]\nS2N_HASH_MD5_SHA1 = 7:[32]\n\n\/*\n134 typedef struct SHA256state_st {\n135     SHA_LONG h[8];\n136     SHA_LONG Nl, Nh;\n137     SHA_LONG data[SHA_LBLOCK];\n138     unsigned int num, md_len;\n139 } SHA256_CTX;\n*\/\n\/\/ Looking at the generated LLVM in ':\/src\/hmac.ll' gives the precise\n\/\/ layout, without having to find the definitions of the above\n\/\/ macros.\n\/*\n%struct.SHA512state_st = type { [8 x i64], i64, i64, %union.anon.0, i32, i32 }\n%union.anon.0 = type { [16 x i64] }\n*\/\n\n\/\/ The hash state in s2n is stored in a union, and the largest member\n\/\/ of that union is the SHA512 hash state. So, we need to translate\n\/\/ between SHA512 and SHA256 hash states.\n\/\/\n\/\/ \/usr\/include\/openssl\/sha.h\ntype SHA512_c_state =\n  { h      : [8][64]\n  , Nl     : [64]\n  , Nh     : [64]\n  , u      : [16][64]\n  , num    : [32]\n  , md_len : [32]\n  }\ntype SHA512_c_bits = 8*64+64+64+16*64+32+32\n\njoin512_c_state : SHA512_c_state -> [SHA512_c_bits]\njoin512_c_state st = join st.h # st.Nl # st.Nh # join st.u # st.num # st.md_len\n\ntype SHA256_c_state =\n  { h      : [8][32]\n  , Nl     : [32]     \/\/ The low bits of 'sz'.\n  , Nh     : [32]     \/\/ The high bits of 'sz'.\n  , u      : [16][32] \/\/ The 'block': '[16][32] == [8][64]' when flattened.\n  , num    : [32]     \/\/ The 'n', but extended to 32 bits.\n  , md_len : [32]     \/\/ The value of 'md_len' is always 32,\n  }                   \/\/ i.e. 'SHA256_DIGEST_LENGTH'.\ntype SHA256_c_bits = 8*32+32+32+16*32+32+32\n\njoin256_c_state : SHA256_c_state -> [SHA256_c_bits]\njoin256_c_state st = join st.h # st.Nl # st.Nh # join st.u # st.num # st.md_len\n\ntype SHA256_DIGEST_LENGTH = 32\ntype SHA512_DIGEST_LENGTH = 64\n\n\n\/\/ Recall the 'SHA256State' in our Cryptol model in '.\/SHA256.cry':\n\/*\ntype SHA256State = { h     : [8][32]\n                   , block : [64][8]\n                   , n     : [16]\n                   , sz    : [64]\n                   }\n*\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Basic hash-state translations.\n\n\/\/ The following code describes how to marshall back and forth between a\n\/\/ SHA256 C state and a SHA512 C state. Doing this is unnecessary for the\n\/\/ HMAC verification, but it is necessary to concretely evaluate the specs.\n\/\/ The rest of this section, therefore, does not need to be trusted.\n\n\/\/ I'm using the initial, high order bits of the SHA512 state to\n\/\/ construct the SHA256 state. The LLVM code doesn't make it clear\n\/\/ that this is correct -- it depends on the semantics of 'bitcast' --\n\/\/ but I did an experiment which validates this choice; see\n\/\/ 'examples\/llvm\/union' in the SAWScript repo.\nsha512_c_state_to_sha256_c_state : SHA512_c_state -> SHA256_c_state\nsha512_c_state_to_sha256_c_state st =\n  { h      = split (take bits)\n  , Nl     = take (drop`{front=8*32} bits)\n  , Nh     = take (drop`{front=8*32+32} bits)\n  , u      = split (take (drop`{front=8*32+32+32} bits))\n  , num    = take (drop`{front=8*32+32+32+16*32} bits)\n  , md_len = drop`{front=8*32+32+32+16*32+32} bits\n  }\n  where\n    bits : [SHA256_c_bits]\n    bits = take bits0\n    bits0 : [SHA512_c_bits]\n    bits0 = join512_c_state st\n\n\/\/ We need the original state, 'st0', to compute the trailing SHA512\n\/\/ bits which aren't used in the SHA256 state.\nsha256_c_state_to_sha512_c_state : SHA512_c_state -> SHA256_c_state -> SHA512_c_state\nsha256_c_state_to_sha512_c_state st0 st =\n  { h      = split (take bits)\n  , Nl     = take (drop`{front=8*64} bits)\n  , Nh     = take (drop`{front=8*64+64} bits)\n  , u      = split (take (drop`{front=8*64+64+64} bits))\n  , num    = take (drop`{front=8*64+64+64+16*64} bits)\n  , md_len = drop`{front=8*64+64+64+16*64+32} bits\n  }\n  where\n    bits : [SHA512_c_bits]\n    bits = join256_c_state st # drop bits0\n    bits0 : [SHA512_c_bits]\n    bits0 = join512_c_state st0\n\nsha256_c_state_to_sha256_state : SHA256_c_state -> SHA256State\nsha256_c_state_to_sha256_state st =\n  { h     = st.h\n  , block = split (join st.u)\n  , n     = drop st.num\n  , sz    = st.Nh # st.Nl\n  }\n  where\n    bits : [SHA256_c_bits]\n    bits = join256_c_state st\n\nsha256_state_to_sha256_c_state : SHA256State -> SHA256_c_state\nsha256_state_to_sha256_c_state st =\n  { h      = st.h\n  , Nl     = Nl\n  , Nh     = Nh\n  , u      = split (join st.block)\n  , num    = (zero # st.n) : [32]\n  , md_len = `SHA256_DIGEST_LENGTH : [32]\n  }\n  where\n    [Nh, Nl] = split st.sz\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Composed hash-state translations.\n\nsha512_c_state_to_sha256_state : SHA512_c_state -> SHA256State\nsha512_c_state_to_sha256_state st =\n  sha256_c_state_to_sha256_state (sha512_c_state_to_sha256_c_state st)\n\nsha256_state_to_sha512_c_state : SHA512_c_state -> SHA256State -> SHA512_c_state\nsha256_state_to_sha512_c_state st0 st =\n  sha256_c_state_to_sha512_c_state st0 (sha256_state_to_sha256_c_state st)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ SHA256 specs in terms of the SHA512 C hash state.\n\nsha256_init_sha512_c_state : SHA512_c_state -> SHA512_c_state\nsha256_init_sha512_c_state st0_c_512 = st1_c_512\n  where\n    st0_256 = SHA256Init\n    st1_c_512 = sha256_state_to_sha512_c_state st0_c_512 st0_256\n\nsha256_update_sha512_c_state : {n} (fin n) => SHA512_c_state -> [n][8] -> SHA512_c_state\nsha256_update_sha512_c_state st0_c_512 in = st1_c_512\n  where\n    st0_256 = sha512_c_state_to_sha256_state st0_c_512\n    st1_256 = SHA256Update st0_256 in\n    st1_c_512 = sha256_state_to_sha512_c_state st0_c_512 st1_256\n\n\/\/ We don't return a new 'SHA512_c_state', since it's unspecified (I\n\/\/ think ...).\nsha256_digest_sha512_c_state : SHA512_c_state -> [SHA256_DIGEST_LENGTH][8]\nsha256_digest_sha512_c_state st0_c_512 = out1\n  where\n    st0_256 = sha512_c_state_to_sha256_state st0_c_512\n    out1 = split (SHA256Final st0_256)\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/HMAC_properties.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and equivalence of the HMAC implementations specialized to SHA256 in the given module. Include properties that check the equivalence between the iterative and state-based HMAC computations, correctness of multi-chunk message processing, and the behavior of update functions when appending or given empty inputs. Ensure the properties cover the functions hmac_c_state_correct, hmac_c_state_multi_correct, hmac_update_append, hash_update_append, hash_update_empty, and hmac_update_empty."},{"role":"assistant","content":"```cryptol\nmodule HMAC_properties where\n\nimport HMAC\nimport Hashing\nimport HMAC_iterative\n\n\/\/\/\/\/\/\/\/ Equivalence of implementations \/\/\/\/\/\/\/\/\n\/\/\n\/\/ This is specialized to SHA256, since we don't have concrete\n\/\/ implementations of the other algorithms.\nhmac_c_state : { key_size, msg_size }\n     ( 32 >= width msg_size, 64 >= width (8 * key_size) )\n  => HMAC_c_state -> [key_size][8] -> [msg_size][8] -> [SHA256_DIGEST_LENGTH * 8]\nhmac_c_state st0 key msg = digest\n  where\n  (st1, digest) =\n    hmac_digest_c_state `{block_size=64}\n      (hmac_update_c_state\n        (hmac_init_c_state `{block_size=64,hash_block_size=64,digest_size=SHA256_DIGEST_LENGTH}\n         st0 alg key)\n        msg)\n  \/\/ Specialize to SHA256.\n  alg = S2N_HMAC_SHA256\n\nhmac_c_state_correct : { key_size, msg_size }\n              ( 32 >= width msg_size, 64 >= width (8 * key_size) )\n           => HMAC_c_state -> [key_size][8] -> [msg_size][8] -> Bit\nproperty hmac_c_state_correct st0 key msg =\n  hmacSHA256 key msg == hmac_c_state st0 key msg\n\nhmac_c_state_multi : { key_size, msg_size, msg_chunks}\n     ( 32 >= width msg_size, 64 >= width (8 * key_size), fin msg_chunks )\n  => HMAC_c_state -> [key_size][8] -> [msg_chunks][msg_size][8] -> [SHA256_DIGEST_LENGTH * 8]\nhmac_c_state_multi st0 key msgs = digest\n  where\n    initial_state = (hmac_init_c_state `{block_size=64,hash_block_size=64,digest_size=SHA256_DIGEST_LENGTH}\n         st0 alg key)\n    mid_state = hmac_update_c_state_multi initial_state msgs\n    (st1, digest) = hmac_digest_c_state `{block_size=64} mid_state\n  \/\/ Specialize to SHA256.\n    alg = S2N_HMAC_SHA256\n\nhmac_update_c_state_multi : {msg_size, msg_chunks}\n  ( 32 >= width msg_size, fin msg_chunks)\n  => HMAC_c_state -> [msg_chunks][msg_size][8] -> HMAC_c_state\nhmac_update_c_state_multi st msgs = states ! 0\n  where\n    states = [st] # [hmac_update_c_state s msg | msg <- msgs | s <- states]\n\nhmac_c_state_multi_correct : { key_size, msg_size, msg_chunks }\n              ( 32 >= width msg_size\n              , 64 >= width (8 * key_size)\n              , fin msg_chunks\n              , 32 >= width (msg_chunks * msg_size)\n              , 64 >= width (8 * (64 + msg_size * msg_chunks))\n              )\n           => HMAC_c_state -> [key_size][8] -> [msg_chunks][msg_size][8] -> Bit\nproperty hmac_c_state_multi_correct st0 key msgs =\n    hmacSHA256 key (join msgs) == hmac_c_state_multi st0 key msgs\n\nhmac_update_append x y s =\n  hmac_update_c_state (hmac_update_c_state s x) y == hmac_update_c_state s (x # y)\n\nhash_update_append x y s =\n  hash_update_c_state (hash_update_c_state s x) y == hash_update_c_state s (x # y)\n\nhmac_update_append_init x y k st0 =\n    hmac_update_c_state (hmac_update_c_state s x) y == hmac_update_c_state s (x # y)\n    where\n      s = hmac_init_c_state st0 S2N_HMAC_SHA256 k\n\nproperty hash_update_empty s = hash_update_c_state s [] == s\n\nproperty hmac_update_empty s =\n  s.currently_in_hash_block == s.currently_in_hash_block % (zero # s.block_size)\n  ==>\n  hmac_update_c_state s [] == s\n\nproperty pass =\n    ~zero ==\n    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] \"Hi There\" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\n    , hmacSHA256 \"Jefe\" \"what do ya want for nothing?\" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\n    ]\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property or proof script that verifies the correctness of the SHA256Imp implementation by proving its equivalence to the SHA256 specification function for all valid inputs."},{"role":"assistant","content":"```cryptol\nmodule SHA256 where\n\n\/*\n * SHA256 Functions : Section 4.1.2\n *\/\n\nCh : [32] -> [32] -> [32] -> [32]\nCh x y z = (x && y) ^ (~x && z)\n\nMaj : [32] -> [32] -> [32] -> [32]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nS0 : [32] -> [32]\nS0 x = (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)\n\nS1 : [32] -> [32]\nS1 x = (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)\n\ns0 : [32] -> [32]\ns0 x = (x >>> 7) ^ (x >>> 18) ^ (x >> 3)\n\ns1 : [32] -> [32]\ns1 x = (x >>> 17) ^ (x >>> 19) ^ (x >> 10)\n\n\/*\n * SHA256 Constants : Section 4.2.2\n *\/\n\nK : [64][32]\nK = [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n     ]\n\n\/*\n * Preprocessing (padding and parsing) for SHA256 : Section 5.1.1 and 5.2.1\n *\/\npreprocess : {msgLen,contentLen,chunks,padding}\n     ( fin msgLen\n     , 64 >= width msgLen                              \/\/ message width fits in a word\n     , contentLen == msgLen + 65                       \/\/ message + header\n     , chunks     == (contentLen+511) \/ 512\n     , padding    == (512 - contentLen % 512) % 512    \/\/ prettier if type #'s could be < 0\n     )\n     => [msgLen] -> [chunks][512]\npreprocess msg = split (msg # [True] # (zero:[padding]) # (`msgLen:[64]))\n\n\/*\n * SHA256 Initial Hash Value :  Section 5.3.3\n *\/\n\nH0 : [8][32]\nH0 = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n       0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]\n\n\/*\n * The SHA256 Hash computation : Section 6.2.2\n *\n * We have split the computation into a message scheduling function, corresponding\n * to step 1 in the documents loop, and a compression function, corresponding to steps 2-4.\n *\/\n\nSHA256MessageSchedule : [16][32] -> [64][32]\nSHA256MessageSchedule M = W where\n    W = M # [ s1 (W@(j-2)) + (W@(j-7)) + s0 (W@(j-15)) + (W@(j-16)) | j <- [16 .. 63]:[_][8] ]\n\n\n\nSHA256Compress : [8][32] -> [64][32] -> [8][32]\nSHA256Compress H W = [as!0 + H@0, bs!0 + H@1, cs!0 + H@2, ds!0 + H@3, es!0 + H@4, fs!0 + H@5, gs!0 + H@6, hs!0 + H@7] where\n    T1 = [h + S1 e + Ch e f g  + k + w | h <- hs | e <- es | f <- fs | g <- gs | k <- K | w <- W]\n    T2 = [S0 a  + Maj a b c  | a <- as | b <- bs | c <- cs]\n    hs = take `{65} ([H@7] # gs)\n    gs = take `{65} ([H@6] # fs)\n    fs = take `{65} ([H@5] # es)\n    es = take `{65} ([H@4] # [d + t1 | d <- ds | t1 <- T1])\n    ds = take `{65} ([H@3] # cs)\n    cs = take `{65} ([H@2] # bs)\n    bs = take `{65} ([H@1] # as)\n    as = take `{65} ([H@0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\nSHA256Block : [8][32] -> [16][32] -> [8][32]\nSHA256Block H M = SHA256Compress H (SHA256MessageSchedule M)\n\n\/*\n * The SHA256' function hashes a preprocessed sequence of blocks with the\n * compression function.  The SHA256 function hashes a sequence of bytes, and\n * is more likely the function that will be similar to those seein in an\n * implementation to be verified.\n *\/\n\nSHA256' : {a} (fin a) => [a][16][32] -> [8][32]\nSHA256' blocks = hash!0 where\n    hash = [H0] # [SHA256Block h b | h <- hash | b <- blocks]\n\nSHA256 : {a} (fin a, 64 >= width (8*a)) => [a][8] -> [256]\nSHA256 msg =   join (SHA256' [ split x | x <- preprocess(join msg)])\n\nproperty katsPass = ~zero == [test == kat | (test,kat) <- kats ]\n\nkats = [ (SHA256 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n         , 0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1)\n       , (SHA256 \"\"\n         ,0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855)\n       , (SHA256 \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n         , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1)\n       \/\/ , ([0x61 | i <- [1..1000000] : [_][32]]\n       \/\/   , 0xcdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0)\n       ]\n\n\/\/\/\/\/\/\/\/ Imperative top level \/\/\/\/\/\/\/\/\n\ntype SHA256State = { h : [8][32]\n                   , block : [64][8]\n                   , n : [16]\n                   , sz : [64]\n                   }\n\nSHA256Init : SHA256State\nSHA256Init = { h = H0\n             , block = zero\n             , n = 0\n             , sz = 0\n             }\n\nSHA256Update1 : SHA256State -> [8] -> SHA256State\nSHA256Update1 s b =\n  if s.n == 64\n    then { h = SHA256Block s.h (split (join s.block))\n         , block = [b] # zero\n         , n = 1\n         , sz = s.sz + 8\n         }\n    else { h = s.h\n         , block = update s.block s.n b\n         , n = s.n + 1\n         , sz = s.sz + 8\n         }\n\nSHA256Update : {n} (fin n) => SHA256State -> [n][8] -> SHA256State\nSHA256Update sinit bs = ss!0\n  where ss = [sinit] # [ SHA256Update1 s b | s <- ss | b <- bs ]\n\n\/\/ Add padding and size and process the final block.\nSHA256Final : SHA256State -> [256]\nSHA256Final s = join (SHA256Block h b')\n  \/\/ Because the message is always made up of bytes, and the size is a\n  \/\/ fixed number of bytes, the 1 pad will always be at least a byte.\n  where s' = SHA256Update1 s 0x80\n        \/\/ Don't need to add zeros. They're already there. Just update\n        \/\/ the count of bytes in this block. After adding the 1 pad, there\n        \/\/ are two possible cases: the size will fit in the current block,\n        \/\/ or it won't.\n        (h, b) = if s'.n <= 56 then (s'.h, s'.block)\n                 else (SHA256Block s'.h (split (join s'.block)), zero)\n        b' = split (join b || (zero # s.sz))\n\nSHA256Imp : {a} (64 >= width (8*a)) => [a][8] -> [256]\nSHA256Imp msg = SHA256Final (SHA256Update SHA256Init msg)\n\nproperty katsPassImp = ~zero == [test == kat | (test,kat) <- katsImp ]\n\nkatsImp = [ (SHA256Imp \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n            , 0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1)\n          , (SHA256Imp \"\"\n            , 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855)\n          , (SHA256Imp \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n            , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1)\n          \/\/ , ([0x61 | i <- [1..1000000] : [_][32]]\n          \/\/   , 0xcdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0)\n          ]\n\nproperty imp_correct msg = SHA256 msg == SHA256Imp msg\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/modthm.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the `modthm` function in the given file. The properties should check that `modthm` holds under the precondition `modthm_precond` for all valid inputs, ensuring the modular arithmetic identity is correctly implemented for the specified block sizes. Include properties that leverage `valid_block_sizes` to constrain the domain and prove the equivalence expressed in `modthm`."},{"role":"assistant","content":"```cryptol\nvalid_block_sizes : [16] -> [16] -> Bit\nvalid_block_sizes hbs bs =\n  \/\/ We're not handling SSLv3 yet.\n  \/\/((bs, hbs) == (40, 64)) ||\n  \/\/((bs, hbs) == (48, 64)) ||\n  ((bs, hbs) == (64, 64)) ||\n  ((bs, hbs) == (128, 128))\n\nmodthm : [32] -> [32] -> [32] -> [16] -> [16] -> Bit\nmodthm x11 x15 x16 hash_block_size block_size =\n  ((((x11 + (x16 % x17)) % x18) + (x15 % x17)) % x18)\n  ==\n  ((x11 + ((x16 + x15) % x17)) % x18)\n  where x17 = zero # hash_block_size\n        x18 = zero # block_size\n\nmodthm_precond : [32] -> [32] -> [32] -> [16] -> [16] -> Bit\nmodthm_precond x11 x15 x16 hash_block_size block_size =\n  if (valid_block_sizes hash_block_size block_size) then\n    modthm x11 x15 x16 hash_block_size block_size\n  else True\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/HMAC_iterative.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol specifications that formally verify the correctness of the HMAC iterative implementation specialized to SHA256 in the provided module. Your specification should capture the expected behavior of the key initialization, update, and digest functions on the HMAC_c_state type, ensuring that the Cryptol model matches the standard HMAC algorithm semantics. Include properties that relate the iterative HMAC state transitions to the functional HMAC definition and verify that the final digest output corresponds to the expected HMAC-SHA256 result."},{"role":"assistant","content":"```cryptol\nmodule HMAC_iterative where\n\nimport Array\nimport SHA256\nimport Hashing\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ HMAC (specialized to SHA256).\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nS2N_HMAC_NONE       = 0:[32]\nS2N_HMAC_MD5        = 1:[32]\nS2N_HMAC_SHA1       = 2:[32]\nS2N_HMAC_SHA224     = 3:[32]\nS2N_HMAC_SHA256     = 4:[32]\nS2N_HMAC_SHA384     = 5:[32]\nS2N_HMAC_SHA512     = 6:[32]\nS2N_HMAC_SSLv3_MD5  = 7:[32]\nS2N_HMAC_SSLv3_SHA1 = 8:[32]\n\n    uint8_t xor_pad[128];\n\n    \/* For storing the inner digest *\/\n    uint8_t digest_pad[SHA512_DIGEST_LENGTH];\n};\n*\/\ntype HMAC_c_state =\n  { alg                     : [32]\n  , hash_block_size         : [16]\n  , currently_in_hash_block : [32]\n  , block_size              : [16]\n  , digest_size             : [8]\n  , inner                   : SHA512_c_state\n  , inner_just_key          : SHA512_c_state\n  , outer                   : SHA512_c_state\n  , outer_just_key          : SHA512_c_state\n  , xor_pad                 : [128][8]\n  , digest_pad              : [SHA512_DIGEST_LENGTH][8]\n  }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Deep HMAC specs in terms of C HMAC state.\n\/\/\n\/\/ Here \"deep\" because we reimplement the HMAC functions to call the\n\/\/ corresponding hash functions on the raw C hash states, instead of\n\/\/ converting them to Cryptol SHA256 hash states.\n\ntype ByteArray = Array[64][8]\n\ntype hash_init_ty =\n  SHA512_c_state -> SHA512_c_state\ntype hash_update_ty msg_size =\n  SHA512_c_state -> [msg_size][8] -> SHA512_c_state\ntype hash_digest_ty digest_size =\n  SHA512_c_state -> [digest_size][8]\n\nhash_init_c_state : hash_init_ty\nhash_init_c_state = sha256_init_sha512_c_state\n\/\/ Cryptol does not support polymorphic arguments (rank 2\n\/\/ polymorphism), so making the hash update function a parameter to\n\/\/ the hmac functions is annoying, since we must pass a separate\n\/\/ monomorphic copy for each use at a different type. Instead, we just\n\/\/ define it at the top level, but can leave it uninterpreted in the\n\/\/ \"generic\" verification.\nhash_update_c_state :\n  {msg_size} (fin msg_size) => hash_update_ty msg_size\nhash_update_c_state = sha256_update_sha512_c_state\nhash_update_c_state_unbounded :\n  SHA512_c_state -> ByteArray -> [32] -> SHA512_c_state\nhash_update_c_state_unbounded = undefined\n\n\nhash_digest_c_state :\n  {digest_size} (fin digest_size) => hash_digest_ty digest_size\n\/\/ To support any digest length, we pad and truncate as necessary.\n\/\/ This implementation only makes sense for SHA256 size params, but\n\/\/ that is not a concern since we leave these functions uninterpreted\n\/\/ in the verification against the S2N C code (we want a concrete\n\/\/ implementation for debugging and to compare with our functional spec).\nhash_digest_c_state st =\n  take `{digest_size}\n    (sha256_digest_sha512_c_state st # (zero : [inf][8]))\n\/\/ Cases depending on key size:\n\/\/\n\/\/ * small key (key size <= block size)\n\/\/\n\/\/   copy key into 'xor_pad', up to key size\n\/\/\n\/\/ * large key (key size > block size)\n\/\/\n\/\/   update outer state with key to key size\n\/\/   digest outer state into digest pad at digest size\n\/\/\n\/\/ The C code that follows the key init sets all remaining bytes,\n\/\/ up to block size, to 0x36, and xors the other bytes with 0x36.\n\/\/ This is equivalent to setting upper bytes (i.e. up to block size)\n\/\/ to zero in key init, and then xoring everything with 0x36.\n\/\/\n\/\/ We don't care about 'xor_pad' and 'outer', so we should be able to\n\/\/ just ignore them. But for now we just compute them anyway.\nkey_init_c_state : { key_size, block_size, digest_size }\n        ( fin key_size, fin block_size,\n          SHA512_DIGEST_LENGTH >= digest_size )\n     => SHA512_c_state\n     -> [SHA512_DIGEST_LENGTH][8]\n     -> [key_size][8]\n     -> (SHA512_c_state, [SHA512_DIGEST_LENGTH][8], [block_size][8])\nkey_init_c_state outer0 digest_pad0 key =\n  if `key_size > (`block_size : [max (width key_size) (width block_size)])\n  then (outer2, digest_pad1, hash')\n  else (outer1, digest_pad0, key')\n  where\n  outer1 = hash_init_c_state outer0\n\n  \/\/ Long key.\n  outer2 = hash_update_c_state outer1 key\n  hash : [digest_size][8]\n  hash = hash_digest_c_state outer2\n  digest_pad1 = hash # drop `{digest_size} digest_pad0\n  hash' = take `{block_size} (hash # (zero : [block_size][8]))\n\n  \/\/ Short key.\n  key' = take `{block_size} (key # (zero : [block_size][8]))\n\nkey_init_c_state_unbounded : { block_size, digest_size }\n        ( 16 >= width block_size, SHA512_DIGEST_LENGTH >= digest_size )\n     => SHA512_c_state\n     -> [SHA512_DIGEST_LENGTH][8]\n     -> ByteArray\n     -> [32]\n     -> (SHA512_c_state, [SHA512_DIGEST_LENGTH][8], [block_size][8])\nkey_init_c_state_unbounded outer0 digest_pad0 key klen =\n  if klen > (`block_size : [32])\n  then (outer2, digest_pad1, hash')\n  else (outer1, digest_pad0, key')\n  where\n  outer1 = hash_init_c_state outer0\n\n  \/\/ Long key.\n  outer2 = hash_update_c_state_unbounded outer1 key klen\n  hash : [digest_size][8]\n  hash = hash_digest_c_state outer2\n  digest_pad1 = hash # drop `{digest_size} digest_pad0\n  hash' = take `{block_size} (hash # (zero : [block_size][8]))\n\n  \/\/ Short key.\n  key' = map\n    (\\i -> if (i <$ (0 # klen)) then (arrayLookup key i) else 0)\n    (take`{block_size} [0 .. block_size])\n\nhmac_init_c_state :\n     { key_size, block_size, hash_block_size, digest_size }\n     ( fin key_size\n     , 64 >= width (8*key_size)\n     , 16 >= width hash_block_size\n     , 16 >= width block_size\n     , 8 >= width digest_size\n     , 128 >= block_size\n     , 64 >= digest_size )\n  => HMAC_c_state\n  -> [32]\n  -> [key_size][8]\n  -> HMAC_c_state\nhmac_init_c_state st0 alg key =\n  { alg                     = alg\n  , hash_block_size         = `hash_block_size\n  , currently_in_hash_block = currently_in_hash_block\n  , block_size              = `block_size\n  , digest_size             = `digest_size\n\n  , inner                   = inner\n  , inner_just_key          = inner_just_key\n  , outer                   = outer\n  , outer_just_key          = outer_just_key\n  , xor_pad                 = xor_pad\n  , digest_pad              = digest_pad\n  }\n  where\n    currently_in_hash_block = 0\n\n    k0 : [block_size][8]\n    (outer, digest_pad, k0) =\n      key_init_c_state `{digest_size=digest_size} st0.outer st0.digest_pad key\n    ikey = [ k ^ 0x36 | k <- k0 ]\n    okey = [ k ^ 0x6a | k <- ikey ]\n\n    inner_just_key = hash_update_c_state\n      (hash_init_c_state st0.inner_just_key) ikey\n    inner          = inner_just_key\n    outer_just_key = hash_update_c_state\n      (hash_init_c_state st0.outer_just_key) okey\n    xor_pad = zero hmac_init_c_state_unbounded :\n     { block_size, hash_block_size, digest_size }\n     ( 16 >= width hash_block_size\n     , 16 >= width block_size\n     , 8 >= width digest_size\n     , 128 >= block_size\n     , 64 >= digest_size )\n  => HMAC_c_state\n  -> [32]\n  -> ByteArray\n  -> [32]\n  -> HMAC_c_state\nhmac_init_c_state_unbounded st0 alg key klen =\n  { alg                     = alg\n  , hash_block_size         = `hash_block_size\n  , currently_in_hash_block = currently_in_hash_block\n  , block_size              = `block_size\n  , digest_size             = `digest_size\n\n  , inner                   = inner\n  , inner_just_key          = inner_just_key\n  , outer                   = outer\n  , outer_just_key          = outer_just_key\n  , xor_pad                 = xor_pad\n  , digest_pad              = digest_pad\n  }\n  where\n    currently_in_hash_block = 0\n\n    k0 : [block_size][8]\n    (outer, digest_pad, k0) =\n      key_init_c_state_unbounded `{digest_size=digest_size}\n        st0.outer st0.digest_pad key klen\n    ikey = [ k ^ 0x36 | k <- k0 ]\n    okey = [ k ^ 0x6a | k <- ikey ]\n\n    inner_just_key = hash_update_c_state\n      (hash_init_c_state st0.inner_just_key) ikey\n    inner          = inner_just_key\n    outer_just_key = hash_update_c_state\n      (hash_init_c_state st0.outer_just_key) okey\n    xor_pad = zero hmac_update_c_state : {msg_size} (32 >= width msg_size) =>\n  HMAC_c_state -> [msg_size][8] -> HMAC_c_state\nhmac_update_c_state s m =\n  { inner = hash_update_c_state s.inner m\n  , currently_in_hash_block =\n      (s.currently_in_hash_block + (`msg_size % (zero # s.hash_block_size))) %\n      (zero # s.block_size)\n\n    , alg             = s.alg\n  , hash_block_size = s.hash_block_size\n  , block_size      = s.block_size\n  , digest_size     = s.digest_size\n  , inner_just_key  = s.inner_just_key\n  , outer           = s.outer\n  , outer_just_key  = s.outer_just_key\n  , xor_pad         = s.xor_pad\n  , digest_pad      = s.digest_pad\n  }\n\nhmac_update_c_state_unbounded :\n  HMAC_c_state -> ByteArray -> [32] -> HMAC_c_state\nhmac_update_c_state_unbounded s m sz =\n  { inner = hash_update_c_state_unbounded s.inner m sz\n  , currently_in_hash_block =\n      (s.currently_in_hash_block + (sz % (zero # s.hash_block_size))) %\n      (zero # s.block_size)\n\n    , alg             = s.alg\n  , hash_block_size = s.hash_block_size\n  , block_size      = s.block_size\n  , digest_size     = s.digest_size\n  , inner_just_key  = s.inner_just_key\n  , outer           = s.outer\n  , outer_just_key  = s.outer_just_key\n  , xor_pad         = s.xor_pad\n  , digest_pad      = s.digest_pad\n  }\n\n\n\/\/ TODO: What about `size` argument to `s2n_hmac_digest`? The `size`\n\/\/ argument is supposed to be the \"digest length\" of the underlying\n\/\/ hash. Here we are specializing to SHA256, so `size` would be 32.\nhmac_digest_c_state :\n     { block_size, digest_size }\n     ( 64 >= digest_size\n     , 128 >= block_size )\n  => HMAC_c_state -> (HMAC_c_state, [8 * digest_size])\nhmac_digest_c_state s = (sout, out)\n  where\n    hin : [digest_size][8]\n    hin = hash_digest_c_state inner\n    digest_pad : [SHA512_DIGEST_LENGTH][8]\n    digest_pad = hin # zero\n\n    okey : [block_size][8]\n    okey = take s.xor_pad\n\n    \/\/ The `inner` and `outer` here are probably not accurate:\n    \/\/ in s2n, the `s2n_hash_digest` has been called on them, which\n    \/\/ presumably can change them (calls `SHA256_Final` from\n    \/\/ underlying C crypto lib behind the scenes). However, our\n    \/\/ Cryptol `SHA256Final` does not change the hash state. Even\n    \/\/ if we leave the hash function uninterpreted later, we will\n    \/\/ still need to change the interface of our Cryptol `<hash>Final`\n    \/\/ to additionally return an updated `<hash>State`.\n    \/\/\n    \/\/ However, we probably don't need to say anything about the\n    \/\/ *hash* state after calls to \"final\" functions, since\n    \/\/ 's2n_hash_reset' just calls 's2n_hash_init'. So, the above\n    \/\/ concern is not much of a concern after all.\n\n    \/\/ Our goal is to leave the hash functions (init, update,\n    \/\/ digest\/final) uninterpreted, and so we need the structure of\n    \/\/ our calls to these functions to match the structure of calls in\n    \/\/ the s2n code, since we don't have lemmas giving algebraic\n    \/\/ properties of these functions (e.g. here we'd need\n    \/\/\n    \/\/   update (update st x) y == update st (x # y)\n    \/\/\n    \/\/ ). So, we replace\n    \/\/\n    \/\/outer = SHA256Update SHA256Init (okey # hin)\n    \/\/\n    \/\/ with:\n    outer = hash_update_c_state s.outer_just_key hin\n    inner = s.inner\n\n    out = join (hash_digest_c_state outer)\n\n    sout : HMAC_c_state\n    sout =\n      { inner      = inner\n      , outer      = s.outer_just_key\n      , digest_pad = digest_pad\n\n            , alg                     = s.alg\n      , hash_block_size         = s.hash_block_size\n      , currently_in_hash_block = s.currently_in_hash_block\n      , block_size              = s.block_size\n      , digest_size             = s.digest_size\n      , inner_just_key          = s.inner_just_key\n      , outer_just_key          = s.outer_just_key\n      , xor_pad                 = s.xor_pad\n      }\n```"}]}
{"filename":"saw-script\/exercises\/sha512\/SHA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification script that proves the equivalence between the functional SHA specification `sha` and the imperative implementation `SHAImp` defined in the SHA.cry Cryptol module. The proof should show that for any input message, both implementations produce the same digest output according to the SHA-2 standard."},{"role":"assistant","content":"```cryptol\nmodule SHA where\n\nsha : {L} (2 * w >= width L) => [L] -> [digest_size]\nsha M = take (join (SHA_2_Common' [ split x | x <- parse`{num_blocks L} (pad`{L} M) ]))\n\nparameter\n\n  \/** Word size\n    Specifications are based on word size w, rather than digest size (8 * w)\n    or block size (m == 16 * w), in order to avoid confusing Cryptol's type\n    constraint verifier with integer division.\n  *\/\n\n  type w : #\n  type constraint (fin w, w >= 2, 32 >= width w)\n\n  type digest_size : #\n  type constraint (fin digest_size, 8*w >= digest_size)\n\n  \/** The number of iterations in the hash computation\n  (i.e. the number of words in K) *\/\n\n  type j : #\n  type constraint (fin j, j >= 17)\n\n  H0 : [8][w]\n  K  : [j][w]\n\n  \/* FIPS 180-4 defines lowercase and uppercase\n      (respective to the Greek alphabet) sigma functions for SHA-256 and SHA-512.\n      (4.4)-(4.7) SHA-224, SHA-256 (w==32)\n      (4.10)-(4.13) SHA-384, SHA-512, SHA-512\/224, SHA-512\/256 (w==64) *\/\n\n  SIGMA_0 : [w] -> [w]\n  SIGMA_1 : [w] -> [w]\n  sigma_0 : [w] -> [w]\n  sigma_1 : [w] -> [w]\n\n\/\/ Export some of the parameters\nSHAH0 = H0\nS0 = SIGMA_0\nS1 = SIGMA_1\ns0 = sigma_0\ns1 = sigma_1\n\n\/\/ Export Ch, Maj and the block function to be used in SAW proofs\n\/** (4.1) (w==32), (4.2) (w==32), (4.8) (w==64) *\/\nCh : [w] -> [w] -> [w] -> [w]\nCh x y z = (x && y) ^ (~x && z)\n\n\n\/** (4.1) (w==32), (4.3) (w==32), (4.9) (w==64) *\/\nMaj : [w] -> [w] -> [w] -> [w]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nprocessBlock_Common : [8][w] -> [16][w] -> [8][w]\nprocessBlock_Common H Mi = compress_Common H (messageSchedule_Common Mi)\n\n\nprivate\n\n  \/** block size corresponding to word size for all SHA algorithms in\n      FIPS 180-4 *\/\n  type block_size = 16 * w\n\n  type num_blocks L     = (L+1+2*w) \/^ block_size\n  type padded_size L    = num_blocks L * block_size\n\n\n  \/**\n    5.1 Padding the Message\n    5.1.1 SHA-1, SHA-224 and SHA-256 (w==32)\n    5.1.2 SHA-384, SHA-512, SHA-512\/224 and SHA-512\/256 (w==64)\n\n  The constraint ensure that the message size, `L`, fits within a\n  (2 * w)-bit word (consistent w\/ Figure 1)\n  *\/\n  pad : {L} (2 * w >= width L) => [L] -> [padded_size L]\n  pad M = M # 0b1 # zero # (`L : [2*w])\n\n  \/**\n    5.2 Parsing the Message\n    5.2.1 SHA-1, SHA-224 and SHA-256 (w==32)\n    5.2.2 SHA-384, SHA-512, SHA-512\/224 and SHA-512\/256 (w==64)\n  *\/\n  parse : {m} [m * block_size] -> [m][block_size]\n  parse = split\n\n  \/**\n  SHA-256 and SHA-512 (and their respective derivatives) use a similar\n  message schedule that can be expressed in the same way relative to their\n  respective sigma functions.\n\n    6.2.2 SHA-256 Hash Computation (w==32, j=64)\n    6.4.2 SHA-512 Hash Computation (w==64, j=80)\n  *\/\n  messageSchedule_Common : [16][w] -> [j][w]\n  messageSchedule_Common Mi = take W\n    where\n    W : [inf][_]\n    W = Mi # [ w1 + s0 w2 + w3 + s1 w4\n             | w1 <- W\n             | w2 <- drop`{1} W\n             | w3 <- drop`{9} W\n             | w4 <- drop`{14} W\n             ]\n\n\n  \/**\n  Amazon S2N's SHA-256 specification includes a compression routine intended\n  to reflect typical implementations.  This same compression routine applies\n  to SHA-512, modulo respective constants, sigma functions,\n  and message schedules.\n  *\/\n\n  compress_Common : [8][w] -> [j][w] -> [8][w]\n  compress_Common H W =\n        [ (as ! 0) + (H @ 0),\n      (bs ! 0) + (H @ 1),\n      (cs ! 0) + (H @ 2),\n      (ds ! 0) + (H @ 3),\n      (es ! 0) + (H @ 4),\n      (fs ! 0) + (H @ 5),\n      (gs ! 0) + (H @ 6),\n      (hs ! 0) + (H @ 7)\n    ]\n    where\n      T1 = [h + S1 e + Ch e f g + k_t + w_t\n                | h <- hs | e <- es | f <- fs | g <- gs | k_t <- K | w_t <- W]\n      T2 = [ S0 a + Maj a b c | a <- as | b <- bs | c <- cs]\n      hs = take`{j + 1}([H @ 7] # gs)\n      gs = take`{j + 1}([H @ 6] # fs)\n      fs = take`{j + 1}([H @ 5] # es)\n      es = take`{j + 1}([H @ 4] # [d + t1 | d <- ds | t1 <- T1])\n      ds = take`{j + 1}([H @ 3] # cs)\n      cs = take`{j + 1}([H @ 2] # bs)\n      bs = take`{j + 1}([H @ 1] # as)\n      as = take`{j + 1}([H @ 0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\n\n  SHA_2_Common' : {L} (fin L) => [L][16][w] -> [8][w]\n  SHA_2_Common' blocks = hash ! 0\n    where\n    hash = [H0] # [ processBlock_Common h b | h <- hash | b <- blocks]\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ SHA imperative specification\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/*\n * This section contains an SHA specification that more closely matches the\n * BoringSSL C implementation to simplify SAW correctness proofs of the\n * implementation.\n *\/\n\n\/\/\/\/\/\/\/\/ Imperative top level \/\/\/\/\/\/\/\/\n\ntype SHAState = { h : [8][w]\n                , block : [w * 2][8]\n                , n : [32]\n                , sz : [w * 2]\n                }\n\n\/\/ Initial state for SHA\nSHAInit : SHAState\nSHAInit = { h = H0\n          , block = zero\n          , n = 0\n          , sz = 0\n          }\n\n\/\/ Process message being hashed, iteratively updating the SHA state with the\n\/\/ input message.\nSHAUpdate : {n} (fin n) => SHAState -> [n][8] -> SHAState\nSHAUpdate sinit bs = ss!0\n  where ss = [sinit] # [ SHAUpdate1 s b | s <- ss | b <- bs ]\n\n\/\/ Add padding and size and process the final block.\nSHAFinal : SHAState -> [digest_size]\nSHAFinal s = take (join (processBlock_Common h b'))\n  \/\/ Because the message is always made up of bytes, and the size is a\n  \/\/ fixed number of bytes, the 1 pad will always be at least a byte.\n  where s' = SHAUpdate1 s 0x80\n        \/\/ Don't need to add zeros. They're already there. Just update\n        \/\/ the count of bytes in this block. After adding the 1 pad, there\n        \/\/ are two possible cases: the size will fit in the current block,\n        \/\/ or it won't.\n        (h, b) = if s'.n <= (`w*2 - (`w\/4)) then (s'.h, s'.block)\n                 else (processBlock_Common s'.h (split (join s'.block)), zero)\n        b' = split (join b || (zero # s.sz))\n\n\/\/ Imperative SHA implementation\nSHAImp : {n} (fin n) => [n][8] -> [digest_size]\nSHAImp msg = SHAFinal (SHAUpdate SHAInit msg)\n\n\nprivate\n\n  \/\/ SHAUpdate1 updates a single byte at position s.n in s.block and return a\n  \/\/ new state to pass to subsequent updates.  If s.n is 128, updates position 0\n  \/\/ to b and zeros the remainder of the block, setting s.n to 1 for the next\n  \/\/ update.\n  SHAUpdate1 : SHAState -> [8] -> SHAState\n  SHAUpdate1 s b =\n    if s.n == (2 * `w - 1)\n      then { h = processBlock_Common s.h (split (join (update s.block s.n b)))\n           , block = zero\n           , n = 0\n           , sz = s.sz + 8\n           }\n      else { h = s.h\n           , block = update s.block s.n b\n           , n = s.n + 1\n           , sz = s.sz + 8\n           }\n```"}]}
{"filename":"saw-script\/exercises\/sha512\/solution.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness using the LLVM backend that verifies the functions defined in sha512.c against their specifications in SHA512.cry. Define let-bound specs for the following C functions with their exact signatures: int SHA512_Init(struct sha512_state_st *sha), int SHA512_Update(struct sha512_state_st *c, const void *in_data, size_t len), int SHA512_Final(uint8_t out[64], struct sha512_state_st *sha), and uint8_t *SHA512(const uint8_t *data, size_t len, uint8_t out[64]). Use llvm_fresh_var to create symbolic inputs for pointers and lengths, and add minimal preconditions to ensure safety (e.g., valid pointers, array sizes). Call llvm_execute_func with the appropriate arguments referencing these functions. Ensure postconditions relate the C state to the corresponding Cryptol specifications (e.g., SHAUpdate, SHAFinal, SHAImp) and verify the functions using llvm_verify with these specs.\n\n# Source code:\nsha512.c\n```C\n\/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n * All rights reserved.\n *\n * This package is an SSL implementation written\n * by Eric Young (eay@cryptsoft.com).\n * The implementation was written so as to conform with Netscapes SSL.\n *\n * This library is free for commercial and non-commercial use as long as\n * the following conditions are aheared to.  The following conditions\n * apply to all code found in this distribution, be it the RC4, RSA,\n * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n * included with this distribution is covered by the same copyright terms\n * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n *\n * Copyright remains Eric Young's, and as such any Copyright notices in\n * the code are not to be removed.\n * If this package is used in a product, Eric Young should be given attribution\n * as the author of the parts of the library used.\n * This can be in the form of a textual message at program startup or\n * in documentation (online or textual) provided with the package.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and\/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *    \"This product includes cryptographic software written by\n *     Eric Young (eay@cryptsoft.com)\"\n *    The word 'cryptographic' can be left out if the rouines from the library\n *    being used are not cryptographic related :-).\n * 4. If you include any Windows specific code (or a derivative thereof) from\n *    the apps directory (application code) you must include an acknowledgement:\n *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n *\n * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * The licence and distribution terms for any publically available version or\n * derivative of this code cannot be changed.  i.e. this code cannot simply be\n * copied and put under another distribution licence\n * [including the GNU Public Licence.] *\/\n\n#include <assert.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"sha512.h\"\n\n\nstatic inline uint16_t CRYPTO_bswap2(uint16_t x) {\n  return (x >> 8) | (x << 8);\n}\n\nstatic inline uint32_t CRYPTO_bswap4(uint32_t x) {\n  x = (x >> 16) | (x << 16);\n  x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);\n  return x;\n}\n\nstatic inline uint64_t CRYPTO_bswap8(uint64_t x) {\n  return CRYPTO_bswap4(x >> 32) | (((uint64_t)CRYPTO_bswap4(x)) << 32);\n}\n\nstatic inline uint64_t CRYPTO_load_u64_be(const void *ptr) {\n  uint64_t ret;\n  memcpy(&ret, ptr, sizeof(ret));\n  return CRYPTO_bswap8(ret);\n}\n\nstatic inline void CRYPTO_store_u64_be(void *out, uint64_t v) {\n  v = CRYPTO_bswap8(v);\n  memcpy(out, &v, sizeof(v));\n}\n\nstatic inline uint64_t CRYPTO_rotr_u64(uint64_t value, int shift) {\n  return (value >> shift) | (value << ((-shift) & 63));\n}\n\n\nint SHA512_Init(SHA512_CTX *sha) {\n  sha->h[0] = UINT64_C(0x6a09e667f3bcc908);\n  sha->h[1] = UINT64_C(0xbb67ae8584caa73b);\n  sha->h[2] = UINT64_C(0x3c6ef372fe94f82b);\n  sha->h[3] = UINT64_C(0xa54ff53a5f1d36f1);\n  sha->h[4] = UINT64_C(0x510e527fade682d1);\n  sha->h[5] = UINT64_C(0x9b05688c2b3e6c1f);\n  sha->h[6] = UINT64_C(0x1f83d9abfb41bd6b);\n  sha->h[7] = UINT64_C(0x5be0cd19137e2179);\n\n  sha->Nl = 0;\n  sha->Nh = 0;\n  sha->num = 0;\n  sha->md_len = SHA512_DIGEST_LENGTH;\n  return 1;\n}\n\nstatic void sha512_block_data_order(uint64_t *state, const uint8_t *in,\n                                    size_t num_blocks);\n\nint SHA512_Update(SHA512_CTX *c, const void *in_data, size_t len) {\n  uint64_t l;\n  uint8_t *p = c->p;\n  const uint8_t *data = in_data;\n\n  if (len == 0) {\n    return 1;\n  }\n\n  l = (c->Nl + (((uint64_t)len) << 3)) & UINT64_C(0xffffffffffffffff);\n  if (l < c->Nl) {\n    c->Nh++;\n  }\n  if (sizeof(len) >= 8) {\n    c->Nh += (((uint64_t)len) >> 61);\n  }\n  c->Nl = l;\n\n  if (c->num != 0) {\n    size_t n = sizeof(c->p) - c->num;\n\n    if (len < n) {\n      memcpy(p + c->num, data, len);\n      c->num += (unsigned int)len;\n      return 1;\n    } else {\n      memcpy(p + c->num, data, n), c->num = 0;\n      len -= n;\n      data += n;\n      sha512_block_data_order(c->h, p, 1);\n    }\n  }\n\n  if (len >= sizeof(c->p)) {\n    sha512_block_data_order(c->h, data, len \/ sizeof(c->p));\n    data += len;\n    len %= sizeof(c->p);\n    data -= len;\n  }\n\n  if (len != 0) {\n    memcpy(p, data, len);\n    c->num = (int)len;\n  }\n\n  return 1;\n}\n\nint SHA512_Final(uint8_t out[SHA512_DIGEST_LENGTH], SHA512_CTX *sha) {\n  assert(sha->md_len == SHA512_DIGEST_LENGTH);\n  uint8_t *p = sha->p;\n  size_t n = sha->num;\n\n  p[n] = 0x80;  \/\/ There always is a room for one\n  n++;\n  if (n > (sizeof(sha->p) - 16)) {\n    memset(p + n, 0, sizeof(sha->p) - n);\n    n = 0;\n    sha512_block_data_order(sha->h, p, 1);\n  }\n\n  memset(p + n, 0, sizeof(sha->p) - 16 - n);\n  CRYPTO_store_u64_be(p + sizeof(sha->p) - 16, sha->Nh);\n  CRYPTO_store_u64_be(p + sizeof(sha->p) - 8, sha->Nl);\n\n  sha512_block_data_order(sha->h, p, 1);\n\n  if (out == NULL) {\n    \/\/ TODO(davidben): This NULL check is absent in other low-level hash 'final'\n    \/\/ functions and is one of the few places one can fail.\n    return 0;\n  }\n\n  assert(sha->md_len % 8 == 0);\n  const size_t out_words = sha->md_len \/ 8;\n  for (size_t i = 0; i < out_words; i++) {\n    CRYPTO_store_u64_be(out, sha->h[i]);\n    out += 8;\n  }\n\n  return 1;\n}\n\nuint8_t *SHA512(const uint8_t *data, size_t len,\n                uint8_t out[SHA512_DIGEST_LENGTH]) {\n  SHA512_CTX ctx;\n  const int ok = SHA512_Init(&ctx) &&\n                 SHA512_Update(&ctx, data, len) &&\n                 SHA512_Final(out, &ctx);\n  memset(&ctx, 0, sizeof(ctx));\n  return out;\n}\n\n\nstatic const uint64_t K512[80] = {\n    UINT64_C(0x428a2f98d728ae22), UINT64_C(0x7137449123ef65cd),\n    UINT64_C(0xb5c0fbcfec4d3b2f), UINT64_C(0xe9b5dba58189dbbc),\n    UINT64_C(0x3956c25bf348b538), UINT64_C(0x59f111f1b605d019),\n    UINT64_C(0x923f82a4af194f9b), UINT64_C(0xab1c5ed5da6d8118),\n    UINT64_C(0xd807aa98a3030242), UINT64_C(0x12835b0145706fbe),\n    UINT64_C(0x243185be4ee4b28c), UINT64_C(0x550c7dc3d5ffb4e2),\n    UINT64_C(0x72be5d74f27b896f), UINT64_C(0x80deb1fe3b1696b1),\n    UINT64_C(0x9bdc06a725c71235), UINT64_C(0xc19bf174cf692694),\n    UINT64_C(0xe49b69c19ef14ad2), UINT64_C(0xefbe4786384f25e3),\n    UINT64_C(0x0fc19dc68b8cd5b5), UINT64_C(0x240ca1cc77ac9c65),\n    UINT64_C(0x2de92c6f592b0275), UINT64_C(0x4a7484aa6ea6e483),\n    UINT64_C(0x5cb0a9dcbd41fbd4), UINT64_C(0x76f988da831153b5),\n    UINT64_C(0x983e5152ee66dfab), UINT64_C(0xa831c66d2db43210),\n    UINT64_C(0xb00327c898fb213f), UINT64_C(0xbf597fc7beef0ee4),\n    UINT64_C(0xc6e00bf33da88fc2), UINT64_C(0xd5a79147930aa725),\n    UINT64_C(0x06ca6351e003826f), UINT64_C(0x142929670a0e6e70),\n    UINT64_C(0x27b70a8546d22ffc), UINT64_C(0x2e1b21385c26c926),\n    UINT64_C(0x4d2c6dfc5ac42aed), UINT64_C(0x53380d139d95b3df),\n    UINT64_C(0x650a73548baf63de), UINT64_C(0x766a0abb3c77b2a8),\n    UINT64_C(0x81c2c92e47edaee6), UINT64_C(0x92722c851482353b),\n    UINT64_C(0xa2bfe8a14cf10364), UINT64_C(0xa81a664bbc423001),\n    UINT64_C(0xc24b8b70d0f89791), UINT64_C(0xc76c51a30654be30),\n    UINT64_C(0xd192e819d6ef5218), UINT64_C(0xd69906245565a910),\n    UINT64_C(0xf40e35855771202a), UINT64_C(0x106aa07032bbd1b8),\n    UINT64_C(0x19a4c116b8d2d0c8), UINT64_C(0x1e376c085141ab53),\n    UINT64_C(0x2748774cdf8eeb99), UINT64_C(0x34b0bcb5e19b48a8),\n    UINT64_C(0x391c0cb3c5c95a63), UINT64_C(0x4ed8aa4ae3418acb),\n    UINT64_C(0x5b9cca4f7763e373), UINT64_C(0x682e6ff3d6b2b8a3),\n    UINT64_C(0x748f82ee5defb2fc), UINT64_C(0x78a5636f43172f60),\n    UINT64_C(0x84c87814a1f0ab72), UINT64_C(0x8cc702081a6439ec),\n    UINT64_C(0x90befffa23631e28), UINT64_C(0xa4506cebde82bde9),\n    UINT64_C(0xbef9a3f7b2c67915), UINT64_C(0xc67178f2e372532b),\n    UINT64_C(0xca273eceea26619c), UINT64_C(0xd186b8c721c0c207),\n    UINT64_C(0xeada7dd6cde0eb1e), UINT64_C(0xf57d4f7fee6ed178),\n    UINT64_C(0x06f067aa72176fba), UINT64_C(0x0a637dc5a2c898a6),\n    UINT64_C(0x113f9804bef90dae), UINT64_C(0x1b710b35131c471b),\n    UINT64_C(0x28db77f523047d84), UINT64_C(0x32caab7b40c72493),\n    UINT64_C(0x3c9ebe0a15c9bebc), UINT64_C(0x431d67c49c100d4c),\n    UINT64_C(0x4cc5d4becb3e42b6), UINT64_C(0x597f299cfc657e2a),\n    UINT64_C(0x5fcb6fab3ad6faec), UINT64_C(0x6c44198c4a475817),\n};\n\nstatic inline uint64_t Sigma0(uint64_t x) {\n    return CRYPTO_rotr_u64((x), 28) ^ CRYPTO_rotr_u64((x), 34) ^\n        CRYPTO_rotr_u64((x), 39);\n}\n\nstatic inline uint64_t Sigma1(uint64_t x) {\n    return CRYPTO_rotr_u64((x), 14) ^ CRYPTO_rotr_u64((x), 18) ^\n        CRYPTO_rotr_u64((x), 41);\n}\n\nstatic inline uint64_t sigma0(uint64_t x) {\n    return CRYPTO_rotr_u64((x), 1) ^ CRYPTO_rotr_u64((x), 8) ^ ((x) >> 7);\n}\n\nstatic inline uint64_t sigma1(uint64_t x) {\n    return CRYPTO_rotr_u64((x), 19) ^ CRYPTO_rotr_u64((x), 61) ^ ((x) >> 6);\n}\n\nstatic inline uint64_t Ch(uint64_t x, uint64_t y, uint64_t z) {\n    return ((x) & (y)) ^ ((~(x)) & (z));\n}\n\n#define Maj(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))\n\n#define ROUND_00_15(i, a, b, c, d, e, f, g, h)   \\\n  do {                                           \\\n    T1 += h + Sigma1(e) + Ch(e, f, g) + K512[i]; \\\n    h = Sigma0(a) + Maj(a, b, c);                \\\n    d += T1;                                     \\\n    h += T1;                                     \\\n  } while (0)\n\n#define ROUND_16_80(i, j, a, b, c, d, e, f, g, h, X)   \\\n  do {                                                 \\\n    s0 = X[(j + 1) & 0x0f];                            \\\n    s0 = sigma0(s0);                                   \\\n    s1 = X[(j + 14) & 0x0f];                           \\\n    s1 = sigma1(s1);                                   \\\n    T1 = X[(j) & 0x0f] += s0 + s1 + X[(j + 9) & 0x0f]; \\\n    ROUND_00_15(i + j, a, b, c, d, e, f, g, h);        \\\n  } while (0)\n\nstatic void sha512_block_data_order(uint64_t *state, const uint8_t *in,\n                                    size_t num) {\n  uint64_t a, b, c, d, e, f, g, h, s0, s1, T1;\n  uint64_t X[16];\n  int i;\n\n  while (num--) {\n\n    a = state[0];\n    b = state[1];\n    c = state[2];\n    d = state[3];\n    e = state[4];\n    f = state[5];\n    g = state[6];\n    h = state[7];\n\n    T1 = X[0] = CRYPTO_load_u64_be(in);\n    ROUND_00_15(0, a, b, c, d, e, f, g, h);\n    T1 = X[1] = CRYPTO_load_u64_be(in + 8);\n    ROUND_00_15(1, h, a, b, c, d, e, f, g);\n    T1 = X[2] = CRYPTO_load_u64_be(in + 2 * 8);\n    ROUND_00_15(2, g, h, a, b, c, d, e, f);\n    T1 = X[3] = CRYPTO_load_u64_be(in + 3 * 8);\n    ROUND_00_15(3, f, g, h, a, b, c, d, e);\n    T1 = X[4] = CRYPTO_load_u64_be(in + 4 * 8);\n    ROUND_00_15(4, e, f, g, h, a, b, c, d);\n    T1 = X[5] = CRYPTO_load_u64_be(in + 5 * 8);\n    ROUND_00_15(5, d, e, f, g, h, a, b, c);\n    T1 = X[6] = CRYPTO_load_u64_be(in + 6 * 8);\n    ROUND_00_15(6, c, d, e, f, g, h, a, b);\n    T1 = X[7] = CRYPTO_load_u64_be(in + 7 * 8);\n    ROUND_00_15(7, b, c, d, e, f, g, h, a);\n    T1 = X[8] = CRYPTO_load_u64_be(in + 8 * 8);\n    ROUND_00_15(8, a, b, c, d, e, f, g, h);\n    T1 = X[9] = CRYPTO_load_u64_be(in + 9 * 8);\n    ROUND_00_15(9, h, a, b, c, d, e, f, g);\n    T1 = X[10] = CRYPTO_load_u64_be(in + 10 * 8);\n    ROUND_00_15(10, g, h, a, b, c, d, e, f);\n    T1 = X[11] = CRYPTO_load_u64_be(in + 11 * 8);\n    ROUND_00_15(11, f, g, h, a, b, c, d, e);\n    T1 = X[12] = CRYPTO_load_u64_be(in + 12 * 8);\n    ROUND_00_15(12, e, f, g, h, a, b, c, d);\n    T1 = X[13] = CRYPTO_load_u64_be(in + 13 * 8);\n    ROUND_00_15(13, d, e, f, g, h, a, b, c);\n    T1 = X[14] = CRYPTO_load_u64_be(in + 14 * 8);\n    ROUND_00_15(14, c, d, e, f, g, h, a, b);\n    T1 = X[15] = CRYPTO_load_u64_be(in + 15 * 8);\n    ROUND_00_15(15, b, c, d, e, f, g, h, a);\n\n    for (i = 16; i < 80; i += 16) {\n      ROUND_16_80(i, 0, a, b, c, d, e, f, g, h, X);\n      ROUND_16_80(i, 1, h, a, b, c, d, e, f, g, X);\n      ROUND_16_80(i, 2, g, h, a, b, c, d, e, f, X);\n      ROUND_16_80(i, 3, f, g, h, a, b, c, d, e, X);\n      ROUND_16_80(i, 4, e, f, g, h, a, b, c, d, X);\n      ROUND_16_80(i, 5, d, e, f, g, h, a, b, c, X);\n      ROUND_16_80(i, 6, c, d, e, f, g, h, a, b, X);\n      ROUND_16_80(i, 7, b, c, d, e, f, g, h, a, X);\n      ROUND_16_80(i, 8, a, b, c, d, e, f, g, h, X);\n      ROUND_16_80(i, 9, h, a, b, c, d, e, f, g, X);\n      ROUND_16_80(i, 10, g, h, a, b, c, d, e, f, X);\n      ROUND_16_80(i, 11, f, g, h, a, b, c, d, e, X);\n      ROUND_16_80(i, 12, e, f, g, h, a, b, c, d, X);\n      ROUND_16_80(i, 13, d, e, f, g, h, a, b, c, X);\n      ROUND_16_80(i, 14, c, d, e, f, g, h, a, b, X);\n      ROUND_16_80(i, 15, b, c, d, e, f, g, h, a, X);\n    }\n\n    state[0] += a;\n    state[1] += b;\n    state[2] += c;\n    state[3] += d;\n    state[4] += e;\n    state[5] += f;\n    state[6] += g;\n    state[7] += h;\n\n    in += 16 * 8;\n  }\n}\n\n\n```"},{"role":"assistant","content":"```saw\nimport \"SHA512.cry\";\n\ninclude \"..\/common\/helpers.saw\";\n\n\n\/\/ Load LLVM bytecode\nm <- llvm_load_module \"sha512.bc\";\n\n\n\/*\n * SHA512 defines\n *\/\n\/\/ Size of a block in bytes\nlet SHA512_CBLOCK = 128;\n\n\/\/ Length of message digest in bytes\nlet SHA512_DIGEST_LENGTH = 64;\n\n\/\/ Size of the SHA512 context struct\nlet SHA512_CTX_SIZE = llvm_sizeof m (llvm_alias \"struct.sha512_state_st\");\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Specifications\n\n\/*\n * This section of the SAW script contains specifications of the functions that\n * SAW will verify.  Each specification can be broken down into 3 components:\n * preconditions, a function call description, and postconditions.\n *\n * A precondition is a predicate that must be true prior to the application of\n * a function for the specification's postcondition to hold.  Preconditions are\n * typically restrictions on function inputs or global state.  For example, a\n * function that returns the first element of an array might have a\n * precondition that the array is not empty.  A specification makes no\n * guarantees about how the function acts when the precondition is violated.\n * In a SAW specification, preconditions are the statements that come before a\n * function call description.  If a function has no preconditions we say that\n * the precondition is \"true\", meaning that the postcondition holds for all\n * possible inputs and program states.\n *\n * A function call description tells SAW how to call the function being\n * specified.  It has the form:\n *     llvm_execute_func [<list of arguments>]\n * These arguments are typically from the preconditions, specification inputs,\n * global variables, and literals.  SAW does not actually execute the function,\n * but rather uses symbolic execution to examine all possible executions\n * through the function, subject to precondition constraints.  For example,\n * if a precondition states that a variable `sha_ptr` is a pointer to an\n * `sha512_state_st` struct:\n *     ctx_ptr <- llvm_alloc (llvm_alias \"struct.sha512_state_st\");\n * And the function call description takes `sha_ptr` as an input:\n *     llvm_execute_func [sha_ptr];\n * Then SAW will reason about the function over all possible `sha512_state_st`\n * structs.  We call `sha_ptr` a symbol because SAW does not evaluate it, but\n * rather treats it as the set of all possible `sha512_state_st` structs.\n *\n * A postcondition is a predicate that must be true following the application\n * of a function, assuming the function's precondition held.  From a logic\n * perspective, you can think of this as:\n *     (<conjunction of preconditions> \/\\ <function application>) ->\n *     <conjunction of postconditions>\n * where \"\/\\\" is logical AND and \"->\" is logical implication.  If a SAW proof\n * succeeds, then SAW guarantees that the postconditions hold following function\n * application, so long as the function's preconditions held just prior to the\n * function's application.  In a SAW specification, postconditions are the\n * statements that come after a function call description.  If a function has\n * no postconditions, then we say that the postcondition is \"true\", meaning\n * that the specification makes no guarantees about the function's behavior.\n *\/\n\n\/*\n * Specifications of functions Sigma0, Sigma1, sigma0, sigma1, and Ch\n *\/\nlet Sigma0_spec = do {\n  x <- llvm_fresh_var \"x\" i64;\n  llvm_execute_func [llvm_term x];\n  llvm_return (llvm_term {{ S0 x }});\n};\n\nlet Sigma1_spec = do {\n  x <- llvm_fresh_var \"x\" i64;\n  llvm_execute_func [llvm_term x];\n  llvm_return (llvm_term {{ S1 x }});\n};\n\nlet sigma0_spec = do {\n  x <- llvm_fresh_var \"x\" i64;\n  llvm_execute_func [llvm_term x];\n  llvm_return (llvm_term {{ s0 x }});\n};\n\nlet sigma1_spec = do {\n  x <- llvm_fresh_var \"x\" i64;\n  llvm_execute_func [llvm_term x];\n  llvm_return (llvm_term {{ s1 x }});\n};\n\nlet Ch_spec = do {\n  x <- llvm_fresh_var \"x\" i64;\n  y <- llvm_fresh_var \"y\" i64;\n  z <- llvm_fresh_var \"z\" i64;\n  llvm_execute_func [llvm_term x, llvm_term y, llvm_term z];\n  llvm_return (llvm_term {{ Ch x y z }});\n};\n\n\/*\n * Specification of block function for SHA512\n *\/\nlet sha512_block_data_order_spec = do {\n  \/\/ Precondition: `state_ptr` points to an array of 8 64 bit integers\n  (state, state_ptr) <- ptr_to_fresh \"state\" (llvm_array 8 i64);\n\n  \/\/ Precondition: `data_ptr` points to a const message block\n  (data, data_ptr) <- ptr_to_fresh_readonly \"data\" (llvm_array SHA512_CBLOCK i8);\n\n  \/\/ Call function with `state_ptr`, `data_ptr`, and the value `1`\n  llvm_execute_func [state_ptr, data_ptr, llvm_term {{ 1 : [64] }}];\n\n  \/\/ Postcondition: The data pointed to by `state_ptr` is equivalent to the\n  \/\/ return value of the processBlock_Common Cryptol spec function applied to `state`\n  \/\/ and `data`.\n  llvm_points_to state_ptr (llvm_term {{ processBlock_Common state (split (join data)) }});\n};\n\n\n\/*\n * Helpers for specifying the SHA512 structs\n *\/\n\/*\n * The next functions all specify structs used in the C SHA implementation.\n * Most of the statements in these are of the form:\n *    llvm_points_to (llvm_field ptr \"name\") (llvm_term {{ term }})\n * which indicates that the field `name` of the struct pointed to by `ptr`\n * contains the value `term`.\n * All statements that do not match these two forms are documented inline\n *\/\n\n\/\/ Specify the sha512_state_st struct from a SHAState\nlet points_to_sha512_state_st_common ptr (h, sz, block, n) num = do {\n  llvm_points_to (llvm_field ptr \"h\") (llvm_term h);\n\n  \/\/ Specify `sha512_state_st.Nl` and `sha512_state_st.Nh` contain `sz`\n  llvm_points_to_at_type (llvm_field ptr \"Nl\") i128 (llvm_term sz);\n\n  if eval_bool {{ `num == 0 }} then do {\n    \/\/ Do not specify anything about `sha512_state_st.p`\n    return ();\n  } else do {\n    \/\/ Specify that the first `num` bytes of `sha512_state_st.p` match the\n    \/\/ first `num` bits of `state.block`.\n    \/\/ Untyped check because the size of `sha512_state_st.p` does not match\n    \/\/ the size of (take`{num} state.block) unless `num` == `SHA512_CBLOCK`\n    llvm_points_to_untyped (llvm_field ptr \"p\") (llvm_term block);\n  };\n\n  llvm_points_to (llvm_field ptr \"num\") (llvm_term n);\n  llvm_points_to (llvm_field ptr \"md_len\") (llvm_term {{ `SHA512_DIGEST_LENGTH : [32] }});\n};\n\nlet pointer_to_fresh_sha512_state_st name n = do {\n  \/\/ Hash value\n  h <- llvm_fresh_var (str_concat name \".h\") (llvm_array 8 i64);\n  \/\/ Message block\n  block <- if eval_bool {{ `n == 0 }} then do {\n    \/\/ Do not specify anything about `sha512_state_st.p`\n    return {{ [] : [0][8] }};\n  } else do {\n    llvm_fresh_var (str_concat name \".block\") (llvm_array n i8);\n  };\n  \/\/ Size\n  sz <- llvm_fresh_var (str_concat name \".sz\") i128;\n  \/\/ Build SHAState, padding `block` with zeros to fit\n  let state = {{ { h = h, block = (block # zero) : [SHA512_CBLOCK][8], n = `n : [32], sz = sz } }};\n\n  \/\/ `ptr` is a pointer to a `sha512_state_st` struct\n  ptr <- llvm_alloc (llvm_alias \"struct.sha512_state_st\");\n  points_to_sha512_state_st_common ptr (h, sz, block, {{ `n : [32]}}) n;\n\n  return (state, ptr);\n};\n\n\/\/ Specify the sha512_state_st struct from a SHAState\nlet points_to_sha512_state_st ptr state num = do {\n points_to_sha512_state_st_common\n   ptr\n   ({{ state.h }}, {{ state.sz }}, {{ take`{num} state.block }}, {{ state.n }}) num;\n};\n\n\n\/*\n * Specifications of SHA512_Init, SHA512_Update, SHA512_Final,\n * and SHA512.\n *\/\nlet SHA512_Init_spec = do {\n  \/\/ Precondition: `sha_ptr` is a pointer to a `sha512_state_st` struct\n  sha_ptr <- llvm_alloc (llvm_alias \"struct.sha512_state_st\");\n\n  \/\/ Call function with `sha_ptr`\n  llvm_execute_func [sha_ptr];\n\n  \/\/ Postcondition: `sha_ptr` holds an initialized SHA512 context\n  points_to_sha512_state_st\n    sha_ptr\n    {{ { h = SHAH0, block = zero : [SHA512_CBLOCK][8], n = 0 : [32], sz = 0 : [128] } }}\n    0;\n\n  \/\/ Postcondition: The function returns 1\n  llvm_return (llvm_term {{ 1 : [32] }});\n};\n\nlet SHA512_Update_spec num len = do {\n  \/\/ Precondition: `sha_ptr` is a pointer to a `sha512_state_st` struct\n  \/\/ Precondition: `sha512_ctx` is a fresh Cryptol SHAState\n  \/\/ Precondition: `sha_ptr` matches `sha512_ctx`.  The message blocks\n  \/\/ of the two must only match up to the first `num` bits.\n  (sha512_ctx, sha_ptr) <- pointer_to_fresh_sha512_state_st \"sha512_ctx\" num;\n\n  \/\/ Precondition: `data` is a fresh array of `len` bytes, and `data_ptr`\n  \/\/ points to `data`.\n  (data, data_ptr) <- ptr_to_fresh_readonly \"data\" (llvm_array len i8);\n\n  \/\/ Call function with `sha_ptr`, `data_ptr`, and `len` as arguments.\n  llvm_execute_func [sha_ptr, data_ptr, llvm_term {{ `len : [64] }}];\n\n  \/\/ Postcondition: The context `sha_ptr` points to matches the result\n  \/\/ of executing the cryptol function `SHAUpdate` on `sha512_ctx` and\n  \/\/ `data`, with the exception of the message block, which must only match up\n  \/\/ to the first `(num + len) % SHA512_CBLOCK` bytes.  This is because the\n  \/\/ C implementation does not clear the unused bytes of message block, and\n  \/\/ therefore the tail end of the block contains garbage.\n  points_to_sha512_state_st\n    sha_ptr\n    {{ SHAUpdate sha512_ctx data }} (eval_size {| (num + len) % SHA512_CBLOCK |});\n\n  \/\/ Postcondition: The function returns 1\n  llvm_return (llvm_term {{ 1 : [32] }});\n};\n\nlet SHA512_Final_spec num = do {\n  \/\/ Precondition: `out_ptr` is allocated and points to an array\n  \/\/ of `SHA512_DIGEST_LENGTH` bytes.\n  out_ptr <- llvm_alloc (llvm_array SHA512_DIGEST_LENGTH i8);\n\n  \/\/ Precondition: `sha_ptr` is a pointer to a `sha512_state_st` struct\n  \/\/ Precondition: `sha512_ctx` is a fresh Cryptol SHAState\n  \/\/ Precondition: `sha_ptr` matches `sha512_ctx`.  The message blocks\n  \/\/ of the two must only match up to the first `num` bits.\n  (sha512_ctx, sha_ptr) <- pointer_to_fresh_sha512_state_st \"sha512_ctx\" num;\n  \n  \/\/ Call function with `out_ptr`, and `sha_ptr`.\n  llvm_execute_func [out_ptr, sha_ptr];\n  \n  \/\/ Postcondition: The data pointed to by `out_ptr` matches the message\n  \/\/ digest returned by the Cryptol function `SHAFinal`.  The reverses,\n  \/\/ splits, and joins transform the Cryptol function's big endian output to\n  \/\/ little endian.\n  llvm_points_to out_ptr (llvm_term {{ split`{SHA512_DIGEST_LENGTH} (SHAFinal sha512_ctx) }});\n\n  \/\/ Postcondition: The function returns 1\n  llvm_return (llvm_term {{ 1 : [32] }});\n};\n\nlet SHA512_spec len = do {\n  \/\/ Precondition: `data` is a fresh const array of `len` bytes, and `data_ptr`\n  \/\/ points to `data`.\n  (data, data_ptr) <- ptr_to_fresh_readonly \"data\" (llvm_array len i8);\n\n  \/\/ Precondition: `out_ptr` is allocated and points to an array\n  \/\/ of `SHA512_DIGEST_LENGTH` bytes.\n  out_ptr <- llvm_alloc (llvm_array SHA512_DIGEST_LENGTH i8);\n    \n  \/\/ Call function with arguments data_ptr, len, and out_ptr.\n  llvm_execute_func\n    [ data_ptr\n    , llvm_term {{ `len : [64] }}\n    , out_ptr\n    ];\n  \n  \/\/ Postcondition: The data pointed to by `out_ptr` matches the message\n  \/\/ digest returned by the Cryptol function `SHAImp`.  The reverses,\n  \/\/ splits, and joins transform the Cryptol function's big endian output to\n  \/\/ little endian.\n  llvm_points_to out_ptr (llvm_term {{ split`{SHA512_DIGEST_LENGTH} (SHAImp data) }});\n\n    llvm_return out_ptr;\n};\n\n\n\/\/ Verify functions Sigma0, Sigma1, sigma0, sigma1, and Ch\n\/\/ satisfy their specifications\n\nSigma0_ov <- llvm_verify m \"Sigma0\"\n  []\n  true\n  Sigma0_spec\n  (w4_unint_z3 []);\n\nSigma1_ov <- llvm_verify m \"Sigma1\"\n  []\n  true\n  Sigma1_spec\n  (w4_unint_z3 []);\n\nsigma0_ov <- llvm_verify m \"sigma0\"\n  []\n  true\n  sigma0_spec\n  (w4_unint_z3 []);\n\nsigma1_ov <- llvm_verify m \"sigma1\"\n  []\n  true\n  sigma1_spec\n  (w4_unint_z3 []);\n\nCh_ov <- llvm_verify m \"Ch\"\n  []\n  true\n  Ch_spec\n  (w4_unint_z3 []);\n\n\/\/ Verify the block data function satisfies the bounded\n\/\/ `sha512_block_data_order_spec` specification\n\nsha512_block_data_order_ov <- llvm_verify m \"sha512_block_data_order\"\n  [Sigma0_ov, Sigma1_ov, sigma0_ov, sigma1_ov, Ch_ov]\n  true\n  sha512_block_data_order_spec\n  (w4_unint_z3 [\"S0\", \"S1\", \"s0\", \"s1\", \"Ch\"]);\n\n\n\/\/ Verify the `SHA512_Init` C function satisfies the `SHA512_Init_spec`\n\/\/ specification\nSHA512_Init_ov <- llvm_verify m \"SHA512_Init\"\n  []\n  true\n  SHA512_Init_spec\n  (w4_unint_z3 []);\n\n\n\/\/ Verify the `SHA512_Update` C function satisfies the\n\/\/ `SHA512_Update_spec` specification.\n\/\/ There are 3 cases to consider to ensure the proof covers all possible code\n\/\/ paths through the update function\n\nSHA512_Update_0_240_ov <- llvm_verify m \"SHA512_Update\"\n  [sha512_block_data_order_ov]\n  true\n  \/\/ num=0, len=240 covers the case with one call to the block function,\n  \/\/ on one block from data, and the rest of data copied in c->data\n  (SHA512_Update_spec 0 240)\n  (w4_unint_z3 [\"processBlock_Common\"]);\nSHA512_Update_0_127_ov <- llvm_verify m \"SHA512_Update\"\n  [sha512_block_data_order_ov]\n  true\n  \/\/ num=0, len=127 covers the case without any calls to the block function,\n  \/\/ and data copied in c->data\n  (SHA512_Update_spec 0 127)\n  (w4_unint_z3 [\"processBlock_Common\"]);\nSHA512_Update_127_241_ov <- llvm_verify m \"SHA512_Update\"\n  [sha512_block_data_order_ov]\n  true\n  \/\/ num=127, len=241 covers the case with two calls to the block function,\n  \/\/ the first one on c->data, the second one on one block from data,\n  \/\/ and the rest of data copied in c->data\n  (SHA512_Update_spec 127 241)\n  (w4_unint_z3 [\"processBlock_Common\"]);\n\n\n\/\/ Verify the `SHA512_Final` C function satisfies the\n\/\/ `SHA512_Final_spec` specification.\n\/\/ There are 2 cases to consider to ensure the proof covers all possible code\n\/\/ paths through the update function\n\nSHA512_Final_111_ov <- llvm_verify m \"SHA512_Final\"\n  [sha512_block_data_order_ov]\n  true\n  \/\/ num=111 covers the case with one call to the block function\n  (SHA512_Final_spec 111)\n  (w4_unint_z3 [\"processBlock_Common\"]);\nSHA512_Final_112_ov <- llvm_verify m \"SHA512_Final\"\n  [sha512_block_data_order_ov]\n  true\n  \/\/ num=112 covers the case with two calls to the block function\n  (SHA512_Final_spec 112)\n  (w4_unint_z3 [\"processBlock_Common\"]);\n\n\n\/\/ Verify the `SHA512` C function satisfies the `SHA512_spec`\n\/\/ specification\nllvm_verify m \"SHA512\"\n  [SHA512_Init_ov, SHA512_Update_0_240_ov, SHA512_Final_112_ov]\n  true\n  (SHA512_spec 240)\n  (w4_unint_z3 [\"processBlock_Common\"]);\n\n\nlet quick_check = true;\nlet target_num = 128;\n\nif quick_check then do {\n  return ();\n} else do {\n  \/\/ this covers the case with all lengths given a target_num.\n  print (str_concat \"Verifying SHA512_Update at target_num=\" (show target_num));\n  let verify_update_at_len len = do {\n    print (str_concat \"Verifying SHA512_Update at len=\" (show len));\n    llvm_verify m \"SHA512_Update\"\n        [sha512_block_data_order_ov]\n        true\n        (SHA512_Update_spec target_num len)\n        (w4_unint_z3 [\"processBlock_Common\"]);\n  };\n  \/\/ Given a fixed `num`, the `lens` cover all possible parameters especially below cases:\n  \/\/ When len = (SHA512_CBLOCK - 1), this covers the case without any calls to the block function, \n  \/\/   and data copied in c->data.\n  \/\/ When len = (SHA512_CBLOCK + 1), this covers the case with one call to the block function, \n  \/\/   on one block from data, and the rest of data copied in c->data.\n  \/\/ When len = (SHA512_CBLOCK + 1), this covers the case with two calls to the block function,\n  \/\/   the first one on c->data,  the second one on one block from data, and the rest of data copied in c->data.\n  \/\/ Note: when num = 0, 'len = 256' check fails due to 'sha512_block_data_order' limit.\n  if eval_bool {{ `target_num == 0 }} then do {\n    lens <- for (eval_list {{ [0 .. (2 * SHA512_CBLOCK - 1)] : [2 * SHA512_CBLOCK][64] }})\n      (\\x -> (return (eval_int x)) : (TopLevel Int));\n    for lens verify_update_at_len;\n  } else do {\n    lens <- for (eval_list {{ [0 .. (2 * SHA512_CBLOCK + 1 - target_num)] : [2 * SHA512_CBLOCK + 2 - target_num][64] }})\n      (\\x -> (return (eval_int x)) : (TopLevel Int));\n    for lens verify_update_at_len;\n  };\n  return ();\n};\n\n\/\/ range of valid indices in the internal block ([0 .. (SHA512_CBLOCK - 1)])\nnums <- for (eval_list {{ [0 .. (SHA512_CBLOCK - 1)] : [SHA512_CBLOCK][64] }})\n  (\\x -> (return (eval_int x)) : (TopLevel Int));\n\nif quick_check then do {\n  return ();\n} else do {\n  let verify_final_at_num num = do {\n    print (str_concat \"Verifying SHA512_Final at num=\" (show num));\n    llvm_verify m \"SHA512_Final\"\n      [sha512_block_data_order_ov]\n      true\n      (SHA512_Final_spec num)\n      (w4_unint_z3 [\"processBlock_Common\"]);\n  };\n  for nums verify_final_at_num;\n  return ();\n};\n```"}]}
{"filename":"saw-script\/exercises\/common\/helpers.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Given the associated C or Java source files and the SAW helpers provided, write a SAWScript verification harness that loads the appropriate backend module (use llvm_load_module if C source is given, or java_load_class if Java source is given). Define a let-bound specification named <target>_spec that uses symbolic inputs created with llvm_fresh_var or jvm_fresh_var as appropriate. The spec should call the exact function or method from the source by its precise symbol name or class.method signature. Include minimal preconditions necessary for safety such as valid array bounds or non-zero divisors. Use the helper functions alloc_init, ptr_to_fresh, and global_alloc_init as needed to set up memory and inputs. Do not inline the spec directly in function calls, and do not reference solvers or include comments in the SAWScript."},{"role":"assistant","content":"```saw\n\/*\n * SAW helpers\n *\/\n\/\/ Given a value `v` of type `ty`, allocates and returns a pointer to memory\n\/\/ storing `v`\nlet alloc_init ty v = do {\n  p <- crucible_alloc ty;\n  crucible_points_to p v;\n  return p;\n};\n\n\/\/ Given a value `v` of type `ty`, allocates and returns a read only pointer to\n\/\/ memory storing `v`\nlet alloc_init_readonly ty v = do {\n  p <- crucible_alloc_readonly ty;\n  crucible_points_to p v;\n  return p;\n};\n\n\/\/ Given a name `n` and a type `ty`, allocates a fresh variable `x` of type\n\/\/ `ty` and returns a tuple of `x` and a pointer to `x`.\nlet ptr_to_fresh n ty = do {\n  x <- crucible_fresh_var n ty;\n  p <- alloc_init ty (crucible_term x);\n  return (x, p);\n};\n\n\/\/ Given a name `n` and a type `ty`, allocates a fresh variable `x` of type\n\/\/ `ty` and returns a tuple of `x` and a read only pointer to `x`.\nlet ptr_to_fresh_readonly n ty = do {\n  x <- crucible_fresh_var n ty;\n  p <- alloc_init_readonly ty (crucible_term x);\n  return (x, p);\n};\n\n\/\/ Given a name `n` and a value `v`, assert that the `n` has a value of `v`\nlet global_points_to n v = do {\n  crucible_points_to (crucible_global n) (crucible_term v);\n};\n\n\/\/ Given a name `n` and a value `v`, declare that n is initialized, and assert that has value v\nlet global_alloc_init n v = do {\n  crucible_alloc_global n;\n  global_points_to n v;\n};\n\n\/\/ llvm integer type aliases\nlet i8 = llvm_int 8;\nlet i16 = llvm_int 16;\nlet i32 = llvm_int 32;\nlet i64 = llvm_int 64;\nlet i128 = llvm_int 128;\nlet i384 = llvm_int 384;\nlet i512 = llvm_int 512;\n```"}]}
{"filename":"saw-script\/exercises\/memory-safety\/point\/solution.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from point.bc that verifies the functions point_eq, point_new, point_copy, and point_add defined in point.c. For each function, define a let-bound spec using llvm_fresh_var and ptr_to_fresh_readonly or ptr_to_fresh to create symbolic inputs and outputs matching the function signatures: point_eq takes two const point* pointers and returns a bool; point_new takes two uint32_t and returns point*; point_copy takes one const point* and returns point*; point_add takes two const point* and returns point*. Include minimal preconditions for safety and termination. Use llvm_execute_func to call the functions with appropriate arguments. Use llvm_return to specify the return values. Reference the global ZERO where needed in point_add_spec. Verify each function with llvm_verify, chaining dependencies as appropriate.\n\n# Source code:\npoint.c\n```C\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n\ntypedef struct point {\n    uint32_t x;\n    uint32_t y;\n} point;\n\npoint ZERO = {0, 0};\n\nbool point_eq(const point *p1, const point *p2) {\n    return p1->x == p2->x && p1->y == p2-> y;\n}\n\npoint* point_new(uint32_t x, uint32_t y) {\n    point* ret = malloc(sizeof(point));\n    ret->x = x;\n    ret->y = y;\n    return ret;\n}\n\npoint* point_copy(const point* p) {\n    return point_new(p->x, p->y);\n}\n\npoint* point_add(const point *p1, const point *p2) {\n    \/\/ Save an addition by checking for zero\n    if (point_eq(p1, &ZERO)) {\n        return point_copy(p2);\n    } \n    \n    if (point_eq(p2, &ZERO)) {\n        return point_copy(p1);\n    }\n\n    return point_new(p1->x + p2->x, p1->y + p2->y);\n}\n```"},{"role":"assistant","content":"```saw\ninclude \"..\/..\/common\/helpers.saw\";\n\nm <- llvm_load_module \"point.bc\";\n\nlet point_eq_spec = do {\n    (p1, p1_ptr) <- ptr_to_fresh_readonly \"p1\" (llvm_alias \"struct.point\");\n    (p2, p2_ptr) <- ptr_to_fresh_readonly \"p2\" (llvm_alias \"struct.point\");\n\n    llvm_execute_func [p1_ptr, p2_ptr];\n\n    ret <- llvm_fresh_var \"ret\" (llvm_int 1);\n    llvm_return (llvm_term ret);\n};\n\npoint_eq_ov <- llvm_verify m \"point_eq\" [] true\n    point_eq_spec\n    (w4_unint_z3 []);\n\nlet point_new_spec = do {\n    p_x <- llvm_fresh_var \"p_x\" (llvm_int 32);\n    p_y <- llvm_fresh_var \"p_y\" (llvm_int 32);\n\n    llvm_execute_func [ llvm_term p_x, llvm_term p_y ];\n\n    (ret, ret_ptr) <- ptr_to_fresh \"ret\" (llvm_alias \"struct.point\");\n    llvm_return ret_ptr;\n};\n\npoint_new_ov <- llvm_verify m \"point_new\" [] true\n    point_new_spec\n    (w4_unint_z3 []);\n\nlet point_copy_spec = do {\n    (p, p_ptr) <- ptr_to_fresh_readonly \"p\" (llvm_alias \"struct.point\");\n\n    llvm_execute_func [p_ptr];\n\n    (ret, ret_ptr) <- ptr_to_fresh \"ret\" (llvm_alias \"struct.point\");\n    llvm_return ret_ptr;\n};\n\npoint_copy_ov <- llvm_verify m \"point_copy\" [point_new_ov] true\n    point_copy_spec\n    (w4_unint_z3 []);\n\nlet point_add_spec = do {\n    llvm_alloc_global \"ZERO\";\n    zero_global <- llvm_fresh_var \"zero_global\" (llvm_alias \"struct.point\");\n    llvm_points_to (llvm_global \"ZERO\") (llvm_term zero_global);\n    \n    (p1, p1_ptr) <- ptr_to_fresh_readonly \"p1\" (llvm_alias \"struct.point\");\n    (p2, p2_ptr) <- ptr_to_fresh_readonly \"p2\" (llvm_alias \"struct.point\");\n\n    llvm_execute_func [p1_ptr, p2_ptr];\n\n    (ret, ret_ptr) <- ptr_to_fresh \"ret\" (llvm_alias \"struct.point\");\n    llvm_return ret_ptr;\n};\n\nllvm_verify m \"point_add\"\n    [point_new_ov, point_copy_ov, point_eq_ov]\n    true\n    point_add_spec\n    (w4_unint_z3 []);\n```"}]}
{"filename":"saw-script\/exercises\/memory-safety\/swap\/solution.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from swap.bc that verifies the functions swap, xor_swap, and selection_sort defined in swap.c. Define let-bound specs named swap_diff_spec, swap_same_spec, and selection_sort_spec respectively. Use llvm_fresh_var and ptr_to_fresh to create symbolic inputs for pointers and arrays of 32-bit integers, ensuring minimal preconditions for memory safety and termination of loops. Reference the exact function names swap, xor_swap, and selection_sort with their appropriate pointer and size_t argument types. The specs should execute the functions symbolically and assert the expected postconditions using llvm_points_to. Do not include comments or solver references in the SAWScript code.\n\n# Source code:\nswap.c\n```C\n#include <stdint.h>\n#include <stdlib.h>\n\n\/\/ Swap two pointers using a temporary variable\nvoid swap(uint32_t *x, uint32_t *y) {\n    uint32_t tmp = *x;\n    *x = *y;\n    *y = tmp;\n}\n\n\/\/ Swap two pointers using XOR\nvoid xor_swap(uint32_t *x, uint32_t *y) {\n    *x ^= *y;\n    *y ^= *x;\n    *x ^= *y;\n}\n\n\/\/ selection sort on an array `a` with `len` elements\nvoid selection_sort(uint32_t *a, size_t len) {\n    for (size_t i = 0; i < len - 1; ++i) {\n        size_t j_min = i;\n        for (size_t j = i; j < len; ++j) {\n            if (a[j] < a[j_min]) {\n                j_min = j;\n            }\n        }\n        swap(a+i, a+j_min);\n    }\n}\n```"},{"role":"assistant","content":"```saw\ninclude \"..\/..\/common\/helpers.saw\";\nswapmod <- llvm_load_module \"swap.bc\";\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Part 1: Swap Different Pointers Spec\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nlet swap_diff_spec = do {\n    (x, xp) <- ptr_to_fresh \"x\" (llvm_int 32);\n    (y, yp) <- ptr_to_fresh \"y\" (llvm_int 32);\n\n    llvm_execute_func [xp, yp];\n\n    x' <- llvm_fresh_var \"x'\" (llvm_int 32);\n    y' <- llvm_fresh_var \"y'\" (llvm_int 32);\n\n    llvm_points_to xp (llvm_term x');\n    llvm_points_to yp (llvm_term y');\n};\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Part 2: Swap Different Pointers Proofs\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Verify swap\nswap_diff_ov <- llvm_verify swapmod \"swap\" [] true swap_diff_spec z3;\n\n\/\/ Verify xor_swap\nllvm_verify swapmod \"xor_swap\" [] true swap_diff_spec z3;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Part 3: Swap Same Pointers Spec\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nlet swap_same_spec = do {\n    (x, xp) <- ptr_to_fresh \"x\" (llvm_int 32);\n\n    llvm_execute_func [xp, xp];\n\n    x' <- llvm_fresh_var \"x'\" (llvm_int 32);\n    llvm_points_to xp (llvm_term x');\n};\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Part 4: Swap Same Pointers Proofs\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nswap_same_ov <- llvm_verify swapmod \"swap\" [] true swap_same_spec z3;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Part 5: Selection Sort Spec\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nlet selection_sort_spec len = do {\n    (a, a_ptr) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 32));\n\n    llvm_execute_func [a_ptr, (llvm_term {{ `len : [64]}})];\n\n    a' <- llvm_fresh_var \"a'\" (llvm_array len (llvm_int 32));\n\n    llvm_points_to a_ptr (llvm_term a');\n};\n\nllvm_verify swapmod \"selection_sort\" [swap_diff_ov, swap_same_ov] true (selection_sort_spec 2) (do {\n    \/\/simplify (cryptol_ss());\n    \/\/print_goal;\n    z3;\n});\n\nllvm_verify swapmod \"selection_sort\" [swap_diff_ov, swap_same_ov] true (selection_sort_spec 3) (do {\n    \/\/simplify (cryptol_ss());\n    \/\/print_goal;\n    z3;\n});\n\nllvm_verify swapmod \"selection_sort\" [swap_diff_ov, swap_same_ov] true (selection_sort_spec 8) (do {\n    \/\/simplify (cryptol_ss());\n    \/\/print_goal;\n    z3;\n});\n```"}]}
{"filename":"saw-script\/exercises\/memory-safety\/popcount\/solution.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module popcount.bc that verifies the functions pop_count, pop_count_mul, and pop_count_sparse. Define a let-bound spec named pop_cryptol_check that creates a fresh 32-bit symbolic variable x, executes the function with x as input, and returns the function's 32-bit integer result. Use llvm_fresh_var to create symbolic inputs. Verify each function against this spec using llvm_verify with no additional preconditions, ensuring the harness references the exact function names from popcount.c.\n\n# Source code:\npopcount.c\n```C\n#include <stdint.h>\n\n\/*\n * Returns a count of the set bits in a word.\n * From Henry S. Warren Jr.'s Hacker's Delight\n *\/\nint pop_count(uint32_t x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0F0F0F0F;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x0000003F;\n}\n\n\/* A version of popcount that uses multiplication *\/\nint pop_count_mul(uint32_t x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = ((x + (x >> 4)) & 0x0F0F0F0F);\n    return (x * 0x01010101) >> 24;\n}\n\n\/* A version of popcount that uses an indefinite while loop(!) *\/\nint pop_count_sparse(uint32_t x) {\n    int n;\n    n = 0;\n    while (x != 0) {\n        n = n + 1;\n        x = x & (x - 1);\n    }\n    return n;\n}\n```"},{"role":"assistant","content":"```saw\npopmod <- llvm_load_module \"popcount.bc\";\n\nlet pop_cryptol_check = do {\n     x <- llvm_fresh_var \"x\" (llvm_int 32);\n     llvm_execute_func [llvm_term x];\n     ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n     llvm_return ( llvm_term ret );\n};\n\n\/\/ same verification against Cryptol spec\nllvm_verify popmod \"pop_count\" [] true pop_cryptol_check yices;\n\n\/\/ Begin Cryptol additional verifications\n\/\/ another tricky implementation\nllvm_verify popmod \"pop_count_mul\" [] true pop_cryptol_check yices;\n\n\/\/ verify the while loop version\nllvm_verify popmod \"pop_count_sparse\" [] true pop_cryptol_check yices;\n```"}]}
{"filename":"saw-script\/exercises\/memory-safety\/u128\/solution.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module 'u128.bc' that defines the functions 'void increment_u128(uint64_t x[2])' and 'bool eq_u128(const uint64_t x[2], const uint64_t y[2])'. Define let-bound specs 'increment_u128_spec' and 'eq_u128_spec' using symbolic pointers to 128-bit integers modeled as arrays of two 64-bit integers. Use 'llvm_fresh_var' for symbolic variables and include minimal preconditions for safety. Reference the exact function names 'increment_u128' and 'eq_u128' from the module. The harness should verify these functions against their specs without inline 'do' blocks and without solver references.\n\n# Source code:\nu128.c\n```C\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <strings.h>\n\n\/\/ Increment a 128-bit uint (represented as an array of 2 64-bit uints)\nvoid increment_u128(uint64_t x[2]) {\n    if (++x[0] == 0) {\n        ++x[1];\n    }\n}\n\nbool eq_u128(const uint64_t x[2], const uint64_t y[2]) {\n    \/\/ \"The bcmp() function compares the two byte sequences s1 and s2 of length\n    \/\/ n each. If they are equal, and in particular if n is zero, bcmp() returns\n    \/\/ 0. Otherwise it returns a nonzero result.\" --bcmp man page\n    \/\/ The type signature for bcmp is:\n    \/\/     int bcmp(const void *b1, const void *b2, size_t len);\n    return !bcmp(x, y, 16);\n}\n```"},{"role":"assistant","content":"```saw\ninclude \"..\/..\/common\/helpers.saw\";\n\nm <- llvm_load_module \"u128.bc\";\n\n\/\/ The interesting thing about this is that we can model it as a 128-bit int directly in Cryptol! Not an array of 2 64-bit ints.\nlet increment_u128_spec = do {\n    (x, x_ptr) <- ptr_to_fresh \"x\" (llvm_int 128);\n\n    llvm_execute_func [x_ptr];\n\n    x' <- llvm_fresh_var \"x'\" (llvm_int 128);\n    llvm_points_to x_ptr (llvm_term x');\n};\n\nllvm_verify m \"increment_u128\"\n    []\n    true\n    increment_u128_spec\n    (do {\n                w4_unint_z3 [];\n});\n\n\/\/ \"The bcmp() function compares the two byte sequences s1 and s2 of length n each. If they are equal, and in particular if n is zero, bcmp() returns 0. Otherwise it returns a nonzero result.\"\nlet bcmp_spec size = do {\n    (s1, s1_ptr) <- ptr_to_fresh_readonly \"s1\" (llvm_array size (llvm_int 8));\n    (s2, s2_ptr) <- ptr_to_fresh_readonly \"s2\" (llvm_array size (llvm_int 8));\n\n    llvm_execute_func [ s1_ptr, s2_ptr, llvm_term {{ `size : [64]}} ];\n\n    ret <- llvm_fresh_var \"ret\" (llvm_int 32);\n    llvm_return (llvm_term ret);\n};\n\nbcmp_16_ov <- llvm_unsafe_assume_spec m \"bcmp\" (bcmp_spec 16);\n\nlet eq_u128_spec = do {\n    (x, x_ptr) <- ptr_to_fresh_readonly \"x\" (llvm_int 128);\n    (y, y_ptr) <- ptr_to_fresh_readonly \"y\" (llvm_int 128);\n\n    llvm_execute_func [x_ptr, y_ptr];\n\n    ret <- llvm_fresh_var \"ret\" (llvm_int 1);\n    llvm_return (llvm_term ret);\n};\n\nllvm_verify m \"eq_u128\"\n    [bcmp_16_ov]\n    true\n    eq_u128_spec\n    (do {\n                w4_unint_z3 [];\n});\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/point\/Point.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the functional correctness of the Point module, including properties that check commutativity and associativity of the point_add function, as well as correctness of the POINT_ZERO constant as the additive identity."},{"role":"assistant","content":"```cryptol\nmodule Point where\n\ntype Point = {x : [32], y : [32]}\n\nPOINT_ZERO : Point\nPOINT_ZERO = zero\n\npoint_add : Point -> Point -> Point\npoint_add p1 p2 = { x = p1.x + p2.x, y = p1.y + p2.y }\n\npoint_add_commutes : Point -> Point -> Bit\nproperty point_add_commutes p1 p2 = point_add p1 p2 == point_add p2 p1\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/point\/solution.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from 'point.bc' that verifies the functions 'point_eq', 'point_new', 'point_copy', and 'point_add' defined in 'point.c'. Define let-bound specs named 'point_eq_spec', 'point_new_spec', 'point_copy_spec', and 'point_add_spec' respectively. Use 'llvm_fresh_var' to create symbolic inputs for all function parameters. For pointer arguments, allocate and initialize memory with symbolic values using 'llvm_alloc_readonly' and 'llvm_points_to'. Include minimal preconditions to ensure safety. Use 'llvm_execute_func' to invoke each function with the symbolic inputs, and specify the expected return values with 'llvm_return'. Verify 'point_add' with dependencies on the other function verifications. Do not inline specs; bind them to let names before verification calls.\n\n# Source code:\npoint.c\n```C\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n\ntypedef struct point {\n    uint32_t x;\n    uint32_t y;\n} point;\n\npoint ZERO = {0, 0};\n\n\/\/ Check whether two points are equal\nbool point_eq(const point *p1, const point *p2) {\n    return p1->x == p2->x && p1->y == p2-> y;\n}\n\n\/\/ Allocate and return a new point\npoint* point_new(uint32_t x, uint32_t y) {\n    point* ret = malloc(sizeof(point));\n    ret->x = x;\n    ret->y = y;\n    return ret;\n}\n\n\/\/ Return a new point containing a copy of `p`\npoint* point_copy(const point* p) {\n    return point_new(p->x, p->y);\n}\n\n\/\/ Add two points\npoint* point_add(const point *p1, const point *p2) {\n    \/\/ Save an addition by checking for zero\n    if (point_eq(p1, &ZERO)) {\n        return point_copy(p2);\n    }\n\n    if (point_eq(p2, &ZERO)) {\n        return point_copy(p1);\n    }\n\n    return point_new(p1->x + p2->x, p1->y + p2->y);\n}\n\n```"},{"role":"assistant","content":"```saw\ninclude \"..\/..\/common\/helpers.saw\";\nimport \"Point.cry\";\n\nm <- llvm_load_module \"point.bc\";\n\nlet fresh_point_readonly name = do {\n    p_ptr <- llvm_alloc_readonly (llvm_alias \"struct.point\");\n    p_x <- llvm_fresh_var (str_concat name \".x\") (llvm_int 32);\n    p_y <- llvm_fresh_var (str_concat name \".y\") (llvm_int 32);\n    llvm_points_to p_ptr (llvm_struct_value [ llvm_term p_x, llvm_term p_y]);\n    let p = {{ { x = p_x, y = p_y } }};\n    return (p, p_ptr);\n};\n\nlet point_eq_spec = do {\n    (p1, p1_ptr) <- fresh_point_readonly \"p1\";\n    (p2, p2_ptr) <- fresh_point_readonly \"p2\";\n\n    llvm_execute_func [p1_ptr, p2_ptr];\n\n    \/\/ This is confusing.  p1 == p2 wont work because that produces a Bit, but\n    \/\/ this function wants a [1] as a response.\n    llvm_return (llvm_term {{ [p1 == p2] }});\n};\n\npoint_eq_ov <- llvm_verify m \"point_eq\" [] true\n    point_eq_spec\n    (w4_unint_z3 []);\n\nlet alloc_assign_point p = do {\n    p_ptr <- llvm_alloc (llvm_alias \"struct.point\");\n    llvm_points_to p_ptr (llvm_struct_value [ llvm_term {{ p.x }}, llvm_term {{ p.y }}]);\n    return p_ptr;\n};\n\nlet point_new_spec = do {\n    p_x <- llvm_fresh_var \"p_x\" (llvm_int 32);\n    p_y <- llvm_fresh_var \"p_y\" (llvm_int 32);\n\n    llvm_execute_func [ llvm_term p_x, llvm_term p_y ];\n\n    ret_ptr <- alloc_assign_point {{ {x = p_x, y = p_y } }};\n    llvm_return ret_ptr;\n};\n\npoint_new_ov <- llvm_verify m \"point_new\" [] true\n    point_new_spec\n    (w4_unint_z3 []);\n\nlet point_copy_spec = do {\n    (p, p_ptr) <- fresh_point_readonly \"p\";\n\n    llvm_execute_func [p_ptr];\n\n    ret_ptr <- alloc_assign_point p;\n    llvm_return ret_ptr;\n};\n\npoint_copy_ov <- llvm_verify m \"point_copy\" [point_new_ov] true\n    point_copy_spec\n    (w4_unint_z3 []);\n\nlet point_add_spec = do {\n    let zero_term = llvm_term {{ 0 : [32] }};\n    llvm_alloc_global \"ZERO\";\n    llvm_points_to (llvm_global \"ZERO\") \n                   (llvm_struct_value [zero_term, zero_term]);\n    \n    (p1, p1_ptr) <- fresh_point_readonly \"p1\";\n    (p2, p2_ptr) <- fresh_point_readonly \"p2\";\n\n    llvm_execute_func [p1_ptr, p2_ptr];\n\n    res_ptr <- alloc_assign_point {{ point_add p1 p2 }};\n    llvm_return res_ptr;\n};\n\nllvm_verify m \"point_add\"\n    [point_new_ov, point_copy_ov, point_eq_ov]\n    true\n    point_add_spec\n    (w4_unint_z3 []);\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/popcount\/solution.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"popcount.bc\" that verifies the three functions pop_count, pop_count_mul, and pop_count_sparse against a Cryptol specification named popCount. Define a let-bound spec named pop_cryptol_check that takes a symbolic 32-bit integer input x, executes the LLVM function with x, and returns the Cryptol popCount applied to x. Use llvm_fresh_var for symbolic inputs and include any minimal preconditions needed for safety, especially for the while loop in pop_count_sparse. Then use llvm_verify to verify each function against pop_cryptol_check with no additional arguments and the verification condition true.\n\n# Source code:\npopcount.c\n```C\n#include <stdint.h>\n\n\/*\n * Returns a count of the set bits in a word.\n * From Henry S. Warren Jr.'s Hacker's Delight\n *\/\nint pop_count(uint32_t x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0F0F0F0F;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x0000003F;\n}\n\n\/* A version of popcount that uses multiplication *\/\nint pop_count_mul(uint32_t x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = ((x + (x >> 4)) & 0x0F0F0F0F);\n    return (x * 0x01010101) >> 24;\n}\n\n\/* A version of popcount that uses an indefinite while loop(!) *\/\nint pop_count_sparse(uint32_t x) {\n    int n;\n    n = 0;\n    while (x != 0) {\n        n = n + 1;\n        x = x & (x - 1);\n    }\n    return n;\n}\n```"},{"role":"assistant","content":"```saw\nimport \"Popcount.cry\";\n\npopmod <- llvm_load_module \"popcount.bc\";\n\nlet pop_cryptol_check = do {\n     x <- llvm_fresh_var \"x\" (llvm_int 32);\n     llvm_execute_func [llvm_term x];\n     llvm_return ( llvm_term {{ popCount x }} );\n};\n\n\/\/ same verification against Cryptol spec\nllvm_verify popmod \"pop_count\" [] true pop_cryptol_check (do {\n          z3;\n});\n\n\/\/ Begin Cryptol additional verifications\n\/\/ another tricky implementation\nllvm_verify popmod \"pop_count_mul\" [] true pop_cryptol_check yices;\n\n\/\/ verify the while loop version\nllvm_verify popmod \"pop_count_sparse\" [] true pop_cryptol_check yices;\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/popcount\/Popcount.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that specifies the correctness of the popCount function, ensuring it accurately counts the number of set bits (1s) in a 32-bit input word."},{"role":"assistant","content":"```cryptol\nmodule Popcount where\n\npopCount : [32] -> [32]\npopCount bits = ic ! 0 where\n     ic = [0] # [ if elt then prev + 1 else prev | elt <- bits | prev <- ic]\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/salsa20\/solution.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Salsa20 implementation in salsa20.c using the LLVM backend. Define let-bound specs for the following functions: s20_quarterround with signature void s20_quarterround(uint32_t *y0, uint32_t *y1, uint32_t *y2, uint32_t *y3); s20_rowround with signature void s20_rowround(uint32_t y[16]); s20_columnround with signature void s20_columnround(uint32_t x[16]); s20_doubleround with signature void s20_doubleround(uint32_t x[16]); s20_hash with signature void s20_hash(uint8_t seq[64]); s20_expand32 with signature void s20_expand32(uint8_t *k, uint8_t n[16], uint8_t keystream[64]); and s20_crypt32 with signature enum s20_status_t s20_crypt32(uint8_t *key, uint8_t nonce[8], uint32_t si, uint8_t *buf, uint32_t buflen). Use llvm_fresh_var to create symbolic inputs and add minimal preconditions to ensure safety such as valid pointer bounds and non-null pointers. Reference the exact function names as defined in salsa20.c and invoke llvm_execute_func accordingly. Do not inline specs; bind each spec to a let-bound name before use.\n\n# Source code:\nsalsa20.c\n```C\n#include <stdint.h>\n#include <stddef.h>\n#include \"salsa20.h\"\n\n\/\/ Implements DJB's definition of '<<<'\nstatic uint32_t rotl(uint32_t value, int shift)\n{\n  return (value << shift) | (value >> (32 - shift));\n}\n\nstatic void s20_quarterround(uint32_t *y0, uint32_t *y1, uint32_t *y2, uint32_t *y3)\n{\n  *y1 = *y1 ^ rotl(*y0 + *y3, 7);\n  *y2 = *y2 ^ rotl(*y1 + *y0, 9);\n  *y3 = *y3 ^ rotl(*y2 + *y1, 13);\n  *y0 = *y0 ^ rotl(*y3 + *y2, 18);\n}\n\nstatic void s20_rowround(uint32_t y[static 16])\n{\n  s20_quarterround(&y[0], &y[1], &y[2], &y[3]);\n  s20_quarterround(&y[5], &y[6], &y[7], &y[4]);\n  s20_quarterround(&y[10], &y[11], &y[8], &y[9]);\n  s20_quarterround(&y[15], &y[12], &y[13], &y[14]);\n}\n\nstatic void s20_columnround(uint32_t x[static 16])\n{\n  s20_quarterround(&x[0], &x[4], &x[8], &x[12]);\n  s20_quarterround(&x[5], &x[9], &x[13], &x[1]);\n  s20_quarterround(&x[10], &x[14], &x[2], &x[6]);\n  s20_quarterround(&x[15], &x[3], &x[7], &x[11]);\n}\n\nstatic void s20_doubleround(uint32_t x[static 16])\n{\n  s20_columnround(x);\n  s20_rowround(x);\n}\n\n\/\/ Creates a little-endian word from 4 bytes pointed to by b\nstatic uint32_t s20_littleendian(uint8_t *b)\n{\n  return b[0] +\n         (b[1] << 8) +\n         (b[2] << 16) +\n         (b[3] << 24);\n}\n\n\/\/ Moves the little-endian word into the 4 bytes pointed to by b\nstatic void s20_rev_littleendian(uint8_t *b, uint32_t w)\n{\n  b[0] = w;\n  b[1] = w >> 8;\n  b[2] = w >> 16;\n  b[3] = w >> 24;\n}\n\n\/\/ The core function of Salsa20\nstatic void s20_hash(uint8_t seq[static 64])\n{\n  int i;\n  uint32_t x[16];\n  uint32_t z[16];\n\n  \/\/ Create two copies of the state in little-endian format\n  \/\/ First copy is hashed together\n  \/\/ Second copy is added to first, word-by-word\n  for (i = 0; i < 16; ++i)\n    x[i] = z[i] = s20_littleendian(seq + (4 * i));\n\n  for (i = 0; i < 10; ++i)\n    s20_doubleround(z);\n\n  for (i = 0; i < 16; ++i) {\n    z[i] += x[i];\n    s20_rev_littleendian(seq + (4 * i), z[i]);\n  }\n}\n\n\/\/ The 16-byte (128-bit) key expansion function\nstatic void s20_expand16(uint8_t *k,\n                         uint8_t n[static 16],\n                         uint8_t keystream[static 64])\n{\n  int i, j;\n  \/\/ The constants specified by the Salsa20 specification, 'tau'\n  \/\/ \"expand 16-byte k\"\n  uint8_t t[4][4] = {\n    { 'e', 'x', 'p', 'a' },\n    { 'n', 'd', ' ', '1' },\n    { '6', '-', 'b', 'y' },\n    { 't', 'e', ' ', 'k' }\n  };\n\n  \/\/ Copy all of 'tau' into the correct spots in our keystream block\n  for (i = 0; i < 64; i += 20)\n    for (j = 0; j < 4; ++j)\n      keystream[i + j] = t[i \/ 20][j];\n\n  \/\/ Copy the key and the nonce into the keystream block\n  for (i = 0; i < 16; ++i) {\n    keystream[4+i]  = k[i];\n    keystream[44+i] = k[i];\n    keystream[24+i] = n[i];\n  }\n\n  s20_hash(keystream);\n}\n\n\/\/ The 32-byte (256-bit) key expansion function\nstatic void s20_expand32(uint8_t *k,\n                         uint8_t n[static 16],\n                         uint8_t keystream[static 64])\n{\n  int i, j;\n  \/\/ The constants specified by the Salsa20 specification, 'sigma'\n  \/\/ \"expand 32-byte k\"\n  uint8_t o[4][4] = {\n    { 'e', 'x', 'p', 'a' },\n    { 'n', 'd', ' ', '3' },\n    { '2', '-', 'b', 'y' },\n    { 't', 'e', ' ', 'k' }\n  };\n\n  \/\/ Copy all of 'sigma' into the correct spots in our keystream block\n  for (i = 0; i < 64; i += 20)\n    for (j = 0; j < 4; ++j)\n      keystream[i + j] = o[i \/ 20][j];\n\n  \/\/ Copy the key and the nonce into the keystream block\n  for (i = 0; i < 16; ++i) {\n    keystream[4+i]  = k[i];\n    keystream[44+i] = k[i+16];\n    keystream[24+i] = n[i];\n  }\n\n  s20_hash(keystream);\n}\n\n\/\/ Performs up to 2^32-1 bytes of encryption or decryption under a\n\/\/ 128- or 256-bit key.\nenum s20_status_t s20_crypt32(uint8_t *key,\n                            uint8_t nonce[static 8],\n                            uint32_t si,\n                            uint8_t *buf,\n                            uint32_t buflen)\n{\n  uint8_t keystream[64];\n  \/\/ 'n' is the 8-byte nonce (unique message number) concatenated\n  \/\/ with the per-block 'counter' value (4 bytes in our case, 8 bytes\n  \/\/ in the standard). We leave the high 4 bytes set to zero because\n  \/\/ we permit only a 32-bit integer for stream index and length.\n  uint8_t n[16] = { 0 };\n  uint32_t i;\n\n  \/\/ If any of the parameters we received are invalid\n  if (key == NULL || nonce == NULL || buf == NULL)\n    return S20_FAILURE;\n\n  \/\/ Set up the low 8 bytes of n with the unique message number\n  for (i = 0; i < 8; ++i)\n    n[i] = nonce[i];\n\n  \/\/ If we're not on a block boundary, compute the first keystream\n  \/\/ block. This will make the primary loop (below) cleaner\n  if (si % 64 != 0) {\n    \/\/ Set the second-to-highest 4 bytes of n to the block number\n    s20_rev_littleendian(n+8, si \/ 64);\n    \/\/ Expand the key with n and hash to produce a keystream block\n    s20_expand32(key, n, keystream);\n  }\n\n  \/\/ Walk over the plaintext byte-by-byte, xoring the keystream with\n  \/\/ the plaintext and producing new keystream blocks as needed\n  for (i = 0; i < buflen; ++i) {\n    \/\/ If we've used up our entire keystream block (or have just begun\n    \/\/ and happen to be on a block boundary), produce keystream block\n    if ((si + i) % 64 == 0) {\n      s20_rev_littleendian(n+8, ((si + i) \/ 64));\n      s20_expand32(key, n, keystream);\n    }\n\n    \/\/ xor one byte of plaintext with one byte of keystream\n    buf[i] ^= keystream[(si + i) % 64];\n  }\n\n  return S20_SUCCESS;\n}\n\n```"},{"role":"assistant","content":"```saw\ninclude \"..\/..\/common\/helpers.saw\";\nimport \"Salsa20.cry\";\n\nlet oneptr_update_func (type : LLVMType) (name : String) (f : Term) = do {\n    (x, p) <- ptr_to_fresh name type;\n    llvm_execute_func [p];\n    llvm_points_to p (llvm_term {{ f x }});\n};\n\nlet quarterround_setup : CrucibleSetup () = do {\n    (y0, p0) <- ptr_to_fresh \"y0\" (llvm_int 32);\n    (y1, p1) <- ptr_to_fresh \"y1\" (llvm_int 32);\n    (y2, p2) <- ptr_to_fresh \"y2\" (llvm_int 32);\n    (y3, p3) <- ptr_to_fresh \"y3\" (llvm_int 32);\n\n    llvm_execute_func [p0, p1, p2, p3];\n\n    let zs = {{ quarterround [y0,y1,y2,y3] }};\n    llvm_points_to p0 (llvm_term {{ zs@0 }});\n    llvm_points_to p1 (llvm_term {{ zs@1 }});\n    llvm_points_to p2 (llvm_term {{ zs@2 }});\n    llvm_points_to p3 (llvm_term {{ zs@3 }});\n};\n\nlet rowround_setup =\n  oneptr_update_func (llvm_array 16 (llvm_int 32)) \"y\" {{ rowround }};\n\nlet columnround_setup =\n  oneptr_update_func (llvm_array 16 (llvm_int 32)) \"x\" {{ columnround }};\n\nlet doubleround_setup =\n  oneptr_update_func (llvm_array 16 (llvm_int 32)) \"x\" {{ doubleround }};\n\nlet salsa20_setup =\n  oneptr_update_func (llvm_array 64 (llvm_int 8)) \"seq\" {{ Salsa20 }};\n\nlet salsa20_expansion_32 = do {\n    (n, pn) <- ptr_to_fresh_readonly \"n\" (llvm_array 16 (llvm_int 8));\n    (k, pk) <- ptr_to_fresh_readonly \"k\" (llvm_array 32 (llvm_int 8));\n\n    pks <- llvm_alloc (llvm_array 64 (llvm_int 8));\n\n    llvm_execute_func [pk, pn, pks];\n\n    let rks = {{ Salsa20_expansion`{a=2}(k, n)}};\n    llvm_points_to pks (llvm_term rks);\n};\n\nlet s20_encrypt32 n = do {\n    (key, pkey) <- ptr_to_fresh_readonly \"key\" (llvm_array 32 (llvm_int 8));\n    (v, pv)     <- ptr_to_fresh_readonly \"nonce\" (llvm_array 8  (llvm_int 8));\n    (m, pm)     <- ptr_to_fresh \"buf\" (llvm_array n (llvm_int 8));\n\n    llvm_execute_func [ pkey\n                          , pv\n                          , llvm_term {{ 0 : [32] }}\n                          , pm\n                          , llvm_term {{ `n : [32] }}\n                          ];\n\n    llvm_points_to pm (llvm_term {{ Salsa20_encrypt (key, v, m) }});\n    llvm_return (llvm_term {{ 0 : [32] }});\n};\n\nm      <- llvm_load_module \"salsa20.bc\";\nqr     <- llvm_verify m \"s20_quarterround\" []      true quarterround_setup   z3;\nrr     <- llvm_verify m \"s20_rowround\"     [qr]    true rowround_setup       z3;\ncr     <- llvm_verify m \"s20_columnround\"  [qr]    true columnround_setup    z3;\ndr     <- llvm_verify m \"s20_doubleround\"  [cr,rr] true doubleround_setup    z3;\ns20    <- llvm_verify m \"s20_hash\"         [dr]    true salsa20_setup        z3;\ns20e32 <- llvm_verify m \"s20_expand32\"     [s20]   true  salsa20_expansion_32 z3;\ns20encrypt_63 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 63) z3;\ns20encrypt_64 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 64) z3;\ns20encrypt_65 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 65) z3;\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/u128\/solution.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from u128.bc that verifies the functions increment_u128 and eq_u128 defined in u128.c. Define let-bound specs increment_u128_spec and eq_u128_spec using llvm_fresh_var and ptr_to_fresh to create symbolic 128-bit inputs as pointers to arrays of two 64-bit integers. For increment_u128_spec, model the effect of incrementing the 128-bit value represented by the array x[2]. For eq_u128_spec, model the function returning true if the two 128-bit inputs are equal, using the bcmp function specification for 16-byte comparison. Include any necessary preconditions for memory safety. Use llvm_execute_func to call the functions and llvm_return to specify their outputs. Reference the exact function names increment_u128 and eq_u128 from the LLVM module.\n\n# Source code:\nu128.c\n```C\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <strings.h>\n\nvoid increment_u128(uint64_t x[2]) {\n    if (++x[1] == 0) {\n        ++x[0];\n    }\n}\n\nbool eq_u128(uint64_t x[2], uint64_t y[2]) {\n    return !bcmp(x, y, 16);\n}\n```"},{"role":"assistant","content":"```saw\ninclude \"..\/..\/common\/helpers.saw\";\n\nm <- llvm_load_module \"u128.bc\";\n\nlet increment_u128_spec = do {\n    (x, x_ptr) <- ptr_to_fresh \"x\" (llvm_int 128);\n\n    llvm_execute_func [x_ptr];\n\n    llvm_points_to x_ptr (llvm_term {{ x + 1 }});\n};\n\n\/\/ NOTE: Solution below is commented out because you need to fix the C code by\n\/\/ changing `x[1]` to `x[0]` on line 7, and `x[0]` to `x[1]` on line 8.  Then\n\/\/ the proof below will go through.\n\/*\nllvm_verify m \"increment_u128\"\n    []\n    true\n    increment_u128_spec\n    (do {\n        simplify (cryptol_ss());\n        print_goal;\n        w4_unint_z3 [];\n});\n*\/\n\n\/\/ \"The bcmp() function compares the two byte sequences s1 and s2 of length n\n\/\/ each. If they are equal, and in particular if n is zero, bcmp() returns 0.\n\/\/ Otherwise it returns a nonzero result.\"\nlet bcmp_spec size = do {\n    (s1, s1_ptr) <- ptr_to_fresh \"s1\" (llvm_array size (llvm_int 8));\n    (s2, s2_ptr) <- ptr_to_fresh \"s2\" (llvm_array size (llvm_int 8));\n\n    llvm_execute_func [ s1_ptr, s2_ptr, llvm_term {{ `size : [64]}} ];\n\n    llvm_return (llvm_term {{ zext`{32} [s1 != s2] }});\n};\n\nbcmp_16_ov <- llvm_unsafe_assume_spec m \"bcmp\" (bcmp_spec 16);\n\nlet eq_u128_spec = do {\n    (x, x_ptr) <- ptr_to_fresh \"x\" (llvm_int 128);\n    (y, y_ptr) <- ptr_to_fresh \"y\" (llvm_int 128);\n\n    llvm_execute_func [x_ptr, y_ptr];\n\n    llvm_return (llvm_term {{ [x == y] : [1] }});\n};\n\nllvm_verify m \"eq_u128\"\n    [bcmp_16_ov]\n    true\n    eq_u128_spec\n    (do {\n                w4_unint_z3 [];\n});\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/swap\/solution\/Swap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties and SAWScript verification scripts to formally verify the correctness of the 'swap_list' and 'selection_sort' functions in the given Cryptol module. Specifically, specify and prove that swapping an element with itself leaves the list unchanged, and that the 'selection_sort' function produces a list equivalent to the built-in 'sort' function. Include necessary preconditions and handle index bounds appropriately."},{"role":"assistant","content":"```cryptol\nmodule Swap where\n\n\/\/ Given a list and two indices, return a new list with the values at the\n\/\/ indices swapped.\nswap_list : {n} [n][32] -> [64] -> [64] -> [n][32]\nswap_list lst i j = update (update lst i jval) j ival\n    where ival = lst @ i\n          jval = lst @ j\n\nargmin : {n} (fin n) => [n][32] -> [64]\nargmin lst =\n    (foldl' min (-1 : [32], -1 : [64]) [(x, i) | x <- lst | i <- [0...]]).1\n\nselection_sort : {n} (fin n, 64 >= width n) => [n][32] -> [n][32]\nselection_sort lst = go`{0} lst\n    where\n        go : {idx} (fin idx, fin n, 64 >= width idx, 64 >= width n, n >= idx) => [n][32] -> [n][32]\n        go acc =\n            if `idx == `n\n            then acc\n            else go`{min n (idx + 1)}\n                    (swap_list acc `idx (`idx + (argmin (drop`{idx} acc))))\n\n\/\/ NOTE: Have to be careful.  Just running :check on this will likely crash because a random index is likely out of bounds (especailly because `n will default to 0)\nswap_list_same : {n} (fin n) => [64] -> [n][32] -> Bit\nproperty swap_list_same i lst = (swap_list lst i i) == lst\n\nsort_eq : {n} (fin n, 64 >= width n) => [n][32] -> Bit\nproperty sort_eq lst = selection_sort lst == sort lst\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/swap\/solution\/solution.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module \"swap.bc\" that defines the C functions swap, xor_swap, selection_sort, argmin, swap_array, selection_sort_composed, and wacky_sort. Define let-bound specs for each function using llvm_fresh_var and llvm_alloc or ptr_to_fresh as appropriate, with minimal preconditions such as array length bounds for selection_sort, argmin, swap_array, selection_sort_composed, and wacky_sort. Use llvm_execute_func to invoke each function symbol by its exact name and verify their functional correctness by asserting expected postconditions with llvm_points_to or llvm_return. Compose verification obligations for functions that call others, referencing prior verification results as needed. Do not inline specs or use hard-coded constants except for array lengths where necessary.\n\n# Source code:\nswap.c\n```C\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid swap(uint32_t *x, uint32_t *y) {\n    uint32_t tmp = *x;\n    *x = *y;\n    *y = tmp;\n}\n\nvoid xor_swap(uint32_t *x, uint32_t *y) {\n    *x ^= *y;\n    *y ^= *x;\n    *x ^= *y;\n}\n\n\/\/ selection sort\nvoid selection_sort(uint32_t *a, size_t len) {\n    for (size_t i = 0; i < len - 1; ++i) {\n        size_t j_min = i;\n        for (size_t j = i; j < len; ++j) {\n            if (a[j] < a[j_min]) {\n                j_min = j;\n            }\n        }\n        swap(a+i, a+j_min);\n    }\n}\n\nsize_t argmin(const uint32_t *a, size_t len) {\n    size_t j_min = 0;\n    for (size_t j = 0; j < len; ++j) {\n        if (a[j] < a[j_min]) {\n            j_min = j;\n        }\n    }\n    return j_min;\n}\n\nvoid swap_array(uint32_t *a, size_t i, size_t j) {\n    swap(a+i, a+j);\n}\n\nvoid selection_sort_composed(uint32_t *a, size_t len) {\n    for (size_t i = 0; i < len - 1; ++i) {\n        size_t j_min = i + argmin(a+i, len-i);\n        swap_array(a, i, j_min);\n    }\n}\n\nvoid wacky_sort(uint32_t *a, size_t len) {\n    for (size_t i = 0; i < 4; ++i) {\n        size_t swap_idx = (argmin(a, len) + i) % len;\n        swap_array(a, 0, swap_idx);\n        swap_array(a, 0, swap_idx);\n    }\n    selection_sort_composed(a, len);\n}\n```"},{"role":"assistant","content":"```saw\ninclude \"..\/..\/..\/common\/helpers.saw\";\nimport \"Swap.cry\";\nswapmod <- llvm_load_module \"swap.bc\";\n\nlet swap_diff_spec = do {\n    \/\/ NOTE: Could use ptr_to_fresh instead\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    xp <- llvm_alloc (llvm_int 32);\n    llvm_points_to xp (llvm_term x);\n\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    yp <- llvm_alloc (llvm_int 32);\n    llvm_points_to yp (llvm_term y);\n\n    llvm_execute_func [xp, yp];\n\n    llvm_points_to yp (llvm_term x);\n    llvm_points_to xp (llvm_term y);\n};\n\n\/\/ Verify swap\nswap_diff_ov <- llvm_verify swapmod \"swap\" [] true swap_diff_spec z3;\n\nlet swap_same_spec = do {\n    (x, x_ptr) <- ptr_to_fresh \"x\" (llvm_int 32);\n\n    llvm_execute_func [x_ptr, x_ptr];\n\n    llvm_points_to x_ptr (llvm_term x);\n};\n\nswap_same_ov <- llvm_verify swapmod \"swap\" [] true swap_same_spec z3;\n\n\/\/ Verify xor_swap\nllvm_verify swapmod \"xor_swap\" [] true swap_diff_spec z3;\n\nlet selection_sort_spec len = do {\n    (a, a_ptr) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 32));\n\n    llvm_execute_func [a_ptr, (llvm_term {{ `len : [64]}})];\n\n    llvm_points_to a_ptr (llvm_term {{ selection_sort a }});\n};\n\nlet a_len = 4;\n\n\/\/ Play with the `len` paramter for this exercise.  At len=4 it solves quickly.\n\/\/ At len=8, the term has blown up.  Will it solve at all?\nllvm_verify swapmod \"selection_sort\" [swap_diff_ov, swap_same_ov] true (selection_sort_spec a_len) (do {\n    \/\/simplify (cryptol_ss());\n    \/\/print_goal;\n    z3;\n});\n\n\/\/ Now we crank a_len up and show the original proof blow up.  How can we fix\n\/\/ it?\nlet a_len = 8;\n\nlet argmin_spec len = do {\n    \/\/ NOTE: Need to be careful to use \"ptr_to_fresh_readonly\" here.  I\n    \/\/ originally made the mistake of making this a \"ptr_to_fresh\", which\n    \/\/ broke the input to swap afterwards by effectively wiping the array.\n    (a, a_ptr) <- ptr_to_fresh_readonly \"a\" (llvm_array len (llvm_int 32));\n\n    llvm_execute_func [a_ptr, (llvm_term {{ `len : [64]}})];\n\n    llvm_return (llvm_term {{ argmin a }});\n};\n\n\/\/ NOTE: Another mistake I made was to use the override below.\n\/\/ This works for size a_len, but on the second time through the loop the override\n\/\/ doesn't match because the size of the list has changed!  Ultimately need a\n\/\/ loop here.\nargmin_ovs <- for (eval_list {{ [1..a_len] : [a_len][64]}}) (\\len ->\n    llvm_verify swapmod \"argmin\" [] true (argmin_spec (eval_int len)) z3\n);\n\n\/\/ NOTE: The reason we created a swap_array function was to get \"swap_list\" in\n\/\/ our goal and reduce the number of ITEs, which in turn will help the solver\nlet swap_array_spec len = do {\n    (a, a_ptr) <- ptr_to_fresh \"a\" (llvm_array len (llvm_int 32));\n\n    i <- llvm_fresh_var \"i\" (llvm_int 64);\n    j <- llvm_fresh_var \"j\" (llvm_int 64);\n\n    llvm_precond {{ i < `len }};\n    llvm_precond {{ j < `len }};\n\n    llvm_execute_func [ a_ptr, llvm_term i, llvm_term j ];\n\n    llvm_points_to a_ptr (llvm_term {{ swap_list a i j }});\n};\n\nswap_array_ov <- llvm_verify swapmod \"swap_array\"\n    [swap_diff_ov, swap_same_ov]\n    true\n    (swap_array_spec a_len)\n    (w4_unint_z3 []);\n\nsort_ov <- llvm_verify swapmod \"selection_sort_composed\"\n    (concat [swap_diff_ov, swap_same_ov, swap_array_ov] argmin_ovs)\n    true\n    (selection_sort_spec a_len)\n    (do {\n                w4_unint_z3 [];\n});\n\nllvm_verify swapmod \"wacky_sort\"\n    (concat argmin_ovs [sort_ov, swap_array_ov])\n    true\n    (selection_sort_spec a_len)\n    (do {\n                w4_unint_z3 [\"selection_sort\"];\n});\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/complete-examples\/add\/solution.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'add.bc', defines a let-bound specification 'add_spec' for the function 'add' with signature 'uint32_t add(uint32_t x, uint32_t y)', uses 'llvm_fresh_var' to create symbolic 32-bit integer inputs 'x' and 'y', executes the function with these inputs, and asserts that the return value equals the sum of 'x' and 'y'. Then verify the function 'add' against 'add_spec' using 'llvm_verify'.\n\n# Source code:\nadd.c\n```C\n#include <stdint.h>\n\nuint32_t add(uint32_t x, uint32_t y) { return x + y; }\n```"},{"role":"assistant","content":"```saw\nlet add_spec = do {\n          x <- llvm_fresh_var \"x\" (llvm_int 32);\n     y <- llvm_fresh_var \"y\" (llvm_int 32);\n\n          llvm_execute_func [llvm_term x, llvm_term y];\n\n          llvm_return (llvm_term {{ x + y }});\n};\n\n\/\/ Load LLVM bitcode to verify\nm <- llvm_load_module \"add.bc\";\n\n\/\/ Verify the `add` function satisfies its specification\nllvm_verify m \"add\" [] true add_spec (do {\n          z3;\n});\n```"}]}
{"filename":"saw-script\/examples\/misc\/rewrite.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated C or Java source files using the appropriate backend inferred from the presence of llvm_load_module or java_load_class. Define a let-bound specification named <name>_spec that uses symbolic inputs created with llvm_fresh_var or jvm_fresh_var corresponding to the exact function or method signatures in the source. Include minimal preconditions necessary for safety and termination, such as array bounds or nonzero divisors. The harness should invoke the target function or method symbol and verify its behavior against the specification using rewriting and proving commands as demonstrated in the provided SAW excerpt. Do not include solver references or inline do blocks; all specs must be let-bound."},{"role":"assistant","content":"```saw\nlet ss = cryptol_ss ();\nlet crule t = rewrite ss t;\n\nrule <- crule {{ \\(x:[384]) -> join ((split x) : [12][32]) == x }};\nrule_thm <- prove_print (admit \"assume rule\") rule;\n\nprint \"== Original version of rule:\";\nprint_term rule;\nlet rule_ss = addsimps [rule_thm] empty_ss;\nlet t = rewrite rule_ss rule;\nprint \"== Rule rewritten with itself:\";\nprint_term t;\nprint \"== Proof result:\";\nprove_print abc t;\n```"}]}
{"filename":"saw-script\/examples\/misc\/mutRecTest.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the associated source files and defines a let-bound specification named fib_spec. The spec should symbolically create an 8-element input vector of 8-bit values using llvm_fresh_var, then call the functions streamFibs, streamFibsAlt, recFibs, and recFibs2 with this input. The spec should assert equivalence between streamFibs and streamFibsAlt, and also between streamFibs and recFibs and recFibs2 where possible, adding minimal preconditions to ensure termination and safety. Use the exact function names as defined in the source and do not inline the spec in the call."},{"role":"assistant","content":"```saw\nimport \"mutRecTest.cry\";\n\nlet {{ f = streamFibs    : [8] -> [32] }};\nlet {{ g = streamFibsAlt : [8] -> [32] }};\nlet {{ h = recFibs       : [8] -> [32] }};\nlet {{ i = recFibs2      : [8] -> [32] }};\n\nlet thm1 = {{ f === g }};\nprove_print abc thm1;\n\n\/\/ FIXME, this makes the simulator crash the stack\n\/\/let thm2 x = f x == h x;\n\/\/ prove_print abc thm2;\n```"}]}
{"filename":"saw-script\/examples\/misc\/define.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/examples\/misc\/define.saw, defines a let-bound specification named twice_id_spec that symbolically models the function twice_id with input of type [8] -> [8], uses llvm_fresh_var to create symbolic inputs, and verifies that twice_id behaves as the twice function applied to ident on 8-bit vectors. Include minimal preconditions to ensure termination and safety, and invoke llvm_verify to check the implementation against twice_id_spec."},{"role":"assistant","content":"```saw\nlet twice = {{ \\f x -> f (f x) }};\nlet ident = {{ \\x -> x }};\n\nprint_term {{ twice ident : [8] -> [8] }};\ntwice_id <- define \"twice_id\" {{ twice ident : [8] -> [8] }};\nprint_term twice_id;\nprint {{ twice_id 5 }};\n```"}]}
{"filename":"saw-script\/examples\/misc\/uninterp.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from saw-script\/examples\/misc\/uninterp.saw, defines a let-bound specification named f_spec that symbolically inputs a 64-bit integer x using llvm_fresh_var, calls the function f with x, and verifies the property that (f(x) + f(x)) == (f(x) * 2). Ensure the spec uses let-binding and references the exact function symbol f with its 64-bit integer argument. Include any minimal preconditions needed for safety or termination. Do not inline the spec in the call but bind it to f_spec before proving it."},{"role":"assistant","content":"```saw\nlet {{ f (x:[64]) = x * x }};\nfsym <- define \"f\" {{ f }};\nlet {{ thm x = ((fsym x) + (fsym x)) == ((fsym x) * 2) }};\nprove_print abc {{ thm }};\n\/\/write_aig \"uninterp.aig\" {{ \\x -> ~(thm x) }};\nprove_print yices {{ thm }};\n```"}]}
{"filename":"saw-script\/examples\/misc\/prove.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the given source file, defines a let-bound specification named f_spec that models the function f with an 8-bit input, uses llvm_fresh_var to create a symbolic input variable, and proves that for all inputs, (x + x) equals (1 * x) as implemented in the LLVM function f. The harness should call llvm_load_module with the provided source path, reference the exact function symbol f, and include minimal preconditions if necessary for safety or termination."},{"role":"assistant","content":"```saw\n\/\/ f : [8] -> Bit;\n\/\/ f x = (x + x) == (1 * x);\n\n\nlet f = {{ \\ (x : [8]) -> (x + x) == (1 * x) }};\nr <- prove abc f;\ncaseProofResult r\n  (\\thm -> print \"Q.E.D.\")\n  (\\v -> do { print \"Oops.\" ; print v; print {{ f v }}; });\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/examples\/sv-comp\/parity.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module parity.bc, defines a let-bound spec main_spec for the function main with signature int main(), uses llvm_fresh_var to create a symbolic unsigned int input v, adds any necessary preconditions for safe loop termination, and verifies main against main_spec with llvm_verify. Also assume the specifications for __VERIFIER_error and __VERIFIER_nondet_uint as llvm_unsafe_assume_spec bindings named error_ov and nondet_int_ov respectively, and include them in the verification obligations list.\n\n# Source code:\nparity.c\n```C\nextern void __VERIFIER_error() __attribute__ ((__noreturn__));\n\nextern unsigned int __VERIFIER_nondet_uint(void);\nvoid __VERIFIER_assert(int cond) {\n  if (!(cond)) {\n    ERROR: __VERIFIER_error();\n  }\n  return;\n}\n\/* see https:\/\/graphics.stanford.edu\/~seander\/bithacks.html#ParityNaive *\/\n#include <assert.h>\n\nint main()\n{\n    unsigned int v = __VERIFIER_nondet_uint();\n    unsigned int v1;\n    unsigned int v2;\n    char parity1;\n    char parity2;\n\n    \/* naive parity *\/\n    v1 = v;\n    parity1 = (char)0;\n    while (v1 != 0) {\n        if (parity1 == (char)0) {\n            parity1 = (char)1;\n        } else {\n            parity1 = (char)0;\n        }\n        v1 = v1 & (v1 - 1U);\n    }\n\n    \/* smart parity *\/\n    v2 = v;\n    parity2 = (char)0;\n    v2 = v2 ^ (v2 >> 1u);\n    v2 = v2 ^ (v2 >> 2u);\n    v2 = (v2 & 286331153U) * 286331153U; \/* 286331153U == 0x11111111U *\/\n    if (((v2 >> 28u) & 1u) == 0) {\n        parity2 = (char)0;\n    } else {\n        parity2 = (char)1;\n    }\n\n    __VERIFIER_assert(parity1 == parity2);\n\n    return 0;\n}\n\n```"},{"role":"assistant","content":"```saw\ninclude \"sv-comp.saw\";\n\nm <- llvm_load_module \"parity.bc\";\nlet assume = llvm_unsafe_assume_spec m;\nerror_ov <- assume \"__VERIFIER_error\" error_spec;\nnondet_int_ov <- assume \"__VERIFIER_nondet_uint\" nondet_int_spec;\nlet ovs = [error_ov, nondet_int_ov];\nllvm_verify m \"main\" ovs true main_spec yices;\n```"}]}
{"filename":"saw-script\/examples\/sv-comp\/sv-comp.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from saw-script\/examples\/sv-comp\/sv-comp.saw. Define let-bound specs for the functions error, assume, nondet_int, and main as per their exact LLVM symbol names. Use llvm_fresh_var to create symbolic 32-bit integer inputs where appropriate, and include minimal preconditions to ensure safety and termination, such as non-zero constraints or valid input ranges. Each spec should call llvm_execute_func with the correct symbolic arguments and specify postconditions or return values as indicated by the function behavior in the SAW excerpt. Do not inline specs; bind them to let names ending with _spec."},{"role":"assistant","content":"```saw\nlet error_spec = do {\n    llvm_precond {{ False }};\n    llvm_execute_func [];\n};\n\nlet assume_spec = do {\n    p <- llvm_fresh_var \"p\" (llvm_int 32);\n    llvm_execute_func [llvm_term p];\n    llvm_postcond {{ p != 0 }};\n};\n\nlet nondet_int_spec = do {\n    llvm_execute_func [];\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_return (llvm_term x);\n};\n\nlet main_spec = do {\n    llvm_execute_func [];\n};\n```"}]}
{"filename":"saw-script\/examples\/fresh-post\/fresh-post-bad.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from source.bc that defines the functions whoknows, one, example, and bad. Define a let-bound spec named whoknows_spec that symbolically executes whoknows with no arguments, introduces a fresh 32-bit integer variable y, and enforces the postcondition y < 0x0000FFFF, returning y. Define a let-bound spec named bad_spec that symbolically executes bad with no arguments and returns the constant 0 as a 32-bit term. Use llvm_fresh_var for symbolic inputs and llvm_execute_func to call functions. Use llvm_unsafe_assume_spec to associate whoknows_spec with whoknows, then verify bad against bad_spec assuming whoknows_spec. Ensure no inline do blocks are passed directly and no comments appear in the SAW code.\n\n# Source code:\nsource.c\n```C\nextern int whoknows(void);\n\nint one(void) {\n  return 1;\n}\n\nint example(void) {\n  int y = whoknows();\n  return y-y;\n}\n\nint bad(void) {\n  int x = whoknows();\n  int y = whoknows();\n  return x-y;\n}\n\n```"},{"role":"assistant","content":"```saw\nlet whoknows_spec : CrucibleSetup () = do {\n  llvm_execute_func [];\n  y <- llvm_fresh_var \"y\" (llvm_int 32);\n  llvm_postcond {{ y < 0x0000FFFF }};\n  llvm_return (llvm_term y);\n};\n\nlet bad_spec : CrucibleSetup () = do {\n  llvm_execute_func [];\n  llvm_return (llvm_term {{0:[32]}});\n};\n\nm <- llvm_load_module \"source.bc\";\nwhoknows <- llvm_unsafe_assume_spec m \"whoknows\" whoknows_spec;\nfails (llvm_verify m \"bad\" [whoknows] false bad_spec abc);\n```"}]}
{"filename":"saw-script\/examples\/partial-spec\/partial-spec.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from source.bc, defines let-bound specs inc_spec and use_inc_spec for the functions inc and use_inc respectively. Use llvm_fresh_var to create symbolic inputs for the struct my_struct pointer in inc_spec, set minimal preconditions to ensure safety, and verify that inc increments the counter field by one. In use_inc_spec, verify that use_inc returns 1. Then verify both functions using llvm_verify with the loaded module and the defined specs.\n\n# Source code:\nsource.c\n```C\nstruct my_nested {\n        int counter1;\n        int counter2;\n};\n\nstruct my_struct {\n    unsigned int counter;\n    char *p;\n};\n\nvoid inc(struct my_struct *s) {\n        s->counter++;\n}\n\nunsigned int use_inc(void) {\n        struct my_struct m = { .counter = 0 };\n        inc(&m);\n        return m.counter;\n}\n\n```"},{"role":"assistant","content":"```saw\nlet inc_spec : CrucibleSetup () = do {\n  m <- llvm_alloc (llvm_alias \"struct.my_struct\");\n  counter <- llvm_fresh_var \"counter\" (llvm_int 32);\n  llvm_points_to (llvm_field m \"counter\") (llvm_term counter);\n  llvm_execute_func [m];\n  llvm_points_to (llvm_field m \"counter\") (llvm_term {{counter+1}});\n};\n\nlet use_inc_spec : CrucibleSetup () = do {\n  llvm_execute_func [];\n  llvm_return (llvm_term {{1:[32]}});\n};\n\nlet main : TopLevel () = do {\n    m <- llvm_load_module \"source.bc\";\n    inc <- llvm_verify m \"inc\" [] false inc_spec abc;\n    llvm_verify m \"use_inc\" [inc] false use_inc_spec abc;\n    print \"done\";\n};\n```"}]}
{"filename":"saw-script\/examples\/multi-override\/multi-override.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from source.bc and verifies the following C functions with let-bound specs: (1) identity_spec verifying int identity(int x) with a symbolic int input; (2) example_spec verifying int example(void) with no inputs; (3) sum_spec verifying unsigned int sum(unsigned int *arr, int n) with a symbolic array and symbolic length n, adding preconditions to ensure n is within array bounds; (4) example_sums_spec verifying unsigned int example_sums(void) with no inputs; (5) set_myglobal_spec verifying void add_myglobal(int x) with a symbolic int input and proper global allocation and initialization; (6) myglobal_example_spec verifying int myglobal_example(void) with no inputs. Use llvm_fresh_var for symbolic inputs, llvm_alloc_global for globals, and llvm_points_to for memory state. Do not inline specs; bind each spec to a let variable before use. Reference exact function names as in source.c.\n\n# Source code:\nsource.c\n```C\nint identity(int x) { return x; }\nint example(void) { return identity(1) + identity(2); }\nint bad_example(void) { return identity(3); }\n\nunsigned int sum (unsigned int *arr, int n) {\n        unsigned int acc = 0;\n        for (int i = 0; i < n; i++) {\n            acc += arr[i];\n        }\n        return acc;\n}\nunsigned int example_sums(void) {\n        unsigned int nums[10] = {0,1,2,3,4,6,7,8,9};\n        return sum(nums, 10) + sum(nums+2,6);\n}\n\nint myglobal;\n\nvoid add_myglobal(int x) { myglobal = myglobal * myglobal; myglobal += x; }\nint myglobal_example(void) {\n  myglobal = 0;\n  add_myglobal(10);\n  add_myglobal(20);\n  return myglobal;\n}\n\n```"},{"role":"assistant","content":"```saw\nimport \"imports.cry\";\n\nlet identity_spec n : CrucibleSetup () = do {\n  llvm_execute_func [llvm_term n];\n  llvm_return (llvm_term n);\n};\n\nlet example_spec : CrucibleSetup () = do {\n  llvm_execute_func [];\n  llvm_return (llvm_term {{3:[32]}});\n};\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet sum_spec n : CrucibleSetup() = do {\n  (arr,arrp) <- ptr_to_fresh \"arr\" (llvm_array n (llvm_int 32));\n\n  llvm_execute_func[arrp, llvm_term {{ `n:[32]}}];\n  llvm_return (llvm_term {{ mysum arr }});\n  llvm_points_to arrp (llvm_term arr);\n};\n\nlet example_sums : CrucibleSetup() = do {\n  llvm_execute_func[];\n  llvm_return (llvm_term {{ 70:[32] }});\n};\n\nlet set_myglobal n : CrucibleSetup() = do {\n  llvm_alloc_global \"myglobal\";\n  old <- llvm_fresh_var \"old\" (llvm_int 32);\n  llvm_precond {{ old < 1000 }};\n  llvm_points_to (llvm_global \"myglobal\") (llvm_term old);\n  llvm_execute_func[llvm_term {{ `n : [32] }}];\n  llvm_points_to (llvm_global \"myglobal\")\n                     (llvm_term {{ `n + old*old : [32] }});\n};\n\nlet myglobal_example : CrucibleSetup() = do {\n  llvm_alloc_global \"myglobal\";\n  llvm_execute_func[];\n  llvm_return (llvm_term {{ 120 : [32] }});\n  llvm_points_to (llvm_global \"myglobal\")\n                 (llvm_term {{ 120 : [32] }});\n};\n\nlet main : TopLevel () = do {\n\n    m <- llvm_load_module \"source.bc\";\n    id1 <- llvm_verify m \"identity\" [] false (identity_spec {{1:[32]}}) abc;\n    id2 <- llvm_verify m \"identity\" [] false (identity_spec {{2:[32]}}) abc;\n    llvm_verify m \"example\"     [id1,id2] false example_spec z3;\n    \/\/llvm_verify \"bad_example\" [id1,id2] false example_spec (do { print_goal; assume_unsat; });\n\n    sum3  <- llvm_verify m \"sum\" [] false (sum_spec  3) z3;\n    sum6  <- llvm_verify m \"sum\" [] false (sum_spec  6) z3;\n    sum10 <- llvm_verify m \"sum\" [] false (sum_spec 10) z3;\n    sum12 <- llvm_verify m \"sum\" [] false (sum_spec 12) z3;\n    llvm_verify m \"example_sums\" [sum3,sum12, sum6,sum10] false example_sums z3;\n\n    set10 <- llvm_verify m \"add_myglobal\" [] false (set_myglobal 10) z3;\n    set20 <- llvm_verify m \"add_myglobal\" [] false (set_myglobal 20) z3;\n    set30 <- llvm_verify m \"add_myglobal\" [] false (set_myglobal 30) z3;\n    llvm_verify m \"myglobal_example\" [set10,set20,set30] false myglobal_example z3;\n    llvm_verify m \"myglobal_example\" [set20,set30,set10] false myglobal_example z3;\n    llvm_verify m \"myglobal_example\" [set30,set10,set20] false myglobal_example z3;\n    print \"done\";\n};\n```"}]}
{"filename":"saw-script\/examples\/llvm\/ptr.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module ptr.bc that verifies the functions add, clear, and copy defined in ptr.c. Define let-bound specs named add_spec, clear_spec, and copy_spec respectively. For add_spec, create two fresh 32-bit integer pointers x and y, allocate and initialize them symbolically, execute the add function with these pointers, and verify the return value equals the sum of the pointed-to values. For clear_spec, create a fresh array of 10 32-bit integers, allocate and initialize it symbolically, execute clear with this array pointer, and verify the array is zeroed. For copy_spec, create two fresh arrays of 10 32-bit integers a and b, allocate and initialize them symbolically, execute copy with their pointers, and verify that a equals b after execution. Use llvm_fresh_var and llvm_alloc as needed and include minimal preconditions for safety. Do not inline specs in calls; bind them with let. Use llvm_execute_func and llvm_points_to accordingly.\n\n# Source code:\nptr.c\n```C\nunsigned int add(unsigned int *x, unsigned int *y) {\n    return *x + *y;\n}\n\nvoid clear(int a[10]) {\n    for(int i = 0; i < 10; i++) {\n        a[i] = 0;\n    }\n}\n\nvoid copy(int a[10], int b[10]) {\n    for(int i = 0; i < 10; i++) {\n        a[i] = b[i];\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet add_setup = do {\n    (x, xp) <- ptr_to_fresh \"x\" (llvm_int 32);\n    (y, yp) <- ptr_to_fresh \"y\" (llvm_int 32);\n    llvm_execute_func [xp, yp];\n    llvm_return (llvm_term {{ x + y : [32] }});\n};\n\nlet clear_setup = do {\n    (a, ap) <- ptr_to_fresh \"a\" (llvm_array 10 (llvm_int 32));\n    llvm_execute_func [ap];\n    llvm_points_to ap (llvm_term {{ zero : [10][32] }});\n};\n\nlet copy_setup = do {\n    (a, ap) <- ptr_to_fresh \"a\" (llvm_array 10 (llvm_int 32));\n    (b, bp) <- ptr_to_fresh \"b\" (llvm_array 10 (llvm_int 32));\n    llvm_execute_func [ap, bp];\n    llvm_points_to ap (llvm_term b);\n};\n\nlet main : TopLevel () = do {\n    m <- llvm_load_module \"ptr.bc\";\n    add_ms <- llvm_verify m \"add\" [] false add_setup abc;\n    clear_ms <- llvm_verify m \"clear\" [] false clear_setup abc;\n    copy_ms <- llvm_verify m \"copy\" [] false copy_setup abc;\n    print \"Done.\";\n};\n```"}]}
{"filename":"saw-script\/examples\/llvm\/ptrcheck.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"ptrcheck.bc\" that verifies the function \"f\" with signature \"uint32_t f(s*)\". Define a let-bound spec named f_spec that uses llvm_fresh_var to create a symbolic pointer of type \"struct.s*\", allocates and initializes memory for it, and includes minimal preconditions ensuring the pointer is non-null to avoid undefined behavior. Then call llvm_execute_func with the symbolic pointer and verify the function returns the expected result. Do not inline the spec; bind it with let before use.\n\n# Source code:\nptrcheck.c\n```C\n#include <stdint.h>\n#include <stdlib.h>\n\ntypedef struct {\n    uint32_t x;\n    uint32_t y;\n    uint32_t z;\n    uint32_t w;\n} s;\n\nuint32_t f(s* sp) {\n    if(sp == NULL) {\n        return 1;\n    } else if(&(sp->x) == NULL) {\n        return 2;\n    } else if(&(sp->y) == NULL) {\n        return 3;\n    } else if(&(sp->z) == NULL) {\n        return 4;\n    } else if(&(sp->w) == NULL) {\n        return 5;\n    } else {\n        return 0;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nm <- llvm_load_module \"ptrcheck.bc\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nllvm_verify m \"f\" [] false do {\n    (s, sp) <- ptr_to_fresh \"s\" (llvm_alias \"struct.s\");\n    llvm_execute_func [sp];\n    llvm_return (llvm_term {{ 0 : [32] }});\n} abc;\n```"}]}
{"filename":"saw-script\/examples\/llvm\/global.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from global.bc that verifies the functions clear(), set(uint32_t), and get() defined in global.c. Define let-bound specs named clear_spec, set_spec, and get_spec using llvm_fresh_var to create symbolic inputs where needed. For set_spec, create a symbolic 32-bit integer input x and verify that after calling set(x), the global variable g points to x. For clear_spec, verify that after calling clear(), g is zero. For get_spec, initialize g to a symbolic 32-bit integer x, call get(), and verify the returned value equals x. Use llvm_alloc_global and llvm_points_to to model the global variable g. Do not inline the specs in the verify calls; instead, pass the let-bound specs as arguments to llvm_verify.\n\n# Source code:\nglobal.c\n```C\n#include <stdint.h>\n\nuint32_t g;\n\nvoid clear() {\n    g = 0;\n}\n\nvoid set(uint32_t x) {\n    g = x;\n}\n\nuint32_t get() {\n    return g;\n}\n\n```"},{"role":"assistant","content":"```saw\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet clear_setup = do {\n    llvm_alloc_global \"g\";\n    llvm_execute_func [];\n    llvm_points_to (llvm_global \"g\") (llvm_term {{ 0 : [32] }});\n};\n\nlet set_setup = do {\n    llvm_alloc_global \"g\";\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_execute_func [llvm_term x];\n    llvm_points_to (llvm_global \"g\") (llvm_term x);\n};\n\nlet get_setup = do {\n    llvm_alloc_global \"g\";\n    let g = llvm_global \"g\";\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_points_to g (llvm_term x);\n    llvm_execute_func [llvm_term x];\n    llvm_points_to g (llvm_term x);\n    llvm_return (llvm_term x);\n};\n\nlet main : TopLevel () = do {\n    m <- llvm_load_module \"global.bc\";\n    llvm_verify m \"clear\" [] false clear_setup abc;\n    llvm_verify m \"set\" [] false set_setup abc;\n    llvm_verify m \"get\" [] false get_setup abc;\n    print \"Done.\";\n};\n```"}]}
{"filename":"saw-script\/examples\/llvm\/nested.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function 'f' defined in 'nested.bc' compiled from 'nested.c'. Define a let-bound specification 'f_spec' that allocates a symbolic pointer to the struct 't_t', uses symbolic 32-bit integer variables for the nested field 'n.b', sets the appropriate memory points-to conditions for 'p->n.b', executes the function 'f' with the symbolic pointer as input, and returns the symbolic value corresponding to 'p->n.b'. Use 'llvm_fresh_var' for symbolic inputs and ensure the spec matches the exact function signature 'uint32_t f(t_t *)'.\n\n# Source code:\nnested.c\n```C\n#include <stdint.h>\n\ntypedef struct s {\n    uint32_t a;\n    uint32_t b;\n} s_t;\n\ntypedef struct t {\n    uint32_t x;\n    s_t n;\n    uint32_t z;\n} t_t;\n\nuint32_t f(t_t *p) {\n    return (p->n).b;\n}\n\n```"},{"role":"assistant","content":"```saw\nlet f_spec = do {\n    tp <- llvm_alloc (llvm_alias \"struct.t\");\n    b <- llvm_fresh_var \"b\" (llvm_int 32);\n\n    \/\/ The following will work if nested.bc is compiled with debug info\n    \/\/ with Clang 3.7 or greater\n    llvm_points_to (llvm_field (llvm_field tp \"n\") \"b\") (llvm_term b);\n\n    \/\/ The following can be a workaround if debug info is not available\n    \/\/llvm_points_to (llvm_elem (llvm_elem tp 1) 1) (llvm_term b);\n\n    llvm_execute_func [tp];\n    llvm_return (llvm_term b);\n};\n\nm <- llvm_load_module \"nested.bc\";\n\nllvm_verify m \"f\" [] false f_spec abc;\n```"}]}
{"filename":"saw-script\/examples\/llvm\/struct.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from struct.bc and defines let-bound specs named set_spec, add_spec, and id_spec for the functions set_indirect, add_indirect, and s_id respectively. Each spec should use llvm_fresh_var to create symbolic inputs matching the function parameters, allocate and initialize memory for the struct s and its unsigned int pointer member x as needed, execute the corresponding function with llvm_execute_func, and specify the expected postconditions using llvm_points_to and llvm_return. Include minimal preconditions to ensure safety and termination, such as valid pointer allocations and array bounds for the two-element unsigned int array pointed to by x.\n\n# Source code:\nstruct.c\n```C\ntypedef struct {\n    unsigned int *x;\n} s;\n\nint add_indirect(s *o) {\n    return (o->x)[0] + (o->x)[1];\n}\n\nvoid set_indirect(s *o) {\n    (o->x)[0] = 0;\n    (o->x)[1] = 0;\n}\n\ns *s_id(s *o) {\n    return o;\n}\n\n```"},{"role":"assistant","content":"```saw\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet set_spec = do {\n    (x, px) <- ptr_to_fresh \"x\" (llvm_array 2 (llvm_int 32));\n    po <- alloc_init (llvm_alias \"struct.s\") (llvm_struct_value [px]);\n    llvm_execute_func [po];\n    llvm_points_to po (llvm_struct_value [px]);\n    llvm_points_to px (llvm_term {{ [0, 0] : [2][32] }});\n};\n\nlet add_spec = do {\n    (x, px) <- ptr_to_fresh \"x\" (llvm_array 2 (llvm_int 32));\n    po <- alloc_init (llvm_alias \"struct.s\") (llvm_struct_value [px]);\n    llvm_execute_func [po];\n    llvm_return (llvm_term {{ x@0 + x@1 }});\n};\n\nlet id_spec = do {\n    (x, px) <- ptr_to_fresh \"x\" (llvm_array 2 (llvm_int 32));\n    po <- alloc_init (llvm_alias \"struct.s\") (llvm_struct_value [px]);\n    llvm_execute_func [po];\n    llvm_return po;\n};\n\nm <- llvm_load_module \"struct.bc\";\nllvm_verify m \"set_indirect\" [] false set_spec abc;\nllvm_verify m \"add_indirect\" [] false add_spec abc;\nllvm_verify m \"s_id\" [] false id_spec abc;\n```"}]}
{"filename":"saw-script\/examples\/llvm\/assert-null.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'assert-null.bc' and defines a let-bound specification named 'f_spec' for the function 'f' with signature 'int f(int *x)'. Use 'llvm_fresh_var' to create a symbolic pointer input for 'x'. Include minimal preconditions to ensure safety. The spec should execute 'f' with the symbolic input and return the expected result based on whether 'x' is null or not. Then verify 'f' against this specification using 'llvm_verify'.\n\n# Source code:\nassert-null.c\n```C\nint f(int *x) {\n    return (x == (int*)0);\n}\n\n```"},{"role":"assistant","content":"```saw\nlet f_spec1 = do {\n    p <- llvm_alloc (llvm_int 32);\n    llvm_execute_func [p];\n    llvm_return (llvm_term {{ 0 : [32] }});\n};\n\nlet f_spec2 = do {\n    llvm_execute_func [llvm_null];\n    llvm_return (llvm_term {{ 1 : [32] }});\n};\n\nm <- llvm_load_module \"assert-null.bc\";\nllvm_verify m \"f\" [] false f_spec1 abc;\nllvm_verify m \"f\" [] false f_spec2 abc;\n```"}]}
{"filename":"saw-script\/examples\/llvm\/basic.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'basic.bc' and defines let-bound specs for verifying the functions 'first', 'second', 'add', and 'dbl' as defined in 'basic.c'. Use llvm_fresh_var to create symbolic 32-bit integer inputs for each function. For 'first' and 'second', specify that 'first(x,y)' returns 'x' and 'second(x,y)' returns 'y'. For 'add(x,y)', specify it returns the sum of 'x' and 'y'. For 'dbl(x)', specify it returns the result of calling 'add(x,x)'. Use llvm_execute_func to execute each function with symbolic inputs and llvm_return to specify expected outputs. Include minimal preconditions if needed for safety or termination. Do not inline specs; bind each spec to a let variable before verification calls.\n\n# Source code:\nbasic.c\n```C\n#include <stdint.h>\nuint32_t first(uint32_t x, uint32_t y) {\n    return x;\n}\n\nuint32_t second(uint32_t x, uint32_t y) {\n    return y;\n}\n\nuint32_t add(uint32_t x, uint32_t y) {\n    return x + y;\n}\n\nuint32_t dbl(uint32_t x) {\n    return add(x, x);\n}\n\n```"},{"role":"assistant","content":"```saw\nlet add_setup = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    y <- llvm_fresh_var \"y\" (llvm_int 32);\n    llvm_execute_func [llvm_term x, llvm_term y];\n    llvm_return (llvm_term {{ x + y : [32] }});\n};\n\nlet dbl_setup = do {\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    llvm_execute_func [llvm_term x];\n    llvm_return (llvm_term {{ x + x : [32] }});\n};\n\nm <- llvm_load_module \"basic.bc\";\nadd_ms <- llvm_verify m \"add\" [] false add_setup abc;\nllvm_verify m \"dbl\" [add_ms] false dbl_setup abc;\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/examples\/llvm\/assert.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from \"assert.bc\" and defines a let-bound specification named f_spec. The spec should symbolically create a 32-bit integer variable x with a precondition x != 0 to ensure safety of the function f(int x). Then execute the function f with this symbolic input. Finally, verify the function f against f_spec using llvm_verify.\n\n# Source code:\nassert.c\n```C\n#include <assert.h>\n\nvoid f(int x) {\n    assert(x != 0);\n}\n\n```"},{"role":"assistant","content":"```saw\nlet f_spec = do {\n  x <- llvm_fresh_var \"x\" (llvm_int 32);\n  llvm_precond {{ x > 0 }};\n  llvm_execute_func [llvm_term x];\n};\n\nm <- llvm_load_module \"assert.bc\";\nllvm_verify m \"f\" [] true f_spec abc;\n```"}]}
{"filename":"saw-script\/examples\/llvm\/nested-full.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'nested.bc' and defines a let-bound specification named 'f_spec'. The specification should create symbolic 32-bit integer variables for the fields 'x', 'a', 'b', and 'z' of the struct 't_t' and its nested struct 's_t' as defined in 'nested.c'. Initialize a pointer to a 't_t' struct with these symbolic values, then execute the function 'f' with this pointer as argument. Finally, assert that the function returns the symbolic variable corresponding to the nested field 'b' of the struct 's_t'. Include any minimal preconditions necessary for safety. Do not inline the specification in the call to 'llvm_verify'.\n\n# Source code:\nnested.c\n```C\n#include <stdint.h>\n\ntypedef struct s {\n    uint32_t a;\n    uint32_t b;\n} s_t;\n\ntypedef struct t {\n    uint32_t x;\n    s_t n;\n    uint32_t z;\n} t_t;\n\nuint32_t f(t_t *p) {\n    return (p->n).b;\n}\n\n```"},{"role":"assistant","content":"```saw\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet f_spec = do {\n    a <- llvm_fresh_var \"a\" (llvm_int 32);\n    b <- llvm_fresh_var \"b\" (llvm_int 32);\n    x <- llvm_fresh_var \"x\" (llvm_int 32);\n    z <- llvm_fresh_var \"z\" (llvm_int 32);\n    let s = (llvm_term {{ (x, (a, b), z) }});\n    p <- alloc_init (llvm_alias \"struct.t\") s;\n    llvm_execute_func [p];\n    llvm_return (llvm_term {{ b }});\n};\n\nm <- llvm_load_module \"nested.bc\";\nllvm_verify m \"f\" [] false f_spec abc;\n```"}]}
{"filename":"saw-script\/examples\/java\/branchsat.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java class BranchTest that defines a let-bound specification named f_spec. The spec should symbolically verify the static method BranchTest.f(int) by using jvm_fresh_var to create a symbolic 32-bit integer input x with a precondition that x is non-negative and less than 10 to ensure termination of the loop. The spec should execute the method with this symbolic input and verify that the return value equals x*(x-1)\/2. Use jvm_load_class to load BranchTest and jvm_verify to verify the method against f_spec.\n\n# Source code:\nBranchTest.java\n```java\nclass BranchTest {\n    static int f(int x) {\n        int r = 0;\n        for(int i = 0; i < x; i++) {\n            r = r + i;\n        }\n        return r;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"BranchTest\";\n\n\/\/ FIXME: make this terminate with the symbolic precondition\n\/\/ The following will not terminate if the last parameter is `false`\njvm_verify c \"f\" [] true\n  do {\n    let x = {{ 6 : [32] }}; \/\/ FIXME\n    \/\/ x <- jvm_fresh_var \"x\" java_int;\n    \/\/ jvm_precond {{ x < 10 }};\n    jvm_execute_func [jvm_term x];\n    jvm_return (jvm_term {{ x * (x - 1) \/ 2 }});\n  }\n  abc;\n```"}]}
{"filename":"saw-script\/examples\/java\/arrays.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java class ArrayTest that defines a let-bound spec for each method: unit_spec, copy_spec, clear_spec, sum_spec, comp_spec, and arr_id_spec. Each spec should use jvm_fresh_var to create symbolic input arrays of length 10 of type java_int, allocate necessary objects and arrays with jvm_alloc_object and jvm_alloc_array, and call the corresponding method (e.g., ArrayTest.unit, ArrayTest.copy) with appropriate arguments. Include minimal preconditions ensuring array lengths are 10 for safe iteration. Use jvm_array_is to assert expected array states after execution, and jvm_return to specify return values where applicable. Do not inline specs; bind them with let. Reference exact method signatures from ArrayTest.java.\n\n# Source code:\nArrayTest.java\n```java\nimport java.util.Arrays;\n\nclass ArrayTest {\n    void unit(int a[]) {\n        for(int i = 0; i < a.length; i++) a[i] = 0;\n        a[0] = 1;\n    }\n\n    void copy(int a[], int b[]) {\n        for(int i = 0; i < a.length; i++) b[i] = a[i];\n    }\n\n    void clear(int a[]) {\n        Arrays.fill(a, 0);\n    }\n\n    int sum(int a[]) {\n        int sum = 0;\n        for(int i = 0; i < a.length; i++) sum += a[i];\n        return sum;\n    }\n\n    void comp(int a[]) {\n        unit(a);\n    }\n\n    int[] arr_id(int a[]) {\n        return a;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"ArrayTest\";\n\ncopy_ms <-\njvm_verify c \"copy\" [] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    b_ref <- jvm_alloc_array 10 java_int;\n    a <- jvm_fresh_var \"a\" (java_array 10 java_int);\n    jvm_array_is a_ref a;\n    jvm_execute_func [this, a_ref, b_ref];\n    jvm_array_is b_ref a;\n  }\n  abc;\n\nunit_ms <-\njvm_verify c \"unit\" [] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    jvm_execute_func [this, a_ref];\n    jvm_array_is a_ref {{ [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] : [10][32] }};\n  }\n  abc;\n\nclear_ms <-\njvm_verify c \"clear\" [] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    jvm_execute_func [this, a_ref];\n    jvm_array_is a_ref {{ zero : [10][32] }};\n  }\n  abc;\n\nsum_ms <-\njvm_verify c \"sum\" [] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    a <- jvm_fresh_var \"a\" (java_array 10 java_int);\n    jvm_array_is a_ref a;\n    jvm_execute_func [this, a_ref];\n    jvm_return (jvm_term {{ sum a }});\n  }\n  abc;\n\ncomp_ms <-\njvm_verify c \"comp\" [unit_ms] false\n  do {\n    this <- jvm_alloc_object \"ArrayTest\";\n    a_ref <- jvm_alloc_array 10 java_int;\n    jvm_execute_func [this, a_ref];\n    jvm_array_is a_ref {{ [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] : [10][32] }};\n  }\n  abc;\n```"}]}
{"filename":"saw-script\/examples\/java\/alloc.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java method Alloc.alloc(int[] dst, int[] src) that loads the Alloc class using java_load_class. Define a let-bound spec named alloc_spec that allocates a fresh Alloc object and two integer arrays dst and src of symbolic length n with a minimal precondition that n is non-negative and within safe bounds. Use jvm_fresh_var to create a symbolic src array, ensure array contents are properly related before and after execution, and verify that after calling alloc, the dst array matches the src array. Do not inline the spec; bind it with let and then verify using jvm_verify referencing alloc_spec.\n\n# Source code:\nAlloc.java\n```java\nclass Alloc {\n    void alloc(int[] dst, int[] src) {\n        int[] tmp = new int[src.length];\n        int i;\n        for(i = 0; i < src.length; i++) {\n            tmp[i] = src[i];\n        }\n        for(i = 0; i < src.length; i++) {\n            dst[i] = tmp[i];\n        }\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"Alloc\";\n\njvm_verify c \"alloc\" [] false\n  do {\n    this <- jvm_alloc_object \"Alloc\";\n    dst_ref <- jvm_alloc_array 10 java_int;\n    src_ref <- jvm_alloc_array 10 java_int;\n    src <- jvm_fresh_var \"src\" (java_array 10 java_int);\n    jvm_array_is src_ref src;\n    jvm_execute_func [this, dst_ref, src_ref];\n    jvm_array_is src_ref src;\n    jvm_array_is dst_ref src;\n  }\n  abc;\n```"}]}
{"filename":"saw-script\/examples\/java\/java_add.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class Add from Add.java using java_load_class. Define a let-bound specification add_spec that symbolically verifies the method Add.add(int x, int y) by allocating an Add object, creating fresh symbolic int variables x and y, executing the add method with these arguments, and returning the sum x + y. Then define a second spec dbl_spec that verifies Add.dbl(int x) by allocating an Add object, creating a fresh symbolic int x, executing dbl, and returning add(x, x). Use jvm_fresh_var for symbolic inputs and jvm_execute_func to call methods. Include minimal preconditions if needed for safety. Do not inline the specs in calls; bind them with let. Do not reference solvers explicitly in the instruction.\n\n# Source code:\nAdd.java\n```java\nclass Add {\n    public int add(int x, int y) {\n        return x + y;\n    }\n\n    public int dbl(int x) {\n        return add(x, x);\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"Add\";\n\nlet {{\n  add : [32] -> [32] -> [32]\n  add x y = x + y\n}};\n\nms <-\n  jvm_verify c \"add\" [] false\n    do {\n      this <- jvm_alloc_object \"Add\";\n      x <- jvm_fresh_var \"x\" java_int;\n      y <- jvm_fresh_var \"y\" java_int;\n      jvm_execute_func [this, jvm_term x, jvm_term y];\n      jvm_return (jvm_term {{ add x y }});\n    }\n    do {\n      unfolding [\"add\"];\n      z3;\n    };\n\nms' <-\n  jvm_verify c \"dbl\" [ms] false\n    do {\n      this <- jvm_alloc_object \"Add\";\n      x <- jvm_fresh_var \"x\" java_int;\n      jvm_execute_func [this, jvm_term x];\n      jvm_return (jvm_term {{ add x x }});\n    }\n    z3;\n\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/examples\/java\/staticfield.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class sfield.StaticField using java_load_class. Define let-bound specs named setx_spec and getx_spec that symbolically verify the methods setx and getx respectively. Use jvm_fresh_var to create symbolic integer inputs where needed. For setx_spec, verify that after executing setx with a symbolic integer argument, the static field sfield\/StaticField.x equals that argument. For getx_spec, assume the static field sfield\/StaticField.x holds a symbolic integer, execute getx, and verify that the return value equals the static field value. Use jvm_execute_func and jvm_return accordingly. Do not inline the specs; bind them with let. Do not include comments or solver references."},{"role":"assistant","content":"```saw\nc <- java_load_class \"sfield.StaticField\";\n\nms_setx <-\n  jvm_verify c \"setx\" [] false\n    do {\n      newx <- jvm_fresh_var \"newx\" java_int;\n      jvm_execute_func [jvm_term newx];\n      jvm_static_field_is \"sfield\/StaticField.x\" (jvm_term newx);\n    }\n    abc;\n\nms_getx <-\n  jvm_verify c \"getx\" [] false\n    do {\n      x <- jvm_fresh_var \"newx\" java_int;\n      jvm_static_field_is \"sfield\/StaticField.x\" (jvm_term x);\n      jvm_execute_func [];\n      jvm_return (jvm_term x);\n    }\n    abc;\n\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/examples\/java\/get.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java class method Get.get with signature int get(int[], int). Define a let-bound spec named get_spec using jvm_fresh_var for the integer index parameter j. Allocate a Get object and an integer array of length 4. Add a precondition that j is less than or equal to 3 to ensure safe array access. Execute the get method with symbolic inputs, specify that the array may be modified, and assert that the method returns the value at index j of the array. Use jvm_load_class and jvm_verify accordingly.\n\n# Source code:\nGet.java\n```java\nclass Get {\n    int get(int a[], int j) {\n        for(int i = 0; i < 4; i++) a[i] = i;\n        return a[j];\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"Get\";\n\njvm_verify c \"get\" [] false\n  do {\n    this <- jvm_alloc_object \"Get\";\n    a <- jvm_alloc_array 4 java_int;\n    j <- jvm_fresh_var \"j\" java_int;\n    jvm_precond {{ j <= 3 }};\n    jvm_execute_func [this, a, jvm_term j];\n    jvm_modifies_array a;\n    jvm_return (jvm_term {{ j }});\n  }\n  abc;\n```"}]}
{"filename":"saw-script\/examples\/java\/fields.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java class Fields defined in Fields.java. Use java_load_class to load the Fields class. Define let-bound specs named setx_spec, sety_spec, unitx_spec, and unity_spec. Each spec should allocate a new Fields object, create fresh symbolic variables for method arguments where applicable (e.g., newx:int for setx, newy:long for sety), execute the corresponding method (setx, sety, unitx, unity) on the object, and verify that the object's fields x or y have the expected values after execution. Use jvm_fresh_var for symbolic inputs and jvm_field_is to assert field values. Include minimal preconditions if needed for safety or termination.\n\n# Source code:\nFields.java\n```java\nclass Fields {\n    int x;\n    long y;\n\n    void setx(int newx) {\n        this.x = newx;\n    }\n\n    void sety(long newy) {\n        this.y = newy;\n    }\n\n    void unitx() {\n        this.x = 1;\n    }\n\n    void unity() {\n        this.y = 1;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"Fields\";\n\nms_setx <-\njvm_verify c \"setx\" [] false\n  do {\n    this <- jvm_alloc_object \"Fields\";\n    newx <- jvm_fresh_var \"newx\" java_int;\n    jvm_execute_func [this, jvm_term newx];\n    jvm_field_is this \"x\" (jvm_term newx);\n  }\n  abc;\n\nms_sety <-\njvm_verify c \"sety\" [] false\n  do {\n    this <- jvm_alloc_object \"Fields\";\n    newy <- jvm_fresh_var \"newy\" java_long;\n    jvm_execute_func [this, jvm_term newy];\n    jvm_field_is this \"y\" (jvm_term newy);\n  }\n  abc;\n\nms_unitx <-\njvm_verify c \"unitx\" [] false\n  do {\n    this <- jvm_alloc_object \"Fields\";\n    jvm_execute_func [this];\n    jvm_field_is this \"x\" (jvm_term {{ 1 : [32] }});\n  }\n  abc;\n\nms_unity <-\njvm_verify c \"unity\" [] false\n  do {\n    this <- jvm_alloc_object \"Fields\";\n    jvm_execute_func [this];\n    jvm_field_is this \"y\" (jvm_term {{ 1 : [64] }});\n  }\n  abc;\n\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/examples\/java\/return.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java class Return that defines let-bound specs for the methods fill(int), fillwrap(int), newSimple(int,int), newSimpleWrap(int,int), and newSimpleWrap2(int,int). Use jvm_fresh_var to create symbolic integer inputs for each method. For fill and fillwrap, specify that the returned int array has length 5 with all elements equal to the input. For newSimple and newSimpleWrap, specify that the returned SimpleObj has fields x and y equal to the inputs. For newSimpleWrap2, specify that the method returns the integer 2. Use jvm_execute_func with appropriate symbolic arguments and jvm_return to specify outputs. Then verify each method with jvm_verify referencing the exact method names in the Return class.\n\n# Source code:\nReturn.java\n```java\nclass Return {\n    public static int[] fill(int n) {\n        int[] x = new int[5];\n        for (int i = 0; i < 5; i++) x[i] = n;\n        return x;\n    }\n\n    public static SimpleObj newSimple(int x, int y) {\n        SimpleObj o = new SimpleObj();\n        o.x = x;\n        o.y = y;\n        return o;\n    }\n\n    public static int[] fillwrap(int n) {\n        return fill(n);\n    }\n\n    public static SimpleObj newSimpleWrap(int x, int y) {\n        return newSimple(x, y);\n    }\n\n    public static int newSimpleWrap2(int x, int y) {\n        SimpleObj o = newSimple(x, y);\n        return 2;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(fill(22)[3]);\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"Return\";\n\nlet fill_spec =\n  do {\n    x <- jvm_fresh_var \"x\" java_int;\n    jvm_execute_func [jvm_term x];\n    aref <- jvm_alloc_array 5 java_int;\n    jvm_array_is aref {{ [x, x, x, x, x] }};\n    jvm_return aref;\n  };\n\nfill_ov <- jvm_verify c \"fill\" [] false fill_spec abc;\njvm_verify c \"fillwrap\" [fill_ov] false fill_spec abc;\n\nlet newSimple_spec =\n  do {\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [jvm_term x, jvm_term y];\n    ref <- jvm_alloc_object \"SimpleObj\";\n    jvm_field_is ref \"x\" (jvm_term x);\n    jvm_field_is ref \"y\" (jvm_term y);\n    jvm_return ref;\n  };\n\nnewSimple_ov <- jvm_verify c \"newSimple\" [] false newSimple_spec abc;\njvm_verify c \"newSimpleWrap\" [newSimple_ov] false newSimple_spec abc;\n\njvm_verify c \"newSimpleWrap2\" [newSimple_ov] false\n  do {\n    x <- jvm_fresh_var \"x\" java_int;\n    y <- jvm_fresh_var \"y\" java_int;\n    jvm_execute_func [jvm_term x, jvm_term y];\n    jvm_return (jvm_term {{ 2 : [32] }});\n  }\n  abc;\n```"}]}
{"filename":"saw-script\/examples\/java\/java_types.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class JavaTypes using java_load_class. Define let-bound specs for each setter method (e.g., bool_set, byte_set, etc.) that allocate a JavaTypes object, create a fresh symbolic variable of the appropriate Java type, execute the setter with these inputs, and verify the corresponding field is set to the symbolic value. Similarly, define specs for each getter method that allocate the object, set the field to a fresh symbolic variable, execute the getter, and verify the return value matches the field. For array setters and getters (e.g., bool_aset, bool_aget), allocate arrays of length 4 with the appropriate element type, execute the method, and verify the field or return value accordingly. Use jvm_fresh_var for symbolic inputs and jvm_alloc_object\/array for allocations. Then invoke jvm_verify on each method with the corresponding spec. Do not inline specs; bind them with let. Reference exact method names and Java types from JavaTypes.java.\n\n# Source code:\nJavaTypes.java\n```java\nclass JavaTypes {\n    boolean boolfld;\n    byte    bfld;\n    char    cfld;\n    short   sfld;\n    int     ifld;\n    long    lfld;\n    boolean[] boolafld;\n    byte[]  bafld;\n    char[]  cafld;\n    short[] safld;\n    int[]   iafld;\n    long[]  lafld;\n\n    void bool_set (boolean b)  { boolfld = b; }\n    void byte_set (byte b)  { bfld = b; }\n    void char_set (char c)  { cfld = c; }\n    void short_set(short s) { sfld = s; }\n    void int_set  (int i)   { ifld = i; }\n    void long_set (long l)  { lfld = l; }\n\n    void bool_aset (boolean[] ba)  { boolafld = ba; }\n    void byte_aset (byte[] ba)  { bafld = ba; }\n    void char_aset (char[] ca)  { cafld = ca; }\n    void short_aset(short[] sa) { safld = sa; }\n    void int_aset  (int[] ia)   { iafld = ia; }\n    void long_aset (long[] la)  { lafld = la; }\n\n    boolean  bool_get () { return boolfld; }\n    byte  byte_get () { return bfld; }\n    char  char_get () { return cfld; }\n    short short_get() { return sfld; }\n    int   int_get  () { return ifld; }\n    long  long_get () { return lfld; }\n\n    boolean[]  bool_aget () { return boolafld; }\n    byte[]  byte_aget () { return bafld; }\n    char[]  char_aget () { return cafld; }\n    short[] short_aget() { return safld; }\n    int[]   int_aget  () { return iafld; }\n    long[]  long_aget () { return lafld; }\n}\n\n```"},{"role":"assistant","content":"```saw\nset_base 16;\n\nc <- java_load_class \"JavaTypes\";\n\nlet set_spec fname ty =\n  do {\n    this <- jvm_alloc_object \"JavaTypes\";\n    x <- jvm_fresh_var \"x\" ty;\n    jvm_execute_func [this, jvm_term x];\n    jvm_field_is this fname (jvm_term x);\n  };\n\nlet get_spec fname ty =\n  do {\n    this <- jvm_alloc_object \"JavaTypes\";\n    x <- jvm_fresh_var \"x\" ty;\n    jvm_field_is this fname (jvm_term x);\n    jvm_execute_func [this];\n    jvm_return (jvm_term x);\n  };\n\nlet aset_spec fname len ty =\n  do {\n    this <- jvm_alloc_object \"JavaTypes\";\n    aref <- jvm_alloc_array len ty;\n    jvm_execute_func [this, aref];\n    jvm_field_is this fname aref;\n  };\n\nlet aget_spec fname len ty =\n  do {\n    this <- jvm_alloc_object \"JavaTypes\";\n    aref <- jvm_alloc_array len ty;\n    jvm_field_is this fname aref;\n    jvm_execute_func [this];\n    jvm_return aref;\n  };\n\nlet verify_set mname fname ty = jvm_verify c mname [] false (set_spec fname ty) abc;\nlet verify_get mname fname ty = jvm_verify c mname [] false (get_spec fname ty) abc;\nlet verify_aset mname fname n ty = jvm_verify c mname [] false (aset_spec fname n ty) abc;\nlet verify_aget mname fname n ty = jvm_verify c mname [] false (aget_spec fname n ty) abc;\n\nverify_set \"bool_set\"  \"boolfld\" java_bool;\nverify_set \"byte_set\"  \"bfld\" java_byte;\nverify_set \"char_set\"  \"cfld\" java_char;\nverify_set \"short_set\" \"sfld\" java_short;\nverify_set \"int_set\"   \"ifld\" java_int;\nverify_set \"long_set\"  \"lfld\" java_long;\n\nverify_get \"bool_get\"  \"boolfld\" java_bool;\nverify_get \"byte_get\"  \"bfld\" java_byte;\nverify_get \"char_get\"  \"cfld\" java_char;\nverify_get \"short_get\" \"sfld\" java_short;\nverify_get \"int_get\"   \"ifld\" java_int;\nverify_get \"long_get\"  \"lfld\" java_long;\n\nverify_aset \"bool_aset\"  \"boolafld\" 4 java_bool;\nverify_aset \"byte_aset\"  \"bafld\" 4 java_byte;\nverify_aset \"char_aset\"  \"cafld\" 4 java_char;\nverify_aset \"short_aset\" \"safld\" 4 java_short;\nverify_aset \"int_aset\"   \"iafld\" 4 java_int;\nverify_aset \"long_aset\"  \"lafld\" 4 java_long;\n\nverify_aget \"bool_aget\"  \"boolafld\" 4 java_bool;\nverify_aget \"byte_aget\"  \"bafld\" 4 java_byte;\nverify_aget \"char_aget\"  \"cafld\" 4 java_char;\nverify_aget \"short_aget\" \"safld\" 4 java_short;\nverify_aget \"int_aget\"   \"iafld\" 4 java_int;\nverify_aget \"long_aget\"  \"lafld\" 4 java_long;\n```"}]}
{"filename":"saw-script\/examples\/java\/classtype.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java method ClassType.id with signature int id(Object). Define a let-bound spec named id_spec that allocates a fresh ClassType object and a fresh java.lang.Object as symbolic inputs using jvm_fresh_var or jvm_alloc_object. Execute the method with these symbolic inputs and specify the expected return value. Include minimal preconditions to ensure safe execution if needed. Use the jvm_* backend functions, referencing the exact class and method names from ClassType.java. Do not inline the spec; bind it with let before passing to jvm_verify.\n\n# Source code:\nClassType.java\n```java\nclass ClassType {\n    int id(Object x) {\n        return 0;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"ClassType\";\n\njvm_verify c \"id\" [] false\n  do {\n    this <- jvm_alloc_object \"ClassType\";\n    x_ref <- jvm_alloc_object \"java.lang.Object\";\n    jvm_execute_func [this, x_ref];\n    jvm_return (jvm_term {{ 0 : [32] }});\n  }\n  abc;\n```"}]}
{"filename":"saw-script\/examples\/java\/arrayfield.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the Java class ArrayField that defines a let-bound specification named init_spec. The spec should symbolically allocate an ArrayField object, create a fresh symbolic integer variable x, and call the init method with x as argument. It should allocate a fresh integer array of length 5, assert that the object's field a points to this array, and verify that all elements of the array are equal to x. Include any necessary preconditions for safe array access and method execution. Use jvm_load_class and jvm_* functions accordingly, referencing the exact method signature ArrayField.init(int).\n\n# Source code:\nArrayField.java\n```java\nclass ArrayField {\n    int a[];\n    void init(int x) {\n        int[] na = new int[5];\n        for(int i = 0; i < 5; i++) na[i] = x;\n        a = na;\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nc <- java_load_class \"ArrayField\";\n\njvm_verify c \"init\" [] false\n  do {\n    this <- jvm_alloc_object \"ArrayField\";\n    x <- jvm_fresh_var \"x\" java_int;\n    jvm_execute_func [this, jvm_term x];\n    na <- jvm_alloc_array 5 java_int;\n    jvm_field_is this \"a\" na;\n    jvm_array_is na {{ [x, x, x, x, x] }};\n  }\n  abc;\n```"}]}
{"filename":"saw-script\/examples\/chacha20\/chacha20.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from chacha20.bc that verifies the function crypto_stream_chacha20 with signature int crypto_stream_chacha20(unsigned char* out, unsigned long long olen, unsigned int counter, const unsigned char* nonce, const unsigned char* key). Define a let-bound spec named crypto_stream_chacha20_spec that uses llvm_fresh_var to create symbolic inputs for out (pointer to an array of bytes), olen (length as a 64-bit integer), counter (32-bit integer), nonce (pointer to 12-byte array), and key (pointer to 32-byte array). Add minimal preconditions to ensure safe memory access and termination. The spec should execute the function with these symbolic inputs and specify expected postconditions using the imported Cryptol chacha20 module if needed. Do not inline the spec in the verify call.\n\n# Source code:\nchacha20.c\n```C\n\/*\n** Portable ChaCha20\/8 implementation. Based on RFC 7539.\n** Copyright (C) 2015-2016 Austin Seipp. Released in the Public Domain.\n*\/\n\n#include \"chacha20.h\"\n\nstatic unsigned int\nl32(unsigned int x,unsigned int n)\n{\n  \/* See: http:\/\/blog.regehr.org\/archives\/1063 *\/\n  return (x<<n) | (x>>(-n&31));\n}\n\nstatic unsigned int\nload32(const unsigned char* x)\n{\n  unsigned int u = x[3];\n  u = (u<<8)|x[2];\n  u = (u<<8)|x[1];\n  return (u<<8)|x[0];\n}\n\nstatic void\nstore32(unsigned char *x,unsigned int u)\n{\n  int i;\n  for (i=0; i < 4; ++i) { x[i] = u; u >>= 8; }\n}\n\nstatic void\nqround(unsigned int* x,\n       unsigned int a,\n       unsigned int b,\n       unsigned int c,\n       unsigned int d)\n{\n  x[a] = x[a]+x[b]; x[d] = l32(x[d]^x[a],16);\n  x[c] = x[c]+x[d]; x[b] = l32(x[b]^x[c],12);\n  x[a] = x[a]+x[b]; x[d] = l32(x[d]^x[a], 8);\n  x[c] = x[c]+x[d]; x[b] = l32(x[b]^x[c], 7);\n}\n\nstatic void\ncore(unsigned char out[64],\n     const unsigned int in[16])\n{\n  unsigned int x[16];\n  int i;\n\n  \/* Copy input block *\/\n  for (i = 0; i < 16; ++i) { x[i] = in[i]; }\n\n  \/* Ten iterations, two rounds each iteration *\/\n  for (i = 0; i < 10; ++i) {\n    \/* Column round *\/\n    qround(x, 0, 4, 8,  12);\n    qround(x, 1, 5, 9,  13);\n    qround(x, 2, 6, 10, 14);\n    qround(x, 3, 7, 11, 15);\n    \/* Diagonal round *\/\n    qround(x, 0, 5, 10, 15);\n    qround(x, 1, 6, 11, 12);\n    qround(x, 2, 7, 8,  13);\n    qround(x, 3, 4, 9,  14);\n  }\n\n  for (i = 0; i < 16; ++i) { x[i] = x[i] + in[i]; }      \/* Add input *\/\n  for (i = 0; i < 16; ++i) { store32(out+(4*i), x[i]); } \/* Output *\/\n}\n\nstatic void\nkexp(unsigned int* st,\n     const unsigned int counter,\n     const unsigned char* nonce,\n     const unsigned char* key)\n{\n  \/* Constants *\/\n  st[0]  = 0x61707865;\n  st[1]  = 0x3320646e;\n  st[2]  = 0x79622d32;\n  st[3]  = 0x6b206574;\n  \/* 4-11: key bytes *\/\n  st[4]  = load32(key);\n  st[5]  = load32(key+4);\n  st[6]  = load32(key+8);\n  st[7]  = load32(key+12);\n  st[8]  = load32(key+16);\n  st[9]  = load32(key+20);\n  st[10] = load32(key+24);\n  st[11] = load32(key+28);\n  \/* Counter + Nonce *\/\n  st[12] = counter;\n  st[13] = load32(nonce);\n  st[14] = load32(nonce+4);\n  st[15] = load32(nonce+8);\n}\n\nint\ncrypto_stream_chacha20_xor(unsigned char* out,\n                           const unsigned char* msg,\n                           unsigned long long mlen,\n                           const unsigned int counter,\n                           const unsigned char* nonce,\n                           const unsigned char* key)\n{\n  unsigned long long i;\n  unsigned int st[16];\n  unsigned char blk[64];\n\n  kexp(st, counter, nonce, key);\n\n  for(;;) {\n    \/* Advance state *\/\n    core(blk, st);\n    st[12] = st[12]+1;\n\n    \/* Fast path *\/\n    if (mlen <= 64) {\n      for (i = 0; i < mlen; ++i) out[i] = msg[i] ^ blk[i];\n      return 0;\n    }\n\n    \/* Normal path *\/\n    for (i = 0; i < 64; ++i) { out[i] = msg[i] ^ blk[i]; }\n    mlen -= 64;\n    msg += 64;\n    out += 64;\n  }\n  return 0;\n}\n\nint\ncrypto_stream_chacha20(unsigned char* out,\n                       unsigned long long olen,\n                       unsigned int counter,\n                       const unsigned char* nonce,\n                       const unsigned char* key)\n{\n  \/* Zero the output before encrypting it. *\/\n  for (unsigned long long i=0; i < olen; ++i) { out[i] = 0; }\n\n  return crypto_stream_chacha20_xor(out, out, olen, counter, nonce, key);\n}\n\n\/* -------------------------------------------------------------------------- *\/\n\/* -- Testing machinery ----------------------------------------------------- *\/\n\n#if defined(WITH_TESTS)\n#include <stdio.h>\n#include <stdlib.h>\n\n\/* Note: why don't we use memset\/memcmp? CompCert interpreter compatibility. *\/\nstatic void\nclear(unsigned char* o, unsigned int n)\n{\n  unsigned int i = 0;\n  for (; i < n; i++) o[i] = 0;\n}\n\nstatic int\nverify(unsigned char* x, unsigned char* y, unsigned int n)\n{\n  unsigned int i = 0, d = 0;\n  for(; i < n; i++) d |= x[i] ^ y[i];\n  return (1 & ((d - 1) >> 8)) - 1;\n}\n\n\/* -------------------------------------------------------------------------- *\/\n\/* -- Test vectors ---------------------------------------------------------- *\/\n\nunsigned char msg1[64] = { 0, };\nunsigned char out1[]\n  = { 0x76, 0xb8, 0xe0, 0xad, 0xa0, 0xf1, 0x3d, 0x90, 0x40, 0x5d,\n      0x6a, 0xe5, 0x53, 0x86, 0xbd, 0x28, 0xbd, 0xd2, 0x19, 0xb8,\n      0xa0, 0x8d, 0xed, 0x1a, 0xa8, 0x36, 0xef, 0xcc, 0x8b, 0x77,\n      0x0d, 0xc7, 0xda, 0x41, 0x59, 0x7c, 0x51, 0x57, 0x48, 0x8d,\n      0x77, 0x24, 0xe0, 0x3f, 0xb8, 0xd8, 0x4a, 0x37, 0x6a, 0x43,\n      0xb8, 0xf4, 0x15, 0x18, 0xa1, 0x1c, 0xc3, 0x87, 0xb6, 0x69,\n      0xb2, 0xee, 0x65, 0x86 };\n\nunsigned char msg2[]\n  = { 0x41, 0x6e, 0x79, 0x20, 0x73, 0x75, 0x62, 0x6d, 0x69, 0x73,\n      0x73, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68,\n      0x65, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x69, 0x6e, 0x74,\n      0x65, 0x6e, 0x64, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74,\n      0x68, 0x65, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62,\n      0x75, 0x74, 0x6f, 0x72, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x70,\n      0x75, 0x62, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n      0x20, 0x61, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6f, 0x72,\n      0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61,\n      0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x49, 0x6e, 0x74,\n      0x65, 0x72, 0x6e, 0x65, 0x74, 0x2d, 0x44, 0x72, 0x61, 0x66,\n      0x74, 0x20, 0x6f, 0x72, 0x20, 0x52, 0x46, 0x43, 0x20, 0x61,\n      0x6e, 0x64, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x73, 0x74, 0x61,\n      0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x61, 0x64,\n      0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x20, 0x74,\n      0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74,\n      0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x20, 0x49, 0x45, 0x54,\n      0x46, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79,\n      0x20, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64,\n      0x65, 0x72, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x20, 0x22, 0x49,\n      0x45, 0x54, 0x46, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69,\n      0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x2e, 0x20, 0x53,\n      0x75, 0x63, 0x68, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6d,\n      0x65, 0x6e, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75,\n      0x64, 0x65, 0x20, 0x6f, 0x72, 0x61, 0x6c, 0x20, 0x73, 0x74,\n      0x61, 0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x69,\n      0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x73, 0x65, 0x73,\n      0x73, 0x69, 0x6f, 0x6e, 0x73, 0x2c, 0x20, 0x61, 0x73, 0x20,\n      0x77, 0x65, 0x6c, 0x6c, 0x20, 0x61, 0x73, 0x20, 0x77, 0x72,\n      0x69, 0x74, 0x74, 0x65, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20,\n      0x65, 0x6c, 0x65, 0x63, 0x74, 0x72, 0x6f, 0x6e, 0x69, 0x63,\n      0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61,\n      0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x6d, 0x61, 0x64, 0x65,\n      0x20, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x69,\n      0x6d, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x70, 0x6c, 0x61, 0x63,\n      0x65, 0x2c, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61,\n      0x72, 0x65, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,\n      0x65, 0x64, 0x20, 0x74, 0x6f };\nunsigned char out2[]\n  = { 0xa3, 0xfb, 0xf0, 0x7d, 0xf3, 0xfa, 0x2f, 0xde, 0x4f, 0x37,\n      0x6c, 0xa2, 0x3e, 0x82, 0x73, 0x70, 0x41, 0x60, 0x5d, 0x9f,\n      0x4f, 0x4f, 0x57, 0xbd, 0x8c, 0xff, 0x2c, 0x1d, 0x4b, 0x79,\n      0x55, 0xec, 0x2a, 0x97, 0x94, 0x8b, 0xd3, 0x72, 0x29, 0x15,\n      0xc8, 0xf3, 0xd3, 0x37, 0xf7, 0xd3, 0x70, 0x05, 0x0e, 0x9e,\n      0x96, 0xd6, 0x47, 0xb7, 0xc3, 0x9f, 0x56, 0xe0, 0x31, 0xca,\n      0x5e, 0xb6, 0x25, 0x0d, 0x40, 0x42, 0xe0, 0x27, 0x85, 0xec,\n      0xec, 0xfa, 0x4b, 0x4b, 0xb5, 0xe8, 0xea, 0xd0, 0x44, 0x0e,\n      0x20, 0xb6, 0xe8, 0xdb, 0x09, 0xd8, 0x81, 0xa7, 0xc6, 0x13,\n      0x2f, 0x42, 0x0e, 0x52, 0x79, 0x50, 0x42, 0xbd, 0xfa, 0x77,\n      0x73, 0xd8, 0xa9, 0x05, 0x14, 0x47, 0xb3, 0x29, 0x1c, 0xe1,\n      0x41, 0x1c, 0x68, 0x04, 0x65, 0x55, 0x2a, 0xa6, 0xc4, 0x05,\n      0xb7, 0x76, 0x4d, 0x5e, 0x87, 0xbe, 0xa8, 0x5a, 0xd0, 0x0f,\n      0x84, 0x49, 0xed, 0x8f, 0x72, 0xd0, 0xd6, 0x62, 0xab, 0x05,\n      0x26, 0x91, 0xca, 0x66, 0x42, 0x4b, 0xc8, 0x6d, 0x2d, 0xf8,\n      0x0e, 0xa4, 0x1f, 0x43, 0xab, 0xf9, 0x37, 0xd3, 0x25, 0x9d,\n      0xc4, 0xb2, 0xd0, 0xdf, 0xb4, 0x8a, 0x6c, 0x91, 0x39, 0xdd,\n      0xd7, 0xf7, 0x69, 0x66, 0xe9, 0x28, 0xe6, 0x35, 0x55, 0x3b,\n      0xa7, 0x6c, 0x5c, 0x87, 0x9d, 0x7b, 0x35, 0xd4, 0x9e, 0xb2,\n      0xe6, 0x2b, 0x08, 0x71, 0xcd, 0xac, 0x63, 0x89, 0x39, 0xe2,\n      0x5e, 0x8a, 0x1e, 0x0e, 0xf9, 0xd5, 0x28, 0x0f, 0xa8, 0xca,\n      0x32, 0x8b, 0x35, 0x1c, 0x3c, 0x76, 0x59, 0x89, 0xcb, 0xcf,\n      0x3d, 0xaa, 0x8b, 0x6c, 0xcc, 0x3a, 0xaf, 0x9f, 0x39, 0x79,\n      0xc9, 0x2b, 0x37, 0x20, 0xfc, 0x88, 0xdc, 0x95, 0xed, 0x84,\n      0xa1, 0xbe, 0x05, 0x9c, 0x64, 0x99, 0xb9, 0xfd, 0xa2, 0x36,\n      0xe7, 0xe8, 0x18, 0xb0, 0x4b, 0x0b, 0xc3, 0x9c, 0x1e, 0x87,\n      0x6b, 0x19, 0x3b, 0xfe, 0x55, 0x69, 0x75, 0x3f, 0x88, 0x12,\n      0x8c, 0xc0, 0x8a, 0xaa, 0x9b, 0x63, 0xd1, 0xa1, 0x6f, 0x80,\n      0xef, 0x25, 0x54, 0xd7, 0x18, 0x9c, 0x41, 0x1f, 0x58, 0x69,\n      0xca, 0x52, 0xc5, 0xb8, 0x3f, 0xa3, 0x6f, 0xf2, 0x16, 0xb9,\n      0xc1, 0xd3, 0x00, 0x62, 0xbe, 0xbc, 0xfd, 0x2d, 0xc5, 0xbc,\n      0xe0, 0x91, 0x19, 0x34, 0xfd, 0xa7, 0x9a, 0x86, 0xf6, 0xe6,\n      0x98, 0xce, 0xd7, 0x59, 0xc3, 0xff, 0x9b, 0x64, 0x77, 0x33,\n      0x8f, 0x3d, 0xa4, 0xf9, 0xcd, 0x85, 0x14, 0xea, 0x99, 0x82,\n      0xcc, 0xaf, 0xb3, 0x41, 0xb2, 0x38, 0x4d, 0xd9, 0x02, 0xf3,\n      0xd1, 0xab, 0x7a, 0xc6, 0x1d, 0xd2, 0x9c, 0x6f, 0x21, 0xba,\n      0x5b, 0x86, 0x2f, 0x37, 0x30, 0xe3, 0x7c, 0xfd, 0xc4, 0xfd,\n      0x80, 0x6c, 0x22, 0xf2, 0x21 };\n\nunsigned char key3[]\n  = { 0x1c, 0x92, 0x40, 0xa5, 0xeb, 0x55, 0xd3, 0x8a, 0xf3, 0x33,\n      0x88, 0x86, 0x04, 0xf6, 0xb5, 0xf0, 0x47, 0x39, 0x17, 0xc1,\n      0x40, 0x2b, 0x80, 0x09, 0x9d, 0xca, 0x5c, 0xbc, 0x20, 0x70,\n      0x75, 0xc0 };\nunsigned char msg3[]\n  = { 0x27, 0x54, 0x77, 0x61, 0x73, 0x20, 0x62, 0x72, 0x69, 0x6c,\n      0x6c, 0x69, 0x67, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74,\n      0x68, 0x65, 0x20, 0x73, 0x6c, 0x69, 0x74, 0x68, 0x79, 0x20,\n      0x74, 0x6f, 0x76, 0x65, 0x73, 0x0a, 0x44, 0x69, 0x64, 0x20,\n      0x67, 0x79, 0x72, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x67,\n      0x69, 0x6d, 0x62, 0x6c, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x74,\n      0x68, 0x65, 0x20, 0x77, 0x61, 0x62, 0x65, 0x3a, 0x0a, 0x41,\n      0x6c, 0x6c, 0x20, 0x6d, 0x69, 0x6d, 0x73, 0x79, 0x20, 0x77,\n      0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6f,\n      0x72, 0x6f, 0x67, 0x6f, 0x76, 0x65, 0x73, 0x2c, 0x0a, 0x41,\n      0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x6f, 0x6d,\n      0x65, 0x20, 0x72, 0x61, 0x74, 0x68, 0x73, 0x20, 0x6f, 0x75,\n      0x74, 0x67, 0x72, 0x61, 0x62, 0x65, 0x2e };\nunsigned char out3[]\n  = { 0x62, 0xe6, 0x34, 0x7f, 0x95, 0xed, 0x87, 0xa4, 0x5f, 0xfa,\n      0xe7, 0x42, 0x6f, 0x27, 0xa1, 0xdf, 0x5f, 0xb6, 0x91, 0x10,\n      0x04, 0x4c, 0x0d, 0x73, 0x11, 0x8e, 0xff, 0xa9, 0x5b, 0x01,\n      0xe5, 0xcf, 0x16, 0x6d, 0x3d, 0xf2, 0xd7, 0x21, 0xca, 0xf9,\n      0xb2, 0x1e, 0x5f, 0xb1, 0x4c, 0x61, 0x68, 0x71, 0xfd, 0x84,\n      0xc5, 0x4f, 0x9d, 0x65, 0xb2, 0x83, 0x19, 0x6c, 0x7f, 0xe4,\n      0xf6, 0x05, 0x53, 0xeb, 0xf3, 0x9c, 0x64, 0x02, 0xc4, 0x22,\n      0x34, 0xe3, 0x2a, 0x35, 0x6b, 0x3e, 0x76, 0x43, 0x12, 0xa6,\n      0x1a, 0x55, 0x32, 0x05, 0x57, 0x16, 0xea, 0xd6, 0x96, 0x25,\n      0x68, 0xf8, 0x7d, 0x3f, 0x3f, 0x77, 0x04, 0xc6, 0xa8, 0xd1,\n      0xbc, 0xd1, 0xbf, 0x4d, 0x50, 0xd6, 0x15, 0x4b, 0x6d, 0xa7,\n      0x31, 0xb1, 0x87, 0xb5, 0x8d, 0xfd, 0x72, 0x8a, 0xfa, 0x36,\n      0x75, 0x7a, 0x79, 0x7a, 0xc1, 0x88, 0xd1 };\n\n\/* -------------------------------------------------------------------------- *\/\n\/* -- Test driver ----------------------------------------------------------- *\/\n\nint\nmain()\n{\n  int r = 0;\n  unsigned char out[512];\n  unsigned char key[32];\n  unsigned char nonce[12];\n\n#define WIPE()                 \\\n  clear(out,   sizeof(out));   \\\n  clear(key,   sizeof(key));   \\\n  clear(nonce, sizeof(nonce));\n\n#define ENCRYPT(msg, cnt, nonce, key)                                   \\\n  crypto_stream_chacha20_xor(out, msg, sizeof(msg), cnt, nonce, key);\n\n#define CHECK(buf, msg)                          \\\n  if (0 != verify(out, buf, sizeof(buf))) {      \\\n    fprintf(stderr, \"FAILURE: %s\", msg);         \\\n    exit(1);                                     \\\n  }\n\n  \/* ------------------------------------------------------------------------ *\/\n  \/* ---- Test vector #1 ---------------------------------------------------- *\/\n  WIPE();\n\n  ENCRYPT(msg1, 0, nonce, key);\n  CHECK(out1, \"Test vector #1 failed\");\n\n  \/* ------------------------------------------------------------------------ *\/\n  \/* ---- Test vector #2 ---------------------------------------------------- *\/\n  WIPE();\n  key[31]   = 0x01;\n  nonce[11] = 0x02;\n\n  ENCRYPT(msg2, 1, nonce, key);\n  CHECK(out2, \"Test vector #2 failed\");\n\n  \/* ------------------------------------------------------------------------ *\/\n  \/* ---- Test vector #3 ---------------------------------------------------- *\/\n  WIPE();\n  nonce[11] = 0x02;\n\n  ENCRYPT(msg3, 42, nonce, key3);\n  CHECK(out3, \"Test vector #3 failed\");\n\n  \/* ------------------------------------------------------------------------ *\/\n  \/* ---- Done -------------------------------------------------------------- *\/\n  printf(\"OK\\n\");\n\n#undef CHECK\n#undef ENCRYPT\n#undef WIPE\n  return 0;\n}\n\n#endif \/* defined(WITH_TESTS) *\/\n\n```"},{"role":"assistant","content":"```saw\nenable_deprecated;\nimport \"..\/..\/deps\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/chacha20.cry\" as chacha20;\n\nprint \"loading LLVM bitcode...\";\nmod <- llvm_load_module \"chacha20.bc\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet i8 = llvm_int 8;\nlet i32 = llvm_int 32;\n\nlet stream_spec len = do {\n  outp <- llvm_alloc (llvm_array len i8);\n  (key, keyp) <- ptr_to_fresh \"key\" (llvm_array 32 i8);\n  (nonce, noncep) <- ptr_to_fresh \"nonce\" (llvm_array 12 i8);\n  counter <- llvm_fresh_var \"counter\" i32;\n\n  llvm_execute_func [ outp\n                    , llvm_term {{ `len : [64] }}\n                    , llvm_term counter\n                    , noncep\n                    , keyp\n                    ];\n\n  llvm_points_to outp (llvm_term {{ chacha20::stream key counter nonce : [len][8] }});\n};\n\nprint \"running verification...\";\ntime (llvm_verify mod \"crypto_stream_chacha20\" [] true (stream_spec 256) abc);\n```"}]}
{"filename":"saw-script\/examples\/chacha20\/chacha20-crucible.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function crypto_stream_chacha20 with signature int crypto_stream_chacha20(unsigned char* out, unsigned long long olen, unsigned int counter, const unsigned char* nonce, const unsigned char* key). Define a let-bound spec named crypto_stream_chacha20_spec that allocates symbolic inputs for out (array of 256 bytes), counter (32-bit int), nonce (array of 12 bytes), and key (array of 32 bytes). Use llvm_fresh_var and llvm_alloc to create symbolic variables and pointers. Include minimal preconditions to ensure safe execution. Symbolically execute the function with llvm_execute_func and assert that the output buffer points to the expected Cryptol specification result from chacha20::stream key counter nonce. Reference the LLVM module loaded from chacha20.bc and verify the function using llvm_verify with the defined spec.\n\n# Source code:\nchacha20.c\n```C\n\/*\n** Portable ChaCha20\/8 implementation. Based on RFC 7539.\n** Copyright (C) 2015-2016 Austin Seipp. Released in the Public Domain.\n*\/\n\n#include \"chacha20.h\"\n\nstatic unsigned int\nl32(unsigned int x,unsigned int n)\n{\n  \/* See: http:\/\/blog.regehr.org\/archives\/1063 *\/\n  return (x<<n) | (x>>(-n&31));\n}\n\nstatic unsigned int\nload32(const unsigned char* x)\n{\n  unsigned int u = x[3];\n  u = (u<<8)|x[2];\n  u = (u<<8)|x[1];\n  return (u<<8)|x[0];\n}\n\nstatic void\nstore32(unsigned char *x,unsigned int u)\n{\n  int i;\n  for (i=0; i < 4; ++i) { x[i] = u; u >>= 8; }\n}\n\nstatic void\nqround(unsigned int* x,\n       unsigned int a,\n       unsigned int b,\n       unsigned int c,\n       unsigned int d)\n{\n  x[a] = x[a]+x[b]; x[d] = l32(x[d]^x[a],16);\n  x[c] = x[c]+x[d]; x[b] = l32(x[b]^x[c],12);\n  x[a] = x[a]+x[b]; x[d] = l32(x[d]^x[a], 8);\n  x[c] = x[c]+x[d]; x[b] = l32(x[b]^x[c], 7);\n}\n\nstatic void\ncore(unsigned char out[64],\n     const unsigned int in[16])\n{\n  unsigned int x[16];\n  int i;\n\n  \/* Copy input block *\/\n  for (i = 0; i < 16; ++i) { x[i] = in[i]; }\n\n  \/* Ten iterations, two rounds each iteration *\/\n  for (i = 0; i < 10; ++i) {\n    \/* Column round *\/\n    qround(x, 0, 4, 8,  12);\n    qround(x, 1, 5, 9,  13);\n    qround(x, 2, 6, 10, 14);\n    qround(x, 3, 7, 11, 15);\n    \/* Diagonal round *\/\n    qround(x, 0, 5, 10, 15);\n    qround(x, 1, 6, 11, 12);\n    qround(x, 2, 7, 8,  13);\n    qround(x, 3, 4, 9,  14);\n  }\n\n  for (i = 0; i < 16; ++i) { x[i] = x[i] + in[i]; }      \/* Add input *\/\n  for (i = 0; i < 16; ++i) { store32(out+(4*i), x[i]); } \/* Output *\/\n}\n\nstatic void\nkexp(unsigned int* st,\n     const unsigned int counter,\n     const unsigned char* nonce,\n     const unsigned char* key)\n{\n  \/* Constants *\/\n  st[0]  = 0x61707865;\n  st[1]  = 0x3320646e;\n  st[2]  = 0x79622d32;\n  st[3]  = 0x6b206574;\n  \/* 4-11: key bytes *\/\n  st[4]  = load32(key);\n  st[5]  = load32(key+4);\n  st[6]  = load32(key+8);\n  st[7]  = load32(key+12);\n  st[8]  = load32(key+16);\n  st[9]  = load32(key+20);\n  st[10] = load32(key+24);\n  st[11] = load32(key+28);\n  \/* Counter + Nonce *\/\n  st[12] = counter;\n  st[13] = load32(nonce);\n  st[14] = load32(nonce+4);\n  st[15] = load32(nonce+8);\n}\n\nint\ncrypto_stream_chacha20_xor(unsigned char* out,\n                           const unsigned char* msg,\n                           unsigned long long mlen,\n                           const unsigned int counter,\n                           const unsigned char* nonce,\n                           const unsigned char* key)\n{\n  unsigned long long i;\n  unsigned int st[16];\n  unsigned char blk[64];\n\n  kexp(st, counter, nonce, key);\n\n  for(;;) {\n    \/* Advance state *\/\n    core(blk, st);\n    st[12] = st[12]+1;\n\n    \/* Fast path *\/\n    if (mlen <= 64) {\n      for (i = 0; i < mlen; ++i) out[i] = msg[i] ^ blk[i];\n      return 0;\n    }\n\n    \/* Normal path *\/\n    for (i = 0; i < 64; ++i) { out[i] = msg[i] ^ blk[i]; }\n    mlen -= 64;\n    msg += 64;\n    out += 64;\n  }\n  return 0;\n}\n\nint\ncrypto_stream_chacha20(unsigned char* out,\n                       unsigned long long olen,\n                       unsigned int counter,\n                       const unsigned char* nonce,\n                       const unsigned char* key)\n{\n  \/* Zero the output before encrypting it. *\/\n  for (unsigned long long i=0; i < olen; ++i) { out[i] = 0; }\n\n  return crypto_stream_chacha20_xor(out, out, olen, counter, nonce, key);\n}\n\n\/* -------------------------------------------------------------------------- *\/\n\/* -- Testing machinery ----------------------------------------------------- *\/\n\n#if defined(WITH_TESTS)\n#include <stdio.h>\n#include <stdlib.h>\n\n\/* Note: why don't we use memset\/memcmp? CompCert interpreter compatibility. *\/\nstatic void\nclear(unsigned char* o, unsigned int n)\n{\n  unsigned int i = 0;\n  for (; i < n; i++) o[i] = 0;\n}\n\nstatic int\nverify(unsigned char* x, unsigned char* y, unsigned int n)\n{\n  unsigned int i = 0, d = 0;\n  for(; i < n; i++) d |= x[i] ^ y[i];\n  return (1 & ((d - 1) >> 8)) - 1;\n}\n\n\/* -------------------------------------------------------------------------- *\/\n\/* -- Test vectors ---------------------------------------------------------- *\/\n\nunsigned char msg1[64] = { 0, };\nunsigned char out1[]\n  = { 0x76, 0xb8, 0xe0, 0xad, 0xa0, 0xf1, 0x3d, 0x90, 0x40, 0x5d,\n      0x6a, 0xe5, 0x53, 0x86, 0xbd, 0x28, 0xbd, 0xd2, 0x19, 0xb8,\n      0xa0, 0x8d, 0xed, 0x1a, 0xa8, 0x36, 0xef, 0xcc, 0x8b, 0x77,\n      0x0d, 0xc7, 0xda, 0x41, 0x59, 0x7c, 0x51, 0x57, 0x48, 0x8d,\n      0x77, 0x24, 0xe0, 0x3f, 0xb8, 0xd8, 0x4a, 0x37, 0x6a, 0x43,\n      0xb8, 0xf4, 0x15, 0x18, 0xa1, 0x1c, 0xc3, 0x87, 0xb6, 0x69,\n      0xb2, 0xee, 0x65, 0x86 };\n\nunsigned char msg2[]\n  = { 0x41, 0x6e, 0x79, 0x20, 0x73, 0x75, 0x62, 0x6d, 0x69, 0x73,\n      0x73, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68,\n      0x65, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x69, 0x6e, 0x74,\n      0x65, 0x6e, 0x64, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74,\n      0x68, 0x65, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62,\n      0x75, 0x74, 0x6f, 0x72, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x70,\n      0x75, 0x62, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n      0x20, 0x61, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6f, 0x72,\n      0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61,\n      0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x49, 0x6e, 0x74,\n      0x65, 0x72, 0x6e, 0x65, 0x74, 0x2d, 0x44, 0x72, 0x61, 0x66,\n      0x74, 0x20, 0x6f, 0x72, 0x20, 0x52, 0x46, 0x43, 0x20, 0x61,\n      0x6e, 0x64, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x73, 0x74, 0x61,\n      0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x61, 0x64,\n      0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x20, 0x74,\n      0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74,\n      0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x20, 0x49, 0x45, 0x54,\n      0x46, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79,\n      0x20, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64,\n      0x65, 0x72, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x20, 0x22, 0x49,\n      0x45, 0x54, 0x46, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69,\n      0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x2e, 0x20, 0x53,\n      0x75, 0x63, 0x68, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6d,\n      0x65, 0x6e, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75,\n      0x64, 0x65, 0x20, 0x6f, 0x72, 0x61, 0x6c, 0x20, 0x73, 0x74,\n      0x61, 0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x69,\n      0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x73, 0x65, 0x73,\n      0x73, 0x69, 0x6f, 0x6e, 0x73, 0x2c, 0x20, 0x61, 0x73, 0x20,\n      0x77, 0x65, 0x6c, 0x6c, 0x20, 0x61, 0x73, 0x20, 0x77, 0x72,\n      0x69, 0x74, 0x74, 0x65, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20,\n      0x65, 0x6c, 0x65, 0x63, 0x74, 0x72, 0x6f, 0x6e, 0x69, 0x63,\n      0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61,\n      0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x6d, 0x61, 0x64, 0x65,\n      0x20, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x69,\n      0x6d, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x70, 0x6c, 0x61, 0x63,\n      0x65, 0x2c, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61,\n      0x72, 0x65, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,\n      0x65, 0x64, 0x20, 0x74, 0x6f };\nunsigned char out2[]\n  = { 0xa3, 0xfb, 0xf0, 0x7d, 0xf3, 0xfa, 0x2f, 0xde, 0x4f, 0x37,\n      0x6c, 0xa2, 0x3e, 0x82, 0x73, 0x70, 0x41, 0x60, 0x5d, 0x9f,\n      0x4f, 0x4f, 0x57, 0xbd, 0x8c, 0xff, 0x2c, 0x1d, 0x4b, 0x79,\n      0x55, 0xec, 0x2a, 0x97, 0x94, 0x8b, 0xd3, 0x72, 0x29, 0x15,\n      0xc8, 0xf3, 0xd3, 0x37, 0xf7, 0xd3, 0x70, 0x05, 0x0e, 0x9e,\n      0x96, 0xd6, 0x47, 0xb7, 0xc3, 0x9f, 0x56, 0xe0, 0x31, 0xca,\n      0x5e, 0xb6, 0x25, 0x0d, 0x40, 0x42, 0xe0, 0x27, 0x85, 0xec,\n      0xec, 0xfa, 0x4b, 0x4b, 0xb5, 0xe8, 0xea, 0xd0, 0x44, 0x0e,\n      0x20, 0xb6, 0xe8, 0xdb, 0x09, 0xd8, 0x81, 0xa7, 0xc6, 0x13,\n      0x2f, 0x42, 0x0e, 0x52, 0x79, 0x50, 0x42, 0xbd, 0xfa, 0x77,\n      0x73, 0xd8, 0xa9, 0x05, 0x14, 0x47, 0xb3, 0x29, 0x1c, 0xe1,\n      0x41, 0x1c, 0x68, 0x04, 0x65, 0x55, 0x2a, 0xa6, 0xc4, 0x05,\n      0xb7, 0x76, 0x4d, 0x5e, 0x87, 0xbe, 0xa8, 0x5a, 0xd0, 0x0f,\n      0x84, 0x49, 0xed, 0x8f, 0x72, 0xd0, 0xd6, 0x62, 0xab, 0x05,\n      0x26, 0x91, 0xca, 0x66, 0x42, 0x4b, 0xc8, 0x6d, 0x2d, 0xf8,\n      0x0e, 0xa4, 0x1f, 0x43, 0xab, 0xf9, 0x37, 0xd3, 0x25, 0x9d,\n      0xc4, 0xb2, 0xd0, 0xdf, 0xb4, 0x8a, 0x6c, 0x91, 0x39, 0xdd,\n      0xd7, 0xf7, 0x69, 0x66, 0xe9, 0x28, 0xe6, 0x35, 0x55, 0x3b,\n      0xa7, 0x6c, 0x5c, 0x87, 0x9d, 0x7b, 0x35, 0xd4, 0x9e, 0xb2,\n      0xe6, 0x2b, 0x08, 0x71, 0xcd, 0xac, 0x63, 0x89, 0x39, 0xe2,\n      0x5e, 0x8a, 0x1e, 0x0e, 0xf9, 0xd5, 0x28, 0x0f, 0xa8, 0xca,\n      0x32, 0x8b, 0x35, 0x1c, 0x3c, 0x76, 0x59, 0x89, 0xcb, 0xcf,\n      0x3d, 0xaa, 0x8b, 0x6c, 0xcc, 0x3a, 0xaf, 0x9f, 0x39, 0x79,\n      0xc9, 0x2b, 0x37, 0x20, 0xfc, 0x88, 0xdc, 0x95, 0xed, 0x84,\n      0xa1, 0xbe, 0x05, 0x9c, 0x64, 0x99, 0xb9, 0xfd, 0xa2, 0x36,\n      0xe7, 0xe8, 0x18, 0xb0, 0x4b, 0x0b, 0xc3, 0x9c, 0x1e, 0x87,\n      0x6b, 0x19, 0x3b, 0xfe, 0x55, 0x69, 0x75, 0x3f, 0x88, 0x12,\n      0x8c, 0xc0, 0x8a, 0xaa, 0x9b, 0x63, 0xd1, 0xa1, 0x6f, 0x80,\n      0xef, 0x25, 0x54, 0xd7, 0x18, 0x9c, 0x41, 0x1f, 0x58, 0x69,\n      0xca, 0x52, 0xc5, 0xb8, 0x3f, 0xa3, 0x6f, 0xf2, 0x16, 0xb9,\n      0xc1, 0xd3, 0x00, 0x62, 0xbe, 0xbc, 0xfd, 0x2d, 0xc5, 0xbc,\n      0xe0, 0x91, 0x19, 0x34, 0xfd, 0xa7, 0x9a, 0x86, 0xf6, 0xe6,\n      0x98, 0xce, 0xd7, 0x59, 0xc3, 0xff, 0x9b, 0x64, 0x77, 0x33,\n      0x8f, 0x3d, 0xa4, 0xf9, 0xcd, 0x85, 0x14, 0xea, 0x99, 0x82,\n      0xcc, 0xaf, 0xb3, 0x41, 0xb2, 0x38, 0x4d, 0xd9, 0x02, 0xf3,\n      0xd1, 0xab, 0x7a, 0xc6, 0x1d, 0xd2, 0x9c, 0x6f, 0x21, 0xba,\n      0x5b, 0x86, 0x2f, 0x37, 0x30, 0xe3, 0x7c, 0xfd, 0xc4, 0xfd,\n      0x80, 0x6c, 0x22, 0xf2, 0x21 };\n\nunsigned char key3[]\n  = { 0x1c, 0x92, 0x40, 0xa5, 0xeb, 0x55, 0xd3, 0x8a, 0xf3, 0x33,\n      0x88, 0x86, 0x04, 0xf6, 0xb5, 0xf0, 0x47, 0x39, 0x17, 0xc1,\n      0x40, 0x2b, 0x80, 0x09, 0x9d, 0xca, 0x5c, 0xbc, 0x20, 0x70,\n      0x75, 0xc0 };\nunsigned char msg3[]\n  = { 0x27, 0x54, 0x77, 0x61, 0x73, 0x20, 0x62, 0x72, 0x69, 0x6c,\n      0x6c, 0x69, 0x67, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74,\n      0x68, 0x65, 0x20, 0x73, 0x6c, 0x69, 0x74, 0x68, 0x79, 0x20,\n      0x74, 0x6f, 0x76, 0x65, 0x73, 0x0a, 0x44, 0x69, 0x64, 0x20,\n      0x67, 0x79, 0x72, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x67,\n      0x69, 0x6d, 0x62, 0x6c, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x74,\n      0x68, 0x65, 0x20, 0x77, 0x61, 0x62, 0x65, 0x3a, 0x0a, 0x41,\n      0x6c, 0x6c, 0x20, 0x6d, 0x69, 0x6d, 0x73, 0x79, 0x20, 0x77,\n      0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6f,\n      0x72, 0x6f, 0x67, 0x6f, 0x76, 0x65, 0x73, 0x2c, 0x0a, 0x41,\n      0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x6f, 0x6d,\n      0x65, 0x20, 0x72, 0x61, 0x74, 0x68, 0x73, 0x20, 0x6f, 0x75,\n      0x74, 0x67, 0x72, 0x61, 0x62, 0x65, 0x2e };\nunsigned char out3[]\n  = { 0x62, 0xe6, 0x34, 0x7f, 0x95, 0xed, 0x87, 0xa4, 0x5f, 0xfa,\n      0xe7, 0x42, 0x6f, 0x27, 0xa1, 0xdf, 0x5f, 0xb6, 0x91, 0x10,\n      0x04, 0x4c, 0x0d, 0x73, 0x11, 0x8e, 0xff, 0xa9, 0x5b, 0x01,\n      0xe5, 0xcf, 0x16, 0x6d, 0x3d, 0xf2, 0xd7, 0x21, 0xca, 0xf9,\n      0xb2, 0x1e, 0x5f, 0xb1, 0x4c, 0x61, 0x68, 0x71, 0xfd, 0x84,\n      0xc5, 0x4f, 0x9d, 0x65, 0xb2, 0x83, 0x19, 0x6c, 0x7f, 0xe4,\n      0xf6, 0x05, 0x53, 0xeb, 0xf3, 0x9c, 0x64, 0x02, 0xc4, 0x22,\n      0x34, 0xe3, 0x2a, 0x35, 0x6b, 0x3e, 0x76, 0x43, 0x12, 0xa6,\n      0x1a, 0x55, 0x32, 0x05, 0x57, 0x16, 0xea, 0xd6, 0x96, 0x25,\n      0x68, 0xf8, 0x7d, 0x3f, 0x3f, 0x77, 0x04, 0xc6, 0xa8, 0xd1,\n      0xbc, 0xd1, 0xbf, 0x4d, 0x50, 0xd6, 0x15, 0x4b, 0x6d, 0xa7,\n      0x31, 0xb1, 0x87, 0xb5, 0x8d, 0xfd, 0x72, 0x8a, 0xfa, 0x36,\n      0x75, 0x7a, 0x79, 0x7a, 0xc1, 0x88, 0xd1 };\n\n\/* -------------------------------------------------------------------------- *\/\n\/* -- Test driver ----------------------------------------------------------- *\/\n\nint\nmain()\n{\n  int r = 0;\n  unsigned char out[512];\n  unsigned char key[32];\n  unsigned char nonce[12];\n\n#define WIPE()                 \\\n  clear(out,   sizeof(out));   \\\n  clear(key,   sizeof(key));   \\\n  clear(nonce, sizeof(nonce));\n\n#define ENCRYPT(msg, cnt, nonce, key)                                   \\\n  crypto_stream_chacha20_xor(out, msg, sizeof(msg), cnt, nonce, key);\n\n#define CHECK(buf, msg)                          \\\n  if (0 != verify(out, buf, sizeof(buf))) {      \\\n    fprintf(stderr, \"FAILURE: %s\", msg);         \\\n    exit(1);                                     \\\n  }\n\n  \/* ------------------------------------------------------------------------ *\/\n  \/* ---- Test vector #1 ---------------------------------------------------- *\/\n  WIPE();\n\n  ENCRYPT(msg1, 0, nonce, key);\n  CHECK(out1, \"Test vector #1 failed\");\n\n  \/* ------------------------------------------------------------------------ *\/\n  \/* ---- Test vector #2 ---------------------------------------------------- *\/\n  WIPE();\n  key[31]   = 0x01;\n  nonce[11] = 0x02;\n\n  ENCRYPT(msg2, 1, nonce, key);\n  CHECK(out2, \"Test vector #2 failed\");\n\n  \/* ------------------------------------------------------------------------ *\/\n  \/* ---- Test vector #3 ---------------------------------------------------- *\/\n  WIPE();\n  nonce[11] = 0x02;\n\n  ENCRYPT(msg3, 42, nonce, key3);\n  CHECK(out3, \"Test vector #3 failed\");\n\n  \/* ------------------------------------------------------------------------ *\/\n  \/* ---- Done -------------------------------------------------------------- *\/\n  printf(\"OK\\n\");\n\n#undef CHECK\n#undef ENCRYPT\n#undef WIPE\n  return 0;\n}\n\n#endif \/* defined(WITH_TESTS) *\/\n\n```"},{"role":"assistant","content":"```saw\nimport \"..\/..\/deps\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/chacha20.cry\" as chacha20;\n\n\/\/ Allocate a pointer of type 'ty', referring to the value 'v'\nlet alloc_init ty v = do {\n  p <- llvm_alloc ty;\n  llvm_points_to p v;\n  return p;\n};\n\n\/\/ Allocate a pointer to a fresh symbolic value\n\/\/ Returns a pair of the symbolic variable and the pointer\nlet ptr_to_fresh n ty = do {\n  x <- llvm_fresh_var n ty;\n  p <- alloc_init ty (llvm_term x);\n  return (x, p);\n};\n\nlet chacha20_setup = do {\n\n\/* The signature of chacha20:\nint\ncrypto_stream_chacha20(unsigned char* out,\n                       unsigned long long olen,\n                       unsigned int counter,\n                       const unsigned char* nonce,\n                       const unsigned char* key)\n*\/\n\n  (_, out_p)       <- ptr_to_fresh       \"out\"     (llvm_array 256 (llvm_int 8));\n  let olen         =                                            {{ 256 : [64] }};\n  counter          <- llvm_fresh_var     \"counter\"                 (llvm_int 32);\n  (nonce, nonce_p) <- ptr_to_fresh       \"nonce\"   (llvm_array 12  (llvm_int 8));\n  (key, key_p)     <- ptr_to_fresh       \"key\"     (llvm_array 32  (llvm_int 8));\n\n  \/\/ symbolically executing the function\n\n  llvm_execute_func\n    [ out_p\n    , llvm_term olen\n    , llvm_term counter\n    , nonce_p\n    , key_p\n    ];\n\n  \/\/ assert the specification\n\n  let spec_result =\n    llvm_term {{ chacha20::stream key counter nonce : [256][8] }};\n\n  llvm_points_to out_p spec_result;\n\n};\n\nprint \"Loading LLVM bitcode...\";\nmod <- llvm_load_module \"chacha20.bc\";\n\nlet solver = abc;\n\nprint \"Testing equality...\";\ntime (llvm_verify mod \"crypto_stream_chacha20\" [] false chacha20_setup solver);\n```"}]}
{"filename":"saw-script\/examples\/ghost\/ghost.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from simple.bc and verifies the function example with respect to a let-bound specification named example_spec. The specification should use llvm_fresh_var to create symbolic 32-bit integer inputs as needed, include minimal preconditions for safety, and use llvm_ghost_value to track the state of the static variable i inside next. The harness should declare a ghost state named ctr, bind the next function to a let-bound spec named next_spec referencing the static variable i, and verify example against example_spec using llvm_verify with next_spec as an assumption. The harness should not include comments or solver references and must call llvm_execute_func and llvm_return appropriately within the specs.\n\n# Source code:\nsimple.c\n```C\nint next(void) {\n        static int i = 0;\n        return i++;\n}\n\nint example(void) {\n        next();\n        next();\n        return next();\n}\n\n```"},{"role":"assistant","content":"```saw\nlet next_spec counter : CrucibleSetup () = do {\n  n <- llvm_fresh_var \"n\" (llvm_int 32);\n  llvm_ghost_value counter n;\n  llvm_execute_func [];\n  llvm_ghost_value counter {{n+1}};\n  llvm_return (llvm_term {{n}});\n};\n\nlet example_spec counter : CrucibleSetup () = do {\n  n <- llvm_fresh_var \"nm\" (llvm_int 32);\n  llvm_precond {{n < 2}};\n  llvm_ghost_value counter n;\n  llvm_execute_func [];\n  llvm_ghost_value counter {{n+3}};\n  llvm_return (llvm_term {{n+2}});\n};\n\nlet main : TopLevel () = do {\n    counter <- declare_ghost_state \"ctr\";\n\n    m <- llvm_load_module \"simple.bc\";\n    next <- llvm_unsafe_assume_spec m \"next\" (next_spec counter);\n    llvm_verify m \"example\" [next] false (example_spec counter)\n                (do { print_goal; z3;} );\n    print \"done\";\n};\n```"}]}
{"filename":"saw-script\/examples\/salsa20\/salsa.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module salsa20.bc and verifies the following C functions with let-bound specs: s20_quarterround with signature void s20_quarterround(uint32_t*, uint32_t*, uint32_t*, uint32_t*), s20_rowround with signature void s20_rowround(uint32_t[16]), s20_columnround with signature void s20_columnround(uint32_t[16]), s20_doubleround with signature void s20_doubleround(uint32_t[16]), s20_hash with signature void s20_hash(uint8_t[64]), s20_expand32 with signature void s20_expand32(uint8_t*, uint8_t[16], uint8_t[64]), and s20_crypt32 with signature enum s20_status_t s20_crypt32(uint8_t*, uint8_t[8], uint32_t, uint8_t*, uint32_t). Use llvm_fresh_var for symbolic inputs and add minimal preconditions for safety such as non-null pointers and valid array sizes. Define each spec as a let-bound do-block before passing it to llvm_verify. Do not inline specs or reference solvers explicitly.\n\n# Source code:\nsalsa20.c\n```C\n#include <stdint.h>\n#include <stddef.h>\n#include \"salsa20.h\"\n\n\/\/ Implements DJB's definition of '<<<'\nstatic uint32_t rotl(uint32_t value, int shift)\n{\n  return (value << shift) | (value >> (32 - shift));\n}\n\nstatic void s20_quarterround(uint32_t *y0, uint32_t *y1, uint32_t *y2, uint32_t *y3)\n{\n  *y1 = *y1 ^ rotl(*y0 + *y3, 7);\n  *y2 = *y2 ^ rotl(*y1 + *y0, 9);\n  *y3 = *y3 ^ rotl(*y2 + *y1, 13);\n  *y0 = *y0 ^ rotl(*y3 + *y2, 18);\n}\n\nstatic void s20_rowround(uint32_t y[static 16])\n{\n  s20_quarterround(&y[0], &y[1], &y[2], &y[3]);\n  s20_quarterround(&y[5], &y[6], &y[7], &y[4]);\n  s20_quarterround(&y[10], &y[11], &y[8], &y[9]);\n  s20_quarterround(&y[15], &y[12], &y[13], &y[14]);\n}\n\nstatic void s20_columnround(uint32_t x[static 16])\n{\n  s20_quarterround(&x[0], &x[4], &x[8], &x[12]);\n  s20_quarterround(&x[5], &x[9], &x[13], &x[1]);\n  s20_quarterround(&x[10], &x[14], &x[2], &x[6]);\n  s20_quarterround(&x[15], &x[3], &x[7], &x[11]);\n}\n\nstatic void s20_doubleround(uint32_t x[static 16])\n{\n  s20_columnround(x);\n  s20_rowround(x);\n}\n\n\/\/ Creates a little-endian word from 4 bytes pointed to by b\nstatic uint32_t s20_littleendian(uint8_t *b)\n{\n  return b[0] +\n         (b[1] << 8) +\n         (b[2] << 16) +\n         (b[3] << 24);\n}\n\n\/\/ Moves the little-endian word into the 4 bytes pointed to by b\nstatic void s20_rev_littleendian(uint8_t *b, uint32_t w)\n{\n  b[0] = w;\n  b[1] = w >> 8;\n  b[2] = w >> 16;\n  b[3] = w >> 24;\n}\n\n\/\/ The core function of Salsa20\nstatic void s20_hash(uint8_t seq[static 64])\n{\n  int i;\n  uint32_t x[16];\n  uint32_t z[16];\n\n  \/\/ Create two copies of the state in little-endian format\n  \/\/ First copy is hashed together\n  \/\/ Second copy is added to first, word-by-word\n  for (i = 0; i < 16; ++i)\n    x[i] = z[i] = s20_littleendian(seq + (4 * i));\n\n  for (i = 0; i < 10; ++i)\n    s20_doubleround(z);\n\n  for (i = 0; i < 16; ++i) {\n    z[i] += x[i];\n    s20_rev_littleendian(seq + (4 * i), z[i]);\n  }\n}\n\n\/\/ The 16-byte (128-bit) key expansion function\nstatic void s20_expand16(uint8_t *k,\n                         uint8_t n[static 16],\n                         uint8_t keystream[static 64])\n{\n  int i, j;\n  \/\/ The constants specified by the Salsa20 specification, 'tau'\n  \/\/ \"expand 16-byte k\"\n  uint8_t t[4][4] = {\n    { 'e', 'x', 'p', 'a' },\n    { 'n', 'd', ' ', '1' },\n    { '6', '-', 'b', 'y' },\n    { 't', 'e', ' ', 'k' }\n  };\n\n  \/\/ Copy all of 'tau' into the correct spots in our keystream block\n  for (i = 0; i < 64; i += 20)\n    for (j = 0; j < 4; ++j)\n      keystream[i + j] = t[i \/ 20][j];\n\n  \/\/ Copy the key and the nonce into the keystream block\n  for (i = 0; i < 16; ++i) {\n    keystream[4+i]  = k[i];\n    keystream[44+i] = k[i];\n    keystream[24+i] = n[i];\n  }\n\n  s20_hash(keystream);\n}\n\n\n\/\/ The 32-byte (256-bit) key expansion function\nstatic void s20_expand32(uint8_t *k,\n                         uint8_t n[static 16],\n                         uint8_t keystream[static 64])\n{\n  int i, j;\n  \/\/ The constants specified by the Salsa20 specification, 'sigma'\n  \/\/ \"expand 32-byte k\"\n  uint8_t o[4][4] = {\n    { 'e', 'x', 'p', 'a' },\n    { 'n', 'd', ' ', '3' },\n    { '2', '-', 'b', 'y' },\n    { 't', 'e', ' ', 'k' }\n  };\n\n  \/\/ Copy all of 'sigma' into the correct spots in our keystream block\n  for (i = 0; i < 64; i += 20)\n    for (j = 0; j < 4; ++j)\n      keystream[i + j] = o[i \/ 20][j];\n\n  \/\/ Copy the key and the nonce into the keystream block\n  for (i = 0; i < 16; ++i) {\n    keystream[4+i]  = k[i];\n    keystream[44+i] = k[i+16];\n    keystream[24+i] = n[i];\n  }\n\n  s20_hash(keystream);\n}\n\n\/\/ Performs up to 2^32-1 bytes of encryption or decryption under a\n\/\/ 128- or 256-bit key.\nenum s20_status_t s20_crypt32(uint8_t *key,\n                            uint8_t nonce[static 8],\n                            uint32_t si,\n                            uint8_t *buf,\n                            uint32_t buflen)\n{\n  uint8_t keystream[64];\n  \/\/ 'n' is the 8-byte nonce (unique message number) concatenated\n  \/\/ with the per-block 'counter' value (4 bytes in our case, 8 bytes\n  \/\/ in the standard). We leave the high 4 bytes set to zero because\n  \/\/ we permit only a 32-bit integer for stream index and length.\n  uint8_t n[16] = { 0 };\n  uint32_t i;\n\n  \/\/ If any of the parameters we received are invalid\n  if (key == NULL || nonce == NULL || buf == NULL)\n    return S20_FAILURE;\n\n  \/\/ Set up the low 8 bytes of n with the unique message number\n  for (i = 0; i < 8; ++i)\n    n[i] = nonce[i];\n\n  \/\/ If we're not on a block boundary, compute the first keystream\n  \/\/ block. This will make the primary loop (below) cleaner\n  if (si % 64 != 0) {\n    \/\/ Set the second-to-highest 4 bytes of n to the block number\n    s20_rev_littleendian(n+8, si \/ 64);\n    \/\/ Expand the key with n and hash to produce a keystream block\n    s20_expand32(key, n, keystream);\n  }\n\n  \/\/ Walk over the plaintext byte-by-byte, xoring the keystream with\n  \/\/ the plaintext and producing new keystream blocks as needed\n  for (i = 0; i < buflen; ++i) {\n    \/\/ If we've used up our entire keystream block (or have just begun\n    \/\/ and happen to be on a block boundary), produce keystream block\n    if ((si + i) % 64 == 0) {\n      s20_rev_littleendian(n+8, ((si + i) \/ 64));\n      s20_expand32(key, n, keystream);\n    }\n\n    \/\/ xor one byte of plaintext with one byte of keystream\n    buf[i] ^= keystream[(si + i) % 64];\n  }\n\n  return S20_SUCCESS;\n}\n\n\n```"},{"role":"assistant","content":"```saw\nimport \"Salsa20.cry\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p (llvm_term v);\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty x;\n    return (x, p);\n};\n\nlet oneptr_update_func n ty f = do {\n    (x, p) <- ptr_to_fresh n ty;\n    llvm_execute_func [p];\n    llvm_points_to p (llvm_term {{ f x }});\n};\n\nlet quarterround_setup : CrucibleSetup () = do {\n        y0 <- llvm_fresh_var \"y0\" (llvm_int 32);\n    y1 <- llvm_fresh_var \"y1\" (llvm_int 32);\n    y2 <- llvm_fresh_var \"y2\" (llvm_int 32);\n    y3 <- llvm_fresh_var \"y3\" (llvm_int 32);\n    p0 <- alloc_init (llvm_int 32) {{ y0 }};\n    p1 <- alloc_init (llvm_int 32) {{ y1 }};\n    p2 <- alloc_init (llvm_int 32) {{ y2 }};\n    p3 <- alloc_init (llvm_int 32) {{ y3 }};\n\n    llvm_execute_func [p0, p1, p2, p3];\n\n    let zs = {{ quarterround [y0,y1,y2,y3] }};\n    llvm_points_to p0 (llvm_term {{ zs@0 }});\n    llvm_points_to p1 (llvm_term {{ zs@1 }});\n    llvm_points_to p2 (llvm_term {{ zs@2 }});\n    llvm_points_to p3 (llvm_term {{ zs@3 }});\n};\n\nlet rowround_setup =\n  oneptr_update_func \"y\" (llvm_array 16 (llvm_int 32)) {{ rowround }};\n\nlet columnround_setup =\n  oneptr_update_func \"x\" (llvm_array 16 (llvm_int 32)) {{ columnround }};\n\nlet doubleround_setup =\n  oneptr_update_func \"x\" (llvm_array 16 (llvm_int 32)) {{ doubleround }};\n\nlet salsa20_setup =\n  oneptr_update_func \"seq\" (llvm_array 64 (llvm_int 8)) {{ Salsa20 }};\n\nlet salsa20_djb_setup = do {\n    (input, ip) <- ptr_to_fresh \"input\" (llvm_array 16 (llvm_int 32));\n    (_, op) <- ptr_to_fresh \"output\" (llvm_array 64 (llvm_int 8));\n    llvm_execute_func [op, ip];\n    llvm_points_to op (llvm_term {{\n        Salsa20 (join [ littleendian_inverse x | x <- input ])\n    }});\n};\n\nlet salsa20_expansion_32 = do {\n        k <- llvm_fresh_var \"k\" (llvm_array 32 (llvm_int 8));\n    pk <- llvm_alloc_readonly (llvm_array 32 (llvm_int 8));\n    llvm_points_to pk (llvm_term k);\n    n <- llvm_fresh_var \"n\" (llvm_array 16 (llvm_int 8));\n    pn <- llvm_alloc_readonly (llvm_array 16 (llvm_int 8));\n    llvm_points_to pn (llvm_term n);\n    pks <- llvm_alloc (llvm_array 64 (llvm_int 8));\n    llvm_execute_func [pk, pn, pks];\n    let rks = {{ Salsa20_expansion`{a=2}(k, n)}};\n    llvm_points_to pks (llvm_term rks);\n};\n\nlet s20_encrypt32 n = do {\n    (key, pkey) <- ptr_to_fresh \"key\" (llvm_array 32 (llvm_int 8));\n    (v, pv) <- ptr_to_fresh \"nonce\" (llvm_array 8 (llvm_int 8));\n    (m, pm) <- ptr_to_fresh \"buf\" (llvm_array n (llvm_int 8));\n    llvm_execute_func [ pkey\n                      , pv\n                      , llvm_term {{ 0 : [32] }}\n                      , pm\n                      , llvm_term {{ `n : [32] }}\n                      ];\n    llvm_points_to pm (llvm_term {{ Salsa20_encrypt (key, v, m) }});\n    llvm_return (llvm_term {{ 0 : [32] }});\n};\n\nlet main : TopLevel () = do {\n    m      <- llvm_load_module \"salsa20.bc\";\n    qr     <- llvm_verify m \"s20_quarterround\" []      false quarterround_setup   yices;\n    rr     <- llvm_verify m \"s20_rowround\"     [qr]    false rowround_setup       yices;\n    cr     <- llvm_verify m \"s20_columnround\"  [qr]    false columnround_setup    yices;\n    dr     <- llvm_verify m \"s20_doubleround\"  [cr,rr] false doubleround_setup    yices;\n    s20    <- llvm_verify m \"s20_hash\"         [dr]    false salsa20_setup        yices;\n    s20e32 <- llvm_verify m \"s20_expand32\"     [s20]   true  salsa20_expansion_32 yices;\n    s20encrypt_63 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 63) yices;\n    s20encrypt_64 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 64) yices;\n    s20encrypt_65 <- llvm_verify m \"s20_crypt32\" [s20e32] true (s20_encrypt32 65) yices;\n\n    djb    <- llvm_load_module \"djb\/salsa20.bc\";\n    s20djb <- llvm_verify djb \"salsa20_wordtobyte\" [] false salsa20_djb_setup     w4_abc_verilog;\n    print \"Done!\";\n};\n```"}]}
{"filename":"saw-script\/examples\/allsat\/allsat_print.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the associated LLVM or JVM module containing the function(s) specified in saw-script\/examples\/allsat\/allsat_print.saw. Define a let-bound specification named <function_name>_spec that uses llvm_fresh_var or jvm_fresh_var to create symbolic inputs matching the exact function signatures from the source files. Include minimal preconditions necessary for safe execution, such as valid array bounds or non-zero divisors. Use the appropriate backend commands (llvm_* or jvm_*) inferred from the presence of llvm_load_module or java_load_class in the SAW file. The harness should invoke the target function symbolically and verify its behavior according to the specification, without inline do blocks or solver references."},{"role":"assistant","content":"```saw\n\/\/ Print all the satisfying assignments for a boolean predicate.\n\/\/\n\/\/ Only works for uncurried predicates, because I don't know\n\/\/ how to write the \"exclude the current solution\" predicate\n\/\/ refinement\n\/\/\n\/\/   \\x -> x != s && p x\n\/\/\n\/\/ for curried predicates 'p'.\n\nrec allsat_print p = do {\n  r <- sat abc p;\n  caseSatResult r\n    (print \"Done!\")\n    (\\s -> do {\n      print s;\n      allsat_print {{ \\x -> x != s \/\\ p x }};\n    });\n};\n```"}]}
{"filename":"saw-script\/examples\/sequential_aigs\/fib.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification script that proves the equivalence of the two Fibonacci state machines fib1 and fib2 defined in the Cryptol file fib.cry, using the provided inputs sequence. The script should formally verify that for all steps in the input sequence, the outputs of fib1 and fib2 match exactly, ensuring the correctness of the fib2 implementation against fib1 as a reference."},{"role":"assistant","content":"```cryptol\nimport StateMachine\n\n\/\/ Fibonacci state iterators with different state but same output\n\/\/ sequence: 8-bit Fibonacci numbers.\n\/\/\n\/\/ The state transitions, ignoring bit widths, are\n\/\/\n\/\/   (0, (0, 0, 0))       |-> (0, (1, 0, 1))\n\/\/\n\/\/ and\n\/\/\n\/\/   (0, (1, fn, f(n+1))) |-> (fn, (1, f(n+1), f(n+2)))\n\/\/\n\/\/ where 'fn' denotes the 'n'th Fibonacci number.\n\/\/\n\/\/ The first bit of the states indicates whether it's the first\n\/\/ step or not; the sequential circuit gets seeded with all zero\n\/\/ bits.\n\nfib1_no_init : ([1], ([8], [8])) -> ([8], ([8], [8]))\nfib1_no_init (_, (fn, fn1)) = (fn, (fn1, fn2))\n  where\n  fn2 = fn + fn1\n\nfib1 = init_with (0, 1) fib1_no_init\nfib1_state_bits = 1 + 8 + 8 : [8]\n\nfib2 : ([1], ([1], [16], [16])) -> ([8], ([1], [16], [16]))\nfib2 (_, (start, fn , fn1)) = (fn', (1, fn1', fn2))\n  where\n  \/\/ Some (at least Cryptol level) obfuscation.\n  fn1' = (zero # start) * fn1 + (zero # ~start)\n  fn2 = fn + fn1'\n  fn' = drop`{8} fn\n\nfib2_state_bits = 1 + 16 + 16 : [8]\n\n\/\/ Make a buggy version of fib state machine which returns wrong value\n\/\/ when state counter has magic value.\n\/\/\n\/\/ If this were a common pattern for example generation, we could\n\/\/ make a \"magic-value bug\" combinator in the style of 'init_with'.\nmk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n  \/\/ Change output when state has magic value.\n  fn' = fn + (if k == magic then 1 else 0)\n\nmk_buggy_fib magic = init_with (0, 1, 0) (mk_buggy_fib_no_init magic)\ncount_buggy_state_bits : {a} (fin a, width a <= 7) => [a] -> [8]\ncount_buggy_state_bits magic = 1 + 8 + 8 + `a\n\n\/\/ 4-bit counter\nbuggy_fib4_magic = 0xf\nbuggy_fib4 = mk_buggy_fib buggy_fib4_magic\nbuggy_fib4_state_bits = count_buggy_state_bits buggy_fib4_magic\n\n\/\/ 8-bit counter\nbuggy_fib8_magic = 0xff\nbuggy_fib8 = mk_buggy_fib buggy_fib8_magic\nbuggy_fib8_state_bits = count_buggy_state_bits buggy_fib8_magic\n\n\/\/ 12-bit counter\nbuggy_fib12_magic = 0b111111111111\nbuggy_fib12 = mk_buggy_fib buggy_fib12_magic\nbuggy_fib12_state_bits = count_buggy_state_bits buggy_fib12_magic\n\n\/\/ 16-bit counter\nbuggy_fib16_magic = 0xffff\nbuggy_fib16 = mk_buggy_fib buggy_fib16_magic\nbuggy_fib16_state_bits = count_buggy_state_bits buggy_fib16_magic\n\n\/\/ 32-bit counter\nbuggy_fib32_magic = 0xffffffff\nbuggy_fib32 = mk_buggy_fib buggy_fib32_magic\nbuggy_fib32_state_bits = count_buggy_state_bits buggy_fib32_magic\n\n\/\/ 64-bit counter\nbuggy_fib64_magic = 0xffffffffffffffff\nbuggy_fib64 = mk_buggy_fib buggy_fib64_magic\nbuggy_fib64_state_bits = count_buggy_state_bits buggy_fib64_magic\n\n\n\/\/ Tests.\ninputs : [1000][1]\ninputs = zero\n\ntest = equiv fib1 fib2 inputs\n\n\/\/ The states sequences.\nstates1 = exec fib1 inputs\nstates2 = exec fib2 inputs\n```"}]}
{"filename":"saw-script\/examples\/sequential_aigs\/CipherMode.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to specify and verify the correctness of the block cipher modes of operation defined in the CipherMode module (ecb, cbc, pcbc, cfb, ofb, ctr). The properties should capture expected behaviors such as reversibility (decryption correctness) and state updates for each mode, suitable for use with :prove or :check commands."},{"role":"assistant","content":"```cryptol\nmodule CipherMode where\n\n\/\/ Block-cipher modes of operation.\n\/\/\n\/\/ A mode turns a block transformer into a stream-of-blocks\n\/\/ transformer. In some cases, the stream-of-blocks transformer is\n\/\/ also a stream-of-bits transformer, e.g. for the one-time-pad-style\n\/\/ modes (CFB, OFB, and CTR below).\n\/\/\n\/\/ http:\/\/en.wikipedia.org\/wiki\/Block_cipher_mode_of_operation .\n\nimport StateMachine\n\n\/\/ Block cipher over 'k'-bit keys and 'n'-bit blocks.\n\/\/\n\/\/ We don't actually care about encryption, so these are actually just\n\/\/ keyed block transformers.\ntype BC k n = [k] -> [n] -> [n]\n\n\/\/ Electronic Code Book mode.\necb : {k, n} BC k n -> SM ([k], [n]) [n] (Bool, [k])\necb bc = init i sm\n  where\n  sm : SM [n] [n] [k]\n  sm (block, key) = (ct, key)\n    where\n    ct = bc key block\n  i : [k] -> [k]\n  i key = key\n\n\/\/ Cipher-Block Chaining mode.\ncbc : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\ncbc bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key (state ^ block)\n    state' = ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\n\/\/ Propagating CBC mode.\npcbc : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\npcbc bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key (state ^ block)\n    state' = block ^ ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\n\/\/ Cipher FeedBack mode.\ncfb : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\ncfb bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key state ^ block\n    state' = ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\n\/\/ Output FeedBack mode.\nofb : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\nofb bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    state' = bc key state\n    ct = state' ^ block\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\n\/\/ CounTer Mode.\nctr : {k, n} (fin n, n >= 1) =>\n  BC k (2*n) -> SM (([k], [n]), [2*n]) [2*n] (Bool, ([k], [n], [n]))\nctr bc = init i sm\n  where\n  sm : SM [2*n] [2*n] ([k], [n], [n])\n  sm (block, (key, iv, counter)) = (ct, (key, iv, counter + 1))\n    where\n    ct = bc key (iv # counter) ^ block\n  i : ([k], [n]) -> ([k], [n], [n])\n  i (key, iv) = (key, iv, 0)\n```"}]}
{"filename":"saw-script\/examples\/sequential_aigs\/exp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification script that proves the equivalence of the two exponentiation state machines `exp_ref` and `exp_opt` defined in the given Cryptol file. The script should use the `miter_loops` or `sync_loops` constructs to create a miter or synchronized composition of the two implementations and verify that for all valid inputs, both state machines produce the same output values and termination conditions."},{"role":"assistant","content":"```cryptol\n\/\/ Compare exponentiation implementations using SAIGs.\n\nimport StateMachine\n\n\/\/ Linear number of multiplications.\n\/*\nr = 1\nwhile p > 0:\n  r *= x\n  --p\nreturn r\n*\/\nexp_ref : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) (Bool, [m]) (Bool, ([m], [n], [m]))\nexp_ref = mk_loop (\\(x, p) -> (x, p, 1)) body\n  where\n  body : Body [m] ([m], [n], [m])\n  body (x, p', r) =\n    if p' == 0\n    then ((True, r), (x, p', r))\n    else ((False, zero), (x, p' - 1, r * x))\n\n\/\/ Logarithmic number of multiplications.\n\/*\nr = 1\nwhile p > 0:\n  if p & 1:\n    r *= x\n  x *= x\n  p >>= 1\nreturn r\n*\/\nexp_opt : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) (Bool, [m]) (Bool, ([m], [n], [m]))\nexp_opt = mk_loop (\\(x, p) -> (x, p, 1)) body\n  where\n  body : Body [m] ([m], [n], [m])\n  body (x', p', r) =\n    if p' == 0\n    then ((True, r), (x', p', r))\n    else ((False, zero), (x' * x', p' >> 1, r'))\n      where\n      r' = if (p' && 1) != 0\n           then r * x'\n           else r\n\nsynced_exp : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  [1] -> SM ([m], [n]) (Bool, [m]) ((Bool, ([m], [n], [m])), (Bool, ([m], [n], [m])))\nsynced_exp bias = sync_loops bias exp_ref exp_opt\n\nmitered_exp : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) Bool ((Bool, ([m], [n], [m])), (Bool, ([m], [n], [m])))\nmitered_exp = miter_loops exp_ref exp_opt\n```"}]}
{"filename":"saw-script\/examples\/sequential_aigs\/StateMachine.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification script that uses the provided StateMachine Cryptol module to verify the equivalence of two state machines using the 'miter' function. The script should load two implementations of a state machine, construct their miter, and prove that the miter is equivalent to the 'const_false' state machine, thereby establishing lock-step equivalence of the two state machines for all inputs."},{"role":"assistant","content":"```cryptol\nmodule StateMachine where\n\n\/\/ A state machine is function of type '(i, s) -> (o, s)',\n\/\/ with input type 'i', state type 's', and output type 'o'.\ntype SM i o s = (i, s) -> (o, s)\n\n\/\/ To run a state machine for 'n' steps, a sequence of 'n'\n\/\/ input values must be provided; the initial state is always\n\/\/ seeded with 'zero : s'.\nrun : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](o,s)\nrun sm is = oss\n  where\n  states = [zero] # [ os.1 | os <- oss ]\n  oss = [ sm (i, s) | i <- is | s <- states ]\n\neval : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](o)\neval sm is = [ os.0 | os <- run sm is ]\n\nexec : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](s)\nexec sm is = [ os.1 | os <- run sm is ]\n\n\/\/ Two state machines are equivalent if their output streams agree\n\/\/ on all input streams. This function checks equivalence at specific\n\/\/ finite input sequences.\nequiv : {n, i, s1, s2, o} (Cmp o, fin n, Zero s1, Zero s2)\n     => SM i o s1 -> SM i o s2 -> [n]i -> Bool\nequiv sm1 sm2 is = all [ o1 == o2 | o1 <- eval sm1 is | o2 <- eval sm2 is ]\n  where\n  all : {m} (fin m) => [m]Bool -> Bool\n  all xs = its ! 0\n    where\n    its = [True] # [ x && it | x <- xs | it <- its ]\n\n\/\/ Because the initial state is always seeded with 'zero : s', it's\n\/\/ common to have boilerplate code which sets up the \"real\" initial state.\n\/\/ This combinator takes the place of that boilerplate.\ninit_with : {i, o, s} s -> SM i o s -> SM i o (Bool, s)\ninit_with s_initial sm (i, (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else s_initial\n  (o, s'') = sm (i, s')\n\n\/\/ A more general initializer which unifies 'init_with' above and\n\/\/ 'mk_loop' below.\n\/\/\n\/\/ The function 'mk_s_initial' computes the initial state from the\n\/\/ first type-'a' input to the state machine, where the input type 'i'\n\/\/ has been extended with initializer input type 'a' to '(a, i)'.\n\/\/ Note that all type-'a' inputs after the first will be ignored, so\n\/\/ this could cause unnecessary work for the prover (e.g. ABC) if it's\n\/\/ unable to realize that these inputs are irrelevant.\ninit : {a, i, o, s}\n  (a -> s) -> SM i o s -> SM (a, i) o (Bool, s)\ninit mk_s_initial sm ((a, i), (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else mk_s_initial a\n  (o, s'') = sm (i, s')\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Miters.\n\/\/\n\/\/ The HWMCC (Hardware Model Checking Competition) provers consider\n\/\/ AIG outputs to represent \"safety properties\" which are \"violated\"\n\/\/ when the output bit is 1. If the circuit has multiple output bits,\n\/\/ then each one is considered a separate safety property. Some\n\/\/ provers, e.g. tip, will attempt to prove each property separately.\n\n\/\/ Miter two statemachines for lock-step equivalence. See also\n\/\/ 'miter_loops' below for an eventual-equivalence miter for loops.\nmiter : {i, o, s1, s2} (Cmp o) =>\n  SM i o s1 -> SM i o s2 -> SM i Bool (s1, s2)\nmiter sm1 sm2 (i, (s1, s2)) = (o, (s1', s2'))\n  where\n  (o1, s1') = sm1 (i, s1)\n  (o2, s2') = sm2 (i, s2)\n  o = o1 != o2\n\n\/\/ For checking equivalence via miters using sequential equivalence\n\/\/ checking: the underlying state machines are equal when their miter\n\/\/ is equal to the const_false state machine.\nconst_false : {i} SM i Bool [1]\nconst_false (_, _) = (False, zero)\n\n\/\/ For comparison to 'const_false' in a miter, to ensure that a given\n\/\/ command works on miters. Some ABC commands, e.g. 'dsec', compare\n\/\/ the current circuit to itself when given only one argument, leading\n\/\/ to false positives when mistakenly using 'dsec' to verify miters.\nconst_true : {i} SM i Bool [1]\nconst_true (_, _) = (True, zero)\n\n\/\/ Pass (the SAIG for) these miters to a verifier to see if it works\n\/\/ on miters.  Create the SAIG with 'write_saig'.\n\/\/\n\/\/ The verification should fail.\nsat_miter : SM [1] Bool ([1], [1])\nsat_miter = miter const_true const_false\n\/\/ The verification should succeed.\nunsat_miter : SM [1] Bool ([1], [1])\nunsat_miter = miter const_true const_true\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Loops.\n\/\/\n\/\/ We can model loops with SAIGs that ignore their input and act like\n\/\/ step functions, producing dummy output until they are done looping,\n\/\/ at which point they produce a constant stream of their result. We\n\/\/ can then compare loops for equivalence by checking they eventually\n\/\/ stabilize to the same constant output stream.\n\n\/\/ A loop has no input, only a state. The output includes a bool\n\/\/ indicating whether the loop has terminated or not.\ntype Body o s = s -> ((Bool, o), s)\n\n\/\/ In order to prove that two loops are equivalent for all initial\n\/\/ states using sequential equivalence checking, we add an input\n\/\/ stream and compute the initial state from the first stream element.\nmk_loop : {i,o,s} (i -> s) -> Body o s -> SM i (Bool, o) (Bool, s)\nmk_loop initializer body (i, (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else initializer i\n  (o, s'') = body s'\n\n\/\/ Run a loop for 'n' steps, seeded with input 'i'.\nrun_loop : {n, i, o, s} (fin n, n >= 1, Zero i, Zero s) =>\n  SM i o s -> i -> [n](o, s)\nrun_loop loop i = run loop ([i] # zero)\n\n\/\/ Sequential equivalence checking (SEC) is lock-step equivalence, so\n\/\/ to compare two loop using SEC we need to ensure that both loops\n\/\/ produce their output in the same step. We can achieve this via a\n\/\/ biased product of streams, which doesn't produce any output until\n\/\/ both internal streams have, at which point it duplicates the stream\n\/\/ it's biased towards.\n\/\/\n\/\/ However, this sounds like a computability theoretic construction --\n\/\/ i.e. it shows something is possible, not that it's feasible in\n\/\/ practice -- and I'm not optimistic that ABC will magically be able\n\/\/ to check the equivalence of such biased joins quickly.\nsync_loops : {i, o, s1, s2} (Zero o) =>\n  [1] -> SM i (Bool, o) s1 -> SM i (Bool, o) s2 -> SM i (Bool, o) (s1, s2)\nsync_loops bias l1 l2 (i, (s1, s2)) = ((done, o'), (s1', s2'))\n  where\n  ((done1, o1), s1') = l1 (i, s1)\n  ((done2, o2), s2') = l2 (i, s2)\n  o = [o1, o2] @ bias\n  done = done1 && done2\n  o' = if done then o else zero\n\n\/\/ Alternatively, we can build a synced miter: run both loops until\n\/\/ they produce output, and then compare the output for equality.  If\n\/\/ two loops are equivalent their miter will be 'const False'.\nmiter_loops : {i, o, s1, s2} (Cmp o) =>\n  SM i (Bool, o) s1 -> SM i (Bool, o) s2 -> SM i Bool (s1, s2)\nmiter_loops l1 l2 (i, (s1, s2)) = (o', (s1', s2'))\n  where\n  ((done1, o1), s1') = l1 (i, s1)\n  ((done2, o2), s2') = l2 (i, s2)\n  done = done1 && done2\n  o' = if done then o1 != o2 else False\n```"}]}
{"filename":"saw-script\/examples\/aes\/aes.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the AES C module using llvm_load_module from saw-script\/examples\/aes\/aes.saw. Define a let-bound spec named aes_encrypt_decrypt_spec that symbolically inputs a 256-bit key and a plaintext block using llvm_fresh_var. The spec should call the C functions encrypt and decrypt with these symbolic inputs, ensuring minimal preconditions for safety. Verify that decrypt is the inverse of encrypt by asserting decrypt(key, encrypt(key, plaintext)) == plaintext. Use appropriate llvm_ functions to set up and prove this property, referencing the exact function signatures from the AES C source."},{"role":"assistant","content":"```saw\n\/**\n * Cryptol AES property verification.\n *\n * This module efficiently checks that decrypt is the inverse of encrypt.\n *\n * @copyright Galois Inc.\n * @author Eric Mertens <emertens@galois.com>\n *\/\n\nimport \"..\/..\/deps\/cryptol-specs\/Common\/GF28.cry\" as GF28;\nimport \"..\/..\/deps\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Instantiations\/AES256.cry\";\n\nlet ss0 = cryptol_ss ();\n\nprint \"Verifying that cipher unrolls\";\nunroll_cipher <- prove_print\n    (w4_unint_z3 [\"AddRoundKey\", \"MixColumns\", \"SubBytes\", \"ShiftRows\"])\n    {{ \\w pt -> cipher w pt ==\n    (stateToMsg (AddRoundKey (w@14) (ShiftRows (SubBytes (t 13 (t 12 (t 11 (t 10 (t 9 (t 8 (t 7 (t 6 (t 5 (t 4 (t 3 (t 2 (t 1 (AddRoundKey (w@0) (msgToState pt))))))))))))))))))\n        where\n        t i state = AddRoundKey (w@i) (MixColumns (ShiftRows (SubBytes state))))\n    }};\n\nprint \"Verifying that invCipher unrolls\";\nunroll_invCipher <- prove_print\n    (w4_unint_z3 [\"AddRoundKey\", \"InvMixColumns\", \"InvSubBytes\", \"InvShiftRows\"])\n    {{ \\w ct -> invCipher w ct ==\n    (stateToMsg (AddRoundKey (w@0) (InvSubBytes (InvShiftRows (t 1 (t 2 (t 3 (t 4 (t 5 (t 6 (t 7 (t 8 (t 9 (t 10 (t 11 (t 12 (t 13 (AddRoundKey (w@14) ( msgToState ct))))))))))))))))))\n        where\n        t i state = InvMixColumns (AddRoundKey (w@i) (InvSubBytes (InvShiftRows state))))\n    }};\n\nprint \"Verifying that SBox unfolds\";\n\/* This performance trick is necessary because SAW doesn't memoize sboxTable *\/\nunfold_SBox <- prove_print (unint_z3 [\"inverse\", \"add\", \"rotateR\"])\n  {{ \\i -> (SBox i == GF28::add [b, b >>> 4, b >>> 5, b >>> 6, b >>> 7, 0x63] where b = GF28::inverse i) }};\n\nprint \"Verifying that InvSBox unfolds\";\n\/* This performance trick is necessary because SAW doesn't memoize sboxInvTable *\/\nunfold_SBoxInv <- prove_print (unint_z3 [\"inverse\", \"add\", \"rotateR\"])\n  {{ \\i -> SBoxInv i == GF28::inverse (GF28::add [i >>> 2, i >>> 5, i >>> 7, 0x05]) }};\n\nprint \"Verifying that SBoxInv inverts SBox\";\ninvert_SBox <- prove_print\n    do {\n        simplify (addsimps [unfold_SBox, unfold_SBoxInv] ss0);\n        rme;\n    }\n    {{ \\s -> SBoxInv (SBox s) == s }};\n\nprint \"Verifying that InvSubBytes inverts SubBytes\";\ninvert_SubBytes <- prove_print\n    do {\n        unfolding [\"InvSubBytes\", \"SubBytes\"];\n        simplify (add_prelude_eqs [\"map_map\"] (addsimps [invert_SBox] ss0));\n        rme;\n    }\n    {{ \\s -> InvSubBytes (SubBytes s) == s }};\n\nprint \"Verifying that InvShiftRows inverts ShiftRows\";\ninvert_ShiftRows <- prove_print rme\n    {{ \\s -> InvShiftRows (ShiftRows s) == s }};\n\nprint \"Verifying that InvMixColumns inverts MixColumns\";\ninvert_MixColumns <- prove_print rme\n    {{ \\s -> InvMixColumns (MixColumns s) == s }};\n\nprint \"Verifying that msgToState inverts stateToMsg\";\ninvert_stateToMsg <- prove_print rme {{\\s -> msgToState (stateToMsg s) == s}};\n\nprint \"Verifying that stateToMsg inverts msgToState\";\ninvert_msgToState <- prove_print rme {{\\s -> stateToMsg (msgToState s) == s}};\n\nprint \"Verifying that AddRoundKey is involutive\";\ninvert_AddRoundKey <- prove_print rme\n    {{ \\x y -> AddRoundKey x (AddRoundKey x y) == y }};\n\nprint \"Verifying that invCipher inverts cipher\";\ninvert_cipher <- prove_print do {\n    simplify (addsimps\n        [unroll_cipher, unroll_invCipher, invert_ShiftRows,\n         invert_MixColumns, invert_SubBytes, invert_msgToState,\n         invert_stateToMsg, invert_msgToState, invert_AddRoundKey] ss0);\n    rme;\n   }\n   {{ \\w pt -> invCipher w (cipher w pt) == pt }};\n\nprint \"Verifying that decrypt inverts encrypt\";\nprove_print do {\n    unfolding [\"aesIsCorrect\", \"encrypt\", \"decrypt\"];\n    simplify (addsimps [invert_cipher] ss0);\n    rme;\n   }\n   {{ aesIsCorrect }};\n```"}]}
{"filename":"saw-script\/examples\/openssl_aes\/AES128TBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification script that proves the correctness of the AES128 encryption and decryption functions defined in AES128TBox.cry. Specifically, verify that decrypting an encrypted plaintext with the same key returns the original plaintext (property encDecInverse), and that the key expansion function is injective (property keyExpansionInjective). Also include checks for the sbox and unsbox inverse property (sboxUnsboxInverse). Use the provided Cryptol properties as a basis for your proofs."},{"role":"assistant","content":"```cryptol\n\/\/ Translated from: https:\/\/github.com\/LeventErkok\/sbv\/blob\/ebf80d83d9259fa5ad42d97fdede1ae97323cfa7\/Data\/SBV\/Examples\/Crypto\/AES.hs\n\nmodule AESTBox where\n\ntype GF28 = [8]\ntype Nk = 4\ntype Nb = 4\ntype Nr = 6 + Nk\n\ntype State = [4][Nb * 8]\ntype Key = [Nk][Nb * 8]\ntype RoundKey = State\ntype KS = (RoundKey, [Nr - 1]RoundKey, RoundKey)\n\ngf28Mult : GF28 -> GF28 -> GF28\ngf28Mult x y = pmod (pmult x y) <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Pow : GF28 -> [8] -> GF28\ngf28Pow n k =\n  if k == 0 then 1\n  else\n    (if (k && 1) == 1 then gf28Mult n w\n     else w\n       where v = gf28Pow n (k >> 1)\n             w = gf28Mult v v)\n\ntoBytes : [32] -> [4]GF28\ntoBytes x = split`{4} x\n\nfromBytes : [4]GF28 -> [32]\nfromBytes xs = join xs\n\nrotR : [4]GF28 -> [2] -> [4]GF28\nrotR xs n = xs >>> n\n\nroundConstants = take`{16} ([0] # [ gf28Pow 2 (k-1) | k <- [1 ... ] ])\n\nsbox = [ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n         0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n         0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n         0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n         0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n         0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n         0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n         0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n         0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n         0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n         0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n         0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n         0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n         0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n         0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n         0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n         0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n         0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n         0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n         0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n         0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n         0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n         0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n         0x54, 0xbb, 0x16]\n\nunsbox = [ unsboxf i sboxit 0 0 | i <- [ 0 .. 255] ]\n  where sboxit = [ (j, i) | i <- [ 0 .. 255] | j <- sbox ]\n        unsboxf n t i d = if i >= (length t) then d\n                          else (if (k == n) then v\n                                else unsboxf n t (i + 1) d\n                                  where (k, v) = t @ i)\n\naddRoundKey : RoundKey -> State -> State\naddRoundKey k s = k ^ s\n\nkeyExpansion : Key -> [inf]RoundKey\nkeyExpansion key = chop4 keys\n  where keys = key # [nextWord i prev old | i <- [ `Nk ... ] | prev <- drop`{Nk-1} keys | old <- keys]\n        chop4 : {a} [inf]a -> [inf][4]a\n        chop4 xs = split xs\n        subWordRcon : [Nb * 8] -> GF28 -> [Nb * 8]\n        subWordRcon w rc = fromBytes [a ^ rc, b, c, d]\n          where [a, b, c, d] = [ sbox @ i | i <- toBytes w ]\n        nextWord : [8] -> [Nb * 8] -> [Nb * 8] -> [Nb * 8]\n        nextWord i prev old = old ^\n          (if (i % `Nk) == 0 then subWordRcon (join (split`{4} prev <<< 1)) (roundConstants @ (i \/ `Nk))\n           else if (i % `Nk) == 4 \/\\ `Nk > 6 then subWordRcon prev 0\n           else prev)\n\nmETable = [ gf28Mult 0x0E i | i <- [ 0 .. 255 ] ]\nmBTable = [ gf28Mult 0x0B i | i <- [ 0 .. 255 ] ]\nmDTable = [ gf28Mult 0x0D i | i <- [ 0 .. 255 ] ]\nm9Table = [ gf28Mult 0x09 i | i <- [ 0 .. 255 ] ]\nmE i = mETable @ i\nmB i = mBTable @ i\nmD i = mDTable @ i\nm9 i = m9Table @ i\ntables = [ [mE, mB, mD, m9],\n           [m9, mE, mB, mD],\n           [mD, m9, mE, mB],\n           [mB, mD, m9, mE] ]\n\ninvMixColumns : State -> State\ninvMixColumns state = [ fromBytes ce | ce <- transpose (mmult [ toBytes se | se <- state ]) ]\n  where dollar f x = f x\n        dot f fs =  foldr1 (^) (zipWith dollar f fs)\n        mmult n = [ [ (dot r) ne | ne <- n ] | r <- tables ]\n\naesEncryptKeySchedule : Key -> KS\naesEncryptKeySchedule key = (rKeys @ 0, m, rKeys @ `Nr)\n  where rKeys = keyExpansion key\n        m = take`{Nr-1}(tail rKeys)\n\naesDecryptKeySchedule : Key -> KS\naesDecryptKeySchedule key = (rKeys @ `Nr, m, rKeys @ 0)\n  where rKeys = keyExpansion key\n        m = [ invMixColumns k | k <- reverse (take`{Nr-1}(tail rKeys)) ]\n\ndoRounds : {a, b} (fin b) => (Bit -> State -> a -> State) -> (RoundKey, [b]a, a) -> State -> State\ndoRounds rnd (ikey, rkeys, fkey) sIn = rnd True (rs ! 0) fkey\n  where s0 = addRoundKey ikey sIn\n        rs = [s0] # [ rnd False s k | s <- rs | k <- rkeys ]\n\nt0Func : GF28 -> [4]GF28\nt0Func a = [gf28Mult s 2, s, s, gf28Mult s 3] where s = sbox @ a\nt0 = [fromBytes (t0Func a) | a <- [0..255]]\nt1 = [fromBytes (rotR (t0Func a) 1) | a <- [0..255]]\nt2 = [fromBytes (rotR (t0Func a) 2) | a <- [0..255]]\nt3 = [fromBytes (rotR (t0Func a) 3) | a <- [0..255]]\n\naesRound : Bit -> State -> RoundKey -> State\naesRound isFinal s key = addRoundKey d key\n  where d = [ f isFinal i | i <- [ 0 .. 3] ]\n        a = [ toBytes se | se <- s ]\n        f b j = if b then\n                  fromBytes [ sbox @ (a @ ((j+0) % 4) @ 0),\n                              sbox @ (a @ ((j+1) % 4) @ 1),\n                              sbox @ (a @ ((j+2) % 4) @ 2),\n                              sbox @ (a @ ((j+3) % 4) @ 3) ]\n                else\n                  e0 ^ e1 ^ e2 ^ e3\n                    where e0 = t0 @ (a @ ((j+0) % 4) @ 0)\n                          e1 = t1 @ (a @ ((j+1) % 4) @ 1)\n                          e2 = t2 @ (a @ ((j+2) % 4) @ 2)\n                          e3 = t3 @ (a @ ((j+3) % 4) @ 3)\n\n\nu0Func : GF28 -> [4]GF28\nu0Func a = [gf28Mult s 0x0E, gf28Mult s 0x09, gf28Mult s 0x0D, gf28Mult s 0x0B] where s = unsbox @ a\nu0 = [fromBytes (u0Func a) | a <- [0..255]]\nu1 = [fromBytes (rotR (u0Func a) 1) | a <- [0..255]]\nu2 = [fromBytes (rotR (u0Func a) 2) | a <- [0..255]]\nu3 = [fromBytes (rotR (u0Func a) 3) | a <- [0..255]]\n\naesInvRound : Bit -> State -> RoundKey -> State\naesInvRound isFinal s key = addRoundKey d key\n  where d = [ f isFinal i | i <- [ 0 .. 3] ]\n        a = [ toBytes se | se <- s ]\n        f b j = if b then\n                  fromBytes [ unsbox @ (a @ ((j+0) % 4) @ 0),\n                              unsbox @ (a @ ((j+3) % 4) @ 1),\n                              unsbox @ (a @ ((j+2) % 4) @ 2),\n                              unsbox @ (a @ ((j+1) % 4) @ 3) ]\n                else\n                  e0 ^ e1 ^ e2 ^ e3\n                    where e0 = u0 @ (a @ ((j+0) % 4) @ 0)\n                          e1 = u1 @ (a @ ((j+3) % 4) @ 1)\n                          e2 = u2 @ (a @ ((j+2) % 4) @ 2)\n                          e3 = u3 @ (a @ ((j+1) % 4) @ 3)\n\naesEncrypt pt key = doRounds aesRound (aesEncryptKeySchedule key) pt\n\naesDecrypt ct key = doRounds aesInvRound (aesDecryptKeySchedule key) ct\n\n\/\/ Test for Nk == 4 (AES128); comment out the next two properties if Nk != 4\nproperty t128EncTest = aesEncrypt pt k == [0x69c4e0d8, 0x6a7b0430, 0xd8cdb780, 0x70b4c55a]\n  where pt = [ 0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff ]\n        k = [ 0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f ]\n\nproperty t128DecTest = aesDecrypt ct k == [0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff]\n  where ct = [ 0x69c4e0d8, 0x6a7b0430, 0xd8cdb780, 0x70b4c55a ]\n        k = [ 0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f ]\n\n\/*\n\/\/ Test for Nk == 6 (AES192); comment out the next two properties if Nk != 6\nproperty t192EncTest = aesEncrypt pt k == [0xdda97ca4, 0x864cdfe0, 0x6eaf70a0, 0xec0d7191]\n  where pt = [0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff]\n        k = [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617]\n\nproperty t192DecTest = aesDecrypt ct k == [0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff]\n  where ct = [0xdda97ca4, 0x864cdfe0, 0x6eaf70a0, 0xec0d7191]\n        k = [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617]\n*\/\n\n\/*\n\/\/ Test for Nk == 8 (AES256); comment out the next two properties if Nk != 8\nproperty t256EncTest = aesEncrypt pt k == [0x8ea2b7ca, 0x516745bf, 0xeafc4990,0x4b496089]\n  where pt = [0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff]\n        k = [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617, 0x18191a1b, 0x1c1d1e1f]\n\nproperty t256DecTest = aesDecrypt ct k == [0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff]\n  where ct = [0x8ea2b7ca, 0x516745bf, 0xeafc4990,0x4b496089]\n        k = [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617, 0x18191a1b, 0x1c1d1e1f]\n*\/\n\n\/\/ The top level property that summarizes all earlier test properties.\n\nproperty AESTests = t128EncTest && t128DecTest\n\n\/\/ Checking and proving sboxUnsboxInverse is easy, given its small\n\/\/ state space.\n\nproperty sboxUnsboxInverse (n : [8]) = n == (unsbox @ (sbox @ n))\n\n\/\/ Checking keyExpansionInjective is easy; proving this takes minutes\/hours.\n\/\/ At one time in the past this took under one minute.\n\nproperty keyExpansionInjective k1 k2 =\n  if k1 != k2\n  then aesEncryptKeySchedule k1 != aesEncryptKeySchedule k2\n  else True\n\n\/\/ The standard theorem relating encryption to decryption.  Again, checking\n\/\/ this is easy; proving this takes time.\n\nproperty encDecInverse pt k = (aesDecrypt (aesEncrypt pt k) k) == pt\n\n\/\/ Because there are some problems with loading modules in the current\n\/\/ cryptol-gen, these definitions are copied from Cryptol.Extras.\n\/\/ foldr1 is added for convenience.\n\nfoldr : {a,b,n} (fin n) => (a -> b -> b) -> b -> [n]a -> b\nfoldr f acc xs = ys ! 0\n  where ys = [acc] # [f x a | a <- ys | x <- reverse xs]\n\nfoldr1 : {a, b} (fin b) => (a -> a -> a) -> [1 + b]a -> a\nfoldr1 f xs = foldr f (xs @ 0) (tail xs)\n\nzipWith : {a,b,c,n} (a -> b -> c) -> [n]a -> [n]b -> [n]c\nzipWith f xs ys = [f x y | x <- xs | y <- ys]\n```"}]}
{"filename":"saw-script\/examples\/ecdsa\/cryptol-spec\/ecc.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification script that formally verifies the correctness of the `ecdsa_sign` and `ecdsa_public_verify` functions in the `ecc.cry` Cryptol module against the ECDSA specification. The script should prove that for valid inputs, a signature produced by `ecdsa_sign` is accepted by `ecdsa_public_verify` when using the same curve parameters and keys."},{"role":"assistant","content":"```cryptol\nmodule ecc where\n\nimport bv\nimport mod_arith\nimport mul_java\n\nimport Field \/* Defines Field type and generic operations *\/\nimport ec_point_ops\nimport ref_ec_mul\nimport p384_field\nimport p384_ec_point_ops\nimport p384_ec_mul\n\n\/* Scalar multiply operations {{{1 *\/\n\n\ntest_params : ([384], AffinePoint [384], [384], AffinePoint [384])\ntest_params =\n\/\/  (0x7b52dc21312701d79a2465bb9fdf6fd30c4f76cf74787e44348f8217e6ffd5e02ee8c55a7c5d91b452825b1026d26893, {x=0xdf1c86a62d76090308a0d4c371704b36f3bfa41f0dbf8185d297b8a2c811756f0f4be19871cde079c5d43cfd0fab7fe8; y=0x70521fdd9165b0d33e948be941c590f2fbe7e2754ba110ae24089d41773acfdd34701acaafa669a884d3eefbf557d98b}, 0x211bb4730ad83e31aedbd66a5a750e800cf4de096495323ea94a73f25e9bcb5068a9dcc93e98efecb136eb057e6f41a4, {x=0x6bdf86d8f4cdf5b63a6a1e93a75457c0816fa2f3f69bc706ab69a7b5a63d4956d83cc4ca551f6aaf7653b8dd0991a6af; y=0xa8ce019e78abd658350e5885c8fddb172117a24bf157dfdbe8a1831e03758e630784470287c8e25908d931f22581bf97});\n\/\/  (0x6250471849e0c0eb47e9cf2c8e04c9ad0745e358d1cf11fb53e178a3c5b301b5f9e7f62e61c8f2113615cc4ff9927f9b, {x=0x005255b811499293ea986c66b4698e0748284d391130afd3f9febbc71ef3b39fe13a3deaa1489d817b885edf270b1bf6; y=0xc9a1dcdb74a4ae432edea47750d754d918b2f1fd8d9ee612b4f0cf2bebcb0eeef43ef5d0ce90cb75362bd2cfe69bffad}, 0xd9e8d87abffb84c0c06fe47396aa84871f08420561a7d8cc64fef7796fc0ca9a5406a37a054cc8cd57e26a3a7249fdb3, {x=0x8da95367d9e731f86adda9bfae6ff170cf090be5223f3b33c0d7c6c585bfc1330137d237fdc16bd432797a1da1dfa331; y=0x114d8b24d75d0149603aa6eab6ccec1cd83f5baaca7898dd6edd7c2ca91176893102b9fe129a09f9fdb208e18be46d16});\n  (0xe74872524f90425d832a4f264e1f7b9209ec7456e9b4c467d8eac6c68f973ea7fea24f4d3fa8498bb1e26f933eaa261b\n  , { x=0xbbab93c429707b2afe9ac285314d7b40c4ee31531b13291aa9058307cdd038b572fdf2f3a84dc912804fa426fe531a3c\n    , y=0x4c2cffaa333bfd82b575918bb979bf51480c836082c097a03fed5454877b37d2f44f0401d212c16b05052bd383047b31\n    }\n  , 0xd4356773f2b311955542c5835696b9dca9d0e59197d5746bbf7dc079a666d955f74114662e38d31196bf94b060cc0c80\n  , { x=0xd40c63c65b413d0741c56e884f0dca63b822a6f6879d36f9261d9b4a270d5d79a9be790fdfb871b5d6ae9204da692663\n    , y=0x4d6b2b937c85b3c0c3cd2df85e9307cc89e0093f336af3b4531aa126bbdbec466562d8aa0dc1cf360fc1f1d0951e3ad1\n    })\n\n\/* ECDSA Operations {{{1 *\/\n\n\/** Operations for ECDSA abstraction layer *\/\ntype Curve fv gv = {\n    point_ops : PointOps fv gv\n  , base : AffinePoint fv\n  , affinify : JacobianPoint fv -> AffinePoint fv\n  , mul : (gv, AffinePoint fv) -> JacobianPoint fv\n  , twin_mul : (gv, AffinePoint fv, gv, AffinePoint fv) -> JacobianPoint fv\n  }\n\n\/* Create a public key from a private key *\/\ninitialize_public_key : {fv} (Curve [fv] [fv], [fv]) -> AffinePoint [fv]\ninitialize_public_key(c, k) = c.affinify(c.mul(k, c.base))\n\n\/**\n * Reference ECDSA signature algorithm as formalized from [ANSI X9.62-2005, pg 8]\n * Parameters:\n *  Curve c\n *  Private key d of signatory.\n *  Integer e obtained after hashing message on step e)\n *  Ephemeral EC private key in range [1 .. c.curve)\n *\/\necdsa_sign : {fv} (fin fv, fv >= 1) => (Curve [fv] [fv], [fv], [fv], [fv]) -> ([fv], [fv])\necdsa_sign(c,d,e,k) = if is_zero(r) || is_zero(s) then (0,0) else (r, s)\n  where\n    g = c.point_ops.group_field\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    \/* Compute x coordinate of public key. *\/\n    j = (c.affinify(c.mul(k, c.base))).x\n    \/* c) Set r = j mod n *\/\n    r = g.normalize(j)\n    s = g.div(g.add(g.normalize(e), g.mul(d, r)), k)\n\n\/**\n * Reference ECDSA signature verification algorithm as formalized from [ANSI X9.62-2005, pg 9]\n * Parameters\n *  Curve c\n *  Integer e' obtained after hashing message on  step \"c\".\n *  Pair returned by ref_ecdsa_sign algorithm.\n *  Public key of key signatory.\n * Result:\n *  Bit that is True if verification suceeds, and false otherwise.\n *\/\necdsa_public_verify : {fv} (fin fv, fv >= 1)\n   => (Curve [fv] [fv], [fv], ([fv], [fv]), AffinePoint [fv]) -> Bit\necdsa_public_verify(c, e, (r, s), q)\n    \/* h) Compare v and r' if v = r', output \"valid\"; otherwise output \"invalid\". *\/\n   = in_range(s) && (v == r)\n  where\n    f = c.point_ops.field\n    g = c.point_ops.group_field\n    mul(x,y) = g.mul(x, y)\n    div(x,y) = g.div(x, y)\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    in_range(x) = ~is_zero(x) && g.is_val(x)\n    s_inv = div(1, s)\n    u1 = mul(e, s_inv)\n    u2 = mul(r, s_inv)\n    r2 = c.twin_mul(u1, c.base, u2, q)\n    \/* f) Convert the field element x_r to an integer j as described in A.5 *\/\n    j = f.mul(r2.x, f.sq(f.div(f.field_unit, r2.z)))\n    \/* g) v = j mod n *\/\n    v = g.normalize(j)\n\n\/* This version performs a cheaper sequence of operations, and matches\n * the Java implementation. Correspondence between the reference and\n * implementation versions of ecdsa_public_verify is probably best proved\n * independent of the Java code.\n *\/\necdsa_public_verify_imp :\n  (Curve [384] [384], [384], ([384], [384]), AffinePoint [384]) -> Bit\necdsa_public_verify_imp(c, e, (r, s), q)\n   = in_range(r) && in_range(s) &&\n     ~is_zero(r2.z) &&\n     (g.is_equal(j, r2.x) || ((carrybits == False) && (g.is_equal(k, r2.x))))\n  where\n    f = c.point_ops.field\n    g = c.point_ops.group_field\n    mul(x,y) = g.mul(x, y)\n    div(x,y) = g.div(x, y)\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    in_range(x) = ~is_zero(x) && g.is_val(x)\n    s_inv = div(1, s)\n    u1 = mul(g.normalize(e), s_inv)\n    u2 = mul(r, s_inv)\n    r2 = c.twin_mul(u1, c.base, u2, q)\n    r2zsq = f.sq(r2.z)\n    j = f.mul(r, r2zsq)\n    sum = r + p384_group_size\n    carrybits = (sum < r) && (sum < p384_group_size)\n    k = f.mul(sum, r2zsq)\n\ntype RsltWithCarry a b = { carrybits : a , rslt : b }\n\np384_incFieldPrime : [384] -> RsltWithCarry [32] [384]\np384_incFieldPrime x = { carrybits = zero # [(bs @ 0)]\n                       , rslt = drop(bs) : [384]\n                       }\n  where bs = safe_add(x, p384_prime)\n\np384_decFieldPrime : [384] -> RsltWithCarry [32] [384]\np384_decFieldPrime x = { carrybits = if (bs @ 0) then -1 else 0\n                       , rslt = drop(bs) : [384]\n                       }\n  where bs = safe_sub(x, p384_prime)\n\np384_field_cube(x)       = p384_field_mul(x, p384_field_sq(x))\n\n\/** P384 curve operations {{{2 *\/\n\np384_base : AffinePoint [384]\np384_base = nzAffinePoint(\n  join [0xaa87ca22, 0xbe8b0537, 0x8eb1c71e, 0xf320ad74, 0x6e1d3b62, 0x8ba79b98\n       ,0x59f741e0, 0x82542a38, 0x5502f25d, 0xbf55296c, 0x3a545e38, 0x72760ab7],\n  join [0x3617de4a, 0x96262c6f, 0x5d9e98bf, 0x9292dc29, 0xf8f41dbd, 0x289a147c\n       ,0xe9da3113, 0xb5f0b8c0, 0x0a60b1ce, 0x1d7e819d, 0x7a431d7c, 0x90ea0e5f])\n\n\n\np384_group_add : ([384],[384]) -> [384]\np384_group_add = p384_group_field.add\n\np384_curve : Curve [384] [384]\np384_curve =\n  { point_ops = p384_point_ops\n  , base = p384_base\n  , affinify = \\x -> ec_affinify(p384_field, x)\n  , mul = p384_ec_mul\n  , twin_mul = p384_ec_twin_mul\n  }\n\np384_ecdsa_sign : ([384], [384], [384]) -> { r:[384], s:[384] }\np384_ecdsa_sign(d,e,k) = { r = rr, s = ss }\n  where (rr, ss) = ecdsa_sign(p384_curve,d,e,k)\n\np384_ecdsa_public_verify : ([384], [384], [384], AffinePoint [384]) -> Bit\np384_ecdsa_public_verify(e,pr,ps,q) =\n  ecdsa_public_verify_imp(p384_curve,e,(pr,ps),q)\n\n\/* Curve \"a\" parameter, defined in [FIPS-186-3, page 87] to be -3 *\/\np384_a : [384]\np384_a = p384_prime - 3\n\n\/* Curve \"b\" parameter, defined in [FIPS-186-3, page 89] *\/\np384_b : [384]\np384_b = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\n\n\n\/* Convert a p384 Jacobian point to an affine point *\/\np384_affinify : JacobianPoint [384] -> AffinePoint [384]\np384_affinify p = ec_affinify(p384_field, p)\n\n\/* Convert a p384 affine point to a Jacobian point *\/\np384_jacobify : AffinePoint [384] -> JacobianPoint [384]\np384_jacobify p = { x = p.x, y = p.y, z = 1 }\n\np384_base4 : JacobianPoint [384]\np384_base4 = p384_ec_double(p384_ec_double(p384_jacobify(p384_base)))\n\np384_base3 : AffinePoint [384]\np384_base3 = p384_affinify(p384_ec_full_sub(p384_base4, p384_base))\n\np384_base5 : AffinePoint [384]\np384_base5 = p384_affinify(p384_ec_full_add(p384_base4, p384_base))\n\n\n\/* Does an affine point lie on the curve? *\/\np384_is_affine_point : AffinePoint [384] -> Bit\np384_is_affine_point p =\n  p384_field_sq(p.y) ==\n  p384_field_add(p384_field_cube(p.x),\n                 p384_field_add(p384_field_mul(p384_a, p.x), p384_b))\n```"}]}
{"filename":"saw-script\/examples\/llvm\/safety\/set.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from set.bc and defines a let-bound spec named set_spec. The spec should symbolically allocate an array of 10 32-bit integers, create symbolic variables for the index i and value v, add a precondition ensuring i is less than 10 to guarantee safe array access, execute the LLVM function 'set' with these arguments, and verify that the array is updated at index i with value v. Use llvm_fresh_var for symbolic inputs and llvm_points_to for memory assertions. Finally, invoke llvm_verify on the module with the set_spec to verify the correctness of the 'set' function.\n\n# Source code:\nset.c\n```C\nvoid set(int *a, int i, int v) {\n    a[i] = v;\n}\n\n```"},{"role":"assistant","content":"```saw\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet set_bad_spec n = do {\n    (a, ap) <- ptr_to_fresh \"a\" (llvm_array n (llvm_int 32));\n    i <- llvm_fresh_var \"i\" (llvm_int 32);\n    v <- llvm_fresh_var \"v\" (llvm_int 32);\n    llvm_execute_func [ap, llvm_term i, llvm_term v];\n    llvm_points_to ap (llvm_term {{ update a i v }});\n};\n\nlet set_good_spec n = do {\n    (a, ap) <- ptr_to_fresh \"a\" (llvm_array n (llvm_int 32));\n    i <- llvm_fresh_var \"i\" (llvm_int 32);\n    v <- llvm_fresh_var \"v\" (llvm_int 32);\n\n    \/\/ The ` in the following is to convert an unbounded integer into a\n    \/\/ fixed-size bit vector.\n    llvm_precond {{ i < (`n : [32]) }};\n\n    llvm_execute_func [ap, llvm_term i, llvm_term v];\n\n    llvm_points_to ap (llvm_term {{ update a i v }});\n};\n\nm <- llvm_load_module \"set.bc\";\n\nllvm_verify m \"set\" [] false (set_good_spec 10) abc;\nfails (llvm_verify m \"set\" [] false (set_bad_spec 10) abc);\n```"}]}
{"filename":"saw-script\/examples\/llvm\/iterative_average\/test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that formally verifies the correctness of the imperative iterative average implementation by proving that for any input sequence, the digest computed from the updated state equals the pure average function applied to the same sequence."},{"role":"assistant","content":"```cryptol\n\/\/ Imperative, iterative average.\n\ntype State =\n  { sum : [32]\n  , len : [32]\n  }\n\ninit : State\ninit =\n  { sum = 0\n  , len = 0\n  }\n\nupdatef : {n} (fin n, 32 >= width n) => State -> [n][32] -> State\nupdatef st xs =\n  { sum = st.sum + sum\n  , len = st.len + `n\n  }\n  where\n    sum = sums!0\n    sums = [ 0 ] # [ acc + x | acc <- sums | x <- xs ]\n\ndigest : State -> [32]\ndigest st = st.sum \/ st.len\n\n\/\/ Pure average.\n\navg : {n} (fin n, 32 >= width n) => [n][32] -> [32]\navg xs = sum \/ `n\n  where\n    sum = sums!0\n    sums = [ 0 ] # [ acc + x | acc <- sums | x <- xs ]\n\n\/\/ Tests.\n\nimp_correct : {n} (fin n, 32 >= width n) => [n][32] -> Bool\nproperty imp_correct xs = avg xs == digest (updatef init xs)\n```"}]}
{"filename":"saw-script\/examples\/llvm\/iterative_average\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM module loaded from \"tmp\/test.bc\" that verifies the C functions 'init', 'update', and 'digest' defined in test.c. Define let-bound specs named 'init_spec', 'update_spec', and 'digest_spec' respectively. Use 'llvm_fresh_var' to create symbolic inputs for pointers and arrays, ensuring minimal preconditions such as nonzero length to avoid division by zero in 'digest'. Use 'llvm_execute_func' to execute each function with appropriate symbolic arguments. Use 'llvm_points_to' to specify expected memory states before and after function execution, referencing the exact struct 'state' and array types as in the source. Do not inline specs directly in calls; bind them with let. Do not reference solvers explicitly.\n\n# Source code:\ntest.c\n```C\n\/* Imperative, iterative average computation, in the style of an\n   imperative hash.\n\n   The imperative hash implementations in e.g. OpenSSL have this\n   style: initialize the state, update the state by hashing\n   incrementally one or more times, extract (digest) the hash value at\n   the end (e.g. by padding as necessary before hashing a final block\n   internally).\n\n   Here we verify a trivial example -- averaging a sequence of numbers\n   -- implemnted in the same init, update, digest style.\n*\/\n\n#include <stdint.h>\n#include <stdio.h>\n\ntypedef struct {\n  uint32_t sum;\n  uint32_t len;\n} state;\n\nvoid init(state *st) {\n  st->sum = 0;\n  st->len = 0;\n}\n\nvoid update(state *st, uint32_t *xs, uint32_t len) {\n  for (int i = 0; i < len; ++i ) {\n    st->sum += xs[i];\n  }\n  st->len += len;\n}\n\nvoid digest(state *st, uint32_t *avg) {\n  *avg = st->sum \/ st->len;\n}\n\nint main(int argc, char *argv[]) {\n  state st;\n  init(&st);\n  uint32_t xs[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n  uint32_t ys[] = { 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 };\n  update(&st, xs, sizeof(xs)\/sizeof(uint32_t));\n  update(&st, ys, sizeof(ys)\/sizeof(uint32_t));\n  uint32_t avg;\n  digest(&st, &avg);\n  printf(\"The average is %i.\\n\", avg);\n}\n\n```"},{"role":"assistant","content":"```saw\nimport \"test.cry\";\nm <- llvm_load_module \"tmp\/test.bc\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\n\/\/ Verify 'init'.\n\nlet init_spec = do {\n  (s, sp) <- ptr_to_fresh \"st\" (llvm_alias \"struct.state\");\n\n  llvm_execute_func [sp];\n\n  let res = llvm_struct_value [ llvm_term {{ init.sum }}\n                              , llvm_term {{ init.len }}\n                              ];\n  llvm_points_to sp res;\n};\nprint \"Verifying 'init' using 'llvm_verify':\";\ninit_ov <- llvm_verify m \"init\" [] true init_spec abc;\nprint \"\";\n\n\/\/ Verify 'update'.\n\nlet update_spec xs_len = do {\n  (st0, stp) <- ptr_to_fresh \"st\" (llvm_alias \"struct.state\");\n  (xs0, xsp) <- ptr_to_fresh \"xs\" (llvm_array xs_len (llvm_int 32));\n\n  llvm_execute_func [stp, xsp, llvm_term {{ `xs_len : [32] }}];\n\n  let st1 = {{ updatef {sum = st0.0, len = st0.1} xs0 }};\n\n\n  let res = llvm_struct_value [ llvm_term {{ st1.sum }}\n                              , llvm_term {{ st1.len }}\n                              ];\n  llvm_points_to stp res;\n  \/\/ Also prove that the content of xs is unchanged.\n  llvm_points_to xsp (llvm_term xs0);\n};\nprint \"Verifying 'update' using 'llvm_verify':\";\nupdate_ov <- llvm_verify m \"update\" [] true (update_spec 3) abc;\nprint \"\";\n\n\/\/ Verify 'digest'.\n\nlet digest_spec = do {\n  (st0, stp) <- ptr_to_fresh \"st\" (llvm_alias \"struct.state\");\n  avgp <- llvm_alloc (llvm_int 32);\n\n  \/\/ Avoid division by zero\n  llvm_precond {{ st0.1 != 0 }};\n\n  llvm_execute_func [stp, avgp];\n\n  llvm_points_to avgp (llvm_term {{ digest {sum = st0.0, len = st0.1} }});\n  \/\/ Also prove that the content of 'st' is unchanged.\n  llvm_points_to stp (llvm_term st0);\n\n};\nprint \"Verifying 'digest' using 'llvm_verify':\";\ndigest_ov <- llvm_verify m \"digest\" [] true digest_spec abc;\nprint \"\";\n\n\/\/ Verify imperative spec against pure spec.\n\nlet check n = do {\n    print (str_concat \"Checking imp_correct for byte count \" (show n));\n    time (prove_print abc {{ imp_correct`{n} }});\n};\n\nfor [0, 32, 64] check;\n```"}]}
{"filename":"saw-script\/examples\/llvm\/union\/test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the function 'inc' correctly implements the increment behavior for both 'Inc_1_st' and 'Inc_2_st' states, ensuring that when 'alg' is INC_1, only 'x' is incremented by 1, and when 'alg' is INC_2, both 'x' and 'y' are incremented by 1. Include properties that check the correctness of the conversions between the bit representation and the structured states."},{"role":"assistant","content":"```cryptol\ntype Alg = [32]\nINC_1 = 0 : Alg\nINC_2 = 1 : Alg\n\ntype Inc_1_st =\n  { x : [32]\n  }\n\ntype Inc_2_st =\n  { x : [32]\n  , y : [32]\n  }\n\ntype UNION_BITS = 32+32\n\n\/\/ The 'bits' field contains a enough bits to hold the largest type in\n\/\/ the union, i.e. 'Inc_2_st'.\n\ntype St =\n  { alg : Alg\n  , bits : [UNION_BITS]\n  }\n\nbits_to_inc_1_st : [UNION_BITS] -> Inc_1_st\nbits_to_inc_1_st bits = { x = take`{32} bits }\n\n\/\/ We need the original bits to supply the bits we dropped when\n\/\/ translating to 'Inc_1_st'. Alternatively, we could add another\n\/\/ field to 'Inc_1_st' to hold the extra, otherwise unused bits.\ninc_1_st_to_bits : [UNION_BITS] -> Inc_1_st -> [UNION_BITS]\ninc_1_st_to_bits bits st = st.x # drop`{32} bits\n\nbits_to_inc_2_st : [UNION_BITS] -> Inc_2_st\nbits_to_inc_2_st bits = { x = take`{32} bits, y = drop`{32} bits }\ninc_2_st_to_bits : Inc_2_st -> [UNION_BITS]\ninc_2_st_to_bits st = st.x # st.y\n\ninc : St -> St\ninc st = { alg = st.alg, bits = bits }\n  where\n    bits =\n      if st.alg == INC_1 then\n        inc_1_st_to_bits st.bits\n          (inc_1 (bits_to_inc_1_st st.bits))\n      else\n        inc_2_st_to_bits\n          (inc_2 (bits_to_inc_2_st st.bits))\n\ninc_1 : Inc_1_st -> Inc_1_st\ninc_1 st = { x = st.x + 1 }\n\ninc_2 : Inc_2_st -> Inc_2_st\ninc_2 st = { x = st.x + 1, y = st.y + 1}\n```"}]}
{"filename":"saw-script\/examples\/llvm\/union\/test.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function 'inc' defined in 'test.c'. Load the LLVM module from 'tmp\/test.bc'. Define a let-bound spec 'inc_spec INC' that allocates and initializes a symbolic 'st' struct with symbolic fields for 'x' and 'y' as needed, sets the 'alg' field to the symbolic enum value INC, and models the union 'inc_st' accordingly. Use 'llvm_fresh_var' for symbolic inputs and add minimal preconditions to ensure safe execution (e.g., avoid division by zero). The spec should execute the 'inc' function with the prepared state and verify the postconditions reflecting the increment behavior for both INC_1 and INC_2 cases. Do not inline the spec in the call to 'llvm_verify'.\n\n# Source code:\ntest.c\n```C\n#include <stdint.h>\n\ntypedef enum { INC_1 , INC_2 } alg;\n\ntypedef struct {\n  uint32_t x;\n} inc_1_st;\n\ntypedef struct {\n  uint32_t x;\n  uint32_t y;\n} inc_2_st;\n\ntypedef struct {\n  alg alg;\n  union {\n    inc_1_st inc_1_st;\n    inc_2_st inc_2_st;\n  } inc_st;\n} st;\n\nuint32_t inc(st *st) {\n  switch (st->alg) {\n  case INC_1:\n    st->inc_st.inc_1_st.x += 1;\n    break;\n  case INC_2:\n    st->inc_st.inc_2_st.x += 1;\n    st->inc_st.inc_2_st.y += 1;\n    break;\n  default:\n    return 1\/0;\n  }\n  return 0;\n}\n\n```"},{"role":"assistant","content":"```saw\nimport \"test.cry\";\nm <- llvm_load_module \"tmp\/test.bc\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\n\/\/ Verify using 'llvm_verify'.\n\n\/\/ The argument 'INC' specifies which 'alg' enum to test.\nlet inc_spec INC = do {\n\n  stp <- llvm_alloc (llvm_alias \"struct.st\");\n\n  \/\/ The union is represented by the largest element type,\n  \/\/ i.e. 'inc_2_st'. The inner '.0' dereferences the union itself.\n  x0 <- llvm_fresh_var \"((st->1).0).0\" (llvm_int 32);\n  y0 <- llvm_fresh_var \"((st->1).0).1\" (llvm_int 32);\n\n  llvm_points_to (llvm_elem stp 0) (llvm_term {{ INC }});\n  llvm_points_to (llvm_elem (llvm_elem (llvm_elem stp 1) 0) 0) (llvm_term x0);\n  llvm_points_to (llvm_elem (llvm_elem (llvm_elem stp 1) 0) 1) (llvm_term y0);\n\n  llvm_execute_func [stp];\n\n  \/\/ We construct an 'inc_2_st' here independent of 'INC', since we\n  \/\/ need to account for all of the bits in the union field 'inc_st',\n  \/\/ and 'inc_1_st' only has half the bits.\n  let inc_2_st0 = {{ { x = x0, y = y0 } }};\n  let st0 = {{\n    { alg = INC\n    , bits = inc_2_st_to_bits inc_2_st0\n    }\n  }};\n  let st1 = {{ inc st0 }};\n  let inc_2_st1 = {{ bits_to_inc_2_st st1.bits }};\n\n  llvm_points_to (llvm_elem stp 0) (llvm_term {{ st1.alg }});\n  llvm_points_to (llvm_elem (llvm_elem (llvm_elem stp 1) 0) 0) (llvm_term {{ inc_2_st1.x }});\n  llvm_points_to (llvm_elem (llvm_elem (llvm_elem stp 1) 0) 1) (llvm_term {{ inc_2_st1.y }});\n\n  llvm_return (llvm_term {{ 0 : [32] }});\n};\n\nprint \"Verifying 'inc_1' using 'llvm_verify':\";\nllvm_verify m \"inc\" [] true (inc_spec {{ INC_1 }}) abc;\nprint \"\";\n\nprint \"Verifying 'inc_2' using 'llvm_verify':\";\nllvm_verify m \"inc\" [] true (inc_spec {{ INC_2 }}) abc;\nprint \"\";\n```"}]}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/xordomain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that formally specify the soundness of the bxor, band, and band_scalar operations in the xordomain module. These properties should verify that the membership predicate holds correctly after applying each operation, ensuring that the abstract domain operations over-approximate the concrete bitwise XOR and AND semantics. Include properties for a fixed bit-width (e.g., 16) to enable automated checking."},{"role":"assistant","content":"```cryptol\n\/*\nThis file contains a Cryptol implementation of a specialzed bitwise\nabstract domain that is optimized for the XOR\/AND semiring representation.\nThe standard bitwise domain from \"bitsdomain.cry\" requires 6 bitwise\noperations to compute XOR, whereas AND and OR only requre 2.\nIn this domain, XOR and AND both can be computed in 3 bitwise operations,\nand scalar AND can be computed in 2.\n*\/\n\nmodule xordomain where\n\n\/\/ In this presentation \"val\" is a bitwise upper bound on\n\/\/ the values in the set, and \"unknown\" represents all the\n\/\/ bits whose values are not concretely known\ntype Dom n = { val : [n], unknown : [n] }\n\n\/\/ Membership predicate for the XOR bitwise domain\nmem : {n} (fin n) => Dom n -> [n] -> Bit\nmem a x = a.val == x || a.unknown\n\nbxor : {n} (fin n) => Dom n -> Dom n -> Dom n\nbxor a b = { val = v || u, unknown = u }\n  where\n  v = a.val ^ b.val\n  u = a.unknown || b.unknown\n\nband : {n} (fin n) => Dom n -> Dom n -> Dom n\nband a b = { val = v, unknown = u && v }\n  where\n  v   = a.val && b.val\n  u   = a.unknown || b.unknown\n\nband_scalar : {n} (fin n) => Dom n -> [n] -> Dom n\nband_scalar a x = { val = a.val && x, unknown = a.unknown && x }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Soundness properties\n\ncorrect_bxor : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_bxor a b x y =\n  mem a x ==> mem b y ==> mem (bxor a b) (x ^ y)\n\ncorrect_band : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_band a b x y =\n  mem a x ==> mem b y ==> mem (band a b) (x && y)\n\ncorrect_band_scalar : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_band_scalar a x y =\n  mem a x ==> mem (band_scalar a y) (x && y)\n\nproperty x1 = correct_bxor`{16}\nproperty x2 = correct_band`{16}\nproperty x3 = correct_band_scalar`{16}\n```"}]}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/bvdomain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties and proofs that verify the correctness and equivalence of the domain conversion functions and bitwise operations defined in the bvdomain module, ensuring that transformations between arithmetic, bitwise, and XOR domains preserve membership and operation semantics."},{"role":"assistant","content":"```cryptol\n\/*\n\nThis file gives Cryptol implementations for transferring between\nthe various bitvector domain representations and proofs of the\ncorrectness of these operations.\n*\/\n\nmodule bvdomain where\n\nimport arithdomain as A\nimport bitsdomain as B\nimport xordomain as X\n\n\n\/\/ Precondition `x <= mask`.  Find the (arithmetically) smallest\n\/\/  `z` above `x` which is bitwise above `mask`.  In other words\n\/\/ find the smallest `z` such that `x <= z` and `mask || z == z`.\n\nbitwise_round_above : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\nbitwise_round_above x mask = (x && ~q) ^ (mask && q)\n  where\n  q = A::fillright_alt ((x || mask) ^ x)\n\nbra_correct1 : {n} (fin n, n>=1) => [n] -> [n] -> Bit\nbra_correct1 x mask = mask <= x ==> (x <= q \/\\ B::bitle mask q)\n  where\n  q = bitwise_round_above x mask\n\nbra_correct2 : {n} (fin n, n>=1) => [n] -> [n] -> [n] -> Bit\nbra_correct2 x mask q' = (x <= q' \/\\ B::bitle mask q') ==> q <= q'\n  where\n  q = bitwise_round_above x mask\n\nproperty bra1 = bra_correct1`{64}\nproperty bra2 = bra_correct2`{64}\n\n\n\/\/ Precondition `lomask <= x <= himask` and `lomask || himask == himask`.\n\/\/ Find the (arithmetically) smallest `z` above `x` which is bitwise between\n\/\/ `lomask` and `himask`.  In otherwords, find the smallest `z` such that\n\/\/  `x <= z` and `lomask || z = z` and `z || himask == himask`.\nbitwise_round_between : {n} (fin n, n >= 1) => [n] -> [n] -> [n] -> [n]\nbitwise_round_between x lomask himask = if r == 0 then loup else final\n  \/\/ Read these steps from the bottom up...\n  where\n\n  \/\/ Finally mask out the low bits and only set those requried by the lomask\n  final = (upper && ~lowbits) || lomask\n\n  \/\/ add the correcting bit and mask out any extraneous bits set in\n  \/\/ the previous step\n  upper = (z + highbit) && himask\n\n  \/\/ set ourselves up so that when we add the high bit to correct,\n  \/\/ the carry will ripple until it finds a bit position that we\n  \/\/ are allowed to set.\n  z = loup || ~himask\n\n  \/\/ isolate just the highest incorrect bit\n  highbit = rmask ^ lowbits\n\n  \/\/ A mask for all the bits lower than the high bit of r\n  lowbits = rmask >> 1\n\n  \/\/ set all the bits to the right of the highest incorrect bit\n  rmask = A::fillright_alt r\n\n  \/\/ now compute all the bits that are set that are not allowed\n  \/\/ to be set according to the himask\n  r = loup && ~himask\n\n  \/\/ first, round up to the lomask\n  loup = bitwise_round_above x lomask\n\n\nbrb_correct1 : {n} (fin n, n>=1) => [n] -> [n] -> [n] -> Bit\nbrb_correct1 x lomask himask =\n    (B::bitle lomask himask \/\\ lomask <= x \/\\ x <= himask) ==>\n    (x <= q \/\\ B::bitle lomask q \/\\ B::bitle q himask)\n\n  where\n  q = bitwise_round_between x lomask himask\n\nbrb_correct2 : {n} (fin n, n>=1) => [n] -> [n] -> [n] -> [n] -> Bit\nbrb_correct2 x lomask himask q' = (x <= q' \/\\ B::bitle lomask q' \/\\ B::bitle q' himask) ==> q <= q'\n  where\n  q = bitwise_round_between x lomask himask\n\nproperty brb1 = brb_correct1`{64}\nproperty brb2 = brb_correct2`{64}\n\n\/\/ Interesting fact about arithmetic domains: the low values of the two domains\n\/\/ represent overlap candidates.  If neither low value is contained in the other domain,\n\/\/ then they do not overlap.\narith_overlap_candidates : {n} (fin n, n >= 1) => A::Dom n -> A::Dom n -> [n] -> Bit\narith_overlap_candidates a b x =\n  A::mem a x ==>\n  A::mem b x ==>\n  ((A::mem a b.lo \/\\ A::mem b b.lo) \\\/\n   (A::mem a a.lo \/\\ A::mem b a.lo))\n\n\/\/ Bitwise domains, if they overlap, must overlap in some specific points.  The bitwise\n\/\/ union of the low bounds is one.\nbitwise_overlap_candidates : {n} (fin n, n >= 1) => B::Dom n -> B::Dom n -> [n] -> Bit\nbitwise_overlap_candidates a b x =\n  B::mem a x ==>\n  B::mem b x ==>\n  (B::mem a witness \/\\ B::mem b witness)\n\n where\n witness = a.lomask || b.lomask\n\n\/\/ If mixed domains have some common value, then they must definintely overlap at one\n\/\/ of the following three listed candidate points.\nmixed_overlap_candidates : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> [n] -> Bit\nmixed_overlap_candidates a b x =\n  A::mem a x ==>\n  B::mem b x ==>\n  (A::mem a b.lomask \/\\ B::mem b b.lomask) \\\/\n  (A::mem a b.himask \/\\ B::mem b b.himask) \\\/\n  (A::mem a next     \/\\ B::mem b next)\n\n where\n next = bitwise_round_between a.lo b.lomask b.himask\n\n\n\/\/ A mixed domain overlap test.  It relies on testing special candidate overlap values.\n\/\/\n\/\/ If none of the overlap candidates are found in both domains, then the domains do not overlap.\n\/\/ On the other hand, if any canadiate is in both domains, it is a constructive witness of\n\/\/ overlap.\nmixed_domain_overlap : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> Bit\nmixed_domain_overlap a b =\n  A::mem a b.lomask \\\/ A::mem a b.himask \\\/ A::mem a (bitwise_round_between a.lo b.lomask b.himask)\n\n\/\/ If mixed domains have a common element, the overlap test will be true.\ncorrect_mixed_domain_overlap : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> [n] -> Bit\ncorrect_mixed_domain_overlap a b x =\n  A::mem a x ==>\n  B::mem b x ==>\n  mixed_domain_overlap a b\n\n\/\/ If the overlap test is true, then we can find some element they share in common,\n\/\/ provided the bitwise domain is nonempty.\ncorrect_mixed_domain_overlap_inv : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> Bit\ncorrect_mixed_domain_overlap_inv a b =\n  B::nonempty b ==> mixed_domain_overlap a b ==> (A::mem a witness \/\\ B::mem b witness)\n\n where\n witness = if A::mem a b.lomask then b.lomask else\n           if A::mem a b.himask then b.himask else\n           bitwise_round_between a.lo b.lomask b.himask\n\nproperty mx = correct_mixed_domain_overlap`{64}\nproperty mx_inv = correct_mixed_domain_overlap_inv`{64}\n\n\n\/\/ Operations that transfer between the domains\n\narithToBitDom : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n\narithToBitDom a = { lomask = lo, himask = hi }\n  where\n  u  = A::unknowns a\n  hi = a.lo || u\n  lo = hi ^ u\n\nbitToArithDom : {n} (fin n) => B::Dom n -> A::Dom n\nbitToArithDom b = A::range b.lomask b.himask\n\nbitToXorDom : {n} (fin n) => B::Dom n -> X::Dom n\nbitToXorDom b = { val = b.himask, unknown = b.lomask ^ b.himask }\n\nxorToBitDom : {n} (fin n) => X::Dom n -> B::Dom n\nxorToBitDom x = { lomask = x.val ^ x.unknown, himask = x.val }\n\narithToXorDom : {n} (fin n, n >= 1) => A::Dom n -> X::Dom n\narithToXorDom a = { val = a.lo || u, unknown = u }\n  where\n  u = A::unknowns a\n\n\/\/ A small collection of operations that start in one\n\/\/ domain and end in the other\n\npopcount : {n} (fin n, n>=1) => [n] -> [n]\npopcount bs = sum [ zero#[b] | b <- bs ]\n\ncountLeadingZeros : {n} (fin n, n>=1) => [n] -> [n]\ncountLeadingZeros x = loop 0\n where\n loop n =\n   if n >= length x then\n     length x\n   else\n     if x@n then n else loop (n+1)\n\ncountTrailingZeros : {n} (fin n, n>=1) => [n] -> [n]\ncountTrailingZeros xs = countLeadingZeros (reverse xs)\n\n\n\npopcnt : {n} (fin n, n>=1) => B::Dom n -> A::Dom n\npopcnt b = A::range lo hi\n  where\n  lo = popcount b.lomask\n  hi = popcount b.himask\n\nclz : {n} (fin n, n>=1) => B::Dom n -> A::Dom n\nclz b = A::range lo hi\n where\n lo = countLeadingZeros b.himask\n hi = countLeadingZeros b.lomask\n\nctz : {n} (fin n, n>=1) => B::Dom n -> A::Dom n\nctz b = A::range lo hi\n where\n lo = countTrailingZeros b.himask\n hi = countTrailingZeros b.lomask\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Correctness properties\n\ncorrect_arithToBitDom : {n} (fin n, n >= 1) => A::Dom n -> [n] -> Bit\ncorrect_arithToBitDom a x =\n  A::mem a x ==> B::mem (arithToBitDom a) x\n\ncorrect_bitToArithDom : {n} (fin n) => B::Dom n -> [n] -> Bit\ncorrect_bitToArithDom b x =\n  B::mem b x ==> A::mem (bitToArithDom b) x\n\ncorrect_bitToXorDom : {n} (fin n) => B::Dom n -> [n] -> Bit\ncorrect_bitToXorDom b x =\n  B::mem b x == X::mem (bitToXorDom b) x\n\ncorrect_xorToBitDom : {n} (fin n) => X::Dom n -> [n] -> Bit\ncorrect_xorToBitDom b x =\n  X::mem b x == B::mem (xorToBitDom b) x\n\ncorrect_arithToXorDom : {n} (fin n, n >= 1) => A::Dom n -> [n] -> Bit\ncorrect_arithToXorDom a x =\n  A::mem a x ==> X::mem (arithToXorDom a) x\n\nproperty t1 = correct_arithToBitDom`{16}\nproperty t2 = correct_bitToArithDom`{16}\nproperty t3 = correct_bitToXorDom`{16}\nproperty t4 = correct_xorToBitDom`{16}\nproperty t5 = correct_arithToXorDom`{16}\n\ncorrect_popcnt : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit\ncorrect_popcnt a x =\n  B::mem a x ==> A::mem (popcnt a) (popcount x)\n\ncorrect_clz : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit\ncorrect_clz a x =\n  B::mem a x ==> A::mem (clz a) (countLeadingZeros x)\n\ncorrect_ctz : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit\ncorrect_ctz a x =\n  B::mem a x ==> A::mem (ctz a) (countTrailingZeros x)\n\nproperty w1 = correct_popcnt`{16}\nproperty w2 = correct_clz`{16}\nproperty w3 = correct_ctz`{16}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Proofs that the XOR domain is really just an alternate way\n\/\/ to compute the same thing as the bitsdomain operations.\n\/\/ For \"band\" this requires the input domains to be nonempty,\n\/\/ which should be the case for all actual values of interest.\n\nequiv_bxor : {n} (fin n) => B::Dom n -> B::Dom n -> Bit\nequiv_bxor a b =\n  B::bxor a b == xorToBitDom (X::bxor (bitToXorDom a) (bitToXorDom b))\n\nequiv_band : {n} (fin n) => B::Dom n -> B::Dom n -> Bit\nequiv_band a b =\n  B::nonempty a \/\\ B::nonempty b ==>\n  B::band a b == xorToBitDom (X::band (bitToXorDom a) (bitToXorDom b))\n\nequiv_band_scalar : {n} (fin n) => B::Dom n -> [n] -> Bit\nequiv_band_scalar a x =\n  B::band a (B::singleton x) == xorToBitDom (X::band_scalar (bitToXorDom a) x)\n\n\nproperty e1 = equiv_bxor`{16}\nproperty e2 = equiv_band`{16}\nproperty e3 = equiv_band_scalar`{16}\n```"}]}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/bitsdomain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the bitwise bitvector abstract domain operations defined in the 'bitsdomain' module. These properties should prove that each domain operation (such as union, intersection, bitwise not, and shifts) correctly models the membership predicate and preserves domain invariants for all bit widths. Include proofs for soundness properties like correct_top, correct_singleton, correct_union, and others as specified in the module."},{"role":"assistant","content":"```cryptol\n\/*\n\nThis file contains a Cryptol implementation of the bitwise\nbitvector abstract domain operations from What4.Utils.BVDomain\n\nIn addition to the algorithms themselves, this file also contains\nspecifications of correctness for each of the operations. All of the\ncorrectness properties can be formally proven (each at some specific\nbit width) by loading this file in cryptol and entering \":prove\".\n\n*\/\nmodule bitsdomain where\n\n\/\/ This type represents _bitwise_ bounds as opposed to the\n\/\/ arithmetic bounds described by BVDom.  Note that\n\/\/ this representation allows the empty set if\n\/\/ lomask is not bitwise below himask.  However, all\n\/\/ the operations (other than intersection) preserve the property\n\/\/ of being nonempty (implied by their various soundness properties).\ntype Dom n = { lomask : [n] , himask : [n] }\n\n\/** Membership predicate that defines the set of concrete values\nrepresented by a bitwise abstract domain element. *\/\nmem : {n} (fin n) => Dom n -> [n] -> Bit\nmem a x = bitle a.lomask x \/\\ bitle x a.himask\n\nbitle : {n} (fin n) => [n] -> [n] -> Bit\nbitle x y = x || y == y\n\nnonempty : {n} (fin n) => Dom n -> Bit\nnonempty b = bitle b.lomask b.himask\n\nsingleton : {n} (fin n) => [n] -> Dom n\nsingleton x = { lomask = x, himask = x }\n\nisSingleton : {n} (fin n) => Dom n -> Bit\nisSingleton a = a.lomask == a.himask\n\ntop : {n} (fin n) => Dom n\ntop = { lomask = 0, himask = ~0 }\n\noverlap : {n} (fin n) => Dom n -> Dom n -> Bit\noverlap a b = nonempty (intersection a b)\n\nintersection : {n} (fin n) => Dom n -> Dom n -> Dom n\nintersection a b = { lomask = a.lomask || b.lomask, himask = a.himask && b.himask }\n\nunion : {n} (fin n) => Dom n -> Dom n -> Dom n\nunion a b = { lomask = a.lomask && b.lomask, himask = a.himask || b.himask }\n\nzero_ext : {m, n} (fin m, m >= n) => Dom n -> Dom m\nzero_ext a = { lomask = zext a.lomask, himask = zext a.himask }\n\nsign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> Dom m\nsign_ext a = { lomask = sext a.lomask, himask = sext a.himask }\n\nconcat : {m, n} (fin m, fin n) => Dom m -> Dom n -> Dom (m + n)\nconcat a b = { lomask = a.lomask # b.lomask, himask = a.himask # b.himask }\n\nshrink : {m, n} (fin m, fin n) => Dom (m + n) -> Dom m\nshrink a = { lomask = take`{m} a.lomask, himask = take`{m} a.himask }\n\ntrunc : {m, n} (fin m, fin n) => Dom (m + n) -> Dom n\ntrunc a = { lomask = drop`{m} a.lomask, himask = drop`{m} a.himask }\n\nbnot : {n} (fin n) => Dom n -> Dom n\nbnot b = { lomask = ~b.himask, himask = ~b.lomask }\n\nband : {n} (fin n) => Dom n -> Dom n -> Dom n\nband a b = { lomask = a.lomask && b.lomask, himask = a.himask && b.himask }\n\nbor : {n} (fin n) => Dom n -> Dom n -> Dom n\nbor a b = { lomask = a.lomask || b.lomask, himask = a.himask || b.himask }\n\n\/\/ Note, this requires quite a few more operations than AND and OR.\n\/\/ See \"xordomain.cry\" for a domain optimized for XOR and AND operations.\nbxor : {n} (fin n) => Dom n -> Dom n -> Dom n\nbxor a b = { lomask = lo, himask = hi }\n  where\n  ua = a.lomask ^ a.himask\n  ub = b.lomask ^ b.himask\n  c  = a.lomask ^ b.lomask\n  u  = ua || ub\n  hi = c || u\n  lo = hi ^ u\n\n\/\/ Note: shift and rotate operations in this domain only apply\n\/\/ when the shift amount is known\nshl : {n} (fin n) => Dom n -> [n] -> Dom n\nshl a x = { lomask = a.lomask << x', himask = a.himask << x' }\n  where x' = if x < `n then x else `n\n\nlshr : {n} (fin n) => Dom n -> [n] -> Dom n\nlshr a x = { lomask = a.lomask >> x', himask = a.himask >> x' }\n  where x' = if x < `n then x else `n\n\nashr : {n} (fin n, n >= 1) => Dom n -> [n] -> Dom n\nashr a x = { lomask = a.lomask >>$ x', himask = a.himask >>$ x' }\n  where x' = if x < `n then x else `n\n\nrol : {n} (fin n) => Dom n -> [n] -> Dom n\nrol a x = { lomask = a.lomask <<< x, himask = a.himask <<< x }\n\nror : {n} (fin n) => Dom n -> [n] -> Dom n\nror a x = { lomask = a.lomask >>> x, himask = a.himask >>> x }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Soundness properties\n\ncorrect_top : {n} (fin n) => [n] -> Bit\ncorrect_top x = mem top x\n\ncorrect_singleton : {n} (fin n) => [n] -> [n] -> Bit\ncorrect_singleton x y = mem (singleton x) y == (x == y)\n\ncorrect_overlap : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_overlap a b x =\n  mem a x ==> mem b x ==> overlap a b\n\ncorrect_overlap_inv : {n} (fin n) => Dom n -> Dom n -> Bit\ncorrect_overlap_inv a b =\n  overlap a b ==> (mem a (a.lomask || b.lomask) \/\\ mem b (a.lomask || b.lomask))\n\ncorrect_union : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_union a b x =\n  (mem a x \\\/ mem b x) ==> mem (union a b) x\n\ncorrect_intersection : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_intersection a b x =\n  (mem a x \/\\ mem b x) == mem (intersection a b) x\n\ncorrect_zero_ext : {m, n} (fin m, m >= n) => Dom n -> [n] -> Bit\ncorrect_zero_ext a x =\n  mem a x ==> mem (zero_ext`{m} a) (zext`{m} x)\n\ncorrect_sign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> [n] -> Bit\ncorrect_sign_ext a x =\n  mem a x ==> mem (sign_ext`{m} a) (sext`{m} x)\n\ncorrect_concat : {m, n} (fin m, fin n) => Dom m -> Dom n -> [m] -> [n] -> Bit\ncorrect_concat a b x y =\n  mem a x ==> mem b y ==> mem (concat a b) (x # y)\n\ncorrect_shrink : {m, n} (fin m, fin n) => Dom (m + n) -> [m+n] -> Bit\ncorrect_shrink a x =\n  mem a x ==> mem (shrink`{m} a) (take`{m} x)\n\ncorrect_trunc : {m, n} (fin m, fin n) => Dom (m + n) -> [m+n] -> Bit\ncorrect_trunc a x =\n  mem a x ==> mem (trunc`{m} a) (drop`{m} x)\n\ncorrect_isSingleton : {n} (fin n) => Dom n -> Bit\ncorrect_isSingleton a =\n  isSingleton a ==> a == singleton a.lomask\n\ncorrect_bnot : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_bnot a x =\n  mem a x == mem (bnot a) (~ x)\n\ncorrect_band : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_band a b x y =\n  mem a x ==> mem b y ==> mem (band a b) (x && y)\n\ncorrect_bor : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_bor a b x y =\n  mem a x ==> mem b y ==> mem (bor a b) (x || y)\n\ncorrect_bxor : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_bxor a b x y =\n  mem a x ==> mem b y ==> mem (bxor a b) (x ^ y)\n\ncorrect_shl : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_shl a x y =\n  mem a x ==> mem (shl a y) (x << y)\n\ncorrect_lshr : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_lshr a x y =\n  mem a x ==> mem (lshr a y) (x >> y)\n\ncorrect_ashr : {n} (fin n, n >= 1) => Dom n -> [n] -> [n] -> Bit\ncorrect_ashr a x y =\n  mem a x ==> mem (ashr a y) (x >>$ y)\n\ncorrect_rol : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_rol a x y =\n  mem a x ==> mem (rol a y) (x <<< y)\n\ncorrect_ror : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_ror a x y =\n  mem a x ==> mem (ror a y) (x >>> y)\n\nproperty b1 = correct_top`{16}\nproperty b2 = correct_singleton`{16}\nproperty b3 = correct_overlap`{16}\nproperty b4 = correct_overlap_inv`{16}\nproperty b5 = correct_union`{8}\nproperty b6 = correct_intersection`{8}\nproperty b7 = correct_zero_ext`{32, 16}\nproperty b8 = correct_sign_ext`{32, 16}\nproperty b9 = correct_concat`{16, 16}\nproperty b10 = correct_shrink`{8, 8}\nproperty b11 = correct_trunc`{8, 8}\nproperty b12 = correct_isSingleton`{16}\n\nproperty l1 = correct_bnot`{16}\nproperty l2 = correct_band`{16}\nproperty l3 = correct_bor`{16}\nproperty l4 = correct_bxor`{16}\n\nproperty s1 = correct_shl`{16}\nproperty s2 = correct_lshr`{16}\nproperty s3 = correct_ashr`{16}\nproperty s4 = correct_rol`{16}\nproperty s5 = correct_ror`{16}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Operations preserve singletons\n\nsingleton_overlap : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_overlap x y =\n  overlap (singleton x) (singleton y) == (x == y)\n\nsingleton_zero_ext : {m, n} (fin m, m >= n) => [n] -> Bit\nsingleton_zero_ext x =\n  zero_ext`{m} (singleton x) == singleton (zext`{m} x)\n\nsingleton_sign_ext : {m, n} (fin m, m >= n, n >= 1) => [n] -> Bit\nsingleton_sign_ext x =\n  sign_ext`{m} (singleton x) == singleton (sext`{m} x)\n\nsingleton_concat : {m, n} (fin m, fin n) => [m] -> [n] -> Bit\nsingleton_concat x y =\n  concat (singleton x) (singleton y) == singleton (x # y)\n\nsingleton_shrink : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_shrink x =\n  shrink`{m} (singleton x) == singleton (take`{m} x)\n\nsingleton_trunc : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_trunc x =\n  trunc`{m} (singleton x) == singleton (drop`{m} x)\n\nsingleton_bnot : {n} (fin n) => [n] -> Bit\nsingleton_bnot x =\n  bnot (singleton x) == singleton (~ x)\n\nsingleton_band : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_band x y =\n  band (singleton x) (singleton y) == singleton (x && y)\n\nsingleton_bor : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_bor x y =\n  bor (singleton x) (singleton y) == singleton (x || y)\n\nsingleton_bxor : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_bxor x y =\n  bxor (singleton x) (singleton y) == singleton (x ^ y)\n\nsingleton_shl : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_shl x y =\n  shl (singleton x) y == singleton (x << y)\n\nsingleton_lshr : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_lshr x y =\n  lshr (singleton x) y == singleton (x >> y)\n\nsingleton_ashr : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ashr x y =\n  ashr (singleton x) y == singleton (x >>$ y)\n\nproperty i01 = singleton_overlap`{16}\nproperty i02 = singleton_zero_ext`{32, 16}\nproperty i03 = singleton_sign_ext`{32, 16}\nproperty i04 = singleton_concat`{16, 16}\nproperty i05 = singleton_shrink`{8, 8}\nproperty i06 = singleton_trunc`{8, 8}\nproperty i07 = singleton_band`{16}\nproperty i08 = singleton_bor`{16}\nproperty i09 = singleton_bxor`{16}\nproperty i10 = singleton_bnot`{16}\nproperty i11 = singleton_shl`{8}\nproperty i12 = singleton_lshr`{8}\nproperty i13 = singleton_ashr`{8}\n```"}]}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/arithdomain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness and soundness of the arithmetic bitvector abstract domain operations defined in the 'arithdomain.cry' module. Include properties that prove the soundness of interval operations such as addition, multiplication, division, shifting, and union, as well as properties that verify the preservation of singletons and commutativity or associativity where applicable. Ensure the properties can be checked or proven using Cryptol's :prove command at specific bit widths."},{"role":"assistant","content":"```cryptol\n\/*\n\nThis file contains a Cryptol implementation of the arithmetic\nbitvector abstract domain operations from module What4.Utils.Domain in what4.\n\nIn addition to the algorithms themselves, this file also contains\nspecifications of correctness for each of the operations. All of the\ncorrectness properties can be formally proven (each at some specific\nbit width) by loading this file in cryptol and entering \":prove\".\n\n*\/\nmodule arithdomain where\n\nbit : {i, n} (fin n, n > i) => [n]\nbit = 1 # (0 : [i])\n\nmask : {i, n} (fin n, n >= i) => [n]\nmask = 0 # (~ 0 : [i])\n\n\/** Checked unsigned addition, asserted not to overflow. *\/\ninfixl 80 .+.\n(.+.) : {n} (fin n) => [n] -> [n] -> [n]\nx .+. y = if carry x y then error \"overflow\" else x + y\n\n\/** Checked unsigned subtraction, asserted not to underflow. *\/\ninfixl 80 .-.\n(.-.) : {n} (fin n) => [n] -> [n] -> [n]\nx .-. y = if x < y then error \"underflow\" else x - y\n\n\/** Minimum of two signed values. *\/\nsmin : {a} (SignedCmp a) => a -> a -> a\nsmin x y = if x <$ y then x else y\n\n\/** Maximum of two signed values. *\/\nsmax : {a} (SignedCmp a) => a -> a -> a\nsmax x y = if x >$ y then x else y\n\ntype Dom n = { lo : [n], sz : [n] }\n\ninterval : {n} (fin n) => [n] -> [n] -> Dom n\ninterval l s = { lo = l, sz = s }\n\nrange : {n} (fin n) => [n] -> [n] -> Dom n\nrange lo hi = interval lo (hi - lo)\n\n\/** Membership predicate that defines the set of concrete values\nrepresented by an abstract domain element. *\/\nmem : {n} (fin n) => Dom n -> [n] -> Bit\nmem a x = x - a.lo <= a.sz\n\numem : {n} (fin n) => ([n], [n]) -> [n] -> Bit\numem (lo, hi) x = lo <= x \/\\ x <= hi\n\nsmem : {n} (fin n, n >= 1) => ([n], [n]) -> [n] -> Bit\nsmem (lo, hi) x = lo <=$ x \/\\ x <=$ hi\n\ntop : {n} (fin n) => Dom n\ntop = interval 0 (~ 0)\n\nsingleton : {n} (fin n) => [n] -> Dom n\nsingleton x = interval x 0\n\nisSingleton : {n} (fin n) => Dom n -> Bit\nisSingleton a = a.sz == 0\n\nubounds : {n} (fin n) => Dom n -> ([n], [n])\nubounds a =\n  if carry a.lo a.sz then (0, ~0) else (a.lo, a.lo + a.sz)\n\nsbounds : {n} (fin n, n >= 1) => Dom n -> ([n], [n])\nsbounds a = (lo - delta, hi - delta)\n  where\n    delta = reverse 1\n    (lo, hi) = ubounds (interval (a.lo + delta) a.sz)\n\n\/** Nonzero signed values in a domain with the least and greatest\nreciprocals. Note that this coincides with the greatest and least\nnonzero values using the unsigned ordering. *\/\nrbounds : {n} (fin n, n >= 1) => Dom n -> ([n], [n])\nrbounds a =\n  if a.lo == 0 then (a_hi, 1) else\n  if a_hi == 0 then (-1, a.lo) else\n  if a_hi < a.lo then (-1, 1) else\n  (a_hi, a.lo)\n  where a_hi = a.lo + a.sz\n\noverlap : {n} (fin n) => Dom n -> Dom n -> Bit\noverlap a b = diff <= b.sz \\\/ carry diff a.sz\n  where diff = a.lo - b.lo\n\n\/\/ To compute the union of two intervals, we choose representatives of\n\/\/ the endpoints modulo 2^n such that their midpoints are no more than\n\/\/ 2^(n-1) apart. In the code below, am and bm are equal to twice the\n\/\/ midpoints of intervals a and b, respectively.\nunion : {n} (fin n) => Dom n -> Dom n -> Dom n\nunion a b =\n  if cw >= size then top else interval (drop`{2} cl) (drop`{2} cw)\n  where\n    size : [n+2]\n    size = bit`{n}\n    am = 2 * zext a.lo .+. zext a.sz\n    bm = 2 * zext b.lo .+. zext b.sz\n    al' = if am .+. size < bm then zext a.lo .+. size else zext a.lo\n    bl' = if bm .+. size < am then zext b.lo .+. size else zext b.lo\n    ah' = al' .+. zext a.sz\n    bh' = bl' .+. zext b.sz\n    cl = min al' bl'\n    ch = max ah' bh'\n    cw = ch .-. cl\n\nzero_ext : {m, n} (fin m, m >= n) => Dom n -> Dom m\nzero_ext a = interval (zext lo) (zext (hi .-. lo))\n  where (lo, hi) = ubounds a\n\nsign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> Dom m\nsign_ext a = interval (sext lo) (zext (hi - lo))\n  where (lo, hi) = sbounds a\n\nconcat : {m, n} (fin m, fin n) => Dom m -> Dom n -> Dom (m + n)\nconcat a b = interval (a.lo # lo) (a.sz # sz)\n  where\n    (lo, hi) = ubounds b\n    sz = hi .-. lo\n\nshrink : {m, n} (fin m, fin n) => Dom (m + n) -> Dom m\nshrink a =\n  if b_sz >= size then top\n  else interval (tail b_lo) (tail b_sz)\n  where\n    size : [1 + m]\n    size = bit`{m}\n    b_lo, b_hi, b_sz : [1 + m]\n    b_lo = take`{back=n} (zext a.lo)\n    b_hi = take`{back=n} (zext a.lo .+. zext a.sz)\n    b_sz = b_hi .-. b_lo\n\ntrunc : {m, n} (fin m, fin n) => Dom (m + n) -> Dom n\ntrunc a =\n  if a.sz > mask`{n} then top\n  else interval (drop`{m} a.lo) (drop`{m} a.sz)\n\nadd : {n} (fin n) => Dom n -> Dom n -> Dom n\nadd a b =\n  if carry a.sz b.sz then top\n  else interval (a.lo + b.lo) (a.sz .+. b.sz)\n\nneg : {n} (fin n) => Dom n -> Dom n\nneg a = interval (- (a.lo + a.sz)) a.sz\n\n\/\/ Turns out, bitwise complement is easy to specify\n\/\/ in this domain also\nbnot : {n} (fin n) => Dom n -> Dom n\nbnot a = interval (~ ah) a.sz\n  where ah = a.lo + a.sz\n\nmul : {n} (fin n) => Dom n -> Dom n -> Dom n\nmul a b =\n  if sz >= bit`{n} then top\n  else interval (drop lo) (drop sz)\n  where\n    (lo, hi) = mulRange (zbounds a) (zbounds b)\n    sz = hi - lo\n\nzbounds : {n} (fin n) => Dom n -> ([1 + n], [1 + n])\nzbounds a = (lo', lo' + zext a.sz)\n  where\n    size : [2 + n]\n    size = bit`{n}\n    lo' = if 2 * zext a.lo .+. zext a.sz >= size then 0b1 # a.lo else 0b0 # a.lo\n\nmulRange : {m, n} (fin m, fin n, m >= 1, n >= 1) => ([m], [m]) -> ([n], [n]) -> ([m+n], [m+n])\nmulRange (xl, xh) (yl, yh) = (zl, zh)\n  where\n    (xlyl, xlyh) = scaleRange xl (yl, yh)\n    (xhyl, xhyh) = scaleRange xh (yl, yh)\n    zl = smin xlyl xhyl\n    zh = smax xlyh xhyh\n\nscaleRange : {m, n} (fin m, fin n, m >= 1, n >= 1) => [m] -> ([n], [n]) -> ([m+n], [m+n])\nscaleRange k (lo, hi) = if k <$ 0 then (hi', lo') else (lo', hi')\n  where\n    lo' = sext k * sext lo\n    hi' = sext k * sext hi\n\nudiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nudiv a b = range cl ch\n  where\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    bl' = max 1 bl \/\/ assume that division by 0 does not happen\n    bh' = max 1 bh \/\/ assume that division by 0 does not happen\n    cl = al \/ bh'\n    ch = ah \/ bl'\n\nurem : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nurem a b =\n  if ql == qh then range rl rh\n  else interval 0 (bh - 1)\n  where\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    bl' = max 1 bl \/\/ assume that division by 0 does not happen\n    bh' = max 1 bh\n    (ql, rl) = (al \/ bh', al % bh')\n    (qh, rh) = (ah \/ bl', ah % bl')\n\n\/\/ The first argument is an ordinary signed interval, but the second\n\/\/ argument is a reciaprocal interval: The arguments should satisfy 'al\n\/\/ <=$ ah' (signed) and '1\/bl <= 1\/bh' (signed), or equivalently, 'bh\n\/\/ <= bl' (unsigned).\nsdivRange : {n} (fin n, n >= 1) => ([n], [n]) -> ([n], [n]) -> ([1+n], [1+n])\nsdivRange (al, ah) (bl, bh) = (ql, qh)\n  where\n    (ql1, qh1) = shrinkRange (al, ah) bh\n    (ql2, qh2) = shrinkRange (al, ah) bl\n    ql = smin ql1 ql2\n    qh = smax qh1 qh2\n\n\/\/ Extra bit of output is to handle the 'INTMIN \/ -1' overflow case.\nshrinkRange : {n} (fin n, n >= 1) => ([n], [n]) -> [n] -> ([1+n], [1+n])\nshrinkRange (lo, hi) k =\n  if k >$ 0 then (lo .\/. k, hi .\/. k) else\n  if k <$ 0 then (hi .\/. k, lo .\/. k) else (sext lo, sext hi)\n  where\n    x .\/. y = sext x \/$ sext y\n\nsdiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nsdiv a b =\n  if sz >= bit`{n} then top\n  else interval (drop lo) (drop sz)\n  where\n    (lo, hi) = sdivRange (sbounds a) (rbounds b)\n    sz = hi - lo\n\nsrem : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nsrem a b =\n  if ql == qh then\n    (if ql <$ 0\n     then range (al - drop ql * bl) (ah - drop ql * bh)\n     else range (al - drop ql * bh) (ah - drop ql * bl))\n  else range rl rh\n  where\n    (al, ah) = sbounds a\n    (bl, bh) = sbounds b\n    (ql, qh) = sdivRange (al, ah) (rbounds b)\n    rl = if al <$ 0 then smin (bl+1) (-bh+1) else 0\n    rh = if ah >$ 0 then smax (-bl-1) (bh-1) else 0\n\nshl : {n} (fin n) => Dom n -> Dom n -> Dom n\nshl a b =\n  if sz > mask`{n} then top\n  else interval (drop lo) (drop sz)\n  where\n    al, ah : [n + 1]\n    (al, ah) = zbounds a\n    bl, bh : [n]\n    (bl, bh) = ubounds b\n    \/\/ [n + 2] is enough to avoid signed overflow in shift\n    cl, ch : [n + 2]\n    cl = if bl < `n then 1 << bl else bit`{n}\n    ch = if bh < `n then 1 << bh else bit`{n}\n    (lo, hi) = mulRange (al, ah) (cl, ch)\n    sz = hi - lo\n\nlshr : {n} (fin n) => Dom n -> Dom n -> Dom n\nlshr a b = interval cl (ch - cl)\n  where\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    cl = al >> bh\n    ch = ah >> bl\n\nashr : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nashr a b = interval cl (ch - cl)\n  where\n    (al, ah) = sbounds a\n    (bl, bh) = ubounds b\n    cl = al >>$ (if al <$ 0 then bl else bh)\n    ch = ah >>$ (if ah <$ 0 then bh else bl)\n\nult : {n} (fin n) => Dom n -> Dom n -> Bit\nult a b = (ubounds a).1 < (ubounds b).0\n\nule : {n} (fin n) => Dom n -> Dom n -> Bit\nule a b = (ubounds a).1 <= (ubounds b).0\n\nslt : {n} (fin n, n >= 1) => Dom n -> Dom n -> Bit\nslt a b = (sbounds a).1 <$ (sbounds b).0\n\nsle : {n} (fin n, n >= 1) => Dom n -> Dom n -> Bit\nsle a b = (sbounds a).1 <=$ (sbounds b).0\n\nult_sum_common_equiv : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nult_sum_common_equiv a b c =\n  if al == ah \/\\ bl == bh \/\\ al == bl\n    then True\n    else if ~(carry cl c.sz)\n      then check_same_wrap_interval cl ch\n      else check_same_wrap_interval cl mask`{n} \/\\ check_same_wrap_interval 0 ch\n  where\n    (cl, ch) = (c.lo, c.lo + c.sz)\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    check_same_wrap_interval lo hi =\n      ~(carry ah hi) \/\\ ~(carry bh hi) \\\/ carry al lo \/\\ carry bl lo\n\n\/\/ A bitmask indicating which bits cannot be determined\n\/\/ given the interval information in the given domain\nunknowns : {n} (fin n, n >= 1) => Dom n -> [n]\nunknowns a = if carry a.lo a.sz then ~0 else bits\n where\n bits = fillright diff\n diff = a.lo ^ (a.lo + a.sz)\n\nfillright : {n} (fin n, n >= 1) => [n] -> [n]\nfillright x = tail (scanl (||) False x)\n\nfillright_alt : {n} (fin n, n >= 1) => [n] -> [n]\nfillright_alt x = x || ((1 << lg2 x) - 1)\n\nproperty fillright_equiv x = fillright`{16} x == fillright_alt x\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Correctness properties\n\ninfix 20 =@=\n\n\/** Equivalence of bitvector domains. *\/\n(=@=) : {n} (fin n) => Dom n -> Dom n -> Bit\na =@= b = (a.sz == ~0 \/\\ b.sz == ~0) \\\/ (a == b)\n\ninfix 5 <==>\n\n(<==>) : Bit -> Bit -> Bit\n(<==>) = (==)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Soundness properties\n\ncorrect_top : {n} (fin n) => [n] -> Bit\ncorrect_top x = mem top x\n\ncorrect_ubounds : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_ubounds a x =\n  mem a x ==> umem (ubounds a) x\n\ncorrect_sbounds : {n} (fin n, n >= 1) => Dom n -> [n] -> Bit\ncorrect_sbounds a x =\n  mem a x ==> smem (sbounds a) x\n\ncorrect_singleton : {n} (fin n) => [n] -> [n] -> Bit\ncorrect_singleton x y =\n  mem (singleton x) y <==> x == y\n\ncorrect_overlap : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_overlap a b x =\n  mem a x ==> mem b x ==> overlap a b\n\ncorrect_overlap_inv : {n} (fin n) => Dom n -> Dom n -> Bit\ncorrect_overlap_inv a b =\n  overlap a b ==> (mem a witness \/\\ mem b witness)\n\n where\n witness = if mem a b.lo then b.lo else a.lo\n\ncorrect_union : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_union a b x =\n  (mem a x \\\/ mem b x) ==> mem (union a b) x\n\ncorrect_zero_ext : {m, n} (fin m, m >= n) => Dom n -> [n] -> Bit\ncorrect_zero_ext a x =\n  mem a x ==> mem (zero_ext`{m} a) (zext`{m} x)\n\ncorrect_sign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> [n] -> Bit\ncorrect_sign_ext a x =\n  mem a x ==> mem (sign_ext`{m} a) (sext`{m} x)\n\ncorrect_concat : {m, n} (fin m, fin n) => Dom m -> Dom n -> [m] -> [n] -> Bit\ncorrect_concat a b x y =\n  mem a x ==> mem b y ==> mem (concat a b) (x # y)\n\ncorrect_shrink : {m, n} (fin m, fin n) => Dom (m + n) -> [m + n] -> Bit\ncorrect_shrink a x =\n  mem a x ==> mem (shrink`{m} a) (take`{m} x)\n\ncorrect_trunc : {m, n} (fin m, fin n) => Dom (m + n) -> [m + n] -> Bit\ncorrect_trunc a x =\n  mem a x ==> mem (trunc`{m} a) (drop`{m} x)\n\ncorrect_add : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_add a b x y =\n  mem a x ==> mem b y ==> mem (add a b) (x + y)\n\ncorrect_neg : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_neg a x =\n  mem a x <==> mem (neg a) (- x)\n\ncorrect_mul : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_mul a b x y =\n  mem a x ==> mem b y ==> mem (mul a b) (x * y)\n\ncorrect_mulRange : {n} (fin n, n >= 1) => ([n], [n]) -> ([n], [n]) -> [n] -> [n] -> Bit\ncorrect_mulRange a b x y =\n  smem a x ==> smem b y ==> smem (mulRange a b) (sext x * sext y)\n\ncorrect_udiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_udiv a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (udiv a b) (x \/ y)\n\ncorrect_urem : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_urem a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (urem a b) (x % y)\n\ncorrect_sdivRange : {n} (fin n, n >= 1) => ([n], [n]) -> ([n], [n]) -> [n] -> [n] -> Bit\ncorrect_sdivRange a b x y =\n  smem a x ==> umem b y ==> y != 0 ==> smem (sdivRange a (b.1, b.0)) (sext x \/$ sext y)\n\ncorrect_shrinkRange : {n} (fin n, n >= 1) => ([n], [n]) -> [n] -> [n] -> Bit\ncorrect_shrinkRange a x y =\n  smem a x ==> y != 0 ==> smem (shrinkRange a y) (sext x \/$ sext y)\n\ncorrect_sdiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_sdiv a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (sdiv a b) (x \/$ y)\n\ncorrect_srem : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_srem a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (srem a b) (x %$ y)\n\ncorrect_shl : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_shl a b x y =\n  mem a x ==> mem b y ==> mem (shl a b) (x << y)\n\ncorrect_lshr : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_lshr a b x y =\n  mem a x ==> mem b y ==> mem (lshr a b) (x >> y)\n\ncorrect_ashr : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_ashr a b x y =\n  mem a x ==> mem b y ==> mem (ashr a b) (x >>$ y)\n\ncorrect_slt : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_slt a b x y =\n  slt a b ==> mem a x ==> mem b y ==> x <$ y\n\ncorrect_sle : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_sle a b x y =\n  sle a b ==> mem a x ==> mem b y ==> x <=$ y\n\ncorrect_ult : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_ult a b x y =\n  ult a b ==> mem a x ==> mem b y ==> x < y\n\ncorrect_ule : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_ule a b x y =\n  ule a b ==> mem a x ==> mem b y ==> x <= y\n\ncorrect_ult_sum_common_equiv :\n  {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n -> [n] -> [n] -> [n] -> Bit\ncorrect_ult_sum_common_equiv a b c x y z =\n  ult_sum_common_equiv a b c ==>\n  mem a x ==> mem b y ==> mem c z ==>\n  (x + z < y + z <==> x < y)\n\ncorrect_bnot : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_bnot a x =\n  mem a x <==> mem (bnot a) (~ x)\n\ncorrect_isSingleton : {n} (fin n) => Dom n -> Bit\ncorrect_isSingleton a =\n  isSingleton a ==> a == singleton a.lo\n\ncorrect_unknowns : {n} (fin n, n >= 1) => Dom n -> [n] -> [n] -> Bit\ncorrect_unknowns a x y =\n  mem a x ==> mem a y ==> (x || unknowns a) == (y || unknowns a)\n\nproperty p1 = correct_top`{16}\nproperty p2 = correct_ubounds`{16}\nproperty p3 = correct_sbounds`{16}\nproperty p4 = correct_singleton`{16}\nproperty p5 = correct_overlap`{16}\nproperty p5_inv = correct_overlap_inv`{16}\nproperty p6 = correct_union`{8}\nproperty p7 = correct_zero_ext`{32, 16}\nproperty p8 = correct_sign_ext`{32, 16}\nproperty p9 = correct_concat`{16, 16}\nproperty p10 = correct_shrink`{8, 8}\nproperty p11 = correct_trunc`{8, 8}\nproperty p12 = correct_unknowns`{16}\nproperty p13 = correct_isSingleton`{16}\n\nproperty a1 = correct_add`{8}\nproperty a2 = correct_neg`{16}\nproperty a3 = correct_mul`{4}\nproperty a4 = correct_udiv`{8}\nproperty a5 = correct_urem`{6}\nproperty a6 = correct_sdiv`{6}\nproperty a7 = correct_srem`{6}\nproperty a8 = correct_bnot`{16}\nproperty a9 = correct_sdivRange`{6}\n\nproperty s1 = correct_shl`{8}\nproperty s2 = correct_lshr`{8}\nproperty s3 = correct_ashr`{8}\n\nproperty o1 = correct_slt`{16}\nproperty o2 = correct_sle`{16}\nproperty o3 = correct_ult`{16}\nproperty o4 = correct_ule`{16}\nproperty o5 = correct_ult_sum_common_equiv`{4}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Operations preserve singletons\n\nsingleton_overlap : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_overlap x y =\n  overlap (singleton x) (singleton y) == (x == y)\n\nsingleton_zero_ext : {m, n} (fin m, m >= n) => [n] -> Bit\nsingleton_zero_ext x =\n  zero_ext`{m} (singleton x) == singleton (zext`{m} x)\n\nsingleton_sign_ext : {m, n} (fin m, m >= n, n >= 1) => [n] -> Bit\nsingleton_sign_ext x =\n  sign_ext`{m} (singleton x) == singleton (sext`{m} x)\n\nsingleton_concat : {m, n} (fin m, fin n) => [m] -> [n] -> Bit\nsingleton_concat x y =\n  concat (singleton x) (singleton y) == singleton (x # y)\n\nsingleton_shrink : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_shrink x =\n  shrink`{m} (singleton x) == singleton (take`{m} x)\n\nsingleton_trunc : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_trunc x =\n  trunc`{m} (singleton x) == singleton (drop`{m} x)\n\nsingleton_add : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_add x y =\n  add (singleton x) (singleton y) == singleton (x + y)\n\nsingleton_neg : {n} (fin n) => [n] -> Bit\nsingleton_neg x =\n  neg (singleton x) == singleton (- x)\n\nsingleton_mul : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_mul x y =\n  mul (singleton x) (singleton y) == singleton (x * y)\n\nsingleton_mulRange : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_mulRange x y =\n  mulRange (x, x) (y, y) == (sext x * sext y, sext x * sext y)\n\nsingleton_udiv : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_udiv x y =\n  y != 0 ==> udiv (singleton x) (singleton y) == singleton (x \/ y)\n\nsingleton_urem : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_urem x y =\n  y != 0 ==> urem (singleton x) (singleton y) == singleton (x % y)\n\nsingleton_sdiv : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_sdiv x y =\n  y != 0 ==> sdiv (singleton x) (singleton y) == singleton (x \/$ y)\n\nsingleton_srem : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_srem x y =\n  y != 0 ==> srem (singleton x) (singleton y) == singleton (x %$ y)\n\nsingleton_shl : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_shl x y =\n  shl (singleton x) (singleton y) == singleton (x << y)\n\nsingleton_lshr : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_lshr x y =\n  lshr (singleton x) (singleton y) == singleton (x >> y)\n\nsingleton_ashr : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ashr x y =\n  ashr (singleton x) (singleton y) == singleton (x >>$ y)\n\nsingleton_slt : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_slt x y =\n  slt (singleton x) (singleton y) == (x <$ y)\n\nsingleton_sle : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_sle x y =\n  sle (singleton x) (singleton y) == (x <=$ y)\n\nsingleton_ult : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ult x y =\n  ult (singleton x) (singleton y) == (x < y)\n\nsingleton_ule : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ule x y =\n  ule (singleton x) (singleton y) == (x <= y)\n\nproperty i01 = singleton_overlap`{16}\nproperty i02 = singleton_zero_ext`{32, 16}\nproperty i03 = singleton_sign_ext`{32, 16}\nproperty i04 = singleton_concat`{16, 16}\nproperty i05 = singleton_shrink`{8, 8}\nproperty i06 = singleton_trunc`{8, 8}\nproperty i07 = singleton_add`{8}\nproperty i08 = singleton_neg`{16}\nproperty i09 = singleton_mul`{4}\nproperty i10 = singleton_udiv`{8}\nproperty i11 = singleton_urem`{8}\nproperty i12 = singleton_sdiv`{8}\nproperty i13 = singleton_srem`{8}\nproperty i14 = singleton_shl`{8}\nproperty i15 = singleton_lshr`{8}\nproperty i16 = singleton_ashr`{8}\nproperty i17 = singleton_slt`{16}\nproperty i18 = singleton_sle`{16}\nproperty i19 = singleton_ult`{16}\nproperty i20 = singleton_ule`{16}\n\ncomm_overlap : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_overlap a b = overlap a b <==> overlap b a\n\ncomm_add : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_add a b = add a b == add b a\n\nassoc_add : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nassoc_add a b c = add a (add b c) =@= add (add a b) c\n\ncomm_mul : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_mul a b = mul a b == mul b a\n\n\/* mul is not associative! *\/\nassoc_mul : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nassoc_mul a b c = mul a (mul b c) =@= mul (mul a b) c\n\ncomm_mulRange :\n  {i, j} (fin i, fin j, i >= 1, j >= 1) => ([i], [i]) -> ([j], [j]) -> Bit\ncomm_mulRange a b =\n  a.0 <=$ a.1 ==> b.0 <=$ b.1 ==> mulRange a b == mulRange b a\n\nassoc_mulRange :\n  {i, j, k} (fin i, fin j, fin k, i >= 1, j >= 1, k >= 1) =>\n  ([i], [i]) -> ([j], [j]) -> ([k], [k]) -> Bit\nassoc_mulRange a b c =\n  a.0 <=$ a.1 ==>\n  b.0 <=$ b.1 ==>\n  c.0 <=$ c.1 ==>\n  mulRange a (mulRange b c) == mulRange (mulRange a b) c\n\nproperty c1 = comm_overlap`{16}\nproperty c2 = comm_add`{16}\nproperty c3 = assoc_add`{16}\nproperty c4 = comm_mul`{4}\nproperty c5 = comm_mulRange`{4,4}\nproperty c6 = assoc_mulRange`{3,3,3}\n\ncomm_union : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_union a b = union a b == union b a\n\n\/* union is actually not associative! *\/\nassoc_union : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nassoc_union a b c = union a (union b c) == union (union a b) c\n\n\/* union always has a lower bound equal to one of the input lower bounds *\/\nlo_union : {n} (fin n) => Dom n -> Dom n -> Bit\nlo_union a b =\n  union a b == top \\\/ (union a b).lo == a.lo \\\/ (union a b).lo == b.lo\n\n\/* union always has an upper bound equal to one of the input upper bounds *\/\nhi_union : {n} (fin n) => Dom n -> Dom n -> Bit\nhi_union a b = c == top \\\/ c_hi == a_hi \\\/ c_hi == b_hi\n  where\n    c = union a b\n    a_hi = a.lo + a.sz\n    b_hi = b.lo + b.sz\n    c_hi = c.lo + c.sz\n\n\/* union doesn't return top unless necessary *\/\nnontriv_union : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\nnontriv_union a b x =\n  union a b =@= top ==> mem a x \\\/ mem b x\n\n\/* union of opposite intervals prefers to exclude zero *\/\nnonzero_union : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nnonzero_union lo sz =\n  mem (union a b) half \/\\\n  (~ mem a 0 ==> ~ mem b 0 ==> ~ mem (union a b) 0)\n  where\n    half : [n]\n    half = reverse 1\n    a = interval lo sz\n    b = interval (lo + half) sz\n\nproperty u1 = comm_union`{16}\nproperty u2 = lo_union`{16}\nproperty u3 = hi_union`{16}\nproperty u4 = nontriv_union`{8}\nproperty u5 = nonzero_union`{16}\n```"}]}
{"filename":"saw-script\/deps\/cryptol\/tests\/enum\/BasicEnums.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of pattern matching functions `c1`, `c2`, and `c3` over the enums `E1` and `N`. Ensure that for all valid inputs, these functions return expected outputs consistent with their definitions. Include type constraints where necessary and cover all enum cases."},{"role":"assistant","content":"```cryptol\n\/** Custom docs for E1 *\/\nenum E1  = A | B | C\nenum M a = N | J a\nenum N n a =\n  | \/** Note that we allow a starting | *\/ X [n]\n  | Y [n-2]\n  | Z a\n\n\n\/\/  Pattern matching\n\nc1 e =\n  case e of\n    A -> 1 : [8]\n    B -> 2\n    C -> 3\n\nc2 : {n} (n>=2) => N n [n] -> [n]\nc2 e =\n  case e of\n    X a -> a\n    Y b -> zero`{[2]} # b\n    Z a -> a\n\nc3 e = case e of A -> 1 : [8]; B -> 2; C -> 3\n\n\/\/ Construction\n\ne1 = N\ne2 = Y 3\n```"}]}
{"filename":"saw-script\/deps\/cryptol\/tests\/issues\/issue_1867.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the functions 'foo' and 'bar' correctly apply the bitwise AND operation between 'myparam' and each element of the input sequence. Ensure the properties check the behavior for varying parameter sizes 'n' and input lengths 'm'."},{"role":"assistant","content":"```cryptol\nmodule Param where\n\nparameter\n  type n : #\n  myparam : [n]\n\nfoo : {m} [m][n] -> [m][n]\nfoo = map ((&&) myparam)\n\nbar = map ((&&) myparam)\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/ffs_gen_aig.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class FFS and the LLVM module ffs.bc, then defines let-bound specs ffs_ref_spec and ffs_imp_spec. Each spec should symbolically create a 32-bit input variable using jvm_fresh_var or llvm_fresh_var as appropriate, apply minimal preconditions to ensure safe execution, and call the corresponding functions ffs_ref and ffs_imp from both Java (FFS.ffs_ref, FFS.ffs_imp) and C (ffs_ref, ffs_imp). The harness should be structured to enable equivalence checking between the Java and C implementations using these specs.\n\n# Source code:\nffs.c\n```C\n#include <stdint.h>\n\n#ifdef RUN\n#include <stdio.h>\ntypedef unsigned int uint32_t;\n#endif\n\n\/\/ returns the index of the first non-zero bit\nuint32_t ffs_ref(uint32_t word) {\n    int i = 0;\n    if(!word)\n        return 0;\n    for(int cnt = 0; cnt < 32; cnt++)\n        if(((1 << i++) & word) != 0)\n            return i;\n    return 0; \/\/ notreached\n}\n\nuint32_t ffs_imp(uint32_t i) {\n    char n = 1;\n    if (!(i & 0xffff)) { n += 16; i >>= 16; }\n    if (!(i & 0x00ff)) { n += 8;  i >>= 8; }\n    if (!(i & 0x000f)) { n += 4;  i >>= 4; }\n    if (!(i & 0x0003)) { n += 2;  i >>= 2; }\n    return (i) ? (n+((i+1) & 0x01)) : 0;\n}\n\nuint32_t ffs_imp_nobranch(uint32_t i) {\n  char n = 1;\n  int s1 = !(i & 0xffff) << 4;\n  n += s1; i >>= s1;\n  int s2 = !(i & 0x00ff) << 3;\n  n += s2;  i >>= s2;\n  int s3 = !(i & 0x000f) << 2;\n  n += s3;  i >>= s3;\n  int s4 = !(i & 0x0003) << 1;\n  n += s4;  i >>= s4;\n  \/\/ Still does have one branch...\n  return (i) ? (n+((i+1) & 0x01)) : 0;\n}\n\n\/\/ and now a buggy one\nuint32_t ffs_bug(uint32_t word) {\n    \/\/ injected bug:\n    if(word == 0x101010) return 4; \/\/ instead of 5\n    return ffs_ref(word);\n}\n\n#ifdef RUN\nint main(int argc, char **argv) {\n    uint32_t t = 0x800000;\n    printf(\"(imp, ref) 0x%x -> (0x%x, 0x%x)\\n\", t, ffs_imp(t), ffs_ref(t));\n    t = 0x000002;\n    printf(\"(imp, ref) 0x%x -> (0x%x, 0x%x)\\n\", t, ffs_imp(t), ffs_ref(t));\n    t = 0x000008;\n    printf(\"(imp, ref) 0x%x -> (0x%x, 0x%x)\\n\", t, ffs_imp(t), ffs_ref(t));\n    t = 0x101010;\n    printf(\"(bug, ref) 0x%x -> (0x%x, 0x%x)\\n\", t, ffs_bug(t), ffs_ref(t));\n}\n#endif\n\n\/\/ Creative optimized version based on musl libc:\n\/\/ http:\/\/www.musl-libc.org\/.\n\/\/\n\/\/ Apparently this is a well known approach:\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Find_first_set#CTZ. The DeBruijn\n\/\/ (https:\/\/en.wikipedia.org\/wiki\/De_Bruijn_sequence) sequence here is\n\/\/ different from the one in the Wikipedia article on 'ffs'.\nuint32_t ffs_musl (uint32_t x)\n{\n  static const char debruijn32[32] = {\n    0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,\n    31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14\n  };\n  return x ? debruijn32[(x&-x)*0x076be629 >> 27]+1 : 0;\n}\n\n```\nFFS.java\n```java\nclass FFS {\n    static int ffs_ref(int word) {\n        int i = 0;\n        if(word == 0)\n            return 0;\n        for(int cnt = 0; cnt < 32; cnt++)\n            if(((1 << i++) & word) != 0)\n                return i;\n        return 0;\n    }\n\n    static int ffs_imp(int i) {\n        byte n = 1;\n        if ((i & 0xffff) == 0) { n += 16; i >>= 16; }\n        if ((i & 0x00ff) == 0) { n +=  8; i >>=  8; }\n        if ((i & 0x000f) == 0) { n +=  4; i >>=  4; }\n        if ((i & 0x0003) == 0) { n +=  2; i >>=  2; }\n        if (i != 0) { return (n+((i+1) & 0x01)); } else { return 0; }\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\ncls <- java_load_class \"FFS\";\nbc <- llvm_load_module \"ffs.bc\";\njava_ffs_ref <- jvm_extract cls \"ffs_ref\";\njava_ffs_imp <- jvm_extract cls \"ffs_imp\";\nc_ffs_ref <- llvm_extract bc \"ffs_ref\";\nc_ffs_imp <- llvm_extract bc \"ffs_imp\";\nwrite_aig \"java_ffs_ref.aig\" java_ffs_ref;\nwrite_aig \"java_ffs_imp.aig\" java_ffs_imp;\nwrite_aig \"c_ffs_ref.aig\" c_ffs_ref;\nwrite_aig \"c_ffs_imp.aig\" c_ffs_imp;\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/ffs_llvm.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from 'ffs.bc' and extracts the functions 'ffs_ref', 'ffs_imp', 'ffs_musl', and 'ffs_bug'. Define a let-bound specification 'ffs_equiv_spec' that takes a symbolic 32-bit word input using 'llvm_fresh_var' and asserts the equivalence of 'ffs_ref' and 'ffs_imp' on this input. Include minimal preconditions ensuring the input is a 32-bit word. Then prove this specification using the appropriate LLVM backend commands.\n\n# Source code:\nffs.c\n```C\n#include <stdint.h>\n\n#ifdef RUN\n#include <stdio.h>\ntypedef unsigned int uint32_t;\n#endif\n\n\/\/ returns the index of the first non-zero bit\nuint32_t ffs_ref(uint32_t word) {\n    int i = 0;\n    if(!word)\n        return 0;\n    for(int cnt = 0; cnt < 32; cnt++)\n        if(((1 << i++) & word) != 0)\n            return i;\n    return 0; \/\/ notreached\n}\n\nuint32_t ffs_imp(uint32_t i) {\n    char n = 1;\n    if (!(i & 0xffff)) { n += 16; i >>= 16; }\n    if (!(i & 0x00ff)) { n += 8;  i >>= 8; }\n    if (!(i & 0x000f)) { n += 4;  i >>= 4; }\n    if (!(i & 0x0003)) { n += 2;  i >>= 2; }\n    return (i) ? (n+((i+1) & 0x01)) : 0;\n}\n\nuint32_t ffs_imp_nobranch(uint32_t i) {\n  char n = 1;\n  int s1 = !(i & 0xffff) << 4;\n  n += s1; i >>= s1;\n  int s2 = !(i & 0x00ff) << 3;\n  n += s2;  i >>= s2;\n  int s3 = !(i & 0x000f) << 2;\n  n += s3;  i >>= s3;\n  int s4 = !(i & 0x0003) << 1;\n  n += s4;  i >>= s4;\n  \/\/ Still does have one branch...\n  return (i) ? (n+((i+1) & 0x01)) : 0;\n}\n\n\/\/ and now a buggy one\nuint32_t ffs_bug(uint32_t word) {\n    \/\/ injected bug:\n    if(word == 0x101010) return 4; \/\/ instead of 5\n    return ffs_ref(word);\n}\n\n#ifdef RUN\nint main(int argc, char **argv) {\n    uint32_t t = 0x800000;\n    printf(\"(imp, ref) 0x%x -> (0x%x, 0x%x)\\n\", t, ffs_imp(t), ffs_ref(t));\n    t = 0x000002;\n    printf(\"(imp, ref) 0x%x -> (0x%x, 0x%x)\\n\", t, ffs_imp(t), ffs_ref(t));\n    t = 0x000008;\n    printf(\"(imp, ref) 0x%x -> (0x%x, 0x%x)\\n\", t, ffs_imp(t), ffs_ref(t));\n    t = 0x101010;\n    printf(\"(bug, ref) 0x%x -> (0x%x, 0x%x)\\n\", t, ffs_bug(t), ffs_ref(t));\n}\n#endif\n\n\/\/ Creative optimized version based on musl libc:\n\/\/ http:\/\/www.musl-libc.org\/.\n\/\/\n\/\/ Apparently this is a well known approach:\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Find_first_set#CTZ. The DeBruijn\n\/\/ (https:\/\/en.wikipedia.org\/wiki\/De_Bruijn_sequence) sequence here is\n\/\/ different from the one in the Wikipedia article on 'ffs'.\nuint32_t ffs_musl (uint32_t x)\n{\n  static const char debruijn32[32] = {\n    0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,\n    31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14\n  };\n  return x ? debruijn32[(x&-x)*0x076be629 >> 27]+1 : 0;\n}\n\n```"},{"role":"assistant","content":"```saw\nset_base 16;\n\nprint \"Extracting reference term: ffs_ref\";\nl <- llvm_load_module \"ffs.bc\";\nffs_ref <- llvm_extract l \"ffs_ref\";\n\nprint \"Extracting implementation term: ffs_imp\";\nffs_imp <- llvm_extract l \"ffs_imp\";\n\nprint \"Extracting implementation term: ffs_musl\";\nffs_musl <- llvm_extract l \"ffs_musl\";\n\nprint \"Extracting buggy term: ffs_bug\";\nffs_bug <- llvm_extract l \"ffs_bug\";\n\nprint \"Proving equivalence: ffs_ref == ffs_imp\";\nlet thm1 = {{ \\x -> ffs_ref x == ffs_imp x }};\nresult <- prove abc thm1;\nprint result;\n\nprint \"Proving equivalence: ffs_ref == ffs_musl\";\nlet thm2 = {{ \\x -> ffs_ref x == ffs_musl x }};\nresult <- prove abc thm2;\nprint result;\n\nprint \"Finding bug via sat search: ffs_ref != ffs_bug\";\nlet thm3 = {{ \\x -> ffs_ref x != ffs_bug x }};\nresult <- sat abc thm3;\nprint result;\n\nprint \"Finding bug via failed proof: ffs_ref == ffs_bug\";\nlet thm4 = {{ \\x -> ffs_ref x == ffs_bug x }};\nresult <- prove abc thm4;\nprint result;\n\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/NQueens.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the nQueens function in the given Cryptol code. The properties should capture that nQueens returns True if and only if the input board configuration represents a valid solution to the n-Queens problem, ensuring no two queens attack each other horizontally, vertically, or diagonally. Include properties that check the distinctness of queen positions, their valid range on the board, and diagonal safety. Also, write properties suitable for automated proving or model checking using the provided helper functions and types."},{"role":"assistant","content":"```cryptol\n\/* To see this in action, try:\n\n  :sat nQueens : (Solution n)\n  where n is the board-size\n\n  You may find that cvc4 takes a long time for solutions bigger than 5.\n  For those sizes, we have had good luck with both Yices and Z3.  \n\n  To do that,\n\n  :set prover=Z3\n  or\n  :set prover=yices\n*\/\n\nall : {n, a} (fin n) => (a -> Bit, [n]a) -> Bit\nall (f, xs) = [ f x | x <- xs ] == ~zero\n\ncontains xs e = [ x == e | x <- xs ] != zero\n\ndistinct : {n,a} (fin n, Cmp a) => [n]a -> Bit\ndistinct xs =\n    [ if n1 < n2 then x != y else True\n    | (x,n1) <- numXs , (y,n2) <- numXs\n    ] == ~zero\n  where\n  numXs = [ (x,n) | x <- xs | n <- [ (0:[width n]) ... ] ]\n\ntype Position n = [width (n - 1)]\n\ntype Board n = [n](Position n)\n\ntype Solution n = Board n -> Bit\n\ncheckDiag : {n} (fin n, n >= 1) => Board n -> (Position n, Position n) -> Bit\ncheckDiag qs (i, j) = (i >= j) || (diffR != diffC)\n  where   qi = qs @ i\n          qj = qs @ j\n          diffR = if qi >= qj then qi-qj else qj-qi\n          diffC = j - i                   \/\/ we know i < j\n\nnQueens : {n} (fin n, n >= 1) => Solution n\nnQueens qs = all (inRange qs, qs) && all (checkDiag qs, ijs `{n}) && distinct qs\n\nijs : {n}(fin n, n>= 1)=> [_](Position n, Position n)\nijs = [ (i, j) | i <- [0 .. (n-1)], j <- [0 .. (n-1)]]\n\ninRange : {n} (fin n, n >= 1) => Board n -> Position n -> Bit\ninRange qs x = x <= `(n - 1)\n\nproperty nQueensProve x = (nQueens x) == False\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/ffs_compare_aig.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class containing the method 'ffs' and defines a let-bound specification 'ffs_spec' which symbolically inputs an integer argument using 'jvm_fresh_var'. The spec should invoke both the reference and implementation versions of the 'ffs' method (e.g., 'ClassName.ffs') and assert their equivalence. Include minimal preconditions to ensure safe execution. Use 'java_load_class' to load the class and 'jvm_verify' to verify the equivalence theorem."},{"role":"assistant","content":"```saw\njava_ffs_ref <- read_aig \"java_ffs_ref.aig\";\njava_ffs_imp <- read_aig \"java_ffs_imp.aig\";\nc_ffs_ref <- read_aig \"c_ffs_ref.aig\";\nc_ffs_imp <- read_aig \"c_ffs_imp.aig\";\n\nlet thm1 = {{ \\x -> java_ffs_ref x == java_ffs_imp x }};\nprove_print abc thm1;\n\nlet thm2 = {{ \\x -> c_ffs_ref x == c_ffs_imp x }};\nprove_print abc thm2;\n\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/Cipher.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the expected properties of the Cipher module, including that decrypt is the inverse of encrypt for all keys and blocks of the given sizes. Include properties suitable for formal verification to ensure correctness of encryption and decryption functions."},{"role":"assistant","content":"```cryptol\nmodule Cipher where\n\ntype Cipher KeySize BlockSize =\n  { encrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  , decrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  }\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/double.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from double.bc, extracts the functions double_ref and double_imp, and defines a let-bound specification double_spec that takes a symbolic integer input x (using llvm_fresh_var) and asserts that double_ref(x) equals double_imp(x). Include any necessary preconditions for safe execution. Then prove the equivalence of these two functions using the defined specification.\n\n# Source code:\ndouble.c\n```C\nint double_ref(int x) {\n    return x * 2;\n}\n\nint double_imp(int x) {\n    return x << 1;\n}\n\n```"},{"role":"assistant","content":"```saw\nl <- llvm_load_module \"double.bc\";\ndouble_imp <- llvm_extract l \"double_imp\";\ndouble_ref <- llvm_extract l \"double_ref\";\nlet thm = {{ \\x -> double_ref x == double_imp x }};\n\nr <- prove yices thm;\nprint r;\n\nr <- prove z3 thm;\nprint r;\n\nlet thm_neg = {{ \\x -> ~(thm x) }};\nwrite_smtlib2 \"double.smt2\" thm_neg;\n\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/dotprod.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness for the LLVM function 'dotprod' defined in 'dotprod.c'. Begin by defining a let-bound specification 'dotprod_spec' that takes a symbolic 32-bit integer 'n' representing the array size. Use 'llvm_fresh_var' to create symbolic arrays 'xs' and 'ys' of length 'n' with 32-bit integer elements. Allocate and initialize pointers to these arrays. Add minimal preconditions ensuring 'n' is within safe bounds for array indexing. Execute the 'dotprod' function with these pointers and 'n' as arguments. Assert that the function's return value equals the sum of element-wise products of 'xs' and 'ys'. Load the LLVM module 'dotprod.bc' and verify 'dotprod' against 'dotprod_spec' using 'llvm_verify'.\n\n# Source code:\ndotprod.c\n```C\n#include <stdint.h>\n#include <stdlib.h>\n\nuint32_t dotprod(uint32_t *x, uint32_t *y, uint32_t size) {\n    uint32_t res = 0;\n    for(size_t i = 0; i < size; i++) {\n        res += x[i] * y[i];\n    }\n    return res;\n}\n\n```"},{"role":"assistant","content":"```saw\nimport \"dotprod.cry\";\n\nlet alloc_init ty v = do {\n    p <- llvm_alloc ty;\n    llvm_points_to p v;\n    return p;\n};\n\nlet ptr_to_fresh n ty = do {\n    x <- llvm_fresh_var n ty;\n    p <- alloc_init ty (llvm_term x);\n    return (x, p);\n};\n\nlet dotprod_spec n = do {\n    let nt = llvm_term {{ `n : [32] }};\n    (xs, xsp) <- ptr_to_fresh \"xs\" (llvm_array n (llvm_int 32));\n    (ys, ysp) <- ptr_to_fresh \"ys\" (llvm_array n (llvm_int 32));\n    llvm_execute_func [xsp, ysp, nt];\n    llvm_return (llvm_term {{ dotprod xs ys }});\n};\n\nm <- llvm_load_module \"dotprod.bc\";\n\ndotprod_ov <- llvm_verify m \"dotprod\" [] true (dotprod_spec 10) z3;\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/ffs.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that formally verifies the equivalence between the reference implementation `ffs_ref` and the optimized implementation `ffs_imp` of the first non-zero bit index function for 32-bit inputs. Ensure the property checks that for all 32-bit inputs, both functions produce the same output."},{"role":"assistant","content":"```cryptol\n\/\/ return the index of the first non-zero bit (big-endian bit order)\nffs_ref: [32] -> [32]\nffs_ref x = ixs!0 where\n    ixs = [0] # [ if (x && (1 << i)) != 0 then (i+1) else prev\n                | prev <- ixs\n                | i <- [31, 30 .. 0]:[32][32]\n                ]\n\nffs_imp: [32] -> [32]\nffs_imp i = if (i'''' > 0) then (n'''' + ((i'''' + 1) && 1)) else 0 where\n    n = 1\n    (n', i') =       if (zero==(i && 0x0000ffff))    then (n + 16, i >> 16) else (n, i)\n    (n'', i'') =     if (zero==(i' && 0x000000ff))   then (n' + 8, i' >> 8) else (n', i')\n    (n''', i''') =   if (zero==(i'' && 0x0000000f))  then (n'' + 4, i'' >> 4) else (n'',i'')\n    (n'''', i'''') = if (zero==(i''' && 0x00000003)) then (n''' + 2, i''' >> 2) else (n''', i''')\n\nproperty ffs_correct x = ffs_ref x == ffs_imp x\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/des3.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the LLVM module from the provided source files and defines a let-bound specification named des3_spec. This spec should symbolically represent inputs for the DES3 encryption and decryption functions exactly as defined in the source, using llvm_fresh_var for keys and messages. Include minimal preconditions to ensure safety and termination. The spec should verify that decrypting an encrypted message returns the original message and that encrypting a decrypted message returns the original message, referencing the exact LLVM function symbols. Use the llvm_* backend commands for loading, symbolic variables, and verification steps, and do not inline the spec in the prove call."},{"role":"assistant","content":"```saw\nimport \"DES.cry\";\n\nprint \"proving dec_enc...\";\nlet prop1 = {{ \\key msg -> decrypt key (encrypt key msg) == msg }};\ndec_enc <- prove_print w4_abc_verilog {{prop1}};\n\nprint dec_enc;\n\nprint \"proving enc_dec...\";\nlet prop2 = {{ \\key msg -> encrypt key (decrypt key msg) == msg }};\nenc_dec <- prove_print w4_abc_verilog {{prop2}};\n\nprint enc_dec;\n\nlet ss = addsimp dec_enc (addsimp enc_dec basic_ss);\n\nlet {{ enc3 k1 k2 k3 msg = encrypt k3 (decrypt k2 (encrypt k1 msg)) }};\nlet {{ dec3 k1 k2 k3 msg = decrypt k1 (encrypt k2 (decrypt k3 msg)) }};\n\nprint \"proving dec3_enc3...\";\nlet {{ prop3 k1 k2 k3 msg = dec3 k1 k2 k3 (enc3 k1 k2 k3 msg) == msg }};\nprove_print do {\n    unfolding [\"prop3\"];\n    unfolding [\"dec3\", \"enc3\"];\n    simplify ss;\n    print_goal;\n    w4_abc_verilog;\n} {{prop3}};\n\nprint \"proving enc3_dec3...\";\nlet {{ prop4 k1 k2 k3 msg = enc3 k1 k2 k3 (dec3 k1 k2 k3 msg) == msg }};\nprove_print do {\n    unfolding [\"prop4\"];\n    unfolding [\"dec3\", \"enc3\"];\n    simplify ss;\n    print_goal;\n    w4_abc_verilog;\n} {{prop4}};\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/ffs_compare.saw","filetype":"saw","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `saw` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a SAWScript verification harness that loads the Java class \"FFS\" and the LLVM module \"ffs.bc\". Define let-bound specs named ffs_ref_spec, ffs_imp_spec, and ffs_bug_spec for the C functions uint32_t ffs_ref(uint32_t), uint32_t ffs_imp(uint32_t), and uint32_t ffs_bug(uint32_t) respectively, using llvm_fresh_var for symbolic 32-bit inputs. Similarly, define let-bound specs java_ffs_ref_spec and java_ffs_imp_spec for the Java static methods int FFS.ffs_ref(int) and int FFS.ffs_imp(int) using jvm_fresh_var for symbolic inputs. Add minimal preconditions to ensure inputs are 32-bit unsigned integers. Then write verification commands that prove equivalence between the C and Java implementations of ffs_ref and ffs_imp, and verify that ffs_bug differs from ffs_ref on at least one input. Do not include solver references or comments.\n\n# Source code:\nffs.c\n```C\n#include <stdint.h>\n\n#ifdef RUN\n#include <stdio.h>\ntypedef unsigned int uint32_t;\n#endif\n\n\/\/ returns the index of the first non-zero bit\nuint32_t ffs_ref(uint32_t word) {\n    int i = 0;\n    if(!word)\n        return 0;\n    for(int cnt = 0; cnt < 32; cnt++)\n        if(((1 << i++) & word) != 0)\n            return i;\n    return 0; \/\/ notreached\n}\n\nuint32_t ffs_imp(uint32_t i) {\n    char n = 1;\n    if (!(i & 0xffff)) { n += 16; i >>= 16; }\n    if (!(i & 0x00ff)) { n += 8;  i >>= 8; }\n    if (!(i & 0x000f)) { n += 4;  i >>= 4; }\n    if (!(i & 0x0003)) { n += 2;  i >>= 2; }\n    return (i) ? (n+((i+1) & 0x01)) : 0;\n}\n\nuint32_t ffs_imp_nobranch(uint32_t i) {\n  char n = 1;\n  int s1 = !(i & 0xffff) << 4;\n  n += s1; i >>= s1;\n  int s2 = !(i & 0x00ff) << 3;\n  n += s2;  i >>= s2;\n  int s3 = !(i & 0x000f) << 2;\n  n += s3;  i >>= s3;\n  int s4 = !(i & 0x0003) << 1;\n  n += s4;  i >>= s4;\n  \/\/ Still does have one branch...\n  return (i) ? (n+((i+1) & 0x01)) : 0;\n}\n\n\/\/ and now a buggy one\nuint32_t ffs_bug(uint32_t word) {\n    \/\/ injected bug:\n    if(word == 0x101010) return 4; \/\/ instead of 5\n    return ffs_ref(word);\n}\n\n#ifdef RUN\nint main(int argc, char **argv) {\n    uint32_t t = 0x800000;\n    printf(\"(imp, ref) 0x%x -> (0x%x, 0x%x)\\n\", t, ffs_imp(t), ffs_ref(t));\n    t = 0x000002;\n    printf(\"(imp, ref) 0x%x -> (0x%x, 0x%x)\\n\", t, ffs_imp(t), ffs_ref(t));\n    t = 0x000008;\n    printf(\"(imp, ref) 0x%x -> (0x%x, 0x%x)\\n\", t, ffs_imp(t), ffs_ref(t));\n    t = 0x101010;\n    printf(\"(bug, ref) 0x%x -> (0x%x, 0x%x)\\n\", t, ffs_bug(t), ffs_ref(t));\n}\n#endif\n\n\/\/ Creative optimized version based on musl libc:\n\/\/ http:\/\/www.musl-libc.org\/.\n\/\/\n\/\/ Apparently this is a well known approach:\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Find_first_set#CTZ. The DeBruijn\n\/\/ (https:\/\/en.wikipedia.org\/wiki\/De_Bruijn_sequence) sequence here is\n\/\/ different from the one in the Wikipedia article on 'ffs'.\nuint32_t ffs_musl (uint32_t x)\n{\n  static const char debruijn32[32] = {\n    0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,\n    31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14\n  };\n  return x ? debruijn32[(x&-x)*0x076be629 >> 27]+1 : 0;\n}\n\n```\nFFS.java\n```java\nclass FFS {\n    static int ffs_ref(int word) {\n        int i = 0;\n        if(word == 0)\n            return 0;\n        for(int cnt = 0; cnt < 32; cnt++)\n            if(((1 << i++) & word) != 0)\n                return i;\n        return 0;\n    }\n\n    static int ffs_imp(int i) {\n        byte n = 1;\n        if ((i & 0xffff) == 0) { n += 16; i >>= 16; }\n        if ((i & 0x00ff) == 0) { n +=  8; i >>=  8; }\n        if ((i & 0x000f) == 0) { n +=  4; i >>=  4; }\n        if ((i & 0x0003) == 0) { n +=  2; i >>=  2; }\n        if (i != 0) { return (n+((i+1) & 0x01)); } else { return 0; }\n    }\n}\n\n```"},{"role":"assistant","content":"```saw\nimport \"ffs.cry\";\nj <- java_load_class \"FFS\";\njava_ffs_ref <- jvm_extract j \"ffs_ref\";\njava_ffs_imp <- jvm_extract j \"ffs_imp\";\n\nl <- llvm_load_module \"ffs.bc\";\nc_ffs_ref <- llvm_extract l \"ffs_ref\";\nc_ffs_imp <- llvm_extract l \"ffs_imp\";\n\nprint \"java ref <-> java imp\";\nlet thm1 = {{ \\x -> java_ffs_ref x == java_ffs_imp x }};\nprove_print abc thm1;\n\nprint \"c ref <-> c imp\";\nlet thm2 = {{ \\x -> c_ffs_ref x == c_ffs_imp x }};\nprove_print abc thm2;\n\nprint \"java imp <-> c imp\";\nlet thm3 = {{ \\x -> java_ffs_imp x == c_ffs_imp x }};\nprove_print abc thm3;\n\nprint \"cryptol imp <-> c imp\";\nlet thm4 = {{ \\x -> ffs_imp x == c_ffs_imp x }};\nprove_print abc thm4;\n\nprint \"cryptol imp <-> cryptol ref\";\nlet thm5 = {{ \\x -> ffs_imp x == ffs_ref x }};\nprove_print abc thm5;\n\nprint \"Done.\";\n```"}]}
{"filename":"saw-script\/doc\/rust-verification-with-saw\/code\/salsa20\/Salsa20Extras.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol specifications to verify the correctness of the functions 'counter_setup' and 'apply_keystream' in the Salsa20Extras module. The specifications should capture the expected behavior of updating the state with the counter and applying the Salsa20 keystream transformation to the output buffer, ensuring the functions conform to the Salsa20 cipher's design."},{"role":"assistant","content":"```cryptol\nmodule Salsa20Extras where\n\nimport Salsa20\n\ntype STATE_WORDS = 16\ntype BLOCK_SIZE = 64\n\ncounter_setup : [STATE_WORDS][32] -> [64] -> [STATE_WORDS][32]\ncounter_setup state counter =\n  updates state [8, 9] [drop counter, drop (counter >> 32)]\n\napply_keystream : [32] -> [STATE_WORDS][32] -> [64] -> [BLOCK_SIZE][8] -> [BLOCK_SIZE][8]\napply_keystream count state0 counter output =\n    output ^ littleendian_state_inverse state2\n  where\n    state1 = counter_setup state0 counter\n    state2 = Salsa20_rounds count state1 state1\n```"}]}
{"filename":"saw-script\/doc\/rust-verification-with-saw\/code\/salsa20\/Salsa20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the Salsa20 quarterround, rowround, columnround, doubleround, and Salsa20 encryption functions. Include properties that check the functions against known test vectors, verify invertibility where applicable, and ensure no collisions occur in the doubleround function. Additionally, specify properties to confirm equivalence between optimized and original implementations of rowround and columnround."},{"role":"assistant","content":"```cryptol\n\/\/ see http:\/\/cr.yp.to\/snuffle\/spec.pdf\n\nmodule Salsa20 where\n\nquarterround : [4][32] -> [4][32]\nquarterround [y0, y1, y2, y3] = [z0, z1, z2, z3]\n  where\n    z1 = y1 ^ ((y0 + y3) <<< 0x7)\n    z2 = y2 ^ ((z1 + y0) <<< 0x9)\n    z3 = y3 ^ ((z2 + z1) <<< 0xd)\n    z0 = y0 ^ ((z3 + z2) <<< 0x12)\n\nproperty quarterround_passes_tests =\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000000] == [0x00000000, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (quarterround [0x00000001, 0x00000000, 0x00000000, 0x00000000] == [0x08008145, 0x00000080, 0x00010200, 0x20500000]) \/\\\n  (quarterround [0x00000000, 0x00000001, 0x00000000, 0x00000000] == [0x88000100, 0x00000001, 0x00000200, 0x00402000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000001, 0x00000000] == [0x80040000, 0x00000000, 0x00000001, 0x00002000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000001] == [0x00048044, 0x00000080, 0x00010000, 0x20100001]) \/\\\n  (quarterround [0xe7e8c006, 0xc4f9417d, 0x6479b4b2, 0x68c67137] == [0xe876d72b, 0x9361dfd5, 0xf1460244, 0x948541a3]) \/\\\n  (quarterround [0xd3917c5b, 0x55f1c407, 0x52a58a7a, 0x8f887a3b] == [0x3e2f308c, 0xd90a8f36, 0x6ab2a923, 0x2883524c])\n\nrowround : [16][32] -> [16][32]\nrowround [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15] =\n    [z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15]\n  where\n    [ z0,  z1,  z2,  z3] = quarterround [ y0,  y1,  y2,  y3]\n    [ z5,  z6,  z7,  z4] = quarterround [ y5,  y6,  y7,  y4]\n    [z10, z11,  z8,  z9] = quarterround [y10, y11,  y8,  y9]\n    [z15, z12, z13, z14] = quarterround [y15, y12, y13, y14]\n\nproperty rowround_passes_tests =\n  (rowround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n            [0x08008145, 0x00000080, 0x00010200, 0x20500000,\n             0x20100001, 0x00048044, 0x00000080, 0x00010000,\n             0x00000001, 0x00002000, 0x80040000, 0x00000000,\n             0x00000001, 0x00000200, 0x00402000, 0x88000100]) \/\\\n  (rowround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n             0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n             0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n             0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n            [0xa890d39d, 0x65d71596, 0xe9487daa, 0xc8ca6a86,\n             0x949d2192, 0x764b7754, 0xe408d9b9, 0x7a41b4d1,\n             0x3402e183, 0x3c3af432, 0x50669f96, 0xd89ef0a8,\n             0x0040ede5, 0xb545fbce, 0xd257ed4f, 0x1818882d])\n\n\nrowround_opt : [16][32] -> [16][32]\nrowround_opt ys = join [ (quarterround (yi<<<i))>>>i | yi <- split ys | i <- [0 .. 3] ]\n\nproperty rowround_opt_is_rowround ys = rowround ys == rowround_opt ys\n\ncolumnround : [16][32] -> [16][32]\ncolumnround [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15] =\n    [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15]\n  where\n    [ y0,  y4,  y8, y12] = quarterround [ x0,  x4,  x8, x12]\n    [ y5,  y9, y13,  y1] = quarterround [ x5,  x9, x13,  x1]\n    [y10, y14,  y2,  y6] = quarterround [x10, x14,  x2,  x6]\n    [y15,  y3,  y7, y11] = quarterround [x15,  x3,  x7, x11]\n\nproperty columnround_passes_tests =\n  (columnround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x10090288, 0x00000000, 0x00000000, 0x00000000,\n                0x00000101, 0x00000000, 0x00000000, 0x00000000,\n                0x00020401, 0x00000000, 0x00000000, 0x00000000,\n                0x40a04001, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (columnround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n                0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n                0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n                0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n               [0x8c9d190a, 0xce8e4c90, 0x1ef8e9d3, 0x1326a71a,\n                0x90a20123, 0xead3c4f3, 0x63a091a0, 0xf0708d69,\n                0x789b010c, 0xd195a681, 0xeb7d5504, 0xa774135c,\n                0x481c2027, 0x53a8e4b5, 0x4c1f89c5, 0x3f78c9c8])\n\n\ncolumnround_opt : [16][32] -> [16][32]\ncolumnround_opt xs = join (transpose [ (quarterround (xi<<<i))>>>i | xi <- transpose(split xs) | i <- [0 .. 3] ])\n\ncolumnround_opt_is_columnround xs = columnround xs == columnround_opt xs\n\nproperty columnround_is_transpose_of_rowround ys =\n  rowround ys == join(transpose(split`{4}(columnround xs)))\n  where xs = join(transpose(split`{4} ys))\n\ndoubleround : [16][32] -> [16][32]\ndoubleround(xs) = rowround(columnround(xs))\n\nproperty doubleround_passes_tests =\n  (doubleround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x8186a22d, 0x0040a284, 0x82479210, 0x06929051,\n                0x08000090, 0x02402200, 0x00004000, 0x00800000,\n                0x00010200, 0x20400000, 0x08008104, 0x00000000,\n                0x20500000, 0xa0000040, 0x0008180a, 0x612a8020]) \/\\\n  (doubleround [0xde501066, 0x6f9eb8f7, 0xe4fbbd9b, 0x454e3f57,\n                0xb75540d3, 0x43e93a4c, 0x3a6f2aa0, 0x726d6b36,\n                0x9243f484, 0x9145d1e8, 0x4fa9d247, 0xdc8dee11,\n                0x054bf545, 0x254dd653, 0xd9421b6d, 0x67b276c1] ==\n               [0xccaaf672, 0x23d960f7, 0x9153e63a, 0xcd9a60d0,\n                0x50440492, 0xf07cad19, 0xae344aa0, 0xdf4cfdfc,\n                0xca531c29, 0x8e7943db, 0xac1680cd, 0xd503ca00,\n                0xa74b2ad6, 0xbc331c5c, 0x1dda24c7, 0xee928277])\n\nlittleendian : [4][8] -> [32]\nlittleendian b = join(reverse b)\n\nproperty littleendian_passes_tests =\n  (littleendian [  0,   0,   0,   0] == 0x00000000) \/\\\n  (littleendian [ 86,  75,  30,   9] == 0x091e4b56) \/\\\n  (littleendian [255, 255, 255, 250] == 0xfaffffff)\n\nlittleendian_inverse : {n} (fin n) => [8 * n] -> [n][8]\nlittleendian_inverse b = reverse(split b)\n\nproperty littleendian_is_invertable b = littleendian_inverse(littleendian b) == b\n\nlittleendian_state : [64][8] -> [16][32]\nlittleendian_state b = [littleendian xi | xi <- split b]\n\nlittleendian_state_inverse : [16][32] -> [64][8]\nlittleendian_state_inverse w = join (map littleendian_inverse w)\n\nproperty littleendian_state_is_invertable b = littleendian_state_inverse(littleendian_state b) == b\n\nSalsa20 : [32] -> [64][8] -> [64][8]\nSalsa20 count xs = littleendian_state_inverse (Salsa20_rounds count xw xw)\n  where\n    xw = littleendian_state xs\n\nSalsa20_rounds : [32] -> [16][32] -> [16][32] -> [16][32]\nSalsa20_rounds count xw xw' = xw + zs@(count\/2)\n  where\n    zs = [xw'] # [ doubleround zi | zi <- zs ]\n\nproperty Salsa20_passes_tests =\n  (Salsa20 20 [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0] ==\n              [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]) \/\\\n  (Salsa20 20 [211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37, 191, 187, 234, 136,\n                49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,  86,  16, 179, 207,\n                31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113, 238,  55, 204,  36,\n                79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,  88, 118, 104,  54] ==\n              [109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,  26, 110, 170, 154,\n                29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,  69, 144,  51,  57,\n               118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35,  27, 111, 114, 114,\n               219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158, 179,  19,  48, 202]) \/\\\n  (Salsa20 20 [ 88, 118, 104,  54,  79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,\n               191, 187, 234, 136, 211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37,\n                86,  16, 179, 207,  49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,\n               238,  55, 204,  36,  31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113] ==\n              [179,  19,  48, 202, 219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158,\n                26, 110, 170, 154, 109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,\n                69, 144,  51,  57,  29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,\n                27, 111, 114, 114, 118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35])\n\nproperty Salsa20_has_no_collisions x1 x2 =\n  if(x1 != x2) then (doubleround x1) != (doubleround x2) else True\n\n\/\/ Salsa 20 supports two key sizes, [16][8] and [32][8]\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([32], [16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(count, k, n) = Salsa20 count (Salsa20_init(k, n))\n\nSalsa20_init : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_init(k, n) = x\n  where\n    [s0, s1, s2, s3] = split \"expand 32-byte k\" : [4][4][8]\n    [t0, t1, t2, t3] = split \"expand 16-byte k\" : [4][4][8]\n    x = if(`a == 2) then s0 # k0 # s1 # n # s2 # k1 # s3\n                    else t0 # k0 # t1 # n # t2 # k0 # t3\n    [k0, k1] = (split(k#zero)):[2][16][8]\n\nSalsa20_encrypt_with_offset : {a, l} (a >= 1, 2 >= a, l <= 2^^70) =>\n    ([32], [16*a][8], [8][8], [64], [l][8]) -> [l][8]\nSalsa20_encrypt_with_offset(count, k, v, o, m) = c\n  where\n    salsa = take (join [ Salsa20_expansion(count, k, v#(littleendian_inverse (o + i))) | i <- [0, 1 ... ] ])\n    c = m ^ salsa\n\nSalsa20_encrypt : {a, l} (a >= 1, 2 >= a, l <= 2^^70) => ([32], [16*a][8], [8][8], [l][8]) -> [l][8]\nSalsa20_encrypt(count, k, v, m) = c\n  where\n    salsa = take (join [ Salsa20_expansion(count, k, v#(littleendian_inverse i)) | i <- [0, 1 ... ] ])\n    c = m ^ salsa\n```"}]}
{"filename":"saw-script\/otherTests\/cryptol-saw-core\/instance.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify that the provided instance implementations for the type classes Zero, Logic, Ring, Integral, Field, Round, Eq, Cmp, SignedCmp, Literal, and LiteralLessThan satisfy their expected algebraic laws and behaviors. Include properties that check correctness of zero values, logical complements, ring negation, integral division, field reciprocals, rounding, equality, comparison, signed comparison, and literal value generation for the various types and type constructors defined in the code."},{"role":"assistant","content":"```cryptol\n\/* instance Zero Bit *\/\nzeroBit : Bit\nzeroBit = zero\n\n\/* instance Zero Integer *\/\nzeroInteger : Integer\nzeroInteger = zero\n\n\/* instance Zero Rational *\/\nzeroRational : Rational\nzeroRational = zero\n\n\/* instance (fin n, n >= 1) => Zero (Z n) *\/\nzeroZ : {n} (fin n, n >= 1) => Z n\nzeroZ = zero\n\n\/* instance Zero [n] *\/\nzeroWord : {n} [n]\nzeroWord = zero\n\n\/* instance (Zero a) => Zero [n]a *\/\nzeroSeq : {n, a} (Zero a) => [n]a\nzeroSeq = zero\n\n\/* instance (ValidFloat e p) => Zero (Float e p) *\/\nzeroFloat : {e, p} (ValidFloat e p) => Float e p\nzeroFloat = zero\n\n\/* instance (Zero b) => Zero (a -> b) *\/\nzeroFun : {a, b} (Zero b) => a -> b\nzeroFun = zero\n\n\/* instance Zero () *\/\nzeroUnit : ()\nzeroUnit = zero\n\n\/* instance (Zero a, Zero b, ...) => Zero (a, b, ...) *\/\nzeroTuple : {a, b} (Zero a, Zero b) => (a, b)\nzeroTuple = zero\n\n\/* instance Zero {} *\/\nzeroEmpty : {}\nzeroEmpty = zero\n\n\/* instance (Zero a, Zero b, ...) => Zero { x : a, y : b, ... } *\/\nzeroRecord : {a, b} (Zero a, Zero b) => {x : a, y : b}\nzeroRecord = zero\n\n\/* instance Logic Bit *\/\nlogicBit : Bit -> Bit\nlogicBit = complement\n\n\/* instance Logic [n] *\/\nlogicWord : {n} [n] -> [n]\nlogicWord = complement\n\n\/* instance (Logic a) => Logic [n]a *\/\nlogicSeq : {n, a} (Logic a) => [n]a -> [n]a\nlogicSeq = complement\n\n\/* instance (Logic b) => Logic (a -> b) *\/\nlogicFun : {a, b} (Logic b) => (a -> b) -> (a -> b)\nlogicFun = complement\n\n\/* instance Logic () *\/\nlogicUnit : () -> ()\nlogicUnit = complement\n\n\/* instance (Logic a, Logic b, ...) => Logic (a, b, ...) *\/\nlogicTuple : {a, b} (Logic a, Logic b) => (a, b) -> (a, b)\nlogicTuple = complement\n\n\/* instance Logic {} *\/\nlogicEmpty : {} -> {}\nlogicEmpty = complement\n\n\/* instance (Logic a, Logic b, ...) => Logic { x : a, y : b, ... } *\/\nlogicRecord : {a, b} (Logic a, Logic b) => {x : a, y : b} -> {x : a, y : b}\nlogicRecord = complement\n\n\/* instance Ring Integer *\/\nringInteger : Integer -> Integer\nringInteger = negate\n\n\/* instance Ring Rational *\/\nringRational : Rational -> Rational\nringRational = negate\n\n\/* instance (fin n, n >= 1) => Ring (Z n) *\/\nringZ : {n} (fin n, n >= 1) => Z n -> Z n\nringZ = negate\n\n\/* instance (fin n) => Ring [n] *\/\nringWord : {n} (fin n) => [n] -> [n]\nringWord = negate\n\n\/\/ NOTE: 'instance Ring a => Ring [n]a' holds for any type 'a'\n\/\/ distinct from 'Bit'.\n\n\/* instance Ring [n]Integer *\/\nringSeqInteger : {n} [n]Integer -> [n]Integer\nringSeqInteger = negate\n\n\/* instance Ring [n]Rational *\/\nringSeqRational : {n} [n]Rational -> [n]Rational\nringSeqRational = negate\n\n\/* instance (fin k, k >= 1) => Ring [n](Z k) *\/\nringSeqZ : {n, k} (fin k, k >= 1) => [n](Z k) -> [n](Z k)\nringSeqZ = negate\n\n\/* instance (Ring [k]a) => Ring [n][k]a *\/\nringSeqSeq : {n, k, a} (Ring ([k]a)) => [n][k]a -> [n][k]a\nringSeqSeq = negate\n\n\/* instance (Ring b) => Ring [n](a -> b) *\/\nringSeqFun : {n, a, b} (Ring b) => [n](a -> b) -> [n](a -> b)\nringSeqFun = negate\n\n\/* instance Ring [n]() *\/\nringSeqUnit : {n} [n]() -> [n]()\nringSeqUnit = negate\n\n\/* instance (Ring a, Ring b) => Ring [n](a, b) *\/\nringSeqTuple : {n, a, b} (Ring a, Ring b) => [n](a, b) -> [n](a, b)\nringSeqTuple = negate\n\n\/* instance Ring [n]{} *\/\nringSeqEmpty : {n} [n]{} -> [n]{}\nringSeqEmpty = negate\n\n\/* instance (Ring a, Ring b) => Ring [n]{x : a, y : b} *\/\nringSeqRecord : {n, a, b} (Ring a, Ring b) => [n]{x : a, y : b} -> [n]{x : a, y : b}\nringSeqRecord = negate\n\n\/* instance (ValidFloat e p) => Ring (Float e p) *\/\nringFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p\nringFloat = negate\n\n\/* instance (Ring b) => Ring (a -> b) *\/\nringFun : {a, b} (Ring b) => (a -> b) -> (a -> b)\nringFun = negate\n\n\/* instance Ring () *\/\nringUnit : () -> ()\nringUnit = negate\n\n\/* instance (Ring a, Ring b, ...) => Ring (a, b, ...) *\/\nringTuple : {a, b} (Ring a, Ring b) => (a, b) -> (a, b)\nringTuple = negate\n\n\/* instance Ring {} *\/\nringEmpty : {} -> {}\nringEmpty = negate\n\n\/* instance (Ring a, Ring b, ...) => Ring { x : a, y : b, ... } *\/\nringRecord : {a, b} (Ring a, Ring b) => {x : a, y : b} -> {x : a, y : b}\nringRecord = negate\n\n\/* instance Integral Integer *\/\nintegralInteger : Integer -> Integer -> Integer\nintegralInteger = (%)\n\n\/* instance (fin n) => Integral [n] *\/\nintegralWord : {n} (fin n) => [n] -> [n] -> [n]\nintegralWord = (%)\n\n\/* instance Field Rational *\/\nfieldRational : Rational -> Rational\nfieldRational = recip\n\n\/* instance (ValidFloat e p) => Field (Float e p) *\/\nfieldFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p\nfieldFloat = recip\n\n\/* instance (prime p) => Field (Z p) *\/\nfieldZ : {p} prime p => Z p -> Z p\nfieldZ = recip\n\n\/* instance Round Rational *\/\nroundRational : Rational -> Integer\nroundRational = floor\n\n\/* instance (ValidFloat e p) => Round (Float e p) *\/\nroundFloat : {e, p} (ValidFloat e p) => Float e p -> Integer\nroundFloat = floor\n\n\/* instance Eq Bit *\/\neqBit : Bit -> Bit -> Bit\neqBit = (==)\n\n\/* instance Eq Integer *\/\neqInteger : Integer -> Integer -> Bit\neqInteger = (==)\n\n\/* instance Eq Rational *\/\neqRational : Rational -> Rational -> Bit\neqRational = (==)\n\n\/* instance (fin n, n >= 1) => Eq (Z n) *\/\neqZ : {n} (fin n, n >= 1) => Z n -> Z n -> Bit\neqZ = (==)\n\n\/* instance (fin n) => Eq [n] *\/\neqWord : {n} (fin n) => [n] -> [n] -> Bit\neqWord = (==)\n\n\/* instance (fin n, Eq a) => Eq [n]a *\/\neqSeq : {n, a} (fin n, Eq a) => [n]a -> [n]a -> Bit\neqSeq = (==)\n\n\/* instance (ValidFloat e p) => Eq (Float e p) *\/\neqFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p -> Bit\neqFloat = (==)\n\n\/* instance Eq () *\/\neqUnit : () -> () -> Bit\neqUnit = (==)\n\n\/* instance (Eq a, Eq b, ...) => Eq (a, b, ...) *\/\neqTuple : {a, b} (Eq a, Eq b) => (a, b) -> (a, b) -> Bit\neqTuple = (==)\n\n\/* instance Eq {} *\/\neqEmpty : {} -> {} -> Bit\neqEmpty = (==)\n\n\/* instance (Eq a, Eq b, ...) => Eq { x : a, y : b, ... } *\/\neqRecord : {a, b} (Eq a, Eq b) => {x : a, y : b} ->  {x : a, y : b} -> Bit\neqRecord = (==)\n\n\/* instance Cmp Bit *\/\ncmpBit : Bit -> Bit -> Bit\ncmpBit = (<)\n\n\/* instance Cmp Integer *\/\ncmpInteger : Integer -> Integer -> Bit\ncmpInteger = (<)\n\n\/* instance Cmp Rational *\/\ncmpRational : Rational -> Rational -> Bit\ncmpRational = (<)\n\n\/* instance (fin n) => Cmp [n] *\/\ncmpWord : {n} (fin n) => [n] -> [n] -> Bit\ncmpWord = (<)\n\n\/* instance (fin n, Cmp a) => Cmp [n]a *\/\ncmpSeq : {n, a} (fin n, Cmp a) => [n]a -> [n]a -> Bit\ncmpSeq = (<)\n\n\/* instance (ValidFloat e p) => Cmp (Float e p) *\/\ncmpFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p -> Bit\ncmpFloat = (<)\n\n\/* instance Cmp () *\/\ncmpUnit : () -> () -> Bit\ncmpUnit = (<)\n\n\/* instance (Cmp a, Cmp b, ...) => Cmp (a, b, ...) *\/\ncmpTuple : {a, b} (Cmp a, Cmp b) => (a, b) -> (a, b) -> Bit\ncmpTuple = (<)\n\n\/* instance Cmp {} *\/\ncmpEmpty : {} -> {} -> Bit\ncmpEmpty = (<)\n\n\/* instance (Cmp a, Cmp b, ...) => Cmp { x : a, y : b, ... } *\/\ncmpRecord : {a, b} (Cmp a, Cmp b) => {x : a, y : b} ->  {x : a, y : b} -> Bit\ncmpRecord = (<)\n\n\/* instance (fin n, n >= 1) => SignedCmp [n] *\/\nsignedCmpWord : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsignedCmpWord = (<$)\n\n\/\/ NOTE: 'instance (fin n, SignedCmp a) => SignedCmp ([n]a)' holds for\n\/\/ any type 'a' distinct from 'Bit'.\n\n\/* instance (fin n, SignedCmp [k]a) => SignedCmp [n][k]a *\/\nsignedCmpSeqSeq : {n, k, a} (fin n, SignedCmp ([k]a)) => [n][k]a -> [n][k]a -> Bit\nsignedCmpSeqSeq = (<$)\n\n\/* instance (fin n) => SignedCmp [n]() *\/\nsignedCmpSeqUnit : {n} (fin n) => [n]() -> [n]() -> Bit\nsignedCmpSeqUnit = (<$)\n\n\/* instance (SignedCmp a, SignedCmp b) => SignedCmp [n](a, b) *\/\nsignedCmpSeqTuple : {n, a, b} (fin n, SignedCmp a, SignedCmp b) => [n](a, b) -> [n](a, b) -> Bit\nsignedCmpSeqTuple = (<$)\n\n\/* instance SignedCmp [n]{} *\/\nsignedCmpSeqEmpty : {n} (fin n) => [n]{} -> [n]{} -> Bit\nsignedCmpSeqEmpty = (<$)\n\n\/* instance (SignedCmp a, SignedCmp b) => SignedCmp [n]{x : a, y : b} *\/\nsignedCmpSeqRecord : {n, a, b} (fin n, SignedCmp a, SignedCmp b) => [n]{x : a, y : b} -> [n]{x : a, y : b} -> Bit\nsignedCmpSeqRecord = (<$)\n\n\/* instance SignedCmp () *\/\nsignedCmpUnit : () -> () -> Bit\nsignedCmpUnit = (<$)\n\n\/* instance (SignedCmp a, SignedCmp b, ...) => SignedCmp (a, b, ...) *\/\nsignedCmpTuple : {a, b} (SignedCmp a, SignedCmp b) => (a, b) -> (a, b) -> Bit\nsignedCmpTuple = (<$)\n\n\/* instance SignedCmp {} *\/\nsignedCmpEmpty : {} -> {} -> Bit\nsignedCmpEmpty = (<$)\n\n\/* instance (SignedCmp a, SignedCmp b, ...) => SignedCmp { x : a, y : b, ... } *\/\nsignedCmpRecord : {a, b} (SignedCmp a, SignedCmp b) => {x : a, y : b} ->  {x : a, y : b} -> Bit\nsignedCmpRecord = (<$)\n\n\/* instance (1 >= val) => Literal val Bit *\/\nliteralBit : {val} (1 >= val) => Bit\nliteralBit = `val\n\n\/* instance (fin val) => Literal val Integer *\/\nliteralInteger : {val} (fin val) => Integer\nliteralInteger = `val\n\n\/* instance (fin val) => Literal val Rational *\/\nliteralRational : {val} (fin val) => Rational\nliteralRational = `val\n\n\/* instance (fin val, fin n, n >= 1, n > val) => Literal val (Z n) *\/\nliteralZ : {val, n} (fin val, fin n, n >= 1, n > val) => Z n\nliteralZ = `val\n\n\/* instance (fin val, fin n, n >= width val) => Literal val [n] *\/\nliteralWord : {val, n} (fin val, fin n, n >= width val) => [n]\nliteralWord = `val\n\n\/* instance (2 >= val) => LiteralLessThan val Bit *\/\nliteralLessThanBit : {val} (1 >= val) => [val]Bit\nliteralLessThanBit = [0..<val]\n\n\/* instance LiteralLessThan val Integer *\/\nliteralLessThanInteger : {val} (fin val) => [val]Integer\nliteralLessThanInteger = [0..<val]\n\n\/* instance LiteralLessThan val Rational *\/\nliteralLessThanRational : {val} (fin val) => [val]Rational\nliteralLessThanRational = [0..<val]\n\n\/* instance (fin n, n >= 1, n >= val) => LiteralLessThan val (Z n) *\/\nliteralLessThanZ : {val, n} (fin n, n >= 1, n >= val) => [val](Z n)\nliteralLessThanZ = [0..<val]\n\n\/* instance (fin n, n >= width val) => LiteralLessThan val [n] *\/\nliteralLessThanWord : {val, n} (fin n, n >= lg2 val) => [val][n]\nliteralLessThanWord = [0..<val]\n```"}]}
{"filename":"saw-script\/otherTests\/cryptol-saw-core\/superclass.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that specify and verify the behavior of the zero and fromInteger functions for the typeclasses Ring, Logic, Integral, Field, and Round as defined in the provided code. Include properties that check that zeroRing, zeroLogic, zeroIntegral, zeroField, and zeroRound all equal zero, and that fromIntIntegral, fromIntField, and fromIntRound correctly produce the value corresponding to integer 42. Also, specify properties for recipRound, compareRound, and eqCmp functions to verify their correctness according to their definitions."},{"role":"assistant","content":"```cryptol\nzeroRing : {a} (Ring a) => a\nzeroRing = zero\n\nzeroLogic : {a} (Logic a) => a\nzeroLogic = zero\n\nzeroIntegral : {a} (Integral a) => a\nzeroIntegral = zero\n\nzeroField : {a} (Field a) => a\nzeroField = zero\n\nzeroRound : {a} (Round a) => a\nzeroRound = zero\n\nfromIntIntegral : {a} (Integral a) => a\nfromIntIntegral = fromInteger 42\n\nfromIntField : {a} (Field a) => a\nfromIntField = fromInteger 42\n\nfromIntRound : {a} (Round a) => a\nfromIntRound = fromInteger 42\n\nrecipRound : {a} (Round a) => a -> Integer\nrecipRound x = trunc (recip x)\n\ncompareRound : {a} (Round a) => a -> a -> Bit\ncompareRound x y = x < y\n\neqCmp : {a} (Cmp a) => a -> a -> Bit\neqCmp x y = x == y\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/ModDivZ.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the 'moddiv' function in the 'Common::ModDivZ' module. The properties should ensure that for a prime modulus p >= 3, 'moddiv x y' correctly computes the modular division x \/ y in Z_p, including handling division by zero as an error, and that the result satisfies the modular inverse relationship (y * (x \/ y) == x) mod p. Include edge cases and verify that the internal 'egcd' function correctly implements Euler's binary gcd algorithm for modular inversion."},{"role":"assistant","content":"```cryptol\n\/\/ Modular division for Z n types\n\nmodule Common::ModDivZ where\n\neven k = k % 2 == 0\n\n\/\/ Calulate x \/ y in F_p using Euler's binary gcd algorithm\nmoddiv : {p}(fin p, p >= 3) => Z p -> Z p -> Z p  \/\/ p prime!\nmoddiv x y = if y == 0 then error \"division by 0\"  \/\/ zero has no inverse\n                       else fromInteger (egcd `p 0 (fromZ y) (fromZ x))\n    where\n\n    egcd : Integer -> Integer -> Integer -> Integer -> Integer\n    egcd a ra b rb =  \/\/ a odd!\n        if b == 0 then ra\n         | even b then egcd a ra (   b    \/ 2) (half rb)\n         | a < b  then egcd a ra ((b - a) \/ 2) (half ((rb - ra) % `p))\n                  else egcd b rb ((a - b) \/ 2) (half ((ra - rb) % `p))\n\n    half : Integer -> Integer\n    half k = (if even k then k else (k + `p)) \/ 2\n\n(%\/) = moddiv  \/\/ infix form of operator\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/mul_java.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the mul_java function and its related helper functions in the Common::mul_java module. Then, create Cryptol properties to verify that mul_java correctly implements multiplication of large integers represented as arrays of 32-bit words, matching the semantics of the Java implementation. Include properties that check the correctness of intermediate steps such as mul_java_inner, sq_java, and the group multiplication and reduction functions, ensuring consistency with the modular arithmetic and array updates performed in the code."},{"role":"assistant","content":"```cryptol\nmodule Common::mul_java where\n\nimport Common::bv\n\nmul_java_inner : (Bit, [24][32], [32], [32], [32], [64]) -> { mji_a : [24][32], mji_d : [64]}\nmul_java_inner (azero, a, ij, xi, yj, d) = { mji_a = a', mji_d = d' >> 32 }\n  where\n    m        = zext(xi) * zext(yj)\n    d'       = d + m + zext(aij)\n    a'       = update a ij (drop(d'))\n    aij      = if ~azero then a @ ij else 0\n\n\/*\naset : {n, is} (fin n, fin is, n >= is, is >= lg2 n, n >= 32, is >= max(lg2 n, 6)) =>\n          ([n], [is], [is]) -> [n]\n*\/\naset (a, i, x) = (a && imask) || x'\n  where\n    imask = ~(zext(0xFFFFFFFF : [32]) << (i*32))\n    x' = zext(x) << (i*32)\n\naset_768 : ([768], [32], [32]) -> [768]\naset_768 = aset\n\ntoJavaArray : [384] -> [12][32]\ntoJavaArray x = reverse (split x)\n\nfromJavaArray : [12][32] -> [384]\nfromJavaArray x = join (reverse x)\n\n\/\/ Matches java implementation; computes safe_product.\nmul_java : ([768], [384], [384]) -> [768]\nmul_java (a0, x, y) = join (reverse (a_final!0))\n  where\n    l   = 12 : [32]\n    x'  = toJavaArray x\n    y'  = toJavaArray y\n    a0' = reverse (split a0) : [24][32]\n\n    \/* First loop in Java implementation *\/\n    a_first : [13]([64],[24][32])\n    a_first = [ (zero : [64], a0' : [24][32]) ]\n            # [ (res.mji_d, res.mji_a)\n                   where res = mul_java_inner(True, a, j, x'@0, y'@j, d)\n              | (d, a) <- a_first\n              | j      <- [0..11]\n              ]\n    (d_first_final, a_first_final) = a_first!0\n    ad_first_final = update a_first_final l (drop(d_first_final):[32])\n\n    \/* Second loop in Java implementation *\/\n    a_final : [12][24][32]\n    a_final = [ ad_first_final ]\n            # [ ad_inner_final\n                 where\n                   \/* Inner loop in Java implementation *\/\n                   a_inner : [13]([64],[24][32],[32])\n                   a_inner = [ ( zero : [64] , a, i) ]\n                           # [ (res.mji_d, res.mji_a, ij+1)\n                                where\n                                  res = mul_java_inner(False, ai, ij, x'@i, y'@j, d)\n                             | (d, ai, ij) <- a_inner\n                             | j          <- [0..(12-1)]:[12][32]\n                             ]\n\n                   (d_inner_final, a_inner_final, ij_final) = a_inner!0\n                   ad_inner_final = update a_inner_final ij_final (drop(d_inner_final))\n              | a <- a_final\n              | i <- [1..11]\n              ]\n\nsq_java_inner1 : ([24][32], [32], [64]) -> { mji_a : [24][32], mji_d : [64]}\nsq_java_inner1 (a, ij, c) = { mji_a = a' , mji_d = c'' }\n  where\n    aij = a @ ij\n    c' = c + (zext(aij) << 1)\n    a' = update a ij (drop(c'))\n    c'' = c' >> 32\n\nsq_java_inner2 : ([24][32], [32], [32], [64]) ->\n                 { mji_a : [24][32], mji_d : [64]}\nsq_java_inner2 (a, ij, xati, c) = { mji_a = a' , mji_d = c'' }\n  where\n    aij = a @ ij\n    xi = zext(xati) : [64]\n    m = xi * xi\n    c' = c + (m && 0x00000000FFFFFFFF) + (zext(aij) << 1)\n    a' = update a ij (drop(c'))\n    c'' = (c' >> 32) + (m >> 32)\n\nsq_java_loop : ([24][32], [384]) -> [24][32]\nsq_java_loop(a0, x) = a_mid!0\n  where\n    \/* Second loop in Java implementation *\/\n    l = 12 : [32]\n    x'  = toJavaArray x\n    a_mid   = [ a0 ]\n            # [ ad_inner_final\n                 where\n                   \/* Inner loop in Java implementation *\/\n                   a_inner = [ ( zero : [64] , a, i+i+1) ]\n                           # [ (res.mji_d, res.mji_a, ij+1)\n                                where\n                                  res = if j+i < l then\n                                          mul_java_inner(False, ai, ij, x'@i, x'@(j+i), d)\n                                        else zero\n                             | (d, ai, ij) <- a_inner\n                             | j          <- [1..(12-1)]\n                             ]\n                   (d_inner_final, a_inner_final, ij_final) = a_inner!i\n                   ad_inner_final = update a_inner_final ij_final (drop(d_inner_final))\n              | a <- a_mid\n              | i <- [1..(12-2)]\n              ]\n\nsq_java : ([768], [384]) -> [768]\nsq_java (a0, x) = join (reverse ad_final_final)\n  where\n    l   = 12 : [32]\n    x'  = toJavaArray x\n    a0' = reverse (split a0) : [24][32]\n    x0 = x'@0\n    \/* First loop in Java implementation *\/\n    a_first = [ (zero : [64], a0' : [24][32]) ]\n            # [ (res.mji_d, res.mji_a)\n                 where res = mul_java_inner(True, a, j, x0, x'@j, d)\n              | (d, a) <- a_first\n              | j      <- [1..11]\n              ]\n    (d_first_final, a_first_final) = a_first!0\n    ad_first_final = update a_first_final l (drop(d_first_final))\n\n    mid_res = mul_java_inner(True, sq_java_loop(ad_first_final, x), 0, x0, x0, 0)\n\n    \/* Third loop in Java implementation *\/\n    a_final : [12]([64],[24][32],[32])\n    a_final = [ (mid_res.mji_d, mid_res.mji_a, 1) ]\n            # [ (res'.mji_d, res'.mji_a, ij+2)\n                where\n                   res = sq_java_inner1(a, ij, c)\n                   res' = sq_java_inner2(res.mji_a, ij+1, x'@(i:[32]), res.mji_d)\n              | (c, a, ij) <- a_final\n              | i      <- [1..11]\n              ]\n    (d_final_final, a_final_final, ij_final) = a_final!0\n    ad_final_final = update a_final_final ((l << 1) - 1) (drop(d_final_final))\n\naset_384 : ([384], [32], [32]) -> [384]\naset_384(a, i, x) = fromJavaArray (update (toJavaArray a) i x)\n\njava_lashr32 : [64] -> [64]\njava_lashr32 x = take(sext(x) : [96])\n\ngroup_red_aux_java : ([384], [32], [32], [64], [64]) ->\n                     { gra_r: [384] , gra_b : [64] }\ngroup_red_aux_java(r, aj, j, c, b) = { gra_r = r' , gra_b = b'' }\n  where\n    rj, m, b' : [64]\n    rj = zext(toJavaArray r @ j)\n    m = c * zext(aj)\n    b' = b + rj - zext(drop(m):[32])\n    r' = aset_384(r, j, drop(b'))\n    b'' = java_lashr32(b') - (m >> 32)\n\ngroup_mul_aux_java : ([384], [32], [32], [32], [64]) ->\n                     { gra_r: [384] , gra_b : [64] }\ngroup_mul_aux_java(r, yj, j, xi, c) = { gra_r = r' , gra_b = c'' }\n  where\n    rj, m, c' : [64]\n    rj = zext(toJavaArray r @ j)\n    m = zext(xi) * zext(yj)\n    c' = c + rj + zext(drop(m):[32])\n    r' = aset_384(r, j, drop(c'))\n    c'' = (c' >> 32) + (m >> 32)\n\np384_group_red : ([384], [384], [64]) -> [384]\np384_group_red(order, r, c) = r'''\n  where\n    order' = toJavaArray order\n    loop : [13]([384],[64])\n    loop = [ (r, zero : [64]) ] #\n           [ (res.gra_r, res.gra_b)\n              where res = group_red_aux_java(rj, order'@j, j, c, bi)\n           | (rj, bi) <- loop\n           | j <- [0..11]\n           ]\n    (r', b) = loop!0\n    c' = c + b\n    (r'', c'') = if c' != 0 then\n                   (r' - order, c' + (if r' >= order then 0 else -1))\n                 else (r', c')\n    r''' = if c'' != 0 then r'' - order else r''\n\np384_group_mul : ([384], [384], [384]) -> [384]\np384_group_mul(order, x, y) = r'\n  where\n    xa = toJavaArray x\n    ya = toJavaArray y\n    outer : [13][384]\n    outer = [ (zero : [384]) ] #\n            [ p384_group_red(order, rn, cn)\n               where\n                 r0 : [384]\n                 r0 = p384_group_red(order,\n                                     ro << (32 : [9]),\n                                     zext(take(ro):[32]))\n                 inner : [13]([384], [64])\n                 inner = [ (r0, 0) ] #\n                         [ (res.gra_r, res.gra_b)\n                            where\n                              res = group_mul_aux_java(rj, ya@j, j, xa@(i:[32]), cj)\n                         | j <- [0..11]\n                         | (rj, cj) <- inner\n                         ]\n                 (rn, cn) = inner!0\n            | i <- reverse [0..11]\n            | ro <- outer\n            ]\n    r = outer!0\n    r' = if order <= r then r - order else r\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/utils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the functions 'half' and 'mp_mod_inv' in the given module. Specifically, specify properties that ensure 'half' correctly computes half of an odd modulus integer as defined, and that 'mp_mod_inv' computes the multiplicative inverse modulo 'n' for nonzero inputs. Include properties that capture the expected mathematical relationships and constraints for these functions."},{"role":"assistant","content":"```cryptol\nmodule Common::utils where\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = (fromInteger (fromZ x))\n\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = (fromInteger (toInteger x))\n\nZtoZ : {p, q} (fin p, fin q, p >= 1, q >= 1) => Z p -> Z q\nZtoZ x = (fromInteger (fromZ x))\n\nintegerToBV : {m} (fin m) => Integer -> [m]\nintegerToBV x = fromInteger x\n\nintegerFromBV : {m} (fin m) => [m] -> Integer\nintegerFromBV x = toInteger x\n\nintegerModulusFromBV : {m} (fin m) => [m] -> Integer\nintegerModulusFromBV x = if (integerFromBV x) < 3 then 3 else (integerFromBV x)\n\nisEven : Integer -> Bit\nisEven x = ~((fromInteger x) : [1]) ! 0\n\nabs : Integer -> Integer\nabs x = if x >= zero then x else zero-x\n\nunzip : {a,f,s} [a](f,s) -> ([a]f,[a]s)\nunzip tuples = (map (\\x -> x.0) tuples , map (\\x -> x.1) tuples)\n\nmul2 x = x + x\nmul3 x = x + mul2 x\nmul4 x = mul2(mul2 x)\nmul8 x = mul2(mul4 x)\n\ntype constraint isOdd a = (a \/ 2) * 2 == a - 1\n\nhalf : {p} (fin p, p >= 3, isOdd p) => Z p -> Z p\nhalf x = fromInteger (if isEven xint then xint\/2 else ((xint + `p) \/ 2))\n  where\n    xint = fromZ x\n\nhalf_correct : {p} (fin p, p >= 3, isOdd p) => Z p -> Bit\nproperty half_correct x = half x + half x == x\n\nmp_mod_inv : {n} (fin n, n >= 1) => Z n -> Z n\nmp_mod_inv c = if c == 0 then error \"Zero does not have a multiplicative inverse\"\n               else fromInteger (if u'' == 1 then x1'' else x2'')\n  where\n    innercond (a, x) = isEven a\n    innerbody (a, x) = (a \/ 2, if isEven x then x \/ 2 else (x + `n) \/ 2)\n\n    outtercond (u, v, x1, x2) = (u != 1) \/\\ (v != 1)\n    outterbody (u, v, x1, x2) = if(u' >= v') then (u' - v', v', x1' - x2' % `n, x2')\n                                             else (u', v' - u', x1', x2' - x1' % `n)\n      where\n        (u', x1') = while innercond innerbody (u, x1)\n        (v', x2') = while innercond innerbody (v, x2)\n\n    (u'', _, x1'', x2'') = while outtercond outterbody (fromZ c, `n, 1, 0)\n\n\/\/ Note, this property will only hold when the modulus is prime\nmp_mod_inv_correct : {a} (fin a, a >=2) => Z a -> Bit\nproperty mp_mod_inv_correct x = x != 0 ==> x * mp_mod_inv x == 1\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the HMAC implementation in the given module. The properties should ensure that the hmacSHA256 function correctly implements the HMAC construction using SHA256 as defined in the standard, including correct key initialization (kinit), inner and outer padding, and final hash computation. Include properties that check the length constraints, key processing, and that the output matches expected HMAC values for given test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC where\n\nimport Primitive::Keyless::Hash::SHA256\n\nhmacSHA256 : {pwBytes, msgBytes}\n             (fin pwBytes, fin msgBytes\n             , 32 >= width msgBytes\n             , 64 >= width (8*pwBytes)\n             , 64 >= width (8 * (64 + msgBytes))\n             ) => [pwBytes][8] -> [msgBytes][8] -> [256]\nhmacSHA256 = hmac `{blockLength=64} SHA256 SHA256 SHA256\n\nkinit : { pwBytes, blockLength, digest }\n        ( fin pwBytes, fin blockLength, fin digest )\n     => ([pwBytes][8] -> [8*digest])\n     -> [pwBytes][8]\n     -> [blockLength][8]\nkinit hash key =\n  if `pwBytes > (`blockLength : [max (width pwBytes) (width blockLength)])\n  then take `{blockLength} (split (hash key) # (zero : [blockLength][8]))\n  else take `{blockLength} (key # (zero : [blockLength][8]))\n\n\/\/ Due to limitations of the type system we must accept two\n\/\/ separate arguments (both aledgedly the same) for two\n\/\/ separate length inputs.\nhmac : { msgBytes, pwBytes, digest, blockLength }\n       ( fin pwBytes, fin digest, fin blockLength )\n    => ([blockLength + msgBytes][8] -> [8*digest])\n    -> ([blockLength + digest][8] -> [8*digest])\n    -> ([pwBytes][8] -> [8*digest])\n    -> [pwBytes][8]\n    -> [msgBytes][8]\n    -> [digest*8]\nhmac hash hash2 hash3 key message = hash2 (okey # internal)\n where\n   ks : [blockLength][8]\n   ks = kinit hash3 key\n   okey = [k ^ 0x5C | k <- ks]\n   ikey = [k ^ 0x36 | k <- ks]\n   internal = split (hash (ikey # message))\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/AES_256_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the AES-256 GCM authenticated encryption implementation in the given module. Include properties that check the correctness of the GCM polynomial multiplication and reduction, the AES block encryption, the counter mode encryption, and the final authentication tag computation. Ensure that the properties capture the expected relationships between inputs, intermediate states, and outputs, suitable for use with Cryptol's :prove or :check commands."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM where\n\nimport Primitive::Symmetric::Cipher::Block::AES\n\n\naes_hw_encrypt : [16][8] -> [32][8] -> [16][8]\naes_hw_encrypt in key = split (aesEncrypt ((join in), (join key)))\n\n\ngcm_pmult_pmod : [128] -> [128] -> [128]\ngcm_pmult_pmod X Y = reverse (pmod (pmult (reverse X) (reverse Y)) <| x^^128 + x^^7 + x^^2 + x + 1|>)\n\ngcm_polyval_mul : {n} (fin n) => [2 * (1 + n)] -> [2 * (1 + n)] -> [4 * (1 + n)]\ngcm_polyval_mul X Y = (0 : [1]) # pmult X Y\n\ngcm_polyval_red : [256] -> [128]\ngcm_polyval_red X = reverse (pmod (reverse X) <| x^^128 + x^^7 + x^^2 + x + 1|>)\n\ngcm_polyval : [128] -> [128] -> [128]\ngcm_polyval X Y = gcm_polyval_red (gcm_polyval_mul X Y)\n\ngcm_init_H : [128] -> [128]\ngcm_init_H Xi = pmod (Xi # (0 : [1]))  <| 1 + x^^121 + x^^126 + x^^127 + x^^128 |>\n\n\ntype AES_GCM_Ctx =\n  { key : [32][8]\n  , iv : [12][8]\n  , Xi : [16][8]\n  , len : [64]\n  }\n\n\nget_H : AES_GCM_Ctx -> [2][64]\nget_H ctx = split (join (aes_hw_encrypt zero ctx.key))\n\nEKi : AES_GCM_Ctx -> [32] -> [16][8]\nEKi ctx i = aes_hw_encrypt (ctx.iv # (split (i + 1))) ctx.key\n\nEKij : AES_GCM_Ctx -> [32] -> [4] -> [8]\nEKij ctx i j = (EKi ctx i) @ j\n\n\ncipher_update : {n} (fin n) => [32] -> AES_GCM_Ctx -> [n][8] -> AES_GCM_Ctx\ncipher_update enc ctx in = ctx'\n  where\n    enc_bytes = if enc ! 0\n      then ctr32_encrypt ctx in\n      else in\n    ctx' = foldl cipher_update_byte ctx enc_bytes\n\nctr32_encrypt : {n} (fin n) => AES_GCM_Ctx -> [n][8] -> [n][8]\nctr32_encrypt ctx in = out\n  where\n    out = [ byte ^ (EKij ctx ((take`{32} (drop`{28} i)) + 1) (drop`{60} i)) | byte <- in | i <- [ctx.len ...] ]\n\ncipher_update_byte : AES_GCM_Ctx -> [8] -> AES_GCM_Ctx\ncipher_update_byte ctx byte = ctx'\n  where\n    H = join (get_H ctx)\n    n = ctx.len % 16\n    Xi' = update ctx.Xi n ((ctx.Xi @ n) ^ byte)\n    len' = ctx.len + 1\n    Xi'' = if (len' % 16) == 0\n      then split (gcm_pmult_pmod H (join Xi'))\n      else Xi'\n    ctx' =\n      { key = ctx.key\n      , iv = ctx.iv\n      , Xi = Xi''\n      , len = len'\n      }\n\ncipher_final : AES_GCM_Ctx -> [16][8]\ncipher_final ctx = (split (gcm_pmult_pmod H Xi'')) ^ (EKi ctx 0)\n  where\n    H = join (get_H ctx)\n    Xi' = if (ctx.len % 16) != 0\n      then gcm_pmult_pmod H (join ctx.Xi)\n      else join ctx.Xi\n    Xi'' = Xi' ^ (0 # (ctx.len * 8))\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/AES_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the AES-GCM encryption implementation against the provided test vectors in the AES_GCM.cry module. Ensure each property checks that the output ciphertext and authentication tag match the expected values for given keys, IVs, plaintexts, and AAD inputs."},{"role":"assistant","content":"```cryptol\n\/\/Test vectors from http:\/\/luca-giuzzi.unibs.it\/corsi\/Support\/papers-cryptography\/gcm-spec.pdf\n\nmodule Primitive::Symmetric::Cipher::Authenticated::AES_GCM where\nimport `Primitive::Symmetric::Cipher::Authenticated::GCM\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\n\nproperty testPass0 = gcmEnc `{K=128, IV=96, AAD=0, T=128} {E=encrypt} {key=zero, iv=zero, pt=[], aad=[]} ==\n                              {ct = [], tag = 0x58e2fccefa7e3061367f1d57a4e7455a}\n\nproperty testPass1 = gcmEnc `{K=128, IV=96, AAD=0, T=128} {E=encrypt} {key=zero, iv=zero, pt=zero, aad=[]} ==\n                              {ct = 0x0388dace60b6a392f328c2b971b2fe78, tag = 0xab6e47d42cec13bdf53a67b21257bddf}\n\nproperty testPass2 = gcmEnc `{K=128, IV=96, AAD=0, T=128} {E=encrypt} {key=0xfeffe9928665731c6d6a8f9467308308, iv=0xcafebabefacedbaddecaf888,         pt=0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b391aafd255, aad=[]} ==\n    {ct = 0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091473f5985,\n    tag = 0x4d5c2af327cd64a62cf35abd2ba6fab4}\n\nproperty testPass3 = gcmEnc `{K=128, IV=96, AAD=160, T=128} {E=encrypt} {key=0xfeffe9928665731c6d6a8f9467308308,                                            iv=0xcafebabefacedbaddecaf888,\n    pt=0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b39,\n    aad=0xfeedfacedeadbeeffeedfacedeadbeefabaddad2} ==\n    {ct=0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091,\n    tag=0x5bc94fbc3221a5db94fae95ae7121a47}\n\n\/\/ A test case from aesgcmtest.c\n\/\/ Test passes\nproperty testPass4 = gcmEnc `{K=256, IV=96, AAD=128, T=128} {E=encrypt} {key=0xeebc1f57487f51921c0465665f8ae6d1658bb26de6f8a069a3520293a572078f,\n    iv=0x99aa3e68ed8173a0eed06684, pt=0xf56e87055bc32d0eeb31b2eacc2bf2a5, aad=0x4d23c3cec334b49bdb370c437fec78de} ==\n   {ct=0xf7264413a84c0e7cd536867eb9f21736, tag=0x67ba0510262ae487d737ee6298f77e0c}\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the GCM authenticated encryption and decryption functions defined in the given module. The properties should ensure that decryption correctly recovers the original plaintext when the authentication tag matches, and that the tag verification fails otherwise. Additionally, specify properties that verify the correctness of the GHASH function and the polynomial multiplication in GF(2^128) as used in the GCM construction."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM where\n\nparameter\n  \/** Key size *\/\n  type K : #\n  type constraint (fin K)\n\n  \/** Size of initialization vector *\/\n  type IV : #\n  type constraint (64 >= width IV, IV >= 1)\n\n  \/** Size of additional authenticated data *\/\n  type AAD  : #\n  type constraint (64 >= width AAD)\n\n  \/** Size of authentication tag *\/\n  type T : #\n  type constraint (128 >= T, T >= 64)\n\n  \/** Block encryption function *\/\n  E : [K] -> [128] -> [128]\n\ngcmEnc :\n  {n} (2^^39 - 256 >= n) =>\n      { key : [K], iv : [IV], aad : [AAD], pt : [n] } -> { ct : [n], tag : [T] }\ngcmEnc input = { ct = C, tag = T }\n  where (C,T) = enc_dec input.key input.iv input.aad input.pt\n\ngcmDec :\n  {n} (2^^39 - 256 >= n) =>\n  { key : [K], iv  : [IV], aad : [AAD], ct  : [n], tag : [T] } ->\n  { valid : Bool, pt : [n] }\ngcmDec input = if input.tag == T then { valid = True, pt = P }\n                                  else { valid = False, pt = 0 }\n  where (P,T) = enc_dec input.key input.iv input.aad input.ct\n\n\n\n\/**\nThe basic functionality between encryption and decryption.\nIn the case of decryption, the plain text is only valid if the tags match.\n*\/\nenc_dec :\n  {n} ((2^^39 - 256) >= n) => [K] -> [IV] -> [AAD] -> [n] -> ([n], [T])\nenc_dec K IV A P = (C,T)\n  where\n  H  = (E K 0)\n\n  Y0 = ifWidth`{96} IV (\\IV96 -> IV96 # 1)\n                       (GHASH H [] IV)\n\n  Ys = [Y0] # [ y+1 | y <- Ys ]\n\n  Cs = [ p ^ (E K y) | p <- blockify P | y <- drop`{1} Ys ]\n  C  = unblockify Cs\n\n  T = take (GHASH H A C ^ (E K Y0))\n\n\n\/** Section 2.3, equation (2) *\/\nGHASH : {C,A} (64 >= width C, 64 >= width A) => [128] -> [A] -> [C] -> [128]\nGHASH H A C = step (XS ! 0) (wa # wc)\n  where\n  wa = `A : [64]\n  wc = `C : [64]\n\n  XS = [0] # [ step X' B | X' <- XS | B <- blockify A # blockify C ]\n\n  step x b = mult (x ^ b) H\n\n\n\n\/** Section 2.5, multiplication in GF(2^^128)\n\nThis is simple polynomial multipliation and reduction in Cryptol.\nSomewhat oddly, when thinking of the 128-bits as polynomials,\nthe spec treats the most significant bit as the 0 power,\nwhich is the reason for the `reverse` operations.\n*\/\nmult : [128] -> [128] -> [128]\nmult X Y = reverse (pmod (pmult (reverse X) (reverse Y)) irred)\n  where irred = <| 1 + x + x^^2 + x^^7 + x^^128 |>\n\n\n\/** Create blocks as described in the spec, first paragraph of Section 2.3.\nBasically we split into 128-bit chunk and pad the last one with 0. *\/\nblockify : {n} (fin n) => [n] -> [n \/^ 128][128]\nblockify msg = split (msg # 0)\n\n\/** Join back the blocks, dropping any additional padding. *\/\nunblockify : {n} (fin n) => [n \/^ 128][128] -> [n]\nunblockify ms = take (join ms)\n\n\nifWidth : {w,n,a} (fin n, fin w) => [n] -> ([w] -> a) -> a -> a\nifWidth thing yep nope = if `w == (`n : [max (width w) (width n)])\n                            then yep (take (thing # (zero : [inf])))\n                            else nope\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/DES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the DES cipher implementation in the given module. Specifically, create properties that check that decrypting an encrypted message with the same key returns the original message, and that the encryption of known test messages with given keys matches the expected ciphertexts. Include properties suitable for :prove or :check commands to validate these behaviors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::DES where\n\nimport Primitive::Symmetric::Cipher::Block::Cipher\n\n\/\/ DES API\nDES : Cipher 64 64\nDES =\n    { encrypt key pt = des (expandKey key) pt\n    , decrypt key ct = des (reverse (expandKey key)) ct\n    }\n\ndes keys pt = (swap (split lst)) @@ FPz\n  where\n        pt' = pt @@ IPz\n        iv  = [ round (k, split lr)\n              | k  <- keys\n              | lr <- [pt'] # iv ]\n        lst = iv @ (length keys - 1)\n\nround : ([48],[2][32]) -> [64]\nround (k, [l, r]) = r # (l ^ f (r, k))\n\n\/\/ f : {a} (a >= 6) => ([2^^(a-1)],[48]) -> [32]\n\/\/ f : {b} (b >= 1, 6 == lg2 b) => ([b - 1], [48]) -> [32]\nf (r, k) = (SBox(k ^ (r @@ EPz))) @@ PPz\n\nswap [a, b] = b # a\n\n\/\/ Key expansion\n\nexpandKey : [64] -> [16][48]\nexpandKey key = expand (split (key @@ KPz))\n\nexpand: [2][28] -> [16][48]\nexpand [kl, kr] =\n    [ ((kl <<< i) # (kr <<< i)) @@ CPz\n    | i <- sums [ 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 ] ]\n\nsums : [16][8] -> [16][8]\nsums xs = ys\n  where ys = [ x + y | x <- xs | y <- [0] # ys ]\n\nzeroBasify XP = [ i - 1 | i <- XP ]\nKPz = zeroBasify KP\nCPz = zeroBasify CP\nPPz = zeroBasify PP\nEPz = zeroBasify EP\nIPz = zeroBasify IP\nFPz = zeroBasify FP\n\nKP : [56][6]\nKP  = [57,49,41,33,25,17, 9, 1,58,50,42,34,26,18,\n       10, 2,59,51,43,35,27,19,11, 3,60,52,44,36,\n       63,55,47,39,31,23,15, 7,62,54,46,38,30,22,\n       14, 6,61,53,45,37,29,21,13, 5,28,20,12, 4\n      ]\n\n\nCP : [48][6]\nCP  = [14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,\n       23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,\n       41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,\n       44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32\n      ]\n\nPP : [32][6]\nPP = [16,  7, 20, 21, 29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,\n       2,  8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25\n     ]\n\nEP : [48][6]\nEP  = [32,  1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,\n        8,  9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,\n       16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,\n       24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,  1\n      ]\n\n\nIP : [64][7]\nIP = [58, 50, 42, 34, 26, 18, 10,  2, 60, 52, 44, 36, 28, 20, 12,  4,\n      62, 54, 46, 38, 30, 22, 14,  6, 64, 56, 48, 40, 32, 24, 16,  8,\n      57, 49, 41, 33, 25, 17,  9,  1, 59, 51, 43, 35, 27, 19, 11,  3,\n      61, 53, 45, 37, 29, 21, 13,  5, 63, 55, 47, 39, 31, 23, 15,  7\n     ]\n\nFP : [64][7]\nFP = [40,  8, 48, 16, 56, 24, 64, 32, 39,  7, 47, 15, 55, 23, 63, 31,\n      38,  6, 46, 14, 54, 22, 62, 30, 37,  5, 45, 13, 53, 21, 61, 29,\n      36,  4, 44, 12, 52, 20, 60, 28, 35,  3, 43, 11, 51, 19, 59, 27,\n      34,  2, 42, 10, 50, 18, 58, 26, 33,  1, 41,  9, 49, 17, 57, 25\n     ]\n\n\/\/ Sboxen\nSBox : [48] -> [32]\nSBox x = join [ sbox (n, b) | n <- [1 .. 8] | b <- split x ]\n\nsbox : ([4], [6]) -> [4]\nsbox (n, x) = (s @ [b1, b6] @ [b2, b3, b4, b5])\n  where s = sboxes @ (n - 1)\n        b1 = x @ 0\n        b2 = x @ 1\n        b3 = x @ 2\n        b4 = x @ 3\n        b5 = x @ 4\n        b6 = x @ 5\n\n\/\/ here are all the SBoxes\n\nsboxes = [ sbox1, sbox2, sbox3, sbox4, sbox5, sbox6, sbox7, sbox8 ]\n\nsbox1 : [4][16][4]\nsbox1 = [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],\n         [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],\n         [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],\n         [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]\n        ]\nsbox2 : [4][16][4]\nsbox2 = [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],\n         [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],\n         [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],\n         [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]\n        ]\n\nsbox3 : [4][16][4]\nsbox3 = [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],\n         [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],\n         [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],\n         [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]\n        ]\n\nsbox4 : [4][16][4]\nsbox4 = [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],\n         [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],\n         [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],\n         [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]\n        ]\n\nsbox5 : [4][16][4]\nsbox5 = [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],\n         [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],\n         [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],\n         [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]\n        ]\n\nsbox6 : [4][16][4]\nsbox6 = [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],\n         [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],\n         [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],\n         [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]\n        ]\n\nsbox7 : [4][16][4]\nsbox7 = [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],\n         [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],\n         [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],\n         [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]\n        ]\n\nsbox8 : [4][16][4]\nsbox8 = [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],\n         [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],\n         [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],\n         [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]\n        ]\n\n\nproperty DESCorrect key msg = DES.decrypt key (DES.encrypt key msg) == msg\n\n\ntestmsgs = [0x1122334455667788\n           ,0x99aabbccddeeff00\n           ,0x41AD068548809D02\n           ,0xB10F843097A0F932]\n\ntestkeys = [0x752878397493CB70\n          ,0x752878397493CB70\n          ,0x0001020304050607\n          ,0x2BD6459F82C5B300]\n\ntestct = [0xB5219EE81AA7499D\n         ,0x2196687E13973856\n         ,0x0011223344556677\n         ,0xEA024714AD5C4D84]\n\nproperty testsPass = and [ DES.encrypt key msg == ct\n                         | key <- testkeys | msg <- testmsgs | ct <- testct ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/PRINCE.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the PRINCE block cipher implementation in the given module. Specifically, create properties that prove the decryption function is the inverse of the encryption function for all valid keys and plaintexts, ensuring that decrypt(encrypt(m)) == m holds universally. Additionally, write properties to check the correctness of key extension functions and the round transformations (SubCells, ShiftRows, defMPrime) to ensure they behave as intended. Use the existing property princeCorrect as a starting point and extend verification coverage to all core components of the cipher."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::PRINCE where\ntype princeBlockSize = 64\ntype princeKeySize = 128\ntype State = [4][4][4]\ntype Round = 4\n\n\/\/S-box\n\nsbox = [0xb, 0xf, 0x3, 0x2, 0xa, 0xc, 0x9, 0x1, 0x6, 0x7, 0x8, 0x0, 0xe, 0x5, 0xd, 0x4]\nsboxInv = [0xb, 0x7, 0x3, 0x2, 0xf, 0xd, 0x8, 0x9, 0xa, 0x6, 0x4, 0x0, 0x5, 0xe, 0xc, 0x1]\n\n\/\/ Round Constant (RC)\n\nRC = [0x0000000000000000, 0x13198a2e03707344, 0xa4093822299f31d0, 0x082efa98ec4e6c89, 0x452821e638d01377, 0xbe5466cf34e90c6c, 0x7ef84f78fd955cb1, 0x85840851f1ac43aa, 0xc882d32f25323c54, 0x64a51195e0e3610d, 0xd3b5a399ca0c2399, 0xc0ac29b7c97c50dd]\n\n\/\/Extend key to 192bits\n\nextendKey :[princeKeySize] -> ([64], [64], [64])\nextendKey key = (K!0, K', K!1) \n          where K = split key:[2][64]\n                K' = ((K!0) >>> 1) ^ ((K!0) >> 63)\n\/\/Message to state\n\nmsgToState:[princeBlockSize] -> State\nmsgToState msg = split (split msg)\n\nstateToMsg :State -> [princeBlockSize]\nstateToMsg st = join (join st)\n\n\/\/Substitute Sbox\n\nSubCell :[4] -> [4]\nSubCell st = sbox@st\n\nSubCells : State -> State\nSubCells st = [ [ SubCell b | b<- row ] | row <- st ]\n\n\/\/Substitute Inverse Sbox\n\nInvSubCell :[4] -> [4]\nInvSubCell st = sboxInv@st\n\nInvSubCells : State -> State\nInvSubCells st = [ [ InvSubCell b | b<- row ] | row <- st ]\n\n\/\/Shift Rows\nperm  = [0x0, 0x5, 0xa, 0xf, 0x4, 0x9, 0xe, 0x3, 0x8, 0xd, 0x2, 0x7, 0xc, 0x1, 0x6, 0xb]\ninv_perm = [0x0, 0xd, 0xa, 0x7, 0x4, 0x1, 0xe, 0xb, 0x8, 0x5, 0x2, 0xf, 0xc,0x9, 0x6, 0x3]\n\nShiftRows : State -> State\nShiftRows state = split [State_16@i\n                  | i <-  perm]\n                where State_16 = join state\nInvShiftRows : State -> State\nInvShiftRows state = split [State_16@i\n                  | i <-  inv_perm]\n                where State_16 = join state\n\n\/\/ Linear Layer\n\nm0 = [ 0x0, 0x4, 0x2, 0x1]\nm1 = [ 0x8, 0x0, 0x2, 0x1]\nm2 = [ 0x8, 0x4, 0x0, 0x1]\nm3 = [ 0x8, 0x4, 0x2, 0x0]\n\nM0 = [ [m0, m1, m2, m3], [m1, m2, m3, m0], [m2, m3, m0, m1], [m3, m0, m1, m2] ]\nM1 = [ [m1, m2, m3, m0], [m2, m3, m0, m1], [m3, m0, m1, m2], [m0, m1, m2, m3] ]\n\nM' = [ M0, M1, M1, M0]\n\n\n\/\/ m0\n\ndefm1 : [16] -> [16]\ndefm1 st = res \n where  res = b15 # b14 # b13 # b12 # b11 # b10 # b9 # b8 # b7 # b6 # b5 # b4 # b3 # b2 # b1 # b0\n        b0 = [st!4 ^ st!8 ^ st!12]\n        b1 = [st!1 ^ st!9 ^ st!13]\n        b2 = [st!2 ^ st!6 ^ st!14]\n        b3 = [st!3 ^ st!7 ^ st!11]\n        b4 = [st!0 ^ st!4 ^ st!8]\n        b5 = [st!5 ^ st!9 ^ st!13]\n        b6 = [st!2 ^ st!10 ^ st!14]\n        b7 = [st!3 ^ st!7 ^ st!15]\n        b8 = [st!0 ^ st!4 ^ st!12]\n        b9 = [st!1 ^ st!5 ^ st!9]\n        b10 = [st!6 ^ st!10 ^ st!14]\n        b11 = [st!3 ^ st!11 ^ st!15]\n        b12 = [st!0 ^ st!8 ^ st!12]\n        b13 = [st!1 ^ st!5 ^ st!13]\n        b14 = [st!2 ^ st!6 ^ st!10]\n        b15 = [st!7 ^ st!11 ^ st!15]\n\n\/\/ m1\n\ndefm0 : [16] -> [16]\ndefm0 st = res\n  where res = b15 # b14 # b13 # b12 # b11 # b10 # b9 # b8 # b7 # b6 # b5 # b4 # b3 # b2 # b1 # b0\n        b0 = [st!0 ^ st!4 ^ st!8]\n        b1 = [st!5 ^ st!9 ^ st!13]\n        b2 = [st!2 ^ st!10 ^ st!14]\n        b3 = [st!3 ^ st!7 ^ st!15]\n        b4 = [st!0 ^ st!4 ^ st!12]\n        b5 = [st!1 ^ st!5 ^ st!9]\n        b6 = [st!6 ^ st!10 ^ st!14]\n        b7 = [st!3 ^ st!11 ^ st!15]\n        b8 = [st!0 ^ st!8 ^ st!12]\n        b9 = [st!1 ^ st!5 ^ st!13]\n        b10 = [st!2 ^ st!6 ^ st!10]\n        b11 = [st!7 ^ st!11 ^ st!15]\n        b12 = [st!4 ^ st!8 ^ st!12]\n        b13 = [st!1 ^ st!9 ^ st!13]\n        b14 = [st!2 ^ st!6 ^ st!14]\n        b15 = [st!3 ^ st!7 ^ st!11]\n\n\/\/ M'\n\ndefMPrime: State -> State\ndefMPrime st = [rt3] # [rt2] # [rt1] # [rt0]\n      where rt0 = split (defm0 (join (st!0))):[4][4]\n            rt1 = split (defm1 (join (st!1))):[4][4]\n            rt2 = split (defm1 (join (st!2))):[4][4]\n            rt3 = split (defm0 (join (st!3))):[4][4]\n\n\n\/\/ first rounds\nfirstRounds : State -> State -> [Round] -> State\nfirstRounds pt key r = res\n           where   pt' =  SubCells(pt)\n                   pt'' = defMPrime (pt')\n                   pt''' = ShiftRows (pt'')\n                   res = pt''' ^ (split (split (RC@r))) ^ key\n                   \n\/\/ last rounds\n\nlastRounds : State -> State -> [Round] -> State\nlastRounds pt key r = res\n           where   pt' =  pt ^ key ^ (split (split (RC@r)))\n                   pt'' = InvShiftRows( pt')\n                   pt''' = defMPrime (pt'')\n                   res = InvSubCells (pt''')\n\nprinceCore : State -> State -> State\nprinceCore pt key  = addRC11\n           where addRC0 = pt ^ key ^ (split (split (RC@0)))\n                 firstR = [(firstRounds addRC0 key 1)] # [ (firstRounds res key i)\n                                                         | i <- [2,3..5]\n                                                         | res <- firstR\n                                                         ]\n                 subSbox = SubCells (firstR!0)\n                 linLayer = defMPrime (subSbox)\n                 subInvSbox = InvSubCells (linLayer)\n                 lastR = [(lastRounds subInvSbox  key 6) ] # [ (lastRounds res key i)\n                                                             | i <- [7,8..10]\n                                                             | res <- lastR\n                                                             ]\n                 addRC11 = (lastR!0) ^ key^ (split (split (RC@11)))\n                 \n\n\nprinceEncrypt : ([princeKeySize], [princeBlockSize]) -> [princeBlockSize]\nprinceEncrypt (key, pt) =  stateToMsg postWhiten\n            where  extk = extendKey (key)\n                   preWhiten = msgToState(pt) ^ msgToState (extk.0)\n                   coreEnc =  (princeCore preWhiten (msgToState (extk.2)))\n                   postWhiten = coreEnc ^ (msgToState (extk.1))\n\/\/Extend key to 192bits\n\nextendKeyDec :[princeKeySize] -> ([64], [64], [64])\nextendKeyDec key = (K', K!0, K!1) \n          where K = split key:[2][64]\n                K' = ((K!0) >>> 1) ^ ((K!0) >> 63)\n\n\/\/ Decryption\n\nprinceDecrypt : ([princeKeySize], [princeBlockSize]) -> [princeBlockSize]\nprinceDecrypt ( key, ct) = stateToMsg postWhiten\n            where alpha_padd = join((split(key):[32][4])^ (split (0xc0ac29b7c97c50dd0000000000000000):[32][4]))\n                  extk = extendKeyDec alpha_padd \n                  preWhiten = msgToState(ct) ^ msgToState (extk.0)\n                  coreEnc =  (princeCore preWhiten (msgToState (extk.2)))\n                  postWhiten = coreEnc ^ (msgToState (extk.1))\n\n\/\/correctness\n\nproperty princeCorrect key m = princeDecrypt ( key, princeEncrypt(key, m)) == m\n\n\/\/Helper functions to run the experiments\n\nprinceEncrypt64 : ([princeBlockSize], [princeBlockSize]) -> [princeBlockSize]\nprinceEncrypt64 (key, pt) = princeEncrypt(key#zero, pt)\n\nprinceDecrypt64 : ([princeBlockSize], [princeBlockSize]) -> [princeBlockSize]\nprinceDecrypt64 (key, ct) = princeDecrypt(key#zero, ct)\n\nproperty princeCorrect' key m = princeDecrypt64 (key, princeEncrypt64 (key, m)) == m\n\nprinceEncrypt128 : ([princeKeySize], [princeKeySize]) -> [princeKeySize]\nprinceEncrypt128 (key, pt) = princeEncrypt(key, (take`{64} pt))# zero\n\n\/\/ Testing\n\ntests = [t01, t02, t03, t04, t05, t06, t07]\nproperty testsPass = and tests\n\nt01 = princeEncrypt (zero, zero) == 0x818665aa0d02dfda\n\nt02 = princeEncrypt (zero, 0xffffffffffffffff) == 0x604ae6ca03c20ada\n\nt03 = princeEncrypt ( 0xffffffffffffffff0000000000000000, zero) == 0x78a54cbe737bb7ef\n\nt04 = princeEncrypt (0xffffffffffffffffffffffffffffffff, zero) == 0xb9f952807615743f\n\nt05 = princeEncrypt (0x0000000000000000ffffffffffffffff, zero) == 0x9fb51935fc3df524\n\nt06 = princeEncrypt (0x0000000000000000fedcba9876543210, 0x0123456789abcdef) == 0x1f24bb8638e813d3\n\nt07 = princeEncrypt (0xfedcba98765432100000000000000000, 0x0123456789abcdef) == 0xae25ad3ca8fa9ccf\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES_parameterized.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the AES parameterized encryption and decryption functions are inverses of each other for all valid keys and plaintexts. Include properties that check the correctness of key expansion for both encryption and decryption keys, and ensure that the encryption with the expanded key schedule followed by decryption returns the original plaintext."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES_parameterized where\n\nimport `Primitive::Symmetric::Cipher::Block::AES::Algorithm as AES\nimport `Primitive::Symmetric::Cipher::Block::AES::ExpandKey\nimport Primitive::Symmetric::Cipher::Block::AES::TBox\n\ntype constraint ValidKey k m = (k == 128 + m * 64, 2 >= m)\n\ntype EncKey m = AES::KeySchedule m\ntype DecKey m = AES::KeySchedule m\n\n\nencrypt : {k,m} ValidKey k m => [k] -> [128] -> [128]\nencrypt k = encryptWithSchedule (expandKeyEnc k)\n\ndecrypt : {k,m} ValidKey k m => [k] -> [128] -> [128]\ndecrypt k = decryptWithSchedule (expandKeyDec k)\n\n\nexpandKeyEnc : {k,m} ValidKey k m => [k] -> EncKey m\nexpandKeyEnc = expandKey`{Nk = AES::Nk m, Nr = AES::Nr m}\n\nencryptWithSchedule : {k,m} ValidKey k m => EncKey m -> [128] -> [128]\nencryptWithSchedule = AES::encrypt params\n\n\n\nexpandKeyDec : {k,m} ValidKey k m => [k] -> EncKey m\nexpandKeyDec k = makeDecKey (expandKey`{Nk = AES::Nk m, Nr = AES::Nr m} k)\n\ndecryptWithSchedule : {k,m} ValidKey k m => DecKey m -> [128] -> [128]\ndecryptWithSchedule = AES::decrypt params\n\n\nparams = { encRound = AESRound, decRound = AESInvRound }\n\nproperty test k pt = decrypt k (encrypt k pt) == pt\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AESKeyWrapPadded.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the aesWrapKeyPadded and aesUnwrapKeyPadded functions according to RFC 5649. Include properties that check the integrity of the padding, the correctness of the wrapping and unwrapping process (i.e., unwrapping a wrapped key returns the original plaintext and passes integrity checks), and boundary conditions for input sizes and padding. Ensure the properties cover both the ECB mode fallback for short inputs and the standard key wrap algorithm for longer inputs."},{"role":"assistant","content":"```cryptol\n\/\/ This is a close implementation of RFC 5649:\n\/\/ https:\/\/tools.ietf.org\/html\/rfc5649\n\nmodule Primitive::Symmetric::Cipher::Block::AESKeyWrapPadded where\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Block::AESKeyWrap\n\n\/\/ Most significant bits of alternate initial value (Section 3)\nAlternativeIV : [4][8]\nAlternativeIV = [0xA6, 0x59, 0x59, 0xA6]\n\n\/\/ Pad a plaintext out to the nearest 8 bytes\npadPlaintext : {n, m} (fin n, (n+m) % 8 == 0, m <= 7) => [n][8] -> [n + m][8]\npadPlaintext p = p # zero\n\n\/\/ Wrap `plaintext` using `key` as the encryption key.  `iv` is the most\n\/\/ significant 4 bytes of the alternative initial value (see Section 3 of\n\/\/ RFC 5649).  This function implements the algorithm from Section 4.1.\naesWrapKeyPadded : {n, m} (n >= 1 , n < 2^^32 , (n+m) % 8 == 0 , m <= 7) =>\n                   [AESKeySize] -> [4][8] -> [n][8] -> [n+m+8][8]\naesWrapKeyPadded key iv plaintext =\n  if `n <= 8\n  \/\/ If padded plaintext is 8 bytes, encrypt in AEC ECB mode.  The `drop` and\n  \/\/ append of `zero` have no effect at runtime and exist to make the types\n  \/\/ work out, as the type checker cannot deduce that `n <= 8` in this branch.\n  then (split (aesEncrypt (drop (join (AIV # P)), key))) # zero\n  \/\/ Otherwise perform standard key wrap algorithm on padded plaintext.  The\n  \/\/ `drop` and append of `zero` have runtime effect and exist to make the\n  \/\/ types work out, as the type checker cannot deduce that `n >= 16` in this\n  \/\/ branch.\n  else drop (aesWrapKey key AIV ((P # zero) : [max 16 (n+m)][8]))\n  where\n    \/\/ Append padding\n    P = padPlaintext`{n, m} plaintext\n    \/\/ Compute alternative initial value\n    AIV = iv # (split`{4,8} (`n : [32]))\n\n\/\/ Unwrap `ciphertext` using `key` as the key encryption key.  `iv` is most\n\/\/ significant 4 bytes of the expected initial value.  This function implements\n\/\/ the algorithm from Section 4.2.  It also performs the integrity check from\n\/\/ Section 3.  This function returns a tuple where the first element indicates\n\/\/ whether or not the integrity check passed (`True` indicates the check\n\/\/ passed), the second element is the size of the plaintext, and the final\n\/\/ element is the decrypted plaintext with the added padding.  The caller of\n\/\/ the function must remove this padding themselves.  If the integrity check\n\/\/ fails, the second and third elements will be zeros.\naesUnwrapKeyPadded : {n} (fin n, n >= 16, n % 8 == 0, width n <= 32) =>\n                     [AESKeySize] -> [4][8] -> [n][8] -> (Bit, [4][8], [n-8][8])\naesUnwrapKeyPadded key iv ciphertext = if valid\n                                       then (True, size, P)\n                                       else (False, zero, zero)\n  where\n    S : [n][8]\n    S = if `n == 16\n        \/\/ If the cipher text is 16 bytes, decrypt in AES ECB mode.  The `drop`\n        \/\/ and append of `zero` have no effect at runtime and exist to make the\n        \/\/ types work out, as the type checker cannot deduce that `n == 16` in\n        \/\/ this branch.\n        then (split (aesDecrypt (drop (join ciphertext), key))) # zero\n        \/\/ Otherwise perform the standard key unwrap algorithm.  The `drop`\n        \/\/ and append of `zero` have no effect at runtime and exist to make the\n        \/\/ types work out, as the type checker cannot deduce that `n >= 24` in\n        \/\/ this branch.\n        else drop (split`{each=8} (join (([A'] # R'))))\n          where\n            (A', R') = aesUnwrapKeyUnchecked key ((ciphertext # zero) : [max 24 n][8])\n    \/\/ Break decrypted ciphertext into the most significant 4 bytes of the IV,\n    \/\/ the size of the plaintext without padding, and the plaintext with\n    \/\/ padding\n    iv' : [4][8]\n    size : [4][8]\n    P : [n-8][8]\n    iv' # size # P = S\n        valid =\n      \/\/ Most significant bytes of IV should match `iv`\n      (iv' == iv) &&\n      \/\/ n - 16 < size <= n - 8\n      (((`n : [32]) - 16) < (join size)) &&\n      ((join size) <= ((`n : [32]) - 8)) &&\n      \/\/ All bytes of the padding must be zeros\n      and [(i < (join size)) || (x == zero) | x <- P | i <- [0...]]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/LED.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the LED block cipher encryption functions ledEncrypt64 and ledEncrypt128 against their specified test vectors. Include properties that check the encryption output for given keys and plaintexts matches the expected ciphertexts, and verify the internal round transformations preserve expected invariants such as invertibility or consistency with the S-box and MixColumns operations."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::LED where\n\ntype GF24 = [4]\ntype State = [4][4]GF24\ntype LEDKeySize64 = 64\ntype LEDKeySize128 = 128\ntype LEDBlockSize = 64\n\/\/ Number of rounds 32 for 64, 48 for 128\ntype Rn = [6]\ntype steps = 8 \n\/\/type steps = 12\n\/\/ Number of rounds\ntype Nr = steps*4\n\n\/\/Number of steps\ntype Ns = 8\n\n\/\/ GF24 operations\n\ngf24Add : {n} (fin n) => [n]GF24 -> GF24\ngf24Add ps = sums ! 0\n      where sums = [zero] # [p^s | p <- ps | s <- sums]\nirreducible = <| x^^4 + x + 1 |>\n\n\/\/ Polynomial multiplication in GF24\n\ngf24Mult : (GF24, GF24) -> GF24\ngf24Mult (x , y) = pmod (pmult x y) irreducible\n\n\/\/ Define a power of an element in GF24\n\ngf24Pow : (GF24, [4]) -> GF24\ngf24Pow (n , k) = pow k\n        where sq x = gf24Mult (x, x)\n              odd x = x ! 0\n              pow i = if i == 0 then 1\n                      else if odd i\n                           then gf24Mult(n, sq (pow (i >> 1)))\n                           else sq (pow (i >> 1))\n\n\/\/ self adding gives zero\n\npolySelfAdd' : GF24 -> Bit\nproperty polySelfAdd' x = x ^ x == zero\n\n\n\/\/ Inverse of an element in GF24\n\ngf24Inverse : GF24 -> GF24\ngf24Inverse x = gf24Pow (x, 14)\n\n\/\/Dot product in GF24\n\ngf24DotProduct : {n} (fin n) => ([n]GF24, [n]GF24) -> GF24\ngf24DotProduct  (xs, ys) = gf24Add [ gf24Mult (x, y) | x <- xs\n                                                     | y <- ys ]\n\n\/\/ Vector Multiplication\n\ngf24VectorMult : {n, m} (fin n) => ([n]GF24, [m][n]GF24) -> [m]GF24\ngf24VectorMult (v, ms) = [ gf24DotProduct(v, m) | m <- ms ]\n\n\/\/ Matrix Multiplication\n\ngf24MatrixMult : {n, m, k} (fin m) => ([n][m]GF24, [m][k]GF24) -> [n][k]GF24\ngf24MatrixMult (xss, yss) = [ gf24VectorMult(xs, yss') | xs <- xss ]\n   where yss' = transpose yss\n                                                       \n\n\/\/ LED re-uses PRESENT Sbox\n\nsbox : [16] GF24\n\nsbox = [0xc, 0x5, 0x6, 0xb, 0x9, 0x0, 0xa, 0xd, 0x3, 0xe, 0xf, 0x8, 0x4, 0x7, 0x1, 0x2]\n\n\/\/arrange_pt : [64]Bit -> [4][4]GF24\n\n\/\/Converting a 64-bit message to a State and back\n\nmsgToState : [64] -> State\nmsgToState msg = split (split msg)\n\nstateToMsg : State -> [64]\nstateToMsg st = join (join st)\n\n\/\/ Split key (128-bits) in to two matrices of size 64 each\nsplitKey1 : [128] -> State\nsplitKey1  key =  msgToState(seed@0)\n          where seed : [2][64]\n                seed = split(key)\n\n\nsplitKey2 : [128] -> State\nsplitKey2  key =  msgToState(seed@1)\n          where seed : [2][64]\n                seed = split(key)\n          \n\nAddRoundKey: (State, State) -> State\nAddRoundKey (rk , s) = rk^s\n\n\/\/ Each round has the follwoing transformations\n\n\/\/round constants for 48-rounds\n\nrcTab : [48][8]\nrcTab = [0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3E, \n                    0x3D, 0x3B, 0x37, 0x2F, 0x1E, 0x3C, 0x39,\n                    0x33, 0x27, 0x0E, 0x1D, 0x3A, 0x35, 0x2B,\n                    0x16, 0x2C, 0x18, 0x30, 0x21, 0x02, 0x05,\n                    0x0B, 0x17, 0x2E, 0x1C, 0x38, 0x31, 0x23,\n                    0x06, 0x0D, 0x1B, 0x36, 0x2D, 0x1A, 0x34,\n                    0x29, 0x12, 0x24, 0x08, 0x11, 0x22, 0x04]\n\n      \n\/\/ Define a matrix to add in each round\n\naddConst64 : Rn -> State\naddConst128 : Rn -> State\n\/* addconst function for 128bit key size *\/\n\/\/uncomment this for 128bit key size\n\naddConst128 rn  = [[ 8, rcpad(rcTab, rn, [5, 4, 3]) , 0, 0], [9, rcpad(rcTab, rn, [2, 1, 0]) , 0, 0], [2, rcpad(rcTab, rn, [5, 4, 3]), 0, 0], [3, rcpad(rcTab, rn, [2, 1, 0]), 0, 0]] \n\n\/* addconst function for 64bit key size *\/\n\/\/uncomment this for 64bit key size\n\naddConst64 rn  =[[ 4, rcpad(rcTab, rn, [5, 4, 3]) , 0, 0], [5, rcpad(rcTab, rn, [2, 1, 0]) , 0, 0], [2, rcpad(rcTab, rn, [5, 4, 3]), 0, 0], [3, rcpad(rcTab, rn, [2, 1, 0]), 0, 0]] \n\n\n\/\/padding (rc5||rc4||rc3) or (rc2||rc1||rc0)\n\nrcpad : ([48][8], Rn, [3][3]) -> GF24\nrcpad (rct, rn, indcs) = (0b0 # ((rct @ rn):[8]) !! indcs)\n\n\/\/ Add constatns\n\nAddConst64 : (Rn, State) -> State\nAddConst64 (rn, st) = st ^ (addConst64 rn)\n\nAddConst128 : (Rn, State) -> State\nAddConst128 (rn, st) = st ^ (addConst128 rn)\n                    \n\/\/Each nibble in the array state is replaced with PRESENT Sbox\n\nSubCell : GF24 -> GF24\nSubCell b = sbox @ b\n\nSubCells : State -> State\nSubCells state = [ [SubCell b | b <- row] | row <- state]\n\nShiftRows : State -> State\nShiftRows state = [ row <<< shiftAmount | row <- state\n                                        | shiftAmount <- [0..3]\n                  ]\n\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> shiftAmount | row <- state\n                                           | shiftAmount <- [0 .. 3]\n                     ]\nMDS : State\n\nMDS = [ [ 0x4, 0x1, 0x2, 0x2],\n            [ 0x8, 0x6, 0x5, 0x6],\n            [ 0xB, 0xE, 0xA, 0x9],\n            [ 0x2, 0x2, 0xF, 0xB] ]\n\n\/\/ Replace each column vector v of state S by MDS.v\n\nMixColumns : State -> State\nMixColumns state = transpose [gf24VectorMult (row, MDS)| row <- state']\n           where state' = transpose state\n\n\/\/ ONE Round\n\nroundXform64 : (Rn, State) -> State\nroundXform64 (rn, st) = MixColumns (ShiftRows( SubCells (AddConst64 (rn, st))))\n\n\n\/\/four rounds\n\nfourRoundXform64 : ([6], State) -> State\nfourRoundXform64 (stp, st) = roundXform64 ((4*stp+3), (roundXform64 ((4*stp+2), (roundXform64 ((4*stp+1), (roundXform64 ((4*stp+0), st)))))))\n\n\/\/ ONE Round\n\nroundXform128 : (Rn, State) -> State\nroundXform128 (rn, st) = MixColumns (ShiftRows( SubCells (AddConst128 (rn, st))))\n\n\n\/\/four rounds\n\nfourRoundXform128 : ([6], State) -> State\nfourRoundXform128 (stp, st) = roundXform128 ((4*stp+3), (roundXform128 ((4*stp+2), (roundXform128 ((4*stp+1), (roundXform128 ((4*stp+0), st)))))))\n\n\n\/\/ LED Encryption\n                       \n\/\/Encryption with the keysize of 64bits\n\nledEncrypt64 : ([LEDKeySize64], [LEDBlockSize])  -> [LEDBlockSize]\nledEncrypt64 (key, pt) = stateToMsg(addrk8)\n              where pt_st = msgToState(pt)\n                    key_st1 =  msgToState(key)\n                    key_st2 = msgToState(key)\n                    addrk0 = (AddRoundKey(pt_st, key_st1))\n                    step0 = (fourRoundXform64 (0, addrk0))        \n                    addrk1 = (AddRoundKey(step0, key_st2))\n                    step1 = (fourRoundXform64 (1, addrk1))\n                    addrk2 = (AddRoundKey(step1, key_st1))\n                    step2 = (fourRoundXform64 (2, addrk2))\n                    addrk3 = (AddRoundKey(step2, key_st2))\n                    step3 = (fourRoundXform64 (3, addrk3))\n                    addrk4 = (AddRoundKey(step3, key_st1))\n                    step4 = (fourRoundXform64 (4, addrk4))\n                    addrk5 = (AddRoundKey(step4, key_st2))\n                    step5 = (fourRoundXform64 (5, addrk5))\n                    addrk6 = (AddRoundKey(step5, key_st1))\n                    step6 = (fourRoundXform64 (6, addrk6))\n                    addrk7 = (AddRoundKey(step6, key_st2))\n                    step7 = (fourRoundXform64 (7, addrk7))\n                    addrk8 = (AddRoundKey(step7, key_st1))\n\n                   \n\/\/ Encryption with the keysize of 128bits\n\nledEncrypt128 : ([LEDKeySize128], [LEDBlockSize])  -> [LEDBlockSize]\nledEncrypt128 ( key, pt) = stateToMsg(addrk12)\n              where pt_st = msgToState(pt)\n                    \/* splitting the key in two with 64bits each*\/\n                    key_st1 = splitKey1(key)\n                    key_st2 = splitKey2(key)\n                    addrk0 = (AddRoundKey(pt_st, key_st1))\n                    step0 = (fourRoundXform128 (0, addrk0))        \n                    addrk1 = (AddRoundKey(step0, key_st2))\n                    step1 = (fourRoundXform128 (1, addrk1))\n                    addrk2 = (AddRoundKey(step1, key_st1))\n                    step2 = (fourRoundXform128 (2, addrk2))\n                    addrk3 = (AddRoundKey(step2, key_st2))\n                    step3 = (fourRoundXform128 (3, addrk3))\n                    addrk4 = (AddRoundKey(step3, key_st1))\n                    step4 = (fourRoundXform128 (4, addrk4))\n                    addrk5 = (AddRoundKey(step4, key_st2))\n                    step5 = (fourRoundXform128 (5, addrk5))\n                    addrk6 = (AddRoundKey(step5, key_st1))\n                    step6 = (fourRoundXform128 (6, addrk6))\n                    addrk7 = (AddRoundKey(step6, key_st2))\n                    step7 = (fourRoundXform128 (7, addrk7))\n                    addrk8 = (AddRoundKey(step7, key_st1))\n                    step8 = (fourRoundXform128 (8, addrk8))\n                    addrk9 = (AddRoundKey(step8, key_st2))\n                    step9 = (fourRoundXform128 (9, addrk9))\n                    addrk10 = (AddRoundKey(step9, key_st1))\n                    step10 = (fourRoundXform128 (10, addrk10))\n                    addrk11 = (AddRoundKey(step10, key_st2))\n                    step11 = (fourRoundXform128 (11, addrk11))\n                    addrk12 = (AddRoundKey(step11, key_st1))\n\n\/\/ Helper to run the experiments\n\n\nledEncrypt64' : ([LEDBlockSize], [LEDBlockSize]) -> [LEDBlockSize]\nledEncrypt64' (key, pt) = ledEncrypt128 (key#zero, pt)\n\nledEncrypt128' : ([LEDKeySize128], [LEDKeySize128]) -> [LEDKeySize128]\nledEncrypt128' (key, pt) = ledEncrypt128(key, (take`{64} pt))# zero\n\n\n\/\/ Testing\n\ntests = [test64_1, test64_2, test128_1, test128_2]\nproperty testsPass = and tests\n\n\/\/Keysize: 64bits\n\nproperty test64_1  = ledEncrypt64 (zero, zero) == 0x39c2401003a0c798\nproperty test64_2 = ledEncrypt64 (0x0123456789abcdef, 0x0123456789abcdef) == 0xa003551e3893fc58\n\n\/\/keysize: 128bits\n\nproperty test128_1 = ledEncrypt128 (zero, zero) == 0x3decb2a0850cdba1\nproperty test128_2 = ledEncrypt128 (0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0xd6b824587f014fc2\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/simon.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that for each Simon cipher variant defined in the module (e.g., Simon32_64, Simon64_96, Simon128_256), the decryption function is the inverse of the encryption function, i.e., decrypting an encrypted plaintext with the same key returns the original plaintext. Additionally, specify properties to ensure the uniqueness of the key expansion function for different keys, confirming that different keys produce different expanded keys."},{"role":"assistant","content":"```cryptol\n\/* Cryptol specification of the Simon block cipher\n * Author: David Lazar\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::simon where\n\nSimon32_64    = encrypt `{n=16,m=4,T=32,j=0}\nSimon48_72    = encrypt `{n=24,m=3,T=36,j=0}\nSimon48_96    = encrypt `{n=24,m=4,T=36,j=1}\nSimon64_96    = encrypt `{n=32,m=3,T=42,j=2}\nSimon64_128   = encrypt `{n=32,m=4,T=44,j=3}\nSimon96_96    = encrypt `{n=48,m=2,T=52,j=2}\nSimon96_144   = encrypt `{n=48,m=3,T=54,j=3}\nSimon128_128  = encrypt `{n=64,m=2,T=68,j=2}\nSimon128_192  = encrypt `{n=64,m=3,T=69,j=3}\nSimon128_256  = encrypt `{n=64,m=4,T=72,j=4}\n\nSimon32_64'   = decrypt `{n=16,m=4,T=32,j=0}\nSimon48_72'   = decrypt `{n=24,m=3,T=36,j=0}\nSimon48_96'   = decrypt `{n=24,m=4,T=36,j=1}\nSimon64_96'   = decrypt `{n=32,m=3,T=42,j=2}\nSimon64_128'  = decrypt `{n=32,m=4,T=44,j=3}\nSimon96_96'   = decrypt `{n=48,m=2,T=52,j=2}\nSimon96_144'  = decrypt `{n=48,m=3,T=54,j=3}\nSimon128_128' = decrypt `{n=64,m=2,T=68,j=2}\nSimon128_192' = decrypt `{n=64,m=3,T=69,j=3}\nSimon128_256' = decrypt `{n=64,m=4,T=72,j=4}\n\nproperty correctSimon32_64 k b   = Simon32_64' k (Simon32_64 k b) == b\nproperty correctSimon64_96 k b   = Simon64_96' k (Simon64_96 k b) == b\nproperty correctSimon96_144 k b  = Simon96_144' k (Simon96_144 k b) == b\nproperty correctSimon128_128 k b = Simon128_128' k (Simon128_128 k b) == b\nproperty correctSimon128_256 k b = Simon128_256' k (Simon128_256 k b) == b\n\nproperty uniqueExpandSimon32_64 k1 k2 = (k1 == k2) || (expandKey `{n=16,m=4,T=32,j=0} k1 != expandKey `{n=16,m=4,T=32,j=0} k2)\nproperty uniqueExpandSimon48_72 k1 k2 = (k1 == k2) || (expandKey `{n=24,m=3,T=36,j=0} k1 != expandKey `{n=24,m=3,T=36,j=0} k2)\nproperty uniqueExpandSimon48_96 k1 k2 = (k1 == k2) || (expandKey `{n=24,m=4,T=36,j=1} k1 != expandKey `{n=24,m=4,T=36,j=1} k2)\nproperty uniqueExpandSimon64_96 k1 k2 = (k1 == k2) || (expandKey `{n=32,m=3,T=42,j=2} k1 != expandKey `{n=32,m=3,T=42,j=2} k2)\nproperty uniqueExpandSimon64_128 k1 k2 = (k1 == k2) || (expandKey `{n=32,m=4,T=44,j=3} k1 != expandKey `{n=32,m=4,T=44,j=3} k2)\nproperty uniqueExpandSimon96_96 k1 k2 = (k1 == k2) || (expandKey `{n=48,m=2,T=52,j=2} k1 != expandKey `{n=48,m=2,T=52,j=2} k2)\nproperty uniqueExpandSimon96_144 k1 k2 = (k1 == k2) || (expandKey `{n=48,m=3,T=54,j=3} k1 != expandKey `{n=48,m=3,T=54,j=3} k2)\nproperty uniqueExpandSimon128_128 k1 k2 = (k1 == k2) || (expandKey `{n=64,m=2,T=68,j=2} k1 != expandKey `{n=64,m=2,T=68,j=2} k2)\nproperty uniqueExpandSimon128_192 k1 k2 = (k1 == k2) || (expandKey `{n=64,m=3,T=69,j=3} k1 != expandKey `{n=64,m=3,T=69,j=3} k2)\nproperty uniqueExpandSimon128_256 k1 k2 = (k1 == k2) || (expandKey `{n=64,m=4,T=72,j=4} k1 != expandKey `{n=64,m=4,T=72,j=4} k2)\n\n\/\/ A weak key theorem would look something like:\n\/\/ :prove exists (\\k1 -> exists (\\k2 -> forall (\\x -> Simon32_64 k1 (Simon32_64 k2 x) != x)))\n\n\nR k (x, y) = (y ^ f x ^ k, x)\n\n\/\/ inverse\nR' k (x, y) = (y, x ^ f y ^ k)\n\nf x = ((x <<< 1) && (x <<< 8)) ^ (x <<< 2)\n\n\nencrypt : {n, m, T, j}\n    ( fin n, fin m, fin T, fin j\n    , n >= 2, 4 >= m, T >= 4, T-1 >= m\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\nencrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [ R k b | b <- bs | k <- ks ]\n    ks = expandKey `{n=n,m=m,T=T,j=j} (reverse k0)\n\ndecrypt : {n, m, T, j}\n    ( fin n, fin m, fin T, fin j\n    , n >= 2, 4 >= m, T >= 4, T-1 >= m\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\ndecrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [ R' k b | b <- bs | k <- reverse ks ]\n    ks = expandKey `{n=n,m=m,T=T,j=j} (reverse k0)\n\n\nexpandKey : {n, m, T, j}\n    ( fin n, fin m, fin T, fin j\n    , n >= 2, 4 >= m, T >= 4, T-1 >= m\n    ) => [m][n] -> [T][n]\nexpandKey k0 = k\n  where\n    k = k0 # [ r where\n                    o = k @ (i - 1) >>> 3\n                    p = if `m == 4 then o ^ k @ (i - 3) else o\n                    q = p ^ p >>> 1\n                    r = ~ k @ (i - `m) ^ q ^ z ^ 3\n                    z = Z @ `j @ ((i - `m) % 62)\n             | i <- [m .. T - 1]\n             ]\n\nZ = [[1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0,\n      0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1,\n      0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0],\n     [1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0,\n      0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1,\n      0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0],\n     [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,\n      0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1,\n      1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1],\n     [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1,\n      0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0,\n      0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1],\n     [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1,\n      1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1,\n      0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1]]\n\ntests = [t01,t02,t03,t04,t05,t06,t07,t08,t09]\nproperty testsPass = and tests\n\nt00 = Simon32_64   [0x1918, 0x1110, 0x0908, 0x0100] (0x6565, 0x6877) == (0xc69b, 0xe9bb)\nt01 = Simon48_72   [0x121110, 0x0a0908, 0x020100] (0x612067, 0x6e696c) == (0xdae5ac, 0x292cac)\nt02 = Simon48_96   [0x1a1918, 0x121110, 0x0a0908, 0x020100] (0x726963, 0x20646e) == (0x6e06a5, 0xacf156)\nt03 = Simon64_96   [0x13121110, 0x0b0a0908, 0x03020100] (0x6f722067, 0x6e696c63) == (0x5ca2e27f, 0x111a8fc8)\nt04 = Simon64_128  [0x1b1a1918, 0x13121110, 0x0b0a0908, 0x03020100] (0x656b696c, 0x20646e75) == (0x44c8fc20, 0xb9dfa07a)\nt05 = Simon96_96   [0x0d0c0b0a0908, 0x050403020100] (0x2072616c6c69, 0x702065687420) == (0x602807a462b4, 0x69063d8ff082)\nt06 = Simon96_144  [0x151413121110, 0x0d0c0b0a0908, 0x050403020100] (0x746168742074, 0x73756420666f) == (0xecad1c6c451e, 0x3f59c5db1ae9)\nt07 = Simon128_128 [0x0f0e0d0c0b0a0908, 0x0706050403020100] (0x6373656420737265, 0x6c6c657661727420) == (0x49681b1e1e54fe3f, 0x65aa832af84e0bbc)\nt08 = Simon128_192 [0x1716151413121110, 0x0f0e0d0c0b0a0908, 0x0706050403020100] (0x206572656874206e, 0x6568772065626972) == (0xc4ac61effcdc0d4f, 0x6c9c8d6e2597b85b)\nt09 = Simon128_256 [0x1f1e1d1c1b1a1918, 0x1716151413121110, 0x0f0e0d0c0b0a0908, 0x0706050403020100] (0x74206e69206d6f6f, 0x6d69732061207369) == (0x8d2b5579afc8a3a0, 0x3bf72a87efe7b868)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AESKeyWrap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the AES Key Wrap and Unwrap functions defined in the AESKeyWrap module, ensuring that wrapping followed by unwrapping returns the original plaintext key when using the default IV, and that the integrity check in aesUnwrapKey correctly detects tampered ciphertext."},{"role":"assistant","content":"```cryptol\n\/\/ This is a close implementation of RFC 3394:\n\/\/ https:\/\/tools.ietf.org\/html\/rfc3394\n\/\/ RFC 3394 provides two equivalent descriptions of AES Key Wrap, one using\n\/\/ shifting and the other using indexing.  This specification closely matches\n\/\/ the index-based algorithm description as that description is more similar\n\/\/ to the BoringSSL AES Key Wrap implementation.\n\nmodule Primitive::Symmetric::Cipher::Block::AESKeyWrap where\nimport Primitive::Symmetric::Cipher::Block::AES\n\n\/\/ Default intial value (Section 2.2.3)\nDefaultIV : [8][8]\nDefaultIV = [0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6]\n\n\/\/ Wrap `plaintext` using `key` as the key encryption key.  `iv` is the initial\n\/\/ value to use.  This function implements the algorithm from Section 2.2.1\n\/\/ using the index-based definition.\naesWrapKey : {n} (fin n, n >= 16, n % 8 == 0, width (n \/ 8) <= 64) =>\n             [AESKeySize] -> [8][8] -> [n][8] -> [n+8][8]\naesWrapKey key iv plaintext = split (join C)\n  where\n        A = join iv\n    R = split`{parts=n\/8, each=64} (join plaintext)\n        intermediates = [(A, R)] # [wrapRound key s j | s <- intermediates\n                                                  | j <- [0..5]]\n        (A', R') = intermediates ! 0\n    C = [A'] # R'\n\n\/\/ Unwrap `ciphertext` using `key` as the key encryption key.  `iv` is the\n\/\/ expected initial value.  This function implements the algorithm from Section\n\/\/ 2.2.2 using the index-based definition.  It also checks the key data\n\/\/ integrity using `iv` (Section 2.2.3).  This function returns a tuple where\n\/\/ the first element indicates  whether or not the integrity check passed\n\/\/ (`True` indicates the check passed), and the second element is the decrypted\n\/\/ plain text.  If the integrity check fails, the second element will be all\n\/\/ zeros.\naesUnwrapKey : {n} (fin n, n >= 24, n % 8 == 0, width (n \/ 8) <= 64) =>\n               [AESKeySize] -> [8][8] -> [n][8] -> (Bit, [n-8][8])\naesUnwrapKey key iv ciphertext = if (join iv) == A'\n                                 then (True, split (join R'))\n                                 else (False, zero)\n  where\n    (A', R') = aesUnwrapKeyUnchecked key ciphertext\n\n\/\/ This function performs steps 1 and 2 of the unwrap key algorithm from\n\/\/ Section 2.2.2 using the index-based definition.\naesUnwrapKeyUnchecked : {n} (fin n, n >= 24, n % 8 == 0, width (n \/ 8) <= 64) =>\n                        [AESKeySize] -> [n][8] -> ([64], [n\/8 - 1][64])\naesUnwrapKeyUnchecked key ciphertext = intermediates ! 0\n  where\n        A = join (take`{8} ciphertext)\n    R = split`{parts=(n-8)\/8, each=64} (join (drop`{8} ciphertext))\n    \/\/ Step 2: Compute intermediate values\n    intermediates = [(A, R)] # [unwrapRound key s j | s <- intermediates\n                                                    | j <- [5, 4 .. 0]]\n\nprivate\n    \/*\n   * This section contains helper functions for wrapping and unwrapping keys.\n   * These functions make use of the notation defined in Section 2.1 of\n   * RFC 3394.\n   *\/\n\n  \/\/ Body of inner loop of step 2 of key wrap algorithm (Section 2.2.1)\n  wrapBlock : {n} (fin n, width n <= 64) =>\n              [AESKeySize] -> ([64], [n][64]) -> [64] -> [64] -> ([64], [n][64])\n  wrapBlock key (A, R) j i = (A', R')\n    where B  = aesEncrypt (A # (R @ (i-1)), key)\n          A' = (take`{64} B) ^ (((`n : [64]) * j) + i)\n          R' = update R (i-1) (drop`{64} B)\n\n  \/\/ Body of inner loop of step 2 of key unwrap algorithm (Section 2.2.2)\n  unwrapBlock : {n} (fin n, width n <= 64) =>\n                [AESKeySize] -> ([64], [n][64]) -> [64] -> [64] -> ([64], [n][64])\n  unwrapBlock key (A, R) j i = (A', R')\n    where B  = aesDecrypt ((A ^ (((`n : [64]) * j) + i)) # (R @ (i-1)), key)\n          A' = take`{64} B\n          R' = update R (i-1) (drop`{64} B)\n\n  \/\/ A single round of the key wrap algorithm (Section 2.2.1, step 2)\n  wrapRound : {n} (fin n, n >= 1, width n <= 64) =>\n              [AESKeySize] -> ([64], [n][64]) -> [64] -> ([64], [n][64])\n  wrapRound key (A, R) j = wrappedBlocks ! 0\n    where wrappedBlocks = [(A, R)] # [wrapBlock key s j i | s <- wrappedBlocks\n                                                          | i <- [1..n]]\n\n  \/\/ A single round of the key unwrap algorithm (Section 2.2.2, step 2)\n  unwrapRound : {n} (fin n, n >= 1, width n <= 64) =>\n                [AESKeySize] -> ([64], [n][64]) -> [64] -> ([64], [n][64])\n  unwrapRound key (A, R) j = unwrappedBlocks ! 0\n    where unwrappedBlocks = [(A, R)] # [unwrapBlock key s j i | s <- unwrappedBlocks\n                                                              | i <- [n, n-1 .. 1]]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/speck.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that for each Speck cipher variant defined in the module, decrypting the ciphertext produced by encrypting a plaintext with the same key returns the original plaintext. Include properties for all Speck variants (e.g., Speck32_64, Speck64_96, Speck96_144, Speck128_128, Speck128_256). Also, write test cases that check the correctness of encryption outputs against the provided known ciphertext values for each variant."},{"role":"assistant","content":"```cryptol\n\/* Cryptol specification of the Speck block cipher\n * Author: David Lazar\n *\/\n\nmodule Primitive::Symmetric::Cipher::Block::speck where\n\nSpeck32_64    = encrypt`{n = 16, m = 4, T = 22}\nSpeck48_72    = encrypt`{n = 24, m = 3, T = 22}\nSpeck48_96    = encrypt`{n = 24, m = 4, T = 23}\nSpeck64_96    = encrypt`{n = 32, m = 3, T = 26}\nSpeck64_128   = encrypt`{n = 32, m = 4, T = 27}\nSpeck96_96    = encrypt`{n = 48, m = 2, T = 28}\nSpeck96_144   = encrypt`{n = 48, m = 3, T = 29}\nSpeck128_128  = encrypt`{n = 64, m = 2, T = 32}\nSpeck128_192  = encrypt`{n = 64, m = 3, T = 33}\nSpeck128_256  = encrypt`{n = 64, m = 4, T = 34}\n\nSpeck32_64'   = decrypt`{n = 16, m = 4, T = 22}\nSpeck48_72'   = decrypt`{n = 24, m = 3, T = 22}\nSpeck48_96'   = decrypt`{n = 24, m = 4, T = 23}\nSpeck64_96'   = decrypt`{n = 32, m = 3, T = 26}\nSpeck64_128'  = decrypt`{n = 32, m = 4, T = 27}\nSpeck96_96'   = decrypt`{n = 48, m = 2, T = 28}\nSpeck96_144'  = decrypt`{n = 48, m = 3, T = 29}\nSpeck128_128' = decrypt`{n = 64, m = 2, T = 32}\nSpeck128_192' = decrypt`{n = 64, m = 3, T = 33}\nSpeck128_256' = decrypt`{n = 64, m = 4, T = 34}\n\nproperty correctSpeck32_64 (k, b) = Speck32_64' k (Speck32_64 k b) == b\nproperty correctSpeck64_96 (k, b) = Speck64_96' k (Speck64_96 k b) == b\nproperty correctSpeck96_144 (k, b) = Speck96_144' k (Speck96_144 k b) == b\nproperty correctSpeck128_128 (k, b) = Speck128_128' k (Speck128_128 k b) == b\nproperty correctSpeck128_256 (k, b) = Speck128_256' k (Speck128_256 k b) == b\n\n\nR : {n} (fin n) => [n] -> ([n], [n]) -> ([n], [n])\nR k (x, y) = f2 (f1 k (x, y))\n\nR' : {n} (fin n) => [n] -> ([n], [n]) -> ([n], [n])\nR' k (x, y) = ((x ^ k) - z <<< (if `n == 16 then 7 else 8), z)\n  where z = (x ^ y) >>> (if `n == 16 then 2 else 3)\n\nf1 : {n} (fin n) => [n] -> ([n], [n]) -> ([n], [n])\nf1 k (x, y) = (y, (x >>> (if `n == 16 then 7 else 8)) + y ^ k)\n\nf2 : {n} (fin n) => ([n], [n]) -> ([n], [n])\nf2 (x, y) = (y, x <<< (if `n == 16 then 2 else 3) ^ y)\n\n\nencrypt : {n, m, T}\n    ( fin n, fin m, fin T\n    , m >= 2, T >= 2, n >= 2\n    , n >= width (T-2)\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\nencrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [R k b | b <- bs | k <- ks]\n    ks = expandKey`{n = n, m = m, T = T} (reverse k0)\n\n\ndecrypt : {n, m, T}\n    ( fin n, fin m, fin T\n    , m >= 2, T >= 2, n >= 2\n    , n >= width (T-2)\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\ndecrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [R' k b | b <- bs | k <- reverse ks]\n    ks = expandKey`{n = n, m = m, T = T} (reverse k0)\n\n\nexpandKey : {n, m, T}\n    ( fin n, fin m, fin T\n    , m >= 2, n >= 2, T >= 2\n    , n >= width (T-2)\n    ) => [m][n] -> [T][n]\nexpandKey K = ks\n  where\n    ls = drop`{1} K # [snd (f1 i (l, k)) | l <- ls | k <- ks | i <- [0 .. T - 2]]\n    ks = take`{1} K # [snd (f2 (k, l)) | l <- drop`{m - 1} ls | k <- ks]\n    snd (x, y) = y\n\n\nproperty testsPass = and tests\n\ntests = [t01, t02, t03, t04, t05, t06, t07, t08, t09]\n\nt00 = Speck32_64 [0x1918, 0x1110, 0x0908, 0x0100] (0x6574, 0x694C) == (0xA868, 0x42F2)\nt01 = Speck48_72 [0x121110, 0x0A0908, 0x020100] (0x20796C, 0x6C6172) == (0xC049A5, 0x385ADC)\nt02 = Speck48_96 [0x1A1918, 0x121110, 0x0A0908, 0x020100] (0x6D2073, 0x696874) == (0x735E10, 0xB6445D)\nt03 = Speck64_96 [0x13121110, 0x0B0A0908, 0x03020100] (0x74614620, 0x736E6165) == (0x9F7952EC, 0x4175946C)\nt04 = Speck64_128 [0x1B1A1918, 0x13121110, 0x0B0A0908, 0x03020100] (0x3B726574, 0x7475432D) == (0x8C6FA548, 0x454E028B)\nt05 = Speck96_96 [0x0D0C0B0A0908, 0x050403020100] (0x65776F68202C, 0x656761737520) == (0x9E4D09AB7178, 0x62BDDE8F79AA)\nt06 = Speck96_144 [0x151413121110, 0x0D0C0B0A0908, 0x050403020100] (0x656D6974206E, 0x69202C726576) == (0x2BF31072228A, 0x7AE440252EE6)\nt07 = Speck128_128 [0x0F0E0D0C0B0A0908, 0x0706050403020100] (0x6C61766975716520, 0x7469206564616D20) == (0xA65D985179783265, 0x7860FEDF5C570D18)\nt08 = Speck128_192 [0x1716151413121110, 0x0F0E0D0C0B0A0908, 0x0706050403020100] (0x7261482066656968, 0x43206F7420746E65) == (0x1BE4CF3A13135566, 0xF9BC185DE03C1886)\nt09 = Speck128_256 [0x1F1E1D1C1B1A1918, 0x1716151413121110, 0x0F0E0D0C0B0A0908, 0x0706050403020100] (0x65736F6874206E49, 0x202E72656E6F6F70) == (0x4109010405C0F53E, 0x4EEEB48D9C188F43)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/TripleDES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the TripleDES blockEncrypt function correctly implements the Triple DES encryption process as defined by the sequence encrypt-decrypt-encrypt with three keys. Include properties that check the correctness of encryption and decryption consistency, and verify the provided test vectors against the expected ciphertext outputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::TripleDES where\n\nimport Primitive::Symmetric::Cipher::Block::DES\n\nblockEncrypt : ([64],[64],[64],[64]) -> [64]\nblockEncrypt (k1,k2,k3,data) = result where\n    ex     = DES.encrypt k1 data\n    dx     = DES.decrypt k2 ex\n    result = DES.encrypt k3 dx\n\n\/\/ Test vectors from NIST 800-67\n\nKey1, Key2, Key3 : [64]\nKey1 = 0x0123456789ABCDEF\nKey2 = 0x23456789ABCDEF01\nKey3 = 0x456789ABCDEF0123\n\nP1, P2, P3 : [64]\nPlainText = \"The qufck brown fox jump\"\n\/\/ Yes, that's the correct phrase.. (see the 7th letter of the phrase).\n\/\/ It's supposed to be \"the quick...\" but they made a mistake in transcribing\n\/\/ the ASCII into hex.\n[P1, P2, P3] = split`{3} (join PlainText)\n\nC1, C2, C3 : [64]\nC1 = 0xA826FD8CE53B855F\nC2 = 0xCCE21C8112256FE6\nC3 = 0x68D5C05DD9B6B900\n\ntest_B1_1 = blockEncrypt (Key1, Key2, Key3, P1) == C1\ntest_B1_2 = blockEncrypt (Key1, Key2, Key3, P2) == C2\ntest_B1_3 = blockEncrypt (Key1, Key2, Key3, P3) == C3\n\nproperty testsPass = and [test_B1_1, test_B1_2, test_B1_3]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the cbcTDesEnc function in the TDES_CBC module. Include properties that check the function against the provided NIST test vectors for Triple DES in CBC mode, ensuring that encryption produces the expected ciphertext for given plaintext, keys, and IV."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::TDES_CBC where\nimport Primitive::Symmetric::Cipher::Block::TripleDES\n\n\/\/ Test vectors from https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Standards-and-Guidelines\/documents\/examples\/TDES_CBC.pdf\ntype iv = [64]\ntype block = [64]\n\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncbcTDesEnc : {n} (fin n) => k1 -> k2 -> k3->iv -> [n]block -> [n]block\ncbcTDesEnc k1 k2 k3 iv ps = cs\n    where cs = [ blockEncrypt (k1, k2, k3, (p ^ c')) | p <- ps | c' <- [iv] # cs ]\n\n\/\/ Number of blocks := 2\n\ntestKey ={ k1=0x0123456789ABCDEF, k2=0x23456789ABCDEF01, k3=0x456789ABCDEF0123,      iv=0xF69F2445DF4F9B17 }\ntestPt = [[0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]]\ntestCt = [[0x2079C3D53AA763E1, 0x93B79E2569AB5262, 0x516570481F25B50F, 0x73C0BDA85C8E0DA7]]\n\nproperty testPass = and [(cbcTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv ps) == cs\n                        | ps <- testPt | cs <- testCt]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the CBC mode encryption and decryption functions defined in the given module. The properties should ensure that decrypting an encrypted message with the same key and IV recovers the original plaintext blocks, and that the functions behave correctly for all valid inputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CBC where\n\n\/\/ set the sizes\ntype iv = [128]\ntype block = [128]\n\n\ncbcEnc : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncbcEnc enc k iv ps = cs\n    where cs = [ enc k (p ^ c') | p <- ps | c' <- [iv] # cs ]\n\ncbcDec : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncbcDec dec k iv cs = [ (dec k c) ^ c' | c <- cs | c' <- [iv] # cs ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AES_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the AES CBC mode encryption and decryption functions defined in the given module. Specifically, create properties that ensure decrypting an encrypted plaintext with the same key and IV returns the original plaintext, and that the encryption function produces ciphertext matching the provided test vectors for 1 to 4 blocks as specified in the module."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::AES_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::CBC\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\nproperty cbcEncCorrect encrypt k c ps = (cbcDec encrypt k c (cbcEnc encrypt k c ps)) == ps\n\n\/\/ Test vectors from https:\/\/tools.ietf.org\/html\/rfc3602\n\n\/\/ No. of blocks := 1\n\ntestKey = [0x06a9214036b8a15b512e03d534120006]\ntestIv = [0x3dafba429d9eb430b422da802c9fac41]\ntestPt = [[join \"Single block msg\"]]\ntestCt = [[0xe353779c1079aeb82708942dbe77181a]]\n\nproperty testEncCbcPassB1 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey | iv <- testIv | ps <- testPt | cs <- testCt ]\n\n\/\/ No. of blocks := 2\n\ntestKey2 = [0xc286696d887c9aa0611bbb3e2025a45a]\ntestIv2 = [0x562e17996d093d28ddb3ba695a2e6f58]\ntestPt2 = [[0x000102030405060708090a0b0c0d0e0f, 0x101112131415161718191a1b1c1d1e1f]]\ntestCt2 = [[0xd296cd94c2cccf8a3a863028b5e1dc0a, 0x7586602d253cfff91b8266bea6d61ab1]]\n\nproperty testEncCbcPassB2 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey2 | iv <- testIv2 | ps <- testPt2 | cs <- testCt2 ]\n                                \n\n\/\/ No. of blocks := 3\n\ntestKey3 = [0x6c3ea0477630ce21a2ce334aa746c2cd]\ntestIv3 = [0xc782dc4c098c66cbd9cd27d825682c81]\ntestPt3 = [[0x5468697320697320612034382d627974, 0x65206d65737361676520286578616374, 0x6c7920332041455320626c6f636b7329]]\ntestCt3 = [[0xd0a02b3836451753d493665d33f0e886, 0x2dea54cdb293abc7506939276772f8d5, 0x021c19216bad525c8579695d83ba2684]]\n\nproperty testEncCbcPassB3 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey3 | iv <- testIv3 | ps <- testPt3 | cs <- testCt3 ]\n\n\/\/ No. of blocks := 4\n\ntestKey4 = [0x56e47a38c5598974bc46903dba290349]\ntestIv4 = [0x8ce82eefbea0da3c44699ed7db51b7d9]\ntestPt4 = [[0xa0a1a2a3a4a5a6a7a8a9aaabacadaeaf, 0xb0b1b2b3b4b5b6b7b8b9babbbcbdbebf, 0xc0c1c2c3c4c5c6c7c8c9cacbcccdcecf, 0xd0d1d2d3d4d5d6d7d8d9dadbdcdddedf]]\ntestCt4 = [[0xc30e32ffedc0774e6aff6af0869f71aa, 0x0f3af07a9a31a9c684db207eb0ef8e4e, 0x35907aa632c3ffdf868bb7b29d3d46ad, 0x83ce9f9a102ee99d49a53e87f4c3da55]]\n\nproperty testEncCbcPassB4 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey4 | iv <- testIv4 | ps <- testPt4 | cs <- testCt4 ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the ctrEnc and ctrDec functions for the CTR mode of operation are inverses of each other, i.e., decrypting an encrypted message with the same key and initial counter returns the original plaintext blocks. Include properties that check correctness for varying input lengths and keys."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CTR where\n\n\/\/ set the sizes\ntype ic = [128]\ntype block = [128]\n\n\nctrEnc : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> ic -> [n]block -> [n]block\nctrEnc enc k c ps = cs\n    where cs = [(enc k c')^p | p <- ps | c' <- ctrs]\n          ctrs = [c+i | i<- [0...]]\n\nctrDec : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> ic -> [n]block -> [n]block\nctrDec enc k c cs = ps\n    where ps = [(enc k c')^ct | ct <- cs | c' <- ctrs]\n          ctrs = [c+i | i<- [0...]]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the `cfbTDesEnc` function correctly implements the Triple DES CFB mode encryption as specified by the provided test vectors. Include properties that check the encryption output against the known ciphertext for given keys, IV, and plaintext blocks, ensuring correctness for any number of blocks."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::TDES_CFB where\nimport Primitive::Symmetric::Cipher::Block::TripleDES\n\n\/\/ Test vectors from https:\/\/csrc.nist.gov\/CSRC\/media\/Projects\/Cryptographic-Standards-and-Guidelines\/documents\/examples\/TDES_CFB.pdf\n\ntype iv = [64]\ntype block = [64]\n\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncfbTDesEnc : {n} (fin n) => k1 -> k2 -> k3->iv -> [n]block -> [n]block\ncfbTDesEnc k1 k2 k3 iv ps = cs\n    where cs = [ blockEncrypt (k1, k2, k3,  c')^p | p <- ps | c' <- [iv] # cs ]\n\n\/\/ Number of blocks := 4\n\ntestKey ={ k1=0x0123456789ABCDEF, k2=0x23456789ABCDEF01, k3=0x456789ABCDEF0123,      iv=0xF69F2445DF4F9B17 }\ntestPt = [[0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]]\ntestCt = [[0x078BB74E59CE7ED6, 0x7666DE9CF95EAF3F, 0xE9ED6BB460F45152, 0x8A5F9FE4ED710918]]\n\nproperty testPass = and [(cfbTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv ps) == cs\n                        | ps <- testPt | cs <- testCt]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AES_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the AES CTR mode implementation in the given module. Specifically, create properties that check that decrypting the ciphertext produced by encryption returns the original plaintext, and that the encryption of a known plaintext with a fixed key and initial counter matches the expected ciphertext. Include test vectors and ensure the properties can be used with :check or :prove commands."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::AES_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::CTR\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\nproperty ctrEncCorrect enc k c ps = (ctrDec enc k c (ctrEnc enc k c ps)) == ps\n\nk = 0x2b7e151628aed2a6abf7158809cf4f3c\nic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\nplaintext = [0x6bc1bee22e409f96e93d7e117393172a, 0xae2d8a571e03ac9c9eb76fac45af8e51, 0x30c81c46a35ce411e5fbc1191a0a52ef, 0xf69f2445df4f9b17ad2b417be66c3710]\nciphertext = [0x874d6191b620e3261bef6864990db6ce, 0x9806f66b7970fdff8617187bb9fffdff, 0x5ae4df3edbd5d35e5b4f09020db03eab, 0x1e031dda2fbe03d1792170a0f3009cee]\n\nproperty testPass = (ctrEnc encrypt k ic plaintext) == ciphertext\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the CFB mode encryption and decryption functions defined in the given module. Specifically, specify properties that ensure decrypting an encrypted plaintext with the same key and IV recovers the original plaintext, and that the functions behave consistently with respect to the block cipher encryption function."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CFB where\n\n\/\/ set the sizes\ntype iv = [128]\ntype block = [128]\n\n\ncfbEnc : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncfbEnc enc k iv ps = cs\n    where cs = [ (enc k c')^p | p <- ps | c' <- [iv] # cs ]\n\ncfbDec : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncfbDec enc k iv cs = [ (enc k c')^c | c <- cs | c' <- [iv] # cs ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AES_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the AES CFB mode encryption and decryption functions defined in the given module. Include properties that check that decrypting an encrypted plaintext returns the original plaintext, and properties that validate the encryption output against the provided NIST test vectors for both single-block and multi-block inputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::AES_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::CFB\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\nproperty cfbEncCorrect encrypt k c ps = (cfbDec encrypt k c (cfbEnc encrypt k c ps)) == ps\n\n\/\/ Test vectors from https:\/\/nvlpubs.nist.gov\/nistpubs\/Legacy\/SP\/nistspecialpublication800-38a.pdf\n\/\/ No. of blocks := 1\n\ntestKey = [0x2b7e151628aed2a6abf7158809cf4f3c]\ntestIv = [0x000102030405060708090a0b0c0d0e0f]\ntestPt = [[0x6bc1bee22e409f96e93d7e117393172a]]\ntestCt = [[0x3b3fd92eb72dad20333449f8e83cfb4a]]\n\nproperty testEncCfbPassB1 = and [ (cfbEnc encrypt k iv ps) == cs\n                                | k <- testKey | iv <- testIv | ps <- testPt | cs <- testCt ]\n\n\/\/ No. of blocks := 2\n\ntestKey2 = [0x2b7e151628aed2a6abf7158809cf4f3c]\ntestIv2 = [0x000102030405060708090a0b0c0d0e0f]\ntestPt2 = [[0x6bc1bee22e409f96e93d7e117393172a, 0xae2d8a571e03ac9c9eb76fac45af8e51, 0x30c81c46a35ce411e5fbc1191a0a52ef, 0xf69f2445df4f9b17ad2b417be66c3710]]\ntestCt2 = [[0x3b3fd92eb72dad20333449f8e83cfb4a, 0xc8a64537a0b3a93fcde3cdad9f1ce58b, 0x26751f67a3cbb140b1808cf187a4f4df, 0xc04b05357c5d1c0eeac4c66f9ff7f2e6]]\n\nproperty testEncCfbPassB2 = and [ (cfbEnc encrypt k iv ps) == cs\n                                | k <- testKey2 | iv <- testIv2 | ps <- testPt2 | cs <- testCt2 ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Tests\/TestAESKeyWrap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally verifies the correctness of the AES key wrap and unwrap functions against the provided test vectors from RFC 3394 and the NIST Key Wrap Validation System. The specification should include properties that check that wrapping a key with a given KEK produces the expected ciphertext, and that unwrapping the ciphertext recovers the original key data or correctly fails when validation fails. Ensure the properties cover all provided test cases for 128-bit, 192-bit, and 256-bit key data lengths and the various COUNT test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Tests::TestAESKeyWrap where\n\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Block::AESKeyWrap\n\n\/\/ This section contains tests of the Key Wrap specifications using test\n\/\/ vectors from Section 4 of RFC 3394.\n\n\/\/ 256-bit key encryption key (KEK) used to encrypt the key data\nKEK256 : [AESKeySize]\nKEK256 = 0x000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\n\n\/\/ 128-bit key data to encrypt\nKeyData128 : [16][8]\nKeyData128 = split 0x00112233445566778899AABBCCDDEEFF\n\n\/\/ Expected ciphertext from encrypting KeyData128 with KEK256\nCiphertext128_256 : [24][8]\nCiphertext128_256 = split 0x64E8C3F9CE0F5BA263E9777905818A2A93C8191E7D6E8AE7\n\n\/\/ Test wrapping and unwrapping of KeyData128 with KEK256 (Section 4.3)\nproperty testWrap128_256 = (aesWrapKey KEK256 DefaultIV KeyData128) == Ciphertext128_256\nproperty testUnwrap128_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext128_256) == (True, KeyData128)\n\n\/\/ 192-bit key data to encrypt\nKeyData192 : [24][8]\nKeyData192 = split 0x00112233445566778899AABBCCDDEEFF0001020304050607\n\n\/\/ Expected ciphertext from encrypting KeyData192 with KEK256\nCiphertext192_256 : [32][8]\nCiphertext192_256 = split 0xA8F9BC1612C68B3FF6E6F4FBE30E71E4769C8B80A32CB8958CD5D17D6B254DA1\n\n\/\/ Test wrapping and unwrapping of KeyData192 with KEK256 (Section 4.5)\nproperty testWrap192_256 = (aesWrapKey KEK256 DefaultIV KeyData192) == Ciphertext192_256\nproperty testUnwrap192_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext192_256) == (True, KeyData192)\n\n\/\/ 256-bit key data to encrypt\nKeyData256 : [32][8]\nKeyData256 = split 0x00112233445566778899AABBCCDDEEFF000102030405060708090A0B0C0D0E0F\n\n\/\/ Expected ciphertext from encrypting KeyData256 with KEK256\nCiphertext256_256 : [40][8]\nCiphertext256_256 = split 0x28C9F404C4B810F4CBCCB35CFB87F8263F5786E2D80ED326CBC7F0E71A99F43BFB988B9B7A02DD21\n\n\/\/ Test wrapping and unwrapping of KeyData256 with KEK256 (Section 4.6)\nproperty testWrap256_256 = (aesWrapKey KEK256 DefaultIV KeyData256) == Ciphertext256_256\nproperty testUnwrap256_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext256_256) == (True, KeyData256)\n\n\/*\n * The following tests come from the NIST Key Wrap Validation System (KWVS)\n * KW-AD-AES256 test vectors.\n *\/\n\n\/\/COUNT = 0\nKCount0 = 0x80aa997327a4806b6a7a41a52b86c3710386f932786ef79676fafb90b8263c5f\nPCount0 = split`{each=8} 0x0a256ba75cfa03aaa02ba94203f15baa\nCCount0 = split`{each=8} 0x423c960d8a2ac4c1d33d3d977bf0a91559f99c8acd293d43\nproperty Count0Wrap = (aesWrapKey KCount0 DefaultIV PCount0) == CCount0\nproperty Count0Unwrap = (aesUnwrapKey KCount0 DefaultIV CCount0) == (True, PCount0)\n\n\/\/COUNT = 1\nKCount1 = 0x2d104bc65c5f78e92993bd78b27d8e59a8a1f7c64b55b05be5df30f96ff04767\nCCount1 = split`{each=8} 0xe69fc01ea73e11bb4bc7485044145f824cfd535528b76517\nPCount1 = split`{each=8} 0xf8d46471445228d2ef399755360bdd6e\nproperty Count1Wrap = (aesWrapKey KCount1 DefaultIV PCount1) == CCount1\nproperty Count1Unwrap = (aesUnwrapKey KCount1 DefaultIV CCount1) == (True, PCount1)\n\n\/\/COUNT = 2\nKCount2 = 0xd963c8f1d3d2392629823fd1df3f644c8690f602c94e5d5818309d7c05e5427f\nCCount2 = split`{each=8} 0x177c6217f7fd6c94cbd4a9f512b1416c869328e3084e09ea\nPCount2 = split`{each=8} 0x451d0222ec29755d9c69165a5d109727\nproperty Count2Wrap = (aesWrapKey KCount2 DefaultIV PCount2) == CCount2\nproperty Count2Unwrap = (aesUnwrapKey KCount2 DefaultIV CCount2) == (True, PCount2)\n\n\/\/COUNT = 3\nKCount3 = 0xe594f0067cedb74e883e7746d29ba725c884c25375323f367cf49d17ad0f567b\nCCount3 = split`{each=8} 0x3b51ae2b0e3ddeed94efd7bfdc22630187e1f7624d15ed78\nPCount3 = split`{each=8} 0x587e3f6c75644bb5c3db9c74714f5556\nproperty Count3Wrap = (aesWrapKey KCount3 DefaultIV PCount3) == CCount3\nproperty Count3Unwrap = (aesUnwrapKey KCount3 DefaultIV CCount3) == (True, PCount3)\n\n\/\/COUNT = 4 (validation failure)\nKCount4 = 0x08c936b25b567a0aa679c29f201bf8b190327df0c2563e39cee061f149f4d91b\nCCount4 = split`{each=8} 0xe227eb8ae9d239ccd8928adec39c28810ca9b3dc1f366444\nproperty Count4Unwrap = (aesUnwrapKey KCount4 DefaultIV CCount4) == (False, zero)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/GF28.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the GF28 arithmetic operations defined in the module Primitive::Symmetric::Cipher::Block::AES::GF28. Specifically, include properties that check the associativity and commutativity of gf28Add, the distributive property of gf28Mult over gf28Add, the correctness of gf28Inverse as the multiplicative inverse, and the consistency of gf28Pow with repeated multiplication. Also, specify properties to verify the correctness of gf28DotProduct, gf28VectorMult, and gf28MatrixMult functions with respect to their mathematical definitions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::GF28 where\n\ntype GF28 = [8]\n\n\/** The irreducable polynomial *\/\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\n\/** Sum up a bunch of GF28 values *\/\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\n\/** Multiply two GF28 values *\/\ngf28Mult : GF28 -> GF28 -> GF28\ngf28Mult x y = pmod (pmult x y) irreducible\n\n\/** A GF28 value to a scalar power *\/\ngf28Pow : GF28 -> [8] -> GF28\ngf28Pow n k = pow k\n  where   sq x  = gf28Mult x x\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult n (sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\n\/** Compute the inverse of a value *\/\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow x 254\n\n\/** Dot product of two vectors *\/\ngf28DotProduct : {n} (fin n) => [n]GF28 -> [n]GF28 -> GF28\ngf28DotProduct xs ys = gf28Add [ gf28Mult x y | x <- xs | y <- ys ]\n\n\/** Multiply a matrix by a vector *\/\ngf28VectorMult : {n, m} (fin n) => [n]GF28 -> [m][n]GF28 -> [m]GF28\ngf28VectorMult v ms = [ gf28DotProduct v m | m <- ms ]\n\n\/** Multiply two matrices *\/\ngf28MatrixMult : {n, m, k} (fin m) => [n][m]GF28 -> [m][k]GF28 -> [n][k]GF28\ngf28MatrixMult xss yss = [ gf28VectorMult xs yss' | xs <- xss ]\n   where yss' = transpose yss\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Algorithm.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the AES encryption and decryption functions in the given module are inverses of each other for all valid keys and plaintexts, ensuring that decrypting an encrypted message returns the original plaintext. Include properties that check the correctness of the key schedule usage and the round transformations according to the AES standard."},{"role":"assistant","content":"```cryptol\n\/\/ This is a fairly close implementation of the FIPS-197 standard:\n\/\/   http:\/\/csrc.nist.gov\/publications\/fips\/fips197\/fips-197.pdf\n\nmodule Primitive::Symmetric::Cipher::Block::AES::Algorithm where\n\nimport Primitive::Symmetric::Cipher::Block::AES::State (State, RoundKey, msgToState, stateToMsg)\nimport Primitive::Symmetric::Cipher::Block::AES::Round (AESFinalRound, AESFinalInvRound)\n\nparameter\n  \/** 0: AES128, 1: AES192, 2: AES256 *\/\n  type Mode : #\n\n  type constraint (2 >= Mode)\n\n  encRound     : RoundKey -> State -> State\n  decRound     : RoundKey -> State -> State\n\n\n\/** Number of 32 bit words in the key *\/\ntype Nk = 4 + 2 * Mode\n\n\/** Number of rounds *\/\ntype Nr = 6 + Nk\n\n\/** Key size in bits *\/\ntype AESKeySize  = 32 * Nk\n\n\/** The keys for all the rounds *\/\ntype KeySchedule = (RoundKey, [Nr-1]RoundKey, RoundKey)\n\n\/** AES Encryption with an expanded key.\nThis is useful if many things will be encrypted with the same key. *\/\nencrypt : KeySchedule -> [128] -> [128]\nencrypt (kInit,ks,kFinal) pt =\n                            stateToMsg (AESFinalRound kFinal (rounds ! 0))\n  where\n  state0 = kInit ^ msgToState pt\n  rounds = [state0] # [ encRound rk s | rk <- ks | s <- rounds ]\n\n\/** AES decryption with an expanded key.\nThis is useful if many things will be decrypted with the same key. *\/\ndecrypt : KeySchedule -> [128] -> [128]\ndecrypt (kInit, ks, kFinal) ct =\n                          stateToMsg (AESFinalInvRound kFinal (rounds ! 0))\n  where\n  state0 = kInit ^ msgToState ct\n  rounds = [state0] # [ decRound rk s | rk <- ks | s <- rounds ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/SBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the AES SBox and its inverse (sboxInv) are correct inverses of each other, ensuring that for every byte input, applying sbox followed by sboxInv returns the original byte, and vice versa."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::SBox where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::SubBytePlain\n\ntype SBox = [256] GF28\n\nsbox : SBox\nsbox = [ SubByte x | x <- [0 .. 255] ]\n\nsboxInv : SBox\nsboxInv = [ InvSubByte x | x <- [0 .. 255] ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/ExpandKey.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the AES key expansion function `expandKey` in the given module. The properties should check that the generated round keys conform to the AES key schedule algorithm, including correct application of `SubWord`, `RotWord`, and `Rcon` transformations, and that the sequence of round keys is consistent with the input key and parameters `Nk` and `Nr`. Include properties that ensure the infinite key word stream `keyWS` is generated correctly and that `expandKeyForever` produces properly transposed round keys."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::ExpandKey where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::State\nimport Primitive::Symmetric::Cipher::Block::AES::SubByteSBox\n\nparameter\n  \/** Number of 32 bit words in the key *\/\n  type Nk : #\n  type constraint (8 >= width Nk, Nk >= 1)\n\n  \/** Number of rounds *\/\n  type Nr : #\n  type constraint (8 >= width Nr, Nr >= 2)\n\nexpandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)\nexpandKey key = ( keys @ 0\n                , keys @@ ([1 .. (Nr - 1)] : [_][8])\n                , keys @ (`Nr : [8])\n                )\n  where   seed : [Nk][4][8]\n          seed = split (split key)\n          keys = expandKeyForever seed\n\n\nexpandKeyForever : [Nk][4][8] -> [inf]RoundKey\nexpandKeyForever seed = [ transpose g | g <- split (keyWS seed) ]\n\nkeyWS : [Nk][4][8] -> [inf][4][8]\nkeyWS seed    = xs\n     where xs = seed # [ NextWord i prev old\n                       | i    <- [ `Nk ... ]\n                       | prev <- drop`{Nk-1} xs\n                       | old  <- xs\n                       ]\n\n\/\/ Key expansion\nRcon : [8] -> [4]GF28\nRcon i = [ gf28Pow <| x |> (i-1), 0, 0, 0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord bs = [ SubByte b | b <- bs ]\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nNextWord : [8] ->[4][8] -> [4][8] -> [4][8]\nNextWord i prev old = old ^ mask\n   where mask = if i % nk == 0\n                then SubWord (RotWord(prev)) ^ Rcon (i \/ `Nk)\n                else if (nk > 6) && (i % nk == 4)\n                     then SubWord prev\n                     else prev\n\n         nk = `Nk : [8]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/SubByteSBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the SubByte and InvSubByte functions are inverses of each other over the entire GF(2^8) field. The specification should check that for every input byte, applying SubByte followed by InvSubByte returns the original byte, and vice versa."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::SubByteSBox where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::SBox\n\nSubByte : GF28 -> GF28\nSubByte b = sbox @ b\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = sboxInv @ b\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Round.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the AES round functions defined in the module Primitive::Symmetric::Cipher::Block::AES::Round. Specifically, specify properties that check the invertibility of AESRound and AESInvRound (i.e., AESInvRound should be the inverse of AESRound), and similarly for AESFinalRound and AESFinalInvRound. Include properties that verify the correctness of the SubBytes, ShiftRows, MixColumns, and their inverse functions, ensuring they satisfy the AES specification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Round where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::State\nimport Primitive::Symmetric::Cipher::Block::AES::SubByteSBox\n\n\/** One round of AES *\/\nAESRound : RoundKey -> State -> State\nAESRound rk s = rk ^ MixColumns (ShiftRows (SubBytes s))\n\nSubBytes : State -> State\nSubBytes state = [ [ SubByte b | b <- row ] | row <- state ]\n\nShiftRows : State -> State\nShiftRows state = [ row <<< i | row <- state | i : [2] <- [0 .. 3] ]\n\nMixColumns : State -> State\nMixColumns state = gf28MatrixMult m state\n    where m = [ [2,3,1,1] >>> i | i <- [0 .. 3] ]\n\n\/** The final AES round *\/\nAESFinalRound : RoundKey -> State -> State\nAESFinalRound rk s = rk ^ ShiftRows (SubBytes s)\n\n\n\n\/** One inverse round of AES *\/\nAESInvRound : RoundKey -> State -> State\nAESInvRound rk s = InvMixColumns (rk ^ InvSubBytes (InvShiftRows s))\n\nInvSubBytes : State -> State\nInvSubBytes state = [ [ InvSubByte b | b <- row ] | row <- state ]\n\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> shiftAmount | row <- state\n                                           | shiftAmount : [2] <- [0 .. 3]\n                     ]\n\nInvMixColumns : State -> State\nInvMixColumns state = gf28MatrixMult m state\n    where m = [[0x0e, 0x0b, 0x0d, 0x09] >>> i | i <- [0 .. 3] ]\n\n\/** The final inverted AES round *\/\nAESFinalInvRound : RoundKey -> State -> State\nAESFinalInvRound rk s = rk ^ InvSubBytes (InvShiftRows s)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/SubBytePlain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify that the functions SubByte and InvSubByte are inverses of each other over GF28, and that xformByte and xformByte' correctly implement the affine transform and its inverse as defined in the AES SubBytes step."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::SubBytePlain where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\n\n\/\/ The SubBytes transform and its inverse\nSubByte : GF28 -> GF28\nSubByte b = xformByte (gf28Inverse b)\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = gf28Inverse (xformByte' b)\n\n\n\/\/ The affine transform and its inverse\nxformByte : GF28 -> GF28\nxformByte b = gf28Add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n   where c = 0x63\n\nxformByte' : GF28 -> GF28\nxformByte' b = gf28Add [(b >>> 2), (b >>> 5), (b >>> 7), d] where d = 0x05\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/TBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the AES TBox generation functions in the given module. Specifically, specify properties that check the consistency of the forward and inverse TBoxes (tbox and tboxInv) with respect to the AES SBox and InvSBox, and verify that the AESRound and AESInvRound functions correctly implement one round of AES encryption and decryption using these TBoxes."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::TBox where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::State\nimport Primitive::Symmetric::Cipher::Block::AES::SBox\nimport Primitive::Symmetric::Cipher::Block::AES::Round\n\n\nAESRound    rk st = genRound ShiftRows    tbox    rk st\n\/\/ AESInvRound rk st = genRound InvShiftRows tboxInv (InvMixColumns rk) st\nAESInvRound rk st = genRound InvShiftRows tboxInv rk st\n\n\nmakeDecKey (a,xs,b) = (b, [ InvMixColumns rk | rk <- reverse xs ], a)\n\ngenRound : (State -> State) -> TBox -> RoundKey -> State -> State\ngenRound shift boxes rk st =\n  rk ^ transpose [ add [ box @ i | box <- boxes | i <- col ]\n                 | col <- transpose (shift st) ]\n  where add [ a, b, c, d ] = a ^ b ^ c ^ d\n\n\n\n\/\/ Computing the TBoxes\ntype TBox = [4][256][4]GF28\n\ntbox : TBox\ntbox = mkTBox [ 0x02, 0x01, 0x01, 0x03 ] sbox\n\ntboxInv : TBox\ntboxInv = mkTBox [ 0x0e, 0x09, 0x0d, 0x0b ] sboxInv\n\nmkTBox : [4]GF28 -> SBox -> TBox\nmkTBox seed box = [ [ a >>> i | a <- t0 ] | i <- [0 .. 3] ]\n  where\n  t0 = [ [ gf28Mult c s | c <- seed ] | s <- box ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/State.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the functions msgToState and stateToMsg are inverses of each other, ensuring that converting a 128-bit message to a State and back yields the original message, and vice versa."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::State where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\n\ntype State       = [4][Nb]GF28\ntype Nb          = 4\ntype RoundKey    = State\n\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Hash\/HMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the HMAC implementation using SHA-384 in the given module. The properties should include checks that the HMAC function produces the expected output for known test vectors, that the HMACInit, HMACUpdate, and HMACFinal functions compose correctly, and that the key initialization behaves as specified for keys of different lengths. Ensure the properties are suitable for automated verification using Cryptol's :prove or :check commands."},{"role":"assistant","content":"```cryptol\n\/*\n * This is a simple implementation of HMAC with SHA-384\n *\/\n\nmodule Primitive::Keyless::Hash::HMAC where\n\nimport Primitive::Keyless::Hash::SHA384\n\n\/\/ Pad or hash `key`, depending on its length, until it is 128 bytes long\nkey_init : {key_size} (fin key_size) => [key_size][8] -> [128][8]\nkey_init key =\n  take`{128} (if `key_size <= 128\n              then key # (zero : [inf][8])\n              else (split`{48} (SHAImp key)) # (zero : [inf][8]))\n\ntype HMACState = { i_ctx  : SHAState\n                 , o_ctx  : SHAState\n                 , md_ctx : SHAState\n                 }\n\n\/\/ HMAC-SHA384 init function\nHMACInit : {key_size} (fin key_size) => [key_size][8] -> HMACState\nHMACInit key =\n  { i_ctx  = i_state\n  , o_ctx  = SHAUpdate SHAInit opad\n  , md_ctx = i_state\n  }\n  where key'    = key_init key\n        ipad    = [ k ^ 0x36 | k <- key' ]\n        opad    = [ k ^ 0x5c | k <- key' ]\n        i_state = SHAUpdate SHAInit ipad\n\n\/\/ HMAC-SHA384 update function\nHMACUpdate : {n} (fin n) => HMACState -> [n][8] -> HMACState\nHMACUpdate state data = { i_ctx = state.i_ctx\n                        , o_ctx = state.o_ctx\n                        , md_ctx = SHAUpdate state.md_ctx data\n                        }\n\n\/\/ HMAC-SHA384 final function\nHMACFinal : HMACState -> [48][8]\nHMACFinal state = split`{48} (SHAFinal o_ctx')\n  where o_ctx' = SHAUpdate state.o_ctx buf\n        buf = split`{48} (SHAFinal state.md_ctx)\n\n\/\/ HMAC-SHA384 implementation\nHMAC : {n, m} (fin n, fin m) => [n][8] -> [m][8] -> [48][8]\nHMAC key data = HMACFinal (HMACUpdate (HMACInit key) data)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Hash\/SHA1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the `sha1` function implementation conforms to the SHA-1 standard by checking its output against known test vectors provided in the code. Include properties that validate the padding function and the compression function `block` behave correctly according to the SHA-1 specification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA1 where\n\nsha1 : {n} (width (8*n) <= 64) => [n][8] -> [160]\nsha1 msg = sha1' pmsg\n    where\n        pmsg = pad(join(msg))\n\nsha1' : {chunks} (fin chunks) => [chunks][512] -> [160]\nsha1' pmsg = join (Hs!0)\n  where\n    Hs = [[0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]] #\n         [ block(H, split(M))\n         | H <- Hs\n         | M <- pmsg\n         ]\n\n\/*\nAs a summary, a \"1\" followed by m \"0\"s followed by a 64-\n   bit integer are appended to the end of the message to produce a\n   padded message of length 512 * n.  The 64-bit integer is the length\n   of the original message.  The padded message is then processed by the\n   SHA-1 as n 512-bit blocks.\n*\/\n\npad : {msgLen}\n     ( fin msgLen\n     , 64 >= width msgLen                             \/\/ message width fits in a word\n     )\n     => [msgLen] -> [(msgLen + 65) \/^ 512][512]\npad msg = split (msg # [True] # (zero:[padLen]) # (`msgLen:[64]))\n    where type padLen     = (msgLen + 65) %^ 512\n\nf : ([8], [32], [32], [32]) -> [32]\nf (t, x, y, z) =\n       if (0 <= t)  \/\\ (t <= 19) then (x && y) ^ (~x && z)\n        | (20 <= t) \/\\ (t <= 39) then x ^ y ^ z\n        | (40 <= t) \/\\ (t <= 59) then (x && y) ^ (x && z) ^ (y && z)\n        | (60 <= t) \/\\ (t <= 79) then x ^ y ^ z\n        else error \"f: t out of range\"\n\nKs : [80][32]\nKs = [ 0x5a827999 | t <- [0..19]  ]\n   # [ 0x6ed9eba1 | t <- [20..39] ]\n   # [ 0x8f1bbcdc | t <- [40..59] ]\n   # [ 0xca62c1d6 | t <- [60..79] ]\n\nblock : ([5][32], [16][32]) -> [5][32]\nblock ([H0, H1, H2, H3, H4], M) =\n [(H0+As@80), (H1+Bs@80), (H2+Cs@80), (H3+Ds@80), (H4+Es@80)]\n  where\n    Ws : [80][32]\n    Ws = M # [ (W3 ^ W8 ^ W14 ^ W16) <<< 1\n             | W16 <- drop`{16 - 16} Ws\n             | W14 <- drop`{16 - 14} Ws\n             | W8  <- drop`{16 - 8}  Ws\n             | W3  <- drop`{16 - 3}  Ws\n             | t <- [16..79]\n             ]\n    As = [H0] # TEMP\n    Bs = [H1] # As\n    Cs = [H2] # [ B <<< 30 | B <- Bs ]\n    Ds = [H3] # Cs\n    Es = [H4] # Ds\n    TEMP : [80][32]\n    TEMP = [ (A <<< 5) + f(t, B, C, D) + E + W + K\n           | A <- As | B <- Bs | C <- Cs | D <- Ds | E <- Es\n           | W <- Ws | K <- Ks\n           | t <- [0..79]\n           ]\n\n\nt0 = sha1 \"\" == 0xda39a3ee5e6b4b0d3255bfef95601890afd80709\n\n\/\/ Sample messages and their digests from FIPS180-1 appendix.\n\nt1 = sha1 \"abc\" == 0xA9993E364706816ABA3E25717850C26C9CD0D89D\nt2 = sha1 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\" ==\n     0x84983E441C3BD26EBAAE4AA1F95129E5E54670F1\nt3 = sha1 [ 'a' | i <- [1..1000000] ] ==\n     0x34AA973CD4C4DAA4F61EEB2BDBAD27316534016F\n\nproperty testsPass = and [t0, t1, t2, t3]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Hash\/MD5.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the `md5` function correctly computes the MD5 hash according to the RFC 1321 test vectors provided (r0 through r8). Ensure the properties check that the output of `md5` on each test input matches the expected 128-bit hash value. Include properties that verify the correctness of padding, block processing, and state updates in the MD5 algorithm as implemented in this module."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::MD5 where\n\n\/\/ Swap byte order from network to host order (long word)\nntohl : [32] -> [32]\nntohl w = join (reverse (groupBy`{8} w))\n\n\/\/ Swap byte order from host to network order (long word)\nhtonl : [32] -> [32]\nhtonl w = join (reverse (groupBy`{8} w))\n\n\/\/ Swap byte order from host to network order (long long word)\nhtonll : [64] -> [64]\nhtonll w = join (reverse (groupBy`{8} w))\n\n\/\/ apply a function to every element of a sequence\nmap : {n, a, b} (a -> b) -> [n]a -> [n]b\nmap f xs = [ f x | x <- xs ]\n\n\/\/ fold with left associativity\nfoldl : {n, a, b} (fin n) => a -> (a -> b -> a) -> [n]b -> a\nfoldl seed f xs = res ! 0\n  where res = [seed] # [ f a x | a <- res\n                               | x <- xs\n                       ]\n\n\/\/ Test driver.  Given a sequence of bytes, calculate the MD5 sum.\ntest s = md5 (join s)\n\n\/\/ Reference implementation of MD5 on exactly 16 bytes.\n\nmd5_ref : [16][8] -> [16][8]\nmd5_ref msg = map reverse (groupBy`{8} (md5 (join (map reverse msg))))\n\nmd5_ref' : [128] -> [128]\nmd5_ref' msg = join (md5_ref (groupBy`{8} msg))\n\n\n\n\/\/ The state of the MD5 algorithm after each 512 bit block\n\/\/ consists of 4 32-bit words.\ntype MD5State = ([32],[32],[32],[32])\n\n\/\/ Main MD5 algorithm.\n\/\/\n\/\/ First, pad the message to a multiple of 512 bits.\n\/\/ Next, initialize the MD5 state using the fixed values from the RFC.\n\/\/ Then, process each message block in turn by computing\n\/\/ the MD5 rounds using the message block.  Add the result\n\/\/ of the final round to the current MD5 state.\n\/\/ Finally, return the current MD5 state after all blocks are processed,\n\/\/ interpreting the 4 32-bit words as a single 128-bit sequence.\n\nmd5 : {a} (64 >= width a) => [a] -> [128]\nmd5 msg = md5output finalState\n    where\n      type p = (a + 65) %^ 512\n      type b = (a + 65) \/^ 512\n\n      finalState : MD5State\n      finalState = foldl initialMD5State processBlock blocks\n\n      blocks : [b][512]\n      blocks = groupBy`{512} (pad `{a,p} msg)\n\n      add : MD5State -> MD5State -> MD5State\n      add (a, b, c, d) (e, f, g, h) = (a + e, b + f, c + g, d + h)\n\n      processBlock : MD5State -> [512] -> MD5State\n      processBlock st blk = add st (computeRounds (decodeBlock blk) st)\n\n\n\/\/ Initial seed for the digest rounds\n\/\/\n\/\/ See RFC 1321, section 3.3\n\ninitialMD5State : MD5State\ninitialMD5State = (A, B, C, D)\n where\n   f x = ntohl (join x)\n   A = f [ 0x01, 0x23, 0x45, 0x67 ]\n   B = f [ 0x89, 0xAB, 0xCD, 0xEF ]\n   C = f [ 0xFE, 0xDC, 0xBA, 0x98 ]\n   D = f [ 0x76, 0x54, 0x32, 0x10 ]\n\n\n\/\/ Each MD5 message block 512 bits long, interpreted as a sequence of 16 32-bit words\n\/\/ Each word is given as a sequence of 4 bytes, with LEAST significant byte first\n\/\/ Each byte is given as a sequence of 8 bits, with MOST significant bit first\n\/\/\n\/\/ The output of the algorithm is a sequence of 4 words, interpreted as above\n\/\/\n\/\/ See RFC 1321, section 2\n\ndecodeBlock : [512] -> [16][32]\ndecodeBlock s = map ntohl (groupBy`{32} s)\n\n\n\/\/ Interpret 4 32-bit words as a single 128-bit sequence\n\/\/\n\/\/ See RFC 1321 section 3.5\n\nmd5output : MD5State -> [128]\nmd5output (a,b,c,d) = htonl a # htonl b # htonl c # htonl d\n\n\n\n\/\/ Given an arbitrary byte sequence whose length can be described\n\/\/ by a 64-bit number, pad the message so it is exactly a multiple of 512.\n\/\/\n\/\/ This is done by adding a single 1 bit to the end of the message, and\n\/\/ then adding enough zero bits to make the whole message 64 bits shorter\n\/\/ than a multiple of 512.  The size (in bits) of the original message is\n\/\/ then appended to complete the padded message.\n\/\/\n\/\/ See RFC 1321, sections 3.1 and 3.2\n\npad : {a, p} (fin p, 64 >= width a) => [a] -> [65 + (a + p)]\npad msg =\n    msg # [True] # zero # htonll sz\n    where\n      sz : [64]\n      sz = length msg\n\n\n\n\/\/ Given a message block (interpreted as 16 32-bit words) and a current MD5 state\n\/\/ (as 4 32-bit words) compute the values of all the rounds of the MD5 algorithm.\n\/\/\n\/\/ In the main MD5 function, the final round will be used to compute the next MD5 state.\n\/\/\n\/\/ See RFC 1321, section 3.4\n\ncomputeRounds : [16][32] -> MD5State -> MD5State\ncomputeRounds msg st = rounds (msg,st) @ 64\n\nrounds : ([16][32], MD5State) -> [65]MD5State\nrounds (msg, (a0, b0, c0, d0)) =\n    [ (a, b, c, d) | a <- as\n                   | b <- bs\n                   | c <- cs\n                   | d <- ds\n    ]\n    where\n      bs =\n          [b0] #\n          [box (i, a, b, c, d, m, t, s) | i <- [0 .. 63]\n                                        | a <- as\n                                        | b <- bs\n                                        | c <- cs\n                                        | d <- ds\n                                        | m <- join [m @@ p | m <- [msg, msg, msg, msg]\n                                                            | p <- permutes\n                                                    ]\n                                        | t <- sineTbl\n                                        | s <- s_constants\n          ]\n      cs = [c0] # bs\n      ds = [d0] # cs\n      as = [a0] # ds\n\n\n\/\/ 'S' constants from the MD5 algorithm, used to indicated how many\n\/\/ bits to rotate in the box function.\n\/\/\n\/\/ See RFC 1321, section 3.4, and the appendix on page 10\n\ns_constants : [64][6]\ns_constants =\n   repeat4 [7, 12, 17, 22] #\n   repeat4 [5,  9, 14, 20] #\n   repeat4 [4, 11, 16, 23] #\n   repeat4 [6, 10, 15, 21]\n where\n   repeat4 abcd = abcd # abcd # abcd # abcd\n\n\n\/\/ This table of permutations indicates which word of the message block to\n\/\/ use in a given MD5 round.  Its structure is most evident via observing\n\/\/ the indices of the message block in the order they are used in the MD5\n\/\/ reference implementation.\n\/\/\n\/\/ See the appendix of RFC 1321, starting on page 13.\n\npermutes : [4][16][4]\npermutes =\n    [ [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15]\n    , [ 1,  6, 11,  0,  5, 10, 15,  4,  9, 14,  3,  8, 13,  2,  7, 12]\n    , [ 5,  8, 11, 14,  1,  4,  7, 10, 13,  0,  3,  6,  9, 12, 15,  2]\n    , [ 0,  7, 14,  5, 12,  3, 10,  1,  8, 15,  6, 13,  4, 11,  2,  9]\n    ]\n\n\n\/\/ The main \"box\" operation.  The first argument indicates\n\/\/ the round number, which is used to select between the box\n\/\/ operations, F, G, H, and I.\n\/\/\n\/\/ See RFC 1321, section 3.4\n\nbox : ([6], [32], [32], [32], [32], [32], [32], [6]) -> [32]\nbox (i, a, b, c, d, m, t, s) =\n    b + (a + boxfunc (i, b, c, d) + m + t <<< s)\n\nboxfunc : ([6],[32],[32],[32]) -> [32]\nboxfunc (i, b, c, d) =\n    if i < 16 then F (b, c, d) else\n    if i < 32 then G (b, c, d) else\n    if i < 48 then H (b, c, d) else\n                   I (b, c, d)\n\nF : ([32], [32], [32]) -> [32]\nF (x, y, z) = x && y || (~x) && z\n\nG : ([32], [32], [32]) -> [32]\nG (x, y, z) = x && z || y && ~z\n\nH : ([32], [32], [32]) -> [32]\nH (x, y, z) = x ^ y ^ z\n\nI : ([32], [32], [32]) -> [32]\nI (x, y, z) = y ^ (x || ~z)\n\n\n\/\/ The table of values generated from the sin function, as described\n\/\/ in RFC 1321, section 3.4.  These values are transcribed from\n\/\/ the appendix, starting on page 13.\n\nsineTbl : [64][32]\nsineTbl =\n    [0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE, 0xF57C0FAF,\n     0x4787C62A, 0xA8304613, 0xFD469501, 0x698098D8, 0x8B44F7AF,\n     0xFFFF5BB1, 0x895CD7BE, 0x6B901122, 0xFD987193, 0xA679438E,\n     0x49B40821, 0xF61E2562, 0xC040B340, 0x265E5A51, 0xE9B6C7AA,\n     0xD62F105D, 0x02441453, 0xD8A1E681, 0xE7D3FBC8, 0x21E1CDE6,\n     0xC33707D6, 0xF4D50D87, 0x455A14ED, 0xA9E3E905, 0xFCEFA3F8,\n     0x676F02D9, 0x8D2A4C8A, 0xFFFA3942, 0x8771F681, 0x6D9D6122,\n     0xFDE5380C, 0xA4BEEA44, 0x4BDECFA9, 0xF6BB4B60, 0xBEBFBC70,\n     0x289B7EC6, 0xEAA127FA, 0xD4EF3085, 0x04881D05, 0xD9D4D039,\n     0xE6DB99E5, 0x1FA27CF8, 0xC4AC5665, 0xF4292244, 0x432AFF97,\n     0xAB9423A7, 0xFC93A039, 0x655B59C3, 0x8F0CCC92, 0xFFEFF47D,\n     0x85845DD1, 0x6FA87E4F, 0xFE2CE6E0, 0xA3014314, 0x4E0811A1,\n     0xF7537E82, 0xBD3AF235, 0x2AD7D2BB, 0xEB86D391]\n\n\n\/\/ The MD5 test suite from RFC 1321, appendix A.5\n\nr0 = test \"\"\n  == 0xd41d8cd98f00b204e9800998ecf8427e\n\nr1 = test \"a\"\n  == 0x0cc175b9c0f1b6a831c399e269772661\n\nr2 = test \"abc\"\n  == 0x900150983cd24fb0d6963f7d28e17f72\n\nr3 = test \"message digest\"\n  == 0xf96b697d7cb7938d525a2f31aaf161d0\n\nr4 = test \"abcdefghijklmnopqrstuvwxyz\"\n  == 0xc3fcd3d76192e4007dfb496cca67e13b\n\nr5 = test \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n  == 0xd174ab98d277d9f5a5611c2c9f419d9f\n\nr6 = test \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n  == 0x57edf4a22be3c955ac49da2e2107b67a\n\nr7 = test \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n  == 0x8215ef0796a20bcaaae116d3876c664a\n\nr8 = test (join (repeat`{1000000} \"a\") )\n  == 0x7707d6ae4e027c70eea2a935c2296f21\n\nproperty testsPass = and [ r0, r1, r2, r3, r4, r5, r6, r7, r8 ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Generator\/DRBG.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the DRBG (Deterministic Random Bit Generator) implementation in the given module. Your properties should check that the functions drbg_instantiate, drbg_reseed, drbg_generate, and drbg_update behave according to the expected cryptographic behavior, including state updates, reseeding conditions, and output generation. Include properties that validate the test vectors provided in the module to ensure conformity with the NIST CTR_DRBG specification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Generator::DRBG where\n\nimport Primitive::Symmetric::Cipher::Block::AES\n\ntype keylen   = AESKeySize type blocklen = 128 type seedlen  = 256 \/\/ bits, 256 bits fixed by table 3 for AES-128\ntype reseed_limit = 2 ^^ 35 \/\/ max number of bytes to generate before reseeding\n\ntype blocksize = 16 \/\/ blocklen \/ 8\ntype keysize = 32 \/\/ keylen \/ 8\ntype seedsize = 48\n\ntype cipher_ctx = { key : [keylen] }\n\nblock_encrypt : [keylen] -> [blocklen] -> [blocklen]\nblock_encrypt key data = aesEncrypt(data, key)\n\ntype s2n_drbg =\n  { bytes_used : [64]\n  , ctx : cipher_ctx\n  , v : [blocklen]\n  }\n\ndrbg_generate_internal : {n, blocks}\n                         ( fin n, fin blocks, n >= 1, n <= 8192\n                         , n == blocklen * blocks)\n                      => s2n_drbg\n                      -> ([n], s2n_drbg)\ndrbg_generate_internal drbg =\n  (join [ block_encrypt drbg.ctx.key (drbg.v + i) | i <- [1 .. blocks]], drbg')\n    where drbg' = { bytes_used = drbg.bytes_used + `(blocks * blocksize)\n                  , ctx = drbg.ctx\n                  , v = drbg.v + `blocks\n                  }\n\ndrbg_instantiate : {ps_size}\n                   (fin ps_size)\n                => [seedlen]\n                -> [ps_size]\n                -> s2n_drbg\ndrbg_instantiate entropy ps = drbg_reseed zero entropy ps'\n  where\n    \/* pad ps with zeros if needed to reach seedlen\n       otherwise truncate to seedlen *\/\n    ps' = take `{seedlen} (ps # (zero : [seedlen]))\n\n\/* Should bytes used be reset before the update? s2n doesn't\n   it seems like the NIST spec counts that update as the first\n\n   we limit ps_size to a maximum of seedlen because this is an\n   implementation specific choice made by s2n*\/\ndrbg_reseed : {ps_size}\n              (ps_size <= seedlen)\n           => s2n_drbg\n           -> [seedlen]\n           -> [ps_size]\n\t   -> s2n_drbg\ndrbg_reseed drbg entropy ps = drbg''\n  where\n    drbg' = drbg_update (entropy ^ (ps # zero)) drbg\n    drbg'' = { v = drbg'.v, ctx = drbg'.ctx, bytes_used = 0}\n\ndrbg_uninstantiate : s2n_drbg -> s2n_drbg\ndrbg_uninstantiate drbg = zero\n\n\/* This is the spec of the s2n code, in that it reseeds automatically\n   if reseed is required. This is in opposition to the spec, which\n   requires an error code.\n\n   We are curious about why s2n_drbg counts a number of bytes used,\n   while the spec tracks a number of calls to generate. We don't\n   belive that this is buggy behavior, since if we call the maximum\n   size with generate each time, we will reseed before the spec would\n   require it. *\/\ndrbg_generate : {n, blocks} (fin n, fin blocks, n >= 1, n <= 8192,\n                             blocks * blocklen >= n,\n                             (blocks - 1) * blocklen <= n - 1) =>\n                s2n_drbg -> [seedlen] -> Bit ->\n                ([n], s2n_drbg)\ndrbg_generate drbg entropy reseed_p = (take enc_result, drbg_out)\n  where\n    \/\/ Re-seed if we have exceeded the limit, or if reseed_p is set\n    drbg_r =\n      if reseed_p \\\/ drbg.bytes_used + `n * 8 + `blocklen * 8 >= `reseed_limit then\n        drbg_reseed drbg entropy (zero : [256])\n      else drbg\n    \/\/ Encrypt v+1, v+2, ..., v + ceil (n \/ blocklen)\n    (enc_result, drbg_v) = drbg_generate_internal `{blocks=blocks} drbg_r\n    \/\/ Update the drbg state\n    drbg_out = drbg_update zero drbg_v\n\n\/* What is ctr_len? We think it is >= blocklen, so\n   we go to the else branch of 2.1 every time *\/\ndrbg_update : [seedlen] -> s2n_drbg -> s2n_drbg\ndrbg_update data drbg = result\n  where\n    \/\/ NOTE: blocklen * seedlen \/ blocklen is seedlen in our case, but might be\n    \/\/ different if seedlen isn't a multiple of blocklen\n    type blocks = (seedlen + blocklen -1)\/blocklen\n    \/\/ Encrypt v+1, v+2, ..., v + ceil (seedlen \/ blocklen)\n    (enc_result, _) = drbg_generate_internal `{blocks=blocks} drbg\n    \/\/ XOR the additional input data with the first bits of enc_result\n    data_xor = (take enc_result) ^ data\n    \/\/ Return the first half of data_xor as the new key, and the last half of it\n    \/\/ as the new value for v\n    result = { bytes_used = drbg.bytes_used + (`blocks * `blocksize)\n             , ctx = { key = take data_xor }\n             , v = drop data_xor\n             }\n\n\n\/* Example test vectors from\n\n   https:\/\/csrc.nist.gov\/Projects\/Cryptographic-Algorithm-Validation-Program\/Random-Number-Generators\n\n   for CTR_DRBG.\n*\/\n\n\/* [AES-128 no df]\n   [PredictionResistance = False]\n   [EntropyInputLen = 256]\n   [NonceLen = 0]\n   [PersonalizationStringLen = 0]\n   [AdditionalInputLen = 0]\n   [ReturnedBitsLen = 512] <- value of type parameter n\n*\/\n\n\n\ntestInstantiate0 = {entropy = 0xed1e7f21ef66ea5d8e2a85b9337245445b71d6393a4eecb0e63c193d0f72f9a9,\n                    pString = zero : [0],\n                        Key = 0xb5fc83ef1518da3cb85598ee9795001e,\n                         \tV = 0x58f90cf75af84f221514db847ec007d1}\n\ntestInstantiatedrbg0 = drbg_instantiate`{ps_size=0} testInstantiate0.entropy testInstantiate0.pString\n\ntestInstantiate0Pass = testInstantiatedrbg0.v == testInstantiate0.V \/\\ testInstantiatedrbg0.ctx.key == testInstantiate0.Key\n\ntestReseed0 = {entropyReseed = 0x303fb519f0a4e17d6df0b6426aa0ecb2a36079bd48be47ad2a8dbfe48da3efad,\n            \t           Key = 0x577a79cc512258c3e255fcf3f4cf0c1a,\n                        \t V = 0x531599fd616f33678192928bf771bb2b}\n\ntestReseed0Pass = drbgreseed.v == testReseed0.V \/\\ drbgreseed.ctx.key == testReseed0.Key\n                where drbgreseed = drbg_reseed`{ps_size=0} testInstantiatedrbg0 testReseed0.entropyReseed zero\n\ntestGenerate0 = {\tKey = 0xac373fb3773597b0d6cb6f37e6b59293,\n                \tV   = 0xcd9bf115d35c60cbf7f2ebac8e43f53b}\n\ntestGeneratedrbg0 = (drbg_generate`{n=512} testInstantiatedrbg0 testReseed0.entropyReseed True).1\n\ntestGenerate0Pass = testGeneratedrbg0.v == testGenerate0.V \/\\ testGeneratedrbg0.ctx.key == testGenerate0.Key\n\ntestGenerateSnd0 = {returnedBits = 0xf80111d08e874672f32f42997133a5210f7a9375e22cea70587f9cfafebe0f6a6aa2eb68e7dd9164536d53fa020fcab20f54caddfab7d6d91e5ffec1dfd8deaa,\n                 \tKey = 0x964c57946a104aa93fc3c2137bb9bc11,\n                 \tV   = 0x9d58008033ac007c9ead254bfa8de2b6}\n\ntestGenerateSnd0Pass = and [ result == testGenerateSnd0.returnedBits\n                           , drbg.ctx.key == testGenerateSnd0.Key\n                           , drbg.v == testGenerateSnd0.V ]\n                     where (result,drbg) = drbg_generate`{n=512} testGeneratedrbg0 zero False\n\n\nproperty testsPass = and [testInstantiate0Pass, testReseed0Pass, testGenerate0Pass, testGenerateSnd0Pass]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/DilithiumR1Int.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the DilithiumR1Int signature scheme implementation in the provided Cryptol module. Include properties that check the key generation function produces consistent keys for a fixed seed, the Sign function produces valid signatures that pass the Verify function, and that the polynomial operations (NTT, inverse NTT, addition, subtraction) satisfy their algebraic properties. Also specify properties to validate the packing and unpacking functions maintain data integrity."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::DilithiumR1Int where\n\nimport Primitive::Keyless::Hash::keccak as SHA3\nimport Common::utils\nimport Primitive::Asymmetric::Signature::testDilithium\nimport Primitive::Asymmetric::Signature::signFinal\n\nimport Primitive::Asymmetric::Signature::testCase2\n\n\n\/\/ Recommended Parameters\ntype q = 8380421\ntype n = 256 \ntype k = 5\ntype l = 4\nd      = 14\nwc     = 60\ngamma1 = ((`q : Integer) - 1) \/ 16 \ngamma2 = (gamma1 \/ 2)\neta    = 5\nbeta   = 275\nomega  = 96 : Integer\nqbits  = 23\n\/\/POLZ_SIZE_PACKED = ((`n*(qbits - 3))\/8)\n\/\/SIG_SIZE_PACKED = (`l*POLZ_SIZE_PACKED + (omega + `k) + (`n\/8 + 8))\n\n\n\n\/\/ Parameters for Number Theoretic Transform (NTT)\nrootOfUnity    = 1753 : (Z q)\nrootOfUnityInv = 731434 : (Z q)\nninv           = 8347681 : (Z q)\n\n\/\/ Integer polynomials; a superset of ring R referenced in specification\ntype intPoly        = [n]Integer\ntype intPolyVec dim = [dim]intPoly\n\n\/\/ Polynomials; a superset of ring R_q referenced in specification\ntype poly        = [n](Z q) \/\/ This is R_q, actually defines a super set of R_q\ntype polyVec dim = [dim]poly \n\n\/\/ Polynomials in NTT representation\ntype nttPoly          = [n](Z q)\ntype nttVec dim       = [dim]nttPoly\ntype nttMat dim1 dim2 = [dim1](nttVec dim2)\n\n\n\ntype PublicKey = {rho : [256], t1 : intPolyVec k} \ntype SecretKey = {rho : [256]\n                 , K  : [256]\n                 , tr : [384]\n                 , s1 : polyVec l\n                 , s2 : polyVec k\n                 , t0 : intPolyVec k}\n\n\n\/* Generate public and private keys *\/\nGen : [256] -> (PublicKey,SecretKey)\nGen seed = (pk, sk)\n    where\n      randoms = split`{3} (join (SHA3::toBytes (take`{768} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))\n      (rho, rho', K) = (randoms@0, randoms@1, randoms@2)\n      A       = ExpandA rho\n      s1      = PolyUniformEtaV`{dim=l} rho' zero\n      s2      = PolyUniformEtaV`{dim=k} rho' (zero + `l)\n      s1ntt   = map ntt s1\n      As1     = map nttinv (nttMatMul A s1ntt)\n      t       = paddV As1 s2\n      (t1,t0) = Power2RoundV t\n      tr      = CRH (rho#(pack_t1 t1))\n      pk      = { rho = rho, t1 = t1}\n      sk      = { rho = rho, K = K, tr = tr, s1 = s1, s2 = s2, t0 = t0}\n\n\/\/ Known Answer Test\n\/\/ To check this property, it is necessary to import testDilithium\n\ntest_key_gen = (pk.rho#(pack_t1 pk.t1) == testCase0.pk)\n\/\/\/\\\n  \/\/  ((sk.rho#sk.K#sk.tr#(pack_polyeta sk.s1)#(pack_polyeta sk.s2)#(pack_t0 sk.t0)) == testCase0.sk)\n    where\n    seed     = 0x7c9935a0b07694aa0c6d10e4db6b1add2fd81a25ccb148032dcd739936737f2d\n    (pk, sk) = Gen seed\n\n\/* Generate signature for message M *\/      \nSign : {mbytes} (fin mbytes, mbytes>=1) => SecretKey -> [mbytes*8] -> (polyVec l, [k][n], poly)\nSign sk M = (final_state.z, h, nttinv final_state.c')\n     where\n      A     = ExpandA sk.rho \/\/checked\n      mu    = CRH`{b=48+mbytes} (sk.tr#M) \/\/ checked\n      kappa = zero:Integer\n      s1'   = map ntt sk.s1 \/\/checked\n      s2'   = map ntt sk.s2 \/\/ checked\n      t0'   = map ntt (IPVtoPV sk.t0) \/\/checked\n\n      init : sign_var_types\n      init = {z=zero,r0=zero,r1=zero,t0'=t0',c'=zero,w=zero,w1=zero\n             ,s1'=s1',s2'=s2',cs2=zero,K=sk.K,mu=mu,A=A,kappa=kappa}\n\n      final_state = dowhile sign_condition sign_body init\n      ct0         = map nttinv (nttVecConstMul final_state.c' final_state.t0')\n      h           = MakeHintV (psubV zero ct0\n                              ,paddV (psubV final_state.w final_state.cs2) (ct0)\n                              ,2*gamma2\n                              )\n\nprivate\n\n    type sign_var_types = { z   : polyVec l\n                          , r0  : intPolyVec k\n                          , r1  : intPolyVec k\n                          , t0' : nttVec k\n                          , c'  : nttPoly\n                          , w   : polyVec k\n                          , w1  : intPolyVec k\n                          , s1' : nttVec l\n                          , s2' : nttVec k\n                          , cs2 : polyVec k\n                          , K   : [256]\n                          , mu  : [384]\n                          , A   : nttMat k l\n                          , kappa: Integer}\n\n\n    sign_condition : sign_var_types -> Bit\n    sign_condition sv = fail1 \\\/ fail2 \n                   where\n                    fail1 = ((infNormPolyVec (PVtoIPV sv.z)) >= (gamma1-beta))\n                            \\\/ ((infNormPolyVec sv.r0) >= (gamma2-beta))\n                            \\\/ (sv.r1 != sv.w1)\n                    fail2 = ((infNormPolyVec (PVtoIPV ct0)) >= gamma2) \n                            \\\/ ( (foldl (+) 0 (map ones h)) > omega )\n                    ct0   = map nttinv (nttVecConstMul sv.c' sv.t0')\n                    h     = MakeHintV (psubV zero ct0\n                                      ,paddV (psubV sv.w sv.cs2) (ct0)\n                                      ,2*gamma2\n                                      )\n\n\n    sign_body : sign_var_types -> sign_var_types\n    sign_body sv = {z=z,r0=r0,r1=r1,t0'=sv.t0',c'=c',w=w,w1=w1,s1'=sv.s1',s2'=sv.s2',\n                   cs2=cs2,K=sv.K,mu=sv.mu,A=sv.A,kappa=(sv.kappa+1)}\n              where\n                y   = ExpandMask(sv.K,sv.mu,sv.kappa)\/\/ checked\n                y'  = map ntt y \/\/ checked\n                w   = map nttinv (nttMatMul sv.A y') \/\/ checked\n                w1  = HighBitsV (w, 2 * gamma2) \/\/ checked\n                c'  = ntt ( H (sv.mu,w1) )                 cs1 = map nttinv (nttVecConstMul c' sv.s1')\n                cs2 = map nttinv (nttVecConstMul c' sv.s2')\n                z   = paddV y cs1\n                (r1, r0) = DecomposeV (psubV w cs2, 2 * gamma2)\n\n\n\n\nVerify : {mbytes} (fin mbytes, mbytes>=1) => PublicKey -> [mbytes*8] -> (polyVec l, [k][n], poly) -> Bit\nVerify pk M (z, h, c) = crit1 && crit2 && crit3\n       where\n        A        = ExpandA pk.rho\n        mu       = CRH`{b=48+mbytes} ((CRH (pk.rho#(pack_t1 pk.t1)))#M)\n        zntt     = map ntt z\n        t1ntt    = map ntt (IPVtoPV pk.t1)\n        ct1ntt   = nttVecConstMul (psub zero c) t1ntt\n        ct1ntt2d = map (\\p -> map (\\x -> x*(2^^d)) p) ct1ntt \n        Az       = nttMatMul A zntt\n        w1'      = UseHintV (h, paddV Az ct1ntt2d, 2*gamma2)\n        zint     = PVtoIPV z\n        zinf     = infNormPolyVec zint\n        crit1    = zinf < gamma1 - beta\n        crit2    = c == H(mu,w1')\n        crit3    = (foldl (+) 0 (map ones h)) <= omega\n\n\n\nprivate\n    pack_w : intPolyVec k -> [4*n*k]\n    pack_w w = join [pack_poly p | p <- wBV ]\n                where\n                wBV = map (\\p -> map (\\x -> fromInteger x:[8]) p) w\n\n                pack2 : [2][8] -> [8]\n                pack2 xs = xs@0 || (xs@1 << 4)\n\n                pack_poly p = join [ pack2 xs | xs <- split p : [128][2][_] ]\n\n    pack_polyeta : {m} (fin m, m >= 1) =>  polyVec m -> [4*n*m]\n    pack_polyeta s = join [ join [elt p i | i <- [0..(n\/2)-1]:[_][8] ] | p <- s ]\n                 where\n                  elt : poly -> [8] -> [8]\n                  elt p i = (c (fromZ`{q} (p@(2*i+0)))) || ((c (fromZ`{q} (p@(2*i+1)))) << 4)\n                  c : Integer -> [8]\n                  c num = if num > eta then fromInteger (`q + eta - num) else fromInteger (eta - num)\n\n    pack_t0 : intPolyVec k -> [k*3584]\n    pack_t0 t0 = join [ pack_poly p | p <- t0 ]\n            where\n              tmp : intPoly -> [8] -> [8] -> [32]\n              tmp p i j = fromInteger (2^^13 - p@(4*i+j))\n\n              pack_poly : intPoly -> [3584]\n              pack_poly p = join [ join [drop`{24} (tmp p i 0),\n                         drop`{24} (((tmp p i 0) >> 8) || ((tmp p i 1) << 6)),\n                         drop`{24} ((tmp p i 1) >> 2),\n                         drop`{24} (((tmp p i 1) >> 10) || ((tmp p i 2) << 4)),\n                         drop`{24} ((tmp p i 2) >> 4),\n                         drop`{24} (((tmp p i 2) >> 12) || ((tmp p i 3) << 2)),\n                         drop`{24} ((tmp p i 3) >> 6)\n                         ] | i <- [0..(n\/4-1)] ]\n\n\n    \/\/ d must be 14 for this to work, and n must be 256\n    pack_t1 : intPolyVec k -> [k*288*8]\n    pack_t1 t1 = join [pack_poly p | p <- t1BV]\n            where\n              t1BV = map (\\p -> map (\\x -> fromInteger x:[9]) p) t1\n\n              pack8 : [8][9] -> [9][8]\n              pack8 xs = map drop`{1} [ xs@0 && zero#0xFF\n                                      , xs@0 >> 8 || ((xs@1 && zero#0x7F) << 1)\n                                      , xs@1 >> 7 || ((xs@2 && zero#0x3F) << 2)\n                                      , xs@2 >> 6 || ((xs@3 && zero#0x1F) << 3)\n                                      , xs@3 >> 5 || ((xs@4 && zero#0x0F) << 4)\n                                      , xs@4 >> 4 || ((xs@5 && zero#0x07) << 5)\n                                      , xs@5 >> 3 || ((xs@6 && zero#0x03) << 6)\n                                      , xs@6 >> 2 || ((xs@7 && zero#0x01) << 7)\n                                      , xs@7 >> 1\n                                      ]\n              pack_poly p = join [join (pack8 xs) | xs <- split p : [32][8][_]]\n\n    \/*pack_sig : (polyVec l, [k][n], poly) -> [SIG_SIZE_PACKED]\n    pack_sig (z, h, c) =\n            where s0 = polyz_pack (z)\n                  s1 = encode (h)\n                  s2 = encode (c)\n    polyz_pack : poly ->[n*qbits]\n    polyz_pack a = [  | i <- [0..n\/2] ] *\/\n\n    \/\/ Only works when n=256\n    PolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [8] -> polyVec dim\n    PolyUniformEtaV rho nonce = [PolyUniformEta rho (nonce + j) | j <- [0..(dim-1)]:[dim][8]]\n\n    PolyUniformEta : [256] -> [8] -> poly\n    PolyUniformEta rho nonce = map (\\x -> eta - x) (map BVtoZ (take`{n} withinEta))\n                   where\n                    seed = rho#nonce\n                    randoms = ((join (SHA3::toBytes (take`{2*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))#zero)\n                    withinEta = randomsInRangeDouble genS (2*eta) randoms\n\n                    genS : [8] -> [2][4]\n                    genS byte = [t0, t1]\n                         where\n                          t0 = drop`{4} (byte && 0x0F)\n                          t1 = drop`{4} (byte >> 4)\n\n\n\n    H : ([384],intPolyVec k) -> poly\n    H (mu,w) = map fromInteger (SampleInBall ss samples)\n      where\n        w_packed = pack_w w\n        randoms  = join (SHA3::toBytes (take`{4352} (SHA3::SHAKE256 (join (SHA3::toBytes (mu#w_packed))))))\n        ss       = take`{60}(reverse (join (reverse (split (take`{64} randoms):[8][8]))))\n\n        extByte : [8] -> [8]\n        extByte x = x\n\n        samples : [60][8]\n        samples = take`{60} (randomsInRanges extByte [196..255] (drop`{64} randoms#zero))\n\n\n    SampleInBall : [60] -> [60][8] -> [256]Integer\n    SampleInBall signs jsamples = ys ! 0\n                  where\n                  ys = [ zero:[256]Integer ]\n                        # [ if i==j then update y i ((-1:Integer)^^(toInteger [s]))\n                            else updates y [j,i] [(-1:Integer)^^(toInteger [s]),y@j] | i <- [196..255]\n                                                                      | j <- jsamples\n                                                                      | s <- signs\n                                                                      | y <- ys\n                          ]\n\n\n    ExpandMask : ([256], [384], Integer) -> polyVec l\n    ExpandMask  (K, mu, kappa) = [samplePoly K mu kappa i `l | i <- [0..(l-1)] ]\n\n\n    samplePoly : [256] -> [384] -> Integer -> Integer -> Integer -> poly\n    samplePoly K mu kappa i dim = [fromInteger (`q + gamma1 - 1 - (toInteger vj)) | vj <- coeffs]\n                where\n                upper      = fromInteger (2*gamma1-2) : [20]\n                kappaBytes = join (reverse (split (fromInteger (dim*kappa+i):[16]):[2][8])) \/\/ LEB order\n                s          = join (SHA3::toBytes (take`{5*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes (K#mu#kappaBytes)))))) \/\/ checked\n                coeffs     = take`{n} (randomsInRangeDouble extractPolyElt upper (s#zero))\n\n\n    extractPolyElt : [40] -> [2][20]\n    extractPolyElt bits = [int1, int2]\n                    where\n                    [b0,b1,b2,b3,b4] = [(zero#b):[20] | b <- split bits : [5][8]]\n                    int1 = b2'*2^^16 + b1*2^^8 +  b0\n                    int2 = b4*2^^12 + b3*2^^4 +  b2''\n                    b2'  = b2 && 15\n                    \/\/b2'' = b2\/(16:[20])\n                    b2'' = b2\/16\n    \/\/ seed should be in little endian byte order\n    CRH : {b} (fin b, b>=1) => [b*8] -> [384]\n    CRH seed = join (SHA3::toBytes (take`{48*8} (SHA3::SHAKE256 (join (SHA3::toBytes seed)))))\n\n\n    ExpandA : [256] -> [k][l]nttPoly \n    ExpandA rho = [ [elt i j | j <- [0..(l-1)] ] |  i <- [0..(k-1)] ]\n            where\n              elt i j = matrixPoly rho i j\n\n\n    matrixPoly : [256] -> [width k] -> [width l] -> nttPoly\n    matrixPoly rho i j = take`{n} [ BVtoZ elt | elt <- randomElts ]\n                where\n                randomElts = randomsInRange extractMatElt ((>=) (`q)) (s#zero)\n                s          = join (SHA3::toBytes (take`{6720} (SHA3::SHAKE128 (join (SHA3::toBytes (rho#b))))))\n                b          = 16*(zero#j:[8])+(zero#i:[8])\n\n\n    extractMatElt : [24] -> [24]\n    extractMatElt rands = zero#(2^^16 * b2' + 2^^8 * b1 + b0):[24]\n                    where\n                      [b0, b1, b2] = [(zero#b):[23] | b <- split`{3} rands]\n                      b2' = (2^^23-1) && b2 \/\/ Typo in paper; following C implementation\n\n\n    \/*\n\n      Supporting Algorithms; see Figure 3\n\n    *\/\n\n    Power2Round : Integer -> (Integer,Integer) -> (Integer,Integer)\n    Power2Round q (r,d') = ((r'-r0)\/2^^d',r0)\n                where r' = r % q\n                      r0 = centered_mod r' (2^^d')\n\n    Power2RoundV : {dim} (fin dim, dim >= 1) => polyVec dim -> ([dim]intPoly,[dim]intPoly)\n    Power2RoundV v = unzip (map polyPower2Round v)\n                  where\n                  polyPower2Round p = unzip [ Power2Round `q ( (fromZ r ) ,d)\n                                            | r <- p\n                                            ]\n\n    Decompose : Integer -> (Integer,Integer) -> (Integer,Integer)\n    Decompose q (r,a) = if (r' - r0) == (q - 1) then (0, r0 - 1)\n                        else ((r' - r0) \/ a, r0)\n              where r' = r % q\n                    r0 = centered_mod r' a\n\n    DecomposeV : (polyVec k , Integer) -> (intPolyVec k, intPolyVec k)\n    DecomposeV (r,a) = unzip [ DecomposePoly p | p <- r ]\n                where\n                DecomposePoly p = unzip [Decompose `q (fromZ x,a) | x <- p]\n\n    HighBits : Integer -> (Integer,Integer) -> Integer\n    HighBits q (r,a) = (Decompose q (r,a)).0\n\n    HighBitsV : (polyVec k , Integer) -> intPolyVec k\n    HighBitsV (r,a) = r1\n              where\n                (r1,r0) = DecomposeV (r,a)\n\n\n    LowBits : Integer -> (Integer,Integer) -> Integer\n    LowBits q (r,a) = (Decompose q (r,a)).1\n\n\n    MakeHint : Integer -> (Integer,Integer,Integer) -> Bit\n    MakeHint q (z,r,a) = r1 != v1\n              where r1 = HighBits q (r,a)\n                    v1 = HighBits q (r + z,a)\n\n    MakeHintV : (polyVec k, polyVec k, Integer) -> [k][n]\n    MakeHintV (z,r,a) = [[x1 != x2 | x1 <- p1 | x2 <- p2] | p1 <- r1 | p2 <- v1]\n              where\n                r1 = HighBitsV (r,a)\n                v1 = HighBitsV (polyVecSum z r,a)\n\n\n    UseHint : Integer -> (Bit,Integer,Integer) -> Integer\n    UseHint q (h,r,a) = if h then r1' else r1\n            where\n              m        = (q - 1) \/ a\n              (r1, r0) = Decompose q (r, a)\n              r1'      = if r0 > 0 then (r1 + 1) % m else (r1 - 1) % m\n\n\n    UseHintV : ([k][n], polyVec k, Integer) -> intPolyVec k\n    UseHintV (hvec, rvec, a) = [polyUseHint hpoly rpoly\n                                  | hpoly <- hvec\n                                  | rpoly <- rvec\n                                  ]\n                where\n                polyUseHint hpoly rpoly = [ UseHint `q (h,fromZ r,a)\n                                          | h <- hpoly\n                                          | r <- rpoly\n                                          ]\n\n\n\n\n    \/*\n\n      Utility functions\n\n    *\/\n\n    ones : {a} (fin a, a >= 1) => [a] -> Integer\n    ones bv = foldl (+) 0 bva\n          where\n          bva = map toInteger (split bv:[_][1])\n\n    IPVtoPV : {dim} (fin dim, dim >= 1) => intPolyVec dim -> polyVec dim\n    IPVtoPV intp = map (\\p -> map fromInteger p) intp\n\n\n    PVtoIPV : {dim} (fin dim, dim >= 1) => polyVec dim -> intPolyVec dim\n    PVtoIPV pvec = map (\\p -> map fromZ p) pvec\n\n\n    centered_mod : Integer -> Integer -> Integer\n    centered_mod x n = if r > (n\/2) then r - n\n                        else r\n                  where r = x % n\n\n\n    randomsInRange : {a} (fin a) => ([a]-> [a]) -> ([a] -> Bit) -> [inf] -> [inf][a]\n    randomsInRange createElt upperCrit randoms = if (upperCrit elt )\n                                    then  [ elt ]#(randomsInRange createElt upperCrit randomTail)\n                                    else randomsInRange createElt upperCrit randomTail\n                                    where\n                                    elt        = createElt (take`{a} randoms) \n                                    randomTail = drop`{a} randoms\n\n    randomsInRanges : {a,m} (fin a,fin m, m>=1) => ([a]-> [a]) -> [m][a] -> [inf] -> [inf][a]\n    randomsInRanges createElt uppers randoms =\n                    if elt <= head uppers\n                    then  [ elt ]#(randomsInRanges createElt uppersRotate randomTail)\n                    else randomsInRanges createElt uppers randomTail\n                    where\n                      elt          = createElt (take`{a} randoms) \n                      randomTail   = drop`{a} randoms\n                      uppersRotate = uppers <<< 1\n\n\n    randomsInRangeDouble : {a} (fin a) => ([2*a]-> [2][a]) -> [a] -> [inf] -> [inf][a]\n    \/*randomsInRangeDouble createElt upper randoms =\n                    if (elts@0 <= upper) \/\\ (elts@1 <= upper)\n                    then  elts#(randomsInRangeDouble createElt upper randomTail)\n                    else\n                      if (elts@0 <= upper)\n                      then [ elts@0 ]#(randomsInRangeDouble createElt upper randomTail)\n                      else\n                        if (elts@1 <= upper)\n                        then [ elts@1 ]#(randomsInRangeDouble createElt upper randomTail)\n                        else randomsInRangeDouble createElt upper randomTail\n                    where\n                      elts       = createElt (take`{2*a} randoms) \n                      randomTail = drop`{2*a} randoms*\/\n\/\/ Correction and checked with the C code\n    randomsInRangeDouble createElt upper randoms =\n                    if (elts@1 <= upper) then [elts@1, elts@1] # (randomsInRangeDouble createElt upper randomTail)\n                    else (randomsInRangeDouble createElt upper randomTail)\n                    where\n                    elts       = createElt (take`{2*a} randoms)\n                    randomTail = drop`{2*a} randoms\n\n    \/*\n\n      Supporting polynomial and polynomial vector functions\n\n    *\/\n\n    ntt : poly -> nttPoly\n    ntt p = nttp\n         where\n          r k = rootOfUnity^^k\n          exponents = join [ [BVtoZ`{q} i, (256+(BVtoZ`{q} i))] | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n          nttp = [ sum [ p@idx * (r k)^^(i) | idx<-[0..(n-1)]:[n][width n] | i<-[0..(n-1)]:[n](Z q)]\n                 | k <- exponents \n                 ]\n\n    nttinv : nttPoly -> poly\n    nttinv p' = p\n           where\n            pu = reorder p'\n            r' i = rootOfUnityInv^^(i*2)\n            p = [ninv*(rootOfUnityInv^^i) * sum [pu@jdx * (r' ((i*j)))\n                                                    | jdx<-[0..(n-1)]:[n][width n]\n                                                    | j<-[0..(n-1)]:[n](Z q)\n                                                    ]\n                | i <- [0..255]\n                ]\n\n    \/\/ Dilithium uses a non-standard ordering of elements in the NTT domain; this function reorders the elements.\n    reorder : nttPoly -> nttPoly\n    reorder a = join [ [a1 @ i, a2 @ i] | i <- [0..127]:[_][8] ]\n            where\n              a1 = a @@ [ (i-1)\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n              a2 = reverse (a @@ [ (511 - (zero#i):[9])\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ])\n\n\n\n    \/\/ Operations on NTT polynomials\n\n    nttMatMul : {dim1,dim2} (fin dim1,fin dim2) => nttMat dim1 dim2 -> nttVec dim2 -> nttVec dim1\n    nttMatMul mat vec = [ nttDotProduct v vec | v <- mat ]\n\n    nttDotProduct : {dim} (fin dim) => nttVec dim -> nttVec dim -> nttPoly\n    nttDotProduct v1 v2 = foldl padd (zero:nttPoly) [ nttPolyMult p1 p2 | p1 <- v1 | p2 <- v2 ]\n\n    nttPolyMult : nttPoly -> nttPoly -> nttPoly\n    nttPolyMult p1 p2 = [ x * y | x <- p1 | y <- p2]\n\n    nttVecConstMul : {dim} (fin dim) => nttPoly -> nttVec dim -> nttVec dim\n    nttVecConstMul c v = map (nttPolyMult c) v\n\n    polyVecSum :  {dim} (fin dim) => polyVec dim -> polyVec dim -> polyVec dim\n    polyVecSum v1 v2 = map nttinv (paddV v1' v2')\n                where\n                v1' = map ntt v1\n                v2' = map ntt v2\n\n    \/\/ Polynomial addition and subtraction\n    padd : [n](Z q) -> [n](Z q) -> [n](Z q)\n    padd p1 p2 = [ x + y | x <- p1 | y <- p2 ]\n\n\n    psub : [n](Z q) -> [n](Z q) -> [n](Z q)\n    psub p1 p2 = [ x - y | x <- p1 | y <- p2 ]\n\n\n    psubV : {dim} (fin dim) => [dim][n](Z q) -> [dim][n](Z q) -> [dim][n](Z q)\n    psubV v1 v2 = zipWith psub v1 v2\n\n\n    paddV : {dim} (fin dim) => [dim][n](Z q) -> [dim][n](Z q) -> [dim][n](Z q)\n    paddV v1 v2 = zipWith padd v1 v2\n\n\n\n    \/\/ Aux functions\n\n    infNorm : Integer -> Integer\n    infNorm x = abs (centered_mod x `q)\n\n    infNormPoly : intPoly -> Integer\n    infNormPoly p = foldl max 0 p_centered\n                where\n                  p_centered = map infNorm p\n\n    infNormPolyVec : {dim} (fin dim, dim>=1) => intPolyVec dim -> Integer\n    infNormPolyVec v = foldl max 0 (map infNormPoly v)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/ECDSA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the ECDSA signature scheme implementation in the given module. Specifically, specify properties that verify: (1) the correctness of the sign function by checking that signatures produced with a private key and nonce verify correctly with the corresponding public key; (2) the correctness of the verify function by ensuring it accepts valid signatures and rejects invalid ones; (3) the consistency of the private_to_public function mapping private keys to public keys; and (4) the correctness of the elliptic curve arithmetic functions (ec_add, ec_double, ec_mult, ec_twin_mult) by specifying algebraic properties they should satisfy. Ensure these properties can be used with Cryptol's :check or :prove commands to validate the implementation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\nimport Common::utils\n\nsign : Z q -> Z q -> Z p -> (Z q, Z q)\nsign d z k = (r, s)\n  where {x = x1, y = _} = ec_affinify (ec_mult k G)\n        r = ZtoZ x1\n        s = (mp_mod_inv (ZtoZ k)) * (z + r*d)\n\nprivate_to_public : Z q -> ProjectivePoint p\nprivate_to_public d = ec_mult (ZtoZ d) G\n\nverify : Z q -> ProjectivePoint p -> (Z q, Z q) -> Bit\nverify z Q (r, s) = r == ZtoZ j\n  where w = mp_mod_inv s\n        u1 = z * w\n        u2 = r * w\n        {x = x1, y = _, z = z1} = ec_twin_mult (ZtoZ u1) G (ZtoZ u2) Q\n        j = x1 * (mp_mod_inv z1)^^2\n\n\/\/Examples\nG_compress R = ec_compress (ec_affinify G) == R\n\nfull_add_example : AffinePoint p -> AffinePoint p -> AffinePoint p -> Bit\nfull_add_example R S T =\n  ec_affinify (ec_full_add (ec_projectify S) (ec_projectify T)) == R\n\nfull_subtract_example : AffinePoint p -> AffinePoint p -> AffinePoint p -> Bit\nfull_subtract_example R S T =\n  ec_affinify (ec_full_sub (ec_projectify S) (ec_projectify T)) == R\n\ndouble_example : AffinePoint p -> AffinePoint p -> Bit\ndouble_example R S =\n  ec_affinify (ec_double (ec_projectify S)) == R\n\nscalar_multiply_example : AffinePoint p -> AffinePoint p -> Z p -> Bit\nscalar_multiply_example R S d =\n  ec_affinify (ec_mult d (ec_projectify S)) == R\n\njoint_scalar_multiply_example : AffinePoint p -> AffinePoint p -> AffinePoint p -> Z p -> Z p -> Bit\njoint_scalar_multiply_example R S T d e =\n  ec_affinify (ec_twin_mult d (ec_projectify S) e (ec_projectify T)) == R\n\nmp_mod_sqrt_correct x = (mp_mod_sqrt (x ^^ 2)) ^^ 2 == (x ^^ 2)\n\n\/\/ This only holds for proper affine points\naffine_decompress_correct : AffinePoint p -> Bit\naffine_decompress_correct R = ~err \/\\ R == R'\n  where\n    (R',err) = ec_decompress (ec_compress`{width p+2} R)\n\n\/\/ Use the generator G to produce random affine points and test\n\/\/ the compression\/decompression algorithm\ndecompress_correct : Z p -> Bit\nproperty decompress_correct k = affine_decompress_correct (ec_affinify (ec_mult k G))\n\nparameter\n\n  type p : #\n  type constraint Constraints p\n\n  b : Z p\n\n  G : ProjectivePoint p\n\n  type q : #\n  type constraint Constraints q\n\n  mp_mod_sqrt : Z p -> Z p\n\nprivate\n\n  type constraint Constraints a = (fin a, isOdd a, a >= 4)\n\n  type AffinePoint a = {x : Z a, y : Z a}\n  type ProjectivePoint a = {x : Z a, y : Z a, z : Z a}\n\n  ec_projectify : {a} (Constraints a) => AffinePoint a -> ProjectivePoint a\n  ec_projectify S = {x = S.x, y = S.y, z = 1}\n\n  ec_affinify : {a} (Constraints a) => ProjectivePoint a -> AffinePoint a\n  ec_affinify S = if S.z == 0 then error \"Cannot affinify the point at infinity\"\n                  else {x = lambda^^2 * S.x, y =  lambda^^3 * S.y}\n    where\n      lambda = mp_mod_inv S.z\n\n  ec_compress : {r} (fin r, r >= width p + 2) => AffinePoint p -> [r]\n  ec_compress S = (2 + (Sy % 2)) # Sx\n    where Sx = ZtoBV S.x : [width p]\n          Sy = ZtoBV S.y : [r - width p]\n\n  ec_decompress : {a} (fin a, a >= width p + 2) => [a] -> (AffinePoint p, Bit)\n  ec_decompress S = ({x = Rx, y = Ry}, err)\n    where c  = toInteger (take S : [2])\n          Rx = BVtoZ (drop S : [a-2])\n          t0 = Rx ^^ 3 - (mul3 Rx) + b\n          t1 = mp_mod_sqrt t0\n          err = t1 ^^ 2 != t0\n          Ry = if (fromZ t1)%2 == c%2 then t1 else -t1\n\n  ec_is_point_affine : AffinePoint p -> Bit\n  ec_is_point_affine S = S.y ^^ 2 == t\n    where t = S.x ^^ 3 - (mul3 S.x) + b\n\n  ec_double : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a\n  ec_double S =\n    if S.z == 0 then\n      {x = 1, y = 1, z = 0}             \/* 5: r <- (1,1,0) and return *\/\n    else\n      {x = r18, y = r23, z = r13}\n    where r7  = S.z ^^ 2                \/*  7: t4 <- (t3)^2 *\/\n          r8  = S.x - r7                \/*  8: t5 <- t1 - t4 *\/\n          r9  = S.x + r7                \/*  9: t4 <- t1 + t4 *\/\n          r10 = r9 * r8                 \/* 10: t5 <- t4 * t5 *\/\n          r11 = mul3 r10                \/* 11: t4 <- 3 * t5 *\/\n          r12 = S.z * S.y               \/* 12: t3 <- t3 * t2 *\/\n          r13 = mul2 r12                \/* 13: t3 <- 2 * t3 *\/\n          r14 = S.y ^^ 2                \/* 14: t2 <- (t2)^2 *\/\n          r15 = S.x * r14               \/* 15: t5 <- t1 * t2 *\/\n          r16 = mul4 r15                \/* 16: t5 <- 4 * t5 *\/\n          r17 = r11 ^^ 2                \/* 17: t1 <- (t4)^2 *\/\n          r18 = r17 - (mul2 r16)        \/* 18: t1 <- t1 - 2 * t5 *\/\n          r19 = r14 ^^ 2                \/* 19: t2 <- (t2)^2 *\/\n          r20 = mul8 r19                          r21 = r16 - r18                         r22 = r11 * r21                         r23 = r22 - r20                 ec_add : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a -> ProjectivePoint a\n  ec_add S T =\n    if r13 == 0 then\n      if r14 == 0 then\n        {x = 0, y = 0, z = 0}            else\n        {x = 1, y = 1, z = 0}          else\n      {x = r32, y = r37, z = r27}\n    where r9  = S.z ^^ 2           \/*  9: t7 <- (t3)^2 *\/\n          r10 = T.x * r9           \/* 10: t4 <- t4 * t7 *\/\n          r11 = S.z * r9           \/* 11: t7 <- t3 * t7 *\/\n          r12 = T.y * r11                    r13 = S.x - r10                    r14 = S.y - r12                    r22 = mul2 S.x - r13               r23 = mul2 S.y - r14               r27 = S.z * r13                    r28 = r13 ^^ 2                     r29 = r13 * r28          \/* 29: t4 <- t4 * t7 *\/\n          r30 = r22 * r28          \/* 30: t7 <- t1 * t7 *\/\n          r31 = r14 ^^ 2           \/* 31: t1 <- (t5)^2 *\/\n          r32 = r31 - r30          \/* 32: t1 <- t1 - t7 *\/\n          r33 = r30 - (mul2 r32)   \/* 33: t7 <- t7 - 2*t1 *\/\n          r34 = r14 * r33          \/* 34: t5 <- t5 * t7 *\/\n          r35 = r23 * r29          \/* 35: t4 <- t2 * t4 *\/\n          r36 = r34 - r35          \/* 36: t2 <- t5 - t4 *\/\n          r37 = half r36             ec_full_add : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a -> ProjectivePoint a\n  ec_full_add S T = \n    if S.z == 0 then T\n     | T.z == 0 then S\n     | R == {x = 0, y = 0, z = 0} then ec_double S\n     else R\n    where R = ec_add S T\n\n  ec_full_sub : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a -> ProjectivePoint a\n  ec_full_sub S T = R\n    where U = {x = T.x, y = -T.y, z = T.z}\n          R = ec_full_add S U\n\n  ec_mult : {a} (Constraints a) => Z a -> ProjectivePoint a -> ProjectivePoint a\n  ec_mult d S = if d == 0 then {x = 1, y = 1, z = 0}\n                 | d == 1 then S\n                 | S.z == 0 then {x = 1, y = 1, z = 0}\n                 else Rs!1\n    where S' = if S.z != 1 then ec_projectify (ec_affinify S) else S\n          k = ZtoBV d : [width a + 2]\n          h = k + k + k\n          Rs = [{x = 1, y = 1, z = 0}] # \/\/Here we start with 1 instead of S because we don't really know where the high-bit is\n               [ if hi && ~ki then ec_full_add RiDouble S\n                  | ~hi && ki then ec_full_sub RiDouble S\n                  else RiDouble\n                 where RiDouble = ec_double Ri\n               | ki <- k | hi <- h | Ri <- Rs ]\n\n  F : [5] -> [5]\n  F t = if (18 <= t) && (t < 22) then 9\n         | (14 <= t) && (t < 18) then 10\n         | (22 <= t) && (t < 24) then 11\n         | (4 <= t)  && (t < 12) then 14\n         else 12\n\n  ec_twin_mult : {a} (Constraints a) => Z a -> ProjectivePoint a -> Z a -> ProjectivePoint a -> ProjectivePoint a\n  ec_twin_mult d0 S d1 T = (states!0).0\n    where Sp = if S.z != 1 then ec_projectify (ec_affinify S) else S\n          Tp = if T.z != 1 then ec_projectify (ec_affinify T) else T\n          SpT = ec_full_add Sp Tp\n          SpTp = if SpT.z != 1 then ec_projectify (ec_affinify SpT) else SpT\n          SmT = ec_full_sub Sp Tp\n          SmTp = if SmT.z != 1 then ec_projectify (ec_affinify SmT) else SmT\n          e0  = ZtoBV d0 : [max 4 (width a)]\n          e1  = ZtoBV d1 : [max 4 (width a)]\n          c   = [[False, False] # take e0,\n                 [False, False] # take e1] : [2][6]\n          states = [({x = 1, y = 1, z = 0}, c)] #\n                   [ (Rk', [c0', c1'])\n                     where h0 = if c0@0 then 31 - tail c0 else tail c0\n                           h1 = if c1@0 then 31 - tail c1 else tail c1\n                           u0 = if h0 < (F h1) then 0 else if c0@0 then -1 else 1 : [2]\n                           u1 = if h1 < (F h0) then 0 else if c1@0 then -1 else 1 : [2]\n                           c0' = [(u0!=0) ^ c0@1] # drop c0 # [e0k]\n                           c1' = [(u1!=0) ^ c1@1] # drop c1 # [e1k]\n                           Rk' = if (u0 == -1) && (u1 == -1) then ec_full_sub RkDouble SpTp\n                                  | (u0 == -1) && (u1 ==  0) then ec_full_sub RkDouble Sp\n                                  | (u0 == -1) && (u1 ==  1) then ec_full_sub RkDouble SmTp\n                                  | (u0 ==  0) && (u1 == -1) then ec_full_sub RkDouble Tp\n                                  | (u0 ==  0) && (u1 ==  1) then ec_full_add RkDouble Tp\n                                  | (u0 ==  1) && (u1 == -1) then ec_full_add RkDouble SmTp\n                                  | (u0 ==  1) && (u1 ==  0) then ec_full_add RkDouble Sp\n                                  | (u0 ==  1) && (u1 ==  1) then ec_full_add RkDouble SpTp\n                                  else RkDouble\n                           RkDouble = ec_double Rk\n                   | (Rk, [c0, c1]) <- states\n                   | e0k <- drop`{4} e0 # (zero : [5])\n                   | e1k <- drop`{4} e1 # (zero : [5]) ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and properties of the ECDSA P-256 signature scheme as implemented in the given module. Include specifications for the prime field parameters, the base point G, the subgroup order q, and the modular square root function mp_mod_sqrt. Ensure the specification captures the correctness of modular arithmetic operations and the cryptographic properties required for secure signature generation and verification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::p256 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\ntype p = 115792089210356248762697446949407573530086143415290314195533631308867097853951\n\nb = 41058363725152142129326129780047268409114441015993725554835256314039467401291\n\nG = {x = 48439561293906451759052585252797914202762949526041747995844080717082404635286,\n     y = 36134250956749795798585127919587881956611106672985015071877198253568414405109,\n     z = 1}\n\ntype q = 115792089210356248762697446949407573529996955224135760342422259061068512044369\n\nmp_mod_sqrt : Z p -> Z p\nmp_mod_sqrt c = r'' ^^ (2 ^^ 94)\n  where t1  = (c ^^ 2) * c\n        t2  = (t1 ^^ (2 ^^ 2)) * t1\n        t3  = (t2 ^^ (2 ^^ 4)) * t2\n        t4  = (t3 ^^ (2 ^^ 8)) * t3\n        r   = (t4 ^^ (2 ^^ 16)) * t4\n        r'  = (r ^^ (2 ^^ 32)) * c\n        r'' = (r' ^^ (2 ^^ 96)) * c\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/ECDSA_tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the ECDSA elliptic curve operations and scalar multiplications for the P-192, P-224, P-256, P-384, and P-521 curves as defined in the ECDSA_tests module. Include properties that check point compression, affine decompression correctness, point addition, subtraction, doubling, scalar multiplication, joint scalar multiplication, and modular square root correctness for each curve."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::ECDSA_tests where\n\nimport Common::utils\n\nimport Primitive::Asymmetric::Signature::ECDSA::p192 as p192\nimport Primitive::Asymmetric::Signature::ECDSA::p224 as p224\nimport Primitive::Asymmetric::Signature::ECDSA::p256 as p256\nimport Primitive::Asymmetric::Signature::ECDSA::p384 as p384\nimport Primitive::Asymmetric::Signature::ECDSA::p521 as p521\n\n\n\/\/p192 tests\n\nproperty p192_G_compress = p192::G_compress 0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\n\np192_S = {x = BVtoZ 0xd458e7d127ae671b0c330266d246769353a012073e97acf8,\n          y = BVtoZ 0x325930500d851f336bddc050cf7fb11b5673a1645086df3b}\n\np192_T = {x = BVtoZ 0xf22c4395213e9ebe67ddecdd87fdbd01be16fb059b9753a4,\n          y = BVtoZ 0x264424096af2b3597796db48f8dfb41fa9cecc97691a9c79}\n\nproperty p192_decompress_S = p192::affine_decompress_correct p192_S\nproperty p192_decompress_T = p192::affine_decompress_correct p192_T\n\nproperty p192_full_add_example =\n  p192::full_add_example R p192_S p192_T\n  where R = {x = BVtoZ 0x48e1e4096b9b8e5ca9d0f1f077b8abf58e843894de4d0290,\n             y = BVtoZ 0x408fa77c797cd7dbfb16aa48a3648d3d63c94117d7b6aa4b}\n\nproperty p192_full_subtract_example =\n  p192::full_subtract_example R p192_S p192_T\n  where R = {x = BVtoZ 0xfc9683cc5abfb4fe0cc8cc3bc9f61eabc4688f11e9f64a2e,\n             y = BVtoZ 0x093e31d00fb78269732b1bd2a73c23cdd31745d0523d816b}\n\nproperty p192_double_example =\n  p192::double_example R p192_S\n  where R = {x = BVtoZ 0x30c5bc6b8c7da25354b373dc14dd8a0eba42d25a3f6e6962,\n             y = BVtoZ 0x0dde14bc4249a721c407aedbf011e2ddbbcb2968c9d889cf}\n\nproperty p192_scalar_multiply_example0 =\n  p192::scalar_multiply_example R p192_S d\n  where d = BVtoZ 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        R = {x = BVtoZ 0x1faee4205a4f669d2d0a8f25e3bcec9a62a6952965bf6d31,\n             y = BVtoZ 0x5ff2cdfa508a2581892367087c696f179e7a4d7e8260fb06}\n\np192_S' = {x = BVtoZ 0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012,\n           y = BVtoZ 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811}\n\nproperty p192_scalar_multiply_example1=\n    p192::scalar_multiply_example R p192_S' d\n    where d = BVtoZ 0xe14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3\n          R = {x = BVtoZ 0x07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6,\n               y = BVtoZ 0x76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477}\n\nproperty p192_joint_scalar_multiply_example =\n  p192::joint_scalar_multiply_example R p192_S p192_T d e\n  where d = BVtoZ 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        e = BVtoZ 0xc4be3d53ec3089e71e4de8ceab7cce889bc393cd85b972bc\n        R = {x = BVtoZ 0x019f64eed8fa9b72b7dfea82c17c9bfa60ecb9e1778b5bde,\n             y = BVtoZ 0x16590c5fcd8655fa4ced33fb800e2a7e3c61f35d83503644}\n\nproperty mp_mod_sqrt_192_correct = p192::mp_mod_sqrt_correct\n\n\n\/\/p224 tests\n\nproperty p224_G_compress = p224::G_compress 0x00000002b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\n\np224_S = {x = BVtoZ 0x6eca814ba59a930843dc814edd6c97da95518df3c6fdf16e9a10bb5b,\n          y = BVtoZ 0xef4b497f0963bc8b6aec0ca0f259b89cd80994147e05dc6b64d7bf22}\n\np224_T = {x = BVtoZ 0xb72b25aea5cb03fb88d7e842002969648e6ef23c5d39ac903826bd6d,\n          y = BVtoZ 0xc42a8a4d34984f0b71b5b4091af7dceb33ea729c1a2dc8b434f10c34}\n\nproperty p224_full_add_example =\n  p224::full_add_example R p224_S p224_T\n  where R = {x = BVtoZ 0x236f26d9e84c2f7d776b107bd478ee0a6d2bcfcaa2162afae8d2fd15,\n             y = BVtoZ 0xe53cc0a7904ce6c3746f6a97471297a0b7d5cdf8d536ae25bb0fda70}\n\nproperty p224_full_subtract_example =\n  p224::full_subtract_example R p224_S p224_T\n  where R = {x = BVtoZ 0xdb4112bcc8f34d4f0b36047bca1054f3615413852a7931335210b332,\n             y = BVtoZ 0x90c6e8304da4813878c1540b2396f411facf787a520a0ffb55a8d961}\n\nproperty p224_double_example =\n  p224::double_example R p224_S\n  where R = {x = BVtoZ 0xa9c96f2117dee0f27ca56850ebb46efad8ee26852f165e29cb5cdfc7,\n             y = BVtoZ 0xadf18c84cf77ced4d76d4930417d9579207840bf49bfbf5837dfdd7d}\n\nproperty p224_scalar_multiply_example =\n  p224::scalar_multiply_example R p224_S d\n  where d = BVtoZ 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        R = {x = BVtoZ 0x96a7625e92a8d72bff1113abdb95777e736a14c6fdaacc392702bca4,\n             y = BVtoZ 0x0f8e5702942a3c5e13cd2fd5801915258b43dfadc70d15dbada3ed10}\n\nproperty p224_joint_scalar_multiply_example =\n  p224::joint_scalar_multiply_example R p224_S p224_T d e\n  where d = BVtoZ 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        e = BVtoZ 0x54d549ffc08c96592519d73e71e8e0703fc8177fa88aa77a6ed35736\n        R = {x = BVtoZ 0xdbfe2958c7b2cda1302a67ea3ffd94c918c5b350ab838d52e288c83e,\n             y = BVtoZ 0x2f521b83ac3b0549ff4895abcc7f0c5a861aacb87acbc5b8147bb18b}\n\nproperty mp_mod_sqrt_224_correct = p224::mp_mod_sqrt_correct\n\n\n\/\/p256 tests\n\nproperty p256_G_compress = p256::G_compress 0x000000036b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\n\np256_S = {x = BVtoZ 0xde2444bebc8d36e682edd27e0f271508617519b3221a8fa0b77cab3989da97c9,\n          y = BVtoZ 0xc093ae7ff36e5380fc01a5aad1e66659702de80f53cec576b6350b243042a256}\n\np256_T = {x = BVtoZ 0x55a8b00f8da1d44e62f6b3b25316212e39540dc861c89575bb8cf92e35e0986b,\n          y = BVtoZ 0x5421c3209c2d6c704835d82ac4c3dd90f61a8a52598b9e7ab656e9d8c8b24316}\n\nproperty p256_full_add_example =\n  p256::full_add_example R p256_S p256_T\n  where R = {x = BVtoZ 0x72b13dd4354b6b81745195e98cc5ba6970349191ac476bd4553cf35a545a067e,\n             y = BVtoZ 0x8d585cbb2e1327d75241a8a122d7620dc33b13315aa5c9d46d013011744ac264}\n\nproperty p256_full_subtract_example =\n  p256::full_subtract_example R p256_S p256_T\n  where R = {x = BVtoZ 0xc09ce680b251bb1d2aad1dbf6129deab837419f8f1c73ea13e7dc64ad6be6021,\n             y = BVtoZ 0x1a815bf700bd88336b2f9bad4edab1723414a022fdf6c3f4ce30675fb1975ef3}\n\nproperty p256_double_example =\n  p256::double_example R p256_S\n  where R = {x = BVtoZ 0x7669e6901606ee3ba1a8eef1e0024c33df6c22f3b17481b82a860ffcdb6127b0,\n             y = BVtoZ 0xfa878162187a54f6c39f6ee0072f33de389ef3eecd03023de10ca2c1db61d0c7}\n\nproperty p256_scalar_multiply_example =\n  p256::scalar_multiply_example R p256_S d\n  where d = BVtoZ 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        R = {x = BVtoZ 0x51d08d5f2d4278882946d88d83c97d11e62becc3cfc18bedacc89ba34eeca03f,\n             y = BVtoZ 0x75ee68eb8bf626aa5b673ab51f6e744e06f8fcf8a6c0cf3035beca956a7b41d5}\n\nproperty p256_joint_scalar_multiply_example =\n  p256::joint_scalar_multiply_example R p256_S p256_T d e\n  where d = BVtoZ 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        e = BVtoZ 0xd37f628ece72a462f0145cbefe3f0b355ee8332d37acdd83a358016aea029db7\n        R = {x = BVtoZ 0xd867b4679221009234939221b8046245efcf58413daacbeff857b8588341f6b8,\n             y = BVtoZ 0xf2504055c03cede12d22720dad69c745106b6607ec7e50dd35d54bd80f615275}\n\nproperty mp_mod_sqrt_256_correct = p256::mp_mod_sqrt_correct\n\n\n\/\/p384 tests\n\nproperty p384_G_compress = p384::G_compress 0x00000003aa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\n\np384_S = {x = BVtoZ 0xfba203b81bbd23f2b3be971cc23997e1ae4d89e69cb6f92385dda82768ada415ebab4167459da98e62b1332d1e73cb0e,\n          y = BVtoZ 0x5ffedbaefdeba603e7923e06cdb5d0c65b22301429293376d5c6944e3fa6259f162b4788de6987fd59aed5e4b5285e45}\n\np384_T = {x = BVtoZ 0xaacc05202e7fda6fc73d82f0a66220527da8117ee8f8330ead7d20ee6f255f582d8bd38c5a7f2b40bcdb68ba13d81051,\n          y = BVtoZ 0x84009a263fefba7c2c57cffa5db3634d286131afc0fca8d25afa22a7b5dce0d9470da89233cee178592f49b6fecb5092}\n\nproperty p384_full_add_example =\n  p384::full_add_example R p384_S p384_T\n  where R = {x = BVtoZ 0x12dc5ce7acdfc5844d939f40b4df012e68f865b89c3213ba97090a247a2fc009075cf471cd2e85c489979b65ee0b5eed,\n             y = BVtoZ 0x167312e58fe0c0afa248f2854e3cddcb557f983b3189b67f21eee01341e7e9fe67f6ee81b36988efa406945c8804a4b0}\n\nproperty p384_full_subtract_example =\n  p384::full_subtract_example R p384_S p384_T\n  where R = {x = BVtoZ 0x6afdaf8da8b11c984cf177e551cee542cda4ac2f25cd522d0cd710f88059c6565aef78f6b5ed6cc05a6666def2a2fb59,\n             y = BVtoZ 0x7bed0e158ae8cc70e847a60347ca1548c348decc6309f48b59bd5afc9a9b804e7f7876178cb5a7eb4f6940a9c73e8e5e}\n\nproperty p384_double_example =\n  p384::double_example R p384_S\n  where R = {x = BVtoZ 0x2a2111b1e0aa8b2fc5a1975516bc4d58017ff96b25e1bdff3c229d5fac3bacc319dcbec29f9478f42dee597b4641504c,\n             y = BVtoZ 0xfa2e3d9dc84db8954ce8085ef28d7184fddfd1344b4d4797343af9b5f9d837520b450f726443e4114bd4e5bdb2f65ddd}\n\nproperty p384_scalar_multiply_example =\n  p384::scalar_multiply_example R p384_S d\n  where d = BVtoZ 0xa4ebcae5a665983493ab3e626085a24c104311a761b5a8fdac052ed1f111a5c44f76f45659d2d111a61b5fdd97583480\n        R = {x = BVtoZ 0xe4f77e7ffeb7f0958910e3a680d677a477191df166160ff7ef6bb5261f791aa7b45e3e653d151b95dad3d93ca0290ef2,\n             y = BVtoZ 0xac7dee41d8c5f4a7d5836960a773cfc1376289d3373f8cf7417b0c6207ac32e913856612fc9ff2e357eb2ee05cf9667f}\n\nproperty p384_joint_scalar_multiply_example =\n  p384::joint_scalar_multiply_example R p384_S p384_T d e\n  where d = BVtoZ 0xa4ebcae5a665983493ab3e626085a24c104311a761b5a8fdac052ed1f111a5c44f76f45659d2d111a61b5fdd97583480\n        e = BVtoZ 0xafcf88119a3a76c87acbd6008e1349b29f4ba9aa0e12ce89bcfcae2180b38d81ab8cf15095301a182afbc6893e75385d\n        R = {x = BVtoZ 0x917ea28bcd641741ae5d18c2f1bd917ba68d34f0f0577387dc81260462aea60e2417b8bdc5d954fc729d211db23a02dc,\n             y = BVtoZ 0x1a29f7ce6d074654d77b40888c73e92546c8f16a5ff6bcbd307f758d4aee684beff26f6742f597e2585c86da908f7186}\n\nproperty mp_mod_sqrt_384_correct = p384::mp_mod_sqrt_correct\n\n\n\/\/p521 tests\n\nproperty p521_G_compress = p521::G_compress 0x04c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\n\np521_S = {x = BVtoZ 0x000001d5c693f66c08ed03ad0f031f937443458f601fd098d3d0227b4bf62873af50740b0bb84aa157fc847bcf8dc16a8b2b8bfd8e2d0a7d39af04b089930ef6dad5c1b4,\n          y = BVtoZ 0x00000144b7770963c63a39248865ff36b074151eac33549b224af5c8664c54012b818ed037b2b7c1a63ac89ebaa11e07db89fcee5b556e49764ee3fa66ea7ae61ac01823}\n\np521_T = {x = BVtoZ 0x000000f411f2ac2eb971a267b80297ba67c322dba4bb21cec8b70073bf88fc1ca5fde3ba09e5df6d39acb2c0762c03d7bc224a3e197feaf760d6324006fe3be9a548c7d5,\n          y = BVtoZ 0x000001fdf842769c707c93c630df6d02eff399a06f1b36fb9684f0b373ed064889629abb92b1ae328fdb45534268384943f0e9222afe03259b32274d35d1b9584c65e305}\n\nproperty p521_full_add_example =\n  p521::full_add_example R p521_S p521_T\n  where R = {x = BVtoZ 0x000001264ae115ba9cbc2ee56e6f0059e24b52c8046321602c59a339cfb757c89a59c358a9a8e1f86d384b3f3b255ea3f73670c6dc9f45d46b6a196dc37bbe0f6b2dd9e9,\n             y = BVtoZ 0x00000062a9c72b8f9f88a271690bfa017a6466c31b9cadc2fc544744aeb817072349cfddc5ad0e81b03f1897bd9c8c6efbdf68237dc3bb00445979fb373b20c9a967ac55}\n\nproperty p521_full_subtract_example =\n  p521::full_subtract_example R p521_S p521_T\n  where R = {x = BVtoZ 0x000001292cb58b1795ba477063fef7cd22e42c20f57ae94ceaad86e0d21ff22918b0dd3b076d63be253de24bc20c6da290fa54d83771a225deecf9149f79a8e614c3c4cd,\n             y = BVtoZ 0x000001695e3821e72c7cacaadcf62909cd83463a21c6d03393c527c643b36239c46af117ab7c7ad19a4c8cf0ae95ed51729885461aa2ce2700a6365bca3733d2920b2267}\n\nproperty p521_double_example =\n  p521::double_example R p521_S\n  where R = {x = BVtoZ 0x0000012879442f2450c119e7119a5f738be1f1eba9e9d7c6cf41b325d9ce6d643106e9d61124a91a96bcf201305a9dee55fa79136dc700831e54c3ca4ff2646bd3c36bc6,\n             y = BVtoZ 0x0000019864a8b8855c2479cbefe375ae553e2393271ed36fadfc4494fc0583f6bd03598896f39854abeae5f9a6515a021e2c0eef139e71de610143f53382f4104dccb543}\n\nproperty p521_scalar_multiply_example =\n  p521::scalar_multiply_example R p521_S d\n  where d = BVtoZ 0x000001eb7f81785c9629f136a7e8f8c674957109735554111a2a866fa5a166699419bfa9936c78b62653964df0d6da940a695c7294d41b2d6600de6dfcf0edcfc89fdcb1\n        R = {x = BVtoZ 0x00000091b15d09d0ca0353f8f96b93cdb13497b0a4bb582ae9ebefa35eee61bf7b7d041b8ec34c6c00c0c0671c4ae063318fb75be87af4fe859608c95f0ab4774f8c95bb,\n             y = BVtoZ 0x00000130f8f8b5e1abb4dd94f6baaf654a2d5810411e77b7423965e0c7fd79ec1ae563c207bd255ee9828eb7a03fed565240d2cc80ddd2cecbb2eb50f0951f75ad87977f}\n\nproperty p521_joint_scalar_multiply_example =\n  p521::joint_scalar_multiply_example R p521_S p521_T d e\n  where d = BVtoZ 0x000001eb7f81785c9629f136a7e8f8c674957109735554111a2a866fa5a166699419bfa9936c78b62653964df0d6da940a695c7294d41b2d6600de6dfcf0edcfc89fdcb1\n        e = BVtoZ 0x00000137e6b73d38f153c3a7575615812608f2bab3229c92e21c0d1c83cfad9261dbb17bb77a63682000031b9122c2f0cdab2af72314be95254de4291a8f85f7c70412e3\n        R = {x = BVtoZ 0x0000009d3802642b3bea152beb9e05fba247790f7fc168072d363340133402f2585588dc1385d40ebcb8552f8db02b23d687cae46185b27528adb1bf9729716e4eba653d,\n             y = BVtoZ 0x0000000fe44344e79da6f49d87c1063744e5957d9ac0a505bafa8281c9ce9ff25ad53f8da084a2deb0923e46501de5797850c61b229023dd9cf7fc7f04cd35ebb026d89d}\n\nproperty mp_mod_sqrt_521_correct = p521::mp_mod_sqrt_correct\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/ECDSA_sign_tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally verifies the correctness of the ECDSA signing function `sign` for the given test cases in the module `Primitive::Asymmetric::Signature::ECDSA::ECDSA_sign_tests`. The specification should assert that for each test case, the signature `(R, S)` produced by `sign` with inputs `(d, Msg, k)` matches the expected values. Include properties that can be used with Cryptol's :prove or :check commands to validate the implementation against these test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::ECDSA_sign_tests where\nimport Common::utils\nimport Primitive::Asymmetric::Signature::ECDSA::p192\n\n\n\/\/p192 SHA1 signing tests\n\ntestCase0 = {\nMsg = BVtoZ 0x608079423f12421de616b7493ebe551cf4d65b92, \/\/ Message digest\nd = BVtoZ 0xe14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3,\nk = BVtoZ 0xcb0abc7043a10783684556fb12c4154d57bc31a289685f25,\nQx = BVtoZ 0x07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6,\nQy = BVtoZ 0x76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477,\nR = BVtoZ 0x6994d962bdd0d793ffddf855ec5bf2f91a9698b46258a63e,\nS = BVtoZ 0x02ba6465a234903744ab02bc8521405b73cf5fc00e1a9f41 }\n\ntestCase1 = {\nMsg = BVtoZ 0x98cff299c35616bfd081543998a5a367b43214e1,\nd = BVtoZ 0x7a0235bea3d70445f14d56f9b7fb80ec8ff4eb2f76865244,\nQx = BVtoZ 0x0ea3c1fa1f124f26530cbfddeb831eecc67df31e08889d1d,\nQy = BVtoZ 0x7215a0cce0501b47903bd8fe1179c2dfe07bd076f89f5225,\nk = BVtoZ 0x3c646b0f03f5575e5fd463d4319817ce8bd3022eaf551cef,\nR = BVtoZ 0xa3ba51c39c43991d87dff0f34d0bec7c883299e04f60f95e,\nS = BVtoZ 0x8a7f9c59c6d65ad390e4c19636ba92b53be5d0f848b4e1f7 }\n\nproperty test192 = and [((i.R, i.S) == (sign i.d i.Msg i.k)) | i <- [ testCase0, testCase1] ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the correctness properties of the ECDSA P-384 signature scheme as implemented in the given module. Include properties that verify the correctness of the modular square root function `mp_mod_sqrt` over the prime field `p`, and ensure that the group parameters `G` and order `q` satisfy the necessary elliptic curve group properties. The specification should enable formal verification of signature generation and verification functions against the ECDSA standard for the P-384 curve."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::p384 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\ntype p = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\n\nb = 27580193559959705877849011840389048093056905856361568521428707301988689241309860865136260764883745107765439761230575\n\nG = {x = 26247035095799689268623156744566981891852923491109213387815615900925518854738050089022388053975719786650872476732087,\n     y = 8325710961489029985546751289520108179287853048861315594709205902480503199884419224438643760392947333078086511627871,\n     z = 1}\n\ntype q = 39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643\n\nmp_mod_sqrt : Z p -> Z p\nmp_mod_sqrt c = r''' ^^ (2 ^^ 30)\n  where t1    = (c ^^ 2) * c\n        t2    = (t1 ^^ (2 ^^ 2)) * t1\n        t2'   = (t2 ^^ 2) * c\n        t3    = (t2' ^^ (2 ^^ 5)) * t2'\n        t4    = (t3 ^^ (2 ^^ 5)) * t2'\n        t2''  = (t4 ^^ (2 ^^ 15)) * t4\n        t3'   = t2'' ^^ (2 ^^ 2)\n        t1'   = t3' * t1\n        t3''  = t3' ^^ (2 ^^ 28)\n        t2''' = t2'' * t3''\n        t3''' = (t2''' ^^ (2 ^^ 60)) * t2'''\n        r     = (t3''' ^^ (2 ^^ 120)) * t3'''\n        r'    = (r ^^ (2 ^^ 15)) * t4\n        r''   = (r' ^^ (2 ^^ 33)) * t1'\n        r'''  = (r'' ^^ (2 ^^ 64)) * c\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the ECDSA signature scheme parameters and operations for the P-192 curve as given in the module Primitive::Asymmetric::Signature::ECDSA::p192. Include properties that verify the correctness of the modular square root function mp_mod_sqrt and ensure that the curve parameters (p, b, G, q) satisfy the necessary elliptic curve and group properties for secure signature generation and verification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::p192 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\ntype p = 6277101735386680763835789423207666416083908700390324961279\n\nb = 2455155546008943817740293915197451784769108058161191238065\n\nG = {x = 602046282375688656758213480587526111916698976636884684818,\n     y = 174050332293622031404857552280219410364023488927386650641,\n     z = 1}\n\ntype q = 6277101735386680763835789423176059013767194773182842284081\n\nmp_mod_sqrt c = r''\n  where t1 = c ^^ 2         ; t1' = t1 * c\n        t2 = t1' ^^ (2^^2)  ; t2' = t2 * t1'\n        t3 = t2' ^^ (2^^4)  ; t3' = t3 * t2'\n        t4 = t3' ^^ (2^^8)  ; t4' = t4 * t3'\n        t5 = t4' ^^ (2^^16) ; t5' = t5 * t4'\n        t6 = t5' ^^ (2^^32) ; t6' = t6 * t5'\n        r  = t6' ^^ (2^^64) ; r'  = r * t6'\n        r'' = r' ^^ (2^^62)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior and properties of the mp_mod_sqrt function in the Primitive::Asymmetric::Signature::ECDSA::p224 module. The specification should capture the mathematical correctness of the modular square root computation over the prime field p, ensuring that the output squared modulo p equals the input value when a square root exists. Include properties to verify the correctness of the helper functions RS, RSS, RM, and RP used in the computation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::p224 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\nimport Common::utils\n\ntype p = 26959946667150639794667015087019630673557916260026308143510066298881\n\nb = 18958286285566608000408668544493926415504680968679321075787234672564\n\nG = {x = 19277929113566293071110308034699488026831934219452440156649784352033,\n     y = 19926808758034470970197974370888749184205991990603949537637343198772,\n     z = 1}\n\ntype q = 26959946667150639794667015087019625940457807714424391721682722368061\n\nmp_mod_sqrt : Z p -> Z p\nmp_mod_sqrt c = r\n  where s = random (ZtoBV c)\n        (d0, e0, f0) = RP c s\n        (d1, e1, f1) = RS d0 e0 f0\n        state = [(d1, e1, f1)] #\n                [ if d1' == 0 then (d, e, f) else (d1', e1', f1')\n                  where (d1', e1', f1') = RS d e f\n                | (d, e, f) <- state ]\n        (d0', e0', _) = state@95\n        r = d0' * (mp_mod_inv e0')\n\nprivate\n\n  RS : Z p -> Z p -> Z p -> (Z p, Z p, Z p)\n  RS d0 e0 f0 = (d1, e1', f1'')\n    where t    = d0 ^^ 2\n          e1   = d0 * e0\n          d1   = t + f0\n          e1'  = e1 + e1\n          f1   = t * f0\n          f1'  = f1 + f1\n          f1'' = f1' + f1'\n\n  RSS : Z p -> Z p -> Z p -> [7] -> (Z p, Z p, Z p)\n  RSS d0 e0 f0 j = (d1, e1, f1)\n    where (d1, e1, f1) = state@j\n          state = [(d0, e0, f0)] # [ RS d e f | (d, e, f) <- state ]\n\n  RM : Z p -> Z p -> Z p -> Z p -> Z p -> (Z p, Z p, Z p)\n  RM c d0 e0 d1 e1 = (d2, e2', f2'')\n    where t1    = e0 * e1\n          t1'   = t1 * c\n          t1''  = -t1'\n          t2    = d0 * d1\n          t2'   = t2 + t1''\n          t1''' = d0 * e1\n          e2    = d1 * e0\n          e2'   = e2 + t1'''\n          f2    = e2' ^^ 2\n          f2'   = f2 * c\n          f2''  = -f2'\n          d2    = t2'\n\n  RP : Z p -> Z p -> (Z p, Z p, Z p)\n  RP c r = (d1, e1, f1)\n    where (d1, e1, f1) = state!0\n          state = [(r, 1, -c)] # [ body d e f i | (d, e, f) <- state | i <- [0..6] ]\n          body d0 e0 f0 i = (d1'', e1'', f1'')\n            where (d1', e1', _) = RSS d0 e0 f0 (2^^i)\n                  (d1'', e1'', f1'') = RM c d1' e1' d0 e0\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/DSA\/DSA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the DSA signature implementation in the given module. Specifically, create properties that prove the 'sign' function produces signatures that always pass the 'verify' function for valid inputs, and include edge cases for the parameters 'x', 'k', and 'z'. Ensure the properties are suitable for automated checking or proving within Cryptol's verification framework."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::DSA::DSA where\nimport Common::mod_arith\nimport Common::utils\n\n\nsign : Z q -> Z q -> Z q -> (Z q, Z q)\nsign x k z = (r, s)\n    where r =  ZtoZ (BVtoZ `{p=p}(mod_pow (pv, g', k')))\n          pv = ZtoBV `{1+p,L} `p\n          g' = ZtoBV `{a=L} g\n          k' = ZtoBV `{a=L} (ZtoZ `{q=q} k)\n          s = BVtoZ `{p=q}  (mod_mul (q', (ZtoBV `{a=N} kinv), zpxr))\n          kinv = mp_mod_inv k\n          xr = mod_mul(q', x', r')\n          zpxr = mod_add(q', xr, z')\n          r' = ZtoBV `{a=N} r\n          x' = ZtoBV `{a=N} x\n          z' = ZtoBV `{a=N} z\n          q' = ZtoBV `{1+q,N} `q\n\n\nverify : Z p -> Z q -> (Z q, Z q) -> Bit\nverify y z (r, s) = ((BVtoZ `{p=q} v) == r)\n   where w = (mp_mod_inv s)\n         u1 = (zero#mod_mul (q', (ZtoBV z), (ZtoBV w))) :[L]\n         u2 = (zero#mod_mul (q', (ZtoBV r), (ZtoBV w))) :[L]\n         v = mod_mul (pv, gu1, yu2)\n         gu1 =  mod_pow(pv, g', u1)\n         yu2 =  mod_pow(pv, y', u2)\n         pv = ZtoBV `{1+p,L} `p\n         g' = ZtoBV `{a=L} g\n         y' = ZtoBV `{a=L} y\n         q' = ZtoBV `{1+q,N} `q\n\n\nparameter\n\n    type p : #\n    type constraint Constraints p\n\n    g : Z p\n\n    type q : #\n\n    type constraint (fin q, isOdd q, q >= 4)\n\n\/\/ NIST recommended bit lengths of p and q\n\/\/L: the size of p, N: the size of q\n\n    type L : #\n\n    type N : #\n\/\/Comment\/uncomment according to the instantiated parameters\n    \/\/type constraint (L==1024,N==160)\n    type constraint (L==2048,N==224)\n    \/\/type constraint (L==2048,N==256)\n    \/\/type constraint (L==3072,N==256)\n\n\n\n\n\nprivate\n\n    type constraint Constraints a = (fin a, isOdd a, a >= 4)\n    \/\/type constraint validPsize L x = (L==1024*x, 2>=x)\n    \/\/type constraint validQsize N = (N==160) \/\/N==224, N==256\n\n\nproperty signDsaCorrect x k z = (verify (BVtoZ `{p=p} (mod_pow ((ZtoBV `{1+p,L} `p), ZtoBV `{a=L} g, (zero#(ZtoBV`{p=q}x):[L])))) z (sign x k z) ) == True\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/trash\/DilithiumBv.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the Dilithium signature scheme implementation in the provided Cryptol module. Include properties that check the key generation (Gen) produces valid public and secret keys, the polynomial sampling functions (PolyUniformEta, samplePoly) generate values within expected bounds, and the hash-based functions (H, CRH) behave consistently with their specifications. Additionally, specify properties to verify that the NTT-related functions (ExpandA, matrixPoly) produce correctly structured polynomials. Ensure the properties are suitable for automated checking or proving within the Cryptol environment."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::DilithiumBV where\n\nimport Primitive::Keyless::Hash::keccak as SHA3\nimport Common::utils\nimport Common::mod_arith\nimport Primitive::Asymmetric::Cipher::RSA\nimport Primitive::Asymmetric::Signature::testDilithium\n\n\n\/\/ DilithiumII parameters\n\/\/ Security level - Medium\ntype qbits = 23\ntype uint32_t = 32\ntype q = 0x7fe001 type n = 0x100 d = 0xe\nwc= 0x3c gamma1 = ((`q) - 1) \/ 16:[_]\ngamma2 = (gamma1\/2):[_]\nalpha = (2*gamma2):[_]\n\n\/\/ Parameters for Number Theoretic Transform (NTT)\nrootOfUnity    = 1753 :[_]\nrootOfUnityInv = 731434 : [_]\nninv           = 8347681 : [_]\n\n\/\/Parameterize\nparameter\n    type k : #\n    type constraint (fin k, k>=3, k <=6)\n    type l : #\n    type constraint (fin l, l>=2, l<=5)\n    eta : [4]\n    beta : [12]\n    omega : [8]\n\n\/\/ Integer polynomials; a superset of ring R referenced in specification\ntype intPoly        = [n][uint32_t]\ntype intPolyVec dim = [dim]intPoly\n\n\/\/ Polynomials; a superset of ring R_q referenced in specification\ntype poly        = [n][qbits] \/\/ This is R_q, actually defines a super set of R_q\ntype polyVec dim = [dim]poly\n\n\/\/ Polynomials in NTT representation\ntype nttPoly          = [n][qbits]\ntype nttVec dim       = [dim]nttPoly\ntype nttMat dim1 dim2 = [dim1](nttVec dim2)\n\n\ntype PublicKey = {rho : [256], t1 : intPolyVec k}\ntype SecretKey = {rho : [256]\n                    , K  : [256]\n                    , tr : [384]\n                    , s1 : polyVec l\n                    , s2 : polyVec k\n                    , t0 : intPolyVec k}\ntype SEEDBYTES = 32\n\n\/* Generate public and private keys *\/\n\/\/Gen : [SEEDBYTES*8] -> (PublicKey,SecretKey)\nGen seed = A\n    where\n      randoms = split`{3} (join (SHA3::toBytes (take`{768} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))\n      (rho, rho', K) = (randoms@0, randoms@1, randoms@2)\n      A       = ExpandA rho\n      s1      = PolyUniformEtaV`{dim=l} rho' zero\n\nprivate\n    pack_w : intPolyVec k -> [4*n*k]\n    pack_w w = join [pack_poly p | p <- wBV ]\n        where\n        wBV = map (\\p -> map (\\x -> drop`{24} x:[8]) p) w\n\n        pack2 : [2][8] -> [8]\n        pack2 xs = xs@0 || (xs@1 << 4)\n\n        pack_poly p = join [ pack2 xs | xs <- split p : [128][2][_] ]\n\n\/\/ Only works when n=256\nPolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [8] -> polyVec dim\nPolyUniformEtaV rho nonce = [PolyUniformEta rho (nonce + j) | j <- [0..(dim-1)]:[dim][8]]\n\nPolyUniformEta : [SEEDBYTES*8] -> [8] -> poly\nPolyUniformEta rho nonce = map (\\x -> (zero#eta:[23]) - x) (map (\\x-> (zero#x):[23]) (take`{n} withinEta))\n    where\n    seed = rho#nonce\n    randoms = ((join (SHA3::toBytes (take`{2*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))#zero)\n    withinEta = randomsInRangeDouble genS (2*eta) randoms\n\ngenS : [8] -> [2][4]\ngenS byte = [t0, t1]\n    where\n    t0 = drop`{4} (byte && 0x0F)\n    t1 = drop`{4} (byte >> 4)\n\n\n\nH : ([384],intPolyVec k) -> poly\nH (mu,w) = map fromInteger (SampleInBall ss samples)\n    where\n    w_packed = pack_w w\n    randoms  = join (SHA3::toBytes (take`{4352} (SHA3::SHAKE256 (join (SHA3::toBytes (mu#w_packed))))))\n    ss       = take`{60}(reverse (join (reverse (split (take`{64} randoms):[8][8]))))\n\n    extByte : [8] -> [8]\n    extByte x = x\n\n    samples : [60][8]\n    samples = take`{60} (randomsInRanges extByte [196..255] (drop`{64} randoms#zero))\n\n\nSampleInBall : [60] -> [60][8] -> [256]Integer\nSampleInBall signs jsamples = ys ! 0\n    where\n    ys = [ zero:[256]Integer ]\n        #    [ if i==j then update y i ((-1:Integer)^^(toInteger [s]))\n            else updates y [j,i] [(-1:Integer)^^(toInteger [s]),y@j] | i <- [196..255]\n        | j <- jsamples\n        | s <- signs\n        | y <- ys\n        ]\n\n\nExpandMask : ([SEEDBYTES*8], [384], Integer) -> polyVec l\nExpandMask  (K, mu, kappa) = [samplePoly K mu kappa i `l | i <- [0..(l-1)] ]\n\n\nsamplePoly : [256] -> [384] -> Integer -> Integer -> Integer -> poly\nsamplePoly K mu kappa i dim = [ (`q + (zero#gamma1:[23]) - (zero#1:[23]) - (zero#vj:[23])) | vj <- coeffs]\n    where\n    (upper:[20])      =  drop`{3}(2*gamma1-2):[20]\n    kappaBytes = join (reverse (split (fromInteger (dim*kappa+i):[16]):[2][8])) \/\/ LEB order\n    s          = join (SHA3::toBytes (take`{5*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes (K#mu#kappaBytes)))))) \/\/ checked\n    (coeffs:[n][20])   = take`{n} (randomsInRangeDouble extractPolyElt upper (s#zero))\n\n\nextractPolyElt : [40] -> [2][20]\nextractPolyElt bits = [zero#int1, zero#int2]\n    where\n    [b0,b1,b2,b3,b4] = [(zero#b):[20] | b <- split bits : [5][8]]\n    int1 = b2'*2^^16 + b1*2^^8 +  b0\n    int2 = b4*2^^12 + b3*2^^4 +  b2''\n    b2'  = b2 && 15\n    \/\/b2'' = b2\/(16:[20])\n    b2'' = b2\/16\n\n\/\/ seed should be in little endian byte order\nCRH : {b} (fin b, b>=1) => [b*8] -> [384]\nCRH seed = join (SHA3::toBytes (take`{48*8} (SHA3::SHAKE256 (join (SHA3::toBytes seed)))))\n\n\nExpandA : [SEEDBYTES*8] -> [k][l]nttPoly\nExpandA rho = [ [elt i j | j <- [0..(l-1)] ] |  i <- [0..(k-1)] ]\n    where\n    elt i j = matrixPoly rho i j\n\n\nmatrixPoly : [SEEDBYTES*8] -> [width k] -> [width l] -> nttPoly\nmatrixPoly rho i j = take`{n} [ drop`{1} elt | elt <- randomElts ]\n    where\n    randomElts = randomsInRange extractMatElt ((>=) (`q)) (s#zero)\n    s          = join (SHA3::toBytes (take`{6720} (SHA3::SHAKE128 (join (SHA3::toBytes (rho#b))))))\n    b          = 2^^4*(zero#j:[8])+(zero#i:[8])\n\n\nextractMatElt : [24] -> [24]\nextractMatElt rands = zero#(2^^16 * b2' + 2^^8 * b1 + b0):[24]\n    where\n    [b0, b1, b2] = [(zero#b):[23] | b <- split`{3} rands]\n    b2' = (2^^23-1) && b2 \/\/ Typo in paper; following C implementation\n\n\nrandomsInRange : {a} (fin a) => ([a]-> [a]) -> ([a] -> Bit) -> [inf] -> [inf][a]\nrandomsInRange createElt upperCrit randoms = if (upperCrit elt )\n                                             then  [ elt ]#(randomsInRange createElt upperCrit randomTail)\n                                             else randomsInRange createElt upperCrit randomTail\n                    where\n                    elt        = createElt (take`{a} randoms)\n                    randomTail = drop`{a} randoms\n\nrandomsInRanges : {a,m} (fin a,fin m, m>=1) => ([a]-> [a]) -> [m][a] -> [inf] -> [inf][a]\nrandomsInRanges createElt uppers randoms =\n                                            if elt <= head uppers\n                                            then  [ elt ]#(randomsInRanges createElt uppersRotate randomTail)\n                                            else randomsInRanges createElt uppers randomTail\n                                where\n                                elt          = createElt (take`{a} randoms)\n                                randomTail   = drop`{a} randoms\n                                uppersRotate = uppers <<< 1\n\n\nrandomsInRangeDouble : {a} (fin a) => ([2*a]-> [2][a]) -> [a] -> [inf] -> [inf][a]\n\/*randomsInRangeDouble createElt upper randoms =\nif (elts@0 <= upper) \/\\ (elts@1 <= upper)\nthen  elts#(randomsInRangeDouble createElt upper randomTail)\nelse\nif (elts@0 <= upper)\nthen [ elts@0 ]#(randomsInRangeDouble createElt upper randomTail)\nelse\nif (elts@1 <= upper)\nthen [ elts@1 ]#(randomsInRangeDouble createElt upper randomTail)\nelse randomsInRangeDouble createElt upper randomTail\nwhere\nelts       = createElt (take`{2*a} randoms)\nrandomTail = drop`{2*a} randoms*\/\n\/\/ Correction and checked with the C code\nrandomsInRangeDouble createElt upper randoms =\n                                    if (elts@1 <= upper) then [elts@1, elts@1] # (randomsInRangeDouble createElt upper randomTail)\n                                    else (randomsInRangeDouble createElt upper randomTail)\n            where\n            elts       = createElt (take`{2*a} randoms)\n            randomTail = drop`{2*a} randoms\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/ref_ec_mul.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the elliptic curve scalar multiplication functions `ec_mul` and `ec_twin_mul` defined in the module `Common::EC::ref_ec_mul`. The properties should ensure that these functions correctly compute scalar multiplication on elliptic curve points according to the mathematical definitions, including handling edge cases such as zero points and verifying the consistency of intermediate computations. Include properties that check the preservation of group laws and the correctness of point addition and doubling operations used within these functions."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::ref_ec_mul where\n\nimport Common::EC::ec_point_ops\n\n\/* Multiplies a large word scalar by the an affine point. *\/\nec_mul : {fv, gv}  (fin gv) => (PointOps fv [gv], [gv], AffinePoint fv) -> JacobianPoint fv\nec_mul (m, d, s) = res!0\n  where\n    k = [False, False] # d\n    h = k + (k + k)\n    res : [gv+2](JacobianPoint fv)\n    res = [(ec_zero_point(m.field))]\n          #  [ if hi && ~ki then\n                 m.add(m.double(r), s)\n               else if ~hi && ki then\n                 m.sub(m.double(r), s)\n               else\n                 m.double(r)\n             | hi <- take`{back=1} h\n             | ki <- take`{back=1} k\n             | r  <- res\n             ]\n\nec_twin_mul_aux1 : {fv, gv} (fin gv, gv >= 4) =>\n  (PointOps fv [gv], JacobianPoint fv, [32], [32],\n   AffinePoint fv, AffinePoint fv, AffinePoint fv, AffinePoint fv)\n  -> (JacobianPoint fv)\nec_twin_mul_aux1(m,rP,u0,u1,sPt,s,sMt,t) = r\n  where\n   f = m.field\n   r = if u0 == -1 then\n         (if      u1 == -1 then m.sub(r2, sPt)\n          else if u1 ==  0 then m.sub(r2, s)\n          else                  m.sub(r2, sMt))\n       else if u0 == 0 then\n         (if      u1 == -1 then m.sub(r2, t)\n          else if u1 ==  1 then m.add(r2, t)\n          else                  r2)\n       else\n         (if      u1 == -1 then m.add(r2, sMt)\n          else if u1 ==  0 then m.add(r2, s)\n          else                  m.add(r2, sPt))\n   r2 = m.double(rP)\n\nF : {a} (fin a, a>=5) => [a] -> [a]\nF(t) = if (18 <= t) && (t < 22) then\n          9\n       else if (14 <= t) && (t < 18) then\n         10\n       else if (22 <= t) && (t < 24) then\n         11\n       else if (4 <= t) && (t < 12) then\n         14\n       else\n         12\n\n\/* Return d0 * S + d1 * T. All points projective, 0 <= d0, d1 < p. *\/\nec_twin_mul : {fv, gv} (fin gv)\n            => (PointOps fv [gv+4], [gv+4], AffinePoint fv, [gv+4], AffinePoint fv)\n            -> (JacobianPoint fv)\nec_twin_mul(m, d0, s, d1, t) =\n  if ec_is_zero_point(f, sPtP) then \/* s + t = 0 *\/\n    ec_mul(m, g.sub(d0, d1), s)\n  else if ec_is_zero_point(f, sMtP) then \/* s = t *\/\n    ec_mul(m, g.add(d0, d1), s)\n  else\n    drop`{gv+4}(r)@0\n where\n   f    = m.field\n   g    = m.group_field\n   sP   = ec_projectify(f, s)\n   sPtP = m.add(sP, t) \/* 1: ec_full_add (SpT, S, T) *\/\n   sMtP = m.sub(sP, t) \/* 2: ec_full_sub (SmT, S, T) *\/\n   sDiv = f.div(f.field_unit, f.mul(sPtP.z, sMtP.z))\n   sPt  = { x = f.mul(g2, sPtP.x)\n          , y = f.mul(f.mul(gd, g2), sPtP.y)\n          }\n     where gd = f.mul(sMtP.z, sDiv)\n           g2 = f.sq(gd)\n   sMt  = { x = f.mul(g2, sMtP.x)\n          , y = f.mul(f.mul(gd, g2), sMtP.y)\n          }\n     where gd  = f.mul(sPtP.z, sDiv)\n           g2 = f.sq(gd)\n   init_c : [2][6]\n   init_c = [zero # (take(d0) : [4]), zero # (take(d1) : [4])]\n   c : [inf]_\n   c = [init_c]\n     # [ [[abs(u0) ^ c01, c02, c03, c04, c05, e0N],\n          [abs(u1) ^ c11, c12, c13, c14, c15, e1N]]\n          where\n            abs : {a} (fin a) => [a] -> Bit\n            abs(x) = x != zero\n       | [[c00, c01, c02, c03, c04, c05], [c10, c11, c12, c13, c14, c15]] <- c\n       | [u0, u1] <- u\n       | e0N <- (drop`{4}(d0)) # (zero : [inf])\n       | e1N <- (drop`{4}(d1)) # (zero : [inf])\n       ]\n   u : [inf]_\n   u = [ [u0, u1]\n            where\n              h0' = [c05, c04, c03, c02, c01]\n              h0 = if c00 then 31 - h0' else h0'\n              h1' = [c15, c14, c13, c12, c11]\n              h1 = if c10 then 31 - h1' else h1'\n              u0 : [32]\n              u0 = if h0 < F(h1) then 0 else if c00 then -1 else 1\n              u1 : [32]\n              u1 = if h1 < F(h0) then 0 else if c10 then -1 else 1\n       | [[c00, c01, c02, c03, c04, c05], [c10, c11, c12, c13, c14, c15]] <- c\n       ]\n   r : [inf]_\n   r = [(ec_zero_point f)]\n     # [ ec_twin_mul_aux1(m, rP, u0, u1, sPt, s, sMt, t)\n       | rP      <- r\n       | [u0, u1] <- u\n       ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/p384_ec_point_ops.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol specifications that formally define the expected behavior and properties of the elliptic curve point operations in the p384_ec_point_ops module, including p384_ec_double, p384_ec_full_add, and p384_ec_full_sub. Ensure the specifications capture correctness criteria such as group law properties, consistency with the underlying field operations, and expected input-output relationships for these functions."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::p384_ec_point_ops where\n\nimport Common::EC::ec_point_ops\nimport Common::EC::p384_field\n\np384_point_ops : PointOps [384] [384]\np384_point_ops = {\n    field  = p384_field\n  , double = p384_ec_double\n  , add    = p384_ec_full_add\n  , sub    = p384_ec_full_sub\n  , group_field = p384_group_field\n  }\n\np384_ec_double : JacobianPoint [384] -> JacobianPoint [384]\np384_ec_double(p) = ec_double(p384_field, p)\n\np384_ec_full_add : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384]\np384_ec_full_add(p,q) = ec_full_add(p384_point_ops, p, q)\n\np384_ec_full_sub : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384]\np384_ec_full_sub(p,q) = ec_full_sub(p384_point_ops, p, q)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/EC_P384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the elliptic curve operations defined in the EC_P384 module. Specifically, specify and prove properties for the affine point addition (ec_point_affine_add), scalar multiplication (ec_point_affine_scalar_mul), and the ECDSA signing and verification functions (ECDSA_sign and ECDSA_verify). Include properties that ensure group law correctness, scalar multiplication consistency, and that ECDSA_verify correctly validates signatures produced by ECDSA_sign. Also, specify properties relating the conversion functions between affine and Jacobian coordinates (toJacobian, fromJacobian) and verify that the Montgomery domain transformations (jacobianToMont, jacobianFromMont) preserve point correctness."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::EC_P384 where\n\nimport Common::ModDivZ\n\n\ntype w = 384\n\n\/\/ Prime modulus\ntype p = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\n\ntype FieldElement = Integer\n\n\/\/ Curve coefficients\na : FieldElement\na = -3\nb : FieldElement\nb = `0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\n\n\/\/ Curve generator point\nG : AffinePoint\nG =\n  { x = `0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\n  , y = `0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\n  }\n\n\/\/ Prime order of generator G\ntype n = 39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643\n\ntype Scalar = Integer\n\n\nR_p : FieldElement\nR_p = 340282367000166625977638945021017194497\nR_p_inv : FieldElement\nR_p_inv = 183479889321925461653251752109332205360611897149516305954304919627392402791260477631193651879713439593005062\n\nR_n : Scalar\nR_n = 1388124618062372383947042015309946732620727252194336364173\nR_n_inv : Scalar\nR_n_inv = 8213155180316830564023772752902517460134849974600554980379995049303147060140144611822562736815346652390458105321745\n\n\nfieldElementToBV : FieldElement -> [w]\nfieldElementToBV x = fromInteger x\n\nfieldElementFromBV : [w] -> FieldElement\nfieldElementFromBV x = toInteger x\n\nscalarToBV : Scalar -> [w]\nscalarToBV x = fromInteger x\n\nscalarFromBV : [w] -> Scalar\nscalarFromBV x = toInteger x\n\ninv0 : Scalar -> Scalar\ninv0 = undefined\n\ntype AffinePoint = { x : FieldElement, y : FieldElement }\n\nec_point_affine_add : AffinePoint -> AffinePoint -> AffinePoint\nec_point_affine_add = undefined\n\nec_point_affine_scalar_mul : Scalar -> AffinePoint -> AffinePoint\nec_point_affine_scalar_mul = undefined\n\n\nEC_keyPrivateToPublic : Integer -> AffinePoint\nEC_keyPrivateToPublic d = ec_point_affine_scalar_mul (d % `n) G\n\n\ntype ECDSA_Signature = { r : Scalar, s : Scalar }\n\nECDSA_sign : Scalar -> Integer -> Scalar -> ECDSA_Signature\nECDSA_sign d z k = { r = r, s = s }\n  where\n    { x = x1, y = _ } = ec_point_affine_scalar_mul k G\n    r =  x1 % `n\n    s = ((inv0 k) * (z + r * d)) % `n\n\nECDSA_verify : AffinePoint -> Integer -> ECDSA_Signature -> Bit\nECDSA_verify Q z { r = r, s = s } = r != 0 \/\\ r < `n \/\\ s != 0 \/\\ s < `n \/\\ r == x1 % `n\n  where\n    u1 = z * (inv0 s) % `n\n    u2 = r * (inv0 s) % `n\n    { x = x1, y = _ } = ec_point_affine_add (ec_point_affine_scalar_mul u1 G) (ec_point_affine_scalar_mul u2 Q)\n\n\nECDH_derive : Scalar -> AffinePoint -> FieldElement\nECDH_derive d Q = x % `p\n  where\n    { x = x, y = _ } = ec_point_affine_scalar_mul d Q\n\n\ntype JacobianPoint = { x : FieldElement, y : FieldElement, z : FieldElement }\n\ntoJacobian : AffinePoint -> JacobianPoint\ntoJacobian p = { x = p.x, y = p.y, z = 1 }\nfromJacobian : JacobianPoint -> AffinePoint\nfromJacobian p = undefined\n\n\nec_point_jacobian_add : JacobianPoint -> JacobianPoint -> JacobianPoint\nec_point_jacobian_add = undefined\n\nec_point_jacobian_scalar_mul : Scalar -> JacobianPoint -> JacobianPoint\nec_point_jacobian_scalar_mul = undefined\n\n\ntype JacobianBVPoint = { X : [w], Y : [w], Z : [w] }\n\njacobianToBV : JacobianPoint -> JacobianBVPoint\njacobianToBV p =\n  { X = fieldElementToBV p.x\n  , Y = fieldElementToBV p.y\n  , Z = fieldElementToBV p.z\n  }\n\njacobianFromBV : JacobianBVPoint -> JacobianPoint\njacobianFromBV p =\n  { x = fieldElementFromBV p.X\n  , y = fieldElementFromBV p.Y\n  , z = fieldElementFromBV p.Z\n  }\n\njacobianToMont : JacobianPoint -> JacobianPoint\njacobianToMont p =\n  { x = (p.x * P384_R_p) % `p\n  , y = (p.y * P384_R_p) % `p\n  , z = (p.z * P384_R_p) % `p\n  }\n\njacobianFromMont : JacobianPoint -> JacobianPoint\njacobianFromMont p =\n  { x = (p.x * P384_R_p_inv) % `p\n  , y = (p.y * P384_R_p_inv) % `p\n  , z = (p.z * P384_R_p_inv) % `p\n  }\n\njacobianToMontBV : JacobianPoint -> JacobianBVPoint\njacobianToMontBV p = jacobianToBV (jacobianToMont p)\n\njacobianFromMontBV : JacobianBVPoint -> JacobianPoint\njacobianFromMontBV p = jacobianFromMont (jacobianFromBV p)\n\n\nmont_R : {m} (fin m, m >= 3) => Integer\nmont_R = 2 ^^ `(width m) % `m\n\nmont_R_inv : {m} (fin m, m >= 3) => Integer\nmont_R_inv = fromZ (moddiv`{m} 1 (fromInteger (mont_R`{m})))\n\nbn_mont_n0 : {m} (fin m, m >= 3) => [64]\nbn_mont_n0 = fromInteger (((2 ^^ `(width m)) * mont_R_inv`{m} - 1) \/ `m)\n\n\ntype P384_w = w\ntype P384_p = p\nP384_a = a\nP384_b = b\nP384_G = G\nP384_G_Jacobian = toJacobian G\ntype P384_n = n\n\nP384_R_p = R_p\nP384_R_p_inv = R_p_inv\nP384_R_n = R_n\nP384_R_n_inv = R_n_inv\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/p384_ec_mul.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the elliptic curve scalar multiplication functions `p384_ec_mul` and `p384_ec_twin_mul` in the given module. Your specifications should ensure that these functions correctly implement scalar multiplication on the P-384 curve according to the standard elliptic curve group laws and match the behavior of the provided Java reference implementation. Include properties that verify the correctness of auxiliary functions such as `ripple_adc`, `ripple_shr`, and the initialization functions, ensuring consistency between the Cryptol implementation and the Java arrays used for internal representation."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::p384_ec_mul where\n\nimport Common::bv\nimport Common::mul_java\nimport Common::EC::ec_point_ops\nimport Common::EC::p384_field\nimport Common::EC::p384_ec_point_ops\nimport Common::EC::ref_ec_mul\n\n\/* Promote a finite sequence to an infinite sequence *\/\nmk_strm : {a, b} fin a => [a][b] -> [inf][b]\nmk_strm x = x # zero\n\n\/* Adds two n*m bit numbers split into m-bit segments and returns carry. *\/\nripple_adc : {m, n} (m >= 1, fin m, fin n) => ([n][m],[n][m]) -> ([n][m],Bit)\nripple_adc(xx,yy) = (values, carry_strm!0)\n  where\n    adc' : ([m],[m],Bit) -> (Bit,[m])\n    adc'(x,y,c) = (sum3@0, drop(sum3))\n      where sum3 = safe_add(x,y) + zext([c])\n    list = [ adc'(a,b,c)\n           | a <- xx\n           | b <- yy\n           | c <- carry_strm\n           ]\n    values = [ v | (_,v) <- list ]\n    carry_strm : [n+1]\n    carry_strm  = [False] # [ c | (c,_) <- list ]\n\nproperty ripple_adc_toJavaArray x y =\n  ripple_adc (toJavaArray x, toJavaArray y) == (toJavaArray (x + y), carry x y)\n\n\/* Returns (xl # c) >> 1. *\/\nripple_shr : {m, n} (m >= 1, fin m, n >= 1, fin n) => ([n][m],Bit) -> ([n][m])\nripple_shr(xl,c) = [ (x' << (length(x) - 1:[width m])) || (x >> 1)\n                   | x <- xl\n                   | x' <- drop`{1}(xl) # [(zext([c]))]\n                   ]\n\nproperty ripple_shr_toJavaArray x c =\n  ripple_shr (toJavaArray x, c) == toJavaArray (take`{back=1} ([c] # x))\n\np384_ec_zero_point : JacobianPoint [384]\np384_ec_zero_point = ec_zero_point(p384_field)\n\n\/* Matches Java implementation *\/\np384_ec_mul : ([384], AffinePoint [384]) -> JacobianPoint [384]\np384_ec_mul (d, s) = res!0\n  where\n    d' : [12][32]\n    d' = toJavaArray d\n    ini =  p384_ec_mul_init(d, s)\n    h : [12][32]\n    h = toJavaArray (ini.h)\n    r0 = ini.r\n    f (j, r) = p384_ec_mul_aux(r, s, j, h@i, c, d'@i, d_at_ip1)\n      where\n        i        = j >> 5\n        c        = i < 11\n        d_at_ip1 = if c then d'@(i+1) else 0\n                   \/* NB: We guard indexing here to avoid bounds VCs;\n                      p384_ec_mul_aux's use of d_at_ip1 is likewise\n                      guarded. *\/\n    res : [385]_\n    res = [r0] #\n          [ f(j, r)\n          | j <- reverse [0..383]\n          | r <- res\n          ]\n\n\/* Matches Java implementation *\/\np384_ec_mul_aux : ( JacobianPoint [384]\n                   , AffinePoint [384]\n                   , [32], [32], Bit, [32], [32] ) -> JacobianPoint [384]\np384_ec_mul_aux (r, s, j, hi, i_lt_11, d_at_i, d_at_ip1) = r'\n  where\n    m = 1 << (j && 31)\n    ki  = d_at_i >> 1\n    ki' = if i_lt_11 then\n            ((d_at_ip1 && 1) << 31) || ki\n          else\n            ki\n    r2 = p384_ec_double(r)\n    r'  = if ((hi && m) != 0) && ((ki' && m) == 0) then\n            p384_ec_full_add(r2, s)\n          else if ((hi && m) == 0) && ((ki' && m) != 0) then\n            p384_ec_full_sub(r2, s)\n          else\n            r2\n\np384_ec_mul_init : ([384], AffinePoint [384]) ->\n                   { h: [384], r: JacobianPoint [384] }\np384_ec_mul_init (d, s) = { h = fromJavaArray h0, r = r0 }\n  where\n    d' : [12][32]\n    d' = toJavaArray d\n    (h0, c) = ripple_adc(d', ripple_shr(d', False))\n    r0 = if c then ec_projectify(p384_field, s)\n              else p384_ec_zero_point\n\np384_ec_twin_mul_init :\n  ([384], AffinePoint [384], [384], AffinePoint [384]) ->\n  { r : JacobianPoint [384]\n  , sMt : AffinePoint [384]\n  , sPt : AffinePoint [384]\n  }\np384_ec_twin_mul_init(d0, s, d1, t) =\n  { r = r0\n  , sPt = if s.x == t.x then azero else sPt0\n  , sMt = if s.x == t.x then azero else sMt0\n  }\n  where\n    azero = { x = 0:[384], y = 0:[384] }\n    r0 =\n      if s.x == t.x then\n        if s.y == t.y then\n          p384_ec_mul(g.add(d0, d1), s)\n        else\n          p384_ec_mul(g.sub(d0, d1), s)\n      else\n        ec_zero_point f\n    m    = p384_point_ops\n    f    = m.field\n    g    = m.group_field\n    sP   = ec_projectify(f, s)\n    sPtP = m.add(sP, t) \/* 1: ec_full_add (SpT, S, T) *\/\n    sMtP = m.sub(sP, t) \/* 2: ec_full_sub (SmT, S, T) *\/\n    sDiv = f.div(f.field_unit, f.mul(sPtP.z, sMtP.z))\n    sPt0 = { x = f.mul(sPtP.x, g2), y = f.mul(f.mul(sPtP.y, g1), g2) }\n           where g1 = f.mul(sMtP.z, sDiv)\n                 g2 = f.sq(g1)\n    sMt0 = { x = f.mul(sMtP.x, g2), y = f.mul(f.mul(sMtP.y, g1), g2) }\n           where g1 = f.mul(sPtP.z, sDiv)\n                 g2 = f.sq(g1)\n\np384_ec_twin_mul_aux1 :\n  (JacobianPoint [384], [32], [32], AffinePoint [384], AffinePoint [384], AffinePoint [384], AffinePoint [384])\n  -> JacobianPoint [384]\np384_ec_twin_mul_aux1(rP, u0_32, u1_32, sPt, s, sMt, t) =\n  ec_twin_mul_aux1(p384_point_ops, rP, u0_32, u1_32, sPt, s, sMt, t)\n\np384_ec_twin_mul_aux2 : ([32],[32],[32],[32],[32],[32],[32],Bit,Bit) ->\n  { tma2_u0:[32]\n  , tma2_u1:[32]\n  , tma2_c0':[32]\n  , tma2_c1':[32]\n  , tma2_e0':[32]\n  , tma2_e1':[32]\n  , tma2_sh':[32]\n  }\np384_ec_twin_mul_aux2 (c0, c1, e0, e1, sh, d0i, d1i, dv1, dv2) =\n  { tma2_u0  = u0\n  , tma2_u1  = u1\n  , tma2_c0' = c0'\n  , tma2_c1' = c1'\n  , tma2_e0' = e0'\n  , tma2_e1' = e1'\n  , tma2_sh' = sh'\n  }\n  where\n    c0'           = ((if h0Less then 0 else `0x20) ^ (c0 << 1)) || ((e0 >> (sh && 31)) && `0x1)\n    c1'           = ((if h1Less then 0 else `0x20) ^ (c1 << 1)) || ((e1 >> (sh && 31)) && `0x1)\n    u0            = if h0Less then 0 else (if (c0 && `0x20) != 0 then (-1) else 1)\n    u1            = if h1Less then 0 else (if (c1 && `0x20) != 0 then (-1) else 1)\n\n    h0            = if (c0 && `0x20) != 0 then 31 - h0' else h0'\n      where h0' = c0 && `0x1F\n\n    h1            = if (c1 && `0x20) != 0 then 31 - h1' else h1'\n      where h1' = c1 && `0x1F\n\n    h0Less        = h0 < F(h1)\n    h1Less        = h1 < F(h0)\n    (e0',e1',sh') = if dv1 then\n                      if dv2 then (d0i, d1i, 31) else (0, 0, 31)\n                    else (e0, e1, sh-1)\n\n\/\/ F : [5] -> [5] via original impl\n\/\/ F : [32] -> [32] via fused impl\np384_ec_twin_mul_aux_F32 : [32] -> [32]\np384_ec_twin_mul_aux_F32 = F\n\n\/* Matches Java implementation *\/\np384_ec_twin_mul : ([384],AffinePoint[384], [384], AffinePoint [384]) -> JacobianPoint [384]\np384_ec_twin_mul(d0, s, d1, t) =\n  if s.x == t.x then i.r else jj_r\n  where\n   m     = p384_point_ops\n   f     = m.field\n   g     = m.group_field\n   i     = p384_ec_twin_mul_init(d0, s, d1, t)\n   d0'   = toJavaArray d0\n   d1'   = toJavaArray d1\n   d0_11 = d0'!0\n   d1_11 = d1'!0\n   (jj_r, _, _, _, _, _) = jj!0\n   jj : [386](JacobianPoint [384], _,_,_,_,_)\n   jj    = [ ( i.r             \/\/ initial point\n             , d0_11 >> 28     \/\/ c0 initial value\n             , d1_11 >> 28     \/\/ c1 initial value\n             , d0_11           \/\/ e0 initial value\n             , d1_11           \/\/ e1 initial value\n             , 27:[32]         \/\/ shift initial value\n             )\n           ]\n         # [ (r', c0', c1', e0', e1', sh')\n             where\n                k = (k0-5):[32]\n                r'         = p384_ec_twin_mul_aux1(r, u0, u1, i.sPt, s, i.sMt, t)\n                aux2       = p384_ec_twin_mul_aux2(c0, c1, e0, e1, sh, d0i, d1i, dv1, dv2)\n                (u0, u1)   = (aux2.tma2_u0, aux2.tma2_u1)\n                (c0', c1') = (aux2.tma2_c0', aux2.tma2_c1')\n                (e0', e1') = (aux2.tma2_e0', aux2.tma2_e1')\n                sh'        = aux2.tma2_sh'\n                (d0i, d1i,\n                 dv1, dv2) = if dv1i && dv2i then\n                               (d0'@ii, d1'@ii, dv1i, dv2i)\n                             else\n                               (zero, zero, dv1i, dv2i)\n                             where\n                               ii    = (k >> 5) - 1\n                               dv1i  = (k && `0x1F) == 0\n                               dv2i  = ~(ii@0)\n           | (r, c0, c1, e0, e1, sh) <- jj\n           | k0 <- reverse [0 .. 384]\n           ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/PrimeField\/PFEC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the elliptic curve point addition (ec_add) and scalar multiplication (scmul) functions defined over the prime field. Include properties that check the group identity element behavior, point validity after operations, commutativity and associativity of addition, and consistency of scalar multiplication with respect to the group law. Ensure the properties are suitable for use with Cryptol's :check or :prove commands."},{"role":"assistant","content":"```cryptol\n\/\/ NIST Prime Field Elliptic Curves defined in FIPS-186-4\n\nmodule Common::EC::PrimeField::PFEC where\n\nimport Common::ModDivZ\n\nparameter\n    type P : #     \/\/  The prime modulus\n    type constraint (fin P, P >= 5)\n    n  : Integer   \/\/  Prime order of generator G\n    b  : Z P       \/\/  Curve coefficient\n    Gx : Z P       \/\/  Curve coordinates\n    Gy : Z P       \/\/    of generator point\n\ntype Point = (Z P, Z P)\nG = (Gx, Gy) : Point\na = -3 : Z P       \/\/  Curve coefficient\np = toInteger`{width P} `P\n\n\/\/ A convenient representation of the point-at-infinity identity element\noo = (0, 0) : Point\n\n\/\/ Check that a given point is on the curve\nvalid_point : Point -> Bit\nvalid_point (x, y) =\n    ((x, y) == oo) \\\/ (y ^^ 2 == x ^^ 3 + a * x + b)\n\n\/\/ (From http:\/\/www.secg.org\/sec1-v2.pdf, section 2.2.1)\n\/\/ Addition of two elliptic curve points in E(F_p) (p an odd prime)\n\/\/ on a curve with coefficient 'a'. Note 'b' is unused.\nec_add : Point -> Point -> Point\nec_add (x1, y1) (x2, y2) =\n    if (x1, y1) ==    oo     then  (x2, y2)  \/\/  Rules 1, 2\n     | (x2, y2) ==    oo     then  (x1, y1)  \/\/  Rules 1, 2\n     | (x1, y1) == (x2, -y1) then     oo     \/\/  Rule 3\n                             else   (x, y)   \/\/  Rules 4, 5\n    where  \/\/ all arithmetic operations are mod p\n    x = L ^^ 2 - x1 - x2\n    y = L * (x1 - x) - y1\n    L = if x1 == x2 then (3 * x1 ^^ 2 + a) %\/ (2 * y1)\n                    else (y2 - y1) %\/ (x2 - x1)\n\n\/\/ Scalar multiplication of a curve point using double-and-add\nscmul : Integer -> Point -> Point\nscmul m xy =\n    if m == 0 then oo\n     | m == 1 then xy\n     | even m then scmul (m \/ 2) (ec_add xy xy)\n              else ec_add xy (scmul (m - 1) xy)\n\n(~*) = scmul  \/\/ infix form of operator\n\n\/\/ TODO: needs a primality checker!\n\/\/ property p_prime = prime p\n\/\/ property n_prime = prime n\nproperty valid_n = (n + 1) ~* G == G\nproperty valid_scmul m = valid_point (m ~* G)\nproperty scmul_commutes m m' = m ~* (m' ~* G) == m' ~* (m ~* G)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/gf.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the finite field arithmetic functions defined in the GF module, including gf_iszero, gf_add, gf_mul, gf_sqmul, gf_sq2mul, gf_sq2, gf_frac, and gf_inv. The properties should capture the expected algebraic properties such as zero detection, addition as XOR, multiplication correctness, squaring, inversion, and fraction computations over the Galois field. Ensure the specifications can be used for automated checking or proving within Cryptol."},{"role":"assistant","content":"```cryptol\nmodule GF where\n\nimport Types\n\n\ngf_iszero : base_t  -> base_t\ngf_iszero a = t_3 where\n    (t_1 : uint32t ) = cvt_16_to_32 a\n    (t_2 : uint32t ) = (t_1-1)>> 19\n    (t_3 : base_t) = cvt_32_to_16 t_2\n\ngf_add : base_t -> base_t -> base_t\ngf_add a b = a^b\n\ngf_mul : gf_t  -> gf_t  -> gf_t\ngf_mul a b = rtn  where\n    (t0:base_64t) = cvt_16_to_64 a\n    (t1:base_64t) = cvt_16_to_64 b\n    loop_i i tmp =\n        if (i>= GFBITS) then tmp\n        else loop_i (i+1) tmp' where\n            tmp' = t0 * (t1 && (1 << i))\n    (tmp_0 : base_64t) = t0 * (t1 && 1)\n    (tmp_1 : base_64t) = loop_i 0 tmp_0\n        (k_0: base_64t) =  cvt_20_to_64 0x1FF0000\n    (k_1: base_64t) =  cvt_20_to_64 0x000E000\n    (t_0: base_64t) = tmp_1 && k_0\n    (t_1: base_64t) = tmp_2 && k_1\n    (tmp_2 : base_64t) = tmp_1 ^ ((t_0 >> 9) ^ (t_0 >> 10) ^ (t_0 >> 12) ^ (t_0 >> 13))\n    (tmp_3 : base_64t) = tmp_2 ^ ((t_1 >> 9) ^ (t_1 >> 10) ^ (t_1 >> 12) ^ (t_1 >> 13))\n    (rtn : gf_t ) = cvt_64_to_16 (tmp_3 && GFMASK)\n\nloop_i i x limit M =\n    if(i<limit) then loop_i i' x' limit M where\n        t = x && (M@i)\n        x'= x^ (t >> 9) ^ (t >> 10) ^ (t >> 12) ^ (t >> 13)\n        i' = i+1\n    else  cvt_64_to_16 (x&& GFMASK)\n\ngf_sqmul : gf_t -> gf_t -> gf_t\ngf_sqmul a b = rtn where\n    M = [0x0000001FF0000000, 0x000000000FF80000, 0x000000000007E000]\n    (t0:uint64t) = cvt_16_to_64  a\n    (t1:uint64t) = cvt_16_to_64  b\n    (x1:uint64t) = (t1 << 6) * (t0 && (1 << 6))\n    (t2:uint64t) = t0^(t0 << 7)\n    (x2:uint64t) = x1^ (t1 * (t2 && (cvt_20_to_64 0x04001)))\n    (x3:uint64t) = x2^ (t1 * (t2 && (cvt_20_to_64 0x08002))) << 1\n    (x4:uint64t) = x3^ (t1 * (t2 && (cvt_20_to_64 0x10004))) << 2\n    (x5:uint64t) = x4^ (t1 * (t2 && (cvt_20_to_64 0x20008))) << 3\n    (x6:uint64t) = x5^ (t1 * (t2 && (cvt_20_to_64 0x40010))) << 4\n    (x7:uint64t) = x6^ (t1 * (t2 && (cvt_20_to_64 0x80020))) << 5\n    rtn = loop_i 0 x7 3 M\n\ngf_sq2mul : gf_t -> gf_t -> gf_t\ngf_sq2mul a b = rtn where\n    (M:[6][64]) = [0x1FF0000000000000,\n        0x000FF80000000000,\n        0x000007FC00000000,\n        0x00000003FE000000,\n        0x0000000001FE0000,\n        0x000000000001E000]\n    (t0:uint64t) = cvt_16_to_64 a\n    (t1:uint64t) = cvt_16_to_64 b\n    (x_1:uint64t) = (t1 << 18) * (t0 && (1 << 6))\n    t2 = t0^(t0 << 21)\n    (x_2:uint64t) = x_1^(t1 * (t0 && (cvt_36_to_64 0x010000001)))\n    (x_3:uint64t) = x_2^(t1 * (t0 && (cvt_36_to_64 0x020000002))) << 3\n    (x_4:uint64t) = x_3^(t1 * (t0 && (cvt_36_to_64 0x040000004))) << 6\n    (x_5:uint64t) = x_4^(t1 * (t0 && (cvt_36_to_64 0x080000008))) << 9\n    (x_6:uint64t) = x_5^(t1 * (t0 && (cvt_36_to_64 0x100000010))) << 12\n    (x_7:uint64t) = x_6^(t1 * (t0 && (cvt_36_to_64 0x200000020))) << 15\n    rtn = loop_i 0 x_7 6 M\n\ngf_sq2 : gf_t -> gf_t\ngf_sq2 in = rtn where\n    (B:[4][64]) = [0x1111111111111111,\n        0x0303030303030303,\n        0x000F000F000F000F,\n        0x000000FF000000FF]\n    (M:[4][64]) = [0x0001FF0000000000,\n        0x000000FF80000000,\n        0x000000007FC00000,\n        0x00000000003FE000]\n    (x_1:uint64t) = cvt_16_to_64 in\n    (x_2:uint64t) = (x_1 || (x_1 << 24)) && (B@3)\n    (x_3:uint64t) = (x_2 || (x_2 << 12)) && (B@2)\n    (x_4:uint64t) = (x_3 || (x_3 << 6)) && (B@1)\n    (x_5:uint64t) = (x_4 || (x_3 << 3)) && (B@0)\n    rtn = loop_i 0 x_5 4 M\n\ngf_frac : gf_t -> gf_t -> gf_t\ngf_frac d n = t7 where\n    t1 = gf_sqmul d d\n    t2 = gf_sq2mul t1 t1\n    t3 = gf_sq2 t2\n    t4 = gf_sq2mul t3 t2\n    t5 = gf_sq2 t4\n    t6 = gf_sq2mul t5 t2\n    t7 = gf_sqmul t7 n\n\ngf_inv : gf_t -> gf_t\ngf_inv d = gf_frac d 1\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/operations.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol specifications for the functions defined in the Operations module of the McEliece KEM implementation. Specifically, provide formal properties or type-level assertions for crypto_kem_enc and crypto_kem_dec that capture their expected input-output behavior and correctness criteria, including the relationship between inputs, outputs, and intermediate computations. Also, specify properties for the hash functions compute_hash_2e, compute_hash_1e, crypto_hash_32b_1, and crypto_hash_32b_2, ensuring their outputs conform to expected lengths and types. The specifications should enable formal verification or testing of these cryptographic operations."},{"role":"assistant","content":"```cryptol\nmodule Operations where\n\n\nimport Types\nimport Encrypt\nimport Decrypt\n\ncompute_hash_2e : SYS_N8_plus1_t -> [32]base_t\ncompute_hash_2e in = undefined\ncompute_hash_1e : pm_t -> [32]base_t\ncompute_hash_1e in = undefined\n\ncrypto_hash_32b_1 : SYS_N8_plus1_t -> [32]base_t\ncrypto_hash_32b_1 in = undefined\n\ncrypto_hash_32b_2 : pm_t -> g_key_t\ncrypto_hash_32b_2 in = undefined\n\n\/\/defined externally\n\/\/ KeccakWidth1600_Sponge\n\n(two_e : SYS_N8_plus1_t) = [ 2 | x <- [0..870]]\n\n\/\/ encapsulation\ncrypto_kem_enc : g_ct_t -> g_key_t -> g_pk_t -> SYS_N8_plus2_t\n    -> (g_ct_t, g_key_t)\ncrypto_kem_enc c0 key pk e =  (c2, key2) where\n    \/\/ step 1. uniform random vector e (given as input)\n    (e :  SYS_N8_plus2_t) = zero\n    \/\/ step 2. use encoding subroutine on e and public key T to compute Co\n    (c1 : g_ct_t) = encrypt c0 pk e\n        (c2 : g_ct_t) = (take `{194} c1 ) # (compute_hash_2e two_e)\n    (one_ec : pm_t) = ([1])#(take `{870} e)#c2\n    (key2 : g_key_t) = compute_hash_1e one_ec\n\n\ncrypto_kem_dec : g_ct_t -> g_sk_t -> g_key_t\ncrypto_kem_dec c sk = key where\n    \/\/ calls decoding subroutine\n    (e : SYS_N8_t, ret_decrypt : gf_t) = decrypt sk c\n    \/\/ calls KeccakWidth1\n    (conf : [32]base_t) = crypto_hash_32b_1 two_e\n    loop_i i rc =\n        if (i<32)\n        then loop_i i' rc' where\n            i' = i+1\n            rc' = rc || ((conf@i) ^ c@(SYND_BYTES + i))\n        else rc\n    (ret_confirm : base_16t) = loop_i 0 0\n    (m_0 : base_16t) = ret_decrypt || ret_confirm\n    (m_1 : base_16t) = m_0 - 1\n    (m : base_16t) = m_1 >> 8\n    x_1 = [(~m && 0) || (m && 1)]\n    x_2 = [(~m && (sk@i)) || (m && (e@i)) | i <- [0..(870-1)]]\n    x_3 = [(c@i) | i <- [0..(194-1+32)]]\n    (preimage: pm_t) = x_1 # x_2 # x_3\n    \/\/ 1 + SYS_N\/8 + (SYND_BYTES + 32)\n    (key : g_key_t) = crypto_hash_32b_2 preimage\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/benes.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the `support_gen` function in the Benes module. The specification should capture the transformation from the input `g_sk_t` to the output list `L_t`, including the intermediate steps such as bit-reversal indexing, matrix updates, and the application of the Benes network. Ensure the specification is suitable for property-based verification or equivalence checking against an implementation."},{"role":"assistant","content":"```cryptol\nmodule Benes where\n\nimport Types\nimport GF\nimport Util\n\n\ntype La_t = [32]\ntype Lb_t = [j_size_t][32]\ntype Lc_t = [GFBITS_t][j_size_t][32]\n\napply_benes r bits rev = zero\n\/* where\n    (bits_ptr, inc) =\n        if rev\n        then (bits_ptr, inc) where\n            bits_ptr = bits + 12288\n            inc = -1024\n        else (bits_ptr, inc) where\n            bits_ptr = bits\n            inc = 0\n\n    (r_int_v_0:[64][64]) = [ load8 (r + i*16 + 0) | i<- [0..63]]\n    (r_int_v_1:[64][64]) = [ load8 (r + i*16 + 8) | i<- [0..63]]\n    (r_int_v:[2][64][64]) = [r_int_v_0, r_int_v_1]\n\n    r_int_h_0 = transpose_64x64 r_int_v_0\n    r_int_h_1 = transpose_64x64 r_int_v_1\n\n    \/\/\/\/--- fixme\n    r_int_v_0 = transpose_64x64 r_int_h_0\n    r_int_v_1 = transpose_64x64 r_int_h_1\n*\/\n\nsupport_gen : g_sk_t  -> L_t\nsupport_gen c  = s where\n    k_size = (1:La_t) << GFBITS\n    loop_i : La_t -> Lc_t -> Lc_t\n    loop_i ix L =\n        if(ix<k_size)\n        then  loop_i ix' L' where\n            (_, a) = bitrev ix\n            loop_j : La_t -> Lc_t -> Lc_t\n            loop_j jx M =\n                if (jx < GFBITS)\n                then loop_j jx' M' where\n                    (kx:La_t) = ix\/8\n                    (val_jx:Lb_t) = M@jx\n                    (val_kx:La_t) = val_jx@kx\n                    (c:La_t) = (ix%8:La_t)\n                    (d:La_t)  = (((a >> jx) && (1:La_t)) << c)\n                    (val_0:La_t) =  val_kx || d\n                    (val_1:Lb_t) = (update val_jx kx val_0)\n                    (M':Lc_t) = update M jx val_1\n                    (jx':La_t) = jx+1\n                else M\n            L' = loop_j 0 L\n            ix' = ix+1\n        else L\n    (L_0:Lc_t) = zero\n    (L_1:Lc_t) = loop_i 0 L_0\n    (L_2:Lc_t) =[(apply_benes l c 0) | l <- L_1]\n    loop_ix : La_t -> L_t -> L_t\n    loop_ix ix s =\n        if (ix<SYS_N)\n        then loop_ix (ix+1) s_2  where\n            loop_jx : La_t -> L_t -> L_t\n            loop_jx jx s =\n                if(jx>=0)\n                then loop_jx jx' s' where\n                    (x : La_t) = (L_2@jx)@(ix\/8)\n                    (y : La_t) = (x >> (ix%8)) && 1\n                    (z : base_t) = (s@ix << (1:base_t)) || ( cvt_32_to_16 y)\n                    (jx': La_t) = jx-1\n                    s' = update s ix z\n                else s\n\n                        s_1 = update s ix 0\n            s_2 = loop_jx (GFBITS-1) s_1\n        else s\n    (s:L_t) = loop_ix 0 zero\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/decrypt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the 'decrypt' function in the given module. The specification should capture the relationship between the secret key input, ciphertext input, and the resulting output tuple (error vector and check value). Include properties that verify correctness of syndrome computation, error locator polynomial generation, root finding, error vector reconstruction, and the final consistency check."},{"role":"assistant","content":"```cryptol\nmodule Decrypt where\n\nimport Benes\nimport Types\nimport Decrypt_helpers\nimport GF\nimport Util\n\n\/\/decrypt\n\/\/[13908] base_t -> [226] base_t  \ndecrypt : g_sk_t -> g_ct_t -> (f_t, gf_t)\ndecrypt sk c = (e, check) where\n    (r : r_t) = (take `{194} c)#zero\n    loop_1 g i sk_index =\n        if i < SYS_T\n        then loop_1 g' (i+1) (sk_index+2) where\n            (a : gf_t)= load2 sk sk_index\n            (b : gf_t) = a && GFMASK\n            g'= update g i b\n        else g\n    (g_0 : g_t) = zero\n    (g_1 : g_t) = loop_1 g_0 0 0\n    (L : L_t) = support_gen sk\n    (s : s_t) = synd g_1 L r\n    (locator : g_t) = bm s\n    (images : SYS_N_t) = root locator L\n    loop_2 : [32] -> f_t -> gf_t -> (f_t, gf_t)\n    loop_2 i e w =\n        if (i<SYS_N)\n        then loop_2 (i+1) e' w' where\n            (t : gf_t) = (gf_iszero (images @i)) && (1:[16])\n            jx = i\/8\n            val = (e@jx) || t << (i%8)\n            (e' : f_t) = update e jx val\n            (w' : gf_t) = w+t\n        else (e, w)\n    (e : f_t, w : gf_t) = loop_2 0 zero 0\n    (s_cmp : s_t) = synd g_1 L e\n    loop_3 i check =\n        if (i<SYS_T*2)\n        then  loop_3 (i+1) check' where\n            check' = check || ((s@i) ^ (s_cmp@i))\n        else check\n    (check_0 : gf_t) = w ^ SYS_T\n    (check_1 : gf_t) = loop_3 0 check_0\n    (check_2 : gf_t) = (check_1 -1)>> 15\n    (check : gf_t) = check_2 ^ 1\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/decrypt_helpers.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the functions 'eval', 'root', 'synd', and 'bm' in the 'Decrypt_helpers' module. The properties should capture the expected algebraic behaviors and invariants of these functions based on their roles in the McEliece KEM decryption process, ensuring they conform to the mathematical definitions of polynomial evaluation, syndrome computation, and the Berlekamp-Massey algorithm."},{"role":"assistant","content":"```cryptol\nmodule Decrypt_helpers where\n\nimport Types\nimport GF\nimport Util\n\neval f a = out where\n    loop_i i r =\n        if (i<0) then r\n        else loop_i i' r' where\n            r' = gf_add (gf_mul r a) (f@i)\n            i' = i-1\n    r_init = f@SYS_T\n    i_init = SYS_T-1\n    out = loop_i i_init r_init\n\nroot : g_t ->  SYS_N_t -> SYS_N_t\nroot f L = out where\n    out = [ eval f l | l <- L]\n\nsynd : g_t -> L_t -> r_t -> s_t\nsynd f L r = out' where\n    loop_j i j out e_inv c =\n        if (j<SYS_T_double)\n        then (loop_j i j' out' e_inv' c) where\n            j' = j+1\n            x = gf_mul e_inv c\n            y = gf_add (out@j) x\n            out' = update out j y\n            e_inv' = gf_mul e_inv (L@i)\n        else (out, e_inv)\n\n    loop_i i out e_inv c =\n        if (i<SYS_N)\n        then loop_i i' out' e_inv' c where\n            c = (r@(i\/8) >> (i%8)) && (1:[16])\n            e = eval f (L@i)\n            e_inv = gf_inv (gf_mul e e)\n            (out', e_inv') = loop_j i 0 out e_inv c\n            i' = i+1\n        else out\n    out' = loop_i 0 zero 0 0\n\nbm : s_t-> g_t\nbm s = out where\n    N_limit =  2 * SYS_T\n    outer_loop N B C T L b =\n        if (N<N_limit) then (outer_loop N_2 B_3 C_2 T_2 L_2 b_2) where\n            (d_0 : gf_t) = zero\n            limit = min N SYS_T\n            loop_1 i d  =\n                if(i < limit)\n                then loop_1 i' d' where\n                    d' = d ^ (gf_mul (C@i) (s@(N-i)))\n                    i' = i+1\n                else d\n            (d_1 : gf_t) = loop_1 0 d_0\n            (mne: uint16t) = ((d_1 - (1:[16]))>> 15) - (1:[16])\n            (mle_0: uint16t)= ((N - (2:[16])*L) >> 15) - (1:[16])\n            (mle_1: uint16t) = mle_0 && mne\n            (T_2 : SYS_T_plus1) = C\n            (f: gf_t) = gf_frac b d_1\n            (C_2: SYS_T_plus1) =\n                [c ^ ((gf_mul f (B@i)) && mne)\n                | i <- [0.. 120]\n                | c <- C]\n            (L_2: uint16t) = (L && ~mle_1) || ((N+1-L) && mle_1)\n            (B_2: SYS_T_plus1) =\n                [((b && ~mle_1) || (t && mle_1)) | b <- B | t <- T]\n            b_2 = (b && ~mle_1) || (d_1 && mle_1)\n            (B_3: SYS_T_plus1) = zero # (take `{119} B_2)\n            N_2 = N+1\n        else C\n    (N : uint16t) = 0\n    (L : uint16t) = 0\n    (B_0 : SYS_T_plus1) = zero\n    (B_1 : SYS_T_plus1) = update B_0 1 1\n    (C_0 : SYS_T_plus1) = zero\n    (C_1 : SYS_T_plus1) = update C_0 0 1\n    (T : SYS_T_plus1) = zero\n    (b : gf_t) = 1\n    (C_2 : SYS_T_plus1)= outer_loop N B_1 C_1 T L b\n    out = reverse C_2\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/types.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol type specifications and properties that verify the correctness and consistency of the type definitions and constants in the given McEliece KEM low-level types module. Ensure that the sizes and relationships between the defined types (e.g., SYS_T, SYS_N, PK_ROW_BYTES) conform to expected constraints and that conversions between base types preserve bit widths correctly."},{"role":"assistant","content":"```cryptol\nmodule Types where\n\n\n\/\/ Values\nSYS_T = 119\nSYS_N = 6960\nSYS_Nd8 = SYS_N\/8 GFBITS =  13\ntype GFBITS_t =  13\nCOND_BYTES  = (((1:[32]) << (GFBITS-(4:[32])))*(2*GFBITS - (1:[32])))\nIRR_BYTES = (SYS_T * 2)\nPK_NROWS  =  (SYS_T*GFBITS)\nPK_NCOLS  =  (SYS_N - PK_NROWS)\nPK_ROW_BYTES  =  ((PK_NCOLS + 7)\/8)\ntype PK_ROW_BYTES_t = [677]\nSK_BYTES  =  (SYS_Nd8 + IRR_BYTES + COND_BYTES)\nSYND_BYTES  =  ((PK_NROWS + 7)\/8)\ntype SYND_BYTES_t = [194]\nGFMASK  =  (((1:[32]) << GFBITS) - 1)\ntype j_size_t =  1024 \/\/ Base Types\ntype base_16t = [16]\ntype base_32t = [32]\ntype base_64t = [64]\ntype uint16t = [16]\ntype uint64t = [64]\ntype uint32t = [32]\ntype base_t = base_16t\ntype gf_t = base_t\n\n\/\/parameter Types\ntype ciphertext_t = [226] base_t    \/\/ crypto_kem_CIPHERTEXTBYTES\ntype keybytes_t = [32] base_t \/\/ crypto_kem_BYTES\ntype publickey_t = [1047319]base_t \/\/ crypto_kem_PUBLICKEYBYTES\ntype secretkey_t = [13908] base_t type g_s_t =   ciphertext_t\ntype g_ct_t =  ciphertext_t\ntype g_key_t = keybytes_t\ntype g_pk_t =  publickey_t\ntype g_sk_t = secretkey_t\n\ntype SYS_N8_t = [870] base_t\ntype SYS_N8_plus1_t = [871] base_t\ntype SYS_N8_plus2_t = [872]base_t\n\nSYS_T_double = 238type SYS_T_double_t = [238]base_t\ntype SYS_N_t = [6960]base_t\ntype SYS_T_plus1 = [120]base_t\n\n\/\/decrypt specific types\ntype L_t = SYS_N_t type f_t = SYS_N8_t\ntype r_t = SYS_N8_t\ntype g_t = SYS_T_plus1\ntype s_t = SYS_T_double_t \/\/encap specific types\ntype e_t = SYS_N8_plus2_t\ntype ind_t = SYS_T_double_t\ntype e_int_t = [109]base_t\ntype val_t = [119] base_t\ntype e_pieces_t = [109][8]base_t\n\n\n\/\/ used in operations module\ntype pm_t =  [1097]base_t cvt_16 e = fromInteger `{[16]} (toInteger e)\ncvt_32 e = fromInteger `{[32]} (toInteger e)\ncvt_64 e = fromInteger `{[64]} (toInteger e)\ncvt_32_to_16 e = cvt_16 e\ncvt_64_to_16 e = cvt_16 e\ncvt_16_to_32 e = cvt_32 e\ncvt_20_to_64 e = cvt_64 e\ncvt_16_to_64 e = cvt_64 e\ncvt_36_to_64 e = cvt_64 e\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/encrypt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the 'encrypt' function in the Encrypt module. The properties should ensure that the encryption output 's' correctly corresponds to the syndrome computed from the public key 'pk' and the error vector 'e', and that the intermediate functions such as 'gen_e' and 'syndrome' behave as expected according to the McEliece KEM specification. Include properties to check invariants on the data transformations and bit manipulations within these functions."},{"role":"assistant","content":"```cryptol\nmodule Encrypt where\n\nimport Types\nimport Util\n\nmov_forward : ind_t -> (ind_t, Bool)\nmov_forward ind_0 = outer_loop 0 ind_0 False where\n    inner_loop : _ -> _ -> ind_t -> Bool -> (ind_t, Bool)\n    inner_loop j i ind found =\n        if (j < (SYS_T* 2))\n        then if(jval<SYS_N)\n            then inner_loop (j+1) i ind' found'\n            else inner_loop (j+1) i ind found\n        else (ind, found)\n        where\n            (jval : base_t) = ind@j\n            (ind' : ind_t) = update (update ind j (ind@i)) i jval\n            found' = True\n    outer_loop : _ -> ind_t -> Bool -> (ind_t, Bool)\n    outer_loop i ind found =\n        if (i < SYS_T)\n        then if(found')\n            then outer_loop (i+1) ind' found'\n            else (ind', found')\n            where\n                (ind', found') = inner_loop i i ind found\n        else (ind, found)\n\nloop_x i ind = if (i<SYS_T*2) then loop_x (i+1) ind' else ind\n    where\n    ind' = update ind i ((ind@i) && GFMASK)\n\n\/\/ when find equal value returns true\nloop_findEq : ind_t  -> _ -> Bool -> Bool\nloop_findEq ind i rtn = if (i<SYS_T) then rtn' else rtn\n    where\n        loop_z : ind_t -> _ -> _ -> Bool\n        loop_z ind i j =\n            if(j<i)\n            then\n                if((ind@i) == (ind@j))\n                then True\n                else loop_z ind i (j+1)\n            else False\n        rtn' = if(loop_z ind i 0)\n            then True\n            else loop_findEq ind (i+1) rtn\n\n\/\/ While_loop : Might consider adding a limit to the counter here\nwhile_loop : ind_t -> ind_t\nwhile_loop ind =\n    if(loop_findEq ind_2 1 False) then ind_2 else while_loop ind_2\n    where ind_2 = loop_x 0 ind\n\n\n\/\/ --------------------------------------------- gen_e for loops\n\/\/ implements val[j] = one << (ind[j] & 63)\nloop_a : base_t -> val_t ->ind_t -> val_t\nloop_a j val ind =\n    if (j<SYS_T) then loop_a (j+1) val' ind else val\n    where\n        x = 1 << ((ind@j) && 63)\n        val' = update val j x\n\nloop_c : base_t ->  val_t -> ind_t -> e_int_t -> e_int_t\nloop_c i val ind e_int  =\n    if(i < (SYS_N+63)\/64) then e_int' else e_int\n    where\n    (e_int' : e_int_t) = loop_b 0 i val ind e_int\n    loop_b : base_t -> base_t -> val_t -> ind_t -> e_int_t -> e_int_t\n    loop_b j i val ind e_int =\n        if (j<SYS_T) then loop_b (j+1) i val ind e_int' else e_int\n        where\n            (mask_0 : base_t) =cvt_16 (ind@j)\n            (mask_1 : base_t) = i^(mask_0 >> 6)\n            (mask_2 : base_t) = mask_1-1\n            (mask_3 : base_t) = mask_2 >> 63\n            (mask : base_t) = -1* mask_2\n            (m : base_t) = e_int@i\n            (n : base_t) = (val@j) && mask\n            (o : base_t) = m ||  n\n            (e_int' : e_int_t) = update e_int i o\n\n\/\/ store in groups of 8\nloop_d : _ ->  e_int_t -> e_pieces_t ->  e_t\nloop_d i e_int e_pieces =\n    if (i < (SYS_N+63)\/64 - 1)\n    then loop_d (i+1) e_int e_pieces'\n    else join e_pieces\n    where\n        (x : [8]base_t) = store8 (e_pieces@i) (e_int@i)\n        (e_pieces' : e_pieces_t) = update e_pieces i x\n\n\/\/shift each value by j and && with 0xFF\nloop_e : _ -> _ -> e_int_t -> e_t -> e_t\nloop_e j i e_int e =\n    if (j<(SYS_N % 64)) then loop_e (j+8) i e_int e' else e\n    where\n        (w : base_t) = (e_int@i) >> j\n        (x : base_t) = w && (cvt_16 0xFF)\n        (e' : [872]base_t) = update e (j\/8) x\n\ngen_e : e_t -> e_t\ngen_e e = undefined where\n    (val_1 : val_t) = zero\n    (ind_1 : ind_t) = zero\n    (e_int_1 : e_int_t) = zero\n    (ind_2 : ind_t)  = while_loop ind_1\n    (val_2 : val_t) = loop_a 0 val_1 ind_2\n    (e_int_2 : e_int_t) = loop_c 0 val_2 ind_2 e_int_1\n    (e_pieces_1 : e_pieces_t) = groupBy `{8} e\n    (e_2 : e_t) = loop_d 0 e_int_2 e_pieces_1\n    (i : [16]) = (SYS_N+63)\/64 - 1 \/\/max at previous loop\n    (e_3 : e_t) = loop_e 0 i e_int_2 e_2\n\nsyndrome : g_pk_t -> e_t -> g_s_t -> g_s_t\nsyndrome pk e s_in = s_out where\n    tail = PK_NROWS % 8\n    \/\/ PK_ROW_BYTES = 677\n    \/\/ PK_NROWS = 1547\n    pk_short = take `{1047319} pk \/\/ PK_ROW_BYTES * PK_NROWS (right size)\n    pk_ptr = groupBy `{677} pk_short\n    loop_c : _ -> SYS_N8_t -> SYS_N8_t\n    loop_c j row =\n        if (j >= SYS_N\/8 - PK_ROW_BYTES)\n        then loop_c (j-1) row'\n        else row\n        where\n            a = (row @ j) << tail\n            b = (row @ (j-1)) >> (8-tail)\n            c = a||b\n            row' = update row j c\n    loop_d : _ -> base_t -> SYS_N8_t -> base_t\n    loop_d j b row =\n        if (j < (SYS_N\/8))\n        then loop_d (j+1) ((row@j) && (e@j)) row\n        else b\n    second_loop : _ -> g_s_t -> g_s_t\n    second_loop i s =\n        if (i < PK_NROWS)\n        then second_loop (i+1) s_out\n        else s\n        where\n            (row_1 : SYS_N8_t) =  zero # (pk_ptr@i)\n            (row_2 : SYS_N8_t) = loop_c (SYS_N\/8-1) row_1\n            (d : base_t) =  (row_2@(i\/8))|| (1 << (i%8))\n            (row_3 : SYS_N8_t) =  update row_2 (i\/8) d\n            (b_0 : base_t) = loop_d 0 0 row_3\n            (b_1 : base_t) = b_0 ^ (b_0>>4)\n            (b_2 : base_t) = b_1 ^ (b_1>>2)\n            (b_3 : base_t) = b_2 ^ (b_2>>1)\n            (b_4 : base_t) = b_3 && 1\n            (sval : base_t) =  (s@(i\/8)) || (b_4 << (i%8))\n            (s_out : g_s_t) =  update s (i\/8) sval\n    (s : g_s_t) = zero # (drop `{194} s_in)\n    s_out = second_loop 0 s\n\nencrypt : g_s_t -> g_pk_t -> e_t -> g_s_t\nencrypt s pk e = s where\n    (e' : e_t) = gen_e e\n    (s : g_s_t) = syndrome pk e' s\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/CM_Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the CM parameter construction and validation functions in the CM_Parameters module. Specifically, specify properties that check the consistency of the make_mk function (e.g., that q equals 2^m, and k equals n - m*t), and that mk_ok correctly identifies valid parameter sets according to the given constraints."},{"role":"assistant","content":"```cryptol\nmodule CM_Parameters where\n\ntype a_ty = [32]\n\ntype CM =\n    { m : a_ty  \/\/log2q\n    , q : a_ty  \/\/ The size of the field used\n    , n : a_ty  \/\/ The code length\n    , t : a_ty  \/\/ The guaranteed error-correction capability\n    , k : a_ty  \/\/ The code dimension\n    , d : a_ty \/\/ ` Length of hash disgest\n    }\n\ntype byte_rep n = [n\/8][8] Bit\n\n\n\/\/ -- 2.8 representation of objects as byte strings\n\/\/ -- 3.1  list of paramter set\n\n\/\/ Initiate CM parameter\nmake_mk : a_ty -> a_ty -> a_ty -> a_ty -> CM \nmake_mk m n t d =\n    { m = m : a_ty\n    , q = (2^m) : a_ty\n    , n = n : a_ty\n    , t = t : a_ty\n    , k = (n-m*t) : a_ty\n    , d = d : a_ty\n    }\n\n\/\/ Check if CM parameters are OK\nmk_ok : CM -> Bool\nmk_ok cm =\n    ((is_pos m) \/\\ (n_ok) \/\\ (t_ok) \/\\ (is_pos cm.d))\n    where\n        m = cm.m\n        n = cm.n\n        t = cm.t\n        is_pos e = e>0\n        n_ok = ((is_pos n) \/\\ (n <= cm.q))\n        t_ok = (t>=2) \/\\ (m*t <n)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/CM_696.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the correctness properties of the `cm696` parameter set for the McEliece KEM scheme, ensuring that all parameters satisfy the expected constraints and relationships as defined in the McEliece cryptosystem."},{"role":"assistant","content":"```cryptol\nmodule CM_696 where\n\nimport CM_Parameters\n\ncm696  =\n    { m = 13 : a_ty\n    , q = (2^13) : a_ty\n    , n = 6960 : a_ty\n    , t = 119 : a_ty\n    , k = 5413 : a_ty\n    , d = 256 : a_ty\n    } : CM\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/Encapsulation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected properties of the 'encapsulation' function in the given McEliece KEM module. The specification should capture the correctness criteria relating the input public key and error vector to the output session key and ciphertext, including the relationship between the encoding subroutine, hash computations, and the resulting ciphertext structure. Include properties that verify the consistency of types and the correctness of the hash outputs relative to the inputs."},{"role":"assistant","content":"```cryptol\nmodule Encapsulation where\n\nparameter\n    type t : #\n    type constraint (fin t, t>=1, t-1>=1)\n    type n : #\n    type constraint (fin n, n>=1)\n    type m : #\n    type constraint (fin m, m>=1, t * n == min t n)\n    type d : #\n\n\/\/ in order of general algorithm spec\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [(n-m*t)]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [m*t]f2_T  \/\/ also n-k\ntype H_T = [t][n]field_element_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                \/\/ [13]Bit\n    , a : alphas_T              \/\/ [6960][13]Bit  \/\/[n][m]Bit\n    }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                   \/\/ [870][8]Bit\n    , g : gamma_T\n    }\ntype public_key_T = [m*t][(n-m*t)]f2_T\ntype C0_T = mt_T\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\n\n\/\/ a bit string of length and Hamming weight T\ntype weighted_T = n_T\n\n\n\/\/--------------------------------------------------\n\/\/ Define H = (I_n-k |T )\nstep_1 : mt_T -> public_key_T -> H_T\nstep_1 I A = zero\n\/\/ get inverse A|I\n\n\/\/ reduce matrix I|B\n\/\/ Co = He\nstep_2 : H_T -> weighted_T -> C0_T\nstep_2 H e = zero\n\n\/\/\n\/\/ encoding subroutine\nencoding_subroutine : weighted_T -> public_key_T -> C0_T\nencoding_subroutine e T = C0 where\n    (I: mt_T) = zero\n    (H:H_T) = step_1 I T         (C0:C0_T) = step_2 H e\n\n\ntype session_key_t = [32] \/\/?\n\/\/ 2.6.3\ncompute_hash_2e e = undefined\n\/\/ 2.6.4\ncompute_hash_1e e C = undefined\n\n\/\/ step 1.) uniform random vector e\nencapsulation\n    : public_key_T ->  weighted_T\n    -> (session_key_t, cipher_text_T)\nencapsulation T e =  (K, C) where\n    \/\/ step 1. uniform random vector e (given as input)\n    \/\/ step 2. use encoding subroutine on e and public key T to compute Co\n    (C0 : C0_T) = encoding_subroutine e T\n        (C1: C1_T) = compute_hash_2e e\n    (C: cipher_text_T) = {C0 = C0, C1 = C1}\n    (K: session_key_t) = compute_hash_1e e C\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/CM_819.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the properties and constraints of the CM_819 parameter set for the McEliece KEM scheme, ensuring that all parameters (m, q, n, t, k, d) satisfy the expected mathematical relationships and security requirements."},{"role":"assistant","content":"```cryptol\nmodule CM_819 where\n\nimport CM_Parameters\n\nCM_819 =\n    { m = 13 : a_ty\n    , q = (2^13) : a_ty\n    , n = 8192 : a_ty\n    , t = 128 : a_ty\n    , k = (8192-(13*128)) : a_ty\n    , d = 256 : a_ty\n    } : CM\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/Key_Generation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the key_generation function in the Key_Generation module. The properties should ensure that the generated public and private keys satisfy the expected type constraints and structural invariants defined in the module, and that the key generation process is consistent with the algorithm's intended behavior."},{"role":"assistant","content":"```cryptol\nmodule Key_Generation where\n\nparameter\n    type t : #\n    type constraint (fin t, t>=1, t-1>=1)\n    type n : #\n    type constraint (fin n, n>=1)\n    type m : #\n    type constraint (fin m, m>=1, t * n == min t n)\n    type d : #\n\n\/\/ in order of general algorithm spec\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [(n-m*t)]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [m*t]f2_T\ntype H_T = [t][n]field_element_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                \/\/ [13]Bit\n    , a : alphas_T              \/\/ [6960][13]Bit  \/\/[n][m]Bit\n    }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                   \/\/ [870][8]Bit\n    , g : gamma_T\n    }\ntype public_key_T = [m*t][(n-m*t)]f2_T\ntype C0_T = mt_T\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\ntype e_T =\n    { length : n_T\n    , hammington_weight : t_T\n    }\n\n\nrandom_element : field_element_T\nrandom_element = ([True | i <- [1..m]])\nrandom_elements : {t0}(fin t0, t0>=1) => [t0]field_element_T\nrandom_elements = ([random_element | i <- [1..t0]])\n\nstep_1 = random_elements `{ t0 = t-1}#[1]\n\nstep_3 : (t * n == min t n) =>  poly_T -> alphas_T -> H_T\nstep_3 g alphas = [[ f i j | j <- [1..n]] | i <- [1..t]]\n    where f i j = aj \/ (g @ aj)\n            where aj = alphas@j\n\nstep_5 : H_T -> (Bool, public_key_T)\nstep_5 H_tilde = undefined\n\nmk_gamma : Integer -> (gamma_T,public_key_T)\nmk_gamma counter =\n    if(flag) then ({p=g, a=alphas}, public_key)\n    else if (counter < 100)\n        then mk_gamma (counter+1)\n    else undefined\n    where\n                (g: poly_T) = step_1\n        (alphas: alphas_T) =  random_elements `{ t0 = n}\n        (H_tilde: H_T) = step_3 g alphas\n        (flag, public_key) = step_5 H_tilde\n\nkey_generation : [n]Bit -> (public_key_T, private_key_T)\nkey_generation s = (public_key, private_key) where\n    (gamma: gamma_T, public_key: public_key_T) = mk_gamma 0\n    (private_key: private_key_T) = {s=s, g=gamma}\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/Types.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol type and value-level specifications that capture the correctness properties and invariants of the McEliece KEM types defined in this module. Include properties that verify the size constraints, relationships between parameters (such as t, n, m, d), and structural consistency of composite types like gamma_T, private_key_T, public_key_T, and cipher_text_T. Ensure the specifications can be used to verify that values conform to the expected bit-lengths and algebraic constraints inherent in the McEliece cryptosystem."},{"role":"assistant","content":"```cryptol\nmodule Types where\n\nparameter\n    type t : #\n    type constraint (fin t, t>=1, t-1>=1)\n    type n : #\n    type constraint (fin n, n>=1)\n    type m : #\n    type constraint (fin m, m>=1, t * n == min t n)\n    type d : #\n\n\/\/ in order of general algorithm spec\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [(n-m*t)]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [m*t]f2_T  \/\/ also n-k\ntype H_T = [t][n]field_element_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                \/\/ [13]Bit\n    , a : alphas_T              \/\/ [6960][13]Bit  \/\/[n][m]Bit\n    }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                   \/\/ [870][8]Bit\n    , g : gamma_T\n    }\ntype public_key_T = [m*t][(n-m*t)]f2_T\ntype C0_T = mt_T\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\n\n\/\/ a bit string of length and Hamming weight T\ntype weighted_T = n_T\n\n\n-------------\n\/\/\/\/type crypto_kem_CIPHERTEXTBYTES = [226] -> 1808\n\/\/vs. {mt_T, d_T}  (1547, 256) -> 1803\n\n\n\/\/type crypto_kem_PUBLICKEYBYTES = [1047319]\n\/\/ [1547][5413]   ->8373911\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/keccak.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the Keccak hash function implementation in the provided module. Include properties that check the correctness of the padding, absorbing, squeezing phases, and the round transformations (\u03b8, \u03c1, \u03c0, \u03c7, \u03b9). Also, specify properties that validate the provided test vectors for SHA-3 and SHAKE variants against the expected hash outputs."},{"role":"assistant","content":"```cryptol\n\/\/ Specification of the Keccak (SHA-3) hash function\n\/\/ Author: David Lazar\n\nmodule Keccak where\n\nSHA_3_224 M = take`{224} (Keccak `{r = 1152, c =  448} (M # 0b01))\nSHA_3_256 M = take`{256} (Keccak `{r = 1088, c =  512} (M # 0b01))\nSHA_3_384 M = take`{384} (Keccak `{r =  832, c =  768} (M # 0b01))\nSHA_3_512 M = take`{512} (Keccak `{r =  576, c = 1024} (M # 0b01))\nSHAKE128 M = Keccak`{r = 1344, c = 256} (M # 0b1111)\nSHAKE256 M = Keccak`{r = 1088, c = 512} (M # 0b1111)\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Specification of the cSHAKE (customizable SHAKE) function\n\n\/\/ cshake_128 : {m, n, s} \n\/\/     ( fin m\n\/\/     , fin n\n\/\/     , fin s\n\/\/    \/\/ , m >= 192\n\/\/     \/\/, m <=320\n\/\/     , (2^^2040-1) >= (n*8)\n\/\/     , (2^^2040-1) >= (n*s)\n\/\/     ) => [m] -> [n][8] -> [s][8]-> [inf]\nCSHAKE128 M s1 s2 = if (s1 == \"\" \/\\ s2 == \"\") then (SHAKE128 M)\n                                               else (Keccak`{r = 1344, c = 256} (join(s1)#join(s2)#M#0b00))\n\n\/\/ NOTE: We are unsure if (join(s1)#join(s2)#M#0b00)) is the correct value\n\n\n\/\/ cshake_256 : {m, n, s} \n\/\/     ( fin m\n\/\/     , fin n \n\/\/     , fin s\n\/\/    \/\/ , m >= 192\n\/\/    \/\/ , m <=320\n\/\/     , (2^^2040-1) >= (n*8)\n\/\/     , (2^^2040-1) >= (n*s)\n\/\/     ) => [m] -> [n][8] -> [s][8]-> [inf]\nCSHAKE256 M s1 s2 = if (s1 == \"\" \/\\ s2 == \"\") then (SHAKE256 M)\n                                               else (Keccak`{r = 1088, c = 512} (join(s1)#join(s2)#M#0b00))\n\n\/\/ NOTE: We are unsure if (join(s1)#join(s2)#M#0b00)) is the correct value\n\n\nKeccak : {r, c, m}\n  ( fin r, fin c, fin m\n  , r >= 1\n  , (r + c) % 25 == 0\n  , 64 >= (r + c) \/ 25\n  ) => [m] -> [inf]\nKeccak M = squeeze `{r = r} (absorb `{w = (r + c) \/ 25} Ps)\n  where Ps = pad `{r = r} M\n\nsqueeze : {r, w} (fin r, fin w, 64 >= w, r >= 0, 25 * w >= r) => [5][5][w] -> [inf]\nsqueeze A = take`{r} (flatten A) # squeeze`{r = r} (Keccak_f A)\n\nabsorb : {r, w, n} (fin r, fin w, fin n, 64 >= w, 25 * w >= r) => [n][r] -> [5][5][w]\nabsorb Ps = as ! 0\n  where\n    as = [zero] # [ Keccak_f `{w = w} (s ^ (unflatten p)) | s <- as | p <- Ps ]\n\npad : {r, m}\n  ( fin r, fin m\n  , r >= 1\n  ) => [m] -> [(m + 2) \/^ r][r]\n  \npad M = split (M # [True] # zero # [True])\n\nKeccak_f : {w} (fin w, 64 >= w) => [5][5][w] -> [5][5][w]\nKeccak_f A0 = rounds ! 0\n  where\n    rounds = [A0] # [ Round RC A | RC <- RCs`{w = w} | A <- rounds ]\n\nRound : {w} (fin w) => [5][5][w] -> [5][5][w] -> [5][5][w]\nRound RC A = \u03b9 RC (\u03c7 (\u03c0 (\u03c1 (\u03b8 A))))\n\n\u03b8 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03b8 A = A'\n  where\n    C = [ xor a | a <- A ]\n    D = [ C @ x ^ (C @ y <<< 1)\n        | (x:[8]) <- [4,0,1,2,3]\n        | (y:[8]) <- [1,2,3,4,0]\n        ]\n    A' = [ [ a ^ (D @ x) | a <- A @ x ] | (x:[8]) <- [0 .. 4] ]\n\n\u03c1 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03c1 A = groupBy`{5} [ a <<< r | a <- join A | (r:[8]) <- R ]\n  where R = [00, 36, 03, 41, 18,\n             01, 44, 10, 45, 02,\n             62, 06, 43, 15, 61,\n             28, 55, 25, 21, 56,\n             27, 20, 39, 08, 14]\n\n\u03c0 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03c0 A = groupBy`{5} [ A @ ((x + 3*y) % 5) @ x\n                  | (x:[8]) <- [0..4], (y:[8]) <- [0..4]\n                  ]\n\n\u03c7 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03c7 A = groupBy`{5} [ (A @ x @ y) ^ (~ A @ ((x + 1) % 5) @ y\n                                  && A @ ((x + 2) % 5) @ y)\n                  | (x:[8]) <- [0..4], (y:[8]) <- [0..4]\n                  ]\n\n\u03b9 : {w} (fin w) => [5][5][w] -> [5][5][w] -> [5][5][w]\n\u03b9 RC A = A ^ RC\n\nRCs : {w, n} (fin w, fin n, 24 >= n, n == 12 + 2 * (lg2 w)) => [n][5][5][w]\nRCs = take`{n} [ [[take`{w} RC] # zero] # zero | RC <- RCs64 ]\n\nRCs64 : [24][64]\nRCs64 = join (transpose [\n    [0x0000000000000001, 0x000000008000808B],\n    [0x0000000000008082, 0x800000000000008B],\n    [0x800000000000808A, 0x8000000000008089],\n    [0x8000000080008000, 0x8000000000008003],\n    [0x000000000000808B, 0x8000000000008002],\n    [0x0000000080000001, 0x8000000000000080],\n    [0x8000000080008081, 0x000000000000800A],\n    [0x8000000000008009, 0x800000008000000A],\n    [0x000000000000008A, 0x8000000080008081],\n    [0x0000000000000088, 0x8000000000008080],\n    [0x0000000080008009, 0x0000000080000001],\n    [0x000000008000000A, 0x8000000080008008]\n])\n\nunflatten : {r, w} (fin w, 25*w >= r) => [r] -> [5][5][w]\nunflatten p = transpose (groupBy`{5} (reverse (groupBy`{w} (reverse (p # zero)))))\n\nflatten : {w} (fin w) => [5][5][w] -> [5 * 5 * w]\nflatten A = reverse (join (reverse (join (transpose A))))\n\nxor : {a, b} (fin a) => [a][b] -> [b]\nxor xs = xors ! 0\n  where xors = [zero] # [ x ^ z | x <- xs | z <- xors ]\n\nproperty RC_correct i j =\n  (i:[8]) < 24 ==> (j:[8]) < 7 ==> RCs64@i!(2^^j - 1) == lfsr@(j + 7*i)\n\nlfsr : [inf]\nlfsr = [ p!0 | p <- ps ]\n  where\n    \/* powers of x modulo m *\/\n    ps = [0x01] # [ pmod (pmult p 0b10) m | p <- ps ]\n    m = <| x^^8 + x^^6 + x^^5 + x^^4 + 1 |>\n\n\/* See https:\/\/keccak.team\/files\/Keccak-reference-3.0.pdf, Section 1.2 *\/\nproperty unflatten_correct x y z p =\n  x < 5 ==> y < 5 ==> z < (64:[12]) ==>\n  p@((5*y + x)*64 + z) == unflatten`{1600,64} p @ x @ y ! z\n\nproperty flatten_correct s =\n  unflatten`{1600,64} (flatten`{64} s) == s\n\n\/** Splits a list of bits into bytes, using little-endian bit order. **\/\ntoBytes : {n} (fin n) => [8*n] -> [n][8]\ntoBytes s = reverse (split (reverse s))\n\n\/** Joins a list of bytes into a list of bits, using little-endian bit order. **\/\nfromBytes : {n} (fin n) => [n][8] -> [8*n]\nfromBytes bs = reverse (join (reverse bs))\n\n\/*\nTest vectors from\nhttps:\/\/csrc.nist.gov\/projects\/cryptographic-standards-and-guidelines\/example-values#aHashing\n*\/\n\nproperty t1 = join (toBytes (SHA_3_224 [])) ==\n  0x6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7\nproperty t2 = join (toBytes (SHA_3_256 [])) ==\n  0xa7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a\nproperty t3 = join (toBytes (SHA_3_384 [])) ==\n  0x0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004\nproperty t4 = join (toBytes (SHA_3_512 [])) ==\n  0xa69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26\n\nproperty u1 = join (toBytes (SHA_3_224 0b11001)) ==\n  0xffbad5da96bad71789330206dc6768ecaeb1b32dca6b3301489674ab\nproperty u2 = join (toBytes (SHA_3_256 0b11001)) ==\n  0x7b0047cf5a456882363cbf0fb05322cf65f4b7059a46365e830132e3b5d957af\nproperty u3 = join (toBytes (SHA_3_384 0b11001)) ==\n  0x737c9b491885e9bf7428e792741a7bf8dca9653471c3e148473f2c236b6a0a6455eb1dce9f779b4b6b237fef171b1c64\nproperty u4 = join (toBytes (SHA_3_512 0b11001)) ==\n  0xa13e01494114c09800622a70288c432121ce70039d753cadd2e006e4d961cb27544c1481e5814bdceb53be6733d5e099795e5e81918addb058e22a9f24883f37\n\nmsg1600 : [1600]\nmsg1600 = join [ 0b11000101 | _ <- zero : [200] ]\n\nproperty v1 = join (toBytes (SHA_3_224 msg1600)) ==\n  0x9376816aba503f72f96ce7eb65ac095deee3be4bf9bbc2a1cb7e11e0\n\nproperty w1 = join (toBytes (SHA_3_224 (msg1600 # 0b11000))) ==\n  0x22d2f7bb0b173fd8c19686f9173166e3ee62738047d7eadd69efb228\n\n\/\/SHAKE -- Test Vectors\n\/\/Author: Ajay Kumar Eeralla\n\/\/source:https:\/\/github.com\/XKCP\/XKCP\/tree\/master\/tests\/TestVectors\n\nproperty k1 = join (toBytes (take`{512} (SHAKE128 []))) == 0x7f9c2ba4e88f827d616045507605853ed73b8093f6efbc88eb1a6eacfa66ef263cb1eea988004b93103cfb0aeefd2a686e01fa4a58e8a3639ca8a1e3f9ae57e2\n\nproperty k2 = join (toBytes (take`{512} (SHAKE128 0b0))) == 0xe78b86559a9ccdc72288bf7bcf8e11d574543a2922978913a02be149e89d03cae63d2c36e2cf6906791b187d7e371d4f21ebe59dcfc249a510b82255a18250dd\n\nproperty k3 = join (toBytes (take`{512} (SHAKE128 0b11))) == 0xf6b6c4093f0a2ceba61b9f2c2fea2ca238ce9005edcd588c380405070532ddd00cbd3a3a7448017d874c52c9e383fa3db1c184e023181fcc8550f53ac92feca5\n\nproperty k4 = join (toBytes (take`{512} (SHAKE256 []))) == 0x46b9dd2b0ba88d13233b3feb743eeb243fcd52ea62b81b82b50c27646ed5762fd75dc4ddd8c0f200cb05019d67b592f6fc821c49479ab48640292eacb3b7c4be\n\nproperty k5 = join (toBytes (take`{512} (SHAKE256 0b0))) == 0x1e20b13f3bdb730d286913335c092bcec0eb1aff2798c05736faa93bd665807a48ed7652aefd600427e9f797d647b9b355d30410d71b8e275a676545600f1c35\n\nproperty k6 = join (toBytes (take`{512} (SHAKE256 0b11))) == 0x4f86b0eb85f7a9f6dc38b622706948adb2beb6dd6911b5e9d865fd1f9667b5c02a0dbb39c488b040a18ff3885f04ef957c98f3948e6b7959a9b8950ffd6345d5\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Shared.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol specifications that formally define and verify the correctness of the functions in the Shared module for the McEliece KEM scheme. Specifically, specify properties for compute_He to ensure correct matrix multiplication over GF(2), for compute_H to verify the construction of the public key matrix H, and for compute_hash_e and compute_hash_eC to confirm correct hashing behavior using SHAKE256. Include type invariants and expected output properties suitable for automated checking or proving within Cryptol."},{"role":"assistant","content":"```cryptol\nmodule Shared where\n\nimport Types\nimport Keccak\n\ncvt_bit_int b = if(b) then 1 else 0\ncvt_int_bit i = if(i==1) then True else False\n\n\/\/ matrix multiplication\ncompute_He : H_T -> e_T -> C0_T\n\/\/ also [n-k][n]f2_T -> [n]f2_T -> [n-k]f2_T\ncompute_He H e =\n    [ cvt_int_bit (sum (f hi)) | hi <- H ]\n        where f hi = [ (cvt_bit_int hij) * (cvt_bit_int ej)\n            |  ej <- e | hij <- hi]\n\n\/\/ Define H = (I_n-k |T )\n\/\/[n-k][n][2]   = [n-k][n-k][2] :: [n-k][k][2]\ncompute_H : public_key_T -> H_T\ncompute_H T =\n    [ (I i) # T@i | i <- [0..(n-k-1)]]\n    where I i = (update zero i True)\n\ncompute_hash_e : Integer -> e_T -> C1_T\ncompute_hash_e  i e = out where\n    (a: [8]) = fromInteger `{[8]} i\n    (x:[inf]) = SHAKE256 ((fromInteger `{[8]} i) # e)\n    (out: C1_T) = take `{256} x\n\ncompute_hash_eC\n    : Integer -> e_T -> cipher_text_T -> session_key_T\ncompute_hash_eC  i e C = out where\n    (a: [8]) = fromInteger `{[8]} i\n    (x:[inf]) = SHAKE256 (a # e # C.C0 # C.C1)\n    (out: session_key_T) = take `{32} x\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Decapsulation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the 'decapsulation' function in the Decapsulation module. The properties should check that for valid inputs, the decapsulation produces the expected session key, and that the intermediate steps (such as 'decrypt' and 'check_e') behave as specified, including correct handling of failure cases."},{"role":"assistant","content":"```cryptol\nmodule Decapsulation where\n\nimport Types\nimport Shared\n\n\/\/ Hamming weight. Number of ones\nget_weight : n_T  -> Integer\nget_weight e = sum ([cvt_bit_int i | i <- e])\n\ncheck_e : e_T -> public_key_T -> C0_T -> (e_T, Bool)\ncheck_e e public_key C0 =\n    if((get_weight e == glob_t) && (C0 == C0'))\n    then (e, True)\n    else (zero, False)\n    where\n        \/\/ checks that \"C0 = He\"\n        (H: H_T) = compute_H public_key\n        (C0':C0_T) = compute_He H e\n\n\/\/[mt]-> {[n],{[t],[n]}} -> [mt][k] \ndecrypt\n    : C0_T -> private_key_T -> public_key_T -> fn_get_goppa_T\n    -> (e_T, Bool)\ndecrypt C0 private_key public_key get_goppa = (e, dec_pass) where\n    (failure : (e_T, Bool)) = (zero, False)\n    (s : n_T) = private_key.s\n    (gamma : gamma_T) = private_key.g\n    \/\/ step 1 : extend C0 to v\n    (v:n_T) = C0#zero\n    \/\/step2 : find unique codeword in the Goppa code\n    (c:n_T, goppa_pass) = get_goppa gamma\n    (e, dec_pass) =\n        if(~ goppa_pass)\n        then failure\n        else (check_e e public_key C0)             where\n            \/\/step 3 : set e to v plus c\n            (e :e_T) = v+c\n\n\/* Note without get_goppa function can use decrypt_1()\n    but it hase different type spec\n    decrypt_1 : ciphertext_t ->  secretkey_t -> (SYS_N8_t, gf_t)\n    It was written based on the reference spec\n*\/\ndecapsulation\n    : cipher_text_T -> private_key_T -> public_key_T -> fn_get_goppa_T\n    -> session_key_T\ndecapsulation C private_key public_key get_goppa =  K where\n    \/\/step 1 :split ciphertext\n    C0 = C.C0\n    C1 = C.C1\n    s = private_key.s\n    gamma = private_key.g\n    \/\/step 2 : set b to 1\n    b_1 = 1\n    \/\/step 3 : use decoding subroutine\n    (e_1:e_T, dec_pass) = decrypt C0 private_key public_key get_goppa\n    (e_2:e_T, b_2) =\n        if(dec_pass)\n        then (e_1, b_1)\n        else (s, 0) \/\/ case of failure\n    \/\/step 4 : compute C1 for H input encoding\n    (C1': C1_T) = compute_hash_e 2 e_2\n    \/\/step 5 : Compare C1\n    (e_3:e_T, b_3) =\n        if(C1==C1')\n        then (e_2, b_2)\n        else (s, 0)\n    \/\/step 6 : H input encodings\n    (K: session_key_T) = compute_hash_eC b_2 e_3 C\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Encapsulation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the 'encapsulation' function in the Encapsulation module. The properties should ensure that for any valid public key and error vector 'e', the output session key and ciphertext satisfy the expected relationships defined by the encoding subroutine and hash computations. Include checks that the ciphertext components are correctly derived from 'e' and the public key, and that the session key is consistently computed from 'e' and the ciphertext."},{"role":"assistant","content":"```cryptol\nmodule Encapsulation where\n\nimport Types\nimport Shared \n\n\/\/ encoding subroutine\nencoding_subroutine : e_T -> public_key_T -> C0_T\nencoding_subroutine e T = C0 where\n    (H:H_T) = compute_H T\n    (C0:C0_T) = compute_He H e\n\nencapsulation\n    : public_key_T ->  e_T\n    -> (session_key_T, cipher_text_T)\nencapsulation T e =  (K, C) where\n    \/\/ step 1. uniform random vector e (given as input)\n    \/\/ step 2. use encoding subroutine on e and public key T to compute Co\n    (C0 : C0_T) = encoding_subroutine e T\n        (C1: C1_T) = compute_hash_e 2 e\n    (C: cipher_text_T) = {C0 = C0, C1 = C1}\n    (K: session_key_T) = compute_hash_eC 1 e C\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/decrypt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the 'decrypt_1' function in the given module. The specification should capture the relationship between the ciphertext, secret key, and the resulting error vector and check value, including the intermediate computations such as syndrome calculation, Berlekamp-Massey decoding, root finding, and error vector reconstruction. Ensure the specification can be used to verify the correctness of the decrypt_1 implementation against the McEliece KEM decryption algorithm."},{"role":"assistant","content":"```cryptol\nmodule Decrypt where\n\n\nimport Types\nimport Shared\nimport Benes\nimport Decrypt_helpers\nimport GF\nimport Util\n\ndecrypt_1\n    : ciphertext_t ->  secretkey_t\n    -> (SYS_N8_t, gf_t)\ndecrypt_1 c sk = (e, check) where\n    (r : SYS_N8_t) = (take `{194} c)#zero\n    loop_1 g i sk_index =\n        if i < glob_t\n        then loop_1 g' (i+1) (sk_index+2) where\n            (a : gf_t)= load2 sk sk_index\n            (b : gf_t) = a && cvt_16 GFMASK\n            g'= update g i b\n        else g\n    (g_0 : SYS_T_plus1) = zero\n    (g_1 : SYS_T_plus1) = loop_1 g_0 0 0\n    (L : SYS_N_t) = support_gen sk\n    (s : SYS_T_double_t) = synd g_1 L r\n    (locator : SYS_T_plus1) = bm s\n    (images : SYS_N_t) = root locator L\n    loop_2 : [32] -> SYS_N8_t -> gf_t -> (SYS_N8_t, gf_t)\n    loop_2 i e w =\n        if (i<glob_n)\n        then loop_2 (i+1) e' w' where\n            (t : gf_t) = (gf_iszero (images @i)) && (1:[16])\n            jx = i\/8\n            val = (e@jx) || t << (i%8)\n            (e' :SYS_N8_t) = update e jx val\n            (w' : gf_t) = w+t\n        else (e, w)\n    (e :SYS_N8_t, w : gf_t) = loop_2 0 zero 0\n    (s_cmp : SYS_T_double_t) = synd g_1 L e\n    loop_3 i check =\n        if (i<glob_t*2)\n        then  loop_3 (i+1) check' where\n            check' = check || ((s@i) ^ (s_cmp@i))\n        else check\n    (check_0 : gf_t) = w ^ glob_t\n    (check_1 : gf_t) = loop_3 0 check_0\n    (check_2 : gf_t) = (check_1 -1)>> 15\n    (check : gf_t) = check_2 ^ 1\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Gauss.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the Gaussian elimination implementation in the Gauss module. The properties should check that the output matrix B_2 is the correct result of applying Gaussian elimination to the input matrix a, ensuring that the transformation preserves linear equivalence and that the determinant tracking is consistent. Include properties that validate intermediate steps such as row operations and matrix updates."},{"role":"assistant","content":"```cryptol\nmodule Gauss where\n\nimport Types\nimport Keccak\nimport Shared\n\ntype M_len1 = n-k\nglob_M_len1 = glob_n-glob_k\ntype b_len2 = k\nglob_b_len2 = glob_k\ntype a_in_T = [M_len1][M_len1]\ntype b_in_T = [M_len1][b_len2]\n\n\/\/ ----------------------- Gaussian Elimination -----------------------\n\/\/ reference https:\/\/rosettacode.org\/wiki\/Gaussian_elimination\n\/\/index Matrix a\nindex M i j = cvt_bit_int ((M@i)@j)\n\nupdate_M M i j v =\n    update M i val' where\n    N =  index M i j\n    val = cvt_int_bit v\n    val' = update N j val\n\nloop_3\n    : a_in_T -> b_in_T -> [32]\n    -> (a_in_T, b_in_T)\nloop_3 a_in b_in i =\n    inner (i+1) a_in b_in where\n    inner j A B =\n        if(j < glob_M_len1)\n        then\n            (A_1, B_1) where\n            tmp = (index A j i)\/ (index A i i)\n            i' = i+1\n                        \/* one way we want to write it\n            A_1 = [(index A j k)- (tmp *(index A i k))\n                    | j <- [i'..(M_len1-1)]\n                    | k <- [i'..(M_len1-1)]]\n            B_1 = [(index B j k)- (tmp *(index B i k))\n                    | j <- [i'..(M_len1-1)]\n                    | k <- [i'..(b_len2-1)]]\n            *\/\n            loop_j1 k k_limit M  =\n                if (k<k_limit)\n                then loop_j2 k' k_limit M' where\n                    k' = k+1\n                    val = (index M j k) - ((index M i k) * tmp)\n                    M' = update_M M j k val\n                else M\n            loop_j2 k k_limit M  =\n                if (k<k_limit)\n                then loop_j2 k' k_limit M' where\n                    k' = k+1\n                    val = (index M j k) - ((index M i k) * tmp)\n                    M' = update_M M j k val\n                else M\n            A_1 = loop_j1 (i+1) glob_M_len1 A\n            B_1 = B         else (A ,B)\n\nbig_loop_1\n    : [32] -> a_in_T -> b_in_T -> [32]\n     -> (a_in_T, b_in_T, [32])\nbig_loop_1 i A B det =\n    if (i< (glob_M_len1-1))\n    then big_loop_1 (i+1) A_2 B_2 det_1 where\n        inner_1 : [32] -> [32] -> [32]\n        inner_1 j k =\n            if(j<glob_M_len1)\n            then\n                if((abs_index A j i) > (abs_index A k i))\n                then j\n                else inner_1 (j+1) k\n            else i         inner_2 k = (A_1, B_1, det_1) where\n                \/\/swap values a[i]=a[k], a[k]=a[i]\n                v1 = index A i k\n                v2 = index A k i\n                A_1 = update_M (update_M A i k v2) k i v1\n                u1 = index B i k\n                u2 = index B k i\n                B_1 = update_M (update_M B i k u2) k i u1\n                det_1 = -1 * det\n                abs_index M i j  = if (val<0)then -1* val else val\n            where val = index M i j\n        k = inner_1 (i+1) i\n        (A_1, B_1, det_1) =\n            if (k!=i) then inner_2 det else (A, B, det)\n        (A_2, B_2) = loop_3 A_1 B_1 i\n    else (A, B, det)\n\nbig_loop_2\n    : [32] -> a_in_T -> b_in_T -> [32]\n    -> b_in_T\nbig_loop_2 i A B_in det =\n    if(i>=0)\n    then big_loop_2 (i+1) A B_3 det_1 where\n        loop_j : [32] -> b_in_T -> b_in_T\n        loop_j j B =\n            if (j<glob_M_len1)\n            then loop_j j' B_1 where\n                tmp = index A i j\n                loop_k k B =\n                    if (k<glob_b_len2)\n                    then loop_k k' B_1 where\n                        k' = k+1\n                        val = (index B i k) - (tmp* (index B j k))\n                        B_1 = update_M  B i k val\n                    else B\n                B_1 = loop_k 0 B\n                j' = j+1\n            else B\n        B_1 = loop_j (i+1) B_in\n        val = index A i i\n        t = 1\/val\n        det_1 = det * val\n        loop_j2 j B_2 =\n            if (j<glob_b_len2)\n            then loop_j2 j' B_3 where\n                j' = j+1\n                val = ((index B_2 i j) * t)\n                B_3 = update_M B_2 i j val\n            else B_2\n        B_3 = loop_j2 0 B_1\n    else B_in\n\n\/\/guassian : H_tilde_T -> (Bool, public_key_T)\n\/\/ H_tilde_T    =   [t][n][m]f2_T\n\/\/ public_key_T = [n-k][k]f2_T\nguassian : a_in_T ->  (Bool, b_in_T)\nguassian a  = (True, B_2) where\n    det = 1\n    (b : b_in_T) = zero\n    (A_1, B_1, det_1) = big_loop_1 0 a b det\n    (B_2) = (big_loop_2 0 A_1 B_1 det_1)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Key_Generation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the key_generation function in the Key_Generation module. The specification should capture the relationship between inputs (seed, polynomial sequence, alpha sequence, counter limit, Gaussian elimination function) and outputs (public and private keys), including the conditions under which key generation succeeds or fails. Include properties that verify the correctness of compute_H_tilde and mk_gamma as used within key_generation."},{"role":"assistant","content":"```cryptol\nmodule Key_Generation where\n\nimport Types\nimport Shared\n\n\n\/\/h_ij  = a_j ^(i-1) \/ g(alpha_j)\ncompute_H_tilde : poly_T -> alphas_T -> [t][n][m]Bit\ncompute_H_tilde g alphas =\n    [[ f i j | j <- [1..n]] | i <- [1..t]]\n            where f i j = aj \/ (g @ aj)\n                    where aj = alphas@j\n\nmk_gamma \n\t: [32]->[32] ->[inf]poly_T -> [inf]alphas_T -> fn_gauss_T\n\t-> (Bool, gamma_T, public_key_T)\nmk_gamma counter counter_limit gs alphas fn_gauss =\n\tif(counter<counter_limit) then \n\t\tif(flag) \n\t\t\tthen (True, current_gamma, public_key)\n\t\t\telse mk_gamma (counter+1) counter_limit gs alphas fn_gauss\n\t\twhere\n\t\t\tg = gs@counter\n\t\t\talpha = alphas@counter\n            \/\/ current gamma selection if successful \n\t\t\tcurrent_gamma = { p = g, a = alpha }\n            \t\t\t(H_tilde: H_tilde_T) = compute_H_tilde g alpha\n            \t\t\t(flag, public_key) = fn_gauss H_tilde\n\telse \n\t\t(False, zero, zero)\n\n\n\/\/ g: uniform random monic irreducible polynomial \n\/\/ alpha :uniform random sequence\n\/\/ counter_limit : how many times should to go back to step 1 if H can be transformed to systematic form\n\/\/ fn_gauss_T : function to apply Gaussian elimination\n\/\/            see also Gauss.cry for example\n\/\/ failed state in this case is zero\nkey_generation\n\t : [n]Bit -> [inf]poly_T -> [inf]alphas_T -> [32] -> fn_gauss_T\n\t-> (public_key_T, private_key_T)\nkey_generation s gs alphas counter_limit fn_gauss = (public_key, private_key) where\n    (rtn, gamma: gamma_T, public_key: public_key_T) = mk_gamma 0 counter_limit gs alphas fn_gauss\n    (private_key: private_key_T) = if rtn then  {s=s, g=gamma} else zero\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Types.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and consistency of the type definitions and constants in the McEliece KEM Types module. Include checks that the derived types (such as k, mt) correctly compute their values from the global constants, and that the sizes of composite types (e.g., public_key_T, private_key_T, cipher_text_T) align with their expected dimensions. Also, specify properties ensuring that the conversion functions (cvt_16, cvt_32, cvt_64) behave as intended for representative inputs."},{"role":"assistant","content":"```cryptol\nmodule Types where\n\n\nglob_t = 119\ntype t = 119\nglob_n = 6960\ntype n = 6960\nglob_m = 13\ntype m = 13\ntype d = 256\ntype mt = m*t \/\/1547\n\/\/--------------------------------------------\n\/\/ Structure Defined by spec\n\/\/--------------------------------------------\nglob_k = (glob_n-glob_m*glob_t) type k = (n-m*t) \/\/ 5413\n\/\/ in order of general algorithm spec\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [k]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [mt]f2_T  \/\/ also n-k\ntype public_key_T = [mt][k]f2_T\ntype H_T = [n-k][n]f2_T \ntype H_tilde_T = [t][n][m]f2_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                \/\/ [13]Bit\n    , a : alphas_T              \/\/ [6960][13]Bit  \/\/[n][m]Bit\n    }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                   \/\/ [870][8]Bit\n    , g : gamma_T\n    }\n\ntype C0_T = mt_T \/\/ also n-k \/\/1547\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\n\n\/\/ a bit string of length and Hamming weight T\ntype weighted_T = n_T\ntype e_T = n_T\n\ntype session_key_T = [32]\n\ntype fn_get_goppa_T = gamma_T -> (n_T, Bool)\ntype fn_gauss_T = H_tilde_T -> (Bool, public_key_T)\n\n\n\/\/--------------------------------------------\n\/\/ Structure Defined by reference implementation\n\/\/--------------------------------------------\n\/\/ Base Types\ntype base_16t = [16]\ntype base_32t = [32]\ntype base_64t = [64]\ntype uint16t = [16]\ntype uint64t = [64]\ntype uint32t = [32]\ntype gf_t = base_t\n\/\/conversions\ncvt_16 e = fromInteger `{[16]} (toInteger e)\ncvt_32 e = fromInteger `{[32]} (toInteger e)\ncvt_64 e = fromInteger `{[64]} (toInteger e)\n\n\n\/\/specific to low level implementation of goppa code\nGFBITS =  13\ntype GFBITS_t =  13\ntype base_t = base_16t\ntype secretkey_t = [13908] base_t\ntype ciphertext_t = [226] base_t  \/\/ crypto_kem_CIPHERTEXTBYTES\n\ntype SYS_N_t = [n]base_t\ntype SYS_N8_t = [n\/8] base_t\ntype SYS_T_double_t = [t*2]base_t\ntype SYS_T_plus1 = [t+1]base_t\nSYS_T_double =  glob_t*2 \/\/ support_gen in benes\nGFMASK  =  cvt_64 (((1:[32]) << GFBITS) - 1)\ntype j_size_t =  1024 \/\/((1:[32]) << GFBITS)\/8\ntype La_t = [32]\ntype Lb_t = [j_size_t][32]\ntype Lc_t = [GFBITS_t][j_size_t][32]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/util.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the functions defined in the Util module, including load2, bitrev, store8, load8, and transpose_64x64. The specifications should capture the intended behavior of bit manipulations, data loading, and transformations, ensuring that these functions operate correctly on their inputs according to the McEliece KEM high-level design."},{"role":"assistant","content":"```cryptol\nmodule Util where\n\nimport Types\n\nload2 : secretkey_t -> [32] -> gf_t\nload2 src sk_index = (a && (cvt_16 GFMASK)) where\n    (a: base_16t) = src@(1+sk_index)\n    b = a << 8\n    c = b || src@(0+sk_index)\n\n\n\nbitrev : [32] -> ([32],  [32])\nbitrev a = (cvt_32 a_4, cvt_32(a_4>>3)) where\n    a_0 = cvt_16 a\n    a_1 = ((a_0 && 0x00FF) << 8) || ((a_0 && 0xFF00) >> 8)\n    a_2 = ((a_1 && 0x0F0F) << 4) || ((a_1 && 0xF0F0) >> 4)\n    a_3 = ((a_2 && 0x3333) << 2) || ((a_2 && 0xCCCC) >> 2)\n    a_4 = ((a_3 && 0x5555) << 1) || ((a_3 && 0xAAAA) >> 1)\n\n\nstore8 out in = out\nload8 in = zero\ntranspose_64x64 in = zero\n```"}]}
{"filename":"aws-lc-verification\/SAW\/spec\/AES\/AES-GCM-implementation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the AES-GCM implementation in the provided module. Specifically, create properties that check the equivalence of the GCM polyval multiplication functions (gcm_polyval_mul_pmult3 and gcm_polyval_mul_pmult4), verify the correctness of the reduction function gcm_polyval_red_pmult, and ensure that the aesni_gcm_cipher function correctly updates the AES_GCM_Ctx state according to the AES-GCM specification. Include properties that validate the behavior of the gcm_ghash_avx and gcm_ghash_avx_8 functions for various input sizes."},{"role":"assistant","content":"```cryptol\nmodule AES_GCM_Implementation where\n\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM\nimport AES_GCM\n\n\n\/*\n * GCM polyval mul\/red implementations\n *\/\ngcm_polyval_mul_pmult3 : {n} (fin n) => [2 * (1 + n)] -> [2 * (1 + n)] -> [4 * (1 + n)]\ngcm_polyval_mul_pmult3 X Y = r3 # (r2 ^ r1 ^ r3 ^ m1) # (r1 ^ r0 ^ r2 ^ m0) # r0\n  where\n    [X_hi, X_lo] = split X\n    [Y_hi, Y_lo] = split Y\n    [r1, r0] = split ((0 : [1]) # (pmult X_lo Y_lo))\n    [r3, r2] = split ((0 : [1]) # (pmult X_hi Y_hi))\n    [m1, m0] = split ((0 : [1]) # (pmult (X_lo ^ X_hi) (Y_hi ^ Y_lo)))\n\ngcm_polyval_mul_pmult4 : {n} (fin n) => [2 * (1 + n)] -> [2 * (1 + n)] -> [4 * (1 + n)]\ngcm_polyval_mul_pmult4 X Y = (hi ^ (0 : [1 + n]) # (hi_bits (m0 ^ m1))) # (lo ^ ((lo_bits (m0 ^ m1)) # (0 : [1 + n])))\n  where\n    [X_hi, X_lo] = split X\n    [Y_hi, Y_lo] = split Y\n    lo = (0 : [1]) # (pmult X_lo Y_lo)\n    hi = (0 : [1]) # (pmult X_hi Y_hi)\n    m0 = (0 : [1]) # (pmult X_lo Y_hi)\n    m1 = (0 : [1]) # (pmult X_hi Y_lo)\n\ngcm_polyval_red_pmult : [256] -> [128]\ngcm_polyval_red_pmult X = (d1 ^ x3) # (d0 ^ x2)\n  where\n    [x3, x2, x1, x0] = split X\n    [a1, a0] = split ((0 : [1]) # (pmult <| x^^63 + x^^62 + x^^57 |> x0))\n    b1 = x0 ^ a1\n    b0 = x1 ^ a0\n    [c1, c0] = split ((0 : [1]) # (pmult <| x^^63 + x^^62 + x^^57 |> b0))\n    d1 = b0 ^ c1\n    d0 = b1 ^ c0\n\ngcm_polyval_avx : [128] -> [128] -> [128]\ngcm_polyval_avx H X = x30\n  where\n    [H_hi, H_lo] = split H\n    [X_hi, X_lo] = split X\n    x17 = (0 : [1]) # (pmult H_lo X_lo)\n    x18 = ((0 : [1]) # (pmult H_hi X_hi)) ^ x17\n    x19 = x18 ^ ((0 : [1]) # (pmult (H_lo ^ H_hi) (X_lo ^ X_hi)))\n    x20 = (lo_bits x19) # (0 : [64])\n    x21 = x17 ^ x20\n    x22 = hi_bits x21\n    x23 = lo_bits x21\n    x25 = (take`{8} ((x23 << 57) ^ (x23 << 62) ^ (x23 << 63))) # (0 : [120])\n    x26 = x21 ^ x25\n    x27 = (hi_bits x26) >> 1\n    x28 = (lo_bits x26) >> 1\n    x29 = (x26 ^ (x27 # x28)) ^ ((x27 >> 5) # (x28 >> 5))\n    x30 = ((((x18 ^ x20) ^ ((0 : [64]) # (hi_bits x19))) ^ x25) ^ ((0 : [64]) # (take`{8} ((x22 << 57) ^ (x22 << 62) ^ (x22 << 63))) # (0 : [56]))) ^ (((hi_bits x29) >> 1) # ((lo_bits x29) >> 1))\n\n\n\/*\n * aesni_gcm_cipher Cryptol implementation\n *\/\naesni_gcm_cipher : {n} (fin n) => [32] -> AES_GCM_Ctx -> [(1 + n) * 6 * 16][8] -> [16][8]\naesni_gcm_cipher enc ctx in = ctx''.Xi\n  where\n    enc_blks = if enc ! 0\n      then split (aesni_gcm_ctr32_encrypt_block ctx in)\n      else split (map join (split in))\n    ctx' = aesni_gcm_cipher_block6 enc False ctx (enc_blks @ 0)\n    ctx'' = foldl (aesni_gcm_cipher_block6 enc (enc ! 0)) ctx' (drop`{1} enc_blks)\n\naesni_gcm_ctr32_encrypt_block : {n} (fin n) => AES_GCM_Ctx -> [n * 16][8] -> [n][16 * 8]\naesni_gcm_ctr32_encrypt_block ctx in = out\n  where\n    ctr = drop ((ctx.len \/ 16) + 1)\n    in' = split in\n    out = [ swap8 ((join (reverse blk)) ^ (join (reverse (EKi ctx (ctr + i))))) | blk <- in' | i <- [0 ...] ]\n\naesni_gcm_cipher_block6 : [32] -> Bit -> AES_GCM_Ctx -> [6][128] -> AES_GCM_Ctx\naesni_gcm_cipher_block6 enc karatsuba ctx blks = ctx'\n  where\n    gcm_polyval_mul_fun = if karatsuba\n      then gcm_polyval_mul_pmult3\n      else gcm_polyval_mul_pmult4\n    Htable = get_Htable ctx\n    Xi = join ctx.Xi\n    Xi_0 = gcm_polyval_mul_fun (Htable @ 0) (blks @ 5)\n    Xi_1 = gcm_polyval_mul_fun (Htable @ 1) (blks @ 4)\n    Xi_2 = gcm_polyval_mul_fun (Htable @ 3) (blks @ 3)\n    Xi_3 = gcm_polyval_mul_fun (Htable @ 4) (blks @ 2)\n    Xi_4 = gcm_polyval_mul_fun (Htable @ 6) (blks @ 1)\n    Xi_5 = gcm_polyval_mul_fun (Htable @ 7) (Xi ^ (blks @ 0))\n    Xi_6 = gcm_polyval_red_pmult (Xi_0 ^ Xi_1 ^ Xi_2 ^ Xi_3 ^ Xi_4 ^ Xi_5)\n    Xi' = split Xi_6\n    ctx' =\n      { key = ctx.key\n      , iv = ctx.iv\n      , Xi = Xi'\n      , len = ctx.len + 6 * 16\n      }\n\ngcm_ghash_avx : {n, m} (fin n, 1 <= m, m <= 8) => [128] -> [16][8] -> [(n * 8 + m) * 16][8] -> [16][8]\ngcm_ghash_avx H Xi in = Xi''\n  where\n    bulk # tl = in\n    Xi' = foldl (gcm_ghash_avx_8`{8} H) Xi (split`{n} bulk)\n    Xi'' = gcm_ghash_avx_8`{m} H Xi' tl\n\ngcm_ghash_avx_8 : {n} (1 <= n, n <= 8) => [128] -> [16][8] -> [n * 16][8] -> [16][8]\ngcm_ghash_avx_8 H Xi in = Xi''\n  where\n    [H0, H1, _, H2, H3, _, H4, H5, _, H6, H7, _] = gcm_init_Htable H\n    Htable = [H0, H1, H2, H3, H4, H5, H6, H7]\n    Xi' = join Xi\n    blks = map join (split in)\n    Xi_0 = gcm_polyval_mul_pmult3 (Htable @ (`n - 1)) (Xi' ^ (blks @ 0))\n    Xi_1 = gcm_polyval_mul_pmult3 (Htable @ (`n - 2)) (blks @ 1)\n    Xi_2 = gcm_polyval_mul_pmult3 (Htable @ (`n - 3)) (blks @ 2)\n    Xi_3 = gcm_polyval_mul_pmult3 (Htable @ (`n - 4)) (blks @ 3)\n    Xi_4 = gcm_polyval_mul_pmult3 (Htable @ (`n - 5)) (blks @ 4)\n    Xi_5 = gcm_polyval_mul_pmult3 (Htable @ (`n - 6)) (blks @ 5)\n    Xi_6 = gcm_polyval_mul_pmult3 (Htable @ (`n - 7)) (blks @ 6)\n    Xi_7 = gcm_polyval_mul_pmult3 (Htable @ (`n - 8)) (blks @ 7)\n    T1 = if `n == 8\n      then Xi_7 ^ Xi_6 ^ Xi_5 ^ Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n      else if `n == 7\n        then Xi_6 ^ Xi_5 ^ Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n        else if `n == 6\n          then Xi_5 ^ Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n          else if `n == 5\n            then Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n            else if `n == 4\n              then Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n              else if `n == 3\n                then Xi_2 ^ Xi_1 ^ Xi_0\n                else if `n == 2\n                  then Xi_1 ^ Xi_0\n                  else Xi_0\n    Xi_n = gcm_polyval_red_pmult T1\n    Xi'' = split Xi_n\n```"}]}
{"filename":"aws-lc-verification\/SAW\/spec\/AES\/X86.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the AES X86 module functions, including aesenc, aesenclast, aesdec, aesdeclast, and aeskeygenassist. The properties should ensure that these functions correctly implement the AES encryption and decryption rounds and key generation steps according to the AES standard, using the provided state and message transformations."},{"role":"assistant","content":"```cryptol\nmodule X86 where\n\nimport Primitive::Symmetric::Cipher::Block::AES\n\n\nclmul : [64] -> [64] -> [128]\nclmul x y = 0b0 # pmult x y\n\naesenc : [128] -> [128] -> [128]\naesenc pt key =\n  stateToMsg_x86 (AESRound (msgToState_x86 key, msgToState_x86 pt))\n\naesenclast : [128] -> [128] -> [128]\naesenclast pt key =\n  stateToMsg_x86 (AESFinalRound (msgToState_x86 key, msgToState_x86 pt))\n\naesdec : [128] -> [128] -> [128]\naesdec pt key =\n  stateToMsg_x86 (AESInvRound (msgToState_x86 key, msgToState_x86 pt))\n\naesdeclast : [128] -> [128] -> [128]\naesdeclast pt key =\n  stateToMsg_x86 (AESFinalInvRound (msgToState_x86 key, msgToState_x86 pt))\n\naeskeygenassist : [128] -> [8] -> [128]\naeskeygenassist src imm = join\n  ( (RotWord_x86 (SubWord x3) ^ rcon)\n  # SubWord x3\n  # (RotWord_x86 (SubWord x1) ^ rcon)\n  # SubWord x1\n  )\n  where\n    [x3, x2, x1, x0] = [split x | x <- split src]\n    rcon = [0, 0, 0, imm]\n\n\nRotWord_x86 : [4]GF28 -> [4]GF28\nRotWord_x86 x = reverse (RotWord (reverse x))\n\nmsgToState_x86 : [128] -> State\nmsgToState_x86 msg = transpose (split (reverse (split msg)))\n\nstateToMsg_x86 : State -> [128]\nstateToMsg_x86 st = join (reverse (join (transpose st)))\n```"}]}
{"filename":"aws-lc-verification\/SAW\/spec\/AES\/AES-GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the AES-GCM implementation in the provided AES_GCM module. Include properties that check the correctness of key schedule transformations (aes_key_to_schedule, aes_key_from_schedule, inv_aes_key_from_schedule), the correctness of AES hardware encryption and decryption functions (aes_hw_decrypt, aes_hw_ctr32_encrypt_blocks), and the correctness of GCM-specific functions such as gcm_init, gcm_init_Htable, gcm_gmult, gcm_ghash, and gcm_ghash_block. Ensure the properties capture expected algebraic relationships, reversibility, and consistency with the AES-GCM specification."},{"role":"assistant","content":"```cryptol\nmodule AES_GCM where\n\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM\nimport X86\n\n\nswap8 : {parts, a} (fin parts) => [parts * 8]a -> [parts * 8]a\nswap8 x = join`{each=8} (reverse (split`{each=8} x))\n\nswap128 : {parts, a} (fin parts) => [parts * 128]a -> [parts * 128]a\nswap128 x = join`{each=128} (reverse (split`{each=128} x))\n\nhi_bits : {n} (fin n) => [2 * n] -> [n]\nhi_bits = take\n\nlo_bits : {n} (fin n) => [2 * n] -> [n]\nlo_bits = drop\n\n\naes_key_to_schedule : [Nr + 1][128] -> KeySchedule\naes_key_to_schedule key = (key' @ 0, key' @@ [1 .. (Nr - 1)], key' @ `Nr)\n  where\n    key' = map msgToState_x86 key\n\naes_key_from_schedule : KeySchedule -> [4 * (Nr - 1)][32]\naes_key_from_schedule (init_key, middle_keys, final_key) = join (map reverse (map split (key' @@ [2 .. Nr])))\n  where\n    key' = map stateToMsg_x86 ([init_key] # middle_keys # [final_key])\n\ninv_aes_key_from_schedule : KeySchedule -> [4 * (Nr - 1)][32]\ninv_aes_key_from_schedule (init_key, middle_keys, final_key) = join (map reverse (map split (reverse (key' @@ [2 .. Nr]))))\n  where\n    key' = map stateToMsg_x86 ([init_key] # middle_keys # [final_key])\n\naes_hw_decrypt : [16][8] -> [32][8] -> [16][8]\naes_hw_decrypt in key = split (aesDecrypt ((join in), (join key)))\n\naes_hw_ctr32_encrypt_blocks : {n} (fin n) => [16*n][8] -> [32][8] -> [16][8] -> [16*n][8]\naes_hw_ctr32_encrypt_blocks in key (iv # ctr) =\n  join [ blk ^ (aes_hw_encrypt (iv # (split ((join ctr) + i))) key) | blk <- split in | i <- [(0 : [32]) ...]]\n\ngcm_init : [2][64] -> [12][128]\ngcm_init Xi = gcm_init_Htable (gcm_init_H (join Xi))\n\ngcm_init_Htable : [128] -> [12][128]\ngcm_init_Htable h0 = [h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11]\n  where\n    h1 = gcm_polyval h0 h0\n    h2 = ((hi_bits h1) ^ (lo_bits h1)) # ((hi_bits h0) ^ (lo_bits h0))\n    h3 = gcm_polyval h0 h1\n    h4 = gcm_polyval h0 h3\n    h5 = ((hi_bits h4) ^ (lo_bits h4)) # ((hi_bits h3) ^ (lo_bits h3))\n    h6 = gcm_polyval h0 h4\n    h7 = gcm_polyval h0 h6\n    h8 = ((hi_bits h7) ^ (lo_bits h7)) # ((hi_bits h6) ^ (lo_bits h6))\n    h9 = gcm_polyval h0 h7\n    h10 = gcm_polyval h0 h9\n    h11 = ((hi_bits h9) ^ (lo_bits h9)) # ((hi_bits h10) ^ (lo_bits h10))\n\ngcm_gmult : [128] -> [16][8] -> [16][8]\ngcm_gmult H Xi = split (gcm_polyval H (join Xi))\n\ngcm_ghash : {n} (fin n) => [128] -> [16][8] -> [n * 16][8] -> [16][8]\ngcm_ghash H Xi inp = foldl (gcm_ghash_block H) Xi (split inp)\n\ngcm_ghash_block : [128] -> [16][8] -> [16][8] -> [16][8]\ngcm_ghash_block H Xi inp = split (gcm_polyval H ((join Xi) ^ (join inp)))\n\n\nget_Htable : AES_GCM_Ctx -> [12][128]\nget_Htable ctx = gcm_init (get_H ctx)\n\nget_i : AES_GCM_Ctx -> [32]\nget_i ctx = drop ((ctx.len + 15) \/ 16)\n\nget_Yi : AES_GCM_Ctx -> [16][8]\nget_Yi ctx = ctx.iv # (split ((get_i ctx) + 2))\n\nget_EKi : AES_GCM_Ctx -> [16][8]\nget_EKi ctx = EKi ctx (get_i ctx)\n\nget_EK0 : AES_GCM_Ctx -> [16][8]\nget_EK0 ctx = EKi ctx 0\n```"}]}
{"filename":"BLST-Verification\/tests\/Fp12_tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the Fp12 field arithmetic implementations in the given file. Specifically, specify properties that prove the equivalence between the alternative and primary Fp12 representations for addition and multiplication, verify that the cyclotomic squaring function behaves correctly on elements in the cyclotomic subgroup, and confirm that the optimized implementation matches the specification version. Include properties that test round-trip conversions between Fp_12 and Fp_12_alt, and properties that validate the cyclotomic subgroup membership and exponentiation behavior as defined in the code."},{"role":"assistant","content":"```cryptol\n\/\/ Tests of the definitions in implementation::Fp12\n\nimport implementation::Fp12\nimport Parameters (Fp_12, t_Fp_12, p, u, u_plus_1, v, w)\nimport FieldExtras\nimport Frobenius (fp12_conjugate)\n\n\/\/ relationship between Fp_12 and Fp_12_alt (all can be proved)\n\nproperty fp12_alt_round_trip_1 x =\n    Fp_12_alt_to_Fp_12 (Fp_12_to_Fp_12_alt x) == x\n\nproperty fp12_alt_round_trip_2 x =\n    Fp_12_to_Fp_12_alt (Fp_12_alt_to_Fp_12 x) == x\n\nproperty fp12_alt_add x y =\n    Fp_12_alt_to_Fp_12 (Fp_12_alt.add (x, y)) == Fp_12.add (Fp_12_alt_to_Fp_12 x, Fp_12_alt_to_Fp_12 y)\n\nproperty fp12_alt_mul_w x =\n    Fp_12_alt_to_Fp_12 (Fp_12_alt.mul (Fp_12_to_Fp_12_alt w, x)) == Fp_12.mul (w, Fp_12_alt_to_Fp_12 x)\n\n\/\/ cyclotomic squaring.  We need values in the cyclotomic subgroup, which are the values x in Fp_12\n\/\/ satisfying x^(p^4-p^2+1) == 1.  These can be found by raising ANY nonzero element to the power\n\/\/   (p^8 + p^6 - p^2 - 1) = (p^6 - 1)(p^2 + 1) = (p^3 + 1)(p^3 - 1)(p^2 + 1),\n\/\/ since all nonzero elements satisfy x^(p^12-1) = 1.\n\n\/*\n\/\/ slow...\nto_cyclotomic x = F_expt Fp_12 (F_expt Fp_12 (F_expt Fp_12 x e1) e2) e3 where\n    e1 = `(p*p+1):[768]\n    e2 = `(p*p*p + 1):[3*384]\n    e3 = e2 - 2\n*\/\n\n\/\/ to_cyclotomic: t_Fp_12 -> t_Fp_12\nto_cyclotomic_fp12 x = k_expt`{4} Fp_12 x1 e where\n    x1 = Fp_12.div (fp12_conjugate x, x) \/\/ = x^(p^6 - 1)\n    e = `(p*p+1):[2*382] \/\/ p^2 + 1\n\nis_cyclotomic_fp12 x = (Fp_12.mul(x4, x) == x2) where \/\/ x^(p^4+1) == x^(p_2), so x^(p^4-p^2+1) == 1\n    x2 = fp12_frobenius2 x \/\/ x^(p^2)\n    x4 = fp12_frobenius2 x2 \/\/ x^(p^4)\n\ncyclotomic_sqr_fp12_ok x =\n    cyclotomic_sqr_fp12 x' == Fp_12.sq x' where x' = to_cyclotomic_fp12 x\n\ntest_a = [[[1,2],[3,4],[5,6]],[[7,8],[9,10],[11,12]]]: t_Fp_12\ntest_b = [[[0,9],[1,8],[2,7]],[[3,6],[4,5],[5,4]]]: t_Fp_12\n\nproperty cyclotomic_sqr_fp12_test_a = cyclotomic_sqr_fp12_ok test_a\nproperty cyclotomic_sqr_fp12_test_b = cyclotomic_sqr_fp12_ok test_b\n\n\/\/ _imp matches the spec version\n\nproperty cyclotomic_sqr_fp12_imp_ok x =\n    cyclotomic_sqr_fp12 x == cyclotomic_sqr_fp12_imp x\n```"}]}
{"filename":"BLST-Verification\/tests\/ParameterTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and consistency of the elliptic curve parameters and field element conversions defined in the given code. Specifically, specify properties that check the round-trip conversion between field elements and their octet representations, and verify that the base points lie on their respective curves and have the correct order."},{"role":"assistant","content":"```cryptol\nimport Parameters\nimport ShortWeierstrassCurve\n\n\/\/ representation of field elements:\n\nproperty Fp_to_octets_to_Fp x =\n  Fp.is_val x ==> octets_to_Fp (Fp_to_octets x) == x\n\nproperty Fp_12_to_octets_to_Fp_12 x =\n  Fp_12.is_val x ==> octets_to_Fp_12 (Fp_12_to_octets x) == x\n\n\/\/ Sanity checks on the curve parameters\n\nproperty BP_on_E =\n    is_point_affine E BP \/\/ BP is on curve E\n\nproperty BP'_on_E' =\n    is_point_affine E' BP' \/\/ BP' is on curve E'\n\nproperty BP_order =\n    is_point_O E (mult E r BP) \/\/ r*BP = O\n\nproperty BP'_order =\n    is_point_O E' (mult E' r BP') \/\/ r*BP' = O\n```"}]}
{"filename":"BLST-Verification\/tests\/G2SubGroupCheckTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the function `psi` correctly maps points in the G2 subgroup of the elliptic curve `E'` to other points on the curve, preserving subgroup membership and satisfying the specified order and multiplication relations. Include properties that check the affine nature of points after applying `psi`, the order of `psi` as 12, and that `psi` acts as multiplication by `p` modulo the subgroup order `r`. Ensure the properties cover base points and their multiples."},{"role":"assistant","content":"```cryptol\nimport Parameters (p, Fp_2, t_Fp_2, E', BP', r)\nimport Frobenius\nimport FieldExtras\nimport ShortWeierstrassCurve\nimport G2SubGroupCheck\n\nproperty test_psi_1 = is_point_affine E' (psi BP') \/\/ psi takes BP' to a point on the curve\n\/\/ and multiples of BP':\ntest_psi_2 m = is_point_affine E' (psi (mult E' m BP')) \/\/ and multiples of BP'\nproperty test_psi_2_1 = test_psi_2 0x6db7\nproperty test_psi_2_2 = test_psi_2 0xdefc\n\nproperty in_G2_1 = is_in_G2' BP'\n\nin_G2_2 m = is_in_G2' (mult E' m BP')\nproperty in_G2_2_1 = in_G2_2 0xa3e0\nproperty in_G2_2_2 = in_G2_2 0xd58f\n\n\/\/ psi has order 12, apparently\n\nproperty test_psi_order =\n  same_point_affine E' (images@12) BP' where\n  images = [BP'] # [psi P | P <- images] \/\/ so images @ i == psi^i BP'\n\ntest_psi_order_mult m =\n  same_point_affine E' (images@12) Q where\n  images = [Q] # [psi P | P <- images] \/\/ so images @ i == psi^i BP'\n  Q = mult E' m BP'\nproperty test_psi_order_mult_1 = test_psi_order_mult 0x7ecf\nproperty test_psi_order_mult_2 = test_psi_order_mult 0xe233\n\n\/\/ psi is claimed to map elements of G2 to a multiple, by p.  So\n\nproperty test_psi_is_mult = same_point_affine E' (psi BP') (mult E' (`p:[384]) BP')\n\n\/\/ or as the order of G2 is r, we can use exponent (p mod r)\n\ntest_psi_is_mult_reduced m = same_point_affine E' (psi P) (mult E' e  P)\n  where e = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfe2dfefffeffff0001\n        P = mult E' m BP'\nproperty test_psi_is_mult_reduced_1 = test_psi_is_mult_reduced 0xdefc\nproperty test_psi_is_mult_reduced_2 = test_psi_is_mult_reduced 0x7ecf\n```"}]}
{"filename":"BLST-Verification\/tests\/ShortWeierstrassCurveTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the algebraic group laws for elliptic curve operations defined in the ShortWeierstrassCurve module. Specifically, specify properties that check closure, commutativity, associativity, and inverses for point addition and doubling on the elliptic curves C1, C2, and C3. Include properties verifying that scalar multiplication distributes over addition and multiplication as expected. Ensure the properties are suitable for automated checking or proving within Cryptol's verification framework."},{"role":"assistant","content":"```cryptol\n\/\/ Some tests of the algebraic properties of curve operations\n\nimport PrimeField\nimport ExtensionField\nimport ShortWeierstrassCurve\n\nF7 = prime_field_bv 0b111\nC1: EllipticCurve [3]\nC1 = {base_field = F7, a = 0, b = 1}\n\nF13 = prime_field`{13}\nC2: EllipticCurve (Z 13)\nC2 = {base_field = F13, a = 3, b = 1} \/\/ 18 rational points\n\nF3 = prime_field`{3}\nF9 = extension_field F3 [0,2]\nC3: EllipticCurve _ \/\/ [2](Z 3) can be inferred\nC3 = {base_field = F9, a = [1,1], b=[1,2]}\n\ndouble_stays_on_curve C S =\n   is_point_affine C S ==> is_point_affine C (double C S)\n\nproperty double_stays_on_curve1 = double_stays_on_curve C1\nproperty double_stays_on_curve2 = double_stays_on_curve C2\nproperty double_stays_on_curve3 = double_stays_on_curve C3\n\nadd_closed C P Q =\n   is_point_affine C P \/\\ is_point_affine C Q ==>\n   is_point_affine C (add C P Q)\n\nproperty add_closed1 = add_closed C1\nproperty add_closed2 = add_closed C2\nproperty add_closed3 = add_closed C3\n\nadd_commutes C P Q =\n   is_point_affine C P \/\\ is_point_affine C Q ==>\n   same_point_affine C (add C P Q) (add C Q P)\n\nproperty add_commutes1 = add_commutes C1\nproperty add_commutes2 = add_commutes C2\nproperty add_commutes3 = add_commutes C3\n\nsubtraction_inverts_addition C P Q =\n   is_point_affine C P \/\\ is_point_affine C Q ==>\n   same_point_affine C (sub C (add C P Q) Q) P  \n\nproperty subtraction_inverts_addition1 = subtraction_inverts_addition C1\nproperty subtraction_inverts_addition2 = subtraction_inverts_addition C2\nproperty subtraction_inverts_addition3 = subtraction_inverts_addition C3\n\naddition_inverts_subtraction C P Q =\n   is_point_affine C P \/\\ is_point_affine C Q ==>\n   same_point_affine C (add C (sub C P Q) Q) P  \n\nproperty addition_inverts_subtraction1 = addition_inverts_subtraction C1\nproperty addition_inverts_subtraction2 = addition_inverts_subtraction C2\nproperty addition_inverts_subtraction3 = addition_inverts_subtraction C3\n\nmult_sum C S a b =\n    is_point_affine C S \/\\ a <= 0x3f \/\\ b <= 0x3f ==> \/\/ so a+b does not overflow\n    same_point_affine C (mult C (a+b) S) (add C (mult C a S) (mult C b S))\n\nproperty mult_sum1 = mult_sum C1\nproperty mult_sum2 = mult_sum C2\nproperty mult_sum3 = mult_sum C3\n\nmult_prod C S a b =\n    is_point_affine C S \/\\ a <= 0x0f \/\\ b <= 0x0f ==> \/\/ so a*b does not overflow\n    same_point_affine C (mult C (a*b) S) (mult C a (mult C b S))\n\nproperty mult_prod1 = mult_prod C1\nproperty mult_prod2 = mult_prod C2\nproperty mult_prod3 = mult_prod C3\n```"}]}
{"filename":"BLST-Verification\/tests\/FrobeniusTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify that the Frobenius operations defined in the Frobenius module correspond exactly to exponentiation by p (the prime modulus) on the respective finite fields Fp_2, Fp_6, and Fp_12. Ensure the properties normalize inputs before comparison and are suitable for automated property checking or formal verification."},{"role":"assistant","content":"```cryptol\nimport Parameters as P\nimport Frobenius\nimport FieldExtras\n\np: [381]\np = `P::p\n\n\/\/ It is a simple mathematical fact that the operations defined in module Frobenius are\n\/\/ in fact p^th powers.  We can run a few tests just to check against simple implementation\n\/\/ errors.\n\nproperty fp2_frobenius_prop x =\n  fp2_frobenius x' == F_expt P::Fp_2 x' p where x' = P::Fp_2.normalize x\n\nproperty f6_frobenius_prop x =\n  fp6_frobenius x' == F_expt P::Fp_6 x' p where x' = P::Fp_6.normalize x\n\nproperty f12_frobenius_prop x =\n  fp12_frobenius x' == F_expt P::Fp_12 x' p where x' = P::Fp_12.normalize x\n```"}]}
{"filename":"BLST-Verification\/tests\/ProjectiveCurveOperationsTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the projective curve operations (addition, doubling, subtraction, and scalar multiplication) preserve the elliptic curve group laws and correspond correctly to their affine counterparts, ensuring correctness of the ProjectiveCurveOperations module against the ShortWeierstrassCurve affine implementation."},{"role":"assistant","content":"```cryptol\n\/\/ Tests of ProjectiveCurveOperations\n\/\/\n\/\/ Here we just check that we get results equivalent to the affine versions\n\nimport ShortWeierstrassCurve\nimport ProjectiveCurveOperations\nimport PrimeField\nimport FieldExtras\n\nF7 = prime_field`{7}\nC1: EllipticCurve _\nC1 = {base_field = F7, a = 1, b = 3}\n  \nF13 = prime_field_bv (13:[4])\nC2: EllipticCurve _\nC2 = {base_field = F13, a = 4, b = 5}\n\n\/\/ FAILS for S = (0,0), because of the special-case representation of point_O\n\/\/ Perhaps projectify should recognize this case?\n\/\/is_point_OK_1 C S =\n\/\/  is_point_affine C S == is_point_projective C (projectify C S)\n\nis_point_OK_1 C S =\n  is_point_O C S \\\/\n  is_point_affine C S == is_point_projective C (projectify C S)\n\nproperty projectify_preserves_is_point_C1 = is_point_OK_1 C1\nproperty projectify_preserves_is_point_C2 = is_point_OK_1 C2\n\n\/\/ FAILS for S = (0,0,1) because of our representation of point_O as (0,0)\n\/\/is_point_OK_2 C S =\n\/\/  (is_point_projective C S == is_point_affine C (affinify C S))\nis_point_OK_2 C S =\n  is_point_O C (affinify C S) \\\/\n  is_point_projective C S == is_point_affine C (affinify C S)\n\nproperty affinify_preserves_is_point_C1 = is_point_OK_2 C1\nproperty affinify_preserves_is_point_C2 = is_point_OK_2 C2\n\n\/\/ doubling\n\ndouble_stays_on_curve C S =\n   is_point_projective C S ==> is_point_projective C (p_double C S)\n\nproperty double_stays_on_curve_C1 = double_stays_on_curve C1\nproperty double_stays_on_curve_C2 = double_stays_on_curve C2\n\ndouble_agrees C S =\n   is_point_projective C S ==>\n   same_point_affine C (affinify C (p_double C S))\n                       (double C (affinify C S))\n\nproperty double_agrees_C1 = double_agrees C1\nproperty double_agrees_C2 = double_agrees C2\n\n\/\/ addition\n\naddition_zero C S =\n    is_point_projective C S ==> same_point C S (p_add C S (p_point_O C))\n\naddition_commutes C S T =\n    is_point_projective C S \/\\  is_point_projective C T ==>\n    same_point C (p_add C S T) (p_add C T S)\n\nproperty addition_commutes_C1 = addition_commutes C1\nproperty addition_commutes_C2 = addition_commutes C2\n\naddition_distributes C S T R =\n    is_point_projective C S \/\\ is_point_projective C T \/\\ is_point_projective C R ==>\n    same_point C (p_add C S (p_add C T R)) (p_add C (p_add C S T) R)\n\nproperty addition_distributes_C1 = addition_distributes C1\nproperty addition_distributes_C2 = addition_distributes C2\n\naddition_agrees C S T =\n    is_point_projective C S \/\\  is_point_projective C T ==>\n    same_point_affine C (add C (affinify C S) (affinify C T))\n                        (affinify C (p_add C S T))\n\nproperty addition_agrees_C1 = addition_agrees C1\nproperty addition_agrees_C2 = addition_agrees C2\n\n\/\/ subtraction\n\nsubtraction_inverts_addition C S T =\n     is_point_projective C S \/\\ is_point_projective C T ==>\n     same_point C S (p_sub C (p_add C S T) T)\n\nproperty subtraction_inverts_addition_C1 = subtraction_inverts_addition C1\nproperty subtraction_inverts_addition_C2 = subtraction_inverts_addition C2\n\nsubtraction_agrees C S T =\n     is_point_projective C S \/\\  is_point_projective C T ==>\n     same_point_affine C (sub C (affinify C S) (affinify C T))\n                         (affinify C (p_sub C S T))\n\nproperty subtraction_agrees_C1 = subtraction_agrees C1\nproperty subtraction_agrees_C2 = subtraction_agrees C2\n\np_mult_agrees: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> ProjectivePoint t -> Bool\np_mult_agrees C m S =\n    is_point_projective C S ==>\n    same_point_affine C (affinify C (p_mult`{k=k} C m S))\n                        (mult`{k=k} C m (affinify C S))\n\nproperty p_mult_agrees_C1 = p_mult_agrees`{k=4} C1\nproperty p_mult_agrees_C2 = p_mult_agrees`{k=3} C2\n\np_mult_affine_agrees: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> AffinePoint t -> Bool\np_mult_affine_agrees C m S =\n    is_point_affine C S ==>\n    same_point_affine C (p_mult_affine`{k=k} C m S)\n                        (mult`{k=k} C m S)\n```"}]}
{"filename":"BLST-Verification\/tests\/SerializationTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that serializing and then deserializing points on the elliptic curves E and E' are identity operations, ensuring that deserialize_E1(serialize_E1(Q) # zero) == just Q and deserialize_E2(serialize_E2(Q)) == just Q hold for all valid points Q generated by scalar multiplication on the respective base points BP and BP'."},{"role":"assistant","content":"```cryptol\nimport Serialization\nimport Parameters\nimport ShortWeierstrassCurve as EC\nimport Maybe\n\nproperty ser_des_E1 (m:[16]) =\n  deserialize_E1 ((serialize_E1 Q) # zero) == just Q where Q = EC::mult E m BP\n\nproperty ser_des_E2 (m:[16]) =\n  deserialize_E2 (serialize_E2 Q) == just Q where Q = EC::mult E' m BP'\n```"}]}
{"filename":"BLST-Verification\/tests\/PolynomialTest.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of polynomial arithmetic operations defined in the Polynomial module. Specifically, create properties that check the behavior of polynomial multiplication with zero and one, commutativity of multiplication, correctness of division with remainder, and the correctness of modular inverse operations over finite fields. Ensure these properties handle polynomials represented as coefficient vectors over prime fields and include tests for irreducible polynomials used as moduli."},{"role":"assistant","content":"```cryptol\n\/\/ tests for the Polynomial module\n\nimport Common::Field\nimport Polynomial\nimport PrimeField\n\n\/\/ check that all coefficients are in their field\nis_OK: {t,k} (fin k) => FieldRep t -> [k]t ->Bool\nis_OK F p = all F.is_val p\n\npoly_mul_0:  {t,k} (fin k, k>=1) => FieldRep t -> [k]t ->Bool\npoly_mul_0 F x = poly_equal F (poly_mul F x (poly_0 F), poly_0 F)\n\npoly_mul_1:  {t,k} (fin k, k>=1) => FieldRep t -> [k]t ->Bool\npoly_mul_1 F x =\n   is_OK F x ==> poly_equal F (poly_mul F x (poly_1 F), x)\n\npoly_mul_commutes:  {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t ->Bool\npoly_mul_commutes F x y =\n    is_OK F x \/\\ is_OK F y ==> poly_equal F (poly_mul F x y, poly_mul F y x)\n\npoly_mul_mod_commutes:  {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t ->Bool\npoly_mul_mod_commutes F x y =\n    is_OK F x \/\\ is_OK F y ==> poly_equal F (poly_mul F x y, poly_mul F y x)\n\npoly_div_mod_prop: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t ->  Bool\npoly_div_mod_prop F x y =\n    is_OK F y \/\\ is_OK F x \/\\ ~ (poly_equal F (y, poly_0 F)) ==>\n    poly_equal F (x, poly_add F (poly_mul F q y) r) where (q,r) = poly_div_mod F x y\n\npoly_inverse_mod_prop: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t -> Bool\n\/\/ only when q represents an irreducible polynomial\npoly_inverse_mod_prop F q p =\n    (is_OK F q) \/\\ is_OK F p \/\\ ~ (poly_equal F (p, poly_0 F)) ==> \n    poly_equal F (poly_mul_mod F p (poly_inverse_mod F p q) q, poly_1 F)\n\n\nF7 = prime_field`{7}\nF29 = prime_field_bv (29:[5])\n\n\/\/ Some monomorphic test cases\n\nproperty mul_0_F7 = poly_mul_0`{k=4} F7\nproperty mul_1_F7 = poly_mul_1`{k=4} F7\nproperty mul_commutes_F7 = poly_mul_commutes`{k=5} F7\nproperty mul_mod_commutes_F7 = poly_mul_mod_commutes`{k=4} F7\n\nproperty div_mod_F7 = poly_div_mod_prop`{k=3} F7\nproperty div_mod_F7' = poly_div_mod_prop`{k=8} F7\n\n\/\/ for the inverse_mod property, take care to recall the unusual representatin of the modulus.\nproperty inverse_mod_F7 = poly_inverse_mod_prop`{k=3} F7 [1,1,3] \/\/ q=x^3-x^2-x-3 is irreducible in F7\nproperty inverse_mod_F7' = poly_inverse_mod_prop`{k=4} F7 [2,0,1,1] \/\/ x^4-2*x^3-x-1 is irreducible in F7\n\nproperty mul_0_F29 = poly_mul_0`{k=4} F29\nproperty mul_1_F29 = poly_mul_1`{k=4} F29\nproperty mul_commutes_F29 = poly_mul_commutes`{k=5} F29\nproperty mul_mod_commutes_F29 = poly_mul_mod_commutes`{k=4} F29\n\nproperty div_mod_F29 = poly_div_mod_prop`{k=3} F29\n\nproperty inverse_mod_F29 = poly_inverse_mod_prop`{k=3} F29 [2,3,5] \/\/ x^3-2x^2-3y-5 is irreducible in F29\nproperty inverse_mod_F29' = poly_inverse_mod_prop`{k=4} F29 [27,1,1,6] \/\/ x^4-27x^3-x^2-x-6, also irreducible\n```"}]}
{"filename":"BLST-Verification\/tests\/ClearCofactorTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the two implementations of the clear_cofactor function for the BLS12-381 G2 curve produce equivalent results on a set of test points. Include properties that compare the specification clear_cofactor_bls12381_g2 with clear_cofactor, and the implementation clear_cofactor_E2_impl with clear_cofactor, ensuring correctness of the implementation against the specification."},{"role":"assistant","content":"```cryptol\nimport HashToCurveE2\nimport HashToCurveE2Aux\nimport Parameters\nimport Serialization\nimport ShortWeierstrassCurve\n\nimport implementation::HashToG2\n\n\/\/ Check that the two clear_cofactor specifications agree\nspec_eq : AffinePoint t_Fp_2 -> Bit\nspec_eq P = (clear_cofactor_bls12381_g2 P) == (clear_cofactor P)\n\nto_Fp2: ([384], [384]) -> t_Fp_2\nto_Fp2 (a,b) = [to_Fp b, to_Fp a] \/\/ a+b*I\n\n\/\/ Get a point on the curve through deserialization\npoint = deserialize_E2 (serialize_E2 (to_Fp2 (0, 1), to_Fp2 (0, 1)))\n\n\/\/ Generate a few more points on the curve from `point`\npoints = [mult E' x (point.1) | x <- [0x1, 0x2 .. 0x5 : [4]]]\n\n\/\/ Check that the implementation function agrees with clear_cofactor\nimpl_eq P = (clear_cofactor P) == (affinify E' (clear_cofactor_E2_impl (projectify E' P)))\n\n\/\/ Since changing `mult` to `scalar_mult` in clear_cofactor_bls12381_g2,\n\/\/ running this check is too slow.  It can be uncommented if\n\/\/ clear_cofactor_bls12381_g2 is ever changed back to use `mult`.\n\/\/property spec_eq_many = all spec_eq points\n\nproperty impl_eq_many = all impl_eq points\n```"}]}
{"filename":"BLST-Verification\/tests\/HashToG2Tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property-based specification that verifies the equivalence between the implementation 'map_to_curve_E2_prime_impl' and the reference function 'map_to_curve_simple_swu' for hashing to G2. The specification should include test vectors and a property that asserts the outputs of both functions are equal after applying 'affinify C'."},{"role":"assistant","content":"```cryptol\nimport HashToCurveE2\nimport HashToCurveE2Aux\nimport Serialization\nimport ShortWeierstrassCurve\nimport implementation::HashToG2\n\ntest u = (affinify C (map_to_curve_E2_prime_impl u)) == map_to_curve_simple_swu u\n\nus = [zero, [324,33], [1,0],[`p-1,7]]\n\nproperty prop = all test us\n```"}]}
{"filename":"BLST-Verification\/tests\/HashToCurveE1Tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the hash-to-curve implementation in the provided file. Your specification should include properties that check the correctness of the expand_message function against known test vectors, verify that hash_to_field produces expected field elements, confirm that map_to_curve_simple_swu maps inputs to valid affine points on the isogenous and target curves, and ensure that the overall hash_to_curve function produces points matching the provided expected coordinates. Include properties that cover all example inputs and outputs shown in the code excerpt."},{"role":"assistant","content":"```cryptol\n\/\/ Tests for hashing to curve E1, from draft-irtf-cfrg-hash-to-curve-09\n\nimport ExpandMessage\nimport HashToCurveE1\nimport ShortWeierstrassCurve as EC\nimport Parameters as P\n\n\/\/ Appendix I.1  tests expand_message\n\ndst_1 = \"QUUX-V01-CS02-with-expander\"\n\nproperty expand_test_1 =\n    expand_message \"\" dst_1 ==\n    split 0xf659819a6473c1835b25ea59e3d38914c98b374f0970b7e4c92181df928fca88\n\nproperty expand_test_2 =\n    expand_message  \"abc\" dst_1 ==\n    split 0x1c38f7c211ef233367b2420d04798fa4698080a8901021a795a1151775fe4da7\n\nproperty expand_test_3 =\n    expand_message \"abcdef0123456789\" dst_1 ==\n    split 0x8f7e7b66791f0da0dbb5ec7c22ec637f79758c0a48170bfb7c4611bd304ece89\n\nmsg_q128 = \"q128_qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\" #\n           \"qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\" #\n           \"qqqqqqqqqqqqqqqqqqqqqqqqq\"\n\nproperty expand_test_4 =\n    expand_message msg_q128 dst_1 ==\n    split 0x72d5aa5ec810370d1f0013c0df2f1d65699494ee2a39f72e1716b1b964e1c642\n\n\nmsg_a512 = \"a512_\"  # ['a' | _ <- [0..511]]\n\nproperty expand_test_5 =\n    expand_message msg_a512 dst_1 ==\n    split 0x3b8e704fc48336aca4c2a12195b720882f2162a4b7b13a9c350db46f429b771b\n\n\/\/ From Section H.9.1, BLS12381G1_XMD:SHA-256_SSWU_RO_\n\nto_Fp = P::to_Fp dst = \"QUUX-V01-CS02-with-BLS12381G1_XMD:SHA-256_SSWU_RO_\"\n\nex1_msg = \"\"\n\nex1_us = hash_to_field`{count=2} ex1_msg dst\n\nex1_expected_us =\n   [ to_Fp 0x0ba14bd907ad64a016293ee7c2d276b8eae71f25a4b941eece7b0d89f17f75cb3ae5438a614fb61d6835ad59f29c564f\n   , to_Fp 0x019b9bd7979f12657976de2884c7cce192b82c177c80e0ec604436a7f538d231552f0d96d9f7babe5fa3b19b3ff25ac9\n   ]\n\nproperty hash_to_field_test_1 =\n    ex1_us == ex1_expected_us\n\n\/\/ .. the first step works (map_to_curve, going to Isogenous_Curve)\n\nproperty map_to_curve_test_1_1_a =\n    EC::is_point_affine Isogenous_Curve (map_to_curve_simple_swu (ex1_us@0))\n\nproperty map_to_curve_test_1_1_b =\n    EC::is_point_affine Isogenous_Curve (map_to_curve_simple_swu (ex1_us@1))\n\n\/\/ ... and the isogeny gets us to the curve C\n\nproperty map_to_curve_test_1_2_a =\n    EC::is_point_affine P::E (map_to_curve_simple_swu_AB0 (ex1_us@0))\n\nproperty map_to_curve_test_1_2_b =\n    EC::is_point_affine P::E (map_to_curve_simple_swu_AB0 (ex1_us@1))\n\n\/\/ .. and indeed to the correct points on that curve\n\nproperty map_to_curve_test_1_3_a =\n    EC::same_point_affine P::E (map_to_curve_simple_swu_AB0 (ex1_us@0))\n    (to_Fp 0x11a3cce7e1d90975990066b2f2643b9540fa40d6137780df4e753a8054d07580db3b7f1f03396333d4a359d1fe3766fe,\n     to_Fp 0x0eeaf6d794e479e270da10fdaf768db4c96b650a74518fc67b04b03927754bac66f3ac720404f339ecdcc028afa091b7)\n\nproperty map_to_curve_test_1_3_b =\n    EC::same_point_affine P::E (map_to_curve_simple_swu_AB0 (ex1_us@1))\n    (to_Fp 0x160003aaf1632b13396dbad518effa00fff532f604de1a7fc2082ff4cb0afa2d63b2c32da1bef2bf6c5ca62dc6b72f9c,\n     to_Fp 0x0d8bb2d14e20cf9f6036152ed386d79189415b6d015a20133acb4e019139b94e9c146aaad5817f866c95d609a361735e)\n\n\/\/ ... finally, the overall mapping gets us the correct result.\n\nproperty hash_to_curve_test_1 =\n    EC::same_point_affine P::E (hash_to_curve (\"\", dst))\n    (to_Fp 0x052926add2207b76ca4fa57a8734416c8dc95e24501772c814278700eed6d1e4e8cf62d9c09db0fac349612b759e79a1,\n     to_Fp 0x08ba738453bfed09cb546dbb0783dbb3a5f1f566ed67bb6be0e8c67e2e81a4cc68ee29813bb7994998f3eae0c9c6a265)\n\n\/\/ Example 2\n\nex2_msg = \"abc\"\nex2_us = hash_to_field`{count=2} ex2_msg dst\n\nex2_expected_us =\n [ to_Fp 0x0d921c33f2bad966478a03ca35d05719bdf92d347557ea166e5bba579eea9b83e9afa5c088573c2281410369fbd32951\n , to_Fp 0x003574a00b109ada2f26a37a91f9d1e740dffd8d69ec0c35e1e9f4652c7dba61123e9dd2e76c655d956e2b3462611139\n ]\n\nproperty hash_to_field_test_2 =\n  ex2_us == ex2_expected_us\n\nproperty hash_to_curve_test_2 =\n    EC::same_point_affine P::E (hash_to_curve (\"abc\", dst))\n    (to_Fp 0x03567bc5ef9c690c2ab2ecdf6a96ef1c139cc0b2f284dca0a9a7943388a49a3aee664ba5379a7655d3c68900be2f6903,\n     to_Fp 0x0b9c15f3fe6e5cf4211f346271d7b01c8f3b28be689c8429c85b67af215533311f0b8dfaaa154fa6b88176c229f2885d)\n\n\/\/ Examples 3 .. \n\nproperty hash_to_curve_test_3 =\n    EC::same_point_affine P::E (hash_to_curve (\"abcdef0123456789\", dst))\n    (to_Fp 0x11e0b079dea29a68f0383ee94fed1b940995272407e3bb916bbf268c263ddd57a6a27200a784cbc248e84f357ce82d98,\n     to_Fp 0x03a87ae2caf14e8ee52e51fa2ed8eefe80f02457004ba4d486d6aa1f517c0889501dc7413753f9599b099ebcbbd2d709)\n\nproperty hash_to_curve_test_4 =\n    EC::same_point_affine P::E (hash_to_curve (msg_q128, dst))\n    (to_Fp 0x15f68eaa693b95ccb85215dc65fa81038d69629f70aeee0d0f677cf22285e7bf58d7cb86eefe8f2e9bc3f8cb84fac488,\n     to_Fp 0x1807a1d50c29f430b8cafc4f8638dfeeadf51211e1602a5f184443076715f91bb90a48ba1e370edce6ae1062f5e6dd38)\n\nproperty hash_to_curve_test_5 =\n    EC::same_point_affine P::E (hash_to_curve (msg_a512, dst))\n    (to_Fp 0x082aabae8b7dedb0e78aeb619ad3bfd9277a2f77ba7fad20ef6aabdc6c31d19ba5a6d12283553294c1825c4b3ca2dcfe,\n     to_Fp 0x05b84ae5a942248eea39e1d91030458c40153f3b654ab7872d779ad1e942856a20c438e8d99bc8abfbf74729ce1f7ac8)\n```"}]}
{"filename":"BLST-Verification\/spec\/ProjectiveCurveOperationsA0.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the elliptic curve point operations defined in the ProjectiveCurveOperationsA0 module. Specifically, specify properties that check: 1) p_double correctly doubles a point on the curve, 2) p_add and p_add_affine produce the same result when adding points, 3) p_sub correctly computes the difference of two points, and 4) p_mult and p_mult_affine produce consistent scalar multiplication results. Include checks for the identity point behavior and ensure that operations respect the curve equation y^2 = x^3 + b in projective coordinates."},{"role":"assistant","content":"```cryptol\n\/\/ Optimized algorithms for curves in Weierstrass short form with a = 0,\n\/\/ over an arbitrary field.  That is, with equation y^2 = x^3 + b\n\/\/\n\/\/ These algorithms work in Jacobian projective coordinates.\n\/\/\n\/\/ Formulas come from https:\/\/hyperelliptic.org\/EFD\/g1p\/auto-shortw-jacobian-0.html\n\nmodule ProjectiveCurveOperationsA0  where\n\nimport Common::Field\nimport ShortWeierstrassCurve\nimport FieldExtras\n\nprivate\n\n  two: {t} FieldRep t -> t\n  two F = F.add (F.field_unit, F.field_unit)   three: {t} FieldRep t -> t\n  three F = F.add (two F, F.field_unit)\n\n  F_double: {t} FieldRep t -> t -> t\n  F_double F x = F.add (x, x)\n\n  cubed: {t} FieldRep t -> t -> t\n  cubed F x = F.mul(x, F.sq x)\n\np_point_O: {t} EllipticCurve t -> ProjectivePoint t\np_point_O C = (F.field_unit, F.field_unit, F.field_zero) where F = C.base_field\n\n\/**\n * p_double P is the sum P+P for P a point on the elliptic curve.\n *\/\np_double: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t\np_double C (X1,Y1,Z1) =\n    \/\/ Using the \"dbl-2009-alnr\" doubling formulas, three-operand code version\n    if F_is_zero F Z1 then p_point_O C else (X3, Y3, Z3) where \n        F = C.base_field\n        A = F.sq X1 \/\/ A = X1^2\n        B = F.sq Y1 \/\/ B = Y1^2\n        ZZ = F.sq Z1 \/\/ ZZ = Z1^2\n        C' = F.sq B    \/\/ C = B^2\n        t0 = F.add (X1, B) \/\/t0 = X1+B\n        t1 = F.sq t0         t2 = F.sub (t1, A)         t3 = F.sub (t2, C')         D = F.mul (two F, t3)         E = F.mul (three F, A)         F' = F.sq E         t4 = F_double F D         X3 = F.sub (F', t4)         t5 = F.sub (D, X3)                            t6 = F_double F (F_double F (F_double F C'))         t7 = F.mul (E, t5)         Y3 = F.sub (t7, t6)         t8 = F.add (Y1, Z1)         t9 = F.sq t8         t10 = F.sub (t9, B)         Z3 = F.sub (t10, ZZ)     \n\n\/**\n * Sum of two distinct points in projective coordinates on the elliptic curve,\n * provided neither is the zero point.\n * If the two points are the same, returns (0,0,0)\n *\/\np_add_generic: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_add_generic C (X1,Y1,Z1) (X2,Y2,Z2) = (X3, Y3, Z3) where\n    F = C.base_field\n    \/\/ using the  \"add-2007-bl\" addition formula\n    Z1Z1 = F.sq Z1                         Z2Z2 = F.sq Z2                         U1 = F.mul (X1, Z2Z2)                  U2 = F.mul (X2, Z1Z1)                  S1 = F.mul (Y1, F.mul (Z2, Z2Z2))      S2 = F.mul (Y2, F.mul (Z1, Z1Z1))      H = F.sub (U2, U1)                     I = F.sq (F.mul (two F, H))        \/\/ I = (2*H)^2\n    J = F.mul (H, I)                       r = F.mul (two F, F.sub (S2, S1))      V = F.mul (U1, I)                  \/\/ V = U1*I\n    X3 = F.sub (F.sub (F.sq r, J), F.mul (two F, V))                       Y3 = F.sub (F.mul (r, F.sub (V, X3)), F.mul (F.mul(two F, S1), J))     Z3 = F.mul (F.sub (F.sub (F.sq (F.add (Z1, Z2)), Z1Z1), Z2Z2), H)  \/\/ Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2)*H\n\n\n\/*\nThe \"madd-2007-bl\" addition formulas https:\/\/hyperelliptic.org\/EFD\/g1p\/auto-shortw-jacobian-0.html\nis a simple algebraic simplification of the \"add-2007-bl\" formula when Z2 = 1.\n*\/\np_add_affine: {t} EllipticCurve t -> ProjectivePoint t -> AffinePoint t -> ProjectivePoint t\np_add_affine C (X1,Y1,Z1) (X2,Y2) = (X3, Y3, Z3) where\n    F = C.base_field\n    \/\/ using the  \"madd-2007-bl\" addition formula\n    Z1Z1 = F.sq Z1                         U2 = F.mul (X2, Z1Z1)                  S2 = F.mul (Y2, F.mul (Z1, Z1Z1))      H = F.sub (U2, X1)                 \/\/ H = U2-X1\n    HH = F.sq H                        \/\/ HH = H^2\n    I = F_double F (F_double F HH)     \/\/ I = 4*HH\n    J = F.mul (H, I)                       r = F.mul (two F, F.sub (S2, Y1))  \/\/ r = 2*(S2-Y1)\n    V = F.mul (X1, I)                      X3 = F.sub (F.sub (F.sq r, J), F.mul (two F, V))                       Y3 = F.sub (F.mul (r, F.sub (V, X3)), F.mul (F.mul(two F, Y1), J)) \/\/ Y3 = r*(V-X3)-2*Y1*J\n    Z3 = F.sub (F.sub (F.sq (F.add (Z1, H)), Z1Z1), HH)                \/\/ Z3 = (Z1+H)^2-Z1Z1-HH\n\n\/**\n * Sum of two points in projective coordinates on the elliptic curve.\n *\/\np_add: {t} EllipticCurve t ->  ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_add C S T = \n    if F_is_zero F Z1 then T\n     | F_is_zero F Z2 then S\n     | all (F_is_zero F) [X3,Y3,Z3] then p_double C S      else R\n    where\n        F = C.base_field\n        (_,_,Z1) = S\n        (_,_,Z2) = T\n        R = p_add_generic C S T\n        (X3,Y3,Z3) = R\n\n\/**\n * Difference of two points in projective coordinates on the elliptic curve.\n *\/\np_sub: {t} EllipticCurve t ->  ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_sub C S (x,y,z) = p_add C S (x, C.base_field.neg y, z)\n\n\/**\n * Integer multiple of a point in projective coordinates on the elliptic curve.\n * The multiplier, a bitvector, is interpreted as a non-negative integer.\n *\/\np_mult: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> ProjectivePoint t -> ProjectivePoint t\np_mult C d S = if d == 0 then p_point_O C\n               |  d == 1 then S\n               |  F_is_zero F S.2 then p_point_O C\n               else Rs!1\n    where\n        F = C.base_field\n        k = 0b00 # d \/\/ 2 extra top bits, so that h does not overflow\n        h = k + k + k\n        Rs = [p_point_O C] # \/\/Here we start with 1 instead of S because we don't really know where the high-bit is\n             [ if hi && ~ki then p_add C RiDouble S\n                | ~hi && ki then p_sub C RiDouble S\n                else RiDouble\n               where RiDouble = p_double C Ri\n             | ki <- k | hi <- h | Ri <- Rs ]\n\n\/**\n * Integer multiple of a point in affine coordinates  on the elliptic curve.\n * The multiplier, a bitvector, is interpreted as a non-negative integer.\n * This definition uses projective operations internally, but should give\n * the same result as `mult`.\n *\/\np_mult_affine: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> AffinePoint t -> AffinePoint t\np_mult_affine C d S =\n               if d == 0 then point_O C\n               |  d == 1 then S\n               |  is_point_O C S then S\n               else affinify C (Rs!1)\n    where\n        F = C.base_field\n        negS = ( (x, F.neg y) where (x,y) = S )\n        k = 0b00 # d \/\/ 2 extra top bits, so that h does not overflow\n        h = k + k + k\n        Rs = [p_point_O C] # \/\/Here we start with 1 instead of S because we don't really know where the high-bit is\n             [ if hi && ~ki then add' RiDouble S\n                | ~hi && ki then add' RiDouble negS\n                else RiDouble\n               where RiDouble = p_double C Ri\n             | ki <- k | hi <- h | Ri <- Rs ]\n        add': ProjectivePoint t -> AffinePoint t -> ProjectivePoint t \/\/ \"full\" version of p_add_affine\n        add' U V = if F_is_zero F Z1 then projectify C V\n                  |  all (F_is_zero F) [X3,Y3,Z3] then p_double C U\n                  else R\n            where\n                (_,_,Z1) = U\n                R = p_add_affine C U V\n                (X3,Y3,Z3) = R\n```"}]}
{"filename":"BLST-Verification\/spec\/Polynomial.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of polynomial operations defined in the Polynomial module. Include properties that check: (1) poly_add and poly_sub behave as expected for polynomial addition and subtraction, (2) poly_mul and poly_full_mul produce consistent multiplication results, (3) poly_div_mod correctly computes quotient and remainder satisfying the division algorithm, and (4) poly_inverse_mod computes the multiplicative inverse modulo a polynomial when it exists. Ensure properties cover edge cases such as zero polynomials and polynomials of minimal degree."},{"role":"assistant","content":"```cryptol\nmodule Polynomial where\n\nimport Common::Field\n\n\/\/\/\/\/ Polynomials over a field\n\/\/\n\/\/  A value `p: [k]t` represents a polyomial with `p!0` giving the constant coefficient\n\/\/  thus for example `[1,0,2]` represents x^2 + 2, as does `[0,1,0,2]`\n\n\/**\n * Are two polynomials equal?  This uses the equality defined in the underlying field,\n * so `poly_equal p q` might not be the same as `p == q`.\n *\/\npoly_equal:  {t,k} (fin k, k>=1) => FieldRep t -> ([k]t, [k]t) -> Bool\npoly_equal F (p,q) = and (zipWith (curry F.is_equal) p q)\n\n\/**\n * 0, as a polynomial over a field\n *\/\npoly_0: {t,k} (fin k) => FieldRep t -> [k]t\npoly_0 F = repeat F.field_zero\n\n\/**\n *\n * Constant polynomial: a member of the base field viewed as a polynomial\n *\/\npoly_const: {t,k} (fin k, k >= 1) => FieldRep t -> t -> [k]t\npoly_const F c = (repeat F.field_zero) # [c]\n\n\/**\n * 1, as a polynomial over a field\n *\/\npoly_1: {t,k} (fin k, k >= 1) => FieldRep t -> [k]t\npoly_1 F = poly_const F F.field_unit\n\n\/**\n * x, as a polynomial over a field\n *\/\npoly_x: {t,k} (fin k, k >= 2) => FieldRep t -> [k]t\npoly_x F = (repeat F.field_zero) # [F.field_unit, F.field_zero]\n\n\/**\n * The degree of a polynomial.  We arbitrarily return 0 for the degree ofthe zero polynomial.\n *\/\npoly_degree: {t, k, a} (fin k, Ring a, Literal (max 1 k) a)\n             => FieldRep t -> [k+1]t -> a\npoly_degree F coeffs = (ds!0).0 where\n    ds = [(`k,True)] # [ if lz \/\\ F.is_equal(ci, F.field_zero) then (d-1,True) else (d, False)\n                       | (d,lz) <- ds\n                       | ci <- coeffs\n                       ]\n\n\/**\n * The leading coefficient of a non-zero polynomial.  This is the coefficient of the\n * largest power of x that has a non-zero coefficient.\n *\/\nleading_coefficient: {t,k} (fin k) => FieldRep t -> [k]t -> t\nleading_coefficient F p =\n    foldr (\\ c a -> if F.is_equal (c, F.field_zero) then a else c) F.field_zero p\n\n\/**\n * The sum of two polynomials over a field.\n *\/\npoly_add: {t,k} (fin k) => FieldRep t -> [k]t -> [k]t -> [k]t\npoly_add F = zipWith (curry F.add)\n\n\/**\n * The difference of two polynomials over a field.\n *\/\npoly_sub: {t,k} (fin k) => FieldRep t -> [k]t -> [k]t -> [k]t\npoly_sub F = zipWith (curry F.sub)\n\nprivate\n    shifts: {k,t} (fin k, k >= 1) => t -> [k]t -> [k][k]t\n    shifts pad seq = take seqs where\n        seqs = [seq] # [shift s | s <- seqs]\n        shift s = tail s # [pad]\n\n\/**\n * The product of two polynomials over a field, truncated at their size\n * That is, if p, q: [k]t, then all terms c*x^i for i >= k are dropped.\n *\n * Function `poly_full_mul` does not discard those terms.\n *\/\npoly_mul: {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t -> [k]t\npoly_mul F p q = foldl (poly_add`{t,k} F) (poly_0 F) rows where\n    rows: [k][k]t\n    rows = zipWith (\\ c s -> map (curry F.mul c) s) p (reverse (shifts F.field_zero q))\n\n\/**\n * The product of two polynomials over a field, with  result type\n * guaranteed to hold all the non-zero coefficients of the result.\n *\n * Compare to function `poly_mul`.\n *\/\npoly_full_mul: {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t -> [2*k-1]t\npoly_full_mul F p q = foldl (poly_add F) (poly_0 F) rows where\n    rows: [k][2*k-1]t\n    rows = zipWith (\\ c s -> map (curry F.mul c) s) p (reverse (full_shifts F.field_zero q))\n    full_shifts: t -> [k]t -> [k][2*k-1]t\n    full_shifts pad seq = take seqs where\n        seqs = [(repeat pad) # seq] # [shift s | s <- seqs]\n        shift s = tail s # [pad]\n\n\/**\n * Division with remainder for two polynomials over a field.\n * If p, q, r, d: [k]t, d is not poly_0, and (q,r) = poly_div_mod F p d,\n * then p == poly_add (poly_mul d q) r \n *\/\npoly_div_mod: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t -> ([k]t, [k]t)\npoly_div_mod F dividend divisor =(quot, rems!0) where\n    \/\/ shifted divisors, from most to least shifted\n    ds: [k][k]t\n    ds = reverse (shifts F.field_zero divisor)\n    \/\/ we only use the shifts when the leading coefficient is still in\n    use: [k]Bool\n    use = reverse us where\n      us = [True] # [u \/\\ F.is_equal (d@0, F.field_zero) | u <- us | d <- take`{k-1} (reverse ds)]\n    \/\/ index into remainder to be used\n    ix: [k+1][width k]\n    ix = [0] # [if u then i+1 else i | u <- use | i <- ix]\n    \/\/ c is the reciprocal of the leading coefficient of the divisor\n    c = F.div (F.field_unit, leading_coefficient F divisor)\n    \/\/ quot is the quotient, built from the highest degree down\n    quot: [k]t\n    quot = [ if u then F.mul (c, rem@i) else F.field_zero\n           | u <- use\n           | rem <- rems\n           | i <- ix\n           ]\n    \/\/ remainders at successive stages\n    rems: [k+1][k]t\n    rems = [dividend] # [ zipWith (curry F.sub) r (map (curry F.mul q) d)\n                        | r <- rems\n                        | q <- quot\n                        | d <- ds\n                        ]\n\n\n\/* For operations modulo some polynomial, we use a finite sequence\n * s: [k]t to represent the poynomial\n *\n *   x^k - sum [(s!i) * x^i | i <- [0 .. (`k-1)] ]      (*)\n *\n * In other words, s represents the reduction of x^k modulo the\n * polynomial.\n *\n * We refer to (*) as \"the polynomial corresponding to modulus s\"\n * in documentation below.\n *\/\n\nprivate\n    \/**\n     * (shifts_mod F p m)@i = (x^i * p) mod (Polynomial_of m)\n     *\/\n    shifts_mod: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t -> [k][k]t\n    shifts_mod F p m = take seqs where\n        seqs = [p] # [shift s | s <- seqs]\n        shift s = poly_add F (tail s # [F.field_zero]) (map (curry F.mul (s@0)) m)\n\n\/*\n * poly_mul_mod F p q m = p*q mod (Polynomial_of m), where\n * p and q are polynomials in F[x]\n *\/\npoly_mul_mod: {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t -> [k]t -> [k]t\npoly_mul_mod F p q m = foldl (poly_add`{t,k} F) (poly_0 F) rows where\n    rows: [k][k]t\n    rows = zipWith (\\ c s -> map (curry F.mul c) s) p (reverse (shifts_mod F q m))\n\n\/\/ specialized version of xgcd used for inverse_mod\n\/\/ we then do not need the \"t\" part, and can reduce mod along the way.\n\/\/ TODO: Find a citation for this algorithm\n\n\/**\n * Inverse of one polynomial modulo a second that it is relatively prime to.\n * For example, over GF(3), the inverse of `x+1` mod `x^2` is `2x+1`, since\n * `(x+1)(2x+1) = 2x^2 + 1`, which is 1 modulo `x^2`.\n *\/\npoly_inverse_mod: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t -> [k]t\npoly_inverse_mod F p q = r where\n    \/\/ if we just do xgcd p (polynomial_of q), that's in [k+1]t\n    \/\/ so instead we compute divrem (poly_of q) p\n    \/\/ drop the msb (which will be 0) and can continue in [k]t\n    poly_of_q = [F.field_unit] # (map F.neg q) \/\/ expanded modulus\n    expand_p = [F.field_zero] # p \/\/ extra bit for p\n    (q1,r1) = poly_div_mod F poly_of_q expand_p\n    \/\/ Now, continue xgcd from the second step\n    tuples = [ (tail r1, p, map F.neg (tail q1), poly_1 F) ]\n             # map (pim_step F q) tuples\n    (p1,p2,s1,s2) = tuples@(`k:Integer) \/\/ \":Integer\" eliminates a type-inference warning\n    \/\/ now p1 should be a constant polynomial, but might not be 1\n    \/\/ i.e p*s1 = p1 mod (poly_of_q)\n    \/\/ so multiply through by its inverse\n    r = map (curry F.mul (F.div (F.field_unit, p1!0))) s1\n\nprivate\n    pim_step F m (p1, p2, s1, s2) =\n        if poly_equal F (p2, poly_0 F)\n        then (p1, p2, s1, s2)\n        else ( (p2, r, s2, poly_sub F s1 (poly_mul_mod F q s2 m)) where\n               (q,r) = poly_div_mod F p1 p2\n             )\n```"}]}
{"filename":"BLST-Verification\/spec\/BLSMinimalPublicKeySize.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the public key serialization and deserialization functions (point_to_pubkey and pubkey_to_point) are inverses of each other for valid points, and that the pubkey_subgroup_check correctly identifies points in the correct subgroup. Include properties to check that deserializing a serialized public key yields the original point when the point is valid, and that invalid points fail the subgroup check."},{"role":"assistant","content":"```cryptol\nmodule BLSMinimalPublicKeySize = BLSGeneric where\n\n\/\/ Suite BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_, as defined in\n\/\/ draft-irtf-cfrg-bls-signature-04, Secton 4.2.1 and Appendix A\n\nimport Parameters\nimport HashToCurveE2\nimport Pairing (bls_ate_pairing)\nimport Serialization\nimport ShortWeierstrassCurve as EC\n\n\/\/ a pairing-friendly elliptic curve\ntype t_F = t_Fp_2 \/\/ representation type for field of the primary curve (signature)\ntype t_F' = t_Fp \/\/ representation type for field of the secondary curve (pubkey)\ntype t_G = t_Fp_12  \/\/ representation type for field of the pairing result\nG = Fp_12\n\ntype pubkey_len = 48*8\ntype signature_len  = 96*8\n\nmain_curve = E'\nother_curve = E\n\n\/\/ hash_to_point  BLS12381G2_XMD:SHA-256_SSWU_RO_\n\/\/ type DST_len = 43\n\nDST: [43][8]\nDST = \"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\"\n\nhash_to_point hx = hash_to_curve_opt (hx, DST)\n\n\/\/ other primitives \"determined by the above parameters\"\n\nP: EC::AffinePoint t_F' \/\/ base point\nP = BP\n\n\/\/ pairing: (EC::AffinePoint t_F, EC::AffinePoint t_F') -> t_G\npairing (p,q) = bls_ate_pairing q p \/\/ Section 2.2\n\n\/\/ point_to_pubkey: EC::AffinePoint t_F' -> [pubkey_len]\n\/\/ point_to_pubkey = point_to_octets_E2 \/\/ Section 2.2 BUT\n\/\/    draft-irtf-cfrg-pairing-friendly-curves-07 does not mention\n\/\/    a function of this name.  So:\npoint_to_pubkey S = join (serialize_E1 S)\n\n\/\/ point_to_signature: EC::AffinePoint t_F -> [signature_len]\n\/\/point_to_signature = point_to_octets_E1 \/\/ Section 2.2\npoint_to_signature S = join (serialize_E2 S)\n\n\/\/ pubkey_to_point: [pubkey_len] -> Maybe (EC::AffinePoint t_F') \/\/ can fail\npubkey_to_point S = uncompress_E1 (split S)\n\n\/\/ signature_to_point: [signature_len] -> Maybe (EC::AffinePoint t_F) \/\/ can fail\n\n\/\/ signature_to_point: [signature_len] -> Maybe (EC::AffinePoint t_F) \/\/ can fail\n\/\/ signature_to_point = octets_to_point_E1\nsignature_to_point S = deserialize_E2 (split S)\n\n\/\/ Here are the unoptimized versions of the subgroup check\n\n\/\/ pubkey_subgroup_check: EC::AffinePoint t_F' -> Bool\npubkey_subgroup_check S =\n    EC::is_point_O E (EC::mult E r S)\n\n\/\/ signature_subgroup_check: EC::AffinePoint t_F -> Bool\n\/\/ ... more efficient versions are allowed.\nsignature_subgroup_check S =\n    EC::is_point_O E' (EC::mult E' r S)\n```"}]}
{"filename":"BLST-Verification\/spec\/CoreVerifyPKInG1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the function core_verify_pk_in_g1, specifying the properties that must hold for valid public keys, signatures, messages, and domain separation tags. Then, write verification properties to check that core_verify_pk_in_g1 correctly verifies BLS signatures by comparing the pairings as implemented."},{"role":"assistant","content":"```cryptol\nmodule CoreVerifyPKInG1 where\n\nimport Parameters\nimport HashToCurveE2\nimport Pairing\n\ncore_verify_pk_in_g1 pk sig msg dst = Fp_12.is_equal(c1, c2) where\n    c1 = bls_ate_pairing pk (hash_to_curve_opt (msg, dst))\n    c2 = bls_ate_pairing BP sig\n```"}]}
{"filename":"BLST-Verification\/spec\/ExtensionField.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the algebraic properties of the extension_field module, including the field axioms (associativity, commutativity, distributivity, existence of additive and multiplicative identities and inverses) for the polynomial quotient ring representation. Include properties to verify that multiplication is correctly performed modulo the irreducible polynomial represented by the sequence `p`. Also, specify correctness properties for the normalization, addition, subtraction, negation, multiplication, squaring, halving, division, and equality operations defined in the extension_field implementation."},{"role":"assistant","content":"```cryptol\n\/\/\/\/\/\/ Field extensions\n\/\/\n\/\/ Extension fields are represented as polynomial quotient rings,\n\/\/ so the elements of an extension of degree m can be represented\n\/\/ by polynomials of degree at most m-1, with operations\n\/\/ carried out modulo some irreducible polynomial of degree m.\n\/\/\n\/\/ We use the Polynomial module, which represents polynomials by\n\/\/ their sequence of coefficients, in big-endian order, that is\n\/\/ with the constant coefficient appearing last.\n\/\/\n\/\/ The modulus is represented a bit strangely; see below.\n\nmodule ExtensionField where\n\nimport Common::Field\nimport Polynomial\n\n\/**\n * An extension field, represented as a polynomial quotient ring.\n *\n * The modulus is not represented directly as in the `Polynomial` module,\n * but instead we use a finite sequence `s: [k]t` to represent the poynomial\n *\n *     x^k - sum [(s!i) * x^i | i <- [0 .. (`k-1)] ]\n *\n * This `s` is in fact the polynomial giving the reduction of x^k modulo\n * the modulus.  So for example, the modulus\n *\n *      x^3 - x^2 - 5\n *\n * is represented as `[1,0,5]`.\n *\n * The modulus should be an irreducible polynomial; we do not check that here.\n *\/\nextension_field: {k, t} (fin k, k >= 1) => FieldRep t -> [k]t -> FieldRep ([k]t)\nextension_field F p =\n    { is_val = all F.is_val\n    , normalize = map F.normalize\n    , field_zero = poly_0 F\n    , field_unit = poly_1 F\n    , add (a,b) = poly_add F a b \/\/ uncurry\n    , sub (a,b) = poly_sub F a b\n    , neg = map  F.neg\n    , mul (a,b) = poly_mul_mod F a b p\n    , sq a = poly_mul_mod F a a p\n    , half = map F.half\n    , div (a,b) = poly_mul_mod F a bi p where bi = poly_inverse_mod F b p\n    , is_equal (a,b) = all F.is_equal (zip a b)\n    }\n```"}]}
{"filename":"BLST-Verification\/spec\/HashToCurveGeneric.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the `hash_to_curve` and `hash_to_curve_opt` functions in the `HashToCurveGeneric` module. The properties should ensure that the output points lie on the specified elliptic curve, that the cofactor clearing is correctly applied, and that the mapping from field elements to curve points respects the simplified SWU map properties. Additionally, specify correctness conditions for `hash_to_field` to guarantee uniform and deterministic field element generation from input messages and domain separation tags."},{"role":"assistant","content":"```cryptol\n\/\/ Hash-to-curve for BLS\n\/\/ Two variants are used:\n\/\/ BLS12381G1_XMD:SHA-256_SSWU_RO_ and  BLS12381G2_XMD:SHA-256_SSWU_RO_\n\nmodule HashToCurveGeneric where\n\nimport rfc8017 (I2OSP, OS2IP)\nimport Primitive::Keyless::Hash::SHA256 as SHA256\nimport Common::Field\nimport Parameters (t_Fp, Fp, to_Fp)\nimport FieldExtras\nimport ShortWeierstrassCurve as EC\nimport ExpandMessage\nimport Common::bv\n\n\/\/ NOTE: we use the trick described below around limitations of the Cryptol module system\n\/\/ https:\/\/github.com\/GaloisInc\/cryptol\/issues\/1092\n\nparameter\n    type _p: # \/\/ the field characteristic\n    type constraint fin _p\n    type constraint width _p <= 384 \/\/ because we have already specialized to BLS12-381 below\n\n    type _q: # \/\/ the number of elements in the field\n    type constraint fin _q\n\n    type _t_F: * \/\/ a type representing field elements in the extension\n    _F: FieldRep _t_F \/\/ the field operatons, in the extension field\n\n    type _m: # \/\/ extension degree\n    type constraint fin _m\n\n    \/\/ various constraints thrown up by the type checker\n    type constraint 8 * ((128 + lg2 p) \/^ 8) >= 384\n    type constraint 2 * m <= 127\n\n    \/\/ Convert a list of elements of F_p to an element of F_q\n    _base_to_F: [m]t_Fp -> _t_F\n\n    \/\/ The curve (will be E1 or E2)\n    _C: EC::EllipticCurve _t_F\n\n    _clear_cofactor: (_t_F, _t_F) -> (_t_F, _t_F)     \/\/ additional field operations\n    _is_square: _t_F -> Bool\n    _sqrt: _t_F -> _t_F\n    _sgn0: _t_F -> Bit     _inv0: _t_F -> _t_F\n\n    \/\/ for map_to_curve_simple_swu for AB=0\n    _Z: _t_F\n    _A': _t_F\n    _B': _t_F\n    _iso_map: (_t_F, _t_F) -> (_t_F, _t_F)\n\ntype p = _p\ntype q = _q\ntype t_F = _t_F\nF: FieldRep t_F \/\/ the field operatons, in the extension field\nF = _F\ntype m = _m \/\/ extension degree\nbase_to_F = _base_to_F\nC = _C\nclear_cofactor = _clear_cofactor\nis_square = _is_square\nsqrt = _sqrt\nsgn0 = _sgn0\ninv0 = _inv0\nZ = _Z\nA' = _A'\nB' = _B'\niso_map = _iso_map\n\n\/\/ Section 3\n\n\/\/ Note: added the dst as an extra parameter; the spec does not really fully determine it.\n\n\/\/ random oracle encoding (hash_to_curve)\nhash_to_curve: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 2 * m <= 127 \/\/ Needed for expand_message, otherwise output too large\n               \/\/ , 2 * m * ((128+lg2 p)\/^ 8) <= 255 \/\/ output length of expand_message must be low enough\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384                ) =>\n               ([msg_len][8], [DST_len][8]) -> EC::AffinePoint t_F\nhash_to_curve (msg,dst) = P where\n    u = hash_to_field`{count=2} msg dst \/\/ spec does not mention the dst here\n    Q0 = map_to_curve_simple_swu_AB0 (u@0)\n    Q1 = map_to_curve_simple_swu_AB0 (u@1)\n    R = EC::add C Q0 Q1\n    P = clear_cofactor R\n\n\/\/ ... however, there is an alternative way of doing it, described in Section 6.6.3\n\/\/ where points are added before the isogeny is applied\n\nhash_to_curve_opt: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 2 * m <= 127 \/\/ Needed for expand_message, otherwise output too large\n               \/\/ , 2 * m * ((128+lg2 p)\/^ 8) <= 255 \/\/ output length of expand_message must be low enough\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384                ) =>\n               ([msg_len][8], [DST_len][8]) -> EC::AffinePoint t_F\nhash_to_curve_opt (msg,dst) = P where\n    u = hash_to_field`{count=2} msg dst \/\/ spec does not mention the dst here\n    Q0 = map_to_curve_simple_swu (u@0)     Q1 = map_to_curve_simple_swu (u@1)     R = EC::add Isogenous_Curve Q0 Q1\n    P = clear_cofactor (iso_map R)\n\n\n\/\/ 5.2\n\nhash_to_field: {msg_len, DST_len, count}\n               (fin msg_len, fin DST_len, fin count\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , count * m <= 127 \/\/ Needed for expand_message, otherwise output too large\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384                ) =>\n               [msg_len][8] -> [DST_len][8] -> [count]t_F\n\nhash_to_field msg DST = us where\n      type k = 128 \/\/ for BLS12-381\n      type L = ((lg2 p) + k) \/^ 8 \/\/ 64 for BLS12-381\n      uniform_bytes: [count * m * L][8]\n      uniform_bytes = expand_message msg DST\n      \/\/ The double loop in the Draft just splits pseduo_random_bytes into\n      \/\/ \"count\" parts, each part consisting of m sub_parts,\n      \/\/ each sub-part consisting of L bytes.\n      parts: [count][m][L][8]\n      parts = split (split uniform_bytes)\n            us = [ make_u_i part | part <- parts ]\n      make_u_i: [m][L][8] -> t_F\n      \/\/ \"drop\" here takes the 8*L-bit (i.e. 512-bit for BLS12-381) result and drops leading zeros to get to [384]\n      make_u_i part = base_to_F [to_Fp (drop`{back=384} ((join bytes) % `p)) | bytes <- part]\n\nhash_to_field_1: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384                ) =>\n               [msg_len][8] -> [DST_len][8] -> [384]\nhash_to_field_1 msg DST = us where\n      type L = 64\n      uniform_bytes: [L][8]\n      uniform_bytes = expand_message msg DST\n      us = drop`{back=384} ((join uniform_bytes) % `p)\n\n\/\/ 6.6.2 Simplified SWU\n\nmap_to_curve_simple_swu: t_F -> (t_F, t_F)\nmap_to_curve_simple_swu u = ret where\n    \/\/1. tv1 = inv0(Z^2 * u^4 + Z * u^2)\n    tv1 = inv0 (F.add (F.mul (F.sq Z, F.sq (F.sq u)),\n                       F.mul (Z, F.sq u)))\n    \/\/2. x1 = (-B \/ A) * (1 + tv1)\n    \/\/3. If tv1 == 0, set x1 = B \/ (Z * A)\n    x1 = if F_is_zero F (tv1)\n         then F.div (B', F.mul (Z, A'))\n         else F.mul (F.div (F.neg B', A'), F.add(F.field_unit, tv1))\n    \/\/ 4. gx1 = x1^3 + A * x1 + B\n    gx1 = F.add (cube x1, F.add (F.mul (A', x1), B'))\n    \/\/ 5. x2 = Z * u^2 * x1\n    x2 = F.mul (Z, F.mul (F.sq u, x1))\n    \/\/ 6. gx2 = x2^3 + A * x2 + B\n    gx2 = F.add (cube x2, F.add (F.mul (A', x2), B'))\n    \/\/ 7. If is_square(gx1), set x = x1 and y = sqrt(gx1)\n    \/\/ 8. Else set x = x2 and y = sqrt(gx2)\n    (x,y) = if is_square(gx1) then (x1, sqrt(gx1)) else (x2, sqrt(gx2))\n    \/\/ 9. If sgn0(u) != sgn0(y), set y = -y\n    \/\/ 10. return (x, y)\n    ret = if sgn0(u) != sgn0(y) then (x, F.neg y) else (x,y)\n\n    cube z = F.mul (z, F.sq z)\n\n\/\/ 6.6.3, Simplified SWU for AB=0\n\nmap_to_curve_simple_swu_AB0(u) = (x, y) where\n    (x', y') = map_to_curve_simple_swu (u) \/\/ (x', y') is on E'\n    (x, y) = iso_map(x', y')               \/\/ (x, y) is on E\n\nIsogenous_Curve: EC::EllipticCurve t_F\nIsogenous_Curve = {base_field=F, a = A', b = B'}\n```"}]}
{"filename":"BLST-Verification\/spec\/HashToCurveE1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the _iso_map function in the HashToCurveE1 module. The properties should check that _iso_map correctly maps points on the elliptic curve according to the given polynomial expressions and that it preserves the curve's group structure, including handling the point at infinity correctly."},{"role":"assistant","content":"```cryptol\n\/\/ hash_to_curve algorithm from draft-irtf-cfrg-hash-to-curve-09\n\nmodule HashToCurveE1 = HashToCurveGeneric where\n\n\/\/ NOTE: Our ExtensionField and Polynonial modules represents elements\n\/\/ of extension fields as polynomials, and those as lists of elements\n\/\/ of a base field in descending order by degree, so that [a,b,c]\n\/\/ represents ax^2 + bx+c.\n\/\/\n\/\/ Section 2.1 of the specification states that they are represented\n\/\/ \"in ascending order by degree\" so that [a,b,c] represents a+bx +\n\/\/ cx^2.  So we need reversals when transcribing the spec's defintions\n\/\/ into our Cryptol model, whenever lists of elements are used. These are\n\/\/ notes in the definitions belo0w\n\nimport Parameters as P\nimport FieldExtras\nimport ShortWeierstrassCurve as EC\nimport HashToCurveE1Aux as Aux\nimport BLSFieldExtras (sqrt_fp)\n\ntype _p = P::p type _q = P::p type _t_F = P::t_Fp _F = P::Fp type _m = 1 \/\/ extension degree\n_base_to_F [x] = x _C = P::E \/\/ {base_field = F, a = _F.field_zero, b = P::b}\n\n\/\/ dst = \"SPEC_IS_NOT_VERY_CLEAR\"\n\n\/\/ extra field operations\n\n_is_square x =  y == 0 \\\/ y == 1 where\n    y = F_expt`{n=width _q} _F x `((_q-1)\/2)\n\n_sqrt = sqrt_fp\n\n_sgn0 = Aux::sgn0\n\n_inv0 x = F_expt`{n=width _q} _F x `(_q-2) \/\/ but could be _F.div (_F.field_unit, x)\n\n\/\/ Constants from Section 8.8.1\n_Z = Aux::Z\n_A' = Aux::A'\n_B' = Aux::B'\n\n_clear_cofactor P = EC::mult _C Aux::h_eff P\n\n_iso_map: (_t_F, _t_F) -> (_t_F, _t_F)\n_iso_map (x', y') = if EC::is_point_O _C (x',y') then EC::point_O _C else (x, y) where\n    x_powers = [_F.field_unit] # [_F.mul(x', xi) | xi <- x_powers]\n    x_num = F_sum _F [_F.mul(ki, xi) | ki <- Aux::k1s | xi <- x_powers]\n    x_den = _F.add (x_powers@10, F_sum _F [_F.mul(ki, xi) | ki <- Aux::k2s | xi <- x_powers])\n    y_num = F_sum _F [_F.mul(ki, xi) | ki <- Aux::k3s | xi <- x_powers]\n    y_den = _F.add (x_powers@15, F_sum _F [_F.mul(ki, xi) | ki <- Aux::k4s | xi <- x_powers])\n    x = _F.div (x_num, x_den)\n    y = _F.mul (y', _F.div(y_num, y_den))\n```"}]}
{"filename":"BLST-Verification\/spec\/HashToCurveE2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the functions defined in the HashToCurveE2 module, including _sqrt, _sgn0, _inv0, _clear_cofactor, and _iso_map. Ensure the properties capture the expected mathematical behavior of these functions over the extension field and verify consistency with the elliptic curve group operations and field arithmetic as defined in the module."},{"role":"assistant","content":"```cryptol\nmodule HashToCurveE2 = HashToCurveGeneric where\n\n\/\/ NOTE: Our ExtensionField and Polynonial modules represents elements\n\/\/ of extension fields as polynomials, and those as lists of elements\n\/\/ of a base field in descending order by degree, so that [a,b,c]\n\/\/ represents ax^2 + bx+c.\n\/\/\n\/\/ Section 2.1 of the specification states that they are represented\n\/\/ \"in ascending order by degree\" so that [a,b,c] represents a+bx +\n\/\/ cx^2.  So we need reversals when transcribing the spec's defintions\n\/\/ into our Cryptol model, whenever lists of elements are used. These are\n\/\/ notes in the definitions belo0w\n\nimport Parameters as P\nimport FieldExtras\nimport ShortWeierstrassCurve as EC\nimport HashToCurveE2Aux as Aux\n\ntype _p = P::p type _q = P::p * P::p \/\/ cardinality, here p^2\ntype _t_F = P::t_Fp_2 _F = P::Fp_2 \/\/ the field structure, containing the operations\ntype _m = 2 \/\/ extension degree\n_base_to_F xs = reverse xs \/\/ Our polynomials are big-endian; the spec is little-endian\n\n_C = P::E' \/\/ {base_field = F, a = F.field_zero, b = P::b'}\n\n\/\/ From Section 4. Utility Functions\nCMOV (a,b,c) = if c==False then a else b\n\n\/\/ extra field operations\n\n_is_square x =  _F.is_equal (y, _F.field_zero) \\\/ _F.is_equal (y, _F.field_unit) where\n    y = F_expt`{n = width _q} _F x `((_q-1)\/2)\n\n\/\/ Alternative implementation from G.5\n\/\/ TODO\n\n\/\/ sqrt from Appendix G.3 (q = 9 mod 8)\n_sqrt x = z where\n    tv1 = F_expt`{n=width ((_q+7)\/16)} _F x `((_q+7)\/16)\n    tv2 = _F.mul (c1, tv1)\n    tv3 = _F.mul (c2, tv1)\n    tv4 = _F.mul (c3, tv1)\n    e1 =  _F.is_equal (_F.sq tv2, x)\n    e2 =  _F.is_equal (_F.sq tv3, x)\n\n    tv1_1 = CMOV (tv1, tv2, e1)\n    tv2_1 = CMOV (tv4, tv3, e2)\n    e3 = _F.is_equal (_F.sq tv2_1, x)\n    z = CMOV (tv1_1, tv2_1, e3)\n\n    \/\/ Need constants c1,c2,c3 with c1^2 = -1, c2^2 = c1, c3^3 = -c1\n    \/\/ As Fp_2 = Fp(u) with u^2 +1 = 0, c1 = u does the first\n    c1 = [1,0]\n    \/\/ Now pick a particular k (thanks to SageMath) so that 2 k^2 = -1 (mod p)\n    k: P::t_Fp\n    k = 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257\n    \/\/ Then (k(u+1))^2 = k^2(2u) = -u and\n    \/\/      (k(u-1))^2 = k^2(-2u) = u\n    c2 = [k, P::Fp.neg k] \/\/ k*(u-1)\n    c3 = [k, k] \/\/ k*(u+1)\n\n\/\/ sgn0 for m=2, from Section 4.1\n_sgn0 [x_1, x_0] =  sign_0 || (zero_0 && sign_1) where\n    \/\/ [x_1, x_0] because Section 2.1 asks for a little-endian order of elements\n    x_0' = P::from_Fp x_0\n    x_1' = P::from_Fp x_1\n    sign_0 = x_0'!0 \/\/ least-signifcant bit\n    zero_0 = x_0' == 0 \/\/ represent the Boolean as 0 or 1\n    sign_1 = x_1'!0\n\n_inv0 x = F_expt`{n=width (_q-2)} _F x `(_q-2) \/\/ but could be F.div (_F.field_unit, x)\n\n\/\/ Constants from Section 8.8.2\n_Z = _F.neg [1, 2] \/\/ -(2+I)\n\/\/ A' = [to_Fp 240, 0]: t_F \/\/ 240 * I\n_A' = Aux::to_Fp2 (0,240)\n\/\/B' = [to_Fp 1012, to_Fp 1012]: t_F  \/\/ 1012 * (1+I)\n_B' = Aux::to_Fp2 (1012,1012)\n\nh_eff = 0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551\n\n_clear_cofactor P = EC::mult _C h_eff P\n\n_iso_map: (_t_F, _t_F) -> (_t_F, _t_F)\n_iso_map (x', y') = if EC::is_point_O _C (x',y') then EC::point_O _C else (x, y) where\n    x_powers = [_F.field_unit] # [_F.mul(x', xi) | xi <- x_powers]\n    x_num = F_sum _F [_F.mul(ki, xi) | ki <- Aux::k1s | xi <- x_powers]\n    x_den = _F.add (x_powers@2, F_sum _F [_F.mul(ki, xi) | ki <- Aux::k2s | xi <- x_powers])\n    y_num = F_sum _F [_F.mul(ki, xi) | ki <- Aux::k3s | xi <- x_powers]\n    y_den = _F.add (x_powers@3, F_sum _F [_F.mul(ki, xi) | ki <- Aux::k4s | xi <- x_powers])\n    x = _F.div (x_num, x_den)\n    y = _F.mul (y', _F.div(y_num, y_den))\n```"}]}
{"filename":"BLST-Verification\/spec\/ProjectiveCurveOperations.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the elliptic curve point operations defined in the ProjectiveCurveOperations module. Specifically, specify properties that verify: (1) p_neg computes the correct negation of a projective point, (2) p_double correctly doubles a point on the curve, (3) p_add and p_add_generic correctly compute the sum of two points, including handling special cases like adding the zero point or identical points, (4) p_sub correctly computes the difference of two points, and (5) p_mult and p_mult_affine produce consistent scalar multiplication results. Include properties that check algebraic identities expected from elliptic curve group laws and consistency between affine and projective representations."},{"role":"assistant","content":"```cryptol\n\/\/ Optimized algorithms for curves in Weierstrass short form\n\/\/ over an arbitrary field.\n\/\/\n\/\/ These algorithms work in Jacobian projective coordinates.\n\/\/\n\/\/ Formulas come from https:\/\/hyperelliptic.org\/EFD\/g1p\/auto-shortw-jacobian.html,\n\/\/ selected from the many choices available there to best match the blst code.\n\nmodule ProjectiveCurveOperations  where\n\nimport Common::Field\nimport ShortWeierstrassCurve\nimport FieldExtras\n\nprivate\n\n  two: {t} FieldRep t -> t\n  two F = F.add (F.field_unit, F.field_unit)   three: {t} FieldRep t -> t\n  three F = F.add (two F, F.field_unit)\n\n  F_double: {t} FieldRep t -> t -> t\n  F_double F x = F.add (x, x)\n\n  F_by4 F x = F_double F (F_double F x)\n  F_by8 F x = F_double F (F_by4 F x)\n\n  cubed: {t} FieldRep t -> t -> t\n  cubed F x = F.mul(x, F.sq x)\n\np_point_O: {t} EllipticCurve t -> ProjectivePoint t\np_point_O C = (F.field_unit, F.field_unit, F.field_zero) where F = C.base_field\n\n\/**\n * The negative of a point in projective coordinates on a curve.\n *\/\np_neg: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t\np_neg C (x,y,z) = (x, C.base_field.neg y, z)\n\n\/**\n * p_double P is the sum P+P for P a point on the elliptic curve.\n *\/\np_double: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t\np_double C (X1,Y1,Z1) =\n    \/\/ Using the \"dbl-1998-cmo-2\" doubling formulas, three-operand code version\n    \/\/    if F_is_zero F Z1 then p_point_O C else (X3, Y3, Z3) where\n    (X3, Y3, Z3) where \n        F = C.base_field\n        XX = F.sq X1                    YY = F.sq Y1                    ZZ = F.sq Z1            \/\/ ZZ = Z1^2\n        t0 = F.mul (X1, YY)             S = F_by4 F t0                  t1 = F.sq ZZ                    t2 = F.mul (C.a, t1)            t3 = F.mul(three F, XX)         M = F.add(t3, t2)               t4 = F.sq M                     t5 = F_double F S               T = F.sub (t4, t5)      \/\/ T = t4-t5\n        X3 = T                  \/\/ X3 = T\n        t6 = F.sub (S, T)       \/\/ t6 = S-T\n        t7 = F.sq YY            \/\/ t7 = YY^2\n        t8 = F_by8 F t7         \/\/ t8 = 8*t7\n        t9 = F.mul (M, t6)      \/\/ t9 = M*t6\n        Y3 = F.sub (t9, t8)     \/\/ Y3 = t9-t8\n        t10 = F.mul (Y1, Z1)    \/\/ t10 = Y1*Z1\n        Z3 = F_double F t10         \n\n\/**\n * Sum of two distinct points in projective coordinates on the elliptic curve,\n * provided neither is the zero point.\n * If the two points are the same, returns (0,0,0)\n *\/\np_add_generic: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_add_generic C (X1,Y1,Z1) (X2,Y2,Z2) = (X3, Y3, Z3) where\n    F = C.base_field\n    \/\/ using the  \"add-1986-cc\" addition formula, three-operand code version\n    t0 = F.sq Z2              U1 = F.mul (X1, t0)       t1 = F.sq Z1              U2 = F.mul (X2, t1)       t2 = F.mul (Z2, t0)       S1 = F.mul (Y1, t2)       t3 = F.mul (Z1, t1)   \/\/ t3 = Z1^3\n    S2 = F.mul (Y2, t3)   \/\/ S2 = Y2*t3\n    P = F.sub (U2, U1)    \/\/ P = U2-U1\n    R = F.sub (S2, S1)    \/\/ R = S2-S1\n    t4 = F.add (U1, U2)   \/\/ t4 = U1+U2\n    t5 = F.sq R           \/\/ t5 = R^2\n    t6 = F.sq P           \/\/ t6 = P^2\n    t7 = F.mul (t4, t6)   \/\/ t7 = t4*t6\n    X3 = F.sub (t5, t7)       t8 = F.sq P           \/\/ t8 = P^2 -- redundant, t6 already holds p^2\n    t9 = F.mul (U1, t8)       t10 = F.sub (t9, X3)      t11 = F.mul (P, t8)       t12 = F.mul (S1, t11)     t13 = F.mul (R, t10)      Y3 = F.sub (t13, t12)     t14 = F.mul (Z2, P)   \/\/ t14 = Z2*P\n    Z3 = F.mul (Z1, t14)  \/\/ Z3 = Z1*t14\n\n\n\/**\n * Sum of two points in projective coordinates on the elliptic curve.\n *\/\np_add: {t} EllipticCurve t ->  ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_add C S T = \n    if F_is_zero F Z1 then T\n     | F_is_zero F Z2 then S\n     | all (F_is_zero F) [X3,Y3,Z3] then p_double C S      else R\n    where\n        F = C.base_field\n        (_,_,Z1) = S\n        (_,_,Z2) = T\n        R = p_add_generic C S T\n        (X3,Y3,Z3) = R\n\n\/**\n * Difference of two points in projective coordinates on the elliptic curve.\n *\/\np_sub: {t} EllipticCurve t ->  ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_sub C S T = p_add C S (p_neg C T)\n\n\/**\n * Integer multiple of a point in projective coordinates on the elliptic curve.\n * The multiplier, a bitvector, is interpreted as a non-negative integer.\n *\/\np_mult: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> ProjectivePoint t -> ProjectivePoint t\np_mult C d S = if d == 0 then p_point_O C\n               |  d == 1 then S\n               |  F_is_zero F S.2 then p_point_O C\n               else Rs!1\n    where\n        F = C.base_field\n        k = 0b00 # d \/\/ 2 extra top bits, so that h does not overflow\n        h = k + k + k\n        Rs = [p_point_O C] # \/\/Here we start with 1 instead of S because we don't really know where the high-bit is\n             [ if hi && ~ki then p_add C RiDouble S\n                | ~hi && ki then p_sub C RiDouble S\n                else RiDouble\n               where RiDouble = p_double C Ri\n             | ki <- k | hi <- h | Ri <- Rs ]\n\n\/**\n * Integer multiple of a point in affine coordinates  on the elliptic curve.\n * The multiplier, a bitvector, is interpreted as a non-negative integer.\n * This definition uses projective operations internally, but should give\n * the same result as `mult`.\n *\/\np_mult_affine: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> AffinePoint t -> AffinePoint t\np_mult_affine C d S = affinify C (p_mult C d (projectify C S))\n```"}]}
{"filename":"BLST-Verification\/spec\/ShortWeierstrassCurve.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the elliptic curve group operations defined in ShortWeierstrassCurve.cry. Specifically, specify properties that check: (1) the point at infinity acts as the additive identity for addition; (2) addition is commutative and associative for points on the curve; (3) the negation function produces the additive inverse; (4) doubling a point is equivalent to adding the point to itself; and (5) scalar multiplication corresponds to repeated addition. Include checks that all points involved satisfy the curve equation and that the equality predicates correctly identify equivalent points."},{"role":"assistant","content":"```cryptol\n\/\/ Curves in Weierstrass short form, over an arbitrary field\n\/\/\n\/\/ That is, the curve equation is y^2 = x^3 + ax + b for some a, b in the field.\n\/\/\n\/\/ We use affine coordinates, and describe Jacobian projective coordiates.\n\/\/ Points are represented as tuples, corresponding to normal math notation.\n\/\/\n\/\/ We represent the point at infinity by the affine coordinates (0,0), which is fine so long as\n\/\/ b is not 0.  This is the case for all curves of interest in this project.\n\/\/\n\/\/ The curve operations are in no way optimized; we are only interested in getting the\n\/\/ mathematically correct answer here.\n\nmodule ShortWeierstrassCurve where\n\nimport Common::Field\n\ntype EllipticCurve t =\n  { base_field: FieldRep t\n  , a: t\n  , b: t\n  } type AffinePoint rep = (rep, rep) type ProjectivePoint rep = (rep, rep, rep) \/**\n * The \"point at infinity\" on an elliptic curve; the zero for point addition.\n * That's the letter \"O\" in the name, not the digit \"0\".\n *\/\npoint_O: {t} EllipticCurve t ->  AffinePoint t\npoint_O C = (F.field_zero, F.field_zero) where F = C.base_field\n\n\/**\n * Is a point the point at infinity for a given curve?\n *\/\nis_point_O: {t} EllipticCurve t ->  AffinePoint t -> Bool\nis_point_O C S = same_point_affine C S (point_O C)\n\n\/**\n * The Jacobian projective coordinates of a point in affine coordinates.\n *\/\nprojectify: {t} EllipticCurve t -> AffinePoint t -> ProjectivePoint t\nprojectify C (x,y) = (x, y, C.base_field.field_unit)\n\n\/**\n * The affine coordinates of a point in Jacobian projective coordinates.\n *\/\naffinify: {t} EllipticCurve t -> ProjectivePoint t -> AffinePoint t\naffinify C (x,y,z) = if is_zero F z\n                     then point_O C\n                     else (F.mul(lambda2, x), F.mul(lambda3, y))\n    where\n        F = C.base_field\n        lambda = F.div (F.field_unit, z)\n        lambda2 = F.sq lambda\n        lambda3 = F.mul(lambda, lambda2)\n\nprivate\n    cubed: {t} FieldRep t -> t -> t\n    cubed F x = F.mul (x, F.sq x)\n\n    fourth: {t} FieldRep t -> t -> t\n    fourth F x = F.sq (F.sq x)\n\n    sixth: {t} FieldRep t -> t -> t\n    sixth F x = F.sq (cubed F x)\n\n    is_zero: {t} FieldRep t -> t -> Bit\n    is_zero F x = F.is_equal (x, F.field_zero)\n\n        twice: {t} FieldRep t -> t -> t\n    twice F x = F.add (x, x)\n\n    thrice: {t} FieldRep t -> t -> t\n    thrice F x = F.add (x, twice F x)\n  \n\/**\n * Determine whether two projective points are different representations of\n * the same point on the curve.\n *\/\nsame_point: {t} EllipticCurve t -> ProjectivePoint t ->  ProjectivePoint t -> Bool\nsame_point C (x,y,z) (x',y',z')  =\n    F.is_equal (F.mul (x, F.sq z'), F.mul (x', F.sq z)) \/\\\n    F.is_equal (F.mul (y, cubed F z'), F.mul (y', cubed F z))\n    where F = C.base_field\n\n\/**\n * Are two affine points on a curve equal?\n *\/\nsame_point_affine:  {t} EllipticCurve t -> AffinePoint t ->  AffinePoint t -> Bool\nsame_point_affine C (x,y) (x',y') = F.is_equal (x, x') \/\\ F.is_equal (y, y')\n    where F = C.base_field\n\n\/**\n * Is a given point in affine coordinates on a given curve?\n *\/\nis_point_affine: {t} EllipticCurve t -> AffinePoint t -> Bit\nis_point_affine C S = is_point_O C S \\\/\n                      (F.is_val x \/\\ F.is_val y \/\\\n                       F.is_equal(F.sq y, F.add(cubed F x, F.add (F.mul (C.a, x), C.b))))\n    where F = C.base_field\n          (x,y) = S\n\n\/**\n * Is a given point in Jacobian projective coordinates on a given curve?\n *\/\nis_point_projective : {t} EllipticCurve t -> ProjectivePoint t -> Bit\nis_point_projective C (x,y,z) = F.is_val x \/\\ F.is_val y \/\\ F.is_val z \/\\ F.is_equal(F.sq y, t)\n    where t = F.add(cubed F x, F.add (F.mul (F.mul (C.a, x), fourth F z), F.mul (C.b, sixth F z)))\n          F = C.base_field\n\n\n\/\/ Group operations on the curve, using affine coordinates\n\n\/**\n * The negative of a point in affine coordinates on a curve.\n *\/\nneg: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t\nneg C (x,y) = (x, C.base_field.neg y)\n\ndouble: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t\ndouble C P = if is_point_O C P then P\n             | is_zero C.base_field P.1 then point_O C              else double_non_O C P\n\nprivate\n    double_non_O: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t\n    double_non_O C (x1,y1) = (x3,y3) where\n        F = C.base_field\n        \/\/ x3 = (3*x1^2+a)^2\/(2*y1)^2-x1-x1\n        x3 = F.sub (F.sq R0, twice F x1)\n        \/\/y3 = (2*x1+x1)*(3*x1^2+a)\/(2*y1)-(3*x1^2+a)^33\/(2*y1)^3-y1\n        \/\/ y3 = F.sub (F.sub (R1, R2), y1)\n        \/\/ alt formula (Wiki)\n        y3 = F.sub (F.mul (R0, F.sub(x1,x3)), y1)\n        R0 = F.div (F.add (thrice F (F.sq x1), C.a), twice F y1) \/\/ (3*x1^2+a)\/(2*y1)\n        R1 = F.mul (thrice F x1, R2)\n        R2 = cubed F R0\n\n\/**\n * The sum of two points in affine coordinates on a curve.\n * This can give meaningless results if the given points are not in fact\n * on the curve.\n *\/\nadd: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\nadd C P Q = if same_point_affine C P (point_O C) then Q\n            |  same_point_affine C Q (point_O C) then P\n            |  same_point_affine C P (neg C Q) then point_O C\n            |  same_point_affine C P Q then double C P\n            else raw_add C P Q \n\nprivate\n  raw_add: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\n  raw_add C (x1,y1) (x2,y2) = (x3,y3) where\n    F = C.base_field\n    \/\/ x3 = (y2-y1)^2\/(x2-x1)^2-x1-x2\n    x3 = F.sub (F.sub (F.sq R0, x1), x2)\n    \/\/ y3 = (2*x1+x2)*(y2-y1)\/(x2-x1)-(y2-y1)^3\/(x2-x1)^3-y1\n    y3 = F.sub (F.sub (R1, R2), y1)\n    R0 = F.div (F.sub (y2, y1), F.sub (x2, x1)) \/\/ (y2-y1)\/(x2-x1)\n    R1 = F.mul (F.add (twice F x1, x2), R0)\n    R2 = cubed F R0\n\n\n\/**\n * The difference of two points in affine coordinates on a curve.\n * This can give meaningless results if the given points are not in fact\n *  on the curve.\n *\/\nsub: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\nsub C P Q = add C P (neg C Q)\n\n\/**\n * Integer multiple of a point on the elliptic curve.  The multiplier,\n * a bitvector, is interpreted as a non-negative integer.\n *\/ \nmult: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> AffinePoint t -> AffinePoint t\nmult C d S = if d == 0 then point_O C\n             | d == 1 then S\n             | same_point_affine C S (point_O C) then point_O C\n             else Rs!1\n  where k = 0b00 # d \/\/ 2 extra top bits, so h does not overflow (e.g. for d=0b11)\n        h = k + k + k\n        Rs = [point_O C] # \/\/ start with 1 instead of S; we don't really know where the high-bit is\n             [ if hi && ~ki then add C RiDouble S\n                | ~hi && ki then sub C RiDouble S\n                else RiDouble\n               where RiDouble = double C Ri\n             | ki <- k\n             | hi <- h\n             | Ri <- Rs ]\n\n\/\/ Scalar multiplication with an Integer exponent\nscalar_mult: {t} EllipticCurve t -> Integer -> AffinePoint t -> AffinePoint t\nscalar_mult C k P = if k < 0 then scalar_mult C (-k) (neg C P)\n                     else if k == 0 then point_O C\n                     else add C P (scalar_mult C (k-1) P)\n```"}]}
{"filename":"BLST-Verification\/spec\/G2SubGroupCheck.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines and verifies the correctness of the `psi_projective` endomorphism and the subgroup check for G2 as implemented in the `G2SubGroupCheck` module. The specification should include properties that ensure the mappings between projective pairs, Jacobian points, and affine points are consistent and that the `psi` function behaves as expected according to the mathematical definitions from the BLS12-381 curve and the referenced draft-irtf-cfrg-hash-to-curve-09 document. Include verification conditions to prove that the subgroup check correctly identifies points in the G2 subgroup."},{"role":"assistant","content":"```cryptol\nmodule G2SubGroupCheck where\n\nimport Parameters (p, Fp_2, t_Fp_2, E', BP', r)\nimport Frobenius\nimport Pairing (alpha) \/\/ alpha is 1\/(u+1) = (1-u)\/2\nimport FieldExtras\nimport ShortWeierstrassCurve\n\n\n\/**\n * A \"projective_pair\" `(xn, xd, yn, yd)` represents the affine point (xn\/xd, yn\/yd)\n *\/\ntype projective_pair_fp2 = (t_Fp_2, t_Fp_2, t_Fp_2, t_Fp_2)\n\n\/**\n *  Endomorphism \"psi\" from Appendix E.4 of draft-irtf-cfrg-hash-to-curve-09\n *\/\npsi_projective: projective_pair_fp2 -> projective_pair_fp2\npsi_projective (xn, xd, yn, yd) = (qxn, qxd, qyn, qyd) where\n    qxn = Fp_2.mul (psi_c1, fp2_frobenius xn)\n    qxd = fp2_frobenius xd\n    qyn = Fp_2.mul (psi_c2, fp2_frobenius yn)\n    qyd = fp2_frobenius yd\n\npsi_c1: t_Fp_2\npsi_c1 = F_expt`{n=384} Fp_2 alpha ((`p-1)\/3)\n\/\/ == [to_Fp 0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad,\n\/\/     0], so also a multiple of u\n\npsi_c2: t_Fp_2\npsi_c2 = F_expt`{n=384} Fp_2 alpha ((`p-1)\/2)\n\/\/ AppendexE.1 describes the mapping from projective_pairs to Jacobian projective coordinate\n\nprojective_pair_to_jacobian: projective_pair_fp2 -> ProjectivePoint t_Fp_2\nprojective_pair_to_jacobian (xn, xd, yn, yd) = (X', Y', Z') where\n    X' = Fp_2.mul (xn, Fp_2.mul (xd, Fp_2.sq yd))\n    Y' = Fp_2.mul (yn, Fp_2.mul (Fp_2.sq yd, Fp_2.mul (xd, Fp_2.sq xd)))\n    Z' = Fp_2.mul (xd, yd)\n\njacobian_to_projective_pair: ProjectivePoint t_Fp_2 -> projective_pair_fp2\njacobian_to_projective_pair (X ,Y, Z) = (X, xd, Y, yd) where\n    xd = Fp_2.sq Z \/\/ Z^2\n    yd = Fp_2.mul (Z, xd) \/\/Z^3\n\n\/\/ and also the mapping to affine\n\nprojective_pair_to_affine: projective_pair_fp2 -> AffinePoint t_Fp_2\nprojective_pair_to_affine (xn, xd, yn, yd) = (X', Y') where\n    X' = Fp_2.div  (xn, xd)\n    Y' = Fp_2.div (yn, yd)\n\naffine_to_projective_pair: AffinePoint t_Fp_2 -> projective_pair_fp2\naffine_to_projective_pair (x, y) = (x,Fp_2.field_unit, y, Fp_2.field_unit)\n\n\/\/ We can derive the effect of psi in affine coordinates\n\npsi: AffinePoint t_Fp_2 -> AffinePoint t_Fp_2\npsi (x, y) = (qxn, qyn) where\n    qxn = Fp_2.mul (psi_c1, fp2_frobenius x)\n    qyn = Fp_2.mul (psi_c2, fp2_frobenius y)\n\n\/\/ The subgroup check for G2, from Bowe \"Faster Subgroup Checks for BLS12-381\"\n```"}]}
{"filename":"BLST-Verification\/spec\/ExpandMessage.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the expand_message_xmd function in the ExpandMessage module, ensuring it conforms to the XMD expand_message operation as defined in the relevant RFC. Include checks for correct output length, proper handling of input constraints, and the correctness of intermediate values like b_0 and b_1 with respect to the SHA-256 hash function."},{"role":"assistant","content":"```cryptol\nmodule ExpandMessage where\n\nimport rfc8017 (I2OSP, OS2IP)\nimport Primitive::Keyless::Hash::SHA256 as SHA256\n\nprivate\n    \/\/ From Section 4. Utility Functions\n\n    \/\/ For byte strings str1 and str2, strxor(str1, str2) returns the bitwise XOR of the two strings.\n    strxor: {k} ([k][8],[k][8]) -> [k][8]\n    strxor (s1, s2) = s1^s2\n\nprivate\n    \/\/ The Draft uses hash function H taking byte strings and outputting byte strings.\n    \/\/ we therefore need some glue around SHA_256, which takes and returns bit strings.\n\n    \/\/ \"Hashable n\" holds if [n][8] is an acceptable argument for H\n    type constraint Hashable n = (61 >= width n)\n\n    H: {n} (Hashable n) => [n][8] -> [32][8]\n    H x = split (SHA256::sha (join x))\n\n\nexpand_message = expand_message_xmd \/\/ as per the chosen suites\n\/\/ Due to the internal calls to H (SHA-256), there is a length limit on the inputs\n\/\/ to this function.  In particular, for computing b_0 we give an argument of length\n\/\/ r_in_bytes + len_message + 2 + 1 + 1 + len_DST = 68 + len_message + len_DST\n\/\/\n\/\/ In Cryptol this is a type-checked condition rather than the \"abort if\" run-time check\n\/\/ in the Draft.\n\ntype constraint Expandable len_message len_DST  =  (61 >= width (69 + len_message + len_DST))\n\nexpand_message_xmd: {len_message, len_DST, len_in_bytes}\n                (fin len_message\n                , fin len_DST\n                , len_DST <= 255\n                , fin len_in_bytes\n                , len_in_bytes \/^ 32 <= 255\n                , Expandable len_message len_DST\n                ) => [len_message][8] -> [len_DST][8] -> [len_in_bytes][8]\nexpand_message_xmd msg DST = take uniform_bytes where\n    \/\/type b = 256                  \/\/ output length of SHA-256, in bits\n    \/\/type b_in_bytes = b \/^ 8      \/\/ = 32\n    type r_in_bytes = 64            \/\/ input block size of SHA-256\n    \/\/ type ell = len_in_bytes \/^ b_in_bytes\n    \/\/ abort if ell > 255           \/\/ this is computed in the type constraint\n    DST_prime = DST # (I2OSP`{xLen=1} (`len_DST))     Z_pad = I2OSP`{xLen=r_in_bytes} (0)\n    l_i_b_str = I2OSP`{xLen=2} (`len_in_bytes)\n    msg' = Z_pad # msg # l_i_b_str # (I2OSP`{1} 0) # DST_prime\n    b_0 = H (msg')\n    b_1 = H (b_0 # (I2OSP`{xLen=1} 1) # DST_prime)\n    bs = [b_1] # [H(strxor(b_0, b_prev) # (I2OSP`{xLen=1} i) # DST_prime) | b_prev <- bs | i:[8] <- [2...]]\n    uniform_bytes = join bs\n\nexpand_b0: {len_message, len_DST, len_in_bytes}\n                (fin len_message\n                , fin len_DST\n                , len_DST <= 255\n                , fin len_in_bytes\n                , len_in_bytes \/^ 32 <= 255\n                , Expandable len_message len_DST\n                ) => ([len_message][8], [len_DST][8]) -> [32][8]\nexpand_b0 (msg, DST) = b_0 where\n    type r_in_bytes = 64            \/\/ input block size of SHA-256\n    DST_prime = DST # (I2OSP`{xLen=1} (`len_DST)) # [0x80]\n    Z_pad = I2OSP`{xLen=r_in_bytes} (0)\n    l_i_b_str = I2OSP`{xLen=2} (`len_in_bytes)\n    b_0 = H (Z_pad # msg # l_i_b_str # (I2OSP`{1} 0) # DST_prime)\n```"}]}
{"filename":"BLST-Verification\/spec\/Serialization.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the serialization and deserialization functions for points on curves E and E' are inverses of each other. Specifically, specify that for any valid affine point P, deserializing the serialized form of P returns P (or the point at infinity when appropriate), and that serialization of a deserialized byte string (when successful) returns the original byte string. Include properties for both serialize_E1\/deserialize_E1 and serialize_E2\/deserialize_E2 functions, ensuring correctness of compression and decompression according to the draft-irtf-cfrg-pairing-friendly-curves-07 specification."},{"role":"assistant","content":"```cryptol\n\/\/ Point serialization, from draft-irtf-cfrg-pairing-friendly-curves-07\n\/\/ Appendix C\n\/\/\nmodule Serialization where\n\nimport Parameters (p, E, E', t_Fp, to_Fp, t_Fp_2, Fp, Fp_2)\nimport ShortWeierstrassCurve as EC\nimport rfc8017\nimport Maybe\nimport FieldExtras (F_expt)\nimport BLSFieldExtras (sqrt_fp, is_square_fp, sqrt_fp2, is_square_fp2)\n\n\/\/\/\/ Serialization (with compression)\n\nsign_F_p: t_Fp -> Bit\nsign_F_p y = y > `((p - 1)\/2)\n\nsign_F_p_2: t_Fp_2 -> Bit\nsign_F_p_2(y') = if y'_1 == 0 then sign_F_p(y'_0) else y'_1 > `((p - 1)\/2) where\n    [y'_1, y'_0] = y'\n\nmetadata_bits_E1:  EC::AffinePoint t_Fp -> [3]\nmetadata_bits_E1 P = [C_bit, I_bit, S_bit] where\n    C_bit = True\n    I_bit = EC::is_point_O E P\n    S_bit = if I_bit then False else sign_F_p y where (_,y) = P\n\nm_byte_E1: EC::AffinePoint t_Fp -> [8]\nm_byte_E1 P = (metadata_bits_E1 P) # zero\n\nx_string_E1: EC::AffinePoint t_Fp -> [48][8]\nx_string_E1 P = if EC::is_point_O E P\n                then I2OSP(0)\n                else I2OSP(x) where (x,_) = P\n\n\/\/ See the note about the order of the x_i below, in deserialize_E2\nx_string_E2: EC::AffinePoint t_Fp_2 -> [96][8]\nx_string_E2 P = if EC::is_point_O E' P\n                then I2OSP(0)\n                else I2OSP`{xLen=48}(x_1) # I2OSP(x_0) where ([x_1, x_0],_) = P\n\nserialize_E1: EC::AffinePoint t_Fp -> [48][8]\nserialize_E1 P = x_string_E1 P || ([m_byte_E1 P]# zero)\n\nserialize_E2: EC::AffinePoint t_Fp_2 -> [96][8]\nserialize_E2 P = x_string_E2 P || ([m_byte]# zero) where\n    C_bit = True\n    I_bit = EC::is_point_O E' P\n    S_bit = if I_bit then False else sign_F_p_2 y where (_,y) = P\n    m_byte = [C_bit, I_bit, S_bit] # zero\n\n\/\/\/\/ Deserialization\n\/\/ Strictly speaking, we should be able to deserialize an uncompressed representation,\n\/\/ but the suites we look at all use compression.\n\n\/\/ TODO: we need [96][8] because if the infinity bit is set, we must check all 96 bytes (except first 3 bits) are zero. We could also have a separate uncompress function.\n\/\/ the C code can take a 96 bytes array whose last 48 are unintialized\n\/\/ we deviate from the RFC: the RFC says \"if the string has length...\", but in the C code there's no concept of length of the string\n\ndeserialize_E1: [96][8] -> Maybe (EC::AffinePoint t_Fp)\ndeserialize_E1 s_string = ret where\n    \/\/ Step 1.\n    m_byte = (s_string@0) && 0xE0 \/\/ three highest bits\n    C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n    \/\/ Step 2 deferred (we check that C_bit is 1 later)\n    \/\/ Step 3\n    s_string' = take`{front=48} ([(s_string@0) && 0x1F] # tail s_string) \/\/ the last 48 bytes may be uninitialized for a compressed point. TODO should we assume they're zero? doesn't seem to make sense (extra work for the caller)\n    \/\/ Step 6\n    x = OS2IP(s_string')\n    \/\/Step 7 (on curve E)\n    y2 = Fp.add (Fp.mul (x, Fp.sq x), 4)\n    y = sqrt_fp y2\n    Y_bit = sign_F_p y\n    \/\/ Steps 2, 4, 8\n    ret = if C_bit == False then nothing \/\/ Error, from Step 2; TODO what if I_bit is set? We could still return inf\n           | I_bit then (if s_string' == zero then just (EC::point_O E) else nothing) \/\/ Step 4\n           | ~ (is_square_fp y2) then nothing \/\/ from Step 7\n           | S_bit == Y_bit then just (x,y)\n          else just (x, Fp.neg y)\n\n\/\/ draft-irtf-cfrg-bls-signature-04 specifies that the compressed representation is used for BLST\nuncompress_E1: [48][8] -> Maybe (EC::AffinePoint t_Fp)\nuncompress_E1 s_string = ret where\n    \/\/ Step 1.\n    m_byte = (s_string@0) && 0xE0 \/\/ three highest bits\n    C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n    \/\/ Step 2 deferred (we check that C_bit is 1 later)\n    \/\/ Step 3\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    \/\/ Step 6\n    x = OS2IP(s_string')\n    \/\/ TODO here the C implementation checks that x is smaller than the modulus\n    \/\/Step 7 (on curve E)\n    y2 = Fp.add (Fp.mul (x, Fp.sq x), 4)\n    y = sqrt_fp y2\n    Y_bit = sign_F_p y\n    \/\/ Steps 2, 4, 8\n    ret = if (m_byte == 0x20 ) || (m_byte == 0x60) || (m_byte == 0xE0) then nothing\n           | C_bit == False then nothing \/\/ Error, from Step 2\n           | I_bit then (if s_string' == zero then just (EC::point_O E) else nothing) \/\/ Step 4\n           | ~ (is_square_fp y2) then nothing \/\/ from Step 7\n           | S_bit == Y_bit then just (x,y)\n          else just (x, Fp.neg y)\n\ndeserialize_E2: [96][8] -> Maybe (EC::AffinePoint t_Fp_2)\ndeserialize_E2 s_string = ret where\n    \/\/ Step 1.\n    m_byte = (s_string@0) && 0xE0\n    C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n    \/\/ Step 2 deferred (we check that C_bit is 1 later)\n    \/\/ Step 3\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    \/\/ Step 6\n    \/\/ Section 2.5 of draft-irtf-cfrg-pairing-friendly-curves-07 suggests this should be:\n    \/\/     x = map to_Fp (reverse (split`{parts=2} (OS2IP`{a=[2*384]}(s_string'))))\n    \/\/ HOWEVER, the  cited ZCash scheme, and personal communications from R Wahby disagree:\n    \/\/ we do not reverse the order of the parts.  So:\n    x = map to_Fp (split`{parts=2} (OS2IP`{a=[2*384]}(s_string')))\n    \/\/Step 7 (on curve E')\n    y2 = Fp_2.add (Fp_2.mul (x, Fp_2.sq x), [4,4])     y = sqrt_fp2 y2\n    Y_bit = sign_F_p_2 y\n    \/\/ Steps 2, 4, 8\n    ret = if m_byte == 0x20 \\\/ m_byte == 0x60 \\\/ m_byte == 0xE0 then nothing \/\/ Error, from Step 1\n           | C_bit == False then nothing \/\/ Error, from Step 2\n           | I_bit then (if s_string' == zero then just (EC::point_O E') else nothing) \/\/ Step 4\n           | ~ (is_square_fp2 y2) then nothing \/\/ from Step 7\n           | S_bit == Y_bit then just (x,y)\n          else just (x, Fp_2.neg y)\n```"}]}
{"filename":"BLST-Verification\/spec\/KeyGen.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the KeyGen and KeyGen_r2 functions in the KeyGen module. The properties should ensure that the generated secret keys (SK) satisfy expected cryptographic constraints, such as length, non-zero values, and consistency with the HKDF extraction and expansion steps. Include checks for the iterative behavior of KeyGenLoop and equivalence between KeyGen and KeyGen_r2 outputs under appropriate conditions."},{"role":"assistant","content":"```cryptol\nmodule KeyGen where\n\n\/\/ 2.3 KeyGen\n\nimport Parameters as P\nimport Primitive::Keyless::Hash::SHA256\nimport Primitive::Symmetric::KDF::HKDF256\nimport rfc8017\n\n\/**\n * KeyGen from draft-02\n *\/\nKeyGen_r2: {IKM_len, info_len} ( IKM_len >= 32\n                               , validHMACSizes 20 (1+IKM_len)\n                               , validHMACSizes 32 (35+info_len)\n                               ) =>\n        ([IKM_len][8], [info_len][8]) -> [256]\nKeyGen_r2 (IKM, key_info) = SK where\n    type L = (3 * 256) \/^ 16 \/\/ (ceil lg2 r) = 256, so L = 3*16=48\n    PRK = HKDF_Extract \"BLS-SIG-KEYGEN-SALT-\" (IKM # [0]) \/\/ [0] is I2OSP`{xLen=1} 0)\n    OKM = HKDF_Expand`{L=L} PRK (key_info # I2OSP`{xLen=2} `L)\n    SK = drop ((OS2IP`{a=[384]} OKM) % (zext P::r))\n\n\/**\n * KeyGen from draft-04\n *\/\nKeyGen: {IKM_len, info_len} ( validHMACSizes 20 (1+IKM_len)\n                            , validHMACSizes 32 (35+info_len)\n                            ) =>\n        ([IKM_len][8], [info_len][8]) -> [256]\n\/\/ artificial cutoff at 4 iterations, to avoid an unbounded loop\nKeyGen (IKM, key_info) = (KeyGenLoop (sha (join \"BLS-SIG-KEYGEN-SALT-\")) IKM key_info) @ 4\n\nKeyGenLoop salt IKM info = keys where\n  salts = [salt] # [sha salt' | salt' <- salts]\n  keys = [zero] #\n         \/\/ hang on to a nonzero key, try again with revised salt otherwise\n         [if k == zero then key_gen_step salt' else k | k <- keys | salt' <- salts]\n  key_gen_step s = KeyGenStep s IKM info\n\nKeyGenStep:  {IKM_len, info_len} (\n                              validHMACSizes 20 (1+IKM_len)\n                            , validHMACSizes 32 (35+info_len)\n                            ) =>\n        [256] -> [IKM_len][8] ->[info_len][8] -> [256]\nKeyGenStep salt IKM key_info = SK where\n    type L = (3 * 256) \/^ 16 \/\/ (ceil lg2 r) = 256, so L = 3*16=48\n    PRK = HKDF_Extract (split salt) (IKM # [0]) \/\/ I2OSP`{xLen=1} 0)\n    OKM = HKDF_Expand`{L=L} PRK (key_info # I2OSP`{xLen=2} `L)\n    SK = drop ((OS2IP`{a=[384]} OKM) % (zext P::r))\n```"}]}
{"filename":"BLST-Verification\/spec\/rfc8017.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the functions I2OSP and OS2IP are inverses of each other for all valid inputs, ensuring that converting an integer to octet string and back yields the original integer, as specified in RFC 8017 Section 4."},{"role":"assistant","content":"```cryptol\nmodule rfc8017 where\n\/\/ Some definitions from RFC 8107 (PKCS #1), November 2016\n\/\/ \n\n\/\/ Section 4. Data Conversion Primitives\n\/\/\n\/\/ The intent is to convert to and from \"Integers\".  For Cryptol,\n\/\/ we make them work with any integer-like type.\n\n\/\/ The bytes are assembled in big-endian order.\n\n\/*\n * I2OSP`{xLen=y} x corresponds to the RFC's notation \"I2OSP(x, y)\"\n *\/\nI2OSP: {xLen, a} (fin xLen, Integral a) => a -> [xLen][8]\nI2OSP x = split (fromInteger (toInteger x))\n\n\/\/ TODO: it may be dangerous to let type \"a\" be inferred; sometimes\n\/\/ Cryptol infers [n] for n < xLen*8, which then ignores high-order bits.\n\nOS2IP: {xLen, a} (fin xLen, Ring a) => [xLen][8] -> a\nOS2IP x = fromInteger (toInteger (join x))\n```"}]}
{"filename":"BLST-Verification\/spec\/Pairing.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the `bls_ate_pairing` function in the `Pairing` module. The properties should check that the pairing satisfies bilinearity, non-degeneracy, and is well-defined over the input elliptic curve points. Additionally, specify properties to verify the correctness of the `final_exponentiation` function and its use of Frobenius mappings as described in the comments."},{"role":"assistant","content":"```cryptol\n\/\/ Pairing for tyhe BLS curves, from draft-irtf-cfrg-pairing-friendly-curves-07\n\nmodule Pairing where\n\nimport Parameters as P\nimport ShortWeierstrassCurve as EC\nimport FieldExtras\nimport Frobenius\n\n\/**\n * The curve E: y^2 = x^3 + 4, over F_p^12\n *\/\nc12: EC::EllipticCurve t12\nc12 = { base_field = P::Fp_12, a = P::Fp_12.field_zero, b = P::Fp_to_Fp_12 P::b }\n\n\/**\n * Take a point on E\/F_p to a point on E\/F_p^12\n * This just applies the field injection to the coordinates\n *\/\nphi_1: EC::AffinePoint t1 -> EC::AffinePoint t12\nphi_1 (x,y) = (P::Fp_to_Fp_12 x, P::Fp_to_Fp_12 y)\n\n\/\/ alpha = (1-u)\/2.  This constant is needed in the sextic twist in function `phi_2`\nalpha: t2\nalpha = f2.half (f2.sub (f2.field_unit, P::u))\n\n\/\/ Note: the layout of f12 over f2 is\n\/\/ [[a,c,e],[b,d,f]] represents a*w^5 + b*w^4 + c*w^3 + d*w^2 + e*w + f \n\n\/**\n *  w4_times x = x*w^3\n *\/\nw3_times: t2 -> t12\nw3_times x = [[z,x,z],[z,z,z]] where z = f2.field_zero\n\n\/**\n *  w4_times x = x * w^4\n *\/\nw4_times: t2 -> t12\nw4_times x = [[z,z,z],[x,z,z]] where z = f2.field_zero\n\n\/**\n * Take a point on E'\/F_p^2 to a point on E\/F_p^12\n * This applies a sextic twist\n *\/\nphi_2: EC::AffinePoint t2 -> EC::AffinePoint t12\nphi_2 (x,y) = (x',y') where\n    x' = w4_times (f2.mul (x, alpha))\n    y' = w3_times (f2.mul (y, alpha))\n\n\/\/ The line_function\n\nprivate\n    twice x = f12.add (x,x)\n    thrice x = f12.add (x, twice x)\n\n\/**\n * The \"Line_Function\" from Appendix A of draft-irtf-cfrg-pairing-friendly-curves-07\n *\/ \nline_function: (t12,t12) -> (t12,t12) -> (t12,t12) -> t12\nline_function A B P = ret where\n    (A1,A2) = A\n    (B1,B2) = B\n    (P1,P2) = P\n    ret = if A == EC::neg c12 B \/\/ if A==-B\n          then f12.sub (P1, A1) \/\/ return P1 - A1\n          else f12.sub (f12.add (f12.mul (l, f12.sub (P1, A1)), A2), P2)\n    l = if A == B\n        then f12.div (thrice (f12.sq A1), twice A2)\n        else f12.div (f12.sub (B2, A2), f12.sub (B1, A1))\n\n\n\/\/ bls_ate_pairing, Appendix A.2 of the Draft\n\/\/\n\/\/ The Draft does not make it clear that the Line Function acts on the curve\n\/\/ E(F_p^{`12}).  Optimizations are possible, as the points involved can be\n\/\/ represented by points on curves over smaller fields.  Here, we simply map\n\/\/ the points to the full curve and compute there.\n\n\/\/ t = -2^63 - 2^62 - 2^60 - 2^57 - 2^48 - 2^16\nnegative_t:[64]\nnegative_t = <| x^^63 + x^^62 + x^^60 + x^^57 + x^^48 + x^^16 |>\n\n\/**\n * The \"Optimal Ate Pairing\" for the BLS12_381 curves,\n * as defined in Appendix A.2 of  draft-irtf-cfrg-pairing-friendly-curves-07\n *\/\nbls_ate_pairing: EC::AffinePoint t1 -> EC::AffinePoint t2 -> t12\nbls_ate_pairing p q = ate_pairing (phi_1 p) (phi_2 q)\n\nate_pairing: EC::AffinePoint t12 -> EC::AffinePoint t12 -> t12\nate_pairing P Q = final_exponentiation (ate_pairing' P Q)\n\n\/\/ skipping the final exponentation\nate_pairing': EC::AffinePoint t12 -> EC::AffinePoint t12 -> t12\nate_pairing' P Q =  last_f where\n   negQ = EC::neg c12 Q\n   (last_f, _) = f_Ts ! 0\n   f_Ts = [(f12.field_unit, negQ)] #\n          [ miller_step P negQ fT ci | fT <- f_Ts | ci <- tail negative_t]\n\n\/\/ in the Miller loop, c_i is only ever 0 or -1, here represented by False and True\n\/\/ We only subtract Q, never add, so we take -Q as a parameter\nmiller_step:  EC::AffinePoint t12 -> EC::AffinePoint t12 -> (t12, EC::AffinePoint t12)\n              -> Bit -> (t12, EC::AffinePoint t12)\nmiller_step P negQ (f, T) ci = (f', T') where\n    f0 = f12.mul (f12.sq f, line_function T T P)\n    T0 = EC::double c12 T\n    (f', T') = if ci\n               then (f12.mul (f0, line_function T0 negQ P),\n                     EC::add c12 T0 negQ)\n               else (f0, T0)\n\n\ntype r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\ntype final_exponent = (P::p^^12 - 1) \/ r\ntype small_final_e =  (P::p^^4 - P::p^^2 +1)\/r\n\n\/\/ Use the Frobenius mapping to compute x^(p^6-1)*(p^2+1)\nfinal_exp_frobenius_map : t12 -> t12\nfinal_exp_frobenius_map x = x2 where\n  x1 = f12.div (fp12_conjugate x, x) \/\/ = x^(p^6 - 1)\n  x2 = f12.mul (fp12_frobenius (fp12_frobenius x1), x1) \/\/ x1^(p^2+1)\n\nfinal_exponentiation: t12 -> t12\n\/* We could most simply define\n\n  final_expt x = k_expt`{6} f12 x (`final_exponent:[4314])\n\n  but is it rather inefficient to do so.  Instead, as noted in [1] and [2]\n  we can use the factorization\n\n     p^12-1 = (p^8+p^6 - p^2-1)*(p^4-p^2+1)\n            = (p^6-1)*(p^2+1)*(p^4-p^2+1)\n\n  and r since divides p^4-p^2+1, we can first use the Frobenius mapping to\n  easily compute x^(p^6-1)*(p^2+1), then complete the calculation\n  raising this to (p^4-p^2+1)\/r.\n\n  For that last exponentiation, we use a (2^5)-ary breakdown of the exponent,\n  noting that 2^5 = 32 is pretty close the the square root of 1268, the number of\n  bits in the exponent.\n\n  [1] Beauchat et al.  \"High-Speed Software Implementation of the Optimal\n      Ate airing over Barreto-Naehrig Curves\"\n\n  [2] Scott et al. \"On the final exponentiation for calculating pairings on\n      ordinary elliptic curves.\" eprint.iacr.org\/2008\/490\n *\/\nfinal_exponentiation x = k_expt`{5} f12 (final_exp_frobenius_map x) (`small_final_e:[1268+2])\n```"}]}
{"filename":"BLST-Verification\/spec\/BLSGeneric.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the CoreSign and CoreVerify functions in the BLSGeneric module. The properties should check that for any valid secret key and message, a signature produced by CoreSign is accepted by CoreVerify with the corresponding public key. Additionally, specify properties to verify that invalid signatures or altered messages fail verification. Include subgroup checks and key validation as part of the verification conditions."},{"role":"assistant","content":"```cryptol\n\/\/ Definitions from draft-irtf-cfrg-bls-signature-04\n\/\/\n\/\/ That specification describes a number of \"parameters\" that are used in its\n\/\/ definitions, and later defines ciphersuites that instantiate those parameters.\n\/\/\n\/\/ This module defines the specification in terms of the parameters, using a Cryptol\n\/\/ parameterized module.  The instantiations are done in separate Crytpol files,\n\/\/ as required by the language.\n\nmodule BLSGeneric where\n\nimport Common::Field (FieldRep)\nimport ShortWeierstrassCurve as EC\nimport Parameters as P\nimport Maybe\nimport Primitive::Keyless::Hash::SHA256\nimport Primitive::Symmetric::KDF::HKDF256\nimport rfc8017\n\n\/\/ Section 2.2, \"parameters\"\n\nparameter\n    \/\/ signature variant: not needed in the formalization\n\n    \/\/ a pairing-friendly elliptic curve\n    type t_F: * \/\/ representation type for field of the primary curve (signature)\n    type t_F': * \/\/ representation type for field of the secondary curve (pubkey)\n    type t_G: * \/\/ representation type for field of the pairing result\n    G: FieldRep t_G\n\n        type constraint Eq t_G\n    type constraint Zero t_G      type pubkey_len: #\n    type signature_len: #\n\n    main_curve: EC::EllipticCurve t_F\n    other_curve: EC::EllipticCurve t_F'\n\n    \/\/ H, a hash function, is always HKDF, so not listed here\n\n        DST: [43][8]\n\n    hash_to_point: {msg_len} (Hashable msg_len) =>\n               [msg_len][8] -> EC::AffinePoint t_F\n\n    \/\/ other primitives \"determined by the above parameters\"\n\n    P: EC::AffinePoint t_F' \/\/ base point\n    \/\/ r -- is fixed in both BLS variants  Should we use it here as a parameter anyway??\n\n    pairing: (EC::AffinePoint t_F, EC::AffinePoint t_F') -> t_G\n\n    point_to_pubkey: EC::AffinePoint t_F' -> [pubkey_len]\n    point_to_signature: EC::AffinePoint t_F -> [signature_len]\n\n    pubkey_to_point: [pubkey_len] -> Maybe (EC::AffinePoint t_F') \/\/ can fail\n    signature_to_point: [signature_len] -> Maybe (EC::AffinePoint t_F) \/\/ can fail\n\n    pubkey_subgroup_check: EC::AffinePoint t_F' -> Bool\n    signature_subgroup_check: EC::AffinePoint t_F -> Bool\n\n\/\/type constraint Hashable msg_len = (msg_len <= 255, 61 >= width (69 + msg_len + DST_len))\ntype constraint Hashable msg_len = (msg_len <= 255, 61 >= width (69 + msg_len + 43))\n\nreexport_DST = DST\n\nreexport_pubkey_subgroup_check = pubkey_subgroup_check\nreexport_signature_subgroup_check = signature_subgroup_check\n\n\/\/ 2.3 KeyGen\n\n\/\/ ... KeyGen has been moved to its own module, called KeyGen, as it does not depend\n\/\/     on the parameters.\n\n\n\/\/ 2.4 SkToPk\n\nsk_to_pk: [255] -> [pubkey_len]\nsk_to_pk sk = point_to_pubkey (EC::mult other_curve sk P)\n\n\n\/\/ 2.5 KeyValidate\n\n\/\/ The spec says to return VALID or INVALID; here we use True for VALID\nKeyValidate: [pubkey_len] -> Bool\nKeyValidate pk = ret where\n    xP = pubkey_to_point pk  \/\/ step 1\n    ret = maybe_cases xP\n            False \/\/ xP is None, step 2\n            (\\y ->   (~ (EC::is_point_O other_curve y)) \/\/ Step 3\n                  \/\\ reexport_pubkey_subgroup_check y) \/\/ Step 4\n\n\/\/ 2.6 CoreSign\n\n\/* CoreSign: {msg_len} (Hashable msg_len) => [255] -> [msg_len][8] -> [signature_len] *\/\nCoreSign: {msg_len} (Hashable msg_len) => ([255], [msg_len][8]) -> [signature_len]\nCoreSign (sk, message) = signature where\n    Q = hash_to_point message\n    R = EC::mult main_curve sk Q\n    signature = point_to_signature R\n\n\/\/ 2.7 CoreVerify\n\nCoreVerify: {msg_len} (Hashable msg_len) => [pubkey_len] -> [msg_len][8] -> [signature_len] -> Bool\n\/* possible alternate definition\nCoreVerify(PK, message, signature) = maybe False step3 (signature_to_point signature) where \/\/ lines 1, 2\n    step3 R = if signature_subgroup_check R == False then False \/\/ line 3\n               |  KeyValidate PK == False then False \/\/ line 4\n              else maybe False (step5 R) (pubkey_to_point PK) \/\/ line 5, but dealing with \"maybe-ness\"\n    step5 R xP = C1 == C2 where \/\/ line 9\n         Q = hash_to_point message \/\/ line 6\n         C1 = pairing (Q, xP) \/\/ line 7\n         C2 = pairing (R, P) \/\/ line 8\n*\/\nCoreVerify PK message signature =\n    maybe_cases (signature_to_point signature)\n        False         (\\ R -> if reexport_signature_subgroup_check R == False then False                  |  KeyValidate PK == False then False                 else maybe_cases (pubkey_to_point PK)\n                    False                     (\\ xP -> (C1 == C2 where                               Q = hash_to_point message                               C1 = pairing (Q, xP)                               C2 = pairing (R, P)))) aggregate_loop: {n, msg_len} (fin n, Hashable msg_len) =>\n                [n][pubkey_len] ->\n                [n][msg_len][8] ->\n                Maybe t_G\naggregate_loop PKs messages = C1s ! 0 where      C1s = [just G.field_unit] # [ aggregate_loop_body PK message C1 |\n                                  PK <- PKs |\n                                  message <- messages |\n                                  C1 <- C1s ]\n\naggregate_loop_body: {msg_len} (Hashable msg_len) =>\n                     [pubkey_len] ->\n                     [msg_len][8] ->\n                     Maybe t_G ->\n                     Maybe t_G\naggregate_loop_body PK message mC1 =\n    maybe_cases mC1 nothing (\\C1 ->\n        if KeyValidate PK == False then nothing          else maybe_cases (pubkey_to_point PK)\n            nothing              (\\ xP -> (just (G.mul (C1, (pairing (Q, xP)))) where                        Q = hash_to_point message)))  CoreAggregateVerify: {n, msg_len} (fin n, Hashable msg_len) =>\n                     [n][pubkey_len] ->\n                     [n][msg_len][8] ->\n                     [signature_len] ->\n                     Bool\nCoreAggregateVerify PKs messages signature =\n    maybe_cases (signature_to_point signature)          False                                           (\\R -> if reexport_signature_subgroup_check R == False\n               then False                 else (maybe_cases mC1 False (\\C1 -> C1 == C2) where                       mC1 = aggregate_loop PKs messages                      C2 = pairing (R, P)))\n```"}]}
{"filename":"BLST-Verification\/spec\/FieldExtras.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the functions in the FieldExtras module. Specifically, specify properties that check: 1) F_sum correctly computes the sum of a list of field elements; 2) F_prod correctly computes the product of a list of field elements; 3) F_expt computes exponentiation consistent with repeated multiplication; 4) F_is_zero correctly identifies the zero element; 5) k_expt computes exponentiation equivalent to F_expt; and 6) the mul_by_n functions correctly multiply by their respective constants. Use the FieldRep interface to express these properties."},{"role":"assistant","content":"```cryptol\nmodule FieldExtras where\n\nimport Common::Field\n\n\/**\n * Sum of a list of field elements\n *\/\nF_sum: {t, n} (fin n) => FieldRep t -> [n]t -> t\nF_sum F vs = sums!0 where\n    sums = [F.field_zero] # [F.add (s, v) | s <- sums | v <- vs]\n\n\/**\n * Product of a list of field elements\n *\/\nF_prod: {t, n} (fin n) => FieldRep t -> [n]t -> t\nF_prod F vs = prods!0 where\n    prods = [F.field_unit] # [F.mul (s, v) | s <- prods | v <- vs]\n\n\/**\n * F_expt F x e = x^e, computed in field F.\n *\/\nF_expt: {t, n} (fin n) => FieldRep t -> t -> Integer -> t\nF_expt F x e = powers ! 0 where\n    powers = [F.field_unit] #\n             [if b then F.mul (x, F.sq p) else F.sq p | p <- powers | b <- ((fromInteger e):[n])]\n\n\/**\n * Is a field element zero?\n *\/\nF_is_zero: {t} FieldRep t -> t -> Bit\nF_is_zero F x = F.is_equal (x, F.field_zero)\n\nprivate\n    kth_square: {k, t} (fin k, k>=1) => FieldRep t -> t -> t\n    kth_square F x = squares@(`k) where\n        squares = [x] # [F.sq y | y <- squares]\n\n\/**\n * k_expt`{k} F b e computes b^e in field f, using `k` bits of the exponent at a time.\n * This is not exactly Brauer's \"2^k-ary\" method, but is close.\n * This can be more efficient than the formal `F_expt` function that uses the convential\n * \"square-and-multiply\" algorithm.\n *\/\nk_expt: {k, n, t} (fin k, fin n, k>=1, n>=1) => FieldRep t -> t -> [n*k] -> t\nk_expt F b e = acc!0 where\n    digits: [n][k]\n    digits = split e\n    small_powers = [F.field_unit] # [F.mul(b, sp) | sp <- small_powers] \/\/ 1, b, b^2, ...\n    acc = [small_powers@(digits@0)] # [F.mul(small_powers@d, kth_square`{k} F a) | a <- acc | d <- tail digits]\n\n\/\/ Multiplication by small constants\n\nmul_by_2: {t} FieldRep t -> t -> t\nmul_by_2 F x = F.add (x,x)\n\nmul_by_3: {t} FieldRep t -> t -> t\nmul_by_3 F x = F.add (x, F.add (x, x))\n\nmul_by_4: {t} FieldRep t -> t -> t\nmul_by_4 F x = mul_by_2 F (mul_by_2 F x)\n\nmul_by_6: {t} FieldRep t -> t -> t\n\/\/ mul_by_6 F x = F.add (y, F.add (y, y)) where y = mul_by_2 F x\nmul_by_6 F x = mul_by_3 F (mul_by_2 F x)\n\nmul_by_8: {t} FieldRep t -> t -> t\nmul_by_8 F x = x8 where\n  x2 = F.add (x, x)\n  x4 = F.add (x2, x2)\n  x8 = F.add (x4, x4)\n```"}]}
{"filename":"BLST-Verification\/spec\/PrimeField.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the three finite field representations (integer-based, modular type Z k, and bit-vector based) in the PrimeField module satisfy the field axioms: closure, associativity, commutativity of addition and multiplication, distributivity of multiplication over addition, existence of additive and multiplicative identities, existence of additive inverses, and existence of multiplicative inverses for non-zero elements. Include properties that check correctness of normalization and equality functions for each representation."},{"role":"assistant","content":"```cryptol\n\/\/ Three representation of a finite field with p elements, where p is prime.\n\/\/\n\/\/ The first uses Integers, the second the modular type `Z n`, and \n\/\/ the third uses bit vectors.\n\/\/\n\/\/ In the second, then, \"p\" is a type parameter, while in the other two it\n\/\/ is a value parameter.\n\nmodule PrimeField where\n\nimport Common::Field\nimport Common::ModDivZ\nimport Common::mod_arith\n\n\/**\n * A finite field with a prime number of elements, represented\n * using Integers\n *\n * The constructor does not check that `p` is prime, so the caller should.\n *\/\nprime_field_integer: Integer -> FieldRep Integer\nprime_field_integer p =\n    { is_val x = 0 <= x \/\\ x < p\n    , normalize x = x % p\n    , add (x, y) =  mod_add_Z (p,x,y)\n    , sub (x, y) = mod_sub_Z (p,x,y)\n    , neg x = mod_neg_Z (p,x)\n    , mul (x,y) = mod_mul_Z (p,x,y)\n    , sq x = mod_sq_Z (p, x)\n    , half x = mod_half_Z (p,x)\n    , div (x,y) = mod_div_Z (p,x,y)\n    , field_zero = 0\n    , field_unit = 1\n    , is_equal (x, y) = x==y\n    }\n\nmod_add_Z: (Integer,Integer,Integer) -> Integer\nmod_add_Z (p,x,y) = (x + y) % p\n\nmod_sub_Z: (Integer,Integer,Integer) -> Integer\nmod_sub_Z (p,x,y) = (x - y) % p\n\nmod_mul_Z: (Integer,Integer,Integer) -> Integer\nmod_mul_Z (p,x,y) = (x * y) % p\n\nmod_neg_Z: (Integer,Integer) -> Integer\nmod_neg_Z (p, x) = (-x)%p\n\nmod_sq_Z: (Integer,Integer) -> Integer\nmod_sq_Z (p,x) = mod_mul_Z (p, x, x)\n\nmod_half_Z: (Integer,Integer)-> Integer\nmod_half_Z (p, x) = if (x%2==0) then x\/2 else (x+p)\/2\n\n\/* Returns x\/y in F_p using Euler's binary gcd algorithm. *\/\n\/* Taken from [HMV] *\/\nmod_div_Z : (Integer,Integer,Integer) -> Integer\nmod_div_Z (p,x,y) = egcd(p,0,y%p,x%p)\n  where\n    \/* In code below, a is always odd. *\/\n    egcd(a,ra,b,rb) =\n      if b == 0 then\n        ra\n      else if (b % 2) == 0 then \/* b is even. *\/\n        egcd(a, ra, b \/ 2, mod_half_Z(p, rb))\n      else if a < b then\n        egcd(a, ra, (b - a) \/ 2, mod_half_Z (p, (rb-ra)%p))\n      else\n        egcd(b, rb, (a - b) \/ 2, mod_half_Z (p, (ra-rb)%p))\n\n\n\/**\n * A finite field with a prime number of elements, represented\n * using modular types: `prime_field`k is represented with type `Z k`.\n *\n * The constructor does not check that `k` is prime, so the caller should.\n *\/\nprime_field: {k} (fin k, k >= 3, k > 2*(k\/2)) =>  FieldRep (Z k)\nprime_field =\n    { is_val x = True\n    , normalize x = x\n    , add (x, y) = x + y\n    , sub (x, y) = x - y\n    , neg x = -x\n    , mul (x,y) = x*y\n    , sq x = x*x\n    , half x = moddiv x 2\n    , div (x,y) = moddiv x y\n    , field_zero = 0\n    , field_unit = 1\n    , is_equal (x, y) = x==y\n    }\n\n\n\/**\n * A finite field with a prime number of elements, represented using\n * bit-vector types: `prime_field (k:[n])` is represented with type `[n]`.\n *\n * The constructor does not check that `m` is prime, so the caller should.\n *\/\nprime_field_bv: {n} (fin n, n >= 1) => [n] -> FieldRep [n]\nprime_field_bv m =\n    { is_val x = x < m\n    , normalize x = (x % m)\n    , add (x, y) = mod_add (m,x,y)\n    , sub (x, y) = mod_sub (m,x,y)\n    , neg x = mod_neg (m, x)\n    , mul (x,y) = mod_mul (m, x, y)\n    , sq x = mod_mul (m, x, x)\n    , half x = mod_half (m, x)\n    , div (x,y) = mod_div (m, x, y)\n    , field_zero = 0\n    , field_unit = 1\n    , is_equal (x, y) = x==y \/\/ does this need to handle unnormalized values?\n    }\n```"}]}
{"filename":"BLST-Verification\/spec\/BLSFieldExtras.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the functions in the BLSFieldExtras module, including is_square_fp, sqrt_fp, inverse_fp, sqrt_fp2, inverse_fp2, and is_square_fp2. The properties should check algebraic identities such as the correctness of square roots, inverses, and the is_square predicates, ensuring they conform to the mathematical definitions over the finite fields Fp and Fp2 as specified in the code."},{"role":"assistant","content":"```cryptol\nmodule BLSFieldExtras where\n\nimport Parameters (p, Fp, t_Fp, Fp_2, t_Fp_2, u)\nimport FieldExtras\n\nis_square_fp x =  y == 0 \\\/ y == 1 where\n    y = F_expt`{n=width p} Fp x `((p-1)\/2)\n\nsqrt_fp x = F_expt`{n=width p} Fp x `((p+1)\/4) \/\/ the =3 (mod 4) variant\n\ninverse_fp x = F_expt`{n=width p} Fp x `(p-2) \/\/ but also could be F.div (F.field_unit, x)\n\ntype q = p*p\n\n\/\/ sqrt in Fp2 from Appendix G.3 (q = 9 mod 8)\nsqrt_fp2 x = z where\n    tv1 = F_expt`{n=(width q) - 3} Fp_2 x `((q+7)\/16)\n    tv2 = Fp_2.mul (c1, tv1)\n    tv3 = Fp_2.mul (c2, tv1)\n    tv4 = Fp_2.mul (c3, tv1)\n    e1 =  Fp_2.is_equal (Fp_2.sq tv2, x)\n    e2 =  Fp_2.is_equal (Fp_2.sq tv3, x)\n\n    tv1_1 = CMOV (tv1, tv2, e1)\n    tv2_1 = CMOV (tv4, tv3, e2)\n    e3 = Fp_2.is_equal (Fp_2.sq tv2_1, x)\n    z = CMOV (tv1_1, tv2_1, e3)\n\n    \/\/ From Section 4. Utility Functions\n    CMOV (a,b,c) = if c==False then a else b\n\n    \/\/ Need constants c1,c2,c3 with c1^2 = -1, c2^2 = c1, c3^3 = -c1\n    \/\/ As Fp_2 = Fp(u) with u^2 +1 = 0, c1 = u does the first\n    c1 = [1,0]\n    c2 = sqrt_fp2_c2\n    c3 = sqrt_fp2_c3\n\n\/\/ Appendix G.3 asks for `c2` so that `c2^2 == u`, without saying how to get it.  If we find a\n\/\/ constant `k` in Fp with `k^^2 == -1\/2, then\n\/\/  (k*(u+1))^2 == k^2 * (u-1)^2 == (-1\/2) * (u^2 - 2*u + 1) = (-1\/2) * (-2*u) == u\n\/\/ and\n\/\/  (k*(u-1))^2 = (-1\/2)*(u^2 + 2*u + 1) == -u\n\/\/ We found this k (thanks to SageMath):\nsqrt_fp2_k: t_Fp\nsqrt_fp2_k = 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257\n\nsqrt_fp2_c2: t_Fp_2\nsqrt_fp2_c2 = [sqrt_fp2_k, Fp.neg sqrt_fp2_k]\n\nsqrt_fp2_c3: t_Fp_2\nsqrt_fp2_c3 = [sqrt_fp2_k, sqrt_fp2_k]\n\n\/\/ the C implementation of sqrt deviates from the above and uses the following defintion\nsqrt_align_fp2_coeff: t_Fp_2 -> t_Fp_2 -> t_Fp_2\nsqrt_align_fp2_coeff s inp =\n  if Fp_2.sq (Fp_2.mul(sqrt_fp2_c3, s)) == inp then sqrt_fp2_c3\n   | Fp_2.sq (Fp_2.mul(sqrt_fp2_c2, s)) == inp then sqrt_fp2_c2\n   | Fp_2.sq (Fp_2.mul(          u, s)) == inp then u\n  else Fp_2.field_unit\n\n\/\/ (a*u + b) inverse is (-a*u + b)\/(a^2+b^2), as can be checked by multiplying out\ninverse_fp2: t_Fp_2 -> t_Fp_2\ninverse_fp2 [a,b] = [Fp.div(Fp.neg a, c), Fp.div(b, c)] where\n    c = Fp.add (Fp.sq a, Fp.sq b)\n\n\/\/ Two ways to implement `is_square` for Fp_2 are offered\n\n\/\/is_square x =  F.is_equal (y, F.field_zero) \\\/ F.is_equal (y, F.field_unit) where\n\/\/    y = F_expt`{n = width q} F x `((q-1)\/2)\n\n\/\/ ... and Appendix G.5 of draft-irtf-cfrg-hash-to-curve\n\nis_square_fp2: t_Fp_2 -> Bool\nis_square_fp2 [x_2, x_1] = (tv1' != Fp_2.neg Fp_2.field_unit) where\n    \/\/ NB our representation of polynomnials is big-endian unlike the spec\n    tv1 = Fp.sq x_1\n    tv2 = Fp_2.sq [x_2, Fp.field_zero] \/\/ = Fp2_sq (Fp_2.mul (u, const_poly x_2))\n    tv1' = F_expt`{n=381} Fp_2 (Fp_2.sub ([Fp.field_zero, tv1], tv2)) ((`p-1)\/2)\n\nfp_exp: t_Fp -> Integer -> t_Fp\nfp_exp x e = if e < 0 then Fp.div (Fp.field_unit, fp_exp x (-e))\n              | e == 0 \/\\ x == Fp.field_zero then Fp.field_zero \/\/ needed for the alg. rules\n              | e == 0 then Fp.field_unit\n              else Fp.mul (x, fp_exp x (e-1))\n\nfp2_exp: t_Fp_2 -> Integer -> t_Fp_2\nfp2_exp x e = if e < 0 then Fp_2.div (Fp_2.field_unit, fp2_exp x (-e))\n              | e == 0 \/\\ x == Fp_2.field_zero then Fp_2.field_zero \/\/ needed for the alg. rules\n              | e == 0 then Fp_2.field_unit\n              else Fp_2.mul (x, fp2_exp x (e-1))\n```"}]}
{"filename":"BLST-Verification\/spec\/Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the field extension operations and the elliptic curve parameters defined in the Parameters module for BLS12-381. Include properties that check the consistency of the field embeddings (e.g., Fp to Fp_2, Fp_2 to Fp_6, Fp_6 to Fp_12), the correctness of the polynomial representations of the extension fields, and the validity of the base points BP and BP' on their respective curves E and E'. Ensure the properties can be used for formal verification of these parameters and their algebraic relationships."},{"role":"assistant","content":"```cryptol\n\/\/ Parameters for the BLS12_381 signature, from draft-irtf-cfrg-pairing-friendly-curves-07\n\nmodule Parameters where\n\nimport Polynomial\nimport PrimeField\nimport ExtensionField\nimport ShortWeierstrassCurve\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Pairing-friendly curves, Section 4.2.2\n\/\/\n\n\/\/ t = -2^63 - 2^62 - 2^60 - 2^57 - 2^48 - 2^16\nt_signed_form: [64][2] \/\/ list of {-1,0,1}, used in ate pairing\n\/\/ here, just {-1, 0} used\nt_signed_form = [ [bit,bit] | bit <-  <| x^^63 + x^^62 + x^^60 + x^^57 + x^^48 + x^^16 |> ]\n\ntype p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\n\n\/\/ Choice of base representation for GF(p) is made here:\n\n\/\/ For the Integer version:\nFp = prime_field_integer `p\ntype t_Fp = Integer\n\nto_Fp: {n} (fin n, n <= 384) => [n] -> t_Fp\nto_Fp bits = toInteger (zext`{m=384} bits)\n\nfrom_Fp: t_Fp -> [384]\nfrom_Fp x = fromInteger x\n\n\/*\n\/\/ For the Z p version:\nFp = prime_field`{p}\ntype t_Fp = Z p\n\nto_Fp: {n} (fin n, n <= 384) => [n] -> t_Fp\nto_Fp bits = fromInteger (toInteger (zext`{m=384} bits))\n\nfrom_Fp: t_Fp -> [384]\nfrom_Fp x = fromInteger (fromZ x)\n*\/\n\n\/*\n\/\/ For the bivector version:\nFp = prime_field_bv`{384} `p  \/\/ representation of F_p\ntype t_Fp = [384]  \/\/ ... and the underlying Cryptol type\n\nto_Fp: {n} (fin n, n <= 384) => [n] -> t_Fp\nto_Fp bits = (zext bits) \/\/ mod something?\n\nfrom_Fp: t_Fp -> [384]\nfrom_Fp x = x\n*\/\n\n\/\/ Nothing else should need to change depending on the version of base representation chosen above.\n\n\n\/\/       F_p^2 = F_p[u] \/ (u^2 + 1)\nFp_2 = extension_field Fp [Fp.field_zero, Fp.neg Fp.field_unit] \/\/ [0,-1]\ntype t_Fp_2 = [2]t_Fp\n\n\/** u is the generator for F_p^2 over F_p *\/\nu: t_Fp_2\nu = poly_x Fp\n\nu_plus_1: t_Fp_2\nu_plus_1 = Fp_2.add (u, poly_1 Fp)\n\n\/**\n * Lift a value from F_p to F_p^2\n *\/\nFp_to_Fp_2: t_Fp -> t_Fp_2\nFp_to_Fp_2 = poly_const Fp\n\n\/\/       F_p^6 = F_p^2[v] \/ (v^3 - u - 1)\nFp_6 = extension_field Fp_2 [Fp_2.field_zero, Fp_2.field_zero, u_plus_1]\ntype t_Fp_6 = [3]t_Fp_2\n\n\/** v is the generator for F_p^6 over F_p^2 *\/\nv: t_Fp_6\nv = poly_x Fp_2\n\n\/**\n * Lift a value from F_p^2 to F_p^6\n *\/\nFp_2_to_Fp_6: t_Fp_2 -> t_Fp_6\nFp_2_to_Fp_6 = poly_const Fp_2\n\n\/**\n * Lift a value from F_p to F_p^6\n *\/\nFp_to_Fp_6: t_Fp -> t_Fp_6\nFp_to_Fp_6 x = Fp_2_to_Fp_6 (Fp_to_Fp_2 x)\n\n\/\/       F_p^12 = F_p^6[w] \/ (w^2 - v).\nFp_12 = extension_field Fp_6 [Fp_6.field_zero, v]\ntype t_Fp_12 = [2]t_Fp_6\n\n\/** w is the generator for F_p^12 over F_p^6 *\/\nw: t_Fp_12\nw = poly_x Fp_6\n\n\/**\n * Lift a value from F_p^6 to F_p^12\n *\/\nFp_6_to_Fp_12: t_Fp_6 -> t_Fp_12\nFp_6_to_Fp_12 = poly_const Fp_6\n\n\/**\n * Lift a value from F_p^2 to F_p^12\n *\/\nFp_2_to_Fp_12: t_Fp_2 -> t_Fp_12\nFp_2_to_Fp_12 x = Fp_6_to_Fp_12 (Fp_2_to_Fp_6 x)\n\n\/**\n * Lift a value from F_p to F_p^12\n *\/\nFp_to_Fp_12: t_Fp -> t_Fp_12\nFp_to_Fp_12 x = Fp_2_to_Fp_12 (Fp_to_Fp_2 x)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ Pairing-friendly curves, Section 2.5, representation convention\n\/\/\n\n\/\/ Given function f: t -> octets, then we just concatenate the octet streams, starting with the\n\/\/ constant coefficient\nprivate\n  poly_to_octets: {t,k,n} (fin k, fin n) => (t->[n*8]) -> [k]t -> [k*n*8]\n  poly_to_octets f p = join (map f (reverse p))\n\nFp_to_octets: t_Fp -> [48*8] \/\/ big endian\nFp_to_octets = from_Fp\n\nFp_12_to_octets: t_Fp_12 -> [12*48*8]\nFp_12_to_octets = poly_to_octets (poly_to_octets (poly_to_octets Fp_to_octets))\n\nprivate\n  octets_to_poly: {t,k,n} (fin k, fin n) => ([n*8]->t) -> [k*n*8] -> [k]t\n  octets_to_poly f octets = map f (reverse (split octets))\n\noctets_to_Fp: [48*8] -> t_Fp\noctets_to_Fp octets = to_Fp octets octets_to_Fp_2: [2*48*8] -> t_Fp_2\noctets_to_Fp_2 = (octets_to_poly`{k=2} octets_to_Fp)\n\noctets_to_Fp_12: [12*48*8] -> t_Fp_12\noctets_to_Fp_12 = octets_to_poly`{k=2} (octets_to_poly`{k=3} (octets_to_poly`{k=2} octets_to_Fp))\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ parameters for a base point on the main curve, Section 4.2.1\n\/\/\n\nr = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\n\nBP_x = octets_to_Fp 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\n\nBP_y = octets_to_Fp 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1\n\nh = 0x396c8c005555e1568c00aaab0000aaab\n\nBP = (BP_x, BP_y)\n\nb: t_Fp\nb = 4\n\nE: EllipticCurve t_Fp\nE = {base_field = Fp, a = Fp.field_zero, b = b}\n\nr' =  0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\n\nx'_0 = octets_to_Fp 0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\n\nx'_1 =  octets_to_Fp 0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e\n\ny'_0 = octets_to_Fp 0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801\n\ny'_1 = octets_to_Fp 0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be\n\nh' = 0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\n\nBP_x' = [x'_1, x'_0]\nBP_y' = [y'_1, y'_0]\n\nBP' = (BP_x', BP_y')\n\nb': t_Fp_2\nb' = [4,4]  \/\/ 4(u+1)\n\nE': EllipticCurve t_Fp_2\nE' = {base_field = Fp_2, a = Fp_2.field_zero, b = b'}\n```"}]}
{"filename":"BLST-Verification\/spec\/Maybe.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the Maybe type implementation in the given code. Include properties that check the injectivity of 'just', the distinctness of 'nothing' and 'just' values, the correctness of the 'is_maybe' recognizer, and the behavior of 'maybe', 'maybe_cases', and 'maybe_map' functions. Ensure the properties cover the absence of junk values and the identity mapping behavior of 'maybe_map'."},{"role":"assistant","content":"```cryptol\n\/*\nSimilar to Haskell's Maybe type, this gives a way to have optional values.\n\nA value of type `Maybe t` is meant to be either `nothing`, or `just x`\nfor some x:t.  There is no way to properly define this type in\nCryptol; the type definition here allows for some undesired values to\nexist in `Maybe t`.  Function `is_maybe` recognizes the proper values.\n\nFunction `maybe` allows for case analysis.\n\nFunction `maybe_map` allows a function to be applied \"inside\" the\nMaybe wrapper.\n*\/\n\nmodule Maybe where\n\ntype Maybe a = (Bool, a)\n\n\/** The `no data` value in a Maybe type. *\/\nnothing: {a} (Zero a) => Maybe a\nnothing = (False, zero)\n\n\/** Inject a value of type `a` into `Maybe a`. *\/\njust: {a} a -> Maybe a\njust x = (True, x)\n\n\/** Case analysis of a value of `Maybe` type.\n    maybe v f nothing  == v\n    maybe v f (just x) == f x\n *\/\nmaybe: {a,b} b -> (a -> b) -> Maybe a -> b\nmaybe c_nothing c_just (b, x) = if b then c_just x else c_nothing\n\n\/** Case analysis of a value of `Maybe` type, alternative order of arguments.\n    maybe_cases nothing  v f  == v\n    maybe_cases (just x) v f  == f x\n *\/\nmaybe_cases: {a,b} Maybe a -> b -> (a -> b) -> b\nmaybe_cases (b, x) c_nothing c_just = if b then c_just x else c_nothing\n\n\/** Apply a function to the contained value if present, in a `Maybe` type.\n    maybe_map f nothing == nothing\n    maybe_map f (just x) == just (f x)\n*\/\nmaybe_map: {a,b} (Zero b) => (a -> b) -> Maybe a -> Maybe b\nmaybe_map f = maybe nothing (\\v -> just (f v))\n\n\/** Recognizer for proper `Maybe` values *\/\nis_maybe: {a} (Cmp a, Zero a) => Maybe a -> Bool\nis_maybe (b,x) = (b \\\/ x==zero) \/\/ b==False ==> x==zero\n\nprivate\n        property distinct (x:[2]) = nothing != just x\n    property injective (x:[2]) y = (just x == just y) == (x == y)\n\n    property recognize_nothing = is_maybe`{[5]} nothing\n    property recognize_just x = is_maybe`{([2],[2])} (just x)\n\n    property no_junk x = is_maybe`{[3]} x ==> x == (maybe nothing just) x\n    property no_junk' x = is_maybe`{[3]} x ==> x == maybe_cases x nothing just\n\n    property map_id x = is_maybe`{([2],Bit)} x ==> x == maybe_map (\\y->y) x\n```"}]}
{"filename":"BLST-Verification\/spec\/BLSMinimalSignatureSize.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the serialization and deserialization functions for public keys and signatures are inverses of each other, ensuring correctness of point_to_pubkey\/pubkey_to_point and point_to_signature\/signature_to_point. Additionally, specify properties to verify that the subgroup checks correctly identify points in the correct subgroup for both public keys and signatures, according to the BLS minimal signature size scheme defined in the module."},{"role":"assistant","content":"```cryptol\nmodule BLSMinimalSignatureSize = BLSGeneric where\n\n\/\/ Suite BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_, as defined in\n\/\/ draft-irtf-cfrg-bls-signature-04, Secton 4.2.1 and Appendix A\n\nimport Parameters\nimport HashToCurveE1\nimport Pairing (bls_ate_pairing)\nimport Serialization\nimport ShortWeierstrassCurve as EC\n\n\/\/ a pairing-friendly elliptic curve\ntype t_F = t_Fp \/\/ representation type for field of the primary curve (signature)\ntype t_F' = t_Fp_2 \/\/ representation type for field of the secondary curve (pubkey)\ntype t_G = t_Fp_12  \/\/ representation type for field of the pairing result\nG = Fp_12\n\ntype pubkey_len = 96*8\ntype signature_len  = 48*8\n\nmain_curve = E\nother_curve = E'\n\n\/\/ hash_to_point  BLS12381G1_XMD:SHA-256_SSWU_RO_\n\/\/ type DST_len = 43\n\nDST: [43][8]\nDST = \"BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_\"\n\nhash_to_point hx = hash_to_curve_opt (hx, DST)\n\n\/\/ other primitives \"determined by the above parameters\"\n\nP: EC::AffinePoint t_F' \/\/ base point\nP = BP'\n\n\/\/ pairing: (EC::AffinePoint t_F, EC::AffinePoint t_F') -> t_G\npairing (p,q) = bls_ate_pairing p q \/\/ Section 2.2\n\n\/\/ point_to_pubkey: EC::AffinePoint t_F' -> [pubkey_len]\n\/\/ point_to_pubkey = point_to_octets_E2 \/\/ Section 2.2 BUT\n\/\/    draft-irtf-cfrg-pairing-friendly-curves-07 does not mention\n\/\/    a function of this name.  So:\npoint_to_pubkey S = join (serialize_E2 S)\n\n\/\/ point_to_signature: EC::AffinePoint t_F -> [signature_len]\n\/\/point_to_signature = point_to_octets_E1 \/\/ Section 2.2\npoint_to_signature S = join (serialize_E1 S)\n\n\/\/ pubkey_to_point: [pubkey_len] -> Maybe (EC::AffinePoint t_F') \/\/ can fail\n\/\/ pubkey_len = 768\n\/\/ deserialize_E2: [96][8] -> Maybe (EC::AffinePoint t_Fp_2)\npubkey_to_point S = deserialize_E2 (split S)\n\n\/\/ signature_to_point: [signature_len] -> Maybe (EC::AffinePoint t_F) \/\/ can fail\n\/\/ signature_to_point = octets_to_point_E1\n\/\/ TODO: Was deserialize_E1, but types didn't line up with the expected\n\/\/ signature length\nsignature_to_point S = uncompress_E1 (split S)\n\n\/\/ Here are the unoptimized versions of the subgroup check\n\n\/\/ pubkey_subgroup_check: EC::AffinePoint t_F' -> Bool\npubkey_subgroup_check S =\n    EC::is_point_O E' (EC::mult E' r S)\n\n\/\/ signature_subgroup_check: EC::AffinePoint t_F -> Bool\n\/\/ ... more efficient versions are allowed.\nsignature_subgroup_check S =\n    EC::is_point_O E (EC::mult E r S)\n```"}]}
{"filename":"BLST-Verification\/spec\/BulkAddition.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the bulk addition functions defined in BulkAddition.cry. Specifically, specify and prove that the combination of bulk_addition_head_imp, bulk_addition_tail, and the Montgomery inverse computations correctly implement elliptic curve point addition according to the curve's group law. Include properties that verify the inverse computations (inverses function) are correct and that the bulk_accumulate and bulk_add functions produce the same results as repeated point addition using the standard add function from the elliptic curve module."},{"role":"assistant","content":"```cryptol\nimport Common::Field\nimport FieldExtras\nimport ShortWeierstrassCurve\nimport PrimeField import implementation::CurveOperation\n\n\/\/ Test setup\n\nF37 = prime_field`{37}\nC1: EllipticCurve (Z 37)\nC1 = { base_field= F37, a = 0, b = 4 }\n\n\/\/ C1, like the BLS curves E and E', has no rational points with y==0.\n\np1: AffinePoint (Z 37)\np1 = (2,7) \/\/ was (1,6), for F31\n\/\/ p1 generates the 39-element group of rational points\n\np2: AffinePoint (Z 37)\np2 = (16,20) \/\/ was (5,6)\n\/\/ p2 = 10*p1\n\nq1: AffinePoint (Z 37)\nq1 = (24, 29) \/\/ q1 generates a group of 13 elements, not including (0,2)\n\n\/\/ ... also with a representation with junk elements\nF37' = prime_field_bv`{6} 37\nC1': EllipticCurve [6]\nC1' = { base_field= F37', a = 0, b = 4 }\n\np1': AffinePoint [6]\np1' = (2,7)\n\np2': AffinePoint [6]\np2' = (16,20)\n\nq1': AffinePoint [6]\nq1' = (24,29)\n\n\/\/ end test setup\n\n\/* Montgomery's trick allows the calculation of the inverses of several\n   field values while only computing one inverse.\n\n   The basic idea, for two values a and b, is to compute (ab)^(-1), then we get\n   a^(-1) = b*(ab)^{-1}   and   b^(-1) = a*(ab)^{-1}\n\n  for 4 values, it works like this.\n  1. From [a,b,c,d], we form the products [a, ab, abc, abcd]\n  2. Compute (abcd)^(-1)\n  3. Get [a^(-1), (ab)^(-1), (abc)^(-1), (abcd)^(-1)] by starting with the last\n     value, and getting each earlier value by a multiplication\n  4. Get [a^(-1),  b^(-1), c^(-1), d^(-1)] by multiplication with the\n     appropriate products, e.g. c^(-1) = (ab) * (abc)^(-1)\n\n If any of the input values is 0, the whole thing fails.\n*\/\n\ninverses: {n, t} (fin n, n >= 1) => FieldRep t -> [n]t -> [n]t\ninverses F xs = results where\n  products = [xs@0] # [F.mul (p, x) | p <- products | x <- tail xs ]\n  \/\/ products@i == product (take`{i} xs)\n  iprods = [F.mul (x, i) | i <- tail`{n-1} iprods | x <- tail xs]\n           # [F.div(F.field_unit, products!0) ]\n  \/\/ iprods@i == xs@(i+1) * iprods@(i+1) == inverse (products@i)\n  results = [iprods@0] # [F.mul(p, i) | p <- products | i <- tail iprods]\n  \/\/ results@i == products@(i-1) * iprods@i == inverse (xs@i)\n\n\/\/ correctness property\ninverse_functionality: {n, t} (fin n, n >= 1, Eq t) => FieldRep t -> [n]t -> Bool\ninverse_functionality F xs =\n  (mem F.field_zero (map F.normalize xs)) \\\/ test_inverses F xs == map (\\ x -> F.field_unit) xs\n  where\n    mem i xs' = (map ((==) i) xs') != zero\n    test_inverses F' xs' = [F'.mul(x,i) | x <- xs' | i <- inverses F' xs']\n\neq_F : {t} (Eq t) => FieldRep t -> t -> t -> Bool\neq_F F x y = F.normalize x == F.normalize y\n\nbulk_addition_head_imp: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t) -> t -> ((t,t,t), (t,t,t))\nbulk_addition_head_imp F A B mul_acc = ((ax_1, ay_1, az_2), (bx_1, by_1, bz_2)) where\n  x1 = F.normalize A.0\n  y1 = F.normalize A.1\n  x2 = F.normalize B.0\n  y2 = F.normalize B.1\n  inf = (eq_F F x1 F.field_zero \/\\ eq_F F y1 F.field_zero) \\\/ (eq_F F x2 F.field_zero \/\\ eq_F F y2 F.field_zero)\n  bz = F.sub (x2, x1)\n  bx = F.add (x2, x1)\n  az = F.add (y2, y1)\n  by_0 = F.sub (y2, y1)\n\n  cond = eq_F F bz F.field_zero \/\/ if test, x2 == x1\n  inf_1 = if cond then eq_F F az F.field_zero else inf\n  bx_1 = if cond then if inf_1 then az else bx else bx\n  by_1 = if cond then mul_by_3 F (F.sq x1) else by_0\n  bz_1 = if cond then az else bz\n\n  ax_1 = if inf_1 then bx_1 else x1\n  ay_1 = if inf_1 then az else y1\n  az_1 = if inf_1 then F.field_unit else bz_1\n  bz_2 = if inf_1 then F.field_zero else bz_1\n  az_2 = F.mul (az_1, mul_acc)\n\n\/\/ The HEAD function computes half of point addition, up to the point that\n\/\/ an inverse is needed.  See comments in `bulk_addition.c` for a description of the\n\/\/ 6 elements of the result.  Those comments suggest this function:\n\nbulk_addition_head: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t) -> t -> ((t,t,t), (t,t,t))\nbulk_addition_head F A B mul_acc = (bulk_addition_head_a F A B mul_acc,  bulk_addition_head_b F A B)\n\nbulk_addition_head_a: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t) -> t -> (t,t,t)\nbulk_addition_head_a F (x1,y1) (x2,y2) mul_acc =\n  if x1 == x2 \/\\ y1 == y2\n  then (x1, y1, mul_by_2 F (F.mul (y1, mul_acc)))\n  else if x1 == x2 \/\\ y1 == F.neg(y2)\n  then (F.field_zero, F.field_zero, mul_acc)\n  else (x1, y1, (F.mul (F.sub (x2, x1), mul_acc)))\n\nbulk_addition_head_b: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t) -> (t,t,t)\nbulk_addition_head_b F (x1,y1) (x2,y2) =\n  if x1 == x2 \/\\ y1 == y2\n  then (mul_by_2 F x1, mul_by_3 F (F.sq x1), mul_by_2 F y1)\n  else if x1 == x2 \/\\ y1 == F.neg(y2)\n  then (F.field_zero, mul_by_3 F (F.sq x1), F.field_zero)\n  else (F.add (x2, x1), F.sub(y2, y1), F.sub (x2, x1))\n\/\/ ... however, this disagrees with the code, which handles (0,0) specially (as it must)\n\n\/\/ TAIL produces two results, D and B->Z\n\nbulk_addition_tail: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t,t) -> t -> (t,t)\nbulk_addition_tail F A B lam = if eq_F F b_z F.field_zero then (a_x, a_y) else (d_x, d_y)\n  where\n    a_x = F.normalize A.0\n    a_y = F.normalize A.1\n    b_x = F.normalize B.0\n    b_y = F.normalize B.1\n    b_z = F.normalize B.2\n    lam' = F.mul(lam, b_y)\n    llam = F.sq lam'\n    d_x = F.sub (llam, b_x)\n    d_y = F.sub (F.mul(F.sub(a_x, d_x), lam'), a_y)\n\n\/\/ the B->Z result does not depend on A or lambda\nbulk_addition_tail_bz: {t} (Eq t) => FieldRep t -> t -> t\nbulk_addition_tail_bz F b_z =\n    if eq_F F b_z F.field_zero then F.field_unit else (F.normalize b_z)\n\n\/\/ TODO: semi-correctness: head, inverse, tail give the correct addition formula.\n\n\/\/ NOTE: in the A==B case, must know that y != 0, i.e., there are no\n\/\/ points (x,0) on the curve.  given the equation y^2 = x^3 + 4 for E,\n\/\/ that's saying that -4 is not a cube (which is true); given the\n\/\/ equation y^2 = x^3+4(u+1) for E', it says that -4(u+1) is not a\n\/\/ cube.  This is also true.  Both assertions are easily checked; when q-1 is divisible by 3,\n\/\/ then if x is a cube modulo q we have  x^((q-1)\/\/3) = 1.  Both p and p^2\n\/\/ are 1 more than a multiple of 3.\n\n\/\/ Now if (ax,ay,az), (bx,by_0,bz) = bulk_addition_head F a b m\n\/\/ and lam = inverse F bz\n\/\/ and c = bulk_addition_tail F (ax,ay) (bx,by_0,bz) lam\n\/\/ then c == add C a b\n\nhead_inverse_tail: {t} (Eq t) => EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\nhead_inverse_tail C a b = c where\n          F = C.base_field\n          ((ax,ay,az), (bx,by_0,bz)) = bulk_addition_head F a b F.field_unit\n          lam = F.div (F.field_unit, az)\n          c = bulk_addition_tail F (ax,ay) (bx,by_0,bz) lam\n\n\/\/ corrected version:\nhead_inverse_tail': {t} (Eq t) => EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\nhead_inverse_tail' C a b = c where\n          F = C.base_field\n          ((ax,ay,az), (bx,by_0,bz)) = bulk_addition_head_imp F a b F.field_unit\n          lam = if az == F.field_zero then F.field_unit else F.div (F.field_unit, az)\n          c = bulk_addition_tail F (ax,ay) (bx,by_0,bz) lam\n\ntype BulkAdditionStuff t =\n  { field : FieldRep t\n  , bulk_addition_head_fn : (t,t) -> (t,t) -> t -> ((t,t,t), (t,t,t))\n  , bulk_addition_tail_fn : (t,t) -> (t,t,t) -> t -> (t,t)\n  , bulk_addition_tail_bz_fn : t -> t\n  , point_dadd_affine_fn : ProjectivePoint t -> AffinePoint t  -> ProjectivePoint t\n  }\n\n\/\/ The accumulate function starts with while loop that halves the length\n\/\/ of the array at each iteration.  Inside that loop are  two other loops, first\n\/\/ calling HEAD on pairs of points, the second calling TAIL, and with some plumbing\n\/\/ for the Montgomery trick.\n\/\/\n\/\/ Following that is a simple loop for fewer than 16 points, that just adds them.\n\n\ncoerceSize : {m,n,a} (fin n, fin m) => [m]a -> [n]a\ncoerceSize xs = assert (`m == `n) \"coerceSize: size mismatch\" [ xs@i | i <- [0..<n] ]\n\natLeastOne: {n,a} [n]a -> [max 1 n]a\natLeastOne xs = (drop`{min 1 n} ([undefined] # xs))\n\n\/*\nbulk_accumulate_0: {n, t} (fin n) => EllipticCurve t -> (t,t) -> [n] (t,t)  -> (t,t)\nbulk_accumulate_0 C sum' points =\n  if `n < 16\n  then bulk_accumulate_small C sum' points\n  else if (`n%2) == 1\n  \/\/ then bulk_accumulate_even`{n\/2} C (add C sum' (points@0)) (take (tail (points # junk)))\n  then bulk_accumulate_even_0`{n\/2} C (add C sum' (points@0)) (tail (coerceSize points))\n  \/\/ else bulk_accumulate_even`{n\/2} C sum' (take points)\n  else bulk_accumulate_even_0`{n\/2} C sum' (coerceSize points)\n  \/\/ where junk = [ point_O C ] # junk\n*\/\n\nbulk_accumulate: {n, t} (fin n, Eq t) => BulkAdditionStuff t -> (t,t,t) -> [n] (t,t)  -> (t,t,t)\nbulk_accumulate C sum' points =\n  if `n < 16\n  then bulk_accumulate_small C sum' points\n  else if (`n%2) == 1\n  then bulk_accumulate`{n\/2} C (C.point_dadd_affine_fn sum' (points@0)) (bulk_accumulate_even`{n\/2} C (tail (coerceSize points)))\n  else bulk_accumulate`{n\/2} C sum' (bulk_accumulate_even`{n\/2} C (coerceSize points))\n\nbulk_accumulate_small: {n, t} (fin n) => BulkAdditionStuff t -> (t,t,t) -> [n] (t,t)  -> (t,t,t)\nbulk_accumulate_small C sum' points = sums!0 where\n  sums = [sum'] # [C.point_dadd_affine_fn x p | x <- sums | p <- points]\n\nbulk_accumulate_even_0: {n, t} (fin n) => EllipticCurve t -> (t,t) -> [2*n] (t,t)  -> (t,t)\nbulk_accumulate_even_0 C sum' points = undefined\n\nbulk_accumulate_even: {n, t} (fin n, Eq t) => BulkAdditionStuff t -> [2*n] (t,t)  -> [n](t,t)\nbulk_accumulate_even C points = dst where\n  points':  [n] ((t,t,t), (t,t,t))\n  points' = bulk_accumulate_loop_1 C points\n  \/\/ the Montgomery trick part\n  last_pair: ((t,t,t), (t,t,t))\n  \/\/last_pair = ([(z,z)] # points')!0 \/\/ type checker does not know n >= 1\n  \/\/z = (z0,z0,z0) \/\/ : (t,t,t)\n  \/\/z0 = C.base_field.field_zero \/\/ : t\n  last_pair = points'!0\n  last_inv = C.field.div (C.field.field_unit, last_pair.0.2)\n  dst = bulk_accumulate_loop_2 C points' last_inv\n\n\/\/ First loop: run adjacent pairs through the HEAD function\n\/\/ this results in an accumulated product in the .Z fields of the even-numbered points\n\/\/ (The \"a\"s in the a\/b splitting), and individual denominator values in the Z fields\n\/\/ of the odd-numbered points.\n\/\/ The c code modifies the points array in place, effectively resulting in a [2*n] (t,t,t)\nbulk_accumulate_loop_1: {n, t} (fin n, Eq t) => BulkAdditionStuff t -> [2*n] (t,t)  -> [n] ((t,t,t), (t,t,t))\nbulk_accumulate_loop_1 C points = points' where\n  points' = [C.bulk_addition_head_fn a b mul_ac | [a,b] <- split points | mul_ac <- mul_acs]\n  mul_acs = [C.field.field_unit] # [ma | ((_,_,ma), _) <- points' ]\n\n\/\/ second loop ` for (dst = points, i = n; --i;) ...`\n\/\/  runs reversed through the points array.  There are two effects:\n\/\/ one is the Montgomery inverse calculation, using the z fields of the\n\/\/ \"b\" points, the other using these inverses in the TAIL part of the\n\/\/ point addition. We use \n\nbulk_accumulate_loop_2: {n, t} (fin n, Eq t) => BulkAdditionStuff t -> [n] ((t,t,t),(t,t,t))  -> t -> [n](t,t)\nbulk_accumulate_loop_2 C point_pairs last_inv = dst where\n    dst = [C.bulk_addition_tail_fn (ax,ay) b i | ((ax,ay,az),b) <- point_pairs | i <- inverses']\n  inverses': [max 1 n] t\n    products = [az | ((_,_,az),_) <- point_pairs]\n  xs = [bz | (_,(_,_,bz)) <- point_pairs]\n  iprods: [max 1 n] t\n  iprods = [C.field.mul (i, C.bulk_addition_tail_bz_fn x) | i <- tail iprods | x <- tail (atLeastOne xs)]\n           # [C.field.div(C.field.field_unit, products!0) ]\n  \/\/ iprods@i == xs@(i+1) * iprods@(i+1) == inverse (products@i)\n  inverses' = [iprods@0] # [C.field.mul(i, p) | i <- tail iprods | p <- products]\n  \/\/ inverses'@i == products@(i-1) * iprods@i == inverse (xs@i)\n\nbulk_accumulate_inverses: {n, t} (fin n, Eq t) => FieldRep t -> [n] ((t,t,t),(t,t,t))  -> t -> [_]t\nbulk_accumulate_inverses F point_pairs last_inv = inverses' where\n  inverses': [max 1 n] t\n    products = [az | ((_,_,az),_) <- point_pairs]\n  xs = [bz | (_,(_,_,bz)) <- point_pairs]\n  iprods: [max 1 n] t\n  iprods = [F.mul (x, i) | i <- tail iprods | x <- tail (atLeastOne xs)]\n           # [F.div(F.field_unit, products!0) ]\n  \/\/ iprods@i == xs@(i+1) * iprods@(i+1) == inverse (products@i)\n  inverses' = [iprods@0] # [F.mul(p, i) | p <- products | i <- tail iprods]\n  \/\/ inverses'@i == products@(i-1) * iprods@i == inverse (xs@i)\n\nbulk_add : {m, n, t} (fin m, fin n, Eq t) => BulkAdditionStuff t -> (t, t, t) -> [n](t, t) -> (t, t, t)\nbulk_add C sum_acc points = if `n == 0\n  then sum_acc\n  else bulk_add`{m} C (bulk_accumulate C sum_acc (take`{min m n} points)) (drop`{min m n} points)\n```"}]}
{"filename":"BLST-Verification\/spec\/Frobenius.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the Frobenius map implementations in the Frobenius module. Specifically, specify properties that check: (1) fp2_frobenius behaves as the Frobenius endomorphism on Fp2, (2) fp6_frobenius correctly applies the Frobenius map on Fp6 elements using the given constants, (3) fp12_frobenius correctly applies the Frobenius map on Fp12 elements, and (4) fp12_conjugate corresponds to the Frobenius map raised to the p^6 power. Include properties that verify the algebraic identities and consistency with field arithmetic for these functions."},{"role":"assistant","content":"```cryptol\n\/* Frobenius and related functions on the BLS fields. *\/\n\nmodule Frobenius where\n\nimport Parameters as P\nimport FieldExtras\n\ntype t1 = P::t_Fp\ntype t2 = P::t_Fp_2\ntype t6 = P::t_Fp_6\ntype t12 = P::t_Fp_12 \n\nf1 = P::Fp\nf2 = P::Fp_2\nf6 = P::Fp_6\nf12 = P::Fp_12\n\n\/\/ F_p2\n\nfp2_conjugate: t2 -> t2\nfp2_conjugate [a,b] = [f1.neg a, b] \/\/ a*u + b -> -a*u + b\n\nfp2_frobenius: t2  -> t2\nfp2_frobenius x = fp2_conjugate x\n\n\/\/ F_p6\n\n\/\/ We have f6 = f2(v) where v^3 = (u+1).\n\/\/ Then v^p = v^(3 ((p-1)\/3)) * v = (u+1)^((p-1)\/3) * v\n\nv_frobenius_constant: t2\nv_frobenius_constant = F_expt`{n=381} f2 P::u_plus_1 `((P::p-1)\/3)\n\nv_frobenius_constant_sq: t2\nv_frobenius_constant_sq = f2.sq v_frobenius_constant\n\n\/\/ Now (av^2+bv+c)^p = a^p k^2 v^2 + b^p k v + c^p\n\nfp6_frobenius: t6 -> t6\nfp6_frobenius [a,b,c] = [a',b',c'] where\n    a' = f2.mul (v_frobenius_constant_sq, fp2_frobenius a)\n    b' = f2.mul (v_frobenius_constant, fp2_frobenius b)\n    c' = fp2_frobenius c\n\n\/\/ F_p12\n\n\/\/ We have f12 = f6(w) where w^2 = v so w^6 = (u+1)\n\/\/ thus w^p = w^(6 ((p-1)\/6)) * w = (u+1)^((p-1)\/6) * w\n\nw_frobenius_constant: t6\nw_frobenius_constant = P::Fp_2_to_Fp_6 (F_expt`{n=381} f2 P::u_plus_1 `((P::p-1)\/6))\n\nfp12_frobenius: t12 -> t12\nfp12_frobenius [a,b] = [a', b'] where\n    a' = f6.mul (w_frobenius_constant, fp6_frobenius a)\n    b' = fp6_frobenius b\n\n\/\/ The conjugate in F_p12 also gives x^(p^6), the six-fold Frobenius\n\nfp12_conjugate: t12 -> t12\nfp12_conjugate [a,b] = [f6.neg a, b] \/\/ a*w + b -> -a*w + b\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/CoreVerifyPKInG1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the function core_verify_pk_in_g1_impl that formally defines its expected behavior. The specification should capture the relationship between the public key, signature, message, domain separation tag, and augmentation data, and the verification result as a Boolean indicating signature validity. Include properties that verify the correctness of the pairing computations, hashing to the curve, and final exponentiation steps used in the implementation."},{"role":"assistant","content":"```cryptol\nmodule implementation::CoreVerifyPKInG1 where\n\nimport Parameters (Fp_12, t_Fp, t_Fp_2, BP, E')\nimport ShortWeierstrassCurve (AffinePoint, affinify)\nimport implementation::PairingImpl (miller_loop_opt)\nimport implementation::HashToG2 (hash_to_curve_E2_opt_impl)\nimport implementation::FinalExp (final_exponentiation_impl)\nimport implementation::PairingImpl (miller_loop_opt_checked)\nimport ExpandMessage\nimport Frobenius (fp12_conjugate)\nimport HashToCurveE2\n\ncore_verify_pk_in_g1_impl : {msg_len,dst_len,aug_len}\n  (fin msg_len, fin dst_len, fin aug_len\n  , Expandable (msg_len+aug_len) dst_len\n  , dst_len <= 255) =>\n  AffinePoint t_Fp -> AffinePoint t_Fp_2 -> [msg_len][8] -> [dst_len][8] -> [aug_len][8] -> Bool\n\ncore_verify_pk_in_g1_impl pk sig msg dst aug = Fp_12.is_equal(gt, Fp_12.field_unit) where\n    Q = affinify E' (hash_to_curve_E2_opt_impl (aug#msg, dst))\n    gtPQ = miller_loop_opt_checked pk Q\n    gtSig = fp12_conjugate (miller_loop_opt_checked BP sig)\n    gt = final_exponentiation_impl (Fp_12.mul (gtSig, gtPQ))\n\n\/* core_verify_pk_in_g1 : {msg_len,dst_len,aug_len} *\/\n  \/* (fin msg_len, fin dst_len, fin aug_len *\/\n  \/* , Expandable (msg_len+aug_len) dst_len *\/\n  \/* , dst_len <= 255) => *\/\n  \/* AffinePoint t_Fp -> AffinePoint t_Fp_2 -> [msg_len][8] -> [dst_len][8] -> [aug_len][8] -> Bool *\/\n\n\/* core_verify_pk_in_g1 pk sig msg dst aug = Fp_12.is_equal(c1, c2) where *\/\n    \/* c1 = bls_ate_pairing pk (hash_to_curve (aug#msg, dst)) *\/\n    \/* c2 = bls_ate_pairing BP sig *\/\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/SerializationP2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and safety of the deserialization functions for the curve E2 (E') in the given module. Specifically, specify properties that check: 1) the output of uncompress_E2_x and deserialize_E2_x correctly reconstruct the original field elements from the compressed and uncompressed byte representations; 2) the not_too_big_E2 predicate correctly identifies valid field elements within the prime field bounds; 3) uncompress_E2_imp returns a valid affine point or nothing according to the specification steps and bit flags; and 4) the relationship between the sign bits S_bit and Y_bit is correctly handled in uncompress_E2_OK. Include properties that ensure no invalid points are returned and that the deserialization respects the Montgomery encoding and field arithmetic constraints."},{"role":"assistant","content":"```cryptol\nmodule implementation::SerializationP2 where\n\nimport Parameters (p, E, E', t_Fp, to_Fp, t_Fp_2, Fp, Fp_2)\nimport ShortWeierstrassCurve as EC\nimport rfc8017\nimport Maybe\nimport FieldExtras (F_expt)\nimport BLSFieldExtras\nimport Serialization\nimport implementation::Types\nimport implementation::Field\n\n\/\/ deserialization of compressed representations for curve E2 (aka E').\n\/\/ From draft-irtf-cfrg-pairing-friendly-curves-07, Appendix C.2\n\nuncompress_E2_x: [96][8] -> [2][384]\nuncompress_E2_x s_string = x where\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    \/\/ Step 6 - but not clearly described in the IETF specification\n    \/\/ AND - some uncertainty about the order of the parts\n    \/\/ x = reverse (split`{parts=2} (join s_string'))\n    \/\/ NOTE: this order, used in ZCash and the code, disagrees with the spec.\n    x = split`{parts=2} (join s_string')\n\nuncompress_E2_x_fp: [96][8] -> t_Fp_2\nuncompress_E2_x_fp s_string = [f x0, f x1] where\n    [x0, x1] = uncompress_E2_x s_string\n    f x = Fp.mul (fp_abs (vec384_rep x), montgomery_factor_p) \/\/ Montgomery-encode using multiplication\n\nnot_too_big_E2: [2][384] -> Bool\nnot_too_big_E2 x = (x@0 < `p) \/\\ (x@1 < `p)\n\nuncompress_E2_y2: [96][8] -> t_Fp_2\nuncompress_E2_y2 s_string = y2 where\n    x = uncompress_E2_x_fp s_string\n    y2 = Fp_2.add (Fp_2.mul (Fp_2.sq x, x), [4,4]) \/\/ Note [4,4] = 4*u\n\nuncompress_E2_y: [96][8] -> t_Fp_2\nuncompress_E2_y s_string = sqrt_fp2 (uncompress_E2_y2 s_string)\n\nuncompress_E2_imp: [96][8] -> Maybe (EC::AffinePoint t_Fp_2)\nuncompress_E2_imp s_string = ret where\n    \/\/ Step 1.\n    m_byte = (s_string@0) && 0xE0 \/\/ three highest bits\n    C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    x = uncompress_E2_x_fp s_string\n    y2 = uncompress_E2_y2 s_string\n    y = sqrt_fp2 y2\n    Y_bit = sign_F_p_2 y\n    ret = if C_bit == False then nothing \/\/ Error, from Step 2\n           | I_bit then (if ~S_bit \/\\ s_string' == zero then just (EC::point_O E') else nothing)\n           | ~ (not_too_big_E2 (uncompress_E2_x s_string)) then nothing \/\/ extra checks in the C code\n           | ~ (is_square_fp2 y2) then nothing \/\/ from Step 7\n           | S_bit == Y_bit then just (x,y)\n          else just (x, Fp_2.neg y)\n\n\nuncompress_E2_OK: [96][8] -> EC::AffinePoint t_Fp_2\nuncompress_E2_OK s_string = if S_bit == Y_bit then (x,y) else (x, Fp_2.neg y) where\n    x = uncompress_E2_x_fp s_string\n    y = uncompress_E2_y s_string\n    S_bit = (s_string@0)@2\n    Y_bit = sign_F_p_2 y\n\n\/\/ deserialization of uncompressed representations\n\ndeserialize_E2_x: [2*96][8] -> [2][384]\ndeserialize_E2_x s_string = x where\n    s_string' = take`{96} ([(s_string@0) && 0x1F] # tail s_string)\n    x = reverse (split`{parts=2} (join s_string'))\n\n\/\/deserialize_E2_x_fp: [96][8] -> t_Fp_2\n\/\/deserialize_E2_x_fp s_string =\n\/\/    Fp.mul (fp_abs (vec384_rep (deserialize_E2_x s_string)), montgomery_factor_p)\n\ndeserialize_E2_y: [2*96][8] -> [2][384]\ndeserialize_E2_y s_string = reverse (split (join (drop`{96} s_string)))\n\n\/\/deserialize_E2_y_fp: [96][8] -> t_Fp_2\n\/\/deserialize_E2_y_fp s_string =\n\/\/    Fp.mul (fp_abs (vec384_rep (deserialize_E2_y s_string)), montgomery_factor_p)\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/Fp12.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol specifications and verification properties for the fp12_frobenius2, fp12_frobenius3, cyclotomic_sqr_fp12, fp12_mul, fp12_sqr, and inverse_fp12_imp functions defined in the Fp12 module. Your specifications should capture the algebraic properties expected of Frobenius maps, cyclotomic squaring, multiplication, squaring, and inversion in the Fp12 extension field. Include properties that verify correctness, such as consistency with field axioms, inverses, and expected behavior under composition. Ensure the properties are suitable for automated checking or proving in Cryptol."},{"role":"assistant","content":"```cryptol\n\/\/\n\/\/ Definitions for fp12_tower.c and the proofs in fp12.saw\n\/\/\n\nmodule implementation::Fp12 where\n\nimport Common::Field\nimport FieldExtras\nimport ExtensionField\nimport implementation::Types\nimport implementation::Field\nimport Parameters (p, Fp, t_Fp, to_Fp, from_Fp, t_Fp_2, Fp_2, t_Fp_6, Fp_6, t_Fp_12, Fp_12,\n                   u_plus_1, Fp_2_to_Fp_6)\nimport Frobenius\nimport PrimeField import ExtensionField\nimport Polynomial\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ Frobenius_map\n\n\/\/ \"nest\" is just used to simplify the writing of the postcondition for the\n\/\/ frobenius_map functions.  However, there is a simpler way, which is used for\n\/\/ frobenius_map_fp12.\nnest f x (n:[64]) =\n    if n==0 then x\n     | n == 1 then f x\n     | n == 2 then f (f x)\n    else f (f (f x))\n\n\n\/\/ constants for the various Frobenius maps\nrep_v_frobenius_constant = \/\/ fp2_rep v_frobenius_constant\n    [[0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000],\n     [0xcd03c9e48671f071, 0x5dab22461fcda5d2, 0x587042afd3851b95,\n      0x8eb60ebe01bacb9e, 0x03f97d6e83d050d2, 0x18f0206554638741]]\n\nrep_v_frobenius_constant_sq =  \/\/ fp2_rep v_frobenius_constant_sq\n    [[0x890dc9e4867545c3, 0x2af322533285a5d5, 0x50880866309b7e2c,\n      0xa20d1b8c7e881024, 0x14e4f04fe2db9068, 0x14e56d3f1564853a],\n     [0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000]]\n\nrep_v_frobenius_constant_sq_const_part =  \/\/ fp_rep (v_frobenius_constant!0)\n    [0x890dc9e4867545c3, 0x2af322533285a5d5, 0x50880866309b7e2c,\n     0xa20d1b8c7e881024, 0x14e4f04fe2db9068, 0x14e56d3f1564853a]\n\n\/\/ w_frobenius_constant has the form [0,0,c], so we can multiply easily using fp2_mul,\n\/\/ and do not need to store all the zeros\nrep_w_frobenius_constant_const_part = \/\/ fp2_rep (w_frobenius_constant!0)\n    [[0x07089552b319d465, 0xc6695f92b50a8313, 0x97e83cccd117228f,\n      0xa35baecab2dc29ee, 0x1ce393ea5daace4d, 0x08f2220fb0fb66eb],\n     [0xb2f66aad4ce5d646, 0x5842a06bfc497cec, 0xcf4895d42599d394,\n      0xc11b9cba40a8e8d0, 0x2e3813cbe5a0de89, 0x110eefda88847faf]]\n\n\/\/ The double Frobenius for fp6 and fp12 have similar formulas to the single\nv_frobenius_constant_2 = F_expt`{n=762} f2 u_plus_1 `((p*p-1)\/3)\nv_frobenius_constant_2_sq = Fp_2.sq v_frobenius_constant_2\n\nw_frobenius_constant_2_part = F_expt`{n=762} f2 u_plus_1 `((p*p-1)\/6)\n\nrep_v_frobenius_constant_2 =\n    [[0x30f1361b798a64e8, 0xf3b8ddab7ece5a2a, 0x16a8ca3ac61577f7,\n      0xc26a2ff874fd029b, 0x3636b76660701c6e, 0x051ba4ab241b6160],\n     [0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000]]\n\nrep_v_frobenius_constant_2_sq_const_part =\n    [0xcd03c9e48671f071, 0x5dab22461fcda5d2, 0x587042afd3851b95,\n     0x8eb60ebe01bacb9e, 0x03f97d6e83d050d2, 0x18f0206554638741]\n\nrep_w_frobenius_constant_2_const_part =\n    [[0xecfb361b798dba3a, 0xc100ddb891865a2c, 0x0ec08ff1232bda8e,\n      0xd5c13cc6f1ca4721, 0x47222a47bf7b5c04, 0x0110f184e51c5f59],\n     [0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000]]\n\nfp6_frobenius2 [a,b,c] = [a',b',c'] where\n    a' = f2.mul (v_frobenius_constant_2_sq, fp2_frobenius (fp2_frobenius a))\n    b' = f2.mul (v_frobenius_constant_2, fp2_frobenius (fp2_frobenius b))\n    c' = fp2_frobenius (fp2_frobenius c)\n\nfp12_frobenius2 [a,b] = [a',b'] where\n    a' = Fp_6.mul (Fp_2_to_Fp_6 w_frobenius_constant_2_part,\n                   fp6_frobenius (fp6_frobenius a))\n    b' = fp6_frobenius (fp6_frobenius b)\n\n\/\/ for triple Frobenius\nv_frobenius_constant_3 = F_expt`{n=1143} f2 u_plus_1 `((p*p*p-1)\/3)\nv_frobenius_constant_3_sq = Fp_2.sq v_frobenius_constant_3\n\nw_frobenius_constant_3_part = F_expt`{n=1143} f2 u_plus_1 `((p*p*p-1)\/6)\n\nrep_v_frobenius_constant_3 =\n    [[0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000],\n     [0x760900000002fffd, 0xebf4000bc40c0002, 0x5f48985753c758ba,\n      0x77ce585370525745, 0x5c071a97a256ec6d, 0x15f65ec3fa80e493]]\n\nrep_v_frobenius_constant_3_sq_const_part =\n    [0x43f5fffffffcaaae, 0x32b7fff2ed47fffd, 0x07e83a49a2e99d69,\n     0xeca8f3318332bb7a, 0xef148d1ea0f4c069, 0x040ab3263eff0206]\n\nrep_w_frobenius_constant_3_const_part =\n    [[0x3e2f585da55c9ad1, 0x4294213d86c18183, 0x382844c88b623732,\n      0x92ad2afd19103e18, 0x1d794e4fac7cf0b9, 0x0bd592fc7d825ec8],\n     [0x7bcfa7a25aa30fda, 0xdc17dec12a927e7c, 0x2f088dd86b4ebef1,\n      0xd1ca2087da74d4a7, 0x2da2596696cebc1d, 0x0e2b7eedbbfd87d2]]\n\nfp6_frobenius3 [a,b,c] = [a',b',c'] where\n    a' = f2.mul (v_frobenius_constant_3_sq, fp2_frobenius a)\n    b' = f2.mul (v_frobenius_constant_3, fp2_frobenius b)\n    c' = fp2_frobenius c\n\nfp12_frobenius3 [a,b] = [a',b'] where\n    a' = Fp_6.mul (Fp_2_to_Fp_6 w_frobenius_constant_3_part,\n                   fp6_frobenius (fp6_frobenius (fp6_frobenius a)))\n    b' = fp6_frobenius (fp6_frobenius (fp6_frobenius b))\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ Cyclotomic squaring\n\n\/* The \"cyclotomic squaring\" operation is described in\n   Robert Granger amd Michael Scott,\n   \"Faster Squaring in the Cyclotomic Subgroup of Sixth Degree Extensions\"\n   eprint.iacr.org\/2009\/565\n\n  This expresses a value in Fp_12 as a cubic expension of a quadratic extension,\n  whereas in most of blst we consider it as a quadratic extension of a cubic extension of Fp_2.\n  The Fp_4 we use here is used only for the purposes of this cyclotomic squaring operation.\n\n  Fp_4 = Fp_2[y]\/(y^2 - u - 1)\n  Fp_12 is isomorphic to Fp_4[x]\/(x^3 - y)\n\n  Noting that in the regular Fp_12 construction of the Parameters module, we have\n  v^3 = u+1 and w^2 = v, we have w^6 = u+1 and so (w^3)^2 = u+1.  So for the alternative\n  construction we have y = w^3 and x = w.\n*\/\n\ntype t_Fp_4 = [2]t_Fp_2\nFp_4 = extension_field Fp_2 [Fp_2.field_zero, u_plus_1]\ny_fp4: t_Fp_4\ny_fp4 = [Fp_2.field_unit, Fp_2.field_zero] \/\/ = poly_x Fp_4\n\nfp4_abs [x, y] = [fp2_abs y, fp2_abs x]\nfp4_rep [x, y] = [fp2_rep y, fp2_rep x]\n\ntype t_Fp_12_alt = [3]t_Fp_4\nFp_12_alt = extension_field Fp_4 [Fp_4.field_zero, Fp_4.field_zero, y_fp4]\n\n\/* In the standard tower, [[a,b,c],[d,e,f]] means\n  (av^2+bv+c)w + (dv^2+ev+f), which, given v = w^2, equals aw^5 + dw^4 + bw^3 + ew^2 + cw + f\n\n  In the alternative tower , [[A,B], [C,D], [E,F]] means\n  (Ay + B)x^2 + (Cy + D)x + (Ey + F),\n  and given y = w^3 and x = w, equals Aw^5 + Cw^4 + Ew^3 + Bw^2 + Dw + F\n\n  These two are equal iff A=a, B=e, C=d, D=c, E=b, and F=f\n*\/\n\nFp_12_to_Fp_12_alt: t_Fp_12 -> t_Fp_12_alt\nFp_12_to_Fp_12_alt [[a,b,c],[d,e,f]] = [[a,e], [d,c], [b,f]]\n\nFp_12_alt_to_Fp_12: t_Fp_12_alt -> t_Fp_12\nFp_12_alt_to_Fp_12 [[A,B], [C,D], [E,F]] = [[A,E,D], [C,B,F]]\n\nconjugate_fp4: t_Fp_4 -> t_Fp_4\nconjugate_fp4 [x,y] = [Fp_2.neg x, y]\n\n\/\/ definition from the paper\n\ncyclotomic_sqr_alt: t_Fp_12_alt -> t_Fp_12_alt\ncyclotomic_sqr_alt [c,b,a] = [C,B,A] where \/\/ paper has a+b+cx^2 and A + Bx + Cx^2\n    A = Fp_4.sub (x3 (Fp_4.sq a), x2 (conjugate_fp4 a))\n    B = Fp_4.add (x3 (Fp_4.mul (y_fp4, Fp_4.sq c)), x2 (conjugate_fp4 b))\n    C = Fp_4.sub (x3 (Fp_4.sq b), x2 (conjugate_fp4 c))\n    x2 x = Fp_4.add (x, x) \/\/ x+x = 2*x\n    x3 x = Fp_4.add (x, x2 x) \/\/ x + 2*x = 3*x\n\ncyclotomic_sqr_fp12: t_Fp_12 -> t_Fp_12\ncyclotomic_sqr_fp12 x =\n    Fp_12_alt_to_Fp_12 (cyclotomic_sqr_alt (Fp_12_to_Fp_12_alt x))\n\n\/\/ .. and as-implemented (in abstract space)\n\ncyclotomic_sqr_fp12_imp: t_Fp_12 -> t_Fp_12\ncyclotomic_sqr_fp12_imp [[a12, a11, a10], [a02, a01, a00]] = r where\n    \/\/ aij, tij, and rij names correspond to the indices of the implementation,\n    \/\/ i.e., reversed from abstract\n    [t01, t00] = Fp_4.sq [a11, a00]\n    [t11, t10] = Fp_4.sq [a02, a10]\n    [t21, t20] = Fp_4.sq [a12, a01]\n    r00 = f_sub t00 a00\n    r01 = f_sub t10 a01\n    r02 = f_sub t20 a02\n\n    r10 = f_add (Fp_2.mul (u_plus_1, t21)) a10\n    r11 = f_add t01 a11\n    r12 = f_add t11 a12\n\n    r = [[r12, r11, r10], [r02, r01, r00]]\n    f_sub x y = Fp_2.add (s, Fp_2.add (s, x)) where s = Fp_2.sub (x, y)\n    f_add x y = Fp_2.add (s, Fp_2.add (s, x)) where s = Fp_2.add (x, y)\n\nsqr_fp4_imp a0 a1 = [ret1, ret0] where\n    t0 = Fp_2x2.sq a0 \/\/ sqr_fp2x2(t0, a0);\n    t1 = Fp_2x2.sq a1 \/\/ sqr_fp2x2(t1, a1);\n    t3 = Fp_2.add (a0, a1)     t2 = Fp_2x2.mul (t1, u_plus_1x2)     ret0 = Fp_2x2.add (t2, t0)     t2_b = Fp_2x2.sq t3     ret1 = Fp_2x2.sub (Fp_2x2.sub (t2_b, t0), t1) \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ mul_fp6, mul_fp12, and friends\n\/\/\n\/\/ Some of the action takes place in rings:\n\/\/ Fpx2: Integers mod 2^384 * p\n\/\/ Fp2x2: Fpx2[x] \/ (x^2+1), a quotient ring.\n\/\/ etc.\n\/\/\n\/\/ We fake the rings by using the field constructors, and taking care never to call `half` or `div`\n\/\/\n\/\/ It would be a big rewrite to introduce a Ring structure (like Field), define polynomials over rings,\n\/\/ and have the projection for fields to rings where needed, but in the end it would be a bit neater.\n\nFpx2 = prime_field_integer (`p * 2^^384 )\n\nFp_2x2 = extension_field Fpx2 [Fpx2.field_zero, Fpx2.neg Fpx2.field_unit] \/\/ [0,-1]\nu_plus_1x2: t_Fp_2x2\nu_plus_1x2 = Fp_2x2.add (poly_x Fpx2, poly_1 Fpx2)\n\nFp_6x2 = extension_field Fp_2x2 [Fp_2x2.field_zero, Fp_2x2.field_zero, u_plus_1x2]\n\n\/\/ \"optimised\" form for a1 b2 + a2 b1\n\/\/ (a1+a2)(b1 + b2) - a1 b1 - a2 b2\nfp6x2_tmp a1 a2 b1 b2 = Fp_2x2.sub (Fp_2x2.sub (t, Fp_2x2.mul (a1, b1)), Fp_2x2.mul (a2, b2)) where\n  t = Fp_2x2.mul (Fp_2.add (a1,a2), Fp_2.add (b1, b2))\n\nfp6x2_mul: [3][2]Integer -> [3][2]Integer -> [3][2]Integer\nfp6x2_mul [a2, a1, a0] [b2, b1, b0] = [r2, r1, r0] where\n  r0 = Fp_2x2.add (Fp_2x2.mul (fp6x2_tmp a1 a2 b1 b2, u_plus_1x2), Fp_2x2.mul (a0, b0))\n  r1 = Fp_2x2.add (fp6x2_tmp a0 a1 b0 b1, Fp_2x2.mul (Fp_2x2.mul (a2, b2), u_plus_1x2))\n  r2 = Fp_2x2.add (fp6x2_tmp a0 a2 b0 b2, Fp_2x2.mul (a1, b1))\n\n\/\/ mul_fp12 \"as implemented\", but without the final \"redc\"\n\/\/ ...  but in the abstract space, so all our indexing is backwards\n\n\/\/ \"optimised\" form for a0 b1 + a1 b0\n\/\/ (a0+a1)(b0 + b1) - a0 b0 - a1 b1\n\nfp12_mul_1 a0 a1 b0 b1 = Fp_6x2.sub (Fp_6x2.sub (t, fp6x2_mul a0  b0), fp6x2_mul a1 b1) where\n  t = fp6x2_mul (Fp_6.add (b0,b1)) (Fp_6.add (a0, a1))\n\n\/* original definition:\nfp12_mul_0 a0 a1 b0 b1 = [rx2, rx1, rx0] where\n  t0 = Fp_6x2.mul (a0, b0)\n  t1 = Fp_6x2.mul (a1, b1)\n  rx2 = Fp_2x2.add (t0!2, t1!1)\n  rx1 = Fp_2x2.add (t0!1, t1!0)\n  rx0 = Fp_2x2.add (t0!0, Fp_2x2.mul (t1!2, u_plus_1x2))\n*\/\n\/\/ better SAWcore terms result if we use destructuring binds rather than indexing:\nfp12_mul_0 a0 a1 b0 b1 = [rx2, rx1, rx0] where\n  [t0_2, t0_1, t0_0] = fp6x2_mul a0 b0\n  [t1_2, t1_1, t1_0] = fp6x2_mul a1 b1\n  rx2 = Fp_2x2.add (t0_2, t1_1)\n  rx1 = Fp_2x2.add (t0_1, t1_0)\n  rx0 = Fp_2x2.add (t0_0, Fp_2x2.mul (t1_2, u_plus_1x2))\n\nfp12_mul: [2][3][2]Integer -> [2][3][2]Integer -> [2][3][2]Integer\nfp12_mul [a1, a0] [b1, b0] = [r1, r0] where\n  r0 = fp12_mul_0 a0 a1 b0 b1\n  r1 = fp12_mul_1 a0 a1 b0 b1\n\n\/\/ The as-implemented sqr_fp12 algorithm, in our abstractspace and so wih indexing\n\/\/ reversed from the code:\n\nfp12_sqr: t_Fp_12 -> t_Fp_12\nfp12_sqr a = ret where\n    [a1, a0] = a\n    [a12, a11, a10] = a1\n    [a02, a01, a00] = a0\n\n    t0 = Fp_6.add (a0, a1)                   t12 = Fp_2.mul (u_plus_1, a12)       \/\/ mul_by_u_plus_1_fp2(t1[2], a[1][2]);\n    t1 = [ Fp_2.add (a02, a11)           \/\/  \/- add_fp2(t1[0], a[0][0], t1[2]);\n         , Fp_2.add (a01, a10)           \/\/ <|-  add_fp2(t1[1], a[0][1], a[1][0]);\n         , Fp_2.add (a00, t12)]          \/\/  \\- add_fp2(t1[2], a[0][2], a[1][1]);\n    t0_a = Fp_6.mul (t0, t1)             \/\/ mul_fp6(t0, t0, t1);\n    t1_a = Fp_6.mul (a0, a1)             \/\/ mul_fp6(t1, a[0], a[1]);\n    [t12_a, t11_a, t10_a] = t1_a\n\n    r1 = Fp_6.add (t1_a, t1_a)           \/\/ add_fp6(ret[1], t1, t1);\n    [r02, r01, r00] = Fp_6.sub (t0_a, t1_a) \/\/ sub_fp6(ret[0], t0, t1);\n\n    t12_b = Fp_2.mul (u_plus_1, t12_a)   \/\/ mul_by_u_plus_1_fp2(t1[2], t1[2]);\n\n    r00_a = Fp_2.sub (r00, t12_b)            r01_a = Fp_2.sub (r01, t10_a)            r02_a = Fp_2.sub (r02, t11_a)            ret = [r1, [r02_a, r01_a, r00_a]]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ mul_by_xy00z0\n\/\/\n\nxy00z0_expander: Fp_6_rep_t -> Fp_12_rep_t\nxy00z0_expander [x,y,z] = [[x, y, zero], [zero, z, zero]] \/\/ in rep space\n\nfp6_to_fp12_xy00z0: t_Fp_6 -> t_Fp_12\nfp6_to_fp12_xy00z0 [z,y,x] = [[zero, z, zero], [zero, y, x]] \/\/ in abs space, reversed.\n\n\nmul_by_0y0_fp6x2: t_Fp_6 -> t_Fp_2 -> t_Fp_6\nmul_by_0y0_fp6x2 a b = [r2, r1, r0] where\n    [a2,a1,a0] = a\n    t = Fp_2x2.mul (a2, b)\n    r0 = Fp_2x2.mul (t, u_plus_1x2)\n    r1 = Fp_2x2.mul (a0, b)\n    r2 = Fp_2x2.mul (a1, b)\n\nmul_by_xy0_fp6x2: t_Fp_6 -> t_Fp_2 -> t_Fp_2 -> t_Fp_6\nmul_by_xy0_fp6x2 a b1 b0 = [r2_a, r1_b, r0_a] where\n    [a2, a1, a0] = a\n    t0 = Fp_2x2.mul (a0, b0)         t1 = Fp_2x2.mul (a1, b1)     \/\/ mul_fp2x2(t1, a[1], b[1]);\n\n    t2 = Fp_2x2.mul (a2, b1)     \/\/ mul_fp2x2(ret[1], a[2], b[1]);  (renaming to t2 here)\n    r0 = Fp_2x2.mul (t2, u_plus_1x2) \/\/ mul_by_u_plus_1_fp2x2(ret[0], ret[1]);\n    r0_a = Fp_2x2.add (r0, t0)   \/\/ add_fp2x2(ret[0], ret[0], t0);\n\n    aa = Fp_2.add (a0, a1)       \/\/ add_fp2(aa, a[0], a[1]);\n    bb = Fp_2.add (b0, b1)       \/\/ add_fp2(bb, b[0], b[1]);\n    r1 = Fp_2x2.mul (aa, bb)     \/\/ mul_fp2x2(ret[1], aa, bb);\n    r1_a = Fp_2x2.sub (r1, t0)   \/\/ sub_fp2x2(ret[1], ret[1], t0);\n    r1_b = Fp_2x2.sub (r1_a, t1) \/\/ sub_fp2x2(ret[1], ret[1], t1);\n\n    r2 = Fp_2x2.mul (a2, b0)     \/\/ mul_fp2x2(ret[2], a[2], b[0]);\n    r2_a = Fp_2x2.add (r2, t1)   \/\/ add_fp2x2(ret[2], ret[2], t1);\n\nmul_by_xy00z0_fp12: t_Fp_12 -> t_Fp_6 -> t_Fp_12\nmul_by_xy00z0_fp12 a xy00z0 = [r1_a, r0] where\n    [a1, a0] = a\n    [b2, b1, b0] = xy00z0\n    t0 =  mul_by_xy0_fp6x2 a0 b1 b0     \/\/ mul_by_xy0_fp6x2(t0, a[0], xy00z0);\n    t1 = mul_by_0y0_fp6x2 a1 b2         \/\/ mul_by_0y0_fp6x2(t1, a[1], xy00z0[2]);\n\n    t2_0 = b0                           \/\/ vec_copy(t2[0], xy00z0[0], sizeof(t2[0]));\n    t2_1 = Fp_2.add (b1, b2)            \/\/ add_fp2(t2[1], xy00z0[1], xy00z0[2]);\n    r1 = Fp_6.add (a0, a1)              \/\/ add_fp6(ret[1], a[0], a[1]);\n    rr = mul_by_xy0_fp6x2 r1 t2_1 t2_0      rr_a = Fp_6x2.sub (rr, t0)              rr_b = Fp_6x2.sub (rr_a, t1)            r1_a = rr_b                             [t0_2, t0_1, t0_0] = t0\n    [t1_2, t1_1, t1_0] = t1\n    rr0 = Fp_2x2.mul (t1_2, u_plus_1x2)     rr0_a = Fp_2x2.add (t0_0, rr0)          rr1 = Fp_2x2.add (t0_1, t1_0)           rr2 = Fp_2x2.add (t0_2, t1_1)           r0 = [rr2, rr1, rr0_a]              \/\/ redc_fp6x2(ret[0], rr);\n\ninverse_fp2_imp: t_Fp_2 -> t_Fp_2\ninverse_fp2_imp [a1,a0] = [r1,r0] where\n    t = Fp.div(Fp.field_unit, Fp.add (Fp.sq a0, Fp.sq a1))\n    r0 = Fp.mul (a0,t)\n    r1 = Fp.neg (Fp.mul (a1,t))\n\ninverse_fp6_imp: t_Fp_6 -> t_Fp_6\ninverse_fp6_imp [a2,a1,a0] = [r2,r1,r0] where \n    c0 = Fp_2.sub (Fp_2.sq a0, Fp_2.mul (u_plus_1,Fp_2.mul (a1,a2)))\n    c1 = Fp_2.sub (Fp_2.mul (u_plus_1, Fp_2.sq a2), Fp_2.mul(a0,a1))\n    c2 = Fp_2.sub (Fp_2.sq a1, Fp_2.mul (a0, a2))\n    t0 = Fp_2.add (Fp_2.mul (c1, a2), Fp_2.mul (c2, a1))\n    t1 = Fp_2.add (Fp_2.mul (u_plus_1, t0), Fp_2.mul (c0, a0))\n    t  = inverse_fp2_imp t1 \/\/ or  Fp_2.div(Fp_2.field_unit, t1)\n    r2 = Fp_2.mul(c2, t)\n    r1 = Fp_2.mul(c1, t)\n    r0 = Fp_2.mul(c0, t)\n\ninverse_fp12_imp: t_Fp_12 -> t_Fp_12\ninverse_fp12_imp [a1,a0] = [r1,r0] where\n    [t0_2, t0_1, t0_0]  = Fp_6.sq a0 \/\/ sqr_fp6(t0, a[0]);\n    [t1_2, t1_1, t1_0] = Fp_6.sq a1  \/\/ sqr_fp6(t1, a[1]);\n    t1_2a = Fp_2.mul (t1_2, u_plus_1) \/\/ mul_by_u_plus_1_fp2(t1[2], t1[2]);\n    t0_0a = Fp_2.sub (t0_0, t1_2a)      t0_1a = Fp_2.sub (t0_1, t1_0)       t0_2a = Fp_2.sub (t0_2, t1_1)       t1_a = inverse_fp6_imp [t0_2a, t0_1a, t0_0a]     r0 = Fp_6.mul (a0, t1_a)            r1 = Fp_6.neg (Fp_6.mul (a1, t1_a)) sqr_fp6_imp: t_Fp_6 -> t_Fp_6\nsqr_fp6_imp a = ret where\n    [a2, a1, a0] = a\n    s0 = Fp_2x2.mul (a0, a0)     m01 = Fp_2x2.mul (a0, a1)     m01_a = Fp_2x2.add (m01, m01)     m12 = Fp_2x2.mul (a1, a2)     m12_a = Fp_2x2.add (m12, m12)     s2 = Fp_2x2.mul (a2,a2)     \/* ret[2] = (a0 + a1 + a2)^2 - a0^2 - a2^2 - 2*(a0*a1) - 2*(a1*a2)\n              = a1^2 + 2*(a0*a2) *\/\n    ret2 = Fp_2.add (a2, a1)     ret2_a = Fp_2.add (ret2, a0)     rx = Fp_2x2.mul (ret2_a, ret2_a)     rx_a = Fp_2x2.sub (rx, s0)     rx_b = Fp_2x2.sub (rx_a, s2)     rx_c = Fp_2x2.sub (rx_b, m01_a)     rx_d = Fp_2x2.sub (rx_c, m12_a)     ret2_b = rx_d \/\/ we apply redc outside this Cryptol function \/\/  redc_fp2x2(ret[2], rx);\n\n    \/* ret[0] = a0^2 + 2*(a1*a2)*(u+1) *\/\n    rx_e = Fp_2x2.mul (m12_a, u_plus_1x2) \/\/  mul_by_u_plus_1_fp2x2(rx, m12);\n    rx_f = Fp_2x2.add (rx_e, s0)     ret0 = rx_f     \/* ret[1] = a2^2*(u+1) + 2*(a0*a1) *\/\n    rx_g = Fp_2x2.mul (s2, u_plus_1x2)     rx_h = Fp_2x2.add (rx_g, m01_a)     ret1 = rx_h     ret = [ret2_b, ret1, ret0]\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/CoreVerifyPKInG2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the function core_verify_pk_in_g2_impl. The specification should capture the relationship between the inputs (public key in G2, signature in G1, message, domain separation tag, and augmentation data) and the output Boolean indicating signature validity. Include properties that verify the correctness of the pairing computations, hashing to the curve, and final exponentiation steps used in the verification process."},{"role":"assistant","content":"```cryptol\nmodule implementation::CoreVerifyPKInG2 where\n\nimport Parameters (Fp_12, t_Fp, t_Fp_2, BP', E)\nimport ShortWeierstrassCurve (AffinePoint, affinify)\nimport implementation::PairingImpl (miller_loop_opt)\nimport implementation::HashToG1 (hash_to_curve_opt_impl)\nimport implementation::FinalExp (final_exponentiation_impl)\nimport implementation::PairingImpl (miller_loop_opt_checked)\nimport ExpandMessage\nimport Frobenius (fp12_conjugate)\nimport HashToCurveE1\n\ncore_verify_pk_in_g2_impl : {msg_len,dst_len,aug_len}\n  (fin msg_len, fin dst_len, fin aug_len\n  , Expandable (msg_len+aug_len) dst_len\n  , dst_len <= 255) =>\n  AffinePoint t_Fp_2 -> AffinePoint t_Fp -> [msg_len][8] -> [dst_len][8] -> [aug_len][8] -> Bool\n\ncore_verify_pk_in_g2_impl pk sig msg dst aug = Fp_12.is_equal(gt, Fp_12.field_unit) where\n    Q = affinify E (hash_to_curve_opt_impl (aug#msg, dst))\n    gtPQ = miller_loop_opt_checked Q pk\n    gtSig = fp12_conjugate (miller_loop_opt_checked sig BP')\n    gt = final_exponentiation_impl (Fp_12.mul (gtSig, gtPQ))\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/SerializationP1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness and consistency of the deserialization and uncompression functions in the module implementation::serialization. Specifically, specify properties that ensure: 1) uncompress_E1_imp correctly reconstructs valid affine points or returns nothing for invalid inputs; 2) uncompress_E1_OK returns points consistent with uncompress_E1_imp when inputs are valid; 3) deserialize_E1_x_fp and deserialize_E1_y_fp correctly convert serialized byte arrays into field elements consistent with uncompress_E1_x_fp and uncompress_E1_y respectively; and 4) the relationships between compressed and uncompressed representations hold as expected. Include checks for boundary conditions and error cases as indicated in the code comments."},{"role":"assistant","content":"```cryptol\nmodule implementation::serialization where\n\nimport Parameters (p, E, E', t_Fp, to_Fp, t_Fp_2, Fp, Fp_2)\nimport ShortWeierstrassCurve as EC\nimport rfc8017\nimport Maybe\nimport FieldExtras (F_expt)\nimport BLSFieldExtras\nimport Serialization\nimport implementation::Types\nimport implementation::Field\n\n\/\/ deserialization of compressed representations\n\nuncompress_E1_x: [48][8] -> [384]\nuncompress_E1_x s_string = x where\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    \/\/ Step 6\n    x = join s_string' \/\/ OS2IP(s_string')\n\nuncompress_E1_x_fp: [48][8] -> t_Fp\nuncompress_E1_x_fp s_string =\n    Fp.mul (fp_abs (vec384_rep (uncompress_E1_x s_string)), montgomery_factor_p)\n\nuncompress_E1_y2: [48][8] -> t_Fp\nuncompress_E1_y2 s_string = y2 where\n    \/\/ x = to_Fp (uncompress_E1_x s_string)\n    x = Fp.mul ( fp_abs (vec384_rep (uncompress_E1_x s_string))\n               , montgomery_factor_p) \/\/ we will prove this = to_Fp ...\n    y2 = Fp.add (Fp.mul (Fp.sq x, x), 4)\n\nuncompress_E1_y: [48][8] -> t_Fp\nuncompress_E1_y s_string = sqrt_fp (uncompress_E1_y2 s_string)\n\nuncompress_E1_imp: [48][8] -> Maybe (EC::AffinePoint t_Fp)\nuncompress_E1_imp s_string = ret where\n    \/\/ Step 1.\n    m_byte = (s_string@0) && 0xE0 \/\/ three highest bits\n    C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    x = uncompress_E1_x_fp s_string\n    y2 = uncompress_E1_y2 s_string\n    y = sqrt_fp y2\n    Y_bit = sign_F_p y\n    ret = if C_bit == False then nothing \/\/ Error, from Step 2\n           | I_bit then (if ~S_bit \/\\ s_string' == zero then just (EC::point_O E) else nothing)\n           | uncompress_E1_x s_string >= `p then nothing \/\/ extra check in the C code\n           | ~ (is_square_fp y2) then nothing \/\/ from Step 7\n           | S_bit == Y_bit then just (x,y)\n          else just (x, Fp.neg y)\n\n\nuncompress_E1_OK: [48][8] -> EC::AffinePoint t_Fp\nuncompress_E1_OK s_string = if S_bit == Y_bit then (x,y) else (x, Fp.neg y) where\n    x = uncompress_E1_x_fp s_string\n    y = uncompress_E1_y s_string\n    S_bit = (s_string@0)@2\n    Y_bit = sign_F_p y\n\n\/\/ deserialization of uncompressed representations\n\ndeserialize_E1_x: [96][8] -> [384]\ndeserialize_E1_x s_string = x where\n    s_string' = take`{48} ([(s_string@0) && 0x1F] # tail s_string)\n    x = join s_string'\n\ndeserialize_E1_x_fp: [96][8] -> t_Fp\ndeserialize_E1_x_fp s_string =\n    Fp.mul (fp_abs (vec384_rep (deserialize_E1_x s_string)), montgomery_factor_p)\n\ndeserialize_E1_y: [96][8] -> [384]\ndeserialize_E1_y s_string = join (drop`{48} s_string)\n\ndeserialize_E1_y_fp: [96][8] -> t_Fp\ndeserialize_E1_y_fp s_string =\n    Fp.mul (fp_abs (vec384_rep (deserialize_E1_y s_string)), montgomery_factor_p)\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/HashToG1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the functions in the HashToG1 module, including map_to_curve_simple_swu_impl, isogeny_map_to_E1_impl, clear_cofactor_impl, and hash_to_curve_opt_impl. The properties should capture the expected mathematical behavior of these functions, such as ensuring that map_to_curve_simple_swu_impl maps field elements to points on the curve, isogeny_map_to_E1_impl correctly applies the isogeny map, clear_cofactor_impl clears the cofactor of points, and hash_to_curve_opt_impl produces valid curve points from messages and domain separation tags. Include properties to check consistency of intermediate computations and correctness of point operations used in the implementation."},{"role":"assistant","content":"```cryptol\nmodule implementation::HashToG1 where\n\nimport Parameters (Fp, t_Fp)\nimport ShortWeierstrassCurve (ProjectivePoint)\nimport BLSFieldExtras (sqrt_fp)\nimport ExpandMessage (Expandable)\nimport implementation::CurveOperation (point_dadd, point_add, point_double)\nimport HashToCurveE1\nimport HashToCurveE1Aux as Aux\n\n\/\/ the SWU map\n\n\/\/ This is what the implementation does:\nmap_to_curve_simple_swu_impl : t_Fp -> ProjectivePoint t_Fp\nmap_to_curve_simple_swu_impl u = res where\n  c2 = sqrt (Fp.neg (Fp.mul (Fp.sq Z, Z))) \/\/ sqrt(-Z^3)\n\n  \/\/ x numerator\n  tv1 = Fp.sq u\n  tv3 = Fp.mul (Z, tv1)\n  tv2 = Fp.add (Fp.sq tv3, tv3)\n  x1n = Fp.mul (Fp.add (tv2, Fp.field_unit), B')\n  x2n = Fp.mul(tv3, x1n)\n\n  \/\/ x denumerator\n  xd = Fp.mul(Fp.neg A', tv2)\n  e1 = Fp.is_equal(xd, Fp.field_zero)\n  xd_b = if e1 then Fp.mul(Z, A') else xd\n\n  \/\/ y numerator\n  tv2_a = Fp.sq xd_b\n  gxd = Fp.mul(xd_b, tv2_a)\n  tv2_b = Fp.mul(A',  tv2_a)\n  gx1 = Fp.sq x1n\n  gx1_a = Fp.add(gx1, tv2_b)\n  gx1_b = Fp.mul(gx1_a,  x1n)\n  tv2_c = Fp.mul(B', gxd)\n  gx1_c = Fp.add(gx1_b, tv2_c)\n  tv4 = Fp.sq gxd\n  tv2_d = Fp.mul (gx1_c, gxd)\n  tv4_b = Fp.mul (tv4, tv2_d)\n  y1 = Fp.div (Fp.field_unit, sqrt_fp tv4_b) \/\/ note this is an exponentiation in the spec\n  e2 = Fp.is_equal (Fp.sq (Fp.mul (y1, tv4_b)), tv4_b) \/\/ this appears in the body of recip_sqrt\n  y1_b = Fp.mul(y1, tv2_d)\n\n  y2 = Fp.mul(y1_b, c2)\n  y2_b = Fp.mul(y2, tv1)\n  y2_c = Fp.mul(y2_b, u)\n\n  xn = if e2 then  x1n else x2n\n  y = if e2 then y1_b else y2_c\n\n  y_a = if sgn0(u) != sgn0(y) then Fp.neg y else y\n\n  \/\/ convert to Jacobian coordinates:\n  res = (Fp.mul (xn, xd_b), Fp.mul (y_a, gxd), xd_b)\n\n\/\/ isogeny_map_to_E1\n\nisogeny_map_to_E1_impl: ProjectivePoint t_Fp -> ProjectivePoint t_Fp\nisogeny_map_to_E1_impl (X, Y, Z) = to_jacobian xn xd yn yd where\n  zzs = Zz_powers Z\n  xn = map_fp (kzzs#[last Aux::k1s]) X where\n    kzzs = map_fp_times_Zz`{n=11} Aux::k1s zzs\n  xd = Fp.mul (xs, last zzs) where\n    xs = map_fp ((take`{front=9}kzzs)#[xkzz9]) X\n    xkzz9 = Fp.add (X, last kzzs)\n    kzzs = map_fp_times_Zz`{n=10} Aux::k2s zzs\n  yn = Fp.mul (map_fp (kzzs#[last Aux::k3s]) X, Y) where\n    kzzs = map_fp_times_Zz`{n=15} Aux::k3s zzs\n  yd = Fp.mul (Fp.mul (xs, Z), last zzs) where\n    xs = map_fp ((take`{front=14}kzzs)#[xkzz14]) X\n    xkzz14 = Fp.add (X, last kzzs)\n    kzzs = map_fp_times_Zz`{n=15} Aux::k4s zzs\n\nZz_powers : t_Fp -> [15]t_Fp \/\/ powers of ZZ in descending order\nZz_powers Z = reverse (take`{front=15} zzs) where\n    zzs = [Fp.sq Z, Fp.sq (Fp.sq Z)]\n      # (join`{parts=inf} [[Fp.mul (zi0, zi1), Fp.sq zi1] | zi0 <- zzs | zi1 <- tail zzs]) map_fp_times_Zz : {m1,m2,n} (fin n, fin m2, m1 >= n, m2 >= n) => [m1]t_Fp -> [m2]t_Fp -> [n]t_Fp\nmap_fp_times_Zz ks zzs = zipWith (curry Fp.mul) (take`{front=n}ks) (drop`{back=n}zzs)\n\nmap_fp kzzs x = last rs where\n  rs = [last kzzs] # [Fp.add (Fp.mul (ri, x), kzzi) | kzzi <- tail (reverse kzzs) | ri <- rs]\n\n\/\/ NOTE: this does not follow jacobian_to_projective_pair in G2SubGroupCheck.cry\nto_jacobian xn xd yn yd = (X, Y, Z) where\n  Z = Fp.mul (xd, yd)\n  X = Fp.mul (Fp.mul (xn, yd) , Z)\n  Y = Fp.mul (Fp.mul (Fp.sq Z, xd) , yn)\n\ndbl_n_add: ProjectivePoint t_Fp -> Integer -> ProjectivePoint t_Fp -> ProjectivePoint t_Fp\ndbl_n_add out n p = point_dadd Fp (db n out) p Fp.field_zero True where\n  db: Integer -> ProjectivePoint t_Fp -> ProjectivePoint t_Fp\n  db k x =\n    if k == 1 then point_double Fp x\n    else point_double Fp (db (k-1) x)\n\nclear_cofactor_impl: ProjectivePoint t_Fp -> ProjectivePoint t_Fp\nclear_cofactor_impl p = out where\n  out1 = point_double Fp p\n  out2 = point_add Fp out1 p \/\/ NOTE: this is okay because (point_double p) != p or both are point_O\n  out3 = dbl_n_add out2 2 p\n  out4 = dbl_n_add out3 3 p\n  out5 = dbl_n_add out4 9 p\n  out6 = dbl_n_add out5 32 p\n  out = dbl_n_add out6 16 p\n\nhash_to_curve_opt_impl: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384\n               ) =>\n               ([msg_len][8], [DST_len][8]) -> ProjectivePoint t_Fp\nhash_to_curve_opt_impl (msg,dst) = map_to_g1_impl u where\n    u = hash_to_field`{count=2} msg dst\n\nmap_to_g1_impl: [2]t_Fp -> ProjectivePoint t_Fp\nmap_to_g1_impl uv = P where\n    Q0 = map_to_curve_simple_swu_impl (uv@0)\n    Q1 = map_to_curve_simple_swu_impl (uv@1)\n    R = point_dadd Fp Q0 Q1 A' False \/\/ This is addition on the isogenous curve E'\n    S = isogeny_map_to_E1_impl R\n    P = clear_cofactor_impl S\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/FinalExp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the `final_exponentiation_impl` function in the `implementation::FinalExp` module. The properties should ensure that `final_exponentiation_impl` correctly computes the final exponentiation on elements of type `P::t_Fp_12`, respecting the cyclotomic subgroup constraints and matching the mathematical definition of the final exponentiation in pairing-based cryptography. Include checks that the input is in the cyclotomic subgroup, that exponentiation handles negative exponents correctly via conjugation, and that the output satisfies expected algebraic properties."},{"role":"assistant","content":"```cryptol\nmodule implementation::FinalExp where\n\nimport FieldExtras\nimport Frobenius\nimport HashToCurveE2Aux\nimport Pairing\nimport Parameters as P\n\nimport implementation::Fp12\n\n\/\/ If x is in the cyclotomic subgroup, then x^(cyclotomic_exponent_modulus) = 1\ntype cyclotomic_exponent_modulus = P::p^^4 - P::p^^2 + 1\n\n\/\/ An integer representation of the constant `z`\nint_z = -pos_c1\n\n\/\/ Small final exponent from the implementation\nsmall_final_e_imp : Integer\nsmall_final_e_imp = `P::p^^27 +\n                    2*`P::p^^21*int_z +\n                    `P::p^^19 +\n                    `P::p^^18*int_z +\n                    `P::p^^15*int_z^^2 +\n                    `P::p^^14*int_z +\n                    `P::p^^13*int_z^^2 +\n                    2*`P::p^^13*int_z +\n                    `P::p^^12*int_z^^3 +\n                    2*`P::p^^12*int_z^^2 +\n                    2*`P::p^^8*int_z^^2 +\n                    2*`P::p^^7*int_z^^3 +\n                    `P::p^^7*int_z^^2 +\n                    2*`P::p^^6*int_z^^4 +\n                    `P::p^^6*int_z^^3 +\n                    `P::p^^2*int_z^^3 +\n                    `P::p*int_z^^4 +\n                    int_z^^5 +\n                    3\n\n\/\/ An exponential function that supports negative exponents.  Uses\n\/\/ fp12_conjugate to compute the inverse of x, so x must be in the cyclotomic\n\/\/ subgroup if e is negative.\nC_expt: P::t_Fp_12 -> Integer -> P::t_Fp_12\nC_expt b e = if e >= 0 then x else fp12_conjugate x where\n  \/\/ Use 16384 bits because thats the smallest \"round\" number that fits\n  \/\/ small_final_e_imp.\n  x = F_expt`{P::t_Fp_12, 16384} P::Fp_12 b (abs e)\n\nfinal_exponentiation_impl: P::t_Fp_12 -> P::t_Fp_12\nfinal_exponentiation_impl x = C_expt (final_exp_frobenius_map x) small_final_e_imp\n\n\/\/ Repeatedly square `x`.  `x` must be in the cyclotomic subgroup.\nchain_cyclotomic_sqr_fp12: {n} (fin n, n >= 1) => P::t_Fp_12 -> P::t_Fp_12\nchain_cyclotomic_sqr_fp12 x = acc ! 0 where\n  acc = [x] # [ cyclotomic_sqr_fp12 y | y <- acc | z <- [1..n]]\n\n\/\/ Multiply `ret` by `a`, then square the result `n` times.  `ret * a` must be\n\/\/ in the cyclotomic subgroup.\nmul_n_sqr: {n} (fin n, n >= 1) => P::t_Fp_12 -> P::t_Fp_12 -> P::t_Fp_12\nmul_n_sqr ret a = chain_cyclotomic_sqr_fp12`{n} (P::Fp_12.mul (ret, a))\n\n\/\/ Compute x^(z\/2).\nraise_to_z_div_by_2: P::t_Fp_12 -> P::t_Fp_12\nraise_to_z_div_by_2 x = C_expt x (int_z \/ 2)\n\n\/\/ True iff `x` is in the cyclotomic subgroup.\nis_cyclotomic: P::t_Fp_12 -> Bit\nis_cyclotomic x = C_expt x `cyclotomic_exponent_modulus == P::Fp_12.field_unit\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/HashToG2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the `map_to_isogenous_E2_impl` and `map_to_g2_impl` functions in the `HashToG2` module. The specification should capture the mathematical properties of the isogeny mapping and cofactor clearing on the elliptic curve over the field extension `t_Fp_2`. Additionally, write verification properties or lemmas that prove the correctness of the `clear_cofactor_E2_impl` function, ensuring that the output point lies in the correct subgroup. The specification should enable formal verification that the implementation matches the mathematical hash-to-curve standard for G2."},{"role":"assistant","content":"```cryptol\nmodule implementation::HashToG2 where\n\nimport FieldExtras (F_is_zero, F_sum, F_prod, F_expt)\nimport BLSFieldExtras (sqrt_align_fp2_coeff)\nimport Parameters (Fp_2, t_Fp_2, u)\nimport ShortWeierstrassCurve (ProjectivePoint, point_O, projectify)\nimport ExpandMessage (Expandable)\nimport implementation::CurveOperation (point_dadd, point_add, point_double, point_neg)\nimport HashToCurveE2\nimport HashToCurveE2Aux as Aux\nimport implementation::Psi\n\nmap_to_isogenous_E2_impl : t_Fp_2 -> ProjectivePoint t_Fp_2\nmap_to_isogenous_E2_impl u = res where\n  \/\/ x1n, x2n, and xd:\n  Zuu = Fp_2.mul (Z, Fp_2.sq u)\n  tv2 = Fp_2.add (Fp_2.sq Zuu, Zuu)\n  x1n = Fp_2.mul (Fp_2.add (tv2, Fp_2.field_unit), B')\n  x2n = Fp_2.mul (Zuu, x1n)\n  xd' = Fp_2.mul (Fp_2.neg A', tv2)\n  xd = if F_is_zero Fp_2 xd' then Fp_2.mul(Z,A') else xd'\n    gxd = Fp_2.mul(xd, Fp_2.sq xd) \/\/ xd^3\n  gx1 = F_sum Fp_2 [Fp_2.mul(x1n, Fp_2.sq x1n), F_prod Fp_2 [A', x1n, Fp_2.sq xd], Fp_2.mul(B', gxd)]\n  tv4 = F_prod Fp_2 [gx1, gxd, Fp_2.sq gxd] \/\/ gx1 gxd^3\n  e2 = is_square tv4\n  y1' = if e2 then Fp_2.div (sqrt tv4, tv4) else (F_expt`{n=758} Fp_2 tv4 `((p^^2-9)\/16))\n  y1 = F_prod Fp_2 [gx1, gxd, y1']\n  \/\/ y2:\n  tv4_recip_ZZZ = (Fp_2.mul (tv4, recip_ZZZ))\n  y1'_sqrt_ZZZ = Fp_2.mul (y1', F_expt`{n=758} Fp_2 ZZZ `((p^^2+7)\/16))\n  y2' = Fp_2.mul (y1'_sqrt_ZZZ, sqrt_align_fp2_coeff (Fp_2.mul (y1'_sqrt_ZZZ, tv4_recip_ZZZ)) tv4_recip_ZZZ)\n  y2 = F_prod Fp_2 [y2', gx1, gxd, Fp_2.sq u, u]\n  \/\/ xn and y:\n  (xn,y') = if e2 then (x1n,y1) else (x2n,y2)\n  y = if sgn0(u) == sgn0(y') then y' else Fp_2.neg y'\n  \/\/ convert to Jacobian coordinates\n  res = (Fp_2.mul (xn, xd), Fp_2.mul (y, gxd), xd)\n\nrecip_ZZZ = Fp_2.div(Fp_2.field_unit, ZZZ)\nZZZ = Fp_2.mul(Z, Fp_2.sq Z)\n\nmap_to_g2_impl: [2]t_Fp_2 -> ProjectivePoint t_Fp_2\nmap_to_g2_impl uv = P where\n    Q0 = map_to_isogenous_E2_impl (uv@0)\n    Q2 = map_to_isogenous_E2_impl (uv@1)\n    R = point_dadd Fp_2 Q0 Q2 A' False \/\/ This is addition on the isogenous curve E'\n    S = isogeny_map_to_E2_impl R\n    P = clear_cofactor_E2_impl S\n\nhash_to_curve_E2_opt_impl: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384\n               ) =>\n               ([msg_len][8], [DST_len][8]) -> ProjectivePoint t_Fp_2\nhash_to_curve_E2_opt_impl (msg,dst) = map_to_g2_impl u where\n    u = hash_to_field`{count=2} msg dst\n\nisogeny_map_to_E2_impl: ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\nisogeny_map_to_E2_impl (X, Y, Z) = to_jacobian xn xd yn yd where\n  zzs = Zz_powers Z\n  xn = map_fp2 (kzzs#[last Aux::k1s]) X where\n    kzzs = map_fp2_times_Zz`{n=3} Aux::k1s zzs\n  xd = Fp_2.mul (xs, last zzs) where \/\/ multiply by Z^2\n    xs = map_fp2 ((take`{front=1}kzzs)#[xkzz1]) X\n    xkzz1 = Fp_2.add (X, last kzzs)\n    kzzs = map_fp2_times_Zz`{n=2} Aux::k2s zzs\n  yn = Fp_2.mul (map_fp2 (kzzs#[last Aux::k3s]) X, Y) where\n    kzzs = map_fp2_times_Zz`{n=3} Aux::k3s zzs\n  yd = Fp_2.mul (Fp_2.mul (xs, Z), last zzs) where \/\/ multiply by Z^3\n    xs = map_fp2 ((take`{front=2}kzzs)#[xkzz2]) X\n    xkzz2 = Fp_2.add (X, last kzzs)\n    kzzs = map_fp2_times_Zz`{n=3} Aux::k4s zzs\n\n\/\/ NOTE: below there's some duplication with HashToG1, but it would be cumbersome to factor this out due to the peculiarities of the current Cryptol module system\nto_jacobian xn xd yn yd = (X, Y, Z) where\n  Z = Fp_2.mul (xd, yd)\n  X = Fp_2.mul (Fp_2.mul (xn, yd) , Z)\n  Y = Fp_2.mul (Fp_2.mul (Fp_2.sq Z, xd) , yn)\n\nmap_fp2_times_Zz : {m1,m2,n} (fin n, fin m2, m1 >= n, m2 >= n) => [m1]t_Fp_2 -> [m2]t_Fp_2 -> [n]t_Fp_2\nmap_fp2_times_Zz ks zzs = zipWith (curry Fp_2.mul) (take`{front=n}ks) (drop`{back=n}zzs)\n\nmap_fp2 kzzs x = last rs where\n  rs = [last kzzs] # [F.add (F.mul (ri, x), kzzi) | kzzi <- tail (reverse kzzs) | ri <- rs]\n\nZz_powers : t_Fp_2 -> [3]t_Fp_2\nZz_powers Z = reverse [Fp_2.sq Z, Fp_2.sq (Fp_2.sq Z), Fp_2.mul (Fp_2.sq (Fp_2.sq Z), Fp_2.sq Z)]\n\nadd_n_dbl : {n} (fin n, n >= 1) =>\n            ProjectivePoint t_Fp_2 ->\n            ProjectivePoint t_Fp_2 ->\n            ProjectivePoint t_Fp_2\nadd_n_dbl out p = doublings ! 0 where\n  outp = point_dadd Fp_2 out p Fp_2.field_zero True\n  doublings = [outp] # [point_double Fp_2 d | d <- doublings | i <- [1 .. n]]\n\ntimes_minus_z : ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\ntimes_minus_z P = out6 where\n  out1 = point_double Fp_2 P\n  out2 = add_n_dbl`{2} out1 P\n  out3 = add_n_dbl`{3} out2 P\n  out4 = add_n_dbl`{9} out3 P\n  out5 = add_n_dbl`{32} out4 P\n  out6 = add_n_dbl`{16} out5 P\n\npsi_psi_double_impl: ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\npsi_psi_double_impl P = psi_imp (psi_imp (point_double Fp_2 P))\n\nclear_cofactor_E2_impl:  ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\nclear_cofactor_E2_impl P = out4 where\n  out1 = psi_psi_double_impl P\n  t0_1 = point_neg Fp_2 P\n  t1   = psi_imp t0_1\n  out2 = point_dadd Fp_2 out1 t0_1 Fp_2.field_zero True\n  out3 = point_dadd Fp_2 out2 t1 Fp_2.field_zero True\n  t0_2 = point_dadd Fp_2 (times_minus_z P) P Fp_2.field_zero True\n  t0_3 = point_dadd Fp_2 t0_2 t1 Fp_2.field_zero True\n  t1'  = times_minus_z t0_3\n  out4 = point_dadd Fp_2 out3 t1' Fp_2.field_zero True\n\n\/\/ A slightly simplified version that we could use in a proof that the implementation corresponds to the specification:\n_map_to_isogenous_E2_impl : t_Fp_2 -> ProjectivePoint t_Fp_2\n_map_to_isogenous_E2_impl u = res where\n  \/\/ x1n, x2n, and xd:\n  Zuu = Fp_2.mul (Z, Fp_2.sq u)\n  tv2 = Fp_2.add (Fp_2.sq Zuu, Zuu)\n  x1n = Fp_2.mul (Fp_2.add (tv2, Fp_2.field_unit), B')\n  x2n = Fp_2.mul (Zuu, x1n)\n  xd' = Fp_2.mul (Fp_2.neg A', tv2)\n  xd = if F_is_zero Fp_2 xd' then Fp_2.mul(Z,A') else xd'\n    gxd = Fp_2.mul(xd, Fp_2.sq xd) \/\/ xd^3\n  gx1 = F_sum Fp_2 [Fp_2.mul(x1n, Fp_2.sq x1n), F_prod Fp_2 [A', x1n, Fp_2.sq xd], Fp_2.mul(B', gxd)]\n  tv4 = F_prod Fp_2 [gx1, gxd, Fp_2.sq gxd] \/\/ gx1 gxd^3\n  e2 = is_square tv4\n  xn = if e2 then x1n else x2n\n  y' = if e2\n        then F_prod Fp_2 [gx1, gxd, Fp_2.div (sqrt tv4, tv4)]\n        else F_prod Fp_2 [sqrt (Fp_2.div(ZZZ, tv4)), gx1, gxd, Fp_2.sq u, u]\n  y = if sgn0(u) == sgn0(y') then y' else Fp_2.neg y'\n  \/\/ convert to Jacobian coordinates\n  res = (Fp_2.mul (xn, xd), Fp_2.mul (y, gxd), xd)\n\n\/\/ other facts we would need for the proof\n\n_one_of_is_square u = Fp_2.is_val u \/\\ ~(is_square x) ==> is_square b where\n  b = Fp_2.mul (x, recip_ZZZ)\n  x = F_prod Fp_2 [gx1, gxd, Fp_2.sq gxd]\n  gxd = Fp_2.mul(xd, Fp_2.sq xd) \/\/ xd^3\n  gx1 = F_sum Fp_2 [Fp_2.mul(x1n, Fp_2.sq x1n), F_prod Fp_2 [A', x1n, Fp_2.sq xd], Fp_2.mul(B', gxd)]\n  Zuu = Fp_2.mul (Z, Fp_2.sq u)\n  tv2 = Fp_2.add (Fp_2.sq Zuu, Zuu)\n  x1n = Fp_2.mul (Fp_2.add (tv2, Fp_2.field_unit), B')\n  xd' = Fp_2.mul (Fp_2.neg A', tv2)\n  xd = if F_is_zero Fp_2 xd' then Fp_2.mul(Z,A') else xd'\n\n\/\/ It may be possible to use this instead of the above:\n\/\/ Fp_2.is_val x \/\\ ~(is_square x) ==> is_square (Fp_2.mul (x, recip_ZZZ))\n\/\/ Should be true because ZZZ is not a square, so dividing by it turns squares into nonsquares and vice versa\n\n_sqrt_align_prop x' = Fp_2.is_val x \/\\ is_square b ==>\n  Fp_2.sq (sqrt_align a ab b) == Fp_2.sq (Fp_2.div (sqrt b, b)) where\n    a = Fp_2.mul (F_expt`{n=758} Fp_2 x `((p^^2-9)\/16), F_expt`{n=758} Fp_2 ZZZ `((p^^2+7)\/16))\n    b = Fp_2.mul (x, recip_ZZZ)\n    ab = Fp_2.mul (a,b)\n    sqrt_align x y z = Fp_2.mul (x, sqrt_align_fp2_coeff y z)\n    recip_ZZZ = Fp_2.div (Fp_2.field_unit, ZZZ)\n    x = Fp_2.normalize x'\n\n_square_same_sign_prop x y u = Fp_2.sq x == Fp_2.sq y ==>\n  (if sgn0(x) == sgn0(u) then x else Fp_2.neg x) == (if sgn0(y) == sgn0(u) then y else Fp_2.neg y)\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/Field.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol specifications that formally define and verify the correctness of the field representation conversions and invariants in the implementation::Field module. Include properties that check the round-trip correctness of from_mont and to_mont functions, the preservation of invariants by normalization functions (fp_normalize, fp2_normalize, etc.), and the consistency between abstract field elements and their vector representations (e.g., fp_abs and fp_rep). Ensure the specifications cover all field types (Fp, Fp_2, Fp_6, Fp_12) and their associated operations and invariants."},{"role":"assistant","content":"```cryptol\n\/\/\n\/\/ Finite field representations in blst\n\/\/\n\nmodule implementation::Field where\n\nimport Common::Field\nimport implementation::Types\nimport Parameters ( p, Fp, t_Fp, to_Fp, from_Fp, t_Fp_2, Fp_2, t_Fp_6, Fp_6, t_Fp_12, Fp_12)\n\nmontgomery_factor_p: t_Fp\n\/\/ montgomery_factor_p = (2^^384) \/\/ NOT portable between Fp implementations.\nmontgomery_factor_p = Fp.mul (2^^4, 2^^380) \/\/ but this *is* portable\n\nmontgomery_factor_inverse_p: t_Fp\nmontgomery_factor_inverse_p = Fp.div(Fp.field_unit, montgomery_factor_p)\n\nfrom_mont: t_Fp -> t_Fp\nfrom_mont x = Fp.mul (x, montgomery_factor_inverse_p)\n\nto_mont: t_Fp -> t_Fp\nto_mont x = Fp.mul(x, montgomery_factor_p)\n\ntype Fp_rep_t = Vec384\n\nfp_abs: Fp_rep_t -> t_Fp\nfp_abs v = from_mont (to_Fp (vec384_abs v))\n\nfp_rep: t_Fp -> Fp_rep_t\nfp_rep x = vec384_rep (from_Fp (to_mont x))\n\nfp_invariant: Fp_rep_t -> Bool\nfp_invariant v = vec384_abs v < `p fp_normalize: Fp_rep_t -> Fp_rep_t\nfp_normalize x = vec384_rep (from_Fp (Fp.normalize (to_Fp (vec384_abs x))))\n\ntype Fp_2_rep_t = [2]Fp_rep_t\n\nfp2_abs: Fp_2_rep_t -> t_Fp_2\nfp2_abs [a,b] = [fp_abs b, fp_abs a]\n\nfp2_rep: t_Fp_2 -> Fp_2_rep_t\nfp2_rep [a,b] = [fp_rep b, fp_rep a]\n\nfp2_invariant: Fp_2_rep_t -> Bool\nfp2_invariant v = all fp_invariant v\n\nfp2_normalize: Fp_2_rep_t -> Fp_2_rep_t\nfp2_normalize [x,y] = [fp_normalize x, fp_normalize y]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ Fpx2 is used in the implementation of the fp_12 tower.  Here, the results of a\n\/\/ multiplication are manipulated at their double width size (768 bits), before the\n\/\/ \"redc\" operation has been applied.  Addition and subtraction work modulo 2^384 p,\n\/\/ so we are no longer working in a field, but a ring.\n\n\/\/ Fp_2x2 is then built from Fp2x in the same way (a polynomial quotient ring) as Fp_2 is\n\/\/ built from Fp. Fp6x2 is similar, built from Fp2x2.\n\ntype Fpx2_rep_t = Vec768\ntype shifted_p = p * 2^^384\n\ntype t_Fpx2 = Integer\n\nfpx2_abs: Fpx2_rep_t -> t_Fpx2\nfpx2_abs x = toInteger (vec768_abs x)\n\nfpx2_rep: t_Fpx2 -> Fpx2_rep_t\nfpx2_rep x = vec768_rep (fromInteger x)\n\nfpx2_invariant v = (vec768_abs v) < `shifted_p\n\n\ntype Fp_2x2_rep_t = [2]Vec768\ntype t_Fp_2x2 = [2]t_Fpx2\n\nfp2x2_abs: Fp_2x2_rep_t -> t_Fp_2x2\nfp2x2_abs [x, y] = [fpx2_abs y, fpx2_abs x]\n\nfp2x2_rep: t_Fp_2x2 -> Fp_2x2_rep_t\nfp2x2_rep [x, y] = [fpx2_rep y, fpx2_rep x]\n\nfp2x2_invariant [x, y] = fpx2_invariant x \/\\ fpx2_invariant y\n\ntype Fp_6_rep_t = [3]Fp_2_rep_t\n\nfp6_abs [x,y,z] = [fp2_abs z, fp2_abs y, fp2_abs x]\nfp6_rep [x,y,z] = [fp2_rep z, fp2_rep y, fp2_rep x]\nfp6_invariant [x,y,z] = fp2_invariant x \/\\ fp2_invariant y \/\\ fp2_invariant z\nfp6_normalize [x,y,z] = [fp2_normalize x, fp2_normalize y, fp2_normalize z]\n\ntype t_Fp_6x2 = [3]t_Fp_2x2\nfp6x2_abs [x,y,z] = [fp2x2_abs z, fp2x2_abs y, fp2x2_abs x]\nfp6x2_rep [x,y,z] = [fp2x2_rep z, fp2x2_rep y, fp2x2_rep x]\nfp6x2_invariant [x,y,z] = fp2x2_invariant x \/\\ fp2x2_invariant y \/\\ fp2x2_invariant z\n\n\ntype Fp_12_rep_t = [2]Fp_6_rep_t\n\nfp12_abs: Fp_12_rep_t -> t_Fp_12\nfp12_abs [a,b] = [fp6_abs b, fp6_abs a]\n\nfp12_rep: t_Fp_12 -> Fp_12_rep_t\nfp12_rep [a,b] = [fp6_rep b, fp6_rep a]\n\nfp12_invariant: Fp_12_rep_t -> Bool\nfp12_invariant [x,y] = fp6_invariant x \/\\ fp6_invariant y\n\nfp12_normalize: Fp_12_rep_t -> Fp_12_rep_t\nfp12_normalize [x,y] = [fp6_normalize x, fp6_normalize y]\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/x86.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the modular multiplication and squaring functions defined in the implementation::x86 module, such as mulx_mont_384x, sqrx_mont_384x, mulx_382x, and sqrx_382x. Ensure the properties check that these functions correctly implement Montgomery multiplication and squaring modulo the given modulus vectors, preserving modular arithmetic properties. Include properties that verify the reduction functions redcx_mont_384 and redcx_mont_256 produce results congruent modulo the modulus, and that fromx_mont_384 and fromx_mont_256 correctly convert Montgomery representations back to standard form."},{"role":"assistant","content":"```cryptol\nmodule implementation::x86 where\n\nimport implementation::Types\nimport implementation::x86::helpers\n\nmulx_mont_384x\n  : Vec768   -> Vec768   -> Vec384    -> [64]   -> Vec768 mulx_mont_384x a b m n0 = result\n  where\n    t0 = __mulx_384 (take a) (take b)\n    t1 = __mulx_384 (drop a) (drop b)\n    t2 = __mulx_384 (__add_mod_384 (take b) (drop b) m) (__add_mod_384 (take a) (drop a) m)\n    t2' = __sub_mod_384x384 (__sub_mod_384x384 t2 t0 m) t1 m\n    t0' = __sub_mod_384x384 t0 t1 m\n    ret_re = redcx_mont_384 t0' m n0\n    ret_im = redcx_mont_384 t2' m n0\n    result = ret_re # ret_im\n\nsqrx_mont_384x\n  : Vec768   -> Vec384    -> [64]   -> Vec768 sqrx_mont_384x a m n0 = result\n  where\n    t0 = __add_mod_384 (take a) (drop a) m\n    t1 = __sub_mod_384 (take a) (drop a) m\n    tmp = mulx_mont_384 (take a) (drop a) m n0\n    ret_im = __add_mod_384 tmp tmp m\n    ret_re = mulx_mont_384 t0 t1 m n0\n    result = ret_re # ret_im\n\nmulx_382x\n  : Vec768   -> Vec768   -> Vec384    -> [2]Vec768 mulx_382x a b m = result\n  where\n    a_re = take a\n    a_im = drop a\n    (t0_cf_0, t0_0) = add (a_re @ 0) (a_im @ 0)\n    (t0_cf_1, t0_1) = adc (a_re @ 1) (a_im @ 1) t0_cf_0\n    (t0_cf_2, t0_2) = adc (a_re @ 2) (a_im @ 2) t0_cf_1\n    (t0_cf_3, t0_3) = adc (a_re @ 3) (a_im @ 3) t0_cf_2\n    (t0_cf_4, t0_4) = adc (a_re @ 4) (a_im @ 4) t0_cf_3\n    (_, t0_5) = adc (a_re @ 5) (a_im @ 5) t0_cf_4\n    b_re = take b\n    b_im = drop b\n    (t1_cf_0, t1_0) = add (b_re @ 0) (b_im @ 0)\n    (t1_cf_1, t1_1) = adc (b_re @ 1) (b_im @ 1) t1_cf_0\n    (t1_cf_2, t1_2) = adc (b_re @ 2) (b_im @ 2) t1_cf_1\n    (t1_cf_3, t1_3) = adc (b_re @ 3) (b_im @ 3) t1_cf_2\n    (t1_cf_4, t1_4) = adc (b_re @ 4) (b_im @ 4) t1_cf_3\n    (_, t1_5) = adc (b_re @ 5) (b_im @ 5) t1_cf_4\n    tmp_im_0 = __mulx_384 [t0_0, t0_1, t0_2, t0_3, t0_4, t0_5] [t1_0, t1_1, t1_2, t1_3, t1_4, t1_5]\n    tmp_re = __mulx_384 a_re b_re\n    tx = __mulx_384 a_im b_im\n    tmp_im_1 = __sub_mod_384x384 tmp_im_0 tx m\n    ret_im = __sub_mod_384x384 tmp_im_1 tmp_re m\n    ret_re = __sub_mod_384x384 tmp_re tx m\n    result = [ret_re, ret_im]\n\nsqrx_382x\n  : Vec768   -> Vec384    -> [2]Vec768 sqrx_382x a m = result\n  where\n    a_re = take a\n    a_im = drop a\n    (t0_cf_0, t0_0) = add (a_re @ 0) (a_im @ 0)\n    (t0_cf_1, t0_1) = adc (a_re @ 1) (a_im @ 1) t0_cf_0\n    (t0_cf_2, t0_2) = adc (a_re @ 2) (a_im @ 2) t0_cf_1\n    (t0_cf_3, t0_3) = adc (a_re @ 3) (a_im @ 3) t0_cf_2\n    (t0_cf_4, t0_4) = adc (a_re @ 4) (a_im @ 4) t0_cf_3\n    (_, t0_5) = adc (a_re @ 5) (a_im @ 5) t0_cf_4\n    t1 = __sub_mod_384 a_re a_im m\n    ret_re = __mulx_384 t1 [t0_0, t0_1, t0_2, t0_3, t0_4, t0_5]\n    tmp_im = __mulx_384 a_re a_im\n    (ret_im_cf_0, ret_im_0) = add (tmp_im @ 0) (tmp_im @ 0)\n    (ret_im_cf_1, ret_im_1) = adc (tmp_im @ 1) (tmp_im @ 1) ret_im_cf_0\n    (ret_im_cf_2, ret_im_2) = adc (tmp_im @ 2) (tmp_im @ 2) ret_im_cf_1\n    (ret_im_cf_3, ret_im_3) = adc (tmp_im @ 3) (tmp_im @ 3) ret_im_cf_2\n    (ret_im_cf_4, ret_im_4) = adc (tmp_im @ 4) (tmp_im @ 4) ret_im_cf_3\n    (ret_im_cf_5, ret_im_5) = adc (tmp_im @ 5) (tmp_im @ 5) ret_im_cf_4\n    (ret_im_cf_6, ret_im_6) = adc (tmp_im @ 6) (tmp_im @ 6) ret_im_cf_5\n    (ret_im_cf_7, ret_im_7) = adc (tmp_im @ 7) (tmp_im @ 7) ret_im_cf_6\n    (ret_im_cf_8, ret_im_8) = adc (tmp_im @ 8) (tmp_im @ 8) ret_im_cf_7\n    (ret_im_cf_9, ret_im_9) = adc (tmp_im @ 9) (tmp_im @ 9) ret_im_cf_8\n    (ret_im_cf_10, ret_im_10) = adc (tmp_im @ 10) (tmp_im @ 10) ret_im_cf_9\n    (_, ret_im_11) = adc (tmp_im @ 11) (tmp_im @ 11) ret_im_cf_10\n    ret_im = [ret_im_0, ret_im_1, ret_im_2, ret_im_3, ret_im_4, ret_im_5, ret_im_6, ret_im_7, ret_im_8, ret_im_9, ret_im_10, ret_im_11]\n    result = [ret_re, ret_im]\n\nredcx_mont_384\n  : Vec768 \/\/ a; pointer in rsi\n  -> Vec384 \/\/ m; pointer in rdx\n  -> [64] \/\/ n0; passed in rcx\n  -> Vec384 redcx_mont_384 a m n0 = result\n  where\n    acc = __mulx_by_1_mont_384 (take a) m n0\n    result = __redc_tail_mont_384 acc a m\nfromx_mont_384\n  : Vec384 \/\/ a; pointer in rsi\n  -> Vec384 \/\/ m; pointer in rdx\n  -> [64] \/\/ n0; passed in rcx\n  -> Vec384 fromx_mont_384 a m n0 = result\n  where\n    \n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0, r14_0, r15_0] = __mulx_by_1_mont_384 a m n0\n    rax_1 = r14_0\n    rcx_1 = r15_0\n    rdx_1 = r8_0\n    rbp_1 = r9_0\n    (cf_2, r14_2) = sub r14_0 (m @ 0)\n    (cf_3, r15_3) = sbb r15_0 (m @ 1) cf_2\n    r13_4 = r10_0\n    (cf_5, r8_5) = sbb r8_0 (m @ 2) cf_3\n    (cf_6, r9_6) = sbb r9_0 (m @ 3) cf_5\n    (cf_7, r10_7) = sbb r10_0 (m @ 4) cf_6\n    rsi_8 = r11_0\n    (cf_9, r11_9) = sbb r11_0 (m @ 5) cf_7\n    r14_10 = cmovb r14_2 rax_1 cf_9\n    r15_10 = cmovb r15_3 rcx_1 cf_9\n    r8_10 = cmovb r8_5 rdx_1 cf_9\n    r9_10 = cmovb r9_6 rbp_1 cf_9\n    r10_10 = cmovb r10_7 r13_4 cf_9\n    r11_10 = cmovb r11_9 rsi_8 cf_9\n    result = [r14_10, r15_10, r8_10, r9_10, r10_10, r11_10]\n\nsgn0x_pty_mont_384\n  : Vec384 \/\/ a; passed in rdi\n  -> Vec384 \/\/ p; passed in rsi\n  -> [64] \/\/ n0; passed in rdx\n  -> [64]\nsgn0x_pty_mont_384 a p n0 = result\n  where\n    \n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0, r14_0, r15_0] = __mulx_by_1_mont_384 a p n0\n    rax_1 = 0\n    r13_2 = r14_0\n    (cf_3, r14_3) = adcx r14_0 r14_0 False\n    (cf_4, r15_4) = adcx r15_0 r15_0 cf_3\n    (cf_5, r8_5) = adcx r8_0 r8_0 cf_4\n    (cf_6, r9_6) = adcx r9_0 r9_0 cf_5\n    (cf_7, r10_7) = adcx r10_0 r10_0 cf_6\n    (cf_8, r11_8) = adcx r11_0 r11_0 cf_7\n    (_, rax_9) = adcx rax_1 0 cf_8\n    (cf_10, r14_10) = sub r14_3 (p @ 0)\n    (cf_11, r15_11) = sbb r15_4 (p @ 1) cf_10\n    (cf_12, r8_12) = sbb r8_5 (p @ 2) cf_11\n    (cf_13, r9_13) = sbb r9_6 (p @ 3) cf_12\n    (cf_14, r10_14) = sbb r10_7 (p @ 4) cf_13\n    (cf_15, r11_15) = sbb r11_8 (p @ 5) cf_14\n    (_, rax_16) = sbb rax_9 0 cf_15\n    rax_17 = ~rax_16\n    r13_18 = r13_2 && (zext 0x1 : [64])\n    rax_18 = rax_17 && (zext 0x2 : [64])\n    result = rax_18 || r13_18\n\nsgn0x_pty_mont_384x\n  : Vec768 \/\/ a; passed in rdi\n  -> Vec384 \/\/ m; passed in rsi\n  -> [64] \/\/ n0; passed in rdx\n  -> [64]\nsgn0x_pty_mont_384x a m n0 = result\n  where\n    [r8_4, r9_4, r10_4, r11_4, r12_4, r13_4, r14_4, r15_4] = __mulx_by_1_mont_384 (drop a) m n0\n    r12_5 = r14_4\n    r14_6 = r14_4 || r15_4\n    r14_7 = r14_6 || r8_4\n    r14_8 = r14_7 || r9_4\n    r14_9 = r14_8 || r10_4\n    r14_10 = r14_9 || r11_4\n    rdi_12 = 0\n    r13_13 = r12_5\n    (cf_14, r12_14) = add r12_5 r12_5\n    (cf_15, r15_15) = adc r15_4 r15_4 cf_14\n    (cf_16, r8_16) = adc r8_4 r8_4 cf_15\n    (cf_17, r9_17) = adc r9_4 r9_4 cf_16\n    (cf_18, r10_18) = adc r10_4 r10_4 cf_17\n    (cf_19, r11_19) = adc r11_4 r11_4 cf_18\n    (cf_20, rdi_20) = adc rdi_12 0 cf_19\n    (cf_21, r12_21) = sub r12_14 (m @ 0)\n    (cf_22, r15_22) = sbb r15_15 (m @ 1) cf_21\n    (cf_23, r8_23) = sbb r8_16 (m @ 2) cf_22\n    (cf_24, r9_24) = sbb r9_17 (m @ 3) cf_23\n    (cf_25, r10_25) = sbb r10_18 (m @ 4) cf_24\n    (cf_26, r11_26) = sbb r11_19 (m @ 5) cf_25\n    (cf_27, rdi_27) = sbb rdi_20 0 cf_26\n    stack0 = r14_10\n    rdi_29 = ~rdi_27\n    r13_30 = r13_13 && zext 0x1\n    rdi_31 = rdi_29 && zext 0x2\n    rdi_32 = rdi_31 || r13_30\n    [r8_33, r9_33, r10_33, r11_33, r12_33, r13_33, r14_33, r15_33] = __mulx_by_1_mont_384 (take a) m n0\n    r12_34 = r14_33\n    r14_35 = r14_33 || r15_33\n    r14_36 = r14_35 || r8_33\n    r14_37 = r14_36 || r9_33\n    r14_38 = r14_37 || r10_33\n    r14_39 = r14_38 || r11_33\n    rax_40 = 0\n    r13_41 = r12_34\n    (cf_42, r12_42) = add r12_34 r12_34\n    (cf_43, r15_43) = adc r15_33 r15_33 cf_42\n    (cf_44, r8_44) = adc r8_33 r8_33 cf_43\n    (cf_45, r9_45) = adc r9_33 r9_33 cf_44\n    (cf_46, r10_46) = adc r10_33 r10_33 cf_45\n    (cf_47, r11_47) = adc r11_33 r11_33 cf_46\n    (cf_48, rax_48) = adc rax_40 0 cf_47\n    (cf_49, r12_49) = sub r12_42 (m @ 0)\n    (cf_50, r15_50) = sbb r15_43 (m @ 1) cf_49\n    (cf_51, r8_51) = sbb r8_44 (m @ 2) cf_50\n    (cf_52, r9_52) = sbb r9_45 (m @ 3) cf_51\n    (cf_53, r10_53) = sbb r10_46 (m @ 4) cf_52\n    (cf_54, r11_54) = sbb r11_47 (m @ 5) cf_53\n    (cf_55, rax_55) = sbb rax_48 0 cf_54\n    r12_56 = stack0\n    rax_57 = ~rax_55\n    zf_58 = r14_39 == 0\n    r13_59 = cmove r13_41 rdi_32 zf_58\n    zf_60 = r12_56 == 0\n    rax_61 = cmovne rax_57 rdi_32 zf_60\n    r13_62 = r13_59 && zext 0x1\n    rax_63 = rax_61 && zext 0x2\n    rax_64 = rax_63 || r13_62\n    result = rax_64\n\nmulx_mont_384\n  : Vec384 \/\/ a; passed in rsi\n  -> Vec384 \/\/ b; passed in rdx\n  -> Vec384 \/\/ m; passed in rcx\n  -> [64] \/\/ n0; passed in r8\n  -> Vec384 mulx_mont_384 a b m n0 = result\n  where\n    (r9, r8) = mulx (a @ 0) (b @ 0)\n    acc =\n      [ r8       , r9       , undefined       , undefined       , a @ 3       , undefined       , a @ 0       , a @ 1       , a @ 2 \/\/ rax\n      ]\n    lo = a @ 4\n    hi = a @ 5\n    result = __mulx_mont_384 acc (b @ 0) n0 lo hi a b m\n\nsqrx_n_mul_mont_383\n  : Vec384   -> Integer    -> Vec384   -> [64]   -> Vec384   -> Vec384 sqrx_n_mul_mont_383 a count m n0 b = result\n  where\n    mulx_mont_383_nonred x y = __mulx_mont_383_nonred [r8, r9, undefined, undefined, x @ 3, undefined, x @ 0, x @ 1, x @ 2] (y @ 0) n0 (x @ 4) (x @ 5) x y m\n      where (r9, r8) = mulx (x @ 0) (y @ 0)\n    loop counter acc =\n      if counter == 0\n      then acc\n      else loop (counter - 1) (mulx_mont_383_nonred acc acc)\n    result = mulx_mont_384 (loop count a) b m n0\n\nsqrx_mont_382x\n  : Vec768 \/\/ a; pointer in rsi\n  -> Vec384  \/\/ m; pointer in rdx\n  -> [64] \/\/ n0; passed in rcx\n  -> Vec768 sqrx_mont_382x a m n0 = result\n  where\n    mulx_mont_383_nonred x y = __mulx_mont_383_nonred [r8, r9, undefined, undefined, x @ 3, undefined, x @ 0, x @ 1, x @ 2] (y @ 0) n0 (x @ 4) (x @ 5) x y m\n      where (r9, r8) = mulx (x @ 0) (y @ 0)\n    a_re = take a\n    a_im = drop a\n    (t0_cf_0, t0_0) = add (a_re @ 0) (a_im @ 0)\n    (t0_cf_1, t0_1) = adc (a_re @ 1) (a_im @ 1) t0_cf_0\n    (t0_cf_2, t0_2) = adc (a_re @ 2) (a_im @ 2) t0_cf_1\n    (t0_cf_3, t0_3) = adc (a_re @ 3) (a_im @ 3) t0_cf_2\n    (t0_cf_4, t0_4) = adc (a_re @ 4) (a_im @ 4) t0_cf_3\n    (_, t0_5) = adc (a_re @ 5) (a_im @ 5) t0_cf_4\n    t0 = [t0_0, t0_1, t0_2, t0_3, t0_4, t0_5]\n    (t1_cf_0, t1_0) = sub (a_re @ 0) (a_im @ 0)\n    (t1_cf_1, t1_1) = sbb (a_re @ 1) (a_im @ 1) t1_cf_0\n    (t1_cf_2, t1_2) = sbb (a_re @ 2) (a_im @ 2) t1_cf_1\n    (t1_cf_3, t1_3) = sbb (a_re @ 3) (a_im @ 3) t1_cf_2\n    (t1_cf_4, t1_4) = sbb (a_re @ 4) (a_im @ 4) t1_cf_3\n    (gt, t1_5) = sbb (a_re @ 5) (a_im @ 5) t1_cf_4\n    t1 = [t1_0, t1_1, t1_2, t1_3, t1_4, t1_5]\n    tmp_im = mulx_mont_383_nonred a_re a_im\n    (ret_im_cf_0, ret_im_0) = add (tmp_im @ 0) (tmp_im @ 0)\n    (ret_im_cf_1, ret_im_1) = adc (tmp_im @ 1) (tmp_im @ 1) ret_im_cf_0\n    (ret_im_cf_2, ret_im_2) = adc (tmp_im @ 2) (tmp_im @ 2) ret_im_cf_1\n    (ret_im_cf_3, ret_im_3) = adc (tmp_im @ 3) (tmp_im @ 3) ret_im_cf_2\n    (ret_im_cf_4, ret_im_4) = adc (tmp_im @ 4) (tmp_im @ 4) ret_im_cf_3\n    (_, ret_im_5) = adc (tmp_im @ 5) (tmp_im @ 5) ret_im_cf_4\n    ret_im = [ret_im_0, ret_im_1, ret_im_2, ret_im_3, ret_im_4, ret_im_5]\n    tmp_re = mulx_mont_383_nonred t0 t1\n    mask = if gt then -1 else 0\n    t0_mask = [mask && (t0 @ 0), mask && (t0 @ 1), mask && (t0 @ 2), mask && (t0 @ 3), mask && (t0 @ 4), mask && (t0 @ 5)]\n    ret_re = __sub_mod_384 tmp_re t0_mask m\n    result = ret_re # ret_im\n\nmulx_mont_sparse_256\n  : Vec256 \/\/ a; passed in rsi\n  -> Vec256 \/\/ b; passed in rdx\n  -> Vec256 \/\/ m; passed in rcx\n  -> [64] \/\/ n0; passed in r8\n  -> Vec256 mulx_mont_sparse_256 a b m n0 = result\n  where\n    (r11, rax) = mulx (a @ 0) (b @ 0)\n    acc =\n      [ undefined       , r11       , undefined       , undefined       , a @ 0       , a @ 1       , rax \/\/ rax\n      ]\n    lo = a @ 2\n    hi = a @ 3\n    result = __mulx_mont_sparse_256 acc (b @ 0) n0 lo hi a b m\n\nredcx_mont_256\n  : Vec512 \/\/ a; pointer in rsi\n  -> Vec256 \/\/ m; pointer in rdx\n  -> [64] \/\/ n0; passed in rcx\n  -> Vec256 redcx_mont_256 a m n0 = result\n  where\n    [r10_0, r11_0, r12_0, r13_0, r14_0, r15_0] = __mulx_by_1_mont_256 (take a) m n0\n    (high_cf_0, high_0) = add r14_0 (a @ 4)\n    (high_cf_1, high_1) = adc r15_0 (a @ 5) high_cf_0\n    (high_cf_2, high_2) = adc r10_0 (a @ 6) high_cf_1\n    (high_cf_3, high_3) = adc r11_0 (a @ 7) high_cf_2\n    mask = if high_cf_3 then -1 else 0\n    (diff_cf_0, diff_0) = sub high_0 (m @ 0)\n    (diff_cf_1, diff_1) = sbb high_1 (m @ 1) diff_cf_0\n    (diff_cf_2, diff_2) = sbb high_2 (m @ 2) diff_cf_1\n    (diff_cf_3, diff_3) = sbb high_3 (m @ 3) diff_cf_2\n    (gt, _) = sbb mask 0 diff_cf_3\n    result0 = cmovae high_0 diff_0 gt\n    result1 = cmovae high_1 diff_1 gt\n    result2 = cmovae high_2 diff_2 gt\n    result3 = cmovae high_3 diff_3 gt\n    result = [result0, result1, result2, result3]\n\nfromx_mont_256\n  : Vec256 \/\/ a; pointer in rsi\n  -> Vec256 \/\/ m; pointer in rdx\n  -> [64] \/\/ n0; passed in rcx\n  -> Vec256 fromx_mont_256 a m n0 = result\n  where\n    [r10_0, r11_0, r12_0, r13_0, r14_0, r15_0] = __mulx_by_1_mont_256 a m n0\n    (diff_cf_0, diff_0) = sub r14_0 (m @ 0)\n    (diff_cf_1, diff_1) = sbb r15_0 (m @ 1) diff_cf_0\n    (diff_cf_2, diff_2) = sbb r10_0 (m @ 2) diff_cf_1\n    (diff_cf_3, diff_3) = sbb r11_0 (m @ 3) diff_cf_2\n    result0 = cmovae r14_0 diff_0 diff_cf_3\n    result1 = cmovae r15_0 diff_1 diff_cf_3\n    result2 = cmovae r10_0 diff_2 diff_cf_3\n    result3 = cmovae r11_0 diff_3 diff_cf_3\n    result = [result0, result1, result2, result3]\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/PairingImpl.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property or verification script that proves the equivalence between the optimized Miller loop implementation `miller_loop_opt` and the naive Miller loop implementation `miller_loop_twist` for the ate pairing on the elliptic curve twist. The verification should assert that for all valid input points P and Q, both implementations produce the same output in Fp_12, considering the optimizations and conjugation steps described in the code comments."},{"role":"assistant","content":"```cryptol\n\/*\n  The naive but mathematically correct definition of pairing in the Pairing module has\n  opportunities for substantial optimization.  Most of these are described, somewhat abstractly,\n  in Costello, Lange, and Naehrig \"Faster Pairing Computations on Curves with High-Degree Twists\"\n  (https:\/\/eprint.iacr.org\/2009\/615)\n\n  The reasoning behind these optimizations is too sophisticated for proof in SAW, and we will\n  instead summarize the mathematical argument here, define the resulting high-level algorithm\n  in Cryptol code, and (in a related SAW file), just assert that these two algorithms give the\n  same result.\n\n  There are several parts to the optimization:\n\n  (1) Costello, Lange, and Naehrig show in their Theorem 1 that the ate\n      pairing computation can be done by mapping to the twist E'\/Fp_12 rather\n      than to the main curve E\/Fp_12.\n\n  (2) We do not need to use a generic point_add routine because we can tell\n      exactly when we will be doubling and when we are adding to points with\n      distinct x coordinates.  That is, in the Miller loop, the values of T are\n      always smallish nonzero multiples of Q, which has order r.  So none of\n      these values are O, or Q, or -Q,\n\n  (3) Costello, Lange, and Naehrig also show that the line computation may be\n      done in Fp_2 rather than in Fp_12, as the factors of w that are\n      introduced get wiped out by the final exponentiation.\n\n  (4) We can eliminate division in computing the line function, even while using\n      projective coordinates for T.  Costello, Lange, and Naehrig explain how\n      (but in their paper using a different system of projective\n      coordinates).  Here, in the Jacobian system, we can retrace the\n      derivation; see below.  Again the key is that we can introduce factors that get\n      wiped out (mapped to 1) in the final exponentiation.\n\n  (5) A final trick used in the C code is to avoid negating Q, computing with\n      Q itself and then conjugating the final result.  This is OK, because for\n      points in Fp_12 that are in the cyclotomic subgroup, conjugation is\n      inversion, and the bilinearity of pairing shows\n\n           [-Q,P] = [Q,P]^{-1}\n\n      So computing with Q and conjugating at the end gives the correct result.\n*\/\n\nmodule implementation::PairingImpl where\n\nimport Parameters (t_Fp, t_Fp_2, t_Fp_6, t_Fp_12, Fp, Fp_2, Fp_12, Fp_to_Fp_2, E, E')\nimport Parameters as P\nimport ShortWeierstrassCurve as EC\nimport Common::Field (FieldRep)\nimport FieldExtras\nimport Frobenius (fp12_conjugate)\nimport implementation::Types (Size_t)\nimport implementation::Fp12 (fp6_to_fp12_xy00z0)\nimport implementation::CurveOperation (point_double, point_add_affine, normalize_point, normalize_affine_point)\n\n\/\/ Note: the layout of Fp_12 over Fp_2 is\n\/\/ [[a,c,e],[b,d,f]] represents a*w^5 + b*w^4 + c*w^3 + d*w^2 + e*w + f\n\n\/**\n * Take a point on E\/F_p to a point on E'\/F_p^12\n * This applies the sextic twist to the coordinates:\n * (x, y) :-> (w^2 x, w^3 y)\n *\/\nphi_3: EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_12\nphi_3 (x,y) = ([[z,z,z],[z,x',z]], [[z,y',z],[z,z,z]]) where\n   z = P::Fp_2.field_zero\n   x' = P::Fp_to_Fp_2 x    y' = P::Fp_to_Fp_2 y \/**\n * Take a point on E'\/F_p^2 to a point on E'\/F_p^12\n * This just injects the coordinates into the larger field\n *\/\nphi_4: EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp_12\nphi_4 (x,y) = (x',y') where\n    x' = P::Fp_2_to_Fp_12 x\n    y' = P::Fp_2_to_Fp_12 y\n\n\/*  For reference, computing the ate_pairing (leaving out the final exponentiation)\n    on the twist would look like this:\n\n     Here we also do the point arithmetic on E', rather than mapping up to the twist on Fp_12.\n     That's legitimate because the phi mappings are all homomorphisms.\n\nmiller_loop_twist: EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_2 -> t_Fp_12\nmiller_loop_twist P Q =  last_f where\n   negQ = EC::neg P::E' Q\n   (last_f, _) = f_Ts ! 0\n   f_Ts = [(P::Fp_12.field_unit, negQ)] #\n          [ miller_step_twist P negQ fT ci | fT <- f_Ts | ci <- tail negative_t]\n\nmiller_step_twist:  EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_2\n                    -> (t_Fp_12, EC::AffinePoint t_Fp_2)\n                    -> Bit -> (t_Fp_12, EC::AffinePoint t_Fp_2)\nmiller_step_twist P negQ (f, T) ci = (f', T') where\n    f0 = f12.mul (f12.sq f, line_function (phi_4 T) (phi_4 T) (phi_3 P))\n    T0 = EC::double P::E' T\n    (f', T') = if ci\n               then (P::Fp_12.mul (f0, line_function (phi_4 T0) (phi_4 negQ) (phi_3 P)),\n                     EC::add P::E' T0 negQ)\n               else (f0, T0)\n\n*\/\n\n\/* Note first that the generic line_function(A,B,P) tests whether A=B or A=-B.\n   We know when calling it when A=B occurs (in the doubling steps), and argued above that\n   A=-B never happens in the cases we care about.  So we can separate out two functions\n   `line_function_add` and `line_function_double`\n\n   line_function_add (A,B,P) = (B2-A2)\/(B1-A1)*(P1-A1) + A2 - P2\n   line_function_double (A,B,P) = (3 A1^2) \/ (2 A2) * (P1-A1) + A2 - P2\n\n   where A = (A1,A2), B=(B1,B2), and P=(P1, P2), in affine coordinates, and all on the twist\n*\/\n\n\/*\n  For the question of how to eliminate division, even when using projective\n  coordinates for A, Costello, Lange, and Naehrig explain how (but in their\n  paper using a different system of projective coordinates).  Here, in the\n  Jacobian system, we can retrace the derivation.\n\n  For the addition step, point A is the projective, non-point-at-infinity, T =\n  (xT:yT:zT), so A1 = xT\/zT^2 and A2 = yT\/zT^3.  B is point Q, already in\n  affine coordinates (xQ, yQ), so B1 = xQ, B2 = yQ, and P = (xP, yP) is in\n  affine coordinate on curve E and is mapped via phi_3 to curve E'.  Thus P1 =\n  w^2 xP, P2 = w^3 yP.  So we can compute the line_function output:\n\n    line_function_add(T, Q, P))\n  = (as defined above)\n    (B2-A2)\/(B1-A1)*(P1-A1) + A2 - P2\n  = (substituting these variables)\n    (yQ - yT\/zT^3)\/(xQ-xT\/zT^2) * (w^2 xP - xT\/zT^2) + yT\/zT^3 - w^3 yP\n  = (simplifying the fraction)\n    (yQ zT^3 - yT)\/(xQ zT^3 -xT zT) * (w^2 xP - xT\/zT^2) + yT\/zT^3 - w^3 yP\n\n  Now we can multiply this by any value in a proper subfield of Fp_12 without\n  affecting the result of the final exponentiation, which sends all such\n  values to 1.  So we can use a factor of k = (xQ zT^3 - xT zT) (which lies in\n  Fp_2) to eliminate most of the division:\n\n    k * line_function_add(T, Q, P)\n  = (algebra)\n    (yQ zT^3 - yT) (w^2 xP - xT\/zT^2) +  (xQ zT^3 - xT zT)(yT\/zT^3 - w^3 yP)\n  = (expand out, collect terms)\n     w^2 xP (yQ zT^3 - yT)\n     - w^3 yP (xQ zT^3 - xT zT)\n     - yQ xT zT + yT xT \/ zT^2 + xQ yT - xT yT \/ zT^2\n  = (cancel matching terms)\n     w^2 xP (yQ zT^3 - yT)\n     - w^3 yP (xQ zT^3 - xT zT)\n     - yQ xT zT + xQ yT\n\n  The C code produces -4 times these values, but as -4 in is a proper subfield\n  this does not affect the result of the final exponentiation.\n*\/\n\n\/\/ line_add_opt: (t_Fp_2,t_Fp_2,t_Fp_2) -> (t_Fp_2, t_Fp_2) -> (t_Fp,t_Fp) -> t_Fp_12\nline_add_opt: EC::ProjectivePoint t_Fp_2 -> EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nline_add_opt (xT, yT, zT) (xQ, yQ) (xP, yP) = ret where\n    xP' = Fp_to_Fp_2 xP\n    yP' = Fp_to_Fp_2 yP\n    l0 = Fp_2.sub (Fp_2.mul (yQ, Fp_2.mul (xT, zT)), Fp_2.mul (xQ, yT)) \/\/ yQ xT zT - xQ yT\n    l1 = Fp_2.mul (Fp_2.sub (yT, Fp_2.mul (yQ, zT3)), xP') \/\/ xP (yT - yQ zT^3)\n    l2 = Fp_2.mul (Fp_2.sub (Fp_2.mul (xQ, zT3), Fp_2.mul (xT, zT)), yP') \/\/ yP (xQ zT^3 - xT zT)\n    zT3 = Fp_2.mul (zT, Fp_2.sq zT) \/\/ zT^3\n    ret = fp6_to_fp12_xy00z0 [ mul_by_4 Fp_2 l2  \/\/ factor of w^3\n                             , mul_by_4 Fp_2 l1  \/\/ factor of w^2\n                             , mul_by_4 Fp_2 l0                              ]\n\n\/*\n  Similarly, for the doubling step, we have\n\n    line_function_dbl(T, Q, P)\n  = (definition)\n    (3 A1^2) \/ (2 A2) * (P1-A1) + A2 - P2\n  = (substitute the variables)\n    (3 xT^2 \/ zT^4) \/ (2 yT\/zT^3) * (w^2 xP - xT\/zT^2) + yT\/zT^3 - w^3 yP\n  = (simplify the fraction)\n    (3 xT^2) \/ (2 yT zT) * (w^2 xP - xT\/zT^2) + yT\/zT^3 - w^3 yP\n\n  This time we can use a factor of k' = (2 yT zT^3), also in Fp_2\n\n    k' * line_function_dbl(T, Q, P)\n  = (algebra)\n    (3 xT^2 zT^2) (w^2 xP - xT\/zT^2) + (2 yT zT^3) (yT\/zT^3 - w^3 yP)\n  = (expand out, collect terms)\n    3 w^2 xP xT^2 zT^2\n    - 2 w^3 yP yT zT^3\n   -  3 xT^3 + 2 yT^2\n\n  In this cases, the C code computes -2 times these values; again this does not\n  affect the result of the final exponentiation.\n*\/\n\n\/\/ line_double_opt: (t_Fp_2,t_Fp_2,t_Fp_2) -> (t_Fp,t_Fp) -> t_Fp_12\nline_double_opt: EC::ProjectivePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nline_double_opt (xT,yT,zT) (xP, yP) = ret where\n    xP' = P::Fp_to_Fp_2 xP\n    yP' = P::Fp_to_Fp_2 yP\n    l0 = Fp_2.sub (mul_by_3 Fp_2 (cubed xT), mul_by_2 Fp_2 (Fp_2.sq yT)) \/\/ 3xT^3 - 2yT^2\n    l1 = Fp_2.neg (mul_by_3 Fp_2 (Fp_2.mul (Fp_2.sq xT, Fp_2.mul (Fp_2.sq zT, xP')))) \/\/ -3 xP xT^2 zT^2\n    l2 = Fp_2.mul (mul_by_2 Fp_2 (Fp_2.mul (yT, cubed zT)), yP') \/\/ 2 yP yT zT^3\n\n    ret = fp6_to_fp12_xy00z0 [ mul_by_2 Fp_2 l2 \/\/ factor of w^3\n                             , mul_by_2 Fp_2 l1 \/\/ factor of w^2\n                             , mul_by_2 Fp_2 l0                              ]\n    cubed x = Fp_2.mul (x, Fp_2.sq x)\n\n\n\/* Putting all that together, with the conjugation trick of step 5, gives this function,\n   which we will use as a high-level specification for the C code. *\/\n\nmiller_step_opt:  EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_2\n                    -> (t_Fp_12, EC::ProjectivePoint t_Fp_2)\n                    -> Bit\n                    -> (t_Fp_12, EC::ProjectivePoint t_Fp_2)\nmiller_step_opt P Q (f, T) ci = (f', T') where\n    f0 = Fp_12.mul (Fp_12.sq f, line_double_opt T P)\n    T0 = point_double Fp_2 T\n    (f', T') = if ci\n               then (Fp_12.mul (f0, line_add_opt T0 Q P),\n                     point_add_affine_alt Fp_2 T0 Q) \/\/ _alt, we know T and Q are not at infinity\n               else (f0, T0)\n\nmiller_loop_opt: EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_2 -> t_Fp_12\nmiller_loop_opt P Q =  fp12_conjugate last_f where\n   (last_f, _) = f_Ts ! 0\n   f_Ts = [(Fp_12.field_unit, EC::projectify P::E' Q)] #\n          [ miller_step_opt P Q fT ci | fT <- f_Ts | ci <- tail negative_t]\n   \/\/ t = -2^63 - 2^62 - 2^60 - 2^57 - 2^48 - 2^16\n   negative_t:[64]\n   negative_t = <| x^^63 + x^^62 + x^^60 + x^^57 + x^^48 + x^^16 |>\n\n\nmiller_loop_opt_checked:  EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_2 -> t_Fp_12\nmiller_loop_opt_checked P Q =\n    if EC::is_point_O E' Q  \\\/ EC::is_point_O E P\n    then Fp_12.field_unit\n    else miller_loop_opt P Q\n\n\/\/ This version avoids the extra check for z1 == 0, relative to point_add_affine\n\npoint_add_affine_alt: {t} FieldRep t -> EC::ProjectivePoint t -> EC::AffinePoint t -> EC::ProjectivePoint t\npoint_add_affine_alt F p1 p2 = p3 where\n    (x1, y1, z1) = normalize_point F p1\n    (x2, y2) = normalize_affine_point F p2\n    z1z1 = F.sq z1\n    h = F.mul(x2,z1z1)\n    r = F.mul(F.mul(y2,z1), z1z1)\n\n    h_1 = F.sub(h, x1)\n    hh = F.sq h_1\n    i = (F.add (hh,hh))\n    i_1 = F.add (i,i)\n\n    j = F.mul (h_1, i_1)\n\n    r_1 = F.sub(r, y1)\n    r_2 = F.add(r_1, r_1)\n\n    v = F.mul(x1, i_1)\n\n    x3 = F.sub(F.sub(F.sub(F.sq r_2, j), v), v)\n\n    j_1 = F.mul(j, y1)\n    y3 = F.sub(v, x3)\n    y3_1 = F.mul(y3, r_2)\n    y3_2 = F.sub(F.sub(y3_1, j_1), j_1)\n\n    z3 = F.add(z1,h_1)\n    z3_1 = F.sq z3\n    z3_2 = F.sub (z3_1, z1z1)\n    z3_3 = F.sub (z3_2, hh)\n\n    p3 = (x3, y3_2, z3_3)\n\nlshift_fp: t_Fp -> Size_t -> t_Fp\nlshift_fp a c = shifts @ c where shifts = [a] # [Fp.add (a',a') | a' <- shifts ]\n\nlshift_fp2: t_Fp_2 -> Size_t -> t_Fp_2\nlshift_fp2 [a1,a0] c = [lshift_fp a1 c, lshift_fp a0 c]\n\nline_by_Px2: t_Fp_6 -> (t_Fp, t_Fp) -> t_Fp_6\nline_by_Px2 [[l2_1, l2_0], [l1_1, l1_0], l0]  (Px, Py) = [l2', l1', l0] where\n    l1' = [Fp.mul (l1_1, Px), Fp.mul (l1_0, Px)]\n    l2' = [Fp.mul (l2_1, Py), Fp.mul (l2_0, Py)]\n\nline_double_imp: (t_Fp_2, t_Fp_2, t_Fp_2) -> t_Fp_6\nline_double_imp (X1, Y1, Z1) = [l2, l1, l0] where\n    A = Fp_2.sq X1\n    E = mul_by_3 Fp_2 A\n    F = Fp_2.sq E\n    B = Fp_2.sq Y1\n    l0_a = Fp_2.add (E, X1)\n    l0_b = Fp_2.sub (Fp_2.sq l0_a, A)\n    l0_c = Fp_2.sub (l0_b, F)\n    l0 = Fp_2.sub (l0_c, lshift_fp2 B 2)\n    l1 = Fp_2.mul (mul_by_3 Fp_2 (Fp_2.sq X1), Fp_2.sq Z1)\n    l2 = Fp_2.mul (Fp_2.mul (Fp_2.add (Z1, Z1), Y1), Fp_2.sq Z1)\n\nline_add_imp (x1,y1,z1) (x2,y2) = [l2, l1, l0] where\n    F = Fp_2\n    z1z1 = F.sq z1\n    h = F.mul(x2,z1z1)\n    r = F.mul(F.mul(y2,z1), z1z1)\n\n    h_1 = F.sub(h, x1)\n    hh = F.sq h_1\n    i = (F.add (hh,hh))\n    i_1 = F.add (i,i)\n\n    r_1 = F.sub(r, y1)\n    r_2 = F.add(r_1, r_1)\n\n    z3 = F.add(z1,h_1)\n    z3_1 = F.sq z3\n    z3_2 = F.sub (z3_1, z1z1)\n    z3_3 = F.sub (z3_2, hh)\n\n    l0 = mul_by_2 F (F.sub (F.mul (r_2, x2), F.mul (y2, z3_3)))\n    l1 = r_2\n    l2 = z3_3\n\nstart_dbl_n_imp: {n} (fin n, n >= 1) => [n](t_Fp_2, t_Fp_2, t_Fp_2) -> [n](t_Fp, t_Fp) -> t_Fp_12\nstart_dbl_n_imp Ts Px2s = rets!0 where\n    line_a = line_double_imp (Ts@0)\n    line_b = line_by_Px2 line_a (Px2s@0)\n    ret_a = fp6_to_fp12_xy00z0 line_b\n    \/\/ standard loop-to-comprehension transcription of the C code\n    rets = [ret_a] # [Fp_12.mul (ret,  fp6_to_fp12_xy00z0 line) | ret <- rets | line <- lines]\n    lines = [line_by_Px2 (line_double_imp T) P | T <- tail Ts | P <- tail Px2s]\n\n\/\/ effect of one point.\nstart_dbl_1: (t_Fp_2, t_Fp_2, t_Fp_2) -> (t_Fp, t_Fp) -> t_Fp_12\nstart_dbl_1 T Px2 = ret where\n    line_a = line_double_imp T\n    line_b = line_by_Px2 line_a Px2\n    ret = fp6_to_fp12_xy00z0 line_b\n\n\/\/ effect on point T -- each of the T_i, Q_i affected independently in the same way\n\/\/ named _alt to avoid conflict with the definition in HashToG2.cry\nadd_n_dbl_alt: {k} (fin k) => EC::ProjectivePoint t_Fp_2 ->  EC::AffinePoint t_Fp_2 -> EC::ProjectivePoint t_Fp_2\nadd_n_dbl_alt T Q = doubles@`k where\n    doubles = [point_add_affine_alt Fp_2 T Q] # [ point_double Fp_2 D | D <- doubles]\n\n\/\/ effect on ret - n=1 case\nadd_n_dbl_ret: {k} (fin k) =>\n      t_Fp_12 -> EC::ProjectivePoint t_Fp_2 -> EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nadd_n_dbl_ret r T Q Px2 = rets@`k where\n    ret_a = Fp_12.mul (r, fp6_to_fp12_xy00z0 (line_by_Px2 (line_add_imp T Q) Px2))\n    T_a = point_add_affine_alt Fp_2 T Q\n    \/\/ standard loop-to-comprehension transcription of the C code, for the loop on `k`\n    Ts = [T_a] # [point_double Fp_2 Ti | Ti <- Ts]\n    lines = [line_by_Px2 (line_double_imp Ti) Px2 | Ti <- Ts ]\n    rets = [ret_a] # [Fp_12.mul (Fp_12.sq ret, fp6_to_fp12_xy00z0 line) | ret <- rets | line <- lines]\n\n\/\/ and for n >= 1\nadd_n_dbl_n_ret: {n, k} (fin n, n >= 1, fin k) =>\n     t_Fp_12 ->[n](EC::ProjectivePoint t_Fp_2) -> [n](EC::AffinePoint t_Fp_2) -> [n](EC::AffinePoint t_Fp)\n     -> t_Fp_12\nadd_n_dbl_n_ret r Ts Qs Px2s = F_prod Fp_12 rets where\n    rets = [add_n_dbl_ret`{k} r (Ts@0) (Qs@0) (Px2s@0)] #\n           [add_n_dbl_ret`{k} Fp_12.field_unit T Q Px2 | T <- tail Ts | Q <- tail Qs | Px2 <- tail Px2s]\n\n\/\/\/\/ miller_loop_n\n\nmiller_loop_imp: EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nmiller_loop_imp Q P = fp12_conjugate ret_f where\n    (xP, yP) = P\n    Px2 = (Fp.neg (Fp.add (xP, xP)), Fp.add (yP, yP))\n    (xQ, yQ) = Q\n    T = (xQ, yQ, Fp_2.field_unit)\n    ret_a = start_dbl_n_imp [T] [Px2]\n    T_a = point_double Fp_2 T\n    ret_b = add_n_dbl_ret`{2} ret_a T_a Q Px2\n    T_b = add_n_dbl_alt`{2} T_a Q\n    ret_c = add_n_dbl_ret`{3} ret_b T_b Q Px2\n    T_c = add_n_dbl_alt`{3} T_b Q\n    ret_d = add_n_dbl_ret`{9} ret_c T_c Q Px2\n    T_d = add_n_dbl_alt`{9} T_c Q\n    ret_e = add_n_dbl_ret`{32} ret_d T_d Q Px2\n    T_e = add_n_dbl_alt`{32} T_d Q\n    ret_f = add_n_dbl_ret`{16} ret_e T_e Q Px2\n\nmiller_loop_n_1_imp:  EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nmiller_loop_n_1_imp Q P = (if Q == (z2,z2) \\\/ P == (z1,z1)\n                           then Fp_12.field_unit\n                           else miller_loop_imp Q P) where\n    z1 = Fp.field_zero\n    z2 = Fp_2.field_zero\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/Keygen.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties and verification scripts to formally specify and verify the correctness of the KeyGen_rep function and its helper functions (KeyGenStep_rep, KeyGenLoop_rep) in the implementation::Keygen module. Ensure the specifications capture the intended behavior of the BLS signature key generation process, including the correctness of Montgomery arithmetic operations, HKDF extraction and expansion, and the iterative key generation loop. Include properties that relate the bitvector and integer representations and verify that the final secret key output matches the expected mathematical definitions modulo the curve order."},{"role":"assistant","content":"```cryptol\nmodule implementation::Keygen where\n\n\/\/ Definitions needed for the code proof of blst_keygen\n\nimport Parameters as P\nimport Primitive::Keyless::Hash::SHA256\nimport Primitive::Symmetric::KDF::HKDF256\nimport rfc8017\n\nimport Common::bv\n\nimport implementation::Types\nimport implementation::Field\n\n\/\/ Implementation types - now in implementation::Types\n\/\/\n\/*\ntype Vec256 = [4][64]\ntype Vec384 = [6][64]\ntype Vec512 = [8][64]\n\ntype Limb = [64]\n\ntype Pow256 = [32][8]\n\n\/\/ Vectors represent numbers, using a little-endian representation\n\n\/**\n * The integer represented by a vector (Vec256, Vec384, ...)\n *\/\nvec_abs: {n} (fin n) => [n]Limb -> [n*64]\nvec_abs limbs = join (reverse limbs)\n\nvec256_abs x = vec_abs`{256\/64} x\nvec512_abs = vec_abs`{512\/64}\n\n\/**\n * A vector representing a given integer.  The integer should be non-negative.\n *\/\nvec_rep:  {n} (fin n) => [n*64] -> [n]Limb\nvec_rep x = reverse (split x)\n\nvec256_rep x = vec_rep`{256\/64} x\n*\/\n\n\/\/ Pow256 uses a little-endian representation\n\npow256_abs: Pow256 -> [256]\npow256_abs x = join (reverse x)\n\n\/\/ for Montgomery mod r\n\nr_modulus = toInteger P::r \/\/ 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001 \/\/ r\n\nr_R = 2^^256\n\nr_R_inv = toInteger 0x1bbe869330009d577204078a4f77266aab6fca8f09dc705f13f75b69fe75c040\n\nr_RR = 2^^512\n\n\/\/ Montgomery representation of values; Integer form\n\nr_R_reduced = r_R % r_modulus\nr_RR_reduced = r_RR % r_modulus\nr_R_inv_reduced = r_R_inv % r_modulus\n\nr_to_mont x = (x*r_R) % r_modulus\n\nr_from_mont x = (x*r_R_inv) % r_modulus\n\nr_add_mont x y = (x+y) % r_modulus\n\nr_mul_mont x y = (x*y*r_R_inv) % r_modulus\n\nproperty keygen_finish_integer x = r_mul_mont (r_from_mont x) (2^^512 % r_modulus) == (x % r_modulus)\n\n\/\/ ... and bitvector form\n\nbv_r = (fromInteger r_modulus):[256] \/\/ = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\nbv_R = (fromInteger r_R_reduced):[256]\nbv_R_inv = (fromInteger r_R_inv):[256] \/\/ = 0x1bbe869330009d577204078a4f77266aab6fca8f09dc705f13f75b69fe75c040\nbv_RR = (fromInteger r_RR_reduced):[256]\n\nmul_mont_r_bv: [256] -> [256] -> [256]\nmul_mont_r_bv a b = safe_mod (bv_r, safe_product (zext a, safe_product (b, bv_R_inv)))\n\nredc_r_bv: [512] -> [256]\nredc_r_bv x = safe_mod (bv_r, safe_product (x, zext bv_R_inv))\n\nproperty keygen_finish_bv x =\n  safe_mod (bv_r, x) == mul_mont_r_bv (redc_r_bv x) bv_RR\n\n\/\/ concretized versions\n\n\/\/ r_modulus_rep = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\n\nmul_mont_256_rep: Vec256 -> Vec256 -> Vec256\nmul_mont_256_rep x y = vec256_rep (mul_mont_r_bv (vec256_abs x) (vec256_abs y))\n\nr_redc_rep: Vec512 -> Vec256\nr_redc_rep x = vec256_rep (redc_r_bv (vec512_abs x))\n\nr_RR_rep: Vec256 \/\/ representing R^2 mod r\nr_RR_rep = [14526898881837571181, 3129137299524312099, 419701826671360399, 524908885293268753]\n\n\/\/ property p2 x = mul_mont_256_rep (from_mont_rep x) RR == (x % r_modulus_rep)\n\nlimbs_from_be_bytes_rep48: [48][8] -> [6]Limb\nlimbs_from_be_bytes_rep48 bytes = reverse (split (join bytes))\n\nle_bytes_from_limbs_rep4: Vec256 -> Pow256\nle_bytes_from_limbs_rep4 limbs = reverse (split (join (reverse limbs)))\n\nproperty le_bytes_from_limbs_rep4_prop limbs =\n    pow256_abs (le_bytes_from_limbs_rep4 limbs) == vec256_abs limbs\n\n\/**\n * KeyGen as implemented in the code\n *\/\nKeyGenStep_rep: {IKM_len, info_len} (validHMACSizes 20 (1+IKM_len)\n                                    , validHMACSizes 32 (35+info_len)\n                                    ) =>\n        [256] -> [IKM_len][8] -> [info_len][8] -> Vec256\nKeyGenStep_rep salt IKM key_info = SK where\n    type L = (3 * 256) \/^ 16 \/\/ (ceil lg2 r) = 256, so L = 3*16=48\n    PRK = HKDF_Extract (split salt) (IKM # [0]) \/\/ I2OSP`{xLen=1} 0)\n    OKM = HKDF_Expand`{L=L} PRK (key_info # I2OSP`{xLen=2} `L)\n    OKM_vec = (limbs_from_be_bytes_rep48 OKM) # [0,0]\n    SK = mul_mont_256_rep (r_redc_rep OKM_vec) r_RR_rep\n\nKeyGenLoop_rep: {IKM_len, info_len} (validHMACSizes 20 (1+IKM_len)\n                                    , validHMACSizes 32 (35+info_len)\n                                    ) =>\n        [256] -> [IKM_len][8] -> [info_len][8] -> [inf]Vec256\nKeyGenLoop_rep salt IKM info = keys where\n    salts = [salt] # [sha salt' | salt' <- salts]\n    keys = [zero] #\n           \/\/ hang on to a nonzero key, try again with revised salt otherwise\n           [if k == zero then key_gen_step salt' else k | k <- keys | salt' <- salts]\n    key_gen_step s = KeyGenStep_rep s IKM info\n\nKeyGen_rep: {IKM_len, info_len} ( validHMACSizes 20 (1+IKM_len)\n                                , validHMACSizes 32 (35+info_len)\n                                ) =>\n        ([IKM_len][8], [info_len][8]) -> Pow256\nKeyGen_rep (IKM, key_info) = le_bytes_from_limbs_rep4 SK_vec where\n    SK_vec = (KeyGenLoop_rep (sha (join \"BLS-SIG-KEYGEN-SALT-\")) IKM key_info) @ 4\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/Psi.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the function `psi_imp` in the `implementation::Psi` module. The specification should capture the expected algebraic behavior of `psi_imp` on projective points over the field `t_Fp_2`, ensuring that the implementation matches the mathematical definition of the Psi endomorphism. Include properties that relate `psi_imp` to the auxiliary functions `psi_projective_imp` and `projective_pair_to_jacobian_imp`, and verify that the transformations preserve the group structure and field operations as intended."},{"role":"assistant","content":"```cryptol\nmodule implementation::Psi where\n\nimport Frobenius\nimport G2SubGroupCheck\nimport Pairing\nimport Parameters\nimport ShortWeierstrassCurve\n\npsi_imp: ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\npsi_imp P = projective_pair_to_jacobian_imp qpp where\n  pp = jacobian_to_projective_pair P\n  qpp = psi_projective_imp pp\n\npsi_x_factor = Fp_2.mul (alpha, [Fp.field_zero,psi_c1@0])\nqi_x_abs x = fp2_frobenius (Fp_2.mul (x, psi_x_factor))\npsi_y_factor = Fp_2.mul (alpha, Fp_2.neg psi_c2)\nqi_y_abs x = fp2_frobenius (Fp_2.mul (x, psi_y_factor))\n\npsi_projective_imp (xn, xd, yn, yd) = (qxn, qxd, qyn, qyd) where\n  qxn = Fp_2.mul (qi_x_abs xn, psi_c1)\n  qxd = qi_x_abs xd\n  qyn = Fp_2.mul (qi_y_abs yn, psi_c2)\n  qyd = qi_y_abs yd\n\n\/\/ This is a simple algebraic reanrrangement of `projective_pair_to_jacobian`\nprojective_pair_to_jacobian_imp: projective_pair_fp2 -> ProjectivePoint t_Fp_2\nprojective_pair_to_jacobian_imp (xn, xd, yn, yd) = (X', Y', Z') where\n  X' = Fp_2.mul (xn, Fp_2.mul (yd, Z'))\n  Y' = Fp_2.mul (Fp_2.sq Z', Fp_2.mul (xd, yn))\n  Z' = Fp_2.mul (xd, yd)\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/Types.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the vector and scalar conversion functions defined in the implementation::Types module. Specifically, specify properties that check that vec_abs and vec_rep are inverses of each other for all valid inputs, that bool_to_limb correctly maps Boolean values to limbs, and that scalar_to_integer correctly computes the integer value from a scalar byte sequence and bit length. Include boundary cases and ensure the properties are suitable for :prove or :check commands."},{"role":"assistant","content":"```cryptol\n\/\/ Implementation types for blst\n\/\/\n\nmodule implementation::Types where\n\ntype Vec256 = [4][64]\ntype Vec384 = [6][64]\ntype Vec512 = [8][64]\ntype Vec768 = [12][64]\ntype Pow256 = [32][8]\ntype Limb = [64]\ntype Size_t = [64]\n\n\/\/ Vectors represent numbers, using a little-endian representation\n\n\/**\n * The integer (bitvector) represented by a vector (Vec256, Vec384, ...)\n *\/\nvec_abs: {n} (fin n) => [n]Limb -> [n*64]\nvec_abs limbs = join (reverse limbs)\n\nvec256_abs = vec_abs`{256\/64}\nvec384_abs = vec_abs`{384\/64}\nvec512_abs = vec_abs`{512\/64}\nvec768_abs = vec_abs`{768\/64}\n\n\/**\n * A vector representing a given (bitvector) integer.  The integer should be non-negative.\n *\/\nvec_rep:  {n} (fin n) => [n*64] -> [n]Limb\nvec_rep x = reverse (split x)\n\nvec256_rep = vec_rep`{256\/64}\nvec384_rep = vec_rep`{384\/64}\nvec768_rep = vec_rep`{768\/64}\n\n\/**\n * Represent a Boolean as a limb, with value 1 for true, 0 for false\n *\/\nbool_to_limb: Bool -> Limb\nbool_to_limb b = if b then (1:Limb) else 0\n\nselect: {t} t -> t-> Bit -> t\nselect a b c = if c then a else b\n\n\/\/ \"Scalars\" represent integers as a sequence of bytes, and allow for the\n\/\/ the exact number of used bits to be given\n\/\/ The bytes are in little-endian order\n\nscalar_to_integer: {n} (fin n, n >= 1, n <= 2^^60) => [n][8] -> Limb -> Integer\nscalar_to_integer bytes n_bits = vs!0 where\n    bits = join (reverse bytes)\n    vs = [0] # [ if j < n_bits then 2*v + (if b then 1 else 0) else 0\n               | b <- bits \/\/ bits from the MSB down\n               | j <- reverse [0 .. 8*n - 1]                | v <- vs ] \/\/ accumulated value\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/x86\/inverse.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the function `ctx_inverse_mod_383` in the given Cryptol module. The properties should specify that for inputs `a` and `n`, where `n` is a modulus, the output corresponds to the modular inverse of `a` modulo `n` as computed by the implemented algorithm. Include properties that check intermediate function correctness, such as `__smulx_383_n_shift_by_31` and `__ab_approximation_31`, and ensure the overall function satisfies modular inversion properties."},{"role":"assistant","content":"```cryptol\nmodule implementation::x86::inverse where\n\nimport implementation::Types\nimport implementation::x86::helpers\n\n__smulx_383_n_shift_by_31\n  : Vec384 \/\/ a, stored at low offsets of rsi\n  -> Vec384 \/\/ b, stored at high offsets of rsi\n  -> [64] \/\/ f0\n  -> [64] \/\/ g0\n  -> (Vec384, [64], [64])\n__smulx_383_n_shift_by_31 a b f0 g0 = result\n  where\n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0] = a\n    r14_0 = 0\n    rdx_0 = f0\n    rcx_0 = g0\n    rbx_0 = rdx_0\n    rax_1 = rdx_0\n    rax_2 = sar rax_1 0x3f\n    rbp_3 = 0\n    (cf_4, rbp_4) = sub rbp_3 rax_2\n    rdx_5 = rdx_0 ^ rax_2\n    (cf_6, rdx_6) = add rdx_5 rbp_4\n    r8_7 = r8_0 ^ rax_2\n    r9_8 = r9_0 ^ rax_2\n    r10_9 = r10_0 ^ rax_2\n    r11_10 = r11_0 ^ rax_2\n    r12_11 = r12_0 ^ rax_2\n    rax_12 = rax_2 ^ r13_0\n    (cf_13, r8_13) = add r8_7 rbp_4\n    (cf_14, r9_14) = adc r9_8 0 cf_13\n    (cf_15, r10_15) = adc r10_9 0 cf_14\n    (cf_16, r11_16) = adc r11_10 0 cf_15\n    (cf_17, r12_17) = adc r12_11 0 cf_16\n    (cf_18, rax_18) = adc rax_12 0 cf_17\n    (rbp_19, r8_19) = mulx r8_13 rdx_6\n    (r13_20, r9_20) = mulx r9_14 rdx_6\n    (cf_21, r9_21) = add r9_20 rbp_19\n    (rbp_22, r10_22) = mulx r10_15 rdx_6\n    (cf_23, r10_23) = adc r10_22 r13_20 cf_21\n    (r13_24, r11_24) = mulx r11_16 rdx_6\n    (cf_25, r11_25) = adc r11_24 rbp_22 cf_23\n    (rbp_26, r12_26) = mulx r12_17 rdx_6\n    (cf_27, r12_27) = adc r12_26 r13_24 cf_25\n    (cf_28, rbp_28) = adc rbp_26 0 cf_27\n    (rdx_29, rax_29) = imul1 rdx_6 rax_18\n    (cf_30, rax_30) = add rax_29 rbp_28\n    (cf_31, r14_31) = adc r14_0 rdx_29 cf_30\n    rdx_32 = rcx_0\n    offload0 = r8_19\n    offload1 = r9_21\n    offload2 = r10_23\n    offload3 = r11_25\n    offload4 = r12_27\n    offload5 = rax_30\n    r8_39 = b @ 0\n    r9_40 = b @ 1\n    r10_41 = b @ 2\n    r11_42 = b @ 3\n    r12_43 = b @ 4\n    r13_44 = b @ 5\n    rax_45 = rdx_32\n    rax_46 = sar rax_45 0x3f\n    rbp_47 = 0\n    (cf_48, rbp_48) = sub rbp_47 rax_46\n    rdx_49 = rdx_32 ^ rax_46\n    (cf_50, rdx_50) = add rdx_49 rbp_48\n    r8_51 = r8_39 ^ rax_46\n    r9_52 = r9_40 ^ rax_46\n    r10_53 = r10_41 ^ rax_46\n    r11_54 = r11_42 ^ rax_46\n    r12_55 = r12_43 ^ rax_46\n    rax_56 = rax_46 ^ r13_44\n    (cf_57, r8_57) = add r8_51 rbp_48\n    (cf_58, r9_58) = adc r9_52 0 cf_57\n    (cf_59, r10_59) = adc r10_53 0 cf_58\n    (cf_60, r11_60) = adc r11_54 0 cf_59\n    (cf_61, r12_61) = adc r12_55 0 cf_60\n    (cf_62, rax_62) = adc rax_56 0 cf_61\n    (rbp_63, r8_63) = mulx r8_57 rdx_50\n    (r13_64, r9_64) = mulx r9_58 rdx_50\n    (cf_65, r9_65) = add r9_64 rbp_63\n    (rbp_66, r10_66) = mulx r10_59 rdx_50\n    (cf_67, r10_67) = adc r10_66 r13_64 cf_65\n    (r13_68, r11_68) = mulx r11_60 rdx_50\n    (cf_69, r11_69) = adc r11_68 rbp_66 cf_67\n    (rbp_70, r12_70) = mulx r12_61 rdx_50\n    (cf_71, r12_71) = adc r12_70 r13_68 cf_69\n    (cf_72, rbp_72) = adc rbp_70 0 cf_71\n    (rdx_73, rax_73) = imul1 rdx_50 rax_62\n    (cf_74, rax_74) = add rax_73 rbp_72\n    (cf_75, rdx_75) = adc rdx_73 0 cf_74\n    (cf_76, r8_76) = add r8_63 offload0\n    (cf_77, r9_77) = adc r9_65 offload1 cf_76\n    (cf_78, r10_78) = adc r10_67 offload2 cf_77\n    (cf_79, r11_79) = adc r11_69 offload3 cf_78\n    (cf_80, r12_80) = adc r12_71 offload4 cf_79\n    (cf_81, rax_81) = adc rax_74 offload5 cf_80\n    (cf_82, r14_82) = adc r14_31 rdx_75 cf_81\n    rdx_83 = rbx_0\n    r8_84 = shrd r8_76 r9_77 (zext`{64} 0x1f)\n    r9_85 = shrd r9_77 r10_78 (zext`{64} 0x1f)\n    r10_86 = shrd r10_78 r11_79 (zext`{64} 0x1f)\n    r11_87 = shrd r11_79 r12_80 (zext`{64} 0x1f)\n    r12_88 = shrd r12_80 rax_81 (zext`{64} 0x1f)\n    rax_89 = shrd rax_81 r14_82 (zext`{64} 0x1f)\n    r14_90 = sar r14_82 0x3f\n    rbp_91 = 0\n    (cf_92, rbp_92) = sub rbp_91 r14_90\n    r8_93 = r8_84 ^ r14_90\n    r9_94 = r9_85 ^ r14_90\n    r10_95 = r10_86 ^ r14_90\n    r11_96 = r11_87 ^ r14_90\n    r12_97 = r12_88 ^ r14_90\n    rax_98 = rax_89 ^ r14_90\n    (cf_99, r8_99) = add r8_93 rbp_92\n    (cf_100, r9_100) = adc r9_94 0 cf_99\n    (cf_101, r10_101) = adc r10_95 0 cf_100\n    (cf_102, r11_102) = adc r11_96 0 cf_101\n    (cf_103, r12_103) = adc r12_97 0 cf_102\n    (cf_104, rax_104) = adc rax_98 0 cf_103\n    result0 = r8_99\n    result1 = r9_100\n    result2 = r10_101\n    result3 = r11_102\n    result4 = r12_103\n    result5 = rax_104\n    rdx_111 = rdx_83 ^ r14_90\n    rcx_111 = rcx_0 ^ r14_90\n    (cf_113, rdx_113) = add rdx_111 rbp_92\n    (cf_114, rcx_114) = add rcx_111 rbp_92\n    result = ([result0, result1, result2, result3, result4, result5], rdx_113, rcx_114)\n\n__smulx_191_n_shift_by_31\n  : [3][64] \/\/ a, stored at low offsets of rsi\n  -> [3][64] \/\/ b, stored at high offsets of rsi\n  -> [64] \/\/ f0\n  -> [64] \/\/ g0\n  -> ([3][64], [64], [64])\n__smulx_191_n_shift_by_31 a b f0 g0 = result\n  where\n    [r8_0, r9_0, r10_0] = take a\n    rdx_0 = f0\n    rcx_0 = g0\n    rbx_0 = rdx_0\n    rax_1 = rdx_0\n    rax_2 = sar rax_1 0x3f\n    rbp_3 = 0\n    (cf_4, rbp_4) = sub rbp_3 rax_2\n    rdx_5 = rdx_0 ^ rax_2\n    (cf_6, rdx_6) = add rdx_5 rbp_4\n    r8_7 = r8_0 ^ rax_2\n    r9_8 = r9_0 ^ rax_2\n    rax_9 = rax_2 ^ r10_0\n    (cf_10, r8_10) = add r8_7 rbp_4\n    (cf_11, r9_11) = adc r9_8 0 cf_10\n    (cf_12, rax_12) = adc rax_9 0 cf_11\n    (rbp_13, r8_13) = mulx r8_10 rdx_6\n    (r10_14, r9_14) = mulx r9_11 rdx_6\n    (cf_15, r9_15) = add r9_14 rbp_13\n    (cf_16, r10_16) = adc r10_14 0 cf_15\n    (rdx_17, rax_17) = imul1 rdx_6 rax_12\n    (cf_18, r10_18) = add r10_16 rax_17\n    (cf_19, rdx_19) = adc rdx_17 0 cf_18\n    r14_20 = rdx_19\n    rdx_21 = rcx_0\n    r11_22 = b @ 0\n    r12_23 = b @ 1\n    r13_24 = b @ 2\n    rax_25 = rdx_21\n    rax_26 = sar rax_25 0x3f\n    rbp_27 = 0\n    (cf_28, rbp_28) = sub rbp_27 rax_26\n    rdx_29 = rdx_21 ^ rax_26\n    (cf_30, rdx_30) = add rdx_29 rbp_28\n    r11_31 = r11_22 ^ rax_26\n    r12_32 = r12_23 ^ rax_26\n    rax_33 = rax_26 ^ r13_24\n    (cf_34, r11_34) = add r11_31 rbp_28\n    (cf_35, r12_35) = adc r12_32 0 cf_34\n    (cf_36, rax_36) = adc rax_33 0 cf_35\n    (rbp_37, r11_37) = mulx r11_34 rdx_30\n    (r13_38, r12_38) = mulx r12_35 rdx_30\n    (cf_39, r12_39) = add r12_38 rbp_37\n    (cf_40, r13_40) = adc r13_38 0 cf_39\n    (rdx_41, rax_41) = imul1 rdx_30 rax_36\n    (cf_42, r13_42) = add r13_40 rax_41\n    (cf_43, rdx_43) = adc rdx_41 0 cf_42\n    (cf_44, r11_44) = add r11_37 r8_13\n    (cf_45, r12_45) = adc r12_39 r9_15 cf_44\n    (cf_46, r13_46) = adc r13_42 r10_18 cf_45\n    (cf_47, r14_47) = adc r14_20 rdx_43 cf_46\n    rdx_48 = rbx_0\n    r11_49 = shrd r11_44 r12_45 (zext`{64} 0x1f)\n    r12_50 = shrd r12_45 r13_46 (zext`{64} 0x1f)\n    r13_51 = shrd r13_46 r14_47 (zext`{64} 0x1f)\n    r14_52 = sar r14_47 0x3f\n    rbp_53 = 0\n    (cf_54, rbp_54) = sub rbp_53 r14_52\n    r11_55 = r11_49 ^ r14_52\n    r12_56 = r12_50 ^ r14_52\n    r13_57 = r13_51 ^ r14_52\n    (cf_58, r11_58) = add r11_55 rbp_54\n    (cf_59, r12_59) = adc r12_56 0 cf_58\n    (cf_60, r13_60) = adc r13_57 0 cf_59\n    result0 = r11_58\n    result1 = r12_59\n    result2 = r13_60\n    rdx_64 = rdx_48 ^ r14_52\n    rcx_65 = rcx_0 ^ r14_52\n    (cf_66, rdx_66) = add rdx_64 rbp_54\n    (cf_67, rcx_67) = add rcx_65 rbp_54\n    result = ([result0, result1, result2], rdx_66, rcx_67)\n\n__smulx_383x63\n  : Vec384 \/\/ u, stored at low offsets of rsi\n  -> Vec384 \/\/ v, stored at high offsets of rsi\n  -> [64] \/\/ f0\n  -> [64] \/\/ g0\n  -> Vec384\n__smulx_383x63 u v f0 g0 = result\n  where\n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0] = u\n    rdx_0 = f0\n    rcx_0 = g0\n    rbp_1 = rdx_0\n    rbp_2 = sar rbp_1 0x3f\n    rax_3 = 0\n    (cf_4, rax_4) = sub rax_3 rbp_2\n    rdx_5 = rdx_0 ^ rbp_2\n    (cf_6, rdx_6) = add rdx_5 rax_4\n    r8_7 = r8_0 ^ rbp_2\n    r9_8 = r9_0 ^ rbp_2\n    r10_9 = r10_0 ^ rbp_2\n    r11_10 = r11_0 ^ rbp_2\n    r12_11 = r12_0 ^ rbp_2\n    r13_12 = r13_0 ^ rbp_2\n    (cf_13, r8_13) = add r8_7 rax_4\n    (cf_14, r9_14) = adc r9_8 0 cf_13\n    (cf_15, r10_15) = adc r10_9 0 cf_14\n    (cf_16, r11_16) = adc r11_10 0 cf_15\n    (cf_17, r12_17) = adc r12_11 0 cf_16\n    (cf_18, r13_18) = adc r13_12 0 cf_17\n    (rbp_19, r8_19) = mulx r8_13 rdx_6\n    (rax_20, r9_20) = mulx r9_14 rdx_6\n    (cf_21, r9_21) = add r9_20 rbp_19\n    (rbp_22, r10_22) = mulx r10_15 rdx_6\n    (cf_23, r10_23) = adc r10_22 rax_20 cf_21\n    (rax_24, r11_24) = mulx r11_16 rdx_6\n    (cf_25, r11_25) = adc r11_24 rbp_22 cf_23\n    (rbp_26, r12_26) = mulx r12_17 rdx_6\n    (cf_27, r12_27) = adc r12_26 rax_24 cf_25\n    (rax_28, r13_28) = mulx r13_18 rdx_6\n    rdx_29 = rcx_0\n    (cf_30, r13_30) = adc r13_28 rbp_26 cf_27\n    offload0 = r8_19\n    offload1 = r9_21\n    offload2 = r10_23\n    offload3 = r11_25\n    offload4 = r12_27\n    offload5 = r13_30\n    r8_37 = v @ 0\n    r9_38 = v @ 1\n    r10_39 = v @ 2\n    r11_40 = v @ 3\n    r12_41 = v @ 4\n    r13_42 = v @ 5\n    rbp_43 = rdx_29\n    rbp_44 = sar rbp_43 0x3f\n    rax_45 = 0\n    (cf_46, rax_46) = sub rax_45 rbp_44\n    rdx_47 = rdx_29 ^ rbp_44\n    (cf_48, rdx_48) = add rdx_47 rax_46\n    r8_49 = r8_37 ^ rbp_44\n    r9_50 = r9_38 ^ rbp_44\n    r10_51 = r10_39 ^ rbp_44\n    r11_52 = r11_40 ^ rbp_44\n    r12_53 = r12_41 ^ rbp_44\n    r13_54 = r13_42 ^ rbp_44\n    (cf_55, r8_55) = add r8_49 rax_46\n    (cf_56, r9_56) = adc r9_50 0 cf_55\n    (cf_57, r10_57) = adc r10_51 0 cf_56\n    (cf_58, r11_58) = adc r11_52 0 cf_57\n    (cf_59, r12_59) = adc r12_53 0 cf_58\n    (cf_60, r13_60) = adc r13_54 0 cf_59\n    (rbp_61, r8_61) = mulx r8_55 rdx_48\n    (rax_62, r9_62) = mulx r9_56 rdx_48\n    (cf_63, r9_63) = add r9_62 rbp_61\n    (rbp_64, r10_64) = mulx r10_57 rdx_48\n    (cf_65, r10_65) = adc r10_64 rax_62 cf_63\n    (rax_66, r11_66) = mulx r11_58 rdx_48\n    (cf_67, r11_67) = adc r11_66 rbp_64 cf_65\n    (rbp_68, r12_68) = mulx r12_59 rdx_48\n    (cf_69, r12_69) = adc r12_68 rax_66 cf_67\n    (rax_70, r13_70) = mulx r13_60 rdx_48\n    (cf_71, r13_71) = adc r13_70 rbp_68 cf_69\n    (cf_72, r8_72) = add r8_61 offload0\n    (cf_73, r9_73) = adc r9_63 offload1 cf_72\n    (cf_74, r10_74) = adc r10_65 offload2 cf_73\n    (cf_75, r11_75) = adc r11_67 offload3 cf_74\n    (cf_76, r12_76) = adc r12_69 offload4 cf_75\n    (cf_77, r13_77) = adc r13_71 offload5 cf_76\n    result0 = r8_72\n    result1 = r9_73\n    result2 = r10_74\n    result3 = r11_75\n    result4 = r12_76\n    result5 = r13_77\n    result = [result0, result1, result2, result3, result4, result5]\n\n__smulx_767x63\n  : Vec384 \/\/ u, stored at low offsets of rsi\n  -> Vec768 \/\/ v, stored at high offsets of rsi\n  -> [64] \/\/ f0\n  -> [64] \/\/ g0\n  -> Vec768\n__smulx_767x63 u v f0 g0 = result\n  where\n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0] = u\n    rdx_0 = f0\n    rcx_0 = g0\n    rax_7 = rdx_0\n    rax_8 = sar rax_7 0x3f\n    rbp_9 = 0\n    (cf_10, rbp_10) = sub rbp_9 rax_8\n    rdx_14 = rdx_0 ^ rax_8\n    (cf_15, rdx_15) = add rdx_14 rbp_10\n    r8_16 = r8_0 ^ rax_8\n    r9_17 = r9_0 ^ rax_8\n    r10_18 = r10_0 ^ rax_8\n    r11_19 = r11_0 ^ rax_8\n    r12_20 = r12_0 ^ rax_8\n    rax_21 = rax_8 ^ r13_0\n    (cf_22, r8_22) = add r8_16 rbp_10\n    (cf_23, r9_23) = adc r9_17 0 cf_22\n    (cf_24, r10_24) = adc r10_18 0 cf_23\n    (cf_25, r11_25) = adc r11_19 0 cf_24\n    (cf_26, r12_26) = adc r12_20 0 cf_25\n    (cf_27, rax_27) = adc rax_21 0 cf_26\n    (rbp_28, r8_28) = mulx r8_22 rdx_15\n    (r13_29, r9_29) = mulx r9_23 rdx_15\n    (cf_30, r9_30) = add r9_29 rbp_28\n    (rbp_31, r10_31) = mulx r10_24 rdx_15\n    (cf_32, r10_32) = adc r10_31 r13_29 cf_30\n    (r13_33, r11_33) = mulx r11_25 rdx_15\n    (cf_34, r11_34) = adc r11_33 rbp_31 cf_32\n    (rbp_35, r12_35) = mulx r12_26 rdx_15\n    (cf_36, r12_36) = adc r12_35 r13_33 cf_34\n    (cf_37, rbp_37) = adc rbp_35 0 cf_36\n    (rdx_38, rax_38) = imul1 rdx_15 rax_27\n    (cf_39, rax_39) = add rax_38 rbp_37\n    (cf_40, rdx_40) = adc rdx_38 0 cf_39\n    offload0 = r8_28\n    offload1 = r9_30\n    offload2 = r10_32\n    offload3 = r11_34\n    offload4 = r12_36\n    offload5 = rax_39\n    offload6 = rdx_40\n    rdx_48 = rdx_40 >>$ 0x3f\n    offload7 = rdx_48\n    rdx_50 = rcx_0\n    rax_51 = rcx_0\n    r8_52 = v @ 0\n    r9_53 = v @ 1\n    r10_54 = v @ 2\n    r11_55 = v @ 3\n    r12_56 = v @ 4\n    r13_57 = v @ 5\n    r14_58 = v @ 6\n    r15_59 = v @ 7\n    rbx_60 = v @ 8\n    rbp_61 = v @ 9\n    rcx_62 = v @ 10\n    rdi_63 = v @ 11\n    rax_64 = sar rax_51 0x3f\n    rsi_65 = 0\n    (cf_66, rsi_66) = sub rsi_65 rax_64\n    rdx_67 = rdx_50 ^ rax_64\n    (cf_68, rdx_68) = add rdx_67 rsi_66\n    r8_69 = r8_52 ^ rax_64\n    r9_70 = r9_53 ^ rax_64\n    r10_71 = r10_54 ^ rax_64\n    r11_72 = r11_55 ^ rax_64\n    r12_73 = r12_56 ^ rax_64\n    r13_74 = r13_57 ^ rax_64\n    r14_75 = r14_58 ^ rax_64\n    r15_76 = r15_59 ^ rax_64\n    rbx_77 = rbx_60 ^ rax_64\n    rbp_78 = rbp_61 ^ rax_64\n    rcx_79 = rcx_62 ^ rax_64\n    rdi_80 = rdi_63 ^ rax_64\n    (cf_81, r8_81) = add r8_69 rsi_66\n    (cf_82, r9_82) = adc r9_70 0 cf_81\n    (cf_83, r10_83) = adc r10_71 0 cf_82\n    (cf_84, r11_84) = adc r11_72 0 cf_83\n    (cf_85, r12_85) = adc r12_73 0 cf_84\n    (cf_86, r13_86) = adc r13_74 0 cf_85\n    (cf_87, r14_87) = adc r14_75 0 cf_86\n    (cf_88, r15_88) = adc r15_76 0 cf_87\n    (cf_89, rbx_89) = adc rbx_77 0 cf_88\n    (cf_90, rbp_90) = adc rbp_78 0 cf_89\n    (cf_91, rcx_91) = adc rcx_79 0 cf_90\n    (cf_92, rdi_92) = adc rdi_80 0 cf_91\n    (rax_93, r8_93) = mulx r8_81 rdx_68\n    (rsi_94, r9_94) = mulx r9_82 rdx_68\n    (cf_95, r9_95) = add r9_94 rax_93\n    (rax_96, r10_96) = mulx r10_83 rdx_68\n    (cf_97, r10_97) = adc r10_96 rsi_94 cf_95\n    (rsi_98, r11_98) = mulx r11_84 rdx_68\n    (cf_99, r11_99) = adc r11_98 rax_96 cf_97\n    (rax_100, r12_100) = mulx r12_85 rdx_68\n    (cf_101, r12_101) = adc r12_100 rsi_98 cf_99\n    (rsi_102, r13_102) = mulx r13_86 rdx_68\n    (cf_103, r13_103) = adc r13_102 rax_100 cf_101\n    (rax_104, r14_104) = mulx r14_87 rdx_68\n    (cf_105, r14_105) = adc r14_104 rsi_102 cf_103\n    (rsi_106, r15_106) = mulx r15_88 rdx_68\n    (cf_107, r15_107) = adc r15_106 rax_104 cf_105\n    (rax_108, rbx_108) = mulx rbx_89 rdx_68\n    (cf_109, rbx_109) = adc rbx_108 rsi_106 cf_107\n    (rsi_110, rbp_110) = mulx rbp_90 rdx_68\n    (cf_111, rbp_111) = adc rbp_110 rax_108 cf_109\n    (rax_112, rcx_112) = mulx rcx_91 rdx_68\n    (cf_113, rcx_113) = adc rcx_112 rsi_110 cf_111\n    (rsi_114, rdi_114) = mulx rdi_92 rdx_68\n    (cf_117, rax_117) = adc rax_112 rdi_114 cf_113\n    (cf_118, r8_118) = add r8_93 offload0\n    (cf_119, r9_119) = adc r9_95 offload1 cf_118\n    (cf_120, r10_120) = adc r10_97 offload2 cf_119\n    (cf_121, r11_121) = adc r11_99 offload3 cf_120\n    (cf_122, r12_122) = adc r12_101 offload4 cf_121\n    (cf_123, r13_123) = adc r13_103 offload5 cf_122\n    (cf_124, r14_124) = adc r14_105 offload6 cf_123\n    rdi_125 = offload7\n    (cf_126, r15_126) = adc r15_107 rdi_125 cf_124\n    (cf_127, rbx_127) = adc rbx_109 rdi_125 cf_126\n    (cf_128, rbp_128) = adc rbp_111 rdi_125 cf_127\n    (cf_129, rcx_129) = adc rcx_113 rdi_125 cf_128\n    (cf_130, rax_130) = adc rax_117 rdi_125 cf_129\n    result0 = r8_118\n    result1 = r9_119\n    result2 = r10_120\n    result3 = r11_121\n    result4 = r12_122\n    result5 = r13_123\n    result6 = r14_124\n    result7 = r15_126\n    result8 = rbx_127\n    result9 = rbp_128\n    result10 = rcx_129\n    result11 = rax_130\n    result =\n      [ result0, result1, result2, result3, result4, result5\n      , result6, result7, result8, result9, result10, result11\n      ]\n\n__ab_approximation_31\n  : Integer \/\/ number of iterations\n  -> Vec384   -> Vec384   -> [4][64] \/\/ result; f0, g0, f1, g1\n__ab_approximation_31 iters a b = result\n  where\n    r9_0 = a @ 5\n    r11_0 = b @ 5\n    rbx_0 = a @ 4\n    rbp_0 = b @ 4\n    r8_0 = a @ 3\n    r10_0 = b @ 3\n    rax_1 = r9_0\n    rax_2 = rax_1 || r11_0\n    zf_2 = rax_2 == 0\n    r9_3 = cmove r9_0 rbx_0 zf_2\n    r11_4 = cmove r11_0 rbp_0 zf_2\n    rbx_5 = cmove rbx_0 r8_0 zf_2\n    r8_6 = a @ 2\n    rbp_7 = cmove rbp_0 r10_0 zf_2\n    r10_8 = b @ 2\n    rax_9 = r9_3\n    rax_10 = rax_9 || r11_4\n    zf_10 = rax_10 == 0\n    r9_11 = cmove r9_3 rbx_5 zf_10\n    r11_12 = cmove r11_4 rbp_7 zf_10\n    rbx_13 = cmove rbx_5 r8_6 zf_10\n    r8_14 = a @ 1\n    rbp_15 = cmove rbp_7 r10_8 zf_10\n    r10_16 = b @ 1\n    rax_17 = r9_11\n    rax_18 = rax_17 || r11_12\n    zf_18 = rax_18 == 0\n    r9_19 = cmove r9_11 rbx_13 zf_18\n    r11_20 = cmove r11_12 rbp_15 zf_18\n    rbx_21 = cmove rbx_13 r8_14 zf_18\n    r8_22 = a @ 0\n    rbp_23 = cmove rbp_15 r10_16 zf_18\n    r10_24 = b @ 0\n    rax_25 = r9_19\n    rax_26 = rax_25 || r11_20\n    zf_26 = rax_26 == 0\n    r9_27 = cmove r9_19 rbx_21 zf_26\n    r11_28 = cmove r11_20 rbp_23 zf_26\n    rbx_29 = cmove rbx_21 r8_22 zf_26\n    rbp_30 = cmove rbp_23 r10_24 zf_26\n    rax_31 = r9_27\n    rax_32 = rax_31 || r11_28\n    zf_33 = rax_32 == 0\n    rcx_33 = bsr rax_32\n    rcx_34 = 1 + rcx_33\n    r9_35 = cmove r9_27 rbx_29 zf_33\n    r11_36 = cmove r11_28 rbp_30 zf_33\n    rcx_37 = cmove rcx_34 rax_32 zf_33\n    rcx_38 = 0 - rcx_37\n    r9_39 = shld r9_35 rbx_29 (drop`{56} rcx_38)\n    r11_40 = shld r11_36 rbp_30 (drop`{56} rcx_38)\n    rcx_41 = r9_39\n    rcx_42 = rcx_41 || r11_40\n    rcx_43 = sar rcx_42 (zext`{64} 0x3f)\n    rcx_44 = (drop`{56} rcx_43) && zext 0x21\n    r9_45 = shr r9_39 rcx_44\n    r11_46 = shr r11_40 rcx_44\n    r8_47 = shl r8_22 rcx_44\n    r10_48 = shl r10_24 rcx_44\n    r8_49 = shrd_ret r8_22 r8_47 r9_45 rcx_44\n    r10_50 = shrd_ret r10_24 r10_48 r11_46 rcx_44\n    result = __inner_loop_31 iters r8_49 r10_50\n\n__inner_loop_31\n  : Integer \/\/ number of iterations\n  -> [64]   -> [64]   -> [4][64] \/\/ result; f0, g0, f1, g1\n__inner_loop_31 iters a_init b_init = result\n  where\n    [post_a, post_b, post_fg0, post_fg1, post_bias] = loop iters [a_init, b_init, 0x7FFFFFFF80000000, 0x800000007FFFFFFF, 0x7FFFFFFF7FFFFFFF]\n    tmp_f0 = zext`{64} (drop`{32} post_fg0)\n    tmp_g0 = shr post_fg0 0x20\n    tmp_f1 = zext`{64} (drop`{32} post_fg1)\n    tmp_g1 = shr post_fg1 0x20\n    tmp_bias = shr post_bias 0x20\n    result = [zext tmp_f0 - tmp_bias, zext tmp_g0 - tmp_bias, zext tmp_f1 - tmp_bias, zext tmp_g1 - tmp_bias]\n    loop : Integer -> [5][64] -> [5][64]\n    loop counter [a, b, fg0, fg1, bias] = loopresult\n      where\n        r8_0 = a\n        r10_0 = b\n        rcx_0 = fg0\n        r13_0 = fg1\n        r15_0 = bias\n        (cf_1, _) = sub r8_0 r10_0\n        rax_2 = r8_0\n        rbx_3 = r10_0\n        rbp_4 = rcx_0\n        r14_5 = r13_0\n        r8_6 = cmovb r8_0 r10_0 cf_1\n        r10_7 = cmovb r10_0 rax_2 cf_1\n        rcx_8 = cmovb rcx_0 r13_0 cf_1\n        r13_9 = cmovb r13_0 rbp_4 cf_1\n        (cf_10, r8_10) = sub r8_6 r10_7\n        (cf_12, rcx_12) = sub (add rcx_8 r15_0).1 r13_9\n        zf_13 = (rax_2 && zext 0x1) == 0\n        r8_14 = cmove r8_10 rax_2 zf_13\n        r10_15 = cmove r10_7 rbx_3 zf_13\n        rcx_16 = cmove rcx_12 rbp_4 zf_13\n        r13_17 = cmove r13_9 r14_5 zf_13\n        r8_18 = shr r8_14 0x01\n        (cf_19, r13_19) = add r13_17 r13_17\n        (cf_20, r13_20) = sub r13_19 r15_0\n        curcounter = counter - 1\n        curresult = [r8_18, r10_15, rcx_16, r13_20, r15_0]\n        loopresult = if curcounter == 0 then curresult else loop curcounter curresult\n\n__inner_loop_62\n  : Integer \/\/ number of iterations\n  -> [64]   -> [64]   -> [4][64] \/\/ result; f0, g0, f1, g1\n__inner_loop_62 iters a_init b_init = result\n  where\n    result = drop (loop iters [a_init, b_init, 1, 0, 0, 1])\n    loop : Integer -> [6][64] -> [6][64]\n    loop counter [a, b, f0, g0, f1, g1] = loopresult\n      where\n        r8_0 = a\n        r10_0 = b\n        rdx_0 = f0\n        rcx_0 = g0\n        r12_0 = f1\n        r13_0 = g1\n        rax_0 = 0\n        zf_2 = (r8_0 && zext 0x1) == 0\n        rbx_3 = r10_0\n        rax_4 = cmovne rax_0 r10_0 zf_2\n        (cf_5, rbx_5) = sub rbx_3 r8_0\n        rbp_6 = r8_0\n        (cf_7, r8_7) = sub r8_0 rax_4\n        r8_8 = cmovb r8_7 rbx_5 cf_7\n        r10_9 = cmovb r10_0 rbp_6 cf_7\n        rax_10 = rdx_0\n        rdx_11 = cmovb rdx_0 r12_0 cf_7\n        r12_12 = cmovb r12_0 rax_10 cf_7\n        rbx_13 = rcx_0\n        rcx_14 = cmovb rcx_0 r13_0 cf_7\n        r13_15 = cmovb r13_0 rbx_13 cf_7\n        rax_16 = 0\n        rbx_17 = 0\n        r8_18 = r8_8 >> 1\n        rbp_19 = (rbp_6 && zext 0x1) == 0\n        rax_20 = cmovne rax_16 r12_12 zf_2\n        rbx_21 = cmovne rbx_17 r13_15 zf_2\n        (cf_22, r12_22) = add r12_12 r12_12\n        (cf_23, r13_23) = add r13_15 r13_15\n        (cf_24, rdx_24) = sub rdx_11 rax_20\n        (cf_25, rcx_25) = sub rcx_14 rbx_21\n        curcounter = counter - 1\n        curresult = [r8_18, r10_9, rdx_24, rcx_25, r12_22, r13_23]\n        loopresult = if curcounter == 0 then curresult else loop curcounter curresult\n\nctx_inverse_mod_383\n  : Vec384 \/\/ a; pointer in rsi\n  -> Vec384 \/\/ n; pointer in rdx\n  -> Vec768 ctx_inverse_mod_383 a n = result   where\n    a_2 = a\n    b_3 = n\n    loa_4 = a_2\n    lob_5 = b_3\n    [f0_6, g0_6, f1_6, g1_6] = __ab_approximation_31 31 loa_4 lob_5\n    (hia_7, f0_7, g0_7) = __smulx_383_n_shift_by_31 loa_4 lob_5 f0_6 g0_6\n    offloadu_7 = f0_7\n    (hib_8, f1_8, g1_8) = __smulx_383_n_shift_by_31 loa_4 lob_5 f1_6 g1_6\n    offloadv_8 = f1_8\n    [f0_9, g0_9, f1_9, g1_9] = __ab_approximation_31 31 hia_7 hib_8\n    (loa_10, f0_10, g0_10) = __smulx_383_n_shift_by_31 hia_7 hib_8 f0_9 g0_9\n    (lob_11, f1_11, g1_11) = __smulx_383_n_shift_by_31 hia_7 hib_8 f1_9 g1_9\n    tmp12_rax_0 = offloadu_7\n    tmp12_r11_0 = offloadv_8\n    tmp12_rbx_0 = f1_11\n    tmp12_r10_0 = tmp12_rax_0\n    (tmp12_rdx_05, tmp12_rax_05) = imul1 f0_10 tmp12_rax_0\n    tmp12_r8_1 = tmp12_rax_05\n    tmp12_rax_1 = tmp12_r11_0\n    tmp12_r9_1 = tmp12_rdx_05\n    (tmp12_rdx_2, tmp12_rax_2) = imul1 g0_10 tmp12_rax_1\n    (tmp12_cf_3, tmp12_r8_3) = add tmp12_r8_1 tmp12_rax_2\n    (tmp12_cf_4, tmp12_r9_4) = adc tmp12_r9_1 tmp12_rdx_2 tmp12_cf_3\n    tmp12_ret0 = tmp12_r8_3\n    tmp12_ret1 = tmp12_r9_4\n    tmp12_r9_5 = sar tmp12_r9_4 0x3f\n    tmp12_ret2 = tmp12_r9_5\n    tmp12_ret3 = tmp12_r9_5\n    tmp12_ret4 = tmp12_r9_5\n    tmp12_ret5 = tmp12_r9_5\n    tmp12_rax_55 = tmp12_r10_0\n    (tmp12_rdx_6, tmp12_rax_6) = imul1 tmp12_rbx_0 tmp12_rax_55\n    tmp12_r8_6 = tmp12_rax_6\n    tmp12_rax_7 = tmp12_r11_0\n    tmp12_r9_7 = tmp12_rdx_6\n    (tmp12_rdx_8, tmp12_rax_8) = imul1 g1_11 tmp12_rax_7\n    (tmp12_cf_9, tmp12_r8_9) = add tmp12_r8_6 tmp12_rax_8\n    (tmp12_cf_10, tmp12_r9_10) = adc tmp12_r9_7 tmp12_rdx_8 tmp12_cf_9\n    tmp12_ret6 = tmp12_r8_9\n    tmp12_ret7 = tmp12_r9_10\n    tmp12_r9_11 = sar tmp12_r9_10 0x3f\n    tmp12_ret8 = tmp12_r9_11\n    tmp12_ret9 = tmp12_r9_11\n    tmp12_ret10 = tmp12_r9_11\n    tmp12_ret11 = tmp12_r9_11\n    lou_12 = [tmp12_ret0, tmp12_ret1, tmp12_ret2, tmp12_ret3, tmp12_ret4, tmp12_ret5]\n    lov_12 = [tmp12_ret6, tmp12_ret7, tmp12_ret8, tmp12_ret9, tmp12_ret10, tmp12_ret11]\n    [f0_14, g0_14, f1_14, g1_14] = __ab_approximation_31 31 loa_10 lob_11\n    (hia_15, f0_15, g0_15) = __smulx_383_n_shift_by_31 loa_10 lob_11 f0_14 g0_14\n    (hib_16, f1_16, g1_16) = __smulx_383_n_shift_by_31 loa_10 lob_11 f1_14 g1_14\n    hiu_17 = __smulx_383x63 lou_12 lov_12 f0_15 g0_15\n    hiv_18 = __smulx_383x63 lou_12 lov_12 f1_16 g1_16\n    [f0_19, g0_19, f1_19, g1_19] = __ab_approximation_31 31 hia_15 hib_16\n    (loa_20, f0_20, g0_20) = __smulx_383_n_shift_by_31 hia_15 hib_16 f0_19 g0_19\n    (lob_21, f1_21, g1_21) = __smulx_383_n_shift_by_31 hia_15 hib_16 f1_19 g1_19\n    lou_22 = __smulx_383x63 hiu_17 hiv_18 f0_20 g0_20\n    lov_23 = __smulx_383x63 hiu_17 hiv_18 f1_21 g1_21\n    [f0_24, g0_24, f1_24, g1_24] = __ab_approximation_31 31 loa_20 lob_21\n    (hia_25, f0_25, g0_25) = __smulx_383_n_shift_by_31 loa_20 lob_21 f0_24 g0_24\n    (hib_26, f1_26, g1_26) = __smulx_383_n_shift_by_31 loa_20 lob_21 f1_24 g1_24\n    hiu_27 = __smulx_383x63 lou_22 lov_23 f0_25 g0_25\n    hiv_28 = __smulx_383x63 lou_22 lov_23 f1_26 g1_26\n    [f0_29, g0_29, f1_29, g1_29] = __ab_approximation_31 31 hia_25 hib_26\n    (loa_30, f0_30, g0_30) = __smulx_383_n_shift_by_31 hia_25 hib_26 f0_29 g0_29\n    (lob_31, f1_31, g1_31) = __smulx_383_n_shift_by_31 hia_25 hib_26 f1_29 g1_29\n    lou_32 = __smulx_383x63 hiu_27 hiv_28 f0_30 g0_30\n    lov_33 = __smulx_383x63 hiu_27 hiv_28 f1_31 g1_31\n    [f0_34, g0_34, f1_34, g1_34] = __ab_approximation_31 31 loa_30 lob_31\n    (hia_35, f0_35, g0_35) = __smulx_383_n_shift_by_31 loa_30 lob_31 f0_34 g0_34\n    (hib_36, f1_36, g1_36) = __smulx_383_n_shift_by_31 loa_30 lob_31 f1_34 g1_34\n    hiu_37 = __smulx_383x63 lou_32 lov_33 f0_35 g0_35\n    hiv_38 = __smulx_383x63 lou_32 lov_33 f1_36 g1_36\n    [f0_39, g0_39, f1_39, g1_39] = __ab_approximation_31 31 hia_35 hib_36\n    (loa_40, f0_40, g0_40) = __smulx_383_n_shift_by_31 hia_35 hib_36 f0_39 g0_39\n    (lob_41, f1_41, g1_41) = __smulx_383_n_shift_by_31 hia_35 hib_36 f1_39 g1_39\n    lou_42 = __smulx_383x63 hiu_37 hiv_38 f0_40 g0_40\n    lov_43 = __smulx_383x63 hiu_37 hiv_38 f1_41 g1_41\n    [f0_44, g0_44, f1_44, g1_44] = __ab_approximation_31 31 loa_40 lob_41\n    (hia_45, f0_45, g0_45) = __smulx_383_n_shift_by_31 loa_40 lob_41 f0_44 g0_44\n    (hib_46, f1_46, g1_46) = __smulx_383_n_shift_by_31 loa_40 lob_41 f1_44 g1_44\n    hiu_47 = __smulx_383x63 lou_42 lov_43 f0_45 g0_45\n    hiv_48 = __smulx_383x63 lou_42 lov_43 f1_46 g1_46\n    [f0_49, g0_49, f1_49, g1_49] = __ab_approximation_31 31 hia_45 hib_46\n    (loa_50, f0_50, g0_50) = __smulx_383_n_shift_by_31 hia_45 hib_46 f0_49 g0_49\n    (lob_51, f1_51, g1_51) = __smulx_383_n_shift_by_31 hia_45 hib_46 f1_49 g1_49\n    lou_52 = __smulx_383x63 hiu_47 hiv_48 f0_50 g0_50\n    lov_53 = __smulx_383x63 hiu_47 hiv_48 f1_51 g1_51\n    [f0_54, g0_54, f1_54, g1_54] = __ab_approximation_31 31 loa_50 lob_51\n    (hia_55, f0_55, g0_55) = __smulx_383_n_shift_by_31 loa_50 lob_51 f0_54 g0_54\n    (hib_56, f1_56, g1_56) = __smulx_383_n_shift_by_31 loa_50 lob_51 f1_54 g1_54\n    hiu_57 = __smulx_383x63 lou_52 lov_53 f0_55 g0_55\n    hiv_58 = __smulx_383x63 lou_52 lov_53 f1_56 g1_56\n    [f0_59, g0_59, f1_59, g1_59] = __ab_approximation_31 31 hia_55 hib_56\n    (loa_60, f0_60, g0_60) = __smulx_383_n_shift_by_31 hia_55 hib_56 f0_59 g0_59\n    (lob_61, f1_61, g1_61) = __smulx_383_n_shift_by_31 hia_55 hib_56 f1_59 g1_59\n    lou_62 = __smulx_383x63 hiu_57 hiv_58 f0_60 g0_60\n    lov_63 = __smulx_383x63 hiu_57 hiv_58 f1_61 g1_61\n    tmp64_r13_0 = sar (lov_63 @ 5) 0x3f\n    lov_64 = lov_63 # [tmp64_r13_0, tmp64_r13_0, tmp64_r13_0, tmp64_r13_0, tmp64_r13_0, tmp64_r13_0]\n    [f0_65, g0_65, f1_65, g1_65] = __ab_approximation_31 31 loa_60 lob_61\n    (hia_66, f0_66, g0_66) = __smulx_383_n_shift_by_31 loa_60 lob_61 f0_65 g0_65\n    (hib_67, f1_67, g1_67) = __smulx_383_n_shift_by_31 loa_60 lob_61 f1_65 g1_65\n    hiu_68 = __smulx_383x63 lou_62 (take lov_64) f0_66 g0_66\n    hiv_69 = __smulx_767x63 lou_62 lov_64 f1_67 g1_67\n    [f0_70, g0_70, f1_70, g1_70] = __ab_approximation_31 31 hia_66 hib_67\n    (loa_71, f0_71, g0_71) = __smulx_383_n_shift_by_31 hia_66 hib_67 f0_70 g0_70\n    (lob_72, f1_72, g1_72) = __smulx_383_n_shift_by_31 hia_66 hib_67 f1_70 g1_70\n    lou_73 = __smulx_383x63 hiu_68 (take hiv_69) f0_71 g0_71\n    lov_74 = __smulx_767x63 hiu_68 hiv_69 f1_72 g1_72\n    [f0_75, g0_75, f1_75, g1_75] = __ab_approximation_31 31 loa_71 lob_72\n    (hia_76, f0_76, g0_76) = __smulx_383_n_shift_by_31 loa_71 lob_72 f0_75 g0_75\n    (hib_77, f1_77, g1_77) = __smulx_383_n_shift_by_31 loa_71 lob_72 f1_75 g1_75\n    hiu_78 = __smulx_383x63 lou_73 (take lov_74) f0_76 g0_76\n    hiv_79 = __smulx_767x63 lou_73 lov_74 f1_77 g1_77\n    [f0_80, g0_80, f1_80, g1_80] = __ab_approximation_31 31 hia_76 hib_77\n    (loa_81, f0_81, g0_81) = __smulx_383_n_shift_by_31 hia_76 hib_77 f0_80 g0_80\n    (lob_82, f1_82, g1_82) = __smulx_383_n_shift_by_31 hia_76 hib_77 f1_80 g1_80\n    lou_83 = __smulx_383x63 hiu_78 (take hiv_79) f0_81 g0_81\n    lov_84 = __smulx_767x63 hiu_78 hiv_79 f1_82 g1_82\n    [f0_85, g0_85, f1_85, g1_85] = __ab_approximation_31 31 loa_81 lob_82\n    (hia_86, f0_86, g0_86) = __smulx_383_n_shift_by_31 loa_81 lob_82 f0_85 g0_85\n    (hib_87, f1_87, g1_87) = __smulx_383_n_shift_by_31 loa_81 lob_82 f1_85 g1_85\n    hiu_88 = __smulx_383x63 lou_83 (take lov_84) f0_86 g0_86\n    hiv_89 = __smulx_767x63 lou_83 lov_84 f1_87 g1_87\n    [f0_90, g0_90, f1_90, g1_90] = __ab_approximation_31 31 hia_86 hib_87\n    (loa_92, f0_92, g0_92) = __smulx_383_n_shift_by_31 hia_86 hib_87 f0_90 g0_90\n    (lob_93, f1_93, g1_93) = __smulx_383_n_shift_by_31 hia_86 hib_87 f1_90 g1_90\n    lou_94 = __smulx_383x63 hiu_88 (take hiv_89) f0_92 g0_92\n    lov_95 = __smulx_767x63 hiu_88 hiv_89 f1_93 g1_93\n    [f0_96, g0_96, f1_96, g1_96] = __ab_approximation_31 31 loa_92 lob_93\n    (hia_97, f0_97, g0_97) = __smulx_383_n_shift_by_31 loa_92 lob_93 f0_96 g0_96\n    (hib_98, f1_98, g1_98) = __smulx_383_n_shift_by_31 loa_92 lob_93 f1_96 g1_96\n    hiu_99 = __smulx_383x63 lou_94 (take lov_95) f0_97 g0_97\n    hiv_100 = __smulx_767x63 lou_94 lov_95 f1_98 g1_98\n    [f0_101, g0_101, f1_101, g1_101] = __ab_approximation_31 31 hia_97 hib_98\n    (loa_102, f0_102, g0_102) = __smulx_191_n_shift_by_31 (take`{3} hia_97) (take`{3} hib_98) f0_101 g0_101\n    (lob_103, f1_103, g1_103) = __smulx_191_n_shift_by_31 (take`{3} hia_97) (take`{3} hib_98) f1_101 g1_101\n    lou_104 = __smulx_383x63 hiu_99 (take hiv_100) f0_102 g0_102\n    lov_105 = __smulx_767x63 hiu_99 hiv_100 f1_103 g1_103\n    [f0_106, g0_106, f1_106, g1_106] = __ab_approximation_31 31 (loa_102 # drop`{3} loa_92) (lob_103 # drop`{3} lob_93)\n    (hia_107, f0_107, g0_107) = __smulx_191_n_shift_by_31 loa_102 lob_103 f0_106 g0_106\n    (hib_108, f1_108, g1_108) = __smulx_191_n_shift_by_31 loa_102 lob_103 f1_106 g1_106\n    hiu_109 = __smulx_383x63 lou_104 (take lov_105) f0_107 g0_107\n    hiv_110 = __smulx_767x63 lou_104 lov_105 f1_108 g1_108\n    [f0_111, g0_111, f1_111, g1_111] = __ab_approximation_31 31 (hia_107 # drop`{3} hia_97) (hib_108 # drop`{3} hib_98)\n    (loa_112, f0_112, g0_112) = __smulx_191_n_shift_by_31 hia_107 hib_108 f0_111 g0_111\n    (lob_113, f1_113, g1_113) = __smulx_191_n_shift_by_31 hia_107 hib_108 f1_111 g1_111\n    lou_114 = __smulx_383x63 hiu_109 (take hiv_110) f0_112 g0_112\n    lov_115 = __smulx_767x63 hiu_109 hiv_110 f1_113 g1_113\n    [f0_116, g0_116, f1_116, g1_116] = __ab_approximation_31 31 (loa_112 # drop`{3} loa_92) (lob_113 # drop`{3} lob_93)\n    (hia_117, f0_117, g0_117) = __smulx_191_n_shift_by_31 loa_112 lob_113 f0_116 g0_116\n    (hib_118, f1_118, g1_118) = __smulx_191_n_shift_by_31 loa_112 lob_113 f1_116 g1_116\n    hiu_119 = __smulx_383x63 lou_114 (take lov_115) f0_117 g0_117\n    hiv_120 = __smulx_767x63 lou_114 lov_115 f1_118 g1_118\n    earlyresult = take`{6} hiv_120\n    [f0_121, g0_121, f1_121, g1_121] = __inner_loop_62 55 (hia_117 @ 0) (hib_118 @ 0)\n    v_122 = __smulx_767x63 hiu_119 hiv_120 f1_121 g1_121\n    resultlow = take v_122\n    [r14_122, r15_122, rbx_122, rbp_122, rcx_122, rax_122] = drop v_122\n    rdx_123 = rax_122\n    tmp123_rax_0 = sar rax_122 0x3f\n    r8_123 = tmp123_rax_0 && (n @ 0)\n    r9_123 = tmp123_rax_0 && (n @ 1)\n    r10_123 = tmp123_rax_0 && (n @ 2)\n    r11_123 = tmp123_rax_0 && (n @ 3)\n    r12_123 = tmp123_rax_0 && (n @ 4)\n    rax_123 = tmp123_rax_0 && (n @ 5)\n    (tmp124_cf_0, r14_124) = add r14_122 r8_123\n    (tmp124_cf_1, r15_124) = adc r15_122 r9_123 tmp124_cf_0\n    (tmp124_cf_2, rbx_124) = adc rbx_122 r10_123 tmp124_cf_1\n    (tmp124_cf_3, rbp_124) = adc rbp_122 r11_123 tmp124_cf_2\n    (tmp124_cf_4, rcx_124) = adc rcx_122 r12_123 tmp124_cf_3\n    (tmp124_cf_5, rdx_124) = adc rdx_123 rax_123 tmp124_cf_4\n    result6 = r14_124\n    result7 = r15_124\n    result8 = rbx_124\n    result9 = rbp_124\n    result10 = rcx_124\n    result11 = rdx_124\n    result : Vec768\n    result = resultlow # [result6, result7, result8, result9, result10, result11]\n```"}]}
{"filename":"formal-verso\/example-proofs\/CustomTypes.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the functions `valid_with_heap` and `val_to_native` in the `CustomTypes` module. The properties should ensure that `valid_with_heap` correctly identifies well-formed MapObjects containing the required keys with valid U32 values, and that `val_to_native` safely extracts the native representation from such MapObjects, handling optional values as specified. Include checks that the extracted native values correspond exactly to the underlying MapObject fields when valid."},{"role":"assistant","content":"```cryptol\n\/*\n * Cryptol-level stuff for modeling the custom type.\n *\n * The Rust representation of the type is a struct with two members\n * (count and last_incr), both u32.\n *\n * The native representation is a pair ([32], [32]).\n *\n * The Soroban-level representation is a Values::MapObject::T with the\n * field names as keys and the values being Values::U32::T.\n *\/\n\nmodule CustomTypes where\n\nimport Option as Option\nimport Values as Values\nimport submodule Values::Symbol as Values::Symbol\nimport submodule Values::MapObject as Values::MapObject\nimport submodule Values::U32 as Values::U32\nimport submodule Values::Raw as Values::Raw\n\ntype T = ([32], [32])\n\ndefault_value : T\ndefault_value = (0, 0)\n\ncountsym : Values::Symbol::T\ncountsym = Values::Symbol::from_native \"count\"\nlastsym : Values::Symbol::T\nlastsym = Values::Symbol::from_native \"last_incr\"\n\ncountsym_raw : Values::Raw::T\ncountsym_raw = Values::Symbol::to_raw countsym\nlastsym_raw : Values::Raw::T\nlastsym_raw = Values::Symbol::to_raw lastsym\n\n\/*\n * Check if the underlying MapObject is well formed.\n * XXX: we can't easily exclude extraneous map fields\n *\/\nvalid_with_heap : Values::MapObject::T -> Values::HostHeap -> Bool\nvalid_with_heap state_val heap =\n   Values::mapobj_has_key countsym_raw state_val heap \/\\\n   Values::mapobj_has_key lastsym_raw state_val heap \/\\\n   Values::raw_is_u32 count_val \/\\\n   Values::raw_is_u32 last_val\n   where\n      count_val = Values::mapobj_get countsym_raw state_val heap\n      last_val = Values::mapobj_get lastsym_raw state_val heap\n\n\/*\n * Extract the native representation from a MapObject.\n *\n * Should have already asserted that the elements are U32.\n * Crashes if they aren't.\n *\/\nval_to_native : Values::MapObject::T -> Values::HostHeap -> T\nval_to_native state_val heap =\n   (count_native, last_native)\n   where\n      count_raw = Values::MapObject::get countsym_raw state_val heap\n      last_raw = Values::MapObject::get lastsym_raw state_val heap\n      count_optval = Values::U32::from_raw count_raw\n      last_optval = Values::U32::from_raw last_raw\n      count_val =\n         if Option::is_some count_optval then Option::unsafe_unwrap count_optval\n                  else Values::U32::from_native 0\n      last_val =\n         if Option::is_some last_optval then Option::unsafe_unwrap last_optval\n                  else Values::U32::from_native 0\n      count_native = Values::U32::to_native count_val\n      last_native = Values::U32::to_native last_val\n```"}]}
{"filename":"formal-verso\/example-proofs\/CustomTypes2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the functions 'valid_with_heap' and 'val_to_native' in the CustomTypes2 module. The properties should ensure that 'valid_with_heap' correctly identifies well-formed VecObject states representing the custom type, and that 'val_to_native' safely and accurately extracts the native representation from a valid VecObject. Include checks for proper length, element types, and correct conversion between raw and native values."},{"role":"assistant","content":"```cryptol\n\/*\n * Cryptol-level stuff for modeling the custom type.\n *\n * The Rust representation of the type is a tuple struct with two\n * members, both u32.\n *\n * The native representation is a pair ([32], [32]).\n *\n * The Soroban-level representation is a Values::VecObject::T that\n * points to two Values::U32::T.\n *\/\n\nmodule CustomTypes2 where\n\nimport Option as Option\nimport Values as Values\nimport submodule Values::Symbol as Values::Symbol\nimport submodule Values::VecObject as Values::VecObject\nimport submodule Values::U32 as Values::U32\nimport submodule Values::Raw as Values::Raw\n\ntype T = ([32], [32])\n\ndefault_value : T\ndefault_value = (0, 0)\n\n\/*\n * Check if the underlying VecObject is well formed.\n *\/\nvalid_with_heap : Values::VecObject::T -> Values::HostHeap -> Bool\nvalid_with_heap state_val heap =\n   Values::vecobj_valid_with_heap state_val heap \/\\\n   Values::vecobj_len state_val heap == 2 \/\\\n   Values::raw_is_u32 count_val \/\\\n   Values::raw_is_u32 last_val\n   where\n      count_val = Values::vecobj_get state_val 0 heap\n      last_val = Values::vecobj_get state_val 1 heap\n\n\/*\n * Extract the native representation from a VecObject.\n *\n * Should have already asserted that the elements are U32.\n * Crashes if they aren't.\n *\/\nval_to_native : Values::VecObject::T -> Values::HostHeap -> T\nval_to_native state_val heap =\n   (count_native, last_native)\n   where\n      count_raw = Values::VecObject::get state_val 0 heap\n      last_raw = Values::VecObject::get state_val 1 heap\n      count_optval = Values::U32::from_raw count_raw\n      last_optval = Values::U32::from_raw last_raw\n      count_val =\n         if Option::is_some count_optval then Option::unsafe_unwrap count_optval\n                  else Values::U32::from_native 0\n      last_val =\n         if Option::is_some last_optval then Option::unsafe_unwrap last_optval\n                  else Values::U32::from_native 0\n      count_native = Values::U32::to_native count_val\n      last_native = Values::U32::to_native last_val\n```"}]}
{"filename":"formal-verso\/example-proofs\/DataKeyEnum.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the functions `to_raw` and `from_native` in the `DataKeyEnum` module. Then, create Cryptol properties or lemmas that verify these functions correctly convert between the native tuple type `T` and the raw vector object representation, preserving data integrity and heap state as appropriate."},{"role":"assistant","content":"```cryptol\nmodule DataKeyEnum where\n\nimport Values as Values\nimport HostValues as HostValues\nimport submodule Values::VecObject as Values::VecObject\nimport submodule Values::Raw as Values::Raw\n\ntype T = (Values::SymbolT, Values::AddressObjectT)\n\nto_raw : Values::VecObject::T -> Values::Val\nto_raw vecobj = Values::VecObject::to_raw vecobj\n\nfrom_native : T -> HostValues::Heap -> (HostValues::Heap, Values::VecObject::T)\nfrom_native v heap = (Values::VecObject::pair v.0.val v.1.val heap)\n```"}]}
{"filename":"formal-verso\/lib\/Store.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the Store module that formally defines the behavior of the 'has', 'get', and 'set' functions. Include properties that verify: (1) 'has s k' returns true if and only if 'get s k' returns a valid value; (2) 'get s k' returns the value previously set by 'set s k v'; and (3) setting a key updates the store without affecting other keys. These properties should be suitable for automated verification or testing."},{"role":"assistant","content":"```cryptol\nmodule Store where\n\nimport Array\nimport Option as Option\nimport Values as Values\nimport submodule Values::Raw as Raw\n\ntype T = Store\n\nprivate\n  newtype Store = { array : Array Raw::T OptionRawVal }\n  \/\/ Can't use Option Raw::T due to saw-script#1988\n  \/\/ first bit = exists, rest = data\n  type OptionRawVal = [65]\n\nhas : Store -> Raw::T -> Bit\nhas s k = Option::is_ok (get s k)\n\nget : Store -> Raw::T -> Option::T Raw::T\nget s k =\n   Option::mk (head orv) (Raw::from_payload (tail orv))\n   where orv = arrayLookup s.array k\n\nset : Store -> Raw::T -> Raw::T -> Store\nset s k v =\n   Store { array = arrayUpdate s.array k (0b1 # payload) }\n   where payload = Raw::get_payload v\n```"}]}
{"filename":"formal-verso\/lib\/Auth.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification and corresponding SAWScript verification script that formally verify the correctness of the authorization state transitions in the Auth module. The specification should capture the valid states of the Auth type, the initial conditions, and the behavior of the key functions such as authorize, check_noargs, and check_withargs. The verification script should prove that these functions preserve the validity of the Auth state and correctly implement the intended authorization logic as described in the module comments."},{"role":"assistant","content":"```cryptol\nmodule Auth where\n\nimport Values as Values\nimport submodule Values::Symbol as Values::Symbol\nimport submodule Values::AddressObject as Values::AddressObject\nimport submodule Values::VecObject as Values::VecObject\n\n\/*\n * Model for the Soroban SDK authorization system.\n *\n * The basis of the authorization system is a concept of call-graph\n * fragments.\n *\n * As I understand it (note that my understanding is based on a lot of\n * guesswork because the documentation is not very clear, and may be\n * quite wrong so far) this probably works as follows:\n *\n * 1. Each call-graph fragment is associated with a particular\n * Address, and represents a projection of a contract execution call\n * graph where (a) all functions in a given contract are folded\n * together, and (b) contracts that don't make authorization calls\n * about the Address in question are dropped. Chains or subgraphs of\n * dropped nodes are replaced with a single edge. Nodes dropped at the\n * root of the graph are dropped completely.\n *\n * Thus, a fragment (a, f -> g -> h) represents a call chain from f to\n * g to h, where f, g, and h each make an authorization check on\n * address a. This allows f to call g and then g to call h, but does\n * not allow f to call h directly, or allow either g or h to be called\n * spontaneously rather than starting from f. However, other contracts\n * that don't check for authorization from a can be interspersed\n * freely.\n *\n * These fragments are described as trees rather than graphs; it\n * appears that each end corresponds to a single invocation, not a\n * general ability to invoke. So for a situation where f calls g\n * twice, and each call to g calls h, you write a fragment of the\n * form\n *       f --> g -> h\n *         \\-> g -> h\n * rather than either the form\n *       f --> g --> h\n *         \\-> g -\/\n * or just\n *       f -> g -> h\n * but this is not totally clear. It is also not clear if these\n * two fragments are different:\n *       f --> g -> w\n *         \\-> g -> z\n * and\n *       f --> g -> z\n *         \\-> g -> w\n * that is, whether the sub-nodes are ordered or not.\n *\n * Update: yes, each subtree corresponds to a single execution\n * sequence. If there are two calls from f to g, then there are two g\n * subtrees, and if g is going to call h each subtree has its own h;\n * that is, there are no diamonds. Also, while in general reentrancy\n * is prohibited there's apparently a special case where it's not,\n * but this results in subtrees of the form f -> f -> g not cycles.\n * So the part that says \"this is not totally clear\" is correct.\n *\n * Update: subnodes are somewhat ordered. If there are multiple subtrees\n * for the same function these subtrees are consumed in order. However,\n * if there are multiple subtrees for different functions, those can be\n * consumed in any order because it searches for unused subtrees from\n * the beginning of the list each time. That is, the two fragments above\n * are different but these two are equivalent:\n *       f --> g -> w\n *         \\-> h -> z\n * and\n *       f --> h -> z\n *         \\-> g -> w\n *\n * 2. When we start executing we have some collection of call graph\n * fragments that we're allowed to execute; these have been signed\n * by the principal behind the Address associated with the fragment.\n *\n * 3. During execution, when an authorization call happens, we search\n * for a fragment with an unused node matching it that will let us\n * conclude the call is authorized. Then we mark off the node we just\n * matched in the fragment as used. When all the nodes in the fragment\n * have been used, the whole fragment is marked used and\/or discarded.\n *\n * Update: subtrees of fragments (including the whole tree as one\n * case) become unreachable when the function rooting the subtree\n * returns, but it's not required that the whole subtree gets used.\n *\n * 4. It appears that a node in a fragment matches if:\n *    - it names the same contract\n *    - the enclosed arguments list matches (see further notes below)\n *    - and either:\n *         - it is the root of the fragment\n *         - it is the (or a) next unused node in the fragment and its\n *           parent in the fragment is still in the current call chain\n *\n * That is, as you execute you pick fragments that authorize you to\n * execute, and these authorize particular patterns of calls, which\n * then get discharged and marked used one at a time. If\/once\n * execution deviates from the pattern the fragment can no longer\n * authorize further calls.\n *\n * Update: the last sentence there is not quite true; the fragment is\n * marked used as its pieces are matched, but the only thing that\n * cancels fragments or subtrees of fragments is when the function\n * that matched the root returns, as described above. (However, any\n * failure nonetheless causes the whole thing to crash out and stop.)\n *\n * As noted above, it's unclear if the patterns of calls are intended\n * to be ordered. Thus, given the example\n *       f --> g -> w\n *         \\-> g -> z\n * it's not clear if the sequence\n *    call f, call g, call z, return z, return g, call g, call w, return all\n * is potentially authorized or only the sequence\n *    call f, call g, call w, return z, return g, call g, call w, return all\n * though it is definitely the case that just\n *    call f, call g, call z, return z, return g, return f\n * or\n *    call f, call g, call w, return w, return g, return f\n * are authorized, and\n *    call f, call g, call z, return z, call w\n * is not.\n *\n * Update: the ordering behavior is as described above. In this case\n * the g -> w subtree will be matched on the first call to g so if\n * the first call to g ends up being the g -> z one it will fail.\n * Note that this means that \n *    call f, call g, call w, return w, return g, return f\n * is authorized but\n *    call f, call g, call z, return z, return g, return f\n * is not, despite what I'd previously thought.\n *\n * It's also unclear if you can have more than one active fragment for\n * the same Address at a time. That is, if you have the two fragments\n *       f -> g -> w\n *       g -> z\n * it's not clear if this sequence is authorized:\n *    call f, call g, call z, return z, return g, call g, call w, return all\n * because it uses the g -> z fragment while the other fragment is\n * partially discharged and then returns to using it. Similarly, it's\n * not clear if the sequence\n *    call f, call g, call z, call g, call w, return z, return w, return all\n * with two live invocations of g at once is supposed to be\n * authorized. From the apparent intent of the system it seems like\n * the first should be authorized but not the second, but it's hard to\n * see how they can readily be distinguished.\n *\n * Update: yes, you can have more than one active fragment for the\n * same Address. However, it matches against all currently active\n * fragments before starting any new ones. So given the example in the\n * previous paragraph,\n *    call f, call g, call z, return z, return g, call g, call w, return all\n *    call f, call g, call z, call g, call w, return z, return w, return all\n * are both not authorized because it will pick the g from the first\n * fragment for the first g execution, but\n *    call f, call g, call w, return w, return g, call g, call z, return all\n *    call f, call g, call w, call g, call z, return w, return z, return all\n * are both authorized. Also, although calling g -> g (or g -> w -> g)\n * is normally prohibited by an unrelated mechanism, that isn't an\n * authorization issue so these:\n *    call f, call g, call w, return w, call g, return g, call z, return all\n *    call f, call g, call w, call g, return w, return g, call z, return all\n * are both authorized; that is, the second fragment can be started by\n * a call to g at any point, and finishing the first call to g doesn't\n * affect the second fragment.\n *\n * Finally, if there are multiple possibly matching fragments, it's\n * not clear which you select to match, and contrary to a vague\n * statement in the docs, it does matter. For example, given these\n * two fragments:\n *       f -> g -> w\n *       f -> g -> z\n * which do you pick to start using and mark partially used when a\n * sequence begins with call f? It seems like to satisfy the apparent\n * intent of the system you have to choose both nondeteriminstically\n * and only resolve which one you actually mark used when it becomes\n * unambiguous. (And if you still have multiple potentially used\n * fragments when you're done executing, which do you pick? If they're\n * the same it doesn't matter, and if one's a subgraph of another it's\n * clear you should pick the smaller one, but in general there's no\n * obvious answer.)\n *\n * Update: the fragments are provided in some order and if they begin\n * with the same function they're matched in the order given, so in\n * the above example your first f call must be the one that proceeds\n * to w. There is no nondeterministic matching or backtracking here;\n * that kind of thing is undesirable in security systems.\n *\n * 5. In addition to the structural matching described above, each\n * node also has a list of values in it, which correspond to the\n * arguments to be passed to the function. These need to be matched at\n * runtime by the arguments given. It isn't clear how these values are\n * supposed to be matched and the documentation is silent, but it\n * appears the intent is just an equality test: the values found at\n * runtime should be the same list as the values found in the fragment.\n *\n * There are two variants of the authorization hypercall, one of which\n * defaults to the argument list from the current invocation, and the\n * other of which takes an explicit argument list. It seems the idea\n * is that the latter can be arbitrary (though related somehow to the\n * current invocation) and the person creating the authorization\n * fragments is supposed to know what'll be posted at runtime so they\n * can include the right list of values in their fragments. This\n * allows e.g. suppressing arguments that are irrelevant to the\n * Address being consulted.\n *\n * Given all the uncertainty above, and given that the more complete\n * model I started out with completely overwhelmed the verification\n * system, I've implemented the following.\n *\n * (Note that because we don't actually support cross-contract calls\n * yet, we can only use this for one contract at a time, so what's\n * here is sufficient for current purposes.)\n *\n * A. We can only have one authorized call-graph fragment.\n *\n * B. That fragment can only have one node in it.\n *\n * C. Call-graph nodes track the function involved but not the\n * argument list.\n *\n * D. We can only be matching in one place at one time. That place\n * can be:\n *    - before the single node in the single fragment\n *    - after the single node in the single fragment\n *    - after the single fragment\n *\n * In the first case, if the current call matches, we succeed and\n * advance past the node.\n *\n * In the first case, if the current call doesn't match we assume the\n * fragment's done and move past it.\n *\n * In the second case the fragment is done so we move past it.\n *\n * In the third case we always fail because there's nothing left to\n * match against.\n *\n * E. In principle if we are partway through a fragment and the\n * current contract function returns we should skip over any pieces of\n * the current fragment this renders inaccessible. In this version\n * this does nothing because we can't be partway through a fragment.\n * (XXX: However, there should be an external hook for triggering this\n * case. That doesn't exist yet, because it's not clear what it should\n * look like until we have logic for cross-contract calls.)\n *\n * F. The top-level contract spec should assert the following\n * preconditions:\n *    - that the authorization state is valid (with \"valid\")\n *    - what the current invocation is (with \"invocation\"), passing\n *      the current contract function name (with a more complete model\n *      this would also pass the current function argument list too)\n *    - that the match state is the initial state (with \"initial\")\n *      (in principle one may start with a partially discharged state,\n *      but there isn't currently direct support for asserting it and\n *      given the current model limitations it isn't very useful)\n * then it should add authorization fragments with \"authorize\".\n * (Currently this can only be done once for the single fragment\n * supported, and the node list should be a list of a single contract\n * function name, without an argument list because that isn't\n * supported either.) It should then bind the resulting auth object to\n * the contract's pre-state.\n *\n * G. The top-level contract spec should then generate an updated auth\n * model by using one of the authorization functions (corresponding to\n * the authorization call the contract makes) and bind the result to\n * the contract's post-state.\n *\n * H. The saw-script wrapper code in soroban.saw provides wrappers for\n * these operations and ghost-state tracking for the pre-state and\n * post-state, as well as specs for the hypercalls involved.\n *\n * I. Because we don't have contract IDs yet (they are BytesObjects,\n * which we don't have support for) we use the Symbol for the function\n * name as the contract function name. In the long run this should\n * probably be either the contract ID or the contract ID paired with\n * the function name.\n *\/\n\n\ntype T = Auth\n\nprivate\n   \/*\n    * We use the following representation:\n    *\n    * (1) to represent the authorization fragment:\n    *    - the address for the fragment\n    *    - the number of nodes in the fragment (fixed to 1)\n    *    - the contract function name for the single node\n    *\n    * Because we don't support contract IDs yet, for now use the\n    * Symbol for the function name instead.\n    *\n    * We'll use 8-bit values to count the number of nodes to try to\n    * reduce the state space. and keep things from getting out of\n    * hand.\n    *\n    * (2) to represent the matching state:\n    *    - whether the fragment is done\n    *    - the next node in the fragment to match against\n    *      (always either 0 or 1)\n    *\n    * (3) to represent the currently running invocation:\n    *    - the current contract function name (as noted above, a\n    *      Symbol for the function name)\n    *\/\n\n   \/\/ type for the array index\n   type NodeNum = [8]\n\n   newtype Auth = {\n      \/\/ The address and number of nodes for the fragment\n      address: Addr,\n      numnodes: NodeNum,\n\n      \/\/ The contract (actually function name) for the one node\n      contract: Values::Symbol::T,\n\n      \/\/ The match state: whether the fragment is done, and if\n      \/\/ not the next node we're going to use within it.\n      fragdone: Bool,\n      nextnode: NodeNum,\n\n      \/\/ The current invocation state. This may need to grow later.\n      invokedcontract: Values::Symbol::T\n   }\n\n      type Heap = Values::HostHeap\n   type Addr = Values::AddressObject::T\n\n\n\/*\n * Check that an Auth is valid. Meant for preconditions.\n *\n * For this version, we can have only one node in the fragment. The\n * commented-out code is for having more than one.\n *\/\nvalid: Auth -> Bool\nvalid auth = conditions\n   where\n      conditions =\n         fragment_valid &&\n         matchstate_valid &&\n         invokedcontract_valid\n            fragment_valid = (auth.numnodes == 1) && addr_valid && node_valid 0\n         where\n            addr_valid = Values::AddressObject::valid auth.address\n                        node_valid node = contract_valid\n               where\n                                    contract = auth.contract\n                  contract_valid = Values::Symbol::valid contract\n      \/\/ Note: because fragments aren't allowed to be\n      \/\/ empty, nextnode == 0 is always valid. However,\n      \/\/ auth.numnodes is not meaningful if fragdone is\n      \/\/ true. Don't rely on it.\n      matchstate_valid = (nextnode == 0) || (nextnode < auth.numnodes)\n         where\n            nextnode = auth.nextnode\n      invokedcontract_valid =\n         Values::Symbol::valid auth.invokedcontract\n\n\/*\n * Check that an Auth is valid _and_ in an initial state:\n * nothing has been consumed yet. Meant for preconditions.\n *\/\ninitial: Auth -> Bool\ninitial auth = valid auth && (auth.fragdone == False) && (auth.nextnode == 0)\n\n\/*\n * Check the invocation state of an Auth.\n *\/\ninvocation: Heap -> Auth -> Values::Symbol::T -> Bool\ninvocation heap auth sym =\n   Values::Symbol::eq auth.invokedcontract sym heap\n\n\nprivate\n   \/*\n    * Convert a list of nodes to an array for use as the fragment.\n    *\n    * The default value in the array is the first node. We have to be\n    * careful to be consistent about that so that SMT-level equality\n    * of arrays is consistent with intended-contents-only equality.\n    *\n    * For this version that has only one node in the fragment, pluck\n    * out the first entry in the argument and use that. The commented\n    * out code is for having more than one node.\n    *\/\n   makenodes: {n} (0 < n, n < 256) =>\n      \/\/[n] Values::Symbol::T -> (NodeNum, Array NodeNum Values::Symbol::T)\n      [n] Values::Symbol::T -> (NodeNum, Values::Symbol::T)\n   makenodes nodes = (1, nodes ! 0)\n   \/\/makenodes nodes = arrays ! 0\n   \/\/   where\n   \/\/      [first] # rest = nodes\n   \/\/      arrays =\n   \/\/         [(1, arrayConstant first)] # [(i + 1, arrayUpdate array i node)\n   \/\/                                         | (i, array) <- arrays\n   \/\/                                         | node <- rest]\n\n\/*\n * Bind a fragment to an authorization state.\n *\n * Leaves the matching state and invocation state alone, so you can\n * assert about that separately.\n *\n * This version has only one node in the fragment. The commented-out\n * code is for having more than one node.\n *\/\nauthorize: {n} (0 < n, n < 256) =>\n   Auth -> Addr -> [n] Values::Symbol::T -> Auth\nauthorize auth addr nodes = auth'\n   where\n            (num, contract) = makenodes nodes\n      auth' = Auth {\n         address = addr,\n         numnodes = num,\n                  contract = contract,\n\n         fragdone = auth.fragdone,\n         nextnode = auth.nextnode,\n\n         invokedcontract = auth.invokedcontract\n      }\n\n\nprivate\n   \/*\n    * Update the current node.\n    *\/\n   set_nextnode: Auth -> Addr -> NodeNum -> Auth\n   set_nextnode auth addr node = auth'\n      where\n         auth' = Auth {\n            address = auth.address,\n            numnodes = auth.numnodes,\n                        contract = auth.contract,\n\n            fragdone = auth.fragdone,\n            nextnode = node,\n\n            invokedcontract = auth.invokedcontract\n         }\n\n   \/*\n    * Mark the fragment done.\n    *\/\n   set_fragdone: Auth -> Bool -> Auth\n   set_fragdone auth state = auth'\n      where\n         auth' = Auth {\n            address = auth.address,\n            numnodes = auth.numnodes,\n                        contract = auth.contract,\n\n            fragdone = state,\n            nextnode = auth.nextnode,\n\n            invokedcontract = auth.invokedcontract\n         }\n\n   \/*\n    * We are done with the fragment. Mark it done, and set nextnode to\n    * 0 as if we were going on to another fragment.\n    *\/\n   finish_fragment: Auth -> Addr -> Auth\n   finish_fragment auth addr = auth''\n      where\n         auth' = set_fragdone auth True\n         auth'' = set_nextnode auth' addr 0\n\n   \/*\n    * Move to the next node in the fragment. If we run out, mark it\n    * done.\n    *\/\n   advance_to_next_node: Auth -> Addr -> Auth\n   advance_to_next_node auth addr =\n      if done then finish_fragment auth addr\n      else set_nextnode auth addr nextnode'\n      where\n         nextnode' = auth.nextnode + 1\n         done = nextnode' >= auth.numnodes\n\n   \/*\n    * Check if the given node of the given fragment matches the\n    * contract presented for authorization (the contract in question\n    * is always the current invoked contract)\n    *\n    * For this version with only one node in the fragment, always\n    * use the only node. (The commented out code is for multiple\n    * nodes.)\n    *\/\n   match_node: Heap -> Auth -> NodeNum -> Bool\n   match_node heap auth _node = ok\n      where\n                  contract = auth.contract\n         ok = Values::Symbol::eq contract auth.invokedcontract heap\n\n   \/*\n    * Match against the fragment. If it has run out, or if match_node\n    * says the next node doesn't match, return false.\n    *\/\n   match_fragment: Heap -> Auth -> Addr -> Bool\n   match_fragment heap auth addr = (auth.nextnode < auth.numnodes) && matches\n      where\n         matches = addr_matches && node_matches\n         addr_matches = Values::addressobj_eq addr auth.address\n         node_matches = match_node heap auth auth.nextnode\n\n   \/*\n    * Try matching the fragment. If that works, move to the\n    * next node and succeed. If not, finish the fragment, and then\n    * fail because there isn't another fragment to try.\n    *\n    * Return an updated Auth state as well as success\/failure.\n    *\/\n   check_fragment: Heap -> Auth -> Addr -> (Auth, Bool)\n   check_fragment heap auth addr =\n      \/\/ try the active fragment\n      if matches then to_nextnode else retry_nextfrag\n      where\n         matches = match_fragment heap auth addr\n         \/\/ the active fragment matched, advance to its next node\n         \/\/ and succeed\n         to_nextnode = (auth', True)\n            where auth' = advance_to_next_node auth addr\n         \/\/ the active fragment didn't match; drop it\n         retry_nextfrag = (auth', False)\n            where\n               auth' = finish_fragment auth addr\n\n\/*\n * Check whether the invoked function (and, theoretically, args) are\n * authorized. Returns an updated authorization state as well as the\n * success\/failure result.\n *\/\ncheck_noargs: Heap -> Auth -> Addr -> (Auth, Bool)\ncheck_noargs heap auth addr = check_fragment heap auth addr\n\n\/* XXX: args aren't supported so ignore them *\/\ncheck_withargs: Heap -> Auth -> Addr -> Values::VecObject::T -> (Auth, Bool)\ncheck_withargs heap auth addr _args = check_fragment heap auth addr\n```"}]}
{"filename":"formal-verso\/lib\/EventLog.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the 'add' function in the EventLog module. The properties should ensure that after adding a new event, the event log's count increases by one, the new topic and value are correctly stored at the updated index, and all previous entries remain unchanged. Additionally, write properties to verify that the 'equiv' function correctly determines equivalence between two EventLog instances based on their contents and counts."},{"role":"assistant","content":"```cryptol\nmodule Events where\n\nimport Array\n\nimport Values as Values\nimport submodule Values::Raw as Values::Raw\nimport submodule Values::VecObject as Values::VecObject\n\ntype T = EventLog\n\nprivate\n   type Topic = Values::VecObject::T\n   type Value = Values::Raw::T\n   type Topics = Array Integer Topic\n   type Values = Array Integer Value\n\n   newtype EventLog = {\n      topics: Topics,\n      values: Values,\n      count: Integer\n   }\n\nadd : EventLog -> Values::VecObject::T -> Values::Raw::T -> EventLog\nadd elog topic val =\n   EventLog { topics = topics', values = values', count = count' }\n   where\n      topics' = arrayUpdate elog.topics elog.count topic\n      values' = arrayUpdate elog.values elog.count val\n      count' = elog.count + 1\n\nprivate\n   equiv_entry : Topic -> Value -> Topic -> Value -> Values::HostHeap -> Bool\n   equiv_entry t1 v1 t2 v2 heap =\n      Values::vecobj_eq t1 t2 heap \/\\ Values::raw_eq v1 v2 heap\n\n   equiv_at : EventLog -> EventLog -> Values::HostHeap -> Integer -> Bool\n   equiv_at el1 el2 heap i =\n      if equiv_entry t1 v1 t2 v2 heap == False then False\n      | i >= el1.count then True\n      else equiv_at el1 el2 heap (i + 1)\n      where\n         t1 = arrayLookup el1.topics i\n         v1 = arrayLookup el1.values i\n         t2 = arrayLookup el2.topics i\n         v2 = arrayLookup el2.values i\n\nequiv : EventLog -> EventLog -> Values::HostHeap -> Bool\nequiv el1 el2 heap =\n   if el1.count != el2.count then False\n   else equiv_at el1 el2 heap 0\n```"}]}
{"filename":"formal-verso\/lib\/Option.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the Option module's functions. Specifically, specify properties that check: 1) 'ok' and 'some' always produce an Option with is_ok set to True; 2) 'none' and 'none'' produce an Option with is_ok set to False; 3) 'unsafe_unwrap' returns the stored value when is_ok is True; 4) 'crashing_unwrap' behaves like 'unsafe_unwrap' but raises an error when is_ok is False; 5) 'unwrap_or' returns the stored value if is_ok is True, otherwise returns the default; 6) 'fmap' preserves the is_ok flag and applies the function to the value only if is_ok is True. Write these as Cryptol properties suitable for :check or :prove."},{"role":"assistant","content":"```cryptol\nmodule Option where\n\ntype T a = Option a\n\ntype Option a =\n  { is_ok : Bit\n  , value : a\n  }\n\n\/*\n * XXX: is this supposed to be \"option\" or \"result\"?\n *\n * Rust's \"option\" is None or Some (like ocaml's) and \"result\" is Ok\n * or Err, but... we are not in a position to be able to store an\n * error value given the above definition, so it shouldn't really be\n * \"result\".\n *\n * I'm going to add \"some\" and \"none\" functions as a stopgap for more\n * clarity until I get a chance to clean it up.\n *\n * Also, it appears this type (as opposed to the other option\n * surrogate in Storage.cry) are never exported into SAW, so there's\n * no clear reason we can't use Cryptol's own Option. XXX...\n *\n * Update: for now at least, add \"none'\" that takes a dummy value to\n * store in the value part, since we need to put something there and\n * we can't actually use zero because there's currently no way to\n * derive (or explicitly instantiate) the Zero typeclass for the\n * newtypes we're using.\n *\/\n\nok : {a} a -> Option a\nok x = mk True x\n\n\nsome : {a} a -> Option a\nsome x = mk True x\n\nnone : {a} Zero a => Option a\nnone = mk False zero\n\nnone' : {a} a -> Option a\nnone' z = mk False z\n\n\nmk : {a} Bit -> a -> Option a\nmk valid value = { is_ok = valid, value = value }\n\nis_ok : {a} Option a -> Bit\nis_ok o = o.is_ok\n\nis_some : {a} Option a -> Bit\nis_some o = o.is_ok\n\nunsafe_unwrap : {a} Option a -> a\nunsafe_unwrap o = o.value\n\ncrashing_unwrap : {a} Option a -> a\ncrashing_unwrap o = if o.is_ok then o.value else error \"Option::crashing_unwrap\"\n\nunwrap_or : {a} Option a -> a -> a\nunwrap_or o def = if o.is_ok then o.value else def\n\nok_implies : {a} (a -> Bit) -> Option a -> Bit\nok_implies p o = if o.is_ok then p o.value else True\n\nok_and : {a} (a -> Bit) -> Option a -> Bit\nok_and p o = if o.is_ok then p o.value else False\n\nfmap : {a, b} Option a -> (a -> b) -> Option b\nfmap o f =\n  { is_ok = o.is_ok\n  , value = f o.value\n  }\n```"}]}
{"filename":"formal-verso\/lib\/HostValues.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the HostValues module's heap allocation and lookup functions. Specifically, specify properties that ensure: (1) after allocating a value (u64, string, vector, or map), the heap's next handle increments correctly; (2) the allocated handle is present and correctly typed in the heap; (3) lookup functions return the stored value for valid handles and return None or invalid representations for out-of-range or mismatched types; and (4) the equivalence functions for vectors and maps behave as expected. Include properties to check the behavior of arrayScatterConstant and arrayScatterVals as used in map and vector representations."},{"role":"assistant","content":"```cryptol\n\/*\n * Values stored on the host side.\n *\n * In the Soroban world these values are stored in the VM host and\n * accessed\/manipulated with hypercalls. The VM guest uses 32-bit\n * object handles to refer to them.\n *\n * For modeling this, we need (a) a representation of the stored\n * values and also (b) a table that maps object handles to them that\n * we can use to get at these values directly.\n *\n * This file defines both.\n *\n * XXX: for the moment the representation here is rather ad hoc. In\n * the long run it might be better to set it up to match the Soroban\n * host code more closely so it can sometime maybe be used as a basis\n * for verifying that code.\n *\n * Note: if we want to have this and the contract-facing values in\n * separate files, only one can depend on the other. For the moment,\n * the choice is that Values depends on HostValues.  It's definitely\n * possible that this should get restructured once it's clearer what\n * things actually look like after they get built out further. Obvious\n * possibilities are:\n *\n * 1. Values depends on HostValues (current state). Advantages:\n * natural relationship, doesn't mess up the abstraction layer in\n * Values. Disadvantages: we can't refer to Values::Raw from here so\n * the contents of vectors and maps have to be unwrapped, stored here\n * as u64, and rewrapped inside Values, which is ugly.\n *\n * 2. HostValues depends on Values. Advantage: the use of integer\n * handles when Values point to HostValues gives an obvious place to\n * cut the circular dependency. The only thing Values need in them is\n * a u32, and while it might be tidier to be able to call that a\n * HostValues::Handle, that's not really necessary or critical. Then\n * we can refer to raw values (Values::Raw::T) here for e.g. the\n * contents of vectors and maps. Disadvantages: since HostValues is\n * part of the implementation of Values, it should really be\n * underneath it, and this way is backwards.  inversion mentioned\n * above; Also, it means the nicely wrapped-up types in Values, which\n * all have a regularized interface and so forth, can't themselves\n * hide the host value lookups inside them. This messes up the\n * abstractions. It'll be particularly messy for the types that can be\n * either small (non-host) or large (host-stored) values, like U64 and\n * Symbol.\n *\n * 3. Split Values::Raw to its own file. Advantages: the proper way to\n * break the circular dependency, and eliminates the tradeoffs in\n * options 1\/2. Disadvantages: creates more things, and exposes many\n * more internal elements.\n *\n * 4. Merge this file into Values. Advantages: eliminates all the other\n * problems. Disadvantage: large and messy.\n *\n * TBD. Watch this space.\n *\/\nmodule HostValues where\n\nimport Array\n\nimport Option as Option\n\n\/*\n * Interface types. We map Handle to any\/all of the representation\n * types (which may include values of type RawRawVal); the state of\n * the mapping is called Heap because it's ultimately an allocation\n * heap. These types are intended to be written qualified, as in\n * HostValues::Handle and HostValues::Heap.\n *\/\ntype Handle = [32]\ntype RawRawVal = [64]\ntype Heap = HostHeap\n\n\n\/* assign V for every key in KS *\/\narrayScatterConstant : {a, b, n} fin n => Array a b -> [n] a -> b -> Array a b\narrayScatterConstant arr ks v = arrs ! 0\n   where arrs = [arr] # [arrayUpdate arr' k v | arr' <- arrs | k <- ks]\n\n\/* assign the corresponding V in VS for every key in KS *\/\narrayScatterVals : {a, b, n} fin n => Array a b -> [n] a -> [n] b -> Array a b\narrayScatterVals arr ks vs = arrs ! 0\n   where arrs = [arr] # [arrayUpdate arr' k v | arr' <- arrs | k <- ks | v <- vs]\n\n\n\/*\n * Because for the moment we don't need to track the actual strings,\n * I'm going to start off with a null\/dummy string representation.\n *\/\ntype StringRepresentation = ()\n\nstring_representation_dummy : StringRepresentation\nstring_representation_dummy = ()\n\ninvalid_string_representation : StringRepresentation\ninvalid_string_representation = ()\n\n\n\/*\n * Vectors map 32-bit indexes to 64-bit unwrapped raw values.\n * Values.cry rewraps those values as needed.\n *\n * XXX we should come up with some shorter names here\n *\/\ntype VecData = Array [32] RawRawVal\nnewtype VecRepresentation = {\n   data: VecData,\n   size: [32]\n}\n\nvec_representation_empty : VecRepresentation\nvec_representation_empty =\n   VecRepresentation { data = arrayConstant 0, size = 0 }\n\nvec_representation_singleton : RawRawVal -> VecRepresentation\nvec_representation_singleton n =\n   VecRepresentation { data = arr, size = 1 }\n   where arr = arrayUpdate (arrayConstant 0) 0 n\n\nvec_representation_pair : RawRawVal -> RawRawVal -> VecRepresentation\nvec_representation_pair n m =\n   VecRepresentation { data = arr, size = 2 }\n   where arr = arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m\n\nvec_representation_triple : RawRawVal -> RawRawVal -> RawRawVal -> VecRepresentation\nvec_representation_triple n m o =\n   VecRepresentation { data = arr, size = 3 }\n   where arr = arrayUpdate (arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m) 2 o\n\nvec_representation_quad : RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> VecRepresentation\nvec_representation_quad n m o p =\n   VecRepresentation { data = arr, size = 4 }\n   where arr = arrayUpdate (arrayUpdate (arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m) 2 o) 3 p\n\nvec_representation_quint : RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> VecRepresentation\nvec_representation_quint n m o p q =\n   VecRepresentation { data = arr, size = 5 }\n   where arr = arrayUpdate (arrayUpdate (arrayUpdate (arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m) 2 o) 3 p) 4 q\n\n\/*\n * N copies of V\n *\n * This has to agree with the equivalent vec_representation_seq, on\n * the _whole_ array and not just the meaningful part, because that's\n * what happens in the SMT and thus with the implicit assertions that\n * happen in SAW, so we can't just do arrayConstant.\n *\/\nvec_representation_n: [32] -> RawRawVal -> VecRepresentation\nvec_representation_n n v =\n   if n == 0 then vec_representation_empty\n   else vec_representation_addtail (vec_representation_n (n - 1) v) v\n\nvec_representation_seq: {n} n <= 0xffffffff => [n] RawRawVal -> VecRepresentation\nvec_representation_seq seq =\n   VecRepresentation { data = arr, size = `n }\n   where arr = arrayRangeUpdate (arrayConstant 0) 0 seq\n\n\/* Vector used when an invalid\/error version is needed *\/\ninvalid_vec_representation : VecRepresentation\ninvalid_vec_representation = vec_representation_empty\n\n\/* get nth value, or return default value if out of range *\/\nvec_representation_get_default : VecRepresentation -> [32] -> RawRawVal -> RawRawVal\nvec_representation_get_default rep n dfl =\n   if n < rep.size then arrayLookup rep.data n else dfl\n\n\/* get all values -- ideally n is rep.size and the default value isn't used *\/\nvec_representation_getall : {n} n <= 0xffffffff => VecRepresentation -> RawRawVal -> [n] RawRawVal\nvec_representation_getall rep dfl = vals\n   where vals @ i = vec_representation_get_default rep i dfl\n\n\/* test contents for equivalence *\/\nprivate\n   vec_representation_equiv_at :\n          (RawRawVal -> RawRawVal -> Heap -> Bool) ->\n          VecRepresentation -> VecRepresentation -> Heap ->\n          [32] ->\n          Bool\n   vec_representation_equiv_at subcmp rep1 rep2 heap i =\n      if i >= rep1.size then True\n      | subcmp x1 x2 heap == False then False\n      else vec_representation_equiv_at subcmp rep1 rep2 heap (i + 1)\n      where\n         x1 = arrayLookup rep1.data i\n         x2 = arrayLookup rep2.data i\n\nvec_representation_equiv :\n       (RawRawVal -> RawRawVal -> Heap -> Bool) ->\n       VecRepresentation -> VecRepresentation -> Heap ->\n       Bool\nvec_representation_equiv subcmp rep1 rep2 heap =\n   if rep1.size != rep2.size then False\n   else vec_representation_equiv_at subcmp rep1 rep2 heap 0\n\n\/* updates *\/\nvec_representation_addtail : VecRepresentation -> RawRawVal -> VecRepresentation\nvec_representation_addtail rep v =\n   VecRepresentation { data = data', size = size' }\n   where\n      data' = arrayUpdate rep.data rep.size v\n      size' = rep.size + 1\n\n\n\/*\n * Maps map 64-bit unwrapped raw keys to 64-bit unwrapped raw values.\n * Values.cry rewraps those values as needed.\n *\/\n\ntype MapHere = Array RawRawVal Bool\ntype MapData = Array RawRawVal RawRawVal\nnewtype MapRepresentation = {\n   here: MapHere,\n   data: MapData\n}\n\nmap_representation_empty: MapRepresentation\nmap_representation_empty =\n   MapRepresentation { here = arrayConstant False, data = arrayConstant 0 }\n\nmap_representation_add: RawRawVal -> RawRawVal -> MapRepresentation -> MapRepresentation\nmap_representation_add k v rep =\n   MapRepresentation { here = here', data = data' }\n   where\n      here' = arrayUpdate rep.here k True\n      data' = arrayUpdate rep.data k v\n\nmap_representation_singleton: RawRawVal -> RawRawVal -> MapRepresentation\nmap_representation_singleton k v =\n   map_representation_add k v map_representation_empty\n\nmap_representation_pair: RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> MapRepresentation\nmap_representation_pair k1 v1 k2 v2 =\n   map_representation_add k2 v2 (map_representation_singleton k1 v1)\n\n\/* Sequence *\/\nmap_representation_seq: {n} n <= 0xffffffff => [n] RawRawVal -> [n] RawRawVal -> MapRepresentation\nmap_representation_seq ks vs =\n   MapRepresentation { here = here, data = data }\n   where\n      here = arrayScatterConstant empty.here ks True\n      data = arrayScatterVals empty.data ks vs\n      empty = map_representation_empty\n\n\/* Map used when an invalid\/error version is needed *\/\ninvalid_map_representation : MapRepresentation\ninvalid_map_representation = map_representation_empty\n\n\/* check if k is present *\/\nmap_representation_has_key : RawRawVal -> MapRepresentation -> Bool\nmap_representation_has_key k rep =\n   arrayLookup rep.here k\n\n\/* get value for k, or return default value if not present *\/\nmap_representation_get_default : RawRawVal -> MapRepresentation -> RawRawVal -> RawRawVal\nmap_representation_get_default k rep dfl =\n   if arrayLookup rep.here k == False then dfl\n   else arrayLookup rep.data k\n\n\/* get values for ks, returning default value where not present *\/\nmap_representation_multiget_default : {n} [n] RawRawVal -> MapRepresentation -> RawRawVal -> [n] RawRawVal\nmap_representation_multiget_default ks rep dfl = result\n   where result @ i = map_representation_get_default (ks @ i) rep dfl\n\n\/* test contents for equivalence *\/\nmap_representation_equiv :\n       (RawRawVal -> RawRawVal -> Heap -> Bool) ->\n       MapRepresentation -> MapRepresentation -> Heap ->\n       Bool\nmap_representation_equiv _subcmp _rep1 _rep2 _heap =\n      error \"map_representation_equiv: not yet implemented\"\n\n\nprivate\n   \/*\n    * The supported types of host-side values are:\n    *    - 64-bit, 128-bit, and 256-bit signed and unsigned integers\n    *    - timepoints\n    *    - durations\n    *    - bytes (essentially arrays of u8)\n    *    - strings\n    *    - symbols (restricted strings)\n    *    - vectors\n    *    - maps\n    *    - addresses\n    *\n    * of which we currently only provide u64, string, and vector.\n    *\n    * It would be better not to need HostInvalid but until we have\n    * a better Option.cry we need a value to stuff in failures.\n    *\/\n\/* apparently we can't have this at all, even if SAW never sees it\n   enum HostVal =\n        HostInvalid\n      | HostU64 [64]\n      | HostVec VecRepresentation\n*\/\n   type TypeTag = [2]\n   TagU64 = 0\n   TagString = 1\n   TagVec = 2\n   TagMap = 3\n\n   newtype HostHeap = {\n            types: Array Handle TypeTag,\n      values_u64: Array Handle [64],\n      values_string: Array Handle StringRepresentation,\n      \/\/ Can't do this (saw-script #1988)\n      \/\/values_vec: Array Handle VecRepresentation,\n      \/\/ Instead make a pair of arrays\n      values_vecdata: Array Handle VecData,\n      values_vecsize: Array Handle [32],\n      values_maphere: Array Handle MapHere,\n      values_mapdata: Array Handle MapData,\n      next: Handle\n   }\n\n\n\/*\n * Assert that the heap can allocate at least as many more objects as\n * \"headroom\". If adding in headroom makes the value smaller, the\n * value overflowed.\n *\/\nheap_has_space : Heap -> [32] -> Bool\nheap_has_space h headroom = h.next + headroom >= h.next\n\nempty_heap : Heap\nempty_heap =\n   HostHeap {\n      types = arrayConstant 0,\n      values_u64 = arrayConstant 0,\n      values_string = arrayConstant string_representation_dummy,\n      values_vecdata = arrayConstant (arrayConstant 0),\n      values_vecsize = arrayConstant 0,\n      values_maphere = arrayConstant (arrayConstant False),\n      values_mapdata = arrayConstant (arrayConstant 0),\n      next = 0\n   }\n\n\/* this also doesn't work\n   \/*\n    * Allocate a value and store it in the state.\n    *\/\n   alloc : HostVal -> Heap -> (Heap, Handle)\n   alloc v s = (s', handle)\n      where\n         handle = s.next\n         values' = arrayUpdate s.values handle v\n         s' = HostHeap { values = values', next = s.next + 1 }\n\n   \/*\n    * Look up a value. Out of range handles produce None.\n    *\/\n   lookup : Handle -> Heap -> Option::T HostVal\n   lookup h s =\n      if h < s.next then Option::some (arrayLookup s.values h)\n      else Option::none' HostInvalid\n*\/\n\n\/*\n * Typed allocate wrappers\n *\/\n\nalloc_u64 : [64] -> Heap -> (Heap, Handle)\nalloc_u64 n s = (s', handle)\n   where\n      handle = s.next\n      types' = arrayUpdate s.types handle TagU64\n      values_u64' = arrayUpdate s.values_u64 handle n\n      s' = HostHeap {\n         types = types',\n         values_u64 = values_u64',\n         values_string = s.values_string,\n         values_vecdata = s.values_vecdata,\n         values_vecsize = s.values_vecsize,\n         values_maphere = s.values_maphere,\n         values_mapdata = s.values_mapdata,\n         next = s.next + 1\n      }\n\nalloc_string : StringRepresentation -> Heap -> (Heap, Handle)\nalloc_string rep s = (s', handle)\n   where\n      handle = s.next\n      types' = arrayUpdate s.types handle TagString\n      values_string' = arrayUpdate s.values_string handle rep\n      s' = HostHeap {\n         types = types',\n         values_u64 = s.values_u64,\n         values_string = values_string',\n         values_vecdata = s.values_vecdata,\n         values_vecsize = s.values_vecsize,\n         values_maphere = s.values_maphere,\n         values_mapdata = s.values_mapdata,\n         next = s.next + 1\n      }\n\nalloc_vec : VecRepresentation -> Heap -> (Heap, Handle)\nalloc_vec rep s = (s', handle)\n   where\n      handle = s.next\n      types' = arrayUpdate s.types handle TagVec\n            values_vecdata' = arrayUpdate s.values_vecdata handle rep.data\n      values_vecsize' = arrayUpdate s.values_vecsize handle rep.size\n      s' = HostHeap {\n         types = types',\n         values_u64 = s.values_u64,\n         values_string = s.values_string,\n         values_vecdata = values_vecdata',\n         values_vecsize = values_vecsize',\n         values_maphere = s.values_maphere,\n         values_mapdata = s.values_mapdata,\n         next = s.next + 1\n      }\n\nalloc_map : MapRepresentation -> Heap -> (Heap, Handle)\nalloc_map rep s = (s', handle)\n   where\n      handle = s.next\n      types' = arrayUpdate s.types handle TagMap\n      values_maphere' = arrayUpdate s.values_maphere handle rep.here\n      values_mapdata' = arrayUpdate s.values_mapdata handle rep.data\n      s' = HostHeap {\n         types = types',\n         values_u64 = s.values_u64,\n         values_string = s.values_string,\n         values_vecdata = s.values_vecdata,\n         values_vecsize = s.values_vecsize,\n         values_maphere = values_maphere',\n         values_mapdata = values_mapdata',\n         next = s.next + 1\n      }\n\n\/*\n * Typed lookup wrappers\n *\/\n\npresent_as_u64 : Handle -> Heap -> Bool\npresent_as_u64 h s =\n   if h >= s.next then False\n   | arrayLookup s.types h != TagU64 then False\n   else True\n\npresent_as_string : Handle -> Heap -> Bool\npresent_as_string h s =\n   if h >= s.next then False\n   | arrayLookup s.types h != TagString then False\n   else True\n\npresent_as_vec : Handle -> Heap -> Bool\npresent_as_vec h s =\n   if h >= s.next then False\n   | arrayLookup s.types h != TagVec then False\n   else True\n\npresent_as_map : Handle -> Heap -> Bool\npresent_as_map h s =\n   if h >= s.next then False\n   | arrayLookup s.types h != TagMap then False\n   else True\n\nlookup_u64 : Handle -> Heap -> Option::T [64]\nlookup_u64 h s =\n   if h >= s.next then Option::none' 0\n   | arrayLookup s.types h != TagU64 then Option::none' 0\n   else Option::some (arrayLookup s.values_u64 h)\n\nlookup_string : Handle -> Heap -> Option::T StringRepresentation\nlookup_string h s =\n   if h >= s.next then Option::none' invalid_string_representation\n   | arrayLookup s.types h != TagString then Option::none' invalid_string_representation\n   else Option::some (arrayLookup s.values_string h)\n\nlookup_vec : Handle -> Heap -> Option::T VecRepresentation\nlookup_vec h s =\n   if h >= s.next then Option::none' invalid_vec_representation\n   | arrayLookup s.types h != TagVec then Option::none' invalid_vec_representation\n   else\n      Option::some rep\n      where\n         data = arrayLookup s.values_vecdata h\n         size = arrayLookup s.values_vecsize h\n                  rep = VecRepresentation { data = data, size = size }\n\nlookup_map : Handle -> Heap -> Option::T MapRepresentation\nlookup_map h s =\n   if h >= s.next then Option::none' invalid_map_representation\n   | arrayLookup s.types h != TagMap then Option::none' invalid_map_representation\n   else\n      Option::some rep\n      where\n         here = arrayLookup s.values_maphere h\n         data = arrayLookup s.values_mapdata h\n         rep = MapRepresentation { here = here, data = data }\n```"}]}
{"filename":"formal-verso\/lib\/Log.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the behavior of the Log module's 'add' function, specifying how it updates the log count. Then, write properties suitable for :check or :prove that verify the correctness of 'add' in incrementing the log count by one."},{"role":"assistant","content":"```cryptol\nmodule Log where\n\nimport Option as Option\nimport Values as Values\nimport submodule Values::Raw as Raw\n\ntype T = Log\n\n\/*\n * In this version we just count the log messages\n *\/\n\nprivate\n  newtype Log = { count : Integer }\n\nadd : Log -> Log\nadd ll = Log { count = ll.count + 1 }\n```"}]}
{"filename":"formal-verso\/lib\/Util.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the lenPolyEq function in the Util module. The properties should check that lenPolyEq returns True if and only if the two input sequences have the same length and are element-wise equal, and returns False otherwise."},{"role":"assistant","content":"```cryptol\nmodule Util where\n\n\/** Length-polymorphic sequence equality. *\/\nlenPolyEq : {a, n, m} (Eq a, fin n) => [n]a -> [m]a -> Bit\nlenPolyEq xs ys\n  | n == m => xs == ys\n  | n != m => False\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/LLVM\/Permutations.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that formally verifies the equivalence between the `bit_reversal_permutation_fast` function defined in the LLVM::Permutations module and the `bit_reversal_permutation` function from the Spec::Permutations module. The property should be generic over the parameters `size` and `n` and include necessary constraints to ensure type correctness. Additionally, provide checks for this property on representative input sizes to confirm correctness."},{"role":"assistant","content":"```cryptol\n\/**\n * The functions in this module are written to more closely match the LLVM\n * generated for the C code we are trying to prove equivalent to our other\n * Cryptol specs. So this is an intermediate step along our proof trail.\n *\/\nmodule LLVM::Permutations where\n\nimport Common::Utils\nimport Spec::Permutations\n\n\/**\n * Return the bit-reversed permutation, which is an involution (inverts itself).\n * @see https:\/\/github.com\/ethereum\/c-kzg-4844\/blob\/430371ed270e97b5b77babc92c0bafa768f68b32\/src\/common\/utils.c#L103\n * Standard algorithm: https:\/\/en.wikipedia.org\/wiki\/Bit-reversal_permutation\n *\/\nbit_reversal_permutation_fast : {size, n}\n    (fin size, size >= 1, n >= 2, size * BYTE_WIDTH >= width n, 64 >= width n)\n    => [n][size * BYTE_WIDTH] -> [n][size * BYTE_WIDTH]\nbit_reversal_permutation_fast sequence =\n    bit_reversal_permutation_fast_rec`{size, n, width (n - 1)} sequence unused_bit_len 0\n    where\n        unused_bit_len = 64 - lg2 `(n)\n\n\/**\n * Recursive helper function for `bit_reversal_permutation_fast`.\n * ```repl\n * :check bit_reversal_permutation_fast_rec`{1, 4, 2} [0x01, 0x03, 0x02, 0x04] 62 3 == [0x01, 0x03, 0x02, 0x04]\n * :check bit_reversal_permutation_fast_rec`{1, 4, 2} [0x01, 0x03, 0x02, 0x04] 62 2 == [0x01, 0x03, 0x02, 0x04]\n * :check bit_reversal_permutation_fast_rec`{1, 4, 2} [0x01, 0x02, 0x03, 0x04] 62 1 == [0x01, 0x03, 0x02, 0x04]\n * :check bit_reversal_permutation_fast_rec`{1, 4, 2} [0x01, 0x02, 0x03, 0x04] 62 0 == [0x01, 0x03, 0x02, 0x04]\n * ```\n *\/\nbit_reversal_permutation_fast_rec : {size, n, nbits}\n    (fin size, size >= 1, n >= 2, size * BYTE_WIDTH >= width n, 64 >= width n, nbits == width (n - 1))\n    => [n][size * BYTE_WIDTH] -> [64] -> [64] -> [n][size * BYTE_WIDTH]\nbit_reversal_permutation_fast_rec sequence unused_bit_len i =\n        if i >= `(n) then sequence\n        else if r > i\n        then bit_reversal_permutation_fast_rec`{size, n, nbits} sequence' unused_bit_len (i + 1)\n        else bit_reversal_permutation_fast_rec`{size, n, nbits} sequence unused_bit_len (i + 1)\n    where\n    r = (reverse i) >> unused_bit_len\n    sequence' = swap`{size, n} sequence i r\n\n\/**\n * Helper function for `bit_reversal_permutation_fast`.\n * @see https:\/\/github.com\/ethereum\/c-kzg-4844\/blob\/430371ed270e97b5b77babc92c0bafa768f68b32\/src\/common\/utils.c#L122\n * ```repl\n * :check swap`{1, 4} [0x01, 0x02, 0x03, 0x04] 1 2 == [0x01, 0x03, 0x02, 0x04]\n * :check swap`{1, 4} [0x01, 0x02, 0x03, 0x04] 2 1 == [0x01, 0x03, 0x02, 0x04]\n * :check swap`{1, 4} [0x01, 0x02, 0x03, 0x04] 3 3 == [0x01, 0x02, 0x03, 0x04]\n * ```\n * NOTE: we just chose these values at \"random\"\n *\/\nswap : {size, n}\n    (fin size, size >= 1, n >= 2, size * BYTE_WIDTH >= width n, 64 >= width n)\n    => [n][size * BYTE_WIDTH] -> [64] -> [64] -> [n][size  * BYTE_WIDTH]\nswap values i r =\n    [swap_elem j | j <- [0 .. (n-1)]]\n    where\n        swap_elem j =\n            if j == r then values@i\n            else if j == i then values@r\n            else values@j\n\n\/*\n *  ==========\n *  Properties\n *  ==========\n *\/\n\n\/**\n * Prove that the `bit_reversal_permutation_fast` function is equivalent\n *  to `bit_reversal_permutation` found in `Spec`.\n * ```repl\n * :check bit_reversal_permutations_equiv`{1, 4}\n * :check bit_reversal_permutations_equiv`{4, 8}\n * :check bit_reversal_permutations_equiv`{8, 256}\n * ```\n *\/\nbit_reversal_permutations_equiv : {size, n}\n    (fin size, size >= 1, n >= 2, size * BYTE_WIDTH >= width n, 64 >= width n)\n    => [n][size * BYTE_WIDTH] -> Bit\nproperty bit_reversal_permutations_equiv seq =\n    bit_reversal_permutation`{size * BYTE_WIDTH, n} seq == bit_reversal_permutation_fast`{size, n} seq\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/KZG.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the KZG polynomial commitment scheme implemented in the Spec::KZG module. Include properties that check the correctness of blob_to_kzg_commitment, compute_kzg_proof and verify_kzg_proof functions, ensuring that proofs generated by compute_kzg_proof are accepted by verify_kzg_proof for valid inputs. Also specify properties for batch verification functions verify_kzg_proof_batch and verify_blob_kzg_proof_batch to confirm soundness and consistency of batch proof verification. Use the provided Ethereum consensus specification references as a basis for the properties."},{"role":"assistant","content":"```cryptol\n\/**\n * The module contains functions that perform the BLS KZG operations.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#kzg\n *\/\nmodule Spec::KZG where\n\nimport Common::ModArith\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::G1\nimport Spec::BlsEC::GP\nimport Spec::BlsEC::Pairing\nimport Spec::BlsHelpers\nimport Spec::BlsSerde\nimport Spec::Permutations\nimport Spec::Polynomials\nimport Spec::TrustedSetup\n\n\/**\n * Create the polynomial commitment for the given `Blob`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#blob_to_kzg_commitment\n *\/\nblob_to_kzg_commitment : Blob -> KZGCommitment\nblob_to_kzg_commitment blob =\n    g1_lincomb (bit_reversal_permutation KZG_SETUP_G1_LAGRANGE) (blob_to_polynomial blob)\n\n\/**\n * Given `y == p(z)` for a polynomial `p(x)`, compute `q(z)`: the KZG quotient polynomial evaluated at `z` for the\n *  special case where `z` is in roots of unity.\n * For more details, read https:\/\/dankradfeist.de\/ethereum\/2021\/06\/18\/pcs-multiproofs.html section \"Dividing\n *  when one of the points is zero\". The code below computes q(x_m) for the roots of unity special case.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#compute_quotient_eval_within_domain\n * NOTE: Test found in 'Test\/KZG\/ComputeQuotient\/TV1.cry'\n *\/\ncompute_quotient_eval_within_domain : BlsFieldElement -> Polynomial -> BlsFieldElement -> BlsFieldElement\ncompute_quotient_eval_within_domain z polynomial y = toIntegral result where\n    result = sum [compute i | i <- [0 .. (FIELD_ELEMENTS_PER_BLOB-1)]]\n    f i = (fromIntegral (polynomial@i)) - (fromIntegral y)\n    omega i = fromIntegral`{BLS_MODULUS} (ROOTS_OF_UNITY_BRP@i)\n    numerator i = (f i) * (omega i)\n    \/\/ Adding the BLS_MODULUS doesn't affect the computation because it is modular arithmetic with that modulus\n    denominator i = z' * (z' - (omega i))\n    z' = fromIntegral z\n    \/\/ Skip the evaluation point (z) in the sum\n    compute i = if omega i != z' then div_mod (numerator i) (denominator i) else 0\n\n\/**\n * Helper function for `compute_kzg_proof` and `compute_blob_kzg_proof`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#compute_kzg_proof_impl\n * Called by `compute_kzg_proof` for which we have a test vector.\n *\/\ncompute_kzg_proof_impl : Polynomial -> BlsFieldElement -> (KZGProof, BlsFieldElement)\ncompute_kzg_proof_impl polynomial z = (proof, y) where\n    \/\/ For all x_i, compute p(x_i) - p(z)\n    y = evaluate_polynomial_in_evaluation_form polynomial z\n    polynomial_shifted = [(fromIntegral`{BLS_MODULUS} p) - (fromIntegral y) | p <- polynomial]\n    \/\/ For all x_i, compute (x_i - z)\n    denominator_poly = [(fromIntegral`{BLS_MODULUS} x) - (fromIntegral z) | x <- ROOTS_OF_UNITY_BRP]\n    \/\/ Compute the quotient polynomial directly in evaluation form\n    quotient_polynomial = [quotient i a b | a <- polynomial_shifted | b <- denominator_poly | i <- [0 .. FIELD_ELEMENTS_PER_BLOB-1]]\n    \/\/ Handle the conditional computation of computing the quotient\n    quotient : Integer -> Z BLS_MODULUS -> Z BLS_MODULUS -> BlsFieldElement\n    quotient i a b =\n        if b == 0 then\n            \/\/ The denominator is zero hence `z` is a root of unity: we must handle it as a special case.\n            \/\/ This case can only happen once at most.\n            compute_quotient_eval_within_domain (ROOTS_OF_UNITY_BRP@i) polynomial y\n        else\n            \/\/ Compute: q(x_i) = (p(x_i) - p(z)) \/ (x_i - z).\n            toIntegral (div_mod`{BLS_MODULUS} a b)\n    proof = g1_lincomb (bit_reversal_permutation KZG_SETUP_G1_LAGRANGE) quotient_polynomial\n\n\/**\n * Compute KZG proof at point `z` for the polynomial represented by `blob`.\n * Do this by computing the quotient polynomial in evaluation form: q(x) = (p(x) - p(z)) \/ (x - z).\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#compute_kzg_proof\n * NOTE: Test found in 'Test\/KZG\/ComputeProof\/TV1.cry'\n *\/\ncompute_kzg_proof : Blob -> Bytes32 -> (KZGProof, Bytes32)\ncompute_kzg_proof blob z_bytes = (proof, y) where\n    polynomial = blob_to_polynomial blob\n    (proof, y') = compute_kzg_proof_impl polynomial (bytes_to_bls_field z_bytes)\n    y = split`{BYTES_PER_FIELD_ELEMENT} y'\n\n\/**\n * Verify KZG proof that `p(z) == y` where `p(z)` is the polynomial represented by `polynomial_kzg`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#verify_kzg_proof_impl\n * Called by `verify_kzg_proof` for which we have a test vector.\n *\/\nverify_kzg_proof_impl : KZGCommitment -> BlsFieldElement -> BlsFieldElement -> KZGProof -> Bit\nverify_kzg_proof_impl commitment z y proof = pairing_check points where\n    \/\/ Verify: P - y = Q * (X - z)\n    x_minus_z = g2_add (bytes96_to_G2 (KZG_SETUP_G2_MONOMIAL@1)) g2_mult\n    g2_mult = g2_multi_optimized G2 ((`(BLS_MODULUS) - z) % `(BLS_MODULUS))\n    p_minus_y = g1_add (bytes48_to_G1 commitment) g1_mult\n    g1_mult = g1_multi_optimized G1 ((`(BLS_MODULUS) - y) % `(BLS_MODULUS))\n    points = [(p_minus_y, (g2_negate G2)), ((bytes48_to_G1 proof), x_minus_z)]\n\n\/**\n * Verify KZG proof that `p(z) == y` where `p(z)` is the polynomial represented by `polynomial_kzg`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#verify_kzg_proof\n * NOTE: Test found in 'Test\/KZG\/VerifyProof\/TV1.cry'\n *\/\nverify_kzg_proof : Bytes48 -> Bytes32 -> Bytes32 -> Bytes48 -> Bit\nverify_kzg_proof commitment_bytes z_bytes y_bytes proof_bytes =\n    verify_kzg_proof_impl (bytes_to_kzg_commitment commitment_bytes)\n                          (bytes_to_bls_field z_bytes)\n                          (bytes_to_bls_field y_bytes)\n                          (bytes_to_kzg_proof proof_bytes)\n\n\/**\n * Return the Fiat-Shamir challenge required by the rest of the protocol.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#compute_challenge\n *\/\ncompute_challenge: Blob -> KZGCommitment -> BlsFieldElement\ncompute_challenge blob commitment = result where\n    degree_poly = groupBy`{8, 16} `(FIELD_ELEMENTS_PER_BLOB)\n    commitment_bytes = groupBy`{8} commitment\n    data = FIAT_SHAMIR_PROTOCOL_DOMAIN # degree_poly # blob # commitment_bytes\n    result = hash_to_bls_field data\n\n\/**\n * Given a blob, return the KZG proof that is used to verify it against the commitment.\n * This method does not verify that the commitment is correct with respect to `blob`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#compute_blob_kzg_proof\n *\/\ncompute_blob_kzg_proof: Blob -> Bytes48 -> KZGProof\ncompute_blob_kzg_proof blob commitment_bytes = proof where\n    commitment = bytes_to_kzg_commitment commitment_bytes\n    polynomial = blob_to_polynomial blob\n    evaluation_challenge = compute_challenge blob commitment\n    (proof, e) = compute_kzg_proof_impl polynomial evaluation_challenge\n\n\/**\n * Given a blob, return the KZG proof that is used to verify it against the commitment.\n * This method does not verify that the commitment is correct with respect to `blob`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#verify_blob_kzg_proof\n *\/\nverify_blob_kzg_proof: Blob -> Bytes48 -> Bytes48 -> Bit\nverify_blob_kzg_proof blob commitment_bytes proof_bytes =\n    verify_kzg_proof_impl commitment evaluation_challenge y proof where\n        commitment = bytes_to_kzg_commitment commitment_bytes\n        polynomial = blob_to_polynomial blob\n        evaluation_challenge = compute_challenge blob commitment\n        y = evaluate_polynomial_in_evaluation_form polynomial evaluation_challenge\n        proof = bytes_to_kzg_proof proof_bytes\n\n\n\/**\n * Verify multiple KZG proofs efficiently.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#verify_kzg_proof_batch\n * Add an additional assumption that k is represented with 64 bits.\n * This additional assumption is required by compute_powers\n *\/\nverify_kzg_proof_batch : {k} (fin k, 64 >= width k) => [k]KZGCommitment -> [k]BlsFieldElement -> [k]BlsFieldElement -> [k]KZGProof -> Bit\nverify_kzg_proof_batch commitments zs ys proofs = pairing_check points where\n    degree_poly = groupBy`{8, 8} `(FIELD_ELEMENTS_PER_BLOB)\n    num_commitments = groupBy`{8, 8} `(k)\n    data_1 = RANDOM_CHALLENGE_KZG_BATCH_DOMAIN # degree_poly # num_commitments\n    data_2 = [ c # z # y # p | c <- commitments | z <- zs | y <- ys | p <- proofs ]\n    data = data_1 # (groupBy`{8} (join data_2))\n    r = hash_to_bls_field data\n    r_powers = compute_powers`{k} r \n    proof_lincomb = g1_lincomb proofs r_powers\n    proof_z_lincomb = g1_lincomb proofs ([z * r_power | z <- zs | r_power <- r_powers])\n    C_minus_ys = [ g1_add (bytes48_to_G1 commitment) (g1_multi G1 ((`(BLS_MODULUS) - y) % `(BLS_MODULUS))) \n                    | commitment <- commitments | y <- ys ] \n    C_minus_y_as_KZGCommitments = [ g1_to_bytes48 x | x <- C_minus_ys ]\n    C_minus_y_lincomb = g1_lincomb C_minus_y_as_KZGCommitments r_powers\n    points = [((bytes48_to_G1 proof_lincomb), (g2_negate (bytes96_to_G2 (KZG_SETUP_G2_MONOMIAL@1)))),\n                            ((g1_add (bytes48_to_G1 C_minus_y_lincomb) (bytes48_to_G1 proof_z_lincomb)), G2)]\n\n\/**\n * Given a list of blobs and blob KZG proofs, verify that they correspond to the provided commitments.\n * Will return True if there are zero blobs\/commitments\/proofs.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#verify_blob_kzg_proof_batch\n * The input parameters are required to have the same length `k` and `k` is represented with 64 bits.\n * The second assumption is also required by `verify_kzg_proof_batch`.\n *\/\nverify_blob_kzg_proof_batch : {k} (fin k, 64 >= width k) => [k]Blob -> [k]Bytes48 -> [k]Bytes48 -> Bit\nverify_blob_kzg_proof_batch blobs commitments_bytes proofs_bytes = verify_kzg_proof_batch commitments evaluation_challenges ys proofs where\n    commitments = map bytes_to_kzg_commitment commitments_bytes\n    polynomials = map blob_to_polynomial blobs \n    evaluation_challenges = [ compute_challenge blob commitment | blob <- blobs | commitment <- commitments ] \n    ys = [ evaluate_polynomial_in_evaluation_form polynomial evaluation_challenge | polynomial <- polynomials | evaluation_challenge <- evaluation_challenges ]\n    proofs = [ bytes_to_kzg_proof proof_bytes | proof_bytes <- proofs_bytes]\n\n\/*\n * ======================\n * Test Vector Generators\n * ======================\n *\/\n\n\/**\n * This function is used to generate a random, but valid data `Blob`.\n *\/\nvalid_blob_generator : Blob -> Blob\nvalid_blob_generator blob = assert (blob != blob') \"error\" blob' where\n    x = [bytes | bytes <- (groupBy`{BYTES_PER_FIELD_ELEMENT} blob)]\n    y = map (\\b -> (join b)) x\n    y' = map (\\b -> b % `BLS_MODULUS) y\n    x' = [groupBy`{8} poly | poly <- y']\n    blob' = join x'\n\n\/**\n * This function is used to generate a random, valid Z bytes.\n *\/\nz_bytes_generator : Bytes32 -> Bytes32\nz_bytes_generator z = z\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsSerde.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the BLS serialization and deserialization functions in the Spec::BlsSerde module. Specifically, create properties that check: (1) decompress_G1 is the inverse of compress_G1 for all valid G1 points, (2) decompress_G2 is the inverse of compress_G2 for all valid G2 points, (3) key_validate correctly identifies valid and invalid compressed G1 points, and (4) fq2_modular_squareroot returns valid square roots or fails appropriately. Include tests for the provided example compressed points and edge cases such as the point at infinity."},{"role":"assistant","content":"```cryptol\n\/**\n * The module contains functions that perform BLS serialization and deserialization operations.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls\/point_compression.py\n * These functions are intended to match the corresponding py_ecc functions.\n *\/\nmodule Spec::BlsSerde where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::FQP\nimport Spec::BlsEC::G1\nimport Spec::BlsEC::GP\n\n\/**\n * Size of a G1 point\n *\/\ntype G1Bits = 384\n\n\/**\n * Serialized G1 point\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#custom-types\n *\/\ntype Bytes48 = [G1Bits]\n\n\/*\n * These are convenience values for working with the\n *  compressed point flags.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/constants.py#L12-L15\n *\/\nPOW_2_381 = 2^^381\nPOW_2_382 = 2^^382\nPOW_2_383 = 2^^383\n\n\/**\n * Compressed G1 point at infinity\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#constants\n *\n * Note: the name, though it is somewhat misleading, is chosen to match the Python spec.\n *\/\nG1_POINT_AT_INFINITY : Bytes48\nG1_POINT_AT_INFINITY = 0xc0 # zero\n\n\/**\n * Helper function for decompressing a G1 or G2 compresed point.\n *\n * The most-significant three bits of a G1 or G2 encoding should be masked away before\n * the coordinate(s) are interpreted.\n * These bits are used to unambiguously represent the underlying element.\n * The format: (c_flag, b_flag, a_flag, x)\n *  - c_flag: is '1' to indicated a compressed point, '0' otherwise.\n *  - b_flag: is '1' to indicate a point at infinity, '0' otherwise.\n *     - NOTE: the c_flag must also be set to indicate an intentionally\n *             compressed infinity point.\n *  - a_flag: is used to store the most significant bit of the y-coordinate.\n *  - x: is the x-coordinate of the point.\n *\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls\/point_compression.py#L43\n *\n * ```repl\n * :check get_flags (0xC0 # (zero:[384-8])) == (True, True, False)\n * :check get_flags (0xE0 # (zero:[384-8])) == (True, True, True)\n * ```\n * NOTE: `Bytes48 == [384]`\n *\/\nget_flags : Bytes48 -> (Bit, Bit, Bit)\nget_flags z = (c_flag, b_flag, a_flag) where\n    \/\/ The index operator '!0' as applied gives us the\n    \/\/   LSB which is what we want.\n    c_flag = ((z >> 383) && 1)!0  \/\/ The most significant bit\n    b_flag = ((z >> 382) && 1)!0  \/\/ The second-most significant bit\n    a_flag = ((z >> 381) && 1)!0  \/\/ The third-most significant bit\n\n\/**\n * Decompress the G1 compressed point\n *\n * Recovers x and y coordinates from the compressed point.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls\/point_compression.py#L80\n *\n* ```repl\n * :check decompress_G1 G1_POINT_AT_INFINITY == G1_INFINITY\n * :check decompress_G1 G1_2P_COMPRESSED == G1_2P\n * :check decompress_G1 G1_7P_COMPRESSED == G1_7P\n * ```\n *\/\ndecompress_G1 : Bytes48 -> G1Point\ndecompress_G1 z =\n    \/\/ c_flag == 1 indicates the compressed form\n    \/\/ MSB should be 1\n    if ~c_flag then\n        error \"decompress_G1: c_flag must be 1\"\n     | b_flag != isInfinity then\n        error \"b_flag should be 1\"\n     | b_flag then\n        \/\/ 3 MSBs should be b110\n        if a_flag then\n            error \"decompress_G1: a point at infinity should have a_flag == 0\"\n        else G1_INFINITY\n     \/\/ Else, not point at infinity\n     \/\/ 3 MSBs should be b100 or b101\n     | xBits >= q then\n        error \"decompress_G1: point value should be less than field modulus\"\n     | (y^^2) != (x^^3 + b) then\n        error \"The given point is not on G1: y^^2 = x^^3 + 4\"\n     \/\/ Choose the y whose leftmost bit is equal to the a_flag\n     | (((fromZ y) * 2) \/ q) != (bit_to_integer a_flag) then\n        { xCoord = x, yCoord = y'}\n     else\n        { xCoord = x, yCoord = y}\n     where\n        isInfinity = (z % POW_2_381) == 0\n        \/\/ We want to use the type Z Fq for all modular arithmetic, but\n        \/\/  we have to use Fq as a value which is not allowable with\n        \/\/  Z Fq, so we sometimes need to convert back and forth between\n        \/\/  Z Fq and Integer.\n        (c_flag, b_flag, a_flag) = get_flags z\n        xBits = (toInteger z) % POW_2_381\n        x = fromInteger xBits\n        q = `(Fq)\n        b = 4 : Z Fq \/\/ Our elliptic curve equation is y^^2 = x^^3 + 4\n        \/\/ Try solving y coordinate from the equation y^^2 = x^^3 + b using quadratic residue\n        y = pow_mod base exp\n        base = x^^3 + b\n        exp = ((q + 1) \/ 4) % q\n        y' = fromInteger (q - (fromZ y))\n\n\/**\n * Compress the G1 point\n *\n * Encodes x and y coordinates in the compressed point.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/point_compression.py#L58-L77\n *\n * ```repl\n * :check compress_G1 G1_INFINITY == G1_POINT_AT_INFINITY\n * :check compress_G1 G1_2P == G1_2P_COMPRESSED\n * :check compress_G1 G1_7P == G1_7P_COMPRESSED\n * ```\n *\/\ncompress_G1 : G1Point -> Bytes48\ncompress_G1 point =\n    if point == G1_INFINITY then\n        \/\/ Set c_flag = 1 and b_flag = 1. leave a_flag = x = 0\n        fromInteger (POW_2_383 + POW_2_382)\n    else\n        \/\/ Set c_flag = 1 and b_flag = 0\n        fromInteger (x + a_flag * POW_2_381 + POW_2_383)\n    where\n        \/\/ Record y's leftmost bit to the a_flag\n        x = fromZ point.xCoord\n        y = fromZ point.yCoord\n        q = toInteger `(Fq)\n        a_flag = (y * 2) \/ q\n\n\/**\n * Check the property that compression => decompression is the same point.\n * This check is performed by running random tests.\n * ```repl\n * :set tests=10000\n * :check check_compression_decompress_inverse\n * ```\n *\/\ncheck_compression_decompress_inverse : G1Point -> Bit\nproperty check_compression_decompress_inverse point = precondition ==> statement where\n    precondition = g1_is_valid_point point\n    statement = decompress_G1 (compress_G1 point) == point\n\n\/**\n * Make sure the compressed G1 point is valid, i.e. not infinity and in the subgroup.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/ciphersuites.py#L113\n * ```repl\n * :check key_validate G1_1P_COMPRESSED == True\n * \/\/ :error key_validate G1_INVALID_POINT_COMPRESSED \/\/ Cryptol cannot currently do this\n * ```\n * NOTE: I have manually checked that calling `key_validate` on an invalid compressed point\n *  fails with an error thrown. Unfortunately, there is not a way in the Cryptol REPL to\n *  say that I expect an error to be thrown.\n * NOTE: this repl test is slow (couple of seconds).\n *\/\nkey_validate : Bytes48 -> Bit\nkey_validate bytes =\n    if bytes == G1_POINT_AT_INFINITY then\n        False\n    else\n        subgroup_check point\n    where\n        point = decompress_G1 bytes\n\n\/**\n * Test point for the decompression function `bytes48_to_G1`\n *\/\nG1_INVALID_INFINITY_COMPRESSED : Bytes48\nG1_INVALID_INFINITY_COMPRESSED = c_flag + b_flag + a_flag where\n    c_flag = (1 << 383) \/\/ is compressed\n    b_flag = (1 << 382) \/\/ is infinity\n    a_flag = (1 << 381) \/\/ invalid a_flag when infinity\n\n\/**\n * Test point for the decompression function `bytes48_to_G1`\n *\/\nG1_INVALID_TO_BIG_COMPRESSED : Bytes48\nG1_INVALID_TO_BIG_COMPRESSED = c_flag + `(Fq) + 1 where\n    c_flag = (1 << 383) \/\/ is compressed\n\n\/**\n * Test point for the decompression function `bytes48_to_G1`\n *\/\nG1_INVALID_POINT_COMPRESSED : Bytes48\nG1_INVALID_POINT_COMPRESSED = c_flag + b_flag + a_flag + 13 where\n    c_flag = (1 << 383) \/\/ is compressed\n    b_flag = (0 << 382) \/\/ not infinity\n    a_flag = (1 << 381) \/\/ doesn't matter since invalid point\n\n\/**\n * Test point for the decompression function `bytes48_to_G1`\n *\/\nG1_1P_COMPRESSED : Bytes48\nG1_1P_COMPRESSED = c_flag + b_flag + a_flag + (toIntegral G1.xCoord) where\n    c_flag = (1 << 383) \/\/ is compressed\n    b_flag = (0 << 382) \/\/ not infinity\n    a_flag = (0 << 381) \/\/ because the MSB of G1.yCoord is '0'\n\n\/**\n * Test point for the decompression function `bytes48_to_G1`\n *\/\nG1_2P_COMPRESSED : Bytes48\nG1_2P_COMPRESSED = c_flag + b_flag + a_flag + (toIntegral G1_2P.xCoord) where\n    c_flag = (1 << 383) \/\/ is compressed\n    b_flag = (0 << 382) \/\/ not infinity\n    a_flag = (1 << 381) \/\/ because the MSB of G1_2P.yCoord is '1'\n\n\/**\n * Test point for the decompression function `bytes48_to_G1`\n *\/\nG1_3P_COMPRESSED : Bytes48\nG1_3P_COMPRESSED = c_flag + b_flag + a_flag + (toIntegral G1_3P.xCoord) where\n    c_flag = (1 << 383) \/\/ is compressed\n    b_flag = (0 << 382) \/\/ not infinity\n    a_flag = (0 << 381) \/\/ because the MSB of G1_3P.yCoord is '0'\n\n\/**\n * Test point for the decompression function `bytes48_to_G1`\n *\/\nG1_7P_COMPRESSED : Bytes48\nG1_7P_COMPRESSED = c_flag + b_flag + a_flag + (toIntegral G1_7P.xCoord) where\n    c_flag = (1 << 383) \/\/ is compressed\n    b_flag = (0 << 382) \/\/ not infinity\n    a_flag = (1 << 381) \/\/ because the MSB of G1_7P.yCoord is '0'\n\n\/**\n * Size of a G2 point\n *\/\ntype G2Bits = 768\n\n\/**\n * Serialized G2 point\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#custom-types\n *\/\ntype Bytes96 = [G2Bits]\n\n\/**\n * Compressed G2 point at infinity\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#constants\n *\n * Note: the name, though it is somewhat misleading, is chosen to match the Python spec.\n *\/\nG2_POINT_AT_INFINITY : Bytes96\nG2_POINT_AT_INFINITY = 0xc0 # zero\n\n\/**\n * Test point for the decompression function `bytes96_to_G2`\n *\/\nG2_2P_COMPRESSED : Bytes96\nG2_2P_COMPRESSED = c_flag + b_flag + a_flag + x_real + x_imag where\n    c_flag = (1 << 767) \/\/ is compressed\n    b_flag = (0 << 766) \/\/ not infinity\n    a_flag = (1 << 765) \/\/ because the MSB of G2_2P.yCoeffs.imag is '1'\n    x_real = (toIntegral (G2_2P.xCoeffs@0))\n    x_imag = (toIntegral (G2_2P.xCoeffs@1)) << 384\n\n\/**\n * Test point for the decompression function `bytes96_to_G2`\n *\/\nG2_3P_COMPRESSED : Bytes96\nG2_3P_COMPRESSED = c_flag + b_flag + a_flag + x_real + x_imag where\n    c_flag = (1 << 767) \/\/ is compressed\n    b_flag = (0 << 766) \/\/ not infinity\n    a_flag = (0 << 765) \/\/ because the MSB of G2_3P.yCoeffs.imag is '0'\n    x_real = (toIntegral (G2_3P.xCoeffs@0))\n    x_imag = (toIntegral (G2_3P.xCoeffs@1)) << 384\n\n\/**\n * Compress the G2 point\n *\n * Encodes x and y coordinates in the compressed point.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/point_compression.py#L145\n *\n * ```repl\n * :check compress_G2 G2_INFINITY == G2_POINT_AT_INFINITY\n * :check compress_G2 G2_2P == G2_2P_COMPRESSED\n * :check compress_G2 G2_3P == G2_3P_COMPRESSED\n * ```\n * The compressed point (z1, z2) has the bit order:\n *  z1: (c_flag1, b_flag1, a_flag1, x1)\n *  z2: (c_flag2, b_flag2, a_flag2, x2)\n *  where\n *  - c_flag1 is always set to 1\n *  - b_flag1 indicates infinity when set to 1\n *  - a_flag1 helps determine the y-coordinate when decompressing,\n *  - a_flag2, b_flag2, and c_flag2 are always set to 0\n *\/\ncompress_G2 : G2Point -> Bytes96\ncompress_G2 point =\n    if point == G2_INFINITY then\n        \/\/ Set c_flag = 1 and b_flag = 1. leave a_flag = x = 0\n        (fromInteger (POW_2_383 + POW_2_382)) # (zero:[G1Bits])\n    else\n        z1Bits + z2Bits\n    where\n        x_re = fromZ (point.xCoeffs@0)\n        x_im = fromZ (point.xCoeffs@1)\n        y_re = fromZ (point.yCoeffs@0)\n        y_im = fromZ (point.yCoeffs@1)\n        q = toInteger `(Fq)\n        \/\/ Record the leftmost bit of y_im to the a_flag1\n        \/\/ If y_im happens to be zero, then use the bit of y_re\n        a_flag1 = if y_im > 0 then (y_im * 2) \/ q else (y_re * 2) \/ q\n        \/\/ Imaginary part of x goes to z1, real part goes to z2\n        \/\/ c_flag1 = 1, b_flag1 = 0\n        z1 = x_im + a_flag1 * POW_2_381 + POW_2_383\n        z2 = x_re\n        z1Bits = (fromInteger z1) # (zero:[G1Bits])\n        z2Bits = (fromInteger z2)\n\n\/**\n * Decompress the G2 compressed point\n *\n * Recovers x and y coordinates from the compressed point.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/point_compression.py#L175\n *\n* ```repl\n * :check decompress_G2 G2_POINT_AT_INFINITY == G2_INFINITY\n * :check decompress_G2 G2_2P_COMPRESSED == G2_2P\n * :check decompress_G2 G2_3P_COMPRESSED == G2_3P\n * ```\n *\/\ndecompress_G2 : Bytes96 -> G2Point\ndecompress_G2 z =\n    \/\/ c_flag == 1 indicates the compressed form\n    \/\/ MSB should be 1\n    if ~c_flag1 then\n        error \"decompress_G2: c_flag1 must be 1\"\n     | b_flag1 != is_inf_pt then\n        error \"b_flag1 should be 1\"\n     | b_flag1 then\n        \/\/ 3 MSBs should be b110\n        if a_flag1 then\n            error \"decompress_G2: a point at infinity should have a_flag1 == 0\"\n        else G2_INFINITY\n     \/\/ Else, not point at infinity\n     \/\/ 3 MSBs should be b100 or b101\n     \/\/ Ensure that x1 is less than the field modulus.\n     | x1Bits >= q then\n        error \"decompress_G2: x1 value should be less than field modulus\"\n     \/\/ Ensure that z2 is less than the field modulus.\n     | z2 >= (fromInteger q) then\n        error \"decompress_G2: z2 value should be less than field modulus\"\n     \/\/ The check for y being invalid is in fq2_modular_squareroot\n     \/\/ Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1\n     \/\/ If y_im happens to be zero, then use the bit of y_re\n     | (y_im > 0) && condition1 then\n        { xCoeffs = x\n        , yCoeffs = (y ~* -1)\n        }\n     | (y_im == 0) && condition2 then\n        { xCoeffs = x\n        , yCoeffs = (y ~* -1)\n        }\n     else\n        { xCoeffs = x\n        , yCoeffs = y\n        }\n    where\n    is_inf_pt = ((z1 % POW_2_381) == 0) && (z2 == 0)\n    z1 = take`{G2Bits \/ 2} z\n    z2 = drop`{G2Bits \/ 2} z\n    (c_flag1, b_flag1, a_flag1) = get_flags z1\n    x1Bits = (toInteger z1) % POW_2_381\n    x1 = fromInteger x1Bits\n    q = `(Fq)\n    x2 = fromIntegral`{Fq} z2\n    \/\/ x1 is the imaginary part, x2 is the real part\n    x = [x2, x1]\n    y = fq2_modular_squareroot (x~^^3 ~+~ b2)\n    (y_re, y_im) = (fromZ (y@0), fromZ (y@1))\n    b2 = FQ2_B2\n    condition1 = ((y_im * 2) \/ q) != (bit_to_integer (a_flag1))\n    condition2 = ((y_re * 2) \/ q) != (bit_to_integer (a_flag1))\n\n\/**\n * Given value=x, returns the value y such that y^^2 % q == x,\n *  and errors if this is not possible. In cases where there are two solutions,\n *  the value with higher imaginary component is favored;\n *  if both solutions have equal imaginary component the value with higher real\n *  component is favored.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/point_compression.py#L123\n * ```repl\n * let y_squared = G2.xCoeffs~^^3 ~+~ FQ2_B2\n * :check ((fq2_modular_squareroot y_squared) ~* -1) == G2.yCoeffs\n * ```\n *\/\nfq2_modular_squareroot : Fq2 -> Fq2\nfq2_modular_squareroot value =\n    if elem check EVEN_EIGHTH_ROOTS_OF_UNITY then\n        if ((x1_im > x2_im) || ((x1_im == x2_im) && (x1_re > x2_re))) then x1 else x2\n    else\n        error \"Failed to find a modular squareroot\"\n    where\n        candidate_squareroot = value~^^((FQ2_ORDER + 8) \/ 16)\n        check = candidate_squareroot~^^2 ~\/~ value\n        candidate_rou_index = (find_eighth_root_of_unity_index check) \/ 2\n        x1 = candidate_squareroot ~\/~ (EIGHTH_ROOTS_OF_UNITY@candidate_rou_index)\n        x2 = fqp_neg x1\n        (x1_re, x1_im) = (fromZ (x1@0), fromZ (x1@1))\n        (x2_re, x2_im) = (fromZ (x2@0), fromZ (x2@1))\n\nFQ2_ONE = [1, 1]\nEIGHTH_ROOTS_OF_UNITY = [FQ2_ONE~^^((FQ2_ORDER * k) \/ 8) | k <- [0..7]]\nEVEN_EIGHTH_ROOTS_OF_UNITY = [EIGHTH_ROOTS_OF_UNITY@i | i <- [0, 2, 4, 6]]\n\n\/**\n * Find the index of the eighth root of unity.\n * When this function is called, we know that we've already found an even\n *  eighth root of unity, so we only check those.\n *\/\nfind_eighth_root_of_unity_index : Fq2 -> Integer\nfind_eighth_root_of_unity_index value =\n    sum [if value == rou then i else 0 | rou <- EVEN_EIGHTH_ROOTS_OF_UNITY | i <- [0, 2, 4, 6]]\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsHelpers.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the BLS helper functions in the Spec::BlsHelpers module. Include properties that check the modular inverse, division, power computations, multi-scalar multiplication, serialization\/deserialization of G1 and G2 points, and validation of KZG commitments and proofs against their expected mathematical properties and constraints."},{"role":"assistant","content":"```cryptol\n\/**\n * The module contains functions that perform BLS operations.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#bls12-381-helpers\n *\/\nmodule Spec::BlsHelpers where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::G1\nimport Spec::BlsEC::GP\nimport Spec::BlsSerde\n\n\/**\n * BLS field elements are 256-bits long.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#custom-types\n *\/\ntype BlsFieldSize = 256\ntype BlsFieldElement = [BlsFieldSize]\n\n\/**\n * Compute the modular inverse of x\n *  i.e. return y such that x * y % BLS_MODULUS == 1\n * Precondition: x != 0 BLS_MODULUS\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#bls_modular_inverse\n * NOTE: Cryptol can not perform exponentiation with negative exponents,\n *  we cannot just execute `x^^(-1) % BLS_MODULUS` like the Python spec does.\n * ```repl\n * :check bls_modular_inverse 1 == 1\n * :check bls_modular_inverse 2 == 0x39f6d3a994cebea4199cec0404d0ec02a9ded2017fff2dff7fffffff80000001\n * :check bls_modular_inverse 3 == 0x4d491a377113a8daccd13ab0066be558e27e6d5755543d54aaaaaaaa00000001\n * ```\n * NOTE: we just chose the values at \"random.\" Checked against: https:\/\/planetcalc.com\/3298\/.\n *\/\nbls_modular_inverse : BlsFieldElement -> BlsFieldElement\nbls_modular_inverse x = toIntegral (modular_inverse x') where\n    x' = fromIntegral`{BLS_MODULUS} x\n\n\/**\n * Divide two field elements: x by y\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#div\n * ```repl\n * :check bls_div 1 2 == 0x39f6d3a994cebea4199cec0404d0ec02a9ded2017fff2dff7fffffff80000001\n * :check bls_div 13 1 == 13\n * :check bls_div 57 13 == 0x1ac0b075a72457fcf8210a7802390a776218122813b0da27276276272762762c\n * ```\n * NOTE: we just chose the last value at \"random\"\n *\/\nbls_div : BlsFieldElement -> BlsFieldElement -> BlsFieldElement\nbls_div x y = toIntegral (div_mod x' y') where\n    x' = fromIntegral`{BLS_MODULUS} x\n    y' = fromIntegral`{BLS_MODULUS} y\n\n\/**\n * Return x to power of [0, n-1].\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#compute_powers\n * ```repl\n * let expected_powers = [1, 3, 3^^2, 3^^3, 3^^4, 3^^5, 3^^6, ((3^^7):BlsFieldElement)]\n * :check compute_powers`{8} 3 == expected_powers\n * :check compute_powers`{0} 3 == []\n * :check compute_powers`{1} 7 == [1:BlsFieldElement]\n * :check compute_powers`{2} 7 == [1:BlsFieldElement, 7]\n * ```\n *\/\ncompute_powers : {n} (fin n, width n <= 64) => BlsFieldElement -> [n]BlsFieldElement\ncompute_powers x\n    | n == 0 => []\n    | n == 1 => [1]\n    | n == 2 => [1, x]\n    | n > 2 => powers where\n        x' = fromIntegral`{BLS_MODULUS} x\n        powers' = [1] # [(powers'@i) * x' | i <- [0 .. n-2]]\n        powers = map toIntegral powers'\n\n\/**\n * Performs a multi-scalar multiplication between G1 `points` and `scalars`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#multi_exp\n * For the actual implementation,\n *   @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/85e2452301382a9d099df16f38deac8178355358\/tests\/core\/pyspec\/eth2spec\/utils\/bls.py#L262\n * NOTE: the Python multi_exp handles both G1 and G2 points, and just calls their\n *  corresponding `add` and `multiply` functions. This implementation is for G1 points only.\n * ```repl\n * :check g1_multi_exp`{1} [G1] [1] == G1\n * :check g1_multi_exp`{2} [G1, G1] [2, 3] == G1_5P\n * :check g1_multi_exp`{2} [G1_3P, G1_2P] [1, 2] == G1_7P\n * :check g1_multi_exp`{3} [G1_4P, G1_2P, G1_3P] [2, 3, 5] == g1_multi_exp`{2} [G1_5P, G1_7P] [3, 2]\n * ```\n *\/\ng1_multi_exp : {len} (fin len, len >= 1) => [len]G1Point -> [len]UInt256 -> G1Point\ng1_multi_exp points scalars = results!0 where\n    results = [G1_INFINITY] # [g1_add r (g1_multi_optimized p s) | r <- results | p <- points | s <- scalars]\n\n\/**\n * Deserialize the G1 bytes into a G1 point\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dcdcf25d8152cd078a9888eeddda4a550e1de009\/tests\/core\/pyspec\/eth2spec\/utils\/bls.py#L337\n * ```repl\n * :check bytes48_to_G1 G1_POINT_AT_INFINITY == G1_INFINITY\n * :check bytes48_to_G1 G1_2P_COMPRESSED == G1_2P\n * :check bytes48_to_G1 G1_7P_COMPRESSED == G1_7P\n * ```\n * NOTE: We're not testing any of the invalid points since they throw runtime errors,\n *  and Cryptol does not have a way to expect that. One can manually test to verify\n *  these errors are thrown.\n *\/\nbytes48_to_G1 : Bytes48 -> G1Point\nbytes48_to_G1 bytes = decompress_G1 bytes\n\n\/**\n * Serialize the G1 point into G1 bytes\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dcdcf25d8152cd078a9888eeddda4a550e1de009\/tests\/core\/pyspec\/eth2spec\/utils\/bls.py#L315\n * ```repl\n * :check g1_to_bytes48 G1_INFINITY == G1_POINT_AT_INFINITY\n * :check g1_to_bytes48 G1_2P == G1_2P_COMPRESSED\n * :check g1_to_bytes48 G1_7P == G1_7P_COMPRESSED\n * ```\n *\/\ng1_to_bytes48 : G1Point -> Bytes48\ng1_to_bytes48 point = compress_G1 point\n\n\/**\n * Deserialize the G2 bytes into a G2 point\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dcdcf25d8152cd078a9888eeddda4a550e1de009\/tests\/core\/pyspec\/eth2spec\/utils\/bls.py#L337\n * ```repl\n * :check bytes96_to_G2 G2_POINT_AT_INFINITY == G2_INFINITY\n * :check bytes96_to_G2 G2_2P_COMPRESSED == G2_2P\n * :check bytes96_to_G2 G2_3P_COMPRESSED == G2_3P\n * ```\n * NOTE: We're not testing any of the invalid points since they throw runtime errors,\n *  and Cryptol does not have a way to expect that. One can manually test to verify\n *  these errors are thrown.\n *\/\nbytes96_to_G2 : Bytes96 -> G2Point\nbytes96_to_G2 bytes = decompress_G2 bytes\n\n\/**\n * Serialize the G2 point into G2 bytes\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dcdcf25d8152cd078a9888eeddda4a550e1de009\/tests\/core\/pyspec\/eth2spec\/utils\/bls.py#L315\n * ```repl\n * :check g2_to_bytes96 G2_INFINITY == G2_POINT_AT_INFINITY\n * :check g2_to_bytes96 G2_2P == G2_2P_COMPRESSED\n * :check g2_to_bytes96 G2_3P == G2_3P_COMPRESSED\n * ```\n *\/\ng2_to_bytes96 : G2Point -> Bytes96\ng2_to_bytes96 point = compress_G2 point\n\n\/**\n * A KZG commitment is just a G1 point\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#custom-types\n *\/\ntype KZGCommitment = Bytes48\n\n\/**\n * BLS multiscalar multiplication in G1. This can be naively implemented using double-and-add.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#g1_lincomb\n * NOTE: we don't need to check for non-equal lengths for `points` and `scalars`,\n *  because our type parameter `n` enforces that for us.\n * NOTE: the `points` being passed in are compressed G1 points.\n * ```repl\n * :check g1_lincomb [] [] == G1_POINT_AT_INFINITY\n * :check g1_lincomb`{1} [G1_1P_COMPRESSED] [1] == G1_1P_COMPRESSED\n * :check g1_lincomb`{2} [G1_1P_COMPRESSED, G1_1P_COMPRESSED] [2, 5] == G1_7P_COMPRESSED\n * :check g1_lincomb`{3} [G1_2P_COMPRESSED, G1_2P_COMPRESSED, G1_1P_COMPRESSED] [1, 1, 3] == G1_7P_COMPRESSED\n * :check g1_lincomb`{3} [G1_3P_COMPRESSED, G1_2P_COMPRESSED, G1_1P_COMPRESSED] [1, 2, 0] == G1_7P_COMPRESSED\n * ```\n *\/\ng1_lincomb : {n} (fin n) => [n]KZGCommitment -> [n]BlsFieldElement -> KZGCommitment\ng1_lincomb points scalars\n    | n == 0 => G1_POINT_AT_INFINITY\n    | n > 0 => g1_to_bytes48 result where\n        points_g1 = [bytes48_to_G1 point | point <- points]\n        result = g1_multi_exp`{n} points_g1 scalars\n\n\/**\n * BLS Primitive root of unity.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#constants\n *\/\nPRIMITIVE_ROOT_OF_UNITY : Z BLS_MODULUS\nPRIMITIVE_ROOT_OF_UNITY = 7\n\n\/**\n * Compute the roots of unity for the `order`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#compute_roots_of_unity\n * Precondition: `(BLS_MODULUS - 1) % order == 0`\n * Assertion: `order == n`\n *\/\ncompute_roots_of_unity : {n} (fin n, width n <= 64) => UInt64 -> [n]BlsFieldElement\ncompute_roots_of_unity order = assert (order == `n) \"order must be equal to n\" result where\n        order' = toInteger order\n        root_of_unity = pow_mod PRIMITIVE_ROOT_OF_UNITY ((`(BLS_MODULUS) - 1) \/ order')\n        root_of_unity' = toIntegral root_of_unity\n        result = compute_powers`{n} root_of_unity'\n\n\/**\n * Bytes used to encode a commitment.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#constants\n *\/\ntype BYTES_PER_COMMITMENT = 48\n\n\/**\n * Bytes used to encode a proof.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#constants\n *\/\ntype BYTES_PER_PROOF = 48\n\n\/**\n * Bytes used to encode a BLS scalar field element.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#constants\n *\/\ntype BYTES_PER_FIELD_ELEMENT = 32\n\n\/**\n * The bytes of a BLS scalar field element.\n *\/\ntype Bytes32 = [BYTES_PER_FIELD_ELEMENT][8]\n\n\/**\n * Convert untrusted bytes to a trusted and validated BLS scalar field element.\n * This function does not accept inputs greater than the BLS modulus.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#bytes_to_bls_field\n * ```repl\n * let bytes = [0x73,0xed,0xa7,0x53,0x29,0x9d,0x7d,0x48,0x33,0x39,0xd8,0x08,0x09,0xa1,0xd8,0x05,0x53,0xbd,0xa4,0x02,0xff,0xfe,0x5b,0xfe,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00]\n * let field_element = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000000\n * :check bytes_to_bls_field bytes == field_element\n * ```\n *\/\nbytes_to_bls_field : Bytes32 -> BlsFieldElement\nbytes_to_bls_field bytes = assert (field_element < `(BLS_MODULUS)) error_msg field_element where\n    field_element = join bytes \/\/ Crytol is big endian\n    error_msg = \"BLS scalar field element must be less than modulus\"\n\n\/**\n * Convert a BLS scalar field element to bytes.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#bls_field_to_bytes\n *\/\nbls_field_to_bytes : BlsFieldElement -> Bytes32 \nbls_field_to_bytes value = groupBy`{8} value\n\n\/**\n * Perform BLS validation required by the types `KZGProof` and `KZGCommitment`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#validate_kzg_g1\n * ```repl\n * :check validate_kzg_g1 G1_1P_COMPRESSED\n * \/\/ :error key_validate G1_INVALID_POINT_COMPRESSED \/\/ Cryptol cannot currently do this\n * ```\n * NOTE: I have manually checked that calling `key_validate` on an invalid compressed point\n *  fails with an error thrown. Unfortunately, there is not a way in the Cryptol REPL to\n *  say that I expect an error to be thrown.\n * NOTE: this repl test is slow (couple of seconds).\n *\/\nvalidate_kzg_g1 : Bytes48 -> Bit\nvalidate_kzg_g1 b =\n    if b == G1_POINT_AT_INFINITY then True\n    else key_validate b\n\n\/**\n * Convert untrusted bytes into a trusted and validated `KZGCommitment`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#bytes_to_kzg_commitment\n * ```repl\n * :check (bytes_to_kzg_commitment G1_1P_COMPRESSED) == G1_1P_COMPRESSED\n * ```\n * NOTE: this repl test is slow (couple of seconds).\n *\/\nbytes_to_kzg_commitment : Bytes48 -> KZGCommitment\nbytes_to_kzg_commitment b =\n    assert (validate_kzg_g1 b) \"validate_kzg_g1 failed\" b\n\n\/**\n * Same as for `KZGCommitment`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#custom-types\n *\/\ntype KZGProof = Bytes48\n\n\/**\n * Convert untrusted bytes into a trusted and validated `KZGProof`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#bytes_to_kzg_proof\n  * ```repl\n * :check (bytes_to_kzg_proof G1_1P_COMPRESSED) == G1_1P_COMPRESSED\n * ```\n * NOTE: this repl test is slow (couple of seconds).\n *\/\nbytes_to_kzg_proof : Bytes48 -> KZGProof\nbytes_to_kzg_proof b =\n    assert (validate_kzg_g1 b) \"validate_kzg_g1 failed\" b\n\n\/**\n * Unit tests for `g1_lincomb`.\n * ```repl\n * :check test_compute_roots_of_unity\n * ```\n *\/\ntest_compute_roots_of_unity : Bit\nproperty test_compute_roots_of_unity =\n    compute_roots_of_unity`{4} 4 == expected_roots where\n    expected_roots =\n        [ 0x0000000000000000000000000000000000000000000000000000000000000001\n        , 0x00000000000000008d51ccce760304d0ec030002760300000001000000000000\n        , 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000000\n        , 0x73eda753299d7d47a5e80b39939ed33467baa40089fb5bfefffeffff00000001\n        ]\n\n\n\/**\n * Hash `data` and convert the output to a BLS scalar field element.\n * The output is not uniform over the BLS field.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#hash_to_bls_field\n * TODO: Temporarily set to always return 0; need to use SHA2-256\n *\/\nhash_to_bls_field: {n} (fin n, n >= 1) => [n][8] -> BlsFieldElement\nhash_to_bls_field data = 0\n\n\/**\n * The two constants FIAT_SHAMIR_PROTOCOL_DOMAIN and RANDOM_CHALLENGE_KZG_BATCH_DOMAIN\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#blob\n *\/\nFIAT_SHAMIR_PROTOCOL_DOMAIN : [16][8]\nFIAT_SHAMIR_PROTOCOL_DOMAIN = \"FSBLOBVERIFY_V1_\" : [16][8]\nRANDOM_CHALLENGE_KZG_BATCH_DOMAIN : [16][8]\nRANDOM_CHALLENGE_KZG_BATCH_DOMAIN = \"RCKZGBATCH___V1_\" : [16][8]\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/Permutations.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the functions in the Spec::Permutations module. Specifically, create properties that prove: (1) is_power_of_two_bit returns true only for powers of two; (2) reverse_bits is an involution (applying it twice returns the original value) for various bit lengths; (3) reverse_bits and reverse_bits_limited are equivalent for 64-bit inputs; and (4) bit_reversal_permutation is an involution on sequences. Include proofs that cover relevant input ranges and edge cases as indicated in the module comments."},{"role":"assistant","content":"```cryptol\n\/*\n * The functions in this module are derived from the consensus-specs.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#helper-functions\n *\/\nmodule Spec::Permutations where\n\nimport Common::Utils\n\n\/**\n * Check if `value` is a power of two integer.\n * Return `1:[1]` if true and `0:[1]` otherwise.\n * NOTE: We use the `Utils::bit_to_bool` function because SAW cannot\n *  convert the `Bit` type internally to an LLVM integer type.\n *\/\nis_power_of_two : {n} (fin n, n >= 1) => [n] -> [1]\nis_power_of_two value = bit_to_bool (is_power_of_two_bit value)\n\n\/**\n * Check if `value` is a power of two integer.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#is_power_of_two\n *\/\nis_power_of_two_bit : {n} (fin n, n >= 1) => [n] -> Bit\nis_power_of_two_bit value = (value > 0) && ((value && (value - 1)) == 0)\n\n\/**\n * Reverse the bits of an integer of length `n`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#reverse_bits\n * NOTE: The Python spec only reverses the low-order bits\n * ```repl\n * :check reverse_bits`{16, 16} 0x18C3 == 0xC318\n * :check reverse_bits`{16, 16} 0x00AA == 0x5500\n * :check reverse_bits`{16, 8} 0x00A5 == 0x00A5\n * ```\n * NOTE: we just chose these values at \"random\"\n *\/\nreverse_bits : {n, order_bit_length} (fin n, n >= 1, order_bit_length >= 1, order_bit_length <= n)\n    => [n] -> [n]\nreverse_bits value = zero # reverse (drop`{n - order_bit_length} value)\n\n\/**\n * Reverse the low-order bits of a 64-bit integer.\n * This function matches the `reverse_bits_limited` function in c-kzg\n * @see https:\/\/github.com\/ethereum\/c-kzg-4844\/blob\/main\/src\/common\/utils.c#L84\n *\/\nreverse_bits_limited : [64] -> [64] -> [64]\nreverse_bits_limited order value = (reverse value) >> unused_bit_len where\n    unused_bit_len = 64 - lg2 order\n\n\/**\n * Return the bit-reversed permutation, which is an involution (inverts itself).\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#bit_reversal_permutation\n * Standard algorithm: https:\/\/en.wikipedia.org\/wiki\/Bit-reversal_permutation\n * ```repl\n * let val = [0x18, 0xC3, 0xD5, 0x02, 0x40, 0xAB, 0xC3, 0x18]\n * let expected_permutation = [0x18, 0x40, 0xd5, 0xc3, 0xc3, 0xab, 0x02, 0x18]\n * let permuted_val = bit_reversal_permutation`{8, 8} val\n * :check permuted_val == expected_permutation\n * :check bit_reversal_permutation`{8, 8} permuted_val == val\n * ```\n *\/\nbit_reversal_permutation : {size, len} (fin size, size >= 1, len >= 2, size >= width (len - 1))\n    => [len][size] -> [len][size]\nbit_reversal_permutation sequence =\n    [sequence@(reverse_bits`{size, width (len - 1)} i) | i <- [0 .. (len-1)]]\n\n\/*\n *  ==========\n *  Properties\n *  ==========\n *\/\n\n\/**\n * Function `is_power_of_two_bit` should be true for all powers of two.\n * ```repl\n * :prove check_is_power_of_two\n * ```\n * NOTE: We'll just prove up to 2^^4096 --- that seems plenty and is still fast.\n *\/\nproperty check_is_power_of_two = all is_power_of_two_bit`{4096} [ 2^^n | n <- [0 .. 4096-1]]\n\n\/**\n * Property: calling `reverse_bits` twice on an value should return that value.\n * Assumes the same bit size of the input and the same desired low-order bits.\n * ```repl\n * :prove check_reverse_bits_involution`{256, 8}\n * :prove check_reverse_bits_involution`{256, 16}\n * :prove check_reverse_bits_involution`{256, 32}\n * :prove check_reverse_bits_involution`{256, 64}\n * :prove check_reverse_bits_involution`{256, 128}\n * :prove check_reverse_bits_involution`{256, 256}\n * ```\n *\/\ncheck_reverse_bits_involution : {n, order_bit_length} (fin n, n >= 1, order_bit_length >= 1, order_bit_length <= n)\n    => [n] -> Bit\nproperty check_reverse_bits_involution val = precondition ==> statement where\n    precondition = lg2 val < `order_bit_length\n    statement = (reverse_bits`{n, order_bit_length} (reverse_bits`{n, order_bit_length} val)) == val\n\n\/**\n * Property: Both implementations for \"reverse_bits\" are equivalent for 64-bit values.\n * ```repl\n * :prove check_reverse_bits_equiv`{64}\n * ```\n *\/\ncheck_reverse_bits_equiv : {order_bit_length} (order_bit_length >= 1, order_bit_length <= 64)\n    => [64] -> [64] -> Bit\nproperty check_reverse_bits_equiv order val = precondition ==> statement where\n    precondition = lg2 order == `order_bit_length\n    statement = reverse_bits`{64, order_bit_length} val == reverse_bits_limited order val\n\n\/**\n * Property: calling `bit_reversal_permutation` twice on an value should return that value.\n * ```repl\n * :prove check_bit_reversal_permutation_involution`{256, 8}\n * :prove check_bit_reversal_permutation_involution`{256, 16}\n * :prove check_bit_reversal_permutation_involution`{256, 32}\n * :prove check_bit_reversal_permutation_involution`{256, 64}\n * :prove check_bit_reversal_permutation_involution`{256, 128}\n * :prove check_bit_reversal_permutation_involution`{256, 256}\n * ```\n *\/\ncheck_bit_reversal_permutation_involution : {size, len} (fin size, size >= 1, len >= 2, size >= width (len - 1))\n    => [len][size] -> Bit\nproperty check_bit_reversal_permutation_involution val =\n    (bit_reversal_permutation`{size, len} (bit_reversal_permutation`{size, len} val)) == val\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Common\/ModArith.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the modular arithmetic functions in the Common::ModArith module. Include properties that check: 1) fromIntegral and toIntegral are inverses modulo n; 2) xgcd correctly computes gcd and B\u00e9zout coefficients satisfying a*s + b*t = gcd(a,b); 3) multinv returns the correct multiplicative inverse modulo m or zero if none exists; 4) modular_inverse computes the modular inverse consistent with multinv; 5) div_mod correctly divides elements in the modular field; and 6) pow_mod correctly computes modular exponentiation. Ensure the properties cover edge cases and respect the documented preconditions."},{"role":"assistant","content":"```cryptol\n\/*\n * This module contains helper functions related to modular arithmetic operations.\n *\/\nmodule Common::ModArith where\n\n\/**\n * Convert from a fixed size bit type to a `Z` type.\n * ```repl\n * :check (fromIntegral`{13} (3:[384])) == (3 : Z 13)\n * :check (fromIntegral`{13} (14:[384])) == (1 : Z 13)\n * :check (fromIntegral`{13} (13:[384])) == (0 : Z 13)\n * ```\n *\/\nfromIntegral : {n, m} (fin n, n >= 1, fin m, m >= 1) => [m] -> Z n\nfromIntegral value = fromInteger (toInteger value)\n\n\/**\n * Convert from a `Z` type to a fixed size bit type.\n * ```repl\n * :check (toIntegral`{m=384} (3 : Z 13) == (3:[384]))\n * ```\n *\/\ntoIntegral : {n, m} (fin n, n >= 1, fin m, m >= 1) => Z n -> [m]\ntoIntegral value = fromInteger (fromZ value)\n\n\/**\n * Calculates the gcd and Bezout coefficients,\n *   using the Extended Euclidean Algorithm (recursive).\n *   (Source: https:\/\/extendedeuclideanalgorithm.com\/code)\n * NOTE: 's' and 't' are used for the B\u00e9zout coefficients,\n *   that satisfy the equation `a*s + b*t = gcd(a,b)`.\n *   `s1` and `t1` are the previous computed coefficients.\n *   `s2` and `t2` are the current computed coefficients.\n * ```repl\n * :check xgcd 7 5 1 0 0 1 == (1, -2, 3)\n * ```\n *\/\nxgcd : Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> (Integer, Integer, Integer)\nxgcd a b s1 s2 t1 t2 =\n    if b == 0 then\n        (abs (a), 1, 0)\n    \/\/ if r == 0, then b will be the gcd and\n    \/\/    s2, t2 the Bezout coefficients\n    else if r == 0 then\n        (abs (b), s2, t2)\n    else\n        xgcd b r s2 s3 t2 t3\n    where\n        q = a \/ b\n        r = a - q * b\n        s3 = s1 - q * s2\n        t3 = t1 - q * t2\n\n\/**\n * Calculates the multiplicative inverse of a number 'x' mod 'm',\n *  using the Extended Euclidean Algorithm. If 'x' does not have a\n *  multiplicative inverse mod 'm', then return 0.\n *  (Source: https:\/\/extendedeuclideanalgorithm.com\/code)\n * ```repl\n * :check multinv 3 7 == 5\n * :check multinv 88831 319 == 167\n * ```\n *\/\nmultinv : Integer -> Integer -> Integer\nmultinv x m =\n    \/\/ 'b' only has a multiplicative inverse if the 'gcd' is 1\n    if gcd == 1\n    then t % m\n    else 0\n    \/\/ Get the 'gcd' and the second Bezout coefficient 't' from\n    \/\/  the Extended Euclidean Algorithm. Note that 's' is unused.\n    \/\/  Default values for the last four parameters are standard.\n    where (gcd, s, t) = xgcd m x 1 0 0 1\n\n\/**\n * Compute the modular inverse of x\n *  i.e. return y such that x * y % n == 1\n * Precondition: x != 0 mod n\n * ```repl\n * :check modular_inverse`{319} (fromInteger 7492) == 177\n * :check modular_inverse`{319} (fromInteger (-3)) == 106\n * ```\n * NOTE: we just chose the values at \"random.\" Checked against: https:\/\/planetcalc.com\/3298\/.\n *\/\nmodular_inverse : {n} (fin n, n >= 1) => Z n -> Z n\nmodular_inverse x = fromInteger (multinv (fromZ x) `n)\n\n\/**\n * Divide two field elements: x by y\n * ```repl\n * :check div_mod (3 : Z 319) (fromInteger 7492) == 212\n * :check div_mod (3 : Z 319) (fromInteger (-7492)) == 107\n * :check div_mod (3 : Z 319) 0 == 0\n * ```\n *\/\ndiv_mod : {n} (fin n, n >= 1) => Z n -> Z n -> Z n\ndiv_mod x y = x * (modular_inverse y)\n\n\/**\n * Exponentiation in the specified modulo field `n`.\n * @see https: * ```repl\n * :check pow_mod (3 : Z 7) 2 == 2\n * :check pow_mod`{2} (fromInteger 1) 18 == 1\n * :check pow_mod`{3} (0 : Z 3) 5 == 0\n *\/\npow_mod : {n} (fin n, n >= 1) => Z n -> Integer -> Z n\npow_mod base exp = base ^^ exp\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Common\/Utils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the conversion functions in the Common::Utils module, including bit_to_bool, bool_to_bit, and bit_to_integer. Ensure the properties cover all input cases and demonstrate that these functions are inverses where applicable and correctly map between Bit, [1], and Integer types."},{"role":"assistant","content":"```cryptol\n\/*\n * This module contains helper functions unrelated to the consensus-specs.\n *\/\nmodule Common::Utils where\n\ntype BYTE_WIDTH = 8\n\ntype UInt64 = [64]\n\ntype UInt256 = [256]\n\n\/**\n * Convert a `Bit` to a 1-bit value.\n * We use this function because SAW cannot convert\n *  the `Bit` type internally to an LLVM integer type.\n * ```repl\n * :check bit_to_bool True == 1\n * :check bit_to_bool False == 0\n * ```\n *\/\nbit_to_bool : Bit -> [1]\nbit_to_bool b = if b then 1 else 0\n\n\/**\n * Convert a 1-bit value to a `Bit`.\n * ```repl\n * :check bool_to_bit 1 == True\n * :check bool_to_bit 0 == False\n * ```\n *\/\nbool_to_bit : [1] -> Bit\nbool_to_bit b = if b == 1 then True else False\n\n\/**\n * Convert an Integral value of 'n' bits to a `Bit`.\n * ```repl\n * :check bit_to_integer True == 1\n * :check bit_to_integer False == 0\n * ```\n *\/\nbit_to_integer : Bit -> Integer\nbit_to_integer b = if b then 1 else 0\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/FQP.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the algebraic properties of the polynomial extension field operations defined in the Spec::BlsEC::FQP module. Specifically, include properties to prove commutativity of addition and multiplication, the equivalence of multiplication by two and addition doubling, non-commutativity of subtraction except when operands are equal, equivalence of squaring via multiplication and exponentiation, and commutativity of equality. Use the provided types and operations on FQP n, Fq2, and Fq12 elements."},{"role":"assistant","content":"```cryptol\n\/**\n * This module provides support for polynomial extension fields.\n * Specifically, we need to support Fq2 and Fq12.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L204\n *\/\nmodule Spec::BlsEC::FQP where\n\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::Poly(poly_extended_euclidean)\n\n\/**\n * A polynomial field extension type contains a list of\n *  coefficients which are elements of Fq.\n *\/\ntype FQP n = [n](Z Fq)\n\n\/**\n * A G2 point is comprised of two Fq2 elements, or sets of coefficients, each of degree two.\n * Each element is comprised of a real and imaginary coeffsicient.\n *\/\ntype Fq2 = FQP 2\n\n\/**\n * A G12 point is comprised of two Fq12 elements, or sets of coefficients, each of degree twelve.\n *\/\ntype Fq12 = FQP 12\n\n\/**\n * The modulus coefficients for the quadratic extension field Fq2.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_properties.py#L30\n *\/\nFQ2_MODULUS_COEFFICIENTS : Fq2\nFQ2_MODULUS_COEFFICIENTS = [1, 0]\n\n\/**\n * The modulus coefficients for the twelfth extension field Fq12.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_properties.py#L31\n *\/\nFQ12_MODULUS_COEFFICIENTS : Fq12\nFQ12_MODULUS_COEFFICIENTS = [2, 0, 0, 0, 0, 0, -2, 0, 0, 0, 0, 0]\n\n\/**\n * Addition of two sets of coefficients.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L232\n * ```repl\n * :check G2_y ~+~ G2_x == G2_y_plus_x\n * :check G12_y ~+~ G12_x == G12_y_plus_x\n * :check G12_x ~*~ G12_x == G12_xSquared\n * :check G12_x ~*~ G12_x ~*~ G12_x == G12_xCubed\n * ```\n *\/\n(~+~) : {n} (fin n, n >= 1) => FQP n -> FQP n -> FQP n\n(~+~) coeffs1 coeffs2 = [c1i + c2i | c1i <- coeffs1 | c2i <- coeffs2]\n\n\/**\n * Subtraction of two sets of coefficients.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L240\n * ```repl\n * :check G2_y ~-~ G2_x == G2_y_minus_x\n * :check G12_y ~-~ G12_x == G12_y_minus_x\n * ```\n *\/\n(~-~) : {n} (fin n, n >= 1) => FQP n -> FQP n -> FQP n\n(~-~) coeffs1 coeffs2 = [c1i - c2i | c1i <- coeffs1 | c2i <- coeffs2]\n\n\/**\n * Multiplication of two sets of coefficients.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L251\n * ```repl\n * :check G2_x ~*~ G2_x == G2_xSquared\n * :check G2_x ~*~ G2_x ~*~ G2_x == G2_xCubed\n * ```\n *\/\n(~*~) : {n} (fin n, n <= 12, n >= 2) => FQP n -> FQP n -> FQP n\n(~*~) coeffs1 coeffs2 = reduce_while b modulus_coeffs (2 * `(n) - 1) where\n    b = poly_multi coeffs1 coeffs2\n\nreduce_while : {a, n} (fin n, n <= 12, n >= 2, fin a, a == 2 * n - 1) => [a](Z Fq) -> [n](Z Fq) -> Integer -> [n](Z Fq)\nreduce_while b mod_coeffs len =\n    if len == `(n) then take`{n} b\n    else reduce_while b' mod_coeffs (len - 1)\n    where\n        top = b@(len-1)\n        exp = len - `(n) - 1\n        b' = [compute bj j | bj <- b | j <- [0 .. (a-1)]]\n        compute bj j =\n            if (j >= exp) && (j <= exp + `(n) - 1) then\n                bj - (top * (mod_coeffs@(j-exp)))\n            else bj\n\n\/**\n * Compute the initial polynomial multiplication.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L253\n * ```repl\n * :check poly_multi [2, 3] [5, 7] == [10, 29, 21]\n * let expected = [8,22,39,87,130,149,133,153,233,278,178,188,276,239,207,125,94,88,51,35,41,28,30]\n * :check poly_multi [2,3,3,1,2,5,6,1,2,5,3,5] [4,5,6,25,12,1,4,6,2,1,2,6] == expected\n * ```\n *\/\npoly_multi : {n, a} (fin n, 2 * n >= 1, fin a, a == 2 * n - 1) => FQP n -> FQP n -> FQP a\npoly_multi l r =\n    if (all (\\x -> x == 0) l) then zero\n    else ((scalar_mult (l@0) r) # zero) ~+~ (((poly_multi (l << 1) r) # zero) >> 1)\n    where scalar_mult x ys = map ((*) x) ys\n\n\/**\n * Multiplication of an integer and a set of coefficients.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L249\n * ```repl\n * :check G2_x ~* 2 == G2_xDoubled\n * :check 2 *~ G2_x == G2_xDoubled\n * ```\n *\/\n(*~) : {n} (fin n, n >= 1) => Integer -> FQP n -> FQP n\n(*~) value coeffs = [value' * ci | ci <- coeffs] where\n    value' = fromInteger value\n\n(~*) : {n} (fin n, n >= 1) => FQP n -> Integer -> FQP n\n(~*) coeffs value = value *~ coeffs\n\n\/**\n * Division of two sets of coefficients.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L280\n * ```repl\n * :check G2_x ~\/~ G2_x == [1, 0]\n * :check G2_y ~\/~ G2_x == G2_y_div_mod_x\n * :check G12_x ~\/~ G12_x == [1] # zero\n * :check G12_y ~\/~ G12_x == G12_y_div_mod_x\n * ```\n *\/\n(~\/~) : {n} (fin n, n <= 12, n >= 2) => FQP n -> FQP n -> FQP n\n(~\/~) coeffs1 coeffs2 = coeffs1 ~*~ (fqp_inv coeffs2)\n\n\/**\n * Compute the inverse of a Fq2 element.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L302\n * ```repl\n * :check fqp_inv G2_x == G2_xInverse\n * :check fqp_inv (fqp_inv G2_x) == G2_x\n * :check fqp_inv G2_y == G2_yInverse\n * :check fqp_inv (fqp_inv G2_y) == G2_y\n * :check fqp_inv G12_x == G12_xInverse\n * :check fqp_inv (fqp_inv G12_x) == G12_x\n * ```\n *\/\nfqp_inv : {n} (fin n, n <= 12, n >= 2) => FQP n -> FQP n\nfqp_inv coeffs = poly_extended_euclidean`{n+1} lm low hm high where\n    lm = [1] # n_zeros\n    hm = [0] # n_zeros\n    low = coeffs # [0]\n    high = modulus_coeffs # [1]\n    n_zeros = repeat`{n} 0\n\n\/**\n * The modulus coefficients of the polynomial extension fields.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_properties.py#L30-L31\n *\/\nmodulus_coeffs : {n} (fin n, n <= 12, n >= 2) => FQP n\nmodulus_coeffs =\n    \/\/ The appending by 'zero' is to help the Cryptol type checker.\n    \/\/ It actually evaluates to an empty bitvector.\n    if `(n) == 2 then FQ2_MODULUS_COEFFICIENTS # zero\n     | `(n) == 12 then take`{n} FQ12_MODULUS_COEFFICIENTS\n    else zero\n\n\/**\n * Exponentiation of a set of coeffsicients by a scalar.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L291\n * ```repl\n * :check G2_x~^^0 == [1, 0]\n * :check G2_x~^^1 == G2_x\n * :check G2_x~^^2 == G2_xSquared\n * :check G2_x~^^3 == G2_xCubed\n * :check G12_x~^^0 == [1] # zero\n * :check G12_x~^^1 == G12_x\n * :check G12_x~^^2 == G12_xSquared\n * :check G12_x~^^3 == G12_xCubed\n * ```\n *\/\n(~^^) : {n} (fin n, n <= 12, n >= 2) => FQP n -> Integer -> FQP n\n(~^^) coeffs scalar =\n    if scalar == 0 then\n        [1] # zero\n     | scalar == 1 then\n        coeffs\n     | scalar % 2 == 0 then\n        (coeffs ~*~ coeffs) ~^^ (scalar \/ 2)\n     else\n        ((coeffs ~*~ coeffs) ~^^ (scalar \/ 2)) ~*~ coeffs\n\n\/**\n * Negate the set of coefficients.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L355\n * ```repl\n * :check fqp_neg (fqp_neg G2_x) == G2_x\n * :check fqp_neg (fqp_neg G12_x) == G12_x\n * ```\n *\/\nfqp_neg : {n} (fin n, n >= 1) => FQP n -> FQP n\nfqp_neg coeffs = [-ci | ci <- coeffs]\n\n\/**\n * Equality of two sets of coefficients.\n * ```repl\n * :check G2_x ~==~ G2_x\n * :check G12_x ~==~ G12_x\n * ```\n *\/\n(~==~) : {n} (fin n, n >= 1) => FQP n -> FQP n -> Bit\n(~==~) coeffs1 coeffs2 = and [c1i == c2i | c1i <- coeffs1 | c2i <- coeffs2]\n\n\/**\n * X coefficients for generator for twisted curve over Fq2.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_curve.py#L44\n *\/\nG2_x : Fq2\nG2_x = [ 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n       , 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758\n       ]\n\n\/**\n * Y coefficients for generator for twisted curve over Fq2.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_curve.py#L44\n *\/\nG2_y : Fq2\nG2_y = [ 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n       , 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582\n       ]\n\n\/**\n * G2_x + G2_y. Computed using py_ecc.\n *\/\nG2_y_plus_x : Fq2\nG2_y_plus_x =\n    [ 2337851671874758553755193637188231783190898931008430971079287309306138512109538745297216704607199160594256266651065\n    , 3986698009736546165718461780529819517744210518930240528684401185085612201771633997414458852832304583413319107585340\n    ]\n\n\/**\n * G2_x - G2_y. Computed using py_ecc.\n *\/\nG2_y_minus_x : Fq2\nG2_y_minus_x =\n    [ 1632449532699825317380915405166111493410839025422880490639470020826550940638108691550521503919468808688732414044745\n    , 1870818876469786139193731976758160400328152687915953296697712908626373202724554996990127355752626211775441853413611\n    ]\n\n\/**\n * G2_x squared. Computed using py_ecc.\n *\/\nG2_xSquared : Fq2\nG2_xSquared =\n    [ 1997086149283677522843833040423074048426674013790346437450988890364808601048656494674186077061491944389142492819694\n    , 3113349101563180256960455051481244719726682130931247942710023183696345206282753395927436272834951815958170074391256\n    ]\n\n\/**\n * G2_x cubed. Computed using py_ecc.\n *\/\nG2_xCubed : Fq2\nG2_xCubed =\n    [ 3341065098200961989598748404381324054605449840948293400785922068969583005812936621662354076014412578129291257715484\n    , 2133050398774337206222816300118221327418763981033055222570091459262312519047975404484651902003138703421962555090218\n    ]\n\n\/**\n * G2_x multipled by two. Computed using py_ecc.\n *\/\nG2_xDoubled : Fq2\nG2_xDoubled =\n    [ 705402139174933236374278232022120289780059905585550480439817288479587571471430053746695200687730351905523852606320\n    , 2115879133266760026524729803771659117416057831014287231986688276459238999047079000424331497079678371637877254171729\n    ]\n\n\/**\n * G2_y \/ G2_x. Computed using py_ecc.\n *\/\nG2_y_div_mod_x : Fq2\nG2_y_div_mod_x =\n    [ 2645964961145567287646174681515652840605182444869364111679220104429646387260976011822898928226591963576020240426619\n    , 3656195751079888906744826605664754595376734064625263022628224160781596224005157110042338963344577397675474692059176\n    ]\n\n\/**\n * G2_x inverse. Computed using py_ecc.\n *\/\nG2_xInverse : Fq2\nG2_xInverse =\n    [ 1223514866584400226619392018844575446040489926980124362465220784014275923982521236729115905530146470033177964357563\n    , 3495453419063574139925455551631318136524378768480668459768684498547208492074727172949503320416899422709399085629096\n    ]\n\n\/**\n * G2_y inverse. Computed using py_ecc.\n *\/\nG2_yInverse : Fq2\nG2_yInverse =\n    [ 3828301281232776537393462114696026453820925117135598932697882187079936548530569912296382199133331215710911400309693\n    , 1450185639544495128598198914056492809111071767684112182252696543466687995844478949870392653614483391964324409513904\n    ]\n\n\/**\n * X coefficients for generator for the curve over Fq12.\n *\/\nG12_x : Fq12\nG12_x =\n    [ 0, 0, 0, 0\n    , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n    , 0, 0, 0, 0, 0\n    , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n    , 0\n    ]\n\n\/**\n * Y coefficients for generator for the curve over Fq12.\n *\/\nG12_y : Fq12\nG12_y =\n    [ 0, 0, 0\n    , 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n    , 0, 0, 0, 0, 0\n    , 1472406309213353956798468635167385199506877017588472562248853724925831900559844855499883907296819622485916638215732\n    , 0, 0\n    ]\n\n\/**\n * G12_y + G12_x. Computed using py_ecc.\n *\/\nG12_y_plus_x : Fq12\nG12_y_plus_x =\n    [ 0, 0, 0\n    , 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n    , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n    , 0, 0, 0, 0\n    , 1472406309213353956798468635167385199506877017588472562248853724925831900559844855499883907296819622485916638215732\n    , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n    , 0\n    ]\n\n\/**\n * G12_x - G12_y. Computed using py_ecc.\n *\/\nG12_y_minus_x : Fq12\nG12_y_minus_x =\n    [ 0, 0, 0\n    , 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n    , 3649708485634200775230650709724844011666852867146232645112149491884237864755122837569340028785150488085132346256627\n    , 0, 0, 0, 0\n    , 1472406309213353956798468635167385199506877017588472562248853724925831900559844855499883907296819622485916638215732\n    , 2649187917893293847525729476364543410508662633597071726112325855098110880974216161662606647748774743095332354028488\n    , 0\n    ]\n\n\/**\n * G12_x squared. Computed using py_ecc.\n *\/\nG12_xSquared : Fq12\nG12_xSquared =\n    [ 0, 0\n    , 1997086149283677522843833040423074048426674013790346437450988890364808601048656494674186077061491944389142492819694\n    , 0, 0, 0, 0, 0\n    , 558131476139751367058311005529085335650004058570450752629517146665768302617048450626625097886729935784513790785781\n    , 0, 0, 0\n    ]\n\n\/**\n * G12_x cubed. Computed using py_ecc.\n *\/\nG12_xCubed : Fq12\nG12_xCubed =\n    [ 3341065098200961989598748404381324054605449840948293400785922068969583005812936621662354076014412578129291257715484\n    , 0, 0, 0, 0, 0\n    , 3398402205508355001729823773604352792963539889981388796224142831270396407108357255853836542123378726684229921247154\n    , 0, 0, 0, 0, 0\n    ]\n\n\/**\n * G12_x \/ G12_y. Computed using py_ecc.\n *\/\nG12_y_div_mod_x : Fq12\nG12_y_div_mod_x =\n    [ 0, 0, 0, 0, 0\n    , 2645964961145567287646174681515652840605182444869364111679220104429646387260976011822898928226591963576020240426619\n    , 0, 0, 0, 0, 0\n    , 2506320172577994506258220874942502955664217219847453398140531096237990743617509481331063832123500549068674362096172\n    ]\n\n\/**\n * G12_x inverse. Computed using py_ecc.\n *\/\nG12_xInverse : Fq12\nG12_xInverse =\n    [ 0, 0\n    , 1730471002742493480111726292949161466072993978438463788028594421591099082398631928222300214242262711361673151288254\n    , 0, 0, 0, 0, 0\n    , 3495453419063574139925455551631318136524378768480668459768684498547208492074727172949503320416899422709399085629096\n    , 0, 0, 0\n    ]\n\n\/**\n * Verify that addition is commutative.\n * ```repl\n * :prove fqp_addition_commutative`{2}\n * :prove fqp_addition_commutative`{12}\n * ```\n *\/\nfqp_addition_commutative : {n} (fin n, n >= 1) => FQP n -> FQP n -> Bit\nproperty fqp_addition_commutative a b =\n    a ~+~ b == b ~+~ a\n\n\/**\n * Verify that multiplication is commutative.\n * ```repl\n * :set prover=cvc5\n * :prove fqp_multiplication_commutative`{2}\n * :prove fqp_multiplication_commutative`{12}\n * ```\n * NOTE: this proof works for Z3 v4.13 but not v4.8. Takes >50 seconds.\n *  It is much faster (~5 seconds) with cvc5.\n *\/\nfqp_multiplication_commutative : {n} (fin n, n <= 12, n >= 2) => FQP n -> FQP n -> Bit\nproperty fqp_multiplication_commutative a b =\n    a ~*~ b == b ~*~ a\n\n\/**\n * Verify that multiplying by two is same as addition doubling an element.\n * ```repl\n * :prove fqp_multi_by_two_is_double`{2}\n * :prove fqp_multi_by_two_is_double`{12}\n * ```\n *\/\nfqp_multi_by_two_is_double : {n} (fin n, n <= 12, n >= 2) => FQP n -> Bit\nproperty fqp_multi_by_two_is_double a =\n    a ~* 2 == a ~+~ a\n\n\/**\n * Verify that subtraction is not commutative,\n *   unless both coefficients are equal.\n * ```repl\n * :prove fqp_subtraction_not_commutative`{2}\n * :prove fqp_subtraction_not_commutative`{12}\n * ```\n *\/\nfqp_subtraction_not_commutative : {n} (fin n, n >= 1) => FQP n -> FQP n -> Bit\nproperty fqp_subtraction_not_commutative a b = precondition ==> statement where\n    precondition = a != b\n    statement = a ~-~ b != b ~-~ a\n\n\/**\n * Verify that squaring is that same using either multiplication or exponentiation.\n * ```repl\n * :prove fqp_squared_equiv`{2}\n * :prove fqp_squared_equiv`{12}\n * ```\n *\/\nfqp_squared_equiv : {n} (fin n, n <= 12, n >= 2) => FQP n -> Bit\nproperty fqp_squared_equiv c =\n    c~^^2 == c ~*~ c\n\n\/**\n * Verify that equality is commutative.\n * ```repl\n * :prove fqp_equality_commutative`{2}\n * :prove fqp_equality_commutative`{12}\n * ```\n *\/\nfqp_equality_commutative : {n} (fin n, n >= 1) => FQP n -> FQP n -> Bit\nproperty fqp_equality_commutative a b =\n    a ~==~ b == b ~==~ a\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/G1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the elliptic curve point operations defined in the Spec::BlsEC::G1 module. Include properties to check that g1_double correctly doubles a point, g1_add correctly adds two points (including identity and doubling cases), and that g1_multi and g1_multi_optimized produce equivalent results for scalar multiplication. Also, specify properties to verify that g1_is_valid_point correctly identifies points on the curve and that subgroup_check correctly determines subgroup membership. Use the provided test points and constants for your specifications."},{"role":"assistant","content":"```cryptol\n\/**\n * This module contains functions that perform ECC Point operations.\n * These functions are specific to the BLS curve, and specifically G1.\n *\n * The Deneb Python specs use the py_ecc library for the same operations.\n * This module's functions are based off of py_ecc.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py\n *\/\nmodule Spec::BlsEC::G1 where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\n\n\/**\n * G1 elliptic curve point.\n *\n * NOTE: by using the Z type, all modular arithmetic\n *  is handled automatically and there is no potential\n *  for any overflow errors.\n *\/\ntype G1Point =\n    { xCoord : Z Fq\n    , yCoord : Z Fq\n    }\n\n\/**\n * Representation of G1 point at infinity.\n *\n * NOTE: (0,0) isn't actually the point at infinity, but since we\n *  can't use enums here and (0, 0) is not on the curve, it's an\n *  acceptable substitute.\n *\/\nG1_INFINITY : G1Point\nG1_INFINITY =\n    { xCoord = 0\n    , yCoord = 0\n    }\n\n\/**\n * Generator for curve over Fq.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_curve.py#L35\n *\/\nG1 : G1Point\nG1 =\n    { xCoord = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\n    , yCoord = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\n    }\n\n\/**\n * Determines whether or not the given point is on the G1 curve.\n * The point must satisfy the EC equation: y^^2 = x^^3 + 4\n * ```repl\n * :check g1_is_valid_point G1\n * :check g1_is_valid_point G1_2P\n * :check g1_is_valid_point G1_3P\n * :check g1_is_valid_point G1_4P\n * :check g1_is_valid_point G1_5P\n * :check g1_is_valid_point G1_6P\n * :check g1_is_valid_point G1_7P\n * ```\n *\/\ng1_is_valid_point : G1Point -> Bit\ng1_is_valid_point point =\n    y^^2 - x^^3 == 4\n    where\n        x = point.xCoord\n        y = point.yCoord\n\n\/**\n * Double a G1 point\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L84\n * ```repl\n * :check g1_double G1 == G1_2P\n * :check g1_double G1_2P == G1_4P\n * :check g1_double G1_3P == G1_6P\n * :check g1_double (g1_double G1) == G1_4P\n * ```\n *\/\ng1_double : G1Point -> G1Point\ng1_double point = newPoint where\n    x = point.xCoord\n    y = point.yCoord\n    m = div_mod (3 * x^^2) (2 * y)\n    newX = m^^2 - (2 * x)\n    newY = m * (x - newX) - y\n    newPoint =\n        { xCoord = newX\n        , yCoord = newY\n        }\n\n\/**\n * Add two G1 points\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L95\n * ```repl\n * :check g1_add G1 G1_INFINITY == G1\n * :check g1_add G1_INFINITY G1_3P == G1_3P\n * :check g1_add G1_INFINITY G1_INFINITY == G1_INFINITY\n * :check g1_add G1 G1 == G1_2P\n * :check g1_add G1 G1_2P == G1_3P\n * :check g1_add G1 G1_4P == G1_5P\n * :check g1_add G1_3P G1_2P == G1_5P\n * :check g1_add G1_2P G1_4P == G1_6P\n * ```\n *\/\ng1_add : G1Point -> G1Point -> G1Point\ng1_add p1 p2 =\n    if p1 == G1_INFINITY then p2\n     | p2 == G1_INFINITY then p1\n     | p1 == p2 then g1_double p1\n     else\n        { xCoord = newX\n        , yCoord = newY\n        }\n    where\n    x1 = p1.xCoord\n    y1 = p1.yCoord\n    x2 = p2.xCoord\n    y2 = p2.yCoord\n    m = div_mod (y2 - y1) (x2 - x1)\n    newX = m^^2 - x1 - x2\n    newY = m * (x1 - newX) - y1\n\n\/**\n * Multiply a G1 point by a scalar\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L114\n * The optimization of running scalar multiplication on the inverse and then using the\n *  inverse of `y` is described here: https:\/\/www.mdpi.com\/2227-7390\/12\/6\/881, Section 4, second case\n * ```repl\n * :check g1_multi_optimized G1 0 == G1_INFINITY\n * :check g1_multi_optimized G1 1 == G1\n * :check g1_multi_optimized G1 6 == G1_6P\n * :check g1_multi_optimized G1 (`(BLS_MODULUS)-1) == g1_multi G1 (`(BLS_MODULUS)-1)\n * :check g1_multi_optimized G1 `(BLS_MODULUS) == g1_multi G1 `(BLS_MODULUS)\n * :check g1_multi_optimized G1 (`(BLS_MODULUS)+1) == g1_multi G1 (`(BLS_MODULUS)+1)\n * ```\n *\/\ng1_multi_optimized : G1Point -> UInt256 -> G1Point\ng1_multi_optimized point scalar =\n    if scalar >= `(BLS_MODULUS) then g1_multi point scalar\n     \/\/ For the special case of scalars < BLS_MODULUS and\n     \/\/  >= `(BLS_MODULUS) \/ 2, we can compute the inverse\n     \/\/  and then inverse the coordinantes.\n     | scalar >= `(BLS_MODULUS) \/ 2 then {xCoord = x, yCoord = y}\n     else g1_multi point scalar\n    where\n        inverse_scalar = `(BLS_MODULUS) - scalar\n        inverse_point = g1_multi point inverse_scalar\n        y = fromInteger (`(Fq) - (fromZ inverse_point.yCoord))\n        x = inverse_point.xCoord\n\n\/**\n * Multiply a G1 point by a scalar\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L114\n * ```repl\n * :check g1_multi G1 0 == G1_INFINITY\n * :check g1_multi G1 1 == G1\n * :check g1_multi G1 6 == G1_6P\n * :check g1_multi G1_2P 3 == g1_multi G1_3P 2\n * ```\n *\/\ng1_multi : G1Point -> UInt256 -> G1Point\ng1_multi point scalar =\n    if scalar == 0 then G1_INFINITY\n        | scalar == 1 then point\n        \/\/ If scalar is even, just double\n        | scalar % 2 == 0 then g1_multi (g1_double point) (scalar \/ 2)\n        \/\/ If scalar is odd, double and add\n        else g1_add ((g1_multi (g1_double point) (scalar \/ 2))) point\n\n\/**\n * Randomize testing to show the two g1_multi functions are equivalent.\n * ```repl\n * :check g1_multis_equiv\n * ```\n * This takes a couple of minutes.\n *\/\ng1_multis_equiv : UInt256 -> Bit\nproperty g1_multis_equiv scalar =\n    g1_multi G1 scalar == g1_multi_optimized G1 scalar\n\n\/**\n * Determine whether or not the G1 point is a member of the subgroup.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/g2_primitives.py#L34\n * ```repl\n * :check subgroup_check G1_INFINITY == False\n * :check subgroup_check G1 == True\n * :check subgroup_check G1_2P == True\n * ```\n * NOTE: these repl tests are very slow (~5 seconds).\n *\/\nsubgroup_check : G1Point -> Bit\nsubgroup_check point = G1_INFINITY != g1_multi point `(BLS_MODULUS)\n\n\/*\n * ===========\n * Test Points\n * ===========\n *\/\n\n\/\/ All of these points were generated from: http:\/\/www.christelbach.com\/eccalculator.aspx\n\nG1_2P : G1Point\nG1_2P =\n    { xCoord = 838589206289216005799424730305866328161735431124665289961769162861615689790485775997575391185127590486775437397838\n    , yCoord = 3450209970729243429733164009999191867485184320918914219895632678707687208996709678363578245114137957452475385814312\n    }\n\nG1_3P : G1Point\nG1_3P =\n    { xCoord = 1527649530533633684281386512094328299672026648504329745640827351945739272160755686119065091946435084697047221031460\n    , yCoord = 487897572011753812113448064805964756454529228648704488481988876974355015977479905373670519228592356747638779818193\n    }\n\nG1_4P : G1Point\nG1_4P =\n    { xCoord = 1940386630589042756063486004190165295069185078823041184114464346315715796897349637805088429212932248421554491972448\n    , yCoord = 3114296198575988357603748217414299058449850389627766458803888308926785677746356789015548793127623382888106859156543\n    }\n\nG1_5P : G1Point\nG1_5P =\n    { xCoord = 2601793266141653880357945339922727723793268013331457916525213050197274797722760296318099993752923714935161798464476\n    , yCoord = 3498096627312022583321348410616510759186251088555060790999813363211667535344132702692445545590448314959259020805858\n    }\n\nG1_6P : G1Point\nG1_6P =\n    { xCoord = 1063080548659463434646774310890803636667161539235054707411467714858983518890075240133758563865893724012200489498889\n    , yCoord = 3669927104170827068533340245967707139563249539898402807511810342954528074138727808893798913182606104785795124774780\n    }\n\nG1_7P : G1Point\nG1_7P =\n    { xCoord = 3872473689207892378470335395114902631176541028916158626161662840934315241539439160301564344905260612642783644023991\n    , yCoord = 2547806390474846378491145127515427451279430889101277169890334737406180277792171092197824251632631671609860505999900\n    }\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/GP.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the elliptic curve group operations defined in the Spec::BlsEC::GP module. Include properties to check that: (1) points are valid on the curve using g2_is_valid_point and g12_is_valid_point; (2) negation is involutive (negating twice returns the original point); (3) point doubling and addition satisfy expected algebraic identities; (4) scalar multiplication behaves correctly for edge cases (0, 1) and respects distributivity; (5) subgroup membership checks are accurate for known points. Ensure the properties cover both G2Point and G12Point types and use the provided test points for validation."},{"role":"assistant","content":"```cryptol\n\/**\n * These functions are specific to the BLS curve and specifically the\n *  ECC points with coordinates in the polynomial extension fields Fq2 and Fq12.\n *\n * The Deneb Python specs has an option to use the py_ecc library for these operations.\n * This module's functions are based off of py_ecc.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py\n *\/\nmodule Spec::BlsEC::GP where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::FQP\n\n\/**\n * The order of Fq2.\n * @see https: *\/\nFQ2_ORDER : Integer\nFQ2_ORDER = `(Fq)^^2 - 1\n\n\/**\n * Twisted curve over Fq2.\n * @see https: *\/\nFQ2_B2 : Fq2\nFQ2_B2 = [4, 4]\n\n\/**\n * Extension curve over Fq12; same b value as over Fq\n * @see https: *\/\nFQ12_B12 : Fq12\nFQ12_B12 = [4] # zero\n\ntype GPPoint n =\n    { xCoeffs : FQP n\n    , yCoeffs : FQP n\n    }\n\n\/**\n * G2 elliptic curve point.\n * This is the quadratic extension field (Fq2) for the field Fq (G1).\n * @see https: *\n * NOTE: by using the Z type, all modular arithmetic\n *  is handled automatically and there is no potential\n *  for any overflow errors.\n *\/\ntype G2Point = GPPoint 2\n\n\/**\n * G12 elliptic curve point.\n * This is the twefth extension field (Fq12) for the field Fq (G1).\n * @see https: *\n * NOTE: by using the Z type, all modular arithmetic\n *  is handled automatically and there is no potential\n *  for any overflow errors.\n *\/\ntype G12Point = GPPoint 12\n\n\/**\n * Representation of G2 point at infinity.\n *\n * NOTE: ((0,0),(0,0)) isn't actually the point at infinity, but since we\n *  can't use enums here and ((0,0),(0,0)) is not on the curve, it's an\n *  acceptable substitute.\n *\/\nG2_INFINITY : G2Point\nG2_INFINITY =\n    { xCoeffs = zero\n    , yCoeffs = zero\n    }\n\n\/**\n * Representation of G12 point at infinity.\n *\n * NOTE: this isn't actually the point at infinity, but since we\n *  can't use enums here and all zeros is not on the curve, it's an\n *  acceptable substitute.\n *\/\nG12_INFINITY : G12Point\nG12_INFINITY =\n    { xCoeffs = zero\n    , yCoeffs = zero\n    }\n\n\/**\n * Generator for twisted curve over Fq2.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_curve.py#L44\n *\/\nG2 : G2Point\nG2 =\n    { xCoeffs =\n        [ 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758\n        ]\n    , yCoeffs =\n        [ 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n        , 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582\n        ]\n    }\n\n\/**\n * Generator for curve over Fq12.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_curve.py#L44\n *\/\nG12 : G12Point\nG12 =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 0, 0, 0, 0, 0\n        , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n        , 0, 0, 0, 0, 0\n        , 1472406309213353956798468635167385199506877017588472562248853724925831900559844855499883907296819622485916638215732\n        , 0, 0\n        ]\n    }\n\n\/**\n * Determines whether or not the given point is on the curve.\n * The point must satisfy the EC equation: y^^2 = x^^3 + 4\n * NOTE: `4 == b`, we will represent `b` differently per curve.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_curve.py#L71\n * ```repl\n * :check g2_is_valid_point G2\n * :check g2_is_valid_point G2_2P\n * :check g2_is_valid_point G2_3P\n * :check g2_is_valid_point G2_6P\n * :check g12_is_valid_point G12\n * :check g12_is_valid_point G12_2P\n * :check g12_is_valid_point G12_3P\n * :check g12_is_valid_point G12_6P\n * ```\n *\/\ngp_is_valid_point : {n} (fin n, n <= 12, n >= 2) => FQP n -> GPPoint n -> Bit\ngp_is_valid_point b point =\n    (y~^^2) ~-~ (x~^^3) == b\n    where\n        x = point.xCoeffs\n        y = point.yCoeffs\n\ng2_is_valid_point : G2Point -> Bit\ng2_is_valid_point point = gp_is_valid_point FQ2_B2 point\n\ng12_is_valid_point : G12Point -> Bit\ng12_is_valid_point point = gp_is_valid_point FQ12_B12 point\n\n\/**\n * Negate a point.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_curve.py#L135\n * ```repl\n * :check g2_negate G2 == G2_Negated\n * :check g2_negate (g2_negate G2) == G2\n * :check g12_negate G12 == G12_Negated\n * :check g12_negate (g12_negate G12) == G12\n * ```\n *\/\ngp_negate : {n} (fin n, n >= 1) => GPPoint n -> GPPoint n\ngp_negate point = newPoint where\n    x = point.xCoeffs\n    y = point.yCoeffs\n    newPoint =\n        { xCoeffs = x\n        , yCoeffs = fqp_neg y\n        }\n\ng2_negate : G2Point -> G2Point\ng2_negate point = gp_negate point\n\ng12_negate : G12Point -> G12Point\ng12_negate point = gp_negate point\n\n\/**\n * Double a point.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L84\n * ```repl\n * :check g2_double G2 == G2_2P\n * :check g2_double G2_3P == G2_6P\n * :check g12_double G12 == G12_2P\n * :check g12_double G12_3P == G12_6P\n * ```\n *\/\ngp_double : {n} (fin n, n <= 12, n >= 2) => GPPoint n -> GPPoint n\ngp_double point = newPoint where\n    x = point.xCoeffs\n    y = point.yCoeffs\n    m = (3 *~ (x~^^2)) ~\/~ (2 *~ y)\n    newX = (m~^^2) ~-~ (2 *~ x)\n    newY = (m ~*~ (x ~-~ newX)) ~-~ y\n    newPoint =\n        { xCoeffs = newX\n        , yCoeffs = newY\n        }\n\ng2_double : G2Point -> G2Point\ng2_double point = gp_double point\n\ng12_double : G12Point -> G12Point\ng12_double point = gp_double point\n\n\/**\n * Add two points.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L95\n * ```repl\n * :check g2_add G2 G2 == G2_2P\n * :check g2_add G2 G2_2P == G2_3P\n * :check g2_add G2_3P G2_3P == G2_6P\n * :check g12_add G12 G12 == G12_2P\n * :check g12_add G12 G12_2P == G12_3P\n * :check g12_add G12_3P G12_3P == G12_6P\n * ```\n *\/\ngp_add : {n} (fin n, n <= 12, n >= 2) => GPPoint n -> GPPoint n -> GPPoint n -> GPPoint n\ngp_add infinity p1 p2 =\n    if p1 == infinity then p2\n     | p2 == infinity then p1\n     | p1 == p2 then gp_double p1\n     else\n        { xCoeffs = newX\n        , yCoeffs = newY\n        }\n    where\n    x1 = p1.xCoeffs\n    y1 = p1.yCoeffs\n    x2 = p2.xCoeffs\n    y2 = p2.yCoeffs\n    m = (y2 ~-~ y1) ~\/~ (x2 ~-~ x1)\n    newX = m~^^2 ~-~ x1 ~-~ x2\n    newY = m ~*~ (x1 ~-~ newX) ~-~ y1\n\ng2_add : G2Point -> G2Point -> G2Point\ng2_add p1 p2 = gp_add G2_INFINITY p1 p2\n\ng12_add : G12Point -> G12Point -> G12Point\ng12_add p1 p2 = gp_add G12_INFINITY p1 p2\n\n\/**\n * Multiply a point by a scalar.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L114\n * ```repl\n * :check g2_multi G2 0 == G2_INFINITY\n * :check g2_multi G2 1 == G2\n * :check g2_multi G2 2 == G2_2P\n * :check g2_multi G2 3 == G2_3P\n * :check g2_multi G2 6 == G2_6P\n * :check g2_multi G2_2P 3 == g2_multi G2_3P 2\n * :check g12_multi G12 0 == G12_INFINITY\n * :check g12_multi G12 1 == G12\n * :check g12_multi G12 2 == G12_2P\n * :check g12_multi G12 3 == G12_3P\n * :check g12_multi G12 6 == G12_6P\n * :check g12_multi G12_2P 3 == g12_multi G12_3P 2\n * ```\n *\/\ngp_multi : {n} (fin n, n <= 12, n >= 2) => GPPoint n -> GPPoint n -> UInt256 -> GPPoint n\ngp_multi infinity point scalar =\n    if scalar == 0 then infinity\n        | scalar == 1 then point\n        \/\/ If scalar is even, just double\n        | scalar % 2 == 0 then gp_multi infinity (gp_double point) (scalar \/ 2)\n        \/\/ If scalar is odd, double and add\n        else gp_add infinity ((gp_multi infinity (gp_double point) (scalar \/ 2))) point\n\ng2_multi : G2Point -> UInt256 -> G2Point\ng2_multi point scalar = gp_multi G2_INFINITY point scalar\n\ng12_multi : G12Point -> UInt256 -> G12Point\ng12_multi point scalar = gp_multi G12_INFINITY point scalar\n\n\/**\n * Multiply a G12 point by a scalar\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/main\/py_ecc\/bls12_381\/bls12_381_curve.py#L114\n * The optimization of running scalar multiplication on the inverse and then using the\n *  inverse of `y` is described here: https:\/\/www.mdpi.com\/2227-7390\/12\/6\/881, Section 4, second case\n * We just have to take the inverse of every `y` coefficient.\n * ```repl\n * :check g2_multi_optimized G2 0 == g2_multi G2 0\n * :check g2_multi_optimized G2 1 == g2_multi G2 1\n * :check g2_multi_optimized G2 6 == g2_multi G2 6\n * :check g2_multi_optimized G2 (`(BLS_MODULUS)-1) == g2_multi G2 (`(BLS_MODULUS)-1)\n * :check g2_multi_optimized G2 `(BLS_MODULUS) == g2_multi G2 `(BLS_MODULUS)\n * :check g2_multi_optimized G2 (`(BLS_MODULUS)+1) == g2_multi G2 (`(BLS_MODULUS)+1)\n * :check g12_multi_optimized G12 0 == g12_multi G12 0\n * :check g12_multi_optimized G12 1 == g12_multi G12 1\n * :check g12_multi_optimized G12 6 == g12_multi G12 6\n * :check g12_multi_optimized G12 (`(BLS_MODULUS)-1) == G12_NEG_ONE\n * :check g12_multi_optimized G12 (`(BLS_MODULUS)-2) == G12_NEG_TWO\n * :check g12_multi_optimized G12 (`(BLS_MODULUS)-3) == G12_NEG_THREE\n * ```\n *\/\ngp_multi_optimized : {n} (fin n, n <= 12, n >= 2) => GPPoint n -> GPPoint n -> UInt256 -> GPPoint n\ngp_multi_optimized infinity point scalar =\n    if scalar >= `(BLS_MODULUS) then gp_multi infinity point scalar\n     \/\/ For the special case of scalars < BLS_MODULUS and\n     \/\/  >= `(BLS_MODULUS) \/ 2, we can compute the inverse\n     \/\/  and then inverse the coordinantes.\n     | scalar >= `(BLS_MODULUS) \/ 2 then {xCoeffs = xcoeffs, yCoeffs = ycoeffs}\n     else gp_multi infinity point scalar\n    where\n        inverse_scalar = `(BLS_MODULUS) - scalar\n        inverse_point = gp_multi infinity point inverse_scalar\n        ycoeffs = map (\\y -> fromInteger (`(Fq) - (fromZ y))) inverse_point.yCoeffs\n        xcoeffs = inverse_point.xCoeffs\n\ng2_multi_optimized : G2Point -> UInt256 -> G2Point\ng2_multi_optimized point scalar = gp_multi_optimized G2_INFINITY point scalar\n\ng12_multi_optimized : G12Point -> UInt256 -> G12Point\ng12_multi_optimized point scalar = gp_multi_optimized G12_INFINITY point scalar\n\n\/**\n * Determine whether or not the G2 point is a member of the subgroup.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls\/g2_primitives.py#L34\n * ```repl\n * :check g2_subgroup_check G2_INFINITY == False\n * :check g2_subgroup_check G2 == True\n * :check g2_subgroup_check G2_2P == True\n * ```\n * NOTE: these repl tests are very slow (~10 seconds each for the last two).\n *\/\ng2_subgroup_check : G2Point -> Bit\ng2_subgroup_check point = G2_INFINITY != (g2_multi point `(BLS_MODULUS))\n\n\/**\n * \"Twist\" a point in Fq2 into a point in Fq12.\n * @see https: *\/\nW : Fq12\nW = [0, 1] # zero\n\n\/**\n * Convert a G2 point into a G12 point.\n * @see https: * ```repl\n * :check twist G2 == G12\n * ```\n *\/\ntwist : G2Point -> G12Point\ntwist p = {xCoeffs = newX, yCoeffs = newY} where\n    x = p.xCoeffs\n    y = p.yCoeffs\n    \/\/ Field isomorphism from Z[p] \/ x^^2 to Z[p] \/ x^^2 - 2*x + 2\n    xcoeffs = [(x@0) - (x@1), x@1]\n    ycoeffs = [(y@0) - (y@1), y@1]\n    \/\/ Isomorphism into subfield of Z[p] \/ w^^12 - 2 * w^^6 + 2,\n    \/\/ where w^^6 = x\n    nx = [xcoeffs@0] # five_zeros # [xcoeffs@1] # five_zeros\n    ny = [ycoeffs@0] # five_zeros # [ycoeffs@1] # five_zeros\n    \/\/ Divide x coord by w^^2 and y coord by w^^3\n    newX = nx ~\/~ (W~^^2)\n    newY = ny ~\/~ (W~^^3)\n    five_zeros = repeat`{5} 0\n\n\/*\n * ===========\n * Test Points\n * ===========\n *\/\n\n\/**\n * G2 doubled. Computed using py_ecc: `normalize(double(G2))`.\n *\/\nG2_2P : G2Point\nG2_2P =\n    { xCoeffs =\n        [ 3419974069068927546093595533691935972093267703063689549934039433172037728172434967174817854768758291501458544631891\n        , 1586560233067062236092888871453626466803933380746149805590083683748120990227823365075019078675272292060187343402359\n        ]\n    , yCoeffs =\n        [ 678774053046495337979740195232911687527971909891867263302465188023833943429943242788645503130663197220262587963545\n        , 2374407843478705782611042739236452317510200146460567463070514850492917978226342495167066333366894448569891658583283\n        ]\n    }\n\n\/**\n * G2 tripled. Computed using py_ecc: `normalize(add(G2, double(G2)))`.\n *\/\nG2_3P : G2Point\nG2_3P =\n    { xCoeffs =\n        [ 2795155019138475430256695697248607867022196082692926850257941893956680503583886174445899854256891620515274933186478\n        , 1418901263980595683832511076652430035654903023556505873032297534993731256453342997202098832403658787934376638965468\n        ]\n    , yCoeffs =\n        [ 1713408536894110516522969272885192173669900392782465197506312048399987681703463801235485042423756235640603447122066\n        , 1376945178829045108008380835987620979304438294788415956605678509674588356753313865659068546846109894276784773457993\n        ]\n    }\n\n\/**\n * G2 multiplied by 6. Computed using py_ecc: `normalize(multiply(G2, 6))`.\n *\/\nG2_6P : G2Point\nG2_6P =\n    { xCoeffs =\n        [ 3984640847924757144714972801294669751518204805083279115209564409785869025937099631985667805381121749661329977337231\n        , 608866484358724393780037751128594231300217318157170134017274809385436427203952108566113171210510640978002034144337\n        ]\n    , yCoeffs =\n        [ 3638085773299732811703058316322950283836045952826105333022656670096922749263292332009255347182392556648551235304444\n        , 1315309522598195877039488735068285781409574791250756219351720987511623939545034443010380218936398442802560800338945\n        ]\n    }\n\n\/**\n * G2 negated. Computed using py_ecc: `normalize(neg(G2))`.\n *\/\nG2_Negated : G2Point\nG2_Negated =\n    { xCoeffs =\n        [ 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758\n        ]\n    , yCoeffs =\n        [ 2017258952934375457849735304558732518256013841723352154472679471057686924117014146018818524865681679396399932211882\n        , 3074855889729334937670587859959866275799142626485414915307030157330054773488162299461738339401058098462460928340205\n        ]\n    }\n\n\/**\n * G12 doubled. Computed using py_ecc: `normalize(double(G12))`.\n *\/\nG12_2P : G12Point\nG12_2P =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 3419974069068927546093595533691935972093267703063689549934039433172037728172434967174817854768758291501458544631891\n        , 0, 0, 0, 0, 0\n        , 3085702637220734738417436494616749403912215658780238013160080261412073281518532063392788241082272664317258671945021\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 678774053046495337979740195232911687527971909891867263302465188023833943429943242788645503130663197220262587963545\n        , 0, 0, 0, 0, 0\n        , 847816895216105222315651272001770314991114118284350099884024831234542017398199626189210415118115625674814535309869\n        , 0, 0\n        ]\n    }\n\n\/**\n * G12 tripled. Computed using py_ecc: `normalize(add(G12, double(G12)))`.\n *\/\nG12_3P : G12Point\nG12_3P =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 2795155019138475430256695697248607867022196082692926850257941893956680503583886174445899854256891620515274933186478\n        , 0, 0, 0, 0, 0\n        , 3314282677642727520205697515437815240873236290370797396719235956642557026925566275820787118202399247747445125449282\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 1713408536894110516522969272885192173669900392782465197506312048399987681703463801235485042423756235640603447122066\n        , 0, 0, 0, 0, 0\n        , 1832973098578300992451600694419166481095710360972479322215712298699316162770343964433135566775684661337037799447857\n        , 0, 0\n        ]\n    }\n\n\/**\n * G12 multiplied by 6. Computed using py_ecc: `normalize(multiply(G12, 6))`.\n *\/\nG12_6P : G12Point\nG12_6P =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 3984640847924757144714972801294669751518204805083279115209564409785869025937099631985667805381121749661329977337231\n        , 0, 0, 0, 0, 0\n        , 2314522373438651017950322300652866396447889076475953394735913335923815351124264102732910312043710109696230300963340\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 3638085773299732811703058316322950283836045952826105333022656670096922749263292332009255347182392556648551235304444\n        , 0, 0, 0, 0, 0\n        , 839816652260065229377110122240619827065205829181829385830561226769366420386289987721906250441510775095951918797144\n        , 0, 0\n        ]\n    }\n\n\/**\n * G12 negated. Computed using py_ecc: `normalize(neg(G12))`.\n *\/\nG12_Negated : G12Point\nG12_Negated =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 0, 0, 0, 0, 0\n        , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 2017258952934375457849735304558732518256013841723352154472679471057686924117014146018818524865681679396399932211882\n        , 0, 0, 0, 0, 0\n        , 2530003246008313436619321190568518957050005802350535323083204411198199749930993008942803721832196041551977634344055\n        , 0, 0\n        ]\n    }\n\n\/**\n * The result of G12 multiplied by BLS_MODULUS - 1.\n *\/\nG12_NEG_ONE : G12Point\nG12_NEG_ONE =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 0, 0, 0, 0, 0\n        , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 2017258952934375457849735304558732518256013841723352154472679471057686924117014146018818524865681679396399932211882\n        , 0, 0, 0, 0, 0\n        , 2530003246008313436619321190568518957050005802350535323083204411198199749930993008942803721832196041551977634344055\n        , 0, 0\n        ]\n    }\n\n\/**\n * The result of G12 multiplied by BLS_MODULUS - 2.\n *\/\nG12_NEG_TWO : G12Point\nG12_NEG_TWO =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 3419974069068927546093595533691935972093267703063689549934039433172037728172434967174817854768758291501458544631891\n        , 0, 0, 0, 0, 0\n        , 3085702637220734738417436494616749403912215658780238013160080261412073281518532063392788241082272664317258671945021\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 3323635502175172055438049630502992469028910910047140622029592948100197707060894621654042125998352466817631684596242\n        , 0, 0, 0, 0, 0\n        , 3154592660005562171102138553734133841565768701654657785448033304889489633092638238253477214010900038363079737249918\n        , 0, 0\n        ]\n    }\n\n\/**\n * The result of G12 multiplied by BLS_MODULUS - 3.\n *\/\nG12_NEG_THREE : G12Point\nG12_NEG_THREE =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 2795155019138475430256695697248607867022196082692926850257941893956680503583886174445899854256891620515274933186478\n        , 0, 0, 0, 0, 0\n        , 3314282677642727520205697515437815240873236290370797396719235956642557026925566275820787118202399247747445125449282\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 2289001018327556876894820552850711982886982427156542687825746087724043968787374063207202586705259428397290825437721\n        , 0, 0, 0, 0, 0\n        , 2169436456643366400966189131316737675461172458966528563116345837424715487720493900009552062353331002700856473111930\n        , 0, 0\n        ]\n    }\n\n\/**\n * Verify that negation twice results in the same value.\n * ```repl\n * :prove gp_negation_correct`{2}\n * :prove gp_negation_correct`{12}\n * ```\n *\/\ngp_negation_correct : {n} (fin n, n >= 1) => GPPoint n -> Bit\nproperty gp_negation_correct a =\n    gp_negate (gp_negate a) == a\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/Pairing.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the BLS pairing implementation in the Spec::BlsEC::Pairing module. Include properties that check the validity of pairing results against known valid and invalid point pairs, correctness of the miller_loop and final_exponentiate functions, and consistency of the cast_point_to_fq12 and linefunc functions. Ensure the properties cover edge cases such as points at infinity and invalid curve points, and verify that the pairing_check function correctly identifies valid multi-pairings."},{"role":"assistant","content":"```cryptol\n\/**\n * This module handles the BLS pairing operation and subfunctions.\n * @see https: *\/\nmodule Spec::BlsEC::Pairing where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::FQP\nimport Spec::BlsEC::G1\nimport Spec::BlsEC::GP\n\n\/**\n * Representation for 1.\n * @see https: *\/\nFQ12_ONE : Fq12\nFQ12_ONE = [1] # zero\n\n\/**\n * For each pair of G1, G2 points, run the pairing computation and\n *  compute the product. Finally, run the final exponentiate on the\n *  product and check that it is equal to the element \"one\" of Fq12.\n * @see https: * ```repl\n * :check pairing_check VALID_MULTI_PAIRING_POINTS == True\n * let good_pair = VALID_MULTI_PAIRING_POINTS@0\n * let (g1, g2) = VALID_MULTI_PAIRING_POINTS@1\n * let bad_g1 = g1_multi G1 (`(BLS_MODULUS) - 13)\n * let bad_pair = (bad_g1, g2)\n * :check pairing_check [good_pair, bad_pair] == False\n * ```\n *\/\npairing_check : {n} (fin n) => [n](G1Point, G2Point) -> Bit\npairing_check points = final ~==~ FQ12_ONE where\n    final = final_exponentiate prod\n    prod = foldl (~*~) FQ12_ONE [pairing q p False | (p, q) <- points]\n\n\/**\n * Cast a point in Fq to Fq12.\n * The x and y coordinates are simply the first coefficient with all other coefficients as zero.\n * @see https: * ```repl\n * let expX = [3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507,0,0,0,0,0,0,0,0,0,0,0]\n * let expY = [1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569,0,0,0,0,0,0,0,0,0,0,0]\n * let expected = { xCoeffs = expX, yCoeffs = expY }\n * :check cast_point_to_fq12 G1 == expected\n * ```\n *\/\ncast_point_to_fq12 : G1Point -> G12Point\ncast_point_to_fq12 p = {xCoeffs = newX, yCoeffs = newY} where\n    x = p.xCoord\n    y = p.yCoord\n    newX = [x] # zero\n    newY = [y] # zero\n\n\/**\n * Create a function representing the line between `p1` and `p2`,\n *  and evaluate it at `t`.\n * @see https: * ```repl\n * let one = G12\n * let two = g12_double G12\n * let three = g12_multi G12 3\n * let negone = g12_multi_optimized G12 (`(BLS_MODULUS)-1)\n * let negtwo = g12_multi_optimized G12 (`(BLS_MODULUS)-2)\n * let negthree = g12_multi_optimized G12 (`(BLS_MODULUS)-3)\n * :check linefunc one two one == zero\n * :check linefunc one two two == zero\n * :check linefunc one two three != zero\n * :check linefunc one two negthree == zero\n * :check linefunc one negone one == zero\n * :check linefunc one negone negone == zero\n * :check linefunc one negone two != zero\n * :check linefunc one one one == zero\n * :check linefunc one one two != zero\n * :check linefunc one one negtwo == zero\n * ```\n * Tests from: https: *\/\nlinefunc : G12Point -> G12Point -> G12Point -> Fq12\nlinefunc p1 p2 t =\n    if (p1 == G12_INFINITY) ||\n       (p2 == G12_INFINITY) ||\n       (t == G12_INFINITY) then \/\/ No points-at-infinity allowed\n        error \"Invalid input - no points-at-infinity allowed\"\n    else\n        if x1 != x2 then m1 ~*~ (xt ~-~ x1) ~-~ (yt ~-~ y1)\n         | y1 == y2 then m2 ~*~ (xt ~-~ x1) ~-~ (yt ~-~ y1)\n         else xt ~-~ x1\n    where\n        x1 = p1.xCoeffs\n        y1 = p1.yCoeffs\n        x2 = p2.xCoeffs\n        y2 = p2.yCoeffs\n        xt = t.xCoeffs\n        yt = t.yCoeffs\n        m1 = (y2 ~-~ y1) ~\/~ (x2 ~-~ x1)\n        m2 = 3 *~ (x1~^^2) ~\/~ (2 *~ y1)\n\n\/**\n * @see https: *\/\nate_loop_count : UInt64\nate_loop_count = 15132376222941642752\n\n\/**\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_pairing.py#L29\n *\/\nlog_ate_loop_count : Integer\nlog_ate_loop_count = 62\n\n\/**\n * Miller's algorithm that uses a double and add looping construct to compute the pairing.\n * If the final result (after the final exponentiation) is FQ12_ONE, then the pairing was successful.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_pairing.py#L84\n * ```repl\n * :check miller_loop (twist G2) (cast_point_to_fq12 G1) True == MILLER_LOOP_G2_G1_FQ12\n * ```\n * NOTE: this repl test is very, very slow (~2 minutes).\n *\/\nmiller_loop : G12Point -> G12Point -> Bit -> Fq12\nmiller_loop q p do_final_exponentiate =\n    if (q == G12_INFINITY) ||\n       (p == G12_INFINITY) then FQ12_ONE\n    else double_and_add q FQ12_ONE log_ate_loop_count\n    where\n        double_and_add : G12Point -> Fq12 -> Integer -> Fq12\n        double_and_add r f count =\n            if count < 0 then\n                if do_final_exponentiate then final_exponentiate f else f\n            else\n                if (ate_loop_count && (2^^count)) != 0 then\n                    double_and_add r'' f'' (count - 1)\n                else double_and_add r' f' (count - 1)\n            where\n                f' = f ~*~ f ~*~ (linefunc r r p)\n                r' = g12_double r\n                f'' = f' ~*~ (linefunc r' q p)\n                r'' = g12_add r' q\n\n\/**\n * Final exponentiation of the pairing algorithm.\n * https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_pairing.py#L116\n * The py_ecc \"field_modulus\" is Fq, and \"curve_order\" is the BLS_MODULUS.\n * ```repl\n * :check final_exponentiate G12_x == [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n * ```\n * NOTE: this repl test is very slow (~45 seconds).\n *\/\nfinal_exponentiate : Fq12 -> Fq12\nfinal_exponentiate p = p~^^((`(Fq)^^12 - 1) \/ `(BLS_MODULUS))\n\n\/**\n * Pairing computation.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_pairing.py#L108\n * The tests in `miller_loop` and `pairing_check` cover this function.\n *\/\npairing : G2Point -> G1Point -> Bit -> Fq12\npairing q p do_final_exponentiate =\n    if ~(g2_is_valid_point q) then\n        error \"Invalid input - point Q is not on the correct curve\"\n     | ~(g1_is_valid_point p) then\n        error \"Invalid input - point P is not on the correct curves\"\n    else miller_loop (twist q) (cast_point_to_fq12 p) do_final_exponentiate\n\n\/**\n * Computed `miller_loop(twist(normalize(G2)), cast_point_to_fq12(G1))` with py_ecc.\n * NOTE: this is not a valid KZG proof, it is just a test value.\n *\/\nMILLER_LOOP_G2_G1_FQ12 : Fq12\nMILLER_LOOP_G2_G1_FQ12 =\n    [ 3408834164464458755751340723502736743445402614640994055433339214424916442641449510670327077303074893591740399366532\n    , 1017299873256115394687936133146817339783508925356207904663165117501336940438300180831508525168135575931758510829235\n    , 1919447955347661378578718469488414822573562393353397544098339472673901193098010131520945815709482515519580400649694\n    , 233557331756520805040932826416017142246700002714928636467514104620558679338483625829873520553081791155104026612174\n    , 2882199334237819327910933128503231887000342950792587449681715803095618652567681747054312179958427092970985872417068\n    , 579878855790610229145575079003483905368886712027403088810647643659132674704592975818766405092658613973478871626949\n    , 3268798540077874559188095304926415053902298079662269128631117894259354335713488241073281881110999874366368799440511\n    , 2688711983546324406847903726099677850388169649284572370749691792743294691894680263880362424577638309433508620982332\n    , 3520140447471844017044610248175793726488927385800919015247604269617056365166670232096113218155158979455637700602719\n    , 1555267885602801620621747613743921378408444002839854792606782732724136830563310004098024452104661167182680744848589\n    , 2626389147790168154036854297373352480470342009417426750876875476996308393122833154115295241935326582225976246741447\n    , 873321072950766150592434764742436722571574260472569072177205897167854308426485977134306337249021436737462538398830\n    ]\n\n\/**\n * Randomly generated valid proof pair.\n *\/\nVALID_MULTI_PAIRING_POINTS : [2](G1Point, G2Point)\nVALID_MULTI_PAIRING_POINTS = [\n ({xCoord = 3942577509585645813112967582905379780757916939878725808374136412369021134738667198410219765812816597637590999762994,\n   yCoord = 1088203199345877024923249081294179597401216953118814114064722100932810217381059447963463973664408120385097692508887},\n  {xCoeffs = [352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160,\n    3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758],\n   yCoeffs = [2017258952934375457849735304558732518256013841723352154472679471057686924117014146018818524865681679396399932211882,\n    3074855889729334937670587859959866275799142626485414915307030157330054773488162299461738339401058098462460928340205]}),\n ({xCoord = 3169842563198574659482326102479611290543931141198734323136036543093361601969542502223164030575983014844841304587037,\n   yCoord = 2824376326786724983588666803486546854391198626677433522546039002353746810155815190686926212247090141910905313411994},\n  {xCoeffs = [3394380795309742284085231944467807101526256495961930479404919454683737253440393636117553364774847296670461098299470,\n    3662689612798884582269339769986716851963132127553475998239595135217324880631479103766927470793514208588880068422260],\n   yCoeffs = [2578225059880913843555694372733822992497931377620121352151046101281018929119028392378298954064169396102755595303745,\n    2741696937477620340841025265339742110829389137752838655176100907337011149212882755711342068822769734096710415902962]})\n ]\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/Poly.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the polynomial extended Euclidean algorithm implementation in the Spec::BlsEC::Poly module. Include properties that check the correctness of the polynomial division, degree computation, and the iterative inverse computation functions (inv_while, inv_nested_for). Ensure the properties validate that the extended Euclidean algorithm returns polynomials satisfying the B\u00e9zout identity for the input polynomials, and that intermediate computations maintain expected invariants."},{"role":"assistant","content":"```cryptol\n\/**\n * This module contains polynomial utility functions for polynomial extension fields.\n *\/\nmodule Spec::BlsEC::Poly where\n\nimport Common::ModArith\nimport Spec::BlsEC::Field\n\n\/**\n * Extended euclidean algorithm for polynomials.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L302\n * ```repl\n * let expected_real = 1223514866584400226619392018844575446040489926980124362465220784014275923982521236729115905530146470033177964357563\n * let expected_imag = 3495453419063574139925455551631318136524378768480668459768684498547208492074727172949503320416899422709399085629096\n * let expected = [expected_real, expected_imag]\n * let low = [352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160, 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758, 0]\n * let high = [1, 0, 1]\n * :check poly_extended_euclidean [1, 0, 0] low [0, 0, 0] high == expected\n * ```\n *\/\npoly_extended_euclidean : {n} (fin n, n >= 2) => [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n-1](Z Fq)\npoly_extended_euclidean lm low hm high = take`{n-1} results where\n    (lm', low') = inv_while lm low hm high\n    results = [div_mod lmi (low'@0) | lmi <- lm']\n\n\/**\n * Implements the inner while look of the inverse function.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L311\n * ```repl\n * let expected_lm = [1, 3997412857189233618731963627508854230078445114494716000095659671964648842284302098129323323820452066022319385239514, 0]\n * let expected_low = [3203368238181144282106772347113517508010041690876866219296399795152074745917376658324329538654856903029901947573594, 0, 0]\n * let expected = (expected_lm, expected_low)\n * let low = [352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160, 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758, 0]\n * let high = [1, 0, 1]\n * :check inv_while [1, 0, 0] low [0, 0, 0] high == expected\n * ```\n *\/\ninv_while : {n} (fin n, n >= 1) => [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> ([n](Z Fq), [n](Z Fq))\ninv_while lm low hm high =\n    if (deg low) > 0 then\n        inv_while nm new lm low\n    else (lm, low)\n    where\n        r = poly_rounded_div high low\n        (nm, new) = inv_nested_for lm low hm high r\n\/**\n * The `inv_nested_for` computation.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/fields\/field_elements.py#L311\n * To see why this function and the following subfunctions work, I'll walk through the\n *  pseudo code and rational. Note, the computation for `nm` and `new` are the same,\n *  the first just uses `lm` and the latter `low`. So we'll just work the computation\n *  with one of them, `nm`.\n *\n * Here is our starting code (see link above) with degree 2, and dropping the `new`.\n * for i = 0..2\n *     for j = 2..0\n *         nm[i + j] -= lm[i] * int(r[j])\n *\n * For each element of `nm`, we subtract one or more multiplications of `lm` and `r`.\n *\n * Let's replace the `i + j` indexing into `nm` with `k`.\n * So now we have this:\n *  for k=0..2:\n *      for i=0..k, j=k..0\n *          nm[k] -= lm[i] * r[j]\n *\n * We have `k` which iterates through the elements of `nm`. For each `k`, `i`\n *  always starts at 0 and increments while `i <= k` for each next multiplication\n *  that we need to subtract from the original `nm[k]` element. For each `k`, the\n *  `j` index does the opposite --- it starts a `k` and then decrements down to 0.\n *\n * So lets think about the pairs of indices `i`, `j` that we care about:\n *  when k=0 then [(i=0, j=0)]\n *  when k=1 then [(i=1, j=0), (i=0, j=1)]\n *  when k=2 then [(i=2, j=0), (i=1, j=1), (i=0, j=2)]\n *\n * This kind of computation lends itself to a fold per `k`. But Cryptol\n *  needs us to use a constant sized list of indices, not variable (in `k+1`).\n *\n * To do this, we need some what to represent of pair of indices that shouldn't\n *  actually be used for the subtraction needed. We'll use (-1, -1) for simplicity.\n *\n * Now we have:\n *  when k=0 then [(i=0, j=0), (i=-1, j=-1), (i=-1, j=-1)]\n *  when k=1 then [(i=1, j=0), (i=0, j=1), (i=-1, j=-1)]\n *  when k=2 then [(i=2, j=0), (i=1, j=1), (i=0, j=2)]\n *\n * In summary, we will do the following:\n * 1) Generate the list of indices, including the placeholder (-1, -1) indices\n *  - This is what function`inv_nested_for_index_pairs` does\n * 2) Determine which indices result in a product or zero, stored in a list\n *  - This is what mapping over `inv_nested_for_multi` does\n * 3) Subtract each value in that list from our original element\n *  - This is what `inv_nested_for_compute_value`\n * 4) Do this for both `nm` and `new`\n *  - This is the body of `inv_nested_for`\n *\/\ninv_nested_for : {n} (fin n, n >= 1) => [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> ([n](Z Fq), [n](Z Fq))\ninv_nested_for lm low nm new r = (nm', new') where\n    nm' = [inv_nested_for_compute_value nmi i lm r | nmi <- nm | i <- [0..(n-1)]]\n    new' = [inv_nested_for_compute_value newi i low r | newi <- new | i <- [0..(n-1)]]\n\n\/**\n * This function handles the inner computation of the `inv_nested_for` for each element of each list.\n * ```repl\n * :check inv_nested_for_compute_value 13 0 [3, 5] [2, 7] == (13 - 3*2)\n * ```\n *\/\ninv_nested_for_compute_value : {n} (fin n, n >= 1) => Z Fq -> Integer -> [n](Z Fq) -> [n](Z Fq) -> Z Fq\ninv_nested_for_compute_value ni i l r =\n    foldl (-) ni (map (poly_pair_multi l r) (inv_nested_for_index_pairs`{n} i))\n\n\/**\n * This function performs pair-wise multiplication between two polynomials.\n * ```repl\n * :check poly_pair_multi [13] [13] (-1, 0) == 0\n * :check poly_pair_multi [13] [13] (0, -1) == 0\n * :check poly_pair_multi [13] [13] (-1, -1) == 0\n * :check poly_pair_multi [(2 : Z Fq), (3 : Z Fq)] [(5 : Z Fq), (7 : Z Fq)] (0, 1) == 14\n * ```\n *\/\npoly_pair_multi : {n} (fin n, n >= 1) => [n](Z Fq) -> [n](Z Fq) -> (Integer, Integer) -> Z Fq\npoly_pair_multi l r (i, j) =\n    if (i == -1) || (j == -1) then 0\n    else (l@i) * (r@j)\n\n\/**\n * Computes all combinations of (i,j) pairs where i + j == k.\n * We use the pair (-1, -1) to indicate no computation needed to be performed.\n * ```repl\n * :check inv_nested_for_index_pairs`{3} 0 == [(0, 0), (-1, -1), (-1, -1)]\n * :check inv_nested_for_index_pairs`{3} 1 == [(1, 0), (0, 1), (-1, -1)]\n * :check inv_nested_for_index_pairs`{3} 2 == [(2, 0), (1, 1), (0, 2)]\n * ```\n *\/\ninv_nested_for_index_pairs : {n} (fin n, n >= 1) => Integer -> [n](Integer, Integer)\ninv_nested_for_index_pairs k =\n    [if j <= k then (k-i, j) else (-1,-1) | i <- [0..(n-1)] | j <- [0..(n-1)]]\n\n\/**\n * Compute the degree of the polynomial.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/utils.py#L43\n * ```repl\n * :check deg [0, 0, 0] == 0\n * :check deg [1, 0, 0] == 0\n * :check deg [0, 1, 0] == 1\n * :check deg [0, 0, 1] == 2\n * ```\n *\/\ndeg : {n} (fin n, n >= 1) => [n](Z Fq) -> Integer\ndeg p = compute_d (`(n)-1) where\n    compute_d : Integer -> Integer\n    compute_d d =\n        if ((p@d) == 0) && (d > 0) then\n            compute_d (d - 1)\n        else d\n\n\/**\n * Division of two polynomials.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/utils.py#L50\n * ```repl\n * let high = [1, 0, 1]\n * :check poly_rounded_div high high == [1, 0, 0]\n * let low = [352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160, 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758, 0]\n * let expected = [0, 3760942702196338589502826385415833209682098933908451272344533612462792778154520066649324657897802310897411427023085, 0]\n * :check poly_rounded_div high low == expected\n *\/\npoly_rounded_div : {n} (fin n, n >= 1) => [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq)\npoly_rounded_div a b = compute_outer_loop o0 temp0 start where\n    dega = deg a\n    degb = deg b\n    o0 = (zero:[n](Z Fq))\n    temp0 = [x | x <- a]\n    start = dega - degb\n\n    compute_outer_loop : [n](Z Fq) -> [n](Z Fq) -> Integer -> [n](Z Fq)\n    compute_outer_loop o temp i =\n        if i < 0 then o\n        else compute_outer_loop o' temp' i'\n        where\n            o' = [if j == i then (o@j) + oi' else (o@j) | j <- [0..(n-1)]]\n            oi' = div_mod (temp@(degb + i)) (b@degb)\n            temp' = compute_temp' temp 0\n            i' = i - 1\n\n            compute_temp' : [n](Z Fq) -> Integer -> [n](Z Fq)\n            compute_temp' t c =\n                if c < (degb + 1) then compute_temp' updated_temp (c+1)\n                else t\n                where\n                    updated_temp = [if j == (c + i) then (t@(c + i)) - (o@c) else (t@c) | j <- [0..(n-1)]]\n```"}]}
{"filename":"SAW-course\/src\/lab1\/csearch_nobug.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property or theorem that formally verifies the correctness of the 'bsearch' function by proving its equivalence to the reference implementation 'refSearchIdx' on sorted (onlyIncreasing) input lists."},{"role":"assistant","content":"```cryptol\n\/\/ Binary search in cryptol - bug is eliminated\n\nbsearch : {n} (fin n, 8 >= width n) => ([8],[n][8]) -> [8]\nbsearch (key, lst) = search (0, (length lst)-1, w)\n  where \n    w = length lst\n    \/\/ The function \"search\" is not symbolically terminating,\n    \/\/ so we use an \"extra\" recursion counter (c) for termination purposes\n    \/\/ Note that this is only needed when doing the proof..\n    search (low, high, c) =\n       if (c <= 0) \\\/ (low > high) \\\/ (high > w-1) then -1\n       else if midVal < key then search (mid+1, high, c-1)\n       else if midVal > key then search (low, mid-1, c-1)\n       else mid\n       where  \n          midVal = lst @ mid\n          mid = computeMid (low, high)\n\ncomputeMid (low, high) = (low + (high-low) \/ 2)\n\n\/\/ Returns the first location of a given key in the given list\n\/\/ or -1 if the key is not in the list\nrefSearchIdx (key, lst) = s!0\n   where\n     s = [-1]#[ if (key == x \/\\ h == -1) then c\n         else h | x <- lst |  h <- s | c <- [0...]]\n\nlst3 = [0,   2,   3,   5,   6,   8,   9,  10,  11,  12,  13,  14,  16,  18,\n       20,  21,  22,  23,  24,  25,  26,  27,  28,  30,  31,  32,  33,  34,\n       35,  36,  37,  39,  40,  41,  32,  43,  44,  45,  46,  47,  49,  50,\n       51,  52,  53,  54,  56,  58,  59,  60,  61,  62,  63,  65,  66,  67,\n       68,  69,  70,  71,  72,  73,  74,  76,  77,  78,  79,  80,  81,  82,\n       84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,\n       98,  99, 101, 102, 103, 104, 105, 106, 107, 108, 110, 112, 113, 114,\n      116, 117, 119, 120, 121, 122, 124, 125, 126, 127, 129, 130, 131, 132,\n      133, 134, 135, 136, 138, 139, 141, 143, 144, 145, 147, 148, 149, 150,\n      152, 153, 155, 156, 157, 158, 159, 160, 162, 163, 164, 166, 167, 168,\n      169, 170, 172, 174, 175, 176, 177, 178, 179, 181, 182, 183, 184, 185,\n      187, 188, 189, 190, 191, 192, 197, 198, 199, 200, 201, 202, 203, 204,\n      206, 207, 208, 209, 210, 211, 213, 214, 215, 216, 218, 220, 221, 222,\n      223, 224, 226, 228, 229, 230, 231, 232, 234, 235, 236, 237, 238, 239,\n      240, 241, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 255]:[210][9]\n\n\/\/ bsearch and refSearch are equivalent when the input is\n\/\/ only increasing in sequence, so recognize such sequences:\nonlyIncreasing lst = pairComps == ~zero\n  where pairComps = [ x < x' | x  <- [0] # lst | x' <- lst ]\n\n\/\/ The theorem holds, establishing correctness.\nbsearchOK : [8] -> [130][8] -> Bit\nproperty bsearchOK key lst =\n  if onlyIncreasing (lst) \/\\ 0 <= key\n  then bsearch (key, lst) == refSearchIdx (key, lst)\n  else True\n\n\/\/ Cryptol> :l csearch_bug.cry\n\/\/ Loading module Cryptol\n\/\/ Loading module Main\n\/\/ Main>  :prove bsearchOK\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 23.144s, using \"Z3\")\n\/\/ Main>\n```"}]}
{"filename":"SAW-course\/src\/lab1\/mid.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol verification script that proves the correctness of the midpoint functions midA and midS defined in the file mid.cry. Specifically, verify the properties midS_is_safe and midpointsAreClose to ensure that midS does not overflow for inputs less than 256 and that the two midpoint calculations differ by at most 1 except when high is 255, in which case they are equal. Use the :prove command to formally verify these properties."},{"role":"assistant","content":"```cryptol\nmidA : [8] -> [8] -> [8]\nmidA low high = (low+high)\/2\n\nmidS : [8] -> [8] -> [8]\nmidS low high = low + (high - low)\/2\n\n\/\/ This theorem shows that as long as high and low are no greater than 255,\n\/\/ the sum of low +(high-low)\/2 is never greater than 255\nmidS_is_safe : [9] -> [9] -> Bit\nproperty midS_is_safe low high\n   = ~(low < 256 \/\\ high < 256 \/\\ low <= high) \\\/ \n      ((high-low) < 256) \/\\ ((high-low)\/2 < (256 - low))\n\n\/\/ This theorem shows that the midpoint calculation using (low+high)\/2\n\/\/ differs from the calculation using low+(high-low)\/2 by at most 1\n\/\/ unless high is 255 in which case they are equal.\n\nmidpointsAreClose : [9] -> [9] -> Bit\nproperty midpointsAreClose low high\n   = (~(0 <= low \/\\ low <= high \/\\ high < 255)  \\\/\n       ((safeMid <= averageMid \/\\ averageMid <= safeMid+1) \\\/\n        (averageMid <= safeMid \/\\ safeMid <= averageMid+1)))\n     \/\\\n     (~(low <= high \/\\ high == 255) \\\/ (averageMid == safeMid))\n  where\n     averageMid = (low+high)\/2         \/\/ Average of low and high as midpoint\n     safeMid    = (low+(high-low)\/2)   \/\/ Safe midpoint given low and high\n\n\/\/ Cryptol> :l mid.cry\n\/\/ Loading module Cryptol\n\/\/ Loading module Main\n\/\/ Main> :prove midpointsAreClose\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 0.030s, using \"Z3\")\n\/\/ Main>\n```"}]}
{"filename":"SAW-course\/src\/lab6A\/saf.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the safe function 'saf' correctly bounds checks the index before accessing the array, ensuring it never produces out-of-bounds errors, and that when the index is valid, 'saf' returns the same result as the unsafe function 'usaf'."},{"role":"assistant","content":"```cryptol\n\/\/:safe usaf (unsafe - no checks for out of bounds errors are made)\nusaf: [1][8] -> [10][8] -> [1][8]\nusaf a b = [(b@(a@0))]\n\n\/\/:safe saf (safe - checks for out of bounds are made)\nsaf : [1][8] -> [10][8] -> [1][8]\nsaf a b = if a@0 > 9 then [0]\n          else if a@0 < 0 then [0]\n\t\t\t else [(b@(a@0))]\n```"}]}
{"filename":"SAW-course\/src\/lab6A\/zero.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the safety and correctness of the functions 'usaf' and 'saf' defined in the given Cryptol code. Specifically, ensure that 'usaf' is unsafe when dividing by zero, and that 'saf' returns 1 when the divisor is zero and otherwise returns the division result. Include properties suitable for both :check and :prove commands."},{"role":"assistant","content":"```cryptol\n\/\/:safe z1  (unsafe - divide by zero error if b is 0)\nusaf : [8] -> [8] -> [8]\nusaf a b = (a\/b):[8]\n\nsaf : [8] -> [8] -> [8]\nsaf a b = if b == 0 then 1 else (a\/b)\n```"}]}
{"filename":"SAW-course\/src\/lab3E\/elevator.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the elevator system represented by the given State type and initState. Include properties that verify correct initialization, button press handling, motor movement logic, door sensor states, and floor sensor updates to ensure the elevator operates safely and as intended."},{"role":"assistant","content":"```cryptol\ntype State = {  cb : [4][12],  \/\/ call buttons - 1\/floor, 4 total\n               cbl : [4][12],  \/\/ call button lights - 1\/floor, 4 total\n                eb : [4][12],  \/\/ elevator buttons - 1\/floor, 4 total\n\t\t\t\t\tebl : [4][12],  \/\/ elevator button lights - 1\/button, 4 total\n\t\t\t\t\tids : [12],     \/\/ elevator door sensor\n\t\t\t\t\tods : [4][12],  \/\/ outside door sensor - 1\/floor, 4 total\n\t\t\t\t\tmtr : [12],     \/\/ motor direction, in motion\n\t\t\t\t\t fs : [4][12],  \/\/ floor sensor - 1\/floor, 4 total\n\t\t\t\t\t pe : [12] }    \/\/ person(s) in elevator\n\ninitState : State\ninitState = {  cb = [0,0,0,0], \/\/ no call buttons pressed\n              cbl = [0,0,0,0], \/\/ all call button lights are off\n\t\t\t\t   eb = [0,0,0,0], \/\/ no elevator buttons pressed\n\t\t\t\t  ebl = [0,0,0,0], \/\/ elevator button lights are off\n\t\t\t\t  ids = 0,         \/\/ elevator door is open\n\t\t\t\t  ods = [0,1,1,1], \/\/ outside floor door is open on 1st floor only\n\t\t\t\t  mtr = 0,         \/\/ elevator is stationary\n\t\t\t\t   fs = [1,0,0,0], \/\/ elevator is on 1st floor\n\t\t\t\t\tpe = 0 }        \/\/ no one is in the elevator\n```"}]}
{"filename":"SAW-course\/src\/lab3B\/alt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol verification script that formally proves or disproves the property WK, which states that double encryption with the same key returns the original plaintext, using an SMT solver such as Boolector. Include commands to check satisfiability and attempt to prove the property, and handle counterexamples if the property does not hold."},{"role":"assistant","content":"```cryptol\nmodule alt where\nimport DES\n\n\/\/ Returns a sequence of 1s iff all numbers in (expandKey key) are the same\nfunc x = z\n  where\n    z = [ a == b | a <- x | b <- drop `{1} x ]\n\nproperty WeakKeys key = (func (expandKey key)) == ~zero\n\n\/\/ Then, in cryptol:\n\/\/ alt> :s satNum=all\n\/\/ alt> :sat WeakKeys\n\nWK : [64] -> [64] -> Bit\nproperty WK key pt = (DES.encrypt key (DES.encrypt key pt)) == pt\n\/\/ alt> :s prover=boolector\n\/\/ alt> :prove WK\n\/\/ Counterexample\n\/\/ WK 0xbe38506e28f20628 0x67ff7750c8ef5f99 = False\n\/\/ (Total Elapsed Time: 2.184s, using \"Boolector\")\n```"}]}
{"filename":"SAW-course\/src\/lab3B\/solution.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the behavior of the DES encryption functions in the given module. Specifically, create properties that check for weak keys by verifying that the 'func' function returns a sequence of all ones only when all numbers in 'expandKey key' are the same, and properties that confirm that encrypting twice with the same key does not return the original plaintext. Include commands to use the SAT solver and SMT solver to check and prove these properties."},{"role":"assistant","content":"```cryptol\nmodule solution where\nimport DES\n\n\/\/ Returns a sequence of 1s iff all numbers in (expandKey key) are the same\nfunc key = z\n  where\n    z = [ x == y | x <- (expandKey key) | y <- (drop `{1} (expandKey key)) ]\n     \n\/\/ Exercise 1: weak keys\nproperty WeakKeys key = (func key) == ~zero\n\n\/\/ Then, in cryptol:\n\/\/ solution> :s satNum=all\n\/\/ solution> :sat WeakKeys\n\n\/\/ Exercise 2:\n\/\/ Encrypting twice should not produce original plaintext\nWK : [64] -> [64] -> Bit\nproperty WK key pt = (DES.encrypt key (DES.encrypt key pt)) == pt\n\/\/ solution> :s prover=boolector\n\/\/ solution> :prove WK\n\/\/ Counterexample\n\/\/ WK 0xbe38506e28f20628 0x67ff7750c8ef5f99 = False\n\/\/ (Total Elapsed Time: 2.180s, using \"Boolector\")\n```"}]}
{"filename":"SAW-course\/src\/lab3C\/sn74as181a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the sn74as181a module's implementation. Specifically, create properties that prove the equivalence between the functional specification (f74181_spec) and the netlist implementation (f74181_netlist), and verify that the module's outputs match expected results for XOR and addition operations as defined by v_xor and v_adder functions. Use the existing functions and inputs to define these properties and prove them using Cryptol's :prove command."},{"role":"assistant","content":"```cryptol\nmodule sn74as181a where\n\n\/\/ Input: a and b are sequences of True,False\n\/\/ Output: xor of each a,b pair until the end of the\n\/\/ shortest sequence is reached.  Below, both sequences\n\/\/ will be of the same length.\n\/\/ Example:  v_xor [True, False, True, False]\n\/\/                 [True, True, False, False]\n\/\/ 0b0110\nv_xor a b = [ x^y  | x <- a | y <- b ]\n\n\/\/ Input: c is a Bit, a and b are sequences of True,False\n\/\/ Output: sequence of Bits where each Bit is the result\n\/\/ of adding 2 input bits plus a carry from the previous\n\/\/ stage.  The last Bit in the sequence is the last carry\n\/\/ bit.\n\/\/ Example: v_adder True [False,True,False,True]\n\/\/                       [False,True,True,True]\n\/\/ 0b10011\nv_adder c a b = drop `{1} [ w.0 | w <- z ]\n  where\n    z = [(False, c)]#\n        [ (x^y^q.1, (x\/\\y)\\\/(x\/\\q.1)\\\/(y\/\\q.1))\n        | x <-a#[False] | y <- b#[False] | q <- z ]\n\n\/\/ On Page 4 see four occurrences of f74171_q0\n\/\/ if s3 and s2 are T this is  ~((a \/\\ b) \\\/ (a \/\\ ~b)) ->\n\/\/    if a is False then True else False -> ~a\n\/\/ if s3 and s2 are False this is True\n\/\/ if s3 is True and s2 is False this is ~(a \/\\ b) \n\/\/ if s3 is False and s2 is True this is ~(a \/\\ ~b)\n\/\/ (f74181_q0 True True True True True True) -> False\nf74181_q0 a b s0 s1 s2 s3 = ~((b \/\\ s3 \/\\ a) \\\/ (a \/\\ s2 \/\\ ~b))\n\n\/\/ On Page 4 see four occurrences of f74171_q1\n\/\/ if s1 and s0 are True this is ~(~b \\\/ a \\\/ b) = False\n\/\/ if s1 and s0 are False this is ~a\n\/\/ if s1 is True and s0 is False this is ~(~b \\\/ a)\n\/\/ if s1 is False and s0 is True this is ~(a \\\/ b)\n\/\/ (f74181_q1 True True True True True True) -> False\nf74181_q1 a b s0 s1 s2 s3 = ~((~b \/\\ s1) \\\/ (s0 \/\\ b) \\\/ a)\n\nf74181_f0 c a0 b0 m s0 s1 s2 s3 = out\n  where\n    m_neg = ~m\n    tmp = (f74181_q0 a0 b0 s0 s1 s2 s3) ^\n          (f74181_q1 a0 b0 s0 s1 s2 s3)\n    out = ~(c \/\\ m_neg) ^ tmp\n\nf74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3 = out\n  where\n    m_neg = ~m\n    tmp1 = (f74181_q0 a1 b1 s0 s1 s2 s3) ^\n            (f74181_q1 a1 b1 s0 s1 s2 s3)\n    tmp2 = ~((m_neg \/\\\n              (f74181_q1 a0 b0 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q0 a0 b0 s0 s1 s2 s3) \/\\\n              c))\n    out = tmp1 ^ tmp2\n\nf74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3 = out\n  where\n    m_neg = ~m\n    tmp1 = (f74181_q0 a2 b2 s0 s1 s2 s3) ^\n           (f74181_q1 a2 b2 s0 s1 s2 s3)\n    tmp2 = ~((m_neg \/\\\n              (f74181_q1 a1 b1 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n              (f74181_q1 a0 b0 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q0 a0 b0 s0 s1 s2 s3) \/\\\n              (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n              c))\n    out = tmp1 ^ tmp2\n\nf74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n    m_neg = ~m\n    tmp1 = (f74181_q1 a3 b3 s0 s1 s2 s3) ^\n           (f74181_q0 a3 b3 s0 s1 s2 s3)\n    tmp2 = ~((m_neg \/\\\n              (f74181_q1 a2 b2 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q1 a1 b1 s0 s1 s2 s3) \/\\\n              (f74181_q0 a2 b2 s0 s2 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q1 a0 b0 s0 s1 s2 s3) \/\\\n              (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n              (f74181_q0 a2 b2 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q0 a0 b0 s0 s1 s2 s3) \/\\\n              (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n              (f74181_q0 a2 b2 s0 s1 s2 s3) \/\\\n              c))\n    out = tmp1 ^ tmp2\n\nf74181_a_b c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n    out = ((f74181_f0 c a0 b0 m s0 s1 s2 s3) \/\\\n           (f74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3) \/\\\n           (f74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3) \/\\\n           (f74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3))\n\nf74181_prop c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n    out = ~((f74181_q0 a0 b0 s0 s1 s2 s3) \/\\\n            (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n            (f74181_q0 a2 b2 s0 s1 s2 s3) \/\\\n            (f74181_q0 a3 b3 s0 s1 s2 s3))\n\nf74181_gen c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n   out = ~(((f74181_q0 a3 b3 s0 s1 s2 s3) \/\\\n            (f74181_q0 a2 b2 s0 s1 s2 s3) \/\\\n            (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n            (f74181_q1 a0 b0 s0 s1 s2 s3)) \\\/\n           ((f74181_q0 a3 b3 s0 s1 s2 s3) \/\\\n            (f74181_q0 a2 b2 s0 s1 s2 s3) \/\\\n            (f74181_q1 a1 b1 s0 s1 s2 s3)) \\\/\n           ((f74181_q0 a3 b3 s0 s1 s2 s3) \/\\\n            (f74181_q1 a2 b2 s0 s1 s2 s3)) \\\/\n           (f74181_q1 a3 b3 s0 s1 s2 s3))\n\nf74181_cout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n    out = (~(f74181_gen c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)) \\\/\n          ((~(f74181_prop c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)) \/\\ c)\n\nf74181_sumout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 =\n   [(f74181_f0 c a0 b0 m s0 s1 s2 s3),\n    (f74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3),\n    (f74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3),\n    (f74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3),\n    (f74181_cout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)]\n\n\/\/ Functional specification\nf74181_spec c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 =\n   [f74181_f0 c a0 b0 m s0 s1 s2 s3,\n    f74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3,\n    f74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3,\n    f74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3,\n    f74181_cout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3,\n    f74181_prop c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3,\n    f74181_gen c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3,\n    f74181_a_b c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3]\n\n\/\/ Wiring diagram\nf74181_netlist c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 =\n  [f0,f1,f2,f3,cout,p,g,a_b]\n  where\n    w0 = ~m\n    w1 = ~b0\n    w2 = ~b1\n    w3 = ~b2\n    w4 = ~b3\n    w5 = a0\n    w6 = b0 \/\\ s0\n    w7 = s1 \/\\ w1\n    w8 = w1 \/\\ s2 \/\\ a0\n    w9 = a0 \/\\ s3 \/\\ b0\n    w10 = a1\n    w11 = b1 \/\\ s0\n    w12 = s1 \/\\ w2\n    w13 = w2 \/\\ s2 \/\\ a1\n    w14 = a1 \/\\ s3 \/\\ b1\n    w15 = a2\n    w16 = b2 \/\\ s0\n    w17 = s1 \/\\ w3\n    w18 = w3 \/\\ s2 \/\\ a2\n    w19 = a2 \/\\ s3 \/\\ b2\n    w20 = a3\n    w21 = b3 \/\\ s0\n    w22 = s1 \/\\ w4\n    w23 = w4 \/\\ s2 \/\\ a3\n    w24 = a3 \/\\ s3 \/\\ b3\n    w25 = ~(w5 \\\/ w6 \\\/ w7)\n    w26 = ~(w8 \\\/ w9)\n    w27 = ~(w10 \\\/ w11 \\\/ w12)\n    w28 = ~(w13 \\\/ w14)\n    w29 = ~(w15 \\\/ w16 \\\/ w17)\n    w30 = ~(w18 \\\/ w19)\n    w31 = ~(w20 \\\/ w21 \\\/ w22)\n    w32 = ~(w23 \\\/ w24)\n    w33 = (w25 ^ w26)\n    w34 = (w27 ^ w28)\n    w35 = (w29 ^ w30)\n    w36 = (w31 ^ w32)\n    w37 = ~(w0 \/\\ c)\n    w38 = w0 \/\\ w25\n    w39 = (w0 \/\\ w26 \/\\ c)\n    w40 = (w0 \/\\ w27)\n    w41 = (w0 \/\\ w25 \/\\ w28)\n    w42 = (w0 \/\\ w28 \/\\ w26 \/\\ c)\n    w43 = (w0 \/\\ w29)\n    w44 = (w0 \/\\ w27 \/\\ w30)\n    w45 = (w0 \/\\ w25 \/\\ w30 \/\\ w28)\n    w46 = (w0 \/\\ w30 \/\\ w28 \/\\ w26 \/\\ c)\n    w47 = ~(w26 \/\\ w28 \/\\ w30 \/\\ w32)\n    w48 = ~(c \/\\ w26 \/\\ w28 \/\\ w30 \/\\ w32)\n    w49 = (w25 \/\\ w28 \/\\ w30 \/\\ w32)\n    w50 = (w27 \/\\ w30 \/\\ w32)\n    w51 = (w29 \/\\ w32)\n    w52 = w31\n    w53 = w37\n    w54 = ~(w38 \\\/ w39)\n    w55 = ~(w40 \\\/ w41 \\\/ w42)\n    w56 = ~(w43 \\\/ w44 \\\/ w45 \\\/ w46)\n    w57 = ~(w49 \\\/ w50 \\\/ w51 \\\/ w52)\n    w58 = (w53 ^ w33)\n    w59 = (w54 ^ w34)\n    w60 = (w55 ^ w35)\n    w61 = (w56 ^ w36)\n    w62 = (~w48 \\\/ ~w57)\n    w63 = (w58 \/\\ w59 \/\\ w60 \/\\ w61)\n    f0 = w58\n    f1 = w59\n    f2 = w60\n    f3 = w61\n    a_b = w63\n    p = w47\n    cout = w62\n    g = w57\n\nv00 = f74181_netlist True False False True True False False\n                     False True True False False True True\n\nf74181_fout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = \n   [(f74181_f0 c a0 b0 m s0 s1 s2 s3),\n    (f74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3),\n    (f74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3),\n    (f74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)]\n\nproperty xorWorks c a0 a1 a2 a3 b0 b1 b2 b3 =\n   (f74181_fout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3) == (v_xor a b)\n     where\n       a = [a0,a1,a2,a3]\n       b = [b0,b1,b2,b3]\n       s0 = False\n       s1 = True\n       s2 = True\n       s3 = False\n       m = True\n\nproperty addingWorks c a0 a1 a2 a3 b0 b1 b2 b3 =\n         [out0,out1,out2,out3,cout] == (v_adder c a b)\n  where\n    a = [a0,a1,a2,a3];\n\t b = [b0,b1,b2,b3]\n    s0 = True\n    s1 = False\n    s2 = False\n    s3 = True\n    m = False\n    output = (f74181_spec (~c) a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)\n    out0 = output@0\n    out1 = output@1\n    out2 = output@2\n    out3 = output@3\n    out4 = output@4\n    cout = ~out4\n\nproperty itWorks c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 =\n    (f74181_spec c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3) ==\n    (f74181_netlist c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)\n  where\n    a = [a0,a1,a2,a3]\n    b = [b0,b1,b2,b3]\n\n\/\/ Cryptol> :l sn74as181a.cry\n\/\/ Main> :prove xorWorks\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 0.011s, using \"Z3\")\n\/\/ Main> :prove addingWorks\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 0.019s, using \"Z3\")\n\/\/ Main> :prove itWorks\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 0.023s, using \"Z3\")\n```"}]}
{"filename":"SAW-course\/src\/lab3C\/f74181_tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify that the function `logicStuff` behaves equivalently to the `f74181_spec` function from the imported `sn74as181a` module for all possible 4-bit inputs `a` and `b` and 4-bit select signals `s`. Ensure the properties are suitable for automated checking or proving within Cryptol."},{"role":"assistant","content":"```cryptol\nmodule f74181_tests where\nimport sn74as181a\n\nlogicStuff a0 a1 a2 a3 b0 b1 b2 b3 s0 s1 s2 s3 = \n  if s == 0 then ~(a) else\n  if s == 1 then ~(a || b) else\n  if s == 2 then (~a && b) else\n  if s == 3 then 0 else\n  if s == 4 then ~(a && b) else\n  if s == 5 then ~b else\n  if s == 6 then (a ^ b) else\n  if s == 7 then a && ~b else\n  if s == 8 then ~a || b else\n  if s == 9 then ~(a ^ b) else\n  if s == 10 then b else\n  if s == 11 then a && b else\n  if s == 12 then 15 else\n  if s == 13 then a || ~b else\n  if s == 14 then a || b else a\n    where\n      a = [a0,a1,a2,a3]:[4];\n\t   b = [b0,b1,b2,b3]:[4];\n\t   s = [s3,s2,s1,s0]:[4]\n\nproperty logicStuffWorks a0 a1 a2 a3 b0 b1 b2 b3 s0 s1 s2 s3 =\n    (logicStuff a0 a1 a2 a3 b0 b1 b2 b3 s0 s1 s2 s3) ==\n    (f74181_spec True a0 a1 a2 a3 b0 b1 b2 b3 True s0 s1 s2 s3)@@[0,1,2,3]\n```"}]}
{"filename":"SAW-course\/src\/lab4\/perm.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the 'perm' function in the given module defines a permutation relation. Specifically, write properties to prove that 'perm' is reflexive, symmetric, and transitive over lists of 32-bit words, using the existing 'permReflexive', 'permSymmetric', and 'permTransitive' property templates. Ensure the properties handle edge cases such as empty lists and verify the correctness of 'remove' and 'member' helper functions as part of the permutation definition."},{"role":"assistant","content":"```cryptol\nmodule perm where\n\nremove lst n = drop `{2} [w.0 | w <- z]\n  where\n    z = [(-1,False)]#[ if (q.1 == False \/\\ ~(za == n)) \n                       then (za, q.1)\n                       else (zb, True)\n                     | za <- [-1]#lst | zb <- lst#[-1] | q <- z ]\n\nmember lst n = z ! 0\n  where\n    z = [False]#[ ss \\\/ (p == n) | p <- lst | ss <- z ]\n\nperm x y = if (length x) == 0 \/\\ (length y) == 0 then True else\n           if (length x) == (length y) then (z ! 0).1 else False\n  where\n    z = [ ((remove q.0 p), (member q.0 p) \/\\ q.1)\n        | q <- [(y,True)]#z | p <- x ]\n\npermReflexive : [10][32] -> [10][32] -> Bit\nproperty permReflexive x y = ~(x == y) \\\/ perm x y\n\npermSymmetric : [10][32] -> [10][32] -> Bit\nproperty permSymmetric x y =\n   if ~(member x (2^^32-1)) \/\\ ~(member y (2^^32-1)) \/\\ perm x y\n   then perm y x else True\n\npermTransitive : [6][32] -> [6][32] -> [6][32] -> Bit\nproperty permTransitive x y z =\n   if ~(member x (2^^32-1)) \/\\ ~(member y (2^^32-1)) \/\\ ~(member z (2^^32-1)) \/\\\n       perm x y \/\\ perm y z\n   then perm x z else True\n\n\/\/ use cvc4 prover\n```"}]}
{"filename":"SAW-course\/src\/lab4\/bsort.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the 'bsort' function produces a sorted list that is a permutation of the input list. Specifically, create properties that check (1) the output of 'bsort' is nondecreasing, and (2) the output is a permutation of the input, using the provided 'perm' module. Ensure the properties handle valid inputs as defined by the 'valid' predicate."},{"role":"assistant","content":"```cryptol\nimport perm\n\nbsort : {n, a} (Cmp a, Integral a, Literal 1 a, fin n) => [n]a -> [n]a\nbsort lst = take `{n} (bb (lst#[-1,-1...]))\n  where\n    bb seq = if (seq@0) == -1 then seq else (bbl (head seq) (bb (tail seq)))\n    bbl n seq =\n      if ((seq@0) == -1) then [n]#[-1,-1...]\n      else if (n < (seq@0)) then [n]#seq\n      else [(seq@0)]#(bbl n (tail seq))\n      \nvalid lst = z ! 0\n  where\n    z = [True]#[~(x == -1) \/\\ y | x <- lst | y <- z ]\n\nisAPerm : [6][32] -> Bit\nproperty isAPerm lst = ~(valid lst) \\\/ perm lst (bsort lst)\n\nnondecreasing : [6][32] -> Bit\nnondecreasing lst = z ! 0\n  where\n    z = [True]#[ if (j1 <= j2) \/\\ k then True else False\n               | k <- z | j1 <- lst | j2 <- drop `{1} lst]\n\nbsortIsOrdered : [6][32] -> Bit\nproperty bsortIsOrdered lst = ~(valid lst) \\\/ nondecreasing (bsort lst)\n```"}]}
{"filename":"SAW-course\/src\/lab4\/mrgsrt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the mergesort function correctly sorts any finite list of positive numbers. Specifically, write properties that check (1) the output list is a permutation of the input list, and (2) the output list is sorted in nondecreasing order. Use the existing definitions of perm and nondecreasing, and ensure the properties handle the infinite list padding appropriately."},{"role":"assistant","content":"```cryptol\nimport perm\n\n\/************************************************************************\/\n\/*  The goal of this page:                                              *\/\n\/*    Show how a specification of an operation on finite lists          *\/\n\/*    can be expressed recursively by switching to infinite lists       *\/\n\/*    and back                                                          *\/\n\/*  Define mergesort on lists of positive numbers and prove correctness *\/\n\/************************************************************************\/\n\/* Mergesort - but only for positive numbers \n   subfunctions operate on infinite lists to allow for recursion\n   subfunctions are as follows:\n   splito: \n     Input - lst=finite list\n     Output - infinite list, padded with -1s after the split elements\n     Process: best described as [ lst@i | i <- [1,3...] ]\n   splite:\n     Input - lst=finite list\n     Output - infinite list, padded with -1s after the split elements\n     Process: best described as [ lst@i | i <- [0,2...] ]\n   merge:\n     Inputs: px, py - two infinite lists in nondecreasing order (padded with -1s)\n     Output: infinite list, nondecreasing, containing all of px & py, padded\n     Process: merge two padded infinite lists, up to the padding\n     if px@0 is -1 then return py, if py@0 is -1 then return px\n     otherwise if px@0 is less than py@0 concat px@0 with (merge (tail(px) py)\n     otherwise concat py@0 with (merge px (tail py))\n   mergesrt:\n     Input: p=infinite list (padded)\n     Output: padded, nondecreasing infinite list that is a permutation of x\n     Process: sort list p up to the padding\n     recursively merge the mergesrt of the even elements of p with the mergesrt\n     of the odd elements of p\n*\/\n\n\/\/  Input: lst - -1 padded finite sequence of numbers\n\/\/  Output: lst with only odd indexed elements followed by -1 padding\nsplito : {n,a} [n]a -> [inf]a\nsplito lst = [ lst@i | i <- [1,3...] ]\n\n\/\/  Input: lst - -1 padded finite sequence of numbers\n\/\/  Output: lst with only even indexed elements followed by -1 padding\nsplite : {n,a} [n]a -> [inf]a\nsplite lst = [ lst@i | i <- [0,2...] ]\n\n\/\/  Inputs: px, py: two infinite lists in nondecreasing order (padded with -1s)\n\/\/  Output: infinite list, nondecreasing, containing all of px and py, padded\nmerge : {a} (Literal 1 a, Ring a, Cmp a) => [inf]a -> [inf]a -> [inf]a\nmerge px py = \n      if px@0 == -1 then py\n      else if py@0 == -1 then px\n      else if px@0 < py@0 then [px@0]#(merge (tail px) py)\n      else [py@0]#(merge px (tail py))\n\n\/\/  Input: finite sequence lst of numbers\n\/\/  Output: finite nondecreasing sequence of numbers that is permutation of lst\nmergesort : {cnt, a} (fin cnt, fin a, a >= 1, cnt >= 0) => [cnt][a] -> [cnt][a]\nmergesort lst = take `{cnt} (mergesrt ax)\n  where\n    mergesrt p = \n      if p@0 == -1 \\\/ p@1 == -1 then p\n      else merge (mergesrt (splite p)) (mergesrt (splito p))\n    ax = lst#[-1,-1 ...]\n\n\/\/ For the following use :s base=10\nres00 = take `{3} (splite [1,2,3,4,5,6])\nres01 = take `{3} (splite [1,2,3,4,5,6,7])\nres02 = take `{4} (splite [1,2,3,4,5,6,7,8])\n\nres10 = take `{3} (splito [1,2,3,4,5,6])\nres11 = take `{4} (splito [1,2,3,4,5,6,7])\nres12 = take `{4} (splito [1,2,3,4,5,6,7,8])\n\nres20 = take `{8} (merge ([1,5,7,10]#[-1,-1 ...]) ([3,7,11,14]#[-1,-1 ...]))\n\nres30 = mergesort [6,7,8,2,3,4,1,11,23,5]\nres31 = mergesort [1]\nres32 = mergesort [2,2]\nres33 = mergesort [2,1]\nres34 = mergesort [9,8,7,6,5,4,3,2,1]\nres35 = mergesort [9,8,7,6,5,4,3,2,1,6]\nres36 = mergesort [9,8,7,6,5,4,3,2,1,6,10]\nres37 = mergesort [9,8,7,6,5,4,3,2,10,6,1]\nres38 = mergesort [1,9,8,7,6,5,4,3,2,1,6]\nres39 = mergesort [10,9,8,7,6,5,4,3,2,1,6]\n\nresults = [take `{11} (res30#[-1,-1...]),\n           take `{11} (res31#[-1,-1...]),\n           take `{11} (res32#[-1,-1...]),\n           take `{11} (res33#[-1,-1...]),\n           take `{11} (res34#[-1,-1...]),\n           take `{11} (res35#[-1,-1...]),\n           take `{11} (res36#[-1,-1...]),\n           take `{11} (res37#[-1,-1...]),\n           take `{11} (res38#[-1,-1...]),\n           take `{11} (res39#[-1,-1...])]\n\nvalid lst = z ! 0\n  where\n    z = [True]#[~(x == -1) \/\\ y | x <- lst | y <- z ]\n\nisAPerm : [6][32] -> Bit\nproperty isAPerm lst = ~(valid lst) \\\/ perm lst (mergesort lst)\n\n\/\/ use cvc4 for isAPerm (0.595s)\n\nnondecreasing lst = z ! 0\n  where\n    z = [True]#[ if (j1 <= j2) \/\\ k then True else False\n               | k <- z | j1 <- lst | j2 <- drop `{1} lst]\n\nmergesortIsOrdered : [6][32] -> Bit\nproperty mergesortIsOrdered lst =\n    ~(valid lst) \\\/ nondecreasing (mergesort lst)\n\n\/\/ use cvc4 for mergesortIsOrdered (0.176s)\n```"}]}
{"filename":"SAW-course\/src\/lab4\/sort_com.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the 'sort' function defined in the given Cryptol module. Specifically, specify properties that prove (1) the output of 'sort' is a permutation of the input sequence, and (2) the output sequence is sorted in nondecreasing order. Use the existing 'isAPerm' and 'sortIsOrdered' properties as a basis, and extend or refine them as needed to fully verify the sorting algorithm's correctness."},{"role":"assistant","content":"```cryptol\nimport perm\n\n\/\/ Sort algorithm: let lst be the sequence to sort and let acc initially\n\/\/ be a sequence of -1s of the same length as lst.   In a round, elements \n\/\/ of lst are compared with elements of acc, starting from the right (greatest\n\/\/ elements first).  If the lst element is greater than the existing acc\n\/\/ element, the acc element moves down (to the left) by 1 position and\n\/\/ makes way for the lst element to be placed where the acc element had been.\n\/\/ If the lst element is not greater then it is placed before (to the left\n\/\/ of) the acc element it is compared with.  This process has the effect\n\/\/ that greater elements move at most one position to the right and lesser\n\/\/ elements at most one position to the left on a round.  Thus, running a\n\/\/ number of rounds equal to the length of lst, output of one round being\n\/\/ input to the next round, sorts lst.  Empty input sequence is not allowed.\nround : {n, b} (Literal 1 b, Ring b, Cmp b, fin n) => [1 + n]b -> [1 + n]b\nround lst = z ! 0\n  where\n    z = [q]#[ if lst@i > acc@(i+1)\n              then (insert (insert acc (acc@(i+1)) i) (lst@i) (i+1))\n              else (insert acc (lst@i) i)\n        | acc <- z | i <- (reverse (take `{n} [0...])) ]\n    q = insert (makeNegs lst) (last lst) ((length lst)-1)\n\ninsert lst m i = [ if k==i then m else x | x <- lst | k <- [0...]]\n\nmakeNegs lst = [ -1 | i <- lst ]\n\n\/\/ Sort a given input sequence lst - the number of rounds is equal to\n\/\/ the length of lst and obtained with i <- lst.\nsort lst =  z ! 0\n  where\n    z = [ round x | x <- [lst]#z | i <- lst ]\n\n\/\/ Returns True if and only if the sequence lst has no -1s \nvalid lst = z ! 0\n  where\n    z = [True]#[ ~(x == -1) \/\\ y | x <- lst | y <- z ]\n\n\/\/ Theorem stating a valid sequence lst implies lst is a permutation\n\/\/ of (sort lst)\nisAPerm : [6][32] -> Bit\nproperty isAPerm lst =  ~(valid lst) \\\/ perm lst (sort lst)\n\n\/\/ Returns True if and only if for every pair of consecutive numbers in\n\/\/ lst, the left number is never greater than the right number\n\/\/nondecreasing : [6][32] -> Bit\nnondecreasing lst = z ! 0\n  where\n    z = [True]#[ if (j1 <= j2) \/\\ k then True else False\n               | k <- z | j1 <- lst | j2 <- drop `{1} lst]\n\n\/\/ Theorem stating a valid sequence lst implies the sequence (sort lst)\n\/\/ is nondecreasing\nsortIsOrdered : [6][32] -> Bit\nproperty sortIsOrdered lst = ~(valid lst) \\\/ nondecreasing (sort lst)\n```"}]}
{"filename":"SAW-course\/src\/lab3A\/a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the 'plus' function and the 'add' function in the provided code. Then, create Cryptol properties suitable for verification that check the correctness of 'plus' as an addition operation on 31-bit words, and that 'add' correctly computes the cumulative sums of a sequence using 'plus'."},{"role":"assistant","content":"```cryptol\nplus : ([31],[31]) -> [31]\nplus (a, b) = if sab @ 0 then sab' + 1 else sab'\n  where\n     sab = ((zero : [1]) # a) + ((zero : [1]) # b)\n     sab' = drop `{1} sab\n\nadd xs = sums ! 0\n  where\n    sums = [0] # [plus (s, x) | s <- sums | x <- xs]\n\nv (ss) = add [ s <<< c | s <- ss@@[15,13,10,4,0,0]\n                       | c <- [15,17,21,20,8,0]]\n```"}]}
{"filename":"SAW-course\/src\/intr\/bitcoin.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property or verification script that formally proves which box contains the Bitcoin given the puzzle constraints in the bitcoin.cry file. The specification should verify that exactly one sign is true, exactly one box contains the Bitcoin, and the signs correctly correspond to the Bitcoin's location, ultimately proving that Box 1 contains the Bitcoin."},{"role":"assistant","content":"```cryptol\n\/\/ Three boxes are presented to you.  One contains Bitcoin, the other two are \n\/\/ empty. Each box has imprinted on it a clue as to its contents; the clues \n\/\/ are:\n\/\/ Box 1: \"The Bitcoin is not here\" \n\/\/ Box 2: \"The Bitcoin is not here\" \n\/\/ Box 3: \"The Bitcoin is in Box 2\"\n\/\/ One message is true; the other two are false.  Which box has the Bitcoin?\n\n\/\/ exactly one of x1 x2 x3 is True\none_is_true : Bit -> Bit -> Bit -> Bit\none_is_true x1 x2 x3 =\n  (~x1 \\\/ ~x2) \/\\ (~x1 \\\/ ~x3) \/\\ (~x2 \\\/ ~x3) \/\\ (x1 \\\/ x2 \\\/ x3)\n\n\/\/ x1 is True\/False if and only if x2 is True\/False\niff : Bit -> Bit -> Bit\niff x1 x2 = x1 == x2\n\n\/\/ not x is True if x is False and is False if x is True\nnot : Bit -> Bit\nnot x = if x then False else True\n\n\/\/ Meaning of signs\n\/\/ if sign1 is True then the Bitcoin is not in box1 otherwise it is in box1\n\/\/ if sign2 is True then the Bitcoin is not in box2 otherwise it is in box2\n\/\/ if sign3 is true then the Bitcoin is in box2 otherwise it is not in box2\nsetup : Bit -> Bit -> Bit -> Bit -> Bit -> Bit\nsetup s1 s2 s3 b1 b2 =\n  (iff s1 (not b1)) \/\\ (iff s2 (not b2)) \/\\ (iff s3 b2)\n\nimplies : Bit -> Bit -> Bit\nimplies x1 x2 = if x1 then x2 else True\n\nans : Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit\nproperty ans s1 s2 s3 b1 b2 b3 =\n  (implies ((one_is_true s1 s2 s3) \/\\ \/\/ one sign is True\n            (one_is_true b1 b2 b3) \/\\ \/\/ one box has the Bitcoin\n\t    (setup s1 s2 s3 b1 b2))   \/\/ signs match\n\t b1)                          \/\/ then b1 has the Bitcoin\n\n\/\/ Main> :l bitcoin.cry \n\/\/ Loading module Cryptol\n\/\/ Loading module Main\n\/\/ Main> :prove ans\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 0.028s, using \"Z3\")\n```"}]}
{"filename":"SAW-course\/src\/intr\/kalotan.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the Kalotan puzzle logic defined in the given Cryptol code. Your specification should capture the constraints on the sexes of the parents and the kid, the truthfulness conditions of the Kalotan tribe, and the relationships between the statements made by the kid and the parents. Include properties that can be used to check satisfiability and prove the correctness of the puzzle solution as modeled by the functions and properties in the code."},{"role":"assistant","content":"```cryptol\n\/\/ Kaloton Puzzle\n\/\/   The Kalotans are a tribe with a peculiar quirk: their females\n\/\/   always tell the truth and their males never make two consecutive\n\/\/   true statements, or two consecutive untrue statements.\n\/\/\n\/\/   An anthropologist (let's call him Worf) has begun to study them.\n\/\/   Worf does not yet know the Kalotan language.  One day, he meets a\n\/\/   Kalotan (heterosexual) couple and their child Kibi (also called \"kid\").\n\/\/   Worf asks the kid: ``Are you a boy?''  The kid answers in Kalotan,\n\/\/   which of course Worf doesn't understand.\n\/\/\n\/\/   Worf turns to the parents (who know English) for explanation.  One\n\/\/   of them (parent1) says: \"Kibi said: `I am a girl.'\" The other (parent2)\n\/\/   adds: \"Kibi is a boy.  Kibi lied.\"\n\/\/\n\/\/   Solve for the sex of the parents and Kibi.\n\n\/\/ -----------------------------------------\n\/\/ variables: parent1: T=male, F=female\n\/\/ parent2: T=male, F=female\n\/\/            kid: T=male, F=female\n\/\/            kid-said: T=male, F=female\n\/\/            kid-lied: T=yes, F=no\n\/\/\n\/\/ if parent1 is a female then \n\/\/    kibi said it is a girl (female response) \n\/\/       and\n\/\/    either kibi is a boy and did not lie \n\/\/       or (male response - alt T,F)\n\/\/          kibi is a girl and did lie \n\/\/              otherwise\n\/\/                 (male response does not matter)\n\/\/                  kibi is a boy and kibi lied  (female response)\n\nxor : Bit -> Bit -> Bit\nxor a b = a ^ b\n\nheterosexual_parents : Bit -> Bit -> Bit\nheterosexual_parents parent1 parent2 = ~(parent1 == parent2)\n\nmeaning_of_kid_lied : Bit -> Bit -> Bit -> Bit\nmeaning_of_kid_lied kid_said kid kid_lied = xor (kid_said == kid) kid_lied\n\nparents_said : Bit -> Bit -> Bit -> Bit -> Bit\nparents_said parent1 kid_said kid kid_lied =\n  if ~parent1 then (~kid_said \/\\ (xor kid kid_lied)) else (kid \/\\ kid_lied)\n\npeople_types : Bit -> Bit -> Bit -> Bit -> Bit -> Bit\nproperty people_types parent1 parent2 kid_said kid kid_lied =\n (heterosexual_parents parent1 parent2 \/\\\n  meaning_of_kid_lied kid_said kid kid_lied \/\\\n  parents_said parent1 kid_said kid kid_lied)\n\n\/\/ use: Main> :s satNum=all\n\/\/      Main> :sat people_types\n\n\/\/ The following is unsatisfiable\n\/\/ use: Main> :sat checkit1\nproperty checkit1 parent1 parent2 kid kid_said kid_lied =\n  ~(parent1 \/\\ ~parent2 \/\\ ~kid_said \/\\ kid \/\\ kid_lied) \/\\\n  (people_types parent1 parent2 kid_said kid kid_lied)\n\n\/\/ The following proves\n\/\/ use: Main> :prove checkit2\nproperty checkit2 parent1 parent2 kid kid_said kid_lied =\n  ~(people_types parent1 parent2 kid_said kid kid_lied) \\\/\n  (parent1 \/\\ ~parent2 \/\\ ~kid_said \/\\ kid \/\\ kid_lied)\n```"}]}
{"filename":"SAW-course\/src\/intr\/comprehensions.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the list comprehensions and infinite sequences defined in the given Cryptol code. Include properties that check the expected outputs for finite sequences like v01, v02, v03, v04, and v06, as well as properties verifying the correctness of infinite sequences such as v05, v07, v09, v11, and v14. Ensure the properties capture the intended behaviors described in the comments, such as the Fibonacci sequence generation, pigeonhole counting, sequence reversal, and doubling sequences."},{"role":"assistant","content":"```cryptol\n\/\/ Simple example of a comprehension\nv01 = [x | x <- [1...] | y <- [1..10]]\n\/\/ v01 is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\n\/\/ Note: x and y take values interactively and simultaneously.  x is\n\/\/ taken from an infinite list but the comprehension is controlled\n\/\/ by y as it runs out of tokens after receiving value 10.\n\nv02 = [ (x,y) | x <- [10..12] , y <- [1..4]]\n\/\/ v02 is [(10, 1), (10, 2), (10, 3), (10, 4), (11, 1), (11, 2),\n\/\/         (11, 3), (11, 4), (12, 1), (12, 2), (12, 3), (12, 4)]\n\/\/ Note: pairs are constructed from all possible combinations\n\/\/ of values of x between 10 and 12 and y between 1 and 4.\n\nv03 = [ (x,y,z) | x <- [10,11] , y <- [20,21], z <- [30,31]]\n\/\/ v03 is [(10, 20, 30), (10, 20, 31), (10, 21, 30), (10, 21, 31),\n\/\/         (11, 20, 30), (11, 20, 31), (11, 21, 30), (11, 21, 31)]\n\/\/ Note: all possible triples from values taken by x, y, and z\n\nv04 = [ (x,y,z) | x <- [10,11] , y <- [20,21] | z <- [30,31,32]]\n\/\/ v04 is [(10, 20, 30), (10, 21, 31), (11, 20, 32)]\n\/\/ Note: the rightmost | controls the number of triples output\n\nv05 = [1]#[ x+y | x <- v05 | y <- [1]#v05 ]\nv06 = take `{10} v05\n\/\/ v05 is an infinite sequence [1, 2, 3, 5, 8, ...] of Fibonaccis\n\/\/ v06 is a finite subsequence of 10 of the first 10 of those\n\/\/ Note: as v05 is being constructed, it is used inside the\n\/\/ comprehension to construct the next element of the sequence v05\n\n\/\/ Pigeon hole formulas - set base=10\nph = [1,1,1,0,1,2,2,1,1]  \/\/ shows number of pigeons in each of 9 holes\nv07 = [0]#[ x+y | x <- ph | y <- v07 ]  \/\/ sum all holes to get # pigeons\nv08 = v07 ! 0 \/\/ number of pigeons is last State\n\/\/ v07 is [0, 1, 2, 3, 3, 4, 6, 8, 9, 10]\n\/\/ v08 is 10\n\n\/\/ Condition that no hole has > 1 pigeon - set base=2\nv09 = [True]#[ (x <= 1) \/\\ y | x <- ph | y <- v09 ]\nv10 = v09 ! 0\n\/\/ v09 is 0b1111110000\n\/\/ v10 is False meaning at least one hole has more than one pigeon\n\n\/\/ The following reverses a sequence\nlst = [16,42,23,77]\nv11 = [lst] # [[b]#(tail (a >> 1)) | a <- v11 | b <- lst ]\nv12 = v11 ! 0\n\/\/ v11 is [[16, 42, 23, 77], [16, 16, 42, 23], [42, 16, 16, 42],\n\/\/         [23, 42, 16, 16], [77, 23, 42, 16]]\n\/\/ v12 is [77, 23, 42, 16]\n\n\/\/ Creates a list of 16 numbers, beginning with the first one, p,\n\/\/ as input, doubled, then followed by numbers that are double the\n\/\/ previous one.\np = 3\nv13 = [ 2*lr | lr <- [p] # v13 | k <- [1 .. 16]]\n\/\/ v13 is [6, 12, 24, 48, 96, 192, 384, 768, 1536, 3072, 6144,\n\/\/         12288, 24576, 49152, 98304, 196608]\n\n\/\/ An infinite version of the above\nv14 = [2*lr | lr <- [p] # v14 | k <- [1...]]\nv15 = take `{12} v14\n\/\/ v14 is [6, 12, 24, 48, 96, ...]\n\/\/ v15 is [6, 12, 24, 48, 96, 192, 384, 768, 1536, 3072, 6144, 12288]\n\n\/\/ Try this\n\/\/ Cryptol infers types hence things like v01 : {a} (Literal 1 a, Integral a) => [10]a\n\/\/ and like \"* Using 'Integer' for type argument 'a' of 'Cryptol::infFrom'\n\/\/ but v01:[10][32] narrows the type to a sequence of 10 32 bit numbers and the above\n\/\/ disappears.  This is a monomorphic type.  The inferred type is polymorphic.\n\/\/ Main> :l comprehensions.cry\n\/\/ Main> :s base=10\n\/\/ Main> :t v01\n\/\/ v01 : {a} (Literal 1 a, Integral a) => [10]a\n\/\/ Main> v01\n\/\/ Showing a specific instance of polymorphic result:\n\/\/  * Using 'Integer' for type argument 'a' of 'Cryptol::infFrom'\n\/\/ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\/\/ Main> v01:[10][32]\n\/\/ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\/\/ Main> :t v02\n\/\/ v02 : {a, b} (Literal 4 b, Literal 12 a) => [12](a, b)\n\/\/ Main> v02:[12]([32],[32])\n\/\/ [(10, 1), (10, 2), (10, 3), (10, 4), (11, 1), (11, 2), (11, 3),\n\/\/  (11, 4), (12, 1), (12, 2), (12, 3), (12, 4)]\n\/\/ :t v03\n\/\/ v03 : {a, b, c} (Literal 31 c, Literal 21 b, Literal 11 a) => [8](a, b, c)\n\/\/ Main> v03:[8]([32],[32],[32])\n\/\/ [(10, 20, 30), (10, 20, 31), (10, 21, 30), (10, 21, 31),\n\/\/  (11, 20, 30), (11, 20, 31), (11, 21, 30), (11, 21, 31)]\n\/\/ Main> :t v04\n\/\/ v04 : {a, b, c} (Literal 32 c, Literal 21 b, Literal 11 a) => [3](a, b, c)\n\/\/ Main> v04:[3]([32],[32],[32])\n\/\/ [(10, 20, 30), (10, 21, 31), (11, 20, 32)]\n\/\/ Main> :t v05\n\/\/ v05 : {a} (Ring a, Literal 1 a) => [inf]a\n\/\/ Main> v05\n\/\/ Showing a specific instance of polymorphic result:\n\/\/   * Using 'Integer' for type argument 'a' of '(Cryptol::+)'\n\/\/ [1, 2, 3, 5, 8, ...]\n\/\/ Main> v05:[inf][32]\n\/\/ [1, 2, 3, 5, 8, ...]\n\/\/ Main> :t v06\n\/\/ v06 : {a} (Ring a, Literal 1 a) => [10]a\n\/\/ Main> v06:[10][32]\n\/\/ [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n\/\/ Main> :t v07\n\/\/ v07 : {a} (Ring a, Literal 2 a) => [10]a\n\/\/ Main> v07:[10][32]\n\/\/ [0, 1, 2, 3, 3, 4, 6, 8, 9, 10]\n\/\/ Main> :t v08\n\/\/ v08 : {a} (Literal 2 a, Ring a) => a\n\/\/ Main> :t v11\n\/\/ v11 : {a} (Literal 77 a, Zero a) => [5][4]a\n\/\/ Main> v11:[5][4][32]\n\/\/ [[16, 42, 23, 77], [16, 16, 42, 23], [42, 16, 16, 42],\n\/\/  [23, 42, 16, 16], [77, 23, 42, 16]]\n\/\/ Main> :t v12\n\/\/ v12 : {a} (Literal 77 a, Zero a) => [4]a\n\/\/ Main> v12:[4][32]\n\/\/ [77, 23, 42, 16]\n\/\/ Main> :t v14\n\/\/ v14 : {a} (Literal 3 a, Ring a) => [inf]a\n\/\/ Main> v14:[inf][32]\n\/\/ [6, 12, 24, 48, 96, ...]\n\/\/ Main> :t v15\n\/\/ v15 : {a} (Ring a, Literal 3 a) => [12]a\n\/\/ Main> v15:[12][32]\n\/\/ [6, 12, 24, 48, 96, 192, 384, 768, 1536, 3072, 6144, 12288]\n```"}]}
{"filename":"SAW-course\/src\/intr\/bat.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that formally verifies the logical puzzle in the 'bat.cry' file, ensuring that under the given constraints about the Bitcoin's location, tiger rooms, and sign truthfulness, the Bitcoin must be in Room 7 if Room 8 is occupied. The property should encode the puzzle's rules and prove the stated conclusion using Cryptol's :prove command."},{"role":"assistant","content":"```cryptol\n\/\/  Riddle of the Bitcoin and the Tiger(s)\n\/\/  9 rooms - Bitcoin is in one room - other rooms may be empty or have tigers\n\/\/  Player wins if room with Bitcoin is selected.  Player is eaten if room with\n\/\/  a tiger is selected.\n\/\/\n\/\/  Signs on doors of rooms:\n\/\/     ROOM 1: THE BITCOIN IS IN A ROOM WITH AN UNEVEN NUMBER\n\/\/     ROOM 2: THIS ROOM IS EMPTY\n\/\/     ROOM 3: EITHER SIGN 5 TELLS THE TRUTH, OR SIGN 7 IS LYING\n\/\/     ROOM 4: SIGN 1 IS LYING\n\/\/     ROOM 5: SIGN 2 IS LYING OR SIGN 4 TELLS THE TRUTH\n\/\/     ROOM 6: SIGN 3 IS LYING\n\/\/     ROOM 7: THE BITCOIN IS NOT IN ROOM 1\n\/\/     ROOM 8: THIS ROOM HOSTS A TIGER, AND ROOM 9 IS EMPTY\n\/\/     ROOM 9: THIS ROOM HOSTS A TIGER, AND SIGN 6 IS LYING\n\/\/\n\/\/  Sign on the door with BITCOIN is True\n\/\/  Signs on doors hiding a TIGER are False\n\/\/  Signs on doors of empty rooms are either True or False\n\/\/  If you know whether room 8 is empty, you uniquely know what room the\n\/\/  BITCOIN is in\nBitcoin_in_one_room b1 b2 b3 b4 b5 b6 b7 b8 b9 =\n   ((~b1) \\\/ (~b2)) \/\\\n   ((~b1) \\\/ (~b3)) \/\\\n   ((~b1) \\\/ (~b4)) \/\\\n   ((~b1) \\\/ (~b5)) \/\\\n   ((~b1) \\\/ (~b6)) \/\\\n   ((~b1) \\\/ (~b7)) \/\\\n   ((~b1) \\\/ (~b8)) \/\\\n   ((~b1) \\\/ (~b9)) \/\\\n   ((~b2) \\\/ (~b3)) \/\\\n   ((~b2) \\\/ (~b4)) \/\\\n   ((~b2) \\\/ (~b5)) \/\\\n   ((~b2) \\\/ (~b6)) \/\\\n   ((~b2) \\\/ (~b7)) \/\\\n   ((~b2) \\\/ (~b8)) \/\\\n   ((~b2) \\\/ (~b9)) \/\\\n   ((~b3) \\\/ (~b4)) \/\\\n   ((~b3) \\\/ (~b5)) \/\\\n   ((~b3) \\\/ (~b6)) \/\\\n   ((~b3) \\\/ (~b7)) \/\\\n   ((~b3) \\\/ (~b8)) \/\\\n   ((~b3) \\\/ (~b9)) \/\\\n   ((~b4) \\\/ (~b5)) \/\\\n   ((~b4) \\\/ (~b6)) \/\\\n   ((~b4) \\\/ (~b7)) \/\\\n   ((~b4) \\\/ (~b8)) \/\\\n   ((~b4) \\\/ (~b9)) \/\\\n   ((~b5) \\\/ (~b6)) \/\\\n   ((~b5) \\\/ (~b7)) \/\\\n   ((~b5) \\\/ (~b8)) \/\\\n   ((~b5) \\\/ (~b9)) \/\\\n   ((~b6) \\\/ (~b7)) \/\\\n   ((~b6) \\\/ (~b8)) \/\\\n   ((~b6) \\\/ (~b9)) \/\\\n   ((~b7) \\\/ (~b8)) \/\\\n   ((~b7) \\\/ (~b9)) \/\\\n   ((~b8) \\\/ (~b9)) \/\\\n   (b1 \\\/ b2 \\\/ b3 \\\/ b4 \\\/ b5 \\\/ b6 \\\/ b7 \\\/ b8 \\\/ b9)\n\nBitcoin_not_in_tiger_room b1 b2 b3 b4 b5 b6 b7 b8 b9 t1 t2 t3 t4 t5 t6 t7 t8 t9 =\n   ((~b1) \\\/ (~t1)) \/\\\n   ((~b2) \\\/ (~t2)) \/\\\n   ((~b3) \\\/ (~t3)) \/\\\n   ((~b4) \\\/ (~t4)) \/\\\n   ((~b5) \\\/ (~t5)) \/\\\n   ((~b6) \\\/ (~t6)) \/\\\n   ((~b7) \\\/ (~t7)) \/\\\n   ((~b8) \\\/ (~t8)) \/\\\n   ((~b9) \\\/ (~t9))\n\nassign_values_to_signs b1 b2 b3 b4 b5 b6 b7 b8 b9\n                       t1 t2 t3 t4 t5 t6 t7 t8 t9\n                       s1 s2 s3 s4 s5 s6 s7 s8 s9 =\n  (s1 == (b1 \\\/ b3 \\\/ b5 \\\/ b7 \\\/ b9)) \/\\   \/* s1 iff bitcoin in odd # room *\/\n  (s2 == ((~t2) \/\\ (~b2))) \/\\    \/* s2 iff room 2 empty *\/\n  (s3 == (s5 \\\/ (~s7))) \/\\       \/* s3 iff sign 5 is true or sign 7 is false *\/\n  (s4 == (~s1)) \/\\               \/* s4 iff sign 1 is false *\/\n  (s5 == ((~s2) \\\/ s4)) \/\\       \/* s5 iff sign 2 is false or sign 4 is true *\/\n  (s6 == (~s3)) \/\\               \/* s6 iff sign 3 is false *\/\n  (s7 == (~b1)) \/\\               \/* s7 iff bitcoin not in room 1 *\/\n  (s8 == (t8 \/\\ (~t9) \/\\ (~b9))) \/\\  \/* s8 iff tiger in room 8. room 9 empty *\/\n  (s9 == (t9 \/\\ (~s6))) \/\\       \/* s9 iff tiger in room 9, sign 8 is false *\/\n  (~t1 \\\/ ~s1) \/\\                \/* if tiger in room 1 sign in room 1 false *\/\n  (~t2 \\\/ ~s2) \/\\                \/* if tiger in room 2 sign in room 2 false *\/\n  (~t3 \\\/ ~s3) \/\\                \/* if tiger in room 3 sign in room 3 false *\/\n  (~t4 \\\/ ~s4) \/\\                \/* if tiger in room 4 sign in room 4 false *\/\n  (~t5 \\\/ ~s5) \/\\                \/* if tiger in room 5 sign in room 5 false *\/\n  (~t6 \\\/ ~s6) \/\\                \/* if tiger in room 6 sign in room 6 false *\/\n  (~t7 \\\/ ~s7) \/\\                \/* if tiger in room 7 sign in room 7 false *\/\n  (~t8 \\\/ ~s8) \/\\                \/* if tiger in room 8 sign in room 8 false *\/\n  (~t9 \\\/ ~s9) \/\\                \/* if tiger in room 9 sign in room 9 false *\/\n  (~b1 \\\/ s1) \/\\                 \/* if bitcoin in room 1 sign 1 is true *\/\n  (~b2 \\\/ s2) \/\\                 \/* if bitcoin in room 2 sign 2 is true *\/\n  (~b3 \\\/ s3) \/\\                 \/* if bitcoin in room 3 sign 3 is true *\/\n  (~b4 \\\/ s4) \/\\                 \/* if bitcoin in room 4 sign 4 is true *\/\n  (~b5 \\\/ s5) \/\\                 \/* if bitcoin in room 5 sign 5 is true *\/\n  (~b6 \\\/ s6) \/\\                 \/* if bitcoin in room 6 sign 6 is true *\/\n  (~b7 \\\/ s7) \/\\                 \/* if bitcoin in room 7 sign 7 is true *\/\n  (~b8 \\\/ s8) \/\\                 \/* if bitcoin in room 8 sign 8 is true *\/\n  (~b9 \\\/ s9)                    \/* if bitcoin in room 9 sign 9 is true *\/\n\n\/\/ room is true or false - one of b1, b2, b3, b4, b5, b6, b7\n\/\/ so this function returns true or false - true if the bitcoin is in\n\/\/ the input room and false otherwise\nBitcoin_in_room room = room\n\nproperty Bitcoin_and_tiger b1 b2 b3 b4 b5 b6 b7 b8 b9\n                           t1 t2 t3 t4 t5 t6 t7 t8 t9\n                           s1 s2 s3 s4 s5 s6 s7 s8 s9 =\n   ~((Bitcoin_in_one_room b1 b2 b3 b4 b5 b6 b7 b8 b9) \/\\\n     (Bitcoin_not_in_tiger_room b1 b2 b3 b4 b5 b6 b7 b8 b9\n                                t1 t2 t3 t4 t5 t6 t7 t8 t9) \/\\\n     (assign_values_to_signs b1 b2 b3 b4 b5 b6 b7 b8 b9 \n                             t1 t2 t3 t4 t5 t6 t7 t8 t9\n                             s1 s2 s3 s4 s5 s6 s7 s8 s9) \/\\\n     (t8 \\\/ t9))            \/* Room 8 is occupied *\/\n    \\\/ (Bitcoin_in_room b7) \/* Proves that Bitcoin must be in Room 7 *\/\n\n\/\/ Loading module Cryptol\n\/\/ Cryptol> :l bat.cry \n\/\/ Loading module Cryptol\n\/\/ Loading module Main\n\/\/ Main> :prove Bitcoin_and_tiger \n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 0.032s, using \"Z3\")\n```"}]}
{"filename":"SAW-course\/src\/lab6C\/linear_search_1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the functions `inputOK` and `linSearchIdx` in the given Cryptol code. The specification should assert that `inputOK` returns 1 if and only if the input sequence is strictly increasing with distinct elements, and that `linSearchIdx` returns the first index of the key in the list if the input passes `inputOK`, or 255 otherwise. Include properties that check these behaviors over representative inputs."},{"role":"assistant","content":"```cryptol\n\/\/ Returns True iff elmts is a sequence whose numbers are always increasing\n\/\/ in order (all are distinct)\ninputOK : [10][16] -> [8]\ninputOK elmts = z ! 0\n  where\n    z = [1]#[ if x >= y \/\\ q == 1 then 0 else q\n            | q <- z | x <- elmts | y <- (tail elmts) ]\n\n\/\/ Returns the first location of a given key in the given list\n\/\/ or -1 (255) if the key is not in the list\nlinSearchIdx : [16] -> [10][16] -> [8]\nlinSearchIdx key xs = if (inputOK xs) == 1 then s!0 else 255\n  where\n    s = [255]#[ if (key == x \/\\ h == -1) then c else h\n              | x <- xs |  h <- s | c <- [0...]]\n```"}]}
{"filename":"SAW-course\/src\/lab2C\/foxChickenCorn.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the 'solution' function correctly identifies valid sequences of BankState transitions solving the fox, chicken, and corn river crossing puzzle. Include checks that all states are safe and valid, transitions between states are consistent with 'nextState', states are unique, and the sequence starts and ends at the specified 'startState' and 'endState'."},{"role":"assistant","content":"```cryptol\ntype OneBank = [4]\ntype BankState = {left : OneBank, right: OneBank }\n\nstartState : BankState\nstartState = { left = 0b1111, right = 0b0000 }\nendState : BankState\nendState = { left = 0b0000, right = 0b1111 }\n\nsolution : [8]BankState -> Bit\nproperty solution states =\n\t(neighborsConsistent states) \/\\\n\t(allStatesSafeAndValid states) \/\\\n\t(allStatesUnique states) \/\\\n\t(states ! 0 == endState) \/\\\n\t(states @ 0 == startState)\n\n\/\/ make sure, in sequence states, that the next state in sequence can be\n\/\/ a nextState of the current state in sequence\nneighborsConsistent states = z ! 0\n  where\n    z = [True]#[ ((y == nextState x 0) \\\/\n                  (y == nextState x 1) \\\/\n\t\t\t         (y == nextState x 2)) \/\\ p\n\t            | x <- states | y <- drop `{1} states | p <- z]\n\n\/\/ if s.left is even then s.right is odd and represents the move to opposite\n\/\/ bank.  Then out.left will be s.left OR s.right masked with 0bXXX1\n\/\/ where 0bXXX is 1 << idx and out.right will be s.right masked with 0xXXX0\n\/\/ if s.right is even then s.left is odd and represents the move to opposite\n\/\/ bank.  Then out.right will be s.right OR s.left masked with 0bXXX1\n\/\/ where 0bXXX is 1 << idx and out.left will be s.left masked with 0xXXX0\nnextState : BankState -> [4] -> BankState\nnextState s idx =\n   if s.right % 2 == 1 then\n     { left = s.left || s.right && (0b0001 || (1 << (idx+1))),\n       right = s.right && 0b1110 && (~ (1 << (idx+1):[4])) }\n   else\n     { left = s.left && 0b1110 && (~ (1 << (idx+1):[4])),\n       right = s.right || s.left && (0b0001 || (1 << (idx+1))) }\n\n\/\/ True iff all states in sequence states are safe states and are valid\nallStatesSafeAndValid : {n} (fin n) => [n]BankState -> Bit\nallStatesSafeAndValid states = z ! 0\n  where\n    z = [True]#[ safeAndValidState y \/\\ x | y <- states | x <- z ]\n\n\/\/ a state is safe and valid if no bank has a number 6 or 10 and the xor of\n\/\/ both banks is 0b1111\nsafeAndValidState : BankState -> Bit\nsafeAndValidState s =\n   ~(s.left == 10 \\\/ s.left == 6 \\\/ s.right == 10 \\\/ s.right == 6) \/\\\n\ts.left ^ s.right == 0xF\n\n\/\/ returns True iff there are two or more states in sequence states that\n\/\/ are identical\nallStatesUnique states = ~(z ! 0)\n  where\n    z = [False]#[ (states@i == states@j \/\\ ~(i == j)) \\\/ k\n\t             | k <- z | i <- [0..7] , j <- [0..7] ]\n\npp states = [ xlate state | state <- states]\n\nxlate : BankState -> [51][8]\nxlate state =\n  if (state.left == 0b1111 \/\\ state.right == 0b0000) then\n     \"fox corn chicken farmer || empty                   \"\n  else if (state.left == 0b0011 \/\\ state.right == 0b1100) then\n     \"         chicken farmer || fox corn                \"\n  else if (state.left == 0b1011 \/\\ state.right == 0b0100) then\n     \"     fox chicken farmer || corn                    \"\n  else if (state.left == 0b0111 \/\\ state.right == 0b1000) then\n     \"    corn chicken farmer || fox                     \"\n  else if (state.left == 0b1100 \/\\ state.right == 0b0011) then\n     \"               fox corn || chicken farmer          \"\n  else if (state.left == 0b0000 \/\\ state.right == 0b1111) then\n     \"                  empty || fox corn chicken farmer \"\n  else if (state.left == 0b1101 \/\\ state.right == 0b0010) then\n     \"        fox corn farmer || chicken                 \"\n  else if (state.left == 0b1000 \/\\ state.right == 0b0111) then\n     \"                    fox || corn chicken farmer     \"\n  else if (state.left == 0b0010 \/\\ state.right == 0b1101) then\n     \"                chicken || fox corn farmer         \"\n  else if (state.left == 0b0100 \/\\ state.right == 0b1011) then\n     \"                   corn || fox chicken farmer      \"\n  else\n     \"                      error                        \"\n\n\ns1 = [{left = 0b1111, right = 0b0000},\n      {left = 0b1100, right = 0b0011},\n\t\t{left = 0b1101, right = 0b0010},\n\t\t{left = 0b1000, right = 0b0111},\n\t\t{left = 0b1011, right = 0b0100},\n\t\t{left = 0b0010, right = 0b1101},\n\t\t{left = 0b0011, right = 0b1100},\n\t\t{left = 0b0000, right = 0b1111}]\n\ns2 = [{left = 0b1111, right = 0b0000},\n      {left = 0b1100, right = 0b0011},\n      {left = 0b1101, right = 0b0010},\n\t\t{left = 0b0100, right = 0b1011},\n      {left = 0b0111, right = 0b1000},\n\t\t{left = 0b0010, right = 0b1101},\n      {left = 0b0011, right = 0b1100},\n\t\t{left = 0b0000, right = 0b1111}]\n\nt1 = { left=0b0100, right=0b1011 }\nt2 = { left=0b0011, right=0b1100 }\nt3 = { left=0b1001, right=0b0110 }\nt4 = { left=0b1001, right=0b0111 }\nt5 = { left=0b1111, right=0b0000 }\nt6 = { left=0b0000, right=0b1111 }\nt7 = { left=0b1011, right=0b0100 }\nt8 = { left=0b1101, right=0b0010 }\n```"}]}
{"filename":"SAW-course\/src\/lab2C\/warmup.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol specifications to verify the correctness of the SHAState initialization and manipulation functions in the provided code. Specifically, create properties that check that stateInit initializes the SHAState fields to the expected values, and that stateManip updates the md_len field correctly while leaving other fields unchanged. Include type-level constraints and ensure the properties can be used for automated checking or proving within Cryptol."},{"role":"assistant","content":"```cryptol\nparameter\n  type w : #\n  type constraint (fin w, w <= 64, 32 <= w)\n\ntype SHAState = { h : [8][64],\n                  block : [128][8],\n                  Nl : [64],\n\t\t\t\t\t\tNh : [64],\n                  num : [32],\n\t\t\t\t\t\tmd_len : [32]\n                }\n\nstateInit : SHAState\nstateInit = { h = [1,2,3,4,5,6,7,8],\n              block = zero,\n\t\t\t\t  Nl = 11,\n\t\t\t\t  Nh = 16,\n\t\t\t\t  num = 1,\n\t\t\t\t  md_len = 128 }\n\nstateManip : SHAState -> SHAState\nstateManip s = { h = s.h,\n                 block = s.block,\n\t\t\t\t\t  Nl = s.Nl,\n\t\t\t\t\t  Nh = s.Nh,\n\t\t\t\t\t  num = s.num,\n\t\t\t\t\t  md_len = 42 }\n\nH0 : [2][w]\nH0 = [100,101]\n\nv1 : [2][32]\nv1 = [23,34]\n\ntype v2 = [2][32]\nv2 = [23,34]\n```"}]}
{"filename":"SAW-course\/src\/lab2C\/solutions.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol specifications and properties to verify the correctness of the functions defined in the given code snippet. Specifically, specify properties for areaCircle to ensure it computes the area correctly using the radius, for nudgeCircle to verify that it correctly updates the circle's position by the given displacement, and for calcBMI and calcBMIimp to confirm they compute Body Mass Index consistently given equivalent inputs. Include properties that relate calcBMI and calcBMIimp outputs for inputs representing the same physical measurements in different units."},{"role":"assistant","content":"```cryptol\nimport Float\n\ntype Circle = { radius : Rational, left : Float16, top : Float16 }\ntype Displacement = { left : Float16, top : Float16 }\n\naCircle : Circle\naCircle = { radius=(ratio 5 2), left=20, top=16}\n\nareaCircle : Circle -> Rational\nareaCircle b = (b.radius * b.radius * (ratio 355 113))\n\nc = areaCircle { radius=(ratio 5 2), left=0, top=0 }\n\naCircleArea = areaCircle aCircle\n\nnudgeCircle : Circle -> Displacement -> Circle\nnudgeCircle circle d =\n   { radius = circle.radius, left = circle.left+d.left, top = circle.top+d.top }\n\ndisp : Displacement\ndisp = { left= 12, top=2 }\n\nnewDisp : Displacement \nnewDisp = { left = -32, top=2 }\n\nmovedaCircle = nudgeCircle aCircle disp\nsecondTry = nudgeCircle aCircle newDisp\n\ntype BMI = { weight : Float16, height : Float16 }\ntype BMIimp = { weight : Float16, feet : Float16, inches : Float16 }\n\ncalcBMI : BMI -> Float16\ncalcBMI bmi = bmi.weight \/. bmi.height \/. bmi.height * 10000\n\ncalcBMIimp : BMIimp -> Float16\ncalcBMIimp bmi = bmi.weight \/. (bmi.feet*12+bmi.inches) \/. (bmi.feet*12+bmi.inches) * 703\n\nt1 = { weight=80, height=174 }\nt2 = { weight=180.0, feet=5.0, inches=8.5 }\n```"}]}
{"filename":"SAW-course\/src\/lab2D\/racetrack.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the correctness criteria for the racetrack fueling station algorithm. The specification should state that the returned station index allows a race car starting with an empty tank to complete the entire circuit without running out of fuel, given the locations and fuel amounts at each station. Include properties that verify the total fuel matches the circuit requirements and that the chosen station is valid according to the fuel deficit logic in the code."},{"role":"assistant","content":"```cryptol\n\/\/ There are a number of fueling stations located at various points around\n\/\/ a race circuit. Suppose the amount of fuel at each fueling station is\n\/\/ different but that the total fuel around the circuit is exactly what is\n\/\/ needed by a race car to make one complete circuit.\n\/\/\n\/\/ Find the point on the circuit from which a race car with an empty tank\n\/\/ may make one complete circuit without running out of fuel by tanking\n\/\/ up at every fueling station in the circuit. Assume the tank is large\n\/\/ enough to hold enough fuel to complete the circuit.\n\n\/\/ location of fueling stations is the percentage of total circuit distance\n\/\/ from the 'starting line'.  Ratios are all less than (ratio 1 1) and\n\/\/ are progressively increasing.\nloc = [ (ratio 2 10), (ratio 3 10), (ratio 45 100), (ratio 49 100),\n        (ratio 71 100), (ratio 78 100), (ratio 81 100), (ratio 98 100)]\n\n\/\/ amount of fuel at each fueling station is a percentage of total fuel\n\/\/ in all fueling stations\ngas = [ (ratio 1 10), (ratio 13 100), (ratio 1 10), (ratio 15 100),\n        (ratio 23 100), (ratio 7 100), (ratio 17 100), (ratio 5 100)]\n\n\/\/ State: (fuel_seen, fuel_deficit, best_station_so_far)\ns = [(0,0,-1)]#[(if (ps-ss.0 > ss.1) then (ss.0+fs, ps-ss.0, i)\n                                     else (ss.0+fs,ss.1,ss.2))\n               | fs <- gas | ps <- loc | ss <- s | i <- [0 ...]]\n\nstation = (s ! 0).2\nstation_location = loc @ station\n\n\/\/ ps = % of track covered\n\/\/ ss.0 = % of fuel seen\n\/\/ ps-ss.0 is the fuel deficit\n```"}]}
{"filename":"SAW-course\/src\/lab2D\/comprehensions.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that specify and verify the correctness of the list comprehensions defined in the file comprehensions.cry. Include properties that check the expected outputs of finite comprehensions (e.g., v01, v02, v03, v04), the correctness of infinite sequences and their finite prefixes (e.g., v05, v06, v14, v15), and the correctness of computations such as the pigeonhole sums (v07, v08), the boolean condition on pigeon counts (v09, v10), the list reversal (v11, v12), and the race course problem (v16). Ensure the properties capture the intended semantics and expected results as described in the comments."},{"role":"assistant","content":"```cryptol\n\/\/ Simple example of a comprehension\nv01 = [x | x <- [1...] | y <- [1..10]]\n\/\/ v01 is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\n\/\/ Note: x and y take values interactively and simultaneously.  x is\n\/\/ taken from an infinite list but the comprehension is controlled\n\/\/ by y as it runs out of tokens after receiving value 10.\n\nv02 = [ (x,y) | x <- [10..12] , y <- [1..4]]\n\/\/ v02 is [(10, 1), (10, 2), (10, 3), (10, 4), (11, 1), (11, 2),\n\/\/         (11, 3), (11, 4), (12, 1), (12, 2), (12, 3), (12, 4)]\n\/\/ Note: pairs are constructed from all possible combinations\n\/\/ of values of x between 10 and 12 and y between 1 and 4.\n\nv03 = [ (x,y,z) | x <- [10,11] , y <- [20,21], z <- [30,31]]\n\/\/ v03 is [(10, 20, 30), (10, 20, 31), (10, 21, 30), (10, 21, 31),\n\/\/         (11, 20, 30), (11, 20, 31), (11, 21, 30), (11, 21, 31)]\n\/\/ Note: all possible triples from values taken by x, y, and z\n\nv04 = [ (x,y,z) | x <- [10,11] , y <- [20,21] | z <- [30,31,32]]\n\/\/ v04 is [(10, 20, 30), (10, 21, 31), (11, 20, 32)]\n\/\/ Note: the rightmost | controls the number of triples output\n\nv05 = [1]#[ x+y | x <- v05 | y <- [1]#v05 ]\nv06 = take `{10} v05\n\/\/ v05 is an infinite sequence [1, 2, 3, 5, 8, ...] of Fibonaccis\n\/\/ v06 is a finite subsequence of 10 of the first 10 of those\n\/\/ Note: as v05 is being constructed, it is used inside the\n\/\/ comprehension to construct the next element of the sequence v05\n\n\/\/ Pigeon hole formulas - set base=10\nph = [1,1,1,0,1,2,2,1,1]  \/\/ shows number of pigeons in each of 9 holes\nv07 = [0]#[ x+y | x <- ph | y <- v07 ]  \/\/ sum all holes to get # pigeons\nv08 = v07 ! 0 \/\/ number of pigeons is last State\n\/\/ v07 is [0, 1, 2, 3, 3, 4, 6, 8, 9, 10]\n\/\/ v08 is 10\n\n\/\/ Condition that no hole has > 1 pigeon - set base=2\nv09 = [True]#[ (x <= 1) \/\\ y | x <- ph | y <- v09 ]\nv10 = v09 ! 0\n\/\/ v09 is 0b1111110000\n\/\/ v10 is False meaning at least one hole has more than one pigeon\n\n\/\/ The following reverses a sequence\nlst = [16,42,23,77]\nv11 = [lst] # [[b]#(tail (a >> 1)) | a <- v11 | b <- lst ]\nv12 = v11 ! 0\n\/\/ v11 is [[16, 42, 23, 77], [16, 16, 42, 23], [42, 16, 16, 42],\n\/\/         [23, 42, 16, 16], [77, 23, 42, 16]]\n\/\/ v12 is [77, 23, 42, 16]\n\n\/\/ Creates a list of 16 numbers, beginning with the first one, p,\n\/\/ as input, doubled, then followed by numbers that are double the\n\/\/ previous one.\np = 3\nv13 = [ 2*lr | lr <- [p] # v13 | k <- [1 .. 16]]\n\/\/ v13 is [6, 12, 24, 48, 96, 192, 384, 768, 1536, 3072, 6144,\n\/\/         12288, 24576, 49152, 98304, 196608]\n\n\/\/ An infinite version of the above\nv14 = [2*lr | lr <- [p] # v14 | k <- [1...]]\nv15 = take `{12} v14\n\/\/ v14 is [6, 12, 24, 48, 96, ...]\n\/\/ v15 is [6, 12, 24, 48, 96, 192, 384, 768, 1536, 3072, 6144, 12288]\n\n\/\/ Race course problem, location and fuel\n\/\/ loc: percentage of racetrack from a starting point for each\n\/\/      fueling station.  All ratios are less than 1\n\/\/ gas: percentage of total fuel needed to traverse course at\n\/\/      each station.  Sum of all ratios is 1\nloc = [(ratio 2 10),(ratio 3 10),(ratio 45 100),(ratio 49 100),\n       (ratio 71 100),(ratio 78 100),(ratio 81 100),(ratio 98 100)]\ngas = [(ratio 1 10),(ratio 13 100),(ratio 1 10),(ratio 15 100),\n       (ratio 23 100),(ratio 7 100),(ratio 17 100),(ratio 5 100)]\ngas_sum = sum gas\n\/\/ gas_sum is (ratio 1 1)\nv16 = [(0,0,-1)]#[(if (ps-ss.0 > ss.1) then (ss.0+fs, ps-ss.0, i)\n                                       else (ss.0+fs, ss.1, ss.2))\n                 | fs <- gas | ps <- loc | ss <- v16 | i <- [0 ...]]\nstation_to_start_from = (v16 ! 0).2\nlocation_of_station = loc @ station_to_start_from\n```"}]}
{"filename":"SAW-course\/src\/lab2D\/solutions.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the functions fmax, member, remove, perm, and nondecreasing as defined in the given Cryptol code. The properties should capture the intended behavior described in the comments, such as fmax returning the maximum element and its first occurrence index, member correctly identifying membership, remove deleting the first occurrence of an element and appending -1, perm checking if two sequences are permutations of each other, and nondecreasing verifying that a sequence is sorted in non-decreasing order. Ensure the properties are suitable for automated checking or proving within Cryptol."},{"role":"assistant","content":"```cryptol\n\/\/ Find the maximum number in lst and return a tuple with that\n\/\/ number on the left and its first occurrence in lst from the\n\/\/ left on the right.  Note: fmax [] returns (-1,-1) as expected.\nfmax lst = (res ! 0).0\n  where\n    res = [(-1,-1)]#[ if (ss.0 < p) then (p,i) else ss\n                    | p <- lst | ss <- res | i <- [0...]]\n\n\/\/ Returns True if n is a member of sequence lst, otherwise\n\/\/ returns False.  member [] 4 returns False as expected.  \n\/\/ Elements of lst must be non-negative.\nmember lst n = (res ! 0)\n  where\n    res = [False]#[ s \\\/ (p == n) | p <- lst | s <- res ]\n\n\/\/ If n is a member of lst return lst with the first occurrence\n\/\/ of n in lst removed and -1 appended to the end of the output\n\/\/ sequence.  Without the -1 appended some output sequences would\n\/\/ be shorter than others and that constitutes a type mismatch\n\/\/ in Cryptol.  Note: remove [] 3 returns [] as expected.\nremove lst n = drop `{2} [w.0 | w <- res]\n  where\n    res = [(-1,False)]#[ if (q.1==False \/\\ ~(za == n)) then (za, q.1)\n                                                       else (zb, True)\n          | za <- [-1]#lst | zb <- lst#[-1] | q <- res ]\n\n\/\/ Returns True if x and y are permutations and False otherwise.\n\/\/ Note: in this version x and y are required to have the same\n\/\/ length which must be greater than 0.  Negative numbers are\n\/\/ permitted.\nperm x y = (res ! 0).1\n  where\n    res = [ ((remove q.0 p), (member q.0 p) \/\\ q.1)\n          | q <- [(y,True)]#res | p <- x ]\n\n\/\/ Returns True iff input sequence is in non-decreasing order\n\/\/ Note: does not work on empty sequences\nnondecreasing lst = (res ! 0)\n  where \n    res = [True]#[ if (j1 <= j2) \/\\ k then True else False\n                 | k <- res | j1 <- lst | j2 <- drop `{1} lst]\n```"}]}
{"filename":"SAW-course\/src\/lab2E\/perm.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the functions 'remove', 'member', and 'perm' defined in the given module. The properties should check that 'remove' correctly removes an element from a list, 'member' accurately detects membership of an element in a list, and 'perm' correctly determines whether two lists are permutations of each other. Include properties suitable for :prove or :check commands."},{"role":"assistant","content":"```cryptol\nmodule perm where\n\nremove : {n, a} (Eq a, Ring a, Literal 1 a, fin n) => [n]a -> a -> [n]a\nremove lst n = drop `{2} [w.0 | w <- res]\n  where\n    res = [(-1,False)]#[ if (q.1 == False \/\\ ~(za == n)) then (za, q.1)\n                                                         else (zb, True)\n                       | za <- [-1]#lst | zb <- lst#[-1] | q <- res ]\n\nmember : {n, a} (Eq a, fin n) => [n]a -> a -> Bit\nmember lst n = (res ! 0)\n  where\n    res = [False]#[ ss \\\/ (p == n) | p <- lst | ss <- res ]\n\nperm :\n  {n, m, a} (Literal 1 a, Ring a, Eq a, fin n, fin m) => [n]a -> [m]a -> Bit\nperm x y = if (length x) == 0 \/\\ (length y) == 0 then True else\n           if (length x) == (length y) then (res ! 0).1 else False\n  where\n    res = [ ((remove q.0 p), (member q.0 p) \/\\ q.1)\n          | q <- [(y,True)]#res | p <- x ]\n```"}]}
{"filename":"SAW-course\/src\/lab2E\/bsort.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the function `bsort` produces a sorted permutation of its input list. Include properties that check the output is ordered and that it is a permutation of the input, leveraging the existing `perm` module and the `valid` predicate."},{"role":"assistant","content":"```cryptol\nmodule bsort where\nimport perm\n\n\/\/ bbl takes a literal n and an ordered sequence seq and places n in seq\n\/\/ so that seq remains ordered.  If seq is empty [n] (plus padding) is\n\/\/ returned. If n is less than the first element of seq then n is added\n\/\/ to the beginning of seq.  Otherwise bbl is called recursively and\n\/\/ returns an ordered sequence whereupon the 1st literal of seq is\n\/\/ prepended to the result and returned.\n\/\/ bb takes a padded sequence as input and recursively calls bbl where\n\/\/ n is the first literal of the input sequence.  The recursion sets up\n\/\/ a stack of literals to add to the output list and begins to establish\n\/\/ an output list when the input to seq is only the padding.  Thus, when\n\/\/ the stacked literals are ready to be added to the output list, what\n\/\/ they are added to is ordered and will remain ordered as stacked\n\/\/ literals are added to seq.\n\/\/ bsort just calls bb on the padded input sequence.  The output of bb\n\/\/ is trimmed by take.\nbsort : {n, a} (Cmp a, Integral a, Literal 1 a, fin n) => [n]a -> [n]a\nbsort lst = take `{n} (bb (lst#[-1,-1...]))\n  where\n    bb seq = if (seq@0) == -1 then seq else (bbl (head seq) (bb (tail seq)))\n    bbl n seq =\n      if ((seq@0) == -1) then [n]#[-1,-1...]\n      else if (n < (seq@0)) then [n]#seq\n      else [(seq@0)]#(bbl n (tail seq))\n\nvalid lst = z ! 0\n  where\n    z = [True]#[~(x == -1) \/\\ y | x <- lst | y <- z ]\n\nisAPerm : [16][4] -> Bit\nproperty isAPerm lst = ~(valid lst) \\\/ (perm lst (bsort lst))\n\/\/property isAPerm lst = if (valid lst) then (perm lst (bsort lst)) else True\n\nres00 = bsort []\nres01 = bsort [1]\nres02 = bsort [2,1]\nres03 = bsort [1,2]\nres04 = bsort [7,3,2,8,1,9,2,3,4,1,8,9,4,2,3]\nres05 = bsort [0,0,0,0,1,1,1,1,2,2,2,2,3,3,3]\nres06 = bsort [3,3,3,2,2,2,2,1,1,1,1,0,0,0,0]\n```"}]}
{"filename":"SAW-course\/src\/lab2E\/mrgsrt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the mergesort implementation in the given module. Specifically, define properties that prove mergesort returns a list that is a permutation of the input list and that the output list is sorted in nondecreasing order. Use the existing helper functions and predicates such as 'perm', 'valid', and 'nondecreasing' to express these properties. Ensure the properties handle the padded infinite list representation used internally by mergesort."},{"role":"assistant","content":"```cryptol\nmodule mrgsrt where\n\nremove lst n = drop `{2} [w.0 | w <- res]\n  where\n    res = [(-1,False)]#[ if (q.1 == False \/\\ ~(za == n)) \n                         then (za, q.1)\n                         else (zb, True)\n                       | za <- [-1]#lst | zb <- lst#[-1] | q <- res ]\n\nmember lst n = (res ! 0)\n  where\n    res = [False]#[ ss \\\/ (p == n) | p <- lst | ss <- res ]\n\nperm x y = if (length x) == 0 \/\\ (length y) == 0 then True else\n           if (length x) == (length y) then (res ! 0).1 else False\n  where\n    res = [ ((remove q.0 p), (member q.0 p) \/\\ q.1)\n          | q <- [(y,True)]#res | p <- x ]\n\n\/************************************************************************\/\n\/*  The goal of this page:                                              *\/\n\/*    Show how a specification of an operation on finite lists          *\/\n\/*    can be expressed recursively by switching to infinite lists       *\/\n\/*    and back                                                          *\/\n\/*  Define mergesort on lists of positive numbers and prove correctness *\/\n\/************************************************************************\/\n\/* Mergesort - but only for positive numbers \n   subfunctions operate on infinite lists to allow for recursion\n   subfunctions are as follows:\n   splito: \n     Input - lst=finite list\n     Output - infinite list, padded with -1s after the split elements\n     Process: best described as [ lst@i | i <- [1,3...] ]\n   splite:\n     Input - lst=finite list\n     Output - infinite list, padded with -1s after the split elements\n     Process: best described as [ lst@i | i <- [0,2...] ]\n   merge:\n     Inputs: px, py - two infinite lists in nondecreasing order (padded with -1s)\n     Output: infinite list, nondecreasing, containing all of px & py, padded\n     Process: merge two padded infinite lists, up to the padding\n     if px@0 is -1 then return py, if py@0 is -1 then return px\n     otherwise if px@0 is less than py@0 concat px@0 with (merge (tail(px) py)\n     otherwise concat py@0 with (merge px (tail py))\n   mergesrt:\n     Input: p=infinite list (padded)\n     Output: padded, nondecreasing infinite list that is a permutation of x\n     Process: sort list p up to the padding\n     recursively merge the mergesrt of the even elements of p with the mergesrt\n     of the odd elements of p\n*\/\n\n\/\/  Input: lst - -1 padded finite sequence of numbers\n\/\/  Output: lst with only odd indexed elements followed by -1 padding\nsplito : {n,a} [n]a -> [inf]a\nsplito lst = [ lst@i | i <- [1,3...] ]\n\n\/\/  Input: lst - -1 padded finite sequence of numbers\n\/\/  Output: lst with only even indexed elements followed by -1 padding\nsplite : {n,a} [n]a -> [inf]a\nsplite lst = [ lst@i | i <- [0,2...] ]\n\n\/\/  Inputs: px, py: two infinite lists in nondecreasing order (padded with -1s)\n\/\/  Output: infinite list, nondecreasing, containing all of px and py, padded\nmerge : {a} (Literal 1 a, Ring a, Cmp a) => [inf]a -> [inf]a -> [inf]a\nmerge px py = \n      if px@0 == -1 then py\n      else if py@0 == -1 then px\n      else if px@0 < py@0 then [px@0]#(merge (tail px) py)\n      else [py@0]#(merge px (tail py))\n\n\/\/  Input: finite sequence lst of numbers\n\/\/  Output: finite nondecreasing sequence of numbers that is permutation of lst\nmergesort : {cnt, a} (fin cnt, fin a, a >= 1, cnt >= 0) => [cnt][a] -> [cnt][a]\nmergesort lst = take `{cnt} (mergesrt ax)\n  where\n    mergesrt p = \n      if (p@0 == -1) \\\/ (p@1 == -1) then p\n      else merge (mergesrt (splite p)) (mergesrt (splito p))\n    ax = lst#[-1,-1 ...]\n\nres00 = take `{3} (splite [1,2,3,4,5,6])\nres01 = take `{3} (splite [1,2,3,4,5,6,7])\nres02 = take `{4} (splite [1,2,3,4,5,6,7,8])\n\nres10 = take `{3} (splito [1,2,3,4,5,6])\nres11 = take `{4} (splito [1,2,3,4,5,6,7])\nres12 = take `{4} (splito [1,2,3,4,5,6,7,8])\n\nres20 = take `{8} (merge ([1,5,7,10]#[-1,-1 ...]) ([3,7,11,14]#[-1,-1 ...]))\n\nres30 = mergesort [6,7,8,2,3,4,1,11,23,5]\nres31 = mergesort [1]\nres32 = mergesort [2,2]\nres33 = mergesort [2,1]\nres34 = mergesort [9,8,7,6,5,4,3,2,1]\nres35 = mergesort [9,8,7,6,5,4,3,2,1,6]\nres36 = mergesort [9,8,7,6,5,4,3,2,1,6,10]\nres37 = mergesort [9,8,7,6,5,4,3,2,10,6,1]\nres38 = mergesort [1,9,8,7,6,5,4,3,2,1,6]\nres39 = mergesort [10,9,8,7,6,5,4,3,2,1,6]\n\nresults = [take `{11} (res30#[-1,-1...]),\n           take `{11} (res31#[-1,-1...]),\n\t\t\t  take `{11} (res32#[-1,-1...]),\n\t\t\t  take `{11} (res33#[-1,-1...]),\n\t\t\t  take `{11} (res34#[-1,-1...]),\n\t\t\t  take `{11} (res35#[-1,-1...]),\n\t\t\t  take `{11} (res36#[-1,-1...]),\n\t\t\t  take `{11} (res37#[-1,-1...]),\n\t\t\t  take `{11} (res38#[-1,-1...]),\n\t\t\t  take `{11} (res39#[-1,-1...])]\n\nvalid lst = z ! 0\n  where\n    z = [True]#[~(x == -1) \/\\ y | x <- lst | y <- z ]\n\nisAPerm : [6][32] -> Bit\nproperty isAPerm lst = if valid lst then perm lst (mergesort lst) else True\n\nnondecreasing lst = (res ! 0)\n  where\n    res = [True]#[ if (j1 <= j2) \/\\ k then True else False\n                 | k <- res | j1 <- lst | j2 <- drop `{1} lst]\n\nmergesortIsOrdered : [6][32] -> Bit\nproperty mergesortIsOrdered lst =\n   if valid lst then nondecreasing (mergesort lst) else True\n```"}]}
{"filename":"SAW-course\/src\/lab2E\/caesar.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property and proof script that verifies the correctness of the Caesar cipher implementation in the provided code. Specifically, prove that decrypting an encrypted message with the complementary key (95 - key) returns the original plaintext for messages up to 512 characters long."},{"role":"assistant","content":"```cryptol\n\/* A simple caesar cipher\n   Rotate the ascii table by a fixed amount (s) and index into the remapped\n   ascii table by the input character to compute the ciphertext\n   In this version the ascii table is shrunk to 95 printable characters\n   so to decrypt use 95-s *\/\n\/*\n  Rotate the ascii table from ' ' to '~'  by s positions\n  Examples: map 0 = [32,33,34,...,124,125,126]\n            map 1 = [33,34,35,...,125,126,32]\n            map 2 = [34,35,36,...,126,32,33]\n            map 64 = [96,97,98,...,93,94,95]\n*\/\nrot s = [' ' .. '~'] <<< s\n\nshift c key = (rot key) @ (c - ' ')\n\ncaesar key msg = [ shift c key | c <- msg ]\n\n\/\/ enc:[_][8]\nenc = caesar 11 \"How Now Brown Cow\"\nenc_ascii = show (enc)\n\n\/\/ dec:[_][8]\ndec = caesar 84 enc\ndec_ascii = show (caesar (95-11) enc)\n\nshow s = [ c:Char | c <- s]\n\n\/\/ Prove it works for messages up to 256 chracters long -\n\/\/ :s prover=abc\n\/\/ :prove itWorks\n\/\/ Q.E.D.\n\/\/ (Total Elapsed Time: 8.091s, using \"ABC\")\nitWorks : [512][8] -> [8] -> Bit\nproperty itWorks pt key = (caesar (95-key) (caesar key pt)) == pt\n```"}]}
{"filename":"SAW-course\/src\/lab2E\/hamming.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the 'hamming' function defined in the given code. Specifically, create specifications that ensure the output stream is sorted in increasing order, contains only numbers whose prime factors are from the input primes list, and that the 'merge' and 'times' helper functions behave as intended. Additionally, write properties to check that no output number is a multiple of 7 when using the primes list [3,5,11], as hinted by the existing 'hamGood' property."},{"role":"assistant","content":"```cryptol\n\/\/ Hammings problem - given primes list in increasing order, find all\n\/\/ numbers whose prime factors are all in the primes list.\n\n\/\/ multiply all integers of a stream by a scalar - input is a stream s\n\/\/ of integers and a number m.  Output is a stream such that each number\n\/\/ is m times its corresponding number in the input stream.\ntimes s m = [(s@0)*m]#times (tail s) m\n\n\/\/ merge two streams of integers - input is two integer streams in\n\/\/ increasing order.  Output is single stream in increasing order, all\n\/\/ output tokens exist in input streams.\nmerge x y = if (x@0) < (y@0) then [x@0]#merge (tail x) y\n                             else [y@0]#merge x (tail y)\n\n\/\/ compute the hamming sequence for a given set of prime numbers.  The\n\/\/ input list of primes is in increasing order.\nhamming primes = ham primes 0\n  where \n    ham p idx =\n      if ((length p) == 0) then [-1,-1...]\n      else if (length p)-1 == idx then\n           [p @ idx] # times (ham p idx) (p@idx)\n      else\n           [p @ idx] # merge (times (ham p idx) (p@idx)) (ham p (idx+1))\n\nhamGood : [64] -> [100][64] -> Bit  \/* no output number is multiple of 7 *\/\nproperty hamGood x y = \n  ~((x <= 99) \/\\ (y == (take `{100} (hamming [3,5,11])))) \\\/ ~((y@x)%7 == 0)\n```"}]}
{"filename":"SAW-course\/src\/lab2E\/coins.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property specification that verifies the correctness of the coinPuzzle function. The specification should ensure that for given inputs n (number of coins) and s (total sum in cents), the function returns true only if the counts of pennies (a), nickels (b), dimes (c), and quarters (d) sum to n coins and their total value equals s cents, with all counts within valid bounds. Include properties that check the coinCount and coinSum helper functions are consistent with the puzzle constraints."},{"role":"assistant","content":"```cryptol\n\/\/ The puzzle goes like this:\n\/\/ You've got n coins that add up to s cents - what are they?\n\/\/ Use currying - for this example #coins is 30, total sum is 109 cents\n\ncoinPuzzle : [10] -> [10] -> [10] -> [10] -> [10] -> [10] -> Bit\ncoinPuzzle n s a b c d =\n  (coinCount a b c d n) \/\\ (coinSum a b c d n s) \/\\ (n < 100) \/\/ avoid overflow\n\ncoinSum a b c d n s =\n  ((a + 5*b + 10*c + 25*d) == s) \/\\ (n <= s)\n\ncoinCount a b c d n =\n  (((a + b + c + d) == n) \/\\       \/\/ the coin count adds up to requested n\n                                   \/\/ number coins of any type doesn't exceed n\n   (a <= n \/\\ b <= n \/\\ c <= n \/\\ d <= n))  \n\ncheck a b c d = a*1 + b*5  + c*10 + d*25\n\n\/\/ run it like this:\n\/\/ Main> :set base=10\n\/\/ Main> :set satNum = all\n\/\/ Main> :sat coinPuzzle 30 109\n\/\/ Satisfiable\n\/\/ coinPuzzle 30 109 19 7 3 1 = True\n\/\/ coinPuzzle 30 109 24 1 3 2 = True\n\/\/ coinPuzzle 30 109 14 13 3 0 = True\n\/\/ coinPuzzle 30 109 19 4 7 0 = True\n\/\/ Models found: 4\n\/\/ (Total Elapsed Time: 0.055s, using \"Z3\")\n```"}]}
{"filename":"SAW-course\/src\/lab2B\/tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the functions defined in the file, including 'tes1' (permutation), 'allButLast', 'rev' (reverse), 'funky_0', 'funky_1', 'funky_2' (sequence generators), 'sum_0', 'sum_1' (cumulative sums), 'fib_1', 'fib_2' (Fibonacci sequences), and 'split' (bit splitting). The properties should capture expected behaviors such as permutation correctness, sequence generation patterns, cumulative sum correctness, Fibonacci sequence properties, and splitting correctness. Ensure the properties are suitable for Cryptol's :prove or :check commands to verify these functions against their intended specifications."},{"role":"assistant","content":"```cryptol\n\/* a permutation *\/\ntes1 x = [ x@i | i <- [0,3,2,1,4] ]\nres00 = tes1 [1,2,3,4,5]\n\nallButLast : {a, b} [1 + b]a -> [b]a\nallButLast x = [ a | a <- x | i <- (tail x) ]\n\nres01 = allButLast [1,2,3,4,5]\n\n\/* reverse a sequence *\/\nrev : {a, b} (fin b) => [1 + b]a -> [1 + b]a\nrev x = (z!0)\n  where \n    z = [x]#[ [b]#(allButLast a) | b <- x | a <- z ]\n\nres02 = rev [1,2,3,4,5,6,7]\n\n\/* Create a list of 16 numbers, beginning with the first one as input\n   doubled, then followed by numbers that are double the previous one \n   in the list  *\/\nfunky_0: [32] -> [16][32]\nfunky_0 x = iv\n   where iv = [ 2*lr | lr <- [x] # iv | k  <- [1 .. 16] ]\n\nres03 = funky_0 2\n\n\/* Slight variation on the one above the first number is not doubled *\/\nfunky_1: [32] -> [16][32]\nfunky_1 x = [x]#iv\n   where iv = [ 2*lr | lr <- [x] # iv | k  <- [1 .. 15] ]\nres04 = funky_1 2\n\n\/* Infinite version of above *\/\nfunky_2: [32] -> [inf][32]\nfunky_2 (x) = [x]#iv\n  where iv  = [ 2*lr | lr <- [x] # iv | k  <- [1 ...] ]\n\nres05 = funky_2 2\n\n\/* The ith term in the output list is the sum of input terms from index 0 to\n   index i.  Hence [1 4 8 17] -> [1 5 13 30]  (superincreasing sequence) *\/\nsum_0 xs = ys\n  where ys = [ x + y | x <- xs | y <- [0] # ys ]\n\nres06 = sum_0 [1,2,3,4,5]\n\nsum_1 xs = ys\n  where ys = [ x + y | x <- ys | y <- [0] # ys ]\n\nres07 = sum_1 [1,2,3,4,5]\n\n\/* Fibonnaci numbers *\/\n\/*   1 1 2 3  5  8 13 21 ...   y <- [1 1] # ys\n     1 2 3 5  8 13 21 ...      x <- [1] # ys\n    --------------------------------------------\nys = 2 3 5 8 13 21 34 ...      ys    *\/\n\nfib_1 = take `{100} ([1,1]#ys)\n  where \n    ys = [ x+y | x <- ([1]:[1][256])#ys | y <- ([1,1]:[2][256])#ys ]\n\n\n\/* Fibonnaci numbers - Wow! only n numbers are pulled!! *\/\nfib_2: [256]->[256]\nfib_2 n = (([1,1]#ys)@(n-1))\n  where \n    ys = [ x+y | x <- [1]#ys | y <- [1,1]#ys ]\n\nres08 = fib_2 100\n\n\/* split splits as needed!! *\/\nres09:[2][24]\nres09 = split(0x570248D00425)  \/* [0x48d00425,0x00005702]       *\/\nres10:[4][12]\nres10 = split(0x570248D00425)  \/* [0x0425,0x48d0,0x5702,0x0000] *\/\nres11:[8][6]\nres11 = split(0x570248D00425)  \/* [0x25,0x04,0xd0,0x48,0x02,0x57,0x00,0x00] *\/\nres12:[2][2][12]\nres12 = split(split(0x570248D00425))  \/* [[0x0425,0x48d0] [0x5702,0x0000]]  *\/\n\nsbox1 : [4][16][4]\nsbox1 = [[14, 4,13, 1, 2,15,11, 8, 3,10, 6,12, 5, 9, 0, 7],\n         [ 0,15, 7, 4,14, 2,13, 1,10, 6,12,11, 9, 5, 3, 8],\n         [ 4, 1,14, 8,13, 6, 2,11,15,12, 9, 7, 3,10, 5, 0],\n         [15,12, 8, 2, 4, 9, 1, 7, 5,11, 3,14,10, 0, 6,13]\n        ]\ns1 = sbox1 @ [True,True]   @ [True,True,True,True]\ns2 = sbox1 @ [True,True]   @ [False,True,True,True]\ns3 = sbox1 @ [True,True]   @ [True,False,True,True]\ns4 = sbox1 @ [True,True]   @ [False,False,True,True]\ns5 = sbox1 @ [False,True]  @ [True,True,True,True]\ns6 = sbox1 @ [True,False]  @ [True,True,True,True]\ns7 = sbox1 @ [False,False] @ [True,True,True,True]\ns8 = reverse(s7)\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Common\/utils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the functions defined in the Common::utils module, including 'while', 'dowhile', 'ZtoBV', 'BVtoZ', 'ZtoZ', 'isEven', 'abs', 'unzip', 'mul2', 'mul3', 'mul4', 'mul8', 'half', and 'mp_mod_inv'. The properties should capture expected behaviors such as loop invariants for 'while' and 'dowhile', correctness of conversions between integer and bitvector representations, arithmetic properties of multiplication functions, and correctness and termination of the modular multiplicative inverse function 'mp_mod_inv'. Ensure the specifications are suitable for automated verification using Cryptol's :prove or :check commands."},{"role":"assistant","content":"```cryptol\nmodule Common::utils where\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = (fromInteger (fromZ x))\n\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = (fromInteger (toInteger x))\n\nZtoZ : {p, q} (fin p, fin q, p >= 1, q >= 1) => Z p -> Z q\nZtoZ x = (fromInteger (fromZ x))\n\nisEven : Integer -> Bit\nisEven x = ~((fromInteger x) : [1]) ! 0\n\nabs : Integer -> Integer\nabs x = if x >= zero then x else zero-x\n\nunzip : {a,f,s} [a](f,s) -> ([a]f,[a]s)\nunzip tuples = (map (\\x -> x.0) tuples , map (\\x -> x.1) tuples)\n\nmul2 x = x + x\nmul3 x = x + mul2 x\nmul4 x = mul2(mul2 x)\nmul8 x = mul2(mul4 x)\n\ntype constraint isOdd a = (a \/ 2) * 2 == a - 1\n\nhalf : {p} (fin p, p >= 3, isOdd p) => Z p -> Z p\nhalf x = if isEven (fromZ x) then x\/2 else (fromInteger ((fromZ x + `p) \/ 2))\n\nmp_mod_inv : {a} (fin a, a >= 1) => Z a -> Z a\nmp_mod_inv c = if c == 0 then error \"Zero does not have a multiplicative inverse\"\n               else fromInteger (if u'' == 1 then x1'' else x2'')\n  where\n    innercond (a, x) = isEven a\n    innerbody (a, x) = (a \/ 2, if isEven x then x \/ 2 else (x + `a) \/ 2)\n\n    outtercond (u, v, x1, x2) = (u != 1) \/\\ (v != 1)\n    outterbody (u, v, x1, x2) = if(u' >= v') then (u' - v', v', x1' - x2' % `a, x2')\n                                             else (u', v' - u', x1', x2' - x1' % `a)\n      where\n        (u', x1') = while innercond innerbody (u, x1)\n        (v', x2') = while innercond innerbody (v, x2)\n\n    (u'', _, x1'', x2'') = while outtercond outterbody (fromZ c, `a, 1, 0)\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the AES implementation in the given file. Specifically, create properties that check that aesDecrypt correctly inverts aesEncrypt for all valid messages and keys, and that the key expansion and round transformations conform to the AES standard. Include properties to validate the SubBytes, ShiftRows, MixColumns, and AddRoundKey steps and their inverses, ensuring they behave as expected according to the FIPS-197 specification."},{"role":"assistant","content":"```cryptol\n\/\/ This is a fairly close implementation of the FIPS-197 standard:\n\/\/   http:\/\/csrc.nist.gov\/publications\/fips\/fips197\/fips-197.pdf\n\n\/\/ Nk: Number of blocks in the key\n\/\/ Must be one of 4 (AES128), 6 (AES192), or 8 (AES256)\n\/\/ Aside from this line, no other code below needs to change for\n\/\/ implementing AES128, AES192, or AES256\nmodule Primitive::Symmetric::Cipher::Block::AES where\n\ntype AES128 = 4\ntype AES192 = 6\ntype AES256 = 8\n\ntype Nk = AES128\n\n\/\/ For Cryptol 2.x | x > 0\n\/\/ NkValid: `Nk -> Bit\n\/\/ property NkValid k = (k == `AES128) || (k == `AES192) || (k == `AES256)\n\n\/\/ Number of blocks and Number of rounds\ntype Nb = 4\ntype Nr = 6 + Nk\n\ntype AESKeySize  = (Nk*32)\n\n\/\/ Helper type definitions\ntype GF28        = [8]\ntype State       = [4][Nb]GF28\ntype RoundKey    = State\ntype KeySchedule = (RoundKey, [Nr-1]RoundKey, RoundKey)\n\/\/ GF28 operations\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Mult : (GF28, GF28) -> GF28\ngf28Mult (x, y) = pmod(pmult x y) irreducible\n\ngf28Pow : (GF28, [8]) -> GF28\ngf28Pow (n, k) = pow k\n  where   sq x  = gf28Mult (x, x)\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult(n, sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow (x, 254)\n\ngf28DotProduct : {n} (fin n) => ([n]GF28, [n]GF28) -> GF28\ngf28DotProduct (xs, ys) = gf28Add [ gf28Mult (x, y) | x <- xs\n                                                    | y <- ys ]\n\ngf28VectorMult : {n, m} (fin n) => ([n]GF28, [m][n]GF28) -> [m]GF28\ngf28VectorMult (v, ms) = [ gf28DotProduct(v, m) | m <- ms ]\n\ngf28MatrixMult : {n, m, k} (fin m) => ([n][m]GF28, [m][k]GF28) -> [n][k]GF28\ngf28MatrixMult (xss, yss) = [ gf28VectorMult(xs, yss') | xs <- xss ]\n   where yss' = transpose yss\n\n\/\/ The affine transform and its inverse\nxformByte : GF28 -> GF28\nxformByte b = gf28Add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n   where c = 0x63\n\nxformByte' : GF28 -> GF28\nxformByte' b = gf28Add [(b >>> 2), (b >>> 5), (b >>> 7), d] where d = 0x05\n\/\/ The SubBytes transform and its inverse\nSubByte : GF28 -> GF28\nSubByte b = xformByte (gf28Inverse b)\n\nSubByte' : GF28 -> GF28\nSubByte' b = sbox@b\n\nSubBytes : State -> State\nSubBytes state = [ [ SubByte' b | b <- row ] | row <- state ]\n\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = gf28Inverse (xformByte' b)\n\nInvSubBytes : State -> State\nInvSubBytes state = [ [ InvSubByte b | b <- row ] | row <- state ]\n\n\/\/ The ShiftRows transform and its inverse\nShiftRows : State -> State\nShiftRows state = [ row <<< shiftAmount | row <- state\n                                        | shiftAmount <- [0 .. 3]\n                  ]\n\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> shiftAmount | row <- state\n                                           | shiftAmount <- [0 .. 3]\n                     ]\n\n\/\/ The MixColumns transform and its inverse\nMixColumns : State -> State\nMixColumns state = gf28MatrixMult (m, state)\n    where m = [[2, 3, 1, 1],\n               [1, 2, 3, 1],\n               [1, 1, 2, 3],\n               [3, 1, 1, 2]]\n\nInvMixColumns : State -> State\nInvMixColumns state = gf28MatrixMult (m, state)\n    where m = [[0x0e, 0x0b, 0x0d, 0x09],\n               [0x09, 0x0e, 0x0b, 0x0d],\n               [0x0d, 0x09, 0x0e, 0x0b],\n               [0x0b, 0x0d, 0x09, 0x0e]]\n\n\/\/ The AddRoundKey transform\nAddRoundKey : (RoundKey, State) -> State\nAddRoundKey (rk, s) = rk ^ s\n\/\/ Key expansion\nRcon : [8] -> [4]GF28\nRcon i = [(gf28Pow (<| x |>, i-1)), 0, 0, 0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord bs = [ SubByte' b | b <- bs ]\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nNextWord : ([8],[4][8],[4][8]) -> [4][8]\nNextWord(i, prev, old) = old ^ mask\n   where mask = if i % `Nk == 0\n                then SubWord(RotWord(prev)) ^ Rcon (i \/ `Nk)\n                else if (`Nk > 6) \/\\ (i % `Nk == 4)\n                     then SubWord(prev)\n                     else prev\n\n\nExpandKeyForever : [Nk][4][8] -> [inf]RoundKey\nExpandKeyForever seed = [ transpose g | g <- groupBy`{4} (keyWS seed) ]\n\nkeyWS : [Nk][4][8] -> [inf][4][8]\nkeyWS seed    = xs\n     where xs = seed # [ NextWord(i, prev, old)\n                       | i    <- [ `Nk ... ]\n                       | prev <- drop`{Nk-1} xs\n                       | old  <- xs\n                       ]\n\nExpandKey : [AESKeySize] -> KeySchedule\nExpandKey key = (keys @ 0, keys @@ [1 .. (Nr - 1)], keys @ `Nr)\n  where   seed : [Nk][4][8]\n          seed = split (split key)\n          keys = ExpandKeyForever seed\n\nfromKS : KeySchedule -> [Nr+1][4][32]\nfromKS (f, ms, l) = [ formKeyWords (transpose k) | k <- [f] # ms # [l] ]\n    where formKeyWords bbs = [ join bs | bs <- bbs ]\n\n\/\/ AES rounds and inverses\nAESRound : (RoundKey, State) -> State\nAESRound (rk, s) = AddRoundKey (rk, MixColumns (ShiftRows (SubBytes s)))\n\nAESFinalRound : (RoundKey, State) -> State\nAESFinalRound (rk, s) = AddRoundKey (rk, ShiftRows (SubBytes s))\n\nAESInvRound : (RoundKey, State) -> State\nAESInvRound (rk, s) =\n      InvMixColumns (AddRoundKey (rk, InvSubBytes (InvShiftRows s)))\nAESFinalInvRound : (RoundKey, State) -> State\nAESFinalInvRound (rk, s) = AddRoundKey (rk, InvSubBytes (InvShiftRows s))\n\n\/\/ Converting a 128 bit message to a State and back\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\n\/\/ AES Encryption\naesEncrypt : ([128], [AESKeySize]) -> [128]\naesEncrypt (pt, key) = stateToMsg (AESFinalRound (kFinal, rounds ! 0))\n  where   (kInit, ks, kFinal) = ExpandKey key\n          state0 = AddRoundKey(kInit, msgToState pt)\n          rounds = [state0] # [ AESRound (rk, s) | rk <- ks\n                                                 | s <- rounds\n                              ]\n\n\/\/ AES Decryption\naesDecrypt : ([128], [AESKeySize]) -> [128]\naesDecrypt (ct, key) = stateToMsg (AESFinalInvRound (kFinal, rounds ! 0))\n  where   (kFinal, ks, kInit) = ExpandKey key\n          state0 = AddRoundKey(kInit, msgToState ct)\n          rounds = [state0] # [ AESInvRound (rk, s)\n                              | rk <- reverse ks\n                              | s  <- rounds\n                              ]\n\nsbox : [256]GF28\nsbox = [\n 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n 0x54, 0xbb, 0x16]\n\n\/\/ Test runs:\n\n\/\/ cryptol> aesEncrypt (0x3243f6a8885a308d313198a2e0370734,   \\\n\/\/                      0x2b7e151628aed2a6abf7158809cf4f3c)\n\/\/ 0x3925841d02dc09fbdc118597196a0b32\n\/\/ cryptol> aesEncrypt (0x00112233445566778899aabbccddeeff,   \\\n\/\/                      0x000102030405060708090a0b0c0d0e0f)\n\/\/ 0x69c4e0d86a7b0430d8cdb78070b4c55a\nproperty AESCorrect msg key = aesDecrypt (aesEncrypt (msg, key), key) == msg\n\ntestmsgs = [0x6bc1bee22e409f96e93d7e117393172a\n           ,0xae2d8a571e03ac9c9eb76fac45af8e51\n           ,0x30c81c46a35ce411e5fbc1191a0a52ef\n           ,0xf69f2445df4f9b17ad2b417be66c3710]\n\n\n\/\/ AES128 tests\n\ntestkey128 = 0x2b7e151628aed2a6abf7158809cf4f3c\n\ntestct128 = [0x3ad77bb40d7a3660a89ecaf32466ef97\n            ,0xf5d3d58503b9699de785895a96fdbaaf\n            ,0x43b1cd7f598ece23881b00e3ed030688\n            ,0x7b0c785e27e8ad3f8223207104725dd4]\n\nproperty testsPass = and [ aesEncrypt (msg, testkey128) == ct\n                         | msg <- testmsgs | ct <- testct128 ]\n\n\n\/\/ AES192 tests\n\n\/\/ testkey192 = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n\n\/\/ testct192 = [0xbd334f1d6e45f25ff712a214571fa5cc \n\/\/             ,0x974104846d0ad3ad7734ecb3ecee4eef \n\/\/             ,0xef7afd2270e2e60adce0ba2face6444e \n\/\/             ,0x9a4b41ba738d6c72fb16691603c18e0e]\n\n\/\/ property testsPass = and [ aesEncrypt (msg, testkey192) == ct\n\/\/                          | msg <- testmsgs | ct <- testct192 ]\n\n\n\/\/ AES256 tests\n\n\/\/ testkey256 = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4 \n\/\/ testct256 = [0xf3eed1bdb5d2a03c064b5a7e3db181f8 \n\/\/             ,0x591ccb10d410ed26dc5ba74a31362870 \n\/\/             ,0xb6ed21b99ca6f4f9f153e7b1beafed1d \n\/\/             ,0x23304b7a39f9f3ff067d8d8f9e24ecc7]\n\n\/\/ property testsPass = and [ aesEncrypt (msg, testkey256) == ct\n\/\/                          | msg <- testmsgs | ct <- testct256 ]\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Primitive\/Keyless\/Hash\/SHA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the SHA hash function implementation in the given module Primitive::Keyless::Hash::SHA. Your properties should include verification of the padding function, message parsing, message schedule generation, compression function, and the overall hash computation. Ensure the properties capture the expected behavior according to the FIPS 180-4 standard for SHA-256 and SHA-512 variants, and check that intermediate functions like Ch, Maj, SIGMA, and sigma functions behave as intended. Use appropriate type constraints and test the consistency of the iterative hash state updates."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA where\n\nsha : {L} (2 * w >= width L) => [L] -> [digest_size]\nsha M = take (join (SHA_2_Common' [ split x | x <- parse`{num_blocks L} (pad`{L} M) ]))\n\nparameter\n\n  \/** Word size\n    Specifications are based on word size w, rather than digest size (8 * w)\n    or block size (m == 16 * w), in order to avoid confusing Cryptol's type\n    constraint verifier with integer division.\n  *\/\n\n  type w : #\n  type constraint (fin w, w >= 1)\n\n  type digest_size : #\n  type constraint (fin digest_size, 8*w >= digest_size)\n\n  \/** The number of iterations in the hash computation\n  (i.e. the number of words in K) *\/\n\n  type j : #\n  type constraint (fin j, j >= 17)\n\n  H0 : [8][w]\n  K  : [j][w]\n\n  \/* FIPS 180-4 defines lowercase and uppercase\n      (respective to the Greek alphabet) sigma functions for SHA-256 and SHA-512.\n      (4.4)-(4.7) SHA-224, SHA-256 (w==32)\n      (4.10)-(4.13) SHA-384, SHA-512, SHA-512\/224, SHA-512\/256 (w==64) *\/\n\n  SIGMA_0 : [w] -> [w]\n  SIGMA_1 : [w] -> [w]\n  sigma_0 : [w] -> [w]\n  sigma_1 : [w] -> [w]\n\nprivate\n\n  \/** block size corresponding to word size for all SHA algorithms in\n      FIPS 180-4 *\/\n  type block_size = 16 * w\n\n  type num_blocks L     = (L+1+2*w) \/^ block_size\n  type padded_size L    = num_blocks L * block_size\n\n\n  \/** (4.1) (w==32), (4.2) (w==32), (4.8) (w==64) *\/\n  Ch : [w] -> [w] -> [w] -> [w]\n  Ch x y z = (x && y) ^ (~x && z)\n\n\n  \/** (4.1) (w==32), (4.3) (w==32), (4.9) (w==64) *\/\n  Maj : [w] -> [w] -> [w] -> [w]\n  Maj x y z = (x && y) ^ (x && z) ^ (y && z)\n\n\n  \/**\n    5.1 Padding the Message\n    5.1.1 SHA-1, SHA-224 and SHA-256 (w==32)\n    5.1.2 SHA-384, SHA-512, SHA-512\/224 and SHA-512\/256 (w==64)\n\n  The constraint ensure that the message size, `L`, fits within a\n  (2 * w)-bit word (consistent w\/ Figure 1)\n  *\/\n  pad : {L} (2 * w >= width L) => [L] -> [padded_size L]\n  pad M = M # 0b1 # zero # (`L : [2*w])\n\n  \/**\n    5.2 Parsing the Message\n    5.2.1 SHA-1, SHA-224 and SHA-256 (w==32)\n    5.2.2 SHA-384, SHA-512, SHA-512\/224 and SHA-512\/256 (w==64)\n  *\/\n  parse : {m} [m * block_size] -> [m][block_size]\n  parse = split\n\n  \/**\n  SHA-256 and SHA-512 (and their respective derivatives) use a similar\n  message schedule that can be expressed in the same way relative to their\n  respective sigma functions.\n\n    6.2.2 SHA-256 Hash Computation (w==32, j=64)\n    6.4.2 SHA-512 Hash Computation (w==64, j=80)\n  *\/\n  messageSchedule_Common : [16][w] -> [j][w]\n  messageSchedule_Common Mi = take W\n    where\n    W : [inf][_]\n    W = Mi # [ w1 + sigma_0 w2 + w3 + sigma_1 w4\n             | w1 <- W\n             | w2 <- drop`{1} W\n             | w3 <- drop`{9} W\n             | w4 <- drop`{14} W\n             ]\n\n\n  \/**\n  Amazon S2N's SHA-256 specification includes a compression routine intended\n  to reflect typical implementations.  This same compression routine applies\n  to SHA-512, modulo respective constants, sigma functions,\n  and message schedules.\n  *\/\n\n  compress_Common : [8][w] -> [j][w] -> [8][w]\n  compress_Common H W =\n        [ (as ! 0) + (H @ 0),\n      (bs ! 0) + (H @ 1),\n      (cs ! 0) + (H @ 2),\n      (ds ! 0) + (H @ 3),\n      (es ! 0) + (H @ 4),\n      (fs ! 0) + (H @ 5),\n      (gs ! 0) + (H @ 6),\n      (hs ! 0) + (H @ 7)\n    ]\n    where\n      T1 = [h + SIGMA_1 e + Ch e f g + k_t + w_t\n                | h <- hs | e <- es | f <- fs | g <- gs | k_t <- K | w_t <- W]\n      T2 = [ SIGMA_0 a + Maj a b c | a <- as | b <- bs | c <- cs]\n      hs = take`{j + 1}([H @ 7] # gs)\n      gs = take`{j + 1}([H @ 6] # fs)\n      fs = take`{j + 1}([H @ 5] # es)\n      es = take`{j + 1}([H @ 4] # [d + t1 | d <- ds | t1 <- T1])\n      ds = take`{j + 1}([H @ 3] # cs)\n      cs = take`{j + 1}([H @ 2] # bs)\n      bs = take`{j + 1}([H @ 1] # as)\n      as = take`{j + 1}([H @ 0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\n\n  processBlock_Common : [8][w] -> [16][w] -> [8][w]\n  processBlock_Common H Mi = compress_Common H (messageSchedule_Common Mi)\n\n\n  SHA_2_Common' : {L} (fin L) => [L][16][w] -> [8][w]\n  SHA_2_Common' blocks = hash ! 0\n    where\n    hash = [H0] # [ processBlock_Common h b | h <- hash | b <- blocks]\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/DilithiumR2BV.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol specifications and verification properties for the DilithiumR2BV module, focusing on verifying the correctness of the key generation (Gen), signing (Sign), and verification (Verify) functions. Include properties that check the consistency of generated keys against known test vectors, the validity of signatures produced by Sign, and that Verify accepts valid signatures and rejects invalid ones. Additionally, specify properties to verify the correctness of polynomial packing\/unpacking and NTT transformations used in the implementation."},{"role":"assistant","content":"```cryptol\n\/*Fixes to comply with the round2 submission to NIST*\/\n\/\/1. Randombytes size changed from SEEDBYTES to 3*SEEDBYTES from\n\/\/2. Expand Mat definition changes\n\n\nmodule Primitive::Asymmetric::Signature::DilithiumR2BV where\n\nimport Primitive::Keyless::Hash::keccak as SHA3\nimport Common::utils\nimport Common::mod_arith\nimport Primitive::Asymmetric::Cipher::RSA\nimport Primitive::Asymmetric::Signature::testDilithium\nimport Primitive::Asymmetric::Signature::test_latest\n\n\n\/\/ These parameters are fixed for all four recommended implementations\ntype qbits = 23\ntype uint32_t = 32\ntype q = 0x7fe001 type n = 0x100 type d = 0xe\nwc= 0x3c gamma1 = ((`q) - 1) \/ 16:[_]\ngamma2 = ( gamma1 \/ 2 ):[_]\nalpha = (2*gamma2):[_]\nqinv  = 0x00000000fc7fdfff\ntype POLT1_SIZE_PACKED = 288\n\n\/\/ Parameters for Number Theoretic Transform (NTT)\nrootOfUnity    = 1753 : [qbits]\nrootOfUnityInv = 731434 : [qbits]\nninv           = 8347681 : [qbits]\n\n\/\/ Parameterize the types based on the following implemenations\n\/* Weak, Medium, Recommended, and VeryHigh*\/\n\/*parameter\n    type k : #\n    type constraint (fin k, k>=3, k<=6)\n    type l : #\n    type constraint (fin l, l>=2, l<=5)\n    eta : [4]\n    beta : [12]\n    omega : [8]*\/\ntype k = 4\ntype l = 3\n\neta = 6\nbeta = 325\ntype omega = 80\n\n\/\/ Integer polynomials; a superset of ring R referenced in specification\ntype intPoly        = [n][qbits]\ntype intPolyVec dim = [dim]intPoly\n\n\/\/ Polynomials; a superset of ring R_q referenced in specification\ntype poly        = [n][qbits] \/\/ This is R_q, actually defines a super set of R_q\ntype polyVec dim = [dim]poly\n\n\/\/ Polynomials in NTT representation\ntype nttPoly          = [n][qbits]\ntype nttVec dim       = [dim]nttPoly\ntype nttMat dim1 dim2 = [dim1](nttVec dim2)\n\n\ntype PublicKey = {rho : [256], t1 : intPolyVec k}\ntype SecretKey = {rho : [256]\n                    , K  : [256]\n                    , tr : [384]\n                    , s1 : polyVec l\n                    , s2 : polyVec k\n                    , t0 : intPolyVec k}\ntype SEEDBYTES = 32\ntype CRYPTO_PUBLICKEYBYTES = SEEDBYTES + (POLT1_SIZE_PACKED * k)\n\n\/* Generate public and private keys *\/\nGen : [3*SEEDBYTES*8] -> (PublicKey,SecretKey)\nGen s = (pk, sk)\n    where\n      [rho, rho', K] = split`{3} s \/\/rho <- {0, 1}^256, K <- {0,1}^256\n      A       = ExpandA (split rho) \/\/A \u2208 R^(k\u00d7l)_q := ExpandA(rho)\n      s1      = PolyUniformEtaV`{dim=l} rho' zero \/\/ s1<-s^l_\u03b7\n      s2      = PolyUniformEtaV`{dim=k} rho' `l \/\/ s2<-s^k_\u03b7\n      s1ntt   = map ntt s1\n      As1     = map nttinv (nttMatMul A s1ntt)\n      t       = paddV As1 s2     \/\/t:= As1 + s2\n      (t1,t0) = Power2RoundV t  \/\/(t1, t0):= Power2Round_q(t, d=4)\n      tr      = CRH (rho#(pack_t1 t1)) \/\/tr \u2208 {0,1}^384 := CRH(rho||t1)\n      pk      = { rho = rho, t1 = t1}\n      sk      = { rho = rho, K = K, tr = tr, s1 = s1, s2 = s2, t0 = t0}\n\n\/\/ Known Answer Test\n\/\/ To check this property, it is necessary to import testDilithium\n\ntest_key_gen = (pk.rho#(pack_t1 pk.t1) == testCase1.pk) \/\\\n    ((sk.rho#sk.K#sk.tr#(pack_polyeta sk.s1)#(pack_polyeta sk.s2)#(pack_t0 sk.t0)) == testCase1.sk)\n    where\n    (pk, sk) = Gen (join testCase1.seed)\n\n\/* Generate signature for message M *\/\nSign : {mbytes} (fin mbytes, mbytes>=1) => SecretKey -> [mbytes*8] -> (polyVec l, polyVec k, poly)\nSign sk M = (final_state.z, h, nttinv final_state.c')\n     where\n      A     = ExpandA (split sk.rho) \/\/ A \u2208 R^(k\u00d7l)_q := ExpandA(\u03c1)\n      mu    = CRH`{b=48+mbytes} (sk.tr#M) \/\/ \u03bc \u2208{0,1}^384 := CRH(tr||M)\n      kappa = zero \/\/ \u03ba := 0\n      s1'   = map ntt sk.s1\n      s2'   = map ntt sk.s2\n      t0'   = map ntt (sk.t0)\n            init : sign_var_types\n      init = {z=zero,r0=zero,r1=zero,t0'=t0',c'=zero,w=zero,w1=zero\n             ,s1'=s1',s2'=s2',cs2=zero,K=sk.K,mu=mu,A=A,kappa=kappa}\n\n      final_state = dowhile sign_condition sign_body init\n      ct0         = map nttinv (nttVecConstMul final_state.c' final_state.t0')\n      h           = MakeHintV (psubV zero ct0\n                              ,paddV (psubV final_state.w final_state.cs2) (ct0))\n\n\n\n\n\n\ntype sign_var_types = { z : polyVec l\n                          , r0  : intPolyVec k\n                          , r1  : intPolyVec k\n                          , t0' : nttVec k\n                          , c'  : nttPoly\n                          , w   : polyVec k\n                          , w1  : intPolyVec k\n                          , s1' : nttVec l\n                          , s2' : nttVec k\n                          , cs2 : polyVec k\n                          , K   : [256]\n                          , mu  : [384]\n                          , A   : nttMat k l\n                          , kappa: [16]}\n\n\nsign_condition : sign_var_types -> Bit\nsign_condition sv = fail1 \\\/ fail2\n                   where\n                    fail1 = ((infNormPolyVec (sv.z)) >= (gamma1-beta)) \/\/ ||z||_\u221e \u2265 \u03b31 - \u03b2\n                            \\\/ ((infNormPolyVec sv.r0) >= (gamma2-beta)) \/\/ ||r0||_\u221e \u2265 \u03b32 - \u03b2\n                            \\\/ (sv.r1 != sv.w1) \/\/ r1 \u2242\u0338 w1\n                    fail2 = ((infNormPolyVec (ct0)) >= gamma2) \/\/ ||ct0||_\u221e \u2265 \u03b32\n                            \\\/ ( (foldl (+) 0 cones) > `omega ) \/\/ number of ones in h > \u03c9\n                    cones = sum (map (\\x -> (map onesBV x)) h)\n                    ct0   = map nttinv (nttVecConstMul sv.c' sv.t0')\n                    h     = MakeHintV (psubV zero ct0\n                                      ,paddV (psubV sv.w sv.cs2) (ct0))\n                                      \/\/ h := MakeHintV(-ct0, w-cs2+ct0, 2\u03b32)\n\n\nsign_body : sign_var_types -> sign_var_types\nsign_body sv = {z=z,r0=r0,r1=r1,t0'=sv.t0',c'=c',w=w,w1=w1,s1'=sv.s1',s2'=sv.s2',\n                   cs2=cs2,K=sv.K,mu=sv.mu,A=sv.A,kappa=(sv.kappa+1)}\n              where\n                \u03c1'  = CRH`{b=48+32} (sv.K#sv.mu) \/\/ \u03c1' \u2208 {0,1}^384 := CRH(K||\u03bc) (or \u03c1' <- {0,1}^384 for randomized signing)\n                y   = ExpandMask((split \u03c1'), sv.kappa)\/\/ y \u2208 S^l_(\u03b31-1) := ExpandMask(\u03c1',\u03ba)\n                y'  = map ntt y \/\/ checked\n                w   = map nttinv (nttMatMul sv.A y') \/\/ w := Ay\n                w1  = HighBitsV w \/\/ w1 := HighBitsV(w, 2\u03b32)\n                c'  = ntt ( H (sv.mu,w1) ) \/\/ c \u2208 B_(60) := H(\u03bc||w1)\n                cs1 = map nttinv (nttVecConstMul c' sv.s1') \/\/ cs1 := c'.s1'\n                cs2 = map nttinv (nttVecConstMul c' sv.s2') \/\/ cs2 := c'.s2'\n                z   = paddV y cs1 \/\/ z:= y+cs1\n                (r1, r0) = DecomposeV (psubV w cs2) \/\/ Decompose_q(w-cs2, 2\u03b32)\n\n\n\n\nVerify : {mbytes} (fin mbytes, mbytes>=1) => PublicKey -> [mbytes*8] -> (polyVec l, polyVec k, poly) -> Bit\nVerify pk M (z, h, c) = crit1 && crit2 && crit3\n       where\n        A        = ExpandA (split pk.rho) \/\/ A \u2208 R^(k\u00d7l)_q := ExpandA(\u03c1)\n        mu       = CRH`{b=48+mbytes} ((CRH (pk.rho#(pack_t1 pk.t1)))#M) \/\/ \u03bc \u2208{0,1}^384 := CRH(CRH(\u03c1||t1)||M)\n        zntt     = map ntt z \/\/ NTT(z)\n        t1dot2d  = map ntt (map (\\p -> map (\\x ->  mod_mul(`q, x, (2^^14))) p) pk.t1) \/\/ t1.2^^d where d=14\n        nttt1dot2d = map ntt t1dot2d\n        ct1ntt   = nttVecConstMul (psub zero c) nttt1dot2d   \/\/ -ct1\n        Az       = nttMatMul A zntt\n        w1'      = UseHintV (h, paddV Az ct1ntt)\n        zint     = z\n        zinf     = infNormPolyVec zint \/\/ ||z||_\u221e\n        crit1    = zinf < gamma1 - beta\n        crit2    = c == H(mu,w1')\n        cones    = sum (map (\\x -> (map onesBV x)) h)\n        crit3    = ( (foldl (+) 0 cones) > `omega ) \/\/ number of 1's in h \u2264 \u03c9 \/\/ TODO: fix this\n\n\nonesBV : {n} (fin n, n>=1)=> [n] -> [n]\nonesBV xs =  l!0\n    where l = [0]#[ (if (xs@i) then j+1 else j):[n] | i <- [0..n-1] | j<- l]\n\n\/\/:prove (\\x -> (onesBV x) == fromInteger (ones x)):[23]-> Bit\n\npack_w : intPolyVec k -> [4*n*k]\npack_w w = join [pack_poly p | p <- wBV ]\n    where\n    wBV = map (\\p -> map (\\x -> drop`{15} x:[8]) p) w\n    pack2 : [2][8] -> [8]\n    pack2 xs = xs@0 || (xs@1 << 4)\n    pack_poly p = join [ pack2 xs | xs <- split p : [128][2][_] ]\n\npack_polyeta : {m} (fin m, m >= 1) =>  polyVec m -> [4*n*m]\npack_polyeta s = join [ join [elt p i | i <- [0..(n\/2)-1]:[_][8] ] | p <- s ]\n    where\n    elt : poly -> [8] -> [8]\n    elt p i = (c (((p@(2*i+0))) % `q)) || ((c (((p@(2*i+1))) % `q)) << 4)\n    c : [qbits] -> [8]\n    c num = drop (if num > eta then `q + eta - num else eta - num)\n\n\/\/unpack_polyeta\ntype POLETA_SIZE_PACKED = 128\nunpack_polyeta :  {m} (fin m, m>=1) => [POLETA_SIZE_PACKED*m][8] -> polyVec m\nunpack_polyeta t = [ elt a | a <- (split t):[m][128][8]]\n      where\n      elt : [128][8] -> poly\n      elt a = (join coeffs)\n            where coeffs = [ [ (`q+eta)- (zext (a@i&&0x0F)), (`q+eta)- (zext (a@(i+1)>>4))] |i <- [0..(n\/2)-1]:[_][8] ]\n\n\n\n\npack_t0 : intPolyVec k -> [k*3584]\npack_t0 t0 = join [ polyt0_pack p | p <- t0 ]\n\npolyt0_pack : intPoly -> [3584]\npolyt0_pack p = join [ join [drop`{15} (tmp p i 0),\n                       drop`{15} (((tmp p i 0) >> 8) || ((tmp p i 1) << 6)),\n                       drop`{15} ((tmp p i 1) >> 2),\n                       drop`{15} (((tmp p i 1) >> 10) || ((tmp p i 2) << 4)),\n                       drop`{15} ((tmp p i 2) >> 4),\n                       drop`{15} (((tmp p i 2) >> 12) || ((tmp p i 3) << 2)),\n                       drop`{15} ((tmp p i 3) >> 6)\n                     ] | i <- [0..(n\/4-1)] ]\n        where\n          tmp : intPoly -> [8] -> [8] -> [23]\n          tmp p i j =  (2^^13 - p@(4*i+j))\ntype POLT0_SIZE_PACKED = 448\npolyt0_unpack : [POLT0_SIZE_PACKED][8] -> intPoly\npolyt0_unpack p = join[ [ (tmp p i 0) || (zext ((tmp p i 1) && zext 0x3F)) << 8,\n                          (zext ((tmp p i 1) >> 6)) || (zext (tmp p i 2)) << 2 || (zext ((tmp p i 3) && zext 0x0F)) << 10,\n                          (zext ((tmp p i 3) >> 4)) || (zext (tmp p i 4)) << 4 || (zext ((tmp p i 5) && zext 0x03)) << 12,\n                          (zext ((tmp p i 5) >> 2)) || (zext (tmp p i 6)) << 6\n                        ] | i <- [0..(n\/4-1)]\n                      ]\n          where\n            tmp :[POLT0_SIZE_PACKED][8] -> [8] -> [8] -> [23]\n            tmp p i j =  zext (2^^13 - p@(7*i+j))\n\n\nunpack_t0 : [k][POLT0_SIZE_PACKED][8] -> intPolyVec k\nunpack_t0 pv = [ (polyt0_unpack pv') | pv' <- pv]\n\n\n\/\/ d must be 14 for this to work, and n must be 256\n\n\/\/ polyt1_pack\n\npoly_pack : poly -> [POLT1_SIZE_PACKED*8]\npoly_pack p = join [ join (pack8 xs) | xs <- split (map (drop`{14}) p) : [32][8][_]]\n\npack8 : [8][9] -> [9][8]\npack8 xs = map drop`{1} [ xs@0\n                        , xs@0 >> 8 || xs@1 << 1\n                        , xs@1 >> 7 || xs@2 << 2\n                        , xs@2 >> 6 || xs@3 << 3\n                        , xs@3 >> 5 || xs@4 << 4\n                        , xs@4 >> 4 || xs@5 << 5\n                        , xs@5 >> 3 || xs@6 << 6\n                        , xs@6 >> 2 || xs@7 << 7\n                        , xs@7 >> 1\n                        ]\n\npack_t1 : polyVec k -> [k*POLT1_SIZE_PACKED*8]\npack_t1 pvk = (join [ poly_pack p | p <- pvk])\n\n\/\/ polyt1_unpack\n\npolyt1_unpack : [POLT1_SIZE_PACKED][8] -> poly\npolyt1_unpack p = map (\\x -> zero#x) (join [unpack8 xs | xs <- (split p): [32][9][_] ])\n    where unpack8: [9][8] -> [8][12]\n          unpack8 xs = [ zero#xs@0 || ((zero#xs@1 << 8) && 0x1FF)\n                        , zero#xs@1 >> 1 || ((zero#xs@2 << 7) && 0x1FF)\n                        , zero#xs@2 >> 2 || ((zero#xs@3 << 6) && 0x1FF)\n                        , zero#xs@3 >> 3 || ((zero#xs@4 << 5) && 0x1FF)\n                        , zero#xs@4 >> 4 || ((zero#xs@5 << 4) && 0x1FF)\n                        , zero#xs@5 >> 5 || ((zero#xs@6 << 3) && 0x1FF)\n                        , zero#xs@6 >> 6 || ((zero#xs@7 << 2) && 0x1FF)\n                        , zero#xs@7 >> 7 || ((zero#xs@8 << 1) && 0x1FF)\n                        ]\n\n\nunpack_t1 : [k][POLT1_SIZE_PACKED][8] -> polyVec k\nunpack_t1  pv = [ (polyt1_unpack p) |  p <- pv]\n\n\/\/pack_pk\n\npack_pk :  [32][8] -> polyVec k -> [CRYPTO_PUBLICKEYBYTES*8]\npack_pk rho t1 = (join rho) # (pack_t1 t1)\n\n\/\/unpack_pk\n\nunpack_pk : [CRYPTO_PUBLICKEYBYTES][8] -> ([SEEDBYTES][8], polyVec k)\nunpack_pk pk = (take`{32} pk, [polyt1_unpack p | p <- (split (drop`{32} pk):[k][288][_])])\n\n\/****Packing SK *********\/\n\ntype CRHBYTES = 48\ntype CRYPTO_SECRETKEYBYTES = 2800\n\n\n\n\/\/pack_sk\n\npack_sk : [SEEDBYTES][8] -> [SEEDBYTES][8] -> [CRHBYTES][8] -> polyVec l -> polyVec k -> polyVec k -> [CRYPTO_SECRETKEYBYTES*8]\npack_sk rho key tr s1 s2 t0 = (join rho) # (join key) # (join tr)# (pack_polyeta s1)#(pack_polyeta s2) # (pack_t0 t0)\n\nunpack_sk : [CRYPTO_SECRETKEYBYTES][8] -> ([SEEDBYTES][8], [SEEDBYTES][8], [CRHBYTES][8], polyVec l, polyVec k, intPolyVec k)\nunpack_sk sk = (rho, key, tr, s1, s2, t0)\n        where rho = (take`{32} sk)\n              key = (take`{32}(drop`{32} sk))\n              tr = (take`{48}(drop`{32} sk))\n              s1 = unpack_polyeta`{m=l} (take`{128*l}(drop`{48} sk))\n              s2 = unpack_polyeta`{m=k} (take`{128*k}(drop`{48+(128*l)} sk))\n              t0 = unpack_t0 (split (drop`{48+(128*l)+(128*k)+64} sk):[k][POLT0_SIZE_PACKED][8])\n\ntype POLZ_SIZE_PACKED = 640\n\npolyz_pack : poly -> [POLZ_SIZE_PACKED][8]\npolyz_pack p =  join [ (tmp p i) | i<- [0..(n\/2)-1]]\n      where tmp: poly -> [8] -> [5][8]\n            tmp p i  = [r0, r1, r2, r3, r4]\n              where\n                    t x = gamma1-1-p@(2*i+x)\n                    t0 = (t 0) + ((zext (t 0))>>31) && `q\n                    t1 = (t 1) + ((zext (t 1))>>31) && `q\n                    r0 = drop t0\n                    r1 = drop (t0>>8)\n                    r2 = drop (t0>>16) || drop (t1 << 4)\n                    r3 = drop (t1 >> 4)\n                    r4 = drop (t1 >> 12)\n\npolyz_unpack : [POLZ_SIZE_PACKED][8] -> poly\npolyz_unpack pp =  (join [ (tmp pp i) | i<-[0..(n\/2)-1]])\n    where tmp : [POLZ_SIZE_PACKED][8] -> [8]-> [2][23]\n          tmp pp i = [rcoeff0, rcoeff1]\n                where\n                  coeff0 = (zero#pp@(5*i+0):[32]) || (((zero#pp@(5*i+1)):[32]) << 8) || (zero#(((zero#pp@(5*i+2)):[8]) && 0x0F):[32]) << 16\n                  coeff1 = ((zero#(pp@(5*i+2) >> 4)):[32]) || ((zero#pp@(5*i+3):[32]) << 4) || ((zero#pp@(5*i+4):[32]) << 12)\n                  rcoeff0 = drop`{9}((gamma1 - 1 - coeff0) + ((zext coeff0:[32]) >> 31) && `q):[23]\n                  rcoeff1 = drop`{9}((gamma1 - 1 - coeff1) + ((zext coeff1:[32]) >> 31) && `q):[23]\n\ntype SIG_SIZE_PACKED = l*POLZ_SIZE_PACKED+omega+k+n\/8+8\n\nencodec : poly -> [(n\/8+8)*8]\nencodec p = (join [ [ p@(8*i+j)!=0 | j <- [0..7] ] | i<- [0..(n\/8)-1]])# (join sigSigns)\n      where\n        signs =[0]# [(if (join qm1coeffsIndcs)@i then s||m else s) | s <- signs | m<- masks| i<-[0..255]]\n        masks = [1]# [(if (join nzcoeffsIndcs)@i then (m << 1) else m) | m<-masks | i<-[0..255] ]\n        nzcoeffsIndcs =  [ [ p@(8*i+j)!=0 | j <- [0..7] ] | i<- [0..(n\/8)-1]]\n        qm1coeffsIndcs = [ [ p@(8*i+j)==(`q-1) | j <- [0..7] ] | i<- [0..(n\/8)-1]]\n        sig = zero:[n\/8+8][8]\n        sigSigns = [ (signs!0) >>(8*i) | i<-[0..7]]:[8][8]\n\npack_sig : (polyVec l, polyVec k, poly) -> [SIG_SIZE_PACKED*8]\npack_sig (z, h, c) = s0#s1#s2\n        where s0 = join [join (polyz_pack z') | z' <- z ]\n              s2 = encodec c\n              s1 = encodeh h\n                where\n                encodeh : polyVec k -> [(omega+k)*8]\n                encodeh h = join omegaUpdates\n                  where nzcoeffsIndcs = [ [ (p@j)!=0 | j<-[0..255]]| p<- h]\n                        cones = sum (map onesBV nzcoeffsIndcs)\n                        sig = zero:[84][8]\n                        kUpdates0=[sig]#[(if (nzcoeffsIndcs@0)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates0]\n                        kUpdates1=[kUpdates0!0]#[(if (nzcoeffsIndcs@1)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates1]\n                        kUpdates2=[kUpdates1!0]#[(if (nzcoeffsIndcs@2)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates2]\n                        kUpdates3=[kUpdates2!0]#[(if (nzcoeffsIndcs@3)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates3]\n                        omegaUpdates = (updates (kUpdates3!0) [`omega+0, `omega+1, `omega+2, `omega+3] [0, 1, 2, 3])\n\ndecodec : [(n\/8+8)][8] -> poly\ndecodec xs = coeffs'!0\n  where coeffs = zero:poly\n        signs = [0]#[ ((sext s) || ((sext (xs@(`n\/8+i))):[64]) << (8*i)) | i<-[0..7] | s<-signs] :[9][64]\n        signs' = [signs!0]#[ (if ((((xs@i) >> j) && 0x01) == 1) then (s >> 1) else s) | j<- [0..255] | s <- signs' | i<- [0..3]]\n        coeffs' = [coeffs]#[(if ((((xs@i) >> j) && 0x01)==1) then (update coeff (8*i+j) (1^(-((drop s)&&1))&&(1^(`q-1)))) else coeff) | i<- [0..7] | j<- [0..255] | s <- signs' | coeff <-coeffs' ]\n\ndecodeh: [(omega+k)][8] -> polyVec k\ndecodeh xs = pv \/\/ it is supposed to be pv'!0\n      where\n        pv = zero : polyVec k\n        ks = [0]#[xs@(`omega+i) | i<- [0..3]]\n        unpack_sig : [SIG_SIZE_PACKED][8] -> (polyVec l, polyVec k, poly)\nunpack_sig sig = (z, h, c)\n        where z = [ (polyz_unpack p) | p<- (split (take`{l*POLZ_SIZE_PACKED} sig):[l][_][_])]\n              c = decodec sig'' \/\/ decodec(c) : [(n\/8+8)*8] -> poly\n              sig' = take`{84}(drop`{l*POLZ_SIZE_PACKED} sig)\n              sig'' = drop`{84}(drop`{l*POLZ_SIZE_PACKED} sig)\n              h = decodeh sig'\n\nupdateCoeffs :  polyVec n -> [k] -> [8] -> [qbits] -> polyVec n\nupdateCoeffs pv i j a =  upv\n      where  upv = (update pv i up)\n             up = (update p j a)\n             p = pv@i\n\n\n\/\/ Only works when n=256\n\n\/\/ This function has been modified in round2\n\/\/PolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [8] -> polyVec dim \/\/ round1\nPolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [16] -> polyVec dim\nPolyUniformEtaV r nonce = [PolyUniformEta (split r) (nonce + j) | j <- [0..(dim-1)]:[dim][16]]\n\ngenS : [8] -> [2][4]\ngenS byte = [t0, t1]\n    where\n    t0 = drop`{4} (byte && 0x0F)\n    t1 = drop`{4} (byte >> 4)\n\n\/\/ This function has been modified in round2\n\/\/(uint8_t) D means taking 8 LSBs from D\n\/\/PolyUniformEta : [SEEDBYTES*8] -> [8] -> poly\nPolyUniformEta : [SEEDBYTES][8] -> [16] -> poly\nPolyUniformEta rho nonce = map (\\x -> if ((toInteger eta) - (toInteger x)) < 0 then (fromInteger  (((toInteger eta) - (toInteger x))+`q):[23]) else (fromInteger ((toInteger eta) - (toInteger x)):[23])) (take`{n} withinEta)\n    where\n        seed = (join rho)#(drop`{8} nonce)# (take`{8} nonce)\n        randoms = ((join (SHA3::toBytes (take`{2*8*168} (SHA3::SHAKE128 (join (SHA3::toBytes seed))))))#zero)\n        withinEta = randomsInRangeDouble genS (2*eta) randoms\n\n\nH : ([384],intPolyVec k) -> poly\nH (mu,w) = (SampleInBall ss samples)\n  where\n    w_packed = pack_w w\n    randoms  = join (SHA3::toBytes (take`{4352} (SHA3::SHAKE256 (join (SHA3::toBytes (mu#w_packed))))))\n    ss       = take`{60}(reverse (join (reverse (split (take`{64} randoms):[8][8]))))\n\n    extByte : [8] -> [8]\n    extByte x = x\n\n    samples : [60][8]\n    samples = take`{60} (randomsInRanges extByte [196..255] (drop`{64} randoms#zero))\n\n\nSampleInBall : [60] -> [60][8] -> [256][qbits]\nSampleInBall signs jsamples = ys ! 0\n              where\n              ys = [ zero:[256][qbits]]\n                    # [ if i==j then (if [s]==1 then (update y i (`q-1)) else (update y i 1))                          else (if [s]==1 then (updates y [j,i] [`q-1,y@j]) else (updates y [j,i] [1,y@j]))  | i <- [196..255]\n                                                                  | j <- jsamples\n                                                                  | s <- signs\n                                                                  | y <- ys\n                      ]\n\n\nExpandMask : ([CRHBYTES][8], [16]) -> polyVec l\nExpandMask  ( \u03c1', kappa) = [samplePoly \u03c1' kappa i `l | i <- [0..(l-1)] ]\n\n\nsamplePoly : [CRHBYTES][8] -> [16] -> [2] -> [2] -> poly\nsamplePoly \u03c1' kappa i dim = (map (\\x -> mod_sub(`q, mod_sub(`q, gamma1, 1), zero#x)) coeffs)\n    where\n        (upper:[20])      =  drop`{4}(2*gamma1-2):[20]\n        kappaBytes = join (reverse (split ((zext dim)*kappa+(zext i)):[2][8])) \/\/ LEB order\n        s          = join (SHA3::toBytes (take`{5*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes ((join \u03c1')#kappaBytes)))))) \/\/ checked\n        (coeffs:[n][20])   = take`{n} (randomsInRangeDouble extractPolyElt upper (s#zero))\n\n\nextractPolyElt : [40] -> [2][20]\nextractPolyElt bits = [zero#int1, zero#int2]\n                where\n                [b0,b1,b2,b3,b4] = [(zero#b):[20] | b <- split bits : [5][8]]\n                int1 = b2'*2^^16 + b1*2^^8 +  b0\n                int2 = b4*2^^12 + b3*2^^4 +  b2''\n                b2'  = b2 && 15\n                \/\/b2'' = b2\/(16:[20])\n                b2'' = b2\/16\n\/\/ seed should be in little endian byte order\nCRH : {b} (fin b, b>=1) => [b*8] -> [384]\nCRH seed = join (SHA3::toBytes (take`{48*8} (SHA3::SHAKE256 (join (SHA3::toBytes seed)))))\n\nExpandA : [SEEDBYTES][8] -> [k][l]nttPoly\nExpandA rho = [ [ (matrixPoly (join rho) i j) | j <- [0..(l-1)] ] |  i <- [0..(k-1)] ]\n\nmatrixPoly : [SEEDBYTES*8] -> [width k] -> [width l] -> nttPoly\nmatrixPoly rho i j = take`{n} [drop`{1} elt | elt <- randomElts ]\n            where\n            randomElts = randomsInRange extractMatElt ((>=) (`q)) (s#zero)\n            s          = join (SHA3::toBytes (take`{6720} (SHA3::SHAKE128 (join (SHA3::toBytes (rho#b))))))\n            \/\/b        = 2^^4*(zero#j:[8])+(zero#i:[8])\n            b          =  drop`{16}(((zero#j:[32]) << 8) + (zero#i:[32]))\n\n\nextractMatElt : [24] -> [24]\nextractMatElt rands = zero#(2^^16 * b2' + 2^^8 * b1 + b0):[24]\n                where\n                  [b0, b1, b2] = [(zero#b):[23] | b <- split`{3} rands]\n                  b2' = (2^^23-1) && b2 \/\/ Typo in paper; following C implementation\n\n\n\/*\n\n  Supporting Algorithms; see Figure 3\n\n*\/\n\nPower2Round : [qbits] -> ([qbits],[qbits]) -> ([qbits],[qbits])\nPower2Round q (r,d') = ((r'-r0)\/2^^d',r0)\n            where r' = mod_pow (zero#q, r, 1)\n                  r0 = centered_mod r' (2^^d')\n\npolyPower2Round : {m} [m][qbits] -> ([m][qbits], [m][qbits])\npolyPower2Round p = unzip [ Power2Round `q (zero#r, zero#0xe)\n                          | r <- p\n                          ]\n\nPower2RoundV : {dim} (fin dim, dim >= 1) => polyVec dim -> ([dim]intPoly,[dim]intPoly)\nPower2RoundV v = unzip (map polyPower2Round v)\n\nALPHA = 2*gamma2\n\nDecompose : [qbits] -> ([qbits],[qbits])\nDecompose r = if (r' - r0) == (`q - 1) then (0, r0 - 1)\n                    else ((r' - r0) \/ ALPHA, r0)\n          where r' =  mod_pow (`q, r, 1)\n                r0 = centered_mod r' ALPHA\n\nDecomposePoly : {m} [m][qbits] -> ([m][qbits], [m][qbits])\nDecomposePoly p = unzip [Decompose (zero#x) | x <- p]\n\nDecomposeV : {n} (fin n, n>=1) => polyVec n  -> (polyVec n, polyVec n)\nDecomposeV r = unzip [ DecomposePoly p | p <- r ]\n\nHighBits : [qbits] -> [qbits]\nHighBits r = (Decompose r).0\n\nHighBitsV : {n} (fin n, n>=1) => polyVec n  -> polyVec n\nHighBitsV rv = r1\n          where\n            (r1,r0) = DecomposeV rv\n\n\nLowBits : [qbits] -> [qbits]\nLowBits r = (Decompose r).1\n\n\nMakeHint : ([qbits],[qbits]) -> [qbits]\nMakeHint (z,r) = zero#[r1 != v1]\n          where r1 = HighBits r\n                v1 = HighBits r+z\nMakeHintP: (poly, poly) -> poly\nMakeHintP (zp, rp) = [MakeHint (z, r) | z <- zp | r <- rp]\n\nMakeHintV : {k} (fin k, k>=1) => (polyVec k, polyVec k) -> polyVec k\nMakeHintV (zv, rv) =  [MakeHintP (zp, rp) | zp <- zv | rp <- rv ]\n\n\n\nUseHint : ([qbits],[qbits]) -> [qbits]\nUseHint  (r,h) = (if h==1 then r1' else r1):[23]\n        where\n          m = ((`q - 1) \/ ALPHA)\n          (r1, r0) = Decompose r\n          r1'      = if (r0 > 0) then mod_pow (m, (r1 + 1), 1) else mod_pow (m, (r1 - 1), 1)\nUseHintPoly : poly -> poly -> poly\nUseHintPoly rp hp = [ UseHint (r, h) | r <- rp | h <- hp ]\n\nUseHintV : {k}(fin k, k>=1) => (polyVec k, polyVec k) -> polyVec k\nUseHintV (rv, hv) = [UseHintPoly hpoly rpoly\n                              | hpoly <- hv\n                              | rpoly <- rv\n                              ]\n\n\/*\n\n  Utility functions\n\n*\/\n\n\nones : {a} (fin a, a >= 1) => [a] -> Integer\nones bv = foldl (+) 0 bva\n      where\n      bva = map toInteger (split bv:[_][1])\n\ncentered_mod : [qbits] -> [qbits] -> [qbits]\ncentered_mod x n = if r > (n\/2) then r - n\n                    else r\n              where r = x % n\n\n\nrandomsInRange : {a} (fin a) => ([a]-> [a]) -> ([a] -> Bit) -> [inf] -> [inf][a]\nrandomsInRange createElt upperCrit randoms = if (upperCrit elt )\n                                then  [ elt ]#(randomsInRange createElt upperCrit randomTail)\n                                else randomsInRange createElt upperCrit randomTail\n                                where\n                                elt        = createElt (take`{a} randoms)\n                                randomTail = drop`{a} randoms\n\nrandomsInRanges : {a,m} (fin a,fin m, m>=1) => ([a]-> [a]) -> [m][a] -> [inf] -> [inf][a]\nrandomsInRanges createElt uppers randoms =\n                if elt <= head uppers\n                then  [ elt ]#(randomsInRanges createElt uppersRotate randomTail)\n                else randomsInRanges createElt uppers randomTail\n                where\n                  elt          = createElt (take`{a} randoms)\n                  randomTail   = drop`{a} randoms\n                  uppersRotate = uppers <<< 1\n\n\nrandomsInRangeDouble : {a} (fin a) => ([2*a]-> [2][a]) -> [a] -> [inf] -> [inf][a]\nrandomsInRangeDouble createElt upper randoms =\n                if (elts@0 <= upper) \/\\ (elts@1 <= upper)\n                then  elts#(randomsInRangeDouble createElt upper randomTail)\n                else\n                  if (elts@0 <= upper)\n                  then [ elts@0 ]#(randomsInRangeDouble createElt upper randomTail)\n                  else\n                    if (elts@1 <= upper)\n                    then [ elts@1 ]#(randomsInRangeDouble createElt upper randomTail)\n                    else randomsInRangeDouble createElt upper randomTail\n                where\n                  elts       = createElt (take`{2*a} randoms)\n                  randomTail = drop`{2*a} randoms\n\/*\n  Supporting polynomial and polynomial vector functions\n*\/\n\nmod_sum : {s, m} (fin s, fin m) => ([s], [m][s]) -> [s]\nmod_sum (p, l) = sums!0\n    where\n    sums = [zero]#[mod_add`{s}(p, x, y) | x <- l | y <- sums]\n\nntt : poly -> nttPoly\nntt p = nttp\n    where\n    r k = mod_pow(`q, rootOfUnity, k)\n    exponents = join [ [zext i, (256+(zext i))] | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n    nttp = [(mod_sum (`q, [ (mod_mul(`q, (p@idx), (mod_pow (`q, (r k), i)))) | idx<-[0..(n-1)]:[n][width n] | i<-[0..(n-1)]:[n][23]]))\n           | k <- exponents\n           ]\n\nnttinv : nttPoly -> poly\nnttinv p' = p\n    where\n        pu = reorder p'\n        r' i = mod_pow (`q, rootOfUnityInv, (i*2))\n        p = [ mod_mul(`q, ninv, mod_mul(`q, mod_pow(`q, rootOfUnityInv, i), (mod_sum (`q, [mod_mul(`q, (pu@jdx), (r' ((i*j))))\n            | jdx<-[0..(n-1)]:[n][width n]\n            | j<-[0..(n-1)]:[n][qbits]\n            ]))))\n            | i <- [0..255]:[n][qbits]\n            ]\n\n\n\n\n\/\/ Dilithium uses a non-standard ordering of elements in the NTT domain; this function reorders the elements.\nreorder : nttPoly -> nttPoly\nreorder a = join [ [a1 @ i, a2 @ i] | i <- [0..127]:[_][8] ]\n        where\n          a1 = a @@ [ (i-1)\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n          a2 = reverse (a @@ [ (511 - (zero#i):[9])\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ])\n\n\n\n\/\/ Operations on NTT polynomials\n\nnttMatMul : {dim1,dim2} (fin dim1,fin dim2) => nttMat dim1 dim2 -> nttVec dim2 -> nttVec dim1\nnttMatMul mat vec = [ nttDotProduct v vec | v <- mat ]\n\nnttDotProduct : {dim} (fin dim) => nttVec dim -> nttVec dim -> nttPoly\nnttDotProduct v1 v2 = foldl padd (zero:nttPoly) [ nttPolyMult p1 p2 | p1 <- v1 | p2 <- v2 ]\n\nnttPolyMult : nttPoly -> nttPoly -> nttPoly\nnttPolyMult p1 p2 = [ mod_mul(`q, x, y) | x <- p1 | y <- p2]\n\nnttVecConstMul : {dim} (fin dim) => nttPoly -> nttVec dim -> nttVec dim\nnttVecConstMul c v = map (nttPolyMult c) v\n\npolyVecSum :  {dim} (fin dim) => polyVec dim -> polyVec dim -> polyVec dim\npolyVecSum v1 v2 = map nttinv (paddV v1' v2')\n        where\n        v1' = map ntt v1\n        v2' = map ntt v2\n\n\/\/ Polynomial addition and subtraction\npadd : [n][qbits] -> [n][qbits] -> [n][qbits]\npadd p1 p2 = [ mod_add(`q, x, y) | x <- p1 | y <- p2 ]\n\npsub : [n][qbits] -> [n][qbits] -> [n][qbits]\npsub p1 p2 = [ mod_sub(`q, x, y) | x <- p1 | y <- p2 ]\n\npsubV : {dim} (fin dim) => [dim][n][qbits] -> [dim][n][qbits] -> [dim][n][qbits]\npsubV v1 v2 = zipWith psub v1 v2\n\n\npaddV : {dim} (fin dim) => [dim][n][qbits] -> [dim][n][qbits] -> [dim][n][qbits]\npaddV v1 v2 = zipWith padd v1 v2\n\n\/\/ Aux functions\n\ninfNorm : [qbits] -> [qbits]\ninfNorm x =  (centered_mod x `q)\n\ninfNormPoly : intPoly -> [qbits]\ninfNormPoly p = foldl max 0 p_centered\n            where\n              p_centered = map infNorm p\n\ninfNormPolyVec : {dim} (fin dim, dim>=1) => intPolyVec dim -> [qbits]\ninfNormPolyVec v = foldl max 0 (map infNormPoly v)\n\n\/************************************\/\n\/* Conversion functions helpful in Testing *\/\n\/************************************\/\n\n\/\/Bit-Vector to Integer type\n\nBVtoIntPoly : poly -> [n]Integer\nBVtoIntPoly p = map (\\x -> toInteger x) p\n\nBVtoIntPolyVec : {dim} (fin dim, dim >= 1) => polyVec dim -> [dim][n]Integer\nBVtoIntPolyVec pvec = map (\\x -> BVtoIntPoly x) pvec\n\nBVtoIntNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => nttMat dim1 dim2 -> [dim1][dim2][n]Integer\nBVtoIntNttMat nttmat = map (\\x -> BVtoIntPolyVec x) nttmat\n\n\/\/Bit-Vector to (Z q) type\n\nBVtoZPoly : poly -> [n](Z q)\nBVtoZPoly p = map (\\x -> BVtoZ`{q} x) p\n\nBVtoZPolyVec : {dim} (fin dim, dim >= 1) => polyVec dim -> [dim][n](Z q)\nBVtoZPolyVec pvec = map (\\x -> BVtoZPoly x) pvec\n\nBVtoZNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => nttMat dim1 dim2 -> [dim1][dim2][n](Z q)\nBVtoZNttMat nttmat = map (\\x -> BVtoZPolyVec x) nttmat\n\n\/\/ Integer to Bit-Vector type\n\nInttoZPoly : [n]Integer -> [n](Z q)\nInttoZPoly p = map (\\x -> fromInteger x:(Z q)) p\n\nInttoZPolyVec : {dim} (fin dim, dim >= 1) => [dim][n]Integer -> [dim][n](Z q)\nInttoZPolyVec pvec = map (\\x -> InttoZPoly x) pvec\n\nInttoZNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => [dim1][dim2][n]Integer -> [dim1][dim2][n](Z q)\nInttoZNttMat nttmat = map (\\x -> InttoZPolyVec x) nttmat\n\n\/\/ (Z q) to Integer type\n\nfromZPoly : [n](Z q) -> [n]Integer\nfromZPoly p = map (\\x -> fromZ x) p\n\nfromZPolyVec : {dim} (fin dim, dim >= 1) => [dim][n](Z q) -> [dim][n]Integer\nfromZPolyVec pvec = map (\\x -> fromZPoly x) pvec\n\nfromZNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => [dim1][dim2][n](Z q) -> [dim1][dim2][n]Integer\nfromZNttMat nttmat = map (\\x -> fromZPolyVec x) nttmat\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ecdsa.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the ECDSA signature and verification functions defined in the ecdsa.cry module. Your specification should include properties that check the validity of signatures generated by ecdsa_sign and ensure that ecdsa_public_verify correctly accepts valid signatures and rejects invalid ones, based on the ANSI X9.62-2005 standard. Additionally, specify properties that verify the correctness of the elliptic curve operations on the P-384 curve, including point addition, doubling, and scalar multiplication, using the provided test vectors."},{"role":"assistant","content":"```cryptol\n\/* Reference ECDSA signature algorithm as formalized from [ANSI X9.62-2005, pg 8]\n   Reference ECDSA signature verification algorithm as formalized from [ANSI X9.62-2005, pg 9]\n   \n   Copyright (c) 2018, Galois Inc.\n   www.cryptol.net\n   You can freely use this source code for educational purposes.\n*\/\n\nmodule Primitive::Asymmetric::Signature::ecdsa where\n\nimport Common::bv\nimport Common::mod_arith\nimport Common::mul_java\n\nimport Common::Field \/* Defines Field type and generic operations *\/\nimport Common::EC::ec_point_ops\nimport Common::EC::ref_ec_mul\nimport Common::EC::p384_field\nimport Common::EC::p384_ec_point_ops\nimport Common::EC::p384_ec_mul\n\n\/* Scalar multiply operations {{{1 *\/\n\n\ntest_params : ([384], AffinePoint [384], [384], AffinePoint [384])\ntest_params =\n\/\/  (0x7b52dc21312701d79a2465bb9fdf6fd30c4f76cf74787e44348f8217e6ffd5e02ee8c55a7c5d91b452825b1026d26893, {x=0xdf1c86a62d76090308a0d4c371704b36f3bfa41f0dbf8185d297b8a2c811756f0f4be19871cde079c5d43cfd0fab7fe8; y=0x70521fdd9165b0d33e948be941c590f2fbe7e2754ba110ae24089d41773acfdd34701acaafa669a884d3eefbf557d98b}, 0x211bb4730ad83e31aedbd66a5a750e800cf4de096495323ea94a73f25e9bcb5068a9dcc93e98efecb136eb057e6f41a4, {x=0x6bdf86d8f4cdf5b63a6a1e93a75457c0816fa2f3f69bc706ab69a7b5a63d4956d83cc4ca551f6aaf7653b8dd0991a6af; y=0xa8ce019e78abd658350e5885c8fddb172117a24bf157dfdbe8a1831e03758e630784470287c8e25908d931f22581bf97});\n\/\/  (0x6250471849e0c0eb47e9cf2c8e04c9ad0745e358d1cf11fb53e178a3c5b301b5f9e7f62e61c8f2113615cc4ff9927f9b, {x=0x005255b811499293ea986c66b4698e0748284d391130afd3f9febbc71ef3b39fe13a3deaa1489d817b885edf270b1bf6; y=0xc9a1dcdb74a4ae432edea47750d754d918b2f1fd8d9ee612b4f0cf2bebcb0eeef43ef5d0ce90cb75362bd2cfe69bffad}, 0xd9e8d87abffb84c0c06fe47396aa84871f08420561a7d8cc64fef7796fc0ca9a5406a37a054cc8cd57e26a3a7249fdb3, {x=0x8da95367d9e731f86adda9bfae6ff170cf090be5223f3b33c0d7c6c585bfc1330137d237fdc16bd432797a1da1dfa331; y=0x114d8b24d75d0149603aa6eab6ccec1cd83f5baaca7898dd6edd7c2ca91176893102b9fe129a09f9fdb208e18be46d16});\n  (0xe74872524f90425d832a4f264e1f7b9209ec7456e9b4c467d8eac6c68f973ea7fea24f4d3fa8498bb1e26f933eaa261b\n  , { x=0xbbab93c429707b2afe9ac285314d7b40c4ee31531b13291aa9058307cdd038b572fdf2f3a84dc912804fa426fe531a3c\n    , y=0x4c2cffaa333bfd82b575918bb979bf51480c836082c097a03fed5454877b37d2f44f0401d212c16b05052bd383047b31\n    }\n  , 0xd4356773f2b311955542c5835696b9dca9d0e59197d5746bbf7dc079a666d955f74114662e38d31196bf94b060cc0c80\n  , { x=0xd40c63c65b413d0741c56e884f0dca63b822a6f6879d36f9261d9b4a270d5d79a9be790fdfb871b5d6ae9204da692663\n    , y=0x4d6b2b937c85b3c0c3cd2df85e9307cc89e0093f336af3b4531aa126bbdbec466562d8aa0dc1cf360fc1f1d0951e3ad1\n    })\n\n\/* ECDSA Operations {{{1 *\/\n\n\/** Operations for ECDSA abstraction layer *\/\ntype Curve fv gv = {\n    point_ops : PointOps fv gv\n  , base : AffinePoint fv\n  , affinify : JacobianPoint fv -> AffinePoint fv\n  , mul : (gv, AffinePoint fv) -> JacobianPoint fv\n  , twin_mul : (gv, AffinePoint fv, gv, AffinePoint fv) -> JacobianPoint fv\n  }\n\n\/* Create a public key from a private key *\/\ninitialize_public_key : {fv} (Curve [fv] [fv], [fv]) -> AffinePoint [fv]\ninitialize_public_key(c, k) = c.affinify(c.mul(k, c.base))\n\n\/**\n * Reference ECDSA signature algorithm as formalized from [ANSI X9.62-2005, pg 8]\n * Parameters:\n *  Curve c\n *  Private key d of signatory.\n *  Integer e obtained after hashing message on step e)\n *  Ephemeral EC private key in range [1 .. c.curve)\n *\/\necdsa_sign : {fv} (fin fv, fv >= 1) => (Curve [fv] [fv], [fv], [fv], [fv]) -> ([fv], [fv])\necdsa_sign(c,d,e,k) = if is_zero(r) || is_zero(s) then (0,0) else (r, s)\n  where\n    g = c.point_ops.group_field\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    \/* Compute x coordinate of public key. *\/\n    j = (c.affinify(c.mul(k, c.base))).x\n    \/* c) Set r = j mod n *\/\n    r = g.norm(j)\n    s = g.div(g.add(g.norm(e), g.mul(d, r)), k)\n\n\/**\n * Reference ECDSA signature verification algorithm as formalized from [ANSI X9.62-2005, pg 9]\n * Parameters\n *  Curve c\n *  Integer e' obtained after hashing message on  step \"c\".\n *  Pair returned by ref_ecdsa_sign algorithm.\n *  Public key of key signatory.\n * Result:\n *  Bit that is True if verification suceeds, and false otherwise.\n *\/\necdsa_public_verify : {fv} (fin fv, fv >= 1)\n   => (Curve [fv] [fv], [fv], ([fv], [fv]), AffinePoint [fv]) -> Bit\necdsa_public_verify(c, e, (r, s), q)\n    \/* h) Compare v and r' if v = r', output \"valid\"; otherwise output \"invalid\". *\/\n   = in_range(s) && (v == r)\n  where\n    f = c.point_ops.field\n    g = c.point_ops.group_field\n    mul(x,y) = g.mul(x, y)\n    div(x,y) = g.div(x, y)\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    in_range(x) = ~is_zero(x) && g.is_val(x)\n    s_inv = div(1, s)\n    u1 = mul(e, s_inv)\n    u2 = mul(r, s_inv)\n    r2 = c.twin_mul(u1, c.base, u2, q)\n    \/* f) Convert the field element x_r to an integer j as described in A.5 *\/\n    j = f.mul(r2.x, f.sq(f.div(f.field_unit, r2.z)))\n    \/* g) v = j mod n *\/\n    v = g.norm(j)\n\n\/* This version performs a cheaper sequence of operations, and matches\n * the Java implementation. Correspondence between the reference and\n * implementation versions of ecdsa_public_verify is probably best proved\n * independent of the Java code.\n *\/\necdsa_public_verify_imp :\n  (Curve [384] [384], [384], ([384], [384]), AffinePoint [384]) -> Bit\necdsa_public_verify_imp(c, e, (r, s), q)\n   = in_range(r) && in_range(s) &&\n     ~is_zero(r2.z) &&\n     (g.is_equal(j, r2.x) || ((carrybits == False) && (g.is_equal(k, r2.x))))\n  where\n    f = c.point_ops.field\n    g = c.point_ops.group_field\n    mul(x,y) = g.mul(x, y)\n    div(x,y) = g.div(x, y)\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    in_range(x) = ~is_zero(x) && g.is_val(x)\n    s_inv = div(1, s)\n    u1 = mul(g.norm(e), s_inv)\n    u2 = mul(r, s_inv)\n    r2 = c.twin_mul(u1, c.base, u2, q)\n    r2zsq = f.sq(r2.z)\n    j = f.mul(r, r2zsq)\n    summ = r + p384_group_size\n    carrybits = (summ < r) && (summ < p384_group_size)\n    k = f.mul(summ, r2zsq)\n\ntype RsltWithCarry a b = { carrybits : a , rslt : b }\n\np384_incFieldPrime : [384] -> RsltWithCarry [32] [384]\np384_incFieldPrime x = { carrybits = zero # [(bs @ 0)]\n                       , rslt = drop(bs) : [384]\n                       }\n  where bs = safe_add(x, p384_prime)\n\np384_decFieldPrime : [384] -> RsltWithCarry [32] [384]\np384_decFieldPrime x = { carrybits = if (bs @ 0) then -1 else 0\n                       , rslt = drop(bs) : [384]\n                       }\n  where bs = safe_sub(x, p384_prime)\n\np384_field_cube(x)       = p384_field_mul(x, p384_field_sq(x))\n\n\/** P384 curve operations {{{2 *\/\n\np384_base : AffinePoint [384]\np384_base = nzAffinePoint(\n  join [0xaa87ca22, 0xbe8b0537, 0x8eb1c71e, 0xf320ad74, 0x6e1d3b62, 0x8ba79b98\n       ,0x59f741e0, 0x82542a38, 0x5502f25d, 0xbf55296c, 0x3a545e38, 0x72760ab7],\n  join [0x3617de4a, 0x96262c6f, 0x5d9e98bf, 0x9292dc29, 0xf8f41dbd, 0x289a147c\n       ,0xe9da3113, 0xb5f0b8c0, 0x0a60b1ce, 0x1d7e819d, 0x7a431d7c, 0x90ea0e5f])\n\n\n\np384_group_add : ([384],[384]) -> [384]\np384_group_add = p384_group_field.add\n\np384_curve : Curve [384] [384]\np384_curve =\n  { point_ops = p384_point_ops\n  , base = p384_base\n  , affinify = \\x -> ec_affinify(p384_field, x)\n  , mul = p384_ec_mul\n  , twin_mul = p384_ec_twin_mul\n  }\n\np384_ecdsa_sign : ([384], [384], [384]) -> { r:[384], s:[384] }\np384_ecdsa_sign(d,e,k) = { r = rr, s = ss }\n  where (rr, ss) = ecdsa_sign(p384_curve,d,e,k)\n\np384_ecdsa_public_verify : ([384], [384], [384], AffinePoint [384]) -> Bit\np384_ecdsa_public_verify(e,pr,ps,q) =\n  ecdsa_public_verify_imp(p384_curve,e,(pr,ps),q)\n\n\/* Curve \"a\" parameter, defined in [FIPS-186-3, page 87] to be -3 *\/\np384_a : [384]\np384_a = p384_prime - 3\n\n\/* Curve \"b\" parameter, defined in [FIPS-186-3, page 89] *\/\np384_b : [384]\np384_b = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\n\n\n\/* Convert a p384 Jacobian point to an affine point *\/\n\/\/ p384_affinify : JacobianPoint [384] -> AffinePoint [384]\n\/\/ p384_affinify p = ec_affinify(p384_field, p)\n\n\/* Convert a p384 affine point to a Jacobian point *\/\np384_jacobify : AffinePoint [384] -> JacobianPoint [384]\np384_jacobify p = { x = p.x, y = p.y, z = 1 }\n\np384_base4 : JacobianPoint [384]\np384_base4 = p384_ec_double(p384_ec_double(p384_jacobify(p384_base)))\n\np384_base3 : AffinePoint [384]\np384_base3 = p384_affinify(p384_ec_full_sub(p384_base4, p384_base))\n\np384_base5 : AffinePoint [384]\np384_base5 = p384_affinify(p384_ec_full_add(p384_base4, p384_base))\n\n\n\/* Does an affine point lie on the curve? *\/\np384_is_affine_point : AffinePoint [384] -> Bit\np384_is_affine_point p =\n  p384_field_sq(p.y) ==\n  p384_field_add(p384_field_cube(p.x),\n                 p384_field_add(p384_field_mul(p384_a, p.x), p384_b))\n\n\/* Tests for p384 *\/\n\n\/* Point \"S\" defined in [NSA 2008, Section 4.4.2] *\/\np384_s : AffinePoint [384]\np384_s = nzAffinePoint(\n  join [0xfba203b8, 0x1bbd23f2, 0xb3be971c, 0xc23997e1, 0xae4d89e6, 0x9cb6f923,\n        0x85dda827, 0x68ada415, 0xebab4167, 0x459da98e, 0x62b1332d, 0x1e73cb0e],\n  join [0x5ffedbae, 0xfdeba603, 0xe7923e06, 0xcdb5d0c6, 0x5b223014, 0x29293376,\n        0xd5c6944e, 0x3fa6259f, 0x162b4788, 0xde6987fd, 0x59aed5e4, 0xb5285e45])\n\n\/* Point \"T\" defined in [NSA 2008, Section 4.4.2] *\/\np384_t : AffinePoint [384]\np384_t = nzAffinePoint(\n  join [0xaacc0520, 0x2e7fda6f, 0xc73d82f0, 0xa6622052, 0x7da8117e, 0xe8f8330e,\n        0xad7d20ee, 0x6f255f58, 0x2d8bd38c, 0x5a7f2b40, 0xbcdb68ba, 0x13d81051],\n  join [0x84009a26, 0x3fefba7c, 0x2c57cffa, 0x5db3634d, 0x286131af, 0xc0fca8d2,\n        0x5afa22a7, 0xb5dce0d9, 0x470da892, 0x33cee178, 0x592f49b6, 0xfecb5092])\n\n\/* Multiple \"D\" defined in [NSA 2008, Section 4.4.2] *\/\np384_d =\n  join [0xa4ebcae5, 0xa6659834, 0x93ab3e62, 0x6085a24c, 0x104311a7, 0x61b5a8fd,\n        0xac052ed1, 0xf111a5c4, 0x4f76f456, 0x59d2d111, 0xa61b5fdd, 0x97583480]\n\n\/* Multiple \"E\" defined in [NSA 2008, Section 4.4.2] *\/\np384_e =\n  join [0xafcf8811, 0x9a3a76c8, 0x7acbd600, 0x8e1349b2, 0x9f4ba9aa, 0x0e12ce89,\n        0xbcfcae21, 0x80b38d81, 0xab8cf150, 0x95301a18, 0x2afbc689, 0x3e75385d]\n\np384_projectify : AffinePoint [384] -> JacobianPoint [384]\np384_projectify(p) = ec_projectify(f,p)\n  where f = p384_curve.point_ops.field\n\np384_affinify : JacobianPoint [384] -> AffinePoint [384]\np384_affinify(p) = ec_affinify(f,p)\n  where f = p384_curve.point_ops.field\n\ntest_p384_s_plus_t : AffinePoint [384]\ntest_p384_s_plus_t = p384_affinify(add(p384_projectify(s),t))\n  where s = p384_s\n        t = p384_t\n        add = p384_curve.point_ops.add\n\nexpected_p384_s_plus_t : AffinePoint [384]\nexpected_p384_s_plus_t =\n  { x = join [0x12dc5ce7, 0xacdfc584, 0x4d939f40, 0xb4df012e, 0x68f865b8, 0x9c3213ba,\n              0x97090a24, 0x7a2fc009, 0x075cf471, 0xcd2e85c4, 0x89979b65, 0xee0b5eed]\n  , y = join [0x167312e5, 0x8fe0c0af, 0xa248f285, 0x4e3cddcb, 0x557f983b, 0x3189b67f,\n              0x21eee013, 0x41e7e9fe, 0x67f6ee81, 0xb36988ef, 0xa406945c, 0x8804a4b0]\n  }\n\ntest_p384_s_minus_t : AffinePoint [384]\ntest_p384_s_minus_t = p384_affinify(sub(p384_projectify(s),t))\n  where s = p384_s\n        t = p384_t\n        sub = p384_curve.point_ops.sub\n\nexpected_p384_s_minus_t : AffinePoint [384]\nexpected_p384_s_minus_t =\n  { x = join [0x6afdaf8d, 0xa8b11c98, 0x4cf177e5, 0x51cee542, 0xcda4ac2f, 0x25cd522d,\n              0x0cd710f8, 0x8059c656, 0x5aef78f6, 0xb5ed6cc0, 0x5a6666de, 0xf2a2fb59]\n  , y = join [0x7bed0e15, 0x8ae8cc70, 0xe847a603, 0x47ca1548, 0xc348decc, 0x6309f48b,\n              0x59bd5afc, 0x9a9b804e, 0x7f787617, 0x8cb5a7eb, 0x4f6940a9, 0xc73e8e5e]\n  }\n\ntest_p384_double_s : AffinePoint [384]\ntest_p384_double_s = p384_affinify(dbl(p384_projectify(s)))\n  where s = p384_s\n        dbl = p384_curve.point_ops.double\n\nexpected_p384_double_s : AffinePoint [384]\nexpected_p384_double_s =\n  { x = join [0x2a2111b1, 0xe0aa8b2f, 0xc5a19755, 0x16bc4d58, 0x017ff96b, 0x25e1bdff,\n              0x3c229d5f, 0xac3bacc3, 0x19dcbec2, 0x9f9478f4, 0x2dee597b, 0x4641504c]\n  , y = join [0xfa2e3d9d, 0xc84db895, 0x4ce8085e, 0xf28d7184, 0xfddfd134, 0x4b4d4797,\n              0x343af9b5, 0xf9d83752, 0x0b450f72, 0x6443e411, 0x4bd4e5bd, 0xb2f65ddd]\n  }\n\ntest_p384_ds : AffinePoint [384]\ntest_p384_ds = p384_affinify(mul(p384_d, p384_s))\n  where mul = p384_curve.mul\n\nexpected_p384_ds : AffinePoint [384]\nexpected_p384_ds =\n  { x = join [0xe4f77e7f, 0xfeb7f095, 0x8910e3a6, 0x80d677a4, 0x77191df1, 0x66160ff7,\n              0xef6bb526, 0x1f791aa7, 0xb45e3e65, 0x3d151b95, 0xdad3d93c, 0xa0290ef2]\n  , y = join [0xac7dee41, 0xd8c5f4a7, 0xd5836960, 0xa773cfc1, 0x376289d3, 0x373f8cf7,\n              0x417b0c62, 0x07ac32e9, 0x13856612, 0xfc9ff2e3, 0x57eb2ee0, 0x5cf9667f]\n  }\n\ntest_p384_ds_et : AffinePoint [384]\ntest_p384_ds_et = p384_affinify(twin_mul(p384_d, p384_s, p384_e, p384_t))\n  where twin_mul = p384_curve.twin_mul\n\nexpected_p384_ds_et : AffinePoint [384]\nexpected_p384_ds_et =\n  { x = join [0x917ea28b, 0xcd641741, 0xae5d18c2, 0xf1bd917b, 0xa68d34f0, 0xf0577387,\n              0xdc812604, 0x62aea60e, 0x2417b8bd, 0xc5d954fc, 0x729d211d, 0xb23a02dc]\n  , y = join [0x1a29f7ce, 0x6d074654, 0xd77b4088, 0x8c73e925, 0x46c8f16a, 0x5ff6bcbd,\n              0x307f758d, 0x4aee684b, 0xeff26f67, 0x42f597e2, 0x585c86da, 0x908f7186]\n  }\n\nproperty test_plus =\n  test_p384_s_plus_t  == expected_p384_s_plus_t\n\nproperty test_minus =\n  test_p384_s_minus_t == expected_p384_s_minus_t\n\nproperty test_double =\n  test_p384_double_s  == expected_p384_double_s\n\nproperty test_ds =\n  test_p384_ds    == expected_p384_ds\n\nproperty test_ds_et =\n  test_p384_ds_et == expected_p384_ds_et\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Common\/EC\/ec_point_ops.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the elliptic curve point operations defined in the module Common::EC::ec_point_ops.cry. Specifically, specify properties that check: 1) ec_affinify correctly converts a JacobianPoint with non-zero z to an AffinePoint; 2) ec_projectify is the inverse of ec_affinify for valid points; 3) ec_double correctly doubles a JacobianPoint; 4) ec_add correctly adds a JacobianPoint and an AffinePoint; and 5) ec_is_zero_point correctly identifies the zero point. Include properties to ensure that the is_JacobianPoint predicate holds for outputs of these operations. The properties should be suitable for Cryptol's :prove or :check commands."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::ec_point_ops where\n\nimport Common::Field\nimport Common::Set\n\ntype AffinePoint fv = { x : fv, y : fv }\n\n\/* Return an affine point. *\/\nnzAffinePoint : {fv} (fv,fv) -> AffinePoint fv\nnzAffinePoint (ax,ay) = { x = ax, y = ay }\n\n\/* Define Jacobian points *\/\ntype JacobianPoint fv = { x : fv, y : fv, z : fv }\n\n\/* Create affine point from Jacobian (only well-defined if z coordinate is non-zero). *\/\nec_affinify : {fv} (Field fv, JacobianPoint fv) -> AffinePoint fv\nec_affinify(f,s) = { x = f.mul(g2, s.x), y = f.mul(g3, s.y) }\n  where g = f.div(f.field_unit, s.z)\n        g2 = f.sq(g)\n        g3 = f.mul(g, g2)\n\n\/* Create projective value from affine. *\/\n\/* Routine 2.2.1 in [NSA 2008] *\/\nec_projectify : {fv} (Field fv, AffinePoint fv) -> JacobianPoint fv\nec_projectify(f,s) = { x = s.x, y = s.y, z = f.field_unit }\n\n\/* Returns zero point. *\/\nec_zero_point : {fv} Field fv -> JacobianPoint fv\nec_zero_point(f) = { x = f.field_unit, y = f.field_unit, z = f.field_zero }\n\n\/* Checks to see if point is zero. *\/\nec_is_zero_point : {fv} (Field fv, JacobianPoint fv) -> Bit\nec_is_zero_point(f,s) = f.is_equal(s.z, f.field_zero)\n\n\/* Is the Jacobian point well-formed? Here we assume\n** the only valid zero-point is the unit zero point.\n** NOTE: The output of ECC operations in this file always\n**   satisfies this assumption. However, they are more\n**   permissive in their inputs, i.e. they still do the\n**   right thing when given a non-unit zero point.\n*\/\nis_JacobianPoint : {fv} (Cmp fv) => Field fv -> Set (JacobianPoint fv)\nis_JacobianPoint f s =\n  (  f.is_val ((s:JacobianPoint fv).x)\n  && f.is_val (s.y)\n  && f.is_val (s.z)\n  && implies (ec_is_zero_point (f,s))\n             (s == ec_zero_point f)\n  )\n\ntype PointOps fv gv = {\n       field : Field fv\n     , double : JacobianPoint fv -> JacobianPoint fv\n     , add : (JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\n     , sub : (JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\n     , group_field : Field gv\n     }\n\n\/* Double a Jacobian point *\/\n\/* Line numbers taken from Routine 2.2.6 in [NSA 2008] *\/\n\/* This version uses 4 multiplies and 4 squarings (4M + 4S).  The paper\n   \"A software implementation of NIST P-224\" by Bernstein 2001 has a\n   version that uses 3M + 5S.\n   In that version, there are the following correspondances\n     r7  = delta\n     r11 = alpha\n     r14 = gamma\n     r15 = beta\n     r16 = 4*beta\n     r17 = alpha^2\n     r18 = x3 = alpha^2 - 8*beta\n     r12 = y1 * z1\n   The key difference is to replace the computation of r13\n    with \"r13 = (s.y + s.z)^2 - s.y^2 - s.z^2\".\n   *\/\nec_double : {fv} (Field fv, JacobianPoint fv) -> JacobianPoint fv\nec_double(f,s) =\n  if is_zero(s.z) then\n    { x = f.field_unit, y = f.field_unit, z = f.field_zero } \/* 5: r <- (1,1,0) and return *\/\n  else\n    { x = r18, y = r23, z = r13 }\n where\n   add = f.add\n   sub = f.sub\n   mul = f.mul\n   is_zero(x) = f.is_equal(x, f.field_zero)\n   dbl(x) = f.add(x, x)\n   mul3(x) = f.add(x, f.add(x, x))\n   mul4(x) = dbl(dbl(x))\n   mul8(x) = dbl(mul4(x))\n\n   r7  = f.sq(s.z)               \/*  7: t4 <- (t3)^2 *\/\n   r8  = f.sub(s.x, r7)          \/*  8: t5 <- t1 - t4 *\/\n   r9  = add(s.x, r7)            \/*  9: t4 <- t1 + t4 *\/\n   r10 = mul(r9, r8)             \/* 10: t5 <- t4 * t5 *\/\n   r11 = mul3(r10)               \/* 11: t4 <- 3 * t5 *\/\n   r12 = mul(s.z, s.y)           \/* 12: t3 <- t3 * t2 *\/\n   r13 = dbl(r12)                \/* 13: t3 <- 2 * t3 *\/\n   r14 = f.sq(s.y)               \/* 14: t2 <- (t2)^2 *\/\n   r15 = mul(s.x, r14)           \/* 15: t5 <- t1 * t2 *\/\n   r16 = mul4(r15)               \/* 16: t5 <- 4 * t5 *\/\n   r17 = f.sq(r11)               \/* 17: t1 <- (t4)^2 *\/\n   r18 = sub(sub(r17, r16), r16) \/* 18: t1 <- t1 - 2 * t5 *\/\n   r19 = f.sq(r14)               \/* 19: t2 <- (t2)^2 *\/\n   r20 = mul8(r19)                  r21 = sub(r16, r18)              r22 = mul(r11, r21)              r23 = sub(r22, r20)           \/**\n * Add a Jacobian point to an affine point over the given field.\n * Note: Will return { 0, 0, 0 } if points are equivalent, and double should be\n *       called.\n * Algorithm comes from Routine 2.2.7 in [NSA 2008].\n *\/\nec_add : {fv, gv} (PointOps fv [gv], JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\nec_add(p,s,t) =\n  if is_zero(r13) then\n    if is_zero(r14) then\n      p.double(s)     else\n      { x = p.field.field_unit\n      , y = p.field.field_unit\n      , z = p.field.field_zero\n      }   else\n    { x = r32, y = r37, z = r27 }\n  where\n   add = p.field.add\n   sub = p.field.sub\n   mul = p.field.mul\n   sq  = p.field.sq\n   is_zero(x) = p.field.is_equal(x, p.field.field_zero)\n   dbl(x) = add(x, x)\n   dbl_dec(x, y) = sub(sub(x, y), y)\n   \/* Line numbers from Routine 2.2.7 definition. *\/\n\n   r9 = sq(s.z)             \/*  9: t7 <- (t3)^2 *\/\n   r10 = mul(t.x, r9)       \/* 10: t4 <- t4 * t7 *\/\n   r11 = mul(s.z, r9)       \/* 11: t7 <- t3 * t7 *\/\n   r12 = mul(t.y, r11)         r13 = sub(s.x, r10)         r14 = sub(s.y, r12)         r22 = sub(dbl(s.x), r13)    r23 = sub(dbl(s.y), r14)    r27 = mul(s.z, r13)         r28 = sq(r13)               r29 = mul(r13, r28)      \/* 29: t4 <- t4 * t7 *\/\n   r30 = mul(r22, r28)      \/* 30: t7 <- t1 * t7 *\/\n   r31 = sq(r14)            \/* 31: t1 <- (t1)^2 *\/\n   r32 = sub(r31, r30)      \/* 32: t1 <- t1 - t7 *\/\n   \/*r33 = sub(r30, dbl(r32))*\/ \/* 33: t7 <- t7 - 2*t1 *\/\n   \/* The following is a better match for the Java implementation. *\/\n   r33 = dbl_dec(r30, r32)  \/* 33: t7 <- t7 - 2*t1 *\/\n   r34 = mul(r14, r33)      \/* 34: t5 <- t5 * t7 *\/\n   r35 = mul(r23, r29)      \/* 35: t4 <- t2 * t4 *\/\n   r36 = sub(r34, r35)      \/* 36: t2 <- t5 - t4 *\/\n   r37 = p.field.half(r36)  \/* Add Jacobian point to an affine point over the given field. *\/\n\/* Algorithm comes from Routine 2.2.8 in [NSA 2008] *\/\nec_full_add : {fv, gv} (fin gv) => (PointOps fv [gv], JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\nec_full_add(p, s, t) =\n  if is_zero(s.z) then\n    { x = t.x, y = t.y, z = p.field.field_unit }\n  else\n    ec_add(p, s, t)\n where\n   is_zero(x) = p.field.is_equal(x, p.field.field_zero)\n\n\/* Subtract affine point from Jacobian point over the given field. *\/\n\/* Algorithm comes from Routine 2.2.9 in [NSA 2008] *\/\nec_full_sub : {fv, gv} (PointOps fv [gv], JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\nec_full_sub(p, s, t) = p.add(s, { x = t.x, y = p.field.neg(t.y) })\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Common\/EC\/p384_field.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the P-384 prime field arithmetic operations defined in the module Common::EC::p384_field.cry. Include properties that check the field axioms (associativity, commutativity, distributivity, existence of additive and multiplicative identities and inverses) for the addition, subtraction, negation, multiplication, squaring, halving, and division functions modulo the P-384 prime. Also specify properties ensuring that the normalization functions produce values within the field range and that the modular reduction function correctly reduces 768-bit inputs to 384-bit field elements. Use these properties to enable automated verification of the field implementation."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::p384_field where\n\nimport Common::bv\nimport Common::mod_arith\nimport Common::mul_java\nimport Common::Field\n\np384_prime : [384]\np384_prime = - (2 ^^ 384 + 2 ^^ 128 + 2 ^^ 96 - 2 ^^ 32 + 1)\n\n\/\/ Give explicit names to these finite field operators, so SBV\n\/\/  can uninterpret them.\np384_is_field_val : [384] -> Bit\np384_is_field_val = is_normal p384_prime\n\np384_is_group_val : [384] -> Bit\np384_is_group_val  = is_normal p384_group_size\n\np384_mod_add : ([384],[384],[384]) -> [384]\np384_mod_add = mod_add\n\np384_mod_sub : ([384],[384],[384]) -> [384]\np384_mod_sub = mod_sub\n\np384_mod_neg : ([384], [384]) -> [384]\np384_mod_neg = mod_neg\n\np384_safe_product : ([384], [384]) -> [768]\np384_safe_product (x, y) = safe_product(x, y)\n\np384_field_add(x,y) = p384_mod_add(p384_prime, x, y)\np384_field_sub(x,y) = p384_mod_sub(p384_prime, x, y)\n\/* p384_field_neg(x) returns -x mod p384_prime. *\/\np384_field_neg(x)        = if x == 0 then 0 else (p384_prime - x)\n\np384_field_mul : ([384],[384]) -> [384]\np384_field_mul(x,y)      = p384_field_mod(p384_safe_product(x, y))\n\np384_field_sq(x)         = p384_field_mul(x, x)\n\np384_mod_half : ([384],[384]) -> [384]\np384_mod_half = mod_half\n\np384_mod_mul : ([384],[384],[384]) -> [384]\np384_mod_mul = mod_mul\n\np384_mod_div : ([384],[384],[384]) -> [384]\np384_mod_div = mod_div\n\n\/\/ P384 field reference modulus.\np384_field_mod : [768] -> [384]\np384_field_mod(a)\n    = drop(if b1 then r0\n           else if b2 then r1\n           else if b3 then r2\n           else if b4 then r3\n           else r4)\n  where\n    [  a23, a22, a21, a20, a19, a18, a17, a16, a15, a14, a13, a12,\n       a11, a10,  a9,  a8,  a7,  a6,  a5,  a4,  a3,  a2,  a1,  a0]\n              = [ zext x | (x : [32]) <- split a ] : [24][64]\n\n    chop : [64] -> ([64],[32])\n    chop x = (sext(take(x):[32]), drop(x))\n\n    (d0, z0)  = chop(    a0          +a12+a21        +a20-a23)\n    (d1, z1)  = chop(d0 +a1          +a13+a22+a23        -a12-a20)\n    (d2, z2)  = chop(d1 +a2          +a14+a23            -a13-a21)\n    (d3, z3)  = chop(d2 +a3          +a15+a12+a20    +a21-a14-a22-a23)\n    (d4, z4)  = chop(d3 +a4 +(a21<<1)+a16+a13+a12+a20+a22-a15-(a23<<1))\n    (d5, z5)  = chop(d4 +a5 +(a22<<1)+a17+a14+a13+a21+a23-a16)\n    (d6, z6)  = chop(d5 +a6 +(a23<<1)+a18+a15+a14+a22    -a17)\n    (d7, z7)  = chop(d6 +a7          +a19+a16+a15+a23    -a18)\n    (d8, z8)  = chop(d7 +a8          +a20+a17+a16        -a19)\n    (d9, z9)  = chop(d8 +a9          +a21+a18+a17        -a20)\n    (d10,z10) = chop(d9 +a10         +a22+a19+a18        -a21)\n    (d11,z11) = chop(d10+a11         +a23+a20+a19        -a22)\n\n    r : [13*32]\n    r = (drop(d11):[32])\n      # z11 # z10 #  z9 #  z8 #  z7 #  z6\n      #  z5 #  z4 #  z3 #  z2 #  z1 #  z0\n\n    p  = zext(p384_prime) : [13*32]\n    \/\/ Fix potential underflow\n    r0 = if (d11@0) then r + p else r\n    \/\/ Fix potential overflow\n    (r1,b1)   = sbb(r0, p)\n    (r2,b2)   = sbb(r1, p)\n    (r3,b3)   = sbb(r2, p)\n    (r4,b4)   = sbb(r3, p)\n\n\/* Defines a reference prime field that uses normalized numbers and\n   large word bit operations. *\/\np384_field :  Field [384]\np384_field = {\n    is_val     = p384_is_field_val\n  , norm       = \\x -> if x < p384_prime then x else x - p384_prime\n  , add        = p384_field_add\n  , sub        = p384_field_sub\n  , neg        = p384_field_neg\n  , mul        = p384_field_mul\n  , sq         = p384_field_sq\n  , half       = \\x -> p384_mod_half(p384_prime, x)\n  , div        = \\(x,y) -> p384_mod_div(p384_prime, x, y)\n  , field_zero = 0\n  , field_unit = 1\n  , is_equal   = \\(x,y) -> x == y\n  }\n\np384_group_size : [384]\np384_group_size =\n  join\n    [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n     0xc7634d81, 0xf4372ddf, 0x581a0db2, 0x48b0a77a, 0xecec196a, 0xccc52973]\n\n\/* Defines a reference prime field that uses normalized numbers and\n   large word bit operations. *\/\np384_group_field :  Field [384]\np384_group_field =\n  { is_val     = p384_is_group_val\n  , norm       = \\x -> if x < p384_group_size then x else x - p384_group_size\n  , add        = \\(x,y) -> p384_mod_add(p384_group_size, x, y)\n  , sub        = \\(x,y) -> p384_mod_sub(p384_group_size, x, y)\n  , neg        = \\x     -> p384_mod_neg(p384_group_size, x)\n  , mul        = \\(x,y) -> p384_group_mul(p384_group_size, x, y)\n  , sq         = \\x     -> p384_mod_mul(p384_group_size, x, x)\n  , half       = \\x     -> p384_mod_half(p384_group_size, x)\n  , div        = \\(x,y) -> p384_mod_div(p384_group_size, x, y)\n  , field_zero = 0\n  , field_unit = 1\n  , is_equal   = \\(x,y) -> x == y\n  }\n```"}]}
{"filename":"saw-demos\/templates\/c\/dotprod.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the 'dotprod' function defined as the dot product of two vectors. Include properties that check the function's behavior for various vector lengths and element types, ensuring it satisfies linearity and distributivity properties expected of a dot product."},{"role":"assistant","content":"```cryptol\ndotprod : {n, a} (fin n, Eq a, Ring a) => [n]a -> [n]a -> a\ndotprod xs ys = sum (zipWith (*) xs ys)\n```"}]}
{"filename":"saw-demos\/demos\/xxhash\/xxhash.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the XXH32 and XXH64 hash functions defined in the xxhash module. Include properties that check the consistency of the prime constants, the correctness of the initialization functions, and that the round, digest, converge, and avalanche functions behave as expected on sample inputs. Also, specify properties to ensure that the hash functions produce consistent outputs for the same inputs and seeds."},{"role":"assistant","content":"```cryptol\nmodule xxhash where\n\n\/**\n * The 32-bit variant of xxHash. The first argument is the sequence\n * of L bytes to hash. The second argument is a seed value.\n *\/\nXXH32 : {L} (fin L) => [L][8] -> [32] -> [32]\nXXH32 input seed = XXH32_avalanche acc1\n  where (stripes16 # stripes4 # stripes1) = input\n        accR = foldl XXH32_rounds (XXH32_init seed) (split stripes16 : [L\/16][16][8])\n        accL = `(L % 2^^32) + if (`L:Integer) < 16\n                              then seed + PRIME32_5\n                              else XXH32_converge accR\n        acc4 = foldl XXH32_digest4 accL (split stripes4 : [(L%16)\/4][4][8])\n        acc1 = foldl XXH32_digest1 acc4 (stripes1 : [L%4][8])\n\n\/**\n * The 64-bit variant of xxHash. The first argument is the sequence\n * of L bytes to hash. The second argument is a seed value.\n *\/\nXXH64 : {L} (fin L) => [L][8] -> [64] -> [64]\nXXH64 input seed = XXH64_avalanche acc1\n  where (stripes32 # stripes8 # stripes4 # stripes1) = input\n        accR = foldl XXH64_rounds (XXH64_init seed) (split stripes32 : [L\/32][32][8])\n        accL = `(L % 2^^64) + if (`L:Integer) < 32\n                              then seed + PRIME64_5\n                              else XXH64_converge accR\n        acc8 = foldl XXH64_digest8 accL (split stripes8 : [(L%32)\/8][8][8])\n        acc4 = foldl XXH64_digest4 acc8 (split stripes4 : [(L%8)\/4][4][8])\n        acc1 = foldl XXH64_digest1 acc4 (stripes1 : [L%4][8])\n\nprivate\n\n  \/\/Utility functions\n\n  \/**\n   * Combines a sequence of bytes into a word using the little-endian\n   * convention.\n   *\/\n  toLE bytes = join (reverse bytes)\n\n  \/\/32-bit xxHash helper functions\n\n  \/\/32-bit prime number constants\n  PRIME32_1 = 0x9E3779B1 : [32]\n  PRIME32_2 = 0x85EBCA77 : [32]\n  PRIME32_3 = 0xC2B2AE3D : [32]\n  PRIME32_4 = 0x27D4EB2F : [32]\n  PRIME32_5 = 0x165667B1 : [32]\n\n  \/**\n   * The property shows that the hexadecimal representation of the\n   * PRIME32 constants is the same as the binary representation.\n   *\/\n  property PRIME32s_as_bits_correct =\n    (PRIME32_1 == 0b10011110001101110111100110110001) \/\\\n    (PRIME32_2 == 0b10000101111010111100101001110111) \/\\\n    (PRIME32_3 == 0b11000010101100101010111000111101) \/\\\n    (PRIME32_4 == 0b00100111110101001110101100101111) \/\\\n    (PRIME32_5 == 0b00010110010101100110011110110001)\n\n  \/**\n   * This function initializes the four internal accumulators of XXH32.\n   *\/\n  XXH32_init : [32] -> [4][32]\n  XXH32_init seed = [acc1, acc2, acc3, acc4]\n    where acc1 = seed + PRIME32_1 + PRIME32_2\n          acc2 = seed + PRIME32_2\n          acc3 = seed + 0\n          acc4 = seed - PRIME32_1\n\n  \/**\n   * This processes a single lane of the main round function of XXH32.\n   *\/\n  XXH32_round : [32] -> [32] -> [32]\n  XXH32_round accN laneN = ((accN + laneN * PRIME32_2) <<< 13) * PRIME32_1\n\n  \/**\n   * This is the main round function of XXH32 and processes a stripe,\n   * i.e. 4 lanes with 4 bytes each.\n   *\/\n  XXH32_rounds : [4][32] -> [16][8] -> [4][32]\n  XXH32_rounds accs stripe =\n    [ XXH32_round accN (toLE laneN) | accN <- accs | laneN <- split stripe ]\n\n  \/**\n   * This function combines the four lane accumulators into a single\n   * 32-bit value.\n   *\/\n  XXH32_converge : [4][32] -> [32]\n  XXH32_converge [acc1, acc2, acc3, acc4] =\n    (acc1 <<< 1) + (acc2 <<< 7) + (acc3 <<< 12) + (acc4 <<< 18)\n\n  \/**\n   * This function digests a four byte lane\n   *\/\n  XXH32_digest4 : [32] -> [4][8] -> [32]\n  XXH32_digest4 acc lane = ((acc + toLE lane * PRIME32_3) <<< 17) * PRIME32_4\n\n  \/**\n   * This function digests a single byte lane\n   *\/\n  XXH32_digest1 : [32] -> [8] -> [32]\n  XXH32_digest1 acc lane = ((acc + (0 # lane) * PRIME32_5) <<< 11) * PRIME32_1\n\n  \/**\n   * This function ensures that all input bits have a chance to impact\n   * any bit in the output digest, resulting in an unbiased\n   * distribution.\n   *\/\n  XXH32_avalanche : [32] -> [32]\n  XXH32_avalanche acc0 = acc5\n    where acc1 = acc0 ^ (acc0 >> 15)\n          acc2 = acc1 * PRIME32_2\n          acc3 = acc2 ^ (acc2 >> 13)\n          acc4 = acc3 * PRIME32_3\n          acc5 = acc4 ^ (acc4 >> 16)\n\n  \/\/64-bit xxHash helper functions\n\n  \/\/64-bit prime number constants\n  PRIME64_1 = 0x9E3779B185EBCA87 : [64]\n  PRIME64_2 = 0xC2B2AE3D27D4EB4F : [64]\n  PRIME64_3 = 0x165667B19E3779F9 : [64]\n  PRIME64_4 = 0x85EBCA77C2B2AE63 : [64]\n  PRIME64_5 = 0x27D4EB2F165667C5 : [64]\n\n  \/**\n   * The property shows that the hexadecimal representation of the\n   * PRIME64 constants is the same as the binary representation.\n   *\/\n  property PRIME64s_as_bits_correct =\n    (PRIME64_1 == 0b1001111000110111011110011011000110000101111010111100101010000111) \/\\\n    (PRIME64_2 == 0b1100001010110010101011100011110100100111110101001110101101001111) \/\\\n    (PRIME64_3 == 0b0001011001010110011001111011000110011110001101110111100111111001) \/\\\n    (PRIME64_4 == 0b1000010111101011110010100111011111000010101100101010111001100011) \/\\\n    (PRIME64_5 == 0b0010011111010100111010110010111100010110010101100110011111000101)\n\n  \/**\n   * This function initializes the four internal accumulators of XXH64.\n   *\/\n  XXH64_init : [64] -> [4][64]\n  XXH64_init seed = [acc1, acc2, acc3, acc4]\n    where acc1 = seed + PRIME64_1 + PRIME64_2\n          acc2 = seed + PRIME64_2\n          acc3 = seed + 0\n          acc4 = seed - PRIME64_1\n\n  \/**\n   * This processes a single lane of the main round function of XXH64.\n   *\/\n  XXH64_round : [64] -> [64] -> [64]\n  XXH64_round accN laneN = ((accN + laneN * PRIME64_2) <<< 31) * PRIME64_1\n\n  \/**\n   * This is the main round function of XXH64 and processes a stripe,\n   * i.e. 4 lanes with 8 bytes each.\n   *\/\n  XXH64_rounds : [4][64] -> [32][8] -> [4][64]\n  XXH64_rounds accs stripe =\n    [ XXH64_round accN (toLE laneN) | accN <- accs | laneN <- split stripe ]\n\n  \/**\n   * This is a helper function, used to merge the four lane accumulators.\n   *\/\n  mergeAccumulator : [64] -> [64] -> [64]\n  mergeAccumulator acc accN = (acc ^ XXH64_round 0 accN) * PRIME64_1 + PRIME64_4\n\n  \/**\n   * This function combines the four lane accumulators into a single\n   * 64-bit value.\n   *\/\n  XXH64_converge : [4][64] -> [64]\n  XXH64_converge [acc1, acc2, acc3, acc4] =\n    foldl mergeAccumulator ((acc1 <<< 1) + (acc2 <<< 7) + (acc3 <<< 12) + (acc4 <<< 18)) [acc1, acc2, acc3, acc4]\n\n  \/**\n   * This function digests an eight byte lane\n   *\/\n  XXH64_digest8 : [64] -> [8][8] -> [64]\n  XXH64_digest8 acc lane = ((acc ^ XXH64_round 0 (toLE lane)) <<< 27) * PRIME64_1 + PRIME64_4\n\n  \/**\n   * This function digests a four byte lane\n   *\/\n  XXH64_digest4 : [64] -> [4][8] -> [64]\n  XXH64_digest4 acc lane = ((acc ^ (0 # toLE lane) * PRIME64_1) <<< 23) * PRIME64_2 + PRIME64_3\n\n  \/**\n   * This function digests a single byte lane\n   *\/\n  XXH64_digest1 : [64] -> [8] -> [64]\n  XXH64_digest1 acc lane = ((acc ^ (0 # lane) * PRIME64_5) <<< 11) * PRIME64_1\n\n  \/**\n   * This function ensures that all input bits have a chance to impact\n   * any bit in the output digest, resulting in an unbiased\n   * distribution.\n   *\/\n  XXH64_avalanche : [64] -> [64]\n  XXH64_avalanche acc0 = acc5\n    where acc1 = acc0 ^ (acc0 >> 33)\n          acc2 = acc1 * PRIME64_2\n          acc3 = acc2 ^ (acc2 >> 29)\n          acc4 = acc3 * PRIME64_3\n          acc5 = acc4 ^ (acc4 >> 32)\n```"}]}
{"filename":"saw-demos\/demos\/signal-protocol\/cryptol\/HMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the HMAC functions (hmac_init, hmac_update, hmac_final) in the provided HMAC.cry file. The specification should capture the relationship between the input key, input data, and the resulting MAC output, suitable for use in formal verification or property-based testing."},{"role":"assistant","content":"```cryptol\ntype HMAC_CONTEXT_LENGTH = 1\ntype HMACContext = [HMAC_CONTEXT_LENGTH][8]\n\ntype SIGNAL_MESSAGE_MAC_LENGTH = 8\n\nhmac_init : {n} [n][8] -> \/\/ Key\n            HMACContext\nhmac_init = undefined\n\nhmac_update : {n} [n][8] -> \/\/ Data\n              HMACContext -> HMACContext\nhmac_update = undefined\n\nhmac_final : HMACContext ->\n             [SIGNAL_MESSAGE_MAC_LENGTH][8] \/\/ Signal buffer\nhmac_final = undefined\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/AES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify that the AES encryption function 'encrypt' is equivalent to the composition of 'expandKey' followed by 'encryptWithSchedule' for all valid keys and plaintexts. Include properties that ensure the key expansion and encryption steps conform to the AES specification as defined in this module."},{"role":"assistant","content":"```cryptol\nmodule AES where\n\nimport `Common::AES\n\ntype constraint ValidKey k m = (k == 128 + m * 64, 2 >= m)\n\ntype ExpandedKey m = KeySchedule m\n\nencrypt : {k,m} ValidKey k m => [k] -> [128] -> [128]\nencrypt = aesEncrypt`{Mode = m}\n\nexpandKey : {k,m} ValidKey k m => [k] -> ExpandedKey m\nexpandKey = ExpandKey`{Mode = m}\n\nencryptWithSchedule : {k,m} ValidKey k m => ExpandedKey m -> [128] -> [128]\nencryptWithSchedule = aesEncryptWithSchedule`{Mode = m}\n\nproperty test k pt = encrypt k pt == encryptWithSchedule (expandKey k) pt\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/AES128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that formally defines the expected behavior of the AES-128 encryption functions provided in the AES128 module, including sub_bytes128, shift_rows128, expand_key128, aes_round128, aes_final_round128, and encryptState128. The specification should capture the correct transformations on the State and KeySchedule types and enable formal verification of the AES-128 encryption process."},{"role":"assistant","content":"```cryptol\n\/\/ 128-bit AES\nmodule AES128 where\n\nimport `Common::AES\nimport `Common::AES as AES\nimport AES as AES\n\ntype State         = AES::State 0  \/* 0 is unused *\/\ntype KeySchedule   = AES::KeySchedule 0\ntype RoundKey      = AES::RoundKey 0\n\nsub_bytes128 : State -> State\nsub_bytes128 = SubBytes`{0}\n\nshift_rows128 : State -> State\nshift_rows128 = ShiftRows`{0}\n\nexpand_key128 : [128] -> KeySchedule\nexpand_key128 = AES::expandKey\n\naes_round128 : RoundKey -> State -> State\naes_round128 = AES::aes_round`{0}\n\naes_final_round128 : RoundKey -> State -> State\naes_final_round128 = AES::aes_final_round`{0}\n\nencryptState128 : KeySchedule -> State -> State\nencryptState128 = AES::encryptState`{0}\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/intrinsics.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the intrinsic functions defined in the Intrinsics module, such as _mm_setr_epi32, _mm_loadu_si128, _mm_clmulepi64_si128, and the polyval_Htable function. Include properties that prove equivalence between these implementations and their corresponding AES_GCM_SIV module functions, ensuring that the polynomial multiplication and table initialization behave as expected."},{"role":"assistant","content":"```cryptol\nmodule Intrinsics where\n\nimport `Common::AES_GCM_SIV as AES_GCM_SIV\n\n_mm_setr_epi32 : [32] -> [32] -> [32] -> [32] -> [128]\n_mm_setr_epi32 a b c d = join [a, b, c, d]\n\n_mm_loadu_si128 : [128] -> [4][32]\n_mm_loadu_si128 v = split v\n\nselect_from_128 : [128] -> Bit -> [128]\nselect_from_128 n b = res\n  where\n    [l,r] = split n\n    res = (if b then l else r) # zero\n\n\n_mm_clmulepi64_si128 : [128] -> [128] -> [2] -> [128 ]\n_mm_clmulepi64_si128 a b s = AES_GCM_SIV::mult`{0}`{0} l r\n  where\n  l = select_from_128 a (s @ 0)\n  r = select_from_128 b (s @ 1)\n\n_mm_xor_si128 : [128] -> [128] -> [128]\n_mm_xor_si128 a b = a ^ b\n\n\/\/this is a word rotation\n_mm_shuffle_epi32_78 : [4][32] -> [4][32]\n_mm_shuffle_epi32_78 l = l >>> 2\n\n\/\/flatten and concat a and b, shifting them right by ralign bytes\n_mm_alignr_epi8 : [16][8] -> [16][8] -> [8] -> [128]\n_mm_alignr_epi8 a b ralign = take ((join (a # b)) >> (ralign * 8))\n\nINIT_Htable : {n} (fin n, n>=2) => [128] -> [n][128]\nINIT_Htable H = hs\n  where\n  hs = [H] # [ AES_GCM_SIV::dot`{0}`{0} hn H\n                | hn <- hs\n                | (j : [width n]) <- [0..n-2]]\n\npolyval_Htable : {n} (fin n, n>=2) => [128] -> [n][128] -> [128]\npolyval_Htable H X = sums ! 0\n  where\n    htable = INIT_Htable`{n} H\n    sums = [zero] # [ (AES_GCM_SIV::dot`{0}`{0} (X@i) (htable!i)) ^ sum\n                    | sum <- sums\n                    | (i : [width n]) <- [0..n-1] ]\n\nproperty polyval_equiv H (xs : [4][128]) =\n  AES_GCM_SIV::polyvalFrom`{0}`{0} H xs zero ==\n  polyval_Htable H xs\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/AES256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally specify and verify the correctness of the AES-256 encryption functions defined in the AES256 module. Include properties that check the behavior of sub_bytes256, shift_rows256, key expansion (expand_key256), aes_round256, aes_final_round256, and encryptState256 functions, ensuring they conform to the AES-256 standard transformations and encryption process."},{"role":"assistant","content":"```cryptol\nmodule AES256 where\n\nimport `Common::AES\nimport `Common::AES as AES\nimport AES as AES\n\ntype State         = AES::State 2\ntype KeySchedule   = AES::KeySchedule 2\ntype RoundKey      = AES::RoundKey 2\n\nsub_bytes256 : State -> State\nsub_bytes256 = SubBytes`{2}\n\nshift_rows256 : State -> State\nshift_rows256 = ShiftRows`{2}\n\nexpand_key256 : [256] -> KeySchedule\nexpand_key256 = AES::expandKey\n\naes_round256 : RoundKey -> State -> State\naes_round256 = AES::aes_round`{2}\n\naes_final_round256 : RoundKey -> State -> State\naes_final_round256 = AES::aes_final_round`{2}\n\nencryptState256 : KeySchedule -> State -> State\nencryptState256 = AES::encryptState`{2}\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/TBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the AES finite field operations defined in TBox.cry, including gf28Add, gf28Mult, gf28Inverse, and the sbox and sbox_inverse arrays. Ensure that gf28Inverse correctly computes multiplicative inverses in GF(2^8), that gf28Mult respects field multiplication modulo the irreducible polynomial, and that sbox and sbox_inverse are inverses of each other. Include properties to check that msgToState and stateToMsg are inverses for all 128-bit inputs."},{"role":"assistant","content":"```cryptol\ntype Nb         = 4\ntype State      = [4][Nb]GF28\ntype RoundKey   = State\n\n\/** Convert a block into the internal state of AES *\/\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\n\/** Convert an AES internal state back to a block. *\/\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\n\n\n\n\n\ntype GF28        = [8]\n\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\ngf28Mult : GF28 -> GF28 -> GF28\ngf28Mult x y  = pmod (pmult x y) irreducible\n\ngf28Pow : GF28 -> [8] -> GF28\ngf28Pow n k = pow k\n  where   sq x  = gf28Mult x x\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult n (sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow x 254\n\ngf28DotProduct : {n} (fin n) => [n]GF28 -> [n]GF28 -> GF28\ngf28DotProduct xs ys = gf28Add [ gf28Mult x y | x <- xs | y <- ys ]\n\ngf28VectorMult : {n, m} (fin n) => [n]GF28 -> [m][n]GF28 -> [m]GF28\ngf28VectorMult v ms = [ gf28DotProduct v m | m <- ms ]\n\ngf28MatrixMult : {n, m, k} (fin m) => [n][m]GF28 -> [m][k]GF28 -> [n][k]GF28\ngf28MatrixMult xss yss = [ gf28VectorMult xs yss' | xs <- xss ]\n   where yss' = transpose yss\n\n\n\nsbox : [256]GF28\nsbox = [\n 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n 0x54, 0xbb, 0x16]\n\n\nsbox_inverse : [256] GF28\nsbox_inverse = [\n    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,\n    0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,\n    0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,\n    0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,\n    0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,\n    0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,\n    0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,\n    0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,\n    0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,\n    0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,\n    0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,\n    0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,\n    0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,\n    0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,\n    0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,\n    0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,\n    0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D]\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/Common\/AES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the AES encryption implementation in the provided module. Include properties that check the correctness of the key expansion, the AES rounds (SubBytes, ShiftRows, MixColumns, AddRoundKey), and the overall aesEncrypt function against known AES test vectors or algebraic properties. Ensure the properties cover the transformations and their inverses where applicable, and verify that the encryption output matches the expected ciphertext for given plaintext and key inputs."},{"role":"assistant","content":"```cryptol\n\/\/ This is a fairly close implementation of the FIPS-197 standard:\n\/\/   http:\/\/csrc.nist.gov\/publications\/fips\/fips197\/fips-197.pdf\n\nmodule Common::AES where\n\nparameter\n  type Mode : #\n  type constraint (2 >= Mode)\n\n\ntype AESKeySize  = 32 * Nk\n\n\/\/ AES Encryption\naesEncrypt : [AESKeySize] -> [128] -> [128]\naesEncrypt key pt = aesEncryptWithSchedule (ExpandKey key) pt\n\n\naes_round : RoundKey -> State -> State\naes_round k s =\n  k ^ transpose\n        [ t 0 ^ t 1 ^ t 2 ^ t 3 where t n = tbox n (s @ n @ (j + n))\n        | j <- [ 0 .. 3 ]\n        ]\n\ntbox : [2] -> GF28 -> [4]GF28\ntbox n x = (T0_table @ x) >>> n\n\nT0_table : [256][4] GF28\nT0_table = [ [gf28Mult (2, s), s, s, gf28Mult (3, s) ] | s <- sbox ]\n\naes_final_round : RoundKey -> State -> State\naes_final_round k s = AESFinalRound (k,s)\n\nencryptState : KeySchedule -> State -> State\nencryptState (kInit, ks, kFinal) pt = aes_final_round kFinal (rounds ! 0)\n  where\n  state0 = AddRoundKey (kInit, pt)\n  rounds = [state0] # [ aes_round rk s | rk <- ks | s <- rounds ]\n\n\n\/** AES Encryption with an expanded key.\nThis is useful if many things will be encrypted with the same key. *\/\naesEncryptWithSchedule : KeySchedule -> [128] -> [128]\naesEncryptWithSchedule ks pt = stateToMsg (encryptState ks (msgToState pt))\n\n\/\/ Number of blocks and Number of rounds\ntype Nk = 4 + 2 * Mode\ntype Nb = 4\ntype Nr = 6 + Nk\n\n\/\/ Helper type definitions\ntype GF28        = [8]\ntype State       = [4][Nb]GF28\ntype RoundKey    = State\ntype KeySchedule = (RoundKey, [Nr-1]RoundKey, RoundKey)\n\n\/\/ GF28 operations\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Mult : (GF28, GF28) -> GF28\ngf28Mult (x, y) = pmod(pmult x y) irreducible\n\ngf28Pow : (GF28, [8]) -> GF28\ngf28Pow (n, k) = pow k\n  where   sq x  = gf28Mult (x, x)\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult(n, sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow (x, 254)\n\ngf28DotProduct : {n} (fin n) => ([n]GF28, [n]GF28) -> GF28\ngf28DotProduct (xs, ys) = gf28Add [ gf28Mult (x, y) | x <- xs\n                                                    | y <- ys ]\ngf28VectorMult : {n, m} (fin n) => ([n]GF28, [m][n]GF28) -> [m]GF28\ngf28VectorMult (v, ms) = [ gf28DotProduct(v, m) | m <- ms ]\n\ngf28MatrixMult : {n, m, k} (fin m) => ([n][m]GF28, [m][k]GF28) -> [n][k]GF28\ngf28MatrixMult (xss, yss) = [ gf28VectorMult(xs, yss') | xs <- xss ]\n   where yss' = transpose yss\n\n\/\/ The affine transform and its inverse\nxformByte : GF28 -> GF28\nxformByte b = gf28Add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n   where c = 0x63\n\nxformByte' : GF28 -> GF28\nxformByte' b = gf28Add [(b >>> 2), (b >>> 5), (b >>> 7), d] where d = 0x05\n\/\/ The SubBytes transform and its inverse\nSubByte : GF28 -> GF28\nSubByte b = xformByte (gf28Inverse b)\n\nSubByte' : GF28 -> GF28\nSubByte' b = sbox@b\n\nSubBytes : State -> State\nSubBytes state = [ [ SubByte' b | b <- row ] | row <- state ]\n\n\/\/ The ShiftRows transform and its inverse\nShiftRows : State -> State\nShiftRows state = [ row <<< shiftAmount | row <- state\n                                        | shiftAmount : [2] <- [0 .. 3]\n                  ]\n\n\/\/ The MixColumns transform and its inverse\nMixColumns : State -> State\nMixColumns state = gf28MatrixMult (m, state)\n    where m = [[2, 3, 1, 1],\n               [1, 2, 3, 1],\n               [1, 1, 2, 3],\n               [3, 1, 1, 2]]\n\n\/\/ The AddRoundKey transform\nAddRoundKey : (RoundKey, State) -> State\nAddRoundKey (rk, s) = rk ^ s\n\n\/\/ Key expansion\nRcon : [8] -> [4]GF28\nRcon i = [(gf28Pow (<| x |>, i-1)), 0, 0, 0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord bs = [ SubByte' b | b <- bs ]\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nNextWord : ([8],[4][8],[4][8]) -> [4][8]\nNextWord(i, prev, old) = old ^ mask\n   where mask = if i % nk == 0\n                then SubWord(RotWord(prev)) ^ Rcon (i \/ `Nk)\n                else if (nk > 6) && (i % nk == 4)\n                     then SubWord(prev)\n                     else prev\n\n         nk = `Nk : [8]\n\nExpandKeyForever : [Nk][4][8] -> [inf]RoundKey\nExpandKeyForever seed = [ transpose g | g <- groupBy`{4} (keyWS seed) ]\n\nkeyWS : [Nk][4][8] -> [inf][4][8]\nkeyWS seed    = xs\n     where xs = seed # [ NextWord(i, prev, old)\n                       | i    <- [ `Nk ... ]\n                       | prev <- drop`{Nk-1} xs\n                       | old  <- xs\n                       ]\n\nExpandKey : [AESKeySize] -> KeySchedule\nExpandKey key = ( keys @ 0\n                , keys @@ ([1 .. (Nr - 1)] : [_][8])\n                , keys @ (`Nr : [8])\n                )\n  where   seed : [Nk][4][8]\n          seed = split (split key)\n          keys = ExpandKeyForever seed\n\nfromKS : KeySchedule -> [Nr+1][4][32]\nfromKS (f, ms, l) = [ formKeyWords (transpose k) | k <- [f] # ms # [l] ]\n    where formKeyWords bbs = [ join bs | bs <- bbs ]\n\n\/\/ AES rounds and inverses\nAESRound : (RoundKey, State) -> State\nAESRound (rk, s) = AddRoundKey (rk, MixColumns (ShiftRows (SubBytes s)))\n\nAESFinalRound : (RoundKey, State) -> State\nAESFinalRound (rk, s) = AddRoundKey (rk, ShiftRows (SubBytes s))\n\n\/\/ Converting a 128 bit message to a State and back\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\nsbox : [256]GF28\nsbox = [\n 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n 0x54, 0xbb, 0x16]\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/cryptol\/Asm128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that specify and verify the correctness of the Polyval and AES-GCM-SIV encryption functions defined in the Asm128.cry module. Include properties that check the polynomial evaluation consistency (e.g., polyProp), the correctness of AES key expansion and encryption functions (e.g., AES_128_ENC_x4_def, AES_KS_ENC_x1_def1, AES_KS_ENC_x1_def2), and the correctness of the combined AES-GCM-SIV encryption pair function (AES_GMC_SIV_Encrypt_pair) ensuring the tag and ciphertext outputs conform to the expected cryptographic behavior."},{"role":"assistant","content":"```cryptol\nmodule GenAsm128 where\n\nimport X86\nimport AES128\nimport AES128_GCM_SIV\nimport Sizes\n\ndot256 : [256] -> [256] -> [256]\ndot256 (_ # res) (_ # h) = 0 # dot res h\n\ndot512 : [512] -> [512] -> [512]\ndot512 (_ # res) (_ # h) = 0 # dot res h\n\nPolyval_Horner_gen_def :\n  {n} fin n => [1][128] -> [n][8] -> [1][128] -> [1][128]\nPolyval_Horner_gen_def [h] i [t] = [ polyvalFrom h (leLoadBlocks i) t ]\n\nPolyval_Horner_AAD_def : [1][128] -> [AAD_Size][8] -> [1][128] -> [1][128]\nPolyval_Horner_AAD_def = Polyval_Horner_gen_def\n\nPolyval_Horner_MSG_def : [1][128] -> [MSG_Size][8] -> [1][128] -> [1][128]\nPolyval_Horner_MSG_def = Polyval_Horner_gen_def\n\nPolyval_Horner_BLK_def : [1][128] -> [16][8] -> [1][128] -> [1][128]\nPolyval_Horner_BLK_def = Polyval_Horner_gen_def\n\nPolyval_Horner_AAD_MSG_def :\n  [16][8] -> [AAD_Size][8] -> [MSG_Size][8] -> [2][64] -> [16][8] -> [1][128]\nPolyval_Horner_AAD_MSG_def h aad pt lblk t =\n  [ polyvalFrom (leLoad h) work (leLoad t) ]\n  where\n  work = leLoadBlocks aad\n       # leLoadBlocks pt\n       # leLoadBlocks [ b | qword <- lblk, b <- leStore qword ]\n\nINIT_Htable_def: [1][128] -> [8][128]\nINIT_Htable_def [h] = INIT_Htable h\n\nPolyval_HTable_gen_def :\n  {n} (fin n) => [8][128] -> [n][8] -> [1][128] -> [1][128]\nPolyval_HTable_gen_def tbl data [t] =\n  [ polyvalHtableNH tbl (leLoadBlocks data) t ]\n\nPolyval_HTable_AAD_def : [8][128] -> [AAD_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_AAD_def = Polyval_HTable_gen_def\n\nPolyval_HTable_MSG_def : [8][128] -> [MSG_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_MSG_def = Polyval_HTable_gen_def\n\nPolyval_HTable_BLK_def : [8][128] -> [16][8] -> [1][128] -> [1][128]\nPolyval_HTable_BLK_def = Polyval_HTable_gen_def\n\n\nPolyval_HTable_call_AAD_def : [8][128] -> [AAD_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_call_AAD_def hs = Polyval_Horner_AAD_def (take hs)\n\nPolyval_HTable_call_MSG_def : [8][128] -> [MSG_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_call_MSG_def hs = Polyval_Horner_MSG_def (take hs)\n\nPolyval_HTable_call_BLK_def : [8][128] -> [16][8] -> [1][128] -> [1][128]\nPolyval_HTable_call_BLK_def hs = Polyval_Horner_BLK_def (take hs)\n\npolyProp :\n  {x,y} (fin x, fin y) => [128] -> [x][128] -> [y][128] -> [128] -> Bool\npolyProp h xs ys t =\n  polyvalFrom h ys (polyvalFrom h xs t) == polyvalFrom h (xs # ys) t\n\n\n\/\/ See `derive_key` in the spec.\nAES_128_ENC_x4_def : [16][8] -> [11][128] -> [4][128]\nAES_128_ENC_x4_def iv' keys = [ aesWithKeys keys (iv # i) | i <- [ 0 .. 3 ] ]\n  where\n  _ # (iv : [96]) = leLoad iv'\n\n\n\/* Encrypt the pt with the given key, expanding it as you go.\nThe result it the encrypted text and the expanded key *\/\nAES_KS_ENC_x1_def1 : [16][8]  -> [11][128]\nAES_KS_ENC_x1_def1 ikey =\n  aesKeyToBits (ExpandKey (beLoad ikey))\n  \/\/ NOTE the BIG ENDIAN load on the key\n\nAES_KS_ENC_x1_def2 : [11][128] -> [16][8] -> [1][128]\nAES_KS_ENC_x1_def2 keys pt = [ aesWithKeys keys (leLoad pt) ]\n\nENC_MSG_def :\n  [11][128] -> [16][8] -> [MSG_Size][8] -> [MSG_Size][8]\nENC_MSG_def keys tag pt =\n  leStoreBlocks (counter_mode K2 (0b1 # tUpper, tLower) M)\n  where\n  K2 = aesKeysFromBits keys\n  M  = leLoadBlocks pt\n  _ # tUpper # tLower = leLoad tag\n\n\n\/\/ NOTE the BIG ENDIAN loads on the AAD and the Message\nAES_GMC_SIV_Encrypt_pair :\n  [11][128] -> [12][8] -> [AAD_Size][8] -> [MSG_Size][8] ->\n                                                    ([8 * MSG_Size], [128])\nAES_GMC_SIV_Encrypt_pair keys iv aad pt =\n  gcm_siv_plus ks nonce (beLoad aad) (beLoad pt)\n  where\n  ks    = derive_key_expanded (aesKeysFromBits keys) nonce\n  nonce = leLoad iv\n\nAES_GMC_SIV_Encrypt_TAG_def :\n  [11][128] -> [12][8] -> [AAD_Size][8] -> [MSG_Size][8] -> [1][128]\nAES_GMC_SIV_Encrypt_TAG_def keys iv add pt = [ tag ]\n  where (_,tag) = AES_GMC_SIV_Encrypt_pair keys iv add pt\n\nAES_GMC_SIV_Encrypt_CT_def :\n  [11][128] -> [12][8] -> [AAD_Size][8] -> [MSG_Size][8] -> [MSG_Size][8]\nAES_GMC_SIV_Encrypt_CT_def keys iv add pt = beStore ct\n  where (ct,_) = AES_GMC_SIV_Encrypt_pair keys iv add pt\n\n\n\n\n\naesWithKeys : [11][128] -> [128] -> [128]\naesWithKeys ks pt = aes (aesKeysFromBits ks) pt\n\naesKeysFromBits : [11][128] -> KeySchedule\naesKeysFromBits ks = (k1,kRest,kLast)\n  where [k1] # kRest # [kLast] = [ aesStateFromBits m | m <- ks ]\n\naesKeyToBits : KeySchedule -> [11][128]\naesKeyToBits (k1,kRest,kLast) =\n  [ aesStateToBits k1 ] #\n  [ aesStateToBits x | x <- kRest ] #\n  [ aesStateToBits kLast ]\n\nleLoadBlocks : {n} (fin n) => [n][8] -> [n \/^ 16][128]\nleLoadBlocks bytes = leLoadArray (bytes # zero)\n\nleStoreBlocks : {n} (fin n) => [n \/^ 16][128] -> [n][8]\nleStoreBlocks arr = take (leStoreArray arr)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/cryptol\/AES128_GCM_SIV.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to formally verify the correctness of the AES-GCM-SIV implementation in AES128_GCM_SIV.cry. Specifically, specify properties that check the equivalence between the high-level aes_gcm_siv function and the underlying primitives such as derive_key, gcm_siv_plus, and polyvalFrom, ensuring that the byte-swapping operations preserve correctness and that the counter_mode encryption matches the expected AES counter mode behavior. Include properties to validate the polynomial multiplication and reduction functions (mult, dot) and the correctness of the polyvalHtableNH optimizations against the baseline polyvalFrom implementation."},{"role":"assistant","content":"```cryptol\n\/* This module implements that AES-GCM-SIV mode of operations\nas desribed in:\n\n\"AES-GCM-SIV: Specification and Analysis\"\nby Shay Gueron, Adam Langley, and Yehuda Lindell\n\nSee also:\nhttps:\/\/tools.ietf.org\/html\/draft-irtf-cfrg-gcmsiv-06\n*\/\n\nmodule AES128_GCM_SIV where\n\nimport AES128 as AES\nimport Sizes\n\ntype AAD  = 8 * AAD_Size\n\ntype K  = 128\ntype KS = AES::KeySchedule\n\n\n\/** Note the weird byte-swapping business (also in `blockify` and `unblockify`)\nIt is not quite clear in what format we want the inputs\/outputs, but we\ndo the swapping so that inputs\/ouputs match the test vectors at\nhttps:\/\/tools.ietf.org\/html\/draft-irtf-cfrg-gcmsiv-06\n*\/\naes_gcm_siv :\n  {n} ((36 + 8) >= width n) =>\n      { key   : [K]\n      , nonce : [96]\n      , aad   : [AAD]\n      , msg   : [n]\n      } -> [n + 128]\naes_gcm_siv input = c # byteSwap t\n  where\n  (c,t) = gcm_siv_plus (derive_key k' n') n' input.aad input.msg\n  k'    = byteSwap input.key\n  n'    = byteSwap input.nonce\n\naes : KS -> [128] -> [128]\naes ks v = byteSwap (AES::aesEncryptWithSchedule ks (byteSwap v))\n\nexpandKey1 : [K] -> KS\nexpandKey1 k = AES::ExpandKey (byteSwap k)\n\n\/** See Figure 2 in Section 4 *\/\nderive_key : [K] -> [96] -> ([128], KS)\nderive_key K N = derive_key_expanded (expandKey1 1) N\n\n\/** See Figure 2 in Section 4 *\/\nderive_key_expanded : KS -> [96] -> ([128], KS)\nderive_key_expanded ks N = (mkKey parts1, expandKey1 (mkKey parts2))\n  where\n  parts1 # parts2 = [ drop (aes ks (N # i)) | i <- take [ 0 ... ]  ]\n\n  mkKey : {n} (fin n) => [n][64] -> [64 * n]\n  mkKey xs = join (reverse xs)\n\n\n\n\n\/** See Figure 1 in Section 3 *\/\ngcm_siv_plus :\n  {n} (64 >= width n) => ([128], KS) -> [96] -> [AAD] -> [n] -> ([n],[128])\ngcm_siv_plus (K1,K2) N AAD MSG = (unblockify Cs,TAG)\n  where\n\n  TAG     = aes K2 (0b0 # drop (T ^ (0 # N)))\n  T       = polyvalFrom K1 (A # M # [msg_len # aad_len]) 0\n  A       = blockify AAD\n  M       = blockify MSG\n  aad_len = `AAD : [64]\n  msg_len = `n   : [64]\n\n  _ # tUpper # tLower = TAG\n\n  Cs = counter_mode K2 (0b1 # tUpper, tLower) M\n\ncounter_mode : {n} KS -> ([96],[32]) -> [n][128] -> [n][128]\ncounter_mode K2 (tUpper,tLower) M =\n            [ aes K2 (tUpper # lower32 i) ^ m | m <- M | i <- [ 0 ... ] ]\n  where\n  lower32 i = tLower + i\n\n\n\/** See Section 2.2 *\/\npolyvalFrom : {n} (fin n) => [128] -> [n][128] -> [128] -> [128]\npolyvalFrom H Xs start = psums ! 0\n  where psums = [start] # [ dot (s ^ x) H | s <- psums | x <- Xs ]\n\n\/\/1 is not the identity for dot forcing it in next function instead\npolyvalFromNH : {n, hs} (fin n, fin hs, hs >=n) => [hs][128] -> [n][128] -> [128] -> [128]\npolyvalFromNH Hs Xs start = (sums ! 0) ^ (dot (([1] # Hs) @ (`n : [width n])) start)\n  where sums = [zero] # [ (dot X H) ^ sum'\n                        | sum' <- sums\n                        | X <- reverse Xs\n                        | H <- Hs ]\n\n\npolyvalHtableNH :\n  {n, hs} (fin n, fin hs, hs >=1) => [hs][128] -> [n][128] -> [128] -> [128]\npolyvalHtableNH Hs Xs start  = result\n  where sums = [start]\n             # [ polyvalFromNH Hs Xchunk sum'\n               | sum'   <- sums\n               | Xchunk <- split (take Xs): [n\/hs][hs][128]\n               ]\n        type W = n % hs\n        remainder = drop Xs : [W][128]\n        result =\n          if `W == (0 : [width (n % hs)]) then\n            sums ! 0\n          else\n            polyvalFromNH Hs remainder (sums!0)\n\n\npht : {a,size} (fin a,fin size,size>=2) => [128] -> [a][128] -> [128] -> Bit\npht H Xs start =\n  polyvalHtableNH (INIT_Htable`{size} H) Xs start == polyvalFrom H Xs start\n\ndot : [128] -> [128] -> [128]\ndot x y = mult x (mult y x_neg_128)\n  where x_neg_128 = <| 1 + x^^114 + x^^121 + x^^124 + x^^127 |>\n        \/\/ This is x^(-128)\n\n\nmult : [128] -> [128] -> [128]\nmult x y = pmod (pmult x y) irred\n  where\n  irred = <| 1 + x^^121 + x^^126 + x^^127 + x^^128 |>\n\nINIT_Htable : {n} (fin n, n>=2) => [128] -> [n][128]\nINIT_Htable H = take hs\n  where\n  hs = [H] # [ dot hn H\n                | hn <- hs]\n\n\/*polyval_Htable : {n} (fin n, n>=1) => [128] -> [n][128] -> [128]\npolyval_Htable H X = polyvalHtableNH`{hs=8} htable X\n  where\n    htable = INIT_Htable H\n\n\n\/\/ -----------------------------------------------------------------------------\n\nprop_poly : {a} (a >= 1, fin a) => [128] -> [a][128] -> Bit\nprop_poly H X = polyval_Htable H X == polyvalFrom H X zero\n*\/\nblockify : {n} (fin n) => [n] -> [n \/^ 128][128]\nblockify x = [ byteSwap b | b <- split (x # zero) ]\n\nunblockify : {n} (fin n) => [n \/^ 128][128] -> [n]\nunblockify xs = take (join [ byteSwap b | b <- xs ])\n\n\/\/ The spec uses byte-oriented little-endian representations.\n\/\/ This function changes back and forth.\nbyteSwap : {n} (fin n) => [8 * n] -> [8 * n]\nbyteSwap xs = join (reverse (split`{each=8} xs))\n\npolnhest1 = polyvalHtableNH`{hs=8,n=1}\n              ([0x551d5202e5be771d5964fbbd1dac89db]#zero)\n              \/\/(INIT_Htable 0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e)\n              [0x189308235800d2810a80a422032144fd]\n              (0x38020aa08800d28bf2fb37d447e1c479)\n\npolnhest2 = polyvalFrom\n                0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e\n                [0x189308235800d2810a80a422032144fd]\n                (0x38020aa08800d28bf2fb37d447e1c479)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/cryptol\/X86.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the conversion functions between bit vectors and AES state representations in the X86 module. Specifically, specify and prove that aesStateFromBits and aesStateToBits are inverses, and that leLoad and leStore correctly convert between bit vectors and byte arrays. Also, write properties to verify that clmul correctly implements carryless multiplication on 64-bit inputs producing 128-bit outputs."},{"role":"assistant","content":"```cryptol\nmodule X86 where\n\nimport AES128\n\naesenc : [128] -> [128] -> [128]\naesenc pt key =\n  aesStateToBits (aes_round (aesStateFromBits key)\n                            (aesStateFromBits pt))\n\naesenclast : [128] -> [128] -> [128]\naesenclast pt key =\n  aesStateToBits (aes_final_round (aesStateFromBits key)\n                                  (aesStateFromBits pt))\n\n\n\/\/ Carryles mulitplication\nclmul : [64] -> [64] -> [128]\nclmul x y = 0b0 # pmult x y\n\n\n\/\/ Store a bit-value as bytes\nleStore : {n} (fin n) => [n * 8] -> [n][8]\nleStore bits = reverse (split bits)\n\n\/\/ Load a bit-value from bytes\nleLoad : {n} (fin n) => [n][8] -> [n*8]\nleLoad bytes = join (reverse bytes)\n\nbeLoad : {n} (fin n) => [n][8] -> [n*8]\nbeLoad bytes = join bytes\n\nbeStore : {n} (fin n) => [n*8] -> [n][8]\nbeStore bits = split bits\n\n\/\/ Load an array from bytes\nleLoadArray : {l,w} (fin l,fin w) => [l * w][8] -> [l][w * 8]\nleLoadArray bytes = [ leLoad mem | mem <- split bytes ]\n\nleStoreArray : {l,w} (fin l,fin w) => [l][w * 8] -> [l * w][8]\nleStoreArray arr = join [ leStore a | a <- arr ]\n\naesStateFromBytes : [16][8] -> State\naesStateFromBytes xs = transpose (split xs)\n\naesStateToBytes : State -> [16][8]\naesStateToBytes s = join (transpose s)\n\naesStateFromBits : [128] -> State\naesStateFromBits xs = aesStateFromBytes (leStore xs)\n\naesStateToBits : State -> [128]\naesStateToBits s = leLoad (aesStateToBytes s)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/intTests\/test_profiling\/dotprod.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the correctness of the 'dotprod' function defined in the given code. The properties should check that 'dotprod' correctly computes the dot product of two vectors by summing the element-wise products, and should include tests for edge cases such as zero-length vectors and vectors with zero elements."},{"role":"assistant","content":"```cryptol\nzip : {n, a} (fin n, Arith a) => (a -> a -> a) -> [n]a -> [n]a -> [n]a\nzip f xs ys = [ f x y | x <- xs | y <- ys ]\n\nsum : {n, a} (fin n, fin a) => [n][a] -> [a]\nsum xs = ys!0\n  where ys = [0] # [ x + y | x <- xs | y <- ys ]\n\ndotprod : {n, a} (fin n, fin a) => [n][a] -> [n][a] -> [a]\ndotprod xs ys = sum (zip (*) xs ys)\n```"}]}
