{"filename":"cryptol\/examples\/splitAt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the following with explicit types and a verification: (1) a constant x as a 4-element sequence of 8-bit values containing 1, 2, 3, and 4 in order; (2) a constant y as the pair produced by splitting x at index 2 into two sequences, each of length 2 and element width 8; (3) constants a, b, c, and d as 8-bit values equal to the first and second elements of the first component of y, and the first and second elements of the second component of y, respectively (use zero-based indexing). Provide type signatures for x, y, a, b, c, and d that reflect these sizes. Also define a property that checks both that concatenating the two parts of y reconstructs x, and that a == 1, b == 2, c == 3, and d == 4. Do not include any implementations beyond these definitions and the property."},{"role":"assistant","content":"```cryptol\nx = [1,2,3,4] : [_][8]\n\ny = (splitAt x) : ([2][8],[2][8])\n\na = y.0 @ 0\nb = y.0 @ 1\nc = y.1 @ 0\nd = y.1 @ 1\n```"}]}
{"filename":"cryptol\/examples\/AE.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named AE that contains the following definitions and specifications: (1) A parameter section declaring abstract value types A and K, numeric types n, p, and tagAmount, with constraints that p and n are finite and n is at least tagAmount. Also declare the following module parameters with the given roles and shapes: a tweakable permutation over n-bit blocks keyed by K that consumes a record containing a nonce, an abstract state, and a 64-bit counter; a 64-bit cost increment; a block encryption transform that maps a record of one p\u00b7n-bit block and the running p\u00b7n-bit state to the next record of the same shape; a corresponding decryption transform; and a tag function that maps a key, a tweak record, and a p\u00b7n\u00b7p-length message stream to an n-bit tag. (2) Type synonyms: Node as a record of a work block and running state, WorkBlock as p\u00b7n bits, State as p\u00b7n bits, Tweak as a record of nonce [n], state A, and counter [64], Nonce as [n], and Int as [64]. (3) A function encrypt with type: for any finite m, takes a key, a nonce, an initial abstract state A, and a message of m blocks of size p\u00b7n, and returns m\u00b7(p\u00b7n) bits followed by tagAmount bits. Specify that it: splits the message into m blocks; iteratively applies the encryption transform to each block using a tweak whose counter is the running cost (starting at 1 and increased by the cost increment per block) and threading the p\u00b7n-bit state; concatenates the resulting per-block ciphertexts; derives the authentication tag by applying the tag function to the key, a tweak whose counter is one less than the final accumulated cost, and the final p\u00b7n-bit state; and returns ciphertext concatenated with the tag truncated to tagAmount bits. (4) Properties to check: output length matches the result type size; the ciphertext prefix equals the concatenation of per-block encryption results; the tag suffix equals the specified tag derivation."},{"role":"assistant","content":"```cryptol\nmodule AE where\n\nparameter\n  type A : *            type K : *            type n : #            type p : #            type tagAmount : #\n\n  type constraint (fin p, fin n, n >= tagAmount)\n\n    tweak_cipher : K -> { nonce : [n], state : A, z : [64] } -> [n] -> [n]\n\n    Cost : [64]\n\n  Enc : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Dec : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Tag : K -> { nonce : [n], state : A, z : [64] } -> [p*n] -> [n]\n\ntype Node       = { message : WorkBlock, state : State }\n\ntype WorkBlock  = [p*n]\n\ntype State      = [p*n]  \ntype Tweak      = { nonce : Nonce, state : A, z : Int }\ntype Nonce      = [n]\n\ntype Int = [64]\n\nencrypt :\n  {m} fin m => K -> Nonce -> A -> [m * (p * n)] -> [m * (p * n) + tagAmount]\nencrypt key nonce state inputMsg = encMsg # tag\n\n  where\n  encMsg = join rest.0.message\n\n  tag = take (Tag key (tweak (1 - final.1)) final.0.state)\n\n  final = steps ! 0\n\n  steps = [ ({ message = undefined, state = zero }, 1) ] # rest\n  rest  = [ (Enc key (tweak v) { message = m, state = prev.state }, v + Cost)\n          | (prev,v) <- steps\n          | m        <- chunks\n          ]\n\n  chunks : [m] [p * n]\n  chunks = split inputMsg\n\n  tweak : Int -> Tweak\n  tweak v = { nonce = nonce, state = state, z = v }\n```"}]}
{"filename":"cryptol\/examples\/xor_cipher.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define type signatures for encrypt and decrypt parameterized by a finite size a: each takes an 8-bit key and a sequence of a 8-bit values, returning a sequence of a 8-bit values. Implement encrypt by XORing each input byte with the key elementwise, and implement decrypt identically (bytewise XOR with the same key). Define a property named roundtrip that, for all finite a, any 8-bit key, and any sequence of a 8-bit values, asserts that applying decrypt with the key to the result of encrypt with the same key yields the original input. State the fin a constraint explicitly, keep all expressions total, and use elementwise operations over the sequence without introducing padding or state."},{"role":"assistant","content":"```cryptol\nencrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\nencrypt key plaintext = [pt ^ key | pt <- plaintext ]\n\ndecrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\ndecrypt key ciphertext = [ct ^ key | ct <- ciphertext ]\n\nproperty roundtrip k ip = decrypt k (encrypt k ip) == ip\n```"}]}
{"filename":"cryptol\/examples\/zero_weird.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) a polymorphic function named x with a single type parameter and no constraints, taking one argument of that type and returning a 16-bit sequence whose value is all zeros; implement x so it ignores its input. (2) a property named xprop that universally quantifies over the input and asserts that applying x to any value yields the 16-bit zero value. (3) a function named y that takes two arguments, the first a 12-bit sequence and the second a 4-bit sequence, and returns a 17-bit sequence whose value is all zeros; implement y so it ignores both inputs. (4) a property named yprop that universally quantifies over both inputs and asserts that applying y to any valid pair yields the 17-bit zero value. (5) two constants named t1 and t2 that are example applications: t1 is x applied to a literal argument, producing the 16-bit zero result; t2 is y applied to two literal arguments, producing the 17-bit zero result. Include precise type signatures for x and y, and ensure the properties are written using the Cryptol property keyword so they can be checked by a solver."},{"role":"assistant","content":"```cryptol\nx : {a}() => a -> [16]\nx v = zero v \n\nproperty xprop v = x v == 0\n\ny : [12] -> [4] -> [17]\ny a b = zero a b\n\nproperty yprop v w = y v w == 0\n\nt1 = x 13\nt2 = y 2 3\n```"}]}
{"filename":"cryptol\/examples\/builtin_lifting.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that demonstrates built-in lifting across sequences, tuples, and records by defining the following and proving the listed properties. Define x and y as two-bit words whose most-significant bit patterns are 10 and 01, respectively. Provide properties: p1 asserts x equals the two-bit numeral 2; p2 asserts x+y equals the two-bit numeral 3; p3 asserts x+y equals the two-bit pattern with both bits set. Define xx and yy as singleton sequences containing x and y, respectively; p4 asserts their elementwise sum is the singleton containing 3; p5 asserts the bitwise complement of xx equals yy. Define infinite arithmetic sequences xinf and yinf of two-bit words starting at 2 and 3, respectively; p6 asserts the first element of their pointwise sum equals the two-bit numeral 1; p7 asserts the first element of the bitwise complement of xinf equals the two-bit numeral 1. Define a record xrec with fields x and y, both two-bit words equal to 2, with an explicit record type; p8 asserts xrec added to itself three times equals xrec (fieldwise modular addition). Define a tuple whose first two components are the two-bit numeral 2 and whose third component is xrec; p9 asserts adding this tuple to itself three times yields the same tuple (componentwise lifting). Finally, p10 asserts that bitwise complement distributes over a record whose first field is a tuple of a 1-bit and a 2-bit word and whose second field is a three-element sequence of three-bit words, and that the complemented record matches the elementwise complements with explicit width annotations. Use property declarations for p1\u2013p10 and fully annotate widths and shapes to disambiguate types."},{"role":"assistant","content":"```cryptol\nx = [True,False]\ny = [False,True]\n\nproperty p1 = x == (2 : [2])\n\nproperty p2 = x + y == 3\nproperty p3 = x + y == [True,True]\n\nxx = [[True,False]]\nyy = [[False,True]]\n\nproperty p4 = xx + yy == [3]\n\nproperty p5 = ~ xx == yy\n\nxinf = [2 ... ]\nyinf = [3 ... ]\n\nproperty p6 = (xinf + yinf) @ (0 : [0]) == (1 : [2])\n\nproperty p7 = (~ xinf) @ (0 : [0]) == (1 : [2])\n\nxrec = { x = 2 : [2], y = 2 : [2] } : {x : [2], y : [2]}\n\nproperty p8 = xrec + xrec + xrec == xrec\n\nproperty p9 = (2,2,xrec) + (2,2,xrec) + (2,2,xrec) == (2:[2],2:[2],xrec) \n\nproperty p10 = (~ { x = (1,2), y = [3,4,5] }) == {x = (0:[1],1:[2]), y = [4, 3, 2] : [3][3] }\n```"}]}
{"filename":"cryptol\/examples\/inflist.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares four sequence constants and four properties. Define: (1) an infinite sequence a that repeats the value 1; (2) an infinite arithmetic sequence b determined by the first two elements 1 then 2 (unit step); (3) a finite inclusive range c from 1 to 5; and (4) a finite arithmetic range d that starts at 1, has next element 3, and ends at 9. Use appropriate numeric types for these sequences (0-based indexing is assumed). Then define properties t1, t2, t3, and t4 asserting, respectively, that the element at index 3 of a equals 1, the element at index 3 of b equals 1, the element at index 3 of c equals 4, and the element at index 3 of d equals 4. Ensure the properties are expressed as boolean equalities suitable for solver checking."},{"role":"assistant","content":"```cryptol\na = [1 ... ]\nb = [1,2 ... ]\nc = [1 .. 5]\nd = [1,3 .. 9]\n\nproperty t1 = a @ 3 == 1\nproperty t2 = b @ 3 == 1\nproperty t3 = c @ 3 == 4\nproperty t4 = d @ 3 == 4\n```"}]}
{"filename":"cryptol\/examples\/Karatsuba.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Karatsuba that contains the following definitions: kmult, make_atleast, splitmult, splitmult_correct_tiny, splitmult_correct_small, splitmult_correct_medium, splitmult_correct_large, and splitmult_correct_huge. Specify kmult as a polymorphic function over size parameters limb and n with constraints fin limb, fin n, limb >= 6, n >= 1; it takes two n-bit sequences and returns their 2n-bit product. It must use a conditional: when n is at least limb, first widen both operands to be at least limb bits by prefixing zeros and then call splitmult; otherwise, perform a direct multiplication on zero-extended operands. Specify make_atleast as a polymorphic helper over sizes n, m and element type a with constraints fin n, fin m, Zero a; it takes an m-length sequence and returns a max(n,m)-length sequence by prefixing zeros. Specify splitmult as Karatsuba multiplication over sizes limb and n with constraints fin limb, fin n, limb >= 6, n >= 6; split each operand at hi = n\/2 (low = n - hi), recursively compute products of high and low halves, compute the cross term via sum-of-halves multiplication minus the partial products, and recombine by appropriate zero-padding and concatenation to yield a 2n-bit result. Include property declarations asserting that, for operand widths 9, 11, 17, and 59 with limb 7, and width 511 with limb 63, the result of splitmult equals the product of the zero-extended operands. Provide precise type signatures with all size constraints and quantify variables as needed."},{"role":"assistant","content":"```cryptol\nmodule Karatsuba where\n\nkmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 1) => [n] -> [n] -> [2*n]\n\nkmult x y =\n if `n >= (`limb : [max (width limb) (width n)]) then\n   take (splitmult`{limb} (make_atleast`{limb} x) (make_atleast`{limb} y))\n else\n   (zero#x)*(zero#y)\n\nmake_atleast : {n, m, a} (fin n, fin m, Zero a) => [m]a -> [max n m]a\nmake_atleast x = zero#x\n\nsplitmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 6)\n         => [n] -> [n] -> [2*n]\n\nsplitmult x y = (ac # bd) + (zero # ad_bc # (zero:[low]))\n  where\n   type hi  = n\/2\n   type low = n - hi\n\n   (a,b) = splitAt`{hi} x\n   (c,d) = splitAt`{hi} y\n\n   ac : [2*hi]\n   ac = kmult`{limb,hi} a c\n\n   bd : [2*low]\n   bd = kmult`{limb,low} b d\n\n   a_b = (zext a) + (zext b)\n   c_d = (zext c) + (zext d)\n\n   ad_bc : [2*(low+1)]\n   ad_bc = (kmult`{limb,low+1} a_b c_d) - (zext ac) - (zext bd)\n\nproperty splitmult_correct_tiny (x:[9]) (y:[9]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_small (x:[11]) (y:[11]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_medium(x:[17]) (y:[17]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_large (x:[59]) (y:[59]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_huge (x:[511]) (y:[511]) =\n  zext x * zext y == splitmult`{limb=63} x y\n```"}]}
{"filename":"cryptol\/examples\/comp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) a constant x with an explicit type signature as a finite sequence of 4-tuples of fixed-width bitvectors, where each field\u2019s width is the minimal width sufficient for the values it ranges over; construct x using a parallel list comprehension where the left side enumerates all pairs from two finite ranges, the right side enumerates all pairs from two other finite ranges, the two sides are zipped elementwise (length equals the minimum of the two sides), and within each side the rightmost generator varies fastest; (2) properties t1, t2, and t3 that assert that the first, third, and fourth elements of x, respectively, equal the tuples produced by this construction at those positions; (3) a constant y built by a parallel comprehension where the left side enumerates all pairs from two finite ranges and the right side is an increasing arithmetic progression, with the zipped result truncated to the left side; ensure the third component of the tuples in y uses a small fixed width so its values wrap modulo its word size; and (4) property t4 that asserts that the fourth element of y matches the tuple produced at that position, including the wrapped third component. Provide any necessary type signatures and constraints, and ensure tuple fields are not implicitly widened."},{"role":"assistant","content":"```cryptol\nx : [_]([2],[3],[3],[4])\nx = [(a,b,c,d) | a <- [1,2], b <- [3,4] | c <- [5,6], d <- [7,8,9] ]\n\nproperty t1 = x @ 0 == (1,3,5,7)\nproperty t2 = x @ 2 == (2,3,5,9)\nproperty t3 = x @ 3 == (2,4,6,7)\n\ny = [(a,b,c) | a <- [1,2,3], b <- [1,2] | c <- [1 ... ] ]\n\nproperty t4 = y @ 3 == (2,2,0)\n```"}]}
{"filename":"cryptol\/examples\/mini.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that reproduces the following definitions and types: (1) a function named id with type 32-bit word to 32-bit word, implemented by a helper recursive function that returns zero when given zero and otherwise returns one plus its result on the predecessor, using modular 32-bit arithmetic; (2) an infinite increasing stream of 8-bit words starting at one; (3) a record named rc with two 8-bit fields x and y set to specific literals, and a constant that equals the x field; (4) a 4-tuple of four 8-bit literals and a constant that equals its third element; (5) a constant defined via a local binding to an 8-bit literal; (6) a polymorphic function named gf28Add with a size parameter n and a fin n constraint that takes a sequence of n 8-bit words and returns an 8-bit word computed as the head of a running XOR prefix-sum stream that begins with zero and is formed by zipping the input with the previously computed prefix values; also define a constant produced by applying this function to a two-element 8-bit sequence; (7) a function named sum with type from a sequence of 8-bit words to a sequence of 8-bit words that zips its input with the fixed sequence [1,2,3,4] and returns their elementwise 8-bit sums. Provide explicit type signatures for id, gf28Add (with its constraint), and sum, and ensure all literals and field\/tuple selections match these behaviors. Do not include proofs; just the definitions with correct typing and semantics."},{"role":"assistant","content":"```cryptol\nid : [32] -> [32]\nid x = rec x\n  where rec k = if (k == 0) then 0 else 1 + rec (k + (-1))\n\ninflist = [1 ... ] : [_][8]\n\nrc = {x = 3 : [8], y = 5 : [8]}\n\nmy_true = rc.x\n\ntup = (1 : [8], 2 : [8], 3 : [8], 4 : [8])\n\nmy_3 = tup.2\n\nsup = y where y = 3 : [8]\n\ngf28Add : {n} (fin n) => [n][8] -> [8]\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\ngex = gf28Add [1,2]\n\nsum : [_][8] -> [_][8]\nsum x = rec\n  where rec = [ p + q | p <- x | q <- [1,2,3,4] ]\n```"}]}
{"filename":"cryptol\/examples\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Test that imports Cipher and contains the following definitions: evktest, evttest, ekatest, dvktest, dvttest, dkatest. For each function, provide a type signature quantified over size variables ks, bs, n with the constraint that bs is finite. Each returns a sequence of length n of pairs (a bs-bit value and a Bit flag). The Bit flag indicates whether the computed result equals the provided expected value. Specify inputs and behavior precisely: (1) evktest takes a cipher instance, a length\u2011n sequence of (key: ks bits, expected ciphertext: bs bits) pairs, and a fixed plaintext (bs bits); for each pair, encrypt the fixed plaintext under the key and pair the produced ciphertext with its equality against the expected ciphertext. (2) evttest takes a cipher instance, a fixed key (ks bits), and a length\u2011n sequence of (plaintext: bs bits, expected ciphertext: bs bits) pairs; for each pair, encrypt the plaintext under the fixed key and compare to the expected ciphertext. (3) ekatest takes a cipher instance and a length\u2011n sequence of (key: ks bits, plaintext: bs bits, expected ciphertext: bs bits) triples; for each triple, encrypt and compare to the expected ciphertext. (4) dvktest takes a cipher instance, a length\u2011n sequence of (key: ks bits, ciphertext: bs bits) pairs, and a fixed plaintext (bs bits); for each pair, decrypt the ciphertext under the key and compare to the fixed plaintext. (5) dvttest takes a cipher instance, a fixed key (ks bits), and a length\u2011n sequence of (plaintext: bs bits, ciphertext: bs bits) pairs; for each pair, decrypt the ciphertext under the fixed key and compare to the plaintext. (6) dkatest takes a cipher instance and a length\u2011n sequence of (key: ks bits, plaintext: bs bits, ciphertext: bs bits) triples; for each triple, decrypt and compare to the plaintext."},{"role":"assistant","content":"```cryptol\nmodule Test where\nimport Cipher\n\nevktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\nevktest (cipher, vkeysCTs, PT) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, CT) <- vkeysCTs ]\n\nevttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\nevttest (cipher, Key, vtextPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (PT, CT) <- vtextPCTs ]\n\nekatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\nekatest (cipher, kaKPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, PT, CT) <- kaKPCTs ]\n\ndvktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\ndvktest (cipher, vkeysCTs, PT) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, CT) <- vkeysCTs ]\n\ndvttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\ndvttest (cipher, Key, vtextPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (PT, CT) <- vtextPCTs ]\n\ndkatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\ndkatest (cipher, kaKPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, PT, CT) <- kaKPCTs ]\n```"}]}
{"filename":"cryptol\/examples\/builtins.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define constants t, f, times, div, mod, exp, lgtest, p, m, neg, and comp, each explicitly typed as an 8-bit sequence. Specify: t as the value chosen by a conditional with a true condition selecting 5; f as the value from a conditional with a false condition selecting 5 over 3; times as the product of 5, 1, 2, and 3; div as 30 divided successively by 1, then 2, then 3 using integer division; mod as 205 modulo 10; exp as 2 raised to the 7th power using the integer exponentiation operator; lgtest as the base-2 logarithm (integer result) of 128 using the built-in log2 function; p as the sum of 3 and 2; m as 8 minus 3; neg as the arithmetic double negation of 5; comp as the bitwise complement of 250 evaluated within 8-bit width. Ensure all arithmetic and bitwise operations are performed in the 8-bit domain and include type annotations for each constant."},{"role":"assistant","content":"```cryptol\nt : [8]\nt = if True then 5 else 4 \nf : [8]\nf = if False then 3 else 5 \ntimes : [8]\ntimes = 5 * 1 * 2 * 3 \ndiv : [8]\ndiv = (((30\/1)\/2)\/3) \nmod : [8]\nmod = 205%10 \nexp : [8]\nexp = 2^^7 \nlgtest : [8]\nlgtest = lg2 128 \np : [8]\np = 3+2 \nm : [8]\nm = 8-3 \nneg : [8]\nneg = -(-5) \ncomp : [8]\ncomp = ~250\n```"}]}
{"filename":"cryptol\/examples\/props.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) defines two 2-bit words, one with the most-significant bit set and the least-significant bit clear, and the other with the most-significant bit clear and the least-significant bit set; defines a third constant as their modular sum in the 2-bit word domain; (2) defines a property named p1 that asserts this sum equals the integer value 3 when represented as a 2-bit word; (3) defines two one-element sequences whose sole elements are the two 2-bit words above, and defines a third one-element sequence as their pointwise (element-wise) sum; (4) defines a polymorphic function t with an explicit type signature universally quantified over a finite natural a, taking a word of length 3\u00b7a and returning a square matrix of bits of size (3\u00b7a) by (3\u00b7a); the function must ignore its input and return an all-zero matrix of the specified size. Clearly specify all types, including that the 2-bit quantities are words of bits, the one-element sequences are sequences of 2-bit words, and the matrix result is a nested sequence. Use the Cryptol property mechanism for p1 and modular arithmetic semantics for word addition."},{"role":"assistant","content":"```cryptol\nx = [True, False]\ny = [False, True]\nz = x + y\n\nproperty p1 = z == 3\n\nxx = [[True,False]]\nyy = [[False, True]]\nzz = xx + yy\n\nt : {a} [a*3] -> [a*3][a*3]\nt d = zero\n```"}]}
{"filename":"cryptol\/examples\/demote.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol specification that introduces: (1) a polymorphic function named x with a numeric type parameter a constrained to be finite; x takes a bitvector of length a and returns a bitvector of length (2*a)+3. The implementation must ignore its input and produce the constant result of adding zero and one, sized to the output width. Provide the full type signature and definition for x. (2) a constant named y defined by applying x to the 3-bit numeric literal whose value is two; give y an explicit type consistent with the instantiated width computed from a = 3. Ensure all size arithmetic and type constraints are explicit and checkable."},{"role":"assistant","content":"```cryptol\nx : {a}(fin a) => [a] -> [(a*2)+3]\nx v = 0 + 1\n\ny = x (2 : [3])\n```"}]}
{"filename":"cryptol\/examples\/append.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares two finite sequences of 8-bit words with explicit type annotations and concrete literal contents, declares a third sequence as the append of the first two, and then declares four additional constants selecting elements from the concatenated sequence at indices 0, 2, 10, and 11. Provide type signatures for all top-level definitions. For the element at index 0, demonstrate indexing using an explicitly typed 1-bit zero; for the others, use natural-number indices. Ensure the index expressions have the correct bit widths implied by the concatenated length so the specification typechecks without defaulting or ambiguity. Clearly state any necessary finiteness and numeric constraints."},{"role":"assistant","content":"```cryptol\nx : [_][8]\nx = [1,2,3,4,5,19,12,38,5,3]\n\ny : [_][8]\ny = [19,3,27,5,12]\n\nz = x # y\n\nm = z @ (0 : [1]) w = z @ 2 \nt = z @ 10 v = z @ 11\n```"}]}
{"filename":"cryptol\/examples\/split.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define constants and properties as follows: create a constant sequence of four 8-bit words holding the values 1, 2, 3, and 4; create a second constant by applying the built-in splitting operation to partition that sequence into two chunks of length two, producing a 2-by-2 nested sequence of 8-bit words; define four constants that extract the elements of the nested sequence by first selecting the outer index (0 or 1) and then the inner index (0 or 1), yielding the first, second, third, and fourth 8-bit values, respectively. Provide explicit type annotations so the first constant is a length-4 sequence of 8-bit words, the split result is a 2-by-2 nested sequence of 8-bit words, and each extracted element is an 8-bit word. Define properties that assert the extracted elements equal 1, 2, 3, and 4 in order, matching the original sequence positions."},{"role":"assistant","content":"```cryptol\nx = [1,2,3,4] : [_][8]\n\ny = (split x) : [2][2][8]\n\na = (y@0) @ 0\nb = (y@0) @ 1\nc = (y@1) @ 0\nd = (y@1) @ 1\n```"}]}
{"filename":"cryptol\/lib\/Array.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Array that contains the following definitions: a primitive two-parameter type constructor representing an indexed array; primitive functions to construct a constant-filled array, read an element by index, write an element at an index producing a new array, test equality of two fixed-size arrays, copy a contiguous range from a source array to a destination array, set a contiguous range in an array to a single value, and test equality of two ranges from two arrays. Provide precise polymorphic type signatures for each, using bitvector index types of width n for fixed-size arrays and appropriate constraints ensuring n is finite and fits within the index type, and that the index type supports integral addition. Implement two total functions: one that returns a length-n sequence of elements starting at a given index by reading successive indices offset by 0..n-1, and one that updates an array with a length-n sequence of values starting at a given index by iteratively applying single-index updates from left to right. Add properties that: (1) the range-read function\u2019s i-th element equals a single read at the base index plus i; (2) the range-update result equals the left-to-right fold of single-index updates at successive offsets with corresponding values; (3) array equality is equivalent to pointwise equality over all indices; (4) range copy equals reading a slice from the source and writing it into the destination at the given start indices for the given length; (5) range set equals writing the same value across the specified contiguous indices; and (6) range equality equals pointwise equality of the corresponding slices. Use universally quantified variables for element type, index type, and length, and clearly state all required class constraints. Do not provide implementations for the primitives beyond their type signatures."},{"role":"assistant","content":"```cryptol\nmodule Array where\n\nprimitive type Array : * -> * -> *\n\nprimitive arrayConstant : {a, b} b -> (Array a b)\nprimitive arrayLookup : {a, b} (Array a b) -> a -> b\nprimitive arrayUpdate : {a, b} (Array a b) -> a -> b -> (Array a b)\nprimitive arrayEq : {n, a} (Array [n] a) -> (Array [n] a) -> Bool\n\nprimitive arrayCopy : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> (Array [n] a)\n\nprimitive arraySet : {n, a} (Array [n] a) -> [n] -> a -> [n] -> (Array [n] a)\n\nprimitive arrayRangeEqual : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> Bool\n\narrayRangeLookup : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b\narrayRangeLookup arr idx = res\n  where\n    res @ i = arrayLookup arr (idx + i)\n\narrayRangeUpdate : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b -> (Array a b)\narrayRangeUpdate arr idx vals = arrs ! 0\n  where\n    arrs = [arr] # [ arrayUpdate acc (idx + i) val | acc <- arrs | i <- [0 ..< n] | val <- vals ]\n```"}]}
{"filename":"cryptol\/lib\/SuiteB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named SuiteB that contains the following definitions, types, and constraints, preserving names and arities: (1) Type synonyms for AES key-size parameters representing the number of 32-bit words for 128-, 192-, and 256-bit keys; a type alias for a 4-by-32-bit AES round key; record types for parameterized encrypt\/decrypt key schedules with fields for initial key, an array of k+5 round keys, and a final key. (2) Public functions that produce encryption\/decryption schedules and paired schedules for each supported key size (128, 192, 256) by delegating to generic expansion helpers. (3) A block encryption function over 128-bit blocks parameterized by k that iteratively applies a primitive AES encryption round across the round keys starting from the initial key addition, then applies a primitive final round and a final key addition; similarly, a block decryption function that uses the corresponding decrypt primitives and round-key order. (4) Private helpers: a generic encrypt-schedule expansion from a k\u00b732-bit key using a primitive key expansion and grouping into round keys; a conversion from encrypt to decrypt schedule that reverses round keys and applies inverse mix-columns; a generic decrypt-schedule expansion and a pair-producing expansion. Include constraints that k is finite and between 4 and 8 inclusive. (5) Primitive declarations for AES round, final round, inverse mix-columns, and key expansion with appropriate types over 4\u00d732-bit states and k-parameterized key material. (6) Public SHA-2 hash functions producing 224-, 256-, 384-, and 512-bit digests that pad an arbitrary-length bitvector, split into 16-word blocks of 32 or 64 bits, and invoke corresponding primitive processors. (7) Private SHA-2 helpers for block size, number of blocks, padded size, a padding function that appends a single \u20181\u2019 bit, zeros, and the length field, a block-splitting function, and primitive processors with sizes matching their digests. Ensure all type signatures, size arithmetic, and constraints match these descriptions."},{"role":"assistant","content":"```cryptol\nmodule SuiteB where\n\ntype AES128 = 4\n\ntype AES192 = 6\n\ntype AES256 = 8\n\ntype AESRoundKey = [4][32]\n\ntype AESEncryptKeySchedule k =\n  { aesEncInitialKey : AESRoundKey\n  , aesEncRoundKeys  : [k+5]AESRoundKey\n  , aesEncFinalKey   : AESRoundKey\n  }\n\ntype AESDecryptKeySchedule k =\n  { aesDecInitialKey : AESRoundKey\n  , aesDecRoundKeys  : [k+5]AESRoundKey\n  , aesDecFinalKey   : AESRoundKey\n  }\n\naes128EncryptSchedule : [128] -> AESEncryptKeySchedule AES128\naes128EncryptSchedule = aesExpandEncryptSchedule\n\naes128DecryptSchedule : [128] -> AESDecryptKeySchedule AES128\naes128DecryptSchedule = aesExpandDecryptSchedule\n\naes128Schedules : [128] -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\naes128Schedules = aesExpandSchedules\n\naes192EncryptSchedule : [192] -> AESEncryptKeySchedule AES192\naes192EncryptSchedule = aesExpandEncryptSchedule\n\naes192DecryptSchedule : [192] -> AESDecryptKeySchedule AES192\naes192DecryptSchedule = aesExpandDecryptSchedule\n\naes192Schedules : [192] -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\naes192Schedules = aesExpandSchedules\n\naes256EncryptSchedule : [256] -> AESEncryptKeySchedule AES256\naes256EncryptSchedule = aesExpandEncryptSchedule\n\naes256DecryptSchedule : [256] -> AESDecryptKeySchedule AES256\naes256DecryptSchedule = aesExpandDecryptSchedule\n\naes256Schedules : [256] -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\naes256Schedules = aesExpandSchedules\n\naesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]\naesEncryptBlock schedule plaintext = rnf (join final)\n  where\n  final = (AESEncFinalRound (rds!0)) ^ schedule.aesEncFinalKey\n\n  rds = [ schedule.aesEncInitialKey ^ split plaintext ] #\n        [ AESEncRound r ^ rdk\n        | rdk <- schedule.aesEncRoundKeys\n        | r   <- rds\n        ]\n\naesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]\naesDecryptBlock schedule cyphertext = rnf (join final)\n  where\n  final = (AESDecFinalRound (rds!0)) ^ schedule.aesDecFinalKey\n\n  rds = [ split cyphertext ^ schedule.aesDecInitialKey ] #\n        [ AESDecRound r ^ rdk\n        | rdk <- schedule.aesDecRoundKeys\n        | r   <- rds\n        ]\n\nprivate\n    aesExpandEncryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESEncryptKeySchedule k\n    aesExpandEncryptSchedule key = rnf\n         { aesEncInitialKey = ks @  0\n         , aesEncRoundKeys  = ks @@ [ 1 .. k+5 ]\n         , aesEncFinalKey   = ks @  `(k+6)\n         }\n      where\n      ks : [k+7]AESRoundKey\n      ks = groupBy`{4} (AESKeyExpand`{k} (split key))\n\n    aesEncToDecSchedule : {k} (fin k) => AESEncryptKeySchedule k -> AESDecryptKeySchedule k\n    aesEncToDecSchedule enc = rnf\n       { aesDecInitialKey = enc.aesEncFinalKey\n       , aesDecRoundKeys  = map AESInvMixColumns (reverse (enc.aesEncRoundKeys))\n       , aesDecFinalKey   = enc.aesEncInitialKey\n       }\n\n    aesExpandDecryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESDecryptKeySchedule k\n    aesExpandDecryptSchedule key = aesEncToDecSchedule (aesExpandEncryptSchedule key)\n\n    aesExpandSchedules : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> (AESEncryptKeySchedule k, AESDecryptKeySchedule k)\n    aesExpandSchedules key = (encS, aesEncToDecSchedule encS)\n      where encS = aesExpandEncryptSchedule key\n\n    primitive AESEncRound      : [4][32] -> [4][32]\n    primitive AESEncFinalRound : [4][32] -> [4][32]\n    primitive AESDecRound      : [4][32] -> [4][32]\n    primitive AESDecFinalRound : [4][32] -> [4][32]\n    primitive AESInvMixColumns : [4][32] -> [4][32]\n    primitive AESKeyExpand     : {k} (fin k, k >= 4, 8 >= k) => [k][32] -> [4*(k+7)][32]\n\nsha224 : {L} (fin L) => [L] -> [224]\nsha224 msg = join (processSHA2_224 (sha2blocks`{32} msg))\n\nsha256 : {L} (fin L) => [L] -> [256]\nsha256 msg = join (processSHA2_256 (sha2blocks`{32} msg))\n\nsha384 : {L} (fin L) => [L] -> [384]\nsha384 msg = join (processSHA2_384 (sha2blocks`{64} msg))\n\nsha512 : {L} (fin L) => [L] -> [512]\nsha512 msg = join (processSHA2_512 (sha2blocks`{64} msg))\n\nprivate\n    type sha2_block_size w = 16 * w\n    type sha2_num_blocks w L = (L+1+2*w) \/^ sha2_block_size w\n    type sha2_padded_size w L = sha2_num_blocks w L * sha2_block_size w\n\n    sha2pad : {w, L} (fin w, fin L, w >= 1) => [L] -> [sha2_padded_size w L]\n    sha2pad M = rnf (M # 0b1 # zero # ((fromInteger `L) : [2*w]))\n\n    sha2blocks : {w, L} (fin w, fin L, w >= 1) =>\n      [L] -> [sha2_num_blocks w L][16][w]\n    sha2blocks msg = [ split x | x <- split (sha2pad`{w} msg) ]\n\n    primitive processSHA2_224 : {n} (fin n) => [n][16][32] -> [7][32]\n\n    primitive processSHA2_256 : {n} (fin n) => [n][16][32] -> [8][32]\n\n    primitive processSHA2_384 : {n} (fin n) => [n][16][64] -> [6][64]\n\n    primitive processSHA2_512 : {n} (fin n) => [n][16][64] -> [8][64]\n```"}]}
{"filename":"cryptol\/lib\/Float.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Float that contains the following definitions: (1) a primitive proposition ValidFloat taking two numeric kinds (exponent size and precision size); (2) a type constructor Float parameterized by exponent and precision, available only when ValidFloat holds; (3) type aliases for common formats with specific exponent\/precision sizes (16, 32, 64, 128, 256); (4) a 3-bit type RoundingMode and five constants for rounding to nearest-even, nearest-away, toward +\u221e, toward \u2212\u221e, and toward zero, each with a short alias, mapped respectively to 0, 1, 2, 3, and 4; (5) primitive values for NaN and +\u221e; derived values \u2212\u221e as the negation of +\u221e, +0 as zero, and \u22120 as the negation of +0; (6) primitives to convert between a bit vector of length exponent+precision and Float, both directions; (7) a primitive float equivalence operator returning Bool, declared infix with precedence 20; (8) primitive predicates to detect NaN, infinity, zero, negative sign, normal, and subnormal; a derived predicate finite defined as not (NaN or infinity); (9) primitive arithmetic operations add, subtract, multiply, divide, and fused multiply-add, each taking a rounding mode; (10) primitive absolute value; (11) primitive square root taking a rounding mode; (12) conversions to Rational and from Rational (the latter taking a rounding mode). All functions must be polymorphic in exponent and precision and require the ValidFloat constraint; use bit-vector lengths computed as exponent+precision. Do not implement bodies for primitives; provide exact type signatures and constants."},{"role":"assistant","content":"```cryptol\nmodule Float where\n\nprimitive type ValidFloat : # -> # -> Prop\n\nprimitive type { exponent : #, precision : #}\n  ValidFloat exponent precision => Float exponent precision : *\n\ntype Float16  = Float 5 11\n\ntype Float32  = Float 8 24\n\ntype Float64  = Float 11 53\n\ntype Float128 = Float 15 113\n\ntype Float256 = Float 19 237\n\ntype RoundingMode = [3]\n\nroundNearestEven, rne : RoundingMode\nroundNearestEven = 0\nrne              = roundNearestEven\n\nroundNearestAway, rna : RoundingMode\nroundNearestAway  = 1\nrna               = roundNearestAway\n\nroundPositive, rtp : RoundingMode\nroundPositive     = 2\nrtp               = roundPositive\n\nroundNegative, rtn : RoundingMode\nroundNegative     = 3\nrtn               = roundNegative\n\nroundZero, rtz : RoundingMode\nroundZero         = 4\nrtz               = roundZero\n\nprimitive\n  fpNaN : {e,p} ValidFloat e p => Float e p\n\nprimitive\n  fpPosInf : {e,p} ValidFloat e p => Float e p\n\nfpNegInf : {e,p} ValidFloat e p => Float e p\nfpNegInf = - fpPosInf\n\nfpPosZero : {e,p} ValidFloat e p => Float e p\nfpPosZero = zero\n\nfpNegZero : {e,p} ValidFloat e p => Float e p\nfpNegZero = - fpPosZero\n\nprimitive\n  fpFromBits : {e,p} ValidFloat e p => [e + p] -> Float e p\n\nprimitive\n  fpToBits : {e,p} ValidFloat e p => Float e p -> [e + p]\n\nprimitive\n  (=.=) : {e,p} ValidFloat e p => Float e p -> Float e p -> Bool\n\ninfix 20 =.=\n\nprimitive fpIsNaN : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsInf : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsZero : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsNeg : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsNormal : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsSubnormal : {e,p} ValidFloat e p => Float e p -> Bool\n\nfpIsFinite : {e,p} ValidFloat e p => Float e p -> Bool\nfpIsFinite f = ~ (fpIsNaN f \\\/ fpIsInf f )\n\nprimitive\n  fpAdd : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpSub : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpMul : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpDiv : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpFMA : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpAbs : {e,p} ValidFloat e p =>\n    Float e p -> Float e p\n\nprimitive\n  fpSqrt : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p\n\nprimitive\n  fpToRational : {e,p} ValidFloat e p =>\n    Float e p -> Rational\n\nprimitive\n  fpFromRational : {e,p} ValidFloat e p =>\n    RoundingMode -> Rational -> Float e p\n```"}]}
{"filename":"cryptol\/lib\/Cryptol.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Cryptol that contains the following definitions, with precise type signatures and constraints over type-level naturals and classes: (1) Operator fixities and precedences for logical, comparison, arithmetic, bit-shift\/rotate, indexing, and concatenation operators. (2) Primitive type-level and value-level entities: bits, unbounded integer, bounded signed integers parameterized by a positive finite width, rational, the infinite length kind, type-level predicates (type equality\/inequality, finiteness, primality, ordering), and type-level arithmetic\/combinators (+, *, -, \/, %, exponentiation, width, min, max, division\/modulo variants, and a length computation for arithmetic progressions). Provide constraint synonyms for natural comparisons. (3) Type synonyms for booleans, words, characters, strings, and a logarithm-of-2 width helper at the type level. (4) Literal predicate classes for numbers and bounded ranges, with constructors\/demoters for literals; finite range constructors for increasing\/decreasing and stride-based sequences, plus from-then-to with a length constraint. (5) Numeric and logical classes (zero, logic, ring, integral, field, rounding, equality, comparison, signed comparison) and their associated operations with required constraints. (6) Algebraic enums for optional and result values; boolean constants and connectives including implication; helpers for absolute value, min\/max, signed\/unsigned comparisons, and pointwise function equality\/inequality. (7) Bitvector\/sequence utilities: carry\/overflow checks, zero\/sign extension, shifts\/rotates by integer indices, integer conversions (signed and Z-based), rational construction, concatenation\/splitting, reversing\/transposition, slicing, head\/tail\/last, grouping, indexing (random and bounds-checked) and bulk\/single updates, generator, sorting (by comparator and default), polynomial arithmetic over bit polynomials, parallel map, strictness utilities, error\/undefined, assertions, randomness, tracing. (8) Higher-order utilities: map, folds (left\/right, strict and non-strict), sum\/product, scans, repeat, membership, zipping, currying\/uncurrying, iteration, predicates all\/any\/and\/or. Ensure all parameters and guards match finiteness and ordering bounds as described."},{"role":"assistant","content":"```cryptol\nmodule Cryptol where\n\ninfixr  5 ==>\ninfixr 10 \\\/\ninfixr 15 \/\\\ninfix  20 ==, ===, !=, !==\ninfix  30 >, >=, <, <=, <$, >$, <=$, >=$\ninfixr 40 ||\ninfixl 45 ^\ninfixr 50 &&\ninfixr 60 #\ninfixl 70 <<, <<<, >>, >>>, >>$\ninfixl 80 +, -\ninfixl 90 *, \/, %, \/$, %$, %^, \/^\ninfixr 95 ^^\ninfixl 100 @, @@, !, !!\n\nprimitive type Bit : *\n\nprimitive type Integer : *\n\nprimitive type {n : #} (fin n, n >= 1) => Z n : *\n\nprimitive type Rational : *\n\ntype Bool = Bit\ntype Word n = [n]\ntype Char = [8]\ntype String n = [n]Char\n\nprimitive type inf : #\n\nprimitive type (==) : # -> # -> Prop\n\nprimitive type (!=) : # -> # -> Prop\n\nprimitive type (>=) : # -> # -> Prop\n\nprimitive type fin : # -> Prop\n\nprimitive type prime : # -> Prop\n\nprimitive type (+) : # -> # -> #\n\nprimitive type (*) : # -> # -> #\n\nprimitive type\n  {m : #, n : # }\n  (fin n, m >= n) =>\n  m - n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin m, n >= 1) =>\n  m \/ n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin m, n >= 1) =>\n  m % n : #\n\nprimitive type (^^) : # -> # -> #\n\nprimitive type width : # -> #\n\ntype lg2 n = width (max n 1 - 1)\n\nprimitive type min : # -> # -> #\n\nprimitive type max : # -> # -> #\n\nprimitive type\n  { m : #, n : # }\n  (fin n, n >= 1) =>\n  m \/^ n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin n, n >= 1) =>\n  m %^ n : #\n\nprimitive type\n  { start : #, next : #, last : # }\n  (fin start, fin next, fin last, start != next) =>\n  lengthFromThenTo start next last : #\n\ntype constraint i <= j = (j >= i)\n\ntype constraint i > j = i >= j + 1\n\ntype constraint i < j = j >= i + 1\n\nprimitive type Literal : # -> * -> Prop\n\nprimitive type LiteralLessThan : # -> * -> Prop\n\nprimitive number : {val, rep} Literal val rep => rep\n\ndemote : {val, rep} Literal val rep => rep\ndemote = number`{val}\n\nlength : {n, a, b} (fin n, Literal n b) => [n]a -> b\nlength _ = `n\n\nprimitive fromTo : {first, last, a}\n  (fin last, last >= first, Literal last a) =>\n  [1 + (last - first)]a\n\nprimitive fromToLessThan :\n  {first, bound, a} (fin first, bound >= first, LiteralLessThan bound a) =>\n  [bound - first]a\n\nprimitive fromToBy : {first, last, stride, a}\n  (fin last, fin stride, stride >= 1, last >= first, Literal last a) =>\n  [1 + (last - first)\/stride]a\n\nprimitive fromToByLessThan : {first, bound, stride, a}\n  (fin first, fin stride, stride >= 1, bound >= first, LiteralLessThan bound a) =>\n  [(bound - first)\/^stride]a\n\nprimitive fromToDownBy : {first, last, stride, a}\n  (fin first, fin stride, stride >= 1, first >= last, Literal first a) =>\n  [1 + (first - last)\/stride]a\n\nprimitive fromToDownByGreaterThan : {first, bound, stride, a}\n  (fin first, fin stride, stride >= 1, first >= bound, Literal first a) =>\n  [(first - bound)\/^stride]a\n\nprimitive fromThenTo : {first, next, last, a, len}\n                       ( fin first, fin next, fin last\n                       , Literal first a, Literal next a, Literal last a\n                       , first != next\n                       , lengthFromThenTo first next last == len) => [len]a\n\nprimitive type FLiteral : # -> # -> # -> * -> Prop\n\nprimitive\n  fraction : { m, n, r, a } FLiteral m n r a => a\n\nprimitive type Zero : * -> Prop\n\nprimitive zero : {a} (Zero a) => a\n\nprimitive type Logic : * -> Prop\n\nprimitive (&&) : {a} (Logic a) => a -> a -> a\n\nprimitive (||) : {a} (Logic a) => a -> a -> a\n\nprimitive (^) : {a} (Logic a) => a -> a -> a\n\nprimitive complement : {a} (Logic a) => a -> a\n\nprimitive type Ring : * -> Prop\n\nprimitive fromInteger : {a} (Ring a) => Integer -> a\n\nprimitive (+) : {a} (Ring a) => a -> a -> a\n\nprimitive (-) : {a} (Ring a) => a -> a -> a\n\nprimitive (*) : {a} (Ring a) => a -> a -> a\n\nprimitive negate : {a} (Ring a) => a -> a\n\nprimitive type Integral : * -> Prop\n\nprimitive (\/) : {a} (Integral a) => a -> a -> a\n\nprimitive (%) : {a} (Integral a) => a -> a -> a\n\nprimitive toInteger : {a} (Integral a) => a -> Integer\n\nprimitive (^^) : {a, e} (Ring a, Integral e) => a -> e -> a\n\nprimitive infFrom : {a} (Integral a) => a -> [inf]a\n\nprimitive infFromThen : {a} (Integral a) => a -> a -> [inf]a\n\nprimitive type Field : * -> Prop\n\nprimitive recip : {a} (Field a) => a -> a\n\nprimitive (\/.) : {a} (Field a) => a -> a -> a\n\nprimitive type Round : * -> Prop\n\nprimitive ceiling : {a} (Round a) => a -> Integer\n\nprimitive floor : {a} (Round a) => a -> Integer\n\nprimitive trunc : {a} (Round a) => a -> Integer\n\nprimitive roundAway : {a} (Round a) => a -> Integer\n\nprimitive roundToEven : {a} (Round a) => a -> Integer\n\nprimitive type Eq : * -> Prop\n\nprimitive (==) : {a} (Eq a) => a -> a -> Bit\n\nprimitive (!=) : {a} (Eq a) => a -> a -> Bit\n\n(===) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\nf === g = \\ x -> f x == g x\n\n(!==) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\nf !== g = \\x -> f x != g x\n\nprimitive type Cmp : * -> Prop\n\nprimitive (<) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (>) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (<=) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (>=) : {a} (Cmp a) => a -> a -> Bit\n\nmin : {a} (Cmp a) => a -> a -> a\nmin x y = if x < y then x else y\n\nmax : {a} (Cmp a) => a -> a -> a\nmax x y = if x > y then x else y\n\nabs : {a} (Cmp a, Ring a) => a -> a\nabs x = if x < fromInteger 0 then negate x else x\n\nprimitive type SignedCmp : * -> Prop\n\nprimitive (<$) : {a} (SignedCmp a) => a -> a -> Bit\n\n(>$) : {a} (SignedCmp a) => a -> a -> Bit\nx >$ y = y <$ x\n\n(<=$) : {a} (SignedCmp a) => a -> a -> Bit\nx <=$ y = ~(y <$ x)\n\n(>=$) : {a} (SignedCmp a) => a -> a -> Bit\nx >=$ y = ~(x <$ y)\n\nenum Option a = None | Some a\n\nenum Result t e = Ok t | Err e\n\nprimitive True  : Bit\n\nprimitive False : Bit\n\n(\/\\) : Bit -> Bit -> Bit\nx \/\\ y = if x then y else False\n\n(\\\/) : Bit -> Bit -> Bit\nx \\\/ y = if x then True else y\n\n(==>) : Bit -> Bit -> Bit\na ==> b = if a then b else True\n\nprimitive (\/$) : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\n\nprimitive (%$) : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\n\ncarry : {n} (fin n) => [n] -> [n] -> Bit\ncarry x y = (x + y) < x\n\nscarry : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nscarry x y = (sx == sy) && (sx != sz)\n  where\n    z  = x + y\n    sx = head x\n    sy = head y\n    sz = head z\n\nsborrow : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsborrow x y = ( x <$ (x-y) ) ^ head y\n\nzext : {m, n} (fin m, m >= n) => [n] -> [m]\nzext x = zero # x\n\nsext : {m, n} (fin m, m >= n, n >= 1) => [n] -> [m]\nsext x = newbits # x\n  where newbits = if head x then ~zero else zero\n\nprimitive (>>$) : {n, ix} (fin n, n >= 1, Integral ix) => [n] -> ix -> [n]\n\nprimitive lg2 : {n} (fin n) => [n] -> [n]\n\nprimitive toSignedInteger : {n} (fin n, n >= 1) => [n] -> Integer\n\nprimitive ratio : Integer -> Integer -> Rational\n\nprimitive fromZ : {n} (fin n, n >= 1) => Z n -> Integer\n\nprimitive (#) : {front, back, a} (fin front) => [front]a -> [back]a\n                                             -> [front + back] a\n\nsplitAt : {front, back, a} (fin front) => [front + back]a\n                                       -> ([front]a, [back]a)\nsplitAt xs = (take`{front,back} xs, drop`{front,back} xs)\n\nprimitive join : {parts, each, a} (fin each) => [parts][each]a\n                                             -> [parts * each]a\n\nprimitive split : {parts, each, a} (fin each) => [parts * each]a\n                                              -> [parts][each]a\n\nprimitive reverse : {n, a} (fin n) => [n]a -> [n]a\n\nprimitive transpose : {rows, cols, a} [rows][cols]a -> [cols][rows]a\n\nprimitive take : {front, back, a} [front + back]a -> [front]a\n\nprimitive drop : {front, back, a} (fin front) => [front + back]a -> [back]a\n\ntail : {n, a} [1 + n]a -> [n]a\ntail xs = drop`{1} xs\n\nhead : {n, a} [1 + n]a -> a\nhead xs = xs @ (0 : Integer)\n\nlast : {n, a} (fin n) => [1 + n]a -> a\nlast xs = xs ! (0 : Integer)\n\ngroupBy : {each, parts, a} (fin each) => [parts * each]a -> [parts][each]a\ngroupBy = split`{parts=parts}\n\nprimitive (<<) : {n, ix, a} (Integral ix, Zero a) => [n]a -> ix -> [n]a\n\nprimitive (>>) : {n, ix, a} (Integral ix, Zero a) => [n]a -> ix -> [n]a\n\nprimitive (<<<) : {n, ix, a} (fin n, Integral ix) => [n]a -> ix -> [n]a\n\nprimitive (>>>) : {n, ix, a} (fin n, Integral ix) => [n]a -> ix -> [n]a\n\nprimitive (@) : {n, a, ix} (Integral ix) => [n]a -> ix -> a\n\n(@@) : {n, k, ix, a} (Integral ix) => [n]a -> [k]ix -> [k]a\nxs @@ is = [ xs @ i | i <- is ]\n\nprimitive (!) : {n, a, ix} (fin n, Integral ix) => [n]a -> ix -> a\n\n(!!) : {n, k, ix, a} (fin n, Integral ix) => [n]a -> [k]ix -> [k]a\nxs !! is = [ xs ! i | i <- is ]\n\nprimitive update : {n, a, ix} (Integral ix) => [n]a -> ix -> a -> [n]a\n\nprimitive updateEnd : {n, a, ix} (fin n, Integral ix) => [n]a -> ix -> a -> [n]a\n\nupdates : {n, k, ix, a} (Integral ix, fin k) => [n]a -> [k]ix -> [k]a -> [n]a\nupdates xs0 idxs vals = foldl upd xs0 (zip idxs vals)\n  where\n    upd xs (i,b) = update xs i b\n\nupdatesEnd : {n, k, ix, a} (fin n, Integral ix, fin k) => [n]a -> [k]ix -> [k]a -> [n]a\nupdatesEnd xs0 idxs vals = foldl upd xs0 (zip idxs vals)\n  where\n    upd xs (i,b) = updateEnd xs i b\n\ngenerate : {n, a, ix} (Integral ix, LiteralLessThan n ix) => (ix -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. <n] ]\n\nsort : {a, n} (Cmp a, fin n) => [n]a -> [n]a\nsort = sortBy (<=)\n\nsortBy : {a, n} (fin n) => (a -> a -> Bit) -> [n]a -> [n]a\nsortBy le ((xs : [n\/2]a) # (ys : [n\/^2]a)) = take zs.0\n  where\n    xs' = if `(n\/2)  == (1 : Integer) then xs else sortBy le xs\n    ys' = if `(n\/^2) == (1 : Integer) then ys else sortBy le ys\n    zs  = [ if i == `(n\/2)        then (ys'@j, i  , j+1)\n             | j == `(n\/^2)       then (xs'@i, i+1, j  )\n             | le (xs'@i) (ys'@j) then (xs'@i, i+1, j  )\n            else                       (ys'@j, i  , j+1)\n          | (_, i , j) <- [ (undefined, 0 : Integer, 0 : Integer) ] # zs\n          ]\n\nprimitive pmult : {u, v} (fin u, fin v) => [1 + u] -> [1 + v] -> [1 + u + v]\n\nprimitive pdiv : {u, v} (fin u, fin v) => [u] -> [v] -> [u]\n\nprimitive pmod : {u, v} (fin u, fin v) => [u] -> [1 + v] -> [v]\n\nprimitive parmap : {a, b, n} (Eq b, fin n) => (a -> b) -> [n]a -> [n]b\n\nprimitive deepseq : {a, b} Eq a => a -> b -> b\n\nrnf : {a} Eq a => a -> a\nrnf x = deepseq x x\n\nprimitive error : {a, n} (fin n) => String n -> a\n\nundefined : {a} a\nundefined = error \"undefined\"\n\nassert : {a, n} (fin n) => Bit -> String n -> a -> a\nassert pred msg x = if pred then x else error msg\n\nprimitive random : {a} [256] -> a\n\nprimitive trace : {n, a, b} (fin n) => String n -> a -> b -> b\n\ntraceVal : {n, a} (fin n) => String n -> a -> a\ntraceVal msg x = trace msg x x\n\nand : {n} (fin n) => [n]Bit -> Bit\nand xs = ~zero == xs\n\nor : {n} (fin n) => [n]Bit -> Bit\nor xs = zero != xs\n\nall : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nall f xs = foldl' (\/\\) True (map f xs)\n\n\/**\n * Disjunction after applying a predicate to all elements.\n *\/\nany : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nany f xs = foldl' (\\\/) False (map f xs)\n\nmap : {n, a, b} (a -> b) -> [n]a -> [n]b\nmap f xs = [f x | x <- xs]\n\nprimitive foldl : {n, a, b} (fin n) => (a -> b -> a) -> a -> [n]b -> a\n\nprimitive foldl' : {n, a, b} (fin n, Eq a) => (a -> b -> a) -> a -> [n]b -> a\n\n\/**\n * Functional right fold.\n *\n * foldr (-) 0 [1,2,3] = 0 - (1 - (2 - 3))\n *\/\nfoldr : {n, a, b} (fin n) => (a -> b -> b) -> b -> [n]a -> b\nfoldr f acc xs = foldl g acc (reverse xs)\n  where g b a = f a b\n\n\/**\n * Functional right fold, with strict evaluation of the accumulator value.\n * The accumulator is reduced to weak head normal form at each step.\n *\n * foldr' (-) 0 [1,2,3] = 0 - (1 - (2 - 3))\n *\/\nfoldr' : {n, a, b} (fin n, Eq b) => (a -> b -> b) -> b -> [n]a -> b\nfoldr' f acc xs = foldl' g acc (reverse xs)\n  where g b a = f a b\n\n\/**\n * Compute the sum of the values in the sequence.\n *\/\nsum : {n, a} (fin n, Eq a, Ring a) => [n]a -> a\nsum xs = foldl' (+) (fromInteger 0) xs\n\nproduct : {n, a} (fin n, Eq a, Ring a) => [n]a -> a\nproduct xs = foldl' (*) (fromInteger 1) xs\n\n\/**\n * Scan left is like a foldl that also emits the intermediate values.\n *\/\nprimitive scanl : {n, a, b}  (a -> b -> a) -> a -> [n]b -> [1+n]a\n\n\/**\n * Scan right is like a foldr that also emits the intermediate values.\n *\/\nscanr : {n, a, b} (fin n) => (a -> b -> b) -> b -> [n]a -> [1+n]b\nscanr f acc xs = reverse (scanl (\\a b -> f b a) acc (reverse xs))\n\n\/**\n * Repeat a value.\n *\/\nrepeat : {n, a} a -> [n]a\nrepeat x = [ x | _ <- zero : [n] ]\n\n\/**\n * 'elem x xs' returns true if x is equal to a value in xs.\n *\/\nelem : {n, a} (fin n, Eq a) => a -> [n]a -> Bit\nelem a xs = any (\\x -> x == a) xs\n\n\/**\n * Create a list of tuples from two lists.\n *\/\nzip : {n, a, b} [n]a -> [n]b -> [n](a, b)\nzip xs ys = [(x,y) | x <- xs | y <- ys]\n\n\/**\n * Create a list by applying the function to each pair of elements in the input.\n *\/\nzipWith : {n, a, b, c} (a -> b -> c) -> [n]a -> [n]b -> [n]c\nzipWith f xs ys = [f x y | x <- xs | y <- ys]\n\n\/**\n * Transform a function into uncurried form.\n *\/\nuncurry : {a, b, c} (a -> b -> c) -> (a, b) -> c\nuncurry f = \\(a, b) -> f a b\n\n\/**\n * Transform a function into curried form.\n *\/\ncurry : {a, b, c} ((a, b) -> c) -> a -> b -> c\ncurry f = \\a b -> f (a, b)\n\n\/**\n * Map a function iteratively over a seed value, producing an infinite\n * list of successive function applications.\n *\/\niterate : {a} (a -> a) -> a -> [inf]a\niterate f z = scanl (\\x _ -> f x) z (zero:[inf]())\n```"}]}
{"filename":"cryptol\/bench\/data\/SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named SHA512 that contains the following definitions: (1) A top-level function sha512 with a precise type signature mapping a finite-length bit sequence to a 512-bit digest. It must pad the message per SHA-512 (append a single 1 bit, then zero bits, then a 128-bit big-endian length) so that the total length is a multiple of 1024, with the usual bound that the original length fits in 128 bits. After padding, split into 1024-bit blocks, iteratively apply a compression function starting from an 8-word 64-bit initial vector, and return the final chaining value concatenated into 512 bits. (2) A function processBlock with type [1024] -> [8][64] -> [8][64] that builds an 80-word schedule from the 16 input words and performs 80 rounds of the SHA-512 step, then adds the result to the incoming state word-wise modulo 2^64. (3) A function step with type [8][64] -> [64] -> [8] -> [8][64] that takes the state, a 64-bit schedule word, and a round index in [0..79], computes T1 and T2 using the SHA-512 Ch, Maj, and big-sigma functions, and returns the next state. (4) A function messageSch with type [16][64] -> [80][64] that defines words 16..79 using the small-sigma recurrences. (5) A polymorphic pad with constraints capturing the SHA-512 padding length arithmetic and output length multiple-of-1024 requirement. (6) Bitwise helpers Ch, Maj, SIGMA0, SIGMA1, sigma0, sigma1 on 64-bit words using rotates and shifts. (7) Constants H0 : [8][64] and K : [80][64] with standard SHA-512 initialization and round constants. (8) A property named testVector1 that checks the hash of a specific hexadecimal message equals a specific 512-bit hexadecimal digest (the property may ignore its argument). Provide all necessary type signatures and ensure 64-bit modular arithmetic."},{"role":"assistant","content":"```cryptol\nmodule SHA512 where\n\nsha512 M = result\n  where\n    M' = (pad M)\n    blocks = (groupBy`{1024} M')\n    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]\n    result = (join (hash!0))\n\nprocessBlock : [1024] -> [8][64] -> [8][64]\nprocessBlock block Hprev = Hs\n  where\n    Mi = split block : [16][64]\n    Ws = (messageSch Mi)\n    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]\n    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]\n\nstep : [8][64] -> [64] -> [8] -> [8][64]\nstep [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']\n  where\n    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt\n    T2 = (SIGMA0 a) + (Maj a b c)\n    h' = g\n    g' = f\n    f' = e\n    e' = d + T1\n    d' = c\n    c' = b\n    b' = a\n    a' = T1 + T2\n\nmessageSch : [16][64] -> [80][64]\nmessageSch Mi = W\n  where\n    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]\n\npad : {l, k} (fin l,\n              l <= ((2^^128) - 1),\n              l >= 0,\n              fin k,\n              k - l >= 129,\n              k == 128 + l + 1 + 1024 - ((l+129)%1024),\n              k%1024 == 0) => [l] -> [k]\npad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])\n\nCh : [64] -> [64] -> [64] -> [64]\nCh x y z = (x && y) ^ ((~x) && z)\n\nMaj : [64] -> [64] -> [64] -> [64]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nSIGMA0 : [64] -> [64]\nSIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)\n\nSIGMA1 : [64] -> [64]\nSIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)\n\nsigma0 : [64] -> [64]\nsigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)\n\nsigma1 : [64] -> [64]\nsigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)\n\nH0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]\n\nK = [\n0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n]\n\nproperty testVector1 x = sha512 0xfd2203e467574e834ab07c9097ae164532f24be1eb5d88f1af7748ceff0d2c67a21f4e4097f9d3bb4e9fbf97186e0db6db0100230a52b453d421f8ab9c9a6043aa3295ea20d2f06a2f37470d8a99075f1b8a8336f6228cf08b5942fc1fb4299c7d2480e8e82bce175540bdfad7752bc95b577f229515394f3ae5cec870a4b2f8 == 0xa21b1077d52b27ac545af63b32746c6e3c51cb0cb9f281eb9f3580a6d4996d5c9917d2a6e484627a9d5a06fa1b25327a9d710e027387fc3e07d7c4d14c6086cc\n```"}]}
{"filename":"cryptol\/rust\/cry-ffi\/Example.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Example that imports the Float module and contains only declarations (no implementations) for the following: (1) a newtype N wrapping a record with one field unN that is an 8-bit sequence; (2) foreign abstract symbols with explicit types: a function Bit -> Bit; functions over fixed-width sequences mapping each width to itself for 8, 16, 32, 64, and 128 bits (two sets named for unsigned and signed but all typed as the corresponding [n]); a function Integer -> Integer; a function Rational -> Rational; a function Float32 -> Float32; a function Float64 -> Float64; a function mapping an array of length 16 of 8-bit sequences to the same; functions over records: empty record -> empty record, a record with field x of 8 bits to itself, and a record with fields x (8 bits) and y (16 bits) to itself; functions over tuples: unit -> unit and a pair (8-bit, 16-bit) to itself; a function N -> N; a function Option [8] -> Option [8]; a function Result [16] [32] -> Result [16] [32]; a curried function taking two 8-bit sequences and returning an 8-bit sequence; a function taking a 128-bit sequence and returning a pair of 128-bit sequences; a function Z 7 -> Z 7; and a polymorphic value with implicit numeric parameter n, constrained to be finite and at least 1, returning Z n. Mark each declared symbol as foreign abstract and give precise Cryptol type signatures matching these descriptions."},{"role":"assistant","content":"```cryptol\nmodule Example where\n\nimport Float\n\nnewtype N = { unN : [8] }\n\nforeign abstract test_bool : Bit -> Bit\nforeign abstract test_u8 : [8] -> [8]\nforeign abstract test_u16 : [16] -> [16]\nforeign abstract test_u32 : [32] -> [32]\nforeign abstract test_u64 : [64] -> [64]\nforeign abstract test_u128 : [128] -> [128]\nforeign abstract test_i8 : [8] -> [8]\nforeign abstract test_i16 : [16] -> [16]\nforeign abstract test_i32 : [32] -> [32]\nforeign abstract test_i64 : [64] -> [64]\nforeign abstract test_i128 : [128] -> [128]\nforeign abstract test_integer : Integer -> Integer\nforeign abstract test_rational : Rational -> Rational\nforeign abstract test_float : Float32 -> Float32\nforeign abstract test_double : Float64 -> Float64\nforeign abstract test_array_16_u8 : [16][8] -> [16][8]\nforeign abstract test_record0 : {} -> {}\nforeign abstract test_record1_u8 : { x : [8] } -> { x : [8] }\nforeign abstract test_record2_u8_u16 : { x : [8], y : [16] } -> { x : [8], y : [16] }\nforeign abstract test_tuple0 : () -> ()\nforeign abstract test_tuple2_u8_u16 : ([8], [16]) -> ([8], [16])\nforeign abstract test_newtype_u8 : N -> N\nforeign abstract test_option_u8 : Option [8] -> Option [8]\nforeign abstract test_result_u16_u32 : Result [16] [32] -> Result [16] [32]\nforeign abstract test_two_u8_args : [8] -> [8] -> [8]\nforeign abstract test_two_u128_res : [128] -> ([128], [128])\nforeign abstract test_z7 : Z 7 -> Z 7\nforeign abstract test_param : {n} (fin n, n >= 1) => Z n\n```"}]}
{"filename":"cryptol\/tests\/modsys\/T007.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a parameterized submodule named F that accepts a numeric type parameter n and a value parameter x of type [n], with constraints that n is finite and at least 4. Inside F, declare y with type [n] and define it as the modular sum of x and the literal 11 (addition modulo 2^n). Next, define a concrete submodule I that fixes n to 8 and assigns x the literal 2 with type [8]. Instantiate F using the parameters from I to create a submodule named M. Finally, import the instantiated submodule under the alias M."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type n : #\n    x      : [n]\n    type constraint (fin n, n >= 4)\n\n  y : [n]\n  y = x + 11\n\nsubmodule I where\n  type n = 8\n  x = 2\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/enum\/CheckEnumPartialError.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an algebraic data type parameterized by an element type to represent an optional value with two constructors: one for absence and one wrapping a present value. Then define two polymorphic functions with type parameters a and b that each take a unary function from a to b and an optional a, and return an optional b. Make both definitions intentionally non-exhaustive via case analysis: the first handles only the present-value constructor and returns a present transformed value; the second handles only the absence constructor and returns absence. Next, define an enumeration type with exactly three distinct nullary constructors. Provide one function from this enum to the unit type that matches only the first constructor (intentionally non-exhaustive). Finally, provide a second function from the same enum to unit that is total by matching the first constructor explicitly and using a wildcard branch to handle all remaining constructors. Use appropriate Cryptol type signatures and case expressions to illustrate the partial and total pattern matches."},{"role":"assistant","content":"```cryptol\nenum Maybe a = Nothing | Just a\n\nmaybeMapBad1 : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMapBad1 f m =\n  case m of\n    Just x -> Just (f x)\n\nmaybeMapBad2 : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMapBad2 f m =\n  case m of\n    Nothing -> Nothing\n\nenum Foo = A | B | C\n\nfooBad1 : Foo -> ()\nfooBad1 f =\n  case f of\n    A -> ()\n\nfooGood : Foo -> ()\nfooGood f =\n  case f of\n    A -> ()\n    _ -> ()\n```"}]}
{"filename":"cryptol\/tests\/enum\/CheckProveEnum.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define enumerations for Maybe a (with absence or a value), Either a b (with left or right value), Foo a (three nullary variants and one carrying an 8-bit word and a value), and Letter (three symbols). Provide equality predicates maybeEqual, eitherEqual, fooEqual with types returning Bit and using Eq constraints where needed to compare only when constructors match and, for parameterized cases, using the underlying equality. Define mapping functions: maybeMap to apply a function only to a present value; eitherMapLeft and eitherMapRight to map over left or right, and eitherMapBoth to map both in one pass; fooMap to map only the value field of the binary Foo constructor, leaving the 8-bit field and other variants unchanged; letterRotate to cycle the three letters. Define a property that for Maybe [8], mapping (+1) twice equals mapping (+2) once, compared via maybeEqual. Define a property that for Either [8] [8], applying (+1) to the right then to the left equals mapping both once, compared via eitherEqual. Define a property that for Foo [8], mapping (+1) twice equals mapping (+2) once, compared via fooEqual. Define a property that for Letter, rotating three times yields the original value, checked by letterEqual."},{"role":"assistant","content":"```cryptol\nenum Maybe a = Nothing | Just a\n\nmaybeEqual : {a} (Eq a) => Maybe a -> Maybe a -> Bit\nmaybeEqual m1 m2 =\n  case m1 of\n    Just x1 ->\n      case m2 of\n        Just x2 -> x1 == x2\n        Nothing -> False\n    Nothing ->\n      case m2 of\n        Just x2 -> False\n        Nothing -> True\n\nmaybeMap : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMap f m =\n  case m of\n    Just x  -> Just (f x)\n    Nothing -> Nothing\n\nmaybeMapProp : Maybe [8] -> Bit\nproperty maybeMapProp m =\n  maybeEqual\n    (maybeMap (\\x -> x + 1) (maybeMap (\\x -> x + 1) m))\n    (maybeMap (\\x -> x + 2) m)\n\nenum Either a b = Left a | Right b\n\neitherEqual : {a, b} (Eq a, Eq b) => Either a b -> Either a b -> Bit\neitherEqual e1 e2 =\n  case e1 of\n    Left x1 ->\n      case e2 of\n        Left x2  -> x1 == x2\n        Right y2 -> False\n    Right y1 ->\n      case e2 of\n        Left x2  -> False\n        Right y2 -> y1 == y2\n\neitherMapLeft : {a, a', b} (a -> a') -> Either a b -> Either a' b\neitherMapLeft f e =\n  case e of\n    Left x  -> Left (f x)\n    Right y -> Right y\n\neitherMapRight : {a, b, b'} (b -> b') -> Either a b -> Either a b'\neitherMapRight g e =\n  case e of\n    Left x  -> Left x\n    Right y -> Right (g y)\n\neitherMapBoth : {a, a', b, b'} (a -> a') -> (b -> b') -> Either a b -> Either a' b'\neitherMapBoth f g e =\n  case e of\n    Left x  -> Left (f x)\n    Right y -> Right (g y)\n\neitherMapProp : Either [8] [8] -> Bit\nproperty eitherMapProp e =\n  eitherEqual\n    (eitherMapLeft (\\x -> x + 1) (eitherMapRight (\\y -> y + 1) e))\n    (eitherMapBoth (\\x -> x + 1) (\\y -> y + 1) e)\n\nenum Foo a = Bar | Baz | Quux | Fred [8] a\n\nfooEqual : {a} (Eq a) => Foo a -> Foo a -> Bit\nfooEqual f1 f2 =\n  case f1 of\n    Bar ->\n      case f2 of\n        Bar        -> True\n        Baz        -> False\n        Quux       -> False\n        Fred y1 y2 -> False\n    Baz ->\n      case f2 of\n        Bar        -> False\n        Baz        -> True\n        Quux       -> False\n        Fred y1 y2 -> False\n    Quux ->\n      case f2 of\n        Bar        -> False\n        Baz        -> False\n        Quux       -> True\n        Fred y1 y2 -> False\n    Fred x1 x2 ->\n      case f2 of\n        Bar        -> False\n        Baz        -> False\n        Quux       -> False\n        Fred y1 y2 -> (x1 == y1) \/\\ (x2 == y2)\n\nfooMap : {a, b} (a -> b) -> Foo a -> Foo b\nfooMap f ff =\n  case ff of\n    Bar      -> Bar\n    Baz      -> Baz\n    Quux     -> Quux\n    Fred x y -> Fred x (f y)\n\nfooMapProp : Foo [8] -> Bit\nproperty fooMapProp f =\n  fooEqual\n    (fooMap (\\x -> x + 1) (fooMap (\\x -> x + 1) f))\n    (fooMap (\\x -> x + 2) f)\n\nenum Letter = A | B | C\n\nletterEqual : Letter -> Letter -> Bit\nletterEqual l1 l2 =\n  case l1 of\n    A ->\n      case l2 of\n        A -> True\n        B -> False\n        C -> False\n    B ->\n      case l2 of\n        A -> False\n        B -> True\n        C -> False\n    C ->\n      case l2 of\n        A -> False\n        B -> False\n        C -> True\n\nletterRotate : Letter -> Letter\nletterRotate l =\n  case l of\n    A -> B\n    B -> C\n    C -> A\n\nletterRotateProp : Letter -> Bit\nproperty letterRotateProp l =\n  letterEqual l (letterRotate (letterRotate (letterRotate l)))\n```"}]}
{"filename":"cryptol\/tests\/parser\/tuples-records.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define constants with explicit type annotations for: (1) a pair named tuple containing two 8-bit values equal to 0xFF; (2) a pair named nested_tuple1 whose first element is an 8-bit 0xFF and whose second element is a pair of two 8-bit 0xFF values; (3) a pair named nested_tupel2 whose first element is a pair of two 8-bit 0xFF values and whose second element is an 8-bit 0xFF; (4) an empty tuple named empty_tuple with unit type; (5) a record named record with fields x and y, each an 8-bit 0xFF; (6) a record named nested_record with field x as an 8-bit 0xFF and field y as a record with fields x and y each an 8-bit 0xFF; and (7) an empty record named empty_records. Ensure all literals use the 8-bit word type and that each definition\u2019s type precisely matches its structure (e.g., pairs vs nested pairs, flat record vs nested record, and empty tuple\/record types). Do not provide implementations beyond these annotated constant declarations."},{"role":"assistant","content":"```cryptol\ntuple           = (0xFF, 0xFF)\nnested_tuple1   = (0xFF, (0xFF,0xFF))\nnested_tupel2   = ((0xFF,0xFF), 0xFF)\nempty_tuple     = ()\n\nrecord          = { x = 0xFF, y = 0xFF }\nnested_record   = { x = 0xFF, y = { x = 0xFF, y = 0xFF }}\nempty_records   = {}\n```"}]}
{"filename":"cryptol\/tests\/parser\/docs.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the following:\n- A constant named test1 with an explicit type of a single-bit boolean and value true.\n- A constant named test2 with value true, relying on type inference (no explicit type signature).\n- A unary function named test3 that returns its input unchanged and is fully polymorphic over its argument type.\n- Define a property named test4 that takes one argument, constrains it to be a single-bit boolean via a type annotation, and uses that annotated value as the property\u2019s boolean result.\n- Declare an infix operator named ++ with left associativity and precedence 5; give it the polymorphic type for all types a: a -> a -> a; define it to return its first operand, ignoring the second.\n- A private constant named test5 whose value is the unit value.\n- A type synonym named Foo that is equal to the unit type.\nInclude the necessary type signatures where specified and ensure the visibility and fixity declarations match the description. Do not provide any proofs or evaluations; only the specification elements described above."},{"role":"assistant","content":"```cryptol\ntest1 : Bit\ntest1 = True\n\ntest2 = True\n\ntest3 x = x\n\nproperty test4 x = (x : Bit)\n\ninfixl 5 ++\n\n(++) : {a} a -> a -> a\nx ++ _ = x\n\nprivate test5 = ()\n\ntype Foo = ()\n```"}]}
{"filename":"cryptol\/tests\/parser\/T437.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the following artifacts mirroring the described behaviors and types: (1) A polymorphic function mk_buggy_fib_no_init with a size parameter a constrained to be finite and at least 1. It takes: (i) a counter target value of a bits (magic), and (ii) a pair whose first element is a single-bit input (ignored) and whose second element is a state triple (x, y, k) where x and y are 8-bit words and k is an a-bit counter. It returns a pair of: an 8-bit output and an updated state triple. The next state is (y, x+y, k+1), with arithmetic modulo the respective widths. The output equals x plus 1 precisely when k equals magic; otherwise it equals x. Provide the corresponding type signature. (2) A generic function generate parameterized by n, ix, and element type a, with constraints that ix and n are finite, n \u2265 1, and ix is at least the bit-width of n\u22121. It takes a function from an ix-bit index to an element and returns a sequence of length n computed by enumerating indices 0..n\u22121. Provide its type signature and definition. (3) A left-associative infix operator $ with precedence level 1 that performs simple function application (apply a unary function to its argument). (4) Two constants foo and bar, each a sequence of length 10 of 4-bit elements. Each is produced by the generator applied to a lambda over an 8-bit index i, yielding 1 at index 0 and otherwise the previous element at index i\u22121. Define foo using the $ operator and bar using direct application; both must have identical behavior and type."},{"role":"assistant","content":"```cryptol\nmk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n  \/\/ Change output when state has magic value.\n  fn' = fn + if k == magic then 1 else 0\n\ngenerate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. n-1] ]\n\ninfixl 1 $\nf $ x = f x\n\nfoo : [10][4]\nfoo = generate $ \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n\nbar : [10][4]\nbar = generate \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n```"}]}
{"filename":"cryptol\/tests\/parser\/unary.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two properties that verify unary operator precedence over addition for 8-bit words. For the first property, assert that for the 8-bit value 5, applying the bitwise complement and then adding 2 is equal to explicitly parenthesizing the complemented value and then adding 2. For the second property, assert the analogous equivalence for unary arithmetic negation and addition by 2. Annotate the literal 5 as an 8-bit word so both sides of each equality have type [8], and ensure each property returns a Boolean result by comparing the two [8]-typed expressions for equality."},{"role":"assistant","content":"```cryptol\ntest1 = (~ (5 : [8]) + 2) == (~ (5 : [8])) + 2\ntest2 = (- (5 : [8]) + 2) == (- (5 : [8])) + 2\n```"}]}
{"filename":"cryptol\/tests\/parser\/pat1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines seven functions using pattern matching with complete, generalized type signatures and necessary size parameters and constraints: (1) a function that takes a 2-tuple and returns its first component (fully polymorphic over element types); (2) a function that, given a sequence known to be the concatenation of two subsequences, returns the left subsequence (polymorphic over element type and lengths m and n, with input length m+n and result length m); (3) a function that consumes a sequence of exactly three elements of an arithmetic type and returns the sum of its three elements; (4) a function that takes a record with exactly two fields, binds both fields to new names in the pattern, and returns the value of the first field; (5) a function that destructures an input formed by concatenating an 8-element left segment with a 10-element right segment and returns their concatenation, ensuring the right segment is explicitly annotated as length 10 in the result; (6) a function that, given an input that is a concatenation whose right segment has length 10, returns the left segment (left length is size-polymorphic); (7) a function identical in behavior to (6) but written so the right segment\u2019s length-10 annotation is parenthesized in the pattern. Use tuple, sequence, list, and record patterns as appropriate. Provide explicit type signatures with size parameters in braces, and include any required arithmetic constraints for addition. Do not include tests; only the definitions."},{"role":"assistant","content":"```cryptol\nf1 (x,y) = x\nf2 (x # y) = x\nf3 [x,y,z] = x + y + z\nf4 {x = a, y = b } = a\nf5 ((x : [8]) # (y : [10])) = x # y : [10]\nf6 (x # y : [10]) = x\nf7 (x # (y : [10])) = x\n```"}]}
{"filename":"cryptol\/tests\/parser\/infix-1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two infix operators named ++ and ** with left associativity. Assign precedence levels 4 for ++ and 5 for ** so that ** binds tighter than ++. Provide a type signature for ++ that takes two 8-bit sequences and returns an 8-bit sequence, and define it to compute their sum using 8-bit addition. Provide a polymorphic type signature for ** with a single type variable constrained by the Ring type class; it takes two values of that type and returns their product, implemented via ring multiplication. Include the infix declarations, type signatures, and definitions."},{"role":"assistant","content":"```cryptol\ninfixl 4 ++\ninfixl 5 **\n\n(++) : [8] -> [8] -> [8]\nx ++ y = x + y\n\n(**) : {a} (Ring a) => a -> a -> a\nx ** y = x * y\n```"}]}
{"filename":"cryptol\/tests\/parser\/applications.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) defines an identity function over finite bitvectors and a function that returns its second argument, each with fully polymorphic type signatures over any finite width; (2) defines nine 8-bit constants exercising function application and modular arithmetic, including: applying the identity to a byte; applying the second-argument function to two bytes; the sum of two identical bytes; a left-associative sum of three small bytes; an expression where multiplication binds tighter than addition; an expression where a product is added to a byte; an expression where a product uses the result of the identity function and then is added to a byte; an application of the second-argument function where the first argument is a parenthesized arithmetic expression and the second is a byte; and a nested application of the identity function to a byte. For each constant, declare a property that equates it to the expected byte result under 8-bit modular arithmetic and additional properties that equate pairs of expressions that should be parsed identically due to precedence and associativity (e.g., function application binding tighter than infix operators, multiplication binding tighter than addition, and left-associative addition). Clearly state all type constraints (finite sequence widths) and ensure every numeric literal and arithmetic expression is 8 bits."},{"role":"assistant","content":"```cryptol\ng x   = x\nf x y = y\n\napp1 = g 0xFF\napp2 = f 0xFF 0xFF\napp3 = 0xFF + 0xFF\napp4 = 0x01 + 0x02 + 0x03\napp5 = 0x01 + 0x02 * 0x03\napp6 = 0x01 * 0x02 + 0x03\napp7 = 0x01 * g 0xFF + 0x02\napp8 = f (0x01 * g 0xFF + 0x02) 0xFF\napp9 = g (g 0xFF)\n```"}]}
{"filename":"cryptol\/tests\/suiteb\/aes-mct-ecb.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that implements AES ECB Monte Carlo Tests for 128-, 192-, and 256-bit keys and verifies them against known vectors. Define a record type parameterized by key size n with fields: a key of n bits, a 128-bit plaintext, and a 128-bit ciphertext. Define functions mct_ecb_encrypt_128, mct_ecb_decrypt_128, mct_ecb_encrypt_192, mct_ecb_decrypt_192, mct_ecb_encrypt_256, and mct_ecb_decrypt_256 with types [n] -> [128] -> [100] of that record (where n is 128, 192, or 256). Each function performs 100 batches of 1000 chained ECB operations: for batch i, encrypt (or decrypt) a stream whose first block is the provided initial block and subsequent blocks are the previous batch\u2019s outputs; within the full 100,000-block stream select, for each batch i, the first input and the 1000th output as that batch\u2019s plaintext and ciphertext; record the current batch key. Maintain a vector of 100 keys: start with the initial key and update between batches by XOR with a 128\/192\/256-bit value derived from the first two outputs of the previous batch as follows: for 128, use the first block; for 192, concatenate the low 64 bits of the second block with the first block; for 256, concatenate the first two blocks. Build a vector of 100 key schedules by mapping the appropriate AES schedule function over the 100 keys; for block index j, use the schedule at floor(j\/1000). Define four constants holding the 100-record expected vectors for 128\/192\/256 encryption and decryption. Define six properties that the expected vectors equal the results of the corresponding functions when applied to the specified initial key and initial 128-bit block for each case."},{"role":"assistant","content":"```cryptol\nimport SuiteB\n\ntype AESTestVector n =\n  { key        : [n]\n  , plaintext  : [128]\n  , ciphertext : [128]\n  }\n\nmct_ecb_encrypt_128 : [128] -> [128] -> [100](AESTestVector 128)\nmct_ecb_encrypt_128 initialKey initialPt = vs\n  where\n  vs@i = { key = keys@i, plaintext=pts@(i*1000), ciphertext=cts@(i*1000 + 999) }\n\n  pts : [100*1000][128]\n  pts = [initialPt] # take cts\n\n  cts : [100*1000][128]\n  cts@i = aesEncryptBlock (schedules@(i\/1000)) (pts@i)\n\n  keys : [100][128]\n  keys = [initialKey] # [ k ^ (xs!0)\n                        | xs <- take`{99} (groupBy`{1000} cts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESEncryptKeySchedule AES128)\n  schedules = map aes128EncryptSchedule keys\n\nmct_ecb_decrypt_128 : [128] -> [128] -> [100](AESTestVector 128)\nmct_ecb_decrypt_128 initialKey initialCt = vs\n  where\n  vs@i = { key = keys@i, ciphertext=cts@(i*1000), plaintext=pts@(i*1000 + 999) }\n\n  cts : [100*1000][128]\n  cts = [initialCt] # take pts\n\n  pts : [100*1000][128]\n  pts@i = aesDecryptBlock (schedules@(i\/1000)) (cts@i)\n\n  keys : [100][128]\n  keys = [initialKey] # [ k ^ (xs!0)\n                        | xs <- take`{99} (groupBy`{1000} pts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESDecryptKeySchedule AES128)\n  schedules = map aes128DecryptSchedule keys\n\nproperty aes128_MCT_vectors_encrypt_correct =\n  aes128_MCT_encrypt_test_vectors ==\n  mct_ecb_encrypt_128 0x139a35422f1d61de3c91787fe0507afd 0xb9145a768b7dc489a096b546f43b231f\n\nproperty aes128_MCT_vectors_decrypt_correct =\n  aes128_MCT_decrypt_test_vectors ==\n  mct_ecb_decrypt_128 0x0c60e7bf20ada9baa9e1ddf0d1540726 0xb08a29b11a500ea3aca42c36675b9785\n\naes128_MCT_encrypt_test_vectors : [100](AESTestVector 128)\naes128_MCT_encrypt_test_vectors =\n [{ key = 0x139a35422f1d61de3c91787fe0507afd\n  , plaintext = 0xb9145a768b7dc489a096b546f43b231f\n  , ciphertext = 0xd7c3ffac9031238650901e157364c386\n  },\n\n  { key = 0xc459caeebf2c42586c01666a9334b97b\n  , plaintext = 0xd7c3ffac9031238650901e157364c386\n  , ciphertext = 0xbc3637da2daf8fcf7c68bb28c143a0a4\n  },\n\n  { key = 0x786ffd349283cd971069dd42527719df\n  , plaintext = 0xbc3637da2daf8fcf7c68bb28c143a0a4\n  , ciphertext = 0x9c88a8db798f48df1ac4936afa959eac\n  },\n\n  { key = 0xe4e755efeb0c85480aad4e28a8e28773\n  , plaintext = 0x9c88a8db798f48df1ac4936afa959eac\n  , ciphertext = 0xb87aaa1c76a775d94c2ddf82abe5c66e\n  },\n\n  { key = 0x5c9dfff39dabf091468091aa0307411d\n  , plaintext = 0xb87aaa1c76a775d94c2ddf82abe5c66e\n  , ciphertext = 0x79ee212734f14d1bf5a59d46e8c2fa34\n  },\n\n  { key = 0x2573ded4a95abd8ab3250cecebc5bb29\n  , plaintext = 0x79ee212734f14d1bf5a59d46e8c2fa34\n  , ciphertext = 0x09df49135aeb8e373a19fa457ab280a0\n  },\n\n  { key = 0x2cac97c7f3b133bd893cf6a991773b89\n  , plaintext = 0x09df49135aeb8e373a19fa457ab280a0\n  , ciphertext = 0xc52263efa6379209d17e87ac250615cb\n  },\n\n  { key = 0xe98ef4285586a1b458427105b4712e42\n  , plaintext = 0xc52263efa6379209d17e87ac250615cb\n  , ciphertext = 0x336bed017e10a247ee92989862431163\n  },\n\n  { key = 0xdae519292b9603f3b6d0e99dd6323f21\n  , plaintext = 0x336bed017e10a247ee92989862431163\n  , ciphertext = 0xb13310581ffe5b10aaefdeb8992aec18\n  },\n\n  { key = 0x6bd60971346858e31c3f37254f18d339\n  , plaintext = 0xb13310581ffe5b10aaefdeb8992aec18\n  , ciphertext = 0xb0eaede3f3eebfef88822a6ede1950b1\n  },\n\n  { key = 0xdb3ce492c786e70c94bd1d4b91018388\n  , plaintext = 0xb0eaede3f3eebfef88822a6ede1950b1\n  , ciphertext = 0x37891fc253b00de13155d5517e1b7890\n  },\n\n  { key = 0xecb5fb509436eaeda5e8c81aef1afb18\n  , plaintext = 0x37891fc253b00de13155d5517e1b7890\n  , ciphertext = 0x8f574c85fa44af2d43c95ee5f627fc9d\n  },\n\n  { key = 0x63e2b7d56e7245c0e62196ff193d0785\n  , plaintext = 0x8f574c85fa44af2d43c95ee5f627fc9d\n  , ciphertext = 0x6c0af6709225f328a0225b2280efa3e3\n  },\n\n  { key = 0x0fe841a5fc57b6e84603cddd99d2a466\n  , plaintext = 0x6c0af6709225f328a0225b2280efa3e3\n  , ciphertext = 0xe2dc36073fe192e712373a8702e8adce\n  },\n\n  { key = 0xed3477a2c3b6240f5434f75a9b3a09a8\n  , plaintext = 0xe2dc36073fe192e712373a8702e8adce\n  , ciphertext = 0x1e91d1e1f82f1d320186210a792f7ba1\n  },\n\n  { key = 0xf3a5a6433b99393d55b2d650e2157209\n  , plaintext = 0x1e91d1e1f82f1d320186210a792f7ba1\n  , ciphertext = 0x228eac74166da261d7fa83f43d9ddd2f\n  },\n\n  { key = 0xd12b0a372df49b5c824855a4df88af26\n  , plaintext = 0x228eac74166da261d7fa83f43d9ddd2f\n  , ciphertext = 0x25d0de6a894361a1b83d5fa2fd607f26\n  },\n\n  { key = 0xf4fbd45da4b7fafd3a750a0622e8d000\n  , plaintext = 0x25d0de6a894361a1b83d5fa2fd607f26\n  , ciphertext = 0x36095dc3e659ec50ca7f6f8207d20031\n  },\n\n  { key = 0xc2f2899e42ee16adf00a6584253ad031\n  , plaintext = 0x36095dc3e659ec50ca7f6f8207d20031\n  , ciphertext = 0x8dbfe965078468875d86145164c4ab4f\n  },\n\n  { key = 0x4f4d60fb456a7e2aad8c71d541fe7b7e\n  , plaintext = 0x8dbfe965078468875d86145164c4ab4f\n  , ciphertext = 0x4032bb8137d4b9eb93644359a995bb4e\n  },\n\n  { key = 0x0f7fdb7a72bec7c13ee8328ce86bc030\n  , plaintext = 0x4032bb8137d4b9eb93644359a995bb4e\n  , ciphertext = 0x85308aa92c625a25bd5f4a40375c6baa\n  },\n\n  { key = 0x8a4f51d35edc9de483b778ccdf37ab9a\n  , plaintext = 0x85308aa92c625a25bd5f4a40375c6baa\n  , ciphertext = 0x73283fc59e04e80a867e478d97a3f388\n  },\n\n  { key = 0xf9676e16c0d875ee05c93f4148945812\n  , plaintext = 0x73283fc59e04e80a867e478d97a3f388\n  , ciphertext = 0x418c1fe377e4ef9832f20286b167f916\n  },\n\n  { key = 0xb8eb71f5b73c9a76373b3dc7f9f3a104\n  , plaintext = 0x418c1fe377e4ef9832f20286b167f916\n  , ciphertext = 0x60ad1341525e67cffdd68ff671253c77\n  },\n\n  { key = 0xd84662b4e562fdb9caedb23188d69d73\n  , plaintext = 0x60ad1341525e67cffdd68ff671253c77\n  , ciphertext = 0x4edf6e01a76de6153d17713a49d5b028\n  },\n\n  { key = 0x96990cb5420f1bacf7fac30bc1032d5b\n  , plaintext = 0x4edf6e01a76de6153d17713a49d5b028\n  , ciphertext = 0x2c85ebf9e3d80596f78712df56ac77cd\n  },\n\n  { key = 0xba1ce74ca1d71e3a007dd1d497af5a96\n  , plaintext = 0x2c85ebf9e3d80596f78712df56ac77cd\n  , ciphertext = 0x8fc8ef9ab7462712977e87c741795ece\n  },\n\n  { key = 0x35d408d61691392897035613d6d60458\n  , plaintext = 0x8fc8ef9ab7462712977e87c741795ece\n  , ciphertext = 0x37e9ac800cfb19133b4e9b0c418ca098\n  },\n\n  { key = 0x023da4561a6a203bac4dcd1f975aa4c0\n  , plaintext = 0x37e9ac800cfb19133b4e9b0c418ca098\n  , ciphertext = 0xcb7cd7619caa605e45f95f5b31a85495\n  },\n\n  { key = 0xc941733786c04065e9b49244a6f2f055\n  , plaintext = 0xcb7cd7619caa605e45f95f5b31a85495\n  , ciphertext = 0x6e265e5fd030847b8841bf6652996392\n  },\n\n  { key = 0xa7672d6856f0c41e61f52d22f46b93c7\n  , plaintext = 0x6e265e5fd030847b8841bf6652996392\n  , ciphertext = 0x5c9a7d2ce1c86f0b3425b3b6aae108e0\n  },\n\n  { key = 0xfbfd5044b738ab1555d09e945e8a9b27\n  , plaintext = 0x5c9a7d2ce1c86f0b3425b3b6aae108e0\n  , ciphertext = 0xc911dee5ff318a7e799f92daadcb3d9a\n  },\n\n  { key = 0x32ec8ea14809216b2c4f0c4ef341a6bd\n  , plaintext = 0xc911dee5ff318a7e799f92daadcb3d9a\n  , ciphertext = 0x7a3afdf10410f1c47c7d928d4a8d432a\n  },\n\n  { key = 0x48d673504c19d0af50329ec3b9cce597\n  , plaintext = 0x7a3afdf10410f1c47c7d928d4a8d432a\n  , ciphertext = 0xc681b7b6d3ec9dc91012e3b7427c67ad\n  },\n\n  { key = 0x8e57c4e69ff54d6640207d74fbb0823a\n  , plaintext = 0xc681b7b6d3ec9dc91012e3b7427c67ad\n  , ciphertext = 0xcd3f84bbe958536d502065eb37ae10b4\n  },\n\n  { key = 0x4368405d76ad1e0b1000189fcc1e928e\n  , plaintext = 0xcd3f84bbe958536d502065eb37ae10b4\n  , ciphertext = 0x879db797e686b9116c25c07f4ae67593\n  },\n\n  { key = 0xc4f5f7ca902ba71a7c25d8e086f8e71d\n  , plaintext = 0x879db797e686b9116c25c07f4ae67593\n  , ciphertext = 0x5959ebd7a1167713429eda69538c536b\n  },\n\n  { key = 0x9dac1c1d313dd0093ebb0289d574b476\n  , plaintext = 0x5959ebd7a1167713429eda69538c536b\n  , ciphertext = 0xf57101d7fa19f97a31d60b276312717c\n  },\n\n  { key = 0x68dd1dcacb2429730f6d09aeb666c50a\n  , plaintext = 0xf57101d7fa19f97a31d60b276312717c\n  , ciphertext = 0x6dfbbc2b147568c55adbfdc3c706edb0\n  },\n\n  { key = 0x0526a1e1df5141b655b6f46d716028ba\n  , plaintext = 0x6dfbbc2b147568c55adbfdc3c706edb0\n  , ciphertext = 0x9c4ea9002306d75e7b0f03e2a72b7a1d\n  },\n\n  { key = 0x996808e1fc5796e82eb9f78fd64b52a7\n  , plaintext = 0x9c4ea9002306d75e7b0f03e2a72b7a1d\n  , ciphertext = 0xcb9975336cc05f0114f26bde4cc84f8d\n  },\n\n  { key = 0x52f17dd29097c9e93a4b9c519a831d2a\n  , plaintext = 0xcb9975336cc05f0114f26bde4cc84f8d\n  , ciphertext = 0x902c4250cff110d792938e8dcd534cf0\n  },\n\n  { key = 0xc2dd3f825f66d93ea8d812dc57d051da\n  , plaintext = 0x902c4250cff110d792938e8dcd534cf0\n  , ciphertext = 0x140242f195ef2ef7f6ee23574c071311\n  },\n\n  { key = 0xd6df7d73ca89f7c95e36318b1bd742cb\n  , plaintext = 0x140242f195ef2ef7f6ee23574c071311\n  , ciphertext = 0x3c6d4ffafde866f1e994480c47d20a04\n  },\n\n  { key = 0xeab2328937619138b7a279875c0548cf\n  , plaintext = 0x3c6d4ffafde866f1e994480c47d20a04\n  , ciphertext = 0x1ca04a21addc38ef8bfc8989d3d6b33b\n  },\n\n  { key = 0xf61278a89abda9d73c5ef00e8fd3fbf4\n  , plaintext = 0x1ca04a21addc38ef8bfc8989d3d6b33b\n  , ciphertext = 0xbb8875ee3c3c8c0987b1c20f999028e9\n  },\n\n  { key = 0x4d9a0d46a68125debbef32011643d31d\n  , plaintext = 0xbb8875ee3c3c8c0987b1c20f999028e9\n  , ciphertext = 0x9d33724d80a76f2033a37a851403ef28\n  },\n\n  { key = 0xd0a97f0b26264afe884c488402403c35\n  , plaintext = 0x9d33724d80a76f2033a37a851403ef28\n  , ciphertext = 0x4c92fe152d16da8ea59b9f29c75f20ff\n  },\n\n  { key = 0x9c3b811e0b3090702dd7d7adc51f1cca\n  , plaintext = 0x4c92fe152d16da8ea59b9f29c75f20ff\n  , ciphertext = 0x659c76f73032b0192b281034b6a99a3f\n  },\n\n  { key = 0xf9a7f7e93b02206906ffc79973b686f5\n  , plaintext = 0x659c76f73032b0192b281034b6a99a3f\n  , ciphertext = 0x5d296637697ccad84fc77936a31c2655\n  },\n\n  { key = 0xa48e91de527eeab14938beafd0aaa0a0\n  , plaintext = 0x5d296637697ccad84fc77936a31c2655\n  , ciphertext = 0xa72a596a030d5541bc4d0fc739491d5b\n  },\n\n  { key = 0x03a4c8b45173bff0f575b168e9e3bdfb\n  , plaintext = 0xa72a596a030d5541bc4d0fc739491d5b\n  , ciphertext = 0x5f5ec53c91225717fcba470688dfa364\n  },\n\n  { key = 0x5cfa0d88c051e8e709cff66e613c1e9f\n  , plaintext = 0x5f5ec53c91225717fcba470688dfa364\n  , ciphertext = 0x5719cb14eba820c0d51109a0c7a4154f\n  },\n\n  { key = 0x0be3c69c2bf9c827dcdeffcea6980bd0\n  , plaintext = 0x5719cb14eba820c0d51109a0c7a4154f\n  , ciphertext = 0x3abd186712a9def73b6312b5300f02af\n  },\n\n  { key = 0x315edefb395016d0e7bded7b9697097f\n  , plaintext = 0x3abd186712a9def73b6312b5300f02af\n  , ciphertext = 0xb1e90c8c0d4c9651a6de7f52a63ac456\n  },\n\n  { key = 0x80b7d277341c80814163922930adcd29\n  , plaintext = 0xb1e90c8c0d4c9651a6de7f52a63ac456\n  , ciphertext = 0x5d26e33aae1441554034c77bde451679\n  },\n\n  { key = 0xdd91314d9a08c1d401575552eee8db50\n  , plaintext = 0x5d26e33aae1441554034c77bde451679\n  , ciphertext = 0x93e44cdce14803544a53bc5b520c156f\n  },\n\n  { key = 0x4e757d917b40c2804b04e909bce4ce3f\n  , plaintext = 0x93e44cdce14803544a53bc5b520c156f\n  , ciphertext = 0x8ee3b6fd953b441043f69f3747e4cf63\n  },\n\n  { key = 0xc096cb6cee7b869008f2763efb00015c\n  , plaintext = 0x8ee3b6fd953b441043f69f3747e4cf63\n  , ciphertext = 0xcb2f545970200630e5145f817a013807\n  },\n\n  { key = 0x0bb99f359e5b80a0ede629bf8101395b\n  , plaintext = 0xcb2f545970200630e5145f817a013807\n  , ciphertext = 0x50047276451ce19cb14d8d2ef0b3851b\n  },\n\n  { key = 0x5bbded43db47613c5caba49171b2bc40\n  , plaintext = 0x50047276451ce19cb14d8d2ef0b3851b\n  , ciphertext = 0xd243791dde33c2a4333ef4dcbcadbd3a\n  },\n\n  { key = 0x89fe945e0574a3986f95504dcd1f017a\n  , plaintext = 0xd243791dde33c2a4333ef4dcbcadbd3a\n  , ciphertext = 0x343181860092a5e33c2e1c441a9f6804\n  },\n\n  { key = 0xbdcf15d805e6067b53bb4c09d780697e\n  , plaintext = 0x343181860092a5e33c2e1c441a9f6804\n  , ciphertext = 0x4e7cdd553d732909e25a13a521e04078\n  },\n\n  { key = 0xf3b3c88d38952f72b1e15facf6602906\n  , plaintext = 0x4e7cdd553d732909e25a13a521e04078\n  , ciphertext = 0x9c16f3fda49bb6a2b6d76a6696bd768f\n  },\n\n  { key = 0x6fa53b709c0e99d0073635ca60dd5f89\n  , plaintext = 0x9c16f3fda49bb6a2b6d76a6696bd768f\n  , ciphertext = 0x9eb63f9099123591a4ca7aa0fff55a49\n  },\n\n  { key = 0xf11304e0051cac41a3fc4f6a9f2805c0\n  , plaintext = 0x9eb63f9099123591a4ca7aa0fff55a49\n  , ciphertext = 0xaa6a9e40aad692550b7c87b92b205af0\n  },\n\n  { key = 0x5b799aa0afca3e14a880c8d3b4085f30\n  , plaintext = 0xaa6a9e40aad692550b7c87b92b205af0\n  , ciphertext = 0xae92c267f38b9b4623df36523bb739b6\n  },\n\n  { key = 0xf5eb58c75c41a5528b5ffe818fbf6686\n  , plaintext = 0xae92c267f38b9b4623df36523bb739b6\n  , ciphertext = 0x39c0de843767dfa2d563c0632405d595\n  },\n\n  { key = 0xcc2b86436b267af05e3c3ee2abbab313\n  , plaintext = 0x39c0de843767dfa2d563c0632405d595\n  , ciphertext = 0x80a9445be75373b07476608feb1f1c7b\n  },\n\n  { key = 0x4c82c2188c7509402a4a5e6d40a5af68\n  , plaintext = 0x80a9445be75373b07476608feb1f1c7b\n  , ciphertext = 0x5306f5a77e42d9f4cee8f134ba1448c6\n  },\n\n  { key = 0x1f8437bff237d0b4e4a2af59fab1e7ae\n  , plaintext = 0x5306f5a77e42d9f4cee8f134ba1448c6\n  , ciphertext = 0x8db0c3fba7dc797cd175d97503759260\n  },\n\n  { key = 0x9234f44455eba9c835d7762cf9c475ce\n  , plaintext = 0x8db0c3fba7dc797cd175d97503759260\n  , ciphertext = 0x04fcb0c77ae0c98d2afb178ab2c2b02d\n  },\n\n  { key = 0x96c844832f0b60451f2c61a64b06c5e3\n  , plaintext = 0x04fcb0c77ae0c98d2afb178ab2c2b02d\n  , ciphertext = 0x1a156581b3557078971cc6877a3d9339\n  },\n\n  { key = 0x8cdd21029c5e103d8830a721313b56da\n  , plaintext = 0x1a156581b3557078971cc6877a3d9339\n  , ciphertext = 0xe47087289290fa2b6734eeaab2fc815d\n  },\n\n  { key = 0x68ada62a0eceea16ef04498b83c7d787\n  , plaintext = 0xe47087289290fa2b6734eeaab2fc815d\n  , ciphertext = 0x00ce641525020d35244e2227287b2a20\n  },\n\n  { key = 0x6863c23f2bcce723cb4a6bacabbcfda7\n  , plaintext = 0x00ce641525020d35244e2227287b2a20\n  , ciphertext = 0xecf623cef1e420d0994070c078592c97\n  },\n\n  { key = 0x8495e1f1da28c7f3520a1b6cd3e5d130\n  , plaintext = 0xecf623cef1e420d0994070c078592c97\n  , ciphertext = 0x256c8f28df4a286fb05514fcfa8cbcaf\n  },\n\n  { key = 0xa1f96ed90562ef9ce25f0f9029696d9f\n  , plaintext = 0x256c8f28df4a286fb05514fcfa8cbcaf\n  , ciphertext = 0xfd4aed4b5a2b8edefe3cc2aef6ecd298\n  },\n\n  { key = 0x5cb383925f4961421c63cd3edf85bf07\n  , plaintext = 0xfd4aed4b5a2b8edefe3cc2aef6ecd298\n  , ciphertext = 0xdfe0e571f77f0b46c52f003e774918ac\n  },\n\n  { key = 0x835366e3a8366a04d94ccd00a8cca7ab\n  , plaintext = 0xdfe0e571f77f0b46c52f003e774918ac\n  , ciphertext = 0xe421fbeb4c23745b97578162f89e68fc\n  },\n\n  { key = 0x67729d08e4151e5f4e1b4c625052cf57\n  , plaintext = 0xe421fbeb4c23745b97578162f89e68fc\n  , ciphertext = 0xc38c0bbde031d1a79438f79ff7cc68a5\n  },\n\n  { key = 0xa4fe96b50424cff8da23bbfda79ea7f2\n  , plaintext = 0xc38c0bbde031d1a79438f79ff7cc68a5\n  , ciphertext = 0x86113133968aa3052709875bf033d804\n  },\n\n  { key = 0x22efa78692ae6cfdfd2a3ca657ad7ff6\n  , plaintext = 0x86113133968aa3052709875bf033d804\n  , ciphertext = 0xfd706bef1bf30c8d1e95543b75629e02\n  },\n\n  { key = 0xdf9fcc69895d6070e3bf689d22cfe1f4\n  , plaintext = 0xfd706bef1bf30c8d1e95543b75629e02\n  , ciphertext = 0x9a5bbb6125152f1352b10e1c1a172aa6\n  },\n\n  { key = 0x45c47708ac484f63b10e668138d8cb52\n  , plaintext = 0x9a5bbb6125152f1352b10e1c1a172aa6\n  , ciphertext = 0x3ee69736488c51fa72784aa263618f45\n  },\n\n  { key = 0x7b22e03ee4c41e99c3762c235bb94417\n  , plaintext = 0x3ee69736488c51fa72784aa263618f45\n  , ciphertext = 0xfc66daa246ebcc320c7c89b599014633\n  },\n\n  { key = 0x87443a9ca22fd2abcf0aa596c2b80224\n  , plaintext = 0xfc66daa246ebcc320c7c89b599014633\n  , ciphertext = 0x35645885ed205d67e5caeff26646c38c\n  },\n\n  { key = 0xb22062194f0f8fcc2ac04a64a4fec1a8\n  , plaintext = 0x35645885ed205d67e5caeff26646c38c\n  , ciphertext = 0xdaeaa866aa4eacdb752caccb2c0ae6c1\n  },\n\n  { key = 0x68caca7fe54123175fece6af88f42769\n  , plaintext = 0xdaeaa866aa4eacdb752caccb2c0ae6c1\n  , ciphertext = 0x29e88b1ae615fcd06b09e767459d6089\n  },\n\n  { key = 0x412241650354dfc734e501c8cd6947e0\n  , plaintext = 0x29e88b1ae615fcd06b09e767459d6089\n  , ciphertext = 0x63470bff052e7f5c7a735cc2e6eb61ac\n  },\n\n  { key = 0x22654a9a067aa09b4e965d0a2b82264c\n  , plaintext = 0x63470bff052e7f5c7a735cc2e6eb61ac\n  , ciphertext = 0xf4fa6a3549cd2b33af9cac134d7b1402\n  },\n\n  { key = 0xd69f20af4fb78ba8e10af11966f9324e\n  , plaintext = 0xf4fa6a3549cd2b33af9cac134d7b1402\n  , ciphertext = 0x5b22a82ccbae9b9c75f797e74e6da53d\n  },\n\n  { key = 0x8dbd88838419103494fd66fe28949773\n  , plaintext = 0x5b22a82ccbae9b9c75f797e74e6da53d\n  , ciphertext = 0x87b51692f8f28743bd8dc843276f351a\n  },\n\n  { key = 0x0a089e117ceb97772970aebd0ffba269\n  , plaintext = 0x87b51692f8f28743bd8dc843276f351a\n  , ciphertext = 0x150fb2180704a7623a1fab8bf17fba18\n  },\n\n  { key = 0x1f072c097bef3015136f0536fe841871\n  , plaintext = 0x150fb2180704a7623a1fab8bf17fba18\n  , ciphertext = 0x8088874e7f3f09a98fd3f0a59f2a0b4b\n  },\n\n  { key = 0x9f8fab4704d039bc9cbcf59361ae133a\n  , plaintext = 0x8088874e7f3f09a98fd3f0a59f2a0b4b\n  , ciphertext = 0x08e02c091057d81c05d917ea5c07cdd0\n  },\n\n  { key = 0x976f874e1487e1a09965e2793da9deea\n  , plaintext = 0x08e02c091057d81c05d917ea5c07cdd0\n  , ciphertext = 0xb9636b3e2752694c3685872fd0a9a0ea\n  },\n\n  { key = 0x2e0cec7033d588ecafe06556ed007e00\n  , plaintext = 0xb9636b3e2752694c3685872fd0a9a0ea\n  , ciphertext = 0x2610dae2b64d74a8cbb4f43fa2d0a603\n  },\n\n  { key = 0x081c36928598fc44645491694fd0d803\n  , plaintext = 0x2610dae2b64d74a8cbb4f43fa2d0a603\n  , ciphertext = 0x9cc994eda697fb5545eaa502b2a30fd3\n  },\n\n  { key = 0x94d5a27f230f071121be346bfd73d7d0\n  , plaintext = 0x9cc994eda697fb5545eaa502b2a30fd3\n  , ciphertext = 0xfb2649694783b551eacd9d5db6126d47\n  }]\n\naes128_MCT_decrypt_test_vectors : [100](AESTestVector 128)\naes128_MCT_decrypt_test_vectors =\n [{ key = 0x0c60e7bf20ada9baa9e1ddf0d1540726\n  , ciphertext = 0xb08a29b11a500ea3aca42c36675b9785\n  , plaintext = 0xb613b87085fed1bb87f07a574e6d2879\n  },\n\n  { key = 0xba735fcfa55378012e11a7a79f392f5f\n  , ciphertext = 0xb613b87085fed1bb87f07a574e6d2879\n  , plaintext = 0x5541d7bf6d25c55c0c2296acba756e9e\n  },\n\n  { key = 0xef328870c876bd5d2233310b254c41c1\n  , ciphertext = 0x5541d7bf6d25c55c0c2296acba756e9e\n  , plaintext = 0x4c138198d55d0d87d43cdb92fb0b5fc0\n  },\n\n  { key = 0xa32109e81d2bb0daf60fea99de471e01\n  , ciphertext = 0x4c138198d55d0d87d43cdb92fb0b5fc0\n  , plaintext = 0x257c07bdcba57aff1643de90b63c0a88\n  },\n\n  { key = 0x865d0e55d68eca25e04c3409687b1489\n  , ciphertext = 0x257c07bdcba57aff1643de90b63c0a88\n  , plaintext = 0x8039be4e65d218d3e640f88309d01c6f\n  },\n\n  { key = 0x0664b01bb35cd2f6060ccc8a61ab08e6\n  , ciphertext = 0x8039be4e65d218d3e640f88309d01c6f\n  , plaintext = 0x0115dcd390855bf5ce32e946a6d5ad38\n  },\n\n  { key = 0x07716cc823d98903c83e25ccc77ea5de\n  , ciphertext = 0x0115dcd390855bf5ce32e946a6d5ad38\n  , plaintext = 0x71741ccb723348c7f3f9e4a397977bdb\n  },\n\n  { key = 0x7605700351eac1c43bc7c16f50e9de05\n  , ciphertext = 0x71741ccb723348c7f3f9e4a397977bdb\n  , plaintext = 0x668c9f3dc9e154bd16d61364a99f635d\n  },\n\n  { key = 0x1089ef3e980b95792d11d20bf976bd58\n  , ciphertext = 0x668c9f3dc9e154bd16d61364a99f635d\n  , plaintext = 0x124b19b2501a540066ddf7943417cba3\n  },\n\n  { key = 0x02c2f68cc811c1794bcc259fcd6176fb\n  , ciphertext = 0x124b19b2501a540066ddf7943417cba3\n  , plaintext = 0x23e7c95f7ed9017af339c234b7a8fcc4\n  },\n\n  { key = 0x21253fd3b6c8c003b8f5e7ab7ac98a3f\n  , ciphertext = 0x23e7c95f7ed9017af339c234b7a8fcc4\n  , plaintext = 0x7b0e1e1afe46c1e50785efb939f8ade3\n  },\n\n  { key = 0x5a2b21c9488e01e6bf700812433127dc\n  , ciphertext = 0x7b0e1e1afe46c1e50785efb939f8ade3\n  , plaintext = 0xc166aeebf5182c96d1f3c92cece9d714\n  },\n\n  { key = 0x9b4d8f22bd962d706e83c13eafd8f0c8\n  , ciphertext = 0xc166aeebf5182c96d1f3c92cece9d714\n  , plaintext = 0x71968762dc1b41bebd9ee8b2396b87be\n  },\n\n  { key = 0xeadb0840618d6cced31d298c96b37776\n  , ciphertext = 0x71968762dc1b41bebd9ee8b2396b87be\n  , plaintext = 0x77b0aa88222a785282352bb861ea0cd2\n  },\n\n  { key = 0x9d6ba2c843a7149c51280234f7597ba4\n  , ciphertext = 0x77b0aa88222a785282352bb861ea0cd2\n  , plaintext = 0xe65c461cba6957fe5b5ee5014c899e65\n  },\n\n  { key = 0x7b37e4d4f9ce43620a76e735bbd0e5c1\n  , ciphertext = 0xe65c461cba6957fe5b5ee5014c899e65\n  , plaintext = 0xa799870cee001551f3494bdf3c27bd94\n  },\n\n  { key = 0xdcae63d817ce5633f93facea87f75855\n  , ciphertext = 0xa799870cee001551f3494bdf3c27bd94\n  , plaintext = 0xf54697576153f97d9fb1a4d164a8538e\n  },\n\n  { key = 0x29e8f48f769daf4e668e083be35f0bdb\n  , ciphertext = 0xf54697576153f97d9fb1a4d164a8538e\n  , plaintext = 0xf3f1f964b98b3498898c3032e44a308c\n  },\n\n  { key = 0xda190debcf169bd6ef02380907153b57\n  , ciphertext = 0xf3f1f964b98b3498898c3032e44a308c\n  , plaintext = 0x40ccc3a26141900280a3a7b62d4ed8b6\n  },\n\n  { key = 0x9ad5ce49ae570bd46fa19fbf2a5be3e1\n  , ciphertext = 0x40ccc3a26141900280a3a7b62d4ed8b6\n  , plaintext = 0x7fcf64bd75808be6199f3fac0881d4d4\n  },\n\n  { key = 0xe51aaaf4dbd78032763ea01322da3735\n  , ciphertext = 0x7fcf64bd75808be6199f3fac0881d4d4\n  , plaintext = 0x11ca970c169315ff0b54ecdb00ba4547\n  },\n\n  { key = 0xf4d03df8cd4495cd7d6a4cc822607272\n  , ciphertext = 0x11ca970c169315ff0b54ecdb00ba4547\n  , plaintext = 0xbc02615754b58eb975c26190a3583d28\n  },\n\n  { key = 0x48d25caf99f11b7408a82d5881384f5a\n  , ciphertext = 0xbc02615754b58eb975c26190a3583d28\n  , plaintext = 0x5b12925c7f72aaafbae6834a6e9d5af9\n  },\n\n  { key = 0x13c0cef3e683b1dbb24eae12efa515a3\n  , ciphertext = 0x5b12925c7f72aaafbae6834a6e9d5af9\n  , plaintext = 0x7950ffe2537235bfaa38101c2a9e6d42\n  },\n\n  { key = 0x6a903111b5f184641876be0ec53b78e1\n  , ciphertext = 0x7950ffe2537235bfaa38101c2a9e6d42\n  , plaintext = 0xcdf5c997d8ddcc1de7cc47ecc47d0819\n  },\n\n  { key = 0xa765f8866d2c4879ffbaf9e2014670f8\n  , ciphertext = 0xcdf5c997d8ddcc1de7cc47ecc47d0819\n  , plaintext = 0x8f4d77bccc4858016b28c2e8f84dd9a3\n  },\n\n  { key = 0x28288f3aa164107894923b0af90ba95b\n  , ciphertext = 0x8f4d77bccc4858016b28c2e8f84dd9a3\n  , plaintext = 0x561d95847869cccc81df7df65d70808d\n  },\n\n  { key = 0x7e351abed90ddcb4154d46fca47b29d6\n  , ciphertext = 0x561d95847869cccc81df7df65d70808d\n  , plaintext = 0x17b9e6f86ec1cff22cc6f8e14072bb0f\n  },\n\n  { key = 0x698cfc46b7cc1346398bbe1de40992d9\n  , ciphertext = 0x17b9e6f86ec1cff22cc6f8e14072bb0f\n  , plaintext = 0x8f959f24fae93418c2262ec73c6c8e1d\n  },\n\n  { key = 0xe61963624d25275efbad90dad8651cc4\n  , ciphertext = 0x8f959f24fae93418c2262ec73c6c8e1d\n  , plaintext = 0x2876f3a90b7a60168869d9de1e455836\n  },\n\n  { key = 0xce6f90cb465f474873c44904c62044f2\n  , ciphertext = 0x2876f3a90b7a60168869d9de1e455836\n  , plaintext = 0x5c609c0acdf2e389f19b3e0657706c9c\n  },\n\n  { key = 0x920f0cc18bada4c1825f77029150286e\n  , ciphertext = 0x5c609c0acdf2e389f19b3e0657706c9c\n  , plaintext = 0x88f537f67481490d20b713ff48b079e5\n  },\n\n  { key = 0x1afa3b37ff2cedcca2e864fdd9e0518b\n  , ciphertext = 0x88f537f67481490d20b713ff48b079e5\n  , plaintext = 0x0b1878fc9406b6c5f2c0085e8c9e0dd9\n  },\n\n  { key = 0x11e243cb6b2a5b0950286ca3557e5c52\n  , ciphertext = 0x0b1878fc9406b6c5f2c0085e8c9e0dd9\n  , plaintext = 0x594b9df3bad040afa14e63298945068d\n  },\n\n  { key = 0x48a9de38d1fa1ba6f1660f8adc3b5adf\n  , ciphertext = 0x594b9df3bad040afa14e63298945068d\n  , plaintext = 0xfcf5ffafacc372e641b1520fe76d16c7\n  },\n\n  { key = 0xb45c21977d396940b0d75d853b564c18\n  , ciphertext = 0xfcf5ffafacc372e641b1520fe76d16c7\n  , plaintext = 0x67319b7ab394937244b93977ba06c1ee\n  },\n\n  { key = 0xd36dbaedceadfa32f46e64f281508df6\n  , ciphertext = 0x67319b7ab394937244b93977ba06c1ee\n  , plaintext = 0xd956a31188a667eea44c93582d6aed6f\n  },\n\n  { key = 0x0a3b19fc460b9ddc5022f7aaac3a6099\n  , ciphertext = 0xd956a31188a667eea44c93582d6aed6f\n  , plaintext = 0x04f18289308787f3d936dd2a45c49e22\n  },\n\n  { key = 0x0eca9b75768c1a2f89142a80e9fefebb\n  , ciphertext = 0x04f18289308787f3d936dd2a45c49e22\n  , plaintext = 0xc925df60f455b0e27852efcf9fddc3d0\n  },\n\n  { key = 0xc7ef441582d9aacdf146c54f76233d6b\n  , ciphertext = 0xc925df60f455b0e27852efcf9fddc3d0\n  , plaintext = 0x14c3bcf83483de973d975dbf249c505e\n  },\n\n  { key = 0xd32cf8edb65a745accd198f052bf6d35\n  , ciphertext = 0x14c3bcf83483de973d975dbf249c505e\n  , plaintext = 0xa5f3f4afd0d01b9f4999d27e6386e925\n  },\n\n  { key = 0x76df0c42668a6fc585484a8e31398410\n  , ciphertext = 0xa5f3f4afd0d01b9f4999d27e6386e925\n  , plaintext = 0xd94451374478c1bdb4b94eb6908a205e\n  },\n\n  { key = 0xaf9b5d7522f2ae7831f10438a1b3a44e\n  , ciphertext = 0xd94451374478c1bdb4b94eb6908a205e\n  , plaintext = 0x9f3c6ed40a32c89d4ee8d4b87c8298c7\n  },\n\n  { key = 0x30a733a128c066e57f19d080dd313c89\n  , ciphertext = 0x9f3c6ed40a32c89d4ee8d4b87c8298c7\n  , plaintext = 0x54aa57cf75650cf6b7ccbd7202469bf7\n  },\n\n  { key = 0x640d646e5da56a13c8d56df2df77a77e\n  , ciphertext = 0x54aa57cf75650cf6b7ccbd7202469bf7\n  , plaintext = 0x11bc0be20465848934c0fd7d7ced8bd1\n  },\n\n  { key = 0x75b16f8c59c0ee9afc15908fa39a2caf\n  , ciphertext = 0x11bc0be20465848934c0fd7d7ced8bd1\n  , plaintext = 0x69d48f1ca39977f1c05f8cabd5f7e4ac\n  },\n\n  { key = 0x1c65e090fa59996b3c4a1c24766dc803\n  , ciphertext = 0x69d48f1ca39977f1c05f8cabd5f7e4ac\n  , plaintext = 0x2e447e6121162382c182b3efb27b2d5a\n  },\n\n  { key = 0x32219ef1db4fbae9fdc8afcbc416e559\n  , ciphertext = 0x2e447e6121162382c182b3efb27b2d5a\n  , plaintext = 0x3d99d0dff0891c38bec01551b4040e55\n  },\n\n  { key = 0x0fb84e2e2bc6a6d14308ba9a7012eb0c\n  , ciphertext = 0x3d99d0dff0891c38bec01551b4040e55\n  , plaintext = 0x92294ba363ed5b750c066cb6708620ee\n  },\n\n  { key = 0x9d91058d482bfda44f0ed62c0094cbe2\n  , ciphertext = 0x92294ba363ed5b750c066cb6708620ee\n  , plaintext = 0xcb674decffaae472d3d0710935b02aae\n  },\n\n  { key = 0x56f64861b78119d69cdea7253524e14c\n  , ciphertext = 0xcb674decffaae472d3d0710935b02aae\n  , plaintext = 0x47cd6a4b2f9b3d610d2bd3fe39feec91\n  },\n\n  { key = 0x113b222a981a24b791f574db0cda0ddd\n  , ciphertext = 0x47cd6a4b2f9b3d610d2bd3fe39feec91\n  , plaintext = 0x65b0b926a5b5b67f6895af42441f106b\n  },\n\n  { key = 0x748b9b0c3daf92c8f960db9948c51db6\n  , ciphertext = 0x65b0b926a5b5b67f6895af42441f106b\n  , plaintext = 0x3642fd59024efb3dc4e5bb268dd9de04\n  },\n\n  { key = 0x42c966553fe169f53d8560bfc51cc3b2\n  , ciphertext = 0x3642fd59024efb3dc4e5bb268dd9de04\n  , plaintext = 0x4e5d32a0e40dd9b830af0c2904518906\n  },\n\n  { key = 0x0c9454f5dbecb04d0d2a6c96c14d4ab4\n  , ciphertext = 0x4e5d32a0e40dd9b830af0c2904518906\n  , plaintext = 0x40a7ff6a6d0ea135245d5b24a0004466\n  },\n\n  { key = 0x4c33ab9fb6e21178297737b2614d0ed2\n  , ciphertext = 0x40a7ff6a6d0ea135245d5b24a0004466\n  , plaintext = 0xb18e6d37f5292acd1eaeee742930952a\n  },\n\n  { key = 0xfdbdc6a843cb3bb537d9d9c6487d9bf8\n  , ciphertext = 0xb18e6d37f5292acd1eaeee742930952a\n  , plaintext = 0x42df9c23bfbc90b787c5cb0dc08e80dc\n  },\n\n  { key = 0xbf625a8bfc77ab02b01c12cb88f31b24\n  , ciphertext = 0x42df9c23bfbc90b787c5cb0dc08e80dc\n  , plaintext = 0x589af99abbba45318106d2c1ca7b82b0\n  },\n\n  { key = 0xe7f8a31147cdee33311ac00a42889994\n  , ciphertext = 0x589af99abbba45318106d2c1ca7b82b0\n  , plaintext = 0x96f54a5bacec995c0263226cd443f2c6\n  },\n\n  { key = 0x710de94aeb21776f3379e26696cb6b52\n  , ciphertext = 0x96f54a5bacec995c0263226cd443f2c6\n  , plaintext = 0x84e07ce717c747cb924e42cdf6ec6524\n  },\n\n  { key = 0xf5ed95adfce630a4a137a0ab60270e76\n  , ciphertext = 0x84e07ce717c747cb924e42cdf6ec6524\n  , plaintext = 0x5140a66d02867ddfa8bb014f75d53b83\n  },\n\n  { key = 0xa4ad33c0fe604d7b098ca1e415f235f5\n  , ciphertext = 0x5140a66d02867ddfa8bb014f75d53b83\n  , plaintext = 0xa1570dc8605d7d68f0a2416aa2c3536a\n  },\n\n  { key = 0x05fa3e089e3d3013f92ee08eb731669f\n  , ciphertext = 0xa1570dc8605d7d68f0a2416aa2c3536a\n  , plaintext = 0x96ab8bd9091a703a6e6d1a2190f0b5c9\n  },\n\n  { key = 0x9351b5d1972740299743faaf27c1d356\n  , ciphertext = 0x96ab8bd9091a703a6e6d1a2190f0b5c9\n  , plaintext = 0x8418c2cec9d7cc3825152790f120488f\n  },\n\n  { key = 0x1749771f5ef08c11b256dd3fd6e19bd9\n  , ciphertext = 0x8418c2cec9d7cc3825152790f120488f\n  , plaintext = 0x7973673755c8201ec52bdec30a86191f\n  },\n\n  { key = 0x6e3a10280b38ac0f777d03fcdc6782c6\n  , ciphertext = 0x7973673755c8201ec52bdec30a86191f\n  , plaintext = 0x2a92ba991755f3c6ad1ef58681ac3a12\n  },\n\n  { key = 0x44a8aab11c6d5fc9da63f67a5dcbb8d4\n  , ciphertext = 0x2a92ba991755f3c6ad1ef58681ac3a12\n  , plaintext = 0xe3daa0cfe79594311762ca0d39985da2\n  },\n\n  { key = 0xa7720a7efbf8cbf8cd013c776453e576\n  , ciphertext = 0xe3daa0cfe79594311762ca0d39985da2\n  , plaintext = 0x5c2ea8b0b4bd7b50b48abd7df8e716f2\n  },\n\n  { key = 0xfb5ca2ce4f45b0a8798b810a9cb4f384\n  , ciphertext = 0x5c2ea8b0b4bd7b50b48abd7df8e716f2\n  , plaintext = 0xf15e39a11ed397378b6de3d62bde10c2\n  },\n\n  { key = 0x0a029b6f5196279ff2e662dcb76ae346\n  , ciphertext = 0xf15e39a11ed397378b6de3d62bde10c2\n  , plaintext = 0xd16879ee2fe2c07703e7eba3e093e911\n  },\n\n  { key = 0xdb6ae2817e74e7e8f101897f57f90a57\n  , ciphertext = 0xd16879ee2fe2c07703e7eba3e093e911\n  , plaintext = 0x57aac9d12da681f1ef4fc3d07269e159\n  },\n\n  { key = 0x8cc02b5053d266191e4e4aaf2590eb0e\n  , ciphertext = 0x57aac9d12da681f1ef4fc3d07269e159\n  , plaintext = 0xf6472d8a7d288db2262d826ff2f806ee\n  },\n\n  { key = 0x7a8706da2efaebab3863c8c0d768ede0\n  , ciphertext = 0xf6472d8a7d288db2262d826ff2f806ee\n  , plaintext = 0xd3ec20ae3257192d51f2ce4e73f87e53\n  },\n\n  { key = 0xa96b26741cadf2866991068ea49093b3\n  , ciphertext = 0xd3ec20ae3257192d51f2ce4e73f87e53\n  , plaintext = 0xd99891b245282641fb9e91681fce7ee1\n  },\n\n  { key = 0x70f3b7c65985d4c7920f97e6bb5eed52\n  , ciphertext = 0xd99891b245282641fb9e91681fce7ee1\n  , plaintext = 0x8f2fa0031baacb388ed7da3e7fd62828\n  },\n\n  { key = 0xffdc17c5422f1fff1cd84dd8c488c57a\n  , ciphertext = 0x8f2fa0031baacb388ed7da3e7fd62828\n  , plaintext = 0x80bed13ad5aebb0783629b03af2f6897\n  },\n\n  { key = 0x7f62c6ff9781a4f89fbad6db6ba7aded\n  , ciphertext = 0x80bed13ad5aebb0783629b03af2f6897\n  , plaintext = 0xfac43dfa16d393580f130b8a955339a6\n  },\n\n  { key = 0x85a6fb05815237a090a9dd51fef4944b\n  , ciphertext = 0xfac43dfa16d393580f130b8a955339a6\n  , plaintext = 0x60aa3f3683346b09466f1c4c11b376f5\n  },\n\n  { key = 0xe50cc43302665ca9d6c6c11def47e2be\n  , ciphertext = 0x60aa3f3683346b09466f1c4c11b376f5\n  , plaintext = 0xe93ac158da113797bce2472240c4d7bb\n  },\n\n  { key = 0x0c36056bd8776b3e6a24863faf833505\n  , ciphertext = 0xe93ac158da113797bce2472240c4d7bb\n  , plaintext = 0xe96e8432e2eea1de7e0cceadfe5e1623\n  },\n\n  { key = 0xe55881593a99cae01428489251dd2326\n  , ciphertext = 0xe96e8432e2eea1de7e0cceadfe5e1623\n  , plaintext = 0xd99630cb34f06a3a02e9803a029980a2\n  },\n\n  { key = 0x3cceb1920e69a0da16c1c8a85344a384\n  , ciphertext = 0xd99630cb34f06a3a02e9803a029980a2\n  , plaintext = 0xe5a14b334430768edf5dd7863ee30678\n  },\n\n  { key = 0xd96ffaa14a59d654c99c1f2e6da7a5fc\n  , ciphertext = 0xe5a14b334430768edf5dd7863ee30678\n  , plaintext = 0x49dab0bc5fb8c387ea9c557d3a35e659\n  },\n\n  { key = 0x90b54a1d15e115d323004a53579243a5\n  , ciphertext = 0x49dab0bc5fb8c387ea9c557d3a35e659\n  , plaintext = 0x6867e956763a7377a15a4248ab91c829\n  },\n\n  { key = 0xf8d2a34b63db66a4825a081bfc038b8c\n  , ciphertext = 0x6867e956763a7377a15a4248ab91c829\n  , plaintext = 0x4f536383ba4e258dd3ab764027a66e39\n  },\n\n  { key = 0xb781c0c8d995432951f17e5bdba5e5b5\n  , ciphertext = 0x4f536383ba4e258dd3ab764027a66e39\n  , plaintext = 0xe9b6abc089286834eb9421e71fe98517\n  },\n\n  { key = 0x5e376b0850bd2b1dba655fbcc44c60a2\n  , ciphertext = 0xe9b6abc089286834eb9421e71fe98517\n  , plaintext = 0x256121dead70e6675ad631dd0527fb1a\n  },\n\n  { key = 0x7b564ad6fdcdcd7ae0b36e61c16b9bb8\n  , ciphertext = 0x256121dead70e6675ad631dd0527fb1a\n  , plaintext = 0x6bdbcc94ec6497445e4024acb601741b\n  },\n\n  { key = 0x108d864211a95a3ebef34acd776aefa3\n  , ciphertext = 0x6bdbcc94ec6497445e4024acb601741b\n  , plaintext = 0x44e86f9d48c6699554a3538eb6f55479\n  },\n\n  { key = 0x5465e9df596f33abea501943c19fbbda\n  , ciphertext = 0x44e86f9d48c6699554a3538eb6f55479\n  , plaintext = 0xc7c622fee00a180f3131a57a82acf7a9\n  },\n\n  { key = 0x93a3cb21b9652ba4db61bc3943334c73\n  , ciphertext = 0xc7c622fee00a180f3131a57a82acf7a9\n  , plaintext = 0xe096b0406e6e8abb6ced353f1be40693\n  },\n\n  { key = 0x73357b61d70ba11fb78c890658d74ae0\n  , ciphertext = 0xe096b0406e6e8abb6ced353f1be40693\n  , plaintext = 0x73326251dbd89c23b37caee2ee6d2d9e\n  },\n\n  { key = 0x000719300cd33d3c04f027e4b6ba677e\n  , ciphertext = 0x73326251dbd89c23b37caee2ee6d2d9e\n  , plaintext = 0x7b2c687d460054af03709645056407c6\n  },\n\n  { key = 0x7b2b714d4ad369930780b1a1b3de60b8\n  , ciphertext = 0x7b2c687d460054af03709645056407c6\n  , plaintext = 0x8bb9f381438145a96714e238a8864e0b\n  },\n\n  { key = 0xf09282cc09522c3a609453991b582eb3\n  , ciphertext = 0x8bb9f381438145a96714e238a8864e0b\n  , plaintext = 0xd59509d08bcfc30e20344b1c4c53f726\n  },\n\n  { key = 0x25078b1c829def3440a01885570bd995\n  , ciphertext = 0xd59509d08bcfc30e20344b1c4c53f726\n  , plaintext = 0x02e6077d01a352637899d6ce626782ac\n  },\n\n  { key = 0x27e18c61833ebd573839ce4b356c5b39\n  , ciphertext = 0x02e6077d01a352637899d6ce626782ac\n  , plaintext = 0xed01d9601145c11662986b0827e403ec\n  },\n\n  { key = 0xcae05501927b7c415aa1a543128858d5\n  , ciphertext = 0xed01d9601145c11662986b0827e403ec\n  , plaintext = 0x7d5b1ca06884b5a55e9035fe7d77d4a7\n  },\n\n  { key = 0xb7bb49a1faffc9e4043190bd6fff8c72\n  , ciphertext = 0x7d5b1ca06884b5a55e9035fe7d77d4a7\n  , plaintext = 0x1a23d371b97e1056e8bc9545c56cab9e\n  },\n\n  { key = 0xad989ad04381d9b2ec8d05f8aa9327ec\n  , ciphertext = 0x1a23d371b97e1056e8bc9545c56cab9e\n  , plaintext = 0xd1d2bfdc58ffcad2341b095bce55221e\n  }]\n\nmct_ecb_encrypt_192 : [192] -> [128] -> [100](AESTestVector 192)\nmct_ecb_encrypt_192 initialKey initialPt = vs\n  where\n  vs@i = { key = keys@i, plaintext=pts@(i*1000), ciphertext=cts@(i*1000 + 999) }\n\n  pts : [100*1000][128]\n  pts = [initialPt] # take cts\n\n  cts : [100*1000][128]\n  cts@i = aesEncryptBlock (schedules@(i\/1000)) (pts@i)\n\n  keys : [100][192]\n  keys = [initialKey] # [ k ^ ((drop`{64} (xs!1)) # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} cts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESEncryptKeySchedule AES192)\n  schedules = map aes192EncryptSchedule keys\n\nmct_ecb_decrypt_192 : [192] -> [128] -> [100](AESTestVector 192)\nmct_ecb_decrypt_192 initialKey initialCt = vs\n  where\n  vs@i = { key = keys@i, ciphertext=cts@(i*1000), plaintext=pts@(i*1000 + 999) }\n\n  cts : [100*1000][128]\n  cts = [initialCt] # take pts\n\n  pts : [100*1000][128]\n  pts@i = aesDecryptBlock (schedules@(i\/1000)) (cts@i)\n\n  keys : [100][192]\n  keys = [initialKey] # [ k ^ ((drop`{64} (xs!1)) # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} pts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESDecryptKeySchedule AES192)\n  schedules = map aes192DecryptSchedule keys\n\nmct_ecb_encrypt_256 : [256] -> [128] -> [100](AESTestVector 256)\nmct_ecb_encrypt_256 initialKey initialPt = vs\n  where\n  vs@i = { key = keys@i, plaintext=pts@(i*1000), ciphertext=cts@(i*1000 + 999) }\n\n  pts : [100*1000][128]\n  pts = [initialPt] # take cts\n\n  cts : [100*1000][128]\n  cts@i = aesEncryptBlock (schedules@(i\/1000)) (pts@i)\n\n  keys : [100][256]\n  keys = [initialKey] # [ k ^ (xs!1 # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} cts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESEncryptKeySchedule AES256)\n  schedules = map aes256EncryptSchedule keys\n\nmct_ecb_decrypt_256 : [256] -> [128] -> [100](AESTestVector 256)\nmct_ecb_decrypt_256 initialKey initialCt = vs\n  where\n  vs@i = { key = keys@i, ciphertext=cts@(i*1000), plaintext=pts@(i*1000 + 999) }\n\n  cts : [100*1000][128]\n  cts = [initialCt] # take pts\n\n  pts : [100*1000][128]\n  pts@i = aesDecryptBlock (schedules@(i\/1000)) (cts@i)\n\n  keys : [100][256]\n  keys = [initialKey] # [ k ^ (xs!1 # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} pts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESDecryptKeySchedule AES256)\n  schedules = map aes256DecryptSchedule keys\n\nproperty aes192_MCT_vectors_encrypt_correct =\n aes192_MCT_encrypt_test_vectors ==\n mct_ecb_encrypt_192\n   0xb9a63e09e1dfc42e93a90d9bad739e5967aef672eedd5da9 \n   0x85a1f7a58167b389cddc8a9ff175ee26\n\nproperty aes192_MCT_vectors_decrypt_correct =\n aes192_MCT_decrypt_test_vectors ==\n mct_ecb_decrypt_192\n   0x4b97585701c03fbebdfa8555024f589f1482c58a00fdd9fd\n   0xd0bd0e02ded155e4516be83f42d347a4\n\naes192_MCT_encrypt_test_vectors : [100](AESTestVector 192)\naes192_MCT_encrypt_test_vectors =\n  [{ key = 0xb9a63e09e1dfc42e93a90d9bad739e5967aef672eedd5da9\n  , plaintext = 0x85a1f7a58167b389cddc8a9ff175ee26\n  , ciphertext = 0xee83d85279e022d2048031abeefbc4a4\n  },\n\n  { key = 0x3aaa458160ee54c97d2ad5c9d493bc8b632ec7d90026990d\n  , plaintext = 0xee83d85279e022d2048031abeefbc4a4\n  , ciphertext = 0xa8f99517b4bd14a16c26bae901417498\n  },\n\n  { key = 0x1d17d1bcc74a8584d5d340de602ea82a0f087d300167ed95\n  , plaintext = 0xa8f99517b4bd14a16c26bae901417498\n  , ciphertext = 0x80286e71937334fd6e90c706abbaf0ff\n  },\n\n  { key = 0xc0025cd0eb1f23c055fb2eaff35d9cd76198ba36aadd1d6a\n  , plaintext = 0x80286e71937334fd6e90c706abbaf0ff\n  , ciphertext = 0xc8b8c153bcb231e9424d65f37bff75b8\n  },\n\n  { key = 0xafb45c1097553d589d43effc4fefad3e23d5dfc5d12268d2\n  , plaintext = 0xc8b8c153bcb231e9424d65f37bff75b8\n  , ciphertext = 0x8108fbfde1cff0d94b88b1073114c657\n  },\n\n  { key = 0x8b81e2418f676a5b1c4b1401ae205de7685d6ec2e036ae85\n  , plaintext = 0x8108fbfde1cff0d94b88b1073114c657\n  , ciphertext = 0x79af44f2490efc90d217af55dd10fd2e\n  },\n\n  { key = 0x43463bbf9528c3bc65e450f3e72ea177ba4ac1973d2653ab\n  , plaintext = 0x79af44f2490efc90d217af55dd10fd2e\n  , ciphertext = 0xd0c2da3860c367e1fd68cf04bb6b41cd\n  },\n\n  { key = 0x0e3efca8ca3fd45bb5268acb87edc69647220e93864d1266\n  , plaintext = 0xd0c2da3860c367e1fd68cf04bb6b41cd\n  , ciphertext = 0xe5d39a5d7ca8c4f4aafd3d851c40c016\n  },\n\n  { key = 0x2908445968d0a18f50f51096fb450262eddf33169a0dd270\n  , plaintext = 0xe5d39a5d7ca8c4f4aafd3d851c40c016\n  , ciphertext = 0x98657051b23c69741b2ab506f818fd3f\n  },\n\n  { key = 0x00feb8bffd6b4bcbc89060c749796b16f6f5861062152f4f\n  , plaintext = 0x98657051b23c69741b2ab506f818fd3f\n  , ciphertext = 0xc9b6e95fb54b540adc1faa8cece00286\n  },\n\n  { key = 0xbe96e16fffe0a2db01268998fc323f1c2aea2c9c8ef52dc9\n  , plaintext = 0xc9b6e95fb54b540adc1faa8cece00286\n  , ciphertext = 0x5cf9f61a3dd3a2f76d571384c831ae88\n  },\n\n  { key = 0x41baf817490bf49c5ddf7f82c1e19deb47bd3f1846c48341\n  , plaintext = 0x5cf9f61a3dd3a2f76d571384c831ae88\n  , ciphertext = 0xdc6e6c13679958963b8648457eb8a415\n  },\n\n  { key = 0xa4afa1ac957b31fe81b11391a678c57d7c3b775d387c2754\n  , plaintext = 0xdc6e6c13679958963b8648457eb8a415\n  , ciphertext = 0x033f2b7189ec7f2ef0c496a83f5c5051\n  },\n\n  { key = 0x6a5b44860a26a4ff828e38e02f94ba538cffe1f507207705\n  , plaintext = 0x033f2b7189ec7f2ef0c496a83f5c5051\n  , ciphertext = 0x032727204d9b169679eff2ffe5f71efb\n  },\n\n  { key = 0xc80d5ebc48693fdc81a91fc0620facc5f510130ae2d769fe\n  , plaintext = 0x032727204d9b169679eff2ffe5f71efb\n  , ciphertext = 0xd19884aaae710c5861fff7251ea143c8\n  },\n\n  { key = 0xb9d36290d5324a8350319b6acc7ea09d94efe42ffc762a36\n  , plaintext = 0xd19884aaae710c5861fff7251ea143c8\n  , ciphertext = 0x3097d32245163fcf4c578e5a7dd2349a\n  },\n\n  { key = 0x3d00403bc3a0ff5b60a6484889689f52d8b86a7581a41eac\n  , plaintext = 0x3097d32245163fcf4c578e5a7dd2349a\n  , ciphertext = 0x39b6615b1e047b9469b3cfd7251987c9\n  },\n\n  { key = 0xbb85f657f0d5241659102913976ce4c6b10ba5a2a4bd9965\n  , plaintext = 0x39b6615b1e047b9469b3cfd7251987c9\n  , ciphertext = 0x868194c44a68d8b48e0ed4dbacded128\n  },\n\n  { key = 0x7db3635bf7d52f66df91bdd7dd043c723f0571790863484d\n  , plaintext = 0x868194c44a68d8b48e0ed4dbacded128\n  , ciphertext = 0xd324fd7db1cfaa86511280dafa5340e6\n  },\n\n  { key = 0x1449e32d51b3680f0cb540aa6ccb96f46e17f1a3f23008ab\n  , plaintext = 0xd324fd7db1cfaa86511280dafa5340e6\n  , ciphertext = 0x409aa25dcb51d8831a2f5627746c2bc9\n  },\n\n  { key = 0x63d4b33e24bf3f7c4c2fe2f7a79a4e777438a784865c2362\n  , plaintext = 0x409aa25dcb51d8831a2f5627746c2bc9\n  , ciphertext = 0xbfa0348398b9bc4e07eb1739c589b225\n  },\n\n  { key = 0x03f21169aad21af3f38fd6743f23f23973d3b0bd43d59147\n  , plaintext = 0xbfa0348398b9bc4e07eb1739c589b225\n  , ciphertext = 0x13582b4881e6b7f6398f41b57d617201\n  },\n\n  { key = 0x541879f8770ad35de0d7fd3cbec545cf4a5cf1083eb4e346\n  , plaintext = 0x13582b4881e6b7f6398f41b57d617201\n  , ciphertext = 0xd9d58082c3a976852a350ba551862362\n  },\n\n  { key = 0xd0c6100d7f8fdd8739027dbe7d6c334a6069faad6f32c024\n  , plaintext = 0xd9d58082c3a976852a350ba551862362\n  , ciphertext = 0x3cafa17506a92359c23600404ad61513\n  },\n\n  { key = 0x05345651ac0d23b305addccb7bc51013a25ffaed25e4d537\n  , plaintext = 0x3cafa17506a92359c23600404ad61513\n  , ciphertext = 0xa4a3041803fe9bf7d355b34d21293ecf\n  },\n\n  { key = 0x4ce9e1102ccba488a10ed8d3783b8be4710a49a004cdebf8\n  , plaintext = 0xa4a3041803fe9bf7d355b34d21293ecf\n  , ciphertext = 0xcfa674aba22c17036da437832c635b30\n  },\n\n  { key = 0x08fed0e9350ac7386ea8ac78da179ce71cae7e2328aeb0c8\n  , plaintext = 0xcfa674aba22c17036da437832c635b30\n  , ciphertext = 0xf4de164a6ca93e96dfc91426d636e481\n  },\n\n  { key = 0xcc5643ba704f961c9a76ba32b6bea271c3676a05fe985449\n  , plaintext = 0xf4de164a6ca93e96dfc91426d636e481\n  , ciphertext = 0x1deb553ac91ec346201154dbbdac9b14\n  },\n\n  { key = 0xd413a379439b2caf879def087fa06137e3763ede4334cf5d\n  , plaintext = 0x1deb553ac91ec346201154dbbdac9b14\n  , ciphertext = 0x52372415208849a222acf6f27e145f75\n  },\n\n  { key = 0x575a3e57736fe96dd5aacb1d5f282895c1dac82c3d209028\n  , plaintext = 0x52372415208849a222acf6f27e145f75\n  , ciphertext = 0x710f708e402325c6763ca461f6f855e0\n  },\n\n  { key = 0x7d593f399f198b9da4a5bb931f0b0d53b7e66c4dcbd8c5c8\n  , plaintext = 0x710f708e402325c6763ca461f6f855e0\n  , ciphertext = 0x8fae56699e3af53b86d484be2463b602\n  },\n\n  { key = 0x401e3d459d7254a82b0bedfa8131f8683132e8f3efbb73ca\n  , plaintext = 0x8fae56699e3af53b86d484be2463b602\n  , ciphertext = 0xaa44678efb43326727d5204edc942fe2\n  },\n\n  { key = 0x996d36de694dc3cb814f8a747a72ca0f16e7c8bd332f5c28\n  , plaintext = 0xaa44678efb43326727d5204edc942fe2\n  , ciphertext = 0xfb04caba312e387528a355d39db15db6\n  },\n\n  { key = 0xbba2ddbf7cc063957a4b40ce4b5cf27a3e449d6eae9e019e\n  , plaintext = 0xfb04caba312e387528a355d39db15db6\n  , ciphertext = 0x5d8156335210cc39885ab652d8ccfd33\n  },\n\n  { key = 0x5fdbf5f7b3b389c727ca16fd194c3e43b61e2b3c7652fcad\n  , plaintext = 0x5d8156335210cc39885ab652d8ccfd33\n  , ciphertext = 0x8b8d3455188ad9615a2c3a34c4bfb8df\n  },\n\n  { key = 0xfa876ec64e22b16bac4722a801c6e722ec321108b2ed4472\n  , plaintext = 0x8b8d3455188ad9615a2c3a34c4bfb8df\n  , ciphertext = 0x1c5bab7b91032ffac3a8e4d41a3a5338\n  },\n\n  { key = 0xceeda64221ae37d3b01c89d390c5c8d82f9af5dca8d7174a\n  , plaintext = 0x1c5bab7b91032ffac3a8e4d41a3a5338\n  , ciphertext = 0xad98def9c24e9d0de0e6a9541c86c34c\n  },\n\n  { key = 0xb2b6b9074795f6501d84572a528b55d5cf7c5c88b451d406\n  , plaintext = 0xad98def9c24e9d0de0e6a9541c86c34c\n  , ciphertext = 0xee54a410d2e410e721bf9b12f9a8bb04\n  },\n\n  { key = 0x42e6927395e5d3dbf3d0f33a806f4532eec3c79a4df96f02\n  , plaintext = 0xee54a410d2e410e721bf9b12f9a8bb04\n  , ciphertext = 0x7b894a4e5514249029af1118576093cc\n  },\n\n  { key = 0x07373c871002daaf8859b974d57b61a2c76cd6821a99fcce\n  , plaintext = 0x7b894a4e5514249029af1118576093cc\n  , ciphertext = 0xf555d93e38137c9b931b4583de367ff2\n  },\n\n  { key = 0x8eebc322f66630687d0c604aed681d3954779301c4af833c\n  , plaintext = 0xf555d93e38137c9b931b4583de367ff2\n  , ciphertext = 0xf5adbb37c99646913d1670ccd8203c04\n  },\n\n  { key = 0x56d70f07f90e11ab88a1db7d24fe5ba86961e3cd1c8fbf38\n  , plaintext = 0xf5adbb37c99646913d1670ccd8203c04\n  , ciphertext = 0x122f214900ffcfd59652c1af64b10c71\n  },\n\n  { key = 0xcf4ec9b7f52cd2d99a8efa342401947dff332262783eb349\n  , plaintext = 0x122f214900ffcfd59652c1af64b10c71\n  , ciphertext = 0xbe1b5d5ac7b61b73c479d7b1fc65ea35\n  },\n\n  { key = 0x8ca5b0fe1053b3982495a76ee3b78f0e3b4af5d3845b597c\n  , plaintext = 0xbe1b5d5ac7b61b73c479d7b1fc65ea35\n  , ciphertext = 0xf9868b44c1ce21b040b8fff3716b011a\n  },\n\n  { key = 0x34f2ce0dbb3fa2d2dd132c2a2279aebe7bf20a20f5305866\n  , plaintext = 0xf9868b44c1ce21b040b8fff3716b011a\n  , ciphertext = 0x9cac4efb170dc8ded3fc6a309fd7aca7\n  },\n\n  { key = 0x603bbb7bf54b365d41bf62d135746660a80e60106ae7f4c1\n  , plaintext = 0x9cac4efb170dc8ded3fc6a309fd7aca7\n  , ciphertext = 0xe52a42e78048c6dda63f98fc6c5f47f9\n  },\n\n  { key = 0xa146ac000cb1f14ba4952036b53ca0bd0e31f8ec06b8b338\n  , plaintext = 0xe52a42e78048c6dda63f98fc6c5f47f9\n  , ciphertext = 0x826af473c60d61bd746a8d8bda3b410c\n  },\n\n  { key = 0x979e0246f75d08e226ffd4457331c1007a5b7567dc83f234\n  , plaintext = 0x826af473c60d61bd746a8d8bda3b410c\n  , ciphertext = 0x9fa4ebdccace9033a56e3a5aace74dba\n  },\n\n  { key = 0x3c34cf05821c9d17b95b3f99b9ff5133df354f3d7064bf8e\n  , plaintext = 0x9fa4ebdccace9033a56e3a5aace74dba\n  , ciphertext = 0xe0ac5dee9d6247d50b379589c2415444\n  },\n\n  { key = 0x3e42ac26f6c0977a59f76277249d16e6d402dab4b225ebca\n  , plaintext = 0xe0ac5dee9d6247d50b379589c2415444\n  , ciphertext = 0x462562da72ea6b5c371530c716879dcd\n  },\n\n  { key = 0xed7edff15890f7841fd200ad56777dbae317ea73a4a27607\n  , plaintext = 0x462562da72ea6b5c371530c716879dcd\n  , ciphertext = 0x78a040009e18ef207253ef992e7e2c91\n  },\n\n  { key = 0x4140882041912162677240adc86f929a914405ea8adc5a96\n  , plaintext = 0x78a040009e18ef207253ef992e7e2c91\n  , ciphertext = 0xf8c7a79f10c92ec49e1ec59b08498d64\n  },\n\n  { key = 0x2cbc00f60f66695a9fb5e732d8a6bc5e0f5ac0718295d7f2\n  , plaintext = 0xf8c7a79f10c92ec49e1ec59b08498d64\n  , ciphertext = 0x2f9a5f2cfd515a6878ecd923c36b1b4e\n  },\n\n  { key = 0xce9854aa7b6e184ab02fb81e25f7e63677b6195241feccbc\n  , plaintext = 0x2f9a5f2cfd515a6878ecd923c36b1b4e\n  , ciphertext = 0xf7d3b3758ecf5359ab523beaa17a0306\n  },\n\n  { key = 0x93163ae28f22570b47fc0b6bab38b56fdce422b8e084cfba\n  , plaintext = 0xf7d3b3758ecf5359ab523beaa17a0306\n  , ciphertext = 0x6c9dd076750bd1d2c0b8f203ca14ee1e\n  },\n\n  { key = 0xca2a7882db1cb3b52b61db1dde3364bd1c5cd0bb2a9021a4\n  , plaintext = 0x6c9dd076750bd1d2c0b8f203ca14ee1e\n  , ciphertext = 0x289cf1ab3b9eac26cdd02df244412d4e\n  },\n\n  { key = 0x90dc3a02ba5b5f2b03fd2ab6e5adc89bd18cfd496ed10cea\n  , plaintext = 0x289cf1ab3b9eac26cdd02df244412d4e\n  , ciphertext = 0x8ee4ca3c6c9cc5f27ddb79ae7cfcc47e\n  },\n\n  { key = 0x11b26d4f3eb77d218d19e08a89310d69ac5784e7122dc894\n  , plaintext = 0x8ee4ca3c6c9cc5f27ddb79ae7cfcc47e\n  , ciphertext = 0x6cbf94fcdcadfd9a39d4c4f702d7b101\n  },\n\n  { key = 0x7159cd8684c28039e1a67476559cf0f39583401010fa7995\n  , plaintext = 0x6cbf94fcdcadfd9a39d4c4f702d7b101\n  , ciphertext = 0x5047270db233f75e84c734b5cb56f765\n  },\n\n  { key = 0x76bbdc75f530ec0ab1e1537be7af07ad114474a5dbac8ef0\n  , plaintext = 0x5047270db233f75e84c734b5cb56f765\n  , ciphertext = 0xb82602cd22e7821be62e5ff67cb193c6\n  },\n\n  { key = 0x306a4720867eca7009c751b6c54885b6f76a2b53a71d1d36\n  , plaintext = 0xb82602cd22e7821be62e5ff67cb193c6\n  , ciphertext = 0x5a241fbcb4a0f769c37408abe658da25\n  },\n\n  { key = 0x306323bbf53bd84f53e34e0a71e872df341e23f84145c713\n  , plaintext = 0x5a241fbcb4a0f769c37408abe658da25\n  , ciphertext = 0x9a63d956a9c719465e30cdc160991042\n  },\n\n  { key = 0x897b6f11ecb97862c980975cd82f6b996a2eee3921dcd751\n  , plaintext = 0x9a63d956a9c719465e30cdc160991042\n  , ciphertext = 0x2a733f407d8080470c5f22a6cf8358cd\n  },\n\n  { key = 0x14fa0e9978672ad5e3f3a81ca5afebde6671cc9fee5f8f9c\n  , plaintext = 0x2a733f407d8080470c5f22a6cf8358cd\n  , ciphertext = 0x24db9f77f61060accf6d41e7639c1ec6\n  },\n\n  { key = 0xc1125a27a85e3826c728376b53bf8b72a91c8d788dc3915a\n  , plaintext = 0x24db9f77f61060accf6d41e7639c1ec6\n  , ciphertext = 0xa89eccce6ee8c9d4d34cf5ba8b29cba7\n  },\n\n  { key = 0x1ce385ac9c70d4e26fb6fba53d5742a67a5078c206ea5afd\n  , plaintext = 0xa89eccce6ee8c9d4d34cf5ba8b29cba7\n  , ciphertext = 0xe4ef08e86141940ef87d6b385d19108c\n  },\n\n  { key = 0x9a3967a8ff01d35f8b59f34d5c16d6a8822d13fa5bf34a71\n  , plaintext = 0xe4ef08e86141940ef87d6b385d19108c\n  , ciphertext = 0x1039c441007d6805551a87e820c63dca\n  },\n\n  { key = 0x7d0af1cd0d641f209b60370c5c6bbeadd73794127b3577bb\n  , plaintext = 0x1039c441007d6805551a87e820c63dca\n  , ciphertext = 0x2584b55b214a94ee9894b104178a6dd5\n  },\n\n  { key = 0x3f78d295449908e6bee482577d212a434fa325166cbf1a6e\n  , plaintext = 0x2584b55b214a94ee9894b104178a6dd5\n  , ciphertext = 0x9d32bd6357551091ca659f7bd4509fc2\n  },\n\n  { key = 0x9cd28f265a13556123d63f342a743ad285c6ba6db8ef85ac\n  , plaintext = 0x9d32bd6357551091ca659f7bd4509fc2\n  , ciphertext = 0x9ac46eb8e253bb37304394ff0042d306\n  },\n\n  { key = 0x34caf580014164d4b912518cc82781e5b5852e92b8ad56aa\n  , plaintext = 0x9ac46eb8e253bb37304394ff0042d306\n  , ciphertext = 0x3b899f1f2d93e3890418763fdd35943a\n  },\n\n  { key = 0x7c19a50fa9360041829bce93e5b4626cb19d58ad6598c290\n  , plaintext = 0x3b899f1f2d93e3890418763fdd35943a\n  , ciphertext = 0xea89d4537784f253eae2d6cebdd63a4c\n  },\n\n  { key = 0x2109b2880479bb4f68121ac09230903f5b7f8e63d84ef8dc\n  , plaintext = 0xea89d4537784f253eae2d6cebdd63a4c\n  , ciphertext = 0x80711a42f6687a62590a8a0d165b2fb8\n  },\n\n  { key = 0x83fe682b1fcdb57be86300826458ea5d0275046ece15d764\n  , plaintext = 0x80711a42f6687a62590a8a0d165b2fb8\n  , ciphertext = 0xb2174ffab755e3e0c666cecb075256ec\n  },\n\n  { key = 0x63434f6c69c041735a744f78d30d09bdc413caa5c9478188\n  , plaintext = 0xb2174ffab755e3e0c666cecb075256ec\n  , ciphertext = 0x57120386bd566d31807a6fe7b0e78041\n  },\n\n  { key = 0xdfa4b3f99eda96420d664cfe6e5b648c4469a54279a001c9\n  , plaintext = 0x57120386bd566d31807a6fe7b0e78041\n  , ciphertext = 0x3b128fcdb7bb4252b5e5e00df5629508\n  },\n\n  { key = 0x24fa37bb6d70bd943674c333d9e026def18c454f8cc294c1\n  , plaintext = 0x3b128fcdb7bb4252b5e5e00df5629508\n  , ciphertext = 0x4826cf69d83c7f475230679b61ca8e0a\n  },\n\n  { key = 0x246a7408f739d1d37e520c5a01dc5999a3bc22d4ed081acb\n  , plaintext = 0x4826cf69d83c7f475230679b61ca8e0a\n  , ciphertext = 0x25a23c7fb798a50f5929e90e743da11c\n  },\n\n  { key = 0x9f1827be83518dbc5bf03025b644fc96fa95cbda9935bbd7\n  , plaintext = 0x25a23c7fb798a50f5929e90e743da11c\n  , ciphertext = 0x7639e9f902d65feb6bc5cbc44b5e12ed\n  },\n\n  { key = 0xfda6b0d164b7fd982dc9d9dcb492a37d9150001ed26ba93a\n  , plaintext = 0x7639e9f902d65feb6bc5cbc44b5e12ed\n  , ciphertext = 0x85a71ee457e94fc85cb9ac461fff1c4f\n  },\n\n  { key = 0x0755b86a470bb93aa86ec738e37becb5cde9ac58cd94b575\n  , plaintext = 0x85a71ee457e94fc85cb9ac461fff1c4f\n  , ciphertext = 0xc9ef84a268877ecef88bb554ea63c336\n  },\n\n  { key = 0x8f13f2d9085091816181439a8bfc927b3562190c27f77643\n  , plaintext = 0xc9ef84a268877ecef88bb554ea63c336\n  , ciphertext = 0x260dd6bf1366c029b5fd64e72853d2d7\n  },\n\n  { key = 0xfdd71c524c374345478c9525989a5252809f7deb0fa4a494\n  , plaintext = 0x260dd6bf1366c029b5fd64e72853d2d7\n  , ciphertext = 0x39cc3e224738efaaf45fab525fc13127\n  },\n\n  { key = 0x8bd43e3f448778ea7e40ab07dfa2bdf874c0d6b9506595b3\n  , plaintext = 0x39cc3e224738efaaf45fab525fc13127\n  , ciphertext = 0x4d5ac8506c0a13b1c2092731c6fe5fbc\n  },\n\n  { key = 0x69b7449dc811b19c331a6357b3a8ae49b6c9f188969bca0f\n  , plaintext = 0x4d5ac8506c0a13b1c2092731c6fe5fbc\n  , ciphertext = 0xede69bd80f879d57640c77bc1312f064\n  },\n\n  { key = 0x40e1692d44e3b441defcf88fbc2f331ed2c5863485893a6b\n  , plaintext = 0xede69bd80f879d57640c77bc1312f064\n  , ciphertext = 0x31dc854d8552e6684904bc6502682434\n  },\n\n  { key = 0xc1de7d9285751138ef207dc2397dd5769bc13a5187e11e5f\n  , plaintext = 0x31dc854d8552e6684904bc6502682434\n  , ciphertext = 0xc7bdc57aaa445e489655154b25d3906d\n  },\n\n  { key = 0xd8689fdcc9b77227289db8b893398b3e0d942f1aa2328e32\n  , plaintext = 0xc7bdc57aaa445e489655154b25d3906d\n  , ciphertext = 0xc4b498470a24113b6b182674c0366131\n  },\n\n  { key = 0x8293a998633a405dec2920ff991d9a05668c096e6204ef03\n  , plaintext = 0xc4b498470a24113b6b182674c0366131\n  , ciphertext = 0x7575104da6d5b4e0fb21d682f93d0d24\n  },\n\n  { key = 0xe71e9c0918c908ae995c30b23fc82ee59daddfec9b39e227\n  , plaintext = 0x7575104da6d5b4e0fb21d682f93d0d24\n  , ciphertext = 0xc5acdc318353c4ef3f6f45bf4a84c659\n  },\n\n  { key = 0xa5f19f392eb2afd15cf0ec83bc9bea0aa2c29a53d1bd247e\n  , plaintext = 0xc5acdc318353c4ef3f6f45bf4a84c659\n  , ciphertext = 0xaf6a60f60fc085656e305a4c050cc9c3\n  },\n\n  { key = 0x180b05bff13a1ad3f39a8c75b35b6f6fccf2c01fd4b1edbd\n  , plaintext = 0xaf6a60f60fc085656e305a4c050cc9c3\n  , ciphertext = 0x9d5f30e488c3243ad20767b39ec9ee4e\n  },\n\n  { key = 0x1fb7ff20cab8a5186ec5bc913b984b551ef5a7ac4a7803f3\n  , plaintext = 0x9d5f30e488c3243ad20767b39ec9ee4e\n  , ciphertext = 0x5c3a1d144e5efe7cede88e21dcbc2777\n  },\n\n  { key = 0x3e999761c9d15f3932ffa18575c6b529f31d298d96c42484\n  , plaintext = 0x5c3a1d144e5efe7cede88e21dcbc2777\n  , ciphertext = 0x4f163c25a6d545ccffc54511b2a5605d\n  },\n\n  { key = 0x8bc1e531e9d3f84f7de99da0d313f0e50cd86c9c246144d9\n  , plaintext = 0x4f163c25a6d545ccffc54511b2a5605d\n  , ciphertext = 0x3eed65dab0bd7ae8c8b115fa185e310a\n  },\n\n  { key = 0x4efaae2e7ecadcd24304f87a63ae8a0dc46979663c3f75d3\n  , plaintext = 0x3eed65dab0bd7ae8c8b115fa185e310a\n  , ciphertext = 0xfefce0da5af3885d022636f19adab9b8\n  },\n\n  { key = 0x44e1224d08476e9cbdf818a0395d0250c64f4f97a6e5cc6b\n  , plaintext = 0xfefce0da5af3885d022636f19adab9b8\n  , ciphertext = 0x3a0c3d806aff32fde868343b0b58c77a\n  },\n\n  { key = 0xef93ffb9eb0b9f1787f4252053a230ad2e277bacadbd0b11\n  , plaintext = 0x3a0c3d806aff32fde868343b0b58c77a\n  , ciphertext = 0x6610ee19970ee606083968e523af2370\n  },\n\n  { key = 0xfc7c2c3d27519036e1e4cb39c4acd6ab261e13498e122861\n  , plaintext = 0x6610ee19970ee606083968e523af2370\n  , ciphertext = 0x2f714ddbd4adf8327dc93c723aebfffa\n  },\n\n  { key = 0xf2f8a8247724e289ce9586e210012e995bd72f3bb4f9d79b\n  , plaintext = 0x2f714ddbd4adf8327dc93c723aebfffa\n  , ciphertext = 0x5d1196da8f184975e240949a25104554\n  }]\n\naes192_MCT_decrypt_test_vectors : [100](AESTestVector 192)\naes192_MCT_decrypt_test_vectors =\n [{ key = 0x4b97585701c03fbebdfa8555024f589f1482c58a00fdd9fd\n  , ciphertext = 0xd0bd0e02ded155e4516be83f42d347a4\n  , plaintext = 0xc7b6581ccc88f7fc26d15d2731e7251b\n  },\n\n  { key = 0x3c98c80336e0f13f7a4cdd49cec7af63325398ad311afce6\n  , ciphertext = 0xc7b6581ccc88f7fc26d15d2731e7251b\n  , plaintext = 0x01aa957b12c596511484ed7705766c67\n  },\n\n  { key = 0x825349971b370dc47be64832dc02393226d775da346c9081\n  , ciphertext = 0x01aa957b12c596511484ed7705766c67\n  , plaintext = 0xf98c15d93f5daef6047c2760c5df5540\n  },\n\n  { key = 0xebb9611cf25685c3826a5debe35f97c422ab52baf1b3c5c1\n  , ciphertext = 0xf98c15d93f5daef6047c2760c5df5540\n  , plaintext = 0x5c86395c6b3ed7d30d5e3ce3331fb3ed\n  },\n\n  { key = 0xd8d6d591e30f4e77deec64b7886140172ff56e59c2ac762c\n  , ciphertext = 0x5c86395c6b3ed7d30d5e3ce3331fb3ed\n  , plaintext = 0x8e8cb768b31e65d054e9db8d19862084\n  },\n\n  { key = 0x775a6f9a0e4733e45060d3df3b7f25c77b1cb5d4db2a56a8\n  , ciphertext = 0x8e8cb768b31e65d054e9db8d19862084\n  , plaintext = 0x96cab38070ea8e37c3d437a091e9e74c\n  },\n\n  { key = 0x511e536ea113429bc6aa605f4b95abf0b8c882744ac3b1e4\n  , ciphertext = 0x96cab38070ea8e37c3d437a091e9e74c\n  , plaintext = 0xf8356cfe486b2375c2e2e4138b285ce7\n  },\n\n  { key = 0xc3f94c74f86b59723e9f0ca103fe88857a2a6667c1ebed03\n  , ciphertext = 0xf8356cfe486b2375c2e2e4138b285ce7\n  , plaintext = 0x6a15770b29960c063395a70dc3cf7575\n  },\n\n  { key = 0xa220f197ee7db5a2548a7baa2a68848349bfc16a02249876\n  , ciphertext = 0x6a15770b29960c063395a70dc3cf7575\n  , plaintext = 0xd16463745da38ef8997e20e102fb8573\n  },\n\n  { key = 0x187bc771e567fb1285ee18de77cb0a7bd0c1e18b00df1d05\n  , ciphertext = 0xd16463745da38ef8997e20e102fb8573\n  , plaintext = 0x98ea16875a9e3006de150e93be9585b8\n  },\n\n  { key = 0x432ab1057033bb041d040e592d553a7d0ed4ef18be4a98bd\n  , ciphertext = 0x98ea16875a9e3006de150e93be9585b8\n  , plaintext = 0x9d4c05cb0c5cb543515cfd05a4b90004\n  },\n\n  { key = 0x64a7f543e2e2a60780480b9221098f3e5f88121d1af398b9\n  , ciphertext = 0x9d4c05cb0c5cb543515cfd05a4b90004\n  , plaintext = 0x93c4638f0f76b0a42481c030314ca594\n  },\n\n  { key = 0x755c48e6e44a956f138c681d2e7f3f9a7b09d22d2bbf3d2d\n  , ciphertext = 0x93c4638f0f76b0a42481c030314ca594\n  , plaintext = 0x8ad1d144144c8530218c0edf3119aa82\n  },\n\n  { key = 0x4ff1466b9e9939af995db9593a33baaa5a85dcf21aa697af\n  , ciphertext = 0x8ad1d144144c8530218c0edf3119aa82\n  , plaintext = 0xa46e11cca3b2f98e9f7360d33d236189\n  },\n\n  { key = 0xb2e265f13266035a3d33a89599814324c5f6bc212785f626\n  , ciphertext = 0xa46e11cca3b2f98e9f7360d33d236189\n  , plaintext = 0x9ece35fb84957574fd353cfac1608943\n  },\n\n  { key = 0x102d9afa0e70b1daa3fd9d6e1d14365038c380dbe6e57f65\n  , ciphertext = 0x9ece35fb84957574fd353cfac1608943\n  , plaintext = 0x225ce2f6987392afd1921c5eecd6ba17\n  },\n\n  { key = 0xc772081227697cc081a17f988567a4ffe9519c850a33c572\n  , ciphertext = 0x225ce2f6987392afd1921c5eecd6ba17\n  , plaintext = 0x85fd494bfd5127cff96088e0b130ef04\n  },\n\n  { key = 0xc306028aea2e8f1c045c36d37836833010311465bb032a76\n  , ciphertext = 0x85fd494bfd5127cff96088e0b130ef04\n  , plaintext = 0x1e693009be7a868db9e6a495c2e238f3\n  },\n\n  { key = 0x7a646ea7ab6a11101a3506dac64c05bda9d7b0f079e11285\n  , ciphertext = 0x1e693009be7a868db9e6a495c2e238f3\n  , plaintext = 0x49f55237f9a66050b7e04e66a0b4bf24\n  },\n\n  { key = 0xddbe30e84a14077953c054ed3fea65ed1e37fe96d955ada1\n  , ciphertext = 0x49f55237f9a66050b7e04e66a0b4bf24\n  , plaintext = 0xb966ec6748bd876046be2be11abff82a\n  },\n\n  { key = 0x55e1472be2e1739aeaa6b88a7757e28d5889d577c3ea558b\n  , ciphertext = 0xb966ec6748bd876046be2be11abff82a\n  , plaintext = 0x0f6a78ac23e6ea2d9f4232e8568cea97\n  },\n\n  { key = 0x38750e9c7a729e09e5ccc02654b108a0c7cbe79f9566bf1c\n  , ciphertext = 0x0f6a78ac23e6ea2d9f4232e8568cea97\n  , plaintext = 0xc80bfbe58fb9b00cd4858fd769e3cd1d\n  },\n\n  { key = 0xe45ace33a0f7494c2dc73bc3db08b8ac134e6848fc857201\n  , ciphertext = 0xc80bfbe58fb9b00cd4858fd769e3cd1d\n  , plaintext = 0x918e28b7a7ad8a370d2f260f9f7a5fec\n  },\n\n  { key = 0xd2a3b2ca9419501abc4913747ca5329b1e614e4763ff2ded\n  , ciphertext = 0x918e28b7a7ad8a370d2f260f9f7a5fec\n  , plaintext = 0x59d1732fc2452e53eeda0790b80a244a\n  },\n\n  { key = 0x9dae1b9eaa53bdfce598605bbee01cc8f0bb49d7dbf509a7\n  , ciphertext = 0x59d1732fc2452e53eeda0790b80a244a\n  , plaintext = 0xe74d820249410cd1a39287dc536ed5fc\n  },\n\n  { key = 0xe74268a3d42edb8702d5e259f7a110195329ce0b889bdc5b\n  , ciphertext = 0xe74d820249410cd1a39287dc536ed5fc\n  , plaintext = 0x27ca67828485be98a6cd22d724af53b9\n  },\n\n  { key = 0x0d793e8f7e0ea82d251f85db7324ae81f5e4ecdcac348fe2\n  , ciphertext = 0x27ca67828485be98a6cd22d724af53b9\n  , plaintext = 0x4927ab19552102414e39126b8a91c675\n  },\n\n  { key = 0xc99788fd8dc7a7246c382ec22605acc0bbddfeb726a54997\n  , ciphertext = 0x4927ab19552102414e39126b8a91c675\n  , plaintext = 0x99ea6ccf100d06243b45998d68c9b6bc\n  },\n\n  { key = 0x733425872bb717edf5d2420d3608aae48098673a4e6cff2b\n  , ciphertext = 0x99ea6ccf100d06243b45998d68c9b6bc\n  , plaintext = 0xf029e59925e67de178b5cb9fd187f2c6\n  },\n\n  { key = 0xfc02106517299a1e05fba79413eed705f82daca59feb0ded\n  , ciphertext = 0xf029e59925e67de178b5cb9fd187f2c6\n  , plaintext = 0x5f9da95aa424d5a65f1ff3d99769522d\n  },\n\n  { key = 0x9b0efe0e5f4f4e395a660eceb7ca02a3a7325f7c08825fc0\n  , ciphertext = 0x5f9da95aa424d5a65f1ff3d99769522d\n  , plaintext = 0xa20f232bb355370df27f55bb53469b40\n  },\n\n  { key = 0x502b270205133d51f8692de5049f35ae554d0ac75bc4c480\n  , ciphertext = 0xa20f232bb355370df27f55bb53469b40\n  , plaintext = 0x32e5d13e44b2e67952d8ef98af19a4d3\n  },\n\n  { key = 0xd1cac8a82a2e3ab3ca8cfcdb402dd3d70795e55ff4dd6053\n  , ciphertext = 0x32e5d13e44b2e67952d8ef98af19a4d3\n  , plaintext = 0x688ab3ed2b373467bc547be2bf519846\n  },\n\n  { key = 0x7e4af6629efd55dfa2064f366b1ae7b0bbc19ebd4b8cf815\n  , ciphertext = 0x688ab3ed2b373467bc547be2bf519846\n  , plaintext = 0x1a88d45de26cab118e86fe7089d818d0\n  },\n\n  { key = 0x216cd4ed3d38e68cb88e9b6b89764ca1354760cdc254e0c5\n  , ciphertext = 0x1a88d45de26cab118e86fe7089d818d0\n  , plaintext = 0x8d154a7ebc0e6fd2d6d7686d9b9492ad\n  },\n\n  { key = 0xedf6f3e4f323dc91359bd11535782373e39008a059c07268\n  , ciphertext = 0x8d154a7ebc0e6fd2d6d7686d9b9492ad\n  , plaintext = 0xbe46ead5f431ee2c6d1795f852558ed7\n  },\n\n  { key = 0x94afb2de656daf688bdd3bc0c149cd5f8e879d580b95fcbf\n  , ciphertext = 0xbe46ead5f431ee2c6d1795f852558ed7\n  , plaintext = 0x9f1ecd9839abd6abbecba89a71405c76\n  },\n\n  { key = 0x70bea40807c903c714c3f658f8e21bf4304c35c27ad5a0c9\n  , ciphertext = 0x9f1ecd9839abd6abbecba89a71405c76\n  , plaintext = 0xf5f335142d71d35a4723bbece7a39c43\n  },\n\n  { key = 0xb32369cb5a1611d7e130c34cd593c8ae776f8e2e9d763c8a\n  , ciphertext = 0xf5f335142d71d35a4723bbece7a39c43\n  , plaintext = 0x55ace2aa461af10d10436e529a2d8d85\n  },\n\n  { key = 0xf6412cbd1f98e445b49c21e6938939a3672ce07c075bb10f\n  , ciphertext = 0x55ace2aa461af10d10436e529a2d8d85\n  , plaintext = 0xf6670a6576aa2d20b63482aab26f7c82\n  },\n\n  { key = 0xea7cf55a9e0fcb0d42fb2b83e5231483d11862d6b534cd8d\n  , ciphertext = 0xf6670a6576aa2d20b63482aab26f7c82\n  , plaintext = 0x93e81b9866979a0adc573d380065f18e\n  },\n\n  { key = 0x1a5d1de4468ed5e5d113301b83b48e890d4f5feeb5513c03\n  , ciphertext = 0x93e81b9866979a0adc573d380065f18e\n  , plaintext = 0x324024007edad9a3e4b435b212bfec88\n  },\n\n  { key = 0x8ed3c18837593af6e353141bfd6e572ae9fb6a5ca7eed08b\n  , ciphertext = 0x324024007edad9a3e4b435b212bfec88\n  , plaintext = 0x5eb5e71f06992c1998ae0cf03dbc9dce\n  },\n\n  { key = 0xe5d6d1566d3c9a17bde6f304fbf77b33715566ac9a524d45\n  , ciphertext = 0x5eb5e71f06992c1998ae0cf03dbc9dce\n  , plaintext = 0xa83fe8f226ad5ee5b358fac03a092882\n  },\n\n  { key = 0xd5ec4f5df302bfa515d91bf6dd5a25d6c20d9c6ca05b65c7\n  , ciphertext = 0xa83fe8f226ad5ee5b358fac03a092882\n  , plaintext = 0x72360b4fcd1293a36ed0bb44213da8b9\n  },\n\n  { key = 0x50257306e757d76567ef10b91048b675acdd27288166cd7e\n  , ciphertext = 0x72360b4fcd1293a36ed0bb44213da8b9\n  , plaintext = 0x982119600a3e73dff33583558134bcf0\n  },\n\n  { key = 0x64b394f798415fbcffce09d91a76c5aa5fe8a47d0052718e\n  , ciphertext = 0x982119600a3e73dff33583558134bcf0\n  , plaintext = 0x0c33669b84d714959785b37d586bb355\n  },\n\n  { key = 0xcbaf8d92f18efe87f3fd6f429ea1d13fc86d17005839c2db\n  , ciphertext = 0x0c33669b84d714959785b37d586bb355\n  , plaintext = 0x9fc2fd51bbefd70fe7ce0c13af3d2ace\n  },\n\n  { key = 0x80bb745fb5b9cb616c3f9213254e06302fa31b13f704e815\n  , ciphertext = 0x9fc2fd51bbefd70fe7ce0c13af3d2ace\n  , plaintext = 0xaf4a4566e556a7f2dd3477a53c094498\n  },\n\n  { key = 0xb5d94340d5852f04c375d775c018a1c2f2976cb6cb0dac8d\n  , ciphertext = 0xaf4a4566e556a7f2dd3477a53c094498\n  , plaintext = 0x8107ca3fc833fee74501f2a42f088401\n  },\n\n  { key = 0x23341a3b649010c942721d4a082b5f25b7969e12e405288c\n  , ciphertext = 0x8107ca3fc833fee74501f2a42f088401\n  , plaintext = 0x714341183a67b95abcf9bc992d1aa290\n  },\n\n  { key = 0x955075d16664498333315c52324ce67f0b6f228bc91f8a1c\n  , ciphertext = 0x714341183a67b95abcf9bc992d1aa290\n  , plaintext = 0x564289f3ac30d6e27dde4308ee5637ab\n  },\n\n  { key = 0x9e5493cf59a7d0e76573d5a19e7c309d76b161832749bdb7\n  , ciphertext = 0x564289f3ac30d6e27dde4308ee5637ab\n  , plaintext = 0x805424be37b7f0b5498ab5bf8904f468\n  },\n\n  { key = 0x0e8dd0538bcfa448e527f11fa9cbc0283f3bd43cae4d49df\n  , ciphertext = 0x805424be37b7f0b5498ab5bf8904f468\n  , plaintext = 0x793554c1cc565f00f9f2122bd06672aa\n  },\n\n  { key = 0xf253723471590c249c12a5de659d9f28c6c9c6177e2b3b75\n  , ciphertext = 0x793554c1cc565f00f9f2122bd06672aa\n  , plaintext = 0xb89feee17d71a452b46e4683cfddc0ba\n  },\n\n  { key = 0x14781c9f73227825248d4b3f18ec3b7a72a78094b1f6fbcf\n  , ciphertext = 0xb89feee17d71a452b46e4683cfddc0ba\n  , plaintext = 0x737c418d35812556f6d26ebf91028ad7\n  },\n\n  { key = 0xc4706d6414a3594657f10ab22d6d1e2c8475ee2b20f47118\n  , ciphertext = 0x737c418d35812556f6d26ebf91028ad7\n  , plaintext = 0xc2e352ec712b84fa74f98254740d0847\n  },\n\n  { key = 0x74fabaf96545e7199512585e5c469ad6f08c6c7f54f9795f\n  , ciphertext = 0xc2e352ec712b84fa74f98254740d0847\n  , plaintext = 0xe09f8d7cc0e4d7f4efb65e10529592e5\n  },\n\n  { key = 0xdbfa75aad7f1ad19758dd5229ca24d221f3a326f066cebba\n  , ciphertext = 0xe09f8d7cc0e4d7f4efb65e10529592e5\n  , plaintext = 0x8a8911579e11d858bd4e336b8125fa6f\n  },\n\n  { key = 0xad8ea306bb3eb77bff04c47502b3957aa2740104874911d5\n  , ciphertext = 0x8a8911579e11d858bd4e336b8125fa6f\n  , plaintext = 0x3b1f396eae6ae53926e9607fb4b6e1d6\n  },\n\n  { key = 0x2b204520b1389d5bc41bfd1bacd97043849d617b33fff003\n  , ciphertext = 0x3b1f396eae6ae53926e9607fb4b6e1d6\n  , plaintext = 0x6d06fe256d84ab0112119425d70d5aa6\n  },\n\n  { key = 0x86d761e020a46b76a91d033ec15ddb42968cf55ee4f2aaa5\n  , ciphertext = 0x6d06fe256d84ab0112119425d70d5aa6\n  , plaintext = 0x537dd3000fdff67107362da65c95f101\n  },\n\n  { key = 0xbee0861f51136bd0fa60d03ece822d3391bad8f8b8675ba4\n  , ciphertext = 0x537dd3000fdff67107362da65c95f101\n  , plaintext = 0x2843b7b7107b1390be393137e3e266c9\n  },\n\n  { key = 0x8706a8a8fab02e3dd2236789def93ea32f83e9cf5b853d6d\n  , ciphertext = 0x2843b7b7107b1390be393137e3e266c9\n  , plaintext = 0xd5fae73a8940ec3c1bebe8a5e4fa0423\n  },\n\n  { key = 0x43ab0c1509505c7407d980b357b9d29f3468016abf7f394e\n  , ciphertext = 0xd5fae73a8940ec3c1bebe8a5e4fa0423\n  , plaintext = 0x63a9a8c99a6a8984dc6975772dd0beac\n  },\n\n  { key = 0xfb0dbb8cab3b89b16470287acdd35b1be801741d92af87e2\n  , ciphertext = 0x63a9a8c99a6a8984dc6975772dd0beac\n  , plaintext = 0x4c7b28c69c39c7eea1359ba2c167266a\n  },\n\n  { key = 0x1abc6031a84a5908280b00bc51ea9cf54934efbf53c8a188\n  , ciphertext = 0x4c7b28c69c39c7eea1359ba2c167266a\n  , plaintext = 0x076024c11bf696874d791813887685e7\n  },\n\n  { key = 0x746718f146cad3d92f6b247d4a1c0a72044df7acdbbe246f\n  , ciphertext = 0x076024c11bf696874d791813887685e7\n  , plaintext = 0xb413f148dc94e0525ad4800fb53dfc64\n  },\n\n  { key = 0x65a422dccc0f07779b78d5359688ea205e9977a36e83d80b\n  , ciphertext = 0xb413f148dc94e0525ad4800fb53dfc64\n  , plaintext = 0xbd94776297b168e862d3afd0669a2668\n  },\n\n  { key = 0x6d9fc6a3839c401426eca257013982c83c4ad8730819fe63\n  , ciphertext = 0xbd94776297b168e862d3afd0669a2668\n  , plaintext = 0xa383eb812e9d2ad7d04ef05beebc663c\n  },\n\n  { key = 0x31e8ba40171be0cc856f49d62fa4a81fec042828e6a5985f\n  , ciphertext = 0xa383eb812e9d2ad7d04ef05beebc663c\n  , plaintext = 0x125833c5a964733d24ca84ae573e537e\n  },\n\n  { key = 0xa1bd656677244e3597377a1386c0db22c8ceac86b19bcb21\n  , ciphertext = 0x125833c5a964733d24ca84ae573e537e\n  , plaintext = 0xd6597fe3687c9dc2f6087ad48bb2ab18\n  },\n\n  { key = 0x9467df27c2b90ca7416e05f0eebc46e03ec6d6523a296039\n  , ciphertext = 0xd6597fe3687c9dc2f6087ad48bb2ab18\n  , plaintext = 0xfd6abdb2793f849bedea160e34ab1a9d\n  },\n\n  { key = 0x1ee8f6b4187a87f0bc04b8429783c27bd32cc05c0e827aa4\n  , ciphertext = 0xfd6abdb2793f849bedea160e34ab1a9d\n  , plaintext = 0xfd2ccba255e74b16864ac2ff80894ebb\n  },\n\n  { key = 0x3f23c25c52d6454c412873e0c264896d556602a38e0b341f\n  , ciphertext = 0xfd2ccba255e74b16864ac2ff80894ebb\n  , plaintext = 0x4571abacb8faa74007702258220b3e19\n  },\n\n  { key = 0x4eedfc725f3901b80459d84c7a9e2e2d521620fbac000a06\n  , ciphertext = 0x4571abacb8faa74007702258220b3e19\n  , plaintext = 0x941b069f7545d16d24e69a309794a259\n  },\n\n  { key = 0xad8b4cd042b874d09042ded30fdbff4076f0bacb3b94a85f\n  , ciphertext = 0x941b069f7545d16d24e69a309794a259\n  , plaintext = 0x515ab9b50447ea30e5ab92ddd1498d69\n  },\n\n  { key = 0xc085e9fde0a60664c11867660b9c1570935b2816eadd2536\n  , ciphertext = 0x515ab9b50447ea30e5ab92ddd1498d69\n  , plaintext = 0x872c0d54b1382c095b1a475fee114cd5\n  },\n\n  { key = 0x4790a2b2ee108fbb46346a32baa43979c8416f4904cc69e3\n  , ciphertext = 0x872c0d54b1382c095b1a475fee114cd5\n  , plaintext = 0x6aa4b9e4559d2c1de4f59dafbaf0909e\n  },\n\n  { key = 0x56880340e6eaf2472c90d3d6ef3915642cb4f2e6be3cf97d\n  , ciphertext = 0x6aa4b9e4559d2c1de4f59dafbaf0909e\n  , plaintext = 0xc4ce24dd760b44799d00ce4c5ffdb8c5\n  },\n\n  { key = 0xd321a216923e2c1de85ef70b9932511db1b43caae1c141b8\n  , ciphertext = 0xc4ce24dd760b44799d00ce4c5ffdb8c5\n  , plaintext = 0xd73e44ee7f75c2fb6696aaba64af9925\n  },\n\n  { key = 0xa80125606ef3f3953f60b3e5e64793e6d7229610856ed89d\n  , ciphertext = 0xd73e44ee7f75c2fb6696aaba64af9925\n  , plaintext = 0x1add98acb3a31733b3e0a32da14a71cf\n  },\n\n  { key = 0xfd54730799c76e1e25bd2b4955e484d564c2353d2424a952\n  , ciphertext = 0x1add98acb3a31733b3e0a32da14a71cf\n  , plaintext = 0x6d2201f6268f7c126e4d57375f5ac97b\n  },\n\n  { key = 0xb07e344619df38e5489f2abf736bf8c70a8f620a7b7e6029\n  , ciphertext = 0x6d2201f6268f7c126e4d57375f5ac97b\n  , plaintext = 0x349daafd5a9676a0bf5e015319a5083b\n  },\n\n  { key = 0xf66e7702379bbeac7c02804229fd8e67b5d1635962db6812\n  , ciphertext = 0x349daafd5a9676a0bf5e015319a5083b\n  , plaintext = 0xfd6cd698388a46f696da48543a327e10\n  },\n\n  { key = 0x1aab1a249cb5fa91816e56da1177c891230b2b0d58e91602\n  , ciphertext = 0xfd6cd698388a46f696da48543a327e10\n  , plaintext = 0xbaa9b8a3f9ffa86241bb5abe04b7eea5\n  },\n\n  { key = 0xdd881f3432073d253bc7ee79e88860f362b071b35c5ef8a7\n  , ciphertext = 0xbaa9b8a3f9ffa86241bb5abe04b7eea5\n  , plaintext = 0x19ad5a0619f1b5eed38fb5fbbbbe1247\n  },\n\n  { key = 0xd4088261dda8dfc1226ab47ff179d51db13fc448e7e0eae0\n  , ciphertext = 0x19ad5a0619f1b5eed38fb5fbbbbe1247\n  , plaintext = 0x832e01274c6a59b148dc6de3e6ccc037\n  },\n\n  { key = 0x0ff97f22bdef4005a144b558bd138cacf9e3a9ab012c2ad7\n  , ciphertext = 0x832e01274c6a59b148dc6de3e6ccc037\n  , plaintext = 0x9853ba4a0880449a6344fd0dabfc9e74\n  },\n\n  { key = 0xa2f2351138f53ed639170f12b593c8369aa754a6aad0b4a3\n  , ciphertext = 0x9853ba4a0880449a6344fd0dabfc9e74\n  , plaintext = 0x89ebc090e07d36670f48a32074c9ca18\n  },\n\n  { key = 0xb7c564161c5e5061b0fccf8255eefe5195eff786de197ebb\n  , ciphertext = 0x89ebc090e07d36670f48a32074c9ca18\n  , plaintext = 0x5695154c14aeb5d09a516ca802d7fb21\n  },\n\n  { key = 0x95aa68a5ba0d346be669dace41404b810fbe9b2edcce859a\n  , ciphertext = 0x5695154c14aeb5d09a516ca802d7fb21\n  , plaintext = 0xf49c9100c165c22f16661c23bf46520e\n  },\n\n  { key = 0x028f06458b3a50ce12f54bce802589ae19d8870d6388d794\n  , ciphertext = 0xf49c9100c165c22f16661c23bf46520e\n  , plaintext = 0x1aec4f3ade3b41dd3d5448dc7e577e67\n  },\n\n  { key = 0xe0b75db3cfb1e3f6081904f45e1ec873248ccfd11ddfa9f3\n  , ciphertext = 0x1aec4f3ade3b41dd3d5448dc7e577e67\n  , plaintext = 0x5c75fbcaa893326641aa343f40f6ee31\n  },\n\n  { key = 0xe51161c0ee3bf4fe546cff3ef68dfa156526fbee5d2947c2\n  , ciphertext = 0x5c75fbcaa893326641aa343f40f6ee31\n  , plaintext = 0xa2c953d404212d5da4e98f31d8cc0a5b\n  },\n\n  { key = 0x1f13dd6e77477337f6a5aceaf2acd748c1cf74df85e54d99\n  , ciphertext = 0xa2c953d404212d5da4e98f31d8cc0a5b\n  , plaintext = 0x17ea5bd0c139ce391240ff701085b060\n  },\n\n  { key = 0x547e1d3ba5988327e14ff73a33951971d38f8baf9560fdf9\n  , ciphertext = 0x17ea5bd0c139ce391240ff701085b060\n  , plaintext = 0x98d87acaeb843ccf7b6e92a1889ff129\n  },\n\n  { key = 0xd140d82958fb4d8979978df0d81125bea8e1190e1dff0cd0\n  , ciphertext = 0x98d87acaeb843ccf7b6e92a1889ff129\n  , plaintext = 0x0c2132942034442ea6eb14d23ccdf868\n  },\n\n  { key = 0xf311ab46bba28f9a75b6bf64f82561900e0a0ddc2132f4b8\n  , ciphertext = 0x0c2132942034442ea6eb14d23ccdf868\n  , plaintext = 0x91341b217d521168251ad3778171e5ba\n  },\n\n  { key = 0x0abea37884946aa1e482a445857770f82b10deaba0431102\n  , ciphertext = 0x91341b217d521168251ad3778171e5ba\n  , plaintext = 0xb63ef1b79507a62eba3dafcec54a6328\n  }]\n\nproperty aes256_MCT_vectors_encrypt_correct =\n  aes256_MCT_encrypt_test_vectors ==\n  mct_ecb_encrypt_256\n    0xf9e8389f5b80712e3886cc1fa2d28a3b8c9cd88a2d4a54c6aa86ce0fef944be0\n    0xb379777f9050e2a818f2940cbbd9aba4\n\nproperty aes256_MCT_vectors_decrypt_correct =\n  aes256_MCT_decrypt_test_vectors ==\n  mct_ecb_decrypt_256\n    0x2b09ba39b834062b9e93f48373b8dd018dedf1e5ba1b8af831ebbacbc92a2643\n    0x89649bd0115f30bd878567610223a59d\n\naes256_MCT_encrypt_test_vectors : [100](AESTestVector 256)\naes256_MCT_encrypt_test_vectors =\n  [{ key = 0xf9e8389f5b80712e3886cc1fa2d28a3b8c9cd88a2d4a54c6aa86ce0fef944be0\n  , plaintext = 0xb379777f9050e2a818f2940cbbd9aba4\n  , ciphertext = 0x6893ebaf0a1fccc704326529fdfb60db\n  },\n\n  { key = 0xdb9ea5a2284fa17fb63e13bf891c8e42e40f332527559801aeb4ab26126f2b3b\n  , plaintext = 0x6893ebaf0a1fccc704326529fdfb60db\n  , ciphertext = 0xf3c78a5e85e5439bf26d5818718157d6\n  },\n\n  { key = 0x7099ed88e82744228a5303ae2ef6c0d017c8b97ba2b0db9a5cd9f33e63ee7ced\n  , plaintext = 0xf3c78a5e85e5439bf26d5818718157d6\n  , ciphertext = 0x2326b958b00b3050697eedb08cc20504\n  },\n\n  { key = 0x5e9e65ea96e78dd4fb78ea1184f6ebde34ee002312bbebca35a71e8eef2c79e9\n  , plaintext = 0x2326b958b00b3050697eedb08cc20504\n  , ciphertext = 0xec4332d5e3cebd3e0f5fc51452f4560d\n  },\n\n  { key = 0x33acf1cafc822646dc869e905bd26f9ad8ad32f6f17556f43af8db9abdd82fe4\n  , plaintext = 0xec4332d5e3cebd3e0f5fc51452f4560d\n  , ciphertext = 0x5da58b5ef2076340d555f861c3449a77\n  },\n\n  { key = 0xeb0ae85c1b44d5db4729d268f49be2a08508b9a8037235b4efad23fb7e9cb593\n  , plaintext = 0x5da58b5ef2076340d555f861c3449a77\n  , ciphertext = 0x307d50c18a0b6a08402ff131d72cb7ec\n  },\n\n  { key = 0xfac93b561a9b6a0e809d71ecdb980afab575e96989795fbcaf82d2caa9b0027f\n  , plaintext = 0x307d50c18a0b6a08402ff131d72cb7ec\n  , ciphertext = 0x92c34165a2963e77e05e2d6fc2d931d5\n  },\n\n  { key = 0xa0559e41d58af36174a67246df87541b27b6a80c2bef61cb4fdcffa56b6933aa\n  , plaintext = 0x92c34165a2963e77e05e2d6fc2d931d5\n  , ciphertext = 0xcb33d519a1fdb1d5fbb185c47870c1ed\n  },\n\n  { key = 0xe48824d6c2251d3a27f38fb543c31fc1ec857d158a12d01eb46d7a611319f247\n  , plaintext = 0xcb33d519a1fdb1d5fbb185c47870c1ed\n  , ciphertext = 0x78fb452f384c8f870e572890588f3728\n  },\n\n  { key = 0x7a33440ad7c69d583355c745e5c88c47947e383ab25e5f99ba3a52f14b96c56f\n  , plaintext = 0x78fb452f384c8f870e572890588f3728\n  , ciphertext = 0x12375e02a8bbc84b00feaab54a66db43\n  },\n\n  { key = 0x0e6877c7fdc234efb9afcd96b4ebdb83864966381ae597d2bac4f84401f01e2c\n  , plaintext = 0x12375e02a8bbc84b00feaab54a66db43\n  , ciphertext = 0xeab1606610b55c857f2b4bf1cf3feba0\n  },\n\n  { key = 0xec91d3550c79ab4914a26987725ab1396cf8065e0a50cb57c5efb3b5cecff58c\n  , plaintext = 0xeab1606610b55c857f2b4bf1cf3feba0\n  , ciphertext = 0x6c73381147de97961cc26ad26602a45a\n  },\n\n  { key = 0x83caed5a49579b3a55a71e5ece5966e5008b3e4f4d8e5cc1d92dd967a8cd51d6\n  , plaintext = 0x6c73381147de97961cc26ad26602a45a\n  , ciphertext = 0xe76c08fd29bf015352003c636fee5ff9\n  },\n\n  { key = 0x91b9b50908968361dcd8f4ba236fa199e7e736b264315d928b2de504c7230e2f\n  , plaintext = 0xe76c08fd29bf015352003c636fee5ff9\n  , ciphertext = 0x6f26b8191a2b059dcdeb3dbabc437c29\n  },\n\n  { key = 0x94fc46213c870f7965b88773afe93b1388c18eab7e1a580f46c6d8be7b607206\n  , plaintext = 0x6f26b8191a2b059dcdeb3dbabc437c29\n  , ciphertext = 0xe91e2fcef14dd4251caec97c45223fef\n  },\n\n  { key = 0xb0deff009aff61f65763b0b9fdd39a9061dfa1658f578c2a5a6811c23e424de9\n  , plaintext = 0xe91e2fcef14dd4251caec97c45223fef\n  , ciphertext = 0x98fb2122912360f07916e4802c0ea1e5\n  },\n\n  { key = 0x968f3c88d27f1be8decb00c4d464d369f92480471e74ecda237ef542124cec0c\n  , plaintext = 0x98fb2122912360f07916e4802c0ea1e5\n  , ciphertext = 0xb4a15c59976b39da50da8ed393f27a62\n  },\n\n  { key = 0x35fe06a60309581565a97232140668464d85dc1e891fd50073a47b9181be966e\n  , plaintext = 0xb4a15c59976b39da50da8ed393f27a62\n  , ciphertext = 0xd8b57d7a72ef92409c51d40bb8c4cbc5\n  },\n\n  { key = 0x4739043d7750bcf4a6f269a3d54083ca9530a164fbf04740eff5af9a397a5dab\n  , plaintext = 0xd8b57d7a72ef92409c51d40bb8c4cbc5\n  , ciphertext = 0x548cc893e80caf5a601c2381517f8c5b\n  },\n\n  { key = 0x4b065b5195f2ddf6f5d0aed72ff7a1e3c1bc69f713fce81a8fe98c1b6805d1f0\n  , plaintext = 0x548cc893e80caf5a601c2381517f8c5b\n  , ciphertext = 0x1c2238c560d678d40b48cc8034add0c4\n  },\n\n  { key = 0x1a949129e14c5963d997c86a6352ea53dd9e5132732a90ce84a1409b5ca80134\n  , plaintext = 0x1c2238c560d678d40b48cc8034add0c4\n  , ciphertext = 0x2771ff806e061df8ad4aa877717bf309\n  },\n\n  { key = 0x91cd3e48f4b42c432bed9848583e6dc7faefaeb21d2c8d3629ebe8ec2dd3f23d\n  , plaintext = 0x2771ff806e061df8ad4aa877717bf309\n  , ciphertext = 0x065593fa1fcdb481bb27f334505543f5\n  },\n\n  { key = 0x42d6f7b585a0a0d356c59be3d07d4d41fcba3d4802e139b792cc1bd87d86b1c8\n  , plaintext = 0x065593fa1fcdb481bb27f334505543f5\n  , ciphertext = 0xd3f309c0039b15d14eb8b739a94b94fa\n  },\n\n  { key = 0x72900f0ecbf90fa058805deb430815072f493488017a2c66dc74ace1d4cd2532\n  , plaintext = 0xd3f309c0039b15d14eb8b739a94b94fa\n  , ciphertext = 0x4e441a3fb277d6fbe0ed7c6e080d9a9f\n  },\n\n  { key = 0x12ef8789b91a8e35fd0ac79457a906f0610d2eb7b30dfa9d3c99d08fdcc0bfad\n  , plaintext = 0x4e441a3fb277d6fbe0ed7c6e080d9a9f\n  , ciphertext = 0xcb9241bc964cbc9823531f68e3a03b7c\n  },\n\n  { key = 0x2cbe5980ad54c5dbf2ee3db1e9875733aa9f6f0b254146051fcacfe73f6084d1\n  , plaintext = 0xcb9241bc964cbc9823531f68e3a03b7c\n  , ciphertext = 0x70b17c3e869aca6076617a2cf75e9f4a\n  },\n\n  { key = 0xdc4da3812736a2a603bcc6390763c5c5da2e1335a3db8c6569abb5cbc83e1b9b\n  , plaintext = 0x70b17c3e869aca6076617a2cf75e9f4a\n  , ciphertext = 0xf4b8a6ed6d6d72aff59484314f210bb9\n  },\n\n  { key = 0x2e4e21a6eb77bb39a1cb5cd20cc5fd3b2e96b5d8ceb6feca9c3f31fa871f1022\n  , plaintext = 0xf4b8a6ed6d6d72aff59484314f210bb9\n  , ciphertext = 0xf56a4597beaeafc0c14ee73988bcbee8\n  },\n\n  { key = 0x54d5c037e61fd09e5cf57fd34c5e0192dbfcf04f7018510a5d71d6c30fa3aeca\n  , plaintext = 0xf56a4597beaeafc0c14ee73988bcbee8\n  , ciphertext = 0x04333079d5352236e1c79213f3f38dbe\n  },\n\n  { key = 0x3a5da203e03fa399caeb1fac63679b56dfcfc036a52d733cbcb644d0fc502374\n  , plaintext = 0x04333079d5352236e1c79213f3f38dbe\n  , ciphertext = 0x22c97ecdf4af830f94b11951f41e4d29\n  },\n\n  { key = 0x5c84147d6ab2051b56b0993a7cbfa306fd06befb5182f03328075d81084e6e5d\n  , plaintext = 0x22c97ecdf4af830f94b11951f41e4d29\n  , ciphertext = 0xdef46a3b39c8048431d2491d97daa6ea\n  },\n\n  { key = 0x7af77aa155a33f658283ebc3e9eb708923f2d4c0684af4b719d5149c9f94c8b7\n  , plaintext = 0xdef46a3b39c8048431d2491d97daa6ea\n  , ciphertext = 0x4c6367ad8a2190366c3d730fe5eeb6ee\n  },\n\n  { key = 0xedabba9dc9d87357bb91da6931c743e16f91b36de26b648175e867937a7a7e59\n  , plaintext = 0x4c6367ad8a2190366c3d730fe5eeb6ee\n  , ciphertext = 0x90bd09b4eb0f7d8397c0026cefea8fb3\n  },\n\n  { key = 0xab7ef1b4a1e43771de88e158ad26a419ff2cbad909641902e22865ff9590f1ea\n  , plaintext = 0x90bd09b4eb0f7d8397c0026cefea8fb3\n  , ciphertext = 0x25aefcfa6ec98fae81b93afad7761711\n  },\n\n  { key = 0x6b0145c6cbeaae320be86c2909c8d643da82462367ad96ac63915f0542e6e6fb\n  , plaintext = 0x25aefcfa6ec98fae81b93afad7761711\n  , ciphertext = 0x607b26f4eb3585e3e886e75c0f3a01cf\n  },\n\n  { key = 0xb46d28c20a614b6d986e92795258631cbaf960d78c98134f8b17b8594ddce734\n  , plaintext = 0x607b26f4eb3585e3e886e75c0f3a01cf\n  , ciphertext = 0xfe35fe16a3290042c28c021ee9ede73f\n  },\n\n  { key = 0x93c5c8403410764717e547e3d07b0ec344cc9ec12fb1130d499bba47a431000b\n  , plaintext = 0xfe35fe16a3290042c28c021ee9ede73f\n  , ciphertext = 0x0141871c357a00ad37ae65597830cac8\n  },\n\n  { key = 0xcf85ea60e0c94e611fedba48e19e9693458d19dd1acb13a07e35df1edc01cac3\n  , plaintext = 0x0141871c357a00ad37ae65597830cac8\n  , ciphertext = 0xdf8bc7782ae10eb2c1bdfdc8887e4907\n  },\n\n  { key = 0xd40735932ea269aeb51fa3caf0c176d89a06dea5302a1d12bf8822d6547f83c4\n  , plaintext = 0xdf8bc7782ae10eb2c1bdfdc8887e4907\n  , ciphertext = 0x1ac65c65b6cd8ab751f1d908ebd962ab\n  },\n\n  { key = 0x9a7120341819fe54fc8a750d17ecf20f80c082c086e797a5ee79fbdebfa6e16f\n  , plaintext = 0x1ac65c65b6cd8ab751f1d908ebd962ab\n  , ciphertext = 0x9f10b53fb6adf7189e277d04e351aa9d\n  },\n\n  { key = 0x8c19642c172cdb804059f751b3f25cff1fd037ff304a60bd705e86da5cf74bf2\n  , plaintext = 0x9f10b53fb6adf7189e277d04e351aa9d\n  , ciphertext = 0xc94ecc943ddc8d1eeafadd173cf73fdc\n  },\n\n  { key = 0xe1cc9575e51d6a8240e6f3cd8958e1a6d69efb6b0d96eda39aa45bcd6000742e\n  , plaintext = 0xc94ecc943ddc8d1eeafadd173cf73fdc\n  , ciphertext = 0x5dd513d74b72f9d46b06b4b96a94c3bd\n  },\n\n  { key = 0xce41ff2d70b2169fad6a5f9ead4471e88b4be8bc46e41477f1a2ef740a94b793\n  , plaintext = 0x5dd513d74b72f9d46b06b4b96a94c3bd\n  , ciphertext = 0x1594a31cc22cdbaf2011a9a317538608\n  },\n\n  { key = 0x7b467b87180772677903a043bc63c3ef9edf4ba084c8cfd8d1b346d71dc7319b\n  , plaintext = 0x1594a31cc22cdbaf2011a9a317538608\n  , ciphertext = 0x4d5e8d6fa3e2ea343b5afb77124529aa\n  },\n\n  { key = 0xca068b3afc717d1f6e8dc7e4eca0f56fd381c6cf272a25eceae9bda00f821831\n  , plaintext = 0x4d5e8d6fa3e2ea343b5afb77124529aa\n  , ciphertext = 0x1bbf651cf61c295c96e73a210483d7a1\n  },\n\n  { key = 0xd04d80998a971ec52d5390fa7eaf78eac83ea3d3d1360cb07c0e87810b01cf90\n  , plaintext = 0x1bbf651cf61c295c96e73a210483d7a1\n  , ciphertext = 0x84b42f75c3b62bbf21707ba66cca399f\n  },\n\n  { key = 0x2cfb1c71e8cac872e6a6dc90b0195acf4c8a8ca61280270f5d7efc2767cbf60f\n  , plaintext = 0x84b42f75c3b62bbf21707ba66cca399f\n  , ciphertext = 0xa0c514e1e6a9c659f605eff4cf4951a0\n  },\n\n  { key = 0x405bc450a19e6dae76847b8eac858c8bec4f9847f429e156ab7b13d3a882a7af\n  , plaintext = 0xa0c514e1e6a9c659f605eff4cf4951a0\n  , ciphertext = 0x1dcc38307c6b3c31e25f868b279b3711\n  },\n\n  { key = 0x35755fe97d9aeb1e67c1f4ca5a40ce1ff183a0778842dd67492495588f1990be\n  , plaintext = 0x1dcc38307c6b3c31e25f868b279b3711\n  , ciphertext = 0xcdd744574664be7b221d7a2921b4f0b2\n  },\n\n  { key = 0x7e9d8b4bbd2aad70d229247d5880a0cb3c54e420ce26631c6b39ef71aead600c\n  , plaintext = 0xcdd744574664be7b221d7a2921b4f0b2\n  , ciphertext = 0xe602ef85184ad4a86ed339e9403f541c\n  },\n\n  { key = 0x73be0bb5b74a8f6324f8a5f0acbf5faada560ba5d66cb7b405ead698ee923410\n  , plaintext = 0xe602ef85184ad4a86ed339e9403f541c\n  , ciphertext = 0x7c227f03e605ff14c42fb9f8e8786e84\n  },\n\n  { key = 0xc82e22faeca51a38045f2a3a04a0e6e2a67474a6306948a0c1c56f6006ea5a94\n  , plaintext = 0x7c227f03e605ff14c42fb9f8e8786e84\n  , ciphertext = 0x94c0466b27aa4d361b19c250329c14a0\n  },\n\n  { key = 0x7c1dd42bdff414e3733b846cbb00c43432b432cd17c30596dadcad3034764e34\n  , plaintext = 0x94c0466b27aa4d361b19c250329c14a0\n  , ciphertext = 0xfd6b281c93c1fd8e9b83b69ecf722f3b\n  },\n\n  { key = 0xaa7ec003efbca86fe5ad028d0571cf3acfdf1ad18402f818415f1baefb04610f\n  , plaintext = 0xfd6b281c93c1fd8e9b83b69ecf722f3b\n  , ciphertext = 0xa75b28be92dc53de9d44714918e3c541\n  },\n\n  { key = 0x14ba26bafb6c8410104d70ec23876db56884326f16deabc6dc1b6ae7e3e7a44e\n  , plaintext = 0xa75b28be92dc53de9d44714918e3c541\n  , ciphertext = 0x48693025ba68f3fa3515e7112b6e32aa\n  },\n\n  { key = 0x33b40738b39ebe39118938c6461ebd7820ed024aacb6583ce90e8df6c88996e4\n  , plaintext = 0x48693025ba68f3fa3515e7112b6e32aa\n  , ciphertext = 0x6bfa37cc5ed6e5d4ddf40b1301957f73\n  },\n\n  { key = 0x0d16eab1b56e2a468bf1ba1035129d574b173586f260bde834fa86e5c91ce997\n  , plaintext = 0x6bfa37cc5ed6e5d4ddf40b1301957f73\n  , ciphertext = 0xca18b89c3225877e02e21042af9836a8\n  },\n\n  { key = 0x44b55514a5b4a5a4294f3cf8e75ff73c810f8d1ac0453a96361896a76684df3f\n  , plaintext = 0xca18b89c3225877e02e21042af9836a8\n  , ciphertext = 0xc3ebc08368be58f8f514cfbd5f98ed52\n  },\n\n  { key = 0x265f1a7a53151bc51526fe476e8c63ad42e44d99a8fb626ec30c591a391c326d\n  , plaintext = 0xc3ebc08368be58f8f514cfbd5f98ed52\n  , ciphertext = 0x788552397ddf2d5841dbc0e73dd11150\n  },\n\n  { key = 0x23fa4630937015585ac065e6a7bd93023a611fa0d5244f3682d799fd04cd233d\n  , plaintext = 0x788552397ddf2d5841dbc0e73dd11150\n  , ciphertext = 0xe9d728bc19b50809bc1245552091d0b2\n  },\n\n  { key = 0x9dd3a2408e5694fced28964c7f442e6ed3b6371ccc91473f3ec5dca8245cf38f\n  , plaintext = 0xe9d728bc19b50809bc1245552091d0b2\n  , ciphertext = 0xce08d78b58179b7957eeab6f74ddb10f\n  },\n\n  { key = 0x055d53ef574a63f77c0b3a88e7e7cdb01dbee0979486dc46692b77c750814280\n  , plaintext = 0xce08d78b58179b7957eeab6f74ddb10f\n  , ciphertext = 0x33ce33e80fcc262e9e862f5ac50c14df\n  },\n\n  { key = 0xc1a90cdef5d5daaf7b182d6b409940e62e70d37f9b4afa68f7ad589d958d565f\n  , plaintext = 0x33ce33e80fcc262e9e862f5ac50c14df\n  , ciphertext = 0x5c4d21e6045f11f9f91a8cef130304e0\n  },\n\n  { key = 0x6a257a4f65bdd7d882ff45ffbb9541e5723df2999f15eb910eb7d472868e52bf\n  , plaintext = 0x5c4d21e6045f11f9f91a8cef130304e0\n  , ciphertext = 0x4f50679c2dbfa63b5e55d031afacd44b\n  },\n\n  { key = 0x5843bf4d6afc64273d328e1baf7821b03d6d9505b2aa4daa50e20443292286f4\n  , plaintext = 0x4f50679c2dbfa63b5e55d031afacd44b\n  , ciphertext = 0x29f64e79de48f3d3d5dff92aa0b1783b\n  },\n\n  { key = 0x8915060a33758a300c053d365c304d4e149bdb7c6ce2be79853dfd698993fecf\n  , plaintext = 0x29f64e79de48f3d3d5dff92aa0b1783b\n  , ciphertext = 0x8c5bf92515a92449846593a3bdbe521b\n  },\n\n  { key = 0xbe2b2a41b3491511c181508b66ec96f798c02259794b9a3001586eca342dacd4\n  , plaintext = 0x8c5bf92515a92449846593a3bdbe521b\n  , ciphertext = 0x5511fef7a2238277aaa9e25f1d097c19\n  },\n\n  { key = 0x4d6f38935317ffa0cb29bdfa8a43cd19cdd1dcaedb681847abf18c952924d0cd\n  , plaintext = 0x5511fef7a2238277aaa9e25f1d097c19\n  , ciphertext = 0x2ecd75c6a5eace1c541e12db150a2143\n  },\n\n  { key = 0x1549ea3d167152c85223b0a603d1fa61e31ca9687e82d65bffef9e4e3c2ef18e\n  , plaintext = 0x2ecd75c6a5eace1c541e12db150a2143\n  , ciphertext = 0x6a4cfcb9e8dae9610df99509daac7be0\n  },\n\n  { key = 0xba593f6731f70edab83f5cdf02527436895055d196583f3af2160b47e6828a6e\n  , plaintext = 0x6a4cfcb9e8dae9610df99509daac7be0\n  , ciphertext = 0x185772deff51807147ac5350249b3e1a\n  },\n\n  { key = 0x7126a05712f987f1c9249bf9a7c17b4f9107270f6909bf4bb5ba5817c219b474\n  , plaintext = 0x185772deff51807147ac5350249b3e1a\n  , ciphertext = 0xbfb1ce7df706bc972e1b8306d44aa135\n  },\n\n  { key = 0x3d0fa3983ebc8a3f64c4135d7cd3195e2eb6e9729e0f03dc9ba1db1116531541\n  , plaintext = 0xbfb1ce7df706bc972e1b8306d44aa135\n  , ciphertext = 0xf21df1e99a781dba4a68ff3491848f99\n  },\n\n  { key = 0x88c88ec4d63eb481cd8d6e8e8d2e2715dcab189b04771e66d1c9242587d79ad8\n  , plaintext = 0xf21df1e99a781dba4a68ff3491848f99\n  , ciphertext = 0xe4e8c9e4963a44f5cf27767e4e42fa61\n  },\n\n  { key = 0x989b9545625a4025f7725d63847213883843d17f924d5a931eee525bc99560b9\n  , plaintext = 0xe4e8c9e4963a44f5cf27767e4e42fa61\n  , ciphertext = 0x27475121d0e3367d0e0c2d9fb39cfe95\n  },\n\n  { key = 0xf49b61f190f982aa866d5c8f2e5749781f04805e42ae6cee10e27fc47a099e2c\n  , plaintext = 0x27475121d0e3367d0e0c2d9fb39cfe95\n  , ciphertext = 0xc2990626cb34c5d7fafe0430650ed907\n  },\n\n  { key = 0x101537d5f633ad8dc7e8cc058ce7fe20dd9d8678899aa939ea1c7bf41f07472b\n  , plaintext = 0xc2990626cb34c5d7fafe0430650ed907\n  , ciphertext = 0x1c5d0cca2845b66c371c1760f81e024a\n  },\n\n  { key = 0x1f6acaa66674733d28dfec92c43c7e76c1c08ab2a1df1f55dd006c94e7194561\n  , plaintext = 0x1c5d0cca2845b66c371c1760f81e024a\n  , ciphertext = 0x6f5a53addd93c9a136401a804a710419\n  },\n\n  { key = 0xb55bdefe370646699012062df748b6aaae9ad91f7c4cd6f4eb407614ad684178\n  , plaintext = 0x6f5a53addd93c9a136401a804a710419\n  , ciphertext = 0x8e0c070be7109ead0e8cc0aa0bf95e61\n  },\n\n  { key = 0xde09c34a85d56a2748559c309f04eb722096de149b5c4859e5ccb6bea6911f19\n  , plaintext = 0x8e0c070be7109ead0e8cc0aa0bf95e61\n  , ciphertext = 0xdb53b5306561db899a635a56c56e7239\n  },\n\n  { key = 0x2650ecd133a5df3825072a4df2d95d15fbc56b24fe3d93d07fafece863ff6d20\n  , plaintext = 0xdb53b5306561db899a635a56c56e7239\n  , ciphertext = 0x72e5ac05990d3f5508295f95f8973313\n  },\n\n  { key = 0xa8599f0edd6446b4bb9371e380bf33488920c7216730ac857786b37d9b685e33\n  , plaintext = 0x72e5ac05990d3f5508295f95f8973313\n  , ciphertext = 0x86a8332f16f997bc02af5271c64e7e0f\n  },\n\n  { key = 0x672e7b0d497458e260084662c566394e0f88f40e71c93b397529e10c5d26203c\n  , plaintext = 0x86a8332f16f997bc02af5271c64e7e0f\n  , ciphertext = 0x8e53858ce7ad0d25410f886eeeca1e0e\n  },\n\n  { key = 0x73ea41a50cdd5a98644e6f8d974af21381db71829664361c34266962b3ec3e32\n  , plaintext = 0x8e53858ce7ad0d25410f886eeeca1e0e\n  , ciphertext = 0xc6a1d493d607d2cef6aef29ee878c434\n  },\n\n  { key = 0x14969b3ff78ccdd66c53b8027a79563e477aa5114063e4d2c2889bfc5b94fa06\n  , plaintext = 0xc6a1d493d607d2cef6aef29ee878c434\n  , ciphertext = 0xa4973e0cfaf8d6ac6758615fc81e06df\n  },\n\n  { key = 0xd09e2741b9480c2166c9c1832654763de3ed9b1dba9b327ea5d0faa3938afcd9\n  , plaintext = 0xa4973e0cfaf8d6ac6758615fc81e06df\n  , ciphertext = 0x67e3243d8bc81887517708a29a5d9ae5\n  },\n\n  { key = 0x22c65ead303a0395cc9c065ada930ddd840ebf2031532af9f4a7f20109d7663c\n  , plaintext = 0x67e3243d8bc81887517708a29a5d9ae5\n  , ciphertext = 0xde2f35df51644cf5d79984be6c17c14c\n  },\n\n  { key = 0x8679ef0357516245ec489386419646bc5a218aff6037660c233e76bf65c0a770\n  , plaintext = 0xde2f35df51644cf5d79984be6c17c14c\n  , ciphertext = 0x9eaedabb3bd046ec27a2bdafabdbc861\n  },\n\n  { key = 0x6043902c115f107639e7c92ba4952301c48f50445be720e0049ccb10ce1b6f11\n  , plaintext = 0x9eaedabb3bd046ec27a2bdafabdbc861\n  , ciphertext = 0x0cde7e6c1aecbbe996865bf30b178de7\n  },\n\n  { key = 0xaca443a9e31033ea73b1eeda6e7d6ca1c8512e28410b9b09921a90e3c50ce2f6\n  , plaintext = 0x0cde7e6c1aecbbe996865bf30b178de7\n  , ciphertext = 0xba25bf5be1e4c099b9e45eedd7369cb5\n  },\n\n  { key = 0x60362e2b0bf998c875c087c370c4ca4772749173a0ef5b902bfece0e123a7e43\n  , plaintext = 0xba25bf5be1e4c099b9e45eedd7369cb5\n  , ciphertext = 0x805be62789549ce6af74966467f41135\n  },\n\n  { key = 0x6d7f0f7584162a1fa4dd6764548f355af22f775429bbc776848a586a75ce6f76\n  , plaintext = 0x805be62789549ce6af74966467f41135\n  , ciphertext = 0xab6001c6c4c56e8ca393c5fd173505ba\n  },\n\n  { key = 0xd8ecc39ac1d00c53216f6e64e826a7a9594f7692ed7ea9fa27199d9762fb6acc\n  , plaintext = 0xab6001c6c4c56e8ca393c5fd173505ba\n  , ciphertext = 0x3ba3673f4f495dd1541d47c22b7921c5\n  },\n\n  { key = 0x493108f91caedf714652149a2b2030fe62ec11ada237f42b7304da5549824b09\n  , plaintext = 0x3ba3673f4f495dd1541d47c22b7921c5\n  , ciphertext = 0xb24fe17cdc5c8cfa4260c38691b57bfa\n  },\n\n  { key = 0x446af6dd5f58755aeaa0a1226d8c584fd0a3f0d17e6b78d1316419d3d83730f3\n  , plaintext = 0xb24fe17cdc5c8cfa4260c38691b57bfa\n  , ciphertext = 0x86d999a63b96f6c9d9aaf3be6202977b\n  },\n\n  { key = 0x65f92d4e1723d5e58aeb350c79df28de567a697745fd8e18e8ceea6dba35a788\n  , plaintext = 0x86d999a63b96f6c9d9aaf3be6202977b\n  , ciphertext = 0xc4712aa733f9737f91e4ed61609e02f1\n  },\n\n  { key = 0x915cee6af4ea95623f7122acda5e9040920b43d07604fd67792a070cdaaba579\n  , plaintext = 0xc4712aa733f9737f91e4ed61609e02f1\n  , ciphertext = 0x0e8c1a77b280f4c753682768fd6f3b23\n  },\n\n  { key = 0x8e9bb2887fe60d42db4d827f00ba68ff9c8759a7c48409a02a42206427c49e5a\n  , plaintext = 0x0e8c1a77b280f4c753682768fd6f3b23\n  , ciphertext = 0xdccb684d47c480cc1317dcaa451234c0\n  },\n\n  { key = 0xcbf85a6645469e5df882fe840776b6aa404c31ea8340896c3955fcce62d6aa9a\n  , plaintext = 0xdccb684d47c480cc1317dcaa451234c0\n  , ciphertext = 0x9a2c4f07489c14265e33ac031d02b3d8\n  },\n\n  { key = 0x3ea3c33d7439ab3c478c01907f13cda7da607eedcbdc9d4a676650cd7fd41942\n  , plaintext = 0x9a2c4f07489c14265e33ac031d02b3d8\n  , ciphertext = 0x5c8e622ddbd32ee79c17572e8b3ee61c\n  },\n\n  { key = 0x312c5b43263c1af8d1e35c0f24d1004386ee1cc0100fb3adfb7107e3f4eaff5e\n  , plaintext = 0x5c8e622ddbd32ee79c17572e8b3ee61c\n  , ciphertext = 0xc5d2cb3d5b7ff0e23e308967ee074825\n  }]\n\naes256_MCT_decrypt_test_vectors : [100](AESTestVector 256)\naes256_MCT_decrypt_test_vectors =\n  [{ key = 0x2b09ba39b834062b9e93f48373b8dd018dedf1e5ba1b8af831ebbacbc92a2643\n  , ciphertext = 0x89649bd0115f30bd878567610223a59d\n  , plaintext = 0x1f9b9b213f1884fa98b62dd6639fd33b\n  },\n\n  { key = 0x58ac71619fdc3ac73a17f285319e1cd492766ac485030e02a95d971daab5f578\n  , ciphertext = 0x1f9b9b213f1884fa98b62dd6639fd33b\n  , plaintext = 0xaecd334ef8fb0c51b6896ae065d8be28\n  },\n\n  { key = 0xf6e3cca2cd628c10625c62cf08b385743cbb598a7df802531fd4fdfdcf6d4b50\n  , ciphertext = 0xaecd334ef8fb0c51b6896ae065d8be28\n  , plaintext = 0xf1938dd245c055e9c380336ff8450d9d\n  },\n\n  { key = 0xa9ae3bd7d454f19d69289875ff009d16cd28d458383857badc54ce92372846cd\n  , ciphertext = 0xf1938dd245c055e9c380336ff8450d9d\n  , plaintext = 0x42d5c4a13b748800ebfe0f67781dcff1\n  },\n\n  { key = 0xe3bc6232865f0476149be7162ef8fc4b8ffd10f9034cdfba37aac1f54f35893c\n  , ciphertext = 0x42d5c4a13b748800ebfe0f67781dcff1\n  , plaintext = 0x469968a00226f0aae7acfda02b2ce0ae\n  },\n\n  { key = 0x451fbfba7f09b625540822fac8c8e30bc9647859016a2f10d0063c5564196992\n  , ciphertext = 0x469968a00226f0aae7acfda02b2ce0ae\n  , plaintext = 0xeab144d6f80ccfd2fae95d16784718ac\n  },\n\n  { key = 0xf53e21e46a0ec97c980d49d6f4b81ec423d53c8ff966e0c22aef61431c5e713e\n  , ciphertext = 0xeab144d6f80ccfd2fae95d16784718ac\n  , plaintext = 0xe04b91c3f084d733d3d0c1c7c152695a\n  },\n\n  { key = 0x5fb3a2cbdbe6971fcd345961bdcba5f6c39ead4c09e237f1f93fa084dd0c1864\n  , ciphertext = 0xe04b91c3f084d733d3d0c1c7c152695a\n  , plaintext = 0xe47db9b8c7fcc9459fa0a7fc84047b5b\n  },\n\n  { key = 0x6b145436c5ae0dcb2477f94f5bdb037927e314f4ce1efeb4669f07785908633f\n  , ciphertext = 0xe47db9b8c7fcc9459fa0a7fc84047b5b\n  , plaintext = 0xf617d26b55da999d65b2d236358b2e60\n  },\n\n  { key = 0x126752da3d7f9a0ffc1a46ccaa8a3925d1f4c69f9bc46729032dd54e6c834d5f\n  , ciphertext = 0xf617d26b55da999d65b2d236358b2e60\n  , plaintext = 0x066ffea799ad5f09d03cb868deb1591e\n  },\n\n  { key = 0xaa3daafbcd647f0a9eaa027146ab7aded79b383802693820d3116d26b2321441\n  , ciphertext = 0x066ffea799ad5f09d03cb868deb1591e\n  , plaintext = 0x6d28dbb55fb10c1c3226609997a4fb38\n  },\n\n  { key = 0xfed7b5c1f84d3dc185222da3fffac7a1bab3e38d5dd8343ce1370dbf2596ef79\n  , ciphertext = 0x6d28dbb55fb10c1c3226609997a4fb38\n  , plaintext = 0x9dd78987562c9c099d67ccc927fcec13\n  },\n\n  { key = 0xc36db4af0bee11dad6ea59679cfb988c27646a0a0bf4a8357c50c176026a036a\n  , ciphertext = 0x9dd78987562c9c099d67ccc927fcec13\n  , plaintext = 0xb5cc780ec75b8d8c5128c4d26fa520ea\n  },\n\n  { key = 0x7b5aebe66f96867504ee9efd2bd56bda92a81204ccaf25b92d7805a46dcf2380\n  , ciphertext = 0xb5cc780ec75b8d8c5128c4d26fa520ea\n  , plaintext = 0xc715bd2f23b98c66bf56e5680c6037f7\n  },\n\n  { key = 0x81a73bfcacc994f47aeec0d655e0485055bdaf2bef16a9df922ee0cc61af1477\n  , ciphertext = 0xc715bd2f23b98c66bf56e5680c6037f7\n  , plaintext = 0xe00984f9d93551e95ae85cfe4a829b82\n  },\n\n  { key = 0x2678e4ccda2eb6ad7f0e2843020da2d8b5b42bd23623f836c8c6bc322b2d8ff5\n  , ciphertext = 0xe00984f9d93551e95ae85cfe4a829b82\n  , plaintext = 0xbfa487fcb2331afe3ad82e59064b4aae\n  },\n\n  { key = 0x03565af5c267a62e0d2500ead06bc7d90a10ac2e8410e2c8f21e926b2d66c55b\n  , ciphertext = 0xbfa487fcb2331afe3ad82e59064b4aae\n  , plaintext = 0x4c278ca418fd1c5718883da0ba4a066f\n  },\n\n  { key = 0xec719a4ed851c36f806fbc78183026cc4637208a9cedfe9fea96afcb972cc334\n  , ciphertext = 0x4c278ca418fd1c5718883da0ba4a066f\n  , plaintext = 0xceed1c8b96d84951cadf809d3ea1b397\n  },\n\n  { key = 0xf138ad912201beecd15ebe2049f980e588da3c010a35b7ce20492f56a98d70a3\n  , ciphertext = 0xceed1c8b96d84951cadf809d3ea1b397\n  , plaintext = 0xf88aed84bca42a06647d6504a5c48379\n  },\n\n  { key = 0x8da22644e1267212742200dbf6b0ba947050d185b6919dc844344a520c49f3da\n  , ciphertext = 0xf88aed84bca42a06647d6504a5c48379\n  , plaintext = 0xc451b75375d0fec1cc1825eefbcc1372\n  },\n\n  { key = 0x5104213aabaccafe44129632f67cf2dab40166d6c3416309882c6fbcf785e0a8\n  , ciphertext = 0xc451b75375d0fec1cc1825eefbcc1372\n  , plaintext = 0x9a54dfd56bff41ea17bcf08d3761e95b\n  },\n\n  { key = 0x4c7c62be3f5a9d09934940284565e9c92e55b903a8be22e39f909f31c0e409f3\n  , ciphertext = 0x9a54dfd56bff41ea17bcf08d3761e95b\n  , plaintext = 0x76e074c587f112f3ffd17b390fa8cffc\n  },\n\n  { key = 0x9871765871b1dae363fca3961224414a58b5cdc62f4f30106041e408cf4cc60f\n  , ciphertext = 0x76e074c587f112f3ffd17b390fa8cffc\n  , plaintext = 0x5b14fd4c40a127733c20cd84648ec287\n  },\n\n  { key = 0x58e044758e5e4f300eb08f8b6ccd967203a1308a6fee17635c61298cabc20488\n  , ciphertext = 0x5b14fd4c40a127733c20cd84648ec287\n  , plaintext = 0x01c234e2392f42831b1172352f322286\n  },\n\n  { key = 0xffbb7104e110fdfe689f68ffa48b79590263046856c155e047705bb984f0260e\n  , ciphertext = 0x01c234e2392f42831b1172352f322286\n  , plaintext = 0xab142165cb093648938660fd800d8896\n  },\n\n  { key = 0x91aefec30a79b2524b19a611c0c4952da977250d9dc863a8d4f63b4404fdae98\n  , ciphertext = 0xab142165cb093648938660fd800d8896\n  , plaintext = 0x5c28ad9b5721edadc30e09b4541fd724\n  },\n\n  { key = 0x00d0f69c36671a9efeb7b8637e22af38f55f8896cae98e0517f832f050e279bc\n  , ciphertext = 0x5c28ad9b5721edadc30e09b4541fd724\n  , plaintext = 0x5a9ad24fe456f4f766e839a8101373c3\n  },\n\n  { key = 0xb22571c62ee4e0b4ebd7d776703c1345afc55ad92ebf7af271100b5840f10a7f\n  , ciphertext = 0x5a9ad24fe456f4f766e839a8101373c3\n  , plaintext = 0xa30e9a7730628b560c71967bdb35efce\n  },\n\n  { key = 0x1431d01006510179dd13e2a83e1b8b7b0ccbc0ae1eddf1a47d619d239bc4e5b1\n  , ciphertext = 0xa30e9a7730628b560c71967bdb35efce\n  , plaintext = 0x7118cc8a057df7ea9b7fb096decf05d9\n  },\n\n  { key = 0x06104531e2d000fff0cc8336b62e9bb87dd30c241ba0064ee61e2db5450be068\n  , ciphertext = 0x7118cc8a057df7ea9b7fb096decf05d9\n  , plaintext = 0xc550ff93a36fbb8e9a505682e07fb981\n  },\n\n  { key = 0x8e5ebd5c9bf858f3379bfb88c7c75319b883f3b7b8cfbdc07c4e7b37a57459e9\n  , ciphertext = 0xc550ff93a36fbb8e9a505682e07fb981\n  , plaintext = 0x1375e7b4164adc861bbb77c50aba445c\n  },\n\n  { key = 0xccc9445c3aab1c03ec8027593d370664abf61403ae85614667f50cf2afce1db5\n  , ciphertext = 0x1375e7b4164adc861bbb77c50aba445c\n  , plaintext = 0x5bc8b411c0fae92bad54b4e5c3a8826e\n  },\n\n  { key = 0xb804994228d618a9b7a3e0c3d8d2d373f03ea0126e7f886dcaa1b8176c669fdb\n  , ciphertext = 0x5bc8b411c0fae92bad54b4e5c3a8826e\n  , plaintext = 0x36c9de7c01298ff06c5e3ecf12507cd6\n  },\n\n  { key = 0x8a784f32cdd7e2ed19e85faf04de2015c6f77e6e6f56079da6ff86d87e36e30d\n  , ciphertext = 0x36c9de7c01298ff06c5e3ecf12507cd6\n  , plaintext = 0x35d814c0f6c07ae72bbe7cd1751d7527\n  },\n\n  { key = 0x71e3cc0f60a2eafd83c3a455eefc4c9cf32f6aae99967d7a8d41fa090b2b962a\n  , ciphertext = 0x35d814c0f6c07ae72bbe7cd1751d7527\n  , plaintext = 0x73c39ce5ea1b5eab18c9c15221e258d1\n  },\n\n  { key = 0x71bef3d2beffa17d37c6c3b28ef2928280ecf64b738d23d195883b5b2ac9cefb\n  , ciphertext = 0x73c39ce5ea1b5eab18c9c15221e258d1\n  , plaintext = 0xac67508a8bcab69f96ead29121718cd7\n  },\n\n  { key = 0x9aa1ffa9e175f03a6bcc71fc2aea3a522c8ba6c1f847954e0362e9ca0bb8422c\n  , ciphertext = 0xac67508a8bcab69f96ead29121718cd7\n  , plaintext = 0x49d2cac2ca39a3b66302e5f3650e71d7\n  },\n\n  { key = 0x4e480b73ab5c659538354b2474c9367b65596c03327e36f860600c396eb633fb\n  , ciphertext = 0x49d2cac2ca39a3b66302e5f3650e71d7\n  , plaintext = 0xe54638674ea0b3e837772a2866723753\n  },\n\n  { key = 0xaeecd55c38bef76367a21469d08721d2801f54647cde85105717261108c404a8\n  , ciphertext = 0xe54638674ea0b3e837772a2866723753\n  , plaintext = 0x074d933018e9e0558b416e39548994ff\n  },\n\n  { key = 0xe36c6a30f734a679ab7af2f9ff767cfe8752c75464376545dc5648285c4d9057\n  , ciphertext = 0x074d933018e9e0558b416e39548994ff\n  , plaintext = 0x04825a9ba20646acadb2cbdbd23530c0\n  },\n\n  { key = 0x124806708fc5fc73a1e50c61e5a76b8783d09dcfc63123e971e483f38e78a097\n  , ciphertext = 0x04825a9ba20646acadb2cbdbd23530c0\n  , plaintext = 0x25b98d2837580f9f3da8f2593f7b1d72\n  },\n\n  { key = 0x560afb5529a8b433738348a296408cada66910e7f1692c764c4c71aab103bde5\n  , ciphertext = 0x25b98d2837580f9f3da8f2593f7b1d72\n  , plaintext = 0x048b220c70d875cad6901e40f45c5b03\n  },\n\n  { key = 0x8b7c61dd007d9d0d1937cfc69b63c114a2e232eb81b159bc9adc6fea455fe6e6\n  , ciphertext = 0x048b220c70d875cad6901e40f45c5b03\n  , plaintext = 0x34e2a33412c0e682b29b26d5409d015f\n  },\n\n  { key = 0x30560ca0a31d8145228d34fbf8415683960091df9371bf3e2847493f05c2e7b9\n  , ciphertext = 0x34e2a33412c0e682b29b26d5409d015f\n  , plaintext = 0x942c057914f3b88fa0a40bb41d02b051\n  },\n\n  { key = 0x20c7e6e45c08ba0756c379b6cd4d6886022c94a6878207b188e3428b18c057e8\n  , ciphertext = 0x942c057914f3b88fa0a40bb41d02b051\n  , plaintext = 0x6f4e5c40e4135abfdf294b4d8c9304b3\n  },\n\n  { key = 0x2a6c928bf8c2b32ce82ed0be1bc954b96d62c8e663915d0e57ca09c69453535b\n  , ciphertext = 0x6f4e5c40e4135abfdf294b4d8c9304b3\n  , plaintext = 0xcac032ddc2b27443d70d0f2dfb1a1d87\n  },\n\n  { key = 0x74994d46526b2e9d5470a0a687f726f2a7a2fa3ba123294d80c706eb6f494edc\n  , ciphertext = 0xcac032ddc2b27443d70d0f2dfb1a1d87\n  , plaintext = 0x6aec33b2c1ae39237b13e86555722d1a\n  },\n\n  { key = 0x5aaec28d079eef5f1c42df377c7e80accd4ec989608d106efbd4ee8e3a3b63c6\n  , ciphertext = 0x6aec33b2c1ae39237b13e86555722d1a\n  , plaintext = 0x2df34173bbff331488b23687c755f617\n  },\n\n  { key = 0x9bfa3c08b8f8b8758f0a1f4b0ef86be4e0bd88fadb72237a7366d809fd6e95d1\n  , ciphertext = 0x2df34173bbff331488b23687c755f617\n  , plaintext = 0x07649dd5c1c7b38810cbecbad9c037ed\n  },\n\n  { key = 0x188e3a027b75fede978c76e70a853f95e7d9152f1ab590f263ad34b324aea23c\n  , ciphertext = 0x07649dd5c1c7b38810cbecbad9c037ed\n  , plaintext = 0xef3d9092321649d9bbb88f6448e3847b\n  },\n\n  { key = 0xaae2c6363be3dbb71c21f3a2d9f123f108e485bd28a3d92bd815bbd76c4d2647\n  , ciphertext = 0xef3d9092321649d9bbb88f6448e3847b\n  , plaintext = 0x1e5058b3e986d4aad80a11f909af1cca\n  },\n\n  { key = 0x85a51c6d62ba97564ac955a5409c362916b4dd0ec1250d81001faa2e65e23a8d\n  , ciphertext = 0x1e5058b3e986d4aad80a11f909af1cca\n  , plaintext = 0x9bf81052596b786b50b3f3506c009169\n  },\n\n  { key = 0x0d09600f108a86cfd58f3c211a40c38d8d4ccd5c984e75ea50ac597e09e2abe4\n  , ciphertext = 0x9bf81052596b786b50b3f3506c009169\n  , plaintext = 0x81bdaf86cf4255e5826294a51d2f9992\n  },\n\n  { key = 0x14ab478866e1d160311aa8820df354fb0cf162da570c200fd2cecddb14cd3276\n  , ciphertext = 0x81bdaf86cf4255e5826294a51d2f9992\n  , plaintext = 0x1fdc5fee9eb640ff547a98d9e1601b52\n  },\n\n  { key = 0x39f18405f0b1da647f99479e87d4d153132d3d34c9ba60f086b45502f5ad2924\n  , ciphertext = 0x1fdc5fee9eb640ff547a98d9e1601b52\n  , plaintext = 0x936609876cd6eebf31db5a6af7839844\n  },\n\n  { key = 0x85a900bc1563b16e01481e45d1125734804b34b3a56c8e4fb76f0f68022eb160\n  , ciphertext = 0x936609876cd6eebf31db5a6af7839844\n  , plaintext = 0x9ea8b6942287f470e9866a48f4dc661a\n  },\n\n  { key = 0xc43d677fc0a1becbb0214221b866f0be1ee3822787eb7a3f5ee96520f6f2d77a\n  , ciphertext = 0x9ea8b6942287f470e9866a48f4dc661a\n  , plaintext = 0x1dfc2cf82bfaa2732eb525916ef9ef13\n  },\n\n  { key = 0x584f10659c2d3c41f6a1926de4595eb2031faedfac11d84c705c40b1980b3869\n  , ciphertext = 0x1dfc2cf82bfaa2732eb525916ef9ef13\n  , plaintext = 0xa5d8d1d60281a152b9b76142e3e5a512\n  },\n\n  { key = 0x8eba336927e18b13eb3858a89709768ba6c77f09ae90791ec9eb21f37bee9d7b\n  , ciphertext = 0xa5d8d1d60281a152b9b76142e3e5a512\n  , plaintext = 0x8ac0278f2ab100a5964173d76934d732\n  },\n\n  { key = 0x13f1558dcae09062bfdccdd0037e5c432c075886842179bb5faa522412da4a49\n  , ciphertext = 0x8ac0278f2ab100a5964173d76934d732\n  , plaintext = 0x30233b70c4d6fd31b23cc77bc73559ea\n  },\n\n  { key = 0xd736669842aa88f43f1de421d38f391f1c2463f640f7848aed96955fd5ef13a3\n  , ciphertext = 0x30233b70c4d6fd31b23cc77bc73559ea\n  , plaintext = 0x766630dfd41e4146a827f55cba745b6a\n  },\n\n  { key = 0x0ca8353df90e73606588a11675bd37a76a42532994e9c5cc45b160036f9b48c9\n  , ciphertext = 0x766630dfd41e4146a827f55cba745b6a\n  , plaintext = 0x177f22d98f009c214a44b08cf40b790d\n  },\n\n  { key = 0x136ec3a1a65ee7bb0fd09af7364b66607d3d71f01be959ed0ff5d08f9b9031c4\n  , ciphertext = 0x177f22d98f009c214a44b08cf40b790d\n  , plaintext = 0xe9c916a21dec9662bdd91a0f865f8b47\n  },\n\n  { key = 0xba5c2bd413daca7866de11c11db2926694f467520605cf8fb22cca801dcfba83\n  , ciphertext = 0xe9c916a21dec9662bdd91a0f865f8b47\n  , plaintext = 0x92b3ab3e28f6c606508706e0c3d76d28\n  },\n\n  { key = 0x0fab4768fa7f104a3579f534508182920647cc6c2ef30989e2abcc60de18d7ab\n  , ciphertext = 0x92b3ab3e28f6c606508706e0c3d76d28\n  , plaintext = 0x3652053dcba591f101944fb1a5eb2b99\n  },\n\n  { key = 0xe766aa23c075deaa6fae68384f5b205e3015c951e5569878e33f83d17bf3fc32\n  , ciphertext = 0x3652053dcba591f101944fb1a5eb2b99\n  , plaintext = 0x242260d2387c6f1a415834b34e300a7e\n  },\n\n  { key = 0x9f1941442336bfffa1d6b27dce7845971437a983dd2af762a267b76235c3f64c\n  , ciphertext = 0x242260d2387c6f1a415834b34e300a7e\n  , plaintext = 0xa2a58ed050231b0d15f8cd99f5e171fb\n  },\n\n  { key = 0x429a3cdc98124fafe33156a66b4e8c2ab69227538d09ec6fb79f7afbc02287b7\n  , ciphertext = 0xa2a58ed050231b0d15f8cd99f5e171fb\n  , plaintext = 0xec6631b17e5c97193fd9651b64feffe7\n  },\n\n  { key = 0x92764a89e0de63823b9d9a5a001868035af416e2f3557b7688461fe0a4dc7850\n  , ciphertext = 0xec6631b17e5c97193fd9651b64feffe7\n  , plaintext = 0x1eef8afa419a9341085a2d611185e42c\n  },\n\n  { key = 0x0c0bf13d79d1297e137e6f5995cb0a2c441b9c18b2cfe837801c3281b5599c7c\n  , ciphertext = 0x1eef8afa419a9341085a2d611185e42c\n  , plaintext = 0xd4eb4e591cf856b816e2207264e426e4\n  },\n\n  { key = 0xde31f995867bb45813d369349cb7434290f0d241ae37be8f96fe12f3d1bdba98\n  , ciphertext = 0xd4eb4e591cf856b816e2207264e426e4\n  , plaintext = 0x401e14b126348e1aedd13662a19c23fb\n  },\n\n  { key = 0x3b1a02b5600444db09118e99765fa61dd0eec6f0880330957b2f249170219963\n  , ciphertext = 0x401e14b126348e1aedd13662a19c23fb\n  , plaintext = 0x38bfea7e1eece741eb6a9601605129dd\n  },\n\n  { key = 0x1fbcf4ffb36f76b88323f745b3152947e8512c8e96efd7d49045b2901070b0be\n  , ciphertext = 0x38bfea7e1eece741eb6a9601605129dd\n  , plaintext = 0x71cd66b3b3553b6aa632c338a307e11a\n  },\n\n  { key = 0xb963bfe1c513f0dba7e24b5cfa1535a3999c4a3d25baecbe367771a8b37751a4\n  , ciphertext = 0x71cd66b3b3553b6aa632c338a307e11a\n  , plaintext = 0x34c2972d43e59eb0c44b7b69a540e7de\n  },\n\n  { key = 0x23458e2a4332ce00e7967a438cd86448ad5edd10665f720ef23c0ac11637b67a\n  , ciphertext = 0x34c2972d43e59eb0c44b7b69a540e7de\n  , plaintext = 0x8988b878d0c6a84b6262351e033fb1b7\n  },\n\n  { key = 0xe552b8a0f474a8da502e749e3f0639b124d66568b699da45905e3fdf150807cd\n  , ciphertext = 0x8988b878d0c6a84b6262351e033fb1b7\n  , plaintext = 0x010e24d01c37edca127484c8d8137772\n  },\n\n  { key = 0x65a0645dd971bdb3b0d3a079ef96f3a925d841b8aaae378f822abb17cd1b70bf\n  , ciphertext = 0x010e24d01c37edca127484c8d8137772\n  , plaintext = 0x6c7b2e83630a8c8b6219839297d7c647\n  },\n\n  { key = 0x9867d55ae9f56a03c435f4b25f2eee2c49a36f3bc9a4bb04e03338855accb6f8\n  , ciphertext = 0x6c7b2e83630a8c8b6219839297d7c647\n  , plaintext = 0xccba81435ecf162f70d30b3163cb3858\n  },\n\n  { key = 0xe4a3addb683bbe85ed84b3ce044bcc538519ee78976bad2b90e033b439078ea0\n  , ciphertext = 0xccba81435ecf162f70d30b3163cb3858\n  , plaintext = 0xa0575bc9b8931f34cd6072e2015e7331\n  },\n\n  { key = 0x6f543088bf24577d55a685e3637d85e8254eb5b12ff8b21f5d8041563859fd91\n  , ciphertext = 0xa0575bc9b8931f34cd6072e2015e7331\n  , plaintext = 0xa44046a87574e6d3e6c6446fb3c324bc\n  },\n\n  { key = 0x5fff671ca24c3b241ddb92761f02dfe3810ef3195a8c54ccbb4605398b9ad92d\n  , ciphertext = 0xa44046a87574e6d3e6c6446fb3c324bc\n  , plaintext = 0xef6abb8ae007b730be45aa85e39f362d\n  },\n\n  { key = 0xdb897d48a317f66412a8c52111c3f3b06e644893ba8be3fc0503afbc6805ef00\n  , ciphertext = 0xef6abb8ae007b730be45aa85e39f362d\n  , plaintext = 0xe5bd2edfb7e563f6cd86da757c4c370f\n  },\n\n  { key = 0x78aec1da8e8e79007af12c05d800a18d8bd9664c0d6e800ac88575c91449d80f\n  , ciphertext = 0xe5bd2edfb7e563f6cd86da757c4c370f\n  , plaintext = 0x33caa267a64fb3cac210271bb8f25369\n  },\n\n  { key = 0x2c3e5387a51addb0b7789ef0289109b3b813c42bab2133c00a9552d2acbb8b66\n  , ciphertext = 0x33caa267a64fb3cac210271bb8f25369\n  , plaintext = 0x27bb26990ca5e12d387bd659cb7e7860\n  },\n\n  { key = 0x85685fe6996d514e5928d7196f41b5d29fa8e2b2a784d2ed32ee848b67c5f306\n  , ciphertext = 0x27bb26990ca5e12d387bd659cb7e7860\n  , plaintext = 0xd866ace71916e00c1559bba4149380a0\n  },\n\n  { key = 0x82abcc9a00bae55087cf5d87413f095547ce4e55be9232e127b73f2f735673a6\n  , ciphertext = 0xd866ace71916e00c1559bba4149380a0\n  , plaintext = 0x8a4d6a0af8488a82a0c31332db3e36de\n  },\n\n  { key = 0x81d983ce59413e84d7af4558d2e3941ccd83245f46dab86387742c1da8684578\n  , ciphertext = 0x8a4d6a0af8488a82a0c31332db3e36de\n  , plaintext = 0x05f6ff378b837cd375cddfae79ec2a9d\n  },\n\n  { key = 0xbbe6d0d13a6b146bb23db6885ba66487c875db68cd59c4b0f2b9f3b3d1846fe5\n  , ciphertext = 0x05f6ff378b837cd375cddfae79ec2a9d\n  , plaintext = 0xb706bdb4019d604cc35faa07197c318d\n  },\n\n  { key = 0x8092df6673b2b77783f2ba73c22e8d3c7f7366dcccc4a4fc31e659b4c8f85e68\n  , ciphertext = 0xb706bdb4019d604cc35faa07197c318d\n  , plaintext = 0xb26354bc77d3ce16909ca505d2381e4c\n  },\n\n  { key = 0x3118fc57b93677af8e14c1b5961b76f3cd103260bb176aeaa17afcb11ac04024\n  , ciphertext = 0xb26354bc77d3ce16909ca505d2381e4c\n  , plaintext = 0x1515ef6a25cf3943eadadc36a029194a\n  },\n\n  { key = 0xc4bde4a0c5f80329be6dd515f5bf6dabd805dd0a9ed853a94ba02087bae9596e\n  , ciphertext = 0x1515ef6a25cf3943eadadc36a029194a\n  , plaintext = 0x7b4ad946dfb59c80b1dc5cedb2fa87a0\n  },\n\n  { key = 0x80b47f9126b0b1f5ab408bb9ea5f349aa34f044c416dcf29fa7c7c6a0813dece\n  , ciphertext = 0x7b4ad946dfb59c80b1dc5cedb2fa87a0\n  , plaintext = 0xfa10a53e14cde5ef1e9a8a5692847aa5\n  },\n\n  { key = 0x86a43939c8cd243f7ff2a9658524373b595fa17255a02ac6e4e6f63c9a97a46b\n  , ciphertext = 0xfa10a53e14cde5ef1e9a8a5692847aa5\n  , plaintext = 0x4c9bed07308abcd0b09265b5efbe301c\n  },\n\n  { key = 0x74a8f02a15285153e0ae160fbddcf6bf15c44c75652a96165474938975299477\n  , ciphertext = 0x4c9bed07308abcd0b09265b5efbe301c\n  , plaintext = 0x75b7496c42809a3a592acbd8e069269e\n  },\n\n  { key = 0x293b40a2f70cc2c4262554663fb6f0986073051927aa0c2c0d5e58519540b2e9\n  , ciphertext = 0x75b7496c42809a3a592acbd8e069269e\n  , plaintext = 0x2dbc01185af7e084d90578468b6b10ef\n  },\n\n  { key = 0xb04d4f4eb708eef86c5b6b8e08a665084dcf04017d5deca8d45b20171e2ba206\n  , ciphertext = 0x2dbc01185af7e084d90578468b6b10ef\n  , plaintext = 0xc95b3a9f689c9dce4995c24f72dd5162\n  },\n\n  { key = 0x7cb9f7211815e0cb48b71286f84f80a184943e9e15c171669dcee2586cf6f364\n  , ciphertext = 0xc95b3a9f689c9dce4995c24f72dd5162\n  , plaintext = 0x616e55c3bf113e2c18cae3c61b7eb7d1\n  },\n\n  { key = 0xb3cdb46cf92aa0b96e87212bc650d5e5e5fa6b5daad04f4a8504019e778844b5\n  , ciphertext = 0x616e55c3bf113e2c18cae3c61b7eb7d1\n  , plaintext = 0x87e8b80767ebbdbad75cb94f4cb54f3b\n  },\n\n  { key = 0x512c2a3821eb53af613141c71e1076656212d35acd3bf2f05258b8d13b3d0b8e\n  , ciphertext = 0x87e8b80767ebbdbad75cb94f4cb54f3b\n  , plaintext = 0xc83e20e18f2b1457788954b49fd84307\n  },\n\n  { key = 0x9977c985745bc33954a2ce898bc8febdaa2cf3bb4210e6a72ad1ec65a4e54889\n  , ciphertext = 0xc83e20e18f2b1457788954b49fd84307\n  , plaintext = 0xe3d3868f578caf34e36445bf14cefc68\n  }]\n```"}]}
{"filename":"cryptol\/tests\/regression\/twinmult.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Using the elliptic-curve utilities from the PrimeEC library, define the following in Cryptol over the curve parameter 7: (1) Define the constant named zro with type ProjectivePoint 7 representing the projective neutral element (point at infinity). (2) Define a property twin_mult_zro that, for arbitrary scalars j and k, verifies that twin scalar multiplication of j and k by the neutral element yields the neutral element, using the library\u2019s equality predicate for this curve. (3) Define a property twin_mult_zro1 that, for arbitrary scalars j and k and any projective point S on the same curve, verifies that twin scalar multiplication with the first input point equal to the neutral element equals single scalar multiplication of S by k. (4) Define a property twin_mult_zro2 that verifies the symmetric case where the second input point is the neutral element equals single scalar multiplication of S by j. (5) Define a property twin_mult_same that verifies twin scalar multiplication applied to the same point in both slots equals the elliptic-curve addition of the separate scalar multiples by j and k. (6) Define a property twin_mult_neg that verifies twin scalar multiplication where the second input point is the negation of the first equals the elliptic-curve subtraction of the corresponding scalar multiples. Use the library operations for twin multiplication, single multiplication, point equality, addition, subtraction, and negation. State parameter and variable types: j and k are curve-appropriate scalars; S is a ProjectivePoint 7. Do not implement algorithms; only specify the constant and the properties as described."},{"role":"assistant","content":"```cryptol\nimport PrimeEC\n\nzro : ProjectivePoint 7\nzro = { x = 1, y = 1, z = 0 }\n\nproperty twin_mult_zro j k =\n  ec_equal`{7} (ec_twin_mult j zro k zro) zro\n\nproperty twin_mult_zro1 j k S =\n  ec_equal`{7} (ec_twin_mult j zro k S) (ec_mult k S)\n\nproperty twin_mult_zro2 j k S =\n  ec_equal`{7} (ec_twin_mult j S k zro) (ec_mult j S)\n\nproperty twin_mult_same j k S =\n  ec_equal`{7} (ec_twin_mult j S k S) (ec_add (ec_mult j S) (ec_mult k S))\n\nproperty twin_mult_neg j k S =\n  ec_equal`{7} (ec_twin_mult j S k (ec_negate S)) (ec_sub (ec_mult j S) (ec_mult k S))\n```"}]}
{"filename":"cryptol\/tests\/regression\/word-update.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define four Cryptol properties named wordUpdate, wordUpdate2, wordUpdateEnd, and wordUpdateEnd2. Each property takes three parameters: a 16-bit word x, an 8-bit index y, and a single bit b, and is conditioned on the precondition y < 16. For wordUpdate, define a property that verifies that updating bit position y counted from the most-significant end equals: if b is 1, the bitwise OR of x with a mask containing a single 1 at the most-significant position shifted right by y; otherwise, the bitwise AND of x with the bitwise complement of that mask. For wordUpdate2, define a property that verifies that the same update equals reconstructing the 16-bit word by iterating indices 0 through 15 (most-significant end first), writing b at index y and copying all other bits from x using most-significant-first indexing. For wordUpdateEnd, define a property that verifies that updating bit position y counted from the least-significant end equals: if b is 1, the bitwise OR of x with a mask containing a single 1 at the least-significant position shifted left by y; otherwise, the bitwise AND of x with the bitwise complement of that mask. For wordUpdateEnd2, define a property that verifies that the same least-significant-end update equals reconstructing the word by enumerating all bit positions and replacing only the least-significant-end index y with b, using least-significant-first indexing for reads."},{"role":"assistant","content":"```cryptol\nproperty wordUpdate (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> update x y b == if b then x || msk else x && ~msk\n\n where\n msk = 0b1000000000000000 >> y\n\nproperty wordUpdate2 (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> update x y b == x'\n\n where\n x' = [ if i == y then b else x@i | i <- [0 .. 15] ]\n\nproperty wordUpdateEnd (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> updateEnd x y b == if b then x || msk else x && ~msk\n\n where\n msk = 0b0000000000000001 << y\n\nproperty wordUpdateEnd2 (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> updateEnd x y b == x'\n\n where\n x' = [ if i == y then b else x!i | i <- reverse [0 .. 15] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/f2polytest.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that verifies local polynomial multiply, divide, and modulus over GF(2) bit-polynomials against trusted reference implementations. Define three Boolean-valued equivalence checker functions, each polymorphic over size parameters u and v with fin constraints: (1) a multiplication checker that takes two sequences of lengths 1+u and 1+v and returns true iff the local multiplication equals the reference result; (2) a division checker that takes two sequences of lengths u and v and returns true if the divisor is zero or the local division equals the reference result; (3) a modulus checker that takes sequences of lengths u and 1+v and returns true if the modulus divisor is zero or the local modulus equals the reference result. Import the reference operations from the project\u2019s reference library and compare local results to those references. Then define properties (for SAT checking) that instantiate these three checkers at the following size pairs: (3,9), (9,3), (8,8), (28,11), (32,32), and (64,64). Provide properties for all three operations at each size pair, each created by specializing the corresponding checker at the given sizes. Do not implement the underlying arithmetic; only define the checkers, constraints, types, and properties as described."},{"role":"assistant","content":"```cryptol\nimport Cryptol::Reference as Ref\n\npmult_equiv : {u, v} (fin u, fin v) => [1+u] -> [1+v] -> Bit\npmult_equiv x y = pmult x y == Ref::pmult x y\n\npdiv_equiv : {u, v} (fin u, fin v) => [u] -> [v] -> Bit\npdiv_equiv x y = y == 0 \\\/ pdiv x y == Ref::pdiv x y\n\npmod_equiv : {u, v} (fin u, fin v) => [u] -> [1+v] -> Bit\npmod_equiv x y = y == 0 \\\/ pmod x y == Ref::pmod x y\n\nproperty mult3_9   = pmult_equiv`{3,9}\nproperty mult9_3   = pmult_equiv`{9,3}\nproperty mult8_8   = pmult_equiv`{8,8}\nproperty mult28_11 = pmult_equiv`{28,11}\nproperty mult32_32 = pmult_equiv`{32,32}\nproperty mult64_64 = pmult_equiv`{64,64}\n\nproperty div3_9   = pdiv_equiv`{3,9}\nproperty div9_3   = pdiv_equiv`{9,3}\nproperty div8_8   = pdiv_equiv`{8,8}\nproperty div28_11 = pdiv_equiv`{28,11}\nproperty div32_32 = pdiv_equiv`{32,32}\nproperty div64_64 = pdiv_equiv`{64,64}\n\nproperty mod3_9   = pmod_equiv`{3,9}\nproperty mod9_3   = pmod_equiv`{9,3}\nproperty mod8_8   = pmod_equiv`{8,8}\nproperty mod28_11 = pmod_equiv`{28,11}\nproperty mod32_32 = pmod_equiv`{32,32}\nproperty mod64_64 = pmod_equiv`{64,64}\n```"}]}
{"filename":"cryptol\/tests\/regression\/r01.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two polymorphic Cryptol functions named any and all. Each takes a predicate from an element to a bit and a finite-length vector of n elements, returning a single bit. Use a size parameter n with a fin n constraint and a universally-quantified element type. Implement both by first mapping the predicate over the input vector to produce an n-bit vector. Then: any returns true if and only if this bit vector is not equal to the all-zero n-bit vector; all returns true if and only if this bit vector is equal to the all-ones n-bit vector (the bitwise complement of the all-zero vector). Provide explicit type signatures capturing the fin n constraint, the predicate type, the vector type, and the Bit result, and define the function bodies accordingly."},{"role":"assistant","content":"```cryptol\nany : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nany f xs = [ f x | x <- xs ] != zero\n\nall : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nall f xs = [ f x | x <- xs ] == ~zero\n```"}]}
{"filename":"cryptol\/tests\/regression\/r05.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol function named unflatten with size parameters r and w. Provide a polymorphic type signature with constraints that r and w are finite and that 5*w >= r. The function must take a sequence of r bits and return a sequence of w elements, each being a 5-bit word. Implement the behavior by appending zero bits to the end of the input until its length is exactly 5*w, then partition the result into consecutive chunks of 5 bits, preserving order, to produce the w-length sequence. State all constraints in the type and use standard sequence concatenation and chunking operations. Do not alter existing bits other than zero-padding at the end."},{"role":"assistant","content":"```cryptol\nunflatten : {r, w}\n            (fin r, 5 * w >= r, fin w)\n            => [r] -> [w][5]\nunflatten p = groupBy`{5}(p # zero)\n```"}]}
{"filename":"cryptol\/tests\/regression\/check22.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) an 8-bit constant named irred with value 0x1b; (2) a function xtimes that takes an 8-bit word, left-shifts it by one bit, and if the original most significant bit was 1, XORs the shifted value with irred; otherwise it returns the shifted value. Use bit indexing of the MSB and the word\u2019s length to detect the carry-out. (3) a function gtimes that takes a pair of 8-bit words and returns their product in GF(2^8) using the Russian peasant method: if the multiplier is zero return zero; otherwise recursively multiply with the multiplier right-shifted by one, apply xtimes to the recursive result, and XOR with the multiplicand when the multiplier\u2019s least significant bit is 1 (else XOR with zero). (4) a boolean named check22 that evaluates whether applying gtimes with multiplicand 13 to each of 1, 12, and 192 yields exactly 13, 92, and 183, respectively."},{"role":"assistant","content":"```cryptol\nirred : [8]\nirred = 0x1b\nxtimes a = (if a ! (length a - 1) then a' ^ irred else a')\n  where a' = a << 1\n\ngtimes : ([8], [8]) -> [8]\ngtimes (a, b)\n  = (if b == 0 then 0 else xtimes (gtimes (a, b >> 1)) ^ a')\n      where a' = if b ! 0 then a else 0\n\ncheck22 = [ gtimes (13, x) | x <- [ 1, 12, 192 ] ] == [ 13, 92, 183 ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check23.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a size-parameterized function named pad that takes a bitvector of length msgLen and returns a bitvector of length chunks*512, implementing Merkle\u2013Damg\u00e5rd-style padding: concatenate the original bits, a single 1-bit set to true, a zero-filled vector of length padding, and a 64-bit big-endian encoding of the original message length. Constrain the size parameters as follows: msgLen and padding are finite; contentLen equals msgLen plus 65 (for the 1 bit and the 64-bit length); chunks equals the ceiling of contentLen\/512 expressed as (contentLen + 511) \/ 512; the bit-width needed to represent msgLen is at most 64; and padding equals (512 \u2212 (contentLen mod 512)) mod 512. Ensure the encoded length is exactly 64 bits and is the length of the input message. Then define a 4-bit constant named tmsg with value 13, a 512-bit constant named out with the given hexadecimal value, and a boolean definition named check23 that is true exactly when applying pad to tmsg yields out."},{"role":"assistant","content":"```cryptol\npad : {msgLen, padding, contentLen, chunks}\n    ( fin msgLen\n    , fin padding\n    , contentLen == msgLen + 65\n    , chunks == (contentLen + 511) \/ 512\n    , 64 >= width msgLen\n    , padding == (512 - contentLen % 512) % 512\n    ) => [msgLen] -> [chunks * 512]\npad msg = msg # [True] # (zero:[padding]) # sz        where  sz : [64]\n             sz = (length msg):[64]\n\ntmsg : [4]\ntmsg = 13\nout : [512]\nout = 0xd8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004\ncheck23 = pad tmsg == out\n```"}]}
{"filename":"cryptol\/tests\/regression\/check09.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models two mutually recursive streams of 32-bit words driven by single-element 32-bit seeds and verifies their outputs. Do the following: 1) Declare two seeds as single-element sequences of 32-bit zeros. 2) Define an infinite stream X where each element is the 32-bit rotate-left-by-3 of the sum (mod 2^32) of: the previous element of X (using 0 at the start), a sequence that is 1 at the start then follows X, and a sequence that is 0 at the start then follows Y. 3) Define an infinite stream Y where each element is the rotate-left by (current X + previous Y-with-initial-0) of the sum (mod 2^32) of: the previous element of Y (seeded initially), the current element of X, and the previous Y-with-initial-0. 4) Define a function with type [4][8] -> [7][32] that: takes 4 bytes, concatenates them to a 32-bit word, uses that as the initial seed for Y (as a single-element sequence), recomputes X and Y as above, and returns the first seven elements of X. 5) Define a property that asserts the first four elements of X equal an expected 4-element 32-bit vector and the first four elements of Y equal another expected 4-element 32-bit vector. 6) Define a property that asserts that applying the function to a specific 4-byte ASCII key whose bytes are reversed yields an expected 7-element 32-bit vector. 7) Define a final property that is the conjunction of the two properties. Keep all operations word-sized; use Cryptol\u2019s rotate-left and addition on 32-bit words; use indexed selection to take the first N elements."},{"role":"assistant","content":"```cryptol\ninitS : [1][32]\ninitL : [1][32]\ninitS = [0]\ninitL = [0]\nss = [ (s + a + b) <<< 3   | s <- initS # ss\n\t                       | a <- [1] # ss\n\t                       | b <- [0] # ls ]\nls = [ (l + a + b) <<< (a + b)\n                        | l <- initL # ls\n\t\t                | a <- ss\n\t\t                | b <- [0] # ls ]\n\ncheck9a = (ss @@ [0 .. 3] == [ 0x00000008, 0x00004080, 0x00068c00, 0x00a22800 ])\n       && (ls @@ [0 .. 3] == [ 0x00000800, 0x00005080, 0x00072d00, 0x00b08200 ])\n\nkeyX : [4][8] -> [7][32]\nkeyX key = ss @@ [ 0 .. 6 ]\n  where\n    initS : [1][32]\n    initL : [1][32]\n    initS = [0]\n    initL = split (join key)\n    ss = [ (s + a + b) <<< 3\n                    | s <- initS # ss\n\t\t\t\t    | a <- [1] # ss\n\t\t\t\t    | b <- [0] # ls ]\n    ls = [ (l + a + b) <<< (a + b)\n                    | l <- initL # ls\n\t\t\t\t    | a <- ss\n\t\t\t\t    | b <- [0] # ls ]\n\ncheck9b = keyX (reverse \"abcd\") ==\n\t    [0x00000008, 0x1b134ba3, 0x11ae69b1, 0xb7b3f42f,\n             0xc9eb1fdc, 0x008b5f36, 0x8991bc8c]\n\ncheck9 = check9a && check9b\n```"}]}
{"filename":"cryptol\/tests\/regression\/check21.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) defines an 8-bit constant equal to the irreducible polynomial used for AES GF(2^8) reduction; (2) defines a function of type [8] -> [8] that multiplies an 8-bit value by x in GF(2^8) by left-shifting one bit and, if the original most-significant bit was set, XORing the shifted value with the reduction constant; and (3) defines a top-level Boolean that asserts the list obtained by applying this function to the sample inputs [1, 12, 192] equals the expected outputs [2, 24, 155]. Do not use the property keyword; the final check should be a Boolean value."},{"role":"assistant","content":"```cryptol\nirred : [8]\nirred = 0x1b\nxtimes a = (if a ! (length a - 1) then a' ^ irred else a')\n  where a' = a << 1\n\ncheck21 = [ xtimes y | y <- [ 1, 12, 192 ] ] == [ 2, 24, 155 ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a boolean constant that evaluates whether the element-wise sum of two three-dimensional sequences of numeric literals (each with an outer length of 1 containing a 2\u00d72 inner matrix) equals a third sequence of the same shape containing the corresponding pairwise sums. Use Cryptol\u2019s sequence addition to add the two arrays pointwise and an equality check to compare against the expected result. The constant\u2019s type is Bit (Boolean), and the element type is a consistent, finite-width unsigned numeric type inferred from the literals. All shapes are fixed and identical across operands and the expected result."},{"role":"assistant","content":"```cryptol\ncheck20 = [ [ [ 1, 2 ], [ 3, 4 ] ] ]\n        + [ [ [ 5, 6 ], [ 7, 8 ] ] ]\n       == [ [ [ 6, 8 ], [ 10, 12 ] ] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check08.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) a constant zs with type an infinite sequence of 32-bit words whose elements are all zero; (2) an infinite sequence qq of 32-bit words produced by a productive, zipped recursive list comprehension where each element equals the sum of three aligned sources: qq with a leading 0, qq with a leading 1, and zs with a leading 0; include appropriate type signatures and ensure the recursion is guarded by the prepended elements; (3) a boolean constant check8 that is true exactly when selecting qq at indices 0 through 4 yields the five-element sequence [1, 2, 5, 12, 27]; and (4) a property named prefix expressing the same equality as check8 so it can be checked by a solver."},{"role":"assistant","content":"```cryptol\nqq = [ s + a + b | s <- [0] # qq\n\t          | a <- [1] # qq\n\t          | b <- [0] # zs ]\nzs : [inf][32]\nzs = [0...]\n\ncheck8 = qq @@ [0 .. 4] == [1, 2, 5, 12, 27]\n\nproperty prefix = qq @@ [0 .. 4] == [1, 2, 5, 12, 27]\n```"}]}
{"filename":"cryptol\/tests\/regression\/reference.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Import the Cryptol Reference library under the alias used for that module. Define three properties named foldl_eq, scanl_eq, and iterate_eq that each assert equivalence between the built-in functions and their reference counterparts. For foldl_eq, take an Integer seed and a length-10 sequence of Integers; assert that left-folding with subtraction starting from the seed over the sequence equals the reference implementation\u2019s result. For scanl_eq, with the same argument types, assert that the sequence of intermediate results from the left-scan with subtraction and the seed matches the reference implementation\u2019s sequence. For iterate_eq, take an Integer seed and an 8-bit index; assert that the element at the given index of the sequence produced by repeatedly adding one starting from the seed matches the element at the same index from the reference implementation. Use explicit type annotations for all property arguments, use equality to compare results, and index the iterative sequences by the 8-bit word."},{"role":"assistant","content":"```cryptol\nimport Cryptol::Reference as Ref\n\nproperty foldl_eq (z:Integer) (xs:[10]Integer) =\n  foldl (-) z xs == Ref::foldl (-) z xs\n\nproperty scanl_eq (z:Integer) (xs:[10]Integer) =\n  scanl (-) z xs == Ref::scanl (-) z xs\n\nproperty iterate_eq (z:Integer) (i:[8]) =\n  (iterate (\\x -> x + 1) z)@i == (Ref::iterate (\\x -> x + 1) z)@i\n```"}]}
{"filename":"cryptol\/tests\/regression\/rec-update.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol specification that introduces a type alias for a record with two fields: an 8-bit unsigned value named x and a boolean named y. Provide explicit type signatures and definitions for the following constants: f1, f2, f3, f4 of the record type; and f5, f6 as sequences of exactly four records of that type. Set f1 to the record with x equal to 2 and y true. Define f2 as f1 with x replaced by 3. Define f3 as f2 with x replaced by 4 and y set to false. Define f4 by functionally updating the x field of f3 by adding 1 to its current value (8-bit modular addition). Construct f5 as the ordered sequence [f1, f2, f3, f4]. Define f6 by updating all elements of f5 so that their x fields are replaced positionally by the sequence [7, 8, 9, 10]. Ensure all integer literals are correctly sized to 8 bits."},{"role":"assistant","content":"```cryptol\ntype T = { x : [8], y : Bool }\n\nf1 = { x = 2, y = True } : T\nf2 = { f1 | x = 3 }\nf3 = { f2 | x = 4, y = False }\nf4 = { f3 | x -> x + 1 }\nf5 = [f1,f2,f3,f4]\nf6 = { f5 | x = [7,8,9,10] }\n```"}]}
{"filename":"cryptol\/tests\/regression\/check24.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that:\n- Declares a polymorphic function named xor with a size parameter a. It takes a pair of a-bit sequences and returns an a-bit sequence computed by comparing corresponding bits from the two inputs for inequality using a parallel list comprehension (bitwise XOR via per-bit inequality).\n- Provides an explicit type for xor indicating it maps a pair of length-a bit sequences to a length-a bit sequence.\n- Defines a top-level Boolean constant named check24 that enumerates all ordered pairs of 4-bit values, applies xor specialized at width 4 to each pair, compares the result to the built-in bitwise exclusive-or, collects the 256 boolean results into a 256-bit sequence, and compares that sequence to the all-ones value so the constant is true exactly when every case matches.\n- Uses only standard Cryptol operators and comprehensions, and clearly names all parameters and widths."},{"role":"assistant","content":"```cryptol\nxor : {a} ([a], [a]) -> [a]\nxor (xs, ys) = [ x != y | x <- xs | y <- ys ]\n\ncheck24 = [ xor`{4} (x, y) == (x ^ y) | x <- [ 0 .. 15 ], y <- [ 0 .. 15 ] ] == ~zero\n```"}]}
{"filename":"cryptol\/tests\/regression\/primes.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) defines a polymorphic constant named z1prime with a type parameter n constrained to be prime, returning the modular value 1 in Z n; then defines four specialized bindings z1_2, z1_3, z1_17, and z1_2_17m1 by applying size parameters 2, 3, 17, and (2^17 \u2212 1), respectively. (2) defines five numeric type synonyms p192, p224, p256, p384, and p521, each bound to the exact large prime integer values indicated, to be used as prime moduli. (3) defines a function recip_correct with type {p} (prime p) => Z p -> Bool that, given x in Z p, returns the Boolean condition \u201cx is zero or x times its modular reciprocal equals one.\u201d Then define properties recip_correct_17, recip_correct_1021, recip_correct_p192, recip_correct_p224, recip_correct_p256, recip_correct_p384, and recip_correct_p521, each a property obtained by specializing recip_correct at modulus 17, 1021, p192, p224, p256, p384, and p521, respectively. (4) defines a function moddiv_eq with type {p} (prime p, p >= 3) => Z p -> Z p -> Bool that, for x and y in Z p, returns the Boolean condition \u201cy is zero or modular division of x by y, multiplied by y, equals x.\u201d Then define properties moddiv_eq17, moddiv_eq1021, moddiv_eq_p192, moddiv_eq_p224, moddiv_eq_p256, moddiv_eq_p384, and moddiv_eq_p521, each specializing moddiv_eq at the same corresponding moduli. Use Cryptol property declarations for all listed properties and ensure the constraints on p are present in the type signatures."},{"role":"assistant","content":"```cryptol\nz1prime : {n} (prime n) => Z n\nz1prime = 1\n\nz1_2 = z1prime`{2}\nz1_3 = z1prime`{3}\nz1_17 = z1prime`{17}\nz1_2_17m1 = z1prime`{2^^17 - 1}\n\ntype p192 = 6277101735386680763835789423207666416083908700390324961279\ntype p224 = 26959946667150639794667015087019630673557916260026308143510066298881\ntype p256 = 115792089210356248762697446949407573530086143415290314195533631308867097853951\ntype p384 = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\ntype p521 = 6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151\n\nrecip_correct : {p} (prime p) => Z p -> Bool\nrecip_correct x = x == 0 \\\/ x * recip x == 1\n\nproperty recip_correct_17   = recip_correct`{17}\nproperty recip_correct_1021 = recip_correct`{1021}\nproperty recip_correct_p192 = recip_correct`{p192}\nproperty recip_correct_p224 = recip_correct`{p224}\nproperty recip_correct_p256 = recip_correct`{p256}\nproperty recip_correct_p384 = recip_correct`{p384}\nproperty recip_correct_p521 = recip_correct`{p521}\n\nmoddiv_eq : {p} (prime p, p >= 3) => Z p -> Z p -> Bool\nmoddiv_eq x y = y == 0 \\\/ (x \/. y) * y == x\n\nproperty moddiv_eq17   = moddiv_eq`{17}\nproperty moddiv_eq1021 = moddiv_eq`{1021}\n\nproperty moddiv_eq_p192 = moddiv_eq`{p192}\nproperty moddiv_eq_p224 = moddiv_eq`{p224}\nproperty moddiv_eq_p256 = moddiv_eq`{p256}\nproperty moddiv_eq_p384 = moddiv_eq`{p384}\nproperty moddiv_eq_p521 = moddiv_eq`{p521}\n```"}]}
{"filename":"cryptol\/tests\/regression\/bitshift.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that includes: (1) type signatures and definitions for functions named shift and shift_alt, both polymorphic over a size parameter d with constraints that d is finite and at least 1. Each takes a length-d sequence of bits and a single bit, and returns a length-d sequence representing a one-position right shift where the most-significant position is filled with the provided bit. Implement shift by prefixing the fill bit to the first d\u22121 elements of the input. Implement shift_alt by prefixing the fill bit to the sequence obtained by dropping one element from the input after shifting it right by one. (2) a constant infZero that is an infinite stream of false bits, defined via a self-referential construction. (3) a property named shift_eq that universally quantifies five bits, constructs a 10-bit sequence by concatenating the first four bits with the infinite-zero stream and taking the first 10 elements, and asserts that applying shift and shift_alt to this 10-bit sequence with the fifth bit as the fill yields identical results."},{"role":"assistant","content":"```cryptol\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n          fills = [bit]#(take fill)\n\nshift_alt : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift_alt fill bit = fills\n\twhere\n\t  fills = [bit]#(drop`{1} (fill >> 1))\n\ninfZero : [inf]Bit\ninfZero = [False] # infZero\n\nproperty shift_eq a b c d e = shift (take`{10} ([a,b,c,d]#infZero)) e\n                           == shift_alt (take`{10} ([a,b,c,d]#infZero)) e\n```"}]}
{"filename":"cryptol\/tests\/regression\/check27.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) a bit-typed constant equal to the all-zero value; (2) two tuple-typed constants, one pairing an 8-bit word with a 32-bit word and another triple of 8-, 32-, and 256-bit words, each initialized to the all-zero value for their types; (3) a total function from an 8-bit word to a 16-bit word that ignores its input and returns the 16-bit all-zero value. Then define a top-level Boolean value that conjoins these checks: the bit constant equals false; each tuple constant equals the corresponding tuple of numeric zeros of matching widths; the equalities also hold when the operands are reversed (i.e., both orders of comparison); and applying the function to the decimal value 13 yields the 16-bit zero. Provide explicit type annotations for all constants and the function, and use Cryptol\u2019s standard zero value for initialization. Do not use the property keyword; the final Boolean should be a plain definition that evaluates to true when all conditions hold."},{"role":"assistant","content":"```cryptol\nzeroBit : Bit\nzeroBit = zero\n\nzeroTuple : ([8], [32])\nzeroTuple = zero\nzeroTuple3 : ([8], [32], [256])\nzeroTuple3 = zero\n\nzeroFun : [8] -> [16]\nzeroFun = zero\n\ncheck27 = (zeroBit == False)\n\t&& (zeroTuple == (0, 0)) && (zeroTuple3 == (0, 0, 0))\n\t&& ((0, 0) == zeroTuple) && ((0, 0, 0) == zeroTuple3)\n\t&& (zeroFun 13 == 0)\n```"}]}
{"filename":"cryptol\/tests\/regression\/check26.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that mirrors the file\u2019s behavior: define two total, polymorphic projection functions that return the first and second element of a pair of finite sequences (bitvectors), respectively. Declare a pair constant using the same two numeric literals as in the source. Define a boolean check that each projection equals both the corresponding tuple field accessed by positional indexing and the concrete literal value. Construct a sequence of all pairs using a list comprehension over the two inclusive ranges present in the source (outer generator for the first range, inner for the second), preserving generator order. Define a boolean asserting that mapping the first-projection over this sequence equals the sequence of values from the first range repeated for each element of the second range. Define another boolean asserting that the sequence of equality results between the two components of each pair is exactly equal to the reversal of the hexadecimal bitvector literal used in the source; the bit width must equal the total number of generated pairs. Finally, define a single aggregate boolean that is the conjunction of the three booleans above. Use general types where possible, with concrete literal widths inferred from the numeric and hexadecimal constants. Do not use the property keyword; implement these as function and constant definitions suitable for evaluation or checking with ==."},{"role":"assistant","content":"```cryptol\nfst (x, y) = x\nsnd (x, y) = y\nxy = (13, 21)\ncheck26a = (fst xy == xy.0) && (snd xy == xy.1) &&\n\t   (fst xy == 13) && (snd xy == 21)\n\nxys = [ (x, y) | x <- [ 1 .. 10 ], y <- [ 2 .. 5 ] ]\ncheck26b = [ fst ixy | ixy <- xys ] ==\n\t   [ x | x <- [ 1 .. 10 ], y <- [ 2 .. 5 ] ]\ncheck26c = [ fst ixy == snd ixy | ixy <- xys ] == reverse 0x0000084210\n\ncheck26 = check26a && check26b && check26c\n```"}]}
{"filename":"cryptol\/tests\/regression\/check03.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol specification that: (1) gives a type signature for a function that takes a 32-bit word and returns an infinite sequence of 32-bit words; (2) implements the function to produce an infinite stream whose first element is the input value and each subsequent element is the previous element plus one; and (3) declares a Boolean constant that is true exactly when the element at index 45 of the stream generated from input 0 equals 45, and the element at index 0 of the stream generated from input 45 equals 45."},{"role":"assistant","content":"```cryptol\nnats : [32] -> [inf][32]\nnats n = [n] # nats (n + 1)\n\ncheck3 = (nats 0 @ 45 == 45) && (nats 45 @ 0 == 45)\n```"}]}
{"filename":"cryptol\/tests\/regression\/rational_properties.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define Cryptol properties with the following names and meanings, using universal quantification over the stated types: QaddUnit, QaddComm, QaddAssoc, Qneg, QmulUnit, QmulComm, QmulAssoc, Qdistrib (all over Rational) to capture additive\/multiplicative identities, commutativity, associativity, additive inverse, and distributivity. Qrecip (Rational) to assert that either the value is zero or multiplying by its reciprocal yields the multiplicative identity. QdivisionEquiv (Rational, Rational) to state that rational division equals multiplication by the reciprocal, guarded so the divisor may be zero without causing a partial operation. Ordering properties over Rational: QordEquiv1 (<= equivalent to not greater-than), QordEquiv2 (<= equivalent to equality or <), QordTrans (transitivity of <), QordIrreflexive (no value is < itself), QordExclusive (cannot be both x<y and y<x), Qtrichotomy (exactly one of <, ==, > holds in disjunction form), QordCompatible (addition preserves < with the same addend), QordPositive (product is positive when both factors are positive). Qdense (Rational) to assert density: if one value is strictly less than another, then their average lies strictly between them; define a local midpoint as the average using rational division by two. Integer\/Rational bridging: intDivDown (Integer, Integer) to assert that either the divisor is zero or the rationalized result of truncating integer division is less than or equal to the exact rational ratio. Floor and ceiling correctness over Rational and Integer: floorCorrect1 (floor is a lower bound), floorCorrect2 (any integer lower bound is \u2264 floor), ceilingCorrect1 (ceiling is an upper bound), ceilingCorrect2 (any integer upper bound is \u2265 ceiling). Use fromInteger, floor, ceiling, ratio, recip, negate, logical implication, disjunction, conjunction, and negation. Guard all potentially partial operations (e.g., reciprocal\/division by zero)."},{"role":"assistant","content":"```cryptol\nproperty QaddUnit (x : Rational) =\n  x + 0 == x\n\nproperty QaddComm (x:Rational) (y:Rational) =\n  x + y == y + x\n\nproperty QaddAssoc (x:Rational) (y:Rational) (z:Rational) =\n  x + (y + z) == (x + y) + z\n\nproperty Qneg (x: Rational) = x + negate x == 0\n\nproperty QmulUnit (x : Rational) =\n  x * 1 == x\n\nproperty QmulComm (x:Rational) (y:Rational) =\n  x * y == y * x\n\nproperty QmulAssoc (x:Rational) (y:Rational) (z:Rational) =\n  x * (y * z) == (x * y) * z\n\nproperty Qdistrib (x:Rational) (y:Rational) (z:Rational) =\n  x * (y + z) == x*y + x*z\n\nproperty Qrecip (x: Rational) = x == 0 \\\/ x * recip x == 1\n\nproperty QdivisionEquiv (x : Rational) (y : Rational) =\n  y == 0 \\\/ x \/. y == x * (recip y)\n\nproperty QordEquiv1 (x : Rational) (y : Rational) =\n  (x <= y) == ~(y < x)\n\nproperty QordEquiv2 (x : Rational) (y : Rational) =\n  (x <= y) == (x == y \\\/ x < y)\n\nproperty QordTrans (x : Rational) (y : Rational) (z : Rational) =\n  x < y ==> y < z ==> x < z\n\nproperty QordIrreflexive (x : Rational) =\n  ~(x < x)\n\nproperty QordExclusive (x : Rational) (y:Rational) =\n  ~(x < y) || ~(y < x) \n\nproperty Qtrichotomy (x : Rational) (y : Rational) =\n  x < y \\\/ x == y \\\/ x > y\n\nproperty QordCompatible (x : Rational) (y : Rational) (z:Rational) =\n  x < y ==> x+z < y+z\n\nproperty QordPositive (x : Rational) (y : Rational) =\n  0 < x ==> 0 < y ==> 0 < x*y\n\nproperty Qdense (x : Rational) (y : Rational) = x < y ==> x < mid \/\\ mid < y\n  where\n  mid = (x + y) \/. 2\n\nproperty intDivDown (x : Integer) (y:Integer) =\n  y == 0 \\\/ fromInteger (x \/ y) <= ratio x y\n\nproperty floorCorrect1 (x:Rational) =\n  fromInteger (floor x) <= x\n\nproperty floorCorrect2 (x:Rational) (y:Integer) =\n  fromInteger y <= x ==>\n  y <= floor x\n\nproperty ceilingCorrect1 (x:Rational) =\n  fromInteger (ceiling x) >= x\n\nproperty ceilingCorrect2 (x:Rational) (y:Integer) =\n  fromInteger y >= x ==>\n  y >= ceiling x\n```"}]}
{"filename":"cryptol\/tests\/regression\/check28.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the constant xs as a length-7 sequence of pairs where each pair contains the same unsigned word value from 1 to 7 in order. Make xs polymorphic over the element width w with the constraint 3 <= w, so each element of a pair has type [w]. Next, define a property named check28 that asserts that mapping equality over each pair in xs (producing a length-7 sequence of Bit) yields an all-ones bitvector of length 7 (i.e., the bitwise complement of zero at that length). Provide full type signatures: xs :: [7] ([w], [w]) with 3 <= w, and check28 :: {w} (3 <= w) => Bit. The property should compare the boolean sequence derived from the pairwise equalities against the all-ones vector constructed via bitwise negation of zero with a length matching the result sequence. Avoid any additional assumptions beyond the width constraint and preserve the exact ordering and values 1 through 7 for the pairs."},{"role":"assistant","content":"```cryptol\nxs = [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7)]\ncheck28 = [ x==y | (x,y) <- xs ] == ~zero\n```"}]}
{"filename":"cryptol\/tests\/regression\/check14.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a polymorphic function named swab with a type signature stating that for any natural length n and any element type a, it takes a sequence of n inner sequences, each of length 4, and returns a sequence of the same shape where each inner sequence has its four elements in reverse order. Also define a boolean constant named check14 that asserts that applying swab to a concrete example consisting of two 4-element sequences of consecutive small integers yields the corresponding result where each of those two inner sequences is reversed. Clearly state the types of all definitions (swab: [n][4]a -> [n][4]a; check14: Bit) and ensure no additional assumptions beyond standard equality on sequences are required."},{"role":"assistant","content":"```cryptol\nswab xxs = [ [d, c, b, a]\n           | [a, b, c, d] <- xxs\n           ]\n\ncheck14 = swab [[0, 1, 2, 3], [4, 5, 6, 7]] == [[3, 2, 1, 0], [7, 6, 5, 4]]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check11.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol specification that introduces a boolean constant named check11 which evaluates whether a base sequence equals a two-stage reindexing of itself. Create: (1) zz as the finite sequence of 100 consecutive unsigned values starting at 0, with element type the minimal fixed-width word sufficient to represent 99; (2) qq as the result of indexing zz by a sequence of 32-bit indices ranging from 0 to 2^32\u22121 using vector-based indexing; and (3) ww as the result of indexing qq by the indices 0 through 99. The constant check11 must be the equality of zz and ww. Include explicit type annotations so that the index elements for qq are 32-bit words and zz has length 100 with minimal element width. Ensure all size and finiteness constraints are concrete (no polymorphic lengths) and that the construction typechecks without runtime assumptions."},{"role":"assistant","content":"```cryptol\ncheck11 = zz == ww\n  where\n    zz = [0 .. 99]\n    qq = zz @@ ([0 .. 0xffffffff] : [_][32])\n    ww = qq @@ [0 .. 99]\n```"}]}
{"filename":"cryptol\/tests\/regression\/FloatTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named FloatTests that imports Float and contains the following definitions: (1) A function section with type {n} fin n => [n][8] -> [78][8] that returns a 78-byte vector formed by concatenating a fixed three-byte prefix consisting of two hyphens and a space, then the first min(60, n) bytes of the input, then enough hyphen bytes to reach length 78. (2) Type aliases: Small as a floating type with exponent 3 and precision 2, Medium as the 64-bit binary floating type, and Large as a floating type with exponent 60 and precision 5000. (3) Define a property that converting any floating value to raw bits and back with the provided conversions yields a value totally equal to the original. (4) A polymorphic signature roundTrip2: {e:#, p:#} (fin e, fin p, ValidFloat e p) => [e + p] -> Bool, and define a property that for any bitvector, decoding then re-encoding either reproduces the original bits or the decoded value is NaN. (5) Define a property that total floating equality is reflexive. (6) Define a property that IEEE partial equality is reflexive except for NaN. (7) Define a property that when IEEE partial equality holds, the operands are totally equal or represent signed-zero equivalents, allowing NaN cases. (8) Define a property that IEEE \u2264 is reflexive except for NaN. (9) A signature roundTripRational: {e,p} (fin e, fin p, ValidFloat e p) => Float e p -> Bool, and define a property that for finite values, converting to rational and back with round-to-nearest-even yields a totally equal result, permitting negative zero as an exceptional equivalent."},{"role":"assistant","content":"```cryptol\nmodule FloatTests where\n\nimport Float\n\nsection : {n} fin n => [n][8] -> [78][8]\nsection x = \"-- \" # take`{min 60 n} x # repeat '-'\n\ntype Small  = Float 3 2\ntype Medium = Float64\ntype Large  = Float 60 5000\n\nproperty roundTrip x  = fpFromBits (fpToBits x) =.= x\n\nroundTrip2 : {e : #, p : #} (fin e, fin p, ValidFloat e p) => [e + p] -> Bool\nproperty roundTrip2 x = fpToBits num == x \\\/ num =.= fpNaN\n                          where num = fpFromBits x : Float e p\nproperty eqRefl1 x    = x =.= x\nproperty eqRefl2 x    = x == x \\\/ x =.= fpNaN\nproperty eqProp x y   = ~(x == y) \\\/\n                         (x =.= y \\\/ x =.= fpNaN\n                                  \\\/ y =.= fpNaN\n                                  \\\/ (x =.=  0.0 \/\\ y =.= -0.0)\n                                  \\\/ (x =.= -0.0 \/\\ y =.=  0.0)\n                         )\nproperty leqRefl x    = x <= x \\\/ x =.= fpNaN\n\nroundTripRational : {e,p} (fin e, fin p, ValidFloat e p) => Float e p -> Bool\nproperty roundTripRational x =\n  ~(fpIsFinite x) \\\/\n  (fpFromRational rne (fpToRational x) =.= x) \\\/\n  (x =.= fpNegZero)\n```"}]}
{"filename":"cryptol\/tests\/regression\/specialize.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named specialize that contains two definitions: (1) a polymorphic function f parameterized by two type variables a and b with the type \u201cfor all a and b, from a pair of (a, b) to a pair of (a, b)\u201d, which returns its input pair unchanged; and (2) a function top with the type \u201cfrom a pair of Bit and Bit to a pair of Bit and Bit\u201d that invokes f using explicit type application specialized to Bit and Bit on its input pair and returns the result. Include explicit type signatures for both functions, no additional constraints, and ensure top\u2019s implementation is exactly the specialization of f to bits."},{"role":"assistant","content":"```cryptol\nmodule specialize where\n\ntop (x, y) = f`{Bit,Bit} (x, y)\n\nf : {a, b} (a, b) -> (a, b)\nf (x, y) = (x, y)\n```"}]}
{"filename":"cryptol\/tests\/regression\/poly.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models dense univariate polynomials over a ring and verifies their evaluation laws. Specifically: 1) Define a parametric newtype representing a polynomial of degree n with coefficients stored as a sequence of length n+1 over an element type that is a ring. 2) Define a function that evaluates a polynomial at a given point, requiring finite n and a ring element type. Compute the value as the sum of each coefficient multiplied by the corresponding power of the input, where the sequence of powers starts at one and is generated by repeated multiplication, and the sum is accumulated with ring addition starting from the additive identity. 3) Define a function that builds a constant polynomial from a scalar, placing the scalar as the constant term and filling remaining coefficients with the additive identity. 4) Define a function that adds two polynomials of the same degree by pointwise addition of their coefficient sequences. 5) Define a function that multiplies two polynomials of degrees n1 and n2 to produce a polynomial of degree n1+n2, by forming, for each coefficient\/index of the first polynomial, a copy of the second polynomial scaled by that coefficient and shifted by the index (implemented by appending the appropriate number of additive-identity coefficients), and summing all such shifted-scaled polynomials starting from the zero polynomial. 6) Define a property that, over integers, evaluating the monic quadratic with only a squared term at an input equals the square of that input. 7) Define a property that, for degree-5 integer polynomials and any integer input, evaluating the sum equals the sum of evaluations. 8) Define a property that, for degree-5 integer polynomials and any integer input, evaluating the product equals the product of evaluations."},{"role":"assistant","content":"```cryptol\nnewtype Poly n a = { coeffs : [n+1]a }\n\nevalPoly : {n, a} (fin n, Ring a) => Poly n a -> a -> a\nevalPoly p x = foldl (+) zero terms\n  where\n    terms = [ c*a | c <- p.coeffs | a <- xs ]\n    xs    = [fromInteger 1]#[ x*a | a <- xs ]\n\npolyConst : {n, a} (fin n, Ring a) => a -> Poly n a\npolyConst a = Poly { coeffs = [a]#zero }\n\npolyAdd : {n, a} (fin n, Ring a) => Poly n a -> Poly n a -> Poly n a\npolyAdd p1 p2 = Poly { coeffs = zipWith (+) p1.coeffs p2.coeffs }\n\npolyMul : {n1, n2, a} (fin n1, fin n2, Ring a) =>\n  Poly n1 a -> Poly n2 a -> Poly (n1+n2) a\npolyMul p1 p2 = foldl polyAdd (polyConst zero) ps\n  where\n    ps : [n1+1](Poly (n1+n2) a)\n    ps@i = Poly{ coeffs = scaleAndShift i }\n\n    scaleAndShift i =\n      ([ p1.coeffs@i * c | c <- p2.coeffs ] # zero) >> i\n\nproperty polySquare (x:Integer) =\n  evalPoly (Poly { coeffs = [0,0,1] }) x == x * x\n\nproperty polyAddEval x (p1:Poly 5 Integer) (p2:Poly 5 Integer) =\n  evalPoly (polyAdd p1 p2) x == evalPoly p1 x + evalPoly p2 x\n\nproperty polyMulEval x (p1:Poly 5 Integer) (p2:Poly 5 Integer) =\n  evalPoly (polyMul p1 p2) x == evalPoly p1 x * evalPoly p2 x\n```"}]}
{"filename":"cryptol\/tests\/regression\/check12.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a polymorphic Cryptol specification with: (1) a function named sums that, for any finite length n and an element type supporting addition with a zero value, takes a sequence of n elements and returns a sequence of n containing the running (prefix) sums. Implement it by pairing each input element with the previous output value, starting from zero, so each output is the current input plus the prior output. Provide an explicit type signature parameterized by n and the element type. (2) a boolean constant named check12 that compares the result of applying sums to the sequence of the first ten non-negative integers, with each element represented as a 32-bit word, against the expected cumulative totals for that input. The constant should evaluate to True exactly when the computed running sums match the known cumulative sums. Ensure sequence length and 32-bit widths are consistent throughout."},{"role":"assistant","content":"```cryptol\nsums xs = ys\n  where ys = [ x + y | x <- xs | y <- [0] # ys ]\n\ncheck12 = sums ([0 .. 9] : [_][32]) == [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check06.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define in Cryptol the following with explicit type signatures: (1) a numeric type parameter w with constraint w >= 2; (2) two mutually recursive infinite sequences onetwos and twoones of type [inf][w], where onetwos begins with 1 followed by the entirety of twoones and twoones begins with 2 followed by the entirety of onetwos, yielding alternating values; (3) a sequence onesytwosy of type [inf][2][w] built by zipping the previous two streams in lock-step via a parallel list comprehension into length-2 sequences at each index; and (4) a Boolean constant check6 that compares the subsequence obtained by selecting indices 0 through 3 from the zipped sequence to the expected four-element sequence whose entries alternate between the two-element sequences [1,2] and [2,1], starting with [1,2]."},{"role":"assistant","content":"```cryptol\nonetwos = [1] # twoones\ntwoones = [2] # onetwos\nonesytwosy = [ [one, two] | one <- onetwos | two <- twoones ]\n\ncheck6 = onesytwosy @@ [0 .. 3] == [ [1, 2], [2, 1], [1, 2], [2, 1] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check13.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define two functions and one boolean constant that mirror the described behavior: (1) a function named ick with type [1][8] -> [8] that returns the only 8-bit element from a length-1 sequence; (2) a function named uck with type [8][1] -> [8] that concatenates eight 1-bit elements, in order, into a single 8-bit value; and (3) a constant named check13 of type Bit that is true exactly when both of the following equalities hold: (a) applying ick to the result of splitting the 8-bit literal 150 into one 8-bit chunk yields 150, and (b) applying uck to the result of splitting the 8-bit literal 150 into eight 1-bit chunks yields 150. Use Cryptol\u2019s split so that the chunking is inferred from each function\u2019s input type, and ensure 150 is treated as an 8-bit value. Do not introduce additional parameters or assumptions."},{"role":"assistant","content":"```cryptol\nick : [1][8] -> [8]\nick [x] = x\n\nuck : [8][1] -> [8]\nuck [a, b, c, d, e, f, g, h] = a # b # c # d # e # f # g # h\n\ncheck13 = (ick (split 150) == 150) && (uck (split 150) == 150)\n```"}]}
{"filename":"cryptol\/tests\/regression\/allsat.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol function named f with type (Integer, Integer, Integer) -> Bit that pattern-matches a 3-tuple and returns true if and only if each of the three integers lies within the inclusive range 1 to 15. Implement the range check via a local where-clause helper that takes an Integer and returns the logical conjunction of the lower-bound and upper-bound comparisons, and have f apply this helper to each component and combine the three results with boolean AND. Use only integer comparisons and Bit-valued logic; do not use lists or sequences."},{"role":"assistant","content":"```cryptol\nf : (Integer, Integer, Integer) -> Bit\nf (x, y, z) =  inRange x && inRange y && inRange z\n  where inRange v = (1 <= v) && (v <= 15)\n```"}]}
{"filename":"cryptol\/tests\/regression\/negshift.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines five boolean-returning helper functions and a suite of properties to check them:\n- A polymorphic function over sequence length n and element type a, with constraints that n is finite, a has a zero element for shift fill, and a is comparable, taking a vector of length n of a and an integer shift amount, and returning whether left-shifting by the amount equals right-shifting by the negated amount.\n- A second polymorphic function with the same constraints returning whether right-shifting by the amount equals left-shifting by the negated amount.\n- A polymorphic function over n and a, with n finite and a comparable, returning whether rotating left by the amount equals rotating right by the negated amount.\n- A second rotate function with the same constraints returning whether rotating right by the amount equals rotating left by the negated amount.\n- A function over n, with n finite and n >= 1, taking a bitvector of length n and an integer shift amount, that returns an implication stating: if the amount is negative, then an arithmetic right shift (sign-extending) by that amount equals a logical left shift by the negated amount.\nProvide explicit type signatures: the first four functions take [n]a and Integer and return Bit; the last takes [n] and Integer and returns Bit. Then define properties that instantiate these functions at the following type parameters:\n- For each of the four shift\/rotate equivalence functions: (n=8, a=Bit), (n=32, a=Bit), (n=8, a=Integer), and (n=8, a=[32]).\n- For the arithmetic-shift implication function: n=8 and n=32.\nUse Cryptol equality and the logical\/rotational\/arithmetic shift operators accordingly."},{"role":"assistant","content":"```cryptol\nnegLeftShift : {n, a} (fin n, Zero a, Cmp a) => [n]a -> Integer -> Bit\nnegLeftShift xs i = xs << i == xs >> (negate i)\n\nnegRightShift : {n, a} (fin n, Zero a, Cmp a) => [n]a -> Integer -> Bit\nnegRightShift xs i = xs >> i == xs << (negate i)\n\nnegLeftRotate : {n, a} (fin n, Cmp a) => [n]a -> Integer -> Bit\nnegLeftRotate xs i = xs <<< i == xs >>> (negate i)\n\nnegRightRotate : {n, a} (fin n, Cmp a) => [n]a -> Integer -> Bit\nnegRightRotate xs i = xs >>> i == xs <<< (negate i)\n\nnegSshr : {n} (fin n, n >= 1) => [n] -> Integer -> Bit\nnegSshr xs i = i < 0 ==> xs >>$ i == xs << (negate i)\n\nproperty nls1 = negLeftShift`{8, Bit}\nproperty nls2 = negLeftShift`{32, Bit}\nproperty nls3 = negLeftShift`{8, Integer}\nproperty nls4 = negLeftShift`{8, [32]}\n\nproperty nrs1 = negRightShift`{8, Bit}\nproperty nrs2 = negRightShift`{32, Bit}\nproperty nrs3 = negRightShift`{8, Integer}\nproperty nrs4 = negRightShift`{8, [32]}\n\nproperty nlr1 = negLeftRotate`{8, Bit}\nproperty nlr2 = negLeftRotate`{32, Bit}\nproperty nlr3 = negLeftRotate`{8, Integer}\nproperty nlr4 = negLeftRotate`{8, [32]}\n\nproperty nrr1 = negRightRotate`{8, Bit}\nproperty nrr2 = negRightRotate`{32, Bit}\nproperty nrr3 = negRightRotate`{8, Integer}\nproperty nrr4 = negRightRotate`{8, [32]}\n\nproperty nsshr1 = negSshr`{8}\nproperty nsshr2 = negSshr`{32}\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T06.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains the following definitions: (1) an interface submodule Iface that declares a single numeric type parameter Width of kind #; (2) a concrete submodule Impl that binds Width to the numeric literal 1; (3) a submodule SubC that imports the interface submodule and defines a value unitVal equal to the unit value; (4) a submodule SubB that imports the interface submodule and defines a nested submodule CInst by instantiating SubC with submodule Impl; and (5) a submodule SubA defined by instantiating SubB with submodule Impl. Use proper Cryptol syntax for interface submodules, type declarations and definitions, submodule imports, submodule instantiation with named submodule arguments, and the unit value. Do not add any extra bindings, functions, or properties."},{"role":"assistant","content":"```cryptol\nmodule T06 where\n\ninterface submodule I where\n  type N : #\n\nsubmodule N1 where\n  type N = 1\n\nsubmodule C where\n  import interface submodule I\n\n  lost = ()\n\nsubmodule B where\n  import interface submodule I\n  submodule C_ = submodule C { submodule N1 }\n\nsubmodule A = submodule B { submodule N1 }\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T10.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains the following definitions: (1) A public property of type Bit that unconditionally evaluates to the true bit. (2) A submodule that declares one public property of type Bit that is true and one private property of type Bit that is true; the private property must not be exported outside this submodule. (3) A parameterized submodule that declares a numeric type parameter of kind # (named generically, e.g., N) and within it defines one public property of type Bit that is true and one private property of type Bit that is true. (4) A submodule instance that binds the numeric type parameter of the parameterized submodule to the literal 1. Clearly indicate visibility (public vs private), the kind of the numeric parameter, and that each property evaluates to true without additional constraints. Do not provide implementations beyond these declarations; focus on correct module\/submodule structure, parameterization, visibility, and property declarations."},{"role":"assistant","content":"```cryptol\nmodule T10 where\n\np : Bit\nproperty p = True\n\nsubmodule M where\n  q : Bit\n  property q = True\n\n  private\n    r : Bit\n    property r = True\n\nsubmodule F where\n  parameter\n    type N : #\n\n  s : Bit\n  property s = True\n\n  private\n    t : Bit\n    property t = True\n\nsubmodule F1 = submodule F where type N = 1\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T02.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named T02 that contains the following definitions: a parameterized submodule F with a numeric type parameter n (kind #) constrained to be finite and at least 2; inside F, declare a private constant c of modular integer type Z n (integers modulo n) with value 1; inside F, define a function p with type Z n -> Bit that returns whether adding c to an input is commutative (the sum is equal regardless of whether c is on the left or right). Define a submodule F7 that instantiates F with n set to 7. At the top level, define a function f with type Integer -> Integer that returns its argument added to itself. Clearly specify all types, constraints, privacy, and intended behavior in Cryptol-compatible form."},{"role":"assistant","content":"```cryptol\nmodule T02 where\n\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n, n >= 2)\n\n  private\n    c : Z n\n    c = 1\n\n  p x = c + x == x + c\n\nsubmodule F7 = submodule F where\n  type n = 7\n\nf : Integer -> Integer\nf x = x + x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue314.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a polymorphic function named f with a numeric type parameter a constrained by fin a and a >= 2. Give f the type [a][8] -> [8], meaning it accepts a sequence of a 8-bit values and returns a single 8-bit value. Implement f by creating a local sequence of length a\/2 whose elements are 8-bit zeros, and return the element at index 0 from that local sequence. Also define a property that, for all valid a and all inputs of the required type, the result of f equals the all-zero 8-bit value. The specification must clearly state the numeric constraints, the local binding\u2019s type [a\/2][8], the use of the zero-initialized sequence, and the safety of indexing (guaranteed by a >= 2 implying a\/2 >= 1)."},{"role":"assistant","content":"```cryptol\nf : {a} (fin a, a>=2) => [a][8] -> [8]\nf xs = ys!0\n where\n  ys : [a\/2][8]\n  ys = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1796.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define five polymorphic functions parameterized by a natural number w. Three functions map a bitvector to itself where the bitvector length is two raised to (two raised to w). Each of these three uses guarded branches that compare this computed length against the constant 2, returning the input when the length is not equal to 2 and returning the bitwise complement when it is equal to 2; the three variants must differ only by the order of the guards but be semantically identical. A fourth function has the same type and behavior but includes only equality-to-2 and greater-than-2 branches (no less-than-2 branch). A fifth function maps a bitvector of length two raised to w to itself, returning the complement only when the length equals 1 and otherwise returning the input. Provide explicit type signatures for all five functions with the appropriate sequence lengths tied to w. Then write Cryptol properties that universally quantify over w and inputs to: (1) prove the three reordered-guard variants are equivalent for all w and inputs; (2) prove the variant lacking the less-than-2 branch is equivalent to the others for all w and inputs; and (3) prove the function over length two-to-the-w returns the complement exactly when the length equals 1 and otherwise returns the input. Also include a property establishing that for all w, two raised to (two raised to w) is never less than 2, justifying the unreachable less-than case."},{"role":"assistant","content":"```cryptol\nexhaustive1 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1 x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n\nexhaustive1Reordered1: {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1Reordered1 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n\nexhaustive1Reordered2 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1Reordered2 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n\nexhaustive2 : {w} [2 ^^ w] -> [2 ^^ w]\nexhaustive2 x\n  | (2 ^^ w) == 1 => ~ x\n  | (2 ^^ w) > 1 => x\n\nexhaustive3 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive3 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue670.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a type-level infix operator named +++ that subtracts its right operand from its left operand on type-level naturals. Then declare two constants: g with a word type whose bit-length is computed by applying +++ in a left-associative chain to 6, 2, and 1, and whose value is 2; and h with a word type whose bit-length is computed by applying +++ to 6 and the parenthesized result of applying +++ to 2 and 1, and whose value is 9. Use the operator only in type-level size expressions, and ensure both values conform to their declared widths."},{"role":"assistant","content":"```cryptol\ntype x +++ y = x-y\n\ng : [6 +++ 2 +++ 1]\ng = 2\n\nh : [6 +++ (2 +++ 1)]\nh = 9\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue116.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the constant t as a 2-tuple where the first element is a 4-bit word with value 1, and the second element is a record with fields: key as an unbounded integer equal to 4, and value as a sequence of seven 8-bit elements encoding the ASCII string goodbye. Provide an explicit type signature for t matching these components. Then define the boolean constant bug116fixed as the logical conjunction of two self-equality checks formed by projecting the second element of t and comparing its value field to itself and its key field to itself. Provide an explicit type signature for bug116fixed as Bit."},{"role":"assistant","content":"```cryptol\nt = (0x1, { key = 4, value = \"goodbye\"})\n\nbug116fixed = (t.1.value == t.1.value) \/\\ (t.1.key == t.1.key)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol function named copy with the type: infinite sequence of bits to infinite sequence of bits. Implement it by recursively deconstructing the input into a head bit and an infinite tail, emitting the head bit unchanged as the new head and recursing on the tail, so the output is elementwise identical to the input. Use standard sequence concatenation and singleton construction for the head element. Then define a property named ok that evaluates to True by asserting that, when copy is applied to a stream whose first element is True and whose remaining elements are all zero bits, the element at index 0 of the result is True. Use the indexing operator to select index 0. Clearly declare the types involved (Bit for elements, infinite sequence for the stream) and avoid introducing any additional parameters or constraints."},{"role":"assistant","content":"```cryptol\ncopy : [inf] -> [inf]\ncopy ([b] # x) = if b then [True] # copy x else [False] # copy x\n\nproperty ok = copy ([True] # zero) @ 0\n```"}]}
{"filename":"cryptol\/tests\/issues\/T1439.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named T that contains the following definitions and structure:\n- A function f with a numeric type parameter n that takes a one-element sequence whose element has length n and returns that element; give f an explicit polymorphic type signature over n.\n- A function p with type variables a and b that takes a pair of (a, b) and returns the first component; include its polymorphic type signature.\n- An interface submodule I that declares a numeric type member n (of kind #).\n- A submodule F that imports the interface I and defines:\n  - A function h using the n from I, with type from a one-element sequence of length-n values to a length-n value, implemented by returning the sole element.\n  - A function g with a numeric parameter m, with type from a one-element sequence of length-m values to a length-m value, implemented by returning the sole element.\n  - Three functions q, q1, and q2 with the same polymorphic type over b, each taking a pair whose first component has type b (second component unconstrained) and returning the first component; implement them respectively by pattern matching on the pair, by selecting the first tuple field, and by destructuring the pair in a local binding and returning the first binding.\n- A submodule P1 that fixes the interface member n to the numeric value 1.\n- A submodule S that is the instantiation of F with P1.\n- An import of submodule S into T so that S\u2019s definitions are brought into the module scope."},{"role":"assistant","content":"```cryptol\nmodule T where\n    f : {n} [1][n] -> [n]\n  f [x] = x\n\n  p : {a,b} (a,b) -> a\n  p (x,_) = x\n\n  interface submodule I where\n    type n : #\n\n  submodule F where\n    import interface submodule I\n\n    h : [1][n] -> [n]\n    h [x] = x\n\n    g : {m} [1][m] -> [m]\n    g [x] = x\n\n    q, q1, q2 : {b} (b,_) -> b\n    q (x,_) = x\n\n    q1 x = x.0\n    q2 x = y\n      where\n      (y,z) = x\n\n  submodule P1 where\n    type n = 1\n\n  submodule S = submodule F { submodule P1 }\n\n  import submodule S\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue058.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define three top-level functions with explicit polymorphic type signatures and bodies: (1) a function named some that, for any natural width n, takes an n-bit word and returns a single bit indicating whether the word is nonzero; implement it by comparing the input to zero. (2) a function named last that, for any length n \u2265 1 and any element type a, takes a sequence of length n of a and returns the element at index 0; include the length constraint n \u2265 1 and use indexing at position 0. (3) a function named pad that, for any n, takes an n-bit word and returns an infinite stream of bits formed by concatenating the finite input with an infinite stream of zeros. Use appropriate Cryptol sequence types, size parameters, and constraints to capture these behaviors precisely, and ensure each definition\u2019s result type matches the described output (Bit for the predicate, element type a for the selector, and an infinite bit sequence for the padding function)."},{"role":"assistant","content":"```cryptol\nsome : {n} [n] -> Bit\nsome x = x != 0\n\nlast : {n, a} (n >= 1) => [n]a -> a\nlast xs = xs ! 0\n\npad : {n} [n] -> [inf]\npad x = x # zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue312.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that includes: (1) a function that maps a 16-bit word to a 16-bit word by returning three times the input via multiplication; (2) a second function that maps a 16-bit word to a 16-bit word by adding the input to itself twice; and (3) a property asserting these two functions are extensionally equal for all 16-bit inputs (i.e., they produce identical results on every possible 16-bit argument) using Cryptol\u2019s function equality. Provide explicit type signatures for both functions and no additional constraints."},{"role":"assistant","content":"```cryptol\nf : [16] -> [16]\nf x = 3 * x\n\ng : [16] -> [16]\ng x = x + x + x\n\nproperty f_g = (f === g)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue662.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the following: (1) a type synonym Q representing a pair of two Integers (numerator, denominator); (2) a function toQ: Integer -> Integer -> Q that normalizes a rational pair by rejecting a zero denominator with an error, and ensuring the denominator is positive by negating both components when it is negative; otherwise return the pair unchanged; (3) a function leQ: Q -> Q -> Bit that returns true when the first rational is less than or equal to the second using cross-multiplication on numerators and denominators; (4) a function intToQ: Integer -> Q that embeds an Integer as a rational with denominator 1; (5) a function abs: Integer -> Integer that returns the absolute value. Additionally, define the following properties: (a) define a property that for all Integers x and y, either y equals zero or the rational formed from the integer quotient x divided by y (as produced by intToQ) is less than or equal to the normalized rational produced by toQ x y under leQ; (b) define a property that for all Integers x and y, either y equals zero or the Euclidean identity holds: divisor times integer quotient plus remainder equals the original dividend; (c) define a property that for all Integers x and y, either y equals zero or the absolute value of the remainder is strictly less than the absolute value of the divisor. Include explicit type signatures for all definitions and use the helper functions within the properties as described."},{"role":"assistant","content":"```cryptol\ntype Q = (Integer, Integer)\n\ntoQ : Integer -> Integer -> Q\ntoQ a b =\n  if b == 0 then error \"divide by 0\" else\n  if b < 0 then (negate a, negate b) else (a, b)\n\nleQ : Q -> Q -> Bit\nleQ (a,b) (c,d) = a*d <= b*c\n\nintToQ : Integer -> Q\nintToQ x = (x, 1)\n\nabs : Integer -> Integer\nabs x = if x < 0 then negate x else x\n\nproperty divRoundsDown (x : Integer) (y : Integer) =\n  y == 0 \\\/ leQ (intToQ ( x \/ y )) (toQ x y)\n\nproperty divEuclidean (x : Integer) (y : Integer) =\n  y == 0 \\\/ y * (x \/ y) + x % y == x\n\nproperty modAbs (x : Integer) (y : Integer) =\n  y == 0 \\\/ abs (x % y) < abs y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue78.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a function named unique with an explicit polymorphic type over two size parameters: a (sequence length) and b (element width), constrained so both are finite and the length is at least 1. The function takes a sequence of length a whose elements are b-bit words and returns a single bit indicating whether all elements are distinct. Implement it by constructing a bitvector via a zipped list comprehension over element-position pairs (iterate positions from 0 to a\u22121). For each element x at index i, call a local helper exist starting from index i+1 to determine if x appears again later in the sequence. The helper exist must be defined in a where block, take a b-bit word and an index whose type is a word wide enough to index the sequence (width equal to the bit-width of a), and return a bit. It should return False when the index is past the end (index \u2265 a), return True if the element at the current index equals x, and otherwise recurse with the index incremented by 1. The outer function must aggregate the per-position results into a bitvector and produce True only when all entries indicate no later duplicate (e.g., by comparing that bitvector to zero). Include complete type signatures for both unique and exist, the stated constraints, and use sequence indexing for element access."},{"role":"assistant","content":"```cryptol\nunique : {a,b} (fin a, fin b, a>=1) => [a][b] -> Bit\nunique xs = [ exist x (i+1) | x <- xs | i <- [0..(a-1)] ] == 0\n  where exist : [b] -> [width a] -> Bit\n        exist x i = if(i>=`a) then False\n                    else if(x==(xs@i)) then True\n                    else exist x (i+1)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue138.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the following in Cryptol: (1) A constant named dwn of type \u201csequence of 16 elements of 4\u2011bit unsigned values\u201d whose elements satisfy a backward recurrence: the last element is zero and each earlier element equals one plus its successor (arithmetic modulo 16), yielding the descending sequence from 15 to 0. (2) A constant named dwn' with the same type and value as dwn, but constructed using index-based self-reference over positions 1 through 15 and appending zero. (3) A polymorphic function named take_some with size parameters n and k and element type t, constrained by n \u2265 k, that maps a sequence of length n to its first k elements using a self-referential, length-driven comprehension; include its full type signature reflecting these parameters and constraint. Also define two properties: one that dwn equals dwn' and both equal the descending 4\u2011bit sequence from 15 to 0 (with arithmetic modulo 16), and another that for all n, k, t with n \u2265 k and all inputs xs of length n, take_some xs returns exactly the first k elements of xs."},{"role":"assistant","content":"```cryptol\ndwn: [16][4]\ndwn = [ 1+d | d <- tail dwn ] # [0]\n\ndwn': [16][4]\ndwn' = [ 1+(dwn' @ i) | i <- [1 .. 15] ] # [0]\n\ntake_some: {n,k,t} (n>=k) => [n]t -> [k]t\ntake_some xs = takes where takes = [ x | x <- xs | _ <- takes ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue851.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a type alias named base, parameterized by a type t, representing a record with one field zero of type t. Define a constant B of type base Bool whose zero field is the boolean false. Define a polymorphic function foo that, for any finite length k, takes a base t record and returns a length-k sequence of t by repeating the record\u2019s zero value. Define a polymorphic function bar that, for any finite k with k \u2265 1, takes three length-k sequences of t and returns the first argument unchanged. Define a polymorphic function baz that, for any finite k with k \u2265 1, takes two length-k sequences of t and returns the second argument unchanged. Finally, define a property named problem that, for any p of the appropriate length and element type consistent with the other uses, states: if p is not equal to the sequence produced by foo applied to B, then calling bar with p as the first argument, with the result of baz applied to p and a fixed finite sequence literal as the second argument, and with the same fixed literal as the third argument, yields a result equal to the sequence produced by foo applied to B. Include all necessary type constraints."},{"role":"assistant","content":"```cryptol\ntype base t = { zero: t }\n\nB: base Bool\nB = { zero = False }\n\nfoo: {t,k} (fin k) => base t -> [k]t\nfoo b = repeat b.zero\n\nbar: {t,k} (fin k, k>=1) => [k]t -> [k]t -> [k]t -> [k]t\nbar p q m = p\n\nbaz: {k,t} (fin k, k >= 1) => [k]t -> [k]t -> [k]t\nbaz p q = q\n\nproperty problem p =\n  p != foo B ==> bar p (baz p 0x03) 0x03 == foo B\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1590.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Main that contains the following definitions: (1) a submodule F parameterized by a single value parameter x of type Bit; inside F, declare a newtype T as a record with one field named bit of type Bit, and define a type alias U that is equal to T; (2) a submodule M created by instantiating F with the parameter x set to False; (3) an import that brings the instantiated submodule M into the Main scope; (4) a top-level constant foo with type U whose value is constructed using the T newtype constructor by setting its record field bit to True. Make all types explicit, ensure the alias U resolves to the T defined within the imported submodule, and specify that foo\u2019s type and constructor usage refer to the imported definitions."},{"role":"assistant","content":"```cryptol\nmodule Main where\n\nsubmodule F where\n  parameter\n    x : Bit\n  newtype T = { bit : Bit }\n  type U = T\n\nsubmodule M = submodule F where x = False\n\nimport submodule M\n\nfoo : U\nfoo = T { bit = True }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1802.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named T1802 that contains the following definitions: (1) a numeric type parameter loglogw (kind #) constrained to be between 1 and 3 inclusive; (2) a type alias logw that is 2 raised to the power of loglogw at the type level; (3) a type alias w that is 2 raised to the power of logw at the type level; (4) a function csum with type: takes a sequence of 32 unsigned values each of width logw bits and returns an unsigned value of width logw+5 bits. Implement csum so that it maps each input element to a width-w value by zero-extending it, computes (w minus 1) minus that zero-extended value, then sums the 32 results. Use a list comprehension to produce the 32 transformed values and the built-in sum to aggregate them. Ensure the result type is exactly logw+5 bits and that the subtraction and summation are performed over width-w operands for the mapped terms. Include the parameter block with the constraint on loglogw and the two type aliases, followed by the csum type signature and its definition as described."},{"role":"assistant","content":"```cryptol\nmodule T1802 where\n\nparameter\n  type loglogw : #\n  type constraint (loglogw >= 1, loglogw <= 3)\n\ntype logw = 2^^loglogw\ntype w = 2^^logw\n\ncsum : [32][logw] -> [logw+5]\ncsum msg = sum [`w - 1 - zext msgi | msgi <- msg]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue962a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the following, with clear types, constraints, and point-free forms where applicable: (1) Define f polymorphically over a size parameter and an element type, with the constraint that the size is finite. It takes a sequence of that length of the element type and returns a pair whose first component is the boolean bit true and whose second component is the input sequence unchanged. (2) Define g with the same polymorphic size constraint that returns the second component of f specialized to the given size parameter; its type maps sequences to themselves. (3) Define h as the point-free second projection of f, with its most general type. (4) Define i specialized to bit sequences, mapping sequences of bits of any finite length to themselves via the second component of f specialized to that size. (5) Define j specialized to sequences whose element type is a record containing a field named fld of type Integer; it returns the sequence of those Integer field values by taking the second component of f at that record type and then projecting the fld field from each element. Also include the following verification artifacts: define a property that for all valid lengths and element types, f returns true and the input as its pair; define a property that for all inputs, g returns its input; define a property that h is extensionally equal to g (and thus to the identity) at all valid types; define a property that for all bit sequences, i returns its input; define a property that for all sequences of the specified records, j returns the sequence of fld fields in order."},{"role":"assistant","content":"```cryptol\nf : {a, b} (fin a) => [a]b -> (Bit, [a]b)\nf x = (True, x)\n\ng : {a,b} (fin a) => [a]b -> [a]b\ng x = (f`{a=a} x).1\n\nh = f.1\n\ni : {a} (fin a) => [a] -> [a]\ni = f`{a=a}.1\n\nj : {a} (fin a) => [a]{ fld : Integer } -> [a]Integer\nj = f`{a=a,b={fld : Integer}}.1.fld\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue160.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define six properties named thm1 through thm6 that each return a boolean (Bit) and use rotate-left and rotate-right over fixed-width words as follows: (1) thm1 has type 16-bit word -> Bit and asserts that rotating a 16-bit value by 16 in either direction yields the original value, combining both equalities with boolean conjunction. (2) thm2 has type 16-bit word -> 16-bit word -> Bit and asserts that rotating a 16-bit value right by an arbitrary 16-bit amount equals rotating it right by that amount masked to its low 4 bits with a 16-bit constant whose lower four bits are set and others cleared. (3) thm3 has type 15-bit word -> 8-bit word -> Bit and asserts that rotating left by an 8-bit amount equals rotating left by that amount reduced modulo 15. (4) thm4 has type 15-bit word -> 15-bit word -> Bit and asserts that rotating left by an amount and then right by the same amount returns the original value. (5) thm5 has type 15-bit word -> 3-bit word -> Bit and asserts the same left-then-right cancellation using a 3-bit amount. (6) thm6 has type 8-bit word -> 4-bit word -> 4-bit word -> Bit and asserts that rotating left by one 4-bit amount and then right by another equals rotating left by the modular difference of the two 4-bit amounts, using fixed-width subtraction for the amount expression."},{"role":"assistant","content":"```cryptol\nthm1 : [16] -> Bit\nproperty thm1 x = (x <<< 16 == x) && (x >>> 16 == x)\n\nthm2 : [16] -> [16] -> Bit\nproperty thm2 x i = x >>> i == x >>> (i && 0x000f)\n\nthm3 : [15] -> [8] -> Bit\nproperty thm3 x i = x <<< i == x <<< (i % 15)\n\nthm4 : [15] -> [15] -> Bit\nproperty thm4 x i = x <<< i >>> i == x\n\nthm5 : [15] -> [3] -> Bit\nproperty thm5 x i = x <<< i >>> i == x\n\nthm6 : [8] -> [4] -> [4] -> Bit\nproperty thm6 x i j = x <<< i >>> j == x <<< (i - j)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue148.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function Salsa20_expansion with a polymorphic numeric type parameter constrained so the key multiplier is either 1 or 2. Give it the type: takes a sequence of 16*multiplier bytes (8-bit each) as the key and a sequence of 16 bytes as the nonce, and returns a sequence of 64 bytes. If the multiplier is 2 (32-byte key), use the standard 16-byte Salsa20 constant for the 32-byte-key variant; otherwise use the standard 16-byte constant for the 16-byte-key variant. Split the chosen 16-byte constant into four 4-byte chunks s0, s1, s2, s3. Define k1 and k2 as follows: for a 32-byte key, k1 is the first 16 bytes and k2 is the last 16 bytes; for a 16-byte key, set k1 and k2 both equal to the 16-byte key. Construct the 64-byte output by concatenating s0, k1, s1, the nonce, s2, k2, and s3, in that order. Ensure the type constraints enforce that the multiplier is exactly 1 or 2, and all intermediate values have the correct [n][8] shapes."},{"role":"assistant","content":"```cryptol\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(k, n) = z\n  where\n    [s0, s1, s2, s3] = if (`a == 2) then split(\"expand 32-byte k\")\n                                    else split(\"expand 16-byte k\")\n    k1 = take`{16}(k#zero)\n    k2 = drop`{16}(zero#k)\n    x = s0 # k1 # s1 # n # s2 # k2 # s3\n    z = x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue389.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a size-polymorphic Cryptol function that implements 512-bit block message padding for hashing. The function takes a sequence of bits of some input length and returns a longer sequence formed by concatenating: the original bits, then a single 1 bit, then a run of 0 bits long enough so that after appending a 64-bit representation of the original input length, the total length is a multiple of 512. Quantify three size parameters: the input length, the zero-pad length, and the output length. Constrain them so that: the bit-width of the input length is at most 64; the zero-pad length equals 512 minus ((input length + 65) modulo 512); and the output length equals input length + 65 + zero-pad length. Provide a type signature that maps a bit sequence of the input length to a bit sequence of the output length under these constraints. In the definition, compute the 64-bit value of the original length and include it as the final segment of the concatenation. Also define a second top-level name that is an alias of this function."},{"role":"assistant","content":"```cryptol\npad : {n, m, b} (64>=width(n), b==512-((n+65)%512), m==65+n+b) => [n]->[m]\npad message = (message#[True])#(0:[b])#sz\n     where\n                sz : [64]\n                sz = length message\n\ntest = pad\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue177.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named issue177 that: imports issue177A; imports issue177B as alias B; imports issue177C as alias C; declares a type synonym Byte for an 8-bit sequence; declares constant w of type Byte equal to zero; declares constant x of type Word16 equal to zero; declares constant y with the type Word32 exported by module B equal to zero; and declares constant z as an alias of the value z from module C, preserving its type. Use qualified names for B and C references and provide explicit type signatures for w, x, and y. Do not introduce any additional definitions."},{"role":"assistant","content":"```cryptol\nmodule issue177 where\n\nimport issue177A\nimport issue177B as B\nimport issue177C as C\n\ntype Byte = [8]\n\nw : Byte\nw = zero\n\nx : Word16\nx = zero\n\ny : B::Word32\ny = zero\n\nz = C::z\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1744-2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Bug that imports the Array library and contains the following: (1) Type synonyms: Widget as a 3-bit word, Wombat as a 4-bit word, and Key as a 5-bit word. (2) A newtype Info as a record with one field stuff, which is an Array mapping 5-bit keys to 6-bit words. (3) A function once with type Info -> Key -> Widget -> Wombat -> Info that returns a new Info identical to the input except with stuff updated at the given key to the zero value of the array\u2019s 6-bit range; the additional arguments are accepted but do not affect the update. (4) A function iter with a size parameter n constrained by n < 10 and type Info -> Key -> [n] (Widget, Wombat) -> Info. It constructs a sequence infos whose first element is the initial Info, and whose subsequent elements are produced by zipping prior elements of infos with the entries and applying once using the fixed Key and each pair\u2019s components. Return the first element of infos. (5) A function process with the same n < 10 constraint and type Info -> [n] (Widget, Wombat) -> Info that invokes iter with the Key set to zero. Include all necessary type signatures and use arrayUpdate for the in-place-like update of stuff."},{"role":"assistant","content":"```cryptol\nmodule Bug where\n\nimport Array\n\ntype Widget = [3]\ntype Wombat = [4]\ntype Key = [5]\nnewtype Info = {\n   stuff: Array [5] [6]\n}\n\nonce: Info -> Key -> Widget -> Wombat -> Info\nonce info key widget = info'\n   where\n      info' = Info {\n         stuff = arrayUpdate info.stuff key 0\n      }\n\niter: {n} n < 10 => Info -> Key -> [n] (Widget, Wombat) -> Info\niter info key entries = infos ! 0\n   where\n      infos = [info] # [once info' key widget wombat\n                           | info' <- infos\n                           | (widget, wombat) <- entries]\n\nprocess: {n} n < 10 => Info -> [n] (Widget, Wombat) -> Info\nprocess info entries = iter info 0 entries\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue485a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named issue485a that imports the Float module and contains the following definitions: (1) a private type alias A denoting functions from an 8-bit sequence to an 8-bit sequence; (2) a private type alias ByteFun t denoting functions from an 8-bit sequence to a result of type t; (3) a constant foo of type RoundingMode with the numeric value zero; (4) a function bar with type A that returns its 8-bit argument unchanged (identity over 8-bit values); (5) a function baz with type ByteFun (ByteFun [8]) that represents the curried 8-bit addition operator, i.e., given an 8-bit value, it returns a function that adds another 8-bit value with wraparound modulo 2^8. Provide explicit type signatures, enforce the stated visibility (private for the type aliases, public for the values), and ensure the addition behavior matches 8-bit modular arithmetic."},{"role":"assistant","content":"```cryptol\nmodule issue485a where\n\nimport Float\n\nprivate type A = [8] -> [8]\n\nprivate type ByteFun t = [8] -> t\n\nfoo : RoundingMode\nfoo = 0\n\nbar : A\nbar x = x\n\nbaz : ByteFun (ByteFun [8])\nbaz = (+)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1324.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares two record type synonyms: the first has exactly one field that is an 8-bit word, and the second has exactly one field that is a 16-bit word. Define a function with an explicit type signature that takes a value of the first record type and returns the unit value, implemented by ignoring its argument. Then define a second function with an explicit type signature that takes a value of the second record type and returns the unit value, and define this second function to be equal to (i.e., an alias of) the first function. Include the type synonyms, both function type signatures, and the function definitions exactly as described, using unit as the return value."},{"role":"assistant","content":"```cryptol\ntype T = { a: [8] }\ntype S = { a: [16] }\n\nf : T -> ()\nf _ = ()\n\ng : S -> ()\ng = f\n```"}]}
{"filename":"cryptol\/tests\/issues\/trac289.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the following and proves their relationships: (1) Six functions named average33, average1, average2, average3, average4, and average5, each with type [32] -> [32] -> [32], operating on unsigned 32-bit words. average33 computes a safe average by zero-extending both inputs to 33 bits, adding them, dividing by 2, then discarding the extra high bit to return a 32-bit result. average1 returns (x + y) divided by 2 using 32-bit arithmetic. average2 returns (x\/2) + (y\/2) plus 1 iff both inputs are odd, else 0. average3 returns (x + y) logically right-shifted by 1. average4 returns (x >> 1) + (y >> 1) plus 1 iff both inputs\u2019 least significant bits are 1, else 0. average5 returns lo + ((hi - lo) >> 1), where lo is the minimum and hi is the maximum of the inputs. (2) Properties av1, av2, av3, av4, and av5 that, for all 32-bit x and y, assert average33 equals average1, average2, average3, average4, and average5 respectively. (3) A property applesOranges that, for all 32-bit x and y, asserts average4 equals average5. Include necessary type signatures and ensure division and shifts are interpreted on unsigned words."},{"role":"assistant","content":"```cryptol\naverage33 : [32] -> [32] -> [32]\naverage33 x y = drop`{1}(z'\/2)\n    where\n          z' : [33]\n          z' = (0b0 # x) + (0b0 # y)\n\naverage1 : [32] -> [32] -> [32]\naverage1 x y = (x + y)\/2\n\naverage2 : [32] -> [32] -> [32]\naverage2 x y = x\/2 + y\/2 + (x%2 && y%2)\n\naverage3 : [32] -> [32] -> [32]\naverage3 x y = (x + y) >> 1\n\naverage4 : [32] -> [32] -> [32]\naverage4 x y =    (x >> 1) + (y >> 1) + (x && y && 1)\n\naverage5 : [32] -> [32] -> [32]\naverage5 x y = lo + ((hi - lo)>>1) where\n    lo = min x y\n    hi = max x y\n\nproperty av1 x y = average33 x y == average1 x y\nproperty av2 x y = average33 x y == average2 x y\nproperty av3 x y = average33 x y == average3 x y\nproperty av4 x y = average33 x y == average4 x y\nproperty av5 x y = average33 x y == average5 x y\n\nproperty applesOranges x y = average4 x y == average5 x y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue214.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol function named bm that reorders an input sequence by grouping even-indexed elements first, followed by odd-indexed elements. Make it polymorphic over the element type and parameterized by a natural r that is finite and at least 1. Provide the type signature so that, for any element type and such r, the function maps a sequence of length twice r to a sequence of the same length and element type. Implement the body by selecting the subsequence of elements at all even positions (from the first element to the last even position) and concatenating it with the subsequence of elements at all odd positions (from the second element to the last odd position), both in increasing index order. Use selection by a list of indices and sequence concatenation primitives. Ensure the output preserves the relative order within the even group and within the odd group, and that the length and element type are unchanged."},{"role":"assistant","content":"```cryptol\nbm : {r} (fin r, r >= 1) => [2*r] -> [2*r]\nbm B = (B @@ [0,2..2*r-2]) # (B @@ [1,3..2*r-1])\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue614.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares two polymorphic functions with explicit size parameters and constraints. First, define a function named f with size parameters m, n, k, constrained so that n equals the maximum of the three numbers 2, m, and k, and that this maximum is also equal to m plus 1. Give f a type that takes a single m-bit word and returns a sequence of length k where each element is an n-bit word. Implement f so it ignores its input and produces the all-zero value of the result type (a k-length sequence of n-bit zeros). Second, define a function named g with size parameters n and k, requiring both sizes to be finite and satisfying 0 < n \u2264 k. Give g a type that maps an n-bit word to a k-bit word, and implement g to return the sign-extended form of its input to width k. Include all necessary constraints in the type signatures and provide the function bodies accordingly."},{"role":"assistant","content":"```cryptol\nf : {m, n, k} (n == max 2 m k == m + 1) => [m] -> [k][n]\nf x = zero\n\ng : {n, k} (fin n, fin k, 0 < n <= k) => [n] -> [k]\ng x = sext x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue416.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol definitions for two functions with an implicit size parameter that is a finite natural whose bit-width is at most three. Both functions must return a sequence of exactly three numbers constructed by the arithmetic progression whose first term is 1, whose second term is the value of that size parameter, and whose final term is 7 (inclusive). Give the first function an explicit type where the element bit-width equals the computed length of that progression (use the built-in operator that computes the number of elements in a from\u2013then\u2013to enumeration based on the first, second, and final terms). Give the second function an explicit, more general type where the outer sequence length is three but the element bit-width is left polymorphic\/unspecified. Implement both function bodies by constructing that enumeration. State the constraints on the size parameter in the type signatures, and ensure the same enumeration is used in both bodies."},{"role":"assistant","content":"```cryptol\nf : {n} (fin n, 3 >= width n) => [lengthFromThenTo 1 n 7][3]\nf = [1, n .. 7]\n\ng : {n} (fin n, 3 >= width n) => [_][3]\ng = [1, n .. 7]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue364.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares: (1) a constant x with type [64], defined as the deterministic output of the Cryptol random function when seeded with the integer 123; (2) a constant x_val with type [64], set to the known expected 64-bit result corresponding to that same seed; (3) a property x_eval that checks x equals x_val; (4) a property x_distinct that checks x is not equal to the 64-bit zero value; (5) a property moderately_bogus_property that takes an argument seed of type [8] and checks that, when forming a larger seed by sequence-concatenating a zero-valued prefix with the 8-bit seed and passing it to the random function, the resulting [64]-bit value is not equal to the 64-bit zero value. Use explicit [64] type annotations for x, x_val, and any zero literal compared against them, and specify the [8] type for the property argument. Do not implement any additional functions beyond these declarations."},{"role":"assistant","content":"```cryptol\nx : [64]\nx = random 123\n\nx_val : [64]\nx_val = 0xe4f7c1740def67df\n\nproperty x_eval = x == x_val\nproperty x_distinct = ~ (x == zero)\n\nproperty moderately_bogus_property (seed:[8]) =\n  ~(random (zero#seed) == (0:[64]))\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue826.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol function named WStep with a polymorphic type: for any finite natural n with n \u2265 2, it takes (1) a block cipher function from 128-bit to 128-bit, (2) an n-element sequence of 64-bit words representing state, and (3) a 64-bit word used as a mask\/tweak, and returns an n-element sequence of 64-bit words. The function\u2019s behavior: interpret the state as a head element and a nonempty tail. Concatenate the head and the first element of the tail to form a 128-bit value (head in the upper 64 bits), apply the cipher to obtain a 128-bit result, and split that result into upper and lower 64-bit halves. XOR the upper half with the 64-bit mask to produce the new head. Form the new tail by removing the first element from the original tail and appending the lower half to the end. Return the updated state as the new head followed by the new tail. Provide a type signature that enforces finiteness of n and the constraint n \u2265 2, and ensure all bit widths and sequence lengths match these roles."},{"role":"assistant","content":"```cryptol\nWStep:\n    {n}\n    (fin n, n >= 2) ->\n    ([128] -> [128]) -> [n][64] -> [64] -> [n][64]\nWStep CIPHk ([A] # Rs) t = [A'] # Rs'\n  where\n    [MSB, LSB] = split (CIPHk (A # head Rs))\n    A'         = MSB ^ t\n    Rs'        = tail Rs # [LSB]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue212.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define three Cryptol declarations with precise polymorphic type signatures and bodies:\n- A value named width_eq_geq parameterized by a numeric type variable n, constrained so that the bit-width of n equals 32 and n is at least 1. Its type is an n-length sequence of bits. Its value is an n-element sequence with every bit set to true (construct via a comprehension producing exactly n elements).\n- A value named can_not_width parameterized by a numeric type variable n, constrained so that the bit-width of 8\u00b7(n+1) is at most 64. Its type is a 64-bit sequence. Its value is formed by concatenating a prefix of zeros with the value-level encoding of n as an unsigned bit-vector whose width equals the bit-width of n, so that the total length is exactly 64 bits.\n- A function named take_knows_no_bounds parameterized by a numeric type variable n, constrained to be finite and at least 4. It takes a sequence of n bytes and returns a sequence of bytes whose length is k = 4 \u2212 (n mod 4). Implement it by taking the first k elements of the input using a type-level length parameter equal to k. Ensure all constraints appear in the type signatures and the result lengths match the described expressions."},{"role":"assistant","content":"```cryptol\nwidth_eq_geq : {n} (32 == width n, n >= 1) => [n]Bit\nwidth_eq_geq = [True | _ <- [1..n] : [_][32] ]\n\ncan_not_width : {n} (64 >= width (8*(n+1))) => [64]\ncan_not_width = zero # (`n : [width n])\n\ntake_knows_no_bounds : {n} (fin n, n >= 4) => [n][8] -> [4 - (n%4)][8]\ntake_knows_no_bounds ns = foo\n where\n foo = take `{4 - (n%4)} ns\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1024b.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Create a Cryptol specification that introduces a constraint synonym with two parameters\u2014a type and a proposition\u2014that expands to require the type has a zero element, supports comparison, and satisfies the given proposition. Then declare a polymorphic, argumentless definition with an explicit type signature that quantifies one type variable and requires that synonym instantiated with the proposition asserting the type supports bitwise logical operations. Implement the definition to return the bitwise complement of the zero value of that type."},{"role":"assistant","content":"```cryptol\ntype constraint PredSyn (a : *) (p:Prop) = (Zero a, Cmp a, p)\n\nsomeFunc : {a} (PredSyn a (Logic a)) => a\nsomeFunc = ~zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/T1440.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named T1440 that contains the following submodule structure and imports:\n- Import an interface submodule named X.\n- Import a regular submodule named Y.\n- Declare an interface submodule I that exports one size parameter n of kind # (no values or constraints beyond its kind).\n- Declare a submodule M whose only content is importing the interface submodule I.\n- Declare a submodule N that defines a single value x equal to the numeric literal 2 (leave its type to default inference, or choose a concrete finite word type if required).\n- Define a submodule M1 as an alias or instantiation based on submodule M that includes a nested submodule named U1 in its body.\n- Define a submodule M2 as an alias or instantiation based on a submodule named U2 that includes submodule N in its body.\nEnsure all constructs use valid Cryptol syntax for interface submodules, submodule imports, and submodule alias\/instantiation with nested submodule inclusion. Do not introduce additional bindings, properties, or exports beyond those listed."},{"role":"assistant","content":"```cryptol\nmodule T1440 where\n\nimport interface submodule X\n\nimport submodule Y\n\ninterface submodule I where\n  type n : #\n\nsubmodule M where\n  import interface submodule I\n\nsubmodule N where\n  x = 2\n\nsubmodule M1 = submodule M { submodule U1 }\nsubmodule M2 = submodule U2 { submodule N }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue368.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares a total function taking two 8-bit sequences as inputs and returning an 8-bit sequence, ignoring both inputs and always producing the all-zero 8-bit value. Then introduce two arbitrary 8-bit variables and add multiple top-level equations that, for a broad variety of binary operators (including arithmetic, bitwise, concatenation, and other symbolic forms), state that applying each operator to these two variables yields the same result as invoking the function on the same variables. Clearly specify the types of the function and variables, and make each equation compare the operator application to the function call using the same pair of variables."},{"role":"assistant","content":"```cryptol\nmyFun : [8] -> [8] -> [8]\nmyFun a b = 0\n\nx + y = myFun x y\nx * y = myFun x y\nx - y = myFun x y\nx ~ y = myFun x y\nx ^^ y = myFun x y\nx ++ y = myFun x y\nx .+ y = myFun x y\nx +. y = myFun x y\nx !+ y = myFun x y\nx +! y = myFun x y\nx .! y = myFun x y\nx :+ y = myFun x y\nx =+ y = myFun x y\nx .: y = myFun x y\nx :+: y = myFun x y\nx +:: y = myFun x y\nx ^^^ y = myFun x y\nx .... y = myFun x y\nx +x .\n```"}]}
{"filename":"cryptol\/tests\/issues\/T146.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the following in Cryptol with precise polymorphic record constraints and implementations: (1) a function that, for any element type, takes a record containing a field named v0 of that element type and returns that element; (2) a function that, for any element type, takes a record containing a field named field whose value is a record with a v0 field of that element type, and returns that element; (3) a function that, given a record f meeting the first function\u2019s requirement, constructs and returns a record c with fields: field set to f, v1 set to the result of applying the first function to f, and v2 set to the result of applying the second function to c itself. Provide explicit type signatures expressing the required record fields and ensure v1 and v2 have exactly the same type as f.v0. Do not add or rename fields."},{"role":"assistant","content":"```cryptol\nmk_curve_ops f = undefined\n  where\n    c = { field = f\n        , v1    = ec_v1 f\n        , v2    = ec_v2 c\n        }\n\nec_v1 : {fv} { v0: fv } -> fv\nec_v1 = undefined\n\nec_v2 : {fv} _ -> fv\nec_v2 p = p.field.v0\n  where _ = p.field.v0\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1024a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two type synonyms and one polymorphic constant. 1) Create a type synonym named Funny that takes one parameter whose kind is a type constructor from numeric kinds to value types; the synonym must equal the built-in arbitrary-precision integer type. 2) Create a type synonym named Strange that takes one parameter of proposition\/constraint kind; this synonym must also equal the arbitrary-precision integer type. 3) Declare a constant named funnyFunc with a type signature that universally quantifies: a numeric type variable, a type-constructor variable of kind from numeric kinds to value types, and a value type variable. The result type must be the arbitrary-precision integer type. Provide a definition for this constant that evaluates to the additive identity for integers. Include explicit kind annotations for all quantified variables and for the parameters of the two type synonyms."},{"role":"assistant","content":"```cryptol\ntype Funny (f : # -> *) = Integer\ntype Strange (f : Prop) = Integer\n\nfunnyFunc : { i : #, f : # -> *, g : * } Integer\nfunnyFunc = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue225.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named EnigmaBroke that contains the following definitions: (1) a type alias for a rotor as a 26-element sequence of pairs, each pair consisting of a character and a bit; (2) a total polymorphic function with a finiteness constraint that takes a 26-element sequence of characters and a sequence of some finite-width type and returns a rotor, ignoring its inputs and producing the zero value of the rotor type; (3) a function that takes a bit, a character, and a rotor and returns a triple of bit, character, and rotor, producing the zero value of that triple type; (4) a function parameterized by a finite size that takes a sequence of that many rotors and an input character and returns a pair of a same-length rotor sequence and a character. Specify that this function constructs an initial rotor from the contiguous uppercase alphabet and an empty sequence using the earlier constructor; seeds a sequence of triples with a fixed-true bit, the input character, and the initial rotor; then extends this sequence by iterating over the input rotors in order, at each step invoking the scrambling function with the previous triple\u2019s bit and character and the current rotor. State that the returned rotor sequence is the tail of the rotor components extracted from the constructed triple sequence, and the returned character equals the character from the initial triple (i.e., the input character). Include finiteness constraints on size parameters, and describe the use of sequence concatenation, list comprehension with parallel generators, element selection by index, and tail extraction."},{"role":"assistant","content":"```cryptol\nmodule EnigmaBroke where\n\ntype Rotor       = [26](Char, Bit)\n\nmkRotor : {a} (fin a) => ([26]Char,[a]) -> Rotor\nmkRotor (_,_) = zero\n\nscramble : (Bit, Char, Rotor) -> (Bit, Char, Rotor)\nscramble (_,_,_) = zero\n\njoinRotors : {n} (fin n) => ([n]Rotor, Char) -> ([n]Rotor, Char)\njoinRotors (rotors, inputChar) = (rotors', outputChar)\n  where\n    initRotor = mkRotor (['A' .. 'Z'], [])\n    \/\/ ncrs : [n+1](Bit, [8], Rotor)\n    ncrs = [(True, inputChar, initRotor)]\n               # [ scramble (notch, char, r)\n                 | r <- rotors\n                 | (notch, char, rotor') <- ncrs\n                 ]\n    rotors' = tail [ r | (_, _, r) <- ncrs ]\n    (_, outputChar, _) = ncrs ! 0\n```"}]}
{"filename":"cryptol\/tests\/issues\/Issue796.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Issue796 that conforms to the existing signature Issue796_Sig and contains the following definitions. Include a numeric type parameter k of kind #. Declare type aliases: Key as a sequence of (8*k) bits, Block as a 64-bit sequence, and RoundKey as a 64-bit sequence. Provide explicit type signatures and implementations for three functions: (1) aux takes a RoundKey and a Block and returns a Block; implement it to produce the all-zero 64-bit block. (2) key_schedule takes a Key and returns a RoundKey; implement it to produce the all-zero 64-bit round key. Inside key_schedule, add a local binding that partitions the input key into groups of four elements solely to enforce that the key\u2019s length is compatible with grouping by four; the grouped value may be ignored. (3) encrypt_block takes a Key and a Block and returns a Block, computed by applying aux to the round key produced by key_schedule and the provided plaintext block. Ensure all type signatures match these descriptions and that encrypt_block composes key_schedule and aux as specified."},{"role":"assistant","content":"```cryptol\nmodule Issue796 = Issue796_Sig where\n\nparameter\n  type _k: #\n\ntype Key = [8 * _k]\ntype Block = [64]\ntype RoundKey = [64]\n\naux : RoundKey -> Block -> Block\naux RK P = zero\n\nkey_schedule K = zero\n  where\n    _ = [ groupBy`{4} K ]\n\nencrypt_block key pt = aux (key_schedule key) pt\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue581.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two polymorphic functions named foo and bar with explicit type signatures parameterized by size variables i and j, constrained so that both are finite and j is at least 1. Each function returns a sequence of 32-bit words. The result length of foo must be the type-level integer quotient obtained when dividing i by j, and the result length of bar must be the corresponding type-level remainder from dividing i by j. Implement both functions by producing the first N elements of a monotonically increasing sequence of natural numbers starting at zero, where N is determined as above for each function, ensuring the element type is a 32-bit unsigned word and only the length depends on i and j."},{"role":"assistant","content":"```cryptol\nfoo : {i, j} (fin i, fin j, j >= 1) => [i \/^ j][32]\nfoo = take [0...]\n\nbar : {i, j} (fin i, fin j, j >= 1) => [i %^ j][32]\nbar = take [0...]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue185.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol function named group that partitions a flat sequence into fixed-size chunks. Provide a polymorphic type with size parameters perGroup, a, b, c and constraints: perGroup is finite, and c equals perGroup multiplied by a. The function must take a sequence of length c of elements of type b and return a sequence of length a where each element is a sequence of length perGroup of type b. Implement the body by splitting the input into consecutive, non-overlapping chunks of size perGroup, preserving the original order, with no padding or truncation. Include the complete type signature with the numeric equality and finiteness constraints, and the function definition that realizes this partitioning behavior."},{"role":"assistant","content":"```cryptol\ngroup : {perGroup, a, b, c} (fin perGroup, c == perGroup * a)\n    => [c]b -> [a][perGroup]b\ngroup xs = split`{each=perGroup}xs\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue187.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Enigma that contains the following definitions: (1) a polymorphic value enigmaLoop with a type that, for any finite size n, yields a sequence of n bits; (2) a function enigma with a type that, for any finite sizes n and m, takes a pair whose first element is a sequence of n bits and whose second element is a sequence of m bits, and returns a sequence of m bits. Implement enigma so that it ignores the actual bit values and produces an output sequence of length m consisting entirely of True, derived by discarding an initial seed element from a stream of pairs and keeping only the second components. Include a property that universally quantifies over n, m, and all inputs of the specified types, and checks that the result of enigma equals a sequence of True values whose length matches the length of the second input. Clearly state the finiteness constraints on n and m, name all parameters, and provide explicit type signatures for both definitions and the property."},{"role":"assistant","content":"```cryptol\nmodule Enigma where\n\nenigmaLoop : {n}(fin n) => [n]\nenigmaLoop = undefined\n\nenigma : {n, m} (fin n, fin m) => ([n], [m]) -> [m]\nenigma (m, pt) = tail [ True | _ <- rcs ]\n  where rcs = [ (m, True)] #\n              [ (enigmaLoop, True)\n              | _     <- pt\n              | (_,_) <- rcs\n              ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1511.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named M that contains the following definitions: (1) a newtype MOOD_t as a record with a single field named value of type [1]; (2) a constant MOOD that is a record with fields HAPPY and SAD, each of type MOOD_t, where HAPPY is constructed with value set to the one-bit constant 1 and SAD is constructed with value set to the one-bit constant 0; (3) a constant v of type [1] that is equal to the value field of the SAD entry within MOOD. Use record construction and field selection so that v references the nested field from MOOD.SAD, and ensure all names and types match exactly."},{"role":"assistant","content":"```cryptol\nmodule M where\n\nv: [1]\nv = MOOD.SAD.value\n\nnewtype MOOD_t = { value: [1] }\n\nMOOD = { HAPPY = MOOD_t { value = 0b1 }\n       , SAD   = MOOD_t { value = 0b0 }\n       }\n```"}]}
{"filename":"cryptol\/tests\/issues\/trac133.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two functions named example1 and example2 with identical polymorphic type signatures: for a numeric parameter a constrained to 1 <= a <= 2, each takes a sequence of 16*a elements where each element is 8 bits, and returns a sequence of 16 elements of 8 bits. Implement example1 by first creating a zero-filled sequence whose length is 16*(2 \u2212 a), concatenating it before the input, and then dropping the first 16 elements of this concatenation to produce the result (i.e., the last 16 elements of the original input). Implement example2 to produce the same result, but do not explicitly annotate the length of the zero-filled sequence; instead, rely on type inference to determine its length so that the input to the drop operation has total length 32 and the result has length 16. Provide the type signatures and definitions for both functions."},{"role":"assistant","content":"```cryptol\nexample1 : {a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8]\nexample1 k = drop`{16} ((zero : [16*(2 - a)][8]) #k)\n\nexample2 : {a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8]\nexample2 k = drop`{16} (zero # k)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue877.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) declares a polymorphic constant equal to the empty sequence with an explicit zero-length sequence type; (2) declares a finite sequence of Integers with an explicit length parameter; (3) defines three derived constants by selecting a subsequence from the Integer sequence using: (a) an empty index sequence, (b) the result of mapping a truncation function over an empty sequence to produce an empty index sequence, and (c) the result of mapping a lambda that wraps each index in a singleton sequence over an empty sequence (to exercise the nested multi-index form); (4) provides explicit, general type signatures for all constants so the selections are well-typed, including constraints tying index widths to the Integer sequence length and ensuring all indices are within bounds; and (5) includes properties asserting that each of the three selections yields the empty sequence and that all three results are equal to each other. Keep the specification general and polymorphic where possible, using size parameters and necessary numeric constraints, and avoid introducing any behavior beyond these declarations and properties."},{"role":"assistant","content":"```cryptol\na = []\n\nxs : [_] Integer\nxs = [1,2,3]\n\nb = xs @@ []\nc = xs @@ (map trunc [])\nd = xs @@ (map (\\x -> [x]) [])\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue_1812.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define six top-level Cryptol definitions named f, g, ff, gg, jj, and kk with explicit polymorphic size parameter h (subject to the fin h constraint). Specify their sequence lengths using type-level arithmetic as follows: f has length 2^h + (2^h \u2212 2^h) and is defined by specializing g at h; g has length 2^h and is the all-zero sequence. Similarly, ff has length (2^h + 2^h) \u2212 2^h and is defined by specializing gg at h; gg has length 2^h and is the all-zero sequence. Define jj with length 2^(1 + h) \u2212 1 and make it equal to kk specialized at h. For kk, add the additional numeric constraint 2^(1 + h) \u2212 1 \u2265 2^h \u2212 1, give it length (2^h \u2212 1) + 2^h, and define it as the all-zero sequence. Ensure all type signatures state the constraints and sizes precisely, and that the definitions use only specialization (no additional computation) to tie each pair (f,g), (ff,gg), and (jj,kk). Do not introduce properties; just provide type signatures and value definitions consistent with the stated lengths and constraints."},{"role":"assistant","content":"```cryptol\nf : {h} (fin h) => [2^^h + (2^^h - 2^^h)]\nf = g`{h}\n\ng : {h} (fin h) => [2^^h]\ng = zero\n\nff : {h} (fin h) => [(2^^h + 2^^h) - 2^^h]\nff = gg`{h}\n\ngg : {h} (fin h) => [2^^h]\ngg = zero\n\njj : {h} (fin h) => [2 ^^ (1 + h) - 1]\njj = kk`{h}\n\nkk : {h} (fin h, 2 ^^ (1 + h) - 1 >= 2 ^^ h - 1) => [2 ^^ h - 1 + 2 ^^ h]\nkk = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue268.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two constants named xs and vs as sequences of length 10 of pairs of 8-bit words. For xs, introduce a helper infinite stream of such pairs with an explicit infinite-length type annotation; the stream is corecursively defined with a fixed head pair and a tail produced by a comprehension over the stream\u2019s own tail (after dropping one element), where each new pair\u2019s first component is a fixed 8-bit constant and the second component is the first component of the source pair. Set xs to the first ten elements of this stream. For vs, define it as the first ten elements of a self-referential stream that is the fixpoint of the same comprehension (no explicit seed). Ensure both definitions type-check, use pair pattern matching in the comprehension, and that the resulting 10-element sequences are extensionally equal."},{"role":"assistant","content":"```cryptol\nxs : [10]([8],[8])\nxs = take `{10} zs\n  where\n  zs : [inf]([8],[8])\n  zs = [(0,0)] # [ (0, z) | (z,_) <- drop `{1} zs]\n\nvs : [10]([8],[8])\nvs = take `{10} zs where zs = [ (0, z) | (z,_) <- zs]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue731.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains the following definitions: (1) a type-constraint alias C1 over a single numeric parameter n that requires n to be finite and at least 1; (2) a type-constraint alias C2 over two constraint parameters p and q that is the conjunction of p and q; (3) a type-constraint alias C3 over two numeric parameters i and j that uses C2 to require both i and j are finite; (4) a type-constraint alias C4 over two numeric parameters a and b that encodes equality by requiring a \u2264 b and a \u2265 b. Do not define any values or functions; only provide these constraint aliases, suitable for reuse in type signatures."},{"role":"assistant","content":"```cryptol\nmodule issue731 where\n\ntype constraint T n = (fin n, n >= 1)\n\ntype constraint Both p q = (p, q)\n\ntype constraint Fin2 i j = Both (fin i) (fin j)\n\ntype constraint i <=> j = (i <= j, i >= j)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1562.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Create a Cryptol specification that defines the following submodule structure: (1) an interface submodule named I that exposes a type alias Zp representing an 8-bit sequence; (2) a submodule F whose contents import the interface submodule I; (3) a submodule M that defines a type alias Empty equal to a single bit; (4) two distinct submodule instances, F1 and F2, each constructed by instantiating F with the submodule argument M using the standard submodule instantiation syntax. Preserve the exact names I, F, M, F1, F2, Zp, and Empty. Do not add any values, functions, constraints, or properties beyond these declarations. Ensure F\u2019s import refers to the interface of I, and ensure both F1 and F2 are separate instantiations that use the same M."},{"role":"assistant","content":"```cryptol\ninterface submodule I where\n  type Zp = [8]\n\nsubmodule F where\n  import interface submodule I\n\nsubmodule M where\n      type Empty = Bit\n\nsubmodule F1 = submodule F { submodule M }\nsubmodule F2 = submodule F { submodule M }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1210.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines four properties with the following exact types and behaviors: (1) A property named mwe with type: takes a 2-bit value and a sequence of two 1-bit values, returns a boolean bit; it asserts that the first element of the 2-element 1-bit sequence equals that same element left-shifted by a distance equal to zero times the 2-bit input. (2) A property named mwe' with type: takes a 2-bit value and a single 1-bit value, returns a boolean bit; it asserts that the 1-bit value equals itself left-shifted by a distance equal to zero times the 2-bit input. (3) A property named mwe'' with no arguments, returning a boolean bit; within a where-clause bind a 1-bit constant equal to one and a 2-bit constant equal to zero, and assert that the 1-bit constant equals itself left-shifted by the 2-bit constant. (4) A property named bitget with type: takes a 12-bit index and a sequence of 436 elements of 8 bits (bytes), returns a boolean bit; it states that if the index is less than 3488 (the total number of bits), then the zero-extended result of extracting the bit at that index from the addressed byte (select byte at index divided by 8, shift right by the index modulo 8, mask with 1) is equal to a 16-bit constant that is 0x0001 when the bit at that position in the bitstring formed by reversing the bits in each byte and concatenating all bytes is set, and 0x0000 otherwise. Include the precise type signatures and the local bindings for mwe'' exactly as described."},{"role":"assistant","content":"```cryptol\nmwe : [2] -> [2][1] -> Bit\nproperty mwe i r = r@0 == (r@0) << 0*i\n\nmwe' : [2] -> [1] -> Bit\nproperty mwe' i r = r == (r << 0*i)\n\nmwe'' : Bit\nproperty mwe'' = r == (r << i)\n where r = 1:[1]\n       i = 0:[2]\n\nbitget : [12] -> [436][8] -> Bit\nproperty bitget i r = i < 3488 ==> bit_gf == if bit_bit then 0x0001 else 0x0000\n  where bit_gf = (zext (((r@(i\/8)) >> (i%8) ) && 1))\n        bit_bit = (join (map reverse r))@i\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue108.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function named sum in Cryptol with an explicit type signature: for finite natural parameters a and b, it takes a sequence of length a whose elements are b-bit words and returns a b-bit word. Implement the body by building a running-accumulator sequence that begins with zero and then, for each step, adds the current input element to the current accumulator using modular addition on b-bit words. Construct this accumulator via a zipped comprehension that pairs each input element with the corresponding accumulator value from the self-referential sequence. Return the final accumulated value by selecting the last element of the accumulator sequence. Ensure the type signature includes the fin constraints on a and b and matches the shape [a][b] -> [b]."},{"role":"assistant","content":"```cryptol\nsum : {a,b} (fin a, fin b) => [a][b] -> [b]\nsum xs = ss ! 0\n  where\n    ss = [0] # [ s + x | x <- xs | s <- ss ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue130.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define three functions and one property as follows: (1) A function named parity that takes a sequence of Bits and computes its XOR parity by forming a running state seeded with False and, for each input bit, XORing it with the previous state; return the final state (the last element of the state stream). (2) A function named foldl1 that, for a non-empty sequence, performs a left-associative reduction with a given binary function by seeding the state with the first element and iteratively combining with each subsequent element; return the final state. Make it polymorphic over element type and sequence length, with appropriate constraints to ensure the length is at least one. (3) A function named par defined as the XOR reduction obtained by applying foldl1 with the XOR operator over a sequence of Bits. Finally, define the property named parOK with a polymorphic size parameter n constrained to be finite; it takes a sequence of n+1 Bits and returns a Bit, asserting that for every such input, the result of par equals the result of parity. Include any necessary type quantification and constraints."},{"role":"assistant","content":"```cryptol\nparity xs = ys!0\n  where ys = [False] # [y ^ x | x <- xs | y <- ys ]\n\nfoldl1 f xs = ys!0\n  where ys = [xs@0] # [ f y x | y <- ys | x <- tail xs ]\n\npar = foldl1 (^)\n\nparOK : {n} (fin n) => [n+1] -> Bit\nproperty parOK x = par x == parity x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1798.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two functions named exhaustive1 and exhaustive2 with explicit type signatures and guarded equations. Both are polymorphic over a numeric size parameter w. For exhaustive1: its type takes and returns a bitvector whose length is 2^(2^w). Implement it with two guards that depend only on the numeric length expression: (a) when 2^(2^w) < 2, return the input unchanged; (b) when 2^(2^w) == 2, return the bitwise complement of the input. Do not include any default or else case. For exhaustive2: its type takes and returns a bitvector whose length is 2^w. Implement it with a single guard: when 2^w == 1, return the bitwise complement of the input. Again, do not include a default case. Use Cryptol\u2019s numeric exponentiation for length calculations and the word-level complement operator. State the polymorphic constraint on w and ensure the guards are purely numeric constraints over w, not dependent on the input value."},{"role":"assistant","content":"```cryptol\nexhaustive1 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1 x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n\nexhaustive2 : {w} [2 ^^ w] -> [2 ^^ w]\nexhaustive2 x\n  | (2 ^^ w) == 1 => ~ x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue093.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that includes the following: - A property named t0 that evaluates to true unconditionally. - A property named t1 that, for all 32-bit words x, asserts x is equal to the same value when explicitly viewed as a 32-bit word. - A property named t2 that, for all 32-bit words x and y, states: if x (as a 32-bit word) is less than y (as a 32-bit word), then y is not the all-zero 32-bit value; otherwise the condition holds trivially. - A Boolean constant named not_a_prop set to true (do not declare it as a property). - A property named f0 that evaluates to false unconditionally. Provide explicit type signatures: t0 and f0 are Boolean properties with no arguments; t1 has type [32] -> Bit; t2 has type [32] -> [32] -> Bit; not_a_prop has type Bit. Do not include implementations or proofs; only specify the declarations and their intended behavior in comments if needed."},{"role":"assistant","content":"```cryptol\nproperty t0 = True\nproperty t1 x = x == (x : [32])\nproperty t2 x y = if (x : [32]) < (y : [32]) then y != zero else True\nnot_a_prop = True\nproperty f0 = False\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue723.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a property named prop_f_selfXorIsZero that, for any finite width n and any input x of length n, asserts that calling f on x yields the all-zero bitvector of length n (i.e., the bitwise XOR of x with itself). Quantify n with a fin constraint and x with type [n], and express the expected result using the zero value of type [n]. Ensure the property is suitable for checking with a SAT solver."},{"role":"assistant","content":"```cryptol\nf : {n} (fin n) => [n] -> [n]\nf x = g x\n  where\n    m1 = x\n\n    g : {k} (fin k) => [k] -> [k]\n    g m0 = m0 ^ m1\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue494.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) adds a polymorphic type signature to the second function so it accepts two sequences of equal length of 32-bit words and returns a single bit, with a constraint that the length parameter is finite; (2) defines its behavior as returning the first element of a self-referential left-to-right scan that starts with False and, for each aligned pair of input elements and the prior scan state, updates the state as the disjunction of the prior state with the comparison of the current left element being greater than the current right element; and (3) introduces a universally quantified verification condition that, for all admissible lengths and all input pairs, the two functions are extensionally equal (produce the same bit). Clearly name the functions and the verification artifact, and state all quantified variables and constraints in the type and the verification condition."},{"role":"assistant","content":"```cryptol\ngt_words : {a} (fin a) => [a][32] -> [a][32] -> Bit\ngt_words l0 l1 = ss!0\n  where\n    ss = [ False ] # [ s \\\/ (i > j) | i <- l0 | j <- l1 | s <- ss ]\n\ngt_words' l0 l1 = ss!0\n  where\n    ss = [ False ] # [ s \\\/ (i > j) | i <- l0 | j <- l1 | s <- ss ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue734.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol declarations that: (1) define a polymorphic function f parameterized by a finite natural a; its type accepts a bitvector whose length is 2^a \u2212 1 and returns a bitvector whose length is 3\u00b7(2^a \u2212 1); its definition is the input value concatenated with itself three times. (2) define a polymorphic constant asdf1 parameterized by a finite natural r with the constraint that the width of 2^r equals r+1; its type is a bitvector of length r+1, and its value is exactly the number 2^r represented at that width. (3) define a polymorphic constant asdf2 parameterized by a finite natural r with the constraint that the width of (2^r \u2212 1) equals r; its type is a bitvector of length r, and its value is exactly the number (2^r \u2212 1) represented at that width. Include the precise Cryptol type signatures with these constraints and the corresponding definitions only."},{"role":"assistant","content":"```cryptol\nf : {a} (fin a) => [2^^a - 1] -> [3*(2^^a - 1)]\nf x = x # x # x\n\nasdf1 : {r} (fin r, width (2^^r)==r+1) => [r+1]\nasdf1 = `(2^^r)\n\nasdf2 : {r} (fin r, width(2^^r-1)==r) => [r]\nasdf2 = `(2^^r-1)\n```"}]}
{"filename":"cryptol\/tests\/issues\/Issue883_A.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Issue883_A that contains the following definitions: (1) a numeric type parameter c declared in a parameter section with constraints that c is finite, c \u2265 1, and the bit-width of (c \u2212 1) is at most 64; (2) a polymorphic function dumbHash with a type parameter n, requiring n to be finite and its bit-width \u2264 64, that takes an n-bit sequence and returns a 128-bit sequence, always producing an all-zero 128-bit value irrespective of the input; (3) a polymorphic function asdf with a type parameter n, requiring n to be finite, the bit-width of n + 192 \u2264 64, and the bit-width of 128 \u00d7 c \u2264 64, that takes an n-bit sequence and returns a 128-bit sequence; inside asdf, define a local value ys as an array of length c + 1 whose elements are 128-bit zeros, drop the first element of ys, concatenate the remaining 128-bit blocks into a single sequence, and pass that sequence to dumbHash, returning its result; (4) include explicit type signatures for dumbHash, asdf, and ys, and use Cryptol primitives for dropping exactly one element and for concatenating an array of fixed-size blocks into a flat bitvector. Do not prove any properties; just provide the module, parameters, constraints, and function bodies as specified."},{"role":"assistant","content":"```cryptol\nmodule Issue883_A where\nparameter\n    type c : #\n    type constraint ( fin c, c >= 1, 64 >= width (c-1) )\n\ndumbHash : {n} (fin n, 64 >= width n) => [n] -> [128]\ndumbHash msg = zero\n\nasdf : {n} (64 >= width (n+192), 64 >= width (128 * c), fin n) => [n] -> [128]\nasdf msg = dumbHash (join (drop`{1} ys))\n where\n   ys : [c+1][128]\n   ys = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue640.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines three functions with explicit type signatures and self-referential constructions: (1) a function that takes a single bit and returns two bits by defining its result as the input concatenated with the first element of its own result (accessed via indexing); (2) a function with the same type and behavior, but instead of indexing, obtain the first element by taking a one-element prefix of its own result; and (3) a function that takes a length-1 sequence of 8-bit words and returns a length-2 sequence of 8-bit words using the same one-element-prefix approach. Also, define a property that, for all single-bit inputs, the first two functions produce identical outputs. Define another property that, for all length-1 sequences of 8-bit words, the third function\u2019s output consists of two copies of the sole input element in order. Use clear, distinct function names of your choice, and ensure the definitions use concatenation as described. Include no additional preconditions or assumptions."},{"role":"assistant","content":"```cryptol\nf : [1] -> [2]\nf x = out\n  where out = x # [out@0]\n\ng : [1] -> [2]\ng x = out\n  where out = x # (take out)\n\nh : [1] [8] -> [2] [8]\nh x = out\n  where out = x # take out\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/mergesort.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define two functions and one property implementing and checking a mergesort. Provide a polymorphic type signature for sort that, for any finite sequence length n and element type a with a comparison constraint, maps a sequence of length n to a sequence of the same length. Implement sort so that if the length is at most 1 it returns the input unchanged; otherwise it splits the input into a left half of floor(n\/2) elements and a right half of the remaining elements, recursively sorts both halves, and combines them with merge. Provide a polymorphic type signature for merge that, for any lengths m and n and comparable element type a, takes sequences of lengths m and n and returns a sequence of length m+n. Implement merge so that if one input is empty it returns the other; otherwise, decompose each input into head and tail, compare the heads, prepend the smaller (preferring the left element when equal) to the recursive merge of the corresponding tail with the other sequence. Use guards on the size parameters for the base cases. Finally, define the property sort_correct that asserts, as a conjunction of equalities, that applying sort to a diverse set of concrete integer sequences (including empty, singleton, and lists with negatives and duplicates) yields the expected ascending nondecreasing sequences for those examples."},{"role":"assistant","content":"```cryptol\nsort : {n,a} Cmp a => (fin n) => [n]a -> [n]a\nsort xs\n  | n <= 1 => xs\n  | ()     => merge (sort left) (sort right)\n              where (left : [n\/2] _) # right = xs\n\nmerge : {m,n,a} Cmp a => [m]a -> [n]a -> [m+n]a\nmerge xs ys\n  | m == 0  => ys\n  | n == 0  => xs\n  | (m > 0, n > 0) => if x <= y \n                        then [x] # merge restX ys\n                        else [y] # merge xs restY\n                      where\n                      [x] # restX = xs\n                      [y] # restY = ys\n\nproperty sort_correct =\n  (sort [] == []) &&\n  (sort [0] == [0]) &&\n  (sort [-6, 1, 9, -3, -9, 2, 4] == [-9, -6, -3, 1, 2, 4, 9]) &&\n  (sort [4, -8, -1, -7, -5, 9, 8, 8] == [-8, -7, -5, -1, 4, 8, 8, 9]) &&\n  (sort [1, -1, -2, -3, -2, 7, 5] == [-3, -2, -2, -1, 1, 5, 7]) &&\n  (sort [9, 9, 8, -3, 1, 1, -6, -6, -8] == [-8, -6, -6, -3, 1, 1, 8, 9, 9]) &&\n  (sort [9, 1, 5, 0] == [0, 1, 5, 9]) &&\n  (sort [8, 3, 3] == [3, 3, 8]) &&\n  (sort [-7, 8] == [-7, 8])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/nestFun.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol submodule named A parameterized by a numeric size variable n. Inside A, declare a boolean constant f with a type signature and guarded equations based on constraints on n: if n equals zero, f evaluates to true; if n is greater than zero, f evaluates to false. Then instantiate\/import this submodule twice under distinct module aliases: one instance binds n to the numeric value 2, and another instance binds n to the numeric value 0. Ensure the type parameter is declared as a numeric kind, the constant has a Bool type, and the guarded definitions cover the specified constraints without introducing any other bindings."},{"role":"assistant","content":"```cryptol\nsubmodule A where\n\n  parameter\n    type n : #\n\n  f : Bool\n  f | n == 0 => True\n    | n > 0  => False\n\nimport submodule A as Two where\n  type n = 2\n\nimport submodule A as Zero where\n  type n = 0\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/constant.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the following in Cryptol using constraint-guarded definitions and explicit type signatures: (1) A size-polymorphic constant named isZero with a numeric type parameter n (kind #) returning a single bit. It must yield true when n equals zero and false otherwise. (2) Define a property that validates isZero by checking it is false at an infinite size, true at size 0, and false at sizes 1, 2, 4, 8, and 16. (3) A size-polymorphic constant named isFin with a numeric type parameter n (kind #) returning a single bit. It must yield true when n is finite and false otherwise. (4) Define a property that validates isFin by checking it is false at an infinite size and true at sizes 0, 1, 2, 4, 8, and 16. (5) A size-polymorphic constant named idTypeNum with a numeric type parameter n (kind #) returning an Integer, guarded so it is defined only when n is finite; its value must be the value-level numeral corresponding to n. (6) Define a property that validates idTypeNum by asserting that, when instantiated at sizes 0, 1, 2, 4, 8, and 16, it produces those same integers. Use only properties to express the checks, and ensure each definition\u2019s constraints and kinds are explicit."},{"role":"assistant","content":"```cryptol\nisZero : {n : #} Bit\nisZero | n == 0 => True\n       | ()     => False\n\nproperty isZero_correct =\n  ~isZero `{inf} &&\n   isZero `{  0}   &&\n  ~isZero `{  1}   &&\n  ~isZero `{  2}   &&\n  ~isZero `{  4}   &&\n  ~isZero `{  8}   &&\n  ~isZero `{ 16}\n\nisFin : {n : #} Bit\nisFin | fin n => True\n      | ()    => False\n\nproperty isFin_correct =\n  ~isFin `{inf} &&\n   isFin `{  0}   &&\n   isFin `{  1}   &&\n   isFin `{  2}   &&\n   isFin `{  4}   &&\n   isFin `{  8}   &&\n   isFin `{ 16}\n\nidTypeNum : {n : #} Integer \nidTypeNum | fin n => `n\n\nproperty idTypeNum_correct =\n  (idTypeNum `{ 0}  ==  0) &&\n  (idTypeNum `{ 1}  ==  1) &&\n  (idTypeNum `{ 2}  ==  2) &&\n  (idTypeNum `{ 4}  ==  4) &&\n  (idTypeNum `{ 8}  ==  8) &&\n  (idTypeNum `{16}  == 16)\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/insert.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a polymorphic Cryptol function named insert with the following specification: it takes an element and a sequence of length n over the same orderable type and returns a sequence of length n+1. Constrain n to be finite and the element type to support ordering. The input sequence is assumed nondecreasing. Implement divide-and-conquer insertion with guarded cases: handle n=0 by returning a singleton sequence containing the element; handle n=1 by comparing the element with the sole item and producing the sorted pair. For n>1, split the sequence into a left prefix, a single pivot element, and a right suffix. When n is even, the left has length n\/2\u22121 and the right has length n\/2; when n is odd, both sides have length n\/2. Compare the new element to the pivot. If it is less than or equal to the pivot, recursively insert into the left side after appending the pivot at its end, then concatenate the unchanged right side. Otherwise, keep the left side with the pivot appended at its end and recursively insert into the right side, then concatenate. Use sequence concatenation to assemble results. Provide the exact type: for any finite n and orderable a, the function maps a and [n]a to [n+1]a. Also define a property named insert_correct that is a conjunction of ten equalities, each asserting that inserting one missing integer from 0 through 9 into its corresponding ascending list of the remaining values yields the fully sorted list 0 through 9."},{"role":"assistant","content":"```cryptol\ninsert : {n, a} (fin n, Cmp a) => a -> [n]a -> [n+1]a\ninsert x' xs \n  | n == 0         => [x']\n  | n == 1         => if x' <= x then [x', x] else [x, x']\n                      where [x] = xs\n  | ( n % 2 == 0\n    , n     >  1 ) => if x' <= x \n                        then insert x' (xs1 # [x]) # xs2 \n                        else xs1 # [x] # insert x' xs2\n                      where (xs1 : [n\/2 - 1]_) # [x] # (xs2 : [n\/2]_) = xs\n  | ( n % 2 == 1\n    , n     >  1 ) => if x' <= x \n                        then insert x' (xs1 # [x]) # xs2\n                        else xs1 # [x] # insert x' xs2\n                      where (xs1 : [n\/2]_) # [x] # (xs2 : [n\/2]_) = xs\n\nproperty insert_correct =\n  (insert 0 [  1,2,3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 1 [0,  2,3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 2 [0,1,  3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 3 [0,1,2,  4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 4 [0,1,2,3,  5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 5 [0,1,2,3,4,  6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 6 [0,1,2,3,4,5,  7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 7 [0,1,2,3,4,5,6,  8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 8 [0,1,2,3,4,5,6,7,  9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 9 [0,1,2,3,4,5,6,7,8  ] == [0,1,2,3,4,5,6,7,8,9])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/len.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a polymorphic Cryptol function named len with the type: for any finite natural n and element type a, it takes a sequence of n elements and returns an Integer. Use constraint guards on n: when n equals zero, return 0; when n is greater than zero, return 1 plus a recursive call on the sequence with its first element removed (drop exactly one element). Ensure termination by decreasing n each step. Then define a property named len_correct asserting, as a conjunction of test cases, that for the empty list and for lists of integers of lengths 1 through 8 (using consecutive literals starting at 1), the result of len equals the result of the built-in sequence-length function on those same lists."},{"role":"assistant","content":"```cryptol\nlen : {n,a} (fin n) => [n] a -> Integer\nlen x\n  | (n == 0) => 0\n  | (n >  0) => 1 + len (drop`{1} x)\n\nproperty \n  len_correct = and\n    [ len l == length l where l = []\n    , len l == length l where l = [1]\n    , len l == length l where l = [1,2]\n    , len l == length l where l = [1,2,3]\n    , len l == length l where l = [1,2,3,4,5]\n    , len l == length l where l = [1,2,3,4,5,6]\n    , len l == length l where l = [1,2,3,4,5,6,7]\n    , len l == length l where l = [1,2,3,4,5,6,7,8]\n    ]\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/tail.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a polymorphic function named tail with an explicit type signature: for any finite size parameter n and element type a, it takes a sequence of length n of a and returns a sequence whose length is (max n 1) minus 1. Implement tail using guarded equations based on the size n: when n equals zero, return the input sequence unchanged; when n is at least one, return the sequence with its first element removed (use the drop operation with count 1). Then define a property named tail_correct that asserts the conjunction of the following behaviors: the tail of an empty sequence is empty; the tail of a singleton sequence is empty; the tail of [1,2] is [2]; the tail of [1,2,3] is [2,3]; and the tail of [1,2,3,4] is [2,3,4]."},{"role":"assistant","content":"```cryptol\ntail : {n, a} (fin n) => [n]a -> [(max n 1) - 1]a\ntail xs | n == 0 => xs\n        | n >= 1 => drop `{1} xs\n\nproperty tail_correct =\n  (tail [] == []) &&\n  (tail [1] == []) &&\n  (tail [1,2] == [2]) &&\n  (tail [1,2,3] == [2,3]) &&\n  (tail [1,2,3,4] == [2,3,4])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/inits.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define Cryptol specifications for: (1) a polymorphic function inits with type parameters n and a, constrained so n is finite, that takes a sequence of length n over a and returns the concatenation of all non-empty initial segments of the input, with result length n*(n+1)\/2. Specify guarded equations: when n is zero return empty; otherwise decompose the input into its first element and remaining suffix and delegate to a loop that builds the result. (2) a helper function initsLoop with type parameters n, l, m, a and constraints fin l, fin m, m >= 1, and l + m = n. It takes three sequences: a remaining suffix of length l, the current prefix of length m, and an accumulator containing the concatenation of prefixes up to length m\u22121 (whose length is (m\u22121)*m\/2). Define guards on l: if l is zero, return the accumulator followed by the current prefix; otherwise split the suffix into head and tail, extend the current prefix by the head, append the previous prefix to the accumulator, and recurse. Also define a property named inits_correct asserting a conjunction of equalities that, for inputs consisting of the first k positive integers for k = 0..5, the output equals the concatenation of prefixes of lengths 1..k, respectively."},{"role":"assistant","content":"```cryptol\ninits : {n, a} (fin n) => [n]a -> [(n * (n+1))\/2]a\ninits xs\n  | n == 0 => []\n  | n >  0 => initsLoop xs' x []\n    where\n      (x : [1]_) # xs' = xs\n\ninitsLoop : {n, l, m, a} (fin l, fin m, l + m == n, m >= 1) =>\n        [l]a -> [m]a ->\n        [((m-1) * ((m-1)+1))\/2]a ->\n        [(n * (n+1))\/2]a\ninitsLoop ys zs acc\n  | l == 0 => acc # zs\n  | l >  0 => initsLoop ys' (zs # y) (acc # zs)\n   where (y : [1]_) # ys' = ys\n\nproperty inits_correct =\n  (inits [] == []) &&\n  (inits [1] == [1]) &&\n  (inits [1,2] == [1,1,2]) &&\n  (inits [1,2,3] == [1,1,2,1,2,3]) &&\n  (inits [1,2,3,4] == [1,1,2,1,2,3,1,2,3,4]) &&\n  (inits [1,2,3,4,5] == [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5])\n```"}]}
{"filename":"cryptol\/tests\/modsys\/T11\/A.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named T11::A that contains the following definitions: (1) two size parameters X and Y, each of kind #; (2) a type synonym T that is a pair where the first element is a sequence of bits of length X and the second element is a sequence of bits of length Y; (3) a function f with type T -> [X] that pattern matches its input pair and returns the first element, ignoring the second. Include the parameter block declaring X and Y with their kinds and the explicit type signature for f."},{"role":"assistant","content":"```cryptol\nmodule T11::A where\n\nparameter\n  type X : #\n  type Y : #\n\ntype T = ([X],[Y])\n\nf : T -> [X]\nf (x,_) = x\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T038.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named T038 that contains the following definitions: (1) an interface submodule I that requires a single 8-bit value named x; (2) a submodule F that is parameterized by any submodule implementing I, imports that interface parameter, and defines an 8-bit value y computed as x plus 1 using modulo-256 arithmetic; (3) a submodule Q that defines x as the 8-bit constant 11; (4) a submodule P that instantiates F with Q (binding F\u2019s interface dependency to Q) and also defines its own x as the 8-bit constant 11; and (5) an interface submodule J that imports F instantiated with P and declares an 8-bit value x. Ensure all x and y values have type [8], the imports correctly express F\u2019s dependency on I, P satisfies F\u2019s dependency via Q, and J reuses F in its context while requiring an 8-bit x. Do not provide implementations beyond these declarations and bindings."},{"role":"assistant","content":"```cryptol\nmodule T038 where\n\ninterface submodule I where\n  x : [8]\n\nsubmodule F where\n  import interface submodule I\n  y = x + 1\n\nsubmodule P where\n  import submodule F { submodule Q }\n  x = 11\n\nsubmodule Q where\n  x = 11\n\ninterface submodule J where\n  import submodule F { submodule P }\n  x : [8]\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T011.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol specification that declares: (1) a submodule A introducing a type alias T for 8\u2011bit words; (2) an interface submodule S that imports A and requires a value x of type T; (3) a submodule F that imports the interface S and defines a value y equal to two times x using modular (wraparound) arithmetic, with y having type T; (4) a concrete submodule I that provides x as the literal 28 with type T; (5) an instantiation M obtained by applying F to I; and (6) an import of submodule M under the same name so its definitions are brought into scope."},{"role":"assistant","content":"```cryptol\nsubmodule A where\n  type T = [8]\n\ninterface submodule S where\n  import submodule A\n  x : T\n\nsubmodule F where\n  import interface submodule S\n\n  y = 2 * x\n\nsubmodule I where\n  x = 28\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T005.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an interface submodule named A that declares a numeric parameter n (finite and at least 1) and a value x that is a bitvector of length n. Define a submodule F that imports two instances of A under aliases X and Y, imposes an interface-level constraint that their numeric parameters are equal, and defines y as the sum of X.x and Y.x with type a bitvector whose length equals X\u2019s numeric parameter. Provide two concrete submodules I and J: I fixes the numeric parameter to 8; J fixes it to 9. In each, define x polymorphically for any ring type that supports the numeric literals 1 and 2, with x computed as the sum of those literals. Instantiate F by binding X to I and Y to J to create a submodule M, and then import M. Ensure the specification precisely encodes the aliasing, constraints, types, and instantiation so that the equality constraint required by F is present despite the differing numeric parameters in I and J."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A as X\n  import interface submodule A as Y\n\n  interface constraint (X::n == Y::n)\n\n  y : [X::n]\n  y = X::x + Y::x\n\nsubmodule I where\n  type n = 8\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule J where\n  type n = 9\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule M = submodule F { X = submodule I, Y = submodule J }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T006.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares an interface submodule A parameterized by a numeric size n (finite, n \u2265 1) and providing a value x of n bits. Define a submodule F that imports A under alias X and imposes an interface constraint that X::n \u2265 3. Within F, define a nested submodule G that imports A, imposes an interface constraint equating X::n with the local n, and defines y as the sum of five times X::x and x, with y having width n. Also in F, define y as five times X::x with width X::n. Provide a concrete submodule I implementing A by fixing n to 8 and defining x as a polymorphic ring element given by the sum of the ring literals 1 and 2, with constraints requiring a ring structure and support for the literals 1 and 2. Instantiate F with I to produce submodule M and import it. Then instantiate the nested G within M using I to produce submodule N and import it. Ensure all type signatures, interface constraints, nested imports, and widths are consistent across submodules."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A as X\n\n  interface constraint (X::n >= 3)\n\n  submodule G where\n    import interface submodule A\n    interface constraint (X::n == n)\n\n    y : [n]\n    y = 5 * X::x + x\n\n  y : [X::n]\n  y = 5 * X::x\n\nsubmodule I where\n  type n = 8\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n\nsubmodule N = submodule M::G { submodule I }\n\nimport submodule N as N\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T012.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models a functor-style submodule pattern: (1) define an interface submodule that imports an external module supplying an abstract numeric type and declares a single value of that type; (2) define a parameterized submodule that depends on that interface and defines a second value equal to twice the interface-provided value using multiplication by the numeric literal 2; (3) define a concrete submodule that implements the interface by assigning the declared value to the numeric literal 28; (4) instantiate the parameterized submodule with the concrete implementation to obtain a concrete submodule, and then import that resulting submodule under an alias. Provide explicit type signatures for the interface value and the derived value, and state any necessary constraints so numeric literals and multiplication are well-typed (for example, the abstract type is a finite unsigned sequence supporting multiplication and wide enough to represent 28). Do not prove any properties; just define the interface, functor, implementation, instantiation, and import."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  import T012_M\n  x : T\n\nsubmodule F where\n  import interface submodule S\n\n  y = 2 * x\n\nsubmodule I where\n  x = 28\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T002.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares an interface submodule named A with a numeric type parameter n of kind #, constrained to be finite and at least 1, and an exported bit-sequence value x of width n. Define a functor-like submodule F that depends on interface A and exports y, a bit-sequence of width n computed as the sum of the literal 1 and x. Provide an implementation submodule I that fixes n to 8 and defines x as the 8-bit encoding of the integer 2. Instantiate F with I to produce a concrete submodule M, and expose M under the same name via an import\/alias. Include explicit type declarations, constraints, and the value definitions so that all widths are statically checked."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 8\n  x = 2 : [n]\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T003.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) declares an interface submodule with a numeric kind parameter representing a bit-width, constrained to be finite and at least one, and an abstract value that is a sequence of exactly that many bits; (2) defines a functor submodule that imports the interface and defines a new value equal to the abstract bitvector plus one using modular addition at the same width; (3) provides a concrete submodule that fixes the width to 8 bits and defines the abstract value as the polymorphic numeric literal 42, using an appropriate literal overloading constraint so it can specialize to an 8-bit sequence; (4) instantiates the functor with the concrete submodule to produce a resulting submodule; and (5) imports the instantiated submodule so its definitions are available in scope. Include explicit type annotations, the numeric kind for the width parameter, the width constraints, and the literal\u2019s overloading constraint."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 8\n\n  x : {a} Literal 42 a => a\n  x = 42\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T001.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an interface submodule named A with one numeric type parameter n (kind numeric) constrained to be finite and at least 1, and declare a value x whose type is a sequence of n bits. Define a functor submodule F that depends on interface A, reusing n and x, and declares a value y with the same width n computed by adding the literal 1 to x. Define an implementation submodule I that fixes n to 0 and provides a value x with width n. Then define a submodule M that applies F to I. The specification must enforce, via the interface constraints, that instantiating F with I is invalid because n = 0 violates n \u2265 1. Include all required type declarations, constraints, and the import of the interface into the functor. Do not provide any solution."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 0\n  x = x : [n]\n\nsubmodule M = submodule F { submodule I }\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T028.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an interface submodule named S that exports a single 8-bit value x. Define a submodule G that imports S and defines y as x plus 1 using 8-bit modular addition, with y typed as 8 bits. Define a submodule F that imports S and also imports G specialized with the same S, and defines z as x plus y using 8-bit modular addition, with z typed as 8 bits. Finally, instantiate F by importing it with an implementation of S where x is the 8-bit constant 5, so that z is available from the instantiation. Ensure all imports reference the correct interface and that all values are sized consistently as 8 bits."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  x : [8]\n\nsubmodule G where\n  import interface submodule S\n  y = x + 1\n\nsubmodule F where\n  import interface submodule S\n  import submodule G { interface S }\n  z = x + y\n\nimport submodule F where\n  x = 5\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T027.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models functor-style submodules and interface wiring as follows: define an interface submodule that exports a single 8-bit constant. Define a submodule that imports this interface and exports an 8-bit value computed as the interface constant plus one using modular 8-bit addition. Define another submodule that accepts the same interface (aliased locally); within it, define a nested submodule that reuses that alias, imports the previously defined submodule instantiated with that alias, and exports an 8-bit result equal to the sum of the interface constant and the imported derived value (all arithmetic modular over 8 bits). At the top level, instantiate the outer submodule by providing the interface constant with the concrete 8-bit value 5, which exposes the nested submodule as a functor; then instantiate that nested submodule at the top level by providing the interface constant with the concrete 8-bit value 6, bringing its exported result into scope. Include explicit 8-bit type signatures for all exposed values and ensure the imports thread the same interface instance through the nested and dependent submodules."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  x : [8]\n\nsubmodule G where\n  import interface submodule S\n  y = x + 1\n\nsubmodule F where\n  import interface submodule S as A\n\n  submodule H where\n    import interface submodule S as A\n    import submodule G { interface A }\n    z = A::x + y\n\nimport submodule F where\n  x = 5\n\nimport submodule H where\n  x = 6\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T037.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named T037 that contains the following definitions: (1) an interface submodule I exporting a single public value x with 8-bit width; (2) a parameterized submodule F that imports the interface I and defines y as x plus one using 8-bit modular addition; (3) a concrete submodule P that provides an implementation for I by binding x to the 8-bit constant 11; (4) a submodule X that instantiates F with P as submodule M, imports M to re-export its bindings, and defines z equal to y so that z is visible within X; and (5) at the top level of T037, import submodule X so that z is brought into the module scope. Provide explicit type signatures for x, y, and z as 8-bit sequences. Add properties asserting within X that z equals y and y equals x plus one, and at the top level that z equals the 8-bit value 12. Do not include any other bindings or side conditions."},{"role":"assistant","content":"```cryptol\nmodule T037 where\n\ninterface submodule I where\n  x : [8]\n\nsubmodule F where\n  import interface submodule I\n  y = x + 1\n\nsubmodule P where\n  x = 11\n\nsubmodule X where\n  submodule M = submodule F { submodule P }\n  import submodule M\n\n  z = y\n\nimport submodule X\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T012_M.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a module named T012_M that contains the following definitions: a single type alias T representing an 8-bit sequence (a byte). The alias must bind T to the fixed-width sequence type of length 8 bits, with no parameters, constraints, or additional declarations in the module."},{"role":"assistant","content":"```cryptol\nmodule T012_M where\n\ntype T = [8]\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T022.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: 1) Defines an interface submodule named interface_name declaring a numeric type parameter size of kind # with a finiteness constraint and a single value elem of type [size]. 2) Defines a submodule named functor_name that imports interface_name as alias alias_name and defines a value sum = alias_name::elem + alias_name::elem, using modular addition on [size]. Provide explicit type signatures for all declarations and state the constraint on size. 3) Instantiates\/imports functor_name by binding size to 8 and supplying elem = 2 as an [8] value, so that sum is computed under 8-bit modular arithmetic. Include the necessary import statements and aliasing to link the submodule to the interface implementation. Do not prove any properties; only define the interface, the functor-like submodule, and the concrete instantiation with the given bindings."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  type n : #\n  type constraint (fin n)\n  x : [n]\n\nsubmodule F where\n  import interface submodule S as A\n\n  z = A::x + A::x\n\nimport submodule F where\n  type n = 8\n  x = 2\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T008.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol specification that creates a parameterized submodule named F with one size type parameter n (kind #) constrained so that n is finite and n \u2265 2. Inside F, declare a constant x typed as a sequence of n bits with the numeric value 2. Then define a submodule named M as the instantiation of F with the parameter bound to n = 2. Finally, include an import that brings this instantiated submodule into scope under the alias M. Clearly state the parameter, its constraints, the type and value of x, the instantiation binding, and the import alias."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n, n >= 2)\n\n  x : [n]\n  x = 2\n\nsubmodule M = submodule F where\n  type n = 2\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T035.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define submodules A, F, M, and N with the following structure: In A, declare a newtype T as a single-field record containing an Integer field named x. In F, introduce a type parameter n of kind numeric with a finiteness constraint, then declare a newtype X as a single-field record whose field x has bit-vector type of width n, and define a function f that takes an X and returns the same X unchanged. Create M and N as separate instantiations of F using implicit parameters. Import M and N qualified under their own names. Finally, define a top-level value named x that applies f from M to a value constructed with the newtype constructor X from N, setting its record field to the zero value appropriate for width n. Do not provide any proofs; just supply the type parameters, constraints, newtypes, function, imports, and the final binding with the correct qualified references."},{"role":"assistant","content":"```cryptol\nsubmodule A where\n  newtype T = { x : Integer }\n\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n)\n\n  newtype X = { x : [n] }\n  f : X -> X\n  f x = x\n\nsubmodule M = submodule F { _ }\nsubmodule N = submodule F { _ }\n\nimport submodule M as M\nimport submodule N as N\n\nx = M::f (N::X { x = 0 })\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T040.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a parameterized submodule with a single type parameter of kind *, containing: (1) a newtype that wraps a single-record whose sole component is a function from the type parameter to the unit type; and (2) a constant of that newtype whose function ignores its argument and returns unit. Then import this submodule while instantiating the type parameter to 32-bit sequences, and define a top-level constant that is the result of applying the wrapped function to a 32-bit value. Provide explicit type signatures for the wrapped constant and the top-level constant, ensuring the latter has unit type. Do not change the behavior: the function must discard its input and yield unit, and the import must fix the parameter to 32-bit words."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type T : *\n\n  newtype NT = { field : T -> () }\n\n  nt : NT\n  nt = NT { field = \\_ -> () }\n\nimport submodule F where\n  type T = [32]\n\nx = nt.field 10\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/ffi-type-errors.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares eight external (foreign) bindings intended to provoke FFI type-checking errors. Provide only type signatures (no bodies) and give each binding a distinct name. The bindings must be: (1) a function from a 65-bit word to a 128-bit word; (2) a function from a 16-bit floating-point value to a 128-bit floating-point value; (3) a function, polymorphic over a finite size n, that takes two arguments\u2014first a sequence of n bits, second a sequence of n tuples each containing two 16-bit words\u2014and returns a 4-by-8 array of records, where each record has two fields: one an n-bit word and the other a 2-bit word; (4) a foreign value that is merely a 32-bit word (i.e., not a function); (5) a polymorphic function over an unconstrained type variable that returns a 32-bit word; (6) a function polymorphic over n, without adding a fin constraint, from an array of n 32-bit words to an array of 2\u00b7n 32-bit words; (7) a function from an infinite-length sequence of 32-bit words to a single bit; and (8) a function that quantifies over named numeric and floating constants and returns an unknown\/placeholder result type. Do not add extra constraints or alter sizes; model the invalid FFI types exactly."},{"role":"assistant","content":"```cryptol\nimport Float\n\nforeign badWordSizes : [65] -> [128]\nforeign badFloatSizes : Float16 -> Float128\nforeign badArrayTypes : {n} (fin n) =>\n  [n]Bit -> [n]([16], [16]) -> [n][4][8]{a : [n], b : [2]}\nforeign notFunction : [32]\nforeign badKind : {t} t -> [32]\nforeign noFin : {n} [n][32] -> [n * 2][32]\nforeign infSeq : [inf][32] -> Bit\nforeign wildcard : { x : [8], y : Float32 } -> _\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/ffi-fallback.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification modeling an FFI fallback scenario for byte-sized functions. Define four top-level declarations over 8-bit sequences (bytes), each with the type [8] -> [8]. Among them: (1) one is declared as a foreign function and also given a Cryptol implementation that returns its input unchanged; (2) two are declared as foreign functions with only type signatures and no Cryptol bodies; and (3) one is a pure Cryptol function that returns its input increased by the constant 3 using modular arithmetic over 8 bits (wrap-around at 256). Include properties suitable for solver checking: (a) for all 8-bit inputs, the foreign-declared function that also has a Cryptol body behaves identically to its input (identity behavior); and (b) for all 8-bit inputs, the pure Cryptol function equals the input plus 3 modulo 2^8. Clearly state the types, the use of modular arithmetic on 8-bit words, and quantify universally over the input byte in each property. Do not assert any behavioral properties for the two foreign-only declarations beyond their types."},{"role":"assistant","content":"```cryptol\nforeign foreignAndCryptol : [8] -> [8]\nforeignAndCryptol x = x\n\nforeign foreignAndNoCryptol : [8] -> [8]\n\nforeign noForeignAndCryptol : [8] -> [8]\nnoForeignAndCryptol x = x + 3\n\nforeign noForeignAndNoCryptol : [8] -> [8]\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/test-ffi.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that imports the floating-point library and declares the following foreign symbols with exact types and constraints, without providing implementations. Include:\n- Arithmetic on fixed-width words: add8 (8-bit +), sub16 (16-bit \u2212), mul32 (32-bit \u00d7), div64 (64-bit \u00f7).\n- Width-changing word functions: extendInput (3-bit to 8-bit), maskOutput (8-bit to 3-bit), noBits (0-bit to 0-bit).\n- Bit negation: not (bit to bit).\n- Floating-point ops: addFloat32 (binary op on single-precision), subFloat64 (binary op on double-precision), specialFloats (selects a single-precision value from a 2-bit selector).\n- Type synonyms: Word32 as a 32-bit word; MyFunc as a function from Word32 and single-precision float to a bit. Declare usesTypeSynonym with the MyFunc type.\n- Fixed-size sequences: sum10 (sum over a 10-element sequence of 32-bit words), reverse5 (reverse a 5-element sequence of double-precision floats).\n- Compound types: a function taking a 32-bit word and a record {x: 10-bit word, y: 3\u00d720-bit matrix}, returning a record {z: 5\u00d720-bit matrix}, and producing a record {a: pair of 16-bit words, b: {c: 8\u00d720-bit matrix, d: 5-bit word, e: 5-bit word}}.\n- Polymorphic\/size-dependent functions with constraints: typeToValue (polymorphic over a finite size parameter; returns a 64-bit word), sumPoly ([n] of 32-bit words to a 32-bit word), inits (from [n] bytes to [n*(n+1)\/2] bytes), zipMul3 (zips three [n],[m],[p] single-precision sequences to length min(n,m,p)), nestedSeq (reshape [n][m][p] bytes to [4][3][2] bytes given n*m*p = 24 and all sizes finite).\n- Conversions: i2Q (integer to rational), i2Qs (integer to 2-element sequence of rationals), iQ2Qi (swap integer\/rational in a pair), i2Z5 (integer to modulus-5 integer), i2Z (integer to modulus-n with finite n and n \u2265 1).\n- A submodule A exposing a nullary function returning an 8-bit word."},{"role":"assistant","content":"```cryptol\nimport Float\n\nforeign add8 : [8] -> [8] -> [8]\nforeign sub16 : [16] -> [16] -> [16]\nforeign mul32 : [32] -> [32] -> [32]\nforeign div64 : [64] -> [64] -> [64]\n\nforeign extendInput : [3] -> [8]\nforeign maskOutput : [8] -> [3]\nforeign noBits : [0] -> [0]\n\nforeign not : Bit -> Bit\n\nforeign addFloat32 : Float32 -> Float32 -> Float32\nforeign subFloat64 : Float64 -> Float64 -> Float64\nforeign specialFloats : [2] -> Float32\n\ntype Word32 = [32]\ntype MyFunc = Word32 -> Float32 -> Bit\nforeign usesTypeSynonym : MyFunc\n\nforeign sum10 : [10]Word32 -> Word32\nforeign reverse5 : [5]Float64 -> [5]Float64\n\nforeign compoundTypes : ([32], { x : [10], y : [3][20] }) -> { z : [5][20] }\n  -> { a : ([16], [16]), b : { c : [8][20], d : [5], e : [5] } }\n\nforeign typeToValue : {n} (fin n) => () -> [64]\nforeign sumPoly : {n} (fin n) => [n]Word32 -> Word32\nforeign inits : {n} (fin n) => [n][8] -> [n * (n + 1) \/ 2][8]\nforeign zipMul3 : {n, m, p} (fin n, fin m, fin p) =>\n  [n]Float32 -> [m]Float32 -> [p]Float32 -> [min n (min m p)]Float32\n\nforeign nestedSeq : {n, m, p} (fin n, fin m, fin p, n * m * p == 4 * 3 * 2) =>\n  [n][m][p][8] -> [4][3][2][8]\n\nforeign i2Q   : Integer -> Rational\nforeign i2Qs  : Integer -> [2]Rational\nforeign iQ2Qi : (Integer,Rational) -> (Rational,Integer)\nforeign i2Z5  : Integer -> Z 5\nforeign i2Z   : {n} (fin n, n >= 1) => Integer -> Z n\n\nsubmodule A where\n  foreign nested : () -> [8]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1489\/issue1489.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named ID that contains the following definitions: (1) A polymorphic function id with the type: for any natural k with finiteness and k > 0, map a 2^k-bit word to a 2^k-bit word. Its behavior is to split the input into two blocks of sizes 2 and 2^(k\u22121) and then immediately join them, returning the original word. (2) A type synonym q equal to 3329, used as the modulus for modular integers. (3) A function ct_butterfly parameterized by naturals m and hm with constraints 2 \u2264 m \u2264 8, 1 \u2264 hm \u2264 7, and hm = m \u2212 1. Its type: take a vector of length 2^m of elements in Z q and a twiddle factor in Z q, and return a vector of length 2^m in Z q. Compute halflen = 2^hm, form two length-2^hm subvectors where, for each index x in [0 .. 2^hm \u2212 1], the lower half equals v[x] + z \u00b7 v[x + halflen] and the upper half equals v[x] \u2212 z \u00b7 v[x + halflen]; return the concatenation of the two halves. (4) A constant zeta_expc, an array of 128 elements in Z q, initialized exactly to the provided coefficients. (5) A recursive function fast_nttl parameterized by lv with constraint 2 \u2264 lv \u2264 8. Its type: take a length-2^lv vector in Z q and an 8-bit index, and return a length-2^lv vector in Z q. Base case when lv = 2: apply ct_butterfly using the twiddle at the given index from zeta_expc. Recursive case when lv > 2: first apply ct_butterfly, split the result into two equal halves, recursively process the halves with indices k\u00b72 and k\u00b72 + 1, and concatenate the results."},{"role":"assistant","content":"```cryptol\nmodule ID where\n\nid : {k} (fin k, k > 0) => [2^^k] -> [2^^k]\nid x = join(split`{2,2^^(k-1)}x)\n\ntype q = 3329\n\nct_butterfly :\n    {m, hm}\n    (m >= 2, m <= 8, hm >= 1, hm <= 7, hm == m - 1) =>\n    [2^^m](Z q) -> (Z q) -> [2^^m](Z q)\nct_butterfly v z = new_v\n  where\n    halflen = 2^^`hm\n    lower, upper : [2^^hm](Z q)\n    lower@x = v@x + z * v@(x + halflen)\n    upper@x = v@x - z * v@(x + halflen)\n    new_v = lower # upper\n\nzeta_expc  : [128](Z q)\nzeta_expc = [ 1, 1729, 2580, 3289, 2642, 630, 1897, 848,\n              1062, 1919, 193, 797, 2786, 3260, 569, 1746,\n              296, 2447, 1339, 1476, 3046, 56, 2240, 1333,\n              1426, 2094, 535, 2882, 2393, 2879, 1974, 821,\n              289, 331, 3253, 1756, 1197, 2304, 2277, 2055,\n              650, 1977, 2513, 632, 2865, 33, 1320, 1915,\n              2319, 1435, 807, 452, 1438, 2868, 1534, 2402,\n              2647, 2617, 1481, 648, 2474, 3110, 1227, 910,\n              17, 2761, 583, 2649, 1637, 723, 2288, 1100,\n              1409, 2662, 3281, 233, 756, 2156, 3015, 3050,\n              1703, 1651, 2789, 1789, 1847, 952, 1461, 2687,\n              939, 2308, 2437, 2388, 733, 2337, 268, 641,\n              1584, 2298, 2037, 3220, 375, 2549, 2090, 1645,\n              1063, 319, 2773, 757, 2099, 561, 2466, 2594,\n              2804, 1092, 403, 1026, 1143, 2150, 2775, 886,\n              1722, 1212, 1874, 1029, 2110, 2935, 885, 2154 ]\n\nfast_nttl :\n    {lv}      (lv >= 2, lv <= 8) =>\n    [2^^lv](Z q) -> [8] -> [2^^lv](Z q)\nfast_nttl v k\n    | lv == 2 => ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n\n        | lv  > 2 => (fast_nttl`{lv-1} s0 (k * 2)) #\n                           (fast_nttl`{lv-1} s1 (k * 2 + 1))\n                where\n                  t = ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n                                    [s0, s1] = split t\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1561\/G.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named G that imports the same interface I twice under distinct aliases J and K, and contains the following constant definitions: ja, jb, ka, kb. Specify that ja is the value of member x from alias J incremented by 1, jb is the value of member y from alias J incremented by 2, ka is the value of member x from alias K incremented by 1, and kb is the value of member y from alias K incremented by 2. Include type constraints so that the members x and y are numeric: x has type a where a supports addition with the literal 1, and y has type b where b supports addition with the literal 2; consequently ja and ka have type a, and jb and kb have type b. Ensure the imports use qualified access through the aliases (no unqualified name leakage) and that both interface imports coexist without conflicts. Do not add any extra definitions."},{"role":"assistant","content":"```cryptol\nmodule G where\n\nimport interface I as J\nimport interface I as K\n\nja = J::x + 1\njb = J::y + 2\n\nka = K::x + 1\nkb = K::y + 2\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1560\/T4.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named T3 that contains the following definitions: (1) An interface submodule I1 with a single numeric type parameter x constrained to be between 1 and 3 inclusive. (2) An interface submodule I2 with a single numeric type parameter x constrained to be between 1 and 4 inclusive. (3) A submodule F that imports interface I1 under the alias I and defines a constant y that is a bitvector whose length is the numeric parameter x from alias I, and whose value is 1. (4) Inside F, a nested submodule G that imports interface I2 twice under aliases I and J, and defines a constant csum that is a bitvector whose length is the numeric parameter x from G\u2019s alias I, and whose value is exactly y from the enclosing submodule F. Ensure the specification makes explicit that the bitvector length used for csum must equal the length of y, thereby constraining the numeric parameter from I2 to match the numeric parameter from I1 while satisfying both interfaces\u2019 bounds. Clearly describe the visibility and aliasing so that the I alias in G shadows F\u2019s I, and J is an additional alias for the same interface in G."},{"role":"assistant","content":"```cryptol\nmodule T3 where\n\ninterface submodule I1 where\n  type x: #\n  type constraint (x >= 1, x <= 3)\n\ninterface submodule I2 where\n  type x: #\n  type constraint (x >= 1, x <= 4)\n\nsubmodule F where\n  import interface submodule I1 as I\n\n  y: [I::x]\n  y = 1\n\n  submodule G where\n    import interface submodule I2 as I\n    import interface submodule I2 as J\n\n    csum : [I::x]\n    csum = y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1560\/T2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named T2 that contains the following: (1) a module-level type parameter n of numeric kind with a finiteness constraint; (2) a constant a with sequence type of length n whose definition is self-referential (it evaluates to itself); and (3) a submodule F that declares its own numeric type parameter n (shadowing the outer one) and defines a polymorphic function b, universally quantified over m, with type taking a sequence of length n and returning a sequence of length m, which ignores its argument and returns the constant from the outer module. Preserve the exact names, kinds, constraints, polymorphism, and the cross-scope reference to the outer constant."},{"role":"assistant","content":"```cryptol\nmodule T2 where\n\nparameter\n  type n: #\n  type constraint (fin n)\n\na:[n]\na = a\n\nsubmodule F where\n  parameter\n    type n: #\n\n  b: {m} [n] -> [m]\n  b _ = a\n```"}]}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Finite.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) a constant named xs equal to the finite sequence of consecutive positive integers from 1 to 100, using the minimal unsigned word width sufficient to hold the largest value; and (2) a polymorphic function named sumInf that takes a finite sequence of unsigned words and returns a sequence whose length is exactly one greater than the input. The function must compute a running-sum stream defined co-recursively: start with zero, then for each position add the next input element to the previous sum (zip the input with the partial-sum stream). Next, zip that partial-sum stream with the increasing sequence of positive integers starting at one and add elementwise to produce the final result. Use modular addition over the word type. Provide explicit type signatures: sumInf should be length-polymorphic with constraints ensuring finite sequence length and finite element width, and the result length must be the input length plus one. Do not include any proofs or properties."},{"role":"assistant","content":"```cryptol\nxs = [ 1 .. 100 ]\n\nsumInf xs = iterSums\n    where\n        sums = [ 0 ] # [ x + y | x <- xs\n                               | y <- sums ]\n        iterSums = [ x + y | x <- sums\n                           | y <- [ 1 ...] ]\n```"}]}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Enigma.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Enigma that contains the following definitions and type signatures, matching the described behaviors and constraints: (1) Type synonyms: a 26-character permutation type; plugboard and reflector share this type; a rotor is a 26-element sequence of pairs (character, notch flag); an Enigma machine is a record with a plugboard, a length-n sequence of rotors, and a reflector. (2) A polymorphic membership function that, given a value and a length-a sequence of comparable elements, returns a bit indicating if the value occurs; use a streaming\/recursive construction. (3) A private function that computes the inverse mapping of a permutation for a given character using an iterative candidate build. (4) A rotor-constructor that, given a permutation and a string of notch locations, produces the rotor by pairing each permuted character with a bit indicating notch presence. (5) A scramble step that, given a rotate flag, an input character, and a rotor, outputs the notch bit from the rotor\u2019s current top position, the mapped character from the rotor at the input\u2019s alphabet index, and the rotor left-rotated by one when rotate is true. (6) A function that threads a character through a length-n rotor stack, starting from a dummy identity rotor with no notches; at each step rotate the next rotor if the previous notch bit is set; return the updated rotors (excluding the dummy) and the final character. (7) Forward and backward substitution via a permutation and its inverse. (8) A backward signal function that routes a character back through the rotors in reverse using only the character components. (9) A full loop: plugboard forward, through rotors, reflector forward, back through original rotors, plugboard backward; return updated rotors and output character. (10) A machine constructor that offsets each rotor by its starting letter. (11) A string transformer that iterates the loop over a length-m message, threading rotor state; decryption is the same function. (12) Concrete constants for a plugboard, three rotors with notch sets, a reflector, and a 3-rotor example machine. (13) A universal-quantifier helper over sequences, and a function that checks a reflector\u2019s forward and backward mappings agree for all uppercase letters."},{"role":"assistant","content":"```cryptol\nmodule Enigma where\n\ntype Permutation = String 26\n\ntype Plugboard   = Permutation\ntype Rotor       = [26](Char, Bit)\ntype Reflector   = Permutation\n\ntype Enigma n    = { plugboard : Plugboard,\n                     rotors    : [n]Rotor,\n                     reflector : Reflector\n                   }\n\nelem : {a, b} (fin 0, fin a, Cmp b) => (b, [a]b) -> Bit\nelem (x, xs) = matches ! 0\n  where matches = [False] # [ m || (x == e)  | e <- xs\n                                             | m <- matches\n                            ]\nprivate\n  invSubst : (Permutation, Char) -> Char\n  invSubst (key, c) = candidates ! 0\n    where candidates = [0] # [ if c == k then a else p\n                             | k <- key\n                             | a <- ['A' .. 'Z']\n                             | p <- candidates\n                             ]\n\nmkRotor : {n} (fin n) => (Permutation, String n) -> Rotor\nmkRotor (perm, notchLocations) = [ (p, elem (p, notchLocations))\n                                 | p <- perm\n                                 ]\n\nscramble : (Bit, Char, Rotor) -> (Bit, Char, Rotor)\nscramble (rotate, c, rotor) = (notch, c', rotor')\n  where \n    (c', _)    = rotor @ (c - 'A')\n    (_, notch) = rotor @ 0\n    rotor'     = if rotate then rotor <<< 1 else rotor\n\njoinRotors : {n} (fin n) => ([n]Rotor, Char) -> ([n]Rotor, Char)\njoinRotors (rotors, inputChar) = (rotors', outputChar)\n  where \n    initRotor = mkRotor (['A' .. 'Z'], [])\n    ncrs : [n+1](Bit, [8], Rotor)\n    ncrs = [(True, inputChar, initRotor)] \n               # [ scramble (notch, char, r)\n                 | r <- rotors\n                 | (notch, char, rotor') <- ncrs\n                 ]\n    rotors' = tail [ r | (_, _, r) <- ncrs ]\n    (_, outputChar, _) = ncrs ! 0\n\n\/\/ Following the signal through a single rotor, forward and backward\nsubstFwd, substBwd : (Permutation, Char) -> Char\nsubstFwd (perm, c) = perm @ (c - 'A')\nsubstBwd (perm, c) = invSubst (perm, c)\n\n\/\/ Route the signal back from the reflector, chase through rotors\nbackSignal : {n} (fin n) => ([n]Rotor, Char) -> Char\nbackSignal (rotors, inputChar) = cs ! 0\n  where   cs = [inputChar] # [ substBwd ([ p | (p, _) <- r ], c)\n                             | r <- reverse rotors\n                             | c <- cs\n                             ]\n\n\/\/ The full enigma loop, from keyboard to lamps:\n\/\/ The signal goes through the plugboard, rotors, and the reflector,\n\/\/ then goes back through the sequence in reverse, out of the\n\/\/ plugboard and to the lamps\nenigmaLoop : {n} (fin n) => (Plugboard, [n]Rotor, Reflector, Char) -> ([n]Rotor, Char)\nenigmaLoop (pboard, rotors, refl, c0) = (rotors', c5)\n  where\n    c1 = substFwd (pboard, c0)\n    (rotors', c2) = joinRotors (rotors, c1)\n    c3 = substFwd (refl, c2)\n    c4 = backSignal(rotors, c3)\n    c5 = substBwd (pboard, c4)\n\n\/\/ Construct a machine out of parts\nmkEnigma : {n} (Plugboard, [n]Rotor, Reflector, [n]Char) -> Enigma n\nmkEnigma (pboard, rs, refl, startingPositions) =\n    { plugboard  = pboard\n    , rotors     = [ r <<< (s - 'A')\n                   | r <- rs\n                   | s <- startingPositions\n                   ]\n    , reflector  = refl\n    }\n\n\/\/ Encryption\/Decryption\nenigma : {n, m} (fin n, fin m) => (Enigma n, String m) -> String m\nenigma (m, pt) = tail [ c | (_, c) <- rcs ]\n  where rcs = [(m.rotors, '*')] # \n              [ enigmaLoop (m.plugboard, r, m.reflector, c)\n              | c      <- pt\n              | (r, _) <- rcs\n              ]\n\n\/\/ Decryption is the same as encryption:\n\/\/ dEnigma : {n, m} (fin n, fin m) => (Enigma n, String m) -> String m\ndEnigma = enigma\n\n\/\/ Build an example enigma machine:\nplugboard : Plugboard\nplugboard = \"HBGDEFCAIJKOWNLPXRSVYTMQUZ\"\n\nrotor1, rotor2, rotor3 : Rotor\nrotor1 = mkRotor (\"RJICAWVQZODLUPYFEHXSMTKNGB\", \"IO\")\nrotor2 = mkRotor (\"DWYOLETKNVQPHURZJMSFIGXCBA\", \"B\")\nrotor3 = mkRotor (\"FGKMAJWUOVNRYIZETDPSHBLCQX\", \"CK\")\n\nreflector : Reflector\nreflector = \"FEIPBATSCYVUWZQDOXHGLKMRJN\"\n\nmodelEnigma : Enigma 3\nmodelEnigma = mkEnigma (plugboard, [rotor1, rotor2, rotor3], reflector, \"GCR\")\n\n\/* Example run:\n\n   cryptol> :set ascii=on\n   cryptol> enigma  (modelEnigma, \"ENIGMAWASAREALLYCOOLMACHINE\")\n   UPEKTBSDROBVTUJGNCEHHGBXGTF\n   cryptol> dEnigma (modelEnigma, \"UPEKTBSDROBVTUJGNCEHHGBXGTF\")\n   ENIGMAWASAREALLYCOOLMACHINE\n*\/\n\nall: {a, n} (fin n) => (a->Bit) -> [n]a -> Bit\nall fn xs = folds ! 0 where\n    folds = [True] # [ fn x && p | x <- xs\n                                 | p <- folds]\ncheckReflectorFwdBwd : Reflector -> Bit\ncheckReflectorFwdBwd refl = all check ['A' .. 'Z']\n    where check c = substFwd (refl, c) == substBwd (refl, c)\n```"}]}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Simple.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that mirrors the file\u2019s behavior: (1) introduce type synonyms for an 8-bit character and a 26-character permutation key over uppercase ASCII; (2) define a function named invSubst with type (Permutation, Char) -> Char that performs an inverse lookup by traversing the key alongside the alphabet \u2018A\u2019..\u2018Z\u2019, threading a prior candidate seeded with zero, and returning the alphabet letter when the input equals the corresponding key entry (return zero when no match exists). State the assumption that the key is a bijection over the 26 uppercase letters. (3) define a polymorphic function named myrev with parameters n and a and constraint fin n, type [n+1][a] -> [n+1][a], that returns a vector whose i-th element is the input\u2019s i-th element for indices 0..n (i.e., it behaves as the identity on vectors of that length). (4) define a function named sumAll that constructs a prefix-sum stream seeded with the additive identity and returns its first element, with constraints on the element type to support addition and literal zero; note that the result is always the additive identity for any input. Include concise boolean properties asserting: invSubst returns the correct alphabet letter for any position matching the key (and zero when none match); myrev equals the identity for all lengths and element types meeting the constraint; sumAll\u2019s result equals the additive identity for all inputs and suitable element types. Use clear type signatures, specify any necessary numeric constraints, and keep names exactly as stated."},{"role":"assistant","content":"```cryptol\ntype Char = [8]\ntype Permutation = String 26\n\ninvSubst : (Permutation, Char) -> Char\ninvSubst (key, c) = candidates ! 0\n  where candidates = [0] # [ if c == k then a else p\n                           | k <- key\n                           | a <- ['A' .. 'Z']\n                           | p <- candidates\n                           ]\n\nmyrev : {n,a} (fin n) => [n+1][a] -> [n+1][a]\nmyrev xs = [ xs!i | i <- [ 0 .. n] ]\n\nsumAll xs = ys ! 0\n    where ys = [0] # [x+y | x <- xs | y <- ys]\n```"}]}
{"filename":"cryptol\/examples\/funstuff\/FoxChickenCorn.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named FoxChickenCorn that contains the following definitions. Types: OneBank as a 4-bit vector; BankState as a record with fields left and right of type OneBank; StringRep as 7 ASCII bytes; DirRep as 5 ASCII bytes. Constants: farmer=1, chicken=2, corn=4, fox=8 (disjoint single-bit flags); startState with all flags on the left and right zero; doneState with left zero and all flags on the right; string literals for each object name and a blank, plus an array listing the four names in a fixed order. Functions and property: give solutionInNmoves a size-polymorphic signature over n with constraint fin n; define a property solutionInNmoves that holds exactly when concatenating startState, the given states, and doneState forms a validMoveSequence. validMoveSequence (n >= 1) checks every adjacent pair using validMove. validMove requires both states satisfy validState and that only items moved with the farmer (stuffOnlyMovedWithFarmer). stuffOnlyMovedWithFarmer chooses source\/destination by the farmer\u2019s starting side and computes the moved mask from the destination-side change, then enforces moveFollowsRules. moveFollowsRules requires the farmer bit moved and at most one non-farmer moved (use popCount). completeState requires each object is on exactly one bank (left XOR right equals the full mask 1|2|4|8). validState requires completeState and both banks pass validBank. validBank allows either the farmer present or neither \u201cfox with chicken\u201d nor \u201cchicken with corn\u201d co-located without the farmer. farmerHere tests the farmer bit presence on a bank. chickenWithCorn and foxWithChicken test co-location masks. all over [n]Bit returns true iff every element is true. popCount (a >= 1) returns the number of set bits in an a-bit vector, with result width width a. Pretty-printing: ppBits maps a 4-bit mask to an array of 4 strings (object name or blank) by bit position. extractMoves maps a nonempty sequence of states to per-step pairs (direction arrow string, 4 strings) using the farmer\u2019s direction and the moved mask."},{"role":"assistant","content":"```cryptol\nmodule FoxChickenCorn where\n\ntype OneBank = [4]\ntype BankState =\n    {left : OneBank\n    ,right: OneBank\n    }\n\nstartState      = { left = farmer || chicken || corn || fox, right = 0x0}\ndoneState       = { left = 0x0, right = farmer || chicken || corn || fox}\n\nfarmer  = 0x1\nchicken = 0x2\ncorn    = 0x4\nfox     = 0x8\n\nsolutionInNmoves : {n} (fin n) => [n] BankState -> Bit\nproperty solutionInNmoves states = validMoveSequence ([startState] # states # [doneState])\n\nvalidMoveSequence : {n} (fin n, n >= 1) => [n] BankState -> Bit\nvalidMoveSequence states = all [validMove a b\n                               | a <- states\n                               | b <- drop`{1} states]\n\nvalidMove : BankState -> BankState -> Bit\nvalidMove b b' = validState b && validState b'\n                 && stuffOnlyMovedWithFarmer b b'\n\nstuffOnlyMovedWithFarmer : BankState -> BankState -> Bit\nstuffOnlyMovedWithFarmer b b' =\n    if farmerHere b.left\n    then farmerHere b'.right && moveFollowsRules b.left b'.right (b'.right - b.right)\n    else farmerHere b'.left  && moveFollowsRules b.right b'.left (b'.left - b.left)\n\nmoveFollowsRules fromBank toBank whatMoved = farmerMoved && atMostOneObjectMoved where\n    farmerMoved = (whatMoved && farmer) == farmer\n    atMostOneObjectMoved = popCount (whatMoved && ~farmer) <= 1\n\ncompleteState : BankState -> Bit\ncompleteState b = (b.left ^ b.right) == 0xf\n\nvalidState : BankState -> Bit\nvalidState bs = completeState bs && validBank bs.left\n                && validBank bs.right && completeState bs\n\nvalidBank : OneBank -> Bit\nvalidBank b = farmerHere b || (~(foxWithChicken b) && ~(chickenWithCorn b))\n\nfarmerHere : OneBank -> Bit\nfarmerHere b = (b && farmer) > 0\n\nchickenWithCorn : OneBank -> Bit\nchickenWithCorn b = (b && (corn || chicken)) == (corn || chicken)\n\nfoxWithChicken : OneBank -> Bit\nfoxWithChicken b = (b && (fox || chicken)) == (fox || chicken)\n\nall : {n} (fin n) => [n] -> Bit\nall xs = xs == ~zero\n\npopCount : {a} (fin a, a >= 1) => [a] -> [width a]\npopCount bs = ic ! 0 where\n    ic = [0] # [ if elt then prev + 1 else prev | elt <- bs | prev <- ic]\n\ntype StringRep = [7][8]\ntype DirRep = [5][8]\nfarmerString  = \"farmer \"\nchickenString = \"chicken\"\ncornString    = \"corn   \"\nfoxString     = \"fox    \"\nnoString      = \"       \"\n\nppArray = [farmerString, chickenString, cornString, foxString]\n\nppBits : [4] -> [4]StringRep\nppBits s =  [ if b then ppArray!i else noString\n            | b <- s\n            | i <- [0 ...]:[_][4] ]\n\nextractMoves : {a} [a+1]BankState -> [a](DirRep, [4]StringRep)\nextractMoves bankStates = [ getMove b b' | b <- bankStates | b' <- drop`{1} bankStates ] where\n    getMove start end = ( dirString, thingsString thingsMoved ) where\n        dirString = if farmerHere start.left then \" --> \" else \" <-- \"\n        thingsMoved = if farmerHere start.left\n                      then end.right - start.right\n                      else end.left - start.left\n        thingsString bits = ppBits bits\n```"}]}
{"filename":"cryptol\/examples\/funstuff\/Coins.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define three Cryptol predicates with explicit type signatures over 10-bit sequences: coinCount, coinSum, and coinPuzzle. coinCount takes four 10-bit inputs and a 10-bit target and returns a Bit indicating that the four inputs sum exactly to the target and that each input is less than or equal to the target. coinSum takes four 10-bit inputs and a 10-bit target amount and returns a Bit indicating that the weighted sum using coin denominations 1, 5, 10, and 25 equals the target amount. coinPuzzle takes four 10-bit inputs and returns a Bit that is the conjunction of coinCount applied with target 30 and coinSum applied with target 109. Preserve the argument order and use [10] for all numeric parameters and Bit for results."},{"role":"assistant","content":"```cryptol\ncoinPuzzle : [10] -> [10] -> [10] -> [10] -> Bit\ncoinPuzzle a b c d = (coinCount a b c d 30) \/\\ (coinSum a b c d 109)\n\ncoinSum : [10] -> [10] -> [10] -> [10] -> [10] -> Bit\ncoinSum   a b c d s = (a + 5 * b + 10 * c + 25 * d) == s\n\ncoinCount : [10] -> [10] -> [10] -> [10] -> [10] -> Bit\ncoinCount a b c d s = (((a + b + c + d) == s) \/\\                        (a <= s \/\\ b <= s \/\\ c <= s \/\\ d <= s))\n```"}]}
{"filename":"cryptol\/examples\/funstuff\/marble.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models a 7\u00d77 peg-solitaire board and validates move sequences. Include: (1) a type alias Board as a 7\u00d77 matrix of bits; (2) a polymorphic function all with a finite length parameter that returns True iff every bit in a bit-vector is 1; (3) a function popCount for any non-empty bit-vector that returns the number of set bits with result width equal to the bit-vector\u2019s index width; (4) constants posns, start, first, second, and goal of type Board, with the same values and shapes; (5) a function validBoard that returns True iff all set positions of a board are within the allowed mask given by posns; (6) a function differentRow that, given two boards, returns the first pair of 7-bit rows that differ (top to bottom); (7) a function validRowMove that, given two 7-bit rows, returns True iff their change encodes exactly one legal horizontal jump of length two (a peg jumps over an adjacent peg into an empty cell) with correct before\/after occupancy; (8) a function validRowJump that holds iff both boards are valid and validRowMove holds for the unique differing row; (9) a function validColJump defined analogously by operating on the transpose of the boards; (10) a function validMove that is True iff either a valid horizontal or vertical jump occurs; (11) a function validMoveSequence, for any finite n \u2265 1, that returns True iff every adjacent pair in a length-n sequence of boards is a valid move; and (12) the property solutionInNmoves, for any finite n, stating that concatenating start, an n-length sequence ms, and second forms a sequence in which every adjacent pair is a valid move. Specify all necessary type signatures, size constraints, and quantification."},{"role":"assistant","content":"```cryptol\ntype Board = [7][7]Bit\n\nall : {n} (fin n) => [n] -> Bit\nall xs = xs == ~zero\n\npopCount : {a} (fin a, a >= 1) => [a] -> [width a]\npopCount bs = ic ! 0 where\n    ic = [0] # [ if elt then prev + 1 else prev | elt <- bs | prev <- ic]\n\nposns : Board\nposns = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nstart : Board\nstart = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,False,True,True,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nfirst : Board\nfirst = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,False,False,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nsecond : Board\nsecond = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,False,True],\n         [True,True,True,True,False,True,True],\n         [False,True,True,True,False,True,False],\n         [False,False,True,True,True,False,False]]\n\ngoal : Board\ngoal = [[False,False,False,False,False,False,False],\n        [False,False,False,True,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False]]\n\nvalidBoard : Board -> Bit\nvalidBoard b = join (b && ~posns) == zero\n\nvalidRowJump : Board -> Board -> Bit\nvalidRowJump a a' = validBoard a\n                 \/\\ validBoard a'\n                 \/\\ validRowMove (differentRow a a')\n\ndifferentRow : Board -> Board -> ([7], [7])\ndifferentRow a a' = rows ! 0\n    where rows = [(0b0000000,0b0000000)]\n               # [ if row != row' then (row,row') else old\n                 | row <- a\n                 | row' <- a'\n                 | old <- rows ]\n\nvalidRowMove : ([7], [7]) -> Bit\nvalidRowMove (r, r') = (xors == 0b0000111 \\\/\n                        xors == 0b0001110 \\\/\n                        xors == 0b0011100 \\\/\n                        xors == 0b0111000 \\\/\n                        xors == 0b1110000)\n                      \/\\ (\n                        rxors == 0b0000011 \\\/\n                        rxors == 0b0000110 \\\/\n                        rxors == 0b0001100 \\\/\n                        rxors == 0b0011000 \\\/\n                        rxors == 0b0110000 \\\/\n                        rxors == 0b1100000)\n    where xors = r ^ r'\n          rxors = r && rxors\n\nvalidColJump : Board -> Board -> Bit\nvalidColJump a a' = validRowJump (transpose a) (transpose a')\n\nvalidMove : Board -> Board -> Bit\nvalidMove a a' = validRowJump a a' \\\/ validColJump a a'\n\nvalidMoveSequence : {n} (fin n, n >= 1) => [n] Board -> Bit\nvalidMoveSequence moves = all [validMove a b | a <- moves | b <- drop`{1} moves]\n\nsolutionInNmoves : {n} (fin n) => [n] Board -> Bit\nproperty solutionInNmoves ms = validMoveSequence ([start] # ms # [second])\n```"}]}
{"filename":"cryptol\/examples\/SuiteB_FFI\/SuiteB_FFI.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named SuiteB_FFI that contains the following definitions and behaviors:\n- Import the SuiteB module with a short alias and create type aliases that refer to its AES-related types: AES128, AES192, AES256, AESRoundKey, AESEncryptKeySchedule k, and AESDecryptKeySchedule k.\n- Define functions that construct AES key schedules from raw keys: aes128EncryptSchedule, aes128DecryptSchedule, aes128Schedules; aes192EncryptSchedule, aes192DecryptSchedule, aes192Schedules; aes256EncryptSchedule, aes256DecryptSchedule, aes256Schedules. Each takes a key of the corresponding bit width and returns an encrypt schedule, a decrypt schedule, or both. At runtime, branch on a Boolean flag indicating AES-NI availability: if supported, convert the key from a single bitvector to an array of bytes (16, 24, or 32 bytes respectively) and call the appropriate foreign AES-NI expansion; otherwise delegate to the imported SuiteB implementation.\n- Define block operations aesEncryptBlock and aesDecryptBlock with a type parameter k and a fin k constraint. Each takes the appropriate key schedule and a 128-bit block, and returns a 128-bit block. When AES-NI is available, split the block into 16 bytes, invoke the corresponding foreign AES-NI block function, then join bytes back to a 128-bit result; otherwise delegate to the imported SuiteB functions.\n- In a private section, declare foreign functions: a zero-argument check that returns a single Bit indicating AES-NI support; key expansion functions for 128\/192\/256-bit keys that operate on byte arrays; paired expand functions returning both schedules; and block encrypt\/decrypt functions parameterized by k with fin k.\n- Define a private constant aesniSupported initialized from the foreign check.\n- Bind sha224, sha256, sha384, and sha512 to the imported implementations."},{"role":"assistant","content":"```cryptol\nmodule SuiteB_FFI where\n\nimport SuiteB as SB\n\ntype AES128 = SB::AES128\n\ntype AES192 = SB::AES192\n\ntype AES256 = SB::AES256\n\ntype AESRoundKey = SB::AESRoundKey\n\ntype AESEncryptKeySchedule k = SB::AESEncryptKeySchedule k\n\ntype AESDecryptKeySchedule k = SB::AESDecryptKeySchedule k\n\naes128EncryptSchedule : [128] -> AESEncryptKeySchedule AES128\naes128EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt128 (split key)\n    else SB::aes128EncryptSchedule\n\naes128DecryptSchedule : [128] -> AESDecryptKeySchedule AES128\naes128DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt128 (split key)\n    else SB::aes128DecryptSchedule\n\naes128Schedules : [128] -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\naes128Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt128 (split key)\n    else SB::aes128Schedules\n\naes192EncryptSchedule : [192] -> AESEncryptKeySchedule AES192\naes192EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt192 (split key)\n    else SB::aes192EncryptSchedule\n\naes192DecryptSchedule : [192] -> AESDecryptKeySchedule AES192\naes192DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt192 (split key)\n    else SB::aes192DecryptSchedule\n\naes192Schedules : [192] -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\naes192Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt192 (split key)\n    else SB::aes192Schedules\n\naes256EncryptSchedule : [256] -> AESEncryptKeySchedule AES256\naes256EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt256 (split key)\n    else SB::aes256EncryptSchedule\n\naes256DecryptSchedule : [256] -> AESDecryptKeySchedule AES256\naes256DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt256 (split key)\n    else SB::aes256DecryptSchedule\n\naes256Schedules : [256] -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\naes256Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt256 (split key)\n    else SB::aes256Schedules\n\naesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]\naesEncryptBlock =\n  if aesniSupported\n    then \\schedule plaintext -> join (aesniEncryptBlock schedule (split plaintext))\n    else SB::aesEncryptBlock\n\naesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]\naesDecryptBlock =\n  if aesniSupported\n    then \\schedule ciphertext -> join (aesniDecryptBlock schedule (split ciphertext))\n    else SB::aesDecryptBlock\n\nprivate\n  foreign checkAESNISupported : () -> Bit\n  foreign aesniExpandEncrypt128 : [16][8] -> AESEncryptKeySchedule AES128\n  foreign aesniExpandDecrypt128 : [16][8] -> AESDecryptKeySchedule AES128\n  foreign aesniExpandEncryptDecrypt128 : [16][8]\n    -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\n  foreign aesniExpandEncrypt192 : [24][8] -> AESEncryptKeySchedule AES192\n  foreign aesniExpandDecrypt192 : [24][8] -> AESDecryptKeySchedule AES192\n  foreign aesniExpandEncryptDecrypt192 : [24][8]\n    -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\n  foreign aesniExpandEncrypt256 : [32][8] -> AESEncryptKeySchedule AES256\n  foreign aesniExpandDecrypt256 : [32][8] -> AESDecryptKeySchedule AES256\n  foreign aesniExpandEncryptDecrypt256 : [32][8]\n    -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\n  foreign aesniEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [16][8] -> [16][8]\n  foreign aesniDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [16][8] -> [16][8]\n\n  aesniSupported = checkAESNISupported ()\n\nsha224 = SB::sha224\n\nsha256 = SB::sha256\n\nsha384 = SB::sha384\n\nsha512 = SB::sha512\n```"}]}
{"filename":"cryptol\/examples\/contrib\/mkrand.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named MKRAND that contains the following definitions: (1) Type aliases: Seg as a 128-bit sequence, and Field as a vector of 128 Seg values. (2) A constant seedUnit of type Seg (the default seed). (3) A function field: Seg -> [inf]Seg that produces an infinite stream where the first element is the seed and each subsequent element is computed by an elementary cellular automaton \u201crule 30\u201d: for each bit position, XOR the left neighbor with the OR of the current and right neighbors (neighbors obtained by 1-bit shifts). (4) A function sha30: Seg -> Seg that evolves field from a given seed, takes the middle-column bit from each row, drops the first 128 rows, takes the next 128 bits, and packs them into a 128-bit result. (5) A function rands: Seg -> [inf]Seg that iteratively maps p to p XOR sha30(p), starting from the given seed, yielding an infinite sequence. (6) A function randBytes: Seg -> [inf][8] that concatenates the rands output and groups it into bytes. (7) A function randXOR: for any length n, takes a Seg and a String n (n bytes) and returns a String n by XORing the source bytes with the byte stream from randBytes; provide an explicit polymorphic type signature with length parameter n. (8) A property otp_encdec that checks that encrypting a fixed ASCII message with seedUnit equals a fixed 16-byte ciphertext, and decrypting that ciphertext with the same seed reproduces the original message. (9) A function otp_involutive: for any length len with fin len, takes String len and returns Bit, asserting that applying randXOR with seedUnit twice yields the original message. (10) A property otp_involutive_32 that quantifies over messages and checks otp_involutive for 32-byte strings."},{"role":"assistant","content":"```cryptol\nmodule MKRAND where\n\ntype Seg   = [0x80]\ntype Field = [0x80]Seg\n\nseedUnit:Seg\nseedUnit = (0 :[63]) # (1:[1]) # (0:[64])\n\nfield: Seg -> [inf]Seg\nfield s = new\n  where\n    new = [s] # [ rule30 row | row <- new]\n    rule30 r = [ a ^ (b || c) | a <- r >>> 1\n                              | b <- r\n                              | c <- r <<< 1\n               ]\n\nsha30: Seg -> Seg\nsha30 s = take`{0x80} (drop`{0x80} [ r @ ((((length r) \/ 2)-1):[8]) | r <- field s])\n\nrands : Seg -> [inf]Seg\nrands s = rest\n  where\n     rand p = p ^ (sha30 p)\n     rest = [rand s] # [rand x | x <- rest]\n\nrandBytes : Seg -> [inf][8]\nrandBytes s = groupBy`{8} (join (rands s))\n\nrandXOR : {n} Seg ->  String n -> String n\nrandXOR seed src = [s ^ r | s <- src\n                          | r <- randBytes seed\n                   ]\n\nproperty otp_encdec =\n     randXOR seedUnit \"Deus Ex Machina\" == c\n  \/\\ randXOR seedUnit c == \"Deus Ex Machina\"\n  where c = [ 0x28, 0x2b, 0x2c, 0xfa\n            , 0x92, 0xca, 0xb3, 0xcb\n            , 0xed, 0x50, 0xc2, 0x1b\n            , 0x11, 0x0e, 0x70]\n\notp_involutive : {len} (fin len) => String len -> Bit\notp_involutive msg = randXOR seedUnit (randXOR seedUnit msg) == msg\n\nproperty otp_involutive_32 msg = otp_involutive (msg : String 32)\n```"}]}
{"filename":"cryptol\/examples\/contrib\/EvenMansour.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the Even\u2013Mansour construction and supporting utilities as follows: define a constant permutation F generated from a fixed 256-bit seed using a PRNG-based shuffle. Define a property that holds for a candidate permutation when all entries are unique and each index is within 0 to length-1. Define a constant F\u2019 as the inverse of F. Define a property that, for any vector, permutation, and its inverse, applying the permutation then its inverse yields the original vector. Define encryption E and decryption D over a size parameter n with constraints: n is finite, n \u2265 1, and the bit-width of n is at least that of n\u22121. Both keys are n-bit vectors, messages and ciphertexts are n-bit vectors. Encryption xors the message with the first key, applies the public permutation, then xors with the second key. Decryption xors the ciphertext with the second key, applies the inverse permutation, then xors with the first key. Define a property that for all keys and messages, decryption after encryption returns the original message. Also define utilities: swap that exchanges two positions in an array of length a (a finite, a \u2265 1; indices have width sufficient to index a\u22121); a permutation generator that starts from the identity and performs a sequence of swaps driven by PRNG-derived indices (parameter a finite, a \u2265 1, with bit-width of a at least that of a\u22121); a predicate that returns true iff all elements in a vector are unique; a predicate that returns true iff every element in a vector is \u2264 a given bound; an index_of function that returns the first index of a value in an array (element type comparable); and an inverse_permutation function that maps each value to its position. Provide precise type signatures and constraints for all definitions."},{"role":"assistant","content":"```cryptol\nF = (generate_random_permutation 1942611697)\n\nproperty is_a_permutation a = (unique a) \/\\ (leq a (length(a)-1))\n\nF' = inverse_permutation F\n\nproperty is_inverse_permutation x a a' = ((x@@a)@@a') == x\n\/\/ Main> is_inverse_permutation ([0..9]:[_][4]) (F:[10]_) (F':[10]_)\n\nE : {n} (fin n, n >= 1, width n >= width(n-1)) => ([n], [n]) -> [n] -> [n]\nE (K1, K2) M =  (M^K1)@@F ^ K2\n\nD : {n} (fin n, n >= 1, width n >= width(n-1)) => ([n], [n]) -> [n] -> [n]\nD (K1, K2) C =  (C^K2)@@F' ^ K1\n\n\/**\n * It is easy to verify that for every M in {0,1}^n and K in {0,1}^2n,\n * the following identity holds D_K(E_K(M)) = M, i.e. D_K decrypts\n * messages that were encrypted using E_K.\n *\/\nproperty E_and_D_are_inverses K M = (D K (E K M)) == M\n\n\/******* Utilities *******\/\n\nswap : {a, b} (fin a, a >= 1) => [a]b -> [width(a-1)] -> [width(a-1)] -> [a]b\nswap xs a b = [ if(i == a) then xs@b\n                 |(i == b) then xs@a\n                else xs@i\n              | i <- [0 .. a-1] ]\n\ngenerate_random_permutation : {a} (fin a, a >= 1, width a >= width(a-1)) => [256] -> [a][width(a-1)]\ngenerate_random_permutation seed = pss!0\n  where\n    indices = [ take `{width(a-1)} (b % `a) | b <- (random seed) : [a][width a] ]\n    pss = [ [0 .. a-1] ] # [ swap ps a b | ps <- pss | a <- [0 .. a-1] | b <- indices ]\n\nunique : {a, b} (fin a, fin b, a>=1) => [a][b] -> Bit\nunique xs = [ exist x (i+1) | x <- xs | i <- [0...] ] == 0\n  where exist : [b] -> [width a] -> Bit\n        exist x i = if(i>=`a) then False\n                    else if(x==(xs@i)) then True\n                    else exist x (i+1)\n\nleq xs a = [ x <= a | x <- xs ] == ~0\n\nindex_of : {a, b} (fin a, a>=1, Cmp b) => [a]b -> b -> [width(a-1)]\nindex_of xs a = (ret!0).1\n  where ret = [(False, 0)] # [ if(xs@i == a) then (True, i) else r\n                             | i <- [0 .. a-1 ]\n                             | r <- ret ]\n\ninverse_permutation : {a} (fin a, a >= 1) => [a][width(a-1)] -> [a][width(a-1)]\ninverse_permutation perm = [ index_of perm i | i <- [0 .. a-1 ] ]\n```"}]}
{"filename":"cryptol\/examples\/contrib\/A51.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the A5\/1 keystream generator with the following elements: 1) Define a type alias equal to 128 for the keystream length. 2) Define a function that steps a length-d LFSR under a boolean clock condition using a degree-(d) characteristic polynomial mask of length d+1; require fin d and d >= 1, ensure the polynomial\u2019s highest bit is set, compute the feedback bit as the XOR of masked state bits, and update the state only when the condition is true. 3) Define a function that, given a polynomial, an infinite stream of clock conditions, and an initial d-bit state, returns both the infinite output bit stream (the leftmost bit of each state) and the infinite stream of LFSR states, by iterating the step function. 4) Define a majority-of-three boolean helper and a helper that produces the running application of a binary operator over a sequence as needed for feedback computation. 5) Define a stream generator that takes three registers of sizes 19, 22, and 23 bits, respectively, constructs three conditionally clocked LFSRs with characteristic polynomials matching the standard taps for those sizes, derives the clock-condition streams by comparing each register\u2019s designated tap (index 8 for the first, 10 for the others) to the per-cycle majority of those taps, and outputs the XOR of the three LFSR output streams. 6) Define a function that returns the first 128 bits of the keystream from the three-register generator. 7) Define constants for the three initial register values (sizes 19, 22, 23) and a 128-bit expected keystream. 8) Define a property that the 128-bit output for the given initial values equals the expected keystream. 9) Define a property that, for variables of sizes 19, 22, and 23, the produced 128-bit keystream equals the expected value (to enable seed search)."},{"role":"assistant","content":"```cryptol\nA51_stream : [19] -> [22] -> [23] -> [inf]\nA51_stream R1 R2 R3 = R1s ^ R2s ^ R3s\n  where\n    (R1s, R1f) = lfsrki <| x^^19 + x^^18 + x^^17 + x^^14 + 1 |>  R1c R1\n    (R2s, R2f) = lfsrki <| x^^22 + x^^21 + 1 |>                  R2c R2\n    (R3s, R3f) = lfsrki <| x^^23 + x^^22 + x^^21 + x^^8 + 1 |>   R3c R3\n    majvs = [ majv (r1@8) (r2@10) (r3@10) | r1 <- R1f | r2 <- R2f | r3 <- R3f ]\n    R1c = [ r1@8 == m | r1 <- R1f | m <- majvs ]\n    R2c = [ r2@10 == m | r2 <- R2f | m <- majvs ]\n    R3c = [ r3@10 == m | r3 <- R3f | m <- majvs ]\n\ntype N = 128\nA51 : ([19], [22], [23]) -> [N]Bit\nA51(reg1, reg2, reg3) = keystream\n  where\n    keystream = take`{N} (A51_stream reg1 reg2 reg3)\n\nlfsrki_step : {d} (fin d, d >=1) => [d+1] -> Bit -> [d] -> [d]\nlfsrki_step poly cond fill = fill'\n where\n   feedback_bit = if(poly@0) then prefix (^) (reverse([False]#fill) && poly)\n                             else error \"polynomial does not have high-bit set.\"\n   fill' = if cond then [feedback_bit]#(take fill) else fill\n\nlfsrki : {d} (fin d, d >=1) => [d+1] -> [inf] -> [d] -> ([inf], [inf][d])\nlfsrki poly conds init = (stream, fills)\n  where\n    lfsrki' = lfsrki_step poly\n    fills = [init] # [ lfsrki' c f | c <- conds | f <- fills]\n    stream = [ f!0 | f <- fills ]\n\nprefix f xs = ys!0\n  where ys = [xs@0] # [ f y x | y <- ys | x <- tail xs ]\n\nmajv a b c = (a && b) || (a && c) || (b && c)\n\niv1 = 0b1010111011101011101\niv2 = 0b1010111011101010101110\niv3 = 0b10100000111100110011011\n\ntest_keystream = 0b00100100111010001110101110101100010100110111110101000101110000011101000111110101010000010011001111110101110001011010100000010001\n\nproperty A51_correct = (A51(iv1, iv2, iv3)) == test_keystream\nproperty A51_search x y z = A51(x,y,z) == test_keystream\n```"}]}
{"filename":"cryptol\/examples\/contrib\/RC4.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the RC4 stream cipher that includes the following: (1) Define swap that takes a 256-element state of bytes and two byte indices and returns a new state with those positions exchanged. (2) Define ksa_step that, given an infinite byte key stream, a byte i, a byte j, and a 256-byte state, computes j\u2019 as the byte-wise sum of j, the state at i, and the key at i (all modulo 256), and returns (j\u2019, updated state via swap at i and j\u2019). (3) Define ksa that starts from the identity 256-byte permutation, iterates i from 0 to 255 applying ksa_step, treats the key as an infinite repetition of the provided key bytes, and returns the final state. (4) Define ks_step that, given i, j, and a state, computes j\u2019 as j plus the state at i (mod 256), produces a swapped state at i and j\u2019, and outputs the keystream byte indexed by the sum of the state at i and the state at j\u2019 (mod 256), along with j\u2019 and the new state. (5) Define ks that first computes the initial state via ksa on the infinitely repeated key, then generates an infinite byte stream by repeatedly applying ks_step with i cycling through 1..255 then 0. (6) Provide type signatures: states are sequences of 256 bytes, indices and intermediate values are bytes, keys and keystreams are infinite sequences of bytes, and all byte arithmetic wraps modulo 256. (7) Define properties test1, test2, and test3 that check the initial keystream bytes for the ASCII keys \"Key\", \"Wiki\", and \"Secret\" against the canonical RC4 test vectors."},{"role":"assistant","content":"```cryptol\nswap : [256][8] -> [8] -> [8] -> [256][8]\nswap s i j = [ s @ (if n == i then j else\n                    if n == j then i else\n                    n)\n             | n <- [0..255]\n             ]\n\nksa_step : [inf][8] -> [8] -> [8] -> [256][8] -> ([8],[256][8])\nksa_step key i j s = (j', swap s i j')\n where j' = j + s@i + key@i\n\nksa : [inf][8] -> [256][8]\nksa key = (go ! 0).1 where\n go : [257]([8],[256][8])\n go = [(0,[0..255])] # [ ksa_step key i j s\n                       | i <- [0..255]\n                       | (j,s) <- go\n                       ]\n\nks_step : [8] -> [8] -> [256][8] -> ([8],[256][8],[8])\nks_step i j s = (j',s',s@(s@i + s@j'))\n where j' = j + s@i\n       s' = swap s i j'\n\nks key = [ k | (_,_,k) <- drop`{1} go ] where\n go = [(0,ksa key',0)] # [ ks_step i j s\n                         | i <- loop\n                         | (j,s,k) <- go\n                         ]\n key' = key # key'\n loop = [1..255] # [0] # loop\n\nproperty test1 = take (ks \"Key\") == [0xEB,0x9F,0x77,0x81,0xB7,0x34,0xCA,0x72,0xA7,0x19]\nproperty test2 = take (ks \"Wiki\") == [0x60,0x44,0xDB,0x6D,0x41,0xB7]\nproperty test3 = take (ks \"Secret\") == [0x04,0xD4,0x6B,0x05,0x3C,0xA8,0x7B,0x59]\n```"}]}
{"filename":"cryptol\/examples\/contrib\/MISTY1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named MISTY1 that contains the following definitions: (1) A key schedule that maps a 16-element sequence of 8-bit words to a 32-element sequence of 16-bit subkeys by: joining to a single bitvector, splitting into 16-bit words, forming a shifted variant, applying the 16-bit round function to each pair, and deriving two additional subkey groups by extracting upper and lower portions and zero-extending them; concatenate the four groups to produce all subkeys. (2) A 32-bit round function FO that takes a 32-bit block half, an 8-bit round index, and the subkey array, splits the half into two 16-bit words, iterates a fixed pipeline of transformations using the 16-bit round function, XORs, and subkey selections based on modular arithmetic over the index, and returns the recombined 32-bit result. (3) A 16-bit round function FI that splits its 16-bit input into 9-bit and 7-bit parts, applies two S-box tables (7-bit and 9-bit), mixes with parts of a 16-bit key via XOR, extraction of high\/low bits, and zero-extension, and returns a 16-bit result. (4) Two S-box constants: a 128-entry table of 7-bit values and a 512-entry table of 9-bit values, using the standard MISTY1 contents. (5) Linear layer FL and its inverse FLINV over 32-bit halves that depend on the parity of the 8-bit round index, split the input into two 16-bit words, and combine them with AND\/OR and XOR using appropriate subkeys. (6) A polymorphic zero-extension function with constraints ensuring the target width is at least the source width. (7) A function that returns true iff the least-significant bit is zero. (8) A 64-bit encryption that performs the specified 10-step schedule of FL\/FO operations on two 32-bit halves using subkeys. (9) A matching 64-bit decryption that inverts the schedule. (10) Define a property that encrypting two fixed 64-bit plaintexts with subkeys from a fixed 128-bit key yields two fixed 64-bit ciphertexts. (11) Define a property that decryption(encryption(pt, EK), EK) equals pt for all 64-bit plaintexts and 128-bit keys, where EK comes from the key schedule."},{"role":"assistant","content":"```cryptol\nmodule MISTY1 where\n\nkeySchedule : [16][8] -> [32][16]\nkeySchedule K = EK_1 # EK_2 # EK_3 # EK_4\n    where EK_1 = split (join K)\n          EK_2 = [ FI ek_1 ek_1_shifted\n                 | ek_1         <- EK_1\n                 | ek_1_shifted <- EK_1 <<< 1\n                 ]\n          EK_3 = [extend (drop`{7} ek_2) | ek_2 <- EK_2]\n          EK_4 = [extend (take`{7} ek_2) | ek_2 <- EK_2]\n\nFO : [32] -> [8] -> [32][16] -> [32]\nFO FO_IN k EK = (FO_OUT ! 0).1 # (FO_OUT ! 0).0\n    where FO_OUT = [(take FO_IN, drop FO_IN)] # [ f t0 t1\n                                                | f        <- funcs\n                                                | (t0, t1) <- FO_OUT\n                                                ]\n                    funcs : [_]([16] -> [16] -> ([16], [16]))\n          funcs = [\\t0 t1 -> (t0 ^ (EK @ k), t1),\n                   \\t0 t1 -> (FI t0 (EK @ ((k + 5) % 8 + 8)), t1),\n                   \\t0 t1 -> (t0 ^ t1, t1),\n                   \\t0 t1 -> (t0, t1 ^ (EK @ ((k + 2) % 8))),\n                   \\t0 t1 -> (t0, FI t1 (EK @ ((k + 1) % 8 + 8))),\n                   \\t0 t1 -> (t0, t1 ^ t0),\n                   \\t0 t1 -> (t0 ^ EK @ ((k + 7) % 8), t1),\n                   \\t0 t1 -> (FI t0 (EK @ ((k + 3) % 8 + 8)), t1),\n                   \\t0 t1 -> (t0 ^ t1, t1),\n                   \\t0 t1 -> (t0, t1 ^ EK @ ((k + 4) % 8))\n                  ]\n\nFI : [16] -> [16] -> [16]\nFI FI_IN FI_KEY = (FI_OUT ! 0).1 # (FI_OUT ! 0).0\n    where FI_OUT = [(take FI_IN, drop FI_IN)] # [ f d9 d7\n                                                | f        <- funcs\n                                                | (d9, d7) <- FI_OUT\n                                                ]\n                              funcs : [_]([9] -> [7] -> ([9], [7]))\n          funcs = [\\d9 d7 -> ((S9 @ d9) ^ (extend d7), d7),\n                   \\d9 d7 -> (d9, drop (extend (S7 @ d7) ^ d9)),\n                   \\d9 d7 -> (d9, d7 ^ drop (FI_KEY >> 9)),\n                   \\d9 d7 -> (d9 ^ drop FI_KEY, d7),\n                   \\d9 d7 -> ((S9 @ d9) ^ (extend d7), d7)\n                  ]\n\nS7 : [_][7]\nS7 = [27,  50,  51,  90,  59,  16,  23,  84,  91,  26, 114, 115, 107,\n      44, 102,  73,  31,  36,  19, 108,  55,  46,  63,  74,  93,  15,\n      64,  86,  37,  81,  28,   4,  11,  70,  32,  13, 123,  53,  68,\n      66,  43,  30,  65,  20,  75, 121,  21, 111,  14,  85,   9,  54,\n     116,  12, 103,  83,  40,  10, 126,  56,   2,   7,  96,  41,  25,\n      18, 101,  47,  48,  57,   8, 104,  95, 120,  42,  76, 100,  69,\n     117,  61,  89,  72,   3,  87, 124,  79,  98,  60,  29,  33,  94,\n      39, 106, 112,  77,  58,   1, 109, 110,  99,  24, 119,  35,   5,\n      38, 118,   0,  49,  45, 122, 127,  97,  80,  34,  17,   6,  71,\n      22,  82,  78, 113,  62, 105,  67,  52,  92,  88, 125]\n\nS9 : [_][9]\nS9 = [451, 203, 339, 415, 483, 233, 251,  53, 385, 185, 279, 491, 307,\n        9,  45, 211, 199, 330,  55, 126, 235, 356, 403, 472, 163, 286,\n       85,  44,  29, 418, 355, 280, 331, 338, 466,  15,  43,  48, 314,\n      229, 273, 312, 398,  99, 227, 200, 500,  27,   1, 157, 248, 416,\n      365, 499,  28, 326, 125, 209, 130, 490, 387, 301, 244, 414, 467,\n      221, 482, 296, 480, 236,  89, 145,  17, 303,  38, 220, 176, 396,\n      271, 503, 231, 364, 182, 249, 216, 337, 257, 332, 259, 184, 340,\n      299, 430,  23, 113,  12,  71,  88, 127, 420, 308, 297, 132, 349,\n      413, 434, 419,  72, 124,  81, 458,  35, 317, 423, 357,  59,  66,\n      218, 402, 206, 193, 107, 159, 497, 300, 388, 250, 406, 481, 361,\n      381,  49, 384, 266, 148, 474, 390, 318, 284,  96, 373, 463, 103,\n      281, 101, 104, 153, 336,   8,   7, 380, 183,  36,  25, 222, 295,\n      219, 228, 425,  82, 265, 144, 412, 449,  40, 435, 309, 362, 374,\n      223, 485, 392, 197, 366, 478, 433, 195, 479,  54, 238, 494, 240,\n      147,  73, 154, 438, 105, 129, 293,  11,  94, 180, 329, 455, 372,\n       62, 315, 439, 142, 454, 174,  16, 149, 495,  78, 242, 509, 133,\n      253, 246, 160, 367, 131, 138, 342, 155, 316, 263, 359, 152, 464,\n      489,   3, 510, 189, 290, 137, 210, 399,  18,  51, 106, 322, 237,\n      368, 283, 226, 335, 344, 305, 327,  93, 275, 461, 121, 353, 421,\n      377, 158, 436, 204,  34, 306,  26, 232,   4, 391, 493, 407,  57,\n      447, 471,  39, 395, 198, 156, 208, 334, 108,  52, 498, 110, 202,\n       37, 186, 401, 254,  19, 262,  47, 429, 370, 475, 192, 267, 470,\n      245, 492, 269, 118, 276, 427, 117, 268, 484, 345,  84, 287,  75,\n      196, 446, 247,  41, 164,  14, 496, 119,  77, 378, 134, 139, 179,\n      369, 191, 270, 260, 151, 347, 352, 360, 215, 187, 102, 462, 252,\n      146, 453, 111,  22,  74, 161, 313, 175, 241, 400,  10, 426, 323,\n      379,  86, 397, 358, 212, 507, 333, 404, 410, 135, 504, 291, 167,\n      440, 321,  60, 505, 320,  42, 341, 282, 417, 408, 213, 294, 431,\n       97, 302, 343, 476, 114, 394, 170, 150, 277, 239,  69, 123, 141,\n      325,  83,  95, 376, 178,  46,  32, 469,  63, 457, 487, 428,  68,\n       56,  20, 177, 363, 171, 181,  90, 386, 456, 468,  24, 375, 100,\n      207, 109, 256, 409, 304, 346,   5, 288, 443, 445, 224,  79, 214,\n      319, 452, 298,  21,   6, 255, 411, 166,  67, 136,  80, 351, 488,\n      289, 115, 382, 188, 194, 201, 371, 393, 501, 116, 460, 486, 424,\n      405,  31,  65,  13, 442,  50,  61, 465, 128, 168,  87, 441, 354,\n      328, 217, 261,  98, 122,  33, 511, 274, 264, 448, 169, 285, 432,\n      422, 205, 243,  92, 258,  91, 473, 324, 502, 173, 165,  58, 459,\n      310, 383,  70, 225,  30, 477, 230, 311, 506, 389, 140, 143,  64,\n      437, 190, 120,   0, 172, 272, 350, 292,   2, 444, 162, 234, 112,\n      508, 278, 348,  76, 450]\n\nFL : [32] -> [8] -> [32][16] -> [32]\nFL FL_IN k EK =\n    if isEven k then\n        d0_even # d1_even\n        where d1_even = d1 ^ (d0 && (EK @ (k \/ 2)))\n              d0_even = d0 ^ (d1_even || (EK @ ((k \/ 2 + 6) % 8 + 8)))\n    else\n        d0_odd # d1_odd\n        where d1_odd = d1 ^ (d0 && (EK @ (((k - 1) \/ 2 + 2) % 8 + 8)))\n              d0_odd = d0 ^ (d1_odd || (EK @ (((k - 1) \/ 2 + 4) % 8)))\n    where         d0 : [16]\n        d0 = take FL_IN\n                d1 : [16]\n        d1 = drop FL_IN\n\nFLINV : [32] -> [8] -> [32][16] -> [32]\nFLINV FL_IN k EK =\n    if isEven k then\n        d0_even # d1_even\n        where d0_even = d0 ^ (d1 || (EK @ ((k \/ 2 + 6) % 8 + 8)))\n              d1_even = d1 ^ (d0_even && (EK @ (k \/ 2)))\n    else\n        d0_odd # d1_odd\n        where d0_odd = d0 ^ (d1 || (EK @ (((k - 1) \/ 2 + 4) % 8)))\n              d1_odd = d1 ^ (d0_odd && (EK @ (((k - 1) \/ 2 + 2) % 8 + 8)))\n    where         d0 : [16]\n        d0 = take FL_IN\n                d1 : [16]\n        d1 = drop FL_IN\n\nmisty1Encrypt : [64] -> [32][16] -> [64]\nmisty1Encrypt P EK = (C ! 0).1 # (C ! 0).0\n    where\n                        C = [(take P, drop P)] # [ f D0 D1\n                                 | f        <- funcs\n                                 | (D0, D1) <- C\n                                 ]\n        funcs : [_]([32] -> [32] -> ([32], [32]))\n        funcs = [                 \\D0 D1 -> (FL D0 0 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 1 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 0 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 1 EK), D1),\n                                  \\D0 D1 -> (FL D0 2 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 3 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 2 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 3 EK), D1),\n                                  \\D0 D1 -> (FL D0 4 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 5 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 4 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 5 EK), D1),\n                                  \\D0 D1 -> (FL D0 6 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 7 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 6 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 7 EK), D1),\n                                  \\D0 D1 -> (FL D0 8 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 9 EK)\n                ]\n\nmisty1Decrypt : [64] -> [32][16] -> [64]\nmisty1Decrypt C EK = (P ! 0).0 # (P ! 0).1\n    where P = [(drop C, take C)] # [ f D0 D1\n                                   | f        <- funcs\n                                   | (D0, D1) <- P\n                                   ]\n          funcs : [_]([32] -> [32] -> ([32], [32]))\n          funcs = [\\D0 D1 -> (FLINV D0 8 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 9 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 7 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 6 EK)),\n                   \\D0 D1 -> (FLINV D0 6 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 7 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 5 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 4 EK)),\n                   \\D0 D1 -> (FLINV D0 4 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 5 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 3 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 2 EK)),\n                   \\D0 D1 -> (FLINV D0 2 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 3 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 1 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 0 EK)),\n                   \\D0 D1 -> (FLINV D0 0 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 1 EK)\n                  ]\n\nextend : {total, n} (fin total, fin n, total >= n) => [n] -> [total]\nextend n = zero # n\n\nisEven : {a} (fin a) => [a] -> Bool\nisEven n = ~(n ! 0)\n\nproperty testMisty1Encrypt = [ misty1Encrypt block EK\n                             | block <- plaintext\n                             ] == ciphertext\n    where EK         = keySchedule key\n          key        = [0x00, 0x11 .. 0xff]\n          plaintext  = [0x0123456789abcdef, 0xfedcba9876543210]\n          ciphertext = [0x8b1da5f56ab3d07c, 0x04b68240b13be95d]\n\nproperty misty1Correct pt key = misty1Decrypt (misty1Encrypt pt EK) EK == pt\n    where EK = keySchedule key\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/Keys.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Keys that imports curve operations, BLAKE2s, scrypt, and Base58 utilities, and contains the following definitions: (1) a type alias for a MiniLock identifier as a sequence of 46 8-bit values; (2) a function that, given a public Curve25519 key, computes a 1-byte BLAKE2s checksum of the key, appends it to the key bytes, and Base58-encodes the result to produce a MiniLock identifier; (3) a function that, given a MiniLock identifier, Base58-decodes it, splits into 33 bytes, extracts the first byte as the received checksum, the remaining 32 bytes as the public key, recomputes the 1-byte BLAKE2s checksum of the public key, and returns a pair of a boolean indicating checksum equality and the public key; (4) a polymorphic function that takes n bytes (with constraints 1 <= n <= 46) and left-pads them with the Base58 zero-character byte to produce exactly 46 bytes; (5) a function that, given password bytes and salt bytes (with finite size parameters and constraints that the password length parameter is at most 64 and four times the salt length parameter has width at most 32), derives a private Curve25519 key using scrypt with cost parameters N=2^1 and r=8 applied to the 32-byte BLAKE2s digest of the password, computes the corresponding public key over the Curve25519 base point, and returns the MiniLock identifier from the public key together with the private key; (6) test constants for a sample password, email, MiniLock identifier, private key bytes, and derived public key; and (7) define a property that asserts all of the following hold simultaneously: decoding the test identifier yields a public key equal to the derived test public key, encoding the derived test public key yields the test identifier, the test identifier matches its expected literal, and the test private key matches its expected byte literal."},{"role":"assistant","content":"```cryptol\nmodule Keys where\n\nimport CfrgCurves\nimport Blake2s\nimport SCrypt\nimport Base58\n\ntype MinilockID = [46][8]\n\nencodeID : Public25519 -> MinilockID\nencodeID pub = base58enc (join (pub # [h]))\n  where\n  h = blake2s `{nn=1} pub : [8]\n\ndecodeID : MinilockID -> (Bit,Public25519)\ndecodeID ident = (hComp == hRecv, key)\n where\n  bs    = split (base58dec ident)  : [33][8]\n  hRecv = bs ! 0\n  hComp = blake2s `{nn=1} key      : [8]\n  key   = take bs                  : [32][8]\n\nmkFullLengthID : {n} (46 >= n, n>= 1) => [n][8] -> MinilockID\nmkFullLengthID n = drop (['1' | _ <- [0..45] : [_][8]]  # n)\n\nmkID : {passBytes, saltBytes}\n       ( fin passBytes, fin saltBytes\n       , 64 >= width passBytes\n       , 32 >= width (4*saltBytes)\n       )\n    => [passBytes][8] -> [saltBytes][8] -> (MinilockID,Private25519)\nmkID pw email = (encodeID pub,priv)\n  where\n    priv : Private25519\n  priv = SCrypt `{N=2^^1,r=8} (split (blake2s `{nn=32} pw)) email\n    pub  = Curve25519 priv basePoint25519\n\ntestPass = \"some bears eat all the honey in the jar\"\ntestEmail = \"example@example.com\"\n\ntestID : MinilockID\ntestID = mkFullLengthID \"28ZvW9rqRqvqpFTtHnusUntRqrxb4qqZAaNAd3QsqjSsXq\"\n\ntestID_computed = \"28ZvW9rqRqvqpFTtHnusUntRqrxb4qqZAaNAd3QsqjSsXq\"  testPriv_computed =\n  [0x12, 0x86, 0xe0, 0x18, 0xc6, 0x68, 0x34, 0x96, 0x09, 0x2e, 0x53,\n   0x32, 0x37, 0x76, 0x80, 0x3c, 0x30, 0xb4, 0x75, 0x2d, 0xd7, 0x70,\n   0xea, 0xa9, 0x6f, 0x0d, 0xda, 0x25, 0xc7, 0xfe, 0x28, 0x1f]\n\ntestPriv = [0x12, 0x86, 0xe0, 0x18, 0xc6, 0x68, 0x34, 0x96, 0x09, 0x2e, 0x53, 0x32, 0x37, 0x76, 0x80, 0x3c, 0x30, 0xb4, 0x75, 0x2d, 0xd7, 0x70,0xea, 0xa9, 0x6f, 0x0d, 0xda, 0x25, 0xc7, 0xfe, 0x28, 0x1f]\n\ntestPub = Curve25519 testPriv basePoint25519\nproperty kat_pub_id_eq = testPub == (decodeID testID).1 \/\\ encodeID testPub == testID \/\\ testID == testID_computed \/\\ testPriv == testPriv_computed\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named AES that contains the following definitions, imports, parameters, and property, matching types and behavior: 1) Import the algorithm module under the alias AES, binding its mode type to a numeric parameter m and selecting the forward and inverse round functions for encryption and decryption, respectively. 2) Import the key expansion module, binding its Nk and Nr type parameters to those provided by the AES package. Also import the T-box definitions used by the algorithm. 3) Declare numeric type parameters m and k with the constraint that k equals 128 plus 64 times m, and that m is at most 2. 4) Define type synonyms EncKey and DecKey that both refer to the algorithm\u2019s key schedule type. 5) Provide the following function signatures and behaviors over bitvectors: - encrypt: takes a k-bit key and a 128-bit plaintext and returns a 128-bit ciphertext by first deriving an encryption schedule from the key and then applying the algorithm\u2019s encryption using that schedule. - decrypt: takes a k-bit key and a 128-bit ciphertext and returns a 128-bit plaintext by first deriving a decryption schedule from the key and then applying the algorithm\u2019s decryption using that schedule. - expandKeyEnc: takes a k-bit key and returns an EncKey using the key expansion routine. - encryptWithSchedule: takes an EncKey and a 128-bit block and returns the encrypted 128-bit block by delegating to the algorithm\u2019s encrypt function. - expandKeyDec: takes a k-bit key and returns an EncKey produced by applying the decryption key constructor to the expanded key. - decryptWithSchedule: takes a DecKey and a 128-bit block and returns the decrypted 128-bit block by delegating to the algorithm\u2019s decrypt function. 6) Define a property that, for any key and 128-bit block, decrypting the result of encrypting that block with the same key yields the original block."},{"role":"assistant","content":"```cryptol\nmodule AES where\n\nimport AES::Algorithm as AES where\n  type Mode = m\n  encRound = AESRound\n  decRound = AESInvRound\n\nimport AES::ExpandKey where\n  type Nk = AES::Nk\n  type Nr = AES::Nr\n\nimport AES::TBox\n\nparameter\n\n  type m : #\n  type k : #\n  type constraint (k == 128 + m * 64, 2 >= m)\n\ntype EncKey = AES::KeySchedule\ntype DecKey = AES::KeySchedule\n\nencrypt : [k] -> [128] -> [128]\nencrypt k = encryptWithSchedule (expandKeyEnc k)\n\ndecrypt : [k] -> [128] -> [128]\ndecrypt k = decryptWithSchedule (expandKeyDec k)\n\nexpandKeyEnc : [k] -> EncKey\nexpandKeyEnc = expandKey\n\nencryptWithSchedule : EncKey -> [128] -> [128]\nencryptWithSchedule = AES::encrypt\n\nexpandKeyDec : [k] -> EncKey\nexpandKeyDec k = makeDecKey (expandKey k)\n\ndecryptWithSchedule : DecKey -> [128] -> [128]\ndecryptWithSchedule = AES::decrypt\n\nproperty test k pt = decrypt k (encrypt k pt) == pt\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES_GCM_SIV_Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Create a Cryptol test specification that mirrors this file\u2019s behavior. Do the following:\n- Import the AES-GCM-SIV implementation multiple times under distinct aliases, each with Mode fixed to the 128-bit (0) or 256-bit (1) key variant, and with the AAD element bit-width fixed as required (including 0, 8, 40, 56, 80, 96, 120, 144, 160, 200, 240, 280).\n- For each alias, define properties named test0 through test49. Each property must be a Boolean equality that applies the aes_gcm_siv encryption function to a record containing a fixed key (128 or 256 bits according to Mode), a 96-bit nonce, an AAD value (possibly empty or a sequence of words whose element width matches the module\u2019s AAD parameter), and a plaintext message (ranging from empty to multiple 128-bit blocks). Assert that the returned ciphertext with its 128-bit tag equals the corresponding provided constant (concatenated where shown).\n- Cover both key sizes (128 and 256 bits), various AAD widths (including a 56-bit case derived from ASCII bytes), empty\/non-empty AAD, empty\/plaintext of different lengths, and multi-block messages. Include edge cases with all-zero inputs and boundary outputs.\n- Also add one final binding named test50 that invokes the 128-bit, empty-AAD variant on a long multi-block message using a fixed key and nonce; it produces the ciphertext value but does not assert equality with a constant.\n- Clearly state types: key is [128] when Mode=0 and [256] when Mode=1; nonce is [96]; AAD elements are [AAD]; msg is a sequence of 8-bit bytes or concatenated blocks; aes_gcm_siv returns the ciphertext concatenated with a 128-bit authentication tag.\nDo not provide solutions; only declare the properties and their exact equalities as specified."},{"role":"assistant","content":"```cryptol\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_56 where\n  type Mode = 0\n  type AAD = 56\n\nproperty test0 =\n  AES_GCM_SIV_0_56::aes_gcm_siv\n    { key   = 0xee8e1ed9ff2540ae8f2ba9f50bc2f27c\n    , nonce = 0x752abad3e0afb5f434dc4310\n    , aad   = join \"example\"\n    , msg   = join \"Hello world\"\n    }\n  ==\n  0x5d349ead175ef6b1def6fd #\n  0x4fbcdeb7e4793f4a1d7e4faa70100af1\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_0 where\n  type Mode = 0\n  type AAD = 0\n\nproperty test1 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = []\n    }\n  ==\n  0xdc20e2d83f25705bb49e439eca56de25\n\nproperty test2 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x0100000000000000\n    }\n  ==\n  0xb5d839330ac7b786578782fff6013b81 #\n  0x5b287c22493a364c\n\nproperty test3 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x010000000000000000000000\n    }\n  ==\n  0x7323ea61d05932260047d942a4978db3 #\n  0x57391a0bc4fdec8b0d106639\n\nproperty test4 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000\n    }\n  ==\n  0x743f7c8077ab25f8624e2e948579cf77 #\n  0x303aaf90f6fe21199c6068577437a0c4\n\nproperty test5 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000\n    }\n  ==\n  0x84e07e62ba83a6585417245d7ec413a9 #\n  0xfe427d6315c09b57ce45f2e3936a9445 #\n  0x1a8e45dcd4578c667cd86847bf6155ff\n\nproperty test6 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000\n    }\n  ==\n  0x3fd24ce1f5a67b75bf2351f181a475c7 #\n  0xb800a5b4d3dcf70106b1eea82fa1d64d #\n  0xf42bf7226122fa92e17a40eeaac1201b #\n  0x5e6e311dbf395d35b0fe39c2714388f8\n\nproperty test7 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000\n    }\n  ==\n  0x2433668f1058190f6d43e360f4f35cd8 #\n  0xe475127cfca7028ea8ab5c20f7ab2af0 #\n  0x2516a2bdcbc08d521be37ff28c152bba #\n  0x36697f25b4cd169c6590d1dd39566d3f #\n  0x8a263dd317aa88d56bdf3936dba75bb8\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_8 where\n  type Mode = 0\n  type AAD = 8\n\nproperty test8 =\n AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x0200000000000000\n    }\n  ==\n  0x1e6daba35669f4273b0a1a2560969cdf #\n  0x790d99759abd1508\n\nproperty test9 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x020000000000000000000000\n    }\n  ==\n  0x296c7889fd99f41917f4462008299c51 #\n  0x02745aaa3a0c469fad9e075a\n\nproperty test10 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000\n    }\n  ==\n  0xe2b0c5da79a901c1745f700525cb335b #\n  0x8f8936ec039e4e4bb97ebd8c4457441f\n\nproperty test11 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000\n    }\n  ==\n  0x620048ef3c1e73e57e02bb8562c416a3 #\n  0x19e73e4caac8e96a1ecb2933145a1d71 #\n  0xe6af6a7f87287da059a71684ed3498e1\n\nproperty test12 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000\n    }\n  ==\n  0x50c8303ea93925d64090d07bd109dfd9 #\n  0x515a5a33431019c17d93465999a8b005 #\n  0x3201d723120a8562b838cdff25bf9d1e #\n  0x6a8cc3865f76897c2e4b245cf31c51f2\n\nproperty test13 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000 #\n              0x05000000000000000000000000000000\n    }\n  ==\n  0x2f5c64059db55ee0fb847ed513003746 #\n  0xaca4e61c711b5de2e7a77ffd02da42fe #\n  0xec601910d3467bb8b36ebbaebce5fba3 #\n  0x0d36c95f48a3e7980f0e7ac299332a80 #\n  0xcdc46ae475563de037001ef84ae21744\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_96 where\n  type Mode = 0\n  type AAD = 96\n\nproperty test14 =\n  AES_GCM_SIV_0_96::aes_gcm_siv\n    { msg = 0x02000000\n    , aad = 0x010000000000000000000000\n    , key = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0xa8fe3e8707eb1f84fb28f8cb73de8e99 #\n  0xe2f48a14\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_144 where\n  type Mode = 0\n  type AAD = 144\n\nproperty test15 =\n  AES_GCM_SIV_0_144::aes_gcm_siv\n    { msg = 0x03000000000000000000000000000000 #\n            0x04000000\n    , aad = 0x01000000000000000000000000000000 #\n            0x0200\n    , key = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0x6bb0fecf5ded9b77f902c7d5da236a43 #\n  0x91dd029724afc9805e976f451e6d87f6 #\n  0xfe106514\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_160 where\n  type Mode = 0\n  type AAD = 160\n\nproperty test16 =\n  AES_GCM_SIV_0_160::aes_gcm_siv\n    { msg =   0x03000000000000000000000000000000 #\n              0x0400\n    , aad   = 0x01000000000000000000000000000000 #\n              0x02000000\n    , key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0x44d0aaf6fb2f1f34add5e8064e83e12a #\n  0x2adabff9b2ef00fb47920cc72a0c0f13 #\n  0xb9fd\n\nproperty test16' =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0xe66021d5eb8e4f4066d4adb9c33560e4\n   , nonce = 0xf46e44bb3da0015c94f70887\n   }\n   == 0xa4194b79071b01a87d65f706e3949578\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_40 where\n  type Mode = 0\n  type AAD = 40\n\nproperty test17 =\n  AES_GCM_SIV_0_40::aes_gcm_siv\n   { msg = 0x7a806c\n   , aad = 0x46bb91c3c5\n   , key = 0x36864200e0eaf5284d884a0e77d31646\n   , nonce = 0xbae8e37fc83441b16034566b\n   }\n   == 0xaf60eb711bd85bc1e4d3e0a462e074ee #\n      0xa428a8\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_80 where\n  type Mode = 0\n  type AAD = 80\n\nproperty test18 =\n  AES_GCM_SIV_0_80::aes_gcm_siv\n   { msg = 0xbdc66f146545\n   , aad = 0xfc880c94a95198874296\n   , key = 0xaedb64a6c590bc84d1a5e269e4b47801\n   , nonce = 0xafc0577e34699b9e671fdd4f\n   }\n   == 0xbb93a3e34d3cd6a9c45545cfc11f03ad #\n      0x743dba20f966\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_120 where\n  type Mode = 0\n  type AAD = 120\n\nproperty test19 =\n  AES_GCM_SIV_0_120::aes_gcm_siv\n   { msg = 0x1177441f195495860f\n   , aad = 0x046787f3ea22c127aaf195d1894728\n   , key = 0xd5cc1fd161320b6920ce07787f86743b\n   , nonce = 0x275d1ab32f6d1f0434d8848c\n   }\n   == 0x4f37281f7ad12949d01d02fd0cd174c8 #\n      0x4fc5dae2f60f52fd2b\n\nproperty test20 =\n  AES_GCM_SIV_0_160::aes_gcm_siv\n   { msg = 0x9f572c614b4745914474e7c7\n   , aad = 0xc9882e5386fd9f92ec489c8fde2be2cf #\n           0x97e74e93\n   , key = 0xb3fed1473c528b8426a582995929a149\n   , nonce = 0x9e9ad8780c8d63d0ab4149c0\n   }\n   == 0xf54673c5ddf710c745641c8bc1dc2f87 #\n      0x1fb7561da1286e655e24b7b0\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_200 where\n  type Mode = 0\n  type AAD = 200\n\nproperty test21 =\n  AES_GCM_SIV_0_200::aes_gcm_siv\n   { msg = 0x0d8c8451178082355c9e940fea2f58\n   , aad = 0x2950a70d5a1db2316fd568378da107b5 #\n           0x2b0da55210cc1c1b0a\n   , key = 0x2d4ed87da44102952ef94b02b805249b\n   , nonce = 0xac80e6f61455bfac8308a2d4\n   }\n   == 0xc9ff545e07b88a015f05b274540aa183 #\n           0xb3449b9f39552de99dc214a1190b0b\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_240 where\n  type Mode = 0\n  type AAD = 240\n\nproperty test22 =\n  AES_GCM_SIV_0_240::aes_gcm_siv\n   { msg = 0x6b3db4da3d57aa94842b9803a96e07fb #\n           0x6de7\n   , aad = 0x1860f762ebfbd08284e421702de0de18 #\n           0xbaa9c9596291b08466f37de21c7f\n   , key = 0xbde3b2f204d1e9f8b06bc47f9745b3d1\n   , nonce = 0xae06556fb6aa7890bebc18fe\n   }\n   == 0x6298b296e24e8cc35dce0bed484b7f30 #\n           0xd5803e377094f04709f64d7b985310a4 #\n           0xdb84\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_280 where\n  type Mode = 0\n  type AAD = 280\n\nproperty test23 =\n  AES_GCM_SIV_0_280::aes_gcm_siv\n   { msg = 0xe42a3c02c25b64869e146d7b233987bd #\n           0xdfc240871d\n   , aad = 0x7576f7028ec6eb5ea7e298342a94d4b2 #\n           0x02b370ef9768ec6561c4fe6b7e7296fa #\n           0x859c21\n   , key = 0xf901cfe8a69615a93fdf7a98cad48179\n   , nonce = 0x6245709fb18853f68d833640\n   }\n   == 0x391cc328d484a4f46406181bcd62efd9 #\n      0xb3ee197d052d15506c84a9edd65e13e9 #\n      0xd24a2a6e70\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_0 where\n  type Mode = 1\n  type AAD = 0\n\nproperty test24 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x07f5f4169bbf55a8400cd47ea6fd400f\n\nproperty test25 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x0100000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc2ef328e5c71c83b843122130f7364b7 #\n      0x61e0b97427e3df28\n\nproperty test26 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x010000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x9aab2aeb3faa0a34aea8e2b18ca50da9 #\n      0xae6559e48fd10f6e5c9ca17e\n\nproperty test27 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x85a01b63025ba19b7fd3ddfc033b3e76 #\n      0xc9eac6fa700942702e90862383c6c366\n\nproperty test28 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x4a6a9db4c8c6549201b9edb53006cba8 #\n      0x21ec9cf850948a7c86c68ac7539d027f #\n      0xe819e63abcd020b006a976397632eb5d\n\nproperty test29 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n\n   == 0xc00d121893a9fa603f48ccc1ca3c57ce #\n      0x7499245ea0046db16c53c7c66fe717e3 #\n      0x9cf6c748837b61f6ee3adcee17534ed5 #\n      0x790bc96880a99ba804bd12c0e6a22cc4\n\nproperty test30 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc2d5160a1f8683834910acdafc41fbb1 #\n      0x632d4a353e8b905ec9a5499ac34f96c7 #\n      0xe1049eb080883891a4db8caaa1f99dd0 #\n      0x04d80487540735234e3744512c6f90ce #\n      0x112864c269fc0d9d88c61fa47e39aa08\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_8 where\n  type Mode = 1\n  type AAD = 8\n\nproperty test31 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x0200000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x1de22967237a813291213f267e3b452f #\n      0x02d01ae33e4ec854\n\nproperty test32 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x020000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x163d6f9cc1b346cd453a2e4cc1a4a19a #\n      0xe800941ccdc57cc8413c277f\n\nproperty test33 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc91545823cc24f17dbb0e9e807d5ec17 #\n      0xb292d28ff61189e8e49f3875ef91aff7\n\nproperty test34 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x07dad364bfc2b9da89116d7bef6daaaf #\n      0x6f255510aa654f920ac81b94e8bad365 #\n      0xaea1bad12702e1965604374aab96dbbc\n\nproperty test35 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc67a1f0f567a5198aa1fcc8e3f213143 #\n      0x36f7f51ca8b1af61feac35a86416fa47 #\n      0xfbca3b5f749cdf564527f2314f42fe25 #\n      0x03332742b228c647173616cfd44c54eb\n\nproperty test36 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000 #\n           0x05000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x67fd45e126bfb9a79930c43aad2d3696 #\n      0x7d3f0e4d217c1e551f59727870beefc9 #\n      0x8cb933a8fce9de887b1e40799988db1f #\n      0xc3f91880ed405b2dd298318858467c89 #\n      0x5bde0285037c5de81e5b570a049b62a0\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_96 where\n  type Mode = 1\n  type AAD = 96\n\nproperty test37 =\n  AES_GCM_SIV_1_96::aes_gcm_siv\n   { msg = 0x02000000\n   , aad = 0x010000000000000000000000\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x22b3f4cd1835e517741dfddccfa07fa4 #\n      0x661b74cf\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_144 where\n  type Mode = 1\n  type AAD = 144\n\nproperty test38 =\n  AES_GCM_SIV_1_144::aes_gcm_siv\n   { msg = 0x03000000000000000000000000000000 #\n           0x04000000\n   , aad = 0x01000000000000000000000000000000 #\n           0x0200\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x43dd0163cdb48f9fe3212bf61b201976 #\n      0x067f342bb879ad976d8242acc188ab59 #\n      0xcabfe307\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_160 where\n  type Mode = 1\n  type AAD = 160\n\nproperty test39 =\n  AES_GCM_SIV_1_160::aes_gcm_siv\n   { msg = 0x03000000000000000000000000000000 #\n           0x0400\n   , aad = 0x01000000000000000000000000000000 #\n           0x02000000\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x462401724b5ce6588d5a54aae5375513 #\n      0xa075cfcdf5042112aa29685c912fc205 #\n      0x6543\n\nproperty test40 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0xe66021d5eb8e4f4066d4adb9c33560e4 #\n           0xf46e44bb3da0015c94f7088736864200\n   , nonce = 0xe0eaf5284d884a0e77d31646\n   }\n   == 0x169fbb2fbf389a995f6390af22228a62\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_40 where\n  type Mode = 1\n  type AAD = 40\n\nproperty test41 =\n  AES_GCM_SIV_1_40::aes_gcm_siv\n   { msg = 0x671fdd\n   , aad = 0x4fbdc66f14\n   , key = 0xbae8e37fc83441b16034566b7a806c46 #\n           0xbb91c3c5aedb64a6c590bc84d1a5e269\n   , nonce = 0xe4b47801afc0577e34699b9e\n   }\n   == 0x0eaccb93da9bb81333aee0c785b240d3 #\n      0x19719d\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_80 where\n  type Mode = 1\n  type AAD = 80\n\nproperty test42 =\n  AES_GCM_SIV_1_80::aes_gcm_siv\n   { msg = 0x195495860f04\n   , aad = 0x6787f3ea22c127aaf195\n   , key = 0x6545fc880c94a95198874296d5cc1fd1 #\n           0x61320b6920ce07787f86743b275d1ab3\n   , nonce = 0x2f6d1f0434d8848c1177441f\n   }\n   == 0xa254dad4f3f96b62b84dc40c84636a5e #\n      0xc12020ec8c2c\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_120 where\n  type Mode = 1\n  type AAD = 120\n\nproperty test43 =\n  AES_GCM_SIV_1_120::aes_gcm_siv\n   { msg = 0xc9882e5386fd9f92ec\n   , aad = 0x489c8fde2be2cf97e74e932d4ed87d\n   , key = 0xd1894728b3fed1473c528b8426a58299 #\n           0x5929a1499e9ad8780c8d63d0ab4149c0\n   , nonce = 0x9f572c614b4745914474e7c7\n   }\n   == 0x0df9e308678244c44bc0fd3dc6628dfe #\n      0x55ebb0b9fb2295c8c2\n\nproperty test44 =\n  AES_GCM_SIV_1_160::aes_gcm_siv\n   { msg = 0x1db2316fd568378da107b52b\n   , aad = 0x0da55210cc1c1b0abde3b2f204d1e9f8 #\n           0xb06bc47f\n   , key = 0xa44102952ef94b02b805249bac80e6f6 #\n           0x1455bfac8308a2d40d8c845117808235\n   , nonce = 0x5c9e940fea2f582950a70d5a\n   }\n   == 0x8dbeb9f7255bf5769dd56692404099c2 #\n      0x587f64979f21826706d497d5\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_200 where\n  type Mode = 1\n  type AAD = 200\n\nproperty test45 =\n  AES_GCM_SIV_1_200::aes_gcm_siv\n   { msg = 0x21702de0de18baa9c9596291b08466\n   , aad = 0xf37de21c7ff901cfe8a69615a93fdf7a #\n           0x98cad481796245709f\n   , key = 0x9745b3d1ae06556fb6aa7890bebc18fe #\n           0x6b3db4da3d57aa94842b9803a96e07fb\n   , nonce = 0x6de71860f762ebfbd08284e4\n   }\n   == 0x793576dfa5c0f88729a7ed3c2f1bffb3 #\n      0x080d28f6ebb5d3648ce97bd5ba67fd\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_240 where\n  type Mode = 1\n  type AAD = 240\n\nproperty test46 =\n  AES_GCM_SIV_1_240::aes_gcm_siv\n   { msg = 0xb202b370ef9768ec6561c4fe6b7e7296 #\n           0xfa85\n   , aad = 0x9c2159058b1f0fe91433a5bdc20e214e #\n           0xab7fecef4454a10ef0657df21ac7\n   , key = 0xb18853f68d833640e42a3c02c25b6486 #\n           0x9e146d7b233987bddfc240871d7576f7\n   , nonce = 0x028ec6eb5ea7e298342a94d4\n   }\n   == 0x857e16a64915a787637687db4a951963 #\n      0x5cdd454fc2a154fea91f8363a39fec7d #\n      0x0a49\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_280 where\n  type Mode = 1\n  type AAD = 280\n\nproperty test47 =\n  AES_GCM_SIV_1_280::aes_gcm_siv\n   { msg = 0xced532ce4159b035277d4dfbb7db6296 #\n           0x8b13cd4eec\n   , aad = 0x734320ccc9d9bbbb19cb81b2af4ecbc3 #\n           0xe72834321f7aa0f70b7282b4f33df23f #\n           0x167541\n   , key = 0x3c535de192eaed3822a2fbbe2ca9dfc8 #\n           0x8255e14a661b8aa82cc54236093bbc23\n   , nonce = 0x688089e55540db1872504e1c\n   }\n   == 0x626660c26ea6612fb17ad91e8e767639 #\n      0xedd6c9faee9d6c7029675b89eaf4ba1d #\n      0xed1a286594\n\nproperty test48 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x00000000000000000000000000000000 #\n           0x4db923dc793ee6497c76dcc03a98e108\n   , aad = []\n   , key = 0x00000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x000000000000000000000000\n   }\n   == 0xf3f80f2cf0cb2dd9c5984fcda908456c #\n      0xc537703b5ba70324a6793a7bf218d3ea #\n      0xffffffff000000000000000000000000\n\nproperty test49 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0xeb3640277c7ffd1303c7a542d02d3e4c #\n           0x0000000000000000\n   , aad = []\n   , key = 0x00000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x000000000000000000000000\n   }\n   == 0x18ce4f0b8cb4d0cac65fea8f79257b20 #\n      0x888e53e72299e56dffffffff00000000 #\n      0x0000000000000000\n\nproperty test50 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { msg = 0x01000000000000000000000000000000 #\n            0x02000000000000000000000000000000 #\n            0x03000000000000000000000000000000 #\n            0x04000000000000000000000000000000 #\n            0x05000000000000000000000000000000 #\n            0x06000000000000000000000000000000 #\n            0x07000000000000000000000000000000 #\n            0x08000000000000000000000000000000 #\n            0x09000000000000000000000000000000 #\n            0x0a000000000000000000000000000000 #\n            0x0b000000000000000000000000000000 #\n            0x0c000000000000000000000000000000 #\n            0x0d000000000000000000000000000000 #\n            0x0e000000000000000000000000000000 #\n            0x0f000000000000000000000000000000 #\n            0x10000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , key = 0x01000000000000000000000000000000\n    , aad = []\n    }\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/GCM_AES_Tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named GCM_AES_Tests that contains the following definitions: (1) three parameterized imports of the AES block cipher as AES128, AES192, and AES256, with type parameters set for their respective key sizes; (2) twelve parameterized imports of the GCM construction specialized as GCM_128_96_0_128, GCM_128_96_160_128, GCM_128_64_160_128, GCM_128_480_160_128, GCM_192_96_0_128, GCM_192_96_160_128, GCM_192_64_160_128, GCM_192_480_160_128, GCM_256_96_0_128, GCM_256_96_160_128, GCM_256_64_160_128, and GCM_256_480_160_128, each setting K (128\/192\/256), IV (96\/64\/480), AAD (0 or 160), T = 128, and binding E to the corresponding AESX::encrypt function. Then define properties test1 through test18. Each property must assert that invoking the encrypt function from the appropriate GCM specialization on a fixed record of inputs {key, pt, iv, aad} yields a record {ct, tag} equal to the expected ciphertext and 128-bit authentication tag. Use the exact constants from the vectors in this file, representing multi-block values by bitvector concatenation and empty data as empty sequences. Ensure types match each specialization: key has K bits; iv has IV bits; aad has AAD bits (or is empty when AAD = 0); tag is 128 bits; pt and ct are byte-aligned bitvectors of the specified lengths. The only statements using the property keyword are these 18 assertions of equality. No additional behavior or definitions are required; the module must be directly checkable by a Cryptol solver."},{"role":"assistant","content":"```cryptol\nmodule GCM_AES_Tests where\n\nimport AES as AES128 where\n  type m = 0\n  type k = 128\n\nimport AES as AES192 where\n  type m = 1\n  type k = 192\n\nimport AES as AES256 where\n  type m = 2\n  type k = 256\n\nimport Common::GCM as GCM_128_96_0_128 where\n  type K = 128\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES128::encrypt\n\nproperty test1 =\n  GCM_128_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000\n    , pt  = []\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = []\n  , tag = 0x58e2fccefa7e3061367f1d57a4e7455a\n  }\n\nproperty test2 =\n  GCM_128_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = 0x0388dace60b6a392f328c2b971b2fe78\n  , tag = 0xab6e47d42cec13bdf53a67b21257bddf\n  }\n\nproperty test3 =\n  GCM_128_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct = 0x42831ec2217774244b7221b784d0d49c #\n         0xe3aa212f2c02a4e035c17e2329aca12e #\n         0x21d514b25466931c7d8f6a5aac84aa05 #\n         0x1ba30b396a0aac973d58e091473f5985\n  , tag = 0x4d5c2af327cd64a62cf35abd2ba6fab4\n  }\n\nimport Common::GCM as GCM_128_96_160_128 where\n  type K = 128\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test4 =\n  GCM_128_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct = 0x42831ec2217774244b7221b784d0d49c #\n         0xe3aa212f2c02a4e035c17e2329aca12e #\n         0x21d514b25466931c7d8f6a5aac84aa05 #\n         0x1ba30b396a0aac973d58e091\n  , tag = 0x5bc94fbc3221a5db94fae95ae7121a47\n  }\n\nimport Common::GCM as GCM_128_64_160_128 where\n  type K = 128\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test5 =\n  GCM_128_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbad\n    }\n  ==\n  { ct = 0x61353b4c2806934a777ff51fa22a4755 #\n         0x699b2a714fcdc6f83766e5f97b6c7423 #\n         0x73806900e49f24b22b097544d4896b42 #\n         0x4989b5e1ebac0f07c23f4598\n  , tag = 0x3612d2e79e3b0785561be14aaca2fccb\n  }\n\nimport Common::GCM as GCM_128_480_160_128 where\n  type K = 128\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test6 =\n  GCM_128_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0x9313225df88406e555909c5aff5269aa #\n            0x6a7a9538534f7da1e4c303d2a318a728 #\n            0xc3c0c95156809539fcf0e2429a6b5254 #\n            0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct = 0x8ce24998625615b603a033aca13fb894 #\n         0xbe9112a5c3a211a8ba262a3cca7e2ca7 #\n         0x01e4a9a4fba43c90ccdcb281d48c7c6f #\n         0xd62875d2aca417034c34aee5\n  , tag = 0x619cc5aefffe0bfa462af43c1699d050\n  }\n\nimport Common::GCM as GCM_192_96_0_128 where\n  type K = 192\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES192::encrypt\n\nproperty test7 =\n  GCM_192_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x0000000000000000\n    , pt  = []\n    , aad = []\n    , iv  = 0x000000000000000000000000\n    }\n  ==\n  { ct = []\n  , tag = 0xcd33b28ac773f74ba00ed1f312572435\n  }\n\nproperty test8 =\n  GCM_192_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x0000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct = 0x98e7247c07f0fe411c267e4384b0f600\n  , tag = 0x2ff58d80033927ab8ef4d4587514f0fb\n  }\n\nproperty test9 =\n  GCM_192_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv  = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct =  0x3980ca0b3c00e841eb06fac4872a2757 #\n          0x859e1ceaa6efd984628593b40ca1e19c #\n          0x7d773d00c144c525ac619d18c84a3f47 #\n          0x18e2448b2fe324d9ccda2710acade256\n  , tag = 0x9924a7c8587336bfb118024db8674a14\n  }\n\nimport Common::GCM as GCM_192_96_160_128 where\n  type K = 192\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test10 =\n  GCM_192_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct  = 0x3980ca0b3c00e841eb06fac4872a2757 #\n          0x859e1ceaa6efd984628593b40ca1e19c #\n          0x7d773d00c144c525ac619d18c84a3f47 #\n          0x18e2448b2fe324d9ccda2710\n  , tag = 0x2519498e80f1478f37ba55bd6d27618c\n  }\n\nimport Common::GCM as GCM_192_64_160_128 where\n  type K = 192\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test11 =\n  GCM_192_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbad\n    }\n  ==\n  { ct  = 0x0f10f599ae14a154ed24b36e25324db8 #\n          0xc566632ef2bbb34f8347280fc4507057 #\n          0xfddc29df9a471f75c66541d4d4dad1c9 #\n          0xe93a19a58e8b473fa0f062f7\n  , tag = 0x65dcc57fcf623a24094fcca40d3533f8\n  }\n\nimport Common::GCM as GCM_192_480_160_128 where\n  type K = 192\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test12 =\n  GCM_192_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0x9313225df88406e555909c5aff5269aa #\n            0x6a7a9538534f7da1e4c303d2a318a728 #\n            0xc3c0c95156809539fcf0e2429a6b5254 #\n            0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct  = 0xd27e88681ce3243c4830165a8fdcf9ff #\n          0x1de9a1d8e6b447ef6ef7b79828666e45 #\n          0x81e79012af34ddd9e2f037589b292db3 #\n          0xe67c036745fa22e7e9b7373b\n  , tag = 0xdcf566ff291c25bbb8568fc3d376a6d9\n  }\n\nimport Common::GCM as GCM_256_96_0_128 where\n  type K = 256\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES256::encrypt\n\nproperty test13 =\n  GCM_256_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x00000000000000000000000000000000\n    , pt  = []\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = []\n  , tag = 0x530f8afbc74536b9a963b4f1c4cb738b\n  }\n\nproperty test14 =\n  GCM_256_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x00000000000000000000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = 0xcea7403d4d606b6e074ec5d3baf39d18\n  , tag = 0xd0d1c8a799996bf0265b98b5d48ab919\n  }\n\nproperty test15 =\n  GCM_256_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct  = 0x522dc1f099567d07f47f37a32a84427d #\n          0x643a8cdcbfe5c0c97598a2bd2555d1aa #\n          0x8cb08e48590dbb3da7b08b1056828838 #\n          0xc5f61e6393ba7a0abcc9f662898015ad\n  , tag = 0xb094dac5d93471bdec1a502270e3cc6c\n  }\n\nimport Common::GCM as GCM_256_96_160_128 where\n  type K = 256\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test16 =\n  GCM_256_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct  = 0x522dc1f099567d07f47f37a32a84427d #\n          0x643a8cdcbfe5c0c97598a2bd2555d1aa #\n          0x8cb08e48590dbb3da7b08b1056828838 #\n          0xc5f61e6393ba7a0abcc9f662\n  , tag = 0x76fc6ece0f4e1768cddf8853bb2d551b\n  }\n\nimport Common::GCM as GCM_256_64_160_128 where\n  type K = 256\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test17 =\n  GCM_256_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0xcafebabefacedbad\n    }\n  ==\n  { ct  = 0xc3762df1ca787d32ae47c13bf19844cb #\n          0xaf1ae14d0b976afac52ff7d79bba9de0 #\n          0xfeb582d33934a4f0954cc2363bc73f78 #\n          0x62ac430e64abe499f47c9b1f\n  , tag = 0x3a337dbf46a792c45e454913fe2ea8f2\n  }\n\nimport Common::GCM as GCM_256_480_160_128 where\n  type K = 256\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test18 =\n  GCM_256_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0x9313225df88406e555909c5aff5269aa #\n           0x6a7a9538534f7da1e4c303d2a318a728 #\n           0xc3c0c95156809539fcf0e2429a6b5254 #\n           0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct  = 0x5a8def2f0c9e53f1f75d7853659e2a20 #\n          0xeeb2b22aafde6419a058ab4f6f746bf4 #\n          0x0fc0c3b780f244452da3ebf1c5d82cde #\n          0xa2418997200ef82e44ae7e3f\n  , tag = 0xa44a8266ee1c8eb0c8b5d4cf5ae9f19a\n  }\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/SHA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named SHA that contains the following definitions: (1) Import the SHA256 module using the alias SHA256. (2) Define a function sha256 with a polymorphic size parameter n, constrained so that 64 is at least the bit-width of n, with type [n] -> [256]; implement it by delegating to the SHA function provided by the SHA256 module. (3) Define a helper function go with a polymorphic size parameter n, constrained so that 64 is at least the bit-width of 8*n, with type [n][8] -> [256]; it must join a sequence of bytes into a single bitvector and pass it to sha256. (4) Define a list sha256tests containing tuples (computed, expected), where computed is the result of go applied to several standard ASCII byte-sequence inputs, and expected is the corresponding 256-bit known-answer constant for each input. Include three classic SHA-256 known-answer cases. (5) Define a property katsPass that asserts all known-answer tests pass by constructing a vector of equality checks between each computed and expected digest from sha256tests, and asserting that this Boolean vector equals an all-ones vector of matching length (i.e., every comparison is True). Ensure all types, size constraints, and polymorphism match these requirements, and use only the described names for the definitions."},{"role":"assistant","content":"```cryptol\nmodule SHA where\n\nimport SHA256 as SHA256\n\nsha256 : {n} (64 >= width n) => [n] -> [256]\nsha256 = SHA256::sha\n\nproperty katsPass = ~zero == [test == kat | (test,kat) <- sha256tests ]\n\nsha256tests =\n  [ (go \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    ,   0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1\n    )\n\n  , (go \"\"\n    ,   0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n    )\n\n    , (go \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n      , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1\n      )\n\n    ]\n\n  where\n  go : {n} (64 >= width (8 * n)) => [n][8] -> [256]\n  go x = sha256 (join x)\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/SCrypt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named SCrypt that contains the following definitions: (1) Import the Salsa20 core and PBKDF2 components used by scrypt. (2) A function BlockMix parameterized by r with constraints that r is finite and r >= 1; its type maps a sequence of 2*r blocks, each 64 bytes (as bits), to a sequence of 2*r blocks; implement the scrypt block-mixing step using the Salsa20\/8 core, maintaining a rolling XOR state initialized from the first block, then output the blocks permuted with all even-indexed blocks followed by all odd-indexed blocks. (3) A function SMix parameterized by N and r with constraints N >= 1, r >= 1, and bit-width bounds sufficient for indexing and arithmetic on N; its type maps a 128*r-byte block (as bits) to a 128*r-byte block; allocate a table V of N states, iterate N times saving states and applying BlockMix, then iterate another N times where each step computes j from the first 64-byte sub-block (interpret as an integer modulo N), XORs the current state with V[j], applies BlockMix, and finally returns the resulting block. (4) A function MFcrypt parameterized by pwBytes, saltBytes, dkLen, r, N with finiteness\/width constraints for lengths and N; it takes a password (pwBytes bytes) and salt (saltBytes bytes) and returns a derived key of dkLen bytes by: first PBKDF2-HMAC with C=1 to produce B, applying SMix with parameters N and r to B, then PBKDF2-HMAC with C=1 to produce the dkLen-bit output using the SMix result as salt. (5) A function SCrypt with the same parameters as MFcrypt that simply delegates to MFcrypt. (6) A property named kats_pass that asserts the SCrypt result for N = 2^4, r = 1, empty password, and empty salt equals the standard 64-byte scrypt test vector for those parameters."},{"role":"assistant","content":"```cryptol\nmodule SCrypt where\n\nimport Salsa20\nimport PBKDF2\n\nBlockMix : {r} (fin r, r >= 1) =>  [2*r][64*8] -> [2*r][64*8]\nBlockMix B = ys @@ ([0,2..2*r-2] # [1,3..2*r-1])\n where\n  rs = [B!0] # [ join (Salsa20 `{r=8} (split (X ^ bi))) | X <- rs | bi <- B ]\n  ys = drop `{1} rs\n\nSMix : {N,r} ( fin r\n             , r >= 1\n             , N >= 1\n             , 512 >= width N\n             , 1 + width N >= width (N-1)\n             ) => [128 * 8 * r] -> [128 * 8 * r]\nSMix B = join (Xs ! 0)\n where\n  Vs = [split B] # [ BlockMix x | x <- Vs | _ <- [0..N-1] : [_][width N + 1]]\n  V  = take `{front=N} Vs\n\n  Xs : [N+1][2*r][64*8]\n  Xs = [Vs!0]    # [ (x' where\n                            j  = integerify x\n                            T  = x ^ (V@j)\n                            x' = BlockMix T)\n                        | x <- Xs | _ <- [0..N-1] : [_][width N + 1] ]\n\n  integerify w = (join (reverse (split `{each=8} (w!0)))) % `N\n\nMFcrypt : { pwBytes, saltBytes, dkLen, r, N }\n          ( fin dkLen\n          , 4*r >= 1\n          , 8 * dkLen >= 1\n          , 64 >= width (8 * pwBytes)\n          , 32 >= width (4 + saltBytes)\n          ,  512 >= width N, 1+width N >= width (N-1)\n          , 32 >= width ((255 + 8 * dkLen) \/ 256)\n          , 32 >= width (4 + 128 * r)\n          , N >= 1\n          )\n        => [pwBytes][8] -> [saltBytes][8] -> [dkLen][8]\nMFcrypt P S = split DK\n where\n  B  = pbkdf2 `{C=1} P S\n  B' = SMix `{N=N,r=r} B\n  DK = pbkdf2 `{dkLenBits=dkLen*8, C=1} P (split B')\n\nSCrypt : {pwBytes, saltBytes, dkBytes, r, N}\n         ( fin dkBytes, 4*r >= 1\n         , 8 * dkBytes >= 1\n         , 32 >= width ((255 + 8 * dkBytes) \/ 256)\n         , 64 >= width (8 * pwBytes)\n         , 512 >= width N, 1+width N >= width (N-1)\n         , 32 >= width (4 + saltBytes)\n         , 32 >= width (4 + 128 * r)\n         , N >= 1\n         )\n      => [pwBytes][8] -> [saltBytes][8] -> [dkBytes][8]\nSCrypt P S = MFcrypt `{r=r,N=N} P S\n\nproperty kats_pass = ~zero ==\n    [ SCrypt `{N=2^^4,r=1} \"\" \"\" ==\n            [ 0x77, 0xd6, 0x57, 0x62, 0x38, 0x65, 0x7b, 0x20\n            , 0x3b, 0x19, 0xca, 0x42, 0xc1, 0x8a, 0x04, 0x97\n            , 0xf1, 0x6b, 0x48, 0x44, 0xe3, 0x07, 0x4a, 0xe8\n            , 0xdf, 0xdf, 0xfa, 0x3f, 0xed, 0xe2, 0x14, 0x42\n            , 0xfc, 0xd0, 0x06, 0x9d, 0xed, 0x09, 0x48, 0xf8\n            , 0x32, 0x6a, 0x75, 0x3a, 0x0f, 0xc8, 0x1f, 0x17\n            , 0xe8, 0xd3, 0xe0, 0xfb, 0x2e, 0x0d, 0x36, 0x28\n            , 0xcf, 0x35, 0xe2, 0x0c, 0x38, 0xd1, 0x89, 0x06\n            ]\n    ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named SHA256 that contains the following definitions: (1) Ch and Maj, each taking three 32-bit words and returning a 32-bit word using bitwise logic. (2) Two \u201cbig sigma\u201d functions over 32-bit words that XOR several right-rotations, and two \u201csmall sigma\u201d functions that XOR right-rotations with logical right shifts. (3) A constant table K of 64 fixed 32-bit words (the standard SHA-256 round constants). (4) A polymorphic preprocess function over a bitvector of length msgLen with constraints that msgLen is finite and its width fits in 64 bits; it must append a single \u20181\u2019 bit, pad with zeros to reach length congruent to 448 mod 512, append the 64-bit big-endian original length, then split into 512-bit blocks. (5) An initial hash state H0 as eight fixed 32-bit words. (6) A message schedule function that maps 16 32-bit words to 64 32-bit words using the standard recursive combination with the small-sigma functions and prior words. (7) A compression function that takes an 8-word state and a 64-word schedule, computes 64 rounds using T1 and T2 derived from the big-sigma, choice, and majority functions, and returns the updated 8-word state by adding the working variables back into the input state. (8) A chaining function over a finite sequence of 512-bit blocks (expressed as arrays of 16 32-bit words) that iteratively applies the compression starting from H0. (9) A top-level function that accepts a finite sequence of bytes and returns a 256-bit digest, by preprocessing, scheduling, compressing, and joining the final state. Include kats, a list of (computed, expected) digest pairs for standard messages using the implemented hash. Define a property katsPass that asserts each computed digest equals its expected value for all pairs in kats."},{"role":"assistant","content":"```cryptol\nmodule SHA256 where\n\nCh : [32] -> [32] -> [32] -> [32]\nCh x y z = (x && y) ^ (~x && z)\n\nMaj : [32] -> [32] -> [32] -> [32]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nS0 : [32] -> [32]\nS0 x = (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)\n\nS1 : [32] -> [32]\nS1 x = (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)\n\ns0 : [32] -> [32]\ns0 x = (x >>> 7) ^ (x >>> 18) ^ (x >> 3)\n\ns1 : [32] -> [32]\ns1 x = (x >>> 17) ^ (x >>> 19) ^ (x >> 10)\n\nK : [64][32]\nK = [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n     ]\n\npreprocess : {msgLen}\n     ( fin msgLen\n     , 64 >= width msgLen                                   )\n     => [msgLen] -> [(msgLen + 65) \/^ 512][512]\npreprocess msg = split (msg # [True] # (zero:[(msgLen + 65) %^ 512]) # (`msgLen:[64]))\n\nH0 : [8][32]\nH0 = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n       0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]\n\nSHA256MessageSchedule : [16][32] -> [64][32]\nSHA256MessageSchedule M = W where\n    W = M # [ s1 (W@(j-2)) + (W@(j-7)) + s0 (W@(j-15)) + (W@(j-16)) | j <- [16 .. 63]:[_][8] ]\n\nSHA256Compress : [8][32] -> [64][32] -> [8][32]\nSHA256Compress H W = [as!0 + H@0, bs!0 + H@1, cs!0 + H@2, ds!0 + H@3, es!0 + H@4, fs!0 + H@5, gs!0 + H@6, hs!0 + H@7] where\n    T1 = [h + S1 e + Ch e f g  + k + w | h <- hs | e <- es | f <- fs | g <- gs | k <- K | w <- W]\n    T2 = [S0 a  + Maj a b c  | a <- as | b <- bs | c <- cs]\n    hs = take `{65} ([H@7] # gs)\n    gs = take `{65} ([H@6] # fs)\n    fs = take `{65} ([H@5] # es)\n    es = take `{65} ([H@4] # [d + t1 | d <- ds | t1 <- T1])\n    ds = take `{65} ([H@3] # cs)\n    cs = take `{65} ([H@2] # bs)\n    bs = take `{65} ([H@1] # as)\n    as = take `{65} ([H@0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\nSHA256' : {a} (fin a) => [a][16][32] -> [8][32]\nSHA256' blocks = hash!0 where\n    hash = [H0] # [SHA256Compress h (SHA256MessageSchedule b) | h <- hash | b <- blocks]\n\nSHA256 : {a} (fin a, 64 >= width (8*a)) => [a][8] -> [256]\nSHA256 msg = join (SHA256' [ split x | x <- preprocess(join msg)])\n\nproperty katsPass = ~zero == [test == kat | (test,kat) <- kats ]\n\nkats = [ (SHA256 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n         , 0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1)\n       , (SHA256 \"\"\n         ,0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855)\n       , (SHA256 \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n         , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1)\n       \/\/ , (SHA256 [0x61 | i <- [1..1000000] : [_][32]]\n       \/\/   , 0xcdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0)\n       ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/HMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named HMAC that imports the SHA256 module and contains the following definitions: (1) A polymorphic function hmac with type parameters for message length, key length, digest size, and block size, all finite. It takes three hash functions whose domains\/codomains enforce: (a) inner: blockSize+message bytes -> digest*8 bits, (b) outer: blockSize+digest bytes -> digest*8 bits, (c) key-hash: key bytes -> digest*8 bits; plus a key (bytes) and a message (bytes); and returns a digest-sized bitvector. Implement standard HMAC: if the key is longer than the block size, hash it to digest bytes; otherwise use it directly; zero-pad to block size; XOR with 0x36 to form the inner pad and with 0x5c to form the outer pad; compute inner = innerHash(innerPad || message); convert the inner hash to a byte sequence as needed; compute and return outerHash(outerPad || inner). (2) A function hmacSHA256 specialized to SHA-256 with block size 64 bytes and digest 32 bytes, mapping a byte-array key and byte-array message to a 256-bit result. Constrain message and key sizes to be finite, with the message-length width at most 32 and the bit-width of the key length at most 64. (3) A property named pass that asserts two HMAC-SHA256 test vectors evaluate to their known digests: one using a 20-byte key of 0x0b with the message \"Hi There\", and one using the key \"Jefe\" with the message \"what do ya want for nothing?\". The property succeeds only if both equalities hold."},{"role":"assistant","content":"```cryptol\nmodule HMAC where\n\nimport SHA256\n\nhmacSHA256 : {pwBytes, msgBytes}\n             (fin pwBytes, fin msgBytes\n             , 32 >= width msgBytes\n             , 64 >= width (8*pwBytes)\n             ) => [pwBytes][8] -> [msgBytes][8] -> [256]\nhmacSHA256 = hmac `{blockLength=64} SHA256 SHA256 SHA256\n\nhmac : { msgBytes, pwBytes, digest, blockLength }\n       ( fin pwBytes, fin digest, fin blockLength\n       )\n    => ([blockLength + msgBytes][8] -> [8*digest])\n    -> ([blockLength + digest][8] -> [8*digest])\n    -> ([pwBytes][8] -> [8*digest])\n    -> [pwBytes][8]\n    -> [msgBytes][8]\n    -> [digest*8]\nhmac hash hash2 hash3 key message = hash2 (okey # internal)\n where\n ks : [blockLength][8]\n ks   = if `pwBytes > (`blockLength : [max (width pwBytes) (width blockLength)])\n            then take `{blockLength} (split (hash3 key) # (zero : [blockLength][8]))\n            else take `{blockLength} (key # (zero : [blockLength][8]))\n okey = [k ^ 0x5C | k <- ks]\n ikey = [k ^ 0x36 | k <- ks]\n internal = split (hash (ikey # message))\n\nproperty pass =\n    ~zero ==\n    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] \"Hi There\" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\n    , hmacSHA256 \"Jefe\" \"what do ya want for nothing?\" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\n    ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Blake2s.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines a module named Blake2s that contains the following: (1) type synonyms for a 16-word 32-bit message block, an 8-word 32-bit chaining state, a 16-word 32-bit local state, a 64-bit byte counter, and a record context with state and counter; (2) a 64-bit constant equal to the block size in bytes; (3) the 8-word 32-bit initialization vector constant; (4) the 10-round message permutation table as a matrix of 4-bit indices; (5) four rotation-distance constants used by the mixing function; (6) a mixing function that updates four chosen lanes of a 16-word local state using additions, xors, fixed right-rotations by those constants, and message words selected via the round index and the permutation table; (7) a helper that computes one invocation of the mixer on the four lanes; (8) a compression function that initializes the 16-word working vector from the chaining state, IV, counter split into two 32-bit words, and a final-block flag, then iterates 10 rounds using a specified sequence of column and diagonal index groups, and returns the new chaining state by xoring halves of the final working vector; (9) a round function that applies eight mixes over the prescribed index groups; (10) a top-level hash function parameterized by message length and output length with constraints that the output length is at most 32 bytes and the message length bit-width fits in 64, returning output-length bytes; (11) a helper that handles padding, splits full and final partial blocks, initializes context with parameter block including output length, iterates compression over full blocks updating the counter by 64 bytes each time, and finalizes with the last block and final flag; (12) utilities to build blocks from bytes, reverse byte order of words, split\/join bytes, and update a vector element by index with necessary numeric constraints; (13) a property katsPass that asserts the hash of byte sequences of lengths 0..255 equals a provided table of 256 expected 32-byte digests, using helpers that generate each input and compare to the table."},{"role":"assistant","content":"```cryptol\nmodule Blake2s where\n\ntype Block   = [16][32]\ntype State   = [8][32]\ntype LocalState = [16][32]\ntype BCounter = [64]\n\ntype Context = { state : State, counter : BCounter }\n\nbbVal : [64]\nbbVal = 64\n\nIV : [8][32]\nIV = [ 0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,\n       0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\n     ]\n\nSIGMA_TABLE : [10][16][4]\nSIGMA_TABLE =\n    [  [  0, 1,   2, 3,   4, 5,   6, 7,   8, 9,  10, 11, 12, 13, 14, 15 ]\n    ,  [ 14, 10,  4, 8,   9, 15, 13, 6,   1, 12,  0, 2,  11, 7,   5, 3  ]\n    ,  [ 11, 8,  12, 0,   5, 2,  15, 13, 10, 14,  3, 6,   7, 1,   9, 4  ]\n    ,  [  7, 9,   3, 1,  13, 12, 11, 14,  2, 6,   5, 10,  4, 0,  15, 8  ]\n    ,  [  9, 0,   5, 7,   2, 4,  10, 15, 14, 1,  11, 12,  6, 8,   3, 13 ]\n    ,  [  2, 12,  6, 10,  0, 11,  8, 3,   4, 13,  7, 5,  15, 14,  1, 9  ]\n    ,  [ 12, 5,   1, 15, 14, 13,  4, 10,  0, 7,   6, 3,   9, 2,   8, 11 ]\n    ,  [ 13, 11,  7, 14, 12, 1,   3, 9,   5, 0,  15, 4,   8, 6,   2, 10 ]\n    ,  [  6, 15, 14, 9,  11, 3,   0, 8,  12, 2,  13, 7,   1, 4,  10, 5  ]\n    ,  [ 10, 2,   8, 4,   7, 6,   1, 5,  15, 11,  9, 14,  3, 12, 13, 0  ]\n    ]\n\nR1,R2,R3,R4 : [6]\nR1 = 16\nR2 = 12\nR3 = 08\nR4 = 07\n\nG : [4] -> [4] -> LocalState -> [4][6] -> Block -> [16][32]\nG r i vec abcd ms = foldl updateVector vec (zip abcd new)\n  where\n  new  = G' r i (vec @@ abcd) ms\n\nG' : [4] -> [4] -> [4][32] -> Block -> [4][32]\nG' r i vals ms = [a2, b2, c2, d2]\n  where\n  x = ms @ (SIGMA_TABLE @ r @ (2*i))\n  y = ms @ (SIGMA_TABLE @ r @ (2*i+1))\n  [a,b,c,d] = vals\n  a1 =  a + b + x\n  d1 = (d ^ a1) >>> R1\n  c1 =  c + d1\n  b1 = (b ^ c1) >>> R2\n  a2 =  a1 + b1 + y\n  d2 = (d1 ^ a2) >>> R3\n  c2 =  c1 + d2\n  b2 = (b1 ^ c2) >>> R4\n\n\/\/ Section 3.2: Compression function\nF : State -> Block -> BCounter -> Bit -> State\nF h ms t f =  h ^ (take (vs!0)) ^ (drop (vs!0))\n where\n  v   = h # IV ^ (zero # [t0,t1,f0,zero])\n  [t1,t0] = split t      : [2][32]\n  f0 = [f | _ <- [0..31] : [_][6]]\n  vs = [v] # [ round i ms v' | v' <- vs | i <- [0..9] ]\n\n\/\/ Sub-function of F (first for loop)\nround : [4] -> Block -> LocalState -> LocalState\nround r ms v = vs ! 0\n  where\n  vs = [v] # [ G r i v' ix ms\n                | v'   <- vs\n                | i    <- [0..7]\n                | ix   <- [ [0,4,8,12],  [1,5,9,13]\n                          , [2,6,10,14], [3,7,11,15]\n                          , [0,5,10,15], [1,6,11,12]\n                          , [2,7,8,13],  [3,4,9,14] ]\n              ]\n\n\/\/ Section 3.3: Padding\n\/\/ Recall kk == key bytes  (0)\n\/\/        nn == hash bytes (32)\n\/\/        ll == input bytes (ceiling $ len \/ 8)\n\/\/        bb == block bytes (64, 1024 bits)\n\/\/        dd == nr Blocks\n\nblake2s : {ll,nn} (fin ll, 32 >= nn, 64 >= width ll)\n      => [ll][8] -> [nn*8]\nblake2s m = blake2s' `{ll=ll,nn=nn} m\n\nblake2s' : {ll,dd,nn}\n         (fin ll\n         , 32  >= nn\n         , dd  == (max 1 ((ll+63)\/64)) - 1\n         , 64 >= width ll\n         )\n          => [ll][8]\n          -> [nn*8]\nblake2s' m = take `{nn*8} (blake2sFinish ({ state = (hs!0).state, counter = `ll}) lastBlock)\n where\n\n fullBlocks : [dd]Block\n fullBlocks = [mkBlock b | b <- split (join (take  `{front=64*dd,back=ll-64*dd} m))]\n\n partialBlock = drop `{front=64*dd,back=ll-64*dd} m\n\n lastBlock : Block\n lastBlock  =\n    if (`ll == (zero:[64]))\n        then zero         else mkBlock ((split (join (partialBlock # (zero : [inf][8]))))@0)\n\n h : Context\n h  = { state = [IV@0 ^ `0x01010000 ^ `nn] # drop `{1} IV, counter = 0 }\n\n hs : [dd+1]Context\n hs = [h] # [blake2Update h' dX |  h' <- hs | dX <- fullBlocks]\n\nblake2Update : Context -> Block -> Context\nblake2Update ctx d = { state = newState, counter = newCount }\n  where newState = F ctx.state d newCount False\n        newCount = ctx.counter + (64 : [64])\n\npostprocess : {ll} (64 >= ll, 64 >= width ll) => BCounter -> [ll][8] -> Block\npostprocess c m =\n    if c == 0 \/\\ `ll == (zero:[64])\n        then zero\n        else split (join m # zero)\n\nblake2sFinish : Context -> Block -> [256]\nblake2sFinish ctx b = join [ reverseBytes w | w <- F ctx.state b ctx.counter True ]\n\nmkBlock x = reverse (split (reverseBytes x))\n\nreverseBytes x = join (reverse (bytes x))\n\nbytes x = split x : [_] [8]\n\nupdateVector : {a, b, c} (c >= width (a-1), a >= 1, fin a, fin c) => [a]b -> ([c], b) -> [a]b\nupdateVector orig idxNew = vs\n where\n idx = idxNew.0\n new = idxNew.1\n vs = [if i == idx then new else orig@i | i <- [0..a-1]]\n\nproperty katsPass = ~zero ==\n                        [ nthKat `{0}\n                        , nthKat `{1}\n                        , nthKat `{2}\n                        , nthKat `{3}\n                        , nthKat `{4}\n                        , nthKat `{5}\n                        , nthKat `{6}\n                        , nthKat `{7}\n                        , nthKat `{8}\n                        , nthKat `{9}\n                        , nthKat `{10}\n                        , nthKat `{11}\n                        , nthKat `{12}\n                        , nthKat `{13}\n                        , nthKat `{14}\n                        , nthKat `{15}\n                        , nthKat `{16}\n                        , nthKat `{17}\n                        , nthKat `{18}\n                        , nthKat `{19}\n                        , nthKat `{20}\n                        , nthKat `{21}\n                        , nthKat `{22}\n                        , nthKat `{23}\n                        , nthKat `{24}\n                        , nthKat `{25}\n                        , nthKat `{26}\n                        , nthKat `{27}\n                        , nthKat `{28}\n                        , nthKat `{29}\n                        , nthKat `{30}\n                        , nthKat `{31}\n                        , nthKat `{32}\n                        , nthKat `{33}\n                        , nthKat `{34}\n                        , nthKat `{35}\n                        , nthKat `{36}\n                        , nthKat `{37}\n                        , nthKat `{38}\n                        , nthKat `{39}\n                        , nthKat `{40}\n                        , nthKat `{41}\n                        , nthKat `{42}\n                        , nthKat `{43}\n                        , nthKat `{44}\n                        , nthKat `{45}\n                        , nthKat `{46}\n                        , nthKat `{47}\n                        , nthKat `{48}\n                        , nthKat `{49}\n                        , nthKat `{50}\n                        , nthKat `{51}\n                        , nthKat `{52}\n                        , nthKat `{53}\n                        , nthKat `{54}\n                        , nthKat `{55}\n                        , nthKat `{56}\n                        , nthKat `{57}\n                        , nthKat `{58}\n                        , nthKat `{59}\n                        , nthKat `{60}\n                        , nthKat `{61}\n                        , nthKat `{62}\n                        , nthKat `{63}\n                        , nthKat `{64}\n                        , nthKat `{65}\n                        , nthKat `{66}\n                        , nthKat `{67}\n                        , nthKat `{68}\n                        , nthKat `{69}\n                        , nthKat `{70}\n                        , nthKat `{71}\n                        , nthKat `{72}\n                        , nthKat `{73}\n                        , nthKat `{74}\n                        , nthKat `{75}\n                        , nthKat `{76}\n                        , nthKat `{77}\n                        , nthKat `{78}\n                        , nthKat `{79}\n                        , nthKat `{80}\n                        , nthKat `{81}\n                        , nthKat `{82}\n                        , nthKat `{83}\n                        , nthKat `{84}\n                        , nthKat `{85}\n                        , nthKat `{86}\n                        , nthKat `{87}\n                        , nthKat `{88}\n                        , nthKat `{89}\n                        , nthKat `{90}\n                        , nthKat `{91}\n                        , nthKat `{92}\n                        , nthKat `{93}\n                        , nthKat `{94}\n                        , nthKat `{95}\n                        , nthKat `{96}\n                        , nthKat `{97}\n                        , nthKat `{98}\n                        , nthKat `{99}\n                        , nthKat `{100}\n                        , nthKat `{101}\n                        , nthKat `{102}\n                        , nthKat `{103}\n                        , nthKat `{104}\n                        , nthKat `{105}\n                        , nthKat `{106}\n                        , nthKat `{107}\n                        , nthKat `{108}\n                        , nthKat `{109}\n                        , nthKat `{110}\n                        , nthKat `{111}\n                        , nthKat `{112}\n                        , nthKat `{113}\n                        , nthKat `{114}\n                        , nthKat `{115}\n                        , nthKat `{116}\n                        , nthKat `{117}\n                        , nthKat `{118}\n                        , nthKat `{119}\n                        , nthKat `{120}\n                        , nthKat `{121}\n                        , nthKat `{122}\n                        , nthKat `{123}\n                        , nthKat `{124}\n                        , nthKat `{125}\n                        , nthKat `{126}\n                        , nthKat `{127}\n                        , nthKat `{128}\n                        , nthKat `{129}\n                        , nthKat `{130}\n                        , nthKat `{131}\n                        , nthKat `{132}\n                        , nthKat `{133}\n                        , nthKat `{134}\n                        , nthKat `{135}\n                        , nthKat `{136}\n                        , nthKat `{137}\n                        , nthKat `{138}\n                        , nthKat `{139}\n                        , nthKat `{140}\n                        , nthKat `{141}\n                        , nthKat `{142}\n                        , nthKat `{143}\n                        , nthKat `{144}\n                        , nthKat `{145}\n                        , nthKat `{146}\n                        , nthKat `{147}\n                        , nthKat `{148}\n                        , nthKat `{149}\n                        , nthKat `{150}\n                        , nthKat `{151}\n                        , nthKat `{152}\n                        , nthKat `{153}\n                        , nthKat `{154}\n                        , nthKat `{155}\n                        , nthKat `{156}\n                        , nthKat `{157}\n                        , nthKat `{158}\n                        , nthKat `{159}\n                        , nthKat `{160}\n                        , nthKat `{161}\n                        , nthKat `{162}\n                        , nthKat `{163}\n                        , nthKat `{164}\n                        , nthKat `{165}\n                        , nthKat `{166}\n                        , nthKat `{167}\n                        , nthKat `{168}\n                        , nthKat `{169}\n                        , nthKat `{170}\n                        , nthKat `{171}\n                        , nthKat `{172}\n                        , nthKat `{173}\n                        , nthKat `{174}\n                        , nthKat `{175}\n                        , nthKat `{176}\n                        , nthKat `{177}\n                        , nthKat `{178}\n                        , nthKat `{179}\n                        , nthKat `{180}\n                        , nthKat `{181}\n                        , nthKat `{182}\n                        , nthKat `{183}\n                        , nthKat `{184}\n                        , nthKat `{185}\n                        , nthKat `{186}\n                        , nthKat `{187}\n                        , nthKat `{188}\n                        , nthKat `{189}\n                        , nthKat `{190}\n                        , nthKat `{191}\n                        , nthKat `{192}\n                        , nthKat `{193}\n                        , nthKat `{194}\n                        , nthKat `{195}\n                        , nthKat `{196}\n                        , nthKat `{197}\n                        , nthKat `{198}\n                        , nthKat `{199}\n                        , nthKat `{200}\n                        , nthKat `{201}\n                        , nthKat `{202}\n                        , nthKat `{203}\n                        , nthKat `{204}\n                        , nthKat `{205}\n                        , nthKat `{206}\n                        , nthKat `{207}\n                        , nthKat `{208}\n                        , nthKat `{209}\n                        , nthKat `{210}\n                        , nthKat `{211}\n                        , nthKat `{212}\n                        , nthKat `{213}\n                        , nthKat `{214}\n                        , nthKat `{215}\n                        , nthKat `{216}\n                        , nthKat `{217}\n                        , nthKat `{218}\n                        , nthKat `{219}\n                        , nthKat `{220}\n                        , nthKat `{221}\n                        , nthKat `{222}\n                        , nthKat `{223}\n                        , nthKat `{224}\n                        , nthKat `{225}\n                        , nthKat `{226}\n                        , nthKat `{227}\n                        , nthKat `{228}\n                        , nthKat `{229}\n                        , nthKat `{230}\n                        , nthKat `{231}\n                        , nthKat `{232}\n                        , nthKat `{233}\n                        , nthKat `{234}\n                        , nthKat `{235}\n                        , nthKat `{236}\n                        , nthKat `{237}\n                        , nthKat `{238}\n                        , nthKat `{239}\n                        , nthKat `{240}\n                        , nthKat `{241}\n                        , nthKat `{242}\n                        , nthKat `{243}\n                        , nthKat `{244}\n                        , nthKat `{245}\n                        , nthKat `{246}\n                        , nthKat `{247}\n                        , nthKat `{248}\n                        , nthKat `{249}\n                        , nthKat `{250}\n                        , nthKat `{251}\n                        , nthKat `{252}\n                        , nthKat `{253}\n                        , nthKat `{254}\n                        , nthKat `{255}\n                        ]\n\nnthKat : {n} (fin n, 8 >= width n) => Bit\nnthKat = blake2s (nthKatInput `{n}) == kats @ (`n : [8])\n\nnthKatInput : {n} (fin n) => [n][8]\nnthKatInput = take ([0 ... ] : [inf][8])\n\nkats = [ 0x69217a3079908094e11121d042354a7c1f55b6482ca1a51e1b250dfd1ed0eef9\n       , 0xe34d74dbaf4ff4c6abd871cc220451d2ea2648846c7757fbaac82fe51ad64bea\n       , 0xddad9ab15dac4549ba42f49d262496bef6c0bae1dd342a8808f8ea267c6e210c\n       , 0xe8f91c6ef232a041452ab0e149070cdd7dd1769e75b3a5921be37876c45c9900\n       , 0x0cc70e00348b86ba2944d0c32038b25c55584f90df2304f55fa332af5fb01e20\n       , 0xec1964191087a4fe9df1c795342a02ffc191a5b251764856ae5b8b5769f0c6cd\n       , 0xe1fa51618d7df4eb70cf0d5a9e906f806e9d19f7f4f01e3b621288e4120405d6\n       , 0x598001fafbe8f94ec66dc827d012cfcbba2228569f448e89ea2208c8bf769293\n       , 0xc7e887b546623635e93e0495598f1726821996c2377705b93a1f636f872bfa2d\n       , 0xc315a437dd28062a770d481967136b1b5eb88b21ee53d0329c5897126e9db02c\n       , 0xbb473deddc055fea6228f207da575347bb00404cd349d38c18026307a224cbff\n       , 0x687e1873a8277591bb33d9adf9a13912efefe557cafc39a7952623e47255f16d\n       , 0x1ac7ba754d6e2f94e0e86c46bfb262abbb74f450ef456d6b4d97aa80ce6da767\n       , 0x012c97809614816b5d9494477d4b687d15b96eb69c0e8074a8516f31224b5c98\n       , 0x91ffd26cfa4da5134c7ea262f7889c329f61f6a657225cc212f40056d986b3f4\n       , 0xd97c828d8182a72180a06a78268330673f7c4e0635947c04c02323fd45c0a52d\n       , 0xefc04cdc391c7e9119bd38668a534e65fe31036d6a62112e44ebeb11f9c57080\n       , 0x992cf5c053442a5fbc4faf583e04e50bb70d2f39fbb6a503f89e56a63e18578a\n       , 0x38640e9f21983e67b539caccae5ecf615ae2764f75a09c9c59b76483c1fbc735\n       , 0x213dd34c7efe4fb27a6b35f6b4000d1fe03281af3c723e5c9f94747a5f31cd3b\n       , 0xec246eeeb9ced3f7ad33ed28660dd9bb0732513db4e2fa278b60cde3682a4ccd\n       , 0xac9b61d446648c3005d7892bf3a8719f4c8181cfdcbc2b79fef10a279b911095\n       , 0x7bf8b22959e34e3a43f7079223e83a9754617d391e213dfd808e41b9bead4ce7\n       , 0x68d4b5d4fa0e302b64ccc5af792913ac4c88ec95c07ddf40694256eb88ce9f3d\n       , 0xb2c2420f05f9abe36315919336b37e4e0fa33ff7e76a492767006fdb5d935462\n       , 0x134f61bbd0bbb69aed5343904551a3e6c1aa7dcdd77e903e7023eb7c60320aa7\n       , 0x4693f9bff7d4f3986a7d176e6e06f72ad1490d805c99e25347b8de77b4db6d9b\n       , 0x853e26f741953b0fd5bdb424e8ab9e8b3750eaa8ef61e47902c91e554e9c73b9\n       , 0xf7de536361abaa0e158156cf0ea4f63a99b5e4054f8fa4c9d45f6285cad55694\n       , 0x4c230608860a99ae8d7bd5c2cc17fa52096b9a61bedb17cb7617864ad29ca7a6\n       , 0xaeb920ea87952dadb1fb759291e3388139a872865001886ed84752e93c250c2a\n       , 0xaba4ad9b480b9df3d08ca5e87b0c2440d4e4ea21224c2eb42cbae469d089b931\n       , 0x05825607d7fdf2d82ef4c3c8c2aea961ad98d60edff7d018983e21204c0d93d1\n       , 0xa742f8b6af82d8a6ca2357c5f1cf91defbd066267d75c048b352366585025962\n       , 0x2bcac89599000b42c95ae23835a713704ed79789c84fef149a874ff733f017a2\n       , 0xac1ed07d048f105a9e5b7ab85b09a492d5baff14b8bfb0e9fd789486eea2b974\n       , 0xe48d0ecfaf497d5b27c25d99e156cb0579d440d6e31fb62473696dbf95e010e4\n       , 0x12a91fadf8b21644fd0f934f3c4a8f62ba862ffd20e8e961154c15c13884ed3d\n       , 0x7cbee96e139897dc98fbef3be81ad4d964d235cb12141fb66727e6e5df73a878\n       , 0xebf66abb597ae572a7297cb0871e355accafad8377b8e78bf164ce2a18de4baf\n       , 0x71b933b07e4ff7818ce059d008829e453c6ff02ec0a7db393fc2d870f37a7286\n       , 0x7cf7c51331220b8d3ebaed9c29398a16d98156e2613cb088f2b0e08a1be4cf4f\n       , 0x3e41a108e0f64ad276b979e1ce068279e16f7bc7e4aa1d211e17b81161df1602\n       , 0x886502a82ab47ba8d86710aa9de3d46ea65c47af6ee8de450cceb8b11b045f50\n       , 0xc021bc5f0954fee94f46ea09487e10a84840d02f64810bc08d9e551f7d416814\n       , 0x2030516e8a5fe19ae79c336fce26382a749d3fd0ec91e537d4bd2358c12dfb22\n       , 0x556698dac8317fd36dfbdf25a79cb112d5425860605cbaf507f23bf7e9f42afe\n       , 0x2f867ba67773fdc3e92fced99a6409ad39d0b880fde8f109a81730c4451d0178\n       , 0x172ec218f119dfae98896dff29dd9876c94af87417f9ae4c7014bb4e4b96afc7\n       , 0x3f85814a18195f879aa962f95d26bd82a278f2b82320218f6b3bd6f7f667a6d9\n       , 0x1b618fbaa566b3d498c12e982c9ec52e4da85a8c54f38f34c090394f23c184c1\n       , 0x0c758fb5692ffd41a3575d0af00cc7fbf2cbe5905a58323a88ae4244f6e4c993\n       , 0xa931360cad628c7f12a6c1c4b753b0f4062aef3ce65a1ae3f19369dadf3ae23d\n       , 0xcbac7d773b1e3b3c6691d7abb7e9df045c8ba19268ded153207f5e804352ec5d\n       , 0x23a196d3802ed3c1b384019a82325840d32f71950c4580b03445e0898e14053c\n       , 0xf4495470f226c8c214be08fdfad4bc4a2a9dbea9136a210df0d4b64929e6fc14\n       , 0xe290dd270b467f34ab1c002d340fa016257ff19e5833fdbbf2cb401c3b2817de\n       , 0x9fc7b5ded3c15042b2a6582dc39be016d24a682d5e61ad1eff9c63309848f706\n       , 0x8cca67a36d17d5e6341cb592fd7bef9926c9e3aa1027ea11a7d8bd260b576e04\n       , 0x409392f560f86831da4373ee5e0074260595d7bc24183b60ed700d4583d3f6f0\n       , 0x2802165de090915546f3398cd849164a19f92adbc361adc99b0f20c8ea071054\n       , 0xad839168d9f8a4be95ba9ef9a692f07256ae43fe6f9864e290691b0256ce50a9\n       , 0x75fdaa5038c284b86d6e8affe8b2807e467b86600e79af3689fbc06328cbf894\n       , 0xe57cb79487dd57902432b250733813bd96a84efce59f650fac26e6696aefafc3\n       , 0x56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e\n       , 0x1b53ee94aaf34e4b159d48de352c7f0661d0a40edff95a0b1639b4090e974472\n       , 0x05705e2a81757c14bd383ea98dda544eb10e6bc07bae435e2518dbe133525375\n       , 0xd8b2866e8a309db53e529ec32911d82f5ca16cff76216891a9676aa31aaa6c42\n       , 0xf5041c241270eb04c71ec2c95d4c38d803b1237b0f29fd4db3eb397669e88699\n       , 0x9a4ce077c349322f595e0ee79ed0da5fab66752cbfef8f87d0e9d0723c7530dd\n       , 0x657b09f3d0f52b5b8f2f97163a0edf0c04f075408a07bbeb3a4101a891990d62\n       , 0x1e3f7bd5a58fa533344aa8ed3ac122bb9e70d4ef50d004530821948f5fe6315a\n       , 0x80dccf3fd83dfd0d35aa28585922ab89d5313997673eaf905cea9c0b225c7b5f\n       , 0x8a0d0fbf6377d83bb08b514b4b1c43acc95d751714f8925645cb6bc856ca150a\n       , 0x9fa5b487738ad2844cc6348a901918f659a3b89e9c0dfeead30dd94bcf42ef8e\n       , 0x80832c4a1677f5ea2560f668e9354dd36997f03728cfa55e1b38337c0c9ef818\n       , 0xab37ddb683137e74080d026b590b96ae9bb447722f305a5ac570ec1df9b1743c\n       , 0x3ee735a694c2559b693aa68629361e15d12265ad6a3dedf488b0b00fac9754ba\n       , 0xd6fcd23219b647e4cbd5eb2d0ad01ec8838a4b2901fc325cc3701981ca6c888b\n       , 0x0520ec2f5bf7a755dacb50c6bf233e3515434763db0139ccd9faefbb8207612d\n       , 0xaff3b75f3f581264d7661662b92f5ad37c1d32bd45ff81a4ed8adc9ef30dd989\n       , 0xd0dd650befd3ba63dc25102c627c921b9cbeb0b130686935b5c927cb7ccd5e3b\n       , 0xe1149816b10a8514fb3e2cab2c08bee9f73ce76221701246a589bbb67302d8a9\n       , 0x7da3f441de9054317e72b5dbf979da01e6bceebb8478eae6a22849d90292635c\n       , 0x1230b1fc8a7d9215edc2d4a2decbdd0a6e216c924278c91fc5d10e7d60192d94\n       , 0x5750d716b4808f751febc38806ba170bf6d5199a7816be514e3f932fbe0cb871\n       , 0x6fc59b2f10feba954aa6820b3ca987ee81d5cc1da3c63ce827301c569dfb39ce\n       , 0xc7c3fe1eebdc7b5a939326e8ddb83e8bf2b780b65678cb62f208b040abdd35e2\n       , 0x0c75c1a15cf34a314ee478f4a5ce0b8a6b36528ef7a820696c3e4246c5a15864\n       , 0x216dc12a108569a3c7cdde4aed43a6c330139dda3ccc4a108905db3861899050\n       , 0xa57be6ae6756f28b02f59dadf7e0d7d8807f10fa15ced1ad3585521a1d995a89\n       , 0x816aef875953716cd7a581f732f53dd435dab66d09c361d2d6592de17755d8a8\n       , 0x9a76893226693b6ea97e6a738f9d10fb3d0b43ae0e8b7d8123ea76ce97989c7e\n       , 0x8daedb9a271529dbb7dc3b607fe5eb2d3211770758dd3b0a3593d2d7954e2d5b\n       , 0x16dbc0aa5dd2c774f505100f733786d8a175fcbbb59c43e1fbff3e1eaf31cb4a\n       , 0x8606cb899c6aeaf51b9db0fe4924a9fd5dabc19f8826f2bc1c1d7da14d2c2c99\n       , 0x8479731aeda57bd37eadb51a507e307f3bd95e69dbca94f3bc21726066ad6dfd\n       , 0x58473a9ea82efa3f3b3d8fc83ed8863127b33ae8deae6307201edb6dde61de29\n       , 0x9a9255d53af116de8ba27ce35b4c7e15640657a0fcb888c70d95431dacd8f830\n       , 0x9eb05ffba39fd8596a45493e18d2510bf3ef065c51d6e13abe66aa57e05cfdb7\n       , 0x81dcc3a505eace3f879d8f702776770f9df50e521d1428a85daf04f9ad2150e0\n       , 0xe3e3c4aa3acbbc85332af9d564bc24165e1687f6b1adcbfae77a8f03c72ac28c\n       , 0x6746c80b4eb56aea45e64e7289bba3edbf45ecf8206481ff6302122984cd526a\n       , 0x2b628e52764d7d62c0868b212357cdd12d9149822f4e9845d918a08d1ae990c0\n       , 0xe4bfe80d58c91994613909dc4b1a12496896c004af7b5701483de45d2823d78e\n       , 0xebb4ba150cef2734345b5d641bbed03a21eafae933c99e009212ef04574a8530\n       , 0x3966ec73b154acc697ac5cf5b24b40bdb0db9e398836d76d4b880e3b2af1aa27\n       , 0xef7e4831b3a84636518d6e4bfce64a43db2a5dda9cca2b44f39033bdc40d6243\n       , 0x7abf6acf5c8e549ddbb15ae8d8b388c1c197e698737c9785501ed1f94930b7d9\n       , 0x88018ded66813f0ca95def474c630692019967b9e36888dadd94124719b682f6\n       , 0x3930876b9fc7529036b008b1b8bb997522a441635a0c25ec02fb6d9026e55a97\n       , 0x0a4049d57e833b5695fac93dd1fbef3166b44b12ad11248662383ae051e15827\n       , 0x81dcc0678bb6a765e48c3209654fe90089ce44ff5618477e39ab286476df052b\n       , 0xe69b3a36a4461912dc08346b11ddcb9db796f885fd01936e662fe29297b099a4\n       , 0x5ac6503b0d8da6917646e6dcc87edc58e94245324cc204f4dd4af01563acd427\n       , 0xdf6dda21359a30bc271780971c1abd56a6ef167e480887888e73a86d3bf605e9\n       , 0xe8e6e47071e7b7df2580f225cfbbedf84ce67746626628d33097e4b7dc571107\n       , 0x53e40ead62051e19cb9ba8133e3e5c1ce00ddcad8acf342a224360b0acc14777\n       , 0x9ccd53fe80be786aa984638462fb28afdf122b34d78f4687ec632bb19de2371a\n       , 0xcbd48052c48d788466a3e8118c56c97fe146e5546faaf93e2bc3c47e45939753\n       , 0x256883b14e2af44dadb28e1b34b2ac0f0f4c91c34ec9169e29036158acaa95b9\n       , 0x4471b91ab42db7c4dd8490ab95a2ee8d04e3ef5c3d6fc71ac74b2b26914d1641\n       , 0xa5eb08038f8f1155ed86e631906fc13095f6bba41de5d4e795758ec8c8df8af1\n       , 0xdc1db64ed8b48a910e060a6b866374c578784e9ac49ab2774092ac71501934ac\n       , 0x285413b2f2ee873d34319ee0bbfbb90f32da434cc87e3db5ed121bb398ed964b\n       , 0x0216e0f81f750f26f1998bc3934e3e124c9945e685a60b25e8fbd9625ab6b599\n       , 0x38c410f5b9d4072050755b31dca89fd5395c6785eeb3d790f320ff941c5a93bf\n       , 0xf18417b39d617ab1c18fdf91ebd0fc6d5516bb34cf39364037bce81fa04cecb1\n       , 0x1fa877de67259d19863a2a34bcc6962a2b25fcbf5cbecd7ede8f1fa36688a796\n       , 0x5bd169e67c82c2c2e98ef7008bdf261f2ddf30b1c00f9e7f275bb3e8a28dc9a2\n       , 0xc80abeebb669ad5deeb5f5ec8ea6b7a05ddf7d31ec4c0a2ee20b0b98caec6746\n       , 0xe76d3fbda5ba374e6bf8e50fadc3bbb9ba5c206ebdec89a3a54cf3dd84a07016\n       , 0x7bba9dc5b5db2071d17752b1044c1eced96aaf2dd46e9b433750e8ea0dcc1870\n       , 0xf29b1b1ab9bab163018ee3da15232cca78ec52dbc34eda5b822ec1d80fc21bd0\n       , 0x9ee3e3e7e900f1e11d308c4b2b3076d272cf70124f9f51e1da60f37846cdd2f4\n       , 0x70ea3b0176927d9096a18508cd123a290325920a9d00a89b5de04273fbc76b85\n       , 0x67de25c02a4aaba23bdc973c8bb0b5796d47cc0659d43dff1f97de174963b68e\n       , 0xb2168e4e0f18b0e64100b517ed95257d73f0620df885c13d2ecf79367b384cee\n       , 0x2e7dec2428853b2c71760745541f7afe9825b5dd77df06511d8441a94bacc927\n       , 0xca9ffac4c43f0b48461dc5c263bea3f6f00611ceacabf6f895ba2b0101dbb68d\n       , 0x7410d42d8fd1d5e9d2f5815cb93417998828ef3c4230bfbd412df0a4a7a2507a\n       , 0x5010f684516dccd0b6ee0852c2512b4dc0066cf0d56f35302978db8ae32c6a81\n       , 0xacaab585f7b79b719935ceb89523ddc54827f75c56883856154a56cdcd5ee988\n       , 0x666de5d1440fee7331aaf0123a62ef2d8ba57453a0769635ac6cd01e633f7712\n       , 0xa6f98658f6eabaf902d8b3871a4b101d16196e8a4b241e1558fe29966e103e8d\n       , 0x891546a8b29f3047ddcfe5b00e45fd55756373105ea8637dfcff547b6ea9535f\n       , 0x18dfbc1ac5d25b0761137dbd22c17c829d0f0ef1d82344e9c89c286694da24e8\n       , 0xb54b9b67f8fed54bbf5a2666dbdf4b23cff1d1b6f4afc985b2e6d3305a9ff80f\n       , 0x7db442e132ba59bc1289aa98b0d3e806004f8ec12811af1e2e33c69bfde729e1\n       , 0x250f37cdc15e817d2f160d9956c71fe3eb5db74556e4adf9a4ffafba74010396\n       , 0x4ab8a3dd1ddf8ad43dab13a27f66a6544f290597fa96040e0e1db9263aa479f8\n       , 0xee61727a0766df939ccdc860334044c79a3c9b156200bc3aa32973483d8341ae\n       , 0x3f68c7ec63ac11ebb98f94b339b05c104984fda50103060144e5a2bfccc9da95\n       , 0x056f29816b8af8f56682bc4d7cf094111da7733e726cd13d6b3e8ea03e92a0d5\n       , 0xf5ec43a28acbeff1f3318a5bcac7c66ddb5230b79db2d105bcbe15f3c1148d69\n       , 0x2a6960ad1d8dd547555cfbd5e4600f1eaa1c8eda34de0374ec4a26eaaaa33b4e\n       , 0xdcc1ea7baab93384f76b796866199754742f7b96d6b4c120165c04a6c4f5ce10\n       , 0x13d5df179221379c6a78c07c793ff53487cae6bf9fe882541ab0e735e3eada3b\n       , 0x8c59e4407641a01e8ff91f9980dc236f4ecd6fcf52589a099a961633967714e1\n       , 0x833b1ac6a251fd08fd6d908fea2a4ee1e040bca93fc1a38ec3820e0c10bd82ea\n       , 0xa244f927f3b40b8f6c391570c765418f2f6e708eac9006c51a7feff4af3b2b9e\n       , 0x3d99ed9550cf1196e6c4d20c259620f858c3d703374c128ce7b590310c83046d\n       , 0x2b35c47d7b87761f0ae43ac56ac27b9f25830367b595be8c240e94600c6e3312\n       , 0x5d11ed37d24dc767305cb7e1467d87c065ac4bc8a426de38991ff59aa8735d02\n       , 0xb836478e1ca0640dce6fd910a5096272c8330990cd97864ac2bf14ef6b23914a\n       , 0x9100f946d6ccde3a597f90d39fc1215baddc7413643d85c21c3eee5d2dd32894\n       , 0xda70eedd23e663aa1a74b9766935b479222a72afba5c795158dad41a3bd77e40\n       , 0xf067ed6a0dbd43aa0a9254e69fd66bdd8acb87de936c258cfb02285f2c11fa79\n       , 0x715c99c7d57580cf9753b4c1d795e45a83fbb228c0d36fbe20faf39bdd6d4e85\n       , 0xe457d6ad1e67cb9bbd17cbd698fa6d7dae0c9b7ad6cbd6539634e32a719c8492\n       , 0xece3ea8103e02483c64a70a4bdcee8ceb6278f2533f3f48dbeedfba94531d4ae\n       , 0x388aa5d3667a97c68d3d56f8f3ee8d3d36091f17fe5d1b0d5d84c93b2ffe40bd\n       , 0x8b6b31b9ad7c3d5cd84bf98947b9cdb59df8a25ff738101013be4fd65e1dd1a3\n       , 0x066291f6bbd25f3c853db7d8b95c9a1cfb9bf1c1c99fb95a9b7869d90f1c2903\n       , 0xa707efbccdceed42967a66f5539b93ed7560d467304016c4780d7755a565d4c4\n       , 0x38c53dfb70be7e792b07a6a35b8a6a0aba02c5c5f38baf5c823fdfd9e42d657e\n       , 0xf2911386501d9ab9d720cf8ad10503d5634bf4b7d12b56dfb74fecc6e4093f68\n       , 0xc6f2bdd52b81e6e4f6595abd4d7fb31f651169d00ff326926b34947b28a83959\n       , 0x293d94b18c98bb3223366b8ce74c28fbdf28e1f84a3350b0eb2d1804a577579b\n       , 0x2c2fa5c0b51533165bc375c22e2781768270a383985d13bd6b67b6fd67f889eb\n       , 0xcaa09b82b72562e43f4b2275c091918e624d911661cc811bb5faec51f6088ef7\n       , 0x24761e45e674395379fb17729c78cb939e6f74c5dffb9c961f495982c3ed1fe3\n       , 0x55b70a82131ec94888d7ab54a7c515255c3938bb10bc784dc9b67f076e341a73\n       , 0x6ab9057b977ebc3ca4d4ce74506c25cccdc566497c450b5415a39486f8657a03\n       , 0x24066deee0ecee15a45f0a326d0f8dbc79761ebb93cf8c0377af440978fcf994\n       , 0x20000d3f66ba76860d5a950688b9aa0d76cfea59b005d859914b1a46653a939b\n       , 0xb92daa79603e3bdbc3bfe0f419e409b2ea10dc435beefe2959da16895d5dca1c\n       , 0xe947948705b206d572b0e8f62f66a6551cbd6bc305d26ce7539a12f9aadf7571\n       , 0x3d67c1b3f9b23910e3d35e6b0f2ccf44a0b540a45c18ba3c36264dd48e96af6a\n       , 0xc7558babda04bccb764d0bbf3358425141902d22391d9f8c59159fec9e49b151\n       , 0x0b732bb035675a50ff58f2c242e4710aece64670079c13044c79c9b7491f7000\n       , 0xd120b5ef6d57ebf06eaf96bc933c967b16cbe6e2bf00741c30aa1c54ba64801f\n       , 0x58d212ad6f58aef0f80116b441e57f6195bfef26b61463edec1183cdb04fe76d\n       , 0xb8836f51d1e29bdfdba325565360268b8fad627473edecef7eaefee837c74003\n       , 0xc547a3c124ae5685ffa7b8edaf96ec86f8b2d0d50cee8be3b1f0c76763069d9c\n       , 0x5d168b769a2f67853d6295f7568be40bb7a16b8d65ba87635d1978d2ab11ba2a\n       , 0xa2f675dc7302638cb60201064ca55077714d71fe096a315f2fe7401277caa5af\n       , 0xc8aab5cd0160ae78cd2e8ac5fb0e093cdb5c4b6052a0a97bb04216826fa7a437\n       , 0xff68ca4035bfeb43fbf145fddd5e43f1cea54f11f7bee13058f027329a4a5fa4\n       , 0x1d4e5487ae3c740f2ba6e541ac91bc2bfcd2999c518d807b426748803a350fd4\n       , 0x6d244e1a06ce4ef578dd0f63aff0936706735119ca9c8d22d86c801414ab9741\n       , 0xdecf7329dbcc827b8fc524c9431e8998029ece12ce93b7b2f3e769a941fb8cea\n       , 0x2fafcc0f2e63cbd07755be7b75ecea0adff9aa5ede2a52fdab4dfd0374cd483f\n       , 0xaa85010dd46a546b535ef4cf5f07d65161e89828f3a77db7b9b56f0df59aae45\n       , 0x07e8e1ee732cb0d356c9c0d1069c89d17adf6a9a334f745ec7867332548ca8e9\n       , 0x0e01e81cada8162bfd5f8a8c818a6c69fedf02ceb5208523cbe5313b89ca1053\n       , 0x6bb6c6472655084399852e00249f8cb247896d392b02d73b7f0dd818e1e29b07\n       , 0x42d4636e2060f08f41c882e76b396b112ef627cc24c43dd5f83a1d1a7ead711a\n       , 0x4858c9a188b0234fb9a8d47d0b4133650a030bd0611b87c3892e94951f8df852\n       , 0x3fab3e36988d445a51c8783e531be3a02be40cd04796cfb61d40347442d3f794\n       , 0xebabc49636bd433d2ec8f0e518732ef8fa21d4d071cc3bc46cd79fa38a28b810\n       , 0xa1d0343523b893fca84f47feb4a64d350a17d8eef5497ece697d02d79178b591\n       , 0x262ebfd9130b7d28760d08ef8bfd3b86cdd3b2113d2caef7ea951a303dfa3846\n       , 0xf76158edd50a154fa78203ed2362932fcb8253aae378903eded1e03f7021a257\n       , 0x26178e950ac722f67ae56e571b284c0207684a6334a17748a94d260bc5f55274\n       , 0xc378d1e493b40ef11fe6a15d9c2737a37809634c5abad5b33d7e393b4ae05d03\n       , 0x984bd8379101be8fd80612d8ea2959a7865ec9718523550107ae3938df32011b\n       , 0xc6f25a812a144858ac5ced37a93a9f4759ba0b1c0fdc431dce35f9ec1f1f4a99\n       , 0x924c75c94424ff75e74b8b4e94358958b027b171df5e57899ad0d4dac37353b6\n       , 0x0af35892a63f45931f6846ed190361cd073089e077165714b50b81a2e3dd9ba1\n       , 0xcc80cefb26c3b2b0daef233e606d5ffc80fa17427d18e30489673e06ef4b87f7\n       , 0xc2f8c8117447f3978b0818dcf6f70116ac56fd184dd1278494e103fc6d74a887\n       , 0xbdecf6bfc1ba0df6e862c831992207796acc797968358828c06e7a51e090098f\n       , 0x24d1a26e3dab02fe4572d2aa7dbd3ec30f0693db26f273d0ab2cb0c13b5e6451\n       , 0xec56f58b09299a300b140565d7d3e68782b6e2fbeb4b7ea97ac057989061dd3f\n       , 0x11a437c1aba3c119ddfab31b3e8c841deeeb913ef57f7e48f2c9cf5a28fa42bc\n       , 0x53c7e6114b850a2cb496c9b3c69a623eaea2cb1d33dd817e4765edaa6823c228\n       , 0x154c3e96fee5db14f8773e18af14857913509da999b46cdd3d4c169760c83ad2\n       , 0x40b9916f093e027a8786641818920620472fbcf68f701d1b680632e6996bded3\n       , 0x24c4cbba07119831a726b05305d96da02ff8b148f0da440fe233bcaa32c72f6f\n       , 0x5d201510250020b783689688abbf8ecf2594a96a08f2bfec6ce0574465dded71\n       , 0x043b97e336ee6fdbbe2b50f22af83275a4084805d2d5645962454b6c9b8053a0\n       , 0x564835cbaea774948568be36cf52fcdd83934eb0a27512dbe3e2db47b9e6635a\n       , 0xf21c33f47bde40a2a101c9cde8027aaf61a3137de2422b30035a04c270894183\n       , 0x9db0ef74e66cbb842eb0e07343a03c5c567e372b3f23b943c788a4f250f67891\n       , 0xab8d08655ff1d3fe8758d562235fd23e7cf9dcaad658872a49e5d3183b6ccebd\n       , 0x6f27f77e7bcf46a1e963ade0309733543031dccdd47caac174d7d27ce8077e8b\n       , 0xe3cd54da7e444caa6207569525a670ebae1278de4e3fe2684b3e33f5ef90cc1b\n       , 0xb2c3e33a51d22c4c08fc0989c873c9cc4150579b1e6163fa694ad51d53d712dc\n       , 0xbe7fda983e13189b4c77e0a80920b6e0e0ea80c3b84dbe7e7117d253f48112f4\n       , 0xb6008c28fae08aa427e5bd3aad36f10021f16c77cfeabed07f97cc7dc1f1284a\n       , 0x6e4e6760c538f2e97b3adbfbbcde57f8966b7ea8fcb5bf7efec913fd2a2b0c55\n       , 0x4ae51fd1834aa5bd9a6f7ec39fc663338dc5d2e20761566d90cc68b1cb875ed8\n       , 0xb673aad75ab1fdb5401abfa1bf89f3add2ebc468df3624a478f4fe859d8d55e2\n       , 0x13c9471a9855913539836660398da0f3f99ada08479c69d1b7fcaa3461dd7e59\n       , 0x2c11f4a7f99a1d23a58bb636350fe849f29cbac1b2a1112d9f1ed5bc5b313ccd\n       , 0xc7d3c0706b11ae741c05a1ef150dd65b5494d6d54c9a86e2617854e6aeeebbd9\n       , 0x194e10c93893afa064c3ac04c0dd808d791c3d4b7556e89d8d9cb225c4b33339\n       , 0x6fc4988b8f78546b1688991845908f134b6a482e6994b3d48317bf08db292185\n       , 0x5665beb8b0955525813b5981cd142ed4d03fba38a6f3e5ad268e0cc270d1cd11\n       , 0xb883d68f5fe51936431ba4256738053b1d0426d4cb64b16e83badc5e9fbe3b81\n       , 0x53e7b27ea59c2f6dbb50769e43554df35af89f4822d0466b007dd6f6deafff02\n       , 0x1f1a0229d4640f01901588d9dec22d13fc3eb34a61b32938efbf5334b2800afa\n       , 0xc2b405afa0fa6668852aee4d88040853fab800e72b57581418e5506f214c7d1f\n       , 0xc08aa1c286d709fdc7473744977188c895ba011014247e4efa8d07e78fec695c\n       , 0xf03f5789d3336b80d002d59fdf918bdb775b00956ed5528e86aa994acb38fe2d\n       ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/TestHMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named TestHMAC that contains the following: (1) imports for the HMAC and SHA256 modules so the HMAC-SHA256 function is available; (2) a property named pass that verifies two HMAC-SHA256 test vectors. The property must check that computing HMAC-SHA256 with a key consisting of 20 repeated bytes of value 0x0b and the message \"Hi There\" yields the digest 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7, and that computing HMAC-SHA256 with the key \"Jefe\" and the message \"what do ya want for nothing?\" yields the digest 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843. Aggregate the two boolean equalities into a two-element sequence and assert that all entries are true by comparing against an all-ones sequence of matching length, so the property holds only if both test vectors match their expected digests."},{"role":"assistant","content":"```cryptol\nmodule TestHMAC where\n\nimport HMAC\nimport SHA256\n\nproperty pass =\n    ~zero ==\n    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] \"Hi There\" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\n    , hmacSHA256 \"Jefe\" \"what do ya want for nothing?\" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\n    ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/CryptoBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named CryptoBox that imports Salsa20, Poly1305, and CfrgCurves, and contains the following definitions: (1) A polymorphic function crypto_box with a size parameter for the message length. Constrain the size parameter to be finite and such that the bit-width needed to represent (32 + message length) is at most 64. The function takes a byte-sequence message, a 24-byte nonce, a Curve25519 public key, and a Curve25519 private key, derives a shared secret via X25519, derives a 32-byte key using HSalsa20 with 20 rounds and a zero constant, and returns an authenticated ciphertext of message length plus 16 bytes by delegating to the symmetric primitive. Provide a complete type signature. (2) A function crypto_box_open with matching constraints and types that takes the authenticated ciphertext, a 24-byte nonce, a public key, and a private key, derives the same symmetric key as above, verifies and decrypts via the symmetric primitive, and returns a pair of a validity bit and the plaintext bytes (zeroed if invalid). (3) A function crypto_secretbox that takes a byte-sequence message, a 32-byte key, and a 24-byte nonce. Encrypt 32 zero bytes concatenated with the message using XSalsa20 with 20 rounds; use the first 32 bytes of the resulting stream as the one-time Poly1305 key; compute the MAC over the ciphertext portion after removing the initial 32 bytes; output tag concatenated with ciphertext. Provide a precise type signature and size constraints as above. (4) A function crypto_secretbox_open mirroring the prior behavior: split tag and ciphertext, recompute keystream and MAC, compare tags, and return (valid, plaintext) with zero plaintext if invalid. (5) A property that for two Curve25519 keypairs, sealing a fixed-size message with one side and opening with the counterpart yields the original message. (6) A property that for the symmetric primitive, opening the output of sealing a fixed-size message returns the original message. (7) A property aggregating known-answer tests for the symmetric primitive, and a boolean constant encoding one such test vector equality. Specify all byte lengths explicitly in the types."},{"role":"assistant","content":"```cryptol\nmodule CryptoBox where\n\nimport Salsa20\nimport Poly1305\nimport CfrgCurves\n\ncrypto_box : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes)) => [msgBytes][8] -> [24][8] -> Public25519 -> Private25519 -> [msgBytes + 16][8]\ncrypto_box m n pub priv = crypto_secretbox m k n\n where\n  s          = Curve25519 priv pub\n  k          = HSalsa20_bytes `{r=20} s zero\n\ncrypto_box_open : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes)) => [msgBytes+16][8] -> [24][8] -> Public25519 -> Private25519 -> (Bit,[msgBytes][8])\ncrypto_box_open box n pub priv = crypto_secretbox_open box k n\n where\n  (tag,ct)  = splitAt `{16} box\n  s         = Curve25519 priv pub\n  k         = HSalsa20_bytes `{r=20} s zero\n\ncrypto_secretbox : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes))\n                => [msgBytes][8] -> [32][8] -> [24][8] -> [msgBytes + 16][8]\ncrypto_secretbox m k n = box\n where\n  blob       = XSalsa20_encrypt `{r=20} k n ((zero : [32][8]) # m)\n  authKey    = join (take `{32} blob)\n  ciphertext = drop `{32} blob\n  authTag    = Poly1305 authKey ciphertext\n  box        = authTag # ciphertext\n\ncrypto_secretbox_open : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes))\n                     => [msgBytes + 16][8] -> [32][8] -> [24][8] -> (Bit,[msgBytes][8])\ncrypto_secretbox_open box k n = (valid,pt)\n where\n  (tag,ct)  = splitAt `{16} box\n  blob      = XSalsa20_encrypt `{r=20} k n ((zero : [32][8]) # ct)\n  authKey   = join (take `{32} blob)\n  plaintext = drop blob                  : [msgBytes][8]\n  cTag      = Poly1305 authKey ct\n  valid     = cTag == tag\n  pt        = if valid then plaintext else zero\n\nproperty cat_in_a_box priv1 priv2 msg nonce = open == msg\n  where pub1 = Curve25519 priv1 basePoint25519\n        pub2 = Curve25519 priv2 basePoint25519\n        box  = crypto_box (msg : [100][8]) nonce pub2 priv1\n        open = (crypto_box_open box nonce pub1 priv2).1\n\nproperty hat_in_a_box k msg nonce = open == msg\n  where box  = crypto_secretbox (msg : [88][8]) k nonce\n        open = (crypto_secretbox_open box k nonce).1\n\nproperty crypto_box_kats = zero != [ katTest1 ]\n\nkatTest1 = crypto_secretbox \"hello\" zero zero == split 0xc769f9d535dc338e99ac93440502c7ceae5bd79391\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Salsa20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Salsa20 that imports LittleEndian and contains the following definitions and checks.\n- quarterround: transform 4 32-bit words using word-wise addition modulo 2^32, XOR, and left-rotations by 7, 9, 13, and 18 to produce 4 words.\n- rowround: transform a 16-word state by applying quarterround to the four rows of the 4\u00d74 matrix layout; rowround_opt: an equivalent vectorized\/rotational formulation. Define a boolean function columnround_opt_is_columnround that returns equality of columnround and columnround_opt for any input.\n- columnround: apply quarterround to the four columns of the 4\u00d74 matrix layout; columnround_opt: an equivalent vectorized\/transpose formulation.\n- doubleround: apply columnround then rowround to a 16-word state.\n- Salsa20: parameterized by r with constraint width r \u2264 8, mapping 64 bytes to 64 bytes by forming 16 little-endian 32-bit words, adding the initial state to the state after r\/2 applications of doubleround, then outputting bytes in little-endian order.\n- Define a property that checks the quarterround known-answer vectors; a property that checks the rowround vectors; a property that proves rowround_opt equals rowround for all inputs; a property that checks the columnround vectors; a property that columnround is the transpose of rowround; a property that checks the doubleround vectors; a property that states injectivity of Salsa20 at r=20; properties that check three standard Salsa20 block test vectors and an scrypt-derived test at r=8; a property that doubleround has no collisions on distinct inputs; a property that the XSalsa20 test encrypts a short ASCII message to the expected bytes; properties theorem1\u2013theorem4 showing fixed-point\/invariance patterns; and a property theorem7 relating equality of Salsa20Words outputs when the input XOR equals a fixed per-word MSB mask.\n- Salsa20_expansion: for a \u2208 {1,2}, map a 16\u00b7a-byte key and 16-byte nonce to 64 bytes using the standard constant words; Salsa20_encrypt: for a \u2208 {1,2} and message length l \u2264 2^70, XOR the message with the keystream blocks.\n- HSalsa20 and HSalsa20_bytes: derive a 32-byte subkey from a 32-byte key and 24-byte nonce; define type aliases Key (32 bytes), Nonce (24 bytes), Counter (64-bit).\n- Salsa20_Constant: the 4 constant 32-bit words derived from the standard ASCII constant for the 32-byte key variant.\n- XSalsa20: parameterized by r, produce a 64-byte block from Key, Nonce, and 64-bit counter using HSalsa20; XSalsa20_expansion and XSalsa20_encrypt: generate and XOR an arbitrary-length keystream subject to width constraints.\n- Salsa20Words: transform a 16\u00d732-bit state by byte-order reversals, apply the r=20 block, and return rearranged words."},{"role":"assistant","content":"```cryptol\nmodule Salsa20 where\n\nimport LittleEndian\n\nquarterround : [4][32] -> [4][32]\nquarterround [y0, y1, y2, y3] = [z0, z1, z2, z3]\n  where\n    z1 = y1 ^ ((y0 + y3) <<< 0x7)\n    z2 = y2 ^ ((z1 + y0) <<< 0x9)\n    z3 = y3 ^ ((z2 + z1) <<< 0xd)\n    z0 = y0 ^ ((z3 + z2) <<< 0x12)\n\nproperty quarterround_passes_tests =\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000000] == [0x00000000, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (quarterround [0x00000001, 0x00000000, 0x00000000, 0x00000000] == [0x08008145, 0x00000080, 0x00010200, 0x20500000]) \/\\\n  (quarterround [0x00000000, 0x00000001, 0x00000000, 0x00000000] == [0x88000100, 0x00000001, 0x00000200, 0x00402000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000001, 0x00000000] == [0x80040000, 0x00000000, 0x00000001, 0x00002000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000001] == [0x00048044, 0x00000080, 0x00010000, 0x20100001]) \/\\\n  (quarterround [0xe7e8c006, 0xc4f9417d, 0x6479b4b2, 0x68c67137] == [0xe876d72b, 0x9361dfd5, 0xf1460244, 0x948541a3]) \/\\\n  (quarterround [0xd3917c5b, 0x55f1c407, 0x52a58a7a, 0x8f887a3b] == [0x3e2f308c, 0xd90a8f36, 0x6ab2a923, 0x2883524c])\n\nrowround : [16][32] -> [16][32]\nrowround [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15] =\n    [z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15]\n  where\n    [ z0,  z1,  z2,  z3] = quarterround [ y0,  y1,  y2,  y3]\n    [ z5,  z6,  z7,  z4] = quarterround [ y5,  y6,  y7,  y4]\n    [z10, z11,  z8,  z9] = quarterround [y10, y11,  y8,  y9]\n    [z15, z12, z13, z14] = quarterround [y15, y12, y13, y14]\n\nproperty rowround_passes_tests =\n  (rowround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n            [0x08008145, 0x00000080, 0x00010200, 0x20500000,\n             0x20100001, 0x00048044, 0x00000080, 0x00010000,\n             0x00000001, 0x00002000, 0x80040000, 0x00000000,\n             0x00000001, 0x00000200, 0x00402000, 0x88000100]) \/\\\n  (rowround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n             0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n             0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n             0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n            [0xa890d39d, 0x65d71596, 0xe9487daa, 0xc8ca6a86,\n             0x949d2192, 0x764b7754, 0xe408d9b9, 0x7a41b4d1,\n             0x3402e183, 0x3c3af432, 0x50669f96, 0xd89ef0a8,\n             0x0040ede5, 0xb545fbce, 0xd257ed4f, 0x1818882d])\n\nrowround_opt : [16][32] -> [16][32]\nrowround_opt ys = join [ (quarterround (yi<<<i))>>>i | yi <- split ys | i <- [0 .. 3] : [_][8] ]\n\nproperty rowround_opt_is_rowround ys = rowround ys == rowround_opt ys\n\ncolumnround : [16][32] -> [16][32]\ncolumnround [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15] =\n    [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15]\n  where\n    [ y0,  y4,  y8, y12] = quarterround [ x0,  x4,  x8, x12]\n    [ y5,  y9, y13,  y1] = quarterround [ x5,  x9, x13,  x1]\n    [y10, y14,  y2,  y6] = quarterround [x10, x14,  x2,  x6]\n    [y15,  y3,  y7, y11] = quarterround [x15,  x3,  x7, x11]\n\nproperty columnround_passes_tests =\n  (columnround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x10090288, 0x00000000, 0x00000000, 0x00000000,\n                0x00000101, 0x00000000, 0x00000000, 0x00000000,\n                0x00020401, 0x00000000, 0x00000000, 0x00000000,\n                0x40a04001, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (columnround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n                0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n                0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n                0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n               [0x8c9d190a, 0xce8e4c90, 0x1ef8e9d3, 0x1326a71a,\n                0x90a20123, 0xead3c4f3, 0x63a091a0, 0xf0708d69,\n                0x789b010c, 0xd195a681, 0xeb7d5504, 0xa774135c,\n                0x481c2027, 0x53a8e4b5, 0x4c1f89c5, 0x3f78c9c8])\n\ncolumnround_opt : [16][32] -> [16][32]\ncolumnround_opt xs = join (transpose [ (quarterround (xi<<<i))>>>i | xi <- transpose(split xs) | i <- [0 .. 3] : [_][8] ])\n\ncolumnround_opt_is_columnround xs = columnround xs == columnround_opt xs\n\nproperty columnround_is_transpose_of_rowround ys =\n  rowround ys == join(transpose(split`{4}(columnround xs)))\n  where xs = join(transpose(split`{4} ys))\n\ndoubleround : [16][32] -> [16][32]\ndoubleround(xs) = rowround(columnround(xs))\n\nproperty doubleround_passes_tests =\n  (doubleround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x8186a22d, 0x0040a284, 0x82479210, 0x06929051,\n                0x08000090, 0x02402200, 0x00004000, 0x00800000,\n                0x00010200, 0x20400000, 0x08008104, 0x00000000,\n                0x20500000, 0xa0000040, 0x0008180a, 0x612a8020]) \/\\\n  (doubleround [0xde501066, 0x6f9eb8f7, 0xe4fbbd9b, 0x454e3f57,\n                0xb75540d3, 0x43e93a4c, 0x3a6f2aa0, 0x726d6b36,\n                0x9243f484, 0x9145d1e8, 0x4fa9d247, 0xdc8dee11,\n                0x054bf545, 0x254dd653, 0xd9421b6d, 0x67b276c1] ==\n               [0xccaaf672, 0x23d960f7, 0x9153e63a, 0xcd9a60d0,\n                0x50440492, 0xf07cad19, 0xae344aa0, 0xdf4cfdfc,\n                0xca531c29, 0x8e7943db, 0xac1680cd, 0xd503ca00,\n                0xa74b2ad6, 0xbc331c5c, 0x1dda24c7, 0xee928277])\n\nSalsa20 : {r} (8 >= width r) => [64][8] -> [64][8]\nSalsa20 xs = join ar\n  where\n    ar = [ littleendian_inverse words | words <- xw + zs@(`r\/2 : [8]) ]\n    xw = [ littleendian xi | xi <- split xs ]\n    zs = [xw] # [ doubleround zi | zi <- zs ]\n\nproperty Salsa20_bijective a b = (a == b) || (Salsa20 `{r=20} a != Salsa20 `{r=20} b)\nproperty Salsa20_passes_tests =\n  (Salsa20 `{r=20}\n           [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0] ==\n           [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]) \/\\\n  (Salsa20 `{r=20}\n            [211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37, 191, 187, 234, 136,\n             49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,  86,  16, 179, 207,\n             31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113, 238,  55, 204,  36,\n             79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,  88, 118, 104,  54] ==\n           [109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,  26, 110, 170, 154,\n             29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,  69, 144,  51,  57,\n            118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35,  27, 111, 114, 114,\n            219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158, 179,  19,  48, 202]) \/\\\n  (Salsa20 `{r=20}\n           [ 88, 118, 104,  54,  79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,\n            191, 187, 234, 136, 211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37,\n             86,  16, 179, 207,  49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,\n            238,  55, 204,  36,  31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113] ==\n           [179,  19,  48, 202, 219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158,\n             26, 110, 170, 154, 109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,\n             69, 144,  51,  57,  29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,\n             27, 111, 114, 114, 118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35])\n\nproperty Salsa20_has_no_collisions x1 x2 =\n    x1 == x2 \\\/ doubleround x1 != doubleround x2\n\nproperty Salsa20_passes_scrypt_tests =\n  Salsa20 `{r=8}\n          [ 0x7e, 0x87, 0x9a, 0x21, 0x4f, 0x3e, 0xc9, 0x86, 0x7c, 0xa9, 0x40, 0xe6, 0x41, 0x71, 0x8f, 0x26\n          , 0xba, 0xee, 0x55, 0x5b, 0x8c, 0x61, 0xc1, 0xb5, 0x0d, 0xf8, 0x46, 0x11, 0x6d, 0xcd, 0x3b, 0x1d\n          , 0xee, 0x24, 0xf3, 0x19, 0xdf, 0x9b, 0x3d, 0x85, 0x14, 0x12, 0x1e, 0x4b, 0x5a, 0xc5, 0xaa, 0x32\n          , 0x76, 0x02, 0x1d, 0x29, 0x09, 0xc7, 0x48, 0x29, 0xed, 0xeb, 0xc6, 0x8d, 0xb8, 0xb8, 0xc2, 0x5e\n          ]\n   == [ 0xa4, 0x1f, 0x85, 0x9c, 0x66, 0x08, 0xcc, 0x99, 0x3b, 0x81, 0xca, 0xcb, 0x02, 0x0c, 0xef, 0x05\n      , 0x04, 0x4b, 0x21, 0x81, 0xa2, 0xfd, 0x33, 0x7d, 0xfd, 0x7b, 0x1c, 0x63, 0x96, 0x68, 0x2f, 0x29\n      , 0xb4, 0x39, 0x31, 0x68, 0xe3, 0xc9, 0xe6, 0xbc, 0xfe, 0x6b, 0xc5, 0xb7, 0xa0, 0x6d, 0x96, 0xba\n      , 0xe4, 0x24, 0xcc, 0x10, 0x2c, 0x91, 0x74, 0x5c, 0x24, 0xad, 0x67, 0x3d, 0xc7, 0x61, 0x8f, 0x81\n      ]\n\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(k, n) = z\n  where\n    [s0, s1, s2, s3] = split \"expand 32-byte k\" : [4][4][8]\n    [t0, t1, t2, t3] = split \"expand 16-byte k\" : [4][4][8]\n    x = if(`a == (2 : [8])) then s0 # k0 # s1 # n # s2 # k1 # s3\n                            else t0 # k0 # t1 # n # t2 # k0 # t3\n    z = Salsa20 `{r=20} x\n    [k0, k1] = (split(k#zero)):[2][16][8]\n\nSalsa20_encrypt : {a, l} (a >= 1, 2 >= a, l <= 2^^70) => ([16*a][8], [8][8], [l][8]) -> [l][8]\nSalsa20_encrypt(k, v, m) = c\n  where\n    salsa = take (join [ Salsa20_expansion(k, v#(split i)) | i <- [0, 1 ... ] ])\n    c     = m ^ salsa\n\nHSalsa20 : {r} (8 >= width r) => Key -> Nonce -> [8][32]\nHSalsa20 key0 nonce0 = zs @@ ([0,5,10,15,6,7,8,9] : [_][8])\n  where\n  zs    = infZs @ (`r\/2 :[8])\n  infZs = [xs] # [ doubleround x | x <- infZs ]\n\n  nonce                         = [ littleendian (split n) | n <- split (join nonce0)]\n  [x0,x5,x10,x15]               = Salsa20_Constant\n  [x1,x2,x3,x4,x11,x12,x13,x14] = [ littleendian (split k) | k <- split (join key0)]\n  [x6,x7,x8,x9]                 = nonce @@ ([0..3] : [_][8])\n\n  xs : [16][32]\n  xs     = [x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15]\n\nHSalsa20_bytes : {r} (8 >= width r) => Key -> Nonce -> [32][8]\nHSalsa20_bytes key0 nonce0 = join [littleendian_inverse x | x <- HSalsa20 `{r=r} key0 nonce0]\n\ntype Key      = [256\/8][8]\ntype Nonce    = [192\/8][8]\ntype Counter  = [64]\n\nSalsa20_Constant : [4][32]\nSalsa20_Constant = [littleendian (split x) | x <- split (join \"expand 32-byte k\") : [4][32]]\n\nXSalsa20 : {r} (8 >= width r) => Key -> Nonce -> Counter -> [64][8]\nXSalsa20 key0 nonce0 ctr =\n    split (join [littleendian (split (x' + z')) | x' <- xs' | z' <- zs'])\n  where\n  nonce                         = [ littleendian (split n) | n <- split (join nonce0)]\n\n  subKey = HSalsa20 `{r=r} key0 nonce0 \n  [x'0,x'5,x'10,x'15]                   = Salsa20_Constant\n  [x'1,x'2,x'3,x'4,x'11,x'12,x'13,x'14] = subKey\n  [x'6,x'7]                             = nonce @@ ([4,5] : [_][8])\n  [x'8,x'9]                             = reverse (split ctr)\n\n  xs', zs' : [16][32]\n  xs'       = [ x'0 ,x'1 ,x'2 ,x'3 ,x'4 ,x'5 ,x'6 ,x'7 ,x'8\n              , x'9 ,x'10 ,x'11 ,x'12 ,x'13 ,x'14 ,x'15\n              ]\n  infZs'    = [xs'] # [ doubleround x | x <- infZs' ]\n  zs'       = infZs' @ (`r\/2 : [8])\n\nXSalsa20_expansion : {n,r} (8 >= width r, 64 >= width n) => Key -> Nonce -> [n][8]\nXSalsa20_expansion k n = take (join ks)\n   where\n   ks = [XSalsa20 `{r=r} k n i | i <- [0...]]\n\nXSalsa20_encrypt : {n,r} (8 >= width r, 64 >= width n) => Key -> Nonce -> [n][8] -> [n][8]\nXSalsa20_encrypt k n msg = ks ^ msg\n where ks = XSalsa20_expansion `{r=r} k n\n\nproperty test =\n    ct == [0x00, 0x2d, 0x45, 0x13, 0x84, 0x3f, 0xc2, 0x40, 0xc4, 0x01, 0xe5, 0x41]\n  where\n   ct    = XSalsa20_encrypt `{r=20} key nonce \"Hello world!\"\n   key   = \"this is 32-byte key for xsalsa20\"\n   nonce = \"24-byte nonce for xsalsa\"\n\nproperty theorem1 a = quarterround [a, -a, a, -a] == [a,-a,a,-a]\nproperty theorem2 a b c d = rowround val == val\n    where val    = [a,-a,a,-a\n                   ,b,-b,b,-b\n                   ,c,-c,c,-c\n                   ,d,-d,d,-d]\nproperty theorem3 a b c d = columnround val == val\n    where val    = [a,-b,c,-d\n                   ,-a,b,-c,d\n                   ,a,-b,c,-d\n                   ,-a,b,-c,d]\nproperty theorem4 a = doubleround val == val\n    where val    = [a,-a,a,-a\n                   ,-a,a,-a,a\n                   ,a,-a,a,-a\n                   ,-a,a,-a,a]\nproperty theorem7 a b =\n    a ^ b != diff \\\/ Salsa20Words a == Salsa20Words b\n where\n  diff = [ 0x80000000 | _ <- [0..15]:[_][4] ]\n\nSalsa20Words : [16][32] -> [16][32]\nSalsa20Words x = [join (reverse r) | r <- split `{each=4} (Salsa20 `{r=20} (join [reverse (split `{4} v) | v <- x]))]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/PBKDF2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named PBKDF2 that contains the following definitions: (1) A polymorphic function pbkdf2 that implements PBKDF2 using HMAC-SHA-256. It takes a password as a sequence of bytes, a salt as a sequence of bytes, and returns a derived key of an exact, caller-specified bit length. Constrain parameters so that: the password bit-length fits in a 64-bit length field, the derived key length is finite and at least 1, the iteration count is at least 1 and fits in 16 bits, the salt length plus a 32-bit counter fits in a 32-bit length field, and the number of 256-bit output blocks (the ceiling of the derived-key length divided by 256) fits in 32 bits. Compute blocks T_i by: U_1 = HMAC-SHA-256(password, salt || INT(i)); U_j = HMAC-SHA-256(password, U_{j-1}) for j>1; T_i = U_1 XOR \u2026 XOR U_C. Concatenate T_i for i from 1 to the required block count, then truncate to the requested bit length. (2) A helper function inner with a suitable type signature that, given a password and the initial 32-byte U_1 for a block index, computes the 256-bit XOR accumulator T_i over exactly C iterations. Include constraints ensuring the password bit-length fits the SHA-256 length field and iteration count bounds. (3) A helper function F with a type signature that takes a password, a 256-bit accumulator, and a 32-byte U value, and returns the next accumulator and next U by applying HMAC-SHA-256 and XORing. (4) A property named test1 that checks pbkdf2 against a standard published test vector for HMAC-SHA-256 with a single iteration and a fixed derived-key length, asserting equality with the known expected output."},{"role":"assistant","content":"```cryptol\nmodule PBKDF2 where\n\nimport SHA256\nimport HMAC\n\npbkdf2 : {pwBytes, saltBytes, dkLenBits, C}\n         ( 64 >= width (8 * pwBytes)\n         , dkLenBits >= 1\n         , fin dkLenBits\n         , C >= 1\n         , 16 >= width C\n         , 32 >= width (4 + saltBytes)\n         , 32 >= width ((dkLenBits + 255)\/256)\n         )\n      => [pwBytes][8] -> [saltBytes][8] -> [dkLenBits]\npbkdf2 P S = take `{dkLenBits} (join Ts)\n where\n Ts : [_][256]\n Ts = [ inner `{C=C} P (split (hmacSHA256 P (S # split i))) | i <- [1..len] : [_][32] ]\n type len = (dkLenBits + 255)\/256\n\ninner : {pwBytes, C}\n         ( 64 >= width (8 * pwBytes)\n         , C >= 1, 16 >= width C\n         )\n     =>  [pwBytes][8] -> [32][8] -> [256]\ninner P U0 = (Ts @ 0).0  where\n    Ts = [(join U0, U0)] # [ F P t u  | _ <- [1..C] : [_][16] | (t,u) <- Ts ]\n\nF : {pwBytes} ( 64 >= width (8 * pwBytes)\n              ) => [pwBytes][8] -> [256] -> [32][8] -> ([256],[32][8])\nF P Tprev Uprev = (Tnext,Unext)\n  where\n  Unext = split (hmacSHA256 P Uprev)\n  Tnext = Tprev ^ join Unext\n\ntest1 : Bit\nproperty test1 = pbkdf2 `{C=1,dkLenBits=64*8} \"passwd\" \"salt\" == 0x55ac046e56e3089fec1691c22544b605f94185216dde0465e68b9d57c20dacbc49ca9cccf179b645991664b39d77ef317c71b845b1e30bd509112041d3a19783\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Base64.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Base64 that contains the following definitions and checks: (1) A type synonym Enc64 n that computes the encoded byte length as four times the sum of the input length n and a padding count, divided by three, where the padding count is (3 \u2212 (n mod 3)) mod 3. (2) A function base64enc with size parameters n, m, padZ and constraints: fin n, fin m, padZ = (3 \u2212 (n mod 3)) mod 3, 2 \u2265 padZ, and 4*(padZ + n)\/3 = m. It takes an array of n bytes and returns an array of Enc64 n bytes. Specify the algorithm: pad the input with padZ zero bytes, partition into groups of three bytes, convert into four 6-bit values, map each 6-bit value to the standard Base64 alphabet, and append padZ \u2018=\u2019 bytes. (3) A constant alphabet equal to the standard 64-character Base64 alphabet. (4) A function base64chunks for any finite n that maps [n*3] bytes to [n*4] bytes by splitting into 6-bit chunks and mapping each index via the alphabet; include a helper that maps a 6-bit index to its alphabet byte. (5) A function base64dec with size parameters n, m and constraints fin n, fin m, 4*n = 3*m, returning a pair of n bytes and a 2-bit padding count. Specify helpers: one that maps an input byte to an 8-bit code (letters, digits, plus, slash to 0..63; others to zero), and another that drops the low two bits to produce a 6-bit value. Count up to two trailing \u2018=\u2019 bytes. (6) Properties: decoding the encoding of any input yields the original bytes and the correct padding count; the alphabet has length 64 and the encode\/decode character mappings are inverse on valid characters; the padding count is between 0 and 2; the encoded length equals Enc64 n."},{"role":"assistant","content":"```cryptol\nmodule Base64 where\n\ntype Enc64 n = 4*(((3-(n%3))%3) + n)\/3\n\nbase64enc : {n,m,padZ} (4*(padZ + n)\/3 == m, fin n, fin m, padZ == (3-(n%3))%3, 2>=padZ)\n          => [n][8] -> [Enc64 n][8]\nbase64enc ns = take `{m} (chunks # padEq)\n where\n  chunks      = take `{(4*n+2)\/3} (base64chunks `{(n+2)\/3} (ns # padZero))\n  padZero     = take `{padZ} [zero | _ <- [1..2] : [_][2]]\n  padEq       = \"==\"\n\nalphabet = ['A'..'Z'] # ['a'..'z'] # ['0'..'9'] # \"+\/\"\n\nbase64chunks : {n} (fin n) => [n*3][8] -> [n*4][8]\nbase64chunks m = [basify x |  x <- ns]\n where\n  ns = split (join m) : [_][6]\n  basify : [6] -> [8]\n  basify x = alphabet @ x\n\nbase64dec : {n,m} (fin m, 4*n == 3*m, fin n) => [m][8] -> ([n][8],[2])\nbase64dec ms = (split (join [debase x | x <- ms]), nrEq)\n where\n nrEq : [2]\n nrEq = sum [ zero # [x == '='] | x <- take `{2} (reverse ms # [zero,zero]) ]\n\n debase : [8] -> [6]\n debase x = drop `{2} (debase' x)\n\n debase' : [8] -> [8]\n debase' x =\n    if x >= 'A' \/\\ x <= 'Z'\n        then x - 'A'\n        else if x >= 'a' \/\\ x <= 'z'\n              then x - 'a' + 26\n              else if x >= '0' \/\\ x <= '9'\n                    then x - '0' + 52\n                    else if x == '+'\n                        then 62\n                        else if x == '\/'\n                                then 63\n                                else zero \/\/ Pad bytes are decoded as NUL\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Base58.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Base58 that contains the following definitions: (1) a constant charMap with type [58][8], holding the 58-character Bitcoin Base58 alphabet (digits 1\u20139, uppercase letters except O and I, lowercase letters except l), encoded as 8-bit character codes; (2) a function base58enc with type variables n and m, requiring finite sizes, n \u2265 6, and signature [n] -> [m][8]. It must implement Base58 encoding by repeatedly dividing the input value by 58 to produce digits 0..57, mapping each digit to an 8-bit character using charMap, selecting exactly m digits (least significant first), and returning them in most-significant-first order. Use local helpers: a stream of quotient\/digit pairs from repeated division and a charOf function to index charMap; (3) a function base58dec with type variables n and m, requiring finite sizes and constraints n \u2265 1, n \u2265 width m, and n \u2265 8, with signature [m][8] -> [n]. It must decode an m-length sequence of 8-bit characters by reversing the sequence, converting each character to a digit 0..57 via a local dec' that inverts the Base58 alphabet mapping (handling alphabet gaps for excluded characters), zero-extending the 8-bit digit to n bits via dec, and summing digit * 58^position to reconstruct the value. Clearly specify all type signatures, constraints, helper functions (charOf, dec, dec'), and the ordering conventions used during encode\/decode."},{"role":"assistant","content":"```cryptol\nmodule Base58 where\n\nbase58enc : {n,m} (fin n, fin m, n >= 6 ) => [n] -> [m][8]\nbase58enc ns = [ x.1 | x <- reverse (take `{m} (drop `{1} enc))]\n where\n  enc      = [(ns,zero)] # [ (n\/58,charOf (n%58)) | (n,_) <- enc ]\n  charOf x = charMap @ x\n\ncharMap : [58][8]\ncharMap = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\nbase58dec : {n,m} (fin n, fin m, n >= 1, n >= width m, n >= 8) => [m][8] -> [n]\nbase58dec ms = sum [ (dec m) * 58 ^^ i | m <- reverse ms | i <- [0..m] ]\n where\n  dec : [8] -> [n]\n  dec x = zero # dec' x\n\n  dec' : [8] -> [8]\n  dec' x =\n    if x >= 'm'\n     then x - 'm' + 44\n     else if x >= 'a'\n            then x - 'a' + 33\n            else if x >= 'P'\n                  then x - 'P' + 22\n                  else if x > 'I'\n                        then x - 'J' + 17\n                        else if x >= 'A'\n                              then x - 'A' + 9\n                              else x - '1'\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/bv.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named bv that contains the following definitions with explicit polymorphic type signatures and fin constraints on all size parameters: uext, iext, safe_add, safe_sub, is_normal, safe_product, safe_mod, adc, and sbb. Use size variables a, b, and n (all finite). Specify behaviors precisely: (1) uext takes an a-bit word and returns an (a+b)-bit word formed by prefixing b zero bits. (2) iext takes an a-bit word and returns an (a+b)-bit word formed by prefixing b copies of the word\u2019s most significant bit (unsigned sign extension using the leading bit). (3) safe_add takes two n-bit words, zero-extends both to n+1 bits, adds them as unsigned integers, and returns the n+1-bit sum. (4) safe_sub takes two n-bit words, zero-extends both to n+1 bits, subtracts as unsigned integers, and returns the n+1-bit result. (5) is_normal takes two a-bit words p and x and returns a single Bit indicating x is strictly less than p (unsigned comparison). (6) safe_product takes two a-bit words, zero-extends both to 2a bits, multiplies them unsigned, and returns the 2a-bit product. (7) safe_mod takes a b-bit modulus p and an (a+b)-bit value x, computes x modulo p using an (a+b)-bit zero-extended modulus, and returns the lower b bits of the remainder. (8) adc takes two n-bit words, forms their n+1-bit zero-extended sum, returns a pair of the lower n bits and the most significant bit as the carry-out. (9) sbb takes two n-bit words, forms an n+1-bit subtraction after prefixing a zero bit to each operand, and returns a pair of the lower n bits and the most significant bit as the borrow\/carry indicator."},{"role":"assistant","content":"```cryptol\nmodule bv where\n\nuext : {a, b} (fin b,fin a) => [a] -> [a+b]\nuext(x) = zero # x\n\niext : {a, b} (fin b,fin a) => [a] -> [a+b]\niext(x) = (if x@0 then ~zero else zero) # x\n\nsafe_add : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_add(x,y) = uext(x) + uext(y)\n\nsafe_sub : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_sub(x,y) = uext(x) - uext(y)\n\nis_normal : {a} (fin a) => [a] -> [a] -> Bit\nis_normal p x = (x < p)\n\nsafe_product : {a} (fin a) => ([a],[a]) -> [2*a]\nsafe_product(x,y) = uext(x) * uext(y)\n\nsafe_mod : {a, b} (fin a, fin b) => ([b],[a+b]) -> [b]\nsafe_mod(p,x) = drop `{a} (x % uext(p))\n\nadc : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nadc(x,y) = (drop(sm), sm@0)\n  where sm = safe_add(x,y)\n\nsbb : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nsbb(x,y) = (drop(r), r@0)\n  where r = ([False] # x) - ([False] # y)\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/LittleEndian.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named LittleEndian that contains the following definitions: (1) A polymorphic function littleendian with the constraint that the length parameter is finite, taking a sequence of a 8-bit values and returning an a\u00d78-bit value by interpreting the input as little-endian bytes (reverse the byte order and then concatenate). Include an explicit type signature reflecting this mapping and constraint. (2) Define a property that asserts the function passes three test vectors: mapping [0,0,0,0] to 0x00000000, [86,75,30,9] to 0x091e4b56, and [255,255,255,250] to 0xfaffffff. (3) A function littleendian_inverse with type from a 32-bit value to a sequence of 4 elements of 8 bits, computed by splitting the 32-bit input into bytes and reversing the order. (4) Define a property that universally quantifies over all 4-element sequences of 8-bit values and asserts that applying littleendian followed by littleendian_inverse returns the original input. Provide clear type signatures for both functions and use the property keyword for the two boolean assertions."},{"role":"assistant","content":"```cryptol\nmodule LittleEndian where\n\nlittleendian : {a}(fin a) => [a][8] -> [a*8]\nlittleendian b = join(reverse b)\n\nproperty littleendian_passes_tests =\n  (littleendian [  0,   0,   0,   0] == 0x00000000) &&\n  (littleendian [ 86,  75,  30,   9] == 0x091e4b56) &&\n  (littleendian [255, 255, 255, 250] == 0xfaffffff)\n\nlittleendian_inverse : [32] -> [4][8]\nlittleendian_inverse b = reverse(split b)\n\nproperty littleendian_is_invertable b = littleendian_inverse(littleendian b) == b\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES\/SBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named AES::SBox that imports AES::GF28 and AES::SubBytePlain. Declare a type synonym SBox as a sequence of length 256 whose elements are the GF(2^8) field type from AES::GF28. Provide type signatures for two constants, sbox and sboxInv, both having type SBox. Define sbox as the sequence formed by applying the SubByte transformation from AES::SubBytePlain to every byte value from 0 through 255 in ascending order, producing GF(2^8) outputs. Define sboxInv as the sequence formed by applying the InvSubByte transformation from the same module to every byte value from 0 through 255 in ascending order, producing GF(2^8) outputs. Ensure the comprehensions enumerate all 256 input values exactly once and that the resulting sequences\u2019 element type matches the field type. Do not add properties or proofs; only provide the module, imports, type synonym, type signatures, and constant definitions."},{"role":"assistant","content":"```cryptol\nmodule AES::SBox where\n\nimport AES::GF28\nimport AES::SubBytePlain\n\ntype SBox = [256] GF28\n\nsbox : SBox\nsbox = [ SubByte x | x <- [0 .. 255] ]\n\nsboxInv : SBox\nsboxInv = [ InvSubByte x | x <- [0 .. 255] ]\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES\/SubByteSBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named AES::SubByteSBox that imports AES::GF28 and AES::SBox and re-exports two functions. Declare a type signature for SubByte that takes one value in GF28 and returns a value in GF28; implement it by applying the imported S-box to its argument. Declare a type signature for InvSubByte that takes one value in GF28 and returns a value in GF28; implement it by applying the imported inverse S-box to its argument. Define a property that, for all b in GF28, SubByte b equals applying the imported S-box to b. Define a property that, for all b in GF28, InvSubByte b equals applying the imported inverse S-box to b. Define a property that, for all b in GF28, composing InvSubByte after SubByte yields b and composing SubByte after InvSubByte yields b. Use universally quantified variables with no additional constraints. Ensure the module exports SubByte and InvSubByte."},{"role":"assistant","content":"```cryptol\nmodule AES::SubByteSBox where\n\nimport AES::GF28\nimport AES::SBox\n\nSubByte : GF28 -> GF28\nSubByte b = sbox @ b\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = sboxInv @ b\n```"}]}
{"filename":"cryptol\/lib\/Cryptol\/Reference.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Cryptol::Reference that contains the following definitions with exact types, constraints, and behaviors:\n- pmult: For size variables u and v with fin constraints, accept two bit vectors of sizes 1+u and 1+v and return a bit vector of size 1+u+v. Implement polynomial multiplication over GF(2), where XOR is coefficient addition and left-shift corresponds to multiplying by x. Use a streaming recurrence that accumulates partial products and returns the final state.\n- pdiv: For size variables u and v with fin constraints, accept bit vectors of sizes u and v and return a bit vector of size u. Compute the quotient of polynomial long division over GF(2). Determine the index of the highest nonzero coefficient of the divisor and drive a state machine that repeatedly reduces the running dividend; output the quotient bits extracted from the evolving state at that index.\n- pmod: For size variables u and v with fin constraints, accept a dividend of size u and a modulus of size 1+v and return the remainder of size v. Compute the remainder of polynomial division over GF(2) using repeated conditional reductions based on the degree of the modulus. If the modulus is the zero polynomial, return an all-unknown vector of length v.\n- foldl: For fin n, types a and b, take a binary function a -> b -> a, an initial accumulator of type a, and a sequence of n elements of type b; return the left fold result of type a.\n- scanl: For types a and b and size n, take a -> b -> a, an initial a, and a sequence of n b\u2019s; return the sequence of prefix accumulations of length 1+n.\n- iterate: For type a, take a unary function a -> a and a seed a; return an infinite stream produced by repeatedly applying the function.\nProvide precise Cryptol type signatures matching these descriptions and implement each algorithm as specified."},{"role":"assistant","content":"```cryptol\nmodule Cryptol::Reference where\n\npmult : {u, v} (fin u, fin v) => [1 + u] -> [1 + v] -> [1 + u + v]\npmult x y = last zs\n  where\n    zs = [0] # [ (z << 1) ^ (if yi then 0 # x else 0) | yi <- y | z <- zs ]\n\npdiv : {u, v} (fin u, fin v) => [u] -> [v] -> [u]\npdiv x y = [ z ! degree | z <- zs ]\n  where\n    degree : [width v]\n    degree = last (ds : [1 + v]_)\n      where ds = [0\/0] # [if yi then i else d | yi <- reverse y | i <- [0..v] | d <- ds ]\n\n    reduce : [v] -> [v]\n    reduce u = if u ! degree then u ^ y else u\n\n    zs : [u][v]\n    zs = [ tail (reduce z # [xi]) | z <- [0] # zs | xi <- x ]\n\npmod : {u, v} (fin u, fin v) => [u] -> [1 + v] -> [v]\npmod x y = if y == 0 then 0\/0 else last zs\n  where\n    degree : [width v]\n    degree = last (ds : [2 + v]_)\n      where ds = [0\/0] # [if yi then i else d | yi <- reverse y | i <- [0..v] | d <- ds ]\n\n    reduce : [1 + v] -> [1 + v]\n    reduce u = if u ! degree then u ^ y else u\n\n    powers : [inf][1 + v]\n    powers = [reduce 1] # [ reduce (p << 1) | p <- powers ]\n\n    zs = [0] # [ z ^ (if xi then tail p else 0) | xi <- reverse x | p <- powers | z <- zs ]\n\nfoldl : {n, a, b} (fin n) => (a -> b -> a) -> a -> [n]b -> a\nfoldl f z bs = last (scanl f z bs)\n\nscanl : {n, a, b}  (a -> b -> a) -> a -> [n]b -> [1+n]a\nscanl f z bs = as\n  where\n    as = [z] # [ f a b | a <- as | b <- bs ]\n\niterate : {a} (a -> a) -> a -> [inf]a\niterate f z = xs\n  where xs = [z] # [ f x | x <- xs ]\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol_eval\/test-files\/M.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named M that contains the following definitions, with explicit type signatures and exact numeric widths: - A function `f` that maps an 8-bit word to a 2-element sequence of 8-bit words by repeating the input twice. - A function `g` with the same type and behavior as `f`, implemented by constructing a two-element sequence containing two copies of the input. - A property `f_g_equiv` stating that for all 8-bit inputs, `f` and `g` produce identical outputs. - A function `h` that takes a 2-element sequence of 8-bit words and returns it unchanged. - A property `h_identity` asserting that for all such inputs, `h` returns its argument. - A polymorphic constant `m` of type `Z a` with constraints that `a` is finite and strictly greater than 42, whose value is 42. - Constants `two`, `three`, and `four` with widths 15, 16, and 17 bits respectively, holding the values 2, 3, and 4. - A polymorphic identity function `id` of type `a -> a` that returns its argument. - A property `id_returns_input` asserting that for any value (use appropriate polymorphic constraints), applying `id` yields the same value. - A type synonym `Word8` for an 8-bit word. - A type synonym `Twenty a` for a length-20 sequence of elements of type `a`. - A predicate function `isSqrtOf9` that takes an 8-bit word and returns a single bit indicating whether the 8-bit square of the input equals 9. Ensure all constraints are stated explicitly in the signatures, and all properties quantify over the required domains."},{"role":"assistant","content":"```cryptol\nmodule M where\nf : [8] -> [2][8]\nf x = repeat x\n\ng : [8] -> [2][8]\ng x = [x, x]\n\nh : [2][8] -> [2][8]\nh x = x\n\nm : {a} (fin a, a > 42) => Z a\nm = 42\n\ntwo : [15]\ntwo = 2\n\nthree : [16]\nthree = 3\n\nfour : [17]\nfour = 4\n\nid : {a} a -> a\nid x = x\n\ntype Word8 = [8]\ntype Twenty a = [20]a\n\nisSqrtOf9 : [8] -> Bit\nisSqrtOf9 x = x*x == 9\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Names.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Names that contains the following: a module value parameter key of type 64-bit word; a function enc that takes a 64-bit word and returns a 64-bit word by XORing the input with key; a property enc_correct that, for any 64-bit input, asserts the input equals the result of applying enc twice; a primitive function prim that maps a 64-bit word to a 64-bit word with no implementation; an infix operator (-!) over 64-bit words that performs saturating subtraction, yielding zero when the right operand is greater than the left, otherwise the arithmetic difference; a numeric type parameter a; a type synonym b equal to a; a constraint alias fin_b requiring that b is finite; an abstract value type c; a newtype d that wraps c with a single selector un_d of type c; and an empty nested submodule M."},{"role":"assistant","content":"```cryptol\nmodule Names where\n\nparameter\n  key : [64]\n\nenc : [64] -> [64]\nenc x = x ^ key\n\nenc_correct : [64] -> Bit\nproperty enc_correct x =\n  x == enc (enc x)\n\nprimitive prim : [64] -> [64]\n\n(-!) : [64] -> [64] -> [64]\nx -! y = if y > x then 0 else x - y\n\nparameter\n  type a : #\n\ntype b = a\n\ntype constraint fin_b = fin b\n\nprimitive type c : *\n\nnewtype d = { un_d : c }\n\nsubmodule M where\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Id.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Id that contains the following definition: a function id that acts as the identity on bit sequences. Provide a type signature that is polymorphic over a size parameter n, constrained to be finite, and maps a sequence of n bits to a sequence of n bits. Implement the body to return its single argument unchanged. Use an implicit numeric type parameter for n, include the finiteness constraint in the signature, and define the function with a single equation and no auxiliary definitions."},{"role":"assistant","content":"```cryptol\nmodule Id where\n\nid : {n} (fin n) => [n] -> [n]\nid a = a\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/CplxQNewtype.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) introduces a type alias for rationals; (2) declares a newtype representing complex numbers with rational real and imaginary fields; (3) provides a function that embeds a rational into the complex type by setting the imaginary component to zero (with an explicit type signature from rational to complex); (4) declares one rational constant equal to 42 and three complex constants obtained by embedding 2, 40, and 42; (5) implements complex addition that adds real parts and imaginary parts component-wise (type: complex -> complex -> complex); (6) implements complex multiplication using the standard formula (type: complex -> complex -> complex); (7) defines a boolean equality predicate that returns true iff both the real and imaginary components are equal (type: complex -> complex -> Bit); (8) define a property that addition is associative for all complex inputs, comparing results with the equality predicate; (9) define a property that multiplication is associative for all complex inputs, comparing results with the equality predicate; and (10) define a property that multiplication left-distributes over addition for all complex inputs, comparing results with the equality predicate."},{"role":"assistant","content":"```cryptol\ntype Q = Rational\n\nfortyTwo : Q\nfortyTwo = 42\n\nnewtype CplxQ =\n  { real : Q, imag : Q }\n\nembedQ : Q -> CplxQ\nembedQ x = CplxQ{ real = x, imag = 0 }\n\ncplxTwo : CplxQ\ncplxTwo = embedQ 2\n\ncplxForty : CplxQ\ncplxForty = embedQ 40\n\ncplxFortyTwo : CplxQ\ncplxFortyTwo = embedQ 42\n\ncplxAdd : CplxQ -> CplxQ -> CplxQ\ncplxAdd x y = CplxQ { real = r, imag = i }\n  where\n  r = x.real + y.real\n  i = x.imag + y.imag\n\ncplxMul : CplxQ -> CplxQ -> CplxQ\ncplxMul x y = CplxQ { real = r, imag = i }\n  where\n  r = x.real * y.real - x.imag * y.imag\n  i = x.real * y.imag + x.imag * y.real\n\ncplxEq : CplxQ -> CplxQ -> Bit\ncplxEq x y = (x.real == y.real) && (x.imag == y.imag)\n\nproperty cplxAddAssoc x y z =\n  cplxEq (cplxAdd (cplxAdd x y) z)\n         (cplxAdd x (cplxAdd y z))\n\nproperty cplxMulAssoc x y z =\n  cplxEq (cplxMul (cplxMul x y) z)\n         (cplxMul x (cplxMul y z))\n\nproperty cplxMulDistrib x y z =\n  cplxEq (cplxMul x (cplxAdd y z))\n         (cplxAdd (cplxMul x y) (cplxMul x z))\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Foo.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Foo that contains the following definitions and types: import the module Id with the alias Id; a polymorphic identity function named id with a type parameter that returns its argument unchanged; an 8-bit constant equal to 255; a polymorphic function add over bitvectors of width a with a finiteness constraint that performs built-in addition; a record constant with two 32-bit fields named foo and bar set to 23 and 99, respectively; a function getFoo that takes such a record and returns the 32-bit value of its foo field. Define eleven functions op1 through op11, each polymorphic over n with a finiteness constraint, each taking a value of width n and returning the zero value of a result type whose width is determined by a type-level computation on n, respectively: plus one; the difference of n and itself; times one; divided by one; remainder upon division by one; raised to the power one; the corresponding inverse operation with operand one; the bit-width required to represent n; the maximum of n and one; the minimum of one and n; the base-2 logarithm of n. Finally, define isSqrtOf9, a function from 8-bit values to a single bit that is true exactly when the input squared equals 9. Provide precise type signatures and bodies matching these behaviors."},{"role":"assistant","content":"```cryptol\nmodule Foo where\n\nimport Id as Id\n\nid : {a} a -> a\nid x = x\n\nx : [8]\nx = 255\n\nadd : {a} (fin a) => [a] -> [a] -> [a]\nadd = (+)\n\nfoo : {foo : [32], bar : [32]} \nfoo = {foo = 23, bar = 99}\n\ngetFoo : {foo : [32], bar : [32]}  -> [32]\ngetFoo x = x.foo\n\nop1 : {n} (fin n) => [n] -> [n + 1]\nop1 a = 0\n\nop2 : {n} (fin n) => [n] -> [n - n]\nop2 a = 0\n\nop3 : {n} (fin n) => [n] -> [n * 1]\nop3 a = 0\n\nop4 : {n} (fin n) => [n] -> [n \/ 1]\nop4 a = 0\n\nop5 : {n} (fin n) => [n] -> [n % 1]\nop5 a = 0\n\nop6 : {n} (fin n) => [n] -> [n ^^ 1]\nop6 a = 0\n\nop7 : {n} (fin n) => [n] -> [n \/^ 1]\nop7 a = 0\n\nop8 : {n} (fin n) => [n] -> [width n]\nop8 a = 0\n\nop9 : {n} (fin n) => [n] -> [max n 1]\nop9 a = 0\n\nop10 : {n} (fin n) => [n] -> [min 1 n]\nop10 a = 0\n\nop11 : {n} (fin n) => [n] -> [lg2 n]\nop11 a = 0\n\nisSqrtOf9 : [8] -> Bit\nisSqrtOf9 x = x*x == 9\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Types.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Types that contains the following definitions: b as a Bit set to true; w as a 16-bit word with decimal value 42; z as an unbounded integer with value 420000; m as an integer modulo 12 with value 6; q as a rational number equal to five quarters; t as a pair consisting of a Bit and an Integer set to false and seven respectively; s as a 3-by-3 matrix of 8-bit words containing the numbers one through nine in row-major order; r as a record with fields xCoord and yCoord, each a 32-bit word, set to 12 and 21 respectively; id as a polymorphic identity function with a size parameter n, constrained so n is finite, that takes a sequence of n bits and returns the same sequence unchanged. Include type signatures for all items and concrete values exactly as specified. Do not add extra declarations."},{"role":"assistant","content":"```cryptol\nmodule Types where\n\nb : Bit\nb = True\n\nw : [16]\nw = 42\n\nz : Integer\nz = 420000\n\nm : Z 12\nm = 6\n\nq : Rational\nq = ratio 5 4\n\nt : (Bit, Integer)\nt = (False, 7)\n\ns : [3][3][8]\ns = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nr : {xCoord : [32], yCoord : [32]}\nr = {xCoord = 12 : [32], yCoord = 21 : [32]}\n\nid : {n} (fin n) => [n] -> [n]\nid a = a\n```"}]}
{"filename":"cryptol-specs\/Common\/ntt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Common::ntt that contains the following definitions: (1) a prime modulus constant set to 8380417, a field type as integers modulo that modulus, and a vector length constant set to 256; (2) a field element generator equal to 1753; (3) a function, parameterized by a finite size, that returns the first n successive powers of a given field element starting at 1; (4) a function, parameterized by a finite size, that returns the first n odd powers of a given element starting at exponent 1; (5) a naive forward NTT that maps a coefficient vector to evaluations at the first n odd powers of the root; (6) a polynomial evaluation function using Horner\u2019s method over the field with coefficients processed in reverse; (7) field constants equal to the multiplicative inverses of the length and the root; (8) a naive inverse NTT that scales by the inverse length and computes inner products of the reversed input with odd powers of the inverse root, enumerated via the powers of the root; (9) define a property that the naive inverse applied to the naive forward returns the original length-256 vector; (10) a function producing the length-256 standard basis vector at a given index less than the length; (11) infinite streams that enumerate even powers of the root and of its inverse via repeated multiplication; (12) a radix-2 decimation-in-time NTT that invokes a recursive helper at depth zero with exponent equal to the base-2 logarithm of the length; (13) a recursive helper that for size 2^n splits by a shuffle into even and odd halves, recurses on both with increased depth, and combines them with a butterfly using a stride determined by depth and twiddle factors from the roots stream; include finiteness and positivity constraints on sizes; (14) a shuffle that splits a length-2n vector into even and odd positions; (15) a butterfly that merges two length-n vectors into a length-2n vector using twiddle factors; (16) corresponding inverse transforms and butterfly using the inverse roots and final scaling by the inverse length; (17) define a property that the inverse composed with the forward equals identity on length-256 vectors; (18) a forward variant that premultiplies by powers of the root and define a property equating it to the naive forward; (19) an inverse variant that postmultiplies by powers of the inverse root and define properties equating it to the naive inverse and asserting that composing the forward and inverse variants yields identity."},{"role":"assistant","content":"```cryptol\nmodule Common::ntt where\n\ntype q = 8380417\n\ntype Fld = Z q\n\ntype nn = 256\n\nr : Fld\nr = 1753\n\nall_powers : {n} (fin n) => Fld -> [n]Fld\nall_powers w = take`{n} (iterate ((*) w) 1)\n\nodd_powers : {n} (fin n) => Fld -> [n]Fld\nodd_powers w = take`{n} (iterate ((*) (w * w)) w)\n\nnaive_ntt : {n} (fin n) => [n]Fld -> [n]Fld\nnaive_ntt xs = map (polyeval xs) (odd_powers r)\n\npolyeval : {n} (fin n) => [n]Fld -> Fld -> Fld\npolyeval p x = foldl (\\y pi -> (x * y) + pi) 0 (reverse p)\n\nivn : Fld\nivn = recip (`nn : Fld)\n\nivr : Fld\nivr = recip r\n\nnaive_ivntt : {n} (fin n) => [n]Fld -> [n]Fld\nnaive_ivntt xs = map ((*) ivn) ys\n  where\n    ys = [ foldl (+) 0 (zipWith (*) (reverse xs) (odd_powers wi))\n         | wi <- all_powers r ]\n\nnaive_ntt_correct : [nn]Fld -> Bool\nproperty naive_ntt_correct a = naive_ivntt (naive_ntt a) == a\n\nunit : {n} (n < nn) => [nn]Fld\nunit =\n  [ if `n == i then 1 else 0 | i <- [0 .. <nn]]\n\nroots : [inf]Fld\nroots = iterate ((*) (r * r)) 1\n\nntt : [nn]Fld -> [nn]Fld\nntt a = ntt_r`{lg2 nn} 0 a\n\nntt_r : {n} (fin n) => Integer -> [2 ^^ n]Fld -> [2 ^^ n]Fld\nntt_r depth a\n  | n == 0 =>  a\n  | n > 0 => butterfly depth even odd\n    where\n      (lft, rht) = shuffle a\n      even = ntt_r`{n - 1} (depth + 1) lft\n      odd = ntt_r`{n - 1} (depth + 1) rht\n\nshuffle : {n, a} (fin n, n > 0) => [2 * n]a -> ([n]a, [n]a)\nshuffle a =\n  ([ a @ (i * 2) | i <- [0 .. <n]], [ a @ (i * 2 + 1) | i <- [0 .. <n]])\n\nbutterfly : {n} (fin n, n > 0) => Integer -> [n]Fld -> [n]Fld -> [2*n]Fld\nbutterfly depth even odd =\n  lft # rht\n  where\n    j = 2 ^^ depth\n    lft = [ even @ i + roots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n    rht = [ even @ i - roots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n\nivroots : [inf]Fld\nivroots = iterate ((*) (ivr * ivr)) 1\n\nivntt : [nn]Fld -> [nn]Fld\nivntt a =\n  map ((*) ivn) (ivntt_r`{lg2 nn} 0 a)\n\nivntt_r : {n} (fin n) => Integer -> [2 ^^ n]Fld -> [2 ^^ n]Fld\nivntt_r depth a\n  | n == 0 => a\n  | n > 0 => ivbutterfly depth even odd\n    where\n      (lft, rht) = shuffle a\n      even = ivntt_r`{n - 1} (depth + 1) lft\n      odd = ivntt_r`{n - 1} (depth + 1) rht\n\nivbutterfly : {n} (fin n, n > 0) => Integer -> [n]Fld -> [n]Fld -> [2 * n]Fld\nivbutterfly depth even odd =\n  lft # rht\n  where\n    j = 2 ^^ depth\n    lft = [ even @ i + ivroots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n    rht = [ even @ i - ivroots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n\nntt_correct : [nn]Fld -> Bool\nproperty ntt_correct a = ivntt (ntt a) == a\n\nfntt : [nn]Fld -> [nn]Fld\nfntt xs = ntt (zipWith (*) xs (all_powers r))\n\nfntt_correct : [nn]Fld -> Bool\nproperty fntt_correct a = naive_ntt a == fntt a\n\nfivntt : [nn]Fld -> [nn]Fld\nfivntt xs = zipWith (*) (all_powers ivr) (ivntt xs)\n\nfivntt_correct : [nn]Fld -> Bool\nproperty fivntt_correct a = fivntt a == naive_ivntt a\n\nffivntt_correct : [nn]Fld -> Bool\nproperty ffivntt_correct a = fivntt (fntt a) == a\n```"}]}
{"filename":"cryptol-specs\/Common\/LUP.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::LUP that contains the following definitions. Parameterize the module over a field-like type Fld with an equality constraint and provide parameters for zero, one, addition, additive inverse, multiplication, and multiplicative inverse. Define a division function that multiplies by the inverse. Provide an index vector generator for sizes, and a function that maps an index-aware updater across a fixed-length sequence. Introduce type synonyms for fixed-length field vectors and square matrices. Implement inner product on vectors using the field operations; vector addition; scalar multiplication; a unit (basis) vector constructor; an identity matrix; matrix-matrix multiplication (using row-by-column inner products) and matrix-vector multiplication; and an element-swapping function that exchanges two positions when both indices are in range, leaving the sequence unchanged otherwise. Implement LUPDecompose to perform in-place LUP decomposition with partial pivoting, returning a boolean that indicates nonsingularity, the combined LU matrix, and a permutation vector. The helpers row, pivot, and elim must be private: pivot must search from the current row downward for a nonzero pivot in the current column and swap rows and permutation entries when found; row must call pivot and then elimination as appropriate; elim must compute multipliers and eliminate entries below the pivot while writing multipliers into the lower triangle. Implement LUPSolve to solve a linear system using the LU matrix and permutation: first permute the right-hand side, then do forward substitution in the unit-lower part, then backward substitution in the upper part. Implement LUPInvert to return the inverse by solving for each identity column when the matrix is nonsingular; otherwise return the input matrix with a false flag. Provide explicit type signatures with size parameters and fin constraints, ensuring all dimensions and widths are consistent and only the supplied field operations are used. Mark the helper functions as private within the module."},{"role":"assistant","content":"```cryptol\nmodule Common::LUP where\n\nparameter\n\n  type Fld : *\n\n  type constraint (Eq Fld)\n\n  fzero : Fld\n\n  fadd : Fld -> Fld -> Fld\n\n  fminus : Fld -> Fld\n\n  fone : Fld\n\n  fmul : Fld -> Fld -> Fld\n\n  finv : Fld -> Fld\n\nfdiv : Fld -> Fld -> Fld\nfdiv x y =\n  fmul x (finv y)\n\nnats : {n} (fin n) => [n][width n]\nnats = take`{n} [0 .. n]\n\nmap_at : {n, a} (fin n) => ([width n] -> a -> a) -> [n]a  -> [n]a\nmap_at f m = [ f i (m @ i) | i <- nats ]\n\ntype FldVec n = [n]Fld\n\ndot : {n} (fin n) => FldVec n -> FldVec n -> Fld\ndot x y =\n  str ! 0\n  where\n    str = [ fzero ] # [ fadd acc (fmul xi yi)\n                      | xi <- x\n                      | yi <- y\n                      | acc <- str ]\n\nvecAdd : {n} (fin n) => FldVec n -> FldVec n -> FldVec n\nvecAdd x y = [ fadd xi yi | xi <- x | yi <- y ]\n\nscalMul : {n} (fin n) => Fld -> FldVec n -> FldVec n\nscalMul c x = [ fmul c xi | xi <- x ]\n\ntype FldMat n = [n](FldVec n)\n\nidMat : {n} (fin n) => FldMat n\nidMat = [ unitVec i | i <- nats ]\n\nunitVec : {n} (fin n) => [width n] -> FldVec n\nunitVec i =\n  [ if i == j then fone else fzero | j <- nats ]\n\nmatMul : {n} (fin n) => FldMat n -> FldMat n -> FldMat n\nmatMul x y =\n  [ [ dot (x @ i) (transpose y @ j) | j <- nats ] | i <- nats]\n\nmatVec : {n} (fin n) => FldMat n -> FldVec n -> FldVec n\nmatVec x y =\n  [ dot (x @ i) y  | i <- nats]\n\nswap : {n, a} (fin n) => [width n] -> [width n] -> [n]a -> [n]a\nswap i j x =\n  [ x @ perm k | k <- nats ]\n  where\n    perm k =\n      if (i >= `n) || (j >= `n)\n      then k\n      else if k == i\n           then j\n           else if k == j\n                then i\n                else k\n\nLUPDecompose : {n} (fin n) => FldMat n -> (Bit, FldMat n, [n][width n])\nLUPDecompose a = str ! 0\n  where\n  perm = [ i | i <- nats ]\n  str = [(True, a, perm)] #\n        [ row i non_sing lu p\n        | (non_sing, lu, p) <- str\n        | i <- nats`{n=n}\n        ]\n\nprivate\n\n  row : {n} (fin n) => [width n] -> Bit -> FldMat n -> [n][width n] ->\n                       (Bit, FldMat n, [n][width n])\n  row i ns a p =\n    if ns\n    then if ns'\n         then (ns', elim i a', p')          else (ns', a', p')        \/\/ a is singular, pivoting failed\n         where\n           (ns', a', p') = pivot i a p\n    else (ns, a, p)             \n\n  pivot : {n} (fin n) => [width n] -> FldMat n -> [n][width n] ->\n                         (Bit, FldMat n, [n][width n])\n  pivot i a perm = str ! 0\n    where\n    str = [(False, a, perm)] #\n          [ f done lu p j | (done, lu, p) <- str | j <- nats`{n=n} ]\n    f done lu p j =\n      if j < i then (done, lu, p)\n       | j == i then (lu @ i @ i != fzero, lu, p)\n       | done then (done, lu, p)\n       | lu @ j @ i == fzero then (done, lu, p)\n      else (True, swap i j lu, swap i j p) \n\n  elim : {n} (fin n) => [width n] -> FldMat n -> FldMat n\n  elim i a = map_at f a\n    where\n      invA_i_i = finv (a @ i @ i)\n      f j v =\n        if i < j then\n          map_at g v\n          where\n            a_j_i = fmul (v @ i) invA_i_i\n            g k x =\n              if k < i then x\n               | k == i then a_j_i\n              else\n                fadd x (fminus (fmul a_j_i (a @ i @ k)))\n        else\n          v\n\nLUPSolve : {n} (fin n) => FldMat n -> [n][width n] ->\n                          FldVec n -> FldVec n\nLUPSolve lu p b =\n  bb\n  where\n        pb = map_at pf b\n    pf i x = b @ (p @ i)\n        fb = [ ff i x | x <- pb | i <- nats`{n=n} ]\n    ff i x = str ! 0\n      where\n        str = [ x ] # [ h j y | y <- str | j <- nats`{n=n} ]\n        h j y =\n          if j < i\n          then fadd y (fminus (fmul (lu @ i @ j) (fb @ j)))\n          else y\n        bb = [ bf i x | x <- fb | i <- nats`{n=n} ]\n    bf i x = fdiv (str ! 0) (lu @ i @ i)\n      where\n        str = [ x ] # [ h j y | y <- str | j <- nats`{n=n} ]\n        h j y =\n          if i < j\n          then fadd y (fminus (fmul (lu @ i @ j) (bb @ j)))\n          else y\n\nLUPInvert : {n} (fin n) => FldMat n -> (Bit, FldMat n)\nLUPInvert a =\n  if ns then\n    (True, transpose [ LUPSolve lu p (unitVec i) | i <- nats ])\n  else\n    (False, a)\n  where\n    (ns, lu, p) = LUPDecompose a\n```"}]}
{"filename":"cryptol-specs\/Common\/ByteArray.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::ByteArray that contains: (1) an import of the library that provides a parametric array type constructor, and (2) a type synonym named ByteArray that denotes a fixed-length array of 64 elements where each element is an 8-bit value. Ensure the alias uses the imported array type constructor (not a built-in sequence), fixes the outer length to 64, and fixes each element\u2019s width to 8 bits. Do not add any functions, constants, or properties beyond this alias and the necessary import. Include the correct module header and keep the definition self-contained."},{"role":"assistant","content":"```cryptol\nmodule Common::ByteArray where\n\nimport Array\n\ntype ByteArray = Array[64][8]\n```"}]}
{"filename":"cryptol-specs\/Common\/pick.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::pick that contains the following definitions with precise polymorphic types and constraints: nats (for a finite size n) produces a length-n sequence of natural numbers encoded in words wide enough to index 0..n\u22121; pickItem consumes the first element of an infinite stream and returns the remainder stream paired with that element; pickSeq, for finite n > 0, repeatedly applies a state-threading picker function exactly n times to an infinite stream, returning the final stream and a length-n sequence of results; pickVec specializes pickSeq using the single-element picker; pickMat specializes pickSeq using pickVec to build an n\u00d7m matrix (n,m finite, >0); pickTri, for finite n > 0, builds an n\u00d7n upper-triangular matrix using a provided picker and a nil fill value, taking elements only on and above the main diagonal while leaving entries below the diagonal as the nil value, and returning the final stream; and a private helper pickTriRow that constructs one row given a row index, inserting the nil value for columns strictly below that row\u2019s diagonal and otherwise consuming from the stream. Also define the following properties: (1) pickItem returns the head element as the second component and the tail as the first; (2) nats has length n and its i-th element equals i encoded at the specified bit width; (3) pickVec is extensionally equal to pickSeq applied with the single-element picker; (4) pickMat is extensionally equal to pickSeq applied with pickVec; (5) pickSeq applies its picker exactly n times, threads the intermediate stream states in order, and the final stream equals the state after the nth application; (6) with the single-element picker, pickTri produces an upper-triangular matrix with nil below the diagonal, consumes exactly n(n+1)\/2 elements from the stream, and returns the stream advanced by that amount; (7) pickTriRow for row j yields nil for columns less than j and consumes exactly n\u2212j elements from the stream."},{"role":"assistant","content":"```cryptol\nmodule Common::pick where\n\nnats : {n} (fin n) => [n][width n]\nnats = take`{n} [0 .. n]\n\npickItem : {a} [inf]a -> ([inf]a, a)\npickItem g = (tail g, head g)\n\npickSeq : {n, a, b} (fin n, n > 0) =>\n          ([inf]a -> ([inf]a, b)) -> [inf]a -> ([inf]a, [n]b)\npickSeq f vals =\n  (str, map snd vec)\n  where\n    vec = [f vals] # [f g | (g, _) <- vec | i <- nats`{n=n-1}]\n    snd (_, x) = x\n    (str, _) = vec ! 0            \n\npickVec : {n, a} (fin n, n > 0) => [inf]a -> ([inf]a, [n]a)\npickVec = pickSeq pickItem\n\npickMat : {n, m, a} (fin n, n > 0, fin m, m > 0) =>\n          [inf]a -> ([inf]a, [n][m]a)\npickMat = pickSeq pickVec\n\npickTri : {n, a} (fin n, n > 0) =>\n          ([inf]a -> ([inf]a, a)) -> a -> [inf]a -> ([inf]a, [n][n]a)\npickTri pick nil s =\n  (str, map snd vec)\n  where\n    vec = [pickSeq pick s] # [pickTriRow pick nil g i\n                             | (g, _) <- vec\n                             | i <- nats`{n=n-1}\n                             ]\n    snd (_, x) = x\n    (str, _) = vec ! 0          \nprivate\n\n  pickTriRow : {n, a} (fin n, n > 0) => ([inf]a -> ([inf]a, a)) ->\n               a -> [inf]a -> [width (n - 1)] -> ([inf]a, [n]a)\n  pickTriRow pick nil s j =\n    (str, map snd vec)\n    where\n      vec = [pick s] # [f g i\n                       | (g, _) <- vec\n                       | i <- nats`{n=n-1}\n                       ]\n      f g i =\n        if i < j\n        then (g, nil)\n        else pick g\n      snd (_, x) = x\n      (str, _) = vec ! 0\n```"}]}
{"filename":"cryptol-specs\/Common\/Field.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::Field that imports Common::Morphism and Common::Set, and declares a type alias FieldRep parameterized by a type variable fv. The alias must be a record with these fields and types: is_val: a Set over fv denoting valid elements; normalize: fv -> fv returning a canonical representative; add, sub, mul, div: (fv, fv) -> fv for field addition, subtraction, multiplication, and division; neg, sq, half: fv -> fv for additive inverse, squaring, and halving; field_zero and field_unit: constants of type fv giving the additive and multiplicative identities; is_equal: (fv, fv) -> Bit as an equality predicate. Provide explicit Cryptol type annotations for every field, ensure the record is fully specified with these names and types, and export the type alias from the module. Do not implement any algorithms; only define the module, imports, and the type alias signature."},{"role":"assistant","content":"```cryptol\nmodule Common::Field where\n\nimport Common::Morphism\nimport Common::Set\n\ntype FieldRep fv =\n  { is_val : Set fv           , normalize : fv -> fv\n  , add : (fv,fv) -> fv\n  , sub : (fv,fv) -> fv\n  , neg : fv -> fv\n  , mul : (fv,fv) -> fv\n  , sq : fv -> fv\n  , half : fv -> fv\n  , div : (fv,fv) -> fv\n\n  , field_zero : fv\n\n  , field_unit : fv\n\n  , is_equal : (fv, fv) -> Bit\n  }\n```"}]}
{"filename":"cryptol-specs\/Common\/mod_arith.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::mod_arith that contains the following definitions: mod_add, mod_sub, mod_neg, mod_half, mod_mul, mod_div, and mod_pow. Import Common::bv to use helpers for addition with carry and subtraction with borrow, and safe-width arithmetic. Use unsigned fixed-width words throughout. Specify polymorphic size parameters (n or a) with the constraint that sizes are finite; additionally require the size to be at least 1 where right-shifts or iteration over bits are needed. Describe each function precisely: mod_add takes (p,x,y) as n-bit words and returns (x + y) reduced modulo p using word-size addition, capturing carry, followed by a conditional subtraction of p. mod_sub takes (p,x,y) and returns (x \u2212 y) reduced modulo p using subtraction with borrow and a conditional addition of p. mod_neg takes (p,x) and returns 0 if x is zero, otherwise p \u2212 x. mod_half takes (p,x) and returns x\/2 modulo p: if x is even, right-shift by one; if x is odd, add p and then halve, preserving width. mod_mul takes (p,x,y) and returns (x \u00d7 y) reduced modulo p using width-safe multiplication and modular reduction. mod_div takes (p,x,y) and returns x multiplied by the modular inverse of y modulo p, implemented via a binary extended GCD that halves even terms and updates residues modulo p; state preconditions p > 0, p is odd, and gcd(y,p) = 1; implement the EGCD as a local helper. mod_pow takes (p,x,e) and returns x raised to exponent e modulo p via square-and-multiply, scanning exponent bits from least to most significant for exactly the bit-width of the size parameter. Clearly state argument and result widths for each function, and ensure all intermediates are width-safe and results are reduced modulo p."},{"role":"assistant","content":"```cryptol\nmodule Common::mod_arith where\n\nimport Common::bv\n\nmod_add : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_add(p,x,y) = if c1 || ~c2 then r2 else r1\n  where\n    (r1,c1) = adc( x, y)\n    (r2,c2) = sbb(r1, p)\n\nmod_sub : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_sub(p,x,y) = if b then r2 else r1\n  where\n    (r1,b) = sbb( x, y)\n    (r2,_) = adc(r1, p)\n\nmod_neg : {n} (fin n) => ([n],[n]) -> [n]\nmod_neg(p,x) = if x == 0 then 0 else (p - x)\n\nmod_half : {n} (fin n, n >= 1) => ([n],[n]) -> [n]\nmod_half(p, x) = if even(x) then x >> 1\n                 else take(safe_add(x, p))\n  where even y = (y && 1) == 0\n\nmod_mul : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_mul(p,x,y) = safe_mod(p, safe_product(x, y))\n\nmod_div : {a} (fin a, a >= 1) => ([a],[a],[a]) -> [a]\nmod_div(p,x,y) = egcd(p,0,y,x)\n  where\n\n    egcd(a,ra,b,rb) =\n      if b == 0 then\n        ra\n      else if (b && 1) == 0 then \n        egcd(a, ra, b >> 1, mod_half(p, rb))\n      else if a < b then\n        egcd(a, ra, (b - a) >> 1, mod_half(p, mod_sub(p, rb, ra)))\n      else\n        egcd(b, rb, (a - b) >> 1, mod_half(p, mod_sub(p, ra, rb)))\n\nmod_pow : {a} (fin a, a >= 1) => ([a] , [a] , [a]) -> [a]\nmod_pow (p,x0,e0) = (results ! 0).2\n where\n results = [(x0,e0,1)] # [ (mod_mul (p,x,x), e>>1, if(e!0) then mod_mul(p,result,x) else result)\n                                | (x,e,result) <- results | _ <- [0..a] :[_][width a] ]\n```"}]}
{"filename":"cryptol-specs\/Common\/OptionUtils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Common::OptionUtils that contains the following definitions: isSome, isNone, optApply, optFold, optTest, optFlatten, and optFlatApply. Provide polymorphic type signatures: isSome: Option a -> Bit; isNone: Option a -> Bit; optApply: (a -> b) -> Option a -> Option b; optFold: b -> (a -> b) -> Option a -> b; optTest: (a -> Bit) -> Option a -> Bit; optFlatten: Option (Option a) -> Option a; optFlatApply: (a -> Option b) -> Option a -> Option b. Specify behavior in plain language: isSome yields true exactly when a value is present; isNone is the boolean negation of isSome; optApply maps a function over a present value and preserves absence; optFold returns the default when absent and applies the function to the value when present; optTest evaluates a predicate when present and otherwise returns false (expressible via optFold with default false); optFlatten removes one level of optional nesting, propagating absence; optFlatApply performs monadic bind for options and is equivalent to applying a function then flattening. Include properties (using Cryptol\u2019s property declarations) to verify: isNone equals the negation of isSome for all inputs; optTest equals optFold with default false; optFlatApply equals optFlatten after optApply; mapping with the identity function leaves an option unchanged; mapping with composed functions equals composing mappings; folding returns the default on absence and the mapped value on presence. Ensure all functions are total and impose no extra typeclass constraints."},{"role":"assistant","content":"```cryptol\nmodule Common::OptionUtils where\n\nisSome : {a} Option a -> Bit\nisSome opt = case opt of\n    Some _ -> True\n    None -> False\n\nisNone : {a} Option a -> Bit\nisNone opt = ~ isSome opt\n\noptApply : {a, b} (a -> b) -> Option a -> Option b\noptApply f opt = case opt of\n    Some x -> Some (f x)\n    None -> None\n\noptFold : {a, b} b -> (a -> b) -> Option a -> b\noptFold def f opt =\n  case opt of\n    Some x -> f x\n    None   -> def\n\noptTest : {a} (a -> Bit) -> Option a -> Bit\noptTest f opt = optFold False f opt\n\noptFlatten : {a} Option (Option a) -> Option a\noptFlatten opt = case opt of\n    Some opt' -> opt'\n    None -> None\n\noptFlatApply: {a, b} (a -> Option b) -> Option a -> Option b\noptFlatApply f opt = optFlatten (optApply f opt)\n```"}]}
{"filename":"cryptol-specs\/Common\/GF24.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Common::GF24 that contains the following definitions: (1) a type alias for field elements as 4-bit sequences representing GF(2^4); (2) a constant irreducible polynomial for GF(2^4) equal to the trinomial of degree 4 with nonzero terms at degrees 4, 1, and 0; (3) a function with signature {n} (fin n) => [n]GF24 -> GF24 that reduces a finite sequence of field elements using bitwise XOR starting from the additive identity; (4) a function GF24 -> GF24 -> GF24 that multiplies two elements by polynomial multiplication modulo the chosen irreducible polynomial; (5) a function GF24 -> GF24 -> GF24 that raises a base to an exponent encoded as a 4-bit vector using square-and-multiply over the exponent\u2019s bits, producing the resulting field element; (6) define a property that, for all field elements, adding an element to itself yields the additive identity; (7) a function GF24 -> GF24 that returns the multiplicative inverse by exponentiating to 2^4 \u2212 2; (8) define a property that, for all elements, applying the inverse operation twice returns the original element; (9) a function {n} (fin n) => [n]GF24 -> [n]GF24 -> GF24 that computes a dot product by summing elementwise products in the field; (10) a function {n, m} (fin n) => [n]GF24 -> [m][n]GF24 -> [m]GF24 that multiplies a vector by a matrix of matching inner dimension via dot products; (11) a function {n, m, k} (fin m) => [n][m]GF24 -> [m][k]GF24 -> [n][k]GF24 that performs matrix multiplication over GF(2^4), e.g., by dotting each row of the left with each column of the right via a transpose. Use the specified names and types."},{"role":"assistant","content":"```cryptol\nmodule Common::GF24 where\n\ntype GF24 = [4]\n\nirreducible = <| x^^4 + x + 1 |>\n\ngf24Add : {n} (fin n) => [n]GF24 -> GF24\ngf24Add ps = foldl (^) zero ps\n\ngf24Mult : GF24 -> GF24 -> GF24\ngf24Mult x y = pmod (pmult x y) irreducible\n\ngf24Pow : GF24 -> GF24 -> GF24\ngf24Pow n k = vals ! 0 where\n    sq x = gf24Mult x x\n    vals = [1] # [ if i then gf24Mult n (sq acc) else sq acc\n        | acc <- vals\n        | i   <- k]\n\npolySelfAdd' : GF24 -> Bit\nproperty polySelfAdd' x = x ^ x == zero\n\ngf24Inverse : GF24 -> GF24\ngf24Inverse x = gf24Pow x 14\n\nproperty gf24InverseCorrect x = gf24Inverse (gf24Inverse x) == x\n\ngf24DotProduct : {n} (fin n) => [n]GF24 -> [n]GF24 -> GF24\ngf24DotProduct xs ys = gf24Add [ gf24Mult x y | x <- xs | y <- ys ]\n\ngf24VectorMult : {n, m} (fin n) => [n]GF24 -> [m][n]GF24 -> [m]GF24\ngf24VectorMult v ms = [ gf24DotProduct v m | m <- ms ]\n\ngf24MatrixMult : {n, m, k} (fin m) => [n][m]GF24 -> [m][k]GF24 -> [n][k]GF24\ngf24MatrixMult xss yss = [ gf24VectorMult xs yss' | xs <- xss ]\n    where\n        yss' = transpose yss\n```"}]}
{"filename":"cryptol-specs\/Common\/bv.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::bv that contains the following definitions: safe_add, safe_sub, is_normal, safe_product, safe_mod, adc, and sbb. Provide explicit polymorphic type signatures with size parameters and fin constraints. Specify behaviors: safe_add returns an (n+1)-bit sum of two n-bit values computed by adding their zero-extended forms; safe_sub returns an (n+1)-bit difference of two n-bit values using zero-extension; is_normal returns a single bit indicating whether the second argument is strictly less than the first; safe_product returns a 2a-bit product of two a-bit values using zero-extension before multiplication; safe_mod takes a b-bit modulus and an (a+b)-bit value, computes the remainder modulo the zero-extended modulus, and returns the low b bits; adc returns an n-bit sum along with the carry-out bit obtained from the most significant bit of the (n+1)-bit sum; sbb returns an n-bit difference along with the borrow bit obtained from the most significant bit of the (n+1)-bit subtraction of zero-extended operands. Also define properties that: (1) for all sizes and inputs, the first component of adc equals the low n bits of the (n+1)-bit sum and its carry bit equals that sum\u2019s most significant bit; (2) sbb\u2019s n-bit result equals the low n bits of the (n+1)-bit zero-extended subtraction and its borrow bit equals that subtraction\u2019s most significant bit; (3) safe_add and safe_sub match addition and subtraction on zero-extended inputs, and their low n bits equal the respective modular results; (4) safe_product equals the product of zero-extended inputs and partitions into low\/high a-bit halves; (5) safe_mod equals the low b bits of the remainder of the (a+b)-bit input modulo the zero-extended modulus, and if the modulus is nonzero the result is strictly less than the modulus; (6) is_normal is true exactly when the second argument is less than the first."},{"role":"assistant","content":"```cryptol\nmodule Common::bv where\n\nsafe_add : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_add(x,y) = zext(x) + zext(y)\n\nsafe_sub : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_sub(x,y) = zext(x) - zext(y)\n\nis_normal : {a} (fin a) => [a] -> [a] -> Bit\nis_normal p x = (x < p)\n\nsafe_product : {a} (fin a) => ([a],[a]) -> [2*a]\nsafe_product(x,y) = zext(x) * zext(y)\n\nsafe_mod : {a, b} (fin a, fin b) => ([b],[a+b]) -> [b]\nsafe_mod(p,x) = drop `{a} (x % zext(p))\n\nadc : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nadc(x,y) = (drop(sm), sm@0)\n  where sm = safe_add(x,y)\n\nsbb : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nsbb(x,y) = (drop(r), r@0)\n  where r = ([False] # x) - ([False] # y)\n```"}]}
{"filename":"cryptol-specs\/Common\/utils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::utils that contains the following definitions: (1) A polymorphic loop while over a state type that takes a predicate from state to Bit, a state transformer, and an initial state, repeatedly applying the transformer while the predicate holds; include a total recursive definition. (2) A do-while loop dowhile that applies the transformer once, then continues with while using the updated state. (3) Converters between modular integers, bitvectors, and Integers with precise type constraints: ZtoBV: Z p -> [a] with p finite and >= 1 and a finite; BVtoZ: [a] -> Z p with p finite and >= 1 and a finite; ZtoZ: Z p -> Z q with p,q finite and >= 1; integerToBV: Integer -> [m] with m finite; integerFromBV: [m] -> Integer; integerModulusFromBV: [m] -> Integer that returns at least 3 (use 3 when the value is less than 3, otherwise the value). (4) isEven: Integer -> Bit using the least significant bit; abs: Integer -> Integer returning absolute value. (5) unzip that transforms a sequence of pairs into a pair of sequences using projections. (6) mul2, mul3, mul4, mul8 as generic numeric helpers defined via repeated addition and doubling. (7) A type-level constraint synonym isOdd that holds when a natural is odd. (8) half: Z p -> Z p implementing modular halving for odd moduli with constraints p finite, p >= 3, and isOdd p; compute half so that it matches division by two modulo p. (9) Define a property that, under the same constraints, verifies that doubling the result of half yields the original value. (10) compose: (a -> a) -> (a -> a) -> a -> a; and composeMany: [nf](a -> a) -> a -> a that composes zero functions as identity, one function as-is, two by composition, and more by recursive composition; constrain nf as a size parameter."},{"role":"assistant","content":"```cryptol\nmodule Common::utils where\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = (fromInteger (fromZ x))\n\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = (fromInteger (toInteger x))\n\nZtoZ : {p, q} (fin p, fin q, p >= 1, q >= 1) => Z p -> Z q\nZtoZ x = (fromInteger (fromZ x))\n\nintegerToBV : {m} (fin m) => Integer -> [m]\nintegerToBV x = fromInteger x\n\nintegerFromBV : {m} (fin m) => [m] -> Integer\nintegerFromBV x = toInteger x\n\nintegerModulusFromBV : {m} (fin m) => [m] -> Integer\nintegerModulusFromBV x = if (integerFromBV x) < 3 then 3 else (integerFromBV x)\n\nisEven : Integer -> Bit\nisEven x = ~((fromInteger x) : [1]) ! 0\n\nabs : Integer -> Integer\nabs x = if x >= zero then x else zero-x\n\nunzip : {a,f,s} [a](f,s) -> ([a]f,[a]s)\nunzip tuples = (map (\\x -> x.0) tuples , map (\\x -> x.1) tuples)\n\nmul2 x = x + x\n\nmul3 x = x + mul2 x\n\nmul4 x = mul2(mul2 x)\n\nmul8 x = mul2(mul4 x)\n\ntype constraint isOdd a = (a \/ 2) * 2 == a - 1\n\nhalf : {p} (fin p, p >= 3, isOdd p) => Z p -> Z p\nhalf x = fromInteger (if isEven xint then xint\/2 else ((xint + `p) \/ 2))\n  where\n    xint = fromZ x\n\nhalf_correct : {p} (fin p, p >= 3, isOdd p) => Z p -> Bit\nproperty half_correct x = half x + half x == x\n\ncompose : {a} () => (a -> a) -> (a -> a) -> a -> a\ncompose f g = \\x -> g (f x)\n\ncomposeMany : {nf, a} () => [nf](a -> a) -> a -> a\ncomposeMany fcns\n    | nf == 0 => \\x -> x\n    | nf == 1 => fcns@0\n    | nf == 2 => compose (fcns@0) (fcns@1)\n    | nf > 2  => compose (fcns@0) (composeMany (drop `{1} fcns))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/KDF\/HKDF256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::KDF::HKDF256 that re-exports the public interface of Primitive::Symmetric::KDF::HKDF and, within its body, imports the SHA-256 HMAC instantiation under an alias. Inside the module, include: (1) a type synonym for the hash output length set to 32 bytes; (2) a constant that aliases the byte-oriented HMAC function; and (3) a function that computes HMAC over byte arrays using SHA-256. The HMAC function must be polymorphic over key length n and message length m, accept a key of n bytes and a message of m bytes, and return a 32-byte digest. Provide a precise type signature with size parameters n and m, finite-size constraints for both, and width constraints sufficient to ensure operations fit within the SHA-256 block size (64 bytes) and digest size (32 bytes) when performing indexing\/length arithmetic. Implement the function by delegating to the imported SHA-256 HMAC routine. All sequences should be 8-bit words, and the constant should reference the defined HMAC function."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::KDF::HKDF256 = Primitive::Symmetric::KDF::HKDF where\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA256 as HMAC_SHA256\n\ntype HashLen = 32\nHMAC = hmacBytes\n\nhmacBytes : {n, m} (64 >= width (8 * (64 + m)),\n                    64 >= width (8 * n), 32 >= width m, fin m, fin n) =>\n            [n][8] -> [m][8] -> [32][8]\nhmacBytes key msg = HMAC_SHA256::hmac key msg\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/AES_GCM_SIV.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Authenticated::AES_GCM_SIV that contains the following definitions and constraints: (1) Type parameters: a numeric KeySize with constraints that it is finite, divisible by 128, and either 128 or 256 bits; a type AAD with a constraint that its width is at most 44 bits. Define Mode = KeySize\/128 \u2212 1 and K = 128 + 128*Mode. Import the AES specification module, parameterized so its key size matches KeySize, and define KS as its key schedule type. (2) A function that implements AES-GCM-SIV authenticated encryption: it takes a record with fields key:[K], nonce:[96], aad:[AAD], msg:[n], for any n whose width is at most 44 bits, and returns the ciphertext of length n concatenated with a 128\u2011bit tag. It must use byte-wise reversal on inputs\/outputs where specified to match test vectors. (3) Helper functions: an AES block encryptor from a KS and a 128\u2011bit block that applies AES::cipher with byte-wise reversal; a key expansion from [K] to KS using AES::keyExpansion with byte-wise reversal; a key derivation that takes [K] and a 96\u2011bit nonce and returns a 128\u2011bit POLYVAL hash key and an expanded KS, constructed by encrypting nonce||counter blocks and assembling 64\u2011bit parts. (4) The core GCM\u2011SIV routine that, given (hash key, KS), nonce, AAD, and message blocks, computes T via POLYVAL over blockified AAD||message||lengths, derives the tag by encrypting a nonce\u2011mixed value, and produces ciphertext via counter mode seeded by the tag. (5) Counter mode over 128\u2011bit blocks with a 96\u2011bit upper and 32\u2011bit lower counter. (6) POLYVAL over GF(2^128) with dot and mult operations, using the specified irreducible polynomials. (7) Blockify\/unblockify with zero padding and byte-wise reversal, and a generic byte-wise reversal function. Include appropriate fin\/width constraints for all polymorphic sizes."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::AES_GCM_SIV where\n\nparameter\n      type KeySize : #\n  type constraint (fin KeySize, KeySize % 128 == 0, KeySize \/ 128 >= 1, KeySize \/ 128 <= 2)\n\n  type AAD : #\n  type constraint ( (36 + 8) >= width AAD )\n\ntype Mode = KeySize \/ 128 - 1\ntype K  = 128 + 128 * Mode\nimport Primitive::Symmetric::Cipher::Block::AES::Specification as AES where\n  type KeySize' = KeySize\ntype KS = AES::KeySchedule\n\n\/** Note the weird byte-swapping business (also in `blockify` and `unblockify`)\n * It is not quite clear in what format we want the inputs\/outputs, but we\n * do the swapping so that inputs\/ouputs match the test vectors at\n * https:\/\/tools.ietf.org\/html\/draft-irtf-cfrg-gcmsiv-06\n *\/\naes_gcm_siv :\n  {n} ((36 + 8) >= width n) =>\n      { key   : [K]\n      , nonce : [96]\n      , aad   : [AAD]\n      , msg   : [n]\n      } -> [n + 128]\naes_gcm_siv input = c # byteSwap t\n  where\n  (c,t) = gcm_siv_plus (derive_key k' n') n' input.aad input.msg\n  k'    = byteSwap input.key\n  n'    = byteSwap input.nonce\n\naes : KS -> [128] -> [128]\naes ks v = byteSwap (AES::cipher ks (byteSwap v))\n\nexpandKey : [K] -> KS\nexpandKey k = AES::keyExpansion (byteSwap k)\n\nderive_key : [K] -> [96] -> ([128], KS)\nderive_key K N = (mkKey parts1, expandKey (mkKey parts2))\n  where\n  parts1 # parts2 = [ drop (aes (expandKey K) (N # i)) | i <- take [ 0 ... ]  ]\n\n  mkKey : {n} (fin n) => [n][64] -> [64 * n]\n  mkKey xs = join (reverse xs)\n\ngcm_siv_plus :\n  {n} (64 >= width n) => ([128], KS) -> [96] -> [AAD] -> [n] -> ([n],[128])\ngcm_siv_plus (K1,K2) N AAD MSG = (unblockify Cs,TAG)\n  where\n\n  TAG     = aes K2 (0b0 # drop (T ^ (0 # N)))\n  T       = polyvalFrom K1 (A # M # [msg_len # aad_len]) 0\n  A       = blockify AAD\n  M       = blockify MSG\n  aad_len = `AAD: [64]\n  msg_len = `n   : [64]\n\n  _ # tUpper # tLower = TAG\n\n  Cs = counter_mode K2 (0b1 # tUpper, tLower) M\n\ncounter_mode : {n} KS -> ([96],[32]) -> [n][128] -> [n][128]\ncounter_mode K2 (tUpper,tLower) M =\n            [ aes K2 (tUpper # lower32 i) ^ m | m <- M | i <- [ 0 ... ] ]\n  where\n  lower32 i = tLower + i\n\npolyvalFrom : {n} (fin n) => [128] -> [n][128] -> [128] -> [128]\npolyvalFrom H Xs start = psums ! 0\n  where psums = [start] # [ dot (s ^ x) H | s <- psums | x <- Xs ]\n\ndot : [128] -> [128] -> [128]\ndot x y = mult x (mult y x_neg_128)\n  where x_neg_128 = <| 1 + x^^114 + x^^121 + x^^124 + x^^127 |>\n\nmult : [128] -> [128] -> [128]\nmult x y = pmod (pmult x y) irred\n  where\n  irred = <| 1 + x^^121 + x^^126 + x^^127 + x^^128 |>\n\nblockify : {n} (fin n) => [n] -> [n \/^ 128][128]\nblockify x = [ byteSwap b | b <- split (x # zero) ]\n\nunblockify : {n} (fin n) => [n \/^ 128][128] -> [n]\nunblockify xs = take (join [ byteSwap b | b <- xs ])\n\nbyteSwap : {n} (fin n) => [8 * n] -> [8 * n]\nbyteSwap xs = join (reverse (split`{each=8} xs))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/MEE_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Authenticated::MEE_CBC that contains: (1) constants for block, tag, and signing key sizes (16, 32, and 64 bytes, respectively) and type synonyms: Blk and EKey as 16-byte words, Tag as 32-byte word, SKey as 64-byte word; (2) a CBC encryption function polymorphic in a finite block count n that takes a block cipher (key \u00d7 block \u2192 block), a key, an IV block, and n plaintext blocks, and returns n ciphertext blocks by XORing each plaintext with the previous ciphertext (or IV) before encryption; (3) a CBC decryption function with the dual behavior that decrypts each ciphertext block and XORs with the previous ciphertext (or IV) to recover plaintext; (4) a padding function polymorphic in n, p, b with constraints p = 16\u00b7b \u2212 n, 16\u00b7b \u2265 n, and p fits in one byte, that appends a 32-byte tag then p bytes each equal to the value p, then splits into (b+2) blocks of 16 bytes; (5) an unpadding function under the same size\/fit constraints that joins (b+2) blocks, returns the first n bytes as message, the next 32 bytes as tag, and a boolean indicating the padding equals p copies of the byte p; (6) a property named unpad_pad_good_1000_256 that, for n = 1000 and p = 104, asserts unpadding after padding yields the original message, the original tag, and a true padding check; (7) an authenticated encryption function that, under constraints fin n, b \u2265 1, 16\u00b7b \u2265 n, and p fits in one byte with p = 16\u00b7b \u2212 n, takes a block cipher, a signing function (SKey \u00d7 n-byte message \u2192 Tag), an encryption key, a signing key, an IV, and a message, computes the tag, pads message+tag, and applies CBC encryption; (8) a corresponding decryption function (using a decryption primitive) that CBC-decrypts, unpads, verifies padding, recomputes the tag over the recovered message, and returns the message and the conjunction of both checks; (9) a property named mee_enc_dec_good_1000 that, for n = 1000 and p = 104, asserts decrypt(encrypt(message)) returns the original message and a true validity flag."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::MEE_CBC where\n\ntype blkBytes = 16\ntype Blk = [blkBytes][8]\ntype EKey = [blkBytes][8]\n\ntype tagBytes = 32\ntype Tag = [tagBytes][8]\n\ntype skeyBytes = 64\ntype SKey = [skeyBytes][8]\n\ncbc_enc : {n} (fin n) => (EKey -> Blk -> Blk) -> EKey -> Blk -> [n]Blk -> [n]Blk\ncbc_enc enc k iv ps = cs\n where cs = [ enc k (p ^ c') | p <- ps | c' <- [iv] # cs ]\n\ncbc_dec : {n} (fin n) => (EKey -> Blk -> Blk) -> EKey -> Blk -> [n]Blk -> [n]Blk\ncbc_dec dec k iv cs = [ (dec k c) ^ c' | c <- cs | c' <- [iv] # cs ]\n\npad : {n, p, b}\n      (fin n, 8 >= width p, p == blkBytes*b - n, blkBytes*b >= n) =>\n      [n][8] -> Tag -> [b+2]Blk\npad msg tag = split `{each=blkBytes} (msg # tag # padding)\n  where\n    padding = (repeat `p) : [p][8]\n\nunpad : {n, p, b}\n        (fin n, 8 >= width p, p == blkBytes*b - n, blkBytes*b >= n) =>\n        [b+2]Blk -> ([n][8], Tag, Bit)\nunpad ct = (m, t, good)\n  where\n    padded = join ct\n    m = take `{n} padded\n    t = take `{tagBytes} (drop `{n} padded)\n    p = drop `{n + tagBytes} padded\n    good = p == ((repeat `p) : [p][8]) \n\nproperty unpad_pad_good_1000_256 msg tag =\n  unpad (pad `{n=1000,p=104} msg tag) == (msg, tag, True)\n\nmee_enc : {n, p, b}\n          (fin n, p == blkBytes*b - n, 8 >= width p, b >= 1, 16*b >= n) =>\n          (Blk -> Blk -> Blk)\n       -> (SKey -> [n][8] -> Tag)\n       -> EKey -> SKey -> Blk -> [n][8] -> [b+2]Blk\nmee_enc enc sign ekey skey iv msg =\n  cbc_enc enc ekey iv (pad msg (sign skey msg))\n\nmee_dec : {n, p, b}\n          (fin n, p == blkBytes*b - n, 8 >= width (32 + p), b >= 1, 16*b >= n)\n       => (EKey -> Blk -> Blk)\n       -> (SKey -> [n][8] -> Tag)\n       -> EKey -> SKey -> Blk -> [b+2]Blk -> ([n][8], Bit)\nmee_dec dec sign ekey skey iv ct = (m, good \/\\ sign skey m == t)\n  where\n    (m, t, good) = unpad (cbc_dec dec ekey iv ct)\n\nproperty mee_enc_dec_good_1000 enc dec sign ekey skey iv msg =\n  mee_dec `{n=1000,p=104} dec sign ekey skey iv ct == (msg, True)\n    where ct = mee_enc `{n=1000,p=104} enc sign ekey skey iv msg\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/trivium.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Stream::trivium that contains the following definitions: (1) A type alias N set to 300. (2) A function Trivium_stream that takes three bit vectors of lengths 93, 84, and 111 and produces an infinite keystream, obtained from a helper that iteratively shifts three NLFSRs. (3) A polymorphic helper shift with constraints fin d and d >= 1 that, given a d-bit vector and a bit, returns the same-length vector shifted by one position, inserting the supplied bit at the most significant end and discarding the least significant bit. (4) A polymorphic helper shift_regs with constraints fin d, fin e, fin f and each length >= 1 that, given three initial registers, returns a tuple of four infinite sequences: the keystream bits and the evolving states of each register. Within it, define s1, s2, s3 as XORs of fixed taps from each register; define feedback bits t1, t2, t3 as XORs of taps within a register combined with an AND of two taps and one cross-register tap; define the keystream as s1 XOR s2 XOR s3; define each register stream by repeatedly applying shift with its corresponding feedback bit, seeded by the initial state. Tap positions must match the Trivium design: for the first register use 65, 90, 91, 92; for the second 68, 81, 82, 83, 77; for the third 65, 108, 109, 110, 86. (5) A function Trivium that takes a triple of the three registers and returns the first N keystream bits. (6) An alternative implementation Trivium_alt that derives the same keystream via sliced views over reversed-and-extended register streams with matching taps, and returns the first N bits. (7) Constants iv1, iv2, iv3 sized to the three registers, and a 300-bit constant test_keystream. (8) Properties: Trivium_correct (test IV matches expected keystream), Trivium_search (unknown IV triple matches expected keystream), Trivium_alt_correct (alt with test IV matches expected), and Trivium_alt_equivalent (first 200 bits of both implementations match for any inputs). (9) A function cycle with constraint fin n that returns true iff a given triple equals the nth register states produced by shift_regs and none of the registers are all-zero."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::trivium where\n\nTrivium_stream : [93] -> [84] -> [111] -> [inf]\nTrivium_stream R1 R2 R3 = stream\n\twhere\n\t(stream, ra, rb, rc) = shift_regs R1 R2 R3\n\ntype N = 300\nTrivium : ([93], [84], [111]) -> [N]Bit\nTrivium (reg1, reg2, reg3) = keystream\n  where\n    keystream =  take`{N} (Trivium_stream reg1 reg2 reg3)\n\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n\t\tfills = [bit]#(drop`{1} (fill >> 1))\n\nshift_regs : {d,e,f} (fin d, fin e, fin f, d >=1, e >=1, f>=1) => [d] -> [e] -> [f] -> ([inf],[inf][d],[inf][e],[inf][f])\nshift_regs r1 r2 r3 = (stream, regA, regB, regC)\n\twhere\n\n\t\ts1 = [(f1 @ 65) ^ (f1 @ 92)  | f1 <- regA]\n\t\ts2 = [(f2 @ 68) ^ (f2 @ 83)  | f2 <- regB]\n\t\ts3 = [(f3 @ 65) ^ (f3 @ 110) | f3 <- regC]\n\n\t\tstream = s1 ^ s2 ^ s3\n\t\tt1 = [(f1 @ 65) ^ ((f1 @ 90) && (f1 @ 91)) ^ (f1 @ 92) ^ (f2 @ 77) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf1 <- regA ]\n\t\tt2 = [(f2 @ 68) ^ ((f2 @ 81) && (f2 @ 82)) ^ (f2 @ 83) ^ (f3 @ 86) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf3 <- regC ]\n\t\tt3 = [(f3 @ 65) ^ ((f3 @ 108) && (f3 @ 109)) ^ (f3 @ 110) ^ (f1 @ 68)|\n\t\t\t\tf1 <- regA |\n\t\t\t\tf3 <- regC ]\n\n\t\tregA = [r1] # [shift f b| f <- regA | b <- t3]\n\t\tregB = [r2] # [shift f b| f <- regB | b <- t1]\n\t\tregC = [r3] # [shift f b| f <- regC | b <- t2]\n\nTrivium_alt : ([93], [84], [111]) -> [N]Bit\nTrivium_alt (r1, r2, r3) = take`{N} (s1 ^ s2 ^ s3)\n  where\n    a_65 = drop`{27} a_92\n    a_68 = drop`{24} a_92\n    a_90 = drop`{2} a_92\n    a_91 = drop`{1} a_92\n    a_92 = reverse r1 # t3\n\n    b_68 = drop`{15} b_83\n    b_77 = drop`{6} b_83\n    b_81 = drop`{2} b_83\n    b_82 = drop`{1} b_83\n    b_83 = reverse r2 # t1\n\n    c_65 = drop`{45} c_110\n    c_86 = drop`{24} c_110\n    c_108 = drop`{2} c_110\n    c_109 = drop`{1} c_110\n    c_110 = reverse r3 # t2\n\n    s1 = a_65 ^ a_92\n    s2 = b_68 ^ b_83\n    s3 = c_65 ^ c_110\n\n    t1 = s1 ^ (a_90 && a_91) ^ b_77\n    t2 = s2 ^ (b_81 && b_82) ^ c_86\n    t3 = s3 ^ (c_108 && c_109) ^ a_68\n\niv1 = 0b111111111111111111101111111111111111111011111111111111111110111111111111111111101111111111111\niv2 = 0b000000000000000000001000000000000000000001000000000000000000001000000000000000000001\niv3 = 0b111111111111111110111111111111111111101111111111111111111011111111111111111110111111111111100000000000000000000\n\ntest_keystream = 0b011111110111101111110100001110000000000000100010000000000000000100011000101100001110001011011010101010000100101110001111100011000110000101001011001111011101110110111010011011010110001000111101101111101100101001000111010001010011111110011100100011101010011110101001001000011100001111111100000001110001\n\nproperty Trivium_correct = (Trivium(iv1, iv2, iv3)) == test_keystream\nproperty Trivium_search (x, y, z) = (Trivium(x, y, z)) == test_keystream\nproperty Trivium_alt_correct = (Trivium_alt(iv1, iv2, iv3)) == test_keystream\nproperty Trivium_alt_equivalent x = take`{200}(Trivium_alt x) == take (Trivium x)\n\ncycle : {n} (fin n) => [n] -> ([93], [84], [111]) -> Bit\ncycle n (rA, rB, rC) =\n  (rA == regAs @ n) \/\\ (rB == regBs @ n) \/\\ (rC == regCs @ n) \/\\ rA != 0 \/\\ rB != 0 \/\\ rC != 0\n    where\n      (_, regAs, regBs, regCs) = shift_regs rA rB rC\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/bivium.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Stream::bivium that contains the following definitions: (1) A type alias N set to the natural 200. (2) A function Bivium_stream with type [93] -> [84] -> [inf] that, given two initial registers, produces an infinite keystream computed by iteratively updating two nonlinear feedback shift registers and XORing two tap-derived output streams. (3) A helper function shift with polymorphic size d, constrained fin d and d >= 1, of type [d] -> Bit -> [d], that shifts right by one and inserts the provided bit at the most significant position. (4) A function shift_regs with polymorphic sizes d and e (fin d, fin e, d >= 1, e >= 1) of type [d] -> [e] -> ([inf], [inf][d], [inf][e]) that returns the infinite keystream and infinite sequences of register states; at each step compute output taps s1 from positions 65 and 92 of the first register sequence and s2 from positions 68 and 83 of the second; compute feedback bits t1 from positions 65, 90, 91, 92 of the first and 77 of the second; compute t2 from positions 68, 81, 82, 83 of the second and 68 of the first; update the first register with t2 and the second with t1; the keystream is s1 XOR s2. (5) A function Bivium of type ([93], [84]) -> [N]Bit that returns the first N bits of Bivium_stream. (6) A function Bivium_alt of the same type that computes the same keystream using equivalent vector drops\/reversals and the same taps\/feedbacks. (7) Constants iv1, iv2, test_keystream, and suffix with the same bitvector values and sizes as in the implementation. (8) A property that Bivium(iv1, iv2) equals test_keystream. (9) A property that for unconstrained [93] and [84] seeds, Bivium returns test_keystream. (10) A property that for an unconstrained [93] seed and a [84] seed formed by appending suffix, Bivium returns test_keystream. (11) A property that Bivium_alt is equivalent to Bivium for all inputs. (12) A function cycle with type {n} (fin n) => [n] -> [93] -> [84] -> Bit that holds when, after n steps of shift_regs, both registers return to the given nonzero states. (13) Helper predicates cycle0, cycle1, cycle2, cycle3, cycle4, cycle5, and cycle10 that specialize cycle at those concrete n values."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::bivium where\n\nBivium_stream : [93] -> [84] -> [inf]\nBivium_stream R1 R2 = stream\n\twhere\n\t(stream, ra, rb) = shift_regs R1 R2\n\ntype N = 200\nBivium : ([93], [84]) -> [N]Bit\nBivium (reg1, reg2) = keystream\n  where\n    keystream =  take`{N} (Bivium_stream reg1 reg2)\n\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n\t\tfills = [bit]#(drop`{1} (fill >> 1))\n\nshift_regs : {d,e} (fin d, fin e, d >=1, e >=1) => [d] -> [e] -> ([inf],[inf][d],[inf][e])\nshift_regs r1 r2 = (stream, regA, regB)\n\twhere\n\t\ts1 = [(f1 @ 65) ^ (f1 @ 92) | f1 <- regA]\n\t\ts2 = [(f2 @ 68) ^ (f2 @ 83) | f2 <- regB]\n\n\t\tstream = s1 ^ s2\n\t\tt1 = [(f1 @ 65) ^ ((f1 @ 90) && (f1 @ 91)) ^ (f1 @ 92) ^ (f2 @ 77) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf1 <- regA ]\n\t\tt2 = [(f2 @ 68) ^ ((f2 @ 81) && (f2 @ 82)) ^ (f2 @ 83) ^ (f1 @ 68) |\n\t\t\t\tf1 <- regA |\n\t\t\t\tf2 <- regB ]\n\n\t\tregA = [r1] # [shift f b| f <- regA | b <- t2]\n\t\tregB = [r2] # [shift f b| f <- regB | b <- t1]\n\nBivium_alt : ([93], [84]) -> [N]Bit\nBivium_alt (r1, r2) = take`{N} (s1 ^ s2)\n  where\n    a_65 = drop`{27} a_92\n    a_68 = drop`{24} a_92\n    a_90 = drop`{2} a_92\n    a_91 = drop`{1} a_92\n    a_92 = reverse r1 # t2\n\n    b_68 = drop`{15} b_83\n    b_77 = drop`{6} b_83\n    b_81 = drop`{2} b_83\n    b_82 = drop`{1} b_83\n    b_83 = reverse r2 # t1\n\n    s1 = a_65 ^ a_92\n    s2 = b_68 ^ b_83\n\n    t1 = s1 ^ (a_90 && a_91) ^ b_77\n    t2 = s2 ^ (b_81 && b_82) ^ a_68\n\niv1 = 0b111110000000101010100100010001000000101010100001011111111111111100100100111111111011111111111\niv2 = 0b000000000000000000001000000000000000000001000000000000000000001000000000000000000001\n\ntest_keystream = 0b01000010000100000101110001100011111101110101110111111110100001111111100110101001000010101100100010000100001100011100000010001001100101101001011101110100000001011010001101000011001000110011111010100110\n\nsuffix = 0b000000001000000000000000000001\nproperty Bivium_correct = (Bivium(iv1, iv2)) == test_keystream\nproperty Bivium_search (x, y) = (Bivium(x, y)) == test_keystream\nproperty Bivium_search_with_suffix (x, y) = (Bivium(x, y#suffix)) == test_keystream\nproperty Bivium_alt_equivalent r = Bivium_alt r == Bivium r\n\ncycle : {n} (fin n) => [n] -> [93] -> [84] -> Bit\ncycle n rA rB =\n  (rA == regAs @ n) \/\\ (rB == regBs @ n) \/\\ rA != 0 \/\\ rB != 0\n    where\n      (_, regAs, regBs) = shift_regs rA rB\n\ncycle0 rA rB = cycle (0 : [8]) rA rB\ncycle1 rA rB = cycle (1 : [8]) rA rB\ncycle2 rA rB = cycle (2 : [8]) rA rB\ncycle3 rA rB = cycle (3 : [8]) rA rB\ncycle4 rA rB = cycle (4 : [8]) rA rB\ncycle5 rA rB = cycle (5 : [8]) rA rB\ncycle10 rA rB = cycle (10 : [8]) rA rB\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/chacha20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains the following definitions: list_definitions. Include: (1) type aliases for a 16\u00d732-bit word state, a 64-byte block, a 32-byte key, a 12-byte nonce, and a 32-bit counter; (2) a function that implements the quarter-round ARX step on four 32-bit words using addition modulo 2^32, XOR, and left-rotations by 16, 12, 8, and 7; (3) a function that performs one column round followed by one diagonal round over a 16-word state; (4) a key\/counter\/nonce expansion that builds the 16-word initial state from four fixed constant words, eight words from the key (packed little-endian from bytes), one counter word, and three words from the nonce (packed little-endian); (5) a core function that applies 20 rounds (ten of the double-round), adds the original state word-wise modulo 2^32, and outputs a 64-byte block by emitting each 32-bit word in little-endian; (6) a function that, given a non-negative integer, returns the state with the counter word incremented that many times; (7) a size-polymorphic stream generator with a fin constraint that produces the first n keystream bytes by iterating the core over successive counter values; (8) an encryption function that XORs an n-byte message with the keystream and returns n bytes; (9) private helpers for little-endian byte\/word packing, mapping, iteration, and row-joining as needed. Provide explicit Cryptol type signatures and necessary constraints for all definitions.\n\nAlso include a single property named property_name that is the conjunction of boolean checks validating: the canonical quarter-round example, the initial state expansion for a sample key\/counter\/nonce, a reference 64-byte block for that state, and three end-to-end encryption test vectors (including the all-zero case), all matching the standard specification. Do not include any solutions or concrete values; only specify the required behaviors and types."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::chacha20 where\n\ntype Round   = [16][32] type Block   = [64][8]  type Key     = [32][8]  type Nonce   = [12][8]  type Counter = [32]     \n\nqround : [4][32] -> [4][32]\nqround [ a0, b0, c0, d0 ] = [ a2, b4, c2, d4 ]\n  where\n    a1 = a0 + b0   \n    d1 = d0 ^ a1\n    d2 = d1 <<< 16\n\n    c1 = c0 + d2   \n    b1 = b0 ^ c1\n    b2 = b1 <<< 12\n\n    a2 = a1 + b2   \n    d3 = d2 ^ a2\n    d4 = d3 <<< 8\n\n    c2 = c1 + d4   \n    b3 = b2 ^ c2\n    b4 = b3 <<< 7\n\ncdround : Round -> Round\ncdround [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 ]\n      = [ z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15 ]\n  where\n        [ y0, y4, y8,  y12 ] = qround [ x0, x4, x8,  x12 ]\n    [ y1, y5, y9,  y13 ] = qround [ x1, x5, x9,  x13 ]\n    [ y2, y6, y10, y14 ] = qround [ x2, x6, x10, x14 ]\n    [ y3, y7, y11, y15 ] = qround [ x3, x7, x11, x15 ]\n\n        [ z0, z5, z10, z15 ] = qround [ y0, y5, y10, y15 ]\n    [ z1, z6, z11, z12 ] = qround [ y1, y6, y11, y12 ]\n    [ z2, z7, z8,  z13 ] = qround [ y2, y7, y8,  y13 ]\n    [ z3, z4, z9,  z14 ] = qround [ y3, y4, y9,  y14 ]\n\ncore : Round -> Block\ncore x = block\n  where\n    rounds = iterate cdround x        result = rounds @ 10              block  = blocked (x + result) \n\nkexp : Key -> Counter -> Nonce -> Round\nkexp k c n = [ c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15 ]\n  where\n\n        [ c0, c1, c2, c3 ] = [ 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574 ]\n\n        [ c4, c5, c6,  c7 ]  = map rjoin (groupBy`{4} kslice1 : [4][4][8]) : [4][32]\n    [ c8, c9, c10, c11 ] = map rjoin (groupBy`{4} kslice2 : [4][4][8]) : [4][32]\n    kslice1 = k @@ ([ 0  .. 15 ] : [16][32])     kslice2 = k @@ ([ 16 .. 31 ] : [16][32]) \n            [ c12 ] = [ c ]\n\n        [ c13, c14, c15 ] = map rjoin (groupBy`{4} n)\n\niround : [64] -> Round -> Round\niround n r = (iterate once r) @ n where\n    once [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12,    x13, x14, x15 ]\n     = [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12+1,  x13, x14, x15 ]\n\nstream : {n} (fin n) => Key -> Counter -> Nonce -> [n][8]\nstream k c n = take`{n} (join rounds)   where\n        key    = kexp k c n\n\n                    rounds = [ core (iround i key) | i <- [ 0, 1 ... ] ]\n\nencrypt : {n} (fin n) => Key -> Counter -> Nonce -> [n][8] -> [n][8]\nencrypt k c n m = m ^ (stream k c n)\n\nprivate\n  qround01 = qround in == out\n    where\n      in  = [ 0x11111111, 0x01020304, 0x9b8d6f43, 0x01234567 ]\n      out = [ 0xea2a92f4, 0xcb1cf8ce, 0x4581472e, 0x5881c4bb ]\n\n  core01 = kexp k 1 n == out\n    where\n      n = [ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x4a,\n            0x00, 0x00, 0x00, 0x00 ]\n      k = [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f ]\n      out = [ 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,\n              0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,\n              0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c,\n              0x00000001, 0x09000000, 0x4a000000, 0x00000000 ]\n\n  core02 = core (kexp k 1 n) == out\n    where\n      n = [ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x4a,\n            0x00, 0x00, 0x00, 0x00 ]\n      k = [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f ]\n      out = [ 0x10, 0xf1, 0xe7, 0xe4, 0xd1, 0x3b, 0x59, 0x15,\n              0x50, 0x0f, 0xdd, 0x1f, 0xa3, 0x20, 0x71, 0xc4,\n              0xc7, 0xd1, 0xf4, 0xc7, 0x33, 0xc0, 0x68, 0x03,\n              0x04, 0x22, 0xaa, 0x9a, 0xc3, 0xd4, 0x6c, 0x4e,\n              0xd2, 0x82, 0x64, 0x46, 0x07, 0x9f, 0xaa, 0x09,\n              0x14, 0xc2, 0xd7, 0x05, 0xd9, 0x8b, 0x02, 0xa2,\n              0xb5, 0x12, 0x9c, 0xd1, 0xde, 0x16, 0x4e, 0xb9,\n              0xcb, 0xd0, 0x83, 0xe8, 0xa2, 0x50, 0x3c, 0x4e ]\n\n  rfctest01 = encrypt zero zero zero zero\n       == [ 0x76, 0xb8, 0xe0, 0xad, 0xa0, 0xf1, 0x3d, 0x90, 0x40, 0x5d,\n            0x6a, 0xe5, 0x53, 0x86, 0xbd, 0x28, 0xbd, 0xd2, 0x19, 0xb8,\n            0xa0, 0x8d, 0xed, 0x1a, 0xa8, 0x36, 0xef, 0xcc, 0x8b, 0x77,\n            0x0d, 0xc7, 0xda, 0x41, 0x59, 0x7c, 0x51, 0x57, 0x48, 0x8d,\n            0x77, 0x24, 0xe0, 0x3f, 0xb8, 0xd8, 0x4a, 0x37, 0x6a, 0x43,\n            0xb8, 0xf4, 0x15, 0x18, 0xa1, 0x1c, 0xc3, 0x87, 0xb6, 0x69,\n            0xb2, 0xee, 0x65, 0x86 ]\n\n  rfctest02 = encrypt (zero # [1]) 1 (zero # [2]) msg == out\n    where\n      out = [ 0xa3, 0xfb, 0xf0, 0x7d, 0xf3, 0xfa, 0x2f, 0xde, 0x4f, 0x37,\n              0x6c, 0xa2, 0x3e, 0x82, 0x73, 0x70, 0x41, 0x60, 0x5d, 0x9f,\n              0x4f, 0x4f, 0x57, 0xbd, 0x8c, 0xff, 0x2c, 0x1d, 0x4b, 0x79,\n              0x55, 0xec, 0x2a, 0x97, 0x94, 0x8b, 0xd3, 0x72, 0x29, 0x15,\n              0xc8, 0xf3, 0xd3, 0x37, 0xf7, 0xd3, 0x70, 0x05, 0x0e, 0x9e,\n              0x96, 0xd6, 0x47, 0xb7, 0xc3, 0x9f, 0x56, 0xe0, 0x31, 0xca,\n              0x5e, 0xb6, 0x25, 0x0d, 0x40, 0x42, 0xe0, 0x27, 0x85, 0xec,\n              0xec, 0xfa, 0x4b, 0x4b, 0xb5, 0xe8, 0xea, 0xd0, 0x44, 0x0e,\n              0x20, 0xb6, 0xe8, 0xdb, 0x09, 0xd8, 0x81, 0xa7, 0xc6, 0x13,\n              0x2f, 0x42, 0x0e, 0x52, 0x79, 0x50, 0x42, 0xbd, 0xfa, 0x77,\n              0x73, 0xd8, 0xa9, 0x05, 0x14, 0x47, 0xb3, 0x29, 0x1c, 0xe1,\n              0x41, 0x1c, 0x68, 0x04, 0x65, 0x55, 0x2a, 0xa6, 0xc4, 0x05,\n              0xb7, 0x76, 0x4d, 0x5e, 0x87, 0xbe, 0xa8, 0x5a, 0xd0, 0x0f,\n              0x84, 0x49, 0xed, 0x8f, 0x72, 0xd0, 0xd6, 0x62, 0xab, 0x05,\n              0x26, 0x91, 0xca, 0x66, 0x42, 0x4b, 0xc8, 0x6d, 0x2d, 0xf8,\n              0x0e, 0xa4, 0x1f, 0x43, 0xab, 0xf9, 0x37, 0xd3, 0x25, 0x9d,\n              0xc4, 0xb2, 0xd0, 0xdf, 0xb4, 0x8a, 0x6c, 0x91, 0x39, 0xdd,\n              0xd7, 0xf7, 0x69, 0x66, 0xe9, 0x28, 0xe6, 0x35, 0x55, 0x3b,\n              0xa7, 0x6c, 0x5c, 0x87, 0x9d, 0x7b, 0x35, 0xd4, 0x9e, 0xb2,\n              0xe6, 0x2b, 0x08, 0x71, 0xcd, 0xac, 0x63, 0x89, 0x39, 0xe2,\n              0x5e, 0x8a, 0x1e, 0x0e, 0xf9, 0xd5, 0x28, 0x0f, 0xa8, 0xca,\n              0x32, 0x8b, 0x35, 0x1c, 0x3c, 0x76, 0x59, 0x89, 0xcb, 0xcf,\n              0x3d, 0xaa, 0x8b, 0x6c, 0xcc, 0x3a, 0xaf, 0x9f, 0x39, 0x79,\n              0xc9, 0x2b, 0x37, 0x20, 0xfc, 0x88, 0xdc, 0x95, 0xed, 0x84,\n              0xa1, 0xbe, 0x05, 0x9c, 0x64, 0x99, 0xb9, 0xfd, 0xa2, 0x36,\n              0xe7, 0xe8, 0x18, 0xb0, 0x4b, 0x0b, 0xc3, 0x9c, 0x1e, 0x87,\n              0x6b, 0x19, 0x3b, 0xfe, 0x55, 0x69, 0x75, 0x3f, 0x88, 0x12,\n              0x8c, 0xc0, 0x8a, 0xaa, 0x9b, 0x63, 0xd1, 0xa1, 0x6f, 0x80,\n              0xef, 0x25, 0x54, 0xd7, 0x18, 0x9c, 0x41, 0x1f, 0x58, 0x69,\n              0xca, 0x52, 0xc5, 0xb8, 0x3f, 0xa3, 0x6f, 0xf2, 0x16, 0xb9,\n              0xc1, 0xd3, 0x00, 0x62, 0xbe, 0xbc, 0xfd, 0x2d, 0xc5, 0xbc,\n              0xe0, 0x91, 0x19, 0x34, 0xfd, 0xa7, 0x9a, 0x86, 0xf6, 0xe6,\n              0x98, 0xce, 0xd7, 0x59, 0xc3, 0xff, 0x9b, 0x64, 0x77, 0x33,\n              0x8f, 0x3d, 0xa4, 0xf9, 0xcd, 0x85, 0x14, 0xea, 0x99, 0x82,\n              0xcc, 0xaf, 0xb3, 0x41, 0xb2, 0x38, 0x4d, 0xd9, 0x02, 0xf3,\n              0xd1, 0xab, 0x7a, 0xc6, 0x1d, 0xd2, 0x9c, 0x6f, 0x21, 0xba,\n              0x5b, 0x86, 0x2f, 0x37, 0x30, 0xe3, 0x7c, 0xfd, 0xc4, 0xfd,\n              0x80, 0x6c, 0x22, 0xf2, 0x21 ]\n\n      msg = [ 0x41, 0x6e, 0x79, 0x20, 0x73, 0x75, 0x62, 0x6d, 0x69, 0x73,\n              0x73, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68,\n              0x65, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x69, 0x6e, 0x74,\n              0x65, 0x6e, 0x64, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62,\n              0x75, 0x74, 0x6f, 0x72, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x70,\n              0x75, 0x62, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n              0x20, 0x61, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6f, 0x72,\n              0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61,\n              0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x49, 0x6e, 0x74,\n              0x65, 0x72, 0x6e, 0x65, 0x74, 0x2d, 0x44, 0x72, 0x61, 0x66,\n              0x74, 0x20, 0x6f, 0x72, 0x20, 0x52, 0x46, 0x43, 0x20, 0x61,\n              0x6e, 0x64, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x73, 0x74, 0x61,\n              0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x61, 0x64,\n              0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74,\n              0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x20, 0x49, 0x45, 0x54,\n              0x46, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79,\n              0x20, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64,\n              0x65, 0x72, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x20, 0x22, 0x49,\n              0x45, 0x54, 0x46, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69,\n              0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x2e, 0x20, 0x53,\n              0x75, 0x63, 0x68, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6d,\n              0x65, 0x6e, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75,\n              0x64, 0x65, 0x20, 0x6f, 0x72, 0x61, 0x6c, 0x20, 0x73, 0x74,\n              0x61, 0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x69,\n              0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x73, 0x65, 0x73,\n              0x73, 0x69, 0x6f, 0x6e, 0x73, 0x2c, 0x20, 0x61, 0x73, 0x20,\n              0x77, 0x65, 0x6c, 0x6c, 0x20, 0x61, 0x73, 0x20, 0x77, 0x72,\n              0x69, 0x74, 0x74, 0x65, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20,\n              0x65, 0x6c, 0x65, 0x63, 0x74, 0x72, 0x6f, 0x6e, 0x69, 0x63,\n              0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61,\n              0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x6d, 0x61, 0x64, 0x65,\n              0x20, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x69,\n              0x6d, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x70, 0x6c, 0x61, 0x63,\n              0x65, 0x2c, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61,\n              0x72, 0x65, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,\n              0x65, 0x64, 0x20, 0x74, 0x6f ]\n\n  rfctest03 = encrypt key 42 (zero # [2]) msg == out\n    where\n      key = [ 0x1c, 0x92, 0x40, 0xa5, 0xeb, 0x55, 0xd3, 0x8a, 0xf3, 0x33,\n              0x88, 0x86, 0x04, 0xf6, 0xb5, 0xf0, 0x47, 0x39, 0x17, 0xc1,\n              0x40, 0x2b, 0x80, 0x09, 0x9d, 0xca, 0x5c, 0xbc, 0x20, 0x70,\n              0x75, 0xc0 ]\n      out = [ 0x27, 0x54, 0x77, 0x61, 0x73, 0x20, 0x62, 0x72, 0x69, 0x6c,\n              0x6c, 0x69, 0x67, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x73, 0x6c, 0x69, 0x74, 0x68, 0x79, 0x20,\n              0x74, 0x6f, 0x76, 0x65, 0x73, 0x0a, 0x44, 0x69, 0x64, 0x20,\n              0x67, 0x79, 0x72, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x67,\n              0x69, 0x6d, 0x62, 0x6c, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x77, 0x61, 0x62, 0x65, 0x3a, 0x0a, 0x41,\n              0x6c, 0x6c, 0x20, 0x6d, 0x69, 0x6d, 0x73, 0x79, 0x20, 0x77,\n              0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6f,\n              0x72, 0x6f, 0x67, 0x6f, 0x76, 0x65, 0x73, 0x2c, 0x0a, 0x41,\n              0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x6f, 0x6d,\n              0x65, 0x20, 0x72, 0x61, 0x74, 0x68, 0x73, 0x20, 0x6f, 0x75,\n              0x74, 0x67, 0x72, 0x61, 0x62, 0x65, 0x2e ]\n\n      msg = [ 0x62, 0xe6, 0x34, 0x7f, 0x95, 0xed, 0x87, 0xa4, 0x5f, 0xfa,\n              0xe7, 0x42, 0x6f, 0x27, 0xa1, 0xdf, 0x5f, 0xb6, 0x91, 0x10,\n              0x04, 0x4c, 0x0d, 0x73, 0x11, 0x8e, 0xff, 0xa9, 0x5b, 0x01,\n              0xe5, 0xcf, 0x16, 0x6d, 0x3d, 0xf2, 0xd7, 0x21, 0xca, 0xf9,\n              0xb2, 0x1e, 0x5f, 0xb1, 0x4c, 0x61, 0x68, 0x71, 0xfd, 0x84,\n              0xc5, 0x4f, 0x9d, 0x65, 0xb2, 0x83, 0x19, 0x6c, 0x7f, 0xe4,\n              0xf6, 0x05, 0x53, 0xeb, 0xf3, 0x9c, 0x64, 0x02, 0xc4, 0x22,\n              0x34, 0xe3, 0x2a, 0x35, 0x6b, 0x3e, 0x76, 0x43, 0x12, 0xa6,\n              0x1a, 0x55, 0x32, 0x05, 0x57, 0x16, 0xea, 0xd6, 0x96, 0x25,\n              0x68, 0xf8, 0x7d, 0x3f, 0x3f, 0x77, 0x04, 0xc6, 0xa8, 0xd1,\n              0xbc, 0xd1, 0xbf, 0x4d, 0x50, 0xd6, 0x15, 0x4b, 0x6d, 0xa7,\n              0x31, 0xb1, 0x87, 0xb5, 0x8d, 0xfd, 0x72, 0x8a, 0xfa, 0x36,\n              0x75, 0x7a, 0x79, 0x7a, 0xc1, 0x88, 0xd1 ]\n\nproperty allTestsPass =\n  and\n  [     qround01, core01, core02\n      , rfctest01, rfctest02, rfctest03\n  ]\n\nprivate\n      blocked : Round -> Block\n  blocked x = join (map toBytes x)\n    where\n                        toBytes : [32] -> [4][8]\n      toBytes v = reverse (groupBy`{8} v)\n\n    map : { a, b, c }\n        (a -> b) -> [c]a -> [c]b\n  map f xs = [ f x | x <- xs ]\n\n          iterate : { a } (a -> a) -> a -> [inf]a\n  iterate f x = [x] # [ f v | v <- iterate f x ]\n    where\n            xs = [x] # [ f v | v <- xs ]\n\n        rjoin : {a, b, c}\n        ( fin a, fin c\n        ) => [c][a]b -> [a * c]b\n  rjoin x = join (reverse x)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/ZUC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Stream::ZUC that contains the following definitions, with exactly the same types and behaviors as the implementation: (1) A boolean constant version1_5 that selects the newer standard\u2019s behavior. (2) add: a polymorphic function (finite length parameter) that consumes a vector of 31\u2011bit words and returns their 31\u2011bit modular sum using a carry from a 32\u2011bit intermediate; include an internal accumulator semantics as in a running sum. (3) A type alias LFSR as a 16\u2011element vector of 31\u2011bit words. (4) LFSRWithInitializationMode: given a 31\u2011bit input and an LFSR, compute the next LFSR by a linear feedback formed from selected taps and left shifts; combine with the input using either modular addition or XOR depending on version1_5; replace zero with a fixed nonzero constant. (5) LFSRWithWorkMode: same feedback update without external input and with zero\u2011replacement. (6) BitReorganization: assemble four 32\u2011bit words from high\/low halves of selected LFSR elements. (7) F: a nonlinear function taking three 32\u2011bit inputs and two 32\u2011bit registers, performing modular additions\/XORs, splitting into halves, applying L1\/L2 (XORs of left rotations by fixed offsets), then S (bytewise S\u2011boxes), returning one word and updated registers. (8) S: map a 32\u2011bit word via S0..S3; define S0,S1,S2,S3: [8]->[8] with S2=S0 and S3=S1, and constants S0Table,S1Table (256 entries of 8 bits) with the same values and types. (9) L1,L2: [32]->[32] linear transforms as XORs of left rotations by fixed offsets. (10) LoadKey: build the initial LFSR from a 128\u2011bit key and 128\u2011bit IV by interleaving bytes with fixed 15\u2011bit constants. (11) A type alias ZUC as (LFSR,[32],[32]). (12) InitializeZUC: produce an infinite stream of internal states via self\u2011recurrence using BitReorganization, F, and the version flag\u2019s mixing rule. (13) WorkingStage: one state update with no output. (14) ProductionStage: output a 32\u2011bit word and next state. (15) ZUC: keystream generator returning an infinite stream of 32\u2011bit words, discarding the first word. Also, define a property that checks S on a specific 32\u2011bit constant yields a specific 32\u2011bit constant (example8); define a property that the initial keystream words for given test inputs match published values (ZUC_TestVectors); define a property that LoadKey yields specified initial LFSRs for given inputs (LoadKey_TestVectors); define a property stating distinct IVs produce distinct states after one initialization step for any key (ZUC_isResistantToCollisionAttack)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::ZUC where\n\nversion1_5 : Bit\nversion1_5 = True\n\nadd : {a} (fin a) => [a][31] -> [31]\nadd xs =\n    sums ! 0\n    where\n      sums =\n          [0] #\n          [plus (s, x) | s <- sums\n                       | x <- xs]\n            plus : ([31], [31]) -> [31]\n      plus (a, b) =\n          if sab @ 0 then sab' + 1 else sab'\n          where\n            sab : [32]\n            sab = ((zero : [1]) # a) + ((zero : [1]) # b)\n            sab' : [31]\n            sab' = drop sab\n\ntype LFSR = [16][31]\n\nLFSRWithInitializationMode : ([31], LFSR) -> LFSR\nLFSRWithInitializationMode (u, ss) =\n    ss @@ [1 .. 15] # [s16]\n    where\n      v = add [s <<< c | s <- ss @@ [15, 13, 10, 4, 0, 0]\n                       | c <- [15, 17, 21, 20, 8, 0]]\n      vu = if version1_5 then add [v, u] else v ^ u\n      s16 = if vu == 0 then `0x7FFFFFFF else vu\n\nLFSRWithWorkMode : LFSR -> LFSR\nLFSRWithWorkMode ss =\n    ss @@ [1 .. 15] # [s16]\n    where\n      v = add [s <<< c | s <- ss @@ [15, 13, 10, 4, 0, 0]\n                       | c <- [15, 17, 21, 20, 8, 0]]\n      s16 = if v == 0 then `0x7FFFFFFF else v\n\nBitReorganization : LFSR -> [4][32]\nBitReorganization ss =\n    [ hi s15 # lo s14\n    , lo s11 # hi s9\n    , lo s7  # hi s5\n    , lo s2  # hi s0]\n    where\n      lo : [31] -> [16]\n      hi : [31] -> [16]\n      lo x = x @@ [15 .. 30]\n      hi x = x @@ [0  .. 15]\n      [s0, s2, s5, s7, s9, s11, s14, s15] = ss @@ [0, 2, 5, 7, 9, 11, 14, 15]\n\nF : ([3][32], [2][32]) -> ([32], [2][32])\nF ([X0, X1, X2], [R1, R2]) =\n    (W, [R1', R2'])\n    where\n      W = (X0 ^ R1) + R2\n      W1 = R1 + X1\n      W2 = R2 ^ X2\n      [W1H, W1L] = split W1\n      [W2H, W2L] = split W2\n      R1' = S (L1 (W1L # W2H))\n      R2' = S (L2 (W2L # W1H))\n\nS : [32] -> [32]\nS X =\n    Y0 # Y1 # Y2 # Y3\n    where\n      [X0, X1, X2, X3] = split X\n      [Y0, Y1, Y2, Y3] = [S0 X0, S1 X1, S2 X2, S3 X3]\n\nproperty example8 = S(0x12345678) == 0xF9C05A4E\n\nS0 : [8] -> [8]\nS1 : [8] -> [8]\nS2 : [8] -> [8]\nS3 : [8] -> [8]\nS0 x = S0Table @ x\nS1 x = S1Table @ x\nS2 = S0\nS3 = S1\n\nS0Table : [256][8]\nS0Table =\n    [0x3E, 0x72, 0x5B, 0x47, 0xCA, 0xE0, 0x00, 0x33, 0x04, 0xD1, 0x54,\n     0x98, 0x09, 0xB9, 0x6D, 0xCB, 0x7B, 0x1B, 0xF9, 0x32, 0xAF, 0x9D,\n     0x6A, 0xA5, 0xB8, 0x2D, 0xFC, 0x1D, 0x08, 0x53, 0x03, 0x90, 0x4D,\n     0x4E, 0x84, 0x99, 0xE4, 0xCE, 0xD9, 0x91, 0xDD, 0xB6, 0x85, 0x48,\n     0x8B, 0x29, 0x6E, 0xAC, 0xCD, 0xC1, 0xF8, 0x1E, 0x73, 0x43, 0x69,\n     0xC6, 0xB5, 0xBD, 0xFD, 0x39, 0x63, 0x20, 0xD4, 0x38, 0x76, 0x7D,\n     0xB2, 0xA7, 0xCF, 0xED, 0x57, 0xC5, 0xF3, 0x2C, 0xBB, 0x14, 0x21,\n     0x06, 0x55, 0x9B, 0xE3, 0xEF, 0x5E, 0x31, 0x4F, 0x7F, 0x5A, 0xA4,\n     0x0D, 0x82, 0x51, 0x49, 0x5F, 0xBA, 0x58, 0x1C, 0x4A, 0x16, 0xD5,\n     0x17, 0xA8, 0x92, 0x24, 0x1F, 0x8C, 0xFF, 0xD8, 0xAE, 0x2E, 0x01,\n     0xD3, 0xAD, 0x3B, 0x4B, 0xDA, 0x46, 0xEB, 0xC9, 0xDE, 0x9A, 0x8F,\n     0x87, 0xD7, 0x3A, 0x80, 0x6F, 0x2F, 0xC8, 0xB1, 0xB4, 0x37, 0xF7,\n     0x0A, 0x22, 0x13, 0x28, 0x7C, 0xCC, 0x3C, 0x89, 0xC7, 0xC3, 0x96,\n     0x56, 0x07, 0xBF, 0x7E, 0xF0, 0x0B, 0x2B, 0x97, 0x52, 0x35, 0x41,\n     0x79, 0x61, 0xA6, 0x4C, 0x10, 0xFE, 0xBC, 0x26, 0x95, 0x88, 0x8A,\n     0xB0, 0xA3, 0xFB, 0xC0, 0x18, 0x94, 0xF2, 0xE1, 0xE5, 0xE9, 0x5D,\n     0xD0, 0xDC, 0x11, 0x66, 0x64, 0x5C, 0xEC, 0x59, 0x42, 0x75, 0x12,\n     0xF5, 0x74, 0x9C, 0xAA, 0x23, 0x0E, 0x86, 0xAB, 0xBE, 0x2A, 0x02,\n     0xE7, 0x67, 0xE6, 0x44, 0xA2, 0x6C, 0xC2, 0x93, 0x9F, 0xF1, 0xF6,\n     0xFA, 0x36, 0xD2, 0x50, 0x68, 0x9E, 0x62, 0x71, 0x15, 0x3D, 0xD6,\n     0x40, 0xC4, 0xE2, 0x0F, 0x8E, 0x83, 0x77, 0x6B, 0x25, 0x05, 0x3F,\n     0x0C, 0x30, 0xEA, 0x70, 0xB7, 0xA1, 0xE8, 0xA9, 0x65, 0x8D, 0x27,\n     0x1A, 0xDB, 0x81, 0xB3, 0xA0, 0xF4, 0x45, 0x7A, 0x19, 0xDF, 0xEE,\n     0x78, 0x34, 0x60]\n\nS1Table : [256][8]\nS1Table =\n    [0x55, 0xC2, 0x63, 0x71, 0x3B, 0xC8, 0x47, 0x86, 0x9F, 0x3C, 0xDA,\n     0x5B, 0x29, 0xAA, 0xFD, 0x77, 0x8C, 0xC5, 0x94, 0x0C, 0xA6, 0x1A,\n     0x13, 0x00, 0xE3, 0xA8, 0x16, 0x72, 0x40, 0xF9, 0xF8, 0x42, 0x44,\n     0x26, 0x68, 0x96, 0x81, 0xD9, 0x45, 0x3E, 0x10, 0x76, 0xC6, 0xA7,\n     0x8B, 0x39, 0x43, 0xE1, 0x3A, 0xB5, 0x56, 0x2A, 0xC0, 0x6D, 0xB3,\n     0x05, 0x22, 0x66, 0xBF, 0xDC, 0x0B, 0xFA, 0x62, 0x48, 0xDD, 0x20,\n     0x11, 0x06, 0x36, 0xC9, 0xC1, 0xCF, 0xF6, 0x27, 0x52, 0xBB, 0x69,\n     0xF5, 0xD4, 0x87, 0x7F, 0x84, 0x4C, 0xD2, 0x9C, 0x57, 0xA4, 0xBC,\n     0x4F, 0x9A, 0xDF, 0xFE, 0xD6, 0x8D, 0x7A, 0xEB, 0x2B, 0x53, 0xD8,\n     0x5C, 0xA1, 0x14, 0x17, 0xFB, 0x23, 0xD5, 0x7D, 0x30, 0x67, 0x73,\n     0x08, 0x09, 0xEE, 0xB7, 0x70, 0x3F, 0x61, 0xB2, 0x19, 0x8E, 0x4E,\n     0xE5, 0x4B, 0x93, 0x8F, 0x5D, 0xDB, 0xA9, 0xAD, 0xF1, 0xAE, 0x2E,\n     0xCB, 0x0D, 0xFC, 0xF4, 0x2D, 0x46, 0x6E, 0x1D, 0x97, 0xE8, 0xD1,\n     0xE9, 0x4D, 0x37, 0xA5, 0x75, 0x5E, 0x83, 0x9E, 0xAB, 0x82, 0x9D,\n     0xB9, 0x1C, 0xE0, 0xCD, 0x49, 0x89, 0x01, 0xB6, 0xBD, 0x58, 0x24,\n     0xA2, 0x5F, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xB8, 0x95, 0xE4,\n     0xD0, 0x91, 0xC7, 0xCE, 0xED, 0x0F, 0xB4, 0x6F, 0xA0, 0xCC, 0xF0,\n     0x02, 0x4A, 0x79, 0xC3, 0xDE, 0xA3, 0xEF, 0xEA, 0x51, 0xE6, 0x6B,\n     0x18, 0xEC, 0x1B, 0x2C, 0x80, 0xF7, 0x74, 0xE7, 0xFF, 0x21, 0x5A,\n     0x6A, 0x54, 0x1E, 0x41, 0x31, 0x92, 0x35, 0xC4, 0x33, 0x07, 0x0A,\n     0xBA, 0x7E, 0x0E, 0x34, 0x88, 0xB1, 0x98, 0x7C, 0xF3, 0x3D, 0x60,\n     0x6C, 0x7B, 0xCA, 0xD3, 0x1F, 0x32, 0x65, 0x04, 0x28, 0x64, 0xBE,\n     0x85, 0x9B, 0x2F, 0x59, 0x8A, 0xD7, 0xB0, 0x25, 0xAC, 0xAF, 0x12,\n     0x03, 0xE2, 0xF2]\n\nL1 : [32] -> [32]\nL1 X = X ^ X <<< 2 ^ X <<< 10 ^ X <<< 18 ^ X <<< 24\n\nL2 : [32] -> [32]\nL2 X = X ^ X <<< 8 ^ X <<< 14 ^ X <<< 22 ^ X <<< 30\n\nLoadKey : ([128], [128]) -> LFSR\nLoadKey (key, iv) =\n    [k # d # i | k <- ks\n               | i <- is\n               | d <- ds]\n    where\n      ks : [16][8]\n      ks = split key\n      is : [16][8]\n      is = split iv\n      ds : [16][15]\n      ds =\n          [ 0b100010011010111, 0b010011010111100\n          , 0b110001001101011, 0b001001101011110\n          , 0b101011110001001, 0b011010111100010\n          , 0b111000100110101, 0b000100110101111\n          , 0b100110101111000, 0b010111100010011\n          , 0b110101111000100, 0b001101011110001\n          , 0b101111000100110, 0b011110001001101\n          , 0b111100010011010, 0b100011110101100\n          ]\n\ntype ZUC = (LFSR, [32], [32])\n\nInitializeZUC : ([128], [128]) -> [inf]ZUC\nInitializeZUC (key, iv) =\n    outs\n    where\n      initLFSR = LoadKey (key, iv)\n      outs = [(initLFSR, 0, 0)] # [step out | out <- outs]\n      step (lfsr, R1, R2) =\n          (LFSRWithInitializationMode (drop (w >> 1), lfsr), R1', R2')\n          where\n            [X0, X1, X2, X3] = BitReorganization lfsr\n            (w', [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n            w = if version1_5 then w' else w' ^ X3\n\n\/\/ Section 3.6.2\nWorkingStage : ZUC -> ZUC\nWorkingStage (lfsr, R1, R2) =\n    (lfsr', R1', R2')\n    where\n      [X0, X1, X2, _] = BitReorganization lfsr\n      (_, [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n      lfsr' = LFSRWithWorkMode lfsr\n\n\/\/ Section 3.6.2\nProductionStage : ZUC -> ([32], ZUC)\nProductionStage (lfsr, R1, R2) =\n    (w ^ X3, (lfsr', R1', R2'))\n    where\n      [X0, X1, X2, X3] = BitReorganization lfsr\n      (w, [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n      lfsr' = LFSRWithWorkMode lfsr\n\n\/\/ ZUC API\nZUC : [128] -> [128] -> [inf][32]\nZUC key iv =\n    tail [w | (w, _) <- zucs]\n    where\n      initZuc = WorkingStage (InitializeZUC (key, iv) @ 32)\n      zucs = [(zero, initZuc)] # [ProductionStage zuc | (_, zuc) <- zucs]\n\n\/\/ Test vectors\nproperty ZUC_TestVectors =\n    t1 \/\\ t2 \/\\ t3 \/\\ t4\n    where\n      t1 = take (ZUC zero    zero   ) == [0x27BEDE74, 0x018082DA]\n      t2 = take (ZUC (~zero) (~zero)) == [0x0657CFA0, 0x7096398B]\n      t3 = take (ZUC (join [ 0x3D, 0x4C, 0x4B, 0xE9, 0x6A, 0x82, 0xFD, 0xAE\n                           , 0xB5, 0x8F, 0x64, 0x1D, 0xB1, 0x7B, 0x45, 0x5B\n                           ])\n                     (join [ 0x84, 0x31, 0x9A, 0xA8, 0xDE, 0x69, 0x15, 0xCA\n                           , 0x1F, 0x6B, 0xDA, 0x6B, 0xFB, 0xD8, 0xC7, 0x66\n                           ])) == [0x14F1C272, 0x3279C419]\n      t4 = take ks # [ks @ 1999] == [0xED4400E7, 0x0633E5C5, 0x7A574CDB]\n        where\n          ks = ZUC (join [ 0x4D, 0x32, 0x0B, 0xFA, 0xD4, 0xC2, 0x85, 0xBF\n                         , 0xD6, 0xB8, 0xBD, 0x00, 0xF3, 0x9D, 0x8B, 0x41\n                         ])\n                   (join [ 0x52, 0x95, 0x9D, 0xAB, 0xA0, 0xBF, 0x17, 0x6E\n                         , 0xCE, 0x2D, 0xC3, 0x15, 0x04, 0x9E, 0xB5, 0x74\n                         ])\n\n\/\/ 3.3-3.6 of the implementor's test data document lists \"LFSR-state at the\n\/\/ beginning\", which is immediately after running LoadKey.\nproperty LoadKey_TestVectors =\n    [ LoadKey(k, iv) == lfsr0\n    | k <- ks\n    | iv <- ivs\n    | lfsr0 <- lfsr0s\n    ] == ~0\n  where\n    ks = [ 0\n         , ~0\n         , 0x3d4c4be96a82fdaeb58f641db17b455b\n         , 0x4d320bfad4c285bfd6b8bd00f39d8b41\n         ]\n    ivs = [ 0\n          , ~0\n          , 0x84319aa8de6915ca1f6bda6bfbd8c766\n          , 0x52959daba0bf176ece2dc315049eb574\n          ]\n    lfsr0s = [ [ `0x0044d700, `0x0026bc00, `0x00626b00, `0x00135e00\n               , `0x00578900, `0x0035e200, `0x00713500, `0x0009af00\n               , `0x004d7800, `0x002f1300, `0x006bc400, `0x001af100\n               , `0x005e2600, `0x003c4d00, `0x00789a00, `0x0047ac00\n               ]\n             , [ `0x7fc4d7ff, `0x7fa6bcff, `0x7fe26bff, `0x7f935eff\n               , `0x7fd789ff, `0x7fb5e2ff, `0x7ff135ff, `0x7f89afff\n               , `0x7fcd78ff, `0x7faf13ff, `0x7febc4ff, `0x7f9af1ff\n               , `0x7fde26ff, `0x7fbc4dff, `0x7ff89aff, `0x7fc7acff\n               ]\n             , [ `0x1ec4d784, `0x2626bc31, `0x25e26b9a, `0x74935ea8\n               , `0x355789de, `0x4135e269, `0x7ef13515, `0x5709afca\n               , `0x5acd781f, `0x47af136b, `0x326bc4da, `0x0e9af16b\n               , `0x58de26fb, `0x3dbc4dd8, `0x22f89ac7, `0x2dc7ac66\n               ]\n             , [ `0x26c4d752, `0x1926bc95, `0x05e26b9d, `0x7d135eab\n               , `0x6a5789a0, `0x6135e2bf, `0x42f13517, `0x5f89af6e\n               , `0x6b4d78ce, `0x5c2f132d, `0x5eebc4c3, `0x001af115\n               , `0x79de2604, `0x4ebc4d9e, `0x45f89ab5, `0x20c7ac74\n               ]\n             ]\n\nproperty ZUC_isResistantToCollisionAttack k iv1 iv2 =\n    if iv1 != iv2\n    then InitializeZUC (k, iv1) @ 1 != InitializeZUC (k, iv2) @ 1\n    else True\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/McMambo.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::McMambo that contains the following definitions with precise type signatures and constraints: type synonyms for a 32-bit word, a 4\u00d74 state of words, an 8-word key, and 16-word tweak and block. Implement bitwise functions nand and nor polymorphic over bitvector length, and introduce infix aliases for NAND, NOR, XOR, AND, and OR. Define a left-rotate function over words taking a word-sized rotation count. Define a tweak injection that conditionally xors a split tweak into a state based on a round index; include properties proving it is injective on states and that applying it twice with the same inputs returns the original state. Define a 4-word nonlinear layer using the Boolean ops and rotations, with a property checking injectivity. Define diffusion layers that apply this nonlinear layer across rows and columns via transposes, plus verbose equivalents; add properties asserting extensional equality between compact and verbose forms. Add a Boolean predicate stating that applying the alternate diffusion after the primary yields the original state (not currently valid). Define round-key injection that xors a structured 4\u00d74 mask derived from key words and a round counter, with a property showing self-inverse behavior. Define one-round and iterated 12-round core permutations (forward and inverse schedules); add a Boolean predicate that the inverse schedule after the forward recovers the input. Provide byte\/word pack and unpack functions parameterized by the number of words, with round-trip properties. Provide padding functions with fin constraints and ceiling-division relations. Define block cipher functions over blocks and byte-level wrappers, plus a known-answer test property comparing to a fixed constant. Include a partial AEAD skeleton with unspecified parts left undefined."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::McMambo where\n\ntype word = [32]\ntype state = [4][4]word\ntype key = [8]word\ntype tweak = [16]word\ntype block = [16]word\n\nnand : {a} [a] -> [a] -> [a]\nnand x y = ~(x && y)\n\nnor : {a} [a] -> [a] -> [a]\nnor x y = ~(x || y)\n\n(\u2191) = nand\n(\u2193) = nor\n(\u2295) = (^)\n(\u2227) = (&&)\n(\u2228) = (||)\n\nR : (word, word) -> word\nR (x, c) = x <<< c\n\nT : word -> tweak -> state -> state\nT n t s = s \u2295 (if n == 5 then split t else zero)\n\nproperty T_bijective t n s s' =\n  (s != s') == (T n t s != T n t s')\n\n\/**\n * ```repl\n * :prove T_inverse\n * ```\n *\/\nproperty T_inverse n t s =\n  T n t (T n t s) == s\n\nQ : [4]word -> [4]word\nQ [x0, x1, x2, x3] = [y0, y1, y2, y3]\n  where\n    y1 = x1 \u2295 R (x0 \u2227 x2, 7)\n    y2 = x2 \u2295 R (x0 \u2228 x3, 9)\n    y3 = x3 \u2295 R (y1 \u2191 x0, 13)\n    y0 = x0 \u2295 R (y1 \u2193 y2, 18)\n\n\/**\n * ```repl\n * :prove Q_bijective\n * ```\n *\/\nproperty Q_bijective x x' =\n  (x != x') == (Q x != Q x')\n\nD : state -> state\nD X = Z\n  where\n    Y = transpose [ Q xs | xs <- X ]\n    Z = transpose [ Q ys | ys <- Y ]\n\nD' : state -> state\nD' X = Z\n  where\n    Y = [ Q xs | xs <- transpose X ]\n    Z = [ Q ys | ys <- transpose Y ]\n\nD_verbose : state -> state\nD_verbose [ [ x0,  x1,  x2,  x3]\n          , [ x4,  x5,  x6,  x7]\n          , [ x8,  x9, x10, x11]\n          , [x12, x13, x14, x15] ] = Z\n  where\n    [ y0,  y1,  y2,  y3] = Q [ x0,  x1,  x2,  x3]\n    [ y4,  y5,  y6,  y7] = Q [ x4,  x5,  x6,  x7]\n    [ y8,  y9, y10, y11] = Q [ x8,  x9, x10, x11]\n    [y12, y13, y14, y15] = Q [x12, x13, x14, x15]\n    [ z0,  z4,  z8, z12] = Q [ y0,  y4,  y8, y12]\n    [ z1,  z5,  z9, z13] = Q [ y1,  y5,  y9, y13]\n    [ z2,  z6, z10, z14] = Q [ y2,  y6, y10, y14]\n    [ z3,  z7, z11, z15] = Q [ y3,  y7, y11, y15]\n    Z = [ [ z0,  z1,  z2,  z3]\n        , [ z4,  z5,  z6,  z7]\n        , [ z8,  z9, z10, z11]\n        , [z12, z13, z14, z15] ]\n\nD'_verbose : state -> state\nD'_verbose [ [ x0,  x1,  x2,  x3]\n           , [ x4,  x5,  x6,  x7]\n           , [ x8,  x9, x10, x11]\n           , [x12, x13, x14, x15] ] = Z\n  where\n    [ y0,  y4,  y8, y12] = Q [ x0,  x4,  x8, x12]\n    [ y1,  y5,  y9, y13] = Q [ x1,  x5,  x9, x13]\n    [ y2,  y6, y10, y14] = Q [ x2,  x6, x10, x14]\n    [ y3,  y7, y11, y15] = Q [ x3,  x7, x11, x15]\n    [ z0,  z1,  z2,  z3] = Q [ y0,  y1,  y2,  y3]\n    [ z4,  z5,  z6,  z7] = Q [ y4,  y5,  y6,  y7]\n    [ z8,  z9, z10, z11] = Q [ y8,  y9, y10, y11]\n    [z12, z13, z14, z15] = Q [y12, y13, y14, y15]\n    Z = [ [ z0,  z1,  z2,  z3]\n        , [ z4,  z5,  z6,  z7]\n        , [ z8,  z9, z10, z11]\n        , [z12, z13, z14, z15] ]\n\nproperty D_matches =\n  D === D_verbose\n\nproperty D'_matches =\n  D' === D'_verbose\n\n\/\/ Not yet true\n\/*property*\/\nD_D'_correct s =\n  D' (D s) == s\n\nK : key -> word -> state -> state\nK [k0, k1, k2, k3, k4, k5, k6, k7] j x =\n  x \u2295 [ [  j, k0,  0, k1 ]\n      , [ k2,  j, k3,  0 ]\n      , [  0, k4,  j, k5 ]\n      , [ k6,  0, k7,  j ]\n      ]\n\n\/**\n * ```repl\n * :prove K_inverse\n * ```\n *\/\nproperty K_inverse k j s =\n  K k j (K k j s) == s\n\nC1 : key -> tweak -> state -> state\nC1 k t s0 = K k 0 (T 1 t (D (K k 1 (T 0 t (D (K k 0 s0))))))\n\nC : key -> tweak -> state -> state\nC k t s0 = K k 0 (ss!0)\n  where\n    ss : [13]state\n    ss = [s0] # [ T n t (D (K k n s)) | s <- ss | n <- [0..11] ]\n\nC' : key -> tweak -> state -> state\nC' k t s0 = ss!0\n  where\n    ss : [13]state\n    ss = [K k 0 s0] # [ K k n (D' (T n t s)) | s <- ss | n <- reverse [0..11] ]\n\nfrom_bytes : {a} [a*4][8] -> [a][32]\nfrom_bytes bytes = [ join (reverse xs) | (xs : [4][8]) <- blocks ]\n  where blocks : [a][4][8]\n        blocks = split bytes\n\nto_bytes : {a} [a][32] -> [a*4][8]\nto_bytes words = join [ reverse (split word : [4][8]) | word <- words ]\n\nproperty from_to_bytes (words : [16][32]) =\n  from_bytes (to_bytes words) == words\n\nproperty to_from_bytes (bytes : [64][8]) =\n  to_bytes (from_bytes bytes) == bytes\n\nC_C'_correct k t s0 =\n  C' k t (C k t s0) == s0\n\npad : {n, b} (fin n, b == (n+8) \/^ 512) => [n] -> [b][512]\npad m = split (m # 0x01 # zero)\n\npad_bytes : {n, b} (fin n, b == (n+1) \/^ 64) => [n][8] -> [b*64][8]\npad_bytes m = m # [0x01] # zero\n\nMambo : key -> tweak -> block -> block\nMambo k t m = join (C k t (split m))\n\nMambo' : key -> tweak -> block -> block\nMambo' k t m = join (C' k t (split m))\n\nMambo_bytes : [_][8] -> [_][8] -> [_][8] -> _\nMambo_bytes k t m = to_bytes (Mambo (from_bytes k) (from_bytes t) (from_bytes m))\n\nMambo_bytes' : [_][8] -> [_][8] -> [_][8] -> _\nMambo_bytes' k t m = to_bytes (Mambo' (from_bytes k) (from_bytes t) (from_bytes m))\n\nproperty Mambo_test =\n  join (Mambo_bytes (\"Me\" # zero) (\"Try\" # zero) (\"Test\" # zero)) ==\n  0xeb514a1ff2609f3a81ccfdd5e5342dba332d7b159a1571cee66d14bb6fd48ceb1ae956a91d3f54c8a545262c26611245a917d0a1582ecbc1d397b612baf7a62d\n\nMcMambo k ad npub M = undefined\n  where\n    Us = [zero] # [ u ^ Mambo_bytes k u a | u <- Us | a <- split (pad_bytes ad) ]\n    \u03c4 = Mambo_bytes k (Us!0) npub\n    u' = (Us!0) ^ \u03c4\n    Cs = [ Mambo_bytes k u m | u <- undefined | m <- split (pad_bytes M # \u03c4)]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/PRESENT.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::PRESENT that contains the following definitions mirroring the PRESENT block cipher and key schedules: (1) Type aliases: 64-bit block size, 32-bit standard size, 80-bit key size, 64-bit round key size, 128-bit key size, and a state as a 4\u00d74 matrix of 4-bit nibbles. (2) Constants: a 16-entry 4-bit S-box and its inverse; 64-entry bit-permutation tables and their inverse, with element types appropriate for indexing a 64-bit block; ensure all constants have the PRESENT standard values. (3) Key schedules: for 80-bit keys, a function taking an 80-bit key and 5-bit round index and returning a 4-tuple (64-bit round key, 80-bit rotated key, 80-bit substituted key, 80-bit next key); and a function producing a 32-element sequence of such tuples (rounds 0..31). For 128-bit keys, analogous functions returning (64-bit round key, 128-bit next key) and a 32-element sequence. (4) Round functions: XOR-based round-key addition on states; nibble-wise S-box and inverse; 64-bit-to-state and state-to-64-bit conversions; bit permutation and its inverse; one-round encryption and decryption over states. (5) Cipher APIs: 80-bit-key encrypt\/decrypt mapping (key, 64-bit block) to 64-bit block using 31 rounds with initial and final whitening as implied by the schedule; 128-bit-key encrypt\/decrypt analogs. (6) Helper adapters: 64-bit-key encrypt\/decrypt via zero-extending to 128-bit key; a 128-bit-block helper that encrypts the lower 64 bits and zero-pads the upper 64. (7) Properties: define properties asserting decrypt(encrypt(m)) == m for 80-bit keys, 128-bit keys, and the 64-bit-key helper. (8) Tests: boolean equalities for known PRESENT test vectors (80-bit and 128-bit), a list collecting them, and a property equal to their conjunction. Provide precise Cryptol type signatures for all definitions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::PRESENT where\n\ntype PrBlockSize = 64\ntype State = [4][4][4]\ntype StdBlockSize = 32\ntype PrKeySize = 80\ntype PrRkeySize = 64\ntype PrKeySize128 = 128\n\nsbox = [0xc, 0x5, 0x6, 0xb, 0x9, 0x0, 0xa, 0xd, 0x3, 0xe, 0xf, 0x8, 0x4, 0x7, 0x1, 0x2]\n\nSbox_inv = [0x5, 0xe, 0xf, 0x8, 0xc, 0x1, 0x2, 0xd, 0xb, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xa]\n\npbox = [0x00, 0x10, 0x20, 0x30, 0x01, 0x11, 0x21, 0x31, 0x02, 0x12, 0x22,\n        0x32, 0x03, 0x13, 0x23, 0x33, 0x04, 0x14, 0x24, 0x34, 0x05, 0x15,\n        0x25, 0x35, 0x06, 0x16, 0x26, 0x36, 0x07, 0x17, 0x27, 0x37, 0x08,\n        0x18, 0x28, 0x38, 0x09, 0x19, 0x29, 0x39, 0x0a, 0x1a, 0x2a, 0x3a,\n        0x0b, 0x1b, 0x2b, 0x3b, 0x0c, 0x1c, 0x2c, 0x3c, 0x0d, 0x1d, 0x2d,\n        0x3d, 0x0e, 0x1e, 0x2e, 0x3e, 0x0f, 0x1f, 0x2f, 0x3f]\n\npbox_inv = [0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c, 0x20, 0x24, 0x28,\n          0x2c, 0x30, 0x34, 0x38, 0x3c, 0x01, 0x05, 0x09, 0x0d, 0x11, 0x15,\n          0x19, 0x1d, 0x21, 0x25, 0x29, 0x2d, 0x31, 0x35, 0x39, 0x3d, 0x02,\n          0x06, 0x0a, 0x0e, 0x12, 0x16, 0x1a, 0x1e, 0x22, 0x26, 0x2a, 0x2e,\n          0x32, 0x36, 0x3a, 0x3e, 0x03, 0x07, 0x0b, 0x0f, 0x13, 0x17, 0x1b,\n          0x1f, 0x23, 0x27, 0x2b, 0x2f, 0x33, 0x37, 0x3b, 0x3f]\n\nupdateKey : [PrKeySize] -> [5] -> _\nupdateKey key i =  (rkey, shift, res,  key'')\n            where rkey = key !![79,78..16]\n                  shift =  (key !! [18,17..0]) # (key !! [79,78..19])\n                  res = sbox@((shift) !! [79,78,77, 76]) # (shift !! [75,74..0])\n                  key'' =  (res !! [79,78..20]) # ((res!![19,18..15])^(i+1)) # (res!![14,13..0])\n\nRoundKeyList : [PrKeySize] -> _\n\nRoundKeyList key = hs\n             where hs = [ (updateKey key 0) ] # [(updateKey (key'.3) i)\n                                                | i<- [1,2..31]\n                                                | key' <- hs\n                                                 ]\n\naddRoundKey : State -> State -> State\naddRoundKey pt key = pt ^ key\n\nSubCell : [4] -> [4]\nSubCell st = sbox@st\n\nSubCells : State -> State\nSubCells st = [ [ SubCell b | b<- row ] | row <- st ]\n\nSubCell_dec : [4] -> [4]\nSubCell_dec st = Sbox_inv@st\n\nSubCells_dec : State -> State\nSubCells_dec st = [ [ SubCell_dec b | b<- row ] | row <- st ]\n\nmsgToState : [PrBlockSize] -> State\nmsgToState msg = split (split msg)\n\nstateToMsg : State -> [PrBlockSize]\nstateToMsg st = join (join st)\n\nSubpLayer: [PrBlockSize] -> [PrBlockSize]\nSubpLayer pt =  hs\n          where hs = [ pt!(pbox_inv ! i) | i <- [0,1..63] ]\n\nSubpLayer_dec: [PrBlockSize] -> [PrBlockSize]\nSubpLayer_dec pt =  hs\n          where hs = [ pt!(pbox ! i) | i <- [0,1..63] ]\n\nroundEncrypt:  (State, State) -> State\nroundEncrypt (pt, key) = msgToState(SubpLayer(stateToMsg(SubCells (addRoundKey pt key))))\n\nroundDecrypt:  (State, State) -> State\nroundDecrypt (pt, key) = SubCells_dec (msgToState(SubpLayer_dec (stateToMsg (addRoundKey pt key))))\n\nPrEncrypt : ([PrKeySize], [PrBlockSize]) -> [PrBlockSize]\nPrEncrypt (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                where hs = [ roundEncrypt (msgToState(pt), msgToState((key'@0).0)) ] # [ roundEncrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [1,2..30]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList key)\n\nPrDecrypt : ([PrKeySize], [PrBlockSize]) -> _\nPrDecrypt (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@0).0))\n                where hs = [ roundDecrypt (msgToState(pt), msgToState((key'@31).0)) ] # [ roundDecrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [30,29..1]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList key)\n\nproperty PresentCorrectnes key m = PrDecrypt( key, PrEncrypt(key, m)) == m\n\nupdateKey_128 : [PrKeySize128] -> [5] -> _\nupdateKey_128 key i =  (rkey, key'')\n            where rkey = key !![127,126..64]\n                  shift =  (key !! [66,65..0]) # (key !! [127,126..67])\n                  res = sbox@((shift) !! [127,126,125, 124]) # sbox@((shift) !! [123,122,121, 120]) # (shift !! [119,118..0])\n                  key'' =  (res !! [127,126..67]) # ((res!![66,65,64,63,62])^(i+1)) # (res!![61,60..0])\n\nRoundKeyList_128: [PrKeySize128] -> _\n\nRoundKeyList_128 key = hs\n             where hs = [ (updateKey_128 key 0)] # [ (updateKey_128 (key'.1) i)\n                                                   | i <- [1,2..31]\n                                                   | key' <- hs ]\n\nPrEncrypt_128 : ([PrKeySize128], [PrBlockSize]) -> _\nPrEncrypt_128 (key , pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                         \/\/stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                where hs = [ roundEncrypt (msgToState(pt), msgToState((key'@0).0)) ] # [ roundEncrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [1,2..30]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList_128 key)\n\n\/\/Decryption-128bit\n\nPrDecrypt_128 : ([PrKeySize128], [PrBlockSize]) -> _\nPrDecrypt_128 (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@0).0))\n                where hs = [ roundDecrypt (msgToState(pt), msgToState((key'@31).0)) ] # [ roundDecrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [30,29..1]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList_128 key)\n\n\/\/Correctness\n\nproperty PresentCorrectnes128 key m = PrDecrypt_128(key, PrEncrypt_128(key, m)) == m\n\n\/\/ Heleper function to perform analaysis\n\nprEncrypt64 : ([PrBlockSize], [PrBlockSize]) -> [PrBlockSize]\nprEncrypt64 (key, pt)  = PrEncrypt_128 (key#zero, pt)\n\nprDecrypt64 : ([PrBlockSize], [PrBlockSize]) -> [PrBlockSize]\nprDecrypt64 (key, ct)  = PrDecrypt_128(key#zero , ct)\n\nproperty PrCorrect64 key m = prDecrypt64 (key, (prEncrypt64(key, m))) == m\n\nprEncrypt128 : ([PrKeySize128], [PrKeySize128]) -> [PrKeySize128]\nprEncrypt128 (key, pt)  = PrEncrypt_128(key, (take`{64} pt)) # zero\n\n\/\/ Testing\ntests = [test80_1, test80_2, test80_3, test80_4, test80_5, test128_1]\nproperty testsPass = and tests\n\/\/keysize: 80bits\n\ntest80_1 =  PrEncrypt (zero, zero) == 0x5579c1387b228445\ntest80_2 =  PrEncrypt (zero, zero) == 0x5579c1387b228445\ntest80_3 =  PrEncrypt (0xffffffffffffffffffff, zero) == 0xe72c46c0f5945049\ntest80_4 =  PrEncrypt (0xffffffffffffffffffff, 0xffffffffffffffff) == 0x3333dcd3213210d2\ntest80_5 =  PrEncrypt (zero, 0xffffffffffffffff) == 0xa112ffc72f68417b\n\n\/\/keysize: 128bits\n\ntest128_1 = PrEncrypt_128 ( 0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0x0e9d28685e671dd6\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Cipher.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named `module_name` that contains the following definitions: a type synonym `type_name` parameterized by two numeric type parameters `key_size` and `block_size`. This type denotes a record interface for a block cipher with exactly two fields: `encrypt_name` and `decrypt_name`. Each field is a curried function that first takes a key as a fixed-size bitvector of length `key_size`, then takes a block as a fixed-size bitvector of length `block_size`, and returns a block of length `block_size`. Use Cryptol\u2019s sequence type notation for fixed widths and function arrows for currying. Both fields must share the same `key_size` and `block_size` parameters, and no other fields or constraints are included. Do not implement any algorithms; only provide the type alias and precise field types."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Cipher where\n\ntype Cipher KeySize BlockSize =\n  { encrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  , decrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/GOST.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::GOST that contains the following definitions: (1) Type aliases: a 64-bit block size, a 32-bit half-block size, and a 256-bit key size. (2) Two S-box constants, each an 8\u00d716 table of 4-bit values. (3) A function to split a 64-bit block into two 32-bit halves. (4) A key-schedule function that splits a 256-bit key into eight 32-bit words. (5) Two round-key schedule functions that produce 32 round subkeys: the encryption schedule repeats the eight words three times in ascending order followed by one reverse-order pass; the decryption schedule uses one ascending pass followed by three reverse-order passes. (6) A round function that adds a 32-bit half and a 32-bit subkey modulo 2^32, splits into eight 4-bit nibbles, substitutes each via the corresponding S-box row, rejoins to 32 bits, and rotates left by 11 bits. (7) A Feistel round function that maps two 32-bit halves and a subkey to a new 64-bit block by outputting the right half concatenated with the left half XOR the round function of the right half. (8) An encryption function that applies 32 Feistel rounds over a 64-bit block using the encryption round-key schedule. (9) A decryption function that applies the inverse Feistel step using the decryption round-key schedule. (10) Define a property that verifies decrypt(encrypt(m, key), key) equals m for 256-bit keys and 64-bit blocks. (11) Helper functions that encrypt and decrypt using 64-bit keys by zero-padding the key to 256 bits. (12) Define a property that verifies the 64-bit-key helper decrypt(encrypt(m, key), key) equals m. (13) A helper that takes a 256-bit plaintext and key, encrypts only the lower 64 bits, and pads the result back to 256 bits with zeros."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::GOST where\n\ntype BlockSize = 64\ntype StdBlockSize = 32\ntype KeySize = 256\n\nsbox = [\n    [0x4, 0xa, 0x9, 0x2, 0xd, 0x8, 0x0, 0xe, 0x6, 0xb, 0x1, 0xc, 0x7, 0xf, 0x5, 0x3],\n    [0xe, 0xb, 0x4, 0xc, 0x6, 0xd, 0xf, 0xa, 0x2, 0x3, 0x8, 0x1, 0x0, 0x7, 0x5, 0x9],\n    [0x5, 0x8, 0x1, 0xd, 0xa, 0x3, 0x4, 0x2, 0xe, 0xf, 0xc, 0x7, 0x6, 0x0, 0x9, 0xb],\n    [0x7, 0xd, 0xa, 0x1, 0x0, 0x8, 0x9, 0xf, 0xe, 0x4, 0x6, 0xc, 0xb, 0x2, 0x5, 0x3],\n    [0x6, 0xc, 0x7, 0x1, 0x5, 0xf, 0xd, 0x8, 0x4, 0xa, 0x9, 0xe, 0x0, 0x3, 0xb, 0x2],\n    [0x4, 0xb, 0xa, 0x0, 0x7, 0x2, 0x1, 0xd, 0x3, 0x6, 0x8, 0x5, 0x9, 0xc, 0xf, 0xe],\n    [0xd, 0xb, 0x4, 0x1, 0x3, 0xf, 0x5, 0x9, 0x0, 0xa, 0xe, 0x7, 0x6, 0x8, 0x2, 0xc],\n    [0x1, 0xf, 0xd, 0x0, 0x5, 0x7, 0xa, 0x4, 0x9, 0x2, 0x3, 0xe, 0x6, 0xb, 0x8, 0xc]\n    ]\n\nsbox_rec = [\n         [0xc, 0x4, 0x6, 0x2, 0xa, 0x5, 0xb, 0x9, 0xe, 0x8, 0xd, 0x7, 0x0, 0x3, 0xf, 0x1],\n         [0x6, 0x8, 0x2, 0x3, 0x9, 0xa, 0x5, 0xc, 0x1, 0xe, 0x4, 0x7, 0xb, 0xd, 0x0, 0xf],\n         [0xb, 0x3, 0x5, 0x8, 0x2, 0xf, 0xa, 0xd, 0xe, 0x1, 0x7, 0x4, 0xc, 0x9, 0x6, 0x0],\n         [0xc, 0x8, 0x2, 0x1, 0xd, 0x4, 0xf, 0x6, 0x7, 0x0, 0xa, 0x5, 0x3, 0xe, 0x9, 0xb],\n         [0x7, 0xf, 0x5, 0xa, 0x8, 0x1, 0x6, 0xd, 0x0, 0x9, 0x3, 0xe, 0xb, 0x4, 0x2, 0xc],\n         [0x5, 0xd, 0xf, 0x6, 0x9, 0x2, 0xc, 0xa, 0xb, 0x7, 0x8, 0x1, 0x4, 0x3, 0xe, 0x0],\n         [0x8, 0xe, 0x2, 0x5, 0x6, 0x9, 0x1, 0xc, 0xf, 0x4, 0xb, 0x0, 0xd, 0xa, 0x3, 0x7],\n         [0x1, 0x7, 0xe, 0xd, 0x0, 0x5, 0x8, 0x3, 0x4, 0xf, 0xa, 0x6, 0x9, 0xc, 0xb, 0x2]\n         ]\n\nsplitPt: [BlockSize] -> [2][StdBlockSize]\nsplitPt pt = split pt:[2][StdBlockSize]\n\nkeySchedule : [KeySize] -> [8][StdBlockSize]\nkeySchedule key = split key : [8][StdBlockSize]\n\nroundKey:[KeySize] ->  _\nroundKey key = [ rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0\n                 ]\n         where rk = (keySchedule key)\nroundKey':[KeySize] ->  _\nroundKey' key = [ rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0\n                 ]\n         where rk = (keySchedule key)\n\nroundFun : [StdBlockSize]-> [StdBlockSize] -> [StdBlockSize]\nroundFun subpt subkey = roundRes\n            where res = subpt + subkey\n                  splitRes = split res: [8][4]\n                  subSboxRes = [ (sbox@i)@(splitRes@i) | i<- [0..7] ]\n                  roundRes = (join subSboxRes) <<< 11\n\nroundEncryption: [StdBlockSize] -> [StdBlockSize] -> [StdBlockSize] -> [BlockSize]\nroundEncryption lpt rpt rkey =  rpt # (lpt ^ (roundFun rpt rkey))\n\ngostEncrypt: ([KeySize], [BlockSize]) ->  [BlockSize]\ngostEncrypt (key, pt) = hs'\n            where hs = [(roundEncryption left right (round_key@0))]  # [ (roundEncryption ((splitPt pT)@0) ((splitPt pT)@1) (round_key@i))\n                                                  | i <- [1,2..31]\n                                                  | pT <- hs\n                                                  ]\n                  splt_pt = (splitPt pt)\n                  left = splt_pt@0\n                  right = splt_pt@1\n                  round_key = (roundKey key)\n                  hs' = hs!0\n\nroundDecryption: [StdBlockSize] -> [StdBlockSize] -> [StdBlockSize] -> [BlockSize]\nroundDecryption lpt rpt rkey =  (rpt ^ (roundFun lpt rkey)) # lpt\n\ngostDecrypt: ([KeySize], [BlockSize]) ->  [BlockSize]\ngostDecrypt (key, ct) = hs'\n            where hs = [(roundDecryption left right (round_key@0))]  # [ (roundDecryption ((splitPt pT)@0) ((splitPt pT)@1) (round_key@i))\n                                                  | i <- [1,2..31]\n                                                  | pT <- hs\n                                                  ]\n                  splt_pt = (splitPt ct)\n                  left = splt_pt@0\n                  right = splt_pt@1\n                  round_key = (roundKey' key)\n                  hs' = hs!0\n\n\/\/ Correctness\n\nproperty gostCorrect key m = gostDecrypt(key, gostEncrypt(key, m)) == m\n\n\/\/ Helper functions to perform analysis\n\ngostEncrypt64: ([BlockSize],[BlockSize]) -> [BlockSize]\ngostEncrypt64 (pt, key)  = gostEncrypt(key', pt)\n             where key' = key # zero\n\ngostDecrypt64 : ([BlockSize], [BlockSize]) -> [BlockSize]\ngostDecrypt64 (ct, key)  = gostDecrypt(key', ct)\n             where key' = key #zero\n\nproperty gostCorrect64 key m = gostDecrypt64( key, gostEncrypt64(key, m)) == m\n\n\/\/ To analyze the schemes from 5 through 20, we take |mi| = k  where k > n (block size)\n\ngostEncrypt256 : ([KeySize], [KeySize]) -> [KeySize]\ngostEncrypt256 (pt, key) = gostEncrypt(key, (take`{64} pt))# zero\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Threefish.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Threefish that contains the following definitions and specifications, with precise Cryptol type signatures and stated constraints, but no implementations: (1) A 6\u2011bit type alias for rotation amounts. (2) Byte\/bit conversion helpers: a function that joins reversed n bytes into an 8\u00b7n\u2011bit vector, its inverse that splits an 8\u00b7n\u2011bit vector into n bytes in reverse order, plus functions to convert between sequences of bytes and sequences of 64\u2011bit words by grouping 8 bytes per word. (3) The MIX function over a pair of 64\u2011bit words parameterized by a rotation amount (add, rotate, xor), and its inverse. Lift these to mixing over 2\u00b7w words using a length\u2011w rotation schedule. (4) Word permutations for widths 4, 8, and 16, and their inverses. (5) Rotation constant tables for widths 4, 8, and 16: each is an array of 8 rows, where each row provides Nw\/2 rotation amounts. (6) A key schedule over Nw 64\u2011bit words and a 2\u2011word tweak producing r subkeys of Nw words. Include the parity key word computed as the xor of all key words with a fixed 64\u2011bit constant, a 3\u2011word tweak extension with xor, subkey selection by word\u2011rotating key\/tweak by a 64\u2011bit counter, and appending the counter as the last word. (7) Constants for the 64\u2011bit key\u2011parity value. (8) Word\u2011level encrypt\u2019\/decrypt\u2019 with parameters Nr, Nw, rotation table, and permutation; constraints: fin Nr, fin Nw, Nw \u2265 3, Nw even; Nr multiple of 4 for encryption and of 8 for decryption. Specify round structure: add subkey every 4 rounds, per\u2011round mixing using cyclic rotation rows, and permutation; decryption reverses order and uses inverse permutation\/mix. (9) Byte\u2011level wrappers encrypt\/decrypt that map between bytes and words. (10) Specialized enc256\/enc512\/enc1024 and dec256\/dec512\/dec1024 with appropriate byte sizes, tweaks of 16 bytes, and round counts. (11) Properties asserting inversion of MIX and the three permutations, and properties that check the specialized encryptions against published test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Threefish where\n\nToInt : {n} (fin n) => [n][8] -> [8 * n]\nToInt bytes = join (reverse bytes)\n\nToBytes : {n} (fin n) => [8 * n] -> [n][8]\nToBytes bits = reverse (split`{each = 8} bits)\n\nBytesToWords : {n} (fin n) => [8 * n][8] -> [n][64]\nBytesToWords bytes = [ ToInt bs | bs <- split`{each = 8} bytes ]\n\nWordsToBytes : {n} (fin n) => [n][64] -> [8 * n][8]\nWordsToBytes words = join [ ToBytes w | w <- words ]\n\nenc256 : [32][8] -> [16][8] -> [32][8] -> [32][8]\nenc256 = encrypt`{Nr=72} R4 pi4\n\nenc512 : [64][8] -> [16][8] -> [64][8] -> [64][8]\nenc512 = encrypt`{Nr=72} R8 pi8\n\nenc1024 : [128][8] -> [16][8] -> [128][8] -> [128][8]\nenc1024 = encrypt`{Nr=80} R16 pi16\n\nencrypt :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 4 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot ->\n  ([Nw][64] -> [Nw][64]) ->\n  [8 * Nw][8] -> [16][8] -> [8 * Nw][8] -> [8 * Nw][8]\nencrypt R pi key tweak plaintext = WordsToBytes (encrypt'`{Nr=Nr} R pi K T P)\n  where\n    K = BytesToWords key\n    T = BytesToWords tweak\n    P = BytesToWords plaintext\n\n\/\/ Encryption in terms of 64-bit words.\nencrypt' :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 4 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot -> ([Nw][64] -> [Nw][64]) ->\n  [Nw][64] -> [2][64] -> [Nw][64] -> [Nw][64]\nencrypt' R pi key tweak plaintext = last v + last ks\n  where\n    ks : [Nr\/4 + 1][Nw][64]\n    ks = KeySchedule key tweak\n\n    \/\/ Add a subkey from the key schedule once every four rounds.\n    e : [Nr][Nw][64]\n    e = [ vd + kd\n        | vd <- v\n        | subkey <- take`{Nr\/4} ks, kd <- [subkey, zero, zero, zero] ]\n\n    \/\/ Cycle over the eight lists of rotation amounts for the mixing function.\n    f : [Nr][Nw][64]\n    f = [ mixing Rd ed | Rd <- join (repeat`{inf} R) | ed <- e ]\n\n    \/\/ Permute the words every round.\n    v : [Nr+1][Nw][64]\n    v = [plaintext] # [ pi fd | fd <- f ]\n\n\/\/ One round of mixing.\nmixing : {w} (fin w) => [w]Rot -> [2 * w][64] -> [2 * w][64]\nmixing Rd e = join [ MIX R x | R <- Rd | x <- split`{each=2} e ]\n\n\/\/ Table 3: Values for the word permutation \u03c0(i).\n\npi4 : [4][64] -> [4][64]\npi4 xs = xs @@ [0, 3, 2, 1:[2]]\n\npi8 : [8][64] -> [8][64]\npi8 xs = xs @@ [2, 1, 4, 7, 6, 5, 0, 3:[3]]\n\npi16 : [16][64] -> [16][64]\npi16 xs = xs @@ [0, 9, 2, 13, 6, 11, 4, 15, 10, 7, 12, 3, 14, 5, 8, 1:[4]]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.1: MIX Functions\n\n\/\/ Rotation amount for a 64-bit word\ntype Rot = [6]\n\nMIX : Rot -> [2][64] -> [2][64]\nMIX R [x0, x1] = [y0, y1]\n  where\n    y0 = x0 + x1\n    y1 = (x1 <<< R) ^ y0\n\n\/\/ Table 4: Rotation constants\n\nR4 : [8][2]Rot\nR4 =\n  [[14, 16],\n   [52, 57],\n   [23, 40],\n   [ 5, 37],\n   [25, 33],\n   [46, 12],\n   [58, 22],\n   [32, 32]]\n\nR8 : [8][4]Rot\nR8 =\n  [[46, 36, 19, 37],\n   [33, 27, 14, 42],\n   [17, 49, 36, 39],\n   [44,  9, 54, 56],\n   [39, 30, 34, 24],\n   [13, 50, 10, 17],\n   [25, 29, 39, 43],\n   [ 8, 35, 56, 22]]\n\nR16 : [8][8]Rot\nR16 =\n  [[24, 13,  8, 47,  8, 17, 22, 37],\n   [38, 19, 10, 55, 49, 18, 23, 52],\n   [33,  4, 51, 13, 34, 41, 59, 17],\n   [ 5, 20, 48, 41, 47, 28, 16, 25],\n   [41,  9, 37, 31, 12, 47, 44, 30],\n   [16, 34, 56, 51,  4, 53, 42, 41],\n   [31, 44, 47, 46, 19, 42, 44, 25],\n   [ 9, 48, 35, 52, 23, 31, 37, 20]]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.2: The Key Schedule\n\n\/\/ \"The key schedule turns the key and tweak into a sequence of Nr\/4+1\n\/\/ subkeys, each of which consists of Nw words.\"\n\nKeySchedule :\n  {Nw, r} (fin Nw, fin r, Nw >= 3) =>\n  [Nw][64] -> [2][64] -> [r][Nw][64]\nKeySchedule k [t0,t1] = take`{r} [ subkey s | s <- [0...] ]\n  where\n    k' = k # [foldl (^) C240 k]\n    t' = [t0, t1, t0 ^ t1]\n\n    subkey : [64] -> [Nw][64]\n    subkey s = take`{Nw} (k' <<< s) + tweak s\n\n    tweak : [64] -> [Nw][64]\n    tweak s = zero # take`{2} (t' <<< s) # [s]\n\nC240 : [64]\nC240 = 0x1BD11BDAA9FC1A22\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.3: Decryption\n\n\/\/ \"The Threefish decryption operation is the obvious inverse of the\n\/\/ encryption operation. Subkeys are used in reverse order and each\n\/\/ round consists of applying the inverse word permutation followed by\n\/\/ the inverse MIX functions.\"\n\ndec256 : [32][8] -> [16][8] -> [32][8] -> [32][8]\ndec256 = decrypt`{Nr=72} R4 pi4'\n\ndec512 : [64][8] -> [16][8] -> [64][8] -> [64][8]\ndec512 = decrypt`{Nr=72} R8 pi8'\n\ndec1024 : [128][8] -> [16][8] -> [128][8] -> [128][8]\ndec1024 = decrypt`{Nr=80} R16 pi16'\n\ndecrypt :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 8 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot ->\n  ([Nw][64] -> [Nw][64]) ->\n  [8 * Nw][8] -> [16][8] -> [8 * Nw][8] -> [8 * Nw][8]\ndecrypt R pi key tweak ciphertext = WordsToBytes (decrypt'`{Nr=Nr} R pi K T P)\n  where\n    K = BytesToWords key\n    T = BytesToWords tweak\n    P = BytesToWords ciphertext\n\n\/\/ Decryption in terms of 64-bit words.\ndecrypt' :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 8 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot -> ([Nw][64] -> [Nw][64]) ->\n  [Nw][64] -> [2][64] -> [Nw][64] -> [Nw][64]\ndecrypt' R pi key tweak ciphertext = last e - last ks\n  where\n    ks : [Nr\/4 + 1][Nw][64]\n    ks = reverse (KeySchedule key tweak)\n\n    \/\/ Add a subkey from the key schedule once every four rounds.\n    v : [Nr][Nw][64]\n    v = [ ed - kd\n        | ed <- e\n        | subkey <- take`{Nr\/4} ks, kd <- [subkey, zero, zero, zero] ]\n\n    \/\/ Cycle over the eight lists of rotation amounts for the mixing function.\n    e : [Nr+1][Nw][64]\n    e = [ciphertext] # [ mixing' Rd fd | Rd <- reverse (join (repeat`{Nr\/8} R)) | fd <- f ]\n\n        f : [Nr][Nw][64]\n    f = [ pi vd | vd <- v ]\n\nMIX' : Rot -> [2][64] -> [2][64]\nMIX' R [y0, y1] = [x0, x1]\n  where\n    x0 = y0 - x1\n    x1 = (y0 ^ y1) >>> R\n\nmixing' : {w} (fin w) => [w]Rot -> [2 * w][64] -> [2 * w][64]\nmixing' Rd e = join [ MIX' R x | R <- Rd | x <- split`{each=2} e ]\n\n\/\/ Inverse permutations.\n\npi4' : [4][64] -> [4][64]\npi4' xs = xs @@ [0, 3, 2, 1:[2]]\n\npi8' : [8][64] -> [8][64]\npi8' xs = xs @@ [6, 1, 0, 7, 2, 5, 4, 3:[3]]\n\npi16' : [16][64] -> [16][64]\npi16' xs = xs @@ [0, 15, 2, 11, 6, 13, 4, 9, 14, 1, 8, 5, 10, 3, 12, 7:[4]]\n\nproperty MIX_inv R x = MIX' R (MIX R x) == x\nproperty pi4_inv xs = pi4' (pi4 xs) == xs\nproperty pi8_inv xs = pi8' (pi8 xs) == xs\nproperty pi16_inv xs = pi16' (pi16 xs) == xs\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Test Vectors\n\n\/\/ https:\/\/sites.google.com\/site\/bartoszmalkowski\/threefish\n\nproperty test256a =\n  enc256 zero zero zero ==\n  split 0x84da2a1f8beaee947066ae3e3103f1ad536db1f4a1192495116b9f3ce6133fd8\n\nproperty test256b =\n  enc256\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xFFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0)\n  ==\n  split 0xe0d091ff0eea8fdfc98192e62ed80ad59d865d08588df476657056b5955e97df\n\nproperty test512a =\n  enc512 zero zero zero ==\n  split 0xb1a2bbc6ef6025bc40eb3822161f36e375d1bb0aee3186fbd19e47c5d479947b #\n  split 0x7bc2f8586e35f0cff7e7f03084b0b7b1f1ab3961a580a3e97eb41ea14a6d7bbe\n\nproperty test512b =\n  enc512\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f #\n     split 0x303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xfffefdfcfbfaf9f8f7f6f5f4f3f2f1f0efeeedecebeae9e8e7e6e5e4e3e2e1e0 #\n     split 0xdfdedddcdbdad9d8d7d6d5d4d3d2d1d0cfcecdcccbcac9c8c7c6c5c4c3c2c1c0)\n  ==\n  split 0xe304439626d45a2cb401cad8d636249a6338330eb06d45dd8b36b90e97254779 #\n  split 0x272a0a8d99463504784420ea18c9a725af11dffea10162348927673d5c1caf3d\n\nproperty test1024a =\n  enc1024 zero zero zero ==\n  split 0xf05c3d0a3d05b304f785ddc7d1e036015c8aa76e2f217b06c6e1544c0bc1a90d #\n  split 0xf0accb9473c24e0fd54fea68057f43329cb454761d6df5cf7b2e9b3614fbd5a2 #\n  split 0x0b2e4760b40603540d82eabc5482c171c832afbe68406bc39500367a592943fa #\n  split 0x9a5b4a43286ca3c4cf46104b443143d560a4b230488311df4feef7e1dfe8391e\n\nproperty test1024b =\n  enc1024\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f #\n     split 0x303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f #\n     split 0x505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f #\n     split 0x707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xfffefdfcfbfaf9f8f7f6f5f4f3f2f1f0efeeedecebeae9e8e7e6e5e4e3e2e1e0 #\n     split 0xdfdedddcdbdad9d8d7d6d5d4d3d2d1d0cfcecdcccbcac9c8c7c6c5c4c3c2c1c0 #\n     split 0xbfbebdbcbbbab9b8b7b6b5b4b3b2b1b0afaeadacabaaa9a8a7a6a5a4a3a2a1a0 #\n     split 0x9f9e9d9c9b9a999897969594939291908f8e8d8c8b8a89888786858483828180)\n  ==\n  split 0xa6654ddbd73cc3b05dd777105aa849bce49372eaaffc5568d254771bab85531c #\n  split 0x94f780e7ffaae430d5d8af8c70eebbe1760f3b42b737a89cb363490d670314bd #\n  split 0x8aa41ee63c2e1f45fbd477922f8360b388d6125ea6c7af0ad7056d01796e90c8 #\n  split 0x3313f4150a5716b30ed5f569288ae974ce2b4347926fce57de44512177dd7cde\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/SHACAL.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::SHACAL that contains the following definitions:\n- Type synonyms for block and key sizes: SHACAL-1 block = 160 bits, SHACAL-1 key = 512 bits; SHACAL-2 block = 256 bits, SHACAL-2 key = 512 bits.\n- Function shacal1Encrypt: takes a 512-bit key and a 160-bit block, returns a 160-bit block; split the block into five 32-bit words and the key into sixteen 32-bit words, run the SHACAL-1 round function, then rejoin to 160 bits.\n- Function shacal1Encrypt160: takes a 160-bit key and 160-bit block, returns 160 bits; zero-extend the key to 512 bits and call the SHACAL-1 encryptor.\n- Function shacal1Encrypt512: takes a 512-bit key and 512-bit block, returns 512 bits; encrypt only the most significant 160 bits of the block and zero-extend the result to 512 bits.\n- Function shacal2Encrypt: takes a 512-bit key and a 256-bit block, returns 256 bits; split the block into eight 32-bit words and the key into sixteen 32-bit words, and use the SHA-256 internal block-processing routine for one block.\n- Function shacal2Encrypt256 and shacal2Encrypt512 with analogous zero-extension and truncation behavior as for SHACAL-1 (256-bit and 512-bit block interfaces, respectively).\n- Function f: round Boolean function taking an 8-bit round index and three 32-bit words, returning a 32-bit word; implement SHA-1 style behaviors for rounds 0\u201319, 20\u201339, 40\u201359, and 60\u201379; error on out-of-range indices.\n- Constant Ks: an 80-element vector of 32-bit round constants (four values repeated for the four 20-round segments).\n- Function block: SHACAL-1 core that takes five 32-bit chaining values and sixteen 32-bit message words, constructs an 80-word schedule via XORs and a 1-bit left rotate, performs 80 rounds updating five 32-bit working registers, and outputs the five updated values added to the inputs.\n- Constants tVector1 and tVector2: lists of test-vector triples (key, plaintext, ciphertext) sized appropriately for SHACAL-1 and SHACAL-2.\n- Properties shacal1TestsPass and shacal2TestsPass: each asserts that encrypting every test-vector pair produces the corresponding expected ciphertext.\nAlso import the internal SHA-256 module required for the SHACAL-2 block processing."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::SHACAL where\n\nimport Primitive::Keyless::Hash::SHA2Internal::SHA256\n\ntype shacal1Block = 160\ntype shacal1Key = 512\n\nshacal1Encrypt : ([shacal1Key], [shacal1Block]) -> [shacal1Block]\nshacal1Encrypt (key, pt) = join (block (pt', key'))\n              where pt' = split pt : [5][32]\n                    key' = split key : [16][32]\n\nshacal1Encrypt160 : ([shacal1Block], [shacal1Block]) -> [shacal1Block]\nshacal1Encrypt160 (key, pt) = shacal1Encrypt(key#zero, pt)\n\nshacal1Encrypt512 : ([shacal1Key], [shacal1Key]) -> [shacal1Key]\nshacal1Encrypt512 (key, pt) = shacal1Encrypt(key, (take`{160} pt))#zero\n\nproperty shacal1TestsPass = and [shacal1Encrypt(key, plain) == cipher | (key, plain, cipher) <- tVector1]\n\ntVector1 = [ (0x8#zero, zero, 0x0FFD8D43B4E33C7C53461BD10F27A5461050D90D)\n           , (0x4#zero, zero, 0xB9C60AA972B49CA04D5A0D9B9E08B2A2BA138C93)\n           , (0x2#zero, zero, 0x3FA618501A3D10E3CAEB3CA06B8B47A16F8E3D9E)\n           , (0x1#zero, zero, 0x2B4AFB3268C32F86B89BB745EC85F24702B38498)\n           , (0x08#zero, zero, 0x58E782A1D205E53DD2901F0F302F8894D0A3B05B)\n           , (0x04#zero, zero, 0xB345AD4DC877D0BFCF760EE25056D21C7DB2F868)\n           , (0x02#zero, zero, 0x334C5A595919EA33E5EB467657AAE3ED825207D3)\n           , (0x01#zero, zero, 0x5F686F27819DF939F877099A222D01EE955F6E66)\n           , (0x008#zero, zero, 0x62BE68D266A28F7E6B44A83E62A476FFD627AF0E)\n           , (0x004#zero, zero, 0x2D5265CD2E72B52B6477F341816F2BB554428BC5)]\n\ntype shacal2Block = 256\ntype shacal2Key = 512\n\nshacal2Encrypt : ([shacal2Key], [shacal2Block]) -> [shacal2Block]\nshacal2Encrypt (key, pt) = join (processBlock_Common pt' key')\n              where pt' = split pt : [8][32]\n                    key' = split key : [16][32]\n\nshacal2Encrypt256 : ([shacal2Block], [shacal2Block]) -> [shacal2Block]\nshacal2Encrypt256 (key, pt) = shacal2Encrypt(key#zero, pt)\n\nshacal2Encrypt512 : ([shacal2Key], [shacal2Key]) -> [shacal2Key]\nshacal2Encrypt512 (key, pt) = shacal2Encrypt(key, (take`{256} pt))#zero\n\nproperty shacal2TestsPass = and [shacal2Encrypt(key, plain) == cipher | (key, plain, cipher) <- tVector2]\n\ntVector2 = [ (0x8#zero, zero, 0x361AB6322FA9E7A7BB23818D839E01BDDAFDF47305426EDD297AEDB9F6202BAE)\n           , (0x4#zero, zero, 0xF3BAF53E5301E08813F8BE6F651BB19E9722151FF15063BA42A6FEF7CF3BF3D7)\n           , (0x1#zero, zero, 0xAE70E355CB7E26FF12421F46CDAD5CB98367FE0E86CC234EDF97481765CD1AD9)\n           , (0x08#zero, zero, 0x00CECD0B01311F881018E7A20BCE169766C089D91FF161346C4E1BD122EA199F)\n           , (0x08#zero, zero, 0x00CECD0B01311F881018E7A20BCE169766C089D91FF161346C4E1BD122EA199F)\n           , (0x04#zero, zero, 0x47A879CB6785AD37119C450CD50E9A36FE318FA8E7B6C6E0FA963430122F33CD)\n           , (0x02#zero, zero, 0xCF3D53B9F9F7CA2C66738A4C09CEA9212C056F525BDC26F263FBA1B482EDF503)\n           , (0x01#zero, zero, 0xA274D404E83E82817389A2CB7B528C792A0E80DE879A5A67DE633B0B7DD57B7B)\n           , (0x008#zero, zero, 0x09B3AB9332301D4E3C239D192A4221AFD43F6829A705D396FA96BDE1E716BC38)\n           , (0x004#zero, zero, 0xD3B9AB867A6868C4400D200979055C8F9E3A6BFB40D1F9E376B9EC89223D7050)]\n\nf : ([8], [32], [32], [32]) -> [32]\nf (t, x, y, z) =\n       if (0 <= t)  \/\\ (t <= 19) then (x && y) ^ (~x && z)\n        | (20 <= t) \/\\ (t <= 39) then x ^ y ^ z\n        | (40 <= t) \/\\ (t <= 59) then (x && y) ^ (x && z) ^ (y && z)\n        | (60 <= t) \/\\ (t <= 79) then x ^ y ^ z\n        else error \"f: t out of range\"\n\nKs : [80][32]\nKs = [ 0x5a827999 | t <- [0..19]  ]\n   # [ 0x6ed9eba1 | t <- [20..39] ]\n   # [ 0x8f1bbcdc | t <- [40..59] ]\n   # [ 0xca62c1d6 | t <- [60..79] ]\n\nblock : ([5][32], [16][32]) -> [5][32]\nblock ([H0, H1, H2, H3, H4], M) =\n [(H0+As@80), (H1+Bs@80), (H2+Cs@80), (H3+Ds@80), (H4+Es@80)]\n  where\n    Ws : [80][32]\n    Ws = M # [ (W3 ^ W8 ^ W14 ^ W16) <<< 1\n             | W16 <- drop`{16 - 16} Ws\n             | W14 <- drop`{16 - 14} Ws\n             | W8  <- drop`{16 - 8}  Ws\n             | W3  <- drop`{16 - 3}  Ws\n             | t <- [16..79]\n             ]\n    As = [H0] # TEMP\n    Bs = [H1] # As\n    Cs = [H2] # [ B <<< 30 | B <- Bs ]\n    Ds = [H3] # Cs\n    Es = [H4] # Ds\n    TEMP : [80][32]\n    TEMP = [ (A <<< 5) + f(t, B, C, D) + E + W + K\n           | A <- As | B <- Bs | C <- Cs | D <- Ds | E <- Es\n           | W <- Ws | K <- Ks\n           | t <- [0..79]\n           ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/CipherInterface.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an interface module named Primitive::Symmetric::Cipher::Block::CipherInterface that contains the following declarations: (1) two abstract numeric type parameters KeySize and BlockSize (both of kind representing natural number sizes), (2) a constraint asserting that both sizes are finite, and (3) two functions, encrypt and decrypt, each taking a key of length KeySize and a block of length BlockSize and returning a block of length BlockSize. Provide only the type declarations\/signatures (no implementations). Clearly state the kinds, the finiteness constraint on both size parameters, and the exact input\/output shapes for the two functions as sequences of bits sized by those parameters."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Symmetric::Cipher::Block::CipherInterface where\n  type KeySize : #\n  type BlockSize : #\n  type constraint (fin BlockSize, fin KeySize)\n  encrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  decrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/KATAN.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::KATAN that contains: (1) size type synonyms for 32, 48, 64-bit blocks, 80-bit key, round counter width, L1\/L2 state widths, and tap-set sizes; (2) tap index vectors for both state halves; (3) a function that splits a 64-bit state into two parts of sizes 25 and 39; (4) round-constant bits indexed by round; (5) polymorphic key-schedule steppers that append 1, 10, and 100 derived bits (constrained to finite sequence lengths), and a function producing a 508-bit keystream; (6) KATAN feedback-bit functions for each state half that XOR\/AND selected taps, include the round constant, and select keystream bits at even\/odd round positions; (7) shift-and-append helpers for each half and an LFSR update that applies one, two, or three successive updates depending on the L1 width; (8) an encryption function that iterates the update for 254 rounds over a 64-bit block with an 80-bit key, plus wrappers that pad\/trim for 64-bit and 80-bit experiments; (9) decryption counterparts (feedback, single-step shifts, update) and a decryption function that iterates rounds in reverse; (10) define a property that checks KATAN correctness by asserting encrypt(key, decrypt(key, m)) equals m; (11) KTANTAN index tables for key-bit selection, KTANTAN feedback-bit functions using those tables, analogous shift\/apply and update, encryption and decryption, and define a property that checks KTANTAN correctness by asserting decrypt(key, encrypt(key, m)) equals m; (12) boolean constants for two known-answer tests for each cipher (all-ones key vs zero plaintext, and zero key vs all-ones plaintext), a list collecting them, and define a property that all tests hold."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::KATAN where\n\ntype Katan32 = 32\ntype Katan48 = 48\ntype Katan64 = 64\ntype KatanBlock = Katan64\ntype KatanKeySize = 80\ntype Round = 8\ntype xSize = 5\ntype ySize = 6\n\ntype Nr = 254\n\ntype L1Size = 25\ntype L2Size = 39\n\nx = [24, 15, 20, 11, 9]\ny = [38, 25, 33, 21, 14, 9]\n\nsplitBlock: [KatanBlock] -> ([L1Size], [L2Size])\n\nsplitBlock pt = (l1, l2)\n            where l1 = take`{L1Size} pt\n                  l2 = drop`{L1Size} pt\n\niR: [1][Nr]\n\niR = [0b11111110001101010101111011001100101001000100011000111100001000010100000111110011111101010001010100110000110011101111101110100101011010011100110110001011101101111001011011010111001001001101000111000100111101000011101011000001011001000000110111000000010010]\n\nkS: {a} (fin a) => ([a], [12]) -> [a+1]\nkS (key, i ) = key # [((key@(i-80))^ (key@(i-61)) ^ (key@(i-50)) ^ (key@(i-13)))]\n\nkS10 : {a} (fin a) => ([a], [12]) -> [a + 10]\nkS10 (key, i) = key9\n           where key0 = kS (key, i)\n                 key1 = kS (key0, i+1)\n                 key2 = kS (key1, i+2)\n                 key3 = kS (key2, i+3)\n                 key4 = kS (key3, i+4)\n                 key5 = kS (key4, i+5)\n                 key6 = kS (key5, i+6)\n                 key7 = kS (key6, i+7)\n                 key8 = kS (key7, i+8)\n                 key9 = kS (key8, i+9)\n\nkS100 : {a} (fin a) => ([a], [12]) -> [a + 100]\nkS100 (key, i) = key9\n            where key0 = kS10 (key, i)\n                  key1 = kS10 (key0, i+10)\n                  key2 = kS10 (key1, i+20)\n                  key3 = kS10 (key2, i+30)\n                  key4 = kS10 (key3, i+40)\n                  key5 = kS10 (key4, i+50)\n                  key6 = kS10 (key5, i+60)\n                  key7 = kS10 (key6, i+70)\n                  key8 = kS10 (key7, i+80)\n                  key9 = kS10 (key8, i+90)\n\nkeySchedule' :[80] -> [508]\nkeySchedule' key = key13\n            where key0 = kS100 (key, 80)\n                  key1= kS100 (key0, 180)\n                  key2 = kS100 (key1, 280)\n                  key3 = kS100 (key2, 380)\n                  key4 = kS10(key3, 480)\n                  key5 = kS10 (key4, 490)\n                  key6 = kS (key5, 500)\n                  key7 = kS (key6, 501)\n                  key8 = kS (key7, 502)\n                  key9 = kS (key8, 503)\n                  key10 = kS (key9, 504)\n                  key11 = kS (key10, 505)\n                  key12 = kS (key11, 506)\n                  key13 = kS (key12, 507)\n\nfunFa : [L1Size]-> [xSize][xSize] -> [508] -> [Round] -> Bit\n\nfunFa L1 x k i = (L1!(x@0)) ^ (L1!(x@1)) ^ ((L1!(x@2)) && (L1!(x@3))) ^ ((L1!(x@4)) && ((iR@0)@i)) ^ (k@(pmult (2:[2]) i))\n\nfunFb : [L2Size]-> [ySize][ySize] -> [508] -> [Round] -> Bit\n\nfunFb L2 y k i = (L2!(y@0)) ^ (L2!(y@1)) ^ (L2!(y@2) && L2!(y@3)) ^ (L2!(y@4) && L2!(y@5)) ^ (k@((pmult (2:[2]) i)+1))\n\naply_fb : [L1Size] -> [L2Size]->  [ySize][ySize] ->[KatanKeySize] -> [Round] -> [L1Size]\naply_fb l1 l2 y key i = (l1 !! [(L1Size-2),(L1Size-3)..0]) # [(funFb l2 y (keySchedule' key) i)]\n\naply_fa : [L1Size] -> [L2Size]-> [xSize][xSize]->[KatanKeySize] -> [Round] -> [L2Size]\naply_fa l1 l2 x key i = (l2 !! [(L2Size-2),(L2Size-3)..0]) # [(funFa l1 x (keySchedule' key) i)]\n\nupdateLfsr : [L1Size] -> [L2Size]-> [xSize][xSize] -> [ySize][ySize]->[KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\nupdateLfsr l1 l2 x y key i = if `(L1Size) == 13\n                             then (l1', l2')\n                             else if `(L1Size) == 19\n                                  then (l1'', l2'')\n                                  else (l1''', l2''')\n\n                 where pt = (aply_fb l1 l2 y key i) # (aply_fa l1 l2 x key i)\n                       l1' = (splitBlock pt).0\n                       l2' = (splitBlock pt).1\n                       pt' = (aply_fb l1' l2' y key i) # (aply_fa l1' l2' x key i)\n                       l1'' = (splitBlock pt').0\n                       l2'' =  (splitBlock pt').1\n                       pt'' = (aply_fb l1'' l2'' y key i) # (aply_fa l1'' l2'' x key i)\n                       l1''' = (splitBlock pt'').0\n                       l2''' =  (splitBlock pt'').1\n\n\/\/Encryption\n\nkatanEncrypt : ( [KatanKeySize], [KatanBlock]) -> _ \/\/ [KatanBlock]\n\nkatanEncrypt (key, pt) =  (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] # [ ( (updateLfsr pT.0 pT.1 x y key i).0, (updateLfsr pT.0 pT.1 x y key i).1)  | i<- [0,1..253] | pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\n\/\/ wrapper to do experiments\n\nkatanEncrypt64 : ([KatanBlock], [KatanBlock]) -> [KatanBlock]\nkatanEncrypt64 (key, pt) = katanEncrypt(key#zero, pt)\n\nkatanEncrypt80 : ([KatanKeySize], [KatanKeySize]) -> [KatanKeySize]\nkatanEncrypt80 (key, pt) = katanEncrypt(key, (take`{64} pt)) # zero\n\n\/\/Auxiliary functions for decryption\n\n\/\/ fa and fb\n\ndecFunFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ndecFunFa L1 L2 x k i = fa ^ (L1!((x@1)+1)) ^ (L1!((x@2)+1) && L1!((x@3)+1)) ^ (L1!((x@4)+1) && ((iR@0)@i)) ^ k@(2*i)\n         where fa = L2!0\n\ndecFunFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [508] -> [Round] -> Bit\ndecFunFb L2 L1 y k i =  fb ^ (L2!((y@1)+1)) ^ ((L2!((y@2)+1)) && L2!((y@3)+1)) ^ ((L2!((y@4)+1)) && L2!((y@5)+1)) ^ k@(2*i+1)\n         where fb = L1!0\n\n\/\/Left shifting L1, L2 and appending fa, fb values\n\naply_decFa_once : [L1Size] -> [L2Size] -> [xSize][xSize] -> [KatanKeySize] -> [Round] -> [L1Size]\n\naply_decFa_once  l1 l2 x k i = [(decFunFa l1 l2 x (keySchedule' k) i)] # (l1!![(L1Size-1),(L1Size-2)..1])\n\naply_decFb_once : [L2Size] -> [L1Size] -> [ySize][ySize] -> [KatanKeySize] -> [Round] -> [L2Size]\naply_decFb_once  l2 l1 y k i =  [(decFunFb l2 l1 y (keySchedule' k) i)] # (l2!![(L2Size-1),(L2Size-2)..1])\n\n\/\/ Updating LFSR for decryption\n\ndecUpdateLfsr: [L1Size] -> [L2Size] -> [xSize][xSize]-> [ySize][ySize] -> [KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\ndecUpdateLfsr  l1 l2 x y key i = if `(L1Size) == 13\n                                 then (l1', l2')\n                                 else if `(L1Size) == 19\n                                      then (l1'', l2'')\n                                      else (l1''', l2''')\n                               where ct = (aply_decFa_once l1 l2 x key i) # (aply_decFb_once l2 l1 y key i)\n                                     l1' = (splitBlock ct).0\n                                     l2' = (splitBlock ct).1\n                                     ct' = (aply_decFa_once l1' l2' x key i) # (aply_decFb_once l2' l1' y key i)\n                                     l1'' = (splitBlock ct').0\n                                     l2'' = (splitBlock ct').1\n                                     ct'' = (aply_decFa_once l1'' l2'' x key i) # (aply_decFb_once l2'' l1'' y key i)\n                                     l1''' = (splitBlock ct'').0\n                                     l2''' = (splitBlock ct'').1\n\nkatanDecrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\nkatanDecrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] #[ ((decUpdateLfsr pT.0 pT.1 x y key i).0 , (decUpdateLfsr pT.0 pT.1 x y key i).1)  | i <-[253,252..0] |pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\nproperty katanCorrect key m = katanEncrypt( key, katanDecrypt(key, m)) == m\n\nk_a_index = [0x3f, 0x1f, 0x1f, 0x0f, 0x0e, 0x3c, 0x28, 0x31, 0x23, 0x36, 0x2d,\n             0x3a, 0x25, 0x4a, 0x45, 0x4a, 0x35, 0x2b, 0x47, 0x3f, 0x1e, 0x2d,\n             0x0b, 0x36, 0x1c, 0x29, 0x03, 0x26, 0x3c, 0x19, 0x22, 0x05, 0x1a,\n             0x14, 0x09, 0x02, 0x14, 0x18, 0x01, 0x02, 0x34, 0x18, 0x11, 0x03,\n             0x06, 0x4c, 0x48, 0x31, 0x13, 0x17, 0x0f, 0x0e, 0x0c, 0x18, 0x10,\n             0x01, 0x02, 0x04, 0x28, 0x30, 0x11, 0x12, 0x05, 0x0a, 0x04, 0x08,\n             0x40, 0x40, 0x41, 0x33, 0x17, 0x2f, 0x0f, 0x4e, 0x4c, 0x49, 0x43,\n             0x37, 0x2f, 0x3f, 0x2f, 0x3e, 0x1d, 0x1a, 0x05, 0x0a, 0x24, 0x38,\n             0x21, 0x32, 0x15, 0x2a, 0x05, 0x3a, 0x14, 0x19, 0x03, 0x06, 0x0c,\n             0x38, 0x10, 0x21, 0x03, 0x46, 0x3c, 0x29, 0x43, 0x47, 0x4e, 0x4d,\n             0x3b, 0x27, 0x4f, 0x4f, 0x3e, 0x2d, 0x3b, 0x17, 0x2e, 0x0d, 0x2a,\n             0x34, 0x29, 0x42, 0x35, 0x2a, 0x35, 0x1b, 0x26, 0x0d, 0x4a, 0x34,\n             0x19, 0x23, 0x07, 0x3e, 0x2c, 0x49, 0x33, 0x16, 0x1d, 0x0b, 0x06,\n             0x2c, 0x48, 0x41, 0x32, 0x25, 0x4b, 0x37, 0x2e, 0x4d, 0x4b, 0x46,\n             0x3d, 0x1b, 0x27, 0x0f, 0x2e, 0x4c, 0x39, 0x22, 0x45, 0x3b, 0x26,\n             0x3d, 0x2b, 0x46, 0x4d, 0x3a, 0x15, 0x2b, 0x07, 0x1e, 0x2c, 0x09,\n             0x12, 0x24, 0x09, 0x32, 0x24, 0x39, 0x13, 0x16, 0x0d, 0x0a, 0x44,\n             0x38, 0x11, 0x13, 0x07, 0x0e, 0x1c, 0x28, 0x01, 0x42, 0x44, 0x39,\n             0x23, 0x37, 0x1f, 0x1e, 0x0d, 0x0a, 0x04, 0x48, 0x30, 0x21, 0x33,\n             0x27, 0x4e, 0x3d, 0x1a, 0x15, 0x0b, 0x06, 0x0c, 0x08, 0x20, 0x40,\n             0x31, 0x12, 0x25, 0x0b, 0x16, 0x1c, 0x09, 0x02, 0x04, 0x08, 0x00,\n             0x30, 0x20, 0x41, 0x43, 0x36, 0x1d, 0x1b, 0x07, 0x0e, 0x0c, 0x08,\n             0x00, 0x00, 0x10, 0x20, 0x01, 0x22, 0x44, 0x49, 0x42, 0x45, 0x4b,\n             0x47]\n\nk_b_index = [0x1f, 0x3f, 0x3f, 0x2f, 0x0e, 0x4c, 0x28, 0x11, 0x43, 0x16, 0x4d,\n             0x1a, 0x45, 0x0a, 0x45, 0x0a, 0x15, 0x2b, 0x07, 0x4f, 0x3e, 0x2d,\n             0x0b, 0x46, 0x3c, 0x29, 0x13, 0x46, 0x1c, 0x49, 0x22, 0x15, 0x4a,\n             0x34, 0x29, 0x12, 0x44, 0x38, 0x21, 0x02, 0x44, 0x38, 0x31, 0x23,\n             0x06, 0x4c, 0x08, 0x11, 0x33, 0x37, 0x3f, 0x2e, 0x1c, 0x48, 0x30,\n             0x31, 0x22, 0x14, 0x48, 0x10, 0x41, 0x32, 0x35, 0x3a, 0x24, 0x08,\n             0x40, 0x00, 0x01, 0x13, 0x37, 0x2f, 0x0f, 0x4e, 0x0c, 0x09, 0x03,\n             0x17, 0x2f, 0x1f, 0x4f, 0x1e, 0x4d, 0x3a, 0x25, 0x1a, 0x44, 0x18,\n             0x41, 0x12, 0x45, 0x2a, 0x05, 0x4a, 0x34, 0x39, 0x33, 0x26, 0x0c,\n             0x48, 0x30, 0x21, 0x03, 0x46, 0x1c, 0x29, 0x03, 0x47, 0x0e, 0x0d,\n             0x1b, 0x27, 0x0f, 0x4f, 0x1e, 0x2d, 0x1b, 0x47, 0x2e, 0x1d, 0x4a,\n             0x14, 0x49, 0x02, 0x45, 0x2a, 0x15, 0x4b, 0x26, 0x0d, 0x4a, 0x14,\n             0x39, 0x23, 0x07, 0x4e, 0x2c, 0x09, 0x43, 0x36, 0x3d, 0x2b, 0x16,\n             0x4c, 0x08, 0x41, 0x12, 0x25, 0x0b, 0x47, 0x2e, 0x0d, 0x4b, 0x06,\n             0x1d, 0x3b, 0x27, 0x1f, 0x4e, 0x0c, 0x49, 0x22, 0x05, 0x4b, 0x26,\n             0x1d, 0x4b, 0x06, 0x4d, 0x1a, 0x35, 0x2b, 0x17, 0x4e, 0x2c, 0x19,\n             0x42, 0x24, 0x09, 0x42, 0x24, 0x19, 0x43, 0x36, 0x2d, 0x0a, 0x44,\n             0x18, 0x31, 0x33, 0x27, 0x1e, 0x4c, 0x28, 0x01, 0x42, 0x04, 0x19,\n             0x23, 0x17, 0x4f, 0x3e, 0x3d, 0x2a, 0x04, 0x48, 0x10, 0x21, 0x13,\n             0x47, 0x0e, 0x4d, 0x3a, 0x35, 0x3b, 0x36, 0x2c, 0x18, 0x40, 0x00,\n             0x41, 0x32, 0x25, 0x1b, 0x46, 0x3c, 0x39, 0x32, 0x34, 0x28, 0x00,\n             0x40, 0x20, 0x01, 0x43, 0x16, 0x3d, 0x3b, 0x37, 0x3e, 0x3c, 0x38,\n             0x20, 0x10, 0x40, 0x20, 0x11, 0x42, 0x04, 0x49, 0x02, 0x05, 0x0b,\n             0x07]\n\ntanFa : [L1Size]-> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ntanFa L1 x k i = (L1!(x@0)) ^ (L1!(x@1)) ^ ((L1!(x@2)) && (L1!(x@3))) ^ ((L1!(x@4)) && ((iR@0)@i)) ^ (k@(k_a_index @i))\n\ntanFb : [L2Size]-> [ySize][ySize] -> [508] -> [Round] -> Bit\n\ntanFb L2 y k i = (L2!(y@0)) ^ (L2!(y@1)) ^ (L2!(y@2) && L2!(y@3)) ^ (L2!(y@4) && L2!(y@5)) ^ (k@(k_b_index @i))\n\ntanAplyFb : [L1Size] -> [L2Size]->  [ySize][ySize] ->[KatanKeySize] -> [Round] -> [L1Size]\ntanAplyFb l1 l2 y key i = (l1 !! [(L1Size-2),(L1Size-3)..0]) # [(tanFb l2 y (keySchedule' key) i)]\n\ntanAplyFa : [L1Size] -> [L2Size]-> [xSize][xSize]->[KatanKeySize] -> [Round] -> [L2Size]\ntanAplyFa l1 l2 x key i = (l2 !! [(L2Size-2),(L2Size-3)..0]) # [(tanFa l1 x (keySchedule' key) i)]\n\nupdateLfsrTan : [L1Size] -> [L2Size]-> [xSize][xSize] -> [ySize][ySize]->[KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\nupdateLfsrTan l1 l2 x y key i = if `(L1Size) == 13\n                             then (l1', l2')\n                             else if `(L1Size) == 19\n                                  then (l1'', l2'')\n                                  else (l1''', l2''')\n\n                 where pt = (tanAplyFb l1 l2 y key i) # (tanAplyFa l1 l2 x key i)\n                       l1' = (splitBlock pt).0\n                       l2' = (splitBlock pt).1\n                       pt' = (tanAplyFb l1' l2' y key i) # (tanAplyFa l1' l2' x key i)\n                       l1'' = (splitBlock pt').0\n                       l2'' =  (splitBlock pt').1\n                       pt'' = (tanAplyFb l1'' l2'' y key i) # (tanAplyFa l1'' l2'' x key i)\n                       l1''' = (splitBlock pt'').0\n                       l2''' =  (splitBlock pt'').1\n\n\/\/Encryption\n\nkatantanEncrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\n\nkatantanEncrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] # [((updateLfsrTan pT.0 pT.1 x y key i).0, (updateLfsrTan pT.0 pT.1 x y key i).1) | i<- [0,1..253] | pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\/\/ Wrapper to do experiments\n\nkatantanEncrypt64 : ([KatanBlock], [KatanBlock]) -> [KatanBlock]\nkatantanEncrypt64  (key, pt) = katantanEncrypt( key#zero, pt)\n\nkatantanEncrypt80 : ([KatanKeySize], [KatanKeySize]) -> [KatanKeySize]\nkatantanEncrypt80  (key, pt) = katantanEncrypt( key, (take`{64} pt)) # zero\n\n\/\/KTANTAN-Decryption\n\ndecTanFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ndecTanFa L1 L2 x k i = fa ^ (L1!((x@1)+1)) ^ (L1!((x@2)+1) && L1!((x@3)+1)) ^ (L1!((x@4)+1) && ((iR@0)@i)) ^ k@(k_a_index@i)\n         where fa = L2!0\n\ndecTanFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [508] -> [Round] -> Bit\ndecTanFb L2 L1 y k i =  fb ^ (L2!((y@1)+1)) ^ ((L2!((y@2)+1)) && L2!((y@3)+1)) ^ ((L2!((y@4)+1)) && L2!((y@5)+1)) ^ k@(k_b_index@i)\n         where fb = L1!0\n\n\/\/Left shifting L1, L2 and appending fa, fb values\n\ntanAplydecFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [KatanKeySize] -> [Round] -> [L1Size]\n\ntanAplydecFa  l1 l2 x k i = [(decTanFa l1 l2 x (keySchedule' k) i)] # (l1!![(L1Size-1),(L1Size-2)..1])\n\ntanAplydecFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [KatanKeySize] -> [Round] -> [L2Size]\ntanAplydecFb  l2 l1 y k i =  [(decTanFb l2 l1 y (keySchedule' k) i)] # (l2!![(L2Size-1),(L2Size-2)..1])\n\n\/\/ Updating LFSR for decryption\n\ndecUpdateLfsrTan: [L1Size] -> [L2Size] -> [xSize][xSize]-> [ySize][ySize] -> [KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\ndecUpdateLfsrTan  l1 l2 x y key i = if `(L1Size) == 13\n                                 then (l1', l2')\n                                 else if `(L1Size) == 19\n                                      then (l1'', l2'')\n                                      else (l1''', l2''')\n                               where ct = (tanAplydecFa l1 l2 x key i) # (tanAplydecFb l2 l1 y key i)\n                                     l1' = (splitBlock ct).0\n                                     l2' = (splitBlock ct).1\n                                     ct' = (tanAplydecFa l1' l2' x key i) # (tanAplydecFb l2' l1' y key i)\n                                     l1'' = (splitBlock ct').0\n                                     l2'' = (splitBlock ct').1\n                                     ct'' = (tanAplydecFa l1'' l2'' x key i) # (tanAplydecFb l2'' l1'' y key i)\n                                     l1''' = (splitBlock ct'').0\n                                     l2''' = (splitBlock ct'').1\n\nkatantanDecrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\nkatantanDecrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] #[ ((decUpdateLfsrTan pT.0 pT.1 x y key i).0 , (decUpdateLfsrTan pT.0 pT.1 x y key i).1)  | i <-[253,252..0] |pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\nproperty katantanCorrect key m = katantanDecrypt(key, katantanEncrypt(key, m)) == m\n\ntests64 = [katan64_1, katan64_2, katantan64_1, katantan64_2]\nproperty testsPass = and tests64\n\nkatan64_1 = katanEncrypt( 0xffffffffffffffffffff, zero) == 0x21f2e99c0fab828a\nkatan64_2 = katanEncrypt(zero, 0xffffffffffffffff) == 0xc956100dbeb64ba8\n\nkatantan64_1 = katantanEncrypt(0xffffffffffffffffffff, zero) == 0xc02de05bfa194b16\nkatantan64_2 = katantanEncrypt(zero, 0xffffffffffffffff) == 0xc956100dbeb64ba8\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/TEA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::TEA that contains the following definitions implementing TEA, XTEA, and XXTEA with explicit types and checks: (1) Type synonyms for parameters and sizes: Nb=2, Nkb=4, Nr (type-level)=2, TeaBlockSize=64, TeaKeySize=128, stdBlock=32, keyInd=2, PTSize=TeaBlockSize, CTSize=TeaBlockSize, NB=2, bTeaPtSize=NB*stdBlock. (2) Constants: dlta:[32] is the TEA delta; sum:[32] is the initial sum. (3) Helpers: splitPT:[64]->[Nb][32]; splitKey:[128]->[Nkb][32]; splitPtN:[NB*32]->[NB][32]. (4) Round functions: teaRoundFun:[32]->[32]->[32]->[32]->[32]; xTeaRoundFun:[32]->[128]->[32]->[32]->[32]; bTeaRoundFun:[32]->[32]->[128]->[6]->[32]->[32]. (5) TEA cycles and APIs: teaEncCycle:([64],[128],[32])->[64]; teaDecCycle:([64],[128],[32])->[64]; teaEncrypt:([128],[64])->[64] performing 32 cycles; teaDecrypt:([128],[64])->[64] as the inverse. Define a property teaCorrect that checks decryption inverts encryption for TEA. (6) Reduced-key TEA wrappers using zero-extension: teaEncrypt':([64],[64])->[64]; teaDecrypt':([64],[64])->[64]. Define a property teaCorrect' with the same inversion check. (7) XTEA: xTeaEncCycle\/xTeaDecCycle:([64],[128],[32])->[64]; xTeaEncrypt\/xTeaDecrypt:([128],[64])->[64] over 32 cycles. Define a property xTeaCorrect for correctness. Helpers with 64-bit keys zero-extended: xTeaEncrypt64\/xTeaDecrypt64:([64],[64])->[64]; define property xTeaCorrect64. xTeaEncrypt128:([128],[128])->[128] by encrypting the lower 64 bits and zero-extending. (8) XXTEA: value-level Nr = 6 + 52\/NB; bTeaEncMixing\/bTeaDecMixing:([NB*32],[128],[32])->[NB*32]; bTeaEncrypt\/bTeaDecrypt:([128],[NB*32])->[NB*32]. Define a property bTeaCorrect for inversion. (9) Test vectors teaTest, xteaTest, xxteaTest as booleans; tests is their list. Define a property testsPass as their conjunction."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::TEA where\n\ntype Nb = 2\ntype Nkb = 4\ntype Nr = 2\ntype TeaBlockSize = 64\ntype TeaKeySize = 128\ntype stdBlock = 32\ntype keyInd = 2\n\nsplitPT: [TeaBlockSize] -> [Nb][stdBlock]\nsplitPT pt = split(pt):[Nb][stdBlock]\n\nsplitKey: [TeaKeySize] -> [Nkb][stdBlock]\nsplitKey key = split(key):[Nkb][stdBlock]\n\ndlta : [stdBlock]\ndlta = 0x9e3779b9\n\nsum = 0xc6ef3720\n\nteaRoundFun : [stdBlock] -> [stdBlock] -> [stdBlock] -> [stdBlock] -> [stdBlock]\nteaRoundFun pt k1 k2 delta = (pt << 4 + k1) ^ (pt + delta) ^ ((pt>>5)+k2)\n\nteaEncCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nteaEncCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          k0 = (splitKey key)@0\n          k1 = (splitKey key)@1\n          k2 = (splitKey key)@2\n          k3 = (splitKey key)@3\n          fiestr1 = rpt# roundf1\n          roundf1 = lpt + (teaRoundFun rpt k0 k1 sum)\n          fiestr2 = roundf1 # roundf2\n          roundf2 = rpt + (teaRoundFun roundf1 k2 k3 sum)\n\nteaDecCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nteaDecCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          k0 = (splitKey key)@0\n          k1 = (splitKey key)@1\n          k2 = (splitKey key)@2\n          k3 = (splitKey key)@3\n          roundf2 = rpt - (teaRoundFun lpt k2 k3 sum)\n          roundf1 = lpt - (teaRoundFun roundf2 k0 k1 sum)\n          fiestr2 = roundf1 # roundf2\n\nteaEncrypt : ([TeaKeySize], [TeaBlockSize]) -> [TeaBlockSize]\nteaEncrypt (key, pt) = (hs!0)\n    where hs = [pt] # [ teaEncCycle(m, key, i*dlta) | i <- [1,2..32] | m <- hs ]\n\nteaDecrypt : ([TeaKeySize], [TeaBlockSize]) -> [TeaBlockSize]\nteaDecrypt (key, ct) = (hs!0)\n    where hs = [ct] # [ teaDecCycle(cT, key, sum-i*dlta) | i <- [0,1..31] | cT <- hs ]\n\nproperty teaCorrect key m = teaDecrypt(key, teaEncrypt (key, m)) == m\n\nteaEncrypt' : ([TeaBlockSize], [TeaBlockSize]) -> [TeaBlockSize]\nteaEncrypt' (key, pt) = (hs!0)\n    where hs = [pt] # [ teaEncCycle(m, key', i*dlta) | i <- [1,2..32] | m <- hs ]\n          key' = key # zero\n\nteaDecrypt' : ([TeaBlockSize], [TeaBlockSize]) -> [TeaBlockSize]\nteaDecrypt' (key, ct) = (hs!0)\n    where hs = [ct] # [ teaDecCycle(cT, key', sum-i*dlta) | i<- [0,1..31] | cT <- hs ]\n          key' = key #zero\n\nproperty teaCorrect' key m = teaDecrypt'(key, teaEncrypt'(key, m)) == m\n\n\/************************************************************************\/\n\/************************************************************************\/\n\/* eXtended TEA *\/\n\n\/\/Round function for XTEA\n\nxTeaRoundFun : [stdBlock] -> [TeaKeySize] -> [stdBlock] -> [stdBlock] -> [stdBlock]\nxTeaRoundFun pt key sum1 sum2 = (((pt << 4) ^ (pt >> 5)) + pt) ^ (sum1 + k)\n    where k = (splitKey key)@(sum2 !![1,0])\n\n\/\/ XTEA cycle contains two Feistel rounds\n\nxTeaEncCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nxTeaEncCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          roundf1 = lpt +(xTeaRoundFun rpt key sum sum)\n          fiestr2 = roundf1 # roundf2\n          roundf2 = rpt+(xTeaRoundFun roundf1 key (sum+dlta) ((sum+dlta)>>11))\n\n\/\/XTEA decryption cycle contains two Feistel rounds\n\nxTeaDecCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nxTeaDecCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          roundf2 = rpt - (xTeaRoundFun lpt key sum (sum>>11))\n          roundf1 = lpt - (xTeaRoundFun roundf2 key (sum-dlta) (sum-dlta))\n          fiestr2 = roundf1 # roundf2\n\n\/\/Encryption: 32 XTEA cycles are recommended\n\/\/I change the signatures to run the experiments\n\ntype PTSize = TeaBlockSize\ntype CTSize = TeaBlockSize\n\nxTeaEncrypt : ([TeaKeySize], [PTSize]) -> [CTSize]\nxTeaEncrypt (key, pt) = (hs!0)\n    where hs = [pt] # [ xTeaEncCycle (m, key, i*dlta) | i <- [0,1..31] | m <- hs ]\n\n\/\/Decryption\n\nxTeaDecrypt : ([TeaKeySize], [CTSize]) -> [PTSize]\nxTeaDecrypt (key, ct) = (hs!0)\n    where hs = [ct] # [ xTeaDecCycle (pT, key, i*dlta) | i <- [32,31..1] | pT <- hs ]\n\nproperty xTeaCorrect key m = xTeaDecrypt(key, xTeaEncrypt(key, m)) == m\n\n\/\/ Helper function to run experiments\n\nxTeaEncrypt64 : ([PTSize], [PTSize]) -> [CTSize]\nxTeaEncrypt64 (key, pt) = (hs!0)\n    where hs = [pt] # [ xTeaEncCycle (m, key', i*dlta) | i <- [0,1..31] | m <- hs ]\n          key' = key # zero\n\nxTeaDecrypt64 : ([CTSize], [PTSize]) -> [PTSize]\nxTeaDecrypt64 (key, ct) = (hs!0)\n    where hs = [ct] # [ xTeaDecCycle (pT, key', i*dlta) | i <- [32,31..1] | pT <- hs ]\n          key' = key # zero\n\nproperty xTeaCorrect64 key m = xTeaDecrypt64 (key, xTeaEncrypt64(key,m)) == m\n\nxTeaEncrypt128 : ([TeaKeySize], [TeaKeySize]) -> [TeaKeySize]\nxTeaEncrypt128 (key, pt) = xTeaEncrypt (key, (take`{64} pt)) # zero\n\n\/************************************************************************\/\n\/************************************************************************\/\n\/* Corrected Block TEA or XXTEA*\/\n\/* XTEA modified to cater larger block sizes*\/\n\ntype NB = 2\nNr = 6 + 52\/`NB\ntype bTeaPtSize= NB*stdBlock\n\n\/\/Splitting text into number of words\n\nsplitPtN: [bTeaPtSize] -> [NB][stdBlock]\nsplitPtN pt = split(pt) : [NB][stdBlock]\n\n\/\/Round Function\n\nbTeaRoundFun: [stdBlock]-> [stdBlock]-> [TeaKeySize]-> [6]-> [stdBlock]->[stdBlock]\nbTeaRoundFun y z key p sum = ((z>>5) ^ (y<<2)) + ((y>>3) ^ (z<<4)) ^ (sum ^ y) + ((ki @ ((p!![1,0]) ^ e)) ^ z)\n    where ki = (splitKey key)\n          e = (sum >> 2) !![1,0]\n\n\/\/Mixing in encryption\n\nbTeaEncMixing : ([bTeaPtSize], [TeaKeySize], [stdBlock]) -> [bTeaPtSize]\n\nbTeaEncMixing (pt, key, sum) = join hs'\n    where pt' = splitPtN pt\n          hs = [ (pt'@0)+(bTeaRoundFun (pt'@1) (pt'@(`NB-1)) key 0 sum) ] # [ (pt'@p)+(bTeaRoundFun (pt'@(p+1)) h key p sum) | p <- [1,2..NB-2] | h <- hs ]\n          hs' = hs # [ (pt'@(`NB-1)) + (bTeaRoundFun (hs@0) (hs!0) key (`NB-1) sum) ]\n\nbTeaEncrypt : ([TeaKeySize], [bTeaPtSize]) -> [bTeaPtSize]\nbTeaEncrypt (key, pt) = hs!0\n    where hs = [bTeaEncMixing (pt, key, dlta)] # [ bTeaEncMixing (pT, key, i*dlta) | i <- [2,3..Nr] | pT <- hs ]\n\nbTeaDecMixing : ([bTeaPtSize], [TeaKeySize], [stdBlock]) -> [bTeaPtSize]\n\nbTeaDecMixing (pt, key, sum) = join hs''\n    where pt' = splitPtN pt\n          hs= [(pt'@(`NB-1)) - (bTeaRoundFun (pt'@0) (pt'@(`NB-2)) key  1 sum)] # [ pt'@(`NB-1-p)-(bTeaRoundFun h (pt'@ (`NB-2-p)) key p sum) | p <- [1,2..(NB-2)] | h <- hs ]\n          hs' =  hs # [ pt'@0 - (bTeaRoundFun (hs!0) (hs@0) key  0 sum)]\n          hs'' = [hs'!0] # [hs'!i | i<- [1,2..NB-1] ]\n\nbTeaDecrypt : ([TeaKeySize], [bTeaPtSize]) -> [bTeaPtSize]\nbTeaDecrypt (key, pt) =  hs!0\n    where hs = [bTeaDecMixing (pt, key, `Nr*dlta)] # [ bTeaDecMixing (pT, key, (`Nr-i)*dlta) | i <- [1,2..(Nr-1)] | pT <- hs ]\n\nproperty bTeaCorrect key m = bTeaDecrypt(key, bTeaEncrypt (key, m)) == m\n\ntests = [teaTest, xteaTest, xxteaTest]\nproperty testsPass = and tests\n\nteaTest = teaEncrypt(0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0xce674a7575034065\nxteaTest = xTeaEncrypt(0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0x27e795e076b2b537\nxxteaTest = bTeaEncrypt(0x0123456789abcdef0123456789abcdef,0x0123456789abcdef) == 0x2b98de778c9b788c\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Authenticated::GCM::Specification that contains the following definitions: (1) Import a block-cipher interface as C and impose interface constraints that the block size is 128 bits and the key size is at least 128 bits. (2) Type constraints: ValidIV (bit-width \u2264 64, \u2265 1, and byte-aligned), ValidAAD (bit-width \u2264 64 and byte-aligned), ValidTag (finite, byte-aligned, length in bytes between 12 and 16 inclusive), and ValidText (finite, length \u2264 2^39 \u2212 256 and byte-aligned). (3) A function GCM_AE with size-polymorphic parameters for ciphertext, IV, AAD, and tag that, given a key, IV, plaintext, and AAD, returns ciphertext of the same length as the plaintext and an authentication tag of the requested length. Use C::encrypt to derive the hash subkey from the all-zero block, derive the initial counter from the IV (special-case 96-bit IVs, otherwise GHASH the IV with length encoding), encrypt via a counter mode that increments the low 32 bits per block, compute GHASH over AAD and ciphertext with zero padding to 128-bit blocks and 64-bit length encodings, then compute the tag by encrypting the GHASH output and truncating to the requested tag length. (4) A function GCM_AD that recomputes the tag from key, IV, ciphertext, and AAD; return Some plaintext if the provided tag matches, otherwise None. (5) Define a property that the bit-serial field multiplication equals the polynomial-reduction multiplication over GF(2^128). (6) Define a property that encrypting then decrypting with the same inputs yields the original plaintext. (7) Private helpers: J0 derivation, GF(2^128) multiply (two variants), GHASH, counter increment on a selected LSB width, MSB\/LSB extractors, GCTR, and a property that GCTR maps empty input to empty output."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Specification where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\ninterface constraint (C::BlockSize == 128)\n\n interface constraint (128 <= C::KeySize)\n\ntype constraint ValidIV IV = (width IV <= 64, IV >= 1, IV % 8 == 0)\n\ntype constraint ValidAAD AAD = (width AAD <= 64, AAD % 8 == 0)\n\ntype constraint ValidTag T = (fin T, T % 8 == 0, T \/ 8 >= 12, T \/ 8 <= 16)\n\ntype constraint ValidText P = (fin P, P <= 2^^39 - 256, P % 8 == 0)\n\nGCM_AE : { len_C, len_IV, len_A, T } (ValidText len_C, ValidIV len_IV, ValidAAD len_A, ValidTag T)\n => [C::KeySize] -> [len_IV] -> [len_C] -> [len_A] -> ([len_C], [T])\nGCM_AE k iv p a = (C, T)\n  where\n    CIPHk = C::encrypt k\n\n    H = CIPHk 0\n    J0 = define_J0 k iv H\n    C = GCTR CIPHk (inc`{32} J0) p\n    type u = len_C %^ 128     type v = len_A %^ 128     S = GHASH`{len_A\/^ 128 + len_C \/^ 128 + 1}\n            H (a # (0 : [v]) # C # (0 : [u]) # (`len_A : [64]) # (`len_C : [64]))\n    T = MSB`{T} (GCTR CIPHk J0 S)\n\nGCM_AD : { len_C, len_IV, len_A, T } (ValidText len_C, ValidIV len_IV, ValidAAD len_A, ValidTag T)\n => [C::KeySize] -> [len_IV] -> [len_C] -> [len_A] -> [T] -> Option [len_C]\nGCM_AD key iv ct aad tag =\n  if tag == T'\n  then Some P\n  else None\n  where\n    CIPHk = C::encrypt key\n\n    H = CIPHk 0\n    J0 = define_J0 key iv H\n    P = GCTR CIPHk (inc`{32} J0) ct\n    type u = len_C %^ 128 \/\/ Equivalently: 128 * len_C \/^ 128 - len_C\n    type v = len_A %^ 128 \/\/ Equivalently: 128 * len_A \/^ 128 - len_A\n    S = GHASH`{len_A \/^ 128 + len_C \/^ 128 + 1}\n            H (aad # (0 : [v]) # ct # (0 : [u]) # (`len_A : [64]) # (`len_C : [64]))\n    T' = MSB`{T} (GCTR CIPHk J0 S)\n\nproperty dotAndMultAreEquivalent X Y = mult X Y == X \u2022 Y\n\ngcmIsSymmetric : { P, IV, AAD } ( ValidText P, ValidIV IV, ValidAAD AAD )\n  => [C::KeySize] -> [IV] -> [P] -> [AAD] -> Bool\nproperty gcmIsSymmetric key iv pt aad = is_symmetric\n    where\n        (ct, tag : [96]) = GCM_AE key iv pt aad\n        dec = GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nprivate\n\n  define_J0 : { len_IV } ( ValidIV len_IV ) => [C::KeySize] -> [len_IV] -> [128] -> [128]\n  define_J0 k iv H\n    | len_IV == 96 => iv # (0 : [31]) # (1 : [1])\n    | len_IV != 96 => GHASH`{len_IV \/^ 128 + 1} H (iv # (0 : [s + 64]) # (`len_IV: [64]))\n    where\n      type s = len_IV %^ 128  \n\n  (\u2022) : [128] -> [128] -> [128]\n  (\u2022) X Y = reverse (pmod (pmult (reverse X) (reverse Y))\n                          <| 1 + x + x^^2 + x^^7 + x^^128|>)\n\n  mult : [128] -> [128] -> [128]\n  mult X Y = last Z\n    where\n      R = 0b11100001 # (0 : [120])\n      Z = [0] # [ if [xi] == 0 then Zi else Zi ^ Vi\n                | Zi <- Z\n                | xi <- X\n                | Vi <- V ]\n      V = [Y] # [ if LSB`{1} Vi == 0 then Vi >> 1 else (Vi >> 1) ^ R\n                | Vi <- V ]\n\n  GHASH : {m} (fin m) => [128] -> [m * 128] -> [128]\n  GHASH H X = last Y\n    where Y = [0] # [ (Yi ^ Xi) \u2022 H | Yi <- Y | Xi <- groupBy`{128} X ]\n\n  inc : {s, a} (fin s, fin a, a >= s) => [a] -> [a]\n  inc X = MSB`{a-s} X # (LSB`{s} X + take (1 : [max s 1]))\n\n  LSB : {s, a} (fin s, fin a, a >= s) => [a] -> [s]\n  LSB X = drop X\n\n  MSB : {s, a} (fin s, a >= s) => [a] -> [s]\n  MSB X = take X\n\n  GCTR : {a} (fin a) => ([128] -> [128]) -> [128] -> [a] -> [a]\n  GCTR CIPHk ICB X = Y\n    where\n      Y = X ^ take`{a} (join (map CIPHk CB))\n      CB = iterate inc`{32} ICB\n\n  emptyInputProducesEmptyOutputGCTR : [C::KeySize] -> [128] -> Bool\n  property emptyInputProducesEmptyOutputGCTR key icb =\n   zero == (GCTR CIPHk icb (zero : [0]))\n    where\n      CIPHk = C::encrypt key\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Tests\/AES128_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES128_GCM that imports the AES-128 GCM instantiation module under a short alias. Inside, declare four properties named aes128_vector_0, aes128_vector_1, aes128_vector_2, and aes128_vector_3. For each property: declare a 128-bit key, a 96-bit IV, a plaintext value (empty, a single 128-bit block, or a longer sequence as required), an associated data value (empty except the last case which is non-empty), and fixed expected ciphertext and 128-bit tag constants. Compute ciphertext and tag using the authenticated-encryption function from the imported module, and compute an optional plaintext via the corresponding authenticated-decryption function. Define a boolean is_symmetric that is true exactly when decryption returns Some actual plaintext equal to the original plaintext, and false if decryption fails. The property must assert the conjunction that the produced ciphertext equals the expected ciphertext, the produced tag equals the expected tag, and is_symmetric holds. Ensure types are explicit: key is 128 bits, IV is 96 bits, tag is 128 bits, the empty ciphertext for the empty plaintext is a 0-length sequence, and other values are sized to match their hex literals. Use the exact fixed hexadecimal values corresponding to the standard AES-128 GCM test vectors represented by these four cases."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES128_GCM where\nimport Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES128_GCM as AES_GCM\n\nproperty aes128_vector_0 = ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        pt = []\n        key = zero : [128]\n        iv = zero : [96]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt []\n        dec = AES_GCM::GCM_AD key iv ct [] tag\n        expected_ct = [] : [0]\n        expected_tag = 0x58e2fccefa7e3061367f1d57a4e7455a : [128]\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nproperty aes128_vector_1 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = zero\n        iv = zero : [96]\n        pt = zero\n        aad = []\n        expected_ct = 0x0388dace60b6a392f328c2b971b2fe78 : [128]\n        expected_tag = 0xab6e47d42cec13bdf53a67b21257bddf : [128]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nproperty aes128_vector_2 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = 0xfeffe9928665731c6d6a8f9467308308\n        iv = 0xcafebabefacedbaddecaf888 : [96]\n        pt = 0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b391aafd255\n        aad = []\n        expected_ct = 0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091473f5985\n        expected_tag = 0x4d5c2af327cd64a62cf35abd2ba6fab4 : [128]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nproperty aes128_vector_3 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = 0xfeffe9928665731c6d6a8f9467308308\n        pt  = 0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b39\n        iv  = 0xcafebabefacedbaddecaf888\n        aad = 0xfeedfacedeadbeeffeedfacedeadbeefabaddad2\n        expected_ct  = 0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091\n        expected_tag = 0x5bc94fbc3221a5db94fae95ae7121a47\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Tests\/AES256_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES256_GCM that contains: (1) an import of the AES-256-GCM instantiation module under the alias AES_GCM to access GCM_AE (encrypt-and-authenticate) and GCM_AD (decrypt-and-verify); (2) a property named aes256_vector_0 that uses fixed hexadecimal constants for a 256-bit key, a 96-bit IV, a 128-bit plaintext, a 128-bit associated data value, an expected ciphertext of the same width as the plaintext, and a 128-bit authentication tag. Within the property, compute (ciphertext, tag) using GCM_AE and assert both match the expected values, and also call GCM_AD with the produced ciphertext and tag and assert it returns Some of the original plaintext (use a Maybe match to yield a boolean). (3) a property named aes256_invalid_vector_1 that reuses the same key, IV, plaintext, AAD, and expected encryption outputs, defines an additional alternate (invalid) 128-bit tag, asserts the encryption still yields the expected ciphertext and valid tag, and asserts that calling GCM_AD with the invalid tag returns None (i.e., decryption\/authentication fails). Clearly state all bit widths for key (256), IV (96), plaintext\/ciphertext (128), AAD (128), and tag (128), and ensure each property is a boolean conjunction of the encryption equality checks with the corresponding decryption success\/failure predicate."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES256_GCM where\nimport Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES256_GCM as AES_GCM\n\nproperty aes256_vector_0 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key   = 0xeebc1f57487f51921c0465665f8ae6d1658bb26de6f8a069a3520293a572078f : [256]\n        iv    = 0x99aa3e68ed8173a0eed06684 : [96]\n        pt    = 0xf56e87055bc32d0eeb31b2eacc2bf2a5 : [128]\n        aad   = 0x4d23c3cec334b49bdb370c437fec78de : [128]\n        expected_ct   = 0xf7264413a84c0e7cd536867eb9f21736\n        expected_tag  = 0x67ba0510262ae487d737ee6298f77e0c\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nproperty aes256_invalid_vector_1 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ requires_symmetry\n    where\n        key   = 0xeebc1f57487f51921c0465665f8ae6d1658bb26de6f8a069a3520293a572078f : [256]\n        iv    = 0x99aa3e68ed8173a0eed06684 : [96]\n        pt    = 0xf56e87055bc32d0eeb31b2eacc2bf2a5 : [128]\n        aad   = 0x4d23c3cec334b49bdb370c437fec78de : [128]\n        expected_ct   = 0xf7264413a84c0e7cd536867eb9f21736\n        expected_tag  = 0x67ba0510262ae487d737ee6298f77e0c\n        invalid_tag  = 0x67ba0510262ae487d737ee6298f77888\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        requires_symmetry = case (AES_GCM::GCM_AD key iv ct aad invalid_tag) of\n            Some _ -> False\n            None -> True\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Instantiations\/AES128_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES128_GCM that is the generic Galois\/Counter Mode (GCM) specification specialized with the AES-128 block cipher implementation. The module must re-export, without modification, all type synonyms, constraints, constants, functions, and properties provided by the generic GCM specification when instantiated with AES-128. This includes AEAD encryption and decryption entry points, authentication tag computation and verification, GHASH-related operations, and any helper definitions. Ensure all sizes and constraints resolve to AES-128 parameters (128-bit block, 128-bit key) and that any length- or width-polymorphic aspects in the generic specification are concretized accordingly. Do not introduce new definitions; expose exactly the specialized interface of the generic GCM spec under this module name."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES128_GCM =\n    Primitive::Symmetric::Cipher::Authenticated::GCM::Specification {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Instantiations\/AES256_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named AES256_GCM that is exactly the generic GCM specification instantiated with the AES-256 block-cipher implementation, re-exporting all resulting types, constraints, and functions without modification. The module should expose: type aliases for key, nonce, tag, block, and byte sizes; the encryption and decryption operations over plaintext and associated data; authentication tag computation and verification; and any GHASH and counter-mode helpers provided by the specification. Constrain the underlying block cipher to have a 128-bit block size as required by GCM and a 256-bit key width. Do not add new logic\u2014make this module a concrete alias of the specialized GCM interface so users can import a ready-to-use AES-256-GCM API."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES256_GCM =\n    Primitive::Symmetric::Cipher::Authenticated::GCM::Specification {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::TDES_CBC that contains the following definitions: (1) an import of encrypt and decrypt from the TripleDES block cipher module; (2) type synonyms for a 64-bit initialization vector, a 64-bit block, and three 64-bit keys; (3) a polymorphic CBC encryption function taking three keys, an initialization vector, and a sequence of n 64-bit blocks, returning n 64-bit blocks, with a finiteness constraint on n; the function must build the three-key list, XOR each plaintext block with the previous ciphertext (or the IV for the first block), and apply the imported encrypt with the key list; (4) a matching CBC decryption function with the same type that decrypts each ciphertext block with the key list, then XORs with the previous ciphertext (or IV for the first block); (5) a property named to assert that, for any three keys, IV, and a plaintext of exactly three blocks, decrypt(encrypt(plaintext)) equals the original plaintext; (6) a record constant bundling three example 64-bit keys and a 64-bit IV, plus two constants giving an example plaintext vector and its expected ciphertext vector, all using 64-bit blocks; (7) a property that checks both directions: encrypting the example plaintext with the example keys and IV yields the example ciphertext, and decrypting the example ciphertext yields the example plaintext. Clearly state all types, size constraints, and that both properties produce a boolean result suitable for solver checking."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::TDES_CBC where\n\nimport Primitive::Symmetric::Cipher::Block::TripleDES (encrypt, decrypt)\n\ntype iv = [64]\ntype block = [64]\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncbcTDesEnc : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncbcTDesEnc k1 k2 k3 iv ps = cs\n    where\n        ks = [ k1, k2, k3 ]\n        cs = [ encrypt ks (p ^ c') | p <- ps | c' <- [iv] # cs ]\n\ncbcTDesDec : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncbcTDesDec k1 k2 k3 iv cts = pts\n    where\n        ks  = [ k1, k2, k3 ]\n        pts = [ (decrypt ks ct) ^ fb |  ct <- cts | fb <- [iv] # cts  ]\n\ncbcTDESEncryptDecryptInverts : k1 -> k2 -> k3 -> iv -> [3]block -> Bit\nproperty cbcTDESEncryptDecryptInverts k1 k2 k3 iv pt = pt == pt'\n    where\n        ct  = cbcTDesEnc k1 k2 k3 iv pt\n        pt' = cbcTDesDec k1 k2 k3 iv ct\n\ntestKey = { k1=0x0123456789ABCDEF\n          , k2=0x23456789ABCDEF01\n          , k3=0x456789ABCDEF0123\n          , iv=0xF69F2445DF4F9B17\n          }\ntestPt  = [0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]\ntestCt  = [0x2079C3D53AA763E1, 0x93B79E2569AB5262, 0x516570481F25B50F, 0x73C0BDA85C8E0DA7]\n\nproperty testsPass = pt == testPt\n                  \/\\ ct == testCt\n    where\n        ct = cbcTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv testPt\n        pt = cbcTDesDec testKey.k1 testKey.k2 testKey.k3 testKey.iv testCt\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::CBC that contains the following definitions: (1) an import of the block-cipher interface aliased as C; (2) a polymorphic function encrypt with type parameter n and constraint that n is finite, taking a key of size C::KeySize, an initialization vector of size C::BlockSize, and a sequence of n blocks of size C::BlockSize, returning a sequence of n blocks of size C::BlockSize; its algorithm implements CBC encryption by applying the block cipher encryption from C to each plaintext block xor\u2019d with the previous ciphertext block, using the IV as the initial previous ciphertext; (3) a polymorphic function decrypt with the same type and constraint, implementing CBC decryption by applying the block cipher decryption from C to each ciphertext block and xor\u2019ing the result with the previous ciphertext (using the IV for the first block); (4) define a property encryptCorrect that, for all finite n, keys, IVs, and plaintext sequences, asserts that decrypt with the same key and IV applied to the result of encrypt with that key and IV yields the original plaintext sequence. Clearly state all type signatures, constraints, parameter roles, and that C::encrypt and C::decrypt are the primitive block cipher operations used. Do not provide implementations, only the precise specifications and the property statement."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CBC where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\nencrypt : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\nencrypt K IV Ps = Cs\n    where\n        CIPH_K = C::encrypt K\n        Cs = [ CIPH_K (P_j ^ C_j_1) | P_j <- Ps | C_j_1 <- [IV] # Cs]\n\ndecrypt : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\ndecrypt K IV Cs = Ps\n    where\n        CIPH_K_inv = C::decrypt K\n        Ps = [ (CIPH_K_inv C_j) ^ C_j_1 | C_j <- Cs | C_j_1 <- [IV] # Cs]\n\nencryptCorrect : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> Bool\nproperty encryptCorrect K IV Ps = (decrypt K IV (encrypt K IV Ps)) == Ps\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::CTR that contains the following definitions: (1) import the block-cipher interface under the alias C; (2) a function encrypt parameterized by a size variable n with constraints that n is finite and strictly less than 2 to the power of the block size. The function takes a key of the cipher\u2019s key size, an initial counter block of the cipher\u2019s block size, and a sequence of n blocks of the cipher\u2019s block size, and returns a sequence of n blocks. It constructs a keystream by applying the cipher\u2019s encryption function under the given key to a counter sequence starting at the initial counter and incrementing by one for each block; it XORs each plaintext block with the corresponding keystream block to produce ciphertext; (3) a function decrypt with the same type and constraints as encrypt that reconstructs plaintext by XORing each ciphertext block with the same keystream derived from the key and counter sequence; (4) a Boolean-valued declaration for a property named encryptCorrect with the same constraints and argument types as encrypt, and define a property that, for all keys, initial counters, and block sequences of length n, decrypt applied to the result of encrypt yields the original sequence. Clearly specify that both encrypt and decrypt use C::encrypt for keystream generation and that counters are computed as the initial counter plus the block index starting from zero."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CTR where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\nencrypt : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\nencrypt k t_1 ps = cs\n    where\n        ciph_k = C::encrypt k\n                cs = [p_j ^ (ciph_k t_j) | p_j <- ps | t_j <- ctrs]\n                ctrs = [t_1 + i | i<- [0...]]\n\ndecrypt : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\ndecrypt k t_1 cs = ps\n    where\n        ciph_k = C::encrypt k\n                ps = [c_j ^ (ciph_k t_j) | c_j <- cs | t_j <- ctrs]\n                ctrs = [t_1 + i | i<- [0...]]\n\nencryptCorrect : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> Bool\nproperty encryptCorrect k c ps = (decrypt k c (encrypt k c ps)) == ps\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/XTS.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named block_xts_mode that contains the following definitions: (1) import a block-cipher interface (aliased C) and require its block size to be exactly 128 bits. (2) define a function that maps a 128-bit value to another 128-bit value by treating it as 16 bytes, reversing the byte order, and rejoining. (3) define a property asserting that applying the byte-reversal function twice returns the original input. (4) define a type constraint ValidLength over a size parameter n such that n is finite, n \u2265 128, and the number of 128-bit blocks in n is \u2264 2^20. (5) define a function that maps an n-bit data-unit sequence number (for n \u2264 128) to a 128-bit IV by zero-extending to 128 bits and then applying the byte-reversal function. (6) define a property giving one concrete example of this IV conversion that equates a fixed short input to its expected 128-bit result. (7) define constants for the polynomial element used as the GF(2) indeterminate and for the irreducible polynomial x^128 + x^7 + x^2 + x + 1 establishing GF(2^128). (8) define a function that multiplies a 128-bit value by the field element corresponding to x in GF(2^128) under a little-endian interpretation using endian-flip, polynomial multiply, modulus, and flip back. (9) define a function that, given a secondary key and a 128-bit IV, produces an infinite stream of 128-bit tweaks starting from encrypt(second-key, IV) and repeatedly applying the field-multiply function. (10) define single-block encrypt\/decrypt primitives that XOR a 128-bit tweak before and after the cipher call. (11) define top-level encrypt\/decrypt over arbitrary bit-length n satisfying ValidLength, using per-block tweaks and ciphertext stealing for a final partial block. (12) define a property stating that decrypt(encrypt(msg)) equals msg for all valid lengths."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::XTS where\n\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\ninterface constraint (C::BlockSize == 128)\n\nflipEndian : [128] -> [128]\nflipEndian x = join (reverse (groupBy`{8} x))\n\nproperty flipEndianInvolutive x = flipEndian (flipEndian x) == x\n\ntype constraint ValidLength n = (n \/^ C::BlockSize <= 2^^20, n >= C::BlockSize, fin n)\n\ndataUnitSeqNoToIV : {n} (n <= 128) => [n] -> [128]\ndataUnitSeqNoToIV S = flipEndian (zext S)\n\nproperty dataUnitSeqNoExample = dataUnitSeqNoToIV 0x123456789a == 0x9a785634120000000000000000000000\n\nmultAlphaLE : [128] -> [128]\nmultAlphaLE x = flipEndian (multAlpha (flipEndian x))\n  where\n    multAlpha p = pmod (pmult p alpha) irreducible\n\nalpha : [2]\nalpha = <| x |>\n\nirreducible : [129]\nirreducible = <| x^^128 + x^^7 + x^^2 + x + 1 |>\n\ngenerateTweaks : [C::KeySize] -> [128] -> [inf][128]\ngenerateTweaks K2 i = iterate multAlphaLE (C::encrypt K2 i)\n\nencryptBlock : [C::KeySize] -> [128] -> [128] -> [128]\nencryptBlock K T P = C\n  where\n            PP = T ^ P     CC = C::encrypt K PP     C  = CC ^ T \n\nencrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> [n]\nencrypt (K1 # K2) i P\n  | 0 == n % 128 =>\n    join\n      [ encryptBlock K1 T blk\n      | T <- generateTweaks K2 i\n      | blk <- split`{n \/ 128} P ]\n  | otherwise => C\n    where\n                  type M = n \/ 128\n\n                        T_0_m1 # [Tm1, Tm] = take`{M + 1} (generateTweaks K2 i)\n\n                        P_0_m2 # Pm1 # Pm = P\n\n            C_0_m2 = join [encryptBlock K1 T blk | T <- T_0_m1 | blk <- split`{M - 1} P_0_m2]\n\n            CC = encryptBlock K1 Tm1 Pm1\n\n            Cm # CP = CC\n\n            PP = Pm # CP\n\n            Cm1 = encryptBlock K1 Tm PP\n\n            C = C_0_m2 # Cm1 # Cm\n\ntype constraint otherwise = ()\n\ndecryptBlock : [C::KeySize] -> [128] -> [128] -> [128]\ndecryptBlock K T C = P\n  where\n            CC = C ^ T     PP = C::decrypt K CC     P = PP ^ T \n\ndecrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> [n]\ndecrypt (K1 # K2) i C\n  | 0 == n % 128 =>\n    join\n      [ decryptBlock K1 T blk\n      | T <- generateTweaks K2 i\n      | blk <- split`{n \/ 128} C ]\n  | otherwise => P\n    where\n            type M = n \/ 128\n\n            T_0_m2 # [Tm1, Tm] = take`{M + 1} (generateTweaks K2 i)\n\n            C_0_m2 # Cm1 # Cm = C\n\n            P_0_m2 = join [decryptBlock K1 T blk | T <- T_0_m2 | blk <- split`{M - 1} C_0_m2]\n\n            Pm # CP = decryptBlock K1 Tm Cm1\n\n            CC = Cm # CP\n\n            Pm1 = decryptBlock K1 Tm1 (Cm # CP)\n\n            P = P_0_m2 # Pm1 # Pm\n\ndecryptInvertsEncrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> Bool\nproperty decryptInvertsEncrypt K i P = decrypt K i (encrypt K i P) == P\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::TDES_CFB that contains the following definitions: (1) Import the TripleDES encrypt operation from the specified TripleDES module. (2) Type synonyms for 64-bit quantities: iv, block, k1, k2, and k3, each representing a 64-bit block. (3) A function cfbTDesEnc with a size parameter n constrained to be finite, taking three 64-bit keys, a 64-bit IV, and a sequence of n 64-bit plaintext blocks, returning a sequence of n 64-bit ciphertext blocks. It must implement Cipher Feedback mode for TripleDES: build the key schedule from the three keys; construct the feedback stream as the IV followed by the produced ciphertext; at each position, encrypt the current feedback block with TripleDES and XOR the result with the corresponding plaintext block to produce ciphertext. (4) A function cfbTDesDec with the same constraints and types as cfbTDesEnc, but taking ciphertext and returning plaintext. It must compute the same feedback stream (IV followed by the given ciphertext), encrypt each feedback block with TripleDES, and XOR with the corresponding ciphertext block to recover plaintext. (5) Define a property that, for any three 64-bit keys, a 64-bit IV, and any plaintext sequence of exactly three 64-bit blocks, decrypting the result of encrypting that plaintext with the same parameters yields the original plaintext. (6) Constants: a record testKey with fields k1=0x0123456789ABCDEF, k2=0x23456789ABCDEF01, k3=0x456789ABCDEF0123, iv=0xF69F2445DF4F9B17; a testPt list [0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]; and a testCt list [0x078BB74E59CE7ED6, 0x7666DE9CF95EAF3F, 0xE9ED6BB460F45152, 0x8A5F9FE4ED710918]. (7) Define a property that asserts encrypting testPt with testKey yields testCt and decrypting testCt yields testPt."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::TDES_CFB where\n\nimport Primitive::Symmetric::Cipher::Block::TripleDES (encrypt)\n\ntype iv = [64]\ntype block = [64]\n\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncfbTDesEnc : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncfbTDesEnc k1 k2 k3 iv ps = cs\n    where\n        ks = [ k1, k2, k3 ]\n        cs = [ (encrypt ks c') ^ p | p <- ps | c' <- [iv] # cs ]\n\ncfbTDesDec : {n} (fin n) => k1 -> k1 -> k3 -> iv -> [n]block -> [n]block\ncfbTDesDec k1 k2 k3 iv cts = pts\n    where\n        ks  = [ k1, k2, k3 ]\n        pts = [ (encrypt ks fb) ^ ct | ct <- cts | fb <- [iv] # cts ]\n\ncfbTDESEncryptDecryptInverts : k1 -> k2 -> k3 -> iv -> [3]block -> Bit\nproperty cfbTDESEncryptDecryptInverts k1 k2 k3 iv pt = pt == pt'\n    where\n        ct = cfbTDesEnc k1 k2 k3 iv pt\n        pt' = cfbTDesDec k1 k2 k3 iv ct\n\ntestKey = { k1=0x0123456789ABCDEF\n          , k2=0x23456789ABCDEF01\n          , k3=0x456789ABCDEF0123\n          , iv=0xF69F2445DF4F9B17\n          }\ntestPt = [0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]\ntestCt = [0x078BB74E59CE7ED6, 0x7666DE9CF95EAF3F, 0xE9ED6BB460F45152, 0x8A5F9FE4ED710918]\n\nproperty testsPass = ct == testCt\n                  \/\\ pt == testPt\n    where\n        ct = cfbTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv testPt\n        pt = cfbTDesDec testKey.k1 testKey.k2 testKey.k3 testKey.iv testCt\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AESKeyWrap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Modes::AESKeyWrap that contains the following definitions: (1) Import the block-cipher interface as alias C and assert interface constraints that the key size is at least 64 bits and the block size is 128 bits. (2) Type synonyms: an 8-bit octet, and a semiblock equal to half the block size. (3) Constants for the AES-KW and RFC 5649 IVs with their standard values and widths (64-bit and 32-bit, respectively). (4) Wrappers for encryption\/decryption using the interface (encrypt\/decrypt). (5) Utilities: a converter from bitvectors to Integer, a length function returning the size parameter as Integer, and MSB\/LSB extractors with size and finiteness constraints. (6) Predicate constraints for plaintext\/ciphertext sizes for KW and KWP variants. (7) Core wrap W and unwrap WInv with polymorphic sizes n >= 3 and a bound on 6*(n\u22121) fitting in a semiblock; implement the NIST AES Key Wrap state machine over A and an array of R blocks, iterating t counters, using split\/join, concatenation, MSB\/LSB selection, and XOR; WInv performs the inverse in reverse t order. (8) A property showing WInv\u2218W is identity on valid inputs. (9) KW_AE (wrap) and KW_AD (unwrap) that prepend\/check the KW IV, producing\/consuming an Option value; include a property that unwrap\u2218wrap returns the original plaintext. (10) KWP_AE (RFC 5649) that constructs S with KWP IV, 32-bit length, and zero padding to 64-bit multiples; Step5 uses single-block encrypt when short, else W. (11) KWP_AD that verifies IV, length, and padding, extracting payload; Step3 uses single-block decrypt when short, else WInv; include a property that unwrap\u2218wrap returns the payload. (12) Simple properties validating hex\/binary literals, zero, concatenation, XOR, bit-length, MSB\/LSB, and integer conversions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::AESKeyWrap where\n\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\ninterface constraint (C::KeySize >= 64)\ninterface constraint (C::BlockSize == 128)\n\ntype Octet = 8\n\ntype Semiblock = C::BlockSize \/ 2\n\nICV1 = 0xA6A6A6A6A6A6A6A6\n\nICV2 = 0xA65959A6\n\nCIPHK K X = C::encrypt K X\n\nCIPHInvK K X = C::decrypt K X\n\nint = toInteger\n\nlen : {n} (fin n) => [n] -> Integer\nlen _X = `n\n\nLSB : {s, n} (fin s, fin n, n >= s) => [n] -> [s]\nLSB = drop`{n - s}\n\nMSB : {s, n} (fin s, fin n, n >= s) => [n] -> [s]\nMSB = take`{s}\n\nproperty hexRepresentation = 0xA659 == 0b1010011001011001\n\nproperty zeroRepresentation = (zero : [8]) == 0b00000000\n\nproperty concatRepresentation = 0b001 # 0b10111 == 0b00110111\n\nproperty xorRepresentation = 0b10011 ^ 0b10101 == 0b00110\n\nproperty lenRepresentation = len 0b00010 == 5\n\nproperty signficanceWorks = lsb && msb where\n    X = 0b111011010\n    lsb = LSB`{3} X == 0b010\n    msb = MSB`{4} X == 0b1110\n\nproperty integerToString = (39 == 0b00100111) && ((39 : [8]) == 0b00100111)\n\nproperty stringToInteger = int 0b00011010 == 26\n\ntype constraint KW_Plaintext n = (2 <= n, width n <= 54)\n\ntype constraint KW_Ciphertext n = (3 <= n, n <= 2^^54)\n\ntype constraint KWP_Plaintext n = (1 <= n, width n <= 32)\n\ntype constraint KWP_Ciphertext n = (2 <= n, n <= 2^^29)\n\nW : {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n][Semiblock] -> [n * Semiblock]\nW K S = C where\n            type s = 6 * (n - 1)\n    A0 = S@0\n    R0 = drop`{1} S\n\n                    update_variables : ([Semiblock], [n-1][Semiblock]) -> [Semiblock]\n        -> ([Semiblock], [n-1][Semiblock])\n    update_variables (At1, Rt1) t = (At, Rt) where\n        At = MSB`{64} (CIPHK K (At1 # Rt1@0)) ^ t\n        Rnt = LSB`{64} (CIPHK K (At1 # Rt1@0))\n        Rt = drop`{1} Rt1 # [Rnt]\n\n    (As, Rs) = foldl update_variables (A0, R0) [1..s]\n\n        C1 = As\n    Cis = Rs\n    C = C1 # (join Cis)\n\nWInv : {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n][Semiblock] -> [n * Semiblock]\nWInv K C = S where\n            type s = 6 * (n - 1)\n    As = C@0\n    Rs = drop`{1} C\n\n                    update_variables : ([Semiblock], [n-1][Semiblock]) -> [Semiblock]\n        -> ([Semiblock], [n-1][Semiblock])\n    update_variables (At, Rt) t = (At1, Rt1) where\n        At1 = MSB`{64} (CIPHInvK K ((At ^ t) # Rt@`(n-2)))\n        R2t1 = LSB`{64} (CIPHInvK K ((At ^ t) # Rt@`(n-2)))\n        Rt1 = [R2t1] # take`{n-2} Rt\n\n    (A0, R0) = foldl update_variables (As, Rs) [s, s-1..1]\n\n        S1 = A0\n    Sis = R0\n    S = S1 # (join Sis)\n\nwrappingInverts :\n    {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n * Semiblock] -> Bit\nproperty wrappingInverts K S = S == S' where\n    C = W K (split S)\n    S' = WInv K (split C)\n\nKW_AE : {n} (KW_Plaintext n)\n    => [C::KeySize] -> [n * Semiblock] -> [(n + 1) * Semiblock]\nKW_AE K P = C where\n    S = ICV1 # P\n    C = W K (split S)\n\nKW_AD : {n} (KW_Ciphertext n)\n    => [C::KeySize] -> [n * Semiblock] -> Option [(n - 1) * Semiblock]\nKW_AD K C = if MSB`{64} S != ICV1 then None\n    else Some (LSB`{64 * (n - 1)} S)\n    where\n        S = WInv K (split C)\n\nkeyWrapInverts : {n} (KW_Plaintext n) => [C::KeySize] -> [n * Semiblock] -> Bit\nproperty keyWrapInverts K P = inverts where\n    C = KW_AE K P\n    inverts = case (KW_AD K C) of\n        Some maybeP -> maybeP == P\n        None -> False\n\nKWP_AE : {n} (KWP_Plaintext n, KWP_Ciphertext (n \/^ 8 + 1))\n    => [C::KeySize] -> [n * Octet] -> [(n \/^ 8 + 1) * Semiblock]\nKWP_AE K P = C where\n            type lenP = 8 * n\n\n        type padlen = 8 * (lenP \/^ 64) - (lenP \/ 8)\n\n        PAD = zero : [8 * padlen]\n\n        S = ICV2 # (`(lenP \/ 8) : [32]) # P # PAD\n\n        C = KWP_AE_Step5`{n} K S\n\nKWP_AE_Step5: {n} (KWP_Plaintext n)\n    => [C::KeySize] -> [(n \/^ 8 + 1) * Semiblock] -> [(n \/^ 8 + 1) * Semiblock]\nKWP_AE_Step5 K S\n    | 8 * n <= 64 => CIPHK K S\n    | 8 * n > 64 => W K (split S)\n\nKWP_AD : {m, n} (KWP_Ciphertext n, KWP_Plaintext m, n == 1 + m \/^ 8)\n    => [C::KeySize] -> [n * Semiblock] -> Option [m * Octet]\nKWP_AD K C =\n    if (ICV2 != MSB`{32} S)                         || (padlen < 0)                             || (padlen > 7)                             || (zero   != LSB`{8 * m %^ 64} S)          || (Plen   != `m)                           || (padlen != `(m %^ 8))                then None\n    else Some P\n    where\n        S = KWP_AD_Step3 K C\n\n                Plen = int (LSB`{32} (MSB`{64} S))\n        padlen = 8 * (`n - 1) - Plen\n\n                P = MSB`{8 * m} (LSB`{64 * (n - 1)} S)\n\nKWP_AD_Step3 : {n} (KWP_Ciphertext n)\n    => [C::KeySize] -> [n * Semiblock] -> [n * 64]\nKWP_AD_Step3 K C\n    | n == 2 => CIPHInvK K C\n    | n > 2 => WInv K (split C)\n\nkeyWrapPaddedInverts : {n} (KWP_Ciphertext (n \/^ 8 + 1), KWP_Plaintext n)\n    => [C::KeySize] -> [n * Octet] -> Bit\nproperty keyWrapPaddedInverts K P = inverts where\n    C = KWP_AE K P\n    inverts = case (KWP_AD K C) of\n        Some maybeP -> maybeP == P\n        None -> False\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Modes::CFB that imports the block-cipher interface as C and contains the following definitions: (1) A polymorphic function encrypt with size parameters s and n (both finite) constrained so that 0 <= s <= C::BlockSize. It takes a key of C::KeySize bits, an initialization vector of C::BlockSize bits, and a sequence of n segments each of s bits, and returns a sequence of n segments each of s bits. Implement Cipher Feedback (CFB) mode using the block-cipher encryption under the given key: initialize the feedback register with the IV; for each segment, encrypt the current register to form a keystream block, XOR the first s bits of that block with the current plaintext segment to produce the ciphertext segment, then update the register by removing its first s bits and appending the produced ciphertext segment. (2) A function decrypt with the same polymorphic type and constraints that uses the same keystream generation and register update as encrypt, but XORs the keystream\u2019s first s bits with the ciphertext segment to recover the plaintext. (3) Define a property that, under the same constraints on s and n, for all keys, IVs, and plaintext sequences, applying decrypt with the same key and IV to the result of encrypt yields the original plaintext sequence. Provide clear type signatures reflecting the key size, block size, and sequence dimensions, and use the sizes exported by C for key and block widths."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CFB where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\nencrypt : {s, n} (fin s, fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> [n][s]\nencrypt K IV Ps = Cs\n    where\n        CIPH_K = C::encrypt K\n        Is = [ (drop`{s} I_j_1) # C_j_1\n             | I_j_1 <- [IV] # Is\n             | C_j_1 <- Cs\n             ]\n        Cs = [ P_j ^ (take`{s} (CIPH_K I_j))\n             | P_j <- Ps\n             | I_j <- [IV] # Is\n             ]\n\ndecrypt : {s, n} (fin s, fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> [n][s]\ndecrypt K IV Cs = Ps\n    where\n        CIPH_K = C::encrypt K\n        Is = [ (drop`{s} I_j_1) # C_j_1\n             | I_j_1 <- [IV] # Is\n             | C_j_1 <- Cs\n             ]\n        Ps = [ C_j ^ (take`{s} (CIPH_K I_j))\n             | C_j <- Cs\n             | I_j <- [IV] # Is\n             ]\n\nencryptCorrect : {s, n} (fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> Bool\nproperty encryptCorrect K IV Ps = (decrypt K IV (encrypt K IV Ps)) == Ps\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Simon::Specification that contains: (1) Numeric type parameters n, m, j, and T with constraints: n and m are finite, n \u2265 4, 2 \u2264 m \u2264 4; j is finite with 0 \u2264 j < 5; T is finite with T > 4. (2) Functions on n-bit words: S (left rotate by i) and S_Inv (right rotate by i), polymorphic in a finite rotation amount i; f that mixes three rotated versions of its input. (3) Round transforms R and R_Inv that map a pair of n-bit words under an n-bit round key; include their types. (4) Helpers compose and composeMany for composing unary functions. (5) Encryption and decryption: encrypt and decrypt taking an m\u00b7n-bit key and a 2\u00b7n-bit block, using round keys from keySchedule and R\/R_Inv via function composition; also iterative variants encrypt' and decrypt' that accumulate rounds step-by-step and are extensionally equivalent. (6) Infinite bitstreams u, v, w, and t; derived streams z0..z4; a function extend that groups a stream into n-bit words; an array of extended streams and a selection by j; a constant c equal to 2^n \u2212 4; and a helper IS_Inv on n-bit words. (7) Key schedules keySchedule and keySchedule' that produce T n-bit round keys from m initial n-bit words, using the selected z-sequence; they must agree for all inputs and handle the m \u2208 {2,3,4} cases. (8) A linearMap for row-vector-by-matrix over XOR, 5\u00d75 matrices U, V, W, a generator seqn, and streams u', v', w' derived from those matrices. Also: define a property that decrypt inverts encrypt. define a property that encrypt equals the iterative encrypt. define a property that decrypt equals the iterative decrypt. define a property that S_Inv after S returns the input. define a property that R_Inv after R returns the input. define a property that different keys yield different key schedules. define a property that both key schedules are equivalent. define a property that the first 100 elements of each sequence (u, v, w) match its formal counterpart (u', v', w')."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Specification where\n\nparameter\n\n  type n : #\n\n  type m : #\n\n  type constraint (fin n, fin m, n >= 4, m >= 2, m <= 4)\n\n  type j : #\n  type constraint (j >= 0, j < 5)\n\n  type T : #\n\n  type constraint (fin T, T > 4)\n\nencrypt : [m * n] -> [2 * n] -> [2 * n]\nencrypt key plaintext = ciphertext\n  where\n    Simon_k = composeMany Rks\n            Rks = map R (keySchedule (reverse (split key)))\n    ciphertext = join (Simon_k (split plaintext))\n\ndecrypt : [m * n] -> [2 * n] -> [2 * n]\ndecrypt key ciphertext = plaintext\n  where\n    Simon_k = composeMany (reverse Rks)\n            Rks = map R_Inv (keySchedule (reverse (split key)))\n    plaintext = join (Simon_k (split ciphertext))\n\nprivate\n\n  property decryptInvertsEncrypt k pt = pt == decrypt k (encrypt k pt)\n\n  encrypt' : [m * n] -> [2 * n] -> [2 * n]\n  encrypt' key plaintext = join (rounds ! 0)\n    where\n      [x, y] = split plaintext\n      ks     = keySchedule' (reverse (split key))\n      \/\/ there are T round keys\n      \/\/ So, the following list comprehension runs over i = 0..T-1\n      rounds = [[x, y]] # [R k p | k <- ks | p <- rounds]\n\n  \/**\n   * Likewise, the decryption can be calculated in a more imperative fashion.\n   *\/\n  decrypt' : [m * n] -> [2 * n] -> [2 * n]\n  decrypt' key ciphertext = join (rounds ! 0)\n    where\n      [x, y] = split ciphertext\n      ks = keySchedule' (reverse (split key))\n      rounds = [[x, y]] # [R_Inv k ct | k <- (reverse ks) | ct <- rounds]\n\n  property encryptsEquivalent k p = encrypt k p == encrypt' k p\n\n  \/**\n   * The two formulations of decryption are functionally equiavalent.\n   *\n   * ```repl\n   * :check decryptsEquivalent\n   * ```\n   *\/\n  property decryptsEquivalent k p = decrypt k p == decrypt' k p\n\n  S : {i} (fin i) => [n] -> [n]\n  S x = x <<< `i\n\n  S_Inv : {i} (fin i) => [n] -> [n]\n  S_Inv x = x >>> `i\n\n  SInvertible : {i} (fin i) => [n] -> Bit\n  property SInvertible x = S_Inv `{i} (S `{i} x) == x\n\n  f : [n] -> [n]\n  f x = (S `{1} x && S `{8} x) ^ S `{2} x\n\n  R : [n] -> [2][n] -> [2][n]\n  R k [x, y] = [y ^ f x ^ k, x]\n\n  R_Inv : [n] -> [2][n] -> [2][n]\n  R_Inv k [x, y] = [y, x ^ f y ^ k]\n\n  property RInvertible k x = x == R_Inv k (R k x)\n\n  u : [inf]\n  u = 0b1111101000100101011000011100110 # u\n\n  v : [inf]\n  v = 0b1000111011111001001100001011010 # v\n\n  w : [inf]\n  w = 0b1000010010110011111000110111010 # w\n\n  t : [inf]\n  t = 0b01 # t\n\n  z0 = u\n\n  z1 = v\n\n  z2 = u ^ t\n\n  z3 = v ^ t\n\n  z4 = w ^ t\n\n  extend : [inf] -> [inf][n]\n  extend s = map (zext `{n}) (split `{inf, 1} s)\n\n  zjs = map extend [z0, z1, z2, z3, z4]\n\n  zj = zjs@`j\n\n  c : [n]\n  c = fromInteger (2 ^^ `n - 4)\n\n  IS_Inv : [n] -> [n]\n  IS_Inv x = x ^ S_Inv `{1} x\n\n  keySchedule : [m][n] -> [T][n]\n  keySchedule k0\n    | m == 2 => k where\n      k = k0 # [\n      c ^ zji ^ (k @ i) ^ IS_Inv (S_Inv `{3} (k @ (i+1)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n    | m == 3 => k where\n      k = k0 # [\n      c ^ zji ^ (k@i) ^ IS_Inv (S_Inv `{3} (k@(i+2)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n    | m == 4 => k where\n      k  = k0 # [\n      c ^ zji ^ (k@i) ^ IS_Inv (S_Inv `{3} (k@(i+3)) ^ (k@(i+1)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n\n  keySchedule' : [m][n] -> [T][n]\n  keySchedule' k0 = k\n    where\n      k = k0 # [ ki where\n                  tmp0 = k @ (i - 1) >>> 3\n                  tmp1 = if `m == 4 then tmp0 ^ k @ (i - 3) else tmp0\n                  tmp2 = tmp1 ^ tmp1 >>> 1\n                  ki = ~ k @ (i - `m) ^ tmp2 ^ z ^ 3\n                  z = zj @ ((i - `m) % 62)\n            | i <- [m .. T - 1]\n            ]\n\n  property keyScheduleInjective k p = k != p ==> keySchedule k != keySchedule p\n\n  property keySchedulesEquivalent k = keySchedule k == keySchedule' k\n\n  \/**\n   * Composition of functions `g` and `h`\n   * specialized to functions from `(a -> a)`.\n   *\/\n  compose : {a} () => (a -> a) -> (a -> a) -> a -> a\n  compose g h = \\x -> h (g x)\n\n  \/**\n   * Composition of many functions from `(a -> a)`\n   *\/\n  composeMany : {nf, a} (fin n) => [nf](a -> a) -> a -> a\n  composeMany fcns\n    | nf == 0 => \\x -> x\n    | nf == 1 => fcns@0\n    | nf == 2 => compose (fcns@0) (fcns@1)\n    | nf > 2  => compose (fcns@0) (composeMany (drop `{1} fcns))\n\n  \/**\n   * Multiplication of a row vector by a matrix\n   * This is not defined in the Simon specification.\n   * We take the straightforward approach of treating\n   * this as a linear combination of a subset of the\n   * matrix rows depending on which bits of the row vector are set.\n   *\/\n  linearMap : {rows, cols} (fin rows, fin cols) =>\n    [rows][cols] -> [rows] -> [cols]\n  linearMap matrix vector = foldl (^) zero matrix'\n    where\n      matrix' = map (\\(i, vi) -> if i then vi else zero) (zip vector matrix)\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `u`\n   * if the initial fill `0b00001` is used.\n   *\/\n  U = [ 0b01000\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10001\n      ]\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `v`\n   * if the initial fill `0b00001` is used.\n   *\/\n  V = [ 0b01100\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10000\n      ]\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `w`\n   * if the initial fill `0b00001` is used.\n   *\/\n  W = [ 0b01000\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10000\n      ]\n\n  \/**\n   * A function that treats row vector - matrix multiplication\n   * as a shift register, generating the sequence of shift\n   * register outputs for a given initial fill.\n   *\/\n  seqn : [5][5] -> [inf]\n  seqn matrix = map (\\x -> x@4) steps\n    where\n      steps     = iterate (\\x -> linearMap matrix x) 0b00001\n\n  \/**\n   * A formal definition of the sequence `u`,\n   * given in Section 3.2 of [SIMON].\n   *\/\n  u' = seqn U\n\n  v' = seqn V\n\n  \/**\n   * A formal definition of the sequence `w`,\n   * given in Section 3.2 of [SIMON].\n   *\/\n  w' = seqn W\n\n  property uDefinitionEquivalence = take `{100} u == take `{100} u'\n\n  \/**\n   * A property encoding that the formal and informal definitions of `v`\n   * are equivalent.\n   *\n   * ```repl\n   * :check vDefinitionEquivalence\n   * ```\n   *\/\n  property vDefinitionEquivalence = take `{100} v == take `{100} v'\n\n  property wDefinitionEquivalence = take `{100} w == take `{100} w'\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Speck::Specification that imports composeMany and compose from Common::utils. Declare type parameters n, m, and T with constraints: fin n, fin m, fin T; 2 <= m <= 4; T >= 2; n >= width T; and n >= 16. Define encrypt: [m*n] -> [2*n] -> [2*n] that splits a 2n-bit block into two n-bit words, derives round functions by scheduling keys from the m n-bit key words, composes the forward round transformers with composeMany, applies to the split state, then rejoins to 2n bits. Define decrypt with the same type that maps the inverse round over the schedule and composes them in reverse order before rejoining. Define S and S_Inv as n-bit rotations parameterized by a type-level j (left and right, respectively). Define S\u03b1 and S\u03b2 that choose rotation amounts based on n (use 7 and 2 when n equals 16, otherwise 8 and 3), and define their inverses S\u03b1_Inv and S\u03b2_Inv. Define the Speck round R: [n] -> [2][n] -> [2][n] using add-rotate-xor with S\u03b1_Inv and S\u03b2, and its inverse R_Inv. Provide factored helpers Rf1 and Rf2, and Rf that composes them to match R. Define keySchedule: [m][n] -> [T][n] that splits the key into an initial word and the remaining words, then iteratively produces T round keys using recurrences that update both the key stream and an auxiliary stream with S\u03b2 and S\u03b1_Inv and round indices. Define an equivalent keySchedule' using helpers derived from Rf1 and Rf2. Finally, define the following properties: decryptInvertsEncrypt (decrypt after encrypt returns the original block), RInvertible (R_Inv after R is identity), REquivalent (Rf equals R), keyScheduleInjective (distinct inputs yield distinct schedules), and keySchedulesEquivalent (both schedules are equal)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\nimport Common::utils (composeMany, compose)\n\nparameter\n\n    type n : #\n\n    type m : #\n\n    type T : #\n\n    type constraint (fin n, fin T, fin m)\n    type constraint (m >= 2, m <= 4, T >= 2, n >= width T)\n    type constraint (n >= 16)\n\nencrypt : [m * n] -> [2 * n] -> [2 * n]\nencrypt key plaintext = join (Speck_k (split plaintext))\n    where\n                                        Rks = map R (keySchedule (reverse (split key)))\n        Speck_k = composeMany Rks\n\ndecrypt : [m * n] -> [2 * n] -> [2 * n]\ndecrypt key ciphertext = join (Speck_k (split ciphertext))\n    where\n                Rks = map R_Inv (keySchedule (reverse (split key)))\n        Speck_k = composeMany (reverse Rks)\n\nprivate\n\n    property decryptInvertsEncrypt k x = decrypt k (encrypt k x) == x\n\n    S : {j} (fin j) => [n] -> [n]\n    S x = x <<< `j\n\n    S_Inv : {j} (fin j) => [n] -> [n]\n    S_Inv x = x >>> `j\n\n    S\u03b1: [n] -> [n]\n    S\u03b1 x | n == 16 => S `{7} x\n         | n >= 16 => S `{8} x\n\n    S\u03b2 : [n] -> [n]\n    S\u03b2 x | n == 16 => S `{2} x\n         | n >= 16 => S `{3} x\n\n    S\u03b1_Inv : [n] -> [n]\n    S\u03b1_Inv x | n == 16 => S_Inv `{7} x\n             | n >= 16 => S_Inv `{8} x\n\n    S\u03b2_Inv : [n] -> [n]\n    S\u03b2_Inv x | n == 16 => S_Inv `{2} x\n             | n >= 16 => S_Inv `{3} x\n\n    R : [n] -> [2][n] -> [2][n]\n    R k [x, y] = [(S\u03b1_Inv x + y) ^ k, S\u03b2 y ^ (S\u03b1_Inv x + y) ^ k]\n\n    R_Inv : [n] -> [2][n] -> [2][n]\n    R_Inv k [x, y] = [S\u03b1 ((x ^ k) - S\u03b2_Inv (x ^ y)), S\u03b2_Inv (x ^ y)]\n\n    property RInvertible k x = R_Inv k (R k x) == x\n\n    Rf1 : [n] -> [2][n] -> [2][n]\n    Rf1 k [x, y] = [y, (S\u03b1_Inv x + y) ^ k]\n\n    Rf2 : [2][n] -> [2][n]\n    Rf2 [x, y] = [y, S\u03b2 x ^ y]\n\n    Rf : [n] -> [2][n] -> [2][n]\n    Rf k s = f s\n        where\n            f = compose (Rf1 k) Rf2\n\n    property REquivalent k s = Rf k s == R k s\n\n    keySchedule : [m][n] -> [T][n]\n    keySchedule K = ks\n        where\n                        [k0] # li = K\n                        ks = [k0] # [S\u03b2 (ks @ i) ^ (ls @ (i + `m - 1)) | i <- [0..T - 2]]\n            ls = li # [(k + S\u03b1_Inv (ls @ i)) ^ i | k <- ks | i <- [0..T - 2] ]\n\n    property keyScheduleInjective k v = k != v ==> result\n        where\n            result = keySchedule k != keySchedule v\n\n    keySchedule' : [m][n] -> [T][n]\n    keySchedule' K = ks\n        where\n                        [k0] # li = K\n                        ks = [k0] # [f2 [(ks @ i), (ls @ (i + `m - 1))] | i <- [0..T - 2]]\n            ls = li # [f1 i [ls @ i, k] | k <- ks | i <- [0..T - 2] ]\n                                                f1 k s = (Rf1 k s) @ 1\n            f2 s = (Rf2 s) @ 1\n\n    property keySchedulesEquivalent K = keySchedule K == keySchedule' K\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::AES::Specification that imports the GF(2^8) utilities module under the alias GF28 and introduces a private type alias for the field element type. Parameterize the module by a numeric type KeySize' constrained to be finite, a multiple of 64, and in the set {128,192,256}. Derive Mode from the key size, and define Nk (words in key), Nr (rounds), Nb (state words = 4), and the exported aliases KeySize and BlockSize (128). Define types: State as a 4\u00d7Nb matrix of GF28 elements, RoundKey as 4\u00d74 GF28, and KeySchedule as (Nr+1) RoundKeys. Define functions and signatures: encrypt and decrypt mapping a KeySize-bit key and 128-bit block to a 128-bit block using cipher\/invCipher with keyExpansion; msgToState and stateToMsg as mutually inverse block\/state conversions using byte splitting and transposition; SBox and SBoxInv via private 256-entry lookup tables derived from multiplicative inversion in GF(2^8) and an affine transform; SubBytes\/InvSubBytes, ShiftRows\/InvShiftRows, MixColumns\/InvMixColumns (matrix multiplication over GF28 with the Rijndael matrices), and AddRoundKey as XOR. Define Rcon that returns the round constant word for a given 8-bit index. Define RotWord (1-byte left rotate) and SubWord (apply SBox to a word). Define keyExpansion for 32\u00b7Nk-bit keys to a (Nr+1) round schedule using the AES recurrence with the Nk==4\/6\/8 cases (including the extra SubWord at i mod Nk == 4 when Nk>6). Define cipher and invCipher as the AES forward and inverse round structures (initial add, Nr\u22121 full rounds, final round without MixColumns). Define a property aesIsCorrect asserting decrypt(encrypt(pt)) yields pt; define a property ioInverts stating state conversion round-trips; define a property SBox53 checking a known SBox test case; define a property SBoxInverts asserting SBoxInv \u2218 SBox is identity; define a property RconIsExponentiation asserting for indices 1..10 the first byte equals the field generator raised to (j\u22121); define properties subBytesInverts, shiftRowsInverts, and mixColumnsInverts asserting each inverse undoes its forward step."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Specification where\n\nimport Common::GF28 as GF28\nprivate type GF28 = GF28::GF28\n\nparameter\n      type KeySize' : #\n  type constraint (fin KeySize', KeySize' % 64 == 0, KeySize' \/ 64 >= 2,\n    KeySize' \/ 64 <= 4)\n\n\/**\n * The AES implementation uses the `Mode` type to compute other parameters.\n * The mode corresponds directly to the key size:\n * Mode 0 = 128 bits; Mode 1 = 192 bits; Mode 2 = 256 bits\n *\/\ntype Mode = (KeySize \/ 64) - 2\n\n\/\/ The following section encodes\n\n\/**\n * Key length: number of 32 bit words in the key.\n * [FIPS-197u1] Section 5, Table 3\n *\/\ntype Nk = 4 + 2 * Mode\n\n\/**\n * Number of rounds\n * [FIPS-197u1] Section 5, Table 3\n *\/\ntype Nr = 6 + Nk\n\n\/**\n * The number of words in the state is generic for the underlying Rijndael\n * algorithm, but in the standard it is fixed to 4.\n * [FIPS-197u1] Section 5.\n *\/\ntype Nb = 4\n\n\/\/ Make `KeySize` and `BlockSize` accessible outside the module.\n\/\/ This also lets us use AES as an instantiation of `CipherInterface`\ntype KeySize = KeySize'\ntype BlockSize = 128\n\nencrypt : [KeySize] -> [BlockSize] -> [BlockSize]\nencrypt k = cipher (keyExpansion k)\n\ndecrypt : [KeySize] -> [BlockSize] -> [BlockSize]\ndecrypt k = invCipher (keyExpansion k)\n\nproperty aesIsCorrect k pt = decrypt k (encrypt k pt) == pt\n\ntype State = [4][Nb]GF28\n\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\nproperty ioInverts msg = stateToMsg (msgToState msg) == msg\n\nsboxTable : [256]GF28\nprivate sboxTable = [ transform (GF28::inverse b) | b <- [0 .. 255] ] where\n        transform b = GF28::add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n        c = 0x63\n\nSBox : GF28 -> GF28\nSBox b = sboxTable @ b\n\nproperty SBox53 = SBox 0x53 == 0xed\n\nsboxInvTable : [256]GF28\nprivate sboxInvTable = [ GF28::inverse (transformInv b) | b <- [0 .. 255] ] where\n    transformInv b = GF28::add [(b >>> 2), (b >>> 5), (b >>> 7), d]\n    d = 0x05\n\nSBoxInv : GF28 -> GF28\nSBoxInv b = sboxInvTable @ b\n\nproperty SBoxInverts b = SBoxInv (SBox b) == b\n\ntype RoundKey = [4][4]GF28\n\ntype KeySchedule = [Nr+1]RoundKey\n\ncipher: KeySchedule -> [128] -> [128]\ncipher w pt = stateToMsg final_state   where\n        state0 = AddRoundKey (w @ 0) (msgToState pt)\n        state4 = foldl transform state0 (w @@ [1 .. (Nr - 1)])\n        transform state word = AddRoundKey word (MixColumns (ShiftRows (SubBytes state)))\n        final_state = AddRoundKey (w @ `Nr) (ShiftRows (SubBytes (state4)))\n\nSubBytes : State -> State\nSubBytes state = [ [ SBox b | b <- row ] | row <- state ]\n\nShiftRows : State -> State\nShiftRows state = [ row <<< i | row <- state | i : [2] <- [0 .. 3] ]\n\nMixColumns : State -> State\nMixColumns state = GF28::matrixMult m state\n    where m = [ [2,3,1,1] >>> i | i : [2] <- [0 .. 3] ]\n\nAddRoundKey : RoundKey -> State -> State\nAddRoundKey w state = w ^ state\n\nRcon : [8] -> [4]GF28\nRcon j = constants @ (j - 1) where\n    constants = [\n        [0x01, 0x00, 0x00, 0x00],\n        [0x02, 0x00, 0x00, 0x00],\n        [0x04, 0x00, 0x00, 0x00],\n        [0x08, 0x00, 0x00, 0x00],\n        [0x10, 0x00, 0x00, 0x00],\n        [0x20, 0x00, 0x00, 0x00],\n        [0x40, 0x00, 0x00, 0x00],\n        [0x80, 0x00, 0x00, 0x00],\n        [0x1b, 0x00, 0x00, 0x00],\n        [0x36, 0x00, 0x00, 0x00]\n    ]\n\nRconIsExponentiation : [8] -> Bit\nproperty RconIsExponentiation j = (1 <= j) && (j <= 10) ==>\n    (Rcon j)@0 == GF28::pow <| x |> (j-1)\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord [a0, a1, a2, a3] = [ SBox a0, SBox a1, SBox a2, SBox a3 ]\n\nkeyExpansion : [32 * Nk] -> [Nr+1]RoundKey\nkeyExpansion key = keys\n  where\n        seed : [Nk][4]GF28\n    seed = split (split key)\n\n        ws : [inf][4]GF28\n    ws = seed # [ nextWord i w_1 w_nk\n       | i    <- [ `Nk ... ]\n       | w_1  <- drop`{Nk-1} ws\n       | w_nk <- ws\n       ]\n\n                nextWord : [8] ->[4]GF28 -> [4]GF28 -> [4]GF28\n    nextWord i w_1 w_nk = w_i where\n            temp =\n                if i % `Nk == 0 then\n          SubWord (RotWord w_1) ^ Rcon (i \/ `Nk)\n                else if (`Nk > 6) && (i % `Nk == 4) then\n          SubWord w_1\n                else w_1\n\n            w_i = w_nk ^ temp\n\n            keys = take `{Nr+1} [ transpose g | g <- split ws ]\n\ninvCipher: KeySchedule -> [128] -> [128]\ninvCipher w ct = stateToMsg final_state   where\n        state0 = AddRoundKey (w @ `Nr) ( msgToState ct)\n        state4 = foldl transform state0 (reverse (w @@ [1 .. (Nr - 1)]))\n        transform state word = InvMixColumns (AddRoundKey word (InvSubBytes (InvShiftRows state)))\n        final_state = AddRoundKey (w @ 0) (InvSubBytes (InvShiftRows (state4)))\n\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> i | row <- state | i : [2] <- [0 .. 3] ]\n\nInvSubBytes : State -> State\nInvSubBytes state = [ [ SBoxInv b | b <- row ] | row <- state ]\n\nInvMixColumns : State -> State\nInvMixColumns state = GF28::matrixMult m state\n    where m = [[0x0e, 0x0b, 0x0d, 0x09] >>> i | i : [2] <- [0 .. 3] ]\n\nsubBytesInverts : State -> Bool\nproperty subBytesInverts s = InvSubBytes (SubBytes s) == s\n\nshiftRowsInverts : State -> Bool\nproperty shiftRowsInverts s = InvShiftRows (ShiftRows s) == s\n\nmixColumnsInverts : State -> Bool\nproperty mixColumnsInverts s = InvMixColumns (MixColumns s) == s\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR that imports Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR (you may alias it). Inside, include two definitions: (1) property aes256_ctr_encrypt_vector asserting that calling the imported encrypt function with a 256-bit key, a 128-bit initial counter, and a sequence of four 128-bit plaintext blocks yields the expected sequence of four 128-bit ciphertext blocks; and (2) property aes256_ctr_decrypt_vector asserting that calling the imported decrypt function with the same key and initial counter on the ciphertext recovers the original plaintext. Provide the constants for key, initial counter, plaintext blocks, and ciphertext blocks using the AES-256 CTR test vectors from NIST SP 800-38A (section F.5.5). Use local where-bindings to define these constants within each property. Ensure the function calls are qualified to the imported module, the key has width 256 bits, the counter has width 128 bits, and the plaintext\/ciphertext values are sequences of length 4 of 128-bit blocks. The properties must evaluate to boolean equalities suitable for solver checking."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR as AES256_CTR\n\nproperty aes256_ctr_encrypt_vector = (AES256_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x601ec313775789a5b7a7f504bbf3d228,\n        0xf443e3ca4d62b59aca84e990cacaf5c5,\n        0x2b0930daa23de94ce87017ba2d84988d,\n        0xdfc9c58db67aada613c2dd08457941a6]\n\nproperty aes256_ctr_decrypt_vector = (AES256_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x601ec313775789a5b7a7f504bbf3d228,\n        0xf443e3ca4d62b59aca84e990cacaf5c5,\n        0x2b0930daa23de94ce87017ba2d84988d,\n        0xdfc9c58db67aada613c2dd08457941a6]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CFB that imports Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB as AES192_CFB and contains the following definitions: aes192_cfb1_encrypt_vector, aes192_cfb1_decrypt_vector, aes192_cfb8_encrypt_vector, aes192_cfb8_decrypt_vector, aes192_cfb128_encrypt_vector, aes192_cfb128_decrypt_vector. For each named definition, define a property that asserts equality between the AES192_CFB encrypt\/decrypt result and an expected test vector, using a single fixed 192-bit key and a single fixed 128-bit IV. Use local bindings (where-clauses) to bind the key, IV, plaintext, and ciphertext constants. Segment sizes and shapes: for the 1-bit CFB case, use a length-16 sequence of bits; for the 8-bit CFB case, use a length-18 sequence of bytes; for the 128-bit CFB case, use a length-4 sequence of 128-bit blocks. The \u201cencrypt_vector\u201d properties must assert that AES192_CFB::encrypt key iv plaintext equals ciphertext, and the corresponding \u201cdecrypt_vector\u201d properties must assert that AES192_CFB::decrypt key iv ciphertext equals plaintext. Ensure the literal widths of the key, IV, plaintext, and ciphertext make each call well-typed and that each property is a Boolean suitable for solver checking."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB as AES192_CFB\n\nproperty aes192_cfb1_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b1, 0b1,\n            0b0, 0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1\n        ]\n\nproperty aes192_cfb1_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b1, 0b1,\n            0b0, 0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\nproperty aes192_cfb8_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0xcd, 0xa2, 0x52, 0x1e, 0xf0, 0xa9, 0x05, 0xca, 0x44,\n            0xcd, 0x05, 0x7c, 0xbf, 0x0d, 0x47, 0xa0, 0x67, 0x8a\n        ]\n\nproperty aes192_cfb8_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xcd, 0xa2, 0x52, 0x1e, 0xf0, 0xa9, 0x05, 0xca, 0x44,\n            0xcd, 0x05, 0x7c, 0xbf, 0x0d, 0x47, 0xa0, 0x67, 0x8a\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\nproperty aes192_cfb128_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0xcdc80d6fddf18cab34c25909c99a4174,\n            0x67ce7f7f81173621961a2b70171d3d7a,\n            0x2e1e8a1dd59b88b1c8e60fed1efac4c9,\n            0xc05f9f9ca9834fa042ae8fba584b09ff\n        ]\n\nproperty aes192_cfb128_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv =  0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xcdc80d6fddf18cab34c25909c99a4174,\n            0x67ce7f7f81173621961a2b70171d3d7a,\n            0x2e1e8a1dd59b88b1c8e60fed1efac4c9,\n            0xc05f9f9ca9834fa042ae8fba584b09ff\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CTR that imports Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CTR as AES128_CTR and contains the following definitions: two properties named aes128_ctr_encrypt_vector and aes128_ctr_decrypt_vector. Each property is a boolean assertion. In aes128_ctr_encrypt_vector, locally bind constants for a 128-bit key, a 128-bit initial counter, a sequence of four 128-bit plaintext blocks, and the corresponding sequence of four 128-bit ciphertext blocks taken from the first NIST AES-128 CTR test vector; assert that calling AES128_CTR.encrypt with the key, counter, and plaintext equals the expected ciphertext sequence. In aes128_ctr_decrypt_vector, reuse the same key and initial counter, locally bind the ciphertext and plaintext sequences from that test vector, and assert that calling AES128_CTR.decrypt with the key, counter, and ciphertext equals the expected plaintext sequence. Ensure types reflect AES-128 CTR: the key and counter are 128-bit words, and the plaintext\/ciphertext are sequences of four 128-bit blocks. Use the AES128_CTR module alias when invoking encrypt and decrypt."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CTR as AES128_CTR\n\nproperty aes128_ctr_encrypt_vector = (AES128_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x874d6191b620e3261bef6864990db6ce,\n        0x9806f66b7970fdff8617187bb9fffdff,\n        0x5ae4df3edbd5d35e5b4f09020db03eab,\n        0x1e031dda2fbe03d1792170a0f3009cee]\n\nproperty aes128_ctr_decrypt_vector = (AES128_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x874d6191b620e3261bef6864990db6ce,\n        0x9806f66b7970fdff8617187bb9fffdff,\n        0x5ae4df3edbd5d35e5b4f09020db03eab,\n        0x1e031dda2fbe03d1792170a0f3009cee]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CFB that imports Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CFB as AES256_CFB. Inside, define six properties: aes256_cfb1_encrypt_vector, aes256_cfb1_decrypt_vector, aes256_cfb8_encrypt_vector, aes256_cfb8_decrypt_vector, aes256_cfb128_encrypt_vector, and aes256_cfb128_decrypt_vector. In each property, bind local constants: a 256-bit key, a 128-bit initialization vector, and fixed plaintext\/ciphertext test vectors. For CFB1, use a sequence of 16 bits; for CFB8, use a sequence of 18 bytes; for CFB128, use a sequence of four 128-bit blocks. The encrypt properties must assert that AES256_CFB::encrypt applied to the key, IV, and plaintext equals the expected ciphertext. The decrypt properties must assert that AES256_CFB::decrypt applied to the key, IV, and ciphertext equals the expected plaintext. Use exactly the provided constants and lengths, ensuring types match AES-256 with a 128-bit block size and the respective CFB segment sizes so that each equality is a well-typed Boolean suitable for solver checking."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CFB as AES256_CFB\n\nproperty aes256_cfb1_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b0, 0b0,\n            0b0, 0b0, 0b1, 0b0, 0b1, 0b0, 0b0, 0b1\n        ]\n\nproperty aes256_cfb1_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b0, 0b0,\n            0b0, 0b0, 0b1, 0b0, 0b1, 0b0, 0b0, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\nproperty aes256_cfb8_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0xdc, 0x1f, 0x1a, 0x85, 0x20, 0xa6, 0x4d, 0xb5, 0x5f,\n            0xcc, 0x8a, 0xc5, 0x54, 0x84, 0x4e, 0x88, 0x97, 0x00\n        ]\n\nproperty aes256_cfb8_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xdc, 0x1f, 0x1a, 0x85, 0x20, 0xa6, 0x4d, 0xb5, 0x5f,\n            0xcc, 0x8a, 0xc5, 0x54, 0x84, 0x4e, 0x88, 0x97, 0x00\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\nproperty aes256_cfb128_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0xdc7e84bfda79164b7ecd8486985d3860,\n            0x39ffed143b28b1c832113c6331e5407b,\n            0xdf10132415e54b92a13ed0a8267ae2f9,\n            0x75a385741ab9cef82031623d55b1e471\n        ]\n\nproperty aes256_cfb128_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv =  0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xdc7e84bfda79164b7ecd8486985d3860,\n            0x39ffed143b28b1c832113c6331e5407b,\n            0xdf10132415e54b92a13ed0a8267ae2f9,\n            0x75a385741ab9cef82031623d55b1e471\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CTR that imports the AES-192 CTR instantiation as AES192_CTR and contains exactly two properties: aes192_ctr_encrypt_vector and aes192_ctr_decrypt_vector. The first property must assert that calling encrypt with a fixed 192-bit key, a fixed 128-bit initial counter block, and a list of four 128-bit plaintext blocks produces the expected list of four 128-bit ciphertext blocks. The second property must assert that calling decrypt with the same key and counter on that ciphertext list reproduces the original plaintext list. Use the standard NIST SP 800-38A AES-CTR 192-bit test vector values for the key, initial counter, plaintext, and ciphertext, provided as local constants within each property. Clearly indicate the bit widths: key as 192 bits, counter as 128 bits, and plaintext\/ciphertext as lists of four 128-bit blocks. Do not implement AES; only invoke the imported encrypt and decrypt functions and assert equality of results."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CTR as AES192_CTR\n\nproperty aes192_ctr_encrypt_vector = (AES192_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x1abc932417521ca24f2b0459fe7e6e0b,\n        0x090339ec0aa6faefd5ccc2c6f4ce8e94,\n        0x1e36b26bd1ebc670d1bd1d665620abf7,\n        0x4f78a7f6d29809585a97daec58c6b050]\n\nproperty aes192_ctr_decrypt_vector = (AES192_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x1abc932417521ca24f2b0459fe7e6e0b,\n        0x090339ec0aa6faefd5ccc2c6f4ce8e94,\n        0x1e36b26bd1ebc670d1bd1d665620abf7,\n        0x4f78a7f6d29809585a97daec58c6b050]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CFB that contains the following definitions: aes128_cfb1_encrypt_vector, aes128_cfb1_decrypt_vector, aes128_cfb8_encrypt_vector, aes128_cfb8_decrypt_vector, aes128_cfb128_encrypt_vector, and aes128_cfb128_decrypt_vector. Import the AES-128 CFB instantiation under the alias AES128_CFB and use its encrypt and decrypt functions. For each property, declare four local constants: a 128-bit key, a 128-bit initialization vector, a plaintext, and a ciphertext drawn from fixed test vectors. In the \u201c1\u201d variants, plaintext and ciphertext are sequences of 16 single-bit elements; in the \u201c8\u201d variants, they are sequences of bytes of equal length; in the \u201c128\u201d variants, they are sequences of four 128-bit blocks. The encrypt properties assert that encrypt(key, iv, plaintext) equals the expected ciphertext. The decrypt properties assert that decrypt(key, iv, ciphertext) equals the expected plaintext. Each property is a boolean equality suitable for solver checking, with no additional constraints beyond matching types and lengths appropriate to the segment sizes (1, 8, and 128)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB as AES128_CFB\n\nproperty aes128_cfb1_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b0, 0b0,\n            0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1, 0b1\n        ]\n\nproperty aes128_cfb1_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b0, 0b0,\n            0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\nproperty aes128_cfb8_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0x3b, 0x79, 0x42, 0x4c, 0x9c, 0x0d, 0xd4, 0x36, 0xba,\n            0xce, 0x9e, 0x0e, 0xd4, 0x58, 0x6a, 0x4f, 0x32, 0xb9\n        ]\n\nproperty aes128_cfb8_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0x3b, 0x79, 0x42, 0x4c, 0x9c, 0x0d, 0xd4, 0x36, 0xba,\n            0xce, 0x9e, 0x0e, 0xd4, 0x58, 0x6a, 0x4f, 0x32, 0xb9\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\nproperty aes128_cfb128_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0x3b3fd92eb72dad20333449f8e83cfb4a,\n            0xc8a64537a0b3a93fcde3cdad9f1ce58b,\n            0x26751f67a3cbb140b1808cf187a4f4df,\n            0xc04b05357c5d1c0eeac4c66f9ff7f2e6\n        ]\n\nproperty aes128_cfb128_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0x3b3fd92eb72dad20333449f8e83cfb4a,\n            0xc8a64537a0b3a93fcde3cdad9f1ce58b,\n            0x26751f67a3cbb140b1808cf187a4f4df,\n            0xc04b05357c5d1c0eeac4c66f9ff7f2e6\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CBC that contains the following definitions: import the AES-192 CBC instantiation module as AES192_CBC; define a property named aes192_cbc_encrypt_vector that asserts AES192_CBC::encrypt applied to a fixed 192-bit key, a fixed 128-bit IV, and a list of four 128-bit plaintext blocks produces the corresponding list of four 128-bit ciphertext blocks; define a property named aes192_cbc_decrypt_vector that asserts AES192_CBC::decrypt applied to the same key and IV and the ciphertext list recovers the original plaintext list. In each property, introduce constants via a where-block with types k:[192], iv:[128], plaintext:[4][128], ciphertext:[4][128], and bind them to specific literal values from a standard AES-192 CBC test vector with four blocks. Use the encrypt\/decrypt functions from AES192_CBC by qualified name; do not redefine them. Ensure the plaintext and ciphertext sequences are ordered per block index and the assertions compare entire sequences for equality."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CBC as AES192_CBC\n\nproperty aes192_cbc_encrypt_vector = (AES192_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x4f021db243bc633d7178183a9fa071e8,\n        0xb4d9ada9ad7dedf4e5e738763f69145a,\n        0x571b242012fb7ae07fa9baac3df102e0,\n        0x08b0e27988598881d920a9e64f5615cd]\n\nproperty aes192_cbc_decrypt_vector = (AES192_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0x4f021db243bc633d7178183a9fa071e8,\n        0xb4d9ada9ad7dedf4e5e738763f69145a,\n        0x571b242012fb7ae07fa9baac3df102e0,\n        0x08b0e27988598881d920a9e64f5615cd]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CBC that contains the following definitions: import the AES-256-CBC instantiation module qualified as AES256_CBC; a property named aes256_cbc_encrypt_vector; and a property named aes256_cbc_decrypt_vector. For aes256_cbc_encrypt_vector, define local bindings for a 256-bit key, a 128-bit IV, a plaintext sequence of four 128-bit blocks, and an expected ciphertext sequence of four 128-bit blocks, all as fixed hexadecimal literals from a standard AES-256-CBC known-answer test. The property must assert that calling AES256_CBC.encrypt with the key, IV, and plaintext yields the expected ciphertext (equality check). For aes256_cbc_decrypt_vector, reuse the same key and IV, define the same ciphertext and plaintext sequences, and assert that calling AES256_CBC.decrypt with the key, IV, and ciphertext yields the original plaintext (equality check). Use where-bound local constants in each property. Ensure type consistency: key has type [256], IV has type [128], plaintext and ciphertext each have type [4][128]. Do not introduce padding or partial blocks; the data are exactly four full blocks. Keep both properties as boolean conditions suitable for solver checking."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CBC as AES256_CBC\n\nproperty aes256_cbc_encrypt_vector = (AES256_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0xf58c4c04d6e5f1ba779eabfb5f7bfbd6,\n        0x9cfc4e967edb808d679f777bc6702c7d,\n        0x39f23369a9d9bacfa530e26304231461,\n        0xb2eb05e2c39be9fcda6c19078c6a9d1b]\n\nproperty aes256_cbc_decrypt_vector = (AES256_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0xf58c4c04d6e5f1ba779eabfb5f7bfbd6,\n        0x9cfc4e967edb808d679f777bc6702c7d,\n        0x39f23369a9d9bacfa530e26304231461,\n        0xb2eb05e2c39be9fcda6c19078c6a9d1b]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_KeyWrapPadded_AE.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_KeyWrapPadded_AE that contains the following definitions: (1) an import of Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap to use the AES-256 Key Wrap with padding operation; (2) a Boolean-valued function check_KWP_AE that takes a 256-bit key, an 8-bit plaintext byte, and a 128-bit expected ciphertext, and returns whether applying the imported key-wrap-with-padding function to the key and plaintext equals the expected ciphertext; (3) properties tcId1001 through tcId1100. For each property, introduce a where-clause that binds: a local constant testPassed set to True; a 256-bit key test vector; an 8-bit plaintext test vector; and a 128-bit ciphertext test vector. The property must assert that testPassed is equal to the result of check_KWP_AE applied to the bound key, plaintext, and ciphertext. Ensure each property is a closed Boolean suitable for solver checking, and that the function and properties use the exact names given above. Clearly specify the argument widths ([256], [8], [128]) and that check_KWP_AE returns a single Bit (boolean)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_KeyWrapPadded_AE where\n\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap\n\ncheck_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct\n\nproperty tcId1001 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x39FA276B26B762599AA1070192987D0CF8184DDB1C98EEA23F06FF81B63481E0\n    pt = 0x8D\n    ct = 0x35A739A8A322805B94DEB3CB1A56A008\n\nproperty tcId1002 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF80E0BDD0D1B3407F241522045574E3C80CA99D3A6854706047942EB694CDBF3\n    pt = 0xC5\n    ct = 0x9581CB7E06C38D57C5262A7BD4BD8840\n\nproperty tcId1003 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC93821958B2A3AC969FFCA59EF5623E609F38585A6C9A9ADE41D546578DE141D\n    pt = 0x1E\n    ct = 0xDD6DC03E825F2E77480F998902FA6BE8\n\nproperty tcId1004 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF6C4018216BC7EAB22D57893BE5E9E3A2A7189813E37D26BFD8A866BADE775F8\n    pt = 0xE3\n    ct = 0x56F07FA0F5512B159F5E70A50C442B0B\n\nproperty tcId1005 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDC426450A27CCAD9B7890661B13480D2225918AAC7C03829512492865763ABDC\n    pt = 0x3F\n    ct = 0x686DE8ABFFBEDF79AAFD4432ECD4CF50\n\nproperty tcId1006 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x44F2DE705C848A3448FF6FFCBD221C0DC2119351D384CE21D5AC2606FE21B6F8\n    pt = 0xDA\n    ct = 0xE4B9BC2CE14293EAF05955A42627269D\n\nproperty tcId1007 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC933E2E4EE7D519FA406AA70EAC833CCD50FBB044427B1D25624254A555EDC43\n    pt = 0x1E\n    ct = 0x901B3CE56E12F8C188039535EBA61996\n\nproperty tcId1008 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x6E0627242E7C51B204DB46A58D6A411B96514555CF8C21DD8B2DC37CDA95F9CD\n    pt = 0x15\n    ct = 0x2AD76F428813B950D099C10105A29FB5\n\nproperty tcId1009 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1FD3508E9533EC697E4B8F59FFFE4B98857919A4DEF918426D068F70F3B2948E\n    pt = 0x02\n    ct = 0x530967E906FD940C887A6AD9F37AC42D\n\nproperty tcId1010 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x85BFD16F7B562AD251329106A3D7A184C5C96CCE489B2DD797A084A72404376D\n    pt = 0x94\n    ct = 0xEFC758A879A703D39B7B85F7BB7B2D44\n\nproperty tcId1011 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDDD6FAB4C49DD7FF2985AE928BD5EA87CC70A31163074F1FB1BC02F7F969D418\n    pt = 0x86\n    ct = 0xBD96D9C865A87BE05A306AB3D6BBA3A5\n\nproperty tcId1012 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDA37F25B6EBE88C9DB9E03A5E126D5AE55F632B1686115C956228326A0DBC789\n    pt = 0xA9\n    ct = 0xAC58CFA83697E911CD09BEA23CA4CD45\n\nproperty tcId1013 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1BB566FE462A27901D86EEF8558F53E505E47D81A66F2918AADE08EA347201B3\n    pt = 0x1D\n    ct = 0x8A51E6B709CB04F59981F7FFDB783D0B\n\nproperty tcId1014 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x73B2AB98DDC2A3557AC51C1976D43F2997D4305D6C1D8DE38B393161DE44A1BA\n    pt = 0x54\n    ct = 0x281900A08220B5F74CF06D739F7C5DC6\n\nproperty tcId1015 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCACF12AE11477B1254437CA92D329F1C7EE6B2C022E4F12C3EAC649621AB0137\n    pt = 0xE2\n    ct = 0x6DCC8657EC2A2443DD056EF73DBBFB7B\n\nproperty tcId1016 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3E7517AE08DA6B2B027AC829D0D96FB0D2B27C611D217174FFF385EEA51ABC9F\n    pt = 0x7E\n    ct = 0x542A995D5BEB0FEF0CA3B56DB914E0DF\n\nproperty tcId1017 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x636062EAF492C67B4E98DC4653031942CE29FB1B81462A31FCA2A40DF760ED1F\n    pt = 0x9C\n    ct = 0x9F24ED46467485D4ED54D232E50E8885\n\nproperty tcId1018 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x86CF07CC35A7624129A9390B14EE6FA8B8D7A9F613050E7CE3E3AF3CAD54ABB3\n    pt = 0x75\n    ct = 0x76A00B69214577BAD18CCDC983C8BAFD\n\nproperty tcId1019 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC4C825E849AE1C195748979D8821711590403E3AC47984C526DF896D120E7396\n    pt = 0x9E\n    ct = 0x5808672A0F4EEDD81328D99819993EB7\n\nproperty tcId1020 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFF84BC98909D273B28F0AC9D0C44386533BFE6A0586294D57DF370FFECCDDB3F\n    pt = 0xC9\n    ct = 0xDA9785C2ADC2CE92EFF5E3523D469235\n\nproperty tcId1021 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x8670FB10B54781839B56C7A14C660412FE2E48F3655ACC55553B794D9FFA32B7\n    pt = 0xF0\n    ct = 0x8850EF6CB7396E775D4F330C6E01EDCE\n\nproperty tcId1022 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x211A909A1C1B0F56BEBBF3362DC2CD75AB14BB2CB4EB191557B5ABAC7EF9E4E4\n    pt = 0x19\n    ct = 0xC76400B498AEB0023E266AFF9EE30FE8\n\nproperty tcId1023 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xB77EBA3E4E1FD9D5989A233E66BFC9CBB8CF245C9DCF7C59AF1D5FDD4811D76A\n    pt = 0xC0\n    ct = 0xC8869A194252053D69CB3700B519B400\n\nproperty tcId1024 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x96A325D96DF23193F21C409B20B83B157E4BC00E7B872A96D57EA7791575B797\n    pt = 0x60\n    ct = 0x9C5C1DCBFE8CEA38DED462DC2268D090\n\nproperty tcId1025 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x67BA246D02CBBBEDDE0B24C8DD8EE9ECF80DC34ECF0A211B1967BC141265F099\n    pt = 0x00\n    ct = 0x38AE876F1E45933C75D8B57531B59075\n\nproperty tcId1026 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x81C3403F359326663B025C16865E245808C4848A54011F6B88385A1A64FBECBC\n    pt = 0xC2\n    ct = 0x8C0DEC2FD4B6AB0231EC56BD50852D84\n\nproperty tcId1027 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x428666365FFAE2B604A71E3EA61D1AB85CFCDEDEF5D40CFE8E53FDB96AC27630\n    pt = 0x1D\n    ct = 0x48D46E384AE3AA2BDCEC10399A82BE37\n\nproperty tcId1028 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x859857F302D7B4BECF1220B55857A1DF064355AB306E9E9C3FEC3DC86FAFCC3A\n    pt = 0x91\n    ct = 0x7E0CF4C530ED36B947CA4C5D7DE0097A\n\nproperty tcId1029 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFC304BE2EBA8E1CD41680F2228E150718D829821F99994AC44D59C7494BDB6A8\n    pt = 0xC2\n    ct = 0xF125384DEE677C7923697F5A3BFC6184\n\nproperty tcId1030 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5D124C781D08A9A1EF74B9BFC5B92C093F47B6C20E566B12ECBC361813688F01\n    pt = 0x3D\n    ct = 0x8435A5CB88740BADEC2C57FE0BBA0DA8\n\nproperty tcId1031 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xAA5AB62D3DF457E141F244ECB7A1B02B7C849535F6114EE43FE5474FA7934D3E\n    pt = 0x19\n    ct = 0xF3E526B2D27DCAE85E3B603219079B17\n\nproperty tcId1032 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B2B4903C7F4FEBFE9600D357C043E891BC2659AA21694810AD9DF8DE2C5D87B\n    pt = 0x7F\n    ct = 0x9AE5B26B28514B2E02866F655689D8A2\n\nproperty tcId1033 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B7572593C032234A0047A9D2A92E9F7323226FD9879B8F8BF73631C16560922\n    pt = 0x5E\n    ct = 0x2E94CB8DFFCDA2399BC422B24928A91A\n\nproperty tcId1034 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x68380612EB8E22DC776E8D05BE01B619D0C1CB99EBC7947C8444CB26FEAC0E91\n    pt = 0xBB\n    ct = 0xAA6ABD32EA59851AFE3AD836727E5DC6\n\nproperty tcId1035 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xED0580C7DAB265D63DCCFEB165778BA3ADCC9C92D807B0DA7D08F05A2D1E0EF1\n    pt = 0xAB\n    ct = 0xC3DC9EA6773BA6B254156BCA2D6CCDC4\n\nproperty tcId1036 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x512E2D54D84820280EFEC1286247D6A17DC5A23F33FC1C32D5A023D38EE43B8E\n    pt = 0xF5\n    ct = 0x4E50FAEF7FEDF00A97744D1E50180D29\n\nproperty tcId1037 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCDDD9A61EE554E27E75D9D2A6905763363ABFDA1A2E0D1351CFAC3B870E72AB7\n    pt = 0x9C\n    ct = 0x13865E5DA697B608016326560370FC34\n\nproperty tcId1038 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xBCDA299791DF47EFEFA436000A4234F9F1DDB2959F7F5CECD7D114DA1555DF39\n    pt = 0x23\n    ct = 0x957A898CF5CA014FA0BC445FA0411B8E\n\nproperty tcId1039 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x14AC4E2D21736EDCC6D423E3AF1E2BC4E8115A9C190AFD7C5A764CB7FDEFE222\n    pt = 0x27\n    ct = 0x47F8738AE025CB323AA904BB8FC94D5A\n\nproperty tcId1040 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD780739A8A8F203E593DFA988C4BEDDAD17EC65E32FF9420E8B7B094AD3504CE\n    pt = 0xA4\n    ct = 0x0ACA7980AA5D91E7CF8A7FF32ACFB820\n\nproperty tcId1041 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFE9E71CE3F0372783D47D1219919A9176DBBA7E1E7BB0E6BD94599DA51F616EA\n    pt = 0x18\n    ct = 0x4BEF98A1A912C5CCFB44398501393A5B\n\nproperty tcId1042 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD067989158B5C486D6CB2317DC4A1F174EDA232A5D0572313666B602F80FAA82\n    pt = 0x87\n    ct = 0x1622F42C6EB932C9C3BA6EE528F5EE2E\n\nproperty tcId1043 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF08EAD0CDBBCC69EF06549FAED6989E5177678A31CDE24081E962C06F80DFFF1\n    pt = 0xB6\n    ct = 0xA164FE1AAC233A7B292190106242BC35\n\nproperty tcId1044 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x6FFA0B069567D8B8CF189E1E651126E16432F4B1DF14D28C7930F167D90E71DC\n    pt = 0xBC\n    ct = 0x81AF399406890408830494067B975DC3\n\nproperty tcId1045 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF0D9A00431BFC37776632DCE8392FB668738B8E7E87B32FE6970AEDE141DBB12\n    pt = 0x15\n    ct = 0x21A2E83460738D67E274DE0231F5DB08\n\nproperty tcId1046 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x8758E274D03DE0037EB638671BF7A5762262CD81FA4710612F0F8C00DD544FD2\n    pt = 0x10\n    ct = 0xB58EF1C43EF4FB8D25C53D673C074A9F\n\nproperty tcId1047 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x611CB910E6F3554891709BE3269311CAEEA4167646770C93B1EB24150B08E7FF\n    pt = 0xAE\n    ct = 0xC4D38071B0325A7DBAE7B8C97E140567\n\nproperty tcId1048 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x595D643FEE1B9DA657E5E0DD89BEA95FBA9D60A9F569E5BD2263ECDA865B6397\n    pt = 0x8A\n    ct = 0x291C122B76FF48EB7A9B1A25C20FF3E9\n\nproperty tcId1049 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF66827A982352FB10D7BD294A6DA6661B9593E850D9AEE8C7E2C2F0662B66609\n    pt = 0x1A\n    ct = 0x8320E7CDE94090DDB0AFA279F71CF86C\n\nproperty tcId1050 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x927B27D5B50BA9D198E9EECD1317FD659A80F9E061A2703E797B61D420C7164D\n    pt = 0x62\n    ct = 0xEF84DE1F6C508958F7ADC6D11C606DB8\n\nproperty tcId1051 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF416A4C6552B4E2E2D5F88C6AF5494C4EA1D04BB22A377C0806611418475F1F8\n    pt = 0x10\n    ct = 0x562ADB01EA14439CE1D8A6FBA46515F4\n\nproperty tcId1052 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x42EE175CB7A7F28620500AE8856C7CDE3C4052FBA5ABF91C9E91E20857AF5066\n    pt = 0x29\n    ct = 0xB5465699DD3DC2969DCF8B1DA3C0DFCC\n\nproperty tcId1053 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD9C652FA5E6A16E51DC513B53AFBC7E6624B8C3E4E3C58CD223320228EEE5DFD\n    pt = 0x55\n    ct = 0x0AD61A07DB5EC915C16F1A320BF0EAED\n\nproperty tcId1054 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x070FDEE3C8E60C382E9EFB3E61AD9B84620F2513F25DE9A535C344774F14BBC0\n    pt = 0xA4\n    ct = 0x906B0FA922E825B9375863FCA511B446\n\nproperty tcId1055 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x965B12BA6F405A1C99A702AC08084090FD80854BF5C09D00D1CBF8020E1FC853\n    pt = 0xEE\n    ct = 0x338C2D6EF2A4F0215F32117A6999E2FE\n\nproperty tcId1056 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x16E8974B487171A030AB25FE03E5789772A2A91E4FBBEFA62A2C3957AC69DAC3\n    pt = 0x51\n    ct = 0xFE89DB7AB88A6A50DBC7B4BBFD7C7D19\n\nproperty tcId1057 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9A729225A773F82968D4E4A61F67F7FEFA1C1EB951506220D2B44FB4EF06C54A\n    pt = 0xFD\n    ct = 0xBC7ED8E326F929CD1CF2939519972DB5\n\nproperty tcId1058 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x41472533F605B84462AD4C8FD062FC9B24B9EE7EBA935D0ECA424D2AB503DEF8\n    pt = 0xF9\n    ct = 0x32746F33EC7A049B4A3C48BD0ED21CE8\n\nproperty tcId1059 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x80F14DD8F5F9EF689A6840363AD88F58DE0EDCDB74700BA33A7DD923FDCB5DAD\n    pt = 0x29\n    ct = 0xF34CACF3816972C90A4AF0E67E7AED85\n\nproperty tcId1060 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xBD62F4F0449F892825008928D877A7543FADFAD05D3877033FFBD343EB83E622\n    pt = 0xD7\n    ct = 0x54F7EF87C184A81009EBF9BF6688CD7C\n\nproperty tcId1061 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x44D2B78F5FD38A5F681DA45F2FD177AFC122B7E780BB516AF29D928F3A17DAF5\n    pt = 0xD2\n    ct = 0x286F752B981CE6847661E0DCDD4D5F49\n\nproperty tcId1062 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x19556188E0349531F56D4144DAD2E5E0F6FFD349E017EFD31A05DB09291ED515\n    pt = 0xEF\n    ct = 0xE6DFA16F00FA7241F84E614649045B40\n\nproperty tcId1063 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC2DF0F8EC128AC630349FA9E452A2A8A10B500E00B9524E146518780EE62B117\n    pt = 0x81\n    ct = 0xDF68CB42ED2761D74BEBCE73E590A4DF\n\nproperty tcId1064 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x4E88503C08AD7EF21832B200F39489D3C5457CDB45912DAA380A6DF414B125C8\n    pt = 0x2D\n    ct = 0x52D5A548C2E4D287DCAAFE03E016AD79\n\nproperty tcId1065 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xA45AFB02BF762298F315E033B04325127E9DC8F237261DDB114D384B44571929\n    pt = 0x42\n    ct = 0xCD487595DFE7F933FEF5B10587AC8981\n\nproperty tcId1066 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x7FB2623EBF05DBAEBD5122920E97DFFF06F57C838DA933538C97FAD59E25EB8A\n    pt = 0x77\n    ct = 0x8A5F782FBED1132D0636F53A51CDBF79\n\nproperty tcId1067 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x150F4FB634BAC25DE6992583F54DD734173E93AB43F63594832D9287778AD0EE\n    pt = 0x7A\n    ct = 0x799C8243EF5EF87891E005B506BF2F64\n\nproperty tcId1068 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B6CF52B74C43964097B6E38D37E01D673FB71F23C3329581F6409D8ED32A16E\n    pt = 0x4D\n    ct = 0xF293CE2D1F9C6725E1F9F107421AC396\n\nproperty tcId1069 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2644CCF9D7C419A437C954C8141CBB2D60F57DE10A5393554A14CCC72229E286\n    pt = 0xE0\n    ct = 0xDA510B1D9A10255380655980A3A73536\n\nproperty tcId1070 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5A2BF1A5098964EEC4D82F7E7C2D5723A5777F202E5CF729B506A5DC9775F1DE\n    pt = 0x11\n    ct = 0x19B164EFC41F5FFF402A1097CD89259C\n\nproperty tcId1071 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9B35B7F2AB8EEBA30101BC8D0BF94B09C8EA02114ED9912F7659967DC3C7D841\n    pt = 0x71\n    ct = 0xC788AB3CE96444554BBA805A1E3A8F91\n\nproperty tcId1072 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B7783AD07911FC6D685E60FCB1213EDFF5DCD7EAC1D73DA2685585AE4C39177\n    pt = 0x3E\n    ct = 0x0EA7AB3B26CDA9612A508EF9B41DB7C8\n\nproperty tcId1073 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFB56787EC73A1EED0C9061D023A305AC301E2455E349B2E573F2AFE326709ADD\n    pt = 0xC1\n    ct = 0x2C713F375FDD12469E753C68BAEAC6D4\n\nproperty tcId1074 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1AC45D1DB5E960DECD86AEA2507F1CD51EAC9BD3EA8B6093D4A795EFCA7187B0\n    pt = 0x73\n    ct = 0x24B65C239B23D8C8F44EC2721ED03B15\n\nproperty tcId1075 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDE8A1521277486D6FCDA3A24031DEE8647344F88A051A4DA7F452A7036DAA8C0\n    pt = 0x5E\n    ct = 0x708D55D92DB692A62CBA3CA4D009C8CE\n\nproperty tcId1076 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xA66E6DA21D52FC24733C303A121AD10626A5194884054CF8B73E7A71AA49380B\n    pt = 0xD3\n    ct = 0x7AD507B5FA5CD4A98C797A8DD824923F\n\nproperty tcId1077 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCC3710FD1C78A8B019AE0E8608E5C60F614D1F043196A3D87A67074A267B5542\n    pt = 0x02\n    ct = 0xF02A71952C7F74D6F509D0DA905B5E44\n\nproperty tcId1078 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x371EEFF5ACEC4E980CA59E9D91BEBF9B1B8013B3340BC45D624F0AA0943118DA\n    pt = 0x74\n    ct = 0x7BD179C985A426CD4FF9BFBEF858436E\n\nproperty tcId1079 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x54D9324535DAC6090439406626141312CB4A61ADC61189947D5572FBD326CB57\n    pt = 0x7F\n    ct = 0xFF0061FC09D685215C4B22BE822405FD\n\nproperty tcId1080 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3EA9325069ED93A96C331BDD6DD766EC64BBBA83A72C69ED75DF55043FB0BFD1\n    pt = 0x06\n    ct = 0x40A9C42012BA38211B800E6E313B6876\n\nproperty tcId1081 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2C0CD8480E0768FB9E33A9929F3991A0DE0B0AC1F35D0CB7E58757A9D28D49D4\n    pt = 0x06\n    ct = 0xCADAD5CFD536F7BA6897EF398483F38F\n\nproperty tcId1082 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2BB319F216DBBA31EB4BB3265FF85D13ABD8B12083DC0CD48C40372C946F70D5\n    pt = 0xE5\n    ct = 0x85427703FBC3BE25BE88765DC8791554\n\nproperty tcId1083 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD393149C58FDB23C4ABDF43EE03D603DEB1FD06CD625F821FF93B27376458C9E\n    pt = 0x1B\n    ct = 0x3D737A3A014ABDDA0BE2696C8097EE95\n\nproperty tcId1084 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x03353DEAB5D9CD40338E8ECC8D810DE4E29B6D34CF158F68DB5AE356A4225266\n    pt = 0x8D\n    ct = 0x9313D7D59E08024181C2146F9123A78F\n\nproperty tcId1085 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x0CFD3A3B0540E5B3F044EB60050FEAFC80BAC758DB99016F79F0F5BF80307779\n    pt = 0xFC\n    ct = 0x02EC669FB26BDCDCC398545D7BDBDEC7\n\nproperty tcId1086 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x4CBC12CEE939C4F915DAE23A4B6F30B8B45734686067B27BF592BCF929C7E75E\n    pt = 0x34\n    ct = 0x5965D7F3EE0A4940BADDDFFA05A30BF4\n\nproperty tcId1087 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1BAD340ABB934070C9B7662815BB7BAA652A056CCF246A375B6D959ADD5D7DEC\n    pt = 0x2A\n    ct = 0xEED916D3195F9C39406802285CA665D3\n\nproperty tcId1088 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xB0D6764B9B604A44D6A201A07E1F3CFCD0DA1A322DAA1251EFA19C12A8488D0E\n    pt = 0x8A\n    ct = 0xFE2A001CB35F00EAF85614EC594E2D9F\n\nproperty tcId1089 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x59BB9A295C7263842521D5F1EDD2DB92D9F09A607F758E2E3EF8CA6137616C93\n    pt = 0xB0\n    ct = 0x4AE1CF2A3BBD5BC2573D8A13212E445A\n\nproperty tcId1090 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x07E0C27A362DFB87EDE1B5E0A1790FA3FB09A99E12A6A71EB0A41B6356C9CC92\n    pt = 0xAC\n    ct = 0x70D749E0C9C77A0EDD98F8BCE3753733\n\nproperty tcId1091 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x50E530EF3EB1A1BAE45B8263BA7E30F6F5A7D2418F3611E30830C87D741647CD\n    pt = 0xFB\n    ct = 0x4FAA8357F2F3EF340A5E8B7AA74DD290\n\nproperty tcId1092 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xE1DE28540953AAF2AFB9EEF0DDBD08B5A1AAB73EECDD2F0E85F8915C94699E4A\n    pt = 0x17\n    ct = 0xC686DC8FE198F9D36374F5C56B99E3DF\n\nproperty tcId1093 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFBDCABF978959C69724C63165A17DB5F1FA7FC2871F9BDFC799391C908F78F6C\n    pt = 0xC8\n    ct = 0xB6B5D8288DAFE8F8584514B5193EEEFE\n\nproperty tcId1094 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x417887E598A05E102E6C651F6900C22412DEB49140585A650DECA9B1BA211B1E\n    pt = 0x72\n    ct = 0x5B0B9FAB5479528F87EB3C91225BB64D\n\nproperty tcId1095 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3BDBA3053CC76471EA0D78531BBA04A9584995BE194A348185698FE4D1338BBE\n    pt = 0xFA\n    ct = 0xF56924CE90ED7C0A79B8CAA4101D1DBC\n\nproperty tcId1096 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9DDFEA3DA8FF9F5401D5BDBBE520E4D47263E5B268BB15DC6FD62939FFA49377\n    pt = 0x58\n    ct = 0x01F0962438250AAEEDF8069D7CFD1F95\n\nproperty tcId1097 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x59DE802DC7805F487E4537941C71A24317B585BD58CC1FF9B5AC18FFA78E74A3\n    pt = 0x0E\n    ct = 0x2B7E6ACDA4967F644662A58CE8077917\n\nproperty tcId1098 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x35F2322E2999AAA3BEBA5E33A237E9D84DF0DA5BB732370AAEF97316F78DD413\n    pt = 0x1E\n    ct = 0x8A4DBD736974C2E73DD27C5E47955D94\n\nproperty tcId1099 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x45D780CFD96B54CF1AB425FAA701645B0FC5F84AA385B1372771BD7AD6109F0F\n    pt = 0xFC\n    ct = 0xA2E47585D0D8F81BA155324417EC2571\n\nproperty tcId1100 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDF9F0529DBBABA0D2A925AD2E0B81E01A0386DFC2033D3D6D446845957C02A15\n    pt = 0x0A\n    ct = 0xF6B6398CA55ACE0222A9391FD81CD276\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CBC that contains: (1) an import of the AES-128 CBC instantiation module, aliased as AES128_CBC; (2) a property aes128_cbc_encrypt_vector that asserts the equality between the result of AES128_CBC::encrypt and an expected ciphertext sequence, using a fixed 128-bit key, a fixed 128-bit IV, and a sequence of four 128-bit plaintext blocks; (3) a property aes128_cbc_decrypt_vector that asserts the equality between the result of AES128_CBC::decrypt and an expected plaintext sequence, using the same key and IV and a sequence of four 128-bit ciphertext blocks. In each property, bind the key, IV, plaintext, and ciphertext as local constants in a where clause. Use 128-bit hexadecimal literals for the key and IV, and four-element sequences of 128-bit hexadecimal literals for plaintext and ciphertext. Ensure the types are: key: [128], iv: [128], plaintext: [4][128], ciphertext: [4][128]. Both properties must compare the function outputs to the corresponding expected sequences with equality so they can be checked by a solver."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CBC as AES128_CBC\n\nproperty aes128_cbc_encrypt_vector = (AES128_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x7649abac8119b246cee98e9b12e9197d,\n        0x5086cb9b507219ee95db113a917678b2,\n        0x73bed6b8e3c1743b7116e69e22229516,\n        0x3ff1caa1681fac09120eca307586e1a7]\n\nproperty aes128_cbc_decrypt_vector = (AES128_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0x7649abac8119b246cee98e9b12e9197d,\n        0x5086cb9b507219ee95db113a917678b2,\n        0x73bed6b8e3c1743b7116e69e22229516,\n        0x3ff1caa1681fac09120eca307586e1a7]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_KeyWrapPadded_AD.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_KeyWrapPadded_AD that imports the AES\u2011256 key\u2011wrap instantiation exposing the padded key\u2011wrap unwrapping operation. Include the following definitions: (1) A helper function check_KWP_AD that takes a 256\u2011bit AES key, an 8\u2011bit expected plaintext octet, and a 128\u2011bit wrapped ciphertext, invokes the unwrapping operation on the key and ciphertext, and returns a boolean: if the result is an optional value with a plaintext, return whether it equals the expected plaintext; if the unwrapping indicates failure, return False. Provide an explicit type signature for this function matching these widths. Use pattern matching on the optional result to distinguish success from failure. (2) A suite of properties named tcId3401 through tcId3500. Each property must introduce local bindings for: testPassed (a boolean), key (256\u2011bit), pt (8\u2011bit), and ct (128\u2011bit), set to the given hexadecimal literals for that test case, and assert that testPassed equals the result of check_KWP_AD applied to those bindings. Ensure the set includes both positive and negative cases exactly as specified by their testPassed value. Do not compute or derive values; use the provided constants as fixed test vectors. Use Cryptol\u2019s property keyword for each test and ensure all types are concrete bitvector widths as stated."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_KeyWrapPadded_AD where\n\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap\n\ncheck_KWP_AD key pt ct = case KWP_AD key ct of\n    Some pt' -> pt == pt'\n    None -> False\n\nproperty tcId3401 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1C8AB00037582D4E850D92E4244B6229D1FA54D6A0B1D1B71D43C0E45C544A18\n    pt = 0x3E\n    ct = 0x4358AA665202E40D725B01FEB065AABF\n\nproperty tcId3402 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA2423B2160857B73A2ED23C995F8374B7DFB2BA458B781131CF7DC4A5B370669\n    pt = 0x44\n    ct = 0x581BA83958B7528436CF9EA163E4873F\n\nproperty tcId3403 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x084D092899BC5F76288CFD7C45C336380BD2D768C98C5144B20D5612CA9CF598\n    pt = 0x59\n    ct = 0xC1B83872E7B0FC48156A06154219A608\n\nproperty tcId3404 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x518594C8D42412C9EDFB1E17E821B37DA0A020CAF4620FF2298AF4254EA0CFB3\n    pt = 0xB8\n    ct = 0x74C938C320B03451ED58DE73BFCAEE25\n\nproperty tcId3405 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x7F45132EE8CD57D9EADB90F15506D716311F2A226CB38D545F5BA4A76E065C90\n    pt = 0xAF\n    ct = 0x43AD1FAC8D9A4878414BC5D224856FC2\n\nproperty tcId3406 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x37839C73459186707F2C53440AA3E7A294A52481C6A8E72BF8FF44A61DC3C94A\n    pt = 0x3B\n    ct = 0x670DDA784A6F7B8629CC487125D83D82\n\nproperty tcId3407 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x699A20B3FED880092AC54A072D0F1944E5AC618E89BF6D82D85B8149409E0A69\n    pt = 0xC7\n    ct = 0xDA945A1E4ADD229EA2628BD2CBF648C5\n\nproperty tcId3408 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF39BBB0C6D6A48FFCD19A8E4FF8EC4D18DB342984D56204A72CC79EA4D331527\n    pt = 0x13\n    ct = 0x731375F0AAAE126D698A3A35C1B59BB4\n\nproperty tcId3409 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x2CC17C155EAED98EE7C5C988A4652BBC1E548D83E355EF2B9CAAB553E33248D1\n    pt = 0xE8\n    ct = 0x9ACE37E97BF83606F87F2C37F2DD0495\n\nproperty tcId3410 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x6EC1F03FE2E913911497B56C997AA18573FADAF5D3D40B5C3AE20C122D57CA26\n    pt = 0x0F\n    ct = 0x9EA3A713894A9A60EC886F994F6E6964\n\nproperty tcId3411 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x222373119D81095C1EA6BC266B7BAC7CC5338B183491E464517F6A1CEE323D72\n    pt = 0x24\n    ct = 0xC4684B34339464E99D38883F4E218D43\n\nproperty tcId3412 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x0E16E4ED5AE9010E977FC718B0A196D05C4EC8CC03881E9498798221CEEF4F60\n    pt = 0x59\n    ct = 0x45E26A81F2A3F3B36F6A1DFD5794339E\n\nproperty tcId3413 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF7C0B2E09007A87A2C6C02F547AE13D315D9F40E8432E2883EBAAD360AE58154\n    pt = 0x28\n    ct = 0xC6EADFAE6689D612BD7720A5FFDF6917\n\nproperty tcId3414 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1E094BFD3FD9FA39528B0A041943F26A146E1B6FFA9B89DBB3F3629E248786B3\n    pt = 0xD9\n    ct = 0x5900AC3014005CD4CB5B58D464D77851\n\nproperty tcId3415 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x2D72DDE845897E8DD914977D23B9C53A3C682F5322923F609786C0DEC4B9B391\n    pt = 0xF7\n    ct = 0x6F26295442B138B9B8559BDF24559292\n\nproperty tcId3416 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD4E74B1FB2D1B8A3A96D69484A3C14D6DAADCAAE26CF0D8C69FE1FF48FFCE55B\n    pt = 0x50\n    ct = 0x8E584B2DE61B3A7408E9CA039A5A2D3F\n\nproperty tcId3417 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8D2E8DC1019C058E0120F7BD454FEB9D2A0CF49C476215D9E1B36EBE31AA8E60\n    pt = 0xF6\n    ct = 0x89EE6AD335AB813F688EA34856C6CC62\n\nproperty tcId3418 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9EF5DA6F8AFEE4EC25A39C0BF3B4661CE1E60F4A08562803F9DAF43C1F5D901C\n    pt = 0x9D\n    ct = 0xF0B50CF34D7E9846BF0C63BC22C132C9\n\nproperty tcId3419 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x163668F7B7DEF32970EB681A9D9CBA20DD3612E48272C7F4ABB2BF32A6F07EC2\n    pt = 0x67\n    ct = 0x1CD75C122ECFBE1519FCC8266FD5BFBA\n\nproperty tcId3420 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8AAC75606AE5DD234EA1D037B220F89AE202BD465CC96CDC629D3AAF663D1811\n    pt = 0xFA\n    ct = 0x62845E954748CE3D22BC3DD347FCFF34\n\nproperty tcId3421 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xE46BBE8227B15C9F7EBC941D324D61A6D4539EE8557989F5D2B05F6EC9247238\n    pt = 0xBE\n    ct = 0xB26924971CA3A0593AD2D41330728677\n\nproperty tcId3422 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD541DD6C55C182DAE396180557E1527405E64C76072491162AEF584C3A723B8E\n    pt = 0x93\n    ct = 0x0ECF1EB9E9FC1A1B1F4061A2C6D8CB5E\n\nproperty tcId3423 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x448042C7E69DE6CD177324D07AA2B074F4914CCADF38E9BA241B847BFBE6A048\n    pt = 0xF8\n    ct = 0x5B16E3D2E4EB040700929EB1F3293826\n\nproperty tcId3424 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xE2FF9378361B637A9C7AB7991232E5C4E450F3F1884B99B32B35F3E483C63F02\n    pt = 0xC1\n    ct = 0x9694370FC567B3CCA1BF96BBC77F2924\n\nproperty tcId3425 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x71F1B8D033B2763D24C824BBC5C7B90F7465312EE68499AEB13936C6820D2DB8\n    pt = 0x41\n    ct = 0xEB1742979FF0D05DDA7A9AA4BC44A3DC\n\nproperty tcId3426 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x5B5D5403DC5F79CD612CE5BE434CDCB0CEF22A431BFFA8DFD03A40496867F36F\n    pt = 0x2A\n    ct = 0xEEF7F7FBA12F09C0E000D7DF78C3B7A7\n\nproperty tcId3427 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x4B6860891760551B1796F7EA2867B5F72CD55158751CECCDD07466B358E5DC2C\n    pt = 0x37\n    ct = 0xFC4728851CB09569B9C09F0DD974FC46\n\nproperty tcId3428 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8CC592A0827016D33FAC7046043CBA05F0F6D52360A131B68BB5CF3473D493E2\n    pt = 0xE9\n    ct = 0x6C4DA849D0312D2C1969F763FB0717EE\n\nproperty tcId3429 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA822410F60C3155AA4612A0A3D69FB6ABAE9CCCE764C45F0715167D4A29F92CC\n    pt = 0x60\n    ct = 0xFD4C6C336BF8189A6578C5D18755332D\n\nproperty tcId3430 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x4887BDA1567FA98C9E6C54A4C40ED9910888F0BB2F3092A990DD15A9FAF514E4\n    pt = 0xA1\n    ct = 0x6E8E313899901A660F45BE923325B3A0\n\nproperty tcId3431 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA34A8ACD5DE1D09B06C68A4BA6B26AD8849A96D097F7234CD87D0B22A77F64A1\n    pt = 0xF0\n    ct = 0x51A1D5CBBE044436F8E30F5EB9760A99\n\nproperty tcId3432 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA91FB46F7AE95553194F72BDE2DEC9C75CBE6F5D5CDA19CAE8DFEF10D2091878\n    pt = 0x49\n    ct = 0xAD8B08BC99A15AD1F61A534E6A6FD912\n\nproperty tcId3433 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBD31DE22B62709C3ADAE6A22C110AF041692A2EFF5AFD94D6F084A5AF7A10BA1\n    pt = 0x12\n    ct = 0xEA18D84DDEACDBFE6308356BD337389E\n\nproperty tcId3434 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xAAA495706CD217702F6589F3A7DCF77796EB9AD9301DACB70679353895821116\n    pt = 0x98\n    ct = 0x570F464452070AB993FDBA098413FA2E\n\nproperty tcId3435 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA6D1836D8FC15DC6655A6AF3C9908D1A458115DE813874DA2A31BAF535F4B898\n    pt = 0xC4\n    ct = 0x52BDFE3157F7E5320FA33902FFE86D9C\n\nproperty tcId3436 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9A372C3FE4AA3D244D7A31F26BE0DC94321AE6A9D399A3024DF1D2FAE01F5D5A\n    pt = 0xA3\n    ct = 0x74785BCEB51BB5BBBF237D204DF5DC3D\n\nproperty tcId3437 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x18EDF67DCED65DB1106F9E95F6E9CA0BCCDDB9C1B0704800E79288B4348D5ED8\n    pt = 0x97\n    ct = 0x53A16352DC6466B129B98EB20E871CB2\n\nproperty tcId3438 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xCA6909990051E5A00B321DB36E9EDC37C21517D05412C27308FA6230B194F3D6\n    pt = 0x8C\n    ct = 0xFA3388CC18FE4DB12B286D78A88F43CE\n\nproperty tcId3439 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x53D9C10A1F2A520C799E17CA84A9F37B7E41C8A8366A0999E6C640B9084F8D89\n    pt = 0xA7\n    ct = 0xCD7DA687F90A8E5B5A8D752383E2A921\n\nproperty tcId3440 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x40DA3BF159117B28AF81C41329BEA2446B47BBA5AA3CFED9C9B6D0FCAC447A26\n    pt = 0xBB\n    ct = 0xB3EB65346F8509E074B4340B225748AF\n\nproperty tcId3441 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xCFD6EACDFE41A0716399AAD812A5904F43E46E94C8F33551244107CBD4454630\n    pt = 0x86\n    ct = 0xEF426FD61C094CB99E553FA242B35BC5\n\nproperty tcId3442 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFEEACB41470DF0A95D4D17413575ECBE4473501166E2B253AC69B769D1DE6EE4\n    pt = 0xD5\n    ct = 0x3B6CE49140A31C29E2B57082556D4655\n\nproperty tcId3443 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC37E571FA0B30A4C320000E46DE47D739D71E958E6D9B5BF165891FD76A2EB69\n    pt = 0x7F\n    ct = 0xCA0BD69463B6FE257339A6F352C383B7\n\nproperty tcId3444 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0xBF4D98E63641C3B0C6C87F94FFADD24E9447DAE3C8179057B992F3E87ABB9371\n    pt = 0x77\n    ct = 0x8C309F22B1A69A82FC959024D9A41055\n\nproperty tcId3445 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xB340E2147C24AA9245D32B44D81932486162078E04E8D604C3BEC77E80D00587\n    pt = 0x9F\n    ct = 0x08E763DE0E9BDB77652BE9F239E76C3A\n\nproperty tcId3446 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x64CC83AE40375F36DF9EFA92623952D9B921C193A303BA44EAF249173E75346A\n    pt = 0x2B\n    ct = 0x96249FF04AE658C774BB76543946F1A7\n\nproperty tcId3447 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xDBB7B9A24F84518CDF7BE4204966A4A82C14F1DF9D3EED53B85BAF4110D2E5A7\n    pt = 0x00\n    ct = 0xBED6EBF099BF397B9CEEE98862B02A82\n\nproperty tcId3448 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x7A07B0AA1E991FC058CF99123C3797A5088331724452A8E6C866456B88700E4E\n    pt = 0xAA\n    ct = 0x0D8879321C745BC971154AE83455FEBF\n\nproperty tcId3449 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x7F9D0A3C5A5778247C91729D9067A522DCBC440B40EABF50E2501C55AD2924F8\n    pt = 0x72\n    ct = 0x22FD8008FA349050267F2C690218E766\n\nproperty tcId3450 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x5E804B2481BC5FBE520F8039375C018037E3BBAECB2249700CCA6A7BD7AA5717\n    pt = 0x2C\n    ct = 0xA75D5317E32EC6AE64F52BDEDF66DF44\n\nproperty tcId3451 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x5C7BA7305D3B4F81FEC1C53743F8C303CB060E9F8CCE92F33653485C1AEF6DB6\n    pt = 0xD2\n    ct = 0x0BEDF4F707D2D7B9703934FDAAD3FEFD\n\nproperty tcId3452 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFB590D85CC2E6666135A6317F8464F3BE2657532F9CD34823C8F9CDD22547223\n    pt = 0xAB\n    ct = 0xB0CBDD6BF81C0518EFAC69E74A5BAEF3\n\nproperty tcId3453 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9FEDC13CB212B80795956FDE94F420032F24C8EAEAD55A5293316FADFCC633C5\n    pt = 0x77\n    ct = 0x7DD4C22110BFE0530FC441F53518F9D1\n\nproperty tcId3454 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x95AC358D0BB126E90D6F604B30129A2B7D830F479C759F3D53CF4C6F998D2117\n    pt = 0x2E\n    ct = 0xCC42D7BD7EC583B5CA43C0BB3B449144\n\nproperty tcId3455 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF7D14A80AA1CB08AEA6CF77961555983FD09F50FE37E3E99F9B521AB0742840F\n    pt = 0x0A\n    ct = 0xF5A1CC956791996B6D0273D8E206E59D\n\nproperty tcId3456 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBDD2F02BD33BE2B9B035B0D7CC3A284979AF20C8DD4FE8EE60DCEFDEF4381813\n    pt = 0xEE\n    ct = 0xECF28482AA1214D6880CB5A909D2C9BF\n\nproperty tcId3457 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xAE2F98FD07E2AAB3E0F790AA523C8B36C4063C22A60AE5FC2D2B54C8D46DF7EF\n    pt = 0xF2\n    ct = 0x4677BCCC99567C44FC8C7326AD57F4F9\n\nproperty tcId3458 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x3530B064609EA0F443877A7070CFFF076741C8374FA72268349450173167509F\n    pt = 0x0E\n    ct = 0xCF30EA838A02E16758F641463221386B\n\nproperty tcId3459 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xDFF4C1198259942F942B1F3525E34D091AFE20A84948FFD6C5ABF1887C2E7324\n    pt = 0x84\n    ct = 0xB73B2D548186990CF25BBC4133344B6E\n\nproperty tcId3460 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x4D2A4B5B3C0F1D90D51B48E72926D1FC584FCDDDCE5971B522E96D9CB10F88EA\n    pt = 0xA6\n    ct = 0x64A8CB69731FDD89376C06309DF26460\n\nproperty tcId3461 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBB3670D9C9E461428A80595F716E091B9F5DBF92228ABB1CD0DFB8596B2F69DA\n    pt = 0x9A\n    ct = 0xC552F589E5D11EFCA42051369F008785\n\nproperty tcId3462 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC4633D8B4A999ED5A664EA02DBC047ABDE3041905A0D06726D7D5C2C2651B3AA\n    pt = 0x36\n    ct = 0x0425D5CD3FE9666B0CCE3C98E280C205\n\nproperty tcId3463 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xEDDD75B989E10681C4AA0D8C6418EB981B69C894FD804D06DDE643D7F53582EB\n    pt = 0xC3\n    ct = 0x3A205767FC5EF65D8CB70E8725B836EA\n\nproperty tcId3464 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x374D48822E30895944C18518E02156238707664276D5A599BF2C390E5C840D91\n    pt = 0xE2\n    ct = 0x26C2CD7AF348C457B5D816182803EA92\n\nproperty tcId3465 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x2795AF727A53461AC2B969CE61708DEEB395DCE6FF17923AEFD57E6E0D4BF308\n    pt = 0x47\n    ct = 0x25F38BC30E500B77ABF0D5B6CB038AEB\n\nproperty tcId3466 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9689C4C49E152D4A554A69BB926A945AC737C6D191D1FA3EF65331D501689383\n    pt = 0x5A\n    ct = 0xA47247E3631B1648EF30CDA790B98B96\n\nproperty tcId3467 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1D3C20DB2B0DE8AB0F9597E1FD3448B80F571EFF3F327F6095614AAA9CAC9811\n    pt = 0xFE\n    ct = 0xF27A4B12E93D2DEB7697C85DA15B92E2\n\nproperty tcId3468 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x9F3AB283C68BC9F03EB9743F816683595FC3C8D71E738422240F473399768437\n    pt = 0x3A\n    ct = 0xC5E6F5DC654A03FE5577FBA06A22DAB7\n\nproperty tcId3469 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x74A9D44D89694D93A1B61BDD02A81E7966118603BDED187D6E1BC4B06894744A\n    pt = 0x66\n    ct = 0xCEEDBDB7D9FD68D8A77DDD7F1C77F8C1\n\nproperty tcId3470 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC3C6ECBA08443278A12A21A390802A3081BFFC3BEC67600F52FF7CA367885A98\n    pt = 0x65\n    ct = 0x2F266F5CE092FFC3F36F8614FDC20C83\n\nproperty tcId3471 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFA610A36F2ADBBE68D460C13ECEABF708F56796EA820915B63D4F3BE2FD984EE\n    pt = 0x8A\n    ct = 0x85469A8A8A8957547CEFD17E5ECFC85D\n\nproperty tcId3472 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD6611F782D10A57647974D5C656B7F7506E37535416326B219AF81BC4A8743BD\n    pt = 0x58\n    ct = 0xE64D8579FE6BB20D0AFE72488E1F3CD7\n\nproperty tcId3473 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x34FCB48486EF3B0ED9EC197F55EC38F291CC68B1F0F68DABEBBB2787E8756303\n    pt = 0xC4\n    ct = 0x936AFF79592C2759AF94E5B48B6C130C\n\nproperty tcId3474 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8CFF7404B9BE4A6E3122654AB28EB3C1A773BC4887192D02C6BB5B50FC33435C\n    pt = 0x90\n    ct = 0x799292C2391C29826E6FE4A48289A37F\n\nproperty tcId3475 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xB6FF2FBAE349BC523847288225C94A3B4B1FCD53947524929BE5198045F81F03\n    pt = 0x4C\n    ct = 0x93C4EBC6F811C7E5025BFB48439C002D\n\nproperty tcId3476 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x730721960D62212552AC8CA2F135A07E884DD33209FD5397EC4CC162D8547BDE\n    pt = 0x98\n    ct = 0x46E634181EFE6254399D78F25549D1D9\n\nproperty tcId3477 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFF2F2B2DC1C3ABFB36C5C2A67EB8FF4E9B2746D43FBE675AD19D15FA782F419C\n    pt = 0x92\n    ct = 0xEB7FC5493BB24DEE35746090C5337BC3\n\nproperty tcId3478 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x575A096AC3B257827DEE39BE44DB62C0B8C8993A0B058AA268CB9401365EE6CA\n    pt = 0x19\n    ct = 0xA36764DF638074D2DB73BA3C73311152\n\nproperty tcId3479 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF61E5A48BFC7142E210405A0063FD24005549DFC3D0CC426C9707D0E3F62EAB4\n    pt = 0x9A\n    ct = 0xEB6575503055566BFC4694FE71A7821F\n\nproperty tcId3480 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBD3D9ECC1F178756F685C94D82E322860C0080471948B1B3B7FFC7A4B0D32D8A\n    pt = 0xCE\n    ct = 0x7D98C641A46D8701F468347EAE06B222\n\nproperty tcId3481 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x44934AB4E3104CFD6BBF02FE2FBEFA40301DA33CD1383728A93D5C772CAAB2D0\n    pt = 0x67\n    ct = 0xC1A236A91FCEB0D4B673934F650B8164\n\nproperty tcId3482 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0xE0695B4D76C38ADF1699088111D2C119B8B3EADAD9D4A62CE6FEAC789BD99048\n    pt = 0x47\n    ct = 0x6F5B8A798E1C44DA653C50AF8B8E96E5\n\nproperty tcId3483 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xE37B904A857C891114209A80CDBAA6B9C372EACB9065D95FC4CE2593E81D6F14\n    pt = 0x4A\n    ct = 0x62A104566D84A2A6F0BD3759EB95B079\n\nproperty tcId3484 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x72A2CA6161F22236DDB39B345F72656ACE5FD1745F6185C839C51509444AE9B3\n    pt = 0x82\n    ct = 0x8EA924155A8F514C73C62250BD742EF4\n\nproperty tcId3485 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1F2801EE032D01D052CDE826C494EA5A5C5CAB39DC871E9B57F8E040D3982E2F\n    pt = 0x16\n    ct = 0xA238DCE4AF87DBB8D4244AEDB9A42CA1\n\nproperty tcId3486 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x70638F85B9B31FAC449DF6AA19FB451960B5EE5CEC6FF3C473AEF8C71615DF65\n    pt = 0x8A\n    ct = 0x21E951E1DEC5BC71F2FA4B0AA90C0ED0\n\nproperty tcId3487 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF64D02392D650E0865F0C18B62772F1C890798E22A1871754ACAE6176583967E\n    pt = 0x05\n    ct = 0x903545EF6A52EC670DD793F78A50B23A\n\nproperty tcId3488 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x629F665A6786B5BC6A604B9306FC7F9B9390B28DA404C1082939DB657D16E280\n    pt = 0x40\n    ct = 0x10067350D2DC09942720CEF27CB6EB9D\n\nproperty tcId3489 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x43C453F9A65CBCF3BCA65BDFC94EFB6DF647391E821ACFBB62DE786890FB8649\n    pt = 0x56\n    ct = 0x9228F1AFED0E44378E1CA3B60005DCC4\n\nproperty tcId3490 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC77DEADC06B1F73C13AADC4EB8E5571EA6BFE3F89600C1FB0EB005A4F96ADB85\n    pt = 0x54\n    ct = 0xEE488F48CC2248482856D2056385A722\n\nproperty tcId3491 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x41FF08CAFC5580110B07360491752DC4654A6CFA0023FF9B423370E48BA881EE\n    pt = 0x3F\n    ct = 0x149D9466A536B0E1C4CB5616D3626845\n\nproperty tcId3492 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x6563A6A6707CCB4CA7CA9AD828F0F94860B932502EA9E3E86E561AB219BF3EBE\n    pt = 0x36\n    ct = 0x9F934514BDCC514DDCBC77510CE6F05E\n\nproperty tcId3493 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x56D362245CA9C93774451E5193D3E54E928ABAD5F1DD0C34C1B6B19C8346458A\n    pt = 0xC2\n    ct = 0x31ACBD193BE3BDF7E4D398BA4F5CCF81\n\nproperty tcId3494 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x01BEA442DFCAE33FE752FCD7F029C0E48A2FEC00CD124FB99A777BA9D43EFADF\n    pt = 0xCA\n    ct = 0xF1F01B25DB56D08FF63B95F9A8320873\n\nproperty tcId3495 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x91B234088667FAD2E005E9791DB57B7E2E65D09442C4396A284ADBD18D58294A\n    pt = 0x51\n    ct = 0xF6501E880ACC1AD562C1589BA3DAE3B2\n\nproperty tcId3496 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD0846D465C055E3CCD45343B6BD9DC549DA718FE62842AA7C0E3D915DE176B14\n    pt = 0x3D\n    ct = 0x5F836DC239426A8AE06D5A40FA8FFE5A\n\nproperty tcId3497 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA9803E483158D203A22C48F9BABCBA8B4E25328A11BA1D310E57F0D7226EC355\n    pt = 0xD9\n    ct = 0x6AACCBB9DBD4B319E50898EB21BA7470\n\nproperty tcId3498 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x063726D0EB03547D726E9D10ACCCB3CFF01006209D7FB39C05211EC88EE37C7F\n    pt = 0x16\n    ct = 0x341CEB90D234A324941D12B2024EBC1E\n\nproperty tcId3499 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x245F675642C52A62E1AD864EDA33FA65006C8BCD3D360D5A3E54D3F0982E2A01\n    pt = 0x42\n    ct = 0x5424035C2260598A200029E0F7533CA4\n\nproperty tcId3500 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x63FEA6C364B3A9C7813472E289513ADC0631493A7C9014FFB395560F7C767E11\n    pt = 0x57\n    ct = 0x92AA71DCDE68A0DA1CDFC86DABF331AA\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_XTS.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_XTS that instantiates the generic XTS block-cipher mode using the AES-256 block cipher and re-exports the specialized API. The module must contain: (1) type aliases describing the specialization: Block = 128-bit block, Tweak = 128-bit tweak\/IV, and Key as two independent 256-bit AES keys (expressed either as a tuple of two 256-bit values or an equivalent 512-bit packed value); (2) the AES-256-based XTS encryption and decryption functions for a single block given Key, Tweak, and block index; (3) the AES-256-based XTS encryption and decryption functions for a sequence of 128-bit blocks (a sector) given Key and Tweak, preserving ordering and using the per-block tweak schedule; (4) any helper to construct\/deconstruct the combined key into its two 256-bit subkeys; and (5) re-exported constants or constraints inherited from the generic XTS mode (e.g., block size equals 128). State all type signatures explicitly, including size polymorphism only where permitted by XTS (e.g., polymorphic sector length) and fixing the block size to 128 and each subkey to 256. Ensure constraints capture that data is a sequence of whole 128-bit blocks; if partial-block handling is supported by the underlying XTS implementation, include the function that performs ciphertext stealing for a final partial block, otherwise state the full-block precondition. Do not redefine AES-256 or XTS; instead reference and instantiate the generic XTS mode with the AES-256 implementation so that all operations are specialized to these sizes and are made available from this module."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_XTS =\n    Primitive::Symmetric::Cipher::Block::Modes::XTS {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR that instantiates the generic CTR block-cipher mode with the AES-256 block cipher implementation. The module must contain: - Type synonyms\/aliases for the 256-bit key, the 128-bit block, and the 128-bit nonce\/counter. - A keystream generator that, given a 256-bit key and a 128-bit nonce\/counter start value, produces a stream of 128-bit blocks by encrypting successive counter values (incrementing modulo 2^128 with a clearly stated endianness) using the AES-256 block encryption function supplied by the existing AES-256 instantiation. - Stream combine\/encrypt\/decrypt functions that XOR the keystream with a message of polymorphic length; encryption and decryption must be the same operation. - Precise Cryptol type signatures that fix bit widths, include necessary fin constraints, and remain polymorphic over message length. - Re-exports (or equivalent wrappers) of the CTR-mode API specialized to AES-256 so users can use this module as a drop-in for CTR over AES-256. - Verification predicates that check: (1) for all keys, nonces, and messages, decrypt(encrypt(msg, key, nonce), key, nonce) equals msg; (2) keystreams produced under the same key for distinct nonces are distinct (at least for the first block); (3) combining with an all-zero message yields the keystream. Do not implement AES yourself; rely on the provided AES-256 block cipher. Clearly document counter semantics and any assumptions about nonce uniqueness. Ensure no extraneous exports beyond the CTR-over-AES-256 specialization."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR =\n    Primitive::Symmetric::Cipher::Block::Modes::CTR {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES192_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that is exactly the specialization of a generic CFB block-cipher mode module instantiated with a 192-bit-key AES block-cipher implementation module. The module must contain and re-export the following definitions from the instantiated mode without alteration: (1) type synonyms for Key (192 bits), Block (128 bits), and IV (128 bits, equal to Block); (2) function signatures for CFB encryption and decryption that each take a Key, an IV, and a sequence of data elements, and return a sequence of the same length; (3) any mode-specific helper definitions exported by the generic module (such as block\/segment sizes and stream update helpers). Clearly state all type parameters and constraints as required by the generic mode (for example, lengths parameterized by n and any divisibility constraints between segment and block sizes). Do not add new logic or change behavior; this module must solely expose the instantiated CFB interface specialized to the AES block cipher with a 192-bit key and 128-bit block. Provide concise descriptions for each exported definition\u2019s purpose."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB =\n    Primitive::Symmetric::Cipher::Block::Modes::CFB {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_XTS.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_XTS that instantiates the generic XTS block-cipher mode using the AES-128 block-cipher implementation. Re-export the XTS interface specialized to 128-bit blocks, including: (1) type synonyms for Block = 128-bit block, Tweak = 128-bit value, and Key = pair of independent AES-128 keys; (2) functions for single-block encrypt\/decrypt with a given tweak; (3) sector-oriented encrypt\/decrypt over sequences of 128-bit blocks given a sector identifier; (4) tweak derivation from a sector identifier and tweak update (GF(2^128) multiply-by-x). Provide explicit Cryptol type signatures for all exported values, ensuring inputs\/outputs use 128-bit blocks and the key pair type. State preconditions such as equal plaintext\/ciphertext lengths, block alignment to 128 bits, and non-empty key pair. The module should contain no new algorithmic code beyond the instantiation and should simply expose the specialized XTS API for AES-128."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_XTS =\n    Primitive::Symmetric::Cipher::Block::Modes::XTS {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CTR that applies the generic CTR block-cipher mode to the AES-128 block cipher instantiation. Re-export the CTR-mode API specialized to AES-128. Specify: (1) type aliases for the 128-bit block, the AES-128 key, the IV\/nonce\/counter (same width as the block), and the stream element type (bytes or blocks) used for I\/O; (2) constraints that the block and counter sizes are 128 bits and that the counter space wraps modulo 2^128; (3) function signatures for CTR encryption and decryption that take a key, an initial counter\/nonce, and a sequence of plaintext or ciphertext elements, returning the transformed sequence; (4) a keystream generator that encrypts successive counter blocks starting from the given IV, and a counter-increment function with carry and wraparound; (5) documentation that encryption and decryption are the same transformation via XOR with the keystream and that both delegate block encryption to the AES-128 primitive; (6) any necessary conversions between byte streams and 128-bit blocks consistent with the underlying cipher\u2019s block type. Ensure the module uses the AES-128 instantiation as the CTR parameter and exposes only the AES-128\u2013specialized types and functions of CTR mode."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CTR =\n    Primitive::Symmetric::Cipher::Block::Modes::CTR {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CFB that instantiates the generic Cipher Feedback (CFB) block-cipher mode with the AES-256 block cipher implementation and re-exports the specialized API. The module must contain the following definitions: (1) Type aliases expressing sizes: BlockSize = 128, KeySize = 256, Key = [256], Block = [128], IV = [128], Byte = [8]. (2) Public function signatures for CFB mode specialized to AES-256: encryptCFB that takes a Key, an IV, and a sequence of Byte values (arbitrary length) and returns ciphertext bytes; decryptCFB that takes a Key, an IV, and ciphertext bytes and returns plaintext bytes; streaming variants encryptCFBStream and decryptCFBStream that operate on chunked sequences with identical semantics. (3) Constraints: IV length equals block size; inputs are byte sequences; the key is exactly 256 bits; block size is fixed at 128 bits. (4) Behavioral specification: keystream is produced by encrypting the feedback register with AES-256; the register is initialized with the IV; encryption XORs keystream with plaintext and shifts in resulting ciphertext; decryption XORs keystream with ciphertext and shifts in ciphertext; semantics hold for any message length. (5) Re-export, without redefining, any additional helper definitions from the CFB mode interface, specialized to these sizes."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CFB =\n    Primitive::Symmetric::Cipher::Block::Modes::CFB {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_KeyWrap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap that instantiates the generic AES Key Wrap mode module with the AES\u2011256 block cipher implementation as its parameter. Do not introduce new definitions; instead, specialize and re\u2011export the generic interface provided by the key\u2011wrap functor. Publicly expose the specialized key\u2011wrap and unwrap functions, any associated constants (such as the default IV), helper predicates, and any verification artifacts from the generic module, all fixed to the AES block size and AES\u2011256 key size. Ensure all type synonyms, function signatures, and constraints reflect the specialization to AES\u2011256 (e.g., 128\u2011bit block, 256\u2011bit key, and list\/sequence sizes required by the AES\u2011KW algorithm per RFC 3394). The resulting module should be importable as a drop\u2011in entry point for using AES Key Wrap with AES\u2011256."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap =\n    Primitive::Symmetric::Cipher::Block::Modes::AESKeyWrap {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES192_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CTR that instantiates the generic CTR mode with the AES\u2011192 block cipher and re\u2011exports its specialized interface. The module must contain: (1) type aliases fixing the key width to 192 bits and the block\/counter\/nonce width to 128 bits; (2) a keystream generator that, given a 192\u2011bit key and a 128\u2011bit initial counter, produces an infinite stream of 128\u2011bit blocks by encrypting successive counters with the AES\u2011192 block function; (3) a counter increment function that adds 1 modulo 2^128; (4) encrypt and decrypt functions that XOR the keystream with input data (block\u2011 or byte\u2011oriented), with decryption identical to encryption; (5) appropriate type signatures and constraints ensuring inputs\/outputs match the fixed widths and that sequence lengths are arbitrary; and (6) re\u2011exports of the same names provided by the generic CTR module (e.g., stream, incCounter, encrypt, decrypt), specialized to AES\u2011192. Use the AES\u2011192 primitive (block encryption only) as the underlying block function E: [192] -> [128] -> [128], and ensure no other block size or key size is admitted."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CTR =\n    Primitive::Symmetric::Cipher::Block::Modes::CTR {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains the following definitions: list_definitions. Inside, instantiate a generic Cipher Feedback (CFB) block-cipher mode with a concrete 128-bit block cipher implementation provided elsewhere. Include: (1) type synonyms for the key, block, and IV as 128-bit words; (2) a constant for the block size (128); (3) functions encryptCFB and decryptCFB that process a stream of segments using CFB semantics (XOR with the encryption of the previous ciphertext\/IV, with matching decryption), plus a one-step variant stepCFB for a single segment; (4) optional segment-size\u2013polymorphic variants where the segment width s satisfies fin s, 1 <= s, s <= 128, and 128 % s == 0; and (5) re-exports or wrappers for the underlying block-cipher encrypt primitive used as the keystream generator. Provide precise Cryptol type signatures for all functions, including length- and width-polymorphism over the number of segments n and segment width s. Add the following verification artifacts: define a property that decryptCFB k iv (encryptCFB k iv pt) == pt for all keys, IVs, segment sizes s satisfying the constraints, and plaintext streams; define a property that encryptCFB preserves length; define a property that encryptCFB and decryptCFB are extensionally equivalent to the generic CFB reference when specialized with the same block-cipher encrypt primitive; and define a property that the IV width equals the block width. Ensure the module only depends on the abstract interface of the 128-bit block cipher and cleanly re-exports the CFB-mode API specialized to that cipher."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB =\n    Primitive::Symmetric::Cipher::Block::Modes::CFB {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES192_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains the following definitions: list_definitions. Instantiate a generic CBC mode functor with a provided block-cipher implementation (passed as a module argument) whose block size is 128 bits and key size is 192 bits. Export CBC encryption and decryption functions specialized to this cipher: encryptCBC and decryptCBC. Provide type synonyms for Key (192-bit sequence), Block (128-bit sequence), IV (128-bit sequence), and for a message as a finite sequence of whole blocks. Give type signatures: encryptCBC takes a Key, an IV, and a sequence of blocks, and returns a sequence of blocks; decryptCBC has the analogous type. State preconditions: the IV length equals the block size; the message is a sequence of whole 128-bit blocks; the key is 192 bits. Implement encryptCBC and decryptCBC by delegating to the generic CBC mode using the block cipher\u2019s primitive encrypt\/decrypt operations. Re-export any necessary types from the instantiated CBC module so users can call these operations without additional wrapping. Do not introduce padding; the API operates on complete blocks. Include clear naming for parameters (key, iv, blocks) and use a size parameter n for the number of blocks where appropriate."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CBC =\n    Primitive::Symmetric::Cipher::Block::Modes::CBC {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that is the instantiation of a generic CBC block-cipher mode using an AES implementation with a 256-bit key and a 128-bit block size. The module must: 1) take the existing AES block-cipher module (providing single-block encrypt\/decrypt for 128-bit blocks with a 256-bit key) as the parameter to the CBC mode functor; 2) re-export the specialized CBC interface. Provide explicit type synonyms: Key = [256], Block = [128], IV = Block. Provide type signatures only (no bodies) for: cbcEncrypt : Key -> IV -> [n]Block -> [n]Block and cbcDecrypt : Key -> IV -> [n]Block -> [n]Block, universally quantified over n >= 1. State that the message and ciphertext are sequences of whole blocks, the IV length equals the block size, and the functions are total for any nonnegative n (including n = 0 if allowed by the chosen CBC definition). Constrain the specialized module to use big-endian bit ordering consistent with the AES block implementation. Ensure the module exports only the specialized CBC types and functions (no generic parameters), making it a ready-to-use AES-256-in-CBC-mode specification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CBC =\n    Primitive::Symmetric::Cipher::Block::Modes::CBC {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CBC that instantiates the generic CBC mode with the AES block cipher configured for 128-bit keys and 128-bit blocks. The module must not introduce any new symbols; it should re-export the CBC interface fully specialized to AES-128. Concretely, fix the block size to 128 bits, the IV size to 128 bits, and the key type appropriate for 128-bit AES. Expose the CBC encryption and decryption operations over sequences of 128-bit blocks, along with any associated types and constraints inherited from the generic CBC mode and the AES-128 implementation. Ensure the interface documents that plaintext and ciphertext are lists of 128-bit blocks, the IV is a single 128-bit block, and that operations are defined for finite sequences. The result should be a module-level instantiation that binds the CBC functor to the AES-128 implementation and re-exports all specialized types, constraints, and functions without modification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CBC =\n    Primitive::Symmetric::Cipher::Block::Modes::CBC {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Tests\/tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named module_name that contains the following definitions: for each imported Simon block-cipher instantiation module, define one 0-argument property that checks the encrypt function on a fixed test vector. Each property must bind three local constants: a key, a plaintext, and the expected ciphertext. Use hexadecimal literals with widths matching the instantiation\u2019s parameters: the key constant has bit width equal to that instantiation\u2019s key size, and both plaintext and ciphertext constants have bit width equal to the block size. The body of each property is a boolean equality asserting that encrypt applied to the key and plaintext equals the expected ciphertext. Import the corresponding Simon instantiation modules (one per supported block\/key size) and refer to each instantiation\u2019s encrypt function fully-qualified. Provide exactly one property per imported instantiation, with distinct names (e.g., test0, test1, \u2026). Do not define new algorithms; only state properties over the imported encrypt functions. Ensure every property is fully monomorphic (no type variables) so it can be checked by a solver. Use local where-bindings to define the key, plaintext, and ciphertext constants inside each property. Do not include any additional definitions beyond these properties and the necessary imports."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Tests::tests where\n\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon32_64 as Simon32_64\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_72 as Simon48_72\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_96 as Simon48_96\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_96 as Simon64_96\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_128 as Simon64_128\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96 as Simon96_96\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_144 as Simon96_144\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128 as Simon128_128\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_192 as Simon128_192\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256 as Simon128_256\n\nproperty t0 = Simon32_64::encrypt k pt == ct\n  where\n    k = 0x1918_1110_0908_0100\n    pt = 0x6565_6877\n    ct = 0xc69b_e9bb\n\nproperty t1 = Simon48_72::encrypt k pt == ct\n  where\n    k = 0x121110_0a0908_020100\n    pt = 0x612067_6e696c\n    ct = 0xdae5ac_292cac\n\nproperty t2 = Simon48_96::encrypt k pt == ct\n  where\n    k = 0x1a1918_121110_0a0908_020100\n    pt = 0x726963_20646e\n    ct = 0x6e06a5_acf156\n\nproperty t3 = Simon64_96::encrypt k pt == ct\n  where\n    k = 0x13121110_0b0a0908_03020100\n    pt = 0x6f722067_6e696c63\n    ct = 0x5ca2e27f_111a8fc8\n\nproperty t4 = Simon64_128::encrypt k pt == ct\n  where\n    k = 0x1b1a1918_13121110_0b0a0908_03020100\n    pt = 0x656b696c_20646e75\n    ct = 0x44c8fc20_b9dfa07a\n\nproperty t5 = Simon96_96::encrypt k pt == ct\n  where\n    k = 0x0d0c0b0a0908_050403020100\n    pt = 0x2072616c6c69_702065687420\n    ct = 0x602807a462b4_69063d8ff082\n\nproperty t6 = Simon96_144::encrypt k pt == ct\n  where\n    k = 0x151413121110_0d0c0b0a0908_050403020100\n    pt = 0x746168742074_73756420666f\n    ct = 0xecad1c6c451e_3f59c5db1ae9\n\nproperty t7 = Simon128_128::encrypt k pt == ct\n  where\n    k = 0x0f0e0d0c0b0a0908_0706050403020100\n    pt = 0x6373656420737265_6c6c657661727420\n    ct = 0x49681b1e1e54fe3f_65aa832af84e0bbc\n\nproperty t8 = Simon128_192::encrypt k pt == ct\n  where\n    k = 0x1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n    pt = 0x206572656874206e_6568772065626972\n    ct = 0xc4ac61effcdc0d4f_6c9c8d6e2597b85b\n\nproperty t9 = Simon128_256::encrypt k pt == ct\n  where\n    k = 0x1f1e1d1c1b1a1918_1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n    pt = 0x74206e69206d6f6f_6d69732061207369\n    ct = 0x8d2b5579afc8a3a0_3bf72a87efe7b868\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon96_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module that instantiates a generic Simon block cipher specification for the 96-bit block with 96-bit key variant by fixing its type parameters. Bind the type-level parameters as follows: set the word size to 48 bits, the block width (words per block) to 2, the number of rounds to 52, and the rotation-constant selector to 2. Make the module equal to the generic specification using a where-clause that introduces these type synonyms, and inherit all functions and properties from the specification without redefining them. Do not add new functions; only provide these type bindings so the instantiated module exports the specialized Simon-96\/96 interface."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 48\n    type m = 2\n    type T = 52\n    type j = 2\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon96_144.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_144 that instantiates and re-exports the generic Simon block-cipher specification with concrete type parameters. Inside the module, declare four type synonyms assigning: a 48-bit word size, a 3-word block size, 54 rounds, and a key-schedule index of 3. Make the module equal to the generic Simon specification specialized by these parameters, with no additional functions, constants, or properties."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_144 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 48\n    type m = 3\n    type T = 54\n    type j = 3\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon64_128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_128 that specializes the generic Simon block-cipher specification for the 64-bit block and 128-bit key variant. Inside this module, set the following type parameters: n = 32 to denote the bit width of each word, m = 4 to denote the number of key words, T = 44 to denote the number of rounds, and j = 3 to denote the key-schedule index parameter. The module must be an instantiation of the shared Simon specification and reexport all of its definitions parameterized by these types, with no additional functions or properties."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_128 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 32\n    type m = 4\n    type T = 44\n    type j = 3\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon48_72.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_72 that instantiates the generic Simon block-cipher specification and contains the following definitions: a type parameter n set to 24 (the half-block size in bits), a type parameter m set to 3 (the number of key words), a type parameter T set to 36 (the number of rounds), and a type parameter j set to 0 (the sequence index for round constants). Ensure the module simply specializes the generic specification with these exact type-level values and exposes all inherited definitions accordingly, without modifying any algorithms or adding new functions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_72 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 24\n    type m = 3\n    type T = 36\n    type j = 0\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon128_128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128 that is an instantiation of the generic Simon block-cipher specification. Make it a module alias of Primitive::Symmetric::Cipher::Block::Simon::Specification and, via a where-clause, set the following type-level parameters: n = 64, m = 2, T = 68, and j = 2. These should be defined as type synonyms for type-level naturals to select the 128-bit block\/128-bit key Simon variant. Do not add any other declarations or properties; only supply these type bindings in the instantiation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 64\n    type m = 2\n    type T = 68\n    type j = 2\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon64_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_96 that instantiates the generic Simon block-cipher specification module and fixes its type parameters as constant type synonyms: set the word-size parameter to 32, the key-word count to 3, the round count to 42, and the key-schedule index parameter to 2. The module must re-export all resulting types, functions, and properties from the generic specification under these fixed parameters, and introduce no additional bindings beyond these type assignments."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_96 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 32\n    type m = 3\n    type T = 42\n    type j = 2\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon128_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256 that instantiates the Simon cipher base specification module and exposes its interface. Within this module, bind the specification\u2019s type parameters to concrete values as follows: set the word-size parameter to 64, the key-word count parameter to 4, the round-count parameter to 72, and the key-schedule index parameter to 4. Provide these as type aliases\/constraints appropriate for the base specification so the instantiation is well-typed, and re-export all declarations from the base specification under this concrete configuration."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 64\n    type m = 4\n    type T = 72\n    type j = 4\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon128_192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_192 that instantiates the generic Primitive::Symmetric::Cipher::Block::Simon::Specification by fixing the type parameters to: n = 64 (word size), m = 3 (number of key words), T = 69 (round count), and j = 3 (round-constant sequence selector). The module should specialize the specification with these parameters and re-export all resulting types and functions (such as key schedule, encryption, and decryption) appropriate for a 128-bit block (2\u00b7n) and a 192-bit key (m\u00b7n). Provide the necessary type aliases and constraints so the instantiation is well-typed and self-contained, and ensure the module body is exactly the parameterized specification instantiated with these values."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_192 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 64\n    type m = 3\n    type T = 69\n    type j = 3\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon48_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_96 that instantiates the generic Simon block-cipher specification and contains the following definitions: a type alias n set to 24 (half-block width in bits), a type alias m set to 4 (number of key words), a type alias T set to 36 (round count), and a type alias j set to 1 (key-schedule parameter). The module must bind to the generic Simon specification using these concrete type parameters and re-export all resulting functions and properties specialized to this configuration, representing the Simon variant with a 48-bit block and a 96-bit key. Do not alter algorithms; only fix these type parameters and expose the instantiated interface."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_96 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 24\n    type m = 4\n    type T = 36\n    type j = 1\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Tests\/tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Speck::Tests::tests that contains: (1) imports of the Speck instantiation modules for the following variants, each aliased to its variant name: 32\/64, 48\/72, 48\/96, 64\/96, 64\/128, 96\/96, 96\/144, 128\/128, 128\/192, and 128\/256; each module provides an encrypt function taking a key and a plaintext block and returning a ciphertext block. (2) ten properties named t0 through t9. For each ti, bind local constants k (key), p (plaintext), and c (ciphertext) to the given literal values for that variant, and assert the Boolean equality encrypt k p == c from the corresponding imported module. Use widths matching each variant: keys of 64, 72, 96, 96, 128, 96, 144, 128, 192, and 256 bits respectively; plaintext and ciphertext blocks of 32, 48, 48, 64, 64, 96, 96, 128, 128, and 128 bits respectively. Each property is a checkable Boolean statement verifying that encryption of the specified plaintext under the given key yields the expected ciphertext. Do not define any additional functions; all verification is via these properties with local where bindings for k, p, and c."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Tests::tests where\n\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck32_64 as Speck32_64\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_72 as Speck48_72\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_96 as Speck48_96\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_96 as Speck64_96\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_128 as Speck64_128\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_96 as Speck96_96\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_144 as Speck96_144\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_128 as Speck128_128\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_192 as Speck128_192\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_256 as Speck128_256\n\nproperty t0 = Speck32_64::encrypt k p == c\n    where\n        k = 0x1918_1110_0908_0100\n        p = 0x6574_694c\n        c = 0xa868_42f2\n\nproperty t1 = Speck48_72::encrypt k p == c\n    where\n        k = 0x121110_0a0908_020100\n        p = 0x20796c_6c6172\n        c = 0xc049a5_385adc\n\nproperty t2 = Speck48_96::encrypt k p == c\n    where\n        k = 0x1a1918_121110_0a0908_020100\n        p = 0x6d2073_696874\n        c = 0x735e10_b6445d\n\nproperty t3 = Speck64_96::encrypt k p == c\n    where\n        k = 0x13121110_0b0a0908_03020100\n        p = 0x74614620_736e6165\n        c = 0x9f7952ec_4175946c\n\nproperty t4 = Speck64_128::encrypt k p == c\n    where\n        k = 0x1b1a1918_13121110_0b0a0908_03020100\n        p = 0x3b726574_7475432d\n        c = 0x8c6fa548_454e028b\n\nproperty t5 = Speck96_96::encrypt k p == c\n    where\n        k = 0x0d0c0b0a0908_050403020100\n        p = 0x65776f68202c_656761737520\n        c = 0x9e4d09ab7178_62bdde8f79aa\n\nproperty t6 = Speck96_144::encrypt k p == c\n    where\n        k = 0x151413121110_0d0c0b0a0908_050403020100\n        p = 0x656d6974206e_69202c726576\n        c = 0x2bf31072228a_7ae440252ee6\n\nproperty t7 = Speck128_128::encrypt k p == c\n    where\n        k = 0x0f0e0d0c0b0a0908_0706050403020100\n        p = 0x6c61766975716520_7469206564616d20\n        c = 0xa65d985179783265_7860fedf5c570d18\n\nproperty t8 = Speck128_192::encrypt k p == c\n    where\n        k = 0x1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n        p = 0x7261482066656968_43206f7420746e65\n        c = 0x1be4cf3a13135566_f9bc185de03c1886\n\nproperty t9 = Speck128_256::encrypt k p == c\n    where\n        k = 0x1f1e1d1c1b1a1918_1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n        p = 0x65736f6874206e49_202e72656e6f6f70\n        c = 0x4109010405c0f53e_4eeeb48d9c188f43\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck48_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_96 that re-exports the generic Speck specification module and fixes its parameters for the 48\/96 instantiation. Inside this module, provide only three type aliases: n set to 24 to denote the word size (implying a 48-bit block), m set to 4 to denote the number of key words (implying a 96-bit key), and T set to 23 to denote the number of rounds. Do not introduce any additional values, functions, or properties; simply bind to the specification module and supply these type parameters so that all inherited definitions specialize to this variant."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_96 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 24\ntype m = 4\ntype T = 23\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck32_64.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck32_64 that instantiates the generic Speck block-cipher specification, providing exactly these numeric type synonyms: n = 16 (word size in bits), m = 4 (number of key words), and T = 22 (round count). Make these synonyms the only bindings supplied to the instantiation so the resulting module denotes the Speck32\/64 configuration. Do not add any additional values, functions, or properties."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck32_64 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 16\ntype m = 4\ntype T = 22\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck128_128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_128 that is an instantiation of Primitive::Symmetric::Cipher::Block::Speck::Specification, specializing it to the Speck-128\/128 configuration. Inside the module, provide exactly these type synonyms: n as the word size in bits set to 64; m as the number of key words set to 2; and T as the number of rounds set to 32. Do not add any other bindings or properties; the module should simply bind to the generic specification with these parameters so that all exported functions and types from the specification are specialized to this configuration."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_128 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 64\ntype m = 2\ntype T = 32\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck64_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_96 that instantiates the generic Speck block-cipher specification and re-exports its definitions specialized to fixed parameters. Inside the module, declare type synonyms to set the cipher parameters: n as 32 to represent the word size in bits (implying a 64-bit block), m as 3 to represent the number of key words (implying a 96-bit key), and T as 26 to represent the number of rounds. Ensure the module aliases the generic specification so that the key schedule, round function, encryption, and decryption are available exactly as defined by the specification but specialized to these parameter values, without introducing any additional functions or properties."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_96 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 32\ntype m = 3\ntype T = 26\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck128_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_256 that instantiates the generic Speck cipher specification module and fixes its type parameters via local type synonyms: set n to 64 (word size in bits), m to 4 (words per block), and T to 34 (number of rounds). The module should otherwise inherit and expose the specification\u2019s definitions unchanged, adding no new functions, properties, or constants."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_256 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 64\ntype m = 4\ntype T = 34\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck96_144.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_144 that instantiates the generic Speck block-cipher specification with fixed type parameters: set the word size parameter to 48 bits, the block to consist of 3 words (144-bit block), and the number of rounds to 29. Inside the module, declare these parameters as type synonyms and re-export the generic specification\u2019s definitions specialized to them, including the key schedule, round function, encryption, and decryption. Provide explicit type signatures for the public functions using these fixed parameters (for example, encryption\/decryption operating on 144-bit blocks and keys of the appropriate width derived from the parameters). Do not modify any algorithms; only specialize the interface to these parameter values and ensure the module exposes the same API as the generic specification under this instantiation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_144 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 48\ntype m = 3\ntype T = 29\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck64_128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_128 that contains the following definitions: a type synonym n set to 32 representing the word size in bits; a type synonym m set to 4 representing the number of n-sized words per block; and a type synonym T set to 27 representing the number of rounds. The module must instantiate the generic Speck block-cipher specification module, binding these parameters so that all cipher components (key schedule, round function, encryption, and decryption) are specialized to the Speck-64\/128 variant and re-exported from this module. Do not modify algorithm logic; only provide the parameterization and ensure the module exports the specialized definitions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_128 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 32\ntype m = 4\ntype T = 27\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck96_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_96 that instantiates and re-exports the generic Speck block-cipher specification. The module must contain the following definitions: a type synonym setting the word size n to 48, a type synonym setting the number of words m to 2, and a type synonym setting the number of rounds T to 28. Ensure the module aliases the generic specification so all functions and types are specialized to these parameters (yielding a 96-bit block and 96-bit key variant)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_96 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 48\ntype m = 2\ntype T = 28\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck48_72.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_72 that instantiates the generic Speck block-cipher specification from Primitive::Symmetric::Cipher::Block::Speck::Specification and sets the parameter types used by that specification. Inside the module, define: (1) a type alias n set to 24 to represent the word size (half of a 48-bit block), (2) a type alias m set to 3 to represent the number of n-bit words in a 72-bit key, and (3) a type alias T set to 22 to represent the number of rounds for this variant. Ensure the module reuses all definitions from the base specification and only overrides these type parameters."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_72 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 24\ntype m = 3\ntype T = 22\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck128_192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_192 that is an instantiation of the generic Speck block-cipher specification. Inside this module, bind the specification\u2019s type parameters as local type synonyms: set the word-size parameter to 64, set the key-word-count parameter to 3 (corresponding to a 192-bit key), and set the round-count parameter to 33. The module should otherwise consist solely of this instantiation and inherit all functions, types, and properties from the base specification under these parameter values."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_192 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 64\ntype m = 3\ntype T = 33\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Tests\/AES256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::AES::Tests::AES256 that contains: (1) an import of the AES\u2011256 instantiation module under the alias AES256, exposing encrypt and decrypt; and (2) a property named aes256TestVectorsPass. In the property\u2019s where-clause, declare a constant 256-bit key, a list of four 128-bit plaintext blocks, and a list of four 128-bit expected ciphertext blocks (use the standard AES\u2011256 ECB known-answer test set). Construct two boolean lists by zipping the plaintext and ciphertext lists: one list where each element asserts that encrypt applied to the fixed key and a plaintext equals the corresponding expected ciphertext, and another list where each element asserts that decrypt applied to the fixed key and a ciphertext equals the corresponding plaintext. The property must evaluate to the conjunction of all encryption checks and all decryption checks. Ensure all constants have the correct bit widths, and use list reduction via conjunction to combine results into a single boolean suitable for solver checking."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Tests::AES256 where\nimport Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256 as AES256\n\nproperty aes256TestVectorsPass = and encryptions \/\\ and decryptions\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        pts = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        expected_cts = [\n            0xf3eed1bdb5d2a03c064b5a7e3db181f8,\n            0x591ccb10d410ed26dc5ba74a31362870,\n            0xb6ed21b99ca6f4f9f153e7b1beafed1d,\n            0x23304b7a39f9f3ff067d8d8f9e24ecc7\n        ]\n        encryptions = [ AES256::encrypt key msg == ct | msg <- pts | ct <- expected_cts ]\n        decryptions = [ AES256::decrypt key ct == pt | pt <- pts | ct <- expected_cts ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Tests\/AES192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::AES::Tests::AES192 that contains the following definitions and types, and no others: import the AES-192 instantiation module under the alias AES192; a constant key of type [192] equal to the given 192-bit test key; a value pts of type [4][128] holding four AES plaintext blocks; a value expected_cts of type [4][128] holding the corresponding expected ciphertext blocks; a value encryptions of type [4]Bit computed by zipping pts with expected_cts and, for each pair, checking that AES192::encrypt key msg equals ct; a value decryptions of type [4]Bit computed by zipping pts with expected_cts and, for each pair, checking that AES192::decrypt key ct equals pt; and a property aes192TestVectorsPass of type Bit that is the logical conjunction of all results in encryptions and all results in decryptions. Use the exact key and test vectors from the source. Provide explicit type signatures for key, pts, expected_cts, encryptions, decryptions, and aes192TestVectorsPass. Preserve the specified names and alias."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Tests::AES192 where\nimport Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192 as AES192\n\nproperty aes192TestVectorsPass = and encryptions \/\\ and decryptions\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        pts = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        expected_cts = [\n            0xbd334f1d6e45f25ff712a214571fa5cc,\n            0x974104846d0ad3ad7734ecb3ecee4eef,\n            0xef7afd2270e2e60adce0ba2face6444e,\n            0x9a4b41ba738d6c72fb16691603c18e0e\n        ]\n        encryptions = [ AES192::encrypt key msg == ct | msg <- pts | ct <- expected_cts ]\n        decryptions = [ AES192::decrypt key ct == pt | pt <- pts | ct <- expected_cts ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Instantiations\/AES128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128 that instantiates the AES specification by fixing the key-size type parameter (KeySize') to 128 bits. The module must re-export all definitions from the AES specification\u2014types (including state and key types), functions (key schedule, encryption, decryption, round transforms), constants (such as S-boxes and round constants), and any properties\u2014specialized for a 128-bit key. No additional changes or new definitions are required beyond binding the key-size type to 128."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128 =\n    Primitive::Symmetric::Cipher::Block::AES::Specification where\n    type KeySize' = 128\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Instantiations\/AES256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256 that specializes the generic AES block-cipher specification to a 256-bit key. Inside the module, declare the type-level natural KeySize' with value 256 (bits). The module should otherwise expose the same public API (types, functions, and properties) as the generic AES specification, but specialized to this key size. Do not add new functions or properties; simply instantiate the specification with this type parameter and re-export all resulting definitions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256 =\n    Primitive::Symmetric::Cipher::Block::AES::Specification where\n    type KeySize' = 256\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Instantiations\/AES192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192 that instantiates the generic AES block-cipher specification by fixing its key-size type parameter to 192 bits. Inside the module, provide a single type binding that sets the key-size parameter to 192, and re-export all types, constants, functions, and properties from the underlying AES specification unchanged. Do not introduce any additional definitions or modifications; the only customization is the key-size parameterization to 192-bit keys so that all inherited definitions operate at this key size."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192 =\n    Primitive::Symmetric::Cipher::Block::AES::Specification where\n    type KeySize' = 192\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::MAC::HMAC::Specification that contains the following definitions: (1) Type parameters for a block size (B) and digest size (L), both numeric kinds. Impose global constraints: B is finite, L does not exceed B, and the bit-widths needed to represent 8\u00b7L and 8\u00b7(B+L) do not exceed B. (2) A polymorphic hash oracle H that, for any message length T whose 8\u00b7T bit-width fits within B, maps a T-byte sequence to an L-byte sequence. (3) A function hmac parameterized by key length k and message length n, with constraints that the bit-widths for 8\u00b7k and 8\u00b7(n+B) fit within B, returning an L-byte authenticator. Its behavior is the standard HMAC construction: compute a block-sized key by expand_key, then hash the concatenation of (key XOR inner pad) with the message, and finally hash the concatenation of (key XOR outer pad) with the inner hash. (4) A function hmac_truncate parameterized by \u03bb, k, n, requiring 4 \u2264 \u03bb < L and the same width constraints as above, returning the first \u03bb bytes of hmac. (5) Private block-sized constants for the inner and outer pads consisting of repeated bytes 0x36 and 0x5c, respectively. (6) A private function expand_key that yields a block-sized key: zero-pad if the key length is at most the block size; otherwise hash the key with H and then zero-pad, so the result is exactly B bytes."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Specification where\n\nparameter\n\n  type B : #\n\n  type L : #\n\n  type constraint (fin B, L <= B, width (8 * L) <= B, width (8 * (B + L)) <= B)\n\n  H : {T} (width (8 * T) <= B) => [T][8] -> [L][8]\n\nhmac : {k, n} (width (8 * k) <= B, width (8 * (n + B)) <= B) => [k][8] -> [n][8] -> [L][8]\nhmac K text = H ((K\u2080 ^ opad) # H ((K\u2080 ^ ipad) # text)) where\n\n  K\u2080 = expand_key K\n\nhmac_truncate : {\u03bb, k, n} (\u03bb < L, \u03bb >= 4, width (8 * k) <= B, width (8 * (n + B)) <= B)\n  => [k][8] -> [n][8] -> [\u03bb][8]\nhmac_truncate K text = take output where\n  output = hmac K text\n\nprivate\n\n  ipad : [B][8]\n  ipad = repeat 0x36\n\n  opad : [B][8]\n  opad = repeat 0x5c\n\n  expand_key : {k} (width (8 * k) <= B) => [k][8] -> [B][8]\n  expand_key K\n    | k <= B => K # zero\n\n    | k > B => H K # zero\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Tests\/HMAC_SHA2_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA2_512 that imports Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA512 as H512 and contains the following definitions: (1) A type alias PrfParams K D for a record with fields: a K-byte key, a D-byte message, and a 512-bit expected tag. (2) A function prf_test with type {K,D} (K < 256, D < 256) => PrfParams K D -> Bit that returns whether H512.hmac applied to the key and message equals the byte-split form of the 512-bit expected tag. (3) Six properties named rfc_4868_2_7_1_1 through rfc_4868_2_7_1_6, each instantiating prf_test with the exact key, message, and full-length tag from the corresponding cases in RFC 4868 section 2.7.1. (4) A type alias AuthTest512 T for a record with fields: a 64-byte key, a T-byte message, a 512-bit full tag, and a 256-bit truncated tag. (5) A function sha2_512_auth_test with type {T} (T < 256) => AuthTest512 T -> Bit that returns the conjunction of: H512.hmac equals the byte-split 512-bit full tag, and H512.hmac_truncate equals the byte-split 256-bit truncated tag. (6) Four properties named rfc_4868_2_7_2_3_1 through rfc_4868_2_7_2_3_4, each instantiating sha2_512_auth_test with the exact vectors from RFC 4868 section 2.7.2.3. Encode all vectors as byte strings or hexadecimal constants, and split bitvectors into bytes before comparison."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA2_512 where\n\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA512 as H512\n\ntype PrfParams K D =\n  { Key : [K][8]\n  , Data: [D][8]\n  , PRF_HMAC_SHA_512 : [512]\n  }\n\nprf_test : {K, D} (K < 256, D < 256) => PrfParams K D -> Bit\nprf_test params =\n  H512::hmac params.Key params.Data == split params.PRF_HMAC_SHA_512\n\nproperty rfc_4868_2_7_1_1 = prf_test\n  { Key = repeat`{20} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_512 =\n      0x87aa7cdea5ef619d4ff0b4241a1d6cb0 #\n      0x2379f4e2ce4ec2787ad0b30545e17cde #\n      0xdaa833b7d6b8a702038b274eaea3f4e4 #\n      0xbe9d914eeb61f1702e696c203a126854\n  }\n\nproperty rfc_4868_2_7_1_2 = prf_test\n  { Key = \"Jefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_512 =\n      0x164b7a7bfcf819e2e395fbe73b56e0a3 #\n      0x87bd64222e831fd610270cd7ea250554 #\n      0x9758bf75c05a994a6d034f65f8f0e6fd #\n      0xcaeab1a34d4a6b4b636e070a38bce737\n  }\n\nproperty rfc_4868_2_7_1_3 = prf_test\n  { Key = repeat`{20} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_512 =\n      0xfa73b0089d56a284efb0f0756c890be9 #\n      0xb1b5dbdd8ee81a3655f83e33b2279d39 #\n      0xbf3e848279a722c806b485a47e67c807 #\n      0xb946a337bee8942674278859e13292fb\n  }\n\nproperty rfc_4868_2_7_1_4 = prf_test\n  { Key = split 0x0102030405060708090a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_512 =\n      0xb0ba465637458c6990e5a8c5f61d4af7 #\n      0xe576d97ff94b872de76f8050361ee3db #\n      0xa91ca5c11aa25eb4d679275cc5788063 #\n      0xa5f19741120c4f2de2adebeb10a298dd\n  }\n\nproperty rfc_4868_2_7_1_5 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  , PRF_HMAC_SHA_512 =\n      0x80b24263c7c1a3ebb71493c1dd7be8b4 #\n      0x9b46d1f41b4aeec1121b013783f8f352 #\n      0x6b56d037e05f2598bd0fd2215d6a1e52 #\n      0x95e64f73f63f0aec8b915a985d786598\n  }\n\nproperty rfc_4868_2_7_1_6 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.\"\n  , PRF_HMAC_SHA_512 =\n      0xe37b6a775dc87dbaa4dfa9f96e5e3ffd #\n      0xdebd71f8867289865df5a32d20cdc944 #\n      0xb6022cac3c4982b10d5eeb55c3e4de15 #\n      0x134676fb6de0446065c97440fa8c6a58\n  }\n\ntype AuthTest512 T =\n  { Key : [64][8]\n  , Data : [T][8]\n  , PRF_HMAC_SHA_512 : [512]\n  , HMAC_SHA_512_256 : [256]\n  }\n\nsha2_512_auth_test : {T} (T < 256) => AuthTest512 T -> Bit\nsha2_512_auth_test params =\n  H512::hmac params.Key params.Data == split params.PRF_HMAC_SHA_512 \/\\\n  H512::hmac_truncate params.Key params.Data == split params.HMAC_SHA_512_256\n\nproperty rfc_4868_2_7_2_3_1 = sha2_512_auth_test\n  { Key = repeat`{64} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_512 =\n      0x637edc6e01dce7e6742a99451aae82df #\n      0x23da3e92439e590e43e761b33e910fb8 #\n      0xac2878ebd5803f6f0b61dbce5e251ff8 #\n      0x789a4722c1be65aea45fd464e89f8f5b\n  , HMAC_SHA_512_256 =\n      0x637edc6e01dce7e6742a99451aae82df #\n      0x23da3e92439e590e43e761b33e910fb8\n  }\n\nproperty rfc_4868_2_7_2_3_2 = sha2_512_auth_test\n  { Key = \"JefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_512 =\n      0xcb370917ae8a7ce28cfd1d8f4705d614 #\n      0x1c173b2a9362c15df235dfb251b15454 #\n      0x6aa334ae9fb9afc2184932d8695e397b #\n      0xfa0ffb93466cfcceaae38c833b7dba38\n  , HMAC_SHA_512_256 =\n      0xcb370917ae8a7ce28cfd1d8f4705d614 #\n      0x1c173b2a9362c15df235dfb251b15454\n  }\n\nproperty rfc_4868_2_7_2_3_3 = sha2_512_auth_test\n  { Key = repeat`{64} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_512 =\n      0x2ee7acd783624ca9398710f3ee05ae41 #\n      0xb9f9b0510c87e49e586cc9bf961733d8 #\n      0x623c7b55cebefccf02d5581acc1c9d5f #\n      0xb1ff68a1de45509fbe4da9a433922655\n  , HMAC_SHA_512_256 =\n      0x2ee7acd783624ca9398710f3ee05ae41 #\n      0xb9f9b0510c87e49e586cc9bf961733d8\n  }\n\nproperty rfc_4868_2_7_2_3_4 = sha2_512_auth_test\n  { Key =\n            split 0x0102030405060708090a0b0c0d0e0f10 #\n      split 0x1112131415161718191a1b1c1d1e1f20 #\n      split 0x2122232425262728292a2b2c2d2e2f30 #\n      split 0x3132333435363738393a3b3c3d3e3f40\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_512 =\n      0x5e6688e5a3daec826ca32eaea224eff5 #\n      0xe700628947470e13ad01302561bab108 #\n      0xb8c48cbc6b807dcfbd850521a685babc #\n      0x7eae4a2a2e660dc0e86b931d65503fd2\n  , HMAC_SHA_512_256 =\n      0x5e6688e5a3daec826ca32eaea224eff5 #\n      0xe700628947470e13ad01302561bab108\n  }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Tests\/HMAC_SHA1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA1 that imports Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA1. Within it, add: (1) a polymorphic record type alias PrfParams parameterized by K and D, where Key is K bytes, Data is D bytes, and PRF_HMAC_SHA_1 is 160 bits; (2) a function prf_test with size parameters K and D constrained to be less than 256, taking PrfParams K D and returning Bit, which holds exactly when the HMAC-SHA1 of Key and Data equals the byte-split form of PRF_HMAC_SHA_1; (3) a record type alias AuthTest parameterized by T, where Key is 20 bytes, Data is T bytes, PRF_HMAC_SHA_1 is 160 bits, and HMAC_SHA_1_96 is 96 bits; (4) a function sha1_auth_test with size parameter T < 256 taking AuthTest T and returning Bit, which holds iff both the full HMAC equals the split PRF_HMAC_SHA_1 and the truncated HMAC equals the split HMAC_SHA_1_96; (5) properties rfc_2202_3_1 through rfc_2202_3_7. Each property must instantiate prf_test or sha1_auth_test with concrete constants from RFC 2202 HMAC-SHA1 test cases 3.1\u20133.7, ensuring sizes match the declared types; the 3.5 case additionally checks the 96-bit truncated tag. Use byte sequences for keys and messages, bitvectors for expected tags, and convert tags to byte sequences via splitting before comparison."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA1 where\n\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA1\n\ntype PrfParams K D =\n  { Key : [K][8]\n  , Data: [D][8]\n  , PRF_HMAC_SHA_1 : [160]\n  }\n\nprf_test : {K, D} (K < 256, D < 256) => PrfParams K D -> Bit\nprf_test params = hmac params.Key params.Data == split params.PRF_HMAC_SHA_1\n\ntype AuthTest T =\n  { Key : [20][8]\n  , Data : [T][8]\n  , PRF_HMAC_SHA_1 : [160]\n  , HMAC_SHA_1_96 : [96]\n  }\n\nsha1_auth_test : {T} (T < 256) => AuthTest T -> Bit\nsha1_auth_test params =\n  hmac params.Key params.Data == split params.PRF_HMAC_SHA_1 \/\\\n  hmac_truncate params.Key params.Data == split params.HMAC_SHA_1_96\n\nproperty rfc_2202_3_1 = prf_test\n  { Key = repeat`{20} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_1 = 0xb617318655057264e28bc0b6fb378c8ef146be00\n  }\n\nproperty rfc_2202_3_2 = prf_test\n  { Key = \"Jefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_1 = 0xeffcdf6ae5eb2fa2d27416d5f184df9c259a7c79\n  }\n\nproperty rfc_2202_3_3 = prf_test\n  { Key = repeat`{20} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_1 = 0x125d7342b9ac11cd91a39af48aa17b4f63f175d3\n  }\n\nproperty rfc_2202_3_4 = prf_test\n  { Key = split 0x0102030405060708090a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_1 = 0x4c9007f4026250c6bc8414f9bf50c86c2d7235da\n  }\n\nproperty rfc_2202_3_5 = sha1_auth_test\n  { Key = repeat`{20} 0x0c\n  , Data = \"Test With Truncation\"\n  , PRF_HMAC_SHA_1 = 0x4c1a03424b55e07fe7f27be1d58bb9324a9a5a04\n  , HMAC_SHA_1_96 = 0x4c1a03424b55e07fe7f27be1\n  }\n\nproperty rfc_2202_3_6 = prf_test\n  { Key = repeat`{80} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  , PRF_HMAC_SHA_1 = 0xaa4ae5e15272d00e95705637ce8a3b55ed402112\n  }\n\nproperty rfc_2202_3_7 = prf_test\n  { Key = repeat`{80} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data\"\n  , PRF_HMAC_SHA_1 = 0xe8e99d0f45237d786d6bbaa7965c7808bbff1a91\n  }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Tests\/HMAC_SHA2_384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA2_384 that imports Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA384 as H384 and contains these definitions: (1) a type PrfParams K D, a record with Key as a sequence of K bytes, Data as a sequence of D bytes, and PRF_HMAC_SHA_384 as a 384-bit expected tag; (2) prf_test with constraints K < 256 and D < 256 that takes PrfParams K D and returns a boolean asserting H384::hmac applied to Key and Data equals the byte-split form of the expected 384-bit tag; (3) six properties rfc_4868_2_7_1_1 through rfc_4868_2_7_1_6, each set to prf_test instantiated with one of the official HMAC-SHA-384 test vectors from RFC 4868 \u00a72.7.1, using the corresponding fixed key, data, and full 384-bit tag constants; (4) a type AuthTest384 T, a record with Key as 48 bytes, Data as a sequence of T bytes, PRF_HMAC_SHA_384 as a 384-bit expected tag, and HMAC_SHA_384_192 as a 192-bit expected truncated tag; (5) sha2_384_auth_test with constraint T < 256 that returns a boolean asserting both H384::hmac equals the split 384-bit tag and H384::hmac_truncate equals the split 192-bit tag; and (6) four properties rfc_4868_2_7_2_2_1 through rfc_4868_2_7_2_2_4 that instantiate sha2_384_auth_test with the corresponding RFC 4868 \u00a72.7.2.2 test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA2_384 where\n\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA384 as H384\n\ntype PrfParams K D =\n  { Key : [K][8]\n  , Data: [D][8]\n  , PRF_HMAC_SHA_384 : [384]\n  }\n\nprf_test : {K, D} (K < 256, D < 256) => PrfParams K D -> Bit\nprf_test params =\n  H384::hmac params.Key params.Data == split params.PRF_HMAC_SHA_384\n\nproperty rfc_4868_2_7_1_1 = prf_test\n  { Key = repeat`{20} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_384 =\n      0xafd03944d84895626b0825f4ab46907f #\n      0x15f9dadbe4101ec682aa034c7cebc59c #\n      0xfaea9ea9076ede7f4af152e8b2fa9cb6\n  }\n\nproperty rfc_4868_2_7_1_2 = prf_test\n  { Key = \"Jefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_384 =\n      0xaf45d2e376484031617f78d2b58a6b1b #\n      0x9c7ef464f5a01b47e42ec3736322445e #\n      0x8e2240ca5e69e2c78b3239ecfab21649\n  }\n\nproperty rfc_4868_2_7_1_3 = prf_test\n  { Key = repeat`{20} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_384 =\n      0x88062608d3e6ad8a0aa2ace014c8a86f #\n      0x0aa635d947ac9febe83ef4e55966144b #\n      0x2a5ab39dc13814b94e3ab6e101a34f27\n  }\n\nproperty rfc_4868_2_7_1_4 = prf_test\n  { Key = split 0x0102030405060708090a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_384 =\n      0x3e8a69b7783c25851933ab6290af6ca7 #\n      0x7a9981480850009cc5577c6e1f573b4e #\n      0x6801dd23c4a7d679ccf8a386c674cffb\n  }\n\nproperty rfc_4868_2_7_1_5 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  , PRF_HMAC_SHA_384 =\n      0x4ece084485813e9088d2c63a041bc5b4 #\n      0x4f9ef1012a2b588f3cd11f05033ac4c6 #\n      0x0c2ef6ab4030fe8296248df163f44952\n  }\n\nproperty rfc_4868_2_7_1_6 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.\"\n  , PRF_HMAC_SHA_384 =\n      0x6617178e941f020d351e2f254e8fd32c #\n      0x602420feb0b8fb9adccebb82461e99c5 #\n      0xa678cc31e799176d3860e6110c46523e\n  }\n\ntype AuthTest384 T =\n  { Key : [48][8]\n  , Data : [T][8]\n  , PRF_HMAC_SHA_384 : [384]\n  , HMAC_SHA_384_192 : [192]\n  }\n\nsha2_384_auth_test : {T} (T < 256) => AuthTest384 T -> Bit\nsha2_384_auth_test params =\n  H384::hmac params.Key params.Data == split params.PRF_HMAC_SHA_384 \/\\\n  H384::hmac_truncate params.Key params.Data == split params.HMAC_SHA_384_192\n\nproperty rfc_4868_2_7_2_2_1 = sha2_384_auth_test\n  { Key = repeat`{48} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_384 =\n      0xb6a8d5636f5c6a7224f9977dcf7ee6c7 #\n      0xfb6d0c48cbdee9737a959796489bddbc #\n      0x4c5df61d5b3297b4fb68dab9f1b582c2\n  , HMAC_SHA_384_192 =\n      0xb6a8d5636f5c6a7224f9977dcf7ee6c7 #\n      0xfb6d0c48cbdee973\n  }\n\nproperty rfc_4868_2_7_2_2_2 = sha2_384_auth_test\n  { Key = \"JefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_384 =\n      0x2c7353974f1842fd66d53c452ca42122 #\n      0xb28c0b594cfb184da86a368e9b8e16f5 #\n      0x349524ca4e82400cbde0686d403371c9\n  , HMAC_SHA_384_192 =\n      0x2c7353974f1842fd66d53c452ca42122 #\n      0xb28c0b594cfb184d\n  }\n\nproperty rfc_4868_2_7_2_2_3 = sha2_384_auth_test\n  { Key = repeat`{48} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_384 =\n      0x809f439be00274321d4a538652164b53 #\n      0x554a508184a0c3160353e3428597003d #\n      0x35914a18770f9443987054944b7c4b4a\n  , HMAC_SHA_384_192 =\n      0x809f439be00274321d4a538652164b53 #\n      0x554a508184a0c316\n  }\n\nproperty rfc_4868_2_7_2_2_4 = sha2_384_auth_test\n  { Key =\n      split 0x0102030405060708090a0b0c0d0e0f10 #\n      split 0x1112131415161718191a1b1c1d1e1f20 #\n      split 0x0a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_384 =\n      0x5b540085c6e6358096532b2493609ed1 #\n      0xcb298f774f87bb5c2ebf182c83cc7428 #\n      0x707fb92eab2536a5812258228bc96687\n  , HMAC_SHA_384_192 =\n      0x5b540085c6e6358096532b2493609ed1 #\n      0xcb298f774f87bb5c\n  }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA512 that instantiates the generic HMAC specification with SHA-512. Inside the module: - import Primitive::Keyless::Hash::SHA2::Instantiations::SHA512 to access the SHA-512 byte-oriented hash function, - define the type alias B as 128 to represent the SHA-512 block size in bytes, - define the type alias L as 64 to represent the SHA-512 digest size in bytes, - define H to refer to the hashBytes function from the imported SHA-512 instantiation. The module should be declared as an instance of the HMAC specification using these parameters so that all HMAC operations are specialized to SHA-512."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA512 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA2::Instantiations::SHA512\n  type B = 128\n  type L = 64\n  H = hashBytes\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA1 that instantiates the generic HMAC specification by supplying SHA-1 parameters and hash function. Within the where-block, include the following definitions: (1) import the SHA-1 hash specification module under a short alias; (2) a type synonym B representing the SHA-1 block size in bytes with numeric value 64; (3) a type synonym L representing the SHA-1 output length in bytes with numeric value 20; (4) a function H that takes a sequence of bytes of arbitrary length and returns an L-byte digest by delegating to the SHA-1 bytes-to-digest function from the imported module. Provide a type signature for H that maps any-length byte sequences to L-byte results, and ensure B and L are numeric type synonyms (not value-level constants). The module must equal the generic HMAC specification and use these definitions to produce the concrete HMAC-SHA1 instantiation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA1 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA1::Specification as SHA1\n  type B = 64\n  type L = 20\n  H text = SHA1::hashBytes text\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA256 that instantiates the generic HMAC specification module Primitive::Symmetric::MAC::HMAC::Specification. Inside this module: import the SHA-256 instantiation from Primitive::Keyless::Hash::SHA2::Instantiations::SHA256; define type synonyms B and L as type-level naturals representing the SHA-256 block size (64 bytes) and digest length (32 bytes), respectively; and define a top-level binding H that refers to the byte-oriented SHA-256 hash function from the imported module. Specify in plain language that H takes a finite sequence of bytes (8-bit words) and returns a digest of length L bytes, and that B and L satisfy the HMAC specification\u2019s expected parameters for block size and output size. The module should solely provide these bindings to instantiate the specification; no additional logic is required."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA256 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256\n  type B = 64\n  type L = 32\n  H = hashBytes\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA384 that instantiates the generic HMAC specification using SHA-384. Inside this module: import the SHA-384 hash instantiation; declare type alias B as 128 to represent the hash block size in bytes; declare type alias L as 48 to represent the digest length in bytes; and bind H to the byte-oriented SHA-384 hash function exported by the imported module. Ensure the resulting module exposes the HMAC interface defined by the generic specification with these parameters."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA384 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA2::Instantiations::SHA384\n  type B = 128\n  type L = 48\n  H = hashBytes\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/FNV.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Keyless::Hash::FNV that contains the following definitions: (1) A function fnv1a with a polymorphic type over any finite bit-length n, taking an n-bit sequence and returning a 64-bit word; it pads the input to whole bytes and delegates to a byte-wise worker. (2) A function pad, polymorphic over any finite message length, that appends zero bits on the right to reach a multiple of 8 and then splits the result into a sequence of 8-bit chunks; its result length is the ceiling of the bit-length divided by 8. (3) A function fnv1a' over any finite number of byte chunks that consumes a sequence of bytes and returns a 64-bit word by initializing with the standard 64-bit FNV-1a offset basis, then iteratively applying the block transformation per byte, and finally selecting the last state. (4) A function block with a type-level equality constraint ensuring the zero-extension width equals 56 (i.e., 64 \u2212 8); it takes a 64-bit state and an 8-bit value, XORs the state with the zero-extended byte, and multiplies by the standard 64-bit FNV-1a prime modulo 2^64. (5) Constants fnv1a_offset_basis and fnv1a_prime, both 64-bit words, set to the standard FNV-1a 64-bit offset basis and prime, respectively. (6) Boolean constants t1, t2, t3 that assert the fnv1a result matches the known 64-bit FNV-1a hashes for the empty input, for the ASCII byte \u2018a\u2019, and for the ASCII string \"foobar\", respectively. (7) Define a property testsPass that is the conjunction of t1, t2, and t3. Include precise type signatures with fin constraints where needed and ensure all definitions compose correctly."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::FNV where\n\nfnv1a : {n} (fin n) => [n] -> [64]\nfnv1a ws = fnv1a' (pad ws)\n\npad : {msgLen} (fin msgLen) => [msgLen] -> [msgLen \/^ 8][8]\npad msg = split (msg # (zero:[msgLen %^ 8]))\n\nfnv1a' : {chunks} (fin chunks) => [chunks][8] -> [64]\nfnv1a' msg = Ss ! 0\n  where\n   Ss = [fnv1a_offset_basis] #\n           [ block s m\n           | s <- Ss\n           | m <- msg\n           ]\n\nblock : {padLen} ( padLen == 64 - 8) => [64] -> [8] -> [64]\nblock state val = (state ^ ((zero : [padLen]) # val)) * fnv1a_prime\n\nfnv1a_offset_basis : [64]\nfnv1a_offset_basis = 14695981039346656037\n\nfnv1a_prime : [64]\nfnv1a_prime = 1099511628211\n\nt1 = fnv1a [] == 0xcbf29ce484222325\nt2 = fnv1a (join \"a\") == 0xaf63dc4c8601ec8c\nt3 = fnv1a (join \"foobar\") == 0x85944171f73967e8\n\nproperty testsPass = and [t1, t2, t3]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/HashInterface.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an interface module named Primitive::Keyless::Hash::HashInterface that contains the following declarations: (1) three type-level numeric parameters (kind #) named MessageUpperBound, DigestLength, and SecurityStrength; and (2) a type signature for a keyless hash function named hash. The hash signature must be polymorphic over a message-length parameter m, require that m is finite and that the bit-width needed to represent m is strictly less than MessageUpperBound, and specify that the function maps an m-bit message to a DigestLength-bit digest. Provide only kinds and the function signature with its constraints; do not implement any bodies. Use correct Cryptol syntax and ensure all constraints are explicit."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Keyless::Hash::HashInterface where\n\n    type MessageUpperBound : #\n\n    type DigestLength : #\n\n    type SecurityStrength : #\n\n    hash: {m} (fin m, width m < MessageUpperBound) => [m] -> [DigestLength]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/Blake2b.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::Blake2b that contains the following definitions: type synonyms for a 16-word 64-bit message block, an 8-word 64-bit chaining state, a 16-word 64-bit local state, a 128-bit counter, and a context record holding state and counter; constants for a 128-bit value equal to 128, the BLAKE2b IV (eight 64-bit words), the 12-round sigma permutation table selecting message word indices, and four right-rotation amounts (32, 24, 16, 63). Provide functions with explicit type signatures: a quarter-round core that updates four selected words of the local state using two message words chosen via the sigma table for a given round and column, applying the BLAKE2b add\/xor\/rotate sequence; a helper that extracts the selected words, applies the quarter-round, and writes back; a round function that performs eight applications of the core using the column and diagonal index patterns; a compression function that builds a 16-word working vector from the chaining value, IV, 128-bit counter split into two 64-bit words, and a mask derived from a boolean finalization flag, runs 12 rounds, and returns the new chaining state as the XOR of the original state with the upper and lower halves of the final working vector; an update that increments the counter by one block (128 bytes) and compresses; a finish that compresses the final block with the finalization flag set and outputs the 512-bit digest after byte-order conversion; a top-level hash function that accepts ll bytes, with constraints that ll and dd are finite, dd = max(1, (ll+127)\/128) \u2212 1, and width(ll) \u2264 128, processes dd full blocks plus one final padded block, and returns a 512-bit digest; and byte\/word helpers for splitting, joining, and reversing to implement little-endian behavior. Also define boolean tests for known-answer vectors (zero-length, 128-byte zeros, 129-byte zeros, and the standard pangram) and a property katsPass that is the conjunction of these tests."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::Blake2b where\n\ntype Block   = [16][64]\ntype State   = [8][64]\ntype LocalState = [16][64]\ntype Counter = [128]\n\ntype Context = { state : State, counter : Counter }\n\nbbVal : [128]\nbbVal = 128\n\nIV : [8][64]\nIV = [ 0x6A09E667F3BCC908, 0xBB67AE8584CAA73B,\n       0x3C6EF372FE94F82B, 0xA54FF53A5F1D36F1,\n       0x510E527FADE682D1, 0x9B05688C2B3E6C1F,\n       0x1F83D9ABFB41BD6B, 0x5BE0CD19137E2179\n     ]\n\nSIGMA_TABLE : [12][16][4]\nSIGMA_TABLE =\n    [  [  0, 1,   2, 3,   4, 5,   6, 7,   8, 9,  10, 11, 12, 13, 14, 15 ]\n    ,  [ 14, 10,  4, 8,   9, 15, 13, 6,   1, 12,  0, 2,  11, 7,   5, 3  ]\n    ,  [ 11, 8,  12, 0,   5, 2,  15, 13, 10, 14,  3, 6,   7, 1,   9, 4  ]\n    ,  [  7, 9,   3, 1,  13, 12, 11, 14,  2, 6,   5, 10,  4, 0,  15, 8  ]\n    ,  [  9, 0,   5, 7,   2, 4,  10, 15, 14, 1,  11, 12,  6, 8,   3, 13 ]\n    ,  [  2, 12,  6, 10,  0, 11,  8, 3,   4, 13,  7, 5,  15, 14,  1, 9  ]\n    ,  [ 12, 5,   1, 15, 14, 13,  4, 10,  0, 7,   6, 3,   9, 2,   8, 11 ]\n    ,  [ 13, 11,  7, 14, 12, 1,   3, 9,   5, 0,  15, 4,   8, 6,   2, 10 ]\n    ,  [  6, 15, 14, 9,  11, 3,   0, 8,  12, 2,  13, 7,   1, 4,  10, 5  ]\n    ,  [ 10, 2,   8, 4,   7, 6,   1, 5,  15, 11,  9, 14,  3, 12, 13, 0  ]\n    ,  [  0, 1,   2, 3,   4, 5,   6, 7,   8, 9,  10, 11, 12, 13, 14, 15 ]\n    ,  [ 14, 10,  4, 8,   9, 15, 13, 6,   1, 12,  0, 2,  11, 7,   5, 3  ]\n    ]\n\nR1,R2,R3,R4 : [6]\nR1 = 32\nR2 = 24\nR3 = 16\nR4 = 63\n\nG : [4] -> [4] -> LocalState -> [4][6] -> Block -> [16][64]\nG r i vec abcd ms = updates vec abcd new\n  where\n  new  = G' r i (vec @@ abcd) ms\n\nG' : [4] -> [4] -> [4][64] -> Block -> [4][64]\nG' r i vals ms = [a2, b2, c2, d2]\n  where\n  x = ms @ (SIGMA_TABLE @ r @ (2*i))\n  y = ms @ (SIGMA_TABLE @ r @ (2*i+1))\n  [a,b,c,d] = vals\n  a1 =  a + b + x\n  d1 = (d ^ a1) >>> R1\n  c1 =  c + d1\n  b1 = (b ^ c1) >>> R2\n  a2 =  a1 + b1 + y\n  d2 = (d1 ^ a2) >>> R3\n  c2 =  c1 + d2\n  b2 = (b1 ^ c2) >>> R4\n\n\/\/ Section 3.2: Compression function\nF : State -> Block -> Counter -> Bit -> State\nF h ms t f =  h ^ (take (vs!0)) ^ (drop (vs!0))\n where\n  v   = h # IV ^ (zero # [t0,t1,f0,zero])\n  [t1,t0] = split t : [2][64]\n  f0 = [f | _ <- [0..63] : [_][6]]\n  vs = [v] # [ round i ms v' | v' <- vs | i <- [0..11] ]\n\n\/\/ Sub-function of F (first for loop)\nround : [4] -> Block -> LocalState -> LocalState\nround r ms v = vs ! 0\n  where\n  vs = [v] # [ G r i v' ix ms\n                | v'   <- vs\n                | i    <- [0..7]\n                | ix   <- [ [0,4,8,12],  [1,5,9,13]\n                          , [2,6,10,14], [3,7,11,15]\n                          , [0,5,10,15], [1,6,11,12]\n                          , [2,7,8,13],  [3,4,9,14] ]\n              ]\n \/\/ ix (ms @ (s @ sIx1)) (ms @ (s @ sIx2))\n \/\/               | sIx1 <- [0,2,4,6,8,10,12,14] : [8][4]\n \/\/               | sIx2 <- [1,3,5,7,9,11,13,15] : [8][4]\n \/\/             ]\n\n\/\/ Section 3.3: Padding\n\/\/ Recall kk == key bytes  (0)\n\/\/        nn == hash bytes (64)\n\/\/        ll == input bytes (ceiling $ len \/ 8)\n\/\/        bb == block bytes (128, 1024 bits)\n\/\/        dd == nr Blocks\n\nblake2b : {ll,dd}\n         (fin ll, fin dd\n         , dd == (max 1 ((ll+127)\/128)) - 1\n         \/\/ ^^^ ugly  We'd like , dd == (ll-1)\/128  but then we can't hash the empty string\n         , 128 >= width ll\n         )\n          => [ll][8]\n          -> [512]\nblake2b m = blake2Finish ({ state = (hs!0).state, counter = `ll}) lastBlock\n where\n\n fullBlocks : [dd]Block\n fullBlocks = [mkBlock b | b <- split (take (join m))]\n\n partialBlock = drop `{128*dd} m\n\n lastBlock : Block\n lastBlock  =\n    if (`ll == (zero:[128]))\n        then zero \/\/ Special case full zero block for empty messages\n        else mkBlock ((split (join (partialBlock # (zero : [inf][8]))))@0)\n\n h : Context\n h  = { state = [IV@0 ^ `0x01010040] # drop `{1} IV, counter = 0 }\n\n hs : [dd+1]Context\n hs = [h] # [blake2Update h' dX |  h' <- hs | dX <- fullBlocks]\n\nblake2Update : Context -> Block -> Context\nblake2Update ctx d = { state = newState, counter = newCount }\n  where newState = F ctx.state d newCount False\n        newCount = ctx.counter + (128 : [128])\n\npostprocess : {ll} (128 >= ll, 128 >= width ll) => Counter -> [ll][8] -> Block\npostprocess c m =\n    if c == 0 \/\\ `ll == (zero:[128])\n        then zero\n        else split (join m # zero)\n\n\/\/ The final round of blake\nblake2Finish : Context -> Block -> [512]\n\/\/ blake2Finish ctx b = ctx.state@0 # zero\nblake2Finish ctx b = join [ reverseBytes w | w <- F ctx.state b ctx.counter True ]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/  Utilities\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nmkBlock x = reverse (split (reverseBytes x))\n\nreverseBytes x = join (reverse (bytes x))\n\nbytes x = split x : [_] [8]\n\ntestZeros =\n  and [ blake2b (zero : [128][8]) == 0x865939e120e6805438478841afb739ae4250cf372653078a065cdcfffca4caf798e6d462b65d658fc165782640eded70963449ae1500fb0f24981d7727e22c41\n      , blake2b (zero : [0][8]) == 0x786A02F742015903C6C6FD852552D272912F4740E15847618A86E217F71F5419D25E1031AFEE585313896444934EB04B903A685B1448B755D56F701AFE9BE2CE ]\n\ntestZerosLarge =\n  and [ blake2b (zero : [129][8]) == 0xa60edba343e7a6933c14d203d2e535f35e6deb6c8a4f8e624c1a6f6e2612860447cb4c37e5aa11bcf03b7c3eea7228eb8b998f922794f2d1b8f2dc63f03bd3fa\n      ]\n\ntestKATs =\n  and [ blake2b \"The quick brown fox jumps over the lazy dog\" == 0xA8ADD4BDDDFD93E4877D2746E62817B116364A1FA7BC148D95090BC7333B3673F82401CF7AA2E4CB1ECD90296E3F14CB5413F8ED77BE73045B13914CDCD6A918\n      ]\n\nproperty katsPass = and [ testZeros, testZerosLarge, testKATs ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Generator\/DRBG.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Generator::DRBG that contains the following: (1) an import of the AES-256 block-cipher instantiation to access an encrypt operation; (2) type synonyms for key length (equal to the AES-256 key size), block length (128), seed length (384), reseed limit (2^35), and corresponding byte sizes for block, key, and seed; (3) a cipher context record holding a key bitvector of key length; (4) a DRBG state record with a 64-bit byte counter, the cipher context, and an internal value of block length; (5) a block encryption function that takes a key-length bitvector and a block-length bitvector and returns the AES-256 encryption of the block under the key; (6) a generate-internal function with size parameters n and blocks, constrained to be finite, with 1 \u2264 n \u2264 8192 and n equal to blocks times the block length. It should produce n output bits by encrypting consecutive counter values (internal value plus 1..blocks), concatenating the blocks, and updating the state by adding blocks to the internal value and adding blocks times the block byte size to the byte counter; (7) an instantiate function that pads or truncates a personalization string to the seed length and reseeds from an all-zero initial state with provided entropy and the processed personalization; (8) a reseed function that XORs entropy with the personalization (padded with zeros), updates the state via the update function, and resets the byte counter; (9) an uninstantiate function that returns the all-zero state; (10) a generate function with size constraints relating n and blocks that optionally reseeds based on an external flag or when a byte\/bit threshold meets or exceeds the reseed limit, then produces n bits and updates the state via the update function with zero data; (11) an update function that generates enough blocks to cover the seed length, XORs them with provided data, sets the key to the first seed-length\/key-size portion, the internal value to the remainder, and increments the byte counter accordingly; (12) test vectors and boolean checks validating instantiation, reseed, and two generate calls; (13) define a property testsPass that is the conjunction of all test checks."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Generator::DRBG where\n\nimport Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256 as AES256\n\ntype keylen   = AES256::KeySize type blocklen = 128 type seedlen  = 384 type reseed_limit = 2 ^^ 35 \ntype blocksize = 16 type keysize = 32 type seedsize = 48\n\ntype cipher_ctx = { key : [keylen] }\n\nblock_encrypt : [keylen] -> [blocklen] -> [blocklen]\nblock_encrypt key data = AES256::encrypt key data\n\ntype s2n_drbg =\n  { bytes_used : [64]\n  , ctx : cipher_ctx\n  , v : [blocklen]\n  }\n\ndrbg_generate_internal : {n, blocks}\n                         ( fin n, fin blocks, n >= 1, n <= 8192\n                         , n == blocklen * blocks)\n                      => s2n_drbg\n                      -> ([n], s2n_drbg)\ndrbg_generate_internal drbg =\n  (join [ block_encrypt drbg.ctx.key (drbg.v + i) | i <- [1 .. blocks]], drbg')\n    where drbg' = { bytes_used = drbg.bytes_used + `(blocks * blocksize)\n                  , ctx = drbg.ctx\n                  , v = drbg.v + `blocks\n                  }\n\ndrbg_instantiate : {ps_size}\n                   (fin ps_size)\n                => [seedlen]\n                -> [ps_size]\n                -> s2n_drbg\ndrbg_instantiate entropy ps = drbg_reseed zero entropy ps'\n  where\n    \/* pad ps with zeros if needed to reach seedlen\n       otherwise truncate to seedlen *\/\n    ps' = take `{seedlen} (ps # (zero : [seedlen]))\n\ndrbg_reseed : {ps_size}\n              (ps_size <= seedlen)\n           => s2n_drbg\n           -> [seedlen]\n           -> [ps_size]\n\t   -> s2n_drbg\ndrbg_reseed drbg entropy ps = drbg''\n  where\n    drbg' = drbg_update (entropy ^ (ps # zero)) drbg\n    drbg'' = { v = drbg'.v, ctx = drbg'.ctx, bytes_used = 0}\n\ndrbg_uninstantiate : s2n_drbg -> s2n_drbg\ndrbg_uninstantiate drbg = zero\n\n\/* This is the spec of the s2n code, in that it reseeds automatically\n   if reseed is required. This is in opposition to the spec, which\n   requires an error code.\n\n   We are curious about why s2n_drbg counts a number of bytes used,\n   while the spec tracks a number of calls to generate. We don't\n   belive that this is buggy behavior, since if we call the maximum\n   size with generate each time, we will reseed before the spec would\n   require it. *\/\ndrbg_generate : {n, blocks} (fin n, fin blocks, n >= 1, n <= 8192,\n                             blocks * blocklen >= n,\n                             (blocks - 1) * blocklen <= n - 1) =>\n                s2n_drbg -> [seedlen] -> Bit ->\n                ([n], s2n_drbg)\ndrbg_generate drbg entropy reseed_p = (take enc_result, drbg_out)\n  where\n        drbg_r =\n      if reseed_p \\\/ drbg.bytes_used + `n * 8 + `blocklen * 8 >= `reseed_limit then\n        drbg_reseed drbg entropy (zero : [256])\n      else drbg\n        (enc_result, drbg_v) = drbg_generate_internal `{blocks=blocks} drbg_r\n        drbg_out = drbg_update zero drbg_v\n\ndrbg_update : [seedlen] -> s2n_drbg -> s2n_drbg\ndrbg_update data drbg = result\n  where\n            type blocks = (seedlen + blocklen -1)\/blocklen\n        (enc_result, _) = drbg_generate_internal `{blocks=blocks} drbg\n        data_xor = (take enc_result) ^ data\n            result = { bytes_used = drbg.bytes_used + (`blocks * `blocksize)\n             , ctx = { key = take data_xor }\n             , v = drop data_xor\n             }\n\ntestInstantiate0 = {entropy = 0xe4bc23c5089a19d86f4119cb3fa08c0a4991e0a1def17e101e4c14d9c323460a7c2fb58e0b086c6c57b55f56cae25bad,\n                    pString = zero : [0],\n                        Key = 0xb7b3a93ecfdf2f61c622ad3afb6bff818736a09c9391157e1902d10a79d0db12,\n                               V = 0x0e4fb6443cae46188617aad8bfe46e23}\n\ntestInstantiatedrbg0 = drbg_instantiate`{ps_size=0} testInstantiate0.entropy testInstantiate0.pString\n\ntestInstantiate0Pass = testInstantiatedrbg0.v == testInstantiate0.V \/\\ testInstantiatedrbg0.ctx.key == testInstantiate0.Key\n\ntestReseed0 = {entropyReseed = 0xfd85a836bba85019881e8c6bad23c9061adc75477659acaea8e4a01dfe07a1832dad1c136f59d70f8653a5dc118663d6,\n                          Key = 0xd230044c2594510d195ffe9923de8848bdbd19f24d0e7558b28e55b2d4de7841,\n                                V = 0xe18637ff12f514f37adc2013a40f38c1}\n\ntestReseed0Pass = drbgreseed.v == testReseed0.V \/\\ drbgreseed.ctx.key == testReseed0.Key\n                where drbgreseed = drbg_reseed`{ps_size=0} testInstantiatedrbg0 testReseed0.entropyReseed zero\n\ntestGenerate0 = {      Key = 0xec871bb7a4f2c45dccdd0e514a21628959aa21e9643934f619b2709b3e38697c,\n                       V   = 0xd8bbe7bfc60bfb710f39acd1088c9f41}\n\ntestGeneratedrbg0 = (drbg_generate`{n=512} testInstantiatedrbg0 testReseed0.entropyReseed True).1\n\ntestGenerate0Pass = testGeneratedrbg0.v == testGenerate0.V \ntestGenerateSnd0 = {returnedBits = 0xb2cb8905c05e5950ca31895096be29ea3d5a3b82b269495554eb80fe07de43e193b9e7c3ece73b80e062b1c1f68202fbb1c52a040ea2478864295282234aaada,\n                       Key = 0xe728308a0e92cbacb269d12246d8e2d24cf5fcc678aa09564132e4972c456eda,\n                       V   = 0xc95f38da34ecb65ebf8b34c32bc215a5}\n\ntestGenerateSnd0Pass = and [ result == testGenerateSnd0.returnedBits\n                           , drbg.ctx.key == testGenerateSnd0.Key\n                           , drbg.v == testGenerateSnd0.V ]\n                     where (result,drbg) = drbg_generate`{n=512} testGeneratedrbg0 zero False\n\nproperty testsPass = and [testInstantiate0Pass, testReseed0Pass, testGenerate0Pass, testGenerateSnd0Pass]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains the following definitions: (1) type parameters for a word size and a digest size, constrained so the word size is either 32 or 64 and a multiple of 32, and the digest size is a multiple of 8 and no larger than the bit-width of eight words; a parameter for the initial chaining value as eight words. (2) type synonyms for a message length upper bound (twice the word size), a predicate restricting valid message lengths by bit-width, digest length equal to the digest size, and security strength equal to half the digest size. (3) internal type synonyms for block size (sixteen words), schedule length (48 plus half the word size), and length-field width (twice the word size), as well as a type-level function computing the number of blocks as the ceiling division of length+1+length-field by the block size. (4) left-rotate, right-rotate, and logical right-shift functions over words, each parameterized by a compile-time shift less than the word size. (5) a property that for all shifts less than the word size, left rotation by n equals right rotation by the complement shift modulo the word size, and vice versa. (6) properties that sanity-check hex-to-binary literal equality for small digits, for representative 32-bit and 64-bit words, and that an integer literal equals its zero-padded hexadecimal form. (7) the SHA-2 boolean functions (choose and majority). (8) the four SHA-2 sigma functions, where the rotation\/shift amounts depend on the word size. (9) the table of round constants sized to the schedule length, selecting the appropriate list for the chosen word size. (10) a padding function implementing SHA-2 padding (message, then a single \u20181\u2019 bit, zeros, then the length-field), with a property that a short 3-byte ASCII message pads to the expected bitstring for both word sizes. (11) a block parser that splits a bitvector into equal-sized blocks. (12) the message schedule expansion from 16 input words to the schedule length using the small sigmas. (13) a round step that updates eight working variables using T1\/T2, the big sigmas, the boolean functions, a schedule word, and a round constant. (14) the hash function that iterates over all blocks and rounds, updates the chaining value, and outputs the digest truncated to the digest size. (15) a byte-oriented wrapper that produces the digest as an array of bytes."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Specification where\n\nparameter\n\n    type w : #\n    type constraint (w % 32 == 0, 32 <= w, 64 >= w)\n\n    type DigestSize : #\n    type constraint (8 * w >= DigestSize, DigestSize % 8 == 0)\n\n    H0 : [8][w]\n\ntype MessageUpperBound = 2 * w\ntype constraint ValidMessageLength L = width L <= MessageUpperBound\n\ntype DigestLength = DigestSize\n\ntype SecurityStrength = DigestSize \/ 2\n\nprivate\n\n    type BlockSize = 16 * w\n\n    type ScheduleLength = 48 + w \/ 2\n\n    ROTL : {n} (n < w) => [w] -> [w]\n    ROTL x = x <<< `n\n\n    ROTR : {n} (n < w) => [w] -> [w]\n    ROTR x = x >>> `n\n\n    rotationEquivalenceRelationsHold : {n} (n < w) => [w] -> Bool\n    property rotationEquivalenceRelationsHold x = left && right where\n        left = ROTL`{n} x == ROTR`{(w - n) % w} x\n        right = ROTR`{n} x == ROTL`{(w - n) % w} x\n\n    SHR : {n} (n < w) => [w] -> [w]\n    SHR x = x >> `n\n\n    property hexDigitsEncodeCorrectly = (0x7 == 0b0111) && (0xa == 0b1010)\n\n    property wordsEncodeCorrectly = short && long where\n        short = 0xa103fe23 == 0b10100001000000111111111000100011\n        long = 0xa103fe2332ef301a == 0b1010000100000011111111100010001100110010111011110011000000011010\n\n    property integersEncodeCorrectly = 291 == 0x00000123\n\n    Ch : [w] -> [w] -> [w] -> [w]\n    Ch x y z = (x && y) ^ (~x && z)\n\n    Maj : [w] -> [w] -> [w] -> [w]\n    Maj x y z = (x && y) ^ (x && z) ^ (y && z)\n\n    Sigma0: [w] -> [w]\n    Sigma0 x\n        | w == 32 => ROTR`{ 2} x ^ ROTR`{13} x ^ ROTR`{22} x\n        | w == 64 => ROTR`{28} x ^ ROTR`{34} x ^ ROTR`{39} x\n\n    Sigma1: [w] -> [w]\n    Sigma1 x\n        | w == 32 => ROTR`{ 6} x ^ ROTR`{11} x ^ ROTR`{25} x\n        | w == 64 => ROTR`{14} x ^ ROTR`{18} x ^ ROTR`{41} x\n\n    sigma0: [w] -> [w]\n    sigma0 x\n        | w == 32 => ROTR`{7} x ^ ROTR`{18} x ^ SHR`{3} x\n        | w == 64 => ROTR`{1} x ^ ROTR`{ 8} x ^ SHR`{7} x\n\n    sigma1: [w] -> [w]\n    sigma1 x\n        | w == 32 => ROTR`{17} x ^ ROTR`{19} x ^ SHR`{10} x\n        | w == 64 => ROTR`{19} x ^ ROTR`{61} x ^ SHR`{ 6} x\n\n    K : [ScheduleLength][w]\n    K | w == 32 => [\n        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]\n      | w == 64 => [\n        0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n        0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n        0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n        0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n        0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n        0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n        0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n        0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n        0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n        0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n        0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n        0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n        0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n        0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n        0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n        0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n        0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n        0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n        0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n        0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817]\n\n    type LengthBits = 2 * w\n\n    type NumBlocks L = (L + 1 + LengthBits) \/^ BlockSize\n\n    pad : {L} (ValidMessageLength L) => [L] -> [NumBlocks L * BlockSize]\n    pad M = M # 0b1 # zero # (`L : [LengthBits])\n\n    paddingExampleWorks : Bool\n    paddingExampleWorks\n        | w == 32 => pad (join \"abc\") == (0b01100001 # 0b01100010 # 0b01100011\n            # 0b1 # (zero : [423]) # (zero : [59]) # 0b11000)\n        | w == 64 => pad (join \"abc\") == (0b01100001 # 0b01100010 # 0b01100011\n            # 0b1 # (zero : [871]) # (zero : [123]) # 0b11000)\n\n    parse : {N} () => [N * BlockSize] -> [N][BlockSize]\n    parse M = split M\n\nhash: {l} (ValidMessageLength l) => [l] -> [DigestSize]\nhash M = take (join (digest ! 0)) where\n    digest = [H0] # [Hi'\n        where\n            \/\/ Step 1. Prepare the message schedule.\n            Ws = messageSchedule (split Mi)\n\n            \/\/ Step 2. Initialize the eight working variables with the\n            \/\/ previous hash value.\n            letters = [(Hi0, Hi1, Hi2, Hi3, Hi4, Hi5, Hi6, Hi7)] # [\n                \/\/ Step 3. Update temporary and working variables...\n                variableUpdate l Kt Wt\n                | l <- letters\n\n                \/\/ ...for t=0 to `ScheduleLength`.\n                | Wt <- Ws\n                | Kt <- K\n            ]\n            (a, b, c, d, e, f, g, h) = letters ! 0\n\n            \/\/ Step 4. Compute the next intermediate hash value.\n            \/\/ Note that in the spec, this is denoted H^(i).\n            Hi' = [a + Hi0, b + Hi1, c + Hi2, d + Hi3, e + Hi4, f + Hi5, g + Hi6, h + Hi7]\n\n                | Mi <- parse (pad M)\n\n                        | [Hi0, Hi1, Hi2, Hi3, Hi4, Hi5, Hi6, Hi7] <- digest\n    ]\n\n        messageSchedule : [16][w] -> [ScheduleLength][w]\n    messageSchedule Mi = take W where\n        W : [inf][w]\n        W = Mi # [ sigma1 w2 + w7 + sigma0 w15 + w16\n                                                | w16 <- W\n            | w15 <- drop`{1} W\n            | w7  <- drop`{9} W\n            | w2  <- drop`{14} W\n        ]\n\n        type LetterVars = ([w], [w], [w], [w], [w], [w], [w], [w])\n\n        variableUpdate : LetterVars -> [w] -> [w] -> LetterVars\n    variableUpdate (a, b, c, d, e, f, g, h) Kt Wt =\n        (a', b', c', d', e', f', g', h')\n        where\n            T1 = h + Sigma1 e + Ch e f g + Kt + Wt\n            T2 = Sigma0 a + Maj a b c\n            h' = g\n            g' = f\n            f' = e\n            e' = d + T1\n            d' = c\n            c' = b\n            b' = a\n            a' = T1 + T2\n\nhashBytes: {l} (ValidMessageLength (8 * l)) => [l][8] -> [DigestSize \/ 8][8]\nhashBytes M = groupBy`{8} (hash (join M))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/KeccakBitOrdering.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Keyless::Hash::SHA3::KeccakBitOrdering that contains the following definitions and checks:\n- Type\/constant: a type alias for a hex digit width equal to four bits.\n- Function toBytes: for any finite n, convert a contiguous vector of 8\u00b7n bits into an array of n bytes, ordering bytes to match Keccak\u2019s bit-ordering convention (use reversals to align grouping).\n- Function fromBytes: the inverse transformation of toBytes, flattening n bytes into 8\u00b7n bits with the same ordering convention.\n- Function reverseBitOrdering: for width m, reverse the bit order within each full 8-bit group; for finite m also handle any remaining non-byte-aligned tail by reversing the tail bits; support infinite widths by grouping in 8-bit chunks. Return the same-width bitvector.\n- Property reverseBitOrderingInvolutes: for finite m, applying the above reversal twice yields the original value.\n- Function truncate: for finite m,n with m \u2265 n and m a multiple of a byte, produce the first n bits under Keccak\u2019s bit-ordering (implement via bit-order reversal, take, and reverse back).\n- Property reverseMatchesh2b: for m > 0, full-length hex-to-bits conversion equals reverseBitOrdering.\n- Property truncateAndReverseMatchesh2b: for m > 0 and n > 0 with n \u2264 8\u00b7m, hex-to-bits truncated to n equals reverseBitOrdering after truncation to n.\n- Function reverseMatchesb2h: for n > 0, return a Boolean that checks bit-to-hex conversion equals reverseBitOrdering.\n- Property reverseAndTruncateMatchesb2h: for n > 0, truncating the bit-to-hex result equals reverseBitOrdering of the input bits.\n- Function h2b: for m > 0 and 0 < n \u2264 8\u00b7m, convert 2\u00b7m hex digits (as bits) to n bits by pairing nibbles into bytes, reversing within bytes, joining, and taking n.\n- Property h2bExampleWorks: a concrete example showing h2b produces the expected bit pattern.\n- Function b2h: for n > 0, pad with zeros to a byte boundary, group into bytes, reverse within bytes, split into nibbles, and output 2\u00b7\u230an\/8\u230b hex digits (as bits).\n- Property zero_length_is_correct: verify the modular arithmetic identity for the padding length.\n- Property h2bAndb2hInvert: for m > 0, b2h composed with full-length h2b yields the original hex bits.\n- Property h2bAndb2hInvertForShortStrings: when the hex-digit count matches m, composing b2h after h2b at length n yields the original normalized hex bits (constructed by per-byte bit reversal and appending one zero bit).\n- Property b2hAndh2bInvert: for n > 0, h2b composed with b2h yields the original bits."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::KeccakBitOrdering where\n\ntoBytes : {n} (fin n) => [8*n] -> [n][8]\ntoBytes s = reverse (split (reverse s))\n\nfromBytes : {n} (fin n) => [n][8] -> [8*n]\nfromBytes bs = reverse (join (reverse bs))\n\nreverseBitOrdering : {m} [m] -> [m]\nreverseBitOrdering msg\n    | m == inf => join (map reverse (groupBy`{8} msg))\n    | fin m => (flipped_full_bytes # flipped_remainder) where\n                        type Bytes = 8 * (m \/ 8)\n        flipped_full_bytes = join (map reverse (groupBy`{each=8, parts=m \/ 8} (take`{Bytes} msg)))\n        flipped_remainder = reverse (drop`{Bytes} msg)\n\nreverseBitOrderingInvolutes : {m} (fin m) => [m] -> Bit\nproperty reverseBitOrderingInvolutes msg = reReverse == msg where\n    reReverse = reverseBitOrdering (reverseBitOrdering msg)\n\ntruncate : {n, m} (fin m, fin n, m >= n, m % (2 * HexDigit) == 0) => [m] -> [n]\ntruncate msg = reverseBitOrdering (take (reverseBitOrdering msg))\n\nreverseMatchesh2b : {m} (fin m, m > 0) => [2 * m * HexDigit] -> Bool\nproperty reverseMatchesh2b msg = h2b msg == reverseBitOrdering msg\n\ntruncateAndReverseMatchesh2b : {m, n} (fin m, m > 0, n > 0, 2 * HexDigit * m >= n) => [2 * m * HexDigit] -> Bool\nproperty truncateAndReverseMatchesh2b msg = h2b_result == rt_result where\n    h2b_result = h2b`{n} msg\n    rt_result = reverseBitOrdering (truncate`{n} msg)\n\nreverseMatchesb2h : {n} (fin n, n > 0) => [2 * n * HexDigit] -> Bool\nreverseMatchesb2h msg = b2h msg == reverseBitOrdering msg\n\nreverseAndTruncateMatchesb2h : {n} (fin n, n > 0) => [n] -> Bool\nproperty reverseAndTruncateMatchesb2h bits = b2h_result == rev_result where\n    b2h_result = truncate`{n} (b2h bits)\n    rev_result = reverseBitOrdering bits\n\ntype HexDigit = 4\n\nh2b: {n, m} (fin m, m > 0, n > 0, n <= 8 * m) => [2 * m * HexDigit] -> [n]\nh2b msg = S where\n        H = groupBy`{HexDigit} msg\n            H8 = map zext H : [2 * m][8]\n        hs = [16 * H8 @ (2 * i) + H8 @ (2 * i + 1) | i <- [0..m-1]]\n            bs = map reverse hs\n        T = join bs\n        S = take`{n} T\n\nproperty h2bExampleWorks = h2b`{14} H == S where\n    H = 0xA32E\n    S = 0b11000101011101\n\nb2h : {n} (fin n, n > 0) => [n] -> [2 * (n \/^ 8) * HexDigit]\nb2h S = H where\n            T = S # (zero : [(8 - (n % 8)) % 8])     type m = n \/^ 8\n        b = [[ T@(8 * i + j) | j <- [0..7]] | i <- [0..m-1]]\n        h = [reverse bs | bs <- b]\n        Hs = [split`{2, HexDigit} hi | hi <- h]\n    H = join (join Hs)\n\nzero_length_is_correct : Integer -> Bool\nproperty zero_length_is_correct n = (-n) % 8 == (8 - (n % 8)) % 8\n\nh2bAndb2hInvert : {m} (fin m, m > 0) => [2 * m * HexDigit] -> Bool\nproperty h2bAndb2hInvert msg = b2h (h2b`{2 * m * HexDigit} msg) == msg\n\nh2bAndb2hInvertForShortStrings : {m, n} (fin m, m > 0, n > 0, n \/^ (2 * HexDigit) == m) => [n] -> Bool\nproperty h2bAndb2hInvertForShortStrings msg = b2h (h2b`{n} hexMsg) == hexMsg where\n    hexMsg = reverseBitOrdering ((reverseBitOrdering msg) # zero) : [2 * m * HexDigit]\n\nb2hAndh2bInvert: {n} (fin n, n > 0) => [n] -> Bool\nproperty b2hAndh2bInvert msg = h2b (b2h msg) == msg\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Keyless::Hash::SHA3::Specification that contains: (1) type parameters b, nr, c with constraints: b finite, divisible by 25, \u22641600, and equal to 25\u00b72^(lg2(b\/25)); nr finite and > 0; c finite with 0 < c < b. (2) Derived types r = b \u2212 c, w = b\/25, ell = lg2 w, and State = [5][5][w]. (3) A sponge-based function Keccak: for finite m, define [m] -> [d] that pads using pad10*1 with rate r, splits into r-bit blocks, absorbs into a zero b-bit state by XORing each block (padded with c zeros), applies Keccak_p after each absorption, then squeezes by repeatedly taking r bits and permuting until producing d bits. (4) Helpers to convert state layout: unflatten and flatten (indexed forms) and unflatten_noindex and flatten_noindex (index-free forms). (5) Step mappings: \u03b8 (column parity mixing), \u03c1 (lane rotations via triangular-number offsets), \u03c1_hardcoded (same rotations using a precomputed offset table), \u03c0 (coordinate permutation), \u03c7 (non-linear row mapping). (6) Round constants: rc : Integer -> Bit via an 8-bit LFSR; include lfsr : [8] -> [8] as a local helper. Also rc_hardcoded : Integer -> Bit using a precomputed 255-bit sequence. (7) \u03b9 : State -> Integer -> State that xors round constants into lane (0,0). (8) pad : for finite x,m and x \u2265 1, produce the pad10*1 string of length x*((m+2)\/^x) \u2212 m. (9) Keccak_p : [b] -> [b] that performs nr rounds of \u03b8\u2192\u03c1_hardcoded\u2192\u03c0\u2192\u03c7 followed by \u03b9 with appropriate round indices. (10) Keccak_f : [b] -> [b] constrained by nr = 12 + 2*ell, delegating to Keccak_p. (11) Define the following properties: unflattens_match, flattens_match, hardcoded_rho_is_correct, index_eq_int (instantiating a general index_eq lemma), value_bound, round_constants_correctly_hardcoded, unflatten_correct, and flatten_correct, each asserting the equivalences and bounds described by their names. Mark internal helpers as private where appropriate."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Specification where\n\nparameter\n\n    type b : #\n    type constraint (fin b, b % 25 == 0, b <= 1600, (2 ^^ (lg2 (b \/ 25))) * 25 == b)\n\n    type nr : #\n    type constraint (fin nr, nr > 0)\n\n    type c : #\n    type constraint (fin c, c < b, c > 0)\n\nKeccak : {d, m} (fin m) => [m] -> [d]\nKeccak M = digest where\n        P = M # pad `{x = r, m = m}\n                type n = (m + 2) \/^ r\n            Ps = split P : [n][r]\n        S = zero : [b]\n        Ss = [S] # [Keccak_p (S' ^ (Pi # (zero : [c]))) | Pi <- Ps | S' <- Ss]\n                extend : [b] -> [inf]\n    extend Z = (take`{r} Z) # extend (Keccak_p Z)\n    digest = take`{front=d, back=inf} (extend (Ss ! 0))\n\nprivate\n\n    type r = b - c\n\n    type w = b \/ 25\n\n    type ell = lg2 w\n\n    type State = [5][5][w]\n\n    unflatten : [b] -> State\n    unflatten S = [[ Lanes@((5 * y + x))\n        | y <- [0..4]]\n        | x <- [0..4]] where\n        Lanes = map reverse (split`{25} S)\n\n    unflatten_noindex : [b] -> State\n    unflatten_noindex S = transpose (groupBy (reverse (groupBy`{w} (reverse S))))\n\n    property unflattens_match S = unflatten S == unflatten_noindex S\n\n    flatten : State -> [b]\n    flatten A = S where\n                                Lanes = [[ reverse (A@i@j)\n            | j <- [0..4]]\n            | i <- [0..4]]\n        Planes = [ Lanes@0@j # Lanes@1@j # Lanes@2@j # Lanes@3@j # Lanes@4@j\n            | j <- [0..4]]\n        S = join Planes\n\n    flatten_noindex : State -> [b]\n    flatten_noindex A = reverse (join (reverse (join (transpose A))))\n\n    property flattens_match A = flatten A == flatten_noindex A\n\n    \u03b8 : State -> State\n    \u03b8 A = A' where\n        C = [ A@x@0 ^ A@x@1 ^ A@x@2 ^ A@x@3 ^ A@x@4\n            | x <- [0..4]]\n        D = [ C @ ((x - 1) % 5) ^ (C @ ((x + 1) % 5) <<< 1)\n            | x <- [0..4]]\n        A' = [[ A@x@y ^ D@x\n            | y <- [0..4]]\n            | x <- [0..4] ]\n\n    \u03c1 : State -> State\n    \u03c1 A = A' where\n        \/\/ Step 1.\n        A1 = [[ if (x == 0) && (y == 0) then A@0@0 else zero\n            | y <- [0..4]]\n            | x <- [0..4]]\n        \/\/ Step 2-3.\n        As = [((1,0), A1)] #\n            [ ((y, (2*x + 3*y) % 5), set_lane x y t Ai)\n            | ((x, y), Ai) <- As\n            | t <- [0..23]]\n        (_, A') = As ! 0\n\n                set_lane x' y' t Ai = [[\n            if (x' == x) && (y' == y) then A@x@y <<< ((t+1)*(t+2)\/2)\n            else Ai@x@y\n            | y <- [0..4]]\n            | x <- [0..4]]\n\n    \u03c1_hardcoded : State -> State\n    \u03c1_hardcoded A = A' where\n        A' = groupBy [ a <<< offset | a <- join A | offset <- t_offsets]\n\n                                        t_offsets = [\n            0x000, 0x024, 0x003, 0x069, 0x0d2,\n            0x001, 0x12c, 0x00a, 0x02d, 0x042,\n            0x0be, 0x006, 0x0ab, 0x00f, 0x0fd,\n            0x01c, 0x037, 0x099, 0x015, 0x078,\n            0x05b, 0x114, 0x0e7, 0x088, 0x04e\n        ]\n\n    property hardcoded_rho_is_correct A = \u03c1 A == \u03c1_hardcoded A\n\n    \u03c0 : State -> State\n    \u03c0 A = [[ A @((x + 3 * y) % 5) @x\n        | y <- [0..4]]\n        | x <- [0..4]]\n\n    \u03c7 : State -> State\n    \u03c7 A = [[ A @x @y ^ (~A @((x + 1) % 5) @y && A @((x + 2) % 5) @y)\n        | y <- [0..4]]\n        | x <- [0..4]]\n\n    rc : Integer -> Bit\n    rc t = if (t % 255) == 0 then 1          else Rs @ (t') @0 \/\/ Step 4.\n         where\n             \/\/ Step 2 - 3.\n             Rs = [0b10000000] # [lfsr R | R <- Rs ]\n             \/\/ Step 3. Linear feedback shift register.\n             \/\/ The truncation in step f is done manually in the return value.\n             lfsr : [8] -> [8]\n             lfsr Rin = [R0, R@1, R@2, R@3, R4, R5, R6, R@7]\n                 where\n                     R = 0b0 # Rin\n                     R0 = R@0 ^ R@8\n                     R4 = R@4 ^ R@8\n                     R5 = R@5 ^ R@8\n                     R6 = R@6 ^ R@8\n             \/\/ Cryptol's SMT interface disallows index by symbolic `Integer`.\n                                                    t' = fromInteger (t % 255) : [8]\n\n    \/**\n     * Hardcode the round constant values.\n     *\n     * Since the `rc` function doesn't depend on any of the functor parameters,\n     * this hardcoded value is correct for all instantiations.\n     * We computed the value `constants` with:\n     * ```cryptol\n     * [rc i | i <- [0..255]]\n     * ```\n     *\n     * This provides a 4x speedup.\n     *\n     * Equivalent to [FIPS-202] Section 3.2.5, Algorithm 5.\n     *\/\n    rc_hardcoded : Integer -> Bit\n    rc_hardcoded t = constants @ (t') where\n        constants = join [\n            0x80b1e87f90a7d57062b32fde6ee54a25,\n            0xa339e361175edf0d35b504ec9303a471\n        ]\n        \/\/ Cryptol's SMT interface disallows index by symbolic `Integer`.\n                                t' = fromInteger (t % 255) : [8]\n\n    \/*\n     * Some properties justifying the conversion of `Integer -> [8]`\n     * in `rc` and `rc_hardcoded`\n     *\/\n    private\n        \/**\n        * A fact about modular arithmetic:\n        *   For any integers `i`, `m`, `n`, such that `m > 0` and `m < n`,\n        *   `i mod m mod n == i mod m`\n        *   I.e., the modular reduction is equivalent to the smaller modulus.\n        *\/\n        index_eq: {ix} (Integral ix, Cmp ix, Literal 0 ix) => ix -> ix -> ix -> Bit\n        index_eq i m n = m > 0 ==> m <= n ==> (i % m) % n == (i % m)\n\n        \/**\n        * An instance of the fact above for Cryptol `Integer`.\n        * ```repl\n        * :prove index_eq_int\n        * ```\n        *\/\n        property index_eq_int = index_eq `{Integer}\n\n        \/**\n        * A consequence of the property above is that reducing an integer\n        * mod 255 and then converting it to an `[8]` is always in `Z 255`.\n        * ```repl\n        * :prove value_bound\n        * ```\n        *\/\n        value_bound: Integer -> Bit\n        property value_bound i = (fromInteger (i % 255) : [8]) < 255\n\n    \/**\n     * Prove that the hardcoded round constants are correct.\n     * ```repl\n     * :prove round_constants_correctly_hardcoded\n     * ```\n     *\/\n    property round_constants_correctly_hardcoded t = rc_hardcoded t == rc t\n\n    \/**\n     * One of the step mappings that's part of a round of Keccak-p.\n     *\n     * The effect is to modify some of the bits of the Lane defined by\n     * `(0, 0)` according to the round index.\n     * [FIPS-202] Section 3.2.5, Algorithm 6.\n     *\/\n    \u03b9 : State -> Integer -> State\n    \u03b9 A ir = A'' where\n                A' = A\n        \/\/ Step 2.\n        RC0 = zero : [w]\n        \/\/ Step 3. 0 is the identity for XOR, so we iteratively set the\n        \/\/ `2^j-1`th element by XORing the previously-set bits of RC with the\n        \/\/ correct value at the desired index.\n        RCs = [RC0] # [RC' ^ (zext`{w} [rc_hardcoded (toInteger j + 7 * ir)] << (2^^j - 1))\n            | RC' <- RCs\n            | j <- [0..ell] ]\n        RC = (RCs ! 0) : [w]\n        \/\/ Step 4.\n        A'' = [[ if (x == 0) && (y == 0) then A'@0@0 ^ RC else A'@x@y\n            | y <- [0..4]]\n            | x <- [0..4]]\n\n    \/**\n     * Padding rule `pad10*1`.\n     *\n     * This function produces padding e.g. a string with an appropriate length\n     * to append to another string.\n     * [FIPS-202] Section 5.1.\n     *\n     * Note: The spec says the output length is a positive multiple of `x` and\n     * defines it to be, basically: `(- m - 2) mod x + 2`. We can't encode this\n     * exactly as-is in the type signature because Cryptol doesn't support\n     * negative numbers in types (`-m`). Instead, we do the following:\n     *      (m + 2)           : The minimum length of the original message and\n     *                        : the padding\n     *      (m + 2) \/^ x      : The multiplier of `x` that determines the\n     *                        : ultimate length of the message + padding\n     * x * ((m + 2) \/^ x)     : The total length of the message + padding\n     * x * ((m + 2) \/^ x) - m : The total length of the padding alone\n     *\/\n    pad : {x, m} (fin x, fin m, x >= 1) => [x * ((m + 2) \/^ x) - m]\n    pad = [1] # zero # [1]\n\n    \/**\n     * The Keccak-p[b, nr] permutation.\n     * [FIPS-202] Section 3.3, Algorithm 7.\n     *\/\n    Keccak_p : [b] -> [b]\n    Keccak_p S = S' where\n                Rnd A ir = \u03b9 (\u03c7 (\u03c0 (\u03c1_hardcoded (\u03b8 A)))) ir\n\n                A0 = unflatten_noindex S\n                                        As = [A0] # [ Rnd A ir where\n                ir = 12 + 2 * `ell - r\n            | A <- As\n            | r <- [nr, nr - 1 .. 1]]\n                S' = flatten_noindex (As ! 0)\n\n    \/**\n     * Keccak-f family of permutations.\n     *\n     * This specializes `Keccak-p` to the case where `nr = 12 + 2*ell`; we\n     * enforce this in the type constraint on this function.\n     * [FIPS-202] Section 3.4.\n     *\/\n    Keccak_f : (nr == 12 + 2 * ell) => [b] -> [b]\n    Keccak_f = Keccak_p\n\n\/**\n * See https:\/\/keccak.team\/files\/Keccak-reference-3.0.pdf, Section 1.2\n * ```repl\n * :prove unflatten_correct\n * ```\n *\/\nunflatten_correct : [12] -> [12] -> [12] -> [b] -> Bit\nproperty unflatten_correct x y z p =\n    x < 5 ==> y < 5 ==> z < (`w:[12]) ==>\n    p@((5*y + x)*`w + z) == unflatten p @ x @ y ! z\n\n\/**\n * Flatten and unflatten must be each other's inverses.\n * ```repl\n * :prove flatten_correct\n * ```\n *\/\nproperty flatten_correct s = unflatten (flatten s) == s\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/SHA3.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA3::SHA3 that contains the following definitions: (1) import the Keccak bit-ordering utilities under a short alias and import the SHA3 Keccak specification while setting its parameters so the permutation width is 1600 bits, the number of rounds is 24, and the capacity equals twice the digest length; (2) declare a type parameter for the digest length with constraints that it is finite, a multiple of 8, and between 224 and 512 bits inclusive; (3) define type synonyms for the digest length, an unbounded message size, and the security strength as half the digest length; (4) define a function that takes a finite-length bitvector message and returns a digest-length bitvector by invoking Keccak parameterized by the digest length, after appending the SHA3 domain-separation bits \u201c01\u201d to the input; (5) define a function that computes the same digest but operates in byte-oriented bit ordering by reversing bit ordering on the input prior to the Keccak call, appending the same domain-separation bits, and reversing the bit ordering on the output; (6) define a function over byte arrays that joins input bytes to a bitvector, applies the byte-oriented hash, and splits the result back into digest\/8 bytes. Provide precise Cryptol type signatures for each function that quantify over the input size with fin constraints, and ensure all outputs have length equal to the digest length (or digest\/8 bytes for the byte-level function)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::SHA3 where\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\nimport Primitive::Keyless::Hash::SHA3::Specification where\n    type b = 1600\n    type nr = 24\n    type c = 2 * digest\n\nparameter\n\n    type digest : #\n    type constraint (fin digest, digest % 8 == 0, digest >= 224, digest <= 512)\n\ntype DigestLength = digest\n\ntype MessageUpperBound = inf\n\ntype SecurityStrength = DigestLength \/ 2\n\nsha3 : {n} (fin n) => [n] -> [digest]\nsha3 M = Keccak`{d=digest} (M # 0b01)\n\nhash : {n} (fin n) => [n] -> [digest]\nhash M = KBO::reverseBitOrdering (Keccak`{d=digest} ((KBO::reverseBitOrdering M) # 0b01))\n\nhashBytes : {m} (fin m) => [m][8] -> [digest \/ 8][8]\nhashBytes M = split (hash (join M))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA2Internal::SHA384 that contains the following definitions: wp, digest_size, j, H0, K, SIGMA_0, SIGMA_1, sigma_0, sigma_1. Set wp to the 64-bit word size, digest_size to 384 bits, and j to 80 rounds. Define H0 as the SHA-384 initial hash vector of eight wp-bit words, and K as the 80 SHA-384\/SHA-512 round constants, each a wp-bit word, in standard order. Provide types: wp, digest_size, and j as type synonyms; H0 : [8][wp]; K : [j][wp]; SIGMA_0, SIGMA_1, sigma_0, sigma_1 : [wp] -> [wp]. Implement the functions over wp-bit words using right-rotate and logical right-shift: SIGMA_0(x) = ROTR 28 \u2295 ROTR 34 \u2295 ROTR 39; SIGMA_1(x) = ROTR 14 \u2295 ROTR 18 \u2295 ROTR 41; sigma_0(x) = ROTR 1 \u2295 ROTR 8 \u2295 SHR 7; sigma_1(x) = ROTR 19 \u2295 ROTR 61 \u2295 SHR 6. Use Cryptol\u2019s rotate and logical shift operators. Ensure H0 and K match the official FIPS 180-4 values for SHA-384 exactly, and that sequence lengths and element widths conform to wp and j. The module should specialize the generic SHA-2 internal definition using these parameters and definitions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2Internal::SHA384 = Primitive::Keyless::Hash::SHA2Internal::SHA where\n\ntype wp = 64\n\ntype digest_size = 384\n\ntype j = 80\n\nH0 = [ 0xcbbb9d5dc1059ed8, 0x629a292a367cd507, 0x9159015a3070dd17, 0x152fecd8f70e5939,\n       0x67332667ffc00b31, 0x8eb44a8768581511, 0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4]\n\nK = [ 0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n      0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n      0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n      0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n      0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n      0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n      0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n      0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n      0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n      0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n      0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n      0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n      0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n      0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n      0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n      0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n      0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n      0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n      0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n      0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817]\n\nSIGMA_0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)\n\nSIGMA_1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)\n\nsigma_0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)\n\nsigma_1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA2Internal::SHA256 that instantiates the generic SHA-2 internal construction for the 32-bit variant and contains the following definitions: type synonyms wp = 32, digest_size = 256, and j = 64; a constant H0 typed as an 8-element sequence of wp-bit words equal to the SHA-256 initial hash values; a constant K typed as a j-element sequence of wp-bit words equal to the 64 SHA-256 round constants; and four functions SIGMA_0, SIGMA_1, sigma_0, and sigma_1, each with type [wp] -> [wp], defined as bitwise XORs of rotate-right and logical right-shift operations with the standard SHA-256 rotation\/shift amounts: (2, 13, 22), (6, 11, 25), (7, 18 with shift by 3), and (17, 19 with shift by 10), respectively. Use explicit type signatures that reference wp so all operations are confined to 32-bit words, and ensure sequences have the exact lengths noted above."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2Internal::SHA256 = Primitive::Keyless::Hash::SHA2Internal::SHA where\n\ntype wp = 32\n\ntype digest_size = 256\n\ntype j = 64\n\nH0 = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n       0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]\n\nK = [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]\n\nSIGMA_0 x = (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)\n\nSIGMA_1 x = (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)\n\nsigma_0 x = (x >>> 7) ^ (x >>> 18) ^ (x >> 3)\n\nsigma_1 x = (x >>> 17) ^ (x >>> 19) ^ (x >> 10)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/Equivalence.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA2Internal::Equivalence that contains the following. Import the SHA-256 instantiation and internal implementations as SHA_256 and SHAI_256, and the SHA-384 instantiation and internal implementations as SHA_384 and SHAI_384. Define a property named sha256ImplsAreEquivalent with a polymorphic size parameter m. Constrain m to be finite and the bit-width of m to be at most the SHA-256 message upper bound. The property takes a single bitvector of length m and asserts that the SHA-256 instantiation\u2019s hash on that input equals the internal SHA-256 implementation\u2019s hash on the same input. Define a property named sha256BytewiseImplsAreEquivalent with a polymorphic size parameter m. Constrain m to be finite and the bit-width of 8*m to be at most the SHA-256 message upper bound. The property takes a sequence of m bytes and asserts that the flattened result of the instantiation\u2019s byte-wise hash equals the internal implementation\u2019s byte-wise output on the same input. Define a property named sha384ImplsAreEquivalent with a polymorphic size parameter m. Constrain m to be finite and the bit-width of m to be at most the SHA-384 message upper bound. The property takes a bitvector of length m and asserts equality between the SHA-384 instantiation\u2019s hash and the internal SHA-384 implementation\u2019s hash. Define a property named sha384BytewiseImplsAreEquivalent with a polymorphic size parameter m. Constrain m to be finite and the bit-width of 8*m to be at most the SHA-384 message upper bound. The property takes a sequence of m bytes and asserts that the flattened result of the instantiation\u2019s byte-wise hash equals the internal SHA-384 implementation\u2019s byte-wise output."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2Internal::Equivalence where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA_256\nimport Primitive::Keyless::Hash::SHA2Internal::SHA256 as SHAI_256\n\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 as SHA_384\nimport Primitive::Keyless::Hash::SHA2Internal::SHA384 as SHAI_384\n\nsha256ImplsAreEquivalent : {m} (fin m, width m <= SHA_256::MessageUpperBound) => [m] -> Bit\nproperty sha256ImplsAreEquivalent m = SHA_256::hash m == SHAI_256::sha m\n\nsha256BytewiseImplsAreEquivalent : {m} (fin m, width (8 * m) <= SHA_256::MessageUpperBound) => [m][8] -> Bit\nproperty sha256BytewiseImplsAreEquivalent m = join (SHA_256::hashBytes m) == SHAI_256::SHAImp m\n\nsha384ImplsAreEquivalent : {m} (fin m, width m <= SHA_384::MessageUpperBound) => [m] -> Bit\nproperty sha384ImplsAreEquivalent m = SHA_384::hash m == SHAI_384::sha m\n\nsha384BytewiseImplsAreEquivalent : {m} (fin m, width (8 * m) <= SHA_384::MessageUpperBound) => [m][8] -> Bit\nproperty sha384BytewiseImplsAreEquivalent m = join (SHA_384::hashBytes m) == SHAI_384::SHAImp m\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/SHA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA2Internal::SHA that contains the following definitions: sha; type parameters wp, digest_size, j with finiteness and range constraints; aliases w, block_size, num_blocks, padded_size, digestSize, securityStrength; constants H0, K; functions SIGMA_0, SIGMA_1, sigma_0, sigma_1; aliases SHAH0, S0, S1, s0, s1; bitwise combinators Ch, Maj; internal helpers pad, parse, messageSchedule_Common, compress_Common, processBlock_Common, SHA_2_Common'; state types SHAState and SHAState_Array with fields for chaining state, partial block buffer, byte counters, and size; initializers SHAInit, SHAInit_Array; streaming updates SHAUpdate, SHAUpdate_Array (the array variants require a word-size lower bound); finalizers SHAFinal, SHAFinal_Array; single-byte update helper SHAUpdate1; top-level entry points SHAImp and SHAImp_Array; block processors processBlocks, processBlock, processBlocksLoop; and a Boolean lemma arrayRangeEqual_arrayRangeLookup_lemma. Provide explicit Cryptol type signatures for every definition, including length and size parameters and all necessary constraints (e.g., finiteness, word-size relations, block-size divisibility, and input-length constraints for sha). Include Boolean lemmas (type Bit) that assert: the high-level sha equals SHAImp for byte-aligned inputs; SHAImp equals SHAImp_Array when the ByteArray contents and length match the byte list; processBlock_Common equals processBlock when converting between a word-array block and the corresponding byte-array slice; processBlocks corresponds to repeated processBlock_Common; SHAFinal equals SHAFinal_Array given equivalent states; pad produces a message whose size is an integer multiple of the block size and embeds the big-endian length; messageSchedule_Common yields the standard schedule length j; and securityStrength equals half the digest size. State any preconditions needed for these lemmas, such as bounds on wp, digest_size, j, and w for array-based routines."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2Internal::SHA where\n\nimport Array\nimport Common::ByteArray\n\nsha : {L} (2 * w >= width L) => [L] -> [digest_size]\nsha M = take (join (SHA_2_Common' [ split x | x <- parse`{num_blocks L} (pad`{L} M) ]))\n\nparameter\n\n  \/** Word size\n    Specifications are based on word size w, rather than digest size (8 * w)\n    or block size (m == 16 * w), in order to avoid confusing Cryptol's type\n    constraint verifier with integer division.\n  *\/\n\n  type wp : #\n  type constraint (fin wp, wp >= 2, 32 >= width wp)\n\n  type digest_size : #\n  type constraint (fin digest_size, 8*wp >= digest_size)\n\n  type j : #\n  type constraint (fin j, j >= 17)\n\n  H0 : [8][wp]\n  K  : [j][wp]\n\n  SIGMA_0 : [wp] -> [wp]\n  SIGMA_1 : [wp] -> [wp]\n  sigma_0 : [wp] -> [wp]\n  sigma_1 : [wp] -> [wp]\n\nSHAH0 = H0\nS0 = SIGMA_0\nS1 = SIGMA_1\ns0 = sigma_0\ns1 = sigma_1\ntype digestSize = digest_size\n\ntype securityStrength = digest_size \/ 2\n\nCh : [wp] -> [wp] -> [wp] -> [wp]\nCh x y z = (x && y) ^ (~x && z)\n\nMaj : [wp] -> [wp] -> [wp] -> [wp]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nprocessBlock_Common : [8][wp] -> [16][wp] -> [8][wp]\nprocessBlock_Common H Mi = compress_Common H (messageSchedule_Common Mi)\n\nprivate\n  type w = wp\n\n  type block_size = 16 * w\n\n  type num_blocks L     = (L+1+2*w) \/^ block_size\n  type padded_size L    = num_blocks L * block_size\n\n  pad : {L} (2 * w >= width L) => [L] -> [padded_size L]\n  pad M = M # 0b1 # zero # (`L : [2*w])\n\n  parse : {m} [m * block_size] -> [m][block_size]\n  parse = split\n\n  messageSchedule_Common : [16][w] -> [j][w]\n  messageSchedule_Common Mi = take W\n    where\n    W : [inf][_]\n    W = Mi # [ w1 + s0 w2 + w3 + s1 w4\n             | w1 <- W\n             | w2 <- drop`{1} W\n             | w3 <- drop`{9} W\n             | w4 <- drop`{14} W\n             ]\n\n  compress_Common : [8][w] -> [j][w] -> [8][w]\n  compress_Common H W =\n        [ (as ! 0) + (H @ 0),\n      (bs ! 0) + (H @ 1),\n      (cs ! 0) + (H @ 2),\n      (ds ! 0) + (H @ 3),\n      (es ! 0) + (H @ 4),\n      (fs ! 0) + (H @ 5),\n      (gs ! 0) + (H @ 6),\n      (hs ! 0) + (H @ 7)\n    ]\n    where\n      T1 = [h + S1 e + Ch e f g + k_t + w_t\n                | h <- hs | e <- es | f <- fs | g <- gs | k_t <- K | w_t <- W]\n      T2 = [ S0 a + Maj a b c | a <- as | b <- bs | c <- cs]\n      hs = take`{j + 1}([H @ 7] # gs)\n      gs = take`{j + 1}([H @ 6] # fs)\n      fs = take`{j + 1}([H @ 5] # es)\n      es = take`{j + 1}([H @ 4] # [d + t1 | d <- ds | t1 <- T1])\n      ds = take`{j + 1}([H @ 3] # cs)\n      cs = take`{j + 1}([H @ 2] # bs)\n      bs = take`{j + 1}([H @ 1] # as)\n      as = take`{j + 1}([H @ 0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\n  SHA_2_Common' : {L} (fin L) => [L][16][w] -> [8][w]\n  SHA_2_Common' blocks = hash ! 0\n    where\n    hash = [H0] # [ processBlock_Common h b | h <- hash | b <- blocks]\n\ntype SHAState = { h : [8][w]\n                , block : [w * 2][8]\n                , n : [32]\n                , sz : [w * 2]\n                }\n\nSHAInit : SHAState\nSHAInit = { h = H0\n          , block = zero\n          , n = 0\n          , sz = 0\n          }\n\nSHAUpdate : {n} (fin n) => SHAState -> [n][8] -> SHAState\nSHAUpdate sinit bs = ss!0\n  where ss = [sinit] # [ SHAUpdate1 s b | s <- ss | b <- bs ]\n\nSHAFinal : SHAState -> [digest_size]\nSHAFinal s = take (join (processBlock_Common h b'))\n  \/\/ Because the message is always made up of bytes, and the size is a\n  \/\/ fixed number of bytes, the 1 pad will always be at least a byte.\n  where s' = SHAUpdate1 s 0x80\n                                        (h, b) = if s'.n <= (`w*2 - (`w\/4)) then (s'.h, s'.block)\n                 else (processBlock_Common s'.h (split (join s'.block)), zero)\n        b' = split (join b || (zero # s.sz))\n\nSHAImp : {n} (fin n) => [n][8] -> [digest_size]\nSHAImp msg = SHAFinal (SHAUpdate SHAInit msg)\n\nprivate\n\n          SHAUpdate1 : SHAState -> [8] -> SHAState\n  SHAUpdate1 s b =\n    if s.n == (2 * `w - 1)\n      then { h = processBlock_Common s.h (split (join (update s.block s.n b)))\n           , block = zero\n           , n = 0\n           , sz = s.sz + 8\n           }\n      else { h = s.h\n           , block = update s.block s.n b\n           , n = s.n + 1\n           , sz = s.sz + 8\n           }\n\ntype SHAState_Array =\n  { h : [8][w]\n  , block : ByteArray\n  , n : [32]\n  , sz : [w * 2]\n  }\n\nSHAInit_Array : SHAState_Array\nSHAInit_Array =\n  { h = H0\n  , block = arrayConstant 0\n  , n = 0\n  , sz = 0\n  }\n\nSHAUpdate_Array : (w >= 32) => SHAState_Array -> ByteArray -> [64] -> SHAState_Array\nSHAUpdate_Array state data len =\n  if state.n != 0\n    then if len < 2 * `w - n\n      then state'\n      else state''\n    else state'''\n where\n   n = 0 # state.n\n   state' = { h = state.h, block = block', n = drop n', sz = state.sz + (0 # len) * 8 }\n    where\n      block' = arrayCopy state.block n data 0 len\n      n' = n + len\n   state'' = { h = h'', block = block''', n = drop n''', sz = state.sz + (0 # len) * 8 }\n    where\n      h' = processBlock state.h (arrayCopy state.block n data 0 (2 * `w - n)) 0\n      block' = arrayCopy state.block n data 0 (2 * `w - n)\n      index' = 2 * `w - n\n      len' = len - (2 * `w - n)\n      (h'', index'', len'') = if len' >= 2 * `w\n        then\n          ( (processBlocks h' (arrayCopy (arrayConstant 0) 0 data index' ((len' \/ (2 * `w)) * (2 * `w))) 0 (len' \/ (2 * `w)))\n          , index' + len' - (len' % (2 * `w))\n          , len' % (2 * `w)\n          )\n        else (h', index', len')\n      (block''', n''') = if len'' != 0\n        then ((arrayCopy block' 0 data index'' len''), len'')\n        else (block', 0)\n   state''' = { h = h'', block = block''', n = drop n''', sz = state.sz + (0 # len) * 8 }\n    where\n      (h'', index'', len'') = if len >= 2 * `w\n        then\n          ( (processBlocks state.h data 0 (len \/ (2 * `w)))\n          , len - (len % (2 * `w))\n          , len % (2 * `w)\n          )\n        else (state.h, 0, len)\n      (block''', n''') = if len'' != 0\n        then ((arrayCopy state.block 0 data index'' len''), len'')\n        else (state.block, n)\n\nSHAFinal_Array : (w >= 32) => SHAState_Array -> [digest_size]\nSHAFinal_Array state = take (join h''')\n  where\n    n = 0 # state.n\n    block' = arrayUpdate state.block n 0x80\n    n' = n + 1\n    (h'', block'', n'') = if n' > 2 * `w - `w \/ 4\n      then ((processBlock state.h (arraySet block' n' 0 (2 * `w - n')) 0), (arraySet block' n' 0 (2 * `w - n')), 0)\n      else (state.h, block', n')\n    h''' = processBlock\n      h''\n      (arrayRangeUpdate\n        (arraySet block'' n'' 0 (2 * `w - `w \/ 4 - n''))\n        (2 * `w - `w \/ 4)\n        (split`{parts=(w+3)\/4} (0 # state.sz)))\n      0\n\n\/\/ Imperative SHA implementation\nSHAImp_Array : (w >= 32) => ByteArray -> [64] -> [digest_size]\nSHAImp_Array msg len = SHAFinal_Array (SHAUpdate_Array SHAInit_Array msg len)\n\nprocessBlocks : [8][w] -> ByteArray -> [64] -> [64] -> [8][w]\nprocessBlocks [a, b, c, d, e, f, g, h] data index n = processBlock [a', b', c', d', e', f', g', h'] data index'\n  where\n    (a', b', c', d', e', f', g', h', index') = processBlocksLoop n data a b c d e f g h index\n\nprocessBlock : [8][w] -> ByteArray -> [64] -> [8][w]\nprocessBlock h block index =\n  processBlock_Common h (split (join (arrayRangeLookup block index)))\n\nprocessBlocksLoop : [64] -> ByteArray -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [64] -> ([w], [w], [w], [w], [w], [w], [w], [w], [64])\nprocessBlocksLoop num data a b c d e f g h index = if (index + 2 * `w) < (num * 2 * `w)\n  then processBlocksLoop num data a' b' c' d' e' f' g' h' (index + 2 * `w)\n  else (a, b, c, d, e, f, g, h, index)\n  where\n    [a', b', c', d', e', f', g', h'] = (processBlock [a, b, c, d, e, f, g, h] data index)\n\narrayRangeEqual_arrayRangeLookup_lemma : {n} (fin n, n >= 1, n <= 1000) => ByteArray -> ByteArray -> Bit\narrayRangeEqual_arrayRangeLookup_lemma a b = arrayRangeEqual a 0 b 0 `n == (arrayRangeLookup`{n=n} a 0 == arrayRangeLookup b 0)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Tests\/SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Keyless::Hash::SHA2::Tests::SHA384 that imports the SHA-384 instantiation module under the alias SHA384. Inside, declare four properties that assert correctness of the SHA-384 hash against standard test vectors:\n- A property named abcWorks that checks the hash of the ASCII string \"abc\" (concatenated into a single bit sequence) equals a 384-bit expected digest given as six 64-bit big-endian words concatenated together.\n- A property named emptyStringWorks that checks the hash of the empty byte sequence equals a 384-bit expected digest given as six 64-bit big-endian words concatenated together.\n- A property named alphabet448 that checks the hash of the 56-byte ASCII message commonly used for SHA-2 testing (starting with \"abcdbcde\" and ending with \"nopq\") equals a 384-bit expected digest given as six 64-bit big-endian words concatenated together. Define the input locally and flatten it to bits before hashing.\n- A property named alphabet896 that checks the hash of the 112-byte ASCII message commonly used for SHA-2 testing (starting with \"abcdefgh\" and ending with \"nopqrstu\") equals a 384-bit expected digest given as six 64-bit big-endian words concatenated together. Define the input locally and flatten it to bits before hashing.\nFor each property, define the expected digest as a local constant and compare SHA384::hash applied to the flattened input with that digest. Use join to concatenate both the input characters and the list of 64-bit words. Do not introduce variables beyond local definitions; ensure types are consistent with a 384-bit output."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Tests::SHA384 where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 as SHA384\n\nproperty abcWorks = SHA384::hash (join \"abc\") == output where\n    output = join [\n        0xcb00753f45a35e8b, 0xb5a03d699ac65007, 0x272c32ab0eded163,\n        0x1a8b605a43ff5bed, 0x8086072ba1e7cc23, 0x58baeca134c825a7\n    ]\n\nproperty emptyStringWorks = SHA384::hash [] == output where\n    output = join [\n        0x38b060a751ac9638, 0x4cd9327eb1b1e36a, 0x21fdb71114be0743,\n        0x4c0cc7bf63f6e1da, 0x274edebfe76f65fb, 0xd51ad2f14898b95b\n    ]\n\nproperty alphabet448 = SHA384::hash input == output where\n    input = join \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    output = join [\n        0x3391fdddfc8dc739, 0x3707a65b1b470939, 0x7cf8b1d162af05ab,\n        0xfe8f450de5f36bc6, 0xb0455a8520bc4e6f, 0x5fe95b1fe3c8452b\n    ]\n\nproperty alphabet896 = SHA384::hash input == output where\n    input = join \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n    output = join [\n        0x09330c33f71147e8, 0x3d192fc782cd1b47, 0x53111b173b3b05d2,\n        0x2fa08086e3b0f712, 0xfcc7c71a557e2db9, 0x66c3e9fa91746039\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Tests\/SHA224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Keyless::Hash::SHA2::Tests::SHA224 that contains the following definitions: four properties abcWorks, emptyStringWorks, alphabet448, and alphabet896. Import Primitive::Keyless::Hash::SHA2::Instantiations::SHA224 as SHA224. Each property must be a boolean assertion that SHA224.hash applied to a specific ASCII message equals a known 224-bit digest. Build each message input by concatenating its 8-bit ASCII bytes into a single bitvector. For emptyStringWorks use the empty message; for abcWorks use a three-character ASCII message; for alphabet448 and alphabet896 use the two standard SHA-224 test messages from FIPS 180 (one that spans multiple blocks but shorter, and one longer). For each property, define the expected digest as a 224-bit constant created by concatenating seven 32-bit words in big-endian order according to the published SHA-224 test vectors for those messages. Assert equality between the 224-bit hash result and the 224-bit expected constant. Do not implement the hash; only import and invoke it, construct the constants, and state these properties."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Tests::SHA224 where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA224 as SHA224\n\nproperty abcWorks = SHA224::hash (join \"abc\") == output where\n    output = join [\n        0x23097d22, 0x3405d822, 0x8642a477, 0xbda255b3,\n        0x2aadbce4, 0xbda0b3f7, 0xe36c9da7\n    ]\n\nproperty emptyStringWorks = SHA224::hash [] == output where\n    output = join [\n        0xd14a028c, 0x2a3a2bc9, 0x476102bb, 0x288234c4,\n        0x15a2b01f, 0x828ea62a, 0xc5b3e42f\n    ]\n\nproperty alphabet448 = SHA224::hash input == output where\n    input = join \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    output = join [\n        0x75388b16, 0x512776cc, 0x5dba5da1, 0xfd890150,\n        0xb0c6455c, 0xb4f58b19, 0x52522525\n    ]\n\nproperty alphabet896 = SHA224::hash input == output where\n    input = join \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n    output = join [\n        0xc97ca9a5, 0x59850ce9, 0x7a04a96d, 0xef6d99a9,\n        0xe0e0e2ab, 0x14e6b8df, 0x265fc0b3\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Tests\/SHA256_FFI.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA2::Tests::SHA256 that imports Primitive::Keyless::Hash::SHA2::Instantiations::SHA256_FFI as SHA256_FFI and Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256. Inside, define a property named FFIAndCryptolAreEqual with a polymorphic size parameter l, constrained so that 8*l satisfies SHA256::ValidMessageLength. Give it a type from a sequence of l bytes (each an 8-bit word) to Bool. In the property body, compute two local values: one by hashing the input bytes with the FFI-based hash function and the other by hashing the same input with the pure Cryptol hash function. Assert that these two hash results are equal. Use clear local bindings for the two computed hashes before comparing them."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Tests::SHA256 where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA256_FFI as SHA256_FFI\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\nFFIAndCryptolAreEqual : {l} (SHA256::ValidMessageLength (8 * l))\n    => [l][8] -> Bool\nproperty FFIAndCryptolAreEqual M = ffi == cryptol where\n    ffi = SHA256_FFI::hashBytes M\n    cryptol = SHA256::hashBytes M\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA512_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Keyless::Hash::SHA2::Instantiations::SHA512_256 that contains the following definitions: a type alias w set to 64 (the word size in bits), a type alias DigestSize set to 256 (the digest size in bits), and a constant H0 that is the SHA\u2011512\/256 initial vector represented as a sequence of eight 64\u2011bit words. Constrain H0 to have length 8 and element type of width w (i.e., H0 has type \u201csequence of eight words of width w\u201d). Instantiate the SHA\u20112 specification with these parameters so the module exports the SHA\u20112 hash functionality specialized to 64\u2011bit words and a 256\u2011bit digest using the standard SHA\u2011512\/256 IV ordering and values. Do not add any other bindings beyond these parameterizations."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA512_256 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 256\n\n                H0 = [\n        0x22312194FC2BF72C\n      , 0x9F555FA3C84C64C2\n      , 0x2393B86B6F53B151\n      , 0x963877195940EABD\n      , 0x96283EE2A88EFFE3\n      , 0xBE5E1E2553863992\n      , 0x2B0199FC2C85B8AA\n      , 0x0EB72DDC81C52CA2\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 that instantiates the generic SHA-2 specification via a where-clause, setting the type synonym w to 64 and the type synonym DigestSize to 384. Inside this module, define the constant H0 as the SHA-384 initial chaining value: a sequence of eight 64-bit words with type [8][w], using the standard SHA-384 IV values. Export w, DigestSize, and H0, and do not introduce any additional bindings or behavior beyond this instantiation and these definitions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 384\n\n            H0 = [\n        0xcbbb9d5dc1059ed8, 0x629a292a367cd507,\n        0x9159015a3070dd17, 0x152fecd8f70e5939,\n        0x67332667ffc00b31, 0x8eb44a8768581511,\n        0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Keyless::Hash::SHA2::Instantiations::SHA224 that instantiates a generic SHA-2 specification module by supplying the required bindings: set the word-width type alias to 32, set the digest size type alias to 224, and define the initial chaining value constant as the standard SHA-224 initialization vector consisting of eight words of width w. Give the constant an explicit type [8][w]. The module should only provide these bindings to the underlying specification and export the resulting instantiation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA224 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 32\n\n    type DigestSize = 224\n\n            H0 = [\n        0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n        0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 that instantiates a generic SHA-2 specification for SHA-256. Inside the module, declare the following definitions: (1) a type synonym w set to 32 to represent the word width in bits; (2) a type synonym DigestSize set to 256 to represent the digest length in bits; (3) a constant H0 with type [8][w], initialized to the standardized SHA-256 initial hash vector (eight 32-bit words as specified by NIST FIPS 180-4). Ensure the module provides these bindings to parameterize the underlying specification and does not introduce any additional functions or properties."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 32\n\n    type DigestSize = 256\n\n            H0 = [\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA512_224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA2::Instantiations::SHA512_224 that instantiates the generic SHA2 specification by providing: (1) a type alias w set to 64 for the word width, (2) a type alias DigestSize set to 224 for the output length in bits, and (3) a constant H0 that is the initial hash vector for this variant, represented as a list of eight unsigned words of width w, preserving the exact standard values and order for SHA-512\/224; ensure H0\u2019s type reflects a sequence of eight w-bit words and that these definitions are exported as part of the instantiation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA512_224 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 224\n\n                H0 = [\n       0x8C3D37C819544DA2\n     , 0x73E1996689DCD4D6\n     , 0x1DFAB7AE32FF9C82\n     , 0x679DD514582F9FCF\n     , 0x0F6D2B697BD44DA8\n     , 0x77E36F7304C48942\n     , 0x3F9D85A86A1D36C8\n     , 0x1112E6AD91D692A1\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that instantiates a generic SHA-2 specification for the SHA-512 variant. Inside the module, provide: (1) a type alias for the word width set to 64 bits, (2) a type alias for the digest size set to 512 bits, and (3) a constant for the initial hash vector as a sequence of eight 64-bit words corresponding to the standard SHA-512 initialization values in the canonical order. Ensure the initial vector\u2019s type is a sequence of eight elements of the chosen word type, and that all aliases and the constant are exported. The module should specialize the shared SHA-2 specification by binding these parameters via the appropriate Cryptol mechanism (e.g., a where-clause) without redefining hashing logic. Keep names consistent and provide any necessary type annotations so that the parameterization type-checks against the generic specification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA512 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 512\n\n            H0 = [\n        0x6a09e667f3bcc908, 0xbb67ae8584caa73b,\n        0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n        0x510e527fade682d1, 0x9b05688c2b3e6c1f,\n        0x1f83d9abfb41bd6b, 0x5be0cd19137e2179\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA256_FFI.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA2::Instantiations::SHA256_FFI that contains the following definitions: (1) import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256; (2) define a type synonym MessageUpperBound that is exactly the same type as SHA256::MessageUpperBound; and (3) declare a foreign function hashBytes that is size-polymorphic over a natural l, with a constraint requiring that 8*l bits is a valid message length according to SHA256::ValidMessageLength. The function takes an array of l bytes (each element is 8 bits) and returns a byte array whose length equals the SHA256 digest size in bytes (i.e., SHA256::DigestLength divided by 8). Clearly describe the role of the size parameter l, the meaning of the validity constraint, the input\/output shapes in bytes, and that hashBytes is an FFI declaration with no Cryptol implementation body."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA256_FFI where\n    import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\n    type MessageUpperBound = SHA256::MessageUpperBound\n\n    foreign hashBytes : {l} (SHA256::ValidMessageLength (8 * l))\n        => [l][8] -> [SHA256::DigestLength \/ 8][8]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA3::Tests::SHA3_512 that contains the following definitions: imports of a Keccak bit-ordering utility module (aliased as KBO) and a SHA3-512 instantiation module; properties t1, t72, and t100. In t1, assert that hashing an empty byte sequence with the SHA3-512 hash function equals a fixed 512-bit expected digest assembled by joining two equal-width parts. In t72, assert a conjunction of two checks: (1) hashWorks compares the SHA3-512 hash of a 72-bit word input to a fixed 512-bit expected digest; (2) hashBytesWorks compares the byte-wise SHA3-512 hash of the input (after splitting the 72-bit word into an array of 8-bit bytes) to the expected digest split into 64 bytes. In t100, assert that hashing a 100-bit input\u2014produced by truncating a larger value to 100 bits using the imported KBO truncation with a 100-bit type parameter\u2014equals a fixed 512-bit expected digest. Within each property, define local bindings for input and output; construct 512-bit outputs by joining two equal-sized chunks, and use split\/join to convert between a 512-bit word and 64 bytes. Ensure types are consistent: inputs are empty bytes, a 72-bit word, and a 100-bit word respectively; outputs are 512-bit digests; the byte-oriented hash returns 64 bytes. Do not compute the digests; reference fixed constants for the expected outputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_512 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512 as SHA3_512\n\nproperty t1 = SHA3_512::hash [] == output where\n    output = join [\n        0xa69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a6,\n        0x15b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26\n    ]\n\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_512::hash input == output\n    hashBytesWorks = SHA3_512::hashBytes (split input) == split output\n    input = 0x3d6093966950abd846\n    output = join [\n        0x53e30da8b74ae76abf1f65761653ebfbe87882e9ea0ea564addd7cfd5a652457,\n        0x8ad6be014d7799799ef5e15c679582b791159add823b95c91e26de62dcb74cfa\n    ]\n\nproperty t100 = SHA3_512::hash input == output where\n    input = KBO::truncate`{100} 0xd404d8e31f8091709122025a0c\n    output = join [\n        0xa5ce9e2523788040eab94f0a2467efc2a1e6d4ea74e9248f97f94ce1407f0c88,\n        0x2e6b0578d98a7067d98c79b2b1dd2cb76393e6356061146637e5240d34ed6955\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHAKE128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA3::Tests::SHAKE128 that contains the following definitions: (1) imports for the Keccak bit-ordering utilities (qualified) and the SHAKE128 instantiation providing the extendable-output function; (2) a polymorphic function computeCavpTestVector with size parameters k and l and constraints that k and l are finite. The function takes a bit vector message of length 8 times the ceiling of k divided by 8 and an expected output of length l, and returns a Boolean. It must truncate the byte-aligned message to exactly k bits using the Keccak bit-ordering helper, apply the SHAKE128 extendable-output function to produce l output bits, and compare the result to the expected value; (3) properties named k0, k1, k2, k3, k265, and k266. Each property specializes the function at the given k (0, 1, 2, 3, 265, 266 respectively), supplies a correctly byte-aligned message representing that many input bits (empty for 0; single\/few-bit values encoded in the leading bits for 1\u20133; specific multi-byte messages for 265 and 266), and checks that the computed output equals the official NIST CAVP SHAKE128 test vector for that case. Use an output length of 512 bits for k in {0,1,2,3} and 128 bits for k in {265,266}. For each property, bind the expected output to the appropriate test-vector constant locally and pass it to the function. Ensure all types are explicit, constraints are stated, and the imports are qualified as needed for truncation and the XOF call."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHAKE128 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE128\n\ncomputeCavpTestVector : {k, l} (fin k, fin l) => [8 * (k \/^ 8)] -> [l] -> Bool\ncomputeCavpTestVector msg expectedResult = result == expectedResult where\n    result = xof (KBO::truncate`{k, 8 * (k \/^ 8)} msg)\n\nproperty k0 = computeCavpTestVector`{0} [] expected_result where\n    expected_result = join [\n        0x7f9c2ba4e88f827d616045507605853e,\n        0xd73b8093f6efbc88eb1a6eacfa66ef26,\n        0x3cb1eea988004b93103cfb0aeefd2a68,\n        0x6e01fa4a58e8a3639ca8a1e3f9ae57e2\n    ]\n\nproperty k1 = computeCavpTestVector`{1} 0x00 expected_result where\n    expected_result = join [\n        0xe78b86559a9ccdc72288bf7bcf8e11d5,\n        0x74543a2922978913a02be149e89d03ca,\n        0xe63d2c36e2cf6906791b187d7e371d4f,\n        0x21ebe59dcfc249a510b82255a18250dd\n    ]\n\nproperty k2 = computeCavpTestVector`{2} 0x03 expected_result where\n    expected_result = join [\n        0xf6b6c4093f0a2ceba61b9f2c2fea2ca2,\n        0x38ce9005edcd588c380405070532ddd0,\n        0x0cbd3a3a7448017d874c52c9e383fa3d,\n        0xb1c184e023181fcc8550f53ac92feca5\n    ]\n\nproperty k3 = computeCavpTestVector`{3} 0x06 expected_result where\n    expected_result = join [\n        0x178afb3be00c33b682f0c920520699e3,\n        0xb7e4c360274fd8b41cdeaa8d3c675bdc,\n        0x079be55d4513e7479aa903169430f0a0,\n        0xbf60169becd0ff9ff3ff6be24bc6fd83\n    ]\n\nproperty k265 = computeCavpTestVector`{265} msg expected_output where\n    msg = 0xa4fb52a45c1e49e1805ccbe419ef3c57b773d84eaa478ed07536129480572e080d01\n    expected_output = 0xf5e3f9934cfa817d75e8db5dce000977\n\nproperty k266 = computeCavpTestVector`{266} msg expectedResult where\n    msg = 0x01de90ca986e1abd50d28ad9f82cc77b45ebd99d19fa4bab0437d3930c27351ca900\n    expectedResult = 0xc47bb657d4f474cd5fa0f29537b85a7a\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains the following definitions: (1) an import of a 384-bit SHA-3 hash implementation exposing a word-oriented hash returning a 384-bit digest and a byte-oriented hash returning a 48-byte digest; (2) a property that checks the hash of the empty byte sequence (type [0][8]) equals a fixed 384-bit expected digest constant; (3) a property that checks the hash of a specific 64-bit message word equals a fixed 384-bit expected digest constant; (4) a property that, for a specific 72-bit message word and its 384-bit expected digest, checks both: (a) the word-oriented hash of the word equals the expected digest, and (b) the byte-oriented hash of the message expressed as a sequence of 8-bit bytes equals the expected digest expressed as a sequence of 8-bit bytes. Use a consistent big-endian conversion between bitvectors and byte sequences. Provide type signatures: word-hash has type [n] -> [384]; byte-hash has type [m][8] -> [48][8]; the 64-bit message is [64], the 72-bit message is [72], the empty message is [0][8], the digest constants are [384] (and [48][8] when expressed as bytes). Use known-answer test values for the empty message, the 64-bit message, and the 72-bit message corresponding to SHA-3-384. Do not implement the hash; only define the properties and the associated constants and type signatures."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_384 where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384 as SHA3_384\n\nproperty t1 = SHA3_384::hash [] == output where\n    output = join [\n        0x0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61,\n        0x995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004\n    ]\n\nproperty t64 = SHA3_384::hash 0x72189b5f18121fb7 == output where\n    output = join [\n        0xb5be454e64fb00d8ebf23cece42fdcf20e88bb5067ab17c2,\n        0x19068b1533eb485341a84a933f837d9abd65b62604936469\n    ]\n\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_384::hash input == output\n    hashBytesWorks = SHA3_384::hashBytes (split input) == split output\n    input = 0xa36e5a59043b6333d7\n    output = join [\n        0xbd045661663436d07720ff3c8b6f922066dfe244456a56ca,\n        0x46dfb3f7e271116d932107c7b04cc7c60173e08d0c2e107c\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHAKE256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 that contains the following definitions: properties k5, k6, k7, and k8. Import the SHAKE256 instantiation that provides the extendable-output function xof. Treat xof as taking a finite sequence of bits and returning a 512-bit value. For each property: introduce a local constant for the expected 512-bit digest, built by concatenating four 128-bit hexadecimal words, then assert that xof applied to the test input equals this local expected value. Use these inputs: k5 uses the empty bit sequence (length 0); k6 uses a 1-bit sequence with value 0; k7 uses a 2-bit sequence with value 3 (binary 11); k8 uses a 3-bit sequence with value 6 (binary 110). State the intended types: the inputs are sequences of bits of lengths 0, 1, 2, and 3, respectively, and each expected digest is a 512-bit value. Each property must be a boolean equality suitable for solver checking. Do not add any other functions or constants beyond the local expected digest bindings inside each property."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256\n\nproperty k5 = xof [] == expected_result where\n    expected_result = join [\n        0x46b9dd2b0ba88d13233b3feb743eeb24,\n        0x3fcd52ea62b81b82b50c27646ed5762f,\n        0xd75dc4ddd8c0f200cb05019d67b592f6,\n        0xfc821c49479ab48640292eacb3b7c4be\n    ]\n\nproperty k6 = xof 0b0 == expected_result where\n    expected_result = join [\n        0x1e20b13f3bdb730d286913335c092bce,\n        0xc0eb1aff2798c05736faa93bd665807a,\n        0x48ed7652aefd600427e9f797d647b9b3,\n        0x55d30410d71b8e275a676545600f1c35\n    ]\n\nproperty k7 = xof 0b11 == expected_result where\n    expected_result = join [\n        0x4f86b0eb85f7a9f6dc38b622706948ad,\n        0xb2beb6dd6911b5e9d865fd1f9667b5c0,\n        0x2a0dbb39c488b040a18ff3885f04ef95,\n        0x7c98f3948e6b7959a9b8950ffd6345d5\n    ]\n\nproperty k8 = xof 0b110 == expected_result where\n    expected_result = join [\n        0x27b5f40b3645215e370472ebb06817ae,\n        0xbddbe2cbd3a9a3ba3914da88e5853e70,\n        0x83630e6d51d7a009017d8176c3067329,\n        0xbec8e5f65591d65c5894c40132f1a2ab\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA3::Tests::SHA3_224 that imports the Keccak bit-ordering helpers (aliased as KBO) and the SHA3-224 instantiation, and contains the following properties: t1, t5, t72, and t512. Each property must be a Cryptol property (Bool) that checks a known test vector. Specify: (1) t1 asserts that hashing an empty bitstring with the SHA3-224 hash function yields the expected 224-bit digest constant. (2) t5 asserts that hashing a 5-bit message (produced by truncating a wider value to 5 bits using the KBO truncate helper with an explicit 5-bit size parameter) yields the expected 224-bit digest. (3) t72 defines local bindings input (a 72-bit value) and output (the expected 224-bit digest) and asserts both: hash input == output and hashBytes (split input) == split output, where split converts the 72-bit value to a sequence of bytes and split output represents the digest as 28 bytes; ensure consistent bit\/byte ordering. (4) t512 defines local bindings input (a 512-bit message obtained by joining four 128-bit words) and output (the expected 224-bit digest) and asserts hash input == output. Include appropriate type annotations where helpful (e.g., 5, 72, 512-bit inputs; 224-bit output; hashBytes returns 28 bytes). Ensure no additional definitions are introduced beyond these imports and properties."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_224 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224 as SHA3_224\n\nproperty t1 = SHA3_224::hash [] ==\n    0x6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7\n\nproperty t5 = SHA3_224::hash (KBO::truncate`{5} 0x1f) ==\n    0x65ad282dcf9642a2facc1e7545c58f3b17523e795fee58e4d21b10bf\n\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_224::hash input == output\n    hashBytesWorks = SHA3_224::hashBytes (split input) == split output\n    input = 0xb29373f6f8839bd498\n    output = 0xe02a13fa4770f824bcd69799284878f19bfdc833ac6d865f28b757d0\n\nproperty t512 = SHA3_224::hash input == output where\n    input = join [\n        0xfc286db63e69d24c6962bb515cc32c86,\n        0x67ed0c08ba9f331d1dd2c42de2e1bd0f,\n        0x18edcc870280650cc87011ce6b0709f7,\n        0xfe60033114144c69751717d315dc152f\n    ]\n    output = 0x157fd9f423a498868e233d9d64631f61aa5e8fbc23df413f7826c962\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Keyless::Hash::SHA3::Tests::SHA3_256 that imports Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO and Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256 as SHA3_256, and declares these properties:\n- t1: a property asserting that SHA3_256::hash applied to the empty bit sequence yields a specific 256-bit digest constant.\n- t7: a property asserting that SHA3_256::hash applied to a 7-bit message obtained by truncating an 8-bit word using KBO::truncate produces a specific 256-bit digest.\n- t8: a property asserting that SHA3_256::hash applied to a single 8-bit word produces a specific 256-bit digest.\n- t72: a property that is the conjunction of two checks: (1) SHA3_256::hash of a fixed multi-byte input word equals a specific 256-bit digest; and (2) SHA3_256::hashBytes of the byte-split form of the same input equals the byte-wise split of the expected digest. Use split to convert a bitvector to a sequence of bytes and join to assemble bitvectors where needed. Ensure both comparisons are equalities of the appropriate sizes.\n- t235: a property asserting that SHA3_256::hash of a 235-bit message constructed by concatenating two blocks (via join), with bit-length controlled via KBO operations as needed, equals a specific 256-bit digest similarly constructed by joining two blocks.\nState types and sizes explicitly: digests are 256-bit sequences; inputs are sized bitvectors (0, 7, 8, 72, 235 bits) or sequences of 8-bit words for hashBytes. Each property must compare the computed result to a provided constant using equality, without implementing the hash algorithm."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_256 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256 as SHA3_256\n\nproperty t1 = SHA3_256::hash [] ==\n    0xa7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a\n\nproperty t7 = SHA3_256::hash (KBO::truncate`{7} 0x0b) ==\n    0x9e5f8c800689fa5168fc5fbfeca8bd5b3668ffd6f08143e2e396b9ae0f9b443e\n\nproperty t8 = SHA3_256::hash 0x6a ==\n    0xf35e560e05de779f2669b9f513c2a7ab81dfeb100e2f4ee1fb17354bfa2740ca\n\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_256::hash input == output\n    hashBytesWorks = SHA3_256::hashBytes (split input) == split output\n    input = 0xfb8dfa3a132f9813ac\n    output = 0xfd09b3501888445ffc8c3bb95d106440ceee469415fce1474743273094306e2e\n\nproperty t235 = SHA3_256::hash input == output where\n    input = KBO::truncate`{235} (join [\n        0xd03d466ab65db8e5131a414637174b,\n        0x646d0612977d194dcb75b910d2a903\n    ])\n    output = join [\n        0x06413eb50e238e09843aa51b0b5fb7ca,\n        0x52b87db7d71f384b5b93f57843c89f37\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512 that instantiates the generic SHA3 construction by fixing its type parameter for digest length to 512 bits. The module must re-export the complete API of the generic SHA3 module specialized to this parameter, including all types, type synonyms, and functions, without modification or additional definitions. Clearly state that the digest type is a 512-bit sequence, and ensure any internal type aliases or constraints are resolved to this concrete size. The specification should focus solely on binding the digest-length parameter and exposing the resulting instantiated interface, with no new properties or implementations added."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 512\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384 that instantiates the generic Primitive::Keyless::Hash::SHA3::SHA3 module, fixing its digest-size type parameter to 384 bits. The module must contain a single type binding that sets the digest parameter to the 384-bit width and should otherwise re-export all definitions from the generic module unchanged. Do not add new functions, types, or properties; simply specialize the parameter so that all exported hashes, types, and interfaces operate at a 384-bit digest size under this module name."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 384\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224 that instantiates the generic SHA3 parameterized module with its digest-length type parameter fixed to 224 bits. The module must re-export the entire specialized interface of the base SHA3 module (all types, constraints, and functions) at this fixed digest size and introduce no new declarations. Ensure the module equates the digest type to 224 so that every exported type signature and operation is specialized to a 224-bit digest context."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 224\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256 that instantiates the generic SHA-3 construction with its digest bit-width fixed at 256. Re-export all definitions (functions, types, and properties) from the underlying generic implementation specialized to this setting, ensuring all hashing operations produce 256-bit digests and any digest-related types resolve to 256. Do not alter behaviors or add new definitions; only bind the parameter and expose the specialized API."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 256\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA1\/Tests\/CAVPShortByte.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::SHA1::Tests::CAVPShortByte that imports the SHA1 specification under the alias SHA1 and contains the properties testCase0 through testCase64. For each property, state a boolean assertion that the result of invoking the SHA1 hashing operation with an explicit bit-length parameter l on a fixed message equals a fixed expected digest. Within each property, introduce two local constants: msg, a finite value representing the message of exactly l bits (corresponding to l\/8 whole bytes, derived from a given hexadecimal literal), and md, a 160-bit value representing the expected SHA-1 digest. Constrain l to take values from 0 to 512 in increments of 8. Require types: l is a finite numeric parameter, msg has type [l], and md has type [160]. Configure the hash by providing a record argument that sets the length field to l, and apply it to msg; the property compares that result to md for equality. Do not implement the hashing algorithm; use the imported SHA1 hash. Do not derive the expected digests; use the provided constants. Ensure each property is suitable for checking with Cryptol\u2019s property mechanism."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA1::Tests::CAVPShortByte where\n\nimport Primitive::Keyless::Hash::SHA1::Specification as SHA1\n\nproperty testCase0 = SHA1::hash `{ l = 0 } msg == md\n  where\n    msg = take 0x00\n    md = 0xda39a3ee5e6b4b0d3255bfef95601890afd80709\n\nproperty testCase1 = SHA1::hash `{ l = 8 } msg == md\n  where\n    msg = take 0x36\n    md = 0xc1dfd96eea8cc2b62785275bca38ac261256e278\n\nproperty testCase2 = SHA1::hash `{ l = 16 } msg == md\n  where\n    msg = take 0x195a\n    md = 0x0a1c2d555bbe431ad6288af5a54f93e0449c9232\n\nproperty testCase3 = SHA1::hash `{ l = 24 } msg == md\n  where\n    msg = take 0xdf4bd2\n    md = 0xbf36ed5d74727dfd5d7854ec6b1d49468d8ee8aa\n\nproperty testCase4 = SHA1::hash `{ l = 32 } msg == md\n  where\n    msg = take 0x549e959e\n    md = 0xb78bae6d14338ffccfd5d5b5674a275f6ef9c717\n\nproperty testCase5 = SHA1::hash `{ l = 40 } msg == md\n  where\n    msg = take 0xf7fb1be205\n    md = 0x60b7d5bb560a1acf6fa45721bd0abb419a841a89\n\nproperty testCase6 = SHA1::hash `{ l = 48 } msg == md\n  where\n    msg = take 0xc0e5abeaea63\n    md = 0xa6d338459780c08363090fd8fc7d28dc80e8e01f\n\nproperty testCase7 = SHA1::hash `{ l = 56 } msg == md\n  where\n    msg = take 0x63bfc1ed7f78ab\n    md = 0x860328d80509500c1783169ebf0ba0c4b94da5e5\n\nproperty testCase8 = SHA1::hash `{ l = 64 } msg == md\n  where\n    msg = take 0x7e3d7b3eada98866\n    md = 0x24a2c34b976305277ce58c2f42d5092031572520\n\nproperty testCase9 = SHA1::hash `{ l = 72 } msg == md\n  where\n    msg = take 0x9e61e55d9ed37b1c20\n    md = 0x411ccee1f6e3677df12698411eb09d3ff580af97\n\nproperty testCase10 = SHA1::hash `{ l = 80 } msg == md\n  where\n    msg = take 0x9777cf90dd7c7e863506\n    md = 0x05c915b5ed4e4c4afffc202961f3174371e90b5c\n\nproperty testCase11 = SHA1::hash `{ l = 88 } msg == md\n  where\n    msg = take 0x4eb08c9e683c94bea00dfa\n    md = 0xaf320b42d7785ca6c8dd220463be23a2d2cb5afc\n\nproperty testCase12 = SHA1::hash `{ l = 96 } msg == md\n  where\n    msg = take 0x0938f2e2ebb64f8af8bbfc91\n    md = 0x9f4e66b6ceea40dcf4b9166c28f1c88474141da9\n\nproperty testCase13 = SHA1::hash `{ l = 104 } msg == md\n  where\n    msg = take 0x74c9996d14e87d3e6cbea7029d\n    md = 0xe6c4363c0852951991057f40de27ec0890466f01\n\nproperty testCase14 = SHA1::hash `{ l = 112 } msg == md\n  where\n    msg = take 0x51dca5c0f8e5d49596f32d3eb874\n    md = 0x046a7b396c01379a684a894558779b07d8c7da20\n\nproperty testCase15 = SHA1::hash `{ l = 120 } msg == md\n  where\n    msg = take 0x3a36ea49684820a2adc7fc4175ba78\n    md = 0xd58a262ee7b6577c07228e71ae9b3e04c8abcda9\n\nproperty testCase16 = SHA1::hash `{ l = 128 } msg == md\n  where\n    msg = take 0x3552694cdf663fd94b224747ac406aaf\n    md = 0xa150de927454202d94e656de4c7c0ca691de955d\n\nproperty testCase17 = SHA1::hash `{ l = 136 } msg == md\n  where\n    msg = take 0xf216a1cbde2446b1edf41e93481d33e2ed\n    md = 0x35a4b39fef560e7ea61246676e1b7e13d587be30\n\nproperty testCase18 = SHA1::hash `{ l = 144 } msg == md\n  where\n    msg = take 0xa3cf714bf112647e727e8cfd46499acd35a6\n    md = 0x7ce69b1acdce52ea7dbd382531fa1a83df13cae7\n\nproperty testCase19 = SHA1::hash `{ l = 152 } msg == md\n  where\n    msg = take 0x148de640f3c11591a6f8c5c48632c5fb79d3b7\n    md = 0xb47be2c64124fa9a124a887af9551a74354ca411\n\nproperty testCase20 = SHA1::hash `{ l = 160 } msg == md\n  where\n    msg = take 0x63a3cc83fd1ec1b6680e9974a0514e1a9ecebb6a\n    md = 0x8bb8c0d815a9c68a1d2910f39d942603d807fbcc\n\nproperty testCase21 = SHA1::hash `{ l = 168 } msg == md\n  where\n    msg = take 0x875a90909a8afc92fb7070047e9d081ec92f3d08b8\n    md = 0xb486f87fb833ebf0328393128646a6f6e660fcb1\n\nproperty testCase22 = SHA1::hash `{ l = 176 } msg == md\n  where\n    msg = take 0x444b25f9c9259dc217772cc4478c44b6feff62353673\n    md = 0x76159368f99dece30aadcfb9b7b41dab33688858\n\nproperty testCase23 = SHA1::hash `{ l = 184 } msg == md\n  where\n    msg = take 0x487351c8a5f440e4d03386483d5fe7bb669d41adcbfdb7\n    md = 0xdbc1cb575ce6aeb9dc4ebf0f843ba8aeb1451e89\n\nproperty testCase24 = SHA1::hash `{ l = 192 } msg == md\n  where\n    msg = take 0x46b061ef132b87f6d3b0ee2462f67d910977da20aed13705\n    md = 0xd7a98289679005eb930ab75efd8f650f991ee952\n\nproperty testCase25 = SHA1::hash `{ l = 200 } msg == md\n  where\n    msg = take 0x3842b6137bb9d27f3ca5bafe5bbb62858344fe4ba5c41589a5\n    md = 0xfda26fa9b4874ab701ed0bb64d134f89b9c4cc50\n\nproperty testCase26 = SHA1::hash `{ l = 208 } msg == md\n  where\n    msg = take 0x44d91d3d465a4111462ba0c7ec223da6735f4f5200453cf132c3\n    md = 0xc2ff7ccde143c8f0601f6974b1903eb8d5741b6e\n\nproperty testCase27 = SHA1::hash `{ l = 216 } msg == md\n  where\n    msg = take 0xcce73f2eabcb52f785d5a6df63c0a105f34a91ca237fe534ee399d\n    md = 0x643c9dc20a929608f6caa9709d843ca6fa7a76f4\n\nproperty testCase28 = SHA1::hash `{ l = 224 } msg == md\n  where\n    msg = take 0x664e6e7946839203037a65a12174b244de8cbc6ec3f578967a84f9ce\n    md = 0x509ef787343d5b5a269229b961b96241864a3d74\n\nproperty testCase29 = SHA1::hash `{ l = 232 } msg == md\n  where\n    msg = take 0x9597f714b2e45e3399a7f02aec44921bd78be0fefee0c5e9b499488f6e\n    md = 0xb61ce538f1a1e6c90432b233d7af5b6524ebfbe3\n\nproperty testCase30 = SHA1::hash `{ l = 240 } msg == md\n  where\n    msg = take 0x75c5ad1f3cbd22e8a95fc3b089526788fb4ebceed3e7d4443da6e081a35e\n    md = 0x5b7b94076b2fc20d6adb82479e6b28d07c902b75\n\nproperty testCase31 = SHA1::hash `{ l = 248 } msg == md\n  where\n    msg = take 0xdd245bffe6a638806667768360a95d0574e1a0bd0d18329fdb915ca484ac0d\n    md = 0x6066db99fc358952cf7fb0ec4d89cb0158ed91d7\n\nproperty testCase32 = SHA1::hash `{ l = 256 } msg == md\n  where\n    msg = take 0x0321794b739418c24e7c2e565274791c4be749752ad234ed56cb0a6347430c6b\n    md = 0xb89962c94d60f6a332fd60f6f07d4f032a586b76\n\nproperty testCase33 = SHA1::hash `{ l = 264 } msg == md\n  where\n    msg = take 0x4c3dcf95c2f0b5258c651fcd1d51bd10425d6203067d0748d37d1340d9ddda7db3\n    md = 0x17bda899c13d35413d2546212bcd8a93ceb0657b\n\nproperty testCase34 = SHA1::hash `{ l = 272 } msg == md\n  where\n    msg = take 0xb8d12582d25b45290a6e1bb95da429befcfdbf5b4dd41cdf3311d6988fa17cec0723\n    md = 0xbadcdd53fdc144b8bf2cc1e64d10f676eebe66ed\n\nproperty testCase35 = SHA1::hash `{ l = 280 } msg == md\n  where\n    msg = take 0x6fda97527a662552be15efaeba32a3aea4ed449abb5c1ed8d9bfff544708a425d69b72\n    md = 0x01b4646180f1f6d2e06bbe22c20e50030322673a\n\nproperty testCase36 = SHA1::hash `{ l = 288 } msg == md\n  where\n    msg = take 0x09fa2792acbb2417e8ed269041cc03c77006466e6e7ae002cf3f1af551e8ce0bb506d705\n    md = 0x10016dc3a2719f9034ffcc689426d28292c42fc9\n\nproperty testCase37 = SHA1::hash `{ l = 296 } msg == md\n  where\n    msg = take 0x5efa2987da0baf0a54d8d728792bcfa707a15798dc66743754406914d1cfe3709b1374eaeb\n    md = 0x9f42fa2bce6ef021d93c6b2d902273797e426535\n\nproperty testCase38 = SHA1::hash `{ l = 304 } msg == md\n  where\n    msg = take 0x2836de99c0f641cd55e89f5af76638947b8227377ef88bfba662e5682babc1ec96c6992bc9a0\n    md = 0xcdf48bacbff6f6152515323f9b43a286e0cb8113\n\nproperty testCase39 = SHA1::hash `{ l = 312 } msg == md\n  where\n    msg = take 0x42143a2b9e1d0b354df3264d08f7b602f54aad922a3d63006d097f683dc11b90178423bff2f7fe\n    md = 0xb88fb75274b9b0fd57c0045988cfcef6c3ce6554\n\nproperty testCase40 = SHA1::hash `{ l = 320 } msg == md\n  where\n    msg = take 0xeb60c28ad8aeda807d69ebc87552024ad8aca68204f1bcd29dc5a81dd228b591e2efb7c4df75ef03\n    md = 0xc06d3a6a12d9e8db62e8cff40ca23820d61d8aa7\n\nproperty testCase41 = SHA1::hash `{ l = 328 } msg == md\n  where\n    msg = take 0x7de4ba85ec54747cdc42b1f23546b7e490e31280f066e52fac117fd3b0792e4de62d5843ee98c72015\n    md = 0x6e40f9e83a4be93874bc97cdebb8da6889ae2c7a\n\nproperty testCase42 = SHA1::hash `{ l = 336 } msg == md\n  where\n    msg = take 0xe70653637bc5e388ccd8dc44e5eace36f7398f2bac993042b9bc2f4fb3b0ee7e23a96439dc01134b8c7d\n    md = 0x3efc940c312ef0dfd4e1143812248db89542f6a5\n\nproperty testCase43 = SHA1::hash `{ l = 344 } msg == md\n  where\n    msg = take 0xdd37bc9f0b3a4788f9b54966f252174c8ce487cbe59c53c22b81bf77621a7ce7616dcb5b1e2ee63c2c309b\n    md = 0xa0cf03f7badd0c3c3c4ea3717f5a4fb7e67b2e56\n\nproperty testCase44 = SHA1::hash `{ l = 352 } msg == md\n  where\n    msg = take 0x5f485c637ae30b1e30497f0fb7ec364e13c906e2813daa34161b7ac4a4fd7a1bddd79601bbd22cef1f57cbc7\n    md = 0xa544e06f1a07ceb175a51d6d9c0111b3e15e9859\n\nproperty testCase45 = SHA1::hash `{ l = 360 } msg == md\n  where\n    msg = take 0xf6c237fb3cfe95ec8414cc16d203b4874e644cc9a543465cad2dc563488a659e8a2e7c981e2a9f22e5e868ffe1\n    md = 0x199d986ed991b99a071f450c6b1121a727e8c735\n\nproperty testCase46 = SHA1::hash `{ l = 368 } msg == md\n  where\n    msg = take 0xda7ab3291553c659873c95913768953c6e526d3a26590898c0ade89ff56fbd110f1436af590b17fed49f8c4b2b1e\n    md = 0x33bac6104b0ad6128d091b5d5e2999099c9f05de\n\nproperty testCase47 = SHA1::hash `{ l = 376 } msg == md\n  where\n    msg = take 0x8cfa5fd56ee239ca47737591cba103e41a18acf8e8d257b0dbe8851134a81ff6b2e97104b39b76e19da256a17ce52d\n    md = 0x76d7db6e18c1f4ae225ce8ccc93c8f9a0dfeb969\n\nproperty testCase48 = SHA1::hash `{ l = 384 } msg == md\n  where\n    msg = take 0x57e89659d878f360af6de45a9a5e372ef40c384988e82640a3d5e4b76d2ef181780b9a099ac06ef0f8a7f3f764209720\n    md = 0xf652f3b1549f16710c7402895911e2b86a9b2aee\n\nproperty testCase49 = SHA1::hash `{ l = 392 } msg == md\n  where\n    msg = take 0xb91e64235dbd234eea2ae14a92a173ebe835347239cff8b02074416f55c6b60dc6ced06ae9f8d705505f0d617e4b29aef9\n    md = 0x63faebb807f32be708cf00fc35519991dc4e7f68\n\nproperty testCase50 = SHA1::hash `{ l = 400 } msg == md\n  where\n    msg = take 0xe42a67362a581e8cf3d847502215755d7ad425ca030c4360b0f7ef513e6980265f61c9fa18dd9ce668f38dbc2a1ef8f83cd6\n    md = 0x0e6730bc4a0e9322ea205f4edfff1fffda26af0a\n\nproperty testCase51 = SHA1::hash `{ l = 408 } msg == md\n  where\n    msg = take 0x634db92c22010e1cbf1e1623923180406c515272209a8acc42de05cc2e96a1e94c1f9f6b93234b7f4c55de8b1961a3bf352259\n    md = 0xb61a3a6f42e8e6604b93196c43c9e84d5359e6fe\n\nproperty testCase52 = SHA1::hash `{ l = 416 } msg == md\n  where\n    msg = take 0xcc6ca3a8cb391cd8a5aff1faa7b3ffbdd21a5a3ce66cfaddbfe8b179e4c860be5ec66bd2c6de6a39a25622f9f2fcb3fc05af12b5\n    md = 0x32d979ca1b3ed0ed8c890d99ec6dd85e6c16abf4\n\nproperty testCase53 = SHA1::hash `{ l = 424 } msg == md\n  where\n    msg = take 0x7c0e6a0d35f8ac854c7245ebc73693731bbbc3e6fab644466de27bb522fcb99307126ae718fe8f00742e6e5cb7a687c88447cbc961\n    md = 0x6f18190bd2d02fc93bce64756575cea36d08b1c3\n\nproperty testCase54 = SHA1::hash `{ l = 432 } msg == md\n  where\n    msg = take 0xc5581d40b331e24003901bd6bf244aca9e9601b9d81252bb38048642731f1146b8a4c69f88e148b2c8f8c14f15e1d6da57b2daa9991e\n    md = 0x68f525feea1d8dbe0117e417ca46708d18d7629a\n\nproperty testCase55 = SHA1::hash `{ l = 440 } msg == md\n  where\n    msg = take 0xec6b4a88713df27c0f2d02e738b69db43abda3921317259c864c1c386e9a5a3f533dc05f3beeb2bec2aac8e06db4c6cb3cddcf697e03d5\n    md = 0xa7272e2308622ff7a339460adc61efd0ea8dabdc\n\nproperty testCase56 = SHA1::hash `{ l = 448 } msg == md\n  where\n    msg = take 0x0321736beba578e90abc1a90aa56157d871618f6de0d764cc8c91e06c68ecd3b9de3824064503384db67beb7fe012232dacaef93a000fba7\n    md = 0xaef843b86916c16f66c84d83a6005d23fd005c9e\n\nproperty testCase57 = SHA1::hash `{ l = 456 } msg == md\n  where\n    msg = take 0xd0a249a97b5f1486721a50d4c4ab3f5d674a0e29925d5bf2678ef6d8d521e456bd84aa755328c83fc890837726a8e7877b570dba39579aabdd\n    md = 0xbe2cd6f380969be59cde2dff5e848a44e7880bd6\n\nproperty testCase58 = SHA1::hash `{ l = 464 } msg == md\n  where\n    msg = take 0xc32138531118f08c7dcc292428ad20b45ab27d9517a18445f38b8f0c2795bcdfe3ffe384e65ecbf74d2c9d0da88398575326074904c1709ba072\n    md = 0xe5eb4543deee8f6a5287845af8b593a95a9749a1\n\nproperty testCase59 = SHA1::hash `{ l = 472 } msg == md\n  where\n    msg = take 0xb0f4cfb939ea785eabb7e7ca7c476cdd9b227f015d905368ba00ae96b9aaf720297491b3921267576b72c8f58d577617e844f9f0759b399c6b064c\n    md = 0x534c850448dd486787b62bdec2d4a0b140a1b170\n\nproperty testCase60 = SHA1::hash `{ l = 480 } msg == md\n  where\n    msg = take 0xbd02e51b0cf2c2b8d204a026b41a66fbfc2ac37ee9411fc449c8d1194a0792a28ee731407dfc89b6dfc2b10faa27723a184afef8fd83def858a32d3f\n    md = 0x6fbfa6e4edce4cc85a845bf0d228dc39acefc2fa\n\nproperty testCase61 = SHA1::hash `{ l = 488 } msg == md\n  where\n    msg = take 0xe33146b83e4bb671392218da9a77f8d9f5974147182fb95ba662cb66011989c16d9af104735d6f79841aa4d1df276615b50108df8a29dbc9de31f4260d\n    md = 0x018872691d9b04e8220e09187df5bc5fa6257cd9\n\nproperty testCase62 = SHA1::hash `{ l = 496 } msg == md\n  where\n    msg = take 0x411c13c75073c1e2d4b1ecf13139ba9656cd35c14201f1c7c6f0eeb58d2dbfe35bfdeccc92c3961cfabb590bc1eb77eac15732fb0275798680e0c7292e50\n    md = 0xd98d512a35572f8bd20de62e9510cc21145c5bf4\n\nproperty testCase63 = SHA1::hash `{ l = 504 } msg == md\n  where\n    msg = take 0xf2c76ef617fa2bfc8a4d6bcbb15fe88436fdc2165d3074629579079d4d5b86f5081ab177b4c3f530376c9c924cbd421a8daf8830d0940c4fb7589865830699\n    md = 0x9f3ea255f6af95c5454e55d7354cabb45352ea0b\n\nproperty testCase64 = SHA1::hash `{ l = 512 } msg == md\n  where\n    msg = take 0x45927e32ddf801caf35e18e7b5078b7f5435278212ec6bb99df884f49b327c6486feae46ba187dc1cc9145121e1492e6b06e9007394dc33b7748f86ac3207cfe\n    md = 0xa70cfbfe7563dd0e665c7c6715a96a8d756950c0\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Scheme\/RSAES_OAEP.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Scheme::RSAES_OAEP that contains the following definitions: (1) Type parameters k and hLen (finite naturals, k>=1, hLen>=1), with KeySize = k*8 bits. (2) A polymorphic hash function returning hLen bytes, constrained so 2*hLen is at least the bit-width of any hashed input. (3) RSA key components n, e, d as KeySize-bit values. (4) A function RSAES_OAEP_ENCRYPT that, for finite l and mLen with l>=0, 2*hLen >= width(8*l) and width(8*(k - hLen + 3)), k >= mLen + 2*hLen + 2, and 2^^32*hLen >= k - hLen - 1, takes a 256-bit randomness value, an mLen-byte message, and an l-byte label, and returns a k-byte ciphertext. Specify that it OAEP-encodes (using MGF1 and hash), converts to an integer, applies RSA encryption with (n,e), and converts back to k bytes. (5) A function RSAES_OAEP_DECRYPT with analogous size constraints (and k >= 2*hLen + 2) that takes a k-byte ciphertext and an l-byte label and returns the recovered message block of k - hLen - 1 bytes together with its length index. It rejects if the ciphertext integer is out of range, if the leading byte is nonzero, or if the embedded label hash mismatches. (6) Define a property that checks: for any randomness, label, and message meeting the constraints, decrypt(encrypt(...)) yields in its first component the original message padded with zeros. (7) Functions EME_OAEP_encode and EME_OAEP_decode that implement OAEP encoding\/decoding with lHash = hash(label), zero padding, 0x01 delimiter, and the standard seed\/data masking using MGF1. (8) A private helper extractMsg that scans a byte array to remove leading zeros up to the first 0x01 and returns the padded message and its remaining-length index. (9) A function MGF1 that, given a seed and mask length, hashes seed||counter for counters 0..ceil(maskLen\/hLen)-1 (4-byte big-endian), concatenates digests, and truncates to maskLen, under the usual OAEP counter and width constraints. Import the RSA cipher module providing OS2IP\/I2OSP, RSAEP, and RSADP."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Scheme::RSAES_OAEP where\n\nimport Primitive::Asymmetric::Cipher::RSA\n\nparameter\n  type k : #\n  type constraint (fin k, k >= 1)\n\n  type hLen : #   type constraint (fin hLen, hLen >= 1)\n\n  hash : {a} (2 * hLen >= width (8 * a) ) => [a][8] -> [8 * hLen]\n\n  type KeySize = k * 8\n  n : [KeySize]\n  e : [KeySize]\n  d : [KeySize]\n\nRSAES_OAEP_ENCRYPT : {l,mLen}\n                   (fin l, fin mLen\n                   , l>=0\n                   , 2 * hLen >= width (8 * l)                    , 2 * hLen >= width (8 * ( k - hLen + 3))                    , k >= mLen+2*hLen+2\n                   , 2^^32*hLen >= k - hLen - 1                    )\n                   => [256]                    -> [mLen][8]\n                   -> [l][8]\n                   -> [k][8]\nRSAES_OAEP_ENCRYPT rand M L = I2OSP`{k} c                    where\n                    EM = EME_OAEP_encode rand (M, L)                       m  = (zero # OS2IP EM) : [KeySize]                      c  = RSAEP ((n, e), m)   \n\nRSAES_OAEP_DECRYPT : {l}\n                   (fin l\n                   , l>=0\n                   , 2 * hLen >= width (8 * l)                    , 2 * hLen >= width (8 * (k - hLen + 3))                    , k >= 2 * hLen + 2\n                   , 2^^32*hLen >= k - hLen - 1                    ) => [k][8] -> [l][8] -> ([k - hLen - 1][8], [width (k - hLen - 1)])\nRSAES_OAEP_DECRYPT C L = if c < 0 \\\/ c >= n then error \"decryption error\"\n                         else M\n                   where\n                    c  = OS2IP C\n                    m  = RSADP ((n,d),c)\n                    EM = I2OSP`{k} m\n                    M  = EME_OAEP_decode (EM, L)\n\nRSAES_OAEP_Correct : {l,mLen}\n                   (fin l, fin mLen\n                   , 2 * hLen >= width (8 * l)                    , 2 * hLen >= width (8 * (k - hLen + 3))                    , k >= mLen+2*hLen+2\n                   , 2^^32*hLen >= k - hLen - 1                    )\n                   => [256]                    -> [l][8]\n                   -> [mLen][8]\n                   -> Bit\nproperty RSAES_OAEP_Correct r l m = (RSAES_OAEP_DECRYPT (RSAES_OAEP_ENCRYPT r m l) l).0 == m#(zero:[_][8])\n\nEME_OAEP_encode : {l,mLen}\n         (fin l,fin mLen\n         , l >= 0\n         , 2 * hLen >= width (8 * l)          , 2 * hLen >= width (8 * ( k - hLen + 3))          , k >= mLen + 2 * hLen + 2\n         , 2^^32*hLen >= k - hLen - 1          )\n         => [256]          -> ([mLen][8], [l][8])\n         -> [k][8]\nEME_OAEP_encode rseed (M,L) = (zero : [1][8]) # maskedSeed # maskedDB          where\n          lHash      = split (hash L) : [hLen][8]\n          PS         = (zero:[(k-mLen-2*hLen-2)][8])           DB         = lHash # PS # [(1:[8])] # M\n          seed       = random rseed : [hLen][8]\n          dbMask     = MGF1`{maskLen=(k-hLen-1)} seed\n          maskedDB   = DB ^ dbMask\n          seedMask   = MGF1`{maskLen=hLen} maskedDB\n          maskedSeed = seed ^ seedMask\n\nEME_OAEP_decode : {l}\n         (fin l\n         , l>=0\n         , 2*hLen >= width (8 * l)          , 2*hLen >= width (8 * ( k - hLen + 3))          , k >= 2 * hLen + 2\n         , 2^^32*hLen >= k - hLen - 1          ) => ([k][8], [l][8]) -> ([k - hLen - 1][8], [width (k - hLen - 1)])\nEME_OAEP_decode (EM,L) = if Y != zero then error \"decryption error\"\n                         | lHash' != lHash then error \"decryption error\"\n                         else (Mpadded,mLen)\n                where\n                  Y          = head EM\n                  maskedSeed = take`{hLen} (drop`{1} EM)\n                  maskedDB   = drop`{hLen+1} EM\n                  seedMask   = MGF1`{maskLen=hLen} maskedDB\n                  seed       = seedMask ^ maskedSeed\n                  dbMask     = MGF1`{maskLen=k-hLen-1} seed\n                  DB         = maskedDB ^ dbMask \/\/ lHash' # (zero:[_][8]) # [(1:[8])] # M\n                  lHash'     = take`{hLen} DB \/\/ This should equal hash L\n                  lHash      = split (hash L) : [_][8]\n                  (Mpadded,mLen) = extractMsg DB \/\/ Original msg is take`{mLen} Mpadded\n\nprivate\n    extractMsg : {a} (fin a, a >= 1) =>  [a][8] -> ([a][8],[width a])\n    extractMsg DB = (Mpadded, mLen)\n                where\n                 init    = {removedPad = False,\n                            padMsg     = DB,\n                            idx        = (`a:[width a])}\n                 ys      = [init] # [ if (~y.removedPad \/\\ x==(1:[8]) )\n                                          then {removedPad = True,\n                                                padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                idx        = y.idx - 1}\n                                          | y.removedPad\n                                          then y\n                                          else {removedPad = False,\n                                                padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                idx        = y.idx - 1}\n                                    | x <- DB\n                                    | y <- ys ]\n                 Mpadded = (ys!0).padMsg\n                 mLen    = (ys!0).idx\n\nMGF1 : {maskLen,l,counterMax}\n       (fin hLen, fin l, fin maskLen\n       , hLen >= 1\n       , maskLen >= 1\n       , 2*hLen >= width (8 * (4 + l))\n       , 2^^32 * hLen >= maskLen\n       , counterMax == maskLen\/^hLen - 1 \/\/ (ceiling maskLen\/hLen) - 1\n       )\n       => [l][8] \/\/ MGF Seed\n       -> [maskLen][8]\nMGF1 mgfSeed = take`{maskLen} Ts\n     where\n\n      Cs = map (\\counter -> I2OSP`{xLen=4} counter) ([0..counterMax]:[_][32])\n      Ts = join [ split (hash (mgfSeed # c)) : [_][8] | c <- Cs]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Scheme\/RSAES_PKCS1_v1_5.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Scheme::RSAES_PKCS1_v1_5 that contains the following definitions. Import the RSA cipher module it depends on. Declare a type parameter k with constraints that it is finite and at least 11. Define a type alias KeySize = k * 8. Declare public parameters n, e, and d as bitvectors of length KeySize (modulus and public\/private exponents). Define a function RSAES_PKCS1_v1_5_Encrypt with a dependent type: for any mLen satisfying 1 \u2264 mLen \u2264 k \u2212 11, it takes a random padding byte array of length k \u2212 mLen \u2212 3 and a message byte array of length mLen, and returns a k-byte ciphertext. Its behavior: build the encoded message as 0x00 || 0x01 || random padding || 0x00 || message; convert this byte array to an integer; apply RSA public-key encryption with (n, e); convert the result back to a k-byte array. Define a function RSAES_PKCS1_v1_5_Decrypt of type k-byte ciphertext to a pair of a k-byte array and an index of type [width k]. Its behavior: convert the ciphertext to an integer; if it is \u2265 n, signal a decryption error; otherwise apply RSA private-key decryption with (n, d); convert the integer to a k-byte array; then decode it using a private helper. Define a private helper EME_PKCS1_v1_5_decode of type k-byte array to a pair (k-byte array, [width k]) that validates: first byte is 0x00, second is 0x01, there exists a 0x00 delimiter after the padding, and the inferred message length satisfies mLen + 11 \u2264 k; on failure, signal a decryption error; on success, return the padded message and the message length index. Finally, define a property RSAES_PKCS1_Correct (with the same mLen constraints and argument types as the encryptor) that asserts: decrypt(encrypt(random, message)).first, truncated to mLen bytes, equals the original message."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Scheme::RSAES_PKCS1_v1_5 where\n\nimport Primitive::Asymmetric::Cipher::RSA\n\nparameter\n\n  type k : #\n  type constraint (fin k, k >= 11)\n\n  type KeySize = k * 8\n  n : [KeySize]\n  e : [KeySize]\n  d : [KeySize]\n\nRSAES_PKCS1_v1_5_Encrypt : {mLen} (mLen <= k - 11, mLen >= 1)\n                         => [k-mLen-3][8] -> [mLen][8] -> [k][8]\nRSAES_PKCS1_v1_5_Encrypt rand M = I2OSP`{k} c\n                         where\n                          PS = rand                           EM = ( zero : [1][8] ) # [( 1 : [8])] # PS # ( zero : [1][8] ) # M\n                          m  = OS2IP EM\n                          c  = RSAEP ((n,e),m)\n\nRSAES_PKCS1_v1_5_Decrypt : [k][8] -> ([k][8],[width k])\nRSAES_PKCS1_v1_5_Decrypt C = if c >= n then error \"decryption error\" else (Mp,idx)                          where\n                          c        = OS2IP C\n                          m        = RSADP ((n,d),c)\n                          EM       = I2OSP`{k} m\n                          (Mp,idx) = EME_PKCS1_v1_5_decode EM\n\nRSAES_PKCS1_Correct : {mLen} (mLen <= k - 11, mLen >= 1) =>\n                    [k-mLen-3][8] -> [mLen][8] -> Bit\nproperty RSAES_PKCS1_Correct rand M = take`{mLen} ((D ( E rand M ) ).0) == M\n         where\n          D = RSAES_PKCS1_v1_5_Decrypt\n          E = RSAES_PKCS1_v1_5_Encrypt\n\nprivate\n\n        EME_PKCS1_v1_5_decode : [k][8] -> ([k][8],[width k])\n        EME_PKCS1_v1_5_decode EM = if (ys!0).removedPad == False then error \"decryption error\"\n                                    | firstOctet != zero then error \"decryption error\"\n                                    | secondOctet != (1:[8]) then error \"decryption error\"\n                                    | mLen + 11 > `k then error \"decryption error\"\n                                   else (Mpadded, mLen)\n                   where\n                    firstOctet  = EM@0\n                    secondOctet = EM@1\n                    init        = {removedPad = False,\n                                   padMsg     = (tail EM)#(zero:[1][8]),\n                                   idx        = (`k-1):[width k]}\n                    ys          = [init] # [ if (~y.removedPad \/\\ x==zero)\n                                             then {removedPad = True,\n                                                   padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                   idx        = y.idx - 1}\n                                             | y.removedPad\n                                             then y\n                                             else {removedPad = False,\n                                                   padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                   idx        = y.idx - 1}\n                                       | x <- tail EM\n                                       | y <- ys ]\n                    Mpadded     = (ys!0).padMsg\n                    mLen        = (ys!0).idx\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/RSA_PSS.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::RSA_PSS that contains the following definitions, types, and constraints: (1) Two parameters: a finite positive natural for the hash output length in bytes, and a message-width upper bound that constrains all hashed inputs. (2) A polymorphic hashing function that accepts n bytes (with finite n and total bit-width within the bound) and returns exactly the configured number of hash-output bytes. (3) An MGF1 function parameterized by seed length and mask length, with finiteness and width constraints, which iteratively hashes the seed concatenated with a 32-bit counter encoded as 4 bytes, concatenates the results, and truncates to the requested mask length. (4) A PSS-encoding function using MGF1 that, given a message digest and a salt (both of the configured hash length) and an output length that is at least twice the hash length plus two, builds the data block with the required zero-padding and delimiter, computes the hash of the PSS message, masks the data block, appends the hash and the standard trailer, and clears the most significant bit of the first byte. (5) A PSS-verification function that performs the inverse checks: trailer byte, cleared leading bit, unmasking with MGF1, correct padding and delimiter, and recomputed hash equality. (6) An RSA signing function that encodes with PSS, interprets the result as a big-endian integer, exponentiates with the private exponent, and reduces modulo the modulus. (7) An RSA verification function that checks the signature is in range, performs modular exponentiation with the public exponent, converts the result to the required byte length, and invokes the PSS verifier. (8) An integer exponentiation alias, plus integer-to-integer functions for Euler\u2019s totient and radical, both with integer types but unspecified bodies. Provide precise Cryptol type signatures and necessary numeric constraints for all definitions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::RSA_PSS where\n\nimport Common::utils\n\nparameter\n  type hLen : #   type constraint (fin hLen, hLen >= 1)\n\n  type MessageUpperBound : #\n  type constraint (width (8 * (hLen + hLen + 8)) <= MessageUpperBound)\n\n  hash : {n} (fin n, width (8 * n) <= MessageUpperBound) => [n][8] -> [8 * hLen]\n\nMGF1 : {seedLen, maskLen} (fin seedLen, fin maskLen, width (8 * seedLen + 32) <= MessageUpperBound) => [seedLen][8] -> [maskLen][8]\nMGF1 seed = take (join [ split (hash (seed # (split c))) | c <- [(0 : [32]) ...] ])\n\nPSS_mgf1_encode : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> [hLen][8] -> [emLen][8]\nPSS_mgf1_encode mHash salt = EM'\n  where\n    M' = (zero : [8][8]) # mHash # salt\n    H = split (hash M')\n    DB = (zero : [emLen - 2 * hLen - 2][8]) # [0x01] # salt\n    dbMask = MGF1 H\n    maskedDB = DB ^ dbMask\n    EM = maskedDB # H # [0xbc]\n    EM' = update EM 0 ((EM @ 0) && 0x7f)\n\nPSS_mgf1_verify : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> [emLen][8] -> Bit\nPSS_mgf1_verify mHash EM = 0xbc == byte_0xbc \/\\ 0 == (maskedDB @ 0) && 0x80 \/\\ (zero : [emLen - 2 * hLen - 2][8]) == padding \/\\ 0x01 == byte_0x01 \/\\ H == H'\n  where\n    (maskedDB # H # [byte_0xbc]) = EM\n    dbMask = MGF1 H\n    DB = maskedDB ^ dbMask\n    DB' = update DB 0 ((DB @ 0) && 0x7f)\n    padding # [byte_0x01] # salt = DB'\n    M' = (zero : [8][8]) # mHash # salt\n    H' = split (hash M')\n\nRSA_sign : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> [hLen][8] -> Integer -> Integer -> Integer\nRSA_sign mHash salt d n = (exp (integerFromBV (join (PSS_mgf1_encode`{emLen} mHash salt))) d) % n\n\nRSA_verify : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> Integer -> Integer -> Integer -> Bit\nRSA_verify mHash sig e n = sig < n \/\\ PSS_mgf1_verify`{emLen} mHash (split (integerToBV ((exp sig e) % n)))\n\nexp : Integer -> Integer -> Integer\nexp = (^^)\n\nphi : Integer -> Integer\nphi = undefined\n\nrad : Integer -> Integer\nrad = undefined\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/RSA_PSS_SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::RSA_PSS_SHA384 that instantiates the generic RSA-PSS signature module for SHA-384. Inside it, include the following definitions: (1) import the SHA-384 instantiation module under the alias SHA384; (2) define a type alias hLen set to 48 (bytes), matching the SHA-384 digest size; (3) define a function hash that takes a finite sequence of bytes (the message) with length constrained by the SHA-384 message bound and returns a 384-bit digest; implement it by invoking the SHA-384 byte-oriented hash and flattening the resulting sequence into a single bitvector; (4) define a type alias MessageUpperBound that re-exports the message size bound from the SHA-384 instantiation. Provide explicit type signatures and constraints so that hash has the shape {n} (n <= MessageUpperBound) => [n][8] -> [8 * hLen], and ensure compatibility with the RSA-PSS module\u2019s expected parameters for hash output length and message bounds."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::RSA_PSS_SHA384 = Primitive::Asymmetric::Signature::RSA_PSS where\n\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 as SHA384\n\ntype hLen = 48\nhash m = join (SHA384::hashBytes m)\ntype MessageUpperBound = SHA384::MessageUpperBound\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Cipher\/RSA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Asymmetric::Cipher::RSA that imports Common::mod_arith and contains the following definitions: (1) I2OSP: a polymorphic function over numeric parameters xLen and a bit-width parameter; require both finite, xLen>=1, and input width \u2264 xLen*8; type [inputWidth] -> [xLen][8]; behavior: left-pad the input with leading zero bits to exactly xLen*8 bits and split into xLen octets. (2) OS2IP: for finite xLen; type [xLen][8] -> [xLen*8]; behavior: concatenate the octets into a single bitvector. (3) Define a property I2OSConversionCorrect asserting that for any finite xLen\u22651, applying OS2IP then I2OSP returns the original byte array. (4) RSAEP: for finite K\u22651; type (([K],[K]),[K]) -> [K]; compute modular exponentiation c = m^e mod n using mod_pow; raise a runtime error if the message representative is not in [0, n-1]. (5) RSADP: for finite K\u22651; type (([K],[K]),[K]) -> [K]; compute m = c^d mod n using mod_pow; raise a runtime error if the ciphertext representative is not in [0, n-1]. (6) Define a property RSACorrect asserting that when 0 \u2264 msg < n, decryption after encryption yields msg. (7) A constant rsaTest: a record with fields n, d, e, M, and C, each a 2048-bit word, used as a test vector. (8) Define a property testsPass asserting that decrypting C with (n,d) equals M. (9) genRSAKeys: (Integer,Integer) -> (Integer,Integer,Integer); n=p*q, e=65537, d is the modular inverse of e modulo lcm(p-1,q-1). (10) Private Integer helpers gcd, lcm, inv (extended Euclidean), with inv requiring coprime inputs. (11) rsaEncrypt and rsaDecrypt for Integers via modular exponentiation. (12) Define properties IntegerRSACorrectKeyGen and IntegerRSACorrect asserting encrypt-then-decrypt correctness under 0 \u2264 msg < n."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Cipher::RSA where\n\nimport Common::mod_arith\n\nI2OSP : {xLen,int} (fin int, fin xLen, int<=xLen*8, xLen>=1) =>\n      [int] -> [xLen][8]\nI2OSP x = split ((zero # x):[xLen*8]) : [xLen][8]\n\nOS2IP : {xLen} (fin xLen) => [xLen][8] -> [xLen*8]\nOS2IP xs = join xs\n\nI2OSConversionCorrect : {xLen} (fin xLen, xLen>=1) => [xLen][8] -> Bit\nproperty I2OSConversionCorrect xs = I2OSP (OS2IP xs) == xs\n\nRSAEP : {K} (fin K, K >= 1) => (([K],[K]),[K]) -> [K]\nRSAEP ((n, e), m) = if (m < zero \\\/ m > (n-1)) then error \"message representative out of range\"\n                    else c\n      where c = mod_pow (n,m,e)\n\nRSADP : {K} (fin K, K >= 1) => (([K],[K]),[K]) -> [K]\nRSADP ((n, d), c) = if (c < 0 \\\/ c > (n-1)) then error \"ciphertext representative out of range\"\n                    else m\n      where m = mod_pow (n,c,d)\n\nRSACorrect : {K} (fin K, K >= 1) => [K] -> [K] -> [K] -> [K] -> Bit\nproperty RSACorrect e d n msg = ( msg >= zero \/\\ msg < n ) ==> RSADP ((n,d), RSAEP ((n,e), msg)) == msg\n\nrsaTest = {n = 0xbad47a84c1782e4dbdd913f2a261fc8b65838412c6e45a2068ed6d7f16e9cdf4462b39119563cafb74b9cbf25cfd544bdae23bff0ebe7f6441042b7e109b9a8afaa056821ef8efaab219d21d6763484785622d918d395a2a31f2ece8385a8131e5ff143314a82e21afd713bae817cc0ee3514d4839007ccb55d68409c97a18ab62fa6f9f89b3f94a2777c47d6136775a56a9a0127f682470bef831fbec4bcd7b5095a7823fd70745d37d1bf72b63c4b1b4a3d0581e74bf9ade93cc46148617553931a79d92e9e488ef47223ee6f6c061884b13c9065b591139de13c1ea2927491ed00fb793cd68f463f5f64baa53916b46c818ab99706557a1c2d50d232577d1 : [2048]\n           , d = 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010001 : [2048]\n           , e = 0x40d60f24b61d76783d3bb1dc00b55f96a2a686f59b3750fdb15c40251c370c65cada222673811bc6b305ed7c90ffcb3abdddc8336612ff13b42a75cb7c88fb936291b523d80acce5a0842c724ed85a1393faf3d470bda8083fa84dc5f31499844f0c7c1e93fb1f734a5a29fb31a35c8a0822455f1c850a49e8629714ec6a2657efe75ec1ca6e62f9a3756c9b20b4855bdc9a3ab58c43d8af85b837a7fd15aa1149c119cfe960c05a9d4cea69c9fb6a897145674882bf57241d77c054dc4c94e8349d376296137eb421686159cb878d15d171eda8692834afc871988f203fc822c5dcee7f6c48df663ea3dc755e7dc06aebd41d05f1ca2891e2679783244d068f : [2048]\n           , M = 0x70992c9d95a4908d2a94b3ab9fa1cd643f120e326f9d7808af50cac42c4b0b4eeb7f0d4df303a568fbfb82b0f58300d25357645721bb71861caf81b27a56082c80a146499fb4eab5bde4493f5d00f1a437bbc360dfcd8056fe6be10e608adb30b6c2f7652428b8d32d362945982a46585d2102ef7995a8ba6e8ad8fd16bd7ae8f53c3d7fcfba290b57ce7f8f09c828d6f2d3ce56f131bd9461e5667e5b73edac77f504dac4f202a9570eb4515b2bf516407db831518db8a2083ec701e8fd387c430bb1a72deca5b49d429cf9deb09cc4518dc5f57c089aa2d3420e567e732102c2c92b88a07c69d70917140ab3823c63f312d3f11fa87ba29da3c7224b4fb4bc : [2048]\n           , C = 0x7e65b998a05f626b028c75dc3fbf98963dce66d0f4c3ae4237cff304d84d8836cb6bad9ac86f9d1b8a28dd70404788b869d2429f1ec0663e51b753f7451c6b4645d99126e457c1dac49551d86a8a974a3131e9b371d5c214cc9ff240c299bd0e62dbc7a9a2dad9fa5404adb00632d36332d5be6106e9e6ec81cac45cd339cc87abbe7f89430800e16e032a66210b25e926eda243d9f09955496ddbc77ef74f17fee41c4435e78b46965b713d72ce8a31af641538add387fedfd88bb22a42eb3bda40f72ecad941dbffdd47b3e77737da741553a45b630d070bcc5205804bf80ee2d51612875dbc4796960052f1687e0074007e6a33ab8b2085c033f9892b6f74 : [2048] }\n\nproperty testsPass = rsaTest.M == RSADP ((rsaTest.n, rsaTest.d), rsaTest.C)\n\ngenRSAKeys : (Integer,Integer) -> (Integer,Integer,Integer) genRSAKeys (p,q) = (p*q,e,d)\n           where nTotient = lcm (p-1) (q-1)\n                 e        = 65537                  d        = inv e nTotient\n\nprivate\n    gcd : Integer -> Integer -> Integer\n    gcd x y =  gcd' x y\n        where gcd' a b = if b == zero then a else gcd' b (a%b)\n\n    lcm : Integer -> Integer -> Integer\n    lcm x y =  if (x == zero \\\/ y == zero) then zero else (x \/ (gcd x y)) * y\n\n    inv : Integer -> Integer -> Integer \/\/ Note, k and m MUST be coprime\n    inv k m = (inv' m k).1 % m\n      where\n        inv' n x = if x==1 then (zero, 1) else (r', q' - r' * q)\n          where\n            (q,  r)  = (n\/x, n%x)\n            (q', r') = inv' x r\n\nrsaEncrypt : (Integer,Integer,Integer) -> Integer\nrsaEncrypt (msg,e,n) = (msg^^e)%n\n\nrsaDecrypt : (Integer,Integer,Integer) -> Integer\nrsaDecrypt (ct,d,n) = (ct^^d)%n\n\n\/\/ :prove IntegerRSACorrectKeyGen 49979693 67867967\n\/\/ :check IntegerRSACorrectKeyGen 49979693 67867967\nIntegerRSACorrectKeyGen : Integer -> Integer -> Integer -> Bit\nproperty IntegerRSACorrectKeyGen p q msg = ( msg >= zero \/\\ msg < n ) ==>\n         rsaDecrypt (rsaEncrypt (msg,e,n),d,n) == msg\n         where (n,e,d) = genRSAKeys (p,q)\n\n\/\/ :prove IntegerRSACorrect 7 103 143\n\/\/ :check IntegerRSACorrect 7 103 143\n\/\/ :check IntegerRSACorrect (toInteger e) (toInteger d) (toInteger n)\nIntegerRSACorrect : Integer -> Integer -> Integer -> Integer -> Bit\nproperty IntegerRSACorrect e d n msg = ( msg >= zero \/\\ msg < n ) ==>\n         rsaDecrypt (rsaEncrypt (msg,e,n),d,n) == msg\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/ML_DSA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ML_DSA::ML_DSA that imports the ML-DSA parameter interface and the optimized specification instantiated with that interface. Provide the following declarations and behaviors: 1) A function KeyGen that takes an optional 32-byte seed and returns an optional pair of public and private keys; it yields None if the seed is absent, otherwise it delegates to an internal key-generation function using the seed. 2) A function Sign, parameterized by finite sizes m and c, that takes a private key, an m-byte message, a c-byte context, and optional randomness, and returns an optional signature; if c exceeds 255 or randomness is absent, return None; otherwise form a prefixed message by concatenating a one-byte zero, a one-byte encoding of c, the context, and the original message, then return Some of the internal signing function applied to the private key, the prefixed message, and the randomness. 3) A function Verify, parameterized by finite sizes m and c, that takes a public key, an m-byte message, a signature, and a c-byte context, and returns an optional boolean; if c exceeds 255 return None; otherwise build the same prefixed message and return Some of the internal verification function applied to the public key, the prefixed message, and the signature. 4) A submodule TestAPI that binds the internal key generation, signing, and verification names to the corresponding definitions from the optimized specification. 5) A property MLDSAIsCorrect, parameterized by finite m, that takes a 32-byte seed, a 32-byte randomness value, an m-byte message, and a 255-byte context; it attempts to generate keys, sign with the provided randomness and context, then verify; it evaluates to False if any step yields None, otherwise to the verification result. Use the Option, Byte, PublicKey, PrivateKey, and Signature types defined by the parameter interface."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ML_DSA::ML_DSA where\n\nimport interface Primitive::Asymmetric::Signature::ML_DSA::Parameters as P\nimport Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification { interface P }\n\nKeyGen : Option ([32]Byte) -> Option (PublicKey, PrivateKey)\nKeyGen maybe_\u03be = case maybe_\u03be of\n    None -> None\n    Some \u03be -> Some (KeyGen_internal \u03be)\n\nSign : {m, c} (fin m, fin c) =>\n    PrivateKey -> [m] -> [c]Byte -> Option ([32]Byte) -> Option (Signature)\nSign sk M ctx maybe_rnd\n        | c > 255 => None\n        | c <= 255 => case maybe_rnd of\n        None -> None\n        Some rnd -> sigma where\n                                                            M' = join (IntegerToBytes`{1} 0 # IntegerToBytes`{1} `c # ctx) # M\n            \/\/ Step 11.\n            sigma = Some (Sign_internal sk M' rnd)\n\nVerify : {m, c} (fin m, fin c) =>\n    PublicKey -> [m] -> Signature -> [c]Byte -> Option Bool\nVerify pk M sigma ctx\n    | c > 255 => None\n    | c <= 255 => Some (Verify_internal pk M' sigma) where\n        \/\/ Step 10. We use `join` instead of `BytesToBits`, which produces\n        \/\/ the same byte string, but with the bits in each byte reversed.\n        \/\/ I think we have to do this to support the later call to `HBits`,\n        \/\/ which expects the bit-order and byte-order to be the same.\n        M' = join (IntegerToBytes`{1} 0 # IntegerToBytes`{1} `c # ctx) # M\n\nsubmodule TestAPI where\n    import Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification { interface P } as Spec\n\n    KeyGen_internal = Spec::KeyGen_internal\n    Sign_internal = Spec::Sign_internal\n    Verify_internal = Spec::Verify_internal\n\nMLDSAIsCorrect : {m} (fin m) => [32]Byte -> [32]Byte -> [m] -> [255]Byte -> Bit\nproperty MLDSAIsCorrect \u03be rnd M ctx = sigVerifies where\n    maybe_keys = KeyGen (Some \u03be)\n    maybe_sigVerifies = case maybe_keys of\n        None -> None\n        Some keys -> case (Sign sk M ctx (Some rnd)) of\n                None -> None\n                Some sig -> Verify pk M sig ctx\n            where (pk, sk) = keys\n    sigVerifies = case maybe_sigVerifies of\n        None -> False\n        Some v -> v\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ML_DSA::Specification that contains the following definitions, with appropriate fin\/positivity width constraints on size parameters: imports for SHAKE128\/SHAKE256 XOF helpers; type aliases for a byte, ring vectors over Z q and Integer; vectorized NTT\/NTTInv; helper for balanced residue lifting from Z q to Integer; norms on vectors; casting from Integer vectors to Z q; SHAKE-based hash\/XOF wrappers; an imported ML-DSA parameters interface; constants for the NTT root, rounding exponent, and a derived integer; sized types for public key, secret key, and signature layouts; internal key generation, signing, and verification procedures implementing ML-DSA with matrix\/vector NTT, masking, decomposition, hint creation\/use, and hashing; bit\/byte conversion and packing\/unpacking utilities; samplers for coefficients and polynomials; expanders for matrix and secret vectors; power-of-two and centered decompositions; accessors for high\/low parts; hint pack\/unpack; w1 encoder; NTT-domain elementwise ops and vector\/matrix products, and ring-like operators. Additionally, define the following properties: a property that the bit-length width examples match expected values; a property that balanced residue lifting returns values in the symmetric interval and preserves congruence; a property that bit-to-integer and integer-to-bit invert; a property that bytes-to-bits and bits-to-bytes compose to identity; a property equating 4-bit take\/drop to division\/mod by 16; properties that simple and general packing\/unpacking invert under stated ranges; a property that hint packing\/unpacking invert for well-formed sparse hints; properties that public, secret, and signature encoders\/decoders invert under their range assumptions; a property that power-of-two decomposition and general decomposition satisfy their recomposition equations; a property that UseHint outputs are within the valid range; properties that NTT and its inverse are mutual inverses; properties that NTT-domain add\/multiply equal ring addition\/multiplication; properties that vector\/matrix NTT operations and custom operators equal their corresponding ring formulations."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ML_DSA::Specification where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE128 as SHAKE128\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256 as SHAKE256\n\ntype Byte = [8]\n\nproperty bitlenIsWidth = (`(width 32) == 6) && (`(width 31) == 5)\n\ntype Tq = [256](Z q)\n\ntype R = [256]Integer\n\ntype R2 = [256]\n\ntype Rq = [256](Z q)\n\nmodPlusMinus : {\u03b1} (fin \u03b1) => Z q -> Integer\nmodPlusMinus m = m' where\n    m_int = (fromZ m) % `\u03b1\n    m' = if m_int > (`\u03b1 \/ 2) then m_int - `\u03b1\n        else m_int\n\nmodPlusMinusWorks : {\u03b1} (fin \u03b1) => Z q -> Bit\nproperty modPlusMinusWorks m = inRange && congruent where\n    m' = modPlusMinus`{\u03b1} m\n    lower_bound = - ((`\u03b1 + 1) \/ 2)\n    inRange = (lower_bound < m') && (m' <= (`\u03b1 \/ 2))\n    congruent = ((fromZ m) % `\u03b1) == (m' % `\u03b1)\n\ninfNormRq : {m} (fin m) => [m]Rq -> Integer\ninfNormRq w = maxList [ maxList [ abs (modPlusMinus`{q} wij)\n    | wij <- wi]\n    | wi <- w]\n\ninfNormR : {m} (fin m) => [m]R -> Integer\ninfNormR w = maxList [ maxList [ abs wij | wij <- wi] | wi <- w]\n\ncastToRq : {m} (fin m) => [m]R -> [m]Rq\ncastToRq v = [map fromInteger vi | vi <- v]\n\nprivate\n\n    maxList : {n, a} (fin n, Literal 0 a, Cmp a) => [n]a -> a\n    maxList list = foldl max 0 list\n\nNTT_Vec = map NTT\nNTTInv_Vec = map NTTInv\n\nH : {l, m} (fin m) => [m][8] -> [l][8]\nH str = SHAKE256::xofBytes`{8 * l} str\n\nHBits : {l, m} (fin m) => [m] -> [l][8]\nHBits str = split (SHAKE256::xof`{8 * l} (str))\n\nG : {l, m} (fin m) => [m][8] -> [l][8]\nG str = SHAKE128::xofBytes`{8 * l} str\n\nimport interface Primitive::Asymmetric::Signature::ML_DSA::Parameters\n\n\u03b6 : Z q\n\u03b6 = 1753\n\ntype d = 13\n\n\u03b2 = `(\u03b7 * \u03c4) : Integer\n\ntype PublicKey = [32 + 32 * k * (width (q - 1) - d)]Byte\n\ntype PrivateKey = [32 + 32 + 64 + 32 * ((k + ell) * width (2 * \u03b7) + d * k)]Byte\n\ntype Signature = [\u03bb \/ 4 + ell * 32 * (1 + width (\u03b31 - 1)) + \u03c9 + k]Byte\n\nKeyGen_internal : [32]Byte -> (PublicKey, PrivateKey)\nKeyGen_internal \u03be = (pk, sk) where\n        (\u03c1 # \u03c1' # K) = H`{128} (\u03be # IntegerToBytes`{1} `k # IntegerToBytes`{1} `ell)\n\n    \/\/ Step 3.\n    A_hat = ExpandA \u03c1\n    \/\/ Step 4.\n    (s1, s2) = ExpandS \u03c1'\n\n        s1' = castToRq s1\n    s2' = castToRq s2\n\n        t = NTTInv_Vec (A_hat \u2218\u2218 NTT_Vec s1') + s2'\n        (t1, t0) = Power2Round t\n\n        pk = pkEncode \u03c1 t1\n        tr = H`{64} pk\n        sk = skEncode \u03c1 K tr s1 s2 t0\n\nSign_internal : {m} (fin m) => PrivateKey -> [m] -> [32]Byte -> Signature\nSign_internal sk M' rnd = \u03c3 where\n    \/\/ Step 1.\n    (\u03c1, K, tr, s1, s2, t0) = skDecode sk\n\n    \/\/ Steps 2 - 5.\n    s1_hat = NTT_Vec (castToRq s1)\n    s2_hat = NTT_Vec (castToRq s2)\n    t0_hat = NTT_Vec (castToRq t0)\n    A_hat = ExpandA \u03c1\n\n    \/\/ Step 6. We use `join` instead of `BytesToBits`, which produces the same\n    \/\/ byte string, but with the bits in each byte reversed. I think we have to\n    \/\/ do this to support the call to `HBits`, which expects the bit-order and\n    \/\/ byte-order to be the same.\n    \u03bc = HBits`{64} (join tr # M')\n\n        \u03c1''= H`{64} (K # rnd # \u03bc)\n\n            rejection_sample: Integer -> ([\u03bb \/ 4]Byte, ([ell]Rq, [k]R2))\n    rejection_sample \u03ba = case maybe_zh of\n            Some zh -> (c_til, zh)\n            None -> rejection_sample (\u03ba + `ell)\n        where\n            y = castToRq (ExpandMask \u03c1'' \u03ba)\n            w = NTTInv_Vec (A_hat \u2218\u2218 (NTT_Vec y))\n            w1 = HighBits w\n            c_til = H`{\u03bb \/ 4} (\u03bc # w1Encode w1)\n            [c] = castToRq [(SampleInBall c_til)]\n            c_hat = NTT c\n            cs1 = NTTInv_Vec (c_hat \u2218 s1_hat)\n            cs2 = NTTInv_Vec (c_hat \u2218 s2_hat)\n            z = y + cs1\n            r0 = LowBits (w - cs2)\n            maybe_zh = if (infNormRq z >= `\u03b31 - \u03b2) || (infNormR r0 >= `\u03b32 - \u03b2)\n                then None\n                else maybe_zh' where\n                    ct0 = NTTInv_Vec (c_hat \u2218 t0_hat)\n                    h = MakeHint (-ct0) (w - cs2 + ct0)\n                    maybe_zh' =\n                        if (infNormRq ct0 >= `\u03b32) || (numberOf1sInh > `\u03c9)\n                        then None\n                        else Some (z, h)\n\n                                                            numberOf1sInh = sum [if b then 1 else 0 | b <- join h]\n\n        (c_tilFinal, (zFinal, hFinal)) = rejection_sample 0\n\n        modPlusMinus_Vec v = [map modPlusMinus`{q} vi | vi <- v]\n\n        \u03c3 = sigEncode c_tilFinal (modPlusMinus_Vec zFinal) hFinal\n\nVerify_internal : {m} (fin m) => PublicKey -> [m] -> Signature -> Bool\nVerify_internal pk M' \u03c3 = isValid where\n    \/\/ Step 1 - 2.\n    (rho, t1) = pkDecode pk\n    (c_til, z, h) = sigDecode \u03c3\n\n    \/\/ Step 5.\n    A_hat = ExpandA rho\n    \/\/ Step 6.\n    tr = H`{64} pk\n    \/\/ Step 7. We use `join` instead of `BytesToBits`, which produces the same\n    \/\/ byte string, but with the bits in each byte reversed. I think we have to\n    \/\/ do this to support the call to `HBits`, which expects the bit-order and\n    \/\/ byte-order to be the same.\n    mu = HBits`{64} (join tr # M')\n\n        [c] = castToRq [(SampleInBall c_til)]\n\n        t1' = castToRq t1\n    z' = castToRq z\n            two_d = repeat (repeat (2^^`d))\n\n        wApprox' = NTTInv_Vec (A_hat \u2218\u2218 NTT_Vec z' - (NTT c \u2218 NTT_Vec (t1' * two_d)))\n\n    \/\/ Steps 3 - 4, 10 - 13.\n    isValid = case h of\n        None -> False\n        Some h' -> (infNormR z < `\u03b31 - \u03b2) && (c_til == c_til') where\n            w1' = UseHint h' wApprox'\n            c_til' = H`{\u03bb \/ 4} (mu # w1Encode w1')\n\nIntegerToBits : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]\nIntegerToBits x = y' where\n    \/\/ Step 3. Compute the value of each `y_i`.\n    y = [x' % 2 | x' <- xs' | i <- [0..\u03b1 - 1]]\n\n            xs' = [x] # [x' \/ 2 | x' <- xs']\n\n            y' = join [(fromInteger yi) : [1] | yi <- y]\n\n\/**\n * Compute the integer value expressed by a bit string using little-endian\n * order.\n * [FIPS-204] Section 7.1, Algorithm 10.\n *\/\nBitsToInteger : {\u03b1} (fin \u03b1, \u03b1 > 0) => [\u03b1] -> Integer\nBitsToInteger y = xs ! 0 where\n    \/\/ Cryptol-specific conversion: separate the input into \u03b1 1-bit vectors,\n    \/\/ then convert each to an integer.\n    y' = map toInteger (split`{\u03b1} y)\n\n        xs = [0] # [2 * x + y' @ (`\u03b1 - i)\n        | x <- xs\n        | i <- [1..\u03b1]]\n\n\/**\n * The integer \/ bit conversion functions must invert each other.\n * This is not explicit in the spec, but we define the property anyway.\n * The parameter choices are approximately the same as some of the use cases\n * in the spec.\n * ```repl\n * :check BitsToIntegersInverts`{44}\n * :exhaust BitsToIntegersInverts`{10}\n * ```\n *\/\nBitsToIntegersInverts : {\u03b1} (fin \u03b1, \u03b1 > 0) => [\u03b1] -> Bit\nproperty BitsToIntegersInverts x = IntegerToBits (BitsToInteger x) == x\n\n\/**\n * Compute a base-256 representation of `x mod 256^\u03b1` using little-endian byte\n * order.\n * [FIPS-204] Section 7.1, Algorithm 11.\n *\/\nIntegerToBytes : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]Byte\nIntegerToBytes x = y where\n    \/\/ Step 2 - 3.\n    y = [fromInteger (x' % 256) | x' <- xs' | i <- [0..\u03b1 - 1]]\n\n        xs' = [x] # [x' \/ 256 | x' <- xs']\n\nBitsToBytes : {\u03b1} (fin \u03b1) => [\u03b1]Bit -> [\u03b1 \/^ 8]Byte\nBitsToBytes y\n        | \u03b1 == 0 => zero\n    | \u03b1 > 0 => z where\n                                        y' = groupBy`{8} ([(zext [yi], i)\n            | yi <- y\n            | i <- [0..\u03b1 - 1]] # zero)\n\n        \/\/ Steps 2 - 4. We compute the `y` terms separately then `sum` them\n        \/\/ for each byte in `z`.\n        z = [sum [yi * (2 ^^ (i % 8))\n                | (yi, i) <- yi8]\n            | yi8 <- y']\n\nBytesToBits : {\u03b1} (fin \u03b1) => [\u03b1]Byte -> [8 * \u03b1]Bit\nBytesToBits z\n    | \u03b1 == 0 => []\n    | \u03b1 > 0 => join [[ y8ij where\n                                    y8ij = zi' ! 0\n            \/\/ Step 5. Shifting right is the same as the iterative\n            \/\/ division (see `div2IsShiftR`). This accounts for all the\n            \/\/ divisions \"up to this point\" (e.g. none when `j = 0`), which\n            \/\/ is why we use `zi'` to evaluate `y8ij` above.\n            zi' = zi >> j\n        \/\/ Step 3.\n        | j <- [0..7]]\n        \/\/ Step 2. We iterate over `z` directly instead of indexing into it.\n        | zi <- z ]\n\nprivate\n    \/**\n     * The iterative division by 2 in `BytesToBits` is the same as shifting\n     * right.\n     * ```repl\n     * :prove div2IsShiftR\n     * ```\n     *\/\n    div2IsShiftR : Byte -> Bit\n    div2IsShiftR C = take (d2 C) == shl where\n        \/\/ Note: division here is floor'd by default.\n        d2 c = [c] # d2 (c \/ 2)\n        shl = [C >> j | j <- [0..7]]\n\nB2B2BInverts : {\u03b1} (fin \u03b1) => [8 * \u03b1] -> Bit\nproperty B2B2BInverts y = BytesToBits (BitsToBytes y) == y\n\nCoeffFromThreeBytes : Byte -> Byte -> Byte -> Option (Z q)\nCoeffFromThreeBytes b0 b1 b2 = maybe_z where\n        b2' = if b2 > 127 then b2 - 128 else b2\n\n    \/\/ We have to explicitly expand the byte strings to support the\n    \/\/ operations in the next step. 32 bits gives us plenty of space.\n    [bq0, bq1, bq2'] = map zext`{32} [b0, b1, b2']\n\n    \/\/ Step 5.\n    z = 2^^16 * bq2' + 2^^8 * bq1 + bq0\n\n                maybe_z = if z < `q then Some (toZ z) else None\n\n    toZ : [32] -> Z q\n    toZ b = fromInteger (toInteger b)\n\nCoeffFromHalfByte : [4] -> Option Integer\nCoeffFromHalfByte b =\n    if (`\u03b7 == 2) && (b < 15) then Some (2 - (toInteger b % 5))\n    else\n        if (`\u03b7 == 4) && (b < 9) then Some (4 - toInteger b)\n        else None\n\nSimpleBitPack : {b} (fin b, width b > 0) => R -> [32 * width b]Byte\nSimpleBitPack w = BitsToBytes z where\n    z = join [IntegerToBits`{width b} (w@i) | i <- [0..255]]\n\nBitPack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    R -> [32 * width (a + b)]Byte\nBitPack w = BitsToBytes z where\n    z = join [IntegerToBits`{width (a + b)} (`b - w@i) | i <- [0..255]]\n\nSimpleBitUnpack : {b} (fin b, width b > 0) => [32 * width b]Byte -> R\nSimpleBitUnpack v = w where\n    type c = width b\n    z = BytesToBits v\n            z_ics = split z : [256][c]\n    w = [BitsToInteger`{c} (z_ics@i) | i <- [0..255]]\n\nSimplePackingInverts : {b} (fin b, width b > 0) => [256](Z b) -> Bit\nproperty SimplePackingInverts w_inRange = simplePackInverts where\n    w = map fromZ w_inRange\n    simplePackInverts = SimpleBitUnpack`{b} (SimpleBitPack`{b} w) == w\n\nBitUnpack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    [32 * width (a + b)]Byte -> R\nBitUnpack v = w where\n    type c = width (a + b)\n    z = BytesToBits v\n\n            z_ics = split z : [256][c]\n\n    w = [`b - BitsToInteger`{c} (z_ics@i)| i <- [0..255]]\n\nPackingInverts : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    [256](Z (a + b)) -> Bit\nproperty PackingInverts w_inRange = packInverts where\n        w = [(fromZ wi) - `a | wi <- w_inRange]\n    packInverts = BitUnpack`{a, b} (BitPack`{a, b} w) == w\n\nHintBitPack : [k]R2 -> [\u03c9 + k]Byte\nHintBitPack h = yFinal where\n        y0 = zero : [\u03c9 + k]Byte\n        Index0 = 0\n            yAndIndex = [(y0, Index0)] # [ (y'', Index') where\n            \/\/ Steps 5 - 8.\n            (y', Index') = if (h @i @j) != 0 then\n                    (update y Index j, Index + 1)\n                else (y, Index)\n\n            \/\/ Step 10.\n            y'' = if j == 255 then\n                    update y' (`\u03c9 + i) Index'\n                else y'\n        | (y, Index) <- yAndIndex\n                | i <- [0..k-1], j <- [0..255]\n    ]\n        (yFinal, _) = yAndIndex ! 0\n\nHintBitUnpack : [\u03c9 + k]Byte -> Option ([k]R2)\nHintBitUnpack y = hFinal where\n        h0 = zero : [k * 256]\n        Index0 = 0\n\n            hAndIndexes = [Some (h0, Index0)] # [\n                        case maybe_hAndIndex of\n                Some hAndIndex -> Step4_5 hAndIndex i\n                None -> None\n        | maybe_hAndIndex <- hAndIndexes\n        | i <- [0..k-1]\n    ]\n\n        Step4_5 (h, Index) i = if (y@(`\u03c9 + i) < Index) || (y@(`\u03c9 + i) > `\u03c9) then\n            None\n        else Step6_15 (h, Index) i\n\n        Step6_15 (h, Index) i = Step7_14 (h, Index) where\n                First = Index\n\n                Step7_14 (h', Index') =\n                        if Index' < (y@(`\u03c9 + i)) then\n                \/\/ Step 8 - 11.\n                \/\/ The `\/\\` is a short-cutting `and`, equivalent to the nested\n                \/\/ `if` statements in the spec.\n                if ((Index' > First) \/\\ (y@(Index' - 1) >= y@Index')) then None\n                                else Step7_14\n                                        (update h' (i*256 + (toInteger (y@Index'))) 1,\n                                        Index' + 1)\n            \/\/ If the loop condition is no longer true, return the current\n            \/\/ values of `h` and `Index`.\n            else Some (h', Index')\n\n    \/\/ Get the values of `h` and `Index` after the loop in Steps 3 - 15.\n    maybe_hAndIndex' = hAndIndexes ! 0\n\n        hFinal = case maybe_hAndIndex' of\n        Some hAndIndex -> if checkLeftoverBytes then\n                \/\/ This `split` converts back to the spec-adherent\n                \/\/ representation of `h`.\n                Some (split`{k} h)\n            else None\n            where\n                (h, Index) = hAndIndex\n                \/\/ This helper reads any \"leftover\" bytes (e.g. beyond `Index`)\n                \/\/ in the first `\u03c9` bytes of `y`; it returns `True` if all of\n                \/\/ them are zero.\n                checkLeftoverBytes = and [i >= Index ==> y@i == 0\n                    | i <- [0..\u03c9 - 1]]\n\n        None -> None\n\n\/**\n * Verify that `HintBitUnpack` is the reverse of `HintBitPack`.\n *\n * This takes a list of indexes indicating the non-zero elements and constructs\n * a valid, sparse `h` -- rejection sampling is not a valid option because\n * sparse-enough `h`s were too rare.\n *\n * We test the case where we have the maximum number of 1s, a medium number, and\n * a case where at least one vector should have no non-zero terms at all.\n * In practice, the hint may fall anywhere in this range.\n * This takes about 1 minute.\n * ```repl\n * :check HintPackingInverts`{\u03c9}\n * :check HintPackingInverts`{\u03c9 \/ 2}\n * :check HintPackingInverts`{3}\n * ```\n *\n * Note that this does not test the error cases for `HintBitUnpack`.\n *\/\nHintPackingInverts : {w} (w <= \u03c9) => [w][lg2 (256 * k)] -> Bit\nproperty HintPackingInverts h_Indexes =\n    case HintBitUnpack (HintBitPack h) of\n        Some h' -> h == h'\n        None -> False\n    where\n        h = buildHint h_Indexes\n\nprivate\n    \/**\n     * Creates a hint with `w` non-zero entries at the indices specified in\n     * the parameter.\n     * This is for testing functions that take a hint as a parameter and assume\n     * it is appropriately sparse.\n     *\/\n    buildHint : {w} (w <= \u03c9) => [w][lg2 (256 * k)] -> [k]R2\n    buildHint h_Indexes = h where\n        h = split`{k} [if elem idx h_Indexes then 1 else 0 | idx <- [0..(256 * k) - 1]]\n\n\/**\n * Encode a public key for ML-DSA into a byte string.\n * [FIPS-204] Section 7.2, Algorithm 22.\n *\n * This assumes that `t1` has coefficients in the range\n * `[0, 2^(bitlen(q-1) - d) - 1]`.\n *\/\npkEncode : [32]Byte -> [k]R -> PublicKey\npkEncode \u03c1 t1 = pk where\n    pk = \u03c1 # join [SimpleBitPack`{2 ^^ (width (q - 1) - d) - 1} (t1@i) | i <- [0..k-1]]\n\n\/**\n * Reverse the procedure `pkEncode`.\n * [FIPS-204] Section 7.2, Algorithm 23.\n *\n * This produces a `t1` with coefficients in the range\n * `[0, 2^(bitlen(q-1) - d) - 1]`.\n *\/\npkDecode : PublicKey -> ([32]Byte, [k]R)\npkDecode pk = (\u03c1, t1) where\n    \/\/ Step 1. We split off the single `\u03c1` byte, then separate the remaining\n    \/\/ bytes into the `k` components as described.\n    (\u03c1 # zBytes) = pk\n    z = split zBytes\n    \/\/ Steps 2 - 4.\n    t1 = [SimpleBitUnpack`{2 ^^ (width (q - 1) - d) - 1} (z@i) | i <- [0..k-1]]\n\nprivate\n    \/**\n     * `pkDecode` must reverse the procedure `pkEncode`.\n     * This takes about 30s.\n     * ```repl\n     * :set tests=20\n     * :check pkCodingInverts\n     * ```\n     *\/\n    pkCodingInverts : [32]Byte -> [k][256][width (q - 1) - d] -> Bit\n    pkCodingInverts \u03c1 t1_inRange = inverts where\n        \/\/ `t1_inRange` is typed to ensure that all the coefficients will be\n        \/\/ in the range `[0, 2^^(width (q-1)-d) - 1]`.\n        t1 = [map toInteger t1_i | t1_i <- t1_inRange]\n        (\u03c1', t1') = pkDecode (pkEncode \u03c1 t1)\n        inverts = (\u03c1 == \u03c1') && (t1 == t1')\n\n\/**\n * Encodes a secret key for ML-DSA into a byte string.\n * [FIPS-204] Secetion 7.2, Algorithm 24.\n *\/\nskEncode : [32]Byte -> [32]Byte -> [64]Byte -> [ell]R -> [k]R -> [k]R\n    -> PrivateKey\nskEncode \u03c1 K tr s1 s2 t0 = sk9 where\n    \/\/ Note: `sk#` indicates the value of `sk` at Step `#`.\n    \/\/ Step 1.\n    sk1 = \u03c1 # K # tr\n    \/\/ Steps 2 - 4.\n    sk3 = sk1 # join [BitPack`{\u03b7, \u03b7} (s1@i) | i <- [0..ell-1]]\n    \/\/ Steps 5 - 7.\n    sk6 = sk3 # join [BitPack`{\u03b7, \u03b7} (s2@i) | i <- [0..k-1]]\n    \/\/ Steps 8 - 10.\n    sk9 = sk6 #\n        join [BitPack`{2^^(d - 1) - 1, 2^^(d - 1)} (t0@i) | i <- [0..k-1]]\n\n\/**\n * Reverse the procedure `skEncode`.\n * [FIPS-204] Section 7.2, Algorithm 25.\n *\n * Warning: there exist malformed inputs that can cause `skDecode` to return\n * values that are not in the correct range! `skDecode` must only be run on\n * inputs that come from trusted sources!\n *\/\nskDecode : PrivateKey -> ([32]Byte, [32]Byte, [64]Byte, [ell]R, [k]R, [k]R)\nskDecode sk = (\u03c1, K, tr, s1, s2, t0) where\n    \/\/ Step 1. We split off the six components, then further separate `y`, `z`,\n    \/\/ and `w` into their two dimensions.\n    (\u03c1 # K # tr # yBytes # zBytes # wBytes) = sk\n    y = split`{ell} yBytes\n    z = split`{k} zBytes\n    w = split`{k} wBytes\n\n    \/\/ Steps 2 - 4.\n    s1 = [BitUnpack`{\u03b7, \u03b7} (y@i) | i <- [0..ell-1]]\n    \/\/ Steps 5 - 7.\n    s2 = [BitUnpack`{\u03b7, \u03b7} (z@i) | i <- [0..k-1]]\n    \/\/ Steps 8 - 10.\n    t0 = [BitUnpack`{2^^(d - 1) - 1, 2^^(d - 1)} (w@i) | i <- [0..k-1]]\n\nprivate\n    \/**\n     * The `skDecode` function must be the inverse of `skEncode`.\n     * [FIPS-204] Section 7.3, comment on Algorithm 25.\n     *\n     * This test enforces the range requirements on the inputs to\n     * `skEncode` by taking parameters in the integers mod groups, then\n     * converting to unbounded integers and shifting to be in the expected\n     * range.\n     *\n     * This takes about 1 minute.\n     * ```repl\n     * :set tests=20\n     * :check skCodingInverts\n     * ```\n     *\/\n    skCodingInverts : [32]Byte -> [32]Byte -> [64]Byte\n        -> [ell][256](Z (2 * \u03b7))\n        -> [k][256](Z (2 * \u03b7))\n        -> [k][256](Z (2 ^^ d - 1))\n        -> Bit\n    skCodingInverts \u03c1 K tr s1_inRange s2_inRange t0_inRange = inverts where\n        \/\/ Adjust to be in the correct range and of the correct type.\n        s1 = [[(fromZ s1_ij) - `\u03b7 | s1_ij <- s1_j ] | s1_j <- s1_inRange]\n        s2 = [[(fromZ s2_ij) - `\u03b7 | s2_ij <- s2_j ] | s2_j <- s2_inRange]\n        t0 = [[(fromZ t0_ij) - (2 ^^ (`d-1) - 1)\n            | t0_ij <- t0_j ]\n            | t0_j <- t0_inRange]\n\n        (\u03c1', K', tr', s1', s2', t0') = skDecode (skEncode \u03c1 K tr s1 s2 t0)\n        inverts = (\u03c1 == \u03c1') && (K == K') && (tr == tr')\n            && (s1 == s1') && (s2 == s2') && (t0 == t0')\n\n\/**\n * Encode a signature into a byte string.\n * [FIPS-204] Section 7.3, Algorithm 26.\n *\n * The parameter `z` must have coefficients in `[-\u03b31 + 1, \u03b31]`.\n *\/\nsigEncode : [\u03bb \/ 4]Byte -> [ell]R -> [k]R2 -> Signature\nsigEncode c_til z h = \u03c3 where\n    \/\/ Note that `\u03c3#` indicates the value of `\u03c3` at Step `#`.\n    \/\/ Step 1.\n    \u03c31 = c_til\n    \/\/ Step 2 - 4.\n    \u03c33 = \u03c31 # join [BitPack`{\u03b31 - 1, \u03b31} (z@i) | i <- [0..ell-1]]\n    \/\/ Step 5.\n    \u03c3 = \u03c33 # HintBitPack h\n\n\/**\n * Reverse the procedure `sigEncode`.\n * [FIPS-204] Section 7.3, Algorithm 27.\n *\/\nsigDecode : Signature -> ([\u03bb \/ 4]Byte, [ell]R, Option ([k]R2))\nsigDecode \u03c3 = (c_til, z, h) where\n    \/\/ Step 1. We separate into bytes, then further split `x` into its two\n    \/\/ dimensions.\n    (c_til # xBytes # y) = \u03c3\n    x = split`{ell} xBytes\n\n    \/\/ Step 2 - 4.\n    z = [BitUnpack`{\u03b31 - 1, \u03b31} (x@i) | i <- [0..ell-1]]\n    \/\/ Step 5.\n    h = HintBitUnpack y\n\nprivate\n    \/**\n     * `sigDecode` must be the reverse of `sigEncode`.\n     * [FIPS-204] Section 7.3, comment on Algorithm 27.\n     *\n     * The parameter `w` defines the number of non-zero entries in the hint.\n     * It can be any number in the range `[0, \u03c9 - 1]`. In practice, it's\n     * dependent on many factors, so we choose the middle of the range for convenience.\n     * This takes about 45 seconds.\n     * ```repl\n     * :set test=20\n     * :check sigCodingInverts`{\u03c9 \/ 2}\n     * ```\n     *\/\n    sigCodingInverts : {w} (w < \u03c9) =>\n        [\u03bb \/ 4]Byte -> [ell][256](Z (2 * \u03b31 - 1)) -> [w][lg2 (256 * k)] -> Bit\n    property sigCodingInverts c_til z_inRange h_Indexes = inverts where\n                        z = [[(fromZ zij) - (`\u03b31 - 1) | zij <- zi ] | zi <- z_inRange]\n\n                        h = buildHint h_Indexes\n\n        (c_til', z', maybe_h') = sigDecode (sigEncode c_til z h)\n        h_matches = case maybe_h' of\n            Some h' -> h == h'\n            None -> False\n        inverts = (c_til == c_til') && (z == z') && h_matches\n\nw1Encode : [k]R -> [32 * k * width ((q - 1) \/ (2 * \u03b32) - 1)]Byte\nw1Encode w1 = w1_til where\n    w1_til = join\n        [SimpleBitPack`{(q - 1) \/ (2 * \u03b32) - 1} (w1@i) | i <- [0..k-1]]\n\nSampleInBall : [\u03bb \/ 4]Byte -> R\nSampleInBall \u03c1 = cFinal where\n        c0 = zero\n        ctx_0 = H`{inf} \u03c1\n        ((s : [8]Byte) # ctx_1) = ctx_0\n        h = BytesToBits s\n\n            sample : [inf]Byte -> Byte -> (Byte, [inf]Byte)\n    sample ([j] # ctx) i =\n        if j > i then\n            sample ctx i\n        else (j, ctx)\n\n            cAndCtx = [(c0, ctx_1)] # [(c'', ctx') where\n            \/\/ Steps 7 - 10.\n            (j, ctx') = sample ctx (fromInteger i)\n                        c' = update c i (c@j)\n            \/\/ Step 12. In Cryptol, we need to manually convert the exponent\n            \/\/ from a `Bit` to a numeric type.\n            hi\u03c4 = if (h @ (i + `\u03c4 - 256)) then 1 else 0 : Integer\n            c'' = update c' j ((-1)^^hi\u03c4)\n\n        | i <- [256 - \u03c4..255]\n        | (c, ctx) <- cAndCtx]\n\n    (cFinal, _) = cAndCtx ! 0\n\nRejNTTPoly : [34]Byte -> Tq\nRejNTTPoly \u03c1 = a_hat where\n        ctx0 = G \u03c1\n\n        a_hat = take`{256} (sample ctx0)\n\n    sample : [inf][8] -> [inf](Z q)\n    sample GSqueeze = a_hat' where\n        \/\/ Step 5. This pops the first 3 bytes off the pseudorandom stream.\n        (s, ctx) = splitAt`{3} GSqueeze\n\n        \/\/ Step 6.\n        a_hat_j = CoeffFromThreeBytes (s@0) (s@1) (s@2)\n\n        \/\/ Step 7 - 9. The recursive call here replaces the `while` loop.\n        a_hat' = case a_hat_j of\n            Some aj -> [aj] # (sample ctx)\n                                                            None -> sample ctx\n\nRejBoundedPoly: [66]Byte -> R\nRejBoundedPoly \u03c1 = a where\n        ctx0 = H \u03c1\n\n        a = take`{256} (sample ctx0)\n\n    sample : [inf][8] -> [inf]Integer\n    sample HSqueeze = a' where\n        \/\/ Step 5. This pops one byte off the pseudorandom stream.\n        ([z] # ctx) = HSqueeze\n\n        \/\/ Step 6 - 8. We use Cryptol-native functions instead of dividing\n        \/\/ and modding `z`. See `TakeAndDropAreDivAndMod` for the equivalence.\n        z0 = CoeffFromHalfByte (drop`{4} z)\n        z1 = CoeffFromHalfByte (take`{4} z)\n\n        \/\/ Step 8 - 15. The recursive calls replace the `while` loop.\n        \/\/ In order to make the types work, we have to mash the two conditions\n        \/\/ together and make exactly one recursive call.\n        a' = case z0 of\n            Some z0' -> case z1 of\n                Some z1' -> [z0', z1'] # (sample ctx)\n                None -> [z0'] # (sample ctx)\n            None -> case z1 of\n                Some z1' -> [z1'] # (sample ctx)\n                None -> sample ctx\n\n\/**\n * Given a byte, the `take` function is equivalent to dividing by 16, and the\n * `drop` function is equivalent to taking the value mod 16.\n *\n * We prefer the Cryptol functions because they automatically convert from a\n * byte to a 4-bit value, which we need to call `CoeffFromHalfByte`. Here, we\n * use `zext` pad the 4-bit-vector, so we can compare it to the byte.\n * ```repl\n * :prove TakeAndDropAreDivAndMod\n * ```\n *\/\nTakeAndDropAreDivAndMod : [8] -> Bool\nproperty TakeAndDropAreDivAndMod z = dropIsMod && takeIsDiv where\n    dropIsMod = z % 16 == zext (drop`{4} z)\n    \/\/ Division of bit vectors in Cryptol automatically takes the floor.\n    takeIsDiv = z \/ 16 == zext (take`{4} z)\n\n\/**\n * Sample a `k x l` matrix of elements of `T_q`.\n * [FIPS-204] Section 7.3, Algorithm 32.\n *\/\nExpandA : [32]Byte -> [k][ell]Tq\nExpandA \u03c1 = A_hat where\n    A_hat = [[RejNTTPoly \u03c1' where\n            \u03c1' = \u03c1 # IntegerToBytes`{1} s # IntegerToBytes`{1} r\n        | s <- [0..ell - 1]]\n        | r <- [0..k - 1]]\n\n\/**\n * Sample vectors in `R^ell` and `R^k`, each with polynomial coordinates whose\n * coefficients are in the interval `[-\u03b7 , \u03b7]`.\n * [FIPS-204] Section 7.3, Algorithm 33.\n *\/\nExpandS : [64]Byte -> ([ell]R, [k]R)\nExpandS \u03c1 = (s1, s2) where\n    s1 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} r) | r <- [0..ell-1]]\n    s2 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} (r + `ell)) | r <- [0..k-1]]\n\n\/**\n * Sample a vector in `R^ell` such that each polynomial in `y` has coefficients\n * in the range `[-\u03b31 + 1, \u03b31]`.\n * [FIPS-204] Section 7.3, Algorithm 34.\n *\n * Note: This function requires that `\u03bc` is non-negative.\n *\/\nExpandMask : [64]Byte -> Integer -> [ell]R\nExpandMask \u03c1 \u03bc = y where\n    type c = 1 + width (\u03b31 - 1)\n\n    y = [BitUnpack`{\u03b31 - 1, \u03b31} v where\n            \u03c1' = \u03c1 # IntegerToBytes`{2} (\u03bc + r)\n            v = H`{32 * c} \u03c1'\n        | r <- [0..ell - 1]]\n\n\/**\n * Decompose a set of integers mod `q` into a pair `(r1, r0)` such that\n * `r === r1 * 2^d + r0 mod q`.\n *\n * This applies the `Power2Round` function (Algorithm 35) coefficientwise to\n * the polynomials in the vectors, per the description at the beginning of\n * [FIPS-204] Section 7.4.\n *\/\nPower2Round : [k]Rq -> ([k]R, [k]R)\nPower2Round r_vec = (r1_vec, r0_vec) where\n    \/\/ [FIPS-204] Section 7.4, Algorithm 35.\n    Power2Round_Single : Z q -> (Integer, Integer)\n    Power2Round_Single r = (r1, r0) where\n        r_plus = r\n        r0 = modPlusMinus`{2^^d} r_plus\n        r1 = ((fromZ r_plus) - r0) \/ (2^^`d)\n\n    \/\/ Apply the function coefficientwise to every polynomial.\n    zipped_r1r0 : [k][256](Integer, Integer)\n    zipped_r1r0 = [map Power2Round_Single r | r <- r_vec]\n\n    \/\/ Unzip the tuples.\n    r1_vec = [[r1_j | (r1_j, _) <- ri] | ri <- zipped_r1r0]\n    r0_vec = [[r0_j | (_, r0_j) <- ri] | ri <- zipped_r1r0]\n\nprivate\n    \/**\n     * Property demonstrating that `Power2Round` does what it says it's\n     * supposed to do in the definition.\n     * [FIPS-204] Section 7.4, comment on Algorithm 35.\n     * ```repl\n     * :check power2RoundSatisfiesDefinition\n     * ```\n     *\/\n    power2RoundSatisfiesDefinition r_vec = validDecomp where\n        (r1_vec, r0_vec)= Power2Round r_vec\n        isValid (r, (r1, r0)) = (r1 * 2^^`d + r0) % `q == (fromZ r)\n        validDecomp = and [ and (map isValid (zip rs (zip r1s r0s)))\n            | r1s <- r1_vec\n            | r0s <- r0_vec\n            | rs <- r_vec]\n\nDecompose : [k]Rq -> ([k]R, [k]R)\nDecompose r_vec = (r1_vec, r0_vec) where\n        Decompose_Single : Z q -> (Integer, Integer)\n    Decompose_Single r = (r1, r0') where\n        r_plus = r\n        r0 = modPlusMinus`{2 * \u03b32} r_plus\n        (r1, r0') = if (fromZ r_plus) - r0 == `q - 1 then\n                (0, r0 - 1)\n            else\n                (((fromZ r_plus) - r0) \/ (2 * `\u03b32), r0)\n\n        zipped_r1r0 : [k][256](Integer, Integer)\n    zipped_r1r0 = [map Decompose_Single r | r <- r_vec]\n\n        r1_vec = [[r1_j | (r1_j, _) <- ri] | ri <- zipped_r1r0]\n    r0_vec = [[r0_j | (_, r0_j) <- ri] | ri <- zipped_r1r0]\n\nprivate\n\n    decomposeSatisfiesDefinition r_vec = validDecomp where\n        (r1_vec, r0_vec)= Decompose r_vec\n        isValid (r, (r1, r0)) = (r1 * 2 * `\u03b32 + r0) % `q == (fromZ r)\n        validDecomp = and [ and (map isValid (zip rs (zip r1s r0s)))\n            | r1s <- r1_vec\n            | r0s <- r0_vec\n            | rs <- r_vec]\n\nHighBits : [k]Rq -> [k]R\nHighBits r = r1 where\n    (r1, _) = Decompose r\n\nLowBits : [k]Rq -> [k]R\nLowBits r = r0 where\n    (_, r0) = Decompose r\n\nMakeHint : [k]Rq -> [k]Rq -> [k]R2\nMakeHint z_vec r_vec = hint where\n    r1_vec = HighBits r_vec\n    v1_vec = HighBits (r_vec + z_vec)\n\n    hint = [[r1 != v1\n        | r1 <- r1s | v1 <- v1s]\n        | r1s <- r1_vec | v1s <- v1_vec]\n\nUseHint : [k]R2 -> [k]Rq -> [k]R\nUseHint h_vec r_vec = r1'_vec where\n    \/\/ Step 1.\n    m = (`q - 1) \/ (2 * `\u03b32)\n    \/\/ Step 2.\n    (r1_vec, r0_vec) = Decompose r_vec\n\n    \/\/ Steps 3 - 5. This takes the decomposed integers instead of the original\n    \/\/ element in `Z q`.\n    adjustHighBits r1 r0 h =\n        if (h == 1) && (r0 > 0) then (r1 + 1) % m\n        | (h == 1) && (r0 <= 0) then (r1 - 1) % m\n        else r1\n\n    \/\/ Apply the function coefficientwise to the decomposed polynomials.\n    r1'_vec = [[adjustHighBits r1 r0 h\n            | r1 <- r1s | r0 <- r0s | h <- hs]\n        | r1s <- r1_vec | r0s <- r0_vec | hs <- h_vec]\n\nprivate\n\n    property useHintIsInRange h_vec r_vec = r1InRange where\n        r1_vec = UseHint h_vec r_vec\n        inRange r1 = (0 <= r1) && (r1 <= (`q - 1) \/ (2 * `\u03b32))\n                r1InRange = and [and (map inRange r1s) | r1s <- r1_vec]\n\nNTT : Rq -> Tq\nNTT f = [f_hat_j j | j <- bitrev_indexes] where\n    f_hat_j j = sum [ (\u03b6 ^^ (2 * i * j + i)) * fi | i <- [0..255] | fi <- f]\n\n            bitrev_indexes = map toInteger (map reverse [0..255 : [8]])\n\nNTTInv : Tq -> Rq\nNTTInv f_hat = [f_i j * inv_root | j <- [0..255]] where\n    inv_root = recip 256 : Z q\n    inv_\u03b6 = recip \u03b6\n    f_i j = sum [ (inv_\u03b6 ^^ (2 * i * j + j)) * f_hat_j\n        | i <- [0..255]\n        | f_hat_j <- indexReversedFHat]\n\n        bitrev_indexes = map reverse [0..255 : [8]]\n    indexReversedFHat = [f_hat@i | i <- bitrev_indexes]\n\nprivate\n\n    NTT_Inverts : Rq -> Bit\n    property NTT_Inverts f =  NTTInv (NTT f) == f\n\n    NTTInv_Inverts : Tq -> Bit\n    property NTTInv_Inverts f =  NTT (NTTInv f) == f\n\nAddNTT : Tq -> Tq -> Tq\nAddNTT a b = c where\n    c = [a@i + b@i | i <- [0..255]]\n\nproperty addNTTisPlus a b = AddNTT a b == a + b\n\nMultiplyNTT : Tq -> Tq -> Tq\nMultiplyNTT a b = c where\n    c = [a@i * b@i | i <- [0..255]]\n\nproperty multiplyNTTisStar a b = MultiplyNTT a b == a * b\n\nAddVectorNTT : {l} (fin l, l > 0) => [l]Tq -> [l]Tq -> [l]Tq\nAddVectorNTT v w = u where\n    u = [AddNTT (v@i) (w@i) | i <- [0..l-1]]\n\naddVectorNTTisPlus : {r} (fin r, r > 0) => [r]Tq -> [r]Tq -> Bit\nproperty addVectorNTTisPlus v w = AddVectorNTT v w == v + w\n\nScalarVectorNTT : {l} (fin l, l > 0) => Tq -> [l]Tq -> [l]Tq\nScalarVectorNTT c v = w where\n    w = [MultiplyNTT c (v@i) | i <- [0..l-1]]\n\n(\u2218) : {l} (fin l, l > 0) => Tq -> [l]Tq -> [l]Tq\n(\u2218) c v = [c * vi | vi <- v]\n\nringIsScalarVectorNTT : {l} (fin l, l > 0) => Tq -> [l]Tq -> Bit\nproperty ringIsScalarVectorNTT c v = c \u2218 v == ScalarVectorNTT c v\n\nMatrixVectorNTT : [k][ell]Tq -> [ell]Tq -> [k]Tq\nMatrixVectorNTT M v = w where\n            w = [sum [ MultiplyNTT (M@i@j) (v@j)\n        | j <- [0..ell-1]]\n        | i <- [0..k-1] ]\n\n(\u2218\u2218) : [k][ell]Tq -> [ell]Tq -> [k]Tq\n(\u2218\u2218) M v = [sum [Mij * vj | Mij <- Mi | vj <- v] | Mi <- M]\n\ndoubleRingIsMatrixVectorNTT : [k][ell]Tq -> [ell]Tq -> Bit\nproperty doubleRingIsMatrixVectorNTT M v = (M \u2218\u2218 v) == MatrixVectorNTT M v\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/OptimizedSpecification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification that contains: (1) type synonyms q, \u03c9, k, ell, \u03b7, \u03bb, \u03b31, \u03b32, \u03c4 sourced from a parameters interface; aliases Byte, Tq, R, R2, Rq; constants\/functions H, HBits, G, \u03b6, \u03b2; type d; key types PublicKey, PrivateKey, Signature. (2) Aliases to reference implementations: infNormRq, infNormR, castToRq, NTT_Vec, NTTInv_Vec, Sign_internal, Verify_internal, B2B2BInverts, CoeffFromThreeBytes, CoeffFromHalfByte, HintBitPack, HintBitUnpack, RejNTTPoly, RejBoundedPoly, Power2Round, Decompose, HighBits, LowBits, MakeHint, UseHint, NTT, NTTInv, AddNTT, MultiplyNTT, AddVectorNTT, ScalarVectorNTT, MatrixVectorNTT. (3) A function modPlusMinus that converts residues modulo q to signed Integers, polymorphic over finite type parameters. (4) A key generation function KeyGen_internal: [32] of Byte -> (PublicKey, PrivateKey) that hashes an input seed to derive matrix\/secret seeds, expands the public matrix and secret vectors, transforms via NTT, rounds\/splits coefficients, and encodes public and private keys using pkEncode and skEncode. Define a property that KeyGen_internal equals the reference implementation on all inputs. (5) Bit\/byte conversion utilities with stated constraints: IntegerToBits and BitsToInteger (\u03b1 finite, \u03b1 > 0); IntegerToBytes (\u03b1 finite, \u03b1 > 0); BitsToBytes and BytesToBits (\u03b1 finite). For each, define a property that the implementation equals the reference. (6) Packing\/unpacking: SimpleBitPack\/Unpack (b finite, width b > 0) and BitPack\/Unpack (a,b finite, width(a+b) > 0); for each, define a property that it equals the reference. (7) Key encoders\/decoders pkEncode\/pkDecode and skEncode\/skDecode with their standard ML-DSA vector\/byte layouts; for each, define a property that it equals the reference. (8) Signature encoders\/decoders sigEncode\/sigDecode. (9) w1Encode with its equivalence property. (10) A sampling function SampleInBall from a hash-derived context; define a property that it equals the reference. (11) ExpandA, ExpandS, ExpandMask with properties stating equality to the reference. (12) An operator for Tq matrix\u2013vector multiplication over length parameters k and ell."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification where\n\nimport interface Primitive::Asymmetric::Signature::ML_DSA::Parameters as P\nimport Primitive::Asymmetric::Signature::ML_DSA::Specification { interface P }  as Spec\n\ntype q = P::q\ntype \u03c9 = P::\u03c9\ntype k = P::k\ntype ell = P::ell\ntype \u03b7 = P::\u03b7\ntype \u03bb = P::\u03bb\ntype \u03b31 = P::\u03b31\ntype \u03b32 = P::\u03b32\ntype \u03c4 = P::\u03c4\n\ntype Byte = Spec::Byte\n\ntype Tq = Spec::Tq\ntype R = Spec::R\ntype R2 = Spec::R2\ntype Rq = Spec::Rq\n\nmodPlusMinus : {\u03b1} (fin \u03b1) => Z q -> Integer\nmodPlusMinus = Spec::modPlusMinus`{\u03b1}\n\ninfNormRq = Spec::infNormRq\n\ninfNormR = Spec::infNormR\n\ncastToRq = Spec::castToRq\n\nNTT_Vec = Spec::NTT_Vec\n\nNTTInv_Vec = Spec::NTTInv_Vec\n\nH = Spec::H\n\nHBits = Spec::HBits\n\nG = Spec::G\n\n\u03b6 = Spec::\u03b6\n\ntype d = Spec::d\n\n\u03b2 = Spec::\u03b2\n\ntype PublicKey = Spec::PublicKey\n\ntype PrivateKey = Spec::PrivateKey\n\ntype Signature = Spec::Signature\n\nKeyGen_internal : [32]Byte -> (PublicKey, PrivateKey)\nKeyGen_internal \u03be = (pk, sk) where\n        (\u03c1 # \u03c1' # K) = H (\u03be # IntegerToBytes`{1} `k # IntegerToBytes`{1} `ell)\n\n    \/\/ Step 3.\n    A_hat = ExpandA \u03c1\n    \/\/ Step 4.\n    (s1, s2) = ExpandS \u03c1'\n\n        s1' = castToRq s1\n    s2' = castToRq s2\n\n        t = NTTInv_Vec (A_hat \u2218\u2218 NTT_Vec s1') + s2'\n        (t1, t0) = Power2Round t\n\n        pk = pkEncode \u03c1 t1\n        tr = H pk\n        sk = skEncode \u03c1 K tr s1 s2 t0\n\nKeyGen_internalEquivalence : [32]Byte -> Bit\nproperty KeyGen_internalEquivalence \u03be = Spec::KeyGen_internal \u03be == KeyGen_internal \u03be\n\nSign_internal = Spec::Sign_internal\n\nVerify_internal = Spec::Verify_internal\n\nIntegerToBits : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]\nIntegerToBits x = reverse (fromInteger x)\n\nIntegerToBitsEquivalence : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> Bit\nproperty IntegerToBitsEquivalence x = Spec::IntegerToBits`{\u03b1} x == IntegerToBits`{\u03b1} x\n\nBitsToInteger y = toInteger (reverse y)\n\nBitsToIntegerEquivalence : {\u03b1} (fin \u03b1, \u03b1 > 0) => [\u03b1] -> Bit\nproperty BitsToIntegerEquivalence x = Spec::BitsToInteger x == BitsToInteger x\n\nIntegerToBytes : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]Byte\nIntegerToBytes x = reverse (split (fromInteger x))\n\nIntegerToBytesEquivalence : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> Bit\nproperty IntegerToBytesEquivalence x = Spec::IntegerToBytes`{\u03b1} x == IntegerToBytes`{\u03b1} x\n\nBitsToBytes : {\u03b1} (fin \u03b1) => [\u03b1]Bit -> [\u03b1 \/^ 8]Byte\nBitsToBytes y = map reverse (split (y # zero))\n\nBitsToBytesEquivalence : {\u03b1} (fin \u03b1) => [\u03b1]Bit -> Bit\nproperty BitsToBytesEquivalence x = Spec::BitsToBytes x == BitsToBytes x\n\nBytesToBits : {\u03b1} (fin \u03b1) => [\u03b1]Byte -> [8 * \u03b1]Bit\nBytesToBits z = join (map reverse z)\n\nBytesToBitsEquivalence : {\u03b1} (fin \u03b1) => [\u03b1]Byte -> Bit\nproperty BytesToBitsEquivalence x = Spec::BytesToBits x == BytesToBits x\n\nB2B2BInverts = Spec::B2B2BInverts\n\nCoeffFromThreeBytes = Spec::CoeffFromThreeBytes\n\nCoeffFromHalfByte = Spec::CoeffFromHalfByte\n\nSimpleBitPack : {b} (fin b, width b > 0) => R -> [32 * width b]Byte\nSimpleBitPack w = BitsToBytes (join (map IntegerToBits`{width b} w))\n\nSimpleBitPackEquivalence : {b} (fin b, width b > 0) => R -> Bit\nproperty SimpleBitPackEquivalence w = Spec::SimpleBitPack`{b} w == SimpleBitPack`{b} w\n\nBitPack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    R -> [32 * width (a + b)]Byte\nBitPack w = BitsToBytes (join (map (\\x -> IntegerToBits`{width (a + b)} (`b - x)) w))\n\nBitPackEquivalence : {a, b} (fin a, fin b, width (a + b) > 0) => R -> Bit\nproperty BitPackEquivalence w = Spec::BitPack`{a, b} w == BitPack`{a, b} w\n\nSimpleBitUnpack : {b} (fin b, width b > 0) => [32 * width b]Byte -> R\nSimpleBitUnpack v = map BitsToInteger (split (BytesToBits v))\n\nSimpleBitUnpackEquivalence : {b} (fin b, width b > 0) => [32 * width b]Byte -> Bit\nproperty SimpleBitUnpackEquivalence v = Spec::SimpleBitUnpack`{b} v == SimpleBitUnpack`{b} v\n\nBitUnpack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    [32 * width (a + b)]Byte -> R\nBitUnpack v = map (\\x -> `b - BitsToInteger x) (split (BytesToBits v))\n\nBitUnpackEquivalence : {a, b} (fin a, fin b, width (a + b) > 0) => [32 * width (a + b)]Byte -> Bit\nproperty BitUnpackEquivalence v = Spec::BitUnpack`{a, b} v == BitUnpack`{a, b} v\n\nHintBitPack = Spec::HintBitPack\n\nHintBitUnpack = Spec::HintBitUnpack\n\npkEncode : [32]Byte -> [k]R -> PublicKey\npkEncode \u03c1 t1 = pk where\n    pk = \u03c1 # join [SimpleBitPack`{2 ^^ (width (q - 1) - d) - 1} (t1@i) | i <- [0..k-1]]\n\npkEncodeEquivalence : [32]Byte -> [k]R -> Bit\nproperty pkEncodeEquivalence \u03c1 t1 = Spec::pkEncode \u03c1 t1 == pkEncode \u03c1 t1\n\npkDecode : PublicKey -> ([32]Byte, [k]R)\npkDecode pk = (\u03c1, t1) where\n            (\u03c1 # zBytes) = pk\n    z = split zBytes\n        t1 = [SimpleBitUnpack`{2 ^^ (width (q - 1) - d) - 1} (z@i) | i <- [0..k-1]]\n\npkDecodeEquivalence : PublicKey -> Bit\nproperty pkDecodeEquivalence pk = Spec::pkDecode pk == pkDecode pk\n\nskEncode : [32]Byte -> [32]Byte -> [64]Byte -> [ell]R -> [k]R -> [k]R\n    -> PrivateKey\nskEncode \u03c1 K tr s1 s2 t0 = sk9 where\n            sk1 = \u03c1 # K # tr\n        sk3 = sk1 # join [BitPack`{\u03b7, \u03b7} (s1@i) | i <- [0..ell-1]]\n        sk6 = sk3 # join [BitPack`{\u03b7, \u03b7} (s2@i) | i <- [0..k-1]]\n        sk9 = sk6 #\n        join [BitPack`{2^^(d - 1) - 1, 2^^(d - 1)} (t0@i) | i <- [0..k-1]]\n\nskEncodeEquivalence : [32]Byte -> [32]Byte -> [64]Byte -> [ell]R -> [k]R -> [k]R -> Bit\nproperty skEncodeEquivalence \u03c1 K tr s1 s2 t0 = Spec::skEncode \u03c1 K tr s1 s2 t0 == skEncode \u03c1 K tr s1 s2 t0\n\nskDecode : PrivateKey -> ([32]Byte, [32]Byte, [64]Byte, [ell]R, [k]R, [k]R)\nskDecode sk = (\u03c1, K, tr, s1, s2, t0) where\n            (\u03c1 # K # tr # yBytes # zBytes # wBytes) = sk\n    y = split`{ell} yBytes\n    z = split`{k} zBytes\n    w = split`{k} wBytes\n\n        s1 = [BitUnpack`{\u03b7, \u03b7} (y@i) | i <- [0..ell-1]]\n        s2 = [BitUnpack`{\u03b7, \u03b7} (z@i) | i <- [0..k-1]]\n        t0 = [BitUnpack`{2^^(d - 1) - 1, 2^^(d - 1)} (w@i) | i <- [0..k-1]]\n\nskDecodeEquivalence : PrivateKey -> Bit\nproperty skDecodeEquivalence sk = Spec::skDecode sk == skDecode sk\n\nsigEncode : [\u03bb \/ 4]Byte -> [ell]R -> [k]R2 -> Signature\nsigEncode c_til z h = \u03c3 where\n            \u03c31 = c_til\n        \u03c33 = \u03c31 # join [BitPack`{\u03b31 - 1, \u03b31} (z@i) | i <- [0..ell-1]]\n        \u03c3 = \u03c33 # HintBitPack h\n\nsigDecode : Signature -> ([\u03bb \/ 4]Byte, [ell]R, Option ([k]R2))\nsigDecode \u03c3 = (c_til, z, h) where\n            (c_til # xBytes # y) = \u03c3\n    x = split`{ell} xBytes\n\n        z = [BitUnpack`{\u03b31 - 1, \u03b31} (x@i) | i <- [0..ell-1]]\n        h = HintBitUnpack y\n\nw1Encode : [k]R -> [32 * k * width ((q - 1) \/ (2 * \u03b32) - 1)]Byte\nw1Encode w1 = w1_til where\n    w1_til = join\n        [SimpleBitPack`{(q - 1) \/ (2 * \u03b32) - 1} (w1@i) | i <- [0..k-1]]\n\nw1EncodeEquivalence : [k]R -> Bit\nproperty w1EncodeEquivalence w1 = Spec::w1Encode w1 == w1Encode w1\n\nSampleInBall : [\u03bb \/ 4]Byte -> R\nSampleInBall \u03c1 = cFinal where\n        c0 = zero\n        ctx_0 = H \u03c1\n        ((s : [8]Byte) # ctx_1) = ctx_0\n        h = BytesToBits s\n\n            sample : [inf]Byte -> Byte -> (Byte, [inf]Byte)\n    sample ([j] # ctx) i =\n        if j > i then\n            sample ctx i\n        else (j, ctx)\n\n            cAndCtx = [(c0, ctx_1)] # [(c'', ctx') where\n            \/\/ Steps 7 - 10.\n            (j, ctx') = sample ctx (fromInteger i)\n                        c' = update c i (c@j)\n            \/\/ Step 12. In Cryptol, we need to manually convert the exponent\n            \/\/ from a `Bit` to a numeric type.\n            hi\u03c4 = if (h @ (i + `\u03c4 - 256)) then 1 else 0 : Integer\n            c'' = update c' j ((-1)^^hi\u03c4)\n\n        | i <- [256 - \u03c4..255]\n        | (c, ctx) <- cAndCtx]\n\n    (cFinal, _) = cAndCtx ! 0\n\nSampleInBallEquivalence : [\u03bb \/ 4]Byte -> Bit\nproperty SampleInBallEquivalence \u03c1 = Spec::SampleInBall \u03c1 == SampleInBall \u03c1\n\nRejNTTPoly = Spec::RejNTTPoly\n\nRejBoundedPoly = Spec::RejBoundedPoly\n\nExpandA : [32]Byte -> [k][ell]Tq\nExpandA \u03c1 = A_hat where\n    A_hat = [[RejNTTPoly \u03c1' where\n            \u03c1' = \u03c1 # IntegerToBytes`{1} s # IntegerToBytes`{1} r\n        | s <- [0..ell - 1]]\n        | r <- [0..k - 1]]\n\nExpandAEquivalence : [32]Byte -> Bit\nproperty ExpandAEquivalence \u03c1 = Spec::ExpandA \u03c1 == ExpandA \u03c1\n\nExpandS : [64]Byte -> ([ell]R, [k]R)\nExpandS \u03c1 = (s1, s2) where\n    s1 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} r) | r <- [0..ell-1]]\n    s2 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} (r + `ell)) | r <- [0..k-1]]\n\nExpandSEquivalence : [64]Byte -> Bit\nproperty ExpandSEquivalence \u03c1 = Spec::ExpandS \u03c1 == ExpandS \u03c1\n\nExpandMask : [64]Byte -> Integer -> [ell]R\nExpandMask \u03c1 \u03bc = y where\n\n    y = [BitUnpack`{\u03b31 - 1, \u03b31} v where\n            \u03c1' = \u03c1 # IntegerToBytes`{2} (\u03bc + r)\n            v = H \u03c1'\n        | r <- [0..ell - 1]]\n\nExpandMaskEquivalence : [64]Byte -> Integer -> Bit\nproperty ExpandMaskEquivalence \u03c1 \u03bc = Spec::ExpandMask \u03c1 \u03bc == ExpandMask \u03c1 \u03bc\n\nPower2Round = Spec::Power2Round\n\nDecompose = Spec::Decompose\n\nHighBits = Spec::HighBits\n\nLowBits = Spec::LowBits\n\nMakeHint = Spec::MakeHint\n\nUseHint = Spec::UseHint\n\nNTT = Spec::NTT\n\nNTTInv = Spec::NTTInv\n\nAddNTT = Spec::AddNTT\n\nMultiplyNTT = Spec::MultiplyNTT\n\nAddVectorNTT = Spec::AddVectorNTT\n\nScalarVectorNTT = Spec::ScalarVectorNTT\n\nMatrixVectorNTT = Spec::MatrixVectorNTT\n\n(\u2218\u2218) : [k][ell]Tq -> [ell]Tq -> [k]Tq\n(\u2218\u2218) M v = [sum [Mij * vj | Mij <- Mi | vj <- v] | Mi <- M]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an interface module named Primitive::Asymmetric::Signature::ML_DSA::Parameters that contains the following type-level declarations and constraints for ML-DSA parameters: (1) A type-level natural constant q equal to 8380417. (2) A numeric type variable \u03c4 with 0 < \u03c4 and \u03c4 \u2264 64. (3) A numeric type variable \u03bb that is finite. (4) A numeric type variable \u03b31 that is finite, is a power of two, and satisfies: the bit-width of (\u03b31 \u2212 1) plus 1 equals the bit-width of ((\u03b31 \u2212 1) + \u03b31). (5) A numeric type variable \u03b32 that is positive, such that q \u2212 1 is divisible by 2\u00b7\u03b32, and the bit-width of (((q \u2212 1) \/ (2\u00b7\u03b32)) \u2212 1) is positive. (6) Numeric type variables k and ell that are finite and strictly positive. (7) A numeric type variable \u03b7 that is even and lies in the inclusive range [2, 4]. (8) A numeric type variable \u03c9 that is finite, strictly positive, and whose bit-width is at most 8. Ensure all variables are of numeric kind and all constraints are expressed at the type level using Cryptol\u2019s constraint syntax, with no term-level definitions."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Asymmetric::Signature::ML_DSA::Parameters where\n\n    type q = 8380417\n\n    type \u03c4 : #\n    type constraint (0 < \u03c4, \u03c4 <= 64)\n\n    type \u03bb : #\n    type constraint (fin \u03bb)\n\n    type \u03b31 : #\n    type constraint (fin \u03b31, 2 ^^ (lg2 \u03b31) == \u03b31)\n    type constraint (1 + width (\u03b31 - 1) == width (\u03b31 - 1 + \u03b31))\n\n    type \u03b32 : #\n    type constraint (\u03b32 > 0, (q - 1) % (2 * \u03b32) == 0)\n    type constraint (width ((q - 1) \/ (2 * \u03b32) - 1) > 0)\n\n    type k : #\n    type ell : #\n    type constraint (fin k, fin ell, k > 0, ell > 0)\n\n    type \u03b7 : #\n    type constraint (\u03b7 % 2 == 0, 2 <= \u03b7, \u03b7 <= 4)\n\n    type \u03c9 : #\n    type constraint (fin \u03c9, \u03c9 > 0, width \u03c9 <= 8)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/UnconstrainedSpec.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec that imports the EC interface as EC and the hash interface as Hash, and includes the following definitions with clear type signatures, constraints, and behavior: 1) sign: for any message bitvector of length m with fin m and width m < Hash::MessageUpperBound, take a secret scalar and an ephemeral scalar in Z EC::n and return an Option of a pair in Z EC::n. If both scalars are nonzero, compute the hash-truncated message, multiply the generator by the ephemeral scalar to get a point, derive the first scalar from that point\u2019s x-coordinate reduced into Z EC::n, and compute the second scalar as the modular product of the inverse ephemeral with the sum of the hash-truncated message and the product of the first scalar and the secret. Return Some pair if both scalars are nonzero; otherwise None. 2) verify: under the same m constraints, take a message, a pair of scalars in Z EC::n, and a public point, and return Bool. Require both input scalars nonzero, compute the hash-truncated message, form two scalars using the modular inverse of the second scalar, compute the linear combination of the generator and the public point via double-scalar multiplication, and succeed if the reduced x-coordinate of the result equals the first input scalar; otherwise fail. 3) publicKey: map a secret scalar in Z EC::n to a point by scalar multiplying the generator. 4) property signAndVerifyIsCorrect: define a property asserting that for any admissible inputs, if signing produces a pair, then verification with the corresponding public key returns true; otherwise false. 5) A private helper hashAndTruncate that hashes the message, truncates to the minimum of the group order bit-width and the hash digest length, converts to an integer, and embeds into Z EC::n."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec where\n\nimport interface Common::EC::ECInterface as EC\n\nimport interface Primitive::Keyless::Hash::HashInterface as Hash\n\nsign : {m} (fin m, width m < Hash::MessageUpperBound) =>\n    [m] -> Z EC::n -> Z EC::n -> Option (Z EC::n, Z EC::n)\nsign M d k = if inputsInRange then maybe_rs else None\n    where\n                inputsInRange = (0 != d) && (0 != k)\n\n                e = hashAndTruncate M\n\n                                k_inv = recip k\n\n                R = EC::scmul (fromZ k) EC::G\n\n                                        maybe_rs = case EC::xCoord R of\n                                    Some xR -> if (r != 0) && (s != 0) then Some (r, s) else None\n                where\n                                                            r1 = fromZ xR\n                                        r = fromInteger r1\n                                                            s = k_inv * (e + r * d)\n\n            None -> None \n\nverify : {m} (fin m, width m < Hash::MessageUpperBound) =>\n    [m] -> (Z EC::n, Z EC::n) -> EC::Point -> Bool\nverify M (r, s) Q = inputsInRange && rMatches\n    where\n                inputsInRange = (0 != r) && (0 != s)\n\n                e = hashAndTruncate M\n\n                                s_inv = recip s\n\n                u = e * s_inv\n        v = r * s_inv\n\n                R_1 = EC::twin_mul (fromZ u) EC::G (fromZ v) Q\n\n                rMatches = case EC::xCoord R_1 of\n                        Some xR -> r1 == r where\n                                                r1 = fromInteger (fromZ xR)\n            None -> False\n\npublicKey : Z EC::n -> EC::Point\npublicKey d = EC::scmul (fromZ d) EC::G\n\nsignAndVerifyIsCorrect : {m} (fin m, width m < Hash::MessageUpperBound) =>\n    [m] -> Z EC::n -> Z EC::n -> Bool\nproperty signAndVerifyIsCorrect M d k = verification\n    where\n        Q = publicKey d\n        signature = sign M d k\n        verification = case signature of\n            Some (r, s) -> verify M (r, s) Q\n            None -> False\n\nprivate\n\n    hashAndTruncate : {m} (fin m, width m < Hash::MessageUpperBound) => [m] -> Z EC::n\n    hashAndTruncate M = e\n        where\n            H = Hash::hash M\n            e' = take`{min (width EC::n) Hash::DigestLength} H\n            \/\/ Cryptol's default bitstring-to-integer `toInteger` conversion\n                                                e = fromInteger (toInteger e')\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::XMSS::Specification that contains the following definitions: import the XMSS Parameters interface and the WOTS interface (aliased), enforce the constraint that the XMSS digest size equals the WOTS digest size. Re-export Address, Byte, and Seed from WOTS, define a 32-bit word type, and define L-tree and hash-tree address types as 32-byte arrays. Define record types for the private key (including an array of 2^h WOTS private keys, an index, PRF key, root, and seed), public key (OID, root, seed), and signature (index, per-signature randomness, WOTS signature, authentication path). Provide private address-manipulation helpers to set\/get type, L-tree fields (height, index, key\/mask), and OTS address fields; include setters\/getters for the private-key index and WOTS secret-key array access. Specify RAND_HASH that derives a key and two bitmasks via the PRF over the seed and keyed address fields, and hashes the masked pair of n-byte inputs with a keyed hash. Define ltree_pk (one reduction round), a recursive ltree\u2019 (handles even\/odd lengths and updates height), and ltree (initializes height and compresses a WOTS public key to n bytes). Define treeHash_base (leaf computation over a block aligned start index), treeHash_combine (pairwise upward hashing with address updates), and treeHash (root of a subtree of height t), with constraints t \u2264 h and all sizes finite and index widths fitting in Word. Define keyGen (compute root via treeHash), buildAuth (recursive authentication path), treeSig (WOTS sign and auth), sign (updates index, derives randomness, hashes message, returns updated key and signature), rootFromSig (reconstruct root from signature and auth), and verify (checks reconstructed root equals the public root). Define properties: test_tree_height_getter_setter and test_tree_index_getter_setter (each checks its getter\/setter round-trip), and XMSSInverts (for any inputs, a generated keypair and produced signature verify). Apply all finiteness, width, and message-size bounds indicated by the parameters."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::XMSS::Specification where\n\nimport interface Primitive::Asymmetric::Signature::XMSS::Parameters\nimport interface Primitive::Asymmetric::Signature::WOTS::Interface as WOTS\n\ninterface constraint (n == WOTS::n)\n\ntype Address = WOTS::Address\ntype Byte = WOTS::Byte\ntype Seed = WOTS::Seed\n\nprivate\n\n    setType : Address -> Word -> Address\n    setType address value = take`{3 * 4} address # split value # drop`{4 * 4} address\n\ntype Word = [32]\n\ntype LTreeAddress = [8 * 4]Byte\n\nprivate\n\n    setLTreeAddress : LTreeAddress -> Word -> LTreeAddress\n    setLTreeAddress address value = take`{4 * 4} address # (split value) # drop`{5 * 4} address\n\n    setTreeHeight : LTreeAddress -> Word -> LTreeAddress\n    setTreeHeight address value = take`{5 * 4} address # (split value) # drop`{6 * 4} address\n\n    getTreeHeight : LTreeAddress -> Word\n    getTreeHeight address = value where\n        value = join (take`{1 * 4} (drop`{5 * 4} address))\n\n    property test_tree_height_getter_setter ADRS i = i' == i where\n        ADRS' = setTreeHeight ADRS i\n        i' = getTreeHeight ADRS'\n\n    setTreeIndex : LTreeAddress -> Word -> LTreeAddress\n    setTreeIndex address value = take`{6 * 4} address # (split value) # drop`{7 * 4} address\n\n    getTreeIndex : LTreeAddress -> Word\n    getTreeIndex address = join (take`{1 * 4} (drop`{6 * 4} address))\n\n    property test_tree_index_getter_setter ADRS i = i' == i where\n        ADRS' = setTreeIndex ADRS i\n        i' = getTreeIndex ADRS'\n\n    setKeyAndMask : LTreeAddress -> Word -> LTreeAddress\n    setKeyAndMask address value = take`{7 * 4} address # split value\n\ntype HashTreeAddress = [8 * 4]Byte\n\ntype PrivateKey = {\n    oid: [32],\n    wots_sks: [2^^h]WOTS::PrivateKey,\n    idx: Word,\n    SK_PRF: [n]Byte,\n    root: [n]Byte,\n    seed: Seed\n}\n\nprivate\n\n    setIdx : PrivateKey -> Word -> PrivateKey\n    setIdx SK idx = { SK | idx = idx }\n\n    getWOTS_SK : PrivateKey -> Word -> WOTS::PrivateKey\n    getWOTS_SK SK i = SK.wots_sks @ i\n\ntype PublicKey = {\n    oid: [32],\n    root: [n]Byte,\n    seed: Seed\n}\n\ntype Signature = {\n    idx_sig: Word,\n    r: [n]Byte,\n    sig_ots: WOTS::Signature,\n    auth: [h][n]Byte\n}\n\nprivate\n\n    setOTSAddress : WOTS::OTSHashAddress -> Word -> WOTS::OTSHashAddress\n    setOTSAddress address value = take`{4 * 4} address # (split value) # drop`{5 * 4} address\n\n    RAND_HASH : [n]Byte -> [n]Byte -> Seed -> LTreeAddress -> [n]Byte\n    RAND_HASH LEFT RIGHT SEED ADRS = hash where\n        ADRS' = setKeyAndMask ADRS 0\n        KEY = WOTS::PRF SEED ADRS'\n        ADRS'' = setKeyAndMask ADRS' 1\n        BM_0 = WOTS::PRF SEED ADRS''\n        ADRS''' = setKeyAndMask ADRS'' 2\n        BM_1 = WOTS::PRF SEED ADRS'''\n        hash = H KEY ((LEFT ^ BM_0) # (RIGHT ^ BM_1))\n\n    \/**\n     * Helper function for `ltree` for computing `pk`.\n     *\n     * This corresponds to the `for`-loop in Algorithm 8:\n     *\n     *   for ( i = 0; i < floor(len' \/ 2); i++ ) {\n     *     ADRS.setTreeIndex(i);\n     *     pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n     *   }\n     *\n     * [RFC-8391] Section 4.1.5, Algorithm 8.\n     *\/\n    ltree_pk : {len', half_floor} (\n            fin len',\n\n            len' > 1,\n            half_floor == len' \/ 2,             \n            width (half_floor - 1) <= 32\n\n        ) => [len'][n]Byte -> Seed -> LTreeAddress -> [half_floor][n]Byte\n    ltree_pk pk SEED ADRS = pk' where\n        pk' = [ pk_i where\n                ADRS' = setTreeIndex ADRS i\n                pk_i = RAND_HASH (pk @ (2 * i)) (pk @ (2 * i + 1)) SEED ADRS'\n              | i <- [0..half_floor - 1]\n              ]\n\n    \/**\n     * Recursive version of `ltree`.\n     *\n     * This corresponds to the `while`-loop in Algorithm 8:\n     *\n     *   while ( len' > 1 ) {\n     *          *     for ( i = 0; i < floor(len' \/ 2); i++ ) {\n     *       ADRS.setTreeIndex(i);\n     *       pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n     *     }\n     *     if ( len' % 2 == 1 ) {\n     *       pk[floor(len' \/ 2)] = pk[len' - 1];\n     *     }\n     *    len' = ceil(len' \/ 2);\n     *    ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     *  }\n     *\n     * [RFC-8391] Section 4.1.5, Algorithm 8.\n     *\/\n    ltree' : {len', half_floor, half_ceil} (\n            fin len',\n            len' >= 1,\n            half_floor == len' \/ 2, \/\/ Equivalent to `floor(len' \/ 2)`\n            width half_floor <= 32,\n            half_ceil == len' \/^ 2  \/\/ Equivalent to `ceil(len' \/ 2)`\n        ) => [len'][n]Byte -> Seed -> LTreeAddress -> [n]Byte\n    ltree' pk SEED ADRS\n\n        | len' == 1 => pk @ 0\n        \/*\n         * The `while`-loop condition for when `len' % 2 == 0`.\n         *\n         * In this case, we do not need to append `pk[len' - 1]` to the end of\n         * `pk`.\n         *\/\n        | (len' > 1, len' % 2 == 0) => result where\n            pk' = ltree_pk pk SEED ADRS\n            ADRS' = setTreeHeight ADRS ((getTreeHeight ADRS) + 1)\n            result = ltree'`{half_ceil} pk' SEED ADRS'\n\n        | (len' > 1, len' % 2 == 1) => result where\n            pk' = (ltree_pk pk SEED ADRS) # split (pk ! 0)\n            ADRS' = setTreeHeight ADRS ((getTreeHeight ADRS) + 1)\n            result = ltree'`{half_ceil} pk' SEED ADRS'\n\n    \/**\n     * `ltree` - unbalanced binary hash tree.\n     *\n     * To compute the leaves of the binary hash tree, a so-called L-tree is\n     * used.  An L-tree is an unbalanced binary hash tree, distinct but similar\n     * to the main XMSS binary hash tree.  The algorithm `ltree` takes as input\n     * a WOTS+ public key pk and compresses it to a single n-byte value pk[0].\n     * It also takes as input an L-tree address ADRS that encodes the address of\n     * the L-tree and the seed SEED.\n     *\n     * Note: We implement `ltree` using recursion instead of the `while`-loop as\n     * specified in Algorithm 8.\n     *\n     *   Input: WOTS+ public key pk, seed SEED, address ADRS (Note: [Errata-5572])\n     *   Output: n-byte compressed public key value pk[0]\n     *\n     *   unsigned int len' = len;\n     *   ADRS.setTreeHeight(0);\n     *   while ( len' > 1 ) {\n     *     for ( i = 0; i < floor(len' \/ 2); i++ ) {\n     *       ADRS.setTreeIndex(i);\n     *       pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n     *     }\n     *     if ( len' % 2 == 1 ) {\n     *       pk[floor(len' \/ 2)] = pk[len' - 1];\n     *     }\n     *     len' = ceil(len' \/ 2);\n     *     ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     *   }\n     *   return pk[0];\n     *\n     * [RFC-8391] Section 4.1.5, Algorithm 8.\n     * [Errata-5572] @see https:\/\/www.rfc-editor.org\/errata\/eid5572\n     *\/\n    ltree : WOTS::PublicKey -> Seed -> LTreeAddress -> [n]Byte\n    ltree pk SEED ADRS = result where\n        ADRS' = setTreeHeight ADRS 0\n        result = ltree'`{WOTS::len} pk SEED ADRS'\n\n    treeHash_base : {t} (\n                        fin t,\n                                    t <= h\n        ) => PrivateKey -> Word -> Address -> [2^^t]([n]Byte, Address)\n    treeHash_base SK s ADRS = if s % (2^^`t) != 0\n        then error \"Invalid `s`: `s % (1 << t) == 0` must hold\"\n        else base where\n            SEED = SK.seed\n            base = [ (node, ADRS''') where\n                     ADRS' = setOTSAddress (setType ADRS 0) (s + i)\n                     pk = WOTS::genPK (getWOTS_SK SK (s + i)) SEED ADRS'\n                     ADRS'' = setLTreeAddress (setType ADRS' 1) (s + i)\n                     node = ltree pk SEED ADRS''\n                     ADRS''' = setTreeIndex (setTreeHeight (setType ADRS'' 2) 0) (i + s)\n                   | i <- [0..2^^t - 1]\n                   ]\n\n    \/**\n     * The \"induction step\" for `treeHash`.\n     *\n     * This takes a list of `2^^t` elements and combines them to produce a\n     * single element by pairwise hashing elements using `RAND_HASH`.\n     *\n     * This roughly corresponds to the `while`-loop in `treeHash`.\n     *\n     * [RFC-8391] Section 4.1.6, Algorithm 9.\n     *\/\n    treeHash_combine : {t} (\n            fin t\n        ) => [2^^t]([n]Byte, Address) -> Seed -> ([n]Byte, Address)\n    treeHash_combine list SEED\n        | t == 0 => list @ 0\n        | t >= 1 => treeHash_combine list' SEED where\n            list' = [ (node, ADRS') where\n                      ADRS = setTreeIndex a.1 ((getTreeIndex b.1 - 1) \/ 2)\n                      node = RAND_HASH a.0 b.0 SEED ADRS\n                      ADRS' = setTreeHeight ADRS (getTreeHeight ADRS + 1)\n                    | [a, b] <- groupBy`{2} list\n                    ]\n\n    \/**\n     * The `treeHash` algorithm.\n     *\n     * This implementation does not closely mimic the algorithm in [RFC-8391].\n     * That algorithm utilizes a stack which is difficult to implement in\n     * Cryptol. Instead, we implement `treeHash` \"level-by-level\". To explain\n     * this, we first step back and explain the goal of `treeHash`.\n     *\n     * At a high level, `treeHash` takes a leftmost leaf of a sub-tree of height\n     * `t`, and computes the root node of that sub-tree. This can be done in two\n     * ways, which essentially boils down to a breadth-first versus depth-first\n     * approach. The breadth-first way is to first compute all the nodes at the\n     * same level as the leftmost leaf, use those nodes to compute the parent\n     * nodes at the next level, etc., until the root is reached. The depth-first\n     * way is to use a stack to store nodes as they are computed so we can\n     * continually complete sub-trees as we process all the nodes on the same\n     * level as `s`.\n     *\n     * The `treeHash` algorithm in [RFC-8391] does the computation in a\n     * depth-first manner, using a stack to store state. In this implementation,\n     * we use the breadth-first approach.\n     *\n     *   Input: XMSS private key SK, start index s, target node height t,\n     *          address ADRS\n     *   Output: n-byte root node - top node on Stack\n     *\n     *   if( s % (1 << t) != 0 ) return -1;\n     *   for ( i = 0; i < 2^t; i++ ) {\n     *     SEED = getSEED(SK);\n     *     ADRS.setType(0);   \/\/ Type = OTS hash address\n     *     ADRS.setOTSAddress(s + i);\n     *     pk = WOTS_genPK (getWOTS_SK(SK, s + i), SEED, ADRS);\n     *     ADRS.setType(1);   \/\/ Type = L-tree address\n     *     ADRS.setLTreeAddress(s + i);\n     *     node = ltree(pk, SEED, ADRS);\n     *     ADRS.setType(2);   \/\/ Type = hash tree address\n     *     ADRS.setTreeHeight(0);\n     *     ADRS.setTreeIndex(i + s);\n     *     while ( Top node on Stack has same height t' as node ) {\n     *        ADRS.setTreeIndex((ADRS.getTreeIndex() - 1) \/ 2);\n     *        node = RAND_HASH(Stack.pop(), node, SEED, ADRS);\n     *        ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     *     }\n     *     Stack.push(node);\n     *   }\n     *   return Stack.pop();\n     *\n     * [RFC-8391] Section 4.1.6, Algorithm 9.\n     *\/\n    treeHash : {t} (\n                        fin t,\n                                    t <= h\n        ) => PrivateKey -> Word -> Address -> [n]Byte\n    treeHash SK s ADRS = if s % (2^^`t) != 0\n        then error \"Invalid `s`: `s % (1 << t) == 0` must hold\"\n        else node.0 where\n            list = treeHash_base`{t} SK s ADRS\n            node = treeHash_combine list SK.seed\n\nkeyGen : [2^^h]WOTS::PrivateKey -> [n]Byte -> Seed -> (PrivateKey, PublicKey)\nkeyGen wots_sks SK_PRF SEED = (SK, PK) where\n    SK_no_root = { oid = oid, idx = 0 : Word, wots_sks = wots_sks, SK_PRF = SK_PRF, root = zero : [n]Byte, seed = SEED }\n    ADRS = zero     root = treeHash`{h} SK_no_root 0 ADRS\n    SK = { SK_no_root | root = root }\n    PK = { oid = oid, root = root, seed = SEED }\n\nprivate\n\n    buildAuth_j : {j} (\n            fin j,\n                        j >= 0,\n            j <= h - 1\n        ) => PrivateKey -> Word -> Address -> [n]Byte\n    buildAuth_j SK i ADRS = auth_j where\n        k = i \/ 2^^`j ^ 1         auth_j = treeHash`{j} SK (k * 2^^`j) ADRS\n\n    buildAuth' : {j} (\n            fin j,\n            j < h\n        ) => PrivateKey -> Word -> Address -> [j + 1][n]Byte\n    buildAuth' SK i ADRS\n        | j == 0 => [ buildAuth_j`{0} SK i ADRS ]\n        | j > 0  => list # [ buildAuth_j`{j} SK i ADRS ] where\n            list = buildAuth'`{j - 1} SK i ADRS\n\n    \/**\n     * `buildAuth` - Compute the authentication path for the i^th WOTS+ key\n     * pair.\n     *\n     * Note: We implement `buildAuth` using recursion instead of the `for`-loop.\n     *\n     *   Input: XMSS private key SK, WOTS+ key pair index i, ADRS\n     *   Output: Authentication path auth\n     *\n     *   for ( j = 0; j < h; j++ ) {\n     *     k = floor(i \/ (2^j)) XOR 1;\n     *     auth[j] = treeHash(SK, k * 2^j, j, ADRS);\n     *   }\n     *\n     * [RFC-8391] Section 4.1.9.\n     *\/\n    buildAuth : PrivateKey -> Word -> Address -> [h][n]Byte\n    buildAuth SK i ADRS = buildAuth'`{h - 1} SK i ADRS\n\n    treeSig : [n]Byte -> PrivateKey -> Word -> Address -> (WOTS::Signature, [h][n]Byte)\n    treeSig M' SK idx_sig ADRS = (sig_ots, auth) where\n        auth = buildAuth SK idx_sig ADRS\n        ADRS' = setOTSAddress (setType ADRS 0) idx_sig\n                sig_ots = WOTS::sign M' (getWOTS_SK SK idx_sig) ADRS' SK.seed\n\nsign : {m} (\n        fin m,\n        width (PaddingWidth + 8 * m) < MessageUpperBound\n    ) => [m]Byte -> PrivateKey -> (PrivateKey, Signature)\nsign M SK = (SK', Sig) where\n    idx_sig = SK.idx\n    SK' = setIdx SK (idx_sig + 1)\n    ADRS = zero : Address     r = WOTS::PRF SK.SK_PRF (WOTS::toByte`{32} idx_sig)\n    M' = H_msg (r # SK.root # WOTS::toByte`{n} idx_sig) M\n    (sig_ots, auth) = treeSig M' SK idx_sig ADRS\n    Sig = { idx_sig = idx_sig, r = r, sig_ots = sig_ots, auth = auth }\n\nrootFromSig : Word -> WOTS::Signature -> [h][n]Byte -> [n]Byte -> Seed -> Address -> [n]Byte\nrootFromSig idx_sig sig_ots auth M' SEED ADRS = node_0' where\n    ADRS' = setOTSAddress (setType ADRS 0) idx_sig\n    \/\/ NOTE: The spec calls `WOTS_pkFromSig` with the wrong parameter order. [Errata-8396].\n    pk_ots = WOTS::pkFromSig M' sig_ots ADRS' SEED\n    ADRS'' = setLTreeAddress (setType ADRS' 1) idx_sig\n    node_0_initial = ltree pk_ots SEED ADRS''\n    ADRS''' = setTreeIndex (setType ADRS'' 2) idx_sig\n    (node_0', _) = foldl updateNode (node_0_initial, ADRS''') [0..h-1] where\n        updateNode (node_0, adrs) k = (node_1, adrs'') where\n            adrs' = setTreeHeight adrs k\n            treeindex = getTreeIndex adrs'\n            treeindex' = if (idx_sig \/ 2^^k) % 2 == 0\n                then treeindex \/ 2\n                else (treeindex - 1) \/ 2\n            adrs'' = setTreeIndex adrs' treeindex'\n            node_1 = if (idx_sig \/ 2^^k) % 2 == 0\n                then RAND_HASH node_0 (auth @ k) SEED adrs''\n                else RAND_HASH (auth @ k) node_0 SEED adrs''\n\nverify : {m} (fin m, width (PaddingWidth + 8 * m) < MessageUpperBound)\n    => Signature -> [m]Byte -> PublicKey -> Bit\nverify Sig M PK = node == PK.root where\n    ADRS = zero     M' = H_msg (Sig.r # PK.root # WOTS::toByte`{n} Sig.idx_sig) M\n    node = rootFromSig Sig.idx_sig Sig.sig_ots Sig.auth M' PK.seed ADRS\n\nproperty XMSSInverts M wots_sks SK_PRF SEED = verify sig M pk where\n    (sk, pk) = keyGen wots_sks SK_PRF SEED\n    (sk', sig) = sign M sk\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an interface module named Primitive::Asymmetric::Signature::XMSS::Parameters that declares: (1) a numeric type parameter h that is finite and constrained to be between 1 and 32 inclusive; (2) a numeric type parameter n that is finite; (3) a function H that consumes a sequence of n 8-bit words and a sequence of 2\u00b7n 8-bit words and returns a sequence of n 8-bit words; (4) numeric type parameters MessageUpperBound and PaddingWidth; (5) a constant oid that is a 32-bit sequence; and (6) a polymorphic function H_msg, quantified over a numeric parameter m, with constraints that m is finite and that the bit-width of (PaddingWidth + 8\u00b7m) is strictly less than MessageUpperBound, where H_msg consumes a sequence of 3\u00b7n 8-bit words and a sequence of m 8-bit words and returns a sequence of n 8-bit words. Provide precise Cryptol type signatures with these constraints, matching the described arities and shapes, and omit implementations (signatures only)."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Asymmetric::Signature::XMSS::Parameters where\n\ntype h : #\ntype constraint (fin h)\n\ntype constraint (h <= 32)\n\ntype constraint (h >= 1)\n\ntype n : #\ntype constraint (fin n)\n\nH : [n][8] -> [2 * n][8] -> [n][8]\n\ntype MessageUpperBound : #\n\ntype PaddingWidth : #\n\noid : [32]\n\nH_msg : {m} (fin m, width (PaddingWidth + 8 * m) < MessageUpperBound)\n    => [3 * n][8] -> [m][8] -> [n][8]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/WOTS\/Interface.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol interface module named Primitive::Asymmetric::Signature::WOTS::Interface that contains the following declarations only (no implementations): (1) Size parameters n and w with constraints: both finite; w is divisible by 4, congruent to 1 modulo 3, and at most 16. (2) Type-level naturals len_1, len_2, and len computed from n and w as in WOTS: len_1 equals the total number of bits in an n-byte string divided by log2(w); len_2 equals the number of base-w digits needed to encode the checksum of len_1 (i.e., about log_w(len_1\u00b7(w\u22121)) plus one); len equals len_1 plus len_2; constrain the bit-width of len to be at most 32. (3) Type synonym Byte as an 8-bit word; Seed as n bytes; Address as 32 bytes; OTSHashAddress same shape as Address; PrivateKey, PublicKey, and Signature each as an array of len elements, where each element is n bytes. (4) Function signatures: F maps two n-byte arrays to an n-byte array (compression-like function); PRF maps an n-byte key and a 32-byte input to an n-byte output; toByte is polymorphic over finite y and m, converting an m-bit vector into an array of y bytes; genPK takes a PrivateKey, an n-byte public seed, and an Address, returning a PublicKey; sign takes an n-byte message digest, a PrivateKey, an Address, and an n-byte public seed, returning a Signature; pkFromSig takes an n-byte message digest, a Signature, an Address, and an n-byte public seed, returning a PublicKey. Clearly state all sizes in terms of n, w, and the derived lengths."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Asymmetric::Signature::WOTS::Interface where\n\ntype n : #\ntype constraint (fin n)\n\ntype w : #\ntype constraint (fin w, w % 4 == 0, w % 3 == 1, w <= 16)\n\nF : [n][8] -> [n][8] -> [n][8]\n\nPRF : [n][8] -> [32][8] -> [n][8]\n\ntype len_1 = (8 * n) \/^ (lg2 w)\n\ntype len_2 = lg2 (len_1 * (w - 1)) \/ lg2 w + 1\n\ntype len = len_1 + len_2\n\ntype constraint (width len <= 32)\n\ntype Byte = [8]\n\ntoByte : {y, m} (fin y, fin m) => [m] -> [y]Byte\n\ntype Seed = [n]Byte\n\ntype Address = [8 * 4]Byte\n\ntype OTSHashAddress = [8 * 4]Byte\n\ntype PrivateKey = [len][n]Byte\n\ntype PublicKey = [len][n]Byte\n\ntype Signature = [len][n]Byte\n\ngenPK : PrivateKey -> [n]Byte -> Address -> PublicKey\n\nsign : [n]Byte -> PrivateKey -> Address -> [n]Byte -> Signature\n\npkFromSig : [n]Byte -> Signature -> Address -> [n]Byte -> PublicKey\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/WOTS\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Asymmetric::Signature::WOTS::Specification that contains: (1) a parameter block introducing size parameters for the digest length and Winternitz base with constraints enforcing finiteness, divisibility, congruence, and an upper bound; abstract primitives for a keyed hash and a pseudorandom function with n-byte inputs\/outputs; derived length types for message digits, checksum digits, and their sum, with explicit width constraints ensuring all derived values fit in 32 bits; and aliases binding unprimed names to parameters. (2) Type synonyms for a byte, seed, 32-bit word, OTS hash address (as an array of bytes covering its 8 fields), and fixed-size arrays for private keys, public keys, and signatures, each sized by the derived len. (3) A big-endian integer-to-bytes function with size parameters that zero-extends then drops to produce exactly y bytes; and a boolean constant that asserts converting zero to 32 bytes yields all-zero bytes for any input width. (4) OTS address field setters for chain index, hash index, and key\/mask selector that update the appropriate 32-bit word positions. (5) A chaining function that iterates the keyed hash s times starting from an n-byte value, validating bounds on i and s, and on each step derives a key and bitmask from the PRF by setting hash address to i+s\u22121 and toggling the key\/mask selector, then hashes the masked intermediate. (6) Two base-w conversion functions from bytes to an array of 32-bit digits: one following the spec\u2019s iterative shifting procedure and one using bit grouping, with appropriate size constraints; and a property that both implementations are equivalent for all valid sizes. (7) A property capturing the published base-w examples for the case w=16. (8) A public-key generation function that chains each private-key element to the end of its chain using per-index addresses. (9) A signing function that converts the message to base w, computes and encodes the checksum, concatenates digits, and chains each secret element for the required steps. (10) A public-key-from-signature function that chains each signature element the remaining steps. (11) A property that, for any inputs, generating a public key, then signing a message and reconstructing the public key from the signature produces identical public keys."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::WOTS::Specification where\n\nparameter\n\n    type n' : #\n    type constraint (fin n')\n\n    type w' : #\n    type constraint (fin w', w' % 4 == 0, w' % 3 == 1, w' <= 16)\n\n    \/**\n     * A keyed cryptographic hash function that takes a key and a message.\n     * [RFC-8391] Section 3.1.1.1.\n     *\/\n    F' : [n'][8] -> [n'][8] -> [n'][8]\n\n    \/**\n     * A pseudorandom function that takes a key and an index.\n     * [RFC-8391] Section 3.1.1.1.\n     *\/\n    PRF' : [n'][8] -> [32][8] -> [n'][8]\n\n    type len_1 = (8 * n') \/^ (lg2 w')\n    type constraint (width (len_1 * (w' - 1) * 2^^8) <= 32)\n\n    \/**\n     * A length value (fixed with respect to `n` and `w`).\n     * [RFC-8391] Section 3.1.1.\n     *\/\n\n    type len_2 = lg2 (len_1 * (w' - 1)) \/ lg2 w' + 1\n\n    \/**\n     * The number of `n`-byte string elements in a WOTS+ private key, public key,\n     * and signature.\n     * [RFC-8391] Section 3.1.1.\n     *\/\n    type len = len_1 + len_2\n\n    \/**\n     * The `len` parameter fits in 32 bits.\n     *\n     * This implicit fact about our inputs is hard for Cryptol to infer, so we\n     * state it explicitly.\n     *\n     * It is implied by the `genPK` function, which sets the chain address\n     * of an OTS hash address to an iterator that varies from 0 to `len-1`.\n     * The chain address is restricted to one 32-bit word. See [RFC-8391]\n     * Algorithm 4.\n     *\n     * This can also be observed from the computed `len` values from the valid\n     * parameter sets in Section 5.2.\n     *\/\n    type constraint (32 >= width len)\n\ntype n = n'\ntype w = w'\nF = F'\nPRF = PRF'\n\n\/**\n * A byte is a sequence of 8 bits using big-endian representation.\n * [RFC-8391] Section 2.1.\n *\/\ntype Byte = [8]\n\n\/**\n * Convert a non-negative integer to a binary representation in big-endian\n * byte order.\n * [RFC-8391] Section 2.4.\n *\n * Note: the spec is not explicit about what to do when `m < 8y` -- e.g. when\n * converting to `y` bytes means truncating the integer representation,\n * rather than padding it with 0s. We chose this behavior based on the\n * reference implementation that accompanies the spec.\n * @see https:\/\/github.com\/XMSS\/xmss-reference\/blob\/master\/utils.c#L6\n * [RFC-8391] Section 7.\n *\n * Essentially, we pad with zeros if needed (using `zext`), then `drop` any\n * unnecessary padding (and potentially also drop some bits of the original\n * integer).\n *\/\ntoByte : {y, m} (fin y, fin m) => [m] -> [y]Byte\ntoByte x = split (drop (zext`{max m (y * 8)} x))\n\n\/**\n * Ensure that `toByte`{32} 0 == zero`.\n * ```repl\n * :check toByteZeroIsZero`{32}\n * ```\n *\/\ntoByteZeroIsZero : {m} fin m => Bit\ntoByteZeroIsZero = zero == toByte`{32, m} 0\n\n\/**\n * An n-byte value used as the key to a PRF.\n *\n * This type is not formally defined in the spec but is defined here for\n * clarity.\n *\n * [RFC-8391] Section 2.5.\n *\/\ntype Seed = [n]Byte\n\n\/**\n * A word is a 32-bit sequence used to define hash addresses.\n * [RFC-8391] Section 2.5.\n *\/\ntype Word = [32]\n\n\/**\n * Address scheme for randomizing hash function calls in the OTS scheme.\n * [RFC-8391] Section 2.5.\n *\n * The address breaks down 7 components, each 1 word long unless specified.\n * 1. Layer address\n * 2-3. Tree address (2 Words)\n * 4. Type (fixed at 0)\n * 5. OTS address\n * 6. Chain address\n * 7. Hash address\n * 8. keyAndMask\n *\n * Note that this isn't defined in terms of the `Word` type because it's\n * operated on by things that require arrays of bytes.\n *\/\ntype OTSHashAddress = [8 * 4]Byte\n\n\/**\n * A private, or secret, key in WOTS+ is a length `len` array of `n`-byte\n * strings.\n *\n * It represents the start nodes in a set of hash chains.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: A private key MUST be selected randomly from the uniform\n * distribution or selected using a cryptographically secure pseudorandom\n * process! Cryptol cannot verify that a `PrivateKey` was chosen suitably!\n * Implementors must independently audit private key generation!\n *\n * [RFC-8391] Section 3.1.3.\n *\n * An implementation may also use a cryptographically secure pseudorandom\n * method to generate the private key from a single `n`-byte value. See\n * [RFC-8391] Section 3.1.7 for a sample method.\n *\/\ntype PrivateKey = [len][n]Byte\n\n\/**\n * A WOTS+ public key is a length `len` array of `n`-byte strings.\n *\n * It represents the end nodes i a set of length-`w` hash chains, where the\n * start nodes are defined in the corresponding `PrivateKey`.\n *\/\ntype PublicKey = [len][n]Byte\n\n\/**\n * Generate a WOTS+ public key from a private key.\n * [RFC-8391] Section 3.1.4, Algorithm 4 (called `WOTS_genPK` in the spec).\n * [Errata-8382] @see https:\/\/www.rfc-editor.org\/errata\/eid8382\n *\/\ngenPK : PrivateKey -> [n]Byte -> OTSHashAddress -> PublicKey\ngenPK sk SEED ADRS = pk where\n    pk = [ pki where\n            ADRSi = setChainAddress ADRS i\n            pki = chain ski 0 (`w - 1) SEED ADRSi\n        | i <- [0..len-1]\n        | ski <- sk]\n\nprivate\n    \/**\n     * Set the chain address word (in the 6th position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setChainAddress : OTSHashAddress -> Word -> OTSHashAddress\n    setChainAddress address value =\n        take`{5 * 4} address # (split value) # drop`{6 * 4} address\n\n    \/**\n     * Set the hash address word (in the 7th position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setHashAddress : OTSHashAddress -> Word -> OTSHashAddress\n    setHashAddress address value =\n        take`{6 * 4} address # (split value) # drop`{7 * 4} address\n\n    \/**\n     * Set the `keyAndMask` word (the last position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setKeyAndMask : OTSHashAddress -> Word -> OTSHashAddress\n    setKeyAndMask address value = take`{7 * 4} address # split value\n\n    \/**\n     * Chaining function that iterates `F` on the input `X`, `s` times.\n     * [RFC-8391] Section 3.1.2, Algorithm 2.\n     *\/\n    chain : [n]Byte -> Word -> Word -> [n]Byte -> OTSHashAddress -> [n]Byte\n    chain X i s SEED ADRS = return where\n        return = if s == 0 then\n                X\n            else if i + s > `w - 1 then\n                error \"Invalid `s` and `i` parameters passed to `chain`\"\n            else\n                tmp'\n        tmp = chain X i (s - 1) SEED ADRS\n\n        ADRS' = setHashAddress ADRS (i + s - 1)\n        ADRS'' = setKeyAndMask ADRS' 0\n        KEY = PRF SEED ADRS''\n        ADRS''' = setKeyAndMask ADRS'' 1\n        BM = PRF SEED ADRS'''\n\n        tmp' = F KEY (tmp ^ BM)\n\n    \/**\n     * Convert a byte string into a set of base-`w` numbers.\n     *\n     * This uses the manual bit-shifting algorithm described in the spec. The\n     * spec is not very particular about bit widths of the helper variables or\n     * the output; we made the following choices:\n     * - `total`: holds each byte of the input, so `[8]`\n     * - `in`: holds the index showing where we are in the input. We use an\n     *   `Integer`, although this could also be `[width len_X]`.\n     * - `bits`: holds the number of bits processed in the current byte. This is\n     *   never larger than 8, but due to the way we've defined the type\n     *   constraint on `w`, it's easier to leave some extra space, so `[8]`.\n     * - `basew`: The output of this function is eventually used as a parameter\n     *   to `chain`, so we pad each base-`w` number to be a `Word` (`[32]`).\n     *\n     * [RFC-8391] Section 2.6, Algorithm 1.\n     *\/\n    base_w_spec : {out_len, len_X} (\n            fin len_X,\n            out_len <= 8 * len_X \/ lg2 w)\n        => [len_X]Byte -> [out_len]Word\n    base_w_spec X = basew where\n        \/\/ Steps 8 - 13. Define how the helper variables (`total`, `in`, `bits`)\n        \/\/ are updated in each round.\n        update_helpers : ([8], Integer, [8]) -> ([8], Integer, [8])\n        update_helpers (total, in, bits) =\n            if bits == 0 then (\n                X@in,\n                in + 1,\n                8 - lg2 `w )\n            else (total, in, bits - lg2 `w)\n\n        \/\/ Step 7. Define the number of iterations we need.\n        type consumed = out_len\n\n        \/\/ Step 14. Compute the set of base-`w` numbers. `zext` converts an\n        \/\/ 8-bit value to a `Word`.\n        basew = take`{consumed} [ zext ((total >> bits) && (`w - 1))\n            \/\/ Steps 1-5. Initialize helper variables (and update them for each\n            \/\/ round). The first element is dropped because the first variable\n            \/\/ update happens before computing any output values.\n            | (total, in, bits) <- drop`{1} (iterate update_helpers (0, 0, 0))]\n\n    \/**\n     * Convert a byte string into a set of base-`w` numbers.\n     *\n     * This uses standard built-in Cryptol functions to achieve the same\n     * functionality as the spec version; rather than manually bit shifting, it\n     * regroups the bits into the desired arrangement. This is about 5x faster\n     * than the spec version.\n     *\n     * Note that this depends on the top-level type constraint restricting `w`\n     * to either 4 or 16. I am not sure the grouping would work as well if we\n     * were working in a base that was not a power of 2.\n     *\/\n    base_w : {out_len, len_X} (\n        fin len_X,\n        out_len <= 8 * len_X \/ lg2 w)\n        => [len_X]Byte -> [out_len]Word\n    base_w X = map zext (groupBy`{lg2 w} (take (join X)))\n\n    \/**\n     * Proof that the Cryptol-ish version of `base_w` matches the spec version.\n     *\n     * Parameter for the following tests are chosen based on the instantiations\n     * that appear in the spec (Algorithms 5 and 6).\n     * ```repl\n     * :prove base_wsMatch`{len_1, n * 8}\n     * type len_2_bytes = len_2 * lg2 w \/^ 8\n     * :prove base_wsMatch`{len_2, len_2_bytes}\n     * ```\n     *\/\n    base_wsMatch : {O, L} (fin L, O <= 8 * L \/ lg2 w) => [L]Byte -> Bit\n    property base_wsMatch X = base_w_spec`{O, L} X == base_w X\n\n    \/**\n     * The spec provides several examples when `w = 16`.\n     * [RFC-8391] Section 2.6.\n     * ```repl\n     * :prove base_wExamplesWork`{}\n     * ```\n     *\/\n    base_wExamplesWork : (w == 16) => Bit\n    property base_wExamplesWork = test4 && test3 && test2 where\n        test4 = base_w`{4} [0x12, 0x34] == [1, 2, 3, 4]\n        test3 = base_w`{3} [0x12, 0x34] == [1, 2, 3]\n        test2 = base_w`{2} [0x12, 0x34] == [1, 2]\n\n\/**\n * A WOTS+ signature.\n * [RFC-8391] Section 3.1.5.\n *\/\ntype Signature = [len][n]Byte\n\n\/**\n * Generate a signature from a private key and a message.\n * [RFC-8391] Section 3.1.5, Algorithm 5 (called `WOTS_sign` in the spec).\n *\n * The checksum in the signature algorithm must fit in 32 bits; we enforce this\n * using a constraint in the type signature; it will always be true for the\n * approved parameter sets.\n *\/\nsign : [n]Byte -> PrivateKey -> OTSHashAddress -> [n]Byte -> Signature\nsign M sk ADRS SEED = sig where\n    \/\/ Convert message to base `w`.\n    msg = base_w`{len_1} M\n\n    \/\/ Compute checksum.\n    csum = sum [ `w - 1 - msg_i | msg_i <- msg ]\n\n    \/\/ Convert `csum` to base `w`.\n    csum' = csum << (8 - (`(len_2 * lg2 w) % 8))\n    type len_2_bytes = (len_2 * lg2 w) \/^ 8\n    msg' = msg # base_w`{len_2} (toByte`{len_2_bytes} csum')\n    sig = [sig_i where\n            ADRS_i = setChainAddress ADRS i\n            sig_i = chain sk_i 0 msg_i SEED ADRS_i\n        | i <- [0..len-1]\n        | sk_i <- sk\n        | msg_i <- msg' ]\n\n\/**\n * Compute a WOTS+ public key from a message and its signature.\n * [RFC-8391] Section 3.1.6, Algorithm 6 (called `WOTS_pkFromSig` in the spec).\n *\n * The result of this function must be compared to the given public key. If\n * the values are not equal, the signature MUST be rejected. This algorithm\n * does not actually reject any signatures!!\n *\/\npkFromSig : [n]Byte -> Signature -> OTSHashAddress -> [n]Byte -> PublicKey\npkFromSig M sig ADRS SEED = tmp_pk where\n    \/\/ Convert message to base `w`.\n    msg = base_w`{len_1} M\n\n    \/\/ Compute checksum.\n    csum = sum [ `w - 1 - msg_i | msg_i <- msg ]\n\n    \/\/ Convert `csum` to base `w`.\n    csum' = csum << (8 - (`(len_2 * lg2 w) % 8))\n    type len_2_bytes = (len_2 * lg2 w) \/^ 8\n    msg' = msg # base_w`{len_2} (toByte`{len_2_bytes} csum')\n    tmp_pk = [tmp_pk_i where\n            ADRS_i = setChainAddress ADRS i\n            tmp_pk_i = chain sig_i msg_i (`w - 1 - msg_i) SEED ADRS_i\n        | i <- [0..len-1]\n        | sig_i <- sig\n        | msg_i <- msg' ]\n\n\/**\n * A single execution of this property takes ~2 minutes.\n * ```repl\n * :set tests = 1\n * :check WOTSisCorrect\n * ```\n *\/\nproperty WOTSisCorrect M sk ADRS SEED = tmp_pk == pk where\n    pk = genPK sk SEED ADRS\n    sig = sign M sk ADRS SEED\n    tmp_pk = pkFromSig M sig ADRS SEED\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Instantiations\/ML_DSA_87.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_87 that instantiates the base Primitive::Asymmetric::Signature::ML_DSA::ML_DSA module and specializes it by declaring the following type-level numeric parameters in the where-clause: q = 8380417; \u03c4 = 60; \u03bb = 256; \u03b31 = 2 raised to 19; \u03b32 = (q \u2212 1) divided by 32; k = 8; ell = 7; \u03b7 = 2; \u03c9 = 75. Declare each as a type synonym (natural number kind), ensure \u03b32 is expressed in terms of q, and do not add any value-level definitions\u2014only these type aliases to configure the instantiation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_87 =\n    Primitive::Asymmetric::Signature::ML_DSA::ML_DSA where\n\n        type q = 8380417\n        type \u03c4 = 60\n        type \u03bb = 256\n        type \u03b31 = 2 ^^ 19\n        type \u03b32 = (q - 1) \/ 32\n        type k = 8\n        type ell = 7\n        type \u03b7 = 2\n        type \u03c9 = 75\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Instantiations\/ML_DSA_44.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_44 that re-exports the generic ML_DSA signature specification specialized by concrete type-level parameters. Inside the module, declare the following numeric type synonyms used by the ML_DSA scheme: q = 8380417; \u03c4 = 39; \u03bb = 128; \u03b31 = 2 raised to 17; \u03b32 = (q \u2212 1) divided by 88; k = 4; ell = 4; \u03b7 = 2; \u03c9 = 80. Make these type-level declarations (not value bindings) so they can be referenced by the imported ML_DSA module. The module should be an alias of the generic ML_DSA module with exactly these parameter bindings and contain no additional definitions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_44 =\n    Primitive::Asymmetric::Signature::ML_DSA::ML_DSA where\n\n        type q = 8380417\n        type \u03c4 = 39\n        type \u03bb = 128\n        type \u03b31 = 2 ^^ 17\n        type \u03b32 = (q - 1) \/ 88\n        type k = 4\n        type ell = 4\n        type \u03b7 = 2\n        type \u03c9 = 80\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P224_SHA224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P224_SHA224 that contains the following definitions and imports. Import the P-224\/SHA-224 ECDSA instantiation module under the alias ECDSA, and import the bitvector-to-integer conversion helper. Declare a property named checkSignature with a type signature that, for any finite byte-length n, takes: a message as a sequence of n bytes, a private scalar, a nonce scalar, and the expected signature scalars (r and s), and returns a Boolean. Inside, compute a signature using the imported sign operation; if signing succeeds, check that both components of the produced signature match the provided expected values; otherwise treat it as a failure. Compute the public key from the private scalar using the imported publicKey operation, and if signing succeeded, verify the produced signature against the message and public key using the imported verify operation; otherwise treat it as a failure. The property should be the conjunction of the equality check and the verification result. Provide a property named sampleVector that applies checkSignature to a message equal to the concatenation of the ASCII bytes of the literal \u201csample\u201d, using fixed test-vector values for the private scalar, nonce, and expected r and s, each constructed by converting the corresponding hexadecimal bitvectors to integers with the imported conversion. Provide a property named testVector that applies checkSignature similarly, but with the message equal to the ASCII bytes of \u201ctest\u201d and a different set of fixed test-vector values. Include explicit type signatures indicating that the message is a sequence of bytes and that all scalars are integers, and pattern match on the optional signature result as described."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P224_SHA224 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA224 as ECDSA\nimport Common::utils(BVtoZ)\n\nproperty checkSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0xF220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\n    k = BVtoZ 0xC1D1F2F10881088301880506805FEB4825FE09ACB6816C36991AA06D\n    expected_r = BVtoZ 0x1CDFE6662DDE1E4A1EC4CDEDF6A1F5A2FB7FBD9145C12113E6ABFD3E\n    expected_s = BVtoZ 0xA6694FD7718A21053F225D3F46197CA699D45006C06F871808F43EBC\n\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0xF220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\n    k = BVtoZ 0xDF8B38D40DCA3E077D0AC520BF56B6D565134D9B5F2EAE0D34900524\n    expected_r = BVtoZ 0xC441CE8E261DED634E4CF84910E4C5D1D22C5CF3B732BB204DBEF019\n    expected_s = BVtoZ 0x902F42847A63BDC5F6046ADA114953120F99442D76510150F372A3F4\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P384_SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P384_SHA384 that imports the P-384\/SHA-384 ECDSA instantiation (aliased as ECDSA) and a bitvector-to-integer conversion utility. Inside the module, add: 1) a property checkSignature d msg k expected_r expected_s with an explicit type where msg is a finite sequence of 8-bit words (bytes) and d, k, expected_r, expected_s are arbitrary-precision integers representing the private key, nonce, and expected signature scalars. The property must: compute a signature of msg using d and k; if signing fails, yield False; otherwise destructure the signature into r and s, require r and s equal the expected scalars, derive the public key from d, and require verification of msg and (r,s) under that public key to succeed. The property\u2019s value is the conjunction of the equality check and the verification result. 2) a property sampleVector that invokes checkSignature using: the message derived from the ASCII string \u201csample\u201d; constants d, k, expected_r, expected_s defined as the same big-endian hexadecimal values as in the source and converted to integers with the utility. 3) a property testVector that similarly invokes checkSignature using the ASCII string \u201ctest\u201d and its corresponding constants. Keep all names, module path, and behavior exactly aligned with the described semantics."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P384_SHA384 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA384 as ECDSA\nimport Common::utils(BVtoZ)\n\nproperty checkSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0x6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\n    k = BVtoZ 0x94ED910D1A099DAD3254E9242AE85ABDE4BA15168EAF0CA87A555FD56D10FBCA2907E3E83BA95368623B8C4686915CF9\n    expected_r = BVtoZ 0x94EDBB92A5ECB8AAD4736E56C691916B3F88140666CE9FA73D64C4EA95AD133C81A648152E44ACF96E36DD1E80FABE46\n    expected_s = BVtoZ 0x99EF4AEB15F178CEA1FE40DB2603138F130E740A19624526203B6351D0A3A94FA329C145786E679E7B82C71A38628AC8\n\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0x6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\n    k = BVtoZ 0x015EE46A5BF88773ED9123A5AB0807962D193719503C527B031B4C2D225092ADA71F4A459BC0DA98ADB95837DB8312EA\n    expected_r = BVtoZ 0x8203B63D3C853E8D77227FB377BCF7B7B772E97892A80F36AB775D509D7A5FEB0542A7F0812998DA8F1DD3CA3CF023DB\n    expected_s = BVtoZ 0xDDD0760448D42D8A43AF45AF836FCE4DE8BE06B485E9B61B827C2F13173923E06A739F040649A667BF3B828246BAA5A5\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P521_SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P521_SHA512 that contains: (1) imports of the P-521\/SHA-512 ECDSA instantiation as ECDSA and the bitvector-to-integer converter BVtoZ; (2) a function checkSignature with a clear type signature: given a private scalar d, a message value msg, an ephemeral scalar k, and expected signature scalars expected_r and expected_s, return a boolean. The function must compute sig = ECDSA.sign msg d k, then return true only if sig is a present signature (r,s), both r and s equal the expected values, and ECDSA.verify msg (r,s) holds when using Q = ECDSA.publicKey d. If sig is absent, return false. Include local bindings that structure this logic. Use types consistent with the ECDSA P-521\/SHA-512 instantiation: msg is a finite bit sequence, d and k are integers modulo the curve order, r and s are signature scalars, and Q is a public key point. (3) A property named sampleVector that asserts checkSignature holds for a message formed by flattening the ASCII text \u201csample\u201d into a bitvector and for a specific private key, nonce, and expected signature components, each provided as integer constants produced via BVtoZ. (4) A property named testVector that asserts checkSignature holds for a message formed by flattening the ASCII text \u201ctest\u201d into a bitvector and for another set of integer constants for the private key, nonce, and expected signature components via BVtoZ. Ensure both properties have boolean type and no additional behavior is introduced."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P521_SHA512 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA512 as ECDSA\nimport Common::utils(BVtoZ)\n\ncheckSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0x0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\n    k = BVtoZ 0x1DAE2EA071F8110DC26882D4D5EAE0621A3256FC8847FB9022E2B7D28E6F10198B1574FDD03A9053C08A1854A168AA5A57470EC97DD5CE090124EF52A2F7ECBFFD3\n    expected_r = BVtoZ 0x0C328FAFCBD79DD77850370C46325D987CB525569FB63C5D3BC53950E6D4C5F174E25A1EE9017B5D450606ADD152B534931D7D4E8455CC91F9B15BF05EC36E377FA\n    expected_s = BVtoZ 0x0617CCE7CF5064806C467F678D3B4080D6F1CC50AF26CA209417308281B68AF282623EAA63E5B5C0723D8B8C37FF0777B1A20F8CCB1DCCC43997F1EE0E44DA4A67A\n\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0x0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\n    k = BVtoZ 0x16200813020EC986863BEDFC1B121F605C1215645018AEA1A7B215A564DE9EB1B38A67AA1128B80CE391C4FB71187654AAA3431027BFC7F395766CA988C964DC56D\n    expected_r = BVtoZ 0x13E99020ABF5CEE7525D16B69B229652AB6BDF2AFFCAEF38773B4B7D08725F10CDB93482FDCC54EDCEE91ECA4166B2A7C6265EF0CE2BD7051B7CEF945BABD47EE6D\n    expected_s = BVtoZ 0x1FBD0013C674AA79CB39849527916CE301C66EA7CE8B80682786AD60F98F7E78A19CA69EFF5C57400E3B3A0AD66CE0978214D13BAF4E9AC60752F7B155E2DE4DCE3\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P256_SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P256_SHA256 that contains the following definitions: (1) import the P\u2011256\/SHA\u2011256 ECDSA instantiation under the alias ECDSA, and import only BVtoZ from Common::utils; (2) a property checkSignature that takes a private scalar d (integer), a message msg (sequence of bytes), a deterministic nonce k (integer), and expected_r, expected_s (integers). It must compute sig = ECDSA::sign msg d k, set signIsCorrect to true only when sig is present with components (r,s) and both equal the expected values, otherwise false; compute Q = ECDSA::publicKey d; set verifyIsCorrect to true only when sig is present with (r,s) and ECDSA::verify msg (r,s) Q holds, otherwise false; and return the conjunction signIsCorrect && verifyIsCorrect. Ensure pattern matching accounts for the optional signature result. (3) a property sampleVector that calls checkSignature using a message formed by joining its ASCII characters into a byte sequence, a specific private scalar, a specific deterministic nonce, and expected signature components, where d, k, expected_r, and expected_s are big\u2011endian integers produced with BVtoZ. (4) a property testVector defined similarly but with a different message, nonce, and expected signature values. Do not add extra behavior; ensure all values and types conform to the P\u2011256\/SHA\u2011256 instantiation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P256_SHA256 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA256 as ECDSA\nimport Common::utils(BVtoZ)\n\nproperty checkSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0xC9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\n    k = BVtoZ 0xA6E3C57DD01ABE90086538398355DD4C3B17AA873382B0F24D6129493D8AAD60\n    expected_r = BVtoZ 0xEFD48B2AACB6A8FD1140DD9CD45E81D69D2C877B56AAF991C34D0EA84EAF3716\n    expected_s = BVtoZ 0xF7CB1C942D657C41D436C7A1B6E29F65F3E900DBB9AFF4064DC4AB2F843ACDA8\n\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0xC9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\n    k = BVtoZ 0xD16B6AE827F17175E040871A1C7EC3500192C4C92677336EC2537ACAEE0008E0\n    expected_r = BVtoZ 0xF1ABB023518351CD71D881567B1EA663ED3EFCF6C5132B354F28D3B0B7D38367\n    expected_s = BVtoZ 0x019F4113742A2B14BD25926B49C649155F267E60D3814B4C0CC84250E46F0083\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P521_SHA3_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains exactly one definition: an instantiation of a generic, unconstrained ECDSA signature specification with two module parameters. Bind the EC parameter to the standard elliptic curve defined over a 521-bit prime field, and bind the Hash parameter to a SHA-3 hash with a 512-bit output. The module should simply re-export all functions, types, and any existing properties from the generic ECDSA specification specialized to these bindings, without introducing or overriding additional definitions. Reference the curve and hash instantiations from their respective libraries using appropriate import qualifications so the module type-checks and compiles."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512 =\n    Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec {\n        EC = Common::EC::PrimeField::Instantiations::P521,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P384_SHA3_384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA3_384 that instantiates a generic ECDSA specification using the NIST P-384 prime-field elliptic curve and the SHA3-384 hash function. The module must expose: (1) type synonyms for the 384-bit scalar\/order, field elements, and elliptic-curve points; (2) private\/public key types; (3) domain parameters (prime modulus, curve coefficients, base point, subgroup order, cofactor); (4) specialized ECDSA operations: key generation from a uniformly random scalar in [1..n-1], signing that hashes messages with SHA3-384 and reduces values mod n, and verification that checks range constraints, point validity, and the ECDSA equation; and (5) boolean, checkable properties asserting that verification succeeds on signatures produced by the signer under valid inputs and fails when r or s are out of range, the nonce is zero mod n, or the public key is not on the curve. Provide precise Cryptol type signatures for all exports consistent with 384-bit parameters, and ensure the module is an instantiation that re-exports the generic ECDSA specification specialized to P-384 and SHA3-384 without altering its algorithms."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA3_384 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P384,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P224_SHA224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA224 that instantiates the generic ECDSA specification by binding its EC parameter to the NIST P-224 prime-field curve implementation and its Hash parameter to the SHA-224 hash implementation. The module should contain only this instantiation and re-export all specialized definitions from the generic specification, including: domain parameters; private\/public key types; the signature type; signing and verification functions; any nonce-generation helpers; encoding\/decoding utilities; and any provided correctness checks. Ensure all types and constraints are consistent with a 224-bit prime-field curve (coordinate and scalar sizes derived from the curve order) and a 224-bit hash output. Do not introduce additional functions or change names; simply provide the parameterized instance so downstream code can use the ECDSA API specialized to P-224 with SHA-224."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA224 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P224,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA224\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P224_SHA3_224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA3_224 that contains the following definitions: an instantiation of the generic ECDSA specification with parameters bound as EC = the existing prime-field P-224 elliptic-curve instantiation and Hash = the existing SHA3-224 hash instantiation. The module must re-export all types, constraints, constants, functions, and properties provided by the ECDSA specification (such as key types, domain parameters, signing, verification, key generation, and associated properties) specialized to these concrete parameters. Do not introduce new behavior; this module is a direct alias of the parameterized specification with EC and Hash fixed as specified. Ensure the appropriate curve and hash instantiations are imported and referenced so that the specialization type-checks and all exposed APIs are the instantiated versions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA3_224 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P224,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P384_SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA384 that is an instantiation of the generic ECDSA specification, binding its elliptic-curve parameter to the NIST P-384 prime-field curve instantiation and its hash parameter to the SHA-384 instantiation. The module must expose the specification\u2019s full interface for this configuration, including: types for private\/public keys and signatures; functions for key generation, signing, and verification; and any associated constants and properties defined by the specification. Do not introduce new behavior\u2014simply configure the specification by wiring the EC backend to the P-384 prime-field module from the common EC prime-field instantiations and the Hash backend to the SHA-384 module from the SHA-2 instantiations\u2014so that all exported definitions operate over P-384 with SHA-384."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA384 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P384,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA384\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P521_SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA512 that is an instantiation of the generic ECDSA unconstrained specification, binding its EC parameter to Common::EC::PrimeField::Instantiations::P521 and its Hash parameter to Primitive::Keyless::Hash::SHA2::Instantiations::SHA512. The resulting module must re-export exactly the functions, types, and properties of the unconstrained ECDSA specification specialized to these parameters (e.g., key generation, signing, verification, and any associated predicates), without adding new definitions. Ensure the module serves purely as a specialization\/alias of the generic specification with those concrete curve and hash choices."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA512 =\n    Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec {\n        EC = Common::EC::PrimeField::Instantiations::P521,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA512\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P256_SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA256 that contains the following: a single instantiation of the generic ECDSA specification, binding the EC parameter to the NIST P-256 prime-field elliptic curve implementation and the Hash parameter to the SHA-256 implementation from the SHA-2 family. The module should introduce no additional declarations and should re-export all resulting types and functions produced by the instantiated specification (including key and signature types, key generation, signing, verification, and any associated utilities). Ensure the instantiation preserves the original specification\u2019s interfaces and type constraints, with the curve and hash parameters fixed to P-256 and SHA-256, respectively."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA256 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P256,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P256_SHA3_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA3_256 that instantiates the generic ECDSA specification by binding its EC parameter to the NIST P-256 prime-field curve instantiation and its Hash parameter to the SHA3-256 hash instantiation. The module must contain only this instantiation and re-export the specification\u2019s public API unchanged, including: types for private\/public keys and signatures; functions for key generation, signing, and verification; and any related size\/constraint aliases. Ensure the exposed types reflect a 256-bit prime-field elliptic curve and a 256-bit hash output. Do not add new functions, change names, or alter behavior\u2014provide a clean, named instantiation of the ECDSA specification with these parameters."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA3_256 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P256,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/ParameterSets\/XMSS_SHA2_10_256_Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_Parameters that imports the SHA-256 instantiation under the alias SHA256. Within it: (1) declare type aliases n = 32 (bytes) and h = 10; (2) define a function H that takes a key and a message, both sequences of bytes, prepends a 256-bit domain-separation tag equal to 1 to the byte-wise concatenation of key and message, computes SHA-256 over that input, and returns the 32-byte digest; (3) define a function H_msg identical to H except using a 256-bit domain-separation tag equal to 2; (4) expose a type alias MessageUpperBound equal to SHA256::MessageUpperBound; (5) define a type alias PaddingWidth equal to 32*8 + 3*n*8 (bits); (6) define a 32-bit constant oid with value 0x00000001. Provide explicit type signatures: key has length n bytes; message is a byte sequence; both functions return n bytes. Constrain inputs so that the total hashed input (256-bit tag plus key plus message) does not exceed MessageUpperBound. Ensure concatenation and join\/split semantics are consistent with byte-oriented hashing and that the SHA-256 result is split into bytes."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_Parameters\nwhere\n    import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\n    type n = 32\n    type h = 10\n\n    H KEY M = split (SHA256::hash ((1 : [32 * 8]) # join (KEY # M)))\n\n        type MessageUpperBound = SHA256::MessageUpperBound\n\n            type PaddingWidth = (32 * 8) + (3 * n * 8)\n\n        oid = 0x00000001\n\n    H_msg KEY M = split (SHA256::hash ((2 : [32 * 8]) # join (KEY # M)))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/ParameterSets\/XMSS_SHA2_10_256_FFI_Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_FFI_Parameters that contains the following definitions: import the SHA-256 FFI instantiation module under the alias SHA256; define numeric type synonyms n = 32 and h = 10; define a type alias MessageUpperBound equal to the corresponding message bound from the imported SHA256 module; define a numeric type alias PaddingWidth equal to 256 plus three times n times 8 (bits); define a 32-bit constant oid with value 1; define two functions, H and H_msg. Give H and H_msg type signatures that take a key of n bytes and a message of m bytes (with m finite and not exceeding MessageUpperBound) and return a 32-byte digest. Each function must compute SHA256::hashBytes over the byte sequence formed by concatenating: a 32-byte domain-separation tag, then the key bytes, then the message bytes. For H the tag is the 256-bit encoding of the integer 1; for H_msg the tag is the 256-bit encoding of the integer 2. Construct each tag by splitting the 256-bit constant into 32 bytes. Ensure all widths and constraints are explicit and the output digest is 32 bytes."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_FFI_Parameters\nwhere\n        import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256_FFI as SHA256\n\n    type n = 32\n    type h = 10\n\n    H KEY M = SHA256::hashBytes (split (1 : [32 * 8]) # KEY # M)\n\n        type MessageUpperBound = SHA256::MessageUpperBound\n\n            type PaddingWidth = (32 * 8) + (3 * n * 8)\n\n        oid = 0x00000001\n\n    H_msg KEY M = SHA256::hashBytes (split (2 : [32 * 8]) # KEY # M)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Instantiations\/XMSS_SHA2_10_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256 that instantiates the generic XMSS specification module by binding its Parameters field to Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_Parameters and its WOTS field to Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256. The module should introduce no additional definitions; it should simply apply the specification functor and re-export the resulting interface unchanged. Ensure that all types, constants, and operations provided by the specification (such as key generation, signing, and verification) are exposed exactly as specialized by these bindings, and that the module compiles without requiring further parameters."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256 =\n    Primitive::Asymmetric::Signature::XMSS::Specification {\n        Parameters = Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_Parameters,\n        WOTS = Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256\n\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Instantiations\/XMSS_SHA2_10_256_FFI.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named M that instantiates an XMSS signature specification functor. Within this instantiation, bind the Parameters field to the SHA-2\u2013based XMSS parameter set configured for tree height 10 with 256-bit security, and bind the WOTS field to the corresponding WOTS+ implementation using SHA-2 with 256-bit output via an FFI-backed instantiation. The resulting module must expose exactly the interface of the instantiated XMSS specification and introduce no additional definitions, types, or properties. Clearly indicate the two field bindings (Parameters and WOTS) and ensure the module body is solely the functor application with these bindings."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256_FFI =\n    Primitive::Asymmetric::Signature::XMSS::Specification {\n        Parameters = Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_FFI_Parameters,\n        WOTS = Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256_FFI\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/WOTS\/Instantiations\/WOTSP_SHA2_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256 that instantiates Primitive::Asymmetric::Signature::WOTS::Specification and imports Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256. Inside the module: (1) declare numeric type synonyms n' = 32 and w' = 16; (2) define a function F' that takes a key and a message as byte sequences and returns a 32-byte digest computed by SHA256::hashBytes over the concatenation of a 32-byte all-zero prefix, the key, and the message; (3) define a function PRF' that takes a key and a message as byte sequences and returns a 32-byte digest computed by SHA256::hashBytes over the concatenation of a 31-byte all-zero prefix, then a single one-byte constant with value 3, then the key, then the message. Provide clear type signatures: key is [n'][8], message is [m][8] for a universally-quantified m, and both functions return [n'][8]. Ensure the concatenations are well-typed and that the import alias is used to reference the SHA-256 byte-wise hash. Do not implement any additional logic beyond these definitions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256 =\n    Primitive::Asymmetric::Signature::WOTS::Specification where\n        import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\n        type n' = 32\n        type w' = 16\n\n        F' KEY M = SHA256::hashBytes ((zero : [32][8]) # KEY # M)\n        PRF' KEY M = SHA256::hashBytes ((zero : [31][8]) # [(3 : [8])] # KEY # M)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/SphincsPlus\/3.1\/sphincsplus128f.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named sphincsplus128f that imports the SHAKE256 instantiation from the SHA3 package and contains the following definitions. Declare numeric type synonyms: n = 16, h = 66, d = 22, a = 6, k = 33, loglogw = 2; set logt = a and t = 2^a. Define m as the sum of three terms using integer division: (k\u00b7logt + 7)\/8 + (h \u2212 h\/d + 7)\/8 + (h\/d + 7)\/8. Provide type signatures and definitions for these byte-oriented functions (all vectors are sequences of 8-bit bytes): (1) H_msg takes R:[n][8], PKseed:[n][8], PKroot:[n][8], and M:[msgLen][8] for any msgLen, and returns [m][8] equal to the first m bytes output by SHAKE256 when applied to the byte-wise concatenation of R, PKseed, PKroot, and M. (2) PRF takes Seed:[n][8] and ADRS:[adrsLen][8] for any adrsLen, and returns [n][8] equal to the first n bytes of SHAKE256 over Seed concatenated with ADRS. (3) PRF_msg takes SKprf:[n][8], OptRand:[n][8], and M:[msgLen][8], and returns [n][8] equal to the first n bytes of SHAKE256 over SKprf concatenated with OptRand and M. (4) T takes PKseed:[n][8], ADRS:[adrsLen][8], and M:[msgLen][8], and returns [n][8] equal to the first n bytes of SHAKE256 over PKseed concatenated with ADRS and M. State any necessary constraints that all size parameters are natural numbers and that concatenation and truncation are performed over byte sequences."},{"role":"assistant","content":"```cryptol\nmodule sphincsplus128f=specification where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256\n\ntype n = 16\ntype h = 66\ntype d = 22\ntype a = 6\ntype k = 33\ntype loglogw = 2\ntype m = (k*logt+7)\/8 + (h-h\/d+7)\/8 + (h\/d+7)\/8\ntype t = 2^^a\ntype logt = a\n\nH_msg(R, PKseed, PKroot, M) =\n    groupBy(take(shake256(join R # join PKseed # join PKroot # join M)))\nPRF(Seed, ADRS) =\n    groupBy(take(shake256(join Seed # join ADRS)))\nPRF_msg(SKprf, OptRand, M) =\n    groupBy(take(shake256(join SKprf # join OptRand # join M)))\nT(PKseed, ADRS, M) =\n    groupBy(take(shake256(join PKseed # join ADRS # join M)))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/FALCON\/1.2\/falcon_parameterized.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named falcon_parameterized that encapsulates a parameterized specification of the FALCON signature components. Include: (1) type parameters and constraints for a power-of-two polynomial degree, byte and integer aliases, a complex number type as a pair of floating points, a rational alias, a fixed modulus, derived sizes, and an array of twiddle factors; (2) generic while\/do-while combinators; (3) complex arithmetic (multiplication, addition, conjugation, inverse), list folding for complex sums, and scalar normalization; (4) a poly\/FFT\/NTT type family, power-of-two constraints, resizer, recursive radix-2 FFT with base case, its inverse (stub allowed but correctly typed), integer and modular lifts to FFT, and NTT\/NTT-inverse stubs; (5) pointwise product, Hadamard-style division, polynomial multiply via FFT, polynomial inverse via FFT, and integer-domain multiply\/divide stubs with appropriate result types; (6) inner product and norm-squared stubs; (7) FFT split\/merge utilities and a constant all-ones FFT vector; (8) public\/private key and encoding types, a binary tree structure for LDL decomposition with getters\/setters, leaf constructor, and node constructor; (9) compression\/decompression stubs, hash-to-point using an extendable-output hash with modulus reduction, key generation that builds the Gram matrix, performs LDL\/ffLDL, sets leaf variances from sigma, and computes the public key via modular transforms; (10) auxiliary N, x-squared lift, sign-flip mapping, NTRU solve via recursive reduction, extended GCD, and iterative reduction; (11) LDL factorization and recursive ffLDL tree builder; (12) signing with hash-to-point, normalized FFT projections, tree-based sampling with rejection, and shaped output; (13) constants and samplers (precomputed table, base sampler, exponential approximation, Bernoulli test, discrete Gaussian sampler); (14) verification that checks a norm bound. Add properties to validate: split\/merge round-trip, get\/set leaves round-trip, extended GCD identity, and key\/public-key relation. Ensure all types and constraints are explicit."},{"role":"assistant","content":"```cryptol\nmodule falcon_parameterized where\n\nparameter\n    type _k : #\n    type _n : #\n    type constraint (fin _k, _n == 2^^_k, _k > 0)\n    type pkbytelen : #\n    type sbytelen : #\n    type constraint (fin sbytelen)\n    type coeffs_number_of_bits : #\n    sigma : Float64\n    type Q = Rational\n    type C = (Float64,Float64)\n    Omega_phi: [_n]C\n    type constraint (8 * sbytelen >= 328)\n\ntype slen = 8 * sbytelen - 328\ntype q = 3 * 2^^12 + 1\n\ntype Byte = [8]Bit\ntype ZZ = Integer\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nCMul : (C, C) -> C\nCMul(x, y) = (x.0*y.0-x.1*y.1, x.0*y.1+x.1*y.0)\n\nCAdd : (C, C) -> C\nCAdd(x, y) = (x.0 + x.1, y.0 + y.1)\n\nCAddList : {n} (fin n) => [n]C -> C\nCAddList(l) = sums ! 0\n    where sums = [zero] # [CAdd(el,sums') | el <- l\n                                          | sums' <- sums\n                          ]\n\nCinv : C -> C\nCinv((a,b)) = (a\/.denominator, -(b\/.denominator)) where\n    denominator = a^^2 + b^^2\n\nConjugate : C -> C\nConjugate((x, y)) = (x, -y)\n\nPolyConj : {k, n} (ispoweroftwo k n) => Poly n C -> Poly n C\nPolyConj(f) = map Conjugate f\n\nNormalize_FFT : {k, n} (ispoweroftwo k n) => (Float64, Poly n C) -> Poly n C\nNormalize_FFT(_q, F) = dot(F, [Cinv(_q,0) | i <- [0 .. (n-1)]])\n\ntype constraint ispoweroftwo a b = (fin a, b == 2^^a)\n\ntype constraint positive_power a = (fin a, a > 0, (2*(2^^(a-1)*a)+2^^a == 2^^a*(1+a)), 2 ^^ a == 2 * 2 ^^ (a - 1))\n\nresize : {m,n,a} (fin m, fin n, Zero a) => [m]a -> [n]a\nresize xs = take`{n} (xs # repeat`{inf} zero)\n\nFFT : {k, n} (ispoweroftwo k n) => Poly n C -> FFT n\nFFT(x) | k == 0 => x\n       | k >  0 => resize(join([result0,result1])) where\n            even = [x@(2*i  ) | i <- [0 .. (2^^(k-1)-1)]]\n            odd =  [x@(2*i+1) | i <- [0 .. (2^^(k-1)-1)]]\n            left = FFT`{k-1}(even)\n            right = FFT`{k-1}(odd)\n            X = join([left,right])\n            result0 = [X@i + CMul(Omega_phi@(`n*i),(X@(i+`n\/2))) | i <- [0 .. (n\/2-1)]]\n            result1 = [X@i - CMul(Omega_phi@(`n*i),(X@(i+`n\/2))) | i <- [0 .. (n\/2-1)]]\n\nFFTInv  : {k, n} (ispoweroftwo k n) => (FFT n) -> (Poly n C)\nFFTInv(x) = zero\n\nFFT' : {k, n} (ispoweroftwo k n) => Poly n ZZ -> FFT n\nFFT'(x) = FFT`{k}(map IntToCmplx x : (Poly n C))\n\nFFT'' : {k, n} (ispoweroftwo k n) => Poly n (Z q) -> FFT n\nFFT''(x) = FFT'`{k}(map fromZ x)\n\n\/\/ Number Theoretic Transform\nNTT : {k, n} (ispoweroftwo k n) => Poly n (Z q) -> Poly n (Z q)\nNTT(f) = zero\n\nNTTInv : {k, n} (ispoweroftwo k n) => Poly n (Z q) -> Poly n (Z q)\nNTTInv(f) = zero\n\nModInv : Z q -> Z q\nModInv(f) =  1\/. f\n\nphi : {k, n} (ispoweroftwo k n) => Poly (n+1) (Z q)\nphi = [1]#zero#[1]\n\nIntToCmplx : ZZ -> C\nIntToCmplx(x) = ((fromInteger x),zero)\n\ndot : {n} (fin n) => (FFT n, FFT n) -> FFT n\ndot(f,g) = [CMul(fi,gi) | fi <- f | gi <- g]\n\nHadamardDivision : {n} (fin n) => (FFT n, FFT n) -> FFT n\nHadamardDivision(f,g) = dot(f, (map Cinv g))\n\nPolyMul : {k, n} (ispoweroftwo k n) => ((Poly n C), (Poly n C)) -> (Poly n C)\nPolyMul(f,g) = FFTInv`{k}(dot(FFT`{k}(f), FFT`{k}(g)))\n\nPolyInv : {k, n} (ispoweroftwo k n) => (Poly n C) -> (Poly n C)\nPolyInv(f) = FFTInv`{k}(map Cinv (FFT`{k}(f)))\n\nPolyMulInZ : {k, n} (ispoweroftwo k n) => ((Poly n ZZ), (Poly n ZZ)) -> (Poly n ZZ)\nPolyMulInZ(f, g) = zero \/\/ TODO!\n\nPolyDivInZ : {k, n} (ispoweroftwo k n) => ((Poly n ZZ), (Poly n ZZ)) -> (Poly n Q)\nPolyDivInZ(f, g) = zero \/\/ TODO!\n\ninnerProduct : {k, n} (ispoweroftwo k n) => ((Poly n C), (Poly n C)) -> C\ninnerProduct(f, g) = zero \/\/ TODO!\n\nnorm_sq : {k, n} (ispoweroftwo k n) => (Poly n C) -> Float64\nnorm_sq(f) = zero \/\/ TODO!\n\nsplitfft : {k, n} (ispoweroftwo k n, n > 2) => (FFT n) -> [2](FFT (n\/2))\nsplitfft FFTf = [resize(FFTf0), resize(FFTf1)] where\n    FFTf0 = [FFTf@(2*i  ) | i <- [0 .. (2^^(k-1)-1)]]\n    FFTf1 = [FFTf@(2*i+1) | i <- [0 .. (2^^(k-1)-1)]]\n\nmergefft : {k, n} (ispoweroftwo k n, n>=2) => [2](FFT (n\/2)) -> (FFT n)\nmergefft ([f0, f1]) = resize FFTf where\n    FFTf = join[[f0@i,f1@i] | i <- [0 .. (2^^(k-1)-1)]]\n\ntype Poly degree a = [degree]a\n\ntype FFT degree = Poly degree C\ntype NTT degree = Poly degree (Z q)\n\n\/\/ public key types\ntype publicKey = Poly _n (Z q)\ntype encodedPublicKey = [14 * _n \/^ 8 + 1]Byte\n\n\/\/ private key types\ntype privateKey = ([2][2](FFT _n), falconTree _k)\ntype encodedPrivateKey = [2*((_n+1)*coeffs_number_of_bits) + ((_n+1)*8)]Bit\n\ntype falconTree k = [2^^k*(1+k)]C\n\ngetValue : {k, n} (ispoweroftwo k n) => falconTree k -> Poly n C\ngetValue T = take`{n} T\n\n\/\/ getChildren: {k, n} (ispoweroftwo k n, positive_power k) => falconTree k -> (falconTree (k-1), falconTree (k-1))\n\/\/ getChildren T = children where\n\/\/     children = split`{2,2^^(k-1)*k} (drop`{n} T)\n\nget_leftchild : {k, n} (ispoweroftwo k n, k > 0) => falconTree k -> falconTree (k-1)\nget_leftchild T = left where\n    children = resize (drop`{n} T): [2*2^^(k-1)*k]C\n    [left, right] = split`{2,2^^(k-1)*k} children\n\nget_rightchild : {k, n} (ispoweroftwo k n, k > 0) => falconTree k -> falconTree (k-1)\nget_rightchild T = right where\n    children = resize (drop`{n} T): [2*2^^(k-1)*k]C\n    [left, right] = split`{2,2^^(k-1)*k} children\n\nnewTree : {k, n} (ispoweroftwo k n, k >= 1) => (Poly n C, falconTree (k-1), falconTree (k-1)) -> falconTree k\nnewTree(value, leftchild, rightchild) = T where\n    T = zero\n\n\/\/ The leaves contain real numbers\n\/\/ For consistency their type is C\nnewLeaf : C -> falconTree 0\nnewLeaf sigma_leaf = [sigma_leaf]\n\nget_leaves : {k, n} (ispoweroftwo k n) => falconTree k -> [2^^k]C\nget_leaves T | k == 0 => T\n             | k >  0 => resize leaves where\n                left_child = get_leftchild`{k} T : falconTree (k-1)\n                right_child = get_rightchild`{k} T : falconTree (k-1)\n                left_leaves  = get_leaves`{k-1} left_child : [2^^(k-1)]C\n                right_leaves  = get_leaves`{k-1} right_child : [2^^(k-1)]C\n                leaves = left_leaves # right_leaves : [2*2^^(k-1)]C\n\nset_leaves : {k, n} (ispoweroftwo k n) => (falconTree k, [2^^k]C) -> falconTree k\nset_leaves(T, leaves) | k == 0 => leaves\n                      | k >  0 => newTree`{k}(value, newleftchild, newrightchild) where\n                        value = getValue`{k} T\n                        leftchild = get_leftchild`{k} T\n                        rightchild = get_rightchild`{k} T\n                        [leftleaves, rightleaves] = split`{2,2^^(k-1)} (resize leaves)\n                        newleftchild = set_leaves`{k-1}(leftchild, leftleaves)\n                        newrightchild = set_leaves`{k-1}(rightchild, rightleaves)\n\nCompress : Poly _n ZZ -> [slen]\nCompress s = zero\n\nDecompress : [slen] -> Poly _n ZZ\nDecompress str = zero\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256\nHashToPoint : {q', k, n, len} (q' <= 2^^16, q' >= 1, ispoweroftwo k n, fin len) => [len] -> Poly n (Z q')\nHashToPoint str = [c i | i <- [0..(n-1)]] where\n    k = 2^^16 \/ `q\n    c i = fromInteger(t i % `q)\n    t i = zero \/\/ TODO!\n\n\/\/ phi and q are fixed so we do not parameterize this algorithm\n\/\/ f and g cannot be sampled in Cryptol so we take them as input\nKeygen : (Poly _n ZZ, Poly _n ZZ) -> (privateKey, publicKey)\nKeygen (f', g') = (sk, pk) where\n    (f, g, F, G) = NTRUGen(f', g'): (Poly _n ZZ, Poly _n ZZ, Poly _n ZZ, Poly _n ZZ)\n    B = [[map IntToCmplx g,map IntToCmplx (-f)],[map IntToCmplx G,map IntToCmplx (-F)]] : [2][2](Poly _n C)\n    Bhat = [[FFT'`{_k}(g),FFT'`{_k}(-f)],[FFT'`{_k}(G),FFT'`{_k}(-F)]] : [2][2](FFT _n)\n    GG = B * Bhat\n    T = ffLDL`{_k}(GG)\n    leaves = get_leaves`{_k} T\n    new_leaves = [(sigma\/.r_leaf,0) | (r_leaf, _) <- leaves]\n    T' = set_leaves`{_k}(T, new_leaves)\n    sk = (Bhat, T')\n    h = NTTInv`{_k}(NTT`{_k}(map fromInteger g)*(map ModInv (NTT`{_k}(map fromInteger f))))\n    pk = h\n\nN : {k, n} (ispoweroftwo k n, k > 0) => (Poly n ZZ) -> (Poly (2^^(k-1)) ZZ)\nN(f) = zero\n\nxSquared : {k, n} (ispoweroftwo k n) => (Poly n ZZ) -> (Poly (2^^(k+1)) ZZ)\nxSquared(F) = resize (join[[c,0] | c <- F])\n\nminusx : {k, n} (ispoweroftwo k n) => (Poly n ZZ) -> (Poly n ZZ)\nminusx(g) = resize (join[ [g@i, -(g@(i+1))] | i <- [0, 2 .. (n-1)]])\n\n\/\/ phi and q are fixed so we do not parameterize this algorithm\n\/\/ f and g cannot be sampled in Cryptol so we take them as input\n\/\/ We assume they pass conditions in lines 7 and 9\nNTRUGen : (Poly _n ZZ, Poly _n ZZ) -> (Poly _n ZZ, Poly _n ZZ, Poly _n ZZ, Poly _n ZZ)\nNTRUGen(f, g) = (f, g, F, G) where\n    (F, G) = NTRUSolve`{_k}(f, g)\n\nNTRUSolve : {k, n} (ispoweroftwo k n) => (Poly n ZZ, Poly n ZZ) -> (Poly n ZZ, Poly n ZZ)\nNTRUSolve(f, g) | k == 0 => ([F], [G]) where\n                                (gcd, u, v) = eGCD(f@0, g@0)\n                                (F, G) = (u*`q, v*`q)\n                | k >  0 => (_F, _G) where\n                                f' = N`{k}(f)\n                                g' = N`{k}(g)\n                                (F', G') = NTRUSolve`{k-1}(f',g')\n                                F = PolyMulInZ`{k}(xSquared`{k-1}(F'), minusx`{k}(g))\n                                G = PolyMulInZ`{k}(xSquared`{k-1}(G'), minusx`{k}(f))\n                                (_F, _G) = Reduce`{k}(f,g,F,G)\n\neGCD : (ZZ, ZZ) -> (ZZ, ZZ, ZZ)\neGCD(a, b) =\n    if a == 0\n    then (b, 0, 1)\n    else (g, t - (b \/ a) * s, s) where\n        (g, s, t) = eGCD((b%a), a)\n\nReduce : {k, n} (ispoweroftwo k n) => (Poly n ZZ, Poly n ZZ, Poly n ZZ, Poly n ZZ) -> (Poly n ZZ, Poly n ZZ)\nReduce(f,g,F,G) = (_F, _G) where\n    numerator = PolyMulInZ`{k}(F, adjoint`{k}(f)) + PolyMulInZ`{k}(G, adjoint`{k}(g))\n    denominator = PolyMulInZ`{k}(f, adjoint`{k}(f)) + PolyMulInZ`{k}(g, adjoint`{k}(g))\n    _k = map roundToEven (PolyDivInZ`{k}(numerator, denominator)): Poly n ZZ\n    F' = F - PolyMulInZ`{k}(_k,f)\n    G' = G - PolyMulInZ`{k}(_k, g)\n    (_F, _G, _) = Reduce'`{k}(_k,f,g,F',G')\n\nadjoint : {k, n} (ispoweroftwo k n) => (Poly n ZZ) -> (Poly n ZZ)\nadjoint(f) = reverse f\n\nReduce' : {k, n} (ispoweroftwo k n) => (Poly n ZZ, Poly n ZZ, Poly n ZZ, Poly n ZZ, Poly n ZZ) -> (Poly n ZZ, Poly n ZZ, Poly n ZZ)\nReduce'(_k,f,g,F,G) =\n    if _k == zero\n    then (F, G, _k)\n    else Reduce'`{k}(_k', f, g, F', G') where\n        numerator = PolyMulInZ`{k}(F, adjoint`{k}(f)) + PolyMulInZ`{k}(G, adjoint`{k}(g))\n        denominator = PolyMulInZ`{k}(f, adjoint`{k}(f)) + PolyMulInZ`{k}(g, adjoint`{k}(g))\n        _k' = map roundToEven (PolyDivInZ`{k}(numerator, denominator)): Poly n ZZ\n        F' = F - PolyMulInZ`{k}(_k',f)\n        G' = G - PolyMulInZ`{k}(_k', g)\n\none : {k, n} (ispoweroftwo k n) => FFT n\none = [(1.0,0.0) | i <- [0 .. (n-1)]]\n\nLDL : {k, n} (ispoweroftwo k n) => [2][2](FFT n) -> (([2][2](FFT n)), ([2][2](FFT n)))\nLDL(G) = (L, D) where\n    D00 = G@0@0\n    L10 = HadamardDivision(G@1@0,G@0@0): FFT n\n    D11 = G@1@1 - dot(L10,dot(PolyConj`{k}(L10),G@0@0))\n    L = [[one`{k}, zero],[L10, one`{k}]]\n    D = [[D00, zero],[zero, D11]]\n\nffLDL : {k, n} (ispoweroftwo k n, n >= 2) => ([2][2](FFT n)) -> (falconTree k)\nffLDL(G) | k == 1 => T where\n            (L, D) = LDL`{k}(G) : ([2][2](FFT n), [2][2](FFT n))\n            left_child = D@0@0 : FFT 2\n            left_leaf = newLeaf(left_child@0) \/\/ Revise this\n            right_child = D@1@1 : FFT 2\n            right_leaf = newLeaf(right_child@0) \/\/ Revise this\n            T = newTree`{k}(L@1@0, left_leaf, right_leaf)\n         | k >  1 => T where\n            (L, D) = LDL`{k}(G) : ([2][2](FFT n), [2][2](FFT n))\n            [d00, d01] = splitfft`{k}(D@0@0)\n            [d10, d11] = splitfft`{k}(D@1@1)\n            G0 = [[resize d00,resize d01],[resize d01, resize d00]] \/\/ Revise this\n            G1 = [[resize d10,resize d11],[resize d11, resize d10]]\n            Tleftchild = ffLDL`{k-1}(G0)\n            Trightchild = ffLDL`{k-1}(G1)\n            T = newTree`{k}(L@1@0, Tleftchild, Trightchild)\n\ntype signature = ([320], [slen])\nSign : {len} (fin len) => ([len], privateKey, Integer, [320]) -> signature\nSign(m, sk, beta, r) = zero where\n    (Bhat, T) = sk\n    c = HashToPoint`{q,_k}(r#m)\n    [[FFTg,FFT_f],[FFTG,FFT_F]] = Bhat \/\/ Bhat stores them in FFT representation (some are negated)\n    t0 = Normalize_FFT`{_k}(`q, dot(FFT''`{_k,_n}(c),FFT_F))\n    t1 = Normalize_FFT`{_k}(`q, dot(FFT''`{_k,_n}(c),FFT_F))\n    tt = [t0, t1] : [2](FFT _n)\n    s_init : [slen]\n    s_init = zero\n    is_bot : [slen] -> Bit\n    is_bot(_s) = (_s == zero)\n    body' : [slen] -> [slen]\n    body'(_s) = zero where\n        ss_init = zero : FFT _n\n        norm_greater_than_beta : FFT _n -> Bit\n        norm_greater_than_beta(_ss) = norm_sq`{_k}(_ss) > (fromInteger beta)\n        body'' : FFT _n -> FFT _n\n        body''(_ss) = zero where\n            zz = ffSampling`{_k}(tt, T) : [2](FFT _n)\n            \/\/ _ss' = [ dot`{_n}((tt_ - zz_),Bhat_) | tt_ <- tt | zz_ <- zz | Bhat_ <- Bhat]\n        _ss_final = dowhile norm_greater_than_beta body'' ss_init\n    s_final = dowhile is_bot body' s_init\n\nffSampling : {k, n} (ispoweroftwo k n) => ([2](FFT n), falconTree k) -> [2](FFT n)\nffSampling(t, T) = z where\n    [t0, t1] = t\n    z = [z0, z1]\n    z0 = zero\n    z1 = zero\n\nRCDT = [\n    3024686241123004913666,\n    1564742784480091954050,\n    636254429462080897535,\n    199560484645026482916,\n    47667343854657281903,\n    8595902006365044063,\n    1163297957344668388,\n    117656387352093658,\n    8867391802663976,\n    496969357462633,\n    20680885154299,\n    638331848991,\n    14602316184,\n    247426747,\n    3104126,\n    28824,\n    198,\n    1,\n    0\n] : [19][72]\n\nBaseSampler : [72] -> ZZ\nBaseSampler(u) = z0 where\n    z0 = zero\n\nimport Float\nApproxExp : (Float64, Float64) -> [64]\nApproxExp(x, ccs) = y'' where\n    C = [\n            0x00000004741183A3,\n            0x00000036548CFC06,\n            0x0000024FDCBF140A,\n            0x0000171D939DE045,\n            0x0000D00CF58F6F84,\n            0x000680681CF796E3,\n            0x002D82D8305B0FEA,\n            0x011111110E066FD0,\n            0x0555555555070F00,\n            0x155555555581FF00,\n            0x400000000002B400,\n            0x7FFFFFFFFFFF4800,\n            0x8000000000000000\n        ]\n    y = C@0\n    z = fromInteger (floor(2^^63 * x))\n    y' = foldl (\\yy -> \\u -> C@u - (z*y)>>63) y [1 .. 12]\n    z' = fromInteger (floor(2^^63 * ccs))\n    y'' = (z'*y')>>63\n\nBerExp : (Float64, Float64) -> Bit\nBerExp(x, ccs) = w < 0 where\n    ln2 = 0.69314718056\n    s = x \/. ln2\n    r = floor(x - s * ln2)\n    s' = min(s, 63)\n        w = zero\n\nSamplerZ : (Float64, Float64) -> ZZ\nSamplerZ(m, sigma') = z where\n    z = zero\n\nVerify : {len} (fin len) => ([len], signature, publicKey, Integer) -> Bit\nVerify(m, sig, pk, beta) = norm^^2 <= beta where\n    norm = zero\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/FALCON\/1.2\/falcon_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named falcon_512 that contains a submodule falcon_inst instantiated from spec2. Inside falcon_inst, declare the following type-level natural parameters with the exact values: a security parameter, a ring dimension, public key byte length, signature byte length, coefficient bit-width, and a modulus defined as 3 multiplied by 2 raised to the 12th power plus 1. Also define value-level constants: an integer small modulus, three real-valued standard deviation bounds (nominal, minimum, maximum), and an integer bound parameter. Include a lookup table constant of unit-circle twiddle factors as a sequence of pairs of real numbers (cosine, sine) sampled at uniform angular steps corresponding to the ring dimension, with the exact numeric entries and ordering. Ensure each definition has an appropriate Cryptol type (type synonyms for naturals; Integer for integral values; sequences of tuples of real numbers for the twiddle table). After the submodule block, import the submodule so its definitions are available in the module\u2019s scope. Do not introduce any additional properties or functions; exactly mirror the configuration parameters and constants and make their types unambiguous."},{"role":"assistant","content":"```cryptol\nmodule falcon_512 where\n\nsubmodule falcon_inst = spec2\n    where\n    type _k = 9\n    type _n = 512\n    type pkbytelen = 897\n    type sbytelen = 666\n    type coeffs_number_of_bits = 6\n    type q = 3 * 2^^12 + 1\n    r = 3\n    sigma = 165.736617183\n    sigma_min = 1.277833697\n    sigma_max = 1.8205\n    beta = 34034726\n\n    Omega_phi = [\n        (1, 0),\n        (0.9999247018391445, 0.012271538285719925),\n        (0.9996988186962042, 0.024541228522912288),\n        (0.9993223845883495, 0.03680722294135883),\n        (0.9987954562051724, 0.049067674327418015),\n        (0.9981181129001492, 0.06132073630220858),\n        (0.9972904566786902, 0.07356456359966743),\n        (0.996312612182778, 0.0857973123444399),\n        (0.9951847266721969, 0.0980171403295606),\n        (0.9939069700023561, 0.11022220729388306),\n        (0.99247953459871, 0.1224106751992162),\n        (0.99090263542778, 0.13458070850712617),\n        (0.989176509964781, 0.14673047445536175),\n        (0.9873014181578584, 0.15885814333386145),\n        (0.9852776423889412, 0.17096188876030122),\n        (0.9831054874312163, 0.18303988795514095),\n        (0.9807852804032304, 0.19509032201612825),\n        (0.9783173707196277, 0.20711137619221856),\n        (0.9757021300385286, 0.2191012401568698),\n        (0.9729399522055602, 0.2310581082806711),\n        (0.970031253194544, 0.24298017990326387),\n        (0.9669764710448521, 0.25486565960451457),\n        (0.9637760657954398, 0.26671275747489837),\n        (0.9604305194155658, 0.27851968938505306),\n        (0.9569403357322088, 0.29028467725446233),\n        (0.9533060403541939, 0.3020059493192281),\n        (0.9495281805930367, 0.3136817403988915),\n        (0.9456073253805213, 0.3253102921622629),\n        (0.9415440651830208, 0.33688985339222005),\n        (0.937339011912575, 0.34841868024943456),\n        (0.932992798834739, 0.3598950365349881),\n        (0.9285060804732156, 0.37131719395183754),\n        (0.9238795325112867, 0.3826834323650898),\n        (0.9191138516900578, 0.3939920400610481),\n        (0.9142097557035307, 0.40524131400498986),\n        (0.9091679830905224, 0.41642956009763715),\n        (0.9039892931234433, 0.4275550934302821),\n        (0.8986744656939538, 0.43861623853852766),\n        (0.8932243011955153, 0.44961132965460654),\n        (0.8876396204028539, 0.46053871095824),\n        (0.881921264348355, 0.47139673682599764),\n        (0.8760700941954066, 0.4821837720791227),\n        (0.8700869911087115, 0.49289819222978404),\n        (0.8639728561215867, 0.5035383837257176),\n        (0.8577286100002721, 0.5141027441932217),\n        (0.8513551931052652, 0.524589682678469),\n        (0.8448535652497071, 0.5349976198870972),\n        (0.838224705554838, 0.5453249884220465),\n        (0.8314696123025452, 0.5555702330196022),\n        (0.8245893027850253, 0.5657318107836131),\n        (0.8175848131515837, 0.5758081914178453),\n        (0.8104571982525948, 0.5857978574564389),\n        (0.8032075314806449, 0.5956993044924334),\n        (0.7958369046088836, 0.6055110414043255),\n        (0.7883464276266063, 0.6152315905806268),\n        (0.7807372285720945, 0.6248594881423863),\n        (0.773010453362737, 0.6343932841636455),\n        (0.765167265622459, 0.6438315428897914),\n        (0.7572088465064846, 0.6531728429537768),\n        (0.7491363945234594, 0.6624157775901718),\n        (0.7409511253549592, 0.6715589548470183),\n        (0.7326542716724128, 0.680600997795453),\n        (0.724247082951467, 0.6895405447370668),\n        (0.7157308252838186, 0.6983762494089729),\n        (0.7071067811865476, 0.7071067811865475),\n        (0.6983762494089729, 0.7157308252838186),\n        (0.6895405447370669, 0.7242470829514669),\n        (0.6806009977954531, 0.7326542716724127),\n        (0.6715589548470184, 0.740951125354959),\n        (0.6624157775901718, 0.7491363945234593),\n        (0.6531728429537769, 0.7572088465064845),\n        (0.6438315428897915, 0.7651672656224588),\n        (0.6343932841636456, 0.7730104533627369),\n        (0.6248594881423865, 0.7807372285720944),\n        (0.6152315905806269, 0.7883464276266062),\n        (0.6055110414043255, 0.7958369046088835),\n        (0.5956993044924335, 0.8032075314806448),\n        (0.5857978574564389, 0.8104571982525948),\n        (0.5758081914178454, 0.8175848131515837),\n        (0.5657318107836132, 0.8245893027850253),\n        (0.5555702330196023, 0.8314696123025451),\n        (0.5453249884220466, 0.838224705554838),\n        (0.5349976198870974, 0.844853565249707),\n        (0.524589682678469, 0.8513551931052652),\n        (0.5141027441932218, 0.8577286100002721),\n        (0.5035383837257176, 0.8639728561215867),\n        (0.49289819222978415, 0.8700869911087113),\n        (0.4821837720791229, 0.8760700941954065),\n        (0.4713967368259978, 0.8819212643483549),\n        (0.46053871095824, 0.8876396204028539),\n        (0.4496113296546066, 0.8932243011955153),\n        (0.4386162385385277, 0.8986744656939538),\n        (0.4275550934302822, 0.9039892931234433),\n        (0.4164295600976373, 0.9091679830905224),\n        (0.4052413140049898, 0.9142097557035307),\n        (0.3939920400610481, 0.9191138516900578),\n        (0.38268343236508984, 0.9238795325112867),\n        (0.3713171939518376, 0.9285060804732155),\n        (0.3598950365349883, 0.9329927988347388),\n        (0.3484186802494345, 0.937339011912575),\n        (0.33688985339222005, 0.9415440651830208),\n        (0.325310292162263, 0.9456073253805213),\n        (0.3136817403988915, 0.9495281805930367),\n        (0.3020059493192282, 0.9533060403541938),\n        (0.2902846772544623, 0.9569403357322089),\n        (0.27851968938505306, 0.9604305194155658),\n        (0.2667127574748984, 0.9637760657954398),\n        (0.2548656596045146, 0.9669764710448521),\n        (0.24298017990326398, 0.970031253194544),\n        (0.23105810828067125, 0.9729399522055601),\n        (0.21910124015686977, 0.9757021300385286),\n        (0.20711137619221856, 0.9783173707196277),\n        (0.1950903220161283, 0.9807852804032304),\n        (0.18303988795514103, 0.9831054874312163),\n        (0.17096188876030136, 0.9852776423889412),\n        (0.1588581433338614, 0.9873014181578584),\n        (0.14673047445536175, 0.989176509964781),\n        (0.13458070850712622, 0.99090263542778),\n        (0.12241067519921628, 0.99247953459871),\n        (0.11022220729388318, 0.9939069700023561),\n        (0.09801714032956077, 0.9951847266721968),\n        (0.08579731234443988, 0.996312612182778),\n        (0.07356456359966745, 0.9972904566786902),\n        (0.061320736302208655, 0.9981181129001492),\n        (0.04906767432741813, 0.9987954562051724),\n        (0.03680722294135899, 0.9993223845883495),\n        (0.024541228522912267, 0.9996988186962042),\n        (0.012271538285719944, 0.9999247018391445),\n        (6.123233995736766e-17, 1.0),\n        (-0.012271538285719823, 0.9999247018391445),\n        (-0.024541228522912142, 0.9996988186962042),\n        (-0.036807222941358866, 0.9993223845883495),\n        (-0.04906767432741801, 0.9987954562051724),\n        (-0.06132073630220853, 0.9981181129001492),\n        (-0.07356456359966734, 0.9972904566786902),\n        (-0.08579731234443977, 0.996312612182778),\n        (-0.09801714032956066, 0.9951847266721969),\n        (-0.11022220729388307, 0.9939069700023561),\n        (-0.12241067519921617, 0.99247953459871),\n        (-0.1345807085071261, 0.99090263542778),\n        (-0.14673047445536164, 0.989176509964781),\n        (-0.15885814333386128, 0.9873014181578584),\n        (-0.17096188876030124, 0.9852776423889412),\n        (-0.18303988795514095, 0.9831054874312163),\n        (-0.1950903220161282, 0.9807852804032304),\n        (-0.20711137619221845, 0.9783173707196277),\n        (-0.21910124015686966, 0.9757021300385286),\n        (-0.23105810828067117, 0.9729399522055602),\n        (-0.24298017990326387, 0.970031253194544),\n        (-0.2548656596045145, 0.9669764710448521),\n        (-0.2667127574748983, 0.9637760657954398),\n        (-0.27851968938505295, 0.9604305194155659),\n        (-0.2902846772544622, 0.9569403357322089),\n        (-0.3020059493192281, 0.9533060403541939),\n        (-0.31368174039889146, 0.9495281805930367),\n        (-0.32531029216226287, 0.9456073253805214),\n        (-0.33688985339221994, 0.9415440651830208),\n        (-0.3484186802494344, 0.937339011912575),\n        (-0.35989503653498817, 0.9329927988347388),\n        (-0.37131719395183754, 0.9285060804732156),\n        (-0.3826834323650897, 0.9238795325112867),\n        (-0.393992040061048, 0.9191138516900578),\n        (-0.40524131400498975, 0.9142097557035307),\n        (-0.416429560097637, 0.9091679830905225),\n        (-0.42755509343028186, 0.9039892931234434),\n        (-0.4386162385385274, 0.8986744656939539),\n        (-0.4496113296546067, 0.8932243011955152),\n        (-0.4605387109582401, 0.8876396204028539),\n        (-0.4713967368259977, 0.881921264348355),\n        (-0.4821837720791227, 0.8760700941954066),\n        (-0.4928981922297839, 0.8700869911087115),\n        (-0.5035383837257175, 0.8639728561215868),\n        (-0.5141027441932216, 0.8577286100002721),\n        (-0.5245896826784687, 0.8513551931052652),\n        (-0.5349976198870969, 0.8448535652497072),\n        (-0.5453249884220461, 0.8382247055548382),\n        (-0.555570233019602, 0.8314696123025455),\n        (-0.5657318107836132, 0.8245893027850253),\n        (-0.5758081914178453, 0.8175848131515837),\n        (-0.5857978574564389, 0.8104571982525948),\n        (-0.5956993044924332, 0.8032075314806449),\n        (-0.6055110414043254, 0.7958369046088836),\n        (-0.6152315905806267, 0.7883464276266063),\n        (-0.6248594881423862, 0.7807372285720946),\n        (-0.6343932841636453, 0.7730104533627371),\n        (-0.6438315428897913, 0.7651672656224591),\n        (-0.6531728429537765, 0.7572088465064848),\n        (-0.6624157775901718, 0.7491363945234593),\n        (-0.6715589548470184, 0.740951125354959),\n        (-0.680600997795453, 0.7326542716724128),\n        (-0.6895405447370668, 0.724247082951467),\n        (-0.6983762494089728, 0.7157308252838187),\n        (-0.7071067811865475, 0.7071067811865476),\n        (-0.7157308252838186, 0.6983762494089729),\n        (-0.7242470829514669, 0.689540544737067),\n        (-0.7326542716724127, 0.6806009977954532),\n        (-0.7409511253549589, 0.6715589548470186),\n        (-0.749136394523459, 0.662415777590172),\n        (-0.7572088465064847, 0.6531728429537766),\n        (-0.765167265622459, 0.6438315428897914),\n        (-0.773010453362737, 0.6343932841636455),\n        (-0.7807372285720945, 0.6248594881423863),\n        (-0.7883464276266062, 0.6152315905806269),\n        (-0.7958369046088835, 0.6055110414043255),\n        (-0.8032075314806448, 0.5956993044924335),\n        (-0.8104571982525947, 0.585797857456439),\n        (-0.8175848131515836, 0.5758081914178454),\n        (-0.8245893027850251, 0.5657318107836135),\n        (-0.8314696123025453, 0.5555702330196022),\n        (-0.8382247055548381, 0.5453249884220464),\n        (-0.8448535652497071, 0.5349976198870972),\n        (-0.8513551931052652, 0.524589682678469),\n        (-0.8577286100002721, 0.5141027441932218),\n        (-0.8639728561215867, 0.5035383837257176),\n        (-0.8700869911087113, 0.49289819222978415),\n        (-0.8760700941954065, 0.4821837720791229),\n        (-0.8819212643483549, 0.4713967368259978),\n        (-0.8876396204028538, 0.4605387109582402),\n        (-0.8932243011955152, 0.4496113296546069),\n        (-0.8986744656939539, 0.43861623853852755),\n        (-0.9039892931234433, 0.42755509343028203),\n        (-0.9091679830905224, 0.41642956009763715),\n        (-0.9142097557035307, 0.40524131400498986),\n        (-0.9191138516900578, 0.39399204006104815),\n        (-0.9238795325112867, 0.38268343236508984),\n        (-0.9285060804732155, 0.37131719395183765),\n        (-0.9329927988347388, 0.35989503653498833),\n        (-0.9373390119125748, 0.3484186802494348),\n        (-0.9415440651830207, 0.3368898533922203),\n        (-0.9456073253805213, 0.3253102921622632),\n        (-0.9495281805930367, 0.3136817403988914),\n        (-0.9533060403541939, 0.30200594931922803),\n        (-0.9569403357322088, 0.29028467725446233),\n        (-0.9604305194155658, 0.2785196893850531),\n        (-0.9637760657954398, 0.2667127574748985),\n        (-0.9669764710448521, 0.2548656596045147),\n        (-0.970031253194544, 0.24298017990326404),\n        (-0.9729399522055601, 0.2310581082806713),\n        (-0.9757021300385285, 0.21910124015687002),\n        (-0.9783173707196275, 0.20711137619221884),\n        (-0.9807852804032304, 0.19509032201612858),\n        (-0.9831054874312164, 0.1830398879551409),\n        (-0.9852776423889412, 0.1709618887603012),\n        (-0.9873014181578584, 0.15885814333386145),\n        (-0.989176509964781, 0.1467304744553618),\n        (-0.99090263542778, 0.13458070850712628),\n        (-0.99247953459871, 0.12241067519921635),\n        (-0.9939069700023561, 0.11022220729388325),\n        (-0.9951847266721968, 0.09801714032956084),\n        (-0.996312612182778, 0.08579731234444016),\n        (-0.9972904566786902, 0.07356456359966775),\n        (-0.9981181129001492, 0.061320736302208495),\n        (-0.9987954562051724, 0.04906767432741797),\n        (-0.9993223845883495, 0.03680722294135883),\n        (-0.9996988186962042, 0.024541228522912326),\n        (-0.9999247018391445, 0.012271538285720007),\n        (-1.0, 1.2246467991473532e-16),\n        (-0.9999247018391445, -0.01227153828571976),\n        (-0.9996988186962042, -0.024541228522912083),\n        (-0.9993223845883495, -0.03680722294135858),\n        (-0.9987954562051724, -0.049067674327417724),\n        (-0.9981181129001492, -0.061320736302208245),\n        (-0.9972904566786902, -0.0735645635996675),\n        (-0.996312612182778, -0.08579731234443992),\n        (-0.9951847266721969, -0.09801714032956059),\n        (-0.9939069700023561, -0.110222207293883),\n        (-0.99247953459871, -0.1224106751992161),\n        (-0.99090263542778, -0.13458070850712606),\n        (-0.989176509964781, -0.14673047445536158),\n        (-0.9873014181578584, -0.15885814333386122),\n        (-0.9852776423889413, -0.17096188876030097),\n        (-0.9831054874312164, -0.18303988795514067),\n        (-0.9807852804032304, -0.19509032201612836),\n        (-0.9783173707196277, -0.20711137619221862),\n        (-0.9757021300385286, -0.21910124015686983),\n        (-0.9729399522055602, -0.2310581082806711),\n        (-0.970031253194544, -0.24298017990326382),\n        (-0.9669764710448522, -0.25486565960451446),\n        (-0.96377606579544, -0.26671275747489825),\n        (-0.9604305194155659, -0.2785196893850529),\n        (-0.9569403357322089, -0.29028467725446216),\n        (-0.953306040354194, -0.3020059493192278),\n        (-0.9495281805930368, -0.3136817403988912),\n        (-0.9456073253805213, -0.32531029216226304),\n        (-0.9415440651830208, -0.3368898533922201),\n        (-0.937339011912575, -0.34841868024943456),\n        (-0.932992798834739, -0.3598950365349881),\n        (-0.9285060804732156, -0.3713171939518375),\n        (-0.9238795325112867, -0.38268343236508967),\n        (-0.9191138516900578, -0.39399204006104793),\n        (-0.9142097557035307, -0.4052413140049897),\n        (-0.9091679830905225, -0.41642956009763693),\n        (-0.9039892931234434, -0.4275550934302818),\n        (-0.898674465693954, -0.4386162385385273),\n        (-0.8932243011955153, -0.44961132965460665),\n        (-0.8876396204028539, -0.46053871095824006),\n        (-0.881921264348355, -0.47139673682599764),\n        (-0.8760700941954066, -0.4821837720791227),\n        (-0.8700869911087115, -0.4928981922297839),\n        (-0.8639728561215868, -0.5035383837257175),\n        (-0.8577286100002721, -0.5141027441932216),\n        (-0.8513551931052652, -0.5245896826784687),\n        (-0.8448535652497072, -0.5349976198870969),\n        (-0.8382247055548382, -0.5453249884220461),\n        (-0.8314696123025455, -0.555570233019602),\n        (-0.8245893027850253, -0.5657318107836132),\n        (-0.8175848131515837, -0.5758081914178453),\n        (-0.8104571982525948, -0.5857978574564389),\n        (-0.8032075314806449, -0.5956993044924332),\n        (-0.7958369046088836, -0.6055110414043254),\n        (-0.7883464276266063, -0.6152315905806267),\n        (-0.7807372285720946, -0.6248594881423862),\n        (-0.7730104533627371, -0.6343932841636453),\n        (-0.7651672656224591, -0.6438315428897913),\n        (-0.7572088465064848, -0.6531728429537765),\n        (-0.7491363945234593, -0.6624157775901718),\n        (-0.740951125354959, -0.6715589548470184),\n        (-0.7326542716724128, -0.680600997795453),\n        (-0.724247082951467, -0.6895405447370668),\n        (-0.7157308252838187, -0.6983762494089728),\n        (-0.7071067811865477, -0.7071067811865475),\n        (-0.698376249408973, -0.7157308252838185),\n        (-0.6895405447370672, -0.7242470829514667),\n        (-0.6806009977954532, -0.7326542716724126),\n        (-0.6715589548470187, -0.7409511253549588),\n        (-0.6624157775901721, -0.749136394523459),\n        (-0.6531728429537771, -0.7572088465064842),\n        (-0.6438315428897915, -0.7651672656224588),\n        (-0.6343932841636459, -0.7730104533627367),\n        (-0.6248594881423865, -0.7807372285720944),\n        (-0.6152315905806274, -0.7883464276266059),\n        (-0.6055110414043257, -0.7958369046088833),\n        (-0.5956993044924332, -0.803207531480645),\n        (-0.5857978574564391, -0.8104571982525947),\n        (-0.5758081914178452, -0.8175848131515837),\n        (-0.5657318107836136, -0.8245893027850251),\n        (-0.5555702330196022, -0.8314696123025452),\n        (-0.5453249884220468, -0.8382247055548377),\n        (-0.5349976198870973, -0.8448535652497071),\n        (-0.5245896826784694, -0.8513551931052649),\n        (-0.5141027441932219, -0.857728610000272),\n        (-0.5035383837257181, -0.8639728561215865),\n        (-0.49289819222978426, -0.8700869911087113),\n        (-0.4821837720791226, -0.8760700941954067),\n        (-0.47139673682599786, -0.8819212643483549),\n        (-0.4605387109582399, -0.887639620402854),\n        (-0.44961132965460693, -0.8932243011955152),\n        (-0.4386162385385276, -0.8986744656939538),\n        (-0.4275550934302825, -0.9039892931234431),\n        (-0.4164295600976372, -0.9091679830905224),\n        (-0.40524131400499036, -0.9142097557035305),\n        (-0.3939920400610482, -0.9191138516900577),\n        (-0.38268343236509034, -0.9238795325112865),\n        (-0.3713171939518377, -0.9285060804732155),\n        (-0.35989503653498794, -0.932992798834739),\n        (-0.34841868024943484, -0.9373390119125748),\n        (-0.33688985339221994, -0.9415440651830208),\n        (-0.32531029216226326, -0.9456073253805212),\n        (-0.31368174039889146, -0.9495281805930367),\n        (-0.3020059493192285, -0.9533060403541938),\n        (-0.2902846772544624, -0.9569403357322088),\n        (-0.2785196893850536, -0.9604305194155657),\n        (-0.26671275747489853, -0.9637760657954398),\n        (-0.2548656596045143, -0.9669764710448522),\n        (-0.24298017990326412, -0.970031253194544),\n        (-0.23105810828067097, -0.9729399522055602),\n        (-0.2191012401568701, -0.9757021300385285),\n        (-0.20711137619221848, -0.9783173707196277),\n        (-0.19509032201612866, -0.9807852804032303),\n        (-0.18303988795514098, -0.9831054874312163),\n        (-0.17096188876030172, -0.9852776423889411),\n        (-0.15885814333386153, -0.9873014181578583),\n        (-0.14673047445536233, -0.9891765099647809),\n        (-0.13458070850712636, -0.99090263542778),\n        (-0.12241067519921596, -0.9924795345987101),\n        (-0.11022220729388331, -0.9939069700023561),\n        (-0.09801714032956045, -0.9951847266721969),\n        (-0.08579731234444021, -0.996312612182778),\n        (-0.07356456359966736, -0.9972904566786902),\n        (-0.06132073630220899, -0.9981181129001492),\n        (-0.04906767432741803, -0.9987954562051724),\n        (-0.03680722294135933, -0.9993223845883494),\n        (-0.02454122852291239, -0.9996988186962042),\n        (-0.012271538285720512, -0.9999247018391445),\n        (-1.8369701987210297e-16, -1.0),\n        (0.012271538285720144, -0.9999247018391445),\n        (0.02454122852291202, -0.9996988186962042),\n        (0.03680722294135897, -0.9993223845883495),\n        (0.04906767432741767, -0.9987954562051724),\n        (0.061320736302208634, -0.9981181129001492),\n        (0.073564563599667, -0.9972904566786902),\n        (0.08579731234443987, -0.996312612182778),\n        (0.09801714032956009, -0.9951847266721969),\n        (0.11022220729388295, -0.9939069700023561),\n        (0.1224106751992156, -0.9924795345987101),\n        (0.13458070850712597, -0.99090263542778),\n        (0.14673047445536194, -0.9891765099647809),\n        (0.15885814333386114, -0.9873014181578584),\n        (0.17096188876030133, -0.9852776423889412),\n        (0.1830398879551406, -0.9831054874312164),\n        (0.19509032201612828, -0.9807852804032304),\n        (0.2071113761922181, -0.9783173707196278),\n        (0.21910124015686974, -0.9757021300385286),\n        (0.23105810828067058, -0.9729399522055603),\n        (0.24298017990326376, -0.970031253194544),\n        (0.25486565960451396, -0.9669764710448523),\n        (0.2667127574748982, -0.96377606579544),\n        (0.2785196893850533, -0.9604305194155658),\n        (0.2902846772544621, -0.9569403357322089),\n        (0.3020059493192282, -0.9533060403541938),\n        (0.31368174039889113, -0.9495281805930368),\n        (0.325310292162263, -0.9456073253805213),\n        (0.3368898533922196, -0.9415440651830209),\n        (0.3484186802494345, -0.937339011912575),\n        (0.35989503653498767, -0.9329927988347391),\n        (0.37131719395183743, -0.9285060804732156),\n        (0.38268343236509, -0.9238795325112866),\n        (0.39399204006104793, -0.9191138516900579),\n        (0.40524131400499, -0.9142097557035306),\n        (0.4164295600976369, -0.9091679830905225),\n        (0.4275550934302822, -0.9039892931234433),\n        (0.43861623853852727, -0.898674465693954),\n        (0.4496113296546066, -0.8932243011955153),\n        (0.4605387109582396, -0.8876396204028542),\n        (0.4713967368259976, -0.881921264348355),\n        (0.4821837720791222, -0.8760700941954069),\n        (0.49289819222978387, -0.8700869911087115),\n        (0.5035383837257177, -0.8639728561215867),\n        (0.5141027441932214, -0.8577286100002722),\n        (0.524589682678469, -0.8513551931052651),\n        (0.5349976198870969, -0.8448535652497073),\n        (0.5453249884220465, -0.838224705554838),\n        (0.5555702330196018, -0.8314696123025456),\n        (0.5657318107836131, -0.8245893027850253),\n        (0.5758081914178449, -0.817584813151584),\n        (0.5857978574564388, -0.8104571982525949),\n        (0.5956993044924328, -0.8032075314806453),\n        (0.6055110414043253, -0.7958369046088837),\n        (0.6152315905806269, -0.7883464276266061),\n        (0.6248594881423861, -0.7807372285720947),\n        (0.6343932841636456, -0.7730104533627369),\n        (0.6438315428897912, -0.7651672656224592),\n        (0.6531728429537768, -0.7572088465064846),\n        (0.6624157775901715, -0.7491363945234597),\n        (0.6715589548470183, -0.7409511253549592),\n        (0.6806009977954527, -0.7326542716724131),\n        (0.6895405447370668, -0.7242470829514671),\n        (0.6983762494089724, -0.715730825283819),\n        (0.7071067811865475, -0.7071067811865477),\n        (0.7157308252838188, -0.6983762494089727),\n        (0.7242470829514667, -0.6895405447370672),\n        (0.7326542716724129, -0.680600997795453),\n        (0.7409511253549588, -0.6715589548470187),\n        (0.7491363945234594, -0.6624157775901718),\n        (0.7572088465064842, -0.6531728429537771),\n        (0.7651672656224588, -0.6438315428897915),\n        (0.7730104533627367, -0.6343932841636459),\n        (0.7807372285720944, -0.6248594881423865),\n        (0.7883464276266059, -0.6152315905806274),\n        (0.7958369046088833, -0.6055110414043257),\n        (0.803207531480645, -0.5956993044924332),\n        (0.8104571982525947, -0.5857978574564391),\n        (0.8175848131515837, -0.5758081914178452),\n        (0.8245893027850251, -0.5657318107836136),\n        (0.8314696123025452, -0.5555702330196022),\n        (0.8382247055548377, -0.5453249884220468),\n        (0.8448535652497071, -0.5349976198870973),\n        (0.8513551931052649, -0.5245896826784694),\n        (0.857728610000272, -0.5141027441932219),\n        (0.8639728561215865, -0.5035383837257181),\n        (0.8700869911087113, -0.49289819222978426),\n        (0.8760700941954067, -0.4821837720791226),\n        (0.8819212643483549, -0.4713967368259979),\n        (0.887639620402854, -0.46053871095823995),\n        (0.8932243011955151, -0.449611329654607),\n        (0.8986744656939538, -0.43861623853852766),\n        (0.9039892931234431, -0.42755509343028253),\n        (0.9091679830905224, -0.41642956009763726),\n        (0.9142097557035305, -0.4052413140049904),\n        (0.9191138516900577, -0.39399204006104827),\n        (0.9238795325112865, -0.3826834323650904),\n        (0.9285060804732155, -0.37131719395183777),\n        (0.932992798834739, -0.359895036534988),\n        (0.9373390119125748, -0.3484186802494349),\n        (0.9415440651830208, -0.33688985339222),\n        (0.9456073253805212, -0.3253102921622633),\n        (0.9495281805930367, -0.3136817403988915),\n        (0.9533060403541936, -0.30200594931922853),\n        (0.9569403357322088, -0.29028467725446244),\n        (0.9604305194155657, -0.27851968938505367),\n        (0.9637760657954398, -0.2667127574748986),\n        (0.9669764710448522, -0.25486565960451435),\n        (0.970031253194544, -0.24298017990326418),\n        (0.9729399522055602, -0.23105810828067103),\n        (0.9757021300385285, -0.21910124015687016),\n        (0.9783173707196277, -0.20711137619221853),\n        (0.9807852804032303, -0.19509032201612872),\n        (0.9831054874312163, -0.18303988795514103),\n        (0.9852776423889411, -0.17096188876030177),\n        (0.9873014181578583, -0.15885814333386158),\n        (0.9891765099647809, -0.1467304744553624),\n        (0.99090263542778, -0.13458070850712642),\n        (0.99247953459871, -0.12241067519921603),\n        (0.9939069700023561, -0.11022220729388338),\n        (0.9951847266721969, -0.09801714032956052),\n        (0.996312612182778, -0.08579731234444028),\n        (0.9972904566786902, -0.07356456359966743),\n        (0.9981181129001492, -0.06132073630220905),\n        (0.9987954562051724, -0.04906767432741809),\n        (0.9993223845883494, -0.036807222941359394),\n        (0.9996988186962042, -0.02454122852291245),\n        (0.9999247018391445, -0.012271538285720572)\n    ]\n\nimport submodule falcon_inst\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Asymmetric::KEM::ML_KEM::Specification that contains: imports of SHAKE256, SHAKE128, SHA3_256, and SHA3_512 instantiations; constants and types for a 256-length ring over integers modulo a prime q, a primitive 256th root of unity zeta (with properties proving its correctness), a Byte alias, and ring\/vector aliases. Provide functions PRF (parameterized by eta in {2,3}), H, J, G (splitting a 64-byte hash into two 32-byte values), and an XOF from a 34-byte seed. Define bit\/byte conversion functions with properties: a property showing iterative division equals shifting, a round-trip invertibility property for bit\/byte conversions, and a rounding behavior property. Define Compress and Decompress between Z q and d-bit vectors (d < width q), with a property that compression inverts decompression, and a property bounding the decompression error; include helpers for the error bound and centered-remainder conversion; and vector\/matrix lifts. Define encoding\/decoding for generic d (1 \u2264 d < 12) and a 12-bit specialization to\/from Z q, vectorized forms, and properties showing loop\/shift equivalences and encode\/decode mutual inverses. Define sampling: SampleNTT (rejection sampling from an XOF to Tq) and SamplePolyCBD (centered binomial over Rq) with eta in {2,3}. Include properties for q\u2019s form, primitive root behavior of zeta, and a BitRev7 function on 8-bit inputs. Add submodule NTT with naive NTT\/Inv, a lookup table of powers of zeta, fast Cooley\u2013Tukey and Gentleman\u2013Sande butterflies and recursive NTT\/Inv, exported fast NTT\/Inv, vectorized transforms, base-case multiply, NTT-domain multiplication, dot products, and properties proving invertibility, equivalence of naive\/fast forms, and a small multiplication test. Add private submodule K_PKE with key types, PKE KeyGen\/Encrypt\/Decrypt, and a correctness property. Provide KEM internals (KeyGen_internal, Encaps_internal, Decaps_internal) with a correctness property. Expose public API types, KeyGen accepting Option seeds, keyPairCheck, a helper that generated keys pass checks, encapsulationKeyCheck, Encaps, decapsulationInputCheck (with private decapsulationKeyCheck), and Decaps. Finish with a parameter block for k, eta_1, eta_2, d_u, d_v and their stated range\/width constraints."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256 as SHAKE256\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE128 as SHAKE128\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256 as SHA3_256\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512 as SHA3_512\n\nprivate\n\n    type n = 256\n\n    type q = 3329\n\n    zeta = 17 : Z q\n\ntype Byte = [8]\n\nprivate\n\n    type Rq = [n](Z q)\n\n    type Tq = [n](Z q)\n\n    PRF : {eta} (2 <= eta, eta <= 3) => [32]Byte -> Byte -> [64 * eta]Byte\n    PRF s b = SHAKE256::xofBytes`{8 * 64 * eta} (s # [b])\n\n    H : {hinl} (fin hinl) => [hinl]Byte -> [32]Byte\n    H s = SHA3_256::hashBytes s\n\n    J : {hinl} (fin hinl) => [hinl]Byte -> [32]Byte\n    J s = SHAKE256::xofBytes`{8 * 32} s\n\n    G : {ginl} (fin ginl) => [ginl]Byte -> ([32]Byte, [32]Byte)\n    G c = (a, b) where\n        [a, b] = split (SHA3_512::hashBytes c)\n\n    XOF : ([34]Byte) -> [inf]Byte\n    XOF = SHAKE128::xofBytes\n\n    BitsToBytes : {ell} (fin ell) => [8 * ell]Bit -> [ell]Byte\n    BitsToBytes b\n        | ell == 0 => zero\n        | ell > 0 => B where\n                                    b' = groupBy`{8} [(zext [bi], i)\n                | bi <- b\n                | i <- [0..8 * ell - 1]]\n\n            \/\/ Steps 2-4.\n            B = [sum [bi * (2 ^^ (i % 8))\n                    | (bi, i) <- bi8]\n                | bi8 <- b']\n\n    BytesToBits : {ell} (fin ell) => [ell]Byte -> [ell*8]Bit\n    BytesToBits C\n        | ell == 0 => []\n        | ell > 0 => join [[ b8ij where\n                                                b8ij = Ci' ! 0\n                \/\/ Step 5. Shifting right is the same as the iterative\n                \/\/ division (see `div2IsShiftR`). This accounts for all the\n                \/\/ divisions \"up to this point\" (e.g. none when `j = 0`), which\n                \/\/ is why we use `Ci'` to evaluate `b8ij` above.\n                Ci' = Ci >> j\n            \/\/ Step 3.\n            | j <- [0..7]]\n            \/\/ Step 2. We iterate over `C` directly instead of indexing into it.\n            | Ci <- C ]\n\n    \/**\n     * The iterative division by 2 in `BytesToBits` is the same as shifting\n     * right.\n     * ```repl\n     * :prove div2IsShiftR\n     * ```\n     *\/\n    div2IsShiftR : Byte -> Bit\n    div2IsShiftR C = take (d2 C) == shl where\n        \/\/ Note: division here is floor'd by default.\n        d2 c = [c] # d2 (c \/ 2)\n        shl = [C >> j | j <- [0..7]]\n\n    B2B2BInverts : {ell} (fin ell, ell > 0) => [ell * 8] -> Bit\n    B2B2BInverts bits = bitsWorks && bytesWorks where\n        bitsWorks = BytesToBits (BitsToBytes bits) == bits\n        bytesWorks = BitsToBytes (BytesToBits (split bits)) == split bits\n\n    B2BExampleWorks = BitsToBytes 0b11010001 == [139]\n\n    property roundingWorks y = y >= 0 ==> roundUpWorks && roundDownWorks where\n        y' = fromInteger y\n        roundUpWorks = roundAway (y' + 0.5) == (y + 1)\n        roundDownWorks = roundAway (y' + 0.4) == y\n\n    \/**\n     * Compress an integer mod `q` into an integer mod `2^d`.\n     * [FIPS-203] Section 4.2.1, Equation 4.7.\n     *\/\n    Compress : {d} (d < width q) => Z q -> [d]\n    Compress x = y where\n        \/\/ Convert from an integer mod `q` to a rational number.\n        x' = fromInteger (fromZ x) : Rational\n                y' = roundAway (((2^^`d) \/. `q) * x')\n                y = (fromInteger y') : [d]\n\n    \/**\n     * Decompress an integer mod `2^d` into an integer mod `q`.\n     * [FIPS-203] Section 4.2.1, Equation 4.8.\n     *\/\n    Decompress : {d} (d < width q) => [d] -> Z q\n    Decompress y = x where\n        \/\/ Convert from a d-length bit vector to a rational number.\n        y' = fromInteger (toInteger y) : Rational\n                x' = roundAway((`q \/. (2^^`d)) * y')\n                x = (fromInteger x') : Z q\n\n    \/**\n     * Compression inverts decompression for all inputs and bit lengths.\n     * We'll prove it for the bit lengths found in the\n     * ```repl\n     * :prove CompressInvertsDecompress`{1}\n     * :exhaust CompressInvertsDecompress`{d_u}\n     * :exhaust CompressInvertsDecompress`{d_v}\n     * ```\n     *\/\n    CompressInvertsDecompress : {d} (d < width q) => [d] -> Bit\n    property CompressInvertsDecompress y = Compress (Decompress y) == y\n\n    DecompressMostlyInvertsCompress : Z q -> Bit\n    property DecompressMostlyInvertsCompress x = errIsSmallEnough where\n        x' = Decompress`{d_u} (Compress`{d_u} x)\n        err = abs (modpm (x' - x))\n        errIsSmallEnough = err <= B_q`{d_u}\n\n                        B_q : {d} (d < lg2 q) => Integer\n        B_q = roundAway((`q\/.(2^^(`d+1))))\n\n                        modpm : Z q -> Integer\n        modpm r = if r' > (`q \/ 2) then r' - `q else r'\n            where r' = fromZ r\n\n    Compress_Vec : {d} (d < lg2 q) => [n](Z q) -> [n][d]\n    Compress_Vec x = map Compress`{d} x\n\n    Decompress_Vec : {d} (d < lg2 q) => [n][d] -> [n](Z q)\n    Decompress_Vec x = map Decompress`{d} x\n\n    Compress_Mat : {d, k1} (d < lg2 q, fin k1) => [k1][n](Z q) -> [k1][n][d]\n    Compress_Mat x = map Compress_Vec`{d} x\n\n    Decompress_Mat : {d, k1} (d < lg2 q, fin k1) => [k1][n][d] -> [k1][n](Z q)\n    Decompress_Mat x = map Decompress_Vec`{d} x\n\n    ByteEncode : {d} (1 <= d, d < 12) => [256][d] -> [32 * d]Byte\n    ByteEncode F = B where\n                                                as = [[ a >> j | j <- [0..d-1]] | a <- F]\n                        b = join [ [ a ! 0 | a <- ajs] | ajs <- as]\n                B = BitsToBytes b\n\n    ByteEncode_Vec : {d} (fin d, 1 <= d, d < 12) => [k][256][d] -> [k * 32 * d]Byte\n    ByteEncode_Vec F_vec = join (map ByteEncode F_vec)\n\n    ByteEncode12 : [256](Z q) -> [32 * 12]Byte\n    ByteEncode12 F = B where\n        type d = 12\n\n                        toBitVec : Z q -> [d]\n        toBitVec f = fromInteger (fromZ f)\n        F' = map toBitVec F\n\n        \/\/ The following is the same as in `ByteEncode`. See notes above.\n        as = [[ a >> j | j <- [0..d-1]] | a <- F' ]\n        b = join [ [ a ! 0 | a <- ajs] | ajs <- as]\n        B = BitsToBytes b\n\n    ByteEncode12_Vec : [k][256](Z q) -> [k * 32 * 12]Byte\n    ByteEncode12_Vec F_vec = join (map ByteEncode12 F_vec)\n\n    subAndDivIsShiftR : {d} (fin d, d > 1) => [d] -> Bit\n    property subAndDivIsShiftR a = take (sad a) == shift a where\n                sad x = [x] # sad ((x - (x % 2)) \/ 2)\n        shift x = [x >> i | i <- [0..d-1]]\n\n    mod2IsFinalBit : {d} (fin d, d > 1) => [d] -> Bit\n    property mod2IsFinalBit a = a % 2 == zext [a ! 0]\n\n    ByteDecode : {d} (1 <= d, d < 12) => [32 * d]Byte -> [256][d]\n    ByteDecode B = F where\n                b = BytesToBits B\n                                                                                F = [ sum [ (zext [bidj]) << j\n                | bidj <- bid\n                | j <- [0..d-1]]\n            | bid <- split`{256} b]\n\n    ByteDecode_Vec : {d} (1 <= d, d < 12) => [k * 32 * d]Byte -> [k][256][d]\n    ByteDecode_Vec B_vec = map ByteDecode (split B_vec)\n\n    ByteDecode12 : [32 * 12]Byte -> [256](Z q)\n    ByteDecode12 B = F' where\n        type d = 12\n        \/\/ These steps are the same as in `ByteDecode`. See that function for\n        \/\/ notes.\n        b = BytesToBits B\n        F = [ sum [ (zext`{d} [bidj]) << j\n                | bidj <- bid\n                | j <- [0..d-1]]\n            | bid <- split`{256} b]\n\n        \/\/ In this case, since `m = q` (and not `2^12`), we need to explicitly\n        \/\/ convert each integer from a 12-bit array to an integer mod `q`.\n        toZq f = fromInteger (toInteger f)\n        F' = map toZq F\n\n    ByteDecode12_Vec : [k * 32 * 12]Byte -> [k][256](Z q)\n    ByteDecode12_Vec B = map ByteDecode12 (split B)\n\n    mul2jIsShiftL : {d} (fin d, 1 < d) => [d] -> Bit\n    property mul2jIsShiftL b = and [( b * (2^^j)) == (b << j) | j <- [0..d-1]]\n\n    ByteEncodeInvertsByteDecode : {d} (fin d, 1 <= d, d < 12) => [256][d] -> Bit\n    property ByteEncodeInvertsByteDecode bits =\n        decode_encode_works && encode_decode_works where\n        decode_encode_works = ByteDecode (ByteEncode bits) == bits\n                bytes = split (join bits)\n        encode_decode_works = ByteEncode (ByteDecode bytes) == bytes\n\n    ByteDecode12InvertsByteEncode12 : [256](Z q) -> Bit\n    ByteDecode12InvertsByteEncode12 bits =\n        ByteDecode12 (ByteEncode12 bits) == bits\n\n    SampleNTT : [34]Byte -> Tq\n    SampleNTT B = a_hat' where\n        \/\/ Steps 1-2, 5.\n        \/\/ We (lazily) take an infinite stream from the XOF and remove only as\n        \/\/ many bytes as are needed to compute the function. See [FIPS-203]\n        \/\/ Section 4.1 Equation 4.6 for a discussion of the equivalence of this\n        \/\/ form to the one in Algorithm 7.\n        ctx0 = XOF B\n\n        \/\/ Step 3. Since Cryptol is not imperative, we implement this loop using\n        \/\/ recursion. The `j` counter is not made explicit; instead we lazily\n        \/\/ generate an infinite stream of coefficients in `T_q` and `take` the\n        \/\/ correct length in the next line.\n\n        \/\/ Step 4-16. `take` fulfills the `j < 256` condition in Steps 4 and 12.\n        a_hat = take`{256} (filter ctx0)\n\n        \/\/ `filter` parses an infinite stream from the XOF, computing\n        \/\/ potential elements `d1` and `d2` from the first 3 bytes in the stream\n        \/\/ and adding them to the output if they are valid elements in `Z q`.\n        filter: [inf]Byte -> [inf][12]\n        filter XOFSqueeze = a_hat_j where\n            \/\/ Step 5.\n            (C # ctx) = XOFSqueeze\n\n            \/\/ The conversion from 8-bit to 12-bit vectors (with the same\n            \/\/ value!) is implicit in the spec -- see notes on Step 5 and 6\/7.\n            \/\/ In Cryptol, we need to convert manually to do the subsequent\n            \/\/ computations.\n            [C0, C1, C2] = map zext`{12} C\n\n            \/\/ Step 6.\n            d1 = C0 + 256 * (C1 % 16)\n\n            \/\/ Step 7. Cryptol uses integer division; it always takes the floor\n            \/\/ of the result.\n            d2 = (C1 \/ 16) + 16 * C2\n\n            \/\/ Steps 4, 8 - 15.\n            \/\/ Add `d1` and\/or `d2` to the sampled vector `a_hat` if they are\n            \/\/ valid elements in `Z q`.\n            \/\/ The `while` loop in Step 4 is equivalent to the recursive call to\n            \/\/ `filter` in each condition.\n            a_hat_j = if (d1 < `q) && (d2 < `q) then\n                    [d1, d2] # filter ctx\n                else if d1 < `q then\n                    [d1] # filter ctx\n                else if d2 < `q then\n                    [d2] # filter ctx\n                else filter ctx\n\n        \/\/ This conversion is implicit in the implementation -- see the notes on\n        \/\/ Step 6\/7 and 9.\n        toZq : [12] -> Z q\n        toZq x = fromInteger (toInteger x)\n\n        a_hat' = map toZq a_hat\n\n    SamplePolyCBD: {eta} (2 <= eta, eta <= 3) => [64 * eta]Byte -> Rq\n    SamplePolyCBD B = f where\n                b = BytesToBits B\n                        BitToZ : Bit -> Z q\n        BitToZ bit = if bit then 1 else 0\n        b' = map BitToZ b\n\n        \/\/ Step 3.\n        x i = sum [b'@(2 * i * `eta + j) | j <- [0 .. (eta-1)]]\n                y i = sum [b'@(2 * i * `eta + `eta + j) | j <- [0 .. (eta-1)]]\n\n        \/\/ Steps 2, 5. The `mod q` is not explicit here because `x` and `y`\n        \/\/ return elements of `Z q`.\n        f = [(x i) - (y i) | i <- [0 .. 255]]\n\n    \/**\n     * [FIPS-203] Section 4.3 \"The mathematical structure of the NTT.\"\n     * ```repl\n     * :prove QisCorrectlyDefined\n     * ```\n     *\/\n    QisCorrectlyDefined: Bit\n    property QisCorrectlyDefined = `q == 2^^8 * 13 + 1\n\n    \/**\n     * `zeta` is a primitive 256-th root of unity modulo `q`.\n     * [FIPS-203] Section 4.3 \"The mathematical structure of the NTT.\"\n     *\n     * ```repl\n     * :prove zetaIsPrimitiveRoot\n     * ```\n     *\/\n    property zetaIsPrimitiveRoot = zeta ^^ 128 == -1\n\n    \/**\n     * Proves that `zeta` is correctly set to be the 256th root of `q`.\n     * ```repl\n     * :exhaust Is256thRootOfq\n     * ```\n     *\/\n    Is256thRootOfq : [lg2 q] -> Bit\n    property Is256thRootOfq p = (p == 0) || (p >= 256) || (zeta^^p != 1)\n\n    \/**\n     * Reverse the unsigned 7-bit value corresponding to an input integer in\n     * `[0, ..., 127]`.\n     * [FIPS-203] Section 4.3 \"The mathematical structure of the NTT.\"\n     *\n     * This diverges from the spec by operating over an 8-bit vector;\n     * this is to ease prior and subsequent computations that would overflow a\n     * 7-bit vector, like:\n     * - `2 * (BitRev7 i) + 1`\n     * - `2 * i + 1`\n     *\n     * A \"pure\" implementation of `BitRev7` in Cryptol is the `reverse` function\n     * on 7-bit vectors. This mini-property shows equivalence:\n     * ```repl\n     * :prove \\(x:[7]) -> ([0] # reverse x) == BitRev7 ([0] # x)\n     * ```\n     *\/\n    BitRev7 : [8] -> [8]\n    BitRev7 i = if i > 255 then error \"BitRev7 called with invalid input\"\n        else (reverse i) >> 1\n\n\/**\n * This section specifies the number-theoretic transform (NTT).\n *\n * It includes the version from [FIPS-203] Section 4.3 as well\n * as a faster O(N log N) version, and a proof of their equivalence.\n *\n * This is explicitly allowed by the spec: \"For every computational procedure\n * [...] a conforming implementation may replace the given set of steps with\n * any mathematically equivalent set of steps\". The equivalence properties\n * prove mathematical equivalence.\n * [FIPS-203] Introduction, \"7. Implementations\".\n *\/\nimport submodule NTT\nsubmodule NTT where\n    private\n        \/**\n         * Number theoretic transform: compute the \"NTT representation\" in\n         * `T_q` of a polynomial in `R_q`.\n         *\n         * [FIPS-203] Section 4.3, Algorithm 9.\n         *\/\n        NaiveNTT : Rq -> Tq\n        NaiveNTT f = join [[f2i i, f2iPlus1 i] | i <- [0 .. 127]] where\n            f2i i = sum [f @(2*j) * zeta_term i j | j <- [0 .. 127]]\n            f2iPlus1 i = sum [f @(2*j+1) * zeta_term i j | j <- [0 .. 127]]\n            zeta_term i j = zeta ^^ ((2 * BitRev7 i + 1) * j)\n\n        \/**\n         * Inverse of the number theoretic transform: converts from the \"NTT\n         * representation\" in `T_q` to a polynomial in `R_q`.\n         *\n         * [FIPS-203] Section 4.3, Algorithm 10.\n         *\/\n        NaiveNTTInv : Tq -> Rq\n        NaiveNTTInv f_hat = [f_i * 3303 | f_i <- f] where\n            f = join [[f2i i, f2iPlus1 i] | i <- [0 .. 127]]\n            f2i i = sum [f_hat @(2*j) * zeta_term i j | j <- [0 .. 127]]\n            f2iPlus1 i = sum [f_hat @(2*j+1) * zeta_term i j | j <- [0 .. 127]]\n            zeta_term i j = (recip zeta) ^^ ((2 * BitRev7 j + 1) * i)\n\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/ This section specifies fast O(N log N) NTT and Inverse NTT\n        \/\/\n        \/\/ A readable explanation of the derivation of this form of\n        \/\/ the NTT is in \"A Complete Beginner Guide to the Number\n        \/\/ Theoretic Transform (NTT)\" by Ardianto Satriawan,\n        \/\/ Rella Mareta, and Hanho Lee. Available from:\n        \/\/    https:\/\/eprint.iacr.org\/2024\/585\n        \/\/\n        \/\/ This section Copyright Amazon.com, Inc. or its affiliates.\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n        \/**\n         * Lookup table for `zeta` values computed in `NTT` and `NTTInv`.\n         *\n         * [FIPS-203] Appendix A.\n         *\/\n        zeta_expc  : [128](Z q)\n        zeta_expc = [\n            1, 1729, 2580, 3289, 2642, 630, 1897, 848,\n            1062, 1919, 193, 797, 2786, 3260, 569, 1746,\n            296, 2447, 1339, 1476, 3046, 56, 2240, 1333,\n            1426, 2094, 535, 2882, 2393, 2879, 1974, 821,\n            289, 331, 3253, 1756, 1197, 2304, 2277, 2055,\n            650, 1977, 2513, 632, 2865, 33, 1320, 1915,\n            2319, 1435, 807, 452, 1438, 2868, 1534, 2402,\n            2647, 2617, 1481, 648, 2474, 3110, 1227, 910,\n            17, 2761, 583, 2649, 1637, 723, 2288, 1100,\n            1409, 2662, 3281, 233, 756, 2156, 3015, 3050,\n            1703, 1651, 2789, 1789, 1847, 952, 1461, 2687,\n            939, 2308, 2437, 2388, 733, 2337, 268, 641,\n            1584, 2298, 2037, 3220, 375, 2549, 2090, 1645,\n            1063, 319, 2773, 757, 2099, 561, 2466, 2594,\n            2804, 1092, 403, 1026, 1143, 2150, 2775, 886,\n            1722, 1212, 1874, 1029, 2110, 2935, 885, 2154\n        ]\n\n        \/\/ Top level entry point - start with lv=256, k=1\n        fast_ntt : Rq -> Tq\n        fast_ntt v = fast_nttl v 1\n\n        \/\/ Recursive NTT function\n        fast_nttl :\n            {lv}  \/\/ Length of v is a member of {256,128,64,32,16,8,4}\n            (lv >= 2, lv <= 8) =>\n            [2^^lv](Z q) -> [8] -> [2^^lv](Z q)\n        fast_nttl v k\n            \/\/ Base case. lv==2 so just compute the butterfly and return\n            | lv == 2 => ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n\n            \/\/ Recursive case. Butterfly what we have, then recurse on each half,\n            \/\/ concatenate the results and return.\n            | lv  > 2 => (fast_nttl`{lv-1} s0 (k * 2)) #\n                    (fast_nttl`{lv-1} s1 (k * 2 + 1))\n                        where\n                        t = ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n                        \/\/ Split t into two halves s0 and s1\n                        [s0, s1] = split t\n\n        \/\/ Fast recursive CT-NTT\n        ct_butterfly :\n            {m, hm}\n            (m >= 2, m <= 8, hm >= 1, hm <= 7, hm == m - 1) =>\n            [2^^m](Z q) -> (Z q) -> [2^^m](Z q)\n        ct_butterfly v z = new_v where\n            halflen = 2^^`hm\n            lower, upper : [2^^hm](Z q)\n            lower@x = v@x + z * v@(x + halflen)\n            upper@x = v@x - z * v@(x + halflen)\n            new_v = lower # upper\n\n        \/\/ Recursive inverse-NTT function\n        fast_invnttl :\n            {lv}  \/\/ Length of v is a member of {256,128,64,32,16,8,4}\n            (lv >= 2, lv <= 8) =>\n            [2^^lv](Z q) -> [8] -> [2^^lv](Z q)\n        fast_invnttl v k\n            \/\/ Base case. lv==2 so just compute the butterfly and return\n            | lv == 2 => gs_butterfly`{lv,lv-1} v (zeta_expc@k)\n\n            \/\/ Recursive case. Recurse on each half,\n            \/\/ concatenate the results, butterfly that, and return.\n            | lv  > 2 => gs_butterfly`{lv,lv-1} t (zeta_expc@k) where\n                \/\/ Split t into two halves s0 and s1\n                [s0, s1] = split v\n                t = (fast_invnttl`{lv-1} s0 (k * 2 + 1)) #\n                    (fast_invnttl`{lv-1} s1 (k * 2))\n\n        \/\/ Fast recursive GS-Inverse-NTT\n        gs_butterfly :\n            {m, hm}\n            (m >= 2, m <= 8, hm >= 1, hm <= 7, hm == m - 1) =>\n            [2^^m](Z q) -> (Z q) -> [2^^m](Z q)\n        gs_butterfly v z = new_v where\n            halflen = 2^^`hm\n            lower, upper : [2^^hm](Z q)\n            lower@x = v@x  + v@(x + halflen)\n            upper@x = z * (v@(x + halflen) - v@x)\n            new_v = lower # upper\n\n        \/\/ Top level entry point - start with lv=256, k=1\n        fast_invntt : Tq -> Rq\n        fast_invntt v = mul_recip128 (fast_invnttl v 1) where\n\n            \/\/ Multiplicative inverse of 128, mod `q`.\n            recip_128_modq = (recip 128) : (Z q)\n\n            \/\/ Multiply all elements of v' by the reciprocal of 128 (modulo q)\n            mul_recip128 : Tq -> Tq\n            mul_recip128 v' = [ v'@x * recip_128_modq | x <- [0 .. <n] ]\n\n        NaiveNTT_Inverts : Rq -> Bit\n        property NaiveNTT_Inverts f =  NaiveNTTInv (NaiveNTT f) == f\n\n        NaiveNTTInv_Inverts : Tq -> Bit\n        property NaiveNTTInv_Inverts f =  NaiveNTT (NaiveNTTInv f) == f\n\n        fast_ntt_inverts : Rq -> Bit\n        property fast_ntt_inverts    f =  fast_invntt (fast_ntt f)    == f\n\n        fast_invntt_inverts : Tq -> Bit\n        property fast_invntt_inverts f =  fast_ntt    (fast_invntt f) == f\n\n        naive_fast_ntt_equiv : Rq -> Bit\n        property naive_fast_ntt_equiv f =  NaiveNTT f == fast_ntt f\n\n        naive_fast_invntt_equiv : Tq -> Bit\n        property naive_fast_invntt_equiv f =  NaiveNTTInv f == fast_invntt f\n\n    NTT : Rq -> Tq\n    NTT = fast_ntt\n\n    NTTInv : Tq -> Rq\n    NTTInv = fast_invntt\n\n    NTT_Vec v = map NTT v\n\n    NTTInv_Vec v = map NTTInv v\n\n    BaseCaseMultiply : (Z q) -> (Z q) -> (Z q) -> (Z q) -> (Z q) -> [2](Z q)\n    BaseCaseMultiply a0 a1 b0 b1 \u03b3 = [c0, c1]\n      where\n        c0 = a0 * b0 + a1 * b1 * \u03b3\n        c1 = a0 * b1 + a1 * b0\n\n    MultiplyNTTs : Tq -> Tq -> Tq\n    MultiplyNTTs f_hat g_hat = join h_hat where\n        h_hat = [ BaseCaseMultiply\n            (f_hat @(2*i))\n            (f_hat @(2*i+1))\n            (g_hat @(2*i))\n            (g_hat @(2*i+1))\n            (zeta ^^(2 * BitRev7 i + 1))\n        | i <- [0 .. 127] ]\n\n    TestMult : Bit\n    property TestMult = prod f f == fsq where\n      f = [1, 1] # [0 | i <- [3 .. 256]]\n      fsq = [1,2,1] # [0 | i <- [4 .. 256]]\n\n      prod : Rq -> Rq -> Rq\n      prod a b = NTTInv (MultiplyNTTs (NTT a) (NTT b))\n\n    (\u00d7) = MultiplyNTTs\n\n    dotVecVec : {k1} (fin k1) => [k1]Tq -> [k1]Tq -> Tq\n    dotVecVec v1 v2 = sum (zipWith (\u00d7) v1 v2)\n\n    dotMatVec : {k1,k2} (fin k1, fin k2) => [k1][k2]Tq -> [k2]Tq -> [k1]Tq\n    dotMatVec matrix vector = [dotVecVec v1 vector | v1 <- matrix]\n\n    dotMatMat :{k1,k2,k3} (fin k1, fin k2, fin k3) =>\n        [k1][k2]Tq -> [k2][k3]Tq -> [k1][k3]Tq\n    dotMatMat matrix1 matrix2 = transpose [dotMatVec matrix1 vector | vector <- m']\n        where m' = transpose matrix2\n\nprivate submodule K_PKE where\n            type EncryptionKey = [384 * k + 32]Byte\n\n            type DecryptionKey = [384 * k]Byte\n\n            type Ciphertext = [32 * (d_u * k + d_v)]Byte\n\n    KeyGen: [32]Byte -> (EncryptionKey, DecryptionKey)\n    KeyGen d = (ekPKE, dkPKE) where\n                (\u03c1, \u03c3) = G (d # [`(k)])\n                A_hat = [[ SampleNTT (\u03c1 # [j] # [i])\n            | j <- [0 .. k-1]]\n            | i <- [0 .. k-1]]\n                s = [SamplePolyCBD`{eta_1} (PRF \u03c3 N)\n            | N <- [0 .. k-1]]\n                e = [SamplePolyCBD`{eta_1} (PRF \u03c3 N)\n            | N <- [k .. 2 * k - 1]]\n                s_hat = NTT_Vec s\n                e_hat = NTT_Vec e\n                t_hat = (dotMatVec A_hat s_hat) + e_hat\n                ekPKE = (ByteEncode12_Vec t_hat) # \u03c1\n                dkPKE = ByteEncode12_Vec s_hat\n\n    Encrypt : EncryptionKey -> [32]Byte -> [32]Byte -> Ciphertext\n    Encrypt ekPKE m r = c where\n                t_hat = ByteDecode12_Vec (ekPKE @@[0 .. 384*k - 1])\n                rho = ekPKE @@[384*k .. 384*k + 32 - 1]\n                A_hat = [[ SampleNTT (rho # [j] # [i])\n            | j <- [0 .. k-1]]\n            | i <- [0 .. k-1]]\n                y = [SamplePolyCBD`{eta_1} (PRF r N)\n            | N <- [0 .. k-1]]\n                e1 = [SamplePolyCBD`{eta_2} (PRF r N)\n            | N <- [k .. 2 * k - 1]]\n                                e2 = SamplePolyCBD`{eta_2} (PRF r (2 * `k))\n                y_hat = NTT_Vec y\n                u = NTTInv_Vec (dotMatVec (transpose A_hat) y_hat) + e1\n                mu = Decompress_Vec`{1} (ByteDecode`{1} m)\n                v = (NTTInv (dotVecVec t_hat y_hat)) + e2 + mu\n                c1 = ByteEncode_Vec`{d_u} (Compress_Mat`{d_u} u)\n                c2 = ByteEncode`{d_v} (Compress_Vec`{d_v} v)\n                c = c1 # c2\n\n    Decrypt : DecryptionKey -> Ciphertext -> [32]Byte\n    Decrypt dkPKE c = m where\n                c1 = c @@[0 .. 32 * d_u * k - 1]\n                c2 = c @@[32 * d_u * k .. 32 * (d_u * k + d_v) - 1]\n                u' = Decompress_Mat`{d_u} (ByteDecode_Vec`{d_u} c1)\n        \/\/ Step 4.\n        v' = Decompress_Vec`{d_v} (ByteDecode`{d_v} c2)\n                s_hat = ByteDecode12_Vec dkPKE\n                w = v' - NTTInv (dotVecVec s_hat (NTT_Vec u'))\n                m = ByteEncode`{1} (Compress_Vec`{1} w)\n\n    CorrectnessPKE : [32]Byte -> [32]Byte -> [32]Byte -> Bit\n    property CorrectnessPKE d m r = (m' == m) where\n        (pk, sk) = KeyGen d\n        c = Encrypt pk m r\n        m' = Decrypt sk c\n\nprivate\n\n    KeyGen_internal : [32]Byte -> [32]Byte\n        -> (EncapsulationKey, DecapsulationKey)\n    KeyGen_internal d z = (ek, dk) where\n      (ekPKE, dkPKE) = K_PKE::KeyGen d\n      ek = ekPKE\n      dk = dkPKE # ek # (H ek) # z\n\n    Encaps_internal : EncapsulationKey -> [32]Byte\n        -> (SharedSecretKey, Ciphertext)\n    Encaps_internal ek m = (K, c) where\n      (K, r) = G (m # (H ek))\n      c = K_PKE::Encrypt ek m r\n\n    Decaps_internal : DecapsulationKey -> Ciphertext -> SharedSecretKey\n    Decaps_internal dk c = K where\n                dkPKE = dk @@ [0 .. 384*k - 1]\n                ekPKE = dk @@ [384*k .. 768*k + 32 - 1]\n                h = dk @@ [768*k + 32 .. 768*k + 64 - 1]\n                z = dk @@ [768*k + 64 .. 768*k + 96 - 1]\n                m' = K_PKE::Decrypt dkPKE c\n        \/\/ Step 6.\n        (K', r') = G (m' # h)\n                Kbar = J (z # c)\n                c' = K_PKE::Encrypt ekPKE m' r'\n        \/\/ Step 9 - 11. If ciphertextx do not match, \"implicitly reject\".\n        K = if (c != c') then\n                Kbar\n            else\n                K'\n\n    \/**\n     * The ML-KEM scheme is correct with probability 1-delta and not 1. As a\n     * result, running `:prove CorrectnessPKE` will not succeed since there is a\n     * fraction delta of seeds `d`, `z`, `m` that do not work.\n     * Cryptol does not currently support counting.\n     * ```repl\n     * :set tests=3\n     * :check CorrectnessKEM\n     * ```\n     *\/\n    CorrectnessKEM : [32]Byte -> [32]Byte -> [32]Byte -> Bit\n    property CorrectnessKEM z d m = (K == K') where\n        (ek, dk) = KeyGen_internal d z\n        (K, c) = Encaps_internal ek m\n        K' = Decaps_internal dk c\n\n\/*\n * Type of an encapsulation key used in the public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 19.\n * See also the paragraph \"Terminology for keys\" in Section 3.2.\n *\/\ntype EncapsulationKey = [384 * k + 32]Byte\n\n\/*\n * Type of an decapsulation key used in the public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 19.\n * See also the paragraph \"Terminology for keys\" in Section 3.2.\n *\/\ntype DecapsulationKey = [768 * k + 96]Byte\n\n\/*\n * Type of the shared secret key material generated by the public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 20.\n * See also the paragraph \"Terminology for keys\" in Section 3.2.\n *\/\ntype SharedSecretKey = [32]Byte\n\n\/*\n * Type of the ciphertext generated by teh public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 20.\n *\n * Usage: This ciphertext is only used in the context of ML-KEM, to derive a\n * shared secret key.\n *\/\ntype Ciphertext = [32 * (d_u * k + d_v)]Byte\n\n\/**\n * Generate an encapsulation key and a corresponding decapsulation key.\n * [FIPS-203] Section 7.1, Algorithm 19.\n *\n * This differs from the spec: it takes the randomness `d` and `z` as\n * parameters instead of generating them internally (because Cryptol\n * cannot generate randomness).\n *\n * The decapsulation key produced from this function MUST remain private. The\n * seed `(d, z)` produced (or in this case, passed as input) is sensitive data\n * and MUST be treated with the same safeguards as the decapsulation key.\n *\/\nKeyGen : Option ([32]Byte) -> Option ([32]Byte)\n    -> (EncapsulationKey, DecapsulationKey)\nKeyGen d z = (ek, dk) where\n    \/\/ Steps 1 and 2 are skipped because Cryptol cannot generate randomness.\n    \/\/ Step 3 - 5.\n    d' = case d of\n        None -> error \"Random bit generation failed; `d` not initialized.\"\n        Some _d -> _d\n    z' = case z of\n        None -> error \"Random bit generation failed; `z` not initialized.\"\n        Some _z -> _z\n    \/\/ Step 6.\n    (ek, dk) = KeyGen_internal d' z'\n\n\/**\n * Perform checks on a key pair.\n *\n * The security of ML-KEM depends on the use of key pairs that were correctly\n * generated using `KeyGen`!\n * This checking process _does not_ guarantee that the input pair is a properly\n * produced output of `KeyGen`. While these checks can detect certain\n * corruptions, they do not guarantee that the key pair was properly generated.\n *\/\nkeyPairCheck : EncapsulationKey\n    -> DecapsulationKey\n    -> Option ([32]Byte, [32]Byte)\n    -> [32]Byte\n    -> Bit\nkeyPairCheck ek dk maybe_seed m =\n    seedConsistency && encapsCheck && decapsCheck && pairwiseConsistency where\n    seedConsistency = case maybe_seed of\n        Some (d, z) -> KeyGen_internal d z == (ek, dk)\n        None -> True\n\n    encapsCheck = encapsulationKeyCheck ek\n    decapsCheck = decapsulationKeyCheck dk\n\n    pairwiseConsistency = K == K'\n    (K, c) = Encaps_internal ek m\n    K' = Decaps_internal dk c\n\n\/**\n * A properly produced output of the `KeyGen` function should always pass the\n * key pair checks.\n * ```repl\n * :set tests=3\n * :check KeyGenProducesValidKeys\n * ```\n *\/\nKeyGenProducesValidKeys d z m = keyPairCheck ek dk (Some (d, z)) m where\n    (ek, dk) = KeyGen (Some d) (Some z)\n\n\/**\n * Perform checks on a candidate encapsulation key.\n *\n * The type check is implicit; if this function compiles with a given `ek`,\n * then it must be of the correct type.\n *\n * This checking process _does not_ gurantee that `ek` is a properly produced\n * output of `KeyGen`.\n *\/\nencapsulationKeyCheck : EncapsulationKey -> Bool\nencapsulationKeyCheck ek = modulusCheck where\n    test = ByteEncode12_Vec (ByteDecode12_Vec (ek @@ [0..384 * k - 1]))\n    modulusCheck = test == (ek @@ [0..384 * k - 1])\n\n\/**\n * Use the encapsulation key to generate a shared secret an an associated\n * ciphertext.\n * [FIPS-203] Section 7.2, Algorithm 20.\n *\n * This differs from the spec: it takes the randomness `m` as a parameter\n * instead of generating it internally (because Cryptol cannot generate\n * randomness).\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f\n * The encapsulation key passed as a parameter MUST be checked before use with\n * `encapsulationKeyCheck`! The caller must have assurance that the\n * encapsulation key is valid.\n * This executable spec (and Cryptol in general) cannot enforce this\n * requirement! Implementors must check it manually.\n *\/\nEncaps : EncapsulationKey -> Option ([32]Byte) -> (SharedSecretKey, Ciphertext)\nEncaps ek m = (K, c) where\n    \/\/ Step 1 is skipped because Cryptol cannot generate randomness.\n    \/\/ Step 2 - 4.\n    m' = case m of\n        None -> error \"Random bit generation failed; `m` not initialized.\"\n        Some _m -> _m\n        (K, c) = Encaps_internal ek m'\n\n\/**\n * Perform three checks on candidate inputs to decapsulation.\n * [FIPS-203] Section 7.3 \"Decapsulation input check\" #1-3.\n *\n * The type checks are implicit; if this function compiles with a given `dk`\n * and `c`, then they must be of the correct type.\n *\n * This check _does not_ guarantee that `dk` is a propertly produced output\n * of `KeyGen`, or that `c` is a properly produced output of `Encaps`!\n *\/\ndecapsulationInputCheck : DecapsulationKey -> Ciphertext -> Bool\ndecapsulationInputCheck dk c = decapsulationKeyCheck dk\n\nprivate\n    \/**\n     * Perform a type check and a hash check on a candidate decapsulation key.\n     * [FIPS-203] Section 7.3 \"Decapsulation input check\" #2-3.\n     *\n     * The type check is implicit; if this function compiles with a given `dk`,\n     * then it must be the correct type.\n     *\n     * This check _does not_ guarantee that `dk` is a propertly produced output\n     * of `KeyGen`!\n     *\/\n    decapsulationKeyCheck : DecapsulationKey -> Bool\n    decapsulationKeyCheck dk = hash_check where\n        test = H (dk @@ [384*k .. 768*k + 32 - 1])\n        hash_check = test == (dk @@ [768*k + 32 .. 768*k + 64 - 1])\n\n\/**\n * Use the decapsulation key to produce a shared secret from a ciphertext.\n * [FIPS-203] Section 7.3, Algorithm 21.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f\n * The decapsulation key and the ciphertext MUST be checked before use with\n * `decapsulationInputCheck`! The caller must have assurance that the\n * decapsulation key and ciphertext are valid.\n * This executable spec (and Cryptol in general) cannot enforce this\n * requirement! Implementors must check it manually.\n *\/\nDecaps : DecapsulationKey -> Ciphertext -> SharedSecretKey\nDecaps = Decaps_internal\n\nparameter\n    \/*\n     * The parameter `k` determines the dimensions of the encryption key matrix\n     * and the secret and noise vectors created and used in key generation and\n     * encryption.\n     * [FIPS-203] Section 8.\n     *\n     * The constraint on the width of `k` is drawn from `K-PKE-KeyGen`. In\n     * that function, the variable `N` varies from 0 to `2k` and is passed as\n     * the second parameter to the `PRF` function. `PRF` restricts the second\n     * parameter to be exactly 1 byte. Therefore, `2k` must fit into a byte.\n     * [FIPS-203] Section 5.1 Algorithm 13 (see lines 2 and 8-15) and Section\n     * 4.1 Equation 4.2.\n     *\/\n    type k : #\n    type constraint (width k > 0, width (2*k) <= 8)\n\n    \/*\n     * The parameter `eta_1` specifies the distribution from which the secret\n     * vectors are drawn in key generation and encryption.\n     * [FIPS-203] Section 8.\n     *\n     * eta_1 must be in the set {2, 3} for use in a PRF and to parameterize\n     * sampling from the centered binomial distribution.\n     * [FIPS-203] Section 4.1 \"Pseudorandom Function\" and Section 4.2.2\n     * \"Sampling from the centered binomial distribution\"\n     *\/\n    type eta_1 : #\n    type constraint (fin eta_1, 2 <= eta_1, eta_1 <= 3)\n\n    \/*\n     * The parameter eta_2 is required to specify the distribution from which\n     * the noise vectors are drawn in encryption.\n     * [FIPS-203] Section 8.\n     *\n     * eta_2 must be in the set {2, 3} for use in a PRF and to parameterize\n     * sampling from the centered binomial distribution.\n     * [FIPS-203] Section 4.1 \"Pseudorandom Function\" and Section 4.2.2\n     * \"Sampling from the centered binomial distribution\"\n     *\/\n    type eta_2 : #\n    type constraint (fin eta_2, 2 <= eta_2, eta_2 <= 3)\n\n    \/*\n     * The parameter `d_u` is a parameter and input for the compression and\n     * encoding functions.\n     * [FIPS-203] Section 8.\n     *\n     * For compression, `d_u` must be smaller than the bit length of `q` (fixed\n     * to 12).\n     * [FIPS-203] Section 4.2.1 \"Compression and decompression\".\n     * For encoding, the valid range of values for `d_u` is `1 \u2264 d_u \u2264 12`.\n     * [FIPS-203] Section 4.2.1 \"Encoding and decoding\".\n     *\/\n    type d_u : #\n    type constraint (fin d_u, d_u < 12, d_u > 0)\n\n    \/*\n     * The parameter `d_v` is a parameter and input for the compression and\n     * encoding functions.\n     * [FIPS-203] Section 8.\n     *\n     * For compression, `d_v` must be smaller than the bit length of `q` (fixed\n     * to 12).\n     * [FIPS-203] Section 4.2.1 \"Compression and decompression\".\n     * For encoding, the valid range of values for `d_v` is `1 \u2264 d_v \u2264 12`.\n     * [FIPS-203] Section 4.2.1 \"Encoding and decoding\".\n     *\/\n    type d_v : #\n    type constraint (fin d_v, d_v < 12, d_v > 0)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ECDH\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::KEM::ECDH::Specification that contains the following definitions, using an elliptic-curve interface imported as EC (providing the curve order, cofactor, base point, point type, scalar multiplication, point equality, validity and infinity checks, x-coordinate extraction, and width of the order) and a utility to convert integers to bitvectors. Provide: (1) a type alias SigningKey for an integer modulo the curve order; (2) a type alias VerifyingKey for an elliptic-curve point; (3) a function signingKeyValid: SigningKey -> Bool that returns true exactly when the secret scalar is nonzero; (4) a function verifyingKeyPartiallyValid: VerifyingKey -> Bool that returns true for points that are on the curve and not the identity; (5) a function verifyingKeyFullyValid: VerifyingKey -> Bool that returns true when the point is partially valid and has the correct group order (i.e., multiplying it by the curve order yields the identity); (6) a function keyPairIsConsistent: SigningKey -> VerifyingKey -> Bool that returns true when the public key equals the base point multiplied by the secret scalar (convert the modular secret into the scalar domain as required by the interface and use the point equality operation); (7) a function ECC_CDH: SigningKey -> VerifyingKey -> Option [((width EC::n) \/^ 8)][8] that computes the shared ECDH point as the cofactor times the product of the secret scalar and the peer\u2019s public key, then returns None if the x-coordinate is absent, otherwise returns Some of the x-coordinate encoded as bytes by converting to a bitvector and splitting into 8-bit chunks."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::KEM::ECDH::Specification where\n\nimport Common::utils(ZtoBV)\n\nimport interface Common::EC::ECInterface as EC\n\ntype SigningKey = Z EC::n\n\ntype VerifyingKey = EC::Point\n\nsigningKeyValid : SigningKey -> Bool\nsigningKeyValid d = d != 0\n\nverifyingKeyFullyValid : VerifyingKey -> Bool\nverifyingKeyFullyValid Q = verifyingKeyPartiallyValid Q && correctOrder where\n    correctOrder = EC::isInfinity (EC::scmul `EC::n Q)\n\nverifyingKeyPartiallyValid : VerifyingKey -> Bool\nverifyingKeyPartiallyValid Q = EC::isValid Q && ~(EC::isInfinity Q)\n\nkeyPairIsConsistent : SigningKey -> VerifyingKey -> Bool\nkeyPairIsConsistent d Q = EC::pointEq expectedQ Q where\n    expectedQ = EC::scmul (fromZ d) EC::G\n\nECC_CDH : SigningKey -> VerifyingKey -> Option ([(width EC::n) \/^ 8][8])\nECC_CDH dA QB = maybe_Z where\n        P = EC::scmul EC::h (EC::scmul (fromZ dA) QB)\n    maybe_Z = case EC::xCoord P of\n                        None -> None\n                                Some z -> Some (split (ZtoBV z))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Instantiations\/ML_KEM512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM512 that contains the following definitions: k, eta_1, eta_2, d_u, and d_v. The module must be an instantiation of Primitive::Asymmetric::KEM::ML_KEM::Specification, binding its type-level numeric parameters to these exact values: k = 2, eta_1 = 3, eta_2 = 2, d_u = 10, d_v = 4. Declare each as a type synonym representing a numeric type (i.e., type-level naturals), not as value-level constants. Do not introduce any additional functions, properties, or constraints. Ensure the module exports these type parameters as part of the instantiated specification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM512 =\n    Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\ntype k = 2\ntype eta_1 = 3\ntype eta_2 = 2\ntype d_u = 10\ntype d_v = 4\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Instantiations\/ML_KEM1024.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that instantiates an existing KEM specification module and re-exports its definitions while fixing five configuration parameters. Inside this module, declare exactly five top-level type synonyms of kind Nat: one representing the polynomial dimension multiplier, two representing small-noise bounds, and two representing ciphertext\/compression bit-widths. Bind each synonym to the precise numeric values implied by the target instantiation. Do not introduce any new functions or properties; only provide these type synonyms to parameterize the underlying specification. Clearly state that these synonyms are public, that they serve as configuration knobs for the imported specification, and that the module\u2019s body otherwise defers to the imported definitions unchanged. Ensure the synonyms\u2019 kinds and intent are unambiguous and that their bindings match the observed constants."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM1024 =\n    Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\ntype k = 4\ntype eta_1 = 2\ntype eta_2 = 2\ntype d_u = 11\ntype d_v = 5\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Instantiations\/ML_KEM768.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM768 that contains the following definitions: a type-level natural k set to 3, a type-level natural eta_1 set to 2, a type-level natural eta_2 set to 2, a type-level natural d_u set to 10, and a type-level natural d_v set to 4. Make this module an instantiation of the generic ML-KEM specification so that all specification definitions are inherited and specialized to these parameters."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM768 =\n    Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\ntype k = 3\ntype eta_1 = 2\ntype eta_2 = 2\ntype d_u = 10\ntype d_v = 4\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/ECInterface.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an interface module named Common::EC::ECInterface that contains the following declarations only (no implementations): an abstract type Point; a numeric type parameter n with type-level constraints that it is finite, prime, and at least 1; a numeric type parameter q with type-level constraints that it is finite and at least 1; a public integer constant h (the cofactor); a public base point G of type Point; predicates isInfinity (takes a point, returns a boolean indicating the point at infinity), isValid (takes a point, returns a boolean for on-curve validity), and pointEq (takes two points, returns a boolean for equality); group operations add (two points to their sum), sub (two points to their difference), and double (a point to its doubling); scalar multiplication scmul (integer scalar and point to a point); double-scalar multiplication twin_mul (two integers and two points, in the order scalar, point, scalar, point, returning their linear combination); and xCoord (takes a point and returns an optional value representing the x-coordinate as a residue modulo q). Ensure n and q are of numeric kind, constraints are attached at the type level, Option is used for optional results, and Z q is used for residues modulo q. Export all declarations from the interface module."},{"role":"assistant","content":"```cryptol\ninterface module Common::EC::ECInterface where\n\n    type Point : *\n\n    type n : #\n    type constraint (fin n, prime n, n >= 1)\n\n    type q : #\n    type constraint (fin q, q >= 1)\n\n    h : Integer\n\n    G : Point\n\n    isInfinity : Point -> Bool\n\n    isValid : Point -> Bool\n\n    pointEq : Point -> Point -> Bool\n\n    add : Point -> Point -> Point\n\n    sub : Point -> Point -> Point\n\n    double : Point -> Point\n\n    scmul : Integer -> Point -> Point\n\n    twin_mul : Integer -> Point -> Integer -> Point -> Point\n\n    xCoord: Point -> Option (Z q)\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/Curve25519.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Common::EC::Curve25519 that contains the following definitions, types, constraints, and properties, with precise type signatures and no solutions: import the utilities providing bit-vector\/field conversions. Declare type synonyms for the curve prime modulus, the Montgomery curve parameter, the group order, and the base-point u and v coordinates. Provide a Bytes type alias for byte arrays and a Fit constraint ensuring sufficient length and finiteness of parameters. Implement a little-endian byte-array decoder to a field element with polymorphic bit-width and array length under Fit, and include a unit test that decodes a known ASCII sample to a known integer. Implement a u-coordinate decoder that truncates to the needed byte count and masks the high bits of the most significant byte when the bit-width is not a multiple of eight; implement the corresponding encoder to 32 bytes little-endian. State properties: partial round-trip for decode then encode under a precondition on the least-significant bit of the first byte; full round-trip for encode then decode; and a targeted test for a small bit-width. Implement scalar decoding with clamping per the curve specification and verify it against a fixed test case. Provide constant-time conditional swap over two field elements using a mask over their bit-vector representations, plus a branchy variant; include: a boolean function asserting both swaps agree when the selector is 0 or 1, and properties for identity and involution. Implement X25519 using the Montgomery ladder with the standard a24 constant, conditional swaps per bits of the clamped scalar, and field inversion by Fermat\u2019s little theorem; include two official test-vector properties and iterative tests for 1 and 1000 iterations while keeping the million-iteration check as a non-property value. Provide a big-endian adapter and a property relating both variants. Define DH_sender and DH_receiver and a property stating the shared secret matches from both sides. Include a property reconstructing the declared group order from its components."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::Curve25519 where\n\nimport Common::utils(ZtoBV, BVtoZ)\n\ntype p = 2^^255 - 19\n\ntype A = 486662\n\ntype order = 2^^252 + 27742317777372353535851937790883648493\n\nproperty orderOk = `order == order'\n    where\n        i = toInteger 0x14def9dea2f79cd65812631a5cf5d3ed\n        order' = 2^^252 + i\n\ntype Gu = 9\n\ntype Gv = 14781619447589544791020593568409986887264606134616475288964881837755586237401\n\ntype Bytes b = [b \/^ 8][8]\n\ntype constraint Fit b n = (b \/^ 8 <= n, fin b, fin n)\n\ndecodeLittleEndian : {bits, n} (Fit bits n) => [n][8] -> Z p\ndecodeLittleEndian x = fromInteger (sum iterates)\n    where\n        lshft y i = y * 256 ^^ i         iterates = [lshft (toInteger b) i | b <- x | i <- [0..bits \/^ 8]]\n\nproperty decodeTest = decodeLittleEndian `{88} \"hello world\" == x\n    where\n        x = 121404708502361365413651816\n\ndecodeUCoordinate : {bits, n} (Fit bits n, bits >= 1) => [n][8] -> Z p\ndecodeUCoordinate u_list = decodeLittleEndian `{bits} u_list''\n    where\n        mask = (1 << (`bits % 8)) - 1 : [8]\n        type m = bits \/^ 8\n        u_list' = take `{m} u_list\n        l = `m - 1\n        u_list'' = if `bits % 8 != 0\n                then update u_list' l (last u_list' && mask)\n                else u_list'\n\nencodeUCoordinate : {bits, n} (Fit bits n, bits >= 1) => Z p -> [n][8]\nencodeUCoordinate u = reverse (split (ZtoBV u))\n\nencodePartiallyInvertsDecode : [32][8] -> Bit\nproperty encodePartiallyInvertsDecode x = ~((x ! 0) @ 0) ==>\n    encodeUCoordinate `{255} (decodeUCoordinate `{255} x) == x\n\ndecodeInvertsEncode : Z p -> Bit\nproperty decodeInvertsEncode x =\n    decodeUCoordinate `{255} (encodeUCoordinate `{255, 32} x) == x\n\nproperty decodeUCoordinateTest = decodeUCoordinate `{6} \"hello world\" == x\n    where\n        x = 40\n\ndecodeScalar25519 : [32][8] -> Z p\ndecodeScalar25519 k0 = decodeLittleEndian `{255} k3\n    where\n        k1 = update k0 0 ((k0@0) && 248)\n        k2 = update k1 31 ((k1@31) && 127)\n        k3 = update k2 31 ((k2@31) || 64)\n\nproperty decodeScalarOk = decodeScalar25519 (repeat 0x61) == x\n    where\n        x = 44046402572626160612103472728795008085361523578694645928734845681441465000288\n\nX25519 : [32][8] -> [32][8] -> [32][8]\nX25519 kb ub = result\n    where\n                a24 = 121665\n                        k = ZtoBV (decodeScalar25519 kb)\n        u = decodeUCoordinate `{255} ub\n                loop (x1, x2, z2, x3, z3, swap) t = (x1', x2', z2', x3', z3', swap')\n            where\n                k_t = (k >> t) && 1\n                swapt = swap ^ k_t\n                (x2s, x3s) = cswap' swapt (x2, x3)\n                (z2s, z3s) = cswap' swapt (z2, z3)\n                swap' = zext [k_t ! 0]\n\n                A = x2s + z2s\n                AA = A^^2\n                B = x2s - z2s\n                BB = B^^2\n                E = AA - BB\n                C = x3s + z3s\n                D = x3s - z3s\n                DA = D * A\n                CB = C * B\n                x1' = x1\n                x3' = (DA + CB) ^^ 2\n                z3' = x1 * (DA - CB) ^^ 2\n                x2' = AA * BB\n                z2' = E * (AA + a24 * E)\n\n                (x1l, x2l, z2l, x3l, z3l, swapl) = foldl loop (u, 1 : Z p, 0 : Z p, u, 1 : Z p, 0 : [255]) (reverse [0..255-1])\n\n                (x2ls, x3ls) = cswap' swapl (x2l, x3l)\n        (z2ls, z3ls) = cswap' swapl (z2l, z3l)\n\n                rzp = x2ls * (z2ls ^^ `(p - 2))\n\n                result = encodeUCoordinate `{255, 32} rzp\n\ncswap : [255] -> (Z p, Z p) -> (Z p, Z p)\ncswap swap (x, y) = (BVtoZ `{p} (dummy ^ x_2), BVtoZ `{p} (dummy ^ x_3))\n    where\n        mask : [255] -> [255]\n        mask z = 0 - z\n\n        (x_2, x_3) = (ZtoBV x, ZtoBV y)\n        dummy = mask swap && (x_2 ^ x_3)\n\ncswap' : [255] -> (Z p, Z p) -> (Z p, Z p)\ncswap' swap (x, y) = if swap == 0 then (x, y) else (y, x)\n\ncswapEq s x = elem s [0, 1] ==> cswap s x == cswap' s x\n\n\/**\n * `cswap False` is the identity.\n *\n * ```repl\n * :check cswapFalse\n * ```\n *\/\nproperty cswapFalse x = cswap 0 x == x\n\n\/**\n * `cswap True` is an involution.\n *\n * ```repl\n * :check cswapTrue\n * ```\n *\/\nproperty cswapTrue y x = y > 0 ==> cswap y (cswap y x) == x\n\n\/**\n * Test vector from section 5.2.\n *\n * ```repl\n * :prove testVector1\n * ```\n *\n * Reference:\n * [rfc7748] Section 5.2.\n *\/\nproperty testVector1 = X25519 k u == u'\n    where\n        k = split 0xa546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4\n        u = split 0xe6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c\n        u' = split 0xc3da55379de9c6908e94ea4df28d084f32eccf03491c71f754b4075577a28552\n\n\/**\n * Test vector from Section 5.2.\n *\n * ```repl\n * :prove testVector2\n * ```\n *\n * Reference:\n * [rfc7748] Section 5.2.\n *\/\nproperty testVector2 = X25519 k u == u'\n    where\n        k = split 0x4b66e9d4d1b4673c5ad22691957d6af5c11b6421e0ea01d42ca4169e7918ba0d\n        u = split 0xe5210f12786811d3f4b7959d0538ae2c31dbe7106fc03c3efc4cd549c715a493\n        u' = split 0x95cbde9476e8907d7aade45cb4b873f88b595a68799fa152e6f8f7647aac7957\n\n\/**\n * Iterative testing.\n *\/\niterTest : {n} (fin n) => [32][8] -> [32][8] -> [32][8]\niterTest k u\n    | n == 0 => k\n    | n >= 1 => iterTest `{n-1} (X25519 k u) k\n\n\/**\n * An \"iterative\" test vector.\n *\n * ```repl\n * :prove mcTv1\n * ```\n *\/\nproperty mcTv1 = iterTest `{1} k u == r\n    where\n        k = split 0x0900000000000000000000000000000000000000000000000000000000000000\n        u = k\n        r = split 0x422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079\n\n\/**\n * An \"iterative\" test vector.\n *\n * ```repl\n * :prove mcTv2\n * ```\n *\/\nproperty mcTv2 = iterTest `{1000} k u == r\n    where\n        k = split 0x0900000000000000000000000000000000000000000000000000000000000000\n        u = k\n        r = split 0x684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51\n\n\/*\n * Cryptol is too slow to efficiently\n * execute the \"iterative\" test vector\n * for a million iterations.\n *\n * We include the test vector for\n * documentary purposes, and omit the\n * property keyword so it is not executed\n * by `check`, `prove`, etc...\n *\/\nmcTv3 = iterTest `{1000} k u == r\n    where\n        k = split 0x0900000000000000000000000000000000000000000000000000000000000000\n        u = k\n        r = split 0x7c3911e0ab2586fd864497297e575e6f3bc601c0883c30df5f4dd2d24f665424\n\/**\n * Cryptol uses a big-endian convention when\n * using intrinsics such as `toInteger`.\n * This version of X25519 assumes that the byte-arrays\n * are big-endian, and converts the arguments\n * to little endian.\n *\/\nX25519' k u = reverse (X25519 k' u')\n    where\n        k' = reverse k\n        u' = reverse u\n\nproperty bigOk k u = reverse (X25519 (reverse k) (reverse u)) == X25519' k u\n\n\/**\n * Generate the public key `X25519(a, 9)` where\n * `9` is the `u` coordinate of the base point\n * and `a` is the secret value.\n *\n * Reference:\n * [rfc7748] Section 6.1.\n *\n * ```repl\n * let a = split `{32} 0x77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a\n * let b = split `{32} 0x5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb\n * let Ga = split `{32} 0x8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a\n * let Gb = split `{32} 0xde9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f\n * let K = split `{32} 0x4a5d9d5ba4ce2de1728e3bf480350f25e07e21c947d19e3376f09b3c1e161742\n * :prove DH_sender a == Ga\n * :prove DH_sender b == Gb\n * :prove X25519 a Gb == K\n * :prove X25519 b Ga == K\n * ```\n *\/\nDH_sender : [32][8] -> [32][8]\nDH_sender a = X25519 a (reverse (split Gu'))\n    where\n                                Gu' = (fromInteger `Gu) : [32 * 8]\n\n\/**\n * Generate the shared value `K` given the received value `Gr`\n * and the secret `a`.\n *\/\nDH_receiver : [32][8] -> [32][8] -> [32][8]\nDH_receiver a Gr = X25519 a Gr\n\n\/**\n * Diffie-Hellman produces a shared secret.\n *\n * ```repl\n * :check DHSharedSecret\n * ```\n *\/\nproperty DHSharedSecret a b = DH_receiver a Gb == DH_receiver b Ga\n    where\n        Ga = DH_sender a\n        Gb = DH_sender b\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/PFEC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Common::EC::PrimeField::PFEC that contains the following definitions, types, constraints, and checks for short-Weierstrass prime-field elliptic curves with a = \u22123: 1) Parameters: a prime field modulus type with constraints (finite, odd, at least 5, not divisible by 3); a prime subgroup order type smaller than the field modulus; curve parameters b, base-point coordinates, and type aliases for the subgroup order and field modulus. 2) Constants: a fixed curve coefficient equal to \u22123 over the field (private), a cofactor equal to 1, and a base point built from the supplied coordinates. 3) Types: a point type with constructors for the point at infinity and affine coordinates; a private projective point record; a private record grouping four projective points for twin operations. 4) Helpers (private): conversions between affine and projective forms; a batch normalization routine over four projective points with shared inversions; constants representing the projective infinity and zero representations. 5) Core projective algorithms with explicit type signatures: point doubling, mixed\/full addition, subtraction via negation, scalar multiplication via a left-to-right recoding using bit vectors, and twin multiplication per a fixed windowed rule; include an auxiliary function mapping 5-bit windows as in the referenced routine. 6) Affine operations and utilities: affine addition (handling inverses and infinity cases), scalar multiplication wrapper and its infix alias, twin multiplication wrapper returning affine output, a function producing a valid point from a subgroup scalar, an optional x-coordinate extractor, and a generic field division operator using multiplicative inverse. 7) Properties: nonzero discriminant for curve parameters; base point lies on the curve; base point has the declared prime order; closure of addition, doubling, subtraction, and scalar multiplication over valid points; commutativity of iterated scalar multiplication; correctness of batch normalization on already-normal inputs; equivalence of affine and projective addition (non-infinity cases) and correct handling of infinity; and correctness of twin multiplication versus the sum of independent scalar multiplications. Import the required arithmetic helpers for doubling\/halving and bit-vector conversion."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::PFEC where\n\nimport Common::utils(half, mul2, mul3, mul4, mul8, ZtoBV)\n\nparameter\n\n    type P : #\n    type constraint (fin P, prime P, P >= 5, P % 2 == 1, P % 3 != 0)\n\n    type n' : #\n    type constraint (fin n', prime n', n' < P)\n\n    b : Z P\n\n    Gx : Z P\n    Gy : Z P\n\ntype n = n'\n\n\/**\n * Modulus of the field over which the curve is defined.\n *\n * This is called `q` for the `ECInterface`, which is designed to support\n * curves that are not necessarily over prime order fields.\n *\/\ntype q = P\n\n\/**\n * Coefficient that defines the curve.\n * For a curve in short-Weierstrass form, the equation is\n * `y^2 = x^3 + ax + b`.\n * See the `curveCoefficientsAreValid` property.\n * [SP-800-186] Section 2.1.1.\n *\n * Due to restrictions on the underlying elliptic curve operations, the\n * a-coordinate must be -3. This is the case for all NIST-standardized\n * prime order fields in short-Weierstrass form.\n *\/\nprivate a = -3 : Z P\n\n\/**\n * Cofactor for the curve.\n *\n * The order of the curve is defined as `h * n`, where `h` is small\n * and `n`, the order of the base point `G`, is prime. If `h` is not\n * 1, then the base point does not generate the entire curve.\n *\n * This is fixed to 1 for all the NIST-standardized prime order fields\n * in short-Weierstrass form. It's not necessarily true for all reasonable\n * elliptic curves.\n *\/\nh = 1 : Integer\n\nenum Point = Infinity | Affine (Z P) (Z P)\n\naffineEq : Point -> Point -> Bool\naffineEq p1 p2 = case p1 of\n    Infinity -> case p2 of\n        Infinity -> True\n        _ -> False\n    Affine x y -> case p2 of\n        Affine x' y' -> (x == x') && (y == y')\n        _ -> False\n\npointEq = affineEq\n\nisValid : Point -> Bit\nisValid point = case point of\n    Infinity -> True\n    Affine x y -> (y ^^ 2 == x ^^ 3 + a * x + b)\n\nisInfinity : Point -> Bool\nisInfinity point = case point of\n    Infinity -> True\n    _ -> False\n\nG = Affine Gx Gy : Point\n\nproperty curveCoefficientsAreValid = (4 * a^^3 + _27 * b^^2 != 0)\n    where\n        _27 : Z P\n        _27 = fromInteger 27\n\nproperty gOrderIsN = affineEq G ((`n + 1) ~* G)\n\nproperty gIsValid = isValid G\n\nadd : Point -> Point -> Point\nadd p1 p2 = to_affine (ec_full_add (to_projective p1) (to_projective p2))\n\nproperty addIsClosed k1 k2 = isValid (add p1 p2)\n    where\n        p1 = validPointFromK k1\n        p2 = validPointFromK k2\n\ndouble : Point -> Point\ndouble p = to_affine (ec_double (to_projective p))\n\nproperty doubleIsClosed k = isValid (double p)\n    where\n        p = validPointFromK k\n\nsub : Point -> Point -> Point\nsub p1 p2 = to_affine (ec_full_sub (to_projective p1) (to_projective p2))\n\nproperty subIsClosed k1 k2 = isValid (sub p1 p2)\n    where\n        p1 = validPointFromK k1\n        p2 = validPointFromK k2\n\nscmul : Integer -> Point -> Point\nscmul k p = to_affine (ec_mult (fromInteger k) (to_projective p))\n\n(~*) = scmul  \n\nproperty scmulIsClosed m = isValid (m ~* G)\n\nproperty scmul_commutes m m' = affineEq (m ~* (m' ~* G)) (m' ~* (m ~* G))\n\n\/**\n * Compute twin multiplication.\n *\/\ntwin_mul : Integer -> Point -> Integer -> Point -> Point\ntwin_mul c P d Q = to_affine (ec_twin_mult c' P' d' Q')\n    where\n        [c', d'] = [fromInteger   x | x <- [c, d]]\n        [P', Q'] = [to_projective p | p <- [P, Q]]\n\n\/**\n * Extract the x-coordinate `Z P` value, if the point is not the point at\n * infinity.\n *\/\nxCoord: Point -> Option (Z P)\nxCoord p = case p of\n    Infinity -> None\n    Affine x _ -> Some x\n\nprivate\n    type ProjectivePoint = { x : Z P, y : Z P, z : Z P }\n    InfinityProjective = { x=1, y=1, z=0 }\n    Zero = { x=0, y=0, z=0 }\n\n    \/**\n     * Convert from an affine to a projective representation.\n     * [MATH-2008] Routine 2.2.1.\n     *\/\n    to_projective : Point -> ProjectivePoint\n    to_projective p = case p of\n        Infinity -> InfinityProjective\n        Affine x y -> { x=x, y=y, z=1 }\n\n    \/**\n     * Convert from a projective to an affine representation.\n     * [MATH-2008] Routine 2.2.2.\n     *\/\n    to_affine : ProjectivePoint -> Point\n    to_affine p =\n        \/\/ The point at infinity does not have an affine representation.\n        if p.z == 0 then Infinity\n        \/\/ Note the parentheses here.\n        \/\/ See Note [Limit scope of recip in where clauses].\n        else (Affine (lambda ^^2 * p.x) (lambda ^^3 * p.y)\n               where\n                 lambda = recip p.z)\n\n    \/\/ The twin affine function depends on the set of four points: two\n    \/\/ arbitrary points S and T, their sum SpT, and their difference SmT.\n    type TwinPoints = {\n        A: ProjectivePoint,\n        B: ProjectivePoint,\n        C: ProjectivePoint,\n        D: ProjectivePoint\n    }\n    \/**\n     * Optimized routine to affinify and projectify four points at once\n     * (or do nothing, if any of the points are the point at infinity).\n     *\n     * This optimization is designed for use in `ec_twin_mult` and should not\n     * be used in other settings without checking that its behavior is suitable.\n     * [MATH-2008] Section 2.2, Note 8.\n     *\/\n    twin_normalize: TwinPoints -> TwinPoints\n    twin_normalize { A=A, B=B, C=C, D=D } =\n        \/\/ We can't compute twin normalization on the point at infinity\n                        if (A.z == 0) || (B.z == 0) || (C.z == 0) || (D.z == 0) then\n            { A=A, B=B, C=C, D=D }\n        else\n                              ({\n             A = normalize_from_inv A a_inv,\n             B = normalize_from_inv B b_inv,\n             C = normalize_from_inv C c_inv,\n             D = normalize_from_inv D d_inv\n           } where\n               ab = A.z * B.z\n               cd = C.z * D.z\n               abc = ab * C.z\n               abd = ab * D.z\n               acd = A.z * cd\n               bcd = B.z * cd\n               abcd = ab * cd\n               e = recip abcd\n               a_inv = e * bcd\n               b_inv = e * acd\n               c_inv = e * abd\n               d_inv = e * abc\n               normalize_from_inv p inv =\n                   to_projective (Affine (inv ^^2 * p.x) (inv ^^3 * p.y)))\n\n    property normalizeWorksOnNormalPoints k1 k2 k3 k4 = all_are_normal && all_match\n        where\n            p1 = to_projective (validPointFromK k1)\n            p2 = to_projective (validPointFromK k2)\n            p3 = to_projective (validPointFromK k3)\n            p4 = to_projective (validPointFromK k4)\n\n            input = {A=p1, B=p2, C=p3, D=p4}\n            out = twin_normalize input\n\n                                                any_are_infinity = any (\\k -> k == 0) [k1, k2, k3, k4]\n\n                                                all_are_normal = any_are_infinity ||\n                all (\\p -> p.z == 1) [out.A, out.B, out.C, out.D]\n\n                                    all_match = (out.A == p1) && (out.B == p2)\n                && (out.C == p3) && (out.D == p4)\n\n    ec_double : ProjectivePoint -> ProjectivePoint\n    ec_double S =\n      if S.z == 0 then InfinityProjective \n      else {x = r18, y = r23, z = r13}\n      where\n          r7  = S.z ^^ 2                \n          r8  = S.x - r7                \n          r9  = S.x + r7                \n          r10 = r9 * r8                 \n          r11 = mul3 r10                \n          r12 = S.z * S.y               \n          r13 = mul2 r12                \n          r14 = S.y ^^ 2                \n          r15 = S.x * r14               \n          r16 = mul4 r15                \n          r17 = r11 ^^ 2                \n          r18 = r17 - (mul2 r16)        \n          r19 = r14 ^^ 2                \n          r20 = mul8 r19                \n          r21 = r16 - r18               \n          r22 = r11 * r21               \n          r23 = r22 - r20               \n\n    ec_add : ProjectivePoint -> ProjectivePoint -> ProjectivePoint\n    ec_add S T =\n        if r13 == 0 then\n            if r14 == 0 then Zero       \n            else InfinityProjective     \n        else\n            {x = r32, y = r37, z = r27} \n        where\n            (t1, t2, t3, t4, t5, t6) = if T.z == 1 then\n                                (S.x, S.y, S.z, T.x, T.y, T.z)\n                else (r5, r7, S.z, T.x, T.y, r3)\n\n            r3 = T.z                \n            r4 = r3 ^^ 2            \n            r5 = S.x * r4           \n            r6 = r3 * r4            \n            r7 = S.y * r6           \n\n            r9  = t3 ^^ 2           \n            r10 = t4 * r9           \n            r11 = t3 * r9           \n            r12 = t5 * r11          \n            r13 = t1 - r10          \n            r14 = t2 - r12          \n\n            r22 = mul2 t1 - r13     \n            r23 = mul2 t2 - r14     \n\n            r25 = t3 * t6           \n\n            r27 = r25 * r13          \n            r28 = r13 ^^ 2           \n            r29 = r13 * r28          \n            r30 = r22 * r28          \n            r31 = r14 ^^ 2           \n            r32 = r31 - r30          \n            r33 = r30 - (mul2 r32)   \n            r34 = r14 * r33          \n            r35 = r23 * r29          \n            r36 = r34 - r35          \n            r37 = half r36           \n\n    ec_full_add : ProjectivePoint -> ProjectivePoint -> ProjectivePoint\n    ec_full_add S T =\n        if S.z == 0 then T\n        | T.z == 0 then S\n        | R == {x = 0, y = 0, z = 0} then ec_double S\n        else R\n        where R = ec_add S T\n\n    ec_full_sub : ProjectivePoint -> ProjectivePoint -> ProjectivePoint\n    ec_full_sub S T = R\n        where\n            U = {x = T.x, y = -T.y, z = T.z}\n            R = ec_full_add S U\n\n    ec_mult : Z P -> ProjectivePoint -> ProjectivePoint\n    ec_mult d S =\n        if d == 0 then to_projective Infinity\n        | d == 1 then S\n        | S.z == 0 then to_projective Infinity\n        else Rs ! 1 \n        where\n            S' = if S.z != 1 then to_projective (to_affine S) else S\n            \/\/ Get bits of `d` and `3d`. The width of `ks` is set to be large\n            \/\/ enough to hold the full width of `hs`.\n            ks = ZtoBV d : [width P + 2]\n            hs = 3 * ks\n\n            \/\/ The specified routine initializes R = S and skips the first\n            \/\/ high-bit of `hs`, assuming that it's 1. Since we're a little\n            \/\/ floppy with our bitwise conversion, we'll start at 0 and\n                        Rs = [ InfinityProjective ] #\n                [ if hi && ~ki then ec_full_add doubleR S\n                  | ~hi && ki then ec_full_sub doubleR S\n                  else doubleR\n                  where doubleR = ec_double Ri\n                | ki <- ks | hi <- hs | Ri <- Rs ]\n\n    affine_add : Point -> Point -> Point\n    affine_add point1 point2 = case point1 of\n        Infinity -> point2\n        Affine x1 y1 -> case point2 of\n            Infinity -> point1\n            Affine x2 y2 -> if (x1 == x2) && (y1 == -y2) then Infinity\n                else Affine x y\n                where                      x = lambda ^^ 2 - x1 - x2\n                    y = lambda * (x1 - x) - y1\n                    lambda = if x1 == x2 then (3 * x1 ^^ 2 + a) %\/ (2 * y1)\n                        else (y2 - y1) %\/ (x2 - x1)\n\n    validPointFromK : Z n' -> Point\n    validPointFromK k = to_affine (ec_mult _k (to_projective G))\n        where\n            _k : Z P\n            _k = fromInteger (fromZ k)\n\n    \/**\n     * Proof that the affine and projective versions of addition are equivalent.\n     * This doesn't test the point at infinity.\n     *\n     * ```repl\n     * :check addsAreEquivalent\n     * ```\n     *\/\n    addsAreEquivalent : Z n' -> Z n' -> Bool\n    property addsAreEquivalent k1 k2 =\n        affineEq (affine_add p1 p2) (to_affine full_sum)\n        where\n            p1 = validPointFromK k1\n            p2 = validPointFromK k2\n            full_sum = ec_full_add (to_projective p1) (to_projective p2)\n\n    addsBehaveCorrectlyAtInfinity : Z n' -> Bool\n    property addsBehaveCorrectlyAtInfinity k =\n        oo && ok && ko && oo' && ok' && ko'\n        where\n                        point = validPointFromK k\n            oo = affineEq Infinity (affine_add Infinity Infinity)\n            ok = affineEq point (affine_add Infinity point)\n            ko = affineEq point (affine_add point Infinity)\n\n                        point' = to_projective point\n            oo' = InfinityProjective ==\n                ec_full_add InfinityProjective InfinityProjective\n            ok' = point' == ec_full_add InfinityProjective point'\n            ko' = point' == ec_full_add point' InfinityProjective\n\n    ec_twin_mult : Z P -> ProjectivePoint -> Z P -> ProjectivePoint -> ProjectivePoint\n    ec_twin_mult d0 S d1 T = (states!0).0\n        where\n            SpT = ec_full_add S T                      \n            SmT = ec_full_sub S T                      \n                                                { A=S', B=T', C=SpT', D=SmT' } =\n                twin_normalize { A=S, B=T, C=SpT, D=SmT }\n            e0s = ZtoBV d0 : [max 4 (width P)]         \n            e1s = ZtoBV d1 : [max 4 (width P)]         \n            c   = [[False, False] # take e0s,          \n                   [False, False] # take e1s] : [2][6]\n            states = [(InfinityProjective, c)] #       \n                [ (Rk', [c0', c1'])\n                    where\n                    \/\/ Lines 8-13.\n                    \/\/ `tail ci` uses Cryptol's built-in bit vector\n                                        h0 = if c0@0 then 31 - tail c0 else tail c0\n                    h1 = if c1@0 then 31 - tail c1 else tail c1\n                                        u0 = if h0 < (F h1) then 0 else if c0@0 then -1 else 1 : [2]\n                    u1 = if h1 < (F h0) then 0 else if c1@0 then -1 else 1 : [2]\n                                                            c0' = [(u0!=0) ^ c0@1] # drop c0 # [e0k]\n                    c1' = [(u1!=0) ^ c1@1] # drop c1 # [e1k]\n                                        RkDouble = ec_double Rk\n                                        Rk' = if (u0 == -1) && (u1 == -1) then\n                            ec_full_sub RkDouble SpT'\n                        | (u0 == -1) && (u1 ==  0) then ec_full_sub RkDouble S'\n                        | (u0 == -1) && (u1 ==  1) then\n                            ec_full_sub RkDouble SmT'\n                        | (u0 ==  0) && (u1 == -1) then ec_full_sub RkDouble T'\n                        | (u0 ==  0) && (u1 ==  1) then ec_full_add RkDouble T'\n                        | (u0 ==  1) && (u1 == -1) then\n                            ec_full_add RkDouble SmT'\n                        | (u0 ==  1) && (u1 ==  0) then ec_full_add RkDouble S'\n                        | (u0 ==  1) && (u1 ==  1) then\n                            ec_full_add RkDouble SpT'\n                        else RkDouble\n                | (Rk, [c0, c1]) <- states\n                \/\/ Line 7: Iterate through the eis, after dropping the four\n                \/\/ bits we already used to initialize `c` and padding with 0.\n                | e0k <- drop`{4} e0s # (zero : [5])\n                | e1k <- drop`{4} e1s # (zero : [5]) ]\n\n            \/\/ An auxiliary routine.\n            \/\/ [MATH-2008] Routine 2.2.11.\n            F : [5] -> [5]\n            F t = if (18 <= t) && (t < 22) then 9\n                | (14 <= t) && (t < 18) then 10\n                | (22 <= t) && (t < 24) then 11\n                | (4 <= t)  && (t < 12) then 14\n                else 12\n\n    \/**\n     * Checks that twin multiplication works as expected. Note that a given\n     * point can have multiple projective representations, so we have to\n     * check equality in the affine representation.\n     *\n     * These tests check the general case, the case where the two points `S`\n     * and `T` are the same, and the case where one of the points is the point\n     * at infinity.\n     * ```repl\n     * :check twin_mult_works\n     * :check (\\d0 d1 k -> twin_mult_works d0 k d1 k)\n     * :check (\\d0 d1 k -> twin_mult_works d0 k d1 0)\n     * :check (\\d0 d1 k -> twin_mult_works d0 0 d1 k)\n     * ```\n     *\/\n    property twin_mult_works d0 k0 d1 k1 = affineEq R_plain R_twin\n        where\n            S = to_projective (validPointFromK k0)\n            T = to_projective (validPointFromK k1)\n            R_plain = to_affine (ec_full_add (ec_mult d0 S) (ec_mult d1 T))\n            R_twin = to_affine (ec_twin_mult d0 S d1 T)\n\n    \/**\n    * Calulate x \/ y in a field.\n    * ```repl\n    * :prove  2 %\/ 2 == (1 : Z 3)\n    * ```\n    *\/\n    (%\/) : {a} (Field a) => a -> a -> a\n    (%\/) x y = x * recip y\n\n\/*\nNote [Limit scope of recip in where clauses]\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nThere are a small number of places where we call the `recip` function in a\nlocal definition bound by a `where` clause such that the definition is only ever\nused in the `else` branch of an if-expression. For example, in `to_affine` we\nhave:\n\n  to_affine p =\n      if p.z == 0 then Infinity\n      \/\/ Note the explicit parentheses here, which ensures that `lambda` is in\n      \/\/ scope in the `else` branch but *not* the `then` branch.\n      else (Affine (lambda ^^2 * p.x) (lambda ^^3 * p.y)\n             where\n               lambda = recip p.z)\n\nDoing so is not strictly necessary in Cryptol, as Cryptol's lazy evaluation\nwill only evaluate `lambda` if the `else` branch is evaluated. This is solely\ndone for the benefit of compiling to call-by-value languages (e.g., C or Rust),\nas evaluating `lambda` before the `if`-expression would result in a panic when\n`p.z == 0`.\n*\/\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Tests\/P256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Common::EC::PrimeField::Tests::P256 that contains the following: (1) import the P-256 affine curve instantiation under the alias used for its namespace, and import the bitvector-to-integer conversion utility. (2) define constants S and T as affine points on the P-256 curve, constructed from fixed 256-bit constants converted to integers via the bitvector-to-integer utility. (3) define a property named sAndTAreValid that holds exactly when both S and T pass the curve\u2019s validity check. (4) define a property named additionVectorPasses that holds exactly when the affine equality predicate reports that adding S and T yields an expected affine point R; define R locally from fixed constants. (5) define a property named subtractionVectorPasses that holds exactly when subtracting T from S equals the corresponding expected affine point R under the affine equality predicate; define R locally. (6) define a property named doubleVectorPasses that holds exactly when doubling S equals an expected affine point R under the affine equality predicate; define R locally. (7) define a property named scalarMultVectorPasses that holds exactly when scalar-multiplying S by a fixed integer d equals an expected affine point R under the affine equality predicate; define d and R locally from fixed constants. (8) define a property named twinMultVectorPasses that holds exactly when the simultaneous scalar multiplication of S by d and T by e equals an expected affine point R under the affine equality predicate; define d, e, and R locally from fixed constants. Use the curve\u2019s affine point constructor for points and integers for coordinates and scalars. Do not provide implementations beyond these declarations."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Tests::P256 where\nimport Common::EC::PrimeField::Instantiations::P256 as P256\nimport Common::utils(BVtoZ)\n\nS = P256::Affine (BVtoZ 0xde2444bebc8d36e682edd27e0f271508617519b3221a8fa0b77cab3989da97c9)\n     (BVtoZ 0xc093ae7ff36e5380fc01a5aad1e66659702de80f53cec576b6350b243042a256)\n\nT = P256::Affine (BVtoZ 0x55a8b00f8da1d44e62f6b3b25316212e39540dc861c89575bb8cf92e35e0986b)\n     (BVtoZ 0x5421c3209c2d6c704835d82ac4c3dd90f61a8a52598b9e7ab656e9d8c8b24316)\n\nproperty sAndTAreValid = P256::isValid S && P256::isValid T\n\nproperty additionVectorPasses = P256::affineEq (P256::add S T) R\n  where R = P256::Affine (BVtoZ 0x72b13dd4354b6b81745195e98cc5ba6970349191ac476bd4553cf35a545a067e)\n             (BVtoZ 0x8d585cbb2e1327d75241a8a122d7620dc33b13315aa5c9d46d013011744ac264)\n\nproperty subtractionVectorPasses = P256::affineEq (P256::sub S T) R\n  where R = P256::Affine (BVtoZ 0xc09ce680b251bb1d2aad1dbf6129deab837419f8f1c73ea13e7dc64ad6be6021)\n             (BVtoZ 0x1a815bf700bd88336b2f9bad4edab1723414a022fdf6c3f4ce30675fb1975ef3)\n\nproperty doubleVectorPasses = P256::affineEq (P256::double S) R\n  where R = P256::Affine (BVtoZ 0x7669e6901606ee3ba1a8eef1e0024c33df6c22f3b17481b82a860ffcdb6127b0)\n             (BVtoZ 0xfa878162187a54f6c39f6ee0072f33de389ef3eecd03023de10ca2c1db61d0c7)\n\nproperty scalarMultVectorPasses = P256::affineEq (P256::scmul d S) R\n  where d = toInteger 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        R = P256::Affine (BVtoZ 0x51d08d5f2d4278882946d88d83c97d11e62becc3cfc18bedacc89ba34eeca03f)\n             (BVtoZ 0x75ee68eb8bf626aa5b673ab51f6e744e06f8fcf8a6c0cf3035beca956a7b41d5)\n\nproperty twinMultVectorPasses =\n  P256::affineEq R (P256::twin_mul d S e T)\n  where d = toInteger 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        e = toInteger 0xd37f628ece72a462f0145cbefe3f0b355ee8332d37acdd83a358016aea029db7\n        R = P256::Affine (BVtoZ 0xd867b4679221009234939221b8046245efcf58413daacbeff857b8588341f6b8)\n            (BVtoZ 0xf2504055c03cede12d22720dad69c745106b6607ec7e50dd35d54bd80f615275)\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Tests\/P192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::EC::PrimeField::Tests::P192 that imports the P-192 curve instantiation module (aliased for convenience) and the bitvector-to-integer converter. Within it, declare two affine curve points as constants using the provided 192-bit x and y coordinates, converted from bitvectors to integers. Then add the following properties: (1) a property that both points are valid on the curve using the curve\u2019s validity predicate; (2) a property that point addition of the two points equals a specified expected affine result, comparing via the curve\u2019s affine equality predicate; (3) a property that point subtraction of the two points equals its specified expected affine result; (4) a property that doubling the first point equals its specified expected affine result; (5) a property that scalar-multiplying the first point by a given integer scalar equals its specified expected affine result; (6) a property that scalar-multiplying a third given affine point by a given integer scalar equals its specified expected affine result (declare the third point and scalar locally within the property); and (7) a property that the simultaneous multiplication d*S + e*T equals a specified expected affine result, using the curve\u2019s twin\/simultaneous multiplication routine. For each vector test, define the expected result as a local affine point with the provided coordinates, and use the curve\u2019s affine equality predicate for comparison. Ensure scalars d and e are declared as integers from the given literals, and that all points are expressed in the curve\u2019s affine type. Name the definitions and properties exactly as in the source (constants for the two points, and the six vector-test properties plus the validity property)."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Tests::P192 where\nimport Common::EC::PrimeField::Instantiations::P192 as P192\nimport Common::utils(BVtoZ)\n\nS = P192::Affine (BVtoZ 0xd458e7d127ae671b0c330266d246769353a012073e97acf8)\n     (BVtoZ 0x325930500d851f336bddc050cf7fb11b5673a1645086df3b)\n\nT = P192::Affine (BVtoZ 0xf22c4395213e9ebe67ddecdd87fdbd01be16fb059b9753a4)\n     (BVtoZ 0x264424096af2b3597796db48f8dfb41fa9cecc97691a9c79)\n\nproperty sAndTAreValid = P192::isValid S && P192::isValid T\n\nproperty additionVectorPasses = P192::affineEq (P192::add S T) R\n  where R = P192::Affine (BVtoZ 0x48e1e4096b9b8e5ca9d0f1f077b8abf58e843894de4d0290)\n             (BVtoZ 0x408fa77c797cd7dbfb16aa48a3648d3d63c94117d7b6aa4b)\n\nproperty subtractionVectorPasses = P192::affineEq (P192::sub S T) R\n  where R = P192::Affine (BVtoZ 0xfc9683cc5abfb4fe0cc8cc3bc9f61eabc4688f11e9f64a2e)\n             (BVtoZ 0x093e31d00fb78269732b1bd2a73c23cdd31745d0523d816b)\n\nproperty doubleVectorPasses = P192::affineEq (P192::double S) R\n  where R = P192::Affine (BVtoZ 0x30c5bc6b8c7da25354b373dc14dd8a0eba42d25a3f6e6962)\n             (BVtoZ 0x0dde14bc4249a721c407aedbf011e2ddbbcb2968c9d889cf)\n\nproperty scalarMultVectorPasses = P192::affineEq (P192::scmul d S) R\n  where d = toInteger 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        R = P192::Affine (BVtoZ 0x1faee4205a4f669d2d0a8f25e3bcec9a62a6952965bf6d31)\n             (BVtoZ 0x5ff2cdfa508a2581892367087c696f179e7a4d7e8260fb06)\n\nproperty scalarMultVectorPasses2 = P192::affineEq (P192::scmul d S') R\n    where\n        S' = P192::Affine (BVtoZ 0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012)\n            (BVtoZ 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811)\n        d = toInteger 0xe14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3\n        R = P192::Affine (BVtoZ 0x07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6)\n            (BVtoZ 0x76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477)\n\nproperty twinMultVectorPasses =\n  P192::affineEq R (P192::twin_mul d S e T)\n  where d = toInteger 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        e = toInteger 0xc4be3d53ec3089e71e4de8ceab7cce889bc393cd85b972bc\n        R = P192::Affine (BVtoZ 0x019f64eed8fa9b72b7dfea82c17c9bfa60ecb9e1778b5bde)\n            (BVtoZ 0x16590c5fcd8655fa4ced33fb800e2a7e3c61f35d83503644)\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Tests\/P224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Common::EC::PrimeField::Tests::P224 that imports Common::EC::PrimeField::Instantiations::P224 as P224 and Common::utils(BVtoZ); declare S and T as P224 affine points constructed from the provided hexadecimal x and y coordinates via BVtoZ; and define the following Cryptol properties: sAndTAreValid asserts P224.isValid holds for S and T; additionVectorPasses asserts P224.affineEq (P224.add S T) equals a fixed expected P224 affine point R with the given coordinates; subtractionVectorPasses asserts P224.affineEq (P224.sub S T) equals a fixed expected point R; doubleVectorPasses asserts P224.affineEq (P224.double S) equals a fixed expected point R; scalarMultVectorPasses asserts P224.affineEq (P224.scmul d S) equals a fixed expected point R, where d is the provided hexadecimal scalar interpreted as an Integer; twinMultVectorPasses asserts P224.affineEq of a fixed expected point R with P224.twin_mul d S e T, where d and e are the provided hexadecimal scalars as Integers. Ensure all R values are P224 affine points built from the provided coordinates and that names, types, and operations match exactly."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Tests::P224 where\nimport Common::EC::PrimeField::Instantiations::P224 as P224\nimport Common::utils(BVtoZ)\n\nS = P224::Affine (BVtoZ 0x6eca814ba59a930843dc814edd6c97da95518df3c6fdf16e9a10bb5b)\n     (BVtoZ 0xef4b497f0963bc8b6aec0ca0f259b89cd80994147e05dc6b64d7bf22)\n\nT = P224::Affine (BVtoZ 0xb72b25aea5cb03fb88d7e842002969648e6ef23c5d39ac903826bd6d)\n     (BVtoZ 0xc42a8a4d34984f0b71b5b4091af7dceb33ea729c1a2dc8b434f10c34)\n\nproperty sAndTAreValid = P224::isValid S && P224::isValid T\n\nproperty additionVectorPasses = P224::affineEq (P224::add S T) R\n  where R = P224::Affine (BVtoZ 0x236f26d9e84c2f7d776b107bd478ee0a6d2bcfcaa2162afae8d2fd15)\n             (BVtoZ 0xe53cc0a7904ce6c3746f6a97471297a0b7d5cdf8d536ae25bb0fda70)\n\nproperty subtractionVectorPasses = P224::affineEq (P224::sub S T) R\n  where R = P224::Affine (BVtoZ 0xdb4112bcc8f34d4f0b36047bca1054f3615413852a7931335210b332)\n             (BVtoZ 0x90c6e8304da4813878c1540b2396f411facf787a520a0ffb55a8d961)\n\nproperty doubleVectorPasses = P224::affineEq (P224::double S) R\n  where R = P224::Affine (BVtoZ 0xa9c96f2117dee0f27ca56850ebb46efad8ee26852f165e29cb5cdfc7)\n             (BVtoZ 0xadf18c84cf77ced4d76d4930417d9579207840bf49bfbf5837dfdd7d)\n\nproperty scalarMultVectorPasses = P224::affineEq (P224::scmul d S) R\n  where d = toInteger 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        R = P224::Affine (BVtoZ 0x96a7625e92a8d72bff1113abdb95777e736a14c6fdaacc392702bca4)\n             (BVtoZ 0x0f8e5702942a3c5e13cd2fd5801915258b43dfadc70d15dbada3ed10)\n\nproperty twinMultVectorPasses =\n  P224::affineEq R (P224::twin_mul d S e T)\n  where d = toInteger 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        e = toInteger 0x54d549ffc08c96592519d73e71e8e0703fc8177fa88aa77a6ed35736\n        R = P224::Affine (BVtoZ 0xdbfe2958c7b2cda1302a67ea3ffd94c918c5b350ab838d52e288c83e)\n            (BVtoZ 0x2f521b83ac3b0549ff4895abcc7f0c5a861aacb87acbc5b8147bb18b)\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Instantiations\/P256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::EC::PrimeField::Instantiations::P256 that instantiates Common::EC::PrimeField::PFEC via a where-clause. Inside the where-clause, provide the following concrete parameters: (1) a type-level natural P equal to the curve\u2019s 256-bit prime field modulus; (2) a type-level natural n' equal to the base point order; (3) value constants b, Gx, and Gy for the curve coefficient and base point coordinates, respectively. Give b, Gx, and Gy explicit 256-bit word types (e.g., sequences of 256 bits) consistent with the field defined by P, and ensure their numeric values exactly match the implementation constants. The resulting module should expose the PFEC API specialized to these parameters and not add any other functions or properties."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Instantiations::P256 =\n       Common::EC::PrimeField::PFEC where\ntype P = 115792089210356248762697446949407573530086143415290314195533631308867097853951\ntype n' = 115792089210356248762697446949407573529996955224135760342422259061068512044369\nb  = `0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\nGx = `0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\nGy = `0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Instantiations\/P192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::EC::PrimeField::Instantiations::P192 that instantiates the generic prime-field EC module Common::EC::PrimeField::PFEC via a where-clause. Inside this module, provide the following definitions using exactly the numeric values from the file: (1) a type-level natural P representing the prime modulus (bit-length 192); (2) a type-level natural n' representing the group\/base-point order; (3) value constants b, Gx, and Gy representing the curve coefficient and the base point coordinates, respectively, taken from the provided hexadecimal literals. Give b, Gx, and Gy explicit types consistent with P, such as 192-bit sequences or elements reduced modulo P, with widths derived from P. Include type signatures for all value definitions and ensure P and n' are available at the type level (usable in constraints). Preserve all names exactly and export these bindings from the module. Do not add new functions; only instantiate the module with these parameters and provide well-formed types that align with the PFEC interface expectations (e.g., values are within [0 .. P-1], widths match the bit-length of P)."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Instantiations::P192 =\n       Common::EC::PrimeField::PFEC where\ntype P = 6277101735386680763835789423207666416083908700390324961279\ntype n' =  6277101735386680763835789423176059013767194773182842284081\nb  = `0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1\nGx = `0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\nGy = `0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Instantiations\/P224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::EC::PrimeField::Instantiations::P224 that instantiates the existing prime-field elliptic-curve module by supplying the NIST P-224 domain parameters. Inside the module: (1) declare a type alias P for the 224-bit prime modulus; (2) declare a type alias n' for the implementation integer constant required by the field arithmetic; (3) declare constants b, Gx, and Gy as 224-bit, big-endian bit sequences for the curve constant and base-point coordinates; (4) make this module equal to the generic prime-field EC module specialized with P, n', b, Gx, and Gy. Provide explicit type signatures for b, Gx, and Gy as 224-bit sequences. Add properties to check that: the widths of b, Gx, and Gy are 224 bits; each of b, Gx, and Gy is strictly less than P; and the base point (Gx, Gy) satisfies the short Weierstrass equation over the field modulo P with coefficient \u22123 and constant b. Do not implement any additional functionality beyond these declarations and verification properties."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Instantiations::P224 =\n       Common::EC::PrimeField::PFEC where\ntype P = 26959946667150639794667015087019630673557916260026308143510066298881\ntype n' = 26959946667150639794667015087019625940457807714424391721682722368061\nb  = `0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\nGx = `0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\nGy = `0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\n```"}]}
{"filename":"saw-script\/intTests\/test_FNV_a1_rev\/FNV_a1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define Cryptol declarations that implement a 64-bit FNV-1a hash over arbitrary-length inputs and verify known-answer tests, plus a salted-hash checking utility. Provide: (1) a polymorphic type for a function that maps an n-bit message to a 64-bit hash with a fin n constraint; (2) a padding function that, given a bitvector, appends the minimal number of zero bits to reach a whole number of bytes, with size parameters and constraints expressing the number of 8-bit chunks and the padding width, and returns the message split into bytes; (3) a helper that hashes a sequence of bytes by iterating a state starting from a 64-bit offset basis and, for each byte, XORs the state with the byte zero-extended to 64 bits (by prepending 56 zeros) and multiplies by a 64-bit prime; (4) a block update function with the necessary size equality constraint (the extension width equals 64\u22128); (5) 64-bit constants for the FNV-1a offset basis and prime with the same values and types as in the source; (6) three boolean test bindings that compare the hash of the empty message, a one-byte message, and a multi-byte ASCII message to their expected 64-bit results; (7) define a property testsPass that asserts all three tests are true; (8) a salted hashing function that concatenates a 64-bit salt with the bitvector obtained by joining a byte sequence and hashes that combined bitvector; (9) a predicate that, given a (salt, result) pair and a candidate secret byte sequence, checks the salted hash equals the expected result; (10) a 4-element list of (salt, result) pairs computed from a fixed ASCII message using four different 64-bit salts; and (11) a function that, given four such pairs and a candidate secret byte sequence, returns true iff all pairs verify. Include precise type signatures and constraints for every definition."},{"role":"assistant","content":"```cryptol\nfnv1a : {n} (fin n) => [n] -> [64]\nfnv1a ws = fnv1a' (pad ws)\n\npad : {msgLen,chunks,padding}\n     ( fin chunks\n     , fin msgLen\n     , chunks     == (msgLen+7) \/ 8\n     , padding    == (8 - msgLen % 8) % 8\n     )\n     => [msgLen] -> [chunks][8]\npad msg = split (msg # (zero:[padding]))\n\nfnv1a' : {chunks} (fin chunks) => [chunks][8] -> [64]\nfnv1a' msg = Ss ! 0\n  where\n   Ss = [fnv1a_offset_basis] #\n           [ block s m\n           | s <- Ss\n           | m <- msg\n           ]\n\nblock : {padding} ( fin padding, padding == 64 - 8) => [64] -> [8] -> [64]\nblock state val = (state ^ ((zero : [padding]) # val)) * fnv1a_prime\n\nfnv1a_offset_basis : [64]\nfnv1a_offset_basis = 14695981039346656037\n\nfnv1a_prime : [64]\nfnv1a_prime = 1099511628211\n\nt1 = fnv1a [] == 0xcbf29ce484222325\nt2 = fnv1a (join \"a\") == 0xaf63dc4c8601ec8c\nt3 = fnv1a (join \"foobar\") == 0x85944171f73967e8\n\nproperty testsPass = [t1, t2, t3] == ~zero\n\nbreak : {n} (fin n) => [4]([64],[64]) -> [n][8] -> Bit\nbreak pairs secret = ~zero == [saltHashCorrect p secret | p <- pairs]\n\nsecret1 : [4]([64],[64])\nsecret1 = [ (`0    , saltHash `0x0   msg)\n          , (`0xF  , saltHash `0xF   msg)\n          , (`0xFF , saltHash `0xFF  msg)\n          , (`0xFFF, saltHash `0xFFF msg)\n          ]\n  where msg = \"Secret Message\"\n\nsaltHashCorrect : {n} (fin n) => ([64],[64]) -> [n][8] -> Bit\nsaltHashCorrect (salt,result) secret = saltHash salt secret == result\n\nsaltHash : {n} (fin n) => [64] -> [n][8] -> [64]\nsaltHash s msg = fnv1a (s # join msg)\n```"}]}
{"filename":"saw-script\/intTests\/test_newtype\/complex.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) declares a type alias named Int for the arbitrary-precision integer type; (2) defines a newtype CplxInt as a record with fields real and imag, both of type Int; (3) implements embedQ : Int -> CplxInt that maps an integer to a complex value with that real part and zero imaginary part; (4) implements cplxAdd : CplxInt -> CplxInt -> CplxInt that adds complex numbers by adding real parts and imaginary parts component-wise; (5) implements cplxMul : CplxInt -> CplxInt -> CplxInt using the standard complex multiplication rule (a+bi)(c+di) = (ac - bd) + (ad + bc)i; (6) implements cplxEq : CplxInt -> CplxInt -> Bit that returns true iff both the real and imaginary components are equal; (7) implements three boolean functions cplxAddAssoc, cplxMulAssoc, and cplxMulDistrib, each of type CplxInt -> CplxInt -> CplxInt -> Bit, that check (using cplxEq) respectively: associativity of addition ((x+y)+z vs x+(y+z)), associativity of multiplication ((x*y)*z vs x*(y*z)), and left distributivity of multiplication over addition (x*(y+z) vs (x*y) + (x*z)). Provide explicit type signatures for all names and use exactly the specified identifiers."},{"role":"assistant","content":"```cryptol\ntype Int = Integer\n\nnewtype CplxInt =\n  { real : Int, imag : Int }\n\nembedQ : Int -> CplxInt\nembedQ x = CplxInt{ real = x, imag = 0 }\n\ncplxAdd : CplxInt -> CplxInt -> CplxInt\ncplxAdd x y = CplxInt { real = r, imag = i }\n  where\n  r = x.real + y.real\n  i = x.imag + y.imag\n\ncplxMul : CplxInt -> CplxInt -> CplxInt\ncplxMul x y = CplxInt { real = r, imag = i }\n  where\n  r = x.real * y.real - x.imag * y.imag\n  i = x.real * y.imag + x.imag * y.real\n\ncplxEq : CplxInt -> CplxInt -> Bit\ncplxEq x y = (x.real == y.real) && (x.imag == y.imag)\n\ncplxAddAssoc : CplxInt -> CplxInt -> CplxInt -> Bit\ncplxAddAssoc x y z =\n  cplxEq (cplxAdd (cplxAdd x y) z)\n         (cplxAdd x (cplxAdd y z))\n\ncplxMulAssoc : CplxInt -> CplxInt -> CplxInt -> Bit\ncplxMulAssoc x y z =\n  cplxEq (cplxMul (cplxMul x y) z)\n         (cplxMul x (cplxMul y z))\n\ncplxMulDistrib : CplxInt -> CplxInt -> CplxInt -> Bit\ncplxMulDistrib x y z =\n  cplxEq (cplxMul x (cplxAdd y z))\n         (cplxAdd (cplxMul x y) (cplxMul x z))\n```"}]}
{"filename":"saw-script\/intTests\/test_bisimulation\/Comp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Comp that contains the following definitions: (1) a stateless specification function andSpec with type from a unit-state paired with two input bits to a unit-state paired with a readiness bit and the bitwise conjunction of the inputs, always asserting readiness; (2) a stateless specification function nandSpec of the same type that outputs readiness true and the logical negation of the conjunction produced by the first specification; (3) a record type andState with bit fields indicating whether an input has been latched and storing the last seen inputs; (4) a single-step implementation andImp with type from (andState, two input bits) to (andState, readiness bit and output bit) that, when previously loaded and the new inputs match the stored ones, returns the same state and outputs readiness true with the conjunction of the stored inputs, otherwise updates the state to loaded with the current inputs and outputs readiness false with a zero bit; (5) an output relation andOutputRel that, given an implementation step result and a specification step result, requires equality of outputs when the implementation signals readiness and vacuously holds otherwise; (6) a state relation andStateRel that always holds between the implementation state and the unit state; (7) a record type nandState containing an andState and an unused bit; (8) an implementation nandImp with type from (nandState, two input bits) to (nandState, readiness bit and output bit) that delegates to the conjunction implementation on the inner state, flips the resulting output bit, sets the unused bit to false, and forwards the readiness bit; (9) an output relation nandOutputRel analogous to the conjunction case; (10) a state relation nandStateRel that always holds. Include clear type signatures for all functions and relations."},{"role":"assistant","content":"```cryptol\nmodule Comp where\n\nandSpec : ((), (Bit, Bit)) -> ((), (Bit, Bit))\nandSpec (_, (x, y)) = ((), (True, x && y))\n\nnandSpec : ((), (Bit, Bit)) -> ((), (Bit, Bit))\nnandSpec (_, (x, y)) = ((), (True, ~ (andSpec ((), (x, y))).1.1))\n\ntype andState = { loaded : Bit, origX : Bit, origY : Bit }\n\nandImp : (andState, (Bit, Bit)) -> (andState, (Bit, Bit))\nandImp (s, (x, y)) =\n  if s.loaded \/\\ x == s.origX \/\\ y == s.origY\n  then (s, (True, s.origX && s.origY))\n  else ({ loaded = True, origX = x, origY = y }, (False, 0))\n\nandOutputRel : (andState, (Bit, Bit)) -> ((), (Bit, Bit)) -> Bit\nandOutputRel (s, (impReady, impO)) ((), (_, specO)) =\n  if impReady then impO == specO else True\n\nandStateRel : andState -> () -> Bit\nandStateRel _ () = True\n\ntype nandState = { as : andState, unused : Bit }\n\nnandImp : (nandState, (Bit, Bit)) -> (nandState, (Bit, Bit))\nnandImp (s, in) = ({ as = as' , unused = False }, (andReady, ~andRes))\n  where\n    (as', (andReady, andRes)) = andImp (s.as, in)\n\nnandOutputRel : (nandState, (Bit, Bit)) -> ((), (Bit, Bit)) -> Bit\nnandOutputRel (s, (impReady, impO)) ((), (_, specO)) =\n  if impReady then impO == specO else True\n\nnandStateRel : nandState -> () -> Bit\nnandStateRel _ () = True\n```"}]}
{"filename":"saw-script\/intTests\/test_bisimulation\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Test that contains the following definitions: (1) two type aliases for 8-bit and 16-bit words; (2) a state-step function f1 that takes an 8-bit counter and an 8-bit input and returns the next 8-bit counter (incremented modulo its width) and an 8-bit output equal to the input plus the previous counter modulo 8 bits; (3) a state-step function f2 that takes a 16-bit counter and an 8-bit input and returns the next 16-bit counter (incremented modulo its width) and an 8-bit output equal to the input plus the low 8 bits of the counter; (4) a variant f2_bad_input_type that instead accepts a 9-bit input and produces an 8-bit output computed as the sum of the low 8 bits of the input and the low 8 bits of the counter; (5) a variant f2_bad_output_type that accepts an 8-bit input and produces a 9-bit output by zero-extending the 8-bit sum of the input and the low 8 bits of the counter; (6) a state relation srel between 8-bit and 16-bit counters that holds when the 8-bit counter equals the low 8 bits of the 16-bit counter; and (7) an output relation orel between pairs of (state, output) that holds when the states satisfy the state relation and the outputs are equal. Also add universally quantified boolean goals that express: when starting from related states and the same 8-bit input, one step of f1 and f2 yields next states still related by the state relation and outputs related by the output relation; and that replacing f2 by either variant does not satisfy this condition (expect a counterexample)."},{"role":"assistant","content":"```cryptol\nmodule Test where\n\ntype S1 = [8]\ntype S2 = [16]\n\nf1 : (S1, [8]) -> (S1, [8])\nf1 (ctr, inp) = (ctr+1, inp+ctr)\nf2 : (S2, [8]) -> (S2, [8])\nf2 (ctr, inp) = (ctr+1, inp+(drop ctr))\n\nf2_bad_input_type : (S2, [9]) -> (S2, [8])\nf2_bad_input_type (ctr, inp) = (ctr+1, (drop inp)+(drop ctr))\n\nf2_bad_output_type : (S2, [8]) -> (S2, [9])\nf2_bad_output_type (ctr, inp) = (ctr+1, zext (inp+(drop ctr)))\n\norel : (S1, [8]) -> (S2, [8]) -> Bit\norel (s1, o1) (s2, o2) = s1 == drop s2 \/\\ o1 == o2\n\nsrel : S1 -> S2 -> Bit\nsrel s1 s2 = s1 == drop s2\n```"}]}
{"filename":"saw-script\/intTests\/test2043\/A.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named A that contains the following definitions: (1) a module parameter N declared as a type-level natural number; (2) a module parameter foo declared as a bitvector whose length is N; (3) a function bar whose type is universally quantified over a length n and an element type a, requiring a Zero constraint on a, and whose result is a sequence of length n of elements of type a. Implement bar using two guarded equations that partition on whether n equals 1 or not; in both cases, return the all-zero value of the appropriate length and element type. Make all quantification, constraints, and sequence lengths explicit in the type of bar, and ensure the implementation typechecks for any n and any a supporting Zero."},{"role":"assistant","content":"```cryptol\nmodule A where\n\nparameter\n  type N : #\n  foo : [N]\n\nbar : {n, a} (Zero a) => [n]a\nbar | n == 1 => zero\n    | n != 1 => zero\n```"}]}
{"filename":"saw-script\/intTests\/test_smt_array_load_concrete_size\/Mix.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Mix that contains the following definitions: (1) import of the array utilities module providing array creation, range update, and copy operations; (2) a type alias ByteArray representing an array of length 64 whose elements are 8-bit values; (3) a function mix with a polymorphic size parameter l constrained so that the bit-width of l is at most 64. The function mix takes three arguments: a ByteArray named block, a 64-bit unsigned index n indicating the destination start position within block, and a sequence of l bytes named data; it returns a new ByteArray. Specify the type of mix accordingly and implement it by constructing a temporary array initialized to zeros, writing data into the first l positions of this temporary array, then copying exactly l elements from this temporary array starting at offset 0 into block starting at offset n, leaving all other positions of block unchanged. Use the array range update to place data at the start of the temporary array and the array copy operation to perform the in-place-style overlay into block. Clearly state all parameter and type constraints, including that l elements are copied and that indices are interpreted within a 64-element destination."},{"role":"assistant","content":"```cryptol\nmodule Mix where\n\nimport Array\n\ntype ByteArray = Array[64][8]\n\nmix : {l} (width l <= 64) => ByteArray -> [64] -> [l][8] -> ByteArray\nmix block n data = arrayCopy block n (arrayRangeUpdate (arrayConstant 0) 0 data) 0 `(l)\n```"}]}
{"filename":"saw-script\/intTests\/test0000\/mutRecTest.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the following and proves their agreement: 1) A function that maps an 8-bit index to the 32-bit Fibonacci number using two mutually recursive infinite streams seeded to produce the Fibonacci sequence, returning the element at the given index. 2) An alternative function with the same type that generates the same sequence using a single infinite stream seeded with the first two values and combining the stream with its one-step tail. 3) A naive recursive Fibonacci function from 8-bit to 32-bit that returns the sum of the two previous values when the index is greater than one, otherwise returns the zero-extended index. 4) A second naive recursive Fibonacci function from 8-bit to 32-bit with explicit base cases for zero and one and the same recurrence otherwise. 5) A polymorphic zero-extension helper with type parameters a and b (both finite) that takes a b-bit value and returns an (a+b)-bit value by prefixing a zero block of width a (state the fin constraints). Then declare properties that: (a) for all 8-bit inputs, all four Fibonacci implementations return exactly the same 32-bit result; (b) the base cases hold (value at index 0 is zero and at index 1 is one) and the recurrence relation holds for indices greater than one for each implementation; and (c) for all widths a, b and all b-bit inputs, the zero-extension result has high-order a bits equal to zero and low-order b bits equal to the input. Do not provide any proofs or solutions; only write the types, definitions, and properties."},{"role":"assistant","content":"```cryptol\nstreamFibs : [8] -> [32]\nstreamFibs x = fibs0@x\n   where fibs0 = [0]#fibs1\n         fibs1 = [1]#[ a + b | a <- fibs0\n                             | b <- fibs1\n                     ]\n\nstreamFibsAlt : [8] -> [32]\nstreamFibsAlt x = fibs@x\n   where fibs = [0,1]#[ a + b | a <- fibs\n                              | b <- drop`{1} fibs\n                      ]\n\nrecFibs : [8] -> [32]\nrecFibs n = if n > 1  then recFibs (n-1) + recFibs (n-2) else zx n\n\nzx : {a, b} (fin a, fin b) => [b] -> [a+b]\nzx m = zero#m\n\nrecFibs2 : [8] -> [32]\nrecFibs2 n =\n  if n == 0 then 0\n   | n == 1 then 1\n   else recFibs2 (n-1) + recFibs2 (n-2)\n```"}]}
{"filename":"saw-script\/intTests\/test_fold_rewrite_proof\/tupletest.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named tupletest that contains the following definitions: (1) A function foldFunction with type [8] -> [16] -> [16] -> [8]. It initializes a triple of the inputs and performs a left fold over all 16 possible 4-bit indices in ascending order. The step function fnc has type ([8], [16], [16]) -> [4] -> ([8], [16], [16]) and, given a state (x, y, z) and an index i, rotates y left and z right by i (on 16-bit words), computes a new 8-bit x as the bitwise XOR of the current x with the most-significant 8 bits of the rotated y and the most-significant 8 bits of the rotated z, and returns the updated triple (x, y, z). The result of foldFunction is the first component of the final triple. (2) A function foldFunction' with type [8] -> [16] -> [16] -> [8] that performs a left fold over all 16 possible 4-bit indices in descending order. Its step function fnc' has type ([8], [16], [16]) -> [4] -> ([8], [16], [16]) and, for state (x, y, z) and index i, first computes a new 8-bit x as the bitwise XOR of the current x with the most-significant 8 bits of y and the most-significant 8 bits of z, then rotates y right and z left by i, and returns the updated triple. The result of foldFunction' is the first component of the final triple. (3) Define a property foldFunctionInverse that universally quantifies an 8-bit value and two 16-bit values and asserts that applying foldFunction and then foldFunction' with the same 16-bit parameters recovers the original 8-bit value. Ensure all rotations are modulo 16 and indices are 4-bit wide."},{"role":"assistant","content":"```cryptol\nmodule tupletest where\n\nfoldFunction : [8] -> [16] -> [16] -> [8]\nfoldFunction x y z = output.0\n  where\n    output = foldl fnc (x, y, z) [0 .. 15]\n\nfnc : ([8], [16], [16]) -> [4] -> ([8], [16], [16])\nfnc (x, y, z) i = returnTup\n  where\n    returnTup = (x ^ take y' ^ take z', y', z')\n    y' = y <<< i\n    z' = z >>> i\n\nfoldFunction' : [8] -> [16] -> [16] -> [8]\nfoldFunction' x y z = output.0\n  where\n    output = foldl fnc' (x, y, z) [15, 14 .. 0]\n\nfnc' : ([8], [16], [16]) -> [4] -> ([8], [16], [16])\nfnc' (x, y, z) i = returnTup\n  where\n    returnTup = (x ^ take y ^ take z, y', z')\n    y' = y >>> i\n    z' = z <<< i\n\nproperty foldFunctionInverse x y z =\n    foldFunction' (foldFunction x y z) y z == x\n```"}]}
{"filename":"saw-script\/intTests\/test_ffi_verify_salsa\/salsa.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a property that universally quantifies over size parameters and inputs to assert equivalence between the externally bound encryption function and the imported stream\u2011cipher encryption function. Constrain the sizes so that one size parameter takes only the values 1 or 2, and the other does not exceed 2 to the power of 70. Quantify over a key that is a sequence of 16 times the first size parameter bytes, a nonce that is a sequence of 8 bytes, and a message that is a sequence of as many bytes as the second size parameter. Each byte is an 8\u2011bit value. The property must assert that, for all such valid sizes and inputs, invoking the external encryption binding on the key, nonce, and message returns exactly the same byte sequence as invoking the imported stream\u2011cipher encryption function on the same inputs. Use the property keyword, include the size constraints explicitly, and structure the equality so it can be checked by a solver across all valid key sizes (16 or 32 bytes), nonces (8 bytes), and message lengths (up to the specified bound). Do not implement the functions; only specify and quantify the conditions and the equality of their results."},{"role":"assistant","content":"```cryptol\nimport Primitive::Symmetric::Cipher::Stream::Salsa20 (Salsa20_encrypt)\n\nforeign cipher : {a, w} (a >= 1, 2 >= a, w <= 2^^70) => [16*a][8] -> [8][8] -> [w][8] -> [w][8]\ncipher = Salsa20_encrypt\n```"}]}
{"filename":"saw-script\/intTests\/test_cryptol_enums\/Test2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Test2 that contains the following definitions: a polymorphic enum type ETT a b with three constructors (one nullary, one carrying a, and one carrying a Bool and b); a function f1 with type forall c d. ETT c d -> [8] that returns one fixed 8-bit constant for the nullary constructor and a different fixed 8-bit constant for any other constructor; a function f1' with identical behavior and inferred type; a function f2 : ETT Bool () -> [8] that maps the nullary, unary, and binary constructors to three distinct fixed 8-bit constants; a function f3 : ETT Bool () -> [8] that maps the nullary constructor to the same first constant as above and any other constructor to a different constant; constants t11, t12, t13 as the results of applying f1 to each constructor (using suitable dummy payloads where needed), and t31, t32, t33 similarly for f3; a constant results1 that is a sequence of booleans asserting those six results equal their expected 8-bit constants; a helper cc3 : forall a b. b -> ETT a b that constructs the binary variant with its Bool field set to true; two 16-bit constants x and y; a function f4 : [16] -> ETT [16] [16] -> [16] that adds a base and the input word, then branches: for the binary variant add its second payload, the input, y, and a branch-specific offset; for the unary variant add its first payload, the input, y, and a different offset; for the nullary variant add the input, x, and another offset; constants t43a, t42a, t41a as applications of f4 to each constructor with concrete 16-bit arguments; and a constant results2 as booleans checking those three results match their expected 16-bit values."},{"role":"assistant","content":"```cryptol\nmodule Test2 where\n\nenum ETT a b = C1\n             | C2 a\n             | C3 Bool b\n\nf1 : {c, d} ETT c d -> [8]\nf1 e1 = case e1 of\n          C1 -> 101\n          _  -> 102\n\nf1' e1 = case e1 of\n           C1 -> 101\n           _  -> 102\n\nf2 : ETT Bool () -> [8]\nf2 e = case e of\n         C1     -> 101\n         C3 _ _ -> 103\n         C2 _   -> 102\n\nf3 : ETT Bool () -> [8]\nf3 e = case e of\n         C1      -> 101\n         _       -> 105\n           \/\/ ^ compiles to two default functions but they have different\n           \/\/   types.\n\nt11 = f1 C1\nt12 = f1 (C2 ())\nt13 = f1 (C3 True False)\n\nt31 = f3 C1\nt32 = f3 (C2 False)\nt33 = f3 (C3 True ())\n\nresults1 = [ t11 == 101\n           , t12 == 102\n           , t13 == 102\n           , t31 == 101\n           , t32 == 105\n           , t33 == 105\n           ]\n\n\/* sawcript idioms:\n\nreturn (type {{ f1  }})\nreturn (type {{ f1' }})\n\nreturn (normalize_term {{ t11 }})\nreturn (normalize_term {{ t12 }})\nreturn (normalize_term {{ t13 }})\n\nreturn (eval_int {{ t31 }})\nreturn (eval_int {{ t32 }})\nreturn (eval_int {{ t33 }})\n*\/\n\ncc3 : {a, b} b -> ETT a b\ncc3 = C3 True\n\nx : [16]\nx = 2\n\ny : [16]\ny = 1\n\nf4 : [16] -> ETT [16] [16] -> [16]\nf4 z e = 4 + z + case e of\n                   C3 _ b   ->     b + z + y + 32\n                   C2 a     -> a +     z + y + 16\n                   _        ->         z + x + 8\n\nt43a = f4 64 (C3 False 512) t42a = f4 64 (C2 128)       t41a = f4 64 C1             \nresults2 = [ t43a == 677\n           , t42a == 277\n           , t41a == 142\n           ]\n```"}]}
{"filename":"saw-script\/intTests\/test_constraint_guards\/Parameterized.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Parameterized that contains the following definitions: (1) a type-level numeric parameter gamma with constraints requiring it to be finite, at least 2, and such that the number of bits needed to represent gamma is at most 32; (2) a constant v whose type is a sequence of length gamma over bits. Specify v using guarded alternatives based on the value of gamma: if gamma equals 3 then v is the numeric value zero at width gamma; if gamma equals 2 then v is the numeric value one at width gamma; otherwise v is the numeric value two at width gamma. Ensure the guards are evaluated in order and that the numeric literals are polymorphic so they are interpreted at width gamma. Include the parameter block with the stated constraints and provide the explicit type annotation for v."},{"role":"assistant","content":"```cryptol\nmodule Parameterized where\n\nparameter\n    type gamma : #\n    type constraint (fin gamma, gamma >= 2, 32 >= width gamma)\n\nv : [gamma]\nv | (gamma == 3) => 0\n      | (gamma == 2) => 1\n  | () => 2\n```"}]}
{"filename":"saw-script\/intTests\/test_constraint_guards\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Test that contains the following definitions: (1) A function guard with a polymorphic numeric type parameter w that takes a bitvector of width w and returns an Integer. Implement guarded equations based on the type-level value w, evaluated top-to-bottom: return 0 when w equals 32; otherwise return 1 when w is at least 32; otherwise return 2 when w is less than 8; otherwise return 3 when w is neither 8 nor 9; otherwise return 4 as the default. (2) A function incomplete with a polymorphic numeric type parameter w that takes a bitvector of width w and returns a Bool. Provide only a single guarded equation that returns True when w equals 32; leave all other cases unspecified (i.e., no catch-all). (3) A value dependent with a polymorphic numeric type parameter n that produces a sequence of n bits. Use guards over n: when n equals 1, return a singleton sequence containing True; otherwise return a sequence of length n filled with False using repetition. Clearly state the type signatures, the role of the numeric parameters, and that the guards are constraints over these parameters (not runtime tests), with the first satisfied guard determining the result. Do not add properties or extra cases beyond those described."},{"role":"assistant","content":"```cryptol\nmodule Test where\n\nguard : {w} [w] -> Integer\nguard x\n  | (w == 32) => 0\n  | (w >= 32) => 1\n  | (w < 8) => 2\n  | (w != 8, w != 9) => 3\n  | () => 4\n\nincomplete : {w} [w] -> Bool\nincomplete x\n  | (w == 32) => True\n\ndependent : {n} [n]\ndependent\n  | n == 1 => [True]\n  | ()     => repeat False\n```"}]}
{"filename":"saw-script\/intTests\/test0052_smt_array_1\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named ArrayTest that imports the Array library and contains the following definitions: lookup_update_axiom_1 and lookup_update_axiom_2. Give each an explicit type signature returning a single Bit. For lookup_update_axiom_1, the inputs are: an array whose indices are 64-bit words and whose elements are 64-bit words, a 64-bit index, and a 64-bit element. Its body should return true exactly when performing an update at the given index with the given element and then looking up that same index yields the inserted element. For lookup_update_axiom_2, the inputs are: the same kind of array, two 64-bit indices, and a 64-bit element. Its body should return the logical implication that if the two indices are not equal, then a lookup at the first index is unchanged by an update performed at the second index. Use the array lookup and update operations from the imported array module, 64-bit word types for indices and elements, and the standard inequality and implication operators. Place both definitions with their type signatures inside the module."},{"role":"assistant","content":"```cryptol\nmodule ArrayTest where\n\nimport Array\n\nlookup_update_axiom_1 : Array [64] [64] -> [64] -> [64] -> Bit\nlookup_update_axiom_1 a i e = arrayLookup (arrayUpdate a i e) i == e\n\nlookup_update_axiom_2 : Array [64] [64] -> [64] -> [64] -> [64] -> Bit\nlookup_update_axiom_2 a i j e = i != j ==> arrayLookup (arrayUpdate a j e) i == arrayLookup a i\n```"}]}
{"filename":"saw-script\/intTests\/test_hash_table\/ht_simplified.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named HT that contains the following definitions and properties. Provide precise Cryptol types and function signatures. Definitions: (1) Record type for a table entry with a 64-bit key, 32-bit value, and 32-bit next index; and a tuple alias with the corresponding triple. Converters between the record and tuple forms. (2) Type-level constants for the bucket count (2) and pool size (5). 32-bit constants for a NULL index (all ones) and a value cap (5). (3) A hash table record with an array of bucket heads indexed by the bucket count and a 32-bit current-allocation index; its tuple alias and converters. (4) An array type for a pool of entries of the given size; its tuple representation (array of triples) and converters. (5) Initializers: empty table (all buckets NULL, current index 0), empty entry (zero key\/value, next NULL), and zeroed entry pool; and an initial state combining them. (6) A djb2-style 32-bit hash over 64-bit input processed as eight bytes; a bucket-selection function returning the hash modulo the bucket count. (7) A state record carrying the entry pool and table, with tuple converters and a zeroed error state. (8) A return-record type for increment operations containing the updated 32-bit value, the 32-bit slot index, and the new state. (9) Predicates: index validity (either within a bound or equal to NULL) and state validity (current index within pool size; all bucket heads valid; for all allocated entries, next is a valid index strictly greater than the entry\u2019s index and value not above the cap). (10) Functions: update of a predecessor\u2019s next pointer; insertion helper that allocates a new node with value 1 and links it either after a predecessor or as a new bucket head; guarded insertion that fails when the pool is full; a bounded loop that searches a bucket chain tracking current and previous indices; a step that compares the key and either recurses or handles a hit; a hit handler that increments the value up to the cap; and a top-level increment that buckets the key, searches up to pool size + 1 steps, and either updates an existing node or inserts a new one. Properties: (a) Round-trip equivalence for all record\/tuple converters (entry, table, pool, and state). (b) Bucket selection is always within range. (c) The initial state satisfies the validity predicate. (d) Updating a predecessor changes only its next pointer as specified. (e) If inputs are valid and capacity remains, insertion preserves validity and increases the current index by exactly one; if full, state is unchanged with a NULL slot and zero value. (f) For an existing key with value below the cap, the top-level increment increases the value by one and preserves the slot; at the cap, the value and state are unchanged except for returned metadata. (g) The top-level increment preserves validity and never increases the current index by more than one."},{"role":"assistant","content":"```cryptol\nmodule HT where\n\ntype Entry =   \n    { key    : [64]\n    , value  : [32]\n    , next   : [32]\n    }\n\ntype EntryTuple = ([64],[32],[32])\n\nentryToTuple : Entry -> EntryTuple\nentryToTuple e = (e.key, e.value, e.next)\n\ntupleToEntry : EntryTuple -> Entry\ntupleToEntry (key_t, value_t, next_t) = {key = key_t, value = value_t, next = next_t}\n\ntype NUMBUCKETS = 2\n\ntype POOLSIZE = 5\n\nNULL : [32]\nNULL = 0xffffffff\n\nCAP : [32]\nCAP = 5\n\ntype PooledHashTable =   \n    { buckets    : [NUMBUCKETS][32]\n    , cur_entry  : [32]\n    }\n\ntype PooledHashTableTuple = ([NUMBUCKETS][32],[32])\n\npooledHashTableToTuple : PooledHashTable -> PooledHashTableTuple\npooledHashTableToTuple pt = (pt.buckets, pt.cur_entry)\n\ntupleToPooledHashTable : PooledHashTableTuple -> PooledHashTable\ntupleToPooledHashTable (bucket_tuple,cur_entry_tuple) = {buckets = bucket_tuple, cur_entry = cur_entry_tuple}\n\ntype EntryPool = [POOLSIZE] Entry\n\ntype EntryPoolTuple = [POOLSIZE]([64], [32], [32])\n\nentryPoolToTuple : EntryPool -> EntryPoolTuple\nentryPoolToTuple ep = map entryToTuple ep\n\ntupleToEntryPool : EntryPoolTuple -> EntryPool\ntupleToEntryPool ep = map tupleToEntry ep\n\ninitTable : PooledHashTable\ninitTable = {cur_entry = 0, buckets = repeat NULL}\n\ninitEntry : Entry\ninitEntry = {key = 0, value = 0, next = NULL}\n\ninitEntryPool : EntryPool\ninitEntryPool = zero\n\nhash : [64] -> [32]\nhash v = foldr (\\c h -> 33 * h + (0 # c)) 5381 ((split v):[8][8])\n\ngetBucket : [64] -> [32]\ngetBucket key = hash(key) % `NUMBUCKETS\n\ntype State = { ep : EntryPool\n             , pht : PooledHashTable\n             }\n\nerrorState : State\nerrorState = zero:State\n\nstateToTuple : State -> ([POOLSIZE]([64], [32], [32]), ([NUMBUCKETS][32], [32]))\nstateToTuple state = (entryPoolToTuple state.ep, pooledHashTableToTuple state.pht)\n\ntupleToState : ([POOLSIZE]([64], [32], [32]), ([NUMBUCKETS][32], [32])) -> State\ntupleToState (entryPoolTuple, phtTuple) = {ep = tupleToEntryPool entryPoolTuple, pht = tupleToPooledHashTable phtTuple}\n\ninitState : State\ninitState = {ep = initEntryPool, pht = initTable}\n\ntype IncrementValueRet = { value : [32]\n                         , slot : [32]\n                         , state : State\n                         }\n\nis_valid_index : [32] -> [32] -> Bool\nis_valid_index n i = i < n \\\/ i == NULL\n\nis_valid_state : State -> Bool\nis_valid_state state =\n  state.pht.cur_entry <= `POOLSIZE\n    \/\\ all (is_valid_index state.pht.cur_entry) state.pht.buckets\n    \/\\ all (\\(i, e) -> i < state.pht.cur_entry ==> ((is_valid_index state.pht.cur_entry e.next) \/\\ i < e.next \/\\ e.value <= CAP)) (zip (take [0 ...]) state.ep)\n\nupdatePrev : EntryPool -> [32] -> [32] -> EntryPool\nupdatePrev epIn cur_index prev_index = ret where\n    prevEntry = epIn@prev_index\n    ret = update epIn prev_index {key = prevEntry.key, value = prevEntry.value, next = cur_index }\n\nincrementNextValue1 : [64] -> [32] -> [32] -> State -> IncrementValueRet\nincrementNextValue1 key prev_index bucket state = ret where\n    cur_index = state.pht.cur_entry\n    newEp = update state.ep cur_index {key = key, value = 1, next = NULL}\n    ret = if(prev_index != NULL) \n        then \n            { value = 1\n            , slot = cur_index \n            , state = \n              { ep = updatePrev newEp cur_index prev_index \n              , pht = {cur_entry = cur_index + 1, buckets = state.pht.buckets}\n              }\n            }\n        else \n            { value = 1\n            , slot = cur_index\n            , state = \n              { ep = newEp\n              , pht = {cur_entry = cur_index + 1, buckets = update state.pht.buckets bucket cur_index}\n              }\n            }\n\nincrementNextValue : [64] -> [32] -> [32] -> State -> IncrementValueRet\nincrementNextValue key prev_index bucket state = \n    if (state.pht.cur_entry < `POOLSIZE) \n        then incrementNextValue1 key prev_index bucket state\n        else {value = 0, slot = NULL, state = state}\n\nincrementValueLoop : [64] -> [64] -> [32] -> [32] -> State -> (Bool, [32], [32], ([32], State))\nincrementValueLoop count key cur_index prev_index state = \n        if (count <= 0) then (False, NULL, NULL, (0, errorState))\n    else \n        if (cur_index == NULL)\n            then (True, cur_index, prev_index, (0, state))\n            else checkCurEntry count key cur_index prev_index state\n\ncheckCurEntry : [64] -> [64] -> [32] -> [32] -> State -> (Bool, [32], [32], ([32], State))\ncheckCurEntry count key cur_index prev_index state = ret where\n    cur_entry = state.ep@cur_index\n    ret = if(cur_entry.key == key)\n        then keyHit key cur_index prev_index cur_entry state\n        else incrementValueLoop (count - 1) key cur_entry.next cur_index state\n\nkeyHit : [64] -> [32] -> [32] -> Entry -> State -> (Bool, [32], [32], ([32], State))\nkeyHit key cur_index prev_index cur_entry state = ret where\n    curValue = cur_entry.value\n    ret = if (curValue < CAP) \n        then (False, cur_index, prev_index, (curValue + 1, {ep = (update state.ep cur_index {key = cur_entry.key, value = curValue + 1, next = cur_entry.next}), pht = state.pht}))\n        else (False, cur_index, prev_index, (curValue, state))\n\nincrementValueFull : [64] -> State -> IncrementValueRet\nincrementValueFull key state = ret where\n    bucket = getBucket(key)\n    cur_index = state.pht.buckets@bucket\n    prev_index = NULL\n    (continue, n_cur_index, n_prev_index, (value, nstate)) = incrementValueLoop (`POOLSIZE + 1) key cur_index prev_index state\n    ret = if continue then incrementNextValue key n_prev_index bucket nstate else {value = value, slot = n_cur_index, state = nstate}\n```"}]}
{"filename":"saw-script\/intTests\/test0037_popcount\/spec.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define three functions over bit sequences and their type signatures using a polymorphic length parameter n. The first function returns the population count of an n-bit input: constrain n to be finite and at least 1, and implement it by folding over the bits, mapping each bit to 1 if set and 0 otherwise, summing with zero as the base; the result is an n-bit value. The second function returns the count of leading zeros of an n-bit input: constrain n to be finite, pair each input bit (from most significant to least) with its 0-based index, then perform a right fold that at each step returns the current index if the bit is set, otherwise propagates the accumulator; initialize the accumulator to the value n so an all-zero input yields n; the result is an n-bit value. The third function returns the count of trailing zeros of an n-bit input: constrain n to be finite, implement it by reversing the input and invoking the leading-zero function; the result is an n-bit value. Provide precise Cryptol type signatures that reflect the above constraints for each function."},{"role":"assistant","content":"```cryptol\npopcount : {n} (n >= 1, fin n) => [n] -> [n]\npopcount x = foldr (+) zero [ if b then 1 else 0 | b <- x ]\n\nclz : {n} fin n => [n] -> [n]\nclz x = foldr f `n [ (b,i) | i <- [0 ...] | b <- x ]\n where\n f (b,i) r = if b then i else r\n\nctz : {n} fin n => [n] -> [n]\nctz x = clz (reverse x)\n```"}]}
{"filename":"saw-script\/intTests\/test_w4_unint_rme\/Code.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Code that contains the following definitions and types, matching the behavior of the given implementation: (1) A type alias State for a sequence of five 64-bit words. (2) A type constraint ValidRnd over a numeric parameter rnd that enforces rnd \u2264 16. (3) A constant Const of 16 round constants, each 64 bits, with the same values as the implementation. (4) A constant SBoxTable of 32 entries, each 5 bits, with the same mapping as the implementation. (5) A function SBox: [5] -> [5] that returns the SBoxTable entry at the input index. (6) A function pC: State -> [64] -> State that XORs the 64-bit round constant into the third lane of the state, leaving other lanes unchanged. (7) A function pS: State -> State that applies the 5-bit SBox independently to each of the 64 bit-columns of the state (transpose-map-transpose structure). (8) A helper sigma: [64] -> [6] -> [6] -> [64] that returns x XOR (x rotated right by the first amount) XOR (x rotated right by the second amount). (9) A function pL: State -> State that applies sigma to each lane with these rotation pairs: lane0 (19,28), lane1 (61,39), lane2 (1,6), lane3 (10,17), lane4 (7,41). (10) A function round: State -> [64] -> State defined as the composition pC then pS then pL. (11) A polymorphic function Ascon_p: {rnd} (ValidRnd rnd) => State -> State that, for any rnd satisfying the constraint, iteratively applies round starting from the input state over the sequence of round constants obtained by dropping rnd elements from the end of Const, using a left fold. Provide precise Cryptol type signatures for all functions and constants."},{"role":"assistant","content":"```cryptol\nmodule Code where\n\ntype constraint ValidRnd rnd = rnd <= 16\n\nAscon_p : {rnd} (ValidRnd rnd) => State -> State\nAscon_p S = foldl round S (drop`{back=rnd} Const)\n\nround : State -> [64] -> State\nround S ci = pL (pS (pC S ci))\n\ntype State = [5][64]\n\npC : State -> [64] -> State\npC [S0, S1, S2, S3, S4] ci = [S0, S1, S2 ^ ci, S3, S4]\n\nConst : [16][64]\nConst =\n    [ 0x000000000000003c\n    , 0x000000000000002d\n    , 0x000000000000001e\n    , 0x000000000000000f\n    , 0x00000000000000f0\n    , 0x00000000000000e1\n    , 0x00000000000000d2\n    , 0x00000000000000c3\n    , 0x00000000000000b4\n    , 0x00000000000000a5\n    , 0x0000000000000096\n    , 0x0000000000000087\n    , 0x0000000000000078\n    , 0x0000000000000069\n    , 0x000000000000005a\n    , 0x000000000000004b\n    ]\n\npS : State -> State\npS S = transpose (map SBox (transpose S))\n\nSBox : [5] -> [5]\nSBox i = SBoxTable@i\n\nSBoxTable : [32][5]\nSBoxTable =\n    map drop\n    [ 0x04, 0x0b, 0x1f, 0x14, 0x1a, 0x15, 0x09, 0x02\n    , 0x1b, 0x05, 0x08, 0x12, 0x1d, 0x03, 0x06, 0x1c\n    , 0x1e, 0x13, 0x07, 0x0e, 0x00, 0x0d, 0x11, 0x18\n    , 0x10, 0x0c, 0x01, 0x19, 0x16, 0x0a, 0x0f, 0x17\n    ]\n\npL : State -> State\npL [S0, S1, S2, S3, S4] =\n    [ sigma S0 19 28\n    , sigma S1 61 39\n    , sigma S2  1  6\n    , sigma S3 10 17\n    , sigma S4  7 41\n    ]\n    where\n        sigma : [64] -> [6] -> [6] -> [64]\n        sigma x i j = x ^ x>>>i ^ x>>>j\n```"}]}
{"filename":"saw-script\/intTests\/test_saw_submodule_access1\/F.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named F that contains the following definitions: import modules B and C; top-level constants top0, topd2, topd3, and d00; a submodule D3 with constants d2, d3D2, d2', and a private helper d3P; and inside D3 a nested submodule D4 with constant d3. Specify the computations precisely in plain language: top0 evaluates to the sum of 2000, the value imported as b from B, and the value imported as c from C; topd2 is 5 plus the value of D3\u2019s d2; topd3 is 10 plus the value of D3.D4\u2019s d3; d00 is a 32-bit word equal to 1. Within D3, define d2 as 10000 plus the top-level top0; define d3D2 as 1 plus the nested D4\u2019s d3; define d2' as 1 plus the private helper d3P; define d3P (private to D3) as 1 plus d2. Within D3.D4, define d3 as 20000 plus the top-level top0 and D3\u2019s d2. Ensure qualified references resolve correctly across scopes, respecting the privacy of d3P (only visible within D3). All additions operate over finite word values with widths sufficient to hold the sums; only d00 is explicitly annotated as a 32-bit word, and other widths may be left to type inference as compatible word sizes."},{"role":"assistant","content":"```cryptol\nmodule F where\nimport B\nimport C\n\ntop0  = 2000 + b + c\ntopd2 = 5  + D3::d2\ntopd3 = 10 + D3::D4::d3\n\nd00 : [32]\nd00 = 1 \nsubmodule D3 where\n  d2   = 10000 + top0\n  d3D2 =     1 + D4::d3\n  d2'  =     1 + d3P\n\n  private\n    d3P = 1 + d2\n\n  submodule D4 where\n    d3 = 20000 + top0 + d2\n```"}]}
{"filename":"saw-script\/intTests\/test_saw_submodule_access1\/D.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named D that imports modules B and C. In D, declare a type synonym DTySy for a 32-bit sequence. Define constants d00 and d01 as 32-bit values: d00 is the sum of the literal 2000 with values imported from B and C, and d01 is the sum of the literal 5 with the value defined as d2 in submodule D2, using a qualified reference. Define a submodule D2 containing a 32-bit type synonym D2TySy and a 32-bit constant d2 equal to d00 plus the literal 10000. Inside D2, define a submodule D3 containing a 32-bit type synonym D3TySy and a 32-bit constant d3 equal to d00 plus d2 plus the literal 1. Provide explicit type signatures for d00, d01, d2, and d3 as 32-bit sequences, and state that arithmetic is modulo 2^32. Assume the imported values from B and C used in the sums are 32-bit sequences so the additions type-check. Include the following verification artifacts in module D: a property that d00 equals 2000 plus the two imported values; a property that d2 equals d00 plus 10000; a property that d3 equals d00 plus d2 plus 1; and a property that d01 equals 5 plus the qualified value from D2. Ensure the properties are stated so they can be discharged by a solver without additional preconditions. Use qualified naming when referring across submodules, and ensure all submodules and synonyms are nested and exported as in the structure described above."},{"role":"assistant","content":"```cryptol\nmodule D where\nimport B\nimport C\n\nd00 = 2000 + b + c\nd01 = 5 + D2::d2\n\ntype DTySy = [32]\n\nsubmodule D2 where\n  d2 = d00 + 10000\n\n  type D2TySy = [32]\n\n  submodule D3 where\n  d3 = d00 + d2 + 1\n\n  type D3TySy = [32]\n```"}]}
{"filename":"saw-script\/intTests\/test_saw_submodule_access1\/UseFunctors.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named UseFunctors that contains the following: (1) A submodule M with an 8-bit constant x set to 0x02, and within it a submodule M1 with an 8-bit constant x set to 0x03. (2) A top-level definition ex1 with type [8], computed as the 8-bit modular sum of M::x and M::M1::x. (3) A parameterized submodule F with a parameter p: [8]; inside F, a submodule FM defining an 8-bit value z as p + 0x03, and a definition f: [8] equal to 2 * p. (4) An instantiation submodule I of F with the parameter p bound to the 8-bit value 11. (5) A top-level definition ex2 with type [8], computed as the 8-bit modular sum of I::f and the 8-bit constant 2. Provide explicit type signatures for all exposed values, ensure all literals are sized [8], and use submodule access via the :: operator. Do not prove properties; only define the module, submodules, parameters, and computations as specified."},{"role":"assistant","content":"```cryptol\nmodule UseFunctors where\n\nsubmodule M where\n    x = 0x02\n\n    submodule M1 where\n      x = 0x03\n\nex1 = M::x + M::M1::x  \nsubmodule F where\n  parameter\n    p: [8]\n\n  submodule FM where\n    z = 0x03 + p\n\n  f = 2 * p\n\nsubmodule I = submodule F where\n  p = 11\n\nex2 = I::f + 2\n```"}]}
{"filename":"saw-script\/intTests\/test_ffi_verify\/test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol verification file containing properties that confirm each foreign binding matches its intended behavior: (1) For 8-, 16-, and 32-bit words, the three binary functions behave exactly like addition, subtraction, and multiplication. (2) For 64-bit division, the result is zero precisely when the divisor is zero, otherwise it equals unsigned division. (3) The 3-to-8 bit input extension equals zero-extension; the 8-to-3 bit output masking returns the low 3 bits by dropping the high 5. (4) The zero-width function is the identity on empty sequences. (5) The unary bit negation flips the bit, and double negation returns the original bit. (6) The synonym-typed predicate returns true exactly when a 32-bit value zero-extended to 64 bits equals the 64-bit argument. (7) The 10-element sum equals the built-in sum over ten 32-bit words. (8) The 5-element reversal equals sequence reversal over five 64-bit words. (9) For the compound tuple\/record transformer: the first field splits a 32-bit word into two 16-bit halves; the second record concatenates a 3\u00d720 array with a 5\u00d720 array, and partitions a 10-element sequence into its first and last five elements. (10) For any n with finite size and width at most 64, the unit-argument function returns the numeric type parameter n encoded as a 64-bit word. (11) The polymorphic sum equals the built-in sum for any finite length. (12) The inits function produces all non-empty prefixes of an n-byte sequence, flattened to length n(n+1)\/2; add helper properties asserting the loop invariant and size constraints under l + m = n and m \u2265 1. (13) The triple-zip multiplication equals pointwise multiplication truncated to the minimum length. (14) The reshape output fields are correct dimension permutations of the input. (15) The tuple identity returns its input unchanged."},{"role":"assistant","content":"```cryptol\nforeign add8 : [8] -> [8] -> [8]\nadd8 = (+)\n\nforeign sub16 : [16] -> [16] -> [16]\nsub16 = (-)\n\nforeign mul32 : [32] -> [32] -> [32]\nmul32 = (*)\n\nforeign div64 : [64] -> [64] -> [64]\ndiv64 x y = if y == 0 then 0 else x \/ y\n\nforeign extendInput : [3] -> [8]\nextendInput = zext\n\nforeign maskOutput : [8] -> [3]\nmaskOutput = drop\n\nforeign noBits : [0] -> [0]\nnoBits x = x\n\nforeign not : Bit -> Bit\nnot x = ~ x\n\ntype Word32 = [32]\ntype Word64 = [64]\ntype MyFunc = Word32 -> [64] -> Bit\n\nforeign usesTypeSynonym : MyFunc\nusesTypeSynonym x y = zext x == y\n\nforeign sum10 : [10]Word32 -> Word32\nsum10 = sum\n\nforeign reverse5 : [5]Word64 -> [5]Word64\nreverse5 = reverse\n\nforeign compoundTypes : ([32], { x : [10], y : [3][20] }) -> { z : [5][20] }\n  -> { a : ([16], [16]), b : { c : [8][20], d : [5], e : [5] } }\ncompoundTypes (n, { x = x, y = y }) { z = z } =\n  { a = splitAt `{16} n\n  , b = { c = y # z, d = take `{5} x, e = drop `{5} x }\n  }\n\nforeign typeToValue : {n} (fin n, width n <= 64) => () -> [64]\ntypeToValue () = `n\n\nforeign sumPoly : {n} (fin n) => [n]Word32 -> Word32\nsumPoly = sum\n\nforeign inits : {n} (fin n) => [n][8] -> [n * (n + 1) \/ 2][8]\ninits xs\n  | n == 0 => []\n  | n >  0 => initsLoop xs' x []\n    where\n      (x : [1]_) # xs' = xs\n\ninitsLoop : {n, l, m, a} (fin l, fin m, l + m == n, m >= 1) =>\n        [l]a -> [m]a ->\n        [((m - 1) * ((m - 1) + 1)) \/ 2]a ->\n        [(n * (n + 1)) \/ 2]a\ninitsLoop ys zs acc\n  | l == 0 => acc # zs\n  | l >  0 => initsLoop ys' (zs # y) (acc # zs)\n   where (y : [1]_) # ys' = ys\n\nforeign zipMul3 : {n, m, p} (fin n, fin m, fin p) =>\n  [n][27] -> [m][27] -> [p][27] -> [min n (min m p)][27]\nzipMul3 xs ys zs = [x * y * z | x <- xs | y <- ys | z <- zs]\n\nforeign reshape : {a, b, c, d} (fin a, fin b, fin c, fin d) =>\n  [a][b][c][d][32] -> { dcba : [d][c][b][a][32], acbd : [a][c][b][d][32] }\nreshape x =\n  { dcba = split (split (split (join (join (join x)))))\n  , acbd = split (split (split (join (join (join x)))))\n  }\n\nforeign same : ([32], [10], [8][20]) -> ([32], [10], [8][20])\nsame x = x\n\nforeign notnot : Bit -> Bit\nnotnot x = not (not x)\n```"}]}
{"filename":"saw-script\/intTests\/test2337\/test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define an algebraic data type named Letter with exactly two nullary constructors A and B. Provide type signatures and implementations for two total functions: (1) eqLetter, which takes two values of type Letter and returns a Bit indicating boolean equality (True when both arguments are the same constructor, False otherwise), implemented via exhaustive pattern matching on both arguments; and (2) letterA, which takes a Bool and returns a Letter, yielding A when the input is true and B when it is false, using a conditional expression. Ensure all cases are covered explicitly and that the function types match these behaviors precisely."},{"role":"assistant","content":"```cryptol\nenum Letter = A | B\n\neqLetter : Letter -> Letter -> Bit\neqLetter l1 l2 =\n  case l1 of\n    A ->\n      case l2 of\n        A -> True\n        B -> False\n    B ->\n      case l2 of\n        A -> False\n        B -> True\n\nletterA : Bool -> Letter\nletterA x =\n  if x then A else B\n```"}]}
{"filename":"saw-script\/crux-mir-comp\/test\/symb_eval\/cryptol\/uninterp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named test::symb_eval::cryptol::uninterp that contains the following definitions: (1) a type alias for a 64\u2011bit word; (2) a function pow with type 64\u2011bit word -> 64\u2011bit word -> 64\u2011bit word that performs exponentiation by scanning the exponent\u2019s bits from most significant to least, starting from an accumulator value of 1, squaring the accumulator each step using mult, and conditionally multiplying by the base when the current bit is 1; the result is the final accumulator; (3) a 65\u2011bit constant representing the irreducible binary polynomial x^64 + x^4 + x^3 + x + 1; (4) a function mult with type 64\u2011bit word -> 64\u2011bit word -> 64\u2011bit word declared without an implementation and used by pow for both squaring and multiplication. State all types explicitly and express pow using a sequence of per\u2011bit accumulator values, returning the last value as the result."},{"role":"assistant","content":"```cryptol\nmodule test::symb_eval::cryptol::uninterp where\n\ntype U64 = [64]\n\npow : U64 -> U64 -> U64\npow n k = last vals where\n    sq x = mult x x\n    vals = [1]\n         # [ if i then mult n acc else acc\n           | acc <- map sq vals\n           | i   <- k ]\n\nirreducible : [65]\nirreducible = <| x^^64 + x^^4 + x^^3 + x + 1 |>\n\nmult : U64 -> U64 -> U64\nmult = undefined\n```"}]}
{"filename":"saw-script\/crux-mir-comp\/test\/symb_eval\/cryptol\/basic.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named test::symb_eval::cryptol::basic that contains the following definitions: (1) A function addByte that takes two 8-bit words and returns their sum as an 8-bit word using modular arithmetic. (2) A function tupleArg that takes a pair of 8-bit words, destructures it into two values, and returns their modular sum as an 8-bit word. (3) A function tupleRet that takes two 8-bit words and returns a pair whose first element is their modular sum and second element is their modular difference (first minus second), both as 8-bit words. (4) A function arrayArg that takes a sequence of length 2 containing 8-bit words, destructures it into two values, and returns their modular sum as an 8-bit word. (5) A function arrayRet that takes two 8-bit words and returns a length-2 sequence whose first element is their modular sum and second element is their modular difference, both 8-bit words. (6) A polymorphic function xorBits with a size parameter n, constrained to finite n, that takes two n-bit words and returns their bitwise exclusive-or as an n-bit word. Provide precise Cryptol type signatures for each function reflecting these domains and codomains, including the {n} (fin n) constraint for the polymorphic function, and ensure all arithmetic on fixed-width words is modulo 2^width."},{"role":"assistant","content":"```cryptol\nmodule test::symb_eval::cryptol::basic where\n\naddByte : [8] -> [8] -> [8]\naddByte x y = x + y\n\ntupleArg : ([8], [8]) -> [8]\ntupleArg (x, y) = x + y\n\ntupleRet : [8] -> [8] -> ([8], [8])\ntupleRet x y = (x + y, x - y)\n\narrayArg : [2][8] -> [8]\narrayArg [x, y] = x + y\n\narrayRet : [8] -> [8] -> [2][8]\narrayRet x y = [x + y, x - y]\n\nxorBits : {n} (fin n) => [n] -> [n] -> [n]\nxorBits x y = x ^ y\n```"}]}
{"filename":"saw-script\/crux-mir-comp\/test\/symb_eval\/cryptol\/size_poly_nested.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named test::symb_eval::cryptol::size_poly_nested that contains the following definition: a function f with a type signature parameterized by two size variables m and n, each required to be finite. The function takes a two-dimensional sequence consisting of m rows and n columns of 8-bit words and returns an 8-bit word. Implement f by first flattening the 2D sequence into a 1D sequence of length m*n and then returning the modular arithmetic sum of all bytes in that sequence. Include the explicit type signature with the size parameters and constraints, and use Cryptol\u2019s built-in combinators for flattening nested sequences and summing a sequence."},{"role":"assistant","content":"```cryptol\nmodule test::symb_eval::cryptol::size_poly_nested where\n\nf: {m,n} (fin m, fin n) => [m][n][8] -> [8]\nf xs = sum (join xs)\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw\/test-files\/Foo.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Foo that contains the following definitions:\n- A polymorphic function id with a type parameter that takes a value of any type and returns the same value unchanged; include the corresponding universally quantified type signature.\n- A constant x that is an 8-bit word with the decimal value 255.\n- A polymorphic function add with a finite-width constraint on its type parameter; it takes two bitvectors of the same width and returns their modular sum using the built-in addition operator; provide the appropriate type signature reflecting the width parameter and constraint.\n- A record constant foo with two fields named foo and bar, each a 32-bit word; assign decimal values 23 and 99 to these fields, respectively, and provide its record type.\n- A function getFoo that takes a record with 32-bit fields foo and bar and returns the value of the foo field; include its type signature mapping such a record to a 32-bit word."},{"role":"assistant","content":"```cryptol\nmodule Foo where\n\nid : {a} a -> a\nid x = x\n\nx : [8]\nx = 255\n\nadd : {a} (fin a) => [a] -> [a] -> [a]\nadd = (+)\n\nfoo : {foo : [32], bar : [32]} \nfoo = {foo = 23, bar = 99}\n\ngetFoo : {foo : [32], bar : [32]}  -> [32]\ngetFoo x = x.foo\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/drbg\/drbg-helpers.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that provides all of the following: (1) a numeric type alias representing a 16-byte key length; (2) a constant for the maximum sequence number, typed as a bitvector whose width equals the cipher\u2019s block size (in bytes) times 8, and defined as the bitwise complement of zero at that width; (3) a wrapper for the library\u2019s deterministic random bit generator \u201cgenerate\u201d operation, specialized so that the bit-count parameter equals a type variable n (the seed length) and the number of blocks is fixed at 2; give it the type: DRBG state -> [n] -> Bit -> ([n], DRBG state), and implement it by instantiating the generic generator with those parameters; (4) a 128-bit block-encryption helper that accepts a 16-byte key and a one-block message, both as sequences of 8-bit words, converts them to bitvectors, applies the in-scope block-encrypt primitive, and returns the ciphertext split back into bytes; use the type: [16][8] -> [B][8] -> [B][8], where B is the cipher\u2019s block size in bytes; and (5) two integer constants that serve as mode identifiers for 128-bit and 256-bit modes with values 0 and 1, respectively. Clearly state all types, polymorphic size variables, and any assumptions about the in-scope cipher\/block size and DRBG state type."},{"role":"assistant","content":"```cryptol\nimport DRBG\nimport AES\n\ntype keysize = 16 \nmax_seq_number : [blocksize*8]\nmax_seq_number = ~zero\n\ndrbg_generate_seedlen : s2n_drbg -> [seedlen] -> Bit -> ([seedlen], s2n_drbg)\ndrbg_generate_seedlen = drbg_generate `{n=seedlen,blocks=2}\n\nencrypt_128 : [keysize][8] -> [blocksize][8] -> [blocksize][8]\nencrypt_128 key msg =\n  split (block_encrypt (join key) (join msg))\n\nmode_128 = 0\nmode_256 = 1\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/Hashing.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Hashing that contains the following definitions: (1) Import the SHA256 module to use its state type and primitives. (2) Eight 32-bit constants for hash identifiers, assigned distinct small nonnegative integers. (3) Two record types representing C-style SHA512 and SHA256 states, with fields: h (array of 8 words, 64-bit for 512, 32-bit for 256), Nl and Nh (counter halves matching the hash width), u (array of 16 words of the hash width), num (32-bit), and md_len (32-bit). Provide type synonyms for the total packed bit sizes of each record. (4) Two packing functions that serialize each record into a bitvector by concatenating, in order: h, Nl, Nh, the flattened u array, num, then md_len. (5) Byte-length constants for SHA256 and SHA512 digests (32 and 64). (6) A function that converts a SHA512 C-state to a SHA256 C-state by packing the 512-state and extracting the leading segment sized for the 256-state, then splitting back into fields. (7) A function that reconstructs a SHA512 C-state from an original SHA512 C-state and a SHA256 C-state by packing the 256-state and splicing it into the front of the packed 512-state while preserving the trailing remainder from the original, then unpacking. (8) Bidirectional conversions between a SHA256 C-state and SHA256State: map h directly; map u to\/from the block as bytes; set n from the low 32 bits of num; set sz as Nh concatenated with Nl; set md_len to the 32-byte constant; zero-extend n when forming num. (9) Bridge conversions between SHA512 C-state and SHA256State via the 256 C-state. (10) Wrapper functions that, given a SHA512 C-state, perform SHA256 initialization, length-polymorphic update (with a fin constraint on the input length), and finalization by converting to\/from SHA256State, returning the updated SHA512 C-state or the 32-byte digest split into bytes. Ensure all bit widths, concatenations, splits, and takes\/drops are consistent."},{"role":"assistant","content":"```cryptol\nmodule Hashing where\n\nimport SHA256\n\nS2N_HASH_NONE     = 0:[32]\nS2N_HASH_MD5      = 1:[32]\nS2N_HASH_SHA1     = 2:[32]\nS2N_HASH_SHA224   = 3:[32]\nS2N_HASH_SHA256   = 4:[32]\nS2N_HASH_SHA384   = 5:[32]\nS2N_HASH_SHA512   = 6:[32]\nS2N_HASH_MD5_SHA1 = 7:[32]\n\ntype SHA512_c_state =\n  { h      : [8][64]\n  , Nl     : [64]\n  , Nh     : [64]\n  , u      : [16][64]\n  , num    : [32]\n  , md_len : [32]\n  }\ntype SHA512_c_bits = 8*64+64+64+16*64+32+32\n\njoin512_c_state : SHA512_c_state -> [SHA512_c_bits]\njoin512_c_state st = join st.h # st.Nl # st.Nh # join st.u # st.num # st.md_len\n\ntype SHA256_c_state =\n  { h      : [8][32]\n  , Nl     : [32]       , Nh     : [32]       , u      : [16][32]   , num    : [32]       , md_len : [32]       }                   type SHA256_c_bits = 8*32+32+32+16*32+32+32\n\njoin256_c_state : SHA256_c_state -> [SHA256_c_bits]\njoin256_c_state st = join st.h # st.Nl # st.Nh # join st.u # st.num # st.md_len\n\ntype SHA256_DIGEST_LENGTH = 32\ntype SHA512_DIGEST_LENGTH = 64\n\nsha512_c_state_to_sha256_c_state : SHA512_c_state -> SHA256_c_state\nsha512_c_state_to_sha256_c_state st =\n  { h      = split (take bits)\n  , Nl     = take (drop`{front=8*32} bits)\n  , Nh     = take (drop`{front=8*32+32} bits)\n  , u      = split (take (drop`{front=8*32+32+32} bits))\n  , num    = take (drop`{front=8*32+32+32+16*32} bits)\n  , md_len = drop`{front=8*32+32+32+16*32+32} bits\n  }\n  where\n    bits : [SHA256_c_bits]\n    bits = take bits0\n    bits0 : [SHA512_c_bits]\n    bits0 = join512_c_state st\n\nsha256_c_state_to_sha512_c_state : SHA512_c_state -> SHA256_c_state -> SHA512_c_state\nsha256_c_state_to_sha512_c_state st0 st =\n  { h      = split (take bits)\n  , Nl     = take (drop`{front=8*64} bits)\n  , Nh     = take (drop`{front=8*64+64} bits)\n  , u      = split (take (drop`{front=8*64+64+64} bits))\n  , num    = take (drop`{front=8*64+64+64+16*64} bits)\n  , md_len = drop`{front=8*64+64+64+16*64+32} bits\n  }\n  where\n    bits : [SHA512_c_bits]\n    bits = join256_c_state st # drop bits0\n    bits0 : [SHA512_c_bits]\n    bits0 = join512_c_state st0\n\nsha256_c_state_to_sha256_state : SHA256_c_state -> SHA256State\nsha256_c_state_to_sha256_state st =\n  { h     = st.h\n  , block = split (join st.u)\n  , n     = drop st.num\n  , sz    = st.Nh # st.Nl\n  }\n  where\n    bits : [SHA256_c_bits]\n    bits = join256_c_state st\n\nsha256_state_to_sha256_c_state : SHA256State -> SHA256_c_state\nsha256_state_to_sha256_c_state st =\n  { h      = st.h\n  , Nl     = Nl\n  , Nh     = Nh\n  , u      = split (join st.block)\n  , num    = (zero # st.n) : [32]\n  , md_len = `SHA256_DIGEST_LENGTH : [32]\n  }\n  where\n    [Nh, Nl] = split st.sz\n\nsha512_c_state_to_sha256_state : SHA512_c_state -> SHA256State\nsha512_c_state_to_sha256_state st =\n  sha256_c_state_to_sha256_state (sha512_c_state_to_sha256_c_state st)\n\nsha256_state_to_sha512_c_state : SHA512_c_state -> SHA256State -> SHA512_c_state\nsha256_state_to_sha512_c_state st0 st =\n  sha256_c_state_to_sha512_c_state st0 (sha256_state_to_sha256_c_state st)\n\nsha256_init_sha512_c_state : SHA512_c_state -> SHA512_c_state\nsha256_init_sha512_c_state st0_c_512 = st1_c_512\n  where\n    st0_256 = SHA256Init\n    st1_c_512 = sha256_state_to_sha512_c_state st0_c_512 st0_256\n\nsha256_update_sha512_c_state : {n} (fin n) => SHA512_c_state -> [n][8] -> SHA512_c_state\nsha256_update_sha512_c_state st0_c_512 in = st1_c_512\n  where\n    st0_256 = sha512_c_state_to_sha256_state st0_c_512\n    st1_256 = SHA256Update st0_256 in\n    st1_c_512 = sha256_state_to_sha512_c_state st0_c_512 st1_256\n\nsha256_digest_sha512_c_state : SHA512_c_state -> [SHA256_DIGEST_LENGTH][8]\nsha256_digest_sha512_c_state st0_c_512 = out1\n  where\n    st0_256 = sha512_c_state_to_sha256_state st0_c_512\n    out1 = split (SHA256Final st0_256)\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/HMAC_properties.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named HMAC_properties that imports HMAC, Hashing, and HMAC_iterative and contains the following: (1) A polymorphic function hmac_c_state parameterized by key_size and msg_size, with constraints that msg_size\u2019s width fits within 32 bits and 8*key_size\u2019s width fits within 64 bits. It takes an HMAC_c_state, a key of key_size bytes, and a message of msg_size bytes, initializes the SHA-256 HMAC state with block size 64 and digest size SHA256_DIGEST_LENGTH, updates with the message, digests, and returns a digest of SHA256_DIGEST_LENGTH*8 bits. (2) The property hmac_c_state_correct asserting equality between this result and a one-shot HMAC-SHA256 of the key and message. (3) A function hmac_c_state_multi parameterized by key_size, msg_size, and a finite msg_chunks, with the above width constraints plus that msg_chunks*msg_size fits within 32 bits and an internal 64-bit bound over block size and total input holds. It initializes, updates over msg_chunks chunks of msg_size bytes via a helper, digests, and returns a digest of the same length. (4) A helper hmac_update_c_state_multi that, under the appropriate finiteness and width constraints, builds a self-referential sequence of states by repeatedly applying hmac_update_c_state to each chunk starting from an initial state, and returns the designated state from that sequence. (5) The property hmac_c_state_multi_correct asserting equality with a one-shot HMAC-SHA256 of the concatenation of all chunks. (6) Boolean functions expressing append laws for both HMAC state updates and the underlying hash updates: two successive updates by x then y equal one update by x concatenated with y. (7) A boolean function hmac_update_append_init stating the same append law when the state is initialized with a key and the SHA-256 algorithm identifier. (8) The property hash_update_empty stating that updating a hash state with empty input is identity. (9) The property hmac_update_empty stating, under a modular congruence precondition on an internal field, that updating an HMAC state with empty input leaves it unchanged. (10) The property pass validating two standard HMAC-SHA256 test vectors."},{"role":"assistant","content":"```cryptol\nmodule HMAC_properties where\n\nimport HMAC\nimport Hashing\nimport HMAC_iterative\n\nhmac_c_state : { key_size, msg_size }\n     ( 32 >= width msg_size, 64 >= width (8 * key_size) )\n  => HMAC_c_state -> [key_size][8] -> [msg_size][8] -> [SHA256_DIGEST_LENGTH * 8]\nhmac_c_state st0 key msg = digest\n  where\n  (st1, digest) =\n    hmac_digest_c_state `{block_size=64}\n      (hmac_update_c_state\n        (hmac_init_c_state `{block_size=64,hash_block_size=64,digest_size=SHA256_DIGEST_LENGTH}\n         st0 alg key)\n        msg)\n    alg = S2N_HMAC_SHA256\n\nhmac_c_state_correct : { key_size, msg_size }\n              ( 32 >= width msg_size, 64 >= width (8 * key_size) )\n           => HMAC_c_state -> [key_size][8] -> [msg_size][8] -> Bit\nproperty hmac_c_state_correct st0 key msg =\n  hmacSHA256 key msg == hmac_c_state st0 key msg\n\nhmac_c_state_multi : { key_size, msg_size, msg_chunks}\n     ( 32 >= width msg_size, 64 >= width (8 * key_size), fin msg_chunks )\n  => HMAC_c_state -> [key_size][8] -> [msg_chunks][msg_size][8] -> [SHA256_DIGEST_LENGTH * 8]\nhmac_c_state_multi st0 key msgs = digest\n  where\n    initial_state = (hmac_init_c_state `{block_size=64,hash_block_size=64,digest_size=SHA256_DIGEST_LENGTH}\n         st0 alg key)\n    mid_state = hmac_update_c_state_multi initial_state msgs\n    (st1, digest) = hmac_digest_c_state `{block_size=64} mid_state\n      alg = S2N_HMAC_SHA256\n\nhmac_update_c_state_multi : {msg_size, msg_chunks}\n  ( 32 >= width msg_size, fin msg_chunks)\n  => HMAC_c_state -> [msg_chunks][msg_size][8] -> HMAC_c_state\nhmac_update_c_state_multi st msgs = states ! 0\n  where\n    states = [st] # [hmac_update_c_state s msg | msg <- msgs | s <- states]\n\nhmac_c_state_multi_correct : { key_size, msg_size, msg_chunks }\n              ( 32 >= width msg_size\n              , 64 >= width (8 * key_size)\n              , fin msg_chunks\n              , 32 >= width (msg_chunks * msg_size)\n              , 64 >= width (8 * (64 + msg_size * msg_chunks))\n              )\n           => HMAC_c_state -> [key_size][8] -> [msg_chunks][msg_size][8] -> Bit\nproperty hmac_c_state_multi_correct st0 key msgs =\n    hmacSHA256 key (join msgs) == hmac_c_state_multi st0 key msgs\n\nhmac_update_append x y s =\n  hmac_update_c_state (hmac_update_c_state s x) y == hmac_update_c_state s (x # y)\n\nhash_update_append x y s =\n  hash_update_c_state (hash_update_c_state s x) y == hash_update_c_state s (x # y)\n\nhmac_update_append_init x y k st0 =\n    hmac_update_c_state (hmac_update_c_state s x) y == hmac_update_c_state s (x # y)\n    where\n      s = hmac_init_c_state st0 S2N_HMAC_SHA256 k\n\nproperty hash_update_empty s = hash_update_c_state s [] == s\n\nproperty hmac_update_empty s =\n  s.currently_in_hash_block == s.currently_in_hash_block % (zero # s.block_size)\n  ==>\n  hmac_update_c_state s [] == s\n\nproperty pass =\n    ~zero ==\n    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] \"Hi There\" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\n    , hmacSHA256 \"Jefe\" \"what do ya want for nothing?\" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\n    ]\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named SHA256 that contains the following definitions implementing and verifying SHA-256: 1) Functions Ch and Maj taking three 32-bit words and returning a 32-bit word using the standard choose and majority boolean combinations. 2) Functions S0, S1, s0, s1 mapping a 32-bit word to a 32-bit word using the specific right-rotate and right-shift mixes used in SHA-256 (S0\/S1 use rotates by 2\/13\/22 and 6\/11\/25; s0\/s1 use rotates by 7\/18 and 17\/19 plus shifts by 3 and 10, respectively). 3) Constant K as an array of 64 32-bit words containing the exact SHA-256 round constants. 4) A polymorphic preprocess with parameters for message length, derived content length, number of 512-bit chunks, and padding amount, constrained so the 64-bit length field is representable and the chunk\/padding equations hold; map a bitvector message to 512-bit blocks by appending a single \u20181\u2019 bit, zero padding, and a 64-bit big-endian length, then splitting. 5) Constant H0 as the initial 8-word (32-bit each) hash state per SHA-256. 6) SHA256MessageSchedule expanding a 16-word block to a 64-word schedule using s0\/s1 and prior words. 7) SHA256Compress updating an 8-word state across 64 rounds using T1\/T2 derived from S0\/S1, Ch, Maj, K, and the schedule. 8) SHA256Block applying compression to one 512-bit block. 9) SHA256\u2019 folding SHA256Block over a sequence of blocks starting from H0. 10) SHA256 accepting a sequence of bytes whose length fits the 64-bit length field and returning the 256-bit digest after preprocessing. 11) property katsPass asserting all provided (digest, expected) pairs in kats are equal; and kats as a list of known-answer test vectors. 12) An imperative API: record type SHA256State with fields for state, 64-byte buffer, index, and 64-bit total size; SHA256Init; SHA256Update1 consuming one byte; SHA256Update consuming a byte sequence; SHA256Final performing padding and final block processing; SHA256Imp computing the digest via this API. 13) property katsPassImp over katsImp mirroring the KATs for the imperative API. 14) property imp_correct asserting SHA256 equals SHA256Imp for all messages under the length constraint."},{"role":"assistant","content":"```cryptol\nmodule SHA256 where\n\nCh : [32] -> [32] -> [32] -> [32]\nCh x y z = (x && y) ^ (~x && z)\n\nMaj : [32] -> [32] -> [32] -> [32]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nS0 : [32] -> [32]\nS0 x = (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)\n\nS1 : [32] -> [32]\nS1 x = (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)\n\ns0 : [32] -> [32]\ns0 x = (x >>> 7) ^ (x >>> 18) ^ (x >> 3)\n\ns1 : [32] -> [32]\ns1 x = (x >>> 17) ^ (x >>> 19) ^ (x >> 10)\n\nK : [64][32]\nK = [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n     ]\n\npreprocess : {msgLen,contentLen,chunks,padding}\n     ( fin msgLen\n     , 64 >= width msgLen                                   , contentLen == msgLen + 65                            , chunks     == (contentLen+511) \/ 512\n     , padding    == (512 - contentLen % 512) % 512         )\n     => [msgLen] -> [chunks][512]\npreprocess msg = split (msg # [True] # (zero:[padding]) # (`msgLen:[64]))\n\nH0 : [8][32]\nH0 = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n       0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]\n\nSHA256MessageSchedule : [16][32] -> [64][32]\nSHA256MessageSchedule M = W where\n    W = M # [ s1 (W@(j-2)) + (W@(j-7)) + s0 (W@(j-15)) + (W@(j-16)) | j <- [16 .. 63]:[_][8] ]\n\nSHA256Compress : [8][32] -> [64][32] -> [8][32]\nSHA256Compress H W = [as!0 + H@0, bs!0 + H@1, cs!0 + H@2, ds!0 + H@3, es!0 + H@4, fs!0 + H@5, gs!0 + H@6, hs!0 + H@7] where\n    T1 = [h + S1 e + Ch e f g  + k + w | h <- hs | e <- es | f <- fs | g <- gs | k <- K | w <- W]\n    T2 = [S0 a  + Maj a b c  | a <- as | b <- bs | c <- cs]\n    hs = take `{65} ([H@7] # gs)\n    gs = take `{65} ([H@6] # fs)\n    fs = take `{65} ([H@5] # es)\n    es = take `{65} ([H@4] # [d + t1 | d <- ds | t1 <- T1])\n    ds = take `{65} ([H@3] # cs)\n    cs = take `{65} ([H@2] # bs)\n    bs = take `{65} ([H@1] # as)\n    as = take `{65} ([H@0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\nSHA256Block : [8][32] -> [16][32] -> [8][32]\nSHA256Block H M = SHA256Compress H (SHA256MessageSchedule M)\n\nSHA256' : {a} (fin a) => [a][16][32] -> [8][32]\nSHA256' blocks = hash!0 where\n    hash = [H0] # [SHA256Block h b | h <- hash | b <- blocks]\n\nSHA256 : {a} (fin a, 64 >= width (8*a)) => [a][8] -> [256]\nSHA256 msg =   join (SHA256' [ split x | x <- preprocess(join msg)])\n\nproperty katsPass = ~zero == [test == kat | (test,kat) <- kats ]\n\nkats = [ (SHA256 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n         , 0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1)\n       , (SHA256 \"\"\n         ,0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855)\n       , (SHA256 \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n         , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1)\n       \/\/ , ([0x61 | i <- [1..1000000] : [_][32]]\n       \/\/   , 0xcdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0)\n       ]\n\n\/\/\/\/\/\/\/\/ Imperative top level \/\/\/\/\/\/\/\/\n\ntype SHA256State = { h : [8][32]\n                   , block : [64][8]\n                   , n : [16]\n                   , sz : [64]\n                   }\n\nSHA256Init : SHA256State\nSHA256Init = { h = H0\n             , block = zero\n             , n = 0\n             , sz = 0\n             }\n\nSHA256Update1 : SHA256State -> [8] -> SHA256State\nSHA256Update1 s b =\n  if s.n == 64\n    then { h = SHA256Block s.h (split (join s.block))\n         , block = [b] # zero\n         , n = 1\n         , sz = s.sz + 8\n         }\n    else { h = s.h\n         , block = update s.block s.n b\n         , n = s.n + 1\n         , sz = s.sz + 8\n         }\n\nSHA256Update : {n} (fin n) => SHA256State -> [n][8] -> SHA256State\nSHA256Update sinit bs = ss!0\n  where ss = [sinit] # [ SHA256Update1 s b | s <- ss | b <- bs ]\n\n\/\/ Add padding and size and process the final block.\nSHA256Final : SHA256State -> [256]\nSHA256Final s = join (SHA256Block h b')\n      where s' = SHA256Update1 s 0x80\n        \/\/ Don't need to add zeros. They're already there. Just update\n        \/\/ the count of bytes in this block. After adding the 1 pad, there\n        \/\/ are two possible cases: the size will fit in the current block,\n        \/\/ or it won't.\n        (h, b) = if s'.n <= 56 then (s'.h, s'.block)\n                 else (SHA256Block s'.h (split (join s'.block)), zero)\n        b' = split (join b || (zero # s.sz))\n\nSHA256Imp : {a} (64 >= width (8*a)) => [a][8] -> [256]\nSHA256Imp msg = SHA256Final (SHA256Update SHA256Init msg)\n\nproperty katsPassImp = ~zero == [test == kat | (test,kat) <- katsImp ]\n\nkatsImp = [ (SHA256Imp \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n            , 0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1)\n          , (SHA256Imp \"\"\n            , 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855)\n          , (SHA256Imp \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n            , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1)\n                              ]\n\nproperty imp_correct msg = SHA256 msg == SHA256Imp msg\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/modthm.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol spec that defines three Bit-valued functions with explicit type signatures: (1) a function named valid_block_sizes that takes two 16-bit words (interpreted as a hash block size and a block size) and returns true exactly when both sizes equal 64, or both equal 128; false otherwise. (2) a function named modthm with five arguments: three 32-bit words (x11, x15, x16) and two 16-bit words (hash_block_size, block_size). Form 32-bit moduli by zero-extending each 16-bit size to 32 bits via prefixing sixteen zero bits. The function returns true iff the following modular-arithmetic equality holds: first reduce x16 modulo the zero-extended hash size, add to x11, reduce modulo the zero-extended block size, then add x15 reduced modulo the zero-extended hash size, and reduce again modulo the zero-extended block size; this must equal the result of first adding x16 and x15, reducing that sum modulo the zero-extended hash size, then adding to x11 and reducing modulo the zero-extended block size. (3) a function named modthm_precond with the same five arguments that returns true if either the block sizes are invalid (i.e., the predicate from valid_block_sizes is false) or, when the sizes are valid, the modular-arithmetic equality described in modthm holds. Ensure all three definitions include their precise Cryptol type signatures and implement the described logic using 32-bit arithmetic for x11, x15, x16 and zero-extended 32-bit moduli derived from the given 16-bit sizes."},{"role":"assistant","content":"```cryptol\nvalid_block_sizes : [16] -> [16] -> Bit\nvalid_block_sizes hbs bs =\n        ((bs, hbs) == (64, 64)) ||\n  ((bs, hbs) == (128, 128))\n\nmodthm : [32] -> [32] -> [32] -> [16] -> [16] -> Bit\nmodthm x11 x15 x16 hash_block_size block_size =\n  ((((x11 + (x16 % x17)) % x18) + (x15 % x17)) % x18)\n  ==\n  ((x11 + ((x16 + x15) % x17)) % x18)\n  where x17 = zero # hash_block_size\n        x18 = zero # block_size\n\nmodthm_precond : [32] -> [32] -> [32] -> [16] -> [16] -> Bit\nmodthm_precond x11 x15 x16 hash_block_size block_size =\n  if (valid_block_sizes hash_block_size block_size) then\n    modthm x11 x15 x16 hash_block_size block_size\n  else True\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/HMAC_iterative.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named HMAC_iterative that imports Array, SHA256, and Hashing, and contains the following definitions: (1) constants for algorithm identifiers as 32-bit words with the same numeric values; (2) a record type for the HMAC state with fields for the selected algorithm (32-bit word), hash block size (16-bit), a 32-bit counter tracking bytes in the current block, the HMAC block size (16-bit), digest size (8-bit), four internal hash states, a 128-byte XOR pad, and a digest pad of SHA-512 digest length; (3) a ByteArray type alias as an array of 64 bytes; (4) type aliases for hash init, update (parameterized by message length, finite), and digest (parameterized by digest length, finite); (5) functions: init that wraps the imported SHA-256-on-SHA512-state initializer; bounded update that consumes a finite-length byte message; unbounded update that consumes a 64-byte array plus an explicit 32-bit length; digest that returns a digest_size-byte digest by truncating the imported digest and padding as needed; (6) key-setup for bounded and unbounded keys: if key length exceeds block size, hash the key to derive a block-sized key and update the digest pad; otherwise zero-pad the key; return the updated outer state, updated digest pad, and block-sized key; (7) HMAC init (bounded and unbounded) that builds inner\/outer states by hashing the key XOR ipad\/opad, initializes counters, and sets pads; (8) HMAC update (bounded and unbounded) that updates the inner state and advances the counter modulo the hash block size and HMAC block size; (9) HMAC digest that hashes the inner digest with the prepared outer state, returns the concatenated output bytes, and resets outer\/digest pad in the returned state. Include width\/fin constraints matching the original intent (e.g., block size \u2264 128, digest size \u2264 64, finite size parameters). Add properties asserting equivalence between bounded and unbounded variants when sizes match, correct counter modular arithmetic, and that the final digest equals hashing the inner digest with the prepared outer state."},{"role":"assistant","content":"```cryptol\nmodule HMAC_iterative where\n\nimport Array\nimport SHA256\nimport Hashing\n\nS2N_HMAC_NONE       = 0:[32]\nS2N_HMAC_MD5        = 1:[32]\nS2N_HMAC_SHA1       = 2:[32]\nS2N_HMAC_SHA224     = 3:[32]\nS2N_HMAC_SHA256     = 4:[32]\nS2N_HMAC_SHA384     = 5:[32]\nS2N_HMAC_SHA512     = 6:[32]\nS2N_HMAC_SSLv3_MD5  = 7:[32]\nS2N_HMAC_SSLv3_SHA1 = 8:[32]\n\ntype HMAC_c_state =\n  { alg                     : [32]\n  , hash_block_size         : [16]\n  , currently_in_hash_block : [32]\n  , block_size              : [16]\n  , digest_size             : [8]\n  , inner                   : SHA512_c_state\n  , inner_just_key          : SHA512_c_state\n  , outer                   : SHA512_c_state\n  , outer_just_key          : SHA512_c_state\n  , xor_pad                 : [128][8]\n  , digest_pad              : [SHA512_DIGEST_LENGTH][8]\n  }\n\ntype ByteArray = Array[64][8]\n\ntype hash_init_ty =\n  SHA512_c_state -> SHA512_c_state\ntype hash_update_ty msg_size =\n  SHA512_c_state -> [msg_size][8] -> SHA512_c_state\ntype hash_digest_ty digest_size =\n  SHA512_c_state -> [digest_size][8]\n\nhash_init_c_state : hash_init_ty\nhash_init_c_state = sha256_init_sha512_c_state\n\nhash_update_c_state :\n  {msg_size} (fin msg_size) => hash_update_ty msg_size\nhash_update_c_state = sha256_update_sha512_c_state\nhash_update_c_state_unbounded :\n  SHA512_c_state -> ByteArray -> [32] -> SHA512_c_state\nhash_update_c_state_unbounded = undefined\n\nhash_digest_c_state :\n  {digest_size} (fin digest_size) => hash_digest_ty digest_size\nhash_digest_c_state st =\n  take `{digest_size}\n    (sha256_digest_sha512_c_state st # (zero : [inf][8]))\n\nkey_init_c_state : { key_size, block_size, digest_size }\n        ( fin key_size, fin block_size,\n          SHA512_DIGEST_LENGTH >= digest_size )\n     => SHA512_c_state\n     -> [SHA512_DIGEST_LENGTH][8]\n     -> [key_size][8]\n     -> (SHA512_c_state, [SHA512_DIGEST_LENGTH][8], [block_size][8])\nkey_init_c_state outer0 digest_pad0 key =\n  if `key_size > (`block_size : [max (width key_size) (width block_size)])\n  then (outer2, digest_pad1, hash')\n  else (outer1, digest_pad0, key')\n  where\n  outer1 = hash_init_c_state outer0\n\n    outer2 = hash_update_c_state outer1 key\n  hash : [digest_size][8]\n  hash = hash_digest_c_state outer2\n  digest_pad1 = hash # drop `{digest_size} digest_pad0\n  hash' = take `{block_size} (hash # (zero : [block_size][8]))\n\n  \/\/ Short key.\n  key' = take `{block_size} (key # (zero : [block_size][8]))\n\nkey_init_c_state_unbounded : { block_size, digest_size }\n        ( 16 >= width block_size, SHA512_DIGEST_LENGTH >= digest_size )\n     => SHA512_c_state\n     -> [SHA512_DIGEST_LENGTH][8]\n     -> ByteArray\n     -> [32]\n     -> (SHA512_c_state, [SHA512_DIGEST_LENGTH][8], [block_size][8])\nkey_init_c_state_unbounded outer0 digest_pad0 key klen =\n  if klen > (`block_size : [32])\n  then (outer2, digest_pad1, hash')\n  else (outer1, digest_pad0, key')\n  where\n  outer1 = hash_init_c_state outer0\n\n    outer2 = hash_update_c_state_unbounded outer1 key klen\n  hash : [digest_size][8]\n  hash = hash_digest_c_state outer2\n  digest_pad1 = hash # drop `{digest_size} digest_pad0\n  hash' = take `{block_size} (hash # (zero : [block_size][8]))\n\n  \/\/ Short key.\n  key' = map\n    (\\i -> if (i <$ (0 # klen)) then (arrayLookup key i) else 0)\n    (take`{block_size} [0 .. block_size])\n\nhmac_init_c_state :\n     { key_size, block_size, hash_block_size, digest_size }\n     ( fin key_size\n     , 64 >= width (8*key_size)\n     , 16 >= width hash_block_size\n     , 16 >= width block_size\n     , 8 >= width digest_size\n     , 128 >= block_size\n     , 64 >= digest_size )\n  => HMAC_c_state\n  -> [32]\n  -> [key_size][8]\n  -> HMAC_c_state\nhmac_init_c_state st0 alg key =\n  { alg                     = alg\n  , hash_block_size         = `hash_block_size\n  , currently_in_hash_block = currently_in_hash_block\n  , block_size              = `block_size\n  , digest_size             = `digest_size\n\n  , inner                   = inner\n  , inner_just_key          = inner_just_key\n  , outer                   = outer\n  , outer_just_key          = outer_just_key\n  , xor_pad                 = xor_pad\n  , digest_pad              = digest_pad\n  }\n  where\n    currently_in_hash_block = 0\n\n    k0 : [block_size][8]\n    (outer, digest_pad, k0) =\n      key_init_c_state `{digest_size=digest_size} st0.outer st0.digest_pad key\n    ikey = [ k ^ 0x36 | k <- k0 ]\n    okey = [ k ^ 0x6a | k <- ikey ]\n\n    inner_just_key = hash_update_c_state\n      (hash_init_c_state st0.inner_just_key) ikey\n    inner          = inner_just_key\n    outer_just_key = hash_update_c_state\n      (hash_init_c_state st0.outer_just_key) okey\n    xor_pad = zero \nhmac_init_c_state_unbounded :\n     { block_size, hash_block_size, digest_size }\n     ( 16 >= width hash_block_size\n     , 16 >= width block_size\n     , 8 >= width digest_size\n     , 128 >= block_size\n     , 64 >= digest_size )\n  => HMAC_c_state\n  -> [32]\n  -> ByteArray\n  -> [32]\n  -> HMAC_c_state\nhmac_init_c_state_unbounded st0 alg key klen =\n  { alg                     = alg\n  , hash_block_size         = `hash_block_size\n  , currently_in_hash_block = currently_in_hash_block\n  , block_size              = `block_size\n  , digest_size             = `digest_size\n\n  , inner                   = inner\n  , inner_just_key          = inner_just_key\n  , outer                   = outer\n  , outer_just_key          = outer_just_key\n  , xor_pad                 = xor_pad\n  , digest_pad              = digest_pad\n  }\n  where\n    currently_in_hash_block = 0\n\n    k0 : [block_size][8]\n    (outer, digest_pad, k0) =\n      key_init_c_state_unbounded `{digest_size=digest_size}\n        st0.outer st0.digest_pad key klen\n    ikey = [ k ^ 0x36 | k <- k0 ]\n    okey = [ k ^ 0x6a | k <- ikey ]\n\n    inner_just_key = hash_update_c_state\n      (hash_init_c_state st0.inner_just_key) ikey\n    inner          = inner_just_key\n    outer_just_key = hash_update_c_state\n      (hash_init_c_state st0.outer_just_key) okey\n    xor_pad = zero \n\nhmac_update_c_state : {msg_size} (32 >= width msg_size) =>\n  HMAC_c_state -> [msg_size][8] -> HMAC_c_state\nhmac_update_c_state s m =\n  { inner = hash_update_c_state s.inner m\n  , currently_in_hash_block =\n      (s.currently_in_hash_block + (`msg_size % (zero # s.hash_block_size))) %\n      (zero # s.block_size)\n\n    , alg             = s.alg\n  , hash_block_size = s.hash_block_size\n  , block_size      = s.block_size\n  , digest_size     = s.digest_size\n  , inner_just_key  = s.inner_just_key\n  , outer           = s.outer\n  , outer_just_key  = s.outer_just_key\n  , xor_pad         = s.xor_pad\n  , digest_pad      = s.digest_pad\n  }\n\nhmac_update_c_state_unbounded :\n  HMAC_c_state -> ByteArray -> [32] -> HMAC_c_state\nhmac_update_c_state_unbounded s m sz =\n  { inner = hash_update_c_state_unbounded s.inner m sz\n  , currently_in_hash_block =\n      (s.currently_in_hash_block + (sz % (zero # s.hash_block_size))) %\n      (zero # s.block_size)\n\n    , alg             = s.alg\n  , hash_block_size = s.hash_block_size\n  , block_size      = s.block_size\n  , digest_size     = s.digest_size\n  , inner_just_key  = s.inner_just_key\n  , outer           = s.outer\n  , outer_just_key  = s.outer_just_key\n  , xor_pad         = s.xor_pad\n  , digest_pad      = s.digest_pad\n  }\n\nhmac_digest_c_state :\n     { block_size, digest_size }\n     ( 64 >= digest_size\n     , 128 >= block_size )\n  => HMAC_c_state -> (HMAC_c_state, [8 * digest_size])\nhmac_digest_c_state s = (sout, out)\n  where\n    hin : [digest_size][8]\n    hin = hash_digest_c_state inner\n    digest_pad : [SHA512_DIGEST_LENGTH][8]\n    digest_pad = hin # zero\n\n    okey : [block_size][8]\n    okey = take s.xor_pad\n\n                                                        outer = hash_update_c_state s.outer_just_key hin\n    inner = s.inner\n\n    out = join (hash_digest_c_state outer)\n\n    sout : HMAC_c_state\n    sout =\n      { inner      = inner\n      , outer      = s.outer_just_key\n      , digest_pad = digest_pad\n\n            , alg                     = s.alg\n      , hash_block_size         = s.hash_block_size\n      , currently_in_hash_block = s.currently_in_hash_block\n      , block_size              = s.block_size\n      , digest_size             = s.digest_size\n      , inner_just_key          = s.inner_just_key\n      , outer_just_key          = s.outer_just_key\n      , xor_pad                 = s.xor_pad\n      }\n```"}]}
{"filename":"saw-script\/exercises\/sha512\/SHA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named SHA that contains the following definitions and properties, using only types, constraints, and behavior described here: 1) A polymorphic digest function that consumes a bitvector message and returns a digest of parameterized size, subject to the precondition relating word size to the message length. The function must pad by appending a single 1 bit, zero bits, and a 2\u00b7w-bit length field; split into 16-word blocks of w-bit words; compute a schedule of j words where each new word is the sum of four prior-derived terms using the small-\u03c3 functions at offsets {1, 9, 14}; iteratively compress from an initial 8-word vector using round constants and the big-\u03a3, choose, and majority functions; and output the joined top 8 words truncated to the digest size. 2) A parameter section with numeric types w, digest_size, and j, with finiteness constraints and inequalities (w \u2265 2, j \u2265 17, and digest_size \u2264 8\u00b7w); initial state vector and round-constant arrays; and four word-to-word functions (two big-\u03a3 and two small-\u03c3). Provide short aliases that re-export these parameters. 3) Boolean word functions for choose and majority. 4) A block processor that compresses one 16-word message block using the schedule and returns the updated 8-word state. 5) Private definitions: block-size arithmetic, number of blocks and padded size for any input length, a padding function with the precondition above, a splitter for blocks, the message schedule, the compressor, and a chaining function that folds over all blocks. 6) A streaming API: a state record with hash state, a byte buffer for one block, a byte index, and a bit-length counter; an initialization constant; a byte-wise updater; a finalizer that appends the mandatory byte-aligned padding and length and returns the digest; and a wrapper that hashes a sequence of bytes. 7) Properties: (a) for any finite sequence of bytes, the byte-streaming wrapper equals the bit-level digest applied to the joined bytes; (b) the single-block processor equals the compressor applied to the schedule of that block."},{"role":"assistant","content":"```cryptol\nmodule SHA where\n\nsha : {L} (2 * w >= width L) => [L] -> [digest_size]\nsha M = take (join (SHA_2_Common' [ split x | x <- parse`{num_blocks L} (pad`{L} M) ]))\n\nparameter\n\n  \/** Word size\n    Specifications are based on word size w, rather than digest size (8 * w)\n    or block size (m == 16 * w), in order to avoid confusing Cryptol's type\n    constraint verifier with integer division.\n  *\/\n\n  type w : #\n  type constraint (fin w, w >= 2, 32 >= width w)\n\n  type digest_size : #\n  type constraint (fin digest_size, 8*w >= digest_size)\n\n  type j : #\n  type constraint (fin j, j >= 17)\n\n  H0 : [8][w]\n  K  : [j][w]\n\n  SIGMA_0 : [w] -> [w]\n  SIGMA_1 : [w] -> [w]\n  sigma_0 : [w] -> [w]\n  sigma_1 : [w] -> [w]\n\nSHAH0 = H0\nS0 = SIGMA_0\nS1 = SIGMA_1\ns0 = sigma_0\ns1 = sigma_1\n\nCh : [w] -> [w] -> [w] -> [w]\nCh x y z = (x && y) ^ (~x && z)\n\nMaj : [w] -> [w] -> [w] -> [w]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nprocessBlock_Common : [8][w] -> [16][w] -> [8][w]\nprocessBlock_Common H Mi = compress_Common H (messageSchedule_Common Mi)\n\nprivate\n\n  type block_size = 16 * w\n\n  type num_blocks L     = (L+1+2*w) \/^ block_size\n  type padded_size L    = num_blocks L * block_size\n\n  pad : {L} (2 * w >= width L) => [L] -> [padded_size L]\n  pad M = M # 0b1 # zero # (`L : [2*w])\n\n  parse : {m} [m * block_size] -> [m][block_size]\n  parse = split\n\n  messageSchedule_Common : [16][w] -> [j][w]\n  messageSchedule_Common Mi = take W\n    where\n    W : [inf][_]\n    W = Mi # [ w1 + s0 w2 + w3 + s1 w4\n             | w1 <- W\n             | w2 <- drop`{1} W\n             | w3 <- drop`{9} W\n             | w4 <- drop`{14} W\n             ]\n\n  compress_Common : [8][w] -> [j][w] -> [8][w]\n  compress_Common H W =\n        [ (as ! 0) + (H @ 0),\n      (bs ! 0) + (H @ 1),\n      (cs ! 0) + (H @ 2),\n      (ds ! 0) + (H @ 3),\n      (es ! 0) + (H @ 4),\n      (fs ! 0) + (H @ 5),\n      (gs ! 0) + (H @ 6),\n      (hs ! 0) + (H @ 7)\n    ]\n    where\n      T1 = [h + S1 e + Ch e f g + k_t + w_t\n                | h <- hs | e <- es | f <- fs | g <- gs | k_t <- K | w_t <- W]\n      T2 = [ S0 a + Maj a b c | a <- as | b <- bs | c <- cs]\n      hs = take`{j + 1}([H @ 7] # gs)\n      gs = take`{j + 1}([H @ 6] # fs)\n      fs = take`{j + 1}([H @ 5] # es)\n      es = take`{j + 1}([H @ 4] # [d + t1 | d <- ds | t1 <- T1])\n      ds = take`{j + 1}([H @ 3] # cs)\n      cs = take`{j + 1}([H @ 2] # bs)\n      bs = take`{j + 1}([H @ 1] # as)\n      as = take`{j + 1}([H @ 0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\n  SHA_2_Common' : {L} (fin L) => [L][16][w] -> [8][w]\n  SHA_2_Common' blocks = hash ! 0\n    where\n    hash = [H0] # [ processBlock_Common h b | h <- hash | b <- blocks]\n\ntype SHAState = { h : [8][w]\n                , block : [w * 2][8]\n                , n : [32]\n                , sz : [w * 2]\n                }\n\nSHAInit : SHAState\nSHAInit = { h = H0\n          , block = zero\n          , n = 0\n          , sz = 0\n          }\n\nSHAUpdate : {n} (fin n) => SHAState -> [n][8] -> SHAState\nSHAUpdate sinit bs = ss!0\n  where ss = [sinit] # [ SHAUpdate1 s b | s <- ss | b <- bs ]\n\nSHAFinal : SHAState -> [digest_size]\nSHAFinal s = take (join (processBlock_Common h b'))\n  \/\/ Because the message is always made up of bytes, and the size is a\n  \/\/ fixed number of bytes, the 1 pad will always be at least a byte.\n  where s' = SHAUpdate1 s 0x80\n                                        (h, b) = if s'.n <= (`w*2 - (`w\/4)) then (s'.h, s'.block)\n                 else (processBlock_Common s'.h (split (join s'.block)), zero)\n        b' = split (join b || (zero # s.sz))\n\nSHAImp : {n} (fin n) => [n][8] -> [digest_size]\nSHAImp msg = SHAFinal (SHAUpdate SHAInit msg)\n\nprivate\n\n          SHAUpdate1 : SHAState -> [8] -> SHAState\n  SHAUpdate1 s b =\n    if s.n == (2 * `w - 1)\n      then { h = processBlock_Common s.h (split (join (update s.block s.n b)))\n           , block = zero\n           , n = 0\n           , sz = s.sz + 8\n           }\n      else { h = s.h\n           , block = update s.block s.n b\n           , n = s.n + 1\n           , sz = s.sz + 8\n           }\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/point\/Point.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Point that contains the following definitions: (1) a record type alias named Point with two fields, x and y, each a 32-bit sequence; (2) a constant named POINT_ZERO of that record type equal to the all-zero value; (3) a function named point_add that takes two values of the record type and returns a value whose x field is the modular sum of the inputs\u2019 x fields and whose y field is the modular sum of the inputs\u2019 y fields; (4) a property named point_add_commutes that universally quantifies two values of the record type and checks that calling the addition function with the arguments in either order produces the same result. Include explicit type signatures for all top-level bindings, and rely on modulo 2^32 arithmetic implied by 32-bit sequences."},{"role":"assistant","content":"```cryptol\nmodule Point where\n\ntype Point = {x : [32], y : [32]}\n\nPOINT_ZERO : Point\nPOINT_ZERO = zero\n\npoint_add : Point -> Point -> Point\npoint_add p1 p2 = { x = p1.x + p2.x, y = p1.y + p2.y }\n\npoint_add_commutes : Point -> Point -> Bit\nproperty point_add_commutes p1 p2 = point_add p1 p2 == point_add p2 p1\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/popcount\/Popcount.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Popcount that contains the following definitions: a function popCount with type [32] -> [32] that computes the Hamming weight of a 32-bit bitvector. Implement it by constructing a running count sequence that starts at zero and, for each input bit from left to right, adds one to the previous count when the bit is 1 and otherwise keeps the previous count; return the final count after all 32 bits are processed. Also define a property that, for all 32-bit inputs, popCount\u2019s result equals the sum of the input bits (treating 1 as one and 0 as zero) and is in the range 0 through 32."},{"role":"assistant","content":"```cryptol\nmodule Popcount where\n\npopCount : [32] -> [32]\npopCount bits = ic ! 0 where\n     ic = [0] # [ if elt then prev + 1 else prev | elt <- bits | prev <- ic]\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/swap\/solution\/Swap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Swap that contains the following definitions: (1) A function swap_list that, for any finite length n, takes a sequence of n 32-bit words and two 64-bit indices and returns a new sequence where the elements at those indices are exchanged. Read the values at both indices from the input sequence and perform two updates to swap them. (2) A function argmin that, for any finite length n, takes a sequence of n 32-bit words and returns a 64-bit index of the smallest element, scanning left-to-right and breaking ties by the earliest position; implement it by folding over paired elements and their zero-based indices and returning the index of the minimum. (3) A function selection_sort that, for any finite length n where the bit-width of n fits in 64 bits, returns the input sequence sorted in nondecreasing order using selection sort. Implement it by iterating an index from 0 up to n, at each step taking the suffix starting at the current index, finding the offset of its minimum via argmin, and swapping the current element with the element at current index plus that offset. Use a local helper parameterized by a type-level index, with constraints ensuring finiteness, index \u2264 n, and widths of both the index and n bounded by 64. (4) A property swap_list_same stating that for any finite n, any 64-bit index, and any sequence of n 32-bit words, swapping an element with itself yields the original sequence. (5) A property sort_eq stating that for any finite n with bit-width of n \u2264 64, the result of selection_sort equals the result of the standard reference sort on the same input."},{"role":"assistant","content":"```cryptol\nmodule Swap where\n\nswap_list : {n} [n][32] -> [64] -> [64] -> [n][32]\nswap_list lst i j = update (update lst i jval) j ival\n    where ival = lst @ i\n          jval = lst @ j\n\nargmin : {n} (fin n) => [n][32] -> [64]\nargmin lst =\n    (foldl' min (-1 : [32], -1 : [64]) [(x, i) | x <- lst | i <- [0...]]).1\n\nselection_sort : {n} (fin n, 64 >= width n) => [n][32] -> [n][32]\nselection_sort lst = go`{0} lst\n    where\n        go : {idx} (fin idx, fin n, 64 >= width idx, 64 >= width n, n >= idx) => [n][32] -> [n][32]\n        go acc =\n            if `idx == `n\n            then acc\n            else go`{min n (idx + 1)}\n                    (swap_list acc `idx (`idx + (argmin (drop`{idx} acc))))\n\n\/\/ NOTE: Have to be careful.  Just running :check on this will likely crash because a random index is likely out of bounds (especailly because `n will default to 0)\nswap_list_same : {n} (fin n) => [64] -> [n][32] -> Bit\nproperty swap_list_same i lst = (swap_list lst i i) == lst\n\nsort_eq : {n} (fin n, 64 >= width n) => [n][32] -> Bit\nproperty sort_eq lst = selection_sort lst == sort lst\n```"}]}
{"filename":"saw-script\/examples\/sequential_aigs\/fib.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) A transition function for an 8-bit Fibonacci state machine with type (1-bit input, (8-bit, 8-bit) state) -> (8-bit output, (8-bit, 8-bit) next state); it ignores the input bit, outputs the first state word, and advances the state to (second, first+second). (2) A state machine initialized to (0,1) using standard state-machine initialization, and an 8-bit constant equal to 1+8+8 representing the total state bits. (3) A second state machine that uses a 1-bit start latch and two 16-bit words with type (1-bit input, (1-bit, 16-bit, 16-bit) state) -> (8-bit output, (1-bit, 16-bit, 16-bit) next state); compute a gated previous value that is 1 on the first step and otherwise the prior second word, set the latch to 1 thereafter, form the next second word by summing, and output the least-significant 8 bits of the first 16-bit word; also define an 8-bit constant equal to 1+16+16. (4) A polymorphic builder for a buggy 8-bit Fibonacci transition function parameterized by a counter width a with constraints fin a and a >= 1: given an a-bit magic value, return a step that increments the a-bit counter and adds 1 to the output only when the counter equals the magic value; otherwise behave like the non-buggy 8-bit step. Wrap it with an initializer setting the start state to (0,1,0). Define a helper that returns (1+8+8+a) as an 8-bit value, with constraint width a <= 7. (5) All-ones magic constants for widths 4, 8, 12, 16, 32, and 64, corresponding buggy machines, and their state-bit-count constants. (6) A 1000-element sequence of 1-bit zeros; a property asserting that the two non-buggy machines produce equal output sequences over these inputs; and the sequences of states obtained by executing each machine on the inputs."},{"role":"assistant","content":"```cryptol\nimport StateMachine\n\nfib1_no_init : ([1], ([8], [8])) -> ([8], ([8], [8]))\nfib1_no_init (_, (fn, fn1)) = (fn, (fn1, fn2))\n  where\n  fn2 = fn + fn1\n\nfib1 = init_with (0, 1) fib1_no_init\nfib1_state_bits = 1 + 8 + 8 : [8]\n\nfib2 : ([1], ([1], [16], [16])) -> ([8], ([1], [16], [16]))\nfib2 (_, (start, fn , fn1)) = (fn', (1, fn1', fn2))\n  where\n    fn1' = (zero # start) * fn1 + (zero # ~start)\n  fn2 = fn + fn1'\n  fn' = drop`{8} fn\n\nfib2_state_bits = 1 + 16 + 16 : [8]\n\n\/\/ Make a buggy version of fib state machine which returns wrong value\n\/\/ when state counter has magic value.\n\/\/\n\/\/ If this were a common pattern for example generation, we could\n\/\/ make a \"magic-value bug\" combinator in the style of 'init_with'.\nmk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n    fn' = fn + (if k == magic then 1 else 0)\n\nmk_buggy_fib magic = init_with (0, 1, 0) (mk_buggy_fib_no_init magic)\ncount_buggy_state_bits : {a} (fin a, width a <= 7) => [a] -> [8]\ncount_buggy_state_bits magic = 1 + 8 + 8 + `a\n\n\/\/ 4-bit counter\nbuggy_fib4_magic = 0xf\nbuggy_fib4 = mk_buggy_fib buggy_fib4_magic\nbuggy_fib4_state_bits = count_buggy_state_bits buggy_fib4_magic\n\n\/\/ 8-bit counter\nbuggy_fib8_magic = 0xff\nbuggy_fib8 = mk_buggy_fib buggy_fib8_magic\nbuggy_fib8_state_bits = count_buggy_state_bits buggy_fib8_magic\n\n\/\/ 12-bit counter\nbuggy_fib12_magic = 0b111111111111\nbuggy_fib12 = mk_buggy_fib buggy_fib12_magic\nbuggy_fib12_state_bits = count_buggy_state_bits buggy_fib12_magic\n\n\/\/ 16-bit counter\nbuggy_fib16_magic = 0xffff\nbuggy_fib16 = mk_buggy_fib buggy_fib16_magic\nbuggy_fib16_state_bits = count_buggy_state_bits buggy_fib16_magic\n\n\/\/ 32-bit counter\nbuggy_fib32_magic = 0xffffffff\nbuggy_fib32 = mk_buggy_fib buggy_fib32_magic\nbuggy_fib32_state_bits = count_buggy_state_bits buggy_fib32_magic\n\n\/\/ 64-bit counter\nbuggy_fib64_magic = 0xffffffffffffffff\nbuggy_fib64 = mk_buggy_fib buggy_fib64_magic\nbuggy_fib64_state_bits = count_buggy_state_bits buggy_fib64_magic\n\n\/\/ Tests.\ninputs : [1000][1]\ninputs = zero\n\ntest = equiv fib1 fib2 inputs\n\n\/\/ The states sequences.\nstates1 = exec fib1 inputs\nstates2 = exec fib2 inputs\n```"}]}
{"filename":"saw-script\/examples\/sequential_aigs\/CipherMode.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named CipherMode that imports StateMachine and contains: (1) a type alias for a block cipher taking a key-width parameter and a block-width parameter, mapping a key to a function from one block to one block; and (2) functions implementing six block-cipher modes as state machines. For each mode (ecb, cbc, pcbc, cfb, ofb, ctr): provide an explicit polymorphic type signature over key width and block width; return an SM that consumes one plaintext block per step and produces one ciphertext block; carry the appropriate machine state; and define an initializer and step function. Specify behavior precisely: ecb encrypts the input block with the key and leaves the key unchanged; cbc xors the chaining value with the block before encryption and updates the chaining value to the ciphertext; pcbc updates the chaining value to the xor of the plaintext block and ciphertext; cfb encrypts the chaining value and xors with the block to form ciphertext, updating the chaining value to the ciphertext; ofb updates the chaining value by encrypting it and xors it with the block to form ciphertext; ctr xors the block with the encryption of the concatenation of the IV and a counter, then increments the counter modulo 2^n. For ctr, add constraints that the block width is finite and at least 1, and require the provided block cipher to operate on 2\u00b7n-bit blocks while IV and counter are n bits each. Use xor for mixing and bit concatenation for IV||counter. Initialize states as key, (key, IV), or (key, IV, 0) accordingly."},{"role":"assistant","content":"```cryptol\nmodule CipherMode where\n\nimport StateMachine\n\ntype BC k n = [k] -> [n] -> [n]\n\necb : {k, n} BC k n -> SM ([k], [n]) [n] (Bool, [k])\necb bc = init i sm\n  where\n  sm : SM [n] [n] [k]\n  sm (block, key) = (ct, key)\n    where\n    ct = bc key block\n  i : [k] -> [k]\n  i key = key\n\ncbc : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\ncbc bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key (state ^ block)\n    state' = ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\npcbc : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\npcbc bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key (state ^ block)\n    state' = block ^ ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\ncfb : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\ncfb bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key state ^ block\n    state' = ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\nofb : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\nofb bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    state' = bc key state\n    ct = state' ^ block\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\n\/\/ CounTer Mode.\nctr : {k, n} (fin n, n >= 1) =>\n  BC k (2*n) -> SM (([k], [n]), [2*n]) [2*n] (Bool, ([k], [n], [n]))\nctr bc = init i sm\n  where\n  sm : SM [2*n] [2*n] ([k], [n], [n])\n  sm (block, (key, iv, counter)) = (ct, (key, iv, counter + 1))\n    where\n    ct = bc key (iv # counter) ^ block\n  i : ([k], [n]) -> ([k], [n], [n])\n  i (key, iv) = (key, iv, 0)\n```"}]}
{"filename":"saw-script\/examples\/sequential_aigs\/exp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines two parametric state machines over unsigned words of widths m and n (with m >= 1, n >= 1, and finite sizes): (1) a reference loop that initializes an accumulator to 1, emits a pair (done, result) each step where done is true exactly when the exponent equals zero and result is the accumulator when done (zero otherwise), and otherwise multiplies the accumulator by the base and decrements the exponent by 1; and (2) an optimized loop implementing exponentiation by squaring that, when not done, squares the base, right-shifts the exponent by 1, and conditionally multiplies the accumulator by the base when the least-significant bit of the exponent is 1, emitting the same (done, result) convention. The machines take input (base:[m], exponent:[n]), maintain state (base:[m], exponent:[n], acc:[m]), and output (Bool, [m]). Also define a synchronized composition that jointly steps both machines (parameterized by a 1-bit bias to break ties) and a miter composition that outputs a Boolean asserting equality of their (done, result) outputs at each step. Finally, define a property universally quantifying m, n, base, and exponent which states that the miter\u2019s Boolean output is true for all steps of the execution and that when either machine signals done, both signal done in the same step with identical results."},{"role":"assistant","content":"```cryptol\nimport StateMachine\n\nexp_ref : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) (Bool, [m]) (Bool, ([m], [n], [m]))\nexp_ref = mk_loop (\\(x, p) -> (x, p, 1)) body\n  where\n  body : Body [m] ([m], [n], [m])\n  body (x, p', r) =\n    if p' == 0\n    then ((True, r), (x, p', r))\n    else ((False, zero), (x, p' - 1, r * x))\n\nexp_opt : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) (Bool, [m]) (Bool, ([m], [n], [m]))\nexp_opt = mk_loop (\\(x, p) -> (x, p, 1)) body\n  where\n  body : Body [m] ([m], [n], [m])\n  body (x', p', r) =\n    if p' == 0\n    then ((True, r), (x', p', r))\n    else ((False, zero), (x' * x', p' >> 1, r'))\n      where\n      r' = if (p' && 1) != 0\n           then r * x'\n           else r\n\nsynced_exp : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  [1] -> SM ([m], [n]) (Bool, [m]) ((Bool, ([m], [n], [m])), (Bool, ([m], [n], [m])))\nsynced_exp bias = sync_loops bias exp_ref exp_opt\n\nmitered_exp : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) Bool ((Bool, ([m], [n], [m])), (Bool, ([m], [n], [m])))\nmitered_exp = miter_loops exp_ref exp_opt\n```"}]}
{"filename":"saw-script\/examples\/sequential_aigs\/StateMachine.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named StateMachine that contains the following definitions and behaviors: (1) A type alias for a state machine mapping an input-state pair to an output-state pair. (2) A polymorphic runner that, for a length-n input sequence and a zero-initializable state, iteratively applies the machine starting from the zero state and returns the sequence of output-state pairs. (3) Two projections over the runner to return only the outputs and only the states, respectively. (4) A polymorphic equivalence checker that, given two machines with zero-initializable states, a finite length n, and comparable outputs, returns True iff their output sequences are element-wise equal; include a local Boolean fold that returns the conjunction of a Boolean sequence using an iterative accumulator initialized to True. (5) Wrappers that add one-step initialization: one using a provided initial state value and one using a function from an auxiliary parameter to the initial state; both use a started flag to select between the initial state on the first step and the carried state thereafter. (6) A miter that combines two machines, steps them in lockstep on the same input, returns True when their outputs differ, and threads the product state. (7) Constant machines that always return False and True, respectively, with a 1-bit state initialized to zero, and their corresponding miters showing the satisfiable and unsatisfiable cases. (8) A type alias for loop bodies and a loop constructor that initializes from input when not started and otherwise steps a provided body that returns a done flag, an output, and the next state. (9) A loop runner that drives the loop for n\u22651 steps using a single input followed by zeros (requires finite n and zero-initializable input\/state). (10) A synchronizer for two loops that outputs zero until both are done, then emits a selection-based output using a 1-bit bias, and (11) a loop miter that flags output inequality only once both loops are done. Include all necessary polymorphic type variables and constraints (e.g., Zero, Cmp, fin, and n\u22651)."},{"role":"assistant","content":"```cryptol\nmodule StateMachine where\n\ntype SM i o s = (i, s) -> (o, s)\n\nrun : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](o,s)\nrun sm is = oss\n  where\n  states = [zero] # [ os.1 | os <- oss ]\n  oss = [ sm (i, s) | i <- is | s <- states ]\n\neval : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](o)\neval sm is = [ os.0 | os <- run sm is ]\n\nexec : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](s)\nexec sm is = [ os.1 | os <- run sm is ]\n\nequiv : {n, i, s1, s2, o} (Cmp o, fin n, Zero s1, Zero s2)\n     => SM i o s1 -> SM i o s2 -> [n]i -> Bool\nequiv sm1 sm2 is = all [ o1 == o2 | o1 <- eval sm1 is | o2 <- eval sm2 is ]\n  where\n  all : {m} (fin m) => [m]Bool -> Bool\n  all xs = its ! 0\n    where\n    its = [True] # [ x && it | x <- xs | it <- its ]\n\ninit_with : {i, o, s} s -> SM i o s -> SM i o (Bool, s)\ninit_with s_initial sm (i, (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else s_initial\n  (o, s'') = sm (i, s')\n\ninit : {a, i, o, s}\n  (a -> s) -> SM i o s -> SM (a, i) o (Bool, s)\ninit mk_s_initial sm ((a, i), (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else mk_s_initial a\n  (o, s'') = sm (i, s')\n\nmiter : {i, o, s1, s2} (Cmp o) =>\n  SM i o s1 -> SM i o s2 -> SM i Bool (s1, s2)\nmiter sm1 sm2 (i, (s1, s2)) = (o, (s1', s2'))\n  where\n  (o1, s1') = sm1 (i, s1)\n  (o2, s2') = sm2 (i, s2)\n  o = o1 != o2\n\nconst_false : {i} SM i Bool [1]\nconst_false (_, _) = (False, zero)\n\nconst_true : {i} SM i Bool [1]\nconst_true (_, _) = (True, zero)\n\nsat_miter : SM [1] Bool ([1], [1])\nsat_miter = miter const_true const_false\nunsat_miter : SM [1] Bool ([1], [1])\nunsat_miter = miter const_true const_true\n\ntype Body o s = s -> ((Bool, o), s)\n\nmk_loop : {i,o,s} (i -> s) -> Body o s -> SM i (Bool, o) (Bool, s)\nmk_loop initializer body (i, (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else initializer i\n  (o, s'') = body s'\n\nrun_loop : {n, i, o, s} (fin n, n >= 1, Zero i, Zero s) =>\n  SM i o s -> i -> [n](o, s)\nrun_loop loop i = run loop ([i] # zero)\n\nsync_loops : {i, o, s1, s2} (Zero o) =>\n  [1] -> SM i (Bool, o) s1 -> SM i (Bool, o) s2 -> SM i (Bool, o) (s1, s2)\nsync_loops bias l1 l2 (i, (s1, s2)) = ((done, o'), (s1', s2'))\n  where\n  ((done1, o1), s1') = l1 (i, s1)\n  ((done2, o2), s2') = l2 (i, s2)\n  o = [o1, o2] @ bias\n  done = done1 && done2\n  o' = if done then o else zero\n\nmiter_loops : {i, o, s1, s2} (Cmp o) =>\n  SM i (Bool, o) s1 -> SM i (Bool, o) s2 -> SM i Bool (s1, s2)\nmiter_loops l1 l2 (i, (s1, s2)) = (o', (s1', s2'))\n  where\n  ((done1, o1), s1') = l1 (i, s1)\n  ((done2, o2), s2') = l2 (i, s2)\n  done = done1 && done2\n  o' = if done then o1 != o2 else False\n```"}]}
{"filename":"saw-script\/examples\/openssl_aes\/AES128TBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named AESTBox that contains the following definitions and properties for AES-128 using T-tables: (1) Type aliases: an 8-bit field element type; key length parameters with 4 columns, 4 words, and number of rounds equal to 6 plus the key-length words; a 4-word state type (each word is 32 bits); a key type of 4 words; a round key equal to a state; and a key-schedule triple of initial, middle (array), and final round keys. (2) Finite-field arithmetic over GF(2^8): a function that multiplies two bytes modulo the AES irreducible polynomial x^8+x^4+x^3+x+1, and an exponentiation function over bytes by an 8-bit exponent. (3) Byte\/word utilities: splitting\/joining 32-bit words into four bytes; a right-rotation on four bytes by a 2-bit amount. (4) Constants: the round-constant sequence derived from powers of 2 in GF(2^8); the 256-byte S-box table and its inverse table computed from the S-box mapping. (5) Core AES helpers: XOR-based round-key addition; key expansion producing an infinite stream of round keys using word substitution with S-box and round constants, including the special cases for word positions; precomputed multiplication tables for MixColumns inverse; an inverse MixColumns on state using those tables. (6) Key schedules: functions that build the encryption and decryption key-schedule triples (with decryption middle keys mixed and reversed appropriately). (7) A higher-order round driver that, given a round function, a key-schedule triple, and an input state, applies initial AddRoundKey, iterates middle rounds, and executes a final round; constrain the round-count length to be finite. (8) T-table generation for forward and inverse rounds; round functions that implement SubBytes\/ShiftRows\/(optional MixColumns) and AddRoundKey depending on the final-round flag. (9) Top-level encryption and decryption functions over a 4-word state and 4-word key. (10) Properties: two test-vector properties checking known AES-128 encryption and decryption results; a property combining them by conjunction; a property asserting S-box and inverse compose to identity on a byte; a property that distinct keys yield distinct encryption key schedules; and a property that decryption inverts encryption for any state and key. Include fold\/reduce and zip-with helpers as needed with appropriate finiteness constraints."},{"role":"assistant","content":"```cryptol\nmodule AESTBox where\n\ntype GF28 = [8]\ntype Nk = 4\ntype Nb = 4\ntype Nr = 6 + Nk\n\ntype State = [4][Nb * 8]\ntype Key = [Nk][Nb * 8]\ntype RoundKey = State\ntype KS = (RoundKey, [Nr - 1]RoundKey, RoundKey)\n\ngf28Mult : GF28 -> GF28 -> GF28\ngf28Mult x y = pmod (pmult x y) <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Pow : GF28 -> [8] -> GF28\ngf28Pow n k =\n  if k == 0 then 1\n  else\n    (if (k && 1) == 1 then gf28Mult n w\n     else w\n       where v = gf28Pow n (k >> 1)\n             w = gf28Mult v v)\n\ntoBytes : [32] -> [4]GF28\ntoBytes x = split`{4} x\n\nfromBytes : [4]GF28 -> [32]\nfromBytes xs = join xs\n\nrotR : [4]GF28 -> [2] -> [4]GF28\nrotR xs n = xs >>> n\n\nroundConstants = take`{16} ([0] # [ gf28Pow 2 (k-1) | k <- [1 ... ] ])\n\nsbox = [ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n         0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n         0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n         0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n         0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n         0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n         0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n         0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n         0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n         0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n         0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n         0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n         0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n         0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n         0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n         0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n         0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n         0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n         0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n         0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n         0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n         0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n         0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n         0x54, 0xbb, 0x16]\n\nunsbox = [ unsboxf i sboxit 0 0 | i <- [ 0 .. 255] ]\n  where sboxit = [ (j, i) | i <- [ 0 .. 255] | j <- sbox ]\n        unsboxf n t i d = if i >= (length t) then d\n                          else (if (k == n) then v\n                                else unsboxf n t (i + 1) d\n                                  where (k, v) = t @ i)\n\naddRoundKey : RoundKey -> State -> State\naddRoundKey k s = k ^ s\n\nkeyExpansion : Key -> [inf]RoundKey\nkeyExpansion key = chop4 keys\n  where keys = key # [nextWord i prev old | i <- [ `Nk ... ] | prev <- drop`{Nk-1} keys | old <- keys]\n        chop4 : {a} [inf]a -> [inf][4]a\n        chop4 xs = split xs\n        subWordRcon : [Nb * 8] -> GF28 -> [Nb * 8]\n        subWordRcon w rc = fromBytes [a ^ rc, b, c, d]\n          where [a, b, c, d] = [ sbox @ i | i <- toBytes w ]\n        nextWord : [8] -> [Nb * 8] -> [Nb * 8] -> [Nb * 8]\n        nextWord i prev old = old ^\n          (if (i % `Nk) == 0 then subWordRcon (join (split`{4} prev <<< 1)) (roundConstants @ (i \/ `Nk))\n           else if (i % `Nk) == 4 \/\\ `Nk > 6 then subWordRcon prev 0\n           else prev)\n\nmETable = [ gf28Mult 0x0E i | i <- [ 0 .. 255 ] ]\nmBTable = [ gf28Mult 0x0B i | i <- [ 0 .. 255 ] ]\nmDTable = [ gf28Mult 0x0D i | i <- [ 0 .. 255 ] ]\nm9Table = [ gf28Mult 0x09 i | i <- [ 0 .. 255 ] ]\nmE i = mETable @ i\nmB i = mBTable @ i\nmD i = mDTable @ i\nm9 i = m9Table @ i\ntables = [ [mE, mB, mD, m9],\n           [m9, mE, mB, mD],\n           [mD, m9, mE, mB],\n           [mB, mD, m9, mE] ]\n\ninvMixColumns : State -> State\ninvMixColumns state = [ fromBytes ce | ce <- transpose (mmult [ toBytes se | se <- state ]) ]\n  where dollar f x = f x\n        dot f fs =  foldr1 (^) (zipWith dollar f fs)\n        mmult n = [ [ (dot r) ne | ne <- n ] | r <- tables ]\n\naesEncryptKeySchedule : Key -> KS\naesEncryptKeySchedule key = (rKeys @ 0, m, rKeys @ `Nr)\n  where rKeys = keyExpansion key\n        m = take`{Nr-1}(tail rKeys)\n\naesDecryptKeySchedule : Key -> KS\naesDecryptKeySchedule key = (rKeys @ `Nr, m, rKeys @ 0)\n  where rKeys = keyExpansion key\n        m = [ invMixColumns k | k <- reverse (take`{Nr-1}(tail rKeys)) ]\n\ndoRounds : {a, b} (fin b) => (Bit -> State -> a -> State) -> (RoundKey, [b]a, a) -> State -> State\ndoRounds rnd (ikey, rkeys, fkey) sIn = rnd True (rs ! 0) fkey\n  where s0 = addRoundKey ikey sIn\n        rs = [s0] # [ rnd False s k | s <- rs | k <- rkeys ]\n\nt0Func : GF28 -> [4]GF28\nt0Func a = [gf28Mult s 2, s, s, gf28Mult s 3] where s = sbox @ a\nt0 = [fromBytes (t0Func a) | a <- [0..255]]\nt1 = [fromBytes (rotR (t0Func a) 1) | a <- [0..255]]\nt2 = [fromBytes (rotR (t0Func a) 2) | a <- [0..255]]\nt3 = [fromBytes (rotR (t0Func a) 3) | a <- [0..255]]\n\naesRound : Bit -> State -> RoundKey -> State\naesRound isFinal s key = addRoundKey d key\n  where d = [ f isFinal i | i <- [ 0 .. 3] ]\n        a = [ toBytes se | se <- s ]\n        f b j = if b then\n                  fromBytes [ sbox @ (a @ ((j+0) % 4) @ 0),\n                              sbox @ (a @ ((j+1) % 4) @ 1),\n                              sbox @ (a @ ((j+2) % 4) @ 2),\n                              sbox @ (a @ ((j+3) % 4) @ 3) ]\n                else\n                  e0 ^ e1 ^ e2 ^ e3\n                    where e0 = t0 @ (a @ ((j+0) % 4) @ 0)\n                          e1 = t1 @ (a @ ((j+1) % 4) @ 1)\n                          e2 = t2 @ (a @ ((j+2) % 4) @ 2)\n                          e3 = t3 @ (a @ ((j+3) % 4) @ 3)\n\nu0Func : GF28 -> [4]GF28\nu0Func a = [gf28Mult s 0x0E, gf28Mult s 0x09, gf28Mult s 0x0D, gf28Mult s 0x0B] where s = unsbox @ a\nu0 = [fromBytes (u0Func a) | a <- [0..255]]\nu1 = [fromBytes (rotR (u0Func a) 1) | a <- [0..255]]\nu2 = [fromBytes (rotR (u0Func a) 2) | a <- [0..255]]\nu3 = [fromBytes (rotR (u0Func a) 3) | a <- [0..255]]\n\naesInvRound : Bit -> State -> RoundKey -> State\naesInvRound isFinal s key = addRoundKey d key\n  where d = [ f isFinal i | i <- [ 0 .. 3] ]\n        a = [ toBytes se | se <- s ]\n        f b j = if b then\n                  fromBytes [ unsbox @ (a @ ((j+0) % 4) @ 0),\n                              unsbox @ (a @ ((j+3) % 4) @ 1),\n                              unsbox @ (a @ ((j+2) % 4) @ 2),\n                              unsbox @ (a @ ((j+1) % 4) @ 3) ]\n                else\n                  e0 ^ e1 ^ e2 ^ e3\n                    where e0 = u0 @ (a @ ((j+0) % 4) @ 0)\n                          e1 = u1 @ (a @ ((j+3) % 4) @ 1)\n                          e2 = u2 @ (a @ ((j+2) % 4) @ 2)\n                          e3 = u3 @ (a @ ((j+1) % 4) @ 3)\n\naesEncrypt pt key = doRounds aesRound (aesEncryptKeySchedule key) pt\n\naesDecrypt ct key = doRounds aesInvRound (aesDecryptKeySchedule key) ct\n\nproperty t128EncTest = aesEncrypt pt k == [0x69c4e0d8, 0x6a7b0430, 0xd8cdb780, 0x70b4c55a]\n  where pt = [ 0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff ]\n        k = [ 0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f ]\n\nproperty t128DecTest = aesDecrypt ct k == [0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff]\n  where ct = [ 0x69c4e0d8, 0x6a7b0430, 0xd8cdb780, 0x70b4c55a ]\n        k = [ 0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f ]\n\nproperty AESTests = t128EncTest && t128DecTest\n\nproperty sboxUnsboxInverse (n : [8]) = n == (unsbox @ (sbox @ n))\n\nproperty keyExpansionInjective k1 k2 =\n  if k1 != k2\n  then aesEncryptKeySchedule k1 != aesEncryptKeySchedule k2\n  else True\n\nproperty encDecInverse pt k = (aesDecrypt (aesEncrypt pt k) k) == pt\n\nfoldr : {a,b,n} (fin n) => (a -> b -> b) -> b -> [n]a -> b\nfoldr f acc xs = ys ! 0\n  where ys = [acc] # [f x a | a <- ys | x <- reverse xs]\n\nfoldr1 : {a, b} (fin b) => (a -> a -> a) -> [1 + b]a -> a\nfoldr1 f xs = foldr f (xs @ 0) (tail xs)\n\nzipWith : {a,b,c,n} (a -> b -> c) -> [n]a -> [n]b -> [n]c\nzipWith f xs ys = [f x y | x <- xs | y <- ys]\n```"}]}
{"filename":"saw-script\/examples\/ecdsa\/cryptol-spec\/ecc.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named ecc that imports the required support libraries for big integers, modular arithmetic, elliptic-curve fields\/points, and P-384 operations. Inside, provide these items with explicit types and behavior: 1) A constant 4-tuple of test parameters with element types: 384-bit scalar, affine P-384 point, 384-bit nonce, and affine P-384 point. 2) A parametric record type for an elliptic curve that includes point operations, a base point, an affine conversion from Jacobian, single-scalar multiplication, and double-scalar (twin) multiplication; the types are indexed by a bit-width parameter for both field and scalar groups. 3) A function that computes a public key by multiplying a scalar by the base point and converting to affine. 4) A generic ECDSA signing function over bit-width fv (with fin fv and fv \u2265 1), producing (r,s) where r is the normalized x-coordinate of k\u00b7G and s = (e + d\u00b7r)\/k in the group; return zeros if either component is group-zero. 5) A generic ECDSA public verification function that checks s is in range, computes s\u207b\u00b9, u1, u2, performs twin multiplication, derives the x-coordinate via field operations, normalizes, and compares to r. 6) A P-384\u2013specialized verification function that also enforces nonzero projective z, handles reduction via conditional addition of the group order, computes a carrybits flag, and accepts either direct or adjusted x-equality when no carry occurs. 7) A record type carrying a small-width carry flag with a 384-bit result, and two functions that add\/subtract the P-384 prime, returning the low 384 bits and carrybits. 8) Helper functions\/constants for P-384: cube via sq\u00b7mul, base point coordinates, group add alias, a Curve instance wiring P-384 ops, sign\/verify wrappers, curve parameters a and b, affine\/jacobian conversions, derived base multiples, and a predicate returning Bit that checks the Weierstrass curve equation over the P-384 field."},{"role":"assistant","content":"```cryptol\nmodule ecc where\n\nimport bv\nimport mod_arith\nimport mul_java\n\nimport Field \nimport ec_point_ops\nimport ref_ec_mul\nimport p384_field\nimport p384_ec_point_ops\nimport p384_ec_mul\n\ntest_params : ([384], AffinePoint [384], [384], AffinePoint [384])\ntest_params =\n  (0xe74872524f90425d832a4f264e1f7b9209ec7456e9b4c467d8eac6c68f973ea7fea24f4d3fa8498bb1e26f933eaa261b\n  , { x=0xbbab93c429707b2afe9ac285314d7b40c4ee31531b13291aa9058307cdd038b572fdf2f3a84dc912804fa426fe531a3c\n    , y=0x4c2cffaa333bfd82b575918bb979bf51480c836082c097a03fed5454877b37d2f44f0401d212c16b05052bd383047b31\n    }\n  , 0xd4356773f2b311955542c5835696b9dca9d0e59197d5746bbf7dc079a666d955f74114662e38d31196bf94b060cc0c80\n  , { x=0xd40c63c65b413d0741c56e884f0dca63b822a6f6879d36f9261d9b4a270d5d79a9be790fdfb871b5d6ae9204da692663\n    , y=0x4d6b2b937c85b3c0c3cd2df85e9307cc89e0093f336af3b4531aa126bbdbec466562d8aa0dc1cf360fc1f1d0951e3ad1\n    })\n\ntype Curve fv gv = {\n    point_ops : PointOps fv gv\n  , base : AffinePoint fv\n  , affinify : JacobianPoint fv -> AffinePoint fv\n  , mul : (gv, AffinePoint fv) -> JacobianPoint fv\n  , twin_mul : (gv, AffinePoint fv, gv, AffinePoint fv) -> JacobianPoint fv\n  }\n\ninitialize_public_key : {fv} (Curve [fv] [fv], [fv]) -> AffinePoint [fv]\ninitialize_public_key(c, k) = c.affinify(c.mul(k, c.base))\n\necdsa_sign : {fv} (fin fv, fv >= 1) => (Curve [fv] [fv], [fv], [fv], [fv]) -> ([fv], [fv])\necdsa_sign(c,d,e,k) = if is_zero(r) || is_zero(s) then (0,0) else (r, s)\n  where\n    g = c.point_ops.group_field\n    is_zero(x) = g.is_equal(x, g.field_zero)\n\n    j = (c.affinify(c.mul(k, c.base))).x\n\n    r = g.normalize(j)\n    s = g.div(g.add(g.normalize(e), g.mul(d, r)), k)\n\necdsa_public_verify : {fv} (fin fv, fv >= 1)\n   => (Curve [fv] [fv], [fv], ([fv], [fv]), AffinePoint [fv]) -> Bit\necdsa_public_verify(c, e, (r, s), q)\n\n   = in_range(s) && (v == r)\n  where\n    f = c.point_ops.field\n    g = c.point_ops.group_field\n    mul(x,y) = g.mul(x, y)\n    div(x,y) = g.div(x, y)\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    in_range(x) = ~is_zero(x) && g.is_val(x)\n    s_inv = div(1, s)\n    u1 = mul(e, s_inv)\n    u2 = mul(r, s_inv)\n    r2 = c.twin_mul(u1, c.base, u2, q)\n\n    j = f.mul(r2.x, f.sq(f.div(f.field_unit, r2.z)))\n\n    v = g.normalize(j)\n\necdsa_public_verify_imp :\n  (Curve [384] [384], [384], ([384], [384]), AffinePoint [384]) -> Bit\necdsa_public_verify_imp(c, e, (r, s), q)\n   = in_range(r) && in_range(s) &&\n     ~is_zero(r2.z) &&\n     (g.is_equal(j, r2.x) || ((carrybits == False) && (g.is_equal(k, r2.x))))\n  where\n    f = c.point_ops.field\n    g = c.point_ops.group_field\n    mul(x,y) = g.mul(x, y)\n    div(x,y) = g.div(x, y)\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    in_range(x) = ~is_zero(x) && g.is_val(x)\n    s_inv = div(1, s)\n    u1 = mul(g.normalize(e), s_inv)\n    u2 = mul(r, s_inv)\n    r2 = c.twin_mul(u1, c.base, u2, q)\n    r2zsq = f.sq(r2.z)\n    j = f.mul(r, r2zsq)\n    sum = r + p384_group_size\n    carrybits = (sum < r) && (sum < p384_group_size)\n    k = f.mul(sum, r2zsq)\n\ntype RsltWithCarry a b = { carrybits : a , rslt : b }\n\np384_incFieldPrime : [384] -> RsltWithCarry [32] [384]\np384_incFieldPrime x = { carrybits = zero # [(bs @ 0)]\n                       , rslt = drop(bs) : [384]\n                       }\n  where bs = safe_add(x, p384_prime)\n\np384_decFieldPrime : [384] -> RsltWithCarry [32] [384]\np384_decFieldPrime x = { carrybits = if (bs @ 0) then -1 else 0\n                       , rslt = drop(bs) : [384]\n                       }\n  where bs = safe_sub(x, p384_prime)\n\np384_field_cube(x)       = p384_field_mul(x, p384_field_sq(x))\n\np384_base : AffinePoint [384]\np384_base = nzAffinePoint(\n  join [0xaa87ca22, 0xbe8b0537, 0x8eb1c71e, 0xf320ad74, 0x6e1d3b62, 0x8ba79b98\n       ,0x59f741e0, 0x82542a38, 0x5502f25d, 0xbf55296c, 0x3a545e38, 0x72760ab7],\n  join [0x3617de4a, 0x96262c6f, 0x5d9e98bf, 0x9292dc29, 0xf8f41dbd, 0x289a147c\n       ,0xe9da3113, 0xb5f0b8c0, 0x0a60b1ce, 0x1d7e819d, 0x7a431d7c, 0x90ea0e5f])\n\np384_group_add : ([384],[384]) -> [384]\np384_group_add = p384_group_field.add\n\np384_curve : Curve [384] [384]\np384_curve =\n  { point_ops = p384_point_ops\n  , base = p384_base\n  , affinify = \\x -> ec_affinify(p384_field, x)\n  , mul = p384_ec_mul\n  , twin_mul = p384_ec_twin_mul\n  }\n\np384_ecdsa_sign : ([384], [384], [384]) -> { r:[384], s:[384] }\np384_ecdsa_sign(d,e,k) = { r = rr, s = ss }\n  where (rr, ss) = ecdsa_sign(p384_curve,d,e,k)\n\np384_ecdsa_public_verify : ([384], [384], [384], AffinePoint [384]) -> Bit\np384_ecdsa_public_verify(e,pr,ps,q) =\n  ecdsa_public_verify_imp(p384_curve,e,(pr,ps),q)\n\np384_a : [384]\np384_a = p384_prime - 3\n\np384_b : [384]\np384_b = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\n\np384_affinify : JacobianPoint [384] -> AffinePoint [384]\np384_affinify p = ec_affinify(p384_field, p)\n\np384_jacobify : AffinePoint [384] -> JacobianPoint [384]\np384_jacobify p = { x = p.x, y = p.y, z = 1 }\n\np384_base4 : JacobianPoint [384]\np384_base4 = p384_ec_double(p384_ec_double(p384_jacobify(p384_base)))\n\np384_base3 : AffinePoint [384]\np384_base3 = p384_affinify(p384_ec_full_sub(p384_base4, p384_base))\n\np384_base5 : AffinePoint [384]\np384_base5 = p384_affinify(p384_ec_full_add(p384_base4, p384_base))\n\np384_is_affine_point : AffinePoint [384] -> Bit\np384_is_affine_point p =\n  p384_field_sq(p.y) ==\n  p384_field_add(p384_field_cube(p.x),\n                 p384_field_add(p384_field_mul(p384_a, p.x), p384_b))\n```"}]}
{"filename":"saw-script\/examples\/llvm\/iterative_average\/test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that includes: (1) a record type State with two 32-bit fields for running sum and element count; (2) a constant init of type State with both fields set to zero; (3) a polymorphic function updatef with type {n} (fin n, 32 >= width n) => State -> [n][32] -> State that returns a new state whose sum is the prior sum plus the total of the n 32-bit inputs (using 32-bit addition) and whose len is the prior count plus n; (4) a function digest : State -> [32] that returns the 32-bit quotient of sum divided by len; (5) a function avg : {n} (fin n, 32 >= width n) => [n][32] -> [32] that returns the 32-bit average of a sequence as total sum divided by n; and (6) define a property imp_correct that, under the same constraints on n, verifies for all sequences of n 32-bit words that the direct average equals the digest of the state produced by applying updatef to init with that sequence. Provide explicit type signatures and ensure all arithmetic is 32-bit unsigned."},{"role":"assistant","content":"```cryptol\ntype State =\n  { sum : [32]\n  , len : [32]\n  }\n\ninit : State\ninit =\n  { sum = 0\n  , len = 0\n  }\n\nupdatef : {n} (fin n, 32 >= width n) => State -> [n][32] -> State\nupdatef st xs =\n  { sum = st.sum + sum\n  , len = st.len + `n\n  }\n  where\n    sum = sums!0\n    sums = [ 0 ] # [ acc + x | acc <- sums | x <- xs ]\n\ndigest : State -> [32]\ndigest st = st.sum \/ st.len\n\navg : {n} (fin n, 32 >= width n) => [n][32] -> [32]\navg xs = sum \/ `n\n  where\n    sum = sums!0\n    sums = [ 0 ] # [ acc + x | acc <- sums | x <- xs ]\n\nimp_correct : {n} (fin n, 32 >= width n) => [n][32] -> Bool\nproperty imp_correct xs = avg xs == digest (updatef init xs)\n```"}]}
{"filename":"saw-script\/examples\/llvm\/union\/test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, write a specification that models a tagged union stored in 64 bits with two variants and an update operation. Define: (1) a 32-bit word type alias; (2) two 32-bit selector constants with values 0 and 1; (3) two record types: variant A with one 32-bit field, and variant B with two 32-bit fields; (4) a 64-bit bitfield type and a top-level record containing a selector and the 64-bit bitfield. Provide conversion functions: from the 64-bit bitfield to variant A by reading the high-order 32 bits; from a 64-bit bitfield and a variant A value back to 64 bits by replacing the high-order 32 bits while preserving the low-order 32 bits; from the 64-bit bitfield to variant B by splitting into high and low 32-bit halves; and from variant B to 64 bits by concatenating its fields as high then low. Implement incrementers: variant A adds 1 to its single field; variant B adds 1 to each field; all arithmetic wraps modulo 2^32. Implement an update function on the top-level record that preserves the selector and: if the selector equals the first constant, interprets the bitfield as variant A, increments it, and writes back replacing only the high half; otherwise interprets as variant B, increments both fields, and writes back both halves. Include Cryptol properties asserting: (a) the variant B convert-then-serialize round-trip is identity on 64-bit bitfields; (b) the variant A writeback replaces only the high half and keeps the low half unchanged; (c) the update function\u2019s result matches the per-variant increment semantics for both selector values."},{"role":"assistant","content":"```cryptol\ntype Alg = [32]\nINC_1 = 0 : Alg\nINC_2 = 1 : Alg\n\ntype Inc_1_st =\n  { x : [32]\n  }\n\ntype Inc_2_st =\n  { x : [32]\n  , y : [32]\n  }\n\ntype UNION_BITS = 32+32\n\ntype St =\n  { alg : Alg\n  , bits : [UNION_BITS]\n  }\n\nbits_to_inc_1_st : [UNION_BITS] -> Inc_1_st\nbits_to_inc_1_st bits = { x = take`{32} bits }\n\ninc_1_st_to_bits : [UNION_BITS] -> Inc_1_st -> [UNION_BITS]\ninc_1_st_to_bits bits st = st.x # drop`{32} bits\n\nbits_to_inc_2_st : [UNION_BITS] -> Inc_2_st\nbits_to_inc_2_st bits = { x = take`{32} bits, y = drop`{32} bits }\ninc_2_st_to_bits : Inc_2_st -> [UNION_BITS]\ninc_2_st_to_bits st = st.x # st.y\n\ninc : St -> St\ninc st = { alg = st.alg, bits = bits }\n  where\n    bits =\n      if st.alg == INC_1 then\n        inc_1_st_to_bits st.bits\n          (inc_1 (bits_to_inc_1_st st.bits))\n      else\n        inc_2_st_to_bits\n          (inc_2 (bits_to_inc_2_st st.bits))\n\ninc_1 : Inc_1_st -> Inc_1_st\ninc_1 st = { x = st.x + 1 }\n\ninc_2 : Inc_2_st -> Inc_2_st\ninc_2 st = { x = st.x + 1, y = st.y + 1}\n```"}]}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/xordomain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named xordomain that contains the following definitions: (1) A type synonym Dom n as a record with fields val and unknown, each an n-bit sequence. (2) A function mem with type, for any finite n, Dom n -> [n] -> Bit, returning true when the candidate n-bit value is equal to the record\u2019s value or permitted by the record\u2019s unknown mask via logical disjunction. (3) A function bxor with type, for any finite n, Dom n -> Dom n -> Dom n, whose result has val computed as the bitwise XOR of the inputs\u2019 val fields combined by bitwise disjunction with the combined unknown mask, and unknown computed as the bitwise disjunction of the inputs\u2019 unknown masks. (4) A function band with type, for any finite n, Dom n -> Dom n -> Dom n, whose result has val as the bitwise conjunction of the inputs\u2019 val fields, and unknown as the bitwise disjunction of the inputs\u2019 unknown masks further masked by the computed val via bitwise conjunction. (5) A function band_scalar with type, for any finite n, Dom n -> [n] -> Dom n, whose result has val as the bitwise conjunction of the record\u2019s val and the scalar, and unknown as the bitwise conjunction of the record\u2019s unknown and the scalar. (6) A predicate correct_bxor with type, for any finite n, Dom n -> Dom n -> [n] -> [n] -> Bit, stating that if a value is in the first domain and a value is in the second domain (per mem), then their bitwise XOR is in the bxor result. (7) A predicate correct_band with the analogous implication for bitwise conjunction and band. (8) A predicate correct_band_scalar with the analogous implication for bitwise conjunction with a scalar and band_scalar. (9) Properties x1, x2, and x3 that instantiate these three predicates at width 16. Include all necessary fin n constraints and explicit type signatures."},{"role":"assistant","content":"```cryptol\nmodule xordomain where\n\ntype Dom n = { val : [n], unknown : [n] }\n\nmem : {n} (fin n) => Dom n -> [n] -> Bit\nmem a x = a.val == x || a.unknown\n\nbxor : {n} (fin n) => Dom n -> Dom n -> Dom n\nbxor a b = { val = v || u, unknown = u }\n  where\n  v = a.val ^ b.val\n  u = a.unknown || b.unknown\n\nband : {n} (fin n) => Dom n -> Dom n -> Dom n\nband a b = { val = v, unknown = u && v }\n  where\n  v   = a.val && b.val\n  u   = a.unknown || b.unknown\n\nband_scalar : {n} (fin n) => Dom n -> [n] -> Dom n\nband_scalar a x = { val = a.val && x, unknown = a.unknown && x }\n\ncorrect_bxor : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_bxor a b x y =\n  mem a x ==> mem b y ==> mem (bxor a b) (x ^ y)\n\ncorrect_band : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_band a b x y =\n  mem a x ==> mem b y ==> mem (band a b) (x && y)\n\ncorrect_band_scalar : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_band_scalar a x y =\n  mem a x ==> mem (band_scalar a y) (x && y)\n\nproperty x1 = correct_bxor`{16}\nproperty x2 = correct_band`{16}\nproperty x3 = correct_band_scalar`{16}\n```"}]}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/bvdomain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named bvdomain that imports arithdomain as A, bitsdomain as B, and xordomain as X. Use a width parameter n (finite; functions noted require n >= 1). Provide:\n- A function bitwise_round_above: [n] x [n] -> [n], rounding x upward guided by a mask using a right-fill of change bits, combining x and mask with bitwise ops.\n- Boolean predicates bra_correct1 and bra_correct2 over [n] values that respectively state soundness (ordering and bitwise inclusion) and minimality of the rounding result from bitwise_round_above. Define properties bra1 and bra2 as these predicates specialized to 64-bit.\n- A function bitwise_round_between: [n] x [n] x [n] -> [n], rounding x to a value within a bitwise domain bounded by low\/high masks via computed r, rmask, lowbits, highbit, and upper\/lower combinations.\n- Boolean predicates brb_correct1 and brb_correct2 asserting, respectively, soundness (bounds and bitwise inclusions) and minimality for bitwise_round_between; properties brb1 and brb2 specialize them at 64-bit.\n- Predicates arith_overlap_candidates, bitwise_overlap_candidates, and mixed_overlap_candidates that, given A::Dom n, B::Dom n, and a value, describe constructive overlap witnesses for arithmetic, bitwise, and mixed domains.\n- A function mixed_domain_overlap: A::Dom n -> B::Dom n -> Bit that tests mixed-domain overlap via candidate checks, and predicates correct_mixed_domain_overlap and correct_mixed_domain_overlap_inv (with a concrete witness when the bitwise domain is nonempty). Define properties mx and mx_inv at 64-bit.\n- Conversions between domains: arithToBitDom, bitToArithDom, bitToXorDom, xorToBitDom, arithToXorDom, with predicates correct_* proving membership preservation; properties t1..t5 at 16-bit.\n- Utility functions popcount, countLeadingZeros, countTrailingZeros, and lifts popcnt, clz, ctz from B::Dom to A::Dom with predicates correct_popcnt, correct_clz, correct_ctz; properties w1..w3 at 16-bit.\n- Equivalence predicates equiv_bxor, equiv_band (assuming nonempty inputs), and equiv_band_scalar between B and X formulations; properties e1..e3 at 16-bit."},{"role":"assistant","content":"```cryptol\nmodule bvdomain where\n\nimport arithdomain as A\nimport bitsdomain as B\nimport xordomain as X\n\nbitwise_round_above : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\nbitwise_round_above x mask = (x && ~q) ^ (mask && q)\n  where\n  q = A::fillright_alt ((x || mask) ^ x)\n\nbra_correct1 : {n} (fin n, n>=1) => [n] -> [n] -> Bit\nbra_correct1 x mask = mask <= x ==> (x <= q \/\\ B::bitle mask q)\n  where\n  q = bitwise_round_above x mask\n\nbra_correct2 : {n} (fin n, n>=1) => [n] -> [n] -> [n] -> Bit\nbra_correct2 x mask q' = (x <= q' \/\\ B::bitle mask q') ==> q <= q'\n  where\n  q = bitwise_round_above x mask\n\nproperty bra1 = bra_correct1`{64}\nproperty bra2 = bra_correct2`{64}\n\nbitwise_round_between : {n} (fin n, n >= 1) => [n] -> [n] -> [n] -> [n]\nbitwise_round_between x lomask himask = if r == 0 then loup else final\n    where\n\n    final = (upper && ~lowbits) || lomask\n\n      upper = (z + highbit) && himask\n\n        z = loup || ~himask\n\n    highbit = rmask ^ lowbits\n\n    lowbits = rmask >> 1\n\n    rmask = A::fillright_alt r\n\n      r = loup && ~himask\n\n    loup = bitwise_round_above x lomask\n\nbrb_correct1 : {n} (fin n, n>=1) => [n] -> [n] -> [n] -> Bit\nbrb_correct1 x lomask himask =\n    (B::bitle lomask himask \/\\ lomask <= x \/\\ x <= himask) ==>\n    (x <= q \/\\ B::bitle lomask q \/\\ B::bitle q himask)\n\n  where\n  q = bitwise_round_between x lomask himask\n\nbrb_correct2 : {n} (fin n, n>=1) => [n] -> [n] -> [n] -> [n] -> Bit\nbrb_correct2 x lomask himask q' = (x <= q' \/\\ B::bitle lomask q' \/\\ B::bitle q' himask) ==> q <= q'\n  where\n  q = bitwise_round_between x lomask himask\n\nproperty brb1 = brb_correct1`{64}\nproperty brb2 = brb_correct2`{64}\n\n\/\/ Interesting fact about arithmetic domains: the low values of the two domains\n\/\/ represent overlap candidates.  If neither low value is contained in the other domain,\n\/\/ then they do not overlap.\narith_overlap_candidates : {n} (fin n, n >= 1) => A::Dom n -> A::Dom n -> [n] -> Bit\narith_overlap_candidates a b x =\n  A::mem a x ==>\n  A::mem b x ==>\n  ((A::mem a b.lo \/\\ A::mem b b.lo) \\\/\n   (A::mem a a.lo \/\\ A::mem b a.lo))\n\n\/\/ Bitwise domains, if they overlap, must overlap in some specific points.  The bitwise\n\/\/ union of the low bounds is one.\nbitwise_overlap_candidates : {n} (fin n, n >= 1) => B::Dom n -> B::Dom n -> [n] -> Bit\nbitwise_overlap_candidates a b x =\n  B::mem a x ==>\n  B::mem b x ==>\n  (B::mem a witness \/\\ B::mem b witness)\n\n where\n witness = a.lomask || b.lomask\n\n\/\/ If mixed domains have some common value, then they must definintely overlap at one\n\/\/ of the following three listed candidate points.\nmixed_overlap_candidates : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> [n] -> Bit\nmixed_overlap_candidates a b x =\n  A::mem a x ==>\n  B::mem b x ==>\n  (A::mem a b.lomask \/\\ B::mem b b.lomask) \\\/\n  (A::mem a b.himask \/\\ B::mem b b.himask) \\\/\n  (A::mem a next     \/\\ B::mem b next)\n\n where\n next = bitwise_round_between a.lo b.lomask b.himask\n\n\/\/ A mixed domain overlap test.  It relies on testing special candidate overlap values.\n\/\/\n\/\/ If none of the overlap candidates are found in both domains, then the domains do not overlap.\n\/\/ On the other hand, if any canadiate is in both domains, it is a constructive witness of\n\/\/ overlap.\nmixed_domain_overlap : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> Bit\nmixed_domain_overlap a b =\n  A::mem a b.lomask \\\/ A::mem a b.himask \\\/ A::mem a (bitwise_round_between a.lo b.lomask b.himask)\n\n\/\/ If mixed domains have a common element, the overlap test will be true.\ncorrect_mixed_domain_overlap : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> [n] -> Bit\ncorrect_mixed_domain_overlap a b x =\n  A::mem a x ==>\n  B::mem b x ==>\n  mixed_domain_overlap a b\n\n\/\/ If the overlap test is true, then we can find some element they share in common,\n\/\/ provided the bitwise domain is nonempty.\ncorrect_mixed_domain_overlap_inv : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> Bit\ncorrect_mixed_domain_overlap_inv a b =\n  B::nonempty b ==> mixed_domain_overlap a b ==> (A::mem a witness \/\\ B::mem b witness)\n\n where\n witness = if A::mem a b.lomask then b.lomask else\n           if A::mem a b.himask then b.himask else\n           bitwise_round_between a.lo b.lomask b.himask\n\nproperty mx = correct_mixed_domain_overlap`{64}\nproperty mx_inv = correct_mixed_domain_overlap_inv`{64}\n\n\/\/ Operations that transfer between the domains\n\narithToBitDom : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n\narithToBitDom a = { lomask = lo, himask = hi }\n  where\n  u  = A::unknowns a\n  hi = a.lo || u\n  lo = hi ^ u\n\nbitToArithDom : {n} (fin n) => B::Dom n -> A::Dom n\nbitToArithDom b = A::range b.lomask b.himask\n\nbitToXorDom : {n} (fin n) => B::Dom n -> X::Dom n\nbitToXorDom b = { val = b.himask, unknown = b.lomask ^ b.himask }\n\nxorToBitDom : {n} (fin n) => X::Dom n -> B::Dom n\nxorToBitDom x = { lomask = x.val ^ x.unknown, himask = x.val }\n\narithToXorDom : {n} (fin n, n >= 1) => A::Dom n -> X::Dom n\narithToXorDom a = { val = a.lo || u, unknown = u }\n  where\n  u = A::unknowns a\n\n\/\/ A small collection of operations that start in one\n\/\/ domain and end in the other\n\npopcount : {n} (fin n, n>=1) => [n] -> [n]\npopcount bs = sum [ zero#[b] | b <- bs ]\n\ncountLeadingZeros : {n} (fin n, n>=1) => [n] -> [n]\ncountLeadingZeros x = loop 0\n where\n loop n =\n   if n >= length x then\n     length x\n   else\n     if x@n then n else loop (n+1)\n\ncountTrailingZeros : {n} (fin n, n>=1) => [n] -> [n]\ncountTrailingZeros xs = countLeadingZeros (reverse xs)\n\npopcnt : {n} (fin n, n>=1) => B::Dom n -> A::Dom n\npopcnt b = A::range lo hi\n  where\n  lo = popcount b.lomask\n  hi = popcount b.himask\n\nclz : {n} (fin n, n>=1) => B::Dom n -> A::Dom n\nclz b = A::range lo hi\n where\n lo = countLeadingZeros b.himask\n hi = countLeadingZeros b.lomask\n\nctz : {n} (fin n, n>=1) => B::Dom n -> A::Dom n\nctz b = A::range lo hi\n where\n lo = countTrailingZeros b.himask\n hi = countTrailingZeros b.lomask\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Correctness properties\n\ncorrect_arithToBitDom : {n} (fin n, n >= 1) => A::Dom n -> [n] -> Bit\ncorrect_arithToBitDom a x =\n  A::mem a x ==> B::mem (arithToBitDom a) x\n\ncorrect_bitToArithDom : {n} (fin n) => B::Dom n -> [n] -> Bit\ncorrect_bitToArithDom b x =\n  B::mem b x ==> A::mem (bitToArithDom b) x\n\ncorrect_bitToXorDom : {n} (fin n) => B::Dom n -> [n] -> Bit\ncorrect_bitToXorDom b x =\n  B::mem b x == X::mem (bitToXorDom b) x\n\ncorrect_xorToBitDom : {n} (fin n) => X::Dom n -> [n] -> Bit\ncorrect_xorToBitDom b x =\n  X::mem b x == B::mem (xorToBitDom b) x\n\ncorrect_arithToXorDom : {n} (fin n, n >= 1) => A::Dom n -> [n] -> Bit\ncorrect_arithToXorDom a x =\n  A::mem a x ==> X::mem (arithToXorDom a) x\n\nproperty t1 = correct_arithToBitDom`{16}\nproperty t2 = correct_bitToArithDom`{16}\nproperty t3 = correct_bitToXorDom`{16}\nproperty t4 = correct_xorToBitDom`{16}\nproperty t5 = correct_arithToXorDom`{16}\n\ncorrect_popcnt : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit\ncorrect_popcnt a x =\n  B::mem a x ==> A::mem (popcnt a) (popcount x)\n\ncorrect_clz : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit\ncorrect_clz a x =\n  B::mem a x ==> A::mem (clz a) (countLeadingZeros x)\n\ncorrect_ctz : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit\ncorrect_ctz a x =\n  B::mem a x ==> A::mem (ctz a) (countTrailingZeros x)\n\nproperty w1 = correct_popcnt`{16}\nproperty w2 = correct_clz`{16}\nproperty w3 = correct_ctz`{16}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Proofs that the XOR domain is really just an alternate way\n\/\/ to compute the same thing as the bitsdomain operations.\n\/\/ For \"band\" this requires the input domains to be nonempty,\n\/\/ which should be the case for all actual values of interest.\n\nequiv_bxor : {n} (fin n) => B::Dom n -> B::Dom n -> Bit\nequiv_bxor a b =\n  B::bxor a b == xorToBitDom (X::bxor (bitToXorDom a) (bitToXorDom b))\n\nequiv_band : {n} (fin n) => B::Dom n -> B::Dom n -> Bit\nequiv_band a b =\n  B::nonempty a \/\\ B::nonempty b ==>\n  B::band a b == xorToBitDom (X::band (bitToXorDom a) (bitToXorDom b))\n\nequiv_band_scalar : {n} (fin n) => B::Dom n -> [n] -> Bit\nequiv_band_scalar a x =\n  B::band a (B::singleton x) == xorToBitDom (X::band_scalar (bitToXorDom a) x)\n\nproperty e1 = equiv_bxor`{16}\nproperty e2 = equiv_band`{16}\nproperty e3 = equiv_band_scalar`{16}\n```"}]}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/bitsdomain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named bitsdomain that contains the following: (1) A parametric record type for bitvector domains with width n, having two fields for lower and upper masks. (2) A Boolean membership function that holds when the lower mask is bitwise-below a value and the value is bitwise-below the upper mask, using a helper that defines bitwise \u2264 via an OR-equality characterization. (3) Basic constructors and predicates: nonempty, singleton, a predicate recognizing singletons, and a constant representing the full domain (all values of width n). (4) Domain combinators: overlap (defined via intersection non-emptiness), intersection (tighten bounds), union (loosen bounds). (5) Width-changing operations: zero and sign extension with appropriate finiteness and ordering constraints, concatenation, high-part shrink, and low-part truncation. (6) Bitwise operations on domains: not (swap and complement bounds), and, or, xor (with uncertainty propagation to compute tight low\/high bounds). (7) Shift\/rotate operations on domains: logical\/arithmetic shifts that clamp the shift amount to the width, and rotates that use modular shift amounts. (8) Soundness predicates correct_* (Boolean-returning functions) that state: top contains every value; singleton contains exactly its value; overlap is implied by shared membership and yields a witness; union, intersection, extensions, concat, shrink, trunc, bitwise ops, shifts, and rotates preserve membership as expected; singleton recognition implies equality with the constructed singleton. (9) Property declarations binding names b1\u2013b12, l1\u2013l4, s1\u2013s5 to width-specialized instances of these predicates as in the file. (10) Predicates singleton_* showing each operation preserves singletons, and property declarations i01\u2013i13 that specialize them at the given widths. Specify all type parameters, finiteness constraints, and any width lower bounds (e.g., for sign operations)."},{"role":"assistant","content":"```cryptol\nmodule bitsdomain where\n\ntype Dom n = { lomask : [n] , himask : [n] }\n\nmem : {n} (fin n) => Dom n -> [n] -> Bit\nmem a x = bitle a.lomask x \/\\ bitle x a.himask\n\nbitle : {n} (fin n) => [n] -> [n] -> Bit\nbitle x y = x || y == y\n\nnonempty : {n} (fin n) => Dom n -> Bit\nnonempty b = bitle b.lomask b.himask\n\nsingleton : {n} (fin n) => [n] -> Dom n\nsingleton x = { lomask = x, himask = x }\n\nisSingleton : {n} (fin n) => Dom n -> Bit\nisSingleton a = a.lomask == a.himask\n\ntop : {n} (fin n) => Dom n\ntop = { lomask = 0, himask = ~0 }\n\noverlap : {n} (fin n) => Dom n -> Dom n -> Bit\noverlap a b = nonempty (intersection a b)\n\nintersection : {n} (fin n) => Dom n -> Dom n -> Dom n\nintersection a b = { lomask = a.lomask || b.lomask, himask = a.himask && b.himask }\n\nunion : {n} (fin n) => Dom n -> Dom n -> Dom n\nunion a b = { lomask = a.lomask && b.lomask, himask = a.himask || b.himask }\n\nzero_ext : {m, n} (fin m, m >= n) => Dom n -> Dom m\nzero_ext a = { lomask = zext a.lomask, himask = zext a.himask }\n\nsign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> Dom m\nsign_ext a = { lomask = sext a.lomask, himask = sext a.himask }\n\nconcat : {m, n} (fin m, fin n) => Dom m -> Dom n -> Dom (m + n)\nconcat a b = { lomask = a.lomask # b.lomask, himask = a.himask # b.himask }\n\nshrink : {m, n} (fin m, fin n) => Dom (m + n) -> Dom m\nshrink a = { lomask = take`{m} a.lomask, himask = take`{m} a.himask }\n\ntrunc : {m, n} (fin m, fin n) => Dom (m + n) -> Dom n\ntrunc a = { lomask = drop`{m} a.lomask, himask = drop`{m} a.himask }\n\nbnot : {n} (fin n) => Dom n -> Dom n\nbnot b = { lomask = ~b.himask, himask = ~b.lomask }\n\nband : {n} (fin n) => Dom n -> Dom n -> Dom n\nband a b = { lomask = a.lomask && b.lomask, himask = a.himask && b.himask }\n\nbor : {n} (fin n) => Dom n -> Dom n -> Dom n\nbor a b = { lomask = a.lomask || b.lomask, himask = a.himask || b.himask }\n\nbxor : {n} (fin n) => Dom n -> Dom n -> Dom n\nbxor a b = { lomask = lo, himask = hi }\n  where\n  ua = a.lomask ^ a.himask\n  ub = b.lomask ^ b.himask\n  c  = a.lomask ^ b.lomask\n  u  = ua || ub\n  hi = c || u\n  lo = hi ^ u\n\nshl : {n} (fin n) => Dom n -> [n] -> Dom n\nshl a x = { lomask = a.lomask << x', himask = a.himask << x' }\n  where x' = if x < `n then x else `n\n\nlshr : {n} (fin n) => Dom n -> [n] -> Dom n\nlshr a x = { lomask = a.lomask >> x', himask = a.himask >> x' }\n  where x' = if x < `n then x else `n\n\nashr : {n} (fin n, n >= 1) => Dom n -> [n] -> Dom n\nashr a x = { lomask = a.lomask >>$ x', himask = a.himask >>$ x' }\n  where x' = if x < `n then x else `n\n\nrol : {n} (fin n) => Dom n -> [n] -> Dom n\nrol a x = { lomask = a.lomask <<< x, himask = a.himask <<< x }\n\nror : {n} (fin n) => Dom n -> [n] -> Dom n\nror a x = { lomask = a.lomask >>> x, himask = a.himask >>> x }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Soundness properties\n\ncorrect_top : {n} (fin n) => [n] -> Bit\ncorrect_top x = mem top x\n\ncorrect_singleton : {n} (fin n) => [n] -> [n] -> Bit\ncorrect_singleton x y = mem (singleton x) y == (x == y)\n\ncorrect_overlap : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_overlap a b x =\n  mem a x ==> mem b x ==> overlap a b\n\ncorrect_overlap_inv : {n} (fin n) => Dom n -> Dom n -> Bit\ncorrect_overlap_inv a b =\n  overlap a b ==> (mem a (a.lomask || b.lomask) \/\\ mem b (a.lomask || b.lomask))\n\ncorrect_union : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_union a b x =\n  (mem a x \\\/ mem b x) ==> mem (union a b) x\n\ncorrect_intersection : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_intersection a b x =\n  (mem a x \/\\ mem b x) == mem (intersection a b) x\n\ncorrect_zero_ext : {m, n} (fin m, m >= n) => Dom n -> [n] -> Bit\ncorrect_zero_ext a x =\n  mem a x ==> mem (zero_ext`{m} a) (zext`{m} x)\n\ncorrect_sign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> [n] -> Bit\ncorrect_sign_ext a x =\n  mem a x ==> mem (sign_ext`{m} a) (sext`{m} x)\n\ncorrect_concat : {m, n} (fin m, fin n) => Dom m -> Dom n -> [m] -> [n] -> Bit\ncorrect_concat a b x y =\n  mem a x ==> mem b y ==> mem (concat a b) (x # y)\n\ncorrect_shrink : {m, n} (fin m, fin n) => Dom (m + n) -> [m+n] -> Bit\ncorrect_shrink a x =\n  mem a x ==> mem (shrink`{m} a) (take`{m} x)\n\ncorrect_trunc : {m, n} (fin m, fin n) => Dom (m + n) -> [m+n] -> Bit\ncorrect_trunc a x =\n  mem a x ==> mem (trunc`{m} a) (drop`{m} x)\n\ncorrect_isSingleton : {n} (fin n) => Dom n -> Bit\ncorrect_isSingleton a =\n  isSingleton a ==> a == singleton a.lomask\n\ncorrect_bnot : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_bnot a x =\n  mem a x == mem (bnot a) (~ x)\n\ncorrect_band : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_band a b x y =\n  mem a x ==> mem b y ==> mem (band a b) (x && y)\n\ncorrect_bor : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_bor a b x y =\n  mem a x ==> mem b y ==> mem (bor a b) (x || y)\n\ncorrect_bxor : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_bxor a b x y =\n  mem a x ==> mem b y ==> mem (bxor a b) (x ^ y)\n\ncorrect_shl : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_shl a x y =\n  mem a x ==> mem (shl a y) (x << y)\n\ncorrect_lshr : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_lshr a x y =\n  mem a x ==> mem (lshr a y) (x >> y)\n\ncorrect_ashr : {n} (fin n, n >= 1) => Dom n -> [n] -> [n] -> Bit\ncorrect_ashr a x y =\n  mem a x ==> mem (ashr a y) (x >>$ y)\n\ncorrect_rol : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_rol a x y =\n  mem a x ==> mem (rol a y) (x <<< y)\n\ncorrect_ror : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_ror a x y =\n  mem a x ==> mem (ror a y) (x >>> y)\n\nproperty b1 = correct_top`{16}\nproperty b2 = correct_singleton`{16}\nproperty b3 = correct_overlap`{16}\nproperty b4 = correct_overlap_inv`{16}\nproperty b5 = correct_union`{8}\nproperty b6 = correct_intersection`{8}\nproperty b7 = correct_zero_ext`{32, 16}\nproperty b8 = correct_sign_ext`{32, 16}\nproperty b9 = correct_concat`{16, 16}\nproperty b10 = correct_shrink`{8, 8}\nproperty b11 = correct_trunc`{8, 8}\nproperty b12 = correct_isSingleton`{16}\n\nproperty l1 = correct_bnot`{16}\nproperty l2 = correct_band`{16}\nproperty l3 = correct_bor`{16}\nproperty l4 = correct_bxor`{16}\n\nproperty s1 = correct_shl`{16}\nproperty s2 = correct_lshr`{16}\nproperty s3 = correct_ashr`{16}\nproperty s4 = correct_rol`{16}\nproperty s5 = correct_ror`{16}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Operations preserve singletons\n\nsingleton_overlap : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_overlap x y =\n  overlap (singleton x) (singleton y) == (x == y)\n\nsingleton_zero_ext : {m, n} (fin m, m >= n) => [n] -> Bit\nsingleton_zero_ext x =\n  zero_ext`{m} (singleton x) == singleton (zext`{m} x)\n\nsingleton_sign_ext : {m, n} (fin m, m >= n, n >= 1) => [n] -> Bit\nsingleton_sign_ext x =\n  sign_ext`{m} (singleton x) == singleton (sext`{m} x)\n\nsingleton_concat : {m, n} (fin m, fin n) => [m] -> [n] -> Bit\nsingleton_concat x y =\n  concat (singleton x) (singleton y) == singleton (x # y)\n\nsingleton_shrink : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_shrink x =\n  shrink`{m} (singleton x) == singleton (take`{m} x)\n\nsingleton_trunc : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_trunc x =\n  trunc`{m} (singleton x) == singleton (drop`{m} x)\n\nsingleton_bnot : {n} (fin n) => [n] -> Bit\nsingleton_bnot x =\n  bnot (singleton x) == singleton (~ x)\n\nsingleton_band : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_band x y =\n  band (singleton x) (singleton y) == singleton (x && y)\n\nsingleton_bor : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_bor x y =\n  bor (singleton x) (singleton y) == singleton (x || y)\n\nsingleton_bxor : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_bxor x y =\n  bxor (singleton x) (singleton y) == singleton (x ^ y)\n\nsingleton_shl : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_shl x y =\n  shl (singleton x) y == singleton (x << y)\n\nsingleton_lshr : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_lshr x y =\n  lshr (singleton x) y == singleton (x >> y)\n\nsingleton_ashr : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ashr x y =\n  ashr (singleton x) y == singleton (x >>$ y)\n\nproperty i01 = singleton_overlap`{16}\nproperty i02 = singleton_zero_ext`{32, 16}\nproperty i03 = singleton_sign_ext`{32, 16}\nproperty i04 = singleton_concat`{16, 16}\nproperty i05 = singleton_shrink`{8, 8}\nproperty i06 = singleton_trunc`{8, 8}\nproperty i07 = singleton_band`{16}\nproperty i08 = singleton_bor`{16}\nproperty i09 = singleton_bxor`{16}\nproperty i10 = singleton_bnot`{16}\nproperty i11 = singleton_shl`{8}\nproperty i12 = singleton_lshr`{8}\nproperty i13 = singleton_ashr`{8}\n```"}]}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/arithdomain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named arithdomain that contains the following definitions and proof obligations.\n- Size-parameterized constants for a single high bit and a full-width mask.\n- Checked infix addition and subtraction on fixed-width words that signal overflow\/underflow; signed min and max under a signed-comparison constraint.\n- A size-parameterized record type for half-open unsigned intervals with low endpoint and size fields, plus constructors and conversions between endpoints and size.\n- Unsigned and signed membership predicates over intervals and endpoint pairs; a top interval, singleton intervals, and a predicate testing singletons.\n- Unsigned, signed, and reciprocal bounds for an interval; overlap and a union operation that merges possibly wrapping intervals using widened arithmetic, plus an equivalence-up-to-top operator and logical equivalence operator.\n- Width-changing operations: zero\/sign extension, concatenation, high\/low-part projections, and truncation; arithmetic: addition, negation, bitwise not, and multiplication via interval products using widened bounds; helpers to compute widened bounds and signed\/unsigned interval products and scaling by a signed factor.\n- Unsigned and signed division and remainder interval transformers with nonzero-divisor assumptions; a signed-division-by-reciprocal range helper; left, logical-right, and arithmetic-right shifts; unsigned and signed ordering predicates; a lemma characterizing preservation of unsigned order under adding a common addend when wrapping is accounted for.\n- A function producing the set of unknown bits in an interval and two equivalent implementations of \u201cfill to the right,\u201d plus a property asserting their equivalence for a fixed width.\n- Correctness properties stating membership preservation\/reflection for each transformer and predicate, including specific instantiations at concrete sizes; singleton-compatibility properties showing each transformer\/predicate agrees with the underlying word operator on degenerate intervals; algebraic properties (commutativity\/associativity) for addition, multiplication, and interval products; and union laws (commutativity, associativity, endpoint origin, and nontriviality), each with concrete instantiations.\nProvide complete type signatures with size and finiteness constraints and express all proof goals as Cryptol properties."},{"role":"assistant","content":"```cryptol\nmodule arithdomain where\n\nbit : {i, n} (fin n, n > i) => [n]\nbit = 1 # (0 : [i])\n\nmask : {i, n} (fin n, n >= i) => [n]\nmask = 0 # (~ 0 : [i])\n\ninfixl 80 .+.\n(.+.) : {n} (fin n) => [n] -> [n] -> [n]\nx .+. y = if carry x y then error \"overflow\" else x + y\n\ninfixl 80 .-.\n(.-.) : {n} (fin n) => [n] -> [n] -> [n]\nx .-. y = if x < y then error \"underflow\" else x - y\n\nsmin : {a} (SignedCmp a) => a -> a -> a\nsmin x y = if x <$ y then x else y\n\nsmax : {a} (SignedCmp a) => a -> a -> a\nsmax x y = if x >$ y then x else y\n\ntype Dom n = { lo : [n], sz : [n] }\n\ninterval : {n} (fin n) => [n] -> [n] -> Dom n\ninterval l s = { lo = l, sz = s }\n\nrange : {n} (fin n) => [n] -> [n] -> Dom n\nrange lo hi = interval lo (hi - lo)\n\nmem : {n} (fin n) => Dom n -> [n] -> Bit\nmem a x = x - a.lo <= a.sz\n\numem : {n} (fin n) => ([n], [n]) -> [n] -> Bit\numem (lo, hi) x = lo <= x \/\\ x <= hi\n\nsmem : {n} (fin n, n >= 1) => ([n], [n]) -> [n] -> Bit\nsmem (lo, hi) x = lo <=$ x \/\\ x <=$ hi\n\ntop : {n} (fin n) => Dom n\ntop = interval 0 (~ 0)\n\nsingleton : {n} (fin n) => [n] -> Dom n\nsingleton x = interval x 0\n\nisSingleton : {n} (fin n) => Dom n -> Bit\nisSingleton a = a.sz == 0\n\nubounds : {n} (fin n) => Dom n -> ([n], [n])\nubounds a =\n  if carry a.lo a.sz then (0, ~0) else (a.lo, a.lo + a.sz)\n\nsbounds : {n} (fin n, n >= 1) => Dom n -> ([n], [n])\nsbounds a = (lo - delta, hi - delta)\n  where\n    delta = reverse 1\n    (lo, hi) = ubounds (interval (a.lo + delta) a.sz)\n\nrbounds : {n} (fin n, n >= 1) => Dom n -> ([n], [n])\nrbounds a =\n  if a.lo == 0 then (a_hi, 1) else\n  if a_hi == 0 then (-1, a.lo) else\n  if a_hi < a.lo then (-1, 1) else\n  (a_hi, a.lo)\n  where a_hi = a.lo + a.sz\n\noverlap : {n} (fin n) => Dom n -> Dom n -> Bit\noverlap a b = diff <= b.sz \\\/ carry diff a.sz\n  where diff = a.lo - b.lo\n\nunion : {n} (fin n) => Dom n -> Dom n -> Dom n\nunion a b =\n  if cw >= size then top else interval (drop`{2} cl) (drop`{2} cw)\n  where\n    size : [n+2]\n    size = bit`{n}\n    am = 2 * zext a.lo .+. zext a.sz\n    bm = 2 * zext b.lo .+. zext b.sz\n    al' = if am .+. size < bm then zext a.lo .+. size else zext a.lo\n    bl' = if bm .+. size < am then zext b.lo .+. size else zext b.lo\n    ah' = al' .+. zext a.sz\n    bh' = bl' .+. zext b.sz\n    cl = min al' bl'\n    ch = max ah' bh'\n    cw = ch .-. cl\n\nzero_ext : {m, n} (fin m, m >= n) => Dom n -> Dom m\nzero_ext a = interval (zext lo) (zext (hi .-. lo))\n  where (lo, hi) = ubounds a\n\nsign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> Dom m\nsign_ext a = interval (sext lo) (zext (hi - lo))\n  where (lo, hi) = sbounds a\n\nconcat : {m, n} (fin m, fin n) => Dom m -> Dom n -> Dom (m + n)\nconcat a b = interval (a.lo # lo) (a.sz # sz)\n  where\n    (lo, hi) = ubounds b\n    sz = hi .-. lo\n\nshrink : {m, n} (fin m, fin n) => Dom (m + n) -> Dom m\nshrink a =\n  if b_sz >= size then top\n  else interval (tail b_lo) (tail b_sz)\n  where\n    size : [1 + m]\n    size = bit`{m}\n    b_lo, b_hi, b_sz : [1 + m]\n    b_lo = take`{back=n} (zext a.lo)\n    b_hi = take`{back=n} (zext a.lo .+. zext a.sz)\n    b_sz = b_hi .-. b_lo\n\ntrunc : {m, n} (fin m, fin n) => Dom (m + n) -> Dom n\ntrunc a =\n  if a.sz > mask`{n} then top\n  else interval (drop`{m} a.lo) (drop`{m} a.sz)\n\nadd : {n} (fin n) => Dom n -> Dom n -> Dom n\nadd a b =\n  if carry a.sz b.sz then top\n  else interval (a.lo + b.lo) (a.sz .+. b.sz)\n\nneg : {n} (fin n) => Dom n -> Dom n\nneg a = interval (- (a.lo + a.sz)) a.sz\n\nbnot : {n} (fin n) => Dom n -> Dom n\nbnot a = interval (~ ah) a.sz\n  where ah = a.lo + a.sz\n\nmul : {n} (fin n) => Dom n -> Dom n -> Dom n\nmul a b =\n  if sz >= bit`{n} then top\n  else interval (drop lo) (drop sz)\n  where\n    (lo, hi) = mulRange (zbounds a) (zbounds b)\n    sz = hi - lo\n\nzbounds : {n} (fin n) => Dom n -> ([1 + n], [1 + n])\nzbounds a = (lo', lo' + zext a.sz)\n  where\n    size : [2 + n]\n    size = bit`{n}\n    lo' = if 2 * zext a.lo .+. zext a.sz >= size then 0b1 # a.lo else 0b0 # a.lo\n\nmulRange : {m, n} (fin m, fin n, m >= 1, n >= 1) => ([m], [m]) -> ([n], [n]) -> ([m+n], [m+n])\nmulRange (xl, xh) (yl, yh) = (zl, zh)\n  where\n    (xlyl, xlyh) = scaleRange xl (yl, yh)\n    (xhyl, xhyh) = scaleRange xh (yl, yh)\n    zl = smin xlyl xhyl\n    zh = smax xlyh xhyh\n\nscaleRange : {m, n} (fin m, fin n, m >= 1, n >= 1) => [m] -> ([n], [n]) -> ([m+n], [m+n])\nscaleRange k (lo, hi) = if k <$ 0 then (hi', lo') else (lo', hi')\n  where\n    lo' = sext k * sext lo\n    hi' = sext k * sext hi\n\nudiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nudiv a b = range cl ch\n  where\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    bl' = max 1 bl     bh' = max 1 bh \/\/ assume that division by 0 does not happen\n    cl = al \/ bh'\n    ch = ah \/ bl'\n\nurem : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nurem a b =\n  if ql == qh then range rl rh\n  else interval 0 (bh - 1)\n  where\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    bl' = max 1 bl     bh' = max 1 bh\n    (ql, rl) = (al \/ bh', al % bh')\n    (qh, rh) = (ah \/ bl', ah % bl')\n\n\/\/ The first argument is an ordinary signed interval, but the second\n\/\/ argument is a reciaprocal interval: The arguments should satisfy 'al\nsdivRange : {n} (fin n, n >= 1) => ([n], [n]) -> ([n], [n]) -> ([1+n], [1+n])\nsdivRange (al, ah) (bl, bh) = (ql, qh)\n  where\n    (ql1, qh1) = shrinkRange (al, ah) bh\n    (ql2, qh2) = shrinkRange (al, ah) bl\n    ql = smin ql1 ql2\n    qh = smax qh1 qh2\n\nshrinkRange : {n} (fin n, n >= 1) => ([n], [n]) -> [n] -> ([1+n], [1+n])\nshrinkRange (lo, hi) k =\n  if k >$ 0 then (lo .\/. k, hi .\/. k) else\n  if k <$ 0 then (hi .\/. k, lo .\/. k) else (sext lo, sext hi)\n  where\n    x .\/. y = sext x \/$ sext y\n\nsdiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nsdiv a b =\n  if sz >= bit`{n} then top\n  else interval (drop lo) (drop sz)\n  where\n    (lo, hi) = sdivRange (sbounds a) (rbounds b)\n    sz = hi - lo\n\nsrem : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nsrem a b =\n  if ql == qh then\n    (if ql <$ 0\n     then range (al - drop ql * bl) (ah - drop ql * bh)\n     else range (al - drop ql * bh) (ah - drop ql * bl))\n  else range rl rh\n  where\n    (al, ah) = sbounds a\n    (bl, bh) = sbounds b\n    (ql, qh) = sdivRange (al, ah) (rbounds b)\n    rl = if al <$ 0 then smin (bl+1) (-bh+1) else 0\n    rh = if ah >$ 0 then smax (-bl-1) (bh-1) else 0\n\nshl : {n} (fin n) => Dom n -> Dom n -> Dom n\nshl a b =\n  if sz > mask`{n} then top\n  else interval (drop lo) (drop sz)\n  where\n    al, ah : [n + 1]\n    (al, ah) = zbounds a\n    bl, bh : [n]\n    (bl, bh) = ubounds b\n        cl, ch : [n + 2]\n    cl = if bl < `n then 1 << bl else bit`{n}\n    ch = if bh < `n then 1 << bh else bit`{n}\n    (lo, hi) = mulRange (al, ah) (cl, ch)\n    sz = hi - lo\n\nlshr : {n} (fin n) => Dom n -> Dom n -> Dom n\nlshr a b = interval cl (ch - cl)\n  where\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    cl = al >> bh\n    ch = ah >> bl\n\nashr : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nashr a b = interval cl (ch - cl)\n  where\n    (al, ah) = sbounds a\n    (bl, bh) = ubounds b\n    cl = al >>$ (if al <$ 0 then bl else bh)\n    ch = ah >>$ (if ah <$ 0 then bh else bl)\n\nult : {n} (fin n) => Dom n -> Dom n -> Bit\nult a b = (ubounds a).1 < (ubounds b).0\n\nule : {n} (fin n) => Dom n -> Dom n -> Bit\nule a b = (ubounds a).1 <= (ubounds b).0\n\nslt : {n} (fin n, n >= 1) => Dom n -> Dom n -> Bit\nslt a b = (sbounds a).1 <$ (sbounds b).0\n\nsle : {n} (fin n, n >= 1) => Dom n -> Dom n -> Bit\nsle a b = (sbounds a).1 <=$ (sbounds b).0\n\nult_sum_common_equiv : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nult_sum_common_equiv a b c =\n  if al == ah \/\\ bl == bh \/\\ al == bl\n    then True\n    else if ~(carry cl c.sz)\n      then check_same_wrap_interval cl ch\n      else check_same_wrap_interval cl mask`{n} \/\\ check_same_wrap_interval 0 ch\n  where\n    (cl, ch) = (c.lo, c.lo + c.sz)\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    check_same_wrap_interval lo hi =\n      ~(carry ah hi) \/\\ ~(carry bh hi) \\\/ carry al lo \/\\ carry bl lo\n\nunknowns : {n} (fin n, n >= 1) => Dom n -> [n]\nunknowns a = if carry a.lo a.sz then ~0 else bits\n where\n bits = fillright diff\n diff = a.lo ^ (a.lo + a.sz)\n\nfillright : {n} (fin n, n >= 1) => [n] -> [n]\nfillright x = tail (scanl (||) False x)\n\nfillright_alt : {n} (fin n, n >= 1) => [n] -> [n]\nfillright_alt x = x || ((1 << lg2 x) - 1)\n\nproperty fillright_equiv x = fillright`{16} x == fillright_alt x\n\ninfix 20 =@=\n\n(=@=) : {n} (fin n) => Dom n -> Dom n -> Bit\na =@= b = (a.sz == ~0 \/\\ b.sz == ~0) \\\/ (a == b)\n\ninfix 5 <==>\n\n(<==>) : Bit -> Bit -> Bit\n(<==>) = (==)\n\ncorrect_top : {n} (fin n) => [n] -> Bit\ncorrect_top x = mem top x\n\ncorrect_ubounds : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_ubounds a x =\n  mem a x ==> umem (ubounds a) x\n\ncorrect_sbounds : {n} (fin n, n >= 1) => Dom n -> [n] -> Bit\ncorrect_sbounds a x =\n  mem a x ==> smem (sbounds a) x\n\ncorrect_singleton : {n} (fin n) => [n] -> [n] -> Bit\ncorrect_singleton x y =\n  mem (singleton x) y <==> x == y\n\ncorrect_overlap : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_overlap a b x =\n  mem a x ==> mem b x ==> overlap a b\n\ncorrect_overlap_inv : {n} (fin n) => Dom n -> Dom n -> Bit\ncorrect_overlap_inv a b =\n  overlap a b ==> (mem a witness \/\\ mem b witness)\n\n where\n witness = if mem a b.lo then b.lo else a.lo\n\ncorrect_union : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_union a b x =\n  (mem a x \\\/ mem b x) ==> mem (union a b) x\n\ncorrect_zero_ext : {m, n} (fin m, m >= n) => Dom n -> [n] -> Bit\ncorrect_zero_ext a x =\n  mem a x ==> mem (zero_ext`{m} a) (zext`{m} x)\n\ncorrect_sign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> [n] -> Bit\ncorrect_sign_ext a x =\n  mem a x ==> mem (sign_ext`{m} a) (sext`{m} x)\n\ncorrect_concat : {m, n} (fin m, fin n) => Dom m -> Dom n -> [m] -> [n] -> Bit\ncorrect_concat a b x y =\n  mem a x ==> mem b y ==> mem (concat a b) (x # y)\n\ncorrect_shrink : {m, n} (fin m, fin n) => Dom (m + n) -> [m + n] -> Bit\ncorrect_shrink a x =\n  mem a x ==> mem (shrink`{m} a) (take`{m} x)\n\ncorrect_trunc : {m, n} (fin m, fin n) => Dom (m + n) -> [m + n] -> Bit\ncorrect_trunc a x =\n  mem a x ==> mem (trunc`{m} a) (drop`{m} x)\n\ncorrect_add : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_add a b x y =\n  mem a x ==> mem b y ==> mem (add a b) (x + y)\n\ncorrect_neg : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_neg a x =\n  mem a x <==> mem (neg a) (- x)\n\ncorrect_mul : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_mul a b x y =\n  mem a x ==> mem b y ==> mem (mul a b) (x * y)\n\ncorrect_mulRange : {n} (fin n, n >= 1) => ([n], [n]) -> ([n], [n]) -> [n] -> [n] -> Bit\ncorrect_mulRange a b x y =\n  smem a x ==> smem b y ==> smem (mulRange a b) (sext x * sext y)\n\ncorrect_udiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_udiv a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (udiv a b) (x \/ y)\n\ncorrect_urem : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_urem a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (urem a b) (x % y)\n\ncorrect_sdivRange : {n} (fin n, n >= 1) => ([n], [n]) -> ([n], [n]) -> [n] -> [n] -> Bit\ncorrect_sdivRange a b x y =\n  smem a x ==> umem b y ==> y != 0 ==> smem (sdivRange a (b.1, b.0)) (sext x \/$ sext y)\n\ncorrect_shrinkRange : {n} (fin n, n >= 1) => ([n], [n]) -> [n] -> [n] -> Bit\ncorrect_shrinkRange a x y =\n  smem a x ==> y != 0 ==> smem (shrinkRange a y) (sext x \/$ sext y)\n\ncorrect_sdiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_sdiv a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (sdiv a b) (x \/$ y)\n\ncorrect_srem : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_srem a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (srem a b) (x %$ y)\n\ncorrect_shl : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_shl a b x y =\n  mem a x ==> mem b y ==> mem (shl a b) (x << y)\n\ncorrect_lshr : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_lshr a b x y =\n  mem a x ==> mem b y ==> mem (lshr a b) (x >> y)\n\ncorrect_ashr : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_ashr a b x y =\n  mem a x ==> mem b y ==> mem (ashr a b) (x >>$ y)\n\ncorrect_slt : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_slt a b x y =\n  slt a b ==> mem a x ==> mem b y ==> x <$ y\n\ncorrect_sle : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_sle a b x y =\n  sle a b ==> mem a x ==> mem b y ==> x <=$ y\n\ncorrect_ult : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_ult a b x y =\n  ult a b ==> mem a x ==> mem b y ==> x < y\n\ncorrect_ule : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_ule a b x y =\n  ule a b ==> mem a x ==> mem b y ==> x <= y\n\ncorrect_ult_sum_common_equiv :\n  {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n -> [n] -> [n] -> [n] -> Bit\ncorrect_ult_sum_common_equiv a b c x y z =\n  ult_sum_common_equiv a b c ==>\n  mem a x ==> mem b y ==> mem c z ==>\n  (x + z < y + z <==> x < y)\n\ncorrect_bnot : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_bnot a x =\n  mem a x <==> mem (bnot a) (~ x)\n\ncorrect_isSingleton : {n} (fin n) => Dom n -> Bit\ncorrect_isSingleton a =\n  isSingleton a ==> a == singleton a.lo\n\ncorrect_unknowns : {n} (fin n, n >= 1) => Dom n -> [n] -> [n] -> Bit\ncorrect_unknowns a x y =\n  mem a x ==> mem a y ==> (x || unknowns a) == (y || unknowns a)\n\nproperty p1 = correct_top`{16}\nproperty p2 = correct_ubounds`{16}\nproperty p3 = correct_sbounds`{16}\nproperty p4 = correct_singleton`{16}\nproperty p5 = correct_overlap`{16}\nproperty p5_inv = correct_overlap_inv`{16}\nproperty p6 = correct_union`{8}\nproperty p7 = correct_zero_ext`{32, 16}\nproperty p8 = correct_sign_ext`{32, 16}\nproperty p9 = correct_concat`{16, 16}\nproperty p10 = correct_shrink`{8, 8}\nproperty p11 = correct_trunc`{8, 8}\nproperty p12 = correct_unknowns`{16}\nproperty p13 = correct_isSingleton`{16}\n\nproperty a1 = correct_add`{8}\nproperty a2 = correct_neg`{16}\nproperty a3 = correct_mul`{4}\nproperty a4 = correct_udiv`{8}\nproperty a5 = correct_urem`{6}\nproperty a6 = correct_sdiv`{6}\nproperty a7 = correct_srem`{6}\nproperty a8 = correct_bnot`{16}\nproperty a9 = correct_sdivRange`{6}\n\nproperty s1 = correct_shl`{8}\nproperty s2 = correct_lshr`{8}\nproperty s3 = correct_ashr`{8}\n\nproperty o1 = correct_slt`{16}\nproperty o2 = correct_sle`{16}\nproperty o3 = correct_ult`{16}\nproperty o4 = correct_ule`{16}\nproperty o5 = correct_ult_sum_common_equiv`{4}\n\nsingleton_overlap : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_overlap x y =\n  overlap (singleton x) (singleton y) == (x == y)\n\nsingleton_zero_ext : {m, n} (fin m, m >= n) => [n] -> Bit\nsingleton_zero_ext x =\n  zero_ext`{m} (singleton x) == singleton (zext`{m} x)\n\nsingleton_sign_ext : {m, n} (fin m, m >= n, n >= 1) => [n] -> Bit\nsingleton_sign_ext x =\n  sign_ext`{m} (singleton x) == singleton (sext`{m} x)\n\nsingleton_concat : {m, n} (fin m, fin n) => [m] -> [n] -> Bit\nsingleton_concat x y =\n  concat (singleton x) (singleton y) == singleton (x # y)\n\nsingleton_shrink : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_shrink x =\n  shrink`{m} (singleton x) == singleton (take`{m} x)\n\nsingleton_trunc : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_trunc x =\n  trunc`{m} (singleton x) == singleton (drop`{m} x)\n\nsingleton_add : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_add x y =\n  add (singleton x) (singleton y) == singleton (x + y)\n\nsingleton_neg : {n} (fin n) => [n] -> Bit\nsingleton_neg x =\n  neg (singleton x) == singleton (- x)\n\nsingleton_mul : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_mul x y =\n  mul (singleton x) (singleton y) == singleton (x * y)\n\nsingleton_mulRange : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_mulRange x y =\n  mulRange (x, x) (y, y) == (sext x * sext y, sext x * sext y)\n\nsingleton_udiv : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_udiv x y =\n  y != 0 ==> udiv (singleton x) (singleton y) == singleton (x \/ y)\n\nsingleton_urem : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_urem x y =\n  y != 0 ==> urem (singleton x) (singleton y) == singleton (x % y)\n\nsingleton_sdiv : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_sdiv x y =\n  y != 0 ==> sdiv (singleton x) (singleton y) == singleton (x \/$ y)\n\nsingleton_srem : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_srem x y =\n  y != 0 ==> srem (singleton x) (singleton y) == singleton (x %$ y)\n\nsingleton_shl : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_shl x y =\n  shl (singleton x) (singleton y) == singleton (x << y)\n\nsingleton_lshr : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_lshr x y =\n  lshr (singleton x) (singleton y) == singleton (x >> y)\n\nsingleton_ashr : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ashr x y =\n  ashr (singleton x) (singleton y) == singleton (x >>$ y)\n\nsingleton_slt : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_slt x y =\n  slt (singleton x) (singleton y) == (x <$ y)\n\nsingleton_sle : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_sle x y =\n  sle (singleton x) (singleton y) == (x <=$ y)\n\nsingleton_ult : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ult x y =\n  ult (singleton x) (singleton y) == (x < y)\n\nsingleton_ule : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ule x y =\n  ule (singleton x) (singleton y) == (x <= y)\n\nproperty i01 = singleton_overlap`{16}\nproperty i02 = singleton_zero_ext`{32, 16}\nproperty i03 = singleton_sign_ext`{32, 16}\nproperty i04 = singleton_concat`{16, 16}\nproperty i05 = singleton_shrink`{8, 8}\nproperty i06 = singleton_trunc`{8, 8}\nproperty i07 = singleton_add`{8}\nproperty i08 = singleton_neg`{16}\nproperty i09 = singleton_mul`{4}\nproperty i10 = singleton_udiv`{8}\nproperty i11 = singleton_urem`{8}\nproperty i12 = singleton_sdiv`{8}\nproperty i13 = singleton_srem`{8}\nproperty i14 = singleton_shl`{8}\nproperty i15 = singleton_lshr`{8}\nproperty i16 = singleton_ashr`{8}\nproperty i17 = singleton_slt`{16}\nproperty i18 = singleton_sle`{16}\nproperty i19 = singleton_ult`{16}\nproperty i20 = singleton_ule`{16}\n\ncomm_overlap : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_overlap a b = overlap a b <==> overlap b a\n\ncomm_add : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_add a b = add a b == add b a\n\nassoc_add : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nassoc_add a b c = add a (add b c) =@= add (add a b) c\n\ncomm_mul : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_mul a b = mul a b == mul b a\n\nassoc_mul : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nassoc_mul a b c = mul a (mul b c) =@= mul (mul a b) c\n\ncomm_mulRange :\n  {i, j} (fin i, fin j, i >= 1, j >= 1) => ([i], [i]) -> ([j], [j]) -> Bit\ncomm_mulRange a b =\n  a.0 <=$ a.1 ==> b.0 <=$ b.1 ==> mulRange a b == mulRange b a\n\nassoc_mulRange :\n  {i, j, k} (fin i, fin j, fin k, i >= 1, j >= 1, k >= 1) =>\n  ([i], [i]) -> ([j], [j]) -> ([k], [k]) -> Bit\nassoc_mulRange a b c =\n  a.0 <=$ a.1 ==>\n  b.0 <=$ b.1 ==>\n  c.0 <=$ c.1 ==>\n  mulRange a (mulRange b c) == mulRange (mulRange a b) c\n\nproperty c1 = comm_overlap`{16}\nproperty c2 = comm_add`{16}\nproperty c3 = assoc_add`{16}\nproperty c4 = comm_mul`{4}\nproperty c5 = comm_mulRange`{4,4}\nproperty c6 = assoc_mulRange`{3,3,3}\n\ncomm_union : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_union a b = union a b == union b a\n\nassoc_union : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nassoc_union a b c = union a (union b c) == union (union a b) c\n\nlo_union : {n} (fin n) => Dom n -> Dom n -> Bit\nlo_union a b =\n  union a b == top \\\/ (union a b).lo == a.lo \\\/ (union a b).lo == b.lo\n\nhi_union : {n} (fin n) => Dom n -> Dom n -> Bit\nhi_union a b = c == top \\\/ c_hi == a_hi \\\/ c_hi == b_hi\n  where\n    c = union a b\n    a_hi = a.lo + a.sz\n    b_hi = b.lo + b.sz\n    c_hi = c.lo + c.sz\n\nnontriv_union : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\nnontriv_union a b x =\n  union a b =@= top ==> mem a x \\\/ mem b x\n\nnonzero_union : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nnonzero_union lo sz =\n  mem (union a b) half \/\\\n  (~ mem a 0 ==> ~ mem b 0 ==> ~ mem (union a b) 0)\n  where\n    half : [n]\n    half = reverse 1\n    a = interval lo sz\n    b = interval (lo + half) sz\n\nproperty u1 = comm_union`{16}\nproperty u2 = lo_union`{16}\nproperty u3 = hi_union`{16}\nproperty u4 = nontriv_union`{8}\nproperty u5 = nonzero_union`{16}\n```"}]}
{"filename":"saw-script\/deps\/cryptol\/tests\/enum\/BasicEnums.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) an enum E1 with three nullary variants; (2) a parametric enum M a with a nullary variant named N and a unary variant carrying a value of type a; (3) a parametric enum N n a with three variants: one carrying a sequence of n bits, one carrying a sequence of n\u22122 bits (only valid when n \u2265 2), and one carrying a value of type a. Define function c1 that consumes E1 and returns an 8-bit result, producing 1, 2, or 3 (as 8-bit values) for the first, second, and third variants respectively. Define function c2 with a size parameter n and the constraint n \u2265 2, taking a value of type N n [n] and returning a sequence of n bits; its behavior is: return the n-bit payload for the first variant, return the (n\u22122)-bit payload left-padded with two zero bits to length n for the second variant, and return the n-bit payload for the third variant. Define c3 to behave exactly like c1. Define constant e1 as the nullary constructor N of type M a (for any a). Define constant e2 as the second variant of N n a applied to the 2-bit value 3, resulting in a value of type N 4 a (for any a). Make all types, size parameters, and constraints explicit."},{"role":"assistant","content":"```cryptol\nenum E1  = A | B | C\nenum M a = N | J a\nenum N n a =\n  |  X [n]\n  | Y [n-2]\n  | Z a\n\nc1 e =\n  case e of\n    A -> 1 : [8]\n    B -> 2\n    C -> 3\n\nc2 : {n} (n>=2) => N n [n] -> [n]\nc2 e =\n  case e of\n    X a -> a\n    Y b -> zero`{[2]} # b\n    Z a -> a\n\nc3 e = case e of A -> 1 : [8]; B -> 2; C -> 3\n\ne1 = N\ne2 = Y 3\n```"}]}
{"filename":"saw-script\/deps\/cryptol\/tests\/issues\/issue_1867.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Param that contains the following definitions: (1) a parameter section declaring a numeric type parameter n and a value parameter myparam that is a sequence of n bits; (2) a polymorphic function foo with an implicit size parameter m that takes a sequence of m elements, each an n-bit sequence, and returns a sequence of m elements where each element is the bitwise AND of myparam with the corresponding input element; implement foo by mapping the binary AND with myparam over the m elements; (3) a definition bar that performs the same mapping as foo but without an explicit type signature so its type is inferred. Ensure the types enforce that m and n are natural numbers and the inner sequence length equals n."},{"role":"assistant","content":"```cryptol\nmodule Param where\n\nparameter\n  type n : #\n  myparam : [n]\n\nfoo : {m} [m][n] -> [m][n]\nfoo = map ((&&) myparam)\n\nbar = map ((&&) myparam)\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/NQueens.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define an N-Queens validator with these names, types, and behaviors:\n- Type synonyms: Position n as a bitvector wide enough to index 0..n-1; Board n as a length-n vector of Position n; Solution n as Board n -> Bit.\n- Function all: for any finite n and any element type, takes a predicate (element -> Bit) and a length-n vector, and returns True iff the predicate holds for every element of the vector.\n- Function contains: given a vector and an element of the same type, returns True iff the vector contains an element equal to the target.\n- Function distinct: for any finite n and comparable element type, takes a length-n vector and returns True iff all elements are pairwise unequal, considering only index pairs where the first index is less than the second.\n- Function checkDiag: for any finite n with n >= 1, given a board and a pair of indices (i, j), returns True if i >= j, otherwise returns True iff the absolute difference of the entries at those indices is not equal to the difference (j - i).\n- Function ijs: for any finite n with n >= 1, produce the vector of all ordered index pairs (i, j) with i and j ranging from 0 to n-1.\n- Function inRange: for any finite n with n >= 1, given a board (to fix n) and a position value, returns True iff the position is within 0..n-1.\n- Function nQueens: for any finite n with n >= 1, given a board, returns True iff every position is in range, all positions are pairwise distinct, and for all index pairs from ijs the diagonal condition checkDiag holds.\n- Define a property nQueensProve that, for all boards x, states that nQueens x equals False.\nProvide precise type signatures expressing the stated constraints."},{"role":"assistant","content":"```cryptol\nall : {n, a} (fin n) => (a -> Bit, [n]a) -> Bit\nall (f, xs) = [ f x | x <- xs ] == ~zero\n\ncontains xs e = [ x == e | x <- xs ] != zero\n\ndistinct : {n,a} (fin n, Cmp a) => [n]a -> Bit\ndistinct xs =\n    [ if n1 < n2 then x != y else True\n    | (x,n1) <- numXs , (y,n2) <- numXs\n    ] == ~zero\n  where\n  numXs = [ (x,n) | x <- xs | n <- [ (0:[width n]) ... ] ]\n\ntype Position n = [width (n - 1)]\n\ntype Board n = [n](Position n)\n\ntype Solution n = Board n -> Bit\n\ncheckDiag : {n} (fin n, n >= 1) => Board n -> (Position n, Position n) -> Bit\ncheckDiag qs (i, j) = (i >= j) || (diffR != diffC)\n  where   qi = qs @ i\n          qj = qs @ j\n          diffR = if qi >= qj then qi-qj else qj-qi\n          diffC = j - i                   \nnQueens : {n} (fin n, n >= 1) => Solution n\nnQueens qs = all (inRange qs, qs) && all (checkDiag qs, ijs `{n}) && distinct qs\n\nijs : {n}(fin n, n>= 1)=> [_](Position n, Position n)\nijs = [ (i, j) | i <- [0 .. (n-1)], j <- [0 .. (n-1)]]\n\ninRange : {n} (fin n, n >= 1) => Board n -> Position n -> Bit\ninRange qs x = x <= `(n - 1)\n\nproperty nQueensProve x = (nQueens x) == False\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/Cipher.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Cipher that contains a single type alias also named Cipher, parameterized by two numeric type parameters representing bit widths: KeySize and BlockSize. The alias must be a record type with two fields: encrypt and decrypt. Each field is a function that takes (1) a key represented as a bitvector whose length is KeySize and (2) a data block represented as a bitvector whose length is BlockSize, and returns a bitvector of length BlockSize. Clearly state that KeySize and BlockSize are numeric type parameters (type-level naturals) and that the record fields are functions over fixed-width bitvectors. Do not implement any algorithms; only define the module and the type alias with the exact field names and function types. Ensure the module compiles in Cryptol and that the type alias and its fields are exported by the module."},{"role":"assistant","content":"```cryptol\nmodule Cipher where\n\ntype Cipher KeySize BlockSize =\n  { encrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  , decrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  }\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/ffs.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define in Cryptol two total functions over 32-bit words with type [32] -> [32]: (1) a reference function that iterates over bit positions 0..31 and returns the 1-based index of the least significant set bit of the input, returning 0 when the input is zero; and (2) an optimized function that computes the same value by conditionally right-shifting by 16, 8, 4, and 2 bits, accumulating an index offset, and applying a final adjustment based on the low bit, returning 0 when the input is zero. Then define a property that universally quantifies over all 32-bit inputs and asserts these two functions always produce equal outputs."},{"role":"assistant","content":"```cryptol\nffs_ref: [32] -> [32]\nffs_ref x = ixs!0 where\n    ixs = [0] # [ if (x && (1 << i)) != 0 then (i+1) else prev\n                | prev <- ixs\n                | i <- [31, 30 .. 0]:[32][32]\n                ]\n\nffs_imp: [32] -> [32]\nffs_imp i = if (i'''' > 0) then (n'''' + ((i'''' + 1) && 1)) else 0 where\n    n = 1\n    (n', i') =       if (zero==(i && 0x0000ffff))    then (n + 16, i >> 16) else (n, i)\n    (n'', i'') =     if (zero==(i' && 0x000000ff))   then (n' + 8, i' >> 8) else (n', i')\n    (n''', i''') =   if (zero==(i'' && 0x0000000f))  then (n'' + 4, i'' >> 4) else (n'',i'')\n    (n'''', i'''') = if (zero==(i''' && 0x00000003)) then (n''' + 2, i''' >> 2) else (n''', i''')\n\nproperty ffs_correct x = ffs_ref x == ffs_imp x\n```"}]}
{"filename":"saw-script\/doc\/rust-verification-with-saw\/code\/salsa20\/Salsa20Extras.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Salsa20Extras that contains the following definitions: (1) import the Salsa20 module; (2) type synonyms STATE_WORDS = 16 and BLOCK_SIZE = 64; (3) a function counter_setup with type [STATE_WORDS][32] -> [64] -> [STATE_WORDS][32] that returns the given 16-word, 32-bit state with elements at indices 8 and 9 replaced by the low and high 32-bit halves of the 64-bit counter, respectively (the high half is obtained by shifting right by 32 bits); (4) a function apply_keystream with type [32] -> [STATE_WORDS][32] -> [64] -> [BLOCK_SIZE][8] -> [BLOCK_SIZE][8] that, given a 32-bit round count, an initial 16x32-bit state, a 64-bit counter, and a 64-byte buffer, computes: first, the updated state via counter_setup; second, the state after applying Salsa20_rounds from the Salsa20 module using the round count and the updated state as both inputs; third, a 64-byte keystream by converting that state with littleendian_state_inverse from the Salsa20 module; and finally returns the XOR of the input buffer with this keystream. Use the exact sizes and indices described."},{"role":"assistant","content":"```cryptol\nmodule Salsa20Extras where\n\nimport Salsa20\n\ntype STATE_WORDS = 16\ntype BLOCK_SIZE = 64\n\ncounter_setup : [STATE_WORDS][32] -> [64] -> [STATE_WORDS][32]\ncounter_setup state counter =\n  updates state [8, 9] [drop counter, drop (counter >> 32)]\n\napply_keystream : [32] -> [STATE_WORDS][32] -> [64] -> [BLOCK_SIZE][8] -> [BLOCK_SIZE][8]\napply_keystream count state0 counter output =\n    output ^ littleendian_state_inverse state2\n  where\n    state1 = counter_setup state0 counter\n    state2 = Salsa20_rounds count state1 state1\n```"}]}
{"filename":"saw-script\/doc\/rust-verification-with-saw\/code\/salsa20\/Salsa20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Salsa20 that contains the following definitions with exact type signatures, constraints, and implementations: quarterround: [4][32] -> [4][32] using 32-bit addition, XOR, and fixed left-rotations per the standard pattern; rowround, rowround_opt, columnround, columnround_opt: [16][32] -> [16][32], where rowround\/columnround apply quarterround across rows\/columns of a 4x4 state, rowround_opt uses split\/rotate\/join, and columnround_opt uses transpose; doubleround: [16][32] -> [16][32] applying columnround then rowround; littleendian: [4][8] -> [32] converting bytes to a 32-bit word (little-endian); littleendian_inverse: {n} (fin n) => [8*n] -> [n][8] as its inverse; littleendian_state: [64][8] -> [16][32] and littleendian_state_inverse: [16][32] -> [64][8] as inverses between byte and word states; Salsa20: [32] -> [64][8] -> [64][8] that converts the byte state to words, iterates doubleround for half the round count, adds the original words, and converts back to bytes; Salsa20_rounds: [32] -> [16][32] -> [16][32] -> [16][32] building the iteration stream and selecting the appropriate element; Salsa20_init: {a} (1 <= a, a <= 2) => ([16*a][8], [16][8]) -> [64][8] that constructs the initial 64-byte state from a 16- or 32-byte key and 16-byte nonce using the standard constant words; Salsa20_expansion: {a} (1 <= a, a <= 2) => ([32], [16*a][8], [16][8]) -> [64][8]; Salsa20_encrypt_with_offset and Salsa20_encrypt: {a,l} (1 <= a, a <= 2, l <= 2^^70) => ([32], [16*a][8], [8][8], [64], [l][8]) -> [l][8] and ([32], [16*a][8], [8][8], [l][8]) -> [l][8], producing a keystream from successive blocks (counter with optional offset) and XORing with the message. Include properties that verify: quarterround, rowround, columnround, doubleround, and Salsa20 match known test vectors; rowround_opt equals rowround for all inputs; columnround equals the transpose-related form; littleendian and state conversions are inverses and match sample cases; and doubleround is collision-free on unequal inputs. Also include a Boolean definition that checks columnround_opt equals columnround."},{"role":"assistant","content":"```cryptol\nmodule Salsa20 where\n\nquarterround : [4][32] -> [4][32]\nquarterround [y0, y1, y2, y3] = [z0, z1, z2, z3]\n  where\n    z1 = y1 ^ ((y0 + y3) <<< 0x7)\n    z2 = y2 ^ ((z1 + y0) <<< 0x9)\n    z3 = y3 ^ ((z2 + z1) <<< 0xd)\n    z0 = y0 ^ ((z3 + z2) <<< 0x12)\n\nproperty quarterround_passes_tests =\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000000] == [0x00000000, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (quarterround [0x00000001, 0x00000000, 0x00000000, 0x00000000] == [0x08008145, 0x00000080, 0x00010200, 0x20500000]) \/\\\n  (quarterround [0x00000000, 0x00000001, 0x00000000, 0x00000000] == [0x88000100, 0x00000001, 0x00000200, 0x00402000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000001, 0x00000000] == [0x80040000, 0x00000000, 0x00000001, 0x00002000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000001] == [0x00048044, 0x00000080, 0x00010000, 0x20100001]) \/\\\n  (quarterround [0xe7e8c006, 0xc4f9417d, 0x6479b4b2, 0x68c67137] == [0xe876d72b, 0x9361dfd5, 0xf1460244, 0x948541a3]) \/\\\n  (quarterround [0xd3917c5b, 0x55f1c407, 0x52a58a7a, 0x8f887a3b] == [0x3e2f308c, 0xd90a8f36, 0x6ab2a923, 0x2883524c])\n\nrowround : [16][32] -> [16][32]\nrowround [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15] =\n    [z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15]\n  where\n    [ z0,  z1,  z2,  z3] = quarterround [ y0,  y1,  y2,  y3]\n    [ z5,  z6,  z7,  z4] = quarterround [ y5,  y6,  y7,  y4]\n    [z10, z11,  z8,  z9] = quarterround [y10, y11,  y8,  y9]\n    [z15, z12, z13, z14] = quarterround [y15, y12, y13, y14]\n\nproperty rowround_passes_tests =\n  (rowround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n            [0x08008145, 0x00000080, 0x00010200, 0x20500000,\n             0x20100001, 0x00048044, 0x00000080, 0x00010000,\n             0x00000001, 0x00002000, 0x80040000, 0x00000000,\n             0x00000001, 0x00000200, 0x00402000, 0x88000100]) \/\\\n  (rowround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n             0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n             0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n             0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n            [0xa890d39d, 0x65d71596, 0xe9487daa, 0xc8ca6a86,\n             0x949d2192, 0x764b7754, 0xe408d9b9, 0x7a41b4d1,\n             0x3402e183, 0x3c3af432, 0x50669f96, 0xd89ef0a8,\n             0x0040ede5, 0xb545fbce, 0xd257ed4f, 0x1818882d])\n\nrowround_opt : [16][32] -> [16][32]\nrowround_opt ys = join [ (quarterround (yi<<<i))>>>i | yi <- split ys | i <- [0 .. 3] ]\n\nproperty rowround_opt_is_rowround ys = rowround ys == rowround_opt ys\n\ncolumnround : [16][32] -> [16][32]\ncolumnround [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15] =\n    [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15]\n  where\n    [ y0,  y4,  y8, y12] = quarterround [ x0,  x4,  x8, x12]\n    [ y5,  y9, y13,  y1] = quarterround [ x5,  x9, x13,  x1]\n    [y10, y14,  y2,  y6] = quarterround [x10, x14,  x2,  x6]\n    [y15,  y3,  y7, y11] = quarterround [x15,  x3,  x7, x11]\n\nproperty columnround_passes_tests =\n  (columnround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x10090288, 0x00000000, 0x00000000, 0x00000000,\n                0x00000101, 0x00000000, 0x00000000, 0x00000000,\n                0x00020401, 0x00000000, 0x00000000, 0x00000000,\n                0x40a04001, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (columnround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n                0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n                0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n                0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n               [0x8c9d190a, 0xce8e4c90, 0x1ef8e9d3, 0x1326a71a,\n                0x90a20123, 0xead3c4f3, 0x63a091a0, 0xf0708d69,\n                0x789b010c, 0xd195a681, 0xeb7d5504, 0xa774135c,\n                0x481c2027, 0x53a8e4b5, 0x4c1f89c5, 0x3f78c9c8])\n\ncolumnround_opt : [16][32] -> [16][32]\ncolumnround_opt xs = join (transpose [ (quarterround (xi<<<i))>>>i | xi <- transpose(split xs) | i <- [0 .. 3] ])\n\ncolumnround_opt_is_columnround xs = columnround xs == columnround_opt xs\n\nproperty columnround_is_transpose_of_rowround ys =\n  rowround ys == join(transpose(split`{4}(columnround xs)))\n  where xs = join(transpose(split`{4} ys))\n\ndoubleround : [16][32] -> [16][32]\ndoubleround(xs) = rowround(columnround(xs))\n\nproperty doubleround_passes_tests =\n  (doubleround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x8186a22d, 0x0040a284, 0x82479210, 0x06929051,\n                0x08000090, 0x02402200, 0x00004000, 0x00800000,\n                0x00010200, 0x20400000, 0x08008104, 0x00000000,\n                0x20500000, 0xa0000040, 0x0008180a, 0x612a8020]) \/\\\n  (doubleround [0xde501066, 0x6f9eb8f7, 0xe4fbbd9b, 0x454e3f57,\n                0xb75540d3, 0x43e93a4c, 0x3a6f2aa0, 0x726d6b36,\n                0x9243f484, 0x9145d1e8, 0x4fa9d247, 0xdc8dee11,\n                0x054bf545, 0x254dd653, 0xd9421b6d, 0x67b276c1] ==\n               [0xccaaf672, 0x23d960f7, 0x9153e63a, 0xcd9a60d0,\n                0x50440492, 0xf07cad19, 0xae344aa0, 0xdf4cfdfc,\n                0xca531c29, 0x8e7943db, 0xac1680cd, 0xd503ca00,\n                0xa74b2ad6, 0xbc331c5c, 0x1dda24c7, 0xee928277])\n\nlittleendian : [4][8] -> [32]\nlittleendian b = join(reverse b)\n\nproperty littleendian_passes_tests =\n  (littleendian [  0,   0,   0,   0] == 0x00000000) \/\\\n  (littleendian [ 86,  75,  30,   9] == 0x091e4b56) \/\\\n  (littleendian [255, 255, 255, 250] == 0xfaffffff)\n\nlittleendian_inverse : {n} (fin n) => [8 * n] -> [n][8]\nlittleendian_inverse b = reverse(split b)\n\nproperty littleendian_is_invertable b = littleendian_inverse(littleendian b) == b\n\nlittleendian_state : [64][8] -> [16][32]\nlittleendian_state b = [littleendian xi | xi <- split b]\n\nlittleendian_state_inverse : [16][32] -> [64][8]\nlittleendian_state_inverse w = join (map littleendian_inverse w)\n\nproperty littleendian_state_is_invertable b = littleendian_state_inverse(littleendian_state b) == b\n\nSalsa20 : [32] -> [64][8] -> [64][8]\nSalsa20 count xs = littleendian_state_inverse (Salsa20_rounds count xw xw)\n  where\n    xw = littleendian_state xs\n\nSalsa20_rounds : [32] -> [16][32] -> [16][32] -> [16][32]\nSalsa20_rounds count xw xw' = xw + zs@(count\/2)\n  where\n    zs = [xw'] # [ doubleround zi | zi <- zs ]\n\nproperty Salsa20_passes_tests =\n  (Salsa20 20 [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0] ==\n              [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]) \/\\\n  (Salsa20 20 [211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37, 191, 187, 234, 136,\n                49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,  86,  16, 179, 207,\n                31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113, 238,  55, 204,  36,\n                79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,  88, 118, 104,  54] ==\n              [109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,  26, 110, 170, 154,\n                29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,  69, 144,  51,  57,\n               118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35,  27, 111, 114, 114,\n               219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158, 179,  19,  48, 202]) \/\\\n  (Salsa20 20 [ 88, 118, 104,  54,  79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,\n               191, 187, 234, 136, 211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37,\n                86,  16, 179, 207,  49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,\n               238,  55, 204,  36,  31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113] ==\n              [179,  19,  48, 202, 219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158,\n                26, 110, 170, 154, 109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,\n                69, 144,  51,  57,  29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,\n                27, 111, 114, 114, 118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35])\n\nproperty Salsa20_has_no_collisions x1 x2 =\n  if(x1 != x2) then (doubleround x1) != (doubleround x2) else True\n\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([32], [16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(count, k, n) = Salsa20 count (Salsa20_init(k, n))\n\nSalsa20_init : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_init(k, n) = x\n  where\n    [s0, s1, s2, s3] = split \"expand 32-byte k\" : [4][4][8]\n    [t0, t1, t2, t3] = split \"expand 16-byte k\" : [4][4][8]\n    x = if(`a == 2) then s0 # k0 # s1 # n # s2 # k1 # s3\n                    else t0 # k0 # t1 # n # t2 # k0 # t3\n    [k0, k1] = (split(k#zero)):[2][16][8]\n\nSalsa20_encrypt_with_offset : {a, l} (a >= 1, 2 >= a, l <= 2^^70) =>\n    ([32], [16*a][8], [8][8], [64], [l][8]) -> [l][8]\nSalsa20_encrypt_with_offset(count, k, v, o, m) = c\n  where\n    salsa = take (join [ Salsa20_expansion(count, k, v#(littleendian_inverse (o + i))) | i <- [0, 1 ... ] ])\n    c = m ^ salsa\n\nSalsa20_encrypt : {a, l} (a >= 1, 2 >= a, l <= 2^^70) => ([32], [16*a][8], [8][8], [l][8]) -> [l][8]\nSalsa20_encrypt(count, k, v, m) = c\n  where\n    salsa = take (join [ Salsa20_expansion(count, k, v#(littleendian_inverse i)) | i <- [0, 1 ... ] ])\n    c = m ^ salsa\n```"}]}
{"filename":"saw-script\/otherTests\/cryptol-saw-core\/instance.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a suite of Cryptol properties that, for every value and function in the file, proves it is extensionally equal to the intended primitive or typeclass method it wraps. Cover these groups: (1) zero-producing constants for bit, integer, rational, modular integers (mod n with n \u2265 1), fixed-size words, sequences over any Zero element, valid floating-point formats, functions that return a Zero result, unit, tuples, empty records, and two-field records; (2) logical complement for bit, words, sequences over a Logic element, functions producing Logic results, unit, tuples, empty records, and two-field records; (3) additive negation for integers, rationals, modular integers, words, sequences of ring elements (including nested sequences, function results, unit, tuples, empty records, and records), and valid floats; (4) remainder for integers and finite words; (5) multiplicative reciprocal for rationals, valid floats, and modular integers modulo a prime; (6) floor-based rounding from rational and valid floats to integer; (7) equality and less-than predicates for base types and for tuples\/records\/sequences under the appropriate Eq and Cmp constraints; (8) signed less-than for non-empty words and its liftings to sequences, tuples, unit, empty records, and records; (9) literal constructors that yield typed values from a numeric parameter under appropriate size\/finite and positivity constraints (e.g., bit limited to 0 or 1; modulus greater than the value; word width sufficient for the value); (10) range constructors producing sequences from zero up to one less than the parameter value for the supported element types with necessary width\/length constraints. Each property must universally quantify all size parameters and element types and state the required finiteness, positivity, validity, and class constraints (Zero, Logic, Ring, Eq, Cmp, SignedCmp, prime, valid float)."},{"role":"assistant","content":"```cryptol\nzeroBit : Bit\nzeroBit = zero\n\nzeroInteger : Integer\nzeroInteger = zero\n\nzeroRational : Rational\nzeroRational = zero\n\nzeroZ : {n} (fin n, n >= 1) => Z n\nzeroZ = zero\n\nzeroWord : {n} [n]\nzeroWord = zero\n\nzeroSeq : {n, a} (Zero a) => [n]a\nzeroSeq = zero\n\nzeroFloat : {e, p} (ValidFloat e p) => Float e p\nzeroFloat = zero\n\nzeroFun : {a, b} (Zero b) => a -> b\nzeroFun = zero\n\nzeroUnit : ()\nzeroUnit = zero\n\nzeroTuple : {a, b} (Zero a, Zero b) => (a, b)\nzeroTuple = zero\n\nzeroEmpty : {}\nzeroEmpty = zero\n\nzeroRecord : {a, b} (Zero a, Zero b) => {x : a, y : b}\nzeroRecord = zero\n\nlogicBit : Bit -> Bit\nlogicBit = complement\n\nlogicWord : {n} [n] -> [n]\nlogicWord = complement\n\nlogicSeq : {n, a} (Logic a) => [n]a -> [n]a\nlogicSeq = complement\n\nlogicFun : {a, b} (Logic b) => (a -> b) -> (a -> b)\nlogicFun = complement\n\nlogicUnit : () -> ()\nlogicUnit = complement\n\nlogicTuple : {a, b} (Logic a, Logic b) => (a, b) -> (a, b)\nlogicTuple = complement\n\nlogicEmpty : {} -> {}\nlogicEmpty = complement\n\nlogicRecord : {a, b} (Logic a, Logic b) => {x : a, y : b} -> {x : a, y : b}\nlogicRecord = complement\n\nringInteger : Integer -> Integer\nringInteger = negate\n\nringRational : Rational -> Rational\nringRational = negate\n\nringZ : {n} (fin n, n >= 1) => Z n -> Z n\nringZ = negate\n\nringWord : {n} (fin n) => [n] -> [n]\nringWord = negate\n\nringSeqInteger : {n} [n]Integer -> [n]Integer\nringSeqInteger = negate\n\nringSeqRational : {n} [n]Rational -> [n]Rational\nringSeqRational = negate\n\nringSeqZ : {n, k} (fin k, k >= 1) => [n](Z k) -> [n](Z k)\nringSeqZ = negate\n\nringSeqSeq : {n, k, a} (Ring ([k]a)) => [n][k]a -> [n][k]a\nringSeqSeq = negate\n\nringSeqFun : {n, a, b} (Ring b) => [n](a -> b) -> [n](a -> b)\nringSeqFun = negate\n\nringSeqUnit : {n} [n]() -> [n]()\nringSeqUnit = negate\n\nringSeqTuple : {n, a, b} (Ring a, Ring b) => [n](a, b) -> [n](a, b)\nringSeqTuple = negate\n\nringSeqEmpty : {n} [n]{} -> [n]{}\nringSeqEmpty = negate\n\nringSeqRecord : {n, a, b} (Ring a, Ring b) => [n]{x : a, y : b} -> [n]{x : a, y : b}\nringSeqRecord = negate\n\nringFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p\nringFloat = negate\n\nringFun : {a, b} (Ring b) => (a -> b) -> (a -> b)\nringFun = negate\n\nringUnit : () -> ()\nringUnit = negate\n\nringTuple : {a, b} (Ring a, Ring b) => (a, b) -> (a, b)\nringTuple = negate\n\nringEmpty : {} -> {}\nringEmpty = negate\n\nringRecord : {a, b} (Ring a, Ring b) => {x : a, y : b} -> {x : a, y : b}\nringRecord = negate\n\nintegralInteger : Integer -> Integer -> Integer\nintegralInteger = (%)\n\nintegralWord : {n} (fin n) => [n] -> [n] -> [n]\nintegralWord = (%)\n\nfieldRational : Rational -> Rational\nfieldRational = recip\n\nfieldFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p\nfieldFloat = recip\n\nfieldZ : {p} prime p => Z p -> Z p\nfieldZ = recip\n\nroundRational : Rational -> Integer\nroundRational = floor\n\nroundFloat : {e, p} (ValidFloat e p) => Float e p -> Integer\nroundFloat = floor\n\neqBit : Bit -> Bit -> Bit\neqBit = (==)\n\neqInteger : Integer -> Integer -> Bit\neqInteger = (==)\n\neqRational : Rational -> Rational -> Bit\neqRational = (==)\n\neqZ : {n} (fin n, n >= 1) => Z n -> Z n -> Bit\neqZ = (==)\n\neqWord : {n} (fin n) => [n] -> [n] -> Bit\neqWord = (==)\n\neqSeq : {n, a} (fin n, Eq a) => [n]a -> [n]a -> Bit\neqSeq = (==)\n\neqFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p -> Bit\neqFloat = (==)\n\neqUnit : () -> () -> Bit\neqUnit = (==)\n\neqTuple : {a, b} (Eq a, Eq b) => (a, b) -> (a, b) -> Bit\neqTuple = (==)\n\neqEmpty : {} -> {} -> Bit\neqEmpty = (==)\n\neqRecord : {a, b} (Eq a, Eq b) => {x : a, y : b} ->  {x : a, y : b} -> Bit\neqRecord = (==)\n\ncmpBit : Bit -> Bit -> Bit\ncmpBit = (<)\n\ncmpInteger : Integer -> Integer -> Bit\ncmpInteger = (<)\n\ncmpRational : Rational -> Rational -> Bit\ncmpRational = (<)\n\ncmpWord : {n} (fin n) => [n] -> [n] -> Bit\ncmpWord = (<)\n\ncmpSeq : {n, a} (fin n, Cmp a) => [n]a -> [n]a -> Bit\ncmpSeq = (<)\n\ncmpFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p -> Bit\ncmpFloat = (<)\n\ncmpUnit : () -> () -> Bit\ncmpUnit = (<)\n\ncmpTuple : {a, b} (Cmp a, Cmp b) => (a, b) -> (a, b) -> Bit\ncmpTuple = (<)\n\ncmpEmpty : {} -> {} -> Bit\ncmpEmpty = (<)\n\ncmpRecord : {a, b} (Cmp a, Cmp b) => {x : a, y : b} ->  {x : a, y : b} -> Bit\ncmpRecord = (<)\n\nsignedCmpWord : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsignedCmpWord = (<$)\n\nsignedCmpSeqSeq : {n, k, a} (fin n, SignedCmp ([k]a)) => [n][k]a -> [n][k]a -> Bit\nsignedCmpSeqSeq = (<$)\n\nsignedCmpSeqUnit : {n} (fin n) => [n]() -> [n]() -> Bit\nsignedCmpSeqUnit = (<$)\n\nsignedCmpSeqTuple : {n, a, b} (fin n, SignedCmp a, SignedCmp b) => [n](a, b) -> [n](a, b) -> Bit\nsignedCmpSeqTuple = (<$)\n\nsignedCmpSeqEmpty : {n} (fin n) => [n]{} -> [n]{} -> Bit\nsignedCmpSeqEmpty = (<$)\n\nsignedCmpSeqRecord : {n, a, b} (fin n, SignedCmp a, SignedCmp b) => [n]{x : a, y : b} -> [n]{x : a, y : b} -> Bit\nsignedCmpSeqRecord = (<$)\n\nsignedCmpUnit : () -> () -> Bit\nsignedCmpUnit = (<$)\n\nsignedCmpTuple : {a, b} (SignedCmp a, SignedCmp b) => (a, b) -> (a, b) -> Bit\nsignedCmpTuple = (<$)\n\nsignedCmpEmpty : {} -> {} -> Bit\nsignedCmpEmpty = (<$)\n\nsignedCmpRecord : {a, b} (SignedCmp a, SignedCmp b) => {x : a, y : b} ->  {x : a, y : b} -> Bit\nsignedCmpRecord = (<$)\n\nliteralBit : {val} (1 >= val) => Bit\nliteralBit = `val\n\nliteralInteger : {val} (fin val) => Integer\nliteralInteger = `val\n\nliteralRational : {val} (fin val) => Rational\nliteralRational = `val\n\nliteralZ : {val, n} (fin val, fin n, n >= 1, n > val) => Z n\nliteralZ = `val\n\nliteralWord : {val, n} (fin val, fin n, n >= width val) => [n]\nliteralWord = `val\n\nliteralLessThanBit : {val} (1 >= val) => [val]Bit\nliteralLessThanBit = [0..<val]\n\nliteralLessThanInteger : {val} (fin val) => [val]Integer\nliteralLessThanInteger = [0..<val]\n\nliteralLessThanRational : {val} (fin val) => [val]Rational\nliteralLessThanRational = [0..<val]\n\nliteralLessThanZ : {val, n} (fin n, n >= 1, n >= val) => [val](Z n)\nliteralLessThanZ = [0..<val]\n\nliteralLessThanWord : {val, n} (fin n, n >= lg2 val) => [val][n]\nliteralLessThanWord = [0..<val]\n```"}]}
{"filename":"saw-script\/otherTests\/cryptol-saw-core\/superclass.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the following polymorphic helpers with explicit type signatures and implementations, using appropriate class constraints and standard primitives: (1) A function named zeroRing that, for any type supporting ring operations, returns the additive identity. (2) A function named zeroLogic that, for any type supporting logical operations, returns the false\/zero element. (3) A function named zeroIntegral that, for any integral type, returns the additive identity. (4) A function named zeroField that, for any field type, returns the additive identity. (5) A function named zeroRound that, for any type supporting rounding semantics, returns the additive identity. (6) A function named fromIntIntegral that, for integral types, produces the value corresponding to the integer literal 42. (7) A function named fromIntField that, for field types, produces the value corresponding to the integer literal 42. (8) A function named fromIntRound that, for round-capable types, produces the value corresponding to the integer literal 42. (9) A function named recipRound that, for round-capable types, takes a value and returns the truncated Integer obtained from its multiplicative inverse. (10) A function named compareRound that, for round-capable types, takes two values and returns a Bit indicating strict less-than. (11) A function named eqCmp that, for types supporting comparisons, takes two values and returns a Bit indicating equality. Use the canonical primitives for zero, numeric literal conversion, reciprocal, truncation to Integer, and the standard comparison operators. Ensure all necessary class constraints (Ring, Logic, Integral, Field, Round, Cmp) are stated in the type signatures, and that the return types for Boolean results are Bit and for integer results are Integer."},{"role":"assistant","content":"```cryptol\nzeroRing : {a} (Ring a) => a\nzeroRing = zero\n\nzeroLogic : {a} (Logic a) => a\nzeroLogic = zero\n\nzeroIntegral : {a} (Integral a) => a\nzeroIntegral = zero\n\nzeroField : {a} (Field a) => a\nzeroField = zero\n\nzeroRound : {a} (Round a) => a\nzeroRound = zero\n\nfromIntIntegral : {a} (Integral a) => a\nfromIntIntegral = fromInteger 42\n\nfromIntField : {a} (Field a) => a\nfromIntField = fromInteger 42\n\nfromIntRound : {a} (Round a) => a\nfromIntRound = fromInteger 42\n\nrecipRound : {a} (Round a) => a -> Integer\nrecipRound x = trunc (recip x)\n\ncompareRound : {a} (Round a) => a -> a -> Bit\ncompareRound x y = x < y\n\neqCmp : {a} (Cmp a) => a -> a -> Bit\neqCmp x y = x == y\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/ModDivZ.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::ModDivZ that contains the following definitions: (1) even: Integer -> Bit, returning true iff its argument is divisible by 2; (2) moddiv: {p} (fin p, p >= 3) => Z p -> Z p -> Z p, performing modular division of two elements in Z p and raising a division-by-zero error when the divisor is zero. Implement moddiv by converting operands to Integer, invoking a binary extended GCD helper to compute a coefficient r such that y*r \u2261 x (mod p), and converting r back to Z p; (3) egcd: Integer -> Integer -> Integer -> Integer -> Integer, implementing the binary extended GCD on state (a, ra, b, rb) with: base case when b = 0 returning ra; if b is even, halve b and replace rb with half(rb); otherwise, if a < b, set b := (b \u2212 a)\/2 and rb := half((rb \u2212 ra) mod p); else set a := (a \u2212 b)\/2 and ra := half((ra \u2212 rb) mod p), maintaining all residues modulo p; (4) half: Integer -> Integer, returning k\/2 when k is even, and (k + p)\/2 when k is odd to preserve residues modulo p; (5) an infix operator (%\/) with the same polymorphic type as moddiv that delegates to moddiv. Also define properties: (a) for all p, x, y meeting the constraints and y \u2260 0, y * moddiv x y == x in Z p; (b) for all valid arguments, (%\/) produces the same result as moddiv. Clearly document the type parameters, constraints, domains, and any necessary conversions between Z p and Integer within the module."},{"role":"assistant","content":"```cryptol\nmodule Common::ModDivZ where\n\neven k = k % 2 == 0\n\nmoddiv : {p}(fin p, p >= 3) => Z p -> Z p -> Z p  moddiv x y = if y == 0 then error \"division by 0\"                         else fromInteger (egcd `p 0 (fromZ y) (fromZ x))\n    where\n\n    egcd : Integer -> Integer -> Integer -> Integer -> Integer\n    egcd a ra b rb =          if b == 0 then ra\n         | even b then egcd a ra (   b    \/ 2) (half rb)\n         | a < b  then egcd a ra ((b - a) \/ 2) (half ((rb - ra) % `p))\n                  else egcd b rb ((a - b) \/ 2) (half ((ra - rb) % `p))\n\n    half : Integer -> Integer\n    half k = (if even k then k else (k + `p)) \/ 2\n\n(%\/) = moddiv\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/mul_java.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Common::mul_java that imports Common::bv and contains the following definitions with precise Cryptol type signatures, array sizes, and carry semantics:\n- mul_java_inner: given a flag indicating whether to zero the selected limb, a 24\u00d732-bit limb array, a 32-bit index, two 32-bit limbs, and a 64-bit carry, compute a 64-bit product of the limbs, add the prior carry and selected limb (or zero), write the low 32 bits back at the index, and return the updated limb array and next 64-bit carry.\n- aset: a generic function that inserts a 32-bit word into limb position i of an n-bit vector by masking and shifting. Include constraints ensuring finiteness, n is a multiple of 32, and the index width covers limb positions. Provide a specialization aset_768 for 768-bit values.\n- toJavaArray\/fromJavaArray: convert between a 384-bit value and a 12\u00d732-bit limb array matching Java int[] limb order (inverse of each other).\n- mul_java: multiply two 384-bit values producing a 768-bit result using schoolbook multiplication over 12 limbs with explicit carry propagation via mul_java_inner; implement the first and second loops as fixed-size comprehensions and finalize by joining limbs.\n- sq_java_inner1 and sq_java_inner2: helpers for squaring that perform double-add and square-with-carry of a selected limb, updating the limb and returning the next carry.\n- sq_java_loop and sq_java: square a 384-bit value into 768 bits using the same limb order and three-phase loop structure (initial accumulation, cross terms, and final diagonal terms) with correct carry handling.\n- aset_384: 384-bit version of aset implemented via the array conversions.\n- java_lashr32: logical right shift by 32 on a 64-bit value using Java semantics (zero-fill).\n- group_red_aux_java and group_mul_aux_java: single-limb reduction and multiplication accumulation steps that read the j-th 32-bit limb from a 384-bit accumulator, update it, and return the next 64-bit carry\/borrow.\n- p384_group_red: reduce a 384-bit value with an incoming 64-bit carry against a 384-bit modulus using 12-limb iteration and conditional subtraction to canonicalize.\n- p384_group_mul: modular multiplication of two 384-bit values modulo a 384-bit modulus using outer limb shifting, inner accumulation, per-step reduction, and final conditional subtraction."},{"role":"assistant","content":"```cryptol\nmodule Common::mul_java where\n\nimport Common::bv\n\nmul_java_inner : (Bit, [24][32], [32], [32], [32], [64]) -> { mji_a : [24][32], mji_d : [64]}\nmul_java_inner (azero, a, ij, xi, yj, d) = { mji_a = a', mji_d = d' >> 32 }\n  where\n    m        = zext(xi) * zext(yj)\n    d'       = d + m + zext(aij)\n    a'       = update a ij (drop(d'))\n    aij      = if ~azero then a @ ij else 0\n\n\/*\naset : {n, is} (fin n, fin is, n >= is, is >= lg2 n, n >= 32, is >= max(lg2 n, 6)) =>\n          ([n], [is], [is]) -> [n]\n*\/\naset (a, i, x) = (a && imask) || x'\n  where\n    imask = ~(zext(0xFFFFFFFF : [32]) << (i*32))\n    x' = zext(x) << (i*32)\n\naset_768 : ([768], [32], [32]) -> [768]\naset_768 = aset\n\ntoJavaArray : [384] -> [12][32]\ntoJavaArray x = reverse (split x)\n\nfromJavaArray : [12][32] -> [384]\nfromJavaArray x = join (reverse x)\n\n\/\/ Matches java implementation; computes safe_product.\nmul_java : ([768], [384], [384]) -> [768]\nmul_java (a0, x, y) = join (reverse (a_final!0))\n  where\n    l   = 12 : [32]\n    x'  = toJavaArray x\n    y'  = toJavaArray y\n    a0' = reverse (split a0) : [24][32]\n\n    a_first : [13]([64],[24][32])\n    a_first = [ (zero : [64], a0' : [24][32]) ]\n            # [ (res.mji_d, res.mji_a)\n                   where res = mul_java_inner(True, a, j, x'@0, y'@j, d)\n              | (d, a) <- a_first\n              | j      <- [0..11]\n              ]\n    (d_first_final, a_first_final) = a_first!0\n    ad_first_final = update a_first_final l (drop(d_first_final):[32])\n\n    \/* Second loop in Java implementation *\/\n    a_final : [12][24][32]\n    a_final = [ ad_first_final ]\n            # [ ad_inner_final\n                 where\n                   \/* Inner loop in Java implementation *\/\n                   a_inner : [13]([64],[24][32],[32])\n                   a_inner = [ ( zero : [64] \/* d *\/, a, i) ]\n                           # [ (res.mji_d, res.mji_a, ij+1)\n                                where\n                                  res = mul_java_inner(False, ai, ij, x'@i, y'@j, d)\n                             | (d, ai, ij) <- a_inner\n                             | j          <- [0..(12-1)]:[12][32]\n                             ]\n\n                   (d_inner_final, a_inner_final, ij_final) = a_inner!0\n                   ad_inner_final = update a_inner_final ij_final (drop(d_inner_final))\n              | a <- a_final\n              | i <- [1..11]\n              ]\n\nsq_java_inner1 : ([24][32], [32], [64]) -> { mji_a : [24][32], mji_d : [64]}\nsq_java_inner1 (a, ij, c) = { mji_a = a' , mji_d = c'' }\n  where\n    aij = a @ ij\n    c' = c + (zext(aij) << 1)\n    a' = update a ij (drop(c'))\n    c'' = c' >> 32\n\nsq_java_inner2 : ([24][32], [32], [32], [64]) ->\n                 { mji_a : [24][32], mji_d : [64]}\nsq_java_inner2 (a, ij, xati, c) = { mji_a = a' , mji_d = c'' }\n  where\n    aij = a @ ij\n    xi = zext(xati) : [64]\n    m = xi * xi\n    c' = c + (m && 0x00000000FFFFFFFF) + (zext(aij) << 1)\n    a' = update a ij (drop(c'))\n    c'' = (c' >> 32) + (m >> 32)\n\nsq_java_loop : ([24][32], [384]) -> [24][32]\nsq_java_loop(a0, x) = a_mid!0\n  where\n    \/* Second loop in Java implementation *\/\n    l = 12 : [32]\n    x'  = toJavaArray x\n    a_mid   = [ a0 ]\n            # [ ad_inner_final\n                 where\n\n                   a_inner = [ ( zero : [64] , a, i+i+1) ]\n                           # [ (res.mji_d, res.mji_a, ij+1)\n                                where\n                                  res = if j+i < l then\n                                          mul_java_inner(False, ai, ij, x'@i, x'@(j+i), d)\n                                        else zero\n                             | (d, ai, ij) <- a_inner\n                             | j          <- [1..(12-1)]\n                             ]\n                   (d_inner_final, a_inner_final, ij_final) = a_inner!i\n                   ad_inner_final = update a_inner_final ij_final (drop(d_inner_final))\n              | a <- a_mid\n              | i <- [1..(12-2)]\n              ]\n\nsq_java : ([768], [384]) -> [768]\nsq_java (a0, x) = join (reverse ad_final_final)\n  where\n    l   = 12 : [32]\n    x'  = toJavaArray x\n    a0' = reverse (split a0) : [24][32]\n    x0 = x'@0\n    \/* First loop in Java implementation *\/\n    a_first = [ (zero : [64], a0' : [24][32]) ]\n            # [ (res.mji_d, res.mji_a)\n                 where res = mul_java_inner(True, a, j, x0, x'@j, d)\n              | (d, a) <- a_first\n              | j      <- [1..11]\n              ]\n    (d_first_final, a_first_final) = a_first!0\n    ad_first_final = update a_first_final l (drop(d_first_final))\n\n    mid_res = mul_java_inner(True, sq_java_loop(ad_first_final, x), 0, x0, x0, 0)\n\n    \/* Third loop in Java implementation *\/\n    a_final : [12]([64],[24][32],[32])\n    a_final = [ (mid_res.mji_d, mid_res.mji_a, 1) ]\n            # [ (res'.mji_d, res'.mji_a, ij+2)\n                where\n                   res = sq_java_inner1(a, ij, c)\n                   res' = sq_java_inner2(res.mji_a, ij+1, x'@(i:[32]), res.mji_d)\n              | (c, a, ij) <- a_final\n              | i      <- [1..11]\n              ]\n    (d_final_final, a_final_final, ij_final) = a_final!0\n    ad_final_final = update a_final_final ((l << 1) - 1) (drop(d_final_final))\n\naset_384 : ([384], [32], [32]) -> [384]\naset_384(a, i, x) = fromJavaArray (update (toJavaArray a) i x)\n\njava_lashr32 : [64] -> [64]\njava_lashr32 x = take(sext(x) : [96])\n\ngroup_red_aux_java : ([384], [32], [32], [64], [64]) ->\n                     { gra_r: [384] , gra_b : [64] }\ngroup_red_aux_java(r, aj, j, c, b) = { gra_r = r' , gra_b = b'' }\n  where\n    rj, m, b' : [64]\n    rj = zext(toJavaArray r @ j)\n    m = c * zext(aj)\n    b' = b + rj - zext(drop(m):[32])\n    r' = aset_384(r, j, drop(b'))\n    b'' = java_lashr32(b') - (m >> 32)\n\ngroup_mul_aux_java : ([384], [32], [32], [32], [64]) ->\n                     { gra_r: [384] , gra_b : [64] }\ngroup_mul_aux_java(r, yj, j, xi, c) = { gra_r = r' , gra_b = c'' }\n  where\n    rj, m, c' : [64]\n    rj = zext(toJavaArray r @ j)\n    m = zext(xi) * zext(yj)\n    c' = c + rj + zext(drop(m):[32])\n    r' = aset_384(r, j, drop(c'))\n    c'' = (c' >> 32) + (m >> 32)\n\np384_group_red : ([384], [384], [64]) -> [384]\np384_group_red(order, r, c) = r'''\n  where\n    order' = toJavaArray order\n    loop : [13]([384],[64])\n    loop = [ (r, zero : [64]) ] #\n           [ (res.gra_r, res.gra_b)\n              where res = group_red_aux_java(rj, order'@j, j, c, bi)\n           | (rj, bi) <- loop\n           | j <- [0..11]\n           ]\n    (r', b) = loop!0\n    c' = c + b\n    (r'', c'') = if c' != 0 then\n                   (r' - order, c' + (if r' >= order then 0 else -1))\n                 else (r', c')\n    r''' = if c'' != 0 then r'' - order else r''\n\np384_group_mul : ([384], [384], [384]) -> [384]\np384_group_mul(order, x, y) = r'\n  where\n    xa = toJavaArray x\n    ya = toJavaArray y\n    outer : [13][384]\n    outer = [ (zero : [384]) ] #\n            [ p384_group_red(order, rn, cn)\n               where\n                 r0 : [384]\n                 r0 = p384_group_red(order,\n                                     ro << (32 : [9]),\n                                     zext(take(ro):[32]))\n                 inner : [13]([384], [64])\n                 inner = [ (r0, 0) ] #\n                         [ (res.gra_r, res.gra_b)\n                            where\n                              res = group_mul_aux_java(rj, ya@j, j, xa@(i:[32]), cj)\n                         | j <- [0..11]\n                         | (rj, cj) <- inner\n                         ]\n                 (rn, cn) = inner!0\n            | i <- reverse [0..11]\n            | ro <- outer\n            ]\n    r = outer!0\n    r' = if order <= r then r - order else r\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/utils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::utils that contains the following definitions: (1) A generic while combinator over a state type that takes a predicate on the state and a state transformer, iterating until the predicate on the current state is false, returning the final state. (2) A generic do-while combinator that applies the transformer once, then continues while the predicate holds on the updated state. (3) Converters between modular integers, bitvectors, and unbounded integers: from modular integer to bitvector, from bitvector to modular integer, between modular integer widths, and Integer\u2194bitvector. Include a function that returns the bitvector\u2019s Integer value but at least 3. State appropriate finiteness and width constraints. (4) An evenness test on Integer using its least significant bit. (5) Absolute value on Integer. (6) Unzipping a sequence of pairs into a pair of sequences. (7) Small multipliers by 2, 3, 4, and 8 using addition\/doubling. (8) A type-level constraint alias expressing that a natural is odd. (9) A function on Z p (with p finite, p \u2265 3, and odd) that returns \u201chalf\u201d of an element: x\/2 when x is even, otherwise (x + p)\/2; ensure the result has type Z p. (10) Define a property that verifies doubling the \u201chalf\u201d result equals the original element in Z p under the stated constraints. (11) A modular inverse function on Z n for n \u2265 1 that errors on zero input and otherwise computes the inverse via a binary extended-GCD style process that repeatedly halves even values and subtracts the smaller from the larger while tracking coefficients modulo n, returning the correct inverse representative. (12) Define a property that verifies for moduli \u2265 2 and nonzero inputs that the product of an element and its modular inverse equals one. Include clear type signatures and constraints for all definitions."},{"role":"assistant","content":"```cryptol\nmodule Common::utils where\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = (fromInteger (fromZ x))\n\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = (fromInteger (toInteger x))\n\nZtoZ : {p, q} (fin p, fin q, p >= 1, q >= 1) => Z p -> Z q\nZtoZ x = (fromInteger (fromZ x))\n\nintegerToBV : {m} (fin m) => Integer -> [m]\nintegerToBV x = fromInteger x\n\nintegerFromBV : {m} (fin m) => [m] -> Integer\nintegerFromBV x = toInteger x\n\nintegerModulusFromBV : {m} (fin m) => [m] -> Integer\nintegerModulusFromBV x = if (integerFromBV x) < 3 then 3 else (integerFromBV x)\n\nisEven : Integer -> Bit\nisEven x = ~((fromInteger x) : [1]) ! 0\n\nabs : Integer -> Integer\nabs x = if x >= zero then x else zero-x\n\nunzip : {a,f,s} [a](f,s) -> ([a]f,[a]s)\nunzip tuples = (map (\\x -> x.0) tuples , map (\\x -> x.1) tuples)\n\nmul2 x = x + x\nmul3 x = x + mul2 x\nmul4 x = mul2(mul2 x)\nmul8 x = mul2(mul4 x)\n\ntype constraint isOdd a = (a \/ 2) * 2 == a - 1\n\nhalf : {p} (fin p, p >= 3, isOdd p) => Z p -> Z p\nhalf x = fromInteger (if isEven xint then xint\/2 else ((xint + `p) \/ 2))\n  where\n    xint = fromZ x\n\nhalf_correct : {p} (fin p, p >= 3, isOdd p) => Z p -> Bit\nproperty half_correct x = half x + half x == x\n\nmp_mod_inv : {n} (fin n, n >= 1) => Z n -> Z n\nmp_mod_inv c = if c == 0 then error \"Zero does not have a multiplicative inverse\"\n               else fromInteger (if u'' == 1 then x1'' else x2'')\n  where\n    innercond (a, x) = isEven a\n    innerbody (a, x) = (a \/ 2, if isEven x then x \/ 2 else (x + `n) \/ 2)\n\n    outtercond (u, v, x1, x2) = (u != 1) \/\\ (v != 1)\n    outterbody (u, v, x1, x2) = if(u' >= v') then (u' - v', v', x1' - x2' % `n, x2')\n                                             else (u', v' - u', x1', x2' - x1' % `n)\n      where\n        (u', x1') = while innercond innerbody (u, x1)\n        (v', x2') = while innercond innerbody (v, x2)\n\n    (u'', _, x1'', x2'') = while outtercond outterbody (fromZ c, `n, 1, 0)\n\nmp_mod_inv_correct : {a} (fin a, a >=2) => Z a -> Bit\nproperty mp_mod_inv_correct x = x != 0 ==> x * mp_mod_inv x == 1\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::MAC::HMAC that contains the following definitions: (1) An import of the SHA-256 hash specification. (2) A function kinit that, given a block size (in bytes), a hash from a key to a digest, and a key as a sequence of bytes, returns a block-sized sequence of bytes: if the key length exceeds the block size, hash the key, then zero-pad and truncate to the block size; otherwise zero-pad the key to the block size. (3) A function hmac with size parameters for message length, key length, digest length, and block size, all finite. It takes three hashes: one over block+message bytes to a digest-sized bitvector, one over block+digest bytes to a digest-sized bitvector, and one over key bytes to a digest-sized bitvector. Given a key and message, compute ks = kinit(hash3, key); form inner and outer keys by XORing each byte of ks with 0x36 and 0x5C, respectively; compute the inner hash over the inner key concatenated with the message; then compute the final digest over the outer key concatenated with the inner hash. The result is a bitvector of length digest*8. (4) A function hmacSHA256 that specializes hmac to SHA-256 with a 64-byte block size, with constraints ensuring all size parameters are finite and bounded consistently with that block size. Also include: (a) define a property that, for all keys and messages, hmacSHA256 equals invoking hmac with SHA-256 and a 64-byte block size; (b) define a property that kinit zero-pads when the key length does not exceed the block size and hash-then-zero-pads-and-truncates when it does; (c) define a property that the inner and outer keys are formed by XORing each byte of the block key with 0x36 and 0x5C, respectively."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC where\n\nimport Primitive::Keyless::Hash::SHA256\n\nhmacSHA256 : {pwBytes, msgBytes}\n             (fin pwBytes, fin msgBytes\n             , 32 >= width msgBytes\n             , 64 >= width (8*pwBytes)\n             , 64 >= width (8 * (64 + msgBytes))\n             ) => [pwBytes][8] -> [msgBytes][8] -> [256]\nhmacSHA256 = hmac `{blockLength=64} SHA256 SHA256 SHA256\n\nkinit : { pwBytes, blockLength, digest }\n        ( fin pwBytes, fin blockLength, fin digest )\n     => ([pwBytes][8] -> [8*digest])\n     -> [pwBytes][8]\n     -> [blockLength][8]\nkinit hash key =\n  if `pwBytes > (`blockLength : [max (width pwBytes) (width blockLength)])\n  then take `{blockLength} (split (hash key) # (zero : [blockLength][8]))\n  else take `{blockLength} (key # (zero : [blockLength][8]))\n\nhmac : { msgBytes, pwBytes, digest, blockLength }\n       ( fin pwBytes, fin digest, fin blockLength )\n    => ([blockLength + msgBytes][8] -> [8*digest])\n    -> ([blockLength + digest][8] -> [8*digest])\n    -> ([pwBytes][8] -> [8*digest])\n    -> [pwBytes][8]\n    -> [msgBytes][8]\n    -> [digest*8]\nhmac hash hash2 hash3 key message = hash2 (okey # internal)\n where\n   ks : [blockLength][8]\n   ks = kinit hash3 key\n   okey = [k ^ 0x5C | k <- ks]\n   ikey = [k ^ 0x36 | k <- ks]\n   internal = split (hash (ikey # message))\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/AES_256_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM that contains the following definitions and types, matching AES-GCM semantics and sizes exactly:\n- Import the AES block-cipher module providing single-block encryption.\n- A function that encrypts one 16-byte block under a 32-byte key using the imported AES primitive, converting between byte arrays and a 128-bit word as needed, and returning a 16-byte block.\n- A function that multiplies two 128-bit field elements in GF(2^128) with bit-order handling appropriate for GCM (reverse before\/after), then reduces modulo the GCM polynomial x^128 + x^7 + x^2 + x + 1, returning a 128-bit result.\n- A size-parameterized polynomial multiply that prefixes a leading zero bit to the product and a corresponding reduction function; compose them to define a POLYVAL-like helper over 128-bit operands.\n- A function that initializes the GHASH subkey H from a 128-bit input by appending a 1-bit and reducing modulo 1 + x^121 + x^126 + x^127 + x^128.\n- A record type AES_GCM_Ctx with fields: key (32 bytes), iv (12 bytes), Xi (16-byte GHASH accumulator), len (64-bit counter of processed bytes).\n- A function that derives H by AES-encrypting the all-zero 16-byte block with the context key and returning the result split into two 64-bit words.\n- A function that produces the i-th keystream block by concatenating the 12-byte IV with a 4-byte big-endian counter (i + 1), then AES-encrypts under the key; and a function that extracts the j-th byte from that block.\n- An update function that, given a 32-bit selector, the context, and a byte sequence, either XORs bytes with the CTR keystream (if selected) or passes bytes through, then folds an incremental GHASH update over bytes.\n- A CTR32 encryptor that XORs each input byte with the corresponding keystream byte using a 32-bit counter derived from the byte index and context length.\n- A per-byte context updater that XORs the byte into Xi at position (len mod 16), increments len, and on 16-byte boundaries multiplies Xi by H in GF(2^128).\n- A finalizer that computes the authentication tag by finishing GHASH (including padding a partial block and XORing the bit-length of data = len*8) and XORing with the first keystream block."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM where\n\nimport Primitive::Symmetric::Cipher::Block::AES\n\naes_hw_encrypt : [16][8] -> [32][8] -> [16][8]\naes_hw_encrypt in key = split (aesEncrypt ((join in), (join key)))\n\ngcm_pmult_pmod : [128] -> [128] -> [128]\ngcm_pmult_pmod X Y = reverse (pmod (pmult (reverse X) (reverse Y)) <| x^^128 + x^^7 + x^^2 + x + 1|>)\n\ngcm_polyval_mul : {n} (fin n) => [2 * (1 + n)] -> [2 * (1 + n)] -> [4 * (1 + n)]\ngcm_polyval_mul X Y = (0 : [1]) # pmult X Y\n\ngcm_polyval_red : [256] -> [128]\ngcm_polyval_red X = reverse (pmod (reverse X) <| x^^128 + x^^7 + x^^2 + x + 1|>)\n\ngcm_polyval : [128] -> [128] -> [128]\ngcm_polyval X Y = gcm_polyval_red (gcm_polyval_mul X Y)\n\ngcm_init_H : [128] -> [128]\ngcm_init_H Xi = pmod (Xi # (0 : [1]))  <| 1 + x^^121 + x^^126 + x^^127 + x^^128 |>\n\ntype AES_GCM_Ctx =\n  { key : [32][8]\n  , iv : [12][8]\n  , Xi : [16][8]\n  , len : [64]\n  }\n\nget_H : AES_GCM_Ctx -> [2][64]\nget_H ctx = split (join (aes_hw_encrypt zero ctx.key))\n\nEKi : AES_GCM_Ctx -> [32] -> [16][8]\nEKi ctx i = aes_hw_encrypt (ctx.iv # (split (i + 1))) ctx.key\n\nEKij : AES_GCM_Ctx -> [32] -> [4] -> [8]\nEKij ctx i j = (EKi ctx i) @ j\n\ncipher_update : {n} (fin n) => [32] -> AES_GCM_Ctx -> [n][8] -> AES_GCM_Ctx\ncipher_update enc ctx in = ctx'\n  where\n    enc_bytes = if enc ! 0\n      then ctr32_encrypt ctx in\n      else in\n    ctx' = foldl cipher_update_byte ctx enc_bytes\n\nctr32_encrypt : {n} (fin n) => AES_GCM_Ctx -> [n][8] -> [n][8]\nctr32_encrypt ctx in = out\n  where\n    out = [ byte ^ (EKij ctx ((take`{32} (drop`{28} i)) + 1) (drop`{60} i)) | byte <- in | i <- [ctx.len ...] ]\n\ncipher_update_byte : AES_GCM_Ctx -> [8] -> AES_GCM_Ctx\ncipher_update_byte ctx byte = ctx'\n  where\n    H = join (get_H ctx)\n    n = ctx.len % 16\n    Xi' = update ctx.Xi n ((ctx.Xi @ n) ^ byte)\n    len' = ctx.len + 1\n    Xi'' = if (len' % 16) == 0\n      then split (gcm_pmult_pmod H (join Xi'))\n      else Xi'\n    ctx' =\n      { key = ctx.key\n      , iv = ctx.iv\n      , Xi = Xi''\n      , len = len'\n      }\n\ncipher_final : AES_GCM_Ctx -> [16][8]\ncipher_final ctx = (split (gcm_pmult_pmod H Xi'')) ^ (EKi ctx 0)\n  where\n    H = join (get_H ctx)\n    Xi' = if (ctx.len % 16) != 0\n      then gcm_pmult_pmod H (join ctx.Xi)\n      else join ctx.Xi\n    Xi'' = Xi' ^ (0 # (ctx.len * 8))\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/AES_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Authenticated::AES_GCM that imports the GCM specification and the parameterized AES block cipher. Inside this module, define five properties named testPass0, testPass1, testPass2, testPass3, and testPass4. Each property must invoke the GCM encryption procedure parameterized by key size, IV size, AAD size, and tag size, using the AES block cipher\u2019s encrypt function, and assert equality with an expected result record containing ciphertext and authentication tag. Specify the following cases: (1) AES-128, 96-bit IV, no AAD, 128-bit tag, all-zero key, all-zero IV, empty plaintext and empty AAD, expecting empty ciphertext and a fixed 128-bit tag; (2) AES-128, 96-bit IV, all-zero key, all-zero IV, one 128-bit block of zero plaintext, no AAD, expecting a fixed 128-bit ciphertext and 128-bit tag; (3) AES-128, 96-bit IV, no AAD, multi-block plaintext with fixed nonzero key and IV, expecting fixed ciphertext and 128-bit tag; (4) AES-128, 96-bit IV, 160-bit AAD, fixed nonzero key, IV, plaintext, and AAD, expecting fixed ciphertext and 128-bit tag; (5) AES-256, 96-bit IV, 128-bit AAD, fixed nonzero 256-bit key, fixed IV, and one 128-bit plaintext block, expecting fixed ciphertext and 128-bit tag. Use exact constants from standard AES-GCM test vectors for keys, IVs, plaintexts, AADs, ciphertexts, and tags. Each property must assert that the computed GCM output record equals the expected record."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::AES_GCM where\nimport `Primitive::Symmetric::Cipher::Authenticated::GCM\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\nproperty testPass0 = gcmEnc `{K=128, IV=96, AAD=0, T=128} {E=encrypt} {key=zero, iv=zero, pt=[], aad=[]} ==\n                              {ct = [], tag = 0x58e2fccefa7e3061367f1d57a4e7455a}\n\nproperty testPass1 = gcmEnc `{K=128, IV=96, AAD=0, T=128} {E=encrypt} {key=zero, iv=zero, pt=zero, aad=[]} ==\n                              {ct = 0x0388dace60b6a392f328c2b971b2fe78, tag = 0xab6e47d42cec13bdf53a67b21257bddf}\n\nproperty testPass2 = gcmEnc `{K=128, IV=96, AAD=0, T=128} {E=encrypt} {key=0xfeffe9928665731c6d6a8f9467308308, iv=0xcafebabefacedbaddecaf888,         pt=0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b391aafd255, aad=[]} ==\n    {ct = 0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091473f5985,\n    tag = 0x4d5c2af327cd64a62cf35abd2ba6fab4}\n\nproperty testPass3 = gcmEnc `{K=128, IV=96, AAD=160, T=128} {E=encrypt} {key=0xfeffe9928665731c6d6a8f9467308308,                                            iv=0xcafebabefacedbaddecaf888,\n    pt=0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b39,\n    aad=0xfeedfacedeadbeeffeedfacedeadbeefabaddad2} ==\n    {ct=0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091,\n    tag=0x5bc94fbc3221a5db94fae95ae7121a47}\n\nproperty testPass4 = gcmEnc `{K=256, IV=96, AAD=128, T=128} {E=encrypt} {key=0xeebc1f57487f51921c0465665f8ae6d1658bb26de6f8a069a3520293a572078f,\n    iv=0x99aa3e68ed8173a0eed06684, pt=0xf56e87055bc32d0eeb31b2eacc2bf2a5, aad=0x4d23c3cec334b49bdb370c437fec78de} ==\n   {ct=0xf7264413a84c0e7cd536867eb9f21736, tag=0x67ba0510262ae487d737ee6298f77e0c}\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Authenticated::GCM that contains: (1) a parameter block with type parameters K, IV, AAD, and T, with constraints: K is finite; IV\u2019s bit-width is between 1 and 64; AAD\u2019s bit-width is at most 64; T is an integer with 64 \u2264 T \u2264 128; and a block-cipher parameter E mapping a K-sized key and a 128-bit block to a 128-bit block. (2) A function gcmEnc that, for any finite n with n \u2264 2^39 \u2212 256, takes a record {key:[K], iv:[IV], aad:[AAD], pt:[n]} and returns {ct:[n], tag:[T]}, delegating to enc_dec. (3) A function gcmDec with the same n constraint that takes {key:[K], iv:[IV], aad:[AAD], ct:[n], tag:[T]} and returns {valid:Bool, pt:[n]}, recomputing the tag via enc_dec and outputting the plaintext and valid=True on match, otherwise pt all-zeros and valid=False. (4) A function enc_dec that implements GCM: compute H by encrypting the all-zero 128-bit block; derive Y0 as IV||1 when IV has 96 bits, otherwise as GHASH of empty AAD with the IV; form counters Y1, Y2, \u2026 by incrementing Y0 modulo 2^128; XOR plaintext blocks with E applied to Y1.. to form ciphertext; compute the authentication value as GHASH over AAD and ciphertext, XORed with E applied to Y0; output the leftmost T bits as the tag. (5) GHASH that folds 128-bit blocks of AAD and ciphertext (zero-padded and blockified) using finite-field multiplication by H over GF(2^128). (6) mult that performs GF(2^128) multiplication using polynomial multiplication modulo 1 + x + x^2 + x^7 + x^128 with the specified bit-order convention. (7) blockify to zero-pad and split a finite bitvector into 128-bit blocks; unblockify to join and truncate to the original length. (8) ifWidth to branch based on a constant-width match by passing a resized value to a continuation or returning an alternate value."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM where\n\nparameter\n\n  type K : #\n  type constraint (fin K)\n\n  type IV : #\n  type constraint (64 >= width IV, IV >= 1)\n\n  type AAD  : #\n  type constraint (64 >= width AAD)\n\n  type T : #\n  type constraint (128 >= T, T >= 64)\n\n  E : [K] -> [128] -> [128]\n\ngcmEnc :\n  {n} (2^^39 - 256 >= n) =>\n      { key : [K], iv : [IV], aad : [AAD], pt : [n] } -> { ct : [n], tag : [T] }\ngcmEnc input = { ct = C, tag = T }\n  where (C,T) = enc_dec input.key input.iv input.aad input.pt\n\ngcmDec :\n  {n} (2^^39 - 256 >= n) =>\n  { key : [K], iv  : [IV], aad : [AAD], ct  : [n], tag : [T] } ->\n  { valid : Bool, pt : [n] }\ngcmDec input = if input.tag == T then { valid = True, pt = P }\n                                  else { valid = False, pt = 0 }\n  where (P,T) = enc_dec input.key input.iv input.aad input.ct\n\nenc_dec :\n  {n} ((2^^39 - 256) >= n) => [K] -> [IV] -> [AAD] -> [n] -> ([n], [T])\nenc_dec K IV A P = (C,T)\n  where\n  H  = (E K 0)\n\n  Y0 = ifWidth`{96} IV (\\IV96 -> IV96 # 1)\n                       (GHASH H [] IV)\n\n  Ys = [Y0] # [ y+1 | y <- Ys ]\n\n  Cs = [ p ^ (E K y) | p <- blockify P | y <- drop`{1} Ys ]\n  C  = unblockify Cs\n\n  T = take (GHASH H A C ^ (E K Y0))\n\nGHASH : {C,A} (64 >= width C, 64 >= width A) => [128] -> [A] -> [C] -> [128]\nGHASH H A C = step (XS ! 0) (wa # wc)\n  where\n  wa = `A : [64]\n  wc = `C : [64]\n\n  XS = [0] # [ step X' B | X' <- XS | B <- blockify A # blockify C ]\n\n  step x b = mult (x ^ b) H\n\nmult : [128] -> [128] -> [128]\nmult X Y = reverse (pmod (pmult (reverse X) (reverse Y)) irred)\n  where irred = <| 1 + x + x^^2 + x^^7 + x^^128 |>\n\nblockify : {n} (fin n) => [n] -> [n \/^ 128][128]\nblockify msg = split (msg # 0)\n\nunblockify : {n} (fin n) => [n \/^ 128][128] -> [n]\nunblockify ms = take (join ms)\n\nifWidth : {w,n,a} (fin n, fin w) => [n] -> ([w] -> a) -> a -> a\nifWidth thing yep nope = if `w == (`n : [max (width w) (width n)])\n                            then yep (take (thing # (zero : [inf])))\n                            else nope\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/DES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::DES that contains the following definitions: import the cipher interface module; define a constant with type \u201cCipher 64 64\u201d whose encrypt applies a DES Feistel construction using subkeys derived from a key expansion function, and whose decrypt applies the same rounds with the subkeys in reverse order. Define a function implementing the 16-round Feistel network over 64-bit blocks: apply an initial permutation, iterate rounds over a pair of 32-bit halves, swap the halves, and apply the final permutation. Define a round function with type ([48], [2][32]) -> [64] that returns the right half concatenated with the left half XOR a round function. Define a round function core that takes a 32-bit half and a 48-bit subkey, expands the half to 48 bits, XORs with the subkey, maps through eight S-boxes (6 bits to 4 bits each) to 32 bits, then permutes the result. Define a swap that exchanges two 32-bit halves. Define key expansion: a function from a 64-bit key to sixteen 48-bit subkeys by permuting, splitting into two 28-bit halves, left-rotating per the DES schedule, and compressing to 48 bits. Define a helper that computes cumulative rotation amounts; and a helper that converts 1-based permutation index tables to 0-based, then define zero-based variants of all permutation tables. Provide the standard DES permutation and compression tables and eight S-box tables (each with type [4][16][4]). Define SBox, sbox, and the list of S-box tables. Define a property that decrypt(encrypt(msg)) equals msg for all 64-bit keys and messages. Define constants for example messages, keys, and ciphertexts, and define a property that all listed test vectors pass. Include precise Cryptol type signatures for all functions and constants."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::DES where\n\nimport Primitive::Symmetric::Cipher::Block::Cipher\n\nDES : Cipher 64 64\nDES =\n    { encrypt key pt = des (expandKey key) pt\n    , decrypt key ct = des (reverse (expandKey key)) ct\n    }\n\ndes keys pt = (swap (split lst)) @@ FPz\n  where\n        pt' = pt @@ IPz\n        iv  = [ round (k, split lr)\n              | k  <- keys\n              | lr <- [pt'] # iv ]\n        lst = iv @ (length keys - 1)\n\nround : ([48],[2][32]) -> [64]\nround (k, [l, r]) = r # (l ^ f (r, k))\n\nf (r, k) = (SBox(k ^ (r @@ EPz))) @@ PPz\n\nswap [a, b] = b # a\n\nexpandKey : [64] -> [16][48]\nexpandKey key = expand (split (key @@ KPz))\n\nexpand: [2][28] -> [16][48]\nexpand [kl, kr] =\n    [ ((kl <<< i) # (kr <<< i)) @@ CPz\n    | i <- sums [ 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 ] ]\n\nsums : [16][8] -> [16][8]\nsums xs = ys\n  where ys = [ x + y | x <- xs | y <- [0] # ys ]\n\nzeroBasify XP = [ i - 1 | i <- XP ]\nKPz = zeroBasify KP\nCPz = zeroBasify CP\nPPz = zeroBasify PP\nEPz = zeroBasify EP\nIPz = zeroBasify IP\nFPz = zeroBasify FP\n\nKP : [56][6]\nKP  = [57,49,41,33,25,17, 9, 1,58,50,42,34,26,18,\n       10, 2,59,51,43,35,27,19,11, 3,60,52,44,36,\n       63,55,47,39,31,23,15, 7,62,54,46,38,30,22,\n       14, 6,61,53,45,37,29,21,13, 5,28,20,12, 4\n      ]\n\nCP : [48][6]\nCP  = [14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,\n       23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,\n       41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,\n       44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32\n      ]\n\nPP : [32][6]\nPP = [16,  7, 20, 21, 29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,\n       2,  8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25\n     ]\n\nEP : [48][6]\nEP  = [32,  1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,\n        8,  9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,\n       16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,\n       24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,  1\n      ]\n\nIP : [64][7]\nIP = [58, 50, 42, 34, 26, 18, 10,  2, 60, 52, 44, 36, 28, 20, 12,  4,\n      62, 54, 46, 38, 30, 22, 14,  6, 64, 56, 48, 40, 32, 24, 16,  8,\n      57, 49, 41, 33, 25, 17,  9,  1, 59, 51, 43, 35, 27, 19, 11,  3,\n      61, 53, 45, 37, 29, 21, 13,  5, 63, 55, 47, 39, 31, 23, 15,  7\n     ]\n\nFP : [64][7]\nFP = [40,  8, 48, 16, 56, 24, 64, 32, 39,  7, 47, 15, 55, 23, 63, 31,\n      38,  6, 46, 14, 54, 22, 62, 30, 37,  5, 45, 13, 53, 21, 61, 29,\n      36,  4, 44, 12, 52, 20, 60, 28, 35,  3, 43, 11, 51, 19, 59, 27,\n      34,  2, 42, 10, 50, 18, 58, 26, 33,  1, 41,  9, 49, 17, 57, 25\n     ]\n\nSBox : [48] -> [32]\nSBox x = join [ sbox (n, b) | n <- [1 .. 8] | b <- split x ]\n\nsbox : ([4], [6]) -> [4]\nsbox (n, x) = (s @ [b1, b6] @ [b2, b3, b4, b5])\n  where s = sboxes @ (n - 1)\n        b1 = x @ 0\n        b2 = x @ 1\n        b3 = x @ 2\n        b4 = x @ 3\n        b5 = x @ 4\n        b6 = x @ 5\n\nsboxes = [ sbox1, sbox2, sbox3, sbox4, sbox5, sbox6, sbox7, sbox8 ]\n\nsbox1 : [4][16][4]\nsbox1 = [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],\n         [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],\n         [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],\n         [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]\n        ]\nsbox2 : [4][16][4]\nsbox2 = [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],\n         [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],\n         [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],\n         [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]\n        ]\n\nsbox3 : [4][16][4]\nsbox3 = [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],\n         [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],\n         [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],\n         [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]\n        ]\n\nsbox4 : [4][16][4]\nsbox4 = [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],\n         [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],\n         [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],\n         [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]\n        ]\n\nsbox5 : [4][16][4]\nsbox5 = [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],\n         [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],\n         [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],\n         [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]\n        ]\n\nsbox6 : [4][16][4]\nsbox6 = [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],\n         [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],\n         [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],\n         [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]\n        ]\n\nsbox7 : [4][16][4]\nsbox7 = [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],\n         [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],\n         [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],\n         [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]\n        ]\n\nsbox8 : [4][16][4]\nsbox8 = [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],\n         [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],\n         [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],\n         [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]\n        ]\n\nproperty DESCorrect key msg = DES.decrypt key (DES.encrypt key msg) == msg\n\ntestmsgs = [0x1122334455667788\n           ,0x99aabbccddeeff00\n           ,0x41AD068548809D02\n           ,0xB10F843097A0F932]\n\ntestkeys = [0x752878397493CB70\n          ,0x752878397493CB70\n          ,0x0001020304050607\n          ,0x2BD6459F82C5B300]\n\ntestct = [0xB5219EE81AA7499D\n         ,0x2196687E13973856\n         ,0x0011223344556677\n         ,0xEA024714AD5C4D84]\n\nproperty testsPass = and [ DES.encrypt key msg == ct\n                         | key <- testkeys | msg <- testmsgs | ct <- testct ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/PRINCE.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::PRINCE that contains the following definitions: type aliases for a 64-bit block size, a 128-bit key size, a 4\u00d74\u00d74-bit State (nibbles), and a 4-bit Round index. Define constants for a 4-bit S-box and its inverse (each a 16-entry lookup table), a list of 64-bit round constants (12 entries), two 16-entry permutation tables for row shifting (forward and inverse), linear-layer coefficient vectors, and their derived 4\u00d74 matrices and a 4-element structure for the linear layer. Provide functions: message-to-state and state-to-message converters between 64-bit blocks and the 4\u00d74\u00d74 State; nibble-wise substitution and its inverse over a State; row-shift and its inverse using the permutation tables; two linear transforms over 16-bit rows and a State-level linear layer built from them; a key extension that splits a 128-bit key into two 64-bit halves and derives a 64-bit middle whitening key by a right rotate\/shift\/xor; per-round forward and backward round functions that apply substitution, linear layer, row shift (or its inverse), add round constant indexed by the 4-bit round, and xor a State key; a core function implementing the full PRINCE round structure with initial\/final key and constant additions and a middle involution; an encrypt function that performs key extension, pre-whitening, core, and post-whitening; a decryption key extension that incorporates a fixed 128-bit constant per the PRINCE specification and a decrypt function mirroring encryption. Include wrappers for a 64-bit-key variant (by zero-extending to 128-bit key) and a 128-bit-block variant that returns a 128-bit value by concatenating the 64-bit ciphertext with zeros. Define a property princeCorrect asserting decrypt(encrypt(key, msg)) equals msg for all keys and messages, and a property princeCorrect' for the 64-bit-key variant. Add seven boolean test vectors comparing encryption outputs to known answers and define a property testsPass as their conjunction. Ensure all types conform to the stated sizes."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::PRINCE where\ntype princeBlockSize = 64\ntype princeKeySize = 128\ntype State = [4][4][4]\ntype Round = 4\n\nsbox = [0xb, 0xf, 0x3, 0x2, 0xa, 0xc, 0x9, 0x1, 0x6, 0x7, 0x8, 0x0, 0xe, 0x5, 0xd, 0x4]\nsboxInv = [0xb, 0x7, 0x3, 0x2, 0xf, 0xd, 0x8, 0x9, 0xa, 0x6, 0x4, 0x0, 0x5, 0xe, 0xc, 0x1]\n\nRC = [0x0000000000000000, 0x13198a2e03707344, 0xa4093822299f31d0, 0x082efa98ec4e6c89, 0x452821e638d01377, 0xbe5466cf34e90c6c, 0x7ef84f78fd955cb1, 0x85840851f1ac43aa, 0xc882d32f25323c54, 0x64a51195e0e3610d, 0xd3b5a399ca0c2399, 0xc0ac29b7c97c50dd]\n\nextendKey :[princeKeySize] -> ([64], [64], [64])\nextendKey key = (K!0, K', K!1) \n          where K = split key:[2][64]\n                K' = ((K!0) >>> 1) ^ ((K!0) >> 63)\n\nmsgToState:[princeBlockSize] -> State\nmsgToState msg = split (split msg)\n\nstateToMsg :State -> [princeBlockSize]\nstateToMsg st = join (join st)\n\nSubCell :[4] -> [4]\nSubCell st = sbox@st\n\nSubCells : State -> State\nSubCells st = [ [ SubCell b | b<- row ] | row <- st ]\n\nInvSubCell :[4] -> [4]\nInvSubCell st = sboxInv@st\n\nInvSubCells : State -> State\nInvSubCells st = [ [ InvSubCell b | b<- row ] | row <- st ]\n\nperm  = [0x0, 0x5, 0xa, 0xf, 0x4, 0x9, 0xe, 0x3, 0x8, 0xd, 0x2, 0x7, 0xc, 0x1, 0x6, 0xb]\ninv_perm = [0x0, 0xd, 0xa, 0x7, 0x4, 0x1, 0xe, 0xb, 0x8, 0x5, 0x2, 0xf, 0xc,0x9, 0x6, 0x3]\n\nShiftRows : State -> State\nShiftRows state = split [State_16@i\n                  | i <-  perm]\n                where State_16 = join state\nInvShiftRows : State -> State\nInvShiftRows state = split [State_16@i\n                  | i <-  inv_perm]\n                where State_16 = join state\n\nm0 = [ 0x0, 0x4, 0x2, 0x1]\nm1 = [ 0x8, 0x0, 0x2, 0x1]\nm2 = [ 0x8, 0x4, 0x0, 0x1]\nm3 = [ 0x8, 0x4, 0x2, 0x0]\n\nM0 = [ [m0, m1, m2, m3], [m1, m2, m3, m0], [m2, m3, m0, m1], [m3, m0, m1, m2] ]\nM1 = [ [m1, m2, m3, m0], [m2, m3, m0, m1], [m3, m0, m1, m2], [m0, m1, m2, m3] ]\n\nM' = [ M0, M1, M1, M0]\n\n\/\/ m0\n\ndefm1 : [16] -> [16]\ndefm1 st = res \n where  res = b15 # b14 # b13 # b12 # b11 # b10 # b9 # b8 # b7 # b6 # b5 # b4 # b3 # b2 # b1 # b0\n        b0 = [st!4 ^ st!8 ^ st!12]\n        b1 = [st!1 ^ st!9 ^ st!13]\n        b2 = [st!2 ^ st!6 ^ st!14]\n        b3 = [st!3 ^ st!7 ^ st!11]\n        b4 = [st!0 ^ st!4 ^ st!8]\n        b5 = [st!5 ^ st!9 ^ st!13]\n        b6 = [st!2 ^ st!10 ^ st!14]\n        b7 = [st!3 ^ st!7 ^ st!15]\n        b8 = [st!0 ^ st!4 ^ st!12]\n        b9 = [st!1 ^ st!5 ^ st!9]\n        b10 = [st!6 ^ st!10 ^ st!14]\n        b11 = [st!3 ^ st!11 ^ st!15]\n        b12 = [st!0 ^ st!8 ^ st!12]\n        b13 = [st!1 ^ st!5 ^ st!13]\n        b14 = [st!2 ^ st!6 ^ st!10]\n        b15 = [st!7 ^ st!11 ^ st!15]\n\n\/\/ m1\n\ndefm0 : [16] -> [16]\ndefm0 st = res\n  where res = b15 # b14 # b13 # b12 # b11 # b10 # b9 # b8 # b7 # b6 # b5 # b4 # b3 # b2 # b1 # b0\n        b0 = [st!0 ^ st!4 ^ st!8]\n        b1 = [st!5 ^ st!9 ^ st!13]\n        b2 = [st!2 ^ st!10 ^ st!14]\n        b3 = [st!3 ^ st!7 ^ st!15]\n        b4 = [st!0 ^ st!4 ^ st!12]\n        b5 = [st!1 ^ st!5 ^ st!9]\n        b6 = [st!6 ^ st!10 ^ st!14]\n        b7 = [st!3 ^ st!11 ^ st!15]\n        b8 = [st!0 ^ st!8 ^ st!12]\n        b9 = [st!1 ^ st!5 ^ st!13]\n        b10 = [st!2 ^ st!6 ^ st!10]\n        b11 = [st!7 ^ st!11 ^ st!15]\n        b12 = [st!4 ^ st!8 ^ st!12]\n        b13 = [st!1 ^ st!9 ^ st!13]\n        b14 = [st!2 ^ st!6 ^ st!14]\n        b15 = [st!3 ^ st!7 ^ st!11]\n\n\/\/ M'\n\ndefMPrime: State -> State\ndefMPrime st = [rt3] # [rt2] # [rt1] # [rt0]\n      where rt0 = split (defm0 (join (st!0))):[4][4]\n            rt1 = split (defm1 (join (st!1))):[4][4]\n            rt2 = split (defm1 (join (st!2))):[4][4]\n            rt3 = split (defm0 (join (st!3))):[4][4]\n\nfirstRounds : State -> State -> [Round] -> State\nfirstRounds pt key r = res\n           where   pt' =  SubCells(pt)\n                   pt'' = defMPrime (pt')\n                   pt''' = ShiftRows (pt'')\n                   res = pt''' ^ (split (split (RC@r))) ^ key\n\nlastRounds : State -> State -> [Round] -> State\nlastRounds pt key r = res\n           where   pt' =  pt ^ key ^ (split (split (RC@r)))\n                   pt'' = InvShiftRows( pt')\n                   pt''' = defMPrime (pt'')\n                   res = InvSubCells (pt''')\n\nprinceCore : State -> State -> State\nprinceCore pt key  = addRC11\n           where addRC0 = pt ^ key ^ (split (split (RC@0)))\n                 firstR = [(firstRounds addRC0 key 1)] # [ (firstRounds res key i)\n                                                         | i <- [2,3..5]\n                                                         | res <- firstR\n                                                         ]\n                 subSbox = SubCells (firstR!0)\n                 linLayer = defMPrime (subSbox)\n                 subInvSbox = InvSubCells (linLayer)\n                 lastR = [(lastRounds subInvSbox  key 6) ] # [ (lastRounds res key i)\n                                                             | i <- [7,8..10]\n                                                             | res <- lastR\n                                                             ]\n                 addRC11 = (lastR!0) ^ key^ (split (split (RC@11)))\n\nprinceEncrypt : ([princeKeySize], [princeBlockSize]) -> [princeBlockSize]\nprinceEncrypt (key, pt) =  stateToMsg postWhiten\n            where  extk = extendKey (key)\n                   preWhiten = msgToState(pt) ^ msgToState (extk.0)\n                   coreEnc =  (princeCore preWhiten (msgToState (extk.2)))\n                   postWhiten = coreEnc ^ (msgToState (extk.1))\n\nextendKeyDec :[princeKeySize] -> ([64], [64], [64])\nextendKeyDec key = (K', K!0, K!1) \n          where K = split key:[2][64]\n                K' = ((K!0) >>> 1) ^ ((K!0) >> 63)\n\nprinceDecrypt : ([princeKeySize], [princeBlockSize]) -> [princeBlockSize]\nprinceDecrypt ( key, ct) = stateToMsg postWhiten\n            where alpha_padd = join((split(key):[32][4])^ (split (0xc0ac29b7c97c50dd0000000000000000):[32][4]))\n                  extk = extendKeyDec alpha_padd \n                  preWhiten = msgToState(ct) ^ msgToState (extk.0)\n                  coreEnc =  (princeCore preWhiten (msgToState (extk.2)))\n                  postWhiten = coreEnc ^ (msgToState (extk.1))\n\nproperty princeCorrect key m = princeDecrypt ( key, princeEncrypt(key, m)) == m\n\nprinceEncrypt64 : ([princeBlockSize], [princeBlockSize]) -> [princeBlockSize]\nprinceEncrypt64 (key, pt) = princeEncrypt(key#zero, pt)\n\nprinceDecrypt64 : ([princeBlockSize], [princeBlockSize]) -> [princeBlockSize]\nprinceDecrypt64 (key, ct) = princeDecrypt(key#zero, ct)\n\nproperty princeCorrect' key m = princeDecrypt64 (key, princeEncrypt64 (key, m)) == m\n\nprinceEncrypt128 : ([princeKeySize], [princeKeySize]) -> [princeKeySize]\nprinceEncrypt128 (key, pt) = princeEncrypt(key, (take`{64} pt))# zero\n\n\/\/ Testing\n\ntests = [t01, t02, t03, t04, t05, t06, t07]\nproperty testsPass = and tests\n\nt01 = princeEncrypt (zero, zero) == 0x818665aa0d02dfda\n\nt02 = princeEncrypt (zero, 0xffffffffffffffff) == 0x604ae6ca03c20ada\n\nt03 = princeEncrypt ( 0xffffffffffffffff0000000000000000, zero) == 0x78a54cbe737bb7ef\n\nt04 = princeEncrypt (0xffffffffffffffffffffffffffffffff, zero) == 0xb9f952807615743f\n\nt05 = princeEncrypt (0x0000000000000000ffffffffffffffff, zero) == 0x9fb51935fc3df524\n\nt06 = princeEncrypt (0x0000000000000000fedcba9876543210, 0x0123456789abcdef) == 0x1f24bb8638e813d3\n\nt07 = princeEncrypt (0xfedcba98765432100000000000000000, 0x0123456789abcdef) == 0xae25ad3ca8fa9ccf\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES_parameterized.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::AES_parameterized that contains the following: (1) An import of the AES algorithm module (aliased), the key expansion utilities, and the T-box round functions used for AES forward and inverse rounds. (2) A type constraint ValidKey k m requiring that the key width k equals 128 + 64\u00b7m and that m is at most 2. (3) Type synonyms EncKey m and DecKey m, both equal to the AES key schedule type indexed by m. (4) A function encrypt with a polymorphic type over k and m under ValidKey k m, taking a k-bit key and a 128-bit block and returning a 128-bit block; implement it by expanding the encryption key using Nk=Nk(m) and Nr=Nr(m) from the AES module, then encrypting with AES::encrypt parameterized by a record of round functions. (5) A function decrypt with the same polymorphic constraints and I\/O widths that expands a decryption schedule (derived from the encryption schedule via makeDecKey) and calls AES::decrypt with the same round-function parameters. (6) Helper functions: expandKeyEnc (produces EncKey m from a k-bit key), expandKeyDec (produces DecKey m by transforming the expanded encryption schedule), encryptWithSchedule (encrypts a 128-bit block using EncKey m), and decryptWithSchedule (decrypts using DecKey m). (7) A constant params record binding encRound to the forward AES round and decRound to the inverse AES round from the T-box module. (8) A property named test asserting that for any well-typed key and 128-bit plaintext, decrypt(key, encrypt(key, plaintext)) equals the plaintext."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES_parameterized where\n\nimport `Primitive::Symmetric::Cipher::Block::AES::Algorithm as AES\nimport `Primitive::Symmetric::Cipher::Block::AES::ExpandKey\nimport Primitive::Symmetric::Cipher::Block::AES::TBox\n\ntype constraint ValidKey k m = (k == 128 + m * 64, 2 >= m)\n\ntype EncKey m = AES::KeySchedule m\ntype DecKey m = AES::KeySchedule m\n\nencrypt : {k,m} ValidKey k m => [k] -> [128] -> [128]\nencrypt k = encryptWithSchedule (expandKeyEnc k)\n\ndecrypt : {k,m} ValidKey k m => [k] -> [128] -> [128]\ndecrypt k = decryptWithSchedule (expandKeyDec k)\n\nexpandKeyEnc : {k,m} ValidKey k m => [k] -> EncKey m\nexpandKeyEnc = expandKey`{Nk = AES::Nk m, Nr = AES::Nr m}\n\nencryptWithSchedule : {k,m} ValidKey k m => EncKey m -> [128] -> [128]\nencryptWithSchedule = AES::encrypt params\n\nexpandKeyDec : {k,m} ValidKey k m => [k] -> EncKey m\nexpandKeyDec k = makeDecKey (expandKey`{Nk = AES::Nk m, Nr = AES::Nr m} k)\n\ndecryptWithSchedule : {k,m} ValidKey k m => DecKey m -> [128] -> [128]\ndecryptWithSchedule = AES::decrypt params\n\nparams = { encRound = AESRound, decRound = AESInvRound }\n\nproperty test k pt = decrypt k (encrypt k pt) == pt\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AESKeyWrapPadded.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::AESKeyWrapPadded that imports the AES and AES Key Wrap modules and contains these definitions:\n- A constant AlternativeIV of type 4 bytes set to the RFC 5649 alternative IV value (A6 59 59 A6).\n- A function padPlaintext with size parameters n and m, under constraints that n is finite, m \u2264 7, and n+m is a multiple of 8. It takes n bytes and returns n+m bytes by appending exactly m zero bytes.\n- A function aesWrapKeyPadded with size parameters n and m, under constraints n \u2265 1, n < 2^32, m \u2264 7, and n+m is a multiple of 8. It takes an AES key, a 4-byte IV, and n-byte plaintext, and returns n+m+8 bytes. Semantics: compute P = padPlaintext(plaintext); form AIV = IV concatenated with the big-endian 32-bit encoding of n; if n \u2264 8, perform AES-ECB encryption of the 16-byte block AIV||P and append zeros to reach n+m+8 bytes; otherwise, call the standard AES Key Wrap using AIV on P zero-extended to at least 16 bytes and sized for n+m, and return the wrapped result.\n- A function aesUnwrapKeyPadded with size parameter n, under constraints fin n, n \u2265 16, n mod 8 = 0, and width n \u2264 32. It takes an AES key, a 4-byte IV, and n-byte ciphertext, and returns (valid, size, P) where valid is a Bit, size is 4 bytes, and P is n\u22128 bytes. Semantics: if n = 16, AES-ECB decrypt the single block and append zeros to reach n bytes; else, call AES Key Unwrap (unchecked) on the ciphertext zero-extended as needed, then parse iv\u2032, size, and P. Set valid iff iv\u2032 equals the supplied IV, the decoded 32-bit size satisfies n\u221216 < size \u2264 n\u22128, and all bytes in P beyond index size are zero. On invalid, return False with zeroed size and P."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AESKeyWrapPadded where\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Block::AESKeyWrap\n\nAlternativeIV : [4][8]\nAlternativeIV = [0xA6, 0x59, 0x59, 0xA6]\n\npadPlaintext : {n, m} (fin n, (n+m) % 8 == 0, m <= 7) => [n][8] -> [n + m][8]\npadPlaintext p = p # zero\n\naesWrapKeyPadded : {n, m} (n >= 1 , n < 2^^32 , (n+m) % 8 == 0 , m <= 7) =>\n                   [AESKeySize] -> [4][8] -> [n][8] -> [n+m+8][8]\naesWrapKeyPadded key iv plaintext =\n  if `n <= 8\n        then (split (aesEncrypt (drop (join (AIV # P)), key))) # zero\n          else drop (aesWrapKey key AIV ((P # zero) : [max 16 (n+m)][8]))\n  where\n        P = padPlaintext`{n, m} plaintext\n        AIV = iv # (split`{4,8} (`n : [32]))\n\naesUnwrapKeyPadded : {n} (fin n, n >= 16, n % 8 == 0, width n <= 32) =>\n                     [AESKeySize] -> [4][8] -> [n][8] -> (Bit, [4][8], [n-8][8])\naesUnwrapKeyPadded key iv ciphertext = if valid\n                                       then (True, size, P)\n                                       else (False, zero, zero)\n  where\n    S : [n][8]\n    S = if `n == 16\n                                        then (split (aesDecrypt (drop (join ciphertext), key))) # zero\n                                        else drop (split`{each=8} (join (([A'] # R'))))\n          where\n            (A', R') = aesUnwrapKeyUnchecked key ((ciphertext # zero) : [max 24 n][8])\n                iv' : [4][8]\n    size : [4][8]\n    P : [n-8][8]\n    iv' # size # P = S\n        valid =\n            (iv' == iv) &&\n      \/\/ n - 16 < size <= n - 8\n      (((`n : [32]) - 16) < (join size)) &&\n      ((join size) <= ((`n : [32]) - 8)) &&\n      \/\/ All bytes of the padding must be zeros\n      and [(i < (join size)) || (x == zero) | x <- P | i <- [0...]]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/LED.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::LED that contains the following definitions, types, and properties mirroring the described behavior: (1) Type aliases for a 4-bit GF(2^4) element, a 4x4 state matrix of such elements, 64- and 128-bit key sizes, a 64-bit block size, a 6-bit round index, the number of steps (8) and derived round count, and a small index size. (2) A polymorphic vector-sum function over GF(2^4) (with fin constraints) implementing field addition; a degree-4 irreducible polynomial x^4 + x + 1; field multiplication as polynomial product reduced modulo that polynomial; exponentiation by a 4-bit exponent via square-and-multiply; and multiplicative inverse as exponentiation to 14. (3) Polymorphic dot product, vector-by-matrix, and matrix-by-matrix multiplication over GF(2^4). (4) A 16-entry substitution table over GF(2^4). (5) Conversions between a 64-bit message and the 4x4 state by splitting\/joining 4-bit nibbles in row-major order; splitting a 128-bit key into two state halves. (6) Round-key XOR on states; a 48x8-bit round-constant table; helpers to build per-round constant states for 64- and 128-bit keys from a 6-bit round index by selecting indexed bits and embedding fixed column constants; and functions that XOR these constants into a state. (7) Bytewise S-box on a state; row shifts by offsets 0..3 and their inverse; a fixed 4x4 MDS matrix; and MixColumns as state column multiplication by that matrix. (8) One-round transforms (64- and 128-bit) composing add-constant, S-box, row shift, and column mix; four-round wrappers applying rounds for indices 4\u00b7step..4\u00b7step+3. (9) Block ciphers: 64-bit-key\/64-bit-block and 128-bit-key\/64-bit-block encryptions performing an initial state XOR with the appropriate key state, then a sequence of eight or twelve four-round groups with alternating key states, finishing with a final key XOR, returning a 64-bit ciphertext. Include two API adapters that pad\/truncate to reuse the 128-bit-key core. (10) A property stating that any GF(2^4) element XORed with itself is zero. (11) Properties asserting known-answer tests for the 64-bit-key and 128-bit-key encryptions on all-zero inputs and a standard incremental pattern, plus a property that conjoins all tests. Provide precise type signatures with necessary fin constraints."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::LED where\n\ntype GF24 = [4]\ntype State = [4][4]GF24\n\ntype LEDKeySize64 = 64\ntype LEDKeySize128 = 128\ntype LEDBlockSize = 64\ntype Rn = [6]\ntype steps = 8 \ntype Nr = steps*4\n\ntype Ns = 8\n\ngf24Add : {n} (fin n) => [n]GF24 -> GF24\ngf24Add ps = sums ! 0\n      where sums = [zero] # [p^s | p <- ps | s <- sums]\nirreducible = <| x^^4 + x + 1 |>\n\ngf24Mult : (GF24, GF24) -> GF24\ngf24Mult (x , y) = pmod (pmult x y) irreducible\n\ngf24Pow : (GF24, [4]) -> GF24\ngf24Pow (n , k) = pow k\n        where sq x = gf24Mult (x, x)\n              odd x = x ! 0\n              pow i = if i == 0 then 1\n                      else if odd i\n                           then gf24Mult(n, sq (pow (i >> 1)))\n                           else sq (pow (i >> 1))\n\npolySelfAdd' : GF24 -> Bit\nproperty polySelfAdd' x = x ^ x == zero\n\ngf24Inverse : GF24 -> GF24\ngf24Inverse x = gf24Pow (x, 14)\n\ngf24DotProduct : {n} (fin n) => ([n]GF24, [n]GF24) -> GF24\ngf24DotProduct  (xs, ys) = gf24Add [ gf24Mult (x, y) | x <- xs\n                                                     | y <- ys ]\n\ngf24VectorMult : {n, m} (fin n) => ([n]GF24, [m][n]GF24) -> [m]GF24\ngf24VectorMult (v, ms) = [ gf24DotProduct(v, m) | m <- ms ]\n\ngf24MatrixMult : {n, m, k} (fin m) => ([n][m]GF24, [m][k]GF24) -> [n][k]GF24\ngf24MatrixMult (xss, yss) = [ gf24VectorMult(xs, yss') | xs <- xss ]\n   where yss' = transpose yss\n\nsbox : [16] GF24\n\nsbox = [0xc, 0x5, 0x6, 0xb, 0x9, 0x0, 0xa, 0xd, 0x3, 0xe, 0xf, 0x8, 0x4, 0x7, 0x1, 0x2]\n\nmsgToState : [64] -> State\nmsgToState msg = split (split msg)\n\nstateToMsg : State -> [64]\nstateToMsg st = join (join st)\n\nsplitKey1 : [128] -> State\nsplitKey1  key =  msgToState(seed@0)\n          where seed : [2][64]\n                seed = split(key)\n\nsplitKey2 : [128] -> State\nsplitKey2  key =  msgToState(seed@1)\n          where seed : [2][64]\n                seed = split(key)\n\nAddRoundKey: (State, State) -> State\nAddRoundKey (rk , s) = rk^s\n\nrcTab : [48][8]\nrcTab = [0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3E, \n                    0x3D, 0x3B, 0x37, 0x2F, 0x1E, 0x3C, 0x39,\n                    0x33, 0x27, 0x0E, 0x1D, 0x3A, 0x35, 0x2B,\n                    0x16, 0x2C, 0x18, 0x30, 0x21, 0x02, 0x05,\n                    0x0B, 0x17, 0x2E, 0x1C, 0x38, 0x31, 0x23,\n                    0x06, 0x0D, 0x1B, 0x36, 0x2D, 0x1A, 0x34,\n                    0x29, 0x12, 0x24, 0x08, 0x11, 0x22, 0x04]\n\naddConst64 : Rn -> State\naddConst128 : Rn -> State\n\naddConst128 rn  = [[ 8, rcpad(rcTab, rn, [5, 4, 3]) , 0, 0], [9, rcpad(rcTab, rn, [2, 1, 0]) , 0, 0], [2, rcpad(rcTab, rn, [5, 4, 3]), 0, 0], [3, rcpad(rcTab, rn, [2, 1, 0]), 0, 0]] \n\naddConst64 rn  =[[ 4, rcpad(rcTab, rn, [5, 4, 3]) , 0, 0], [5, rcpad(rcTab, rn, [2, 1, 0]) , 0, 0], [2, rcpad(rcTab, rn, [5, 4, 3]), 0, 0], [3, rcpad(rcTab, rn, [2, 1, 0]), 0, 0]] \n\nrcpad : ([48][8], Rn, [3][3]) -> GF24\nrcpad (rct, rn, indcs) = (0b0 # ((rct @ rn):[8]) !! indcs)\n\nAddConst64 : (Rn, State) -> State\nAddConst64 (rn, st) = st ^ (addConst64 rn)\n\nAddConst128 : (Rn, State) -> State\nAddConst128 (rn, st) = st ^ (addConst128 rn)\n\nSubCell : GF24 -> GF24\nSubCell b = sbox @ b\n\nSubCells : State -> State\nSubCells state = [ [SubCell b | b <- row] | row <- state]\n\nShiftRows : State -> State\nShiftRows state = [ row <<< shiftAmount | row <- state\n                                        | shiftAmount <- [0..3]\n                  ]\n\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> shiftAmount | row <- state\n                                           | shiftAmount <- [0 .. 3]\n                     ]\nMDS : State\n\nMDS = [ [ 0x4, 0x1, 0x2, 0x2],\n            [ 0x8, 0x6, 0x5, 0x6],\n            [ 0xB, 0xE, 0xA, 0x9],\n            [ 0x2, 0x2, 0xF, 0xB] ]\n\nMixColumns : State -> State\nMixColumns state = transpose [gf24VectorMult (row, MDS)| row <- state']\n           where state' = transpose state\n\nroundXform64 : (Rn, State) -> State\nroundXform64 (rn, st) = MixColumns (ShiftRows( SubCells (AddConst64 (rn, st))))\n\nfourRoundXform64 : ([6], State) -> State\nfourRoundXform64 (stp, st) = roundXform64 ((4*stp+3), (roundXform64 ((4*stp+2), (roundXform64 ((4*stp+1), (roundXform64 ((4*stp+0), st)))))))\n\nroundXform128 : (Rn, State) -> State\nroundXform128 (rn, st) = MixColumns (ShiftRows( SubCells (AddConst128 (rn, st))))\n\nfourRoundXform128 : ([6], State) -> State\nfourRoundXform128 (stp, st) = roundXform128 ((4*stp+3), (roundXform128 ((4*stp+2), (roundXform128 ((4*stp+1), (roundXform128 ((4*stp+0), st)))))))\n\nledEncrypt64 : ([LEDKeySize64], [LEDBlockSize])  -> [LEDBlockSize]\nledEncrypt64 (key, pt) = stateToMsg(addrk8)\n              where pt_st = msgToState(pt)\n                    key_st1 =  msgToState(key)\n                    key_st2 = msgToState(key)\n                    addrk0 = (AddRoundKey(pt_st, key_st1))\n                    step0 = (fourRoundXform64 (0, addrk0))        \n                    addrk1 = (AddRoundKey(step0, key_st2))\n                    step1 = (fourRoundXform64 (1, addrk1))\n                    addrk2 = (AddRoundKey(step1, key_st1))\n                    step2 = (fourRoundXform64 (2, addrk2))\n                    addrk3 = (AddRoundKey(step2, key_st2))\n                    step3 = (fourRoundXform64 (3, addrk3))\n                    addrk4 = (AddRoundKey(step3, key_st1))\n                    step4 = (fourRoundXform64 (4, addrk4))\n                    addrk5 = (AddRoundKey(step4, key_st2))\n                    step5 = (fourRoundXform64 (5, addrk5))\n                    addrk6 = (AddRoundKey(step5, key_st1))\n                    step6 = (fourRoundXform64 (6, addrk6))\n                    addrk7 = (AddRoundKey(step6, key_st2))\n                    step7 = (fourRoundXform64 (7, addrk7))\n                    addrk8 = (AddRoundKey(step7, key_st1))\n\nledEncrypt128 : ([LEDKeySize128], [LEDBlockSize])  -> [LEDBlockSize]\nledEncrypt128 ( key, pt) = stateToMsg(addrk12)\n              where pt_st = msgToState(pt)\n\n                    key_st1 = splitKey1(key)\n                    key_st2 = splitKey2(key)\n                    addrk0 = (AddRoundKey(pt_st, key_st1))\n                    step0 = (fourRoundXform128 (0, addrk0))        \n                    addrk1 = (AddRoundKey(step0, key_st2))\n                    step1 = (fourRoundXform128 (1, addrk1))\n                    addrk2 = (AddRoundKey(step1, key_st1))\n                    step2 = (fourRoundXform128 (2, addrk2))\n                    addrk3 = (AddRoundKey(step2, key_st2))\n                    step3 = (fourRoundXform128 (3, addrk3))\n                    addrk4 = (AddRoundKey(step3, key_st1))\n                    step4 = (fourRoundXform128 (4, addrk4))\n                    addrk5 = (AddRoundKey(step4, key_st2))\n                    step5 = (fourRoundXform128 (5, addrk5))\n                    addrk6 = (AddRoundKey(step5, key_st1))\n                    step6 = (fourRoundXform128 (6, addrk6))\n                    addrk7 = (AddRoundKey(step6, key_st2))\n                    step7 = (fourRoundXform128 (7, addrk7))\n                    addrk8 = (AddRoundKey(step7, key_st1))\n                    step8 = (fourRoundXform128 (8, addrk8))\n                    addrk9 = (AddRoundKey(step8, key_st2))\n                    step9 = (fourRoundXform128 (9, addrk9))\n                    addrk10 = (AddRoundKey(step9, key_st1))\n                    step10 = (fourRoundXform128 (10, addrk10))\n                    addrk11 = (AddRoundKey(step10, key_st2))\n                    step11 = (fourRoundXform128 (11, addrk11))\n                    addrk12 = (AddRoundKey(step11, key_st1))\n\nledEncrypt64' : ([LEDBlockSize], [LEDBlockSize]) -> [LEDBlockSize]\nledEncrypt64' (key, pt) = ledEncrypt128 (key#zero, pt)\n\nledEncrypt128' : ([LEDKeySize128], [LEDKeySize128]) -> [LEDKeySize128]\nledEncrypt128' (key, pt) = ledEncrypt128(key, (take`{64} pt))# zero\n\ntests = [test64_1, test64_2, test128_1, test128_2]\nproperty testsPass = and tests\n\nproperty test64_1  = ledEncrypt64 (zero, zero) == 0x39c2401003a0c798\nproperty test64_2 = ledEncrypt64 (0x0123456789abcdef, 0x0123456789abcdef) == 0xa003551e3893fc58\n\nproperty test128_1 = ledEncrypt128 (zero, zero) == 0x3decb2a0850cdba1\nproperty test128_2 = ledEncrypt128 (0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0xd6b824587f014fc2\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/simon.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::simon that contains the following definitions: (1) Round functions R and R' over n-bit words operating on a pair (x, y) with a round key, where R maps to (y XOR f(x) XOR k, x) and R' is its inverse using f(y); helper f computes a combination of circular left shifts by 1, 8, and 2 with bitwise AND and XOR. (2) A generic encrypt function and a generic decrypt function with type parameters {n, m, T, j} and constraints fin n, fin m, fin T, fin j, n >= 2, m <= 4, T >= 4, and T-1 >= m; both take a key as a sequence of m n-bit words and a block as a pair of n-bit words, and return a pair of n-bit words; encryption applies T rounds using R and a round-key schedule; decryption applies the inverse schedule with R'. (3) A key-schedule function expandKey : [m][n] -> [T][n] under the same constraints, producing T round keys via a recurrence that uses prior words, circular right shifts by 3 and 1, optional inclusion of the word i-3 when m == 4, bitwise complement, XOR with a round constant bit z from a fixed table, and addition of a small constant; the round-constant bit is selected from a constant Z using parameter j and index (i - m) modulo 62. (4) A constant Z containing five sequences of 62 booleans for the Simon round constants. (5) Specialized encrypt wrappers and matching decrypt wrappers for standard Simon parameter sets, and boolean properties named to check that, for selected variants, decryption inverts encryption on all keys and blocks. (6) Boolean properties for each variant that assert key expansion uniqueness: unequal keys imply unequal expanded key sequences. (7) Boolean test-vector predicates for standard keys\/blocks\/ciphertexts, a list collecting them, and a property asserting their conjunction."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::simon where\n\nSimon32_64    = encrypt `{n=16,m=4,T=32,j=0}\nSimon48_72    = encrypt `{n=24,m=3,T=36,j=0}\nSimon48_96    = encrypt `{n=24,m=4,T=36,j=1}\nSimon64_96    = encrypt `{n=32,m=3,T=42,j=2}\nSimon64_128   = encrypt `{n=32,m=4,T=44,j=3}\nSimon96_96    = encrypt `{n=48,m=2,T=52,j=2}\nSimon96_144   = encrypt `{n=48,m=3,T=54,j=3}\nSimon128_128  = encrypt `{n=64,m=2,T=68,j=2}\nSimon128_192  = encrypt `{n=64,m=3,T=69,j=3}\nSimon128_256  = encrypt `{n=64,m=4,T=72,j=4}\n\nSimon32_64'   = decrypt `{n=16,m=4,T=32,j=0}\nSimon48_72'   = decrypt `{n=24,m=3,T=36,j=0}\nSimon48_96'   = decrypt `{n=24,m=4,T=36,j=1}\nSimon64_96'   = decrypt `{n=32,m=3,T=42,j=2}\nSimon64_128'  = decrypt `{n=32,m=4,T=44,j=3}\nSimon96_96'   = decrypt `{n=48,m=2,T=52,j=2}\nSimon96_144'  = decrypt `{n=48,m=3,T=54,j=3}\nSimon128_128' = decrypt `{n=64,m=2,T=68,j=2}\nSimon128_192' = decrypt `{n=64,m=3,T=69,j=3}\nSimon128_256' = decrypt `{n=64,m=4,T=72,j=4}\n\nproperty correctSimon32_64 k b   = Simon32_64' k (Simon32_64 k b) == b\nproperty correctSimon64_96 k b   = Simon64_96' k (Simon64_96 k b) == b\nproperty correctSimon96_144 k b  = Simon96_144' k (Simon96_144 k b) == b\nproperty correctSimon128_128 k b = Simon128_128' k (Simon128_128 k b) == b\nproperty correctSimon128_256 k b = Simon128_256' k (Simon128_256 k b) == b\n\nproperty uniqueExpandSimon32_64 k1 k2 = (k1 == k2) || (expandKey `{n=16,m=4,T=32,j=0} k1 != expandKey `{n=16,m=4,T=32,j=0} k2)\nproperty uniqueExpandSimon48_72 k1 k2 = (k1 == k2) || (expandKey `{n=24,m=3,T=36,j=0} k1 != expandKey `{n=24,m=3,T=36,j=0} k2)\nproperty uniqueExpandSimon48_96 k1 k2 = (k1 == k2) || (expandKey `{n=24,m=4,T=36,j=1} k1 != expandKey `{n=24,m=4,T=36,j=1} k2)\nproperty uniqueExpandSimon64_96 k1 k2 = (k1 == k2) || (expandKey `{n=32,m=3,T=42,j=2} k1 != expandKey `{n=32,m=3,T=42,j=2} k2)\nproperty uniqueExpandSimon64_128 k1 k2 = (k1 == k2) || (expandKey `{n=32,m=4,T=44,j=3} k1 != expandKey `{n=32,m=4,T=44,j=3} k2)\nproperty uniqueExpandSimon96_96 k1 k2 = (k1 == k2) || (expandKey `{n=48,m=2,T=52,j=2} k1 != expandKey `{n=48,m=2,T=52,j=2} k2)\nproperty uniqueExpandSimon96_144 k1 k2 = (k1 == k2) || (expandKey `{n=48,m=3,T=54,j=3} k1 != expandKey `{n=48,m=3,T=54,j=3} k2)\nproperty uniqueExpandSimon128_128 k1 k2 = (k1 == k2) || (expandKey `{n=64,m=2,T=68,j=2} k1 != expandKey `{n=64,m=2,T=68,j=2} k2)\nproperty uniqueExpandSimon128_192 k1 k2 = (k1 == k2) || (expandKey `{n=64,m=3,T=69,j=3} k1 != expandKey `{n=64,m=3,T=69,j=3} k2)\nproperty uniqueExpandSimon128_256 k1 k2 = (k1 == k2) || (expandKey `{n=64,m=4,T=72,j=4} k1 != expandKey `{n=64,m=4,T=72,j=4} k2)\n\n\/\/ A weak key theorem would look something like:\n\/\/ :prove exists (\\k1 -> exists (\\k2 -> forall (\\x -> Simon32_64 k1 (Simon32_64 k2 x) != x)))\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ round function\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nR k (x, y) = (y ^ f x ^ k, x)\n\n\/\/ inverse\nR' k (x, y) = (y, x ^ f y ^ k)\n\nf x = ((x <<< 1) && (x <<< 8)) ^ (x <<< 2)\n\nencrypt : {n, m, T, j}\n    ( fin n, fin m, fin T, fin j\n    , n >= 2, 4 >= m, T >= 4, T-1 >= m\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\nencrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [ R k b | b <- bs | k <- ks ]\n    ks = expandKey `{n=n,m=m,T=T,j=j} (reverse k0)\n\ndecrypt : {n, m, T, j}\n    ( fin n, fin m, fin T, fin j\n    , n >= 2, 4 >= m, T >= 4, T-1 >= m\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\ndecrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [ R' k b | b <- bs | k <- reverse ks ]\n    ks = expandKey `{n=n,m=m,T=T,j=j} (reverse k0)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ key expansion\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nexpandKey : {n, m, T, j}\n    ( fin n, fin m, fin T, fin j\n    , n >= 2, 4 >= m, T >= 4, T-1 >= m\n    ) => [m][n] -> [T][n]\nexpandKey k0 = k\n  where\n    k = k0 # [ r where\n                    o = k @ (i - 1) >>> 3\n                    p = if `m == 4 then o ^ k @ (i - 3) else o\n                    q = p ^ p >>> 1\n                    r = ~ k @ (i - `m) ^ q ^ z ^ 3\n                    z = Z @ `j @ ((i - `m) % 62)\n             | i <- [m .. T - 1]\n             ]\n\n\/\/ TODO specify how Z is constructed\nZ = [[1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0,\n      0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1,\n      0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0],\n     [1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0,\n      0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1,\n      0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0],\n     [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,\n      0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1,\n      1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1],\n     [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1,\n      0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0,\n      0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1],\n     [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1,\n      1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1,\n      0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1]]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ tests\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\ntests = [t01,t02,t03,t04,t05,t06,t07,t08,t09]\nproperty testsPass = and tests\n\nt00 = Simon32_64   [0x1918, 0x1110, 0x0908, 0x0100] (0x6565, 0x6877) == (0xc69b, 0xe9bb)\nt01 = Simon48_72   [0x121110, 0x0a0908, 0x020100] (0x612067, 0x6e696c) == (0xdae5ac, 0x292cac)\nt02 = Simon48_96   [0x1a1918, 0x121110, 0x0a0908, 0x020100] (0x726963, 0x20646e) == (0x6e06a5, 0xacf156)\nt03 = Simon64_96   [0x13121110, 0x0b0a0908, 0x03020100] (0x6f722067, 0x6e696c63) == (0x5ca2e27f, 0x111a8fc8)\nt04 = Simon64_128  [0x1b1a1918, 0x13121110, 0x0b0a0908, 0x03020100] (0x656b696c, 0x20646e75) == (0x44c8fc20, 0xb9dfa07a)\nt05 = Simon96_96   [0x0d0c0b0a0908, 0x050403020100] (0x2072616c6c69, 0x702065687420) == (0x602807a462b4, 0x69063d8ff082)\nt06 = Simon96_144  [0x151413121110, 0x0d0c0b0a0908, 0x050403020100] (0x746168742074, 0x73756420666f) == (0xecad1c6c451e, 0x3f59c5db1ae9)\nt07 = Simon128_128 [0x0f0e0d0c0b0a0908, 0x0706050403020100] (0x6373656420737265, 0x6c6c657661727420) == (0x49681b1e1e54fe3f, 0x65aa832af84e0bbc)\nt08 = Simon128_192 [0x1716151413121110, 0x0f0e0d0c0b0a0908, 0x0706050403020100] (0x206572656874206e, 0x6568772065626972) == (0xc4ac61effcdc0d4f, 0x6c9c8d6e2597b85b)\nt09 = Simon128_256 [0x1f1e1d1c1b1a1918, 0x1716151413121110, 0x0f0e0d0c0b0a0908, 0x0706050403020100] (0x74206e69206d6f6f, 0x6d69732061207369) == (0x8d2b5579afc8a3a0, 0x3bf72a87efe7b868)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AESKeyWrap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::AESKeyWrap that imports the AES block cipher module and contains the following definitions: a constant DefaultIV, the functions aesWrapKey, aesUnwrapKey, aesUnwrapKeyUnchecked, and the private helpers wrapBlock, unwrapBlock, wrapRound, and unwrapRound. Specify DefaultIV as an 8-byte sequence equal to the standard AES Key Wrap default IV. Give aesWrapKey a polymorphic size parameter n with constraints that n is finite, n \u2265 16, n is a multiple of 8, and the bit-width of (n\/8) is \u2264 64. Its type takes an AES key, an 8-byte IV, and n bytes of plaintext, returning n+8 bytes of ciphertext. Describe the wrapping algorithm: split the plaintext into 64-bit blocks R[1..n\/8], set A from the IV (64 bits), then for six rounds j = 0..5 and i = 1..n\/8 compute B = AES-ENC(A || R[i]); set A to the upper 64 bits of B XOR t where t = (n\/8)*j + i as a 64-bit value; set R[i] to the lower 64 bits of B; output A followed by all R blocks as bytes. Give aesUnwrapKey constraints n \u2265 24, same divisibility and width conditions, and type returning a success bit and n-8 bytes. Define it to call the unchecked variant and compare A to the IV; on match return True and the recovered plaintext, else False and zero bytes. Specify aesUnwrapKeyUnchecked to return the 64-bit A value and the array of R blocks after performing six rounds j = 5..0 and i = (n\/8)..1 using AES-DEC and reversing the t mix. Define private helpers wrapBlock\/unwrapBlock (single i, given j), and wrapRound\/unwrapRound (iterate over all i), with constraints fin n and width n \u2264 64 where applicable, and precise byte\/word packing between [8]-byte chunks and 64-bit words."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AESKeyWrap where\nimport Primitive::Symmetric::Cipher::Block::AES\n\nDefaultIV : [8][8]\nDefaultIV = [0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6]\n\naesWrapKey : {n} (fin n, n >= 16, n % 8 == 0, width (n \/ 8) <= 64) =>\n             [AESKeySize] -> [8][8] -> [n][8] -> [n+8][8]\naesWrapKey key iv plaintext = split (join C)\n  where\n        A = join iv\n    R = split`{parts=n\/8, each=64} (join plaintext)\n        intermediates = [(A, R)] # [wrapRound key s j | s <- intermediates\n                                                  | j <- [0..5]]\n        (A', R') = intermediates ! 0\n    C = [A'] # R'\n\naesUnwrapKey : {n} (fin n, n >= 24, n % 8 == 0, width (n \/ 8) <= 64) =>\n               [AESKeySize] -> [8][8] -> [n][8] -> (Bit, [n-8][8])\naesUnwrapKey key iv ciphertext = if (join iv) == A'\n                                 then (True, split (join R'))\n                                 else (False, zero)\n  where\n    (A', R') = aesUnwrapKeyUnchecked key ciphertext\n\naesUnwrapKeyUnchecked : {n} (fin n, n >= 24, n % 8 == 0, width (n \/ 8) <= 64) =>\n                        [AESKeySize] -> [n][8] -> ([64], [n\/8 - 1][64])\naesUnwrapKeyUnchecked key ciphertext = intermediates ! 0\n  where\n        A = join (take`{8} ciphertext)\n    R = split`{parts=(n-8)\/8, each=64} (join (drop`{8} ciphertext))\n        intermediates = [(A, R)] # [unwrapRound key s j | s <- intermediates\n                                                    | j <- [5, 4 .. 0]]\n\nprivate\n\n    wrapBlock : {n} (fin n, width n <= 64) =>\n              [AESKeySize] -> ([64], [n][64]) -> [64] -> [64] -> ([64], [n][64])\n  wrapBlock key (A, R) j i = (A', R')\n    where B  = aesEncrypt (A # (R @ (i-1)), key)\n          A' = (take`{64} B) ^ (((`n : [64]) * j) + i)\n          R' = update R (i-1) (drop`{64} B)\n\n    unwrapBlock : {n} (fin n, width n <= 64) =>\n                [AESKeySize] -> ([64], [n][64]) -> [64] -> [64] -> ([64], [n][64])\n  unwrapBlock key (A, R) j i = (A', R')\n    where B  = aesDecrypt ((A ^ (((`n : [64]) * j) + i)) # (R @ (i-1)), key)\n          A' = take`{64} B\n          R' = update R (i-1) (drop`{64} B)\n\n    wrapRound : {n} (fin n, n >= 1, width n <= 64) =>\n              [AESKeySize] -> ([64], [n][64]) -> [64] -> ([64], [n][64])\n  wrapRound key (A, R) j = wrappedBlocks ! 0\n    where wrappedBlocks = [(A, R)] # [wrapBlock key s j i | s <- wrappedBlocks\n                                                          | i <- [1..n]]\n\n    unwrapRound : {n} (fin n, n >= 1, width n <= 64) =>\n                [AESKeySize] -> ([64], [n][64]) -> [64] -> ([64], [n][64])\n  unwrapRound key (A, R) j = unwrappedBlocks ! 0\n    where unwrappedBlocks = [(A, R)] # [unwrapBlock key s j i | s <- unwrappedBlocks\n                                                              | i <- [n, n-1 .. 1]]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/speck.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::speck that contains the following definitions: R, R', f1, f2, encrypt, decrypt, expandKey; constant aliases for specific cipher variants (both encryption and decryption) for 32\/64, 48\/72, 48\/96, 64\/96, 64\/128, 96\/96, 96\/144, 128\/128, 128\/192, and 128\/256; properties correctSpeck32_64, correctSpeck64_96, correctSpeck96_144, correctSpeck128_128, correctSpeck128_256; boolean test constants t00..t09; a list tests; and a property testsPass.\n\nSpecify types and constraints:\n- R, R', f1, f2: for any finite n, each has type [n] -> ([n],[n]) -> ([n],[n]).\n- encrypt, decrypt: for finite n, m, T with m>=2, T>=2, n>=2, and n sufficient to index T-2; type [m][n] -> ([n],[n]) -> ([n],[n]).\n- expandKey: same parameters\/constraints; type [m][n] -> [T][n].\n\nDefine behavior:\n- f1: maps (x,y) and round key k to (y, (x rotated right by a) + y XOR k), where a=7 when n==16, else a=8.\n- f2: maps (x,y) to (y, (x rotated left by b) XOR y), where b=2 when n==16, else b=3.\n- R applies f1 then f2 with round key k; R' inverts a round using XOR, subtraction modulo 2^n, and the same rotation amounts conditioned on n.\n- expandKey: generate T round keys by iterating f1\/f2 over key state arrays derived from the input key words (use list comprehensions\/zips; include taking\/dropping head\/tail segments as needed).\n- encrypt: iterate T rounds of R over the input block using the round keys from expandKey; define as a stream over prior states and round keys; return the first produced ciphertext pair.\n- decrypt: iterate R' using the round keys in reverse order to recover the plaintext.\n- For each listed variant alias, fix n, m, T appropriately for that parameter set (both enc and dec).\n- Define properties that universally quantify key and block and assert decrypt(enc(b)) equals the original block for the listed variants.\n- Define boolean test vectors t00..t09 using concrete keys\/plaintexts\/ciphertexts for the variants, a list tests collecting them, and a property testsPass as their conjunction."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::speck where\n\nSpeck32_64    = encrypt`{n = 16, m = 4, T = 22}\nSpeck48_72    = encrypt`{n = 24, m = 3, T = 22}\nSpeck48_96    = encrypt`{n = 24, m = 4, T = 23}\nSpeck64_96    = encrypt`{n = 32, m = 3, T = 26}\nSpeck64_128   = encrypt`{n = 32, m = 4, T = 27}\nSpeck96_96    = encrypt`{n = 48, m = 2, T = 28}\nSpeck96_144   = encrypt`{n = 48, m = 3, T = 29}\nSpeck128_128  = encrypt`{n = 64, m = 2, T = 32}\nSpeck128_192  = encrypt`{n = 64, m = 3, T = 33}\nSpeck128_256  = encrypt`{n = 64, m = 4, T = 34}\n\nSpeck32_64'   = decrypt`{n = 16, m = 4, T = 22}\nSpeck48_72'   = decrypt`{n = 24, m = 3, T = 22}\nSpeck48_96'   = decrypt`{n = 24, m = 4, T = 23}\nSpeck64_96'   = decrypt`{n = 32, m = 3, T = 26}\nSpeck64_128'  = decrypt`{n = 32, m = 4, T = 27}\nSpeck96_96'   = decrypt`{n = 48, m = 2, T = 28}\nSpeck96_144'  = decrypt`{n = 48, m = 3, T = 29}\nSpeck128_128' = decrypt`{n = 64, m = 2, T = 32}\nSpeck128_192' = decrypt`{n = 64, m = 3, T = 33}\nSpeck128_256' = decrypt`{n = 64, m = 4, T = 34}\n\nproperty correctSpeck32_64 (k, b) = Speck32_64' k (Speck32_64 k b) == b\nproperty correctSpeck64_96 (k, b) = Speck64_96' k (Speck64_96 k b) == b\nproperty correctSpeck96_144 (k, b) = Speck96_144' k (Speck96_144 k b) == b\nproperty correctSpeck128_128 (k, b) = Speck128_128' k (Speck128_128 k b) == b\nproperty correctSpeck128_256 (k, b) = Speck128_256' k (Speck128_256 k b) == b\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ round function\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nR : {n} (fin n) => [n] -> ([n], [n]) -> ([n], [n])\nR k (x, y) = f2 (f1 k (x, y))\n\nR' : {n} (fin n) => [n] -> ([n], [n]) -> ([n], [n])\nR' k (x, y) = ((x ^ k) - z <<< (if `n == 16 then 7 else 8), z)\n  where z = (x ^ y) >>> (if `n == 16 then 2 else 3)\n\nf1 : {n} (fin n) => [n] -> ([n], [n]) -> ([n], [n])\nf1 k (x, y) = (y, (x >>> (if `n == 16 then 7 else 8)) + y ^ k)\n\nf2 : {n} (fin n) => ([n], [n]) -> ([n], [n])\nf2 (x, y) = (y, x <<< (if `n == 16 then 2 else 3) ^ y)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ encryption \/ decryption\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nencrypt : {n, m, T}\n    ( fin n, fin m, fin T\n    , m >= 2, T >= 2, n >= 2\n    , n >= width (T-2)\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\nencrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [R k b | b <- bs | k <- ks]\n    ks = expandKey`{n = n, m = m, T = T} (reverse k0)\n\ndecrypt : {n, m, T}\n    ( fin n, fin m, fin T\n    , m >= 2, T >= 2, n >= 2\n    , n >= width (T-2)\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\ndecrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [R' k b | b <- bs | k <- reverse ks]\n    ks = expandKey`{n = n, m = m, T = T} (reverse k0)\n\nexpandKey : {n, m, T}\n    ( fin n, fin m, fin T\n    , m >= 2, n >= 2, T >= 2\n    , n >= width (T-2)\n    ) => [m][n] -> [T][n]\nexpandKey K = ks\n  where\n    ls = drop`{1} K # [snd (f1 i (l, k)) | l <- ls | k <- ks | i <- [0 .. T - 2]]\n    ks = take`{1} K # [snd (f2 (k, l)) | l <- drop`{m - 1} ls | k <- ks]\n    snd (x, y) = y\n\nproperty testsPass = and tests\n\ntests = [t01, t02, t03, t04, t05, t06, t07, t08, t09]\n\nt00 = Speck32_64 [0x1918, 0x1110, 0x0908, 0x0100] (0x6574, 0x694C) == (0xA868, 0x42F2)\nt01 = Speck48_72 [0x121110, 0x0A0908, 0x020100] (0x20796C, 0x6C6172) == (0xC049A5, 0x385ADC)\nt02 = Speck48_96 [0x1A1918, 0x121110, 0x0A0908, 0x020100] (0x6D2073, 0x696874) == (0x735E10, 0xB6445D)\nt03 = Speck64_96 [0x13121110, 0x0B0A0908, 0x03020100] (0x74614620, 0x736E6165) == (0x9F7952EC, 0x4175946C)\nt04 = Speck64_128 [0x1B1A1918, 0x13121110, 0x0B0A0908, 0x03020100] (0x3B726574, 0x7475432D) == (0x8C6FA548, 0x454E028B)\nt05 = Speck96_96 [0x0D0C0B0A0908, 0x050403020100] (0x65776F68202C, 0x656761737520) == (0x9E4D09AB7178, 0x62BDDE8F79AA)\nt06 = Speck96_144 [0x151413121110, 0x0D0C0B0A0908, 0x050403020100] (0x656D6974206E, 0x69202C726576) == (0x2BF31072228A, 0x7AE440252EE6)\nt07 = Speck128_128 [0x0F0E0D0C0B0A0908, 0x0706050403020100] (0x6C61766975716520, 0x7469206564616D20) == (0xA65D985179783265, 0x7860FEDF5C570D18)\nt08 = Speck128_192 [0x1716151413121110, 0x0F0E0D0C0B0A0908, 0x0706050403020100] (0x7261482066656968, 0x43206F7420746E65) == (0x1BE4CF3A13135566, 0xF9BC185DE03C1886)\nt09 = Speck128_256 [0x1F1E1D1C1B1A1918, 0x1716151413121110, 0x0F0E0D0C0B0A0908, 0x0706050403020100] (0x65736F6874206E49, 0x202E72656E6F6F70) == (0x4109010405C0F53E, 0x4EEEB48D9C188F43)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/TripleDES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::TripleDES that contains the following definitions: blockEncrypt, Key1, Key2, Key3, PlainText, P1, P2, P3, C1, C2, C3, test_B1_1, test_B1_2, test_B1_3, testsPass. Import the DES block cipher module and implement blockEncrypt with type ( [64], [64], [64], [64] ) -> [64], performing 3DES in EDE mode: encrypt with the first 64-bit key via DES.encrypt, decrypt with the second via DES.decrypt, then encrypt with the third via DES.encrypt. Declare Key1, Key2, Key3 as 64-bit constants with the same hexadecimal values and types as the reference. Declare PlainText as a 24-byte ASCII string; derive P1, P2, P3 as three 64-bit plaintext blocks by packing the bytes of PlainText and splitting into three consecutive 64-bit chunks. Declare C1, C2, C3 as 64-bit ciphertext constants with the expected values. Define boolean tests test_B1_1, test_B1_2, test_B1_3 that each check equality between blockEncrypt applied to the corresponding plaintext block under the three keys and its expected ciphertext. Define a property that asserts the logical conjunction of those three booleans holds. State all types explicitly."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::TripleDES where\n\nimport Primitive::Symmetric::Cipher::Block::DES\n\nblockEncrypt : ([64],[64],[64],[64]) -> [64]\nblockEncrypt (k1,k2,k3,data) = result where\n    ex     = DES.encrypt k1 data\n    dx     = DES.decrypt k2 ex\n    result = DES.encrypt k3 dx\n\nKey1, Key2, Key3 : [64]\nKey1 = 0x0123456789ABCDEF\nKey2 = 0x23456789ABCDEF01\nKey3 = 0x456789ABCDEF0123\n\nP1, P2, P3 : [64]\nPlainText = \"The qufck brown fox jump\"\n[P1, P2, P3] = split`{3} (join PlainText)\n\nC1, C2, C3 : [64]\nC1 = 0xA826FD8CE53B855F\nC2 = 0xCCE21C8112256FE6\nC3 = 0x68D5C05DD9B6B900\n\ntest_B1_1 = blockEncrypt (Key1, Key2, Key3, P1) == C1\ntest_B1_2 = blockEncrypt (Key1, Key2, Key3, P2) == C2\ntest_B1_3 = blockEncrypt (Key1, Key2, Key3, P3) == C3\n\nproperty testsPass = and [test_B1_1, test_B1_2, test_B1_3]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::TDES_CBC that contains the following definitions: type aliases iv, block, k1, k2, and k3 for 64-bit sequences; a function cbcTDesEnc that is polymorphic in a block count n with a finiteness constraint, taking three 64-bit keys, a 64-bit IV, and a sequence of n plaintext blocks (each 64 bits), returning a sequence of n ciphertext blocks (each 64 bits). The function must implement CBC-mode Triple-DES encryption: for each plaintext block, XOR it with the previous ciphertext (or the IV for the first block), then encrypt that 64-bit value using the TripleDES block encryptor with the three keys, producing the next ciphertext block. Include constants: testKey (record containing specific 64-bit values for k1, k2, k3, and iv), testPt (a singleton list containing a list of four 64-bit plaintext blocks), and testCt (a singleton list containing the corresponding expected four 64-bit ciphertext blocks). Define a property named testPass that checks, for each paired plaintext\/ciphertext test sequence, that running cbcTDesEnc with the keys and IV from testKey on the plaintext sequence yields the expected ciphertext sequence. Import the Primitive::Symmetric::Cipher::Block::TripleDES module to use its block encryption function inside the CBC computation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::TDES_CBC where\nimport Primitive::Symmetric::Cipher::Block::TripleDES\n\ntype iv = [64]\ntype block = [64]\n\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncbcTDesEnc : {n} (fin n) => k1 -> k2 -> k3->iv -> [n]block -> [n]block\ncbcTDesEnc k1 k2 k3 iv ps = cs\n    where cs = [ blockEncrypt (k1, k2, k3, (p ^ c')) | p <- ps | c' <- [iv] # cs ]\n\ntestKey ={ k1=0x0123456789ABCDEF, k2=0x23456789ABCDEF01, k3=0x456789ABCDEF0123,      iv=0xF69F2445DF4F9B17 }\ntestPt = [[0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]]\ntestCt = [[0x2079C3D53AA763E1, 0x93B79E2569AB5262, 0x516570481F25B50F, 0x73C0BDA85C8E0DA7]]\n\nproperty testPass = and [(cbcTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv ps) == cs\n                        | ps <- testPt | cs <- testCt]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Modes::CBC that contains: (1) two type synonyms for a 128-bit initialization vector and a 128-bit block; (2) a polymorphic function for CBC encryption with type parameters n and k (both finite). It accepts a block cipher encryption function of type [k] -> [128] -> [128], a key of width k, a 128-bit IV, and a sequence of n 128-bit plaintext blocks, and returns a sequence of n 128-bit ciphertext blocks. The algorithm XORs each plaintext block with the previous ciphertext block (using the IV for the first), then applies the encryption function, producing the ciphertext stream; (3) a polymorphic function for CBC decryption with the same parameters and types, but taking a block cipher decryption function and a sequence of ciphertext blocks, returning plaintext by decrypting each ciphertext block and XORing the result with the previous ciphertext block (seeded with the IV). Include explicit type constraints fin n and fin k in the signatures. Also declare properties that: (a) assuming the provided encryption and decryption functions are blockwise inverses under the same key, decrypting the encryption of any sequence of n blocks with the same IV yields the original plaintext sequence; (b) the output sequence lengths and block widths match the inputs. Do not define a concrete block cipher; treat the encryption and decryption functions as parameters. Provide complete type signatures and definitions within the module."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CBC where\n\ntype iv = [128]\ntype block = [128]\n\ncbcEnc : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncbcEnc enc k iv ps = cs\n    where cs = [ enc k (p ^ c') | p <- ps | c' <- [iv] # cs ]\n\ncbcDec : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncbcDec dec k iv cs = [ (dec k c) ^ c' | c <- cs | c' <- [iv] # cs ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AES_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Modes::AES_CBC that imports the CBC mode utilities (providing CBC encryption and decryption) and the parameterized AES block cipher. Within it: (1) define a property cbcEncCorrect that states: for any AES-compatible block encryption function over 128-bit blocks, a 128-bit key, a 128-bit initialization vector, and a sequence of 128-bit plaintext blocks, decrypting (with CBC decryption) the result of CBC encryption under the same function, key, and IV yields the original plaintext sequence; (2) define constants testKey, testIv, testPt, testCt as singleton lists containing, respectively, one AES-128 key, one 128-bit IV, one plaintext consisting of a single 128-bit block formed from a 16-byte ASCII string, and the corresponding expected single-block ciphertext; (3) define a property testEncCbcPassB1 that checks CBC encryption with the AES encrypt function, the given key, IV, and plaintext equals the expected ciphertext, using a zipped list-comprehension over those singleton lists; (4) similarly define constants testKey2\/testIv2\/testPt2\/testCt2 (two-block plaintext) and a property testEncCbcPassB2; (5) define constants testKey3\/testIv3\/testPt3\/testCt3 (three-block plaintext) and a property testEncCbcPassB3; (6) define constants testKey4\/testIv4\/testPt4\/testCt4 (four-block plaintext) and a property testEncCbcPassB4. Ensure all constants are sized as 128-bit words and sequences of 128-bit blocks, the encrypt function\u2019s type matches AES over 128-bit blocks, and each property is universally quantified and suitable for solver checking."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::AES_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::CBC\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\nproperty cbcEncCorrect encrypt k c ps = (cbcDec encrypt k c (cbcEnc encrypt k c ps)) == ps\n\ntestKey = [0x06a9214036b8a15b512e03d534120006]\ntestIv = [0x3dafba429d9eb430b422da802c9fac41]\ntestPt = [[join \"Single block msg\"]]\ntestCt = [[0xe353779c1079aeb82708942dbe77181a]]\n\nproperty testEncCbcPassB1 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey | iv <- testIv | ps <- testPt | cs <- testCt ]\n\ntestKey2 = [0xc286696d887c9aa0611bbb3e2025a45a]\ntestIv2 = [0x562e17996d093d28ddb3ba695a2e6f58]\ntestPt2 = [[0x000102030405060708090a0b0c0d0e0f, 0x101112131415161718191a1b1c1d1e1f]]\ntestCt2 = [[0xd296cd94c2cccf8a3a863028b5e1dc0a, 0x7586602d253cfff91b8266bea6d61ab1]]\n\nproperty testEncCbcPassB2 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey2 | iv <- testIv2 | ps <- testPt2 | cs <- testCt2 ]\n\ntestKey3 = [0x6c3ea0477630ce21a2ce334aa746c2cd]\ntestIv3 = [0xc782dc4c098c66cbd9cd27d825682c81]\ntestPt3 = [[0x5468697320697320612034382d627974, 0x65206d65737361676520286578616374, 0x6c7920332041455320626c6f636b7329]]\ntestCt3 = [[0xd0a02b3836451753d493665d33f0e886, 0x2dea54cdb293abc7506939276772f8d5, 0x021c19216bad525c8579695d83ba2684]]\n\nproperty testEncCbcPassB3 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey3 | iv <- testIv3 | ps <- testPt3 | cs <- testCt3 ]\n\ntestKey4 = [0x56e47a38c5598974bc46903dba290349]\ntestIv4 = [0x8ce82eefbea0da3c44699ed7db51b7d9]\ntestPt4 = [[0xa0a1a2a3a4a5a6a7a8a9aaabacadaeaf, 0xb0b1b2b3b4b5b6b7b8b9babbbcbdbebf, 0xc0c1c2c3c4c5c6c7c8c9cacbcccdcecf, 0xd0d1d2d3d4d5d6d7d8d9dadbdcdddedf]]\ntestCt4 = [[0xc30e32ffedc0774e6aff6af0869f71aa, 0x0f3af07a9a31a9c684db207eb0ef8e4e, 0x35907aa632c3ffdf868bb7b29d3d46ad, 0x83ce9f9a102ee99d49a53e87f4c3da55]]\n\nproperty testEncCbcPassB4 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey4 | iv <- testIv4 | ps <- testPt4 | cs <- testCt4 ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::CTR that contains the following definitions: type synonyms ic and block for 128-bit words, and two functions ctrEnc and ctrDec. Provide explicit type signatures for ctrEnc and ctrDec that are polymorphic over sequence length n and key size k, constrained by fin n and fin k. Each function must take: (1) a block-cipher encryption function of type key -> block -> block, (2) a k-bit key, (3) a 128-bit initial counter, and (4) a sequence of n 128-bit blocks. The encryption function returns n ciphertext blocks; the decryption function returns n plaintext blocks. Implement both by generating a counter stream starting at the initial counter and incrementing by 1 for each subsequent block using modular addition over 128-bit words. For encryption, for each plaintext block, compute the keystream block by applying the cipher to the corresponding counter value, then XOR it with the plaintext to produce the ciphertext. For decryption, perform the same keystream generation and XOR it with the ciphertext to recover the plaintext. Use zipping over the input sequence and the counter stream so that exactly n counters are consumed. Ensure total definitions, correct types for all values, and that ctrEnc and ctrDec are extensionally identical procedures due to XOR involution (but do not add a property)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CTR where\n\ntype ic = [128]\ntype block = [128]\n\nctrEnc : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> ic -> [n]block -> [n]block\nctrEnc enc k c ps = cs\n    where cs = [(enc k c')^p | p <- ps | c' <- ctrs]\n          ctrs = [c+i | i<- [0...]]\n\nctrDec : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> ic -> [n]block -> [n]block\nctrDec enc k c cs = ps\n    where ps = [(enc k c')^ct | ct <- cs | c' <- ctrs]\n          ctrs = [c+i | i<- [0...]]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Modes::TDES_CFB that imports Primitive::Symmetric::Cipher::Block::TripleDES. Inside the module: (1) Declare type synonyms for 64-bit quantities: iv, block, k1, k2, k3. (2) Define the function cfbTDesEnc with type: for any length n (with fin n), it takes three 64-bit keys, a 64-bit IV, and a sequence of n 64-bit plaintext blocks, and returns a sequence of n 64-bit ciphertext blocks. Implement Triple-DES CFB encryption: generate the ciphertext stream cs where each ciphertext block is the Triple-DES block encryption of the current feedback, XORed with the corresponding plaintext block; the feedback stream is the IV followed by the previously produced ciphertext blocks. Use the block encryption function from the imported TripleDES module. (3) Define constants testKey (a record with fields k1, k2, k3, iv, each 64 bits), testPt (a list of test cases, where each test case is a sequence of 64-bit plaintext blocks), and testCt (the corresponding list of expected ciphertext sequences), preserving the same types and concrete values as the source. (4) Define a property named testPass that, for every test case, asserts that applying cfbTDesEnc to the testKey and the plaintext sequence yields the corresponding expected ciphertext sequence. Keep the types, constraints, and names exactly as specified, and ensure the property is a boolean suitable for automated checking."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::TDES_CFB where\nimport Primitive::Symmetric::Cipher::Block::TripleDES\n\ntype iv = [64]\ntype block = [64]\n\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncfbTDesEnc : {n} (fin n) => k1 -> k2 -> k3->iv -> [n]block -> [n]block\ncfbTDesEnc k1 k2 k3 iv ps = cs\n    where cs = [ blockEncrypt (k1, k2, k3,  c')^p | p <- ps | c' <- [iv] # cs ]\n\ntestKey ={ k1=0x0123456789ABCDEF, k2=0x23456789ABCDEF01, k3=0x456789ABCDEF0123,      iv=0xF69F2445DF4F9B17 }\ntestPt = [[0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]]\ntestCt = [[0x078BB74E59CE7ED6, 0x7666DE9CF95EAF3F, 0xE9ED6BB460F45152, 0x8A5F9FE4ED710918]]\n\nproperty testPass = and [(cfbTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv ps) == cs\n                        | ps <- testPt | cs <- testCt]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AES_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Modes::AES_CTR that contains the following definitions: ctrEncCorrect, k, ic, plaintext, ciphertext, and testPass. Import the CTR mode utilities and the parameterized AES block cipher so you can use the CTR-mode encrypt\/decrypt helpers and the AES block encrypt function. Provide explicit type signatures. The property ctrEncCorrect must quantify over an AES block-encrypt function argument of type (key -> block -> block), a 128-bit key, a 128-bit initial counter block, and a finite sequence of 128-bit plaintext blocks, and assert that CTR-mode decryption of the CTR-mode encryption yields the original plaintext sequence. Define constants k (a 128-bit AES key), ic (a 128-bit initial counter), plaintext (a list of four 128-bit blocks), and ciphertext (a list of four 128-bit blocks) with the same values and types as in the reference implementation. The property testPass must assert that CTR-mode encryption of plaintext using the AES encrypt function, key k, and counter ic equals ciphertext. Ensure all blocks are 128 bits and the test vectors\u2019 lengths and types are consistent with AES-128 CTR. Do not implement new algorithms; reuse the imported CTR helpers and AES encrypt. Do not provide solutions; only specify the declarations and properties as described."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::AES_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::CTR\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\nproperty ctrEncCorrect enc k c ps = (ctrDec enc k c (ctrEnc enc k c ps)) == ps\n\nk = 0x2b7e151628aed2a6abf7158809cf4f3c\nic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\nplaintext = [0x6bc1bee22e409f96e93d7e117393172a, 0xae2d8a571e03ac9c9eb76fac45af8e51, 0x30c81c46a35ce411e5fbc1191a0a52ef, 0xf69f2445df4f9b17ad2b417be66c3710]\nciphertext = [0x874d6191b620e3261bef6864990db6ce, 0x9806f66b7970fdff8617187bb9fffdff, 0x5ae4df3edbd5d35e5b4f09020db03eab, 0x1e031dda2fbe03d1792170a0f3009cee]\n\nproperty testPass = (ctrEnc encrypt k ic plaintext) == ciphertext\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Modes::CFB that contains: (1) two type aliases for 128-bit words used as the initialization vector and block type; (2) a polymorphic encryption function cfbEnc parameterized by finite sizes n and k. It accepts a block-cipher oracle that maps a k-bit key and a 128-bit block to a 128-bit block, a k-bit key value, a 128-bit IV, and a sequence of n 128-bit plaintext blocks, and returns a sequence of n 128-bit ciphertext blocks. Its semantics: for each plaintext block, encrypt the previous ciphertext value (use the IV for the first step) with the given key to form a keystream block, then output the XOR of that keystream and the current plaintext; the feedback value for the next step is the ciphertext just produced. Model the feedback stream as the IV followed by the ciphertext sequence. (3) a polymorphic decryption function cfbDec with the same type parameters and argument structure, mapping a sequence of n ciphertext blocks to a sequence of n plaintext blocks. Its semantics: for each ciphertext block, encrypt the previous ciphertext value (IV first) with the key to form a keystream block, then output the XOR of that keystream and the current ciphertext; the feedback value remains the ciphertext stream (not the plaintext). Specify XOR as bitwise over 128-bit blocks, sequences as length-n lists of 128-bit blocks, and include finiteness constraints on n and k in the type signatures."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CFB where\n\ntype iv = [128]\ntype block = [128]\n\ncfbEnc : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncfbEnc enc k iv ps = cs\n    where cs = [ (enc k c')^p | p <- ps | c' <- [iv] # cs ]\n\ncfbDec : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncfbDec enc k iv cs = [ (enc k c')^c | c <- cs | c' <- [iv] # cs ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AES_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::AES_CFB that contains the following definitions: cfbEncCorrect, testKey, testIv, testPt, testCt, testEncCfbPassB1, testKey2, testIv2, testPt2, testCt2, and testEncCfbPassB2. Import the CFB mode operations and an AES block-cipher encrypt function. Specify types: the key and IV are 128-bit sequences; a block is 128 bits; plaintext and ciphertext are sequences of 128-bit blocks (lists). The encrypt function takes a 128-bit key and a 128-bit block and returns a 128-bit block. Use the CFB-mode encrypt and decrypt operations parameterized by the encrypt function. Define a property cfbEncCorrect over an encrypt function, key, IV, and plaintext sequence that asserts decrypting the CFB-mode encryption output with the same parameters yields the original plaintext. Define constants testKey, testIv, testPt, and testCt as singleton lists holding one 128-bit key, one 128-bit IV, one one-block plaintext, and the corresponding one-block ciphertext test vector. Define a property testEncCfbPassB1 that computes the conjunction over a zipped list-comprehension asserting the CFB-mode encryption of each (key, IV, plaintext) equals the expected ciphertext. Define constants testKey2, testIv2, testPt2, and testCt2 as singleton lists where the plaintext and ciphertext contain four 128-bit blocks, with the same key and IV as above. Define a property testEncCfbPassB2 that similarly conjoins equality checks for the multi-block case. Ensure all properties are boolean and suitable for solver checking, and all constants have explicit types consistent with AES-128 CFB."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::AES_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::CFB\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\nproperty cfbEncCorrect encrypt k c ps = (cfbDec encrypt k c (cfbEnc encrypt k c ps)) == ps\n\ntestKey = [0x2b7e151628aed2a6abf7158809cf4f3c]\ntestIv = [0x000102030405060708090a0b0c0d0e0f]\ntestPt = [[0x6bc1bee22e409f96e93d7e117393172a]]\ntestCt = [[0x3b3fd92eb72dad20333449f8e83cfb4a]]\n\nproperty testEncCfbPassB1 = and [ (cfbEnc encrypt k iv ps) == cs\n                                | k <- testKey | iv <- testIv | ps <- testPt | cs <- testCt ]\n\ntestKey2 = [0x2b7e151628aed2a6abf7158809cf4f3c]\ntestIv2 = [0x000102030405060708090a0b0c0d0e0f]\ntestPt2 = [[0x6bc1bee22e409f96e93d7e117393172a, 0xae2d8a571e03ac9c9eb76fac45af8e51, 0x30c81c46a35ce411e5fbc1191a0a52ef, 0xf69f2445df4f9b17ad2b417be66c3710]]\ntestCt2 = [[0x3b3fd92eb72dad20333449f8e83cfb4a, 0xc8a64537a0b3a93fcde3cdad9f1ce58b, 0x26751f67a3cbb140b1808cf187a4f4df, 0xc04b05357c5d1c0eeac4c66f9ff7f2e6]]\n\nproperty testEncCfbPassB2 = and [ (cfbEnc encrypt k iv ps) == cs\n                                | k <- testKey2 | iv <- testIv2 | ps <- testPt2 | cs <- testCt2 ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Tests\/TestAESKeyWrap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Tests::TestAESKeyWrap that imports the AES and AESKeyWrap modules. Inside, declare: (1) a 256-bit key constant KEK256 with type [AESKeySize]; (2) byte-sequence constants KeyData128:[16][8], Ciphertext128_256:[24][8]; KeyData192:[24][8], Ciphertext192_256:[32][8]; KeyData256:[32][8], Ciphertext256_256:[40][8]; (3) constants KCount0..KCount4 as 256-bit keys; (4) PCount0..PCount3 as [16][8]; (5) CCount0..CCount4 as [24][8]. Use DefaultIV for wrapping\/unwrapping. Initialize all constants from the specified fixed hexadecimal test vectors and ensure the exact types as stated. Then add the following properties: define a property that wrapping KEK256 with KeyData128 equals Ciphertext128_256; define a property that unwrapping KEK256 with Ciphertext128_256 equals (True, KeyData128). Repeat the same two properties for the 192-bit and 256-bit key data\/ciphertext pairs. For Count0 through Count3, define a property that wrapping KCounti with PCounti equals CCounti, and define a property that unwrapping KCounti with CCounti equals (True, PCounti). For Count4, define a property that unwrapping KCount4 with CCount4 equals (False, zero) where zero is the all-zero byte sequence of the appropriate length. All properties should call aesWrapKey and aesUnwrapKey with DefaultIV and compare results for exact equality, including the boolean success flag for unwrap. Do not implement the algorithms; only reference the imported functions and provide the precise test vectors and types so the properties can be checked by a solver."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Tests::TestAESKeyWrap where\n\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Block::AESKeyWrap\n\nKEK256 : [AESKeySize]\nKEK256 = 0x000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\n\nKeyData128 : [16][8]\nKeyData128 = split 0x00112233445566778899AABBCCDDEEFF\n\nCiphertext128_256 : [24][8]\nCiphertext128_256 = split 0x64E8C3F9CE0F5BA263E9777905818A2A93C8191E7D6E8AE7\n\nproperty testWrap128_256 = (aesWrapKey KEK256 DefaultIV KeyData128) == Ciphertext128_256\nproperty testUnwrap128_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext128_256) == (True, KeyData128)\n\nKeyData192 : [24][8]\nKeyData192 = split 0x00112233445566778899AABBCCDDEEFF0001020304050607\n\nCiphertext192_256 : [32][8]\nCiphertext192_256 = split 0xA8F9BC1612C68B3FF6E6F4FBE30E71E4769C8B80A32CB8958CD5D17D6B254DA1\n\nproperty testWrap192_256 = (aesWrapKey KEK256 DefaultIV KeyData192) == Ciphertext192_256\nproperty testUnwrap192_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext192_256) == (True, KeyData192)\n\nKeyData256 : [32][8]\nKeyData256 = split 0x00112233445566778899AABBCCDDEEFF000102030405060708090A0B0C0D0E0F\n\nCiphertext256_256 : [40][8]\nCiphertext256_256 = split 0x28C9F404C4B810F4CBCCB35CFB87F8263F5786E2D80ED326CBC7F0E71A99F43BFB988B9B7A02DD21\n\nproperty testWrap256_256 = (aesWrapKey KEK256 DefaultIV KeyData256) == Ciphertext256_256\nproperty testUnwrap256_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext256_256) == (True, KeyData256)\n\nKCount0 = 0x80aa997327a4806b6a7a41a52b86c3710386f932786ef79676fafb90b8263c5f\nPCount0 = split`{each=8} 0x0a256ba75cfa03aaa02ba94203f15baa\nCCount0 = split`{each=8} 0x423c960d8a2ac4c1d33d3d977bf0a91559f99c8acd293d43\nproperty Count0Wrap = (aesWrapKey KCount0 DefaultIV PCount0) == CCount0\nproperty Count0Unwrap = (aesUnwrapKey KCount0 DefaultIV CCount0) == (True, PCount0)\n\nKCount1 = 0x2d104bc65c5f78e92993bd78b27d8e59a8a1f7c64b55b05be5df30f96ff04767\nCCount1 = split`{each=8} 0xe69fc01ea73e11bb4bc7485044145f824cfd535528b76517\nPCount1 = split`{each=8} 0xf8d46471445228d2ef399755360bdd6e\nproperty Count1Wrap = (aesWrapKey KCount1 DefaultIV PCount1) == CCount1\nproperty Count1Unwrap = (aesUnwrapKey KCount1 DefaultIV CCount1) == (True, PCount1)\n\nKCount2 = 0xd963c8f1d3d2392629823fd1df3f644c8690f602c94e5d5818309d7c05e5427f\nCCount2 = split`{each=8} 0x177c6217f7fd6c94cbd4a9f512b1416c869328e3084e09ea\nPCount2 = split`{each=8} 0x451d0222ec29755d9c69165a5d109727\nproperty Count2Wrap = (aesWrapKey KCount2 DefaultIV PCount2) == CCount2\nproperty Count2Unwrap = (aesUnwrapKey KCount2 DefaultIV CCount2) == (True, PCount2)\n\nKCount3 = 0xe594f0067cedb74e883e7746d29ba725c884c25375323f367cf49d17ad0f567b\nCCount3 = split`{each=8} 0x3b51ae2b0e3ddeed94efd7bfdc22630187e1f7624d15ed78\nPCount3 = split`{each=8} 0x587e3f6c75644bb5c3db9c74714f5556\nproperty Count3Wrap = (aesWrapKey KCount3 DefaultIV PCount3) == CCount3\nproperty Count3Unwrap = (aesUnwrapKey KCount3 DefaultIV CCount3) == (True, PCount3)\n\nKCount4 = 0x08c936b25b567a0aa679c29f201bf8b190327df0c2563e39cee061f149f4d91b\nCCount4 = split`{each=8} 0xe227eb8ae9d239ccd8928adec39c28810ca9b3dc1f366444\nproperty Count4Unwrap = (aesUnwrapKey KCount4 DefaultIV CCount4) == (False, zero)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/GF28.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::AES::GF28 that contains the following definitions and verification artifacts: a type alias GF28 for 8-bit words representing elements of GF(2^8) in polynomial basis; a constant irreducible equal to the AES polynomial x^8 + x^4 + x^3 + x + 1. Provide type signatures and implementations for: gf28Add (polymorphic over finite n) returning the field sum (XOR reduction) of a length-n sequence; gf28Mult performing polynomial multiplication over GF(2) reduced modulo the irreducible polynomial; gf28Pow exponentiating by an 8-bit exponent using square-and-multiply with LSB-first processing and right shifts; gf28Inverse computing the multiplicative inverse via exponentiation by 254; gf28DotProduct (polymorphic over finite n) returning the field dot product of two length-n vectors; gf28VectorMult (polymorphic over finite n and m) multiplying a length-n row vector by an m-by-n matrix to produce a length-m vector of dot products; gf28MatrixMult (polymorphic over finite n, m, k) multiplying an n-by-m matrix by an m-by-k matrix via row\u2013column dot products. Add properties asserting: gf28Add equals XOR folding with zero; gf28Mult matches polynomial multiplication modulo the irreducible polynomial and satisfies identity, zero annihilator, commutativity, associativity, and distributivity over addition; gf28Pow returns one for zero exponent, returns the base for exponent one, and satisfies the exponent law pow(x, a+b) == pow(x,a)*pow(x,b); gf28Inverse yields a multiplicative inverse for all nonzero inputs; gf28DotProduct is linear in each argument; gf28VectorMult and gf28MatrixMult agree with standard linear algebra semantics (row\u2013matrix and matrix\u2013matrix multiplication, respectively). Use explicit type constraints indicating all size parameters are finite."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::GF28 where\n\ntype GF28 = [8]\n\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\ngf28Mult : GF28 -> GF28 -> GF28\ngf28Mult x y = pmod (pmult x y) irreducible\n\ngf28Pow : GF28 -> [8] -> GF28\ngf28Pow n k = pow k\n  where   sq x  = gf28Mult x x\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult n (sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow x 254\n\ngf28DotProduct : {n} (fin n) => [n]GF28 -> [n]GF28 -> GF28\ngf28DotProduct xs ys = gf28Add [ gf28Mult x y | x <- xs | y <- ys ]\n\ngf28VectorMult : {n, m} (fin n) => [n]GF28 -> [m][n]GF28 -> [m]GF28\ngf28VectorMult v ms = [ gf28DotProduct v m | m <- ms ]\n\ngf28MatrixMult : {n, m, k} (fin m) => [n][m]GF28 -> [m][k]GF28 -> [n][k]GF28\ngf28MatrixMult xss yss = [ gf28VectorMult xs yss' | xs <- xss ]\n   where yss' = transpose yss\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Algorithm.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::AES::Algorithm that contains the following definitions. Import the AES state and round modules to bring in the State and RoundKey types, the message\/state conversion functions, and the final round functions. Declare a numeric type parameter Mode (kind #) with the constraint that Mode is at most 2. Declare two parameter functions encRound and decRound, each taking a round key and a state and returning a state. Define type synonyms: Nk as 4 plus twice Mode, Nr as 6 plus Nk, AESKeySize as 32 times Nk, and KeySchedule as a triple of the initial round key, a sequence of (Nr\u22121) round keys, and the final round key. Define encrypt with type KeySchedule -> [128] -> [128]: given a key schedule and a 128-bit plaintext block, convert the block to a state, XOR with the initial key to form the initial state, iteratively compute intermediate states by applying the encryption round function paired elementwise with the round keys, then apply the final encryption round with the final key and convert the result back to a 128-bit block. Define decrypt with the same type but using the decryption round function and the inverse final round, starting from a 128-bit ciphertext block and producing a 128-bit plaintext block. Provide explicit type signatures for all definitions and use the imported types and functions for states, round keys, and conversions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Algorithm where\n\nimport Primitive::Symmetric::Cipher::Block::AES::State (State, RoundKey, msgToState, stateToMsg)\nimport Primitive::Symmetric::Cipher::Block::AES::Round (AESFinalRound, AESFinalInvRound)\n\nparameter\n\n  type Mode : #\n\n  type constraint (2 >= Mode)\n\n  encRound     : RoundKey -> State -> State\n  decRound     : RoundKey -> State -> State\n\ntype Nk = 4 + 2 * Mode\n\ntype Nr = 6 + Nk\n\ntype AESKeySize  = 32 * Nk\n\ntype KeySchedule = (RoundKey, [Nr-1]RoundKey, RoundKey)\n\nencrypt : KeySchedule -> [128] -> [128]\nencrypt (kInit,ks,kFinal) pt =\n                            stateToMsg (AESFinalRound kFinal (rounds ! 0))\n  where\n  state0 = kInit ^ msgToState pt\n  rounds = [state0] # [ encRound rk s | rk <- ks | s <- rounds ]\n\ndecrypt : KeySchedule -> [128] -> [128]\ndecrypt (kInit, ks, kFinal) ct =\n                          stateToMsg (AESFinalInvRound kFinal (rounds ! 0))\n  where\n  state0 = kInit ^ msgToState ct\n  rounds = [state0] # [ decRound rk s | rk <- ks | s <- rounds ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/SBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::AES::SBox that contains the following definitions: (1) a type alias SBox representing a 256-element sequence of elements in GF(2^8); (2) a constant sbox of type SBox constructed by applying the AES SubByte transformation to every 8-bit value from 0 to 255; (3) a constant sboxInv of type SBox constructed by applying the AES inverse SubByte transformation to every 8-bit value from 0 to 255. Include explicit type signatures for SBox, sbox, and sboxInv that use the GF(2^8) element type. Add properties that verify: (a) for all 8-bit inputs x, indexing sbox at x equals SubByte applied to x; (b) for all 8-bit inputs x, indexing sboxInv at x equals InvSubByte applied to x; and (c) for all 8-bit inputs x, the tables are inverses, i.e., indexing sboxInv at the value from sbox equals x and indexing sbox at the value from sboxInv equals x. Ensure indices are 8-bit values and table sizes are exactly 256. Do not provide implementations of SubByte or InvSubByte; assume they are imported from the AES SubBytes module along with the GF(2^8) type."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::SBox where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::SubBytePlain\n\ntype SBox = [256] GF28\n\nsbox : SBox\nsbox = [ SubByte x | x <- [0 .. 255] ]\n\nsboxInv : SBox\nsboxInv = [ InvSubByte x | x <- [0 .. 255] ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/ExpandKey.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::AES::ExpandKey that contains the following definitions and type constraints for the AES key schedule: import the AES GF(2^8) arithmetic, AES state\/round-key type, and the AES S-box. Declare numeric type parameters Nk and Nr with constraints that each fits within 8 bits, Nk \u2265 1, and Nr \u2265 2. Provide: (1) a function expandKey that takes a 32*Nk-bit key, splits it into Nk words of 4 bytes, derives the infinite key schedule, and returns a triple consisting of the initial round key, the middle Nr\u22121 round keys, and the final round key; (2) a function expandKeyForever that, given Nk words of 4 bytes, produces an infinite sequence of round keys by grouping successive words; (3) a function keyWS that builds an infinite stream of 4\u2011byte words seeded by the initial Nk words and extended by iteratively computing each new word from the previous word and the word Nk positions earlier; (4) a function Rcon that maps an 8\u2011bit index to a 4\u2011byte word whose first byte is the AES round constant computed as the generator raised to (index\u22121) in GF(2^8), with the remaining bytes zero; (5) a function SubWord that applies the AES S\u2011box to each byte of a 4\u2011byte word; (6) a function RotWord that rotates a 4\u2011byte word left by one byte; (7) a function NextWord that forms the next 4\u2011byte word by XORing the word Nk positions back with a mask defined by AES rules: if the index modulo Nk equals zero, use SubWord(RotWord(previous)) XOR the round constant; else if Nk > 6 and the index modulo Nk equals four, use SubWord(previous); otherwise use the previous word. Provide precise Cryptol type signatures reflecting 4\u2011byte words, 8\u2011bit bytes, and infinite streams."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::ExpandKey where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::State\nimport Primitive::Symmetric::Cipher::Block::AES::SubByteSBox\n\nparameter\n\n  type Nk : #\n  type constraint (8 >= width Nk, Nk >= 1)\n\n  type Nr : #\n  type constraint (8 >= width Nr, Nr >= 2)\n\nexpandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)\nexpandKey key = ( keys @ 0\n                , keys @@ ([1 .. (Nr - 1)] : [_][8])\n                , keys @ (`Nr : [8])\n                )\n  where   seed : [Nk][4][8]\n          seed = split (split key)\n          keys = expandKeyForever seed\n\nexpandKeyForever : [Nk][4][8] -> [inf]RoundKey\nexpandKeyForever seed = [ transpose g | g <- split (keyWS seed) ]\n\nkeyWS : [Nk][4][8] -> [inf][4][8]\nkeyWS seed    = xs\n     where xs = seed # [ NextWord i prev old\n                       | i    <- [ `Nk ... ]\n                       | prev <- drop`{Nk-1} xs\n                       | old  <- xs\n                       ]\n\nRcon : [8] -> [4]GF28\nRcon i = [ gf28Pow <| x |> (i-1), 0, 0, 0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord bs = [ SubByte b | b <- bs ]\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nNextWord : [8] ->[4][8] -> [4][8] -> [4][8]\nNextWord i prev old = old ^ mask\n   where mask = if i % nk == 0\n                then SubWord (RotWord(prev)) ^ Rcon (i \/ `Nk)\n                else if (nk > 6) && (i % nk == 4)\n                     then SubWord prev\n                     else prev\n\n         nk = `Nk : [8]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/SubByteSBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::AES::SubByteSBox that imports the AES GF(2^8) field module and the AES S-Box module, and contains exactly two definitions: SubByte and InvSubByte. Provide explicit type signatures for both functions as GF28 -> GF28. Implement SubByte by applying the imported forward S-Box mapping to its input, and implement InvSubByte by applying the imported inverse S-Box mapping to its input. Do not introduce additional logic, constraints, or properties; simply delegate to the corresponding imported S-Box functions. Ensure the module compiles and the functions are total over GF28."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::SubByteSBox where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::SBox\n\nSubByte : GF28 -> GF28\nSubByte b = sbox @ b\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = sboxInv @ b\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Round.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::AES::Round that contains the following definitions: AESRound, AESFinalRound, AESInvRound, AESFinalInvRound, SubBytes, InvSubBytes, ShiftRows, InvShiftRows, MixColumns, InvMixColumns. Import the byte-sized finite-field operations over GF(2^8), the AES State and RoundKey types, and the S-box and its inverse. Use State as a 4\u00d74 array of bytes and RoundKey with the same shape. Specify types for each function accordingly (functions consuming a State and\/or RoundKey and producing a State). Precisely define behavior: SubBytes applies the S-box to every byte in the state; ShiftRows performs a row-wise cyclic left rotation by 0, 1, 2, and 3 positions for rows 0\u20133, respectively; MixColumns left-multiplies the state by a fixed 4\u00d74 matrix over GF(2^8) whose first row is [2, 3, 1, 1] and other rows are right rotations of that row; AESRound computes SubBytes, then ShiftRows, then MixColumns, and finally adds the round key via element-wise XOR. Define AESFinalRound identically but omitting the mix step. For the inverse direction: InvSubBytes applies the inverse S-box element-wise; InvShiftRows performs row-wise cyclic right rotations by 0\u20133 positions; InvMixColumns left-multiplies by the inverse matrix with first row [0x0e, 0x0b, 0x0d, 0x09] and other rows as right rotations; AESInvRound performs inverse shift, inverse substitute, add round key via XOR, then inverse mix; AESFinalInvRound is the same but omits the inverse mix. Constrain all matrix multiplications to GF(2^8) and make XOR and shifts element-wise with correct widths."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Round where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::State\nimport Primitive::Symmetric::Cipher::Block::AES::SubByteSBox\n\nAESRound : RoundKey -> State -> State\nAESRound rk s = rk ^ MixColumns (ShiftRows (SubBytes s))\n\nSubBytes : State -> State\nSubBytes state = [ [ SubByte b | b <- row ] | row <- state ]\n\nShiftRows : State -> State\nShiftRows state = [ row <<< i | row <- state | i : [2] <- [0 .. 3] ]\n\nMixColumns : State -> State\nMixColumns state = gf28MatrixMult m state\n    where m = [ [2,3,1,1] >>> i | i <- [0 .. 3] ]\n\nAESFinalRound : RoundKey -> State -> State\nAESFinalRound rk s = rk ^ ShiftRows (SubBytes s)\n\nAESInvRound : RoundKey -> State -> State\nAESInvRound rk s = InvMixColumns (rk ^ InvSubBytes (InvShiftRows s))\n\nInvSubBytes : State -> State\nInvSubBytes state = [ [ InvSubByte b | b <- row ] | row <- state ]\n\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> shiftAmount | row <- state\n                                           | shiftAmount : [2] <- [0 .. 3]\n                     ]\n\nInvMixColumns : State -> State\nInvMixColumns state = gf28MatrixMult m state\n    where m = [[0x0e, 0x0b, 0x0d, 0x09] >>> i | i <- [0 .. 3] ]\n\nAESFinalInvRound : RoundKey -> State -> State\nAESFinalInvRound rk s = rk ^ InvSubBytes (InvShiftRows s)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/SubBytePlain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::AES::SubBytePlain that contains the following definitions: SubByte, InvSubByte, xformByte, and xformByte'. Import the AES GF(2^8) module to use the 8-bit field type and its addition and multiplicative inverse operations. Provide type signatures stating each function maps a single GF(2^8) element to another. Implement SubByte by first computing the multiplicative inverse in GF(2^8) (with zero mapped to zero as per AES) and then applying an affine transform over GF(2) on the 8-bit vector: XOR the byte with its 8-bit right-rotations by 4, 5, 6, and 7 bits, then XOR the constant 0x63. Implement InvSubByte by first applying the inverse affine transform (XOR the 8-bit right-rotations by 2, 5, and 7 bits, then XOR the constant 0x05) and then computing the multiplicative inverse in GF(2^8). Implement xformByte and xformByte' as the affine and inverse-affine helpers respectively, using GF(2^8) addition (bitwise XOR) and 8-bit rotate-right operations; ensure all intermediate values are constrained to 8-bit field elements. Define properties that, for all GF(2^8) values b: InvSubByte(SubByte(b)) == b and SubByte(InvSubByte(b)) == b, and that xformByte'(xformByte(b)) == b and xformByte(xformByte'(b)) == b. Include type signatures for all functions and properties, and ensure no implicit size polymorphism is used (all bytes are exactly 8 bits)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::SubBytePlain where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\n\nSubByte : GF28 -> GF28\nSubByte b = xformByte (gf28Inverse b)\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = gf28Inverse (xformByte' b)\n\n\/\/ The affine transform and its inverse\nxformByte : GF28 -> GF28\nxformByte b = gf28Add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n   where c = 0x63\n\nxformByte' : GF28 -> GF28\nxformByte' b = gf28Add [(b >>> 2), (b >>> 5), (b >>> 7), d] where d = 0x05\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/TBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::AES::TBox that contains the following: imports for GF(2^8) arithmetic, AES state operations (including row-shift permutations), S-boxes, and round-key utilities; a type alias TBox as four tables, each mapping all byte values to a vector of four GF(2^8) elements; a function mkTBox that, given four GF(2^8) coefficients and an S-box, constructs the four tables by computing coefficient-by-byte products in GF(2^8) for each S-box output and generating three additional tables by successive one-byte rotations of each 4-element vector; constants for the forward and inverse T-box sets built by mkTBox using the standard AES MixColumns and inverse MixColumns coefficients with the corresponding S-box; a function genRound with a type signature taking a state permutation function, a T-box set, a round key, and a state, returning a state; genRound must apply the permutation to the input state, for each column perform table lookups indexed by the column\u2019s bytes in the corresponding table, XOR-reduce the four resulting 4-element vectors per column position in GF(2^8), reassemble columns via transposition, and XOR with the round key to yield the next state; functions AESRound and AESInvRound that specialize genRound with the forward and inverse row-shift permutations and the respective T-box sets; and a function makeDecKey that transforms an encryption key schedule triple into a decryption schedule by swapping the endpoints, reversing the middle list, and applying inverse MixColumns to each middle round key. Provide precise type signatures for mkTBox, genRound, AESRound, AESInvRound, makeDecKey, and the TBox alias using the State, RoundKey, and SBox types from the imported modules."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::TBox where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::State\nimport Primitive::Symmetric::Cipher::Block::AES::SBox\nimport Primitive::Symmetric::Cipher::Block::AES::Round\n\nAESRound    rk st = genRound ShiftRows    tbox    rk st\nAESInvRound rk st = genRound InvShiftRows tboxInv rk st\n\nmakeDecKey (a,xs,b) = (b, [ InvMixColumns rk | rk <- reverse xs ], a)\n\ngenRound : (State -> State) -> TBox -> RoundKey -> State -> State\ngenRound shift boxes rk st =\n  rk ^ transpose [ add [ box @ i | box <- boxes | i <- col ]\n                 | col <- transpose (shift st) ]\n  where add [ a, b, c, d ] = a ^ b ^ c ^ d\n\ntype TBox = [4][256][4]GF28\n\ntbox : TBox\ntbox = mkTBox [ 0x02, 0x01, 0x01, 0x03 ] sbox\n\ntboxInv : TBox\ntboxInv = mkTBox [ 0x0e, 0x09, 0x0d, 0x0b ] sboxInv\n\nmkTBox : [4]GF28 -> SBox -> TBox\nmkTBox seed box = [ [ a >>> i | a <- t0 ] | i <- [0 .. 3] ]\n  where\n  t0 = [ [ gf28Mult c s | c <- seed ] | s <- box ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/State.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::AES::State that contains the following definitions: import the finite-field element type for bytes from the AES GF(2^8) module; a constant giving the AES block column count as 4; a type synonym for the AES state as a 4-by-4 matrix of GF(2^8) elements; a type synonym for a round key equal to the state type; a function that takes a 128-bit block and returns the state by interpreting the 16 bytes in column-major AES layout (four columns of four bytes, yielding a 4\u00d74 matrix of GF(2^8)); a function that takes a state and returns the 128-bit block by reversing that layout; and two properties: one that, for all 128-bit inputs, composing the message-to-state function with the state-to-message function yields the original 128-bit block, and one that, for all states, composing the state-to-message function with the message-to-state function yields the original state. Provide precise type signatures for all definitions and ensure the state element type is the GF(2^8) byte type imported from the AES field module."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::State where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\n\ntype State       = [4][Nb]GF28\ntype Nb          = 4\ntype RoundKey    = State\n\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Hash\/HMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Keyless::Hash::HMAC that imports Primitive::Keyless::Hash::SHA384 and contains the following definitions: (1) a function key_init with a polymorphic finite key length parameter that takes a sequence of key bytes and returns exactly 128 bytes: if the key length is at most 128, right-pad with zeros to 128; otherwise compute the SHA-384 digest of the key to 48 bytes and then right-pad with zeros to 128. (2) a record type HMACState with three fields i_ctx, o_ctx, and md_ctx, each of the SHA state type provided by the import. (3) a function HMACInit that, given a key, derives a 128-byte key block via key_init, forms inner and outer pads by XORing each byte with 0x36 and 0x5c respectively, initializes i_ctx and md_ctx by updating the SHA-384 initial state with the inner pad, and initializes o_ctx by updating the initial state with the outer pad. (4) a function HMACUpdate that, for any finite message length, returns a new state where only md_ctx is updated with the provided message bytes; i_ctx and o_ctx are unchanged. (5) a function HMACFinal that finalizes md_ctx to 48 digest bytes, updates o_ctx with this inner digest, and returns the 48-byte final digest of the updated o_ctx. (6) a function HMAC that, for any finite key and message lengths, returns the 48-byte tag computed by invoking HMACInit, then HMACUpdate with the message, then HMACFinal. Also define properties that: (a) for any key, HMACInit produces i_ctx equal to md_ctx; (b) for any state and message, HMACUpdate leaves i_ctx and o_ctx unchanged; (c) for any key and message, HMAC equals HMACFinal(HMACUpdate(HMACInit key) message). Use [n][8] types for byte vectors and enforce fin constraints on all size parameters."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::HMAC where\n\nimport Primitive::Keyless::Hash::SHA384\n\nkey_init : {key_size} (fin key_size) => [key_size][8] -> [128][8]\nkey_init key =\n  take`{128} (if `key_size <= 128\n              then key # (zero : [inf][8])\n              else (split`{48} (SHAImp key)) # (zero : [inf][8]))\n\ntype HMACState = { i_ctx  : SHAState\n                 , o_ctx  : SHAState\n                 , md_ctx : SHAState\n                 }\n\nHMACInit : {key_size} (fin key_size) => [key_size][8] -> HMACState\nHMACInit key =\n  { i_ctx  = i_state\n  , o_ctx  = SHAUpdate SHAInit opad\n  , md_ctx = i_state\n  }\n  where key'    = key_init key\n        ipad    = [ k ^ 0x36 | k <- key' ]\n        opad    = [ k ^ 0x5c | k <- key' ]\n        i_state = SHAUpdate SHAInit ipad\n\n\/\/ HMAC-SHA384 update function\nHMACUpdate : {n} (fin n) => HMACState -> [n][8] -> HMACState\nHMACUpdate state data = { i_ctx = state.i_ctx\n                        , o_ctx = state.o_ctx\n                        , md_ctx = SHAUpdate state.md_ctx data\n                        }\n\n\/\/ HMAC-SHA384 final function\nHMACFinal : HMACState -> [48][8]\nHMACFinal state = split`{48} (SHAFinal o_ctx')\n  where o_ctx' = SHAUpdate state.o_ctx buf\n        buf = split`{48} (SHAFinal state.md_ctx)\n\n\/\/ HMAC-SHA384 implementation\nHMAC : {n, m} (fin n, fin m) => [n][8] -> [m][8] -> [48][8]\nHMAC key data = HMACFinal (HMACUpdate (HMACInit key) data)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Hash\/SHA1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Keyless::Hash::SHA1 that contains the following definitions to fully specify SHA-1 and its validation tests: 1) A top-level digest function sha1 with a size parameter for message length in bytes, constrained so the bit-length fits in 64 bits; it accepts a sequence of 8-bit bytes and returns a 160-bit digest, delegating to a pre-padded block processor. 2) A block-processing function sha1' with a finite block count parameter; it accepts a sequence of 512-bit blocks and returns the 160-bit digest by iterating a compression step starting from the standard initial five 32-bit words and folding over all blocks. 3) A padding function pad with constraints that the message length is finite and its bit-length width is at most 64; it appends a single \u20181\u2019 bit, enough \u20180\u2019 bits, and the 64-bit big-endian original-length encoding to yield an integral number of 512-bit blocks, and outputs the resulting sequence of 512-bit blocks. 4) A round function f taking an 8-bit round index and three 32-bit words, returning a 32-bit word, defined piecewise for rounds 0\u201319, 20\u201339, 40\u201359, and 60\u201379 using the standard SHA-1 boolean formulas, and signaling an error for out-of-range indices. 5) A constant Ks of 80 32-bit words containing the four SHA-1 round constants expanded across their respective round ranges. 6) A compression function block that takes the current five 32-bit state words and sixteen 32-bit message words and returns the updated state after 80 rounds, including the message schedule expansion by XORs and 1-bit left-rotate, the per-round updates\/rotations, and modular additions. 7) Boolean constants t0, t1, t2, t3 that compare the digest of the empty string, \u201cabc\u201d, the FIPS long test string, and one million \u2018a\u2019 characters against their known SHA-1 digests. 8) A property testsPass that is the conjunction of t0, t1, t2, and t3."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA1 where\n\nsha1 : {n} (width (8*n) <= 64) => [n][8] -> [160]\nsha1 msg = sha1' pmsg\n    where\n        pmsg = pad(join(msg))\n\nsha1' : {chunks} (fin chunks) => [chunks][512] -> [160]\nsha1' pmsg = join (Hs!0)\n  where\n    Hs = [[0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]] #\n         [ block(H, split(M))\n         | H <- Hs\n         | M <- pmsg\n         ]\n\n\/*\nAs a summary, a \"1\" followed by m \"0\"s followed by a 64-\n   bit integer are appended to the end of the message to produce a\n   padded message of length 512 * n.  The 64-bit integer is the length\n   of the original message.  The padded message is then processed by the\n   SHA-1 as n 512-bit blocks.\n*\/\n\npad : {msgLen}\n     ( fin msgLen\n     , 64 >= width msgLen                             \/\/ message width fits in a word\n     )\n     => [msgLen] -> [(msgLen + 65) \/^ 512][512]\npad msg = split (msg # [True] # (zero:[padLen]) # (`msgLen:[64]))\n    where type padLen     = (msgLen + 65) %^ 512\n\nf : ([8], [32], [32], [32]) -> [32]\nf (t, x, y, z) =\n       if (0 <= t)  \/\\ (t <= 19) then (x && y) ^ (~x && z)\n        | (20 <= t) \/\\ (t <= 39) then x ^ y ^ z\n        | (40 <= t) \/\\ (t <= 59) then (x && y) ^ (x && z) ^ (y && z)\n        | (60 <= t) \/\\ (t <= 79) then x ^ y ^ z\n        else error \"f: t out of range\"\n\nKs : [80][32]\nKs = [ 0x5a827999 | t <- [0..19]  ]\n   # [ 0x6ed9eba1 | t <- [20..39] ]\n   # [ 0x8f1bbcdc | t <- [40..59] ]\n   # [ 0xca62c1d6 | t <- [60..79] ]\n\nblock : ([5][32], [16][32]) -> [5][32]\nblock ([H0, H1, H2, H3, H4], M) =\n [(H0+As@80), (H1+Bs@80), (H2+Cs@80), (H3+Ds@80), (H4+Es@80)]\n  where\n    Ws : [80][32]\n    Ws = M # [ (W3 ^ W8 ^ W14 ^ W16) <<< 1\n             | W16 <- drop`{16 - 16} Ws\n             | W14 <- drop`{16 - 14} Ws\n             | W8  <- drop`{16 - 8}  Ws\n             | W3  <- drop`{16 - 3}  Ws\n             | t <- [16..79]\n             ]\n    As = [H0] # TEMP\n    Bs = [H1] # As\n    Cs = [H2] # [ B <<< 30 | B <- Bs ]\n    Ds = [H3] # Cs\n    Es = [H4] # Ds\n    TEMP : [80][32]\n    TEMP = [ (A <<< 5) + f(t, B, C, D) + E + W + K\n           | A <- As | B <- Bs | C <- Cs | D <- Ds | E <- Es\n           | W <- Ws | K <- Ks\n           | t <- [0..79]\n           ]\n\nt0 = sha1 \"\" == 0xda39a3ee5e6b4b0d3255bfef95601890afd80709\n\n\/\/ Sample messages and their digests from FIPS180-1 appendix.\n\nt1 = sha1 \"abc\" == 0xA9993E364706816ABA3E25717850C26C9CD0D89D\nt2 = sha1 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\" ==\n     0x84983E441C3BD26EBAAE4AA1F95129E5E54670F1\nt3 = sha1 [ 'a' | i <- [1..1000000] ] ==\n     0x34AA973CD4C4DAA4F61EEB2BDBAD27316534016F\n\nproperty testsPass = and [t0, t1, t2, t3]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Hash\/MD5.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Keyless::Hash::MD5 that contains the following definitions: (1) byte-order utilities for 32- and 64-bit words that reverse byte order; (2) generic sequence combinators map and a left fold that accumulates across an n-element sequence with a finite-length constraint; (3) a test helper that computes the MD5 of a byte sequence by concatenating its bytes; (4) reference wrappers that adapt inputs\/outputs between bitvectors and byte arrays via grouping and byte-reversal; (5) a type alias for the MD5 state as a tuple of four 32-bit words; (6) the MD5 function that takes an a-bit message (with the constraint that the bit-length a is representable within 64 bits), pads it per the MD5 spec (1-bit, zeros, then a 64-bit length field; total length \u2261 448 mod 512), partitions into 512-bit blocks, iteratively processes each block starting from the standard initial state, and returns a 128-bit digest; (7) the standard initial state constants; (8) block decoding that splits a 512-bit block into sixteen 32-bit words with appropriate byte-order conversion; (9) digest emission that concatenates the four state words after converting to network byte order; (10) the round computation: a 64-step transformation over the state using the MD5 round functions F, G, H, I, a per-step message word selected by a fixed permutation schedule, a 32-bit additive constant table (the sine table), and per-step left-rotation amounts; model the interdependent a\/b\/c\/d streams and return the state after 64 steps; (11) the per-step function and selector that chooses F\/G\/H\/I based on the step index; (12) constants: the 64-element rotation schedule, the 4\u00d716 message index permutations, and the 64-entry 32-bit sine table as defined by the MD5 standard; (13) boolean constants r0\u2013r8 that check the digest of standard RFC 1321 test messages against their known MD5 values; (14) define a property testsPass that is the conjunction of r0\u2013r8."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::MD5 where\n\nntohl : [32] -> [32]\nntohl w = join (reverse (groupBy`{8} w))\n\nhtonl : [32] -> [32]\nhtonl w = join (reverse (groupBy`{8} w))\n\nhtonll : [64] -> [64]\nhtonll w = join (reverse (groupBy`{8} w))\n\nmap : {n, a, b} (a -> b) -> [n]a -> [n]b\nmap f xs = [ f x | x <- xs ]\n\nfoldl : {n, a, b} (fin n) => a -> (a -> b -> a) -> [n]b -> a\nfoldl seed f xs = res ! 0\n  where res = [seed] # [ f a x | a <- res\n                               | x <- xs\n                       ]\n\ntest s = md5 (join s)\n\nmd5_ref : [16][8] -> [16][8]\nmd5_ref msg = map reverse (groupBy`{8} (md5 (join (map reverse msg))))\n\nmd5_ref' : [128] -> [128]\nmd5_ref' msg = join (md5_ref (groupBy`{8} msg))\n\ntype MD5State = ([32],[32],[32],[32])\n\nmd5 : {a} (64 >= width a) => [a] -> [128]\nmd5 msg = md5output finalState\n    where\n      type p = (a + 65) %^ 512\n      type b = (a + 65) \/^ 512\n\n      finalState : MD5State\n      finalState = foldl initialMD5State processBlock blocks\n\n      blocks : [b][512]\n      blocks = groupBy`{512} (pad `{a,p} msg)\n\n      add : MD5State -> MD5State -> MD5State\n      add (a, b, c, d) (e, f, g, h) = (a + e, b + f, c + g, d + h)\n\n      processBlock : MD5State -> [512] -> MD5State\n      processBlock st blk = add st (computeRounds (decodeBlock blk) st)\n\ninitialMD5State : MD5State\ninitialMD5State = (A, B, C, D)\n where\n   f x = ntohl (join x)\n   A = f [ 0x01, 0x23, 0x45, 0x67 ]\n   B = f [ 0x89, 0xAB, 0xCD, 0xEF ]\n   C = f [ 0xFE, 0xDC, 0xBA, 0x98 ]\n   D = f [ 0x76, 0x54, 0x32, 0x10 ]\n\ndecodeBlock : [512] -> [16][32]\ndecodeBlock s = map ntohl (groupBy`{32} s)\n\nmd5output : MD5State -> [128]\nmd5output (a,b,c,d) = htonl a # htonl b # htonl c # htonl d\n\npad : {a, p} (fin p, 64 >= width a) => [a] -> [65 + (a + p)]\npad msg =\n    msg # [True] # zero # htonll sz\n    where\n      sz : [64]\n      sz = length msg\n\ncomputeRounds : [16][32] -> MD5State -> MD5State\ncomputeRounds msg st = rounds (msg,st) @ 64\n\nrounds : ([16][32], MD5State) -> [65]MD5State\nrounds (msg, (a0, b0, c0, d0)) =\n    [ (a, b, c, d) | a <- as\n                   | b <- bs\n                   | c <- cs\n                   | d <- ds\n    ]\n    where\n      bs =\n          [b0] #\n          [box (i, a, b, c, d, m, t, s) | i <- [0 .. 63]\n                                        | a <- as\n                                        | b <- bs\n                                        | c <- cs\n                                        | d <- ds\n                                        | m <- join [m @@ p | m <- [msg, msg, msg, msg]\n                                                            | p <- permutes\n                                                    ]\n                                        | t <- sineTbl\n                                        | s <- s_constants\n          ]\n      cs = [c0] # bs\n      ds = [d0] # cs\n      as = [a0] # ds\n\ns_constants : [64][6]\ns_constants =\n   repeat4 [7, 12, 17, 22] #\n   repeat4 [5,  9, 14, 20] #\n   repeat4 [4, 11, 16, 23] #\n   repeat4 [6, 10, 15, 21]\n where\n   repeat4 abcd = abcd # abcd # abcd # abcd\n\npermutes : [4][16][4]\npermutes =\n    [ [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15]\n    , [ 1,  6, 11,  0,  5, 10, 15,  4,  9, 14,  3,  8, 13,  2,  7, 12]\n    , [ 5,  8, 11, 14,  1,  4,  7, 10, 13,  0,  3,  6,  9, 12, 15,  2]\n    , [ 0,  7, 14,  5, 12,  3, 10,  1,  8, 15,  6, 13,  4, 11,  2,  9]\n    ]\n\nbox : ([6], [32], [32], [32], [32], [32], [32], [6]) -> [32]\nbox (i, a, b, c, d, m, t, s) =\n    b + (a + boxfunc (i, b, c, d) + m + t <<< s)\n\nboxfunc : ([6],[32],[32],[32]) -> [32]\nboxfunc (i, b, c, d) =\n    if i < 16 then F (b, c, d) else\n    if i < 32 then G (b, c, d) else\n    if i < 48 then H (b, c, d) else\n                   I (b, c, d)\n\nF : ([32], [32], [32]) -> [32]\nF (x, y, z) = x && y || (~x) && z\n\nG : ([32], [32], [32]) -> [32]\nG (x, y, z) = x && z || y && ~z\n\nH : ([32], [32], [32]) -> [32]\nH (x, y, z) = x ^ y ^ z\n\nI : ([32], [32], [32]) -> [32]\nI (x, y, z) = y ^ (x || ~z)\n\nsineTbl : [64][32]\nsineTbl =\n    [0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE, 0xF57C0FAF,\n     0x4787C62A, 0xA8304613, 0xFD469501, 0x698098D8, 0x8B44F7AF,\n     0xFFFF5BB1, 0x895CD7BE, 0x6B901122, 0xFD987193, 0xA679438E,\n     0x49B40821, 0xF61E2562, 0xC040B340, 0x265E5A51, 0xE9B6C7AA,\n     0xD62F105D, 0x02441453, 0xD8A1E681, 0xE7D3FBC8, 0x21E1CDE6,\n     0xC33707D6, 0xF4D50D87, 0x455A14ED, 0xA9E3E905, 0xFCEFA3F8,\n     0x676F02D9, 0x8D2A4C8A, 0xFFFA3942, 0x8771F681, 0x6D9D6122,\n     0xFDE5380C, 0xA4BEEA44, 0x4BDECFA9, 0xF6BB4B60, 0xBEBFBC70,\n     0x289B7EC6, 0xEAA127FA, 0xD4EF3085, 0x04881D05, 0xD9D4D039,\n     0xE6DB99E5, 0x1FA27CF8, 0xC4AC5665, 0xF4292244, 0x432AFF97,\n     0xAB9423A7, 0xFC93A039, 0x655B59C3, 0x8F0CCC92, 0xFFEFF47D,\n     0x85845DD1, 0x6FA87E4F, 0xFE2CE6E0, 0xA3014314, 0x4E0811A1,\n     0xF7537E82, 0xBD3AF235, 0x2AD7D2BB, 0xEB86D391]\n\nr0 = test \"\"\n  == 0xd41d8cd98f00b204e9800998ecf8427e\n\nr1 = test \"a\"\n  == 0x0cc175b9c0f1b6a831c399e269772661\n\nr2 = test \"abc\"\n  == 0x900150983cd24fb0d6963f7d28e17f72\n\nr3 = test \"message digest\"\n  == 0xf96b697d7cb7938d525a2f31aaf161d0\n\nr4 = test \"abcdefghijklmnopqrstuvwxyz\"\n  == 0xc3fcd3d76192e4007dfb496cca67e13b\n\nr5 = test \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n  == 0xd174ab98d277d9f5a5611c2c9f419d9f\n\nr6 = test \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n  == 0x57edf4a22be3c955ac49da2e2107b67a\n\nr7 = test \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n  == 0x8215ef0796a20bcaaae116d3876c664a\n\nr8 = test (join (repeat`{1000000} \"a\") )\n  == 0x7707d6ae4e027c70eea2a935c2296f21\n\nproperty testsPass = and [ r0, r1, r2, r3, r4, r5, r6, r7, r8 ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Generator\/DRBG.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Keyless::Generator::DRBG that contains: (1) an import of an AES block-cipher module; (2) type aliases for AES key length, 128-bit block length, 256-bit seed length, a reseed limit equal to 2 raised to 35, and byte\/word sizes used by the DRBG; (3) a cipher context record holding a key of the AES key length; (4) a DRBG state record with a 64-bit byte counter, a cipher context, and a 128-bit counter value; (5) a function that encrypts one 128-bit block with a given key using AES; (6) a function that, for finite n and blocks with 1 \u2264 n \u2264 8192 and n equal to block length times blocks, produces n output bits by encrypting successive counter values and returns the updated state with the byte counter increased by blocks times the block size (in bytes) and the counter advanced by blocks; (7) an instantiate function that takes a seed-length entropy input and a finite-length personalization string, pads or truncates the personalization string to the seed length, and initializes state by reseeding from an all-zero state; (8) a reseed function (with the personalization size not exceeding the seed length) that updates the state using the XOR of entropy and the personalization string padded to the seed length, and resets the byte counter to zero; (9) an uninstantiate function that returns the all-zero state; (10) a generate function with finite n and blocks satisfying tight bounds around ceil(n\/block length) that optionally reseeds when a flag is set or when the byte counter plus the upcoming output and a safety margin reach the reseed limit, then emits n bits and updates state via an update with zero additional data; (11) an update function that emits enough encryption blocks to cover the seed length, XORs with supplied data, splits into a new key and counter value, and increments the byte counter accordingly; (12) constants encoding known-answer tests for instantiate, reseed, and two generate scenarios, along with Boolean checks that keys, counters, and returned bits match expectations; and (13) define a property that is the conjunction of all test checks."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Generator::DRBG where\n\nimport Primitive::Symmetric::Cipher::Block::AES\n\ntype keylen   = AESKeySize type blocklen = 128 type seedlen  = 256 type reseed_limit = 2 ^^ 35 \ntype blocksize = 16 type keysize = 32 type seedsize = 48\n\ntype cipher_ctx = { key : [keylen] }\n\nblock_encrypt : [keylen] -> [blocklen] -> [blocklen]\nblock_encrypt key data = aesEncrypt(data, key)\n\ntype s2n_drbg =\n  { bytes_used : [64]\n  , ctx : cipher_ctx\n  , v : [blocklen]\n  }\n\ndrbg_generate_internal : {n, blocks}\n                         ( fin n, fin blocks, n >= 1, n <= 8192\n                         , n == blocklen * blocks)\n                      => s2n_drbg\n                      -> ([n], s2n_drbg)\ndrbg_generate_internal drbg =\n  (join [ block_encrypt drbg.ctx.key (drbg.v + i) | i <- [1 .. blocks]], drbg')\n    where drbg' = { bytes_used = drbg.bytes_used + `(blocks * blocksize)\n                  , ctx = drbg.ctx\n                  , v = drbg.v + `blocks\n                  }\n\ndrbg_instantiate : {ps_size}\n                   (fin ps_size)\n                => [seedlen]\n                -> [ps_size]\n                -> s2n_drbg\ndrbg_instantiate entropy ps = drbg_reseed zero entropy ps'\n  where\n    \/* pad ps with zeros if needed to reach seedlen\n       otherwise truncate to seedlen *\/\n    ps' = take `{seedlen} (ps # (zero : [seedlen]))\n\ndrbg_reseed : {ps_size}\n              (ps_size <= seedlen)\n           => s2n_drbg\n           -> [seedlen]\n           -> [ps_size]\n\t   -> s2n_drbg\ndrbg_reseed drbg entropy ps = drbg''\n  where\n    drbg' = drbg_update (entropy ^ (ps # zero)) drbg\n    drbg'' = { v = drbg'.v, ctx = drbg'.ctx, bytes_used = 0}\n\ndrbg_uninstantiate : s2n_drbg -> s2n_drbg\ndrbg_uninstantiate drbg = zero\n\n\/* This is the spec of the s2n code, in that it reseeds automatically\n   if reseed is required. This is in opposition to the spec, which\n   requires an error code.\n\n   We are curious about why s2n_drbg counts a number of bytes used,\n   while the spec tracks a number of calls to generate. We don't\n   belive that this is buggy behavior, since if we call the maximum\n   size with generate each time, we will reseed before the spec would\n   require it. *\/\ndrbg_generate : {n, blocks} (fin n, fin blocks, n >= 1, n <= 8192,\n                             blocks * blocklen >= n,\n                             (blocks - 1) * blocklen <= n - 1) =>\n                s2n_drbg -> [seedlen] -> Bit ->\n                ([n], s2n_drbg)\ndrbg_generate drbg entropy reseed_p = (take enc_result, drbg_out)\n  where\n        drbg_r =\n      if reseed_p \\\/ drbg.bytes_used + `n * 8 + `blocklen * 8 >= `reseed_limit then\n        drbg_reseed drbg entropy (zero : [256])\n      else drbg\n        (enc_result, drbg_v) = drbg_generate_internal `{blocks=blocks} drbg_r\n        drbg_out = drbg_update zero drbg_v\n\ndrbg_update : [seedlen] -> s2n_drbg -> s2n_drbg\ndrbg_update data drbg = result\n  where\n            type blocks = (seedlen + blocklen -1)\/blocklen\n        (enc_result, _) = drbg_generate_internal `{blocks=blocks} drbg\n        data_xor = (take enc_result) ^ data\n            result = { bytes_used = drbg.bytes_used + (`blocks * `blocksize)\n             , ctx = { key = take data_xor }\n             , v = drop data_xor\n             }\n\ntestInstantiate0 = {entropy = 0xed1e7f21ef66ea5d8e2a85b9337245445b71d6393a4eecb0e63c193d0f72f9a9,\n                    pString = zero : [0],\n                        Key = 0xb5fc83ef1518da3cb85598ee9795001e,\n                         \tV = 0x58f90cf75af84f221514db847ec007d1}\n\ntestInstantiatedrbg0 = drbg_instantiate`{ps_size=0} testInstantiate0.entropy testInstantiate0.pString\n\ntestInstantiate0Pass = testInstantiatedrbg0.v == testInstantiate0.V \/\\ testInstantiatedrbg0.ctx.key == testInstantiate0.Key\n\ntestReseed0 = {entropyReseed = 0x303fb519f0a4e17d6df0b6426aa0ecb2a36079bd48be47ad2a8dbfe48da3efad,\n            \t           Key = 0x577a79cc512258c3e255fcf3f4cf0c1a,\n                        \t V = 0x531599fd616f33678192928bf771bb2b}\n\ntestReseed0Pass = drbgreseed.v == testReseed0.V \/\\ drbgreseed.ctx.key == testReseed0.Key\n                where drbgreseed = drbg_reseed`{ps_size=0} testInstantiatedrbg0 testReseed0.entropyReseed zero\n\ntestGenerate0 = {\tKey = 0xac373fb3773597b0d6cb6f37e6b59293,\n                \tV   = 0xcd9bf115d35c60cbf7f2ebac8e43f53b}\n\ntestGeneratedrbg0 = (drbg_generate`{n=512} testInstantiatedrbg0 testReseed0.entropyReseed True).1\n\ntestGenerate0Pass = testGeneratedrbg0.v == testGenerate0.V \/\\ testGeneratedrbg0.ctx.key == testGenerate0.Key\n\ntestGenerateSnd0 = {returnedBits = 0xf80111d08e874672f32f42997133a5210f7a9375e22cea70587f9cfafebe0f6a6aa2eb68e7dd9164536d53fa020fcab20f54caddfab7d6d91e5ffec1dfd8deaa,\n                 \tKey = 0x964c57946a104aa93fc3c2137bb9bc11,\n                 \tV   = 0x9d58008033ac007c9ead254bfa8de2b6}\n\ntestGenerateSnd0Pass = and [ result == testGenerateSnd0.returnedBits\n                           , drbg.ctx.key == testGenerateSnd0.Key\n                           , drbg.v == testGenerateSnd0.V ]\n                     where (result,drbg) = drbg_generate`{n=512} testGeneratedrbg0 zero False\n\nproperty testsPass = and [testInstantiate0Pass, testReseed0Pass, testGenerate0Pass, testGenerateSnd0Pass]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/DilithiumR1Int.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::DilithiumR1Int that contains: (1) constants for modulus, dimensions, bounds, and packing bit-widths consistent with the Dilithium R1 parameter set; (2) type synonyms for polynomials and vectors over the modulus, including integer and modular forms, NTT-domain types, and matrix types; (3) record types for public and secret keys; (4) function Gen that derives a key pair from a 256-bit seed using SHAKE-based expansion, matrix expansion, centered sampling with parameter eta, NTT\/Inverse NTT, vector\/matrix multiplications, power-of-two rounding, and collision-resistant hashing to form public and secret key fields; (5) function Sign with a size-parameterized message input (finite, at least one byte) that iteratively samples a mask, computes NTT-domain products, forms a challenge hash, computes z and decomposition components, enforces infinity-norm and hint-weight bounds via a loop condition, and returns the signature tuple (z, hint matrix, and challenge polynomial); (6) function Verify with the same message-length constraints that recomputes A and the message digest, checks the z bound, recomputes the challenge from the hinted high bits, and verifies the hint weight; (7) a top-level Boolean constant that performs a known-answer test for key generation by seeding Gen, packing and concatenating fields, and comparing against imported test vectors; (8) private helpers for packing\/unpacking, sampling in ranges, challenge construction, mask expansion, SHAKE-based CRH, matrix expansion, element extraction, rounding\/decomposition\/high\/low bits, hint creation\/use, conversions between integer and modular polynomials, centered modular reduction, random stream filtering, NTT and inverse NTT with Dilithium-specific ordering, NTT-domain operations, polynomial\/vector arithmetic, and infinity-norm computations. Provide precise Cryptol type signatures with size constraints for all public and private definitions. Import the required SHA3\/KECCAK utilities and any test-vector modules used by the known-answer test."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::DilithiumR1Int where\n\nimport Primitive::Keyless::Hash::keccak as SHA3\nimport Common::utils\nimport Primitive::Asymmetric::Signature::testDilithium\nimport Primitive::Asymmetric::Signature::signFinal\n\nimport Primitive::Asymmetric::Signature::testCase2\n\ntype q = 8380421\ntype n = 256 \ntype k = 5\ntype l = 4\nd      = 14\nwc     = 60\ngamma1 = ((`q : Integer) - 1) \/ 16 \ngamma2 = (gamma1 \/ 2)\neta    = 5\nbeta   = 275\nomega  = 96 : Integer\nqbits  = 23\n\nrootOfUnity    = 1753 : (Z q)\nrootOfUnityInv = 731434 : (Z q)\nninv           = 8347681 : (Z q)\n\ntype intPoly        = [n]Integer\ntype intPolyVec dim = [dim]intPoly\n\ntype poly        = [n](Z q) type polyVec dim = [dim]poly \n\ntype nttPoly          = [n](Z q)\ntype nttVec dim       = [dim]nttPoly\ntype nttMat dim1 dim2 = [dim1](nttVec dim2)\n\ntype PublicKey = {rho : [256], t1 : intPolyVec k} \ntype SecretKey = {rho : [256]\n                 , K  : [256]\n                 , tr : [384]\n                 , s1 : polyVec l\n                 , s2 : polyVec k\n                 , t0 : intPolyVec k}\n\nGen : [256] -> (PublicKey,SecretKey)\nGen seed = (pk, sk)\n    where\n      randoms = split`{3} (join (SHA3::toBytes (take`{768} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))\n      (rho, rho', K) = (randoms@0, randoms@1, randoms@2)\n      A       = ExpandA rho\n      s1      = PolyUniformEtaV`{dim=l} rho' zero\n      s2      = PolyUniformEtaV`{dim=k} rho' (zero + `l)\n      s1ntt   = map ntt s1\n      As1     = map nttinv (nttMatMul A s1ntt)\n      t       = paddV As1 s2\n      (t1,t0) = Power2RoundV t\n      tr      = CRH (rho#(pack_t1 t1))\n      pk      = { rho = rho, t1 = t1}\n      sk      = { rho = rho, K = K, tr = tr, s1 = s1, s2 = s2, t0 = t0}\n\n\/\/ Known Answer Test\n\/\/ To check this property, it is necessary to import testDilithium\n\ntest_key_gen = (pk.rho#(pack_t1 pk.t1) == testCase0.pk)\n\/\/\/\\\n  \/\/  ((sk.rho#sk.K#sk.tr#(pack_polyeta sk.s1)#(pack_polyeta sk.s2)#(pack_t0 sk.t0)) == testCase0.sk)\n    where\n    seed     = 0x7c9935a0b07694aa0c6d10e4db6b1add2fd81a25ccb148032dcd739936737f2d\n    (pk, sk) = Gen seed\n\n\/* Generate signature for message M *\/      \nSign : {mbytes} (fin mbytes, mbytes>=1) => SecretKey -> [mbytes*8] -> (polyVec l, [k][n], poly)\nSign sk M = (final_state.z, h, nttinv final_state.c')\n     where\n      A     = ExpandA sk.rho       mu    = CRH`{b=48+mbytes} (sk.tr#M)       kappa = zero:Integer\n      s1'   = map ntt sk.s1 \/\/checked\n      s2'   = map ntt sk.s2       t0'   = map ntt (IPVtoPV sk.t0) \/\/checked\n\n      init : sign_var_types\n      init = {z=zero,r0=zero,r1=zero,t0'=t0',c'=zero,w=zero,w1=zero\n             ,s1'=s1',s2'=s2',cs2=zero,K=sk.K,mu=mu,A=A,kappa=kappa}\n\n      final_state = dowhile sign_condition sign_body init\n      ct0         = map nttinv (nttVecConstMul final_state.c' final_state.t0')\n      h           = MakeHintV (psubV zero ct0\n                              ,paddV (psubV final_state.w final_state.cs2) (ct0)\n                              ,2*gamma2\n                              )\n\nprivate\n\n    type sign_var_types = { z   : polyVec l\n                          , r0  : intPolyVec k\n                          , r1  : intPolyVec k\n                          , t0' : nttVec k\n                          , c'  : nttPoly\n                          , w   : polyVec k\n                          , w1  : intPolyVec k\n                          , s1' : nttVec l\n                          , s2' : nttVec k\n                          , cs2 : polyVec k\n                          , K   : [256]\n                          , mu  : [384]\n                          , A   : nttMat k l\n                          , kappa: Integer}\n\n    sign_condition : sign_var_types -> Bit\n    sign_condition sv = fail1 \\\/ fail2 \n                   where\n                    fail1 = ((infNormPolyVec (PVtoIPV sv.z)) >= (gamma1-beta))\n                            \\\/ ((infNormPolyVec sv.r0) >= (gamma2-beta))\n                            \\\/ (sv.r1 != sv.w1)\n                    fail2 = ((infNormPolyVec (PVtoIPV ct0)) >= gamma2) \n                            \\\/ ( (foldl (+) 0 (map ones h)) > omega )\n                    ct0   = map nttinv (nttVecConstMul sv.c' sv.t0')\n                    h     = MakeHintV (psubV zero ct0\n                                      ,paddV (psubV sv.w sv.cs2) (ct0)\n                                      ,2*gamma2\n                                      )\n\n    sign_body : sign_var_types -> sign_var_types\n    sign_body sv = {z=z,r0=r0,r1=r1,t0'=sv.t0',c'=c',w=w,w1=w1,s1'=sv.s1',s2'=sv.s2',\n                   cs2=cs2,K=sv.K,mu=sv.mu,A=sv.A,kappa=(sv.kappa+1)}\n              where\n                y   = ExpandMask(sv.K,sv.mu,sv.kappa)                y'  = map ntt y \/\/ checked\n                w   = map nttinv (nttMatMul sv.A y')                 w1  = HighBitsV (w, 2 * gamma2)                 c'  = ntt ( H (sv.mu,w1) ) \/\/ corrected it\n                cs1 = map nttinv (nttVecConstMul c' sv.s1')\n                cs2 = map nttinv (nttVecConstMul c' sv.s2')\n                z   = paddV y cs1\n                (r1, r0) = DecomposeV (psubV w cs2, 2 * gamma2)\n\nVerify : {mbytes} (fin mbytes, mbytes>=1) => PublicKey -> [mbytes*8] -> (polyVec l, [k][n], poly) -> Bit\nVerify pk M (z, h, c) = crit1 && crit2 && crit3\n       where\n        A        = ExpandA pk.rho\n        mu       = CRH`{b=48+mbytes} ((CRH (pk.rho#(pack_t1 pk.t1)))#M)\n        zntt     = map ntt z\n        t1ntt    = map ntt (IPVtoPV pk.t1)\n        ct1ntt   = nttVecConstMul (psub zero c) t1ntt\n        ct1ntt2d = map (\\p -> map (\\x -> x*(2^^d)) p) ct1ntt \n        Az       = nttMatMul A zntt\n        w1'      = UseHintV (h, paddV Az ct1ntt2d, 2*gamma2)\n        zint     = PVtoIPV z\n        zinf     = infNormPolyVec zint\n        crit1    = zinf < gamma1 - beta\n        crit2    = c == H(mu,w1')\n        crit3    = (foldl (+) 0 (map ones h)) <= omega\n\nprivate\n    pack_w : intPolyVec k -> [4*n*k]\n    pack_w w = join [pack_poly p | p <- wBV ]\n                where\n                wBV = map (\\p -> map (\\x -> fromInteger x:[8]) p) w\n\n                pack2 : [2][8] -> [8]\n                pack2 xs = xs@0 || (xs@1 << 4)\n\n                pack_poly p = join [ pack2 xs | xs <- split p : [128][2][_] ]\n\n    pack_polyeta : {m} (fin m, m >= 1) =>  polyVec m -> [4*n*m]\n    pack_polyeta s = join [ join [elt p i | i <- [0..(n\/2)-1]:[_][8] ] | p <- s ]\n                 where\n                  elt : poly -> [8] -> [8]\n                  elt p i = (c (fromZ`{q} (p@(2*i+0)))) || ((c (fromZ`{q} (p@(2*i+1)))) << 4)\n                  c : Integer -> [8]\n                  c num = if num > eta then fromInteger (`q + eta - num) else fromInteger (eta - num)\n\n    pack_t0 : intPolyVec k -> [k*3584]\n    pack_t0 t0 = join [ pack_poly p | p <- t0 ]\n            where\n              tmp : intPoly -> [8] -> [8] -> [32]\n              tmp p i j = fromInteger (2^^13 - p@(4*i+j))\n\n              pack_poly : intPoly -> [3584]\n              pack_poly p = join [ join [drop`{24} (tmp p i 0),\n                         drop`{24} (((tmp p i 0) >> 8) || ((tmp p i 1) << 6)),\n                         drop`{24} ((tmp p i 1) >> 2),\n                         drop`{24} (((tmp p i 1) >> 10) || ((tmp p i 2) << 4)),\n                         drop`{24} ((tmp p i 2) >> 4),\n                         drop`{24} (((tmp p i 2) >> 12) || ((tmp p i 3) << 2)),\n                         drop`{24} ((tmp p i 3) >> 6)\n                         ] | i <- [0..(n\/4-1)] ]\n\n    \/\/ d must be 14 for this to work, and n must be 256\n    pack_t1 : intPolyVec k -> [k*288*8]\n    pack_t1 t1 = join [pack_poly p | p <- t1BV]\n            where\n              t1BV = map (\\p -> map (\\x -> fromInteger x:[9]) p) t1\n\n              pack8 : [8][9] -> [9][8]\n              pack8 xs = map drop`{1} [ xs@0 && zero#0xFF\n                                      , xs@0 >> 8 || ((xs@1 && zero#0x7F) << 1)\n                                      , xs@1 >> 7 || ((xs@2 && zero#0x3F) << 2)\n                                      , xs@2 >> 6 || ((xs@3 && zero#0x1F) << 3)\n                                      , xs@3 >> 5 || ((xs@4 && zero#0x0F) << 4)\n                                      , xs@4 >> 4 || ((xs@5 && zero#0x07) << 5)\n                                      , xs@5 >> 3 || ((xs@6 && zero#0x03) << 6)\n                                      , xs@6 >> 2 || ((xs@7 && zero#0x01) << 7)\n                                      , xs@7 >> 1\n                                      ]\n              pack_poly p = join [join (pack8 xs) | xs <- split p : [32][8][_]]\n\n    \/*pack_sig : (polyVec l, [k][n], poly) -> [SIG_SIZE_PACKED]\n    pack_sig (z, h, c) =\n            where s0 = polyz_pack (z)\n                  s1 = encode (h)\n                  s2 = encode (c)\n    polyz_pack : poly ->[n*qbits]\n    polyz_pack a = [  | i <- [0..n\/2] ] *\/\n\n    \/\/ Only works when n=256\n    PolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [8] -> polyVec dim\n    PolyUniformEtaV rho nonce = [PolyUniformEta rho (nonce + j) | j <- [0..(dim-1)]:[dim][8]]\n\n    PolyUniformEta : [256] -> [8] -> poly\n    PolyUniformEta rho nonce = map (\\x -> eta - x) (map BVtoZ (take`{n} withinEta))\n                   where\n                    seed = rho#nonce\n                    randoms = ((join (SHA3::toBytes (take`{2*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))#zero)\n                    withinEta = randomsInRangeDouble genS (2*eta) randoms\n\n                    genS : [8] -> [2][4]\n                    genS byte = [t0, t1]\n                         where\n                          t0 = drop`{4} (byte && 0x0F)\n                          t1 = drop`{4} (byte >> 4)\n\n    H : ([384],intPolyVec k) -> poly\n    H (mu,w) = map fromInteger (SampleInBall ss samples)\n      where\n        w_packed = pack_w w\n        randoms  = join (SHA3::toBytes (take`{4352} (SHA3::SHAKE256 (join (SHA3::toBytes (mu#w_packed))))))\n        ss       = take`{60}(reverse (join (reverse (split (take`{64} randoms):[8][8]))))\n\n        extByte : [8] -> [8]\n        extByte x = x\n\n        samples : [60][8]\n        samples = take`{60} (randomsInRanges extByte [196..255] (drop`{64} randoms#zero))\n\n    SampleInBall : [60] -> [60][8] -> [256]Integer\n    SampleInBall signs jsamples = ys ! 0\n                  where\n                  ys = [ zero:[256]Integer ]\n                        # [ if i==j then update y i ((-1:Integer)^^(toInteger [s]))\n                            else updates y [j,i] [(-1:Integer)^^(toInteger [s]),y@j] | i <- [196..255]\n                                                                      | j <- jsamples\n                                                                      | s <- signs\n                                                                      | y <- ys\n                          ]\n\n    ExpandMask : ([256], [384], Integer) -> polyVec l\n    ExpandMask  (K, mu, kappa) = [samplePoly K mu kappa i `l | i <- [0..(l-1)] ]\n\n    samplePoly : [256] -> [384] -> Integer -> Integer -> Integer -> poly\n    samplePoly K mu kappa i dim = [fromInteger (`q + gamma1 - 1 - (toInteger vj)) | vj <- coeffs]\n                where\n                upper      = fromInteger (2*gamma1-2) : [20]\n                kappaBytes = join (reverse (split (fromInteger (dim*kappa+i):[16]):[2][8])) \/\/ LEB order\n                s          = join (SHA3::toBytes (take`{5*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes (K#mu#kappaBytes)))))) \/\/ checked\n                coeffs     = take`{n} (randomsInRangeDouble extractPolyElt upper (s#zero))\n\n    extractPolyElt : [40] -> [2][20]\n    extractPolyElt bits = [int1, int2]\n                    where\n                    [b0,b1,b2,b3,b4] = [(zero#b):[20] | b <- split bits : [5][8]]\n                    int1 = b2'*2^^16 + b1*2^^8 +  b0\n                    int2 = b4*2^^12 + b3*2^^4 +  b2''\n                    b2'  = b2 && 15\n                    \/\/b2'' = b2\/(16:[20])\n                    b2'' = b2\/16\n    \/\/ seed should be in little endian byte order\n    CRH : {b} (fin b, b>=1) => [b*8] -> [384]\n    CRH seed = join (SHA3::toBytes (take`{48*8} (SHA3::SHAKE256 (join (SHA3::toBytes seed)))))\n\n    ExpandA : [256] -> [k][l]nttPoly \n    ExpandA rho = [ [elt i j | j <- [0..(l-1)] ] |  i <- [0..(k-1)] ]\n            where\n              elt i j = matrixPoly rho i j\n\n    matrixPoly : [256] -> [width k] -> [width l] -> nttPoly\n    matrixPoly rho i j = take`{n} [ BVtoZ elt | elt <- randomElts ]\n                where\n                randomElts = randomsInRange extractMatElt ((>=) (`q)) (s#zero)\n                s          = join (SHA3::toBytes (take`{6720} (SHA3::SHAKE128 (join (SHA3::toBytes (rho#b))))))\n                b          = 16*(zero#j:[8])+(zero#i:[8])\n\n    extractMatElt : [24] -> [24]\n    extractMatElt rands = zero#(2^^16 * b2' + 2^^8 * b1 + b0):[24]\n                    where\n                      [b0, b1, b2] = [(zero#b):[23] | b <- split`{3} rands]\n                      b2' = (2^^23-1) && b2 \/\/ Typo in paper; following C implementation\n\n    \/*\n\n      Supporting Algorithms; see Figure 3\n\n    *\/\n\n    Power2Round : Integer -> (Integer,Integer) -> (Integer,Integer)\n    Power2Round q (r,d') = ((r'-r0)\/2^^d',r0)\n                where r' = r % q\n                      r0 = centered_mod r' (2^^d')\n\n    Power2RoundV : {dim} (fin dim, dim >= 1) => polyVec dim -> ([dim]intPoly,[dim]intPoly)\n    Power2RoundV v = unzip (map polyPower2Round v)\n                  where\n                  polyPower2Round p = unzip [ Power2Round `q ( (fromZ r ) ,d)\n                                            | r <- p\n                                            ]\n\n    Decompose : Integer -> (Integer,Integer) -> (Integer,Integer)\n    Decompose q (r,a) = if (r' - r0) == (q - 1) then (0, r0 - 1)\n                        else ((r' - r0) \/ a, r0)\n              where r' = r % q\n                    r0 = centered_mod r' a\n\n    DecomposeV : (polyVec k , Integer) -> (intPolyVec k, intPolyVec k)\n    DecomposeV (r,a) = unzip [ DecomposePoly p | p <- r ]\n                where\n                DecomposePoly p = unzip [Decompose `q (fromZ x,a) | x <- p]\n\n    HighBits : Integer -> (Integer,Integer) -> Integer\n    HighBits q (r,a) = (Decompose q (r,a)).0\n\n    HighBitsV : (polyVec k , Integer) -> intPolyVec k\n    HighBitsV (r,a) = r1\n              where\n                (r1,r0) = DecomposeV (r,a)\n\n    LowBits : Integer -> (Integer,Integer) -> Integer\n    LowBits q (r,a) = (Decompose q (r,a)).1\n\n    MakeHint : Integer -> (Integer,Integer,Integer) -> Bit\n    MakeHint q (z,r,a) = r1 != v1\n              where r1 = HighBits q (r,a)\n                    v1 = HighBits q (r + z,a)\n\n    MakeHintV : (polyVec k, polyVec k, Integer) -> [k][n]\n    MakeHintV (z,r,a) = [[x1 != x2 | x1 <- p1 | x2 <- p2] | p1 <- r1 | p2 <- v1]\n              where\n                r1 = HighBitsV (r,a)\n                v1 = HighBitsV (polyVecSum z r,a)\n\n    UseHint : Integer -> (Bit,Integer,Integer) -> Integer\n    UseHint q (h,r,a) = if h then r1' else r1\n            where\n              m        = (q - 1) \/ a\n              (r1, r0) = Decompose q (r, a)\n              r1'      = if r0 > 0 then (r1 + 1) % m else (r1 - 1) % m\n\n    UseHintV : ([k][n], polyVec k, Integer) -> intPolyVec k\n    UseHintV (hvec, rvec, a) = [polyUseHint hpoly rpoly\n                                  | hpoly <- hvec\n                                  | rpoly <- rvec\n                                  ]\n                where\n                polyUseHint hpoly rpoly = [ UseHint `q (h,fromZ r,a)\n                                          | h <- hpoly\n                                          | r <- rpoly\n                                          ]\n\n    \/*\n\n      Utility functions\n\n    *\/\n\n    ones : {a} (fin a, a >= 1) => [a] -> Integer\n    ones bv = foldl (+) 0 bva\n          where\n          bva = map toInteger (split bv:[_][1])\n\n    IPVtoPV : {dim} (fin dim, dim >= 1) => intPolyVec dim -> polyVec dim\n    IPVtoPV intp = map (\\p -> map fromInteger p) intp\n\n    PVtoIPV : {dim} (fin dim, dim >= 1) => polyVec dim -> intPolyVec dim\n    PVtoIPV pvec = map (\\p -> map fromZ p) pvec\n\n    centered_mod : Integer -> Integer -> Integer\n    centered_mod x n = if r > (n\/2) then r - n\n                        else r\n                  where r = x % n\n\n    randomsInRange : {a} (fin a) => ([a]-> [a]) -> ([a] -> Bit) -> [inf] -> [inf][a]\n    randomsInRange createElt upperCrit randoms = if (upperCrit elt )\n                                    then  [ elt ]#(randomsInRange createElt upperCrit randomTail)\n                                    else randomsInRange createElt upperCrit randomTail\n                                    where\n                                    elt        = createElt (take`{a} randoms) \n                                    randomTail = drop`{a} randoms\n\n    randomsInRanges : {a,m} (fin a,fin m, m>=1) => ([a]-> [a]) -> [m][a] -> [inf] -> [inf][a]\n    randomsInRanges createElt uppers randoms =\n                    if elt <= head uppers\n                    then  [ elt ]#(randomsInRanges createElt uppersRotate randomTail)\n                    else randomsInRanges createElt uppers randomTail\n                    where\n                      elt          = createElt (take`{a} randoms) \n                      randomTail   = drop`{a} randoms\n                      uppersRotate = uppers <<< 1\n\n    randomsInRangeDouble : {a} (fin a) => ([2*a]-> [2][a]) -> [a] -> [inf] -> [inf][a]\n\/\/wrong code\n    \/*randomsInRangeDouble createElt upper randoms =\n                    if (elts@0 <= upper) \/\\ (elts@1 <= upper)\n                    then  elts#(randomsInRangeDouble createElt upper randomTail)\n                    else\n                      if (elts@0 <= upper)\n                      then [ elts@0 ]#(randomsInRangeDouble createElt upper randomTail)\n                      else\n                        if (elts@1 <= upper)\n                        then [ elts@1 ]#(randomsInRangeDouble createElt upper randomTail)\n                        else randomsInRangeDouble createElt upper randomTail\n                    where\n                      elts       = createElt (take`{2*a} randoms) \n                      randomTail = drop`{2*a} randoms*\/\n\/\/ Correction and checked with the C code\n    randomsInRangeDouble createElt upper randoms =\n                    if (elts@1 <= upper) then [elts@1, elts@1] # (randomsInRangeDouble createElt upper randomTail)\n                    else (randomsInRangeDouble createElt upper randomTail)\n                    where\n                    elts       = createElt (take`{2*a} randoms)\n                    randomTail = drop`{2*a} randoms\n\n    \/*\n\n      Supporting polynomial and polynomial vector functions\n\n    *\/\n\n    ntt : poly -> nttPoly\n    ntt p = nttp\n         where\n          r k = rootOfUnity^^k\n          exponents = join [ [BVtoZ`{q} i, (256+(BVtoZ`{q} i))] | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n          nttp = [ sum [ p@idx * (r k)^^(i) | idx<-[0..(n-1)]:[n][width n] | i<-[0..(n-1)]:[n](Z q)]\n                 | k <- exponents \n                 ]\n\n    nttinv : nttPoly -> poly\n    nttinv p' = p\n           where\n            pu = reorder p'\n            r' i = rootOfUnityInv^^(i*2)\n            p = [ninv*(rootOfUnityInv^^i) * sum [pu@jdx * (r' ((i*j)))\n                                                    | jdx<-[0..(n-1)]:[n][width n]\n                                                    | j<-[0..(n-1)]:[n](Z q)\n                                                    ]\n                | i <- [0..255]\n                ]\n\n    \/\/ Dilithium uses a non-standard ordering of elements in the NTT domain; this function reorders the elements.\n    reorder : nttPoly -> nttPoly\n    reorder a = join [ [a1 @ i, a2 @ i] | i <- [0..127]:[_][8] ]\n            where\n              a1 = a @@ [ (i-1)\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n              a2 = reverse (a @@ [ (511 - (zero#i):[9])\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ])\n\n    \/\/ Operations on NTT polynomials\n\n    nttMatMul : {dim1,dim2} (fin dim1,fin dim2) => nttMat dim1 dim2 -> nttVec dim2 -> nttVec dim1\n    nttMatMul mat vec = [ nttDotProduct v vec | v <- mat ]\n\n    nttDotProduct : {dim} (fin dim) => nttVec dim -> nttVec dim -> nttPoly\n    nttDotProduct v1 v2 = foldl padd (zero:nttPoly) [ nttPolyMult p1 p2 | p1 <- v1 | p2 <- v2 ]\n\n    nttPolyMult : nttPoly -> nttPoly -> nttPoly\n    nttPolyMult p1 p2 = [ x * y | x <- p1 | y <- p2]\n\n    nttVecConstMul : {dim} (fin dim) => nttPoly -> nttVec dim -> nttVec dim\n    nttVecConstMul c v = map (nttPolyMult c) v\n\n    polyVecSum :  {dim} (fin dim) => polyVec dim -> polyVec dim -> polyVec dim\n    polyVecSum v1 v2 = map nttinv (paddV v1' v2')\n                where\n                v1' = map ntt v1\n                v2' = map ntt v2\n\n    \/\/ Polynomial addition and subtraction\n    padd : [n](Z q) -> [n](Z q) -> [n](Z q)\n    padd p1 p2 = [ x + y | x <- p1 | y <- p2 ]\n\n    psub : [n](Z q) -> [n](Z q) -> [n](Z q)\n    psub p1 p2 = [ x - y | x <- p1 | y <- p2 ]\n\n    psubV : {dim} (fin dim) => [dim][n](Z q) -> [dim][n](Z q) -> [dim][n](Z q)\n    psubV v1 v2 = zipWith psub v1 v2\n\n    paddV : {dim} (fin dim) => [dim][n](Z q) -> [dim][n](Z q) -> [dim][n](Z q)\n    paddV v1 v2 = zipWith padd v1 v2\n\n    \/\/ Aux functions\n\n    infNorm : Integer -> Integer\n    infNorm x = abs (centered_mod x `q)\n\n    infNormPoly : intPoly -> Integer\n    infNormPoly p = foldl max 0 p_centered\n                where\n                  p_centered = map infNorm p\n\n    infNormPolyVec : {dim} (fin dim, dim>=1) => intPolyVec dim -> Integer\n    infNormPolyVec v = foldl max 0 (map infNormPoly v)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/ECDSA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ECDSA::ECDSA that contains the following definitions: (1) Type parameters p and q and a reusable Constraints predicate requiring finite, odd moduli with size at least 4. (2) Public curve parameters: b (curve coefficient over Z p), G (projective base point over p), and mp_mod_sqrt (maps Z p to a modular square root). (3) Type aliases AffinePoint p = record {x: Z p, y: Z p} and ProjectivePoint p = record {x: Z p, y: Z p, z: Z p}. (4) ECDSA API: sign (inputs: secret in Z q, message hash in Z q, nonce scalar in Z p; outputs: pair in Z q) following standard ECDSA: compute R = k\u00b7G, r from R\u2019s x-coordinate, s = k^{-1}(z + r\u00b7d) mod q; private_to_public (multiply secret by G to produce a projective public key); verify (inputs: z, public key, signature; output Bit) that computes w = s^{-1}, u1 = z\u00b7w, u2 = r\u00b7w, evaluates u1\u00b7G + u2\u00b7Q via joint scalar multiplication, normalizes to affine, and checks r equals the reduced x-coordinate. (5) Validation helpers returning Bit that check round-trip\/consistency: compression of G against a provided encoding; full add, full subtract, doubling, scalar multiply, and joint scalar multiply (each compares affine results after projective operations). Include a boolean stating mp_mod_sqrt(x\u00b2)\u00b2 equals x\u00b2. Define affine_decompress_correct that returns no error and exact round-trip for an affine point. Define property decompress_correct that universally quantifies a scalar k and asserts compress(affinify(k\u00b7G)) decomposes back to the same point without error. (6) Private helpers: projectify, affinify (error on infinity), compress (two control bits with x; length \u2265 width(p)+2), decompress (returns point and error via square-root check and parity selection), affine curve predicate, projective double\/add and full variants with edge cases, scalar multiplication (binary double-and-add with normalization and infinity handling), a small windowing function F, and joint scalar multiplication using signed joint recoding. Assume standard modular arithmetic and bitvector utilities from a common support module."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\nimport Common::utils\n\nsign : Z q -> Z q -> Z p -> (Z q, Z q)\nsign d z k = (r, s)\n  where {x = x1, y = _} = ec_affinify (ec_mult k G)\n        r = ZtoZ x1\n        s = (mp_mod_inv (ZtoZ k)) * (z + r*d)\n\nprivate_to_public : Z q -> ProjectivePoint p\nprivate_to_public d = ec_mult (ZtoZ d) G\n\nverify : Z q -> ProjectivePoint p -> (Z q, Z q) -> Bit\nverify z Q (r, s) = r == ZtoZ j\n  where w = mp_mod_inv s\n        u1 = z * w\n        u2 = r * w\n        {x = x1, y = _, z = z1} = ec_twin_mult (ZtoZ u1) G (ZtoZ u2) Q\n        j = x1 * (mp_mod_inv z1)^^2\n\nG_compress R = ec_compress (ec_affinify G) == R\n\nfull_add_example : AffinePoint p -> AffinePoint p -> AffinePoint p -> Bit\nfull_add_example R S T =\n  ec_affinify (ec_full_add (ec_projectify S) (ec_projectify T)) == R\n\nfull_subtract_example : AffinePoint p -> AffinePoint p -> AffinePoint p -> Bit\nfull_subtract_example R S T =\n  ec_affinify (ec_full_sub (ec_projectify S) (ec_projectify T)) == R\n\ndouble_example : AffinePoint p -> AffinePoint p -> Bit\ndouble_example R S =\n  ec_affinify (ec_double (ec_projectify S)) == R\n\nscalar_multiply_example : AffinePoint p -> AffinePoint p -> Z p -> Bit\nscalar_multiply_example R S d =\n  ec_affinify (ec_mult d (ec_projectify S)) == R\n\njoint_scalar_multiply_example : AffinePoint p -> AffinePoint p -> AffinePoint p -> Z p -> Z p -> Bit\njoint_scalar_multiply_example R S T d e =\n  ec_affinify (ec_twin_mult d (ec_projectify S) e (ec_projectify T)) == R\n\nmp_mod_sqrt_correct x = (mp_mod_sqrt (x ^^ 2)) ^^ 2 == (x ^^ 2)\n\naffine_decompress_correct : AffinePoint p -> Bit\naffine_decompress_correct R = ~err \/\\ R == R'\n  where\n    (R',err) = ec_decompress (ec_compress`{width p+2} R)\n\ndecompress_correct : Z p -> Bit\nproperty decompress_correct k = affine_decompress_correct (ec_affinify (ec_mult k G))\n\nparameter\n\n  type p : #\n  type constraint Constraints p\n\n  b : Z p\n\n  G : ProjectivePoint p\n\n  type q : #\n  type constraint Constraints q\n\n  mp_mod_sqrt : Z p -> Z p\n\nprivate\n\n  type constraint Constraints a = (fin a, isOdd a, a >= 4)\n\n  type AffinePoint a = {x : Z a, y : Z a}\n  type ProjectivePoint a = {x : Z a, y : Z a, z : Z a}\n\n  ec_projectify : {a} (Constraints a) => AffinePoint a -> ProjectivePoint a\n  ec_projectify S = {x = S.x, y = S.y, z = 1}\n\n  ec_affinify : {a} (Constraints a) => ProjectivePoint a -> AffinePoint a\n  ec_affinify S = if S.z == 0 then error \"Cannot affinify the point at infinity\"\n                  else {x = lambda^^2 * S.x, y =  lambda^^3 * S.y}\n    where\n      lambda = mp_mod_inv S.z\n\n  ec_compress : {r} (fin r, r >= width p + 2) => AffinePoint p -> [r]\n  ec_compress S = (2 + (Sy % 2)) # Sx\n    where Sx = ZtoBV S.x : [width p]\n          Sy = ZtoBV S.y : [r - width p]\n\n  ec_decompress : {a} (fin a, a >= width p + 2) => [a] -> (AffinePoint p, Bit)\n  ec_decompress S = ({x = Rx, y = Ry}, err)\n    where c  = toInteger (take S : [2])\n          Rx = BVtoZ (drop S : [a-2])\n          t0 = Rx ^^ 3 - (mul3 Rx) + b\n          t1 = mp_mod_sqrt t0\n          err = t1 ^^ 2 != t0\n          Ry = if (fromZ t1)%2 == c%2 then t1 else -t1\n\n  ec_is_point_affine : AffinePoint p -> Bit\n  ec_is_point_affine S = S.y ^^ 2 == t\n    where t = S.x ^^ 3 - (mul3 S.x) + b\n\n  ec_double : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a\n  ec_double S =\n    if S.z == 0 then\n      {x = 1, y = 1, z = 0}             \n    else\n      {x = r18, y = r23, z = r13}\n    where r7  = S.z ^^ 2                \n          r8  = S.x - r7                \n          r9  = S.x + r7                \n          r10 = r9 * r8                 \n          r11 = mul3 r10                \n          r12 = S.z * S.y               \n          r13 = mul2 r12                \n          r14 = S.y ^^ 2                \n          r15 = S.x * r14               \n          r16 = mul4 r15                \n          r17 = r11 ^^ 2                \n          r18 = r17 - (mul2 r16)        \n          r19 = r14 ^^ 2                \n          r20 = mul8 r19                \n          r21 = r16 - r18               \n          r22 = r11 * r21               \n          r23 = r22 - r20               \n\n  ec_add : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a -> ProjectivePoint a\n  ec_add S T =\n    if r13 == 0 then\n      if r14 == 0 then\n        {x = 0, y = 0, z = 0}      \n      else\n        {x = 1, y = 1, z = 0}      \n    else\n      {x = r32, y = r37, z = r27}\n    where r9  = S.z ^^ 2           \n          r10 = T.x * r9           \n          r11 = S.z * r9           \n          r12 = T.y * r11          \n          r13 = S.x - r10          \n          r14 = S.y - r12          \n\n          r22 = mul2 S.x - r13     \n          r23 = mul2 S.y - r14     \n\n          r27 = S.z * r13          \n          r28 = r13 ^^ 2           \n          r29 = r13 * r28          \n          r30 = r22 * r28          \n          r31 = r14 ^^ 2           \n          r32 = r31 - r30          \n          r33 = r30 - (mul2 r32)   \n          r34 = r14 * r33          \n          r35 = r23 * r29          \n          r36 = r34 - r35          \n          r37 = half r36           \n\n  ec_full_add : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a -> ProjectivePoint a\n  ec_full_add S T = \n    if S.z == 0 then T\n     | T.z == 0 then S\n     | R == {x = 0, y = 0, z = 0} then ec_double S\n     else R\n    where R = ec_add S T\n\n  ec_full_sub : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a -> ProjectivePoint a\n  ec_full_sub S T = R\n    where U = {x = T.x, y = -T.y, z = T.z}\n          R = ec_full_add S U\n\n  ec_mult : {a} (Constraints a) => Z a -> ProjectivePoint a -> ProjectivePoint a\n  ec_mult d S = if d == 0 then {x = 1, y = 1, z = 0}\n                 | d == 1 then S\n                 | S.z == 0 then {x = 1, y = 1, z = 0}\n                 else Rs!1\n    where S' = if S.z != 1 then ec_projectify (ec_affinify S) else S\n          k = ZtoBV d : [width a + 2]\n          h = k + k + k\n          Rs = [{x = 1, y = 1, z = 0}] # \/\/Here we start with 1 instead of S because we don't really know where the high-bit is\n               [ if hi && ~ki then ec_full_add RiDouble S\n                  | ~hi && ki then ec_full_sub RiDouble S\n                  else RiDouble\n                 where RiDouble = ec_double Ri\n               | ki <- k | hi <- h | Ri <- Rs ]\n\n  F : [5] -> [5]\n  F t = if (18 <= t) && (t < 22) then 9\n         | (14 <= t) && (t < 18) then 10\n         | (22 <= t) && (t < 24) then 11\n         | (4 <= t)  && (t < 12) then 14\n         else 12\n\n  ec_twin_mult : {a} (Constraints a) => Z a -> ProjectivePoint a -> Z a -> ProjectivePoint a -> ProjectivePoint a\n  ec_twin_mult d0 S d1 T = (states!0).0\n    where Sp = if S.z != 1 then ec_projectify (ec_affinify S) else S\n          Tp = if T.z != 1 then ec_projectify (ec_affinify T) else T\n          SpT = ec_full_add Sp Tp\n          SpTp = if SpT.z != 1 then ec_projectify (ec_affinify SpT) else SpT\n          SmT = ec_full_sub Sp Tp\n          SmTp = if SmT.z != 1 then ec_projectify (ec_affinify SmT) else SmT\n          e0  = ZtoBV d0 : [max 4 (width a)]\n          e1  = ZtoBV d1 : [max 4 (width a)]\n          c   = [[False, False] # take e0,\n                 [False, False] # take e1] : [2][6]\n          states = [({x = 1, y = 1, z = 0}, c)] #\n                   [ (Rk', [c0', c1'])\n                     where h0 = if c0@0 then 31 - tail c0 else tail c0\n                           h1 = if c1@0 then 31 - tail c1 else tail c1\n                           u0 = if h0 < (F h1) then 0 else if c0@0 then -1 else 1 : [2]\n                           u1 = if h1 < (F h0) then 0 else if c1@0 then -1 else 1 : [2]\n                           c0' = [(u0!=0) ^ c0@1] # drop c0 # [e0k]\n                           c1' = [(u1!=0) ^ c1@1] # drop c1 # [e1k]\n                           Rk' = if (u0 == -1) && (u1 == -1) then ec_full_sub RkDouble SpTp\n                                  | (u0 == -1) && (u1 ==  0) then ec_full_sub RkDouble Sp\n                                  | (u0 == -1) && (u1 ==  1) then ec_full_sub RkDouble SmTp\n                                  | (u0 ==  0) && (u1 == -1) then ec_full_sub RkDouble Tp\n                                  | (u0 ==  0) && (u1 ==  1) then ec_full_add RkDouble Tp\n                                  | (u0 ==  1) && (u1 == -1) then ec_full_add RkDouble SmTp\n                                  | (u0 ==  1) && (u1 ==  0) then ec_full_add RkDouble Sp\n                                  | (u0 ==  1) && (u1 ==  1) then ec_full_add RkDouble SpTp\n                                  else RkDouble\n                           RkDouble = ec_double Rk\n                   | (Rk, [c0, c1]) <- states\n                   | e0k <- drop`{4} e0 # (zero : [5])\n                   | e1k <- drop`{4} e1 # (zero : [5]) ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Asymmetric::Signature::ECDSA::p256 that aliases\/re-exports the generic ECDSA module and adds the following definitions: (1) a type synonym for the prime field modulus p used by the P-256 curve; (2) a constant b for the curve\u2019s coefficient over the field Z p; (3) a constant G as the curve\u2019s base point given as a record with fields x and y in Z p and z set to 1 to represent projective\/affine form; (4) a type synonym q for the base point\u2019s subgroup order; and (5) a function mp_mod_sqrt with the type Z p -> Z p that computes a modular square root in Z p using a fixed addition-chain exponentiation. The algorithm should form intermediate values by repeated squaring and multiplication of the input element c: build t1 from c and c^2; derive t2 by squaring t1 twice and multiplying by t1; derive t3 by squaring t2 four times and multiplying by t2; derive t4 by squaring t3 eight times and multiplying by t3; derive r by squaring t4 sixteen times and multiplying by t4; derive r\u2032 by squaring r thirty-two times and multiplying by c; derive r\u2033 by squaring r\u2032 ninety-six times and multiplying by c; then return the result of squaring r\u2033 ninety-four times. All arithmetic must be performed in Z p, and the constants p, q, b, and the coordinates of G must have exactly the same numeric values and appropriate types as in the P-256 specification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::p256 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\ntype p = 115792089210356248762697446949407573530086143415290314195533631308867097853951\n\nb = 41058363725152142129326129780047268409114441015993725554835256314039467401291\n\nG = {x = 48439561293906451759052585252797914202762949526041747995844080717082404635286,\n     y = 36134250956749795798585127919587881956611106672985015071877198253568414405109,\n     z = 1}\n\ntype q = 115792089210356248762697446949407573529996955224135760342422259061068512044369\n\nmp_mod_sqrt : Z p -> Z p\nmp_mod_sqrt c = r'' ^^ (2 ^^ 94)\n  where t1  = (c ^^ 2) * c\n        t2  = (t1 ^^ (2 ^^ 2)) * t1\n        t3  = (t2 ^^ (2 ^^ 4)) * t2\n        t4  = (t3 ^^ (2 ^^ 8)) * t3\n        r   = (t4 ^^ (2 ^^ 16)) * t4\n        r'  = (r ^^ (2 ^^ 32)) * c\n        r'' = (r' ^^ (2 ^^ 96)) * c\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/ECDSA_tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains the following definitions:\n- Import a utility module for converting fixed-width big-endian bitvectors to integers and import curve modules for the NIST prime curves with 192, 224, 256, 384, and 521-bit primes.\n- For each curve, declare two constants S and T as affine points over the curve\u2019s prime field. Each point is a record with x and y coordinates as integers derived from fixed-size bitvectors. Ensure their types align with the curve\u2019s affine point type.\n- For each curve, add a property that the compressed encoding of the standard base point equals a given constant.\n- For each curve, add properties for:\n  - Decompression correctness: decompressing the compressed form of S (and of T) yields the original affine point.\n  - Full point addition: S + T equals a provided expected point R.\n  - Full point subtraction: S \u2212 T equals a provided expected point R.\n  - Doubling: 2\u00b7S equals a provided expected point R.\n  - Scalar multiplication: d\u00b7S equals a provided expected point R for a specified scalar d.\n  - Joint scalar multiplication: d\u00b7S + e\u00b7T equals a provided expected point R for specified scalars d and e.\n- For each curve, add a property asserting the modular square-root routine is correct for that curve\u2019s prime modulus.\nAll properties must be boolean specifications that compare computed results to the provided expected constants using equality. Declare any expected points R and scalars d, e locally (e.g., in where-clauses). State appropriate type signatures for points, scalars, and properties, but do not compute proofs or values; only define the specifications and checks."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::ECDSA_tests where\n\nimport Common::utils\n\nimport Primitive::Asymmetric::Signature::ECDSA::p192 as p192\nimport Primitive::Asymmetric::Signature::ECDSA::p224 as p224\nimport Primitive::Asymmetric::Signature::ECDSA::p256 as p256\nimport Primitive::Asymmetric::Signature::ECDSA::p384 as p384\nimport Primitive::Asymmetric::Signature::ECDSA::p521 as p521\n\nproperty p192_G_compress = p192::G_compress 0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\n\np192_S = {x = BVtoZ 0xd458e7d127ae671b0c330266d246769353a012073e97acf8,\n          y = BVtoZ 0x325930500d851f336bddc050cf7fb11b5673a1645086df3b}\n\np192_T = {x = BVtoZ 0xf22c4395213e9ebe67ddecdd87fdbd01be16fb059b9753a4,\n          y = BVtoZ 0x264424096af2b3597796db48f8dfb41fa9cecc97691a9c79}\n\nproperty p192_decompress_S = p192::affine_decompress_correct p192_S\nproperty p192_decompress_T = p192::affine_decompress_correct p192_T\n\nproperty p192_full_add_example =\n  p192::full_add_example R p192_S p192_T\n  where R = {x = BVtoZ 0x48e1e4096b9b8e5ca9d0f1f077b8abf58e843894de4d0290,\n             y = BVtoZ 0x408fa77c797cd7dbfb16aa48a3648d3d63c94117d7b6aa4b}\n\nproperty p192_full_subtract_example =\n  p192::full_subtract_example R p192_S p192_T\n  where R = {x = BVtoZ 0xfc9683cc5abfb4fe0cc8cc3bc9f61eabc4688f11e9f64a2e,\n             y = BVtoZ 0x093e31d00fb78269732b1bd2a73c23cdd31745d0523d816b}\n\nproperty p192_double_example =\n  p192::double_example R p192_S\n  where R = {x = BVtoZ 0x30c5bc6b8c7da25354b373dc14dd8a0eba42d25a3f6e6962,\n             y = BVtoZ 0x0dde14bc4249a721c407aedbf011e2ddbbcb2968c9d889cf}\n\nproperty p192_scalar_multiply_example0 =\n  p192::scalar_multiply_example R p192_S d\n  where d = BVtoZ 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        R = {x = BVtoZ 0x1faee4205a4f669d2d0a8f25e3bcec9a62a6952965bf6d31,\n             y = BVtoZ 0x5ff2cdfa508a2581892367087c696f179e7a4d7e8260fb06}\n\np192_S' = {x = BVtoZ 0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012,\n           y = BVtoZ 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811}\n\nproperty p192_scalar_multiply_example1=\n    p192::scalar_multiply_example R p192_S' d\n    where d = BVtoZ 0xe14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3\n          R = {x = BVtoZ 0x07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6,\n               y = BVtoZ 0x76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477}\n\nproperty p192_joint_scalar_multiply_example =\n  p192::joint_scalar_multiply_example R p192_S p192_T d e\n  where d = BVtoZ 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        e = BVtoZ 0xc4be3d53ec3089e71e4de8ceab7cce889bc393cd85b972bc\n        R = {x = BVtoZ 0x019f64eed8fa9b72b7dfea82c17c9bfa60ecb9e1778b5bde,\n             y = BVtoZ 0x16590c5fcd8655fa4ced33fb800e2a7e3c61f35d83503644}\n\nproperty mp_mod_sqrt_192_correct = p192::mp_mod_sqrt_correct\n\nproperty p224_G_compress = p224::G_compress 0x00000002b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\n\np224_S = {x = BVtoZ 0x6eca814ba59a930843dc814edd6c97da95518df3c6fdf16e9a10bb5b,\n          y = BVtoZ 0xef4b497f0963bc8b6aec0ca0f259b89cd80994147e05dc6b64d7bf22}\n\np224_T = {x = BVtoZ 0xb72b25aea5cb03fb88d7e842002969648e6ef23c5d39ac903826bd6d,\n          y = BVtoZ 0xc42a8a4d34984f0b71b5b4091af7dceb33ea729c1a2dc8b434f10c34}\n\nproperty p224_full_add_example =\n  p224::full_add_example R p224_S p224_T\n  where R = {x = BVtoZ 0x236f26d9e84c2f7d776b107bd478ee0a6d2bcfcaa2162afae8d2fd15,\n             y = BVtoZ 0xe53cc0a7904ce6c3746f6a97471297a0b7d5cdf8d536ae25bb0fda70}\n\nproperty p224_full_subtract_example =\n  p224::full_subtract_example R p224_S p224_T\n  where R = {x = BVtoZ 0xdb4112bcc8f34d4f0b36047bca1054f3615413852a7931335210b332,\n             y = BVtoZ 0x90c6e8304da4813878c1540b2396f411facf787a520a0ffb55a8d961}\n\nproperty p224_double_example =\n  p224::double_example R p224_S\n  where R = {x = BVtoZ 0xa9c96f2117dee0f27ca56850ebb46efad8ee26852f165e29cb5cdfc7,\n             y = BVtoZ 0xadf18c84cf77ced4d76d4930417d9579207840bf49bfbf5837dfdd7d}\n\nproperty p224_scalar_multiply_example =\n  p224::scalar_multiply_example R p224_S d\n  where d = BVtoZ 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        R = {x = BVtoZ 0x96a7625e92a8d72bff1113abdb95777e736a14c6fdaacc392702bca4,\n             y = BVtoZ 0x0f8e5702942a3c5e13cd2fd5801915258b43dfadc70d15dbada3ed10}\n\nproperty p224_joint_scalar_multiply_example =\n  p224::joint_scalar_multiply_example R p224_S p224_T d e\n  where d = BVtoZ 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        e = BVtoZ 0x54d549ffc08c96592519d73e71e8e0703fc8177fa88aa77a6ed35736\n        R = {x = BVtoZ 0xdbfe2958c7b2cda1302a67ea3ffd94c918c5b350ab838d52e288c83e,\n             y = BVtoZ 0x2f521b83ac3b0549ff4895abcc7f0c5a861aacb87acbc5b8147bb18b}\n\nproperty mp_mod_sqrt_224_correct = p224::mp_mod_sqrt_correct\n\nproperty p256_G_compress = p256::G_compress 0x000000036b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\n\np256_S = {x = BVtoZ 0xde2444bebc8d36e682edd27e0f271508617519b3221a8fa0b77cab3989da97c9,\n          y = BVtoZ 0xc093ae7ff36e5380fc01a5aad1e66659702de80f53cec576b6350b243042a256}\n\np256_T = {x = BVtoZ 0x55a8b00f8da1d44e62f6b3b25316212e39540dc861c89575bb8cf92e35e0986b,\n          y = BVtoZ 0x5421c3209c2d6c704835d82ac4c3dd90f61a8a52598b9e7ab656e9d8c8b24316}\n\nproperty p256_full_add_example =\n  p256::full_add_example R p256_S p256_T\n  where R = {x = BVtoZ 0x72b13dd4354b6b81745195e98cc5ba6970349191ac476bd4553cf35a545a067e,\n             y = BVtoZ 0x8d585cbb2e1327d75241a8a122d7620dc33b13315aa5c9d46d013011744ac264}\n\nproperty p256_full_subtract_example =\n  p256::full_subtract_example R p256_S p256_T\n  where R = {x = BVtoZ 0xc09ce680b251bb1d2aad1dbf6129deab837419f8f1c73ea13e7dc64ad6be6021,\n             y = BVtoZ 0x1a815bf700bd88336b2f9bad4edab1723414a022fdf6c3f4ce30675fb1975ef3}\n\nproperty p256_double_example =\n  p256::double_example R p256_S\n  where R = {x = BVtoZ 0x7669e6901606ee3ba1a8eef1e0024c33df6c22f3b17481b82a860ffcdb6127b0,\n             y = BVtoZ 0xfa878162187a54f6c39f6ee0072f33de389ef3eecd03023de10ca2c1db61d0c7}\n\nproperty p256_scalar_multiply_example =\n  p256::scalar_multiply_example R p256_S d\n  where d = BVtoZ 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        R = {x = BVtoZ 0x51d08d5f2d4278882946d88d83c97d11e62becc3cfc18bedacc89ba34eeca03f,\n             y = BVtoZ 0x75ee68eb8bf626aa5b673ab51f6e744e06f8fcf8a6c0cf3035beca956a7b41d5}\n\nproperty p256_joint_scalar_multiply_example =\n  p256::joint_scalar_multiply_example R p256_S p256_T d e\n  where d = BVtoZ 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        e = BVtoZ 0xd37f628ece72a462f0145cbefe3f0b355ee8332d37acdd83a358016aea029db7\n        R = {x = BVtoZ 0xd867b4679221009234939221b8046245efcf58413daacbeff857b8588341f6b8,\n             y = BVtoZ 0xf2504055c03cede12d22720dad69c745106b6607ec7e50dd35d54bd80f615275}\n\nproperty mp_mod_sqrt_256_correct = p256::mp_mod_sqrt_correct\n\nproperty p384_G_compress = p384::G_compress 0x00000003aa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\n\np384_S = {x = BVtoZ 0xfba203b81bbd23f2b3be971cc23997e1ae4d89e69cb6f92385dda82768ada415ebab4167459da98e62b1332d1e73cb0e,\n          y = BVtoZ 0x5ffedbaefdeba603e7923e06cdb5d0c65b22301429293376d5c6944e3fa6259f162b4788de6987fd59aed5e4b5285e45}\n\np384_T = {x = BVtoZ 0xaacc05202e7fda6fc73d82f0a66220527da8117ee8f8330ead7d20ee6f255f582d8bd38c5a7f2b40bcdb68ba13d81051,\n          y = BVtoZ 0x84009a263fefba7c2c57cffa5db3634d286131afc0fca8d25afa22a7b5dce0d9470da89233cee178592f49b6fecb5092}\n\nproperty p384_full_add_example =\n  p384::full_add_example R p384_S p384_T\n  where R = {x = BVtoZ 0x12dc5ce7acdfc5844d939f40b4df012e68f865b89c3213ba97090a247a2fc009075cf471cd2e85c489979b65ee0b5eed,\n             y = BVtoZ 0x167312e58fe0c0afa248f2854e3cddcb557f983b3189b67f21eee01341e7e9fe67f6ee81b36988efa406945c8804a4b0}\n\nproperty p384_full_subtract_example =\n  p384::full_subtract_example R p384_S p384_T\n  where R = {x = BVtoZ 0x6afdaf8da8b11c984cf177e551cee542cda4ac2f25cd522d0cd710f88059c6565aef78f6b5ed6cc05a6666def2a2fb59,\n             y = BVtoZ 0x7bed0e158ae8cc70e847a60347ca1548c348decc6309f48b59bd5afc9a9b804e7f7876178cb5a7eb4f6940a9c73e8e5e}\n\nproperty p384_double_example =\n  p384::double_example R p384_S\n  where R = {x = BVtoZ 0x2a2111b1e0aa8b2fc5a1975516bc4d58017ff96b25e1bdff3c229d5fac3bacc319dcbec29f9478f42dee597b4641504c,\n             y = BVtoZ 0xfa2e3d9dc84db8954ce8085ef28d7184fddfd1344b4d4797343af9b5f9d837520b450f726443e4114bd4e5bdb2f65ddd}\n\nproperty p384_scalar_multiply_example =\n  p384::scalar_multiply_example R p384_S d\n  where d = BVtoZ 0xa4ebcae5a665983493ab3e626085a24c104311a761b5a8fdac052ed1f111a5c44f76f45659d2d111a61b5fdd97583480\n        R = {x = BVtoZ 0xe4f77e7ffeb7f0958910e3a680d677a477191df166160ff7ef6bb5261f791aa7b45e3e653d151b95dad3d93ca0290ef2,\n             y = BVtoZ 0xac7dee41d8c5f4a7d5836960a773cfc1376289d3373f8cf7417b0c6207ac32e913856612fc9ff2e357eb2ee05cf9667f}\n\nproperty p384_joint_scalar_multiply_example =\n  p384::joint_scalar_multiply_example R p384_S p384_T d e\n  where d = BVtoZ 0xa4ebcae5a665983493ab3e626085a24c104311a761b5a8fdac052ed1f111a5c44f76f45659d2d111a61b5fdd97583480\n        e = BVtoZ 0xafcf88119a3a76c87acbd6008e1349b29f4ba9aa0e12ce89bcfcae2180b38d81ab8cf15095301a182afbc6893e75385d\n        R = {x = BVtoZ 0x917ea28bcd641741ae5d18c2f1bd917ba68d34f0f0577387dc81260462aea60e2417b8bdc5d954fc729d211db23a02dc,\n             y = BVtoZ 0x1a29f7ce6d074654d77b40888c73e92546c8f16a5ff6bcbd307f758d4aee684beff26f6742f597e2585c86da908f7186}\n\nproperty mp_mod_sqrt_384_correct = p384::mp_mod_sqrt_correct\n\nproperty p521_G_compress = p521::G_compress 0x04c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\n\np521_S = {x = BVtoZ 0x000001d5c693f66c08ed03ad0f031f937443458f601fd098d3d0227b4bf62873af50740b0bb84aa157fc847bcf8dc16a8b2b8bfd8e2d0a7d39af04b089930ef6dad5c1b4,\n          y = BVtoZ 0x00000144b7770963c63a39248865ff36b074151eac33549b224af5c8664c54012b818ed037b2b7c1a63ac89ebaa11e07db89fcee5b556e49764ee3fa66ea7ae61ac01823}\n\np521_T = {x = BVtoZ 0x000000f411f2ac2eb971a267b80297ba67c322dba4bb21cec8b70073bf88fc1ca5fde3ba09e5df6d39acb2c0762c03d7bc224a3e197feaf760d6324006fe3be9a548c7d5,\n          y = BVtoZ 0x000001fdf842769c707c93c630df6d02eff399a06f1b36fb9684f0b373ed064889629abb92b1ae328fdb45534268384943f0e9222afe03259b32274d35d1b9584c65e305}\n\nproperty p521_full_add_example =\n  p521::full_add_example R p521_S p521_T\n  where R = {x = BVtoZ 0x000001264ae115ba9cbc2ee56e6f0059e24b52c8046321602c59a339cfb757c89a59c358a9a8e1f86d384b3f3b255ea3f73670c6dc9f45d46b6a196dc37bbe0f6b2dd9e9,\n             y = BVtoZ 0x00000062a9c72b8f9f88a271690bfa017a6466c31b9cadc2fc544744aeb817072349cfddc5ad0e81b03f1897bd9c8c6efbdf68237dc3bb00445979fb373b20c9a967ac55}\n\nproperty p521_full_subtract_example =\n  p521::full_subtract_example R p521_S p521_T\n  where R = {x = BVtoZ 0x000001292cb58b1795ba477063fef7cd22e42c20f57ae94ceaad86e0d21ff22918b0dd3b076d63be253de24bc20c6da290fa54d83771a225deecf9149f79a8e614c3c4cd,\n             y = BVtoZ 0x000001695e3821e72c7cacaadcf62909cd83463a21c6d03393c527c643b36239c46af117ab7c7ad19a4c8cf0ae95ed51729885461aa2ce2700a6365bca3733d2920b2267}\n\nproperty p521_double_example =\n  p521::double_example R p521_S\n  where R = {x = BVtoZ 0x0000012879442f2450c119e7119a5f738be1f1eba9e9d7c6cf41b325d9ce6d643106e9d61124a91a96bcf201305a9dee55fa79136dc700831e54c3ca4ff2646bd3c36bc6,\n             y = BVtoZ 0x0000019864a8b8855c2479cbefe375ae553e2393271ed36fadfc4494fc0583f6bd03598896f39854abeae5f9a6515a021e2c0eef139e71de610143f53382f4104dccb543}\n\nproperty p521_scalar_multiply_example =\n  p521::scalar_multiply_example R p521_S d\n  where d = BVtoZ 0x000001eb7f81785c9629f136a7e8f8c674957109735554111a2a866fa5a166699419bfa9936c78b62653964df0d6da940a695c7294d41b2d6600de6dfcf0edcfc89fdcb1\n        R = {x = BVtoZ 0x00000091b15d09d0ca0353f8f96b93cdb13497b0a4bb582ae9ebefa35eee61bf7b7d041b8ec34c6c00c0c0671c4ae063318fb75be87af4fe859608c95f0ab4774f8c95bb,\n             y = BVtoZ 0x00000130f8f8b5e1abb4dd94f6baaf654a2d5810411e77b7423965e0c7fd79ec1ae563c207bd255ee9828eb7a03fed565240d2cc80ddd2cecbb2eb50f0951f75ad87977f}\n\nproperty p521_joint_scalar_multiply_example =\n  p521::joint_scalar_multiply_example R p521_S p521_T d e\n  where d = BVtoZ 0x000001eb7f81785c9629f136a7e8f8c674957109735554111a2a866fa5a166699419bfa9936c78b62653964df0d6da940a695c7294d41b2d6600de6dfcf0edcfc89fdcb1\n        e = BVtoZ 0x00000137e6b73d38f153c3a7575615812608f2bab3229c92e21c0d1c83cfad9261dbb17bb77a63682000031b9122c2f0cdab2af72314be95254de4291a8f85f7c70412e3\n        R = {x = BVtoZ 0x0000009d3802642b3bea152beb9e05fba247790f7fc168072d363340133402f2585588dc1385d40ebcb8552f8db02b23d687cae46185b27528adb1bf9729716e4eba653d,\n             y = BVtoZ 0x0000000fe44344e79da6f49d87c1063744e5957d9ac0a505bafa8281c9ce9ff25ad53f8da084a2deb0923e46501de5797850c61b229023dd9cf7fc7f04cd35ebb026d89d}\n\nproperty mp_mod_sqrt_521_correct = p521::mp_mod_sqrt_correct\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/ECDSA_sign_tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::ECDSA::ECDSA_sign_tests that imports Common::utils and Primitive::Asymmetric::Signature::ECDSA::p192. Inside the module, define two records named testCase0 and testCase1 with the following fields and meanings: Msg (arbitrary-precision integer message\/hash), d (arbitrary-precision integer private key scalar), k (arbitrary-precision integer nonce), Qx and Qy (arbitrary-precision integer public key coordinates corresponding to d), and R and S (arbitrary-precision integer expected signature scalars). Use the same values and types as the reference and convert the hexadecimal bitvector literals to integers with BVtoZ. Define property test192 that holds exactly when, for each record i drawn from the list [testCase0, testCase1], the tuple (i.R, i.S) equals the result of invoking the P-192 ECDSA signing function on (i.d, i.Msg, i.k). Express this by mapping each test case to a boolean equality of tuples and taking the conjunction over all results. The sign function is provided by the imported p192 module and is expected to accept (private key, message, nonce) as integers and return a pair of integers (r, s). Ensure the property is a boolean suitable for solver checking and that all constants preserve their intended sizes and semantics via BVtoZ conversion."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::ECDSA_sign_tests where\nimport Common::utils\nimport Primitive::Asymmetric::Signature::ECDSA::p192\n\ntestCase0 = {\nMsg = BVtoZ 0x608079423f12421de616b7493ebe551cf4d65b92, d = BVtoZ 0xe14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3,\nk = BVtoZ 0xcb0abc7043a10783684556fb12c4154d57bc31a289685f25,\nQx = BVtoZ 0x07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6,\nQy = BVtoZ 0x76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477,\nR = BVtoZ 0x6994d962bdd0d793ffddf855ec5bf2f91a9698b46258a63e,\nS = BVtoZ 0x02ba6465a234903744ab02bc8521405b73cf5fc00e1a9f41 }\n\ntestCase1 = {\nMsg = BVtoZ 0x98cff299c35616bfd081543998a5a367b43214e1,\nd = BVtoZ 0x7a0235bea3d70445f14d56f9b7fb80ec8ff4eb2f76865244,\nQx = BVtoZ 0x0ea3c1fa1f124f26530cbfddeb831eecc67df31e08889d1d,\nQy = BVtoZ 0x7215a0cce0501b47903bd8fe1179c2dfe07bd076f89f5225,\nk = BVtoZ 0x3c646b0f03f5575e5fd463d4319817ce8bd3022eaf551cef,\nR = BVtoZ 0xa3ba51c39c43991d87dff0f34d0bec7c883299e04f60f95e,\nS = BVtoZ 0x8a7f9c59c6d65ad390e4c19636ba92b53be5d0f848b4e1f7 }\n\nproperty test192 = and [((i.R, i.S) == (sign i.d i.Msg i.k)) | i <- [ testCase0, testCase1] ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named `module_name` that contains the following definitions: `list_definitions` \u2014 (1) a type alias for the 384-bit prime field modulus; (2) a constant for the curve\u2019s Weierstrass coefficient over that field; (3) a base-point record of coordinates with affine components and a projective component set to 1; (4) a type alias for the subgroup order; and (5) a total function that computes modular square roots over the field using a fixed addition chain of squarings and multiplications (no loops), semantically equivalent to exponentiation by (p + 1) \/ 4. Provide explicit type signatures for all items, with the square-root function typed from integers modulo the prime to the same domain. Use concrete literal values for the standardized 384-bit curve parameters and base point. Restrict the function body to field operations and exponentiation by powers of two, following a straight-line sequence of temporaries that culminates in the final square-root result."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::p384 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\ntype p = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\n\nb = 27580193559959705877849011840389048093056905856361568521428707301988689241309860865136260764883745107765439761230575\n\nG = {x = 26247035095799689268623156744566981891852923491109213387815615900925518854738050089022388053975719786650872476732087,\n     y = 8325710961489029985546751289520108179287853048861315594709205902480503199884419224438643760392947333078086511627871,\n     z = 1}\n\ntype q = 39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643\n\nmp_mod_sqrt : Z p -> Z p\nmp_mod_sqrt c = r''' ^^ (2 ^^ 30)\n  where t1    = (c ^^ 2) * c\n        t2    = (t1 ^^ (2 ^^ 2)) * t1\n        t2'   = (t2 ^^ 2) * c\n        t3    = (t2' ^^ (2 ^^ 5)) * t2'\n        t4    = (t3 ^^ (2 ^^ 5)) * t2'\n        t2''  = (t4 ^^ (2 ^^ 15)) * t4\n        t3'   = t2'' ^^ (2 ^^ 2)\n        t1'   = t3' * t1\n        t3''  = t3' ^^ (2 ^^ 28)\n        t2''' = t2'' * t3''\n        t3''' = (t2''' ^^ (2 ^^ 60)) * t2'''\n        r     = (t3''' ^^ (2 ^^ 120)) * t3'''\n        r'    = (r ^^ (2 ^^ 15)) * t4\n        r''   = (r' ^^ (2 ^^ 33)) * t1'\n        r'''  = (r'' ^^ (2 ^^ 64)) * c\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Asymmetric::Signature::ECDSA::p192 that instantiates the generic ECDSA module for the NIST P-192 domain. Include: (1) a numeric type synonym p for the field prime; (2) a constant b for the curve coefficient over GF(p); (3) a constant G, the base point in Jacobian coordinates with fields x, y, and z set to z = 1; (4) a numeric type synonym q for the subgroup order; and (5) a function mp_mod_sqrt that, for an input field element c in GF(p), returns a modular square root by exponentiating c to (p+1)\/4 using a fixed addition chain of repeated squarings by powers of two interleaved with multiplications to achieve the exponent 2^190 \u2212 2^62. Provide clear type signatures: p and q as numeric types, b as a field element modulo p, G as a record with x, y, z in GF(p), and mp_mod_sqrt as GF(p) -> GF(p). Ensure all arithmetic in mp_mod_sqrt occurs modulo p and that the exponentiation chain matches the intended (p+1)\/4 computation for primes congruent to 3 mod 4."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::p192 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\ntype p = 6277101735386680763835789423207666416083908700390324961279\n\nb = 2455155546008943817740293915197451784769108058161191238065\n\nG = {x = 602046282375688656758213480587526111916698976636884684818,\n     y = 174050332293622031404857552280219410364023488927386650641,\n     z = 1}\n\ntype q = 6277101735386680763835789423176059013767194773182842284081\n\nmp_mod_sqrt c = r''\n  where t1 = c ^^ 2         ; t1' = t1 * c\n        t2 = t1' ^^ (2^^2)  ; t2' = t2 * t1'\n        t3 = t2' ^^ (2^^4)  ; t3' = t3 * t2'\n        t4 = t3' ^^ (2^^8)  ; t4' = t4 * t3'\n        t5 = t4' ^^ (2^^16) ; t5' = t5 * t4'\n        t6 = t5' ^^ (2^^32) ; t6' = t6 * t5'\n        r  = t6' ^^ (2^^64) ; r'  = r * t6'\n        r'' = r' ^^ (2^^62)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Asymmetric::Signature::ECDSA::p224 that is based on the ECDSA module and imports the utilities module. Within it, declare: (1) a type synonym p for the prime field modulus of the P-224 curve; (2) a constant b for the curve parameter; (3) a constant G for the base point as a record with fields x, y, z, where all coordinates are elements of Z p and z equals 1; (4) a type synonym q for the group order. Provide the function mp_mod_sqrt : Z p -> Z p that computes a modular square root as follows: derive a seed from the bit-vector representation of the input, build an intermediate triple via RP using the modulus and seed, perform one RS step, then iterate RS producing a stream that stops advancing once the first component becomes zero; select a specific later iteration (the same index as in the original code) and return the product of that iteration\u2019s first component with the modular inverse of its second component, all in Z p. Also define the following helper functions as private with exact type signatures over Z p: RS performing a single iteration update of a (d,e,f) triple using additions, doublings, squarings, and products; RSS performing RS repeated j times where j is a 7-bit index selecting the j-th state; RM combining two (d,e) pairs with the curve constant to produce a new (d,e,f) triple; RP constructing a sequence using repeated squaring and multiply for exponents of two over indices 0 through 6, returning the resulting triple. Ensure all arithmetic and inversions are in the field Z p, and the selected iteration index matches the original algorithm\u2019s choice."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::p224 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\nimport Common::utils\n\ntype p = 26959946667150639794667015087019630673557916260026308143510066298881\n\nb = 18958286285566608000408668544493926415504680968679321075787234672564\n\nG = {x = 19277929113566293071110308034699488026831934219452440156649784352033,\n     y = 19926808758034470970197974370888749184205991990603949537637343198772,\n     z = 1}\n\ntype q = 26959946667150639794667015087019625940457807714424391721682722368061\n\nmp_mod_sqrt : Z p -> Z p\nmp_mod_sqrt c = r\n  where s = random (ZtoBV c)\n        (d0, e0, f0) = RP c s\n        (d1, e1, f1) = RS d0 e0 f0\n        state = [(d1, e1, f1)] #\n                [ if d1' == 0 then (d, e, f) else (d1', e1', f1')\n                  where (d1', e1', f1') = RS d e f\n                | (d, e, f) <- state ]\n        (d0', e0', _) = state@95\n        r = d0' * (mp_mod_inv e0')\n\nprivate\n\n  RS : Z p -> Z p -> Z p -> (Z p, Z p, Z p)\n  RS d0 e0 f0 = (d1, e1', f1'')\n    where t    = d0 ^^ 2\n          e1   = d0 * e0\n          d1   = t + f0\n          e1'  = e1 + e1\n          f1   = t * f0\n          f1'  = f1 + f1\n          f1'' = f1' + f1'\n\n  RSS : Z p -> Z p -> Z p -> [7] -> (Z p, Z p, Z p)\n  RSS d0 e0 f0 j = (d1, e1, f1)\n    where (d1, e1, f1) = state@j\n          state = [(d0, e0, f0)] # [ RS d e f | (d, e, f) <- state ]\n\n  RM : Z p -> Z p -> Z p -> Z p -> Z p -> (Z p, Z p, Z p)\n  RM c d0 e0 d1 e1 = (d2, e2', f2'')\n    where t1    = e0 * e1\n          t1'   = t1 * c\n          t1''  = -t1'\n          t2    = d0 * d1\n          t2'   = t2 + t1''\n          t1''' = d0 * e1\n          e2    = d1 * e0\n          e2'   = e2 + t1'''\n          f2    = e2' ^^ 2\n          f2'   = f2 * c\n          f2''  = -f2'\n          d2    = t2'\n\n  RP : Z p -> Z p -> (Z p, Z p, Z p)\n  RP c r = (d1, e1, f1)\n    where (d1, e1, f1) = state!0\n          state = [(r, 1, -c)] # [ body d e f i | (d, e, f) <- state | i <- [0..6] ]\n          body d0 e0 f0 i = (d1'', e1'', f1'')\n            where (d1', e1', _) = RSS d0 e0 f0 (2^^i)\n                  (d1'', e1'', f1'') = RM c d1' e1' d0 e0\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/DSA\/DSA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Asymmetric::Signature::DSA::DSA that imports Common::mod_arith and Common::utils, and contains: (1) a parameter block declaring numeric parameters p and q with constraints ensuring finiteness, oddness, and minimum size; bit-size parameters L and N constrained to NIST-recommended pairs, with the active choice fixing L to 2048 and N to 224; and a generator constant g of type integers modulo p. Provide a private type alias capturing the common constraint tuple used for such numeric parameters. (2) A function sign with type Z q -> Z q -> Z q -> (Z q, Z q) that implements DSA signing: given secret key x, nonce k, and message representative z (all modulo q), compute r by exponentiating the generator to k modulo p and reducing the result into the order-q domain; compute kinv as the multiplicative inverse of k modulo q; compute s = kinv * (z + x*r) modulo q; and return (r, s). Use the modular exponentiation, multiplication, addition, and inversion utilities from the imported modules, along with conversions between modulo-p\/q integers and L\/N-sized bitvectors as needed. (3) A function verify with type Z p -> Z q -> (Z q, Z q) -> Bit that implements DSA verification: given public key y (mod p), message representative z (mod q), and signature (r, s), compute w = s^{-1} mod q, u1 = z*w mod q, u2 = r*w mod q, and v as the reduction into the order-q domain of (g^u1 * y^u2 mod p); return whether v equals r. (4) Define a property signDsaCorrect that universally quantifies x, k, z in Z q and checks that verify returns True when given the public key derived as g^x mod p, the same message representative, and the signature produced by sign x k z."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::DSA::DSA where\nimport Common::mod_arith\nimport Common::utils\n\nsign : Z q -> Z q -> Z q -> (Z q, Z q)\nsign x k z = (r, s)\n    where r =  ZtoZ (BVtoZ `{p=p}(mod_pow (pv, g', k')))\n          pv = ZtoBV `{1+p,L} `p\n          g' = ZtoBV `{a=L} g\n          k' = ZtoBV `{a=L} (ZtoZ `{q=q} k)\n          s = BVtoZ `{p=q}  (mod_mul (q', (ZtoBV `{a=N} kinv), zpxr))\n          kinv = mp_mod_inv k\n          xr = mod_mul(q', x', r')\n          zpxr = mod_add(q', xr, z')\n          r' = ZtoBV `{a=N} r\n          x' = ZtoBV `{a=N} x\n          z' = ZtoBV `{a=N} z\n          q' = ZtoBV `{1+q,N} `q\n\nverify : Z p -> Z q -> (Z q, Z q) -> Bit\nverify y z (r, s) = ((BVtoZ `{p=q} v) == r)\n   where w = (mp_mod_inv s)\n         u1 = (zero#mod_mul (q', (ZtoBV z), (ZtoBV w))) :[L]\n         u2 = (zero#mod_mul (q', (ZtoBV r), (ZtoBV w))) :[L]\n         v = mod_mul (pv, gu1, yu2)\n         gu1 =  mod_pow(pv, g', u1)\n         yu2 =  mod_pow(pv, y', u2)\n         pv = ZtoBV `{1+p,L} `p\n         g' = ZtoBV `{a=L} g\n         y' = ZtoBV `{a=L} y\n         q' = ZtoBV `{1+q,N} `q\n\nparameter\n\n    type p : #\n    type constraint Constraints p\n\n    g : Z p\n\n    type q : #\n\n    type constraint (fin q, isOdd q, q >= 4)\n\n\/\/ NIST recommended bit lengths of p and q\n\/\/L: the size of p, N: the size of q\n\n    type L : #\n\n    type N : #\n\/\/Comment\/uncomment according to the instantiated parameters\n    \/\/type constraint (L==1024,N==160)\n    type constraint (L==2048,N==224)\n    \/\/type constraint (L==2048,N==256)\n    \/\/type constraint (L==3072,N==256)\n\nprivate\n\n    type constraint Constraints a = (fin a, isOdd a, a >= 4)\n    \/\/type constraint validPsize L x = (L==1024*x, 2>=x)\n    \/\/type constraint validQsize N = (N==160) \/\/N==224, N==256\n\nproperty signDsaCorrect x k z = (verify (BVtoZ `{p=p} (mod_pow ((ZtoBV `{1+p,L} `p), ZtoBV `{a=L} g, (zero#(ZtoBV`{p=q}x):[L])))) z (sign x k z) ) == True\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/trash\/DilithiumBv.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Asymmetric::Signature::DilithiumBV that contains: (1) constants and parameters: bit widths qbits=23 and uint32_t=32; modulus q; polynomial length n=256; d; wc; gamma1=(q\u22121)\/16; gamma2=gamma1\/2; alpha=2*gamma2; NTT parameters rootOfUnity, rootOfUnityInv, ninv; type parameters k and l with constraints fin k, 3<=k<=6; fin l, 2<=l<=5; constants eta (4 bits), beta (12 bits), omega (8 bits), SEEDBYTES=32. (2) type definitions: intPoly=[n][uint32_t], intPolyVec dim=[dim]intPoly; poly=[n][qbits], polyVec dim=[dim]poly; nttPoly=[n][qbits], nttVec dim=[dim]nttPoly, nttMat dim1 dim2=[dim1](nttVec dim2); records PublicKey {rho:[256], t1:intPolyVec k} and SecretKey {rho:[256], K:[256], tr:[384], s1:polyVec l, s2:polyVec k, t0:intPolyVec k}. (3) functions: Gen(seed) deriving rho, rho\u2032, K via SHAKE256; returns A=ExpandA(rho) and forms s1 with PolyUniformEtaV. PolyUniformEtaV(rho, nonce) producing a vector of dim polynomials (constraints: fin dim, dim>=1, width(dim\u22121)<=8). PolyUniformEta(seed, nonce) sampling centered small coefficients using SHAKE256 and rejection via randomsInRangeDouble with genS (which extracts two 4-bit nibbles from a byte). H(mu, w) computing a challenge polynomial by hashing mu with a packed form of w (pack_w is private: packs k integer polynomials by taking low 8 bits of coefficients and packing two nibbles per byte) and constructing a sparse length-n integer vector via SampleInBall(signs, positions). ExpandMask(K, mu, kappa) producing polyVec l using samplePoly; samplePoly uses SHAKE256, extractPolyElt to parse 40-bit chunks into two 20-bit values, rejection-samples, and shifts into [0,q). CRH(seed) maps any [b*8] to [384] using SHAKE256 (constraints: fin b, b>=1). ExpandA(rho) builds a k\u00d7l matrix of nttPoly via matrixPoly; matrixPoly uses SHAKE128 and rejection with extractMatElt to ensure coefficients < q. Include helpers extractPolyElt, extractMatElt, and generic stream samplers randomsInRange, randomsInRanges, randomsInRangeDouble, with appropriate type constraints."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::DilithiumBV where\n\nimport Primitive::Keyless::Hash::keccak as SHA3\nimport Common::utils\nimport Common::mod_arith\nimport Primitive::Asymmetric::Cipher::RSA\nimport Primitive::Asymmetric::Signature::testDilithium\n\ntype qbits = 23\ntype uint32_t = 32\ntype q = 0x7fe001 type n = 0x100 d = 0xe\nwc= 0x3c gamma1 = ((`q) - 1) \/ 16:[_]\ngamma2 = (gamma1\/2):[_]\nalpha = (2*gamma2):[_]\n\nrootOfUnity    = 1753 :[_]\nrootOfUnityInv = 731434 : [_]\nninv           = 8347681 : [_]\n\nparameter\n    type k : #\n    type constraint (fin k, k>=3, k <=6)\n    type l : #\n    type constraint (fin l, l>=2, l<=5)\n    eta : [4]\n    beta : [12]\n    omega : [8]\n\ntype intPoly        = [n][uint32_t]\ntype intPolyVec dim = [dim]intPoly\n\ntype poly        = [n][qbits] type polyVec dim = [dim]poly\n\ntype nttPoly          = [n][qbits]\ntype nttVec dim       = [dim]nttPoly\ntype nttMat dim1 dim2 = [dim1](nttVec dim2)\n\ntype PublicKey = {rho : [256], t1 : intPolyVec k}\ntype SecretKey = {rho : [256]\n                    , K  : [256]\n                    , tr : [384]\n                    , s1 : polyVec l\n                    , s2 : polyVec k\n                    , t0 : intPolyVec k}\ntype SEEDBYTES = 32\n\nGen seed = A\n    where\n      randoms = split`{3} (join (SHA3::toBytes (take`{768} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))\n      (rho, rho', K) = (randoms@0, randoms@1, randoms@2)\n      A       = ExpandA rho\n      s1      = PolyUniformEtaV`{dim=l} rho' zero\n\nprivate\n    pack_w : intPolyVec k -> [4*n*k]\n    pack_w w = join [pack_poly p | p <- wBV ]\n        where\n        wBV = map (\\p -> map (\\x -> drop`{24} x:[8]) p) w\n\n        pack2 : [2][8] -> [8]\n        pack2 xs = xs@0 || (xs@1 << 4)\n\n        pack_poly p = join [ pack2 xs | xs <- split p : [128][2][_] ]\n\nPolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [8] -> polyVec dim\nPolyUniformEtaV rho nonce = [PolyUniformEta rho (nonce + j) | j <- [0..(dim-1)]:[dim][8]]\n\nPolyUniformEta : [SEEDBYTES*8] -> [8] -> poly\nPolyUniformEta rho nonce = map (\\x -> (zero#eta:[23]) - x) (map (\\x-> (zero#x):[23]) (take`{n} withinEta))\n    where\n    seed = rho#nonce\n    randoms = ((join (SHA3::toBytes (take`{2*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))#zero)\n    withinEta = randomsInRangeDouble genS (2*eta) randoms\n\ngenS : [8] -> [2][4]\ngenS byte = [t0, t1]\n    where\n    t0 = drop`{4} (byte && 0x0F)\n    t1 = drop`{4} (byte >> 4)\n\nH : ([384],intPolyVec k) -> poly\nH (mu,w) = map fromInteger (SampleInBall ss samples)\n    where\n    w_packed = pack_w w\n    randoms  = join (SHA3::toBytes (take`{4352} (SHA3::SHAKE256 (join (SHA3::toBytes (mu#w_packed))))))\n    ss       = take`{60}(reverse (join (reverse (split (take`{64} randoms):[8][8]))))\n\n    extByte : [8] -> [8]\n    extByte x = x\n\n    samples : [60][8]\n    samples = take`{60} (randomsInRanges extByte [196..255] (drop`{64} randoms#zero))\n\nSampleInBall : [60] -> [60][8] -> [256]Integer\nSampleInBall signs jsamples = ys ! 0\n    where\n    ys = [ zero:[256]Integer ]\n        #    [ if i==j then update y i ((-1:Integer)^^(toInteger [s]))\n            else updates y [j,i] [(-1:Integer)^^(toInteger [s]),y@j] | i <- [196..255]\n        | j <- jsamples\n        | s <- signs\n        | y <- ys\n        ]\n\nExpandMask : ([SEEDBYTES*8], [384], Integer) -> polyVec l\nExpandMask  (K, mu, kappa) = [samplePoly K mu kappa i `l | i <- [0..(l-1)] ]\n\nsamplePoly : [256] -> [384] -> Integer -> Integer -> Integer -> poly\nsamplePoly K mu kappa i dim = [ (`q + (zero#gamma1:[23]) - (zero#1:[23]) - (zero#vj:[23])) | vj <- coeffs]\n    where\n    (upper:[20])      =  drop`{3}(2*gamma1-2):[20]\n    kappaBytes = join (reverse (split (fromInteger (dim*kappa+i):[16]):[2][8]))     s          = join (SHA3::toBytes (take`{5*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes (K#mu#kappaBytes))))))     (coeffs:[n][20])   = take`{n} (randomsInRangeDouble extractPolyElt upper (s#zero))\n\nextractPolyElt : [40] -> [2][20]\nextractPolyElt bits = [zero#int1, zero#int2]\n    where\n    [b0,b1,b2,b3,b4] = [(zero#b):[20] | b <- split bits : [5][8]]\n    int1 = b2'*2^^16 + b1*2^^8 +  b0\n    int2 = b4*2^^12 + b3*2^^4 +  b2''\n    b2'  = b2 && 15\n        b2'' = b2\/16\n\nCRH : {b} (fin b, b>=1) => [b*8] -> [384]\nCRH seed = join (SHA3::toBytes (take`{48*8} (SHA3::SHAKE256 (join (SHA3::toBytes seed)))))\n\nExpandA : [SEEDBYTES*8] -> [k][l]nttPoly\nExpandA rho = [ [elt i j | j <- [0..(l-1)] ] |  i <- [0..(k-1)] ]\n    where\n    elt i j = matrixPoly rho i j\n\nmatrixPoly : [SEEDBYTES*8] -> [width k] -> [width l] -> nttPoly\nmatrixPoly rho i j = take`{n} [ drop`{1} elt | elt <- randomElts ]\n    where\n    randomElts = randomsInRange extractMatElt ((>=) (`q)) (s#zero)\n    s          = join (SHA3::toBytes (take`{6720} (SHA3::SHAKE128 (join (SHA3::toBytes (rho#b))))))\n    b          = 2^^4*(zero#j:[8])+(zero#i:[8])\n\nextractMatElt : [24] -> [24]\nextractMatElt rands = zero#(2^^16 * b2' + 2^^8 * b1 + b0):[24]\n    where\n    [b0, b1, b2] = [(zero#b):[23] | b <- split`{3} rands]\n    b2' = (2^^23-1) && b2 \n\nrandomsInRange : {a} (fin a) => ([a]-> [a]) -> ([a] -> Bit) -> [inf] -> [inf][a]\nrandomsInRange createElt upperCrit randoms = if (upperCrit elt )\n                                             then  [ elt ]#(randomsInRange createElt upperCrit randomTail)\n                                             else randomsInRange createElt upperCrit randomTail\n                    where\n                    elt        = createElt (take`{a} randoms)\n                    randomTail = drop`{a} randoms\n\nrandomsInRanges : {a,m} (fin a,fin m, m>=1) => ([a]-> [a]) -> [m][a] -> [inf] -> [inf][a]\nrandomsInRanges createElt uppers randoms =\n                                            if elt <= head uppers\n                                            then  [ elt ]#(randomsInRanges createElt uppersRotate randomTail)\n                                            else randomsInRanges createElt uppers randomTail\n                                where\n                                elt          = createElt (take`{a} randoms)\n                                randomTail   = drop`{a} randoms\n                                uppersRotate = uppers <<< 1\n\nrandomsInRangeDouble : {a} (fin a) => ([2*a]-> [2][a]) -> [a] -> [inf] -> [inf][a]\n\nrandomsInRangeDouble createElt upper randoms =\n                                    if (elts@1 <= upper) then [elts@1, elts@1] # (randomsInRangeDouble createElt upper randomTail)\n                                    else (randomsInRangeDouble createElt upper randomTail)\n            where\n            elts       = createElt (take`{2*a} randoms)\n            randomTail = drop`{2*a} randoms\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/ref_ec_mul.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Common::EC::ref_ec_mul that imports Common::EC::ec_point_ops and contains the following definitions: ec_mul, ec_twin_mul_aux1, F, and ec_twin_mul. Specify all types and constraints explicitly. For ec_mul, make it polymorphic over a field element width fv and a scalar width gv with gv finite; take a tuple of a point-ops interface over fv and gv, a gv-bit scalar, and an affine point over fv; return a Jacobian point over fv. Implement left-to-right scalar multiplication using only the provided point operations, performing a conditional add, subtract, or double each step based on a signed-bit recoding derived from the scalar and its triple. For ec_twin_mul_aux1, parametrize over fv and gv with gv finite and at least 4; take a point-ops interface, a running Jacobian point, two 32-bit signed control digits, and four precomputed affine points (sum, base, difference, and the second base); return the updated Jacobian point produced by doubling then conditionally adding or subtracting one of the precomputed points according to whether each control digit is \u22121, 0, or 1. For F, parametrize over a with a finite and at least 5; map an a-bit word to a fixed a-bit constant chosen by which of five half-open numeric intervals the input falls into. For ec_twin_mul, parametrize over fv and gv with gv finite; take a point-ops interface over fv and gv+4, two scalars of width gv+4, and two affine points; return a Jacobian point. Implement simultaneous scalar multiplication by normalizing sum\/difference precomputations via field operations, generating a stream of two signed control digits per step using F, iterating with ec_twin_mul_aux1, and handling identity-point special cases by reducing to single-scalar multiplication."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::ref_ec_mul where\n\nimport Common::EC::ec_point_ops\n\nec_mul : {fv, gv}  (fin gv) => (PointOps fv [gv], [gv], AffinePoint fv) -> JacobianPoint fv\nec_mul (m, d, s) = res!0\n  where\n    k = [False, False] # d\n    h = k + (k + k)\n    res : [gv+2](JacobianPoint fv)\n    res = [(ec_zero_point(m.field))]\n          #  [ if hi && ~ki then\n                 m.add(m.double(r), s)\n               else if ~hi && ki then\n                 m.sub(m.double(r), s)\n               else\n                 m.double(r)\n             | hi <- take`{back=1} h\n             | ki <- take`{back=1} k\n             | r  <- res\n             ]\n\nec_twin_mul_aux1 : {fv, gv} (fin gv, gv >= 4) =>\n  (PointOps fv [gv], JacobianPoint fv, [32], [32],\n   AffinePoint fv, AffinePoint fv, AffinePoint fv, AffinePoint fv)\n  -> (JacobianPoint fv)\nec_twin_mul_aux1(m,rP,u0,u1,sPt,s,sMt,t) = r\n  where\n   f = m.field\n   r = if u0 == -1 then\n         (if      u1 == -1 then m.sub(r2, sPt)\n          else if u1 ==  0 then m.sub(r2, s)\n          else                  m.sub(r2, sMt))\n       else if u0 == 0 then\n         (if      u1 == -1 then m.sub(r2, t)\n          else if u1 ==  1 then m.add(r2, t)\n          else                  r2)\n       else\n         (if      u1 == -1 then m.add(r2, sMt)\n          else if u1 ==  0 then m.add(r2, s)\n          else                  m.add(r2, sPt))\n   r2 = m.double(rP)\n\nF : {a} (fin a, a>=5) => [a] -> [a]\nF(t) = if (18 <= t) && (t < 22) then\n          9\n       else if (14 <= t) && (t < 18) then\n         10\n       else if (22 <= t) && (t < 24) then\n         11\n       else if (4 <= t) && (t < 12) then\n         14\n       else\n         12\n\nec_twin_mul : {fv, gv} (fin gv)\n            => (PointOps fv [gv+4], [gv+4], AffinePoint fv, [gv+4], AffinePoint fv)\n            -> (JacobianPoint fv)\nec_twin_mul(m, d0, s, d1, t) =\n  if ec_is_zero_point(f, sPtP) then \n    ec_mul(m, g.sub(d0, d1), s)\n  else if ec_is_zero_point(f, sMtP) then \n    ec_mul(m, g.add(d0, d1), s)\n  else\n    drop`{gv+4}(r)@0\n where\n   f    = m.field\n   g    = m.group_field\n   sP   = ec_projectify(f, s)\n   sPtP = m.add(sP, t) \n   sMtP = m.sub(sP, t) \n   sDiv = f.div(f.field_unit, f.mul(sPtP.z, sMtP.z))\n   sPt  = { x = f.mul(g2, sPtP.x)\n          , y = f.mul(f.mul(gd, g2), sPtP.y)\n          }\n     where gd = f.mul(sMtP.z, sDiv)\n           g2 = f.sq(gd)\n   sMt  = { x = f.mul(g2, sMtP.x)\n          , y = f.mul(f.mul(gd, g2), sMtP.y)\n          }\n     where gd  = f.mul(sPtP.z, sDiv)\n           g2 = f.sq(gd)\n   init_c : [2][6]\n   init_c = [zero # (take(d0) : [4]), zero # (take(d1) : [4])]\n   c : [inf]_\n   c = [init_c]\n     # [ [[abs(u0) ^ c01, c02, c03, c04, c05, e0N],\n          [abs(u1) ^ c11, c12, c13, c14, c15, e1N]]\n          where\n            abs : {a} (fin a) => [a] -> Bit\n            abs(x) = x != zero\n       | [[c00, c01, c02, c03, c04, c05], [c10, c11, c12, c13, c14, c15]] <- c\n       | [u0, u1] <- u\n       | e0N <- (drop`{4}(d0)) # (zero : [inf])\n       | e1N <- (drop`{4}(d1)) # (zero : [inf])\n       ]\n   u : [inf]_\n   u = [ [u0, u1]\n            where\n              h0' = [c05, c04, c03, c02, c01]\n              h0 = if c00 then 31 - h0' else h0'\n              h1' = [c15, c14, c13, c12, c11]\n              h1 = if c10 then 31 - h1' else h1'\n              u0 : [32]\n              u0 = if h0 < F(h1) then 0 else if c00 then -1 else 1\n              u1 : [32]\n              u1 = if h1 < F(h0) then 0 else if c10 then -1 else 1\n       | [[c00, c01, c02, c03, c04, c05], [c10, c11, c12, c13, c14, c15]] <- c\n       ]\n   r : [inf]_\n   r = [(ec_zero_point f)]\n     # [ ec_twin_mul_aux1(m, rP, u0, u1, sPt, s, sMt, t)\n       | rP      <- r\n       | [u0, u1] <- u\n       ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/p384_ec_point_ops.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Common::EC::p384_ec_point_ops that contains the following definitions: p384_point_ops, p384_ec_double, p384_ec_full_add, and p384_ec_full_sub. Import the elliptic-curve point operations module and the P-384 finite field module. Specify p384_point_ops to have type PointOps [384] [384] and to bundle the P-384 field and group parameters with the point operation implementations: set its field component to the P-384 field constant, its group_field component to the P-384 group descriptor, its double component to p384_ec_double, its add component to p384_ec_full_add, and its sub component to p384_ec_full_sub. Provide type signatures: p384_ec_double : JacobianPoint [384] -> JacobianPoint [384]; p384_ec_full_add : (JacobianPoint [384], AffinePoint [384]) -> JacobianPoint [384]; p384_ec_full_sub : (JacobianPoint [384], AffinePoint [384]) -> JacobianPoint [384]. Define p384_ec_double to delegate to the generic Jacobian point doubling over the imported P-384 field. Define p384_ec_full_add to delegate to the generic mixed-coordinate full addition using the p384_point_ops bundle. Define p384_ec_full_sub to delegate to the generic mixed-coordinate full subtraction using the p384_point_ops bundle. Ensure all points use 384-bit coordinates consistent with the imported types, and that all functions are specialized to the P-384 field and group parameters via the provided imports. Do not include proofs; only provide the module, imports, type signatures, and definitions with the described delegations."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::p384_ec_point_ops where\n\nimport Common::EC::ec_point_ops\nimport Common::EC::p384_field\n\np384_point_ops : PointOps [384] [384]\np384_point_ops = {\n    field  = p384_field\n  , double = p384_ec_double\n  , add    = p384_ec_full_add\n  , sub    = p384_ec_full_sub\n  , group_field = p384_group_field\n  }\n\np384_ec_double : JacobianPoint [384] -> JacobianPoint [384]\np384_ec_double(p) = ec_double(p384_field, p)\n\np384_ec_full_add : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384]\np384_ec_full_add(p,q) = ec_full_add(p384_point_ops, p, q)\n\np384_ec_full_sub : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384]\np384_ec_full_sub(p,q) = ec_full_sub(p384_point_ops, p, q)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/EC_P384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::EC::EC_P384 that contains the following definitions, types, and semantics for the NIST P-384 curve: import the modular-division helper used to compute modular inverses for arbitrary moduli. Provide a bit-width alias equal to 384 and the curve prime modulus. Define type aliases for field elements and scalars as unbounded integers. Declare curve parameters for a short Weierstrass curve with a equal to \u22123 and b equal to the standard P-384 constant. Define the affine base point with its standard x and y coordinates and the subgroup order. Provide Montgomery constants for the field modulus and group order (radix and their inverses), consistent with the chosen modulus and order. Implement conversions between integers and width-parameterized bitvectors for both field elements and scalars. Provide a modular inverse over the group order for nonzero scalars. Define an affine point record type and implement elliptic-curve point addition and scalar multiplication over the field modulus, assuming valid, non-infinite inputs. Implement key derivation from a private scalar by reducing modulo the order and multiplying by the base point. Define an ECDSA signature record and implement signing (compute r from the x-coordinate of k\u00b7G reduced modulo the order; compute s as k\u207b\u00b9\u00b7(z + r\u00b7d) modulo the order) and verification (range-check r and s; compute u1 = z\u00b7s\u207b\u00b9 and u2 = r\u00b7s\u207b\u00b9 modulo the order; verify r equals the x-coordinate of u1\u00b7G + u2\u00b7Q reduced modulo the order). Implement ECDH to output the x-coordinate of d\u00b7Q reduced modulo the field modulus. Define Jacobian point types and conversions to\/from affine (with z=1 for affine), Jacobian addition and scalar multiplication, and conversions to\/from width-parameterized bitvectors. Provide Montgomery-domain conversions for Jacobian coordinates and their bitvector wrappers. Implement generic helpers mont_R, mont_R_inv (using the imported division), and bn_mont_n0 with constraints that the modulus width is finite and at least 3. Re-export P-384-specific aliases and constants (types, parameters, base point in affine and Jacobian, and Montgomery constants)."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::EC_P384 where\n\nimport Common::ModDivZ\n\ntype w = 384\n\ntype p = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\n\ntype FieldElement = Integer\n\na : FieldElement\na = -3\nb : FieldElement\nb = `0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\n\nG : AffinePoint\nG =\n  { x = `0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\n  , y = `0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\n  }\n\ntype n = 39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643\n\ntype Scalar = Integer\n\nR_p : FieldElement\nR_p = 340282367000166625977638945021017194497\nR_p_inv : FieldElement\nR_p_inv = 183479889321925461653251752109332205360611897149516305954304919627392402791260477631193651879713439593005062\n\nR_n : Scalar\nR_n = 1388124618062372383947042015309946732620727252194336364173\nR_n_inv : Scalar\nR_n_inv = 8213155180316830564023772752902517460134849974600554980379995049303147060140144611822562736815346652390458105321745\n\nfieldElementToBV : FieldElement -> [w]\nfieldElementToBV x = fromInteger x\n\nfieldElementFromBV : [w] -> FieldElement\nfieldElementFromBV x = toInteger x\n\nscalarToBV : Scalar -> [w]\nscalarToBV x = fromInteger x\n\nscalarFromBV : [w] -> Scalar\nscalarFromBV x = toInteger x\n\ninv0 : Scalar -> Scalar\ninv0 = undefined\n\ntype AffinePoint = { x : FieldElement, y : FieldElement }\n\nec_point_affine_add : AffinePoint -> AffinePoint -> AffinePoint\nec_point_affine_add = undefined\n\nec_point_affine_scalar_mul : Scalar -> AffinePoint -> AffinePoint\nec_point_affine_scalar_mul = undefined\n\nEC_keyPrivateToPublic : Integer -> AffinePoint\nEC_keyPrivateToPublic d = ec_point_affine_scalar_mul (d % `n) G\n\ntype ECDSA_Signature = { r : Scalar, s : Scalar }\n\nECDSA_sign : Scalar -> Integer -> Scalar -> ECDSA_Signature\nECDSA_sign d z k = { r = r, s = s }\n  where\n    { x = x1, y = _ } = ec_point_affine_scalar_mul k G\n    r =  x1 % `n\n    s = ((inv0 k) * (z + r * d)) % `n\n\nECDSA_verify : AffinePoint -> Integer -> ECDSA_Signature -> Bit\nECDSA_verify Q z { r = r, s = s } = r != 0 \/\\ r < `n \/\\ s != 0 \/\\ s < `n \/\\ r == x1 % `n\n  where\n    u1 = z * (inv0 s) % `n\n    u2 = r * (inv0 s) % `n\n    { x = x1, y = _ } = ec_point_affine_add (ec_point_affine_scalar_mul u1 G) (ec_point_affine_scalar_mul u2 Q)\n\nECDH_derive : Scalar -> AffinePoint -> FieldElement\nECDH_derive d Q = x % `p\n  where\n    { x = x, y = _ } = ec_point_affine_scalar_mul d Q\n\ntype JacobianPoint = { x : FieldElement, y : FieldElement, z : FieldElement }\n\ntoJacobian : AffinePoint -> JacobianPoint\ntoJacobian p = { x = p.x, y = p.y, z = 1 }\nfromJacobian : JacobianPoint -> AffinePoint\nfromJacobian p = undefined\n\nec_point_jacobian_add : JacobianPoint -> JacobianPoint -> JacobianPoint\nec_point_jacobian_add = undefined\n\nec_point_jacobian_scalar_mul : Scalar -> JacobianPoint -> JacobianPoint\nec_point_jacobian_scalar_mul = undefined\n\ntype JacobianBVPoint = { X : [w], Y : [w], Z : [w] }\n\njacobianToBV : JacobianPoint -> JacobianBVPoint\njacobianToBV p =\n  { X = fieldElementToBV p.x\n  , Y = fieldElementToBV p.y\n  , Z = fieldElementToBV p.z\n  }\n\njacobianFromBV : JacobianBVPoint -> JacobianPoint\njacobianFromBV p =\n  { x = fieldElementFromBV p.X\n  , y = fieldElementFromBV p.Y\n  , z = fieldElementFromBV p.Z\n  }\n\njacobianToMont : JacobianPoint -> JacobianPoint\njacobianToMont p =\n  { x = (p.x * P384_R_p) % `p\n  , y = (p.y * P384_R_p) % `p\n  , z = (p.z * P384_R_p) % `p\n  }\n\njacobianFromMont : JacobianPoint -> JacobianPoint\njacobianFromMont p =\n  { x = (p.x * P384_R_p_inv) % `p\n  , y = (p.y * P384_R_p_inv) % `p\n  , z = (p.z * P384_R_p_inv) % `p\n  }\n\njacobianToMontBV : JacobianPoint -> JacobianBVPoint\njacobianToMontBV p = jacobianToBV (jacobianToMont p)\n\njacobianFromMontBV : JacobianBVPoint -> JacobianPoint\njacobianFromMontBV p = jacobianFromMont (jacobianFromBV p)\n\nmont_R : {m} (fin m, m >= 3) => Integer\nmont_R = 2 ^^ `(width m) % `m\n\nmont_R_inv : {m} (fin m, m >= 3) => Integer\nmont_R_inv = fromZ (moddiv`{m} 1 (fromInteger (mont_R`{m})))\n\nbn_mont_n0 : {m} (fin m, m >= 3) => [64]\nbn_mont_n0 = fromInteger (((2 ^^ `(width m)) * mont_R_inv`{m} - 1) \/ `m)\n\ntype P384_w = w\ntype P384_p = p\nP384_a = a\nP384_b = b\nP384_G = G\nP384_G_Jacobian = toJacobian G\ntype P384_n = n\n\nP384_R_p = R_p\nP384_R_p_inv = R_p_inv\nP384_R_n = R_n\nP384_R_n_inv = R_n_inv\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/p384_ec_mul.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::EC::p384_ec_mul that imports the required bit-vector, Java-array, P-384 field, and point-ops libraries, and contains the following definitions with precise types and constraints:\n- mk_strm: polymorphic over element width b and finite length a; converts a finite sequence of elements into an infinite stream by appending zeros.\n- ripple_adc: polymorphic ripple-carry adder over n words of m bits (m >= 1), returning the word-wise sum and the final carry bit; specify its internal per-word add-with-carry behavior.\n- ripple_shr: for n >= 1, performs a word-wise right shift across an array of m-bit words with a single-bit carry-in that ripples from most- to least-significant word; return the shifted array.\n- property ripple_adc_toJavaArray: verify that adding two 384-bit values via their 12\u00d732 word-array representation yields the same word-array and carry as big-integer addition with the provided carry function.\n- property ripple_shr_toJavaArray: verify that the word-wise right shift with carry-in equals the big-integer construction formed by prefixing the carry bit and dropping the last bit to keep width.\n- p384_ec_zero_point: constant Jacobian zero point for the P-384 curve.\n- p384_ec_mul: scalar multiplication on P-384 with type (scalar, affine point) -> Jacobian point; implement the Java-style bit-scanning algorithm that initializes h = d + (d >> 1) and iterates j from 383..0, doubling each step and conditionally full-adds or full-subs based on bits from h and a recoded scalar window.\n- p384_ec_mul_aux: helper that for a given bit index computes masks from two adjacent 32-bit words, doubles, and conditionally adds\/subtracts.\n- p384_ec_mul_init: prepares h and the initial accumulator point depending on the carry from h computation.\n- p384_ec_twin_mul_init: initializes double-scalar multiplication, handling equal-x special cases and computing adjusted affine points using field\/group operations.\n- p384_ec_twin_mul_aux1: wrapper invoking twin-mul step with P-384 ops.\n- p384_ec_twin_mul_aux2: 32-bit recoding update producing u0\/u1 in {-1,0,1}, updated control words, and next shift.\n- p384_ec_twin_mul_aux_F32: 32-bit version of the F helper.\n- p384_ec_twin_mul: double-scalar multiplication that seeds state from the init function and folds over all bit positions to produce the final Jacobian point."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::p384_ec_mul where\n\nimport Common::bv\nimport Common::mul_java\nimport Common::EC::ec_point_ops\nimport Common::EC::p384_field\nimport Common::EC::p384_ec_point_ops\nimport Common::EC::ref_ec_mul\n\nmk_strm : {a, b} fin a => [a][b] -> [inf][b]\nmk_strm x = x # zero\n\nripple_adc : {m, n} (m >= 1, fin m, fin n) => ([n][m],[n][m]) -> ([n][m],Bit)\nripple_adc(xx,yy) = (values, carry_strm!0)\n  where\n    adc' : ([m],[m],Bit) -> (Bit,[m])\n    adc'(x,y,c) = (sum3@0, drop(sum3))\n      where sum3 = safe_add(x,y) + zext([c])\n    list = [ adc'(a,b,c)\n           | a <- xx\n           | b <- yy\n           | c <- carry_strm\n           ]\n    values = [ v | (_,v) <- list ]\n    carry_strm : [n+1]\n    carry_strm  = [False] # [ c | (c,_) <- list ]\n\nproperty ripple_adc_toJavaArray x y =\n  ripple_adc (toJavaArray x, toJavaArray y) == (toJavaArray (x + y), carry x y)\n\n\/* Returns (xl # c) >> 1. *\/\nripple_shr : {m, n} (m >= 1, fin m, n >= 1, fin n) => ([n][m],Bit) -> ([n][m])\nripple_shr(xl,c) = [ (x' << (length(x) - 1:[width m])) || (x >> 1)\n                   | x <- xl\n                   | x' <- drop`{1}(xl) # [(zext([c]))]\n                   ]\n\nproperty ripple_shr_toJavaArray x c =\n  ripple_shr (toJavaArray x, c) == toJavaArray (take`{back=1} ([c] # x))\n\np384_ec_zero_point : JacobianPoint [384]\np384_ec_zero_point = ec_zero_point(p384_field)\n\n\/* Matches Java implementation *\/\np384_ec_mul : ([384], AffinePoint [384]) -> JacobianPoint [384]\np384_ec_mul (d, s) = res!0\n  where\n    d' : [12][32]\n    d' = toJavaArray d\n    ini =  p384_ec_mul_init(d, s)\n    h : [12][32]\n    h = toJavaArray (ini.h)\n    r0 = ini.r\n    f (j, r) = p384_ec_mul_aux(r, s, j, h@i, c, d'@i, d_at_ip1)\n      where\n        i        = j >> 5\n        c        = i < 11\n        d_at_ip1 = if c then d'@(i+1) else 0\n                   \/* NB: We guard indexing here to avoid bounds VCs;\n                      p384_ec_mul_aux's use of d_at_ip1 is likewise\n                      guarded. *\/\n    res : [385]_\n    res = [r0] #\n          [ f(j, r)\n          | j <- reverse [0..383]\n          | r <- res\n          ]\n\np384_ec_mul_aux : ( JacobianPoint [384]\n                   , AffinePoint [384]\n                   , [32], [32], Bit, [32], [32] ) -> JacobianPoint [384]\np384_ec_mul_aux (r, s, j, hi, i_lt_11, d_at_i, d_at_ip1) = r'\n  where\n    m = 1 << (j && 31)\n    ki  = d_at_i >> 1\n    ki' = if i_lt_11 then\n            ((d_at_ip1 && 1) << 31) || ki\n          else\n            ki\n    r2 = p384_ec_double(r)\n    r'  = if ((hi && m) != 0) && ((ki' && m) == 0) then\n            p384_ec_full_add(r2, s)\n          else if ((hi && m) == 0) && ((ki' && m) != 0) then\n            p384_ec_full_sub(r2, s)\n          else\n            r2\n\np384_ec_mul_init : ([384], AffinePoint [384]) ->\n                   { h: [384], r: JacobianPoint [384] }\np384_ec_mul_init (d, s) = { h = fromJavaArray h0, r = r0 }\n  where\n    d' : [12][32]\n    d' = toJavaArray d\n    (h0, c) = ripple_adc(d', ripple_shr(d', False))\n    r0 = if c then ec_projectify(p384_field, s)\n              else p384_ec_zero_point\n\np384_ec_twin_mul_init :\n  ([384], AffinePoint [384], [384], AffinePoint [384]) ->\n  { r : JacobianPoint [384]\n  , sMt : AffinePoint [384]\n  , sPt : AffinePoint [384]\n  }\np384_ec_twin_mul_init(d0, s, d1, t) =\n  { r = r0\n  , sPt = if s.x == t.x then azero else sPt0\n  , sMt = if s.x == t.x then azero else sMt0\n  }\n  where\n    azero = { x = 0:[384], y = 0:[384] }\n    r0 =\n      if s.x == t.x then\n        if s.y == t.y then\n          p384_ec_mul(g.add(d0, d1), s)\n        else\n          p384_ec_mul(g.sub(d0, d1), s)\n      else\n        ec_zero_point f\n    m    = p384_point_ops\n    f    = m.field\n    g    = m.group_field\n    sP   = ec_projectify(f, s)\n    sPtP = m.add(sP, t) \/* 1: ec_full_add (SpT, S, T) *\/\n    sMtP = m.sub(sP, t) \/* 2: ec_full_sub (SmT, S, T) *\/\n    sDiv = f.div(f.field_unit, f.mul(sPtP.z, sMtP.z))\n    sPt0 = { x = f.mul(sPtP.x, g2), y = f.mul(f.mul(sPtP.y, g1), g2) }\n           where g1 = f.mul(sMtP.z, sDiv)\n                 g2 = f.sq(g1)\n    sMt0 = { x = f.mul(sMtP.x, g2), y = f.mul(f.mul(sMtP.y, g1), g2) }\n           where g1 = f.mul(sPtP.z, sDiv)\n                 g2 = f.sq(g1)\n\np384_ec_twin_mul_aux1 :\n  (JacobianPoint [384], [32], [32], AffinePoint [384], AffinePoint [384], AffinePoint [384], AffinePoint [384])\n  -> JacobianPoint [384]\np384_ec_twin_mul_aux1(rP, u0_32, u1_32, sPt, s, sMt, t) =\n  ec_twin_mul_aux1(p384_point_ops, rP, u0_32, u1_32, sPt, s, sMt, t)\n\np384_ec_twin_mul_aux2 : ([32],[32],[32],[32],[32],[32],[32],Bit,Bit) ->\n  { tma2_u0:[32]\n  , tma2_u1:[32]\n  , tma2_c0':[32]\n  , tma2_c1':[32]\n  , tma2_e0':[32]\n  , tma2_e1':[32]\n  , tma2_sh':[32]\n  }\np384_ec_twin_mul_aux2 (c0, c1, e0, e1, sh, d0i, d1i, dv1, dv2) =\n  { tma2_u0  = u0\n  , tma2_u1  = u1\n  , tma2_c0' = c0'\n  , tma2_c1' = c1'\n  , tma2_e0' = e0'\n  , tma2_e1' = e1'\n  , tma2_sh' = sh'\n  }\n  where\n    c0'           = ((if h0Less then 0 else `0x20) ^ (c0 << 1)) || ((e0 >> (sh && 31)) && `0x1)\n    c1'           = ((if h1Less then 0 else `0x20) ^ (c1 << 1)) || ((e1 >> (sh && 31)) && `0x1)\n    u0            = if h0Less then 0 else (if (c0 && `0x20) != 0 then (-1) else 1)\n    u1            = if h1Less then 0 else (if (c1 && `0x20) != 0 then (-1) else 1)\n\n    h0            = if (c0 && `0x20) != 0 then 31 - h0' else h0'\n      where h0' = c0 && `0x1F\n\n    h1            = if (c1 && `0x20) != 0 then 31 - h1' else h1'\n      where h1' = c1 && `0x1F\n\n    h0Less        = h0 < F(h1)\n    h1Less        = h1 < F(h0)\n    (e0',e1',sh') = if dv1 then\n                      if dv2 then (d0i, d1i, 31) else (0, 0, 31)\n                    else (e0, e1, sh-1)\n\n\/\/ F : [5] -> [5] via original impl\n\/\/ F : [32] -> [32] via fused impl\np384_ec_twin_mul_aux_F32 : [32] -> [32]\np384_ec_twin_mul_aux_F32 = F\n\n\/* Matches Java implementation *\/\np384_ec_twin_mul : ([384],AffinePoint[384], [384], AffinePoint [384]) -> JacobianPoint [384]\np384_ec_twin_mul(d0, s, d1, t) =\n  if s.x == t.x then i.r else jj_r\n  where\n   m     = p384_point_ops\n   f     = m.field\n   g     = m.group_field\n   i     = p384_ec_twin_mul_init(d0, s, d1, t)\n   d0'   = toJavaArray d0\n   d1'   = toJavaArray d1\n   d0_11 = d0'!0\n   d1_11 = d1'!0\n   (jj_r, _, _, _, _, _) = jj!0\n   jj : [386](JacobianPoint [384], _,_,_,_,_)\n   jj    = [ ( i.r             \/\/ initial point\n             , d0_11 >> 28     \/\/ c0 initial value\n             , d1_11 >> 28     \/\/ c1 initial value\n             , d0_11           \/\/ e0 initial value\n             , d1_11           \/\/ e1 initial value\n             , 27:[32]         \/\/ shift initial value\n             )\n           ]\n         # [ (r', c0', c1', e0', e1', sh')\n             where\n                k = (k0-5):[32]\n                r'         = p384_ec_twin_mul_aux1(r, u0, u1, i.sPt, s, i.sMt, t)\n                aux2       = p384_ec_twin_mul_aux2(c0, c1, e0, e1, sh, d0i, d1i, dv1, dv2)\n                (u0, u1)   = (aux2.tma2_u0, aux2.tma2_u1)\n                (c0', c1') = (aux2.tma2_c0', aux2.tma2_c1')\n                (e0', e1') = (aux2.tma2_e0', aux2.tma2_e1')\n                sh'        = aux2.tma2_sh'\n                (d0i, d1i,\n                 dv1, dv2) = if dv1i && dv2i then\n                               (d0'@ii, d1'@ii, dv1i, dv2i)\n                             else\n                               (zero, zero, dv1i, dv2i)\n                             where\n                               ii    = (k >> 5) - 1\n                               dv1i  = (k && `0x1F) == 0\n                               dv2i  = ~(ii@0)\n           | (r, c0, c1, e0, e1, sh) <- jj\n           | k0 <- reverse [0 .. 384]\n           ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/PrimeField\/PFEC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::EC::PrimeField::PFEC that contains the following definitions: import the modular-division utilities from Common::ModDivZ; a numeric type parameter P with constraints that it is finite and at least 5; value parameters including an Integer n and field elements b, Gx, and Gy of type Z P. Define a type alias Point as a pair of field elements over Z P. Provide constants: a base point built from Gx and Gy; a curve coefficient equal to \u22123 in Z P; an Integer constant equal to the modulus derived from P; and an identity point representing the point at infinity. Define type signatures and implementations for: (1) a total function that returns a Bit indicating whether a point is either the identity or lies on the short Weierstrass curve y^2 = x^3 + a\u00b7x + b over Z P; (2) a total function for affine elliptic-curve point addition over Z P handling special cases (identity operands and additive inverses), computing the slope via modular division as either the tangent formula for doubling or the chord formula for distinct points, and producing the resulting coordinates via the usual formulas; (3) a total function for scalar multiplication by recursive double-and-add with base cases for 0 and 1, using halving-and-doubling for even scalars and decrement-and-add for odd scalars; and an infix operator alias equivalent to this scalar multiplication function. Also include: define a property that asserts that adding one to the scalar parameter and multiplying the base point yields the base point; define a property that asserts that scalar-multiplying the base point by any Integer produces a valid curve point; define a property that asserts that nested scalar multiplications on the base point commute with respect to the two scalars. Ensure all arithmetic is over Z P and all definitions have appropriate types."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::PFEC where\n\nimport Common::ModDivZ\n\nparameter\n    type P : #         type constraint (fin P, P >= 5)\n    n  : Integer       b  : Z P           Gx : Z P           Gy : Z P       \ntype Point = (Z P, Z P)\nG = (Gx, Gy) : Point\na = -3 : Z P       p = toInteger`{width P} `P\n\noo = (0, 0) : Point\n\nvalid_point : Point -> Bit\nvalid_point (x, y) =\n    ((x, y) == oo) \\\/ (y ^^ 2 == x ^^ 3 + a * x + b)\n\nec_add : Point -> Point -> Point\nec_add (x1, y1) (x2, y2) =\n    if (x1, y1) ==    oo     then  (x2, y2)       | (x2, y2) ==    oo     then  (x1, y1)       | (x1, y1) == (x2, -y1) then     oo                                  else   (x, y)       where      x = L ^^ 2 - x1 - x2\n    y = L * (x1 - x) - y1\n    L = if x1 == x2 then (3 * x1 ^^ 2 + a) %\/ (2 * y1)\n                    else (y2 - y1) %\/ (x2 - x1)\n\nscmul : Integer -> Point -> Point\nscmul m xy =\n    if m == 0 then oo\n     | m == 1 then xy\n     | even m then scmul (m \/ 2) (ec_add xy xy)\n              else ec_add xy (scmul (m - 1) xy)\n\n(~*) = scmul  \nproperty valid_n = (n + 1) ~* G == G\nproperty valid_scmul m = valid_point (m ~* G)\nproperty scmul_commutes m m' = m ~* (m' ~* G) == m' ~* (m ~* G)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/gf.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named GF that imports an existing Types module and contains the following definitions with explicit type signatures and implementations:\n- A function returning a mask indicating whether a base field element is zero, using widening to a larger unsigned width, arithmetic and shifting to form the mask, then narrowing back to the base width.\n- An addition function on base field elements that performs bitwise XOR.\n- A finite-field multiplication on field elements represented in a fixed base width, using a 64-bit accumulator to build the carryless polynomial product across the bit-length of the multiplier, then reducing modulo the field polynomial and finally masking by the field mask.\n- A top-level reduction helper that takes an index, a 64-bit accumulator, a loop bound, and an array of 64-bit masks, and iteratively folds the accumulator by XORing selected right-shifts gated by those masks, returning a field element.\n- A function computing (a squared) times b using precomputed 64-bit masks and shifts, finalized by the reduction helper.\n- A function computing (a squared twice) times b using a larger set of masks and shifts, finalized by the reduction helper.\n- A function computing squaring twice of a single input by bit spreading via fixed 64-bit mask patterns, then reduction via the helper.\n- A function computing n divided by d in the field via an addition chain of squarings and squaring-times-multiply steps that yields d^(\u22121) and multiplies by n.\n- A function returning the multiplicative inverse by calling the division function with numerator one.\nUse the Types module for base_t, gf_t, uint32\/64 types, conversion functions, the field bit-size, and the reduction mask. Also include properties: that addition equals XOR on base elements; that for nonzero inputs d, inv(d) multiplied by d equals one; and that for nonzero d, frac(d,n) equals mul(n, inv(d))."},{"role":"assistant","content":"```cryptol\nmodule GF where\n\nimport Types\n\ngf_iszero : base_t  -> base_t\ngf_iszero a = t_3 where\n    (t_1 : uint32t ) = cvt_16_to_32 a\n    (t_2 : uint32t ) = (t_1-1)>> 19\n    (t_3 : base_t) = cvt_32_to_16 t_2\n\ngf_add : base_t -> base_t -> base_t\ngf_add a b = a^b\n\ngf_mul : gf_t  -> gf_t  -> gf_t\ngf_mul a b = rtn  where\n    (t0:base_64t) = cvt_16_to_64 a\n    (t1:base_64t) = cvt_16_to_64 b\n    loop_i i tmp =\n        if (i>= GFBITS) then tmp\n        else loop_i (i+1) tmp' where\n            tmp' = t0 * (t1 && (1 << i))\n    (tmp_0 : base_64t) = t0 * (t1 && 1)\n    (tmp_1 : base_64t) = loop_i 0 tmp_0\n        (k_0: base_64t) =  cvt_20_to_64 0x1FF0000\n    (k_1: base_64t) =  cvt_20_to_64 0x000E000\n    (t_0: base_64t) = tmp_1 && k_0\n    (t_1: base_64t) = tmp_2 && k_1\n    (tmp_2 : base_64t) = tmp_1 ^ ((t_0 >> 9) ^ (t_0 >> 10) ^ (t_0 >> 12) ^ (t_0 >> 13))\n    (tmp_3 : base_64t) = tmp_2 ^ ((t_1 >> 9) ^ (t_1 >> 10) ^ (t_1 >> 12) ^ (t_1 >> 13))\n    (rtn : gf_t ) = cvt_64_to_16 (tmp_3 && GFMASK)\n\nloop_i i x limit M =\n    if(i<limit) then loop_i i' x' limit M where\n        t = x && (M@i)\n        x'= x^ (t >> 9) ^ (t >> 10) ^ (t >> 12) ^ (t >> 13)\n        i' = i+1\n    else  cvt_64_to_16 (x&& GFMASK)\n\ngf_sqmul : gf_t -> gf_t -> gf_t\ngf_sqmul a b = rtn where\n    M = [0x0000001FF0000000, 0x000000000FF80000, 0x000000000007E000]\n    (t0:uint64t) = cvt_16_to_64  a\n    (t1:uint64t) = cvt_16_to_64  b\n    (x1:uint64t) = (t1 << 6) * (t0 && (1 << 6))\n    (t2:uint64t) = t0^(t0 << 7)\n    (x2:uint64t) = x1^ (t1 * (t2 && (cvt_20_to_64 0x04001)))\n    (x3:uint64t) = x2^ (t1 * (t2 && (cvt_20_to_64 0x08002))) << 1\n    (x4:uint64t) = x3^ (t1 * (t2 && (cvt_20_to_64 0x10004))) << 2\n    (x5:uint64t) = x4^ (t1 * (t2 && (cvt_20_to_64 0x20008))) << 3\n    (x6:uint64t) = x5^ (t1 * (t2 && (cvt_20_to_64 0x40010))) << 4\n    (x7:uint64t) = x6^ (t1 * (t2 && (cvt_20_to_64 0x80020))) << 5\n    rtn = loop_i 0 x7 3 M\n\ngf_sq2mul : gf_t -> gf_t -> gf_t\ngf_sq2mul a b = rtn where\n    (M:[6][64]) = [0x1FF0000000000000,\n        0x000FF80000000000,\n        0x000007FC00000000,\n        0x00000003FE000000,\n        0x0000000001FE0000,\n        0x000000000001E000]\n    (t0:uint64t) = cvt_16_to_64 a\n    (t1:uint64t) = cvt_16_to_64 b\n    (x_1:uint64t) = (t1 << 18) * (t0 && (1 << 6))\n    t2 = t0^(t0 << 21)\n    (x_2:uint64t) = x_1^(t1 * (t0 && (cvt_36_to_64 0x010000001)))\n    (x_3:uint64t) = x_2^(t1 * (t0 && (cvt_36_to_64 0x020000002))) << 3\n    (x_4:uint64t) = x_3^(t1 * (t0 && (cvt_36_to_64 0x040000004))) << 6\n    (x_5:uint64t) = x_4^(t1 * (t0 && (cvt_36_to_64 0x080000008))) << 9\n    (x_6:uint64t) = x_5^(t1 * (t0 && (cvt_36_to_64 0x100000010))) << 12\n    (x_7:uint64t) = x_6^(t1 * (t0 && (cvt_36_to_64 0x200000020))) << 15\n    rtn = loop_i 0 x_7 6 M\n\ngf_sq2 : gf_t -> gf_t\ngf_sq2 in = rtn where\n    (B:[4][64]) = [0x1111111111111111,\n        0x0303030303030303,\n        0x000F000F000F000F,\n        0x000000FF000000FF]\n    (M:[4][64]) = [0x0001FF0000000000,\n        0x000000FF80000000,\n        0x000000007FC00000,\n        0x00000000003FE000]\n    (x_1:uint64t) = cvt_16_to_64 in\n    (x_2:uint64t) = (x_1 || (x_1 << 24)) && (B@3)\n    (x_3:uint64t) = (x_2 || (x_2 << 12)) && (B@2)\n    (x_4:uint64t) = (x_3 || (x_3 << 6)) && (B@1)\n    (x_5:uint64t) = (x_4 || (x_3 << 3)) && (B@0)\n    rtn = loop_i 0 x_5 4 M\n\ngf_frac : gf_t -> gf_t -> gf_t\ngf_frac d n = t7 where\n    t1 = gf_sqmul d d\n    t2 = gf_sq2mul t1 t1\n    t3 = gf_sq2 t2\n    t4 = gf_sq2mul t3 t2\n    t5 = gf_sq2 t4\n    t6 = gf_sq2mul t5 t2\n    t7 = gf_sqmul t7 n\n\ngf_inv : gf_t -> gf_t\ngf_inv d = gf_frac d 1\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/operations.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Operations that contains the following definitions: compute_hash_2e, compute_hash_1e, crypto_hash_32b_1, crypto_hash_32b_2, two_e, crypto_kem_enc, and crypto_kem_dec. Import the Types, Encrypt, and Decrypt modules and use their types and constants. Specify types in plain language: compute_hash_2e and crypto_hash_32b_1 each take a length-(N8+1) system vector and return a 32-element sequence of the base element type; compute_hash_1e takes a preimage message vector and returns a 32-element base sequence; crypto_hash_32b_2 takes a preimage message vector and returns a key; crypto_kem_enc takes a ciphertext buffer, a key, a public key, and a length-(N8+2) error vector, returning a pair of ciphertext and key; crypto_kem_dec takes a ciphertext and secret key and returns a key. Define the constant two_e as a length-(N8+1) vector filled with the element value 2. Specify crypto_kem_enc to: zero the error vector; call the encrypt function; form the output ciphertext by concatenating the first 194 elements of the encrypt output with a 32-element hash of two_e; build a preimage by concatenating a single element equal to 1, the first 870 elements of the error vector, and the ciphertext; derive the output key by hashing this preimage. Specify crypto_kem_dec to: decrypt to obtain an error vector and a decryption flag; compute a 32-element hash of two_e; confirm integrity by iterating 32 positions and OR-accumulating XOR differences between the hash and the ciphertext starting at the syndrome-length offset; create a mask from the confirmation and decryption flag and, in constant time, select between secret-key elements and decrypted error elements across 870 positions; build a preimage from a single selected bit, the 870 selected elements, and the first (194+32) ciphertext elements; hash this preimage to produce the returned key. Ensure all concatenations, slices, and indices are length-safe and match the declared types."},{"role":"assistant","content":"```cryptol\nmodule Operations where\n\nimport Types\nimport Encrypt\nimport Decrypt\n\ncompute_hash_2e : SYS_N8_plus1_t -> [32]base_t\ncompute_hash_2e in = undefined\ncompute_hash_1e : pm_t -> [32]base_t\ncompute_hash_1e in = undefined\n\ncrypto_hash_32b_1 : SYS_N8_plus1_t -> [32]base_t\ncrypto_hash_32b_1 in = undefined\n\ncrypto_hash_32b_2 : pm_t -> g_key_t\ncrypto_hash_32b_2 in = undefined\n\n(two_e : SYS_N8_plus1_t) = [ 2 | x <- [0..870]]\n\ncrypto_kem_enc : g_ct_t -> g_key_t -> g_pk_t -> SYS_N8_plus2_t\n    -> (g_ct_t, g_key_t)\ncrypto_kem_enc c0 key pk e =  (c2, key2) where\n        (e :  SYS_N8_plus2_t) = zero\n        (c1 : g_ct_t) = encrypt c0 pk e\n        (c2 : g_ct_t) = (take `{194} c1 ) # (compute_hash_2e two_e)\n    (one_ec : pm_t) = ([1])#(take `{870} e)#c2\n    (key2 : g_key_t) = compute_hash_1e one_ec\n\ncrypto_kem_dec : g_ct_t -> g_sk_t -> g_key_t\ncrypto_kem_dec c sk = key where\n        (e : SYS_N8_t, ret_decrypt : gf_t) = decrypt sk c\n        (conf : [32]base_t) = crypto_hash_32b_1 two_e\n    loop_i i rc =\n        if (i<32)\n        then loop_i i' rc' where\n            i' = i+1\n            rc' = rc || ((conf@i) ^ c@(SYND_BYTES + i))\n        else rc\n    (ret_confirm : base_16t) = loop_i 0 0\n    (m_0 : base_16t) = ret_decrypt || ret_confirm\n    (m_1 : base_16t) = m_0 - 1\n    (m : base_16t) = m_1 >> 8\n    x_1 = [(~m && 0) || (m && 1)]\n    x_2 = [(~m && (sk@i)) || (m && (e@i)) | i <- [0..(870-1)]]\n    x_3 = [(c@i) | i <- [0..(194-1+32)]]\n    (preimage: pm_t) = x_1 # x_2 # x_3\n        (key : g_key_t) = crypto_hash_32b_2 preimage\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/benes.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Benes that imports the required type and utility modules and contains the following definitions: (1) Type synonyms: La_t is a 32-bit word; Lb_t is a vector of j_size_t elements of 32-bit words; Lc_t is a vector of GFBITS_t elements, each an Lb_t. (2) A function apply_benes with type Lb_t -> g_sk_t -> Bit -> Lb_t that, for this specification, returns an all-zero Lb_t regardless of inputs. (3) A function support_gen with type g_sk_t -> L_t implementing this algorithm: compute k_size as 1 shifted left by GFBITS (in 32-bit space); initialize an Lc_t accumulator to zeros; for ix from 0 to k_size-1, obtain the bit-reversed form of ix (use only the reversed value), and for each jx from 0 to GFBITS-1 update layer jx at index kx = floor(ix\/8) by OR-ing a single-bit mask d, where d is the jx-th bit of the reversed value shifted left by c = ix mod 8; after building the accumulator, map apply_benes across all GFBITS_t layers with reverse flag false to produce an Lc_t; initialize the output s as zeros of type L_t, then for ix from 0 to SYS_N-1 fold jx from GFBITS-1 down to 0, repeatedly setting s[ix] = (s[ix] << 1) OR convert(extracted_bit) where extracted_bit is the least-significant bit of the selected 32-bit word from the current layer; return s. (4) Define properties: property apply_benes_zero asserting that for all inputs, apply_benes returns an all-zero Lb_t; property support_gen_zero asserting that for all keys, support_gen returns the all-zero L_t (consistent with the zero apply_benes). Provide precise type signatures for all names and ensure size\/index constraints align with GFBITS, SYS_N, j_size_t, GFBITS_t, and base_t."},{"role":"assistant","content":"```cryptol\nmodule Benes where\n\nimport Types\nimport GF\nimport Util\n\ntype La_t = [32]\ntype Lb_t = [j_size_t][32]\ntype Lc_t = [GFBITS_t][j_size_t][32]\n\napply_benes r bits rev = zero\n\nsupport_gen : g_sk_t  -> L_t\nsupport_gen c  = s where\n    k_size = (1:La_t) << GFBITS\n    loop_i : La_t -> Lc_t -> Lc_t\n    loop_i ix L =\n        if(ix<k_size)\n        then  loop_i ix' L' where\n            (_, a) = bitrev ix\n            loop_j : La_t -> Lc_t -> Lc_t\n            loop_j jx M =\n                if (jx < GFBITS)\n                then loop_j jx' M' where\n                    (kx:La_t) = ix\/8\n                    (val_jx:Lb_t) = M@jx\n                    (val_kx:La_t) = val_jx@kx\n                    (c:La_t) = (ix%8:La_t)\n                    (d:La_t)  = (((a >> jx) && (1:La_t)) << c)\n                    (val_0:La_t) =  val_kx || d\n                    (val_1:Lb_t) = (update val_jx kx val_0)\n                    (M':Lc_t) = update M jx val_1\n                    (jx':La_t) = jx+1\n                else M\n            L' = loop_j 0 L\n            ix' = ix+1\n        else L\n    (L_0:Lc_t) = zero\n    (L_1:Lc_t) = loop_i 0 L_0\n    (L_2:Lc_t) =[(apply_benes l c 0) | l <- L_1]\n    loop_ix : La_t -> L_t -> L_t\n    loop_ix ix s =\n        if (ix<SYS_N)\n        then loop_ix (ix+1) s_2  where\n            loop_jx : La_t -> L_t -> L_t\n            loop_jx jx s =\n                if(jx>=0)\n                then loop_jx jx' s' where\n                    (x : La_t) = (L_2@jx)@(ix\/8)\n                    (y : La_t) = (x >> (ix%8)) && 1\n                    (z : base_t) = (s@ix << (1:base_t)) || ( cvt_32_to_16 y)\n                    (jx': La_t) = jx-1\n                    s' = update s ix z\n                else s\n\n                        s_1 = update s ix 0\n            s_2 = loop_jx (GFBITS-1) s_1\n        else s\n    (s:L_t) = loop_ix 0 zero\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/decrypt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Decrypt that imports Benes, Types, Decrypt_helpers, GF, and Util, and contains a total function decrypt with type g_sk_t -> g_ct_t -> (f_t, gf_t). Specify that decrypt takes a secret key and ciphertext and returns an error vector and a success flag, implementing Niederreiter decryption as follows: (1) Extract an r_t value from the ciphertext. (2) Build a g_t structure by iterating SYS_T steps: at each step load a gf_t element from the secret key (two-byte stride), mask it to the field domain, and place it at the current position. (3) Compute the support L_t from the secret key. (4) Compute an initial syndrome s_t from g_t, L_t, and r_t. (5) Run Berlekamp\u2013Massey on the syndrome to produce a locator (g_t). (6) Evaluate the locator on the support to obtain images over SYS_N positions. (7) Construct the error vector f_t by scanning all positions i in [0 .. SYS_N-1]: set bit i in f_t iff the corresponding image equals zero in gf_t; maintain a running weight counter as a gf_t sum. Bits are packed into bytes by byte index i\/8 and bit index i%8. (8) Recompute the syndrome from the constructed error vector. (9) Reduce the XOR of the two syndromes across 2*SYS_T positions with a bitwise OR fold into a single accumulator. (10) Compute the final gf_t success flag by combining the weight check against SYS_T with the syndrome-accumulator nonzero test using constant-time bitwise\/arithmetic operations so that the flag is 1 on success and 0 otherwise. Provide explicit type annotations for all intermediates (r_t, g_t, L_t, s_t, SYS_N_t, gf_t, f_t) and ensure loops are total and index-safe."},{"role":"assistant","content":"```cryptol\nmodule Decrypt where\n\nimport Benes\nimport Types\nimport Decrypt_helpers\nimport GF\nimport Util\n\ndecrypt : g_sk_t -> g_ct_t -> (f_t, gf_t)\ndecrypt sk c = (e, check) where\n    (r : r_t) = (take `{194} c)#zero\n    loop_1 g i sk_index =\n        if i < SYS_T\n        then loop_1 g' (i+1) (sk_index+2) where\n            (a : gf_t)= load2 sk sk_index\n            (b : gf_t) = a && GFMASK\n            g'= update g i b\n        else g\n    (g_0 : g_t) = zero\n    (g_1 : g_t) = loop_1 g_0 0 0\n    (L : L_t) = support_gen sk\n    (s : s_t) = synd g_1 L r\n    (locator : g_t) = bm s\n    (images : SYS_N_t) = root locator L\n    loop_2 : [32] -> f_t -> gf_t -> (f_t, gf_t)\n    loop_2 i e w =\n        if (i<SYS_N)\n        then loop_2 (i+1) e' w' where\n            (t : gf_t) = (gf_iszero (images @i)) && (1:[16])\n            jx = i\/8\n            val = (e@jx) || t << (i%8)\n            (e' : f_t) = update e jx val\n            (w' : gf_t) = w+t\n        else (e, w)\n    (e : f_t, w : gf_t) = loop_2 0 zero 0\n    (s_cmp : s_t) = synd g_1 L e\n    loop_3 i check =\n        if (i<SYS_T*2)\n        then  loop_3 (i+1) check' where\n            check' = check || ((s@i) ^ (s_cmp@i))\n        else check\n    (check_0 : gf_t) = w ^ SYS_T\n    (check_1 : gf_t) = loop_3 0 check_0\n    (check_2 : gf_t) = (check_1 -1)>> 15\n    (check : gf_t) = check_2 ^ 1\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/decrypt_helpers.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Decrypt_helpers that imports the existing type aliases and field operations from Types, GF, and Util, and contains the following definitions with explicit type signatures and behaviors:\n- eval : takes a polynomial over the field (coefficients vector sized to the system\u2019s error-correcting capability) and a field element, and returns the polynomial\u2019s value at that element. Implement Horner evaluation using the field\u2019s add and multiply, iterating from highest to lowest coefficient.\n- root : maps the above evaluator over a support vector of field elements whose length matches the system code length, returning the vector of evaluations.\n- synd : computes the syndrome vector from a polynomial, a support vector, and a binary error pattern. Iterate over all code positions; for each position, extract the corresponding bit from the error pattern, evaluate the polynomial at the support element, form the inverse of its square in the field, and accumulate contributions across all syndrome components by repeatedly multiplying by the support element. Sizes must respect the system parameters for code length and twice the error-correcting capability.\n- bm : implements the constant-time Berlekamp\u2013Massey algorithm over the field to recover the error-locator polynomial from the syndrome vector. Initialize the connection polynomial, auxiliary polynomial, discrepancy scalar, current length, and counters per standard BM. For each step up to twice the error-correcting capability, compute the discrepancy from the current connection polynomial and syndrome, derive constant-time masks to conditionally update polynomials and length, perform a fractional field multiply to scale updates, shift the auxiliary polynomial, and finally return the locator polynomial in the expected coefficient order. Use the provided field operations (add, multiply, inverse, fractional multiply) and system-sized vectors."},{"role":"assistant","content":"```cryptol\nmodule Decrypt_helpers where\n\nimport Types\nimport GF\nimport Util\n\neval f a = out where\n    loop_i i r =\n        if (i<0) then r\n        else loop_i i' r' where\n            r' = gf_add (gf_mul r a) (f@i)\n            i' = i-1\n    r_init = f@SYS_T\n    i_init = SYS_T-1\n    out = loop_i i_init r_init\n\nroot : g_t ->  SYS_N_t -> SYS_N_t\nroot f L = out where\n    out = [ eval f l | l <- L]\n\nsynd : g_t -> L_t -> r_t -> s_t\nsynd f L r = out' where\n    loop_j i j out e_inv c =\n        if (j<SYS_T_double)\n        then (loop_j i j' out' e_inv' c) where\n            j' = j+1\n            x = gf_mul e_inv c\n            y = gf_add (out@j) x\n            out' = update out j y\n            e_inv' = gf_mul e_inv (L@i)\n        else (out, e_inv)\n\n    loop_i i out e_inv c =\n        if (i<SYS_N)\n        then loop_i i' out' e_inv' c where\n            c = (r@(i\/8) >> (i%8)) && (1:[16])\n            e = eval f (L@i)\n            e_inv = gf_inv (gf_mul e e)\n            (out', e_inv') = loop_j i 0 out e_inv c\n            i' = i+1\n        else out\n    out' = loop_i 0 zero 0 0\n\nbm : s_t-> g_t\nbm s = out where\n    N_limit =  2 * SYS_T\n    outer_loop N B C T L b =\n        if (N<N_limit) then (outer_loop N_2 B_3 C_2 T_2 L_2 b_2) where\n            (d_0 : gf_t) = zero\n            limit = min N SYS_T\n            loop_1 i d  =\n                if(i < limit)\n                then loop_1 i' d' where\n                    d' = d ^ (gf_mul (C@i) (s@(N-i)))\n                    i' = i+1\n                else d\n            (d_1 : gf_t) = loop_1 0 d_0\n            (mne: uint16t) = ((d_1 - (1:[16]))>> 15) - (1:[16])\n            (mle_0: uint16t)= ((N - (2:[16])*L) >> 15) - (1:[16])\n            (mle_1: uint16t) = mle_0 && mne\n            (T_2 : SYS_T_plus1) = C\n            (f: gf_t) = gf_frac b d_1\n            (C_2: SYS_T_plus1) =\n                [c ^ ((gf_mul f (B@i)) && mne)\n                | i <- [0.. 120]\n                | c <- C]\n            (L_2: uint16t) = (L && ~mle_1) || ((N+1-L) && mle_1)\n            (B_2: SYS_T_plus1) =\n                [((b && ~mle_1) || (t && mle_1)) | b <- B | t <- T]\n            b_2 = (b && ~mle_1) || (d_1 && mle_1)\n            (B_3: SYS_T_plus1) = zero # (take `{119} B_2)\n            N_2 = N+1\n        else C\n    (N : uint16t) = 0\n    (L : uint16t) = 0\n    (B_0 : SYS_T_plus1) = zero\n    (B_1 : SYS_T_plus1) = update B_0 1 1\n    (C_0 : SYS_T_plus1) = zero\n    (C_1 : SYS_T_plus1) = update C_0 0 1\n    (T : SYS_T_plus1) = zero\n    (b : gf_t) = 1\n    (C_2 : SYS_T_plus1)= outer_loop N B_1 C_1 T L b\n    out = reverse C_2\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/types.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains the following definitions: list_definitions. Inside, declare compile-time constants for core system parameters (e.g., code dimension, length, element bit-width) and all derived sizes for byte counts, matrix dimensions, row-byte sizes, key sizes, and syndrome sizes. Provide type synonyms for several fixed-width word types, a base element type chosen from these widths, and a finite-field element type equal to the base. Define sized sequence type aliases for buffers representing ciphertext, key bytes, public keys, secret keys, and other internal arrays; include variants sized by the system length divided by a byte width and its plus-one\/plus-two offsets, as well as sequences sized by the system length, twice the error-correcting capability, and plus-one forms needed by algorithms. Add helper functions that convert values between all defined fixed-width word types by round-tripping through integer conversion (to integer then from integer). Include both widening and narrowing variants between each pair, mappings from custom narrower widths to the largest width, and identity-like casts where source and destination widths are the same. Give each function an explicit type signature reflecting its source and destination word widths. Ensure all sequence types carry explicit lengths using Cryptol\u2019s sequence notation, and every derived constant and type synonym is expressed in terms of previously defined parameters rather than hard-coded literals."},{"role":"assistant","content":"```cryptol\nmodule Types where\n\nSYS_T = 119\nSYS_N = 6960\nSYS_Nd8 = SYS_N\/8 \nGFBITS =  13\ntype GFBITS_t =  13\nCOND_BYTES  = (((1:[32]) << (GFBITS-(4:[32])))*(2*GFBITS - (1:[32])))\nIRR_BYTES = (SYS_T * 2)\nPK_NROWS  =  (SYS_T*GFBITS)\nPK_NCOLS  =  (SYS_N - PK_NROWS)\nPK_ROW_BYTES  =  ((PK_NCOLS + 7)\/8)\ntype PK_ROW_BYTES_t = [677]\nSK_BYTES  =  (SYS_Nd8 + IRR_BYTES + COND_BYTES)\nSYND_BYTES  =  ((PK_NROWS + 7)\/8)\ntype SYND_BYTES_t = [194]\nGFMASK  =  (((1:[32]) << GFBITS) - 1)\ntype j_size_t =  1024 \n\ntype base_16t = [16]\ntype base_32t = [32]\ntype base_64t = [64]\ntype uint16t = [16]\ntype uint64t = [64]\ntype uint32t = [32]\ntype base_t = base_16t\ntype gf_t = base_t\n\ntype ciphertext_t = [226] base_t    type keybytes_t = [32] base_t type publickey_t = [1047319]base_t type secretkey_t = [13908] base_t \ntype g_s_t =   ciphertext_t\ntype g_ct_t =  ciphertext_t\ntype g_key_t = keybytes_t\ntype g_pk_t =  publickey_t\ntype g_sk_t = secretkey_t\n\ntype SYS_N8_t = [870] base_t\ntype SYS_N8_plus1_t = [871] base_t\ntype SYS_N8_plus2_t = [872]base_t\n\nSYS_T_double = 238type SYS_T_double_t = [238]base_t\ntype SYS_N_t = [6960]base_t\ntype SYS_T_plus1 = [120]base_t\n\ntype L_t = SYS_N_t type f_t = SYS_N8_t\ntype r_t = SYS_N8_t\ntype g_t = SYS_T_plus1\ntype s_t = SYS_T_double_t \ntype e_t = SYS_N8_plus2_t\ntype ind_t = SYS_T_double_t\ntype e_int_t = [109]base_t\ntype val_t = [119] base_t\ntype e_pieces_t = [109][8]base_t\n\ntype pm_t =  [1097]base_t \n\ncvt_16 e = fromInteger `{[16]} (toInteger e)\ncvt_32 e = fromInteger `{[32]} (toInteger e)\ncvt_64 e = fromInteger `{[64]} (toInteger e)\ncvt_32_to_16 e = cvt_16 e\ncvt_64_to_16 e = cvt_16 e\ncvt_16_to_32 e = cvt_32 e\ncvt_20_to_64 e = cvt_64 e\ncvt_16_to_64 e = cvt_64 e\ncvt_36_to_64 e = cvt_64 e\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/encrypt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Encrypt that contains the following definitions: mov_forward, loop_x, loop_findEq, while_loop, loop_a, loop_c, loop_d, loop_e, gen_e, syndrome, and encrypt. Provide precise type signatures for each using the aliases and size parameters from the imported type utilities (word type, index vector type, value vector, intermediate block array, grouped-bytes array, error vector, public key, syndrome, and constants such as system sizes and row counts). Constrain indices, shifts, and loop bounds so all accesses are within range and all bit widths are valid. Implement behaviors as follows: mov_forward scans a bounded region of the index vector for a qualifying element, swaps it with the current position, and returns the updated vector with a found-flag. loop_x masks each of the first double-sized index entries by the field mask. loop_findEq returns true iff there exist two distinct positions among the first sized subset with equal values. while_loop repeatedly applies the masking step and recurs until the equality predicate signals the stop condition, returning the current index vector. loop_a produces one-hot words from the low six bits of each selected index element. loop_c builds packed blocks by OR-accumulating those one-hot words into the block selected by the high bits. loop_d serializes blocks into groups of eight bytes and concatenates them. loop_e finalizes the trailing partial block by writing only the remainder bits as bytes. gen_e composes the above pipeline to produce the error vector from an input buffer. syndrome aligns each key row by the row-count remainder, computes the parity of the bytewise AND of the row with the error vector, and sets the corresponding bit in the output, starting from the provided initial value. encrypt computes the syndrome of the generated error vector with the given key and initial syndrome. Also define properties to check: masking equals a map-spec, equality detection matches an existential duplicate predicate, loop fixpoint stability, one-hot encoding correctness, block accumulation equals a reference fold, serialization round-trip, remainder handling, pipeline equivalence, syndrome parity per row, and encrypt equals syndrome(key, gen_e(e), s)."},{"role":"assistant","content":"```cryptol\nmodule Encrypt where\n\nimport Types\nimport Util\n\nmov_forward : ind_t -> (ind_t, Bool)\nmov_forward ind_0 = outer_loop 0 ind_0 False where\n    inner_loop : _ -> _ -> ind_t -> Bool -> (ind_t, Bool)\n    inner_loop j i ind found =\n        if (j < (SYS_T* 2))\n        then if(jval<SYS_N)\n            then inner_loop (j+1) i ind' found'\n            else inner_loop (j+1) i ind found\n        else (ind, found)\n        where\n            (jval : base_t) = ind@j\n            (ind' : ind_t) = update (update ind j (ind@i)) i jval\n            found' = True\n    outer_loop : _ -> ind_t -> Bool -> (ind_t, Bool)\n    outer_loop i ind found =\n        if (i < SYS_T)\n        then if(found')\n            then outer_loop (i+1) ind' found'\n            else (ind', found')\n            where\n                (ind', found') = inner_loop i i ind found\n        else (ind, found)\n\n\/\/ --------------------------------------------- while for loops\nloop_x i ind = if (i<SYS_T*2) then loop_x (i+1) ind' else ind\n    where\n    ind' = update ind i ((ind@i) && GFMASK)\n\n\/\/ when find equal value returns true\nloop_findEq : ind_t  -> _ -> Bool -> Bool\nloop_findEq ind i rtn = if (i<SYS_T) then rtn' else rtn\n    where\n        loop_z : ind_t -> _ -> _ -> Bool\n        loop_z ind i j =\n            if(j<i)\n            then\n                if((ind@i) == (ind@j))\n                then True\n                else loop_z ind i (j+1)\n            else False\n        rtn' = if(loop_z ind i 0)\n            then True\n            else loop_findEq ind (i+1) rtn\n\n\/\/ While_loop : Might consider adding a limit to the counter here\nwhile_loop : ind_t -> ind_t\nwhile_loop ind =\n    if(loop_findEq ind_2 1 False) then ind_2 else while_loop ind_2\n    where ind_2 = loop_x 0 ind\n\n\/\/ --------------------------------------------- gen_e for loops\n\/\/ implements val[j] = one << (ind[j] & 63)\nloop_a : base_t -> val_t ->ind_t -> val_t\nloop_a j val ind =\n    if (j<SYS_T) then loop_a (j+1) val' ind else val\n    where\n        x = 1 << ((ind@j) && 63)\n        val' = update val j x\n\n\/\/nested for loop\nloop_c : base_t ->  val_t -> ind_t -> e_int_t -> e_int_t\nloop_c i val ind e_int  =\n    if(i < (SYS_N+63)\/64) then e_int' else e_int\n    where\n    (e_int' : e_int_t) = loop_b 0 i val ind e_int\n    loop_b : base_t -> base_t -> val_t -> ind_t -> e_int_t -> e_int_t\n    loop_b j i val ind e_int =\n        if (j<SYS_T) then loop_b (j+1) i val ind e_int' else e_int\n        where\n            (mask_0 : base_t) =cvt_16 (ind@j)\n            (mask_1 : base_t) = i^(mask_0 >> 6)\n            (mask_2 : base_t) = mask_1-1\n            (mask_3 : base_t) = mask_2 >> 63\n            (mask : base_t) = -1* mask_2\n            (m : base_t) = e_int@i\n            (n : base_t) = (val@j) && mask\n            (o : base_t) = m ||  n\n            (e_int' : e_int_t) = update e_int i o\n\n\/\/ store in groups of 8\nloop_d : _ ->  e_int_t -> e_pieces_t ->  e_t\nloop_d i e_int e_pieces =\n    if (i < (SYS_N+63)\/64 - 1)\n    then loop_d (i+1) e_int e_pieces'\n    else join e_pieces\n    where\n        (x : [8]base_t) = store8 (e_pieces@i) (e_int@i)\n        (e_pieces' : e_pieces_t) = update e_pieces i x\n\n\/\/shift each value by j and && with 0xFF\nloop_e : _ -> _ -> e_int_t -> e_t -> e_t\nloop_e j i e_int e =\n    if (j<(SYS_N % 64)) then loop_e (j+8) i e_int e' else e\n    where\n        (w : base_t) = (e_int@i) >> j\n        (x : base_t) = w && (cvt_16 0xFF)\n        (e' : [872]base_t) = update e (j\/8) x\n\ngen_e : e_t -> e_t\ngen_e e = undefined where\n    (val_1 : val_t) = zero\n    (ind_1 : ind_t) = zero\n    (e_int_1 : e_int_t) = zero\n    (ind_2 : ind_t)  = while_loop ind_1\n    (val_2 : val_t) = loop_a 0 val_1 ind_2\n    (e_int_2 : e_int_t) = loop_c 0 val_2 ind_2 e_int_1\n    (e_pieces_1 : e_pieces_t) = groupBy `{8} e\n    (e_2 : e_t) = loop_d 0 e_int_2 e_pieces_1\n    (i : [16]) = (SYS_N+63)\/64 - 1 \/\/max at previous loop\n    (e_3 : e_t) = loop_e 0 i e_int_2 e_2\n\nsyndrome : g_pk_t -> e_t -> g_s_t -> g_s_t\nsyndrome pk e s_in = s_out where\n    tail = PK_NROWS % 8\n    \/\/ PK_ROW_BYTES = 677\n    \/\/ PK_NROWS = 1547\n    pk_short = take `{1047319} pk \/\/ PK_ROW_BYTES * PK_NROWS (right size)\n    pk_ptr = groupBy `{677} pk_short\n    loop_c : _ -> SYS_N8_t -> SYS_N8_t\n    loop_c j row =\n        if (j >= SYS_N\/8 - PK_ROW_BYTES)\n        then loop_c (j-1) row'\n        else row\n        where\n            a = (row @ j) << tail\n            b = (row @ (j-1)) >> (8-tail)\n            c = a||b\n            row' = update row j c\n    loop_d : _ -> base_t -> SYS_N8_t -> base_t\n    loop_d j b row =\n        if (j < (SYS_N\/8))\n        then loop_d (j+1) ((row@j) && (e@j)) row\n        else b\n    second_loop : _ -> g_s_t -> g_s_t\n    second_loop i s =\n        if (i < PK_NROWS)\n        then second_loop (i+1) s_out\n        else s\n        where\n            (row_1 : SYS_N8_t) =  zero # (pk_ptr@i)\n            (row_2 : SYS_N8_t) = loop_c (SYS_N\/8-1) row_1\n            (d : base_t) =  (row_2@(i\/8))|| (1 << (i%8))\n            (row_3 : SYS_N8_t) =  update row_2 (i\/8) d\n            (b_0 : base_t) = loop_d 0 0 row_3\n            (b_1 : base_t) = b_0 ^ (b_0>>4)\n            (b_2 : base_t) = b_1 ^ (b_1>>2)\n            (b_3 : base_t) = b_2 ^ (b_2>>1)\n            (b_4 : base_t) = b_3 && 1\n            (sval : base_t) =  (s@(i\/8)) || (b_4 << (i%8))\n            (s_out : g_s_t) =  update s (i\/8) sval\n    (s : g_s_t) = zero # (drop `{194} s_in)\n    s_out = second_loop 0 s\n\nencrypt : g_s_t -> g_pk_t -> e_t -> g_s_t\nencrypt s pk e = s where\n    (e' : e_t) = gen_e e\n    (s : g_s_t) = syndrome pk e' s\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/CM_Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named CM_Parameters that contains the following definitions: (1) a type alias for a 32-bit sequence; (2) a record type with fields named m, q, n, t, k, and d, each of the 32-bit sequence type; (3) a generic type alias parameterized by n that represents an array of n divided by 8 elements, each an 8-bit bit-vector; (4) a function that takes four 32-bit inputs representing m, n, t, and d and returns the record, where q is computed as two raised to the power m, k is computed as n minus (m times t), and the remaining fields are set from the inputs; ensure all assigned values are annotated as 32-bit sequences; (5) a predicate from the record to Bool that returns true exactly when m is positive, n is positive and less than or equal to q, t is at least two and the product m times t is strictly less than n, and d is positive; implement this predicate using local bindings to extract m, n, and t from the record and a helper that checks whether a 32-bit value is greater than zero. Provide full type signatures for all definitions and ensure the module compiles."},{"role":"assistant","content":"```cryptol\nmodule CM_Parameters where\n\ntype a_ty = [32]\n\ntype CM =\n    { m : a_ty      , q : a_ty      , n : a_ty      , t : a_ty      , k : a_ty      , d : a_ty     }\n\ntype byte_rep n = [n\/8][8] Bit\n\nmake_mk : a_ty -> a_ty -> a_ty -> a_ty -> CM \nmake_mk m n t d =\n    { m = m : a_ty\n    , q = (2^m) : a_ty\n    , n = n : a_ty\n    , t = t : a_ty\n    , k = (n-m*t) : a_ty\n    , d = d : a_ty\n    }\n\nmk_ok : CM -> Bool\nmk_ok cm =\n    ((is_pos m) \/\\ (n_ok) \/\\ (t_ok) \/\\ (is_pos cm.d))\n    where\n        m = cm.m\n        n = cm.n\n        t = cm.t\n        is_pos e = e>0\n        n_ok = ((is_pos n) \/\\ (n <= cm.q))\n        t_ok = (t>=2) \/\\ (m*t <n)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/CM_696.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named CM_696 that imports CM_Parameters and contains a single top-level constant cm696 of type CM. Implement cm696 as a record with fields m, q, n, t, k, and d. Each field value must be a numeric literal explicitly annotated with the element type a_ty, and the entire record must be annotated as CM. Assign the following values: m = 13, q = 2 raised to 13, n = 6960, t = 119, k = 5413, and d = 256. Do not include any additional definitions or properties; ensure the module only provides this constant with the specified types and values."},{"role":"assistant","content":"```cryptol\nmodule CM_696 where\n\nimport CM_Parameters\n\ncm696  =\n    { m = 13 : a_ty\n    , q = (2^13) : a_ty\n    , n = 6960 : a_ty\n    , t = 119 : a_ty\n    , k = 5413 : a_ty\n    , d = 256 : a_ty\n    } : CM\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/Encapsulation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Encapsulation that contains the following definitions: (1) Numeric type parameters t, n, m, d with finiteness constraints; require t, n, m to be at least 1, ensure t-1 is at least 1, and include any necessary relations so all vector and matrix sizes below are well-formed. (2) Type aliases: a single-bit field element; length-n bit vector; length-(n \u2212 m\u00b7t) bit vector; length-t, length-m, and length-(m\u00b7t) bit vectors; a t-by-n matrix of m-bit field elements; length-d bit vector; a field element type equal to an m-bit vector; a polynomial as t field elements; an array of n field elements; records grouping polynomial and alphas, secret state and parameters, and ciphertext fields; a public key as an (m\u00b7t)-by-(n \u2212 m\u00b7t) bit matrix; a hash-input record with an Integer, an n-bit vector, and a ciphertext; a weighted error vector as an n-bit vector; a session key as a 32-bit vector. (3) Function signatures: step_1: takes an m\u00b7t-bit vector and a public key, returns the t-by-n matrix of field elements; step_2: takes that matrix and a weighted error vector, returns an m\u00b7t-bit vector; encoding_subroutine: takes a weighted error vector and a public key, initializes an m\u00b7t-bit zero vector, computes the matrix with step_1, then computes and returns the m\u00b7t-bit result with step_2; compute_hash_2e: maps a weighted error vector to a length-d bit vector; compute_hash_1e: maps a weighted error vector and a ciphertext record to a 32-bit session key; encapsulation: takes a public key and weighted error vector, derives C0 via encoding_subroutine, derives C1 via compute_hash_2e, constructs a ciphertext record from C0 and C1, derives the session key via compute_hash_1e with the error and ciphertext, and returns the pair (session key, ciphertext). Provide complete type signatures for all names listed and bodies consistent with these behaviors."},{"role":"assistant","content":"```cryptol\nmodule Encapsulation where\n\nparameter\n    type t : #\n    type constraint (fin t, t>=1, t-1>=1)\n    type n : #\n    type constraint (fin n, n>=1)\n    type m : #\n    type constraint (fin m, m>=1, t * n == min t n)\n    type d : #\n\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [(n-m*t)]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [m*t]f2_T  type H_T = [t][n]field_element_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                    , a : alphas_T                  }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                       , g : gamma_T\n    }\ntype public_key_T = [m*t][(n-m*t)]f2_T\ntype C0_T = mt_T\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\n\ntype weighted_T = n_T\n\nstep_1 : mt_T -> public_key_T -> H_T\nstep_1 I A = zero\n\nstep_2 : H_T -> weighted_T -> C0_T\nstep_2 H e = zero\n\nencoding_subroutine : weighted_T -> public_key_T -> C0_T\nencoding_subroutine e T = C0 where\n    (I: mt_T) = zero\n    (H:H_T) = step_1 I T         (C0:C0_T) = step_2 H e\n\ntype session_key_t = [32] compute_hash_2e e = undefined\ncompute_hash_1e e C = undefined\n\nencapsulation\n    : public_key_T ->  weighted_T\n    -> (session_key_t, cipher_text_T)\nencapsulation T e =  (K, C) where\n            (C0 : C0_T) = encoding_subroutine e T\n        (C1: C1_T) = compute_hash_2e e\n    (C: cipher_text_T) = {C0 = C0, C1 = C1}\n    (K: session_key_t) = compute_hash_1e e C\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/CM_819.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named CM_819 that imports CM_Parameters and contains the following definition: a constant record named CM_819 of type CM. The record must have fields m, q, n, t, k, and d, each annotated with the parameter type a_ty from the imported module. Assign the values as follows: m equals 13; q equals 2 raised to m; n equals 8192; t equals 128; k equals n minus (m times t); d equals 256. Explicitly ascribe the overall record to type CM."},{"role":"assistant","content":"```cryptol\nmodule CM_819 where\n\nimport CM_Parameters\n\nCM_819 =\n    { m = 13 : a_ty\n    , q = (2^13) : a_ty\n    , n = 8192 : a_ty\n    , t = 128 : a_ty\n    , k = (8192-(13*128)) : a_ty\n    , d = 256 : a_ty\n    } : CM\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/Key_Generation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Key_Generation that contains the following definitions aligned with McEliece KEM key generation: declare type parameters t, n, m, d with constraints that they are finite, positive, and satisfy the given shape relation between t and n. Introduce type synonyms for the binary field element, n-bit vector, (n \u2212 m\u00b7t)-bit vector, t-bit vector, m-bit vector, (m\u00b7t)-bit vector, t\u00d7n matrix of field elements, d-bit vector, field element equal to an m-bit vector, polynomial as a length\u2011t vector of field elements, n evaluation points, a record with polynomial and evaluation points, a secret n\u2011bit seed alias, a private key record holding the seed and the gamma record, a public key as an (m\u00b7t)\u00d7(n \u2212 m\u00b7t) bit matrix, ciphertext parts and record, a hash input record, and an error record with length and weight fields. Provide random_element : field_element_T that returns the m\u2011bit element with all bits set, and random_elements : {t0}(fin t0, t0>=1) => [t0]field_element_T that repeats random_element t0 times. Define step_1 : poly_T as a monic polynomial of length t formed by concatenating (t\u22121) random field elements with a single multiplicative\u2011identity coefficient. Define step_3 : (t*n == min t n) => poly_T -> alphas_T -> H_T that constructs a t\u00d7n matrix whose entries are each evaluation point divided by the polynomial\u2019s value at that point. Provide step_5 : H_T -> (Bool, public_key_T) that validates the matrix and derives a public key (body may remain unspecified). Implement mk_gamma : Integer -> (gamma_T, public_key_T) that loops: sample the monic polynomial and n evaluation points, form the matrix with step_3, call step_5, return the gamma\/public key on success or retry up to 100 attempts. Implement key_generation : [n]Bit -> (public_key_T, private_key_T) that calls mk_gamma 0 and returns the public key and a private key pairing the input seed with the produced gamma."},{"role":"assistant","content":"```cryptol\nmodule Key_Generation where\n\nparameter\n    type t : #\n    type constraint (fin t, t>=1, t-1>=1)\n    type n : #\n    type constraint (fin n, n>=1)\n    type m : #\n    type constraint (fin m, m>=1, t * n == min t n)\n    type d : #\n\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [(n-m*t)]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [m*t]f2_T\ntype H_T = [t][n]field_element_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                    , a : alphas_T                  }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                       , g : gamma_T\n    }\ntype public_key_T = [m*t][(n-m*t)]f2_T\ntype C0_T = mt_T\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\ntype e_T =\n    { length : n_T\n    , hammington_weight : t_T\n    }\n\nrandom_element : field_element_T\nrandom_element = ([True | i <- [1..m]])\nrandom_elements : {t0}(fin t0, t0>=1) => [t0]field_element_T\nrandom_elements = ([random_element | i <- [1..t0]])\n\nstep_1 = random_elements `{ t0 = t-1}#[1]\n\nstep_3 : (t * n == min t n) =>  poly_T -> alphas_T -> H_T\nstep_3 g alphas = [[ f i j | j <- [1..n]] | i <- [1..t]]\n    where f i j = aj \/ (g @ aj)\n            where aj = alphas@j\n\nstep_5 : H_T -> (Bool, public_key_T)\nstep_5 H_tilde = undefined\n\nmk_gamma : Integer -> (gamma_T,public_key_T)\nmk_gamma counter =\n    if(flag) then ({p=g, a=alphas}, public_key)\n    else if (counter < 100)\n        then mk_gamma (counter+1)\n    else undefined\n    where\n                (g: poly_T) = step_1\n        (alphas: alphas_T) =  random_elements `{ t0 = n}\n        (H_tilde: H_T) = step_3 g alphas\n        (flag, public_key) = step_5 H_tilde\n\nkey_generation : [n]Bit -> (public_key_T, private_key_T)\nkey_generation s = (public_key, private_key) where\n    (gamma: gamma_T, public_key: public_key_T) = mk_gamma 0\n    (private_key: private_key_T) = {s=s, g=gamma}\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/Types.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Types that declares four type parameters t, n, m, and d with kind # and constraints: each is finite; t \u2265 1; t \u2212 1 \u2265 1; n \u2265 1; m \u2265 1; and the product t*n equals min(t, n). Inside the module, define these type synonyms over GF(2): f2_T as the bit type; n_T as a vector of n bits; k_T as a vector of (n \u2212 m*t) bits; t_T as a vector of t bits; m_T as a vector of m bits; mt_T as a vector of m*t bits; H_T as a t-by-n matrix of field elements; d_T as a vector of d bits; field_element_T as m_T; poly_T as a vector of t field elements; alphas_T as a vector of n field elements; gamma_T as a record with fields p (poly_T) and a (alphas_T); s_T as n_T; private_key_T as a record with fields s (n_T) and g (gamma_T); public_key_T as a matrix of bits with m*t rows and (n \u2212 m*t) columns; C0_T as mt_T; C1_T as d_T; cipher_text_T as a record with fields C0 (C0_T) and C1 (C1_T); hash_input_T as a record with fields n (Integer), v (n_T), and C (cipher_text_T); weighted_T as n_T. Ensure all type-level size expressions and finiteness\/kind constraints are attached to the corresponding parameters within the module."},{"role":"assistant","content":"```cryptol\nmodule Types where\n\nparameter\n    type t : #\n    type constraint (fin t, t>=1, t-1>=1)\n    type n : #\n    type constraint (fin n, n>=1)\n    type m : #\n    type constraint (fin m, m>=1, t * n == min t n)\n    type d : #\n\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [(n-m*t)]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [m*t]f2_T  type H_T = [t][n]field_element_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                    , a : alphas_T                  }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                       , g : gamma_T\n    }\ntype public_key_T = [m*t][(n-m*t)]f2_T\ntype C0_T = mt_T\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\n\ntype weighted_T = n_T\n\n-------------\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/keccak.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Keccak that contains the following definitions and properties, with explicit type signatures and size constraints: (1) Hash and XOF front-ends: SHA3-224, SHA3-256, SHA3-384, SHA3-512 that call a parameterized sponge with specific rate\/capacity and SHA-3 domain-separation; SHAKE128 and SHAKE256 that stream output with their domain-separation; cSHAKE128 and cSHAKE256 that, when customization inputs are both empty, equal the corresponding SHAKE, otherwise absorb encodings of two customization strings followed by the message with the cSHAKE domain bits. (2) Core sponge: Keccak that takes a bitvector message and returns an infinite bitstream by absorbing padded rate-sized blocks into a 5\u00d75 state of w-bit lanes (w = (r+c)\/25, w \u2264 64, r \u2265 1, r+c multiple of 25) using absorb, and squeezing rate bits using squeeze with repeated Keccak_f applications. (3) Padding: pad that performs the standard multi-rate padding to a given rate. (4) Permutation: Keccak_f that applies 24 rounds; Round that composes \u03b8, \u03c1, \u03c0, \u03c7, then \u03b9 with the round constant; lane-wise transforms \u03b8, \u03c1 (rotates each lane by fixed offsets), \u03c0 (lane permutation), \u03c7 (nonlinear row-wise combine), and \u03b9 (xor of round constant). (5) Round constants: RCs64 as 24 fixed 64-bit constants; RCs as the width-adapted 5\u00d75 constants array where n = 12 + 2\u00b7lg2(w) \u2264 24. (6) Layout helpers: unflatten and flatten between a flat bitvector and a 5\u00d75 array of w-bit lanes; xor as reduction-xor of a vector of words. (7) Stream helpers: toBytes and fromBytes converting between bitvectors and byte arrays. (8) LFSR: lfsr producing an infinite bitstream from an 8-bit LFSR defined by a primitive polynomial. (9) Constants and tests: msg1600 as a 1600-bit pattern vector. Define properties: RC_correct (relates RCs64 bits to the LFSR sequence for valid indices), unflatten_correct (indexing equivalence between flat and 5\u00d75 view), flatten_correct (flatten is inverse of unflatten at w=64 and full width), and test-vector properties t1\u2013t4, u1\u2013u4, v1, w1, k1\u2013k6 asserting known outputs for specified inputs. Ensure all size parameters are finite where required and constraints (e.g., r+c divisible by 25, w \u2264 64, 25\u00b7w \u2265 r) are stated in signatures."},{"role":"assistant","content":"```cryptol\nmodule Keccak where\n\nSHA_3_224 M = take`{224} (Keccak `{r = 1152, c =  448} (M # 0b01))\nSHA_3_256 M = take`{256} (Keccak `{r = 1088, c =  512} (M # 0b01))\nSHA_3_384 M = take`{384} (Keccak `{r =  832, c =  768} (M # 0b01))\nSHA_3_512 M = take`{512} (Keccak `{r =  576, c = 1024} (M # 0b01))\nSHAKE128 M = Keccak`{r = 1344, c = 256} (M # 0b1111)\nSHAKE256 M = Keccak`{r = 1088, c = 512} (M # 0b1111)\n\nCSHAKE128 M s1 s2 = if (s1 == \"\" \/\\ s2 == \"\") then (SHAKE128 M)\n                                               else (Keccak`{r = 1344, c = 256} (join(s1)#join(s2)#M#0b00))\n\nCSHAKE256 M s1 s2 = if (s1 == \"\" \/\\ s2 == \"\") then (SHAKE256 M)\n                                               else (Keccak`{r = 1088, c = 512} (join(s1)#join(s2)#M#0b00))\n\nKeccak : {r, c, m}\n  ( fin r, fin c, fin m\n  , r >= 1\n  , (r + c) % 25 == 0\n  , 64 >= (r + c) \/ 25\n  ) => [m] -> [inf]\nKeccak M = squeeze `{r = r} (absorb `{w = (r + c) \/ 25} Ps)\n  where Ps = pad `{r = r} M\n\nsqueeze : {r, w} (fin r, fin w, 64 >= w, r >= 0, 25 * w >= r) => [5][5][w] -> [inf]\nsqueeze A = take`{r} (flatten A) # squeeze`{r = r} (Keccak_f A)\n\nabsorb : {r, w, n} (fin r, fin w, fin n, 64 >= w, 25 * w >= r) => [n][r] -> [5][5][w]\nabsorb Ps = as ! 0\n  where\n    as = [zero] # [ Keccak_f `{w = w} (s ^ (unflatten p)) | s <- as | p <- Ps ]\n\npad : {r, m}\n  ( fin r, fin m\n  , r >= 1\n  ) => [m] -> [(m + 2) \/^ r][r]\n\npad M = split (M # [True] # zero # [True])\n\nKeccak_f : {w} (fin w, 64 >= w) => [5][5][w] -> [5][5][w]\nKeccak_f A0 = rounds ! 0\n  where\n    rounds = [A0] # [ Round RC A | RC <- RCs`{w = w} | A <- rounds ]\n\nRound : {w} (fin w) => [5][5][w] -> [5][5][w] -> [5][5][w]\nRound RC A = \u03b9 RC (\u03c7 (\u03c0 (\u03c1 (\u03b8 A))))\n\n\u03b8 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03b8 A = A'\n  where\n    C = [ xor a | a <- A ]\n    D = [ C @ x ^ (C @ y <<< 1)\n        | (x:[8]) <- [4,0,1,2,3]\n        | (y:[8]) <- [1,2,3,4,0]\n        ]\n    A' = [ [ a ^ (D @ x) | a <- A @ x ] | (x:[8]) <- [0 .. 4] ]\n\n\u03c1 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03c1 A = groupBy`{5} [ a <<< r | a <- join A | (r:[8]) <- R ]\n  where R = [00, 36, 03, 41, 18,\n             01, 44, 10, 45, 02,\n             62, 06, 43, 15, 61,\n             28, 55, 25, 21, 56,\n             27, 20, 39, 08, 14]\n\n\u03c0 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03c0 A = groupBy`{5} [ A @ ((x + 3*y) % 5) @ x\n                  | (x:[8]) <- [0..4], (y:[8]) <- [0..4]\n                  ]\n\n\u03c7 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03c7 A = groupBy`{5} [ (A @ x @ y) ^ (~ A @ ((x + 1) % 5) @ y\n                                  && A @ ((x + 2) % 5) @ y)\n                  | (x:[8]) <- [0..4], (y:[8]) <- [0..4]\n                  ]\n\n\u03b9 : {w} (fin w) => [5][5][w] -> [5][5][w] -> [5][5][w]\n\u03b9 RC A = A ^ RC\n\nRCs : {w, n} (fin w, fin n, 24 >= n, n == 12 + 2 * (lg2 w)) => [n][5][5][w]\nRCs = take`{n} [ [[take`{w} RC] # zero] # zero | RC <- RCs64 ]\n\nRCs64 : [24][64]\nRCs64 = join (transpose [\n    [0x0000000000000001, 0x000000008000808B],\n    [0x0000000000008082, 0x800000000000008B],\n    [0x800000000000808A, 0x8000000000008089],\n    [0x8000000080008000, 0x8000000000008003],\n    [0x000000000000808B, 0x8000000000008002],\n    [0x0000000080000001, 0x8000000000000080],\n    [0x8000000080008081, 0x000000000000800A],\n    [0x8000000000008009, 0x800000008000000A],\n    [0x000000000000008A, 0x8000000080008081],\n    [0x0000000000000088, 0x8000000000008080],\n    [0x0000000080008009, 0x0000000080000001],\n    [0x000000008000000A, 0x8000000080008008]\n])\n\nunflatten : {r, w} (fin w, 25*w >= r) => [r] -> [5][5][w]\nunflatten p = transpose (groupBy`{5} (reverse (groupBy`{w} (reverse (p # zero)))))\n\nflatten : {w} (fin w) => [5][5][w] -> [5 * 5 * w]\nflatten A = reverse (join (reverse (join (transpose A))))\n\nxor : {a, b} (fin a) => [a][b] -> [b]\nxor xs = xors ! 0\n  where xors = [zero] # [ x ^ z | x <- xs | z <- xors ]\n\nproperty RC_correct i j =\n  (i:[8]) < 24 ==> (j:[8]) < 7 ==> RCs64@i!(2^^j - 1) == lfsr@(j + 7*i)\n\nlfsr : [inf]\nlfsr = [ p!0 | p <- ps ]\n  where\n\n    ps = [0x01] # [ pmod (pmult p 0b10) m | p <- ps ]\n    m = <| x^^8 + x^^6 + x^^5 + x^^4 + 1 |>\n\nproperty unflatten_correct x y z p =\n  x < 5 ==> y < 5 ==> z < (64:[12]) ==>\n  p@((5*y + x)*64 + z) == unflatten`{1600,64} p @ x @ y ! z\n\nproperty flatten_correct s =\n  unflatten`{1600,64} (flatten`{64} s) == s\n\ntoBytes : {n} (fin n) => [8*n] -> [n][8]\ntoBytes s = reverse (split (reverse s))\n\nfromBytes : {n} (fin n) => [n][8] -> [8*n]\nfromBytes bs = reverse (join (reverse bs))\n\nproperty t1 = join (toBytes (SHA_3_224 [])) ==\n  0x6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7\nproperty t2 = join (toBytes (SHA_3_256 [])) ==\n  0xa7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a\nproperty t3 = join (toBytes (SHA_3_384 [])) ==\n  0x0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004\nproperty t4 = join (toBytes (SHA_3_512 [])) ==\n  0xa69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26\n\nproperty u1 = join (toBytes (SHA_3_224 0b11001)) ==\n  0xffbad5da96bad71789330206dc6768ecaeb1b32dca6b3301489674ab\nproperty u2 = join (toBytes (SHA_3_256 0b11001)) ==\n  0x7b0047cf5a456882363cbf0fb05322cf65f4b7059a46365e830132e3b5d957af\nproperty u3 = join (toBytes (SHA_3_384 0b11001)) ==\n  0x737c9b491885e9bf7428e792741a7bf8dca9653471c3e148473f2c236b6a0a6455eb1dce9f779b4b6b237fef171b1c64\nproperty u4 = join (toBytes (SHA_3_512 0b11001)) ==\n  0xa13e01494114c09800622a70288c432121ce70039d753cadd2e006e4d961cb27544c1481e5814bdceb53be6733d5e099795e5e81918addb058e22a9f24883f37\n\nmsg1600 : [1600]\nmsg1600 = join [ 0b11000101 | _ <- zero : [200] ]\n\nproperty v1 = join (toBytes (SHA_3_224 msg1600)) ==\n  0x9376816aba503f72f96ce7eb65ac095deee3be4bf9bbc2a1cb7e11e0\n\nproperty w1 = join (toBytes (SHA_3_224 (msg1600 # 0b11000))) ==\n  0x22d2f7bb0b173fd8c19686f9173166e3ee62738047d7eadd69efb228\n\nproperty k1 = join (toBytes (take`{512} (SHAKE128 []))) == 0x7f9c2ba4e88f827d616045507605853ed73b8093f6efbc88eb1a6eacfa66ef263cb1eea988004b93103cfb0aeefd2a686e01fa4a58e8a3639ca8a1e3f9ae57e2\n\nproperty k2 = join (toBytes (take`{512} (SHAKE128 0b0))) == 0xe78b86559a9ccdc72288bf7bcf8e11d574543a2922978913a02be149e89d03cae63d2c36e2cf6906791b187d7e371d4f21ebe59dcfc249a510b82255a18250dd\n\nproperty k3 = join (toBytes (take`{512} (SHAKE128 0b11))) == 0xf6b6c4093f0a2ceba61b9f2c2fea2ca238ce9005edcd588c380405070532ddd00cbd3a3a7448017d874c52c9e383fa3db1c184e023181fcc8550f53ac92feca5\n\nproperty k4 = join (toBytes (take`{512} (SHAKE256 []))) == 0x46b9dd2b0ba88d13233b3feb743eeb243fcd52ea62b81b82b50c27646ed5762fd75dc4ddd8c0f200cb05019d67b592f6fc821c49479ab48640292eacb3b7c4be\n\nproperty k5 = join (toBytes (take`{512} (SHAKE256 0b0))) == 0x1e20b13f3bdb730d286913335c092bcec0eb1aff2798c05736faa93bd665807a48ed7652aefd600427e9f797d647b9b355d30410d71b8e275a676545600f1c35\n\nproperty k6 = join (toBytes (take`{512} (SHAKE256 0b11))) == 0x4f86b0eb85f7a9f6dc38b622706948adb2beb6dd6911b5e9d865fd1f9667b5c02a0dbb39c488b040a18ff3885f04ef957c98f3948e6b7959a9b8950ffd6345d5\n```"}]}
