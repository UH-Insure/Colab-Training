{"filename":"cryptol\/examples\/splitAt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a function `splitAt` that splits a 4-element sequence of 8-bit values into a pair of 2-element sequences, and provide a property that the example bindings for `x`, `y`, `a`, `b`, `c`, and `d` type-check and evaluate consistently with this behavior."},{"role":"assistant","content":"```cryptol\nx = [1,2,3,4] : [_][8]\n\ny = (splitAt x) : ([2][8],[2][8])\n\na = y.0 @ 0\nb = y.0 @ 1\nc = y.1 @ 0\nd = y.1 @ 1\n```"}]}
{"filename":"cryptol\/examples\/AE.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing this generic authenticated encryption (AE) interface with abstract types A, K, n, p, tagAmount, defining tweak_cipher, Enc, Dec, Tag, and the encrypt function, and include properties that Enc\/Dec are inverses and that Tag authenticates the ciphertext."},{"role":"assistant","content":"```cryptol\nmodule AE where\n\nparameter\n  type A : *            type K : *            type n : #            type p : #            type tagAmount : #\n\n  type constraint (fin p, fin n, n >= tagAmount)\n\n    tweak_cipher : K -> { nonce : [n], state : A, z : [64] } -> [n] -> [n]\n\n    Cost : [64]\n\n  Enc : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Dec : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Tag : K -> { nonce : [n], state : A, z : [64] } -> [p*n] -> [n]\n\ntype Node       = { message : WorkBlock, state : State }\n\ntype WorkBlock  = [p*n]\n\ntype State      = [p*n]  \ntype Tweak      = { nonce : Nonce, state : A, z : Int }\ntype Nonce      = [n]\n\ntype Int = [64]\n\nencrypt :\n  {m} fin m => K -> Nonce -> A -> [m * (p * n)] -> [m * (p * n) + tagAmount]\nencrypt key nonce state inputMsg = encMsg # tag\n\n  where\n  encMsg = join rest.0.message\n\n  tag = take (Tag key (tweak (1 - final.1)) final.0.state)\n\n  final = steps ! 0\n\n  steps = [ ({ message = undefined, state = zero }, 1) ] # rest\n  rest  = [ (Enc key (tweak v) { message = m, state = prev.state }, v + Cost)\n          | (prev,v) <- steps\n          | m        <- chunks\n          ]\n\n  chunks : [m] [p * n]\n  chunks = split inputMsg\n\n  tweak : Int -> Tweak\n  tweak v = { nonce = nonce, state = state, z = v }\n```"}]}
{"filename":"cryptol\/examples\/xor_cipher.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that specifies an XOR-based stream cipher with 8-bit keys, defines `encrypt` and `decrypt` as byte-wise XOR of key and message, and includes a property `roundtrip` stating that decrypting an encrypted message with the same key returns the original message."},{"role":"assistant","content":"```cryptol\nencrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\nencrypt key plaintext = [pt ^ key | pt <- plaintext ]\n\ndecrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\ndecrypt key ciphertext = [ct ^ key | ct <- ciphertext ]\n\nproperty roundtrip k ip = decrypt k (encrypt k ip) == ip\n```"}]}
{"filename":"cryptol\/examples\/zero_weird.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the functions `x` and `y` using `zero`, along with properties `xprop` and `yprop` asserting their results are 0 for all inputs, and include example constants `t1` and `t2` as in the description."},{"role":"assistant","content":"```cryptol\nx : {a}() => a -> [16]\nx v = zero v \n\nproperty xprop v = x v == 0\n\ny : [12] -> [4] -> [17]\ny a b = zero a b\n\nproperty yprop v w = y v w == 0\n\nt1 = x 13\nt2 = y 2 3\n```"}]}
{"filename":"cryptol\/examples\/builtin_lifting.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the given values and collections and proves the listed properties (p1\u2013p10) about lifted arithmetic, bitwise negation, and tuple\/record operations over finite and infinite sequences."},{"role":"assistant","content":"```cryptol\nx = [True,False]\ny = [False,True]\n\nproperty p1 = x == (2 : [2])\n\nproperty p2 = x + y == 3\nproperty p3 = x + y == [True,True]\n\nxx = [[True,False]]\nyy = [[False,True]]\n\nproperty p4 = xx + yy == [3]\n\nproperty p5 = ~ xx == yy\n\nxinf = [2 ... ]\nyinf = [3 ... ]\n\nproperty p6 = (xinf + yinf) @ (0 : [0]) == (1 : [2])\n\nproperty p7 = (~ xinf) @ (0 : [0]) == (1 : [2])\n\nxrec = { x = 2 : [2], y = 2 : [2] } : {x : [2], y : [2]}\n\nproperty p8 = xrec + xrec + xrec == xrec\n\nproperty p9 = (2,2,xrec) + (2,2,xrec) + (2,2,xrec) == (2:[2],2:[2],xrec) \n\nproperty p10 = (~ { x = (1,2), y = [3,4,5] }) == {x = (0:[1],1:[2]), y = [4, 3, 2] : [3][3] }\n```"}]}
{"filename":"cryptol\/examples\/inflist.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the infinite sequences a, b, c, and d as above and includes the properties t1\u2013t4 asserting that specific indices of these sequences equal the given values."},{"role":"assistant","content":"```cryptol\na = [1 ... ]\nb = [1,2 ... ]\nc = [1 .. 5]\nd = [1,3 .. 9]\n\nproperty t1 = a @ 3 == 1\nproperty t2 = b @ 3 == 1\nproperty t3 = c @ 3 == 4\nproperty t4 = d @ 3 == 4\n```"}]}
{"filename":"cryptol\/examples\/Karatsuba.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing Karatsuba multiplication via kmult and splitmult, and include properties showing that splitmult`{limb} correctly computes zext x * zext y for various word sizes as in splitmult_correct_tiny\/small\/medium\/large\/huge."},{"role":"assistant","content":"```cryptol\nmodule Karatsuba where\n\nkmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 1) => [n] -> [n] -> [2*n]\n\nkmult x y =\n if `n >= (`limb : [max (width limb) (width n)]) then\n   take (splitmult`{limb} (make_atleast`{limb} x) (make_atleast`{limb} y))\n else\n   (zero#x)*(zero#y)\n\nmake_atleast : {n, m, a} (fin n, fin m, Zero a) => [m]a -> [max n m]a\nmake_atleast x = zero#x\n\nsplitmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 6)\n         => [n] -> [n] -> [2*n]\n\nsplitmult x y = (ac # bd) + (zero # ad_bc # (zero:[low]))\n  where\n   type hi  = n\/2\n   type low = n - hi\n\n   (a,b) = splitAt`{hi} x\n   (c,d) = splitAt`{hi} y\n\n   ac : [2*hi]\n   ac = kmult`{limb,hi} a c\n\n   bd : [2*low]\n   bd = kmult`{limb,low} b d\n\n   a_b = (zext a) + (zext b)\n   c_d = (zext c) + (zext d)\n\n   ad_bc : [2*(low+1)]\n   ad_bc = (kmult`{limb,low+1} a_b c_d) - (zext ac) - (zext bd)\n\nproperty splitmult_correct_tiny (x:[9]) (y:[9]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_small (x:[11]) (y:[11]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_medium(x:[17]) (y:[17]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_large (x:[59]) (y:[59]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_huge (x:[511]) (y:[511]) =\n  zext x * zext y == splitmult`{limb=63} x y\n```"}]}
{"filename":"cryptol\/examples\/comp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the sequence comprehensions `x` and `y` as given, and the properties `t1`, `t2`, `t3`, and `t4` that assert specific tuple values at selected indices of these sequences."},{"role":"assistant","content":"```cryptol\nx : [_]([2],[3],[3],[4])\nx = [(a,b,c,d) | a <- [1,2], b <- [3,4] | c <- [5,6], d <- [7,8,9] ]\n\nproperty t1 = x @ 0 == (1,3,5,7)\nproperty t2 = x @ 2 == (2,3,5,9)\nproperty t3 = x @ 3 == (2,4,6,7)\n\ny = [(a,b,c) | a <- [1,2,3], b <- [1,2] | c <- [1 ... ] ]\n\nproperty t4 = y @ 3 == (2,2,0)\n```"}]}
{"filename":"cryptol\/examples\/mini.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the given values and functions (id, inflist, rc, my_true, tup, my_3, sup, gf28Add, gex, sum) with the same types and behaviors, and add a property that checks gf28Add [1,2] == gex for all equivalent instantiations."},{"role":"assistant","content":"```cryptol\nid : [32] -> [32]\nid x = rec x\n  where rec k = if (k == 0) then 0 else 1 + rec (k + (-1))\n\ninflist = [1 ... ] : [_][8]\n\nrc = {x = 3 : [8], y = 5 : [8]}\n\nmy_true = rc.x\n\ntup = (1 : [8], 2 : [8], 3 : [8], 4 : [8])\n\nmy_3 = tup.2\n\nsup = y where y = 3 : [8]\n\ngf28Add : {n} (fin n) => [n][8] -> [8]\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\ngex = gf28Add [1,2]\n\nsum : [_][8] -> [_][8]\nsum x = rec\n  where rec = [ p + q | p <- x | q <- [1,2,3,4] ]\n```"}]}
{"filename":"cryptol\/examples\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Test` that, given an abstract `Cipher ks bs` interface, defines the functions `evktest`, `evttest`, `ekatest`, `dvktest`, `dvttest`, and `dkatest` to test encryption\/decryption against known key\/plaintext\/ciphertext vectors as in the provided type signatures."},{"role":"assistant","content":"```cryptol\nmodule Test where\nimport Cipher\n\nevktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\nevktest (cipher, vkeysCTs, PT) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, CT) <- vkeysCTs ]\n\nevttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\nevttest (cipher, Key, vtextPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (PT, CT) <- vtextPCTs ]\n\nekatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\nekatest (cipher, kaKPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, PT, CT) <- kaKPCTs ]\n\ndvktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\ndvktest (cipher, vkeysCTs, PT) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, CT) <- vkeysCTs ]\n\ndvttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\ndvttest (cipher, Key, vtextPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (PT, CT) <- vtextPCTs ]\n\ndkatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\ndkatest (cipher, kaKPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, PT, CT) <- kaKPCTs ]\n```"}]}
{"filename":"cryptol\/examples\/builtins.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define Cryptol constants t, f, times, div, mod, exp, lgtest, p, m, neg, and comp with type [8], using basic arithmetic, logical, and bitwise built-in operators exactly as in the description below."},{"role":"assistant","content":"```cryptol\nt : [8]\nt = if True then 5 else 4 \nf : [8]\nf = if False then 3 else 5 \ntimes : [8]\ntimes = 5 * 1 * 2 * 3 \ndiv : [8]\ndiv = (((30\/1)\/2)\/3) \nmod : [8]\nmod = 205%10 \nexp : [8]\nexp = 2^^7 \nlgtest : [8]\nlgtest = lg2 128 \np : [8]\np = 3+2 \nm : [8]\nm = 8-3 \nneg : [8]\nneg = -(-5) \ncomp : [8]\ncomp = ~250\n```"}]}
{"filename":"cryptol\/examples\/props.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the constants x, y, z, xx, yy, zz, the polymorphic function t : {a} [a*3] -> [a*3][a*3], and the property p1 = (z == 3), matching the given behavior and types so p1 can be checked by a solver."},{"role":"assistant","content":"```cryptol\nx = [True, False]\ny = [False, True]\nz = x + y\n\nproperty p1 = z == 3\n\nxx = [[True,False]]\nyy = [[False, True]]\nzz = xx + yy\n\nt : {a} [a*3] -> [a*3][a*3]\nt d = zero\n```"}]}
{"filename":"cryptol\/examples\/demote.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the polymorphic function `x : {a}(fin a) => [a] -> [(a*2)+3]` as a constant function returning `0 + 1`, and a top-level binding `y` equal to `x (2 : [3])`."},{"role":"assistant","content":"```cryptol\nx : {a}(fin a) => [a] -> [(a*2)+3]\nx v = 0 + 1\n\ny = x (2 : [3])\n```"}]}
{"filename":"cryptol\/examples\/append.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the sequences x, y, and their concatenation z as given, and specify constants m, w, t, and v that index into z at the same positions and have the same values and types as in the original file."},{"role":"assistant","content":"```cryptol\nx : [_][8]\nx = [1,2,3,4,5,19,12,38,5,3]\n\ny : [_][8]\ny = [19,3,27,5,12]\n\nz = x # y\n\nm = z @ (0 : [1]) w = z @ 2 \nt = z @ 10 v = z @ 11\n```"}]}
{"filename":"cryptol\/examples\/split.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the vector x : [_][8], uses split to produce y : [2][2][8], and defines a, b, c, d as indexed elements of y as in the given example."},{"role":"assistant","content":"```cryptol\nx = [1,2,3,4] : [_][8]\n\ny = (split x) : [2][2][8]\n\na = (y@0) @ 0\nb = (y@0) @ 1\nc = (y@1) @ 0\nd = (y@1) @ 1\n```"}]}
{"filename":"cryptol\/lib\/Array.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Array` that introduces a primitive `Array` type and its primitive operations (constant, lookup, update, equality, copy, set, rangeEqual), and specifies the derived functions `arrayRangeLookup` and `arrayRangeUpdate` with appropriate type constraints and behavior as in the given interface."},{"role":"assistant","content":"```cryptol\nmodule Array where\n\nprimitive type Array : * -> * -> *\n\nprimitive arrayConstant : {a, b} b -> (Array a b)\nprimitive arrayLookup : {a, b} (Array a b) -> a -> b\nprimitive arrayUpdate : {a, b} (Array a b) -> a -> b -> (Array a b)\nprimitive arrayEq : {n, a} (Array [n] a) -> (Array [n] a) -> Bool\n\nprimitive arrayCopy : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> (Array [n] a)\n\nprimitive arraySet : {n, a} (Array [n] a) -> [n] -> a -> [n] -> (Array [n] a)\n\nprimitive arrayRangeEqual : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> Bool\n\narrayRangeLookup : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b\narrayRangeLookup arr idx = res\n  where\n    res @ i = arrayLookup arr (idx + i)\n\narrayRangeUpdate : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b -> (Array a b)\narrayRangeUpdate arr idx vals = arrs ! 0\n  where\n    arrs = [arr] # [ arrayUpdate acc (idx + i) val | acc <- arrs | i <- [0 ..< n] | val <- vals ]\n```"}]}
{"filename":"cryptol\/lib\/SuiteB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `SuiteB` that specifies AES-128\/192\/256 key schedules and block encryption\/decryption plus SHA-224\/256\/384\/512 functions, and include any necessary types, primitives, and helper functions as in the snippet."},{"role":"assistant","content":"```cryptol\nmodule SuiteB where\n\ntype AES128 = 4\n\ntype AES192 = 6\n\ntype AES256 = 8\n\ntype AESRoundKey = [4][32]\n\ntype AESEncryptKeySchedule k =\n  { aesEncInitialKey : AESRoundKey\n  , aesEncRoundKeys  : [k+5]AESRoundKey\n  , aesEncFinalKey   : AESRoundKey\n  }\n\ntype AESDecryptKeySchedule k =\n  { aesDecInitialKey : AESRoundKey\n  , aesDecRoundKeys  : [k+5]AESRoundKey\n  , aesDecFinalKey   : AESRoundKey\n  }\n\naes128EncryptSchedule : [128] -> AESEncryptKeySchedule AES128\naes128EncryptSchedule = aesExpandEncryptSchedule\n\naes128DecryptSchedule : [128] -> AESDecryptKeySchedule AES128\naes128DecryptSchedule = aesExpandDecryptSchedule\n\naes128Schedules : [128] -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\naes128Schedules = aesExpandSchedules\n\naes192EncryptSchedule : [192] -> AESEncryptKeySchedule AES192\naes192EncryptSchedule = aesExpandEncryptSchedule\n\naes192DecryptSchedule : [192] -> AESDecryptKeySchedule AES192\naes192DecryptSchedule = aesExpandDecryptSchedule\n\naes192Schedules : [192] -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\naes192Schedules = aesExpandSchedules\n\naes256EncryptSchedule : [256] -> AESEncryptKeySchedule AES256\naes256EncryptSchedule = aesExpandEncryptSchedule\n\naes256DecryptSchedule : [256] -> AESDecryptKeySchedule AES256\naes256DecryptSchedule = aesExpandDecryptSchedule\n\naes256Schedules : [256] -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\naes256Schedules = aesExpandSchedules\n\naesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]\naesEncryptBlock schedule plaintext = rnf (join final)\n  where\n  final = (AESEncFinalRound (rds!0)) ^ schedule.aesEncFinalKey\n\n  rds = [ schedule.aesEncInitialKey ^ split plaintext ] #\n        [ AESEncRound r ^ rdk\n        | rdk <- schedule.aesEncRoundKeys\n        | r   <- rds\n        ]\n\naesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]\naesDecryptBlock schedule cyphertext = rnf (join final)\n  where\n  final = (AESDecFinalRound (rds!0)) ^ schedule.aesDecFinalKey\n\n  rds = [ split cyphertext ^ schedule.aesDecInitialKey ] #\n        [ AESDecRound r ^ rdk\n        | rdk <- schedule.aesDecRoundKeys\n        | r   <- rds\n        ]\n\nprivate\n    aesExpandEncryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESEncryptKeySchedule k\n    aesExpandEncryptSchedule key = rnf\n         { aesEncInitialKey = ks @  0\n         , aesEncRoundKeys  = ks @@ [ 1 .. k+5 ]\n         , aesEncFinalKey   = ks @  `(k+6)\n         }\n      where\n      ks : [k+7]AESRoundKey\n      ks = groupBy`{4} (AESKeyExpand`{k} (split key))\n\n    aesEncToDecSchedule : {k} (fin k) => AESEncryptKeySchedule k -> AESDecryptKeySchedule k\n    aesEncToDecSchedule enc = rnf\n       { aesDecInitialKey = enc.aesEncFinalKey\n       , aesDecRoundKeys  = map AESInvMixColumns (reverse (enc.aesEncRoundKeys))\n       , aesDecFinalKey   = enc.aesEncInitialKey\n       }\n\n    aesExpandDecryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESDecryptKeySchedule k\n    aesExpandDecryptSchedule key = aesEncToDecSchedule (aesExpandEncryptSchedule key)\n\n    aesExpandSchedules : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> (AESEncryptKeySchedule k, AESDecryptKeySchedule k)\n    aesExpandSchedules key = (encS, aesEncToDecSchedule encS)\n      where encS = aesExpandEncryptSchedule key\n\n    primitive AESEncRound      : [4][32] -> [4][32]\n    primitive AESEncFinalRound : [4][32] -> [4][32]\n    primitive AESDecRound      : [4][32] -> [4][32]\n    primitive AESDecFinalRound : [4][32] -> [4][32]\n    primitive AESInvMixColumns : [4][32] -> [4][32]\n    primitive AESKeyExpand     : {k} (fin k, k >= 4, 8 >= k) => [k][32] -> [4*(k+7)][32]\n\nsha224 : {L} (fin L) => [L] -> [224]\nsha224 msg = join (processSHA2_224 (sha2blocks`{32} msg))\n\nsha256 : {L} (fin L) => [L] -> [256]\nsha256 msg = join (processSHA2_256 (sha2blocks`{32} msg))\n\nsha384 : {L} (fin L) => [L] -> [384]\nsha384 msg = join (processSHA2_384 (sha2blocks`{64} msg))\n\nsha512 : {L} (fin L) => [L] -> [512]\nsha512 msg = join (processSHA2_512 (sha2blocks`{64} msg))\n\nprivate\n    type sha2_block_size w = 16 * w\n    type sha2_num_blocks w L = (L+1+2*w) \/^ sha2_block_size w\n    type sha2_padded_size w L = sha2_num_blocks w L * sha2_block_size w\n\n    sha2pad : {w, L} (fin w, fin L, w >= 1) => [L] -> [sha2_padded_size w L]\n    sha2pad M = rnf (M # 0b1 # zero # ((fromInteger `L) : [2*w]))\n\n    sha2blocks : {w, L} (fin w, fin L, w >= 1) =>\n      [L] -> [sha2_num_blocks w L][16][w]\n    sha2blocks msg = [ split x | x <- split (sha2pad`{w} msg) ]\n\n    primitive processSHA2_224 : {n} (fin n) => [n][16][32] -> [7][32]\n\n    primitive processSHA2_256 : {n} (fin n) => [n][16][32] -> [8][32]\n\n    primitive processSHA2_384 : {n} (fin n) => [n][16][64] -> [6][64]\n\n    primitive processSHA2_512 : {n} (fin n) => [n][16][64] -> [8][64]\n```"}]}
{"filename":"cryptol\/lib\/Float.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines IEEE-754 style floating-point types Float16\/32\/64\/128\/256, rounding modes, and primitives (e.g., fpAdd, fpSub, fpMul, fpDiv, fpFMA, fpSqrt, fpFromBits, fpToBits, fpIsNaN\/Inf\/Zero\/Normal\/Subnormal, fpFromRational, fpToRational) with the same interfaces."},{"role":"assistant","content":"```cryptol\nmodule Float where\n\nprimitive type ValidFloat : # -> # -> Prop\n\nprimitive type { exponent : #, precision : #}\n  ValidFloat exponent precision => Float exponent precision : *\n\ntype Float16  = Float 5 11\n\ntype Float32  = Float 8 24\n\ntype Float64  = Float 11 53\n\ntype Float128 = Float 15 113\n\ntype Float256 = Float 19 237\n\ntype RoundingMode = [3]\n\nroundNearestEven, rne : RoundingMode\nroundNearestEven = 0\nrne              = roundNearestEven\n\nroundNearestAway, rna : RoundingMode\nroundNearestAway  = 1\nrna               = roundNearestAway\n\nroundPositive, rtp : RoundingMode\nroundPositive     = 2\nrtp               = roundPositive\n\nroundNegative, rtn : RoundingMode\nroundNegative     = 3\nrtn               = roundNegative\n\nroundZero, rtz : RoundingMode\nroundZero         = 4\nrtz               = roundZero\n\nprimitive\n  fpNaN : {e,p} ValidFloat e p => Float e p\n\nprimitive\n  fpPosInf : {e,p} ValidFloat e p => Float e p\n\nfpNegInf : {e,p} ValidFloat e p => Float e p\nfpNegInf = - fpPosInf\n\nfpPosZero : {e,p} ValidFloat e p => Float e p\nfpPosZero = zero\n\nfpNegZero : {e,p} ValidFloat e p => Float e p\nfpNegZero = - fpPosZero\n\nprimitive\n  fpFromBits : {e,p} ValidFloat e p => [e + p] -> Float e p\n\nprimitive\n  fpToBits : {e,p} ValidFloat e p => Float e p -> [e + p]\n\nprimitive\n  (=.=) : {e,p} ValidFloat e p => Float e p -> Float e p -> Bool\n\ninfix 20 =.=\n\nprimitive fpIsNaN : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsInf : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsZero : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsNeg : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsNormal : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsSubnormal : {e,p} ValidFloat e p => Float e p -> Bool\n\nfpIsFinite : {e,p} ValidFloat e p => Float e p -> Bool\nfpIsFinite f = ~ (fpIsNaN f \\\/ fpIsInf f )\n\nprimitive\n  fpAdd : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpSub : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpMul : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpDiv : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpFMA : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpAbs : {e,p} ValidFloat e p =>\n    Float e p -> Float e p\n\nprimitive\n  fpSqrt : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p\n\nprimitive\n  fpToRational : {e,p} ValidFloat e p =>\n    Float e p -> Rational\n\nprimitive\n  fpFromRational : {e,p} ValidFloat e p =>\n    RoundingMode -> Rational -> Float e p\n```"}]}
{"filename":"cryptol\/lib\/Cryptol.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Cryptol` that provides the core prelude: primitive numeric and logical types, bitvector and sequence operations, comparison and arithmetic classes, folds\/maps\/zips, sorting, and utility functions, with the same names, types, infix declarations, and properties as in the standard Cryptol prelude."},{"role":"assistant","content":"```cryptol\nmodule Cryptol where\n\ninfixr  5 ==>\ninfixr 10 \\\/\ninfixr 15 \/\\\ninfix  20 ==, ===, !=, !==\ninfix  30 >, >=, <, <=, <$, >$, <=$, >=$\ninfixr 40 ||\ninfixl 45 ^\ninfixr 50 &&\ninfixr 60 #\ninfixl 70 <<, <<<, >>, >>>, >>$\ninfixl 80 +, -\ninfixl 90 *, \/, %, \/$, %$, %^, \/^\ninfixr 95 ^^\ninfixl 100 @, @@, !, !!\n\nprimitive type Bit : *\n\nprimitive type Integer : *\n\nprimitive type {n : #} (fin n, n >= 1) => Z n : *\n\nprimitive type Rational : *\n\ntype Bool = Bit\ntype Word n = [n]\ntype Char = [8]\ntype String n = [n]Char\n\nprimitive type inf : #\n\nprimitive type (==) : # -> # -> Prop\n\nprimitive type (!=) : # -> # -> Prop\n\nprimitive type (>=) : # -> # -> Prop\n\nprimitive type fin : # -> Prop\n\nprimitive type prime : # -> Prop\n\nprimitive type (+) : # -> # -> #\n\nprimitive type (*) : # -> # -> #\n\nprimitive type\n  {m : #, n : # }\n  (fin n, m >= n) =>\n  m - n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin m, n >= 1) =>\n  m \/ n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin m, n >= 1) =>\n  m % n : #\n\nprimitive type (^^) : # -> # -> #\n\nprimitive type width : # -> #\n\ntype lg2 n = width (max n 1 - 1)\n\nprimitive type min : # -> # -> #\n\nprimitive type max : # -> # -> #\n\nprimitive type\n  { m : #, n : # }\n  (fin n, n >= 1) =>\n  m \/^ n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin n, n >= 1) =>\n  m %^ n : #\n\nprimitive type\n  { start : #, next : #, last : # }\n  (fin start, fin next, fin last, start != next) =>\n  lengthFromThenTo start next last : #\n\ntype constraint i <= j = (j >= i)\n\ntype constraint i > j = i >= j + 1\n\ntype constraint i < j = j >= i + 1\n\nprimitive type Literal : # -> * -> Prop\n\nprimitive type LiteralLessThan : # -> * -> Prop\n\nprimitive number : {val, rep} Literal val rep => rep\n\ndemote : {val, rep} Literal val rep => rep\ndemote = number`{val}\n\nlength : {n, a, b} (fin n, Literal n b) => [n]a -> b\nlength _ = `n\n\nprimitive fromTo : {first, last, a}\n  (fin last, last >= first, Literal last a) =>\n  [1 + (last - first)]a\n\nprimitive fromToLessThan :\n  {first, bound, a} (fin first, bound >= first, LiteralLessThan bound a) =>\n  [bound - first]a\n\nprimitive fromToBy : {first, last, stride, a}\n  (fin last, fin stride, stride >= 1, last >= first, Literal last a) =>\n  [1 + (last - first)\/stride]a\n\nprimitive fromToByLessThan : {first, bound, stride, a}\n  (fin first, fin stride, stride >= 1, bound >= first, LiteralLessThan bound a) =>\n  [(bound - first)\/^stride]a\n\nprimitive fromToDownBy : {first, last, stride, a}\n  (fin first, fin stride, stride >= 1, first >= last, Literal first a) =>\n  [1 + (first - last)\/stride]a\n\nprimitive fromToDownByGreaterThan : {first, bound, stride, a}\n  (fin first, fin stride, stride >= 1, first >= bound, Literal first a) =>\n  [(first - bound)\/^stride]a\n\nprimitive fromThenTo : {first, next, last, a, len}\n                       ( fin first, fin next, fin last\n                       , Literal first a, Literal next a, Literal last a\n                       , first != next\n                       , lengthFromThenTo first next last == len) => [len]a\n\nprimitive type FLiteral : # -> # -> # -> * -> Prop\n\nprimitive\n  fraction : { m, n, r, a } FLiteral m n r a => a\n\nprimitive type Zero : * -> Prop\n\nprimitive zero : {a} (Zero a) => a\n\nprimitive type Logic : * -> Prop\n\nprimitive (&&) : {a} (Logic a) => a -> a -> a\n\nprimitive (||) : {a} (Logic a) => a -> a -> a\n\nprimitive (^) : {a} (Logic a) => a -> a -> a\n\nprimitive complement : {a} (Logic a) => a -> a\n\nprimitive type Ring : * -> Prop\n\nprimitive fromInteger : {a} (Ring a) => Integer -> a\n\nprimitive (+) : {a} (Ring a) => a -> a -> a\n\nprimitive (-) : {a} (Ring a) => a -> a -> a\n\nprimitive (*) : {a} (Ring a) => a -> a -> a\n\nprimitive negate : {a} (Ring a) => a -> a\n\nprimitive type Integral : * -> Prop\n\nprimitive (\/) : {a} (Integral a) => a -> a -> a\n\nprimitive (%) : {a} (Integral a) => a -> a -> a\n\nprimitive toInteger : {a} (Integral a) => a -> Integer\n\nprimitive (^^) : {a, e} (Ring a, Integral e) => a -> e -> a\n\nprimitive infFrom : {a} (Integral a) => a -> [inf]a\n\nprimitive infFromThen : {a} (Integral a) => a -> a -> [inf]a\n\nprimitive type Field : * -> Prop\n\nprimitive recip : {a} (Field a) => a -> a\n\nprimitive (\/.) : {a} (Field a) => a -> a -> a\n\nprimitive type Round : * -> Prop\n\nprimitive ceiling : {a} (Round a) => a -> Integer\n\nprimitive floor : {a} (Round a) => a -> Integer\n\nprimitive trunc : {a} (Round a) => a -> Integer\n\nprimitive roundAway : {a} (Round a) => a -> Integer\n\nprimitive roundToEven : {a} (Round a) => a -> Integer\n\nprimitive type Eq : * -> Prop\n\nprimitive (==) : {a} (Eq a) => a -> a -> Bit\n\nprimitive (!=) : {a} (Eq a) => a -> a -> Bit\n\n(===) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\nf === g = \\ x -> f x == g x\n\n(!==) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\nf !== g = \\x -> f x != g x\n\nprimitive type Cmp : * -> Prop\n\nprimitive (<) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (>) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (<=) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (>=) : {a} (Cmp a) => a -> a -> Bit\n\nmin : {a} (Cmp a) => a -> a -> a\nmin x y = if x < y then x else y\n\nmax : {a} (Cmp a) => a -> a -> a\nmax x y = if x > y then x else y\n\nabs : {a} (Cmp a, Ring a) => a -> a\nabs x = if x < fromInteger 0 then negate x else x\n\nprimitive type SignedCmp : * -> Prop\n\nprimitive (<$) : {a} (SignedCmp a) => a -> a -> Bit\n\n(>$) : {a} (SignedCmp a) => a -> a -> Bit\nx >$ y = y <$ x\n\n(<=$) : {a} (SignedCmp a) => a -> a -> Bit\nx <=$ y = ~(y <$ x)\n\n(>=$) : {a} (SignedCmp a) => a -> a -> Bit\nx >=$ y = ~(x <$ y)\n\nenum Option a = None | Some a\n\nenum Result t e = Ok t | Err e\n\nprimitive True  : Bit\n\nprimitive False : Bit\n\n(\/\\) : Bit -> Bit -> Bit\nx \/\\ y = if x then y else False\n\n(\\\/) : Bit -> Bit -> Bit\nx \\\/ y = if x then True else y\n\n(==>) : Bit -> Bit -> Bit\na ==> b = if a then b else True\n\nprimitive (\/$) : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\n\nprimitive (%$) : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\n\ncarry : {n} (fin n) => [n] -> [n] -> Bit\ncarry x y = (x + y) < x\n\nscarry : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nscarry x y = (sx == sy) && (sx != sz)\n  where\n    z  = x + y\n    sx = head x\n    sy = head y\n    sz = head z\n\nsborrow : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsborrow x y = ( x <$ (x-y) ) ^ head y\n\nzext : {m, n} (fin m, m >= n) => [n] -> [m]\nzext x = zero # x\n\nsext : {m, n} (fin m, m >= n, n >= 1) => [n] -> [m]\nsext x = newbits # x\n  where newbits = if head x then ~zero else zero\n\nprimitive (>>$) : {n, ix} (fin n, n >= 1, Integral ix) => [n] -> ix -> [n]\n\nprimitive lg2 : {n} (fin n) => [n] -> [n]\n\nprimitive toSignedInteger : {n} (fin n, n >= 1) => [n] -> Integer\n\nprimitive ratio : Integer -> Integer -> Rational\n\nprimitive fromZ : {n} (fin n, n >= 1) => Z n -> Integer\n\nprimitive (#) : {front, back, a} (fin front) => [front]a -> [back]a\n                                             -> [front + back] a\n\nsplitAt : {front, back, a} (fin front) => [front + back]a\n                                       -> ([front]a, [back]a)\nsplitAt xs = (take`{front,back} xs, drop`{front,back} xs)\n\nprimitive join : {parts, each, a} (fin each) => [parts][each]a\n                                             -> [parts * each]a\n\nprimitive split : {parts, each, a} (fin each) => [parts * each]a\n                                              -> [parts][each]a\n\nprimitive reverse : {n, a} (fin n) => [n]a -> [n]a\n\nprimitive transpose : {rows, cols, a} [rows][cols]a -> [cols][rows]a\n\nprimitive take : {front, back, a} [front + back]a -> [front]a\n\nprimitive drop : {front, back, a} (fin front) => [front + back]a -> [back]a\n\ntail : {n, a} [1 + n]a -> [n]a\ntail xs = drop`{1} xs\n\nhead : {n, a} [1 + n]a -> a\nhead xs = xs @ (0 : Integer)\n\nlast : {n, a} (fin n) => [1 + n]a -> a\nlast xs = xs ! (0 : Integer)\n\ngroupBy : {each, parts, a} (fin each) => [parts * each]a -> [parts][each]a\ngroupBy = split`{parts=parts}\n\nprimitive (<<) : {n, ix, a} (Integral ix, Zero a) => [n]a -> ix -> [n]a\n\nprimitive (>>) : {n, ix, a} (Integral ix, Zero a) => [n]a -> ix -> [n]a\n\nprimitive (<<<) : {n, ix, a} (fin n, Integral ix) => [n]a -> ix -> [n]a\n\nprimitive (>>>) : {n, ix, a} (fin n, Integral ix) => [n]a -> ix -> [n]a\n\nprimitive (@) : {n, a, ix} (Integral ix) => [n]a -> ix -> a\n\n(@@) : {n, k, ix, a} (Integral ix) => [n]a -> [k]ix -> [k]a\nxs @@ is = [ xs @ i | i <- is ]\n\nprimitive (!) : {n, a, ix} (fin n, Integral ix) => [n]a -> ix -> a\n\n(!!) : {n, k, ix, a} (fin n, Integral ix) => [n]a -> [k]ix -> [k]a\nxs !! is = [ xs ! i | i <- is ]\n\nprimitive update : {n, a, ix} (Integral ix) => [n]a -> ix -> a -> [n]a\n\nprimitive updateEnd : {n, a, ix} (fin n, Integral ix) => [n]a -> ix -> a -> [n]a\n\nupdates : {n, k, ix, a} (Integral ix, fin k) => [n]a -> [k]ix -> [k]a -> [n]a\nupdates xs0 idxs vals = foldl upd xs0 (zip idxs vals)\n  where\n    upd xs (i,b) = update xs i b\n\nupdatesEnd : {n, k, ix, a} (fin n, Integral ix, fin k) => [n]a -> [k]ix -> [k]a -> [n]a\nupdatesEnd xs0 idxs vals = foldl upd xs0 (zip idxs vals)\n  where\n    upd xs (i,b) = updateEnd xs i b\n\ngenerate : {n, a, ix} (Integral ix, LiteralLessThan n ix) => (ix -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. <n] ]\n\nsort : {a, n} (Cmp a, fin n) => [n]a -> [n]a\nsort = sortBy (<=)\n\nsortBy : {a, n} (fin n) => (a -> a -> Bit) -> [n]a -> [n]a\nsortBy le ((xs : [n\/2]a) # (ys : [n\/^2]a)) = take zs.0\n  where\n    xs' = if `(n\/2)  == (1 : Integer) then xs else sortBy le xs\n    ys' = if `(n\/^2) == (1 : Integer) then ys else sortBy le ys\n    zs  = [ if i == `(n\/2)        then (ys'@j, i  , j+1)\n             | j == `(n\/^2)       then (xs'@i, i+1, j  )\n             | le (xs'@i) (ys'@j) then (xs'@i, i+1, j  )\n            else                       (ys'@j, i  , j+1)\n          | (_, i , j) <- [ (undefined, 0 : Integer, 0 : Integer) ] # zs\n          ]\n\nprimitive pmult : {u, v} (fin u, fin v) => [1 + u] -> [1 + v] -> [1 + u + v]\n\nprimitive pdiv : {u, v} (fin u, fin v) => [u] -> [v] -> [u]\n\nprimitive pmod : {u, v} (fin u, fin v) => [u] -> [1 + v] -> [v]\n\nprimitive parmap : {a, b, n} (Eq b, fin n) => (a -> b) -> [n]a -> [n]b\n\nprimitive deepseq : {a, b} Eq a => a -> b -> b\n\nrnf : {a} Eq a => a -> a\nrnf x = deepseq x x\n\nprimitive error : {a, n} (fin n) => String n -> a\n\nundefined : {a} a\nundefined = error \"undefined\"\n\nassert : {a, n} (fin n) => Bit -> String n -> a -> a\nassert pred msg x = if pred then x else error msg\n\nprimitive random : {a} [256] -> a\n\nprimitive trace : {n, a, b} (fin n) => String n -> a -> b -> b\n\ntraceVal : {n, a} (fin n) => String n -> a -> a\ntraceVal msg x = trace msg x x\n\nand : {n} (fin n) => [n]Bit -> Bit\nand xs = ~zero == xs\n\nor : {n} (fin n) => [n]Bit -> Bit\nor xs = zero != xs\n\nall : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nall f xs = foldl' (\/\\) True (map f xs)\n\n\/**\n * Disjunction after applying a predicate to all elements.\n *\/\nany : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nany f xs = foldl' (\\\/) False (map f xs)\n\nmap : {n, a, b} (a -> b) -> [n]a -> [n]b\nmap f xs = [f x | x <- xs]\n\nprimitive foldl : {n, a, b} (fin n) => (a -> b -> a) -> a -> [n]b -> a\n\nprimitive foldl' : {n, a, b} (fin n, Eq a) => (a -> b -> a) -> a -> [n]b -> a\n\n\/**\n * Functional right fold.\n *\n * foldr (-) 0 [1,2,3] = 0 - (1 - (2 - 3))\n *\/\nfoldr : {n, a, b} (fin n) => (a -> b -> b) -> b -> [n]a -> b\nfoldr f acc xs = foldl g acc (reverse xs)\n  where g b a = f a b\n\n\/**\n * Functional right fold, with strict evaluation of the accumulator value.\n * The accumulator is reduced to weak head normal form at each step.\n *\n * foldr' (-) 0 [1,2,3] = 0 - (1 - (2 - 3))\n *\/\nfoldr' : {n, a, b} (fin n, Eq b) => (a -> b -> b) -> b -> [n]a -> b\nfoldr' f acc xs = foldl' g acc (reverse xs)\n  where g b a = f a b\n\n\/**\n * Compute the sum of the values in the sequence.\n *\/\nsum : {n, a} (fin n, Eq a, Ring a) => [n]a -> a\nsum xs = foldl' (+) (fromInteger 0) xs\n\nproduct : {n, a} (fin n, Eq a, Ring a) => [n]a -> a\nproduct xs = foldl' (*) (fromInteger 1) xs\n\n\/**\n * Scan left is like a foldl that also emits the intermediate values.\n *\/\nprimitive scanl : {n, a, b}  (a -> b -> a) -> a -> [n]b -> [1+n]a\n\n\/**\n * Scan right is like a foldr that also emits the intermediate values.\n *\/\nscanr : {n, a, b} (fin n) => (a -> b -> b) -> b -> [n]a -> [1+n]b\nscanr f acc xs = reverse (scanl (\\a b -> f b a) acc (reverse xs))\n\n\/**\n * Repeat a value.\n *\/\nrepeat : {n, a} a -> [n]a\nrepeat x = [ x | _ <- zero : [n] ]\n\n\/**\n * 'elem x xs' returns true if x is equal to a value in xs.\n *\/\nelem : {n, a} (fin n, Eq a) => a -> [n]a -> Bit\nelem a xs = any (\\x -> x == a) xs\n\n\/**\n * Create a list of tuples from two lists.\n *\/\nzip : {n, a, b} [n]a -> [n]b -> [n](a, b)\nzip xs ys = [(x,y) | x <- xs | y <- ys]\n\n\/**\n * Create a list by applying the function to each pair of elements in the input.\n *\/\nzipWith : {n, a, b, c} (a -> b -> c) -> [n]a -> [n]b -> [n]c\nzipWith f xs ys = [f x y | x <- xs | y <- ys]\n\n\/**\n * Transform a function into uncurried form.\n *\/\nuncurry : {a, b, c} (a -> b -> c) -> (a, b) -> c\nuncurry f = \\(a, b) -> f a b\n\n\/**\n * Transform a function into curried form.\n *\/\ncurry : {a, b, c} ((a, b) -> c) -> a -> b -> c\ncurry f = \\a b -> f (a, b)\n\n\/**\n * Map a function iteratively over a seed value, producing an infinite\n * list of successive function applications.\n *\/\niterate : {a} (a -> a) -> a -> [inf]a\niterate f z = scanl (\\x _ -> f x) z (zero:[inf]())\n```"}]}
{"filename":"cryptol\/bench\/data\/SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that implements the SHA-512 hash function as in FIPS 180-4, including padding, message scheduling, round constants, initial vector, and define a property `testVector1` asserting the given fixed input hashes to the specified 512-bit output."},{"role":"assistant","content":"```cryptol\nmodule SHA512 where\n\nsha512 M = result\n  where\n    M' = (pad M)\n    blocks = (groupBy`{1024} M')\n    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]\n    result = (join (hash!0))\n\nprocessBlock : [1024] -> [8][64] -> [8][64]\nprocessBlock block Hprev = Hs\n  where\n    Mi = split block : [16][64]\n    Ws = (messageSch Mi)\n    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]\n    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]\n\nstep : [8][64] -> [64] -> [8] -> [8][64]\nstep [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']\n  where\n    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt\n    T2 = (SIGMA0 a) + (Maj a b c)\n    h' = g\n    g' = f\n    f' = e\n    e' = d + T1\n    d' = c\n    c' = b\n    b' = a\n    a' = T1 + T2\n\nmessageSch : [16][64] -> [80][64]\nmessageSch Mi = W\n  where\n    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]\n\npad : {l, k} (fin l,\n              l <= ((2^^128) - 1),\n              l >= 0,\n              fin k,\n              k - l >= 129,\n              k == 128 + l + 1 + 1024 - ((l+129)%1024),\n              k%1024 == 0) => [l] -> [k]\npad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])\n\nCh : [64] -> [64] -> [64] -> [64]\nCh x y z = (x && y) ^ ((~x) && z)\n\nMaj : [64] -> [64] -> [64] -> [64]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nSIGMA0 : [64] -> [64]\nSIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)\n\nSIGMA1 : [64] -> [64]\nSIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)\n\nsigma0 : [64] -> [64]\nsigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)\n\nsigma1 : [64] -> [64]\nsigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)\n\nH0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]\n\nK = [\n0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n]\n\nproperty testVector1 x = sha512 0xfd2203e467574e834ab07c9097ae164532f24be1eb5d88f1af7748ceff0d2c67a21f4e4097f9d3bb4e9fbf97186e0db6db0100230a52b453d421f8ab9c9a6043aa3295ea20d2f06a2f37470d8a99075f1b8a8336f6228cf08b5942fc1fb4299c7d2480e8e82bce175540bdfad7752bc95b577f229515394f3ae5cec870a4b2f8 == 0xa21b1077d52b27ac545af63b32746c6e3c51cb0cb9f281eb9f3580a6d4996d5c9917d2a6e484627a9d5a06fa1b25327a9d710e027387fc3e07d7c4d14c6086cc\n```"}]}
{"filename":"cryptol\/rust\/cry-ffi\/Example.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define Cryptol properties for the Example module that specify type-correct round-trip behavior for each foreign abstract test_* function (e.g., identity or simple invariants) over their inputs and outputs, suitable for use as verification targets for an FFI implementation."},{"role":"assistant","content":"```cryptol\nmodule Example where\n\nimport Float\n\nnewtype N = { unN : [8] }\n\nforeign abstract test_bool : Bit -> Bit\nforeign abstract test_u8 : [8] -> [8]\nforeign abstract test_u16 : [16] -> [16]\nforeign abstract test_u32 : [32] -> [32]\nforeign abstract test_u64 : [64] -> [64]\nforeign abstract test_u128 : [128] -> [128]\nforeign abstract test_i8 : [8] -> [8]\nforeign abstract test_i16 : [16] -> [16]\nforeign abstract test_i32 : [32] -> [32]\nforeign abstract test_i64 : [64] -> [64]\nforeign abstract test_i128 : [128] -> [128]\nforeign abstract test_integer : Integer -> Integer\nforeign abstract test_rational : Rational -> Rational\nforeign abstract test_float : Float32 -> Float32\nforeign abstract test_double : Float64 -> Float64\nforeign abstract test_array_16_u8 : [16][8] -> [16][8]\nforeign abstract test_record0 : {} -> {}\nforeign abstract test_record1_u8 : { x : [8] } -> { x : [8] }\nforeign abstract test_record2_u8_u16 : { x : [8], y : [16] } -> { x : [8], y : [16] }\nforeign abstract test_tuple0 : () -> ()\nforeign abstract test_tuple2_u8_u16 : ([8], [16]) -> ([8], [16])\nforeign abstract test_newtype_u8 : N -> N\nforeign abstract test_option_u8 : Option [8] -> Option [8]\nforeign abstract test_result_u16_u32 : Result [16] [32] -> Result [16] [32]\nforeign abstract test_two_u8_args : [8] -> [8] -> [8]\nforeign abstract test_two_u128_res : [128] -> ([128], [128])\nforeign abstract test_z7 : Z 7 -> Z 7\nforeign abstract test_param : {n} (fin n, n >= 1) => Z n\n```"}]}
{"filename":"cryptol\/tests\/modsys\/T007.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines submodule F parameterized over a finite type n and value x, defines submodule I instantiating n = 8 and x = 2, and then defines and imports submodule M as F instantiated with I, including y = x + 11."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type n : #\n    x      : [n]\n    type constraint (fin n, n >= 4)\n\n  y : [n]\n  y = x + 11\n\nsubmodule I where\n  type n = 8\n  x = 2\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/enum\/CheckEnumPartialError.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the enums `Maybe a` and `Foo`, the functions `maybeMapBad1`, `maybeMapBad2`, `fooBad1`, and `fooGood`, and includes properties or checks that demonstrate the incomplete pattern matches in the `Bad` functions cause partiality or non-exhaustive pattern errors."},{"role":"assistant","content":"```cryptol\nenum Maybe a = Nothing | Just a\n\nmaybeMapBad1 : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMapBad1 f m =\n  case m of\n    Just x -> Just (f x)\n\nmaybeMapBad2 : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMapBad2 f m =\n  case m of\n    Nothing -> Nothing\n\nenum Foo = A | B | C\n\nfooBad1 : Foo -> ()\nfooBad1 f =\n  case f of\n    A -> ()\n\nfooGood : Foo -> ()\nfooGood f =\n  case f of\n    A -> ()\n    _ -> ()\n```"}]}
{"filename":"cryptol\/tests\/enum\/CheckProveEnum.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module defining the enums Maybe, Either, Foo, and Letter, with their map and equality functions, and properties maybeMapProp, eitherMapProp, fooMapProp, and letterRotateProp that verify the given composition\/rotation equalities for all inputs."},{"role":"assistant","content":"```cryptol\nenum Maybe a = Nothing | Just a\n\nmaybeEqual : {a} (Eq a) => Maybe a -> Maybe a -> Bit\nmaybeEqual m1 m2 =\n  case m1 of\n    Just x1 ->\n      case m2 of\n        Just x2 -> x1 == x2\n        Nothing -> False\n    Nothing ->\n      case m2 of\n        Just x2 -> False\n        Nothing -> True\n\nmaybeMap : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMap f m =\n  case m of\n    Just x  -> Just (f x)\n    Nothing -> Nothing\n\nmaybeMapProp : Maybe [8] -> Bit\nproperty maybeMapProp m =\n  maybeEqual\n    (maybeMap (\\x -> x + 1) (maybeMap (\\x -> x + 1) m))\n    (maybeMap (\\x -> x + 2) m)\n\nenum Either a b = Left a | Right b\n\neitherEqual : {a, b} (Eq a, Eq b) => Either a b -> Either a b -> Bit\neitherEqual e1 e2 =\n  case e1 of\n    Left x1 ->\n      case e2 of\n        Left x2  -> x1 == x2\n        Right y2 -> False\n    Right y1 ->\n      case e2 of\n        Left x2  -> False\n        Right y2 -> y1 == y2\n\neitherMapLeft : {a, a', b} (a -> a') -> Either a b -> Either a' b\neitherMapLeft f e =\n  case e of\n    Left x  -> Left (f x)\n    Right y -> Right y\n\neitherMapRight : {a, b, b'} (b -> b') -> Either a b -> Either a b'\neitherMapRight g e =\n  case e of\n    Left x  -> Left x\n    Right y -> Right (g y)\n\neitherMapBoth : {a, a', b, b'} (a -> a') -> (b -> b') -> Either a b -> Either a' b'\neitherMapBoth f g e =\n  case e of\n    Left x  -> Left (f x)\n    Right y -> Right (g y)\n\neitherMapProp : Either [8] [8] -> Bit\nproperty eitherMapProp e =\n  eitherEqual\n    (eitherMapLeft (\\x -> x + 1) (eitherMapRight (\\y -> y + 1) e))\n    (eitherMapBoth (\\x -> x + 1) (\\y -> y + 1) e)\n\nenum Foo a = Bar | Baz | Quux | Fred [8] a\n\nfooEqual : {a} (Eq a) => Foo a -> Foo a -> Bit\nfooEqual f1 f2 =\n  case f1 of\n    Bar ->\n      case f2 of\n        Bar        -> True\n        Baz        -> False\n        Quux       -> False\n        Fred y1 y2 -> False\n    Baz ->\n      case f2 of\n        Bar        -> False\n        Baz        -> True\n        Quux       -> False\n        Fred y1 y2 -> False\n    Quux ->\n      case f2 of\n        Bar        -> False\n        Baz        -> False\n        Quux       -> True\n        Fred y1 y2 -> False\n    Fred x1 x2 ->\n      case f2 of\n        Bar        -> False\n        Baz        -> False\n        Quux       -> False\n        Fred y1 y2 -> (x1 == y1) \/\\ (x2 == y2)\n\nfooMap : {a, b} (a -> b) -> Foo a -> Foo b\nfooMap f ff =\n  case ff of\n    Bar      -> Bar\n    Baz      -> Baz\n    Quux     -> Quux\n    Fred x y -> Fred x (f y)\n\nfooMapProp : Foo [8] -> Bit\nproperty fooMapProp f =\n  fooEqual\n    (fooMap (\\x -> x + 1) (fooMap (\\x -> x + 1) f))\n    (fooMap (\\x -> x + 2) f)\n\nenum Letter = A | B | C\n\nletterEqual : Letter -> Letter -> Bit\nletterEqual l1 l2 =\n  case l1 of\n    A ->\n      case l2 of\n        A -> True\n        B -> False\n        C -> False\n    B ->\n      case l2 of\n        A -> False\n        B -> True\n        C -> False\n    C ->\n      case l2 of\n        A -> False\n        B -> False\n        C -> True\n\nletterRotate : Letter -> Letter\nletterRotate l =\n  case l of\n    A -> B\n    B -> C\n    C -> A\n\nletterRotateProp : Letter -> Bit\nproperty letterRotateProp l =\n  letterEqual l (letterRotate (letterRotate (letterRotate l)))\n```"}]}
{"filename":"cryptol\/tests\/parser\/tuples-records.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the same tuple and record constants (including nested and empty variants) in a Cryptol module, preserving their structure and values exactly as given."},{"role":"assistant","content":"```cryptol\ntuple           = (0xFF, 0xFF)\nnested_tuple1   = (0xFF, (0xFF,0xFF))\nnested_tupel2   = ((0xFF,0xFF), 0xFF)\nempty_tuple     = ()\n\nrecord          = { x = 0xFF, y = 0xFF }\nnested_record   = { x = 0xFF, y = { x = 0xFF, y = 0xFF }}\nempty_records   = {}\n```"}]}
{"filename":"cryptol\/tests\/parser\/docs.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the same values, type synonym, infix operator, and property as in the given snippet, ensuring `property test4 x = (x : Bit)` type-checks for all `x` and that the operator `(++)` has the specified behavior and associativity."},{"role":"assistant","content":"```cryptol\ntest1 : Bit\ntest1 = True\n\ntest2 = True\n\ntest3 x = x\n\nproperty test4 x = (x : Bit)\n\ninfixl 5 ++\n\n(++) : {a} a -> a -> a\nx ++ _ = x\n\nprivate test5 = ()\n\ntype Foo = ()\n```"}]}
{"filename":"cryptol\/tests\/parser\/T437.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the functions `mk_buggy_fib_no_init`, `generate`, the infix operator `$`, and the sequences `foo` and `bar` with the given types and behaviors, including the self-referential definition of `foo` using `generate` and function application."},{"role":"assistant","content":"```cryptol\nmk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n  \/\/ Change output when state has magic value.\n  fn' = fn + if k == magic then 1 else 0\n\ngenerate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. n-1] ]\n\ninfixl 1 $\nf $ x = f x\n\nfoo : [10][4]\nfoo = generate $ \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n\nbar : [10][4]\nbar = generate \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n```"}]}
{"filename":"cryptol\/tests\/parser\/unary.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the expressions test1 and test2 as given, and add properties that assert each of these equalities holds for the 8-bit interpretations of bitwise complement (~) and arithmetic negation (-)."},{"role":"assistant","content":"```cryptol\ntest1 = (~ (5 : [8]) + 2) == (~ (5 : [8])) + 2\ntest2 = (- (5 : [8]) + 2) == (- (5 : [8])) + 2\n```"}]}
{"filename":"cryptol\/tests\/parser\/pat1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions f1 through f7 with the same pattern-matching behavior and types as below, ensuring they type-check correctly: f1 (x,y)=x; f2 (x # y)=x; f3 [x,y,z]=x+y+z; f4 {x=a,y=b}=a; f5 ((x:[8])#(y:[10]))=x#y:[10]; f6 (x#y:[10])=x; f7 (x#(y:[10]))=x."},{"role":"assistant","content":"```cryptol\nf1 (x,y) = x\nf2 (x # y) = x\nf3 [x,y,z] = x + y + z\nf4 {x = a, y = b } = a\nf5 ((x : [8]) # (y : [10])) = x # y : [10]\nf6 (x # y : [10]) = x\nf7 (x # (y : [10])) = x\n```"}]}
{"filename":"cryptol\/tests\/parser\/infix-1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the infix operators (++) and (**) in Cryptol with the given fixities and types, implementing (++) as byte-wise addition on [8] and (**) as ring multiplication for any Ring a, matching the provided semantics."},{"role":"assistant","content":"```cryptol\ninfixl 4 ++\ninfixl 5 **\n\n(++) : [8] -> [8] -> [8]\nx ++ y = x + y\n\n(**) : {a} (Ring a) => a -> a -> a\nx ** y = x * y\n```"}]}
{"filename":"cryptol\/tests\/parser\/applications.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the functions g, f and the constants app1 through app9 exactly as given, preserving their arithmetic expressions and applications so they can be typechecked and evaluated."},{"role":"assistant","content":"```cryptol\ng x   = x\nf x y = y\n\napp1 = g 0xFF\napp2 = f 0xFF 0xFF\napp3 = 0xFF + 0xFF\napp4 = 0x01 + 0x02 + 0x03\napp5 = 0x01 + 0x02 * 0x03\napp6 = 0x01 * 0x02 + 0x03\napp7 = 0x01 * g 0xFF + 0x02\napp8 = f (0x01 * g 0xFF + 0x02) 0xFF\napp9 = g (g 0xFF)\n```"}]}
{"filename":"cryptol\/tests\/regression\/twinmult.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In a Cryptol module that imports PrimeEC, define the projective point constant zro and the properties twin_mult_zro, twin_mult_zro1, twin_mult_zro2, twin_mult_same, and twin_mult_neg that specify correctness of ec_twin_mult against ec_mult, ec_add, ec_sub, and ec_negate on curve parameter 7."},{"role":"assistant","content":"```cryptol\nimport PrimeEC\n\nzro : ProjectivePoint 7\nzro = { x = 1, y = 1, z = 0 }\n\nproperty twin_mult_zro j k =\n  ec_equal`{7} (ec_twin_mult j zro k zro) zro\n\nproperty twin_mult_zro1 j k S =\n  ec_equal`{7} (ec_twin_mult j zro k S) (ec_mult k S)\n\nproperty twin_mult_zro2 j k S =\n  ec_equal`{7} (ec_twin_mult j S k zro) (ec_mult j S)\n\nproperty twin_mult_same j k S =\n  ec_equal`{7} (ec_twin_mult j S k S) (ec_add (ec_mult j S) (ec_mult k S))\n\nproperty twin_mult_neg j k S =\n  ec_equal`{7} (ec_twin_mult j S k (ec_negate S)) (ec_sub (ec_mult j S) (ec_mult k S))\n```"}]}
{"filename":"cryptol\/tests\/regression\/word-update.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines bit-update functions `update` and `updateEnd` on 16-bit words and properties `wordUpdate`, `wordUpdate2`, `wordUpdateEnd`, and `wordUpdateEnd2` that verify these functions match equivalent mask-based and index-based specifications for all `x:[16]`, `y:[8]`, and `b:Bit`."},{"role":"assistant","content":"```cryptol\nproperty wordUpdate (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> update x y b == if b then x || msk else x && ~msk\n\n where\n msk = 0b1000000000000000 >> y\n\nproperty wordUpdate2 (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> update x y b == x'\n\n where\n x' = [ if i == y then b else x@i | i <- [0 .. 15] ]\n\nproperty wordUpdateEnd (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> updateEnd x y b == if b then x || msk else x && ~msk\n\n where\n msk = 0b0000000000000001 << y\n\nproperty wordUpdateEnd2 (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> updateEnd x y b == x'\n\n where\n x' = [ if i == y then b else x!i | i <- reverse [0 .. 15] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/f2polytest.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines polynomial multiplication, division, and modulus over finite fields (pmult, pdiv, pmod) and properties asserting their equivalence to reference implementations Ref::pmult, Ref::pdiv, and Ref::pmod for several bit-width pairs."},{"role":"assistant","content":"```cryptol\nimport Cryptol::Reference as Ref\n\npmult_equiv : {u, v} (fin u, fin v) => [1+u] -> [1+v] -> Bit\npmult_equiv x y = pmult x y == Ref::pmult x y\n\npdiv_equiv : {u, v} (fin u, fin v) => [u] -> [v] -> Bit\npdiv_equiv x y = y == 0 \\\/ pdiv x y == Ref::pdiv x y\n\npmod_equiv : {u, v} (fin u, fin v) => [u] -> [1+v] -> Bit\npmod_equiv x y = y == 0 \\\/ pmod x y == Ref::pmod x y\n\nproperty mult3_9   = pmult_equiv`{3,9}\nproperty mult9_3   = pmult_equiv`{9,3}\nproperty mult8_8   = pmult_equiv`{8,8}\nproperty mult28_11 = pmult_equiv`{28,11}\nproperty mult32_32 = pmult_equiv`{32,32}\nproperty mult64_64 = pmult_equiv`{64,64}\n\nproperty div3_9   = pdiv_equiv`{3,9}\nproperty div9_3   = pdiv_equiv`{9,3}\nproperty div8_8   = pdiv_equiv`{8,8}\nproperty div28_11 = pdiv_equiv`{28,11}\nproperty div32_32 = pdiv_equiv`{32,32}\nproperty div64_64 = pdiv_equiv`{64,64}\n\nproperty mod3_9   = pmod_equiv`{3,9}\nproperty mod9_3   = pmod_equiv`{9,3}\nproperty mod8_8   = pmod_equiv`{8,8}\nproperty mod28_11 = pmod_equiv`{28,11}\nproperty mod32_32 = pmod_equiv`{32,32}\nproperty mod64_64 = pmod_equiv`{64,64}\n```"}]}
{"filename":"cryptol\/tests\/regression\/r01.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the polymorphic functions `any` and `all` in Cryptol, with the given types and list-comprehension-based implementations using bit-vector comparisons against `zero` and `~zero`, respectively."},{"role":"assistant","content":"```cryptol\nany : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nany f xs = [ f x | x <- xs ] != zero\n\nall : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nall f xs = [ f x | x <- xs ] == ~zero\n```"}]}
{"filename":"cryptol\/tests\/regression\/r05.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `unflatten : {r, w} (fin r, 5 * w >= r, fin w) => [r] -> [w][5]` in Cryptol so that it pads its input with zeros and groups it into `w` blocks of 5 bits using `groupBy` and concatenation with `zero`."},{"role":"assistant","content":"```cryptol\nunflatten : {r, w}\n            (fin r, 5 * w >= r, fin w)\n            => [r] -> [w][5]\nunflatten p = groupBy`{5}(p # zero)\n```"}]}
{"filename":"cryptol\/tests\/regression\/check22.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the functions `xtimes` and `gtimes` over 8-bit words using the AES Rijndael finite field with irreducible polynomial 0x1b, and a property `check22` that asserts [ gtimes (13, x) | x <- [1, 12, 192] ] == [13, 92, 183 ]."},{"role":"assistant","content":"```cryptol\nirred : [8]\nirred = 0x1b\nxtimes a = (if a ! (length a - 1) then a' ^ irred else a')\n  where a' = a << 1\n\ngtimes : ([8], [8]) -> [8]\ngtimes (a, b)\n  = (if b == 0 then 0 else xtimes (gtimes (a, b >> 1)) ^ a')\n      where a' = if b ! 0 then a else 0\n\ncheck22 = [ gtimes (13, x) | x <- [ 1, 12, 192 ] ] == [ 13, 92, 183 ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check23.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the function `pad` with the given constraints and constants `tmsg` and `out`, and includes the property `check23` that asserts `pad tmsg == out` holds."},{"role":"assistant","content":"```cryptol\npad : {msgLen, padding, contentLen, chunks}\n    ( fin msgLen\n    , fin padding\n    , contentLen == msgLen + 65\n    , chunks == (contentLen + 511) \/ 512\n    , 64 >= width msgLen\n    , padding == (512 - contentLen % 512) % 512\n    ) => [msgLen] -> [chunks * 512]\npad msg = msg # [True] # (zero:[padding]) # sz        where  sz : [64]\n             sz = (length msg):[64]\n\ntmsg : [4]\ntmsg = 13\nout : [512]\nout = 0xd8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004\ncheck23 = pad tmsg == out\n```"}]}
{"filename":"cryptol\/tests\/regression\/check09.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the mutually recursive streams ss and ls and the function keyX : [4][8] -> [7][32] as given, and a property check9 asserting check9a && check9b holds with the specified constant test vectors."},{"role":"assistant","content":"```cryptol\ninitS : [1][32]\ninitL : [1][32]\ninitS = [0]\ninitL = [0]\nss = [ (s + a + b) <<< 3   | s <- initS # ss\n\t                       | a <- [1] # ss\n\t                       | b <- [0] # ls ]\nls = [ (l + a + b) <<< (a + b)\n                        | l <- initL # ls\n\t\t                | a <- ss\n\t\t                | b <- [0] # ls ]\n\ncheck9a = (ss @@ [0 .. 3] == [ 0x00000008, 0x00004080, 0x00068c00, 0x00a22800 ])\n       && (ls @@ [0 .. 3] == [ 0x00000800, 0x00005080, 0x00072d00, 0x00b08200 ])\n\nkeyX : [4][8] -> [7][32]\nkeyX key = ss @@ [ 0 .. 6 ]\n  where\n    initS : [1][32]\n    initL : [1][32]\n    initS = [0]\n    initL = split (join key)\n    ss = [ (s + a + b) <<< 3\n                    | s <- initS # ss\n\t\t\t\t    | a <- [1] # ss\n\t\t\t\t    | b <- [0] # ls ]\n    ls = [ (l + a + b) <<< (a + b)\n                    | l <- initL # ls\n\t\t\t\t    | a <- ss\n\t\t\t\t    | b <- [0] # ls ]\n\ncheck9b = keyX (reverse \"abcd\") ==\n\t    [0x00000008, 0x1b134ba3, 0x11ae69b1, 0xb7b3f42f,\n             0xc9eb1fdc, 0x008b5f36, 0x8991bc8c]\n\ncheck9 = check9a && check9b\n```"}]}
{"filename":"cryptol\/tests\/regression\/check21.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `xtimes` over 8-bit values using the irreducible polynomial 0x1b and a property `check21` that asserts `[ xtimes y | y <- [1, 12, 192] ] == [2, 24, 155 ]` holds."},{"role":"assistant","content":"```cryptol\nirred : [8]\nirred = 0x1b\nxtimes a = (if a ! (length a - 1) then a' ^ irred else a')\n  where a' = a << 1\n\ncheck21 = [ xtimes y | y <- [ 1, 12, 192 ] ] == [ 2, 24, 155 ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the constant `check20` that evaluates to the Boolean result of adding two nested lists `[[[1,2],[3,4]]]` and `[[[5,6],[7,8]]]` and comparing the sum to `[[[6,8],[10,12]]]` using `==`."},{"role":"assistant","content":"```cryptol\ncheck20 = [ [ [ 1, 2 ], [ 3, 4 ] ] ]\n        + [ [ [ 5, 6 ], [ 7, 8 ] ] ]\n       == [ [ [ 6, 8 ], [ 10, 12 ] ] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check08.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the infinite sequences `qq` and `zs` as given, the value `check8`, and the property `prefix` asserting `qq @@ [0 .. 4] == [1, 2, 5, 12, 27]`, so that the property can be checked by a solver."},{"role":"assistant","content":"```cryptol\nqq = [ s + a + b | s <- [0] # qq\n\t          | a <- [1] # qq\n\t          | b <- [0] # zs ]\nzs : [inf][32]\nzs = [0...]\n\ncheck8 = qq @@ [0 .. 4] == [1, 2, 5, 12, 27]\n\nproperty prefix = qq @@ [0 .. 4] == [1, 2, 5, 12, 27]\n```"}]}
{"filename":"cryptol\/tests\/regression\/reference.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In a Cryptol module, import `Cryptol::Reference` as `Ref` and define the three properties `foldl_eq`, `scanl_eq`, and `iterate_eq` exactly as given so they can be checked for all valid inputs."},{"role":"assistant","content":"```cryptol\nimport Cryptol::Reference as Ref\n\nproperty foldl_eq (z:Integer) (xs:[10]Integer) =\n  foldl (-) z xs == Ref::foldl (-) z xs\n\nproperty scanl_eq (z:Integer) (xs:[10]Integer) =\n  scanl (-) z xs == Ref::scanl (-) z xs\n\nproperty iterate_eq (z:Integer) (i:[8]) =\n  (iterate (\\x -> x + 1) z)@i == (Ref::iterate (\\x -> x + 1) z)@i\n```"}]}
{"filename":"cryptol\/tests\/regression\/rec-update.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the record type T and the values f1 through f6 using record and sequence update syntax exactly as shown, ensuring type correctness and evaluating to the same resulting values."},{"role":"assistant","content":"```cryptol\ntype T = { x : [8], y : Bool }\n\nf1 = { x = 2, y = True } : T\nf2 = { f1 | x = 3 }\nf3 = { f2 | x = 4, y = False }\nf4 = { f3 | x -> x + 1 }\nf5 = [f1,f2,f3,f4]\nf6 = { f5 | x = [7,8,9,10] }\n```"}]}
{"filename":"cryptol\/tests\/regression\/check24.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `xor : {a} ([a], [a]) -> [a]` as bitwise inequality over two bitvectors and a constant `check24` that verifies for all 4-bit `x` and `y` that `xor` equals the built-in `(^)` operator, returning `~zero` when all comparisons hold."},{"role":"assistant","content":"```cryptol\nxor : {a} ([a], [a]) -> [a]\nxor (xs, ys) = [ x != y | x <- xs | y <- ys ]\n\ncheck24 = [ xor`{4} (x, y) == (x ^ y) | x <- [ 0 .. 15 ], y <- [ 0 .. 15 ] ] == ~zero\n```"}]}
{"filename":"cryptol\/tests\/regression\/primes.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the prime-modulus types p192, p224, p256, p384, p521, the functions z1prime, recip_correct, moddiv_eq over Z p, and properties verifying recip_correct and moddiv_eq for primes 17, 1021, and these NIST prime moduli."},{"role":"assistant","content":"```cryptol\nz1prime : {n} (prime n) => Z n\nz1prime = 1\n\nz1_2 = z1prime`{2}\nz1_3 = z1prime`{3}\nz1_17 = z1prime`{17}\nz1_2_17m1 = z1prime`{2^^17 - 1}\n\ntype p192 = 6277101735386680763835789423207666416083908700390324961279\ntype p224 = 26959946667150639794667015087019630673557916260026308143510066298881\ntype p256 = 115792089210356248762697446949407573530086143415290314195533631308867097853951\ntype p384 = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\ntype p521 = 6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151\n\nrecip_correct : {p} (prime p) => Z p -> Bool\nrecip_correct x = x == 0 \\\/ x * recip x == 1\n\nproperty recip_correct_17   = recip_correct`{17}\nproperty recip_correct_1021 = recip_correct`{1021}\nproperty recip_correct_p192 = recip_correct`{p192}\nproperty recip_correct_p224 = recip_correct`{p224}\nproperty recip_correct_p256 = recip_correct`{p256}\nproperty recip_correct_p384 = recip_correct`{p384}\nproperty recip_correct_p521 = recip_correct`{p521}\n\nmoddiv_eq : {p} (prime p, p >= 3) => Z p -> Z p -> Bool\nmoddiv_eq x y = y == 0 \\\/ (x \/. y) * y == x\n\nproperty moddiv_eq17   = moddiv_eq`{17}\nproperty moddiv_eq1021 = moddiv_eq`{1021}\n\nproperty moddiv_eq_p192 = moddiv_eq`{p192}\nproperty moddiv_eq_p224 = moddiv_eq`{p224}\nproperty moddiv_eq_p256 = moddiv_eq`{p256}\nproperty moddiv_eq_p384 = moddiv_eq`{p384}\nproperty moddiv_eq_p521 = moddiv_eq`{p521}\n```"}]}
{"filename":"cryptol\/tests\/regression\/bitshift.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the functions `shift`, `shift_alt`, the infinite zero stream `infZero`, and the property `shift_eq` asserting these two shift implementations are equivalent on 10-bit prefixes of an infinite zero-extended stream."},{"role":"assistant","content":"```cryptol\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n          fills = [bit]#(take fill)\n\nshift_alt : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift_alt fill bit = fills\n\twhere\n\t  fills = [bit]#(drop`{1} (fill >> 1))\n\ninfZero : [inf]Bit\ninfZero = [False] # infZero\n\nproperty shift_eq a b c d e = shift (take`{10} ([a,b,c,d]#infZero)) e\n                           == shift_alt (take`{10} ([a,b,c,d]#infZero)) e\n```"}]}
{"filename":"cryptol\/tests\/regression\/check27.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the constants and function `zeroBit`, `zeroTuple`, `zeroTuple3`, `zeroFun` and the property `check27` that checks they are all equal to the appropriate zero values as shown, so that `check27` holds for all inputs."},{"role":"assistant","content":"```cryptol\nzeroBit : Bit\nzeroBit = zero\n\nzeroTuple : ([8], [32])\nzeroTuple = zero\nzeroTuple3 : ([8], [32], [256])\nzeroTuple3 = zero\n\nzeroFun : [8] -> [16]\nzeroFun = zero\n\ncheck27 = (zeroBit == False)\n\t&& (zeroTuple == (0, 0)) && (zeroTuple3 == (0, 0, 0))\n\t&& ((0, 0) == zeroTuple) && ((0, 0, 0) == zeroTuple3)\n\t&& (zeroFun 13 == 0)\n```"}]}
{"filename":"cryptol\/tests\/regression\/check26.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions fst and snd for pairs and the values xy and xys, and then define the boolean properties check26a, check26b, check26c, and check26 that verify tuple projection and list-comprehension behavior as described."},{"role":"assistant","content":"```cryptol\nfst (x, y) = x\nsnd (x, y) = y\nxy = (13, 21)\ncheck26a = (fst xy == xy.0) && (snd xy == xy.1) &&\n\t   (fst xy == 13) && (snd xy == 21)\n\nxys = [ (x, y) | x <- [ 1 .. 10 ], y <- [ 2 .. 5 ] ]\ncheck26b = [ fst ixy | ixy <- xys ] ==\n\t   [ x | x <- [ 1 .. 10 ], y <- [ 2 .. 5 ] ]\ncheck26c = [ fst ixy == snd ixy | ixy <- xys ] == reverse 0x0000084210\n\ncheck26 = check26a && check26b && check26c\n```"}]}
{"filename":"cryptol\/tests\/regression\/check03.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `nats : [32] -> [inf][32]` as an infinite stream starting from a given 32-bit value, and define\/check the property `check3` that `(nats 0 @ 45 == 45) && (nats 45 @ 0 == 45)`."},{"role":"assistant","content":"```cryptol\nnats : [32] -> [inf][32]\nnats n = [n] # nats (n + 1)\n\ncheck3 = (nats 0 @ 45 == 45) && (nats 45 @ 0 == 45)\n```"}]}
{"filename":"cryptol\/tests\/regression\/rational_properties.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines a Rational type and proves the listed algebraic, order, and floor\/ceiling properties (QaddUnit, QaddComm, QaddAssoc, Qneg, QmulUnit, QmulComm, QmulAssoc, Qdistrib, Qrecip, QdivisionEquiv, QordEquiv1, QordEquiv2, QordTrans, QordIrreflexive, QordExclusive, Qtrichotomy, QordCompatible, QordPositive, Qdense, intDivDown, floorCorrect1, floorCorrect2, ceilingCorrect1, ceilingCorrect2) for all inputs."},{"role":"assistant","content":"```cryptol\nproperty QaddUnit (x : Rational) =\n  x + 0 == x\n\nproperty QaddComm (x:Rational) (y:Rational) =\n  x + y == y + x\n\nproperty QaddAssoc (x:Rational) (y:Rational) (z:Rational) =\n  x + (y + z) == (x + y) + z\n\nproperty Qneg (x: Rational) = x + negate x == 0\n\nproperty QmulUnit (x : Rational) =\n  x * 1 == x\n\nproperty QmulComm (x:Rational) (y:Rational) =\n  x * y == y * x\n\nproperty QmulAssoc (x:Rational) (y:Rational) (z:Rational) =\n  x * (y * z) == (x * y) * z\n\nproperty Qdistrib (x:Rational) (y:Rational) (z:Rational) =\n  x * (y + z) == x*y + x*z\n\nproperty Qrecip (x: Rational) = x == 0 \\\/ x * recip x == 1\n\nproperty QdivisionEquiv (x : Rational) (y : Rational) =\n  y == 0 \\\/ x \/. y == x * (recip y)\n\nproperty QordEquiv1 (x : Rational) (y : Rational) =\n  (x <= y) == ~(y < x)\n\nproperty QordEquiv2 (x : Rational) (y : Rational) =\n  (x <= y) == (x == y \\\/ x < y)\n\nproperty QordTrans (x : Rational) (y : Rational) (z : Rational) =\n  x < y ==> y < z ==> x < z\n\nproperty QordIrreflexive (x : Rational) =\n  ~(x < x)\n\nproperty QordExclusive (x : Rational) (y:Rational) =\n  ~(x < y) || ~(y < x) \n\nproperty Qtrichotomy (x : Rational) (y : Rational) =\n  x < y \\\/ x == y \\\/ x > y\n\nproperty QordCompatible (x : Rational) (y : Rational) (z:Rational) =\n  x < y ==> x+z < y+z\n\nproperty QordPositive (x : Rational) (y : Rational) =\n  0 < x ==> 0 < y ==> 0 < x*y\n\nproperty Qdense (x : Rational) (y : Rational) = x < y ==> x < mid \/\\ mid < y\n  where\n  mid = (x + y) \/. 2\n\nproperty intDivDown (x : Integer) (y:Integer) =\n  y == 0 \\\/ fromInteger (x \/ y) <= ratio x y\n\nproperty floorCorrect1 (x:Rational) =\n  fromInteger (floor x) <= x\n\nproperty floorCorrect2 (x:Rational) (y:Integer) =\n  fromInteger y <= x ==>\n  y <= floor x\n\nproperty ceilingCorrect1 (x:Rational) =\n  fromInteger (ceiling x) >= x\n\nproperty ceilingCorrect2 (x:Rational) (y:Integer) =\n  fromInteger y >= x ==>\n  y >= ceiling x\n```"}]}
{"filename":"cryptol\/tests\/regression\/check28.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the list `xs` of pairs and the value `check28` as a property-like boolean expression `[ x == y | (x,y) <- xs ] == ~zero` that can be checked by the solver."},{"role":"assistant","content":"```cryptol\nxs = [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7)]\ncheck28 = [ x==y | (x,y) <- xs ] == ~zero\n```"}]}
{"filename":"cryptol\/tests\/regression\/check14.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `swab` that reverses each 4-element sequence in a list, and a property `check14` asserting that `swab [[0, 1, 2, 3], [4, 5, 6, 7]] == [[3, 2, 1, 0], [7, 6, 5, 4]]` holds."},{"role":"assistant","content":"```cryptol\nswab xxs = [ [d, c, b, a]\n           | [a, b, c, d] <- xxs\n           ]\n\ncheck14 = swab [[0, 1, 2, 3], [4, 5, 6, 7]] == [[3, 2, 1, 0], [7, 6, 5, 4]]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check11.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `check11` that constructs a sequence `zz = [0 .. 99]`, forms `qq = zz @@ ([0 .. 0xffffffff] : [_][32])`, then `ww = qq @@ [0 .. 99]`, and returns the boolean result `zz == ww`."},{"role":"assistant","content":"```cryptol\ncheck11 = zz == ww\n  where\n    zz = [0 .. 99]\n    qq = zz @@ ([0 .. 0xffffffff] : [_][32])\n    ww = qq @@ [0 .. 99]\n```"}]}
{"filename":"cryptol\/tests\/regression\/FloatTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that imports `Float` and defines the Small, Medium, and Large floating-point types, along with the given floating-point round-trip, equality, ordering, and rational-conversion properties, so they can be checked by a SAT\/SMT solver."},{"role":"assistant","content":"```cryptol\nmodule FloatTests where\n\nimport Float\n\nsection : {n} fin n => [n][8] -> [78][8]\nsection x = \"-- \" # take`{min 60 n} x # repeat '-'\n\ntype Small  = Float 3 2\ntype Medium = Float64\ntype Large  = Float 60 5000\n\nproperty roundTrip x  = fpFromBits (fpToBits x) =.= x\n\nroundTrip2 : {e : #, p : #} (fin e, fin p, ValidFloat e p) => [e + p] -> Bool\nproperty roundTrip2 x = fpToBits num == x \\\/ num =.= fpNaN\n                          where num = fpFromBits x : Float e p\nproperty eqRefl1 x    = x =.= x\nproperty eqRefl2 x    = x == x \\\/ x =.= fpNaN\nproperty eqProp x y   = ~(x == y) \\\/\n                         (x =.= y \\\/ x =.= fpNaN\n                                  \\\/ y =.= fpNaN\n                                  \\\/ (x =.=  0.0 \/\\ y =.= -0.0)\n                                  \\\/ (x =.= -0.0 \/\\ y =.=  0.0)\n                         )\nproperty leqRefl x    = x <= x \\\/ x =.= fpNaN\n\nroundTripRational : {e,p} (fin e, fin p, ValidFloat e p) => Float e p -> Bool\nproperty roundTripRational x =\n  ~(fpIsFinite x) \\\/\n  (fpFromRational rne (fpToRational x) =.= x) \\\/\n  (x =.= fpNegZero)\n```"}]}
{"filename":"cryptol\/tests\/regression\/specialize.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define module `specialize` with a polymorphic function `f : {a, b} (a, b) -> (a, b)` and a function `top` that specializes `f` to `{Bit, Bit}` and applies it to a pair of bits."},{"role":"assistant","content":"```cryptol\nmodule specialize where\n\ntop (x, y) = f`{Bit,Bit} (x, y)\n\nf : {a, b} (a, b) -> (a, b)\nf (x, y) = (x, y)\n```"}]}
{"filename":"cryptol\/tests\/regression\/poly.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module defining a polymorphic polynomial type `Poly n a`, functions `evalPoly`, `polyConst`, `polyAdd`, `polyMul`, and properties `polySquare`, `polyAddEval`, and `polyMulEval` that verify polynomial evaluation, addition, and multiplication behave as expected over `Integer` and any `Ring a`."},{"role":"assistant","content":"```cryptol\nnewtype Poly n a = { coeffs : [n+1]a }\n\nevalPoly : {n, a} (fin n, Ring a) => Poly n a -> a -> a\nevalPoly p x = foldl (+) zero terms\n  where\n    terms = [ c*a | c <- p.coeffs | a <- xs ]\n    xs    = [fromInteger 1]#[ x*a | a <- xs ]\n\npolyConst : {n, a} (fin n, Ring a) => a -> Poly n a\npolyConst a = Poly { coeffs = [a]#zero }\n\npolyAdd : {n, a} (fin n, Ring a) => Poly n a -> Poly n a -> Poly n a\npolyAdd p1 p2 = Poly { coeffs = zipWith (+) p1.coeffs p2.coeffs }\n\npolyMul : {n1, n2, a} (fin n1, fin n2, Ring a) =>\n  Poly n1 a -> Poly n2 a -> Poly (n1+n2) a\npolyMul p1 p2 = foldl polyAdd (polyConst zero) ps\n  where\n    ps : [n1+1](Poly (n1+n2) a)\n    ps@i = Poly{ coeffs = scaleAndShift i }\n\n    scaleAndShift i =\n      ([ p1.coeffs@i * c | c <- p2.coeffs ] # zero) >> i\n\nproperty polySquare (x:Integer) =\n  evalPoly (Poly { coeffs = [0,0,1] }) x == x * x\n\nproperty polyAddEval x (p1:Poly 5 Integer) (p2:Poly 5 Integer) =\n  evalPoly (polyAdd p1 p2) x == evalPoly p1 x + evalPoly p2 x\n\nproperty polyMulEval x (p1:Poly 5 Integer) (p2:Poly 5 Integer) =\n  evalPoly (polyMul p1 p2) x == evalPoly p1 x * evalPoly p2 x\n```"}]}
{"filename":"cryptol\/tests\/regression\/check12.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `sums` implementing the recursive cumulative sum as given, and define the property `check12` that asserts `sums ([0 .. 9] : [_][32])` equals `[0, 1, 3, 6, 10, 15, 21, 28, 36, 45]`."},{"role":"assistant","content":"```cryptol\nsums xs = ys\n  where ys = [ x + y | x <- xs | y <- [0] # ys ]\n\ncheck12 = sums ([0 .. 9] : [_][32]) == [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check06.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the sequences `onetwos`, `twoones`, `onesytwosy`, and the property `check6` which asserts that `onesytwosy @@ [0 .. 3]` equals `[[1,2],[2,1],[1,2],[2,1]]` for all valid indices."},{"role":"assistant","content":"```cryptol\nonetwos = [1] # twoones\ntwoones = [2] # onetwos\nonesytwosy = [ [one, two] | one <- onetwos | two <- twoones ]\n\ncheck6 = onesytwosy @@ [0 .. 3] == [ [1, 2], [2, 1], [1, 2], [2, 1] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check13.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions `ick : [1][8] -> [8]` and `uck : [8][1] -> [8]`, and a property `check13` asserting `(ick (split 150) == 150) && (uck (split 150) == 150)`."},{"role":"assistant","content":"```cryptol\nick : [1][8] -> [8]\nick [x] = x\n\nuck : [8][1] -> [8]\nuck [a, b, c, d, e, f, g, h] = a # b # c # d # e # f # g # h\n\ncheck13 = (ick (split 150) == 150) && (uck (split 150) == 150)\n```"}]}
{"filename":"cryptol\/tests\/regression\/allsat.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the function `f : (Integer, Integer, Integer) -> Bit` which returns `True` exactly when all three integer arguments are in the inclusive range 1 to 15."},{"role":"assistant","content":"```cryptol\nf : (Integer, Integer, Integer) -> Bit\nf (x, y, z) =  inRange x && inRange y && inRange z\n  where inRange v = (1 <= v) && (v <= 15)\n```"}]}
{"filename":"cryptol\/tests\/regression\/negshift.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions negLeftShift, negRightShift, negLeftRotate, negRightRotate, and negSshr as given, and properties nls1\u20134, nrs1\u20134, nlr1\u20134, nrr1\u20134, and nsshr1\u20132 that verify these shift\/rotate identities for the specified type instantiations."},{"role":"assistant","content":"```cryptol\nnegLeftShift : {n, a} (fin n, Zero a, Cmp a) => [n]a -> Integer -> Bit\nnegLeftShift xs i = xs << i == xs >> (negate i)\n\nnegRightShift : {n, a} (fin n, Zero a, Cmp a) => [n]a -> Integer -> Bit\nnegRightShift xs i = xs >> i == xs << (negate i)\n\nnegLeftRotate : {n, a} (fin n, Cmp a) => [n]a -> Integer -> Bit\nnegLeftRotate xs i = xs <<< i == xs >>> (negate i)\n\nnegRightRotate : {n, a} (fin n, Cmp a) => [n]a -> Integer -> Bit\nnegRightRotate xs i = xs >>> i == xs <<< (negate i)\n\nnegSshr : {n} (fin n, n >= 1) => [n] -> Integer -> Bit\nnegSshr xs i = i < 0 ==> xs >>$ i == xs << (negate i)\n\nproperty nls1 = negLeftShift`{8, Bit}\nproperty nls2 = negLeftShift`{32, Bit}\nproperty nls3 = negLeftShift`{8, Integer}\nproperty nls4 = negLeftShift`{8, [32]}\n\nproperty nrs1 = negRightShift`{8, Bit}\nproperty nrs2 = negRightShift`{32, Bit}\nproperty nrs3 = negRightShift`{8, Integer}\nproperty nrs4 = negRightShift`{8, [32]}\n\nproperty nlr1 = negLeftRotate`{8, Bit}\nproperty nlr2 = negLeftRotate`{32, Bit}\nproperty nlr3 = negLeftRotate`{8, Integer}\nproperty nlr4 = negLeftRotate`{8, [32]}\n\nproperty nrr1 = negRightRotate`{8, Bit}\nproperty nrr2 = negRightRotate`{32, Bit}\nproperty nrr3 = negRightRotate`{8, Integer}\nproperty nrr4 = negRightRotate`{8, [32]}\n\nproperty nsshr1 = negSshr`{8}\nproperty nsshr2 = negSshr`{32}\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T06.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `T06` that uses an interface submodule `I` with a numeric type `N`, defines submodules `N1`, `C`, `B`, and `A` with the same structure as given, ensuring that submodule instantiation and interface imports type-check correctly."},{"role":"assistant","content":"```cryptol\nmodule T06 where\n\ninterface submodule I where\n  type N : #\n\nsubmodule N1 where\n  type N = 1\n\nsubmodule C where\n  import interface submodule I\n\n  lost = ()\n\nsubmodule B where\n  import interface submodule I\n  submodule C_ = submodule C { submodule N1 }\n\nsubmodule A = submodule B { submodule N1 }\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T10.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `T10` that defines public and private properties `p`, `q`, `r`, `s`, `t` of type `Bit` in nested submodules, including a parameterized submodule `F` with type parameter `N` and an instantiated submodule `F1` where `N = 1`, all properties equal to `True`."},{"role":"assistant","content":"```cryptol\nmodule T10 where\n\np : Bit\nproperty p = True\n\nsubmodule M where\n  q : Bit\n  property q = True\n\n  private\n    r : Bit\n    property r = True\n\nsubmodule F where\n  parameter\n    type N : #\n\n  s : Bit\n  property s = True\n\n  private\n    t : Bit\n    property t = True\n\nsubmodule F1 = submodule F where type N = 1\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T02.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module equivalent to `T02` with submodule `F` parameterized by a finite type `n >= 2`, a private constant `c : Z n = 1`, a property `p x = c + x == x + c`, its instantiation `F7` with `n = 7`, and function `f : Integer -> Integer` defined as `x + x`."},{"role":"assistant","content":"```cryptol\nmodule T02 where\n\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n, n >= 2)\n\n  private\n    c : Z n\n    c = 1\n\n  p x = c + x == x + c\n\nsubmodule F7 = submodule F where\n  type n = 7\n\nf : Integer -> Integer\nf x = x + x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue314.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `f : {a} (fin a, a >= 2) => [a][8] -> [8]` that returns the first element of a zero-initialized array `ys : [a\/2][8]`, as in the given snippet."},{"role":"assistant","content":"```cryptol\nf : {a} (fin a, a>=2) => [a][8] -> [8]\nf xs = ys!0\n where\n  ys : [a\/2][8]\n  ys = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1796.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define properties that prove the functions exhaustive1, exhaustive1Reordered1, exhaustive1Reordered2, exhaustive2, and exhaustive3 are total and that all the reordered exhaustive1 variants are extensionally equal for all type parameters w and inputs x."},{"role":"assistant","content":"```cryptol\nexhaustive1 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1 x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n\nexhaustive1Reordered1: {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1Reordered1 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n\nexhaustive1Reordered2 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1Reordered2 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n\nexhaustive2 : {w} [2 ^^ w] -> [2 ^^ w]\nexhaustive2 x\n  | (2 ^^ w) == 1 => ~ x\n  | (2 ^^ w) > 1 => x\n\nexhaustive3 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive3 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue670.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the custom infix type operator `(+++ )` as `x +++ y = x - y` and write the type signatures and definitions for the constants `g` and `h` so that the expressions `[6 +++ 2 +++ 1]` and `[6 +++ (2 +++ 1)]` type-check correctly."},{"role":"assistant","content":"```cryptol\ntype x +++ y = x-y\n\ng : [6 +++ 2 +++ 1]\ng = 2\n\nh : [6 +++ (2 +++ 1)]\nh = 9\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue116.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the tuple `t` and the property `bug116fixed` that checks `(t.1.value == t.1.value) \/\n(t.1.key == t.1.key)` holds, matching the given structure and field names."},{"role":"assistant","content":"```cryptol\nt = (0x1, { key = 4, value = \"goodbye\"})\n\nbug116fixed = (t.1.value == t.1.value) \/\\ (t.1.key == t.1.key)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `copy : [inf] -> [inf]` as specified, and define the property `ok` asserting that `copy ([True] # zero) @ 0` holds."},{"role":"assistant","content":"```cryptol\ncopy : [inf] -> [inf]\ncopy ([b] # x) = if b then [True] # copy x else [False] # copy x\n\nproperty ok = copy ([True] # zero) @ 0\n```"}]}
{"filename":"cryptol\/tests\/issues\/T1439.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module equivalent to `T` that defines polymorphic functions over 1-element sequences and pairs, an interface submodule with a type parameter `n`, a submodule `F` using that type, a concrete instantiation `P1` with `n = 1`, and a submodule alias `S` importing `F` with `P1`."},{"role":"assistant","content":"```cryptol\nmodule T where\n    f : {n} [1][n] -> [n]\n  f [x] = x\n\n  p : {a,b} (a,b) -> a\n  p (x,_) = x\n\n  interface submodule I where\n    type n : #\n\n  submodule F where\n    import interface submodule I\n\n    h : [1][n] -> [n]\n    h [x] = x\n\n    g : {m} [1][m] -> [m]\n    g [x] = x\n\n    q, q1, q2 : {b} (b,_) -> b\n    q (x,_) = x\n\n    q1 x = x.0\n    q2 x = y\n      where\n      (y,z) = x\n\n  submodule P1 where\n    type n = 1\n\n  submodule S = submodule F { submodule P1 }\n\n  import submodule S\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue058.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions `some : {n} [n] -> Bit`, `last : {n, a} (n >= 1) => [n]a -> a`, and `pad : {n} [n] -> [inf]` with the given semantics, matching these exact types and behaviors."},{"role":"assistant","content":"```cryptol\nsome : {n} [n] -> Bit\nsome x = x != 0\n\nlast : {n, a} (n >= 1) => [n]a -> a\nlast xs = xs ! 0\n\npad : {n} [n] -> [inf]\npad x = x # zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue312.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define functions `f : [16] -> [16]` and `g : [16] -> [16]` as `f x = 3 * x` and `g x = x + x + x`, and a property `f_g` asserting `(f === g)` for all 16-bit inputs."},{"role":"assistant","content":"```cryptol\nf : [16] -> [16]\nf x = 3 * x\n\ng : [16] -> [16]\ng x = x + x + x\n\nproperty f_g = (f === g)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue662.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification defining rational numbers as integer pairs and prove the integer division properties `divRoundsDown`, `divEuclidean`, and `modAbs` as given, ensuring they hold for all integer inputs `x` and `y`."},{"role":"assistant","content":"```cryptol\ntype Q = (Integer, Integer)\n\ntoQ : Integer -> Integer -> Q\ntoQ a b =\n  if b == 0 then error \"divide by 0\" else\n  if b < 0 then (negate a, negate b) else (a, b)\n\nleQ : Q -> Q -> Bit\nleQ (a,b) (c,d) = a*d <= b*c\n\nintToQ : Integer -> Q\nintToQ x = (x, 1)\n\nabs : Integer -> Integer\nabs x = if x < 0 then negate x else x\n\nproperty divRoundsDown (x : Integer) (y : Integer) =\n  y == 0 \\\/ leQ (intToQ ( x \/ y )) (toQ x y)\n\nproperty divEuclidean (x : Integer) (y : Integer) =\n  y == 0 \\\/ y * (x \/ y) + x % y == x\n\nproperty modAbs (x : Integer) (y : Integer) =\n  y == 0 \\\/ abs (x % y) < abs y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue78.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `unique : {a,b} (fin a, fin b, a>=1) => [a][b] -> Bit` that returns True iff all elements in the input sequence are distinct, matching the recursive definition using `exist` as given."},{"role":"assistant","content":"```cryptol\nunique : {a,b} (fin a, fin b, a>=1) => [a][b] -> Bit\nunique xs = [ exist x (i+1) | x <- xs | i <- [0..(a-1)] ] == 0\n  where exist : [b] -> [width a] -> Bit\n        exist x i = if(i>=`a) then False\n                    else if(x==(xs@i)) then True\n                    else exist x (i+1)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue138.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the constants `dwn` and `dwn'` of type `[16][4]` and the function `take_some : {n,k,t} (n >= k) => [n]t -> [k]t` with the same recursive list-comprehension behavior as described, suitable for testing termination and type-checking."},{"role":"assistant","content":"```cryptol\ndwn: [16][4]\ndwn = [ 1+d | d <- tail dwn ] # [0]\n\ndwn': [16][4]\ndwn' = [ 1+(dwn' @ i) | i <- [1 .. 15] ] # [0]\n\ntake_some: {n,k,t} (n>=k) => [n]t -> [k]t\ntake_some xs = takes where takes = [ x | x <- xs | _ <- takes ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue851.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the types, functions, and property shown, and verify that property `problem` holds for all inputs `p`."},{"role":"assistant","content":"```cryptol\ntype base t = { zero: t }\n\nB: base Bool\nB = { zero = False }\n\nfoo: {t,k} (fin k) => base t -> [k]t\nfoo b = repeat b.zero\n\nbar: {t,k} (fin k, k>=1) => [k]t -> [k]t -> [k]t -> [k]t\nbar p q m = p\n\nbaz: {k,t} (fin k, k >= 1) => [k]t -> [k]t -> [k]t\nbaz p q = q\n\nproperty problem p =\n  p != foo B ==> bar p (baz p 0x03) 0x03 == foo B\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1590.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a module hierarchy with a parameterized submodule `F`, a constrained submodule `M = submodule F where x = False`, import `M`, and define `foo : U` where `U` is a type alias for `F::T`, ensuring the `newtype` and import resolution behave as in the code."},{"role":"assistant","content":"```cryptol\nmodule Main where\n\nsubmodule F where\n  parameter\n    x : Bit\n  newtype T = { bit : Bit }\n  type U = T\n\nsubmodule M = submodule F where x = False\n\nimport submodule M\n\nfoo : U\nfoo = T { bit = True }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1802.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the parameterized types `loglogw`, `logw`, `w` and the function `csum : [32][logw] -> [logw+5]` computing `sum [`w - 1 - zext msgi | msgi <- msg]` under the constraint 1 <= loglogw <= 3."},{"role":"assistant","content":"```cryptol\nmodule T1802 where\n\nparameter\n  type loglogw : #\n  type constraint (loglogw >= 1, loglogw <= 3)\n\ntype logw = 2^^loglogw\ntype w = 2^^logw\n\ncsum : [32][logw] -> [logw+5]\ncsum msg = sum [`w - 1 - zext msgi | msgi <- msg]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue962a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the polymorphic functions `f`, `g`, `h`, `i`, and `j` with the given type constraints and expressions, ensuring that type applications and record field selections are correctly typed and accepted by the type checker."},{"role":"assistant","content":"```cryptol\nf : {a, b} (fin a) => [a]b -> (Bit, [a]b)\nf x = (True, x)\n\ng : {a,b} (fin a) => [a]b -> [a]b\ng x = (f`{a=a} x).1\n\nh = f.1\n\ni : {a} (fin a) => [a] -> [a]\ni = f`{a=a}.1\n\nj : {a} (fin a) => [a]{ fld : Integer } -> [a]Integer\nj = f`{a=a,b={fld : Integer}}.1.fld\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue160.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the rotation and shift operations used here and includes properties thm1\u2013thm6 exactly as stated, so they can be checked\/proved by Cryptol\u2019s solvers."},{"role":"assistant","content":"```cryptol\nthm1 : [16] -> Bit\nproperty thm1 x = (x <<< 16 == x) && (x >>> 16 == x)\n\nthm2 : [16] -> [16] -> Bit\nproperty thm2 x i = x >>> i == x >>> (i && 0x000f)\n\nthm3 : [15] -> [8] -> Bit\nproperty thm3 x i = x <<< i == x <<< (i % 15)\n\nthm4 : [15] -> [15] -> Bit\nproperty thm4 x i = x <<< i >>> i == x\n\nthm5 : [15] -> [3] -> Bit\nproperty thm5 x i = x <<< i >>> i == x\n\nthm6 : [8] -> [4] -> [4] -> Bit\nproperty thm6 x i j = x <<< i >>> j == x <<< (i - j)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue148.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that specifies the Salsa20 key expansion function `Salsa20_expansion : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]`, handling both 16-byte and 32-byte keys using the appropriate \"expand 16-byte k\" and \"expand 32-byte k\" constants."},{"role":"assistant","content":"```cryptol\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(k, n) = z\n  where\n    [s0, s1, s2, s3] = if (`a == 2) then split(\"expand 32-byte k\")\n                                    else split(\"expand 16-byte k\")\n    k1 = take`{16}(k#zero)\n    k2 = drop`{16}(zero#k)\n    x = s0 # k1 # s1 # n # s2 # k2 # s3\n    z = x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue389.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the Cryptol function `pad : {n, m, b} (64>=width(n), b==512-((n+65)%512), m==65+n+b) => [n] -> [m]` that appends a '1' bit, zero padding, and a 64-bit length field, and export `test = pad` for testing."},{"role":"assistant","content":"```cryptol\npad : {n, m, b} (64>=width(n), b==512-((n+65)%512), m==65+n+b) => [n]->[m]\npad message = (message#[True])#(0:[b])#sz\n     where\n                sz : [64]\n                sz = length message\n\ntest = pad\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue177.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `issue177` that imports `issue177A`, `issue177B` as `B`, and `issue177C` as `C`, declares `type Byte = [8]`, and defines constants `w : Byte = zero`, `x : Word16 = zero`, `y : B::Word32 = zero`, and `z = C::z`."},{"role":"assistant","content":"```cryptol\nmodule issue177 where\n\nimport issue177A\nimport issue177B as B\nimport issue177C as C\n\ntype Byte = [8]\n\nw : Byte\nw = zero\n\nx : Word16\nx = zero\n\ny : B::Word32\ny = zero\n\nz = C::z\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1744-2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the types Widget = [3], Wombat = [4], Key = [5], the newtype Info with field stuff : Array [5] [6], and the functions once, iter, and process with the same type signatures and behavior as in the given code."},{"role":"assistant","content":"```cryptol\nmodule Bug where\n\nimport Array\n\ntype Widget = [3]\ntype Wombat = [4]\ntype Key = [5]\nnewtype Info = {\n   stuff: Array [5] [6]\n}\n\nonce: Info -> Key -> Widget -> Wombat -> Info\nonce info key widget = info'\n   where\n      info' = Info {\n         stuff = arrayUpdate info.stuff key 0\n      }\n\niter: {n} n < 10 => Info -> Key -> [n] (Widget, Wombat) -> Info\niter info key entries = infos ! 0\n   where\n      infos = [info] # [once info' key widget wombat\n                           | info' <- infos\n                           | (widget, wombat) <- entries]\n\nprocess: {n} n < 10 => Info -> [n] (Widget, Wombat) -> Info\nprocess info entries = iter info 0 entries\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue485a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, recreate a module `issue485a` that defines the private types `A = [8] -> [8]` and `ByteFun t = [8] -> t`, a constant `foo : RoundingMode = 0`, a function `bar : A` returning its input, and `baz : ByteFun (ByteFun [8]) = (+)`."},{"role":"assistant","content":"```cryptol\nmodule issue485a where\n\nimport Float\n\nprivate type A = [8] -> [8]\n\nprivate type ByteFun t = [8] -> t\n\nfoo : RoundingMode\nfoo = 0\n\nbar : A\nbar x = x\n\nbaz : ByteFun (ByteFun [8])\nbaz = (+)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1324.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define records `T = { a: [8] }` and `S = { a: [16] }`, implement `f : T -> ()` as `f _ = ()`, and define `g : S -> ()` by assigning `g = f`, ensuring the specification type-checks correctly."},{"role":"assistant","content":"```cryptol\ntype T = { a: [8] }\ntype S = { a: [16] }\n\nf : T -> ()\nf _ = ()\n\ng : S -> ()\ng = f\n```"}]}
{"filename":"cryptol\/tests\/issues\/trac289.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines five 32-bit integer average functions (average1\u2013average5 and a reference average33) and properties av1\u2013av5 and applesOranges that verify their equivalence for all 32-bit inputs."},{"role":"assistant","content":"```cryptol\naverage33 : [32] -> [32] -> [32]\naverage33 x y = drop`{1}(z'\/2)\n    where\n          z' : [33]\n          z' = (0b0 # x) + (0b0 # y)\n\naverage1 : [32] -> [32] -> [32]\naverage1 x y = (x + y)\/2\n\naverage2 : [32] -> [32] -> [32]\naverage2 x y = x\/2 + y\/2 + (x%2 && y%2)\n\naverage3 : [32] -> [32] -> [32]\naverage3 x y = (x + y) >> 1\n\naverage4 : [32] -> [32] -> [32]\naverage4 x y =    (x >> 1) + (y >> 1) + (x && y && 1)\n\naverage5 : [32] -> [32] -> [32]\naverage5 x y = lo + ((hi - lo)>>1) where\n    lo = min x y\n    hi = max x y\n\nproperty av1 x y = average33 x y == average1 x y\nproperty av2 x y = average33 x y == average2 x y\nproperty av3 x y = average33 x y == average3 x y\nproperty av4 x y = average33 x y == average4 x y\nproperty av5 x y = average33 x y == average5 x y\n\nproperty applesOranges x y = average4 x y == average5 x y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue214.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `bm : {r} (fin r, r >= 1) => [2*r] -> [2*r]` such that `bm B = (B @@ [0,2..2*r-2]) # (B @@ [1,3..2*r-1])`, preserving exactly this type and behavior."},{"role":"assistant","content":"```cryptol\nbm : {r} (fin r, r >= 1) => [2*r] -> [2*r]\nbm B = (B @@ [0,2..2*r-2]) # (B @@ [1,3..2*r-1])\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue614.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the functions `f` and `g` with the given polymorphic types and constraints, where `f : {m, n, k} (n == max 2 m k == m + 1) => [m] -> [k][n]` and `g : {n, k} (fin n, fin k, 0 < n <= k) => [n] -> [k]`."},{"role":"assistant","content":"```cryptol\nf : {m, n, k} (n == max 2 m k == m + 1) => [m] -> [k][n]\nf x = zero\n\ng : {n, k} (fin n, fin k, 0 < n <= k) => [n] -> [k]\ng x = sext x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue416.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the polymorphic functions `f` and `g` with the given constraints and sequence comprehensions, ensuring `f` has type `{n} (fin n, 3 >= width n) => [lengthFromThenTo 1 n 7][3]` and `g` has type `{n} (fin n, 3 >= width n) => [_][3]`."},{"role":"assistant","content":"```cryptol\nf : {n} (fin n, 3 >= width n) => [lengthFromThenTo 1 n 7][3]\nf = [1, n .. 7]\n\ng : {n} (fin n, 3 >= width n) => [_][3]\ng = [1, n .. 7]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue364.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the constant x : [64], the constant x_val : [64], and the properties x_eval, x_distinct, and moderately_bogus_property so they match the given random-based specification and verify that these properties hold."},{"role":"assistant","content":"```cryptol\nx : [64]\nx = random 123\n\nx_val : [64]\nx_val = 0xe4f7c1740def67df\n\nproperty x_eval = x == x_val\nproperty x_distinct = ~ (x == zero)\n\nproperty moderately_bogus_property (seed:[8]) =\n  ~(random (zero#seed) == (0:[64]))\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue826.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `WStep` in Cryptol with polymorphic size parameter `n` (where `fin n` and `n >= 2`), taking a block cipher `CIPHk : [128] -> [128]`, a state `[n][64]`, and a tweak `[64]`, and returning the updated state `[n][64]` as in the given transformation."},{"role":"assistant","content":"```cryptol\nWStep:\n    {n}\n    (fin n, n >= 2) ->\n    ([128] -> [128]) -> [n][64] -> [64] -> [n][64]\nWStep CIPHk ([A] # Rs) t = [A'] # Rs'\n  where\n    [MSB, LSB] = split (CIPHk (A # head Rs))\n    A'         = MSB ^ t\n    Rs'        = tail Rs # [LSB]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue212.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the functions `width_eq_geq`, `can_not_width`, and `take_knows_no_bounds` with the given polymorphic type constraints, ensuring the width constraints are respected and the definitions type-check correctly."},{"role":"assistant","content":"```cryptol\nwidth_eq_geq : {n} (32 == width n, n >= 1) => [n]Bit\nwidth_eq_geq = [True | _ <- [1..n] : [_][32] ]\n\ncan_not_width : {n} (64 >= width (8*(n+1))) => [64]\ncan_not_width = zero # (`n : [width n])\n\ntake_knows_no_bounds : {n} (fin n, n >= 4) => [n][8] -> [4 - (n%4)][8]\ntake_knows_no_bounds ns = foo\n where\n foo = take `{4 - (n%4)} ns\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1024b.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the type synonym constraint `PredSyn (a : *) (p : Prop) = (Zero a, Cmp a, p)` and the function `someFunc : {a} (PredSyn a (Logic a)) => a` with definition `someFunc = ~zero` exactly as specified."},{"role":"assistant","content":"```cryptol\ntype constraint PredSyn (a : *) (p:Prop) = (Zero a, Cmp a, p)\n\nsomeFunc : {a} (PredSyn a (Logic a)) => a\nsomeFunc = ~zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/T1440.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module T1440 that declares interface and non-interface submodules (X, Y, I, M, N, M1, M2) with the same structure as described, ensuring correct use of `import interface submodule` and submodule instantiation syntax."},{"role":"assistant","content":"```cryptol\nmodule T1440 where\n\nimport interface submodule X\n\nimport submodule Y\n\ninterface submodule I where\n  type n : #\n\nsubmodule M where\n  import interface submodule I\n\nsubmodule N where\n  x = 2\n\nsubmodule M1 = submodule M { submodule U1 }\nsubmodule M2 = submodule U2 { submodule N }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue368.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module that declares the function `myFun : [8] -> [8] -> [8]` returning 0 and introduces infix operator aliases (e.g., `+`, `*`, `-`, `~`, `^^`, `++`, `.+`, `+.`) all equal to `myFun`, ensuring the syntax is valid and type-correct."},{"role":"assistant","content":"```cryptol\nmyFun : [8] -> [8] -> [8]\nmyFun a b = 0\n\nx + y = myFun x y\nx * y = myFun x y\nx - y = myFun x y\nx ~ y = myFun x y\nx ^^ y = myFun x y\nx ++ y = myFun x y\nx .+ y = myFun x y\nx +. y = myFun x y\nx !+ y = myFun x y\nx +! y = myFun x y\nx .! y = myFun x y\nx :+ y = myFun x y\nx =+ y = myFun x y\nx .: y = myFun x y\nx :+: y = myFun x y\nx +:: y = myFun x y\nx ^^^ y = myFun x y\nx .... y = myFun x y\nx +x .\n```"}]}
{"filename":"cryptol\/tests\/issues\/T146.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the functions `mk_curve_ops`, `ec_v1`, and `ec_v2` with appropriate types so that `mk_curve_ops` constructs a record `c` with a `field` component `f` and components `v1` and `v2` derived from `ec_v1` and `ec_v2` without causing recursive type or record definition issues."},{"role":"assistant","content":"```cryptol\nmk_curve_ops f = undefined\n  where\n    c = { field = f\n        , v1    = ec_v1 f\n        , v2    = ec_v2 c\n        }\n\nec_v1 : {fv} { v0: fv } -> fv\nec_v1 = undefined\n\nec_v2 : {fv} _ -> fv\nec_v2 p = p.field.v0\n  where _ = p.field.v0\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1024a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the type synonyms `Funny` and `Strange` as given, and the polymorphic function `funnyFunc : { i : #, f : # -> *, g : * } Integer` with value `zero` in a Cryptol module."},{"role":"assistant","content":"```cryptol\ntype Funny (f : # -> *) = Integer\ntype Strange (f : Prop) = Integer\n\nfunnyFunc : { i : #, f : # -> *, g : * } Integer\nfunnyFunc = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue225.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `EnigmaBroke` that models an Enigma-style rotor machine, including the types `Rotor`, functions `mkRotor`, `scramble`, and `joinRotors`, with `scramble` and `mkRotor` fully specified so that `joinRotors` correctly processes a character through a sequence of rotors."},{"role":"assistant","content":"```cryptol\nmodule EnigmaBroke where\n\ntype Rotor       = [26](Char, Bit)\n\nmkRotor : {a} (fin a) => ([26]Char,[a]) -> Rotor\nmkRotor (_,_) = zero\n\nscramble : (Bit, Char, Rotor) -> (Bit, Char, Rotor)\nscramble (_,_,_) = zero\n\njoinRotors : {n} (fin n) => ([n]Rotor, Char) -> ([n]Rotor, Char)\njoinRotors (rotors, inputChar) = (rotors', outputChar)\n  where\n    initRotor = mkRotor (['A' .. 'Z'], [])\n    \/\/ ncrs : [n+1](Bit, [8], Rotor)\n    ncrs = [(True, inputChar, initRotor)]\n               # [ scramble (notch, char, r)\n                 | r <- rotors\n                 | (notch, char, rotor') <- ncrs\n                 ]\n    rotors' = tail [ r | (_, _, r) <- ncrs ]\n    (_, outputChar, _) = ncrs ! 0\n```"}]}
{"filename":"cryptol\/tests\/issues\/Issue796.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Issue796` parameterized by a numeric type `_k` that declares types `Key = [8 * _k]`, `Block = [64]`, `RoundKey = [64]`, and implements `aux`, `key_schedule`, and `encrypt_block` consistent with this interface, including use of `groupBy` in `key_schedule`."},{"role":"assistant","content":"```cryptol\nmodule Issue796 = Issue796_Sig where\n\nparameter\n  type _k: #\n\ntype Key = [8 * _k]\ntype Block = [64]\ntype RoundKey = [64]\n\naux : RoundKey -> Block -> Block\naux RK P = zero\n\nkey_schedule K = zero\n  where\n    _ = [ groupBy`{4} K ]\n\nencrypt_block key pt = aux (key_schedule key) pt\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue581.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions `foo` and `bar` with the given polymorphic signatures using `(\/^ )` and `(%^)` size operators and `take`, ensuring the types `[i \/^ j][32]` and `[i %^ j][32]` are well-formed under constraints `fin i`, `fin j`, and `j >= 1`."},{"role":"assistant","content":"```cryptol\nfoo : {i, j} (fin i, fin j, j >= 1) => [i \/^ j][32]\nfoo = take [0...]\n\nbar : {i, j} (fin i, fin j, j >= 1) => [i %^ j][32]\nbar = take [0...]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue185.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `group : {perGroup,a,b,c} (fin perGroup, c == perGroup * a) => [c]b -> [a][perGroup]b` using `split` to partition an input sequence into `a` groups of length `perGroup`."},{"role":"assistant","content":"```cryptol\ngroup : {perGroup, a, b, c} (fin perGroup, c == perGroup * a)\n    => [c]b -> [a][perGroup]b\ngroup xs = split`{each=perGroup}xs\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue187.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `enigmaLoop : {n} (fin n) => [n]` and verify that `enigma : {n, m} (fin n, fin m) => ([n], [m]) -> [m]` typechecks and behaves consistently with the recursive construction of `rcs` shown, using `tail [ True | _ <- rcs ]` as specified."},{"role":"assistant","content":"```cryptol\nmodule Enigma where\n\nenigmaLoop : {n}(fin n) => [n]\nenigmaLoop = undefined\n\nenigma : {n, m} (fin n, fin m) => ([n], [m]) -> [m]\nenigma (m, pt) = tail [ True | _ <- rcs ]\n  where rcs = [ (m, True)] #\n              [ (enigmaLoop, True)\n              | _     <- pt\n              | (_,_) <- rcs\n              ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1511.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `M` with a 1-bit newtype `MOOD_t`, a record `MOOD` containing `HAPPY` and `SAD` constructors with values 0b1 and 0b0, and a constant `v : [1]` equal to `MOOD.SAD.value`."},{"role":"assistant","content":"```cryptol\nmodule M where\n\nv: [1]\nv = MOOD.SAD.value\n\nnewtype MOOD_t = { value: [1] }\n\nMOOD = { HAPPY = MOOD_t { value = 0b1 }\n       , SAD   = MOOD_t { value = 0b0 }\n       }\n```"}]}
{"filename":"cryptol\/tests\/issues\/trac133.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the polymorphic functions `example1` and `example2` with type `{a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8]` such that `example1 k = drop`{16} ((zero : [16*(2 - a)][8]) # k)` and `example2 k = drop`{16} (zero # k)`."},{"role":"assistant","content":"```cryptol\nexample1 : {a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8]\nexample1 k = drop`{16} ((zero : [16*(2 - a)][8]) #k)\n\nexample2 : {a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8]\nexample2 k = drop`{16} (zero # k)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue877.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the list `xs : [_] Integer = [1,2,3]` and verify that the expressions `xs @@ []`, `xs @@ (map trunc [])`, and `xs @@ (map (\\x -> [x]) [])` all typecheck and are well-formed."},{"role":"assistant","content":"```cryptol\na = []\n\nxs : [_] Integer\nxs = [1,2,3]\n\nb = xs @@ []\nc = xs @@ (map trunc [])\nd = xs @@ (map (\\x -> [x]) [])\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue_1812.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the polymorphic functions f, g, ff, gg, jj, and kk with the given parametric size expressions in their types, ensuring all arithmetic on sequence lengths is well-typed under the fin h constraint and any necessary numeric constraints."},{"role":"assistant","content":"```cryptol\nf : {h} (fin h) => [2^^h + (2^^h - 2^^h)]\nf = g`{h}\n\ng : {h} (fin h) => [2^^h]\ng = zero\n\nff : {h} (fin h) => [(2^^h + 2^^h) - 2^^h]\nff = gg`{h}\n\ngg : {h} (fin h) => [2^^h]\ngg = zero\n\njj : {h} (fin h) => [2 ^^ (1 + h) - 1]\njj = kk`{h}\n\nkk : {h} (fin h, 2 ^^ (1 + h) - 1 >= 2 ^^ h - 1) => [2 ^^ h - 1 + 2 ^^ h]\nkk = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue268.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the infinite stream `zs : [inf]([8],[8])` recursively as shown and the finite sequences `xs` and `vs` of length 10 using `take` and list comprehensions with self-referential `zs`, matching the given definitions exactly."},{"role":"assistant","content":"```cryptol\nxs : [10]([8],[8])\nxs = take `{10} zs\n  where\n  zs : [inf]([8],[8])\n  zs = [(0,0)] # [ (0, z) | (z,_) <- drop `{1} zs]\n\nvs : [10]([8],[8])\nvs = take `{10} zs where zs = [ (0, z) | (z,_) <- zs]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue731.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the type constraints `T`, `Both`, `Fin2`, and `(<=>)` exactly as in the description, preserving their intended meanings and relationships between numeric type variables."},{"role":"assistant","content":"```cryptol\nmodule issue731 where\n\ntype constraint T n = (fin n, n >= 1)\n\ntype constraint Both p q = (p, q)\n\ntype constraint Fin2 i j = Both (fin i) (fin j)\n\ntype constraint i <=> j = (i <= j, i >= j)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1562.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the given submodule interface `I` with type `Zp = [8]`, imports it in submodule `F`, defines submodule `M` with type `Empty = Bit`, and creates submodules `F1` and `F2` as `F { submodule M }` instances."},{"role":"assistant","content":"```cryptol\ninterface submodule I where\n  type Zp = [8]\n\nsubmodule F where\n  import interface submodule I\n\nsubmodule M where\n      type Empty = Bit\n\nsubmodule F1 = submodule F { submodule M }\nsubmodule F2 = submodule F { submodule M }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1210.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the functions and properties `mwe`, `mwe'`, `mwe''`, and `bitget` exactly as specified, ensuring they type-check and can be checked by Cryptol\u2019s property checking tools."},{"role":"assistant","content":"```cryptol\nmwe : [2] -> [2][1] -> Bit\nproperty mwe i r = r@0 == (r@0) << 0*i\n\nmwe' : [2] -> [1] -> Bit\nproperty mwe' i r = r == (r << 0*i)\n\nmwe'' : Bit\nproperty mwe'' = r == (r << i)\n where r = 1:[1]\n       i = 0:[2]\n\nbitget : [12] -> [436][8] -> Bit\nproperty bitget i r = i < 3488 ==> bit_gf == if bit_bit then 0x0001 else 0x0000\n  where bit_gf = (zext (((r@(i\/8)) >> (i%8) ) && 1))\n        bit_bit = (join (map reverse r))@i\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue108.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `sum : {a,b} (fin a, fin b) => [a][b] -> [b]` using the prefix-scan style definition with a self-referential sequence `ss = [0] # [ s + x | x <- xs | s <- ss ]` and `sum xs = ss ! 0`."},{"role":"assistant","content":"```cryptol\nsum : {a,b} (fin a, fin b) => [a][b] -> [b]\nsum xs = ss ! 0\n  where\n    ss = [0] # [ s + x | x <- xs | s <- ss ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue130.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions parity, foldl1, par, and the property parOK : {n} (fin n) => [n+1] -> Bit, where parOK asserts par x == parity x for all inputs x."},{"role":"assistant","content":"```cryptol\nparity xs = ys!0\n  where ys = [False] # [y ^ x | x <- xs | y <- ys ]\n\nfoldl1 f xs = ys!0\n  where ys = [xs@0] # [ f y x | y <- ys | x <- tail xs ]\n\npar = foldl1 (^)\n\nparOK : {n} (fin n) => [n+1] -> Bit\nproperty parOK x = par x == parity x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1798.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the polymorphic functions exhaustive1 and exhaustive2 with the given types and guarded definitions, ensuring the guards are exhaustive and type-correct for all widths w."},{"role":"assistant","content":"```cryptol\nexhaustive1 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1 x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n\nexhaustive2 : {w} [2 ^^ w] -> [2 ^^ w]\nexhaustive2 x\n  | (2 ^^ w) == 1 => ~ x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue093.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the given properties `t0`, `t1`, `t2`, `f0`, and the non-property `not_a_prop`, preserving their exact meanings and types so that only the `property`-prefixed names are treated as properties."},{"role":"assistant","content":"```cryptol\nproperty t0 = True\nproperty t1 x = x == (x : [32])\nproperty t2 x y = if (x : [32]) < (y : [32]) then y != zero else True\nnot_a_prop = True\nproperty f0 = False\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue723.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions `f` and `g` with the given polymorphic types, where `f x = g x` and `g m0 = m0 ^ m1` using the captured outer variable `m1 = x`, preserving the scoping and type constraints."},{"role":"assistant","content":"```cryptol\nf : {n} (fin n) => [n] -> [n]\nf x = g x\n  where\n    m1 = x\n\n    g : {k} (fin k) => [k] -> [k]\n    g m0 = m0 ^ m1\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue494.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions `gt_words` and `gt_words'` with type `{a} (fin a) => [a][32] -> [a][32] -> Bit` that compute whether the first word-vector is greater than the second using the given recursive list-comprehension pattern."},{"role":"assistant","content":"```cryptol\ngt_words : {a} (fin a) => [a][32] -> [a][32] -> Bit\ngt_words l0 l1 = ss!0\n  where\n    ss = [ False ] # [ s \\\/ (i > j) | i <- l0 | j <- l1 | s <- ss ]\n\ngt_words' l0 l1 = ss!0\n  where\n    ss = [ False ] # [ s \\\/ (i > j) | i <- l0 | j <- l1 | s <- ss ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue734.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module defining the functions and constants `f`, `asdf1`, and `asdf2` with the given polymorphic type constraints and bit-width equalities, matching the specified types and behaviors exactly."},{"role":"assistant","content":"```cryptol\nf : {a} (fin a) => [2^^a - 1] -> [3*(2^^a - 1)]\nf x = x # x # x\n\nasdf1 : {r} (fin r, width (2^^r)==r+1) => [r+1]\nasdf1 = `(2^^r)\n\nasdf2 : {r} (fin r, width(2^^r-1)==r) => [r]\nasdf2 = `(2^^r-1)\n```"}]}
{"filename":"cryptol\/tests\/issues\/Issue883_A.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, write a module `Issue883_A` that defines a type parameter `c` with constraint `(fin c, c >= 1, 64 >= width (c-1))`, a function `dumbHash : {n} (fin n, 64 >= width n) => [n] -> [128]`, and a function `asdf : {n} (64 >= width (n+192), 64 >= width (128 * c), fin n) => [n] -> [128]` implemented as `dumbHash (join (drop`{1} ys))` where `ys : [c+1][128]` is `zero`."},{"role":"assistant","content":"```cryptol\nmodule Issue883_A where\nparameter\n    type c : #\n    type constraint ( fin c, c >= 1, 64 >= width (c-1) )\n\ndumbHash : {n} (fin n, 64 >= width n) => [n] -> [128]\ndumbHash msg = zero\n\nasdf : {n} (64 >= width (n+192), 64 >= width (128 * c), fin n) => [n] -> [128]\nasdf msg = dumbHash (join (drop`{1} ys))\n where\n   ys : [c+1][128]\n   ys = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue640.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions `f`, `g`, and `h` with the given types so that each uses a recursively defined `out` where `out` is built from its input and `out` (or `take out`) as in the snippet, preserving the original recursive structure."},{"role":"assistant","content":"```cryptol\nf : [1] -> [2]\nf x = out\n  where out = x # [out@0]\n\ng : [1] -> [2]\ng x = out\n  where out = x # (take out)\n\nh : [1] [8] -> [2] [8]\nh x = out\n  where out = x # take out\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/mergesort.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of a mergesort algorithm with functions `sort` and `merge` as given, and a property `sort_correct` that checks `sort` returns the expected sorted results on the listed concrete test vectors."},{"role":"assistant","content":"```cryptol\nsort : {n,a} Cmp a => (fin n) => [n]a -> [n]a\nsort xs\n  | n <= 1 => xs\n  | ()     => merge (sort left) (sort right)\n              where (left : [n\/2] _) # right = xs\n\nmerge : {m,n,a} Cmp a => [m]a -> [n]a -> [m+n]a\nmerge xs ys\n  | m == 0  => ys\n  | n == 0  => xs\n  | (m > 0, n > 0) => if x <= y \n                        then [x] # merge restX ys\n                        else [y] # merge xs restY\n                      where\n                      [x] # restX = xs\n                      [y] # restY = ys\n\nproperty sort_correct =\n  (sort [] == []) &&\n  (sort [0] == [0]) &&\n  (sort [-6, 1, 9, -3, -9, 2, 4] == [-9, -6, -3, 1, 2, 4, 9]) &&\n  (sort [4, -8, -1, -7, -5, 9, 8, 8] == [-8, -7, -5, -1, 4, 8, 8, 9]) &&\n  (sort [1, -1, -2, -3, -2, 7, 5] == [-3, -2, -2, -1, 1, 5, 7]) &&\n  (sort [9, 9, 8, -3, 1, 1, -6, -6, -8] == [-8, -6, -6, -3, 1, 1, 8, 9, 9]) &&\n  (sort [9, 1, 5, 0] == [0, 1, 5, 9]) &&\n  (sort [8, 3, 3] == [3, 3, 8]) &&\n  (sort [-7, 8] == [-7, 8])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/nestFun.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines submodule `A` with a numeric type parameter `n`, function `f : Bool` guarded by `n == 0` and `n > 0`, and imports `A` twice as `Two` (with `type n = 2`) and `Zero` (with `type n = 0`)."},{"role":"assistant","content":"```cryptol\nsubmodule A where\n\n  parameter\n    type n : #\n\n  f : Bool\n  f | n == 0 => True\n    | n > 0  => False\n\nimport submodule A as Two where\n  type n = 2\n\nimport submodule A as Zero where\n  type n = 0\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/constant.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the functions isZero, isFin, and idTypeNum using constraint guards on the type parameter n, and includes properties isZero_correct, isFin_correct, and idTypeNum_correct that verify their expected behavior for finite and infinite type sizes."},{"role":"assistant","content":"```cryptol\nisZero : {n : #} Bit\nisZero | n == 0 => True\n       | ()     => False\n\nproperty isZero_correct =\n  ~isZero `{inf} &&\n   isZero `{  0}   &&\n  ~isZero `{  1}   &&\n  ~isZero `{  2}   &&\n  ~isZero `{  4}   &&\n  ~isZero `{  8}   &&\n  ~isZero `{ 16}\n\nisFin : {n : #} Bit\nisFin | fin n => True\n      | ()    => False\n\nproperty isFin_correct =\n  ~isFin `{inf} &&\n   isFin `{  0}   &&\n   isFin `{  1}   &&\n   isFin `{  2}   &&\n   isFin `{  4}   &&\n   isFin `{  8}   &&\n   isFin `{ 16}\n\nidTypeNum : {n : #} Integer \nidTypeNum | fin n => `n\n\nproperty idTypeNum_correct =\n  (idTypeNum `{ 0}  ==  0) &&\n  (idTypeNum `{ 1}  ==  1) &&\n  (idTypeNum `{ 2}  ==  2) &&\n  (idTypeNum `{ 4}  ==  4) &&\n  (idTypeNum `{ 8}  ==  8) &&\n  (idTypeNum `{16}  == 16)\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/insert.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the function `insert : {n, a} (fin n, Cmp a) => a -> [n]a -> [n+1]a` inserting an element into a sorted sequence, and the property `insert_correct` that checks the given example insertions yield `[0,1,2,3,4,5,6,7,8,9]`."},{"role":"assistant","content":"```cryptol\ninsert : {n, a} (fin n, Cmp a) => a -> [n]a -> [n+1]a\ninsert x' xs \n  | n == 0         => [x']\n  | n == 1         => if x' <= x then [x', x] else [x, x']\n                      where [x] = xs\n  | ( n % 2 == 0\n    , n     >  1 ) => if x' <= x \n                        then insert x' (xs1 # [x]) # xs2 \n                        else xs1 # [x] # insert x' xs2\n                      where (xs1 : [n\/2 - 1]_) # [x] # (xs2 : [n\/2]_) = xs\n  | ( n % 2 == 1\n    , n     >  1 ) => if x' <= x \n                        then insert x' (xs1 # [x]) # xs2\n                        else xs1 # [x] # insert x' xs2\n                      where (xs1 : [n\/2]_) # [x] # (xs2 : [n\/2]_) = xs\n\nproperty insert_correct =\n  (insert 0 [  1,2,3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 1 [0,  2,3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 2 [0,1,  3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 3 [0,1,2,  4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 4 [0,1,2,3,  5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 5 [0,1,2,3,4,  6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 6 [0,1,2,3,4,5,  7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 7 [0,1,2,3,4,5,6,  8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 8 [0,1,2,3,4,5,6,7,  9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 9 [0,1,2,3,4,5,6,7,8  ] == [0,1,2,3,4,5,6,7,8,9])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/len.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a recursive function len : {n,a} (fin n) => [n] a -> Integer using constraint guards to compute a list\u2019s length, and a property len_correct that checks len equals Cryptol\u2019s built-in length for several concrete example lists."},{"role":"assistant","content":"```cryptol\nlen : {n,a} (fin n) => [n] a -> Integer\nlen x\n  | (n == 0) => 0\n  | (n >  0) => 1 + len (drop`{1} x)\n\nproperty \n  len_correct = and\n    [ len l == length l where l = []\n    , len l == length l where l = [1]\n    , len l == length l where l = [1,2]\n    , len l == length l where l = [1,2,3]\n    , len l == length l where l = [1,2,3,4,5]\n    , len l == length l where l = [1,2,3,4,5,6]\n    , len l == length l where l = [1,2,3,4,5,6,7]\n    , len l == length l where l = [1,2,3,4,5,6,7,8]\n    ]\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/tail.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `tail : {n, a} (fin n) => [n]a -> [(max n 1) - 1]a` with guarded equations for the `n == 0` and `n >= 1` cases, and the property `tail_correct` capturing the listed test cases."},{"role":"assistant","content":"```cryptol\ntail : {n, a} (fin n) => [n]a -> [(max n 1) - 1]a\ntail xs | n == 0 => xs\n        | n >= 1 => drop `{1} xs\n\nproperty tail_correct =\n  (tail [] == []) &&\n  (tail [1] == []) &&\n  (tail [1,2] == [2]) &&\n  (tail [1,2,3] == [2,3]) &&\n  (tail [1,2,3,4] == [2,3,4])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/inits.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions inits and initsLoop as given, and a property inits_correct that checks inits produces the concatenation of all non-empty prefixes for several example lists."},{"role":"assistant","content":"```cryptol\ninits : {n, a} (fin n) => [n]a -> [(n * (n+1))\/2]a\ninits xs\n  | n == 0 => []\n  | n >  0 => initsLoop xs' x []\n    where\n      (x : [1]_) # xs' = xs\n\ninitsLoop : {n, l, m, a} (fin l, fin m, l + m == n, m >= 1) =>\n        [l]a -> [m]a ->\n        [((m-1) * ((m-1)+1))\/2]a ->\n        [(n * (n+1))\/2]a\ninitsLoop ys zs acc\n  | l == 0 => acc # zs\n  | l >  0 => initsLoop ys' (zs # y) (acc # zs)\n   where (y : [1]_) # ys' = ys\n\nproperty inits_correct =\n  (inits [] == []) &&\n  (inits [1] == [1]) &&\n  (inits [1,2] == [1,1,2]) &&\n  (inits [1,2,3] == [1,1,2,1,2,3]) &&\n  (inits [1,2,3,4] == [1,1,2,1,2,3,1,2,3,4]) &&\n  (inits [1,2,3,4,5] == [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5])\n```"}]}
{"filename":"cryptol\/tests\/modsys\/T11\/A.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the module `T11::A` parameterized by types `X` and `Y`, introduce the type synonym `T = ([X],[Y])`, and implement the function `f : T -> [X]` that returns the first component of a `T` pair."},{"role":"assistant","content":"```cryptol\nmodule T11::A where\n\nparameter\n  type X : #\n  type Y : #\n\ntype T = ([X],[Y])\n\nf : T -> [X]\nf (x,_) = x\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T038.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that reproduces the submodule\/interface structure of T038, including interfaces I and J, submodules F, P, Q, their imports, and the definition y = x + 1, with x and y having appropriate 8-bit types."},{"role":"assistant","content":"```cryptol\nmodule T038 where\n\ninterface submodule I where\n  x : [8]\n\nsubmodule F where\n  import interface submodule I\n  y = x + 1\n\nsubmodule P where\n  import submodule F { submodule Q }\n  x = 11\n\nsubmodule Q where\n  x = 11\n\ninterface submodule J where\n  import submodule F { submodule P }\n  x : [8]\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T011.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that mirrors the given submodule\/interface structure (A, S, F, I, M), where type T = [8], S exposes x:T, F defines y=2*x, I provides x=28, and M is F instantiated with I, then import M as M."},{"role":"assistant","content":"```cryptol\nsubmodule A where\n  type T = [8]\n\ninterface submodule S where\n  import submodule A\n  x : T\n\nsubmodule F where\n  import interface submodule S\n\n  y = 2 * x\n\nsubmodule I where\n  x = 28\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T005.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines functor-style submodules A, F, I, J, and M as in the description, and include a property that demonstrates the interface constraint (X::n == Y::n) fails for M when instantiated with I (n=8) and J (n=9)."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A as X\n  import interface submodule A as Y\n\n  interface constraint (X::n == Y::n)\n\n  y : [X::n]\n  y = X::x + Y::x\n\nsubmodule I where\n  type n = 8\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule J where\n  type n = 9\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule M = submodule F { X = submodule I, Y = submodule J }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T006.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines these submodules, interfaces, and constraints (A, F, G, I, M, N) using functor-style submodule instantiation, ensuring that type constraints (e.g., X::n >= 3, X::n == n) and expressions for x and y are correctly typed and well-formed."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A as X\n\n  interface constraint (X::n >= 3)\n\n  submodule G where\n    import interface submodule A\n    interface constraint (X::n == n)\n\n    y : [n]\n    y = 5 * X::x + x\n\n  y : [X::n]\n  y = 5 * X::x\n\nsubmodule I where\n  type n = 8\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n\nsubmodule N = submodule M::G { submodule I }\n\nimport submodule N as N\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T012.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines interface submodule S with type T and value x, submodule F importing S and defining y = 2 * x, submodule I defining x = 28, and submodule M as submodule F instantiated with I, then import M as M."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  import T012_M\n  x : T\n\nsubmodule F where\n  import interface submodule S\n\n  y = 2 * x\n\nsubmodule I where\n  x = 28\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T002.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines interface submodule A with parameter n and x:[n], functor submodule F depending on A with y = 1 + x, instance submodule I with n = 8 and x = 2:[n], and submodule M = F{I}, then imports M as M."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 8\n  x = 2 : [n]\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T003.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that uses submodule functors and interfaces to instantiate submodule F with implementation I, where type n = 8 and x is a literal 42, and export the resulting submodule M with value y = 1 + x."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 8\n\n  x : {a} Literal 42 a => a\n  x = 42\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T001.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module using submodule functors that matches this structure: an interface submodule A with a numeric type n and value x:[n], a functor submodule F importing A and defining y = 1 + x, an implementation I fixing n=0 and x:[n], and a submodule M = F{I}."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 0\n  x = x : [n]\n\nsubmodule M = submodule F { submodule I }\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T028.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines interfaces and submodules S, G, and F as in the code, wires the imports correctly, and exposes a top-level binding x = 5 and derived values y = x + 1 and z = x + y."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  x : [8]\n\nsubmodule G where\n  import interface submodule S\n  y = x + 1\n\nsubmodule F where\n  import interface submodule S\n  import submodule G { interface S }\n  z = x + y\n\nimport submodule F where\n  x = 5\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T027.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the submodules S, G, F, and H using interface imports and submodule parameters as in the code, ensuring that name resolution and interface sharing work so that z = A::x + y type-checks correctly and the final imports of F and H override x appropriately."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  x : [8]\n\nsubmodule G where\n  import interface submodule S\n  y = x + 1\n\nsubmodule F where\n  import interface submodule S as A\n\n  submodule H where\n    import interface submodule S as A\n    import submodule G { interface A }\n    z = A::x + y\n\nimport submodule F where\n  x = 5\n\nimport submodule H where\n  x = 6\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T037.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module equivalent to T037 that defines interface submodule I with x:[8], functor submodule F importing I and defining y = x + 1, submodule P with x = 11, submodule X instantiating F with P, and exports z = y from X."},{"role":"assistant","content":"```cryptol\nmodule T037 where\n\ninterface submodule I where\n  x : [8]\n\nsubmodule F where\n  import interface submodule I\n  y = x + 1\n\nsubmodule P where\n  x = 11\n\nsubmodule X where\n  submodule M = submodule F { submodule P }\n  import submodule M\n\n  z = y\n\nimport submodule X\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T012_M.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the type synonym `T` as an 8-bit wide sequence (`[8]`) in a Cryptol module named `T012_M`."},{"role":"assistant","content":"```cryptol\nmodule T012_M where\n\ntype T = [8]\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T022.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines an interface submodule `S` with a finite size type parameter `n` and value `x : [n]`, a submodule `F` that imports `S` as `A` and defines `z = A::x + A::x`, and then instantiates `F` with `n = 8` and `x = 2`."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  type n : #\n  type constraint (fin n)\n  x : [n]\n\nsubmodule F where\n  import interface submodule S as A\n\n  z = A::x + A::x\n\nimport submodule F where\n  type n = 8\n  x = 2\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T008.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a module using a submodule parameterized by a type `n` with constraints `fin n` and `n >= 2`, set a value `x : [n] = 2`, then instantiate it with `n = 2` as submodule `M` and import it as `M`."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n, n >= 2)\n\n  x : [n]\n  x = 2\n\nsubmodule M = submodule F where\n  type n = 2\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T035.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines submodules with parameterized types and newtypes, instantiates the same functor-like submodule twice, imports both instances, and defines a value using a function from one instance applied to a value from the other, matching the structure described."},{"role":"assistant","content":"```cryptol\nsubmodule A where\n  newtype T = { x : Integer }\n\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n)\n\n  newtype X = { x : [n] }\n  f : X -> X\n  f x = x\n\nsubmodule M = submodule F { _ }\nsubmodule N = submodule F { _ }\n\nimport submodule M as M\nimport submodule N as N\n\nx = M::f (N::X { x = 0 })\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T040.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines a submodule `F` parameterized by a type `T`, introduces a `newtype NT = { field : T -> () }` with a value `nt`, imports `F` with `T = [32]`, and defines `x = nt.field 10`."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type T : *\n\n  newtype NT = { field : T -> () }\n\n  nt : NT\n  nt = NT { field = \\_ -> () }\n\nimport submodule F where\n  type T = [32]\n\nx = nt.field 10\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/ffi-type-errors.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that declares the given foreign imports and adds appropriate type-correctness properties (or comments) that capture why each of these FFI declarations is ill-typed or invalid under Cryptol\u2019s C calling convention rules."},{"role":"assistant","content":"```cryptol\nimport Float\n\nforeign badWordSizes : [65] -> [128]\nforeign badFloatSizes : Float16 -> Float128\nforeign badArrayTypes : {n} (fin n) =>\n  [n]Bit -> [n]([16], [16]) -> [n][4][8]{a : [n], b : [2]}\nforeign notFunction : [32]\nforeign badKind : {t} t -> [32]\nforeign noFin : {n} [n][32] -> [n * 2][32]\nforeign infSeq : [inf][32] -> Bit\nforeign wildcard : { x : [8], y : Float32 } -> _\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/ffi-fallback.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module that declares and, where present, implements the four foreign functions `foreignAndCryptol`, `foreignAndNoCryptol`, `noForeignAndCryptol`, and `noForeignAndNoCryptol`, each with type `[8] -> [8]`, matching the given bodies for the two defined functions and leaving the others foreign-only."},{"role":"assistant","content":"```cryptol\nforeign foreignAndCryptol : [8] -> [8]\nforeignAndCryptol x = x\n\nforeign foreignAndNoCryptol : [8] -> [8]\n\nforeign noForeignAndCryptol : [8] -> [8]\nnoForeignAndCryptol x = x + 3\n\nforeign noForeignAndNoCryptol : [8] -> [8]\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/test-ffi.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that declares the same set of `foreign` functions and types as this FFI calling-convention test (integer, word, float, rational, sequence, polymorphic, and submodule `A` signatures) so they can be linked to external C implementations."},{"role":"assistant","content":"```cryptol\nimport Float\n\nforeign add8 : [8] -> [8] -> [8]\nforeign sub16 : [16] -> [16] -> [16]\nforeign mul32 : [32] -> [32] -> [32]\nforeign div64 : [64] -> [64] -> [64]\n\nforeign extendInput : [3] -> [8]\nforeign maskOutput : [8] -> [3]\nforeign noBits : [0] -> [0]\n\nforeign not : Bit -> Bit\n\nforeign addFloat32 : Float32 -> Float32 -> Float32\nforeign subFloat64 : Float64 -> Float64 -> Float64\nforeign specialFloats : [2] -> Float32\n\ntype Word32 = [32]\ntype MyFunc = Word32 -> Float32 -> Bit\nforeign usesTypeSynonym : MyFunc\n\nforeign sum10 : [10]Word32 -> Word32\nforeign reverse5 : [5]Float64 -> [5]Float64\n\nforeign compoundTypes : ([32], { x : [10], y : [3][20] }) -> { z : [5][20] }\n  -> { a : ([16], [16]), b : { c : [8][20], d : [5], e : [5] } }\n\nforeign typeToValue : {n} (fin n) => () -> [64]\nforeign sumPoly : {n} (fin n) => [n]Word32 -> Word32\nforeign inits : {n} (fin n) => [n][8] -> [n * (n + 1) \/ 2][8]\nforeign zipMul3 : {n, m, p} (fin n, fin m, fin p) =>\n  [n]Float32 -> [m]Float32 -> [p]Float32 -> [min n (min m p)]Float32\n\nforeign nestedSeq : {n, m, p} (fin n, fin m, fin p, n * m * p == 4 * 3 * 2) =>\n  [n][m][p][8] -> [4][3][2][8]\n\nforeign i2Q   : Integer -> Rational\nforeign i2Qs  : Integer -> [2]Rational\nforeign iQ2Qi : (Integer,Rational) -> (Rational,Integer)\nforeign i2Z5  : Integer -> Z 5\nforeign i2Z   : {n} (fin n, n >= 1) => Integer -> Z n\n\nsubmodule A where\n  foreign nested : () -> [8]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1489\/issue1489.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the types, constants, and functions `id`, `q`, `ct_butterfly`, `zeta_expc`, and `fast_nttl` exactly as specified, preserving their polymorphic constraints, modular arithmetic, and vector operations."},{"role":"assistant","content":"```cryptol\nmodule ID where\n\nid : {k} (fin k, k > 0) => [2^^k] -> [2^^k]\nid x = join(split`{2,2^^(k-1)}x)\n\ntype q = 3329\n\nct_butterfly :\n    {m, hm}\n    (m >= 2, m <= 8, hm >= 1, hm <= 7, hm == m - 1) =>\n    [2^^m](Z q) -> (Z q) -> [2^^m](Z q)\nct_butterfly v z = new_v\n  where\n    halflen = 2^^`hm\n    lower, upper : [2^^hm](Z q)\n    lower@x = v@x + z * v@(x + halflen)\n    upper@x = v@x - z * v@(x + halflen)\n    new_v = lower # upper\n\nzeta_expc  : [128](Z q)\nzeta_expc = [ 1, 1729, 2580, 3289, 2642, 630, 1897, 848,\n              1062, 1919, 193, 797, 2786, 3260, 569, 1746,\n              296, 2447, 1339, 1476, 3046, 56, 2240, 1333,\n              1426, 2094, 535, 2882, 2393, 2879, 1974, 821,\n              289, 331, 3253, 1756, 1197, 2304, 2277, 2055,\n              650, 1977, 2513, 632, 2865, 33, 1320, 1915,\n              2319, 1435, 807, 452, 1438, 2868, 1534, 2402,\n              2647, 2617, 1481, 648, 2474, 3110, 1227, 910,\n              17, 2761, 583, 2649, 1637, 723, 2288, 1100,\n              1409, 2662, 3281, 233, 756, 2156, 3015, 3050,\n              1703, 1651, 2789, 1789, 1847, 952, 1461, 2687,\n              939, 2308, 2437, 2388, 733, 2337, 268, 641,\n              1584, 2298, 2037, 3220, 375, 2549, 2090, 1645,\n              1063, 319, 2773, 757, 2099, 561, 2466, 2594,\n              2804, 1092, 403, 1026, 1143, 2150, 2775, 886,\n              1722, 1212, 1874, 1029, 2110, 2935, 885, 2154 ]\n\nfast_nttl :\n    {lv}      (lv >= 2, lv <= 8) =>\n    [2^^lv](Z q) -> [8] -> [2^^lv](Z q)\nfast_nttl v k\n    | lv == 2 => ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n\n        | lv  > 2 => (fast_nttl`{lv-1} s0 (k * 2)) #\n                           (fast_nttl`{lv-1} s1 (k * 2 + 1))\n                where\n                  t = ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n                                    [s0, s1] = split t\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1561\/G.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `G` that imports the same interface `I` twice under different names (`J` and `K`) and defines `ja`, `jb`, `ka`, and `kb` using fields `x` and `y` from each interface instance as shown, preserving the qualified-name usage."},{"role":"assistant","content":"```cryptol\nmodule G where\n\nimport interface I as J\nimport interface I as K\n\nja = J::x + 1\njb = J::y + 2\n\nka = K::x + 1\nkb = K::y + 2\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1560\/T4.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module equivalent to T3 that defines the submodule interfaces I1 and I2 with constrained type x, submodules F and F::G, and the values y and csum with the given type dependencies, ensuring it type-checks under these interface constraints."},{"role":"assistant","content":"```cryptol\nmodule T3 where\n\ninterface submodule I1 where\n  type x: #\n  type constraint (x >= 1, x <= 3)\n\ninterface submodule I2 where\n  type x: #\n  type constraint (x >= 1, x <= 4)\n\nsubmodule F where\n  import interface submodule I1 as I\n\n  y: [I::x]\n  y = 1\n\n  submodule G where\n    import interface submodule I2 as I\n    import interface submodule I2 as J\n\n    csum : [I::x]\n    csum = y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1560\/T2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `T2` with parameterized type `n`, a finite-size constraint on `n`, a self-referential constant `a : [n]`, and a submodule `F` with its own type parameter `n` and a polymorphic function `b : {m} [n] -> [m]` returning `a`."},{"role":"assistant","content":"```cryptol\nmodule T2 where\n\nparameter\n  type n: #\n  type constraint (fin n)\n\na:[n]\na = a\n\nsubmodule F where\n  parameter\n    type n: #\n\n  b: {m} [n] -> [m]\n  b _ = a\n```"}]}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Finite.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the sequence `xs = [1 .. 100]` and the function `sumInf` as given below, preserving its use of infinite streams and list comprehensions, in a self-contained module."},{"role":"assistant","content":"```cryptol\nxs = [ 1 .. 100 ]\n\nsumInf xs = iterSums\n    where\n        sums = [ 0 ] # [ x + y | x <- xs\n                               | y <- sums ]\n        iterSums = [ x + y | x <- sums\n                           | y <- [ 1 ...] ]\n```"}]}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Enigma.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that fully specifies this Enigma machine implementation (types, functions, and constants as given) and adds properties proving that encryption and decryption with the same Enigma configuration are inverses and that checkReflectorFwdBwd holds for the given reflector."},{"role":"assistant","content":"```cryptol\nmodule Enigma where\n\ntype Permutation = String 26\n\ntype Plugboard   = Permutation\ntype Rotor       = [26](Char, Bit)\ntype Reflector   = Permutation\n\ntype Enigma n    = { plugboard : Plugboard,\n                     rotors    : [n]Rotor,\n                     reflector : Reflector\n                   }\n\nelem : {a, b} (fin 0, fin a, Cmp b) => (b, [a]b) -> Bit\nelem (x, xs) = matches ! 0\n  where matches = [False] # [ m || (x == e)  | e <- xs\n                                             | m <- matches\n                            ]\nprivate\n  invSubst : (Permutation, Char) -> Char\n  invSubst (key, c) = candidates ! 0\n    where candidates = [0] # [ if c == k then a else p\n                             | k <- key\n                             | a <- ['A' .. 'Z']\n                             | p <- candidates\n                             ]\n\nmkRotor : {n} (fin n) => (Permutation, String n) -> Rotor\nmkRotor (perm, notchLocations) = [ (p, elem (p, notchLocations))\n                                 | p <- perm\n                                 ]\n\nscramble : (Bit, Char, Rotor) -> (Bit, Char, Rotor)\nscramble (rotate, c, rotor) = (notch, c', rotor')\n  where \n    (c', _)    = rotor @ (c - 'A')\n    (_, notch) = rotor @ 0\n    rotor'     = if rotate then rotor <<< 1 else rotor\n\njoinRotors : {n} (fin n) => ([n]Rotor, Char) -> ([n]Rotor, Char)\njoinRotors (rotors, inputChar) = (rotors', outputChar)\n  where \n    initRotor = mkRotor (['A' .. 'Z'], [])\n    ncrs : [n+1](Bit, [8], Rotor)\n    ncrs = [(True, inputChar, initRotor)] \n               # [ scramble (notch, char, r)\n                 | r <- rotors\n                 | (notch, char, rotor') <- ncrs\n                 ]\n    rotors' = tail [ r | (_, _, r) <- ncrs ]\n    (_, outputChar, _) = ncrs ! 0\n\n\/\/ Following the signal through a single rotor, forward and backward\nsubstFwd, substBwd : (Permutation, Char) -> Char\nsubstFwd (perm, c) = perm @ (c - 'A')\nsubstBwd (perm, c) = invSubst (perm, c)\n\n\/\/ Route the signal back from the reflector, chase through rotors\nbackSignal : {n} (fin n) => ([n]Rotor, Char) -> Char\nbackSignal (rotors, inputChar) = cs ! 0\n  where   cs = [inputChar] # [ substBwd ([ p | (p, _) <- r ], c)\n                             | r <- reverse rotors\n                             | c <- cs\n                             ]\n\n\/\/ The full enigma loop, from keyboard to lamps:\n\/\/ The signal goes through the plugboard, rotors, and the reflector,\n\/\/ then goes back through the sequence in reverse, out of the\n\/\/ plugboard and to the lamps\nenigmaLoop : {n} (fin n) => (Plugboard, [n]Rotor, Reflector, Char) -> ([n]Rotor, Char)\nenigmaLoop (pboard, rotors, refl, c0) = (rotors', c5)\n  where\n    c1 = substFwd (pboard, c0)\n    (rotors', c2) = joinRotors (rotors, c1)\n    c3 = substFwd (refl, c2)\n    c4 = backSignal(rotors, c3)\n    c5 = substBwd (pboard, c4)\n\n\/\/ Construct a machine out of parts\nmkEnigma : {n} (Plugboard, [n]Rotor, Reflector, [n]Char) -> Enigma n\nmkEnigma (pboard, rs, refl, startingPositions) =\n    { plugboard  = pboard\n    , rotors     = [ r <<< (s - 'A')\n                   | r <- rs\n                   | s <- startingPositions\n                   ]\n    , reflector  = refl\n    }\n\n\/\/ Encryption\/Decryption\nenigma : {n, m} (fin n, fin m) => (Enigma n, String m) -> String m\nenigma (m, pt) = tail [ c | (_, c) <- rcs ]\n  where rcs = [(m.rotors, '*')] # \n              [ enigmaLoop (m.plugboard, r, m.reflector, c)\n              | c      <- pt\n              | (r, _) <- rcs\n              ]\n\n\/\/ Decryption is the same as encryption:\n\/\/ dEnigma : {n, m} (fin n, fin m) => (Enigma n, String m) -> String m\ndEnigma = enigma\n\n\/\/ Build an example enigma machine:\nplugboard : Plugboard\nplugboard = \"HBGDEFCAIJKOWNLPXRSVYTMQUZ\"\n\nrotor1, rotor2, rotor3 : Rotor\nrotor1 = mkRotor (\"RJICAWVQZODLUPYFEHXSMTKNGB\", \"IO\")\nrotor2 = mkRotor (\"DWYOLETKNVQPHURZJMSFIGXCBA\", \"B\")\nrotor3 = mkRotor (\"FGKMAJWUOVNRYIZETDPSHBLCQX\", \"CK\")\n\nreflector : Reflector\nreflector = \"FEIPBATSCYVUWZQDOXHGLKMRJN\"\n\nmodelEnigma : Enigma 3\nmodelEnigma = mkEnigma (plugboard, [rotor1, rotor2, rotor3], reflector, \"GCR\")\n\n\/* Example run:\n\n   cryptol> :set ascii=on\n   cryptol> enigma  (modelEnigma, \"ENIGMAWASAREALLYCOOLMACHINE\")\n   UPEKTBSDROBVTUJGNCEHHGBXGTF\n   cryptol> dEnigma (modelEnigma, \"UPEKTBSDROBVTUJGNCEHHGBXGTF\")\n   ENIGMAWASAREALLYCOOLMACHINE\n*\/\n\nall: {a, n} (fin n) => (a->Bit) -> [n]a -> Bit\nall fn xs = folds ! 0 where\n    folds = [True] # [ fn x && p | x <- xs\n                                 | p <- folds]\ncheckReflectorFwdBwd : Reflector -> Bit\ncheckReflectorFwdBwd refl = all check ['A' .. 'Z']\n    where check c = substFwd (refl, c) == substBwd (refl, c)\n```"}]}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Simple.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define Cryptol specifications for invSubst, myrev, and sumAll (including their types), and write properties that (1) invSubst correctly inverts a substitution permutation on capital letters, (2) myrev returns its input unchanged, and (3) sumAll computes the sum of all elements in its input sequence."},{"role":"assistant","content":"```cryptol\ntype Char = [8]\ntype Permutation = String 26\n\ninvSubst : (Permutation, Char) -> Char\ninvSubst (key, c) = candidates ! 0\n  where candidates = [0] # [ if c == k then a else p\n                           | k <- key\n                           | a <- ['A' .. 'Z']\n                           | p <- candidates\n                           ]\n\nmyrev : {n,a} (fin n) => [n+1][a] -> [n+1][a]\nmyrev xs = [ xs!i | i <- [ 0 .. n] ]\n\nsumAll xs = ys ! 0\n    where ys = [0] # [x+y | x <- xs | y <- ys]\n```"}]}
{"filename":"cryptol\/examples\/funstuff\/FoxChickenCorn.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that models the classic fox, chicken, and corn river-crossing puzzle using bit-encoded bank states, and includes the given `solutionInNmoves : {n} (fin n) => [n] BankState -> Bit` property to verify whether a sequence of moves is a valid solution."},{"role":"assistant","content":"```cryptol\nmodule FoxChickenCorn where\n\ntype OneBank = [4]\ntype BankState =\n    {left : OneBank\n    ,right: OneBank\n    }\n\nstartState      = { left = farmer || chicken || corn || fox, right = 0x0}\ndoneState       = { left = 0x0, right = farmer || chicken || corn || fox}\n\nfarmer  = 0x1\nchicken = 0x2\ncorn    = 0x4\nfox     = 0x8\n\nsolutionInNmoves : {n} (fin n) => [n] BankState -> Bit\nproperty solutionInNmoves states = validMoveSequence ([startState] # states # [doneState])\n\nvalidMoveSequence : {n} (fin n, n >= 1) => [n] BankState -> Bit\nvalidMoveSequence states = all [validMove a b\n                               | a <- states\n                               | b <- drop`{1} states]\n\nvalidMove : BankState -> BankState -> Bit\nvalidMove b b' = validState b && validState b'\n                 && stuffOnlyMovedWithFarmer b b'\n\nstuffOnlyMovedWithFarmer : BankState -> BankState -> Bit\nstuffOnlyMovedWithFarmer b b' =\n    if farmerHere b.left\n    then farmerHere b'.right && moveFollowsRules b.left b'.right (b'.right - b.right)\n    else farmerHere b'.left  && moveFollowsRules b.right b'.left (b'.left - b.left)\n\nmoveFollowsRules fromBank toBank whatMoved = farmerMoved && atMostOneObjectMoved where\n    farmerMoved = (whatMoved && farmer) == farmer\n    atMostOneObjectMoved = popCount (whatMoved && ~farmer) <= 1\n\ncompleteState : BankState -> Bit\ncompleteState b = (b.left ^ b.right) == 0xf\n\nvalidState : BankState -> Bit\nvalidState bs = completeState bs && validBank bs.left\n                && validBank bs.right && completeState bs\n\nvalidBank : OneBank -> Bit\nvalidBank b = farmerHere b || (~(foxWithChicken b) && ~(chickenWithCorn b))\n\nfarmerHere : OneBank -> Bit\nfarmerHere b = (b && farmer) > 0\n\nchickenWithCorn : OneBank -> Bit\nchickenWithCorn b = (b && (corn || chicken)) == (corn || chicken)\n\nfoxWithChicken : OneBank -> Bit\nfoxWithChicken b = (b && (fox || chicken)) == (fox || chicken)\n\nall : {n} (fin n) => [n] -> Bit\nall xs = xs == ~zero\n\npopCount : {a} (fin a, a >= 1) => [a] -> [width a]\npopCount bs = ic ! 0 where\n    ic = [0] # [ if elt then prev + 1 else prev | elt <- bs | prev <- ic]\n\ntype StringRep = [7][8]\ntype DirRep = [5][8]\nfarmerString  = \"farmer \"\nchickenString = \"chicken\"\ncornString    = \"corn   \"\nfoxString     = \"fox    \"\nnoString      = \"       \"\n\nppArray = [farmerString, chickenString, cornString, foxString]\n\nppBits : [4] -> [4]StringRep\nppBits s =  [ if b then ppArray!i else noString\n            | b <- s\n            | i <- [0 ...]:[_][4] ]\n\nextractMoves : {a} [a+1]BankState -> [a](DirRep, [4]StringRep)\nextractMoves bankStates = [ getMove b b' | b <- bankStates | b' <- drop`{1} bankStates ] where\n    getMove start end = ( dirString, thingsString thingsMoved ) where\n        dirString = if farmerHere start.left then \" --> \" else \" <-- \"\n        thingsMoved = if farmerHere start.left\n                      then end.right - start.right\n                      else end.left - start.left\n        thingsString bits = ppBits bits\n```"}]}
{"filename":"cryptol\/examples\/funstuff\/Coins.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that specifies the coin-counting puzzle using functions `coinSum` and `coinCount`, and a property `coinPuzzle` that holds exactly when four 10-bit coin counts sum to 30 coins and total 109 cents."},{"role":"assistant","content":"```cryptol\ncoinPuzzle : [10] -> [10] -> [10] -> [10] -> Bit\ncoinPuzzle a b c d = (coinCount a b c d 30) \/\\ (coinSum a b c d 109)\n\ncoinSum : [10] -> [10] -> [10] -> [10] -> [10] -> Bit\ncoinSum   a b c d s = (a + 5 * b + 10 * c + 25 * d) == s\n\ncoinCount : [10] -> [10] -> [10] -> [10] -> [10] -> Bit\ncoinCount a b c d s = (((a + b + c + d) == s) \/\\                        (a <= s \/\\ b <= s \/\\ c <= s \/\\ d <= s))\n```"}]}
{"filename":"cryptol\/examples\/funstuff\/marble.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models the 7x7 marble solitaire board and defines properties to verify that a given sequence of board states represents only valid jumps from the initial configuration to the goal configuration in exactly n moves."},{"role":"assistant","content":"```cryptol\ntype Board = [7][7]Bit\n\nall : {n} (fin n) => [n] -> Bit\nall xs = xs == ~zero\n\npopCount : {a} (fin a, a >= 1) => [a] -> [width a]\npopCount bs = ic ! 0 where\n    ic = [0] # [ if elt then prev + 1 else prev | elt <- bs | prev <- ic]\n\nposns : Board\nposns = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nstart : Board\nstart = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,False,True,True,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nfirst : Board\nfirst = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,False,False,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nsecond : Board\nsecond = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,False,True],\n         [True,True,True,True,False,True,True],\n         [False,True,True,True,False,True,False],\n         [False,False,True,True,True,False,False]]\n\ngoal : Board\ngoal = [[False,False,False,False,False,False,False],\n        [False,False,False,True,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False]]\n\nvalidBoard : Board -> Bit\nvalidBoard b = join (b && ~posns) == zero\n\nvalidRowJump : Board -> Board -> Bit\nvalidRowJump a a' = validBoard a\n                 \/\\ validBoard a'\n                 \/\\ validRowMove (differentRow a a')\n\ndifferentRow : Board -> Board -> ([7], [7])\ndifferentRow a a' = rows ! 0\n    where rows = [(0b0000000,0b0000000)]\n               # [ if row != row' then (row,row') else old\n                 | row <- a\n                 | row' <- a'\n                 | old <- rows ]\n\nvalidRowMove : ([7], [7]) -> Bit\nvalidRowMove (r, r') = (xors == 0b0000111 \\\/\n                        xors == 0b0001110 \\\/\n                        xors == 0b0011100 \\\/\n                        xors == 0b0111000 \\\/\n                        xors == 0b1110000)\n                      \/\\ (\n                        rxors == 0b0000011 \\\/\n                        rxors == 0b0000110 \\\/\n                        rxors == 0b0001100 \\\/\n                        rxors == 0b0011000 \\\/\n                        rxors == 0b0110000 \\\/\n                        rxors == 0b1100000)\n    where xors = r ^ r'\n          rxors = r && rxors\n\nvalidColJump : Board -> Board -> Bit\nvalidColJump a a' = validRowJump (transpose a) (transpose a')\n\nvalidMove : Board -> Board -> Bit\nvalidMove a a' = validRowJump a a' \\\/ validColJump a a'\n\nvalidMoveSequence : {n} (fin n, n >= 1) => [n] Board -> Bit\nvalidMoveSequence moves = all [validMove a b | a <- moves | b <- drop`{1} moves]\n\nsolutionInNmoves : {n} (fin n) => [n] Board -> Bit\nproperty solutionInNmoves ms = validMoveSequence ([start] # ms # [second])\n```"}]}
{"filename":"cryptol\/examples\/SuiteB_FFI\/SuiteB_FFI.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `SuiteB_FFI` that exposes AES-128\/192\/256 key schedule and block encrypt\/decrypt functions and SHA-2 hash functions, using AES-NI foreign functions when available and falling back to the `SuiteB` module otherwise."},{"role":"assistant","content":"```cryptol\nmodule SuiteB_FFI where\n\nimport SuiteB as SB\n\ntype AES128 = SB::AES128\n\ntype AES192 = SB::AES192\n\ntype AES256 = SB::AES256\n\ntype AESRoundKey = SB::AESRoundKey\n\ntype AESEncryptKeySchedule k = SB::AESEncryptKeySchedule k\n\ntype AESDecryptKeySchedule k = SB::AESDecryptKeySchedule k\n\naes128EncryptSchedule : [128] -> AESEncryptKeySchedule AES128\naes128EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt128 (split key)\n    else SB::aes128EncryptSchedule\n\naes128DecryptSchedule : [128] -> AESDecryptKeySchedule AES128\naes128DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt128 (split key)\n    else SB::aes128DecryptSchedule\n\naes128Schedules : [128] -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\naes128Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt128 (split key)\n    else SB::aes128Schedules\n\naes192EncryptSchedule : [192] -> AESEncryptKeySchedule AES192\naes192EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt192 (split key)\n    else SB::aes192EncryptSchedule\n\naes192DecryptSchedule : [192] -> AESDecryptKeySchedule AES192\naes192DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt192 (split key)\n    else SB::aes192DecryptSchedule\n\naes192Schedules : [192] -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\naes192Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt192 (split key)\n    else SB::aes192Schedules\n\naes256EncryptSchedule : [256] -> AESEncryptKeySchedule AES256\naes256EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt256 (split key)\n    else SB::aes256EncryptSchedule\n\naes256DecryptSchedule : [256] -> AESDecryptKeySchedule AES256\naes256DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt256 (split key)\n    else SB::aes256DecryptSchedule\n\naes256Schedules : [256] -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\naes256Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt256 (split key)\n    else SB::aes256Schedules\n\naesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]\naesEncryptBlock =\n  if aesniSupported\n    then \\schedule plaintext -> join (aesniEncryptBlock schedule (split plaintext))\n    else SB::aesEncryptBlock\n\naesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]\naesDecryptBlock =\n  if aesniSupported\n    then \\schedule ciphertext -> join (aesniDecryptBlock schedule (split ciphertext))\n    else SB::aesDecryptBlock\n\nprivate\n  foreign checkAESNISupported : () -> Bit\n  foreign aesniExpandEncrypt128 : [16][8] -> AESEncryptKeySchedule AES128\n  foreign aesniExpandDecrypt128 : [16][8] -> AESDecryptKeySchedule AES128\n  foreign aesniExpandEncryptDecrypt128 : [16][8]\n    -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\n  foreign aesniExpandEncrypt192 : [24][8] -> AESEncryptKeySchedule AES192\n  foreign aesniExpandDecrypt192 : [24][8] -> AESDecryptKeySchedule AES192\n  foreign aesniExpandEncryptDecrypt192 : [24][8]\n    -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\n  foreign aesniExpandEncrypt256 : [32][8] -> AESEncryptKeySchedule AES256\n  foreign aesniExpandDecrypt256 : [32][8] -> AESDecryptKeySchedule AES256\n  foreign aesniExpandEncryptDecrypt256 : [32][8]\n    -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\n  foreign aesniEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [16][8] -> [16][8]\n  foreign aesniDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [16][8] -> [16][8]\n\n  aesniSupported = checkAESNISupported ()\n\nsha224 = SB::sha224\n\nsha256 = SB::sha256\n\nsha384 = SB::sha384\n\nsha512 = SB::sha512\n```"}]}
{"filename":"cryptol\/examples\/contrib\/mkrand.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module MKRAND that defines a rule-30-based stream cipher (randXOR) with associated random byte generators, and includes properties otp_encdec and otp_involutive_32 showing correct encryption\/decryption and involutive behavior with the fixed seed seedUnit."},{"role":"assistant","content":"```cryptol\nmodule MKRAND where\n\ntype Seg   = [0x80]\ntype Field = [0x80]Seg\n\nseedUnit:Seg\nseedUnit = (0 :[63]) # (1:[1]) # (0:[64])\n\nfield: Seg -> [inf]Seg\nfield s = new\n  where\n    new = [s] # [ rule30 row | row <- new]\n    rule30 r = [ a ^ (b || c) | a <- r >>> 1\n                              | b <- r\n                              | c <- r <<< 1\n               ]\n\nsha30: Seg -> Seg\nsha30 s = take`{0x80} (drop`{0x80} [ r @ ((((length r) \/ 2)-1):[8]) | r <- field s])\n\nrands : Seg -> [inf]Seg\nrands s = rest\n  where\n     rand p = p ^ (sha30 p)\n     rest = [rand s] # [rand x | x <- rest]\n\nrandBytes : Seg -> [inf][8]\nrandBytes s = groupBy`{8} (join (rands s))\n\nrandXOR : {n} Seg ->  String n -> String n\nrandXOR seed src = [s ^ r | s <- src\n                          | r <- randBytes seed\n                   ]\n\nproperty otp_encdec =\n     randXOR seedUnit \"Deus Ex Machina\" == c\n  \/\\ randXOR seedUnit c == \"Deus Ex Machina\"\n  where c = [ 0x28, 0x2b, 0x2c, 0xfa\n            , 0x92, 0xca, 0xb3, 0xcb\n            , 0xed, 0x50, 0xc2, 0x1b\n            , 0x11, 0x0e, 0x70]\n\notp_involutive : {len} (fin len) => String len -> Bit\notp_involutive msg = randXOR seedUnit (randXOR seedUnit msg) == msg\n\nproperty otp_involutive_32 msg = otp_involutive (msg : String 32)\n```"}]}
{"filename":"cryptol\/examples\/contrib\/EvenMansour.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that specifies the Even-Mansour block cipher using a random permutation F and its inverse F', defines encryption E and decryption D, and includes properties that F is a permutation, F' is its inverse, and D_K(E_K(M)) == M for all keys and messages."},{"role":"assistant","content":"```cryptol\nF = (generate_random_permutation 1942611697)\n\nproperty is_a_permutation a = (unique a) \/\\ (leq a (length(a)-1))\n\nF' = inverse_permutation F\n\nproperty is_inverse_permutation x a a' = ((x@@a)@@a') == x\n\/\/ Main> is_inverse_permutation ([0..9]:[_][4]) (F:[10]_) (F':[10]_)\n\nE : {n} (fin n, n >= 1, width n >= width(n-1)) => ([n], [n]) -> [n] -> [n]\nE (K1, K2) M =  (M^K1)@@F ^ K2\n\nD : {n} (fin n, n >= 1, width n >= width(n-1)) => ([n], [n]) -> [n] -> [n]\nD (K1, K2) C =  (C^K2)@@F' ^ K1\n\n\/**\n * It is easy to verify that for every M in {0,1}^n and K in {0,1}^2n,\n * the following identity holds D_K(E_K(M)) = M, i.e. D_K decrypts\n * messages that were encrypted using E_K.\n *\/\nproperty E_and_D_are_inverses K M = (D K (E K M)) == M\n\n\/******* Utilities *******\/\n\nswap : {a, b} (fin a, a >= 1) => [a]b -> [width(a-1)] -> [width(a-1)] -> [a]b\nswap xs a b = [ if(i == a) then xs@b\n                 |(i == b) then xs@a\n                else xs@i\n              | i <- [0 .. a-1] ]\n\ngenerate_random_permutation : {a} (fin a, a >= 1, width a >= width(a-1)) => [256] -> [a][width(a-1)]\ngenerate_random_permutation seed = pss!0\n  where\n    indices = [ take `{width(a-1)} (b % `a) | b <- (random seed) : [a][width a] ]\n    pss = [ [0 .. a-1] ] # [ swap ps a b | ps <- pss | a <- [0 .. a-1] | b <- indices ]\n\nunique : {a, b} (fin a, fin b, a>=1) => [a][b] -> Bit\nunique xs = [ exist x (i+1) | x <- xs | i <- [0...] ] == 0\n  where exist : [b] -> [width a] -> Bit\n        exist x i = if(i>=`a) then False\n                    else if(x==(xs@i)) then True\n                    else exist x (i+1)\n\nleq xs a = [ x <= a | x <- xs ] == ~0\n\nindex_of : {a, b} (fin a, a>=1, Cmp b) => [a]b -> b -> [width(a-1)]\nindex_of xs a = (ret!0).1\n  where ret = [(False, 0)] # [ if(xs@i == a) then (True, i) else r\n                             | i <- [0 .. a-1 ]\n                             | r <- ret ]\n\ninverse_permutation : {a} (fin a, a >= 1) => [a][width(a-1)] -> [a][width(a-1)]\ninverse_permutation perm = [ index_of perm i | i <- [0 .. a-1 ] ]\n```"}]}
{"filename":"cryptol\/examples\/contrib\/A51.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that specifies the A5\/1 stream cipher using three irregularly clocked LFSRs, defines the keystream function `A51 : ([19],[22],[23]) -> [128]Bit`, and includes the properties `A51_correct` and `A51_search` as given."},{"role":"assistant","content":"```cryptol\nA51_stream : [19] -> [22] -> [23] -> [inf]\nA51_stream R1 R2 R3 = R1s ^ R2s ^ R3s\n  where\n    (R1s, R1f) = lfsrki <| x^^19 + x^^18 + x^^17 + x^^14 + 1 |>  R1c R1\n    (R2s, R2f) = lfsrki <| x^^22 + x^^21 + 1 |>                  R2c R2\n    (R3s, R3f) = lfsrki <| x^^23 + x^^22 + x^^21 + x^^8 + 1 |>   R3c R3\n    majvs = [ majv (r1@8) (r2@10) (r3@10) | r1 <- R1f | r2 <- R2f | r3 <- R3f ]\n    R1c = [ r1@8 == m | r1 <- R1f | m <- majvs ]\n    R2c = [ r2@10 == m | r2 <- R2f | m <- majvs ]\n    R3c = [ r3@10 == m | r3 <- R3f | m <- majvs ]\n\ntype N = 128\nA51 : ([19], [22], [23]) -> [N]Bit\nA51(reg1, reg2, reg3) = keystream\n  where\n    keystream = take`{N} (A51_stream reg1 reg2 reg3)\n\nlfsrki_step : {d} (fin d, d >=1) => [d+1] -> Bit -> [d] -> [d]\nlfsrki_step poly cond fill = fill'\n where\n   feedback_bit = if(poly@0) then prefix (^) (reverse([False]#fill) && poly)\n                             else error \"polynomial does not have high-bit set.\"\n   fill' = if cond then [feedback_bit]#(take fill) else fill\n\nlfsrki : {d} (fin d, d >=1) => [d+1] -> [inf] -> [d] -> ([inf], [inf][d])\nlfsrki poly conds init = (stream, fills)\n  where\n    lfsrki' = lfsrki_step poly\n    fills = [init] # [ lfsrki' c f | c <- conds | f <- fills]\n    stream = [ f!0 | f <- fills ]\n\nprefix f xs = ys!0\n  where ys = [xs@0] # [ f y x | y <- ys | x <- tail xs ]\n\nmajv a b c = (a && b) || (a && c) || (b && c)\n\niv1 = 0b1010111011101011101\niv2 = 0b1010111011101010101110\niv3 = 0b10100000111100110011011\n\ntest_keystream = 0b00100100111010001110101110101100010100110111110101000101110000011101000111110101010000010011001111110101110001011010100000010001\n\nproperty A51_correct = (A51(iv1, iv2, iv3)) == test_keystream\nproperty A51_search x y z = A51(x,y,z) == test_keystream\n```"}]}
{"filename":"cryptol\/examples\/contrib\/RC4.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that implements the RC4 stream cipher (including KSA and keystream generation) and defines properties test1, test2, and test3 asserting that the first bytes of ks \"Key\", ks \"Wiki\", and ks \"Secret\" match the given known test vectors."},{"role":"assistant","content":"```cryptol\nswap : [256][8] -> [8] -> [8] -> [256][8]\nswap s i j = [ s @ (if n == i then j else\n                    if n == j then i else\n                    n)\n             | n <- [0..255]\n             ]\n\nksa_step : [inf][8] -> [8] -> [8] -> [256][8] -> ([8],[256][8])\nksa_step key i j s = (j', swap s i j')\n where j' = j + s@i + key@i\n\nksa : [inf][8] -> [256][8]\nksa key = (go ! 0).1 where\n go : [257]([8],[256][8])\n go = [(0,[0..255])] # [ ksa_step key i j s\n                       | i <- [0..255]\n                       | (j,s) <- go\n                       ]\n\nks_step : [8] -> [8] -> [256][8] -> ([8],[256][8],[8])\nks_step i j s = (j',s',s@(s@i + s@j'))\n where j' = j + s@i\n       s' = swap s i j'\n\nks key = [ k | (_,_,k) <- drop`{1} go ] where\n go = [(0,ksa key',0)] # [ ks_step i j s\n                         | i <- loop\n                         | (j,s,k) <- go\n                         ]\n key' = key # key'\n loop = [1..255] # [0] # loop\n\nproperty test1 = take (ks \"Key\") == [0xEB,0x9F,0x77,0x81,0xB7,0x34,0xCA,0x72,0xA7,0x19]\nproperty test2 = take (ks \"Wiki\") == [0x60,0x44,0xDB,0x6D,0x41,0xB7]\nproperty test3 = take (ks \"Secret\") == [0x04,0xD4,0x6B,0x05,0x3C,0xA8,0x7B,0x59]\n```"}]}
{"filename":"cryptol\/examples\/contrib\/MISTY1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `MISTY1` that implements the MISTY1 block cipher (including keySchedule, FI, FO, FL, FLINV, S-boxes, misty1Encrypt, misty1Decrypt) and the properties `testMisty1Encrypt` and `misty1Correct` as described, so they can be checked by a solver."},{"role":"assistant","content":"```cryptol\nmodule MISTY1 where\n\nkeySchedule : [16][8] -> [32][16]\nkeySchedule K = EK_1 # EK_2 # EK_3 # EK_4\n    where EK_1 = split (join K)\n          EK_2 = [ FI ek_1 ek_1_shifted\n                 | ek_1         <- EK_1\n                 | ek_1_shifted <- EK_1 <<< 1\n                 ]\n          EK_3 = [extend (drop`{7} ek_2) | ek_2 <- EK_2]\n          EK_4 = [extend (take`{7} ek_2) | ek_2 <- EK_2]\n\nFO : [32] -> [8] -> [32][16] -> [32]\nFO FO_IN k EK = (FO_OUT ! 0).1 # (FO_OUT ! 0).0\n    where FO_OUT = [(take FO_IN, drop FO_IN)] # [ f t0 t1\n                                                | f        <- funcs\n                                                | (t0, t1) <- FO_OUT\n                                                ]\n                    funcs : [_]([16] -> [16] -> ([16], [16]))\n          funcs = [\\t0 t1 -> (t0 ^ (EK @ k), t1),\n                   \\t0 t1 -> (FI t0 (EK @ ((k + 5) % 8 + 8)), t1),\n                   \\t0 t1 -> (t0 ^ t1, t1),\n                   \\t0 t1 -> (t0, t1 ^ (EK @ ((k + 2) % 8))),\n                   \\t0 t1 -> (t0, FI t1 (EK @ ((k + 1) % 8 + 8))),\n                   \\t0 t1 -> (t0, t1 ^ t0),\n                   \\t0 t1 -> (t0 ^ EK @ ((k + 7) % 8), t1),\n                   \\t0 t1 -> (FI t0 (EK @ ((k + 3) % 8 + 8)), t1),\n                   \\t0 t1 -> (t0 ^ t1, t1),\n                   \\t0 t1 -> (t0, t1 ^ EK @ ((k + 4) % 8))\n                  ]\n\nFI : [16] -> [16] -> [16]\nFI FI_IN FI_KEY = (FI_OUT ! 0).1 # (FI_OUT ! 0).0\n    where FI_OUT = [(take FI_IN, drop FI_IN)] # [ f d9 d7\n                                                | f        <- funcs\n                                                | (d9, d7) <- FI_OUT\n                                                ]\n                              funcs : [_]([9] -> [7] -> ([9], [7]))\n          funcs = [\\d9 d7 -> ((S9 @ d9) ^ (extend d7), d7),\n                   \\d9 d7 -> (d9, drop (extend (S7 @ d7) ^ d9)),\n                   \\d9 d7 -> (d9, d7 ^ drop (FI_KEY >> 9)),\n                   \\d9 d7 -> (d9 ^ drop FI_KEY, d7),\n                   \\d9 d7 -> ((S9 @ d9) ^ (extend d7), d7)\n                  ]\n\nS7 : [_][7]\nS7 = [27,  50,  51,  90,  59,  16,  23,  84,  91,  26, 114, 115, 107,\n      44, 102,  73,  31,  36,  19, 108,  55,  46,  63,  74,  93,  15,\n      64,  86,  37,  81,  28,   4,  11,  70,  32,  13, 123,  53,  68,\n      66,  43,  30,  65,  20,  75, 121,  21, 111,  14,  85,   9,  54,\n     116,  12, 103,  83,  40,  10, 126,  56,   2,   7,  96,  41,  25,\n      18, 101,  47,  48,  57,   8, 104,  95, 120,  42,  76, 100,  69,\n     117,  61,  89,  72,   3,  87, 124,  79,  98,  60,  29,  33,  94,\n      39, 106, 112,  77,  58,   1, 109, 110,  99,  24, 119,  35,   5,\n      38, 118,   0,  49,  45, 122, 127,  97,  80,  34,  17,   6,  71,\n      22,  82,  78, 113,  62, 105,  67,  52,  92,  88, 125]\n\nS9 : [_][9]\nS9 = [451, 203, 339, 415, 483, 233, 251,  53, 385, 185, 279, 491, 307,\n        9,  45, 211, 199, 330,  55, 126, 235, 356, 403, 472, 163, 286,\n       85,  44,  29, 418, 355, 280, 331, 338, 466,  15,  43,  48, 314,\n      229, 273, 312, 398,  99, 227, 200, 500,  27,   1, 157, 248, 416,\n      365, 499,  28, 326, 125, 209, 130, 490, 387, 301, 244, 414, 467,\n      221, 482, 296, 480, 236,  89, 145,  17, 303,  38, 220, 176, 396,\n      271, 503, 231, 364, 182, 249, 216, 337, 257, 332, 259, 184, 340,\n      299, 430,  23, 113,  12,  71,  88, 127, 420, 308, 297, 132, 349,\n      413, 434, 419,  72, 124,  81, 458,  35, 317, 423, 357,  59,  66,\n      218, 402, 206, 193, 107, 159, 497, 300, 388, 250, 406, 481, 361,\n      381,  49, 384, 266, 148, 474, 390, 318, 284,  96, 373, 463, 103,\n      281, 101, 104, 153, 336,   8,   7, 380, 183,  36,  25, 222, 295,\n      219, 228, 425,  82, 265, 144, 412, 449,  40, 435, 309, 362, 374,\n      223, 485, 392, 197, 366, 478, 433, 195, 479,  54, 238, 494, 240,\n      147,  73, 154, 438, 105, 129, 293,  11,  94, 180, 329, 455, 372,\n       62, 315, 439, 142, 454, 174,  16, 149, 495,  78, 242, 509, 133,\n      253, 246, 160, 367, 131, 138, 342, 155, 316, 263, 359, 152, 464,\n      489,   3, 510, 189, 290, 137, 210, 399,  18,  51, 106, 322, 237,\n      368, 283, 226, 335, 344, 305, 327,  93, 275, 461, 121, 353, 421,\n      377, 158, 436, 204,  34, 306,  26, 232,   4, 391, 493, 407,  57,\n      447, 471,  39, 395, 198, 156, 208, 334, 108,  52, 498, 110, 202,\n       37, 186, 401, 254,  19, 262,  47, 429, 370, 475, 192, 267, 470,\n      245, 492, 269, 118, 276, 427, 117, 268, 484, 345,  84, 287,  75,\n      196, 446, 247,  41, 164,  14, 496, 119,  77, 378, 134, 139, 179,\n      369, 191, 270, 260, 151, 347, 352, 360, 215, 187, 102, 462, 252,\n      146, 453, 111,  22,  74, 161, 313, 175, 241, 400,  10, 426, 323,\n      379,  86, 397, 358, 212, 507, 333, 404, 410, 135, 504, 291, 167,\n      440, 321,  60, 505, 320,  42, 341, 282, 417, 408, 213, 294, 431,\n       97, 302, 343, 476, 114, 394, 170, 150, 277, 239,  69, 123, 141,\n      325,  83,  95, 376, 178,  46,  32, 469,  63, 457, 487, 428,  68,\n       56,  20, 177, 363, 171, 181,  90, 386, 456, 468,  24, 375, 100,\n      207, 109, 256, 409, 304, 346,   5, 288, 443, 445, 224,  79, 214,\n      319, 452, 298,  21,   6, 255, 411, 166,  67, 136,  80, 351, 488,\n      289, 115, 382, 188, 194, 201, 371, 393, 501, 116, 460, 486, 424,\n      405,  31,  65,  13, 442,  50,  61, 465, 128, 168,  87, 441, 354,\n      328, 217, 261,  98, 122,  33, 511, 274, 264, 448, 169, 285, 432,\n      422, 205, 243,  92, 258,  91, 473, 324, 502, 173, 165,  58, 459,\n      310, 383,  70, 225,  30, 477, 230, 311, 506, 389, 140, 143,  64,\n      437, 190, 120,   0, 172, 272, 350, 292,   2, 444, 162, 234, 112,\n      508, 278, 348,  76, 450]\n\nFL : [32] -> [8] -> [32][16] -> [32]\nFL FL_IN k EK =\n    if isEven k then\n        d0_even # d1_even\n        where d1_even = d1 ^ (d0 && (EK @ (k \/ 2)))\n              d0_even = d0 ^ (d1_even || (EK @ ((k \/ 2 + 6) % 8 + 8)))\n    else\n        d0_odd # d1_odd\n        where d1_odd = d1 ^ (d0 && (EK @ (((k - 1) \/ 2 + 2) % 8 + 8)))\n              d0_odd = d0 ^ (d1_odd || (EK @ (((k - 1) \/ 2 + 4) % 8)))\n    where         d0 : [16]\n        d0 = take FL_IN\n                d1 : [16]\n        d1 = drop FL_IN\n\nFLINV : [32] -> [8] -> [32][16] -> [32]\nFLINV FL_IN k EK =\n    if isEven k then\n        d0_even # d1_even\n        where d0_even = d0 ^ (d1 || (EK @ ((k \/ 2 + 6) % 8 + 8)))\n              d1_even = d1 ^ (d0_even && (EK @ (k \/ 2)))\n    else\n        d0_odd # d1_odd\n        where d0_odd = d0 ^ (d1 || (EK @ (((k - 1) \/ 2 + 4) % 8)))\n              d1_odd = d1 ^ (d0_odd && (EK @ (((k - 1) \/ 2 + 2) % 8 + 8)))\n    where         d0 : [16]\n        d0 = take FL_IN\n                d1 : [16]\n        d1 = drop FL_IN\n\nmisty1Encrypt : [64] -> [32][16] -> [64]\nmisty1Encrypt P EK = (C ! 0).1 # (C ! 0).0\n    where\n                        C = [(take P, drop P)] # [ f D0 D1\n                                 | f        <- funcs\n                                 | (D0, D1) <- C\n                                 ]\n        funcs : [_]([32] -> [32] -> ([32], [32]))\n        funcs = [                 \\D0 D1 -> (FL D0 0 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 1 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 0 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 1 EK), D1),\n                                  \\D0 D1 -> (FL D0 2 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 3 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 2 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 3 EK), D1),\n                                  \\D0 D1 -> (FL D0 4 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 5 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 4 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 5 EK), D1),\n                                  \\D0 D1 -> (FL D0 6 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 7 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 6 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 7 EK), D1),\n                                  \\D0 D1 -> (FL D0 8 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 9 EK)\n                ]\n\nmisty1Decrypt : [64] -> [32][16] -> [64]\nmisty1Decrypt C EK = (P ! 0).0 # (P ! 0).1\n    where P = [(drop C, take C)] # [ f D0 D1\n                                   | f        <- funcs\n                                   | (D0, D1) <- P\n                                   ]\n          funcs : [_]([32] -> [32] -> ([32], [32]))\n          funcs = [\\D0 D1 -> (FLINV D0 8 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 9 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 7 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 6 EK)),\n                   \\D0 D1 -> (FLINV D0 6 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 7 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 5 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 4 EK)),\n                   \\D0 D1 -> (FLINV D0 4 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 5 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 3 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 2 EK)),\n                   \\D0 D1 -> (FLINV D0 2 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 3 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 1 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 0 EK)),\n                   \\D0 D1 -> (FLINV D0 0 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 1 EK)\n                  ]\n\nextend : {total, n} (fin total, fin n, total >= n) => [n] -> [total]\nextend n = zero # n\n\nisEven : {a} (fin a) => [a] -> Bool\nisEven n = ~(n ! 0)\n\nproperty testMisty1Encrypt = [ misty1Encrypt block EK\n                             | block <- plaintext\n                             ] == ciphertext\n    where EK         = keySchedule key\n          key        = [0x00, 0x11 .. 0xff]\n          plaintext  = [0x0123456789abcdef, 0xfedcba9876543210]\n          ciphertext = [0x8b1da5f56ab3d07c, 0x04b68240b13be95d]\n\nproperty misty1Correct pt key = misty1Decrypt (misty1Encrypt pt EK) EK == pt\n    where EK = keySchedule key\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/Keys.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the MiniLock key and ID generation functions (encodeID, decodeID, mkFullLengthID, mkID) and a property kat_pub_id_eq that checks the given test vectors and round-trip correctness between public keys and Minilock IDs."},{"role":"assistant","content":"```cryptol\nmodule Keys where\n\nimport CfrgCurves\nimport Blake2s\nimport SCrypt\nimport Base58\n\ntype MinilockID = [46][8]\n\nencodeID : Public25519 -> MinilockID\nencodeID pub = base58enc (join (pub # [h]))\n  where\n  h = blake2s `{nn=1} pub : [8]\n\ndecodeID : MinilockID -> (Bit,Public25519)\ndecodeID ident = (hComp == hRecv, key)\n where\n  bs    = split (base58dec ident)  : [33][8]\n  hRecv = bs ! 0\n  hComp = blake2s `{nn=1} key      : [8]\n  key   = take bs                  : [32][8]\n\nmkFullLengthID : {n} (46 >= n, n>= 1) => [n][8] -> MinilockID\nmkFullLengthID n = drop (['1' | _ <- [0..45] : [_][8]]  # n)\n\nmkID : {passBytes, saltBytes}\n       ( fin passBytes, fin saltBytes\n       , 64 >= width passBytes\n       , 32 >= width (4*saltBytes)\n       )\n    => [passBytes][8] -> [saltBytes][8] -> (MinilockID,Private25519)\nmkID pw email = (encodeID pub,priv)\n  where\n    priv : Private25519\n  priv = SCrypt `{N=2^^1,r=8} (split (blake2s `{nn=32} pw)) email\n    pub  = Curve25519 priv basePoint25519\n\ntestPass = \"some bears eat all the honey in the jar\"\ntestEmail = \"example@example.com\"\n\ntestID : MinilockID\ntestID = mkFullLengthID \"28ZvW9rqRqvqpFTtHnusUntRqrxb4qqZAaNAd3QsqjSsXq\"\n\ntestID_computed = \"28ZvW9rqRqvqpFTtHnusUntRqrxb4qqZAaNAd3QsqjSsXq\"  testPriv_computed =\n  [0x12, 0x86, 0xe0, 0x18, 0xc6, 0x68, 0x34, 0x96, 0x09, 0x2e, 0x53,\n   0x32, 0x37, 0x76, 0x80, 0x3c, 0x30, 0xb4, 0x75, 0x2d, 0xd7, 0x70,\n   0xea, 0xa9, 0x6f, 0x0d, 0xda, 0x25, 0xc7, 0xfe, 0x28, 0x1f]\n\ntestPriv = [0x12, 0x86, 0xe0, 0x18, 0xc6, 0x68, 0x34, 0x96, 0x09, 0x2e, 0x53, 0x32, 0x37, 0x76, 0x80, 0x3c, 0x30, 0xb4, 0x75, 0x2d, 0xd7, 0x70,0xea, 0xa9, 0x6f, 0x0d, 0xda, 0x25, 0xc7, 0xfe, 0x28, 0x1f]\n\ntestPub = Curve25519 testPriv basePoint25519\nproperty kat_pub_id_eq = testPub == (decodeID testID).1 \/\\ encodeID testPub == testID \/\\ testID == testID_computed \/\\ testPriv == testPriv_computed\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a parameterized Cryptol module `AES` that defines AES encryption\/decryption for key sizes 128, 192, and 256 bits, including key expansion and a property `test k pt = decrypt k (encrypt k pt) == pt` for all valid keys and 128-bit plaintexts."},{"role":"assistant","content":"```cryptol\nmodule AES where\n\nimport AES::Algorithm as AES where\n  type Mode = m\n  encRound = AESRound\n  decRound = AESInvRound\n\nimport AES::ExpandKey where\n  type Nk = AES::Nk\n  type Nr = AES::Nr\n\nimport AES::TBox\n\nparameter\n\n  type m : #\n  type k : #\n  type constraint (k == 128 + m * 64, 2 >= m)\n\ntype EncKey = AES::KeySchedule\ntype DecKey = AES::KeySchedule\n\nencrypt : [k] -> [128] -> [128]\nencrypt k = encryptWithSchedule (expandKeyEnc k)\n\ndecrypt : [k] -> [128] -> [128]\ndecrypt k = decryptWithSchedule (expandKeyDec k)\n\nexpandKeyEnc : [k] -> EncKey\nexpandKeyEnc = expandKey\n\nencryptWithSchedule : EncKey -> [128] -> [128]\nencryptWithSchedule = AES::encrypt\n\nexpandKeyDec : [k] -> EncKey\nexpandKeyDec k = makeDecKey (expandKey k)\n\ndecryptWithSchedule : DecKey -> [128] -> [128]\ndecryptWithSchedule = AES::decrypt\n\nproperty test k pt = decrypt k (encrypt k pt) == pt\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES_GCM_SIV_Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module that imports `Common::AES_GCM_SIV` and defines properties `test0` through `test50` asserting that `aes_gcm_siv` encryption outputs the given NIST AES-GCM-SIV test vectors for the specified keys, nonces, AAD lengths, modes, and messages."},{"role":"assistant","content":"```cryptol\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_56 where\n  type Mode = 0\n  type AAD = 56\n\nproperty test0 =\n  AES_GCM_SIV_0_56::aes_gcm_siv\n    { key   = 0xee8e1ed9ff2540ae8f2ba9f50bc2f27c\n    , nonce = 0x752abad3e0afb5f434dc4310\n    , aad   = join \"example\"\n    , msg   = join \"Hello world\"\n    }\n  ==\n  0x5d349ead175ef6b1def6fd #\n  0x4fbcdeb7e4793f4a1d7e4faa70100af1\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_0 where\n  type Mode = 0\n  type AAD = 0\n\nproperty test1 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = []\n    }\n  ==\n  0xdc20e2d83f25705bb49e439eca56de25\n\nproperty test2 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x0100000000000000\n    }\n  ==\n  0xb5d839330ac7b786578782fff6013b81 #\n  0x5b287c22493a364c\n\nproperty test3 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x010000000000000000000000\n    }\n  ==\n  0x7323ea61d05932260047d942a4978db3 #\n  0x57391a0bc4fdec8b0d106639\n\nproperty test4 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000\n    }\n  ==\n  0x743f7c8077ab25f8624e2e948579cf77 #\n  0x303aaf90f6fe21199c6068577437a0c4\n\nproperty test5 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000\n    }\n  ==\n  0x84e07e62ba83a6585417245d7ec413a9 #\n  0xfe427d6315c09b57ce45f2e3936a9445 #\n  0x1a8e45dcd4578c667cd86847bf6155ff\n\nproperty test6 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000\n    }\n  ==\n  0x3fd24ce1f5a67b75bf2351f181a475c7 #\n  0xb800a5b4d3dcf70106b1eea82fa1d64d #\n  0xf42bf7226122fa92e17a40eeaac1201b #\n  0x5e6e311dbf395d35b0fe39c2714388f8\n\nproperty test7 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000\n    }\n  ==\n  0x2433668f1058190f6d43e360f4f35cd8 #\n  0xe475127cfca7028ea8ab5c20f7ab2af0 #\n  0x2516a2bdcbc08d521be37ff28c152bba #\n  0x36697f25b4cd169c6590d1dd39566d3f #\n  0x8a263dd317aa88d56bdf3936dba75bb8\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_8 where\n  type Mode = 0\n  type AAD = 8\n\nproperty test8 =\n AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x0200000000000000\n    }\n  ==\n  0x1e6daba35669f4273b0a1a2560969cdf #\n  0x790d99759abd1508\n\nproperty test9 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x020000000000000000000000\n    }\n  ==\n  0x296c7889fd99f41917f4462008299c51 #\n  0x02745aaa3a0c469fad9e075a\n\nproperty test10 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000\n    }\n  ==\n  0xe2b0c5da79a901c1745f700525cb335b #\n  0x8f8936ec039e4e4bb97ebd8c4457441f\n\nproperty test11 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000\n    }\n  ==\n  0x620048ef3c1e73e57e02bb8562c416a3 #\n  0x19e73e4caac8e96a1ecb2933145a1d71 #\n  0xe6af6a7f87287da059a71684ed3498e1\n\nproperty test12 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000\n    }\n  ==\n  0x50c8303ea93925d64090d07bd109dfd9 #\n  0x515a5a33431019c17d93465999a8b005 #\n  0x3201d723120a8562b838cdff25bf9d1e #\n  0x6a8cc3865f76897c2e4b245cf31c51f2\n\nproperty test13 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000 #\n              0x05000000000000000000000000000000\n    }\n  ==\n  0x2f5c64059db55ee0fb847ed513003746 #\n  0xaca4e61c711b5de2e7a77ffd02da42fe #\n  0xec601910d3467bb8b36ebbaebce5fba3 #\n  0x0d36c95f48a3e7980f0e7ac299332a80 #\n  0xcdc46ae475563de037001ef84ae21744\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_96 where\n  type Mode = 0\n  type AAD = 96\n\nproperty test14 =\n  AES_GCM_SIV_0_96::aes_gcm_siv\n    { msg = 0x02000000\n    , aad = 0x010000000000000000000000\n    , key = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0xa8fe3e8707eb1f84fb28f8cb73de8e99 #\n  0xe2f48a14\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_144 where\n  type Mode = 0\n  type AAD = 144\n\nproperty test15 =\n  AES_GCM_SIV_0_144::aes_gcm_siv\n    { msg = 0x03000000000000000000000000000000 #\n            0x04000000\n    , aad = 0x01000000000000000000000000000000 #\n            0x0200\n    , key = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0x6bb0fecf5ded9b77f902c7d5da236a43 #\n  0x91dd029724afc9805e976f451e6d87f6 #\n  0xfe106514\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_160 where\n  type Mode = 0\n  type AAD = 160\n\nproperty test16 =\n  AES_GCM_SIV_0_160::aes_gcm_siv\n    { msg =   0x03000000000000000000000000000000 #\n              0x0400\n    , aad   = 0x01000000000000000000000000000000 #\n              0x02000000\n    , key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0x44d0aaf6fb2f1f34add5e8064e83e12a #\n  0x2adabff9b2ef00fb47920cc72a0c0f13 #\n  0xb9fd\n\nproperty test16' =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0xe66021d5eb8e4f4066d4adb9c33560e4\n   , nonce = 0xf46e44bb3da0015c94f70887\n   }\n   == 0xa4194b79071b01a87d65f706e3949578\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_40 where\n  type Mode = 0\n  type AAD = 40\n\nproperty test17 =\n  AES_GCM_SIV_0_40::aes_gcm_siv\n   { msg = 0x7a806c\n   , aad = 0x46bb91c3c5\n   , key = 0x36864200e0eaf5284d884a0e77d31646\n   , nonce = 0xbae8e37fc83441b16034566b\n   }\n   == 0xaf60eb711bd85bc1e4d3e0a462e074ee #\n      0xa428a8\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_80 where\n  type Mode = 0\n  type AAD = 80\n\nproperty test18 =\n  AES_GCM_SIV_0_80::aes_gcm_siv\n   { msg = 0xbdc66f146545\n   , aad = 0xfc880c94a95198874296\n   , key = 0xaedb64a6c590bc84d1a5e269e4b47801\n   , nonce = 0xafc0577e34699b9e671fdd4f\n   }\n   == 0xbb93a3e34d3cd6a9c45545cfc11f03ad #\n      0x743dba20f966\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_120 where\n  type Mode = 0\n  type AAD = 120\n\nproperty test19 =\n  AES_GCM_SIV_0_120::aes_gcm_siv\n   { msg = 0x1177441f195495860f\n   , aad = 0x046787f3ea22c127aaf195d1894728\n   , key = 0xd5cc1fd161320b6920ce07787f86743b\n   , nonce = 0x275d1ab32f6d1f0434d8848c\n   }\n   == 0x4f37281f7ad12949d01d02fd0cd174c8 #\n      0x4fc5dae2f60f52fd2b\n\nproperty test20 =\n  AES_GCM_SIV_0_160::aes_gcm_siv\n   { msg = 0x9f572c614b4745914474e7c7\n   , aad = 0xc9882e5386fd9f92ec489c8fde2be2cf #\n           0x97e74e93\n   , key = 0xb3fed1473c528b8426a582995929a149\n   , nonce = 0x9e9ad8780c8d63d0ab4149c0\n   }\n   == 0xf54673c5ddf710c745641c8bc1dc2f87 #\n      0x1fb7561da1286e655e24b7b0\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_200 where\n  type Mode = 0\n  type AAD = 200\n\nproperty test21 =\n  AES_GCM_SIV_0_200::aes_gcm_siv\n   { msg = 0x0d8c8451178082355c9e940fea2f58\n   , aad = 0x2950a70d5a1db2316fd568378da107b5 #\n           0x2b0da55210cc1c1b0a\n   , key = 0x2d4ed87da44102952ef94b02b805249b\n   , nonce = 0xac80e6f61455bfac8308a2d4\n   }\n   == 0xc9ff545e07b88a015f05b274540aa183 #\n           0xb3449b9f39552de99dc214a1190b0b\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_240 where\n  type Mode = 0\n  type AAD = 240\n\nproperty test22 =\n  AES_GCM_SIV_0_240::aes_gcm_siv\n   { msg = 0x6b3db4da3d57aa94842b9803a96e07fb #\n           0x6de7\n   , aad = 0x1860f762ebfbd08284e421702de0de18 #\n           0xbaa9c9596291b08466f37de21c7f\n   , key = 0xbde3b2f204d1e9f8b06bc47f9745b3d1\n   , nonce = 0xae06556fb6aa7890bebc18fe\n   }\n   == 0x6298b296e24e8cc35dce0bed484b7f30 #\n           0xd5803e377094f04709f64d7b985310a4 #\n           0xdb84\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_280 where\n  type Mode = 0\n  type AAD = 280\n\nproperty test23 =\n  AES_GCM_SIV_0_280::aes_gcm_siv\n   { msg = 0xe42a3c02c25b64869e146d7b233987bd #\n           0xdfc240871d\n   , aad = 0x7576f7028ec6eb5ea7e298342a94d4b2 #\n           0x02b370ef9768ec6561c4fe6b7e7296fa #\n           0x859c21\n   , key = 0xf901cfe8a69615a93fdf7a98cad48179\n   , nonce = 0x6245709fb18853f68d833640\n   }\n   == 0x391cc328d484a4f46406181bcd62efd9 #\n      0xb3ee197d052d15506c84a9edd65e13e9 #\n      0xd24a2a6e70\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_0 where\n  type Mode = 1\n  type AAD = 0\n\nproperty test24 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x07f5f4169bbf55a8400cd47ea6fd400f\n\nproperty test25 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x0100000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc2ef328e5c71c83b843122130f7364b7 #\n      0x61e0b97427e3df28\n\nproperty test26 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x010000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x9aab2aeb3faa0a34aea8e2b18ca50da9 #\n      0xae6559e48fd10f6e5c9ca17e\n\nproperty test27 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x85a01b63025ba19b7fd3ddfc033b3e76 #\n      0xc9eac6fa700942702e90862383c6c366\n\nproperty test28 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x4a6a9db4c8c6549201b9edb53006cba8 #\n      0x21ec9cf850948a7c86c68ac7539d027f #\n      0xe819e63abcd020b006a976397632eb5d\n\nproperty test29 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n\n   == 0xc00d121893a9fa603f48ccc1ca3c57ce #\n      0x7499245ea0046db16c53c7c66fe717e3 #\n      0x9cf6c748837b61f6ee3adcee17534ed5 #\n      0x790bc96880a99ba804bd12c0e6a22cc4\n\nproperty test30 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc2d5160a1f8683834910acdafc41fbb1 #\n      0x632d4a353e8b905ec9a5499ac34f96c7 #\n      0xe1049eb080883891a4db8caaa1f99dd0 #\n      0x04d80487540735234e3744512c6f90ce #\n      0x112864c269fc0d9d88c61fa47e39aa08\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_8 where\n  type Mode = 1\n  type AAD = 8\n\nproperty test31 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x0200000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x1de22967237a813291213f267e3b452f #\n      0x02d01ae33e4ec854\n\nproperty test32 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x020000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x163d6f9cc1b346cd453a2e4cc1a4a19a #\n      0xe800941ccdc57cc8413c277f\n\nproperty test33 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc91545823cc24f17dbb0e9e807d5ec17 #\n      0xb292d28ff61189e8e49f3875ef91aff7\n\nproperty test34 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x07dad364bfc2b9da89116d7bef6daaaf #\n      0x6f255510aa654f920ac81b94e8bad365 #\n      0xaea1bad12702e1965604374aab96dbbc\n\nproperty test35 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc67a1f0f567a5198aa1fcc8e3f213143 #\n      0x36f7f51ca8b1af61feac35a86416fa47 #\n      0xfbca3b5f749cdf564527f2314f42fe25 #\n      0x03332742b228c647173616cfd44c54eb\n\nproperty test36 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000 #\n           0x05000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x67fd45e126bfb9a79930c43aad2d3696 #\n      0x7d3f0e4d217c1e551f59727870beefc9 #\n      0x8cb933a8fce9de887b1e40799988db1f #\n      0xc3f91880ed405b2dd298318858467c89 #\n      0x5bde0285037c5de81e5b570a049b62a0\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_96 where\n  type Mode = 1\n  type AAD = 96\n\nproperty test37 =\n  AES_GCM_SIV_1_96::aes_gcm_siv\n   { msg = 0x02000000\n   , aad = 0x010000000000000000000000\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x22b3f4cd1835e517741dfddccfa07fa4 #\n      0x661b74cf\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_144 where\n  type Mode = 1\n  type AAD = 144\n\nproperty test38 =\n  AES_GCM_SIV_1_144::aes_gcm_siv\n   { msg = 0x03000000000000000000000000000000 #\n           0x04000000\n   , aad = 0x01000000000000000000000000000000 #\n           0x0200\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x43dd0163cdb48f9fe3212bf61b201976 #\n      0x067f342bb879ad976d8242acc188ab59 #\n      0xcabfe307\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_160 where\n  type Mode = 1\n  type AAD = 160\n\nproperty test39 =\n  AES_GCM_SIV_1_160::aes_gcm_siv\n   { msg = 0x03000000000000000000000000000000 #\n           0x0400\n   , aad = 0x01000000000000000000000000000000 #\n           0x02000000\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x462401724b5ce6588d5a54aae5375513 #\n      0xa075cfcdf5042112aa29685c912fc205 #\n      0x6543\n\nproperty test40 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0xe66021d5eb8e4f4066d4adb9c33560e4 #\n           0xf46e44bb3da0015c94f7088736864200\n   , nonce = 0xe0eaf5284d884a0e77d31646\n   }\n   == 0x169fbb2fbf389a995f6390af22228a62\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_40 where\n  type Mode = 1\n  type AAD = 40\n\nproperty test41 =\n  AES_GCM_SIV_1_40::aes_gcm_siv\n   { msg = 0x671fdd\n   , aad = 0x4fbdc66f14\n   , key = 0xbae8e37fc83441b16034566b7a806c46 #\n           0xbb91c3c5aedb64a6c590bc84d1a5e269\n   , nonce = 0xe4b47801afc0577e34699b9e\n   }\n   == 0x0eaccb93da9bb81333aee0c785b240d3 #\n      0x19719d\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_80 where\n  type Mode = 1\n  type AAD = 80\n\nproperty test42 =\n  AES_GCM_SIV_1_80::aes_gcm_siv\n   { msg = 0x195495860f04\n   , aad = 0x6787f3ea22c127aaf195\n   , key = 0x6545fc880c94a95198874296d5cc1fd1 #\n           0x61320b6920ce07787f86743b275d1ab3\n   , nonce = 0x2f6d1f0434d8848c1177441f\n   }\n   == 0xa254dad4f3f96b62b84dc40c84636a5e #\n      0xc12020ec8c2c\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_120 where\n  type Mode = 1\n  type AAD = 120\n\nproperty test43 =\n  AES_GCM_SIV_1_120::aes_gcm_siv\n   { msg = 0xc9882e5386fd9f92ec\n   , aad = 0x489c8fde2be2cf97e74e932d4ed87d\n   , key = 0xd1894728b3fed1473c528b8426a58299 #\n           0x5929a1499e9ad8780c8d63d0ab4149c0\n   , nonce = 0x9f572c614b4745914474e7c7\n   }\n   == 0x0df9e308678244c44bc0fd3dc6628dfe #\n      0x55ebb0b9fb2295c8c2\n\nproperty test44 =\n  AES_GCM_SIV_1_160::aes_gcm_siv\n   { msg = 0x1db2316fd568378da107b52b\n   , aad = 0x0da55210cc1c1b0abde3b2f204d1e9f8 #\n           0xb06bc47f\n   , key = 0xa44102952ef94b02b805249bac80e6f6 #\n           0x1455bfac8308a2d40d8c845117808235\n   , nonce = 0x5c9e940fea2f582950a70d5a\n   }\n   == 0x8dbeb9f7255bf5769dd56692404099c2 #\n      0x587f64979f21826706d497d5\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_200 where\n  type Mode = 1\n  type AAD = 200\n\nproperty test45 =\n  AES_GCM_SIV_1_200::aes_gcm_siv\n   { msg = 0x21702de0de18baa9c9596291b08466\n   , aad = 0xf37de21c7ff901cfe8a69615a93fdf7a #\n           0x98cad481796245709f\n   , key = 0x9745b3d1ae06556fb6aa7890bebc18fe #\n           0x6b3db4da3d57aa94842b9803a96e07fb\n   , nonce = 0x6de71860f762ebfbd08284e4\n   }\n   == 0x793576dfa5c0f88729a7ed3c2f1bffb3 #\n      0x080d28f6ebb5d3648ce97bd5ba67fd\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_240 where\n  type Mode = 1\n  type AAD = 240\n\nproperty test46 =\n  AES_GCM_SIV_1_240::aes_gcm_siv\n   { msg = 0xb202b370ef9768ec6561c4fe6b7e7296 #\n           0xfa85\n   , aad = 0x9c2159058b1f0fe91433a5bdc20e214e #\n           0xab7fecef4454a10ef0657df21ac7\n   , key = 0xb18853f68d833640e42a3c02c25b6486 #\n           0x9e146d7b233987bddfc240871d7576f7\n   , nonce = 0x028ec6eb5ea7e298342a94d4\n   }\n   == 0x857e16a64915a787637687db4a951963 #\n      0x5cdd454fc2a154fea91f8363a39fec7d #\n      0x0a49\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_280 where\n  type Mode = 1\n  type AAD = 280\n\nproperty test47 =\n  AES_GCM_SIV_1_280::aes_gcm_siv\n   { msg = 0xced532ce4159b035277d4dfbb7db6296 #\n           0x8b13cd4eec\n   , aad = 0x734320ccc9d9bbbb19cb81b2af4ecbc3 #\n           0xe72834321f7aa0f70b7282b4f33df23f #\n           0x167541\n   , key = 0x3c535de192eaed3822a2fbbe2ca9dfc8 #\n           0x8255e14a661b8aa82cc54236093bbc23\n   , nonce = 0x688089e55540db1872504e1c\n   }\n   == 0x626660c26ea6612fb17ad91e8e767639 #\n      0xedd6c9faee9d6c7029675b89eaf4ba1d #\n      0xed1a286594\n\nproperty test48 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x00000000000000000000000000000000 #\n           0x4db923dc793ee6497c76dcc03a98e108\n   , aad = []\n   , key = 0x00000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x000000000000000000000000\n   }\n   == 0xf3f80f2cf0cb2dd9c5984fcda908456c #\n      0xc537703b5ba70324a6793a7bf218d3ea #\n      0xffffffff000000000000000000000000\n\nproperty test49 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0xeb3640277c7ffd1303c7a542d02d3e4c #\n           0x0000000000000000\n   , aad = []\n   , key = 0x00000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x000000000000000000000000\n   }\n   == 0x18ce4f0b8cb4d0cac65fea8f79257b20 #\n      0x888e53e72299e56dffffffff00000000 #\n      0x0000000000000000\n\nproperty test50 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { msg = 0x01000000000000000000000000000000 #\n            0x02000000000000000000000000000000 #\n            0x03000000000000000000000000000000 #\n            0x04000000000000000000000000000000 #\n            0x05000000000000000000000000000000 #\n            0x06000000000000000000000000000000 #\n            0x07000000000000000000000000000000 #\n            0x08000000000000000000000000000000 #\n            0x09000000000000000000000000000000 #\n            0x0a000000000000000000000000000000 #\n            0x0b000000000000000000000000000000 #\n            0x0c000000000000000000000000000000 #\n            0x0d000000000000000000000000000000 #\n            0x0e000000000000000000000000000000 #\n            0x0f000000000000000000000000000000 #\n            0x10000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , key = 0x01000000000000000000000000000000\n    , aad = []\n    }\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/GCM_AES_Tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines AES-based GCM encryption for 128-, 192-, and 256-bit keys and includes properties test1 through test18 that check the encrypt function against the given NIST GCM test vectors for various key, IV, AAD, and plaintext configurations."},{"role":"assistant","content":"```cryptol\nmodule GCM_AES_Tests where\n\nimport AES as AES128 where\n  type m = 0\n  type k = 128\n\nimport AES as AES192 where\n  type m = 1\n  type k = 192\n\nimport AES as AES256 where\n  type m = 2\n  type k = 256\n\nimport Common::GCM as GCM_128_96_0_128 where\n  type K = 128\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES128::encrypt\n\nproperty test1 =\n  GCM_128_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000\n    , pt  = []\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = []\n  , tag = 0x58e2fccefa7e3061367f1d57a4e7455a\n  }\n\nproperty test2 =\n  GCM_128_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = 0x0388dace60b6a392f328c2b971b2fe78\n  , tag = 0xab6e47d42cec13bdf53a67b21257bddf\n  }\n\nproperty test3 =\n  GCM_128_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct = 0x42831ec2217774244b7221b784d0d49c #\n         0xe3aa212f2c02a4e035c17e2329aca12e #\n         0x21d514b25466931c7d8f6a5aac84aa05 #\n         0x1ba30b396a0aac973d58e091473f5985\n  , tag = 0x4d5c2af327cd64a62cf35abd2ba6fab4\n  }\n\nimport Common::GCM as GCM_128_96_160_128 where\n  type K = 128\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test4 =\n  GCM_128_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct = 0x42831ec2217774244b7221b784d0d49c #\n         0xe3aa212f2c02a4e035c17e2329aca12e #\n         0x21d514b25466931c7d8f6a5aac84aa05 #\n         0x1ba30b396a0aac973d58e091\n  , tag = 0x5bc94fbc3221a5db94fae95ae7121a47\n  }\n\nimport Common::GCM as GCM_128_64_160_128 where\n  type K = 128\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test5 =\n  GCM_128_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbad\n    }\n  ==\n  { ct = 0x61353b4c2806934a777ff51fa22a4755 #\n         0x699b2a714fcdc6f83766e5f97b6c7423 #\n         0x73806900e49f24b22b097544d4896b42 #\n         0x4989b5e1ebac0f07c23f4598\n  , tag = 0x3612d2e79e3b0785561be14aaca2fccb\n  }\n\nimport Common::GCM as GCM_128_480_160_128 where\n  type K = 128\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test6 =\n  GCM_128_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0x9313225df88406e555909c5aff5269aa #\n            0x6a7a9538534f7da1e4c303d2a318a728 #\n            0xc3c0c95156809539fcf0e2429a6b5254 #\n            0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct = 0x8ce24998625615b603a033aca13fb894 #\n         0xbe9112a5c3a211a8ba262a3cca7e2ca7 #\n         0x01e4a9a4fba43c90ccdcb281d48c7c6f #\n         0xd62875d2aca417034c34aee5\n  , tag = 0x619cc5aefffe0bfa462af43c1699d050\n  }\n\nimport Common::GCM as GCM_192_96_0_128 where\n  type K = 192\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES192::encrypt\n\nproperty test7 =\n  GCM_192_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x0000000000000000\n    , pt  = []\n    , aad = []\n    , iv  = 0x000000000000000000000000\n    }\n  ==\n  { ct = []\n  , tag = 0xcd33b28ac773f74ba00ed1f312572435\n  }\n\nproperty test8 =\n  GCM_192_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x0000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct = 0x98e7247c07f0fe411c267e4384b0f600\n  , tag = 0x2ff58d80033927ab8ef4d4587514f0fb\n  }\n\nproperty test9 =\n  GCM_192_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv  = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct =  0x3980ca0b3c00e841eb06fac4872a2757 #\n          0x859e1ceaa6efd984628593b40ca1e19c #\n          0x7d773d00c144c525ac619d18c84a3f47 #\n          0x18e2448b2fe324d9ccda2710acade256\n  , tag = 0x9924a7c8587336bfb118024db8674a14\n  }\n\nimport Common::GCM as GCM_192_96_160_128 where\n  type K = 192\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test10 =\n  GCM_192_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct  = 0x3980ca0b3c00e841eb06fac4872a2757 #\n          0x859e1ceaa6efd984628593b40ca1e19c #\n          0x7d773d00c144c525ac619d18c84a3f47 #\n          0x18e2448b2fe324d9ccda2710\n  , tag = 0x2519498e80f1478f37ba55bd6d27618c\n  }\n\nimport Common::GCM as GCM_192_64_160_128 where\n  type K = 192\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test11 =\n  GCM_192_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbad\n    }\n  ==\n  { ct  = 0x0f10f599ae14a154ed24b36e25324db8 #\n          0xc566632ef2bbb34f8347280fc4507057 #\n          0xfddc29df9a471f75c66541d4d4dad1c9 #\n          0xe93a19a58e8b473fa0f062f7\n  , tag = 0x65dcc57fcf623a24094fcca40d3533f8\n  }\n\nimport Common::GCM as GCM_192_480_160_128 where\n  type K = 192\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test12 =\n  GCM_192_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0x9313225df88406e555909c5aff5269aa #\n            0x6a7a9538534f7da1e4c303d2a318a728 #\n            0xc3c0c95156809539fcf0e2429a6b5254 #\n            0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct  = 0xd27e88681ce3243c4830165a8fdcf9ff #\n          0x1de9a1d8e6b447ef6ef7b79828666e45 #\n          0x81e79012af34ddd9e2f037589b292db3 #\n          0xe67c036745fa22e7e9b7373b\n  , tag = 0xdcf566ff291c25bbb8568fc3d376a6d9\n  }\n\nimport Common::GCM as GCM_256_96_0_128 where\n  type K = 256\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES256::encrypt\n\nproperty test13 =\n  GCM_256_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x00000000000000000000000000000000\n    , pt  = []\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = []\n  , tag = 0x530f8afbc74536b9a963b4f1c4cb738b\n  }\n\nproperty test14 =\n  GCM_256_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x00000000000000000000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = 0xcea7403d4d606b6e074ec5d3baf39d18\n  , tag = 0xd0d1c8a799996bf0265b98b5d48ab919\n  }\n\nproperty test15 =\n  GCM_256_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct  = 0x522dc1f099567d07f47f37a32a84427d #\n          0x643a8cdcbfe5c0c97598a2bd2555d1aa #\n          0x8cb08e48590dbb3da7b08b1056828838 #\n          0xc5f61e6393ba7a0abcc9f662898015ad\n  , tag = 0xb094dac5d93471bdec1a502270e3cc6c\n  }\n\nimport Common::GCM as GCM_256_96_160_128 where\n  type K = 256\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test16 =\n  GCM_256_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct  = 0x522dc1f099567d07f47f37a32a84427d #\n          0x643a8cdcbfe5c0c97598a2bd2555d1aa #\n          0x8cb08e48590dbb3da7b08b1056828838 #\n          0xc5f61e6393ba7a0abcc9f662\n  , tag = 0x76fc6ece0f4e1768cddf8853bb2d551b\n  }\n\nimport Common::GCM as GCM_256_64_160_128 where\n  type K = 256\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test17 =\n  GCM_256_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0xcafebabefacedbad\n    }\n  ==\n  { ct  = 0xc3762df1ca787d32ae47c13bf19844cb #\n          0xaf1ae14d0b976afac52ff7d79bba9de0 #\n          0xfeb582d33934a4f0954cc2363bc73f78 #\n          0x62ac430e64abe499f47c9b1f\n  , tag = 0x3a337dbf46a792c45e454913fe2ea8f2\n  }\n\nimport Common::GCM as GCM_256_480_160_128 where\n  type K = 256\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test18 =\n  GCM_256_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0x9313225df88406e555909c5aff5269aa #\n           0x6a7a9538534f7da1e4c303d2a318a728 #\n           0xc3c0c95156809539fcf0e2429a6b5254 #\n           0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct  = 0x5a8def2f0c9e53f1f75d7853659e2a20 #\n          0xeeb2b22aafde6419a058ab4f6f746bf4 #\n          0x0fc0c3b780f244452da3ebf1c5d82cde #\n          0xa2418997200ef82e44ae7e3f\n  , tag = 0xa44a8266ee1c8eb0c8b5d4cf5ae9f19a\n  }\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/SHA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines a SHA-256 hash function `sha256 : {n} (64 >= width n) => [n] -> [256]` using an imported `SHA256::sha`, along with the test vector list `sha256tests` and the property `katsPass` that all known-answer tests pass."},{"role":"assistant","content":"```cryptol\nmodule SHA where\n\nimport SHA256 as SHA256\n\nsha256 : {n} (64 >= width n) => [n] -> [256]\nsha256 = SHA256::sha\n\nproperty katsPass = ~zero == [test == kat | (test,kat) <- sha256tests ]\n\nsha256tests =\n  [ (go \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    ,   0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1\n    )\n\n  , (go \"\"\n    ,   0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n    )\n\n    , (go \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n      , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1\n      )\n\n    ]\n\n  where\n  go : {n} (64 >= width (8 * n)) => [n][8] -> [256]\n  go x = sha256 (join x)\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/SCrypt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing the scrypt password-based key derivation function (including BlockMix, SMix, MFcrypt, and SCrypt) and define a property kats_pass that checks SCrypt `{N=2^^4,r=1} \"\" \"\" equals the given 64-byte known-answer-test vector."},{"role":"assistant","content":"```cryptol\nmodule SCrypt where\n\nimport Salsa20\nimport PBKDF2\n\nBlockMix : {r} (fin r, r >= 1) =>  [2*r][64*8] -> [2*r][64*8]\nBlockMix B = ys @@ ([0,2..2*r-2] # [1,3..2*r-1])\n where\n  rs = [B!0] # [ join (Salsa20 `{r=8} (split (X ^ bi))) | X <- rs | bi <- B ]\n  ys = drop `{1} rs\n\nSMix : {N,r} ( fin r\n             , r >= 1\n             , N >= 1\n             , 512 >= width N\n             , 1 + width N >= width (N-1)\n             ) => [128 * 8 * r] -> [128 * 8 * r]\nSMix B = join (Xs ! 0)\n where\n  Vs = [split B] # [ BlockMix x | x <- Vs | _ <- [0..N-1] : [_][width N + 1]]\n  V  = take `{front=N} Vs\n\n  Xs : [N+1][2*r][64*8]\n  Xs = [Vs!0]    # [ (x' where\n                            j  = integerify x\n                            T  = x ^ (V@j)\n                            x' = BlockMix T)\n                        | x <- Xs | _ <- [0..N-1] : [_][width N + 1] ]\n\n  integerify w = (join (reverse (split `{each=8} (w!0)))) % `N\n\nMFcrypt : { pwBytes, saltBytes, dkLen, r, N }\n          ( fin dkLen\n          , 4*r >= 1\n          , 8 * dkLen >= 1\n          , 64 >= width (8 * pwBytes)\n          , 32 >= width (4 + saltBytes)\n          ,  512 >= width N, 1+width N >= width (N-1)\n          , 32 >= width ((255 + 8 * dkLen) \/ 256)\n          , 32 >= width (4 + 128 * r)\n          , N >= 1\n          )\n        => [pwBytes][8] -> [saltBytes][8] -> [dkLen][8]\nMFcrypt P S = split DK\n where\n  B  = pbkdf2 `{C=1} P S\n  B' = SMix `{N=N,r=r} B\n  DK = pbkdf2 `{dkLenBits=dkLen*8, C=1} P (split B')\n\nSCrypt : {pwBytes, saltBytes, dkBytes, r, N}\n         ( fin dkBytes, 4*r >= 1\n         , 8 * dkBytes >= 1\n         , 32 >= width ((255 + 8 * dkBytes) \/ 256)\n         , 64 >= width (8 * pwBytes)\n         , 512 >= width N, 1+width N >= width (N-1)\n         , 32 >= width (4 + saltBytes)\n         , 32 >= width (4 + 128 * r)\n         , N >= 1\n         )\n      => [pwBytes][8] -> [saltBytes][8] -> [dkBytes][8]\nSCrypt P S = MFcrypt `{r=r,N=N} P S\n\nproperty kats_pass = ~zero ==\n    [ SCrypt `{N=2^^4,r=1} \"\" \"\" ==\n            [ 0x77, 0xd6, 0x57, 0x62, 0x38, 0x65, 0x7b, 0x20\n            , 0x3b, 0x19, 0xca, 0x42, 0xc1, 0x8a, 0x04, 0x97\n            , 0xf1, 0x6b, 0x48, 0x44, 0xe3, 0x07, 0x4a, 0xe8\n            , 0xdf, 0xdf, 0xfa, 0x3f, 0xed, 0xe2, 0x14, 0x42\n            , 0xfc, 0xd0, 0x06, 0x9d, 0xed, 0x09, 0x48, 0xf8\n            , 0x32, 0x6a, 0x75, 0x3a, 0x0f, 0xc8, 0x1f, 0x17\n            , 0xe8, 0xd3, 0xe0, 0xfb, 0x2e, 0x0d, 0x36, 0x28\n            , 0xcf, 0x35, 0xe2, 0x0c, 0x38, 0xd1, 0x89, 0x06\n            ]\n    ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing the SHA-256 hash function with preprocessing, message schedule, compression function, top-level SHA256 : {a} (fin a, 64 >= width (8*a)) => [a][8] -> [256], and a property katsPass that checks the given known-answer test vectors."},{"role":"assistant","content":"```cryptol\nmodule SHA256 where\n\nCh : [32] -> [32] -> [32] -> [32]\nCh x y z = (x && y) ^ (~x && z)\n\nMaj : [32] -> [32] -> [32] -> [32]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nS0 : [32] -> [32]\nS0 x = (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)\n\nS1 : [32] -> [32]\nS1 x = (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)\n\ns0 : [32] -> [32]\ns0 x = (x >>> 7) ^ (x >>> 18) ^ (x >> 3)\n\ns1 : [32] -> [32]\ns1 x = (x >>> 17) ^ (x >>> 19) ^ (x >> 10)\n\nK : [64][32]\nK = [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n     ]\n\npreprocess : {msgLen}\n     ( fin msgLen\n     , 64 >= width msgLen                                   )\n     => [msgLen] -> [(msgLen + 65) \/^ 512][512]\npreprocess msg = split (msg # [True] # (zero:[(msgLen + 65) %^ 512]) # (`msgLen:[64]))\n\nH0 : [8][32]\nH0 = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n       0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]\n\nSHA256MessageSchedule : [16][32] -> [64][32]\nSHA256MessageSchedule M = W where\n    W = M # [ s1 (W@(j-2)) + (W@(j-7)) + s0 (W@(j-15)) + (W@(j-16)) | j <- [16 .. 63]:[_][8] ]\n\nSHA256Compress : [8][32] -> [64][32] -> [8][32]\nSHA256Compress H W = [as!0 + H@0, bs!0 + H@1, cs!0 + H@2, ds!0 + H@3, es!0 + H@4, fs!0 + H@5, gs!0 + H@6, hs!0 + H@7] where\n    T1 = [h + S1 e + Ch e f g  + k + w | h <- hs | e <- es | f <- fs | g <- gs | k <- K | w <- W]\n    T2 = [S0 a  + Maj a b c  | a <- as | b <- bs | c <- cs]\n    hs = take `{65} ([H@7] # gs)\n    gs = take `{65} ([H@6] # fs)\n    fs = take `{65} ([H@5] # es)\n    es = take `{65} ([H@4] # [d + t1 | d <- ds | t1 <- T1])\n    ds = take `{65} ([H@3] # cs)\n    cs = take `{65} ([H@2] # bs)\n    bs = take `{65} ([H@1] # as)\n    as = take `{65} ([H@0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\nSHA256' : {a} (fin a) => [a][16][32] -> [8][32]\nSHA256' blocks = hash!0 where\n    hash = [H0] # [SHA256Compress h (SHA256MessageSchedule b) | h <- hash | b <- blocks]\n\nSHA256 : {a} (fin a, 64 >= width (8*a)) => [a][8] -> [256]\nSHA256 msg = join (SHA256' [ split x | x <- preprocess(join msg)])\n\nproperty katsPass = ~zero == [test == kat | (test,kat) <- kats ]\n\nkats = [ (SHA256 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n         , 0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1)\n       , (SHA256 \"\"\n         ,0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855)\n       , (SHA256 \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n         , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1)\n       \/\/ , (SHA256 [0x61 | i <- [1..1000000] : [_][32]]\n       \/\/   , 0xcdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0)\n       ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/HMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the generic HMAC function over a hash with configurable block length and digest size, a specialized hmacSHA256 instance, and a property pass that checks the given two standard HMAC-SHA256 test vectors hold."},{"role":"assistant","content":"```cryptol\nmodule HMAC where\n\nimport SHA256\n\nhmacSHA256 : {pwBytes, msgBytes}\n             (fin pwBytes, fin msgBytes\n             , 32 >= width msgBytes\n             , 64 >= width (8*pwBytes)\n             ) => [pwBytes][8] -> [msgBytes][8] -> [256]\nhmacSHA256 = hmac `{blockLength=64} SHA256 SHA256 SHA256\n\nhmac : { msgBytes, pwBytes, digest, blockLength }\n       ( fin pwBytes, fin digest, fin blockLength\n       )\n    => ([blockLength + msgBytes][8] -> [8*digest])\n    -> ([blockLength + digest][8] -> [8*digest])\n    -> ([pwBytes][8] -> [8*digest])\n    -> [pwBytes][8]\n    -> [msgBytes][8]\n    -> [digest*8]\nhmac hash hash2 hash3 key message = hash2 (okey # internal)\n where\n ks : [blockLength][8]\n ks   = if `pwBytes > (`blockLength : [max (width pwBytes) (width blockLength)])\n            then take `{blockLength} (split (hash3 key) # (zero : [blockLength][8]))\n            else take `{blockLength} (key # (zero : [blockLength][8]))\n okey = [k ^ 0x5C | k <- ks]\n ikey = [k ^ 0x36 | k <- ks]\n internal = split (hash (ikey # message))\n\nproperty pass =\n    ~zero ==\n    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] \"Hi There\" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\n    , hmacSHA256 \"Jefe\" \"what do ya want for nothing?\" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\n    ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Blake2s.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing the BLAKE2s hash function (including its compression function, padding, and context handling) with a top-level function `blake2s : {ll,nn} (fin ll, 32 >= nn, 64 >= width ll) => [ll][8] -> [nn*8]` and a property `katsPass` asserting all given test vectors `kats` are satisfied."},{"role":"assistant","content":"```cryptol\nmodule Blake2s where\n\ntype Block   = [16][32]\ntype State   = [8][32]\ntype LocalState = [16][32]\ntype BCounter = [64]\n\ntype Context = { state : State, counter : BCounter }\n\nbbVal : [64]\nbbVal = 64\n\nIV : [8][32]\nIV = [ 0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,\n       0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\n     ]\n\nSIGMA_TABLE : [10][16][4]\nSIGMA_TABLE =\n    [  [  0, 1,   2, 3,   4, 5,   6, 7,   8, 9,  10, 11, 12, 13, 14, 15 ]\n    ,  [ 14, 10,  4, 8,   9, 15, 13, 6,   1, 12,  0, 2,  11, 7,   5, 3  ]\n    ,  [ 11, 8,  12, 0,   5, 2,  15, 13, 10, 14,  3, 6,   7, 1,   9, 4  ]\n    ,  [  7, 9,   3, 1,  13, 12, 11, 14,  2, 6,   5, 10,  4, 0,  15, 8  ]\n    ,  [  9, 0,   5, 7,   2, 4,  10, 15, 14, 1,  11, 12,  6, 8,   3, 13 ]\n    ,  [  2, 12,  6, 10,  0, 11,  8, 3,   4, 13,  7, 5,  15, 14,  1, 9  ]\n    ,  [ 12, 5,   1, 15, 14, 13,  4, 10,  0, 7,   6, 3,   9, 2,   8, 11 ]\n    ,  [ 13, 11,  7, 14, 12, 1,   3, 9,   5, 0,  15, 4,   8, 6,   2, 10 ]\n    ,  [  6, 15, 14, 9,  11, 3,   0, 8,  12, 2,  13, 7,   1, 4,  10, 5  ]\n    ,  [ 10, 2,   8, 4,   7, 6,   1, 5,  15, 11,  9, 14,  3, 12, 13, 0  ]\n    ]\n\nR1,R2,R3,R4 : [6]\nR1 = 16\nR2 = 12\nR3 = 08\nR4 = 07\n\nG : [4] -> [4] -> LocalState -> [4][6] -> Block -> [16][32]\nG r i vec abcd ms = foldl updateVector vec (zip abcd new)\n  where\n  new  = G' r i (vec @@ abcd) ms\n\nG' : [4] -> [4] -> [4][32] -> Block -> [4][32]\nG' r i vals ms = [a2, b2, c2, d2]\n  where\n  x = ms @ (SIGMA_TABLE @ r @ (2*i))\n  y = ms @ (SIGMA_TABLE @ r @ (2*i+1))\n  [a,b,c,d] = vals\n  a1 =  a + b + x\n  d1 = (d ^ a1) >>> R1\n  c1 =  c + d1\n  b1 = (b ^ c1) >>> R2\n  a2 =  a1 + b1 + y\n  d2 = (d1 ^ a2) >>> R3\n  c2 =  c1 + d2\n  b2 = (b1 ^ c2) >>> R4\n\n\/\/ Section 3.2: Compression function\nF : State -> Block -> BCounter -> Bit -> State\nF h ms t f =  h ^ (take (vs!0)) ^ (drop (vs!0))\n where\n  v   = h # IV ^ (zero # [t0,t1,f0,zero])\n  [t1,t0] = split t      : [2][32]\n  f0 = [f | _ <- [0..31] : [_][6]]\n  vs = [v] # [ round i ms v' | v' <- vs | i <- [0..9] ]\n\n\/\/ Sub-function of F (first for loop)\nround : [4] -> Block -> LocalState -> LocalState\nround r ms v = vs ! 0\n  where\n  vs = [v] # [ G r i v' ix ms\n                | v'   <- vs\n                | i    <- [0..7]\n                | ix   <- [ [0,4,8,12],  [1,5,9,13]\n                          , [2,6,10,14], [3,7,11,15]\n                          , [0,5,10,15], [1,6,11,12]\n                          , [2,7,8,13],  [3,4,9,14] ]\n              ]\n\n\/\/ Section 3.3: Padding\n\/\/ Recall kk == key bytes  (0)\n\/\/        nn == hash bytes (32)\n\/\/        ll == input bytes (ceiling $ len \/ 8)\n\/\/        bb == block bytes (64, 1024 bits)\n\/\/        dd == nr Blocks\n\nblake2s : {ll,nn} (fin ll, 32 >= nn, 64 >= width ll)\n      => [ll][8] -> [nn*8]\nblake2s m = blake2s' `{ll=ll,nn=nn} m\n\nblake2s' : {ll,dd,nn}\n         (fin ll\n         , 32  >= nn\n         , dd  == (max 1 ((ll+63)\/64)) - 1\n         , 64 >= width ll\n         )\n          => [ll][8]\n          -> [nn*8]\nblake2s' m = take `{nn*8} (blake2sFinish ({ state = (hs!0).state, counter = `ll}) lastBlock)\n where\n\n fullBlocks : [dd]Block\n fullBlocks = [mkBlock b | b <- split (join (take  `{front=64*dd,back=ll-64*dd} m))]\n\n partialBlock = drop `{front=64*dd,back=ll-64*dd} m\n\n lastBlock : Block\n lastBlock  =\n    if (`ll == (zero:[64]))\n        then zero         else mkBlock ((split (join (partialBlock # (zero : [inf][8]))))@0)\n\n h : Context\n h  = { state = [IV@0 ^ `0x01010000 ^ `nn] # drop `{1} IV, counter = 0 }\n\n hs : [dd+1]Context\n hs = [h] # [blake2Update h' dX |  h' <- hs | dX <- fullBlocks]\n\nblake2Update : Context -> Block -> Context\nblake2Update ctx d = { state = newState, counter = newCount }\n  where newState = F ctx.state d newCount False\n        newCount = ctx.counter + (64 : [64])\n\npostprocess : {ll} (64 >= ll, 64 >= width ll) => BCounter -> [ll][8] -> Block\npostprocess c m =\n    if c == 0 \/\\ `ll == (zero:[64])\n        then zero\n        else split (join m # zero)\n\nblake2sFinish : Context -> Block -> [256]\nblake2sFinish ctx b = join [ reverseBytes w | w <- F ctx.state b ctx.counter True ]\n\nmkBlock x = reverse (split (reverseBytes x))\n\nreverseBytes x = join (reverse (bytes x))\n\nbytes x = split x : [_] [8]\n\nupdateVector : {a, b, c} (c >= width (a-1), a >= 1, fin a, fin c) => [a]b -> ([c], b) -> [a]b\nupdateVector orig idxNew = vs\n where\n idx = idxNew.0\n new = idxNew.1\n vs = [if i == idx then new else orig@i | i <- [0..a-1]]\n\nproperty katsPass = ~zero ==\n                        [ nthKat `{0}\n                        , nthKat `{1}\n                        , nthKat `{2}\n                        , nthKat `{3}\n                        , nthKat `{4}\n                        , nthKat `{5}\n                        , nthKat `{6}\n                        , nthKat `{7}\n                        , nthKat `{8}\n                        , nthKat `{9}\n                        , nthKat `{10}\n                        , nthKat `{11}\n                        , nthKat `{12}\n                        , nthKat `{13}\n                        , nthKat `{14}\n                        , nthKat `{15}\n                        , nthKat `{16}\n                        , nthKat `{17}\n                        , nthKat `{18}\n                        , nthKat `{19}\n                        , nthKat `{20}\n                        , nthKat `{21}\n                        , nthKat `{22}\n                        , nthKat `{23}\n                        , nthKat `{24}\n                        , nthKat `{25}\n                        , nthKat `{26}\n                        , nthKat `{27}\n                        , nthKat `{28}\n                        , nthKat `{29}\n                        , nthKat `{30}\n                        , nthKat `{31}\n                        , nthKat `{32}\n                        , nthKat `{33}\n                        , nthKat `{34}\n                        , nthKat `{35}\n                        , nthKat `{36}\n                        , nthKat `{37}\n                        , nthKat `{38}\n                        , nthKat `{39}\n                        , nthKat `{40}\n                        , nthKat `{41}\n                        , nthKat `{42}\n                        , nthKat `{43}\n                        , nthKat `{44}\n                        , nthKat `{45}\n                        , nthKat `{46}\n                        , nthKat `{47}\n                        , nthKat `{48}\n                        , nthKat `{49}\n                        , nthKat `{50}\n                        , nthKat `{51}\n                        , nthKat `{52}\n                        , nthKat `{53}\n                        , nthKat `{54}\n                        , nthKat `{55}\n                        , nthKat `{56}\n                        , nthKat `{57}\n                        , nthKat `{58}\n                        , nthKat `{59}\n                        , nthKat `{60}\n                        , nthKat `{61}\n                        , nthKat `{62}\n                        , nthKat `{63}\n                        , nthKat `{64}\n                        , nthKat `{65}\n                        , nthKat `{66}\n                        , nthKat `{67}\n                        , nthKat `{68}\n                        , nthKat `{69}\n                        , nthKat `{70}\n                        , nthKat `{71}\n                        , nthKat `{72}\n                        , nthKat `{73}\n                        , nthKat `{74}\n                        , nthKat `{75}\n                        , nthKat `{76}\n                        , nthKat `{77}\n                        , nthKat `{78}\n                        , nthKat `{79}\n                        , nthKat `{80}\n                        , nthKat `{81}\n                        , nthKat `{82}\n                        , nthKat `{83}\n                        , nthKat `{84}\n                        , nthKat `{85}\n                        , nthKat `{86}\n                        , nthKat `{87}\n                        , nthKat `{88}\n                        , nthKat `{89}\n                        , nthKat `{90}\n                        , nthKat `{91}\n                        , nthKat `{92}\n                        , nthKat `{93}\n                        , nthKat `{94}\n                        , nthKat `{95}\n                        , nthKat `{96}\n                        , nthKat `{97}\n                        , nthKat `{98}\n                        , nthKat `{99}\n                        , nthKat `{100}\n                        , nthKat `{101}\n                        , nthKat `{102}\n                        , nthKat `{103}\n                        , nthKat `{104}\n                        , nthKat `{105}\n                        , nthKat `{106}\n                        , nthKat `{107}\n                        , nthKat `{108}\n                        , nthKat `{109}\n                        , nthKat `{110}\n                        , nthKat `{111}\n                        , nthKat `{112}\n                        , nthKat `{113}\n                        , nthKat `{114}\n                        , nthKat `{115}\n                        , nthKat `{116}\n                        , nthKat `{117}\n                        , nthKat `{118}\n                        , nthKat `{119}\n                        , nthKat `{120}\n                        , nthKat `{121}\n                        , nthKat `{122}\n                        , nthKat `{123}\n                        , nthKat `{124}\n                        , nthKat `{125}\n                        , nthKat `{126}\n                        , nthKat `{127}\n                        , nthKat `{128}\n                        , nthKat `{129}\n                        , nthKat `{130}\n                        , nthKat `{131}\n                        , nthKat `{132}\n                        , nthKat `{133}\n                        , nthKat `{134}\n                        , nthKat `{135}\n                        , nthKat `{136}\n                        , nthKat `{137}\n                        , nthKat `{138}\n                        , nthKat `{139}\n                        , nthKat `{140}\n                        , nthKat `{141}\n                        , nthKat `{142}\n                        , nthKat `{143}\n                        , nthKat `{144}\n                        , nthKat `{145}\n                        , nthKat `{146}\n                        , nthKat `{147}\n                        , nthKat `{148}\n                        , nthKat `{149}\n                        , nthKat `{150}\n                        , nthKat `{151}\n                        , nthKat `{152}\n                        , nthKat `{153}\n                        , nthKat `{154}\n                        , nthKat `{155}\n                        , nthKat `{156}\n                        , nthKat `{157}\n                        , nthKat `{158}\n                        , nthKat `{159}\n                        , nthKat `{160}\n                        , nthKat `{161}\n                        , nthKat `{162}\n                        , nthKat `{163}\n                        , nthKat `{164}\n                        , nthKat `{165}\n                        , nthKat `{166}\n                        , nthKat `{167}\n                        , nthKat `{168}\n                        , nthKat `{169}\n                        , nthKat `{170}\n                        , nthKat `{171}\n                        , nthKat `{172}\n                        , nthKat `{173}\n                        , nthKat `{174}\n                        , nthKat `{175}\n                        , nthKat `{176}\n                        , nthKat `{177}\n                        , nthKat `{178}\n                        , nthKat `{179}\n                        , nthKat `{180}\n                        , nthKat `{181}\n                        , nthKat `{182}\n                        , nthKat `{183}\n                        , nthKat `{184}\n                        , nthKat `{185}\n                        , nthKat `{186}\n                        , nthKat `{187}\n                        , nthKat `{188}\n                        , nthKat `{189}\n                        , nthKat `{190}\n                        , nthKat `{191}\n                        , nthKat `{192}\n                        , nthKat `{193}\n                        , nthKat `{194}\n                        , nthKat `{195}\n                        , nthKat `{196}\n                        , nthKat `{197}\n                        , nthKat `{198}\n                        , nthKat `{199}\n                        , nthKat `{200}\n                        , nthKat `{201}\n                        , nthKat `{202}\n                        , nthKat `{203}\n                        , nthKat `{204}\n                        , nthKat `{205}\n                        , nthKat `{206}\n                        , nthKat `{207}\n                        , nthKat `{208}\n                        , nthKat `{209}\n                        , nthKat `{210}\n                        , nthKat `{211}\n                        , nthKat `{212}\n                        , nthKat `{213}\n                        , nthKat `{214}\n                        , nthKat `{215}\n                        , nthKat `{216}\n                        , nthKat `{217}\n                        , nthKat `{218}\n                        , nthKat `{219}\n                        , nthKat `{220}\n                        , nthKat `{221}\n                        , nthKat `{222}\n                        , nthKat `{223}\n                        , nthKat `{224}\n                        , nthKat `{225}\n                        , nthKat `{226}\n                        , nthKat `{227}\n                        , nthKat `{228}\n                        , nthKat `{229}\n                        , nthKat `{230}\n                        , nthKat `{231}\n                        , nthKat `{232}\n                        , nthKat `{233}\n                        , nthKat `{234}\n                        , nthKat `{235}\n                        , nthKat `{236}\n                        , nthKat `{237}\n                        , nthKat `{238}\n                        , nthKat `{239}\n                        , nthKat `{240}\n                        , nthKat `{241}\n                        , nthKat `{242}\n                        , nthKat `{243}\n                        , nthKat `{244}\n                        , nthKat `{245}\n                        , nthKat `{246}\n                        , nthKat `{247}\n                        , nthKat `{248}\n                        , nthKat `{249}\n                        , nthKat `{250}\n                        , nthKat `{251}\n                        , nthKat `{252}\n                        , nthKat `{253}\n                        , nthKat `{254}\n                        , nthKat `{255}\n                        ]\n\nnthKat : {n} (fin n, 8 >= width n) => Bit\nnthKat = blake2s (nthKatInput `{n}) == kats @ (`n : [8])\n\nnthKatInput : {n} (fin n) => [n][8]\nnthKatInput = take ([0 ... ] : [inf][8])\n\nkats = [ 0x69217a3079908094e11121d042354a7c1f55b6482ca1a51e1b250dfd1ed0eef9\n       , 0xe34d74dbaf4ff4c6abd871cc220451d2ea2648846c7757fbaac82fe51ad64bea\n       , 0xddad9ab15dac4549ba42f49d262496bef6c0bae1dd342a8808f8ea267c6e210c\n       , 0xe8f91c6ef232a041452ab0e149070cdd7dd1769e75b3a5921be37876c45c9900\n       , 0x0cc70e00348b86ba2944d0c32038b25c55584f90df2304f55fa332af5fb01e20\n       , 0xec1964191087a4fe9df1c795342a02ffc191a5b251764856ae5b8b5769f0c6cd\n       , 0xe1fa51618d7df4eb70cf0d5a9e906f806e9d19f7f4f01e3b621288e4120405d6\n       , 0x598001fafbe8f94ec66dc827d012cfcbba2228569f448e89ea2208c8bf769293\n       , 0xc7e887b546623635e93e0495598f1726821996c2377705b93a1f636f872bfa2d\n       , 0xc315a437dd28062a770d481967136b1b5eb88b21ee53d0329c5897126e9db02c\n       , 0xbb473deddc055fea6228f207da575347bb00404cd349d38c18026307a224cbff\n       , 0x687e1873a8277591bb33d9adf9a13912efefe557cafc39a7952623e47255f16d\n       , 0x1ac7ba754d6e2f94e0e86c46bfb262abbb74f450ef456d6b4d97aa80ce6da767\n       , 0x012c97809614816b5d9494477d4b687d15b96eb69c0e8074a8516f31224b5c98\n       , 0x91ffd26cfa4da5134c7ea262f7889c329f61f6a657225cc212f40056d986b3f4\n       , 0xd97c828d8182a72180a06a78268330673f7c4e0635947c04c02323fd45c0a52d\n       , 0xefc04cdc391c7e9119bd38668a534e65fe31036d6a62112e44ebeb11f9c57080\n       , 0x992cf5c053442a5fbc4faf583e04e50bb70d2f39fbb6a503f89e56a63e18578a\n       , 0x38640e9f21983e67b539caccae5ecf615ae2764f75a09c9c59b76483c1fbc735\n       , 0x213dd34c7efe4fb27a6b35f6b4000d1fe03281af3c723e5c9f94747a5f31cd3b\n       , 0xec246eeeb9ced3f7ad33ed28660dd9bb0732513db4e2fa278b60cde3682a4ccd\n       , 0xac9b61d446648c3005d7892bf3a8719f4c8181cfdcbc2b79fef10a279b911095\n       , 0x7bf8b22959e34e3a43f7079223e83a9754617d391e213dfd808e41b9bead4ce7\n       , 0x68d4b5d4fa0e302b64ccc5af792913ac4c88ec95c07ddf40694256eb88ce9f3d\n       , 0xb2c2420f05f9abe36315919336b37e4e0fa33ff7e76a492767006fdb5d935462\n       , 0x134f61bbd0bbb69aed5343904551a3e6c1aa7dcdd77e903e7023eb7c60320aa7\n       , 0x4693f9bff7d4f3986a7d176e6e06f72ad1490d805c99e25347b8de77b4db6d9b\n       , 0x853e26f741953b0fd5bdb424e8ab9e8b3750eaa8ef61e47902c91e554e9c73b9\n       , 0xf7de536361abaa0e158156cf0ea4f63a99b5e4054f8fa4c9d45f6285cad55694\n       , 0x4c230608860a99ae8d7bd5c2cc17fa52096b9a61bedb17cb7617864ad29ca7a6\n       , 0xaeb920ea87952dadb1fb759291e3388139a872865001886ed84752e93c250c2a\n       , 0xaba4ad9b480b9df3d08ca5e87b0c2440d4e4ea21224c2eb42cbae469d089b931\n       , 0x05825607d7fdf2d82ef4c3c8c2aea961ad98d60edff7d018983e21204c0d93d1\n       , 0xa742f8b6af82d8a6ca2357c5f1cf91defbd066267d75c048b352366585025962\n       , 0x2bcac89599000b42c95ae23835a713704ed79789c84fef149a874ff733f017a2\n       , 0xac1ed07d048f105a9e5b7ab85b09a492d5baff14b8bfb0e9fd789486eea2b974\n       , 0xe48d0ecfaf497d5b27c25d99e156cb0579d440d6e31fb62473696dbf95e010e4\n       , 0x12a91fadf8b21644fd0f934f3c4a8f62ba862ffd20e8e961154c15c13884ed3d\n       , 0x7cbee96e139897dc98fbef3be81ad4d964d235cb12141fb66727e6e5df73a878\n       , 0xebf66abb597ae572a7297cb0871e355accafad8377b8e78bf164ce2a18de4baf\n       , 0x71b933b07e4ff7818ce059d008829e453c6ff02ec0a7db393fc2d870f37a7286\n       , 0x7cf7c51331220b8d3ebaed9c29398a16d98156e2613cb088f2b0e08a1be4cf4f\n       , 0x3e41a108e0f64ad276b979e1ce068279e16f7bc7e4aa1d211e17b81161df1602\n       , 0x886502a82ab47ba8d86710aa9de3d46ea65c47af6ee8de450cceb8b11b045f50\n       , 0xc021bc5f0954fee94f46ea09487e10a84840d02f64810bc08d9e551f7d416814\n       , 0x2030516e8a5fe19ae79c336fce26382a749d3fd0ec91e537d4bd2358c12dfb22\n       , 0x556698dac8317fd36dfbdf25a79cb112d5425860605cbaf507f23bf7e9f42afe\n       , 0x2f867ba67773fdc3e92fced99a6409ad39d0b880fde8f109a81730c4451d0178\n       , 0x172ec218f119dfae98896dff29dd9876c94af87417f9ae4c7014bb4e4b96afc7\n       , 0x3f85814a18195f879aa962f95d26bd82a278f2b82320218f6b3bd6f7f667a6d9\n       , 0x1b618fbaa566b3d498c12e982c9ec52e4da85a8c54f38f34c090394f23c184c1\n       , 0x0c758fb5692ffd41a3575d0af00cc7fbf2cbe5905a58323a88ae4244f6e4c993\n       , 0xa931360cad628c7f12a6c1c4b753b0f4062aef3ce65a1ae3f19369dadf3ae23d\n       , 0xcbac7d773b1e3b3c6691d7abb7e9df045c8ba19268ded153207f5e804352ec5d\n       , 0x23a196d3802ed3c1b384019a82325840d32f71950c4580b03445e0898e14053c\n       , 0xf4495470f226c8c214be08fdfad4bc4a2a9dbea9136a210df0d4b64929e6fc14\n       , 0xe290dd270b467f34ab1c002d340fa016257ff19e5833fdbbf2cb401c3b2817de\n       , 0x9fc7b5ded3c15042b2a6582dc39be016d24a682d5e61ad1eff9c63309848f706\n       , 0x8cca67a36d17d5e6341cb592fd7bef9926c9e3aa1027ea11a7d8bd260b576e04\n       , 0x409392f560f86831da4373ee5e0074260595d7bc24183b60ed700d4583d3f6f0\n       , 0x2802165de090915546f3398cd849164a19f92adbc361adc99b0f20c8ea071054\n       , 0xad839168d9f8a4be95ba9ef9a692f07256ae43fe6f9864e290691b0256ce50a9\n       , 0x75fdaa5038c284b86d6e8affe8b2807e467b86600e79af3689fbc06328cbf894\n       , 0xe57cb79487dd57902432b250733813bd96a84efce59f650fac26e6696aefafc3\n       , 0x56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e\n       , 0x1b53ee94aaf34e4b159d48de352c7f0661d0a40edff95a0b1639b4090e974472\n       , 0x05705e2a81757c14bd383ea98dda544eb10e6bc07bae435e2518dbe133525375\n       , 0xd8b2866e8a309db53e529ec32911d82f5ca16cff76216891a9676aa31aaa6c42\n       , 0xf5041c241270eb04c71ec2c95d4c38d803b1237b0f29fd4db3eb397669e88699\n       , 0x9a4ce077c349322f595e0ee79ed0da5fab66752cbfef8f87d0e9d0723c7530dd\n       , 0x657b09f3d0f52b5b8f2f97163a0edf0c04f075408a07bbeb3a4101a891990d62\n       , 0x1e3f7bd5a58fa533344aa8ed3ac122bb9e70d4ef50d004530821948f5fe6315a\n       , 0x80dccf3fd83dfd0d35aa28585922ab89d5313997673eaf905cea9c0b225c7b5f\n       , 0x8a0d0fbf6377d83bb08b514b4b1c43acc95d751714f8925645cb6bc856ca150a\n       , 0x9fa5b487738ad2844cc6348a901918f659a3b89e9c0dfeead30dd94bcf42ef8e\n       , 0x80832c4a1677f5ea2560f668e9354dd36997f03728cfa55e1b38337c0c9ef818\n       , 0xab37ddb683137e74080d026b590b96ae9bb447722f305a5ac570ec1df9b1743c\n       , 0x3ee735a694c2559b693aa68629361e15d12265ad6a3dedf488b0b00fac9754ba\n       , 0xd6fcd23219b647e4cbd5eb2d0ad01ec8838a4b2901fc325cc3701981ca6c888b\n       , 0x0520ec2f5bf7a755dacb50c6bf233e3515434763db0139ccd9faefbb8207612d\n       , 0xaff3b75f3f581264d7661662b92f5ad37c1d32bd45ff81a4ed8adc9ef30dd989\n       , 0xd0dd650befd3ba63dc25102c627c921b9cbeb0b130686935b5c927cb7ccd5e3b\n       , 0xe1149816b10a8514fb3e2cab2c08bee9f73ce76221701246a589bbb67302d8a9\n       , 0x7da3f441de9054317e72b5dbf979da01e6bceebb8478eae6a22849d90292635c\n       , 0x1230b1fc8a7d9215edc2d4a2decbdd0a6e216c924278c91fc5d10e7d60192d94\n       , 0x5750d716b4808f751febc38806ba170bf6d5199a7816be514e3f932fbe0cb871\n       , 0x6fc59b2f10feba954aa6820b3ca987ee81d5cc1da3c63ce827301c569dfb39ce\n       , 0xc7c3fe1eebdc7b5a939326e8ddb83e8bf2b780b65678cb62f208b040abdd35e2\n       , 0x0c75c1a15cf34a314ee478f4a5ce0b8a6b36528ef7a820696c3e4246c5a15864\n       , 0x216dc12a108569a3c7cdde4aed43a6c330139dda3ccc4a108905db3861899050\n       , 0xa57be6ae6756f28b02f59dadf7e0d7d8807f10fa15ced1ad3585521a1d995a89\n       , 0x816aef875953716cd7a581f732f53dd435dab66d09c361d2d6592de17755d8a8\n       , 0x9a76893226693b6ea97e6a738f9d10fb3d0b43ae0e8b7d8123ea76ce97989c7e\n       , 0x8daedb9a271529dbb7dc3b607fe5eb2d3211770758dd3b0a3593d2d7954e2d5b\n       , 0x16dbc0aa5dd2c774f505100f733786d8a175fcbbb59c43e1fbff3e1eaf31cb4a\n       , 0x8606cb899c6aeaf51b9db0fe4924a9fd5dabc19f8826f2bc1c1d7da14d2c2c99\n       , 0x8479731aeda57bd37eadb51a507e307f3bd95e69dbca94f3bc21726066ad6dfd\n       , 0x58473a9ea82efa3f3b3d8fc83ed8863127b33ae8deae6307201edb6dde61de29\n       , 0x9a9255d53af116de8ba27ce35b4c7e15640657a0fcb888c70d95431dacd8f830\n       , 0x9eb05ffba39fd8596a45493e18d2510bf3ef065c51d6e13abe66aa57e05cfdb7\n       , 0x81dcc3a505eace3f879d8f702776770f9df50e521d1428a85daf04f9ad2150e0\n       , 0xe3e3c4aa3acbbc85332af9d564bc24165e1687f6b1adcbfae77a8f03c72ac28c\n       , 0x6746c80b4eb56aea45e64e7289bba3edbf45ecf8206481ff6302122984cd526a\n       , 0x2b628e52764d7d62c0868b212357cdd12d9149822f4e9845d918a08d1ae990c0\n       , 0xe4bfe80d58c91994613909dc4b1a12496896c004af7b5701483de45d2823d78e\n       , 0xebb4ba150cef2734345b5d641bbed03a21eafae933c99e009212ef04574a8530\n       , 0x3966ec73b154acc697ac5cf5b24b40bdb0db9e398836d76d4b880e3b2af1aa27\n       , 0xef7e4831b3a84636518d6e4bfce64a43db2a5dda9cca2b44f39033bdc40d6243\n       , 0x7abf6acf5c8e549ddbb15ae8d8b388c1c197e698737c9785501ed1f94930b7d9\n       , 0x88018ded66813f0ca95def474c630692019967b9e36888dadd94124719b682f6\n       , 0x3930876b9fc7529036b008b1b8bb997522a441635a0c25ec02fb6d9026e55a97\n       , 0x0a4049d57e833b5695fac93dd1fbef3166b44b12ad11248662383ae051e15827\n       , 0x81dcc0678bb6a765e48c3209654fe90089ce44ff5618477e39ab286476df052b\n       , 0xe69b3a36a4461912dc08346b11ddcb9db796f885fd01936e662fe29297b099a4\n       , 0x5ac6503b0d8da6917646e6dcc87edc58e94245324cc204f4dd4af01563acd427\n       , 0xdf6dda21359a30bc271780971c1abd56a6ef167e480887888e73a86d3bf605e9\n       , 0xe8e6e47071e7b7df2580f225cfbbedf84ce67746626628d33097e4b7dc571107\n       , 0x53e40ead62051e19cb9ba8133e3e5c1ce00ddcad8acf342a224360b0acc14777\n       , 0x9ccd53fe80be786aa984638462fb28afdf122b34d78f4687ec632bb19de2371a\n       , 0xcbd48052c48d788466a3e8118c56c97fe146e5546faaf93e2bc3c47e45939753\n       , 0x256883b14e2af44dadb28e1b34b2ac0f0f4c91c34ec9169e29036158acaa95b9\n       , 0x4471b91ab42db7c4dd8490ab95a2ee8d04e3ef5c3d6fc71ac74b2b26914d1641\n       , 0xa5eb08038f8f1155ed86e631906fc13095f6bba41de5d4e795758ec8c8df8af1\n       , 0xdc1db64ed8b48a910e060a6b866374c578784e9ac49ab2774092ac71501934ac\n       , 0x285413b2f2ee873d34319ee0bbfbb90f32da434cc87e3db5ed121bb398ed964b\n       , 0x0216e0f81f750f26f1998bc3934e3e124c9945e685a60b25e8fbd9625ab6b599\n       , 0x38c410f5b9d4072050755b31dca89fd5395c6785eeb3d790f320ff941c5a93bf\n       , 0xf18417b39d617ab1c18fdf91ebd0fc6d5516bb34cf39364037bce81fa04cecb1\n       , 0x1fa877de67259d19863a2a34bcc6962a2b25fcbf5cbecd7ede8f1fa36688a796\n       , 0x5bd169e67c82c2c2e98ef7008bdf261f2ddf30b1c00f9e7f275bb3e8a28dc9a2\n       , 0xc80abeebb669ad5deeb5f5ec8ea6b7a05ddf7d31ec4c0a2ee20b0b98caec6746\n       , 0xe76d3fbda5ba374e6bf8e50fadc3bbb9ba5c206ebdec89a3a54cf3dd84a07016\n       , 0x7bba9dc5b5db2071d17752b1044c1eced96aaf2dd46e9b433750e8ea0dcc1870\n       , 0xf29b1b1ab9bab163018ee3da15232cca78ec52dbc34eda5b822ec1d80fc21bd0\n       , 0x9ee3e3e7e900f1e11d308c4b2b3076d272cf70124f9f51e1da60f37846cdd2f4\n       , 0x70ea3b0176927d9096a18508cd123a290325920a9d00a89b5de04273fbc76b85\n       , 0x67de25c02a4aaba23bdc973c8bb0b5796d47cc0659d43dff1f97de174963b68e\n       , 0xb2168e4e0f18b0e64100b517ed95257d73f0620df885c13d2ecf79367b384cee\n       , 0x2e7dec2428853b2c71760745541f7afe9825b5dd77df06511d8441a94bacc927\n       , 0xca9ffac4c43f0b48461dc5c263bea3f6f00611ceacabf6f895ba2b0101dbb68d\n       , 0x7410d42d8fd1d5e9d2f5815cb93417998828ef3c4230bfbd412df0a4a7a2507a\n       , 0x5010f684516dccd0b6ee0852c2512b4dc0066cf0d56f35302978db8ae32c6a81\n       , 0xacaab585f7b79b719935ceb89523ddc54827f75c56883856154a56cdcd5ee988\n       , 0x666de5d1440fee7331aaf0123a62ef2d8ba57453a0769635ac6cd01e633f7712\n       , 0xa6f98658f6eabaf902d8b3871a4b101d16196e8a4b241e1558fe29966e103e8d\n       , 0x891546a8b29f3047ddcfe5b00e45fd55756373105ea8637dfcff547b6ea9535f\n       , 0x18dfbc1ac5d25b0761137dbd22c17c829d0f0ef1d82344e9c89c286694da24e8\n       , 0xb54b9b67f8fed54bbf5a2666dbdf4b23cff1d1b6f4afc985b2e6d3305a9ff80f\n       , 0x7db442e132ba59bc1289aa98b0d3e806004f8ec12811af1e2e33c69bfde729e1\n       , 0x250f37cdc15e817d2f160d9956c71fe3eb5db74556e4adf9a4ffafba74010396\n       , 0x4ab8a3dd1ddf8ad43dab13a27f66a6544f290597fa96040e0e1db9263aa479f8\n       , 0xee61727a0766df939ccdc860334044c79a3c9b156200bc3aa32973483d8341ae\n       , 0x3f68c7ec63ac11ebb98f94b339b05c104984fda50103060144e5a2bfccc9da95\n       , 0x056f29816b8af8f56682bc4d7cf094111da7733e726cd13d6b3e8ea03e92a0d5\n       , 0xf5ec43a28acbeff1f3318a5bcac7c66ddb5230b79db2d105bcbe15f3c1148d69\n       , 0x2a6960ad1d8dd547555cfbd5e4600f1eaa1c8eda34de0374ec4a26eaaaa33b4e\n       , 0xdcc1ea7baab93384f76b796866199754742f7b96d6b4c120165c04a6c4f5ce10\n       , 0x13d5df179221379c6a78c07c793ff53487cae6bf9fe882541ab0e735e3eada3b\n       , 0x8c59e4407641a01e8ff91f9980dc236f4ecd6fcf52589a099a961633967714e1\n       , 0x833b1ac6a251fd08fd6d908fea2a4ee1e040bca93fc1a38ec3820e0c10bd82ea\n       , 0xa244f927f3b40b8f6c391570c765418f2f6e708eac9006c51a7feff4af3b2b9e\n       , 0x3d99ed9550cf1196e6c4d20c259620f858c3d703374c128ce7b590310c83046d\n       , 0x2b35c47d7b87761f0ae43ac56ac27b9f25830367b595be8c240e94600c6e3312\n       , 0x5d11ed37d24dc767305cb7e1467d87c065ac4bc8a426de38991ff59aa8735d02\n       , 0xb836478e1ca0640dce6fd910a5096272c8330990cd97864ac2bf14ef6b23914a\n       , 0x9100f946d6ccde3a597f90d39fc1215baddc7413643d85c21c3eee5d2dd32894\n       , 0xda70eedd23e663aa1a74b9766935b479222a72afba5c795158dad41a3bd77e40\n       , 0xf067ed6a0dbd43aa0a9254e69fd66bdd8acb87de936c258cfb02285f2c11fa79\n       , 0x715c99c7d57580cf9753b4c1d795e45a83fbb228c0d36fbe20faf39bdd6d4e85\n       , 0xe457d6ad1e67cb9bbd17cbd698fa6d7dae0c9b7ad6cbd6539634e32a719c8492\n       , 0xece3ea8103e02483c64a70a4bdcee8ceb6278f2533f3f48dbeedfba94531d4ae\n       , 0x388aa5d3667a97c68d3d56f8f3ee8d3d36091f17fe5d1b0d5d84c93b2ffe40bd\n       , 0x8b6b31b9ad7c3d5cd84bf98947b9cdb59df8a25ff738101013be4fd65e1dd1a3\n       , 0x066291f6bbd25f3c853db7d8b95c9a1cfb9bf1c1c99fb95a9b7869d90f1c2903\n       , 0xa707efbccdceed42967a66f5539b93ed7560d467304016c4780d7755a565d4c4\n       , 0x38c53dfb70be7e792b07a6a35b8a6a0aba02c5c5f38baf5c823fdfd9e42d657e\n       , 0xf2911386501d9ab9d720cf8ad10503d5634bf4b7d12b56dfb74fecc6e4093f68\n       , 0xc6f2bdd52b81e6e4f6595abd4d7fb31f651169d00ff326926b34947b28a83959\n       , 0x293d94b18c98bb3223366b8ce74c28fbdf28e1f84a3350b0eb2d1804a577579b\n       , 0x2c2fa5c0b51533165bc375c22e2781768270a383985d13bd6b67b6fd67f889eb\n       , 0xcaa09b82b72562e43f4b2275c091918e624d911661cc811bb5faec51f6088ef7\n       , 0x24761e45e674395379fb17729c78cb939e6f74c5dffb9c961f495982c3ed1fe3\n       , 0x55b70a82131ec94888d7ab54a7c515255c3938bb10bc784dc9b67f076e341a73\n       , 0x6ab9057b977ebc3ca4d4ce74506c25cccdc566497c450b5415a39486f8657a03\n       , 0x24066deee0ecee15a45f0a326d0f8dbc79761ebb93cf8c0377af440978fcf994\n       , 0x20000d3f66ba76860d5a950688b9aa0d76cfea59b005d859914b1a46653a939b\n       , 0xb92daa79603e3bdbc3bfe0f419e409b2ea10dc435beefe2959da16895d5dca1c\n       , 0xe947948705b206d572b0e8f62f66a6551cbd6bc305d26ce7539a12f9aadf7571\n       , 0x3d67c1b3f9b23910e3d35e6b0f2ccf44a0b540a45c18ba3c36264dd48e96af6a\n       , 0xc7558babda04bccb764d0bbf3358425141902d22391d9f8c59159fec9e49b151\n       , 0x0b732bb035675a50ff58f2c242e4710aece64670079c13044c79c9b7491f7000\n       , 0xd120b5ef6d57ebf06eaf96bc933c967b16cbe6e2bf00741c30aa1c54ba64801f\n       , 0x58d212ad6f58aef0f80116b441e57f6195bfef26b61463edec1183cdb04fe76d\n       , 0xb8836f51d1e29bdfdba325565360268b8fad627473edecef7eaefee837c74003\n       , 0xc547a3c124ae5685ffa7b8edaf96ec86f8b2d0d50cee8be3b1f0c76763069d9c\n       , 0x5d168b769a2f67853d6295f7568be40bb7a16b8d65ba87635d1978d2ab11ba2a\n       , 0xa2f675dc7302638cb60201064ca55077714d71fe096a315f2fe7401277caa5af\n       , 0xc8aab5cd0160ae78cd2e8ac5fb0e093cdb5c4b6052a0a97bb04216826fa7a437\n       , 0xff68ca4035bfeb43fbf145fddd5e43f1cea54f11f7bee13058f027329a4a5fa4\n       , 0x1d4e5487ae3c740f2ba6e541ac91bc2bfcd2999c518d807b426748803a350fd4\n       , 0x6d244e1a06ce4ef578dd0f63aff0936706735119ca9c8d22d86c801414ab9741\n       , 0xdecf7329dbcc827b8fc524c9431e8998029ece12ce93b7b2f3e769a941fb8cea\n       , 0x2fafcc0f2e63cbd07755be7b75ecea0adff9aa5ede2a52fdab4dfd0374cd483f\n       , 0xaa85010dd46a546b535ef4cf5f07d65161e89828f3a77db7b9b56f0df59aae45\n       , 0x07e8e1ee732cb0d356c9c0d1069c89d17adf6a9a334f745ec7867332548ca8e9\n       , 0x0e01e81cada8162bfd5f8a8c818a6c69fedf02ceb5208523cbe5313b89ca1053\n       , 0x6bb6c6472655084399852e00249f8cb247896d392b02d73b7f0dd818e1e29b07\n       , 0x42d4636e2060f08f41c882e76b396b112ef627cc24c43dd5f83a1d1a7ead711a\n       , 0x4858c9a188b0234fb9a8d47d0b4133650a030bd0611b87c3892e94951f8df852\n       , 0x3fab3e36988d445a51c8783e531be3a02be40cd04796cfb61d40347442d3f794\n       , 0xebabc49636bd433d2ec8f0e518732ef8fa21d4d071cc3bc46cd79fa38a28b810\n       , 0xa1d0343523b893fca84f47feb4a64d350a17d8eef5497ece697d02d79178b591\n       , 0x262ebfd9130b7d28760d08ef8bfd3b86cdd3b2113d2caef7ea951a303dfa3846\n       , 0xf76158edd50a154fa78203ed2362932fcb8253aae378903eded1e03f7021a257\n       , 0x26178e950ac722f67ae56e571b284c0207684a6334a17748a94d260bc5f55274\n       , 0xc378d1e493b40ef11fe6a15d9c2737a37809634c5abad5b33d7e393b4ae05d03\n       , 0x984bd8379101be8fd80612d8ea2959a7865ec9718523550107ae3938df32011b\n       , 0xc6f25a812a144858ac5ced37a93a9f4759ba0b1c0fdc431dce35f9ec1f1f4a99\n       , 0x924c75c94424ff75e74b8b4e94358958b027b171df5e57899ad0d4dac37353b6\n       , 0x0af35892a63f45931f6846ed190361cd073089e077165714b50b81a2e3dd9ba1\n       , 0xcc80cefb26c3b2b0daef233e606d5ffc80fa17427d18e30489673e06ef4b87f7\n       , 0xc2f8c8117447f3978b0818dcf6f70116ac56fd184dd1278494e103fc6d74a887\n       , 0xbdecf6bfc1ba0df6e862c831992207796acc797968358828c06e7a51e090098f\n       , 0x24d1a26e3dab02fe4572d2aa7dbd3ec30f0693db26f273d0ab2cb0c13b5e6451\n       , 0xec56f58b09299a300b140565d7d3e68782b6e2fbeb4b7ea97ac057989061dd3f\n       , 0x11a437c1aba3c119ddfab31b3e8c841deeeb913ef57f7e48f2c9cf5a28fa42bc\n       , 0x53c7e6114b850a2cb496c9b3c69a623eaea2cb1d33dd817e4765edaa6823c228\n       , 0x154c3e96fee5db14f8773e18af14857913509da999b46cdd3d4c169760c83ad2\n       , 0x40b9916f093e027a8786641818920620472fbcf68f701d1b680632e6996bded3\n       , 0x24c4cbba07119831a726b05305d96da02ff8b148f0da440fe233bcaa32c72f6f\n       , 0x5d201510250020b783689688abbf8ecf2594a96a08f2bfec6ce0574465dded71\n       , 0x043b97e336ee6fdbbe2b50f22af83275a4084805d2d5645962454b6c9b8053a0\n       , 0x564835cbaea774948568be36cf52fcdd83934eb0a27512dbe3e2db47b9e6635a\n       , 0xf21c33f47bde40a2a101c9cde8027aaf61a3137de2422b30035a04c270894183\n       , 0x9db0ef74e66cbb842eb0e07343a03c5c567e372b3f23b943c788a4f250f67891\n       , 0xab8d08655ff1d3fe8758d562235fd23e7cf9dcaad658872a49e5d3183b6ccebd\n       , 0x6f27f77e7bcf46a1e963ade0309733543031dccdd47caac174d7d27ce8077e8b\n       , 0xe3cd54da7e444caa6207569525a670ebae1278de4e3fe2684b3e33f5ef90cc1b\n       , 0xb2c3e33a51d22c4c08fc0989c873c9cc4150579b1e6163fa694ad51d53d712dc\n       , 0xbe7fda983e13189b4c77e0a80920b6e0e0ea80c3b84dbe7e7117d253f48112f4\n       , 0xb6008c28fae08aa427e5bd3aad36f10021f16c77cfeabed07f97cc7dc1f1284a\n       , 0x6e4e6760c538f2e97b3adbfbbcde57f8966b7ea8fcb5bf7efec913fd2a2b0c55\n       , 0x4ae51fd1834aa5bd9a6f7ec39fc663338dc5d2e20761566d90cc68b1cb875ed8\n       , 0xb673aad75ab1fdb5401abfa1bf89f3add2ebc468df3624a478f4fe859d8d55e2\n       , 0x13c9471a9855913539836660398da0f3f99ada08479c69d1b7fcaa3461dd7e59\n       , 0x2c11f4a7f99a1d23a58bb636350fe849f29cbac1b2a1112d9f1ed5bc5b313ccd\n       , 0xc7d3c0706b11ae741c05a1ef150dd65b5494d6d54c9a86e2617854e6aeeebbd9\n       , 0x194e10c93893afa064c3ac04c0dd808d791c3d4b7556e89d8d9cb225c4b33339\n       , 0x6fc4988b8f78546b1688991845908f134b6a482e6994b3d48317bf08db292185\n       , 0x5665beb8b0955525813b5981cd142ed4d03fba38a6f3e5ad268e0cc270d1cd11\n       , 0xb883d68f5fe51936431ba4256738053b1d0426d4cb64b16e83badc5e9fbe3b81\n       , 0x53e7b27ea59c2f6dbb50769e43554df35af89f4822d0466b007dd6f6deafff02\n       , 0x1f1a0229d4640f01901588d9dec22d13fc3eb34a61b32938efbf5334b2800afa\n       , 0xc2b405afa0fa6668852aee4d88040853fab800e72b57581418e5506f214c7d1f\n       , 0xc08aa1c286d709fdc7473744977188c895ba011014247e4efa8d07e78fec695c\n       , 0xf03f5789d3336b80d002d59fdf918bdb775b00956ed5528e86aa994acb38fe2d\n       ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/TestHMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the HMAC-SHA256 specification (including hmacSHA256) and the property pass that checks these two known test vectors against their expected 256-bit outputs."},{"role":"assistant","content":"```cryptol\nmodule TestHMAC where\n\nimport HMAC\nimport SHA256\n\nproperty pass =\n    ~zero ==\n    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] \"Hi There\" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\n    , hmacSHA256 \"Jefe\" \"what do ya want for nothing?\" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\n    ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/CryptoBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that specifies the NaCl-style CryptoBox and CryptoSecretBox constructions using Curve25519, XSalsa20, and Poly1305, including the functions crypto_box, crypto_box_open, crypto_secretbox, crypto_secretbox_open, and properties cat_in_a_box, hat_in_a_box, and crypto_box_kats with katTest1."},{"role":"assistant","content":"```cryptol\nmodule CryptoBox where\n\nimport Salsa20\nimport Poly1305\nimport CfrgCurves\n\ncrypto_box : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes)) => [msgBytes][8] -> [24][8] -> Public25519 -> Private25519 -> [msgBytes + 16][8]\ncrypto_box m n pub priv = crypto_secretbox m k n\n where\n  s          = Curve25519 priv pub\n  k          = HSalsa20_bytes `{r=20} s zero\n\ncrypto_box_open : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes)) => [msgBytes+16][8] -> [24][8] -> Public25519 -> Private25519 -> (Bit,[msgBytes][8])\ncrypto_box_open box n pub priv = crypto_secretbox_open box k n\n where\n  (tag,ct)  = splitAt `{16} box\n  s         = Curve25519 priv pub\n  k         = HSalsa20_bytes `{r=20} s zero\n\ncrypto_secretbox : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes))\n                => [msgBytes][8] -> [32][8] -> [24][8] -> [msgBytes + 16][8]\ncrypto_secretbox m k n = box\n where\n  blob       = XSalsa20_encrypt `{r=20} k n ((zero : [32][8]) # m)\n  authKey    = join (take `{32} blob)\n  ciphertext = drop `{32} blob\n  authTag    = Poly1305 authKey ciphertext\n  box        = authTag # ciphertext\n\ncrypto_secretbox_open : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes))\n                     => [msgBytes + 16][8] -> [32][8] -> [24][8] -> (Bit,[msgBytes][8])\ncrypto_secretbox_open box k n = (valid,pt)\n where\n  (tag,ct)  = splitAt `{16} box\n  blob      = XSalsa20_encrypt `{r=20} k n ((zero : [32][8]) # ct)\n  authKey   = join (take `{32} blob)\n  plaintext = drop blob                  : [msgBytes][8]\n  cTag      = Poly1305 authKey ct\n  valid     = cTag == tag\n  pt        = if valid then plaintext else zero\n\nproperty cat_in_a_box priv1 priv2 msg nonce = open == msg\n  where pub1 = Curve25519 priv1 basePoint25519\n        pub2 = Curve25519 priv2 basePoint25519\n        box  = crypto_box (msg : [100][8]) nonce pub2 priv1\n        open = (crypto_box_open box nonce pub1 priv2).1\n\nproperty hat_in_a_box k msg nonce = open == msg\n  where box  = crypto_secretbox (msg : [88][8]) k nonce\n        open = (crypto_secretbox_open box k nonce).1\n\nproperty crypto_box_kats = zero != [ katTest1 ]\n\nkatTest1 = crypto_secretbox \"hello\" zero zero == split 0xc769f9d535dc338e99ac93440502c7ceae5bd79391\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Salsa20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that fully specifies the Salsa20 and XSalsa20 stream ciphers (including quarterround, rowround, columnround, doubleround, HSalsa20, key\/nonce expansion, and encryption) along with the given test vectors and algebraic properties as Cryptol properties."},{"role":"assistant","content":"```cryptol\nmodule Salsa20 where\n\nimport LittleEndian\n\nquarterround : [4][32] -> [4][32]\nquarterround [y0, y1, y2, y3] = [z0, z1, z2, z3]\n  where\n    z1 = y1 ^ ((y0 + y3) <<< 0x7)\n    z2 = y2 ^ ((z1 + y0) <<< 0x9)\n    z3 = y3 ^ ((z2 + z1) <<< 0xd)\n    z0 = y0 ^ ((z3 + z2) <<< 0x12)\n\nproperty quarterround_passes_tests =\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000000] == [0x00000000, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (quarterround [0x00000001, 0x00000000, 0x00000000, 0x00000000] == [0x08008145, 0x00000080, 0x00010200, 0x20500000]) \/\\\n  (quarterround [0x00000000, 0x00000001, 0x00000000, 0x00000000] == [0x88000100, 0x00000001, 0x00000200, 0x00402000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000001, 0x00000000] == [0x80040000, 0x00000000, 0x00000001, 0x00002000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000001] == [0x00048044, 0x00000080, 0x00010000, 0x20100001]) \/\\\n  (quarterround [0xe7e8c006, 0xc4f9417d, 0x6479b4b2, 0x68c67137] == [0xe876d72b, 0x9361dfd5, 0xf1460244, 0x948541a3]) \/\\\n  (quarterround [0xd3917c5b, 0x55f1c407, 0x52a58a7a, 0x8f887a3b] == [0x3e2f308c, 0xd90a8f36, 0x6ab2a923, 0x2883524c])\n\nrowround : [16][32] -> [16][32]\nrowround [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15] =\n    [z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15]\n  where\n    [ z0,  z1,  z2,  z3] = quarterround [ y0,  y1,  y2,  y3]\n    [ z5,  z6,  z7,  z4] = quarterround [ y5,  y6,  y7,  y4]\n    [z10, z11,  z8,  z9] = quarterround [y10, y11,  y8,  y9]\n    [z15, z12, z13, z14] = quarterround [y15, y12, y13, y14]\n\nproperty rowround_passes_tests =\n  (rowround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n            [0x08008145, 0x00000080, 0x00010200, 0x20500000,\n             0x20100001, 0x00048044, 0x00000080, 0x00010000,\n             0x00000001, 0x00002000, 0x80040000, 0x00000000,\n             0x00000001, 0x00000200, 0x00402000, 0x88000100]) \/\\\n  (rowround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n             0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n             0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n             0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n            [0xa890d39d, 0x65d71596, 0xe9487daa, 0xc8ca6a86,\n             0x949d2192, 0x764b7754, 0xe408d9b9, 0x7a41b4d1,\n             0x3402e183, 0x3c3af432, 0x50669f96, 0xd89ef0a8,\n             0x0040ede5, 0xb545fbce, 0xd257ed4f, 0x1818882d])\n\nrowround_opt : [16][32] -> [16][32]\nrowround_opt ys = join [ (quarterround (yi<<<i))>>>i | yi <- split ys | i <- [0 .. 3] : [_][8] ]\n\nproperty rowround_opt_is_rowround ys = rowround ys == rowround_opt ys\n\ncolumnround : [16][32] -> [16][32]\ncolumnround [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15] =\n    [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15]\n  where\n    [ y0,  y4,  y8, y12] = quarterround [ x0,  x4,  x8, x12]\n    [ y5,  y9, y13,  y1] = quarterround [ x5,  x9, x13,  x1]\n    [y10, y14,  y2,  y6] = quarterround [x10, x14,  x2,  x6]\n    [y15,  y3,  y7, y11] = quarterround [x15,  x3,  x7, x11]\n\nproperty columnround_passes_tests =\n  (columnround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x10090288, 0x00000000, 0x00000000, 0x00000000,\n                0x00000101, 0x00000000, 0x00000000, 0x00000000,\n                0x00020401, 0x00000000, 0x00000000, 0x00000000,\n                0x40a04001, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (columnround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n                0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n                0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n                0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n               [0x8c9d190a, 0xce8e4c90, 0x1ef8e9d3, 0x1326a71a,\n                0x90a20123, 0xead3c4f3, 0x63a091a0, 0xf0708d69,\n                0x789b010c, 0xd195a681, 0xeb7d5504, 0xa774135c,\n                0x481c2027, 0x53a8e4b5, 0x4c1f89c5, 0x3f78c9c8])\n\ncolumnround_opt : [16][32] -> [16][32]\ncolumnround_opt xs = join (transpose [ (quarterround (xi<<<i))>>>i | xi <- transpose(split xs) | i <- [0 .. 3] : [_][8] ])\n\ncolumnround_opt_is_columnround xs = columnround xs == columnround_opt xs\n\nproperty columnround_is_transpose_of_rowround ys =\n  rowround ys == join(transpose(split`{4}(columnround xs)))\n  where xs = join(transpose(split`{4} ys))\n\ndoubleround : [16][32] -> [16][32]\ndoubleround(xs) = rowround(columnround(xs))\n\nproperty doubleround_passes_tests =\n  (doubleround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x8186a22d, 0x0040a284, 0x82479210, 0x06929051,\n                0x08000090, 0x02402200, 0x00004000, 0x00800000,\n                0x00010200, 0x20400000, 0x08008104, 0x00000000,\n                0x20500000, 0xa0000040, 0x0008180a, 0x612a8020]) \/\\\n  (doubleround [0xde501066, 0x6f9eb8f7, 0xe4fbbd9b, 0x454e3f57,\n                0xb75540d3, 0x43e93a4c, 0x3a6f2aa0, 0x726d6b36,\n                0x9243f484, 0x9145d1e8, 0x4fa9d247, 0xdc8dee11,\n                0x054bf545, 0x254dd653, 0xd9421b6d, 0x67b276c1] ==\n               [0xccaaf672, 0x23d960f7, 0x9153e63a, 0xcd9a60d0,\n                0x50440492, 0xf07cad19, 0xae344aa0, 0xdf4cfdfc,\n                0xca531c29, 0x8e7943db, 0xac1680cd, 0xd503ca00,\n                0xa74b2ad6, 0xbc331c5c, 0x1dda24c7, 0xee928277])\n\nSalsa20 : {r} (8 >= width r) => [64][8] -> [64][8]\nSalsa20 xs = join ar\n  where\n    ar = [ littleendian_inverse words | words <- xw + zs@(`r\/2 : [8]) ]\n    xw = [ littleendian xi | xi <- split xs ]\n    zs = [xw] # [ doubleround zi | zi <- zs ]\n\nproperty Salsa20_bijective a b = (a == b) || (Salsa20 `{r=20} a != Salsa20 `{r=20} b)\nproperty Salsa20_passes_tests =\n  (Salsa20 `{r=20}\n           [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0] ==\n           [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]) \/\\\n  (Salsa20 `{r=20}\n            [211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37, 191, 187, 234, 136,\n             49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,  86,  16, 179, 207,\n             31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113, 238,  55, 204,  36,\n             79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,  88, 118, 104,  54] ==\n           [109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,  26, 110, 170, 154,\n             29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,  69, 144,  51,  57,\n            118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35,  27, 111, 114, 114,\n            219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158, 179,  19,  48, 202]) \/\\\n  (Salsa20 `{r=20}\n           [ 88, 118, 104,  54,  79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,\n            191, 187, 234, 136, 211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37,\n             86,  16, 179, 207,  49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,\n            238,  55, 204,  36,  31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113] ==\n           [179,  19,  48, 202, 219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158,\n             26, 110, 170, 154, 109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,\n             69, 144,  51,  57,  29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,\n             27, 111, 114, 114, 118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35])\n\nproperty Salsa20_has_no_collisions x1 x2 =\n    x1 == x2 \\\/ doubleround x1 != doubleround x2\n\nproperty Salsa20_passes_scrypt_tests =\n  Salsa20 `{r=8}\n          [ 0x7e, 0x87, 0x9a, 0x21, 0x4f, 0x3e, 0xc9, 0x86, 0x7c, 0xa9, 0x40, 0xe6, 0x41, 0x71, 0x8f, 0x26\n          , 0xba, 0xee, 0x55, 0x5b, 0x8c, 0x61, 0xc1, 0xb5, 0x0d, 0xf8, 0x46, 0x11, 0x6d, 0xcd, 0x3b, 0x1d\n          , 0xee, 0x24, 0xf3, 0x19, 0xdf, 0x9b, 0x3d, 0x85, 0x14, 0x12, 0x1e, 0x4b, 0x5a, 0xc5, 0xaa, 0x32\n          , 0x76, 0x02, 0x1d, 0x29, 0x09, 0xc7, 0x48, 0x29, 0xed, 0xeb, 0xc6, 0x8d, 0xb8, 0xb8, 0xc2, 0x5e\n          ]\n   == [ 0xa4, 0x1f, 0x85, 0x9c, 0x66, 0x08, 0xcc, 0x99, 0x3b, 0x81, 0xca, 0xcb, 0x02, 0x0c, 0xef, 0x05\n      , 0x04, 0x4b, 0x21, 0x81, 0xa2, 0xfd, 0x33, 0x7d, 0xfd, 0x7b, 0x1c, 0x63, 0x96, 0x68, 0x2f, 0x29\n      , 0xb4, 0x39, 0x31, 0x68, 0xe3, 0xc9, 0xe6, 0xbc, 0xfe, 0x6b, 0xc5, 0xb7, 0xa0, 0x6d, 0x96, 0xba\n      , 0xe4, 0x24, 0xcc, 0x10, 0x2c, 0x91, 0x74, 0x5c, 0x24, 0xad, 0x67, 0x3d, 0xc7, 0x61, 0x8f, 0x81\n      ]\n\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(k, n) = z\n  where\n    [s0, s1, s2, s3] = split \"expand 32-byte k\" : [4][4][8]\n    [t0, t1, t2, t3] = split \"expand 16-byte k\" : [4][4][8]\n    x = if(`a == (2 : [8])) then s0 # k0 # s1 # n # s2 # k1 # s3\n                            else t0 # k0 # t1 # n # t2 # k0 # t3\n    z = Salsa20 `{r=20} x\n    [k0, k1] = (split(k#zero)):[2][16][8]\n\nSalsa20_encrypt : {a, l} (a >= 1, 2 >= a, l <= 2^^70) => ([16*a][8], [8][8], [l][8]) -> [l][8]\nSalsa20_encrypt(k, v, m) = c\n  where\n    salsa = take (join [ Salsa20_expansion(k, v#(split i)) | i <- [0, 1 ... ] ])\n    c     = m ^ salsa\n\nHSalsa20 : {r} (8 >= width r) => Key -> Nonce -> [8][32]\nHSalsa20 key0 nonce0 = zs @@ ([0,5,10,15,6,7,8,9] : [_][8])\n  where\n  zs    = infZs @ (`r\/2 :[8])\n  infZs = [xs] # [ doubleround x | x <- infZs ]\n\n  nonce                         = [ littleendian (split n) | n <- split (join nonce0)]\n  [x0,x5,x10,x15]               = Salsa20_Constant\n  [x1,x2,x3,x4,x11,x12,x13,x14] = [ littleendian (split k) | k <- split (join key0)]\n  [x6,x7,x8,x9]                 = nonce @@ ([0..3] : [_][8])\n\n  xs : [16][32]\n  xs     = [x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15]\n\nHSalsa20_bytes : {r} (8 >= width r) => Key -> Nonce -> [32][8]\nHSalsa20_bytes key0 nonce0 = join [littleendian_inverse x | x <- HSalsa20 `{r=r} key0 nonce0]\n\ntype Key      = [256\/8][8]\ntype Nonce    = [192\/8][8]\ntype Counter  = [64]\n\nSalsa20_Constant : [4][32]\nSalsa20_Constant = [littleendian (split x) | x <- split (join \"expand 32-byte k\") : [4][32]]\n\nXSalsa20 : {r} (8 >= width r) => Key -> Nonce -> Counter -> [64][8]\nXSalsa20 key0 nonce0 ctr =\n    split (join [littleendian (split (x' + z')) | x' <- xs' | z' <- zs'])\n  where\n  nonce                         = [ littleendian (split n) | n <- split (join nonce0)]\n\n  subKey = HSalsa20 `{r=r} key0 nonce0 \n  [x'0,x'5,x'10,x'15]                   = Salsa20_Constant\n  [x'1,x'2,x'3,x'4,x'11,x'12,x'13,x'14] = subKey\n  [x'6,x'7]                             = nonce @@ ([4,5] : [_][8])\n  [x'8,x'9]                             = reverse (split ctr)\n\n  xs', zs' : [16][32]\n  xs'       = [ x'0 ,x'1 ,x'2 ,x'3 ,x'4 ,x'5 ,x'6 ,x'7 ,x'8\n              , x'9 ,x'10 ,x'11 ,x'12 ,x'13 ,x'14 ,x'15\n              ]\n  infZs'    = [xs'] # [ doubleround x | x <- infZs' ]\n  zs'       = infZs' @ (`r\/2 : [8])\n\nXSalsa20_expansion : {n,r} (8 >= width r, 64 >= width n) => Key -> Nonce -> [n][8]\nXSalsa20_expansion k n = take (join ks)\n   where\n   ks = [XSalsa20 `{r=r} k n i | i <- [0...]]\n\nXSalsa20_encrypt : {n,r} (8 >= width r, 64 >= width n) => Key -> Nonce -> [n][8] -> [n][8]\nXSalsa20_encrypt k n msg = ks ^ msg\n where ks = XSalsa20_expansion `{r=r} k n\n\nproperty test =\n    ct == [0x00, 0x2d, 0x45, 0x13, 0x84, 0x3f, 0xc2, 0x40, 0xc4, 0x01, 0xe5, 0x41]\n  where\n   ct    = XSalsa20_encrypt `{r=20} key nonce \"Hello world!\"\n   key   = \"this is 32-byte key for xsalsa20\"\n   nonce = \"24-byte nonce for xsalsa\"\n\nproperty theorem1 a = quarterround [a, -a, a, -a] == [a,-a,a,-a]\nproperty theorem2 a b c d = rowround val == val\n    where val    = [a,-a,a,-a\n                   ,b,-b,b,-b\n                   ,c,-c,c,-c\n                   ,d,-d,d,-d]\nproperty theorem3 a b c d = columnround val == val\n    where val    = [a,-b,c,-d\n                   ,-a,b,-c,d\n                   ,a,-b,c,-d\n                   ,-a,b,-c,d]\nproperty theorem4 a = doubleround val == val\n    where val    = [a,-a,a,-a\n                   ,-a,a,-a,a\n                   ,a,-a,a,-a\n                   ,-a,a,-a,a]\nproperty theorem7 a b =\n    a ^ b != diff \\\/ Salsa20Words a == Salsa20Words b\n where\n  diff = [ 0x80000000 | _ <- [0..15]:[_][4] ]\n\nSalsa20Words : [16][32] -> [16][32]\nSalsa20Words x = [join (reverse r) | r <- split `{each=4} (Salsa20 `{r=20} (join [reverse (split `{4} v) | v <- x]))]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/PBKDF2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `PBKDF2` that implements PBKDF2 using HMAC-SHA256 with parameters `pwBytes`, `saltBytes`, `dkLenBits`, and `C`, and include a property `test1` that checks the derived key for password \"passwd\" and salt \"salt\" against the given 512-bit test vector."},{"role":"assistant","content":"```cryptol\nmodule PBKDF2 where\n\nimport SHA256\nimport HMAC\n\npbkdf2 : {pwBytes, saltBytes, dkLenBits, C}\n         ( 64 >= width (8 * pwBytes)\n         , dkLenBits >= 1\n         , fin dkLenBits\n         , C >= 1\n         , 16 >= width C\n         , 32 >= width (4 + saltBytes)\n         , 32 >= width ((dkLenBits + 255)\/256)\n         )\n      => [pwBytes][8] -> [saltBytes][8] -> [dkLenBits]\npbkdf2 P S = take `{dkLenBits} (join Ts)\n where\n Ts : [_][256]\n Ts = [ inner `{C=C} P (split (hmacSHA256 P (S # split i))) | i <- [1..len] : [_][32] ]\n type len = (dkLenBits + 255)\/256\n\ninner : {pwBytes, C}\n         ( 64 >= width (8 * pwBytes)\n         , C >= 1, 16 >= width C\n         )\n     =>  [pwBytes][8] -> [32][8] -> [256]\ninner P U0 = (Ts @ 0).0  where\n    Ts = [(join U0, U0)] # [ F P t u  | _ <- [1..C] : [_][16] | (t,u) <- Ts ]\n\nF : {pwBytes} ( 64 >= width (8 * pwBytes)\n              ) => [pwBytes][8] -> [256] -> [32][8] -> ([256],[32][8])\nF P Tprev Uprev = (Tnext,Unext)\n  where\n  Unext = split (hmacSHA256 P Uprev)\n  Tnext = Tprev ^ join Unext\n\ntest1 : Bit\nproperty test1 = pbkdf2 `{C=1,dkLenBits=64*8} \"passwd\" \"salt\" == 0x55ac046e56e3089fec1691c22544b605f94185216dde0465e68b9d57c20dacbc49ca9cccf179b645991664b39d77ef317c71b845b1e30bd509112041d3a19783\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Base64.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module that implements Base64 encoding\/decoding with functions `base64enc` and `base64dec` and properties proving that decoding is the inverse of encoding (up to padding) and that they satisfy the given type-level length and padding constraints."},{"role":"assistant","content":"```cryptol\nmodule Base64 where\n\ntype Enc64 n = 4*(((3-(n%3))%3) + n)\/3\n\nbase64enc : {n,m,padZ} (4*(padZ + n)\/3 == m, fin n, fin m, padZ == (3-(n%3))%3, 2>=padZ)\n          => [n][8] -> [Enc64 n][8]\nbase64enc ns = take `{m} (chunks # padEq)\n where\n  chunks      = take `{(4*n+2)\/3} (base64chunks `{(n+2)\/3} (ns # padZero))\n  padZero     = take `{padZ} [zero | _ <- [1..2] : [_][2]]\n  padEq       = \"==\"\n\nalphabet = ['A'..'Z'] # ['a'..'z'] # ['0'..'9'] # \"+\/\"\n\nbase64chunks : {n} (fin n) => [n*3][8] -> [n*4][8]\nbase64chunks m = [basify x |  x <- ns]\n where\n  ns = split (join m) : [_][6]\n  basify : [6] -> [8]\n  basify x = alphabet @ x\n\nbase64dec : {n,m} (fin m, 4*n == 3*m, fin n) => [m][8] -> ([n][8],[2])\nbase64dec ms = (split (join [debase x | x <- ms]), nrEq)\n where\n nrEq : [2]\n nrEq = sum [ zero # [x == '='] | x <- take `{2} (reverse ms # [zero,zero]) ]\n\n debase : [8] -> [6]\n debase x = drop `{2} (debase' x)\n\n debase' : [8] -> [8]\n debase' x =\n    if x >= 'A' \/\\ x <= 'Z'\n        then x - 'A'\n        else if x >= 'a' \/\\ x <= 'z'\n              then x - 'a' + 26\n              else if x >= '0' \/\\ x <= '9'\n                    then x - '0' + 52\n                    else if x == '+'\n                        then 62\n                        else if x == '\/'\n                                then 63\n                                else zero \/\/ Pad bytes are decoded as NUL\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Base58.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the Base58 module that defines the functions base58enc and base58dec as shown, and add a property proving that for all valid inputs x, base58dec (base58enc x) == x."},{"role":"assistant","content":"```cryptol\nmodule Base58 where\n\nbase58enc : {n,m} (fin n, fin m, n >= 6 ) => [n] -> [m][8]\nbase58enc ns = [ x.1 | x <- reverse (take `{m} (drop `{1} enc))]\n where\n  enc      = [(ns,zero)] # [ (n\/58,charOf (n%58)) | (n,_) <- enc ]\n  charOf x = charMap @ x\n\ncharMap : [58][8]\ncharMap = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\nbase58dec : {n,m} (fin n, fin m, n >= 1, n >= width m, n >= 8) => [m][8] -> [n]\nbase58dec ms = sum [ (dec m) * 58 ^^ i | m <- reverse ms | i <- [0..m] ]\n where\n  dec : [8] -> [n]\n  dec x = zero # dec' x\n\n  dec' : [8] -> [8]\n  dec' x =\n    if x >= 'm'\n     then x - 'm' + 44\n     else if x >= 'a'\n            then x - 'a' + 33\n            else if x >= 'P'\n                  then x - 'P' + 22\n                  else if x > 'I'\n                        then x - 'J' + 17\n                        else if x >= 'A'\n                              then x - 'A' + 9\n                              else x - '1'\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/bv.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the bit-vector utility functions uext, iext, safe_add, safe_sub, is_normal, safe_product, safe_mod, adc, and sbb with the same polymorphic types and behavior, including carry\/borrow handling for addition and subtraction."},{"role":"assistant","content":"```cryptol\nmodule bv where\n\nuext : {a, b} (fin b,fin a) => [a] -> [a+b]\nuext(x) = zero # x\n\niext : {a, b} (fin b,fin a) => [a] -> [a+b]\niext(x) = (if x@0 then ~zero else zero) # x\n\nsafe_add : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_add(x,y) = uext(x) + uext(y)\n\nsafe_sub : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_sub(x,y) = uext(x) - uext(y)\n\nis_normal : {a} (fin a) => [a] -> [a] -> Bit\nis_normal p x = (x < p)\n\nsafe_product : {a} (fin a) => ([a],[a]) -> [2*a]\nsafe_product(x,y) = uext(x) * uext(y)\n\nsafe_mod : {a, b} (fin a, fin b) => ([b],[a+b]) -> [b]\nsafe_mod(p,x) = drop `{a} (x % uext(p))\n\nadc : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nadc(x,y) = (drop(sm), sm@0)\n  where sm = safe_add(x,y)\n\nsbb : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nsbb(x,y) = (drop(r), r@0)\n  where r = ([False] # x) - ([False] # y)\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/LittleEndian.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the little-endian packing\/unpacking functions `littleendian : {a}(fin a) => [a][8] -> [a*8]` and `littleendian_inverse : [32] -> [4][8]`, and properties `littleendian_passes_tests` and `littleendian_is_invertable` as specified."},{"role":"assistant","content":"```cryptol\nmodule LittleEndian where\n\nlittleendian : {a}(fin a) => [a][8] -> [a*8]\nlittleendian b = join(reverse b)\n\nproperty littleendian_passes_tests =\n  (littleendian [  0,   0,   0,   0] == 0x00000000) &&\n  (littleendian [ 86,  75,  30,   9] == 0x091e4b56) &&\n  (littleendian [255, 255, 255, 250] == 0xfaffffff)\n\nlittleendian_inverse : [32] -> [4][8]\nlittleendian_inverse b = reverse(split b)\n\nproperty littleendian_is_invertable b = littleendian_inverse(littleendian b) == b\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES\/SBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `AES::SBox` that specifies the AES S-box and its inverse as arrays of 256 GF(2^8) elements, using `SubByte` and `InvSubByte` over all byte inputs 0..255."},{"role":"assistant","content":"```cryptol\nmodule AES::SBox where\n\nimport AES::GF28\nimport AES::SubBytePlain\n\ntype SBox = [256] GF28\n\nsbox : SBox\nsbox = [ SubByte x | x <- [0 .. 255] ]\n\nsboxInv : SBox\nsboxInv = [ InvSubByte x | x <- [0 .. 255] ]\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES\/SubByteSBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the module `AES::SubByteSBox` that provides the functions `SubByte : GF28 -> GF28` and `InvSubByte : GF28 -> GF28` using the AES S-box and inverse S-box, importing `AES::GF28` and `AES::SBox` as needed."},{"role":"assistant","content":"```cryptol\nmodule AES::SubByteSBox where\n\nimport AES::GF28\nimport AES::SBox\n\nSubByte : GF28 -> GF28\nSubByte b = sbox @ b\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = sboxInv @ b\n```"}]}
{"filename":"cryptol\/lib\/Cryptol\/Reference.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Cryptol::Reference` that implements polynomial multiplication `pmult`, division `pdiv`, and modulus `pmod` over GF(2), plus generic higher-order functions `foldl`, `scanl`, and `iterate`, with the same polymorphic types and behaviors as described."},{"role":"assistant","content":"```cryptol\nmodule Cryptol::Reference where\n\npmult : {u, v} (fin u, fin v) => [1 + u] -> [1 + v] -> [1 + u + v]\npmult x y = last zs\n  where\n    zs = [0] # [ (z << 1) ^ (if yi then 0 # x else 0) | yi <- y | z <- zs ]\n\npdiv : {u, v} (fin u, fin v) => [u] -> [v] -> [u]\npdiv x y = [ z ! degree | z <- zs ]\n  where\n    degree : [width v]\n    degree = last (ds : [1 + v]_)\n      where ds = [0\/0] # [if yi then i else d | yi <- reverse y | i <- [0..v] | d <- ds ]\n\n    reduce : [v] -> [v]\n    reduce u = if u ! degree then u ^ y else u\n\n    zs : [u][v]\n    zs = [ tail (reduce z # [xi]) | z <- [0] # zs | xi <- x ]\n\npmod : {u, v} (fin u, fin v) => [u] -> [1 + v] -> [v]\npmod x y = if y == 0 then 0\/0 else last zs\n  where\n    degree : [width v]\n    degree = last (ds : [2 + v]_)\n      where ds = [0\/0] # [if yi then i else d | yi <- reverse y | i <- [0..v] | d <- ds ]\n\n    reduce : [1 + v] -> [1 + v]\n    reduce u = if u ! degree then u ^ y else u\n\n    powers : [inf][1 + v]\n    powers = [reduce 1] # [ reduce (p << 1) | p <- powers ]\n\n    zs = [0] # [ z ^ (if xi then tail p else 0) | xi <- reverse x | p <- powers | z <- zs ]\n\nfoldl : {n, a, b} (fin n) => (a -> b -> a) -> a -> [n]b -> a\nfoldl f z bs = last (scanl f z bs)\n\nscanl : {n, a, b}  (a -> b -> a) -> a -> [n]b -> [1+n]a\nscanl f z bs = as\n  where\n    as = [z] # [ f a b | a <- as | b <- bs ]\n\niterate : {a} (a -> a) -> a -> [inf]a\niterate f z = xs\n  where xs = [z] # [ f x | x <- xs ]\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol_eval\/test-files\/M.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `M` containing the given functions, types, and constants, ensuring the polymorphic constraints and sizes match, including the property-like predicate `isSqrtOf9 : [8] -> Bit` that checks whether its argument squared equals 9."},{"role":"assistant","content":"```cryptol\nmodule M where\nf : [8] -> [2][8]\nf x = repeat x\n\ng : [8] -> [2][8]\ng x = [x, x]\n\nh : [2][8] -> [2][8]\nh x = x\n\nm : {a} (fin a, a > 42) => Z a\nm = 42\n\ntwo : [15]\ntwo = 2\n\nthree : [16]\nthree = 3\n\nfour : [17]\nfour = 4\n\nid : {a} a -> a\nid x = x\n\ntype Word8 = [8]\ntype Twenty a = [20]a\n\nisSqrtOf9 : [8] -> Bit\nisSqrtOf9 x = x*x == 9\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Names.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Names` that defines the given parameters, types, functions, primitive declarations, and the property `enc_correct : [64] -> Bit` stating `x == enc (enc x)` for all 64-bit inputs `x`."},{"role":"assistant","content":"```cryptol\nmodule Names where\n\nparameter\n  key : [64]\n\nenc : [64] -> [64]\nenc x = x ^ key\n\nenc_correct : [64] -> Bit\nproperty enc_correct x =\n  x == enc (enc x)\n\nprimitive prim : [64] -> [64]\n\n(-!) : [64] -> [64] -> [64]\nx -! y = if y > x then 0 else x - y\n\nparameter\n  type a : #\n\ntype b = a\n\ntype constraint fin_b = fin b\n\nprimitive type c : *\n\nnewtype d = { un_d : c }\n\nsubmodule M where\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Id.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define in Cryptol the polymorphic identity function `id : {n} (fin n) => [n] -> [n]` that returns its input unchanged, matching the given specification."},{"role":"assistant","content":"```cryptol\nmodule Id where\n\nid : {n} (fin n) => [n] -> [n]\nid a = a\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/CplxQNewtype.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module defining a Rational-based complex number newtype CplxQ with addition, multiplication, equality, and properties cplxAddAssoc, cplxMulAssoc, and cplxMulDistrib that verify associativity and left distributivity for these operations."},{"role":"assistant","content":"```cryptol\ntype Q = Rational\n\nfortyTwo : Q\nfortyTwo = 42\n\nnewtype CplxQ =\n  { real : Q, imag : Q }\n\nembedQ : Q -> CplxQ\nembedQ x = CplxQ{ real = x, imag = 0 }\n\ncplxTwo : CplxQ\ncplxTwo = embedQ 2\n\ncplxForty : CplxQ\ncplxForty = embedQ 40\n\ncplxFortyTwo : CplxQ\ncplxFortyTwo = embedQ 42\n\ncplxAdd : CplxQ -> CplxQ -> CplxQ\ncplxAdd x y = CplxQ { real = r, imag = i }\n  where\n  r = x.real + y.real\n  i = x.imag + y.imag\n\ncplxMul : CplxQ -> CplxQ -> CplxQ\ncplxMul x y = CplxQ { real = r, imag = i }\n  where\n  r = x.real * y.real - x.imag * y.imag\n  i = x.real * y.imag + x.imag * y.real\n\ncplxEq : CplxQ -> CplxQ -> Bit\ncplxEq x y = (x.real == y.real) && (x.imag == y.imag)\n\nproperty cplxAddAssoc x y z =\n  cplxEq (cplxAdd (cplxAdd x y) z)\n         (cplxAdd x (cplxAdd y z))\n\nproperty cplxMulAssoc x y z =\n  cplxEq (cplxMul (cplxMul x y) z)\n         (cplxMul x (cplxMul y z))\n\nproperty cplxMulDistrib x y z =\n  cplxEq (cplxMul x (cplxAdd y z))\n         (cplxAdd (cplxMul x y) (cplxMul x z))\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Foo.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module equivalent to Foo.cry, defining the same polymorphic functions, record value and accessor, arithmetic-width operations op1\u2013op11 over [n], and the predicate isSqrtOf9 : [8] -> Bit, preserving types and behavior."},{"role":"assistant","content":"```cryptol\nmodule Foo where\n\nimport Id as Id\n\nid : {a} a -> a\nid x = x\n\nx : [8]\nx = 255\n\nadd : {a} (fin a) => [a] -> [a] -> [a]\nadd = (+)\n\nfoo : {foo : [32], bar : [32]} \nfoo = {foo = 23, bar = 99}\n\ngetFoo : {foo : [32], bar : [32]}  -> [32]\ngetFoo x = x.foo\n\nop1 : {n} (fin n) => [n] -> [n + 1]\nop1 a = 0\n\nop2 : {n} (fin n) => [n] -> [n - n]\nop2 a = 0\n\nop3 : {n} (fin n) => [n] -> [n * 1]\nop3 a = 0\n\nop4 : {n} (fin n) => [n] -> [n \/ 1]\nop4 a = 0\n\nop5 : {n} (fin n) => [n] -> [n % 1]\nop5 a = 0\n\nop6 : {n} (fin n) => [n] -> [n ^^ 1]\nop6 a = 0\n\nop7 : {n} (fin n) => [n] -> [n \/^ 1]\nop7 a = 0\n\nop8 : {n} (fin n) => [n] -> [width n]\nop8 a = 0\n\nop9 : {n} (fin n) => [n] -> [max n 1]\nop9 a = 0\n\nop10 : {n} (fin n) => [n] -> [min 1 n]\nop10 a = 0\n\nop11 : {n} (fin n) => [n] -> [lg2 n]\nop11 a = 0\n\nisSqrtOf9 : [8] -> Bit\nisSqrtOf9 x = x*x == 9\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Types.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Types` that defines the given typed constants (`b`, `w`, `z`, `m`, `q`, `t`, `s`, `r`) and a polymorphic identity function `id : {n} (fin n) => [n] -> [n]` with matching values and types."},{"role":"assistant","content":"```cryptol\nmodule Types where\n\nb : Bit\nb = True\n\nw : [16]\nw = 42\n\nz : Integer\nz = 420000\n\nm : Z 12\nm = 6\n\nq : Rational\nq = ratio 5 4\n\nt : (Bit, Integer)\nt = (False, 7)\n\ns : [3][3][8]\ns = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nr : {xCoord : [32], yCoord : [32]}\nr = {xCoord = 12 : [32], yCoord = 21 : [32]}\n\nid : {n} (fin n) => [n] -> [n]\nid a = a\n```"}]}
{"filename":"cryptol-specs\/Common\/ntt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that implements the number-theoretic transform (NTT) and inverse NTT over F_q with q = 8380417 and n = 256, including naive and fast NTT\/INTT variants and properties showing they are mutual inverses and equivalent (naive_ntt_correct, ntt_correct, fntt_correct, fivntt_correct, ffivntt_correct)."},{"role":"assistant","content":"```cryptol\nmodule Common::ntt where\n\ntype q = 8380417\n\ntype Fld = Z q\n\ntype nn = 256\n\nr : Fld\nr = 1753\n\nall_powers : {n} (fin n) => Fld -> [n]Fld\nall_powers w = take`{n} (iterate ((*) w) 1)\n\nodd_powers : {n} (fin n) => Fld -> [n]Fld\nodd_powers w = take`{n} (iterate ((*) (w * w)) w)\n\nnaive_ntt : {n} (fin n) => [n]Fld -> [n]Fld\nnaive_ntt xs = map (polyeval xs) (odd_powers r)\n\npolyeval : {n} (fin n) => [n]Fld -> Fld -> Fld\npolyeval p x = foldl (\\y pi -> (x * y) + pi) 0 (reverse p)\n\nivn : Fld\nivn = recip (`nn : Fld)\n\nivr : Fld\nivr = recip r\n\nnaive_ivntt : {n} (fin n) => [n]Fld -> [n]Fld\nnaive_ivntt xs = map ((*) ivn) ys\n  where\n    ys = [ foldl (+) 0 (zipWith (*) (reverse xs) (odd_powers wi))\n         | wi <- all_powers r ]\n\nnaive_ntt_correct : [nn]Fld -> Bool\nproperty naive_ntt_correct a = naive_ivntt (naive_ntt a) == a\n\nunit : {n} (n < nn) => [nn]Fld\nunit =\n  [ if `n == i then 1 else 0 | i <- [0 .. <nn]]\n\nroots : [inf]Fld\nroots = iterate ((*) (r * r)) 1\n\nntt : [nn]Fld -> [nn]Fld\nntt a = ntt_r`{lg2 nn} 0 a\n\nntt_r : {n} (fin n) => Integer -> [2 ^^ n]Fld -> [2 ^^ n]Fld\nntt_r depth a\n  | n == 0 =>  a\n  | n > 0 => butterfly depth even odd\n    where\n      (lft, rht) = shuffle a\n      even = ntt_r`{n - 1} (depth + 1) lft\n      odd = ntt_r`{n - 1} (depth + 1) rht\n\nshuffle : {n, a} (fin n, n > 0) => [2 * n]a -> ([n]a, [n]a)\nshuffle a =\n  ([ a @ (i * 2) | i <- [0 .. <n]], [ a @ (i * 2 + 1) | i <- [0 .. <n]])\n\nbutterfly : {n} (fin n, n > 0) => Integer -> [n]Fld -> [n]Fld -> [2*n]Fld\nbutterfly depth even odd =\n  lft # rht\n  where\n    j = 2 ^^ depth\n    lft = [ even @ i + roots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n    rht = [ even @ i - roots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n\nivroots : [inf]Fld\nivroots = iterate ((*) (ivr * ivr)) 1\n\nivntt : [nn]Fld -> [nn]Fld\nivntt a =\n  map ((*) ivn) (ivntt_r`{lg2 nn} 0 a)\n\nivntt_r : {n} (fin n) => Integer -> [2 ^^ n]Fld -> [2 ^^ n]Fld\nivntt_r depth a\n  | n == 0 => a\n  | n > 0 => ivbutterfly depth even odd\n    where\n      (lft, rht) = shuffle a\n      even = ivntt_r`{n - 1} (depth + 1) lft\n      odd = ivntt_r`{n - 1} (depth + 1) rht\n\nivbutterfly : {n} (fin n, n > 0) => Integer -> [n]Fld -> [n]Fld -> [2 * n]Fld\nivbutterfly depth even odd =\n  lft # rht\n  where\n    j = 2 ^^ depth\n    lft = [ even @ i + ivroots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n    rht = [ even @ i - ivroots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n\nntt_correct : [nn]Fld -> Bool\nproperty ntt_correct a = ivntt (ntt a) == a\n\nfntt : [nn]Fld -> [nn]Fld\nfntt xs = ntt (zipWith (*) xs (all_powers r))\n\nfntt_correct : [nn]Fld -> Bool\nproperty fntt_correct a = naive_ntt a == fntt a\n\nfivntt : [nn]Fld -> [nn]Fld\nfivntt xs = zipWith (*) (all_powers ivr) (ivntt xs)\n\nfivntt_correct : [nn]Fld -> Bool\nproperty fivntt_correct a = fivntt a == naive_ivntt a\n\nffivntt_correct : [nn]Fld -> Bool\nproperty ffivntt_correct a = fivntt (fntt a) == a\n```"}]}
{"filename":"cryptol-specs\/Common\/LUP.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the LUPDecompose, LUPSolve, and LUPInvert functions over an abstract field, and add properties showing that LUPDecompose produces a valid LUP factorization and that LUPInvert returns the correct inverse when the matrix is non-singular."},{"role":"assistant","content":"```cryptol\nmodule Common::LUP where\n\nparameter\n\n  type Fld : *\n\n  type constraint (Eq Fld)\n\n  fzero : Fld\n\n  fadd : Fld -> Fld -> Fld\n\n  fminus : Fld -> Fld\n\n  fone : Fld\n\n  fmul : Fld -> Fld -> Fld\n\n  finv : Fld -> Fld\n\nfdiv : Fld -> Fld -> Fld\nfdiv x y =\n  fmul x (finv y)\n\nnats : {n} (fin n) => [n][width n]\nnats = take`{n} [0 .. n]\n\nmap_at : {n, a} (fin n) => ([width n] -> a -> a) -> [n]a  -> [n]a\nmap_at f m = [ f i (m @ i) | i <- nats ]\n\ntype FldVec n = [n]Fld\n\ndot : {n} (fin n) => FldVec n -> FldVec n -> Fld\ndot x y =\n  str ! 0\n  where\n    str = [ fzero ] # [ fadd acc (fmul xi yi)\n                      | xi <- x\n                      | yi <- y\n                      | acc <- str ]\n\nvecAdd : {n} (fin n) => FldVec n -> FldVec n -> FldVec n\nvecAdd x y = [ fadd xi yi | xi <- x | yi <- y ]\n\nscalMul : {n} (fin n) => Fld -> FldVec n -> FldVec n\nscalMul c x = [ fmul c xi | xi <- x ]\n\ntype FldMat n = [n](FldVec n)\n\nidMat : {n} (fin n) => FldMat n\nidMat = [ unitVec i | i <- nats ]\n\nunitVec : {n} (fin n) => [width n] -> FldVec n\nunitVec i =\n  [ if i == j then fone else fzero | j <- nats ]\n\nmatMul : {n} (fin n) => FldMat n -> FldMat n -> FldMat n\nmatMul x y =\n  [ [ dot (x @ i) (transpose y @ j) | j <- nats ] | i <- nats]\n\nmatVec : {n} (fin n) => FldMat n -> FldVec n -> FldVec n\nmatVec x y =\n  [ dot (x @ i) y  | i <- nats]\n\nswap : {n, a} (fin n) => [width n] -> [width n] -> [n]a -> [n]a\nswap i j x =\n  [ x @ perm k | k <- nats ]\n  where\n    perm k =\n      if (i >= `n) || (j >= `n)\n      then k\n      else if k == i\n           then j\n           else if k == j\n                then i\n                else k\n\nLUPDecompose : {n} (fin n) => FldMat n -> (Bit, FldMat n, [n][width n])\nLUPDecompose a = str ! 0\n  where\n  perm = [ i | i <- nats ]\n  str = [(True, a, perm)] #\n        [ row i non_sing lu p\n        | (non_sing, lu, p) <- str\n        | i <- nats`{n=n}\n        ]\n\nprivate\n\n  row : {n} (fin n) => [width n] -> Bit -> FldMat n -> [n][width n] ->\n                       (Bit, FldMat n, [n][width n])\n  row i ns a p =\n    if ns\n    then if ns'\n         then (ns', elim i a', p')          else (ns', a', p')        \/\/ a is singular, pivoting failed\n         where\n           (ns', a', p') = pivot i a p\n    else (ns, a, p)             \n\n  pivot : {n} (fin n) => [width n] -> FldMat n -> [n][width n] ->\n                         (Bit, FldMat n, [n][width n])\n  pivot i a perm = str ! 0\n    where\n    str = [(False, a, perm)] #\n          [ f done lu p j | (done, lu, p) <- str | j <- nats`{n=n} ]\n    f done lu p j =\n      if j < i then (done, lu, p)\n       | j == i then (lu @ i @ i != fzero, lu, p)\n       | done then (done, lu, p)\n       | lu @ j @ i == fzero then (done, lu, p)\n      else (True, swap i j lu, swap i j p) \n\n  elim : {n} (fin n) => [width n] -> FldMat n -> FldMat n\n  elim i a = map_at f a\n    where\n      invA_i_i = finv (a @ i @ i)\n      f j v =\n        if i < j then\n          map_at g v\n          where\n            a_j_i = fmul (v @ i) invA_i_i\n            g k x =\n              if k < i then x\n               | k == i then a_j_i\n              else\n                fadd x (fminus (fmul a_j_i (a @ i @ k)))\n        else\n          v\n\nLUPSolve : {n} (fin n) => FldMat n -> [n][width n] ->\n                          FldVec n -> FldVec n\nLUPSolve lu p b =\n  bb\n  where\n        pb = map_at pf b\n    pf i x = b @ (p @ i)\n        fb = [ ff i x | x <- pb | i <- nats`{n=n} ]\n    ff i x = str ! 0\n      where\n        str = [ x ] # [ h j y | y <- str | j <- nats`{n=n} ]\n        h j y =\n          if j < i\n          then fadd y (fminus (fmul (lu @ i @ j) (fb @ j)))\n          else y\n        bb = [ bf i x | x <- fb | i <- nats`{n=n} ]\n    bf i x = fdiv (str ! 0) (lu @ i @ i)\n      where\n        str = [ x ] # [ h j y | y <- str | j <- nats`{n=n} ]\n        h j y =\n          if i < j\n          then fadd y (fminus (fmul (lu @ i @ j) (bb @ j)))\n          else y\n\nLUPInvert : {n} (fin n) => FldMat n -> (Bit, FldMat n)\nLUPInvert a =\n  if ns then\n    (True, transpose [ LUPSolve lu p (unitVec i) | i <- nats ])\n  else\n    (False, a)\n  where\n    (ns, lu, p) = LUPDecompose a\n```"}]}
{"filename":"cryptol-specs\/Common\/ByteArray.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a module `Common::ByteArray` that imports `Array` and introduces the type synonym `ByteArray = Array[64][8]`, matching exactly this type declaration."},{"role":"assistant","content":"```cryptol\nmodule Common::ByteArray where\n\nimport Array\n\ntype ByteArray = Array[64][8]\n```"}]}
{"filename":"cryptol-specs\/Common\/pick.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module Common::pick that implements the given picking combinators (nats, pickItem, pickSeq, pickVec, pickMat, pickTri, pickTriRow) for extracting vectors, matrices, and triangular matrices from infinite streams, preserving the same polymorphic types and constraints."},{"role":"assistant","content":"```cryptol\nmodule Common::pick where\n\nnats : {n} (fin n) => [n][width n]\nnats = take`{n} [0 .. n]\n\npickItem : {a} [inf]a -> ([inf]a, a)\npickItem g = (tail g, head g)\n\npickSeq : {n, a, b} (fin n, n > 0) =>\n          ([inf]a -> ([inf]a, b)) -> [inf]a -> ([inf]a, [n]b)\npickSeq f vals =\n  (str, map snd vec)\n  where\n    vec = [f vals] # [f g | (g, _) <- vec | i <- nats`{n=n-1}]\n    snd (_, x) = x\n    (str, _) = vec ! 0            \n\npickVec : {n, a} (fin n, n > 0) => [inf]a -> ([inf]a, [n]a)\npickVec = pickSeq pickItem\n\npickMat : {n, m, a} (fin n, n > 0, fin m, m > 0) =>\n          [inf]a -> ([inf]a, [n][m]a)\npickMat = pickSeq pickVec\n\npickTri : {n, a} (fin n, n > 0) =>\n          ([inf]a -> ([inf]a, a)) -> a -> [inf]a -> ([inf]a, [n][n]a)\npickTri pick nil s =\n  (str, map snd vec)\n  where\n    vec = [pickSeq pick s] # [pickTriRow pick nil g i\n                             | (g, _) <- vec\n                             | i <- nats`{n=n-1}\n                             ]\n    snd (_, x) = x\n    (str, _) = vec ! 0          \nprivate\n\n  pickTriRow : {n, a} (fin n, n > 0) => ([inf]a -> ([inf]a, a)) ->\n               a -> [inf]a -> [width (n - 1)] -> ([inf]a, [n]a)\n  pickTriRow pick nil s j =\n    (str, map snd vec)\n    where\n      vec = [pick s] # [f g i\n                       | (g, _) <- vec\n                       | i <- nats`{n=n-1}\n                       ]\n      f g i =\n        if i < j\n        then (g, nil)\n        else pick g\n      snd (_, x) = x\n      (str, _) = vec ! 0\n```"}]}
{"filename":"cryptol-specs\/Common\/Field.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define in Cryptol the `FieldRep` record type for an abstract field representation with all its function components and constants exactly as specified."},{"role":"assistant","content":"```cryptol\nmodule Common::Field where\n\nimport Common::Morphism\nimport Common::Set\n\ntype FieldRep fv =\n  { is_val : Set fv           , normalize : fv -> fv\n  , add : (fv,fv) -> fv\n  , sub : (fv,fv) -> fv\n  , neg : fv -> fv\n  , mul : (fv,fv) -> fv\n  , sq : fv -> fv\n  , half : fv -> fv\n  , div : (fv,fv) -> fv\n\n  , field_zero : fv\n\n  , field_unit : fv\n\n  , is_equal : (fv, fv) -> Bit\n  }\n```"}]}
{"filename":"cryptol-specs\/Common\/mod_arith.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module Common::mod_arith that implements modular addition, subtraction, negation, halving, multiplication, division (via extended GCD), and exponentiation over [n] bit-vectors, with appropriate finite-size constraints on n and a."},{"role":"assistant","content":"```cryptol\nmodule Common::mod_arith where\n\nimport Common::bv\n\nmod_add : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_add(p,x,y) = if c1 || ~c2 then r2 else r1\n  where\n    (r1,c1) = adc( x, y)\n    (r2,c2) = sbb(r1, p)\n\nmod_sub : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_sub(p,x,y) = if b then r2 else r1\n  where\n    (r1,b) = sbb( x, y)\n    (r2,_) = adc(r1, p)\n\nmod_neg : {n} (fin n) => ([n],[n]) -> [n]\nmod_neg(p,x) = if x == 0 then 0 else (p - x)\n\nmod_half : {n} (fin n, n >= 1) => ([n],[n]) -> [n]\nmod_half(p, x) = if even(x) then x >> 1\n                 else take(safe_add(x, p))\n  where even y = (y && 1) == 0\n\nmod_mul : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_mul(p,x,y) = safe_mod(p, safe_product(x, y))\n\nmod_div : {a} (fin a, a >= 1) => ([a],[a],[a]) -> [a]\nmod_div(p,x,y) = egcd(p,0,y,x)\n  where\n\n    egcd(a,ra,b,rb) =\n      if b == 0 then\n        ra\n      else if (b && 1) == 0 then \n        egcd(a, ra, b >> 1, mod_half(p, rb))\n      else if a < b then\n        egcd(a, ra, (b - a) >> 1, mod_half(p, mod_sub(p, rb, ra)))\n      else\n        egcd(b, rb, (a - b) >> 1, mod_half(p, mod_sub(p, ra, rb)))\n\nmod_pow : {a} (fin a, a >= 1) => ([a] , [a] , [a]) -> [a]\nmod_pow (p,x0,e0) = (results ! 0).2\n where\n results = [(x0,e0,1)] # [ (mod_mul (p,x,x), e>>1, if(e!0) then mod_mul(p,result,x) else result)\n                                | (x,e,result) <- results | _ <- [0..a] :[_][width a] ]\n```"}]}
{"filename":"cryptol-specs\/Common\/OptionUtils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Common::OptionUtils that defines the given Option utility functions (isSome, isNone, optApply, optFold, optTest, optFlatten, optFlatApply) with the shown types and implement properties that verify their expected relationships (e.g., isNone opt == ~ isSome opt, optFlatApply f opt == optFlatten (optApply f opt))."},{"role":"assistant","content":"```cryptol\nmodule Common::OptionUtils where\n\nisSome : {a} Option a -> Bit\nisSome opt = case opt of\n    Some _ -> True\n    None -> False\n\nisNone : {a} Option a -> Bit\nisNone opt = ~ isSome opt\n\noptApply : {a, b} (a -> b) -> Option a -> Option b\noptApply f opt = case opt of\n    Some x -> Some (f x)\n    None -> None\n\noptFold : {a, b} b -> (a -> b) -> Option a -> b\noptFold def f opt =\n  case opt of\n    Some x -> f x\n    None   -> def\n\noptTest : {a} (a -> Bit) -> Option a -> Bit\noptTest f opt = optFold False f opt\n\noptFlatten : {a} Option (Option a) -> Option a\noptFlatten opt = case opt of\n    Some opt' -> opt'\n    None -> None\n\noptFlatApply: {a, b} (a -> Option b) -> Option a -> Option b\noptFlatApply f opt = optFlatten (optApply f opt)\n```"}]}
{"filename":"cryptol-specs\/Common\/GF24.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module implementing arithmetic over GF(2^4) with type GF24, including addition, multiplication modulo the irreducible polynomial x^4 + x + 1, exponentiation, inversion, dot product, vector\/matrix multiplication, and properties polySelfAdd' and gf24InverseCorrect."},{"role":"assistant","content":"```cryptol\nmodule Common::GF24 where\n\ntype GF24 = [4]\n\nirreducible = <| x^^4 + x + 1 |>\n\ngf24Add : {n} (fin n) => [n]GF24 -> GF24\ngf24Add ps = foldl (^) zero ps\n\ngf24Mult : GF24 -> GF24 -> GF24\ngf24Mult x y = pmod (pmult x y) irreducible\n\ngf24Pow : GF24 -> GF24 -> GF24\ngf24Pow n k = vals ! 0 where\n    sq x = gf24Mult x x\n    vals = [1] # [ if i then gf24Mult n (sq acc) else sq acc\n        | acc <- vals\n        | i   <- k]\n\npolySelfAdd' : GF24 -> Bit\nproperty polySelfAdd' x = x ^ x == zero\n\ngf24Inverse : GF24 -> GF24\ngf24Inverse x = gf24Pow x 14\n\nproperty gf24InverseCorrect x = gf24Inverse (gf24Inverse x) == x\n\ngf24DotProduct : {n} (fin n) => [n]GF24 -> [n]GF24 -> GF24\ngf24DotProduct xs ys = gf24Add [ gf24Mult x y | x <- xs | y <- ys ]\n\ngf24VectorMult : {n, m} (fin n) => [n]GF24 -> [m][n]GF24 -> [m]GF24\ngf24VectorMult v ms = [ gf24DotProduct v m | m <- ms ]\n\ngf24MatrixMult : {n, m, k} (fin m) => [n][m]GF24 -> [m][k]GF24 -> [n][k]GF24\ngf24MatrixMult xss yss = [ gf24VectorMult xs yss' | xs <- xss ]\n    where\n        yss' = transpose yss\n```"}]}
{"filename":"cryptol-specs\/Common\/bv.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Common::bv` that defines safe bit-vector arithmetic helpers (safe_add, safe_sub, safe_product, safe_mod, adc, sbb) with the given type signatures and semantics for zero-extended, carry\/borrow-aware operations."},{"role":"assistant","content":"```cryptol\nmodule Common::bv where\n\nsafe_add : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_add(x,y) = zext(x) + zext(y)\n\nsafe_sub : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_sub(x,y) = zext(x) - zext(y)\n\nis_normal : {a} (fin a) => [a] -> [a] -> Bit\nis_normal p x = (x < p)\n\nsafe_product : {a} (fin a) => ([a],[a]) -> [2*a]\nsafe_product(x,y) = zext(x) * zext(y)\n\nsafe_mod : {a, b} (fin a, fin b) => ([b],[a+b]) -> [b]\nsafe_mod(p,x) = drop `{a} (x % zext(p))\n\nadc : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nadc(x,y) = (drop(sm), sm@0)\n  where sm = safe_add(x,y)\n\nsbb : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nsbb(x,y) = (drop(r), r@0)\n  where r = ([False] # x) - ([False] # y)\n```"}]}
{"filename":"cryptol-specs\/Common\/utils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Create a Cryptol module Common::utils that defines these generic utility functions and properties (while, dowhile, ZtoBV, BVtoZ, ZtoZ, integerToBV, integerFromBV, integerModulusFromBV, isEven, abs, unzip, mul2\/3\/4\/8, isOdd constraint, half, half_correct, compose, composeMany)."},{"role":"assistant","content":"```cryptol\nmodule Common::utils where\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = (fromInteger (fromZ x))\n\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = (fromInteger (toInteger x))\n\nZtoZ : {p, q} (fin p, fin q, p >= 1, q >= 1) => Z p -> Z q\nZtoZ x = (fromInteger (fromZ x))\n\nintegerToBV : {m} (fin m) => Integer -> [m]\nintegerToBV x = fromInteger x\n\nintegerFromBV : {m} (fin m) => [m] -> Integer\nintegerFromBV x = toInteger x\n\nintegerModulusFromBV : {m} (fin m) => [m] -> Integer\nintegerModulusFromBV x = if (integerFromBV x) < 3 then 3 else (integerFromBV x)\n\nisEven : Integer -> Bit\nisEven x = ~((fromInteger x) : [1]) ! 0\n\nabs : Integer -> Integer\nabs x = if x >= zero then x else zero-x\n\nunzip : {a,f,s} [a](f,s) -> ([a]f,[a]s)\nunzip tuples = (map (\\x -> x.0) tuples , map (\\x -> x.1) tuples)\n\nmul2 x = x + x\n\nmul3 x = x + mul2 x\n\nmul4 x = mul2(mul2 x)\n\nmul8 x = mul2(mul4 x)\n\ntype constraint isOdd a = (a \/ 2) * 2 == a - 1\n\nhalf : {p} (fin p, p >= 3, isOdd p) => Z p -> Z p\nhalf x = fromInteger (if isEven xint then xint\/2 else ((xint + `p) \/ 2))\n  where\n    xint = fromZ x\n\nhalf_correct : {p} (fin p, p >= 3, isOdd p) => Z p -> Bit\nproperty half_correct x = half x + half x == x\n\ncompose : {a} () => (a -> a) -> (a -> a) -> a -> a\ncompose f g = \\x -> g (f x)\n\ncomposeMany : {nf, a} () => [nf](a -> a) -> a -> a\ncomposeMany fcns\n    | nf == 0 => \\x -> x\n    | nf == 1 => fcns@0\n    | nf == 2 => compose (fcns@0) (fcns@1)\n    | nf > 2  => compose (fcns@0) (composeMany (drop `{1} fcns))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/KDF\/HKDF256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::KDF::HKDF256` that instantiates HKDF using HMAC-SHA256, including the type alias `HashLen = 32` and the function `hmacBytes : {n, m} ... -> [n][8] -> [m][8] -> [32][8]` implemented via `HMAC_SHA256::hmac`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::KDF::HKDF256 = Primitive::Symmetric::KDF::HKDF where\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA256 as HMAC_SHA256\n\ntype HashLen = 32\nHMAC = hmacBytes\n\nhmacBytes : {n, m} (64 >= width (8 * (64 + m)),\n                    64 >= width (8 * n), 32 >= width m, fin m, fin n) =>\n            [n][8] -> [m][8] -> [32][8]\nhmacBytes key msg = HMAC_SHA256::hmac key msg\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/AES_GCM_SIV.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module AES_GCM_SIV that specifies the AES-GCM-SIV authenticated encryption scheme with function aes_gcm_siv and all supporting types and functions, matching the draft-irtf-cfrg-gcmsiv-06 test vector formats including key derivation, POLYVAL, counter mode, and byte-swapping behavior."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::AES_GCM_SIV where\n\nparameter\n      type KeySize : #\n  type constraint (fin KeySize, KeySize % 128 == 0, KeySize \/ 128 >= 1, KeySize \/ 128 <= 2)\n\n  type AAD : #\n  type constraint ( (36 + 8) >= width AAD )\n\ntype Mode = KeySize \/ 128 - 1\ntype K  = 128 + 128 * Mode\nimport Primitive::Symmetric::Cipher::Block::AES::Specification as AES where\n  type KeySize' = KeySize\ntype KS = AES::KeySchedule\n\n\/** Note the weird byte-swapping business (also in `blockify` and `unblockify`)\n * It is not quite clear in what format we want the inputs\/outputs, but we\n * do the swapping so that inputs\/ouputs match the test vectors at\n * https:\/\/tools.ietf.org\/html\/draft-irtf-cfrg-gcmsiv-06\n *\/\naes_gcm_siv :\n  {n} ((36 + 8) >= width n) =>\n      { key   : [K]\n      , nonce : [96]\n      , aad   : [AAD]\n      , msg   : [n]\n      } -> [n + 128]\naes_gcm_siv input = c # byteSwap t\n  where\n  (c,t) = gcm_siv_plus (derive_key k' n') n' input.aad input.msg\n  k'    = byteSwap input.key\n  n'    = byteSwap input.nonce\n\naes : KS -> [128] -> [128]\naes ks v = byteSwap (AES::cipher ks (byteSwap v))\n\nexpandKey : [K] -> KS\nexpandKey k = AES::keyExpansion (byteSwap k)\n\nderive_key : [K] -> [96] -> ([128], KS)\nderive_key K N = (mkKey parts1, expandKey (mkKey parts2))\n  where\n  parts1 # parts2 = [ drop (aes (expandKey K) (N # i)) | i <- take [ 0 ... ]  ]\n\n  mkKey : {n} (fin n) => [n][64] -> [64 * n]\n  mkKey xs = join (reverse xs)\n\ngcm_siv_plus :\n  {n} (64 >= width n) => ([128], KS) -> [96] -> [AAD] -> [n] -> ([n],[128])\ngcm_siv_plus (K1,K2) N AAD MSG = (unblockify Cs,TAG)\n  where\n\n  TAG     = aes K2 (0b0 # drop (T ^ (0 # N)))\n  T       = polyvalFrom K1 (A # M # [msg_len # aad_len]) 0\n  A       = blockify AAD\n  M       = blockify MSG\n  aad_len = `AAD: [64]\n  msg_len = `n   : [64]\n\n  _ # tUpper # tLower = TAG\n\n  Cs = counter_mode K2 (0b1 # tUpper, tLower) M\n\ncounter_mode : {n} KS -> ([96],[32]) -> [n][128] -> [n][128]\ncounter_mode K2 (tUpper,tLower) M =\n            [ aes K2 (tUpper # lower32 i) ^ m | m <- M | i <- [ 0 ... ] ]\n  where\n  lower32 i = tLower + i\n\npolyvalFrom : {n} (fin n) => [128] -> [n][128] -> [128] -> [128]\npolyvalFrom H Xs start = psums ! 0\n  where psums = [start] # [ dot (s ^ x) H | s <- psums | x <- Xs ]\n\ndot : [128] -> [128] -> [128]\ndot x y = mult x (mult y x_neg_128)\n  where x_neg_128 = <| 1 + x^^114 + x^^121 + x^^124 + x^^127 |>\n\nmult : [128] -> [128] -> [128]\nmult x y = pmod (pmult x y) irred\n  where\n  irred = <| 1 + x^^121 + x^^126 + x^^127 + x^^128 |>\n\nblockify : {n} (fin n) => [n] -> [n \/^ 128][128]\nblockify x = [ byteSwap b | b <- split (x # zero) ]\n\nunblockify : {n} (fin n) => [n \/^ 128][128] -> [n]\nunblockify xs = take (join [ byteSwap b | b <- xs ])\n\nbyteSwap : {n} (fin n) => [8 * n] -> [8 * n]\nbyteSwap xs = join (reverse (split`{each=8} xs))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/MEE_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing the MEE-CBC authenticated encryption scheme with CBC mode, padding\/unpadding, tagging, and define properties `unpad_pad_good_1000_256` and `mee_enc_dec_good_1000` that verify correct padding removal and that decryption of `mee_enc` returns the original message and `True`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::MEE_CBC where\n\ntype blkBytes = 16\ntype Blk = [blkBytes][8]\ntype EKey = [blkBytes][8]\n\ntype tagBytes = 32\ntype Tag = [tagBytes][8]\n\ntype skeyBytes = 64\ntype SKey = [skeyBytes][8]\n\ncbc_enc : {n} (fin n) => (EKey -> Blk -> Blk) -> EKey -> Blk -> [n]Blk -> [n]Blk\ncbc_enc enc k iv ps = cs\n where cs = [ enc k (p ^ c') | p <- ps | c' <- [iv] # cs ]\n\ncbc_dec : {n} (fin n) => (EKey -> Blk -> Blk) -> EKey -> Blk -> [n]Blk -> [n]Blk\ncbc_dec dec k iv cs = [ (dec k c) ^ c' | c <- cs | c' <- [iv] # cs ]\n\npad : {n, p, b}\n      (fin n, 8 >= width p, p == blkBytes*b - n, blkBytes*b >= n) =>\n      [n][8] -> Tag -> [b+2]Blk\npad msg tag = split `{each=blkBytes} (msg # tag # padding)\n  where\n    padding = (repeat `p) : [p][8]\n\nunpad : {n, p, b}\n        (fin n, 8 >= width p, p == blkBytes*b - n, blkBytes*b >= n) =>\n        [b+2]Blk -> ([n][8], Tag, Bit)\nunpad ct = (m, t, good)\n  where\n    padded = join ct\n    m = take `{n} padded\n    t = take `{tagBytes} (drop `{n} padded)\n    p = drop `{n + tagBytes} padded\n    good = p == ((repeat `p) : [p][8]) \n\nproperty unpad_pad_good_1000_256 msg tag =\n  unpad (pad `{n=1000,p=104} msg tag) == (msg, tag, True)\n\nmee_enc : {n, p, b}\n          (fin n, p == blkBytes*b - n, 8 >= width p, b >= 1, 16*b >= n) =>\n          (Blk -> Blk -> Blk)\n       -> (SKey -> [n][8] -> Tag)\n       -> EKey -> SKey -> Blk -> [n][8] -> [b+2]Blk\nmee_enc enc sign ekey skey iv msg =\n  cbc_enc enc ekey iv (pad msg (sign skey msg))\n\nmee_dec : {n, p, b}\n          (fin n, p == blkBytes*b - n, 8 >= width (32 + p), b >= 1, 16*b >= n)\n       => (EKey -> Blk -> Blk)\n       -> (SKey -> [n][8] -> Tag)\n       -> EKey -> SKey -> Blk -> [b+2]Blk -> ([n][8], Bit)\nmee_dec dec sign ekey skey iv ct = (m, good \/\\ sign skey m == t)\n  where\n    (m, t, good) = unpad (cbc_dec dec ekey iv ct)\n\nproperty mee_enc_dec_good_1000 enc dec sign ekey skey iv msg =\n  mee_dec `{n=1000,p=104} dec sign ekey skey iv ct == (msg, True)\n    where ct = mee_enc `{n=1000,p=104} enc sign ekey skey iv msg\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/trivium.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module specifying the Trivium stream cipher, including Trivium_stream, Trivium, Trivium_alt, and shift_regs, and define properties Trivium_correct, Trivium_search, Trivium_alt_correct, Trivium_alt_equivalent, and cycle as in the description."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::trivium where\n\nTrivium_stream : [93] -> [84] -> [111] -> [inf]\nTrivium_stream R1 R2 R3 = stream\n\twhere\n\t(stream, ra, rb, rc) = shift_regs R1 R2 R3\n\ntype N = 300\nTrivium : ([93], [84], [111]) -> [N]Bit\nTrivium (reg1, reg2, reg3) = keystream\n  where\n    keystream =  take`{N} (Trivium_stream reg1 reg2 reg3)\n\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n\t\tfills = [bit]#(drop`{1} (fill >> 1))\n\nshift_regs : {d,e,f} (fin d, fin e, fin f, d >=1, e >=1, f>=1) => [d] -> [e] -> [f] -> ([inf],[inf][d],[inf][e],[inf][f])\nshift_regs r1 r2 r3 = (stream, regA, regB, regC)\n\twhere\n\n\t\ts1 = [(f1 @ 65) ^ (f1 @ 92)  | f1 <- regA]\n\t\ts2 = [(f2 @ 68) ^ (f2 @ 83)  | f2 <- regB]\n\t\ts3 = [(f3 @ 65) ^ (f3 @ 110) | f3 <- regC]\n\n\t\tstream = s1 ^ s2 ^ s3\n\t\tt1 = [(f1 @ 65) ^ ((f1 @ 90) && (f1 @ 91)) ^ (f1 @ 92) ^ (f2 @ 77) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf1 <- regA ]\n\t\tt2 = [(f2 @ 68) ^ ((f2 @ 81) && (f2 @ 82)) ^ (f2 @ 83) ^ (f3 @ 86) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf3 <- regC ]\n\t\tt3 = [(f3 @ 65) ^ ((f3 @ 108) && (f3 @ 109)) ^ (f3 @ 110) ^ (f1 @ 68)|\n\t\t\t\tf1 <- regA |\n\t\t\t\tf3 <- regC ]\n\n\t\tregA = [r1] # [shift f b| f <- regA | b <- t3]\n\t\tregB = [r2] # [shift f b| f <- regB | b <- t1]\n\t\tregC = [r3] # [shift f b| f <- regC | b <- t2]\n\nTrivium_alt : ([93], [84], [111]) -> [N]Bit\nTrivium_alt (r1, r2, r3) = take`{N} (s1 ^ s2 ^ s3)\n  where\n    a_65 = drop`{27} a_92\n    a_68 = drop`{24} a_92\n    a_90 = drop`{2} a_92\n    a_91 = drop`{1} a_92\n    a_92 = reverse r1 # t3\n\n    b_68 = drop`{15} b_83\n    b_77 = drop`{6} b_83\n    b_81 = drop`{2} b_83\n    b_82 = drop`{1} b_83\n    b_83 = reverse r2 # t1\n\n    c_65 = drop`{45} c_110\n    c_86 = drop`{24} c_110\n    c_108 = drop`{2} c_110\n    c_109 = drop`{1} c_110\n    c_110 = reverse r3 # t2\n\n    s1 = a_65 ^ a_92\n    s2 = b_68 ^ b_83\n    s3 = c_65 ^ c_110\n\n    t1 = s1 ^ (a_90 && a_91) ^ b_77\n    t2 = s2 ^ (b_81 && b_82) ^ c_86\n    t3 = s3 ^ (c_108 && c_109) ^ a_68\n\niv1 = 0b111111111111111111101111111111111111111011111111111111111110111111111111111111101111111111111\niv2 = 0b000000000000000000001000000000000000000001000000000000000000001000000000000000000001\niv3 = 0b111111111111111110111111111111111111101111111111111111111011111111111111111110111111111111100000000000000000000\n\ntest_keystream = 0b011111110111101111110100001110000000000000100010000000000000000100011000101100001110001011011010101010000100101110001111100011000110000101001011001111011101110110111010011011010110001000111101101111101100101001000111010001010011111110011100100011101010011110101001001000011100001111111100000001110001\n\nproperty Trivium_correct = (Trivium(iv1, iv2, iv3)) == test_keystream\nproperty Trivium_search (x, y, z) = (Trivium(x, y, z)) == test_keystream\nproperty Trivium_alt_correct = (Trivium_alt(iv1, iv2, iv3)) == test_keystream\nproperty Trivium_alt_equivalent x = take`{200}(Trivium_alt x) == take (Trivium x)\n\ncycle : {n} (fin n) => [n] -> ([93], [84], [111]) -> Bit\ncycle n (rA, rB, rC) =\n  (rA == regAs @ n) \/\\ (rB == regBs @ n) \/\\ (rC == regCs @ n) \/\\ rA != 0 \/\\ rB != 0 \/\\ rC != 0\n    where\n      (_, regAs, regBs, regCs) = shift_regs rA rB rC\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/bivium.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that specifies the Bivium stream cipher with functions Bivium_stream, Bivium, and Bivium_alt, and properties Bivium_correct, Bivium_search, Bivium_search_with_suffix, Bivium_alt_equivalent, and cycle\/cycleN to verify the given keystream, key\/IV recovery conditions, implementation equivalence, and short cycles."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::bivium where\n\nBivium_stream : [93] -> [84] -> [inf]\nBivium_stream R1 R2 = stream\n\twhere\n\t(stream, ra, rb) = shift_regs R1 R2\n\ntype N = 200\nBivium : ([93], [84]) -> [N]Bit\nBivium (reg1, reg2) = keystream\n  where\n    keystream =  take`{N} (Bivium_stream reg1 reg2)\n\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n\t\tfills = [bit]#(drop`{1} (fill >> 1))\n\nshift_regs : {d,e} (fin d, fin e, d >=1, e >=1) => [d] -> [e] -> ([inf],[inf][d],[inf][e])\nshift_regs r1 r2 = (stream, regA, regB)\n\twhere\n\t\ts1 = [(f1 @ 65) ^ (f1 @ 92) | f1 <- regA]\n\t\ts2 = [(f2 @ 68) ^ (f2 @ 83) | f2 <- regB]\n\n\t\tstream = s1 ^ s2\n\t\tt1 = [(f1 @ 65) ^ ((f1 @ 90) && (f1 @ 91)) ^ (f1 @ 92) ^ (f2 @ 77) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf1 <- regA ]\n\t\tt2 = [(f2 @ 68) ^ ((f2 @ 81) && (f2 @ 82)) ^ (f2 @ 83) ^ (f1 @ 68) |\n\t\t\t\tf1 <- regA |\n\t\t\t\tf2 <- regB ]\n\n\t\tregA = [r1] # [shift f b| f <- regA | b <- t2]\n\t\tregB = [r2] # [shift f b| f <- regB | b <- t1]\n\nBivium_alt : ([93], [84]) -> [N]Bit\nBivium_alt (r1, r2) = take`{N} (s1 ^ s2)\n  where\n    a_65 = drop`{27} a_92\n    a_68 = drop`{24} a_92\n    a_90 = drop`{2} a_92\n    a_91 = drop`{1} a_92\n    a_92 = reverse r1 # t2\n\n    b_68 = drop`{15} b_83\n    b_77 = drop`{6} b_83\n    b_81 = drop`{2} b_83\n    b_82 = drop`{1} b_83\n    b_83 = reverse r2 # t1\n\n    s1 = a_65 ^ a_92\n    s2 = b_68 ^ b_83\n\n    t1 = s1 ^ (a_90 && a_91) ^ b_77\n    t2 = s2 ^ (b_81 && b_82) ^ a_68\n\niv1 = 0b111110000000101010100100010001000000101010100001011111111111111100100100111111111011111111111\niv2 = 0b000000000000000000001000000000000000000001000000000000000000001000000000000000000001\n\ntest_keystream = 0b01000010000100000101110001100011111101110101110111111110100001111111100110101001000010101100100010000100001100011100000010001001100101101001011101110100000001011010001101000011001000110011111010100110\n\nsuffix = 0b000000001000000000000000000001\nproperty Bivium_correct = (Bivium(iv1, iv2)) == test_keystream\nproperty Bivium_search (x, y) = (Bivium(x, y)) == test_keystream\nproperty Bivium_search_with_suffix (x, y) = (Bivium(x, y#suffix)) == test_keystream\nproperty Bivium_alt_equivalent r = Bivium_alt r == Bivium r\n\ncycle : {n} (fin n) => [n] -> [93] -> [84] -> Bit\ncycle n rA rB =\n  (rA == regAs @ n) \/\\ (rB == regBs @ n) \/\\ rA != 0 \/\\ rB != 0\n    where\n      (_, regAs, regBs) = shift_regs rA rB\n\ncycle0 rA rB = cycle (0 : [8]) rA rB\ncycle1 rA rB = cycle (1 : [8]) rA rB\ncycle2 rA rB = cycle (2 : [8]) rA rB\ncycle3 rA rB = cycle (3 : [8]) rA rB\ncycle4 rA rB = cycle (4 : [8]) rA rB\ncycle5 rA rB = cycle (5 : [8]) rA rB\ncycle10 rA rB = cycle (10 : [8]) rA rB\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/chacha20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module implementing the ChaCha20 stream cipher (including qround, cdround, kexp, core, stream, and encrypt) and a property allTestsPass that checks the given RFC 7539 test vectors and internal test cases all evaluate to True."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::chacha20 where\n\ntype Round   = [16][32] type Block   = [64][8]  type Key     = [32][8]  type Nonce   = [12][8]  type Counter = [32]     \n\nqround : [4][32] -> [4][32]\nqround [ a0, b0, c0, d0 ] = [ a2, b4, c2, d4 ]\n  where\n    a1 = a0 + b0   \n    d1 = d0 ^ a1\n    d2 = d1 <<< 16\n\n    c1 = c0 + d2   \n    b1 = b0 ^ c1\n    b2 = b1 <<< 12\n\n    a2 = a1 + b2   \n    d3 = d2 ^ a2\n    d4 = d3 <<< 8\n\n    c2 = c1 + d4   \n    b3 = b2 ^ c2\n    b4 = b3 <<< 7\n\ncdround : Round -> Round\ncdround [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 ]\n      = [ z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15 ]\n  where\n        [ y0, y4, y8,  y12 ] = qround [ x0, x4, x8,  x12 ]\n    [ y1, y5, y9,  y13 ] = qround [ x1, x5, x9,  x13 ]\n    [ y2, y6, y10, y14 ] = qround [ x2, x6, x10, x14 ]\n    [ y3, y7, y11, y15 ] = qround [ x3, x7, x11, x15 ]\n\n        [ z0, z5, z10, z15 ] = qround [ y0, y5, y10, y15 ]\n    [ z1, z6, z11, z12 ] = qround [ y1, y6, y11, y12 ]\n    [ z2, z7, z8,  z13 ] = qround [ y2, y7, y8,  y13 ]\n    [ z3, z4, z9,  z14 ] = qround [ y3, y4, y9,  y14 ]\n\ncore : Round -> Block\ncore x = block\n  where\n    rounds = iterate cdround x        result = rounds @ 10              block  = blocked (x + result) \n\nkexp : Key -> Counter -> Nonce -> Round\nkexp k c n = [ c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15 ]\n  where\n\n        [ c0, c1, c2, c3 ] = [ 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574 ]\n\n        [ c4, c5, c6,  c7 ]  = map rjoin (groupBy`{4} kslice1 : [4][4][8]) : [4][32]\n    [ c8, c9, c10, c11 ] = map rjoin (groupBy`{4} kslice2 : [4][4][8]) : [4][32]\n    kslice1 = k @@ ([ 0  .. 15 ] : [16][32])     kslice2 = k @@ ([ 16 .. 31 ] : [16][32]) \n            [ c12 ] = [ c ]\n\n        [ c13, c14, c15 ] = map rjoin (groupBy`{4} n)\n\niround : [64] -> Round -> Round\niround n r = (iterate once r) @ n where\n    once [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12,    x13, x14, x15 ]\n     = [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12+1,  x13, x14, x15 ]\n\nstream : {n} (fin n) => Key -> Counter -> Nonce -> [n][8]\nstream k c n = take`{n} (join rounds)   where\n        key    = kexp k c n\n\n                    rounds = [ core (iround i key) | i <- [ 0, 1 ... ] ]\n\nencrypt : {n} (fin n) => Key -> Counter -> Nonce -> [n][8] -> [n][8]\nencrypt k c n m = m ^ (stream k c n)\n\nprivate\n  qround01 = qround in == out\n    where\n      in  = [ 0x11111111, 0x01020304, 0x9b8d6f43, 0x01234567 ]\n      out = [ 0xea2a92f4, 0xcb1cf8ce, 0x4581472e, 0x5881c4bb ]\n\n  core01 = kexp k 1 n == out\n    where\n      n = [ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x4a,\n            0x00, 0x00, 0x00, 0x00 ]\n      k = [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f ]\n      out = [ 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,\n              0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,\n              0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c,\n              0x00000001, 0x09000000, 0x4a000000, 0x00000000 ]\n\n  core02 = core (kexp k 1 n) == out\n    where\n      n = [ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x4a,\n            0x00, 0x00, 0x00, 0x00 ]\n      k = [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f ]\n      out = [ 0x10, 0xf1, 0xe7, 0xe4, 0xd1, 0x3b, 0x59, 0x15,\n              0x50, 0x0f, 0xdd, 0x1f, 0xa3, 0x20, 0x71, 0xc4,\n              0xc7, 0xd1, 0xf4, 0xc7, 0x33, 0xc0, 0x68, 0x03,\n              0x04, 0x22, 0xaa, 0x9a, 0xc3, 0xd4, 0x6c, 0x4e,\n              0xd2, 0x82, 0x64, 0x46, 0x07, 0x9f, 0xaa, 0x09,\n              0x14, 0xc2, 0xd7, 0x05, 0xd9, 0x8b, 0x02, 0xa2,\n              0xb5, 0x12, 0x9c, 0xd1, 0xde, 0x16, 0x4e, 0xb9,\n              0xcb, 0xd0, 0x83, 0xe8, 0xa2, 0x50, 0x3c, 0x4e ]\n\n  rfctest01 = encrypt zero zero zero zero\n       == [ 0x76, 0xb8, 0xe0, 0xad, 0xa0, 0xf1, 0x3d, 0x90, 0x40, 0x5d,\n            0x6a, 0xe5, 0x53, 0x86, 0xbd, 0x28, 0xbd, 0xd2, 0x19, 0xb8,\n            0xa0, 0x8d, 0xed, 0x1a, 0xa8, 0x36, 0xef, 0xcc, 0x8b, 0x77,\n            0x0d, 0xc7, 0xda, 0x41, 0x59, 0x7c, 0x51, 0x57, 0x48, 0x8d,\n            0x77, 0x24, 0xe0, 0x3f, 0xb8, 0xd8, 0x4a, 0x37, 0x6a, 0x43,\n            0xb8, 0xf4, 0x15, 0x18, 0xa1, 0x1c, 0xc3, 0x87, 0xb6, 0x69,\n            0xb2, 0xee, 0x65, 0x86 ]\n\n  rfctest02 = encrypt (zero # [1]) 1 (zero # [2]) msg == out\n    where\n      out = [ 0xa3, 0xfb, 0xf0, 0x7d, 0xf3, 0xfa, 0x2f, 0xde, 0x4f, 0x37,\n              0x6c, 0xa2, 0x3e, 0x82, 0x73, 0x70, 0x41, 0x60, 0x5d, 0x9f,\n              0x4f, 0x4f, 0x57, 0xbd, 0x8c, 0xff, 0x2c, 0x1d, 0x4b, 0x79,\n              0x55, 0xec, 0x2a, 0x97, 0x94, 0x8b, 0xd3, 0x72, 0x29, 0x15,\n              0xc8, 0xf3, 0xd3, 0x37, 0xf7, 0xd3, 0x70, 0x05, 0x0e, 0x9e,\n              0x96, 0xd6, 0x47, 0xb7, 0xc3, 0x9f, 0x56, 0xe0, 0x31, 0xca,\n              0x5e, 0xb6, 0x25, 0x0d, 0x40, 0x42, 0xe0, 0x27, 0x85, 0xec,\n              0xec, 0xfa, 0x4b, 0x4b, 0xb5, 0xe8, 0xea, 0xd0, 0x44, 0x0e,\n              0x20, 0xb6, 0xe8, 0xdb, 0x09, 0xd8, 0x81, 0xa7, 0xc6, 0x13,\n              0x2f, 0x42, 0x0e, 0x52, 0x79, 0x50, 0x42, 0xbd, 0xfa, 0x77,\n              0x73, 0xd8, 0xa9, 0x05, 0x14, 0x47, 0xb3, 0x29, 0x1c, 0xe1,\n              0x41, 0x1c, 0x68, 0x04, 0x65, 0x55, 0x2a, 0xa6, 0xc4, 0x05,\n              0xb7, 0x76, 0x4d, 0x5e, 0x87, 0xbe, 0xa8, 0x5a, 0xd0, 0x0f,\n              0x84, 0x49, 0xed, 0x8f, 0x72, 0xd0, 0xd6, 0x62, 0xab, 0x05,\n              0x26, 0x91, 0xca, 0x66, 0x42, 0x4b, 0xc8, 0x6d, 0x2d, 0xf8,\n              0x0e, 0xa4, 0x1f, 0x43, 0xab, 0xf9, 0x37, 0xd3, 0x25, 0x9d,\n              0xc4, 0xb2, 0xd0, 0xdf, 0xb4, 0x8a, 0x6c, 0x91, 0x39, 0xdd,\n              0xd7, 0xf7, 0x69, 0x66, 0xe9, 0x28, 0xe6, 0x35, 0x55, 0x3b,\n              0xa7, 0x6c, 0x5c, 0x87, 0x9d, 0x7b, 0x35, 0xd4, 0x9e, 0xb2,\n              0xe6, 0x2b, 0x08, 0x71, 0xcd, 0xac, 0x63, 0x89, 0x39, 0xe2,\n              0x5e, 0x8a, 0x1e, 0x0e, 0xf9, 0xd5, 0x28, 0x0f, 0xa8, 0xca,\n              0x32, 0x8b, 0x35, 0x1c, 0x3c, 0x76, 0x59, 0x89, 0xcb, 0xcf,\n              0x3d, 0xaa, 0x8b, 0x6c, 0xcc, 0x3a, 0xaf, 0x9f, 0x39, 0x79,\n              0xc9, 0x2b, 0x37, 0x20, 0xfc, 0x88, 0xdc, 0x95, 0xed, 0x84,\n              0xa1, 0xbe, 0x05, 0x9c, 0x64, 0x99, 0xb9, 0xfd, 0xa2, 0x36,\n              0xe7, 0xe8, 0x18, 0xb0, 0x4b, 0x0b, 0xc3, 0x9c, 0x1e, 0x87,\n              0x6b, 0x19, 0x3b, 0xfe, 0x55, 0x69, 0x75, 0x3f, 0x88, 0x12,\n              0x8c, 0xc0, 0x8a, 0xaa, 0x9b, 0x63, 0xd1, 0xa1, 0x6f, 0x80,\n              0xef, 0x25, 0x54, 0xd7, 0x18, 0x9c, 0x41, 0x1f, 0x58, 0x69,\n              0xca, 0x52, 0xc5, 0xb8, 0x3f, 0xa3, 0x6f, 0xf2, 0x16, 0xb9,\n              0xc1, 0xd3, 0x00, 0x62, 0xbe, 0xbc, 0xfd, 0x2d, 0xc5, 0xbc,\n              0xe0, 0x91, 0x19, 0x34, 0xfd, 0xa7, 0x9a, 0x86, 0xf6, 0xe6,\n              0x98, 0xce, 0xd7, 0x59, 0xc3, 0xff, 0x9b, 0x64, 0x77, 0x33,\n              0x8f, 0x3d, 0xa4, 0xf9, 0xcd, 0x85, 0x14, 0xea, 0x99, 0x82,\n              0xcc, 0xaf, 0xb3, 0x41, 0xb2, 0x38, 0x4d, 0xd9, 0x02, 0xf3,\n              0xd1, 0xab, 0x7a, 0xc6, 0x1d, 0xd2, 0x9c, 0x6f, 0x21, 0xba,\n              0x5b, 0x86, 0x2f, 0x37, 0x30, 0xe3, 0x7c, 0xfd, 0xc4, 0xfd,\n              0x80, 0x6c, 0x22, 0xf2, 0x21 ]\n\n      msg = [ 0x41, 0x6e, 0x79, 0x20, 0x73, 0x75, 0x62, 0x6d, 0x69, 0x73,\n              0x73, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68,\n              0x65, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x69, 0x6e, 0x74,\n              0x65, 0x6e, 0x64, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62,\n              0x75, 0x74, 0x6f, 0x72, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x70,\n              0x75, 0x62, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n              0x20, 0x61, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6f, 0x72,\n              0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61,\n              0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x49, 0x6e, 0x74,\n              0x65, 0x72, 0x6e, 0x65, 0x74, 0x2d, 0x44, 0x72, 0x61, 0x66,\n              0x74, 0x20, 0x6f, 0x72, 0x20, 0x52, 0x46, 0x43, 0x20, 0x61,\n              0x6e, 0x64, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x73, 0x74, 0x61,\n              0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x61, 0x64,\n              0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74,\n              0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x20, 0x49, 0x45, 0x54,\n              0x46, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79,\n              0x20, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64,\n              0x65, 0x72, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x20, 0x22, 0x49,\n              0x45, 0x54, 0x46, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69,\n              0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x2e, 0x20, 0x53,\n              0x75, 0x63, 0x68, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6d,\n              0x65, 0x6e, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75,\n              0x64, 0x65, 0x20, 0x6f, 0x72, 0x61, 0x6c, 0x20, 0x73, 0x74,\n              0x61, 0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x69,\n              0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x73, 0x65, 0x73,\n              0x73, 0x69, 0x6f, 0x6e, 0x73, 0x2c, 0x20, 0x61, 0x73, 0x20,\n              0x77, 0x65, 0x6c, 0x6c, 0x20, 0x61, 0x73, 0x20, 0x77, 0x72,\n              0x69, 0x74, 0x74, 0x65, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20,\n              0x65, 0x6c, 0x65, 0x63, 0x74, 0x72, 0x6f, 0x6e, 0x69, 0x63,\n              0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61,\n              0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x6d, 0x61, 0x64, 0x65,\n              0x20, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x69,\n              0x6d, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x70, 0x6c, 0x61, 0x63,\n              0x65, 0x2c, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61,\n              0x72, 0x65, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,\n              0x65, 0x64, 0x20, 0x74, 0x6f ]\n\n  rfctest03 = encrypt key 42 (zero # [2]) msg == out\n    where\n      key = [ 0x1c, 0x92, 0x40, 0xa5, 0xeb, 0x55, 0xd3, 0x8a, 0xf3, 0x33,\n              0x88, 0x86, 0x04, 0xf6, 0xb5, 0xf0, 0x47, 0x39, 0x17, 0xc1,\n              0x40, 0x2b, 0x80, 0x09, 0x9d, 0xca, 0x5c, 0xbc, 0x20, 0x70,\n              0x75, 0xc0 ]\n      out = [ 0x27, 0x54, 0x77, 0x61, 0x73, 0x20, 0x62, 0x72, 0x69, 0x6c,\n              0x6c, 0x69, 0x67, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x73, 0x6c, 0x69, 0x74, 0x68, 0x79, 0x20,\n              0x74, 0x6f, 0x76, 0x65, 0x73, 0x0a, 0x44, 0x69, 0x64, 0x20,\n              0x67, 0x79, 0x72, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x67,\n              0x69, 0x6d, 0x62, 0x6c, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x77, 0x61, 0x62, 0x65, 0x3a, 0x0a, 0x41,\n              0x6c, 0x6c, 0x20, 0x6d, 0x69, 0x6d, 0x73, 0x79, 0x20, 0x77,\n              0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6f,\n              0x72, 0x6f, 0x67, 0x6f, 0x76, 0x65, 0x73, 0x2c, 0x0a, 0x41,\n              0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x6f, 0x6d,\n              0x65, 0x20, 0x72, 0x61, 0x74, 0x68, 0x73, 0x20, 0x6f, 0x75,\n              0x74, 0x67, 0x72, 0x61, 0x62, 0x65, 0x2e ]\n\n      msg = [ 0x62, 0xe6, 0x34, 0x7f, 0x95, 0xed, 0x87, 0xa4, 0x5f, 0xfa,\n              0xe7, 0x42, 0x6f, 0x27, 0xa1, 0xdf, 0x5f, 0xb6, 0x91, 0x10,\n              0x04, 0x4c, 0x0d, 0x73, 0x11, 0x8e, 0xff, 0xa9, 0x5b, 0x01,\n              0xe5, 0xcf, 0x16, 0x6d, 0x3d, 0xf2, 0xd7, 0x21, 0xca, 0xf9,\n              0xb2, 0x1e, 0x5f, 0xb1, 0x4c, 0x61, 0x68, 0x71, 0xfd, 0x84,\n              0xc5, 0x4f, 0x9d, 0x65, 0xb2, 0x83, 0x19, 0x6c, 0x7f, 0xe4,\n              0xf6, 0x05, 0x53, 0xeb, 0xf3, 0x9c, 0x64, 0x02, 0xc4, 0x22,\n              0x34, 0xe3, 0x2a, 0x35, 0x6b, 0x3e, 0x76, 0x43, 0x12, 0xa6,\n              0x1a, 0x55, 0x32, 0x05, 0x57, 0x16, 0xea, 0xd6, 0x96, 0x25,\n              0x68, 0xf8, 0x7d, 0x3f, 0x3f, 0x77, 0x04, 0xc6, 0xa8, 0xd1,\n              0xbc, 0xd1, 0xbf, 0x4d, 0x50, 0xd6, 0x15, 0x4b, 0x6d, 0xa7,\n              0x31, 0xb1, 0x87, 0xb5, 0x8d, 0xfd, 0x72, 0x8a, 0xfa, 0x36,\n              0x75, 0x7a, 0x79, 0x7a, 0xc1, 0x88, 0xd1 ]\n\nproperty allTestsPass =\n  and\n  [     qround01, core01, core02\n      , rfctest01, rfctest02, rfctest03\n  ]\n\nprivate\n      blocked : Round -> Block\n  blocked x = join (map toBytes x)\n    where\n                        toBytes : [32] -> [4][8]\n      toBytes v = reverse (groupBy`{8} v)\n\n    map : { a, b, c }\n        (a -> b) -> [c]a -> [c]b\n  map f xs = [ f x | x <- xs ]\n\n          iterate : { a } (a -> a) -> a -> [inf]a\n  iterate f x = [x] # [ f v | v <- iterate f x ]\n    where\n            xs = [x] # [ f v | v <- xs ]\n\n        rjoin : {a, b, c}\n        ( fin a, fin c\n        ) => [c][a]b -> [a * c]b\n  rjoin x = join (reverse x)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/ZUC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module implementing the ZUC stream cipher (key\/IV loading, LFSR modes, S-boxes, F function, keystream generator) with properties ZUC_TestVectors, LoadKey_TestVectors, example8, and ZUC_isResistantToCollisionAttack that all hold as in the given specification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::ZUC where\n\nversion1_5 : Bit\nversion1_5 = True\n\nadd : {a} (fin a) => [a][31] -> [31]\nadd xs =\n    sums ! 0\n    where\n      sums =\n          [0] #\n          [plus (s, x) | s <- sums\n                       | x <- xs]\n            plus : ([31], [31]) -> [31]\n      plus (a, b) =\n          if sab @ 0 then sab' + 1 else sab'\n          where\n            sab : [32]\n            sab = ((zero : [1]) # a) + ((zero : [1]) # b)\n            sab' : [31]\n            sab' = drop sab\n\ntype LFSR = [16][31]\n\nLFSRWithInitializationMode : ([31], LFSR) -> LFSR\nLFSRWithInitializationMode (u, ss) =\n    ss @@ [1 .. 15] # [s16]\n    where\n      v = add [s <<< c | s <- ss @@ [15, 13, 10, 4, 0, 0]\n                       | c <- [15, 17, 21, 20, 8, 0]]\n      vu = if version1_5 then add [v, u] else v ^ u\n      s16 = if vu == 0 then `0x7FFFFFFF else vu\n\nLFSRWithWorkMode : LFSR -> LFSR\nLFSRWithWorkMode ss =\n    ss @@ [1 .. 15] # [s16]\n    where\n      v = add [s <<< c | s <- ss @@ [15, 13, 10, 4, 0, 0]\n                       | c <- [15, 17, 21, 20, 8, 0]]\n      s16 = if v == 0 then `0x7FFFFFFF else v\n\nBitReorganization : LFSR -> [4][32]\nBitReorganization ss =\n    [ hi s15 # lo s14\n    , lo s11 # hi s9\n    , lo s7  # hi s5\n    , lo s2  # hi s0]\n    where\n      lo : [31] -> [16]\n      hi : [31] -> [16]\n      lo x = x @@ [15 .. 30]\n      hi x = x @@ [0  .. 15]\n      [s0, s2, s5, s7, s9, s11, s14, s15] = ss @@ [0, 2, 5, 7, 9, 11, 14, 15]\n\nF : ([3][32], [2][32]) -> ([32], [2][32])\nF ([X0, X1, X2], [R1, R2]) =\n    (W, [R1', R2'])\n    where\n      W = (X0 ^ R1) + R2\n      W1 = R1 + X1\n      W2 = R2 ^ X2\n      [W1H, W1L] = split W1\n      [W2H, W2L] = split W2\n      R1' = S (L1 (W1L # W2H))\n      R2' = S (L2 (W2L # W1H))\n\nS : [32] -> [32]\nS X =\n    Y0 # Y1 # Y2 # Y3\n    where\n      [X0, X1, X2, X3] = split X\n      [Y0, Y1, Y2, Y3] = [S0 X0, S1 X1, S2 X2, S3 X3]\n\nproperty example8 = S(0x12345678) == 0xF9C05A4E\n\nS0 : [8] -> [8]\nS1 : [8] -> [8]\nS2 : [8] -> [8]\nS3 : [8] -> [8]\nS0 x = S0Table @ x\nS1 x = S1Table @ x\nS2 = S0\nS3 = S1\n\nS0Table : [256][8]\nS0Table =\n    [0x3E, 0x72, 0x5B, 0x47, 0xCA, 0xE0, 0x00, 0x33, 0x04, 0xD1, 0x54,\n     0x98, 0x09, 0xB9, 0x6D, 0xCB, 0x7B, 0x1B, 0xF9, 0x32, 0xAF, 0x9D,\n     0x6A, 0xA5, 0xB8, 0x2D, 0xFC, 0x1D, 0x08, 0x53, 0x03, 0x90, 0x4D,\n     0x4E, 0x84, 0x99, 0xE4, 0xCE, 0xD9, 0x91, 0xDD, 0xB6, 0x85, 0x48,\n     0x8B, 0x29, 0x6E, 0xAC, 0xCD, 0xC1, 0xF8, 0x1E, 0x73, 0x43, 0x69,\n     0xC6, 0xB5, 0xBD, 0xFD, 0x39, 0x63, 0x20, 0xD4, 0x38, 0x76, 0x7D,\n     0xB2, 0xA7, 0xCF, 0xED, 0x57, 0xC5, 0xF3, 0x2C, 0xBB, 0x14, 0x21,\n     0x06, 0x55, 0x9B, 0xE3, 0xEF, 0x5E, 0x31, 0x4F, 0x7F, 0x5A, 0xA4,\n     0x0D, 0x82, 0x51, 0x49, 0x5F, 0xBA, 0x58, 0x1C, 0x4A, 0x16, 0xD5,\n     0x17, 0xA8, 0x92, 0x24, 0x1F, 0x8C, 0xFF, 0xD8, 0xAE, 0x2E, 0x01,\n     0xD3, 0xAD, 0x3B, 0x4B, 0xDA, 0x46, 0xEB, 0xC9, 0xDE, 0x9A, 0x8F,\n     0x87, 0xD7, 0x3A, 0x80, 0x6F, 0x2F, 0xC8, 0xB1, 0xB4, 0x37, 0xF7,\n     0x0A, 0x22, 0x13, 0x28, 0x7C, 0xCC, 0x3C, 0x89, 0xC7, 0xC3, 0x96,\n     0x56, 0x07, 0xBF, 0x7E, 0xF0, 0x0B, 0x2B, 0x97, 0x52, 0x35, 0x41,\n     0x79, 0x61, 0xA6, 0x4C, 0x10, 0xFE, 0xBC, 0x26, 0x95, 0x88, 0x8A,\n     0xB0, 0xA3, 0xFB, 0xC0, 0x18, 0x94, 0xF2, 0xE1, 0xE5, 0xE9, 0x5D,\n     0xD0, 0xDC, 0x11, 0x66, 0x64, 0x5C, 0xEC, 0x59, 0x42, 0x75, 0x12,\n     0xF5, 0x74, 0x9C, 0xAA, 0x23, 0x0E, 0x86, 0xAB, 0xBE, 0x2A, 0x02,\n     0xE7, 0x67, 0xE6, 0x44, 0xA2, 0x6C, 0xC2, 0x93, 0x9F, 0xF1, 0xF6,\n     0xFA, 0x36, 0xD2, 0x50, 0x68, 0x9E, 0x62, 0x71, 0x15, 0x3D, 0xD6,\n     0x40, 0xC4, 0xE2, 0x0F, 0x8E, 0x83, 0x77, 0x6B, 0x25, 0x05, 0x3F,\n     0x0C, 0x30, 0xEA, 0x70, 0xB7, 0xA1, 0xE8, 0xA9, 0x65, 0x8D, 0x27,\n     0x1A, 0xDB, 0x81, 0xB3, 0xA0, 0xF4, 0x45, 0x7A, 0x19, 0xDF, 0xEE,\n     0x78, 0x34, 0x60]\n\nS1Table : [256][8]\nS1Table =\n    [0x55, 0xC2, 0x63, 0x71, 0x3B, 0xC8, 0x47, 0x86, 0x9F, 0x3C, 0xDA,\n     0x5B, 0x29, 0xAA, 0xFD, 0x77, 0x8C, 0xC5, 0x94, 0x0C, 0xA6, 0x1A,\n     0x13, 0x00, 0xE3, 0xA8, 0x16, 0x72, 0x40, 0xF9, 0xF8, 0x42, 0x44,\n     0x26, 0x68, 0x96, 0x81, 0xD9, 0x45, 0x3E, 0x10, 0x76, 0xC6, 0xA7,\n     0x8B, 0x39, 0x43, 0xE1, 0x3A, 0xB5, 0x56, 0x2A, 0xC0, 0x6D, 0xB3,\n     0x05, 0x22, 0x66, 0xBF, 0xDC, 0x0B, 0xFA, 0x62, 0x48, 0xDD, 0x20,\n     0x11, 0x06, 0x36, 0xC9, 0xC1, 0xCF, 0xF6, 0x27, 0x52, 0xBB, 0x69,\n     0xF5, 0xD4, 0x87, 0x7F, 0x84, 0x4C, 0xD2, 0x9C, 0x57, 0xA4, 0xBC,\n     0x4F, 0x9A, 0xDF, 0xFE, 0xD6, 0x8D, 0x7A, 0xEB, 0x2B, 0x53, 0xD8,\n     0x5C, 0xA1, 0x14, 0x17, 0xFB, 0x23, 0xD5, 0x7D, 0x30, 0x67, 0x73,\n     0x08, 0x09, 0xEE, 0xB7, 0x70, 0x3F, 0x61, 0xB2, 0x19, 0x8E, 0x4E,\n     0xE5, 0x4B, 0x93, 0x8F, 0x5D, 0xDB, 0xA9, 0xAD, 0xF1, 0xAE, 0x2E,\n     0xCB, 0x0D, 0xFC, 0xF4, 0x2D, 0x46, 0x6E, 0x1D, 0x97, 0xE8, 0xD1,\n     0xE9, 0x4D, 0x37, 0xA5, 0x75, 0x5E, 0x83, 0x9E, 0xAB, 0x82, 0x9D,\n     0xB9, 0x1C, 0xE0, 0xCD, 0x49, 0x89, 0x01, 0xB6, 0xBD, 0x58, 0x24,\n     0xA2, 0x5F, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xB8, 0x95, 0xE4,\n     0xD0, 0x91, 0xC7, 0xCE, 0xED, 0x0F, 0xB4, 0x6F, 0xA0, 0xCC, 0xF0,\n     0x02, 0x4A, 0x79, 0xC3, 0xDE, 0xA3, 0xEF, 0xEA, 0x51, 0xE6, 0x6B,\n     0x18, 0xEC, 0x1B, 0x2C, 0x80, 0xF7, 0x74, 0xE7, 0xFF, 0x21, 0x5A,\n     0x6A, 0x54, 0x1E, 0x41, 0x31, 0x92, 0x35, 0xC4, 0x33, 0x07, 0x0A,\n     0xBA, 0x7E, 0x0E, 0x34, 0x88, 0xB1, 0x98, 0x7C, 0xF3, 0x3D, 0x60,\n     0x6C, 0x7B, 0xCA, 0xD3, 0x1F, 0x32, 0x65, 0x04, 0x28, 0x64, 0xBE,\n     0x85, 0x9B, 0x2F, 0x59, 0x8A, 0xD7, 0xB0, 0x25, 0xAC, 0xAF, 0x12,\n     0x03, 0xE2, 0xF2]\n\nL1 : [32] -> [32]\nL1 X = X ^ X <<< 2 ^ X <<< 10 ^ X <<< 18 ^ X <<< 24\n\nL2 : [32] -> [32]\nL2 X = X ^ X <<< 8 ^ X <<< 14 ^ X <<< 22 ^ X <<< 30\n\nLoadKey : ([128], [128]) -> LFSR\nLoadKey (key, iv) =\n    [k # d # i | k <- ks\n               | i <- is\n               | d <- ds]\n    where\n      ks : [16][8]\n      ks = split key\n      is : [16][8]\n      is = split iv\n      ds : [16][15]\n      ds =\n          [ 0b100010011010111, 0b010011010111100\n          , 0b110001001101011, 0b001001101011110\n          , 0b101011110001001, 0b011010111100010\n          , 0b111000100110101, 0b000100110101111\n          , 0b100110101111000, 0b010111100010011\n          , 0b110101111000100, 0b001101011110001\n          , 0b101111000100110, 0b011110001001101\n          , 0b111100010011010, 0b100011110101100\n          ]\n\ntype ZUC = (LFSR, [32], [32])\n\nInitializeZUC : ([128], [128]) -> [inf]ZUC\nInitializeZUC (key, iv) =\n    outs\n    where\n      initLFSR = LoadKey (key, iv)\n      outs = [(initLFSR, 0, 0)] # [step out | out <- outs]\n      step (lfsr, R1, R2) =\n          (LFSRWithInitializationMode (drop (w >> 1), lfsr), R1', R2')\n          where\n            [X0, X1, X2, X3] = BitReorganization lfsr\n            (w', [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n            w = if version1_5 then w' else w' ^ X3\n\n\/\/ Section 3.6.2\nWorkingStage : ZUC -> ZUC\nWorkingStage (lfsr, R1, R2) =\n    (lfsr', R1', R2')\n    where\n      [X0, X1, X2, _] = BitReorganization lfsr\n      (_, [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n      lfsr' = LFSRWithWorkMode lfsr\n\n\/\/ Section 3.6.2\nProductionStage : ZUC -> ([32], ZUC)\nProductionStage (lfsr, R1, R2) =\n    (w ^ X3, (lfsr', R1', R2'))\n    where\n      [X0, X1, X2, X3] = BitReorganization lfsr\n      (w, [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n      lfsr' = LFSRWithWorkMode lfsr\n\n\/\/ ZUC API\nZUC : [128] -> [128] -> [inf][32]\nZUC key iv =\n    tail [w | (w, _) <- zucs]\n    where\n      initZuc = WorkingStage (InitializeZUC (key, iv) @ 32)\n      zucs = [(zero, initZuc)] # [ProductionStage zuc | (_, zuc) <- zucs]\n\n\/\/ Test vectors\nproperty ZUC_TestVectors =\n    t1 \/\\ t2 \/\\ t3 \/\\ t4\n    where\n      t1 = take (ZUC zero    zero   ) == [0x27BEDE74, 0x018082DA]\n      t2 = take (ZUC (~zero) (~zero)) == [0x0657CFA0, 0x7096398B]\n      t3 = take (ZUC (join [ 0x3D, 0x4C, 0x4B, 0xE9, 0x6A, 0x82, 0xFD, 0xAE\n                           , 0xB5, 0x8F, 0x64, 0x1D, 0xB1, 0x7B, 0x45, 0x5B\n                           ])\n                     (join [ 0x84, 0x31, 0x9A, 0xA8, 0xDE, 0x69, 0x15, 0xCA\n                           , 0x1F, 0x6B, 0xDA, 0x6B, 0xFB, 0xD8, 0xC7, 0x66\n                           ])) == [0x14F1C272, 0x3279C419]\n      t4 = take ks # [ks @ 1999] == [0xED4400E7, 0x0633E5C5, 0x7A574CDB]\n        where\n          ks = ZUC (join [ 0x4D, 0x32, 0x0B, 0xFA, 0xD4, 0xC2, 0x85, 0xBF\n                         , 0xD6, 0xB8, 0xBD, 0x00, 0xF3, 0x9D, 0x8B, 0x41\n                         ])\n                   (join [ 0x52, 0x95, 0x9D, 0xAB, 0xA0, 0xBF, 0x17, 0x6E\n                         , 0xCE, 0x2D, 0xC3, 0x15, 0x04, 0x9E, 0xB5, 0x74\n                         ])\n\n\/\/ 3.3-3.6 of the implementor's test data document lists \"LFSR-state at the\n\/\/ beginning\", which is immediately after running LoadKey.\nproperty LoadKey_TestVectors =\n    [ LoadKey(k, iv) == lfsr0\n    | k <- ks\n    | iv <- ivs\n    | lfsr0 <- lfsr0s\n    ] == ~0\n  where\n    ks = [ 0\n         , ~0\n         , 0x3d4c4be96a82fdaeb58f641db17b455b\n         , 0x4d320bfad4c285bfd6b8bd00f39d8b41\n         ]\n    ivs = [ 0\n          , ~0\n          , 0x84319aa8de6915ca1f6bda6bfbd8c766\n          , 0x52959daba0bf176ece2dc315049eb574\n          ]\n    lfsr0s = [ [ `0x0044d700, `0x0026bc00, `0x00626b00, `0x00135e00\n               , `0x00578900, `0x0035e200, `0x00713500, `0x0009af00\n               , `0x004d7800, `0x002f1300, `0x006bc400, `0x001af100\n               , `0x005e2600, `0x003c4d00, `0x00789a00, `0x0047ac00\n               ]\n             , [ `0x7fc4d7ff, `0x7fa6bcff, `0x7fe26bff, `0x7f935eff\n               , `0x7fd789ff, `0x7fb5e2ff, `0x7ff135ff, `0x7f89afff\n               , `0x7fcd78ff, `0x7faf13ff, `0x7febc4ff, `0x7f9af1ff\n               , `0x7fde26ff, `0x7fbc4dff, `0x7ff89aff, `0x7fc7acff\n               ]\n             , [ `0x1ec4d784, `0x2626bc31, `0x25e26b9a, `0x74935ea8\n               , `0x355789de, `0x4135e269, `0x7ef13515, `0x5709afca\n               , `0x5acd781f, `0x47af136b, `0x326bc4da, `0x0e9af16b\n               , `0x58de26fb, `0x3dbc4dd8, `0x22f89ac7, `0x2dc7ac66\n               ]\n             , [ `0x26c4d752, `0x1926bc95, `0x05e26b9d, `0x7d135eab\n               , `0x6a5789a0, `0x6135e2bf, `0x42f13517, `0x5f89af6e\n               , `0x6b4d78ce, `0x5c2f132d, `0x5eebc4c3, `0x001af115\n               , `0x79de2604, `0x4ebc4d9e, `0x45f89ab5, `0x20c7ac74\n               ]\n             ]\n\nproperty ZUC_isResistantToCollisionAttack k iv1 iv2 =\n    if iv1 != iv2\n    then InitializeZUC (k, iv1) @ 1 != InitializeZUC (k, iv2) @ 1\n    else True\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/McMambo.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module implementing the McMambo tweakable block cipher (including Mambo\/Mambo_bytes and McMambo AEAD) over 32-bit words, along with properties proving bijectivity of T, Q, D, key\/tweak injection correctness, byte\/word conversion round-trips, and that C' inverts C and Mambo' inverts Mambo."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::McMambo where\n\ntype word = [32]\ntype state = [4][4]word\ntype key = [8]word\ntype tweak = [16]word\ntype block = [16]word\n\nnand : {a} [a] -> [a] -> [a]\nnand x y = ~(x && y)\n\nnor : {a} [a] -> [a] -> [a]\nnor x y = ~(x || y)\n\n(\u2191) = nand\n(\u2193) = nor\n(\u2295) = (^)\n(\u2227) = (&&)\n(\u2228) = (||)\n\nR : (word, word) -> word\nR (x, c) = x <<< c\n\nT : word -> tweak -> state -> state\nT n t s = s \u2295 (if n == 5 then split t else zero)\n\nproperty T_bijective t n s s' =\n  (s != s') == (T n t s != T n t s')\n\n\/**\n * ```repl\n * :prove T_inverse\n * ```\n *\/\nproperty T_inverse n t s =\n  T n t (T n t s) == s\n\nQ : [4]word -> [4]word\nQ [x0, x1, x2, x3] = [y0, y1, y2, y3]\n  where\n    y1 = x1 \u2295 R (x0 \u2227 x2, 7)\n    y2 = x2 \u2295 R (x0 \u2228 x3, 9)\n    y3 = x3 \u2295 R (y1 \u2191 x0, 13)\n    y0 = x0 \u2295 R (y1 \u2193 y2, 18)\n\n\/**\n * ```repl\n * :prove Q_bijective\n * ```\n *\/\nproperty Q_bijective x x' =\n  (x != x') == (Q x != Q x')\n\nD : state -> state\nD X = Z\n  where\n    Y = transpose [ Q xs | xs <- X ]\n    Z = transpose [ Q ys | ys <- Y ]\n\nD' : state -> state\nD' X = Z\n  where\n    Y = [ Q xs | xs <- transpose X ]\n    Z = [ Q ys | ys <- transpose Y ]\n\nD_verbose : state -> state\nD_verbose [ [ x0,  x1,  x2,  x3]\n          , [ x4,  x5,  x6,  x7]\n          , [ x8,  x9, x10, x11]\n          , [x12, x13, x14, x15] ] = Z\n  where\n    [ y0,  y1,  y2,  y3] = Q [ x0,  x1,  x2,  x3]\n    [ y4,  y5,  y6,  y7] = Q [ x4,  x5,  x6,  x7]\n    [ y8,  y9, y10, y11] = Q [ x8,  x9, x10, x11]\n    [y12, y13, y14, y15] = Q [x12, x13, x14, x15]\n    [ z0,  z4,  z8, z12] = Q [ y0,  y4,  y8, y12]\n    [ z1,  z5,  z9, z13] = Q [ y1,  y5,  y9, y13]\n    [ z2,  z6, z10, z14] = Q [ y2,  y6, y10, y14]\n    [ z3,  z7, z11, z15] = Q [ y3,  y7, y11, y15]\n    Z = [ [ z0,  z1,  z2,  z3]\n        , [ z4,  z5,  z6,  z7]\n        , [ z8,  z9, z10, z11]\n        , [z12, z13, z14, z15] ]\n\nD'_verbose : state -> state\nD'_verbose [ [ x0,  x1,  x2,  x3]\n           , [ x4,  x5,  x6,  x7]\n           , [ x8,  x9, x10, x11]\n           , [x12, x13, x14, x15] ] = Z\n  where\n    [ y0,  y4,  y8, y12] = Q [ x0,  x4,  x8, x12]\n    [ y1,  y5,  y9, y13] = Q [ x1,  x5,  x9, x13]\n    [ y2,  y6, y10, y14] = Q [ x2,  x6, x10, x14]\n    [ y3,  y7, y11, y15] = Q [ x3,  x7, x11, x15]\n    [ z0,  z1,  z2,  z3] = Q [ y0,  y1,  y2,  y3]\n    [ z4,  z5,  z6,  z7] = Q [ y4,  y5,  y6,  y7]\n    [ z8,  z9, z10, z11] = Q [ y8,  y9, y10, y11]\n    [z12, z13, z14, z15] = Q [y12, y13, y14, y15]\n    Z = [ [ z0,  z1,  z2,  z3]\n        , [ z4,  z5,  z6,  z7]\n        , [ z8,  z9, z10, z11]\n        , [z12, z13, z14, z15] ]\n\nproperty D_matches =\n  D === D_verbose\n\nproperty D'_matches =\n  D' === D'_verbose\n\n\/\/ Not yet true\n\/*property*\/\nD_D'_correct s =\n  D' (D s) == s\n\nK : key -> word -> state -> state\nK [k0, k1, k2, k3, k4, k5, k6, k7] j x =\n  x \u2295 [ [  j, k0,  0, k1 ]\n      , [ k2,  j, k3,  0 ]\n      , [  0, k4,  j, k5 ]\n      , [ k6,  0, k7,  j ]\n      ]\n\n\/**\n * ```repl\n * :prove K_inverse\n * ```\n *\/\nproperty K_inverse k j s =\n  K k j (K k j s) == s\n\nC1 : key -> tweak -> state -> state\nC1 k t s0 = K k 0 (T 1 t (D (K k 1 (T 0 t (D (K k 0 s0))))))\n\nC : key -> tweak -> state -> state\nC k t s0 = K k 0 (ss!0)\n  where\n    ss : [13]state\n    ss = [s0] # [ T n t (D (K k n s)) | s <- ss | n <- [0..11] ]\n\nC' : key -> tweak -> state -> state\nC' k t s0 = ss!0\n  where\n    ss : [13]state\n    ss = [K k 0 s0] # [ K k n (D' (T n t s)) | s <- ss | n <- reverse [0..11] ]\n\nfrom_bytes : {a} [a*4][8] -> [a][32]\nfrom_bytes bytes = [ join (reverse xs) | (xs : [4][8]) <- blocks ]\n  where blocks : [a][4][8]\n        blocks = split bytes\n\nto_bytes : {a} [a][32] -> [a*4][8]\nto_bytes words = join [ reverse (split word : [4][8]) | word <- words ]\n\nproperty from_to_bytes (words : [16][32]) =\n  from_bytes (to_bytes words) == words\n\nproperty to_from_bytes (bytes : [64][8]) =\n  to_bytes (from_bytes bytes) == bytes\n\nC_C'_correct k t s0 =\n  C' k t (C k t s0) == s0\n\npad : {n, b} (fin n, b == (n+8) \/^ 512) => [n] -> [b][512]\npad m = split (m # 0x01 # zero)\n\npad_bytes : {n, b} (fin n, b == (n+1) \/^ 64) => [n][8] -> [b*64][8]\npad_bytes m = m # [0x01] # zero\n\nMambo : key -> tweak -> block -> block\nMambo k t m = join (C k t (split m))\n\nMambo' : key -> tweak -> block -> block\nMambo' k t m = join (C' k t (split m))\n\nMambo_bytes : [_][8] -> [_][8] -> [_][8] -> _\nMambo_bytes k t m = to_bytes (Mambo (from_bytes k) (from_bytes t) (from_bytes m))\n\nMambo_bytes' : [_][8] -> [_][8] -> [_][8] -> _\nMambo_bytes' k t m = to_bytes (Mambo' (from_bytes k) (from_bytes t) (from_bytes m))\n\nproperty Mambo_test =\n  join (Mambo_bytes (\"Me\" # zero) (\"Try\" # zero) (\"Test\" # zero)) ==\n  0xeb514a1ff2609f3a81ccfdd5e5342dba332d7b159a1571cee66d14bb6fd48ceb1ae956a91d3f54c8a545262c26611245a917d0a1582ecbc1d397b612baf7a62d\n\nMcMambo k ad npub M = undefined\n  where\n    Us = [zero] # [ u ^ Mambo_bytes k u a | u <- Us | a <- split (pad_bytes ad) ]\n    \u03c4 = Mambo_bytes k (Us!0) npub\n    u' = (Us!0) ^ \u03c4\n    Cs = [ Mambo_bytes k u m | u <- undefined | m <- split (pad_bytes M # \u03c4)]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/PRESENT.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that fully specifies the PRESENT block cipher (64-bit block, 80- and 128-bit keys), including key schedule, encryption\/decryption functions, known-answer test vectors, and properties stating that decryption inverts encryption for all supported key sizes."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::PRESENT where\n\ntype PrBlockSize = 64\ntype State = [4][4][4]\ntype StdBlockSize = 32\ntype PrKeySize = 80\ntype PrRkeySize = 64\ntype PrKeySize128 = 128\n\nsbox = [0xc, 0x5, 0x6, 0xb, 0x9, 0x0, 0xa, 0xd, 0x3, 0xe, 0xf, 0x8, 0x4, 0x7, 0x1, 0x2]\n\nSbox_inv = [0x5, 0xe, 0xf, 0x8, 0xc, 0x1, 0x2, 0xd, 0xb, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xa]\n\npbox = [0x00, 0x10, 0x20, 0x30, 0x01, 0x11, 0x21, 0x31, 0x02, 0x12, 0x22,\n        0x32, 0x03, 0x13, 0x23, 0x33, 0x04, 0x14, 0x24, 0x34, 0x05, 0x15,\n        0x25, 0x35, 0x06, 0x16, 0x26, 0x36, 0x07, 0x17, 0x27, 0x37, 0x08,\n        0x18, 0x28, 0x38, 0x09, 0x19, 0x29, 0x39, 0x0a, 0x1a, 0x2a, 0x3a,\n        0x0b, 0x1b, 0x2b, 0x3b, 0x0c, 0x1c, 0x2c, 0x3c, 0x0d, 0x1d, 0x2d,\n        0x3d, 0x0e, 0x1e, 0x2e, 0x3e, 0x0f, 0x1f, 0x2f, 0x3f]\n\npbox_inv = [0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c, 0x20, 0x24, 0x28,\n          0x2c, 0x30, 0x34, 0x38, 0x3c, 0x01, 0x05, 0x09, 0x0d, 0x11, 0x15,\n          0x19, 0x1d, 0x21, 0x25, 0x29, 0x2d, 0x31, 0x35, 0x39, 0x3d, 0x02,\n          0x06, 0x0a, 0x0e, 0x12, 0x16, 0x1a, 0x1e, 0x22, 0x26, 0x2a, 0x2e,\n          0x32, 0x36, 0x3a, 0x3e, 0x03, 0x07, 0x0b, 0x0f, 0x13, 0x17, 0x1b,\n          0x1f, 0x23, 0x27, 0x2b, 0x2f, 0x33, 0x37, 0x3b, 0x3f]\n\nupdateKey : [PrKeySize] -> [5] -> _\nupdateKey key i =  (rkey, shift, res,  key'')\n            where rkey = key !![79,78..16]\n                  shift =  (key !! [18,17..0]) # (key !! [79,78..19])\n                  res = sbox@((shift) !! [79,78,77, 76]) # (shift !! [75,74..0])\n                  key'' =  (res !! [79,78..20]) # ((res!![19,18..15])^(i+1)) # (res!![14,13..0])\n\nRoundKeyList : [PrKeySize] -> _\n\nRoundKeyList key = hs\n             where hs = [ (updateKey key 0) ] # [(updateKey (key'.3) i)\n                                                | i<- [1,2..31]\n                                                | key' <- hs\n                                                 ]\n\naddRoundKey : State -> State -> State\naddRoundKey pt key = pt ^ key\n\nSubCell : [4] -> [4]\nSubCell st = sbox@st\n\nSubCells : State -> State\nSubCells st = [ [ SubCell b | b<- row ] | row <- st ]\n\nSubCell_dec : [4] -> [4]\nSubCell_dec st = Sbox_inv@st\n\nSubCells_dec : State -> State\nSubCells_dec st = [ [ SubCell_dec b | b<- row ] | row <- st ]\n\nmsgToState : [PrBlockSize] -> State\nmsgToState msg = split (split msg)\n\nstateToMsg : State -> [PrBlockSize]\nstateToMsg st = join (join st)\n\nSubpLayer: [PrBlockSize] -> [PrBlockSize]\nSubpLayer pt =  hs\n          where hs = [ pt!(pbox_inv ! i) | i <- [0,1..63] ]\n\nSubpLayer_dec: [PrBlockSize] -> [PrBlockSize]\nSubpLayer_dec pt =  hs\n          where hs = [ pt!(pbox ! i) | i <- [0,1..63] ]\n\nroundEncrypt:  (State, State) -> State\nroundEncrypt (pt, key) = msgToState(SubpLayer(stateToMsg(SubCells (addRoundKey pt key))))\n\nroundDecrypt:  (State, State) -> State\nroundDecrypt (pt, key) = SubCells_dec (msgToState(SubpLayer_dec (stateToMsg (addRoundKey pt key))))\n\nPrEncrypt : ([PrKeySize], [PrBlockSize]) -> [PrBlockSize]\nPrEncrypt (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                where hs = [ roundEncrypt (msgToState(pt), msgToState((key'@0).0)) ] # [ roundEncrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [1,2..30]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList key)\n\nPrDecrypt : ([PrKeySize], [PrBlockSize]) -> _\nPrDecrypt (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@0).0))\n                where hs = [ roundDecrypt (msgToState(pt), msgToState((key'@31).0)) ] # [ roundDecrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [30,29..1]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList key)\n\nproperty PresentCorrectnes key m = PrDecrypt( key, PrEncrypt(key, m)) == m\n\nupdateKey_128 : [PrKeySize128] -> [5] -> _\nupdateKey_128 key i =  (rkey, key'')\n            where rkey = key !![127,126..64]\n                  shift =  (key !! [66,65..0]) # (key !! [127,126..67])\n                  res = sbox@((shift) !! [127,126,125, 124]) # sbox@((shift) !! [123,122,121, 120]) # (shift !! [119,118..0])\n                  key'' =  (res !! [127,126..67]) # ((res!![66,65,64,63,62])^(i+1)) # (res!![61,60..0])\n\nRoundKeyList_128: [PrKeySize128] -> _\n\nRoundKeyList_128 key = hs\n             where hs = [ (updateKey_128 key 0)] # [ (updateKey_128 (key'.1) i)\n                                                   | i <- [1,2..31]\n                                                   | key' <- hs ]\n\nPrEncrypt_128 : ([PrKeySize128], [PrBlockSize]) -> _\nPrEncrypt_128 (key , pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                         \/\/stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                where hs = [ roundEncrypt (msgToState(pt), msgToState((key'@0).0)) ] # [ roundEncrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [1,2..30]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList_128 key)\n\n\/\/Decryption-128bit\n\nPrDecrypt_128 : ([PrKeySize128], [PrBlockSize]) -> _\nPrDecrypt_128 (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@0).0))\n                where hs = [ roundDecrypt (msgToState(pt), msgToState((key'@31).0)) ] # [ roundDecrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [30,29..1]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList_128 key)\n\n\/\/Correctness\n\nproperty PresentCorrectnes128 key m = PrDecrypt_128(key, PrEncrypt_128(key, m)) == m\n\n\/\/ Heleper function to perform analaysis\n\nprEncrypt64 : ([PrBlockSize], [PrBlockSize]) -> [PrBlockSize]\nprEncrypt64 (key, pt)  = PrEncrypt_128 (key#zero, pt)\n\nprDecrypt64 : ([PrBlockSize], [PrBlockSize]) -> [PrBlockSize]\nprDecrypt64 (key, ct)  = PrDecrypt_128(key#zero , ct)\n\nproperty PrCorrect64 key m = prDecrypt64 (key, (prEncrypt64(key, m))) == m\n\nprEncrypt128 : ([PrKeySize128], [PrKeySize128]) -> [PrKeySize128]\nprEncrypt128 (key, pt)  = PrEncrypt_128(key, (take`{64} pt)) # zero\n\n\/\/ Testing\ntests = [test80_1, test80_2, test80_3, test80_4, test80_5, test128_1]\nproperty testsPass = and tests\n\/\/keysize: 80bits\n\ntest80_1 =  PrEncrypt (zero, zero) == 0x5579c1387b228445\ntest80_2 =  PrEncrypt (zero, zero) == 0x5579c1387b228445\ntest80_3 =  PrEncrypt (0xffffffffffffffffffff, zero) == 0xe72c46c0f5945049\ntest80_4 =  PrEncrypt (0xffffffffffffffffffff, 0xffffffffffffffff) == 0x3333dcd3213210d2\ntest80_5 =  PrEncrypt (zero, 0xffffffffffffffff) == 0xa112ffc72f68417b\n\n\/\/keysize: 128bits\n\ntest128_1 = PrEncrypt_128 ( 0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0x0e9d28685e671dd6\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Cipher.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the module `Primitive::Symmetric::Cipher::Block::Cipher` that introduces the polymorphic `Cipher` type with `encrypt` and `decrypt` functions over bitvector key and block sizes, suitable as an interface for block cipher specifications."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Cipher where\n\ntype Cipher KeySize BlockSize =\n  { encrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  , decrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/GOST.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that fully specifies the GOST 64-bit block cipher (with 256-bit key), including encryption\/decryption functions, key schedule, S-boxes, and properties gostCorrect and gostCorrect64 showing decryption inverts encryption for all keys and messages."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::GOST where\n\ntype BlockSize = 64\ntype StdBlockSize = 32\ntype KeySize = 256\n\nsbox = [\n    [0x4, 0xa, 0x9, 0x2, 0xd, 0x8, 0x0, 0xe, 0x6, 0xb, 0x1, 0xc, 0x7, 0xf, 0x5, 0x3],\n    [0xe, 0xb, 0x4, 0xc, 0x6, 0xd, 0xf, 0xa, 0x2, 0x3, 0x8, 0x1, 0x0, 0x7, 0x5, 0x9],\n    [0x5, 0x8, 0x1, 0xd, 0xa, 0x3, 0x4, 0x2, 0xe, 0xf, 0xc, 0x7, 0x6, 0x0, 0x9, 0xb],\n    [0x7, 0xd, 0xa, 0x1, 0x0, 0x8, 0x9, 0xf, 0xe, 0x4, 0x6, 0xc, 0xb, 0x2, 0x5, 0x3],\n    [0x6, 0xc, 0x7, 0x1, 0x5, 0xf, 0xd, 0x8, 0x4, 0xa, 0x9, 0xe, 0x0, 0x3, 0xb, 0x2],\n    [0x4, 0xb, 0xa, 0x0, 0x7, 0x2, 0x1, 0xd, 0x3, 0x6, 0x8, 0x5, 0x9, 0xc, 0xf, 0xe],\n    [0xd, 0xb, 0x4, 0x1, 0x3, 0xf, 0x5, 0x9, 0x0, 0xa, 0xe, 0x7, 0x6, 0x8, 0x2, 0xc],\n    [0x1, 0xf, 0xd, 0x0, 0x5, 0x7, 0xa, 0x4, 0x9, 0x2, 0x3, 0xe, 0x6, 0xb, 0x8, 0xc]\n    ]\n\nsbox_rec = [\n         [0xc, 0x4, 0x6, 0x2, 0xa, 0x5, 0xb, 0x9, 0xe, 0x8, 0xd, 0x7, 0x0, 0x3, 0xf, 0x1],\n         [0x6, 0x8, 0x2, 0x3, 0x9, 0xa, 0x5, 0xc, 0x1, 0xe, 0x4, 0x7, 0xb, 0xd, 0x0, 0xf],\n         [0xb, 0x3, 0x5, 0x8, 0x2, 0xf, 0xa, 0xd, 0xe, 0x1, 0x7, 0x4, 0xc, 0x9, 0x6, 0x0],\n         [0xc, 0x8, 0x2, 0x1, 0xd, 0x4, 0xf, 0x6, 0x7, 0x0, 0xa, 0x5, 0x3, 0xe, 0x9, 0xb],\n         [0x7, 0xf, 0x5, 0xa, 0x8, 0x1, 0x6, 0xd, 0x0, 0x9, 0x3, 0xe, 0xb, 0x4, 0x2, 0xc],\n         [0x5, 0xd, 0xf, 0x6, 0x9, 0x2, 0xc, 0xa, 0xb, 0x7, 0x8, 0x1, 0x4, 0x3, 0xe, 0x0],\n         [0x8, 0xe, 0x2, 0x5, 0x6, 0x9, 0x1, 0xc, 0xf, 0x4, 0xb, 0x0, 0xd, 0xa, 0x3, 0x7],\n         [0x1, 0x7, 0xe, 0xd, 0x0, 0x5, 0x8, 0x3, 0x4, 0xf, 0xa, 0x6, 0x9, 0xc, 0xb, 0x2]\n         ]\n\nsplitPt: [BlockSize] -> [2][StdBlockSize]\nsplitPt pt = split pt:[2][StdBlockSize]\n\nkeySchedule : [KeySize] -> [8][StdBlockSize]\nkeySchedule key = split key : [8][StdBlockSize]\n\nroundKey:[KeySize] ->  _\nroundKey key = [ rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0\n                 ]\n         where rk = (keySchedule key)\nroundKey':[KeySize] ->  _\nroundKey' key = [ rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0\n                 ]\n         where rk = (keySchedule key)\n\nroundFun : [StdBlockSize]-> [StdBlockSize] -> [StdBlockSize]\nroundFun subpt subkey = roundRes\n            where res = subpt + subkey\n                  splitRes = split res: [8][4]\n                  subSboxRes = [ (sbox@i)@(splitRes@i) | i<- [0..7] ]\n                  roundRes = (join subSboxRes) <<< 11\n\nroundEncryption: [StdBlockSize] -> [StdBlockSize] -> [StdBlockSize] -> [BlockSize]\nroundEncryption lpt rpt rkey =  rpt # (lpt ^ (roundFun rpt rkey))\n\ngostEncrypt: ([KeySize], [BlockSize]) ->  [BlockSize]\ngostEncrypt (key, pt) = hs'\n            where hs = [(roundEncryption left right (round_key@0))]  # [ (roundEncryption ((splitPt pT)@0) ((splitPt pT)@1) (round_key@i))\n                                                  | i <- [1,2..31]\n                                                  | pT <- hs\n                                                  ]\n                  splt_pt = (splitPt pt)\n                  left = splt_pt@0\n                  right = splt_pt@1\n                  round_key = (roundKey key)\n                  hs' = hs!0\n\nroundDecryption: [StdBlockSize] -> [StdBlockSize] -> [StdBlockSize] -> [BlockSize]\nroundDecryption lpt rpt rkey =  (rpt ^ (roundFun lpt rkey)) # lpt\n\ngostDecrypt: ([KeySize], [BlockSize]) ->  [BlockSize]\ngostDecrypt (key, ct) = hs'\n            where hs = [(roundDecryption left right (round_key@0))]  # [ (roundDecryption ((splitPt pT)@0) ((splitPt pT)@1) (round_key@i))\n                                                  | i <- [1,2..31]\n                                                  | pT <- hs\n                                                  ]\n                  splt_pt = (splitPt ct)\n                  left = splt_pt@0\n                  right = splt_pt@1\n                  round_key = (roundKey' key)\n                  hs' = hs!0\n\n\/\/ Correctness\n\nproperty gostCorrect key m = gostDecrypt(key, gostEncrypt(key, m)) == m\n\n\/\/ Helper functions to perform analysis\n\ngostEncrypt64: ([BlockSize],[BlockSize]) -> [BlockSize]\ngostEncrypt64 (pt, key)  = gostEncrypt(key', pt)\n             where key' = key # zero\n\ngostDecrypt64 : ([BlockSize], [BlockSize]) -> [BlockSize]\ngostDecrypt64 (ct, key)  = gostDecrypt(key', ct)\n             where key' = key #zero\n\nproperty gostCorrect64 key m = gostDecrypt64( key, gostEncrypt64(key, m)) == m\n\n\/\/ To analyze the schemes from 5 through 20, we take |mi| = k  where k > n (block size)\n\ngostEncrypt256 : ([KeySize], [KeySize]) -> [KeySize]\ngostEncrypt256 (pt, key) = gostEncrypt(key, (take`{64} pt))# zero\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Threefish.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module implementing the Threefish block cipher (256\/512\/1024-bit variants) with enc\/dec functions, key schedule, MIX\/mixing operations, and properties that show MIX\/MIX' and \u03c0\/\u03c0' are inverses and that provided known-answer test vectors for enc256\/enc512\/enc1024 hold."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Threefish where\n\nToInt : {n} (fin n) => [n][8] -> [8 * n]\nToInt bytes = join (reverse bytes)\n\nToBytes : {n} (fin n) => [8 * n] -> [n][8]\nToBytes bits = reverse (split`{each = 8} bits)\n\nBytesToWords : {n} (fin n) => [8 * n][8] -> [n][64]\nBytesToWords bytes = [ ToInt bs | bs <- split`{each = 8} bytes ]\n\nWordsToBytes : {n} (fin n) => [n][64] -> [8 * n][8]\nWordsToBytes words = join [ ToBytes w | w <- words ]\n\nenc256 : [32][8] -> [16][8] -> [32][8] -> [32][8]\nenc256 = encrypt`{Nr=72} R4 pi4\n\nenc512 : [64][8] -> [16][8] -> [64][8] -> [64][8]\nenc512 = encrypt`{Nr=72} R8 pi8\n\nenc1024 : [128][8] -> [16][8] -> [128][8] -> [128][8]\nenc1024 = encrypt`{Nr=80} R16 pi16\n\nencrypt :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 4 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot ->\n  ([Nw][64] -> [Nw][64]) ->\n  [8 * Nw][8] -> [16][8] -> [8 * Nw][8] -> [8 * Nw][8]\nencrypt R pi key tweak plaintext = WordsToBytes (encrypt'`{Nr=Nr} R pi K T P)\n  where\n    K = BytesToWords key\n    T = BytesToWords tweak\n    P = BytesToWords plaintext\n\n\/\/ Encryption in terms of 64-bit words.\nencrypt' :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 4 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot -> ([Nw][64] -> [Nw][64]) ->\n  [Nw][64] -> [2][64] -> [Nw][64] -> [Nw][64]\nencrypt' R pi key tweak plaintext = last v + last ks\n  where\n    ks : [Nr\/4 + 1][Nw][64]\n    ks = KeySchedule key tweak\n\n    \/\/ Add a subkey from the key schedule once every four rounds.\n    e : [Nr][Nw][64]\n    e = [ vd + kd\n        | vd <- v\n        | subkey <- take`{Nr\/4} ks, kd <- [subkey, zero, zero, zero] ]\n\n    \/\/ Cycle over the eight lists of rotation amounts for the mixing function.\n    f : [Nr][Nw][64]\n    f = [ mixing Rd ed | Rd <- join (repeat`{inf} R) | ed <- e ]\n\n    \/\/ Permute the words every round.\n    v : [Nr+1][Nw][64]\n    v = [plaintext] # [ pi fd | fd <- f ]\n\n\/\/ One round of mixing.\nmixing : {w} (fin w) => [w]Rot -> [2 * w][64] -> [2 * w][64]\nmixing Rd e = join [ MIX R x | R <- Rd | x <- split`{each=2} e ]\n\n\/\/ Table 3: Values for the word permutation \u03c0(i).\n\npi4 : [4][64] -> [4][64]\npi4 xs = xs @@ [0, 3, 2, 1:[2]]\n\npi8 : [8][64] -> [8][64]\npi8 xs = xs @@ [2, 1, 4, 7, 6, 5, 0, 3:[3]]\n\npi16 : [16][64] -> [16][64]\npi16 xs = xs @@ [0, 9, 2, 13, 6, 11, 4, 15, 10, 7, 12, 3, 14, 5, 8, 1:[4]]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.1: MIX Functions\n\n\/\/ Rotation amount for a 64-bit word\ntype Rot = [6]\n\nMIX : Rot -> [2][64] -> [2][64]\nMIX R [x0, x1] = [y0, y1]\n  where\n    y0 = x0 + x1\n    y1 = (x1 <<< R) ^ y0\n\n\/\/ Table 4: Rotation constants\n\nR4 : [8][2]Rot\nR4 =\n  [[14, 16],\n   [52, 57],\n   [23, 40],\n   [ 5, 37],\n   [25, 33],\n   [46, 12],\n   [58, 22],\n   [32, 32]]\n\nR8 : [8][4]Rot\nR8 =\n  [[46, 36, 19, 37],\n   [33, 27, 14, 42],\n   [17, 49, 36, 39],\n   [44,  9, 54, 56],\n   [39, 30, 34, 24],\n   [13, 50, 10, 17],\n   [25, 29, 39, 43],\n   [ 8, 35, 56, 22]]\n\nR16 : [8][8]Rot\nR16 =\n  [[24, 13,  8, 47,  8, 17, 22, 37],\n   [38, 19, 10, 55, 49, 18, 23, 52],\n   [33,  4, 51, 13, 34, 41, 59, 17],\n   [ 5, 20, 48, 41, 47, 28, 16, 25],\n   [41,  9, 37, 31, 12, 47, 44, 30],\n   [16, 34, 56, 51,  4, 53, 42, 41],\n   [31, 44, 47, 46, 19, 42, 44, 25],\n   [ 9, 48, 35, 52, 23, 31, 37, 20]]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.2: The Key Schedule\n\n\/\/ \"The key schedule turns the key and tweak into a sequence of Nr\/4+1\n\/\/ subkeys, each of which consists of Nw words.\"\n\nKeySchedule :\n  {Nw, r} (fin Nw, fin r, Nw >= 3) =>\n  [Nw][64] -> [2][64] -> [r][Nw][64]\nKeySchedule k [t0,t1] = take`{r} [ subkey s | s <- [0...] ]\n  where\n    k' = k # [foldl (^) C240 k]\n    t' = [t0, t1, t0 ^ t1]\n\n    subkey : [64] -> [Nw][64]\n    subkey s = take`{Nw} (k' <<< s) + tweak s\n\n    tweak : [64] -> [Nw][64]\n    tweak s = zero # take`{2} (t' <<< s) # [s]\n\nC240 : [64]\nC240 = 0x1BD11BDAA9FC1A22\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.3: Decryption\n\n\/\/ \"The Threefish decryption operation is the obvious inverse of the\n\/\/ encryption operation. Subkeys are used in reverse order and each\n\/\/ round consists of applying the inverse word permutation followed by\n\/\/ the inverse MIX functions.\"\n\ndec256 : [32][8] -> [16][8] -> [32][8] -> [32][8]\ndec256 = decrypt`{Nr=72} R4 pi4'\n\ndec512 : [64][8] -> [16][8] -> [64][8] -> [64][8]\ndec512 = decrypt`{Nr=72} R8 pi8'\n\ndec1024 : [128][8] -> [16][8] -> [128][8] -> [128][8]\ndec1024 = decrypt`{Nr=80} R16 pi16'\n\ndecrypt :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 8 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot ->\n  ([Nw][64] -> [Nw][64]) ->\n  [8 * Nw][8] -> [16][8] -> [8 * Nw][8] -> [8 * Nw][8]\ndecrypt R pi key tweak ciphertext = WordsToBytes (decrypt'`{Nr=Nr} R pi K T P)\n  where\n    K = BytesToWords key\n    T = BytesToWords tweak\n    P = BytesToWords ciphertext\n\n\/\/ Decryption in terms of 64-bit words.\ndecrypt' :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 8 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot -> ([Nw][64] -> [Nw][64]) ->\n  [Nw][64] -> [2][64] -> [Nw][64] -> [Nw][64]\ndecrypt' R pi key tweak ciphertext = last e - last ks\n  where\n    ks : [Nr\/4 + 1][Nw][64]\n    ks = reverse (KeySchedule key tweak)\n\n    \/\/ Add a subkey from the key schedule once every four rounds.\n    v : [Nr][Nw][64]\n    v = [ ed - kd\n        | ed <- e\n        | subkey <- take`{Nr\/4} ks, kd <- [subkey, zero, zero, zero] ]\n\n    \/\/ Cycle over the eight lists of rotation amounts for the mixing function.\n    e : [Nr+1][Nw][64]\n    e = [ciphertext] # [ mixing' Rd fd | Rd <- reverse (join (repeat`{Nr\/8} R)) | fd <- f ]\n\n        f : [Nr][Nw][64]\n    f = [ pi vd | vd <- v ]\n\nMIX' : Rot -> [2][64] -> [2][64]\nMIX' R [y0, y1] = [x0, x1]\n  where\n    x0 = y0 - x1\n    x1 = (y0 ^ y1) >>> R\n\nmixing' : {w} (fin w) => [w]Rot -> [2 * w][64] -> [2 * w][64]\nmixing' Rd e = join [ MIX' R x | R <- Rd | x <- split`{each=2} e ]\n\n\/\/ Inverse permutations.\n\npi4' : [4][64] -> [4][64]\npi4' xs = xs @@ [0, 3, 2, 1:[2]]\n\npi8' : [8][64] -> [8][64]\npi8' xs = xs @@ [6, 1, 0, 7, 2, 5, 4, 3:[3]]\n\npi16' : [16][64] -> [16][64]\npi16' xs = xs @@ [0, 15, 2, 11, 6, 13, 4, 9, 14, 1, 8, 5, 10, 3, 12, 7:[4]]\n\nproperty MIX_inv R x = MIX' R (MIX R x) == x\nproperty pi4_inv xs = pi4' (pi4 xs) == xs\nproperty pi8_inv xs = pi8' (pi8 xs) == xs\nproperty pi16_inv xs = pi16' (pi16 xs) == xs\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Test Vectors\n\n\/\/ https:\/\/sites.google.com\/site\/bartoszmalkowski\/threefish\n\nproperty test256a =\n  enc256 zero zero zero ==\n  split 0x84da2a1f8beaee947066ae3e3103f1ad536db1f4a1192495116b9f3ce6133fd8\n\nproperty test256b =\n  enc256\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xFFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0)\n  ==\n  split 0xe0d091ff0eea8fdfc98192e62ed80ad59d865d08588df476657056b5955e97df\n\nproperty test512a =\n  enc512 zero zero zero ==\n  split 0xb1a2bbc6ef6025bc40eb3822161f36e375d1bb0aee3186fbd19e47c5d479947b #\n  split 0x7bc2f8586e35f0cff7e7f03084b0b7b1f1ab3961a580a3e97eb41ea14a6d7bbe\n\nproperty test512b =\n  enc512\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f #\n     split 0x303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xfffefdfcfbfaf9f8f7f6f5f4f3f2f1f0efeeedecebeae9e8e7e6e5e4e3e2e1e0 #\n     split 0xdfdedddcdbdad9d8d7d6d5d4d3d2d1d0cfcecdcccbcac9c8c7c6c5c4c3c2c1c0)\n  ==\n  split 0xe304439626d45a2cb401cad8d636249a6338330eb06d45dd8b36b90e97254779 #\n  split 0x272a0a8d99463504784420ea18c9a725af11dffea10162348927673d5c1caf3d\n\nproperty test1024a =\n  enc1024 zero zero zero ==\n  split 0xf05c3d0a3d05b304f785ddc7d1e036015c8aa76e2f217b06c6e1544c0bc1a90d #\n  split 0xf0accb9473c24e0fd54fea68057f43329cb454761d6df5cf7b2e9b3614fbd5a2 #\n  split 0x0b2e4760b40603540d82eabc5482c171c832afbe68406bc39500367a592943fa #\n  split 0x9a5b4a43286ca3c4cf46104b443143d560a4b230488311df4feef7e1dfe8391e\n\nproperty test1024b =\n  enc1024\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f #\n     split 0x303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f #\n     split 0x505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f #\n     split 0x707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xfffefdfcfbfaf9f8f7f6f5f4f3f2f1f0efeeedecebeae9e8e7e6e5e4e3e2e1e0 #\n     split 0xdfdedddcdbdad9d8d7d6d5d4d3d2d1d0cfcecdcccbcac9c8c7c6c5c4c3c2c1c0 #\n     split 0xbfbebdbcbbbab9b8b7b6b5b4b3b2b1b0afaeadacabaaa9a8a7a6a5a4a3a2a1a0 #\n     split 0x9f9e9d9c9b9a999897969594939291908f8e8d8c8b8a89888786858483828180)\n  ==\n  split 0xa6654ddbd73cc3b05dd777105aa849bce49372eaaffc5568d254771bab85531c #\n  split 0x94f780e7ffaae430d5d8af8c70eebbe1760f3b42b737a89cb363490d670314bd #\n  split 0x8aa41ee63c2e1f45fbd477922f8360b388d6125ea6c7af0ad7056d01796e90c8 #\n  split 0x3313f4150a5716b30ed5f569288ae974ce2b4347926fce57de44512177dd7cde\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/SHACAL.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module implementing the SHACAL-1 and SHACAL-2 block ciphers using SHA-1\/SHA-256 style compression (including shacal1Encrypt*, shacal2Encrypt* and helper functions), and include properties shacal1TestsPass and shacal2TestsPass that check the provided test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::SHACAL where\n\nimport Primitive::Keyless::Hash::SHA2Internal::SHA256\n\ntype shacal1Block = 160\ntype shacal1Key = 512\n\nshacal1Encrypt : ([shacal1Key], [shacal1Block]) -> [shacal1Block]\nshacal1Encrypt (key, pt) = join (block (pt', key'))\n              where pt' = split pt : [5][32]\n                    key' = split key : [16][32]\n\nshacal1Encrypt160 : ([shacal1Block], [shacal1Block]) -> [shacal1Block]\nshacal1Encrypt160 (key, pt) = shacal1Encrypt(key#zero, pt)\n\nshacal1Encrypt512 : ([shacal1Key], [shacal1Key]) -> [shacal1Key]\nshacal1Encrypt512 (key, pt) = shacal1Encrypt(key, (take`{160} pt))#zero\n\nproperty shacal1TestsPass = and [shacal1Encrypt(key, plain) == cipher | (key, plain, cipher) <- tVector1]\n\ntVector1 = [ (0x8#zero, zero, 0x0FFD8D43B4E33C7C53461BD10F27A5461050D90D)\n           , (0x4#zero, zero, 0xB9C60AA972B49CA04D5A0D9B9E08B2A2BA138C93)\n           , (0x2#zero, zero, 0x3FA618501A3D10E3CAEB3CA06B8B47A16F8E3D9E)\n           , (0x1#zero, zero, 0x2B4AFB3268C32F86B89BB745EC85F24702B38498)\n           , (0x08#zero, zero, 0x58E782A1D205E53DD2901F0F302F8894D0A3B05B)\n           , (0x04#zero, zero, 0xB345AD4DC877D0BFCF760EE25056D21C7DB2F868)\n           , (0x02#zero, zero, 0x334C5A595919EA33E5EB467657AAE3ED825207D3)\n           , (0x01#zero, zero, 0x5F686F27819DF939F877099A222D01EE955F6E66)\n           , (0x008#zero, zero, 0x62BE68D266A28F7E6B44A83E62A476FFD627AF0E)\n           , (0x004#zero, zero, 0x2D5265CD2E72B52B6477F341816F2BB554428BC5)]\n\ntype shacal2Block = 256\ntype shacal2Key = 512\n\nshacal2Encrypt : ([shacal2Key], [shacal2Block]) -> [shacal2Block]\nshacal2Encrypt (key, pt) = join (processBlock_Common pt' key')\n              where pt' = split pt : [8][32]\n                    key' = split key : [16][32]\n\nshacal2Encrypt256 : ([shacal2Block], [shacal2Block]) -> [shacal2Block]\nshacal2Encrypt256 (key, pt) = shacal2Encrypt(key#zero, pt)\n\nshacal2Encrypt512 : ([shacal2Key], [shacal2Key]) -> [shacal2Key]\nshacal2Encrypt512 (key, pt) = shacal2Encrypt(key, (take`{256} pt))#zero\n\nproperty shacal2TestsPass = and [shacal2Encrypt(key, plain) == cipher | (key, plain, cipher) <- tVector2]\n\ntVector2 = [ (0x8#zero, zero, 0x361AB6322FA9E7A7BB23818D839E01BDDAFDF47305426EDD297AEDB9F6202BAE)\n           , (0x4#zero, zero, 0xF3BAF53E5301E08813F8BE6F651BB19E9722151FF15063BA42A6FEF7CF3BF3D7)\n           , (0x1#zero, zero, 0xAE70E355CB7E26FF12421F46CDAD5CB98367FE0E86CC234EDF97481765CD1AD9)\n           , (0x08#zero, zero, 0x00CECD0B01311F881018E7A20BCE169766C089D91FF161346C4E1BD122EA199F)\n           , (0x08#zero, zero, 0x00CECD0B01311F881018E7A20BCE169766C089D91FF161346C4E1BD122EA199F)\n           , (0x04#zero, zero, 0x47A879CB6785AD37119C450CD50E9A36FE318FA8E7B6C6E0FA963430122F33CD)\n           , (0x02#zero, zero, 0xCF3D53B9F9F7CA2C66738A4C09CEA9212C056F525BDC26F263FBA1B482EDF503)\n           , (0x01#zero, zero, 0xA274D404E83E82817389A2CB7B528C792A0E80DE879A5A67DE633B0B7DD57B7B)\n           , (0x008#zero, zero, 0x09B3AB9332301D4E3C239D192A4221AFD43F6829A705D396FA96BDE1E716BC38)\n           , (0x004#zero, zero, 0xD3B9AB867A6868C4400D200979055C8F9E3A6BFB40D1F9E376B9EC89223D7050)]\n\nf : ([8], [32], [32], [32]) -> [32]\nf (t, x, y, z) =\n       if (0 <= t)  \/\\ (t <= 19) then (x && y) ^ (~x && z)\n        | (20 <= t) \/\\ (t <= 39) then x ^ y ^ z\n        | (40 <= t) \/\\ (t <= 59) then (x && y) ^ (x && z) ^ (y && z)\n        | (60 <= t) \/\\ (t <= 79) then x ^ y ^ z\n        else error \"f: t out of range\"\n\nKs : [80][32]\nKs = [ 0x5a827999 | t <- [0..19]  ]\n   # [ 0x6ed9eba1 | t <- [20..39] ]\n   # [ 0x8f1bbcdc | t <- [40..59] ]\n   # [ 0xca62c1d6 | t <- [60..79] ]\n\nblock : ([5][32], [16][32]) -> [5][32]\nblock ([H0, H1, H2, H3, H4], M) =\n [(H0+As@80), (H1+Bs@80), (H2+Cs@80), (H3+Ds@80), (H4+Es@80)]\n  where\n    Ws : [80][32]\n    Ws = M # [ (W3 ^ W8 ^ W14 ^ W16) <<< 1\n             | W16 <- drop`{16 - 16} Ws\n             | W14 <- drop`{16 - 14} Ws\n             | W8  <- drop`{16 - 8}  Ws\n             | W3  <- drop`{16 - 3}  Ws\n             | t <- [16..79]\n             ]\n    As = [H0] # TEMP\n    Bs = [H1] # As\n    Cs = [H2] # [ B <<< 30 | B <- Bs ]\n    Ds = [H3] # Cs\n    Es = [H4] # Ds\n    TEMP : [80][32]\n    TEMP = [ (A <<< 5) + f(t, B, C, D) + E + W + K\n           | A <- As | B <- Bs | C <- Cs | D <- Ds | E <- Es\n           | W <- Ws | K <- Ks\n           | t <- [0..79]\n           ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/CipherInterface.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol interface module `Primitive::Symmetric::Cipher::Block::CipherInterface` with abstract `KeySize` and `BlockSize` types, an appropriate finiteness constraint, and `encrypt`\/`decrypt` functions on blocks, suitable as a generic block cipher interface."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Symmetric::Cipher::Block::CipherInterface where\n  type KeySize : #\n  type BlockSize : #\n  type constraint (fin BlockSize, fin KeySize)\n  encrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  decrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/KATAN.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing the KATAN and KTANTAN lightweight block ciphers (including 64-bit variants), their key schedules, encrypt\/decrypt functions, and properties katanCorrect, katantanCorrect, and testsPass that verify encryption\/decryption correctness and given known-answer tests."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::KATAN where\n\ntype Katan32 = 32\ntype Katan48 = 48\ntype Katan64 = 64\ntype KatanBlock = Katan64\ntype KatanKeySize = 80\ntype Round = 8\ntype xSize = 5\ntype ySize = 6\n\ntype Nr = 254\n\ntype L1Size = 25\ntype L2Size = 39\n\nx = [24, 15, 20, 11, 9]\ny = [38, 25, 33, 21, 14, 9]\n\nsplitBlock: [KatanBlock] -> ([L1Size], [L2Size])\n\nsplitBlock pt = (l1, l2)\n            where l1 = take`{L1Size} pt\n                  l2 = drop`{L1Size} pt\n\niR: [1][Nr]\n\niR = [0b11111110001101010101111011001100101001000100011000111100001000010100000111110011111101010001010100110000110011101111101110100101011010011100110110001011101101111001011011010111001001001101000111000100111101000011101011000001011001000000110111000000010010]\n\nkS: {a} (fin a) => ([a], [12]) -> [a+1]\nkS (key, i ) = key # [((key@(i-80))^ (key@(i-61)) ^ (key@(i-50)) ^ (key@(i-13)))]\n\nkS10 : {a} (fin a) => ([a], [12]) -> [a + 10]\nkS10 (key, i) = key9\n           where key0 = kS (key, i)\n                 key1 = kS (key0, i+1)\n                 key2 = kS (key1, i+2)\n                 key3 = kS (key2, i+3)\n                 key4 = kS (key3, i+4)\n                 key5 = kS (key4, i+5)\n                 key6 = kS (key5, i+6)\n                 key7 = kS (key6, i+7)\n                 key8 = kS (key7, i+8)\n                 key9 = kS (key8, i+9)\n\nkS100 : {a} (fin a) => ([a], [12]) -> [a + 100]\nkS100 (key, i) = key9\n            where key0 = kS10 (key, i)\n                  key1 = kS10 (key0, i+10)\n                  key2 = kS10 (key1, i+20)\n                  key3 = kS10 (key2, i+30)\n                  key4 = kS10 (key3, i+40)\n                  key5 = kS10 (key4, i+50)\n                  key6 = kS10 (key5, i+60)\n                  key7 = kS10 (key6, i+70)\n                  key8 = kS10 (key7, i+80)\n                  key9 = kS10 (key8, i+90)\n\nkeySchedule' :[80] -> [508]\nkeySchedule' key = key13\n            where key0 = kS100 (key, 80)\n                  key1= kS100 (key0, 180)\n                  key2 = kS100 (key1, 280)\n                  key3 = kS100 (key2, 380)\n                  key4 = kS10(key3, 480)\n                  key5 = kS10 (key4, 490)\n                  key6 = kS (key5, 500)\n                  key7 = kS (key6, 501)\n                  key8 = kS (key7, 502)\n                  key9 = kS (key8, 503)\n                  key10 = kS (key9, 504)\n                  key11 = kS (key10, 505)\n                  key12 = kS (key11, 506)\n                  key13 = kS (key12, 507)\n\nfunFa : [L1Size]-> [xSize][xSize] -> [508] -> [Round] -> Bit\n\nfunFa L1 x k i = (L1!(x@0)) ^ (L1!(x@1)) ^ ((L1!(x@2)) && (L1!(x@3))) ^ ((L1!(x@4)) && ((iR@0)@i)) ^ (k@(pmult (2:[2]) i))\n\nfunFb : [L2Size]-> [ySize][ySize] -> [508] -> [Round] -> Bit\n\nfunFb L2 y k i = (L2!(y@0)) ^ (L2!(y@1)) ^ (L2!(y@2) && L2!(y@3)) ^ (L2!(y@4) && L2!(y@5)) ^ (k@((pmult (2:[2]) i)+1))\n\naply_fb : [L1Size] -> [L2Size]->  [ySize][ySize] ->[KatanKeySize] -> [Round] -> [L1Size]\naply_fb l1 l2 y key i = (l1 !! [(L1Size-2),(L1Size-3)..0]) # [(funFb l2 y (keySchedule' key) i)]\n\naply_fa : [L1Size] -> [L2Size]-> [xSize][xSize]->[KatanKeySize] -> [Round] -> [L2Size]\naply_fa l1 l2 x key i = (l2 !! [(L2Size-2),(L2Size-3)..0]) # [(funFa l1 x (keySchedule' key) i)]\n\nupdateLfsr : [L1Size] -> [L2Size]-> [xSize][xSize] -> [ySize][ySize]->[KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\nupdateLfsr l1 l2 x y key i = if `(L1Size) == 13\n                             then (l1', l2')\n                             else if `(L1Size) == 19\n                                  then (l1'', l2'')\n                                  else (l1''', l2''')\n\n                 where pt = (aply_fb l1 l2 y key i) # (aply_fa l1 l2 x key i)\n                       l1' = (splitBlock pt).0\n                       l2' = (splitBlock pt).1\n                       pt' = (aply_fb l1' l2' y key i) # (aply_fa l1' l2' x key i)\n                       l1'' = (splitBlock pt').0\n                       l2'' =  (splitBlock pt').1\n                       pt'' = (aply_fb l1'' l2'' y key i) # (aply_fa l1'' l2'' x key i)\n                       l1''' = (splitBlock pt'').0\n                       l2''' =  (splitBlock pt'').1\n\n\/\/Encryption\n\nkatanEncrypt : ( [KatanKeySize], [KatanBlock]) -> _ \/\/ [KatanBlock]\n\nkatanEncrypt (key, pt) =  (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] # [ ( (updateLfsr pT.0 pT.1 x y key i).0, (updateLfsr pT.0 pT.1 x y key i).1)  | i<- [0,1..253] | pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\n\/\/ wrapper to do experiments\n\nkatanEncrypt64 : ([KatanBlock], [KatanBlock]) -> [KatanBlock]\nkatanEncrypt64 (key, pt) = katanEncrypt(key#zero, pt)\n\nkatanEncrypt80 : ([KatanKeySize], [KatanKeySize]) -> [KatanKeySize]\nkatanEncrypt80 (key, pt) = katanEncrypt(key, (take`{64} pt)) # zero\n\n\/\/Auxiliary functions for decryption\n\n\/\/ fa and fb\n\ndecFunFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ndecFunFa L1 L2 x k i = fa ^ (L1!((x@1)+1)) ^ (L1!((x@2)+1) && L1!((x@3)+1)) ^ (L1!((x@4)+1) && ((iR@0)@i)) ^ k@(2*i)\n         where fa = L2!0\n\ndecFunFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [508] -> [Round] -> Bit\ndecFunFb L2 L1 y k i =  fb ^ (L2!((y@1)+1)) ^ ((L2!((y@2)+1)) && L2!((y@3)+1)) ^ ((L2!((y@4)+1)) && L2!((y@5)+1)) ^ k@(2*i+1)\n         where fb = L1!0\n\n\/\/Left shifting L1, L2 and appending fa, fb values\n\naply_decFa_once : [L1Size] -> [L2Size] -> [xSize][xSize] -> [KatanKeySize] -> [Round] -> [L1Size]\n\naply_decFa_once  l1 l2 x k i = [(decFunFa l1 l2 x (keySchedule' k) i)] # (l1!![(L1Size-1),(L1Size-2)..1])\n\naply_decFb_once : [L2Size] -> [L1Size] -> [ySize][ySize] -> [KatanKeySize] -> [Round] -> [L2Size]\naply_decFb_once  l2 l1 y k i =  [(decFunFb l2 l1 y (keySchedule' k) i)] # (l2!![(L2Size-1),(L2Size-2)..1])\n\n\/\/ Updating LFSR for decryption\n\ndecUpdateLfsr: [L1Size] -> [L2Size] -> [xSize][xSize]-> [ySize][ySize] -> [KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\ndecUpdateLfsr  l1 l2 x y key i = if `(L1Size) == 13\n                                 then (l1', l2')\n                                 else if `(L1Size) == 19\n                                      then (l1'', l2'')\n                                      else (l1''', l2''')\n                               where ct = (aply_decFa_once l1 l2 x key i) # (aply_decFb_once l2 l1 y key i)\n                                     l1' = (splitBlock ct).0\n                                     l2' = (splitBlock ct).1\n                                     ct' = (aply_decFa_once l1' l2' x key i) # (aply_decFb_once l2' l1' y key i)\n                                     l1'' = (splitBlock ct').0\n                                     l2'' = (splitBlock ct').1\n                                     ct'' = (aply_decFa_once l1'' l2'' x key i) # (aply_decFb_once l2'' l1'' y key i)\n                                     l1''' = (splitBlock ct'').0\n                                     l2''' = (splitBlock ct'').1\n\nkatanDecrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\nkatanDecrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] #[ ((decUpdateLfsr pT.0 pT.1 x y key i).0 , (decUpdateLfsr pT.0 pT.1 x y key i).1)  | i <-[253,252..0] |pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\nproperty katanCorrect key m = katanEncrypt( key, katanDecrypt(key, m)) == m\n\nk_a_index = [0x3f, 0x1f, 0x1f, 0x0f, 0x0e, 0x3c, 0x28, 0x31, 0x23, 0x36, 0x2d,\n             0x3a, 0x25, 0x4a, 0x45, 0x4a, 0x35, 0x2b, 0x47, 0x3f, 0x1e, 0x2d,\n             0x0b, 0x36, 0x1c, 0x29, 0x03, 0x26, 0x3c, 0x19, 0x22, 0x05, 0x1a,\n             0x14, 0x09, 0x02, 0x14, 0x18, 0x01, 0x02, 0x34, 0x18, 0x11, 0x03,\n             0x06, 0x4c, 0x48, 0x31, 0x13, 0x17, 0x0f, 0x0e, 0x0c, 0x18, 0x10,\n             0x01, 0x02, 0x04, 0x28, 0x30, 0x11, 0x12, 0x05, 0x0a, 0x04, 0x08,\n             0x40, 0x40, 0x41, 0x33, 0x17, 0x2f, 0x0f, 0x4e, 0x4c, 0x49, 0x43,\n             0x37, 0x2f, 0x3f, 0x2f, 0x3e, 0x1d, 0x1a, 0x05, 0x0a, 0x24, 0x38,\n             0x21, 0x32, 0x15, 0x2a, 0x05, 0x3a, 0x14, 0x19, 0x03, 0x06, 0x0c,\n             0x38, 0x10, 0x21, 0x03, 0x46, 0x3c, 0x29, 0x43, 0x47, 0x4e, 0x4d,\n             0x3b, 0x27, 0x4f, 0x4f, 0x3e, 0x2d, 0x3b, 0x17, 0x2e, 0x0d, 0x2a,\n             0x34, 0x29, 0x42, 0x35, 0x2a, 0x35, 0x1b, 0x26, 0x0d, 0x4a, 0x34,\n             0x19, 0x23, 0x07, 0x3e, 0x2c, 0x49, 0x33, 0x16, 0x1d, 0x0b, 0x06,\n             0x2c, 0x48, 0x41, 0x32, 0x25, 0x4b, 0x37, 0x2e, 0x4d, 0x4b, 0x46,\n             0x3d, 0x1b, 0x27, 0x0f, 0x2e, 0x4c, 0x39, 0x22, 0x45, 0x3b, 0x26,\n             0x3d, 0x2b, 0x46, 0x4d, 0x3a, 0x15, 0x2b, 0x07, 0x1e, 0x2c, 0x09,\n             0x12, 0x24, 0x09, 0x32, 0x24, 0x39, 0x13, 0x16, 0x0d, 0x0a, 0x44,\n             0x38, 0x11, 0x13, 0x07, 0x0e, 0x1c, 0x28, 0x01, 0x42, 0x44, 0x39,\n             0x23, 0x37, 0x1f, 0x1e, 0x0d, 0x0a, 0x04, 0x48, 0x30, 0x21, 0x33,\n             0x27, 0x4e, 0x3d, 0x1a, 0x15, 0x0b, 0x06, 0x0c, 0x08, 0x20, 0x40,\n             0x31, 0x12, 0x25, 0x0b, 0x16, 0x1c, 0x09, 0x02, 0x04, 0x08, 0x00,\n             0x30, 0x20, 0x41, 0x43, 0x36, 0x1d, 0x1b, 0x07, 0x0e, 0x0c, 0x08,\n             0x00, 0x00, 0x10, 0x20, 0x01, 0x22, 0x44, 0x49, 0x42, 0x45, 0x4b,\n             0x47]\n\nk_b_index = [0x1f, 0x3f, 0x3f, 0x2f, 0x0e, 0x4c, 0x28, 0x11, 0x43, 0x16, 0x4d,\n             0x1a, 0x45, 0x0a, 0x45, 0x0a, 0x15, 0x2b, 0x07, 0x4f, 0x3e, 0x2d,\n             0x0b, 0x46, 0x3c, 0x29, 0x13, 0x46, 0x1c, 0x49, 0x22, 0x15, 0x4a,\n             0x34, 0x29, 0x12, 0x44, 0x38, 0x21, 0x02, 0x44, 0x38, 0x31, 0x23,\n             0x06, 0x4c, 0x08, 0x11, 0x33, 0x37, 0x3f, 0x2e, 0x1c, 0x48, 0x30,\n             0x31, 0x22, 0x14, 0x48, 0x10, 0x41, 0x32, 0x35, 0x3a, 0x24, 0x08,\n             0x40, 0x00, 0x01, 0x13, 0x37, 0x2f, 0x0f, 0x4e, 0x0c, 0x09, 0x03,\n             0x17, 0x2f, 0x1f, 0x4f, 0x1e, 0x4d, 0x3a, 0x25, 0x1a, 0x44, 0x18,\n             0x41, 0x12, 0x45, 0x2a, 0x05, 0x4a, 0x34, 0x39, 0x33, 0x26, 0x0c,\n             0x48, 0x30, 0x21, 0x03, 0x46, 0x1c, 0x29, 0x03, 0x47, 0x0e, 0x0d,\n             0x1b, 0x27, 0x0f, 0x4f, 0x1e, 0x2d, 0x1b, 0x47, 0x2e, 0x1d, 0x4a,\n             0x14, 0x49, 0x02, 0x45, 0x2a, 0x15, 0x4b, 0x26, 0x0d, 0x4a, 0x14,\n             0x39, 0x23, 0x07, 0x4e, 0x2c, 0x09, 0x43, 0x36, 0x3d, 0x2b, 0x16,\n             0x4c, 0x08, 0x41, 0x12, 0x25, 0x0b, 0x47, 0x2e, 0x0d, 0x4b, 0x06,\n             0x1d, 0x3b, 0x27, 0x1f, 0x4e, 0x0c, 0x49, 0x22, 0x05, 0x4b, 0x26,\n             0x1d, 0x4b, 0x06, 0x4d, 0x1a, 0x35, 0x2b, 0x17, 0x4e, 0x2c, 0x19,\n             0x42, 0x24, 0x09, 0x42, 0x24, 0x19, 0x43, 0x36, 0x2d, 0x0a, 0x44,\n             0x18, 0x31, 0x33, 0x27, 0x1e, 0x4c, 0x28, 0x01, 0x42, 0x04, 0x19,\n             0x23, 0x17, 0x4f, 0x3e, 0x3d, 0x2a, 0x04, 0x48, 0x10, 0x21, 0x13,\n             0x47, 0x0e, 0x4d, 0x3a, 0x35, 0x3b, 0x36, 0x2c, 0x18, 0x40, 0x00,\n             0x41, 0x32, 0x25, 0x1b, 0x46, 0x3c, 0x39, 0x32, 0x34, 0x28, 0x00,\n             0x40, 0x20, 0x01, 0x43, 0x16, 0x3d, 0x3b, 0x37, 0x3e, 0x3c, 0x38,\n             0x20, 0x10, 0x40, 0x20, 0x11, 0x42, 0x04, 0x49, 0x02, 0x05, 0x0b,\n             0x07]\n\ntanFa : [L1Size]-> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ntanFa L1 x k i = (L1!(x@0)) ^ (L1!(x@1)) ^ ((L1!(x@2)) && (L1!(x@3))) ^ ((L1!(x@4)) && ((iR@0)@i)) ^ (k@(k_a_index @i))\n\ntanFb : [L2Size]-> [ySize][ySize] -> [508] -> [Round] -> Bit\n\ntanFb L2 y k i = (L2!(y@0)) ^ (L2!(y@1)) ^ (L2!(y@2) && L2!(y@3)) ^ (L2!(y@4) && L2!(y@5)) ^ (k@(k_b_index @i))\n\ntanAplyFb : [L1Size] -> [L2Size]->  [ySize][ySize] ->[KatanKeySize] -> [Round] -> [L1Size]\ntanAplyFb l1 l2 y key i = (l1 !! [(L1Size-2),(L1Size-3)..0]) # [(tanFb l2 y (keySchedule' key) i)]\n\ntanAplyFa : [L1Size] -> [L2Size]-> [xSize][xSize]->[KatanKeySize] -> [Round] -> [L2Size]\ntanAplyFa l1 l2 x key i = (l2 !! [(L2Size-2),(L2Size-3)..0]) # [(tanFa l1 x (keySchedule' key) i)]\n\nupdateLfsrTan : [L1Size] -> [L2Size]-> [xSize][xSize] -> [ySize][ySize]->[KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\nupdateLfsrTan l1 l2 x y key i = if `(L1Size) == 13\n                             then (l1', l2')\n                             else if `(L1Size) == 19\n                                  then (l1'', l2'')\n                                  else (l1''', l2''')\n\n                 where pt = (tanAplyFb l1 l2 y key i) # (tanAplyFa l1 l2 x key i)\n                       l1' = (splitBlock pt).0\n                       l2' = (splitBlock pt).1\n                       pt' = (tanAplyFb l1' l2' y key i) # (tanAplyFa l1' l2' x key i)\n                       l1'' = (splitBlock pt').0\n                       l2'' =  (splitBlock pt').1\n                       pt'' = (tanAplyFb l1'' l2'' y key i) # (tanAplyFa l1'' l2'' x key i)\n                       l1''' = (splitBlock pt'').0\n                       l2''' =  (splitBlock pt'').1\n\n\/\/Encryption\n\nkatantanEncrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\n\nkatantanEncrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] # [((updateLfsrTan pT.0 pT.1 x y key i).0, (updateLfsrTan pT.0 pT.1 x y key i).1) | i<- [0,1..253] | pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\/\/ Wrapper to do experiments\n\nkatantanEncrypt64 : ([KatanBlock], [KatanBlock]) -> [KatanBlock]\nkatantanEncrypt64  (key, pt) = katantanEncrypt( key#zero, pt)\n\nkatantanEncrypt80 : ([KatanKeySize], [KatanKeySize]) -> [KatanKeySize]\nkatantanEncrypt80  (key, pt) = katantanEncrypt( key, (take`{64} pt)) # zero\n\n\/\/KTANTAN-Decryption\n\ndecTanFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ndecTanFa L1 L2 x k i = fa ^ (L1!((x@1)+1)) ^ (L1!((x@2)+1) && L1!((x@3)+1)) ^ (L1!((x@4)+1) && ((iR@0)@i)) ^ k@(k_a_index@i)\n         where fa = L2!0\n\ndecTanFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [508] -> [Round] -> Bit\ndecTanFb L2 L1 y k i =  fb ^ (L2!((y@1)+1)) ^ ((L2!((y@2)+1)) && L2!((y@3)+1)) ^ ((L2!((y@4)+1)) && L2!((y@5)+1)) ^ k@(k_b_index@i)\n         where fb = L1!0\n\n\/\/Left shifting L1, L2 and appending fa, fb values\n\ntanAplydecFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [KatanKeySize] -> [Round] -> [L1Size]\n\ntanAplydecFa  l1 l2 x k i = [(decTanFa l1 l2 x (keySchedule' k) i)] # (l1!![(L1Size-1),(L1Size-2)..1])\n\ntanAplydecFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [KatanKeySize] -> [Round] -> [L2Size]\ntanAplydecFb  l2 l1 y k i =  [(decTanFb l2 l1 y (keySchedule' k) i)] # (l2!![(L2Size-1),(L2Size-2)..1])\n\n\/\/ Updating LFSR for decryption\n\ndecUpdateLfsrTan: [L1Size] -> [L2Size] -> [xSize][xSize]-> [ySize][ySize] -> [KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\ndecUpdateLfsrTan  l1 l2 x y key i = if `(L1Size) == 13\n                                 then (l1', l2')\n                                 else if `(L1Size) == 19\n                                      then (l1'', l2'')\n                                      else (l1''', l2''')\n                               where ct = (tanAplydecFa l1 l2 x key i) # (tanAplydecFb l2 l1 y key i)\n                                     l1' = (splitBlock ct).0\n                                     l2' = (splitBlock ct).1\n                                     ct' = (tanAplydecFa l1' l2' x key i) # (tanAplydecFb l2' l1' y key i)\n                                     l1'' = (splitBlock ct').0\n                                     l2'' = (splitBlock ct').1\n                                     ct'' = (tanAplydecFa l1'' l2'' x key i) # (tanAplydecFb l2'' l1'' y key i)\n                                     l1''' = (splitBlock ct'').0\n                                     l2''' = (splitBlock ct'').1\n\nkatantanDecrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\nkatantanDecrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] #[ ((decUpdateLfsrTan pT.0 pT.1 x y key i).0 , (decUpdateLfsrTan pT.0 pT.1 x y key i).1)  | i <-[253,252..0] |pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\nproperty katantanCorrect key m = katantanDecrypt(key, katantanEncrypt(key, m)) == m\n\ntests64 = [katan64_1, katan64_2, katantan64_1, katantan64_2]\nproperty testsPass = and tests64\n\nkatan64_1 = katanEncrypt( 0xffffffffffffffffffff, zero) == 0x21f2e99c0fab828a\nkatan64_2 = katanEncrypt(zero, 0xffffffffffffffff) == 0xc956100dbeb64ba8\n\nkatantan64_1 = katantanEncrypt(0xffffffffffffffffffff, zero) == 0xc02de05bfa194b16\nkatantan64_2 = katantanEncrypt(zero, 0xffffffffffffffff) == 0xc956100dbeb64ba8\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/TEA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing the TEA, XTEA, and Corrected Block TEA (XXTEA) block ciphers, including encryption\/decryption functions, test vectors, and properties teaCorrect, teaCorrect', xTeaCorrect, xTeaCorrect64, and bTeaCorrect that verify decryption inverts encryption and that testsPass holds."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::TEA where\n\ntype Nb = 2\ntype Nkb = 4\ntype Nr = 2\ntype TeaBlockSize = 64\ntype TeaKeySize = 128\ntype stdBlock = 32\ntype keyInd = 2\n\nsplitPT: [TeaBlockSize] -> [Nb][stdBlock]\nsplitPT pt = split(pt):[Nb][stdBlock]\n\nsplitKey: [TeaKeySize] -> [Nkb][stdBlock]\nsplitKey key = split(key):[Nkb][stdBlock]\n\ndlta : [stdBlock]\ndlta = 0x9e3779b9\n\nsum = 0xc6ef3720\n\nteaRoundFun : [stdBlock] -> [stdBlock] -> [stdBlock] -> [stdBlock] -> [stdBlock]\nteaRoundFun pt k1 k2 delta = (pt << 4 + k1) ^ (pt + delta) ^ ((pt>>5)+k2)\n\nteaEncCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nteaEncCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          k0 = (splitKey key)@0\n          k1 = (splitKey key)@1\n          k2 = (splitKey key)@2\n          k3 = (splitKey key)@3\n          fiestr1 = rpt# roundf1\n          roundf1 = lpt + (teaRoundFun rpt k0 k1 sum)\n          fiestr2 = roundf1 # roundf2\n          roundf2 = rpt + (teaRoundFun roundf1 k2 k3 sum)\n\nteaDecCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nteaDecCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          k0 = (splitKey key)@0\n          k1 = (splitKey key)@1\n          k2 = (splitKey key)@2\n          k3 = (splitKey key)@3\n          roundf2 = rpt - (teaRoundFun lpt k2 k3 sum)\n          roundf1 = lpt - (teaRoundFun roundf2 k0 k1 sum)\n          fiestr2 = roundf1 # roundf2\n\nteaEncrypt : ([TeaKeySize], [TeaBlockSize]) -> [TeaBlockSize]\nteaEncrypt (key, pt) = (hs!0)\n    where hs = [pt] # [ teaEncCycle(m, key, i*dlta) | i <- [1,2..32] | m <- hs ]\n\nteaDecrypt : ([TeaKeySize], [TeaBlockSize]) -> [TeaBlockSize]\nteaDecrypt (key, ct) = (hs!0)\n    where hs = [ct] # [ teaDecCycle(cT, key, sum-i*dlta) | i <- [0,1..31] | cT <- hs ]\n\nproperty teaCorrect key m = teaDecrypt(key, teaEncrypt (key, m)) == m\n\nteaEncrypt' : ([TeaBlockSize], [TeaBlockSize]) -> [TeaBlockSize]\nteaEncrypt' (key, pt) = (hs!0)\n    where hs = [pt] # [ teaEncCycle(m, key', i*dlta) | i <- [1,2..32] | m <- hs ]\n          key' = key # zero\n\nteaDecrypt' : ([TeaBlockSize], [TeaBlockSize]) -> [TeaBlockSize]\nteaDecrypt' (key, ct) = (hs!0)\n    where hs = [ct] # [ teaDecCycle(cT, key', sum-i*dlta) | i<- [0,1..31] | cT <- hs ]\n          key' = key #zero\n\nproperty teaCorrect' key m = teaDecrypt'(key, teaEncrypt'(key, m)) == m\n\n\/************************************************************************\/\n\/************************************************************************\/\n\/* eXtended TEA *\/\n\n\/\/Round function for XTEA\n\nxTeaRoundFun : [stdBlock] -> [TeaKeySize] -> [stdBlock] -> [stdBlock] -> [stdBlock]\nxTeaRoundFun pt key sum1 sum2 = (((pt << 4) ^ (pt >> 5)) + pt) ^ (sum1 + k)\n    where k = (splitKey key)@(sum2 !![1,0])\n\n\/\/ XTEA cycle contains two Feistel rounds\n\nxTeaEncCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nxTeaEncCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          roundf1 = lpt +(xTeaRoundFun rpt key sum sum)\n          fiestr2 = roundf1 # roundf2\n          roundf2 = rpt+(xTeaRoundFun roundf1 key (sum+dlta) ((sum+dlta)>>11))\n\n\/\/XTEA decryption cycle contains two Feistel rounds\n\nxTeaDecCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nxTeaDecCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          roundf2 = rpt - (xTeaRoundFun lpt key sum (sum>>11))\n          roundf1 = lpt - (xTeaRoundFun roundf2 key (sum-dlta) (sum-dlta))\n          fiestr2 = roundf1 # roundf2\n\n\/\/Encryption: 32 XTEA cycles are recommended\n\/\/I change the signatures to run the experiments\n\ntype PTSize = TeaBlockSize\ntype CTSize = TeaBlockSize\n\nxTeaEncrypt : ([TeaKeySize], [PTSize]) -> [CTSize]\nxTeaEncrypt (key, pt) = (hs!0)\n    where hs = [pt] # [ xTeaEncCycle (m, key, i*dlta) | i <- [0,1..31] | m <- hs ]\n\n\/\/Decryption\n\nxTeaDecrypt : ([TeaKeySize], [CTSize]) -> [PTSize]\nxTeaDecrypt (key, ct) = (hs!0)\n    where hs = [ct] # [ xTeaDecCycle (pT, key, i*dlta) | i <- [32,31..1] | pT <- hs ]\n\nproperty xTeaCorrect key m = xTeaDecrypt(key, xTeaEncrypt(key, m)) == m\n\n\/\/ Helper function to run experiments\n\nxTeaEncrypt64 : ([PTSize], [PTSize]) -> [CTSize]\nxTeaEncrypt64 (key, pt) = (hs!0)\n    where hs = [pt] # [ xTeaEncCycle (m, key', i*dlta) | i <- [0,1..31] | m <- hs ]\n          key' = key # zero\n\nxTeaDecrypt64 : ([CTSize], [PTSize]) -> [PTSize]\nxTeaDecrypt64 (key, ct) = (hs!0)\n    where hs = [ct] # [ xTeaDecCycle (pT, key', i*dlta) | i <- [32,31..1] | pT <- hs ]\n          key' = key # zero\n\nproperty xTeaCorrect64 key m = xTeaDecrypt64 (key, xTeaEncrypt64(key,m)) == m\n\nxTeaEncrypt128 : ([TeaKeySize], [TeaKeySize]) -> [TeaKeySize]\nxTeaEncrypt128 (key, pt) = xTeaEncrypt (key, (take`{64} pt)) # zero\n\n\/************************************************************************\/\n\/************************************************************************\/\n\/* Corrected Block TEA or XXTEA*\/\n\/* XTEA modified to cater larger block sizes*\/\n\ntype NB = 2\nNr = 6 + 52\/`NB\ntype bTeaPtSize= NB*stdBlock\n\n\/\/Splitting text into number of words\n\nsplitPtN: [bTeaPtSize] -> [NB][stdBlock]\nsplitPtN pt = split(pt) : [NB][stdBlock]\n\n\/\/Round Function\n\nbTeaRoundFun: [stdBlock]-> [stdBlock]-> [TeaKeySize]-> [6]-> [stdBlock]->[stdBlock]\nbTeaRoundFun y z key p sum = ((z>>5) ^ (y<<2)) + ((y>>3) ^ (z<<4)) ^ (sum ^ y) + ((ki @ ((p!![1,0]) ^ e)) ^ z)\n    where ki = (splitKey key)\n          e = (sum >> 2) !![1,0]\n\n\/\/Mixing in encryption\n\nbTeaEncMixing : ([bTeaPtSize], [TeaKeySize], [stdBlock]) -> [bTeaPtSize]\n\nbTeaEncMixing (pt, key, sum) = join hs'\n    where pt' = splitPtN pt\n          hs = [ (pt'@0)+(bTeaRoundFun (pt'@1) (pt'@(`NB-1)) key 0 sum) ] # [ (pt'@p)+(bTeaRoundFun (pt'@(p+1)) h key p sum) | p <- [1,2..NB-2] | h <- hs ]\n          hs' = hs # [ (pt'@(`NB-1)) + (bTeaRoundFun (hs@0) (hs!0) key (`NB-1) sum) ]\n\nbTeaEncrypt : ([TeaKeySize], [bTeaPtSize]) -> [bTeaPtSize]\nbTeaEncrypt (key, pt) = hs!0\n    where hs = [bTeaEncMixing (pt, key, dlta)] # [ bTeaEncMixing (pT, key, i*dlta) | i <- [2,3..Nr] | pT <- hs ]\n\nbTeaDecMixing : ([bTeaPtSize], [TeaKeySize], [stdBlock]) -> [bTeaPtSize]\n\nbTeaDecMixing (pt, key, sum) = join hs''\n    where pt' = splitPtN pt\n          hs= [(pt'@(`NB-1)) - (bTeaRoundFun (pt'@0) (pt'@(`NB-2)) key  1 sum)] # [ pt'@(`NB-1-p)-(bTeaRoundFun h (pt'@ (`NB-2-p)) key p sum) | p <- [1,2..(NB-2)] | h <- hs ]\n          hs' =  hs # [ pt'@0 - (bTeaRoundFun (hs!0) (hs@0) key  0 sum)]\n          hs'' = [hs'!0] # [hs'!i | i<- [1,2..NB-1] ]\n\nbTeaDecrypt : ([TeaKeySize], [bTeaPtSize]) -> [bTeaPtSize]\nbTeaDecrypt (key, pt) =  hs!0\n    where hs = [bTeaDecMixing (pt, key, `Nr*dlta)] # [ bTeaDecMixing (pT, key, (`Nr-i)*dlta) | i <- [1,2..(Nr-1)] | pT <- hs ]\n\nproperty bTeaCorrect key m = bTeaDecrypt(key, bTeaEncrypt (key, m)) == m\n\ntests = [teaTest, xteaTest, xxteaTest]\nproperty testsPass = and tests\n\nteaTest = teaEncrypt(0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0xce674a7575034065\nxteaTest = xTeaEncrypt(0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0x27e795e076b2b537\nxxteaTest = bTeaEncrypt(0x0123456789abcdef0123456789abcdef,0x0123456789abcdef) == 0x2b98de778c9b788c\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that fully specifies the Galois\/Counter Mode (GCM) authenticated encryption scheme over a 128-bit block cipher, including GCM_AE, GCM_AD, GHASH, GCTR, define_J0, and properties such as gcmIsSymmetric and dotAndMultAreEquivalent, with the same type constraints and behavior."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Specification where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\ninterface constraint (C::BlockSize == 128)\n\n interface constraint (128 <= C::KeySize)\n\ntype constraint ValidIV IV = (width IV <= 64, IV >= 1, IV % 8 == 0)\n\ntype constraint ValidAAD AAD = (width AAD <= 64, AAD % 8 == 0)\n\ntype constraint ValidTag T = (fin T, T % 8 == 0, T \/ 8 >= 12, T \/ 8 <= 16)\n\ntype constraint ValidText P = (fin P, P <= 2^^39 - 256, P % 8 == 0)\n\nGCM_AE : { len_C, len_IV, len_A, T } (ValidText len_C, ValidIV len_IV, ValidAAD len_A, ValidTag T)\n => [C::KeySize] -> [len_IV] -> [len_C] -> [len_A] -> ([len_C], [T])\nGCM_AE k iv p a = (C, T)\n  where\n    CIPHk = C::encrypt k\n\n    H = CIPHk 0\n    J0 = define_J0 k iv H\n    C = GCTR CIPHk (inc`{32} J0) p\n    type u = len_C %^ 128     type v = len_A %^ 128     S = GHASH`{len_A\/^ 128 + len_C \/^ 128 + 1}\n            H (a # (0 : [v]) # C # (0 : [u]) # (`len_A : [64]) # (`len_C : [64]))\n    T = MSB`{T} (GCTR CIPHk J0 S)\n\nGCM_AD : { len_C, len_IV, len_A, T } (ValidText len_C, ValidIV len_IV, ValidAAD len_A, ValidTag T)\n => [C::KeySize] -> [len_IV] -> [len_C] -> [len_A] -> [T] -> Option [len_C]\nGCM_AD key iv ct aad tag =\n  if tag == T'\n  then Some P\n  else None\n  where\n    CIPHk = C::encrypt key\n\n    H = CIPHk 0\n    J0 = define_J0 key iv H\n    P = GCTR CIPHk (inc`{32} J0) ct\n    type u = len_C %^ 128 \/\/ Equivalently: 128 * len_C \/^ 128 - len_C\n    type v = len_A %^ 128 \/\/ Equivalently: 128 * len_A \/^ 128 - len_A\n    S = GHASH`{len_A \/^ 128 + len_C \/^ 128 + 1}\n            H (aad # (0 : [v]) # ct # (0 : [u]) # (`len_A : [64]) # (`len_C : [64]))\n    T' = MSB`{T} (GCTR CIPHk J0 S)\n\nproperty dotAndMultAreEquivalent X Y = mult X Y == X \u2022 Y\n\ngcmIsSymmetric : { P, IV, AAD } ( ValidText P, ValidIV IV, ValidAAD AAD )\n  => [C::KeySize] -> [IV] -> [P] -> [AAD] -> Bool\nproperty gcmIsSymmetric key iv pt aad = is_symmetric\n    where\n        (ct, tag : [96]) = GCM_AE key iv pt aad\n        dec = GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nprivate\n\n  define_J0 : { len_IV } ( ValidIV len_IV ) => [C::KeySize] -> [len_IV] -> [128] -> [128]\n  define_J0 k iv H\n    | len_IV == 96 => iv # (0 : [31]) # (1 : [1])\n    | len_IV != 96 => GHASH`{len_IV \/^ 128 + 1} H (iv # (0 : [s + 64]) # (`len_IV: [64]))\n    where\n      type s = len_IV %^ 128  \n\n  (\u2022) : [128] -> [128] -> [128]\n  (\u2022) X Y = reverse (pmod (pmult (reverse X) (reverse Y))\n                          <| 1 + x + x^^2 + x^^7 + x^^128|>)\n\n  mult : [128] -> [128] -> [128]\n  mult X Y = last Z\n    where\n      R = 0b11100001 # (0 : [120])\n      Z = [0] # [ if [xi] == 0 then Zi else Zi ^ Vi\n                | Zi <- Z\n                | xi <- X\n                | Vi <- V ]\n      V = [Y] # [ if LSB`{1} Vi == 0 then Vi >> 1 else (Vi >> 1) ^ R\n                | Vi <- V ]\n\n  GHASH : {m} (fin m) => [128] -> [m * 128] -> [128]\n  GHASH H X = last Y\n    where Y = [0] # [ (Yi ^ Xi) \u2022 H | Yi <- Y | Xi <- groupBy`{128} X ]\n\n  inc : {s, a} (fin s, fin a, a >= s) => [a] -> [a]\n  inc X = MSB`{a-s} X # (LSB`{s} X + take (1 : [max s 1]))\n\n  LSB : {s, a} (fin s, fin a, a >= s) => [a] -> [s]\n  LSB X = drop X\n\n  MSB : {s, a} (fin s, a >= s) => [a] -> [s]\n  MSB X = take X\n\n  GCTR : {a} (fin a) => ([128] -> [128]) -> [128] -> [a] -> [a]\n  GCTR CIPHk ICB X = Y\n    where\n      Y = X ^ take`{a} (join (map CIPHk CB))\n      CB = iterate inc`{32} ICB\n\n  emptyInputProducesEmptyOutputGCTR : [C::KeySize] -> [128] -> Bool\n  property emptyInputProducesEmptyOutputGCTR key icb =\n   zero == (GCTR CIPHk icb (zero : [0]))\n    where\n      CIPHk = C::encrypt key\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Tests\/AES128_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module that instantiates AES-GCM with AES-128 (GCM_AE and GCM_AD) and defines properties aes128_vector_0 through aes128_vector_3 checking NIST test vectors for ciphertext, authentication tag, and successful decryption symmetry for the given keys, IVs, plaintexts, and AADs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES128_GCM where\nimport Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES128_GCM as AES_GCM\n\nproperty aes128_vector_0 = ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        pt = []\n        key = zero : [128]\n        iv = zero : [96]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt []\n        dec = AES_GCM::GCM_AD key iv ct [] tag\n        expected_ct = [] : [0]\n        expected_tag = 0x58e2fccefa7e3061367f1d57a4e7455a : [128]\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nproperty aes128_vector_1 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = zero\n        iv = zero : [96]\n        pt = zero\n        aad = []\n        expected_ct = 0x0388dace60b6a392f328c2b971b2fe78 : [128]\n        expected_tag = 0xab6e47d42cec13bdf53a67b21257bddf : [128]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nproperty aes128_vector_2 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = 0xfeffe9928665731c6d6a8f9467308308\n        iv = 0xcafebabefacedbaddecaf888 : [96]\n        pt = 0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b391aafd255\n        aad = []\n        expected_ct = 0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091473f5985\n        expected_tag = 0x4d5c2af327cd64a62cf35abd2ba6fab4 : [128]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nproperty aes128_vector_3 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = 0xfeffe9928665731c6d6a8f9467308308\n        pt  = 0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b39\n        iv  = 0xcafebabefacedbaddecaf888\n        aad = 0xfeedfacedeadbeeffeedfacedeadbeefabaddad2\n        expected_ct  = 0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091\n        expected_tag = 0x5bc94fbc3221a5db94fae95ae7121a47\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Tests\/AES256_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES256_GCM` that defines properties `aes256_vector_0` and `aes256_invalid_vector_1` to test AES-256-GCM authenticated encryption\/decryption correctness and tag-validation behavior against the given fixed key\/IV\/PT\/AAD\/test-vector values using `AES_GCM::GCM_AE` and `AES_GCM::GCM_AD`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES256_GCM where\nimport Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES256_GCM as AES_GCM\n\nproperty aes256_vector_0 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key   = 0xeebc1f57487f51921c0465665f8ae6d1658bb26de6f8a069a3520293a572078f : [256]\n        iv    = 0x99aa3e68ed8173a0eed06684 : [96]\n        pt    = 0xf56e87055bc32d0eeb31b2eacc2bf2a5 : [128]\n        aad   = 0x4d23c3cec334b49bdb370c437fec78de : [128]\n        expected_ct   = 0xf7264413a84c0e7cd536867eb9f21736\n        expected_tag  = 0x67ba0510262ae487d737ee6298f77e0c\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nproperty aes256_invalid_vector_1 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ requires_symmetry\n    where\n        key   = 0xeebc1f57487f51921c0465665f8ae6d1658bb26de6f8a069a3520293a572078f : [256]\n        iv    = 0x99aa3e68ed8173a0eed06684 : [96]\n        pt    = 0xf56e87055bc32d0eeb31b2eacc2bf2a5 : [128]\n        aad   = 0x4d23c3cec334b49bdb370c437fec78de : [128]\n        expected_ct   = 0xf7264413a84c0e7cd536867eb9f21736\n        expected_tag  = 0x67ba0510262ae487d737ee6298f77e0c\n        invalid_tag  = 0x67ba0510262ae487d737ee6298f77888\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        requires_symmetry = case (AES_GCM::GCM_AD key iv ct aad invalid_tag) of\n            Some _ -> False\n            None -> True\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Instantiations\/AES128_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES128_GCM` that instantiates the generic GCM specification with AES-128 as the underlying block cipher, matching the given module path and structure."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES128_GCM =\n    Primitive::Symmetric::Cipher::Authenticated::GCM::Specification {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Instantiations\/AES256_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES256_GCM` that instantiates the generic GCM authenticated-encryption specification with AES-256 as the underlying block cipher, exposing the appropriate AES-256-GCM encryption\/decryption and authentication interfaces."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES256_GCM =\n    Primitive::Symmetric::Cipher::Authenticated::GCM::Specification {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::TDES_CBC` that specifies CBC mode encryption\/decryption using TripleDES over 64-bit blocks, including the functions `cbcTDesEnc`, `cbcTDesDec`, and properties `cbcTDESEncryptDecryptInverts` and `testsPass` with the given known-answer test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::TDES_CBC where\n\nimport Primitive::Symmetric::Cipher::Block::TripleDES (encrypt, decrypt)\n\ntype iv = [64]\ntype block = [64]\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncbcTDesEnc : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncbcTDesEnc k1 k2 k3 iv ps = cs\n    where\n        ks = [ k1, k2, k3 ]\n        cs = [ encrypt ks (p ^ c') | p <- ps | c' <- [iv] # cs ]\n\ncbcTDesDec : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncbcTDesDec k1 k2 k3 iv cts = pts\n    where\n        ks  = [ k1, k2, k3 ]\n        pts = [ (decrypt ks ct) ^ fb |  ct <- cts | fb <- [iv] # cts  ]\n\ncbcTDESEncryptDecryptInverts : k1 -> k2 -> k3 -> iv -> [3]block -> Bit\nproperty cbcTDESEncryptDecryptInverts k1 k2 k3 iv pt = pt == pt'\n    where\n        ct  = cbcTDesEnc k1 k2 k3 iv pt\n        pt' = cbcTDesDec k1 k2 k3 iv ct\n\ntestKey = { k1=0x0123456789ABCDEF\n          , k2=0x23456789ABCDEF01\n          , k3=0x456789ABCDEF0123\n          , iv=0xF69F2445DF4F9B17\n          }\ntestPt  = [0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]\ntestCt  = [0x2079C3D53AA763E1, 0x93B79E2569AB5262, 0x516570481F25B50F, 0x73C0BDA85C8E0DA7]\n\nproperty testsPass = pt == testPt\n                  \/\\ ct == testCt\n    where\n        ct = cbcTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv testPt\n        pt = cbcTDesDec testKey.k1 testKey.k2 testKey.k3 testKey.iv testCt\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module implementing CBC block cipher mode over an abstract block cipher interface, including encrypt\/decrypt functions with key, IV, and block sequence parameters, and a property encryptCorrect asserting decrypt K IV (encrypt K IV Ps) == Ps for all inputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CBC where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\nencrypt : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\nencrypt K IV Ps = Cs\n    where\n        CIPH_K = C::encrypt K\n        Cs = [ CIPH_K (P_j ^ C_j_1) | P_j <- Ps | C_j_1 <- [IV] # Cs]\n\ndecrypt : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\ndecrypt K IV Cs = Ps\n    where\n        CIPH_K_inv = C::decrypt K\n        Ps = [ (CIPH_K_inv C_j) ^ C_j_1 | C_j <- Cs | C_j_1 <- [IV] # Cs]\n\nencryptCorrect : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> Bool\nproperty encryptCorrect K IV Ps = (decrypt K IV (encrypt K IV Ps)) == Ps\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing CTR mode for a block cipher (given C::encrypt, C::KeySize, C::BlockSize), with encrypt\/decrypt functions over n blocks and a property encryptCorrect stating decrypt k c (encrypt k c ps) == ps for all valid n, keys, nonces, and plaintexts."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CTR where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\nencrypt : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\nencrypt k t_1 ps = cs\n    where\n        ciph_k = C::encrypt k\n                cs = [p_j ^ (ciph_k t_j) | p_j <- ps | t_j <- ctrs]\n                ctrs = [t_1 + i | i<- [0...]]\n\ndecrypt : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\ndecrypt k t_1 cs = ps\n    where\n        ciph_k = C::encrypt k\n                ps = [c_j ^ (ciph_k t_j) | c_j <- cs | t_j <- ctrs]\n                ctrs = [t_1 + i | i<- [0...]]\n\nencryptCorrect : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> Bool\nproperty encryptCorrect k c ps = (decrypt k c (encrypt k c ps)) == ps\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/XTS.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module specifying AES-XTS block cipher mode (XTS mode) with tweak generation, encrypt\/decrypt functions for valid lengths, and properties such as decryptInvertsEncrypt and flipEndianInvolutive holding for all appropriate inputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::XTS where\n\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\ninterface constraint (C::BlockSize == 128)\n\nflipEndian : [128] -> [128]\nflipEndian x = join (reverse (groupBy`{8} x))\n\nproperty flipEndianInvolutive x = flipEndian (flipEndian x) == x\n\ntype constraint ValidLength n = (n \/^ C::BlockSize <= 2^^20, n >= C::BlockSize, fin n)\n\ndataUnitSeqNoToIV : {n} (n <= 128) => [n] -> [128]\ndataUnitSeqNoToIV S = flipEndian (zext S)\n\nproperty dataUnitSeqNoExample = dataUnitSeqNoToIV 0x123456789a == 0x9a785634120000000000000000000000\n\nmultAlphaLE : [128] -> [128]\nmultAlphaLE x = flipEndian (multAlpha (flipEndian x))\n  where\n    multAlpha p = pmod (pmult p alpha) irreducible\n\nalpha : [2]\nalpha = <| x |>\n\nirreducible : [129]\nirreducible = <| x^^128 + x^^7 + x^^2 + x + 1 |>\n\ngenerateTweaks : [C::KeySize] -> [128] -> [inf][128]\ngenerateTweaks K2 i = iterate multAlphaLE (C::encrypt K2 i)\n\nencryptBlock : [C::KeySize] -> [128] -> [128] -> [128]\nencryptBlock K T P = C\n  where\n            PP = T ^ P     CC = C::encrypt K PP     C  = CC ^ T \n\nencrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> [n]\nencrypt (K1 # K2) i P\n  | 0 == n % 128 =>\n    join\n      [ encryptBlock K1 T blk\n      | T <- generateTweaks K2 i\n      | blk <- split`{n \/ 128} P ]\n  | otherwise => C\n    where\n                  type M = n \/ 128\n\n                        T_0_m1 # [Tm1, Tm] = take`{M + 1} (generateTweaks K2 i)\n\n                        P_0_m2 # Pm1 # Pm = P\n\n            C_0_m2 = join [encryptBlock K1 T blk | T <- T_0_m1 | blk <- split`{M - 1} P_0_m2]\n\n            CC = encryptBlock K1 Tm1 Pm1\n\n            Cm # CP = CC\n\n            PP = Pm # CP\n\n            Cm1 = encryptBlock K1 Tm PP\n\n            C = C_0_m2 # Cm1 # Cm\n\ntype constraint otherwise = ()\n\ndecryptBlock : [C::KeySize] -> [128] -> [128] -> [128]\ndecryptBlock K T C = P\n  where\n            CC = C ^ T     PP = C::decrypt K CC     P = PP ^ T \n\ndecrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> [n]\ndecrypt (K1 # K2) i C\n  | 0 == n % 128 =>\n    join\n      [ decryptBlock K1 T blk\n      | T <- generateTweaks K2 i\n      | blk <- split`{n \/ 128} C ]\n  | otherwise => P\n    where\n            type M = n \/ 128\n\n            T_0_m2 # [Tm1, Tm] = take`{M + 1} (generateTweaks K2 i)\n\n            C_0_m2 # Cm1 # Cm = C\n\n            P_0_m2 = join [decryptBlock K1 T blk | T <- T_0_m2 | blk <- split`{M - 1} C_0_m2]\n\n            Pm # CP = decryptBlock K1 Tm Cm1\n\n            CC = Cm # CP\n\n            Pm1 = decryptBlock K1 Tm1 (Cm # CP)\n\n            P = P_0_m2 # Pm1 # Pm\n\ndecryptInvertsEncrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> Bool\nproperty decryptInvertsEncrypt K i P = decrypt K i (encrypt K i P) == P\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing Triple-DES in CFB mode with 64-bit blocks and IV, including cfbTDesEnc and cfbTDesDec, and properties cfbTDESEncryptDecryptInverts and testsPass that verify encryption\/decryption invert each other and match the given NIST-style test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::TDES_CFB where\n\nimport Primitive::Symmetric::Cipher::Block::TripleDES (encrypt)\n\ntype iv = [64]\ntype block = [64]\n\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncfbTDesEnc : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncfbTDesEnc k1 k2 k3 iv ps = cs\n    where\n        ks = [ k1, k2, k3 ]\n        cs = [ (encrypt ks c') ^ p | p <- ps | c' <- [iv] # cs ]\n\ncfbTDesDec : {n} (fin n) => k1 -> k1 -> k3 -> iv -> [n]block -> [n]block\ncfbTDesDec k1 k2 k3 iv cts = pts\n    where\n        ks  = [ k1, k2, k3 ]\n        pts = [ (encrypt ks fb) ^ ct | ct <- cts | fb <- [iv] # cts ]\n\ncfbTDESEncryptDecryptInverts : k1 -> k2 -> k3 -> iv -> [3]block -> Bit\nproperty cfbTDESEncryptDecryptInverts k1 k2 k3 iv pt = pt == pt'\n    where\n        ct = cfbTDesEnc k1 k2 k3 iv pt\n        pt' = cfbTDesDec k1 k2 k3 iv ct\n\ntestKey = { k1=0x0123456789ABCDEF\n          , k2=0x23456789ABCDEF01\n          , k3=0x456789ABCDEF0123\n          , iv=0xF69F2445DF4F9B17\n          }\ntestPt = [0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]\ntestCt = [0x078BB74E59CE7ED6, 0x7666DE9CF95EAF3F, 0xE9ED6BB460F45152, 0x8A5F9FE4ED710918]\n\nproperty testsPass = ct == testCt\n                  \/\\ pt == testPt\n    where\n        ct = cfbTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv testPt\n        pt = cfbTDesDec testKey.k1 testKey.k2 testKey.k3 testKey.iv testCt\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AESKeyWrap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing the AES Key Wrap and AES Key Wrap with Padding modes over a 128-bit block cipher, including W\/WInv, KW_AE\/KW_AD, KWP_AE\/KWP_AD, and properties proving wrappingInverts, keyWrapInverts, and keyWrapPaddedInverts hold for all valid inputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::AESKeyWrap where\n\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\ninterface constraint (C::KeySize >= 64)\ninterface constraint (C::BlockSize == 128)\n\ntype Octet = 8\n\ntype Semiblock = C::BlockSize \/ 2\n\nICV1 = 0xA6A6A6A6A6A6A6A6\n\nICV2 = 0xA65959A6\n\nCIPHK K X = C::encrypt K X\n\nCIPHInvK K X = C::decrypt K X\n\nint = toInteger\n\nlen : {n} (fin n) => [n] -> Integer\nlen _X = `n\n\nLSB : {s, n} (fin s, fin n, n >= s) => [n] -> [s]\nLSB = drop`{n - s}\n\nMSB : {s, n} (fin s, fin n, n >= s) => [n] -> [s]\nMSB = take`{s}\n\nproperty hexRepresentation = 0xA659 == 0b1010011001011001\n\nproperty zeroRepresentation = (zero : [8]) == 0b00000000\n\nproperty concatRepresentation = 0b001 # 0b10111 == 0b00110111\n\nproperty xorRepresentation = 0b10011 ^ 0b10101 == 0b00110\n\nproperty lenRepresentation = len 0b00010 == 5\n\nproperty signficanceWorks = lsb && msb where\n    X = 0b111011010\n    lsb = LSB`{3} X == 0b010\n    msb = MSB`{4} X == 0b1110\n\nproperty integerToString = (39 == 0b00100111) && ((39 : [8]) == 0b00100111)\n\nproperty stringToInteger = int 0b00011010 == 26\n\ntype constraint KW_Plaintext n = (2 <= n, width n <= 54)\n\ntype constraint KW_Ciphertext n = (3 <= n, n <= 2^^54)\n\ntype constraint KWP_Plaintext n = (1 <= n, width n <= 32)\n\ntype constraint KWP_Ciphertext n = (2 <= n, n <= 2^^29)\n\nW : {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n][Semiblock] -> [n * Semiblock]\nW K S = C where\n            type s = 6 * (n - 1)\n    A0 = S@0\n    R0 = drop`{1} S\n\n                    update_variables : ([Semiblock], [n-1][Semiblock]) -> [Semiblock]\n        -> ([Semiblock], [n-1][Semiblock])\n    update_variables (At1, Rt1) t = (At, Rt) where\n        At = MSB`{64} (CIPHK K (At1 # Rt1@0)) ^ t\n        Rnt = LSB`{64} (CIPHK K (At1 # Rt1@0))\n        Rt = drop`{1} Rt1 # [Rnt]\n\n    (As, Rs) = foldl update_variables (A0, R0) [1..s]\n\n        C1 = As\n    Cis = Rs\n    C = C1 # (join Cis)\n\nWInv : {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n][Semiblock] -> [n * Semiblock]\nWInv K C = S where\n            type s = 6 * (n - 1)\n    As = C@0\n    Rs = drop`{1} C\n\n                    update_variables : ([Semiblock], [n-1][Semiblock]) -> [Semiblock]\n        -> ([Semiblock], [n-1][Semiblock])\n    update_variables (At, Rt) t = (At1, Rt1) where\n        At1 = MSB`{64} (CIPHInvK K ((At ^ t) # Rt@`(n-2)))\n        R2t1 = LSB`{64} (CIPHInvK K ((At ^ t) # Rt@`(n-2)))\n        Rt1 = [R2t1] # take`{n-2} Rt\n\n    (A0, R0) = foldl update_variables (As, Rs) [s, s-1..1]\n\n        S1 = A0\n    Sis = R0\n    S = S1 # (join Sis)\n\nwrappingInverts :\n    {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n * Semiblock] -> Bit\nproperty wrappingInverts K S = S == S' where\n    C = W K (split S)\n    S' = WInv K (split C)\n\nKW_AE : {n} (KW_Plaintext n)\n    => [C::KeySize] -> [n * Semiblock] -> [(n + 1) * Semiblock]\nKW_AE K P = C where\n    S = ICV1 # P\n    C = W K (split S)\n\nKW_AD : {n} (KW_Ciphertext n)\n    => [C::KeySize] -> [n * Semiblock] -> Option [(n - 1) * Semiblock]\nKW_AD K C = if MSB`{64} S != ICV1 then None\n    else Some (LSB`{64 * (n - 1)} S)\n    where\n        S = WInv K (split C)\n\nkeyWrapInverts : {n} (KW_Plaintext n) => [C::KeySize] -> [n * Semiblock] -> Bit\nproperty keyWrapInverts K P = inverts where\n    C = KW_AE K P\n    inverts = case (KW_AD K C) of\n        Some maybeP -> maybeP == P\n        None -> False\n\nKWP_AE : {n} (KWP_Plaintext n, KWP_Ciphertext (n \/^ 8 + 1))\n    => [C::KeySize] -> [n * Octet] -> [(n \/^ 8 + 1) * Semiblock]\nKWP_AE K P = C where\n            type lenP = 8 * n\n\n        type padlen = 8 * (lenP \/^ 64) - (lenP \/ 8)\n\n        PAD = zero : [8 * padlen]\n\n        S = ICV2 # (`(lenP \/ 8) : [32]) # P # PAD\n\n        C = KWP_AE_Step5`{n} K S\n\nKWP_AE_Step5: {n} (KWP_Plaintext n)\n    => [C::KeySize] -> [(n \/^ 8 + 1) * Semiblock] -> [(n \/^ 8 + 1) * Semiblock]\nKWP_AE_Step5 K S\n    | 8 * n <= 64 => CIPHK K S\n    | 8 * n > 64 => W K (split S)\n\nKWP_AD : {m, n} (KWP_Ciphertext n, KWP_Plaintext m, n == 1 + m \/^ 8)\n    => [C::KeySize] -> [n * Semiblock] -> Option [m * Octet]\nKWP_AD K C =\n    if (ICV2 != MSB`{32} S)                         || (padlen < 0)                             || (padlen > 7)                             || (zero   != LSB`{8 * m %^ 64} S)          || (Plen   != `m)                           || (padlen != `(m %^ 8))                then None\n    else Some P\n    where\n        S = KWP_AD_Step3 K C\n\n                Plen = int (LSB`{32} (MSB`{64} S))\n        padlen = 8 * (`n - 1) - Plen\n\n                P = MSB`{8 * m} (LSB`{64 * (n - 1)} S)\n\nKWP_AD_Step3 : {n} (KWP_Ciphertext n)\n    => [C::KeySize] -> [n * Semiblock] -> [n * 64]\nKWP_AD_Step3 K C\n    | n == 2 => CIPHInvK K C\n    | n > 2 => WInv K (split C)\n\nkeyWrapPaddedInverts : {n} (KWP_Ciphertext (n \/^ 8 + 1), KWP_Plaintext n)\n    => [C::KeySize] -> [n * Octet] -> Bit\nproperty keyWrapPaddedInverts K P = inverts where\n    C = KWP_AE K P\n    inverts = case (KWP_AD K C) of\n        Some maybeP -> maybeP == P\n        None -> False\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module specifying the CFB block cipher mode built over an abstract block cipher interface, including encrypt and decrypt functions parameterized by segment size, and a property encryptCorrect stating decrypt K IV (encrypt K IV Ps) == Ps for all valid parameters."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CFB where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\nencrypt : {s, n} (fin s, fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> [n][s]\nencrypt K IV Ps = Cs\n    where\n        CIPH_K = C::encrypt K\n        Is = [ (drop`{s} I_j_1) # C_j_1\n             | I_j_1 <- [IV] # Is\n             | C_j_1 <- Cs\n             ]\n        Cs = [ P_j ^ (take`{s} (CIPH_K I_j))\n             | P_j <- Ps\n             | I_j <- [IV] # Is\n             ]\n\ndecrypt : {s, n} (fin s, fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> [n][s]\ndecrypt K IV Cs = Ps\n    where\n        CIPH_K = C::encrypt K\n        Is = [ (drop`{s} I_j_1) # C_j_1\n             | I_j_1 <- [IV] # Is\n             | C_j_1 <- Cs\n             ]\n        Ps = [ C_j ^ (take`{s} (CIPH_K I_j))\n             | C_j <- Cs\n             | I_j <- [IV] # Is\n             ]\n\nencryptCorrect : {s, n} (fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> Bool\nproperty encryptCorrect K IV Ps = (decrypt K IV (encrypt K IV Ps)) == Ps\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing the SIMON block cipher (parameterized by word size n, key words m, and rounds T), including encrypt\/decrypt, the key schedule, and properties showing decryption inverts encryption, both formulations of encrypt\/decrypt and keySchedule\/keySchedule' are equivalent, and u\/v\/w sequences match their matrix definitions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Specification where\n\nparameter\n\n  type n : #\n\n  type m : #\n\n  type constraint (fin n, fin m, n >= 4, m >= 2, m <= 4)\n\n  type j : #\n  type constraint (j >= 0, j < 5)\n\n  type T : #\n\n  type constraint (fin T, T > 4)\n\nencrypt : [m * n] -> [2 * n] -> [2 * n]\nencrypt key plaintext = ciphertext\n  where\n    Simon_k = composeMany Rks\n            Rks = map R (keySchedule (reverse (split key)))\n    ciphertext = join (Simon_k (split plaintext))\n\ndecrypt : [m * n] -> [2 * n] -> [2 * n]\ndecrypt key ciphertext = plaintext\n  where\n    Simon_k = composeMany (reverse Rks)\n            Rks = map R_Inv (keySchedule (reverse (split key)))\n    plaintext = join (Simon_k (split ciphertext))\n\nprivate\n\n  property decryptInvertsEncrypt k pt = pt == decrypt k (encrypt k pt)\n\n  encrypt' : [m * n] -> [2 * n] -> [2 * n]\n  encrypt' key plaintext = join (rounds ! 0)\n    where\n      [x, y] = split plaintext\n      ks     = keySchedule' (reverse (split key))\n      \/\/ there are T round keys\n      \/\/ So, the following list comprehension runs over i = 0..T-1\n      rounds = [[x, y]] # [R k p | k <- ks | p <- rounds]\n\n  \/**\n   * Likewise, the decryption can be calculated in a more imperative fashion.\n   *\/\n  decrypt' : [m * n] -> [2 * n] -> [2 * n]\n  decrypt' key ciphertext = join (rounds ! 0)\n    where\n      [x, y] = split ciphertext\n      ks = keySchedule' (reverse (split key))\n      rounds = [[x, y]] # [R_Inv k ct | k <- (reverse ks) | ct <- rounds]\n\n  property encryptsEquivalent k p = encrypt k p == encrypt' k p\n\n  \/**\n   * The two formulations of decryption are functionally equiavalent.\n   *\n   * ```repl\n   * :check decryptsEquivalent\n   * ```\n   *\/\n  property decryptsEquivalent k p = decrypt k p == decrypt' k p\n\n  S : {i} (fin i) => [n] -> [n]\n  S x = x <<< `i\n\n  S_Inv : {i} (fin i) => [n] -> [n]\n  S_Inv x = x >>> `i\n\n  SInvertible : {i} (fin i) => [n] -> Bit\n  property SInvertible x = S_Inv `{i} (S `{i} x) == x\n\n  f : [n] -> [n]\n  f x = (S `{1} x && S `{8} x) ^ S `{2} x\n\n  R : [n] -> [2][n] -> [2][n]\n  R k [x, y] = [y ^ f x ^ k, x]\n\n  R_Inv : [n] -> [2][n] -> [2][n]\n  R_Inv k [x, y] = [y, x ^ f y ^ k]\n\n  property RInvertible k x = x == R_Inv k (R k x)\n\n  u : [inf]\n  u = 0b1111101000100101011000011100110 # u\n\n  v : [inf]\n  v = 0b1000111011111001001100001011010 # v\n\n  w : [inf]\n  w = 0b1000010010110011111000110111010 # w\n\n  t : [inf]\n  t = 0b01 # t\n\n  z0 = u\n\n  z1 = v\n\n  z2 = u ^ t\n\n  z3 = v ^ t\n\n  z4 = w ^ t\n\n  extend : [inf] -> [inf][n]\n  extend s = map (zext `{n}) (split `{inf, 1} s)\n\n  zjs = map extend [z0, z1, z2, z3, z4]\n\n  zj = zjs@`j\n\n  c : [n]\n  c = fromInteger (2 ^^ `n - 4)\n\n  IS_Inv : [n] -> [n]\n  IS_Inv x = x ^ S_Inv `{1} x\n\n  keySchedule : [m][n] -> [T][n]\n  keySchedule k0\n    | m == 2 => k where\n      k = k0 # [\n      c ^ zji ^ (k @ i) ^ IS_Inv (S_Inv `{3} (k @ (i+1)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n    | m == 3 => k where\n      k = k0 # [\n      c ^ zji ^ (k@i) ^ IS_Inv (S_Inv `{3} (k@(i+2)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n    | m == 4 => k where\n      k  = k0 # [\n      c ^ zji ^ (k@i) ^ IS_Inv (S_Inv `{3} (k@(i+3)) ^ (k@(i+1)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n\n  keySchedule' : [m][n] -> [T][n]\n  keySchedule' k0 = k\n    where\n      k = k0 # [ ki where\n                  tmp0 = k @ (i - 1) >>> 3\n                  tmp1 = if `m == 4 then tmp0 ^ k @ (i - 3) else tmp0\n                  tmp2 = tmp1 ^ tmp1 >>> 1\n                  ki = ~ k @ (i - `m) ^ tmp2 ^ z ^ 3\n                  z = zj @ ((i - `m) % 62)\n            | i <- [m .. T - 1]\n            ]\n\n  property keyScheduleInjective k p = k != p ==> keySchedule k != keySchedule p\n\n  property keySchedulesEquivalent k = keySchedule k == keySchedule' k\n\n  \/**\n   * Composition of functions `g` and `h`\n   * specialized to functions from `(a -> a)`.\n   *\/\n  compose : {a} () => (a -> a) -> (a -> a) -> a -> a\n  compose g h = \\x -> h (g x)\n\n  \/**\n   * Composition of many functions from `(a -> a)`\n   *\/\n  composeMany : {nf, a} (fin n) => [nf](a -> a) -> a -> a\n  composeMany fcns\n    | nf == 0 => \\x -> x\n    | nf == 1 => fcns@0\n    | nf == 2 => compose (fcns@0) (fcns@1)\n    | nf > 2  => compose (fcns@0) (composeMany (drop `{1} fcns))\n\n  \/**\n   * Multiplication of a row vector by a matrix\n   * This is not defined in the Simon specification.\n   * We take the straightforward approach of treating\n   * this as a linear combination of a subset of the\n   * matrix rows depending on which bits of the row vector are set.\n   *\/\n  linearMap : {rows, cols} (fin rows, fin cols) =>\n    [rows][cols] -> [rows] -> [cols]\n  linearMap matrix vector = foldl (^) zero matrix'\n    where\n      matrix' = map (\\(i, vi) -> if i then vi else zero) (zip vector matrix)\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `u`\n   * if the initial fill `0b00001` is used.\n   *\/\n  U = [ 0b01000\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10001\n      ]\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `v`\n   * if the initial fill `0b00001` is used.\n   *\/\n  V = [ 0b01100\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10000\n      ]\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `w`\n   * if the initial fill `0b00001` is used.\n   *\/\n  W = [ 0b01000\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10000\n      ]\n\n  \/**\n   * A function that treats row vector - matrix multiplication\n   * as a shift register, generating the sequence of shift\n   * register outputs for a given initial fill.\n   *\/\n  seqn : [5][5] -> [inf]\n  seqn matrix = map (\\x -> x@4) steps\n    where\n      steps     = iterate (\\x -> linearMap matrix x) 0b00001\n\n  \/**\n   * A formal definition of the sequence `u`,\n   * given in Section 3.2 of [SIMON].\n   *\/\n  u' = seqn U\n\n  v' = seqn V\n\n  \/**\n   * A formal definition of the sequence `w`,\n   * given in Section 3.2 of [SIMON].\n   *\/\n  w' = seqn W\n\n  property uDefinitionEquivalence = take `{100} u == take `{100} u'\n\n  \/**\n   * A property encoding that the formal and informal definitions of `v`\n   * are equivalent.\n   *\n   * ```repl\n   * :check vDefinitionEquivalence\n   * ```\n   *\/\n  property vDefinitionEquivalence = take `{100} v == take `{100} v'\n\n  property wDefinitionEquivalence = take `{100} w == take `{100} w'\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that specifies the parameterized Speck block cipher (encrypt\/decrypt and key schedule) and includes properties proving decrypt inverts encrypt, the round function is invertible and equivalent to its factored form, and the key schedule is injective and equivalent to an alternative formulation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\nimport Common::utils (composeMany, compose)\n\nparameter\n\n    type n : #\n\n    type m : #\n\n    type T : #\n\n    type constraint (fin n, fin T, fin m)\n    type constraint (m >= 2, m <= 4, T >= 2, n >= width T)\n    type constraint (n >= 16)\n\nencrypt : [m * n] -> [2 * n] -> [2 * n]\nencrypt key plaintext = join (Speck_k (split plaintext))\n    where\n                                        Rks = map R (keySchedule (reverse (split key)))\n        Speck_k = composeMany Rks\n\ndecrypt : [m * n] -> [2 * n] -> [2 * n]\ndecrypt key ciphertext = join (Speck_k (split ciphertext))\n    where\n                Rks = map R_Inv (keySchedule (reverse (split key)))\n        Speck_k = composeMany (reverse Rks)\n\nprivate\n\n    property decryptInvertsEncrypt k x = decrypt k (encrypt k x) == x\n\n    S : {j} (fin j) => [n] -> [n]\n    S x = x <<< `j\n\n    S_Inv : {j} (fin j) => [n] -> [n]\n    S_Inv x = x >>> `j\n\n    S\u03b1: [n] -> [n]\n    S\u03b1 x | n == 16 => S `{7} x\n         | n >= 16 => S `{8} x\n\n    S\u03b2 : [n] -> [n]\n    S\u03b2 x | n == 16 => S `{2} x\n         | n >= 16 => S `{3} x\n\n    S\u03b1_Inv : [n] -> [n]\n    S\u03b1_Inv x | n == 16 => S_Inv `{7} x\n             | n >= 16 => S_Inv `{8} x\n\n    S\u03b2_Inv : [n] -> [n]\n    S\u03b2_Inv x | n == 16 => S_Inv `{2} x\n             | n >= 16 => S_Inv `{3} x\n\n    R : [n] -> [2][n] -> [2][n]\n    R k [x, y] = [(S\u03b1_Inv x + y) ^ k, S\u03b2 y ^ (S\u03b1_Inv x + y) ^ k]\n\n    R_Inv : [n] -> [2][n] -> [2][n]\n    R_Inv k [x, y] = [S\u03b1 ((x ^ k) - S\u03b2_Inv (x ^ y)), S\u03b2_Inv (x ^ y)]\n\n    property RInvertible k x = R_Inv k (R k x) == x\n\n    Rf1 : [n] -> [2][n] -> [2][n]\n    Rf1 k [x, y] = [y, (S\u03b1_Inv x + y) ^ k]\n\n    Rf2 : [2][n] -> [2][n]\n    Rf2 [x, y] = [y, S\u03b2 x ^ y]\n\n    Rf : [n] -> [2][n] -> [2][n]\n    Rf k s = f s\n        where\n            f = compose (Rf1 k) Rf2\n\n    property REquivalent k s = Rf k s == R k s\n\n    keySchedule : [m][n] -> [T][n]\n    keySchedule K = ks\n        where\n                        [k0] # li = K\n                        ks = [k0] # [S\u03b2 (ks @ i) ^ (ls @ (i + `m - 1)) | i <- [0..T - 2]]\n            ls = li # [(k + S\u03b1_Inv (ls @ i)) ^ i | k <- ks | i <- [0..T - 2] ]\n\n    property keyScheduleInjective k v = k != v ==> result\n        where\n            result = keySchedule k != keySchedule v\n\n    keySchedule' : [m][n] -> [T][n]\n    keySchedule' K = ks\n        where\n                        [k0] # li = K\n                        ks = [k0] # [f2 [(ks @ i), (ls @ (i + `m - 1))] | i <- [0..T - 2]]\n            ls = li # [f1 i [ls @ i, k] | k <- ks | i <- [0..T - 2] ]\n                                                f1 k s = (Rf1 k s) @ 1\n            f2 s = (Rf2 s) @ 1\n\n    property keySchedulesEquivalent K = keySchedule K == keySchedule' K\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::AES::Specification` that fully specifies AES-128\/192\/256 encryption\/decryption (including key schedule, S-boxes, round transformations, Rcon) and defines properties such as `aesIsCorrect`, `ioInverts`, `SBox53`, `SBoxInverts`, `RconIsExponentiation`, and inversion properties for each round operation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Specification where\n\nimport Common::GF28 as GF28\nprivate type GF28 = GF28::GF28\n\nparameter\n      type KeySize' : #\n  type constraint (fin KeySize', KeySize' % 64 == 0, KeySize' \/ 64 >= 2,\n    KeySize' \/ 64 <= 4)\n\n\/**\n * The AES implementation uses the `Mode` type to compute other parameters.\n * The mode corresponds directly to the key size:\n * Mode 0 = 128 bits; Mode 1 = 192 bits; Mode 2 = 256 bits\n *\/\ntype Mode = (KeySize \/ 64) - 2\n\n\/\/ The following section encodes\n\n\/**\n * Key length: number of 32 bit words in the key.\n * [FIPS-197u1] Section 5, Table 3\n *\/\ntype Nk = 4 + 2 * Mode\n\n\/**\n * Number of rounds\n * [FIPS-197u1] Section 5, Table 3\n *\/\ntype Nr = 6 + Nk\n\n\/**\n * The number of words in the state is generic for the underlying Rijndael\n * algorithm, but in the standard it is fixed to 4.\n * [FIPS-197u1] Section 5.\n *\/\ntype Nb = 4\n\n\/\/ Make `KeySize` and `BlockSize` accessible outside the module.\n\/\/ This also lets us use AES as an instantiation of `CipherInterface`\ntype KeySize = KeySize'\ntype BlockSize = 128\n\nencrypt : [KeySize] -> [BlockSize] -> [BlockSize]\nencrypt k = cipher (keyExpansion k)\n\ndecrypt : [KeySize] -> [BlockSize] -> [BlockSize]\ndecrypt k = invCipher (keyExpansion k)\n\nproperty aesIsCorrect k pt = decrypt k (encrypt k pt) == pt\n\ntype State = [4][Nb]GF28\n\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\nproperty ioInverts msg = stateToMsg (msgToState msg) == msg\n\nsboxTable : [256]GF28\nprivate sboxTable = [ transform (GF28::inverse b) | b <- [0 .. 255] ] where\n        transform b = GF28::add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n        c = 0x63\n\nSBox : GF28 -> GF28\nSBox b = sboxTable @ b\n\nproperty SBox53 = SBox 0x53 == 0xed\n\nsboxInvTable : [256]GF28\nprivate sboxInvTable = [ GF28::inverse (transformInv b) | b <- [0 .. 255] ] where\n    transformInv b = GF28::add [(b >>> 2), (b >>> 5), (b >>> 7), d]\n    d = 0x05\n\nSBoxInv : GF28 -> GF28\nSBoxInv b = sboxInvTable @ b\n\nproperty SBoxInverts b = SBoxInv (SBox b) == b\n\ntype RoundKey = [4][4]GF28\n\ntype KeySchedule = [Nr+1]RoundKey\n\ncipher: KeySchedule -> [128] -> [128]\ncipher w pt = stateToMsg final_state   where\n        state0 = AddRoundKey (w @ 0) (msgToState pt)\n        state4 = foldl transform state0 (w @@ [1 .. (Nr - 1)])\n        transform state word = AddRoundKey word (MixColumns (ShiftRows (SubBytes state)))\n        final_state = AddRoundKey (w @ `Nr) (ShiftRows (SubBytes (state4)))\n\nSubBytes : State -> State\nSubBytes state = [ [ SBox b | b <- row ] | row <- state ]\n\nShiftRows : State -> State\nShiftRows state = [ row <<< i | row <- state | i : [2] <- [0 .. 3] ]\n\nMixColumns : State -> State\nMixColumns state = GF28::matrixMult m state\n    where m = [ [2,3,1,1] >>> i | i : [2] <- [0 .. 3] ]\n\nAddRoundKey : RoundKey -> State -> State\nAddRoundKey w state = w ^ state\n\nRcon : [8] -> [4]GF28\nRcon j = constants @ (j - 1) where\n    constants = [\n        [0x01, 0x00, 0x00, 0x00],\n        [0x02, 0x00, 0x00, 0x00],\n        [0x04, 0x00, 0x00, 0x00],\n        [0x08, 0x00, 0x00, 0x00],\n        [0x10, 0x00, 0x00, 0x00],\n        [0x20, 0x00, 0x00, 0x00],\n        [0x40, 0x00, 0x00, 0x00],\n        [0x80, 0x00, 0x00, 0x00],\n        [0x1b, 0x00, 0x00, 0x00],\n        [0x36, 0x00, 0x00, 0x00]\n    ]\n\nRconIsExponentiation : [8] -> Bit\nproperty RconIsExponentiation j = (1 <= j) && (j <= 10) ==>\n    (Rcon j)@0 == GF28::pow <| x |> (j-1)\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord [a0, a1, a2, a3] = [ SBox a0, SBox a1, SBox a2, SBox a3 ]\n\nkeyExpansion : [32 * Nk] -> [Nr+1]RoundKey\nkeyExpansion key = keys\n  where\n        seed : [Nk][4]GF28\n    seed = split (split key)\n\n        ws : [inf][4]GF28\n    ws = seed # [ nextWord i w_1 w_nk\n       | i    <- [ `Nk ... ]\n       | w_1  <- drop`{Nk-1} ws\n       | w_nk <- ws\n       ]\n\n                nextWord : [8] ->[4]GF28 -> [4]GF28 -> [4]GF28\n    nextWord i w_1 w_nk = w_i where\n            temp =\n                if i % `Nk == 0 then\n          SubWord (RotWord w_1) ^ Rcon (i \/ `Nk)\n                else if (`Nk > 6) && (i % `Nk == 4) then\n          SubWord w_1\n                else w_1\n\n            w_i = w_nk ^ temp\n\n            keys = take `{Nr+1} [ transpose g | g <- split ws ]\n\ninvCipher: KeySchedule -> [128] -> [128]\ninvCipher w ct = stateToMsg final_state   where\n        state0 = AddRoundKey (w @ `Nr) ( msgToState ct)\n        state4 = foldl transform state0 (reverse (w @@ [1 .. (Nr - 1)]))\n        transform state word = InvMixColumns (AddRoundKey word (InvSubBytes (InvShiftRows state)))\n        final_state = AddRoundKey (w @ 0) (InvSubBytes (InvShiftRows (state4)))\n\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> i | row <- state | i : [2] <- [0 .. 3] ]\n\nInvSubBytes : State -> State\nInvSubBytes state = [ [ SBoxInv b | b <- row ] | row <- state ]\n\nInvMixColumns : State -> State\nInvMixColumns state = GF28::matrixMult m state\n    where m = [[0x0e, 0x0b, 0x0d, 0x09] >>> i | i : [2] <- [0 .. 3] ]\n\nsubBytesInverts : State -> Bool\nproperty subBytesInverts s = InvSubBytes (SubBytes s) == s\n\nshiftRowsInverts : State -> Bool\nproperty shiftRowsInverts s = InvShiftRows (ShiftRows s) == s\n\nmixColumnsInverts : State -> Bool\nproperty mixColumnsInverts s = InvMixColumns (MixColumns s) == s\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a module `Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR` with properties asserting that `AES256_CTR::encrypt` and `AES256_CTR::decrypt` match the given NIST AES-256 CTR test vectors for the specified key, initial counter, plaintext, and ciphertext."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR as AES256_CTR\n\nproperty aes256_ctr_encrypt_vector = (AES256_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x601ec313775789a5b7a7f504bbf3d228,\n        0xf443e3ca4d62b59aca84e990cacaf5c5,\n        0x2b0930daa23de94ce87017ba2d84988d,\n        0xdfc9c58db67aada613c2dd08457941a6]\n\nproperty aes256_ctr_decrypt_vector = (AES256_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x601ec313775789a5b7a7f504bbf3d228,\n        0xf443e3ca4d62b59aca84e990cacaf5c5,\n        0x2b0930daa23de94ce87017ba2d84988d,\n        0xdfc9c58db67aada613c2dd08457941a6]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CFB` that imports `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB` and defines properties asserting AES-192 CFB encrypt\/decrypt match given NIST-style test vectors for CFB-1, CFB-8, and CFB-128 modes."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB as AES192_CFB\n\nproperty aes192_cfb1_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b1, 0b1,\n            0b0, 0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1\n        ]\n\nproperty aes192_cfb1_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b1, 0b1,\n            0b0, 0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\nproperty aes192_cfb8_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0xcd, 0xa2, 0x52, 0x1e, 0xf0, 0xa9, 0x05, 0xca, 0x44,\n            0xcd, 0x05, 0x7c, 0xbf, 0x0d, 0x47, 0xa0, 0x67, 0x8a\n        ]\n\nproperty aes192_cfb8_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xcd, 0xa2, 0x52, 0x1e, 0xf0, 0xa9, 0x05, 0xca, 0x44,\n            0xcd, 0x05, 0x7c, 0xbf, 0x0d, 0x47, 0xa0, 0x67, 0x8a\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\nproperty aes192_cfb128_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0xcdc80d6fddf18cab34c25909c99a4174,\n            0x67ce7f7f81173621961a2b70171d3d7a,\n            0x2e1e8a1dd59b88b1c8e60fed1efac4c9,\n            0xc05f9f9ca9834fa042ae8fba584b09ff\n        ]\n\nproperty aes192_cfb128_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv =  0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xcdc80d6fddf18cab34c25909c99a4174,\n            0x67ce7f7f81173621961a2b70171d3d7a,\n            0x2e1e8a1dd59b88b1c8e60fed1efac4c9,\n            0xc05f9f9ca9834fa042ae8fba584b09ff\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CTR that imports Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CTR and defines properties aes128_ctr_encrypt_vector and aes128_ctr_decrypt_vector checking AES-128 CTR encrypt\/decrypt against the given NIST test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CTR as AES128_CTR\n\nproperty aes128_ctr_encrypt_vector = (AES128_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x874d6191b620e3261bef6864990db6ce,\n        0x9806f66b7970fdff8617187bb9fffdff,\n        0x5ae4df3edbd5d35e5b4f09020db03eab,\n        0x1e031dda2fbe03d1792170a0f3009cee]\n\nproperty aes128_ctr_decrypt_vector = (AES128_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x874d6191b620e3261bef6864990db6ce,\n        0x9806f66b7970fdff8617187bb9fffdff,\n        0x5ae4df3edbd5d35e5b4f09020db03eab,\n        0x1e031dda2fbe03d1792170a0f3009cee]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CFB that imports Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CFB and defines properties asserting AES256_CFB::encrypt and AES256_CFB::decrypt match the given AES-256 CFB test vectors for 1-, 8-, and 128-bit segment sizes."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CFB as AES256_CFB\n\nproperty aes256_cfb1_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b0, 0b0,\n            0b0, 0b0, 0b1, 0b0, 0b1, 0b0, 0b0, 0b1\n        ]\n\nproperty aes256_cfb1_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b0, 0b0,\n            0b0, 0b0, 0b1, 0b0, 0b1, 0b0, 0b0, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\nproperty aes256_cfb8_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0xdc, 0x1f, 0x1a, 0x85, 0x20, 0xa6, 0x4d, 0xb5, 0x5f,\n            0xcc, 0x8a, 0xc5, 0x54, 0x84, 0x4e, 0x88, 0x97, 0x00\n        ]\n\nproperty aes256_cfb8_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xdc, 0x1f, 0x1a, 0x85, 0x20, 0xa6, 0x4d, 0xb5, 0x5f,\n            0xcc, 0x8a, 0xc5, 0x54, 0x84, 0x4e, 0x88, 0x97, 0x00\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\nproperty aes256_cfb128_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0xdc7e84bfda79164b7ecd8486985d3860,\n            0x39ffed143b28b1c832113c6331e5407b,\n            0xdf10132415e54b92a13ed0a8267ae2f9,\n            0x75a385741ab9cef82031623d55b1e471\n        ]\n\nproperty aes256_cfb128_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv =  0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xdc7e84bfda79164b7ecd8486985d3860,\n            0x39ffed143b28b1c832113c6331e5407b,\n            0xdf10132415e54b92a13ed0a8267ae2f9,\n            0x75a385741ab9cef82031623d55b1e471\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module that imports AES192_CTR and defines properties aes192_ctr_encrypt_vector and aes192_ctr_decrypt_vector checking that encrypt and decrypt match the given NIST AES-192 CTR test vectors for key, initial counter, plaintext, and ciphertext blocks."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CTR as AES192_CTR\n\nproperty aes192_ctr_encrypt_vector = (AES192_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x1abc932417521ca24f2b0459fe7e6e0b,\n        0x090339ec0aa6faefd5ccc2c6f4ce8e94,\n        0x1e36b26bd1ebc670d1bd1d665620abf7,\n        0x4f78a7f6d29809585a97daec58c6b050]\n\nproperty aes192_ctr_decrypt_vector = (AES192_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x1abc932417521ca24f2b0459fe7e6e0b,\n        0x090339ec0aa6faefd5ccc2c6f4ce8e94,\n        0x1e36b26bd1ebc670d1bd1d665620abf7,\n        0x4f78a7f6d29809585a97daec58c6b050]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module `Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CFB` that imports `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB` and defines properties asserting AES-128 CFB encrypt\/decrypt match the given NIST test vectors for 1-bit, 8-bit, and 128-bit CFB modes."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB as AES128_CFB\n\nproperty aes128_cfb1_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b0, 0b0,\n            0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1, 0b1\n        ]\n\nproperty aes128_cfb1_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b0, 0b0,\n            0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\nproperty aes128_cfb8_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0x3b, 0x79, 0x42, 0x4c, 0x9c, 0x0d, 0xd4, 0x36, 0xba,\n            0xce, 0x9e, 0x0e, 0xd4, 0x58, 0x6a, 0x4f, 0x32, 0xb9\n        ]\n\nproperty aes128_cfb8_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0x3b, 0x79, 0x42, 0x4c, 0x9c, 0x0d, 0xd4, 0x36, 0xba,\n            0xce, 0x9e, 0x0e, 0xd4, 0x58, 0x6a, 0x4f, 0x32, 0xb9\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\nproperty aes128_cfb128_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0x3b3fd92eb72dad20333449f8e83cfb4a,\n            0xc8a64537a0b3a93fcde3cdad9f1ce58b,\n            0x26751f67a3cbb140b1808cf187a4f4df,\n            0xc04b05357c5d1c0eeac4c66f9ff7f2e6\n        ]\n\nproperty aes128_cfb128_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0x3b3fd92eb72dad20333449f8e83cfb4a,\n            0xc8a64537a0b3a93fcde3cdad9f1ce58b,\n            0x26751f67a3cbb140b1808cf187a4f4df,\n            0xc04b05357c5d1c0eeac4c66f9ff7f2e6\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a module `Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CBC` with properties `aes192_cbc_encrypt_vector` and `aes192_cbc_decrypt_vector` that check AES-192 CBC encryption and decryption against these fixed NIST-style key, IV, plaintext, and ciphertext test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CBC as AES192_CBC\n\nproperty aes192_cbc_encrypt_vector = (AES192_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x4f021db243bc633d7178183a9fa071e8,\n        0xb4d9ada9ad7dedf4e5e738763f69145a,\n        0x571b242012fb7ae07fa9baac3df102e0,\n        0x08b0e27988598881d920a9e64f5615cd]\n\nproperty aes192_cbc_decrypt_vector = (AES192_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0x4f021db243bc633d7178183a9fa071e8,\n        0xb4d9ada9ad7dedf4e5e738763f69145a,\n        0x571b242012fb7ae07fa9baac3df102e0,\n        0x08b0e27988598881d920a9e64f5615cd]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CBC` that imports `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CBC` and defines properties `aes256_cbc_encrypt_vector` and `aes256_cbc_decrypt_vector` checking AES-256 CBC against the given NIST test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CBC as AES256_CBC\n\nproperty aes256_cbc_encrypt_vector = (AES256_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0xf58c4c04d6e5f1ba779eabfb5f7bfbd6,\n        0x9cfc4e967edb808d679f777bc6702c7d,\n        0x39f23369a9d9bacfa530e26304231461,\n        0xb2eb05e2c39be9fcda6c19078c6a9d1b]\n\nproperty aes256_cbc_decrypt_vector = (AES256_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0xf58c4c04d6e5f1ba779eabfb5f7bfbd6,\n        0x9cfc4e967edb808d679f777bc6702c7d,\n        0x39f23369a9d9bacfa530e26304231461,\n        0xb2eb05e2c39be9fcda6c19078c6a9d1b]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_KeyWrapPadded_AE.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module that imports AES256_KeyWrap.KWP_AE and defines properties tcId1001 through tcId1100, each asserting that KWP_AE key pt equals the given expected ciphertext for the corresponding test vector."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_KeyWrapPadded_AE where\n\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap\n\ncheck_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct\n\nproperty tcId1001 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x39FA276B26B762599AA1070192987D0CF8184DDB1C98EEA23F06FF81B63481E0\n    pt = 0x8D\n    ct = 0x35A739A8A322805B94DEB3CB1A56A008\n\nproperty tcId1002 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF80E0BDD0D1B3407F241522045574E3C80CA99D3A6854706047942EB694CDBF3\n    pt = 0xC5\n    ct = 0x9581CB7E06C38D57C5262A7BD4BD8840\n\nproperty tcId1003 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC93821958B2A3AC969FFCA59EF5623E609F38585A6C9A9ADE41D546578DE141D\n    pt = 0x1E\n    ct = 0xDD6DC03E825F2E77480F998902FA6BE8\n\nproperty tcId1004 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF6C4018216BC7EAB22D57893BE5E9E3A2A7189813E37D26BFD8A866BADE775F8\n    pt = 0xE3\n    ct = 0x56F07FA0F5512B159F5E70A50C442B0B\n\nproperty tcId1005 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDC426450A27CCAD9B7890661B13480D2225918AAC7C03829512492865763ABDC\n    pt = 0x3F\n    ct = 0x686DE8ABFFBEDF79AAFD4432ECD4CF50\n\nproperty tcId1006 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x44F2DE705C848A3448FF6FFCBD221C0DC2119351D384CE21D5AC2606FE21B6F8\n    pt = 0xDA\n    ct = 0xE4B9BC2CE14293EAF05955A42627269D\n\nproperty tcId1007 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC933E2E4EE7D519FA406AA70EAC833CCD50FBB044427B1D25624254A555EDC43\n    pt = 0x1E\n    ct = 0x901B3CE56E12F8C188039535EBA61996\n\nproperty tcId1008 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x6E0627242E7C51B204DB46A58D6A411B96514555CF8C21DD8B2DC37CDA95F9CD\n    pt = 0x15\n    ct = 0x2AD76F428813B950D099C10105A29FB5\n\nproperty tcId1009 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1FD3508E9533EC697E4B8F59FFFE4B98857919A4DEF918426D068F70F3B2948E\n    pt = 0x02\n    ct = 0x530967E906FD940C887A6AD9F37AC42D\n\nproperty tcId1010 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x85BFD16F7B562AD251329106A3D7A184C5C96CCE489B2DD797A084A72404376D\n    pt = 0x94\n    ct = 0xEFC758A879A703D39B7B85F7BB7B2D44\n\nproperty tcId1011 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDDD6FAB4C49DD7FF2985AE928BD5EA87CC70A31163074F1FB1BC02F7F969D418\n    pt = 0x86\n    ct = 0xBD96D9C865A87BE05A306AB3D6BBA3A5\n\nproperty tcId1012 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDA37F25B6EBE88C9DB9E03A5E126D5AE55F632B1686115C956228326A0DBC789\n    pt = 0xA9\n    ct = 0xAC58CFA83697E911CD09BEA23CA4CD45\n\nproperty tcId1013 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1BB566FE462A27901D86EEF8558F53E505E47D81A66F2918AADE08EA347201B3\n    pt = 0x1D\n    ct = 0x8A51E6B709CB04F59981F7FFDB783D0B\n\nproperty tcId1014 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x73B2AB98DDC2A3557AC51C1976D43F2997D4305D6C1D8DE38B393161DE44A1BA\n    pt = 0x54\n    ct = 0x281900A08220B5F74CF06D739F7C5DC6\n\nproperty tcId1015 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCACF12AE11477B1254437CA92D329F1C7EE6B2C022E4F12C3EAC649621AB0137\n    pt = 0xE2\n    ct = 0x6DCC8657EC2A2443DD056EF73DBBFB7B\n\nproperty tcId1016 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3E7517AE08DA6B2B027AC829D0D96FB0D2B27C611D217174FFF385EEA51ABC9F\n    pt = 0x7E\n    ct = 0x542A995D5BEB0FEF0CA3B56DB914E0DF\n\nproperty tcId1017 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x636062EAF492C67B4E98DC4653031942CE29FB1B81462A31FCA2A40DF760ED1F\n    pt = 0x9C\n    ct = 0x9F24ED46467485D4ED54D232E50E8885\n\nproperty tcId1018 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x86CF07CC35A7624129A9390B14EE6FA8B8D7A9F613050E7CE3E3AF3CAD54ABB3\n    pt = 0x75\n    ct = 0x76A00B69214577BAD18CCDC983C8BAFD\n\nproperty tcId1019 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC4C825E849AE1C195748979D8821711590403E3AC47984C526DF896D120E7396\n    pt = 0x9E\n    ct = 0x5808672A0F4EEDD81328D99819993EB7\n\nproperty tcId1020 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFF84BC98909D273B28F0AC9D0C44386533BFE6A0586294D57DF370FFECCDDB3F\n    pt = 0xC9\n    ct = 0xDA9785C2ADC2CE92EFF5E3523D469235\n\nproperty tcId1021 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x8670FB10B54781839B56C7A14C660412FE2E48F3655ACC55553B794D9FFA32B7\n    pt = 0xF0\n    ct = 0x8850EF6CB7396E775D4F330C6E01EDCE\n\nproperty tcId1022 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x211A909A1C1B0F56BEBBF3362DC2CD75AB14BB2CB4EB191557B5ABAC7EF9E4E4\n    pt = 0x19\n    ct = 0xC76400B498AEB0023E266AFF9EE30FE8\n\nproperty tcId1023 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xB77EBA3E4E1FD9D5989A233E66BFC9CBB8CF245C9DCF7C59AF1D5FDD4811D76A\n    pt = 0xC0\n    ct = 0xC8869A194252053D69CB3700B519B400\n\nproperty tcId1024 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x96A325D96DF23193F21C409B20B83B157E4BC00E7B872A96D57EA7791575B797\n    pt = 0x60\n    ct = 0x9C5C1DCBFE8CEA38DED462DC2268D090\n\nproperty tcId1025 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x67BA246D02CBBBEDDE0B24C8DD8EE9ECF80DC34ECF0A211B1967BC141265F099\n    pt = 0x00\n    ct = 0x38AE876F1E45933C75D8B57531B59075\n\nproperty tcId1026 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x81C3403F359326663B025C16865E245808C4848A54011F6B88385A1A64FBECBC\n    pt = 0xC2\n    ct = 0x8C0DEC2FD4B6AB0231EC56BD50852D84\n\nproperty tcId1027 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x428666365FFAE2B604A71E3EA61D1AB85CFCDEDEF5D40CFE8E53FDB96AC27630\n    pt = 0x1D\n    ct = 0x48D46E384AE3AA2BDCEC10399A82BE37\n\nproperty tcId1028 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x859857F302D7B4BECF1220B55857A1DF064355AB306E9E9C3FEC3DC86FAFCC3A\n    pt = 0x91\n    ct = 0x7E0CF4C530ED36B947CA4C5D7DE0097A\n\nproperty tcId1029 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFC304BE2EBA8E1CD41680F2228E150718D829821F99994AC44D59C7494BDB6A8\n    pt = 0xC2\n    ct = 0xF125384DEE677C7923697F5A3BFC6184\n\nproperty tcId1030 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5D124C781D08A9A1EF74B9BFC5B92C093F47B6C20E566B12ECBC361813688F01\n    pt = 0x3D\n    ct = 0x8435A5CB88740BADEC2C57FE0BBA0DA8\n\nproperty tcId1031 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xAA5AB62D3DF457E141F244ECB7A1B02B7C849535F6114EE43FE5474FA7934D3E\n    pt = 0x19\n    ct = 0xF3E526B2D27DCAE85E3B603219079B17\n\nproperty tcId1032 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B2B4903C7F4FEBFE9600D357C043E891BC2659AA21694810AD9DF8DE2C5D87B\n    pt = 0x7F\n    ct = 0x9AE5B26B28514B2E02866F655689D8A2\n\nproperty tcId1033 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B7572593C032234A0047A9D2A92E9F7323226FD9879B8F8BF73631C16560922\n    pt = 0x5E\n    ct = 0x2E94CB8DFFCDA2399BC422B24928A91A\n\nproperty tcId1034 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x68380612EB8E22DC776E8D05BE01B619D0C1CB99EBC7947C8444CB26FEAC0E91\n    pt = 0xBB\n    ct = 0xAA6ABD32EA59851AFE3AD836727E5DC6\n\nproperty tcId1035 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xED0580C7DAB265D63DCCFEB165778BA3ADCC9C92D807B0DA7D08F05A2D1E0EF1\n    pt = 0xAB\n    ct = 0xC3DC9EA6773BA6B254156BCA2D6CCDC4\n\nproperty tcId1036 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x512E2D54D84820280EFEC1286247D6A17DC5A23F33FC1C32D5A023D38EE43B8E\n    pt = 0xF5\n    ct = 0x4E50FAEF7FEDF00A97744D1E50180D29\n\nproperty tcId1037 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCDDD9A61EE554E27E75D9D2A6905763363ABFDA1A2E0D1351CFAC3B870E72AB7\n    pt = 0x9C\n    ct = 0x13865E5DA697B608016326560370FC34\n\nproperty tcId1038 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xBCDA299791DF47EFEFA436000A4234F9F1DDB2959F7F5CECD7D114DA1555DF39\n    pt = 0x23\n    ct = 0x957A898CF5CA014FA0BC445FA0411B8E\n\nproperty tcId1039 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x14AC4E2D21736EDCC6D423E3AF1E2BC4E8115A9C190AFD7C5A764CB7FDEFE222\n    pt = 0x27\n    ct = 0x47F8738AE025CB323AA904BB8FC94D5A\n\nproperty tcId1040 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD780739A8A8F203E593DFA988C4BEDDAD17EC65E32FF9420E8B7B094AD3504CE\n    pt = 0xA4\n    ct = 0x0ACA7980AA5D91E7CF8A7FF32ACFB820\n\nproperty tcId1041 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFE9E71CE3F0372783D47D1219919A9176DBBA7E1E7BB0E6BD94599DA51F616EA\n    pt = 0x18\n    ct = 0x4BEF98A1A912C5CCFB44398501393A5B\n\nproperty tcId1042 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD067989158B5C486D6CB2317DC4A1F174EDA232A5D0572313666B602F80FAA82\n    pt = 0x87\n    ct = 0x1622F42C6EB932C9C3BA6EE528F5EE2E\n\nproperty tcId1043 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF08EAD0CDBBCC69EF06549FAED6989E5177678A31CDE24081E962C06F80DFFF1\n    pt = 0xB6\n    ct = 0xA164FE1AAC233A7B292190106242BC35\n\nproperty tcId1044 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x6FFA0B069567D8B8CF189E1E651126E16432F4B1DF14D28C7930F167D90E71DC\n    pt = 0xBC\n    ct = 0x81AF399406890408830494067B975DC3\n\nproperty tcId1045 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF0D9A00431BFC37776632DCE8392FB668738B8E7E87B32FE6970AEDE141DBB12\n    pt = 0x15\n    ct = 0x21A2E83460738D67E274DE0231F5DB08\n\nproperty tcId1046 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x8758E274D03DE0037EB638671BF7A5762262CD81FA4710612F0F8C00DD544FD2\n    pt = 0x10\n    ct = 0xB58EF1C43EF4FB8D25C53D673C074A9F\n\nproperty tcId1047 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x611CB910E6F3554891709BE3269311CAEEA4167646770C93B1EB24150B08E7FF\n    pt = 0xAE\n    ct = 0xC4D38071B0325A7DBAE7B8C97E140567\n\nproperty tcId1048 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x595D643FEE1B9DA657E5E0DD89BEA95FBA9D60A9F569E5BD2263ECDA865B6397\n    pt = 0x8A\n    ct = 0x291C122B76FF48EB7A9B1A25C20FF3E9\n\nproperty tcId1049 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF66827A982352FB10D7BD294A6DA6661B9593E850D9AEE8C7E2C2F0662B66609\n    pt = 0x1A\n    ct = 0x8320E7CDE94090DDB0AFA279F71CF86C\n\nproperty tcId1050 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x927B27D5B50BA9D198E9EECD1317FD659A80F9E061A2703E797B61D420C7164D\n    pt = 0x62\n    ct = 0xEF84DE1F6C508958F7ADC6D11C606DB8\n\nproperty tcId1051 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF416A4C6552B4E2E2D5F88C6AF5494C4EA1D04BB22A377C0806611418475F1F8\n    pt = 0x10\n    ct = 0x562ADB01EA14439CE1D8A6FBA46515F4\n\nproperty tcId1052 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x42EE175CB7A7F28620500AE8856C7CDE3C4052FBA5ABF91C9E91E20857AF5066\n    pt = 0x29\n    ct = 0xB5465699DD3DC2969DCF8B1DA3C0DFCC\n\nproperty tcId1053 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD9C652FA5E6A16E51DC513B53AFBC7E6624B8C3E4E3C58CD223320228EEE5DFD\n    pt = 0x55\n    ct = 0x0AD61A07DB5EC915C16F1A320BF0EAED\n\nproperty tcId1054 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x070FDEE3C8E60C382E9EFB3E61AD9B84620F2513F25DE9A535C344774F14BBC0\n    pt = 0xA4\n    ct = 0x906B0FA922E825B9375863FCA511B446\n\nproperty tcId1055 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x965B12BA6F405A1C99A702AC08084090FD80854BF5C09D00D1CBF8020E1FC853\n    pt = 0xEE\n    ct = 0x338C2D6EF2A4F0215F32117A6999E2FE\n\nproperty tcId1056 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x16E8974B487171A030AB25FE03E5789772A2A91E4FBBEFA62A2C3957AC69DAC3\n    pt = 0x51\n    ct = 0xFE89DB7AB88A6A50DBC7B4BBFD7C7D19\n\nproperty tcId1057 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9A729225A773F82968D4E4A61F67F7FEFA1C1EB951506220D2B44FB4EF06C54A\n    pt = 0xFD\n    ct = 0xBC7ED8E326F929CD1CF2939519972DB5\n\nproperty tcId1058 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x41472533F605B84462AD4C8FD062FC9B24B9EE7EBA935D0ECA424D2AB503DEF8\n    pt = 0xF9\n    ct = 0x32746F33EC7A049B4A3C48BD0ED21CE8\n\nproperty tcId1059 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x80F14DD8F5F9EF689A6840363AD88F58DE0EDCDB74700BA33A7DD923FDCB5DAD\n    pt = 0x29\n    ct = 0xF34CACF3816972C90A4AF0E67E7AED85\n\nproperty tcId1060 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xBD62F4F0449F892825008928D877A7543FADFAD05D3877033FFBD343EB83E622\n    pt = 0xD7\n    ct = 0x54F7EF87C184A81009EBF9BF6688CD7C\n\nproperty tcId1061 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x44D2B78F5FD38A5F681DA45F2FD177AFC122B7E780BB516AF29D928F3A17DAF5\n    pt = 0xD2\n    ct = 0x286F752B981CE6847661E0DCDD4D5F49\n\nproperty tcId1062 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x19556188E0349531F56D4144DAD2E5E0F6FFD349E017EFD31A05DB09291ED515\n    pt = 0xEF\n    ct = 0xE6DFA16F00FA7241F84E614649045B40\n\nproperty tcId1063 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC2DF0F8EC128AC630349FA9E452A2A8A10B500E00B9524E146518780EE62B117\n    pt = 0x81\n    ct = 0xDF68CB42ED2761D74BEBCE73E590A4DF\n\nproperty tcId1064 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x4E88503C08AD7EF21832B200F39489D3C5457CDB45912DAA380A6DF414B125C8\n    pt = 0x2D\n    ct = 0x52D5A548C2E4D287DCAAFE03E016AD79\n\nproperty tcId1065 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xA45AFB02BF762298F315E033B04325127E9DC8F237261DDB114D384B44571929\n    pt = 0x42\n    ct = 0xCD487595DFE7F933FEF5B10587AC8981\n\nproperty tcId1066 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x7FB2623EBF05DBAEBD5122920E97DFFF06F57C838DA933538C97FAD59E25EB8A\n    pt = 0x77\n    ct = 0x8A5F782FBED1132D0636F53A51CDBF79\n\nproperty tcId1067 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x150F4FB634BAC25DE6992583F54DD734173E93AB43F63594832D9287778AD0EE\n    pt = 0x7A\n    ct = 0x799C8243EF5EF87891E005B506BF2F64\n\nproperty tcId1068 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B6CF52B74C43964097B6E38D37E01D673FB71F23C3329581F6409D8ED32A16E\n    pt = 0x4D\n    ct = 0xF293CE2D1F9C6725E1F9F107421AC396\n\nproperty tcId1069 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2644CCF9D7C419A437C954C8141CBB2D60F57DE10A5393554A14CCC72229E286\n    pt = 0xE0\n    ct = 0xDA510B1D9A10255380655980A3A73536\n\nproperty tcId1070 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5A2BF1A5098964EEC4D82F7E7C2D5723A5777F202E5CF729B506A5DC9775F1DE\n    pt = 0x11\n    ct = 0x19B164EFC41F5FFF402A1097CD89259C\n\nproperty tcId1071 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9B35B7F2AB8EEBA30101BC8D0BF94B09C8EA02114ED9912F7659967DC3C7D841\n    pt = 0x71\n    ct = 0xC788AB3CE96444554BBA805A1E3A8F91\n\nproperty tcId1072 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B7783AD07911FC6D685E60FCB1213EDFF5DCD7EAC1D73DA2685585AE4C39177\n    pt = 0x3E\n    ct = 0x0EA7AB3B26CDA9612A508EF9B41DB7C8\n\nproperty tcId1073 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFB56787EC73A1EED0C9061D023A305AC301E2455E349B2E573F2AFE326709ADD\n    pt = 0xC1\n    ct = 0x2C713F375FDD12469E753C68BAEAC6D4\n\nproperty tcId1074 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1AC45D1DB5E960DECD86AEA2507F1CD51EAC9BD3EA8B6093D4A795EFCA7187B0\n    pt = 0x73\n    ct = 0x24B65C239B23D8C8F44EC2721ED03B15\n\nproperty tcId1075 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDE8A1521277486D6FCDA3A24031DEE8647344F88A051A4DA7F452A7036DAA8C0\n    pt = 0x5E\n    ct = 0x708D55D92DB692A62CBA3CA4D009C8CE\n\nproperty tcId1076 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xA66E6DA21D52FC24733C303A121AD10626A5194884054CF8B73E7A71AA49380B\n    pt = 0xD3\n    ct = 0x7AD507B5FA5CD4A98C797A8DD824923F\n\nproperty tcId1077 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCC3710FD1C78A8B019AE0E8608E5C60F614D1F043196A3D87A67074A267B5542\n    pt = 0x02\n    ct = 0xF02A71952C7F74D6F509D0DA905B5E44\n\nproperty tcId1078 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x371EEFF5ACEC4E980CA59E9D91BEBF9B1B8013B3340BC45D624F0AA0943118DA\n    pt = 0x74\n    ct = 0x7BD179C985A426CD4FF9BFBEF858436E\n\nproperty tcId1079 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x54D9324535DAC6090439406626141312CB4A61ADC61189947D5572FBD326CB57\n    pt = 0x7F\n    ct = 0xFF0061FC09D685215C4B22BE822405FD\n\nproperty tcId1080 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3EA9325069ED93A96C331BDD6DD766EC64BBBA83A72C69ED75DF55043FB0BFD1\n    pt = 0x06\n    ct = 0x40A9C42012BA38211B800E6E313B6876\n\nproperty tcId1081 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2C0CD8480E0768FB9E33A9929F3991A0DE0B0AC1F35D0CB7E58757A9D28D49D4\n    pt = 0x06\n    ct = 0xCADAD5CFD536F7BA6897EF398483F38F\n\nproperty tcId1082 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2BB319F216DBBA31EB4BB3265FF85D13ABD8B12083DC0CD48C40372C946F70D5\n    pt = 0xE5\n    ct = 0x85427703FBC3BE25BE88765DC8791554\n\nproperty tcId1083 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD393149C58FDB23C4ABDF43EE03D603DEB1FD06CD625F821FF93B27376458C9E\n    pt = 0x1B\n    ct = 0x3D737A3A014ABDDA0BE2696C8097EE95\n\nproperty tcId1084 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x03353DEAB5D9CD40338E8ECC8D810DE4E29B6D34CF158F68DB5AE356A4225266\n    pt = 0x8D\n    ct = 0x9313D7D59E08024181C2146F9123A78F\n\nproperty tcId1085 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x0CFD3A3B0540E5B3F044EB60050FEAFC80BAC758DB99016F79F0F5BF80307779\n    pt = 0xFC\n    ct = 0x02EC669FB26BDCDCC398545D7BDBDEC7\n\nproperty tcId1086 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x4CBC12CEE939C4F915DAE23A4B6F30B8B45734686067B27BF592BCF929C7E75E\n    pt = 0x34\n    ct = 0x5965D7F3EE0A4940BADDDFFA05A30BF4\n\nproperty tcId1087 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1BAD340ABB934070C9B7662815BB7BAA652A056CCF246A375B6D959ADD5D7DEC\n    pt = 0x2A\n    ct = 0xEED916D3195F9C39406802285CA665D3\n\nproperty tcId1088 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xB0D6764B9B604A44D6A201A07E1F3CFCD0DA1A322DAA1251EFA19C12A8488D0E\n    pt = 0x8A\n    ct = 0xFE2A001CB35F00EAF85614EC594E2D9F\n\nproperty tcId1089 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x59BB9A295C7263842521D5F1EDD2DB92D9F09A607F758E2E3EF8CA6137616C93\n    pt = 0xB0\n    ct = 0x4AE1CF2A3BBD5BC2573D8A13212E445A\n\nproperty tcId1090 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x07E0C27A362DFB87EDE1B5E0A1790FA3FB09A99E12A6A71EB0A41B6356C9CC92\n    pt = 0xAC\n    ct = 0x70D749E0C9C77A0EDD98F8BCE3753733\n\nproperty tcId1091 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x50E530EF3EB1A1BAE45B8263BA7E30F6F5A7D2418F3611E30830C87D741647CD\n    pt = 0xFB\n    ct = 0x4FAA8357F2F3EF340A5E8B7AA74DD290\n\nproperty tcId1092 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xE1DE28540953AAF2AFB9EEF0DDBD08B5A1AAB73EECDD2F0E85F8915C94699E4A\n    pt = 0x17\n    ct = 0xC686DC8FE198F9D36374F5C56B99E3DF\n\nproperty tcId1093 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFBDCABF978959C69724C63165A17DB5F1FA7FC2871F9BDFC799391C908F78F6C\n    pt = 0xC8\n    ct = 0xB6B5D8288DAFE8F8584514B5193EEEFE\n\nproperty tcId1094 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x417887E598A05E102E6C651F6900C22412DEB49140585A650DECA9B1BA211B1E\n    pt = 0x72\n    ct = 0x5B0B9FAB5479528F87EB3C91225BB64D\n\nproperty tcId1095 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3BDBA3053CC76471EA0D78531BBA04A9584995BE194A348185698FE4D1338BBE\n    pt = 0xFA\n    ct = 0xF56924CE90ED7C0A79B8CAA4101D1DBC\n\nproperty tcId1096 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9DDFEA3DA8FF9F5401D5BDBBE520E4D47263E5B268BB15DC6FD62939FFA49377\n    pt = 0x58\n    ct = 0x01F0962438250AAEEDF8069D7CFD1F95\n\nproperty tcId1097 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x59DE802DC7805F487E4537941C71A24317B585BD58CC1FF9B5AC18FFA78E74A3\n    pt = 0x0E\n    ct = 0x2B7E6ACDA4967F644662A58CE8077917\n\nproperty tcId1098 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x35F2322E2999AAA3BEBA5E33A237E9D84DF0DA5BB732370AAEF97316F78DD413\n    pt = 0x1E\n    ct = 0x8A4DBD736974C2E73DD27C5E47955D94\n\nproperty tcId1099 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x45D780CFD96B54CF1AB425FAA701645B0FC5F84AA385B1372771BD7AD6109F0F\n    pt = 0xFC\n    ct = 0xA2E47585D0D8F81BA155324417EC2571\n\nproperty tcId1100 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDF9F0529DBBABA0D2A925AD2E0B81E01A0386DFC2033D3D6D446845957C02A15\n    pt = 0x0A\n    ct = 0xF6B6398CA55ACE0222A9391FD81CD276\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CBC that imports Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CBC and defines properties aes128_cbc_encrypt_vector and aes128_cbc_decrypt_vector checking AES-128 CBC against the given NIST test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CBC as AES128_CBC\n\nproperty aes128_cbc_encrypt_vector = (AES128_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x7649abac8119b246cee98e9b12e9197d,\n        0x5086cb9b507219ee95db113a917678b2,\n        0x73bed6b8e3c1743b7116e69e22229516,\n        0x3ff1caa1681fac09120eca307586e1a7]\n\nproperty aes128_cbc_decrypt_vector = (AES128_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0x7649abac8119b246cee98e9b12e9197d,\n        0x5086cb9b507219ee95db113a917678b2,\n        0x73bed6b8e3c1743b7116e69e22229516,\n        0x3ff1caa1681fac09120eca307586e1a7]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_KeyWrapPadded_AD.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module `Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_KeyWrapPadded_AD` that imports `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap` and defines properties tcId3401\u2013tcId3500 checking that `check_KWP_AD key pt ct` matches the expected boolean result for given AES-256 key-wrap-with-padding associated-data test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_KeyWrapPadded_AD where\n\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap\n\ncheck_KWP_AD key pt ct = case KWP_AD key ct of\n    Some pt' -> pt == pt'\n    None -> False\n\nproperty tcId3401 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1C8AB00037582D4E850D92E4244B6229D1FA54D6A0B1D1B71D43C0E45C544A18\n    pt = 0x3E\n    ct = 0x4358AA665202E40D725B01FEB065AABF\n\nproperty tcId3402 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA2423B2160857B73A2ED23C995F8374B7DFB2BA458B781131CF7DC4A5B370669\n    pt = 0x44\n    ct = 0x581BA83958B7528436CF9EA163E4873F\n\nproperty tcId3403 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x084D092899BC5F76288CFD7C45C336380BD2D768C98C5144B20D5612CA9CF598\n    pt = 0x59\n    ct = 0xC1B83872E7B0FC48156A06154219A608\n\nproperty tcId3404 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x518594C8D42412C9EDFB1E17E821B37DA0A020CAF4620FF2298AF4254EA0CFB3\n    pt = 0xB8\n    ct = 0x74C938C320B03451ED58DE73BFCAEE25\n\nproperty tcId3405 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x7F45132EE8CD57D9EADB90F15506D716311F2A226CB38D545F5BA4A76E065C90\n    pt = 0xAF\n    ct = 0x43AD1FAC8D9A4878414BC5D224856FC2\n\nproperty tcId3406 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x37839C73459186707F2C53440AA3E7A294A52481C6A8E72BF8FF44A61DC3C94A\n    pt = 0x3B\n    ct = 0x670DDA784A6F7B8629CC487125D83D82\n\nproperty tcId3407 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x699A20B3FED880092AC54A072D0F1944E5AC618E89BF6D82D85B8149409E0A69\n    pt = 0xC7\n    ct = 0xDA945A1E4ADD229EA2628BD2CBF648C5\n\nproperty tcId3408 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF39BBB0C6D6A48FFCD19A8E4FF8EC4D18DB342984D56204A72CC79EA4D331527\n    pt = 0x13\n    ct = 0x731375F0AAAE126D698A3A35C1B59BB4\n\nproperty tcId3409 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x2CC17C155EAED98EE7C5C988A4652BBC1E548D83E355EF2B9CAAB553E33248D1\n    pt = 0xE8\n    ct = 0x9ACE37E97BF83606F87F2C37F2DD0495\n\nproperty tcId3410 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x6EC1F03FE2E913911497B56C997AA18573FADAF5D3D40B5C3AE20C122D57CA26\n    pt = 0x0F\n    ct = 0x9EA3A713894A9A60EC886F994F6E6964\n\nproperty tcId3411 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x222373119D81095C1EA6BC266B7BAC7CC5338B183491E464517F6A1CEE323D72\n    pt = 0x24\n    ct = 0xC4684B34339464E99D38883F4E218D43\n\nproperty tcId3412 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x0E16E4ED5AE9010E977FC718B0A196D05C4EC8CC03881E9498798221CEEF4F60\n    pt = 0x59\n    ct = 0x45E26A81F2A3F3B36F6A1DFD5794339E\n\nproperty tcId3413 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF7C0B2E09007A87A2C6C02F547AE13D315D9F40E8432E2883EBAAD360AE58154\n    pt = 0x28\n    ct = 0xC6EADFAE6689D612BD7720A5FFDF6917\n\nproperty tcId3414 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1E094BFD3FD9FA39528B0A041943F26A146E1B6FFA9B89DBB3F3629E248786B3\n    pt = 0xD9\n    ct = 0x5900AC3014005CD4CB5B58D464D77851\n\nproperty tcId3415 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x2D72DDE845897E8DD914977D23B9C53A3C682F5322923F609786C0DEC4B9B391\n    pt = 0xF7\n    ct = 0x6F26295442B138B9B8559BDF24559292\n\nproperty tcId3416 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD4E74B1FB2D1B8A3A96D69484A3C14D6DAADCAAE26CF0D8C69FE1FF48FFCE55B\n    pt = 0x50\n    ct = 0x8E584B2DE61B3A7408E9CA039A5A2D3F\n\nproperty tcId3417 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8D2E8DC1019C058E0120F7BD454FEB9D2A0CF49C476215D9E1B36EBE31AA8E60\n    pt = 0xF6\n    ct = 0x89EE6AD335AB813F688EA34856C6CC62\n\nproperty tcId3418 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9EF5DA6F8AFEE4EC25A39C0BF3B4661CE1E60F4A08562803F9DAF43C1F5D901C\n    pt = 0x9D\n    ct = 0xF0B50CF34D7E9846BF0C63BC22C132C9\n\nproperty tcId3419 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x163668F7B7DEF32970EB681A9D9CBA20DD3612E48272C7F4ABB2BF32A6F07EC2\n    pt = 0x67\n    ct = 0x1CD75C122ECFBE1519FCC8266FD5BFBA\n\nproperty tcId3420 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8AAC75606AE5DD234EA1D037B220F89AE202BD465CC96CDC629D3AAF663D1811\n    pt = 0xFA\n    ct = 0x62845E954748CE3D22BC3DD347FCFF34\n\nproperty tcId3421 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xE46BBE8227B15C9F7EBC941D324D61A6D4539EE8557989F5D2B05F6EC9247238\n    pt = 0xBE\n    ct = 0xB26924971CA3A0593AD2D41330728677\n\nproperty tcId3422 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD541DD6C55C182DAE396180557E1527405E64C76072491162AEF584C3A723B8E\n    pt = 0x93\n    ct = 0x0ECF1EB9E9FC1A1B1F4061A2C6D8CB5E\n\nproperty tcId3423 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x448042C7E69DE6CD177324D07AA2B074F4914CCADF38E9BA241B847BFBE6A048\n    pt = 0xF8\n    ct = 0x5B16E3D2E4EB040700929EB1F3293826\n\nproperty tcId3424 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xE2FF9378361B637A9C7AB7991232E5C4E450F3F1884B99B32B35F3E483C63F02\n    pt = 0xC1\n    ct = 0x9694370FC567B3CCA1BF96BBC77F2924\n\nproperty tcId3425 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x71F1B8D033B2763D24C824BBC5C7B90F7465312EE68499AEB13936C6820D2DB8\n    pt = 0x41\n    ct = 0xEB1742979FF0D05DDA7A9AA4BC44A3DC\n\nproperty tcId3426 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x5B5D5403DC5F79CD612CE5BE434CDCB0CEF22A431BFFA8DFD03A40496867F36F\n    pt = 0x2A\n    ct = 0xEEF7F7FBA12F09C0E000D7DF78C3B7A7\n\nproperty tcId3427 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x4B6860891760551B1796F7EA2867B5F72CD55158751CECCDD07466B358E5DC2C\n    pt = 0x37\n    ct = 0xFC4728851CB09569B9C09F0DD974FC46\n\nproperty tcId3428 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8CC592A0827016D33FAC7046043CBA05F0F6D52360A131B68BB5CF3473D493E2\n    pt = 0xE9\n    ct = 0x6C4DA849D0312D2C1969F763FB0717EE\n\nproperty tcId3429 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA822410F60C3155AA4612A0A3D69FB6ABAE9CCCE764C45F0715167D4A29F92CC\n    pt = 0x60\n    ct = 0xFD4C6C336BF8189A6578C5D18755332D\n\nproperty tcId3430 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x4887BDA1567FA98C9E6C54A4C40ED9910888F0BB2F3092A990DD15A9FAF514E4\n    pt = 0xA1\n    ct = 0x6E8E313899901A660F45BE923325B3A0\n\nproperty tcId3431 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA34A8ACD5DE1D09B06C68A4BA6B26AD8849A96D097F7234CD87D0B22A77F64A1\n    pt = 0xF0\n    ct = 0x51A1D5CBBE044436F8E30F5EB9760A99\n\nproperty tcId3432 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA91FB46F7AE95553194F72BDE2DEC9C75CBE6F5D5CDA19CAE8DFEF10D2091878\n    pt = 0x49\n    ct = 0xAD8B08BC99A15AD1F61A534E6A6FD912\n\nproperty tcId3433 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBD31DE22B62709C3ADAE6A22C110AF041692A2EFF5AFD94D6F084A5AF7A10BA1\n    pt = 0x12\n    ct = 0xEA18D84DDEACDBFE6308356BD337389E\n\nproperty tcId3434 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xAAA495706CD217702F6589F3A7DCF77796EB9AD9301DACB70679353895821116\n    pt = 0x98\n    ct = 0x570F464452070AB993FDBA098413FA2E\n\nproperty tcId3435 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA6D1836D8FC15DC6655A6AF3C9908D1A458115DE813874DA2A31BAF535F4B898\n    pt = 0xC4\n    ct = 0x52BDFE3157F7E5320FA33902FFE86D9C\n\nproperty tcId3436 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9A372C3FE4AA3D244D7A31F26BE0DC94321AE6A9D399A3024DF1D2FAE01F5D5A\n    pt = 0xA3\n    ct = 0x74785BCEB51BB5BBBF237D204DF5DC3D\n\nproperty tcId3437 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x18EDF67DCED65DB1106F9E95F6E9CA0BCCDDB9C1B0704800E79288B4348D5ED8\n    pt = 0x97\n    ct = 0x53A16352DC6466B129B98EB20E871CB2\n\nproperty tcId3438 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xCA6909990051E5A00B321DB36E9EDC37C21517D05412C27308FA6230B194F3D6\n    pt = 0x8C\n    ct = 0xFA3388CC18FE4DB12B286D78A88F43CE\n\nproperty tcId3439 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x53D9C10A1F2A520C799E17CA84A9F37B7E41C8A8366A0999E6C640B9084F8D89\n    pt = 0xA7\n    ct = 0xCD7DA687F90A8E5B5A8D752383E2A921\n\nproperty tcId3440 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x40DA3BF159117B28AF81C41329BEA2446B47BBA5AA3CFED9C9B6D0FCAC447A26\n    pt = 0xBB\n    ct = 0xB3EB65346F8509E074B4340B225748AF\n\nproperty tcId3441 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xCFD6EACDFE41A0716399AAD812A5904F43E46E94C8F33551244107CBD4454630\n    pt = 0x86\n    ct = 0xEF426FD61C094CB99E553FA242B35BC5\n\nproperty tcId3442 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFEEACB41470DF0A95D4D17413575ECBE4473501166E2B253AC69B769D1DE6EE4\n    pt = 0xD5\n    ct = 0x3B6CE49140A31C29E2B57082556D4655\n\nproperty tcId3443 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC37E571FA0B30A4C320000E46DE47D739D71E958E6D9B5BF165891FD76A2EB69\n    pt = 0x7F\n    ct = 0xCA0BD69463B6FE257339A6F352C383B7\n\nproperty tcId3444 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0xBF4D98E63641C3B0C6C87F94FFADD24E9447DAE3C8179057B992F3E87ABB9371\n    pt = 0x77\n    ct = 0x8C309F22B1A69A82FC959024D9A41055\n\nproperty tcId3445 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xB340E2147C24AA9245D32B44D81932486162078E04E8D604C3BEC77E80D00587\n    pt = 0x9F\n    ct = 0x08E763DE0E9BDB77652BE9F239E76C3A\n\nproperty tcId3446 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x64CC83AE40375F36DF9EFA92623952D9B921C193A303BA44EAF249173E75346A\n    pt = 0x2B\n    ct = 0x96249FF04AE658C774BB76543946F1A7\n\nproperty tcId3447 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xDBB7B9A24F84518CDF7BE4204966A4A82C14F1DF9D3EED53B85BAF4110D2E5A7\n    pt = 0x00\n    ct = 0xBED6EBF099BF397B9CEEE98862B02A82\n\nproperty tcId3448 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x7A07B0AA1E991FC058CF99123C3797A5088331724452A8E6C866456B88700E4E\n    pt = 0xAA\n    ct = 0x0D8879321C745BC971154AE83455FEBF\n\nproperty tcId3449 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x7F9D0A3C5A5778247C91729D9067A522DCBC440B40EABF50E2501C55AD2924F8\n    pt = 0x72\n    ct = 0x22FD8008FA349050267F2C690218E766\n\nproperty tcId3450 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x5E804B2481BC5FBE520F8039375C018037E3BBAECB2249700CCA6A7BD7AA5717\n    pt = 0x2C\n    ct = 0xA75D5317E32EC6AE64F52BDEDF66DF44\n\nproperty tcId3451 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x5C7BA7305D3B4F81FEC1C53743F8C303CB060E9F8CCE92F33653485C1AEF6DB6\n    pt = 0xD2\n    ct = 0x0BEDF4F707D2D7B9703934FDAAD3FEFD\n\nproperty tcId3452 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFB590D85CC2E6666135A6317F8464F3BE2657532F9CD34823C8F9CDD22547223\n    pt = 0xAB\n    ct = 0xB0CBDD6BF81C0518EFAC69E74A5BAEF3\n\nproperty tcId3453 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9FEDC13CB212B80795956FDE94F420032F24C8EAEAD55A5293316FADFCC633C5\n    pt = 0x77\n    ct = 0x7DD4C22110BFE0530FC441F53518F9D1\n\nproperty tcId3454 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x95AC358D0BB126E90D6F604B30129A2B7D830F479C759F3D53CF4C6F998D2117\n    pt = 0x2E\n    ct = 0xCC42D7BD7EC583B5CA43C0BB3B449144\n\nproperty tcId3455 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF7D14A80AA1CB08AEA6CF77961555983FD09F50FE37E3E99F9B521AB0742840F\n    pt = 0x0A\n    ct = 0xF5A1CC956791996B6D0273D8E206E59D\n\nproperty tcId3456 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBDD2F02BD33BE2B9B035B0D7CC3A284979AF20C8DD4FE8EE60DCEFDEF4381813\n    pt = 0xEE\n    ct = 0xECF28482AA1214D6880CB5A909D2C9BF\n\nproperty tcId3457 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xAE2F98FD07E2AAB3E0F790AA523C8B36C4063C22A60AE5FC2D2B54C8D46DF7EF\n    pt = 0xF2\n    ct = 0x4677BCCC99567C44FC8C7326AD57F4F9\n\nproperty tcId3458 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x3530B064609EA0F443877A7070CFFF076741C8374FA72268349450173167509F\n    pt = 0x0E\n    ct = 0xCF30EA838A02E16758F641463221386B\n\nproperty tcId3459 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xDFF4C1198259942F942B1F3525E34D091AFE20A84948FFD6C5ABF1887C2E7324\n    pt = 0x84\n    ct = 0xB73B2D548186990CF25BBC4133344B6E\n\nproperty tcId3460 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x4D2A4B5B3C0F1D90D51B48E72926D1FC584FCDDDCE5971B522E96D9CB10F88EA\n    pt = 0xA6\n    ct = 0x64A8CB69731FDD89376C06309DF26460\n\nproperty tcId3461 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBB3670D9C9E461428A80595F716E091B9F5DBF92228ABB1CD0DFB8596B2F69DA\n    pt = 0x9A\n    ct = 0xC552F589E5D11EFCA42051369F008785\n\nproperty tcId3462 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC4633D8B4A999ED5A664EA02DBC047ABDE3041905A0D06726D7D5C2C2651B3AA\n    pt = 0x36\n    ct = 0x0425D5CD3FE9666B0CCE3C98E280C205\n\nproperty tcId3463 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xEDDD75B989E10681C4AA0D8C6418EB981B69C894FD804D06DDE643D7F53582EB\n    pt = 0xC3\n    ct = 0x3A205767FC5EF65D8CB70E8725B836EA\n\nproperty tcId3464 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x374D48822E30895944C18518E02156238707664276D5A599BF2C390E5C840D91\n    pt = 0xE2\n    ct = 0x26C2CD7AF348C457B5D816182803EA92\n\nproperty tcId3465 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x2795AF727A53461AC2B969CE61708DEEB395DCE6FF17923AEFD57E6E0D4BF308\n    pt = 0x47\n    ct = 0x25F38BC30E500B77ABF0D5B6CB038AEB\n\nproperty tcId3466 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x9689C4C49E152D4A554A69BB926A945AC737C6D191D1FA3EF65331D501689383\n    pt = 0x5A\n    ct = 0xA47247E3631B1648EF30CDA790B98B96\n\nproperty tcId3467 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1D3C20DB2B0DE8AB0F9597E1FD3448B80F571EFF3F327F6095614AAA9CAC9811\n    pt = 0xFE\n    ct = 0xF27A4B12E93D2DEB7697C85DA15B92E2\n\nproperty tcId3468 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0x9F3AB283C68BC9F03EB9743F816683595FC3C8D71E738422240F473399768437\n    pt = 0x3A\n    ct = 0xC5E6F5DC654A03FE5577FBA06A22DAB7\n\nproperty tcId3469 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x74A9D44D89694D93A1B61BDD02A81E7966118603BDED187D6E1BC4B06894744A\n    pt = 0x66\n    ct = 0xCEEDBDB7D9FD68D8A77DDD7F1C77F8C1\n\nproperty tcId3470 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC3C6ECBA08443278A12A21A390802A3081BFFC3BEC67600F52FF7CA367885A98\n    pt = 0x65\n    ct = 0x2F266F5CE092FFC3F36F8614FDC20C83\n\nproperty tcId3471 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFA610A36F2ADBBE68D460C13ECEABF708F56796EA820915B63D4F3BE2FD984EE\n    pt = 0x8A\n    ct = 0x85469A8A8A8957547CEFD17E5ECFC85D\n\nproperty tcId3472 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD6611F782D10A57647974D5C656B7F7506E37535416326B219AF81BC4A8743BD\n    pt = 0x58\n    ct = 0xE64D8579FE6BB20D0AFE72488E1F3CD7\n\nproperty tcId3473 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x34FCB48486EF3B0ED9EC197F55EC38F291CC68B1F0F68DABEBBB2787E8756303\n    pt = 0xC4\n    ct = 0x936AFF79592C2759AF94E5B48B6C130C\n\nproperty tcId3474 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x8CFF7404B9BE4A6E3122654AB28EB3C1A773BC4887192D02C6BB5B50FC33435C\n    pt = 0x90\n    ct = 0x799292C2391C29826E6FE4A48289A37F\n\nproperty tcId3475 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xB6FF2FBAE349BC523847288225C94A3B4B1FCD53947524929BE5198045F81F03\n    pt = 0x4C\n    ct = 0x93C4EBC6F811C7E5025BFB48439C002D\n\nproperty tcId3476 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x730721960D62212552AC8CA2F135A07E884DD33209FD5397EC4CC162D8547BDE\n    pt = 0x98\n    ct = 0x46E634181EFE6254399D78F25549D1D9\n\nproperty tcId3477 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xFF2F2B2DC1C3ABFB36C5C2A67EB8FF4E9B2746D43FBE675AD19D15FA782F419C\n    pt = 0x92\n    ct = 0xEB7FC5493BB24DEE35746090C5337BC3\n\nproperty tcId3478 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x575A096AC3B257827DEE39BE44DB62C0B8C8993A0B058AA268CB9401365EE6CA\n    pt = 0x19\n    ct = 0xA36764DF638074D2DB73BA3C73311152\n\nproperty tcId3479 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF61E5A48BFC7142E210405A0063FD24005549DFC3D0CC426C9707D0E3F62EAB4\n    pt = 0x9A\n    ct = 0xEB6575503055566BFC4694FE71A7821F\n\nproperty tcId3480 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xBD3D9ECC1F178756F685C94D82E322860C0080471948B1B3B7FFC7A4B0D32D8A\n    pt = 0xCE\n    ct = 0x7D98C641A46D8701F468347EAE06B222\n\nproperty tcId3481 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x44934AB4E3104CFD6BBF02FE2FBEFA40301DA33CD1383728A93D5C772CAAB2D0\n    pt = 0x67\n    ct = 0xC1A236A91FCEB0D4B673934F650B8164\n\nproperty tcId3482 = testPassed == check_KWP_AD key pt ct where\n    testPassed = False\n    key = 0xE0695B4D76C38ADF1699088111D2C119B8B3EADAD9D4A62CE6FEAC789BD99048\n    pt = 0x47\n    ct = 0x6F5B8A798E1C44DA653C50AF8B8E96E5\n\nproperty tcId3483 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xE37B904A857C891114209A80CDBAA6B9C372EACB9065D95FC4CE2593E81D6F14\n    pt = 0x4A\n    ct = 0x62A104566D84A2A6F0BD3759EB95B079\n\nproperty tcId3484 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x72A2CA6161F22236DDB39B345F72656ACE5FD1745F6185C839C51509444AE9B3\n    pt = 0x82\n    ct = 0x8EA924155A8F514C73C62250BD742EF4\n\nproperty tcId3485 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x1F2801EE032D01D052CDE826C494EA5A5C5CAB39DC871E9B57F8E040D3982E2F\n    pt = 0x16\n    ct = 0xA238DCE4AF87DBB8D4244AEDB9A42CA1\n\nproperty tcId3486 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x70638F85B9B31FAC449DF6AA19FB451960B5EE5CEC6FF3C473AEF8C71615DF65\n    pt = 0x8A\n    ct = 0x21E951E1DEC5BC71F2FA4B0AA90C0ED0\n\nproperty tcId3487 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xF64D02392D650E0865F0C18B62772F1C890798E22A1871754ACAE6176583967E\n    pt = 0x05\n    ct = 0x903545EF6A52EC670DD793F78A50B23A\n\nproperty tcId3488 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x629F665A6786B5BC6A604B9306FC7F9B9390B28DA404C1082939DB657D16E280\n    pt = 0x40\n    ct = 0x10067350D2DC09942720CEF27CB6EB9D\n\nproperty tcId3489 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x43C453F9A65CBCF3BCA65BDFC94EFB6DF647391E821ACFBB62DE786890FB8649\n    pt = 0x56\n    ct = 0x9228F1AFED0E44378E1CA3B60005DCC4\n\nproperty tcId3490 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xC77DEADC06B1F73C13AADC4EB8E5571EA6BFE3F89600C1FB0EB005A4F96ADB85\n    pt = 0x54\n    ct = 0xEE488F48CC2248482856D2056385A722\n\nproperty tcId3491 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x41FF08CAFC5580110B07360491752DC4654A6CFA0023FF9B423370E48BA881EE\n    pt = 0x3F\n    ct = 0x149D9466A536B0E1C4CB5616D3626845\n\nproperty tcId3492 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x6563A6A6707CCB4CA7CA9AD828F0F94860B932502EA9E3E86E561AB219BF3EBE\n    pt = 0x36\n    ct = 0x9F934514BDCC514DDCBC77510CE6F05E\n\nproperty tcId3493 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x56D362245CA9C93774451E5193D3E54E928ABAD5F1DD0C34C1B6B19C8346458A\n    pt = 0xC2\n    ct = 0x31ACBD193BE3BDF7E4D398BA4F5CCF81\n\nproperty tcId3494 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x01BEA442DFCAE33FE752FCD7F029C0E48A2FEC00CD124FB99A777BA9D43EFADF\n    pt = 0xCA\n    ct = 0xF1F01B25DB56D08FF63B95F9A8320873\n\nproperty tcId3495 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x91B234088667FAD2E005E9791DB57B7E2E65D09442C4396A284ADBD18D58294A\n    pt = 0x51\n    ct = 0xF6501E880ACC1AD562C1589BA3DAE3B2\n\nproperty tcId3496 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xD0846D465C055E3CCD45343B6BD9DC549DA718FE62842AA7C0E3D915DE176B14\n    pt = 0x3D\n    ct = 0x5F836DC239426A8AE06D5A40FA8FFE5A\n\nproperty tcId3497 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0xA9803E483158D203A22C48F9BABCBA8B4E25328A11BA1D310E57F0D7226EC355\n    pt = 0xD9\n    ct = 0x6AACCBB9DBD4B319E50898EB21BA7470\n\nproperty tcId3498 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x063726D0EB03547D726E9D10ACCCB3CFF01006209D7FB39C05211EC88EE37C7F\n    pt = 0x16\n    ct = 0x341CEB90D234A324941D12B2024EBC1E\n\nproperty tcId3499 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x245F675642C52A62E1AD864EDA33FA65006C8BCD3D360D5A3E54D3F0982E2A01\n    pt = 0x42\n    ct = 0x5424035C2260598A200029E0F7533CA4\n\nproperty tcId3500 = testPassed == check_KWP_AD key pt ct where\n    testPassed = True\n    key = 0x63FEA6C364B3A9C7813472E289513ADC0631493A7C9014FFB395560F7C767E11\n    pt = 0x57\n    ct = 0x92AA71DCDE68A0DA1CDFC86DABF331AA\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_XTS.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_XTS` that instantiates the generic XTS block cipher mode with the AES-256 block cipher implementation as its underlying primitive."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_XTS =\n    Primitive::Symmetric::Cipher::Block::Modes::XTS {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR` that instantiates the CTR block cipher mode using the AES-256 block cipher, matching the given module alias structure."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR =\n    Primitive::Symmetric::Cipher::Block::Modes::CTR {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES192_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB` that instantiates the generic CFB block cipher mode with the AES-192 block cipher implementation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB =\n    Primitive::Symmetric::Cipher::Block::Modes::CFB {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_XTS.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_XTS` that instantiates the generic XTS block cipher mode using the AES-128 block cipher implementation as its underlying primitive."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_XTS =\n    Primitive::Symmetric::Cipher::Block::Modes::XTS {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CTR` that instantiates the CTR block cipher mode using the AES-128 block cipher implementation, exposing the AES-128-CTR encryption\/decryption interfaces."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CTR =\n    Primitive::Symmetric::Cipher::Block::Modes::CTR {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CFB` that instantiates the generic CFB block cipher mode using the AES-256 block cipher implementation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CFB =\n    Primitive::Symmetric::Cipher::Block::Modes::CFB {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_KeyWrap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap` that instantiates the generic AES Key Wrap mode using the AES-256 block cipher implementation as its underlying primitive."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap =\n    Primitive::Symmetric::Cipher::Block::Modes::AESKeyWrap {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES192_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CTR` that instantiates the CTR block cipher mode using the AES-192 block cipher implementation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CTR =\n    Primitive::Symmetric::Cipher::Block::Modes::CTR {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB` that instantiates the generic CFB block cipher mode using the AES-128 block cipher implementation, exposing the AES-128 CFB encryption\/decryption interfaces."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB =\n    Primitive::Symmetric::Cipher::Block::Modes::CFB {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES192_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CBC` that instantiates CBC mode using the AES-192 block cipher implementation from `Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192`, exposing the CBC encryption\/decryption interfaces specialized to AES-192."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CBC =\n    Primitive::Symmetric::Cipher::Block::Modes::CBC {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES256_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CBC` that instantiates the generic CBC block cipher mode with the AES-256 block cipher specification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CBC =\n    Primitive::Symmetric::Cipher::Block::Modes::CBC {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Instantiations\/AES128_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CBC` that instantiates the CBC block cipher mode using AES-128 as the underlying block cipher, exposing the CBC-mode encryption\/decryption interfaces specialized to AES-128."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CBC =\n    Primitive::Symmetric::Cipher::Block::Modes::CBC {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Tests\/tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module that imports all Simon block cipher instantiations (Simon32_64 through Simon128_256) and defines properties t0\u2013t9 asserting that their encrypt functions map the given NIST test vectors\u2019 keys and plaintexts to the specified ciphertexts."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Tests::tests where\n\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon32_64 as Simon32_64\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_72 as Simon48_72\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_96 as Simon48_96\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_96 as Simon64_96\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_128 as Simon64_128\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96 as Simon96_96\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_144 as Simon96_144\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128 as Simon128_128\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_192 as Simon128_192\nimport Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256 as Simon128_256\n\nproperty t0 = Simon32_64::encrypt k pt == ct\n  where\n    k = 0x1918_1110_0908_0100\n    pt = 0x6565_6877\n    ct = 0xc69b_e9bb\n\nproperty t1 = Simon48_72::encrypt k pt == ct\n  where\n    k = 0x121110_0a0908_020100\n    pt = 0x612067_6e696c\n    ct = 0xdae5ac_292cac\n\nproperty t2 = Simon48_96::encrypt k pt == ct\n  where\n    k = 0x1a1918_121110_0a0908_020100\n    pt = 0x726963_20646e\n    ct = 0x6e06a5_acf156\n\nproperty t3 = Simon64_96::encrypt k pt == ct\n  where\n    k = 0x13121110_0b0a0908_03020100\n    pt = 0x6f722067_6e696c63\n    ct = 0x5ca2e27f_111a8fc8\n\nproperty t4 = Simon64_128::encrypt k pt == ct\n  where\n    k = 0x1b1a1918_13121110_0b0a0908_03020100\n    pt = 0x656b696c_20646e75\n    ct = 0x44c8fc20_b9dfa07a\n\nproperty t5 = Simon96_96::encrypt k pt == ct\n  where\n    k = 0x0d0c0b0a0908_050403020100\n    pt = 0x2072616c6c69_702065687420\n    ct = 0x602807a462b4_69063d8ff082\n\nproperty t6 = Simon96_144::encrypt k pt == ct\n  where\n    k = 0x151413121110_0d0c0b0a0908_050403020100\n    pt = 0x746168742074_73756420666f\n    ct = 0xecad1c6c451e_3f59c5db1ae9\n\nproperty t7 = Simon128_128::encrypt k pt == ct\n  where\n    k = 0x0f0e0d0c0b0a0908_0706050403020100\n    pt = 0x6373656420737265_6c6c657661727420\n    ct = 0x49681b1e1e54fe3f_65aa832af84e0bbc\n\nproperty t8 = Simon128_192::encrypt k pt == ct\n  where\n    k = 0x1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n    pt = 0x206572656874206e_6568772065626972\n    ct = 0xc4ac61effcdc0d4f_6c9c8d6e2597b85b\n\nproperty t9 = Simon128_256::encrypt k pt == ct\n  where\n    k = 0x1f1e1d1c1b1a1918_1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n    pt = 0x74206e69206d6f6f_6d69732061207369\n    ct = 0x8d2b5579afc8a3a0_3bf72a87efe7b868\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon96_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96` that instantiates the generic Simon block cipher specification for the Simon-96\/96 variant with parameters `n = 48`, `m = 2`, `T = 52`, and `j = 2`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_96 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 48\n    type m = 2\n    type T = 52\n    type j = 2\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon96_144.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_144` that instantiates the Simon block cipher specification with parameters `n = 48`, `m = 3`, `T = 54`, and `j = 3`, exposing the resulting cipher functions and types."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon96_144 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 48\n    type m = 3\n    type T = 54\n    type j = 3\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon64_128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_128` that instantiates the generic Simon block cipher specification with parameters n = 32, m = 4, T = 44, and j = 3, exposing the resulting Simon64\/128 cipher interface."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_128 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 32\n    type m = 4\n    type T = 44\n    type j = 3\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon48_72.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that instantiates the SIMON block cipher specification for the Simon48\/72 variant with parameters n=24, m=3, T=36, and j=0, exposing the resulting cipher interface and types."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_72 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 24\n    type m = 3\n    type T = 36\n    type j = 0\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon128_128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128` instantiating the generic Simon block cipher specification for the Simon-128\/128 variant with parameters `n=64`, `m=2`, `T=68`, and `j=2`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 64\n    type m = 2\n    type T = 68\n    type j = 2\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon64_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_96` instantiating the Simon block cipher specification for the Simon-64\/96 variant with type parameters `n = 32`, `m = 3`, `T = 42`, and `j = 2`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon64_96 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 32\n    type m = 3\n    type T = 42\n    type j = 2\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon128_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256` that instantiates the generic Simon block cipher specification with parameters `n = 64`, `m = 4`, `T = 72`, and `j = 4`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 64\n    type m = 4\n    type T = 72\n    type j = 4\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon128_192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_192` instantiating the Simon block cipher specification for the Simon-128\/192 variant with parameters `n = 64`, `m = 3`, `T = 69`, and `j = 3`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_192 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 64\n    type m = 3\n    type T = 69\n    type j = 3\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Instantiations\/Simon48_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_96` instantiating the Simon block cipher specification with parameters `n = 24`, `m = 4`, `T = 36`, and `j = 1`, exposing the resulting Simon48\/96 cipher functions and types."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon48_96 =\n  Primitive::Symmetric::Cipher::Block::Simon::Specification where\n    type n = 24\n    type m = 4\n    type T = 36\n    type j = 1\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Tests\/tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module that imports all Speck block cipher instantiations (Speck32_64 through Speck128_256) and defines properties t0\u2013t9 asserting that encrypting given standard test vectors (keys and plaintexts) yields the specified ciphertexts."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Tests::tests where\n\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck32_64 as Speck32_64\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_72 as Speck48_72\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_96 as Speck48_96\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_96 as Speck64_96\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_128 as Speck64_128\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_96 as Speck96_96\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_144 as Speck96_144\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_128 as Speck128_128\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_192 as Speck128_192\nimport Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_256 as Speck128_256\n\nproperty t0 = Speck32_64::encrypt k p == c\n    where\n        k = 0x1918_1110_0908_0100\n        p = 0x6574_694c\n        c = 0xa868_42f2\n\nproperty t1 = Speck48_72::encrypt k p == c\n    where\n        k = 0x121110_0a0908_020100\n        p = 0x20796c_6c6172\n        c = 0xc049a5_385adc\n\nproperty t2 = Speck48_96::encrypt k p == c\n    where\n        k = 0x1a1918_121110_0a0908_020100\n        p = 0x6d2073_696874\n        c = 0x735e10_b6445d\n\nproperty t3 = Speck64_96::encrypt k p == c\n    where\n        k = 0x13121110_0b0a0908_03020100\n        p = 0x74614620_736e6165\n        c = 0x9f7952ec_4175946c\n\nproperty t4 = Speck64_128::encrypt k p == c\n    where\n        k = 0x1b1a1918_13121110_0b0a0908_03020100\n        p = 0x3b726574_7475432d\n        c = 0x8c6fa548_454e028b\n\nproperty t5 = Speck96_96::encrypt k p == c\n    where\n        k = 0x0d0c0b0a0908_050403020100\n        p = 0x65776f68202c_656761737520\n        c = 0x9e4d09ab7178_62bdde8f79aa\n\nproperty t6 = Speck96_144::encrypt k p == c\n    where\n        k = 0x151413121110_0d0c0b0a0908_050403020100\n        p = 0x656d6974206e_69202c726576\n        c = 0x2bf31072228a_7ae440252ee6\n\nproperty t7 = Speck128_128::encrypt k p == c\n    where\n        k = 0x0f0e0d0c0b0a0908_0706050403020100\n        p = 0x6c61766975716520_7469206564616d20\n        c = 0xa65d985179783265_7860fedf5c570d18\n\nproperty t8 = Speck128_192::encrypt k p == c\n    where\n        k = 0x1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n        p = 0x7261482066656968_43206f7420746e65\n        c = 0x1be4cf3a13135566_f9bc185de03c1886\n\nproperty t9 = Speck128_256::encrypt k p == c\n    where\n        k = 0x1f1e1d1c1b1a1918_1716151413121110_0f0e0d0c0b0a0908_0706050403020100\n        p = 0x65736f6874206e49_202e72656e6f6f70\n        c = 0x4109010405c0f53e_4eeeb48d9c188f43\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck48_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_96` that instantiates the generic Speck block cipher specification for the Speck48\/96 variant using n=24, m=4, and T=23, exposing the appropriate encryption\/decryption interface."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_96 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 24\ntype m = 4\ntype T = 23\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck32_64.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck32_64` instantiating the generic Speck block cipher specification for the Speck32\/64 variant with parameters `n = 16`, `m = 4`, and `T = 22`, exposing the usual encryption\/decryption interfaces and any relevant properties."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck32_64 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 16\ntype m = 4\ntype T = 22\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck128_128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_128` that instantiates the generic Speck block cipher specification for the Speck128\/128 variant, specifying the appropriate word sizes and parameters and exposing the resulting encryption and decryption interfaces."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_128 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 64\ntype m = 2\ntype T = 32\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck64_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_96` instantiating the generic Speck block-cipher specification for the Speck64\/96 variant, with type parameters `n = 32`, `m = 3`, and `T = 26`, exposing the appropriate cipher functions and types."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_96 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 32\ntype m = 3\ntype T = 26\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck128_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_256` that instantiates the generic Speck block cipher specification for the 128-bit block, 256-bit key variant using n = 64, m = 4, and T = 34, exposing the appropriate encryption\/decryption interfaces."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_256 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 64\ntype m = 4\ntype T = 34\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck96_144.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_144` that instantiates the generic Speck block cipher specification for a 96-bit block and 144-bit key, using type aliases `n = 48`, `m = 3`, and `T = 29`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_144 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 48\ntype m = 3\ntype T = 29\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck64_128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_128` that instantiates the generic Speck block cipher specification for the 64-bit block \/ 128-bit key variant with parameters `n = 32`, `m = 4`, and `T = 27`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck64_128 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 32\ntype m = 4\ntype T = 27\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck96_96.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_96` that instantiates the generic Speck block cipher specification for the 96-bit block, 96-bit key variant by setting `n = 48`, `m = 2`, and `T = 28`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck96_96 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 48\ntype m = 2\ntype T = 28\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck48_72.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_72` that instantiates the generic Speck block cipher specification for the Speck48\/72 variant with type parameters `n = 24`, `m = 3`, and `T = 22`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck48_72 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 24\ntype m = 3\ntype T = 22\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Instantiations\/Speck128_192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_192` that instantiates the generic Speck block cipher specification for the 128-bit block, 192-bit key variant using parameters `n = 64`, `m = 3`, and `T = 33`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Instantiations::Speck128_192 =\n    Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\ntype n = 64\ntype m = 3\ntype T = 33\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Tests\/AES256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the module Primitive::Symmetric::Cipher::Block::AES::Tests::AES256 with the property aes256TestVectorsPass that checks AES256::encrypt and AES256::decrypt against the given NIST AES-256 ECB test vectors, returning true only if all encryptions and decryptions match."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Tests::AES256 where\nimport Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256 as AES256\n\nproperty aes256TestVectorsPass = and encryptions \/\\ and decryptions\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        pts = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        expected_cts = [\n            0xf3eed1bdb5d2a03c064b5a7e3db181f8,\n            0x591ccb10d410ed26dc5ba74a31362870,\n            0xb6ed21b99ca6f4f9f153e7b1beafed1d,\n            0x23304b7a39f9f3ff067d8d8f9e24ecc7\n        ]\n        encryptions = [ AES256::encrypt key msg == ct | msg <- pts | ct <- expected_cts ]\n        decryptions = [ AES256::decrypt key ct == pt | pt <- pts | ct <- expected_cts ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Tests\/AES192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the module Primitive::Symmetric::Cipher::Block::AES::Tests::AES192 with the property aes192TestVectorsPass that checks AES192::encrypt and AES192::decrypt against the given NIST AES-192 ECB test vectors for the specified key, plaintexts, and expected ciphertexts."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Tests::AES192 where\nimport Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192 as AES192\n\nproperty aes192TestVectorsPass = and encryptions \/\\ and decryptions\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        pts = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        expected_cts = [\n            0xbd334f1d6e45f25ff712a214571fa5cc,\n            0x974104846d0ad3ad7734ecb3ecee4eef,\n            0xef7afd2270e2e60adce0ba2face6444e,\n            0x9a4b41ba738d6c72fb16691603c18e0e\n        ]\n        encryptions = [ AES192::encrypt key msg == ct | msg <- pts | ct <- expected_cts ]\n        decryptions = [ AES192::decrypt key ct == pt | pt <- pts | ct <- expected_cts ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Instantiations\/AES128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128` that instantiates the generic AES block cipher specification with a 128-bit key size (i.e., `type KeySize' = 128`) and exposes the appropriate AES-128 encryption\/decryption interfaces."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128 =\n    Primitive::Symmetric::Cipher::Block::AES::Specification where\n    type KeySize' = 128\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Instantiations\/AES256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256` that instantiates the generic AES specification with `KeySize' = 256`, exposing the standard AES-256 encryption\/decryption interfaces and any associated properties."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256 =\n    Primitive::Symmetric::Cipher::Block::AES::Specification where\n    type KeySize' = 256\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Instantiations\/AES192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192` that instantiates the generic AES specification with a 192-bit key by setting `type KeySize' = 192`, exposing the resulting AES-192 cipher interface."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192 =\n    Primitive::Symmetric::Cipher::Block::AES::Specification where\n    type KeySize' = 192\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module that specifies a generic HMAC construction over a parameterized hash function H, including the functions hmac and hmac_truncate with the given typing and padding behavior, suitable for use in verifying HMAC-based MAC schemes."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Specification where\n\nparameter\n\n  type B : #\n\n  type L : #\n\n  type constraint (fin B, L <= B, width (8 * L) <= B, width (8 * (B + L)) <= B)\n\n  H : {T} (width (8 * T) <= B) => [T][8] -> [L][8]\n\nhmac : {k, n} (width (8 * k) <= B, width (8 * (n + B)) <= B) => [k][8] -> [n][8] -> [L][8]\nhmac K text = H ((K\u2080 ^ opad) # H ((K\u2080 ^ ipad) # text)) where\n\n  K\u2080 = expand_key K\n\nhmac_truncate : {\u03bb, k, n} (\u03bb < L, \u03bb >= 4, width (8 * k) <= B, width (8 * (n + B)) <= B)\n  => [k][8] -> [n][8] -> [\u03bb][8]\nhmac_truncate K text = take output where\n  output = hmac K text\n\nprivate\n\n  ipad : [B][8]\n  ipad = repeat 0x36\n\n  opad : [B][8]\n  opad = repeat 0x5c\n\n  expand_key : {k} (width (8 * k) <= B) => [k][8] -> [B][8]\n  expand_key K\n    | k <= B => K # zero\n\n    | k > B => H K # zero\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Tests\/HMAC_SHA2_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module that verifies an HMAC-SHA-512 implementation against RFC 4868 test vectors, including full 512-bit PRF outputs and 256-bit truncated HMAC-SHA-512\/256 outputs via boolean properties over key\/data parameters."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA2_512 where\n\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA512 as H512\n\ntype PrfParams K D =\n  { Key : [K][8]\n  , Data: [D][8]\n  , PRF_HMAC_SHA_512 : [512]\n  }\n\nprf_test : {K, D} (K < 256, D < 256) => PrfParams K D -> Bit\nprf_test params =\n  H512::hmac params.Key params.Data == split params.PRF_HMAC_SHA_512\n\nproperty rfc_4868_2_7_1_1 = prf_test\n  { Key = repeat`{20} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_512 =\n      0x87aa7cdea5ef619d4ff0b4241a1d6cb0 #\n      0x2379f4e2ce4ec2787ad0b30545e17cde #\n      0xdaa833b7d6b8a702038b274eaea3f4e4 #\n      0xbe9d914eeb61f1702e696c203a126854\n  }\n\nproperty rfc_4868_2_7_1_2 = prf_test\n  { Key = \"Jefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_512 =\n      0x164b7a7bfcf819e2e395fbe73b56e0a3 #\n      0x87bd64222e831fd610270cd7ea250554 #\n      0x9758bf75c05a994a6d034f65f8f0e6fd #\n      0xcaeab1a34d4a6b4b636e070a38bce737\n  }\n\nproperty rfc_4868_2_7_1_3 = prf_test\n  { Key = repeat`{20} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_512 =\n      0xfa73b0089d56a284efb0f0756c890be9 #\n      0xb1b5dbdd8ee81a3655f83e33b2279d39 #\n      0xbf3e848279a722c806b485a47e67c807 #\n      0xb946a337bee8942674278859e13292fb\n  }\n\nproperty rfc_4868_2_7_1_4 = prf_test\n  { Key = split 0x0102030405060708090a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_512 =\n      0xb0ba465637458c6990e5a8c5f61d4af7 #\n      0xe576d97ff94b872de76f8050361ee3db #\n      0xa91ca5c11aa25eb4d679275cc5788063 #\n      0xa5f19741120c4f2de2adebeb10a298dd\n  }\n\nproperty rfc_4868_2_7_1_5 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  , PRF_HMAC_SHA_512 =\n      0x80b24263c7c1a3ebb71493c1dd7be8b4 #\n      0x9b46d1f41b4aeec1121b013783f8f352 #\n      0x6b56d037e05f2598bd0fd2215d6a1e52 #\n      0x95e64f73f63f0aec8b915a985d786598\n  }\n\nproperty rfc_4868_2_7_1_6 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.\"\n  , PRF_HMAC_SHA_512 =\n      0xe37b6a775dc87dbaa4dfa9f96e5e3ffd #\n      0xdebd71f8867289865df5a32d20cdc944 #\n      0xb6022cac3c4982b10d5eeb55c3e4de15 #\n      0x134676fb6de0446065c97440fa8c6a58\n  }\n\ntype AuthTest512 T =\n  { Key : [64][8]\n  , Data : [T][8]\n  , PRF_HMAC_SHA_512 : [512]\n  , HMAC_SHA_512_256 : [256]\n  }\n\nsha2_512_auth_test : {T} (T < 256) => AuthTest512 T -> Bit\nsha2_512_auth_test params =\n  H512::hmac params.Key params.Data == split params.PRF_HMAC_SHA_512 \/\\\n  H512::hmac_truncate params.Key params.Data == split params.HMAC_SHA_512_256\n\nproperty rfc_4868_2_7_2_3_1 = sha2_512_auth_test\n  { Key = repeat`{64} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_512 =\n      0x637edc6e01dce7e6742a99451aae82df #\n      0x23da3e92439e590e43e761b33e910fb8 #\n      0xac2878ebd5803f6f0b61dbce5e251ff8 #\n      0x789a4722c1be65aea45fd464e89f8f5b\n  , HMAC_SHA_512_256 =\n      0x637edc6e01dce7e6742a99451aae82df #\n      0x23da3e92439e590e43e761b33e910fb8\n  }\n\nproperty rfc_4868_2_7_2_3_2 = sha2_512_auth_test\n  { Key = \"JefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_512 =\n      0xcb370917ae8a7ce28cfd1d8f4705d614 #\n      0x1c173b2a9362c15df235dfb251b15454 #\n      0x6aa334ae9fb9afc2184932d8695e397b #\n      0xfa0ffb93466cfcceaae38c833b7dba38\n  , HMAC_SHA_512_256 =\n      0xcb370917ae8a7ce28cfd1d8f4705d614 #\n      0x1c173b2a9362c15df235dfb251b15454\n  }\n\nproperty rfc_4868_2_7_2_3_3 = sha2_512_auth_test\n  { Key = repeat`{64} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_512 =\n      0x2ee7acd783624ca9398710f3ee05ae41 #\n      0xb9f9b0510c87e49e586cc9bf961733d8 #\n      0x623c7b55cebefccf02d5581acc1c9d5f #\n      0xb1ff68a1de45509fbe4da9a433922655\n  , HMAC_SHA_512_256 =\n      0x2ee7acd783624ca9398710f3ee05ae41 #\n      0xb9f9b0510c87e49e586cc9bf961733d8\n  }\n\nproperty rfc_4868_2_7_2_3_4 = sha2_512_auth_test\n  { Key =\n            split 0x0102030405060708090a0b0c0d0e0f10 #\n      split 0x1112131415161718191a1b1c1d1e1f20 #\n      split 0x2122232425262728292a2b2c2d2e2f30 #\n      split 0x3132333435363738393a3b3c3d3e3f40\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_512 =\n      0x5e6688e5a3daec826ca32eaea224eff5 #\n      0xe700628947470e13ad01302561bab108 #\n      0xb8c48cbc6b807dcfbd850521a685babc #\n      0x7eae4a2a2e660dc0e86b931d65503fd2\n  , HMAC_SHA_512_256 =\n      0x5e6688e5a3daec826ca32eaea224eff5 #\n      0xe700628947470e13ad01302561bab108\n  }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Tests\/HMAC_SHA1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that imports an HMAC-SHA1 implementation and defines properties rfc_2202_3_1 through rfc_2202_3_7 to verify its outputs against the RFC 2202 HMAC-SHA1 and truncated HMAC-SHA1-96 test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA1 where\n\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA1\n\ntype PrfParams K D =\n  { Key : [K][8]\n  , Data: [D][8]\n  , PRF_HMAC_SHA_1 : [160]\n  }\n\nprf_test : {K, D} (K < 256, D < 256) => PrfParams K D -> Bit\nprf_test params = hmac params.Key params.Data == split params.PRF_HMAC_SHA_1\n\ntype AuthTest T =\n  { Key : [20][8]\n  , Data : [T][8]\n  , PRF_HMAC_SHA_1 : [160]\n  , HMAC_SHA_1_96 : [96]\n  }\n\nsha1_auth_test : {T} (T < 256) => AuthTest T -> Bit\nsha1_auth_test params =\n  hmac params.Key params.Data == split params.PRF_HMAC_SHA_1 \/\\\n  hmac_truncate params.Key params.Data == split params.HMAC_SHA_1_96\n\nproperty rfc_2202_3_1 = prf_test\n  { Key = repeat`{20} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_1 = 0xb617318655057264e28bc0b6fb378c8ef146be00\n  }\n\nproperty rfc_2202_3_2 = prf_test\n  { Key = \"Jefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_1 = 0xeffcdf6ae5eb2fa2d27416d5f184df9c259a7c79\n  }\n\nproperty rfc_2202_3_3 = prf_test\n  { Key = repeat`{20} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_1 = 0x125d7342b9ac11cd91a39af48aa17b4f63f175d3\n  }\n\nproperty rfc_2202_3_4 = prf_test\n  { Key = split 0x0102030405060708090a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_1 = 0x4c9007f4026250c6bc8414f9bf50c86c2d7235da\n  }\n\nproperty rfc_2202_3_5 = sha1_auth_test\n  { Key = repeat`{20} 0x0c\n  , Data = \"Test With Truncation\"\n  , PRF_HMAC_SHA_1 = 0x4c1a03424b55e07fe7f27be1d58bb9324a9a5a04\n  , HMAC_SHA_1_96 = 0x4c1a03424b55e07fe7f27be1\n  }\n\nproperty rfc_2202_3_6 = prf_test\n  { Key = repeat`{80} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  , PRF_HMAC_SHA_1 = 0xaa4ae5e15272d00e95705637ce8a3b55ed402112\n  }\n\nproperty rfc_2202_3_7 = prf_test\n  { Key = repeat`{80} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data\"\n  , PRF_HMAC_SHA_1 = 0xe8e99d0f45237d786d6bbaa7965c7808bbff1a91\n  }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Tests\/HMAC_SHA2_384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module that verifies an HMAC-SHA-384 implementation against RFC 4868 test vectors, including full 384-bit PRF outputs and 192-bit truncated outputs, using properties like rfc_4868_2_7_1_1 and rfc_4868_2_7_2_2_1."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA2_384 where\n\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA384 as H384\n\ntype PrfParams K D =\n  { Key : [K][8]\n  , Data: [D][8]\n  , PRF_HMAC_SHA_384 : [384]\n  }\n\nprf_test : {K, D} (K < 256, D < 256) => PrfParams K D -> Bit\nprf_test params =\n  H384::hmac params.Key params.Data == split params.PRF_HMAC_SHA_384\n\nproperty rfc_4868_2_7_1_1 = prf_test\n  { Key = repeat`{20} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_384 =\n      0xafd03944d84895626b0825f4ab46907f #\n      0x15f9dadbe4101ec682aa034c7cebc59c #\n      0xfaea9ea9076ede7f4af152e8b2fa9cb6\n  }\n\nproperty rfc_4868_2_7_1_2 = prf_test\n  { Key = \"Jefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_384 =\n      0xaf45d2e376484031617f78d2b58a6b1b #\n      0x9c7ef464f5a01b47e42ec3736322445e #\n      0x8e2240ca5e69e2c78b3239ecfab21649\n  }\n\nproperty rfc_4868_2_7_1_3 = prf_test\n  { Key = repeat`{20} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_384 =\n      0x88062608d3e6ad8a0aa2ace014c8a86f #\n      0x0aa635d947ac9febe83ef4e55966144b #\n      0x2a5ab39dc13814b94e3ab6e101a34f27\n  }\n\nproperty rfc_4868_2_7_1_4 = prf_test\n  { Key = split 0x0102030405060708090a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_384 =\n      0x3e8a69b7783c25851933ab6290af6ca7 #\n      0x7a9981480850009cc5577c6e1f573b4e #\n      0x6801dd23c4a7d679ccf8a386c674cffb\n  }\n\nproperty rfc_4868_2_7_1_5 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  , PRF_HMAC_SHA_384 =\n      0x4ece084485813e9088d2c63a041bc5b4 #\n      0x4f9ef1012a2b588f3cd11f05033ac4c6 #\n      0x0c2ef6ab4030fe8296248df163f44952\n  }\n\nproperty rfc_4868_2_7_1_6 = prf_test\n  { Key = repeat`{131} 0xaa\n  , Data = \"This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.\"\n  , PRF_HMAC_SHA_384 =\n      0x6617178e941f020d351e2f254e8fd32c #\n      0x602420feb0b8fb9adccebb82461e99c5 #\n      0xa678cc31e799176d3860e6110c46523e\n  }\n\ntype AuthTest384 T =\n  { Key : [48][8]\n  , Data : [T][8]\n  , PRF_HMAC_SHA_384 : [384]\n  , HMAC_SHA_384_192 : [192]\n  }\n\nsha2_384_auth_test : {T} (T < 256) => AuthTest384 T -> Bit\nsha2_384_auth_test params =\n  H384::hmac params.Key params.Data == split params.PRF_HMAC_SHA_384 \/\\\n  H384::hmac_truncate params.Key params.Data == split params.HMAC_SHA_384_192\n\nproperty rfc_4868_2_7_2_2_1 = sha2_384_auth_test\n  { Key = repeat`{48} 0x0b\n  , Data = \"Hi There\"\n  , PRF_HMAC_SHA_384 =\n      0xb6a8d5636f5c6a7224f9977dcf7ee6c7 #\n      0xfb6d0c48cbdee9737a959796489bddbc #\n      0x4c5df61d5b3297b4fb68dab9f1b582c2\n  , HMAC_SHA_384_192 =\n      0xb6a8d5636f5c6a7224f9977dcf7ee6c7 #\n      0xfb6d0c48cbdee973\n  }\n\nproperty rfc_4868_2_7_2_2_2 = sha2_384_auth_test\n  { Key = \"JefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefe\"\n  , Data = \"what do ya want for nothing?\"\n  , PRF_HMAC_SHA_384 =\n      0x2c7353974f1842fd66d53c452ca42122 #\n      0xb28c0b594cfb184da86a368e9b8e16f5 #\n      0x349524ca4e82400cbde0686d403371c9\n  , HMAC_SHA_384_192 =\n      0x2c7353974f1842fd66d53c452ca42122 #\n      0xb28c0b594cfb184d\n  }\n\nproperty rfc_4868_2_7_2_2_3 = sha2_384_auth_test\n  { Key = repeat`{48} 0xaa\n  , Data = repeat`{50} 0xdd\n  , PRF_HMAC_SHA_384 =\n      0x809f439be00274321d4a538652164b53 #\n      0x554a508184a0c3160353e3428597003d #\n      0x35914a18770f9443987054944b7c4b4a\n  , HMAC_SHA_384_192 =\n      0x809f439be00274321d4a538652164b53 #\n      0x554a508184a0c316\n  }\n\nproperty rfc_4868_2_7_2_2_4 = sha2_384_auth_test\n  { Key =\n      split 0x0102030405060708090a0b0c0d0e0f10 #\n      split 0x1112131415161718191a1b1c1d1e1f20 #\n      split 0x0a0b0c0d0e0f10111213141516171819\n  , Data = repeat`{50} 0xcd\n  , PRF_HMAC_SHA_384 =\n      0x5b540085c6e6358096532b2493609ed1 #\n      0xcb298f774f87bb5c2ebf182c83cc7428 #\n      0x707fb92eab2536a5812258228bc96687\n  , HMAC_SHA_384_192 =\n      0x5b540085c6e6358096532b2493609ed1 #\n      0xcb298f774f87bb5c\n  }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA512` that instantiates the generic HMAC specification with SHA-512, using block size B=128, output length L=64, and `H = hashBytes` from the SHA512 module."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA512 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA2::Instantiations::SHA512\n  type B = 128\n  type L = 64\n  H = hashBytes\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA1` instantiating the generic HMAC specification with SHA1, using block size 64 bytes, output length 20 bytes, and `H text = SHA1::hashBytes text` as the underlying hash function."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA1 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA1::Specification as SHA1\n  type B = 64\n  type L = 20\n  H text = SHA1::hashBytes text\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA256` that instantiates the generic HMAC specification using SHA-256, with block size 64 bytes, output length 32 bytes, and `H = hashBytes` from the SHA-256 instantiation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA256 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256\n  type B = 64\n  type L = 32\n  H = hashBytes\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC\/Instantiations\/HMAC_SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA384` that instantiates the generic HMAC specification with SHA-384, using block size B = 128 bits, output length L = 48 bytes, and `H = hashBytes` from the SHA384 instantiation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA384 =\n  Primitive::Symmetric::MAC::HMAC::Specification where\n\n  import Primitive::Keyless::Hash::SHA2::Instantiations::SHA384\n  type B = 128\n  type L = 48\n  H = hashBytes\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/FNV.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing the 64-bit FNV-1a hash function over byte vectors, including the constants fnv1a_offset_basis and fnv1a_prime, the functions pad, block, fnv1a, and a property testsPass that checks the given three known-answer tests."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::FNV where\n\nfnv1a : {n} (fin n) => [n] -> [64]\nfnv1a ws = fnv1a' (pad ws)\n\npad : {msgLen} (fin msgLen) => [msgLen] -> [msgLen \/^ 8][8]\npad msg = split (msg # (zero:[msgLen %^ 8]))\n\nfnv1a' : {chunks} (fin chunks) => [chunks][8] -> [64]\nfnv1a' msg = Ss ! 0\n  where\n   Ss = [fnv1a_offset_basis] #\n           [ block s m\n           | s <- Ss\n           | m <- msg\n           ]\n\nblock : {padLen} ( padLen == 64 - 8) => [64] -> [8] -> [64]\nblock state val = (state ^ ((zero : [padLen]) # val)) * fnv1a_prime\n\nfnv1a_offset_basis : [64]\nfnv1a_offset_basis = 14695981039346656037\n\nfnv1a_prime : [64]\nfnv1a_prime = 1099511628211\n\nt1 = fnv1a [] == 0xcbf29ce484222325\nt2 = fnv1a (join \"a\") == 0xaf63dc4c8601ec8c\nt3 = fnv1a (join \"foobar\") == 0x85944171f73967e8\n\nproperty testsPass = and [t1, t2, t3]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/HashInterface.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol interface module `Primitive::Keyless::Hash::HashInterface` that declares numeric types `MessageUpperBound`, `DigestLength`, `SecurityStrength`, and a polymorphic function `hash : {m} (fin m, width m < MessageUpperBound) => [m] -> [DigestLength]` for a generic keyless hash primitive."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Keyless::Hash::HashInterface where\n\n    type MessageUpperBound : #\n\n    type DigestLength : #\n\n    type SecurityStrength : #\n\n    hash: {m} (fin m, width m < MessageUpperBound) => [m] -> [DigestLength]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/Blake2b.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Keyless::Hash::Blake2b` implementing the BLAKE2b hash function and its compression function `F`, along with a property `katsPass` that checks the included test vectors and known-answer tests for correctness."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::Blake2b where\n\ntype Block   = [16][64]\ntype State   = [8][64]\ntype LocalState = [16][64]\ntype Counter = [128]\n\ntype Context = { state : State, counter : Counter }\n\nbbVal : [128]\nbbVal = 128\n\nIV : [8][64]\nIV = [ 0x6A09E667F3BCC908, 0xBB67AE8584CAA73B,\n       0x3C6EF372FE94F82B, 0xA54FF53A5F1D36F1,\n       0x510E527FADE682D1, 0x9B05688C2B3E6C1F,\n       0x1F83D9ABFB41BD6B, 0x5BE0CD19137E2179\n     ]\n\nSIGMA_TABLE : [12][16][4]\nSIGMA_TABLE =\n    [  [  0, 1,   2, 3,   4, 5,   6, 7,   8, 9,  10, 11, 12, 13, 14, 15 ]\n    ,  [ 14, 10,  4, 8,   9, 15, 13, 6,   1, 12,  0, 2,  11, 7,   5, 3  ]\n    ,  [ 11, 8,  12, 0,   5, 2,  15, 13, 10, 14,  3, 6,   7, 1,   9, 4  ]\n    ,  [  7, 9,   3, 1,  13, 12, 11, 14,  2, 6,   5, 10,  4, 0,  15, 8  ]\n    ,  [  9, 0,   5, 7,   2, 4,  10, 15, 14, 1,  11, 12,  6, 8,   3, 13 ]\n    ,  [  2, 12,  6, 10,  0, 11,  8, 3,   4, 13,  7, 5,  15, 14,  1, 9  ]\n    ,  [ 12, 5,   1, 15, 14, 13,  4, 10,  0, 7,   6, 3,   9, 2,   8, 11 ]\n    ,  [ 13, 11,  7, 14, 12, 1,   3, 9,   5, 0,  15, 4,   8, 6,   2, 10 ]\n    ,  [  6, 15, 14, 9,  11, 3,   0, 8,  12, 2,  13, 7,   1, 4,  10, 5  ]\n    ,  [ 10, 2,   8, 4,   7, 6,   1, 5,  15, 11,  9, 14,  3, 12, 13, 0  ]\n    ,  [  0, 1,   2, 3,   4, 5,   6, 7,   8, 9,  10, 11, 12, 13, 14, 15 ]\n    ,  [ 14, 10,  4, 8,   9, 15, 13, 6,   1, 12,  0, 2,  11, 7,   5, 3  ]\n    ]\n\nR1,R2,R3,R4 : [6]\nR1 = 32\nR2 = 24\nR3 = 16\nR4 = 63\n\nG : [4] -> [4] -> LocalState -> [4][6] -> Block -> [16][64]\nG r i vec abcd ms = updates vec abcd new\n  where\n  new  = G' r i (vec @@ abcd) ms\n\nG' : [4] -> [4] -> [4][64] -> Block -> [4][64]\nG' r i vals ms = [a2, b2, c2, d2]\n  where\n  x = ms @ (SIGMA_TABLE @ r @ (2*i))\n  y = ms @ (SIGMA_TABLE @ r @ (2*i+1))\n  [a,b,c,d] = vals\n  a1 =  a + b + x\n  d1 = (d ^ a1) >>> R1\n  c1 =  c + d1\n  b1 = (b ^ c1) >>> R2\n  a2 =  a1 + b1 + y\n  d2 = (d1 ^ a2) >>> R3\n  c2 =  c1 + d2\n  b2 = (b1 ^ c2) >>> R4\n\n\/\/ Section 3.2: Compression function\nF : State -> Block -> Counter -> Bit -> State\nF h ms t f =  h ^ (take (vs!0)) ^ (drop (vs!0))\n where\n  v   = h # IV ^ (zero # [t0,t1,f0,zero])\n  [t1,t0] = split t : [2][64]\n  f0 = [f | _ <- [0..63] : [_][6]]\n  vs = [v] # [ round i ms v' | v' <- vs | i <- [0..11] ]\n\n\/\/ Sub-function of F (first for loop)\nround : [4] -> Block -> LocalState -> LocalState\nround r ms v = vs ! 0\n  where\n  vs = [v] # [ G r i v' ix ms\n                | v'   <- vs\n                | i    <- [0..7]\n                | ix   <- [ [0,4,8,12],  [1,5,9,13]\n                          , [2,6,10,14], [3,7,11,15]\n                          , [0,5,10,15], [1,6,11,12]\n                          , [2,7,8,13],  [3,4,9,14] ]\n              ]\n \/\/ ix (ms @ (s @ sIx1)) (ms @ (s @ sIx2))\n \/\/               | sIx1 <- [0,2,4,6,8,10,12,14] : [8][4]\n \/\/               | sIx2 <- [1,3,5,7,9,11,13,15] : [8][4]\n \/\/             ]\n\n\/\/ Section 3.3: Padding\n\/\/ Recall kk == key bytes  (0)\n\/\/        nn == hash bytes (64)\n\/\/        ll == input bytes (ceiling $ len \/ 8)\n\/\/        bb == block bytes (128, 1024 bits)\n\/\/        dd == nr Blocks\n\nblake2b : {ll,dd}\n         (fin ll, fin dd\n         , dd == (max 1 ((ll+127)\/128)) - 1\n         \/\/ ^^^ ugly  We'd like , dd == (ll-1)\/128  but then we can't hash the empty string\n         , 128 >= width ll\n         )\n          => [ll][8]\n          -> [512]\nblake2b m = blake2Finish ({ state = (hs!0).state, counter = `ll}) lastBlock\n where\n\n fullBlocks : [dd]Block\n fullBlocks = [mkBlock b | b <- split (take (join m))]\n\n partialBlock = drop `{128*dd} m\n\n lastBlock : Block\n lastBlock  =\n    if (`ll == (zero:[128]))\n        then zero \/\/ Special case full zero block for empty messages\n        else mkBlock ((split (join (partialBlock # (zero : [inf][8]))))@0)\n\n h : Context\n h  = { state = [IV@0 ^ `0x01010040] # drop `{1} IV, counter = 0 }\n\n hs : [dd+1]Context\n hs = [h] # [blake2Update h' dX |  h' <- hs | dX <- fullBlocks]\n\nblake2Update : Context -> Block -> Context\nblake2Update ctx d = { state = newState, counter = newCount }\n  where newState = F ctx.state d newCount False\n        newCount = ctx.counter + (128 : [128])\n\npostprocess : {ll} (128 >= ll, 128 >= width ll) => Counter -> [ll][8] -> Block\npostprocess c m =\n    if c == 0 \/\\ `ll == (zero:[128])\n        then zero\n        else split (join m # zero)\n\n\/\/ The final round of blake\nblake2Finish : Context -> Block -> [512]\n\/\/ blake2Finish ctx b = ctx.state@0 # zero\nblake2Finish ctx b = join [ reverseBytes w | w <- F ctx.state b ctx.counter True ]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/  Utilities\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nmkBlock x = reverse (split (reverseBytes x))\n\nreverseBytes x = join (reverse (bytes x))\n\nbytes x = split x : [_] [8]\n\ntestZeros =\n  and [ blake2b (zero : [128][8]) == 0x865939e120e6805438478841afb739ae4250cf372653078a065cdcfffca4caf798e6d462b65d658fc165782640eded70963449ae1500fb0f24981d7727e22c41\n      , blake2b (zero : [0][8]) == 0x786A02F742015903C6C6FD852552D272912F4740E15847618A86E217F71F5419D25E1031AFEE585313896444934EB04B903A685B1448B755D56F701AFE9BE2CE ]\n\ntestZerosLarge =\n  and [ blake2b (zero : [129][8]) == 0xa60edba343e7a6933c14d203d2e535f35e6deb6c8a4f8e624c1a6f6e2612860447cb4c37e5aa11bcf03b7c3eea7228eb8b998f922794f2d1b8f2dc63f03bd3fa\n      ]\n\ntestKATs =\n  and [ blake2b \"The quick brown fox jumps over the lazy dog\" == 0xA8ADD4BDDDFD93E4877D2746E62817B116364A1FA7BC148D95090BC7333B3673F82401CF7AA2E4CB1ECD90296E3F14CB5413F8ED77BE73045B13914CDCD6A918\n      ]\n\nproperty katsPass = and [ testZeros, testZerosLarge, testKATs ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Generator\/DRBG.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that specifies the AES-256-based s2n deterministic random bit generator (DRBG) with types, state record, instantiate\/reseed\/generate\/update\/uninstantiate functions, fixed test vectors, and a property testsPass asserting all test cases hold."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Generator::DRBG where\n\nimport Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256 as AES256\n\ntype keylen   = AES256::KeySize type blocklen = 128 type seedlen  = 384 type reseed_limit = 2 ^^ 35 \ntype blocksize = 16 type keysize = 32 type seedsize = 48\n\ntype cipher_ctx = { key : [keylen] }\n\nblock_encrypt : [keylen] -> [blocklen] -> [blocklen]\nblock_encrypt key data = AES256::encrypt key data\n\ntype s2n_drbg =\n  { bytes_used : [64]\n  , ctx : cipher_ctx\n  , v : [blocklen]\n  }\n\ndrbg_generate_internal : {n, blocks}\n                         ( fin n, fin blocks, n >= 1, n <= 8192\n                         , n == blocklen * blocks)\n                      => s2n_drbg\n                      -> ([n], s2n_drbg)\ndrbg_generate_internal drbg =\n  (join [ block_encrypt drbg.ctx.key (drbg.v + i) | i <- [1 .. blocks]], drbg')\n    where drbg' = { bytes_used = drbg.bytes_used + `(blocks * blocksize)\n                  , ctx = drbg.ctx\n                  , v = drbg.v + `blocks\n                  }\n\ndrbg_instantiate : {ps_size}\n                   (fin ps_size)\n                => [seedlen]\n                -> [ps_size]\n                -> s2n_drbg\ndrbg_instantiate entropy ps = drbg_reseed zero entropy ps'\n  where\n    \/* pad ps with zeros if needed to reach seedlen\n       otherwise truncate to seedlen *\/\n    ps' = take `{seedlen} (ps # (zero : [seedlen]))\n\ndrbg_reseed : {ps_size}\n              (ps_size <= seedlen)\n           => s2n_drbg\n           -> [seedlen]\n           -> [ps_size]\n\t   -> s2n_drbg\ndrbg_reseed drbg entropy ps = drbg''\n  where\n    drbg' = drbg_update (entropy ^ (ps # zero)) drbg\n    drbg'' = { v = drbg'.v, ctx = drbg'.ctx, bytes_used = 0}\n\ndrbg_uninstantiate : s2n_drbg -> s2n_drbg\ndrbg_uninstantiate drbg = zero\n\n\/* This is the spec of the s2n code, in that it reseeds automatically\n   if reseed is required. This is in opposition to the spec, which\n   requires an error code.\n\n   We are curious about why s2n_drbg counts a number of bytes used,\n   while the spec tracks a number of calls to generate. We don't\n   belive that this is buggy behavior, since if we call the maximum\n   size with generate each time, we will reseed before the spec would\n   require it. *\/\ndrbg_generate : {n, blocks} (fin n, fin blocks, n >= 1, n <= 8192,\n                             blocks * blocklen >= n,\n                             (blocks - 1) * blocklen <= n - 1) =>\n                s2n_drbg -> [seedlen] -> Bit ->\n                ([n], s2n_drbg)\ndrbg_generate drbg entropy reseed_p = (take enc_result, drbg_out)\n  where\n        drbg_r =\n      if reseed_p \\\/ drbg.bytes_used + `n * 8 + `blocklen * 8 >= `reseed_limit then\n        drbg_reseed drbg entropy (zero : [256])\n      else drbg\n        (enc_result, drbg_v) = drbg_generate_internal `{blocks=blocks} drbg_r\n        drbg_out = drbg_update zero drbg_v\n\ndrbg_update : [seedlen] -> s2n_drbg -> s2n_drbg\ndrbg_update data drbg = result\n  where\n            type blocks = (seedlen + blocklen -1)\/blocklen\n        (enc_result, _) = drbg_generate_internal `{blocks=blocks} drbg\n        data_xor = (take enc_result) ^ data\n            result = { bytes_used = drbg.bytes_used + (`blocks * `blocksize)\n             , ctx = { key = take data_xor }\n             , v = drop data_xor\n             }\n\ntestInstantiate0 = {entropy = 0xe4bc23c5089a19d86f4119cb3fa08c0a4991e0a1def17e101e4c14d9c323460a7c2fb58e0b086c6c57b55f56cae25bad,\n                    pString = zero : [0],\n                        Key = 0xb7b3a93ecfdf2f61c622ad3afb6bff818736a09c9391157e1902d10a79d0db12,\n                               V = 0x0e4fb6443cae46188617aad8bfe46e23}\n\ntestInstantiatedrbg0 = drbg_instantiate`{ps_size=0} testInstantiate0.entropy testInstantiate0.pString\n\ntestInstantiate0Pass = testInstantiatedrbg0.v == testInstantiate0.V \/\\ testInstantiatedrbg0.ctx.key == testInstantiate0.Key\n\ntestReseed0 = {entropyReseed = 0xfd85a836bba85019881e8c6bad23c9061adc75477659acaea8e4a01dfe07a1832dad1c136f59d70f8653a5dc118663d6,\n                          Key = 0xd230044c2594510d195ffe9923de8848bdbd19f24d0e7558b28e55b2d4de7841,\n                                V = 0xe18637ff12f514f37adc2013a40f38c1}\n\ntestReseed0Pass = drbgreseed.v == testReseed0.V \/\\ drbgreseed.ctx.key == testReseed0.Key\n                where drbgreseed = drbg_reseed`{ps_size=0} testInstantiatedrbg0 testReseed0.entropyReseed zero\n\ntestGenerate0 = {      Key = 0xec871bb7a4f2c45dccdd0e514a21628959aa21e9643934f619b2709b3e38697c,\n                       V   = 0xd8bbe7bfc60bfb710f39acd1088c9f41}\n\ntestGeneratedrbg0 = (drbg_generate`{n=512} testInstantiatedrbg0 testReseed0.entropyReseed True).1\n\ntestGenerate0Pass = testGeneratedrbg0.v == testGenerate0.V \ntestGenerateSnd0 = {returnedBits = 0xb2cb8905c05e5950ca31895096be29ea3d5a3b82b269495554eb80fe07de43e193b9e7c3ece73b80e062b1c1f68202fbb1c52a040ea2478864295282234aaada,\n                       Key = 0xe728308a0e92cbacb269d12246d8e2d24cf5fcc678aa09564132e4972c456eda,\n                       V   = 0xc95f38da34ecb65ebf8b34c32bc215a5}\n\ntestGenerateSnd0Pass = and [ result == testGenerateSnd0.returnedBits\n                           , drbg.ctx.key == testGenerateSnd0.Key\n                           , drbg.v == testGenerateSnd0.V ]\n                     where (result,drbg) = drbg_generate`{n=512} testGeneratedrbg0 zero False\n\nproperty testsPass = and [testInstantiate0Pass, testReseed0Pass, testGenerate0Pass, testGenerateSnd0Pass]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Primitive::Keyless::Hash::SHA2::Specification that implements the SHA-2 hash function family (w \u2208 {32,64}) with parameters H0 and DigestSize, including the padding, message schedule, round function, hash, hashBytes, and the listed correctness properties for rotations and encodings."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Specification where\n\nparameter\n\n    type w : #\n    type constraint (w % 32 == 0, 32 <= w, 64 >= w)\n\n    type DigestSize : #\n    type constraint (8 * w >= DigestSize, DigestSize % 8 == 0)\n\n    H0 : [8][w]\n\ntype MessageUpperBound = 2 * w\ntype constraint ValidMessageLength L = width L <= MessageUpperBound\n\ntype DigestLength = DigestSize\n\ntype SecurityStrength = DigestSize \/ 2\n\nprivate\n\n    type BlockSize = 16 * w\n\n    type ScheduleLength = 48 + w \/ 2\n\n    ROTL : {n} (n < w) => [w] -> [w]\n    ROTL x = x <<< `n\n\n    ROTR : {n} (n < w) => [w] -> [w]\n    ROTR x = x >>> `n\n\n    rotationEquivalenceRelationsHold : {n} (n < w) => [w] -> Bool\n    property rotationEquivalenceRelationsHold x = left && right where\n        left = ROTL`{n} x == ROTR`{(w - n) % w} x\n        right = ROTR`{n} x == ROTL`{(w - n) % w} x\n\n    SHR : {n} (n < w) => [w] -> [w]\n    SHR x = x >> `n\n\n    property hexDigitsEncodeCorrectly = (0x7 == 0b0111) && (0xa == 0b1010)\n\n    property wordsEncodeCorrectly = short && long where\n        short = 0xa103fe23 == 0b10100001000000111111111000100011\n        long = 0xa103fe2332ef301a == 0b1010000100000011111111100010001100110010111011110011000000011010\n\n    property integersEncodeCorrectly = 291 == 0x00000123\n\n    Ch : [w] -> [w] -> [w] -> [w]\n    Ch x y z = (x && y) ^ (~x && z)\n\n    Maj : [w] -> [w] -> [w] -> [w]\n    Maj x y z = (x && y) ^ (x && z) ^ (y && z)\n\n    Sigma0: [w] -> [w]\n    Sigma0 x\n        | w == 32 => ROTR`{ 2} x ^ ROTR`{13} x ^ ROTR`{22} x\n        | w == 64 => ROTR`{28} x ^ ROTR`{34} x ^ ROTR`{39} x\n\n    Sigma1: [w] -> [w]\n    Sigma1 x\n        | w == 32 => ROTR`{ 6} x ^ ROTR`{11} x ^ ROTR`{25} x\n        | w == 64 => ROTR`{14} x ^ ROTR`{18} x ^ ROTR`{41} x\n\n    sigma0: [w] -> [w]\n    sigma0 x\n        | w == 32 => ROTR`{7} x ^ ROTR`{18} x ^ SHR`{3} x\n        | w == 64 => ROTR`{1} x ^ ROTR`{ 8} x ^ SHR`{7} x\n\n    sigma1: [w] -> [w]\n    sigma1 x\n        | w == 32 => ROTR`{17} x ^ ROTR`{19} x ^ SHR`{10} x\n        | w == 64 => ROTR`{19} x ^ ROTR`{61} x ^ SHR`{ 6} x\n\n    K : [ScheduleLength][w]\n    K | w == 32 => [\n        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]\n      | w == 64 => [\n        0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n        0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n        0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n        0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n        0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n        0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n        0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n        0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n        0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n        0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n        0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n        0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n        0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n        0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n        0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n        0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n        0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n        0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n        0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n        0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817]\n\n    type LengthBits = 2 * w\n\n    type NumBlocks L = (L + 1 + LengthBits) \/^ BlockSize\n\n    pad : {L} (ValidMessageLength L) => [L] -> [NumBlocks L * BlockSize]\n    pad M = M # 0b1 # zero # (`L : [LengthBits])\n\n    paddingExampleWorks : Bool\n    paddingExampleWorks\n        | w == 32 => pad (join \"abc\") == (0b01100001 # 0b01100010 # 0b01100011\n            # 0b1 # (zero : [423]) # (zero : [59]) # 0b11000)\n        | w == 64 => pad (join \"abc\") == (0b01100001 # 0b01100010 # 0b01100011\n            # 0b1 # (zero : [871]) # (zero : [123]) # 0b11000)\n\n    parse : {N} () => [N * BlockSize] -> [N][BlockSize]\n    parse M = split M\n\nhash: {l} (ValidMessageLength l) => [l] -> [DigestSize]\nhash M = take (join (digest ! 0)) where\n    digest = [H0] # [Hi'\n        where\n            \/\/ Step 1. Prepare the message schedule.\n            Ws = messageSchedule (split Mi)\n\n            \/\/ Step 2. Initialize the eight working variables with the\n            \/\/ previous hash value.\n            letters = [(Hi0, Hi1, Hi2, Hi3, Hi4, Hi5, Hi6, Hi7)] # [\n                \/\/ Step 3. Update temporary and working variables...\n                variableUpdate l Kt Wt\n                | l <- letters\n\n                \/\/ ...for t=0 to `ScheduleLength`.\n                | Wt <- Ws\n                | Kt <- K\n            ]\n            (a, b, c, d, e, f, g, h) = letters ! 0\n\n            \/\/ Step 4. Compute the next intermediate hash value.\n            \/\/ Note that in the spec, this is denoted H^(i).\n            Hi' = [a + Hi0, b + Hi1, c + Hi2, d + Hi3, e + Hi4, f + Hi5, g + Hi6, h + Hi7]\n\n                | Mi <- parse (pad M)\n\n                        | [Hi0, Hi1, Hi2, Hi3, Hi4, Hi5, Hi6, Hi7] <- digest\n    ]\n\n        messageSchedule : [16][w] -> [ScheduleLength][w]\n    messageSchedule Mi = take W where\n        W : [inf][w]\n        W = Mi # [ sigma1 w2 + w7 + sigma0 w15 + w16\n                                                | w16 <- W\n            | w15 <- drop`{1} W\n            | w7  <- drop`{9} W\n            | w2  <- drop`{14} W\n        ]\n\n        type LetterVars = ([w], [w], [w], [w], [w], [w], [w], [w])\n\n        variableUpdate : LetterVars -> [w] -> [w] -> LetterVars\n    variableUpdate (a, b, c, d, e, f, g, h) Kt Wt =\n        (a', b', c', d', e', f', g', h')\n        where\n            T1 = h + Sigma1 e + Ch e f g + Kt + Wt\n            T2 = Sigma0 a + Maj a b c\n            h' = g\n            g' = f\n            f' = e\n            e' = d + T1\n            d' = c\n            c' = b\n            b' = a\n            a' = T1 + T2\n\nhashBytes: {l} (ValidMessageLength (8 * l)) => [l][8] -> [DigestSize \/ 8][8]\nhashBytes M = groupBy`{8} (hash (join M))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/KeccakBitOrdering.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that specifies the SHA-3\/Keccak bit and byte ordering utilities (toBytes, fromBytes, reverseBitOrdering, truncate, h2b, b2h) and includes properties proving involution and mutual inversion (e.g., reverseBitOrderingInvolutes, h2bAndb2hInvert, b2hAndh2bInvert)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::KeccakBitOrdering where\n\ntoBytes : {n} (fin n) => [8*n] -> [n][8]\ntoBytes s = reverse (split (reverse s))\n\nfromBytes : {n} (fin n) => [n][8] -> [8*n]\nfromBytes bs = reverse (join (reverse bs))\n\nreverseBitOrdering : {m} [m] -> [m]\nreverseBitOrdering msg\n    | m == inf => join (map reverse (groupBy`{8} msg))\n    | fin m => (flipped_full_bytes # flipped_remainder) where\n                        type Bytes = 8 * (m \/ 8)\n        flipped_full_bytes = join (map reverse (groupBy`{each=8, parts=m \/ 8} (take`{Bytes} msg)))\n        flipped_remainder = reverse (drop`{Bytes} msg)\n\nreverseBitOrderingInvolutes : {m} (fin m) => [m] -> Bit\nproperty reverseBitOrderingInvolutes msg = reReverse == msg where\n    reReverse = reverseBitOrdering (reverseBitOrdering msg)\n\ntruncate : {n, m} (fin m, fin n, m >= n, m % (2 * HexDigit) == 0) => [m] -> [n]\ntruncate msg = reverseBitOrdering (take (reverseBitOrdering msg))\n\nreverseMatchesh2b : {m} (fin m, m > 0) => [2 * m * HexDigit] -> Bool\nproperty reverseMatchesh2b msg = h2b msg == reverseBitOrdering msg\n\ntruncateAndReverseMatchesh2b : {m, n} (fin m, m > 0, n > 0, 2 * HexDigit * m >= n) => [2 * m * HexDigit] -> Bool\nproperty truncateAndReverseMatchesh2b msg = h2b_result == rt_result where\n    h2b_result = h2b`{n} msg\n    rt_result = reverseBitOrdering (truncate`{n} msg)\n\nreverseMatchesb2h : {n} (fin n, n > 0) => [2 * n * HexDigit] -> Bool\nreverseMatchesb2h msg = b2h msg == reverseBitOrdering msg\n\nreverseAndTruncateMatchesb2h : {n} (fin n, n > 0) => [n] -> Bool\nproperty reverseAndTruncateMatchesb2h bits = b2h_result == rev_result where\n    b2h_result = truncate`{n} (b2h bits)\n    rev_result = reverseBitOrdering bits\n\ntype HexDigit = 4\n\nh2b: {n, m} (fin m, m > 0, n > 0, n <= 8 * m) => [2 * m * HexDigit] -> [n]\nh2b msg = S where\n        H = groupBy`{HexDigit} msg\n            H8 = map zext H : [2 * m][8]\n        hs = [16 * H8 @ (2 * i) + H8 @ (2 * i + 1) | i <- [0..m-1]]\n            bs = map reverse hs\n        T = join bs\n        S = take`{n} T\n\nproperty h2bExampleWorks = h2b`{14} H == S where\n    H = 0xA32E\n    S = 0b11000101011101\n\nb2h : {n} (fin n, n > 0) => [n] -> [2 * (n \/^ 8) * HexDigit]\nb2h S = H where\n            T = S # (zero : [(8 - (n % 8)) % 8])     type m = n \/^ 8\n        b = [[ T@(8 * i + j) | j <- [0..7]] | i <- [0..m-1]]\n        h = [reverse bs | bs <- b]\n        Hs = [split`{2, HexDigit} hi | hi <- h]\n    H = join (join Hs)\n\nzero_length_is_correct : Integer -> Bool\nproperty zero_length_is_correct n = (-n) % 8 == (8 - (n % 8)) % 8\n\nh2bAndb2hInvert : {m} (fin m, m > 0) => [2 * m * HexDigit] -> Bool\nproperty h2bAndb2hInvert msg = b2h (h2b`{2 * m * HexDigit} msg) == msg\n\nh2bAndb2hInvertForShortStrings : {m, n} (fin m, m > 0, n > 0, n \/^ (2 * HexDigit) == m) => [n] -> Bool\nproperty h2bAndb2hInvertForShortStrings msg = b2h (h2b`{n} hexMsg) == hexMsg where\n    hexMsg = reverseBitOrdering ((reverseBitOrdering msg) # zero) : [2 * m * HexDigit]\n\nb2hAndh2bInvert: {n} (fin n, n > 0) => [n] -> Bool\nproperty b2hAndh2bInvert msg = h2b (b2h msg) == msg\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Keyless::Hash::SHA3::Specification` that specifies the Keccak\/SHA-3 sponge construction and Keccak-p\/Keccak-f permutations, including state flatten\/unflatten functions, pad10*1 padding, round constants (and hardcoded versions), and properties proving their correctness and equivalence."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Specification where\n\nparameter\n\n    type b : #\n    type constraint (fin b, b % 25 == 0, b <= 1600, (2 ^^ (lg2 (b \/ 25))) * 25 == b)\n\n    type nr : #\n    type constraint (fin nr, nr > 0)\n\n    type c : #\n    type constraint (fin c, c < b, c > 0)\n\nKeccak : {d, m} (fin m) => [m] -> [d]\nKeccak M = digest where\n        P = M # pad `{x = r, m = m}\n                type n = (m + 2) \/^ r\n            Ps = split P : [n][r]\n        S = zero : [b]\n        Ss = [S] # [Keccak_p (S' ^ (Pi # (zero : [c]))) | Pi <- Ps | S' <- Ss]\n                extend : [b] -> [inf]\n    extend Z = (take`{r} Z) # extend (Keccak_p Z)\n    digest = take`{front=d, back=inf} (extend (Ss ! 0))\n\nprivate\n\n    type r = b - c\n\n    type w = b \/ 25\n\n    type ell = lg2 w\n\n    type State = [5][5][w]\n\n    unflatten : [b] -> State\n    unflatten S = [[ Lanes@((5 * y + x))\n        | y <- [0..4]]\n        | x <- [0..4]] where\n        Lanes = map reverse (split`{25} S)\n\n    unflatten_noindex : [b] -> State\n    unflatten_noindex S = transpose (groupBy (reverse (groupBy`{w} (reverse S))))\n\n    property unflattens_match S = unflatten S == unflatten_noindex S\n\n    flatten : State -> [b]\n    flatten A = S where\n                                Lanes = [[ reverse (A@i@j)\n            | j <- [0..4]]\n            | i <- [0..4]]\n        Planes = [ Lanes@0@j # Lanes@1@j # Lanes@2@j # Lanes@3@j # Lanes@4@j\n            | j <- [0..4]]\n        S = join Planes\n\n    flatten_noindex : State -> [b]\n    flatten_noindex A = reverse (join (reverse (join (transpose A))))\n\n    property flattens_match A = flatten A == flatten_noindex A\n\n    \u03b8 : State -> State\n    \u03b8 A = A' where\n        C = [ A@x@0 ^ A@x@1 ^ A@x@2 ^ A@x@3 ^ A@x@4\n            | x <- [0..4]]\n        D = [ C @ ((x - 1) % 5) ^ (C @ ((x + 1) % 5) <<< 1)\n            | x <- [0..4]]\n        A' = [[ A@x@y ^ D@x\n            | y <- [0..4]]\n            | x <- [0..4] ]\n\n    \u03c1 : State -> State\n    \u03c1 A = A' where\n        \/\/ Step 1.\n        A1 = [[ if (x == 0) && (y == 0) then A@0@0 else zero\n            | y <- [0..4]]\n            | x <- [0..4]]\n        \/\/ Step 2-3.\n        As = [((1,0), A1)] #\n            [ ((y, (2*x + 3*y) % 5), set_lane x y t Ai)\n            | ((x, y), Ai) <- As\n            | t <- [0..23]]\n        (_, A') = As ! 0\n\n                set_lane x' y' t Ai = [[\n            if (x' == x) && (y' == y) then A@x@y <<< ((t+1)*(t+2)\/2)\n            else Ai@x@y\n            | y <- [0..4]]\n            | x <- [0..4]]\n\n    \u03c1_hardcoded : State -> State\n    \u03c1_hardcoded A = A' where\n        A' = groupBy [ a <<< offset | a <- join A | offset <- t_offsets]\n\n                                        t_offsets = [\n            0x000, 0x024, 0x003, 0x069, 0x0d2,\n            0x001, 0x12c, 0x00a, 0x02d, 0x042,\n            0x0be, 0x006, 0x0ab, 0x00f, 0x0fd,\n            0x01c, 0x037, 0x099, 0x015, 0x078,\n            0x05b, 0x114, 0x0e7, 0x088, 0x04e\n        ]\n\n    property hardcoded_rho_is_correct A = \u03c1 A == \u03c1_hardcoded A\n\n    \u03c0 : State -> State\n    \u03c0 A = [[ A @((x + 3 * y) % 5) @x\n        | y <- [0..4]]\n        | x <- [0..4]]\n\n    \u03c7 : State -> State\n    \u03c7 A = [[ A @x @y ^ (~A @((x + 1) % 5) @y && A @((x + 2) % 5) @y)\n        | y <- [0..4]]\n        | x <- [0..4]]\n\n    rc : Integer -> Bit\n    rc t = if (t % 255) == 0 then 1          else Rs @ (t') @0 \/\/ Step 4.\n         where\n             \/\/ Step 2 - 3.\n             Rs = [0b10000000] # [lfsr R | R <- Rs ]\n             \/\/ Step 3. Linear feedback shift register.\n             \/\/ The truncation in step f is done manually in the return value.\n             lfsr : [8] -> [8]\n             lfsr Rin = [R0, R@1, R@2, R@3, R4, R5, R6, R@7]\n                 where\n                     R = 0b0 # Rin\n                     R0 = R@0 ^ R@8\n                     R4 = R@4 ^ R@8\n                     R5 = R@5 ^ R@8\n                     R6 = R@6 ^ R@8\n             \/\/ Cryptol's SMT interface disallows index by symbolic `Integer`.\n                                                    t' = fromInteger (t % 255) : [8]\n\n    \/**\n     * Hardcode the round constant values.\n     *\n     * Since the `rc` function doesn't depend on any of the functor parameters,\n     * this hardcoded value is correct for all instantiations.\n     * We computed the value `constants` with:\n     * ```cryptol\n     * [rc i | i <- [0..255]]\n     * ```\n     *\n     * This provides a 4x speedup.\n     *\n     * Equivalent to [FIPS-202] Section 3.2.5, Algorithm 5.\n     *\/\n    rc_hardcoded : Integer -> Bit\n    rc_hardcoded t = constants @ (t') where\n        constants = join [\n            0x80b1e87f90a7d57062b32fde6ee54a25,\n            0xa339e361175edf0d35b504ec9303a471\n        ]\n        \/\/ Cryptol's SMT interface disallows index by symbolic `Integer`.\n                                t' = fromInteger (t % 255) : [8]\n\n    \/*\n     * Some properties justifying the conversion of `Integer -> [8]`\n     * in `rc` and `rc_hardcoded`\n     *\/\n    private\n        \/**\n        * A fact about modular arithmetic:\n        *   For any integers `i`, `m`, `n`, such that `m > 0` and `m < n`,\n        *   `i mod m mod n == i mod m`\n        *   I.e., the modular reduction is equivalent to the smaller modulus.\n        *\/\n        index_eq: {ix} (Integral ix, Cmp ix, Literal 0 ix) => ix -> ix -> ix -> Bit\n        index_eq i m n = m > 0 ==> m <= n ==> (i % m) % n == (i % m)\n\n        \/**\n        * An instance of the fact above for Cryptol `Integer`.\n        * ```repl\n        * :prove index_eq_int\n        * ```\n        *\/\n        property index_eq_int = index_eq `{Integer}\n\n        \/**\n        * A consequence of the property above is that reducing an integer\n        * mod 255 and then converting it to an `[8]` is always in `Z 255`.\n        * ```repl\n        * :prove value_bound\n        * ```\n        *\/\n        value_bound: Integer -> Bit\n        property value_bound i = (fromInteger (i % 255) : [8]) < 255\n\n    \/**\n     * Prove that the hardcoded round constants are correct.\n     * ```repl\n     * :prove round_constants_correctly_hardcoded\n     * ```\n     *\/\n    property round_constants_correctly_hardcoded t = rc_hardcoded t == rc t\n\n    \/**\n     * One of the step mappings that's part of a round of Keccak-p.\n     *\n     * The effect is to modify some of the bits of the Lane defined by\n     * `(0, 0)` according to the round index.\n     * [FIPS-202] Section 3.2.5, Algorithm 6.\n     *\/\n    \u03b9 : State -> Integer -> State\n    \u03b9 A ir = A'' where\n                A' = A\n        \/\/ Step 2.\n        RC0 = zero : [w]\n        \/\/ Step 3. 0 is the identity for XOR, so we iteratively set the\n        \/\/ `2^j-1`th element by XORing the previously-set bits of RC with the\n        \/\/ correct value at the desired index.\n        RCs = [RC0] # [RC' ^ (zext`{w} [rc_hardcoded (toInteger j + 7 * ir)] << (2^^j - 1))\n            | RC' <- RCs\n            | j <- [0..ell] ]\n        RC = (RCs ! 0) : [w]\n        \/\/ Step 4.\n        A'' = [[ if (x == 0) && (y == 0) then A'@0@0 ^ RC else A'@x@y\n            | y <- [0..4]]\n            | x <- [0..4]]\n\n    \/**\n     * Padding rule `pad10*1`.\n     *\n     * This function produces padding e.g. a string with an appropriate length\n     * to append to another string.\n     * [FIPS-202] Section 5.1.\n     *\n     * Note: The spec says the output length is a positive multiple of `x` and\n     * defines it to be, basically: `(- m - 2) mod x + 2`. We can't encode this\n     * exactly as-is in the type signature because Cryptol doesn't support\n     * negative numbers in types (`-m`). Instead, we do the following:\n     *      (m + 2)           : The minimum length of the original message and\n     *                        : the padding\n     *      (m + 2) \/^ x      : The multiplier of `x` that determines the\n     *                        : ultimate length of the message + padding\n     * x * ((m + 2) \/^ x)     : The total length of the message + padding\n     * x * ((m + 2) \/^ x) - m : The total length of the padding alone\n     *\/\n    pad : {x, m} (fin x, fin m, x >= 1) => [x * ((m + 2) \/^ x) - m]\n    pad = [1] # zero # [1]\n\n    \/**\n     * The Keccak-p[b, nr] permutation.\n     * [FIPS-202] Section 3.3, Algorithm 7.\n     *\/\n    Keccak_p : [b] -> [b]\n    Keccak_p S = S' where\n                Rnd A ir = \u03b9 (\u03c7 (\u03c0 (\u03c1_hardcoded (\u03b8 A)))) ir\n\n                A0 = unflatten_noindex S\n                                        As = [A0] # [ Rnd A ir where\n                ir = 12 + 2 * `ell - r\n            | A <- As\n            | r <- [nr, nr - 1 .. 1]]\n                S' = flatten_noindex (As ! 0)\n\n    \/**\n     * Keccak-f family of permutations.\n     *\n     * This specializes `Keccak-p` to the case where `nr = 12 + 2*ell`; we\n     * enforce this in the type constraint on this function.\n     * [FIPS-202] Section 3.4.\n     *\/\n    Keccak_f : (nr == 12 + 2 * ell) => [b] -> [b]\n    Keccak_f = Keccak_p\n\n\/**\n * See https:\/\/keccak.team\/files\/Keccak-reference-3.0.pdf, Section 1.2\n * ```repl\n * :prove unflatten_correct\n * ```\n *\/\nunflatten_correct : [12] -> [12] -> [12] -> [b] -> Bit\nproperty unflatten_correct x y z p =\n    x < 5 ==> y < 5 ==> z < (`w:[12]) ==>\n    p@((5*y + x)*`w + z) == unflatten p @ x @ y ! z\n\n\/**\n * Flatten and unflatten must be each other's inverses.\n * ```repl\n * :prove flatten_correct\n * ```\n *\/\nproperty flatten_correct s = unflatten (flatten s) == s\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/SHA3.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module for SHA-3 that parameterizes the digest size, implements the sha3, hash, and hashBytes functions using Keccak with appropriate bit-ordering and padding, and exposes DigestLength, MessageUpperBound, and SecurityStrength type aliases."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::SHA3 where\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\nimport Primitive::Keyless::Hash::SHA3::Specification where\n    type b = 1600\n    type nr = 24\n    type c = 2 * digest\n\nparameter\n\n    type digest : #\n    type constraint (fin digest, digest % 8 == 0, digest >= 224, digest <= 512)\n\ntype DigestLength = digest\n\ntype MessageUpperBound = inf\n\ntype SecurityStrength = DigestLength \/ 2\n\nsha3 : {n} (fin n) => [n] -> [digest]\nsha3 M = Keccak`{d=digest} (M # 0b01)\n\nhash : {n} (fin n) => [n] -> [digest]\nhash M = KBO::reverseBitOrdering (Keccak`{d=digest} ((KBO::reverseBitOrdering M) # 0b01))\n\nhashBytes : {m} (fin m) => [m][8] -> [digest \/ 8][8]\nhashBytes M = split (hash (join M))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing the SHA-384 hash function using 64-bit word operations and the given initial hash values H0, round constants K, and sigma\/SIGMA functions, and expose a top-level function `sha384 : [inf][8] -> [384]` for hashing byte streams."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2Internal::SHA384 = Primitive::Keyless::Hash::SHA2Internal::SHA where\n\ntype wp = 64\n\ntype digest_size = 384\n\ntype j = 80\n\nH0 = [ 0xcbbb9d5dc1059ed8, 0x629a292a367cd507, 0x9159015a3070dd17, 0x152fecd8f70e5939,\n       0x67332667ffc00b31, 0x8eb44a8768581511, 0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4]\n\nK = [ 0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n      0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n      0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n      0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n      0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n      0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n      0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n      0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n      0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n      0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n      0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n      0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n      0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n      0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n      0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n      0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n      0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n      0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n      0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n      0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817]\n\nSIGMA_0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)\n\nSIGMA_1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)\n\nsigma_0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)\n\nsigma_1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing the SHA-256 hash function using 32-bit words, 64 rounds, the given IV H0 and round constants K, and define the external function sha256 : [inf][8] -> [256] along with standard NIST test-vector properties."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2Internal::SHA256 = Primitive::Keyless::Hash::SHA2Internal::SHA where\n\ntype wp = 32\n\ntype digest_size = 256\n\ntype j = 64\n\nH0 = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n       0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]\n\nK = [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]\n\nSIGMA_0 x = (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)\n\nSIGMA_1 x = (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)\n\nsigma_0 x = (x >>> 7) ^ (x >>> 18) ^ (x >> 3)\n\nsigma_1 x = (x >>> 17) ^ (x >>> 19) ^ (x >> 10)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/Equivalence.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, write a module Primitive::Keyless::Hash::SHA2Internal::Equivalence that defines properties asserting functional equivalence between the high-level and internal implementations of SHA-256 and SHA-384, for both bitwise and bytewise hashing, using the functions hash, hashBytes, sha, and SHAImp with appropriate message bounds."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2Internal::Equivalence where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA_256\nimport Primitive::Keyless::Hash::SHA2Internal::SHA256 as SHAI_256\n\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 as SHA_384\nimport Primitive::Keyless::Hash::SHA2Internal::SHA384 as SHAI_384\n\nsha256ImplsAreEquivalent : {m} (fin m, width m <= SHA_256::MessageUpperBound) => [m] -> Bit\nproperty sha256ImplsAreEquivalent m = SHA_256::hash m == SHAI_256::sha m\n\nsha256BytewiseImplsAreEquivalent : {m} (fin m, width (8 * m) <= SHA_256::MessageUpperBound) => [m][8] -> Bit\nproperty sha256BytewiseImplsAreEquivalent m = join (SHA_256::hashBytes m) == SHAI_256::SHAImp m\n\nsha384ImplsAreEquivalent : {m} (fin m, width m <= SHA_384::MessageUpperBound) => [m] -> Bit\nproperty sha384ImplsAreEquivalent m = SHA_384::hash m == SHAI_384::sha m\n\nsha384BytewiseImplsAreEquivalent : {m} (fin m, width (8 * m) <= SHA_384::MessageUpperBound) => [m][8] -> Bit\nproperty sha384BytewiseImplsAreEquivalent m = join (SHA_384::hashBytes m) == SHAI_384::SHAImp m\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2Internal\/SHA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module implementing the internal SHA-2 compression and hashing functions over a parameterized word size, including streaming state-based APIs (SHAInit, SHAUpdate, SHAFinal, SHAImp, SHAImp_Array) and the lemma arrayRangeEqual_arrayRangeLookup_lemma with the same types and behavior as described."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2Internal::SHA where\n\nimport Array\nimport Common::ByteArray\n\nsha : {L} (2 * w >= width L) => [L] -> [digest_size]\nsha M = take (join (SHA_2_Common' [ split x | x <- parse`{num_blocks L} (pad`{L} M) ]))\n\nparameter\n\n  \/** Word size\n    Specifications are based on word size w, rather than digest size (8 * w)\n    or block size (m == 16 * w), in order to avoid confusing Cryptol's type\n    constraint verifier with integer division.\n  *\/\n\n  type wp : #\n  type constraint (fin wp, wp >= 2, 32 >= width wp)\n\n  type digest_size : #\n  type constraint (fin digest_size, 8*wp >= digest_size)\n\n  type j : #\n  type constraint (fin j, j >= 17)\n\n  H0 : [8][wp]\n  K  : [j][wp]\n\n  SIGMA_0 : [wp] -> [wp]\n  SIGMA_1 : [wp] -> [wp]\n  sigma_0 : [wp] -> [wp]\n  sigma_1 : [wp] -> [wp]\n\nSHAH0 = H0\nS0 = SIGMA_0\nS1 = SIGMA_1\ns0 = sigma_0\ns1 = sigma_1\ntype digestSize = digest_size\n\ntype securityStrength = digest_size \/ 2\n\nCh : [wp] -> [wp] -> [wp] -> [wp]\nCh x y z = (x && y) ^ (~x && z)\n\nMaj : [wp] -> [wp] -> [wp] -> [wp]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nprocessBlock_Common : [8][wp] -> [16][wp] -> [8][wp]\nprocessBlock_Common H Mi = compress_Common H (messageSchedule_Common Mi)\n\nprivate\n  type w = wp\n\n  type block_size = 16 * w\n\n  type num_blocks L     = (L+1+2*w) \/^ block_size\n  type padded_size L    = num_blocks L * block_size\n\n  pad : {L} (2 * w >= width L) => [L] -> [padded_size L]\n  pad M = M # 0b1 # zero # (`L : [2*w])\n\n  parse : {m} [m * block_size] -> [m][block_size]\n  parse = split\n\n  messageSchedule_Common : [16][w] -> [j][w]\n  messageSchedule_Common Mi = take W\n    where\n    W : [inf][_]\n    W = Mi # [ w1 + s0 w2 + w3 + s1 w4\n             | w1 <- W\n             | w2 <- drop`{1} W\n             | w3 <- drop`{9} W\n             | w4 <- drop`{14} W\n             ]\n\n  compress_Common : [8][w] -> [j][w] -> [8][w]\n  compress_Common H W =\n        [ (as ! 0) + (H @ 0),\n      (bs ! 0) + (H @ 1),\n      (cs ! 0) + (H @ 2),\n      (ds ! 0) + (H @ 3),\n      (es ! 0) + (H @ 4),\n      (fs ! 0) + (H @ 5),\n      (gs ! 0) + (H @ 6),\n      (hs ! 0) + (H @ 7)\n    ]\n    where\n      T1 = [h + S1 e + Ch e f g + k_t + w_t\n                | h <- hs | e <- es | f <- fs | g <- gs | k_t <- K | w_t <- W]\n      T2 = [ S0 a + Maj a b c | a <- as | b <- bs | c <- cs]\n      hs = take`{j + 1}([H @ 7] # gs)\n      gs = take`{j + 1}([H @ 6] # fs)\n      fs = take`{j + 1}([H @ 5] # es)\n      es = take`{j + 1}([H @ 4] # [d + t1 | d <- ds | t1 <- T1])\n      ds = take`{j + 1}([H @ 3] # cs)\n      cs = take`{j + 1}([H @ 2] # bs)\n      bs = take`{j + 1}([H @ 1] # as)\n      as = take`{j + 1}([H @ 0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\n  SHA_2_Common' : {L} (fin L) => [L][16][w] -> [8][w]\n  SHA_2_Common' blocks = hash ! 0\n    where\n    hash = [H0] # [ processBlock_Common h b | h <- hash | b <- blocks]\n\ntype SHAState = { h : [8][w]\n                , block : [w * 2][8]\n                , n : [32]\n                , sz : [w * 2]\n                }\n\nSHAInit : SHAState\nSHAInit = { h = H0\n          , block = zero\n          , n = 0\n          , sz = 0\n          }\n\nSHAUpdate : {n} (fin n) => SHAState -> [n][8] -> SHAState\nSHAUpdate sinit bs = ss!0\n  where ss = [sinit] # [ SHAUpdate1 s b | s <- ss | b <- bs ]\n\nSHAFinal : SHAState -> [digest_size]\nSHAFinal s = take (join (processBlock_Common h b'))\n  \/\/ Because the message is always made up of bytes, and the size is a\n  \/\/ fixed number of bytes, the 1 pad will always be at least a byte.\n  where s' = SHAUpdate1 s 0x80\n                                        (h, b) = if s'.n <= (`w*2 - (`w\/4)) then (s'.h, s'.block)\n                 else (processBlock_Common s'.h (split (join s'.block)), zero)\n        b' = split (join b || (zero # s.sz))\n\nSHAImp : {n} (fin n) => [n][8] -> [digest_size]\nSHAImp msg = SHAFinal (SHAUpdate SHAInit msg)\n\nprivate\n\n          SHAUpdate1 : SHAState -> [8] -> SHAState\n  SHAUpdate1 s b =\n    if s.n == (2 * `w - 1)\n      then { h = processBlock_Common s.h (split (join (update s.block s.n b)))\n           , block = zero\n           , n = 0\n           , sz = s.sz + 8\n           }\n      else { h = s.h\n           , block = update s.block s.n b\n           , n = s.n + 1\n           , sz = s.sz + 8\n           }\n\ntype SHAState_Array =\n  { h : [8][w]\n  , block : ByteArray\n  , n : [32]\n  , sz : [w * 2]\n  }\n\nSHAInit_Array : SHAState_Array\nSHAInit_Array =\n  { h = H0\n  , block = arrayConstant 0\n  , n = 0\n  , sz = 0\n  }\n\nSHAUpdate_Array : (w >= 32) => SHAState_Array -> ByteArray -> [64] -> SHAState_Array\nSHAUpdate_Array state data len =\n  if state.n != 0\n    then if len < 2 * `w - n\n      then state'\n      else state''\n    else state'''\n where\n   n = 0 # state.n\n   state' = { h = state.h, block = block', n = drop n', sz = state.sz + (0 # len) * 8 }\n    where\n      block' = arrayCopy state.block n data 0 len\n      n' = n + len\n   state'' = { h = h'', block = block''', n = drop n''', sz = state.sz + (0 # len) * 8 }\n    where\n      h' = processBlock state.h (arrayCopy state.block n data 0 (2 * `w - n)) 0\n      block' = arrayCopy state.block n data 0 (2 * `w - n)\n      index' = 2 * `w - n\n      len' = len - (2 * `w - n)\n      (h'', index'', len'') = if len' >= 2 * `w\n        then\n          ( (processBlocks h' (arrayCopy (arrayConstant 0) 0 data index' ((len' \/ (2 * `w)) * (2 * `w))) 0 (len' \/ (2 * `w)))\n          , index' + len' - (len' % (2 * `w))\n          , len' % (2 * `w)\n          )\n        else (h', index', len')\n      (block''', n''') = if len'' != 0\n        then ((arrayCopy block' 0 data index'' len''), len'')\n        else (block', 0)\n   state''' = { h = h'', block = block''', n = drop n''', sz = state.sz + (0 # len) * 8 }\n    where\n      (h'', index'', len'') = if len >= 2 * `w\n        then\n          ( (processBlocks state.h data 0 (len \/ (2 * `w)))\n          , len - (len % (2 * `w))\n          , len % (2 * `w)\n          )\n        else (state.h, 0, len)\n      (block''', n''') = if len'' != 0\n        then ((arrayCopy state.block 0 data index'' len''), len'')\n        else (state.block, n)\n\nSHAFinal_Array : (w >= 32) => SHAState_Array -> [digest_size]\nSHAFinal_Array state = take (join h''')\n  where\n    n = 0 # state.n\n    block' = arrayUpdate state.block n 0x80\n    n' = n + 1\n    (h'', block'', n'') = if n' > 2 * `w - `w \/ 4\n      then ((processBlock state.h (arraySet block' n' 0 (2 * `w - n')) 0), (arraySet block' n' 0 (2 * `w - n')), 0)\n      else (state.h, block', n')\n    h''' = processBlock\n      h''\n      (arrayRangeUpdate\n        (arraySet block'' n'' 0 (2 * `w - `w \/ 4 - n''))\n        (2 * `w - `w \/ 4)\n        (split`{parts=(w+3)\/4} (0 # state.sz)))\n      0\n\n\/\/ Imperative SHA implementation\nSHAImp_Array : (w >= 32) => ByteArray -> [64] -> [digest_size]\nSHAImp_Array msg len = SHAFinal_Array (SHAUpdate_Array SHAInit_Array msg len)\n\nprocessBlocks : [8][w] -> ByteArray -> [64] -> [64] -> [8][w]\nprocessBlocks [a, b, c, d, e, f, g, h] data index n = processBlock [a', b', c', d', e', f', g', h'] data index'\n  where\n    (a', b', c', d', e', f', g', h', index') = processBlocksLoop n data a b c d e f g h index\n\nprocessBlock : [8][w] -> ByteArray -> [64] -> [8][w]\nprocessBlock h block index =\n  processBlock_Common h (split (join (arrayRangeLookup block index)))\n\nprocessBlocksLoop : [64] -> ByteArray -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [64] -> ([w], [w], [w], [w], [w], [w], [w], [w], [64])\nprocessBlocksLoop num data a b c d e f g h index = if (index + 2 * `w) < (num * 2 * `w)\n  then processBlocksLoop num data a' b' c' d' e' f' g' h' (index + 2 * `w)\n  else (a, b, c, d, e, f, g, h, index)\n  where\n    [a', b', c', d', e', f', g', h'] = (processBlock [a, b, c, d, e, f, g, h] data index)\n\narrayRangeEqual_arrayRangeLookup_lemma : {n} (fin n, n >= 1, n <= 1000) => ByteArray -> ByteArray -> Bit\narrayRangeEqual_arrayRangeLookup_lemma a b = arrayRangeEqual a 0 b 0 `n == (arrayRangeLookup`{n=n} a 0 == arrayRangeLookup b 0)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Tests\/SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module that imports the SHA-384 instantiation and defines properties checking that SHA384::hash matches the standard test vectors for the empty string, \"abc\", and the given longer alphabet-based messages."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Tests::SHA384 where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 as SHA384\n\nproperty abcWorks = SHA384::hash (join \"abc\") == output where\n    output = join [\n        0xcb00753f45a35e8b, 0xb5a03d699ac65007, 0x272c32ab0eded163,\n        0x1a8b605a43ff5bed, 0x8086072ba1e7cc23, 0x58baeca134c825a7\n    ]\n\nproperty emptyStringWorks = SHA384::hash [] == output where\n    output = join [\n        0x38b060a751ac9638, 0x4cd9327eb1b1e36a, 0x21fdb71114be0743,\n        0x4c0cc7bf63f6e1da, 0x274edebfe76f65fb, 0xd51ad2f14898b95b\n    ]\n\nproperty alphabet448 = SHA384::hash input == output where\n    input = join \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    output = join [\n        0x3391fdddfc8dc739, 0x3707a65b1b470939, 0x7cf8b1d162af05ab,\n        0xfe8f450de5f36bc6, 0xb0455a8520bc4e6f, 0x5fe95b1fe3c8452b\n    ]\n\nproperty alphabet896 = SHA384::hash input == output where\n    input = join \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n    output = join [\n        0x09330c33f71147e8, 0x3d192fc782cd1b47, 0x53111b173b3b05d2,\n        0x2fa08086e3b0f712, 0xfcc7c71a557e2db9, 0x66c3e9fa91746039\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Tests\/SHA224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define Cryptol properties that verify the SHA-224 hash function `SHA224::hash` produces the correct standard test vector outputs for the empty string, \"abc\", the 448-bit alphabet message, and the 896-bit alphabet message, as in the given module."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Tests::SHA224 where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA224 as SHA224\n\nproperty abcWorks = SHA224::hash (join \"abc\") == output where\n    output = join [\n        0x23097d22, 0x3405d822, 0x8642a477, 0xbda255b3,\n        0x2aadbce4, 0xbda0b3f7, 0xe36c9da7\n    ]\n\nproperty emptyStringWorks = SHA224::hash [] == output where\n    output = join [\n        0xd14a028c, 0x2a3a2bc9, 0x476102bb, 0x288234c4,\n        0x15a2b01f, 0x828ea62a, 0xc5b3e42f\n    ]\n\nproperty alphabet448 = SHA224::hash input == output where\n    input = join \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    output = join [\n        0x75388b16, 0x512776cc, 0x5dba5da1, 0xfd890150,\n        0xb0c6455c, 0xb4f58b19, 0x52522525\n    ]\n\nproperty alphabet896 = SHA224::hash input == output where\n    input = join \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n    output = join [\n        0xc97ca9a5, 0x59850ce9, 0x7a04a96d, 0xef6d99a9,\n        0xe0e0e2ab, 0x14e6b8df, 0x265fc0b3\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Tests\/SHA256_FFI.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the module `Primitive::Keyless::Hash::SHA2::Tests::SHA256` with the property `FFIAndCryptolAreEqual : {l} (SHA256::ValidMessageLength (8 * l)) => [l][8] -> Bool` asserting `SHA256_FFI::hashBytes M == SHA256::hashBytes M` for all valid messages."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Tests::SHA256 where\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA256_FFI as SHA256_FFI\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\nFFIAndCryptolAreEqual : {l} (SHA256::ValidMessageLength (8 * l))\n    => [l][8] -> Bool\nproperty FFIAndCryptolAreEqual M = ffi == cryptol where\n    ffi = SHA256_FFI::hashBytes M\n    cryptol = SHA256::hashBytes M\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA512_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA512_256` that instantiates the generic SHA-512-based specification for SHA-512\/256 (w=64, DigestSize=256) with the given 8-word IV `H0`, exposing the standard SHA-512\/256 hashing interface and related types."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA512_256 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 256\n\n                H0 = [\n        0x22312194FC2BF72C\n      , 0x9F555FA3C84C64C2\n      , 0x2393B86B6F53B151\n      , 0x963877195940EABD\n      , 0x96283EE2A88EFFE3\n      , 0xBE5E1E2553863992\n      , 0x2B0199FC2C85B8AA\n      , 0x0EB72DDC81C52CA2\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA384` that instantiates the generic SHA-2 specification with 64-bit words and a 384-bit digest, including the given SHA-384 initial hash vector `H0` with the specified 64-bit constants."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 384\n\n            H0 = [\n        0xcbbb9d5dc1059ed8, 0x629a292a367cd507,\n        0x9159015a3070dd17, 0x152fecd8f70e5939,\n        0x67332667ffc00b31, 0x8eb44a8768581511,\n        0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA224` that instantiates the generic SHA-2 specification for SHA-224, setting `type w = 32`, `type DigestSize = 224`, and defining the SHA-224 initial hash vector `H0` as the given eight 32-bit constants."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA224 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 32\n\n    type DigestSize = 224\n\n            H0 = [\n        0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n        0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 that instantiates the generic SHA-2 specification for SHA-256 with 32-bit words, 256-bit digests, and the given SHA-256 initial hash values H0."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 32\n\n    type DigestSize = 256\n\n            H0 = [\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA512_224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA512_224` that instantiates the generic SHA-2 specification for SHA-512\/224 with 64-bit words, 224-bit digest size, and the given 8-word initial hash vector `H0`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA512_224 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 224\n\n                H0 = [\n       0x8C3D37C819544DA2\n     , 0x73E1996689DCD4D6\n     , 0x1DFAB7AE32FF9C82\n     , 0x679DD514582F9FCF\n     , 0x0F6D2B697BD44DA8\n     , 0x77E36F7304C48942\n     , 0x3F9D85A86A1D36C8\n     , 0x1112E6AD91D692A1\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Keyless::Hash::SHA2::Instantiations::SHA512` instantiating the generic SHA-2 specification for 64-bit words and 512-bit digests, including the SHA-512 initial hash vector `H0` with the standard eight 64-bit constants."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA512 =\n    Primitive::Keyless::Hash::SHA2::Specification\nwhere\n    type w = 64\n\n    type DigestSize = 512\n\n            H0 = [\n        0x6a09e667f3bcc908, 0xbb67ae8584caa73b,\n        0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n        0x510e527fade682d1, 0x9b05688c2b3e6c1f,\n        0x1f83d9abfb41bd6b, 0x5be0cd19137e2179\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA2\/Instantiations\/SHA256_FFI.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that exposes a foreign-function interface for SHA-256, including the type alias MessageUpperBound from the SHA256 instantiation module and a foreign hashBytes function with the signature `{l} (SHA256::ValidMessageLength (8 * l)) => [l][8] -> [SHA256::DigestLength \/ 8][8]`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA2::Instantiations::SHA256_FFI where\n    import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\n    type MessageUpperBound = SHA256::MessageUpperBound\n\n    foreign hashBytes : {l} (SHA256::ValidMessageLength (8 * l))\n        => [l][8] -> [SHA256::DigestLength \/ 8][8]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module for SHA3-512 that imports the SHA3_512 instantiation and defines properties t1, t72, and t100 checking that SHA3_512::hash and SHA3_512::hashBytes produce the given known-answer outputs for the specified inputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_512 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512 as SHA3_512\n\nproperty t1 = SHA3_512::hash [] == output where\n    output = join [\n        0xa69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a6,\n        0x15b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26\n    ]\n\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_512::hash input == output\n    hashBytesWorks = SHA3_512::hashBytes (split input) == split output\n    input = 0x3d6093966950abd846\n    output = join [\n        0x53e30da8b74ae76abf1f65761653ebfbe87882e9ea0ea564addd7cfd5a652457,\n        0x8ad6be014d7799799ef5e15c679582b791159add823b95c91e26de62dcb74cfa\n    ]\n\nproperty t100 = SHA3_512::hash input == output where\n    input = KBO::truncate`{100} 0xd404d8e31f8091709122025a0c\n    output = join [\n        0xa5ce9e2523788040eab94f0a2467efc2a1e6d4ea74e9248f97f94ce1407f0c88,\n        0x2e6b0578d98a7067d98c79b2b1dd2cb76393e6356061146637e5240d34ed6955\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHAKE128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the Cryptol module Primitive::Keyless::Hash::SHA3::Tests::SHAKE128 containing the function computeCavpTestVector and SHAKE128 CAVP test properties k0, k1, k2, k3, k265, and k266 that verify xof against the given known-answer test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHAKE128 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE128\n\ncomputeCavpTestVector : {k, l} (fin k, fin l) => [8 * (k \/^ 8)] -> [l] -> Bool\ncomputeCavpTestVector msg expectedResult = result == expectedResult where\n    result = xof (KBO::truncate`{k, 8 * (k \/^ 8)} msg)\n\nproperty k0 = computeCavpTestVector`{0} [] expected_result where\n    expected_result = join [\n        0x7f9c2ba4e88f827d616045507605853e,\n        0xd73b8093f6efbc88eb1a6eacfa66ef26,\n        0x3cb1eea988004b93103cfb0aeefd2a68,\n        0x6e01fa4a58e8a3639ca8a1e3f9ae57e2\n    ]\n\nproperty k1 = computeCavpTestVector`{1} 0x00 expected_result where\n    expected_result = join [\n        0xe78b86559a9ccdc72288bf7bcf8e11d5,\n        0x74543a2922978913a02be149e89d03ca,\n        0xe63d2c36e2cf6906791b187d7e371d4f,\n        0x21ebe59dcfc249a510b82255a18250dd\n    ]\n\nproperty k2 = computeCavpTestVector`{2} 0x03 expected_result where\n    expected_result = join [\n        0xf6b6c4093f0a2ceba61b9f2c2fea2ca2,\n        0x38ce9005edcd588c380405070532ddd0,\n        0x0cbd3a3a7448017d874c52c9e383fa3d,\n        0xb1c184e023181fcc8550f53ac92feca5\n    ]\n\nproperty k3 = computeCavpTestVector`{3} 0x06 expected_result where\n    expected_result = join [\n        0x178afb3be00c33b682f0c920520699e3,\n        0xb7e4c360274fd8b41cdeaa8d3c675bdc,\n        0x079be55d4513e7479aa903169430f0a0,\n        0xbf60169becd0ff9ff3ff6be24bc6fd83\n    ]\n\nproperty k265 = computeCavpTestVector`{265} msg expected_output where\n    msg = 0xa4fb52a45c1e49e1805ccbe419ef3c57b773d84eaa478ed07536129480572e080d01\n    expected_output = 0xf5e3f9934cfa817d75e8db5dce000977\n\nproperty k266 = computeCavpTestVector`{266} msg expectedResult where\n    msg = 0x01de90ca986e1abd50d28ad9f82cc77b45ebd99d19fa4bab0437d3930c27351ca900\n    expectedResult = 0xc47bb657d4f474cd5fa0f29537b85a7a\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module Primitive::Keyless::Hash::SHA3::Tests::SHA3_384 that imports Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384 and defines properties t1, t64, and t72 checking SHA3_384::hash and SHA3_384::hashBytes against the given fixed test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_384 where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384 as SHA3_384\n\nproperty t1 = SHA3_384::hash [] == output where\n    output = join [\n        0x0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61,\n        0x995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004\n    ]\n\nproperty t64 = SHA3_384::hash 0x72189b5f18121fb7 == output where\n    output = join [\n        0xb5be454e64fb00d8ebf23cece42fdcf20e88bb5067ab17c2,\n        0x19068b1533eb485341a84a933f837d9abd65b62604936469\n    ]\n\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_384::hash input == output\n    hashBytesWorks = SHA3_384::hashBytes (split input) == split output\n    input = 0xa36e5a59043b6333d7\n    output = join [\n        0xbd045661663436d07720ff3c8b6f922066dfe244456a56ca,\n        0x46dfb3f7e271116d932107c7b04cc7c60173e08d0c2e107c\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHAKE256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In a Cryptol module for SHAKE256, define the extendable-output function `xof` and properties `k5`, `k6`, `k7`, and `k8` that assert `xof` on the given fixed inputs equals the specified 512-bit expected_result values."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHAKE256 where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256\n\nproperty k5 = xof [] == expected_result where\n    expected_result = join [\n        0x46b9dd2b0ba88d13233b3feb743eeb24,\n        0x3fcd52ea62b81b82b50c27646ed5762f,\n        0xd75dc4ddd8c0f200cb05019d67b592f6,\n        0xfc821c49479ab48640292eacb3b7c4be\n    ]\n\nproperty k6 = xof 0b0 == expected_result where\n    expected_result = join [\n        0x1e20b13f3bdb730d286913335c092bce,\n        0xc0eb1aff2798c05736faa93bd665807a,\n        0x48ed7652aefd600427e9f797d647b9b3,\n        0x55d30410d71b8e275a676545600f1c35\n    ]\n\nproperty k7 = xof 0b11 == expected_result where\n    expected_result = join [\n        0x4f86b0eb85f7a9f6dc38b622706948ad,\n        0xb2beb6dd6911b5e9d865fd1f9667b5c0,\n        0x2a0dbb39c488b040a18ff3885f04ef95,\n        0x7c98f3948e6b7959a9b8950ffd6345d5\n    ]\n\nproperty k8 = xof 0b110 == expected_result where\n    expected_result = join [\n        0x27b5f40b3645215e370472ebb06817ae,\n        0xbddbe2cbd3a9a3ba3914da88e5853e70,\n        0x83630e6d51d7a009017d8176c3067329,\n        0xbec8e5f65591d65c5894c40132f1a2ab\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In a Cryptol module for SHA3-224, define the SHA3_224::hash and SHA3_224::hashBytes interfaces and write properties t1, t5, t72, and t512 that check their outputs against the given known-answer test vectors (including bit-order truncation via KBO::truncate)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_224 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224 as SHA3_224\n\nproperty t1 = SHA3_224::hash [] ==\n    0x6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7\n\nproperty t5 = SHA3_224::hash (KBO::truncate`{5} 0x1f) ==\n    0x65ad282dcf9642a2facc1e7545c58f3b17523e795fee58e4d21b10bf\n\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_224::hash input == output\n    hashBytesWorks = SHA3_224::hashBytes (split input) == split output\n    input = 0xb29373f6f8839bd498\n    output = 0xe02a13fa4770f824bcd69799284878f19bfdc833ac6d865f28b757d0\n\nproperty t512 = SHA3_224::hash input == output where\n    input = join [\n        0xfc286db63e69d24c6962bb515cc32c86,\n        0x67ed0c08ba9f331d1dd2c42de2e1bd0f,\n        0x18edcc870280650cc87011ce6b0709f7,\n        0xfe60033114144c69751717d315dc152f\n    ]\n    output = 0x157fd9f423a498868e233d9d64631f61aa5e8fbc23df413f7826c962\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Tests\/SHA3_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Keyless::Hash::SHA3::Tests::SHA3_256` that imports the SHA3-256 instantiation and defines properties t1, t7, t8, t72, and t235 to verify SHA3_256::hash and hashBytes against known test vectors using Keccak bit ordering and truncation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Tests::SHA3_256 where\n\nimport Primitive::Keyless::Hash::SHA3::KeccakBitOrdering as KBO\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256 as SHA3_256\n\nproperty t1 = SHA3_256::hash [] ==\n    0xa7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a\n\nproperty t7 = SHA3_256::hash (KBO::truncate`{7} 0x0b) ==\n    0x9e5f8c800689fa5168fc5fbfeca8bd5b3668ffd6f08143e2e396b9ae0f9b443e\n\nproperty t8 = SHA3_256::hash 0x6a ==\n    0xf35e560e05de779f2669b9f513c2a7ab81dfeb100e2f4ee1fb17354bfa2740ca\n\nproperty t72 = hashWorks && hashBytesWorks where\n    hashWorks = SHA3_256::hash input == output\n    hashBytesWorks = SHA3_256::hashBytes (split input) == split output\n    input = 0xfb8dfa3a132f9813ac\n    output = 0xfd09b3501888445ffc8c3bb95d106440ceee469415fce1474743273094306e2e\n\nproperty t235 = SHA3_256::hash input == output where\n    input = KBO::truncate`{235} (join [\n        0xd03d466ab65db8e5131a414637174b,\n        0x646d0612977d194dcb75b910d2a903\n    ])\n    output = join [\n        0x06413eb50e238e09843aa51b0b5fb7ca,\n        0x52b87db7d71f384b5b93f57843c89f37\n    ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512` that instantiates the generic SHA3 construction with `type digest = 512`, exposing the appropriate SHA3-512 hashing interface."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 512\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384` that instantiates the generic SHA3 specification with a 384-bit digest, setting `type digest = 384` as its external-facing configuration."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 384\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224` that instantiates the generic SHA3 specification with a 224-bit digest type alias `digest = 224` and exposes the resulting SHA3-224 hash interface."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 224\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA3\/Instantiations\/SHA3_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256` that instantiates the generic SHA3 specification with a digest size of 256 bits (i.e., `type digest = 256`)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256 =\n    Primitive::Keyless::Hash::SHA3::SHA3 where\n        type digest = 256\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Keyless\/Hash\/SHA1\/Tests\/CAVPShortByte.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Keyless::Hash::SHA1::Tests::CAVPShortByte` that imports `Primitive::Keyless::Hash::SHA1::Specification` and defines properties `testCase0` through `testCase64` asserting `SHA1::hash` over given bitlengths and fixed messages equals the specified SHA-1 digests."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA1::Tests::CAVPShortByte where\n\nimport Primitive::Keyless::Hash::SHA1::Specification as SHA1\n\nproperty testCase0 = SHA1::hash `{ l = 0 } msg == md\n  where\n    msg = take 0x00\n    md = 0xda39a3ee5e6b4b0d3255bfef95601890afd80709\n\nproperty testCase1 = SHA1::hash `{ l = 8 } msg == md\n  where\n    msg = take 0x36\n    md = 0xc1dfd96eea8cc2b62785275bca38ac261256e278\n\nproperty testCase2 = SHA1::hash `{ l = 16 } msg == md\n  where\n    msg = take 0x195a\n    md = 0x0a1c2d555bbe431ad6288af5a54f93e0449c9232\n\nproperty testCase3 = SHA1::hash `{ l = 24 } msg == md\n  where\n    msg = take 0xdf4bd2\n    md = 0xbf36ed5d74727dfd5d7854ec6b1d49468d8ee8aa\n\nproperty testCase4 = SHA1::hash `{ l = 32 } msg == md\n  where\n    msg = take 0x549e959e\n    md = 0xb78bae6d14338ffccfd5d5b5674a275f6ef9c717\n\nproperty testCase5 = SHA1::hash `{ l = 40 } msg == md\n  where\n    msg = take 0xf7fb1be205\n    md = 0x60b7d5bb560a1acf6fa45721bd0abb419a841a89\n\nproperty testCase6 = SHA1::hash `{ l = 48 } msg == md\n  where\n    msg = take 0xc0e5abeaea63\n    md = 0xa6d338459780c08363090fd8fc7d28dc80e8e01f\n\nproperty testCase7 = SHA1::hash `{ l = 56 } msg == md\n  where\n    msg = take 0x63bfc1ed7f78ab\n    md = 0x860328d80509500c1783169ebf0ba0c4b94da5e5\n\nproperty testCase8 = SHA1::hash `{ l = 64 } msg == md\n  where\n    msg = take 0x7e3d7b3eada98866\n    md = 0x24a2c34b976305277ce58c2f42d5092031572520\n\nproperty testCase9 = SHA1::hash `{ l = 72 } msg == md\n  where\n    msg = take 0x9e61e55d9ed37b1c20\n    md = 0x411ccee1f6e3677df12698411eb09d3ff580af97\n\nproperty testCase10 = SHA1::hash `{ l = 80 } msg == md\n  where\n    msg = take 0x9777cf90dd7c7e863506\n    md = 0x05c915b5ed4e4c4afffc202961f3174371e90b5c\n\nproperty testCase11 = SHA1::hash `{ l = 88 } msg == md\n  where\n    msg = take 0x4eb08c9e683c94bea00dfa\n    md = 0xaf320b42d7785ca6c8dd220463be23a2d2cb5afc\n\nproperty testCase12 = SHA1::hash `{ l = 96 } msg == md\n  where\n    msg = take 0x0938f2e2ebb64f8af8bbfc91\n    md = 0x9f4e66b6ceea40dcf4b9166c28f1c88474141da9\n\nproperty testCase13 = SHA1::hash `{ l = 104 } msg == md\n  where\n    msg = take 0x74c9996d14e87d3e6cbea7029d\n    md = 0xe6c4363c0852951991057f40de27ec0890466f01\n\nproperty testCase14 = SHA1::hash `{ l = 112 } msg == md\n  where\n    msg = take 0x51dca5c0f8e5d49596f32d3eb874\n    md = 0x046a7b396c01379a684a894558779b07d8c7da20\n\nproperty testCase15 = SHA1::hash `{ l = 120 } msg == md\n  where\n    msg = take 0x3a36ea49684820a2adc7fc4175ba78\n    md = 0xd58a262ee7b6577c07228e71ae9b3e04c8abcda9\n\nproperty testCase16 = SHA1::hash `{ l = 128 } msg == md\n  where\n    msg = take 0x3552694cdf663fd94b224747ac406aaf\n    md = 0xa150de927454202d94e656de4c7c0ca691de955d\n\nproperty testCase17 = SHA1::hash `{ l = 136 } msg == md\n  where\n    msg = take 0xf216a1cbde2446b1edf41e93481d33e2ed\n    md = 0x35a4b39fef560e7ea61246676e1b7e13d587be30\n\nproperty testCase18 = SHA1::hash `{ l = 144 } msg == md\n  where\n    msg = take 0xa3cf714bf112647e727e8cfd46499acd35a6\n    md = 0x7ce69b1acdce52ea7dbd382531fa1a83df13cae7\n\nproperty testCase19 = SHA1::hash `{ l = 152 } msg == md\n  where\n    msg = take 0x148de640f3c11591a6f8c5c48632c5fb79d3b7\n    md = 0xb47be2c64124fa9a124a887af9551a74354ca411\n\nproperty testCase20 = SHA1::hash `{ l = 160 } msg == md\n  where\n    msg = take 0x63a3cc83fd1ec1b6680e9974a0514e1a9ecebb6a\n    md = 0x8bb8c0d815a9c68a1d2910f39d942603d807fbcc\n\nproperty testCase21 = SHA1::hash `{ l = 168 } msg == md\n  where\n    msg = take 0x875a90909a8afc92fb7070047e9d081ec92f3d08b8\n    md = 0xb486f87fb833ebf0328393128646a6f6e660fcb1\n\nproperty testCase22 = SHA1::hash `{ l = 176 } msg == md\n  where\n    msg = take 0x444b25f9c9259dc217772cc4478c44b6feff62353673\n    md = 0x76159368f99dece30aadcfb9b7b41dab33688858\n\nproperty testCase23 = SHA1::hash `{ l = 184 } msg == md\n  where\n    msg = take 0x487351c8a5f440e4d03386483d5fe7bb669d41adcbfdb7\n    md = 0xdbc1cb575ce6aeb9dc4ebf0f843ba8aeb1451e89\n\nproperty testCase24 = SHA1::hash `{ l = 192 } msg == md\n  where\n    msg = take 0x46b061ef132b87f6d3b0ee2462f67d910977da20aed13705\n    md = 0xd7a98289679005eb930ab75efd8f650f991ee952\n\nproperty testCase25 = SHA1::hash `{ l = 200 } msg == md\n  where\n    msg = take 0x3842b6137bb9d27f3ca5bafe5bbb62858344fe4ba5c41589a5\n    md = 0xfda26fa9b4874ab701ed0bb64d134f89b9c4cc50\n\nproperty testCase26 = SHA1::hash `{ l = 208 } msg == md\n  where\n    msg = take 0x44d91d3d465a4111462ba0c7ec223da6735f4f5200453cf132c3\n    md = 0xc2ff7ccde143c8f0601f6974b1903eb8d5741b6e\n\nproperty testCase27 = SHA1::hash `{ l = 216 } msg == md\n  where\n    msg = take 0xcce73f2eabcb52f785d5a6df63c0a105f34a91ca237fe534ee399d\n    md = 0x643c9dc20a929608f6caa9709d843ca6fa7a76f4\n\nproperty testCase28 = SHA1::hash `{ l = 224 } msg == md\n  where\n    msg = take 0x664e6e7946839203037a65a12174b244de8cbc6ec3f578967a84f9ce\n    md = 0x509ef787343d5b5a269229b961b96241864a3d74\n\nproperty testCase29 = SHA1::hash `{ l = 232 } msg == md\n  where\n    msg = take 0x9597f714b2e45e3399a7f02aec44921bd78be0fefee0c5e9b499488f6e\n    md = 0xb61ce538f1a1e6c90432b233d7af5b6524ebfbe3\n\nproperty testCase30 = SHA1::hash `{ l = 240 } msg == md\n  where\n    msg = take 0x75c5ad1f3cbd22e8a95fc3b089526788fb4ebceed3e7d4443da6e081a35e\n    md = 0x5b7b94076b2fc20d6adb82479e6b28d07c902b75\n\nproperty testCase31 = SHA1::hash `{ l = 248 } msg == md\n  where\n    msg = take 0xdd245bffe6a638806667768360a95d0574e1a0bd0d18329fdb915ca484ac0d\n    md = 0x6066db99fc358952cf7fb0ec4d89cb0158ed91d7\n\nproperty testCase32 = SHA1::hash `{ l = 256 } msg == md\n  where\n    msg = take 0x0321794b739418c24e7c2e565274791c4be749752ad234ed56cb0a6347430c6b\n    md = 0xb89962c94d60f6a332fd60f6f07d4f032a586b76\n\nproperty testCase33 = SHA1::hash `{ l = 264 } msg == md\n  where\n    msg = take 0x4c3dcf95c2f0b5258c651fcd1d51bd10425d6203067d0748d37d1340d9ddda7db3\n    md = 0x17bda899c13d35413d2546212bcd8a93ceb0657b\n\nproperty testCase34 = SHA1::hash `{ l = 272 } msg == md\n  where\n    msg = take 0xb8d12582d25b45290a6e1bb95da429befcfdbf5b4dd41cdf3311d6988fa17cec0723\n    md = 0xbadcdd53fdc144b8bf2cc1e64d10f676eebe66ed\n\nproperty testCase35 = SHA1::hash `{ l = 280 } msg == md\n  where\n    msg = take 0x6fda97527a662552be15efaeba32a3aea4ed449abb5c1ed8d9bfff544708a425d69b72\n    md = 0x01b4646180f1f6d2e06bbe22c20e50030322673a\n\nproperty testCase36 = SHA1::hash `{ l = 288 } msg == md\n  where\n    msg = take 0x09fa2792acbb2417e8ed269041cc03c77006466e6e7ae002cf3f1af551e8ce0bb506d705\n    md = 0x10016dc3a2719f9034ffcc689426d28292c42fc9\n\nproperty testCase37 = SHA1::hash `{ l = 296 } msg == md\n  where\n    msg = take 0x5efa2987da0baf0a54d8d728792bcfa707a15798dc66743754406914d1cfe3709b1374eaeb\n    md = 0x9f42fa2bce6ef021d93c6b2d902273797e426535\n\nproperty testCase38 = SHA1::hash `{ l = 304 } msg == md\n  where\n    msg = take 0x2836de99c0f641cd55e89f5af76638947b8227377ef88bfba662e5682babc1ec96c6992bc9a0\n    md = 0xcdf48bacbff6f6152515323f9b43a286e0cb8113\n\nproperty testCase39 = SHA1::hash `{ l = 312 } msg == md\n  where\n    msg = take 0x42143a2b9e1d0b354df3264d08f7b602f54aad922a3d63006d097f683dc11b90178423bff2f7fe\n    md = 0xb88fb75274b9b0fd57c0045988cfcef6c3ce6554\n\nproperty testCase40 = SHA1::hash `{ l = 320 } msg == md\n  where\n    msg = take 0xeb60c28ad8aeda807d69ebc87552024ad8aca68204f1bcd29dc5a81dd228b591e2efb7c4df75ef03\n    md = 0xc06d3a6a12d9e8db62e8cff40ca23820d61d8aa7\n\nproperty testCase41 = SHA1::hash `{ l = 328 } msg == md\n  where\n    msg = take 0x7de4ba85ec54747cdc42b1f23546b7e490e31280f066e52fac117fd3b0792e4de62d5843ee98c72015\n    md = 0x6e40f9e83a4be93874bc97cdebb8da6889ae2c7a\n\nproperty testCase42 = SHA1::hash `{ l = 336 } msg == md\n  where\n    msg = take 0xe70653637bc5e388ccd8dc44e5eace36f7398f2bac993042b9bc2f4fb3b0ee7e23a96439dc01134b8c7d\n    md = 0x3efc940c312ef0dfd4e1143812248db89542f6a5\n\nproperty testCase43 = SHA1::hash `{ l = 344 } msg == md\n  where\n    msg = take 0xdd37bc9f0b3a4788f9b54966f252174c8ce487cbe59c53c22b81bf77621a7ce7616dcb5b1e2ee63c2c309b\n    md = 0xa0cf03f7badd0c3c3c4ea3717f5a4fb7e67b2e56\n\nproperty testCase44 = SHA1::hash `{ l = 352 } msg == md\n  where\n    msg = take 0x5f485c637ae30b1e30497f0fb7ec364e13c906e2813daa34161b7ac4a4fd7a1bddd79601bbd22cef1f57cbc7\n    md = 0xa544e06f1a07ceb175a51d6d9c0111b3e15e9859\n\nproperty testCase45 = SHA1::hash `{ l = 360 } msg == md\n  where\n    msg = take 0xf6c237fb3cfe95ec8414cc16d203b4874e644cc9a543465cad2dc563488a659e8a2e7c981e2a9f22e5e868ffe1\n    md = 0x199d986ed991b99a071f450c6b1121a727e8c735\n\nproperty testCase46 = SHA1::hash `{ l = 368 } msg == md\n  where\n    msg = take 0xda7ab3291553c659873c95913768953c6e526d3a26590898c0ade89ff56fbd110f1436af590b17fed49f8c4b2b1e\n    md = 0x33bac6104b0ad6128d091b5d5e2999099c9f05de\n\nproperty testCase47 = SHA1::hash `{ l = 376 } msg == md\n  where\n    msg = take 0x8cfa5fd56ee239ca47737591cba103e41a18acf8e8d257b0dbe8851134a81ff6b2e97104b39b76e19da256a17ce52d\n    md = 0x76d7db6e18c1f4ae225ce8ccc93c8f9a0dfeb969\n\nproperty testCase48 = SHA1::hash `{ l = 384 } msg == md\n  where\n    msg = take 0x57e89659d878f360af6de45a9a5e372ef40c384988e82640a3d5e4b76d2ef181780b9a099ac06ef0f8a7f3f764209720\n    md = 0xf652f3b1549f16710c7402895911e2b86a9b2aee\n\nproperty testCase49 = SHA1::hash `{ l = 392 } msg == md\n  where\n    msg = take 0xb91e64235dbd234eea2ae14a92a173ebe835347239cff8b02074416f55c6b60dc6ced06ae9f8d705505f0d617e4b29aef9\n    md = 0x63faebb807f32be708cf00fc35519991dc4e7f68\n\nproperty testCase50 = SHA1::hash `{ l = 400 } msg == md\n  where\n    msg = take 0xe42a67362a581e8cf3d847502215755d7ad425ca030c4360b0f7ef513e6980265f61c9fa18dd9ce668f38dbc2a1ef8f83cd6\n    md = 0x0e6730bc4a0e9322ea205f4edfff1fffda26af0a\n\nproperty testCase51 = SHA1::hash `{ l = 408 } msg == md\n  where\n    msg = take 0x634db92c22010e1cbf1e1623923180406c515272209a8acc42de05cc2e96a1e94c1f9f6b93234b7f4c55de8b1961a3bf352259\n    md = 0xb61a3a6f42e8e6604b93196c43c9e84d5359e6fe\n\nproperty testCase52 = SHA1::hash `{ l = 416 } msg == md\n  where\n    msg = take 0xcc6ca3a8cb391cd8a5aff1faa7b3ffbdd21a5a3ce66cfaddbfe8b179e4c860be5ec66bd2c6de6a39a25622f9f2fcb3fc05af12b5\n    md = 0x32d979ca1b3ed0ed8c890d99ec6dd85e6c16abf4\n\nproperty testCase53 = SHA1::hash `{ l = 424 } msg == md\n  where\n    msg = take 0x7c0e6a0d35f8ac854c7245ebc73693731bbbc3e6fab644466de27bb522fcb99307126ae718fe8f00742e6e5cb7a687c88447cbc961\n    md = 0x6f18190bd2d02fc93bce64756575cea36d08b1c3\n\nproperty testCase54 = SHA1::hash `{ l = 432 } msg == md\n  where\n    msg = take 0xc5581d40b331e24003901bd6bf244aca9e9601b9d81252bb38048642731f1146b8a4c69f88e148b2c8f8c14f15e1d6da57b2daa9991e\n    md = 0x68f525feea1d8dbe0117e417ca46708d18d7629a\n\nproperty testCase55 = SHA1::hash `{ l = 440 } msg == md\n  where\n    msg = take 0xec6b4a88713df27c0f2d02e738b69db43abda3921317259c864c1c386e9a5a3f533dc05f3beeb2bec2aac8e06db4c6cb3cddcf697e03d5\n    md = 0xa7272e2308622ff7a339460adc61efd0ea8dabdc\n\nproperty testCase56 = SHA1::hash `{ l = 448 } msg == md\n  where\n    msg = take 0x0321736beba578e90abc1a90aa56157d871618f6de0d764cc8c91e06c68ecd3b9de3824064503384db67beb7fe012232dacaef93a000fba7\n    md = 0xaef843b86916c16f66c84d83a6005d23fd005c9e\n\nproperty testCase57 = SHA1::hash `{ l = 456 } msg == md\n  where\n    msg = take 0xd0a249a97b5f1486721a50d4c4ab3f5d674a0e29925d5bf2678ef6d8d521e456bd84aa755328c83fc890837726a8e7877b570dba39579aabdd\n    md = 0xbe2cd6f380969be59cde2dff5e848a44e7880bd6\n\nproperty testCase58 = SHA1::hash `{ l = 464 } msg == md\n  where\n    msg = take 0xc32138531118f08c7dcc292428ad20b45ab27d9517a18445f38b8f0c2795bcdfe3ffe384e65ecbf74d2c9d0da88398575326074904c1709ba072\n    md = 0xe5eb4543deee8f6a5287845af8b593a95a9749a1\n\nproperty testCase59 = SHA1::hash `{ l = 472 } msg == md\n  where\n    msg = take 0xb0f4cfb939ea785eabb7e7ca7c476cdd9b227f015d905368ba00ae96b9aaf720297491b3921267576b72c8f58d577617e844f9f0759b399c6b064c\n    md = 0x534c850448dd486787b62bdec2d4a0b140a1b170\n\nproperty testCase60 = SHA1::hash `{ l = 480 } msg == md\n  where\n    msg = take 0xbd02e51b0cf2c2b8d204a026b41a66fbfc2ac37ee9411fc449c8d1194a0792a28ee731407dfc89b6dfc2b10faa27723a184afef8fd83def858a32d3f\n    md = 0x6fbfa6e4edce4cc85a845bf0d228dc39acefc2fa\n\nproperty testCase61 = SHA1::hash `{ l = 488 } msg == md\n  where\n    msg = take 0xe33146b83e4bb671392218da9a77f8d9f5974147182fb95ba662cb66011989c16d9af104735d6f79841aa4d1df276615b50108df8a29dbc9de31f4260d\n    md = 0x018872691d9b04e8220e09187df5bc5fa6257cd9\n\nproperty testCase62 = SHA1::hash `{ l = 496 } msg == md\n  where\n    msg = take 0x411c13c75073c1e2d4b1ecf13139ba9656cd35c14201f1c7c6f0eeb58d2dbfe35bfdeccc92c3961cfabb590bc1eb77eac15732fb0275798680e0c7292e50\n    md = 0xd98d512a35572f8bd20de62e9510cc21145c5bf4\n\nproperty testCase63 = SHA1::hash `{ l = 504 } msg == md\n  where\n    msg = take 0xf2c76ef617fa2bfc8a4d6bcbb15fe88436fdc2165d3074629579079d4d5b86f5081ab177b4c3f530376c9c924cbd421a8daf8830d0940c4fb7589865830699\n    md = 0x9f3ea255f6af95c5454e55d7354cabb45352ea0b\n\nproperty testCase64 = SHA1::hash `{ l = 512 } msg == md\n  where\n    msg = take 0x45927e32ddf801caf35e18e7b5078b7f5435278212ec6bb99df884f49b327c6486feae46ba187dc1cc9145121e1492e6b06e9007394dc33b7748f86ac3207cfe\n    md = 0xa70cfbfe7563dd0e665c7c6715a96a8d756950c0\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Scheme\/RSAES_OAEP.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing the RSAES-OAEP encryption scheme (per RSA PKCS #1 with OAEP and MGF1) over RSA, including RSAES_OAEP_ENCRYPT, RSAES_OAEP_DECRYPT, EME_OAEP_encode\/decode, MGF1, and a property RSAES_OAEP_Correct that proves decrypt(encrypt(m)) recovers m under the given type constraints."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Scheme::RSAES_OAEP where\n\nimport Primitive::Asymmetric::Cipher::RSA\n\nparameter\n  type k : #\n  type constraint (fin k, k >= 1)\n\n  type hLen : #   type constraint (fin hLen, hLen >= 1)\n\n  hash : {a} (2 * hLen >= width (8 * a) ) => [a][8] -> [8 * hLen]\n\n  type KeySize = k * 8\n  n : [KeySize]\n  e : [KeySize]\n  d : [KeySize]\n\nRSAES_OAEP_ENCRYPT : {l,mLen}\n                   (fin l, fin mLen\n                   , l>=0\n                   , 2 * hLen >= width (8 * l)                    , 2 * hLen >= width (8 * ( k - hLen + 3))                    , k >= mLen+2*hLen+2\n                   , 2^^32*hLen >= k - hLen - 1                    )\n                   => [256]                    -> [mLen][8]\n                   -> [l][8]\n                   -> [k][8]\nRSAES_OAEP_ENCRYPT rand M L = I2OSP`{k} c                    where\n                    EM = EME_OAEP_encode rand (M, L)                       m  = (zero # OS2IP EM) : [KeySize]                      c  = RSAEP ((n, e), m)   \n\nRSAES_OAEP_DECRYPT : {l}\n                   (fin l\n                   , l>=0\n                   , 2 * hLen >= width (8 * l)                    , 2 * hLen >= width (8 * (k - hLen + 3))                    , k >= 2 * hLen + 2\n                   , 2^^32*hLen >= k - hLen - 1                    ) => [k][8] -> [l][8] -> ([k - hLen - 1][8], [width (k - hLen - 1)])\nRSAES_OAEP_DECRYPT C L = if c < 0 \\\/ c >= n then error \"decryption error\"\n                         else M\n                   where\n                    c  = OS2IP C\n                    m  = RSADP ((n,d),c)\n                    EM = I2OSP`{k} m\n                    M  = EME_OAEP_decode (EM, L)\n\nRSAES_OAEP_Correct : {l,mLen}\n                   (fin l, fin mLen\n                   , 2 * hLen >= width (8 * l)                    , 2 * hLen >= width (8 * (k - hLen + 3))                    , k >= mLen+2*hLen+2\n                   , 2^^32*hLen >= k - hLen - 1                    )\n                   => [256]                    -> [l][8]\n                   -> [mLen][8]\n                   -> Bit\nproperty RSAES_OAEP_Correct r l m = (RSAES_OAEP_DECRYPT (RSAES_OAEP_ENCRYPT r m l) l).0 == m#(zero:[_][8])\n\nEME_OAEP_encode : {l,mLen}\n         (fin l,fin mLen\n         , l >= 0\n         , 2 * hLen >= width (8 * l)          , 2 * hLen >= width (8 * ( k - hLen + 3))          , k >= mLen + 2 * hLen + 2\n         , 2^^32*hLen >= k - hLen - 1          )\n         => [256]          -> ([mLen][8], [l][8])\n         -> [k][8]\nEME_OAEP_encode rseed (M,L) = (zero : [1][8]) # maskedSeed # maskedDB          where\n          lHash      = split (hash L) : [hLen][8]\n          PS         = (zero:[(k-mLen-2*hLen-2)][8])           DB         = lHash # PS # [(1:[8])] # M\n          seed       = random rseed : [hLen][8]\n          dbMask     = MGF1`{maskLen=(k-hLen-1)} seed\n          maskedDB   = DB ^ dbMask\n          seedMask   = MGF1`{maskLen=hLen} maskedDB\n          maskedSeed = seed ^ seedMask\n\nEME_OAEP_decode : {l}\n         (fin l\n         , l>=0\n         , 2*hLen >= width (8 * l)          , 2*hLen >= width (8 * ( k - hLen + 3))          , k >= 2 * hLen + 2\n         , 2^^32*hLen >= k - hLen - 1          ) => ([k][8], [l][8]) -> ([k - hLen - 1][8], [width (k - hLen - 1)])\nEME_OAEP_decode (EM,L) = if Y != zero then error \"decryption error\"\n                         | lHash' != lHash then error \"decryption error\"\n                         else (Mpadded,mLen)\n                where\n                  Y          = head EM\n                  maskedSeed = take`{hLen} (drop`{1} EM)\n                  maskedDB   = drop`{hLen+1} EM\n                  seedMask   = MGF1`{maskLen=hLen} maskedDB\n                  seed       = seedMask ^ maskedSeed\n                  dbMask     = MGF1`{maskLen=k-hLen-1} seed\n                  DB         = maskedDB ^ dbMask \/\/ lHash' # (zero:[_][8]) # [(1:[8])] # M\n                  lHash'     = take`{hLen} DB \/\/ This should equal hash L\n                  lHash      = split (hash L) : [_][8]\n                  (Mpadded,mLen) = extractMsg DB \/\/ Original msg is take`{mLen} Mpadded\n\nprivate\n    extractMsg : {a} (fin a, a >= 1) =>  [a][8] -> ([a][8],[width a])\n    extractMsg DB = (Mpadded, mLen)\n                where\n                 init    = {removedPad = False,\n                            padMsg     = DB,\n                            idx        = (`a:[width a])}\n                 ys      = [init] # [ if (~y.removedPad \/\\ x==(1:[8]) )\n                                          then {removedPad = True,\n                                                padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                idx        = y.idx - 1}\n                                          | y.removedPad\n                                          then y\n                                          else {removedPad = False,\n                                                padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                idx        = y.idx - 1}\n                                    | x <- DB\n                                    | y <- ys ]\n                 Mpadded = (ys!0).padMsg\n                 mLen    = (ys!0).idx\n\nMGF1 : {maskLen,l,counterMax}\n       (fin hLen, fin l, fin maskLen\n       , hLen >= 1\n       , maskLen >= 1\n       , 2*hLen >= width (8 * (4 + l))\n       , 2^^32 * hLen >= maskLen\n       , counterMax == maskLen\/^hLen - 1 \/\/ (ceiling maskLen\/hLen) - 1\n       )\n       => [l][8] \/\/ MGF Seed\n       -> [maskLen][8]\nMGF1 mgfSeed = take`{maskLen} Ts\n     where\n\n      Cs = map (\\counter -> I2OSP`{xLen=4} counter) ([0..counterMax]:[_][32])\n      Ts = join [ split (hash (mgfSeed # c)) : [_][8] | c <- Cs]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Scheme\/RSAES_PKCS1_v1_5.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module implementing RSAES-PKCS1-v1_5 encryption and decryption over RSA keys, including the RSAES_PKCS1_v1_5_Encrypt and RSAES_PKCS1_v1_5_Decrypt functions and a property RSAES_PKCS1_Correct stating that decryption of an encrypted message recovers the original message."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Scheme::RSAES_PKCS1_v1_5 where\n\nimport Primitive::Asymmetric::Cipher::RSA\n\nparameter\n\n  type k : #\n  type constraint (fin k, k >= 11)\n\n  type KeySize = k * 8\n  n : [KeySize]\n  e : [KeySize]\n  d : [KeySize]\n\nRSAES_PKCS1_v1_5_Encrypt : {mLen} (mLen <= k - 11, mLen >= 1)\n                         => [k-mLen-3][8] -> [mLen][8] -> [k][8]\nRSAES_PKCS1_v1_5_Encrypt rand M = I2OSP`{k} c\n                         where\n                          PS = rand                           EM = ( zero : [1][8] ) # [( 1 : [8])] # PS # ( zero : [1][8] ) # M\n                          m  = OS2IP EM\n                          c  = RSAEP ((n,e),m)\n\nRSAES_PKCS1_v1_5_Decrypt : [k][8] -> ([k][8],[width k])\nRSAES_PKCS1_v1_5_Decrypt C = if c >= n then error \"decryption error\" else (Mp,idx)                          where\n                          c        = OS2IP C\n                          m        = RSADP ((n,d),c)\n                          EM       = I2OSP`{k} m\n                          (Mp,idx) = EME_PKCS1_v1_5_decode EM\n\nRSAES_PKCS1_Correct : {mLen} (mLen <= k - 11, mLen >= 1) =>\n                    [k-mLen-3][8] -> [mLen][8] -> Bit\nproperty RSAES_PKCS1_Correct rand M = take`{mLen} ((D ( E rand M ) ).0) == M\n         where\n          D = RSAES_PKCS1_v1_5_Decrypt\n          E = RSAES_PKCS1_v1_5_Encrypt\n\nprivate\n\n        EME_PKCS1_v1_5_decode : [k][8] -> ([k][8],[width k])\n        EME_PKCS1_v1_5_decode EM = if (ys!0).removedPad == False then error \"decryption error\"\n                                    | firstOctet != zero then error \"decryption error\"\n                                    | secondOctet != (1:[8]) then error \"decryption error\"\n                                    | mLen + 11 > `k then error \"decryption error\"\n                                   else (Mpadded, mLen)\n                   where\n                    firstOctet  = EM@0\n                    secondOctet = EM@1\n                    init        = {removedPad = False,\n                                   padMsg     = (tail EM)#(zero:[1][8]),\n                                   idx        = (`k-1):[width k]}\n                    ys          = [init] # [ if (~y.removedPad \/\\ x==zero)\n                                             then {removedPad = True,\n                                                   padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                   idx        = y.idx - 1}\n                                             | y.removedPad\n                                             then y\n                                             else {removedPad = False,\n                                                   padMsg     = (tail y.padMsg)#(zero:[1][8]),\n                                                   idx        = y.idx - 1}\n                                       | x <- tail EM\n                                       | y <- ys ]\n                    Mpadded     = (ys!0).padMsg\n                    mLen        = (ys!0).idx\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/RSA_PSS.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module Primitive::Asymmetric::Signature::RSA_PSS that specifies RSA-PSS signing and verification over a generic hash function, including MGF1, PSS_mgf1_encode\/verify, RSA_sign, and RSA_verify, with appropriate type parameters and constraints but without leaving any functions undefined."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::RSA_PSS where\n\nimport Common::utils\n\nparameter\n  type hLen : #   type constraint (fin hLen, hLen >= 1)\n\n  type MessageUpperBound : #\n  type constraint (width (8 * (hLen + hLen + 8)) <= MessageUpperBound)\n\n  hash : {n} (fin n, width (8 * n) <= MessageUpperBound) => [n][8] -> [8 * hLen]\n\nMGF1 : {seedLen, maskLen} (fin seedLen, fin maskLen, width (8 * seedLen + 32) <= MessageUpperBound) => [seedLen][8] -> [maskLen][8]\nMGF1 seed = take (join [ split (hash (seed # (split c))) | c <- [(0 : [32]) ...] ])\n\nPSS_mgf1_encode : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> [hLen][8] -> [emLen][8]\nPSS_mgf1_encode mHash salt = EM'\n  where\n    M' = (zero : [8][8]) # mHash # salt\n    H = split (hash M')\n    DB = (zero : [emLen - 2 * hLen - 2][8]) # [0x01] # salt\n    dbMask = MGF1 H\n    maskedDB = DB ^ dbMask\n    EM = maskedDB # H # [0xbc]\n    EM' = update EM 0 ((EM @ 0) && 0x7f)\n\nPSS_mgf1_verify : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> [emLen][8] -> Bit\nPSS_mgf1_verify mHash EM = 0xbc == byte_0xbc \/\\ 0 == (maskedDB @ 0) && 0x80 \/\\ (zero : [emLen - 2 * hLen - 2][8]) == padding \/\\ 0x01 == byte_0x01 \/\\ H == H'\n  where\n    (maskedDB # H # [byte_0xbc]) = EM\n    dbMask = MGF1 H\n    DB = maskedDB ^ dbMask\n    DB' = update DB 0 ((DB @ 0) && 0x7f)\n    padding # [byte_0x01] # salt = DB'\n    M' = (zero : [8][8]) # mHash # salt\n    H' = split (hash M')\n\nRSA_sign : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> [hLen][8] -> Integer -> Integer -> Integer\nRSA_sign mHash salt d n = (exp (integerFromBV (join (PSS_mgf1_encode`{emLen} mHash salt))) d) % n\n\nRSA_verify : {emLen} (fin emLen, emLen >= 2 * hLen + 2) => [hLen][8] -> Integer -> Integer -> Integer -> Bit\nRSA_verify mHash sig e n = sig < n \/\\ PSS_mgf1_verify`{emLen} mHash (split (integerToBV ((exp sig e) % n)))\n\nexp : Integer -> Integer -> Integer\nexp = (^^)\n\nphi : Integer -> Integer\nphi = undefined\n\nrad : Integer -> Integer\nrad = undefined\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/RSA_PSS_SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Asymmetric::Signature::RSA_PSS_SHA384` that instantiates RSA-PSS using SHA-384, including the hash length `hLen = 48`, a `hash` function based on SHA-384, and a `MessageUpperBound` type alias, suitable for use in RSA-PSS verification properties."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::RSA_PSS_SHA384 = Primitive::Asymmetric::Signature::RSA_PSS where\n\nimport Primitive::Keyless::Hash::SHA2::Instantiations::SHA384 as SHA384\n\ntype hLen = 48\nhash m = join (SHA384::hashBytes m)\ntype MessageUpperBound = SHA384::MessageUpperBound\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Cipher\/RSA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that specifies RSA encryption\/decryption and key generation, including I2OSP\/OS2IP conversions, RSAEP\/RSADP, rsaEncrypt\/rsaDecrypt, and properties RSACorrect, IntegerRSACorrectKeyGen, and IntegerRSACorrect that prove correctness of RSA and the integer-based RSA implementation for all valid messages."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Cipher::RSA where\n\nimport Common::mod_arith\n\nI2OSP : {xLen,int} (fin int, fin xLen, int<=xLen*8, xLen>=1) =>\n      [int] -> [xLen][8]\nI2OSP x = split ((zero # x):[xLen*8]) : [xLen][8]\n\nOS2IP : {xLen} (fin xLen) => [xLen][8] -> [xLen*8]\nOS2IP xs = join xs\n\nI2OSConversionCorrect : {xLen} (fin xLen, xLen>=1) => [xLen][8] -> Bit\nproperty I2OSConversionCorrect xs = I2OSP (OS2IP xs) == xs\n\nRSAEP : {K} (fin K, K >= 1) => (([K],[K]),[K]) -> [K]\nRSAEP ((n, e), m) = if (m < zero \\\/ m > (n-1)) then error \"message representative out of range\"\n                    else c\n      where c = mod_pow (n,m,e)\n\nRSADP : {K} (fin K, K >= 1) => (([K],[K]),[K]) -> [K]\nRSADP ((n, d), c) = if (c < 0 \\\/ c > (n-1)) then error \"ciphertext representative out of range\"\n                    else m\n      where m = mod_pow (n,c,d)\n\nRSACorrect : {K} (fin K, K >= 1) => [K] -> [K] -> [K] -> [K] -> Bit\nproperty RSACorrect e d n msg = ( msg >= zero \/\\ msg < n ) ==> RSADP ((n,d), RSAEP ((n,e), msg)) == msg\n\nrsaTest = {n = 0xbad47a84c1782e4dbdd913f2a261fc8b65838412c6e45a2068ed6d7f16e9cdf4462b39119563cafb74b9cbf25cfd544bdae23bff0ebe7f6441042b7e109b9a8afaa056821ef8efaab219d21d6763484785622d918d395a2a31f2ece8385a8131e5ff143314a82e21afd713bae817cc0ee3514d4839007ccb55d68409c97a18ab62fa6f9f89b3f94a2777c47d6136775a56a9a0127f682470bef831fbec4bcd7b5095a7823fd70745d37d1bf72b63c4b1b4a3d0581e74bf9ade93cc46148617553931a79d92e9e488ef47223ee6f6c061884b13c9065b591139de13c1ea2927491ed00fb793cd68f463f5f64baa53916b46c818ab99706557a1c2d50d232577d1 : [2048]\n           , d = 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010001 : [2048]\n           , e = 0x40d60f24b61d76783d3bb1dc00b55f96a2a686f59b3750fdb15c40251c370c65cada222673811bc6b305ed7c90ffcb3abdddc8336612ff13b42a75cb7c88fb936291b523d80acce5a0842c724ed85a1393faf3d470bda8083fa84dc5f31499844f0c7c1e93fb1f734a5a29fb31a35c8a0822455f1c850a49e8629714ec6a2657efe75ec1ca6e62f9a3756c9b20b4855bdc9a3ab58c43d8af85b837a7fd15aa1149c119cfe960c05a9d4cea69c9fb6a897145674882bf57241d77c054dc4c94e8349d376296137eb421686159cb878d15d171eda8692834afc871988f203fc822c5dcee7f6c48df663ea3dc755e7dc06aebd41d05f1ca2891e2679783244d068f : [2048]\n           , M = 0x70992c9d95a4908d2a94b3ab9fa1cd643f120e326f9d7808af50cac42c4b0b4eeb7f0d4df303a568fbfb82b0f58300d25357645721bb71861caf81b27a56082c80a146499fb4eab5bde4493f5d00f1a437bbc360dfcd8056fe6be10e608adb30b6c2f7652428b8d32d362945982a46585d2102ef7995a8ba6e8ad8fd16bd7ae8f53c3d7fcfba290b57ce7f8f09c828d6f2d3ce56f131bd9461e5667e5b73edac77f504dac4f202a9570eb4515b2bf516407db831518db8a2083ec701e8fd387c430bb1a72deca5b49d429cf9deb09cc4518dc5f57c089aa2d3420e567e732102c2c92b88a07c69d70917140ab3823c63f312d3f11fa87ba29da3c7224b4fb4bc : [2048]\n           , C = 0x7e65b998a05f626b028c75dc3fbf98963dce66d0f4c3ae4237cff304d84d8836cb6bad9ac86f9d1b8a28dd70404788b869d2429f1ec0663e51b753f7451c6b4645d99126e457c1dac49551d86a8a974a3131e9b371d5c214cc9ff240c299bd0e62dbc7a9a2dad9fa5404adb00632d36332d5be6106e9e6ec81cac45cd339cc87abbe7f89430800e16e032a66210b25e926eda243d9f09955496ddbc77ef74f17fee41c4435e78b46965b713d72ce8a31af641538add387fedfd88bb22a42eb3bda40f72ecad941dbffdd47b3e77737da741553a45b630d070bcc5205804bf80ee2d51612875dbc4796960052f1687e0074007e6a33ab8b2085c033f9892b6f74 : [2048] }\n\nproperty testsPass = rsaTest.M == RSADP ((rsaTest.n, rsaTest.d), rsaTest.C)\n\ngenRSAKeys : (Integer,Integer) -> (Integer,Integer,Integer) genRSAKeys (p,q) = (p*q,e,d)\n           where nTotient = lcm (p-1) (q-1)\n                 e        = 65537                  d        = inv e nTotient\n\nprivate\n    gcd : Integer -> Integer -> Integer\n    gcd x y =  gcd' x y\n        where gcd' a b = if b == zero then a else gcd' b (a%b)\n\n    lcm : Integer -> Integer -> Integer\n    lcm x y =  if (x == zero \\\/ y == zero) then zero else (x \/ (gcd x y)) * y\n\n    inv : Integer -> Integer -> Integer \/\/ Note, k and m MUST be coprime\n    inv k m = (inv' m k).1 % m\n      where\n        inv' n x = if x==1 then (zero, 1) else (r', q' - r' * q)\n          where\n            (q,  r)  = (n\/x, n%x)\n            (q', r') = inv' x r\n\nrsaEncrypt : (Integer,Integer,Integer) -> Integer\nrsaEncrypt (msg,e,n) = (msg^^e)%n\n\nrsaDecrypt : (Integer,Integer,Integer) -> Integer\nrsaDecrypt (ct,d,n) = (ct^^d)%n\n\n\/\/ :prove IntegerRSACorrectKeyGen 49979693 67867967\n\/\/ :check IntegerRSACorrectKeyGen 49979693 67867967\nIntegerRSACorrectKeyGen : Integer -> Integer -> Integer -> Bit\nproperty IntegerRSACorrectKeyGen p q msg = ( msg >= zero \/\\ msg < n ) ==>\n         rsaDecrypt (rsaEncrypt (msg,e,n),d,n) == msg\n         where (n,e,d) = genRSAKeys (p,q)\n\n\/\/ :prove IntegerRSACorrect 7 103 143\n\/\/ :check IntegerRSACorrect 7 103 143\n\/\/ :check IntegerRSACorrect (toInteger e) (toInteger d) (toInteger n)\nIntegerRSACorrect : Integer -> Integer -> Integer -> Integer -> Bit\nproperty IntegerRSACorrect e d n msg = ( msg >= zero \/\\ msg < n ) ==>\n         rsaDecrypt (rsaEncrypt (msg,e,n),d,n) == msg\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/ML_DSA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the ML-DSA key generation, signing, and verification API (KeyGen, Sign, Verify) and the property MLDSAIsCorrect that states signatures produced by Sign with keys from KeyGen always verify with Verify for all inputs and contexts, matching the described types and behavior."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ML_DSA::ML_DSA where\n\nimport interface Primitive::Asymmetric::Signature::ML_DSA::Parameters as P\nimport Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification { interface P }\n\nKeyGen : Option ([32]Byte) -> Option (PublicKey, PrivateKey)\nKeyGen maybe_\u03be = case maybe_\u03be of\n    None -> None\n    Some \u03be -> Some (KeyGen_internal \u03be)\n\nSign : {m, c} (fin m, fin c) =>\n    PrivateKey -> [m] -> [c]Byte -> Option ([32]Byte) -> Option (Signature)\nSign sk M ctx maybe_rnd\n        | c > 255 => None\n        | c <= 255 => case maybe_rnd of\n        None -> None\n        Some rnd -> sigma where\n                                                            M' = join (IntegerToBytes`{1} 0 # IntegerToBytes`{1} `c # ctx) # M\n            \/\/ Step 11.\n            sigma = Some (Sign_internal sk M' rnd)\n\nVerify : {m, c} (fin m, fin c) =>\n    PublicKey -> [m] -> Signature -> [c]Byte -> Option Bool\nVerify pk M sigma ctx\n    | c > 255 => None\n    | c <= 255 => Some (Verify_internal pk M' sigma) where\n        \/\/ Step 10. We use `join` instead of `BytesToBits`, which produces\n        \/\/ the same byte string, but with the bits in each byte reversed.\n        \/\/ I think we have to do this to support the later call to `HBits`,\n        \/\/ which expects the bit-order and byte-order to be the same.\n        M' = join (IntegerToBytes`{1} 0 # IntegerToBytes`{1} `c # ctx) # M\n\nsubmodule TestAPI where\n    import Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification { interface P } as Spec\n\n    KeyGen_internal = Spec::KeyGen_internal\n    Sign_internal = Spec::Sign_internal\n    Verify_internal = Spec::Verify_internal\n\nMLDSAIsCorrect : {m} (fin m) => [32]Byte -> [32]Byte -> [m] -> [255]Byte -> Bit\nproperty MLDSAIsCorrect \u03be rnd M ctx = sigVerifies where\n    maybe_keys = KeyGen (Some \u03be)\n    maybe_sigVerifies = case maybe_keys of\n        None -> None\n        Some keys -> case (Sign sk M ctx (Some rnd)) of\n                None -> None\n                Some sig -> Verify pk M sig ctx\n            where (pk, sk) = keys\n    sigVerifies = case maybe_sigVerifies of\n        None -> False\n        Some v -> v\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that fully specifies the ML-DSA (FIPS-204) scheme, including key generation, signing, and verification, along with the given encoding\/decoding, sampling, NTT operations, and all listed properties that show these components are inverses or satisfy their stated definitions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ML_DSA::Specification where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE128 as SHAKE128\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256 as SHAKE256\n\ntype Byte = [8]\n\nproperty bitlenIsWidth = (`(width 32) == 6) && (`(width 31) == 5)\n\ntype Tq = [256](Z q)\n\ntype R = [256]Integer\n\ntype R2 = [256]\n\ntype Rq = [256](Z q)\n\nmodPlusMinus : {\u03b1} (fin \u03b1) => Z q -> Integer\nmodPlusMinus m = m' where\n    m_int = (fromZ m) % `\u03b1\n    m' = if m_int > (`\u03b1 \/ 2) then m_int - `\u03b1\n        else m_int\n\nmodPlusMinusWorks : {\u03b1} (fin \u03b1) => Z q -> Bit\nproperty modPlusMinusWorks m = inRange && congruent where\n    m' = modPlusMinus`{\u03b1} m\n    lower_bound = - ((`\u03b1 + 1) \/ 2)\n    inRange = (lower_bound < m') && (m' <= (`\u03b1 \/ 2))\n    congruent = ((fromZ m) % `\u03b1) == (m' % `\u03b1)\n\ninfNormRq : {m} (fin m) => [m]Rq -> Integer\ninfNormRq w = maxList [ maxList [ abs (modPlusMinus`{q} wij)\n    | wij <- wi]\n    | wi <- w]\n\ninfNormR : {m} (fin m) => [m]R -> Integer\ninfNormR w = maxList [ maxList [ abs wij | wij <- wi] | wi <- w]\n\ncastToRq : {m} (fin m) => [m]R -> [m]Rq\ncastToRq v = [map fromInteger vi | vi <- v]\n\nprivate\n\n    maxList : {n, a} (fin n, Literal 0 a, Cmp a) => [n]a -> a\n    maxList list = foldl max 0 list\n\nNTT_Vec = map NTT\nNTTInv_Vec = map NTTInv\n\nH : {l, m} (fin m) => [m][8] -> [l][8]\nH str = SHAKE256::xofBytes`{8 * l} str\n\nHBits : {l, m} (fin m) => [m] -> [l][8]\nHBits str = split (SHAKE256::xof`{8 * l} (str))\n\nG : {l, m} (fin m) => [m][8] -> [l][8]\nG str = SHAKE128::xofBytes`{8 * l} str\n\nimport interface Primitive::Asymmetric::Signature::ML_DSA::Parameters\n\n\u03b6 : Z q\n\u03b6 = 1753\n\ntype d = 13\n\n\u03b2 = `(\u03b7 * \u03c4) : Integer\n\ntype PublicKey = [32 + 32 * k * (width (q - 1) - d)]Byte\n\ntype PrivateKey = [32 + 32 + 64 + 32 * ((k + ell) * width (2 * \u03b7) + d * k)]Byte\n\ntype Signature = [\u03bb \/ 4 + ell * 32 * (1 + width (\u03b31 - 1)) + \u03c9 + k]Byte\n\nKeyGen_internal : [32]Byte -> (PublicKey, PrivateKey)\nKeyGen_internal \u03be = (pk, sk) where\n        (\u03c1 # \u03c1' # K) = H`{128} (\u03be # IntegerToBytes`{1} `k # IntegerToBytes`{1} `ell)\n\n    \/\/ Step 3.\n    A_hat = ExpandA \u03c1\n    \/\/ Step 4.\n    (s1, s2) = ExpandS \u03c1'\n\n        s1' = castToRq s1\n    s2' = castToRq s2\n\n        t = NTTInv_Vec (A_hat \u2218\u2218 NTT_Vec s1') + s2'\n        (t1, t0) = Power2Round t\n\n        pk = pkEncode \u03c1 t1\n        tr = H`{64} pk\n        sk = skEncode \u03c1 K tr s1 s2 t0\n\nSign_internal : {m} (fin m) => PrivateKey -> [m] -> [32]Byte -> Signature\nSign_internal sk M' rnd = \u03c3 where\n    \/\/ Step 1.\n    (\u03c1, K, tr, s1, s2, t0) = skDecode sk\n\n    \/\/ Steps 2 - 5.\n    s1_hat = NTT_Vec (castToRq s1)\n    s2_hat = NTT_Vec (castToRq s2)\n    t0_hat = NTT_Vec (castToRq t0)\n    A_hat = ExpandA \u03c1\n\n    \/\/ Step 6. We use `join` instead of `BytesToBits`, which produces the same\n    \/\/ byte string, but with the bits in each byte reversed. I think we have to\n    \/\/ do this to support the call to `HBits`, which expects the bit-order and\n    \/\/ byte-order to be the same.\n    \u03bc = HBits`{64} (join tr # M')\n\n        \u03c1''= H`{64} (K # rnd # \u03bc)\n\n            rejection_sample: Integer -> ([\u03bb \/ 4]Byte, ([ell]Rq, [k]R2))\n    rejection_sample \u03ba = case maybe_zh of\n            Some zh -> (c_til, zh)\n            None -> rejection_sample (\u03ba + `ell)\n        where\n            y = castToRq (ExpandMask \u03c1'' \u03ba)\n            w = NTTInv_Vec (A_hat \u2218\u2218 (NTT_Vec y))\n            w1 = HighBits w\n            c_til = H`{\u03bb \/ 4} (\u03bc # w1Encode w1)\n            [c] = castToRq [(SampleInBall c_til)]\n            c_hat = NTT c\n            cs1 = NTTInv_Vec (c_hat \u2218 s1_hat)\n            cs2 = NTTInv_Vec (c_hat \u2218 s2_hat)\n            z = y + cs1\n            r0 = LowBits (w - cs2)\n            maybe_zh = if (infNormRq z >= `\u03b31 - \u03b2) || (infNormR r0 >= `\u03b32 - \u03b2)\n                then None\n                else maybe_zh' where\n                    ct0 = NTTInv_Vec (c_hat \u2218 t0_hat)\n                    h = MakeHint (-ct0) (w - cs2 + ct0)\n                    maybe_zh' =\n                        if (infNormRq ct0 >= `\u03b32) || (numberOf1sInh > `\u03c9)\n                        then None\n                        else Some (z, h)\n\n                                                            numberOf1sInh = sum [if b then 1 else 0 | b <- join h]\n\n        (c_tilFinal, (zFinal, hFinal)) = rejection_sample 0\n\n        modPlusMinus_Vec v = [map modPlusMinus`{q} vi | vi <- v]\n\n        \u03c3 = sigEncode c_tilFinal (modPlusMinus_Vec zFinal) hFinal\n\nVerify_internal : {m} (fin m) => PublicKey -> [m] -> Signature -> Bool\nVerify_internal pk M' \u03c3 = isValid where\n    \/\/ Step 1 - 2.\n    (rho, t1) = pkDecode pk\n    (c_til, z, h) = sigDecode \u03c3\n\n    \/\/ Step 5.\n    A_hat = ExpandA rho\n    \/\/ Step 6.\n    tr = H`{64} pk\n    \/\/ Step 7. We use `join` instead of `BytesToBits`, which produces the same\n    \/\/ byte string, but with the bits in each byte reversed. I think we have to\n    \/\/ do this to support the call to `HBits`, which expects the bit-order and\n    \/\/ byte-order to be the same.\n    mu = HBits`{64} (join tr # M')\n\n        [c] = castToRq [(SampleInBall c_til)]\n\n        t1' = castToRq t1\n    z' = castToRq z\n            two_d = repeat (repeat (2^^`d))\n\n        wApprox' = NTTInv_Vec (A_hat \u2218\u2218 NTT_Vec z' - (NTT c \u2218 NTT_Vec (t1' * two_d)))\n\n    \/\/ Steps 3 - 4, 10 - 13.\n    isValid = case h of\n        None -> False\n        Some h' -> (infNormR z < `\u03b31 - \u03b2) && (c_til == c_til') where\n            w1' = UseHint h' wApprox'\n            c_til' = H`{\u03bb \/ 4} (mu # w1Encode w1')\n\nIntegerToBits : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]\nIntegerToBits x = y' where\n    \/\/ Step 3. Compute the value of each `y_i`.\n    y = [x' % 2 | x' <- xs' | i <- [0..\u03b1 - 1]]\n\n            xs' = [x] # [x' \/ 2 | x' <- xs']\n\n            y' = join [(fromInteger yi) : [1] | yi <- y]\n\n\/**\n * Compute the integer value expressed by a bit string using little-endian\n * order.\n * [FIPS-204] Section 7.1, Algorithm 10.\n *\/\nBitsToInteger : {\u03b1} (fin \u03b1, \u03b1 > 0) => [\u03b1] -> Integer\nBitsToInteger y = xs ! 0 where\n    \/\/ Cryptol-specific conversion: separate the input into \u03b1 1-bit vectors,\n    \/\/ then convert each to an integer.\n    y' = map toInteger (split`{\u03b1} y)\n\n        xs = [0] # [2 * x + y' @ (`\u03b1 - i)\n        | x <- xs\n        | i <- [1..\u03b1]]\n\n\/**\n * The integer \/ bit conversion functions must invert each other.\n * This is not explicit in the spec, but we define the property anyway.\n * The parameter choices are approximately the same as some of the use cases\n * in the spec.\n * ```repl\n * :check BitsToIntegersInverts`{44}\n * :exhaust BitsToIntegersInverts`{10}\n * ```\n *\/\nBitsToIntegersInverts : {\u03b1} (fin \u03b1, \u03b1 > 0) => [\u03b1] -> Bit\nproperty BitsToIntegersInverts x = IntegerToBits (BitsToInteger x) == x\n\n\/**\n * Compute a base-256 representation of `x mod 256^\u03b1` using little-endian byte\n * order.\n * [FIPS-204] Section 7.1, Algorithm 11.\n *\/\nIntegerToBytes : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]Byte\nIntegerToBytes x = y where\n    \/\/ Step 2 - 3.\n    y = [fromInteger (x' % 256) | x' <- xs' | i <- [0..\u03b1 - 1]]\n\n        xs' = [x] # [x' \/ 256 | x' <- xs']\n\nBitsToBytes : {\u03b1} (fin \u03b1) => [\u03b1]Bit -> [\u03b1 \/^ 8]Byte\nBitsToBytes y\n        | \u03b1 == 0 => zero\n    | \u03b1 > 0 => z where\n                                        y' = groupBy`{8} ([(zext [yi], i)\n            | yi <- y\n            | i <- [0..\u03b1 - 1]] # zero)\n\n        \/\/ Steps 2 - 4. We compute the `y` terms separately then `sum` them\n        \/\/ for each byte in `z`.\n        z = [sum [yi * (2 ^^ (i % 8))\n                | (yi, i) <- yi8]\n            | yi8 <- y']\n\nBytesToBits : {\u03b1} (fin \u03b1) => [\u03b1]Byte -> [8 * \u03b1]Bit\nBytesToBits z\n    | \u03b1 == 0 => []\n    | \u03b1 > 0 => join [[ y8ij where\n                                    y8ij = zi' ! 0\n            \/\/ Step 5. Shifting right is the same as the iterative\n            \/\/ division (see `div2IsShiftR`). This accounts for all the\n            \/\/ divisions \"up to this point\" (e.g. none when `j = 0`), which\n            \/\/ is why we use `zi'` to evaluate `y8ij` above.\n            zi' = zi >> j\n        \/\/ Step 3.\n        | j <- [0..7]]\n        \/\/ Step 2. We iterate over `z` directly instead of indexing into it.\n        | zi <- z ]\n\nprivate\n    \/**\n     * The iterative division by 2 in `BytesToBits` is the same as shifting\n     * right.\n     * ```repl\n     * :prove div2IsShiftR\n     * ```\n     *\/\n    div2IsShiftR : Byte -> Bit\n    div2IsShiftR C = take (d2 C) == shl where\n        \/\/ Note: division here is floor'd by default.\n        d2 c = [c] # d2 (c \/ 2)\n        shl = [C >> j | j <- [0..7]]\n\nB2B2BInverts : {\u03b1} (fin \u03b1) => [8 * \u03b1] -> Bit\nproperty B2B2BInverts y = BytesToBits (BitsToBytes y) == y\n\nCoeffFromThreeBytes : Byte -> Byte -> Byte -> Option (Z q)\nCoeffFromThreeBytes b0 b1 b2 = maybe_z where\n        b2' = if b2 > 127 then b2 - 128 else b2\n\n    \/\/ We have to explicitly expand the byte strings to support the\n    \/\/ operations in the next step. 32 bits gives us plenty of space.\n    [bq0, bq1, bq2'] = map zext`{32} [b0, b1, b2']\n\n    \/\/ Step 5.\n    z = 2^^16 * bq2' + 2^^8 * bq1 + bq0\n\n                maybe_z = if z < `q then Some (toZ z) else None\n\n    toZ : [32] -> Z q\n    toZ b = fromInteger (toInteger b)\n\nCoeffFromHalfByte : [4] -> Option Integer\nCoeffFromHalfByte b =\n    if (`\u03b7 == 2) && (b < 15) then Some (2 - (toInteger b % 5))\n    else\n        if (`\u03b7 == 4) && (b < 9) then Some (4 - toInteger b)\n        else None\n\nSimpleBitPack : {b} (fin b, width b > 0) => R -> [32 * width b]Byte\nSimpleBitPack w = BitsToBytes z where\n    z = join [IntegerToBits`{width b} (w@i) | i <- [0..255]]\n\nBitPack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    R -> [32 * width (a + b)]Byte\nBitPack w = BitsToBytes z where\n    z = join [IntegerToBits`{width (a + b)} (`b - w@i) | i <- [0..255]]\n\nSimpleBitUnpack : {b} (fin b, width b > 0) => [32 * width b]Byte -> R\nSimpleBitUnpack v = w where\n    type c = width b\n    z = BytesToBits v\n            z_ics = split z : [256][c]\n    w = [BitsToInteger`{c} (z_ics@i) | i <- [0..255]]\n\nSimplePackingInverts : {b} (fin b, width b > 0) => [256](Z b) -> Bit\nproperty SimplePackingInverts w_inRange = simplePackInverts where\n    w = map fromZ w_inRange\n    simplePackInverts = SimpleBitUnpack`{b} (SimpleBitPack`{b} w) == w\n\nBitUnpack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    [32 * width (a + b)]Byte -> R\nBitUnpack v = w where\n    type c = width (a + b)\n    z = BytesToBits v\n\n            z_ics = split z : [256][c]\n\n    w = [`b - BitsToInteger`{c} (z_ics@i)| i <- [0..255]]\n\nPackingInverts : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    [256](Z (a + b)) -> Bit\nproperty PackingInverts w_inRange = packInverts where\n        w = [(fromZ wi) - `a | wi <- w_inRange]\n    packInverts = BitUnpack`{a, b} (BitPack`{a, b} w) == w\n\nHintBitPack : [k]R2 -> [\u03c9 + k]Byte\nHintBitPack h = yFinal where\n        y0 = zero : [\u03c9 + k]Byte\n        Index0 = 0\n            yAndIndex = [(y0, Index0)] # [ (y'', Index') where\n            \/\/ Steps 5 - 8.\n            (y', Index') = if (h @i @j) != 0 then\n                    (update y Index j, Index + 1)\n                else (y, Index)\n\n            \/\/ Step 10.\n            y'' = if j == 255 then\n                    update y' (`\u03c9 + i) Index'\n                else y'\n        | (y, Index) <- yAndIndex\n                | i <- [0..k-1], j <- [0..255]\n    ]\n        (yFinal, _) = yAndIndex ! 0\n\nHintBitUnpack : [\u03c9 + k]Byte -> Option ([k]R2)\nHintBitUnpack y = hFinal where\n        h0 = zero : [k * 256]\n        Index0 = 0\n\n            hAndIndexes = [Some (h0, Index0)] # [\n                        case maybe_hAndIndex of\n                Some hAndIndex -> Step4_5 hAndIndex i\n                None -> None\n        | maybe_hAndIndex <- hAndIndexes\n        | i <- [0..k-1]\n    ]\n\n        Step4_5 (h, Index) i = if (y@(`\u03c9 + i) < Index) || (y@(`\u03c9 + i) > `\u03c9) then\n            None\n        else Step6_15 (h, Index) i\n\n        Step6_15 (h, Index) i = Step7_14 (h, Index) where\n                First = Index\n\n                Step7_14 (h', Index') =\n                        if Index' < (y@(`\u03c9 + i)) then\n                \/\/ Step 8 - 11.\n                \/\/ The `\/\\` is a short-cutting `and`, equivalent to the nested\n                \/\/ `if` statements in the spec.\n                if ((Index' > First) \/\\ (y@(Index' - 1) >= y@Index')) then None\n                                else Step7_14\n                                        (update h' (i*256 + (toInteger (y@Index'))) 1,\n                                        Index' + 1)\n            \/\/ If the loop condition is no longer true, return the current\n            \/\/ values of `h` and `Index`.\n            else Some (h', Index')\n\n    \/\/ Get the values of `h` and `Index` after the loop in Steps 3 - 15.\n    maybe_hAndIndex' = hAndIndexes ! 0\n\n        hFinal = case maybe_hAndIndex' of\n        Some hAndIndex -> if checkLeftoverBytes then\n                \/\/ This `split` converts back to the spec-adherent\n                \/\/ representation of `h`.\n                Some (split`{k} h)\n            else None\n            where\n                (h, Index) = hAndIndex\n                \/\/ This helper reads any \"leftover\" bytes (e.g. beyond `Index`)\n                \/\/ in the first `\u03c9` bytes of `y`; it returns `True` if all of\n                \/\/ them are zero.\n                checkLeftoverBytes = and [i >= Index ==> y@i == 0\n                    | i <- [0..\u03c9 - 1]]\n\n        None -> None\n\n\/**\n * Verify that `HintBitUnpack` is the reverse of `HintBitPack`.\n *\n * This takes a list of indexes indicating the non-zero elements and constructs\n * a valid, sparse `h` -- rejection sampling is not a valid option because\n * sparse-enough `h`s were too rare.\n *\n * We test the case where we have the maximum number of 1s, a medium number, and\n * a case where at least one vector should have no non-zero terms at all.\n * In practice, the hint may fall anywhere in this range.\n * This takes about 1 minute.\n * ```repl\n * :check HintPackingInverts`{\u03c9}\n * :check HintPackingInverts`{\u03c9 \/ 2}\n * :check HintPackingInverts`{3}\n * ```\n *\n * Note that this does not test the error cases for `HintBitUnpack`.\n *\/\nHintPackingInverts : {w} (w <= \u03c9) => [w][lg2 (256 * k)] -> Bit\nproperty HintPackingInverts h_Indexes =\n    case HintBitUnpack (HintBitPack h) of\n        Some h' -> h == h'\n        None -> False\n    where\n        h = buildHint h_Indexes\n\nprivate\n    \/**\n     * Creates a hint with `w` non-zero entries at the indices specified in\n     * the parameter.\n     * This is for testing functions that take a hint as a parameter and assume\n     * it is appropriately sparse.\n     *\/\n    buildHint : {w} (w <= \u03c9) => [w][lg2 (256 * k)] -> [k]R2\n    buildHint h_Indexes = h where\n        h = split`{k} [if elem idx h_Indexes then 1 else 0 | idx <- [0..(256 * k) - 1]]\n\n\/**\n * Encode a public key for ML-DSA into a byte string.\n * [FIPS-204] Section 7.2, Algorithm 22.\n *\n * This assumes that `t1` has coefficients in the range\n * `[0, 2^(bitlen(q-1) - d) - 1]`.\n *\/\npkEncode : [32]Byte -> [k]R -> PublicKey\npkEncode \u03c1 t1 = pk where\n    pk = \u03c1 # join [SimpleBitPack`{2 ^^ (width (q - 1) - d) - 1} (t1@i) | i <- [0..k-1]]\n\n\/**\n * Reverse the procedure `pkEncode`.\n * [FIPS-204] Section 7.2, Algorithm 23.\n *\n * This produces a `t1` with coefficients in the range\n * `[0, 2^(bitlen(q-1) - d) - 1]`.\n *\/\npkDecode : PublicKey -> ([32]Byte, [k]R)\npkDecode pk = (\u03c1, t1) where\n    \/\/ Step 1. We split off the single `\u03c1` byte, then separate the remaining\n    \/\/ bytes into the `k` components as described.\n    (\u03c1 # zBytes) = pk\n    z = split zBytes\n    \/\/ Steps 2 - 4.\n    t1 = [SimpleBitUnpack`{2 ^^ (width (q - 1) - d) - 1} (z@i) | i <- [0..k-1]]\n\nprivate\n    \/**\n     * `pkDecode` must reverse the procedure `pkEncode`.\n     * This takes about 30s.\n     * ```repl\n     * :set tests=20\n     * :check pkCodingInverts\n     * ```\n     *\/\n    pkCodingInverts : [32]Byte -> [k][256][width (q - 1) - d] -> Bit\n    pkCodingInverts \u03c1 t1_inRange = inverts where\n        \/\/ `t1_inRange` is typed to ensure that all the coefficients will be\n        \/\/ in the range `[0, 2^^(width (q-1)-d) - 1]`.\n        t1 = [map toInteger t1_i | t1_i <- t1_inRange]\n        (\u03c1', t1') = pkDecode (pkEncode \u03c1 t1)\n        inverts = (\u03c1 == \u03c1') && (t1 == t1')\n\n\/**\n * Encodes a secret key for ML-DSA into a byte string.\n * [FIPS-204] Secetion 7.2, Algorithm 24.\n *\/\nskEncode : [32]Byte -> [32]Byte -> [64]Byte -> [ell]R -> [k]R -> [k]R\n    -> PrivateKey\nskEncode \u03c1 K tr s1 s2 t0 = sk9 where\n    \/\/ Note: `sk#` indicates the value of `sk` at Step `#`.\n    \/\/ Step 1.\n    sk1 = \u03c1 # K # tr\n    \/\/ Steps 2 - 4.\n    sk3 = sk1 # join [BitPack`{\u03b7, \u03b7} (s1@i) | i <- [0..ell-1]]\n    \/\/ Steps 5 - 7.\n    sk6 = sk3 # join [BitPack`{\u03b7, \u03b7} (s2@i) | i <- [0..k-1]]\n    \/\/ Steps 8 - 10.\n    sk9 = sk6 #\n        join [BitPack`{2^^(d - 1) - 1, 2^^(d - 1)} (t0@i) | i <- [0..k-1]]\n\n\/**\n * Reverse the procedure `skEncode`.\n * [FIPS-204] Section 7.2, Algorithm 25.\n *\n * Warning: there exist malformed inputs that can cause `skDecode` to return\n * values that are not in the correct range! `skDecode` must only be run on\n * inputs that come from trusted sources!\n *\/\nskDecode : PrivateKey -> ([32]Byte, [32]Byte, [64]Byte, [ell]R, [k]R, [k]R)\nskDecode sk = (\u03c1, K, tr, s1, s2, t0) where\n    \/\/ Step 1. We split off the six components, then further separate `y`, `z`,\n    \/\/ and `w` into their two dimensions.\n    (\u03c1 # K # tr # yBytes # zBytes # wBytes) = sk\n    y = split`{ell} yBytes\n    z = split`{k} zBytes\n    w = split`{k} wBytes\n\n    \/\/ Steps 2 - 4.\n    s1 = [BitUnpack`{\u03b7, \u03b7} (y@i) | i <- [0..ell-1]]\n    \/\/ Steps 5 - 7.\n    s2 = [BitUnpack`{\u03b7, \u03b7} (z@i) | i <- [0..k-1]]\n    \/\/ Steps 8 - 10.\n    t0 = [BitUnpack`{2^^(d - 1) - 1, 2^^(d - 1)} (w@i) | i <- [0..k-1]]\n\nprivate\n    \/**\n     * The `skDecode` function must be the inverse of `skEncode`.\n     * [FIPS-204] Section 7.3, comment on Algorithm 25.\n     *\n     * This test enforces the range requirements on the inputs to\n     * `skEncode` by taking parameters in the integers mod groups, then\n     * converting to unbounded integers and shifting to be in the expected\n     * range.\n     *\n     * This takes about 1 minute.\n     * ```repl\n     * :set tests=20\n     * :check skCodingInverts\n     * ```\n     *\/\n    skCodingInverts : [32]Byte -> [32]Byte -> [64]Byte\n        -> [ell][256](Z (2 * \u03b7))\n        -> [k][256](Z (2 * \u03b7))\n        -> [k][256](Z (2 ^^ d - 1))\n        -> Bit\n    skCodingInverts \u03c1 K tr s1_inRange s2_inRange t0_inRange = inverts where\n        \/\/ Adjust to be in the correct range and of the correct type.\n        s1 = [[(fromZ s1_ij) - `\u03b7 | s1_ij <- s1_j ] | s1_j <- s1_inRange]\n        s2 = [[(fromZ s2_ij) - `\u03b7 | s2_ij <- s2_j ] | s2_j <- s2_inRange]\n        t0 = [[(fromZ t0_ij) - (2 ^^ (`d-1) - 1)\n            | t0_ij <- t0_j ]\n            | t0_j <- t0_inRange]\n\n        (\u03c1', K', tr', s1', s2', t0') = skDecode (skEncode \u03c1 K tr s1 s2 t0)\n        inverts = (\u03c1 == \u03c1') && (K == K') && (tr == tr')\n            && (s1 == s1') && (s2 == s2') && (t0 == t0')\n\n\/**\n * Encode a signature into a byte string.\n * [FIPS-204] Section 7.3, Algorithm 26.\n *\n * The parameter `z` must have coefficients in `[-\u03b31 + 1, \u03b31]`.\n *\/\nsigEncode : [\u03bb \/ 4]Byte -> [ell]R -> [k]R2 -> Signature\nsigEncode c_til z h = \u03c3 where\n    \/\/ Note that `\u03c3#` indicates the value of `\u03c3` at Step `#`.\n    \/\/ Step 1.\n    \u03c31 = c_til\n    \/\/ Step 2 - 4.\n    \u03c33 = \u03c31 # join [BitPack`{\u03b31 - 1, \u03b31} (z@i) | i <- [0..ell-1]]\n    \/\/ Step 5.\n    \u03c3 = \u03c33 # HintBitPack h\n\n\/**\n * Reverse the procedure `sigEncode`.\n * [FIPS-204] Section 7.3, Algorithm 27.\n *\/\nsigDecode : Signature -> ([\u03bb \/ 4]Byte, [ell]R, Option ([k]R2))\nsigDecode \u03c3 = (c_til, z, h) where\n    \/\/ Step 1. We separate into bytes, then further split `x` into its two\n    \/\/ dimensions.\n    (c_til # xBytes # y) = \u03c3\n    x = split`{ell} xBytes\n\n    \/\/ Step 2 - 4.\n    z = [BitUnpack`{\u03b31 - 1, \u03b31} (x@i) | i <- [0..ell-1]]\n    \/\/ Step 5.\n    h = HintBitUnpack y\n\nprivate\n    \/**\n     * `sigDecode` must be the reverse of `sigEncode`.\n     * [FIPS-204] Section 7.3, comment on Algorithm 27.\n     *\n     * The parameter `w` defines the number of non-zero entries in the hint.\n     * It can be any number in the range `[0, \u03c9 - 1]`. In practice, it's\n     * dependent on many factors, so we choose the middle of the range for convenience.\n     * This takes about 45 seconds.\n     * ```repl\n     * :set test=20\n     * :check sigCodingInverts`{\u03c9 \/ 2}\n     * ```\n     *\/\n    sigCodingInverts : {w} (w < \u03c9) =>\n        [\u03bb \/ 4]Byte -> [ell][256](Z (2 * \u03b31 - 1)) -> [w][lg2 (256 * k)] -> Bit\n    property sigCodingInverts c_til z_inRange h_Indexes = inverts where\n                        z = [[(fromZ zij) - (`\u03b31 - 1) | zij <- zi ] | zi <- z_inRange]\n\n                        h = buildHint h_Indexes\n\n        (c_til', z', maybe_h') = sigDecode (sigEncode c_til z h)\n        h_matches = case maybe_h' of\n            Some h' -> h == h'\n            None -> False\n        inverts = (c_til == c_til') && (z == z') && h_matches\n\nw1Encode : [k]R -> [32 * k * width ((q - 1) \/ (2 * \u03b32) - 1)]Byte\nw1Encode w1 = w1_til where\n    w1_til = join\n        [SimpleBitPack`{(q - 1) \/ (2 * \u03b32) - 1} (w1@i) | i <- [0..k-1]]\n\nSampleInBall : [\u03bb \/ 4]Byte -> R\nSampleInBall \u03c1 = cFinal where\n        c0 = zero\n        ctx_0 = H`{inf} \u03c1\n        ((s : [8]Byte) # ctx_1) = ctx_0\n        h = BytesToBits s\n\n            sample : [inf]Byte -> Byte -> (Byte, [inf]Byte)\n    sample ([j] # ctx) i =\n        if j > i then\n            sample ctx i\n        else (j, ctx)\n\n            cAndCtx = [(c0, ctx_1)] # [(c'', ctx') where\n            \/\/ Steps 7 - 10.\n            (j, ctx') = sample ctx (fromInteger i)\n                        c' = update c i (c@j)\n            \/\/ Step 12. In Cryptol, we need to manually convert the exponent\n            \/\/ from a `Bit` to a numeric type.\n            hi\u03c4 = if (h @ (i + `\u03c4 - 256)) then 1 else 0 : Integer\n            c'' = update c' j ((-1)^^hi\u03c4)\n\n        | i <- [256 - \u03c4..255]\n        | (c, ctx) <- cAndCtx]\n\n    (cFinal, _) = cAndCtx ! 0\n\nRejNTTPoly : [34]Byte -> Tq\nRejNTTPoly \u03c1 = a_hat where\n        ctx0 = G \u03c1\n\n        a_hat = take`{256} (sample ctx0)\n\n    sample : [inf][8] -> [inf](Z q)\n    sample GSqueeze = a_hat' where\n        \/\/ Step 5. This pops the first 3 bytes off the pseudorandom stream.\n        (s, ctx) = splitAt`{3} GSqueeze\n\n        \/\/ Step 6.\n        a_hat_j = CoeffFromThreeBytes (s@0) (s@1) (s@2)\n\n        \/\/ Step 7 - 9. The recursive call here replaces the `while` loop.\n        a_hat' = case a_hat_j of\n            Some aj -> [aj] # (sample ctx)\n                                                            None -> sample ctx\n\nRejBoundedPoly: [66]Byte -> R\nRejBoundedPoly \u03c1 = a where\n        ctx0 = H \u03c1\n\n        a = take`{256} (sample ctx0)\n\n    sample : [inf][8] -> [inf]Integer\n    sample HSqueeze = a' where\n        \/\/ Step 5. This pops one byte off the pseudorandom stream.\n        ([z] # ctx) = HSqueeze\n\n        \/\/ Step 6 - 8. We use Cryptol-native functions instead of dividing\n        \/\/ and modding `z`. See `TakeAndDropAreDivAndMod` for the equivalence.\n        z0 = CoeffFromHalfByte (drop`{4} z)\n        z1 = CoeffFromHalfByte (take`{4} z)\n\n        \/\/ Step 8 - 15. The recursive calls replace the `while` loop.\n        \/\/ In order to make the types work, we have to mash the two conditions\n        \/\/ together and make exactly one recursive call.\n        a' = case z0 of\n            Some z0' -> case z1 of\n                Some z1' -> [z0', z1'] # (sample ctx)\n                None -> [z0'] # (sample ctx)\n            None -> case z1 of\n                Some z1' -> [z1'] # (sample ctx)\n                None -> sample ctx\n\n\/**\n * Given a byte, the `take` function is equivalent to dividing by 16, and the\n * `drop` function is equivalent to taking the value mod 16.\n *\n * We prefer the Cryptol functions because they automatically convert from a\n * byte to a 4-bit value, which we need to call `CoeffFromHalfByte`. Here, we\n * use `zext` pad the 4-bit-vector, so we can compare it to the byte.\n * ```repl\n * :prove TakeAndDropAreDivAndMod\n * ```\n *\/\nTakeAndDropAreDivAndMod : [8] -> Bool\nproperty TakeAndDropAreDivAndMod z = dropIsMod && takeIsDiv where\n    dropIsMod = z % 16 == zext (drop`{4} z)\n    \/\/ Division of bit vectors in Cryptol automatically takes the floor.\n    takeIsDiv = z \/ 16 == zext (take`{4} z)\n\n\/**\n * Sample a `k x l` matrix of elements of `T_q`.\n * [FIPS-204] Section 7.3, Algorithm 32.\n *\/\nExpandA : [32]Byte -> [k][ell]Tq\nExpandA \u03c1 = A_hat where\n    A_hat = [[RejNTTPoly \u03c1' where\n            \u03c1' = \u03c1 # IntegerToBytes`{1} s # IntegerToBytes`{1} r\n        | s <- [0..ell - 1]]\n        | r <- [0..k - 1]]\n\n\/**\n * Sample vectors in `R^ell` and `R^k`, each with polynomial coordinates whose\n * coefficients are in the interval `[-\u03b7 , \u03b7]`.\n * [FIPS-204] Section 7.3, Algorithm 33.\n *\/\nExpandS : [64]Byte -> ([ell]R, [k]R)\nExpandS \u03c1 = (s1, s2) where\n    s1 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} r) | r <- [0..ell-1]]\n    s2 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} (r + `ell)) | r <- [0..k-1]]\n\n\/**\n * Sample a vector in `R^ell` such that each polynomial in `y` has coefficients\n * in the range `[-\u03b31 + 1, \u03b31]`.\n * [FIPS-204] Section 7.3, Algorithm 34.\n *\n * Note: This function requires that `\u03bc` is non-negative.\n *\/\nExpandMask : [64]Byte -> Integer -> [ell]R\nExpandMask \u03c1 \u03bc = y where\n    type c = 1 + width (\u03b31 - 1)\n\n    y = [BitUnpack`{\u03b31 - 1, \u03b31} v where\n            \u03c1' = \u03c1 # IntegerToBytes`{2} (\u03bc + r)\n            v = H`{32 * c} \u03c1'\n        | r <- [0..ell - 1]]\n\n\/**\n * Decompose a set of integers mod `q` into a pair `(r1, r0)` such that\n * `r === r1 * 2^d + r0 mod q`.\n *\n * This applies the `Power2Round` function (Algorithm 35) coefficientwise to\n * the polynomials in the vectors, per the description at the beginning of\n * [FIPS-204] Section 7.4.\n *\/\nPower2Round : [k]Rq -> ([k]R, [k]R)\nPower2Round r_vec = (r1_vec, r0_vec) where\n    \/\/ [FIPS-204] Section 7.4, Algorithm 35.\n    Power2Round_Single : Z q -> (Integer, Integer)\n    Power2Round_Single r = (r1, r0) where\n        r_plus = r\n        r0 = modPlusMinus`{2^^d} r_plus\n        r1 = ((fromZ r_plus) - r0) \/ (2^^`d)\n\n    \/\/ Apply the function coefficientwise to every polynomial.\n    zipped_r1r0 : [k][256](Integer, Integer)\n    zipped_r1r0 = [map Power2Round_Single r | r <- r_vec]\n\n    \/\/ Unzip the tuples.\n    r1_vec = [[r1_j | (r1_j, _) <- ri] | ri <- zipped_r1r0]\n    r0_vec = [[r0_j | (_, r0_j) <- ri] | ri <- zipped_r1r0]\n\nprivate\n    \/**\n     * Property demonstrating that `Power2Round` does what it says it's\n     * supposed to do in the definition.\n     * [FIPS-204] Section 7.4, comment on Algorithm 35.\n     * ```repl\n     * :check power2RoundSatisfiesDefinition\n     * ```\n     *\/\n    power2RoundSatisfiesDefinition r_vec = validDecomp where\n        (r1_vec, r0_vec)= Power2Round r_vec\n        isValid (r, (r1, r0)) = (r1 * 2^^`d + r0) % `q == (fromZ r)\n        validDecomp = and [ and (map isValid (zip rs (zip r1s r0s)))\n            | r1s <- r1_vec\n            | r0s <- r0_vec\n            | rs <- r_vec]\n\nDecompose : [k]Rq -> ([k]R, [k]R)\nDecompose r_vec = (r1_vec, r0_vec) where\n        Decompose_Single : Z q -> (Integer, Integer)\n    Decompose_Single r = (r1, r0') where\n        r_plus = r\n        r0 = modPlusMinus`{2 * \u03b32} r_plus\n        (r1, r0') = if (fromZ r_plus) - r0 == `q - 1 then\n                (0, r0 - 1)\n            else\n                (((fromZ r_plus) - r0) \/ (2 * `\u03b32), r0)\n\n        zipped_r1r0 : [k][256](Integer, Integer)\n    zipped_r1r0 = [map Decompose_Single r | r <- r_vec]\n\n        r1_vec = [[r1_j | (r1_j, _) <- ri] | ri <- zipped_r1r0]\n    r0_vec = [[r0_j | (_, r0_j) <- ri] | ri <- zipped_r1r0]\n\nprivate\n\n    decomposeSatisfiesDefinition r_vec = validDecomp where\n        (r1_vec, r0_vec)= Decompose r_vec\n        isValid (r, (r1, r0)) = (r1 * 2 * `\u03b32 + r0) % `q == (fromZ r)\n        validDecomp = and [ and (map isValid (zip rs (zip r1s r0s)))\n            | r1s <- r1_vec\n            | r0s <- r0_vec\n            | rs <- r_vec]\n\nHighBits : [k]Rq -> [k]R\nHighBits r = r1 where\n    (r1, _) = Decompose r\n\nLowBits : [k]Rq -> [k]R\nLowBits r = r0 where\n    (_, r0) = Decompose r\n\nMakeHint : [k]Rq -> [k]Rq -> [k]R2\nMakeHint z_vec r_vec = hint where\n    r1_vec = HighBits r_vec\n    v1_vec = HighBits (r_vec + z_vec)\n\n    hint = [[r1 != v1\n        | r1 <- r1s | v1 <- v1s]\n        | r1s <- r1_vec | v1s <- v1_vec]\n\nUseHint : [k]R2 -> [k]Rq -> [k]R\nUseHint h_vec r_vec = r1'_vec where\n    \/\/ Step 1.\n    m = (`q - 1) \/ (2 * `\u03b32)\n    \/\/ Step 2.\n    (r1_vec, r0_vec) = Decompose r_vec\n\n    \/\/ Steps 3 - 5. This takes the decomposed integers instead of the original\n    \/\/ element in `Z q`.\n    adjustHighBits r1 r0 h =\n        if (h == 1) && (r0 > 0) then (r1 + 1) % m\n        | (h == 1) && (r0 <= 0) then (r1 - 1) % m\n        else r1\n\n    \/\/ Apply the function coefficientwise to the decomposed polynomials.\n    r1'_vec = [[adjustHighBits r1 r0 h\n            | r1 <- r1s | r0 <- r0s | h <- hs]\n        | r1s <- r1_vec | r0s <- r0_vec | hs <- h_vec]\n\nprivate\n\n    property useHintIsInRange h_vec r_vec = r1InRange where\n        r1_vec = UseHint h_vec r_vec\n        inRange r1 = (0 <= r1) && (r1 <= (`q - 1) \/ (2 * `\u03b32))\n                r1InRange = and [and (map inRange r1s) | r1s <- r1_vec]\n\nNTT : Rq -> Tq\nNTT f = [f_hat_j j | j <- bitrev_indexes] where\n    f_hat_j j = sum [ (\u03b6 ^^ (2 * i * j + i)) * fi | i <- [0..255] | fi <- f]\n\n            bitrev_indexes = map toInteger (map reverse [0..255 : [8]])\n\nNTTInv : Tq -> Rq\nNTTInv f_hat = [f_i j * inv_root | j <- [0..255]] where\n    inv_root = recip 256 : Z q\n    inv_\u03b6 = recip \u03b6\n    f_i j = sum [ (inv_\u03b6 ^^ (2 * i * j + j)) * f_hat_j\n        | i <- [0..255]\n        | f_hat_j <- indexReversedFHat]\n\n        bitrev_indexes = map reverse [0..255 : [8]]\n    indexReversedFHat = [f_hat@i | i <- bitrev_indexes]\n\nprivate\n\n    NTT_Inverts : Rq -> Bit\n    property NTT_Inverts f =  NTTInv (NTT f) == f\n\n    NTTInv_Inverts : Tq -> Bit\n    property NTTInv_Inverts f =  NTT (NTTInv f) == f\n\nAddNTT : Tq -> Tq -> Tq\nAddNTT a b = c where\n    c = [a@i + b@i | i <- [0..255]]\n\nproperty addNTTisPlus a b = AddNTT a b == a + b\n\nMultiplyNTT : Tq -> Tq -> Tq\nMultiplyNTT a b = c where\n    c = [a@i * b@i | i <- [0..255]]\n\nproperty multiplyNTTisStar a b = MultiplyNTT a b == a * b\n\nAddVectorNTT : {l} (fin l, l > 0) => [l]Tq -> [l]Tq -> [l]Tq\nAddVectorNTT v w = u where\n    u = [AddNTT (v@i) (w@i) | i <- [0..l-1]]\n\naddVectorNTTisPlus : {r} (fin r, r > 0) => [r]Tq -> [r]Tq -> Bit\nproperty addVectorNTTisPlus v w = AddVectorNTT v w == v + w\n\nScalarVectorNTT : {l} (fin l, l > 0) => Tq -> [l]Tq -> [l]Tq\nScalarVectorNTT c v = w where\n    w = [MultiplyNTT c (v@i) | i <- [0..l-1]]\n\n(\u2218) : {l} (fin l, l > 0) => Tq -> [l]Tq -> [l]Tq\n(\u2218) c v = [c * vi | vi <- v]\n\nringIsScalarVectorNTT : {l} (fin l, l > 0) => Tq -> [l]Tq -> Bit\nproperty ringIsScalarVectorNTT c v = c \u2218 v == ScalarVectorNTT c v\n\nMatrixVectorNTT : [k][ell]Tq -> [ell]Tq -> [k]Tq\nMatrixVectorNTT M v = w where\n            w = [sum [ MultiplyNTT (M@i@j) (v@j)\n        | j <- [0..ell-1]]\n        | i <- [0..k-1] ]\n\n(\u2218\u2218) : [k][ell]Tq -> [ell]Tq -> [k]Tq\n(\u2218\u2218) M v = [sum [Mij * vj | Mij <- Mi | vj <- v] | Mi <- M]\n\ndoubleRingIsMatrixVectorNTT : [k][ell]Tq -> [ell]Tq -> Bit\nproperty doubleRingIsMatrixVectorNTT M v = (M \u2218\u2218 v) == MatrixVectorNTT M v\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/OptimizedSpecification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification that defines the optimized ML-DSA key generation and encoding\/decoding functions and proves their equivalence (via properties) to the reference Specification versions, including Integer\/Bit\/Byte conversions, (Simple)BitPack\/Unpack, ExpandA\/S\/Mask, SampleInBall, and w1Encode."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification where\n\nimport interface Primitive::Asymmetric::Signature::ML_DSA::Parameters as P\nimport Primitive::Asymmetric::Signature::ML_DSA::Specification { interface P }  as Spec\n\ntype q = P::q\ntype \u03c9 = P::\u03c9\ntype k = P::k\ntype ell = P::ell\ntype \u03b7 = P::\u03b7\ntype \u03bb = P::\u03bb\ntype \u03b31 = P::\u03b31\ntype \u03b32 = P::\u03b32\ntype \u03c4 = P::\u03c4\n\ntype Byte = Spec::Byte\n\ntype Tq = Spec::Tq\ntype R = Spec::R\ntype R2 = Spec::R2\ntype Rq = Spec::Rq\n\nmodPlusMinus : {\u03b1} (fin \u03b1) => Z q -> Integer\nmodPlusMinus = Spec::modPlusMinus`{\u03b1}\n\ninfNormRq = Spec::infNormRq\n\ninfNormR = Spec::infNormR\n\ncastToRq = Spec::castToRq\n\nNTT_Vec = Spec::NTT_Vec\n\nNTTInv_Vec = Spec::NTTInv_Vec\n\nH = Spec::H\n\nHBits = Spec::HBits\n\nG = Spec::G\n\n\u03b6 = Spec::\u03b6\n\ntype d = Spec::d\n\n\u03b2 = Spec::\u03b2\n\ntype PublicKey = Spec::PublicKey\n\ntype PrivateKey = Spec::PrivateKey\n\ntype Signature = Spec::Signature\n\nKeyGen_internal : [32]Byte -> (PublicKey, PrivateKey)\nKeyGen_internal \u03be = (pk, sk) where\n        (\u03c1 # \u03c1' # K) = H (\u03be # IntegerToBytes`{1} `k # IntegerToBytes`{1} `ell)\n\n    \/\/ Step 3.\n    A_hat = ExpandA \u03c1\n    \/\/ Step 4.\n    (s1, s2) = ExpandS \u03c1'\n\n        s1' = castToRq s1\n    s2' = castToRq s2\n\n        t = NTTInv_Vec (A_hat \u2218\u2218 NTT_Vec s1') + s2'\n        (t1, t0) = Power2Round t\n\n        pk = pkEncode \u03c1 t1\n        tr = H pk\n        sk = skEncode \u03c1 K tr s1 s2 t0\n\nKeyGen_internalEquivalence : [32]Byte -> Bit\nproperty KeyGen_internalEquivalence \u03be = Spec::KeyGen_internal \u03be == KeyGen_internal \u03be\n\nSign_internal = Spec::Sign_internal\n\nVerify_internal = Spec::Verify_internal\n\nIntegerToBits : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]\nIntegerToBits x = reverse (fromInteger x)\n\nIntegerToBitsEquivalence : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> Bit\nproperty IntegerToBitsEquivalence x = Spec::IntegerToBits`{\u03b1} x == IntegerToBits`{\u03b1} x\n\nBitsToInteger y = toInteger (reverse y)\n\nBitsToIntegerEquivalence : {\u03b1} (fin \u03b1, \u03b1 > 0) => [\u03b1] -> Bit\nproperty BitsToIntegerEquivalence x = Spec::BitsToInteger x == BitsToInteger x\n\nIntegerToBytes : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> [\u03b1]Byte\nIntegerToBytes x = reverse (split (fromInteger x))\n\nIntegerToBytesEquivalence : {\u03b1} (fin \u03b1, \u03b1 > 0) => Integer -> Bit\nproperty IntegerToBytesEquivalence x = Spec::IntegerToBytes`{\u03b1} x == IntegerToBytes`{\u03b1} x\n\nBitsToBytes : {\u03b1} (fin \u03b1) => [\u03b1]Bit -> [\u03b1 \/^ 8]Byte\nBitsToBytes y = map reverse (split (y # zero))\n\nBitsToBytesEquivalence : {\u03b1} (fin \u03b1) => [\u03b1]Bit -> Bit\nproperty BitsToBytesEquivalence x = Spec::BitsToBytes x == BitsToBytes x\n\nBytesToBits : {\u03b1} (fin \u03b1) => [\u03b1]Byte -> [8 * \u03b1]Bit\nBytesToBits z = join (map reverse z)\n\nBytesToBitsEquivalence : {\u03b1} (fin \u03b1) => [\u03b1]Byte -> Bit\nproperty BytesToBitsEquivalence x = Spec::BytesToBits x == BytesToBits x\n\nB2B2BInverts = Spec::B2B2BInverts\n\nCoeffFromThreeBytes = Spec::CoeffFromThreeBytes\n\nCoeffFromHalfByte = Spec::CoeffFromHalfByte\n\nSimpleBitPack : {b} (fin b, width b > 0) => R -> [32 * width b]Byte\nSimpleBitPack w = BitsToBytes (join (map IntegerToBits`{width b} w))\n\nSimpleBitPackEquivalence : {b} (fin b, width b > 0) => R -> Bit\nproperty SimpleBitPackEquivalence w = Spec::SimpleBitPack`{b} w == SimpleBitPack`{b} w\n\nBitPack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    R -> [32 * width (a + b)]Byte\nBitPack w = BitsToBytes (join (map (\\x -> IntegerToBits`{width (a + b)} (`b - x)) w))\n\nBitPackEquivalence : {a, b} (fin a, fin b, width (a + b) > 0) => R -> Bit\nproperty BitPackEquivalence w = Spec::BitPack`{a, b} w == BitPack`{a, b} w\n\nSimpleBitUnpack : {b} (fin b, width b > 0) => [32 * width b]Byte -> R\nSimpleBitUnpack v = map BitsToInteger (split (BytesToBits v))\n\nSimpleBitUnpackEquivalence : {b} (fin b, width b > 0) => [32 * width b]Byte -> Bit\nproperty SimpleBitUnpackEquivalence v = Spec::SimpleBitUnpack`{b} v == SimpleBitUnpack`{b} v\n\nBitUnpack : {a, b} (fin a, fin b, width (a + b) > 0) =>\n    [32 * width (a + b)]Byte -> R\nBitUnpack v = map (\\x -> `b - BitsToInteger x) (split (BytesToBits v))\n\nBitUnpackEquivalence : {a, b} (fin a, fin b, width (a + b) > 0) => [32 * width (a + b)]Byte -> Bit\nproperty BitUnpackEquivalence v = Spec::BitUnpack`{a, b} v == BitUnpack`{a, b} v\n\nHintBitPack = Spec::HintBitPack\n\nHintBitUnpack = Spec::HintBitUnpack\n\npkEncode : [32]Byte -> [k]R -> PublicKey\npkEncode \u03c1 t1 = pk where\n    pk = \u03c1 # join [SimpleBitPack`{2 ^^ (width (q - 1) - d) - 1} (t1@i) | i <- [0..k-1]]\n\npkEncodeEquivalence : [32]Byte -> [k]R -> Bit\nproperty pkEncodeEquivalence \u03c1 t1 = Spec::pkEncode \u03c1 t1 == pkEncode \u03c1 t1\n\npkDecode : PublicKey -> ([32]Byte, [k]R)\npkDecode pk = (\u03c1, t1) where\n            (\u03c1 # zBytes) = pk\n    z = split zBytes\n        t1 = [SimpleBitUnpack`{2 ^^ (width (q - 1) - d) - 1} (z@i) | i <- [0..k-1]]\n\npkDecodeEquivalence : PublicKey -> Bit\nproperty pkDecodeEquivalence pk = Spec::pkDecode pk == pkDecode pk\n\nskEncode : [32]Byte -> [32]Byte -> [64]Byte -> [ell]R -> [k]R -> [k]R\n    -> PrivateKey\nskEncode \u03c1 K tr s1 s2 t0 = sk9 where\n            sk1 = \u03c1 # K # tr\n        sk3 = sk1 # join [BitPack`{\u03b7, \u03b7} (s1@i) | i <- [0..ell-1]]\n        sk6 = sk3 # join [BitPack`{\u03b7, \u03b7} (s2@i) | i <- [0..k-1]]\n        sk9 = sk6 #\n        join [BitPack`{2^^(d - 1) - 1, 2^^(d - 1)} (t0@i) | i <- [0..k-1]]\n\nskEncodeEquivalence : [32]Byte -> [32]Byte -> [64]Byte -> [ell]R -> [k]R -> [k]R -> Bit\nproperty skEncodeEquivalence \u03c1 K tr s1 s2 t0 = Spec::skEncode \u03c1 K tr s1 s2 t0 == skEncode \u03c1 K tr s1 s2 t0\n\nskDecode : PrivateKey -> ([32]Byte, [32]Byte, [64]Byte, [ell]R, [k]R, [k]R)\nskDecode sk = (\u03c1, K, tr, s1, s2, t0) where\n            (\u03c1 # K # tr # yBytes # zBytes # wBytes) = sk\n    y = split`{ell} yBytes\n    z = split`{k} zBytes\n    w = split`{k} wBytes\n\n        s1 = [BitUnpack`{\u03b7, \u03b7} (y@i) | i <- [0..ell-1]]\n        s2 = [BitUnpack`{\u03b7, \u03b7} (z@i) | i <- [0..k-1]]\n        t0 = [BitUnpack`{2^^(d - 1) - 1, 2^^(d - 1)} (w@i) | i <- [0..k-1]]\n\nskDecodeEquivalence : PrivateKey -> Bit\nproperty skDecodeEquivalence sk = Spec::skDecode sk == skDecode sk\n\nsigEncode : [\u03bb \/ 4]Byte -> [ell]R -> [k]R2 -> Signature\nsigEncode c_til z h = \u03c3 where\n            \u03c31 = c_til\n        \u03c33 = \u03c31 # join [BitPack`{\u03b31 - 1, \u03b31} (z@i) | i <- [0..ell-1]]\n        \u03c3 = \u03c33 # HintBitPack h\n\nsigDecode : Signature -> ([\u03bb \/ 4]Byte, [ell]R, Option ([k]R2))\nsigDecode \u03c3 = (c_til, z, h) where\n            (c_til # xBytes # y) = \u03c3\n    x = split`{ell} xBytes\n\n        z = [BitUnpack`{\u03b31 - 1, \u03b31} (x@i) | i <- [0..ell-1]]\n        h = HintBitUnpack y\n\nw1Encode : [k]R -> [32 * k * width ((q - 1) \/ (2 * \u03b32) - 1)]Byte\nw1Encode w1 = w1_til where\n    w1_til = join\n        [SimpleBitPack`{(q - 1) \/ (2 * \u03b32) - 1} (w1@i) | i <- [0..k-1]]\n\nw1EncodeEquivalence : [k]R -> Bit\nproperty w1EncodeEquivalence w1 = Spec::w1Encode w1 == w1Encode w1\n\nSampleInBall : [\u03bb \/ 4]Byte -> R\nSampleInBall \u03c1 = cFinal where\n        c0 = zero\n        ctx_0 = H \u03c1\n        ((s : [8]Byte) # ctx_1) = ctx_0\n        h = BytesToBits s\n\n            sample : [inf]Byte -> Byte -> (Byte, [inf]Byte)\n    sample ([j] # ctx) i =\n        if j > i then\n            sample ctx i\n        else (j, ctx)\n\n            cAndCtx = [(c0, ctx_1)] # [(c'', ctx') where\n            \/\/ Steps 7 - 10.\n            (j, ctx') = sample ctx (fromInteger i)\n                        c' = update c i (c@j)\n            \/\/ Step 12. In Cryptol, we need to manually convert the exponent\n            \/\/ from a `Bit` to a numeric type.\n            hi\u03c4 = if (h @ (i + `\u03c4 - 256)) then 1 else 0 : Integer\n            c'' = update c' j ((-1)^^hi\u03c4)\n\n        | i <- [256 - \u03c4..255]\n        | (c, ctx) <- cAndCtx]\n\n    (cFinal, _) = cAndCtx ! 0\n\nSampleInBallEquivalence : [\u03bb \/ 4]Byte -> Bit\nproperty SampleInBallEquivalence \u03c1 = Spec::SampleInBall \u03c1 == SampleInBall \u03c1\n\nRejNTTPoly = Spec::RejNTTPoly\n\nRejBoundedPoly = Spec::RejBoundedPoly\n\nExpandA : [32]Byte -> [k][ell]Tq\nExpandA \u03c1 = A_hat where\n    A_hat = [[RejNTTPoly \u03c1' where\n            \u03c1' = \u03c1 # IntegerToBytes`{1} s # IntegerToBytes`{1} r\n        | s <- [0..ell - 1]]\n        | r <- [0..k - 1]]\n\nExpandAEquivalence : [32]Byte -> Bit\nproperty ExpandAEquivalence \u03c1 = Spec::ExpandA \u03c1 == ExpandA \u03c1\n\nExpandS : [64]Byte -> ([ell]R, [k]R)\nExpandS \u03c1 = (s1, s2) where\n    s1 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} r) | r <- [0..ell-1]]\n    s2 = [RejBoundedPoly (\u03c1 # IntegerToBytes`{2} (r + `ell)) | r <- [0..k-1]]\n\nExpandSEquivalence : [64]Byte -> Bit\nproperty ExpandSEquivalence \u03c1 = Spec::ExpandS \u03c1 == ExpandS \u03c1\n\nExpandMask : [64]Byte -> Integer -> [ell]R\nExpandMask \u03c1 \u03bc = y where\n\n    y = [BitUnpack`{\u03b31 - 1, \u03b31} v where\n            \u03c1' = \u03c1 # IntegerToBytes`{2} (\u03bc + r)\n            v = H \u03c1'\n        | r <- [0..ell - 1]]\n\nExpandMaskEquivalence : [64]Byte -> Integer -> Bit\nproperty ExpandMaskEquivalence \u03c1 \u03bc = Spec::ExpandMask \u03c1 \u03bc == ExpandMask \u03c1 \u03bc\n\nPower2Round = Spec::Power2Round\n\nDecompose = Spec::Decompose\n\nHighBits = Spec::HighBits\n\nLowBits = Spec::LowBits\n\nMakeHint = Spec::MakeHint\n\nUseHint = Spec::UseHint\n\nNTT = Spec::NTT\n\nNTTInv = Spec::NTTInv\n\nAddNTT = Spec::AddNTT\n\nMultiplyNTT = Spec::MultiplyNTT\n\nAddVectorNTT = Spec::AddVectorNTT\n\nScalarVectorNTT = Spec::ScalarVectorNTT\n\nMatrixVectorNTT = Spec::MatrixVectorNTT\n\n(\u2218\u2218) : [k][ell]Tq -> [ell]Tq -> [k]Tq\n(\u2218\u2218) M v = [sum [Mij * vj | Mij <- Mi | vj <- v] | Mi <- M]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol interface module Primitive::Asymmetric::Signature::ML_DSA::Parameters that specifies the ML-DSA (Dilithium-like) signature scheme parameter types q, \u03c4, \u03bb, \u03b31, \u03b32, k, ell, \u03b7, and \u03c9, together with all their numeric and finiteness constraints as given."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Asymmetric::Signature::ML_DSA::Parameters where\n\n    type q = 8380417\n\n    type \u03c4 : #\n    type constraint (0 < \u03c4, \u03c4 <= 64)\n\n    type \u03bb : #\n    type constraint (fin \u03bb)\n\n    type \u03b31 : #\n    type constraint (fin \u03b31, 2 ^^ (lg2 \u03b31) == \u03b31)\n    type constraint (1 + width (\u03b31 - 1) == width (\u03b31 - 1 + \u03b31))\n\n    type \u03b32 : #\n    type constraint (\u03b32 > 0, (q - 1) % (2 * \u03b32) == 0)\n    type constraint (width ((q - 1) \/ (2 * \u03b32) - 1) > 0)\n\n    type k : #\n    type ell : #\n    type constraint (fin k, fin ell, k > 0, ell > 0)\n\n    type \u03b7 : #\n    type constraint (\u03b7 % 2 == 0, 2 <= \u03b7, \u03b7 <= 4)\n\n    type \u03c9 : #\n    type constraint (fin \u03c9, \u03c9 > 0, width \u03c9 <= 8)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/UnconstrainedSpec.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing unconstrained ECDSA signing, verification, and public key derivation over an abstract EC and hash interface, along with the property signAndVerifyIsCorrect that checks verifying a produced signature with the derived public key returns True for all valid inputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec where\n\nimport interface Common::EC::ECInterface as EC\n\nimport interface Primitive::Keyless::Hash::HashInterface as Hash\n\nsign : {m} (fin m, width m < Hash::MessageUpperBound) =>\n    [m] -> Z EC::n -> Z EC::n -> Option (Z EC::n, Z EC::n)\nsign M d k = if inputsInRange then maybe_rs else None\n    where\n                inputsInRange = (0 != d) && (0 != k)\n\n                e = hashAndTruncate M\n\n                                k_inv = recip k\n\n                R = EC::scmul (fromZ k) EC::G\n\n                                        maybe_rs = case EC::xCoord R of\n                                    Some xR -> if (r != 0) && (s != 0) then Some (r, s) else None\n                where\n                                                            r1 = fromZ xR\n                                        r = fromInteger r1\n                                                            s = k_inv * (e + r * d)\n\n            None -> None \n\nverify : {m} (fin m, width m < Hash::MessageUpperBound) =>\n    [m] -> (Z EC::n, Z EC::n) -> EC::Point -> Bool\nverify M (r, s) Q = inputsInRange && rMatches\n    where\n                inputsInRange = (0 != r) && (0 != s)\n\n                e = hashAndTruncate M\n\n                                s_inv = recip s\n\n                u = e * s_inv\n        v = r * s_inv\n\n                R_1 = EC::twin_mul (fromZ u) EC::G (fromZ v) Q\n\n                rMatches = case EC::xCoord R_1 of\n                        Some xR -> r1 == r where\n                                                r1 = fromInteger (fromZ xR)\n            None -> False\n\npublicKey : Z EC::n -> EC::Point\npublicKey d = EC::scmul (fromZ d) EC::G\n\nsignAndVerifyIsCorrect : {m} (fin m, width m < Hash::MessageUpperBound) =>\n    [m] -> Z EC::n -> Z EC::n -> Bool\nproperty signAndVerifyIsCorrect M d k = verification\n    where\n        Q = publicKey d\n        signature = sign M d k\n        verification = case signature of\n            Some (r, s) -> verify M (r, s) Q\n            None -> False\n\nprivate\n\n    hashAndTruncate : {m} (fin m, width m < Hash::MessageUpperBound) => [m] -> Z EC::n\n    hashAndTruncate M = e\n        where\n            H = Hash::hash M\n            e' = take`{min (width EC::n) Hash::DigestLength} H\n            \/\/ Cryptol's default bitstring-to-integer `toInteger` conversion\n                                                e = fromInteger (toInteger e')\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that fully specifies the XMSS (eXtended Merkle Signature Scheme) per RFC-8391, including key generation, signing, verification, treeHash, ltree, and a property `XMSSInverts` stating that `verify (sign M SK) M` succeeds for all messages and keys."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::XMSS::Specification where\n\nimport interface Primitive::Asymmetric::Signature::XMSS::Parameters\nimport interface Primitive::Asymmetric::Signature::WOTS::Interface as WOTS\n\ninterface constraint (n == WOTS::n)\n\ntype Address = WOTS::Address\ntype Byte = WOTS::Byte\ntype Seed = WOTS::Seed\n\nprivate\n\n    setType : Address -> Word -> Address\n    setType address value = take`{3 * 4} address # split value # drop`{4 * 4} address\n\ntype Word = [32]\n\ntype LTreeAddress = [8 * 4]Byte\n\nprivate\n\n    setLTreeAddress : LTreeAddress -> Word -> LTreeAddress\n    setLTreeAddress address value = take`{4 * 4} address # (split value) # drop`{5 * 4} address\n\n    setTreeHeight : LTreeAddress -> Word -> LTreeAddress\n    setTreeHeight address value = take`{5 * 4} address # (split value) # drop`{6 * 4} address\n\n    getTreeHeight : LTreeAddress -> Word\n    getTreeHeight address = value where\n        value = join (take`{1 * 4} (drop`{5 * 4} address))\n\n    property test_tree_height_getter_setter ADRS i = i' == i where\n        ADRS' = setTreeHeight ADRS i\n        i' = getTreeHeight ADRS'\n\n    setTreeIndex : LTreeAddress -> Word -> LTreeAddress\n    setTreeIndex address value = take`{6 * 4} address # (split value) # drop`{7 * 4} address\n\n    getTreeIndex : LTreeAddress -> Word\n    getTreeIndex address = join (take`{1 * 4} (drop`{6 * 4} address))\n\n    property test_tree_index_getter_setter ADRS i = i' == i where\n        ADRS' = setTreeIndex ADRS i\n        i' = getTreeIndex ADRS'\n\n    setKeyAndMask : LTreeAddress -> Word -> LTreeAddress\n    setKeyAndMask address value = take`{7 * 4} address # split value\n\ntype HashTreeAddress = [8 * 4]Byte\n\ntype PrivateKey = {\n    oid: [32],\n    wots_sks: [2^^h]WOTS::PrivateKey,\n    idx: Word,\n    SK_PRF: [n]Byte,\n    root: [n]Byte,\n    seed: Seed\n}\n\nprivate\n\n    setIdx : PrivateKey -> Word -> PrivateKey\n    setIdx SK idx = { SK | idx = idx }\n\n    getWOTS_SK : PrivateKey -> Word -> WOTS::PrivateKey\n    getWOTS_SK SK i = SK.wots_sks @ i\n\ntype PublicKey = {\n    oid: [32],\n    root: [n]Byte,\n    seed: Seed\n}\n\ntype Signature = {\n    idx_sig: Word,\n    r: [n]Byte,\n    sig_ots: WOTS::Signature,\n    auth: [h][n]Byte\n}\n\nprivate\n\n    setOTSAddress : WOTS::OTSHashAddress -> Word -> WOTS::OTSHashAddress\n    setOTSAddress address value = take`{4 * 4} address # (split value) # drop`{5 * 4} address\n\n    RAND_HASH : [n]Byte -> [n]Byte -> Seed -> LTreeAddress -> [n]Byte\n    RAND_HASH LEFT RIGHT SEED ADRS = hash where\n        ADRS' = setKeyAndMask ADRS 0\n        KEY = WOTS::PRF SEED ADRS'\n        ADRS'' = setKeyAndMask ADRS' 1\n        BM_0 = WOTS::PRF SEED ADRS''\n        ADRS''' = setKeyAndMask ADRS'' 2\n        BM_1 = WOTS::PRF SEED ADRS'''\n        hash = H KEY ((LEFT ^ BM_0) # (RIGHT ^ BM_1))\n\n    \/**\n     * Helper function for `ltree` for computing `pk`.\n     *\n     * This corresponds to the `for`-loop in Algorithm 8:\n     *\n     *   for ( i = 0; i < floor(len' \/ 2); i++ ) {\n     *     ADRS.setTreeIndex(i);\n     *     pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n     *   }\n     *\n     * [RFC-8391] Section 4.1.5, Algorithm 8.\n     *\/\n    ltree_pk : {len', half_floor} (\n            fin len',\n\n            len' > 1,\n            half_floor == len' \/ 2,             \n            width (half_floor - 1) <= 32\n\n        ) => [len'][n]Byte -> Seed -> LTreeAddress -> [half_floor][n]Byte\n    ltree_pk pk SEED ADRS = pk' where\n        pk' = [ pk_i where\n                ADRS' = setTreeIndex ADRS i\n                pk_i = RAND_HASH (pk @ (2 * i)) (pk @ (2 * i + 1)) SEED ADRS'\n              | i <- [0..half_floor - 1]\n              ]\n\n    \/**\n     * Recursive version of `ltree`.\n     *\n     * This corresponds to the `while`-loop in Algorithm 8:\n     *\n     *   while ( len' > 1 ) {\n     *          *     for ( i = 0; i < floor(len' \/ 2); i++ ) {\n     *       ADRS.setTreeIndex(i);\n     *       pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n     *     }\n     *     if ( len' % 2 == 1 ) {\n     *       pk[floor(len' \/ 2)] = pk[len' - 1];\n     *     }\n     *    len' = ceil(len' \/ 2);\n     *    ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     *  }\n     *\n     * [RFC-8391] Section 4.1.5, Algorithm 8.\n     *\/\n    ltree' : {len', half_floor, half_ceil} (\n            fin len',\n            len' >= 1,\n            half_floor == len' \/ 2, \/\/ Equivalent to `floor(len' \/ 2)`\n            width half_floor <= 32,\n            half_ceil == len' \/^ 2  \/\/ Equivalent to `ceil(len' \/ 2)`\n        ) => [len'][n]Byte -> Seed -> LTreeAddress -> [n]Byte\n    ltree' pk SEED ADRS\n\n        | len' == 1 => pk @ 0\n        \/*\n         * The `while`-loop condition for when `len' % 2 == 0`.\n         *\n         * In this case, we do not need to append `pk[len' - 1]` to the end of\n         * `pk`.\n         *\/\n        | (len' > 1, len' % 2 == 0) => result where\n            pk' = ltree_pk pk SEED ADRS\n            ADRS' = setTreeHeight ADRS ((getTreeHeight ADRS) + 1)\n            result = ltree'`{half_ceil} pk' SEED ADRS'\n\n        | (len' > 1, len' % 2 == 1) => result where\n            pk' = (ltree_pk pk SEED ADRS) # split (pk ! 0)\n            ADRS' = setTreeHeight ADRS ((getTreeHeight ADRS) + 1)\n            result = ltree'`{half_ceil} pk' SEED ADRS'\n\n    \/**\n     * `ltree` - unbalanced binary hash tree.\n     *\n     * To compute the leaves of the binary hash tree, a so-called L-tree is\n     * used.  An L-tree is an unbalanced binary hash tree, distinct but similar\n     * to the main XMSS binary hash tree.  The algorithm `ltree` takes as input\n     * a WOTS+ public key pk and compresses it to a single n-byte value pk[0].\n     * It also takes as input an L-tree address ADRS that encodes the address of\n     * the L-tree and the seed SEED.\n     *\n     * Note: We implement `ltree` using recursion instead of the `while`-loop as\n     * specified in Algorithm 8.\n     *\n     *   Input: WOTS+ public key pk, seed SEED, address ADRS (Note: [Errata-5572])\n     *   Output: n-byte compressed public key value pk[0]\n     *\n     *   unsigned int len' = len;\n     *   ADRS.setTreeHeight(0);\n     *   while ( len' > 1 ) {\n     *     for ( i = 0; i < floor(len' \/ 2); i++ ) {\n     *       ADRS.setTreeIndex(i);\n     *       pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n     *     }\n     *     if ( len' % 2 == 1 ) {\n     *       pk[floor(len' \/ 2)] = pk[len' - 1];\n     *     }\n     *     len' = ceil(len' \/ 2);\n     *     ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     *   }\n     *   return pk[0];\n     *\n     * [RFC-8391] Section 4.1.5, Algorithm 8.\n     * [Errata-5572] @see https:\/\/www.rfc-editor.org\/errata\/eid5572\n     *\/\n    ltree : WOTS::PublicKey -> Seed -> LTreeAddress -> [n]Byte\n    ltree pk SEED ADRS = result where\n        ADRS' = setTreeHeight ADRS 0\n        result = ltree'`{WOTS::len} pk SEED ADRS'\n\n    treeHash_base : {t} (\n                        fin t,\n                                    t <= h\n        ) => PrivateKey -> Word -> Address -> [2^^t]([n]Byte, Address)\n    treeHash_base SK s ADRS = if s % (2^^`t) != 0\n        then error \"Invalid `s`: `s % (1 << t) == 0` must hold\"\n        else base where\n            SEED = SK.seed\n            base = [ (node, ADRS''') where\n                     ADRS' = setOTSAddress (setType ADRS 0) (s + i)\n                     pk = WOTS::genPK (getWOTS_SK SK (s + i)) SEED ADRS'\n                     ADRS'' = setLTreeAddress (setType ADRS' 1) (s + i)\n                     node = ltree pk SEED ADRS''\n                     ADRS''' = setTreeIndex (setTreeHeight (setType ADRS'' 2) 0) (i + s)\n                   | i <- [0..2^^t - 1]\n                   ]\n\n    \/**\n     * The \"induction step\" for `treeHash`.\n     *\n     * This takes a list of `2^^t` elements and combines them to produce a\n     * single element by pairwise hashing elements using `RAND_HASH`.\n     *\n     * This roughly corresponds to the `while`-loop in `treeHash`.\n     *\n     * [RFC-8391] Section 4.1.6, Algorithm 9.\n     *\/\n    treeHash_combine : {t} (\n            fin t\n        ) => [2^^t]([n]Byte, Address) -> Seed -> ([n]Byte, Address)\n    treeHash_combine list SEED\n        | t == 0 => list @ 0\n        | t >= 1 => treeHash_combine list' SEED where\n            list' = [ (node, ADRS') where\n                      ADRS = setTreeIndex a.1 ((getTreeIndex b.1 - 1) \/ 2)\n                      node = RAND_HASH a.0 b.0 SEED ADRS\n                      ADRS' = setTreeHeight ADRS (getTreeHeight ADRS + 1)\n                    | [a, b] <- groupBy`{2} list\n                    ]\n\n    \/**\n     * The `treeHash` algorithm.\n     *\n     * This implementation does not closely mimic the algorithm in [RFC-8391].\n     * That algorithm utilizes a stack which is difficult to implement in\n     * Cryptol. Instead, we implement `treeHash` \"level-by-level\". To explain\n     * this, we first step back and explain the goal of `treeHash`.\n     *\n     * At a high level, `treeHash` takes a leftmost leaf of a sub-tree of height\n     * `t`, and computes the root node of that sub-tree. This can be done in two\n     * ways, which essentially boils down to a breadth-first versus depth-first\n     * approach. The breadth-first way is to first compute all the nodes at the\n     * same level as the leftmost leaf, use those nodes to compute the parent\n     * nodes at the next level, etc., until the root is reached. The depth-first\n     * way is to use a stack to store nodes as they are computed so we can\n     * continually complete sub-trees as we process all the nodes on the same\n     * level as `s`.\n     *\n     * The `treeHash` algorithm in [RFC-8391] does the computation in a\n     * depth-first manner, using a stack to store state. In this implementation,\n     * we use the breadth-first approach.\n     *\n     *   Input: XMSS private key SK, start index s, target node height t,\n     *          address ADRS\n     *   Output: n-byte root node - top node on Stack\n     *\n     *   if( s % (1 << t) != 0 ) return -1;\n     *   for ( i = 0; i < 2^t; i++ ) {\n     *     SEED = getSEED(SK);\n     *     ADRS.setType(0);   \/\/ Type = OTS hash address\n     *     ADRS.setOTSAddress(s + i);\n     *     pk = WOTS_genPK (getWOTS_SK(SK, s + i), SEED, ADRS);\n     *     ADRS.setType(1);   \/\/ Type = L-tree address\n     *     ADRS.setLTreeAddress(s + i);\n     *     node = ltree(pk, SEED, ADRS);\n     *     ADRS.setType(2);   \/\/ Type = hash tree address\n     *     ADRS.setTreeHeight(0);\n     *     ADRS.setTreeIndex(i + s);\n     *     while ( Top node on Stack has same height t' as node ) {\n     *        ADRS.setTreeIndex((ADRS.getTreeIndex() - 1) \/ 2);\n     *        node = RAND_HASH(Stack.pop(), node, SEED, ADRS);\n     *        ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n     *     }\n     *     Stack.push(node);\n     *   }\n     *   return Stack.pop();\n     *\n     * [RFC-8391] Section 4.1.6, Algorithm 9.\n     *\/\n    treeHash : {t} (\n                        fin t,\n                                    t <= h\n        ) => PrivateKey -> Word -> Address -> [n]Byte\n    treeHash SK s ADRS = if s % (2^^`t) != 0\n        then error \"Invalid `s`: `s % (1 << t) == 0` must hold\"\n        else node.0 where\n            list = treeHash_base`{t} SK s ADRS\n            node = treeHash_combine list SK.seed\n\nkeyGen : [2^^h]WOTS::PrivateKey -> [n]Byte -> Seed -> (PrivateKey, PublicKey)\nkeyGen wots_sks SK_PRF SEED = (SK, PK) where\n    SK_no_root = { oid = oid, idx = 0 : Word, wots_sks = wots_sks, SK_PRF = SK_PRF, root = zero : [n]Byte, seed = SEED }\n    ADRS = zero     root = treeHash`{h} SK_no_root 0 ADRS\n    SK = { SK_no_root | root = root }\n    PK = { oid = oid, root = root, seed = SEED }\n\nprivate\n\n    buildAuth_j : {j} (\n            fin j,\n                        j >= 0,\n            j <= h - 1\n        ) => PrivateKey -> Word -> Address -> [n]Byte\n    buildAuth_j SK i ADRS = auth_j where\n        k = i \/ 2^^`j ^ 1         auth_j = treeHash`{j} SK (k * 2^^`j) ADRS\n\n    buildAuth' : {j} (\n            fin j,\n            j < h\n        ) => PrivateKey -> Word -> Address -> [j + 1][n]Byte\n    buildAuth' SK i ADRS\n        | j == 0 => [ buildAuth_j`{0} SK i ADRS ]\n        | j > 0  => list # [ buildAuth_j`{j} SK i ADRS ] where\n            list = buildAuth'`{j - 1} SK i ADRS\n\n    \/**\n     * `buildAuth` - Compute the authentication path for the i^th WOTS+ key\n     * pair.\n     *\n     * Note: We implement `buildAuth` using recursion instead of the `for`-loop.\n     *\n     *   Input: XMSS private key SK, WOTS+ key pair index i, ADRS\n     *   Output: Authentication path auth\n     *\n     *   for ( j = 0; j < h; j++ ) {\n     *     k = floor(i \/ (2^j)) XOR 1;\n     *     auth[j] = treeHash(SK, k * 2^j, j, ADRS);\n     *   }\n     *\n     * [RFC-8391] Section 4.1.9.\n     *\/\n    buildAuth : PrivateKey -> Word -> Address -> [h][n]Byte\n    buildAuth SK i ADRS = buildAuth'`{h - 1} SK i ADRS\n\n    treeSig : [n]Byte -> PrivateKey -> Word -> Address -> (WOTS::Signature, [h][n]Byte)\n    treeSig M' SK idx_sig ADRS = (sig_ots, auth) where\n        auth = buildAuth SK idx_sig ADRS\n        ADRS' = setOTSAddress (setType ADRS 0) idx_sig\n                sig_ots = WOTS::sign M' (getWOTS_SK SK idx_sig) ADRS' SK.seed\n\nsign : {m} (\n        fin m,\n        width (PaddingWidth + 8 * m) < MessageUpperBound\n    ) => [m]Byte -> PrivateKey -> (PrivateKey, Signature)\nsign M SK = (SK', Sig) where\n    idx_sig = SK.idx\n    SK' = setIdx SK (idx_sig + 1)\n    ADRS = zero : Address     r = WOTS::PRF SK.SK_PRF (WOTS::toByte`{32} idx_sig)\n    M' = H_msg (r # SK.root # WOTS::toByte`{n} idx_sig) M\n    (sig_ots, auth) = treeSig M' SK idx_sig ADRS\n    Sig = { idx_sig = idx_sig, r = r, sig_ots = sig_ots, auth = auth }\n\nrootFromSig : Word -> WOTS::Signature -> [h][n]Byte -> [n]Byte -> Seed -> Address -> [n]Byte\nrootFromSig idx_sig sig_ots auth M' SEED ADRS = node_0' where\n    ADRS' = setOTSAddress (setType ADRS 0) idx_sig\n    \/\/ NOTE: The spec calls `WOTS_pkFromSig` with the wrong parameter order. [Errata-8396].\n    pk_ots = WOTS::pkFromSig M' sig_ots ADRS' SEED\n    ADRS'' = setLTreeAddress (setType ADRS' 1) idx_sig\n    node_0_initial = ltree pk_ots SEED ADRS''\n    ADRS''' = setTreeIndex (setType ADRS'' 2) idx_sig\n    (node_0', _) = foldl updateNode (node_0_initial, ADRS''') [0..h-1] where\n        updateNode (node_0, adrs) k = (node_1, adrs'') where\n            adrs' = setTreeHeight adrs k\n            treeindex = getTreeIndex adrs'\n            treeindex' = if (idx_sig \/ 2^^k) % 2 == 0\n                then treeindex \/ 2\n                else (treeindex - 1) \/ 2\n            adrs'' = setTreeIndex adrs' treeindex'\n            node_1 = if (idx_sig \/ 2^^k) % 2 == 0\n                then RAND_HASH node_0 (auth @ k) SEED adrs''\n                else RAND_HASH (auth @ k) node_0 SEED adrs''\n\nverify : {m} (fin m, width (PaddingWidth + 8 * m) < MessageUpperBound)\n    => Signature -> [m]Byte -> PublicKey -> Bit\nverify Sig M PK = node == PK.root where\n    ADRS = zero     M' = H_msg (Sig.r # PK.root # WOTS::toByte`{n} Sig.idx_sig) M\n    node = rootFromSig Sig.idx_sig Sig.sig_ots Sig.auth M' PK.seed ADRS\n\nproperty XMSSInverts M wots_sks SK_PRF SEED = verify sig M pk where\n    (sk, pk) = keyGen wots_sks SK_PRF SEED\n    (sk', sig) = sign M sk\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol interface module Primitive::Asymmetric::Signature::XMSS::Parameters that declares the XMSS parameter types h, n, MessageUpperBound, PaddingWidth, the functions H and H_msg with the given constraints, and the constant oid, matching the specified type signatures and bounds."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Asymmetric::Signature::XMSS::Parameters where\n\ntype h : #\ntype constraint (fin h)\n\ntype constraint (h <= 32)\n\ntype constraint (h >= 1)\n\ntype n : #\ntype constraint (fin n)\n\nH : [n][8] -> [2 * n][8] -> [n][8]\n\ntype MessageUpperBound : #\n\ntype PaddingWidth : #\n\noid : [32]\n\nH_msg : {m} (fin m, width (PaddingWidth + 8 * m) < MessageUpperBound)\n    => [3 * n][8] -> [m][8] -> [n][8]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/WOTS\/Interface.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the Cryptol interface for the WOTS (Winternitz One-Time Signature) scheme, including the given types and the external functions F, PRF, toByte, genPK, sign, and pkFromSig with their exact type signatures and constraints."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Asymmetric::Signature::WOTS::Interface where\n\ntype n : #\ntype constraint (fin n)\n\ntype w : #\ntype constraint (fin w, w % 4 == 0, w % 3 == 1, w <= 16)\n\nF : [n][8] -> [n][8] -> [n][8]\n\nPRF : [n][8] -> [32][8] -> [n][8]\n\ntype len_1 = (8 * n) \/^ (lg2 w)\n\ntype len_2 = lg2 (len_1 * (w - 1)) \/ lg2 w + 1\n\ntype len = len_1 + len_2\n\ntype constraint (width len <= 32)\n\ntype Byte = [8]\n\ntoByte : {y, m} (fin y, fin m) => [m] -> [y]Byte\n\ntype Seed = [n]Byte\n\ntype Address = [8 * 4]Byte\n\ntype OTSHashAddress = [8 * 4]Byte\n\ntype PrivateKey = [len][n]Byte\n\ntype PublicKey = [len][n]Byte\n\ntype Signature = [len][n]Byte\n\ngenPK : PrivateKey -> [n]Byte -> Address -> PublicKey\n\nsign : [n]Byte -> PrivateKey -> Address -> [n]Byte -> Signature\n\npkFromSig : [n]Byte -> Signature -> Address -> [n]Byte -> PublicKey\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/WOTS\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the WOTS+ (Winternitz One-Time Signature Plus) scheme in Cryptol per RFC 8391, including types, functions genPK, sign, pkFromSig, and properties base_wsMatch, base_wExamplesWork, and WOTSisCorrect showing that verification of a generated signature recovers the original public key."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::WOTS::Specification where\n\nparameter\n\n    type n' : #\n    type constraint (fin n')\n\n    type w' : #\n    type constraint (fin w', w' % 4 == 0, w' % 3 == 1, w' <= 16)\n\n    \/**\n     * A keyed cryptographic hash function that takes a key and a message.\n     * [RFC-8391] Section 3.1.1.1.\n     *\/\n    F' : [n'][8] -> [n'][8] -> [n'][8]\n\n    \/**\n     * A pseudorandom function that takes a key and an index.\n     * [RFC-8391] Section 3.1.1.1.\n     *\/\n    PRF' : [n'][8] -> [32][8] -> [n'][8]\n\n    type len_1 = (8 * n') \/^ (lg2 w')\n    type constraint (width (len_1 * (w' - 1) * 2^^8) <= 32)\n\n    \/**\n     * A length value (fixed with respect to `n` and `w`).\n     * [RFC-8391] Section 3.1.1.\n     *\/\n\n    type len_2 = lg2 (len_1 * (w' - 1)) \/ lg2 w' + 1\n\n    \/**\n     * The number of `n`-byte string elements in a WOTS+ private key, public key,\n     * and signature.\n     * [RFC-8391] Section 3.1.1.\n     *\/\n    type len = len_1 + len_2\n\n    \/**\n     * The `len` parameter fits in 32 bits.\n     *\n     * This implicit fact about our inputs is hard for Cryptol to infer, so we\n     * state it explicitly.\n     *\n     * It is implied by the `genPK` function, which sets the chain address\n     * of an OTS hash address to an iterator that varies from 0 to `len-1`.\n     * The chain address is restricted to one 32-bit word. See [RFC-8391]\n     * Algorithm 4.\n     *\n     * This can also be observed from the computed `len` values from the valid\n     * parameter sets in Section 5.2.\n     *\/\n    type constraint (32 >= width len)\n\ntype n = n'\ntype w = w'\nF = F'\nPRF = PRF'\n\n\/**\n * A byte is a sequence of 8 bits using big-endian representation.\n * [RFC-8391] Section 2.1.\n *\/\ntype Byte = [8]\n\n\/**\n * Convert a non-negative integer to a binary representation in big-endian\n * byte order.\n * [RFC-8391] Section 2.4.\n *\n * Note: the spec is not explicit about what to do when `m < 8y` -- e.g. when\n * converting to `y` bytes means truncating the integer representation,\n * rather than padding it with 0s. We chose this behavior based on the\n * reference implementation that accompanies the spec.\n * @see https:\/\/github.com\/XMSS\/xmss-reference\/blob\/master\/utils.c#L6\n * [RFC-8391] Section 7.\n *\n * Essentially, we pad with zeros if needed (using `zext`), then `drop` any\n * unnecessary padding (and potentially also drop some bits of the original\n * integer).\n *\/\ntoByte : {y, m} (fin y, fin m) => [m] -> [y]Byte\ntoByte x = split (drop (zext`{max m (y * 8)} x))\n\n\/**\n * Ensure that `toByte`{32} 0 == zero`.\n * ```repl\n * :check toByteZeroIsZero`{32}\n * ```\n *\/\ntoByteZeroIsZero : {m} fin m => Bit\ntoByteZeroIsZero = zero == toByte`{32, m} 0\n\n\/**\n * An n-byte value used as the key to a PRF.\n *\n * This type is not formally defined in the spec but is defined here for\n * clarity.\n *\n * [RFC-8391] Section 2.5.\n *\/\ntype Seed = [n]Byte\n\n\/**\n * A word is a 32-bit sequence used to define hash addresses.\n * [RFC-8391] Section 2.5.\n *\/\ntype Word = [32]\n\n\/**\n * Address scheme for randomizing hash function calls in the OTS scheme.\n * [RFC-8391] Section 2.5.\n *\n * The address breaks down 7 components, each 1 word long unless specified.\n * 1. Layer address\n * 2-3. Tree address (2 Words)\n * 4. Type (fixed at 0)\n * 5. OTS address\n * 6. Chain address\n * 7. Hash address\n * 8. keyAndMask\n *\n * Note that this isn't defined in terms of the `Word` type because it's\n * operated on by things that require arrays of bytes.\n *\/\ntype OTSHashAddress = [8 * 4]Byte\n\n\/**\n * A private, or secret, key in WOTS+ is a length `len` array of `n`-byte\n * strings.\n *\n * It represents the start nodes in a set of hash chains.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f: A private key MUST be selected randomly from the uniform\n * distribution or selected using a cryptographically secure pseudorandom\n * process! Cryptol cannot verify that a `PrivateKey` was chosen suitably!\n * Implementors must independently audit private key generation!\n *\n * [RFC-8391] Section 3.1.3.\n *\n * An implementation may also use a cryptographically secure pseudorandom\n * method to generate the private key from a single `n`-byte value. See\n * [RFC-8391] Section 3.1.7 for a sample method.\n *\/\ntype PrivateKey = [len][n]Byte\n\n\/**\n * A WOTS+ public key is a length `len` array of `n`-byte strings.\n *\n * It represents the end nodes i a set of length-`w` hash chains, where the\n * start nodes are defined in the corresponding `PrivateKey`.\n *\/\ntype PublicKey = [len][n]Byte\n\n\/**\n * Generate a WOTS+ public key from a private key.\n * [RFC-8391] Section 3.1.4, Algorithm 4 (called `WOTS_genPK` in the spec).\n * [Errata-8382] @see https:\/\/www.rfc-editor.org\/errata\/eid8382\n *\/\ngenPK : PrivateKey -> [n]Byte -> OTSHashAddress -> PublicKey\ngenPK sk SEED ADRS = pk where\n    pk = [ pki where\n            ADRSi = setChainAddress ADRS i\n            pki = chain ski 0 (`w - 1) SEED ADRSi\n        | i <- [0..len-1]\n        | ski <- sk]\n\nprivate\n    \/**\n     * Set the chain address word (in the 6th position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setChainAddress : OTSHashAddress -> Word -> OTSHashAddress\n    setChainAddress address value =\n        take`{5 * 4} address # (split value) # drop`{6 * 4} address\n\n    \/**\n     * Set the hash address word (in the 7th position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setHashAddress : OTSHashAddress -> Word -> OTSHashAddress\n    setHashAddress address value =\n        take`{6 * 4} address # (split value) # drop`{7 * 4} address\n\n    \/**\n     * Set the `keyAndMask` word (the last position) in an `OTSHashAddress`.\n     * This setter is defined implicitly in the spec.\n     * [RFC-8391] Section 2.7.\n     *\/\n    setKeyAndMask : OTSHashAddress -> Word -> OTSHashAddress\n    setKeyAndMask address value = take`{7 * 4} address # split value\n\n    \/**\n     * Chaining function that iterates `F` on the input `X`, `s` times.\n     * [RFC-8391] Section 3.1.2, Algorithm 2.\n     *\/\n    chain : [n]Byte -> Word -> Word -> [n]Byte -> OTSHashAddress -> [n]Byte\n    chain X i s SEED ADRS = return where\n        return = if s == 0 then\n                X\n            else if i + s > `w - 1 then\n                error \"Invalid `s` and `i` parameters passed to `chain`\"\n            else\n                tmp'\n        tmp = chain X i (s - 1) SEED ADRS\n\n        ADRS' = setHashAddress ADRS (i + s - 1)\n        ADRS'' = setKeyAndMask ADRS' 0\n        KEY = PRF SEED ADRS''\n        ADRS''' = setKeyAndMask ADRS'' 1\n        BM = PRF SEED ADRS'''\n\n        tmp' = F KEY (tmp ^ BM)\n\n    \/**\n     * Convert a byte string into a set of base-`w` numbers.\n     *\n     * This uses the manual bit-shifting algorithm described in the spec. The\n     * spec is not very particular about bit widths of the helper variables or\n     * the output; we made the following choices:\n     * - `total`: holds each byte of the input, so `[8]`\n     * - `in`: holds the index showing where we are in the input. We use an\n     *   `Integer`, although this could also be `[width len_X]`.\n     * - `bits`: holds the number of bits processed in the current byte. This is\n     *   never larger than 8, but due to the way we've defined the type\n     *   constraint on `w`, it's easier to leave some extra space, so `[8]`.\n     * - `basew`: The output of this function is eventually used as a parameter\n     *   to `chain`, so we pad each base-`w` number to be a `Word` (`[32]`).\n     *\n     * [RFC-8391] Section 2.6, Algorithm 1.\n     *\/\n    base_w_spec : {out_len, len_X} (\n            fin len_X,\n            out_len <= 8 * len_X \/ lg2 w)\n        => [len_X]Byte -> [out_len]Word\n    base_w_spec X = basew where\n        \/\/ Steps 8 - 13. Define how the helper variables (`total`, `in`, `bits`)\n        \/\/ are updated in each round.\n        update_helpers : ([8], Integer, [8]) -> ([8], Integer, [8])\n        update_helpers (total, in, bits) =\n            if bits == 0 then (\n                X@in,\n                in + 1,\n                8 - lg2 `w )\n            else (total, in, bits - lg2 `w)\n\n        \/\/ Step 7. Define the number of iterations we need.\n        type consumed = out_len\n\n        \/\/ Step 14. Compute the set of base-`w` numbers. `zext` converts an\n        \/\/ 8-bit value to a `Word`.\n        basew = take`{consumed} [ zext ((total >> bits) && (`w - 1))\n            \/\/ Steps 1-5. Initialize helper variables (and update them for each\n            \/\/ round). The first element is dropped because the first variable\n            \/\/ update happens before computing any output values.\n            | (total, in, bits) <- drop`{1} (iterate update_helpers (0, 0, 0))]\n\n    \/**\n     * Convert a byte string into a set of base-`w` numbers.\n     *\n     * This uses standard built-in Cryptol functions to achieve the same\n     * functionality as the spec version; rather than manually bit shifting, it\n     * regroups the bits into the desired arrangement. This is about 5x faster\n     * than the spec version.\n     *\n     * Note that this depends on the top-level type constraint restricting `w`\n     * to either 4 or 16. I am not sure the grouping would work as well if we\n     * were working in a base that was not a power of 2.\n     *\/\n    base_w : {out_len, len_X} (\n        fin len_X,\n        out_len <= 8 * len_X \/ lg2 w)\n        => [len_X]Byte -> [out_len]Word\n    base_w X = map zext (groupBy`{lg2 w} (take (join X)))\n\n    \/**\n     * Proof that the Cryptol-ish version of `base_w` matches the spec version.\n     *\n     * Parameter for the following tests are chosen based on the instantiations\n     * that appear in the spec (Algorithms 5 and 6).\n     * ```repl\n     * :prove base_wsMatch`{len_1, n * 8}\n     * type len_2_bytes = len_2 * lg2 w \/^ 8\n     * :prove base_wsMatch`{len_2, len_2_bytes}\n     * ```\n     *\/\n    base_wsMatch : {O, L} (fin L, O <= 8 * L \/ lg2 w) => [L]Byte -> Bit\n    property base_wsMatch X = base_w_spec`{O, L} X == base_w X\n\n    \/**\n     * The spec provides several examples when `w = 16`.\n     * [RFC-8391] Section 2.6.\n     * ```repl\n     * :prove base_wExamplesWork`{}\n     * ```\n     *\/\n    base_wExamplesWork : (w == 16) => Bit\n    property base_wExamplesWork = test4 && test3 && test2 where\n        test4 = base_w`{4} [0x12, 0x34] == [1, 2, 3, 4]\n        test3 = base_w`{3} [0x12, 0x34] == [1, 2, 3]\n        test2 = base_w`{2} [0x12, 0x34] == [1, 2]\n\n\/**\n * A WOTS+ signature.\n * [RFC-8391] Section 3.1.5.\n *\/\ntype Signature = [len][n]Byte\n\n\/**\n * Generate a signature from a private key and a message.\n * [RFC-8391] Section 3.1.5, Algorithm 5 (called `WOTS_sign` in the spec).\n *\n * The checksum in the signature algorithm must fit in 32 bits; we enforce this\n * using a constraint in the type signature; it will always be true for the\n * approved parameter sets.\n *\/\nsign : [n]Byte -> PrivateKey -> OTSHashAddress -> [n]Byte -> Signature\nsign M sk ADRS SEED = sig where\n    \/\/ Convert message to base `w`.\n    msg = base_w`{len_1} M\n\n    \/\/ Compute checksum.\n    csum = sum [ `w - 1 - msg_i | msg_i <- msg ]\n\n    \/\/ Convert `csum` to base `w`.\n    csum' = csum << (8 - (`(len_2 * lg2 w) % 8))\n    type len_2_bytes = (len_2 * lg2 w) \/^ 8\n    msg' = msg # base_w`{len_2} (toByte`{len_2_bytes} csum')\n    sig = [sig_i where\n            ADRS_i = setChainAddress ADRS i\n            sig_i = chain sk_i 0 msg_i SEED ADRS_i\n        | i <- [0..len-1]\n        | sk_i <- sk\n        | msg_i <- msg' ]\n\n\/**\n * Compute a WOTS+ public key from a message and its signature.\n * [RFC-8391] Section 3.1.6, Algorithm 6 (called `WOTS_pkFromSig` in the spec).\n *\n * The result of this function must be compared to the given public key. If\n * the values are not equal, the signature MUST be rejected. This algorithm\n * does not actually reject any signatures!!\n *\/\npkFromSig : [n]Byte -> Signature -> OTSHashAddress -> [n]Byte -> PublicKey\npkFromSig M sig ADRS SEED = tmp_pk where\n    \/\/ Convert message to base `w`.\n    msg = base_w`{len_1} M\n\n    \/\/ Compute checksum.\n    csum = sum [ `w - 1 - msg_i | msg_i <- msg ]\n\n    \/\/ Convert `csum` to base `w`.\n    csum' = csum << (8 - (`(len_2 * lg2 w) % 8))\n    type len_2_bytes = (len_2 * lg2 w) \/^ 8\n    msg' = msg # base_w`{len_2} (toByte`{len_2_bytes} csum')\n    tmp_pk = [tmp_pk_i where\n            ADRS_i = setChainAddress ADRS i\n            tmp_pk_i = chain sig_i msg_i (`w - 1 - msg_i) SEED ADRS_i\n        | i <- [0..len-1]\n        | sig_i <- sig\n        | msg_i <- msg' ]\n\n\/**\n * A single execution of this property takes ~2 minutes.\n * ```repl\n * :set tests = 1\n * :check WOTSisCorrect\n * ```\n *\/\nproperty WOTSisCorrect M sk ADRS SEED = tmp_pk == pk where\n    pk = genPK sk SEED ADRS\n    sig = sign M sk ADRS SEED\n    tmp_pk = pkFromSig M sig ADRS SEED\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Instantiations\/ML_DSA_87.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_87` that instantiates the generic ML_DSA signature scheme with the given parameter types q=8380417, \u03c4=60, \u03bb=256, \u03b31=2^^19, \u03b32=(q-1)\/32, k=8, ell=7, \u03b7=2, and \u03c9=75."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_87 =\n    Primitive::Asymmetric::Signature::ML_DSA::ML_DSA where\n\n        type q = 8380417\n        type \u03c4 = 60\n        type \u03bb = 256\n        type \u03b31 = 2 ^^ 19\n        type \u03b32 = (q - 1) \/ 32\n        type k = 8\n        type ell = 7\n        type \u03b7 = 2\n        type \u03c9 = 75\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ML_DSA\/Instantiations\/ML_DSA_44.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the Cryptol module `Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_44` that instantiates the ML-DSA signature scheme with the given parameter types q, \u03c4, \u03bb, \u03b31, \u03b32, k, ell, \u03b7, and \u03c9, suitable for ML-DSA-44."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ML_DSA::Instantiations::ML_DSA_44 =\n    Primitive::Asymmetric::Signature::ML_DSA::ML_DSA where\n\n        type q = 8380417\n        type \u03c4 = 39\n        type \u03bb = 128\n        type \u03b31 = 2 ^^ 17\n        type \u03b32 = (q - 1) \/ 88\n        type k = 4\n        type ell = 4\n        type \u03b7 = 2\n        type \u03c9 = 80\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P224_SHA224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the ECDSA_P224_SHA224 test properties `checkSignature`, `sampleVector`, and `testVector`, ensuring that signing with given keys and messages produces the expected `(r,s)` pair and that verification of the produced signature with the derived public key succeeds."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P224_SHA224 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA224 as ECDSA\nimport Common::utils(BVtoZ)\n\nproperty checkSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0xF220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\n    k = BVtoZ 0xC1D1F2F10881088301880506805FEB4825FE09ACB6816C36991AA06D\n    expected_r = BVtoZ 0x1CDFE6662DDE1E4A1EC4CDEDF6A1F5A2FB7FBD9145C12113E6ABFD3E\n    expected_s = BVtoZ 0xA6694FD7718A21053F225D3F46197CA699D45006C06F871808F43EBC\n\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0xF220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\n    k = BVtoZ 0xDF8B38D40DCA3E077D0AC520BF56B6D565134D9B5F2EAE0D34900524\n    expected_r = BVtoZ 0xC441CE8E261DED634E4CF84910E4C5D1D22C5CF3B732BB204DBEF019\n    expected_s = BVtoZ 0x902F42847A63BDC5F6046ADA114953120F99442D76510150F372A3F4\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P384_SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module `Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P384_SHA384` that imports `ECDSA_P384_SHA384` and defines properties `checkSignature`, `sampleVector`, and `testVector` to validate ECDSA P-384 with SHA-384 test vectors for signing and verification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P384_SHA384 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA384 as ECDSA\nimport Common::utils(BVtoZ)\n\nproperty checkSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0x6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\n    k = BVtoZ 0x94ED910D1A099DAD3254E9242AE85ABDE4BA15168EAF0CA87A555FD56D10FBCA2907E3E83BA95368623B8C4686915CF9\n    expected_r = BVtoZ 0x94EDBB92A5ECB8AAD4736E56C691916B3F88140666CE9FA73D64C4EA95AD133C81A648152E44ACF96E36DD1E80FABE46\n    expected_s = BVtoZ 0x99EF4AEB15F178CEA1FE40DB2603138F130E740A19624526203B6351D0A3A94FA329C145786E679E7B82C71A38628AC8\n\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0x6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\n    k = BVtoZ 0x015EE46A5BF88773ED9123A5AB0807962D193719503C527B031B4C2D225092ADA71F4A459BC0DA98ADB95837DB8312EA\n    expected_r = BVtoZ 0x8203B63D3C853E8D77227FB377BCF7B7B772E97892A80F36AB775D509D7A5FEB0542A7F0812998DA8F1DD3CA3CF023DB\n    expected_s = BVtoZ 0xDDD0760448D42D8A43AF45AF836FCE4DE8BE06B485E9B61B827C2F13173923E06A739F040649A667BF3B828246BAA5A5\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P521_SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module that imports an ECDSA_P521_SHA512 instantiation and defines properties `sampleVector` and `testVector` that check deterministic signatures against given (d, msg, k, r, s) test vectors using `sign`, `verify`, and `publicKey` and `checkSignature` helper."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P521_SHA512 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA512 as ECDSA\nimport Common::utils(BVtoZ)\n\ncheckSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0x0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\n    k = BVtoZ 0x1DAE2EA071F8110DC26882D4D5EAE0621A3256FC8847FB9022E2B7D28E6F10198B1574FDD03A9053C08A1854A168AA5A57470EC97DD5CE090124EF52A2F7ECBFFD3\n    expected_r = BVtoZ 0x0C328FAFCBD79DD77850370C46325D987CB525569FB63C5D3BC53950E6D4C5F174E25A1EE9017B5D450606ADD152B534931D7D4E8455CC91F9B15BF05EC36E377FA\n    expected_s = BVtoZ 0x0617CCE7CF5064806C467F678D3B4080D6F1CC50AF26CA209417308281B68AF282623EAA63E5B5C0723D8B8C37FF0777B1A20F8CCB1DCCC43997F1EE0E44DA4A67A\n\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0x0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\n    k = BVtoZ 0x16200813020EC986863BEDFC1B121F605C1215645018AEA1A7B215A564DE9EB1B38A67AA1128B80CE391C4FB71187654AAA3431027BFC7F395766CA988C964DC56D\n    expected_r = BVtoZ 0x13E99020ABF5CEE7525D16B69B229652AB6BDF2AFFCAEF38773B4B7D08725F10CDB93482FDCC54EDCEE91ECA4166B2A7C6265EF0CE2BD7051B7CEF945BABD47EE6D\n    expected_s = BVtoZ 0x1FBD0013C674AA79CB39849527916CE301C66EA7CE8B80682786AD60F98F7E78A19CA69EFF5C57400E3B3A0AD66CE0978214D13BAF4E9AC60752F7B155E2DE4DCE3\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Tests\/ECDSA_P256_SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P256_SHA256 that defines properties checkSignature, sampleVector, and testVector to validate ECDSA-P256 with SHA-256 signatures against given private key, nonce, message, and expected (r,s) values using sign, verify, and publicKey."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Tests::ECDSA_P256_SHA256 where\nimport Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA256 as ECDSA\nimport Common::utils(BVtoZ)\n\nproperty checkSignature d msg k expected_r expected_s =\n    signIsCorrect && verifyIsCorrect where\n\n    sig = ECDSA::sign msg d k\n    signIsCorrect = case sig of\n        Some (r,s) -> (expected_r == r) && (expected_s == s)\n        None -> False\n\n    Q = ECDSA::publicKey d\n    verifyIsCorrect = case sig of\n        Some (r,s) -> ECDSA::verify msg (r,s) Q\n        None -> False\n\nproperty sampleVector = checkSignature d M k expected_r expected_s where\n    M = join \"sample\"\n    d = BVtoZ 0xC9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\n    k = BVtoZ 0xA6E3C57DD01ABE90086538398355DD4C3B17AA873382B0F24D6129493D8AAD60\n    expected_r = BVtoZ 0xEFD48B2AACB6A8FD1140DD9CD45E81D69D2C877B56AAF991C34D0EA84EAF3716\n    expected_s = BVtoZ 0xF7CB1C942D657C41D436C7A1B6E29F65F3E900DBB9AFF4064DC4AB2F843ACDA8\n\nproperty testVector = checkSignature d M k expected_r expected_s where\n    M = join \"test\"\n    d = BVtoZ 0xC9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\n    k = BVtoZ 0xD16B6AE827F17175E040871A1C7EC3500192C4C92677336EC2537ACAEE0008E0\n    expected_r = BVtoZ 0xF1ABB023518351CD71D881567B1EA663ED3EFCF6C5132B354F28D3B0B7D38367\n    expected_s = BVtoZ 0x019F4113742A2B14BD25926B49C649155F267E60D3814B4C0CC84250E46F0083\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P521_SHA3_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512` that instantiates the unconstrained ECDSA specification over curve P-521 with the SHA3-512 hash function, exposing the resulting ECDSA signing and verification interfaces."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA3_512 =\n    Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec {\n        EC = Common::EC::PrimeField::Instantiations::P521,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P384_SHA3_384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA3_384` instantiating the generic ECDSA specification with curve P384 and hash SHA3-384, exposing the resulting ECDSA signing and verification interface."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA3_384 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P384,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_384\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P224_SHA224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA224` instantiating the generic ECDSA specification with the P-224 elliptic curve over a prime field and the SHA-224 hash function, exposing the resulting ECDSA signing and verification interfaces."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA224 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P224,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA224\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P224_SHA3_224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA3_224` that instantiates the generic ECDSA specification with the NIST P-224 prime-field curve and the SHA3-224 hash function, exposing the resulting ECDSA signing and verification interfaces."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P224_SHA3_224 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P224,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_224\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P384_SHA384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA384` that instantiates the generic ECDSA specification with the P-384 elliptic curve and SHA-384 hash function, exposing the appropriate ECDSA signing and verification interfaces."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P384_SHA384 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P384,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA384\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P521_SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA512` that instantiates the unconstrained ECDSA specification using the P-521 prime-field curve and SHA-512 hash function, exposing the resulting ECDSA signing and verification interfaces."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P521_SHA512 =\n    Primitive::Asymmetric::Signature::ECDSA::UnconstrainedSpec {\n        EC = Common::EC::PrimeField::Instantiations::P521,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA512\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P256_SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA256` that instantiates the generic ECDSA specification with the P-256 prime-field elliptic curve and SHA-256 hash function, exposing the resulting ECDSA signing and verification interfaces."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA256 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P256,\n        Hash = Primitive::Keyless::Hash::SHA2::Instantiations::SHA256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/Instantiations\/ECDSA_P256_SHA3_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA3_256` that instantiates the generic ECDSA specification with the P-256 elliptic curve over a prime field and the SHA3-256 hash function, exposing the resulting ECDSA signing and verification interfaces."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::Instantiations::ECDSA_P256_SHA3_256 =\n    Primitive::Asymmetric::Signature::ECDSA::Specification {\n        EC = Common::EC::PrimeField::Instantiations::P256,\n        Hash = Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/ParameterSets\/XMSS_SHA2_10_256_Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module XMSS_SHA2_10_256_Parameters that defines the XMSS parameter set with n = 32, h = 10, SHA256-based hash functions H and H_msg, MessageUpperBound and PaddingWidth types, and constant oid = 0x00000001."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_Parameters\nwhere\n    import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\n    type n = 32\n    type h = 10\n\n    H KEY M = split (SHA256::hash ((1 : [32 * 8]) # join (KEY # M)))\n\n        type MessageUpperBound = SHA256::MessageUpperBound\n\n            type PaddingWidth = (32 * 8) + (3 * n * 8)\n\n        oid = 0x00000001\n\n    H_msg KEY M = split (SHA256::hash ((2 : [32 * 8]) # join (KEY # M)))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/ParameterSets\/XMSS_SHA2_10_256_FFI_Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `XMSS_SHA2_10_256_FFI_Parameters` that specifies the XMSS SHA2-10-256 parameter set using SHA256_FFI, including constants `n`, `h`, `MessageUpperBound`, `PaddingWidth`, `oid`, and functions `H` and `H_msg` with the indicated constructions and types."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_FFI_Parameters\nwhere\n        import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256_FFI as SHA256\n\n    type n = 32\n    type h = 10\n\n    H KEY M = SHA256::hashBytes (split (1 : [32 * 8]) # KEY # M)\n\n        type MessageUpperBound = SHA256::MessageUpperBound\n\n            type PaddingWidth = (32 * 8) + (3 * n * 8)\n\n        oid = 0x00000001\n\n    H_msg KEY M = SHA256::hashBytes (split (2 : [32 * 8]) # KEY # M)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Instantiations\/XMSS_SHA2_10_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the module `Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256` as an instantiation of the generic XMSS specification using the `XMSS_SHA2_10_256_Parameters` and the `WOTSP_SHA2_256` WOTS instantiation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256 =\n    Primitive::Asymmetric::Signature::XMSS::Specification {\n        Parameters = Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_Parameters,\n        WOTS = Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256\n\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/XMSS\/Instantiations\/XMSS_SHA2_10_256_FFI.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256_FFI` that instantiates the generic XMSS specification with the `XMSS_SHA2_10_256_FFI_Parameters` parameter set and the `WOTSP_SHA2_256_FFI` WOTS instantiation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256_FFI =\n    Primitive::Asymmetric::Signature::XMSS::Specification {\n        Parameters = Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_FFI_Parameters,\n        WOTS = Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256_FFI\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/WOTS\/Instantiations\/WOTSP_SHA2_256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the Cryptol module `Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256` instantiating the generic WOTS specification with SHA-256, including type parameters `n' = 32`, `w' = 16`, and the functions `F'` and `PRF'` as given."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256 =\n    Primitive::Asymmetric::Signature::WOTS::Specification where\n        import Primitive::Keyless::Hash::SHA2::Instantiations::SHA256 as SHA256\n\n        type n' = 32\n        type w' = 16\n\n        F' KEY M = SHA256::hashBytes ((zero : [32][8]) # KEY # M)\n        PRF' KEY M = SHA256::hashBytes ((zero : [31][8]) # [(3 : [8])] # KEY # M)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/SphincsPlus\/3.1\/sphincsplus128f.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the Cryptol module `sphincsplus128f` specifying the SPHINCS+ 128f parameter set, including types `n`, `h`, `d`, `a`, `k`, `loglogw`, `m`, `t`, `logt`, and the hash-based functions `H_msg`, `PRF`, `PRF_msg`, and `T` instantiated with SHAKE256."},{"role":"assistant","content":"```cryptol\nmodule sphincsplus128f=specification where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256\n\ntype n = 16\ntype h = 66\ntype d = 22\ntype a = 6\ntype k = 33\ntype loglogw = 2\ntype m = (k*logt+7)\/8 + (h-h\/d+7)\/8 + (h\/d+7)\/8\ntype t = 2^^a\ntype logt = a\n\nH_msg(R, PKseed, PKroot, M) =\n    groupBy(take(shake256(join R # join PKseed # join PKroot # join M)))\nPRF(Seed, ADRS) =\n    groupBy(take(shake256(join Seed # join ADRS)))\nPRF_msg(SKprf, OptRand, M) =\n    groupBy(take(shake256(join SKprf # join OptRand # join M)))\nT(PKseed, ADRS, M) =\n    groupBy(take(shake256(join PKseed # join ADRS # join M)))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/FALCON\/1.2\/falcon_parameterized.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing the parameterized FALCON 1.2 signature scheme, including FFT\/NTT-based polynomial operations, Falcon tree construction (ffLDL, sampling), key generation, signing, compression\/decompression, hashing to point, and a Verify function that checks signatures against a norm bound beta."},{"role":"assistant","content":"```cryptol\nmodule falcon_parameterized where\n\nparameter\n    type _k : #\n    type _n : #\n    type constraint (fin _k, _n == 2^^_k, _k > 0)\n    type pkbytelen : #\n    type sbytelen : #\n    type constraint (fin sbytelen)\n    type coeffs_number_of_bits : #\n    sigma : Float64\n    type Q = Rational\n    type C = (Float64,Float64)\n    Omega_phi: [_n]C\n    type constraint (8 * sbytelen >= 328)\n\ntype slen = 8 * sbytelen - 328\ntype q = 3 * 2^^12 + 1\n\ntype Byte = [8]Bit\ntype ZZ = Integer\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nCMul : (C, C) -> C\nCMul(x, y) = (x.0*y.0-x.1*y.1, x.0*y.1+x.1*y.0)\n\nCAdd : (C, C) -> C\nCAdd(x, y) = (x.0 + x.1, y.0 + y.1)\n\nCAddList : {n} (fin n) => [n]C -> C\nCAddList(l) = sums ! 0\n    where sums = [zero] # [CAdd(el,sums') | el <- l\n                                          | sums' <- sums\n                          ]\n\nCinv : C -> C\nCinv((a,b)) = (a\/.denominator, -(b\/.denominator)) where\n    denominator = a^^2 + b^^2\n\nConjugate : C -> C\nConjugate((x, y)) = (x, -y)\n\nPolyConj : {k, n} (ispoweroftwo k n) => Poly n C -> Poly n C\nPolyConj(f) = map Conjugate f\n\nNormalize_FFT : {k, n} (ispoweroftwo k n) => (Float64, Poly n C) -> Poly n C\nNormalize_FFT(_q, F) = dot(F, [Cinv(_q,0) | i <- [0 .. (n-1)]])\n\ntype constraint ispoweroftwo a b = (fin a, b == 2^^a)\n\ntype constraint positive_power a = (fin a, a > 0, (2*(2^^(a-1)*a)+2^^a == 2^^a*(1+a)), 2 ^^ a == 2 * 2 ^^ (a - 1))\n\nresize : {m,n,a} (fin m, fin n, Zero a) => [m]a -> [n]a\nresize xs = take`{n} (xs # repeat`{inf} zero)\n\nFFT : {k, n} (ispoweroftwo k n) => Poly n C -> FFT n\nFFT(x) | k == 0 => x\n       | k >  0 => resize(join([result0,result1])) where\n            even = [x@(2*i  ) | i <- [0 .. (2^^(k-1)-1)]]\n            odd =  [x@(2*i+1) | i <- [0 .. (2^^(k-1)-1)]]\n            left = FFT`{k-1}(even)\n            right = FFT`{k-1}(odd)\n            X = join([left,right])\n            result0 = [X@i + CMul(Omega_phi@(`n*i),(X@(i+`n\/2))) | i <- [0 .. (n\/2-1)]]\n            result1 = [X@i - CMul(Omega_phi@(`n*i),(X@(i+`n\/2))) | i <- [0 .. (n\/2-1)]]\n\nFFTInv  : {k, n} (ispoweroftwo k n) => (FFT n) -> (Poly n C)\nFFTInv(x) = zero\n\nFFT' : {k, n} (ispoweroftwo k n) => Poly n ZZ -> FFT n\nFFT'(x) = FFT`{k}(map IntToCmplx x : (Poly n C))\n\nFFT'' : {k, n} (ispoweroftwo k n) => Poly n (Z q) -> FFT n\nFFT''(x) = FFT'`{k}(map fromZ x)\n\n\/\/ Number Theoretic Transform\nNTT : {k, n} (ispoweroftwo k n) => Poly n (Z q) -> Poly n (Z q)\nNTT(f) = zero\n\nNTTInv : {k, n} (ispoweroftwo k n) => Poly n (Z q) -> Poly n (Z q)\nNTTInv(f) = zero\n\nModInv : Z q -> Z q\nModInv(f) =  1\/. f\n\nphi : {k, n} (ispoweroftwo k n) => Poly (n+1) (Z q)\nphi = [1]#zero#[1]\n\nIntToCmplx : ZZ -> C\nIntToCmplx(x) = ((fromInteger x),zero)\n\ndot : {n} (fin n) => (FFT n, FFT n) -> FFT n\ndot(f,g) = [CMul(fi,gi) | fi <- f | gi <- g]\n\nHadamardDivision : {n} (fin n) => (FFT n, FFT n) -> FFT n\nHadamardDivision(f,g) = dot(f, (map Cinv g))\n\nPolyMul : {k, n} (ispoweroftwo k n) => ((Poly n C), (Poly n C)) -> (Poly n C)\nPolyMul(f,g) = FFTInv`{k}(dot(FFT`{k}(f), FFT`{k}(g)))\n\nPolyInv : {k, n} (ispoweroftwo k n) => (Poly n C) -> (Poly n C)\nPolyInv(f) = FFTInv`{k}(map Cinv (FFT`{k}(f)))\n\nPolyMulInZ : {k, n} (ispoweroftwo k n) => ((Poly n ZZ), (Poly n ZZ)) -> (Poly n ZZ)\nPolyMulInZ(f, g) = zero \/\/ TODO!\n\nPolyDivInZ : {k, n} (ispoweroftwo k n) => ((Poly n ZZ), (Poly n ZZ)) -> (Poly n Q)\nPolyDivInZ(f, g) = zero \/\/ TODO!\n\ninnerProduct : {k, n} (ispoweroftwo k n) => ((Poly n C), (Poly n C)) -> C\ninnerProduct(f, g) = zero \/\/ TODO!\n\nnorm_sq : {k, n} (ispoweroftwo k n) => (Poly n C) -> Float64\nnorm_sq(f) = zero \/\/ TODO!\n\nsplitfft : {k, n} (ispoweroftwo k n, n > 2) => (FFT n) -> [2](FFT (n\/2))\nsplitfft FFTf = [resize(FFTf0), resize(FFTf1)] where\n    FFTf0 = [FFTf@(2*i  ) | i <- [0 .. (2^^(k-1)-1)]]\n    FFTf1 = [FFTf@(2*i+1) | i <- [0 .. (2^^(k-1)-1)]]\n\nmergefft : {k, n} (ispoweroftwo k n, n>=2) => [2](FFT (n\/2)) -> (FFT n)\nmergefft ([f0, f1]) = resize FFTf where\n    FFTf = join[[f0@i,f1@i] | i <- [0 .. (2^^(k-1)-1)]]\n\ntype Poly degree a = [degree]a\n\ntype FFT degree = Poly degree C\ntype NTT degree = Poly degree (Z q)\n\n\/\/ public key types\ntype publicKey = Poly _n (Z q)\ntype encodedPublicKey = [14 * _n \/^ 8 + 1]Byte\n\n\/\/ private key types\ntype privateKey = ([2][2](FFT _n), falconTree _k)\ntype encodedPrivateKey = [2*((_n+1)*coeffs_number_of_bits) + ((_n+1)*8)]Bit\n\ntype falconTree k = [2^^k*(1+k)]C\n\ngetValue : {k, n} (ispoweroftwo k n) => falconTree k -> Poly n C\ngetValue T = take`{n} T\n\n\/\/ getChildren: {k, n} (ispoweroftwo k n, positive_power k) => falconTree k -> (falconTree (k-1), falconTree (k-1))\n\/\/ getChildren T = children where\n\/\/     children = split`{2,2^^(k-1)*k} (drop`{n} T)\n\nget_leftchild : {k, n} (ispoweroftwo k n, k > 0) => falconTree k -> falconTree (k-1)\nget_leftchild T = left where\n    children = resize (drop`{n} T): [2*2^^(k-1)*k]C\n    [left, right] = split`{2,2^^(k-1)*k} children\n\nget_rightchild : {k, n} (ispoweroftwo k n, k > 0) => falconTree k -> falconTree (k-1)\nget_rightchild T = right where\n    children = resize (drop`{n} T): [2*2^^(k-1)*k]C\n    [left, right] = split`{2,2^^(k-1)*k} children\n\nnewTree : {k, n} (ispoweroftwo k n, k >= 1) => (Poly n C, falconTree (k-1), falconTree (k-1)) -> falconTree k\nnewTree(value, leftchild, rightchild) = T where\n    T = zero\n\n\/\/ The leaves contain real numbers\n\/\/ For consistency their type is C\nnewLeaf : C -> falconTree 0\nnewLeaf sigma_leaf = [sigma_leaf]\n\nget_leaves : {k, n} (ispoweroftwo k n) => falconTree k -> [2^^k]C\nget_leaves T | k == 0 => T\n             | k >  0 => resize leaves where\n                left_child = get_leftchild`{k} T : falconTree (k-1)\n                right_child = get_rightchild`{k} T : falconTree (k-1)\n                left_leaves  = get_leaves`{k-1} left_child : [2^^(k-1)]C\n                right_leaves  = get_leaves`{k-1} right_child : [2^^(k-1)]C\n                leaves = left_leaves # right_leaves : [2*2^^(k-1)]C\n\nset_leaves : {k, n} (ispoweroftwo k n) => (falconTree k, [2^^k]C) -> falconTree k\nset_leaves(T, leaves) | k == 0 => leaves\n                      | k >  0 => newTree`{k}(value, newleftchild, newrightchild) where\n                        value = getValue`{k} T\n                        leftchild = get_leftchild`{k} T\n                        rightchild = get_rightchild`{k} T\n                        [leftleaves, rightleaves] = split`{2,2^^(k-1)} (resize leaves)\n                        newleftchild = set_leaves`{k-1}(leftchild, leftleaves)\n                        newrightchild = set_leaves`{k-1}(rightchild, rightleaves)\n\nCompress : Poly _n ZZ -> [slen]\nCompress s = zero\n\nDecompress : [slen] -> Poly _n ZZ\nDecompress str = zero\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256\nHashToPoint : {q', k, n, len} (q' <= 2^^16, q' >= 1, ispoweroftwo k n, fin len) => [len] -> Poly n (Z q')\nHashToPoint str = [c i | i <- [0..(n-1)]] where\n    k = 2^^16 \/ `q\n    c i = fromInteger(t i % `q)\n    t i = zero \/\/ TODO!\n\n\/\/ phi and q are fixed so we do not parameterize this algorithm\n\/\/ f and g cannot be sampled in Cryptol so we take them as input\nKeygen : (Poly _n ZZ, Poly _n ZZ) -> (privateKey, publicKey)\nKeygen (f', g') = (sk, pk) where\n    (f, g, F, G) = NTRUGen(f', g'): (Poly _n ZZ, Poly _n ZZ, Poly _n ZZ, Poly _n ZZ)\n    B = [[map IntToCmplx g,map IntToCmplx (-f)],[map IntToCmplx G,map IntToCmplx (-F)]] : [2][2](Poly _n C)\n    Bhat = [[FFT'`{_k}(g),FFT'`{_k}(-f)],[FFT'`{_k}(G),FFT'`{_k}(-F)]] : [2][2](FFT _n)\n    GG = B * Bhat\n    T = ffLDL`{_k}(GG)\n    leaves = get_leaves`{_k} T\n    new_leaves = [(sigma\/.r_leaf,0) | (r_leaf, _) <- leaves]\n    T' = set_leaves`{_k}(T, new_leaves)\n    sk = (Bhat, T')\n    h = NTTInv`{_k}(NTT`{_k}(map fromInteger g)*(map ModInv (NTT`{_k}(map fromInteger f))))\n    pk = h\n\nN : {k, n} (ispoweroftwo k n, k > 0) => (Poly n ZZ) -> (Poly (2^^(k-1)) ZZ)\nN(f) = zero\n\nxSquared : {k, n} (ispoweroftwo k n) => (Poly n ZZ) -> (Poly (2^^(k+1)) ZZ)\nxSquared(F) = resize (join[[c,0] | c <- F])\n\nminusx : {k, n} (ispoweroftwo k n) => (Poly n ZZ) -> (Poly n ZZ)\nminusx(g) = resize (join[ [g@i, -(g@(i+1))] | i <- [0, 2 .. (n-1)]])\n\n\/\/ phi and q are fixed so we do not parameterize this algorithm\n\/\/ f and g cannot be sampled in Cryptol so we take them as input\n\/\/ We assume they pass conditions in lines 7 and 9\nNTRUGen : (Poly _n ZZ, Poly _n ZZ) -> (Poly _n ZZ, Poly _n ZZ, Poly _n ZZ, Poly _n ZZ)\nNTRUGen(f, g) = (f, g, F, G) where\n    (F, G) = NTRUSolve`{_k}(f, g)\n\nNTRUSolve : {k, n} (ispoweroftwo k n) => (Poly n ZZ, Poly n ZZ) -> (Poly n ZZ, Poly n ZZ)\nNTRUSolve(f, g) | k == 0 => ([F], [G]) where\n                                (gcd, u, v) = eGCD(f@0, g@0)\n                                (F, G) = (u*`q, v*`q)\n                | k >  0 => (_F, _G) where\n                                f' = N`{k}(f)\n                                g' = N`{k}(g)\n                                (F', G') = NTRUSolve`{k-1}(f',g')\n                                F = PolyMulInZ`{k}(xSquared`{k-1}(F'), minusx`{k}(g))\n                                G = PolyMulInZ`{k}(xSquared`{k-1}(G'), minusx`{k}(f))\n                                (_F, _G) = Reduce`{k}(f,g,F,G)\n\neGCD : (ZZ, ZZ) -> (ZZ, ZZ, ZZ)\neGCD(a, b) =\n    if a == 0\n    then (b, 0, 1)\n    else (g, t - (b \/ a) * s, s) where\n        (g, s, t) = eGCD((b%a), a)\n\nReduce : {k, n} (ispoweroftwo k n) => (Poly n ZZ, Poly n ZZ, Poly n ZZ, Poly n ZZ) -> (Poly n ZZ, Poly n ZZ)\nReduce(f,g,F,G) = (_F, _G) where\n    numerator = PolyMulInZ`{k}(F, adjoint`{k}(f)) + PolyMulInZ`{k}(G, adjoint`{k}(g))\n    denominator = PolyMulInZ`{k}(f, adjoint`{k}(f)) + PolyMulInZ`{k}(g, adjoint`{k}(g))\n    _k = map roundToEven (PolyDivInZ`{k}(numerator, denominator)): Poly n ZZ\n    F' = F - PolyMulInZ`{k}(_k,f)\n    G' = G - PolyMulInZ`{k}(_k, g)\n    (_F, _G, _) = Reduce'`{k}(_k,f,g,F',G')\n\nadjoint : {k, n} (ispoweroftwo k n) => (Poly n ZZ) -> (Poly n ZZ)\nadjoint(f) = reverse f\n\nReduce' : {k, n} (ispoweroftwo k n) => (Poly n ZZ, Poly n ZZ, Poly n ZZ, Poly n ZZ, Poly n ZZ) -> (Poly n ZZ, Poly n ZZ, Poly n ZZ)\nReduce'(_k,f,g,F,G) =\n    if _k == zero\n    then (F, G, _k)\n    else Reduce'`{k}(_k', f, g, F', G') where\n        numerator = PolyMulInZ`{k}(F, adjoint`{k}(f)) + PolyMulInZ`{k}(G, adjoint`{k}(g))\n        denominator = PolyMulInZ`{k}(f, adjoint`{k}(f)) + PolyMulInZ`{k}(g, adjoint`{k}(g))\n        _k' = map roundToEven (PolyDivInZ`{k}(numerator, denominator)): Poly n ZZ\n        F' = F - PolyMulInZ`{k}(_k',f)\n        G' = G - PolyMulInZ`{k}(_k', g)\n\none : {k, n} (ispoweroftwo k n) => FFT n\none = [(1.0,0.0) | i <- [0 .. (n-1)]]\n\nLDL : {k, n} (ispoweroftwo k n) => [2][2](FFT n) -> (([2][2](FFT n)), ([2][2](FFT n)))\nLDL(G) = (L, D) where\n    D00 = G@0@0\n    L10 = HadamardDivision(G@1@0,G@0@0): FFT n\n    D11 = G@1@1 - dot(L10,dot(PolyConj`{k}(L10),G@0@0))\n    L = [[one`{k}, zero],[L10, one`{k}]]\n    D = [[D00, zero],[zero, D11]]\n\nffLDL : {k, n} (ispoweroftwo k n, n >= 2) => ([2][2](FFT n)) -> (falconTree k)\nffLDL(G) | k == 1 => T where\n            (L, D) = LDL`{k}(G) : ([2][2](FFT n), [2][2](FFT n))\n            left_child = D@0@0 : FFT 2\n            left_leaf = newLeaf(left_child@0) \/\/ Revise this\n            right_child = D@1@1 : FFT 2\n            right_leaf = newLeaf(right_child@0) \/\/ Revise this\n            T = newTree`{k}(L@1@0, left_leaf, right_leaf)\n         | k >  1 => T where\n            (L, D) = LDL`{k}(G) : ([2][2](FFT n), [2][2](FFT n))\n            [d00, d01] = splitfft`{k}(D@0@0)\n            [d10, d11] = splitfft`{k}(D@1@1)\n            G0 = [[resize d00,resize d01],[resize d01, resize d00]] \/\/ Revise this\n            G1 = [[resize d10,resize d11],[resize d11, resize d10]]\n            Tleftchild = ffLDL`{k-1}(G0)\n            Trightchild = ffLDL`{k-1}(G1)\n            T = newTree`{k}(L@1@0, Tleftchild, Trightchild)\n\ntype signature = ([320], [slen])\nSign : {len} (fin len) => ([len], privateKey, Integer, [320]) -> signature\nSign(m, sk, beta, r) = zero where\n    (Bhat, T) = sk\n    c = HashToPoint`{q,_k}(r#m)\n    [[FFTg,FFT_f],[FFTG,FFT_F]] = Bhat \/\/ Bhat stores them in FFT representation (some are negated)\n    t0 = Normalize_FFT`{_k}(`q, dot(FFT''`{_k,_n}(c),FFT_F))\n    t1 = Normalize_FFT`{_k}(`q, dot(FFT''`{_k,_n}(c),FFT_F))\n    tt = [t0, t1] : [2](FFT _n)\n    s_init : [slen]\n    s_init = zero\n    is_bot : [slen] -> Bit\n    is_bot(_s) = (_s == zero)\n    body' : [slen] -> [slen]\n    body'(_s) = zero where\n        ss_init = zero : FFT _n\n        norm_greater_than_beta : FFT _n -> Bit\n        norm_greater_than_beta(_ss) = norm_sq`{_k}(_ss) > (fromInteger beta)\n        body'' : FFT _n -> FFT _n\n        body''(_ss) = zero where\n            zz = ffSampling`{_k}(tt, T) : [2](FFT _n)\n            \/\/ _ss' = [ dot`{_n}((tt_ - zz_),Bhat_) | tt_ <- tt | zz_ <- zz | Bhat_ <- Bhat]\n        _ss_final = dowhile norm_greater_than_beta body'' ss_init\n    s_final = dowhile is_bot body' s_init\n\nffSampling : {k, n} (ispoweroftwo k n) => ([2](FFT n), falconTree k) -> [2](FFT n)\nffSampling(t, T) = z where\n    [t0, t1] = t\n    z = [z0, z1]\n    z0 = zero\n    z1 = zero\n\nRCDT = [\n    3024686241123004913666,\n    1564742784480091954050,\n    636254429462080897535,\n    199560484645026482916,\n    47667343854657281903,\n    8595902006365044063,\n    1163297957344668388,\n    117656387352093658,\n    8867391802663976,\n    496969357462633,\n    20680885154299,\n    638331848991,\n    14602316184,\n    247426747,\n    3104126,\n    28824,\n    198,\n    1,\n    0\n] : [19][72]\n\nBaseSampler : [72] -> ZZ\nBaseSampler(u) = z0 where\n    z0 = zero\n\nimport Float\nApproxExp : (Float64, Float64) -> [64]\nApproxExp(x, ccs) = y'' where\n    C = [\n            0x00000004741183A3,\n            0x00000036548CFC06,\n            0x0000024FDCBF140A,\n            0x0000171D939DE045,\n            0x0000D00CF58F6F84,\n            0x000680681CF796E3,\n            0x002D82D8305B0FEA,\n            0x011111110E066FD0,\n            0x0555555555070F00,\n            0x155555555581FF00,\n            0x400000000002B400,\n            0x7FFFFFFFFFFF4800,\n            0x8000000000000000\n        ]\n    y = C@0\n    z = fromInteger (floor(2^^63 * x))\n    y' = foldl (\\yy -> \\u -> C@u - (z*y)>>63) y [1 .. 12]\n    z' = fromInteger (floor(2^^63 * ccs))\n    y'' = (z'*y')>>63\n\nBerExp : (Float64, Float64) -> Bit\nBerExp(x, ccs) = w < 0 where\n    ln2 = 0.69314718056\n    s = x \/. ln2\n    r = floor(x - s * ln2)\n    s' = min(s, 63)\n        w = zero\n\nSamplerZ : (Float64, Float64) -> ZZ\nSamplerZ(m, sigma') = z where\n    z = zero\n\nVerify : {len} (fin len) => ([len], signature, publicKey, Integer) -> Bit\nVerify(m, sig, pk, beta) = norm^^2 <= beta where\n    norm = zero\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/Signature\/FALCON\/1.2\/falcon_512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `falcon_512` that instantiates the FALCON lattice-based signature scheme (parameter set n=512, k=9) using a submodule `spec2`, defining the associated constants (e.g., q, sigma, pkbytelen, sbytelen) and the precomputed Omega_phi table, and then imports this instantiated submodule."},{"role":"assistant","content":"```cryptol\nmodule falcon_512 where\n\nsubmodule falcon_inst = spec2\n    where\n    type _k = 9\n    type _n = 512\n    type pkbytelen = 897\n    type sbytelen = 666\n    type coeffs_number_of_bits = 6\n    type q = 3 * 2^^12 + 1\n    r = 3\n    sigma = 165.736617183\n    sigma_min = 1.277833697\n    sigma_max = 1.8205\n    beta = 34034726\n\n    Omega_phi = [\n        (1, 0),\n        (0.9999247018391445, 0.012271538285719925),\n        (0.9996988186962042, 0.024541228522912288),\n        (0.9993223845883495, 0.03680722294135883),\n        (0.9987954562051724, 0.049067674327418015),\n        (0.9981181129001492, 0.06132073630220858),\n        (0.9972904566786902, 0.07356456359966743),\n        (0.996312612182778, 0.0857973123444399),\n        (0.9951847266721969, 0.0980171403295606),\n        (0.9939069700023561, 0.11022220729388306),\n        (0.99247953459871, 0.1224106751992162),\n        (0.99090263542778, 0.13458070850712617),\n        (0.989176509964781, 0.14673047445536175),\n        (0.9873014181578584, 0.15885814333386145),\n        (0.9852776423889412, 0.17096188876030122),\n        (0.9831054874312163, 0.18303988795514095),\n        (0.9807852804032304, 0.19509032201612825),\n        (0.9783173707196277, 0.20711137619221856),\n        (0.9757021300385286, 0.2191012401568698),\n        (0.9729399522055602, 0.2310581082806711),\n        (0.970031253194544, 0.24298017990326387),\n        (0.9669764710448521, 0.25486565960451457),\n        (0.9637760657954398, 0.26671275747489837),\n        (0.9604305194155658, 0.27851968938505306),\n        (0.9569403357322088, 0.29028467725446233),\n        (0.9533060403541939, 0.3020059493192281),\n        (0.9495281805930367, 0.3136817403988915),\n        (0.9456073253805213, 0.3253102921622629),\n        (0.9415440651830208, 0.33688985339222005),\n        (0.937339011912575, 0.34841868024943456),\n        (0.932992798834739, 0.3598950365349881),\n        (0.9285060804732156, 0.37131719395183754),\n        (0.9238795325112867, 0.3826834323650898),\n        (0.9191138516900578, 0.3939920400610481),\n        (0.9142097557035307, 0.40524131400498986),\n        (0.9091679830905224, 0.41642956009763715),\n        (0.9039892931234433, 0.4275550934302821),\n        (0.8986744656939538, 0.43861623853852766),\n        (0.8932243011955153, 0.44961132965460654),\n        (0.8876396204028539, 0.46053871095824),\n        (0.881921264348355, 0.47139673682599764),\n        (0.8760700941954066, 0.4821837720791227),\n        (0.8700869911087115, 0.49289819222978404),\n        (0.8639728561215867, 0.5035383837257176),\n        (0.8577286100002721, 0.5141027441932217),\n        (0.8513551931052652, 0.524589682678469),\n        (0.8448535652497071, 0.5349976198870972),\n        (0.838224705554838, 0.5453249884220465),\n        (0.8314696123025452, 0.5555702330196022),\n        (0.8245893027850253, 0.5657318107836131),\n        (0.8175848131515837, 0.5758081914178453),\n        (0.8104571982525948, 0.5857978574564389),\n        (0.8032075314806449, 0.5956993044924334),\n        (0.7958369046088836, 0.6055110414043255),\n        (0.7883464276266063, 0.6152315905806268),\n        (0.7807372285720945, 0.6248594881423863),\n        (0.773010453362737, 0.6343932841636455),\n        (0.765167265622459, 0.6438315428897914),\n        (0.7572088465064846, 0.6531728429537768),\n        (0.7491363945234594, 0.6624157775901718),\n        (0.7409511253549592, 0.6715589548470183),\n        (0.7326542716724128, 0.680600997795453),\n        (0.724247082951467, 0.6895405447370668),\n        (0.7157308252838186, 0.6983762494089729),\n        (0.7071067811865476, 0.7071067811865475),\n        (0.6983762494089729, 0.7157308252838186),\n        (0.6895405447370669, 0.7242470829514669),\n        (0.6806009977954531, 0.7326542716724127),\n        (0.6715589548470184, 0.740951125354959),\n        (0.6624157775901718, 0.7491363945234593),\n        (0.6531728429537769, 0.7572088465064845),\n        (0.6438315428897915, 0.7651672656224588),\n        (0.6343932841636456, 0.7730104533627369),\n        (0.6248594881423865, 0.7807372285720944),\n        (0.6152315905806269, 0.7883464276266062),\n        (0.6055110414043255, 0.7958369046088835),\n        (0.5956993044924335, 0.8032075314806448),\n        (0.5857978574564389, 0.8104571982525948),\n        (0.5758081914178454, 0.8175848131515837),\n        (0.5657318107836132, 0.8245893027850253),\n        (0.5555702330196023, 0.8314696123025451),\n        (0.5453249884220466, 0.838224705554838),\n        (0.5349976198870974, 0.844853565249707),\n        (0.524589682678469, 0.8513551931052652),\n        (0.5141027441932218, 0.8577286100002721),\n        (0.5035383837257176, 0.8639728561215867),\n        (0.49289819222978415, 0.8700869911087113),\n        (0.4821837720791229, 0.8760700941954065),\n        (0.4713967368259978, 0.8819212643483549),\n        (0.46053871095824, 0.8876396204028539),\n        (0.4496113296546066, 0.8932243011955153),\n        (0.4386162385385277, 0.8986744656939538),\n        (0.4275550934302822, 0.9039892931234433),\n        (0.4164295600976373, 0.9091679830905224),\n        (0.4052413140049898, 0.9142097557035307),\n        (0.3939920400610481, 0.9191138516900578),\n        (0.38268343236508984, 0.9238795325112867),\n        (0.3713171939518376, 0.9285060804732155),\n        (0.3598950365349883, 0.9329927988347388),\n        (0.3484186802494345, 0.937339011912575),\n        (0.33688985339222005, 0.9415440651830208),\n        (0.325310292162263, 0.9456073253805213),\n        (0.3136817403988915, 0.9495281805930367),\n        (0.3020059493192282, 0.9533060403541938),\n        (0.2902846772544623, 0.9569403357322089),\n        (0.27851968938505306, 0.9604305194155658),\n        (0.2667127574748984, 0.9637760657954398),\n        (0.2548656596045146, 0.9669764710448521),\n        (0.24298017990326398, 0.970031253194544),\n        (0.23105810828067125, 0.9729399522055601),\n        (0.21910124015686977, 0.9757021300385286),\n        (0.20711137619221856, 0.9783173707196277),\n        (0.1950903220161283, 0.9807852804032304),\n        (0.18303988795514103, 0.9831054874312163),\n        (0.17096188876030136, 0.9852776423889412),\n        (0.1588581433338614, 0.9873014181578584),\n        (0.14673047445536175, 0.989176509964781),\n        (0.13458070850712622, 0.99090263542778),\n        (0.12241067519921628, 0.99247953459871),\n        (0.11022220729388318, 0.9939069700023561),\n        (0.09801714032956077, 0.9951847266721968),\n        (0.08579731234443988, 0.996312612182778),\n        (0.07356456359966745, 0.9972904566786902),\n        (0.061320736302208655, 0.9981181129001492),\n        (0.04906767432741813, 0.9987954562051724),\n        (0.03680722294135899, 0.9993223845883495),\n        (0.024541228522912267, 0.9996988186962042),\n        (0.012271538285719944, 0.9999247018391445),\n        (6.123233995736766e-17, 1.0),\n        (-0.012271538285719823, 0.9999247018391445),\n        (-0.024541228522912142, 0.9996988186962042),\n        (-0.036807222941358866, 0.9993223845883495),\n        (-0.04906767432741801, 0.9987954562051724),\n        (-0.06132073630220853, 0.9981181129001492),\n        (-0.07356456359966734, 0.9972904566786902),\n        (-0.08579731234443977, 0.996312612182778),\n        (-0.09801714032956066, 0.9951847266721969),\n        (-0.11022220729388307, 0.9939069700023561),\n        (-0.12241067519921617, 0.99247953459871),\n        (-0.1345807085071261, 0.99090263542778),\n        (-0.14673047445536164, 0.989176509964781),\n        (-0.15885814333386128, 0.9873014181578584),\n        (-0.17096188876030124, 0.9852776423889412),\n        (-0.18303988795514095, 0.9831054874312163),\n        (-0.1950903220161282, 0.9807852804032304),\n        (-0.20711137619221845, 0.9783173707196277),\n        (-0.21910124015686966, 0.9757021300385286),\n        (-0.23105810828067117, 0.9729399522055602),\n        (-0.24298017990326387, 0.970031253194544),\n        (-0.2548656596045145, 0.9669764710448521),\n        (-0.2667127574748983, 0.9637760657954398),\n        (-0.27851968938505295, 0.9604305194155659),\n        (-0.2902846772544622, 0.9569403357322089),\n        (-0.3020059493192281, 0.9533060403541939),\n        (-0.31368174039889146, 0.9495281805930367),\n        (-0.32531029216226287, 0.9456073253805214),\n        (-0.33688985339221994, 0.9415440651830208),\n        (-0.3484186802494344, 0.937339011912575),\n        (-0.35989503653498817, 0.9329927988347388),\n        (-0.37131719395183754, 0.9285060804732156),\n        (-0.3826834323650897, 0.9238795325112867),\n        (-0.393992040061048, 0.9191138516900578),\n        (-0.40524131400498975, 0.9142097557035307),\n        (-0.416429560097637, 0.9091679830905225),\n        (-0.42755509343028186, 0.9039892931234434),\n        (-0.4386162385385274, 0.8986744656939539),\n        (-0.4496113296546067, 0.8932243011955152),\n        (-0.4605387109582401, 0.8876396204028539),\n        (-0.4713967368259977, 0.881921264348355),\n        (-0.4821837720791227, 0.8760700941954066),\n        (-0.4928981922297839, 0.8700869911087115),\n        (-0.5035383837257175, 0.8639728561215868),\n        (-0.5141027441932216, 0.8577286100002721),\n        (-0.5245896826784687, 0.8513551931052652),\n        (-0.5349976198870969, 0.8448535652497072),\n        (-0.5453249884220461, 0.8382247055548382),\n        (-0.555570233019602, 0.8314696123025455),\n        (-0.5657318107836132, 0.8245893027850253),\n        (-0.5758081914178453, 0.8175848131515837),\n        (-0.5857978574564389, 0.8104571982525948),\n        (-0.5956993044924332, 0.8032075314806449),\n        (-0.6055110414043254, 0.7958369046088836),\n        (-0.6152315905806267, 0.7883464276266063),\n        (-0.6248594881423862, 0.7807372285720946),\n        (-0.6343932841636453, 0.7730104533627371),\n        (-0.6438315428897913, 0.7651672656224591),\n        (-0.6531728429537765, 0.7572088465064848),\n        (-0.6624157775901718, 0.7491363945234593),\n        (-0.6715589548470184, 0.740951125354959),\n        (-0.680600997795453, 0.7326542716724128),\n        (-0.6895405447370668, 0.724247082951467),\n        (-0.6983762494089728, 0.7157308252838187),\n        (-0.7071067811865475, 0.7071067811865476),\n        (-0.7157308252838186, 0.6983762494089729),\n        (-0.7242470829514669, 0.689540544737067),\n        (-0.7326542716724127, 0.6806009977954532),\n        (-0.7409511253549589, 0.6715589548470186),\n        (-0.749136394523459, 0.662415777590172),\n        (-0.7572088465064847, 0.6531728429537766),\n        (-0.765167265622459, 0.6438315428897914),\n        (-0.773010453362737, 0.6343932841636455),\n        (-0.7807372285720945, 0.6248594881423863),\n        (-0.7883464276266062, 0.6152315905806269),\n        (-0.7958369046088835, 0.6055110414043255),\n        (-0.8032075314806448, 0.5956993044924335),\n        (-0.8104571982525947, 0.585797857456439),\n        (-0.8175848131515836, 0.5758081914178454),\n        (-0.8245893027850251, 0.5657318107836135),\n        (-0.8314696123025453, 0.5555702330196022),\n        (-0.8382247055548381, 0.5453249884220464),\n        (-0.8448535652497071, 0.5349976198870972),\n        (-0.8513551931052652, 0.524589682678469),\n        (-0.8577286100002721, 0.5141027441932218),\n        (-0.8639728561215867, 0.5035383837257176),\n        (-0.8700869911087113, 0.49289819222978415),\n        (-0.8760700941954065, 0.4821837720791229),\n        (-0.8819212643483549, 0.4713967368259978),\n        (-0.8876396204028538, 0.4605387109582402),\n        (-0.8932243011955152, 0.4496113296546069),\n        (-0.8986744656939539, 0.43861623853852755),\n        (-0.9039892931234433, 0.42755509343028203),\n        (-0.9091679830905224, 0.41642956009763715),\n        (-0.9142097557035307, 0.40524131400498986),\n        (-0.9191138516900578, 0.39399204006104815),\n        (-0.9238795325112867, 0.38268343236508984),\n        (-0.9285060804732155, 0.37131719395183765),\n        (-0.9329927988347388, 0.35989503653498833),\n        (-0.9373390119125748, 0.3484186802494348),\n        (-0.9415440651830207, 0.3368898533922203),\n        (-0.9456073253805213, 0.3253102921622632),\n        (-0.9495281805930367, 0.3136817403988914),\n        (-0.9533060403541939, 0.30200594931922803),\n        (-0.9569403357322088, 0.29028467725446233),\n        (-0.9604305194155658, 0.2785196893850531),\n        (-0.9637760657954398, 0.2667127574748985),\n        (-0.9669764710448521, 0.2548656596045147),\n        (-0.970031253194544, 0.24298017990326404),\n        (-0.9729399522055601, 0.2310581082806713),\n        (-0.9757021300385285, 0.21910124015687002),\n        (-0.9783173707196275, 0.20711137619221884),\n        (-0.9807852804032304, 0.19509032201612858),\n        (-0.9831054874312164, 0.1830398879551409),\n        (-0.9852776423889412, 0.1709618887603012),\n        (-0.9873014181578584, 0.15885814333386145),\n        (-0.989176509964781, 0.1467304744553618),\n        (-0.99090263542778, 0.13458070850712628),\n        (-0.99247953459871, 0.12241067519921635),\n        (-0.9939069700023561, 0.11022220729388325),\n        (-0.9951847266721968, 0.09801714032956084),\n        (-0.996312612182778, 0.08579731234444016),\n        (-0.9972904566786902, 0.07356456359966775),\n        (-0.9981181129001492, 0.061320736302208495),\n        (-0.9987954562051724, 0.04906767432741797),\n        (-0.9993223845883495, 0.03680722294135883),\n        (-0.9996988186962042, 0.024541228522912326),\n        (-0.9999247018391445, 0.012271538285720007),\n        (-1.0, 1.2246467991473532e-16),\n        (-0.9999247018391445, -0.01227153828571976),\n        (-0.9996988186962042, -0.024541228522912083),\n        (-0.9993223845883495, -0.03680722294135858),\n        (-0.9987954562051724, -0.049067674327417724),\n        (-0.9981181129001492, -0.061320736302208245),\n        (-0.9972904566786902, -0.0735645635996675),\n        (-0.996312612182778, -0.08579731234443992),\n        (-0.9951847266721969, -0.09801714032956059),\n        (-0.9939069700023561, -0.110222207293883),\n        (-0.99247953459871, -0.1224106751992161),\n        (-0.99090263542778, -0.13458070850712606),\n        (-0.989176509964781, -0.14673047445536158),\n        (-0.9873014181578584, -0.15885814333386122),\n        (-0.9852776423889413, -0.17096188876030097),\n        (-0.9831054874312164, -0.18303988795514067),\n        (-0.9807852804032304, -0.19509032201612836),\n        (-0.9783173707196277, -0.20711137619221862),\n        (-0.9757021300385286, -0.21910124015686983),\n        (-0.9729399522055602, -0.2310581082806711),\n        (-0.970031253194544, -0.24298017990326382),\n        (-0.9669764710448522, -0.25486565960451446),\n        (-0.96377606579544, -0.26671275747489825),\n        (-0.9604305194155659, -0.2785196893850529),\n        (-0.9569403357322089, -0.29028467725446216),\n        (-0.953306040354194, -0.3020059493192278),\n        (-0.9495281805930368, -0.3136817403988912),\n        (-0.9456073253805213, -0.32531029216226304),\n        (-0.9415440651830208, -0.3368898533922201),\n        (-0.937339011912575, -0.34841868024943456),\n        (-0.932992798834739, -0.3598950365349881),\n        (-0.9285060804732156, -0.3713171939518375),\n        (-0.9238795325112867, -0.38268343236508967),\n        (-0.9191138516900578, -0.39399204006104793),\n        (-0.9142097557035307, -0.4052413140049897),\n        (-0.9091679830905225, -0.41642956009763693),\n        (-0.9039892931234434, -0.4275550934302818),\n        (-0.898674465693954, -0.4386162385385273),\n        (-0.8932243011955153, -0.44961132965460665),\n        (-0.8876396204028539, -0.46053871095824006),\n        (-0.881921264348355, -0.47139673682599764),\n        (-0.8760700941954066, -0.4821837720791227),\n        (-0.8700869911087115, -0.4928981922297839),\n        (-0.8639728561215868, -0.5035383837257175),\n        (-0.8577286100002721, -0.5141027441932216),\n        (-0.8513551931052652, -0.5245896826784687),\n        (-0.8448535652497072, -0.5349976198870969),\n        (-0.8382247055548382, -0.5453249884220461),\n        (-0.8314696123025455, -0.555570233019602),\n        (-0.8245893027850253, -0.5657318107836132),\n        (-0.8175848131515837, -0.5758081914178453),\n        (-0.8104571982525948, -0.5857978574564389),\n        (-0.8032075314806449, -0.5956993044924332),\n        (-0.7958369046088836, -0.6055110414043254),\n        (-0.7883464276266063, -0.6152315905806267),\n        (-0.7807372285720946, -0.6248594881423862),\n        (-0.7730104533627371, -0.6343932841636453),\n        (-0.7651672656224591, -0.6438315428897913),\n        (-0.7572088465064848, -0.6531728429537765),\n        (-0.7491363945234593, -0.6624157775901718),\n        (-0.740951125354959, -0.6715589548470184),\n        (-0.7326542716724128, -0.680600997795453),\n        (-0.724247082951467, -0.6895405447370668),\n        (-0.7157308252838187, -0.6983762494089728),\n        (-0.7071067811865477, -0.7071067811865475),\n        (-0.698376249408973, -0.7157308252838185),\n        (-0.6895405447370672, -0.7242470829514667),\n        (-0.6806009977954532, -0.7326542716724126),\n        (-0.6715589548470187, -0.7409511253549588),\n        (-0.6624157775901721, -0.749136394523459),\n        (-0.6531728429537771, -0.7572088465064842),\n        (-0.6438315428897915, -0.7651672656224588),\n        (-0.6343932841636459, -0.7730104533627367),\n        (-0.6248594881423865, -0.7807372285720944),\n        (-0.6152315905806274, -0.7883464276266059),\n        (-0.6055110414043257, -0.7958369046088833),\n        (-0.5956993044924332, -0.803207531480645),\n        (-0.5857978574564391, -0.8104571982525947),\n        (-0.5758081914178452, -0.8175848131515837),\n        (-0.5657318107836136, -0.8245893027850251),\n        (-0.5555702330196022, -0.8314696123025452),\n        (-0.5453249884220468, -0.8382247055548377),\n        (-0.5349976198870973, -0.8448535652497071),\n        (-0.5245896826784694, -0.8513551931052649),\n        (-0.5141027441932219, -0.857728610000272),\n        (-0.5035383837257181, -0.8639728561215865),\n        (-0.49289819222978426, -0.8700869911087113),\n        (-0.4821837720791226, -0.8760700941954067),\n        (-0.47139673682599786, -0.8819212643483549),\n        (-0.4605387109582399, -0.887639620402854),\n        (-0.44961132965460693, -0.8932243011955152),\n        (-0.4386162385385276, -0.8986744656939538),\n        (-0.4275550934302825, -0.9039892931234431),\n        (-0.4164295600976372, -0.9091679830905224),\n        (-0.40524131400499036, -0.9142097557035305),\n        (-0.3939920400610482, -0.9191138516900577),\n        (-0.38268343236509034, -0.9238795325112865),\n        (-0.3713171939518377, -0.9285060804732155),\n        (-0.35989503653498794, -0.932992798834739),\n        (-0.34841868024943484, -0.9373390119125748),\n        (-0.33688985339221994, -0.9415440651830208),\n        (-0.32531029216226326, -0.9456073253805212),\n        (-0.31368174039889146, -0.9495281805930367),\n        (-0.3020059493192285, -0.9533060403541938),\n        (-0.2902846772544624, -0.9569403357322088),\n        (-0.2785196893850536, -0.9604305194155657),\n        (-0.26671275747489853, -0.9637760657954398),\n        (-0.2548656596045143, -0.9669764710448522),\n        (-0.24298017990326412, -0.970031253194544),\n        (-0.23105810828067097, -0.9729399522055602),\n        (-0.2191012401568701, -0.9757021300385285),\n        (-0.20711137619221848, -0.9783173707196277),\n        (-0.19509032201612866, -0.9807852804032303),\n        (-0.18303988795514098, -0.9831054874312163),\n        (-0.17096188876030172, -0.9852776423889411),\n        (-0.15885814333386153, -0.9873014181578583),\n        (-0.14673047445536233, -0.9891765099647809),\n        (-0.13458070850712636, -0.99090263542778),\n        (-0.12241067519921596, -0.9924795345987101),\n        (-0.11022220729388331, -0.9939069700023561),\n        (-0.09801714032956045, -0.9951847266721969),\n        (-0.08579731234444021, -0.996312612182778),\n        (-0.07356456359966736, -0.9972904566786902),\n        (-0.06132073630220899, -0.9981181129001492),\n        (-0.04906767432741803, -0.9987954562051724),\n        (-0.03680722294135933, -0.9993223845883494),\n        (-0.02454122852291239, -0.9996988186962042),\n        (-0.012271538285720512, -0.9999247018391445),\n        (-1.8369701987210297e-16, -1.0),\n        (0.012271538285720144, -0.9999247018391445),\n        (0.02454122852291202, -0.9996988186962042),\n        (0.03680722294135897, -0.9993223845883495),\n        (0.04906767432741767, -0.9987954562051724),\n        (0.061320736302208634, -0.9981181129001492),\n        (0.073564563599667, -0.9972904566786902),\n        (0.08579731234443987, -0.996312612182778),\n        (0.09801714032956009, -0.9951847266721969),\n        (0.11022220729388295, -0.9939069700023561),\n        (0.1224106751992156, -0.9924795345987101),\n        (0.13458070850712597, -0.99090263542778),\n        (0.14673047445536194, -0.9891765099647809),\n        (0.15885814333386114, -0.9873014181578584),\n        (0.17096188876030133, -0.9852776423889412),\n        (0.1830398879551406, -0.9831054874312164),\n        (0.19509032201612828, -0.9807852804032304),\n        (0.2071113761922181, -0.9783173707196278),\n        (0.21910124015686974, -0.9757021300385286),\n        (0.23105810828067058, -0.9729399522055603),\n        (0.24298017990326376, -0.970031253194544),\n        (0.25486565960451396, -0.9669764710448523),\n        (0.2667127574748982, -0.96377606579544),\n        (0.2785196893850533, -0.9604305194155658),\n        (0.2902846772544621, -0.9569403357322089),\n        (0.3020059493192282, -0.9533060403541938),\n        (0.31368174039889113, -0.9495281805930368),\n        (0.325310292162263, -0.9456073253805213),\n        (0.3368898533922196, -0.9415440651830209),\n        (0.3484186802494345, -0.937339011912575),\n        (0.35989503653498767, -0.9329927988347391),\n        (0.37131719395183743, -0.9285060804732156),\n        (0.38268343236509, -0.9238795325112866),\n        (0.39399204006104793, -0.9191138516900579),\n        (0.40524131400499, -0.9142097557035306),\n        (0.4164295600976369, -0.9091679830905225),\n        (0.4275550934302822, -0.9039892931234433),\n        (0.43861623853852727, -0.898674465693954),\n        (0.4496113296546066, -0.8932243011955153),\n        (0.4605387109582396, -0.8876396204028542),\n        (0.4713967368259976, -0.881921264348355),\n        (0.4821837720791222, -0.8760700941954069),\n        (0.49289819222978387, -0.8700869911087115),\n        (0.5035383837257177, -0.8639728561215867),\n        (0.5141027441932214, -0.8577286100002722),\n        (0.524589682678469, -0.8513551931052651),\n        (0.5349976198870969, -0.8448535652497073),\n        (0.5453249884220465, -0.838224705554838),\n        (0.5555702330196018, -0.8314696123025456),\n        (0.5657318107836131, -0.8245893027850253),\n        (0.5758081914178449, -0.817584813151584),\n        (0.5857978574564388, -0.8104571982525949),\n        (0.5956993044924328, -0.8032075314806453),\n        (0.6055110414043253, -0.7958369046088837),\n        (0.6152315905806269, -0.7883464276266061),\n        (0.6248594881423861, -0.7807372285720947),\n        (0.6343932841636456, -0.7730104533627369),\n        (0.6438315428897912, -0.7651672656224592),\n        (0.6531728429537768, -0.7572088465064846),\n        (0.6624157775901715, -0.7491363945234597),\n        (0.6715589548470183, -0.7409511253549592),\n        (0.6806009977954527, -0.7326542716724131),\n        (0.6895405447370668, -0.7242470829514671),\n        (0.6983762494089724, -0.715730825283819),\n        (0.7071067811865475, -0.7071067811865477),\n        (0.7157308252838188, -0.6983762494089727),\n        (0.7242470829514667, -0.6895405447370672),\n        (0.7326542716724129, -0.680600997795453),\n        (0.7409511253549588, -0.6715589548470187),\n        (0.7491363945234594, -0.6624157775901718),\n        (0.7572088465064842, -0.6531728429537771),\n        (0.7651672656224588, -0.6438315428897915),\n        (0.7730104533627367, -0.6343932841636459),\n        (0.7807372285720944, -0.6248594881423865),\n        (0.7883464276266059, -0.6152315905806274),\n        (0.7958369046088833, -0.6055110414043257),\n        (0.803207531480645, -0.5956993044924332),\n        (0.8104571982525947, -0.5857978574564391),\n        (0.8175848131515837, -0.5758081914178452),\n        (0.8245893027850251, -0.5657318107836136),\n        (0.8314696123025452, -0.5555702330196022),\n        (0.8382247055548377, -0.5453249884220468),\n        (0.8448535652497071, -0.5349976198870973),\n        (0.8513551931052649, -0.5245896826784694),\n        (0.857728610000272, -0.5141027441932219),\n        (0.8639728561215865, -0.5035383837257181),\n        (0.8700869911087113, -0.49289819222978426),\n        (0.8760700941954067, -0.4821837720791226),\n        (0.8819212643483549, -0.4713967368259979),\n        (0.887639620402854, -0.46053871095823995),\n        (0.8932243011955151, -0.449611329654607),\n        (0.8986744656939538, -0.43861623853852766),\n        (0.9039892931234431, -0.42755509343028253),\n        (0.9091679830905224, -0.41642956009763726),\n        (0.9142097557035305, -0.4052413140049904),\n        (0.9191138516900577, -0.39399204006104827),\n        (0.9238795325112865, -0.3826834323650904),\n        (0.9285060804732155, -0.37131719395183777),\n        (0.932992798834739, -0.359895036534988),\n        (0.9373390119125748, -0.3484186802494349),\n        (0.9415440651830208, -0.33688985339222),\n        (0.9456073253805212, -0.3253102921622633),\n        (0.9495281805930367, -0.3136817403988915),\n        (0.9533060403541936, -0.30200594931922853),\n        (0.9569403357322088, -0.29028467725446244),\n        (0.9604305194155657, -0.27851968938505367),\n        (0.9637760657954398, -0.2667127574748986),\n        (0.9669764710448522, -0.25486565960451435),\n        (0.970031253194544, -0.24298017990326418),\n        (0.9729399522055602, -0.23105810828067103),\n        (0.9757021300385285, -0.21910124015687016),\n        (0.9783173707196277, -0.20711137619221853),\n        (0.9807852804032303, -0.19509032201612872),\n        (0.9831054874312163, -0.18303988795514103),\n        (0.9852776423889411, -0.17096188876030177),\n        (0.9873014181578583, -0.15885814333386158),\n        (0.9891765099647809, -0.1467304744553624),\n        (0.99090263542778, -0.13458070850712642),\n        (0.99247953459871, -0.12241067519921603),\n        (0.9939069700023561, -0.11022220729388338),\n        (0.9951847266721969, -0.09801714032956052),\n        (0.996312612182778, -0.08579731234444028),\n        (0.9972904566786902, -0.07356456359966743),\n        (0.9981181129001492, -0.06132073630220905),\n        (0.9987954562051724, -0.04906767432741809),\n        (0.9993223845883494, -0.036807222941359394),\n        (0.9996988186962042, -0.02454122852291245),\n        (0.9999247018391445, -0.012271538285720572)\n    ]\n\nimport submodule falcon_inst\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that fully specifies the ML-KEM (FIPS-203) KEM scheme, including NTT\/INTT, compression\/encoding, key generation, encapsulation, decapsulation, and the properties CorrectnessPKE, CorrectnessKEM, and KeyGenProducesValidKeys as defined in the given description."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE256 as SHAKE256\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHAKE128 as SHAKE128\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_256 as SHA3_256\nimport Primitive::Keyless::Hash::SHA3::Instantiations::SHA3_512 as SHA3_512\n\nprivate\n\n    type n = 256\n\n    type q = 3329\n\n    zeta = 17 : Z q\n\ntype Byte = [8]\n\nprivate\n\n    type Rq = [n](Z q)\n\n    type Tq = [n](Z q)\n\n    PRF : {eta} (2 <= eta, eta <= 3) => [32]Byte -> Byte -> [64 * eta]Byte\n    PRF s b = SHAKE256::xofBytes`{8 * 64 * eta} (s # [b])\n\n    H : {hinl} (fin hinl) => [hinl]Byte -> [32]Byte\n    H s = SHA3_256::hashBytes s\n\n    J : {hinl} (fin hinl) => [hinl]Byte -> [32]Byte\n    J s = SHAKE256::xofBytes`{8 * 32} s\n\n    G : {ginl} (fin ginl) => [ginl]Byte -> ([32]Byte, [32]Byte)\n    G c = (a, b) where\n        [a, b] = split (SHA3_512::hashBytes c)\n\n    XOF : ([34]Byte) -> [inf]Byte\n    XOF = SHAKE128::xofBytes\n\n    BitsToBytes : {ell} (fin ell) => [8 * ell]Bit -> [ell]Byte\n    BitsToBytes b\n        | ell == 0 => zero\n        | ell > 0 => B where\n                                    b' = groupBy`{8} [(zext [bi], i)\n                | bi <- b\n                | i <- [0..8 * ell - 1]]\n\n            \/\/ Steps 2-4.\n            B = [sum [bi * (2 ^^ (i % 8))\n                    | (bi, i) <- bi8]\n                | bi8 <- b']\n\n    BytesToBits : {ell} (fin ell) => [ell]Byte -> [ell*8]Bit\n    BytesToBits C\n        | ell == 0 => []\n        | ell > 0 => join [[ b8ij where\n                                                b8ij = Ci' ! 0\n                \/\/ Step 5. Shifting right is the same as the iterative\n                \/\/ division (see `div2IsShiftR`). This accounts for all the\n                \/\/ divisions \"up to this point\" (e.g. none when `j = 0`), which\n                \/\/ is why we use `Ci'` to evaluate `b8ij` above.\n                Ci' = Ci >> j\n            \/\/ Step 3.\n            | j <- [0..7]]\n            \/\/ Step 2. We iterate over `C` directly instead of indexing into it.\n            | Ci <- C ]\n\n    \/**\n     * The iterative division by 2 in `BytesToBits` is the same as shifting\n     * right.\n     * ```repl\n     * :prove div2IsShiftR\n     * ```\n     *\/\n    div2IsShiftR : Byte -> Bit\n    div2IsShiftR C = take (d2 C) == shl where\n        \/\/ Note: division here is floor'd by default.\n        d2 c = [c] # d2 (c \/ 2)\n        shl = [C >> j | j <- [0..7]]\n\n    B2B2BInverts : {ell} (fin ell, ell > 0) => [ell * 8] -> Bit\n    B2B2BInverts bits = bitsWorks && bytesWorks where\n        bitsWorks = BytesToBits (BitsToBytes bits) == bits\n        bytesWorks = BitsToBytes (BytesToBits (split bits)) == split bits\n\n    B2BExampleWorks = BitsToBytes 0b11010001 == [139]\n\n    property roundingWorks y = y >= 0 ==> roundUpWorks && roundDownWorks where\n        y' = fromInteger y\n        roundUpWorks = roundAway (y' + 0.5) == (y + 1)\n        roundDownWorks = roundAway (y' + 0.4) == y\n\n    \/**\n     * Compress an integer mod `q` into an integer mod `2^d`.\n     * [FIPS-203] Section 4.2.1, Equation 4.7.\n     *\/\n    Compress : {d} (d < width q) => Z q -> [d]\n    Compress x = y where\n        \/\/ Convert from an integer mod `q` to a rational number.\n        x' = fromInteger (fromZ x) : Rational\n                y' = roundAway (((2^^`d) \/. `q) * x')\n                y = (fromInteger y') : [d]\n\n    \/**\n     * Decompress an integer mod `2^d` into an integer mod `q`.\n     * [FIPS-203] Section 4.2.1, Equation 4.8.\n     *\/\n    Decompress : {d} (d < width q) => [d] -> Z q\n    Decompress y = x where\n        \/\/ Convert from a d-length bit vector to a rational number.\n        y' = fromInteger (toInteger y) : Rational\n                x' = roundAway((`q \/. (2^^`d)) * y')\n                x = (fromInteger x') : Z q\n\n    \/**\n     * Compression inverts decompression for all inputs and bit lengths.\n     * We'll prove it for the bit lengths found in the\n     * ```repl\n     * :prove CompressInvertsDecompress`{1}\n     * :exhaust CompressInvertsDecompress`{d_u}\n     * :exhaust CompressInvertsDecompress`{d_v}\n     * ```\n     *\/\n    CompressInvertsDecompress : {d} (d < width q) => [d] -> Bit\n    property CompressInvertsDecompress y = Compress (Decompress y) == y\n\n    DecompressMostlyInvertsCompress : Z q -> Bit\n    property DecompressMostlyInvertsCompress x = errIsSmallEnough where\n        x' = Decompress`{d_u} (Compress`{d_u} x)\n        err = abs (modpm (x' - x))\n        errIsSmallEnough = err <= B_q`{d_u}\n\n                        B_q : {d} (d < lg2 q) => Integer\n        B_q = roundAway((`q\/.(2^^(`d+1))))\n\n                        modpm : Z q -> Integer\n        modpm r = if r' > (`q \/ 2) then r' - `q else r'\n            where r' = fromZ r\n\n    Compress_Vec : {d} (d < lg2 q) => [n](Z q) -> [n][d]\n    Compress_Vec x = map Compress`{d} x\n\n    Decompress_Vec : {d} (d < lg2 q) => [n][d] -> [n](Z q)\n    Decompress_Vec x = map Decompress`{d} x\n\n    Compress_Mat : {d, k1} (d < lg2 q, fin k1) => [k1][n](Z q) -> [k1][n][d]\n    Compress_Mat x = map Compress_Vec`{d} x\n\n    Decompress_Mat : {d, k1} (d < lg2 q, fin k1) => [k1][n][d] -> [k1][n](Z q)\n    Decompress_Mat x = map Decompress_Vec`{d} x\n\n    ByteEncode : {d} (1 <= d, d < 12) => [256][d] -> [32 * d]Byte\n    ByteEncode F = B where\n                                                as = [[ a >> j | j <- [0..d-1]] | a <- F]\n                        b = join [ [ a ! 0 | a <- ajs] | ajs <- as]\n                B = BitsToBytes b\n\n    ByteEncode_Vec : {d} (fin d, 1 <= d, d < 12) => [k][256][d] -> [k * 32 * d]Byte\n    ByteEncode_Vec F_vec = join (map ByteEncode F_vec)\n\n    ByteEncode12 : [256](Z q) -> [32 * 12]Byte\n    ByteEncode12 F = B where\n        type d = 12\n\n                        toBitVec : Z q -> [d]\n        toBitVec f = fromInteger (fromZ f)\n        F' = map toBitVec F\n\n        \/\/ The following is the same as in `ByteEncode`. See notes above.\n        as = [[ a >> j | j <- [0..d-1]] | a <- F' ]\n        b = join [ [ a ! 0 | a <- ajs] | ajs <- as]\n        B = BitsToBytes b\n\n    ByteEncode12_Vec : [k][256](Z q) -> [k * 32 * 12]Byte\n    ByteEncode12_Vec F_vec = join (map ByteEncode12 F_vec)\n\n    subAndDivIsShiftR : {d} (fin d, d > 1) => [d] -> Bit\n    property subAndDivIsShiftR a = take (sad a) == shift a where\n                sad x = [x] # sad ((x - (x % 2)) \/ 2)\n        shift x = [x >> i | i <- [0..d-1]]\n\n    mod2IsFinalBit : {d} (fin d, d > 1) => [d] -> Bit\n    property mod2IsFinalBit a = a % 2 == zext [a ! 0]\n\n    ByteDecode : {d} (1 <= d, d < 12) => [32 * d]Byte -> [256][d]\n    ByteDecode B = F where\n                b = BytesToBits B\n                                                                                F = [ sum [ (zext [bidj]) << j\n                | bidj <- bid\n                | j <- [0..d-1]]\n            | bid <- split`{256} b]\n\n    ByteDecode_Vec : {d} (1 <= d, d < 12) => [k * 32 * d]Byte -> [k][256][d]\n    ByteDecode_Vec B_vec = map ByteDecode (split B_vec)\n\n    ByteDecode12 : [32 * 12]Byte -> [256](Z q)\n    ByteDecode12 B = F' where\n        type d = 12\n        \/\/ These steps are the same as in `ByteDecode`. See that function for\n        \/\/ notes.\n        b = BytesToBits B\n        F = [ sum [ (zext`{d} [bidj]) << j\n                | bidj <- bid\n                | j <- [0..d-1]]\n            | bid <- split`{256} b]\n\n        \/\/ In this case, since `m = q` (and not `2^12`), we need to explicitly\n        \/\/ convert each integer from a 12-bit array to an integer mod `q`.\n        toZq f = fromInteger (toInteger f)\n        F' = map toZq F\n\n    ByteDecode12_Vec : [k * 32 * 12]Byte -> [k][256](Z q)\n    ByteDecode12_Vec B = map ByteDecode12 (split B)\n\n    mul2jIsShiftL : {d} (fin d, 1 < d) => [d] -> Bit\n    property mul2jIsShiftL b = and [( b * (2^^j)) == (b << j) | j <- [0..d-1]]\n\n    ByteEncodeInvertsByteDecode : {d} (fin d, 1 <= d, d < 12) => [256][d] -> Bit\n    property ByteEncodeInvertsByteDecode bits =\n        decode_encode_works && encode_decode_works where\n        decode_encode_works = ByteDecode (ByteEncode bits) == bits\n                bytes = split (join bits)\n        encode_decode_works = ByteEncode (ByteDecode bytes) == bytes\n\n    ByteDecode12InvertsByteEncode12 : [256](Z q) -> Bit\n    ByteDecode12InvertsByteEncode12 bits =\n        ByteDecode12 (ByteEncode12 bits) == bits\n\n    SampleNTT : [34]Byte -> Tq\n    SampleNTT B = a_hat' where\n        \/\/ Steps 1-2, 5.\n        \/\/ We (lazily) take an infinite stream from the XOF and remove only as\n        \/\/ many bytes as are needed to compute the function. See [FIPS-203]\n        \/\/ Section 4.1 Equation 4.6 for a discussion of the equivalence of this\n        \/\/ form to the one in Algorithm 7.\n        ctx0 = XOF B\n\n        \/\/ Step 3. Since Cryptol is not imperative, we implement this loop using\n        \/\/ recursion. The `j` counter is not made explicit; instead we lazily\n        \/\/ generate an infinite stream of coefficients in `T_q` and `take` the\n        \/\/ correct length in the next line.\n\n        \/\/ Step 4-16. `take` fulfills the `j < 256` condition in Steps 4 and 12.\n        a_hat = take`{256} (filter ctx0)\n\n        \/\/ `filter` parses an infinite stream from the XOF, computing\n        \/\/ potential elements `d1` and `d2` from the first 3 bytes in the stream\n        \/\/ and adding them to the output if they are valid elements in `Z q`.\n        filter: [inf]Byte -> [inf][12]\n        filter XOFSqueeze = a_hat_j where\n            \/\/ Step 5.\n            (C # ctx) = XOFSqueeze\n\n            \/\/ The conversion from 8-bit to 12-bit vectors (with the same\n            \/\/ value!) is implicit in the spec -- see notes on Step 5 and 6\/7.\n            \/\/ In Cryptol, we need to convert manually to do the subsequent\n            \/\/ computations.\n            [C0, C1, C2] = map zext`{12} C\n\n            \/\/ Step 6.\n            d1 = C0 + 256 * (C1 % 16)\n\n            \/\/ Step 7. Cryptol uses integer division; it always takes the floor\n            \/\/ of the result.\n            d2 = (C1 \/ 16) + 16 * C2\n\n            \/\/ Steps 4, 8 - 15.\n            \/\/ Add `d1` and\/or `d2` to the sampled vector `a_hat` if they are\n            \/\/ valid elements in `Z q`.\n            \/\/ The `while` loop in Step 4 is equivalent to the recursive call to\n            \/\/ `filter` in each condition.\n            a_hat_j = if (d1 < `q) && (d2 < `q) then\n                    [d1, d2] # filter ctx\n                else if d1 < `q then\n                    [d1] # filter ctx\n                else if d2 < `q then\n                    [d2] # filter ctx\n                else filter ctx\n\n        \/\/ This conversion is implicit in the implementation -- see the notes on\n        \/\/ Step 6\/7 and 9.\n        toZq : [12] -> Z q\n        toZq x = fromInteger (toInteger x)\n\n        a_hat' = map toZq a_hat\n\n    SamplePolyCBD: {eta} (2 <= eta, eta <= 3) => [64 * eta]Byte -> Rq\n    SamplePolyCBD B = f where\n                b = BytesToBits B\n                        BitToZ : Bit -> Z q\n        BitToZ bit = if bit then 1 else 0\n        b' = map BitToZ b\n\n        \/\/ Step 3.\n        x i = sum [b'@(2 * i * `eta + j) | j <- [0 .. (eta-1)]]\n                y i = sum [b'@(2 * i * `eta + `eta + j) | j <- [0 .. (eta-1)]]\n\n        \/\/ Steps 2, 5. The `mod q` is not explicit here because `x` and `y`\n        \/\/ return elements of `Z q`.\n        f = [(x i) - (y i) | i <- [0 .. 255]]\n\n    \/**\n     * [FIPS-203] Section 4.3 \"The mathematical structure of the NTT.\"\n     * ```repl\n     * :prove QisCorrectlyDefined\n     * ```\n     *\/\n    QisCorrectlyDefined: Bit\n    property QisCorrectlyDefined = `q == 2^^8 * 13 + 1\n\n    \/**\n     * `zeta` is a primitive 256-th root of unity modulo `q`.\n     * [FIPS-203] Section 4.3 \"The mathematical structure of the NTT.\"\n     *\n     * ```repl\n     * :prove zetaIsPrimitiveRoot\n     * ```\n     *\/\n    property zetaIsPrimitiveRoot = zeta ^^ 128 == -1\n\n    \/**\n     * Proves that `zeta` is correctly set to be the 256th root of `q`.\n     * ```repl\n     * :exhaust Is256thRootOfq\n     * ```\n     *\/\n    Is256thRootOfq : [lg2 q] -> Bit\n    property Is256thRootOfq p = (p == 0) || (p >= 256) || (zeta^^p != 1)\n\n    \/**\n     * Reverse the unsigned 7-bit value corresponding to an input integer in\n     * `[0, ..., 127]`.\n     * [FIPS-203] Section 4.3 \"The mathematical structure of the NTT.\"\n     *\n     * This diverges from the spec by operating over an 8-bit vector;\n     * this is to ease prior and subsequent computations that would overflow a\n     * 7-bit vector, like:\n     * - `2 * (BitRev7 i) + 1`\n     * - `2 * i + 1`\n     *\n     * A \"pure\" implementation of `BitRev7` in Cryptol is the `reverse` function\n     * on 7-bit vectors. This mini-property shows equivalence:\n     * ```repl\n     * :prove \\(x:[7]) -> ([0] # reverse x) == BitRev7 ([0] # x)\n     * ```\n     *\/\n    BitRev7 : [8] -> [8]\n    BitRev7 i = if i > 255 then error \"BitRev7 called with invalid input\"\n        else (reverse i) >> 1\n\n\/**\n * This section specifies the number-theoretic transform (NTT).\n *\n * It includes the version from [FIPS-203] Section 4.3 as well\n * as a faster O(N log N) version, and a proof of their equivalence.\n *\n * This is explicitly allowed by the spec: \"For every computational procedure\n * [...] a conforming implementation may replace the given set of steps with\n * any mathematically equivalent set of steps\". The equivalence properties\n * prove mathematical equivalence.\n * [FIPS-203] Introduction, \"7. Implementations\".\n *\/\nimport submodule NTT\nsubmodule NTT where\n    private\n        \/**\n         * Number theoretic transform: compute the \"NTT representation\" in\n         * `T_q` of a polynomial in `R_q`.\n         *\n         * [FIPS-203] Section 4.3, Algorithm 9.\n         *\/\n        NaiveNTT : Rq -> Tq\n        NaiveNTT f = join [[f2i i, f2iPlus1 i] | i <- [0 .. 127]] where\n            f2i i = sum [f @(2*j) * zeta_term i j | j <- [0 .. 127]]\n            f2iPlus1 i = sum [f @(2*j+1) * zeta_term i j | j <- [0 .. 127]]\n            zeta_term i j = zeta ^^ ((2 * BitRev7 i + 1) * j)\n\n        \/**\n         * Inverse of the number theoretic transform: converts from the \"NTT\n         * representation\" in `T_q` to a polynomial in `R_q`.\n         *\n         * [FIPS-203] Section 4.3, Algorithm 10.\n         *\/\n        NaiveNTTInv : Tq -> Rq\n        NaiveNTTInv f_hat = [f_i * 3303 | f_i <- f] where\n            f = join [[f2i i, f2iPlus1 i] | i <- [0 .. 127]]\n            f2i i = sum [f_hat @(2*j) * zeta_term i j | j <- [0 .. 127]]\n            f2iPlus1 i = sum [f_hat @(2*j+1) * zeta_term i j | j <- [0 .. 127]]\n            zeta_term i j = (recip zeta) ^^ ((2 * BitRev7 j + 1) * i)\n\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/ This section specifies fast O(N log N) NTT and Inverse NTT\n        \/\/\n        \/\/ A readable explanation of the derivation of this form of\n        \/\/ the NTT is in \"A Complete Beginner Guide to the Number\n        \/\/ Theoretic Transform (NTT)\" by Ardianto Satriawan,\n        \/\/ Rella Mareta, and Hanho Lee. Available from:\n        \/\/    https:\/\/eprint.iacr.org\/2024\/585\n        \/\/\n        \/\/ This section Copyright Amazon.com, Inc. or its affiliates.\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n        \/**\n         * Lookup table for `zeta` values computed in `NTT` and `NTTInv`.\n         *\n         * [FIPS-203] Appendix A.\n         *\/\n        zeta_expc  : [128](Z q)\n        zeta_expc = [\n            1, 1729, 2580, 3289, 2642, 630, 1897, 848,\n            1062, 1919, 193, 797, 2786, 3260, 569, 1746,\n            296, 2447, 1339, 1476, 3046, 56, 2240, 1333,\n            1426, 2094, 535, 2882, 2393, 2879, 1974, 821,\n            289, 331, 3253, 1756, 1197, 2304, 2277, 2055,\n            650, 1977, 2513, 632, 2865, 33, 1320, 1915,\n            2319, 1435, 807, 452, 1438, 2868, 1534, 2402,\n            2647, 2617, 1481, 648, 2474, 3110, 1227, 910,\n            17, 2761, 583, 2649, 1637, 723, 2288, 1100,\n            1409, 2662, 3281, 233, 756, 2156, 3015, 3050,\n            1703, 1651, 2789, 1789, 1847, 952, 1461, 2687,\n            939, 2308, 2437, 2388, 733, 2337, 268, 641,\n            1584, 2298, 2037, 3220, 375, 2549, 2090, 1645,\n            1063, 319, 2773, 757, 2099, 561, 2466, 2594,\n            2804, 1092, 403, 1026, 1143, 2150, 2775, 886,\n            1722, 1212, 1874, 1029, 2110, 2935, 885, 2154\n        ]\n\n        \/\/ Top level entry point - start with lv=256, k=1\n        fast_ntt : Rq -> Tq\n        fast_ntt v = fast_nttl v 1\n\n        \/\/ Recursive NTT function\n        fast_nttl :\n            {lv}  \/\/ Length of v is a member of {256,128,64,32,16,8,4}\n            (lv >= 2, lv <= 8) =>\n            [2^^lv](Z q) -> [8] -> [2^^lv](Z q)\n        fast_nttl v k\n            \/\/ Base case. lv==2 so just compute the butterfly and return\n            | lv == 2 => ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n\n            \/\/ Recursive case. Butterfly what we have, then recurse on each half,\n            \/\/ concatenate the results and return.\n            | lv  > 2 => (fast_nttl`{lv-1} s0 (k * 2)) #\n                    (fast_nttl`{lv-1} s1 (k * 2 + 1))\n                        where\n                        t = ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n                        \/\/ Split t into two halves s0 and s1\n                        [s0, s1] = split t\n\n        \/\/ Fast recursive CT-NTT\n        ct_butterfly :\n            {m, hm}\n            (m >= 2, m <= 8, hm >= 1, hm <= 7, hm == m - 1) =>\n            [2^^m](Z q) -> (Z q) -> [2^^m](Z q)\n        ct_butterfly v z = new_v where\n            halflen = 2^^`hm\n            lower, upper : [2^^hm](Z q)\n            lower@x = v@x + z * v@(x + halflen)\n            upper@x = v@x - z * v@(x + halflen)\n            new_v = lower # upper\n\n        \/\/ Recursive inverse-NTT function\n        fast_invnttl :\n            {lv}  \/\/ Length of v is a member of {256,128,64,32,16,8,4}\n            (lv >= 2, lv <= 8) =>\n            [2^^lv](Z q) -> [8] -> [2^^lv](Z q)\n        fast_invnttl v k\n            \/\/ Base case. lv==2 so just compute the butterfly and return\n            | lv == 2 => gs_butterfly`{lv,lv-1} v (zeta_expc@k)\n\n            \/\/ Recursive case. Recurse on each half,\n            \/\/ concatenate the results, butterfly that, and return.\n            | lv  > 2 => gs_butterfly`{lv,lv-1} t (zeta_expc@k) where\n                \/\/ Split t into two halves s0 and s1\n                [s0, s1] = split v\n                t = (fast_invnttl`{lv-1} s0 (k * 2 + 1)) #\n                    (fast_invnttl`{lv-1} s1 (k * 2))\n\n        \/\/ Fast recursive GS-Inverse-NTT\n        gs_butterfly :\n            {m, hm}\n            (m >= 2, m <= 8, hm >= 1, hm <= 7, hm == m - 1) =>\n            [2^^m](Z q) -> (Z q) -> [2^^m](Z q)\n        gs_butterfly v z = new_v where\n            halflen = 2^^`hm\n            lower, upper : [2^^hm](Z q)\n            lower@x = v@x  + v@(x + halflen)\n            upper@x = z * (v@(x + halflen) - v@x)\n            new_v = lower # upper\n\n        \/\/ Top level entry point - start with lv=256, k=1\n        fast_invntt : Tq -> Rq\n        fast_invntt v = mul_recip128 (fast_invnttl v 1) where\n\n            \/\/ Multiplicative inverse of 128, mod `q`.\n            recip_128_modq = (recip 128) : (Z q)\n\n            \/\/ Multiply all elements of v' by the reciprocal of 128 (modulo q)\n            mul_recip128 : Tq -> Tq\n            mul_recip128 v' = [ v'@x * recip_128_modq | x <- [0 .. <n] ]\n\n        NaiveNTT_Inverts : Rq -> Bit\n        property NaiveNTT_Inverts f =  NaiveNTTInv (NaiveNTT f) == f\n\n        NaiveNTTInv_Inverts : Tq -> Bit\n        property NaiveNTTInv_Inverts f =  NaiveNTT (NaiveNTTInv f) == f\n\n        fast_ntt_inverts : Rq -> Bit\n        property fast_ntt_inverts    f =  fast_invntt (fast_ntt f)    == f\n\n        fast_invntt_inverts : Tq -> Bit\n        property fast_invntt_inverts f =  fast_ntt    (fast_invntt f) == f\n\n        naive_fast_ntt_equiv : Rq -> Bit\n        property naive_fast_ntt_equiv f =  NaiveNTT f == fast_ntt f\n\n        naive_fast_invntt_equiv : Tq -> Bit\n        property naive_fast_invntt_equiv f =  NaiveNTTInv f == fast_invntt f\n\n    NTT : Rq -> Tq\n    NTT = fast_ntt\n\n    NTTInv : Tq -> Rq\n    NTTInv = fast_invntt\n\n    NTT_Vec v = map NTT v\n\n    NTTInv_Vec v = map NTTInv v\n\n    BaseCaseMultiply : (Z q) -> (Z q) -> (Z q) -> (Z q) -> (Z q) -> [2](Z q)\n    BaseCaseMultiply a0 a1 b0 b1 \u03b3 = [c0, c1]\n      where\n        c0 = a0 * b0 + a1 * b1 * \u03b3\n        c1 = a0 * b1 + a1 * b0\n\n    MultiplyNTTs : Tq -> Tq -> Tq\n    MultiplyNTTs f_hat g_hat = join h_hat where\n        h_hat = [ BaseCaseMultiply\n            (f_hat @(2*i))\n            (f_hat @(2*i+1))\n            (g_hat @(2*i))\n            (g_hat @(2*i+1))\n            (zeta ^^(2 * BitRev7 i + 1))\n        | i <- [0 .. 127] ]\n\n    TestMult : Bit\n    property TestMult = prod f f == fsq where\n      f = [1, 1] # [0 | i <- [3 .. 256]]\n      fsq = [1,2,1] # [0 | i <- [4 .. 256]]\n\n      prod : Rq -> Rq -> Rq\n      prod a b = NTTInv (MultiplyNTTs (NTT a) (NTT b))\n\n    (\u00d7) = MultiplyNTTs\n\n    dotVecVec : {k1} (fin k1) => [k1]Tq -> [k1]Tq -> Tq\n    dotVecVec v1 v2 = sum (zipWith (\u00d7) v1 v2)\n\n    dotMatVec : {k1,k2} (fin k1, fin k2) => [k1][k2]Tq -> [k2]Tq -> [k1]Tq\n    dotMatVec matrix vector = [dotVecVec v1 vector | v1 <- matrix]\n\n    dotMatMat :{k1,k2,k3} (fin k1, fin k2, fin k3) =>\n        [k1][k2]Tq -> [k2][k3]Tq -> [k1][k3]Tq\n    dotMatMat matrix1 matrix2 = transpose [dotMatVec matrix1 vector | vector <- m']\n        where m' = transpose matrix2\n\nprivate submodule K_PKE where\n            type EncryptionKey = [384 * k + 32]Byte\n\n            type DecryptionKey = [384 * k]Byte\n\n            type Ciphertext = [32 * (d_u * k + d_v)]Byte\n\n    KeyGen: [32]Byte -> (EncryptionKey, DecryptionKey)\n    KeyGen d = (ekPKE, dkPKE) where\n                (\u03c1, \u03c3) = G (d # [`(k)])\n                A_hat = [[ SampleNTT (\u03c1 # [j] # [i])\n            | j <- [0 .. k-1]]\n            | i <- [0 .. k-1]]\n                s = [SamplePolyCBD`{eta_1} (PRF \u03c3 N)\n            | N <- [0 .. k-1]]\n                e = [SamplePolyCBD`{eta_1} (PRF \u03c3 N)\n            | N <- [k .. 2 * k - 1]]\n                s_hat = NTT_Vec s\n                e_hat = NTT_Vec e\n                t_hat = (dotMatVec A_hat s_hat) + e_hat\n                ekPKE = (ByteEncode12_Vec t_hat) # \u03c1\n                dkPKE = ByteEncode12_Vec s_hat\n\n    Encrypt : EncryptionKey -> [32]Byte -> [32]Byte -> Ciphertext\n    Encrypt ekPKE m r = c where\n                t_hat = ByteDecode12_Vec (ekPKE @@[0 .. 384*k - 1])\n                rho = ekPKE @@[384*k .. 384*k + 32 - 1]\n                A_hat = [[ SampleNTT (rho # [j] # [i])\n            | j <- [0 .. k-1]]\n            | i <- [0 .. k-1]]\n                y = [SamplePolyCBD`{eta_1} (PRF r N)\n            | N <- [0 .. k-1]]\n                e1 = [SamplePolyCBD`{eta_2} (PRF r N)\n            | N <- [k .. 2 * k - 1]]\n                                e2 = SamplePolyCBD`{eta_2} (PRF r (2 * `k))\n                y_hat = NTT_Vec y\n                u = NTTInv_Vec (dotMatVec (transpose A_hat) y_hat) + e1\n                mu = Decompress_Vec`{1} (ByteDecode`{1} m)\n                v = (NTTInv (dotVecVec t_hat y_hat)) + e2 + mu\n                c1 = ByteEncode_Vec`{d_u} (Compress_Mat`{d_u} u)\n                c2 = ByteEncode`{d_v} (Compress_Vec`{d_v} v)\n                c = c1 # c2\n\n    Decrypt : DecryptionKey -> Ciphertext -> [32]Byte\n    Decrypt dkPKE c = m where\n                c1 = c @@[0 .. 32 * d_u * k - 1]\n                c2 = c @@[32 * d_u * k .. 32 * (d_u * k + d_v) - 1]\n                u' = Decompress_Mat`{d_u} (ByteDecode_Vec`{d_u} c1)\n        \/\/ Step 4.\n        v' = Decompress_Vec`{d_v} (ByteDecode`{d_v} c2)\n                s_hat = ByteDecode12_Vec dkPKE\n                w = v' - NTTInv (dotVecVec s_hat (NTT_Vec u'))\n                m = ByteEncode`{1} (Compress_Vec`{1} w)\n\n    CorrectnessPKE : [32]Byte -> [32]Byte -> [32]Byte -> Bit\n    property CorrectnessPKE d m r = (m' == m) where\n        (pk, sk) = KeyGen d\n        c = Encrypt pk m r\n        m' = Decrypt sk c\n\nprivate\n\n    KeyGen_internal : [32]Byte -> [32]Byte\n        -> (EncapsulationKey, DecapsulationKey)\n    KeyGen_internal d z = (ek, dk) where\n      (ekPKE, dkPKE) = K_PKE::KeyGen d\n      ek = ekPKE\n      dk = dkPKE # ek # (H ek) # z\n\n    Encaps_internal : EncapsulationKey -> [32]Byte\n        -> (SharedSecretKey, Ciphertext)\n    Encaps_internal ek m = (K, c) where\n      (K, r) = G (m # (H ek))\n      c = K_PKE::Encrypt ek m r\n\n    Decaps_internal : DecapsulationKey -> Ciphertext -> SharedSecretKey\n    Decaps_internal dk c = K where\n                dkPKE = dk @@ [0 .. 384*k - 1]\n                ekPKE = dk @@ [384*k .. 768*k + 32 - 1]\n                h = dk @@ [768*k + 32 .. 768*k + 64 - 1]\n                z = dk @@ [768*k + 64 .. 768*k + 96 - 1]\n                m' = K_PKE::Decrypt dkPKE c\n        \/\/ Step 6.\n        (K', r') = G (m' # h)\n                Kbar = J (z # c)\n                c' = K_PKE::Encrypt ekPKE m' r'\n        \/\/ Step 9 - 11. If ciphertextx do not match, \"implicitly reject\".\n        K = if (c != c') then\n                Kbar\n            else\n                K'\n\n    \/**\n     * The ML-KEM scheme is correct with probability 1-delta and not 1. As a\n     * result, running `:prove CorrectnessPKE` will not succeed since there is a\n     * fraction delta of seeds `d`, `z`, `m` that do not work.\n     * Cryptol does not currently support counting.\n     * ```repl\n     * :set tests=3\n     * :check CorrectnessKEM\n     * ```\n     *\/\n    CorrectnessKEM : [32]Byte -> [32]Byte -> [32]Byte -> Bit\n    property CorrectnessKEM z d m = (K == K') where\n        (ek, dk) = KeyGen_internal d z\n        (K, c) = Encaps_internal ek m\n        K' = Decaps_internal dk c\n\n\/*\n * Type of an encapsulation key used in the public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 19.\n * See also the paragraph \"Terminology for keys\" in Section 3.2.\n *\/\ntype EncapsulationKey = [384 * k + 32]Byte\n\n\/*\n * Type of an decapsulation key used in the public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 19.\n * See also the paragraph \"Terminology for keys\" in Section 3.2.\n *\/\ntype DecapsulationKey = [768 * k + 96]Byte\n\n\/*\n * Type of the shared secret key material generated by the public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 20.\n * See also the paragraph \"Terminology for keys\" in Section 3.2.\n *\/\ntype SharedSecretKey = [32]Byte\n\n\/*\n * Type of the ciphertext generated by teh public ML-KEM API.\n * [FIPS-203], as in the output type in Algorithm 20.\n *\n * Usage: This ciphertext is only used in the context of ML-KEM, to derive a\n * shared secret key.\n *\/\ntype Ciphertext = [32 * (d_u * k + d_v)]Byte\n\n\/**\n * Generate an encapsulation key and a corresponding decapsulation key.\n * [FIPS-203] Section 7.1, Algorithm 19.\n *\n * This differs from the spec: it takes the randomness `d` and `z` as\n * parameters instead of generating them internally (because Cryptol\n * cannot generate randomness).\n *\n * The decapsulation key produced from this function MUST remain private. The\n * seed `(d, z)` produced (or in this case, passed as input) is sensitive data\n * and MUST be treated with the same safeguards as the decapsulation key.\n *\/\nKeyGen : Option ([32]Byte) -> Option ([32]Byte)\n    -> (EncapsulationKey, DecapsulationKey)\nKeyGen d z = (ek, dk) where\n    \/\/ Steps 1 and 2 are skipped because Cryptol cannot generate randomness.\n    \/\/ Step 3 - 5.\n    d' = case d of\n        None -> error \"Random bit generation failed; `d` not initialized.\"\n        Some _d -> _d\n    z' = case z of\n        None -> error \"Random bit generation failed; `z` not initialized.\"\n        Some _z -> _z\n    \/\/ Step 6.\n    (ek, dk) = KeyGen_internal d' z'\n\n\/**\n * Perform checks on a key pair.\n *\n * The security of ML-KEM depends on the use of key pairs that were correctly\n * generated using `KeyGen`!\n * This checking process _does not_ guarantee that the input pair is a properly\n * produced output of `KeyGen`. While these checks can detect certain\n * corruptions, they do not guarantee that the key pair was properly generated.\n *\/\nkeyPairCheck : EncapsulationKey\n    -> DecapsulationKey\n    -> Option ([32]Byte, [32]Byte)\n    -> [32]Byte\n    -> Bit\nkeyPairCheck ek dk maybe_seed m =\n    seedConsistency && encapsCheck && decapsCheck && pairwiseConsistency where\n    seedConsistency = case maybe_seed of\n        Some (d, z) -> KeyGen_internal d z == (ek, dk)\n        None -> True\n\n    encapsCheck = encapsulationKeyCheck ek\n    decapsCheck = decapsulationKeyCheck dk\n\n    pairwiseConsistency = K == K'\n    (K, c) = Encaps_internal ek m\n    K' = Decaps_internal dk c\n\n\/**\n * A properly produced output of the `KeyGen` function should always pass the\n * key pair checks.\n * ```repl\n * :set tests=3\n * :check KeyGenProducesValidKeys\n * ```\n *\/\nKeyGenProducesValidKeys d z m = keyPairCheck ek dk (Some (d, z)) m where\n    (ek, dk) = KeyGen (Some d) (Some z)\n\n\/**\n * Perform checks on a candidate encapsulation key.\n *\n * The type check is implicit; if this function compiles with a given `ek`,\n * then it must be of the correct type.\n *\n * This checking process _does not_ gurantee that `ek` is a properly produced\n * output of `KeyGen`.\n *\/\nencapsulationKeyCheck : EncapsulationKey -> Bool\nencapsulationKeyCheck ek = modulusCheck where\n    test = ByteEncode12_Vec (ByteDecode12_Vec (ek @@ [0..384 * k - 1]))\n    modulusCheck = test == (ek @@ [0..384 * k - 1])\n\n\/**\n * Use the encapsulation key to generate a shared secret an an associated\n * ciphertext.\n * [FIPS-203] Section 7.2, Algorithm 20.\n *\n * This differs from the spec: it takes the randomness `m` as a parameter\n * instead of generating it internally (because Cryptol cannot generate\n * randomness).\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f\n * The encapsulation key passed as a parameter MUST be checked before use with\n * `encapsulationKeyCheck`! The caller must have assurance that the\n * encapsulation key is valid.\n * This executable spec (and Cryptol in general) cannot enforce this\n * requirement! Implementors must check it manually.\n *\/\nEncaps : EncapsulationKey -> Option ([32]Byte) -> (SharedSecretKey, Ciphertext)\nEncaps ek m = (K, c) where\n    \/\/ Step 1 is skipped because Cryptol cannot generate randomness.\n    \/\/ Step 2 - 4.\n    m' = case m of\n        None -> error \"Random bit generation failed; `m` not initialized.\"\n        Some _m -> _m\n        (K, c) = Encaps_internal ek m'\n\n\/**\n * Perform three checks on candidate inputs to decapsulation.\n * [FIPS-203] Section 7.3 \"Decapsulation input check\" #1-3.\n *\n * The type checks are implicit; if this function compiles with a given `dk`\n * and `c`, then they must be of the correct type.\n *\n * This check _does not_ guarantee that `dk` is a propertly produced output\n * of `KeyGen`, or that `c` is a properly produced output of `Encaps`!\n *\/\ndecapsulationInputCheck : DecapsulationKey -> Ciphertext -> Bool\ndecapsulationInputCheck dk c = decapsulationKeyCheck dk\n\nprivate\n    \/**\n     * Perform a type check and a hash check on a candidate decapsulation key.\n     * [FIPS-203] Section 7.3 \"Decapsulation input check\" #2-3.\n     *\n     * The type check is implicit; if this function compiles with a given `dk`,\n     * then it must be the correct type.\n     *\n     * This check _does not_ guarantee that `dk` is a propertly produced output\n     * of `KeyGen`!\n     *\/\n    decapsulationKeyCheck : DecapsulationKey -> Bool\n    decapsulationKeyCheck dk = hash_check where\n        test = H (dk @@ [384*k .. 768*k + 32 - 1])\n        hash_check = test == (dk @@ [768*k + 32 .. 768*k + 64 - 1])\n\n\/**\n * Use the decapsulation key to produce a shared secret from a ciphertext.\n * [FIPS-203] Section 7.3, Algorithm 21.\n *\n * \u26a0\ufe0f Warning \u26a0\ufe0f\n * The decapsulation key and the ciphertext MUST be checked before use with\n * `decapsulationInputCheck`! The caller must have assurance that the\n * decapsulation key and ciphertext are valid.\n * This executable spec (and Cryptol in general) cannot enforce this\n * requirement! Implementors must check it manually.\n *\/\nDecaps : DecapsulationKey -> Ciphertext -> SharedSecretKey\nDecaps = Decaps_internal\n\nparameter\n    \/*\n     * The parameter `k` determines the dimensions of the encryption key matrix\n     * and the secret and noise vectors created and used in key generation and\n     * encryption.\n     * [FIPS-203] Section 8.\n     *\n     * The constraint on the width of `k` is drawn from `K-PKE-KeyGen`. In\n     * that function, the variable `N` varies from 0 to `2k` and is passed as\n     * the second parameter to the `PRF` function. `PRF` restricts the second\n     * parameter to be exactly 1 byte. Therefore, `2k` must fit into a byte.\n     * [FIPS-203] Section 5.1 Algorithm 13 (see lines 2 and 8-15) and Section\n     * 4.1 Equation 4.2.\n     *\/\n    type k : #\n    type constraint (width k > 0, width (2*k) <= 8)\n\n    \/*\n     * The parameter `eta_1` specifies the distribution from which the secret\n     * vectors are drawn in key generation and encryption.\n     * [FIPS-203] Section 8.\n     *\n     * eta_1 must be in the set {2, 3} for use in a PRF and to parameterize\n     * sampling from the centered binomial distribution.\n     * [FIPS-203] Section 4.1 \"Pseudorandom Function\" and Section 4.2.2\n     * \"Sampling from the centered binomial distribution\"\n     *\/\n    type eta_1 : #\n    type constraint (fin eta_1, 2 <= eta_1, eta_1 <= 3)\n\n    \/*\n     * The parameter eta_2 is required to specify the distribution from which\n     * the noise vectors are drawn in encryption.\n     * [FIPS-203] Section 8.\n     *\n     * eta_2 must be in the set {2, 3} for use in a PRF and to parameterize\n     * sampling from the centered binomial distribution.\n     * [FIPS-203] Section 4.1 \"Pseudorandom Function\" and Section 4.2.2\n     * \"Sampling from the centered binomial distribution\"\n     *\/\n    type eta_2 : #\n    type constraint (fin eta_2, 2 <= eta_2, eta_2 <= 3)\n\n    \/*\n     * The parameter `d_u` is a parameter and input for the compression and\n     * encoding functions.\n     * [FIPS-203] Section 8.\n     *\n     * For compression, `d_u` must be smaller than the bit length of `q` (fixed\n     * to 12).\n     * [FIPS-203] Section 4.2.1 \"Compression and decompression\".\n     * For encoding, the valid range of values for `d_u` is `1 \u2264 d_u \u2264 12`.\n     * [FIPS-203] Section 4.2.1 \"Encoding and decoding\".\n     *\/\n    type d_u : #\n    type constraint (fin d_u, d_u < 12, d_u > 0)\n\n    \/*\n     * The parameter `d_v` is a parameter and input for the compression and\n     * encoding functions.\n     * [FIPS-203] Section 8.\n     *\n     * For compression, `d_v` must be smaller than the bit length of `q` (fixed\n     * to 12).\n     * [FIPS-203] Section 4.2.1 \"Compression and decompression\".\n     * For encoding, the valid range of values for `d_v` is `1 \u2264 d_v \u2264 12`.\n     * [FIPS-203] Section 4.2.1 \"Encoding and decoding\".\n     *\/\n    type d_v : #\n    type constraint (fin d_v, d_v < 12, d_v > 0)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ECDH\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for an ECDH-based KEM module that defines SigningKey and VerifyingKey types, key validity and consistency predicates, and an ECC_CDH function that derives a shared secret from a signing key and verifying key using the EC interface."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::KEM::ECDH::Specification where\n\nimport Common::utils(ZtoBV)\n\nimport interface Common::EC::ECInterface as EC\n\ntype SigningKey = Z EC::n\n\ntype VerifyingKey = EC::Point\n\nsigningKeyValid : SigningKey -> Bool\nsigningKeyValid d = d != 0\n\nverifyingKeyFullyValid : VerifyingKey -> Bool\nverifyingKeyFullyValid Q = verifyingKeyPartiallyValid Q && correctOrder where\n    correctOrder = EC::isInfinity (EC::scmul `EC::n Q)\n\nverifyingKeyPartiallyValid : VerifyingKey -> Bool\nverifyingKeyPartiallyValid Q = EC::isValid Q && ~(EC::isInfinity Q)\n\nkeyPairIsConsistent : SigningKey -> VerifyingKey -> Bool\nkeyPairIsConsistent d Q = EC::pointEq expectedQ Q where\n    expectedQ = EC::scmul (fromZ d) EC::G\n\nECC_CDH : SigningKey -> VerifyingKey -> Option ([(width EC::n) \/^ 8][8])\nECC_CDH dA QB = maybe_Z where\n        P = EC::scmul EC::h (EC::scmul (fromZ dA) QB)\n    maybe_Z = case EC::xCoord P of\n                        None -> None\n                                Some z -> Some (split (ZtoBV z))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Instantiations\/ML_KEM512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write the Cryptol module Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM512 instantiating the ML-KEM (Kyber) specification with security parameters k=2, eta_1=3, eta_2=2, d_u=10, and d_v=4, matching the existing ML_KEM::Specification interface."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM512 =\n    Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\ntype k = 2\ntype eta_1 = 3\ntype eta_2 = 2\ntype d_u = 10\ntype d_v = 4\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Instantiations\/ML_KEM1024.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write the Cryptol specification for the ML-KEM1024 instantiation of ML-KEM, defining the parameter types k, eta_1, eta_2, d_u, and d_v and exposing the externally visible KEM interface (key generation, encapsulation, decapsulation) for this parameter set."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM1024 =\n    Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\ntype k = 4\ntype eta_1 = 2\ntype eta_2 = 2\ntype d_u = 11\ntype d_v = 5\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Asymmetric\/KEM\/ML_KEM\/Instantiations\/ML_KEM768.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM768` that instantiates the ML-KEM (Kyber) specification for the 768-parameter set, defining the type parameters `k`, `eta_1`, `eta_2`, `d_u`, and `d_v` with the given values."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::KEM::ML_KEM::Instantiations::ML_KEM768 =\n    Primitive::Asymmetric::KEM::ML_KEM::Specification where\n\ntype k = 3\ntype eta_1 = 2\ntype eta_2 = 2\ntype d_u = 10\ntype d_v = 4\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/ECInterface.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an interface module `Common::EC::ECInterface` specifying an abstract elliptic curve group with type `Point`, parameters `n`, `q`, `h`, generator `G`, and operations `isInfinity`, `isValid`, `pointEq`, `add`, `sub`, `double`, `scmul`, `twin_mul`, and `xCoord` with appropriate Cryptol types and constraints."},{"role":"assistant","content":"```cryptol\ninterface module Common::EC::ECInterface where\n\n    type Point : *\n\n    type n : #\n    type constraint (fin n, prime n, n >= 1)\n\n    type q : #\n    type constraint (fin q, q >= 1)\n\n    h : Integer\n\n    G : Point\n\n    isInfinity : Point -> Bool\n\n    isValid : Point -> Bool\n\n    pointEq : Point -> Point -> Bool\n\n    add : Point -> Point -> Point\n\n    sub : Point -> Point -> Point\n\n    double : Point -> Point\n\n    scmul : Integer -> Point -> Point\n\n    twin_mul : Integer -> Point -> Integer -> Point -> Point\n\n    xCoord: Point -> Option (Z q)\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/Curve25519.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing Curve25519\/X25519 (RFC 7748) over prime field p = 2^^255 - 19, including scalar\/coordinate decode\/encode, cswap, X25519 and X25519', DH_sender, DH_receiver, and all listed test\/proof properties (orderOk, decode\/encode properties, cswap properties, testVector1\/2, mcTv1\/2, bigOk, DHSharedSecret)."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::Curve25519 where\n\nimport Common::utils(ZtoBV, BVtoZ)\n\ntype p = 2^^255 - 19\n\ntype A = 486662\n\ntype order = 2^^252 + 27742317777372353535851937790883648493\n\nproperty orderOk = `order == order'\n    where\n        i = toInteger 0x14def9dea2f79cd65812631a5cf5d3ed\n        order' = 2^^252 + i\n\ntype Gu = 9\n\ntype Gv = 14781619447589544791020593568409986887264606134616475288964881837755586237401\n\ntype Bytes b = [b \/^ 8][8]\n\ntype constraint Fit b n = (b \/^ 8 <= n, fin b, fin n)\n\ndecodeLittleEndian : {bits, n} (Fit bits n) => [n][8] -> Z p\ndecodeLittleEndian x = fromInteger (sum iterates)\n    where\n        lshft y i = y * 256 ^^ i         iterates = [lshft (toInteger b) i | b <- x | i <- [0..bits \/^ 8]]\n\nproperty decodeTest = decodeLittleEndian `{88} \"hello world\" == x\n    where\n        x = 121404708502361365413651816\n\ndecodeUCoordinate : {bits, n} (Fit bits n, bits >= 1) => [n][8] -> Z p\ndecodeUCoordinate u_list = decodeLittleEndian `{bits} u_list''\n    where\n        mask = (1 << (`bits % 8)) - 1 : [8]\n        type m = bits \/^ 8\n        u_list' = take `{m} u_list\n        l = `m - 1\n        u_list'' = if `bits % 8 != 0\n                then update u_list' l (last u_list' && mask)\n                else u_list'\n\nencodeUCoordinate : {bits, n} (Fit bits n, bits >= 1) => Z p -> [n][8]\nencodeUCoordinate u = reverse (split (ZtoBV u))\n\nencodePartiallyInvertsDecode : [32][8] -> Bit\nproperty encodePartiallyInvertsDecode x = ~((x ! 0) @ 0) ==>\n    encodeUCoordinate `{255} (decodeUCoordinate `{255} x) == x\n\ndecodeInvertsEncode : Z p -> Bit\nproperty decodeInvertsEncode x =\n    decodeUCoordinate `{255} (encodeUCoordinate `{255, 32} x) == x\n\nproperty decodeUCoordinateTest = decodeUCoordinate `{6} \"hello world\" == x\n    where\n        x = 40\n\ndecodeScalar25519 : [32][8] -> Z p\ndecodeScalar25519 k0 = decodeLittleEndian `{255} k3\n    where\n        k1 = update k0 0 ((k0@0) && 248)\n        k2 = update k1 31 ((k1@31) && 127)\n        k3 = update k2 31 ((k2@31) || 64)\n\nproperty decodeScalarOk = decodeScalar25519 (repeat 0x61) == x\n    where\n        x = 44046402572626160612103472728795008085361523578694645928734845681441465000288\n\nX25519 : [32][8] -> [32][8] -> [32][8]\nX25519 kb ub = result\n    where\n                a24 = 121665\n                        k = ZtoBV (decodeScalar25519 kb)\n        u = decodeUCoordinate `{255} ub\n                loop (x1, x2, z2, x3, z3, swap) t = (x1', x2', z2', x3', z3', swap')\n            where\n                k_t = (k >> t) && 1\n                swapt = swap ^ k_t\n                (x2s, x3s) = cswap' swapt (x2, x3)\n                (z2s, z3s) = cswap' swapt (z2, z3)\n                swap' = zext [k_t ! 0]\n\n                A = x2s + z2s\n                AA = A^^2\n                B = x2s - z2s\n                BB = B^^2\n                E = AA - BB\n                C = x3s + z3s\n                D = x3s - z3s\n                DA = D * A\n                CB = C * B\n                x1' = x1\n                x3' = (DA + CB) ^^ 2\n                z3' = x1 * (DA - CB) ^^ 2\n                x2' = AA * BB\n                z2' = E * (AA + a24 * E)\n\n                (x1l, x2l, z2l, x3l, z3l, swapl) = foldl loop (u, 1 : Z p, 0 : Z p, u, 1 : Z p, 0 : [255]) (reverse [0..255-1])\n\n                (x2ls, x3ls) = cswap' swapl (x2l, x3l)\n        (z2ls, z3ls) = cswap' swapl (z2l, z3l)\n\n                rzp = x2ls * (z2ls ^^ `(p - 2))\n\n                result = encodeUCoordinate `{255, 32} rzp\n\ncswap : [255] -> (Z p, Z p) -> (Z p, Z p)\ncswap swap (x, y) = (BVtoZ `{p} (dummy ^ x_2), BVtoZ `{p} (dummy ^ x_3))\n    where\n        mask : [255] -> [255]\n        mask z = 0 - z\n\n        (x_2, x_3) = (ZtoBV x, ZtoBV y)\n        dummy = mask swap && (x_2 ^ x_3)\n\ncswap' : [255] -> (Z p, Z p) -> (Z p, Z p)\ncswap' swap (x, y) = if swap == 0 then (x, y) else (y, x)\n\ncswapEq s x = elem s [0, 1] ==> cswap s x == cswap' s x\n\n\/**\n * `cswap False` is the identity.\n *\n * ```repl\n * :check cswapFalse\n * ```\n *\/\nproperty cswapFalse x = cswap 0 x == x\n\n\/**\n * `cswap True` is an involution.\n *\n * ```repl\n * :check cswapTrue\n * ```\n *\/\nproperty cswapTrue y x = y > 0 ==> cswap y (cswap y x) == x\n\n\/**\n * Test vector from section 5.2.\n *\n * ```repl\n * :prove testVector1\n * ```\n *\n * Reference:\n * [rfc7748] Section 5.2.\n *\/\nproperty testVector1 = X25519 k u == u'\n    where\n        k = split 0xa546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4\n        u = split 0xe6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c\n        u' = split 0xc3da55379de9c6908e94ea4df28d084f32eccf03491c71f754b4075577a28552\n\n\/**\n * Test vector from Section 5.2.\n *\n * ```repl\n * :prove testVector2\n * ```\n *\n * Reference:\n * [rfc7748] Section 5.2.\n *\/\nproperty testVector2 = X25519 k u == u'\n    where\n        k = split 0x4b66e9d4d1b4673c5ad22691957d6af5c11b6421e0ea01d42ca4169e7918ba0d\n        u = split 0xe5210f12786811d3f4b7959d0538ae2c31dbe7106fc03c3efc4cd549c715a493\n        u' = split 0x95cbde9476e8907d7aade45cb4b873f88b595a68799fa152e6f8f7647aac7957\n\n\/**\n * Iterative testing.\n *\/\niterTest : {n} (fin n) => [32][8] -> [32][8] -> [32][8]\niterTest k u\n    | n == 0 => k\n    | n >= 1 => iterTest `{n-1} (X25519 k u) k\n\n\/**\n * An \"iterative\" test vector.\n *\n * ```repl\n * :prove mcTv1\n * ```\n *\/\nproperty mcTv1 = iterTest `{1} k u == r\n    where\n        k = split 0x0900000000000000000000000000000000000000000000000000000000000000\n        u = k\n        r = split 0x422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079\n\n\/**\n * An \"iterative\" test vector.\n *\n * ```repl\n * :prove mcTv2\n * ```\n *\/\nproperty mcTv2 = iterTest `{1000} k u == r\n    where\n        k = split 0x0900000000000000000000000000000000000000000000000000000000000000\n        u = k\n        r = split 0x684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51\n\n\/*\n * Cryptol is too slow to efficiently\n * execute the \"iterative\" test vector\n * for a million iterations.\n *\n * We include the test vector for\n * documentary purposes, and omit the\n * property keyword so it is not executed\n * by `check`, `prove`, etc...\n *\/\nmcTv3 = iterTest `{1000} k u == r\n    where\n        k = split 0x0900000000000000000000000000000000000000000000000000000000000000\n        u = k\n        r = split 0x7c3911e0ab2586fd864497297e575e6f3bc601c0883c30df5f4dd2d24f665424\n\/**\n * Cryptol uses a big-endian convention when\n * using intrinsics such as `toInteger`.\n * This version of X25519 assumes that the byte-arrays\n * are big-endian, and converts the arguments\n * to little endian.\n *\/\nX25519' k u = reverse (X25519 k' u')\n    where\n        k' = reverse k\n        u' = reverse u\n\nproperty bigOk k u = reverse (X25519 (reverse k) (reverse u)) == X25519' k u\n\n\/**\n * Generate the public key `X25519(a, 9)` where\n * `9` is the `u` coordinate of the base point\n * and `a` is the secret value.\n *\n * Reference:\n * [rfc7748] Section 6.1.\n *\n * ```repl\n * let a = split `{32} 0x77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a\n * let b = split `{32} 0x5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb\n * let Ga = split `{32} 0x8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a\n * let Gb = split `{32} 0xde9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f\n * let K = split `{32} 0x4a5d9d5ba4ce2de1728e3bf480350f25e07e21c947d19e3376f09b3c1e161742\n * :prove DH_sender a == Ga\n * :prove DH_sender b == Gb\n * :prove X25519 a Gb == K\n * :prove X25519 b Ga == K\n * ```\n *\/\nDH_sender : [32][8] -> [32][8]\nDH_sender a = X25519 a (reverse (split Gu'))\n    where\n                                Gu' = (fromInteger `Gu) : [32 * 8]\n\n\/**\n * Generate the shared value `K` given the received value `Gr`\n * and the secret `a`.\n *\/\nDH_receiver : [32][8] -> [32][8] -> [32][8]\nDH_receiver a Gr = X25519 a Gr\n\n\/**\n * Diffie-Hellman produces a shared secret.\n *\n * ```repl\n * :check DHSharedSecret\n * ```\n *\/\nproperty DHSharedSecret a b = DH_receiver a Gb == DH_receiver b Ga\n    where\n        Ga = DH_sender a\n        Gb = DH_sender b\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/PFEC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify a Cryptol module implementing prime-field short-Weierstrass elliptic-curve arithmetic (affine and projective), including scalar and twin multiplication, and properties proving group closure, correct behavior at infinity, affine\/projective equivalence, curve coefficient validity, base-point order, and correctness of twin multiplication."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::PFEC where\n\nimport Common::utils(half, mul2, mul3, mul4, mul8, ZtoBV)\n\nparameter\n\n    type P : #\n    type constraint (fin P, prime P, P >= 5, P % 2 == 1, P % 3 != 0)\n\n    type n' : #\n    type constraint (fin n', prime n', n' < P)\n\n    b : Z P\n\n    Gx : Z P\n    Gy : Z P\n\ntype n = n'\n\n\/**\n * Modulus of the field over which the curve is defined.\n *\n * This is called `q` for the `ECInterface`, which is designed to support\n * curves that are not necessarily over prime order fields.\n *\/\ntype q = P\n\n\/**\n * Coefficient that defines the curve.\n * For a curve in short-Weierstrass form, the equation is\n * `y^2 = x^3 + ax + b`.\n * See the `curveCoefficientsAreValid` property.\n * [SP-800-186] Section 2.1.1.\n *\n * Due to restrictions on the underlying elliptic curve operations, the\n * a-coordinate must be -3. This is the case for all NIST-standardized\n * prime order fields in short-Weierstrass form.\n *\/\nprivate a = -3 : Z P\n\n\/**\n * Cofactor for the curve.\n *\n * The order of the curve is defined as `h * n`, where `h` is small\n * and `n`, the order of the base point `G`, is prime. If `h` is not\n * 1, then the base point does not generate the entire curve.\n *\n * This is fixed to 1 for all the NIST-standardized prime order fields\n * in short-Weierstrass form. It's not necessarily true for all reasonable\n * elliptic curves.\n *\/\nh = 1 : Integer\n\nenum Point = Infinity | Affine (Z P) (Z P)\n\naffineEq : Point -> Point -> Bool\naffineEq p1 p2 = case p1 of\n    Infinity -> case p2 of\n        Infinity -> True\n        _ -> False\n    Affine x y -> case p2 of\n        Affine x' y' -> (x == x') && (y == y')\n        _ -> False\n\npointEq = affineEq\n\nisValid : Point -> Bit\nisValid point = case point of\n    Infinity -> True\n    Affine x y -> (y ^^ 2 == x ^^ 3 + a * x + b)\n\nisInfinity : Point -> Bool\nisInfinity point = case point of\n    Infinity -> True\n    _ -> False\n\nG = Affine Gx Gy : Point\n\nproperty curveCoefficientsAreValid = (4 * a^^3 + _27 * b^^2 != 0)\n    where\n        _27 : Z P\n        _27 = fromInteger 27\n\nproperty gOrderIsN = affineEq G ((`n + 1) ~* G)\n\nproperty gIsValid = isValid G\n\nadd : Point -> Point -> Point\nadd p1 p2 = to_affine (ec_full_add (to_projective p1) (to_projective p2))\n\nproperty addIsClosed k1 k2 = isValid (add p1 p2)\n    where\n        p1 = validPointFromK k1\n        p2 = validPointFromK k2\n\ndouble : Point -> Point\ndouble p = to_affine (ec_double (to_projective p))\n\nproperty doubleIsClosed k = isValid (double p)\n    where\n        p = validPointFromK k\n\nsub : Point -> Point -> Point\nsub p1 p2 = to_affine (ec_full_sub (to_projective p1) (to_projective p2))\n\nproperty subIsClosed k1 k2 = isValid (sub p1 p2)\n    where\n        p1 = validPointFromK k1\n        p2 = validPointFromK k2\n\nscmul : Integer -> Point -> Point\nscmul k p = to_affine (ec_mult (fromInteger k) (to_projective p))\n\n(~*) = scmul  \n\nproperty scmulIsClosed m = isValid (m ~* G)\n\nproperty scmul_commutes m m' = affineEq (m ~* (m' ~* G)) (m' ~* (m ~* G))\n\n\/**\n * Compute twin multiplication.\n *\/\ntwin_mul : Integer -> Point -> Integer -> Point -> Point\ntwin_mul c P d Q = to_affine (ec_twin_mult c' P' d' Q')\n    where\n        [c', d'] = [fromInteger   x | x <- [c, d]]\n        [P', Q'] = [to_projective p | p <- [P, Q]]\n\n\/**\n * Extract the x-coordinate `Z P` value, if the point is not the point at\n * infinity.\n *\/\nxCoord: Point -> Option (Z P)\nxCoord p = case p of\n    Infinity -> None\n    Affine x _ -> Some x\n\nprivate\n    type ProjectivePoint = { x : Z P, y : Z P, z : Z P }\n    InfinityProjective = { x=1, y=1, z=0 }\n    Zero = { x=0, y=0, z=0 }\n\n    \/**\n     * Convert from an affine to a projective representation.\n     * [MATH-2008] Routine 2.2.1.\n     *\/\n    to_projective : Point -> ProjectivePoint\n    to_projective p = case p of\n        Infinity -> InfinityProjective\n        Affine x y -> { x=x, y=y, z=1 }\n\n    \/**\n     * Convert from a projective to an affine representation.\n     * [MATH-2008] Routine 2.2.2.\n     *\/\n    to_affine : ProjectivePoint -> Point\n    to_affine p =\n        \/\/ The point at infinity does not have an affine representation.\n        if p.z == 0 then Infinity\n        \/\/ Note the parentheses here.\n        \/\/ See Note [Limit scope of recip in where clauses].\n        else (Affine (lambda ^^2 * p.x) (lambda ^^3 * p.y)\n               where\n                 lambda = recip p.z)\n\n    \/\/ The twin affine function depends on the set of four points: two\n    \/\/ arbitrary points S and T, their sum SpT, and their difference SmT.\n    type TwinPoints = {\n        A: ProjectivePoint,\n        B: ProjectivePoint,\n        C: ProjectivePoint,\n        D: ProjectivePoint\n    }\n    \/**\n     * Optimized routine to affinify and projectify four points at once\n     * (or do nothing, if any of the points are the point at infinity).\n     *\n     * This optimization is designed for use in `ec_twin_mult` and should not\n     * be used in other settings without checking that its behavior is suitable.\n     * [MATH-2008] Section 2.2, Note 8.\n     *\/\n    twin_normalize: TwinPoints -> TwinPoints\n    twin_normalize { A=A, B=B, C=C, D=D } =\n        \/\/ We can't compute twin normalization on the point at infinity\n                        if (A.z == 0) || (B.z == 0) || (C.z == 0) || (D.z == 0) then\n            { A=A, B=B, C=C, D=D }\n        else\n                              ({\n             A = normalize_from_inv A a_inv,\n             B = normalize_from_inv B b_inv,\n             C = normalize_from_inv C c_inv,\n             D = normalize_from_inv D d_inv\n           } where\n               ab = A.z * B.z\n               cd = C.z * D.z\n               abc = ab * C.z\n               abd = ab * D.z\n               acd = A.z * cd\n               bcd = B.z * cd\n               abcd = ab * cd\n               e = recip abcd\n               a_inv = e * bcd\n               b_inv = e * acd\n               c_inv = e * abd\n               d_inv = e * abc\n               normalize_from_inv p inv =\n                   to_projective (Affine (inv ^^2 * p.x) (inv ^^3 * p.y)))\n\n    property normalizeWorksOnNormalPoints k1 k2 k3 k4 = all_are_normal && all_match\n        where\n            p1 = to_projective (validPointFromK k1)\n            p2 = to_projective (validPointFromK k2)\n            p3 = to_projective (validPointFromK k3)\n            p4 = to_projective (validPointFromK k4)\n\n            input = {A=p1, B=p2, C=p3, D=p4}\n            out = twin_normalize input\n\n                                                any_are_infinity = any (\\k -> k == 0) [k1, k2, k3, k4]\n\n                                                all_are_normal = any_are_infinity ||\n                all (\\p -> p.z == 1) [out.A, out.B, out.C, out.D]\n\n                                    all_match = (out.A == p1) && (out.B == p2)\n                && (out.C == p3) && (out.D == p4)\n\n    ec_double : ProjectivePoint -> ProjectivePoint\n    ec_double S =\n      if S.z == 0 then InfinityProjective \n      else {x = r18, y = r23, z = r13}\n      where\n          r7  = S.z ^^ 2                \n          r8  = S.x - r7                \n          r9  = S.x + r7                \n          r10 = r9 * r8                 \n          r11 = mul3 r10                \n          r12 = S.z * S.y               \n          r13 = mul2 r12                \n          r14 = S.y ^^ 2                \n          r15 = S.x * r14               \n          r16 = mul4 r15                \n          r17 = r11 ^^ 2                \n          r18 = r17 - (mul2 r16)        \n          r19 = r14 ^^ 2                \n          r20 = mul8 r19                \n          r21 = r16 - r18               \n          r22 = r11 * r21               \n          r23 = r22 - r20               \n\n    ec_add : ProjectivePoint -> ProjectivePoint -> ProjectivePoint\n    ec_add S T =\n        if r13 == 0 then\n            if r14 == 0 then Zero       \n            else InfinityProjective     \n        else\n            {x = r32, y = r37, z = r27} \n        where\n            (t1, t2, t3, t4, t5, t6) = if T.z == 1 then\n                                (S.x, S.y, S.z, T.x, T.y, T.z)\n                else (r5, r7, S.z, T.x, T.y, r3)\n\n            r3 = T.z                \n            r4 = r3 ^^ 2            \n            r5 = S.x * r4           \n            r6 = r3 * r4            \n            r7 = S.y * r6           \n\n            r9  = t3 ^^ 2           \n            r10 = t4 * r9           \n            r11 = t3 * r9           \n            r12 = t5 * r11          \n            r13 = t1 - r10          \n            r14 = t2 - r12          \n\n            r22 = mul2 t1 - r13     \n            r23 = mul2 t2 - r14     \n\n            r25 = t3 * t6           \n\n            r27 = r25 * r13          \n            r28 = r13 ^^ 2           \n            r29 = r13 * r28          \n            r30 = r22 * r28          \n            r31 = r14 ^^ 2           \n            r32 = r31 - r30          \n            r33 = r30 - (mul2 r32)   \n            r34 = r14 * r33          \n            r35 = r23 * r29          \n            r36 = r34 - r35          \n            r37 = half r36           \n\n    ec_full_add : ProjectivePoint -> ProjectivePoint -> ProjectivePoint\n    ec_full_add S T =\n        if S.z == 0 then T\n        | T.z == 0 then S\n        | R == {x = 0, y = 0, z = 0} then ec_double S\n        else R\n        where R = ec_add S T\n\n    ec_full_sub : ProjectivePoint -> ProjectivePoint -> ProjectivePoint\n    ec_full_sub S T = R\n        where\n            U = {x = T.x, y = -T.y, z = T.z}\n            R = ec_full_add S U\n\n    ec_mult : Z P -> ProjectivePoint -> ProjectivePoint\n    ec_mult d S =\n        if d == 0 then to_projective Infinity\n        | d == 1 then S\n        | S.z == 0 then to_projective Infinity\n        else Rs ! 1 \n        where\n            S' = if S.z != 1 then to_projective (to_affine S) else S\n            \/\/ Get bits of `d` and `3d`. The width of `ks` is set to be large\n            \/\/ enough to hold the full width of `hs`.\n            ks = ZtoBV d : [width P + 2]\n            hs = 3 * ks\n\n            \/\/ The specified routine initializes R = S and skips the first\n            \/\/ high-bit of `hs`, assuming that it's 1. Since we're a little\n            \/\/ floppy with our bitwise conversion, we'll start at 0 and\n                        Rs = [ InfinityProjective ] #\n                [ if hi && ~ki then ec_full_add doubleR S\n                  | ~hi && ki then ec_full_sub doubleR S\n                  else doubleR\n                  where doubleR = ec_double Ri\n                | ki <- ks | hi <- hs | Ri <- Rs ]\n\n    affine_add : Point -> Point -> Point\n    affine_add point1 point2 = case point1 of\n        Infinity -> point2\n        Affine x1 y1 -> case point2 of\n            Infinity -> point1\n            Affine x2 y2 -> if (x1 == x2) && (y1 == -y2) then Infinity\n                else Affine x y\n                where                      x = lambda ^^ 2 - x1 - x2\n                    y = lambda * (x1 - x) - y1\n                    lambda = if x1 == x2 then (3 * x1 ^^ 2 + a) %\/ (2 * y1)\n                        else (y2 - y1) %\/ (x2 - x1)\n\n    validPointFromK : Z n' -> Point\n    validPointFromK k = to_affine (ec_mult _k (to_projective G))\n        where\n            _k : Z P\n            _k = fromInteger (fromZ k)\n\n    \/**\n     * Proof that the affine and projective versions of addition are equivalent.\n     * This doesn't test the point at infinity.\n     *\n     * ```repl\n     * :check addsAreEquivalent\n     * ```\n     *\/\n    addsAreEquivalent : Z n' -> Z n' -> Bool\n    property addsAreEquivalent k1 k2 =\n        affineEq (affine_add p1 p2) (to_affine full_sum)\n        where\n            p1 = validPointFromK k1\n            p2 = validPointFromK k2\n            full_sum = ec_full_add (to_projective p1) (to_projective p2)\n\n    addsBehaveCorrectlyAtInfinity : Z n' -> Bool\n    property addsBehaveCorrectlyAtInfinity k =\n        oo && ok && ko && oo' && ok' && ko'\n        where\n                        point = validPointFromK k\n            oo = affineEq Infinity (affine_add Infinity Infinity)\n            ok = affineEq point (affine_add Infinity point)\n            ko = affineEq point (affine_add point Infinity)\n\n                        point' = to_projective point\n            oo' = InfinityProjective ==\n                ec_full_add InfinityProjective InfinityProjective\n            ok' = point' == ec_full_add InfinityProjective point'\n            ko' = point' == ec_full_add point' InfinityProjective\n\n    ec_twin_mult : Z P -> ProjectivePoint -> Z P -> ProjectivePoint -> ProjectivePoint\n    ec_twin_mult d0 S d1 T = (states!0).0\n        where\n            SpT = ec_full_add S T                      \n            SmT = ec_full_sub S T                      \n                                                { A=S', B=T', C=SpT', D=SmT' } =\n                twin_normalize { A=S, B=T, C=SpT, D=SmT }\n            e0s = ZtoBV d0 : [max 4 (width P)]         \n            e1s = ZtoBV d1 : [max 4 (width P)]         \n            c   = [[False, False] # take e0s,          \n                   [False, False] # take e1s] : [2][6]\n            states = [(InfinityProjective, c)] #       \n                [ (Rk', [c0', c1'])\n                    where\n                    \/\/ Lines 8-13.\n                    \/\/ `tail ci` uses Cryptol's built-in bit vector\n                                        h0 = if c0@0 then 31 - tail c0 else tail c0\n                    h1 = if c1@0 then 31 - tail c1 else tail c1\n                                        u0 = if h0 < (F h1) then 0 else if c0@0 then -1 else 1 : [2]\n                    u1 = if h1 < (F h0) then 0 else if c1@0 then -1 else 1 : [2]\n                                                            c0' = [(u0!=0) ^ c0@1] # drop c0 # [e0k]\n                    c1' = [(u1!=0) ^ c1@1] # drop c1 # [e1k]\n                                        RkDouble = ec_double Rk\n                                        Rk' = if (u0 == -1) && (u1 == -1) then\n                            ec_full_sub RkDouble SpT'\n                        | (u0 == -1) && (u1 ==  0) then ec_full_sub RkDouble S'\n                        | (u0 == -1) && (u1 ==  1) then\n                            ec_full_sub RkDouble SmT'\n                        | (u0 ==  0) && (u1 == -1) then ec_full_sub RkDouble T'\n                        | (u0 ==  0) && (u1 ==  1) then ec_full_add RkDouble T'\n                        | (u0 ==  1) && (u1 == -1) then\n                            ec_full_add RkDouble SmT'\n                        | (u0 ==  1) && (u1 ==  0) then ec_full_add RkDouble S'\n                        | (u0 ==  1) && (u1 ==  1) then\n                            ec_full_add RkDouble SpT'\n                        else RkDouble\n                | (Rk, [c0, c1]) <- states\n                \/\/ Line 7: Iterate through the eis, after dropping the four\n                \/\/ bits we already used to initialize `c` and padding with 0.\n                | e0k <- drop`{4} e0s # (zero : [5])\n                | e1k <- drop`{4} e1s # (zero : [5]) ]\n\n            \/\/ An auxiliary routine.\n            \/\/ [MATH-2008] Routine 2.2.11.\n            F : [5] -> [5]\n            F t = if (18 <= t) && (t < 22) then 9\n                | (14 <= t) && (t < 18) then 10\n                | (22 <= t) && (t < 24) then 11\n                | (4 <= t)  && (t < 12) then 14\n                else 12\n\n    \/**\n     * Checks that twin multiplication works as expected. Note that a given\n     * point can have multiple projective representations, so we have to\n     * check equality in the affine representation.\n     *\n     * These tests check the general case, the case where the two points `S`\n     * and `T` are the same, and the case where one of the points is the point\n     * at infinity.\n     * ```repl\n     * :check twin_mult_works\n     * :check (\\d0 d1 k -> twin_mult_works d0 k d1 k)\n     * :check (\\d0 d1 k -> twin_mult_works d0 k d1 0)\n     * :check (\\d0 d1 k -> twin_mult_works d0 0 d1 k)\n     * ```\n     *\/\n    property twin_mult_works d0 k0 d1 k1 = affineEq R_plain R_twin\n        where\n            S = to_projective (validPointFromK k0)\n            T = to_projective (validPointFromK k1)\n            R_plain = to_affine (ec_full_add (ec_mult d0 S) (ec_mult d1 T))\n            R_twin = to_affine (ec_twin_mult d0 S d1 T)\n\n    \/**\n    * Calulate x \/ y in a field.\n    * ```repl\n    * :prove  2 %\/ 2 == (1 : Z 3)\n    * ```\n    *\/\n    (%\/) : {a} (Field a) => a -> a -> a\n    (%\/) x y = x * recip y\n\n\/*\nNote [Limit scope of recip in where clauses]\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nThere are a small number of places where we call the `recip` function in a\nlocal definition bound by a `where` clause such that the definition is only ever\nused in the `else` branch of an if-expression. For example, in `to_affine` we\nhave:\n\n  to_affine p =\n      if p.z == 0 then Infinity\n      \/\/ Note the explicit parentheses here, which ensures that `lambda` is in\n      \/\/ scope in the `else` branch but *not* the `then` branch.\n      else (Affine (lambda ^^2 * p.x) (lambda ^^3 * p.y)\n             where\n               lambda = recip p.z)\n\nDoing so is not strictly necessary in Cryptol, as Cryptol's lazy evaluation\nwill only evaluate `lambda` if the `else` branch is evaluated. This is solely\ndone for the benefit of compiling to call-by-value languages (e.g., C or Rust),\nas evaluating `lambda` before the `if`-expression would result in a panic when\n`p.z == 0`.\n*\/\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Tests\/P256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that test the NIST P-256 elliptic curve implementation by checking that given affine points S and T are valid and that add, sub, double, scalar multiplication, and twin multiplication produce specified expected results."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Tests::P256 where\nimport Common::EC::PrimeField::Instantiations::P256 as P256\nimport Common::utils(BVtoZ)\n\nS = P256::Affine (BVtoZ 0xde2444bebc8d36e682edd27e0f271508617519b3221a8fa0b77cab3989da97c9)\n     (BVtoZ 0xc093ae7ff36e5380fc01a5aad1e66659702de80f53cec576b6350b243042a256)\n\nT = P256::Affine (BVtoZ 0x55a8b00f8da1d44e62f6b3b25316212e39540dc861c89575bb8cf92e35e0986b)\n     (BVtoZ 0x5421c3209c2d6c704835d82ac4c3dd90f61a8a52598b9e7ab656e9d8c8b24316)\n\nproperty sAndTAreValid = P256::isValid S && P256::isValid T\n\nproperty additionVectorPasses = P256::affineEq (P256::add S T) R\n  where R = P256::Affine (BVtoZ 0x72b13dd4354b6b81745195e98cc5ba6970349191ac476bd4553cf35a545a067e)\n             (BVtoZ 0x8d585cbb2e1327d75241a8a122d7620dc33b13315aa5c9d46d013011744ac264)\n\nproperty subtractionVectorPasses = P256::affineEq (P256::sub S T) R\n  where R = P256::Affine (BVtoZ 0xc09ce680b251bb1d2aad1dbf6129deab837419f8f1c73ea13e7dc64ad6be6021)\n             (BVtoZ 0x1a815bf700bd88336b2f9bad4edab1723414a022fdf6c3f4ce30675fb1975ef3)\n\nproperty doubleVectorPasses = P256::affineEq (P256::double S) R\n  where R = P256::Affine (BVtoZ 0x7669e6901606ee3ba1a8eef1e0024c33df6c22f3b17481b82a860ffcdb6127b0)\n             (BVtoZ 0xfa878162187a54f6c39f6ee0072f33de389ef3eecd03023de10ca2c1db61d0c7)\n\nproperty scalarMultVectorPasses = P256::affineEq (P256::scmul d S) R\n  where d = toInteger 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        R = P256::Affine (BVtoZ 0x51d08d5f2d4278882946d88d83c97d11e62becc3cfc18bedacc89ba34eeca03f)\n             (BVtoZ 0x75ee68eb8bf626aa5b673ab51f6e744e06f8fcf8a6c0cf3035beca956a7b41d5)\n\nproperty twinMultVectorPasses =\n  P256::affineEq R (P256::twin_mul d S e T)\n  where d = toInteger 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        e = toInteger 0xd37f628ece72a462f0145cbefe3f0b355ee8332d37acdd83a358016aea029db7\n        R = P256::Affine (BVtoZ 0xd867b4679221009234939221b8046245efcf58413daacbeff857b8588341f6b8)\n            (BVtoZ 0xf2504055c03cede12d22720dad69c745106b6607ec7e50dd35d54bd80f615275)\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Tests\/P192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the module Common::EC::PrimeField::Tests::P192 with constants S and T and properties checking point validity, affine addition, subtraction, doubling, scalar multiplication, and twin multiplication over the P-192 elliptic curve implementation P192::Affine, matching the given test vectors."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Tests::P192 where\nimport Common::EC::PrimeField::Instantiations::P192 as P192\nimport Common::utils(BVtoZ)\n\nS = P192::Affine (BVtoZ 0xd458e7d127ae671b0c330266d246769353a012073e97acf8)\n     (BVtoZ 0x325930500d851f336bddc050cf7fb11b5673a1645086df3b)\n\nT = P192::Affine (BVtoZ 0xf22c4395213e9ebe67ddecdd87fdbd01be16fb059b9753a4)\n     (BVtoZ 0x264424096af2b3597796db48f8dfb41fa9cecc97691a9c79)\n\nproperty sAndTAreValid = P192::isValid S && P192::isValid T\n\nproperty additionVectorPasses = P192::affineEq (P192::add S T) R\n  where R = P192::Affine (BVtoZ 0x48e1e4096b9b8e5ca9d0f1f077b8abf58e843894de4d0290)\n             (BVtoZ 0x408fa77c797cd7dbfb16aa48a3648d3d63c94117d7b6aa4b)\n\nproperty subtractionVectorPasses = P192::affineEq (P192::sub S T) R\n  where R = P192::Affine (BVtoZ 0xfc9683cc5abfb4fe0cc8cc3bc9f61eabc4688f11e9f64a2e)\n             (BVtoZ 0x093e31d00fb78269732b1bd2a73c23cdd31745d0523d816b)\n\nproperty doubleVectorPasses = P192::affineEq (P192::double S) R\n  where R = P192::Affine (BVtoZ 0x30c5bc6b8c7da25354b373dc14dd8a0eba42d25a3f6e6962)\n             (BVtoZ 0x0dde14bc4249a721c407aedbf011e2ddbbcb2968c9d889cf)\n\nproperty scalarMultVectorPasses = P192::affineEq (P192::scmul d S) R\n  where d = toInteger 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        R = P192::Affine (BVtoZ 0x1faee4205a4f669d2d0a8f25e3bcec9a62a6952965bf6d31)\n             (BVtoZ 0x5ff2cdfa508a2581892367087c696f179e7a4d7e8260fb06)\n\nproperty scalarMultVectorPasses2 = P192::affineEq (P192::scmul d S') R\n    where\n        S' = P192::Affine (BVtoZ 0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012)\n            (BVtoZ 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811)\n        d = toInteger 0xe14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3\n        R = P192::Affine (BVtoZ 0x07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6)\n            (BVtoZ 0x76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477)\n\nproperty twinMultVectorPasses =\n  P192::affineEq R (P192::twin_mul d S e T)\n  where d = toInteger 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        e = toInteger 0xc4be3d53ec3089e71e4de8ceab7cce889bc393cd85b972bc\n        R = P192::Affine (BVtoZ 0x019f64eed8fa9b72b7dfea82c17c9bfa60ecb9e1778b5bde)\n            (BVtoZ 0x16590c5fcd8655fa4ced33fb800e2a7e3c61f35d83503644)\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Tests\/P224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Common::EC::PrimeField::Tests::P224` that defines points S and T on the NIST P-224 curve and properties checking they are valid and that add, sub, double, scmul, and twin_mul produce the given affine test vectors."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Tests::P224 where\nimport Common::EC::PrimeField::Instantiations::P224 as P224\nimport Common::utils(BVtoZ)\n\nS = P224::Affine (BVtoZ 0x6eca814ba59a930843dc814edd6c97da95518df3c6fdf16e9a10bb5b)\n     (BVtoZ 0xef4b497f0963bc8b6aec0ca0f259b89cd80994147e05dc6b64d7bf22)\n\nT = P224::Affine (BVtoZ 0xb72b25aea5cb03fb88d7e842002969648e6ef23c5d39ac903826bd6d)\n     (BVtoZ 0xc42a8a4d34984f0b71b5b4091af7dceb33ea729c1a2dc8b434f10c34)\n\nproperty sAndTAreValid = P224::isValid S && P224::isValid T\n\nproperty additionVectorPasses = P224::affineEq (P224::add S T) R\n  where R = P224::Affine (BVtoZ 0x236f26d9e84c2f7d776b107bd478ee0a6d2bcfcaa2162afae8d2fd15)\n             (BVtoZ 0xe53cc0a7904ce6c3746f6a97471297a0b7d5cdf8d536ae25bb0fda70)\n\nproperty subtractionVectorPasses = P224::affineEq (P224::sub S T) R\n  where R = P224::Affine (BVtoZ 0xdb4112bcc8f34d4f0b36047bca1054f3615413852a7931335210b332)\n             (BVtoZ 0x90c6e8304da4813878c1540b2396f411facf787a520a0ffb55a8d961)\n\nproperty doubleVectorPasses = P224::affineEq (P224::double S) R\n  where R = P224::Affine (BVtoZ 0xa9c96f2117dee0f27ca56850ebb46efad8ee26852f165e29cb5cdfc7)\n             (BVtoZ 0xadf18c84cf77ced4d76d4930417d9579207840bf49bfbf5837dfdd7d)\n\nproperty scalarMultVectorPasses = P224::affineEq (P224::scmul d S) R\n  where d = toInteger 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        R = P224::Affine (BVtoZ 0x96a7625e92a8d72bff1113abdb95777e736a14c6fdaacc392702bca4)\n             (BVtoZ 0x0f8e5702942a3c5e13cd2fd5801915258b43dfadc70d15dbada3ed10)\n\nproperty twinMultVectorPasses =\n  P224::affineEq R (P224::twin_mul d S e T)\n  where d = toInteger 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        e = toInteger 0x54d549ffc08c96592519d73e71e8e0703fc8177fa88aa77a6ed35736\n        R = P224::Affine (BVtoZ 0xdbfe2958c7b2cda1302a67ea3ffd94c918c5b350ab838d52e288c83e)\n            (BVtoZ 0x2f521b83ac3b0549ff4895abcc7f0c5a861aacb87acbc5b8147bb18b)\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Instantiations\/P256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Common::EC::PrimeField::Instantiations::P256` instantiating the PFEC prime-field elliptic curve over the P-256 parameters (P, n', b, Gx, Gy), exposing the curve constants and any necessary types and functions for ECDSA\/NIST P-256 operations."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Instantiations::P256 =\n       Common::EC::PrimeField::PFEC where\ntype P = 115792089210356248762697446949407573530086143415290314195533631308867097853951\ntype n' = 115792089210356248762697446949407573529996955224135760342422259061068512044369\nb  = `0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\nGx = `0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\nGy = `0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Instantiations\/P192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Common::EC::PrimeField::Instantiations::P192 that instantiates the generic PFEC prime-field elliptic curve module for NIST P-192 using the given prime P, order n', curve parameter b, and base point (Gx, Gy)."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Instantiations::P192 =\n       Common::EC::PrimeField::PFEC where\ntype P = 6277101735386680763835789423207666416083908700390324961279\ntype n' =  6277101735386680763835789423176059013767194773182842284081\nb  = `0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1\nGx = `0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\nGy = `0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811\n```"}]}
{"filename":"cryptol-specs\/Common\/EC\/PrimeField\/Instantiations\/P224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Common::EC::PrimeField::Instantiations::P224` that instantiates `Common::EC::PrimeField::PFEC` for the NIST P-224 curve, defining the prime `P`, order `n'`, curve parameter `b`, and base point coordinates `Gx` and `Gy` with the given constants."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::Instantiations::P224 =\n       Common::EC::PrimeField::PFEC where\ntype P = 26959946667150639794667015087019630673557916260026308143510066298881\ntype n' = 26959946667150639794667015087019625940457807714424391721682722368061\nb  = `0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\nGx = `0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\nGy = `0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\n```"}]}
{"filename":"saw-script\/intTests\/test_FNV_a1_rev\/FNV_a1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the 64-bit FNV-1a hash, including functions `pad`, `fnv1a`, `saltHash`, and a property `testsPass` that checks the given known-answer tests and a `break` function that verifies all provided salted hashes match `saltHash` outputs for a secret message."},{"role":"assistant","content":"```cryptol\nfnv1a : {n} (fin n) => [n] -> [64]\nfnv1a ws = fnv1a' (pad ws)\n\npad : {msgLen,chunks,padding}\n     ( fin chunks\n     , fin msgLen\n     , chunks     == (msgLen+7) \/ 8\n     , padding    == (8 - msgLen % 8) % 8\n     )\n     => [msgLen] -> [chunks][8]\npad msg = split (msg # (zero:[padding]))\n\nfnv1a' : {chunks} (fin chunks) => [chunks][8] -> [64]\nfnv1a' msg = Ss ! 0\n  where\n   Ss = [fnv1a_offset_basis] #\n           [ block s m\n           | s <- Ss\n           | m <- msg\n           ]\n\nblock : {padding} ( fin padding, padding == 64 - 8) => [64] -> [8] -> [64]\nblock state val = (state ^ ((zero : [padding]) # val)) * fnv1a_prime\n\nfnv1a_offset_basis : [64]\nfnv1a_offset_basis = 14695981039346656037\n\nfnv1a_prime : [64]\nfnv1a_prime = 1099511628211\n\nt1 = fnv1a [] == 0xcbf29ce484222325\nt2 = fnv1a (join \"a\") == 0xaf63dc4c8601ec8c\nt3 = fnv1a (join \"foobar\") == 0x85944171f73967e8\n\nproperty testsPass = [t1, t2, t3] == ~zero\n\nbreak : {n} (fin n) => [4]([64],[64]) -> [n][8] -> Bit\nbreak pairs secret = ~zero == [saltHashCorrect p secret | p <- pairs]\n\nsecret1 : [4]([64],[64])\nsecret1 = [ (`0    , saltHash `0x0   msg)\n          , (`0xF  , saltHash `0xF   msg)\n          , (`0xFF , saltHash `0xFF  msg)\n          , (`0xFFF, saltHash `0xFFF msg)\n          ]\n  where msg = \"Secret Message\"\n\nsaltHashCorrect : {n} (fin n) => ([64],[64]) -> [n][8] -> Bit\nsaltHashCorrect (salt,result) secret = saltHash salt secret == result\n\nsaltHash : {n} (fin n) => [64] -> [n][8] -> [64]\nsaltHash s msg = fnv1a (s # join msg)\n```"}]}
{"filename":"saw-script\/intTests\/test_newtype\/complex.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define properties `cplxAddAssoc`, `cplxMulAssoc`, and `cplxMulDistrib` that prove associativity of complex addition and multiplication and left-distributivity of multiplication over addition for the `CplxInt` newtype and its operations."},{"role":"assistant","content":"```cryptol\ntype Int = Integer\n\nnewtype CplxInt =\n  { real : Int, imag : Int }\n\nembedQ : Int -> CplxInt\nembedQ x = CplxInt{ real = x, imag = 0 }\n\ncplxAdd : CplxInt -> CplxInt -> CplxInt\ncplxAdd x y = CplxInt { real = r, imag = i }\n  where\n  r = x.real + y.real\n  i = x.imag + y.imag\n\ncplxMul : CplxInt -> CplxInt -> CplxInt\ncplxMul x y = CplxInt { real = r, imag = i }\n  where\n  r = x.real * y.real - x.imag * y.imag\n  i = x.real * y.imag + x.imag * y.real\n\ncplxEq : CplxInt -> CplxInt -> Bit\ncplxEq x y = (x.real == y.real) && (x.imag == y.imag)\n\ncplxAddAssoc : CplxInt -> CplxInt -> CplxInt -> Bit\ncplxAddAssoc x y z =\n  cplxEq (cplxAdd (cplxAdd x y) z)\n         (cplxAdd x (cplxAdd y z))\n\ncplxMulAssoc : CplxInt -> CplxInt -> CplxInt -> Bit\ncplxMulAssoc x y z =\n  cplxEq (cplxMul (cplxMul x y) z)\n         (cplxMul x (cplxMul y z))\n\ncplxMulDistrib : CplxInt -> CplxInt -> CplxInt -> Bit\ncplxMulDistrib x y z =\n  cplxEq (cplxMul x (cplxAdd y z))\n         (cplxAdd (cplxMul x y) (cplxMul x z))\n```"}]}
{"filename":"saw-script\/intTests\/test_bisimulation\/Comp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the given andSpec\/andImp and nandSpec\/nandImp interfaces and relational predicates, and adds properties stating that andImp implements andSpec and nandImp implements nandSpec via the respective state and output refinement relations."},{"role":"assistant","content":"```cryptol\nmodule Comp where\n\nandSpec : ((), (Bit, Bit)) -> ((), (Bit, Bit))\nandSpec (_, (x, y)) = ((), (True, x && y))\n\nnandSpec : ((), (Bit, Bit)) -> ((), (Bit, Bit))\nnandSpec (_, (x, y)) = ((), (True, ~ (andSpec ((), (x, y))).1.1))\n\ntype andState = { loaded : Bit, origX : Bit, origY : Bit }\n\nandImp : (andState, (Bit, Bit)) -> (andState, (Bit, Bit))\nandImp (s, (x, y)) =\n  if s.loaded \/\\ x == s.origX \/\\ y == s.origY\n  then (s, (True, s.origX && s.origY))\n  else ({ loaded = True, origX = x, origY = y }, (False, 0))\n\nandOutputRel : (andState, (Bit, Bit)) -> ((), (Bit, Bit)) -> Bit\nandOutputRel (s, (impReady, impO)) ((), (_, specO)) =\n  if impReady then impO == specO else True\n\nandStateRel : andState -> () -> Bit\nandStateRel _ () = True\n\ntype nandState = { as : andState, unused : Bit }\n\nnandImp : (nandState, (Bit, Bit)) -> (nandState, (Bit, Bit))\nnandImp (s, in) = ({ as = as' , unused = False }, (andReady, ~andRes))\n  where\n    (as', (andReady, andRes)) = andImp (s.as, in)\n\nnandOutputRel : (nandState, (Bit, Bit)) -> ((), (Bit, Bit)) -> Bit\nnandOutputRel (s, (impReady, impO)) ((), (_, specO)) =\n  if impReady then impO == specO else True\n\nnandStateRel : nandState -> () -> Bit\nnandStateRel _ () = True\n```"}]}
{"filename":"saw-script\/intTests\/test_bisimulation\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines a bisimulation-style property relating f1 : (S1,[8]) -> (S1,[8]) and f2 : (S2,[8]) -> (S2,[8]) using the given state\/output relations srel and orel, and shows that ill-typed variants f2_bad_input_type and f2_bad_output_type do not satisfy it."},{"role":"assistant","content":"```cryptol\nmodule Test where\n\ntype S1 = [8]\ntype S2 = [16]\n\nf1 : (S1, [8]) -> (S1, [8])\nf1 (ctr, inp) = (ctr+1, inp+ctr)\nf2 : (S2, [8]) -> (S2, [8])\nf2 (ctr, inp) = (ctr+1, inp+(drop ctr))\n\nf2_bad_input_type : (S2, [9]) -> (S2, [8])\nf2_bad_input_type (ctr, inp) = (ctr+1, (drop inp)+(drop ctr))\n\nf2_bad_output_type : (S2, [8]) -> (S2, [9])\nf2_bad_output_type (ctr, inp) = (ctr+1, zext (inp+(drop ctr)))\n\norel : (S1, [8]) -> (S2, [8]) -> Bit\norel (s1, o1) (s2, o2) = s1 == drop s2 \/\\ o1 == o2\n\nsrel : S1 -> S2 -> Bit\nsrel s1 s2 = s1 == drop s2\n```"}]}
{"filename":"saw-script\/intTests\/test2043\/A.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the parameterized module `A` with type parameter `N` and constant `foo : [N]`, and define the polymorphic function `bar : {n, a} (Zero a) => [n]a` using pattern guards `n == 1` and `n != 1`, both returning `zero`."},{"role":"assistant","content":"```cryptol\nmodule A where\n\nparameter\n  type N : #\n  foo : [N]\n\nbar : {n, a} (Zero a) => [n]a\nbar | n == 1 => zero\n    | n != 1 => zero\n```"}]}
{"filename":"saw-script\/intTests\/test_smt_array_load_concrete_size\/Mix.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the module `Mix` with type alias `ByteArray` and function `mix : {l} (width l <= 64) => ByteArray -> [64] -> [l][8] -> ByteArray` that uses `arrayCopy`, `arrayRangeUpdate`, and `arrayConstant` as in the given implementation."},{"role":"assistant","content":"```cryptol\nmodule Mix where\n\nimport Array\n\ntype ByteArray = Array[64][8]\n\nmix : {l} (width l <= 64) => ByteArray -> [64] -> [l][8] -> ByteArray\nmix block n data = arrayCopy block n (arrayRangeUpdate (arrayConstant 0) 0 data) 0 `(l)\n```"}]}
{"filename":"saw-script\/intTests\/test0000\/mutRecTest.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines properties asserting that streamFibs, streamFibsAlt, recFibs, and recFibs2 all compute the same Fibonacci values for all 8-bit inputs, and are pairwise equivalent for all valid arguments."},{"role":"assistant","content":"```cryptol\nstreamFibs : [8] -> [32]\nstreamFibs x = fibs0@x\n   where fibs0 = [0]#fibs1\n         fibs1 = [1]#[ a + b | a <- fibs0\n                             | b <- fibs1\n                     ]\n\nstreamFibsAlt : [8] -> [32]\nstreamFibsAlt x = fibs@x\n   where fibs = [0,1]#[ a + b | a <- fibs\n                              | b <- drop`{1} fibs\n                      ]\n\nrecFibs : [8] -> [32]\nrecFibs n = if n > 1  then recFibs (n-1) + recFibs (n-2) else zx n\n\nzx : {a, b} (fin a, fin b) => [b] -> [a+b]\nzx m = zero#m\n\nrecFibs2 : [8] -> [32]\nrecFibs2 n =\n  if n == 0 then 0\n   | n == 1 then 1\n   else recFibs2 (n-1) + recFibs2 (n-2)\n```"}]}
{"filename":"saw-script\/intTests\/test_fold_rewrite_proof\/tupletest.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the given fold-based tuple functions and a property foldFunctionInverse stating that for all x, y, z, foldFunction' (foldFunction x y z) y z == x, suitable for formal verification."},{"role":"assistant","content":"```cryptol\nmodule tupletest where\n\nfoldFunction : [8] -> [16] -> [16] -> [8]\nfoldFunction x y z = output.0\n  where\n    output = foldl fnc (x, y, z) [0 .. 15]\n\nfnc : ([8], [16], [16]) -> [4] -> ([8], [16], [16])\nfnc (x, y, z) i = returnTup\n  where\n    returnTup = (x ^ take y' ^ take z', y', z')\n    y' = y <<< i\n    z' = z >>> i\n\nfoldFunction' : [8] -> [16] -> [16] -> [8]\nfoldFunction' x y z = output.0\n  where\n    output = foldl fnc' (x, y, z) [15, 14 .. 0]\n\nfnc' : ([8], [16], [16]) -> [4] -> ([8], [16], [16])\nfnc' (x, y, z) i = returnTup\n  where\n    returnTup = (x ^ take y ^ take z, y', z')\n    y' = y >>> i\n    z' = z <<< i\n\nproperty foldFunctionInverse x y z =\n    foldFunction' (foldFunction x y z) y z == x\n```"}]}
{"filename":"saw-script\/intTests\/test_ffi_verify_salsa\/salsa.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the foreign function `cipher` with the given polymorphic type, implemented as `Salsa20_encrypt` imported from `Primitive::Symmetric::Cipher::Stream::Salsa20`, matching the provided type constraints and array sizes."},{"role":"assistant","content":"```cryptol\nimport Primitive::Symmetric::Cipher::Stream::Salsa20 (Salsa20_encrypt)\n\nforeign cipher : {a, w} (a >= 1, 2 >= a, w <= 2^^70) => [16*a][8] -> [8][8] -> [w][8] -> [w][8]\ncipher = Salsa20_encrypt\n```"}]}
{"filename":"saw-script\/intTests\/test_cryptol_enums\/Test2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines the enum type `ETT a b` and the functions `f1`, `f1'`, `f2`, `f3`, `cc3`, `f4`, along with test values and booleans `results1` and `results2` that verify the case analysis behaves as in the given specification."},{"role":"assistant","content":"```cryptol\nmodule Test2 where\n\nenum ETT a b = C1\n             | C2 a\n             | C3 Bool b\n\nf1 : {c, d} ETT c d -> [8]\nf1 e1 = case e1 of\n          C1 -> 101\n          _  -> 102\n\nf1' e1 = case e1 of\n           C1 -> 101\n           _  -> 102\n\nf2 : ETT Bool () -> [8]\nf2 e = case e of\n         C1     -> 101\n         C3 _ _ -> 103\n         C2 _   -> 102\n\nf3 : ETT Bool () -> [8]\nf3 e = case e of\n         C1      -> 101\n         _       -> 105\n           \/\/ ^ compiles to two default functions but they have different\n           \/\/   types.\n\nt11 = f1 C1\nt12 = f1 (C2 ())\nt13 = f1 (C3 True False)\n\nt31 = f3 C1\nt32 = f3 (C2 False)\nt33 = f3 (C3 True ())\n\nresults1 = [ t11 == 101\n           , t12 == 102\n           , t13 == 102\n           , t31 == 101\n           , t32 == 105\n           , t33 == 105\n           ]\n\n\/* sawcript idioms:\n\nreturn (type {{ f1  }})\nreturn (type {{ f1' }})\n\nreturn (normalize_term {{ t11 }})\nreturn (normalize_term {{ t12 }})\nreturn (normalize_term {{ t13 }})\n\nreturn (eval_int {{ t31 }})\nreturn (eval_int {{ t32 }})\nreturn (eval_int {{ t33 }})\n*\/\n\ncc3 : {a, b} b -> ETT a b\ncc3 = C3 True\n\nx : [16]\nx = 2\n\ny : [16]\ny = 1\n\nf4 : [16] -> ETT [16] [16] -> [16]\nf4 z e = 4 + z + case e of\n                   C3 _ b   ->     b + z + y + 32\n                   C2 a     -> a +     z + y + 16\n                   _        ->         z + x + 8\n\nt43a = f4 64 (C3 False 512) t42a = f4 64 (C2 128)       t41a = f4 64 C1             \nresults2 = [ t43a == 677\n           , t42a == 277\n           , t41a == 142\n           ]\n```"}]}
{"filename":"saw-script\/intTests\/test_constraint_guards\/Parameterized.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the module `Parameterized` with the given `gamma` type parameter and constraint, and implement the guarded definition for `v : [gamma]` that returns 0 when `gamma == 3`, 1 when `gamma == 2`, and 2 otherwise."},{"role":"assistant","content":"```cryptol\nmodule Parameterized where\n\nparameter\n    type gamma : #\n    type constraint (fin gamma, gamma >= 2, 32 >= width gamma)\n\nv : [gamma]\nv | (gamma == 3) => 0\n      | (gamma == 2) => 1\n  | () => 2\n```"}]}
{"filename":"saw-script\/intTests\/test_constraint_guards\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the functions `guard`, `incomplete`, and `dependent` that uses type-size constraints in guards, preserving the same patterns and behaviors as in the given code."},{"role":"assistant","content":"```cryptol\nmodule Test where\n\nguard : {w} [w] -> Integer\nguard x\n  | (w == 32) => 0\n  | (w >= 32) => 1\n  | (w < 8) => 2\n  | (w != 8, w != 9) => 3\n  | () => 4\n\nincomplete : {w} [w] -> Bool\nincomplete x\n  | (w == 32) => True\n\ndependent : {n} [n]\ndependent\n  | n == 1 => [True]\n  | ()     => repeat False\n```"}]}
{"filename":"saw-script\/intTests\/test0052_smt_array_1\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions and properties in module ArrayTest that formalize the SMT array axioms: (1) looking up an index after an update at that same index returns the new element, and (2) looking up a different index is unchanged by an update elsewhere."},{"role":"assistant","content":"```cryptol\nmodule ArrayTest where\n\nimport Array\n\nlookup_update_axiom_1 : Array [64] [64] -> [64] -> [64] -> Bit\nlookup_update_axiom_1 a i e = arrayLookup (arrayUpdate a i e) i == e\n\nlookup_update_axiom_2 : Array [64] [64] -> [64] -> [64] -> [64] -> Bit\nlookup_update_axiom_2 a i j e = i != j ==> arrayLookup (arrayUpdate a j e) i == arrayLookup a i\n```"}]}
{"filename":"saw-script\/intTests\/test_hash_table\/ht_simplified.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol that this pooled hash table implementation (with fixed-size entry pool, buckets, and djb2-style hash) preserves the is_valid_state invariant across calls to incrementValueFull for all possible keys and initial valid states."},{"role":"assistant","content":"```cryptol\nmodule HT where\n\ntype Entry =   \n    { key    : [64]\n    , value  : [32]\n    , next   : [32]\n    }\n\ntype EntryTuple = ([64],[32],[32])\n\nentryToTuple : Entry -> EntryTuple\nentryToTuple e = (e.key, e.value, e.next)\n\ntupleToEntry : EntryTuple -> Entry\ntupleToEntry (key_t, value_t, next_t) = {key = key_t, value = value_t, next = next_t}\n\ntype NUMBUCKETS = 2\n\ntype POOLSIZE = 5\n\nNULL : [32]\nNULL = 0xffffffff\n\nCAP : [32]\nCAP = 5\n\ntype PooledHashTable =   \n    { buckets    : [NUMBUCKETS][32]\n    , cur_entry  : [32]\n    }\n\ntype PooledHashTableTuple = ([NUMBUCKETS][32],[32])\n\npooledHashTableToTuple : PooledHashTable -> PooledHashTableTuple\npooledHashTableToTuple pt = (pt.buckets, pt.cur_entry)\n\ntupleToPooledHashTable : PooledHashTableTuple -> PooledHashTable\ntupleToPooledHashTable (bucket_tuple,cur_entry_tuple) = {buckets = bucket_tuple, cur_entry = cur_entry_tuple}\n\ntype EntryPool = [POOLSIZE] Entry\n\ntype EntryPoolTuple = [POOLSIZE]([64], [32], [32])\n\nentryPoolToTuple : EntryPool -> EntryPoolTuple\nentryPoolToTuple ep = map entryToTuple ep\n\ntupleToEntryPool : EntryPoolTuple -> EntryPool\ntupleToEntryPool ep = map tupleToEntry ep\n\ninitTable : PooledHashTable\ninitTable = {cur_entry = 0, buckets = repeat NULL}\n\ninitEntry : Entry\ninitEntry = {key = 0, value = 0, next = NULL}\n\ninitEntryPool : EntryPool\ninitEntryPool = zero\n\nhash : [64] -> [32]\nhash v = foldr (\\c h -> 33 * h + (0 # c)) 5381 ((split v):[8][8])\n\ngetBucket : [64] -> [32]\ngetBucket key = hash(key) % `NUMBUCKETS\n\ntype State = { ep : EntryPool\n             , pht : PooledHashTable\n             }\n\nerrorState : State\nerrorState = zero:State\n\nstateToTuple : State -> ([POOLSIZE]([64], [32], [32]), ([NUMBUCKETS][32], [32]))\nstateToTuple state = (entryPoolToTuple state.ep, pooledHashTableToTuple state.pht)\n\ntupleToState : ([POOLSIZE]([64], [32], [32]), ([NUMBUCKETS][32], [32])) -> State\ntupleToState (entryPoolTuple, phtTuple) = {ep = tupleToEntryPool entryPoolTuple, pht = tupleToPooledHashTable phtTuple}\n\ninitState : State\ninitState = {ep = initEntryPool, pht = initTable}\n\ntype IncrementValueRet = { value : [32]\n                         , slot : [32]\n                         , state : State\n                         }\n\nis_valid_index : [32] -> [32] -> Bool\nis_valid_index n i = i < n \\\/ i == NULL\n\nis_valid_state : State -> Bool\nis_valid_state state =\n  state.pht.cur_entry <= `POOLSIZE\n    \/\\ all (is_valid_index state.pht.cur_entry) state.pht.buckets\n    \/\\ all (\\(i, e) -> i < state.pht.cur_entry ==> ((is_valid_index state.pht.cur_entry e.next) \/\\ i < e.next \/\\ e.value <= CAP)) (zip (take [0 ...]) state.ep)\n\nupdatePrev : EntryPool -> [32] -> [32] -> EntryPool\nupdatePrev epIn cur_index prev_index = ret where\n    prevEntry = epIn@prev_index\n    ret = update epIn prev_index {key = prevEntry.key, value = prevEntry.value, next = cur_index }\n\nincrementNextValue1 : [64] -> [32] -> [32] -> State -> IncrementValueRet\nincrementNextValue1 key prev_index bucket state = ret where\n    cur_index = state.pht.cur_entry\n    newEp = update state.ep cur_index {key = key, value = 1, next = NULL}\n    ret = if(prev_index != NULL) \n        then \n            { value = 1\n            , slot = cur_index \n            , state = \n              { ep = updatePrev newEp cur_index prev_index \n              , pht = {cur_entry = cur_index + 1, buckets = state.pht.buckets}\n              }\n            }\n        else \n            { value = 1\n            , slot = cur_index\n            , state = \n              { ep = newEp\n              , pht = {cur_entry = cur_index + 1, buckets = update state.pht.buckets bucket cur_index}\n              }\n            }\n\nincrementNextValue : [64] -> [32] -> [32] -> State -> IncrementValueRet\nincrementNextValue key prev_index bucket state = \n    if (state.pht.cur_entry < `POOLSIZE) \n        then incrementNextValue1 key prev_index bucket state\n        else {value = 0, slot = NULL, state = state}\n\nincrementValueLoop : [64] -> [64] -> [32] -> [32] -> State -> (Bool, [32], [32], ([32], State))\nincrementValueLoop count key cur_index prev_index state = \n        if (count <= 0) then (False, NULL, NULL, (0, errorState))\n    else \n        if (cur_index == NULL)\n            then (True, cur_index, prev_index, (0, state))\n            else checkCurEntry count key cur_index prev_index state\n\ncheckCurEntry : [64] -> [64] -> [32] -> [32] -> State -> (Bool, [32], [32], ([32], State))\ncheckCurEntry count key cur_index prev_index state = ret where\n    cur_entry = state.ep@cur_index\n    ret = if(cur_entry.key == key)\n        then keyHit key cur_index prev_index cur_entry state\n        else incrementValueLoop (count - 1) key cur_entry.next cur_index state\n\nkeyHit : [64] -> [32] -> [32] -> Entry -> State -> (Bool, [32], [32], ([32], State))\nkeyHit key cur_index prev_index cur_entry state = ret where\n    curValue = cur_entry.value\n    ret = if (curValue < CAP) \n        then (False, cur_index, prev_index, (curValue + 1, {ep = (update state.ep cur_index {key = cur_entry.key, value = curValue + 1, next = cur_entry.next}), pht = state.pht}))\n        else (False, cur_index, prev_index, (curValue, state))\n\nincrementValueFull : [64] -> State -> IncrementValueRet\nincrementValueFull key state = ret where\n    bucket = getBucket(key)\n    cur_index = state.pht.buckets@bucket\n    prev_index = NULL\n    (continue, n_cur_index, n_prev_index, (value, nstate)) = incrementValueLoop (`POOLSIZE + 1) key cur_index prev_index state\n    ret = if continue then incrementNextValue key n_prev_index bucket nstate else {value = value, slot = n_cur_index, state = nstate}\n```"}]}
{"filename":"saw-script\/intTests\/test0037_popcount\/spec.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions `popcount`, `clz`, and `ctz` over bit vectors (with the given polymorphic types), implementing population count, count-leading-zeros, and count-trailing-zeros as shown, suitable for use in verification tests."},{"role":"assistant","content":"```cryptol\npopcount : {n} (n >= 1, fin n) => [n] -> [n]\npopcount x = foldr (+) zero [ if b then 1 else 0 | b <- x ]\n\nclz : {n} fin n => [n] -> [n]\nclz x = foldr f `n [ (b,i) | i <- [0 ...] | b <- x ]\n where\n f (b,i) r = if b then i else r\n\nctz : {n} fin n => [n] -> [n]\nctz x = clz (reverse x)\n```"}]}
{"filename":"saw-script\/intTests\/test_w4_unint_rme\/Code.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the Ascon permutation round function, including the type alias State, the Ascon_p permutation over a symbolic number of rounds rnd \u2264 16, and the component functions pC, pS (with SBox and SBoxTable), and pL with its sigma helper."},{"role":"assistant","content":"```cryptol\nmodule Code where\n\ntype constraint ValidRnd rnd = rnd <= 16\n\nAscon_p : {rnd} (ValidRnd rnd) => State -> State\nAscon_p S = foldl round S (drop`{back=rnd} Const)\n\nround : State -> [64] -> State\nround S ci = pL (pS (pC S ci))\n\ntype State = [5][64]\n\npC : State -> [64] -> State\npC [S0, S1, S2, S3, S4] ci = [S0, S1, S2 ^ ci, S3, S4]\n\nConst : [16][64]\nConst =\n    [ 0x000000000000003c\n    , 0x000000000000002d\n    , 0x000000000000001e\n    , 0x000000000000000f\n    , 0x00000000000000f0\n    , 0x00000000000000e1\n    , 0x00000000000000d2\n    , 0x00000000000000c3\n    , 0x00000000000000b4\n    , 0x00000000000000a5\n    , 0x0000000000000096\n    , 0x0000000000000087\n    , 0x0000000000000078\n    , 0x0000000000000069\n    , 0x000000000000005a\n    , 0x000000000000004b\n    ]\n\npS : State -> State\npS S = transpose (map SBox (transpose S))\n\nSBox : [5] -> [5]\nSBox i = SBoxTable@i\n\nSBoxTable : [32][5]\nSBoxTable =\n    map drop\n    [ 0x04, 0x0b, 0x1f, 0x14, 0x1a, 0x15, 0x09, 0x02\n    , 0x1b, 0x05, 0x08, 0x12, 0x1d, 0x03, 0x06, 0x1c\n    , 0x1e, 0x13, 0x07, 0x0e, 0x00, 0x0d, 0x11, 0x18\n    , 0x10, 0x0c, 0x01, 0x19, 0x16, 0x0a, 0x0f, 0x17\n    ]\n\npL : State -> State\npL [S0, S1, S2, S3, S4] =\n    [ sigma S0 19 28\n    , sigma S1 61 39\n    , sigma S2  1  6\n    , sigma S3 10 17\n    , sigma S4  7 41\n    ]\n    where\n        sigma : [64] -> [6] -> [6] -> [64]\n        sigma x i j = x ^ x>>>i ^ x>>>j\n```"}]}
{"filename":"saw-script\/intTests\/test_saw_submodule_access1\/F.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module F that imports modules B and C, defines the top-level values top0, topd2, topd3, d00, and nested submodules D3 and D4 with values d2, d3D2, d2', private d3P, and d3, matching the given dependency structure and types."},{"role":"assistant","content":"```cryptol\nmodule F where\nimport B\nimport C\n\ntop0  = 2000 + b + c\ntopd2 = 5  + D3::d2\ntopd3 = 10 + D3::D4::d3\n\nd00 : [32]\nd00 = 1 \nsubmodule D3 where\n  d2   = 10000 + top0\n  d3D2 =     1 + D4::d3\n  d2'  =     1 + d3P\n\n  private\n    d3P = 1 + d2\n\n  submodule D4 where\n    d3 = 20000 + top0 + d2\n```"}]}
{"filename":"saw-script\/intTests\/test_saw_submodule_access1\/D.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module D (with submodules D2 and D3) that imports modules B and C, defines the constants d00, d01, d2, d3, and the types DTySy, D2TySy, and D3TySy exactly as specified, ensuring correct submodule access and type declarations."},{"role":"assistant","content":"```cryptol\nmodule D where\nimport B\nimport C\n\nd00 = 2000 + b + c\nd01 = 5 + D2::d2\n\ntype DTySy = [32]\n\nsubmodule D2 where\n  d2 = d00 + 10000\n\n  type D2TySy = [32]\n\n  submodule D3 where\n  d3 = d00 + d2 + 1\n\n  type D3TySy = [32]\n```"}]}
{"filename":"saw-script\/intTests\/test_saw_submodule_access1\/UseFunctors.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `UseFunctors` that demonstrates nested `submodule` declarations, parameterized functor-style submodules, and qualified name access, reproducing the constants `ex1` and `ex2` as in the given structure."},{"role":"assistant","content":"```cryptol\nmodule UseFunctors where\n\nsubmodule M where\n    x = 0x02\n\n    submodule M1 where\n      x = 0x03\n\nex1 = M::x + M::M1::x  \nsubmodule F where\n  parameter\n    p: [8]\n\n  submodule FM where\n    z = 0x03 + p\n\n  f = 2 * p\n\nsubmodule I = submodule F where\n  p = 11\n\nex2 = I::f + 2\n```"}]}
{"filename":"saw-script\/intTests\/test_ffi_verify\/test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines these foreign functions with the given types and implementations, suitable for use as FFI verification targets in SAW, preserving all polymorphism, constraints, and composite types."},{"role":"assistant","content":"```cryptol\nforeign add8 : [8] -> [8] -> [8]\nadd8 = (+)\n\nforeign sub16 : [16] -> [16] -> [16]\nsub16 = (-)\n\nforeign mul32 : [32] -> [32] -> [32]\nmul32 = (*)\n\nforeign div64 : [64] -> [64] -> [64]\ndiv64 x y = if y == 0 then 0 else x \/ y\n\nforeign extendInput : [3] -> [8]\nextendInput = zext\n\nforeign maskOutput : [8] -> [3]\nmaskOutput = drop\n\nforeign noBits : [0] -> [0]\nnoBits x = x\n\nforeign not : Bit -> Bit\nnot x = ~ x\n\ntype Word32 = [32]\ntype Word64 = [64]\ntype MyFunc = Word32 -> [64] -> Bit\n\nforeign usesTypeSynonym : MyFunc\nusesTypeSynonym x y = zext x == y\n\nforeign sum10 : [10]Word32 -> Word32\nsum10 = sum\n\nforeign reverse5 : [5]Word64 -> [5]Word64\nreverse5 = reverse\n\nforeign compoundTypes : ([32], { x : [10], y : [3][20] }) -> { z : [5][20] }\n  -> { a : ([16], [16]), b : { c : [8][20], d : [5], e : [5] } }\ncompoundTypes (n, { x = x, y = y }) { z = z } =\n  { a = splitAt `{16} n\n  , b = { c = y # z, d = take `{5} x, e = drop `{5} x }\n  }\n\nforeign typeToValue : {n} (fin n, width n <= 64) => () -> [64]\ntypeToValue () = `n\n\nforeign sumPoly : {n} (fin n) => [n]Word32 -> Word32\nsumPoly = sum\n\nforeign inits : {n} (fin n) => [n][8] -> [n * (n + 1) \/ 2][8]\ninits xs\n  | n == 0 => []\n  | n >  0 => initsLoop xs' x []\n    where\n      (x : [1]_) # xs' = xs\n\ninitsLoop : {n, l, m, a} (fin l, fin m, l + m == n, m >= 1) =>\n        [l]a -> [m]a ->\n        [((m - 1) * ((m - 1) + 1)) \/ 2]a ->\n        [(n * (n + 1)) \/ 2]a\ninitsLoop ys zs acc\n  | l == 0 => acc # zs\n  | l >  0 => initsLoop ys' (zs # y) (acc # zs)\n   where (y : [1]_) # ys' = ys\n\nforeign zipMul3 : {n, m, p} (fin n, fin m, fin p) =>\n  [n][27] -> [m][27] -> [p][27] -> [min n (min m p)][27]\nzipMul3 xs ys zs = [x * y * z | x <- xs | y <- ys | z <- zs]\n\nforeign reshape : {a, b, c, d} (fin a, fin b, fin c, fin d) =>\n  [a][b][c][d][32] -> { dcba : [d][c][b][a][32], acbd : [a][c][b][d][32] }\nreshape x =\n  { dcba = split (split (split (join (join (join x)))))\n  , acbd = split (split (split (join (join (join x)))))\n  }\n\nforeign same : ([32], [10], [8][20]) -> ([32], [10], [8][20])\nsame x = x\n\nforeign notnot : Bit -> Bit\nnotnot x = not (not x)\n```"}]}
{"filename":"saw-script\/intTests\/test2337\/test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the type `Letter` with constructors `A` and `B`, the function `eqLetter : Letter -> Letter -> Bit` implementing equality on `Letter`, and the function `letterA : Bool -> Letter` that returns `A` when its argument is `True` and `B` otherwise."},{"role":"assistant","content":"```cryptol\nenum Letter = A | B\n\neqLetter : Letter -> Letter -> Bit\neqLetter l1 l2 =\n  case l1 of\n    A ->\n      case l2 of\n        A -> True\n        B -> False\n    B ->\n      case l2 of\n        A -> False\n        B -> True\n\nletterA : Bool -> Letter\nletterA x =\n  if x then A else B\n```"}]}
{"filename":"saw-script\/crux-mir-comp\/test\/symb_eval\/cryptol\/uninterp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `mult : [64] -> [64] -> [64]` as an uninterpreted polynomial multiplication over GF(2) using the given 65-bit irreducible polynomial, so that the existing `pow` function correctly computes exponentiation in this field."},{"role":"assistant","content":"```cryptol\nmodule test::symb_eval::cryptol::uninterp where\n\ntype U64 = [64]\n\npow : U64 -> U64 -> U64\npow n k = last vals where\n    sq x = mult x x\n    vals = [1]\n         # [ if i then mult n acc else acc\n           | acc <- map sq vals\n           | i   <- k ]\n\nirreducible : [65]\nirreducible = <| x^^64 + x^^4 + x^^3 + x + 1 |>\n\nmult : U64 -> U64 -> U64\nmult = undefined\n```"}]}
{"filename":"saw-script\/crux-mir-comp\/test\/symb_eval\/cryptol\/basic.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification with functions addByte, tupleArg, tupleRet, arrayArg, arrayRet, and xorBits (with the given types) and include properties that these functions correctly perform byte-wise addition, subtraction, and bitwise XOR for all valid inputs."},{"role":"assistant","content":"```cryptol\nmodule test::symb_eval::cryptol::basic where\n\naddByte : [8] -> [8] -> [8]\naddByte x y = x + y\n\ntupleArg : ([8], [8]) -> [8]\ntupleArg (x, y) = x + y\n\ntupleRet : [8] -> [8] -> ([8], [8])\ntupleRet x y = (x + y, x - y)\n\narrayArg : [2][8] -> [8]\narrayArg [x, y] = x + y\n\narrayRet : [8] -> [8] -> [2][8]\narrayRet x y = [x + y, x - y]\n\nxorBits : {n} (fin n) => [n] -> [n] -> [n]\nxorBits x y = x ^ y\n```"}]}
{"filename":"saw-script\/crux-mir-comp\/test\/symb_eval\/cryptol\/size_poly_nested.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the polymorphic function `f : {m,n} (fin m, fin n) => [m][n][8] -> [8]` that flattens a 2D array of 8-bit values and returns the sum of all elements as an 8-bit value, using `sum (join xs)`."},{"role":"assistant","content":"```cryptol\nmodule test::symb_eval::cryptol::size_poly_nested where\n\nf: {m,n} (fin m, fin n) => [m][n][8] -> [8]\nf xs = sum (join xs)\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw\/test-files\/Foo.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the same module Foo with the functions, constant, and record given (id, x, add, foo, getFoo), preserving their types and behavior, and include a property that getFoo foo == 23."},{"role":"assistant","content":"```cryptol\nmodule Foo where\n\nid : {a} a -> a\nid x = x\n\nx : [8]\nx = 255\n\nadd : {a} (fin a) => [a] -> [a] -> [a]\nadd = (+)\n\nfoo : {foo : [32], bar : [32]} \nfoo = {foo = 23, bar = 99}\n\ngetFoo : {foo : [32], bar : [32]}  -> [32]\ngetFoo x = x.foo\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/drbg\/drbg-helpers.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the helper functions and constants for a DRBG based on AES, including keysize, max_seq_number, drbg_generate_seedlen, encrypt_128, and mode constants, suitable for use in verifying an AES-based DRBG implementation."},{"role":"assistant","content":"```cryptol\nimport DRBG\nimport AES\n\ntype keysize = 16 \nmax_seq_number : [blocksize*8]\nmax_seq_number = ~zero\n\ndrbg_generate_seedlen : s2n_drbg -> [seedlen] -> Bit -> ([seedlen], s2n_drbg)\ndrbg_generate_seedlen = drbg_generate `{n=seedlen,blocks=2}\n\nencrypt_128 : [keysize][8] -> [blocksize][8] -> [blocksize][8]\nencrypt_128 key msg =\n  split (block_encrypt (join key) (join msg))\n\nmode_128 = 0\nmode_256 = 1\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/Hashing.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the Hashing module that defines the SHA256\/SHA512 C-style state records, their conversion functions, and the SHA256 init\/update\/digest wrappers operating on SHA512_c_state, matching the given names and types."},{"role":"assistant","content":"```cryptol\nmodule Hashing where\n\nimport SHA256\n\nS2N_HASH_NONE     = 0:[32]\nS2N_HASH_MD5      = 1:[32]\nS2N_HASH_SHA1     = 2:[32]\nS2N_HASH_SHA224   = 3:[32]\nS2N_HASH_SHA256   = 4:[32]\nS2N_HASH_SHA384   = 5:[32]\nS2N_HASH_SHA512   = 6:[32]\nS2N_HASH_MD5_SHA1 = 7:[32]\n\ntype SHA512_c_state =\n  { h      : [8][64]\n  , Nl     : [64]\n  , Nh     : [64]\n  , u      : [16][64]\n  , num    : [32]\n  , md_len : [32]\n  }\ntype SHA512_c_bits = 8*64+64+64+16*64+32+32\n\njoin512_c_state : SHA512_c_state -> [SHA512_c_bits]\njoin512_c_state st = join st.h # st.Nl # st.Nh # join st.u # st.num # st.md_len\n\ntype SHA256_c_state =\n  { h      : [8][32]\n  , Nl     : [32]       , Nh     : [32]       , u      : [16][32]   , num    : [32]       , md_len : [32]       }                   type SHA256_c_bits = 8*32+32+32+16*32+32+32\n\njoin256_c_state : SHA256_c_state -> [SHA256_c_bits]\njoin256_c_state st = join st.h # st.Nl # st.Nh # join st.u # st.num # st.md_len\n\ntype SHA256_DIGEST_LENGTH = 32\ntype SHA512_DIGEST_LENGTH = 64\n\nsha512_c_state_to_sha256_c_state : SHA512_c_state -> SHA256_c_state\nsha512_c_state_to_sha256_c_state st =\n  { h      = split (take bits)\n  , Nl     = take (drop`{front=8*32} bits)\n  , Nh     = take (drop`{front=8*32+32} bits)\n  , u      = split (take (drop`{front=8*32+32+32} bits))\n  , num    = take (drop`{front=8*32+32+32+16*32} bits)\n  , md_len = drop`{front=8*32+32+32+16*32+32} bits\n  }\n  where\n    bits : [SHA256_c_bits]\n    bits = take bits0\n    bits0 : [SHA512_c_bits]\n    bits0 = join512_c_state st\n\nsha256_c_state_to_sha512_c_state : SHA512_c_state -> SHA256_c_state -> SHA512_c_state\nsha256_c_state_to_sha512_c_state st0 st =\n  { h      = split (take bits)\n  , Nl     = take (drop`{front=8*64} bits)\n  , Nh     = take (drop`{front=8*64+64} bits)\n  , u      = split (take (drop`{front=8*64+64+64} bits))\n  , num    = take (drop`{front=8*64+64+64+16*64} bits)\n  , md_len = drop`{front=8*64+64+64+16*64+32} bits\n  }\n  where\n    bits : [SHA512_c_bits]\n    bits = join256_c_state st # drop bits0\n    bits0 : [SHA512_c_bits]\n    bits0 = join512_c_state st0\n\nsha256_c_state_to_sha256_state : SHA256_c_state -> SHA256State\nsha256_c_state_to_sha256_state st =\n  { h     = st.h\n  , block = split (join st.u)\n  , n     = drop st.num\n  , sz    = st.Nh # st.Nl\n  }\n  where\n    bits : [SHA256_c_bits]\n    bits = join256_c_state st\n\nsha256_state_to_sha256_c_state : SHA256State -> SHA256_c_state\nsha256_state_to_sha256_c_state st =\n  { h      = st.h\n  , Nl     = Nl\n  , Nh     = Nh\n  , u      = split (join st.block)\n  , num    = (zero # st.n) : [32]\n  , md_len = `SHA256_DIGEST_LENGTH : [32]\n  }\n  where\n    [Nh, Nl] = split st.sz\n\nsha512_c_state_to_sha256_state : SHA512_c_state -> SHA256State\nsha512_c_state_to_sha256_state st =\n  sha256_c_state_to_sha256_state (sha512_c_state_to_sha256_c_state st)\n\nsha256_state_to_sha512_c_state : SHA512_c_state -> SHA256State -> SHA512_c_state\nsha256_state_to_sha512_c_state st0 st =\n  sha256_c_state_to_sha512_c_state st0 (sha256_state_to_sha256_c_state st)\n\nsha256_init_sha512_c_state : SHA512_c_state -> SHA512_c_state\nsha256_init_sha512_c_state st0_c_512 = st1_c_512\n  where\n    st0_256 = SHA256Init\n    st1_c_512 = sha256_state_to_sha512_c_state st0_c_512 st0_256\n\nsha256_update_sha512_c_state : {n} (fin n) => SHA512_c_state -> [n][8] -> SHA512_c_state\nsha256_update_sha512_c_state st0_c_512 in = st1_c_512\n  where\n    st0_256 = sha512_c_state_to_sha256_state st0_c_512\n    st1_256 = SHA256Update st0_256 in\n    st1_c_512 = sha256_state_to_sha512_c_state st0_c_512 st1_256\n\nsha256_digest_sha512_c_state : SHA512_c_state -> [SHA256_DIGEST_LENGTH][8]\nsha256_digest_sha512_c_state st0_c_512 = out1\n  where\n    st0_256 = sha512_c_state_to_sha256_state st0_c_512\n    out1 = split (SHA256Final st0_256)\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/HMAC_properties.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the HMAC_c_state, hmac_c_state, and hmac_c_state_multi functions for SHA-256 and properties proving they are equivalent to a reference hmacSHA256 implementation, including test-vector properties like those in RFC 4231."},{"role":"assistant","content":"```cryptol\nmodule HMAC_properties where\n\nimport HMAC\nimport Hashing\nimport HMAC_iterative\n\nhmac_c_state : { key_size, msg_size }\n     ( 32 >= width msg_size, 64 >= width (8 * key_size) )\n  => HMAC_c_state -> [key_size][8] -> [msg_size][8] -> [SHA256_DIGEST_LENGTH * 8]\nhmac_c_state st0 key msg = digest\n  where\n  (st1, digest) =\n    hmac_digest_c_state `{block_size=64}\n      (hmac_update_c_state\n        (hmac_init_c_state `{block_size=64,hash_block_size=64,digest_size=SHA256_DIGEST_LENGTH}\n         st0 alg key)\n        msg)\n    alg = S2N_HMAC_SHA256\n\nhmac_c_state_correct : { key_size, msg_size }\n              ( 32 >= width msg_size, 64 >= width (8 * key_size) )\n           => HMAC_c_state -> [key_size][8] -> [msg_size][8] -> Bit\nproperty hmac_c_state_correct st0 key msg =\n  hmacSHA256 key msg == hmac_c_state st0 key msg\n\nhmac_c_state_multi : { key_size, msg_size, msg_chunks}\n     ( 32 >= width msg_size, 64 >= width (8 * key_size), fin msg_chunks )\n  => HMAC_c_state -> [key_size][8] -> [msg_chunks][msg_size][8] -> [SHA256_DIGEST_LENGTH * 8]\nhmac_c_state_multi st0 key msgs = digest\n  where\n    initial_state = (hmac_init_c_state `{block_size=64,hash_block_size=64,digest_size=SHA256_DIGEST_LENGTH}\n         st0 alg key)\n    mid_state = hmac_update_c_state_multi initial_state msgs\n    (st1, digest) = hmac_digest_c_state `{block_size=64} mid_state\n      alg = S2N_HMAC_SHA256\n\nhmac_update_c_state_multi : {msg_size, msg_chunks}\n  ( 32 >= width msg_size, fin msg_chunks)\n  => HMAC_c_state -> [msg_chunks][msg_size][8] -> HMAC_c_state\nhmac_update_c_state_multi st msgs = states ! 0\n  where\n    states = [st] # [hmac_update_c_state s msg | msg <- msgs | s <- states]\n\nhmac_c_state_multi_correct : { key_size, msg_size, msg_chunks }\n              ( 32 >= width msg_size\n              , 64 >= width (8 * key_size)\n              , fin msg_chunks\n              , 32 >= width (msg_chunks * msg_size)\n              , 64 >= width (8 * (64 + msg_size * msg_chunks))\n              )\n           => HMAC_c_state -> [key_size][8] -> [msg_chunks][msg_size][8] -> Bit\nproperty hmac_c_state_multi_correct st0 key msgs =\n    hmacSHA256 key (join msgs) == hmac_c_state_multi st0 key msgs\n\nhmac_update_append x y s =\n  hmac_update_c_state (hmac_update_c_state s x) y == hmac_update_c_state s (x # y)\n\nhash_update_append x y s =\n  hash_update_c_state (hash_update_c_state s x) y == hash_update_c_state s (x # y)\n\nhmac_update_append_init x y k st0 =\n    hmac_update_c_state (hmac_update_c_state s x) y == hmac_update_c_state s (x # y)\n    where\n      s = hmac_init_c_state st0 S2N_HMAC_SHA256 k\n\nproperty hash_update_empty s = hash_update_c_state s [] == s\n\nproperty hmac_update_empty s =\n  s.currently_in_hash_block == s.currently_in_hash_block % (zero # s.block_size)\n  ==>\n  hmac_update_c_state s [] == s\n\nproperty pass =\n    ~zero ==\n    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] \"Hi There\" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\n    , hmacSHA256 \"Jefe\" \"what do ya want for nothing?\" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\n    ]\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the SHA-256 hash function, including both functional and imperative-style interfaces, and properties that (1) check known-answer test vectors and (2) prove the imperative SHA256Imp implementation is equivalent to the functional SHA256 for all messages."},{"role":"assistant","content":"```cryptol\nmodule SHA256 where\n\nCh : [32] -> [32] -> [32] -> [32]\nCh x y z = (x && y) ^ (~x && z)\n\nMaj : [32] -> [32] -> [32] -> [32]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nS0 : [32] -> [32]\nS0 x = (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)\n\nS1 : [32] -> [32]\nS1 x = (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)\n\ns0 : [32] -> [32]\ns0 x = (x >>> 7) ^ (x >>> 18) ^ (x >> 3)\n\ns1 : [32] -> [32]\ns1 x = (x >>> 17) ^ (x >>> 19) ^ (x >> 10)\n\nK : [64][32]\nK = [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n     ]\n\npreprocess : {msgLen,contentLen,chunks,padding}\n     ( fin msgLen\n     , 64 >= width msgLen                                   , contentLen == msgLen + 65                            , chunks     == (contentLen+511) \/ 512\n     , padding    == (512 - contentLen % 512) % 512         )\n     => [msgLen] -> [chunks][512]\npreprocess msg = split (msg # [True] # (zero:[padding]) # (`msgLen:[64]))\n\nH0 : [8][32]\nH0 = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n       0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]\n\nSHA256MessageSchedule : [16][32] -> [64][32]\nSHA256MessageSchedule M = W where\n    W = M # [ s1 (W@(j-2)) + (W@(j-7)) + s0 (W@(j-15)) + (W@(j-16)) | j <- [16 .. 63]:[_][8] ]\n\nSHA256Compress : [8][32] -> [64][32] -> [8][32]\nSHA256Compress H W = [as!0 + H@0, bs!0 + H@1, cs!0 + H@2, ds!0 + H@3, es!0 + H@4, fs!0 + H@5, gs!0 + H@6, hs!0 + H@7] where\n    T1 = [h + S1 e + Ch e f g  + k + w | h <- hs | e <- es | f <- fs | g <- gs | k <- K | w <- W]\n    T2 = [S0 a  + Maj a b c  | a <- as | b <- bs | c <- cs]\n    hs = take `{65} ([H@7] # gs)\n    gs = take `{65} ([H@6] # fs)\n    fs = take `{65} ([H@5] # es)\n    es = take `{65} ([H@4] # [d + t1 | d <- ds | t1 <- T1])\n    ds = take `{65} ([H@3] # cs)\n    cs = take `{65} ([H@2] # bs)\n    bs = take `{65} ([H@1] # as)\n    as = take `{65} ([H@0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\nSHA256Block : [8][32] -> [16][32] -> [8][32]\nSHA256Block H M = SHA256Compress H (SHA256MessageSchedule M)\n\nSHA256' : {a} (fin a) => [a][16][32] -> [8][32]\nSHA256' blocks = hash!0 where\n    hash = [H0] # [SHA256Block h b | h <- hash | b <- blocks]\n\nSHA256 : {a} (fin a, 64 >= width (8*a)) => [a][8] -> [256]\nSHA256 msg =   join (SHA256' [ split x | x <- preprocess(join msg)])\n\nproperty katsPass = ~zero == [test == kat | (test,kat) <- kats ]\n\nkats = [ (SHA256 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n         , 0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1)\n       , (SHA256 \"\"\n         ,0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855)\n       , (SHA256 \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n         , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1)\n       \/\/ , ([0x61 | i <- [1..1000000] : [_][32]]\n       \/\/   , 0xcdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0)\n       ]\n\n\/\/\/\/\/\/\/\/ Imperative top level \/\/\/\/\/\/\/\/\n\ntype SHA256State = { h : [8][32]\n                   , block : [64][8]\n                   , n : [16]\n                   , sz : [64]\n                   }\n\nSHA256Init : SHA256State\nSHA256Init = { h = H0\n             , block = zero\n             , n = 0\n             , sz = 0\n             }\n\nSHA256Update1 : SHA256State -> [8] -> SHA256State\nSHA256Update1 s b =\n  if s.n == 64\n    then { h = SHA256Block s.h (split (join s.block))\n         , block = [b] # zero\n         , n = 1\n         , sz = s.sz + 8\n         }\n    else { h = s.h\n         , block = update s.block s.n b\n         , n = s.n + 1\n         , sz = s.sz + 8\n         }\n\nSHA256Update : {n} (fin n) => SHA256State -> [n][8] -> SHA256State\nSHA256Update sinit bs = ss!0\n  where ss = [sinit] # [ SHA256Update1 s b | s <- ss | b <- bs ]\n\n\/\/ Add padding and size and process the final block.\nSHA256Final : SHA256State -> [256]\nSHA256Final s = join (SHA256Block h b')\n      where s' = SHA256Update1 s 0x80\n        \/\/ Don't need to add zeros. They're already there. Just update\n        \/\/ the count of bytes in this block. After adding the 1 pad, there\n        \/\/ are two possible cases: the size will fit in the current block,\n        \/\/ or it won't.\n        (h, b) = if s'.n <= 56 then (s'.h, s'.block)\n                 else (SHA256Block s'.h (split (join s'.block)), zero)\n        b' = split (join b || (zero # s.sz))\n\nSHA256Imp : {a} (64 >= width (8*a)) => [a][8] -> [256]\nSHA256Imp msg = SHA256Final (SHA256Update SHA256Init msg)\n\nproperty katsPassImp = ~zero == [test == kat | (test,kat) <- katsImp ]\n\nkatsImp = [ (SHA256Imp \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n            , 0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1)\n          , (SHA256Imp \"\"\n            , 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855)\n          , (SHA256Imp \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n            , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1)\n                              ]\n\nproperty imp_correct msg = SHA256 msg == SHA256Imp msg\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/modthm.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function and property `modthm_precond : [32] -> [32] -> [32] -> [16] -> [16] -> Bit` that asserts `modthm` holds for valid hash and block sizes (64 or 128), matching the given modular arithmetic relation and `valid_block_sizes` predicate."},{"role":"assistant","content":"```cryptol\nvalid_block_sizes : [16] -> [16] -> Bit\nvalid_block_sizes hbs bs =\n        ((bs, hbs) == (64, 64)) ||\n  ((bs, hbs) == (128, 128))\n\nmodthm : [32] -> [32] -> [32] -> [16] -> [16] -> Bit\nmodthm x11 x15 x16 hash_block_size block_size =\n  ((((x11 + (x16 % x17)) % x18) + (x15 % x17)) % x18)\n  ==\n  ((x11 + ((x16 + x15) % x17)) % x18)\n  where x17 = zero # hash_block_size\n        x18 = zero # block_size\n\nmodthm_precond : [32] -> [32] -> [32] -> [16] -> [16] -> Bit\nmodthm_precond x11 x15 x16 hash_block_size block_size =\n  if (valid_block_sizes hash_block_size block_size) then\n    modthm x11 x15 x16 hash_block_size block_size\n  else True\n```"}]}
{"filename":"saw-script\/saw-python\/tests\/saw-in-progress\/HMAC\/spec\/HMAC_iterative.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification and associated properties for the HMAC_iterative module that model iterative HMAC-SHA256\/SHA512 initialization, update, and digest functions over SHA512_c_state, including both bounded and unbounded key\/message variants, suitable for formal verification with SAW."},{"role":"assistant","content":"```cryptol\nmodule HMAC_iterative where\n\nimport Array\nimport SHA256\nimport Hashing\n\nS2N_HMAC_NONE       = 0:[32]\nS2N_HMAC_MD5        = 1:[32]\nS2N_HMAC_SHA1       = 2:[32]\nS2N_HMAC_SHA224     = 3:[32]\nS2N_HMAC_SHA256     = 4:[32]\nS2N_HMAC_SHA384     = 5:[32]\nS2N_HMAC_SHA512     = 6:[32]\nS2N_HMAC_SSLv3_MD5  = 7:[32]\nS2N_HMAC_SSLv3_SHA1 = 8:[32]\n\ntype HMAC_c_state =\n  { alg                     : [32]\n  , hash_block_size         : [16]\n  , currently_in_hash_block : [32]\n  , block_size              : [16]\n  , digest_size             : [8]\n  , inner                   : SHA512_c_state\n  , inner_just_key          : SHA512_c_state\n  , outer                   : SHA512_c_state\n  , outer_just_key          : SHA512_c_state\n  , xor_pad                 : [128][8]\n  , digest_pad              : [SHA512_DIGEST_LENGTH][8]\n  }\n\ntype ByteArray = Array[64][8]\n\ntype hash_init_ty =\n  SHA512_c_state -> SHA512_c_state\ntype hash_update_ty msg_size =\n  SHA512_c_state -> [msg_size][8] -> SHA512_c_state\ntype hash_digest_ty digest_size =\n  SHA512_c_state -> [digest_size][8]\n\nhash_init_c_state : hash_init_ty\nhash_init_c_state = sha256_init_sha512_c_state\n\nhash_update_c_state :\n  {msg_size} (fin msg_size) => hash_update_ty msg_size\nhash_update_c_state = sha256_update_sha512_c_state\nhash_update_c_state_unbounded :\n  SHA512_c_state -> ByteArray -> [32] -> SHA512_c_state\nhash_update_c_state_unbounded = undefined\n\nhash_digest_c_state :\n  {digest_size} (fin digest_size) => hash_digest_ty digest_size\nhash_digest_c_state st =\n  take `{digest_size}\n    (sha256_digest_sha512_c_state st # (zero : [inf][8]))\n\nkey_init_c_state : { key_size, block_size, digest_size }\n        ( fin key_size, fin block_size,\n          SHA512_DIGEST_LENGTH >= digest_size )\n     => SHA512_c_state\n     -> [SHA512_DIGEST_LENGTH][8]\n     -> [key_size][8]\n     -> (SHA512_c_state, [SHA512_DIGEST_LENGTH][8], [block_size][8])\nkey_init_c_state outer0 digest_pad0 key =\n  if `key_size > (`block_size : [max (width key_size) (width block_size)])\n  then (outer2, digest_pad1, hash')\n  else (outer1, digest_pad0, key')\n  where\n  outer1 = hash_init_c_state outer0\n\n    outer2 = hash_update_c_state outer1 key\n  hash : [digest_size][8]\n  hash = hash_digest_c_state outer2\n  digest_pad1 = hash # drop `{digest_size} digest_pad0\n  hash' = take `{block_size} (hash # (zero : [block_size][8]))\n\n  \/\/ Short key.\n  key' = take `{block_size} (key # (zero : [block_size][8]))\n\nkey_init_c_state_unbounded : { block_size, digest_size }\n        ( 16 >= width block_size, SHA512_DIGEST_LENGTH >= digest_size )\n     => SHA512_c_state\n     -> [SHA512_DIGEST_LENGTH][8]\n     -> ByteArray\n     -> [32]\n     -> (SHA512_c_state, [SHA512_DIGEST_LENGTH][8], [block_size][8])\nkey_init_c_state_unbounded outer0 digest_pad0 key klen =\n  if klen > (`block_size : [32])\n  then (outer2, digest_pad1, hash')\n  else (outer1, digest_pad0, key')\n  where\n  outer1 = hash_init_c_state outer0\n\n    outer2 = hash_update_c_state_unbounded outer1 key klen\n  hash : [digest_size][8]\n  hash = hash_digest_c_state outer2\n  digest_pad1 = hash # drop `{digest_size} digest_pad0\n  hash' = take `{block_size} (hash # (zero : [block_size][8]))\n\n  \/\/ Short key.\n  key' = map\n    (\\i -> if (i <$ (0 # klen)) then (arrayLookup key i) else 0)\n    (take`{block_size} [0 .. block_size])\n\nhmac_init_c_state :\n     { key_size, block_size, hash_block_size, digest_size }\n     ( fin key_size\n     , 64 >= width (8*key_size)\n     , 16 >= width hash_block_size\n     , 16 >= width block_size\n     , 8 >= width digest_size\n     , 128 >= block_size\n     , 64 >= digest_size )\n  => HMAC_c_state\n  -> [32]\n  -> [key_size][8]\n  -> HMAC_c_state\nhmac_init_c_state st0 alg key =\n  { alg                     = alg\n  , hash_block_size         = `hash_block_size\n  , currently_in_hash_block = currently_in_hash_block\n  , block_size              = `block_size\n  , digest_size             = `digest_size\n\n  , inner                   = inner\n  , inner_just_key          = inner_just_key\n  , outer                   = outer\n  , outer_just_key          = outer_just_key\n  , xor_pad                 = xor_pad\n  , digest_pad              = digest_pad\n  }\n  where\n    currently_in_hash_block = 0\n\n    k0 : [block_size][8]\n    (outer, digest_pad, k0) =\n      key_init_c_state `{digest_size=digest_size} st0.outer st0.digest_pad key\n    ikey = [ k ^ 0x36 | k <- k0 ]\n    okey = [ k ^ 0x6a | k <- ikey ]\n\n    inner_just_key = hash_update_c_state\n      (hash_init_c_state st0.inner_just_key) ikey\n    inner          = inner_just_key\n    outer_just_key = hash_update_c_state\n      (hash_init_c_state st0.outer_just_key) okey\n    xor_pad = zero \nhmac_init_c_state_unbounded :\n     { block_size, hash_block_size, digest_size }\n     ( 16 >= width hash_block_size\n     , 16 >= width block_size\n     , 8 >= width digest_size\n     , 128 >= block_size\n     , 64 >= digest_size )\n  => HMAC_c_state\n  -> [32]\n  -> ByteArray\n  -> [32]\n  -> HMAC_c_state\nhmac_init_c_state_unbounded st0 alg key klen =\n  { alg                     = alg\n  , hash_block_size         = `hash_block_size\n  , currently_in_hash_block = currently_in_hash_block\n  , block_size              = `block_size\n  , digest_size             = `digest_size\n\n  , inner                   = inner\n  , inner_just_key          = inner_just_key\n  , outer                   = outer\n  , outer_just_key          = outer_just_key\n  , xor_pad                 = xor_pad\n  , digest_pad              = digest_pad\n  }\n  where\n    currently_in_hash_block = 0\n\n    k0 : [block_size][8]\n    (outer, digest_pad, k0) =\n      key_init_c_state_unbounded `{digest_size=digest_size}\n        st0.outer st0.digest_pad key klen\n    ikey = [ k ^ 0x36 | k <- k0 ]\n    okey = [ k ^ 0x6a | k <- ikey ]\n\n    inner_just_key = hash_update_c_state\n      (hash_init_c_state st0.inner_just_key) ikey\n    inner          = inner_just_key\n    outer_just_key = hash_update_c_state\n      (hash_init_c_state st0.outer_just_key) okey\n    xor_pad = zero \n\nhmac_update_c_state : {msg_size} (32 >= width msg_size) =>\n  HMAC_c_state -> [msg_size][8] -> HMAC_c_state\nhmac_update_c_state s m =\n  { inner = hash_update_c_state s.inner m\n  , currently_in_hash_block =\n      (s.currently_in_hash_block + (`msg_size % (zero # s.hash_block_size))) %\n      (zero # s.block_size)\n\n    , alg             = s.alg\n  , hash_block_size = s.hash_block_size\n  , block_size      = s.block_size\n  , digest_size     = s.digest_size\n  , inner_just_key  = s.inner_just_key\n  , outer           = s.outer\n  , outer_just_key  = s.outer_just_key\n  , xor_pad         = s.xor_pad\n  , digest_pad      = s.digest_pad\n  }\n\nhmac_update_c_state_unbounded :\n  HMAC_c_state -> ByteArray -> [32] -> HMAC_c_state\nhmac_update_c_state_unbounded s m sz =\n  { inner = hash_update_c_state_unbounded s.inner m sz\n  , currently_in_hash_block =\n      (s.currently_in_hash_block + (sz % (zero # s.hash_block_size))) %\n      (zero # s.block_size)\n\n    , alg             = s.alg\n  , hash_block_size = s.hash_block_size\n  , block_size      = s.block_size\n  , digest_size     = s.digest_size\n  , inner_just_key  = s.inner_just_key\n  , outer           = s.outer\n  , outer_just_key  = s.outer_just_key\n  , xor_pad         = s.xor_pad\n  , digest_pad      = s.digest_pad\n  }\n\nhmac_digest_c_state :\n     { block_size, digest_size }\n     ( 64 >= digest_size\n     , 128 >= block_size )\n  => HMAC_c_state -> (HMAC_c_state, [8 * digest_size])\nhmac_digest_c_state s = (sout, out)\n  where\n    hin : [digest_size][8]\n    hin = hash_digest_c_state inner\n    digest_pad : [SHA512_DIGEST_LENGTH][8]\n    digest_pad = hin # zero\n\n    okey : [block_size][8]\n    okey = take s.xor_pad\n\n                                                        outer = hash_update_c_state s.outer_just_key hin\n    inner = s.inner\n\n    out = join (hash_digest_c_state outer)\n\n    sout : HMAC_c_state\n    sout =\n      { inner      = inner\n      , outer      = s.outer_just_key\n      , digest_pad = digest_pad\n\n            , alg                     = s.alg\n      , hash_block_size         = s.hash_block_size\n      , currently_in_hash_block = s.currently_in_hash_block\n      , block_size              = s.block_size\n      , digest_size             = s.digest_size\n      , inner_just_key          = s.inner_just_key\n      , outer_just_key          = s.outer_just_key\n      , xor_pad                 = s.xor_pad\n      }\n```"}]}
{"filename":"saw-script\/exercises\/sha512\/SHA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the SHA-2 family compression-based hash (parameterized by word size w, constants H0 and K) and define the externally visible function `SHAImp : {n} (fin n) => [n][8] -> [digest_size]` that hashes a byte sequence into a digest of length `digest_size`."},{"role":"assistant","content":"```cryptol\nmodule SHA where\n\nsha : {L} (2 * w >= width L) => [L] -> [digest_size]\nsha M = take (join (SHA_2_Common' [ split x | x <- parse`{num_blocks L} (pad`{L} M) ]))\n\nparameter\n\n  \/** Word size\n    Specifications are based on word size w, rather than digest size (8 * w)\n    or block size (m == 16 * w), in order to avoid confusing Cryptol's type\n    constraint verifier with integer division.\n  *\/\n\n  type w : #\n  type constraint (fin w, w >= 2, 32 >= width w)\n\n  type digest_size : #\n  type constraint (fin digest_size, 8*w >= digest_size)\n\n  type j : #\n  type constraint (fin j, j >= 17)\n\n  H0 : [8][w]\n  K  : [j][w]\n\n  SIGMA_0 : [w] -> [w]\n  SIGMA_1 : [w] -> [w]\n  sigma_0 : [w] -> [w]\n  sigma_1 : [w] -> [w]\n\nSHAH0 = H0\nS0 = SIGMA_0\nS1 = SIGMA_1\ns0 = sigma_0\ns1 = sigma_1\n\nCh : [w] -> [w] -> [w] -> [w]\nCh x y z = (x && y) ^ (~x && z)\n\nMaj : [w] -> [w] -> [w] -> [w]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nprocessBlock_Common : [8][w] -> [16][w] -> [8][w]\nprocessBlock_Common H Mi = compress_Common H (messageSchedule_Common Mi)\n\nprivate\n\n  type block_size = 16 * w\n\n  type num_blocks L     = (L+1+2*w) \/^ block_size\n  type padded_size L    = num_blocks L * block_size\n\n  pad : {L} (2 * w >= width L) => [L] -> [padded_size L]\n  pad M = M # 0b1 # zero # (`L : [2*w])\n\n  parse : {m} [m * block_size] -> [m][block_size]\n  parse = split\n\n  messageSchedule_Common : [16][w] -> [j][w]\n  messageSchedule_Common Mi = take W\n    where\n    W : [inf][_]\n    W = Mi # [ w1 + s0 w2 + w3 + s1 w4\n             | w1 <- W\n             | w2 <- drop`{1} W\n             | w3 <- drop`{9} W\n             | w4 <- drop`{14} W\n             ]\n\n  compress_Common : [8][w] -> [j][w] -> [8][w]\n  compress_Common H W =\n        [ (as ! 0) + (H @ 0),\n      (bs ! 0) + (H @ 1),\n      (cs ! 0) + (H @ 2),\n      (ds ! 0) + (H @ 3),\n      (es ! 0) + (H @ 4),\n      (fs ! 0) + (H @ 5),\n      (gs ! 0) + (H @ 6),\n      (hs ! 0) + (H @ 7)\n    ]\n    where\n      T1 = [h + S1 e + Ch e f g + k_t + w_t\n                | h <- hs | e <- es | f <- fs | g <- gs | k_t <- K | w_t <- W]\n      T2 = [ S0 a + Maj a b c | a <- as | b <- bs | c <- cs]\n      hs = take`{j + 1}([H @ 7] # gs)\n      gs = take`{j + 1}([H @ 6] # fs)\n      fs = take`{j + 1}([H @ 5] # es)\n      es = take`{j + 1}([H @ 4] # [d + t1 | d <- ds | t1 <- T1])\n      ds = take`{j + 1}([H @ 3] # cs)\n      cs = take`{j + 1}([H @ 2] # bs)\n      bs = take`{j + 1}([H @ 1] # as)\n      as = take`{j + 1}([H @ 0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\n  SHA_2_Common' : {L} (fin L) => [L][16][w] -> [8][w]\n  SHA_2_Common' blocks = hash ! 0\n    where\n    hash = [H0] # [ processBlock_Common h b | h <- hash | b <- blocks]\n\ntype SHAState = { h : [8][w]\n                , block : [w * 2][8]\n                , n : [32]\n                , sz : [w * 2]\n                }\n\nSHAInit : SHAState\nSHAInit = { h = H0\n          , block = zero\n          , n = 0\n          , sz = 0\n          }\n\nSHAUpdate : {n} (fin n) => SHAState -> [n][8] -> SHAState\nSHAUpdate sinit bs = ss!0\n  where ss = [sinit] # [ SHAUpdate1 s b | s <- ss | b <- bs ]\n\nSHAFinal : SHAState -> [digest_size]\nSHAFinal s = take (join (processBlock_Common h b'))\n  \/\/ Because the message is always made up of bytes, and the size is a\n  \/\/ fixed number of bytes, the 1 pad will always be at least a byte.\n  where s' = SHAUpdate1 s 0x80\n                                        (h, b) = if s'.n <= (`w*2 - (`w\/4)) then (s'.h, s'.block)\n                 else (processBlock_Common s'.h (split (join s'.block)), zero)\n        b' = split (join b || (zero # s.sz))\n\nSHAImp : {n} (fin n) => [n][8] -> [digest_size]\nSHAImp msg = SHAFinal (SHAUpdate SHAInit msg)\n\nprivate\n\n          SHAUpdate1 : SHAState -> [8] -> SHAState\n  SHAUpdate1 s b =\n    if s.n == (2 * `w - 1)\n      then { h = processBlock_Common s.h (split (join (update s.block s.n b)))\n           , block = zero\n           , n = 0\n           , sz = s.sz + 8\n           }\n      else { h = s.h\n           , block = update s.block s.n b\n           , n = s.n + 1\n           , sz = s.sz + 8\n           }\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/point\/Point.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the Point type, POINT_ZERO, point_add, and the property point_add_commutes stating that point_add is commutative for all Points."},{"role":"assistant","content":"```cryptol\nmodule Point where\n\ntype Point = {x : [32], y : [32]}\n\nPOINT_ZERO : Point\nPOINT_ZERO = zero\n\npoint_add : Point -> Point -> Point\npoint_add p1 p2 = { x = p1.x + p2.x, y = p1.y + p2.y }\n\npoint_add_commutes : Point -> Point -> Bit\nproperty point_add_commutes p1 p2 = point_add p1 p2 == point_add p2 p1\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/popcount\/Popcount.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function popCount : [32] -> [32] that counts the number of set bits (population count) in a 32-bit input using the given iterative construction pattern."},{"role":"assistant","content":"```cryptol\nmodule Popcount where\n\npopCount : [32] -> [32]\npopCount bits = ic ! 0 where\n     ic = [0] # [ if elt then prev + 1 else prev | elt <- bits | prev <- ic]\n```"}]}
{"filename":"saw-script\/exercises\/functional-correctness\/swap\/solution\/Swap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions swap_list, argmin, and selection_sort as given, and includes the properties swap_list_same and sort_eq to verify swap_list is a no-op when indices are equal and selection_sort matches Cryptol\u2019s sort."},{"role":"assistant","content":"```cryptol\nmodule Swap where\n\nswap_list : {n} [n][32] -> [64] -> [64] -> [n][32]\nswap_list lst i j = update (update lst i jval) j ival\n    where ival = lst @ i\n          jval = lst @ j\n\nargmin : {n} (fin n) => [n][32] -> [64]\nargmin lst =\n    (foldl' min (-1 : [32], -1 : [64]) [(x, i) | x <- lst | i <- [0...]]).1\n\nselection_sort : {n} (fin n, 64 >= width n) => [n][32] -> [n][32]\nselection_sort lst = go`{0} lst\n    where\n        go : {idx} (fin idx, fin n, 64 >= width idx, 64 >= width n, n >= idx) => [n][32] -> [n][32]\n        go acc =\n            if `idx == `n\n            then acc\n            else go`{min n (idx + 1)}\n                    (swap_list acc `idx (`idx + (argmin (drop`{idx} acc))))\n\n\/\/ NOTE: Have to be careful.  Just running :check on this will likely crash because a random index is likely out of bounds (especailly because `n will default to 0)\nswap_list_same : {n} (fin n) => [64] -> [n][32] -> Bit\nproperty swap_list_same i lst = (swap_list lst i i) == lst\n\nsort_eq : {n} (fin n, 64 >= width n) => [n][32] -> Bit\nproperty sort_eq lst = selection_sort lst == sort lst\n```"}]}
{"filename":"saw-script\/examples\/sequential_aigs\/fib.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that prove fib1 and fib2 are equivalent on all input streams, and that each buggy_fib variant (4-, 8-, 12-, 16-, 32-, 64-bit) differs from fib1 at least once on some input sequence."},{"role":"assistant","content":"```cryptol\nimport StateMachine\n\nfib1_no_init : ([1], ([8], [8])) -> ([8], ([8], [8]))\nfib1_no_init (_, (fn, fn1)) = (fn, (fn1, fn2))\n  where\n  fn2 = fn + fn1\n\nfib1 = init_with (0, 1) fib1_no_init\nfib1_state_bits = 1 + 8 + 8 : [8]\n\nfib2 : ([1], ([1], [16], [16])) -> ([8], ([1], [16], [16]))\nfib2 (_, (start, fn , fn1)) = (fn', (1, fn1', fn2))\n  where\n    fn1' = (zero # start) * fn1 + (zero # ~start)\n  fn2 = fn + fn1'\n  fn' = drop`{8} fn\n\nfib2_state_bits = 1 + 16 + 16 : [8]\n\n\/\/ Make a buggy version of fib state machine which returns wrong value\n\/\/ when state counter has magic value.\n\/\/\n\/\/ If this were a common pattern for example generation, we could\n\/\/ make a \"magic-value bug\" combinator in the style of 'init_with'.\nmk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n    fn' = fn + (if k == magic then 1 else 0)\n\nmk_buggy_fib magic = init_with (0, 1, 0) (mk_buggy_fib_no_init magic)\ncount_buggy_state_bits : {a} (fin a, width a <= 7) => [a] -> [8]\ncount_buggy_state_bits magic = 1 + 8 + 8 + `a\n\n\/\/ 4-bit counter\nbuggy_fib4_magic = 0xf\nbuggy_fib4 = mk_buggy_fib buggy_fib4_magic\nbuggy_fib4_state_bits = count_buggy_state_bits buggy_fib4_magic\n\n\/\/ 8-bit counter\nbuggy_fib8_magic = 0xff\nbuggy_fib8 = mk_buggy_fib buggy_fib8_magic\nbuggy_fib8_state_bits = count_buggy_state_bits buggy_fib8_magic\n\n\/\/ 12-bit counter\nbuggy_fib12_magic = 0b111111111111\nbuggy_fib12 = mk_buggy_fib buggy_fib12_magic\nbuggy_fib12_state_bits = count_buggy_state_bits buggy_fib12_magic\n\n\/\/ 16-bit counter\nbuggy_fib16_magic = 0xffff\nbuggy_fib16 = mk_buggy_fib buggy_fib16_magic\nbuggy_fib16_state_bits = count_buggy_state_bits buggy_fib16_magic\n\n\/\/ 32-bit counter\nbuggy_fib32_magic = 0xffffffff\nbuggy_fib32 = mk_buggy_fib buggy_fib32_magic\nbuggy_fib32_state_bits = count_buggy_state_bits buggy_fib32_magic\n\n\/\/ 64-bit counter\nbuggy_fib64_magic = 0xffffffffffffffff\nbuggy_fib64 = mk_buggy_fib buggy_fib64_magic\nbuggy_fib64_state_bits = count_buggy_state_bits buggy_fib64_magic\n\n\/\/ Tests.\ninputs : [1000][1]\ninputs = zero\n\ntest = equiv fib1 fib2 inputs\n\n\/\/ The states sequences.\nstates1 = exec fib1 inputs\nstates2 = exec fib2 inputs\n```"}]}
{"filename":"saw-script\/examples\/sequential_aigs\/CipherMode.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `CipherMode` that defines ECB, CBC, PCBC, CFB, OFB, and CTR block cipher modes as state machines over a generic block cipher type `BC`, matching the given type signatures and behavior for state updates and ciphertext computation."},{"role":"assistant","content":"```cryptol\nmodule CipherMode where\n\nimport StateMachine\n\ntype BC k n = [k] -> [n] -> [n]\n\necb : {k, n} BC k n -> SM ([k], [n]) [n] (Bool, [k])\necb bc = init i sm\n  where\n  sm : SM [n] [n] [k]\n  sm (block, key) = (ct, key)\n    where\n    ct = bc key block\n  i : [k] -> [k]\n  i key = key\n\ncbc : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\ncbc bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key (state ^ block)\n    state' = ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\npcbc : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\npcbc bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key (state ^ block)\n    state' = block ^ ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\ncfb : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\ncfb bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    ct = bc key state ^ block\n    state' = ct\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\nofb : {k, n} BC k n -> SM (([k], [n]), [n]) [n] (Bool, ([k], [n]))\nofb bc = init i sm\n  where\n  sm : SM [n] [n] ([k], [n])\n  sm (block, (key, state)) = (ct, (key, state'))\n    where\n    state' = bc key state\n    ct = state' ^ block\n  i : ([k], [n]) -> ([k], [n])\n  i (key, iv) = (key, iv)\n\n\/\/ CounTer Mode.\nctr : {k, n} (fin n, n >= 1) =>\n  BC k (2*n) -> SM (([k], [n]), [2*n]) [2*n] (Bool, ([k], [n], [n]))\nctr bc = init i sm\n  where\n  sm : SM [2*n] [2*n] ([k], [n], [n])\n  sm (block, (key, iv, counter)) = (ct, (key, iv, counter + 1))\n    where\n    ct = bc key (iv # counter) ^ block\n  i : ([k], [n]) -> ([k], [n], [n])\n  i (key, iv) = (key, iv, 0)\n```"}]}
{"filename":"saw-script\/examples\/sequential_aigs\/exp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol that the state machines exp_ref and exp_opt, which implement exponentiation via iterative multiplication and exponentiation by squaring, are functionally equivalent using the synced_exp and mitered_exp constructions."},{"role":"assistant","content":"```cryptol\nimport StateMachine\n\nexp_ref : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) (Bool, [m]) (Bool, ([m], [n], [m]))\nexp_ref = mk_loop (\\(x, p) -> (x, p, 1)) body\n  where\n  body : Body [m] ([m], [n], [m])\n  body (x, p', r) =\n    if p' == 0\n    then ((True, r), (x, p', r))\n    else ((False, zero), (x, p' - 1, r * x))\n\nexp_opt : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) (Bool, [m]) (Bool, ([m], [n], [m]))\nexp_opt = mk_loop (\\(x, p) -> (x, p, 1)) body\n  where\n  body : Body [m] ([m], [n], [m])\n  body (x', p', r) =\n    if p' == 0\n    then ((True, r), (x', p', r))\n    else ((False, zero), (x' * x', p' >> 1, r'))\n      where\n      r' = if (p' && 1) != 0\n           then r * x'\n           else r\n\nsynced_exp : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  [1] -> SM ([m], [n]) (Bool, [m]) ((Bool, ([m], [n], [m])), (Bool, ([m], [n], [m])))\nsynced_exp bias = sync_loops bias exp_ref exp_opt\n\nmitered_exp : {m, n} (m >= 1, n >= 1, fin m, fin n) =>\n  SM ([m], [n]) Bool ((Bool, ([m], [n], [m])), (Bool, ([m], [n], [m])))\nmitered_exp = miter_loops exp_ref exp_opt\n```"}]}
{"filename":"saw-script\/examples\/sequential_aigs\/StateMachine.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines these state machine combinators (SM, run, eval, exec, equiv, init_with, init, miter, mk_loop, run_loop, sync_loops, miter_loops, const_true\/false, sat_miter, unsat_miter) with the same types and behavior, suitable for verification of sequential AIG circuits."},{"role":"assistant","content":"```cryptol\nmodule StateMachine where\n\ntype SM i o s = (i, s) -> (o, s)\n\nrun : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](o,s)\nrun sm is = oss\n  where\n  states = [zero] # [ os.1 | os <- oss ]\n  oss = [ sm (i, s) | i <- is | s <- states ]\n\neval : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](o)\neval sm is = [ os.0 | os <- run sm is ]\n\nexec : {n, i, s, o} (Zero s) => SM i o s -> [n]i -> [n](s)\nexec sm is = [ os.1 | os <- run sm is ]\n\nequiv : {n, i, s1, s2, o} (Cmp o, fin n, Zero s1, Zero s2)\n     => SM i o s1 -> SM i o s2 -> [n]i -> Bool\nequiv sm1 sm2 is = all [ o1 == o2 | o1 <- eval sm1 is | o2 <- eval sm2 is ]\n  where\n  all : {m} (fin m) => [m]Bool -> Bool\n  all xs = its ! 0\n    where\n    its = [True] # [ x && it | x <- xs | it <- its ]\n\ninit_with : {i, o, s} s -> SM i o s -> SM i o (Bool, s)\ninit_with s_initial sm (i, (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else s_initial\n  (o, s'') = sm (i, s')\n\ninit : {a, i, o, s}\n  (a -> s) -> SM i o s -> SM (a, i) o (Bool, s)\ninit mk_s_initial sm ((a, i), (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else mk_s_initial a\n  (o, s'') = sm (i, s')\n\nmiter : {i, o, s1, s2} (Cmp o) =>\n  SM i o s1 -> SM i o s2 -> SM i Bool (s1, s2)\nmiter sm1 sm2 (i, (s1, s2)) = (o, (s1', s2'))\n  where\n  (o1, s1') = sm1 (i, s1)\n  (o2, s2') = sm2 (i, s2)\n  o = o1 != o2\n\nconst_false : {i} SM i Bool [1]\nconst_false (_, _) = (False, zero)\n\nconst_true : {i} SM i Bool [1]\nconst_true (_, _) = (True, zero)\n\nsat_miter : SM [1] Bool ([1], [1])\nsat_miter = miter const_true const_false\nunsat_miter : SM [1] Bool ([1], [1])\nunsat_miter = miter const_true const_true\n\ntype Body o s = s -> ((Bool, o), s)\n\nmk_loop : {i,o,s} (i -> s) -> Body o s -> SM i (Bool, o) (Bool, s)\nmk_loop initializer body (i, (started, s)) = (o, (True, s''))\n  where\n  s' = if started then s else initializer i\n  (o, s'') = body s'\n\nrun_loop : {n, i, o, s} (fin n, n >= 1, Zero i, Zero s) =>\n  SM i o s -> i -> [n](o, s)\nrun_loop loop i = run loop ([i] # zero)\n\nsync_loops : {i, o, s1, s2} (Zero o) =>\n  [1] -> SM i (Bool, o) s1 -> SM i (Bool, o) s2 -> SM i (Bool, o) (s1, s2)\nsync_loops bias l1 l2 (i, (s1, s2)) = ((done, o'), (s1', s2'))\n  where\n  ((done1, o1), s1') = l1 (i, s1)\n  ((done2, o2), s2') = l2 (i, s2)\n  o = [o1, o2] @ bias\n  done = done1 && done2\n  o' = if done then o else zero\n\nmiter_loops : {i, o, s1, s2} (Cmp o) =>\n  SM i (Bool, o) s1 -> SM i (Bool, o) s2 -> SM i Bool (s1, s2)\nmiter_loops l1 l2 (i, (s1, s2)) = (o', (s1', s2'))\n  where\n  ((done1, o1), s1') = l1 (i, s1)\n  ((done2, o2), s2') = l2 (i, s2)\n  done = done1 && done2\n  o' = if done then o1 != o2 else False\n```"}]}
{"filename":"saw-script\/examples\/openssl_aes\/AES128TBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of AES-128 using T-tables, including encryption\/decryption functions, key schedule, S-box\/inverse S-box, and properties AESTests, sboxUnsboxInverse, keyExpansionInjective, and encDecInverse as given."},{"role":"assistant","content":"```cryptol\nmodule AESTBox where\n\ntype GF28 = [8]\ntype Nk = 4\ntype Nb = 4\ntype Nr = 6 + Nk\n\ntype State = [4][Nb * 8]\ntype Key = [Nk][Nb * 8]\ntype RoundKey = State\ntype KS = (RoundKey, [Nr - 1]RoundKey, RoundKey)\n\ngf28Mult : GF28 -> GF28 -> GF28\ngf28Mult x y = pmod (pmult x y) <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Pow : GF28 -> [8] -> GF28\ngf28Pow n k =\n  if k == 0 then 1\n  else\n    (if (k && 1) == 1 then gf28Mult n w\n     else w\n       where v = gf28Pow n (k >> 1)\n             w = gf28Mult v v)\n\ntoBytes : [32] -> [4]GF28\ntoBytes x = split`{4} x\n\nfromBytes : [4]GF28 -> [32]\nfromBytes xs = join xs\n\nrotR : [4]GF28 -> [2] -> [4]GF28\nrotR xs n = xs >>> n\n\nroundConstants = take`{16} ([0] # [ gf28Pow 2 (k-1) | k <- [1 ... ] ])\n\nsbox = [ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n         0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n         0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n         0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n         0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n         0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n         0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n         0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n         0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n         0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n         0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n         0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n         0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n         0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n         0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n         0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n         0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n         0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n         0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n         0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n         0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n         0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n         0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n         0x54, 0xbb, 0x16]\n\nunsbox = [ unsboxf i sboxit 0 0 | i <- [ 0 .. 255] ]\n  where sboxit = [ (j, i) | i <- [ 0 .. 255] | j <- sbox ]\n        unsboxf n t i d = if i >= (length t) then d\n                          else (if (k == n) then v\n                                else unsboxf n t (i + 1) d\n                                  where (k, v) = t @ i)\n\naddRoundKey : RoundKey -> State -> State\naddRoundKey k s = k ^ s\n\nkeyExpansion : Key -> [inf]RoundKey\nkeyExpansion key = chop4 keys\n  where keys = key # [nextWord i prev old | i <- [ `Nk ... ] | prev <- drop`{Nk-1} keys | old <- keys]\n        chop4 : {a} [inf]a -> [inf][4]a\n        chop4 xs = split xs\n        subWordRcon : [Nb * 8] -> GF28 -> [Nb * 8]\n        subWordRcon w rc = fromBytes [a ^ rc, b, c, d]\n          where [a, b, c, d] = [ sbox @ i | i <- toBytes w ]\n        nextWord : [8] -> [Nb * 8] -> [Nb * 8] -> [Nb * 8]\n        nextWord i prev old = old ^\n          (if (i % `Nk) == 0 then subWordRcon (join (split`{4} prev <<< 1)) (roundConstants @ (i \/ `Nk))\n           else if (i % `Nk) == 4 \/\\ `Nk > 6 then subWordRcon prev 0\n           else prev)\n\nmETable = [ gf28Mult 0x0E i | i <- [ 0 .. 255 ] ]\nmBTable = [ gf28Mult 0x0B i | i <- [ 0 .. 255 ] ]\nmDTable = [ gf28Mult 0x0D i | i <- [ 0 .. 255 ] ]\nm9Table = [ gf28Mult 0x09 i | i <- [ 0 .. 255 ] ]\nmE i = mETable @ i\nmB i = mBTable @ i\nmD i = mDTable @ i\nm9 i = m9Table @ i\ntables = [ [mE, mB, mD, m9],\n           [m9, mE, mB, mD],\n           [mD, m9, mE, mB],\n           [mB, mD, m9, mE] ]\n\ninvMixColumns : State -> State\ninvMixColumns state = [ fromBytes ce | ce <- transpose (mmult [ toBytes se | se <- state ]) ]\n  where dollar f x = f x\n        dot f fs =  foldr1 (^) (zipWith dollar f fs)\n        mmult n = [ [ (dot r) ne | ne <- n ] | r <- tables ]\n\naesEncryptKeySchedule : Key -> KS\naesEncryptKeySchedule key = (rKeys @ 0, m, rKeys @ `Nr)\n  where rKeys = keyExpansion key\n        m = take`{Nr-1}(tail rKeys)\n\naesDecryptKeySchedule : Key -> KS\naesDecryptKeySchedule key = (rKeys @ `Nr, m, rKeys @ 0)\n  where rKeys = keyExpansion key\n        m = [ invMixColumns k | k <- reverse (take`{Nr-1}(tail rKeys)) ]\n\ndoRounds : {a, b} (fin b) => (Bit -> State -> a -> State) -> (RoundKey, [b]a, a) -> State -> State\ndoRounds rnd (ikey, rkeys, fkey) sIn = rnd True (rs ! 0) fkey\n  where s0 = addRoundKey ikey sIn\n        rs = [s0] # [ rnd False s k | s <- rs | k <- rkeys ]\n\nt0Func : GF28 -> [4]GF28\nt0Func a = [gf28Mult s 2, s, s, gf28Mult s 3] where s = sbox @ a\nt0 = [fromBytes (t0Func a) | a <- [0..255]]\nt1 = [fromBytes (rotR (t0Func a) 1) | a <- [0..255]]\nt2 = [fromBytes (rotR (t0Func a) 2) | a <- [0..255]]\nt3 = [fromBytes (rotR (t0Func a) 3) | a <- [0..255]]\n\naesRound : Bit -> State -> RoundKey -> State\naesRound isFinal s key = addRoundKey d key\n  where d = [ f isFinal i | i <- [ 0 .. 3] ]\n        a = [ toBytes se | se <- s ]\n        f b j = if b then\n                  fromBytes [ sbox @ (a @ ((j+0) % 4) @ 0),\n                              sbox @ (a @ ((j+1) % 4) @ 1),\n                              sbox @ (a @ ((j+2) % 4) @ 2),\n                              sbox @ (a @ ((j+3) % 4) @ 3) ]\n                else\n                  e0 ^ e1 ^ e2 ^ e3\n                    where e0 = t0 @ (a @ ((j+0) % 4) @ 0)\n                          e1 = t1 @ (a @ ((j+1) % 4) @ 1)\n                          e2 = t2 @ (a @ ((j+2) % 4) @ 2)\n                          e3 = t3 @ (a @ ((j+3) % 4) @ 3)\n\nu0Func : GF28 -> [4]GF28\nu0Func a = [gf28Mult s 0x0E, gf28Mult s 0x09, gf28Mult s 0x0D, gf28Mult s 0x0B] where s = unsbox @ a\nu0 = [fromBytes (u0Func a) | a <- [0..255]]\nu1 = [fromBytes (rotR (u0Func a) 1) | a <- [0..255]]\nu2 = [fromBytes (rotR (u0Func a) 2) | a <- [0..255]]\nu3 = [fromBytes (rotR (u0Func a) 3) | a <- [0..255]]\n\naesInvRound : Bit -> State -> RoundKey -> State\naesInvRound isFinal s key = addRoundKey d key\n  where d = [ f isFinal i | i <- [ 0 .. 3] ]\n        a = [ toBytes se | se <- s ]\n        f b j = if b then\n                  fromBytes [ unsbox @ (a @ ((j+0) % 4) @ 0),\n                              unsbox @ (a @ ((j+3) % 4) @ 1),\n                              unsbox @ (a @ ((j+2) % 4) @ 2),\n                              unsbox @ (a @ ((j+1) % 4) @ 3) ]\n                else\n                  e0 ^ e1 ^ e2 ^ e3\n                    where e0 = u0 @ (a @ ((j+0) % 4) @ 0)\n                          e1 = u1 @ (a @ ((j+3) % 4) @ 1)\n                          e2 = u2 @ (a @ ((j+2) % 4) @ 2)\n                          e3 = u3 @ (a @ ((j+1) % 4) @ 3)\n\naesEncrypt pt key = doRounds aesRound (aesEncryptKeySchedule key) pt\n\naesDecrypt ct key = doRounds aesInvRound (aesDecryptKeySchedule key) ct\n\nproperty t128EncTest = aesEncrypt pt k == [0x69c4e0d8, 0x6a7b0430, 0xd8cdb780, 0x70b4c55a]\n  where pt = [ 0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff ]\n        k = [ 0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f ]\n\nproperty t128DecTest = aesDecrypt ct k == [0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff]\n  where ct = [ 0x69c4e0d8, 0x6a7b0430, 0xd8cdb780, 0x70b4c55a ]\n        k = [ 0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f ]\n\nproperty AESTests = t128EncTest && t128DecTest\n\nproperty sboxUnsboxInverse (n : [8]) = n == (unsbox @ (sbox @ n))\n\nproperty keyExpansionInjective k1 k2 =\n  if k1 != k2\n  then aesEncryptKeySchedule k1 != aesEncryptKeySchedule k2\n  else True\n\nproperty encDecInverse pt k = (aesDecrypt (aesEncrypt pt k) k) == pt\n\nfoldr : {a,b,n} (fin n) => (a -> b -> b) -> b -> [n]a -> b\nfoldr f acc xs = ys ! 0\n  where ys = [acc] # [f x a | a <- ys | x <- reverse xs]\n\nfoldr1 : {a, b} (fin b) => (a -> a -> a) -> [1 + b]a -> a\nfoldr1 f xs = foldr f (xs @ 0) (tail xs)\n\nzipWith : {a,b,c,n} (a -> b -> c) -> [n]a -> [n]b -> [n]c\nzipWith f xs ys = [f x y | x <- xs | y <- ys]\n```"}]}
{"filename":"saw-script\/examples\/ecdsa\/cryptol-spec\/ecc.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that specifies NIST P-384 elliptic-curve arithmetic and ECDSA (signing and public verification), including the p384 curve parameters, scalar multiplication, twin multiplication, field prime increment\/decrement, and a property capturing correctness of ecdsa_public_verify_imp for the P-384 curve."},{"role":"assistant","content":"```cryptol\nmodule ecc where\n\nimport bv\nimport mod_arith\nimport mul_java\n\nimport Field \nimport ec_point_ops\nimport ref_ec_mul\nimport p384_field\nimport p384_ec_point_ops\nimport p384_ec_mul\n\ntest_params : ([384], AffinePoint [384], [384], AffinePoint [384])\ntest_params =\n  (0xe74872524f90425d832a4f264e1f7b9209ec7456e9b4c467d8eac6c68f973ea7fea24f4d3fa8498bb1e26f933eaa261b\n  , { x=0xbbab93c429707b2afe9ac285314d7b40c4ee31531b13291aa9058307cdd038b572fdf2f3a84dc912804fa426fe531a3c\n    , y=0x4c2cffaa333bfd82b575918bb979bf51480c836082c097a03fed5454877b37d2f44f0401d212c16b05052bd383047b31\n    }\n  , 0xd4356773f2b311955542c5835696b9dca9d0e59197d5746bbf7dc079a666d955f74114662e38d31196bf94b060cc0c80\n  , { x=0xd40c63c65b413d0741c56e884f0dca63b822a6f6879d36f9261d9b4a270d5d79a9be790fdfb871b5d6ae9204da692663\n    , y=0x4d6b2b937c85b3c0c3cd2df85e9307cc89e0093f336af3b4531aa126bbdbec466562d8aa0dc1cf360fc1f1d0951e3ad1\n    })\n\ntype Curve fv gv = {\n    point_ops : PointOps fv gv\n  , base : AffinePoint fv\n  , affinify : JacobianPoint fv -> AffinePoint fv\n  , mul : (gv, AffinePoint fv) -> JacobianPoint fv\n  , twin_mul : (gv, AffinePoint fv, gv, AffinePoint fv) -> JacobianPoint fv\n  }\n\ninitialize_public_key : {fv} (Curve [fv] [fv], [fv]) -> AffinePoint [fv]\ninitialize_public_key(c, k) = c.affinify(c.mul(k, c.base))\n\necdsa_sign : {fv} (fin fv, fv >= 1) => (Curve [fv] [fv], [fv], [fv], [fv]) -> ([fv], [fv])\necdsa_sign(c,d,e,k) = if is_zero(r) || is_zero(s) then (0,0) else (r, s)\n  where\n    g = c.point_ops.group_field\n    is_zero(x) = g.is_equal(x, g.field_zero)\n\n    j = (c.affinify(c.mul(k, c.base))).x\n\n    r = g.normalize(j)\n    s = g.div(g.add(g.normalize(e), g.mul(d, r)), k)\n\necdsa_public_verify : {fv} (fin fv, fv >= 1)\n   => (Curve [fv] [fv], [fv], ([fv], [fv]), AffinePoint [fv]) -> Bit\necdsa_public_verify(c, e, (r, s), q)\n\n   = in_range(s) && (v == r)\n  where\n    f = c.point_ops.field\n    g = c.point_ops.group_field\n    mul(x,y) = g.mul(x, y)\n    div(x,y) = g.div(x, y)\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    in_range(x) = ~is_zero(x) && g.is_val(x)\n    s_inv = div(1, s)\n    u1 = mul(e, s_inv)\n    u2 = mul(r, s_inv)\n    r2 = c.twin_mul(u1, c.base, u2, q)\n\n    j = f.mul(r2.x, f.sq(f.div(f.field_unit, r2.z)))\n\n    v = g.normalize(j)\n\necdsa_public_verify_imp :\n  (Curve [384] [384], [384], ([384], [384]), AffinePoint [384]) -> Bit\necdsa_public_verify_imp(c, e, (r, s), q)\n   = in_range(r) && in_range(s) &&\n     ~is_zero(r2.z) &&\n     (g.is_equal(j, r2.x) || ((carrybits == False) && (g.is_equal(k, r2.x))))\n  where\n    f = c.point_ops.field\n    g = c.point_ops.group_field\n    mul(x,y) = g.mul(x, y)\n    div(x,y) = g.div(x, y)\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    in_range(x) = ~is_zero(x) && g.is_val(x)\n    s_inv = div(1, s)\n    u1 = mul(g.normalize(e), s_inv)\n    u2 = mul(r, s_inv)\n    r2 = c.twin_mul(u1, c.base, u2, q)\n    r2zsq = f.sq(r2.z)\n    j = f.mul(r, r2zsq)\n    sum = r + p384_group_size\n    carrybits = (sum < r) && (sum < p384_group_size)\n    k = f.mul(sum, r2zsq)\n\ntype RsltWithCarry a b = { carrybits : a , rslt : b }\n\np384_incFieldPrime : [384] -> RsltWithCarry [32] [384]\np384_incFieldPrime x = { carrybits = zero # [(bs @ 0)]\n                       , rslt = drop(bs) : [384]\n                       }\n  where bs = safe_add(x, p384_prime)\n\np384_decFieldPrime : [384] -> RsltWithCarry [32] [384]\np384_decFieldPrime x = { carrybits = if (bs @ 0) then -1 else 0\n                       , rslt = drop(bs) : [384]\n                       }\n  where bs = safe_sub(x, p384_prime)\n\np384_field_cube(x)       = p384_field_mul(x, p384_field_sq(x))\n\np384_base : AffinePoint [384]\np384_base = nzAffinePoint(\n  join [0xaa87ca22, 0xbe8b0537, 0x8eb1c71e, 0xf320ad74, 0x6e1d3b62, 0x8ba79b98\n       ,0x59f741e0, 0x82542a38, 0x5502f25d, 0xbf55296c, 0x3a545e38, 0x72760ab7],\n  join [0x3617de4a, 0x96262c6f, 0x5d9e98bf, 0x9292dc29, 0xf8f41dbd, 0x289a147c\n       ,0xe9da3113, 0xb5f0b8c0, 0x0a60b1ce, 0x1d7e819d, 0x7a431d7c, 0x90ea0e5f])\n\np384_group_add : ([384],[384]) -> [384]\np384_group_add = p384_group_field.add\n\np384_curve : Curve [384] [384]\np384_curve =\n  { point_ops = p384_point_ops\n  , base = p384_base\n  , affinify = \\x -> ec_affinify(p384_field, x)\n  , mul = p384_ec_mul\n  , twin_mul = p384_ec_twin_mul\n  }\n\np384_ecdsa_sign : ([384], [384], [384]) -> { r:[384], s:[384] }\np384_ecdsa_sign(d,e,k) = { r = rr, s = ss }\n  where (rr, ss) = ecdsa_sign(p384_curve,d,e,k)\n\np384_ecdsa_public_verify : ([384], [384], [384], AffinePoint [384]) -> Bit\np384_ecdsa_public_verify(e,pr,ps,q) =\n  ecdsa_public_verify_imp(p384_curve,e,(pr,ps),q)\n\np384_a : [384]\np384_a = p384_prime - 3\n\np384_b : [384]\np384_b = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\n\np384_affinify : JacobianPoint [384] -> AffinePoint [384]\np384_affinify p = ec_affinify(p384_field, p)\n\np384_jacobify : AffinePoint [384] -> JacobianPoint [384]\np384_jacobify p = { x = p.x, y = p.y, z = 1 }\n\np384_base4 : JacobianPoint [384]\np384_base4 = p384_ec_double(p384_ec_double(p384_jacobify(p384_base)))\n\np384_base3 : AffinePoint [384]\np384_base3 = p384_affinify(p384_ec_full_sub(p384_base4, p384_base))\n\np384_base5 : AffinePoint [384]\np384_base5 = p384_affinify(p384_ec_full_add(p384_base4, p384_base))\n\np384_is_affine_point : AffinePoint [384] -> Bit\np384_is_affine_point p =\n  p384_field_sq(p.y) ==\n  p384_field_add(p384_field_cube(p.x),\n                 p384_field_add(p384_field_mul(p384_a, p.x), p384_b))\n```"}]}
{"filename":"saw-script\/examples\/llvm\/iterative_average\/test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the types, functions, and property shown (State, init, updatef, digest, avg) and proves via the property imp_correct that avg xs equals digest (updatef init xs) for all valid inputs xs."},{"role":"assistant","content":"```cryptol\ntype State =\n  { sum : [32]\n  , len : [32]\n  }\n\ninit : State\ninit =\n  { sum = 0\n  , len = 0\n  }\n\nupdatef : {n} (fin n, 32 >= width n) => State -> [n][32] -> State\nupdatef st xs =\n  { sum = st.sum + sum\n  , len = st.len + `n\n  }\n  where\n    sum = sums!0\n    sums = [ 0 ] # [ acc + x | acc <- sums | x <- xs ]\n\ndigest : State -> [32]\ndigest st = st.sum \/ st.len\n\navg : {n} (fin n, 32 >= width n) => [n][32] -> [32]\navg xs = sum \/ `n\n  where\n    sum = sums!0\n    sums = [ 0 ] # [ acc + x | acc <- sums | x <- xs ]\n\nimp_correct : {n} (fin n, 32 >= width n) => [n][32] -> Bool\nproperty imp_correct xs = avg xs == digest (updatef init xs)\n```"}]}
{"filename":"saw-script\/examples\/llvm\/union\/test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models the tagged-union state type St and proves that the function inc correctly increments the fields of either Inc_1_st or Inc_2_st depending on alg, preserving all other bits."},{"role":"assistant","content":"```cryptol\ntype Alg = [32]\nINC_1 = 0 : Alg\nINC_2 = 1 : Alg\n\ntype Inc_1_st =\n  { x : [32]\n  }\n\ntype Inc_2_st =\n  { x : [32]\n  , y : [32]\n  }\n\ntype UNION_BITS = 32+32\n\ntype St =\n  { alg : Alg\n  , bits : [UNION_BITS]\n  }\n\nbits_to_inc_1_st : [UNION_BITS] -> Inc_1_st\nbits_to_inc_1_st bits = { x = take`{32} bits }\n\ninc_1_st_to_bits : [UNION_BITS] -> Inc_1_st -> [UNION_BITS]\ninc_1_st_to_bits bits st = st.x # drop`{32} bits\n\nbits_to_inc_2_st : [UNION_BITS] -> Inc_2_st\nbits_to_inc_2_st bits = { x = take`{32} bits, y = drop`{32} bits }\ninc_2_st_to_bits : Inc_2_st -> [UNION_BITS]\ninc_2_st_to_bits st = st.x # st.y\n\ninc : St -> St\ninc st = { alg = st.alg, bits = bits }\n  where\n    bits =\n      if st.alg == INC_1 then\n        inc_1_st_to_bits st.bits\n          (inc_1 (bits_to_inc_1_st st.bits))\n      else\n        inc_2_st_to_bits\n          (inc_2 (bits_to_inc_2_st st.bits))\n\ninc_1 : Inc_1_st -> Inc_1_st\ninc_1 st = { x = st.x + 1 }\n\ninc_2 : Inc_2_st -> Inc_2_st\ninc_2 st = { x = st.x + 1, y = st.y + 1}\n```"}]}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/xordomain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the xordomain module defining the Dom type, the mem, bxor, band, and band_scalar functions, and the correctness properties x1, x2, and x3 that verify correct_bxor, correct_band, and correct_band_scalar for 16-bit vectors."},{"role":"assistant","content":"```cryptol\nmodule xordomain where\n\ntype Dom n = { val : [n], unknown : [n] }\n\nmem : {n} (fin n) => Dom n -> [n] -> Bit\nmem a x = a.val == x || a.unknown\n\nbxor : {n} (fin n) => Dom n -> Dom n -> Dom n\nbxor a b = { val = v || u, unknown = u }\n  where\n  v = a.val ^ b.val\n  u = a.unknown || b.unknown\n\nband : {n} (fin n) => Dom n -> Dom n -> Dom n\nband a b = { val = v, unknown = u && v }\n  where\n  v   = a.val && b.val\n  u   = a.unknown || b.unknown\n\nband_scalar : {n} (fin n) => Dom n -> [n] -> Dom n\nband_scalar a x = { val = a.val && x, unknown = a.unknown && x }\n\ncorrect_bxor : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_bxor a b x y =\n  mem a x ==> mem b y ==> mem (bxor a b) (x ^ y)\n\ncorrect_band : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_band a b x y =\n  mem a x ==> mem b y ==> mem (band a b) (x && y)\n\ncorrect_band_scalar : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_band_scalar a x y =\n  mem a x ==> mem (band_scalar a y) (x && y)\n\nproperty x1 = correct_bxor`{16}\nproperty x2 = correct_band`{16}\nproperty x3 = correct_band_scalar`{16}\n```"}]}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/bvdomain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `bvdomain` that defines bitvector-domain rounding and domain-conversion functions (between arithmetic, bitwise, and XOR domains) together with the listed correctness properties (bra1, bra2, brb1, brb2, mx, mx_inv, t1\u2013t5, w1\u2013w3, e1\u2013e3) for fixed widths."},{"role":"assistant","content":"```cryptol\nmodule bvdomain where\n\nimport arithdomain as A\nimport bitsdomain as B\nimport xordomain as X\n\nbitwise_round_above : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\nbitwise_round_above x mask = (x && ~q) ^ (mask && q)\n  where\n  q = A::fillright_alt ((x || mask) ^ x)\n\nbra_correct1 : {n} (fin n, n>=1) => [n] -> [n] -> Bit\nbra_correct1 x mask = mask <= x ==> (x <= q \/\\ B::bitle mask q)\n  where\n  q = bitwise_round_above x mask\n\nbra_correct2 : {n} (fin n, n>=1) => [n] -> [n] -> [n] -> Bit\nbra_correct2 x mask q' = (x <= q' \/\\ B::bitle mask q') ==> q <= q'\n  where\n  q = bitwise_round_above x mask\n\nproperty bra1 = bra_correct1`{64}\nproperty bra2 = bra_correct2`{64}\n\nbitwise_round_between : {n} (fin n, n >= 1) => [n] -> [n] -> [n] -> [n]\nbitwise_round_between x lomask himask = if r == 0 then loup else final\n    where\n\n    final = (upper && ~lowbits) || lomask\n\n      upper = (z + highbit) && himask\n\n        z = loup || ~himask\n\n    highbit = rmask ^ lowbits\n\n    lowbits = rmask >> 1\n\n    rmask = A::fillright_alt r\n\n      r = loup && ~himask\n\n    loup = bitwise_round_above x lomask\n\nbrb_correct1 : {n} (fin n, n>=1) => [n] -> [n] -> [n] -> Bit\nbrb_correct1 x lomask himask =\n    (B::bitle lomask himask \/\\ lomask <= x \/\\ x <= himask) ==>\n    (x <= q \/\\ B::bitle lomask q \/\\ B::bitle q himask)\n\n  where\n  q = bitwise_round_between x lomask himask\n\nbrb_correct2 : {n} (fin n, n>=1) => [n] -> [n] -> [n] -> [n] -> Bit\nbrb_correct2 x lomask himask q' = (x <= q' \/\\ B::bitle lomask q' \/\\ B::bitle q' himask) ==> q <= q'\n  where\n  q = bitwise_round_between x lomask himask\n\nproperty brb1 = brb_correct1`{64}\nproperty brb2 = brb_correct2`{64}\n\n\/\/ Interesting fact about arithmetic domains: the low values of the two domains\n\/\/ represent overlap candidates.  If neither low value is contained in the other domain,\n\/\/ then they do not overlap.\narith_overlap_candidates : {n} (fin n, n >= 1) => A::Dom n -> A::Dom n -> [n] -> Bit\narith_overlap_candidates a b x =\n  A::mem a x ==>\n  A::mem b x ==>\n  ((A::mem a b.lo \/\\ A::mem b b.lo) \\\/\n   (A::mem a a.lo \/\\ A::mem b a.lo))\n\n\/\/ Bitwise domains, if they overlap, must overlap in some specific points.  The bitwise\n\/\/ union of the low bounds is one.\nbitwise_overlap_candidates : {n} (fin n, n >= 1) => B::Dom n -> B::Dom n -> [n] -> Bit\nbitwise_overlap_candidates a b x =\n  B::mem a x ==>\n  B::mem b x ==>\n  (B::mem a witness \/\\ B::mem b witness)\n\n where\n witness = a.lomask || b.lomask\n\n\/\/ If mixed domains have some common value, then they must definintely overlap at one\n\/\/ of the following three listed candidate points.\nmixed_overlap_candidates : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> [n] -> Bit\nmixed_overlap_candidates a b x =\n  A::mem a x ==>\n  B::mem b x ==>\n  (A::mem a b.lomask \/\\ B::mem b b.lomask) \\\/\n  (A::mem a b.himask \/\\ B::mem b b.himask) \\\/\n  (A::mem a next     \/\\ B::mem b next)\n\n where\n next = bitwise_round_between a.lo b.lomask b.himask\n\n\/\/ A mixed domain overlap test.  It relies on testing special candidate overlap values.\n\/\/\n\/\/ If none of the overlap candidates are found in both domains, then the domains do not overlap.\n\/\/ On the other hand, if any canadiate is in both domains, it is a constructive witness of\n\/\/ overlap.\nmixed_domain_overlap : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> Bit\nmixed_domain_overlap a b =\n  A::mem a b.lomask \\\/ A::mem a b.himask \\\/ A::mem a (bitwise_round_between a.lo b.lomask b.himask)\n\n\/\/ If mixed domains have a common element, the overlap test will be true.\ncorrect_mixed_domain_overlap : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> [n] -> Bit\ncorrect_mixed_domain_overlap a b x =\n  A::mem a x ==>\n  B::mem b x ==>\n  mixed_domain_overlap a b\n\n\/\/ If the overlap test is true, then we can find some element they share in common,\n\/\/ provided the bitwise domain is nonempty.\ncorrect_mixed_domain_overlap_inv : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n -> Bit\ncorrect_mixed_domain_overlap_inv a b =\n  B::nonempty b ==> mixed_domain_overlap a b ==> (A::mem a witness \/\\ B::mem b witness)\n\n where\n witness = if A::mem a b.lomask then b.lomask else\n           if A::mem a b.himask then b.himask else\n           bitwise_round_between a.lo b.lomask b.himask\n\nproperty mx = correct_mixed_domain_overlap`{64}\nproperty mx_inv = correct_mixed_domain_overlap_inv`{64}\n\n\/\/ Operations that transfer between the domains\n\narithToBitDom : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n\narithToBitDom a = { lomask = lo, himask = hi }\n  where\n  u  = A::unknowns a\n  hi = a.lo || u\n  lo = hi ^ u\n\nbitToArithDom : {n} (fin n) => B::Dom n -> A::Dom n\nbitToArithDom b = A::range b.lomask b.himask\n\nbitToXorDom : {n} (fin n) => B::Dom n -> X::Dom n\nbitToXorDom b = { val = b.himask, unknown = b.lomask ^ b.himask }\n\nxorToBitDom : {n} (fin n) => X::Dom n -> B::Dom n\nxorToBitDom x = { lomask = x.val ^ x.unknown, himask = x.val }\n\narithToXorDom : {n} (fin n, n >= 1) => A::Dom n -> X::Dom n\narithToXorDom a = { val = a.lo || u, unknown = u }\n  where\n  u = A::unknowns a\n\n\/\/ A small collection of operations that start in one\n\/\/ domain and end in the other\n\npopcount : {n} (fin n, n>=1) => [n] -> [n]\npopcount bs = sum [ zero#[b] | b <- bs ]\n\ncountLeadingZeros : {n} (fin n, n>=1) => [n] -> [n]\ncountLeadingZeros x = loop 0\n where\n loop n =\n   if n >= length x then\n     length x\n   else\n     if x@n then n else loop (n+1)\n\ncountTrailingZeros : {n} (fin n, n>=1) => [n] -> [n]\ncountTrailingZeros xs = countLeadingZeros (reverse xs)\n\npopcnt : {n} (fin n, n>=1) => B::Dom n -> A::Dom n\npopcnt b = A::range lo hi\n  where\n  lo = popcount b.lomask\n  hi = popcount b.himask\n\nclz : {n} (fin n, n>=1) => B::Dom n -> A::Dom n\nclz b = A::range lo hi\n where\n lo = countLeadingZeros b.himask\n hi = countLeadingZeros b.lomask\n\nctz : {n} (fin n, n>=1) => B::Dom n -> A::Dom n\nctz b = A::range lo hi\n where\n lo = countTrailingZeros b.himask\n hi = countTrailingZeros b.lomask\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Correctness properties\n\ncorrect_arithToBitDom : {n} (fin n, n >= 1) => A::Dom n -> [n] -> Bit\ncorrect_arithToBitDom a x =\n  A::mem a x ==> B::mem (arithToBitDom a) x\n\ncorrect_bitToArithDom : {n} (fin n) => B::Dom n -> [n] -> Bit\ncorrect_bitToArithDom b x =\n  B::mem b x ==> A::mem (bitToArithDom b) x\n\ncorrect_bitToXorDom : {n} (fin n) => B::Dom n -> [n] -> Bit\ncorrect_bitToXorDom b x =\n  B::mem b x == X::mem (bitToXorDom b) x\n\ncorrect_xorToBitDom : {n} (fin n) => X::Dom n -> [n] -> Bit\ncorrect_xorToBitDom b x =\n  X::mem b x == B::mem (xorToBitDom b) x\n\ncorrect_arithToXorDom : {n} (fin n, n >= 1) => A::Dom n -> [n] -> Bit\ncorrect_arithToXorDom a x =\n  A::mem a x ==> X::mem (arithToXorDom a) x\n\nproperty t1 = correct_arithToBitDom`{16}\nproperty t2 = correct_bitToArithDom`{16}\nproperty t3 = correct_bitToXorDom`{16}\nproperty t4 = correct_xorToBitDom`{16}\nproperty t5 = correct_arithToXorDom`{16}\n\ncorrect_popcnt : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit\ncorrect_popcnt a x =\n  B::mem a x ==> A::mem (popcnt a) (popcount x)\n\ncorrect_clz : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit\ncorrect_clz a x =\n  B::mem a x ==> A::mem (clz a) (countLeadingZeros x)\n\ncorrect_ctz : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit\ncorrect_ctz a x =\n  B::mem a x ==> A::mem (ctz a) (countTrailingZeros x)\n\nproperty w1 = correct_popcnt`{16}\nproperty w2 = correct_clz`{16}\nproperty w3 = correct_ctz`{16}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Proofs that the XOR domain is really just an alternate way\n\/\/ to compute the same thing as the bitsdomain operations.\n\/\/ For \"band\" this requires the input domains to be nonempty,\n\/\/ which should be the case for all actual values of interest.\n\nequiv_bxor : {n} (fin n) => B::Dom n -> B::Dom n -> Bit\nequiv_bxor a b =\n  B::bxor a b == xorToBitDom (X::bxor (bitToXorDom a) (bitToXorDom b))\n\nequiv_band : {n} (fin n) => B::Dom n -> B::Dom n -> Bit\nequiv_band a b =\n  B::nonempty a \/\\ B::nonempty b ==>\n  B::band a b == xorToBitDom (X::band (bitToXorDom a) (bitToXorDom b))\n\nequiv_band_scalar : {n} (fin n) => B::Dom n -> [n] -> Bit\nequiv_band_scalar a x =\n  B::band a (B::singleton x) == xorToBitDom (X::band_scalar (bitToXorDom a) x)\n\nproperty e1 = equiv_bxor`{16}\nproperty e2 = equiv_band`{16}\nproperty e3 = equiv_band_scalar`{16}\n```"}]}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/bitsdomain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `bitsdomain` that defines an abstract bit-vector domain `Dom n`, its operations (membership, set ops, extensions, shifts\/rotations), and properties `b1`\u2013`b12`, `l1`\u2013`l4`, `s1`\u2013`s5`, `i01`\u2013`i13` verifying soundness and singleton preservation as given."},{"role":"assistant","content":"```cryptol\nmodule bitsdomain where\n\ntype Dom n = { lomask : [n] , himask : [n] }\n\nmem : {n} (fin n) => Dom n -> [n] -> Bit\nmem a x = bitle a.lomask x \/\\ bitle x a.himask\n\nbitle : {n} (fin n) => [n] -> [n] -> Bit\nbitle x y = x || y == y\n\nnonempty : {n} (fin n) => Dom n -> Bit\nnonempty b = bitle b.lomask b.himask\n\nsingleton : {n} (fin n) => [n] -> Dom n\nsingleton x = { lomask = x, himask = x }\n\nisSingleton : {n} (fin n) => Dom n -> Bit\nisSingleton a = a.lomask == a.himask\n\ntop : {n} (fin n) => Dom n\ntop = { lomask = 0, himask = ~0 }\n\noverlap : {n} (fin n) => Dom n -> Dom n -> Bit\noverlap a b = nonempty (intersection a b)\n\nintersection : {n} (fin n) => Dom n -> Dom n -> Dom n\nintersection a b = { lomask = a.lomask || b.lomask, himask = a.himask && b.himask }\n\nunion : {n} (fin n) => Dom n -> Dom n -> Dom n\nunion a b = { lomask = a.lomask && b.lomask, himask = a.himask || b.himask }\n\nzero_ext : {m, n} (fin m, m >= n) => Dom n -> Dom m\nzero_ext a = { lomask = zext a.lomask, himask = zext a.himask }\n\nsign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> Dom m\nsign_ext a = { lomask = sext a.lomask, himask = sext a.himask }\n\nconcat : {m, n} (fin m, fin n) => Dom m -> Dom n -> Dom (m + n)\nconcat a b = { lomask = a.lomask # b.lomask, himask = a.himask # b.himask }\n\nshrink : {m, n} (fin m, fin n) => Dom (m + n) -> Dom m\nshrink a = { lomask = take`{m} a.lomask, himask = take`{m} a.himask }\n\ntrunc : {m, n} (fin m, fin n) => Dom (m + n) -> Dom n\ntrunc a = { lomask = drop`{m} a.lomask, himask = drop`{m} a.himask }\n\nbnot : {n} (fin n) => Dom n -> Dom n\nbnot b = { lomask = ~b.himask, himask = ~b.lomask }\n\nband : {n} (fin n) => Dom n -> Dom n -> Dom n\nband a b = { lomask = a.lomask && b.lomask, himask = a.himask && b.himask }\n\nbor : {n} (fin n) => Dom n -> Dom n -> Dom n\nbor a b = { lomask = a.lomask || b.lomask, himask = a.himask || b.himask }\n\nbxor : {n} (fin n) => Dom n -> Dom n -> Dom n\nbxor a b = { lomask = lo, himask = hi }\n  where\n  ua = a.lomask ^ a.himask\n  ub = b.lomask ^ b.himask\n  c  = a.lomask ^ b.lomask\n  u  = ua || ub\n  hi = c || u\n  lo = hi ^ u\n\nshl : {n} (fin n) => Dom n -> [n] -> Dom n\nshl a x = { lomask = a.lomask << x', himask = a.himask << x' }\n  where x' = if x < `n then x else `n\n\nlshr : {n} (fin n) => Dom n -> [n] -> Dom n\nlshr a x = { lomask = a.lomask >> x', himask = a.himask >> x' }\n  where x' = if x < `n then x else `n\n\nashr : {n} (fin n, n >= 1) => Dom n -> [n] -> Dom n\nashr a x = { lomask = a.lomask >>$ x', himask = a.himask >>$ x' }\n  where x' = if x < `n then x else `n\n\nrol : {n} (fin n) => Dom n -> [n] -> Dom n\nrol a x = { lomask = a.lomask <<< x, himask = a.himask <<< x }\n\nror : {n} (fin n) => Dom n -> [n] -> Dom n\nror a x = { lomask = a.lomask >>> x, himask = a.himask >>> x }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Soundness properties\n\ncorrect_top : {n} (fin n) => [n] -> Bit\ncorrect_top x = mem top x\n\ncorrect_singleton : {n} (fin n) => [n] -> [n] -> Bit\ncorrect_singleton x y = mem (singleton x) y == (x == y)\n\ncorrect_overlap : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_overlap a b x =\n  mem a x ==> mem b x ==> overlap a b\n\ncorrect_overlap_inv : {n} (fin n) => Dom n -> Dom n -> Bit\ncorrect_overlap_inv a b =\n  overlap a b ==> (mem a (a.lomask || b.lomask) \/\\ mem b (a.lomask || b.lomask))\n\ncorrect_union : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_union a b x =\n  (mem a x \\\/ mem b x) ==> mem (union a b) x\n\ncorrect_intersection : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_intersection a b x =\n  (mem a x \/\\ mem b x) == mem (intersection a b) x\n\ncorrect_zero_ext : {m, n} (fin m, m >= n) => Dom n -> [n] -> Bit\ncorrect_zero_ext a x =\n  mem a x ==> mem (zero_ext`{m} a) (zext`{m} x)\n\ncorrect_sign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> [n] -> Bit\ncorrect_sign_ext a x =\n  mem a x ==> mem (sign_ext`{m} a) (sext`{m} x)\n\ncorrect_concat : {m, n} (fin m, fin n) => Dom m -> Dom n -> [m] -> [n] -> Bit\ncorrect_concat a b x y =\n  mem a x ==> mem b y ==> mem (concat a b) (x # y)\n\ncorrect_shrink : {m, n} (fin m, fin n) => Dom (m + n) -> [m+n] -> Bit\ncorrect_shrink a x =\n  mem a x ==> mem (shrink`{m} a) (take`{m} x)\n\ncorrect_trunc : {m, n} (fin m, fin n) => Dom (m + n) -> [m+n] -> Bit\ncorrect_trunc a x =\n  mem a x ==> mem (trunc`{m} a) (drop`{m} x)\n\ncorrect_isSingleton : {n} (fin n) => Dom n -> Bit\ncorrect_isSingleton a =\n  isSingleton a ==> a == singleton a.lomask\n\ncorrect_bnot : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_bnot a x =\n  mem a x == mem (bnot a) (~ x)\n\ncorrect_band : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_band a b x y =\n  mem a x ==> mem b y ==> mem (band a b) (x && y)\n\ncorrect_bor : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_bor a b x y =\n  mem a x ==> mem b y ==> mem (bor a b) (x || y)\n\ncorrect_bxor : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_bxor a b x y =\n  mem a x ==> mem b y ==> mem (bxor a b) (x ^ y)\n\ncorrect_shl : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_shl a x y =\n  mem a x ==> mem (shl a y) (x << y)\n\ncorrect_lshr : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_lshr a x y =\n  mem a x ==> mem (lshr a y) (x >> y)\n\ncorrect_ashr : {n} (fin n, n >= 1) => Dom n -> [n] -> [n] -> Bit\ncorrect_ashr a x y =\n  mem a x ==> mem (ashr a y) (x >>$ y)\n\ncorrect_rol : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_rol a x y =\n  mem a x ==> mem (rol a y) (x <<< y)\n\ncorrect_ror : {n} (fin n) => Dom n -> [n] -> [n] -> Bit\ncorrect_ror a x y =\n  mem a x ==> mem (ror a y) (x >>> y)\n\nproperty b1 = correct_top`{16}\nproperty b2 = correct_singleton`{16}\nproperty b3 = correct_overlap`{16}\nproperty b4 = correct_overlap_inv`{16}\nproperty b5 = correct_union`{8}\nproperty b6 = correct_intersection`{8}\nproperty b7 = correct_zero_ext`{32, 16}\nproperty b8 = correct_sign_ext`{32, 16}\nproperty b9 = correct_concat`{16, 16}\nproperty b10 = correct_shrink`{8, 8}\nproperty b11 = correct_trunc`{8, 8}\nproperty b12 = correct_isSingleton`{16}\n\nproperty l1 = correct_bnot`{16}\nproperty l2 = correct_band`{16}\nproperty l3 = correct_bor`{16}\nproperty l4 = correct_bxor`{16}\n\nproperty s1 = correct_shl`{16}\nproperty s2 = correct_lshr`{16}\nproperty s3 = correct_ashr`{16}\nproperty s4 = correct_rol`{16}\nproperty s5 = correct_ror`{16}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Operations preserve singletons\n\nsingleton_overlap : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_overlap x y =\n  overlap (singleton x) (singleton y) == (x == y)\n\nsingleton_zero_ext : {m, n} (fin m, m >= n) => [n] -> Bit\nsingleton_zero_ext x =\n  zero_ext`{m} (singleton x) == singleton (zext`{m} x)\n\nsingleton_sign_ext : {m, n} (fin m, m >= n, n >= 1) => [n] -> Bit\nsingleton_sign_ext x =\n  sign_ext`{m} (singleton x) == singleton (sext`{m} x)\n\nsingleton_concat : {m, n} (fin m, fin n) => [m] -> [n] -> Bit\nsingleton_concat x y =\n  concat (singleton x) (singleton y) == singleton (x # y)\n\nsingleton_shrink : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_shrink x =\n  shrink`{m} (singleton x) == singleton (take`{m} x)\n\nsingleton_trunc : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_trunc x =\n  trunc`{m} (singleton x) == singleton (drop`{m} x)\n\nsingleton_bnot : {n} (fin n) => [n] -> Bit\nsingleton_bnot x =\n  bnot (singleton x) == singleton (~ x)\n\nsingleton_band : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_band x y =\n  band (singleton x) (singleton y) == singleton (x && y)\n\nsingleton_bor : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_bor x y =\n  bor (singleton x) (singleton y) == singleton (x || y)\n\nsingleton_bxor : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_bxor x y =\n  bxor (singleton x) (singleton y) == singleton (x ^ y)\n\nsingleton_shl : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_shl x y =\n  shl (singleton x) y == singleton (x << y)\n\nsingleton_lshr : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_lshr x y =\n  lshr (singleton x) y == singleton (x >> y)\n\nsingleton_ashr : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ashr x y =\n  ashr (singleton x) y == singleton (x >>$ y)\n\nproperty i01 = singleton_overlap`{16}\nproperty i02 = singleton_zero_ext`{32, 16}\nproperty i03 = singleton_sign_ext`{32, 16}\nproperty i04 = singleton_concat`{16, 16}\nproperty i05 = singleton_shrink`{8, 8}\nproperty i06 = singleton_trunc`{8, 8}\nproperty i07 = singleton_band`{16}\nproperty i08 = singleton_bor`{16}\nproperty i09 = singleton_bxor`{16}\nproperty i10 = singleton_bnot`{16}\nproperty i11 = singleton_shl`{8}\nproperty i12 = singleton_lshr`{8}\nproperty i13 = singleton_ashr`{8}\n```"}]}
{"filename":"saw-script\/deps\/what4\/what4\/doc\/arithdomain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module arithdomain that defines the Dom interval type and its arithmetic\/bitwise operations, and includes all the given correctness, singleton, commutativity, associativity, and union properties (p1\u2013p13, a1\u2013a9, s1\u2013s3, o1\u2013o5, i01\u2013i20, c1\u2013c6, u1\u2013u5)."},{"role":"assistant","content":"```cryptol\nmodule arithdomain where\n\nbit : {i, n} (fin n, n > i) => [n]\nbit = 1 # (0 : [i])\n\nmask : {i, n} (fin n, n >= i) => [n]\nmask = 0 # (~ 0 : [i])\n\ninfixl 80 .+.\n(.+.) : {n} (fin n) => [n] -> [n] -> [n]\nx .+. y = if carry x y then error \"overflow\" else x + y\n\ninfixl 80 .-.\n(.-.) : {n} (fin n) => [n] -> [n] -> [n]\nx .-. y = if x < y then error \"underflow\" else x - y\n\nsmin : {a} (SignedCmp a) => a -> a -> a\nsmin x y = if x <$ y then x else y\n\nsmax : {a} (SignedCmp a) => a -> a -> a\nsmax x y = if x >$ y then x else y\n\ntype Dom n = { lo : [n], sz : [n] }\n\ninterval : {n} (fin n) => [n] -> [n] -> Dom n\ninterval l s = { lo = l, sz = s }\n\nrange : {n} (fin n) => [n] -> [n] -> Dom n\nrange lo hi = interval lo (hi - lo)\n\nmem : {n} (fin n) => Dom n -> [n] -> Bit\nmem a x = x - a.lo <= a.sz\n\numem : {n} (fin n) => ([n], [n]) -> [n] -> Bit\numem (lo, hi) x = lo <= x \/\\ x <= hi\n\nsmem : {n} (fin n, n >= 1) => ([n], [n]) -> [n] -> Bit\nsmem (lo, hi) x = lo <=$ x \/\\ x <=$ hi\n\ntop : {n} (fin n) => Dom n\ntop = interval 0 (~ 0)\n\nsingleton : {n} (fin n) => [n] -> Dom n\nsingleton x = interval x 0\n\nisSingleton : {n} (fin n) => Dom n -> Bit\nisSingleton a = a.sz == 0\n\nubounds : {n} (fin n) => Dom n -> ([n], [n])\nubounds a =\n  if carry a.lo a.sz then (0, ~0) else (a.lo, a.lo + a.sz)\n\nsbounds : {n} (fin n, n >= 1) => Dom n -> ([n], [n])\nsbounds a = (lo - delta, hi - delta)\n  where\n    delta = reverse 1\n    (lo, hi) = ubounds (interval (a.lo + delta) a.sz)\n\nrbounds : {n} (fin n, n >= 1) => Dom n -> ([n], [n])\nrbounds a =\n  if a.lo == 0 then (a_hi, 1) else\n  if a_hi == 0 then (-1, a.lo) else\n  if a_hi < a.lo then (-1, 1) else\n  (a_hi, a.lo)\n  where a_hi = a.lo + a.sz\n\noverlap : {n} (fin n) => Dom n -> Dom n -> Bit\noverlap a b = diff <= b.sz \\\/ carry diff a.sz\n  where diff = a.lo - b.lo\n\nunion : {n} (fin n) => Dom n -> Dom n -> Dom n\nunion a b =\n  if cw >= size then top else interval (drop`{2} cl) (drop`{2} cw)\n  where\n    size : [n+2]\n    size = bit`{n}\n    am = 2 * zext a.lo .+. zext a.sz\n    bm = 2 * zext b.lo .+. zext b.sz\n    al' = if am .+. size < bm then zext a.lo .+. size else zext a.lo\n    bl' = if bm .+. size < am then zext b.lo .+. size else zext b.lo\n    ah' = al' .+. zext a.sz\n    bh' = bl' .+. zext b.sz\n    cl = min al' bl'\n    ch = max ah' bh'\n    cw = ch .-. cl\n\nzero_ext : {m, n} (fin m, m >= n) => Dom n -> Dom m\nzero_ext a = interval (zext lo) (zext (hi .-. lo))\n  where (lo, hi) = ubounds a\n\nsign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> Dom m\nsign_ext a = interval (sext lo) (zext (hi - lo))\n  where (lo, hi) = sbounds a\n\nconcat : {m, n} (fin m, fin n) => Dom m -> Dom n -> Dom (m + n)\nconcat a b = interval (a.lo # lo) (a.sz # sz)\n  where\n    (lo, hi) = ubounds b\n    sz = hi .-. lo\n\nshrink : {m, n} (fin m, fin n) => Dom (m + n) -> Dom m\nshrink a =\n  if b_sz >= size then top\n  else interval (tail b_lo) (tail b_sz)\n  where\n    size : [1 + m]\n    size = bit`{m}\n    b_lo, b_hi, b_sz : [1 + m]\n    b_lo = take`{back=n} (zext a.lo)\n    b_hi = take`{back=n} (zext a.lo .+. zext a.sz)\n    b_sz = b_hi .-. b_lo\n\ntrunc : {m, n} (fin m, fin n) => Dom (m + n) -> Dom n\ntrunc a =\n  if a.sz > mask`{n} then top\n  else interval (drop`{m} a.lo) (drop`{m} a.sz)\n\nadd : {n} (fin n) => Dom n -> Dom n -> Dom n\nadd a b =\n  if carry a.sz b.sz then top\n  else interval (a.lo + b.lo) (a.sz .+. b.sz)\n\nneg : {n} (fin n) => Dom n -> Dom n\nneg a = interval (- (a.lo + a.sz)) a.sz\n\nbnot : {n} (fin n) => Dom n -> Dom n\nbnot a = interval (~ ah) a.sz\n  where ah = a.lo + a.sz\n\nmul : {n} (fin n) => Dom n -> Dom n -> Dom n\nmul a b =\n  if sz >= bit`{n} then top\n  else interval (drop lo) (drop sz)\n  where\n    (lo, hi) = mulRange (zbounds a) (zbounds b)\n    sz = hi - lo\n\nzbounds : {n} (fin n) => Dom n -> ([1 + n], [1 + n])\nzbounds a = (lo', lo' + zext a.sz)\n  where\n    size : [2 + n]\n    size = bit`{n}\n    lo' = if 2 * zext a.lo .+. zext a.sz >= size then 0b1 # a.lo else 0b0 # a.lo\n\nmulRange : {m, n} (fin m, fin n, m >= 1, n >= 1) => ([m], [m]) -> ([n], [n]) -> ([m+n], [m+n])\nmulRange (xl, xh) (yl, yh) = (zl, zh)\n  where\n    (xlyl, xlyh) = scaleRange xl (yl, yh)\n    (xhyl, xhyh) = scaleRange xh (yl, yh)\n    zl = smin xlyl xhyl\n    zh = smax xlyh xhyh\n\nscaleRange : {m, n} (fin m, fin n, m >= 1, n >= 1) => [m] -> ([n], [n]) -> ([m+n], [m+n])\nscaleRange k (lo, hi) = if k <$ 0 then (hi', lo') else (lo', hi')\n  where\n    lo' = sext k * sext lo\n    hi' = sext k * sext hi\n\nudiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nudiv a b = range cl ch\n  where\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    bl' = max 1 bl     bh' = max 1 bh \/\/ assume that division by 0 does not happen\n    cl = al \/ bh'\n    ch = ah \/ bl'\n\nurem : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nurem a b =\n  if ql == qh then range rl rh\n  else interval 0 (bh - 1)\n  where\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    bl' = max 1 bl     bh' = max 1 bh\n    (ql, rl) = (al \/ bh', al % bh')\n    (qh, rh) = (ah \/ bl', ah % bl')\n\n\/\/ The first argument is an ordinary signed interval, but the second\n\/\/ argument is a reciaprocal interval: The arguments should satisfy 'al\nsdivRange : {n} (fin n, n >= 1) => ([n], [n]) -> ([n], [n]) -> ([1+n], [1+n])\nsdivRange (al, ah) (bl, bh) = (ql, qh)\n  where\n    (ql1, qh1) = shrinkRange (al, ah) bh\n    (ql2, qh2) = shrinkRange (al, ah) bl\n    ql = smin ql1 ql2\n    qh = smax qh1 qh2\n\nshrinkRange : {n} (fin n, n >= 1) => ([n], [n]) -> [n] -> ([1+n], [1+n])\nshrinkRange (lo, hi) k =\n  if k >$ 0 then (lo .\/. k, hi .\/. k) else\n  if k <$ 0 then (hi .\/. k, lo .\/. k) else (sext lo, sext hi)\n  where\n    x .\/. y = sext x \/$ sext y\n\nsdiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nsdiv a b =\n  if sz >= bit`{n} then top\n  else interval (drop lo) (drop sz)\n  where\n    (lo, hi) = sdivRange (sbounds a) (rbounds b)\n    sz = hi - lo\n\nsrem : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nsrem a b =\n  if ql == qh then\n    (if ql <$ 0\n     then range (al - drop ql * bl) (ah - drop ql * bh)\n     else range (al - drop ql * bh) (ah - drop ql * bl))\n  else range rl rh\n  where\n    (al, ah) = sbounds a\n    (bl, bh) = sbounds b\n    (ql, qh) = sdivRange (al, ah) (rbounds b)\n    rl = if al <$ 0 then smin (bl+1) (-bh+1) else 0\n    rh = if ah >$ 0 then smax (-bl-1) (bh-1) else 0\n\nshl : {n} (fin n) => Dom n -> Dom n -> Dom n\nshl a b =\n  if sz > mask`{n} then top\n  else interval (drop lo) (drop sz)\n  where\n    al, ah : [n + 1]\n    (al, ah) = zbounds a\n    bl, bh : [n]\n    (bl, bh) = ubounds b\n        cl, ch : [n + 2]\n    cl = if bl < `n then 1 << bl else bit`{n}\n    ch = if bh < `n then 1 << bh else bit`{n}\n    (lo, hi) = mulRange (al, ah) (cl, ch)\n    sz = hi - lo\n\nlshr : {n} (fin n) => Dom n -> Dom n -> Dom n\nlshr a b = interval cl (ch - cl)\n  where\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    cl = al >> bh\n    ch = ah >> bl\n\nashr : {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n\nashr a b = interval cl (ch - cl)\n  where\n    (al, ah) = sbounds a\n    (bl, bh) = ubounds b\n    cl = al >>$ (if al <$ 0 then bl else bh)\n    ch = ah >>$ (if ah <$ 0 then bh else bl)\n\nult : {n} (fin n) => Dom n -> Dom n -> Bit\nult a b = (ubounds a).1 < (ubounds b).0\n\nule : {n} (fin n) => Dom n -> Dom n -> Bit\nule a b = (ubounds a).1 <= (ubounds b).0\n\nslt : {n} (fin n, n >= 1) => Dom n -> Dom n -> Bit\nslt a b = (sbounds a).1 <$ (sbounds b).0\n\nsle : {n} (fin n, n >= 1) => Dom n -> Dom n -> Bit\nsle a b = (sbounds a).1 <=$ (sbounds b).0\n\nult_sum_common_equiv : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nult_sum_common_equiv a b c =\n  if al == ah \/\\ bl == bh \/\\ al == bl\n    then True\n    else if ~(carry cl c.sz)\n      then check_same_wrap_interval cl ch\n      else check_same_wrap_interval cl mask`{n} \/\\ check_same_wrap_interval 0 ch\n  where\n    (cl, ch) = (c.lo, c.lo + c.sz)\n    (al, ah) = ubounds a\n    (bl, bh) = ubounds b\n    check_same_wrap_interval lo hi =\n      ~(carry ah hi) \/\\ ~(carry bh hi) \\\/ carry al lo \/\\ carry bl lo\n\nunknowns : {n} (fin n, n >= 1) => Dom n -> [n]\nunknowns a = if carry a.lo a.sz then ~0 else bits\n where\n bits = fillright diff\n diff = a.lo ^ (a.lo + a.sz)\n\nfillright : {n} (fin n, n >= 1) => [n] -> [n]\nfillright x = tail (scanl (||) False x)\n\nfillright_alt : {n} (fin n, n >= 1) => [n] -> [n]\nfillright_alt x = x || ((1 << lg2 x) - 1)\n\nproperty fillright_equiv x = fillright`{16} x == fillright_alt x\n\ninfix 20 =@=\n\n(=@=) : {n} (fin n) => Dom n -> Dom n -> Bit\na =@= b = (a.sz == ~0 \/\\ b.sz == ~0) \\\/ (a == b)\n\ninfix 5 <==>\n\n(<==>) : Bit -> Bit -> Bit\n(<==>) = (==)\n\ncorrect_top : {n} (fin n) => [n] -> Bit\ncorrect_top x = mem top x\n\ncorrect_ubounds : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_ubounds a x =\n  mem a x ==> umem (ubounds a) x\n\ncorrect_sbounds : {n} (fin n, n >= 1) => Dom n -> [n] -> Bit\ncorrect_sbounds a x =\n  mem a x ==> smem (sbounds a) x\n\ncorrect_singleton : {n} (fin n) => [n] -> [n] -> Bit\ncorrect_singleton x y =\n  mem (singleton x) y <==> x == y\n\ncorrect_overlap : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_overlap a b x =\n  mem a x ==> mem b x ==> overlap a b\n\ncorrect_overlap_inv : {n} (fin n) => Dom n -> Dom n -> Bit\ncorrect_overlap_inv a b =\n  overlap a b ==> (mem a witness \/\\ mem b witness)\n\n where\n witness = if mem a b.lo then b.lo else a.lo\n\ncorrect_union : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\ncorrect_union a b x =\n  (mem a x \\\/ mem b x) ==> mem (union a b) x\n\ncorrect_zero_ext : {m, n} (fin m, m >= n) => Dom n -> [n] -> Bit\ncorrect_zero_ext a x =\n  mem a x ==> mem (zero_ext`{m} a) (zext`{m} x)\n\ncorrect_sign_ext : {m, n} (fin m, m >= n, n >= 1) => Dom n -> [n] -> Bit\ncorrect_sign_ext a x =\n  mem a x ==> mem (sign_ext`{m} a) (sext`{m} x)\n\ncorrect_concat : {m, n} (fin m, fin n) => Dom m -> Dom n -> [m] -> [n] -> Bit\ncorrect_concat a b x y =\n  mem a x ==> mem b y ==> mem (concat a b) (x # y)\n\ncorrect_shrink : {m, n} (fin m, fin n) => Dom (m + n) -> [m + n] -> Bit\ncorrect_shrink a x =\n  mem a x ==> mem (shrink`{m} a) (take`{m} x)\n\ncorrect_trunc : {m, n} (fin m, fin n) => Dom (m + n) -> [m + n] -> Bit\ncorrect_trunc a x =\n  mem a x ==> mem (trunc`{m} a) (drop`{m} x)\n\ncorrect_add : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_add a b x y =\n  mem a x ==> mem b y ==> mem (add a b) (x + y)\n\ncorrect_neg : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_neg a x =\n  mem a x <==> mem (neg a) (- x)\n\ncorrect_mul : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_mul a b x y =\n  mem a x ==> mem b y ==> mem (mul a b) (x * y)\n\ncorrect_mulRange : {n} (fin n, n >= 1) => ([n], [n]) -> ([n], [n]) -> [n] -> [n] -> Bit\ncorrect_mulRange a b x y =\n  smem a x ==> smem b y ==> smem (mulRange a b) (sext x * sext y)\n\ncorrect_udiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_udiv a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (udiv a b) (x \/ y)\n\ncorrect_urem : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_urem a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (urem a b) (x % y)\n\ncorrect_sdivRange : {n} (fin n, n >= 1) => ([n], [n]) -> ([n], [n]) -> [n] -> [n] -> Bit\ncorrect_sdivRange a b x y =\n  smem a x ==> umem b y ==> y != 0 ==> smem (sdivRange a (b.1, b.0)) (sext x \/$ sext y)\n\ncorrect_shrinkRange : {n} (fin n, n >= 1) => ([n], [n]) -> [n] -> [n] -> Bit\ncorrect_shrinkRange a x y =\n  smem a x ==> y != 0 ==> smem (shrinkRange a y) (sext x \/$ sext y)\n\ncorrect_sdiv : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_sdiv a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (sdiv a b) (x \/$ y)\n\ncorrect_srem : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_srem a b x y =\n  mem a x ==> mem b y ==> y != 0 ==> mem (srem a b) (x %$ y)\n\ncorrect_shl : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_shl a b x y =\n  mem a x ==> mem b y ==> mem (shl a b) (x << y)\n\ncorrect_lshr : {n} (fin n) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_lshr a b x y =\n  mem a x ==> mem b y ==> mem (lshr a b) (x >> y)\n\ncorrect_ashr : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_ashr a b x y =\n  mem a x ==> mem b y ==> mem (ashr a b) (x >>$ y)\n\ncorrect_slt : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_slt a b x y =\n  slt a b ==> mem a x ==> mem b y ==> x <$ y\n\ncorrect_sle : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_sle a b x y =\n  sle a b ==> mem a x ==> mem b y ==> x <=$ y\n\ncorrect_ult : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_ult a b x y =\n  ult a b ==> mem a x ==> mem b y ==> x < y\n\ncorrect_ule : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit\ncorrect_ule a b x y =\n  ule a b ==> mem a x ==> mem b y ==> x <= y\n\ncorrect_ult_sum_common_equiv :\n  {n} (fin n, n >= 1) => Dom n -> Dom n -> Dom n -> [n] -> [n] -> [n] -> Bit\ncorrect_ult_sum_common_equiv a b c x y z =\n  ult_sum_common_equiv a b c ==>\n  mem a x ==> mem b y ==> mem c z ==>\n  (x + z < y + z <==> x < y)\n\ncorrect_bnot : {n} (fin n) => Dom n -> [n] -> Bit\ncorrect_bnot a x =\n  mem a x <==> mem (bnot a) (~ x)\n\ncorrect_isSingleton : {n} (fin n) => Dom n -> Bit\ncorrect_isSingleton a =\n  isSingleton a ==> a == singleton a.lo\n\ncorrect_unknowns : {n} (fin n, n >= 1) => Dom n -> [n] -> [n] -> Bit\ncorrect_unknowns a x y =\n  mem a x ==> mem a y ==> (x || unknowns a) == (y || unknowns a)\n\nproperty p1 = correct_top`{16}\nproperty p2 = correct_ubounds`{16}\nproperty p3 = correct_sbounds`{16}\nproperty p4 = correct_singleton`{16}\nproperty p5 = correct_overlap`{16}\nproperty p5_inv = correct_overlap_inv`{16}\nproperty p6 = correct_union`{8}\nproperty p7 = correct_zero_ext`{32, 16}\nproperty p8 = correct_sign_ext`{32, 16}\nproperty p9 = correct_concat`{16, 16}\nproperty p10 = correct_shrink`{8, 8}\nproperty p11 = correct_trunc`{8, 8}\nproperty p12 = correct_unknowns`{16}\nproperty p13 = correct_isSingleton`{16}\n\nproperty a1 = correct_add`{8}\nproperty a2 = correct_neg`{16}\nproperty a3 = correct_mul`{4}\nproperty a4 = correct_udiv`{8}\nproperty a5 = correct_urem`{6}\nproperty a6 = correct_sdiv`{6}\nproperty a7 = correct_srem`{6}\nproperty a8 = correct_bnot`{16}\nproperty a9 = correct_sdivRange`{6}\n\nproperty s1 = correct_shl`{8}\nproperty s2 = correct_lshr`{8}\nproperty s3 = correct_ashr`{8}\n\nproperty o1 = correct_slt`{16}\nproperty o2 = correct_sle`{16}\nproperty o3 = correct_ult`{16}\nproperty o4 = correct_ule`{16}\nproperty o5 = correct_ult_sum_common_equiv`{4}\n\nsingleton_overlap : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_overlap x y =\n  overlap (singleton x) (singleton y) == (x == y)\n\nsingleton_zero_ext : {m, n} (fin m, m >= n) => [n] -> Bit\nsingleton_zero_ext x =\n  zero_ext`{m} (singleton x) == singleton (zext`{m} x)\n\nsingleton_sign_ext : {m, n} (fin m, m >= n, n >= 1) => [n] -> Bit\nsingleton_sign_ext x =\n  sign_ext`{m} (singleton x) == singleton (sext`{m} x)\n\nsingleton_concat : {m, n} (fin m, fin n) => [m] -> [n] -> Bit\nsingleton_concat x y =\n  concat (singleton x) (singleton y) == singleton (x # y)\n\nsingleton_shrink : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_shrink x =\n  shrink`{m} (singleton x) == singleton (take`{m} x)\n\nsingleton_trunc : {m, n} (fin m, fin n) => [m + n] -> Bit\nsingleton_trunc x =\n  trunc`{m} (singleton x) == singleton (drop`{m} x)\n\nsingleton_add : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_add x y =\n  add (singleton x) (singleton y) == singleton (x + y)\n\nsingleton_neg : {n} (fin n) => [n] -> Bit\nsingleton_neg x =\n  neg (singleton x) == singleton (- x)\n\nsingleton_mul : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_mul x y =\n  mul (singleton x) (singleton y) == singleton (x * y)\n\nsingleton_mulRange : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_mulRange x y =\n  mulRange (x, x) (y, y) == (sext x * sext y, sext x * sext y)\n\nsingleton_udiv : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_udiv x y =\n  y != 0 ==> udiv (singleton x) (singleton y) == singleton (x \/ y)\n\nsingleton_urem : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_urem x y =\n  y != 0 ==> urem (singleton x) (singleton y) == singleton (x % y)\n\nsingleton_sdiv : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_sdiv x y =\n  y != 0 ==> sdiv (singleton x) (singleton y) == singleton (x \/$ y)\n\nsingleton_srem : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_srem x y =\n  y != 0 ==> srem (singleton x) (singleton y) == singleton (x %$ y)\n\nsingleton_shl : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_shl x y =\n  shl (singleton x) (singleton y) == singleton (x << y)\n\nsingleton_lshr : {n} (fin n) => [n] -> [n] -> Bit\nsingleton_lshr x y =\n  lshr (singleton x) (singleton y) == singleton (x >> y)\n\nsingleton_ashr : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ashr x y =\n  ashr (singleton x) (singleton y) == singleton (x >>$ y)\n\nsingleton_slt : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_slt x y =\n  slt (singleton x) (singleton y) == (x <$ y)\n\nsingleton_sle : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_sle x y =\n  sle (singleton x) (singleton y) == (x <=$ y)\n\nsingleton_ult : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ult x y =\n  ult (singleton x) (singleton y) == (x < y)\n\nsingleton_ule : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsingleton_ule x y =\n  ule (singleton x) (singleton y) == (x <= y)\n\nproperty i01 = singleton_overlap`{16}\nproperty i02 = singleton_zero_ext`{32, 16}\nproperty i03 = singleton_sign_ext`{32, 16}\nproperty i04 = singleton_concat`{16, 16}\nproperty i05 = singleton_shrink`{8, 8}\nproperty i06 = singleton_trunc`{8, 8}\nproperty i07 = singleton_add`{8}\nproperty i08 = singleton_neg`{16}\nproperty i09 = singleton_mul`{4}\nproperty i10 = singleton_udiv`{8}\nproperty i11 = singleton_urem`{8}\nproperty i12 = singleton_sdiv`{8}\nproperty i13 = singleton_srem`{8}\nproperty i14 = singleton_shl`{8}\nproperty i15 = singleton_lshr`{8}\nproperty i16 = singleton_ashr`{8}\nproperty i17 = singleton_slt`{16}\nproperty i18 = singleton_sle`{16}\nproperty i19 = singleton_ult`{16}\nproperty i20 = singleton_ule`{16}\n\ncomm_overlap : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_overlap a b = overlap a b <==> overlap b a\n\ncomm_add : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_add a b = add a b == add b a\n\nassoc_add : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nassoc_add a b c = add a (add b c) =@= add (add a b) c\n\ncomm_mul : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_mul a b = mul a b == mul b a\n\nassoc_mul : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nassoc_mul a b c = mul a (mul b c) =@= mul (mul a b) c\n\ncomm_mulRange :\n  {i, j} (fin i, fin j, i >= 1, j >= 1) => ([i], [i]) -> ([j], [j]) -> Bit\ncomm_mulRange a b =\n  a.0 <=$ a.1 ==> b.0 <=$ b.1 ==> mulRange a b == mulRange b a\n\nassoc_mulRange :\n  {i, j, k} (fin i, fin j, fin k, i >= 1, j >= 1, k >= 1) =>\n  ([i], [i]) -> ([j], [j]) -> ([k], [k]) -> Bit\nassoc_mulRange a b c =\n  a.0 <=$ a.1 ==>\n  b.0 <=$ b.1 ==>\n  c.0 <=$ c.1 ==>\n  mulRange a (mulRange b c) == mulRange (mulRange a b) c\n\nproperty c1 = comm_overlap`{16}\nproperty c2 = comm_add`{16}\nproperty c3 = assoc_add`{16}\nproperty c4 = comm_mul`{4}\nproperty c5 = comm_mulRange`{4,4}\nproperty c6 = assoc_mulRange`{3,3,3}\n\ncomm_union : {n} (fin n) => Dom n -> Dom n -> Bit\ncomm_union a b = union a b == union b a\n\nassoc_union : {n} (fin n) => Dom n -> Dom n -> Dom n -> Bit\nassoc_union a b c = union a (union b c) == union (union a b) c\n\nlo_union : {n} (fin n) => Dom n -> Dom n -> Bit\nlo_union a b =\n  union a b == top \\\/ (union a b).lo == a.lo \\\/ (union a b).lo == b.lo\n\nhi_union : {n} (fin n) => Dom n -> Dom n -> Bit\nhi_union a b = c == top \\\/ c_hi == a_hi \\\/ c_hi == b_hi\n  where\n    c = union a b\n    a_hi = a.lo + a.sz\n    b_hi = b.lo + b.sz\n    c_hi = c.lo + c.sz\n\nnontriv_union : {n} (fin n) => Dom n -> Dom n -> [n] -> Bit\nnontriv_union a b x =\n  union a b =@= top ==> mem a x \\\/ mem b x\n\nnonzero_union : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nnonzero_union lo sz =\n  mem (union a b) half \/\\\n  (~ mem a 0 ==> ~ mem b 0 ==> ~ mem (union a b) 0)\n  where\n    half : [n]\n    half = reverse 1\n    a = interval lo sz\n    b = interval (lo + half) sz\n\nproperty u1 = comm_union`{16}\nproperty u2 = lo_union`{16}\nproperty u3 = hi_union`{16}\nproperty u4 = nontriv_union`{8}\nproperty u5 = nonzero_union`{16}\n```"}]}
{"filename":"saw-script\/deps\/cryptol\/tests\/enum\/BasicEnums.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the enums E1, M, and N, the functions c1, c2, and c3 with the same behavior and types, and the constants e1 and e2, suitable for use in enumeration and pattern-matching tests."},{"role":"assistant","content":"```cryptol\nenum E1  = A | B | C\nenum M a = N | J a\nenum N n a =\n  |  X [n]\n  | Y [n-2]\n  | Z a\n\nc1 e =\n  case e of\n    A -> 1 : [8]\n    B -> 2\n    C -> 3\n\nc2 : {n} (n>=2) => N n [n] -> [n]\nc2 e =\n  case e of\n    X a -> a\n    Y b -> zero`{[2]} # b\n    Z a -> a\n\nc3 e = case e of A -> 1 : [8]; B -> 2; C -> 3\n\ne1 = N\ne2 = Y 3\n```"}]}
{"filename":"saw-script\/deps\/cryptol\/tests\/issues\/issue_1867.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a module `Param` with a type parameter `n` and parameter `myparam : [n]`, and implement `foo : {m} [m][n] -> [m][n]` and `bar` as mapping bitwise `(&&) myparam` over their input arrays, matching the given behavior."},{"role":"assistant","content":"```cryptol\nmodule Param where\n\nparameter\n  type n : #\n  myparam : [n]\n\nfoo : {m} [m][n] -> [m][n]\nfoo = map ((&&) myparam)\n\nbar = map ((&&) myparam)\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/NQueens.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the N-Queens solver `nQueens : {n} (fin n, n >= 1) => Board n -> Bit` and a property `nQueensProve` asserting that for all boards `x`, `nQueens x == False`, suitable for verification with SAW against an LLVM\/Java implementation."},{"role":"assistant","content":"```cryptol\nall : {n, a} (fin n) => (a -> Bit, [n]a) -> Bit\nall (f, xs) = [ f x | x <- xs ] == ~zero\n\ncontains xs e = [ x == e | x <- xs ] != zero\n\ndistinct : {n,a} (fin n, Cmp a) => [n]a -> Bit\ndistinct xs =\n    [ if n1 < n2 then x != y else True\n    | (x,n1) <- numXs , (y,n2) <- numXs\n    ] == ~zero\n  where\n  numXs = [ (x,n) | x <- xs | n <- [ (0:[width n]) ... ] ]\n\ntype Position n = [width (n - 1)]\n\ntype Board n = [n](Position n)\n\ntype Solution n = Board n -> Bit\n\ncheckDiag : {n} (fin n, n >= 1) => Board n -> (Position n, Position n) -> Bit\ncheckDiag qs (i, j) = (i >= j) || (diffR != diffC)\n  where   qi = qs @ i\n          qj = qs @ j\n          diffR = if qi >= qj then qi-qj else qj-qi\n          diffC = j - i                   \nnQueens : {n} (fin n, n >= 1) => Solution n\nnQueens qs = all (inRange qs, qs) && all (checkDiag qs, ijs `{n}) && distinct qs\n\nijs : {n}(fin n, n>= 1)=> [_](Position n, Position n)\nijs = [ (i, j) | i <- [0 .. (n-1)], j <- [0 .. (n-1)]]\n\ninRange : {n} (fin n, n >= 1) => Board n -> Position n -> Bit\ninRange qs x = x <= `(n - 1)\n\nproperty nQueensProve x = (nQueens x) == False\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/Cipher.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define this Cipher module by implementing a generic block cipher interface with an encrypt and decrypt function matching the given Cipher type, where both operate on a key and block of configurable bit-vector sizes."},{"role":"assistant","content":"```cryptol\nmodule Cipher where\n\ntype Cipher KeySize BlockSize =\n  { encrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  , decrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  }\n```"}]}
{"filename":"saw-script\/doc\/llvm-java-verification-with-saw\/code\/ffs.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions ffs_ref : [32] -> [32] and ffs_imp : [32] -> [32], and a property ffs_correct stating that for all 32-bit inputs x, ffs_ref x == ffs_imp x."},{"role":"assistant","content":"```cryptol\nffs_ref: [32] -> [32]\nffs_ref x = ixs!0 where\n    ixs = [0] # [ if (x && (1 << i)) != 0 then (i+1) else prev\n                | prev <- ixs\n                | i <- [31, 30 .. 0]:[32][32]\n                ]\n\nffs_imp: [32] -> [32]\nffs_imp i = if (i'''' > 0) then (n'''' + ((i'''' + 1) && 1)) else 0 where\n    n = 1\n    (n', i') =       if (zero==(i && 0x0000ffff))    then (n + 16, i >> 16) else (n, i)\n    (n'', i'') =     if (zero==(i' && 0x000000ff))   then (n' + 8, i' >> 8) else (n', i')\n    (n''', i''') =   if (zero==(i'' && 0x0000000f))  then (n'' + 4, i'' >> 4) else (n'',i'')\n    (n'''', i'''') = if (zero==(i''' && 0x00000003)) then (n''' + 2, i''' >> 2) else (n''', i''')\n\nproperty ffs_correct x = ffs_ref x == ffs_imp x\n```"}]}
{"filename":"saw-script\/doc\/rust-verification-with-saw\/code\/salsa20\/Salsa20Extras.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the Salsa20Extras module, defining counter_setup and apply_keystream with the given types, using Salsa20_rounds and littleendian_state_inverse from the Salsa20 module, suitable for use in formal verification of Salsa20 keystream application."},{"role":"assistant","content":"```cryptol\nmodule Salsa20Extras where\n\nimport Salsa20\n\ntype STATE_WORDS = 16\ntype BLOCK_SIZE = 64\n\ncounter_setup : [STATE_WORDS][32] -> [64] -> [STATE_WORDS][32]\ncounter_setup state counter =\n  updates state [8, 9] [drop counter, drop (counter >> 32)]\n\napply_keystream : [32] -> [STATE_WORDS][32] -> [64] -> [BLOCK_SIZE][8] -> [BLOCK_SIZE][8]\napply_keystream count state0 counter output =\n    output ^ littleendian_state_inverse state2\n  where\n    state1 = counter_setup state0 counter\n    state2 = Salsa20_rounds count state1 state1\n```"}]}
{"filename":"saw-script\/doc\/rust-verification-with-saw\/code\/salsa20\/Salsa20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the Salsa20 stream cipher, including quarterround, rowround, columnround, doubleround, littleendian conversions, Salsa20 core and expansion, and properties that check against the given test vectors and verify collision-freedom of doubleround."},{"role":"assistant","content":"```cryptol\nmodule Salsa20 where\n\nquarterround : [4][32] -> [4][32]\nquarterround [y0, y1, y2, y3] = [z0, z1, z2, z3]\n  where\n    z1 = y1 ^ ((y0 + y3) <<< 0x7)\n    z2 = y2 ^ ((z1 + y0) <<< 0x9)\n    z3 = y3 ^ ((z2 + z1) <<< 0xd)\n    z0 = y0 ^ ((z3 + z2) <<< 0x12)\n\nproperty quarterround_passes_tests =\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000000] == [0x00000000, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (quarterround [0x00000001, 0x00000000, 0x00000000, 0x00000000] == [0x08008145, 0x00000080, 0x00010200, 0x20500000]) \/\\\n  (quarterround [0x00000000, 0x00000001, 0x00000000, 0x00000000] == [0x88000100, 0x00000001, 0x00000200, 0x00402000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000001, 0x00000000] == [0x80040000, 0x00000000, 0x00000001, 0x00002000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000001] == [0x00048044, 0x00000080, 0x00010000, 0x20100001]) \/\\\n  (quarterround [0xe7e8c006, 0xc4f9417d, 0x6479b4b2, 0x68c67137] == [0xe876d72b, 0x9361dfd5, 0xf1460244, 0x948541a3]) \/\\\n  (quarterround [0xd3917c5b, 0x55f1c407, 0x52a58a7a, 0x8f887a3b] == [0x3e2f308c, 0xd90a8f36, 0x6ab2a923, 0x2883524c])\n\nrowround : [16][32] -> [16][32]\nrowround [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15] =\n    [z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15]\n  where\n    [ z0,  z1,  z2,  z3] = quarterround [ y0,  y1,  y2,  y3]\n    [ z5,  z6,  z7,  z4] = quarterround [ y5,  y6,  y7,  y4]\n    [z10, z11,  z8,  z9] = quarterround [y10, y11,  y8,  y9]\n    [z15, z12, z13, z14] = quarterround [y15, y12, y13, y14]\n\nproperty rowround_passes_tests =\n  (rowround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n            [0x08008145, 0x00000080, 0x00010200, 0x20500000,\n             0x20100001, 0x00048044, 0x00000080, 0x00010000,\n             0x00000001, 0x00002000, 0x80040000, 0x00000000,\n             0x00000001, 0x00000200, 0x00402000, 0x88000100]) \/\\\n  (rowround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n             0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n             0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n             0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n            [0xa890d39d, 0x65d71596, 0xe9487daa, 0xc8ca6a86,\n             0x949d2192, 0x764b7754, 0xe408d9b9, 0x7a41b4d1,\n             0x3402e183, 0x3c3af432, 0x50669f96, 0xd89ef0a8,\n             0x0040ede5, 0xb545fbce, 0xd257ed4f, 0x1818882d])\n\nrowround_opt : [16][32] -> [16][32]\nrowround_opt ys = join [ (quarterround (yi<<<i))>>>i | yi <- split ys | i <- [0 .. 3] ]\n\nproperty rowround_opt_is_rowround ys = rowround ys == rowround_opt ys\n\ncolumnround : [16][32] -> [16][32]\ncolumnround [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15] =\n    [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15]\n  where\n    [ y0,  y4,  y8, y12] = quarterround [ x0,  x4,  x8, x12]\n    [ y5,  y9, y13,  y1] = quarterround [ x5,  x9, x13,  x1]\n    [y10, y14,  y2,  y6] = quarterround [x10, x14,  x2,  x6]\n    [y15,  y3,  y7, y11] = quarterround [x15,  x3,  x7, x11]\n\nproperty columnround_passes_tests =\n  (columnround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x10090288, 0x00000000, 0x00000000, 0x00000000,\n                0x00000101, 0x00000000, 0x00000000, 0x00000000,\n                0x00020401, 0x00000000, 0x00000000, 0x00000000,\n                0x40a04001, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (columnround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n                0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n                0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n                0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n               [0x8c9d190a, 0xce8e4c90, 0x1ef8e9d3, 0x1326a71a,\n                0x90a20123, 0xead3c4f3, 0x63a091a0, 0xf0708d69,\n                0x789b010c, 0xd195a681, 0xeb7d5504, 0xa774135c,\n                0x481c2027, 0x53a8e4b5, 0x4c1f89c5, 0x3f78c9c8])\n\ncolumnround_opt : [16][32] -> [16][32]\ncolumnround_opt xs = join (transpose [ (quarterround (xi<<<i))>>>i | xi <- transpose(split xs) | i <- [0 .. 3] ])\n\ncolumnround_opt_is_columnround xs = columnround xs == columnround_opt xs\n\nproperty columnround_is_transpose_of_rowround ys =\n  rowround ys == join(transpose(split`{4}(columnround xs)))\n  where xs = join(transpose(split`{4} ys))\n\ndoubleround : [16][32] -> [16][32]\ndoubleround(xs) = rowround(columnround(xs))\n\nproperty doubleround_passes_tests =\n  (doubleround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x8186a22d, 0x0040a284, 0x82479210, 0x06929051,\n                0x08000090, 0x02402200, 0x00004000, 0x00800000,\n                0x00010200, 0x20400000, 0x08008104, 0x00000000,\n                0x20500000, 0xa0000040, 0x0008180a, 0x612a8020]) \/\\\n  (doubleround [0xde501066, 0x6f9eb8f7, 0xe4fbbd9b, 0x454e3f57,\n                0xb75540d3, 0x43e93a4c, 0x3a6f2aa0, 0x726d6b36,\n                0x9243f484, 0x9145d1e8, 0x4fa9d247, 0xdc8dee11,\n                0x054bf545, 0x254dd653, 0xd9421b6d, 0x67b276c1] ==\n               [0xccaaf672, 0x23d960f7, 0x9153e63a, 0xcd9a60d0,\n                0x50440492, 0xf07cad19, 0xae344aa0, 0xdf4cfdfc,\n                0xca531c29, 0x8e7943db, 0xac1680cd, 0xd503ca00,\n                0xa74b2ad6, 0xbc331c5c, 0x1dda24c7, 0xee928277])\n\nlittleendian : [4][8] -> [32]\nlittleendian b = join(reverse b)\n\nproperty littleendian_passes_tests =\n  (littleendian [  0,   0,   0,   0] == 0x00000000) \/\\\n  (littleendian [ 86,  75,  30,   9] == 0x091e4b56) \/\\\n  (littleendian [255, 255, 255, 250] == 0xfaffffff)\n\nlittleendian_inverse : {n} (fin n) => [8 * n] -> [n][8]\nlittleendian_inverse b = reverse(split b)\n\nproperty littleendian_is_invertable b = littleendian_inverse(littleendian b) == b\n\nlittleendian_state : [64][8] -> [16][32]\nlittleendian_state b = [littleendian xi | xi <- split b]\n\nlittleendian_state_inverse : [16][32] -> [64][8]\nlittleendian_state_inverse w = join (map littleendian_inverse w)\n\nproperty littleendian_state_is_invertable b = littleendian_state_inverse(littleendian_state b) == b\n\nSalsa20 : [32] -> [64][8] -> [64][8]\nSalsa20 count xs = littleendian_state_inverse (Salsa20_rounds count xw xw)\n  where\n    xw = littleendian_state xs\n\nSalsa20_rounds : [32] -> [16][32] -> [16][32] -> [16][32]\nSalsa20_rounds count xw xw' = xw + zs@(count\/2)\n  where\n    zs = [xw'] # [ doubleround zi | zi <- zs ]\n\nproperty Salsa20_passes_tests =\n  (Salsa20 20 [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0] ==\n              [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n                 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]) \/\\\n  (Salsa20 20 [211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37, 191, 187, 234, 136,\n                49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,  86,  16, 179, 207,\n                31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113, 238,  55, 204,  36,\n                79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,  88, 118, 104,  54] ==\n              [109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,  26, 110, 170, 154,\n                29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,  69, 144,  51,  57,\n               118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35,  27, 111, 114, 114,\n               219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158, 179,  19,  48, 202]) \/\\\n  (Salsa20 20 [ 88, 118, 104,  54,  79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,\n               191, 187, 234, 136, 211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37,\n                86,  16, 179, 207,  49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,\n               238,  55, 204,  36,  31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113] ==\n              [179,  19,  48, 202, 219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158,\n                26, 110, 170, 154, 109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,\n                69, 144,  51,  57,  29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,\n                27, 111, 114, 114, 118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35])\n\nproperty Salsa20_has_no_collisions x1 x2 =\n  if(x1 != x2) then (doubleround x1) != (doubleround x2) else True\n\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([32], [16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(count, k, n) = Salsa20 count (Salsa20_init(k, n))\n\nSalsa20_init : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_init(k, n) = x\n  where\n    [s0, s1, s2, s3] = split \"expand 32-byte k\" : [4][4][8]\n    [t0, t1, t2, t3] = split \"expand 16-byte k\" : [4][4][8]\n    x = if(`a == 2) then s0 # k0 # s1 # n # s2 # k1 # s3\n                    else t0 # k0 # t1 # n # t2 # k0 # t3\n    [k0, k1] = (split(k#zero)):[2][16][8]\n\nSalsa20_encrypt_with_offset : {a, l} (a >= 1, 2 >= a, l <= 2^^70) =>\n    ([32], [16*a][8], [8][8], [64], [l][8]) -> [l][8]\nSalsa20_encrypt_with_offset(count, k, v, o, m) = c\n  where\n    salsa = take (join [ Salsa20_expansion(count, k, v#(littleendian_inverse (o + i))) | i <- [0, 1 ... ] ])\n    c = m ^ salsa\n\nSalsa20_encrypt : {a, l} (a >= 1, 2 >= a, l <= 2^^70) => ([32], [16*a][8], [8][8], [l][8]) -> [l][8]\nSalsa20_encrypt(count, k, v, m) = c\n  where\n    salsa = take (join [ Salsa20_expansion(count, k, v#(littleendian_inverse i)) | i <- [0, 1 ... ] ])\n    c = m ^ salsa\n```"}]}
{"filename":"saw-script\/otherTests\/cryptol-saw-core\/instance.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines these zero\/logic\/ring\/integral\/field\/round\/eq\/cmp\/signedCmp\/literal functions and add properties that they are extensionally equal to the corresponding built\u2011in operations (zero, complement, negate, %, recip, floor, ==, <, <$, numeric literals)."},{"role":"assistant","content":"```cryptol\nzeroBit : Bit\nzeroBit = zero\n\nzeroInteger : Integer\nzeroInteger = zero\n\nzeroRational : Rational\nzeroRational = zero\n\nzeroZ : {n} (fin n, n >= 1) => Z n\nzeroZ = zero\n\nzeroWord : {n} [n]\nzeroWord = zero\n\nzeroSeq : {n, a} (Zero a) => [n]a\nzeroSeq = zero\n\nzeroFloat : {e, p} (ValidFloat e p) => Float e p\nzeroFloat = zero\n\nzeroFun : {a, b} (Zero b) => a -> b\nzeroFun = zero\n\nzeroUnit : ()\nzeroUnit = zero\n\nzeroTuple : {a, b} (Zero a, Zero b) => (a, b)\nzeroTuple = zero\n\nzeroEmpty : {}\nzeroEmpty = zero\n\nzeroRecord : {a, b} (Zero a, Zero b) => {x : a, y : b}\nzeroRecord = zero\n\nlogicBit : Bit -> Bit\nlogicBit = complement\n\nlogicWord : {n} [n] -> [n]\nlogicWord = complement\n\nlogicSeq : {n, a} (Logic a) => [n]a -> [n]a\nlogicSeq = complement\n\nlogicFun : {a, b} (Logic b) => (a -> b) -> (a -> b)\nlogicFun = complement\n\nlogicUnit : () -> ()\nlogicUnit = complement\n\nlogicTuple : {a, b} (Logic a, Logic b) => (a, b) -> (a, b)\nlogicTuple = complement\n\nlogicEmpty : {} -> {}\nlogicEmpty = complement\n\nlogicRecord : {a, b} (Logic a, Logic b) => {x : a, y : b} -> {x : a, y : b}\nlogicRecord = complement\n\nringInteger : Integer -> Integer\nringInteger = negate\n\nringRational : Rational -> Rational\nringRational = negate\n\nringZ : {n} (fin n, n >= 1) => Z n -> Z n\nringZ = negate\n\nringWord : {n} (fin n) => [n] -> [n]\nringWord = negate\n\nringSeqInteger : {n} [n]Integer -> [n]Integer\nringSeqInteger = negate\n\nringSeqRational : {n} [n]Rational -> [n]Rational\nringSeqRational = negate\n\nringSeqZ : {n, k} (fin k, k >= 1) => [n](Z k) -> [n](Z k)\nringSeqZ = negate\n\nringSeqSeq : {n, k, a} (Ring ([k]a)) => [n][k]a -> [n][k]a\nringSeqSeq = negate\n\nringSeqFun : {n, a, b} (Ring b) => [n](a -> b) -> [n](a -> b)\nringSeqFun = negate\n\nringSeqUnit : {n} [n]() -> [n]()\nringSeqUnit = negate\n\nringSeqTuple : {n, a, b} (Ring a, Ring b) => [n](a, b) -> [n](a, b)\nringSeqTuple = negate\n\nringSeqEmpty : {n} [n]{} -> [n]{}\nringSeqEmpty = negate\n\nringSeqRecord : {n, a, b} (Ring a, Ring b) => [n]{x : a, y : b} -> [n]{x : a, y : b}\nringSeqRecord = negate\n\nringFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p\nringFloat = negate\n\nringFun : {a, b} (Ring b) => (a -> b) -> (a -> b)\nringFun = negate\n\nringUnit : () -> ()\nringUnit = negate\n\nringTuple : {a, b} (Ring a, Ring b) => (a, b) -> (a, b)\nringTuple = negate\n\nringEmpty : {} -> {}\nringEmpty = negate\n\nringRecord : {a, b} (Ring a, Ring b) => {x : a, y : b} -> {x : a, y : b}\nringRecord = negate\n\nintegralInteger : Integer -> Integer -> Integer\nintegralInteger = (%)\n\nintegralWord : {n} (fin n) => [n] -> [n] -> [n]\nintegralWord = (%)\n\nfieldRational : Rational -> Rational\nfieldRational = recip\n\nfieldFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p\nfieldFloat = recip\n\nfieldZ : {p} prime p => Z p -> Z p\nfieldZ = recip\n\nroundRational : Rational -> Integer\nroundRational = floor\n\nroundFloat : {e, p} (ValidFloat e p) => Float e p -> Integer\nroundFloat = floor\n\neqBit : Bit -> Bit -> Bit\neqBit = (==)\n\neqInteger : Integer -> Integer -> Bit\neqInteger = (==)\n\neqRational : Rational -> Rational -> Bit\neqRational = (==)\n\neqZ : {n} (fin n, n >= 1) => Z n -> Z n -> Bit\neqZ = (==)\n\neqWord : {n} (fin n) => [n] -> [n] -> Bit\neqWord = (==)\n\neqSeq : {n, a} (fin n, Eq a) => [n]a -> [n]a -> Bit\neqSeq = (==)\n\neqFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p -> Bit\neqFloat = (==)\n\neqUnit : () -> () -> Bit\neqUnit = (==)\n\neqTuple : {a, b} (Eq a, Eq b) => (a, b) -> (a, b) -> Bit\neqTuple = (==)\n\neqEmpty : {} -> {} -> Bit\neqEmpty = (==)\n\neqRecord : {a, b} (Eq a, Eq b) => {x : a, y : b} ->  {x : a, y : b} -> Bit\neqRecord = (==)\n\ncmpBit : Bit -> Bit -> Bit\ncmpBit = (<)\n\ncmpInteger : Integer -> Integer -> Bit\ncmpInteger = (<)\n\ncmpRational : Rational -> Rational -> Bit\ncmpRational = (<)\n\ncmpWord : {n} (fin n) => [n] -> [n] -> Bit\ncmpWord = (<)\n\ncmpSeq : {n, a} (fin n, Cmp a) => [n]a -> [n]a -> Bit\ncmpSeq = (<)\n\ncmpFloat : {e, p} (ValidFloat e p) => Float e p -> Float e p -> Bit\ncmpFloat = (<)\n\ncmpUnit : () -> () -> Bit\ncmpUnit = (<)\n\ncmpTuple : {a, b} (Cmp a, Cmp b) => (a, b) -> (a, b) -> Bit\ncmpTuple = (<)\n\ncmpEmpty : {} -> {} -> Bit\ncmpEmpty = (<)\n\ncmpRecord : {a, b} (Cmp a, Cmp b) => {x : a, y : b} ->  {x : a, y : b} -> Bit\ncmpRecord = (<)\n\nsignedCmpWord : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsignedCmpWord = (<$)\n\nsignedCmpSeqSeq : {n, k, a} (fin n, SignedCmp ([k]a)) => [n][k]a -> [n][k]a -> Bit\nsignedCmpSeqSeq = (<$)\n\nsignedCmpSeqUnit : {n} (fin n) => [n]() -> [n]() -> Bit\nsignedCmpSeqUnit = (<$)\n\nsignedCmpSeqTuple : {n, a, b} (fin n, SignedCmp a, SignedCmp b) => [n](a, b) -> [n](a, b) -> Bit\nsignedCmpSeqTuple = (<$)\n\nsignedCmpSeqEmpty : {n} (fin n) => [n]{} -> [n]{} -> Bit\nsignedCmpSeqEmpty = (<$)\n\nsignedCmpSeqRecord : {n, a, b} (fin n, SignedCmp a, SignedCmp b) => [n]{x : a, y : b} -> [n]{x : a, y : b} -> Bit\nsignedCmpSeqRecord = (<$)\n\nsignedCmpUnit : () -> () -> Bit\nsignedCmpUnit = (<$)\n\nsignedCmpTuple : {a, b} (SignedCmp a, SignedCmp b) => (a, b) -> (a, b) -> Bit\nsignedCmpTuple = (<$)\n\nsignedCmpEmpty : {} -> {} -> Bit\nsignedCmpEmpty = (<$)\n\nsignedCmpRecord : {a, b} (SignedCmp a, SignedCmp b) => {x : a, y : b} ->  {x : a, y : b} -> Bit\nsignedCmpRecord = (<$)\n\nliteralBit : {val} (1 >= val) => Bit\nliteralBit = `val\n\nliteralInteger : {val} (fin val) => Integer\nliteralInteger = `val\n\nliteralRational : {val} (fin val) => Rational\nliteralRational = `val\n\nliteralZ : {val, n} (fin val, fin n, n >= 1, n > val) => Z n\nliteralZ = `val\n\nliteralWord : {val, n} (fin val, fin n, n >= width val) => [n]\nliteralWord = `val\n\nliteralLessThanBit : {val} (1 >= val) => [val]Bit\nliteralLessThanBit = [0..<val]\n\nliteralLessThanInteger : {val} (fin val) => [val]Integer\nliteralLessThanInteger = [0..<val]\n\nliteralLessThanRational : {val} (fin val) => [val]Rational\nliteralLessThanRational = [0..<val]\n\nliteralLessThanZ : {val, n} (fin n, n >= 1, n >= val) => [val](Z n)\nliteralLessThanZ = [0..<val]\n\nliteralLessThanWord : {val, n} (fin n, n >= lg2 val) => [val][n]\nliteralLessThanWord = [0..<val]\n```"}]}
{"filename":"saw-script\/otherTests\/cryptol-saw-core\/superclass.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the given typeclass-constrained helper functions (zeroRing, zeroLogic, zeroIntegral, zeroField, zeroRound, fromIntIntegral, fromIntField, fromIntRound, recipRound, compareRound, eqCmp) and adds properties checking they behave as expected for all applicable instances."},{"role":"assistant","content":"```cryptol\nzeroRing : {a} (Ring a) => a\nzeroRing = zero\n\nzeroLogic : {a} (Logic a) => a\nzeroLogic = zero\n\nzeroIntegral : {a} (Integral a) => a\nzeroIntegral = zero\n\nzeroField : {a} (Field a) => a\nzeroField = zero\n\nzeroRound : {a} (Round a) => a\nzeroRound = zero\n\nfromIntIntegral : {a} (Integral a) => a\nfromIntIntegral = fromInteger 42\n\nfromIntField : {a} (Field a) => a\nfromIntField = fromInteger 42\n\nfromIntRound : {a} (Round a) => a\nfromIntRound = fromInteger 42\n\nrecipRound : {a} (Round a) => a -> Integer\nrecipRound x = trunc (recip x)\n\ncompareRound : {a} (Round a) => a -> a -> Bit\ncompareRound x y = x < y\n\neqCmp : {a} (Cmp a) => a -> a -> Bit\neqCmp x y = x == y\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/ModDivZ.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for modular division over Z p using an extended Euclidean algorithm, including the function moddiv : {p} (fin p, p >= 3) => Z p -> Z p -> Z p and any supporting functions so that (%\/) is defined as modular division and handles division by zero with an error."},{"role":"assistant","content":"```cryptol\nmodule Common::ModDivZ where\n\neven k = k % 2 == 0\n\nmoddiv : {p}(fin p, p >= 3) => Z p -> Z p -> Z p  moddiv x y = if y == 0 then error \"division by 0\"                         else fromInteger (egcd `p 0 (fromZ y) (fromZ x))\n    where\n\n    egcd : Integer -> Integer -> Integer -> Integer -> Integer\n    egcd a ra b rb =          if b == 0 then ra\n         | even b then egcd a ra (   b    \/ 2) (half rb)\n         | a < b  then egcd a ra ((b - a) \/ 2) (half ((rb - ra) % `p))\n                  else egcd b rb ((a - b) \/ 2) (half ((ra - rb) % `p))\n\n    half : Integer -> Integer\n    half k = (if even k then k else (k + `p)) \/ 2\n\n(%\/) = moddiv\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/mul_java.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that implements the Java-style multi-precision multiplication, squaring, and P-384 group reduction\/multiplication algorithms defined by mul_java, sq_java, p384_group_red, and p384_group_mul, including all helper functions with the same types and semantics."},{"role":"assistant","content":"```cryptol\nmodule Common::mul_java where\n\nimport Common::bv\n\nmul_java_inner : (Bit, [24][32], [32], [32], [32], [64]) -> { mji_a : [24][32], mji_d : [64]}\nmul_java_inner (azero, a, ij, xi, yj, d) = { mji_a = a', mji_d = d' >> 32 }\n  where\n    m        = zext(xi) * zext(yj)\n    d'       = d + m + zext(aij)\n    a'       = update a ij (drop(d'))\n    aij      = if ~azero then a @ ij else 0\n\n\/*\naset : {n, is} (fin n, fin is, n >= is, is >= lg2 n, n >= 32, is >= max(lg2 n, 6)) =>\n          ([n], [is], [is]) -> [n]\n*\/\naset (a, i, x) = (a && imask) || x'\n  where\n    imask = ~(zext(0xFFFFFFFF : [32]) << (i*32))\n    x' = zext(x) << (i*32)\n\naset_768 : ([768], [32], [32]) -> [768]\naset_768 = aset\n\ntoJavaArray : [384] -> [12][32]\ntoJavaArray x = reverse (split x)\n\nfromJavaArray : [12][32] -> [384]\nfromJavaArray x = join (reverse x)\n\n\/\/ Matches java implementation; computes safe_product.\nmul_java : ([768], [384], [384]) -> [768]\nmul_java (a0, x, y) = join (reverse (a_final!0))\n  where\n    l   = 12 : [32]\n    x'  = toJavaArray x\n    y'  = toJavaArray y\n    a0' = reverse (split a0) : [24][32]\n\n    a_first : [13]([64],[24][32])\n    a_first = [ (zero : [64], a0' : [24][32]) ]\n            # [ (res.mji_d, res.mji_a)\n                   where res = mul_java_inner(True, a, j, x'@0, y'@j, d)\n              | (d, a) <- a_first\n              | j      <- [0..11]\n              ]\n    (d_first_final, a_first_final) = a_first!0\n    ad_first_final = update a_first_final l (drop(d_first_final):[32])\n\n    \/* Second loop in Java implementation *\/\n    a_final : [12][24][32]\n    a_final = [ ad_first_final ]\n            # [ ad_inner_final\n                 where\n                   \/* Inner loop in Java implementation *\/\n                   a_inner : [13]([64],[24][32],[32])\n                   a_inner = [ ( zero : [64] \/* d *\/, a, i) ]\n                           # [ (res.mji_d, res.mji_a, ij+1)\n                                where\n                                  res = mul_java_inner(False, ai, ij, x'@i, y'@j, d)\n                             | (d, ai, ij) <- a_inner\n                             | j          <- [0..(12-1)]:[12][32]\n                             ]\n\n                   (d_inner_final, a_inner_final, ij_final) = a_inner!0\n                   ad_inner_final = update a_inner_final ij_final (drop(d_inner_final))\n              | a <- a_final\n              | i <- [1..11]\n              ]\n\nsq_java_inner1 : ([24][32], [32], [64]) -> { mji_a : [24][32], mji_d : [64]}\nsq_java_inner1 (a, ij, c) = { mji_a = a' , mji_d = c'' }\n  where\n    aij = a @ ij\n    c' = c + (zext(aij) << 1)\n    a' = update a ij (drop(c'))\n    c'' = c' >> 32\n\nsq_java_inner2 : ([24][32], [32], [32], [64]) ->\n                 { mji_a : [24][32], mji_d : [64]}\nsq_java_inner2 (a, ij, xati, c) = { mji_a = a' , mji_d = c'' }\n  where\n    aij = a @ ij\n    xi = zext(xati) : [64]\n    m = xi * xi\n    c' = c + (m && 0x00000000FFFFFFFF) + (zext(aij) << 1)\n    a' = update a ij (drop(c'))\n    c'' = (c' >> 32) + (m >> 32)\n\nsq_java_loop : ([24][32], [384]) -> [24][32]\nsq_java_loop(a0, x) = a_mid!0\n  where\n    \/* Second loop in Java implementation *\/\n    l = 12 : [32]\n    x'  = toJavaArray x\n    a_mid   = [ a0 ]\n            # [ ad_inner_final\n                 where\n\n                   a_inner = [ ( zero : [64] , a, i+i+1) ]\n                           # [ (res.mji_d, res.mji_a, ij+1)\n                                where\n                                  res = if j+i < l then\n                                          mul_java_inner(False, ai, ij, x'@i, x'@(j+i), d)\n                                        else zero\n                             | (d, ai, ij) <- a_inner\n                             | j          <- [1..(12-1)]\n                             ]\n                   (d_inner_final, a_inner_final, ij_final) = a_inner!i\n                   ad_inner_final = update a_inner_final ij_final (drop(d_inner_final))\n              | a <- a_mid\n              | i <- [1..(12-2)]\n              ]\n\nsq_java : ([768], [384]) -> [768]\nsq_java (a0, x) = join (reverse ad_final_final)\n  where\n    l   = 12 : [32]\n    x'  = toJavaArray x\n    a0' = reverse (split a0) : [24][32]\n    x0 = x'@0\n    \/* First loop in Java implementation *\/\n    a_first = [ (zero : [64], a0' : [24][32]) ]\n            # [ (res.mji_d, res.mji_a)\n                 where res = mul_java_inner(True, a, j, x0, x'@j, d)\n              | (d, a) <- a_first\n              | j      <- [1..11]\n              ]\n    (d_first_final, a_first_final) = a_first!0\n    ad_first_final = update a_first_final l (drop(d_first_final))\n\n    mid_res = mul_java_inner(True, sq_java_loop(ad_first_final, x), 0, x0, x0, 0)\n\n    \/* Third loop in Java implementation *\/\n    a_final : [12]([64],[24][32],[32])\n    a_final = [ (mid_res.mji_d, mid_res.mji_a, 1) ]\n            # [ (res'.mji_d, res'.mji_a, ij+2)\n                where\n                   res = sq_java_inner1(a, ij, c)\n                   res' = sq_java_inner2(res.mji_a, ij+1, x'@(i:[32]), res.mji_d)\n              | (c, a, ij) <- a_final\n              | i      <- [1..11]\n              ]\n    (d_final_final, a_final_final, ij_final) = a_final!0\n    ad_final_final = update a_final_final ((l << 1) - 1) (drop(d_final_final))\n\naset_384 : ([384], [32], [32]) -> [384]\naset_384(a, i, x) = fromJavaArray (update (toJavaArray a) i x)\n\njava_lashr32 : [64] -> [64]\njava_lashr32 x = take(sext(x) : [96])\n\ngroup_red_aux_java : ([384], [32], [32], [64], [64]) ->\n                     { gra_r: [384] , gra_b : [64] }\ngroup_red_aux_java(r, aj, j, c, b) = { gra_r = r' , gra_b = b'' }\n  where\n    rj, m, b' : [64]\n    rj = zext(toJavaArray r @ j)\n    m = c * zext(aj)\n    b' = b + rj - zext(drop(m):[32])\n    r' = aset_384(r, j, drop(b'))\n    b'' = java_lashr32(b') - (m >> 32)\n\ngroup_mul_aux_java : ([384], [32], [32], [32], [64]) ->\n                     { gra_r: [384] , gra_b : [64] }\ngroup_mul_aux_java(r, yj, j, xi, c) = { gra_r = r' , gra_b = c'' }\n  where\n    rj, m, c' : [64]\n    rj = zext(toJavaArray r @ j)\n    m = zext(xi) * zext(yj)\n    c' = c + rj + zext(drop(m):[32])\n    r' = aset_384(r, j, drop(c'))\n    c'' = (c' >> 32) + (m >> 32)\n\np384_group_red : ([384], [384], [64]) -> [384]\np384_group_red(order, r, c) = r'''\n  where\n    order' = toJavaArray order\n    loop : [13]([384],[64])\n    loop = [ (r, zero : [64]) ] #\n           [ (res.gra_r, res.gra_b)\n              where res = group_red_aux_java(rj, order'@j, j, c, bi)\n           | (rj, bi) <- loop\n           | j <- [0..11]\n           ]\n    (r', b) = loop!0\n    c' = c + b\n    (r'', c'') = if c' != 0 then\n                   (r' - order, c' + (if r' >= order then 0 else -1))\n                 else (r', c')\n    r''' = if c'' != 0 then r'' - order else r''\n\np384_group_mul : ([384], [384], [384]) -> [384]\np384_group_mul(order, x, y) = r'\n  where\n    xa = toJavaArray x\n    ya = toJavaArray y\n    outer : [13][384]\n    outer = [ (zero : [384]) ] #\n            [ p384_group_red(order, rn, cn)\n               where\n                 r0 : [384]\n                 r0 = p384_group_red(order,\n                                     ro << (32 : [9]),\n                                     zext(take(ro):[32]))\n                 inner : [13]([384], [64])\n                 inner = [ (r0, 0) ] #\n                         [ (res.gra_r, res.gra_b)\n                            where\n                              res = group_mul_aux_java(rj, ya@j, j, xa@(i:[32]), cj)\n                         | j <- [0..11]\n                         | (rj, cj) <- inner\n                         ]\n                 (rn, cn) = inner!0\n            | i <- reverse [0..11]\n            | ro <- outer\n            ]\n    r = outer!0\n    r' = if order <= r then r - order else r\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/utils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the utility functions and properties in module `Common::utils`, including `while`, `dowhile`, conversions between `Z`, bitvectors, `Integer`, `half` with `half_correct`, and `mp_mod_inv` with property `mp_mod_inv_correct` for all valid parameter sizes."},{"role":"assistant","content":"```cryptol\nmodule Common::utils where\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = (fromInteger (fromZ x))\n\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = (fromInteger (toInteger x))\n\nZtoZ : {p, q} (fin p, fin q, p >= 1, q >= 1) => Z p -> Z q\nZtoZ x = (fromInteger (fromZ x))\n\nintegerToBV : {m} (fin m) => Integer -> [m]\nintegerToBV x = fromInteger x\n\nintegerFromBV : {m} (fin m) => [m] -> Integer\nintegerFromBV x = toInteger x\n\nintegerModulusFromBV : {m} (fin m) => [m] -> Integer\nintegerModulusFromBV x = if (integerFromBV x) < 3 then 3 else (integerFromBV x)\n\nisEven : Integer -> Bit\nisEven x = ~((fromInteger x) : [1]) ! 0\n\nabs : Integer -> Integer\nabs x = if x >= zero then x else zero-x\n\nunzip : {a,f,s} [a](f,s) -> ([a]f,[a]s)\nunzip tuples = (map (\\x -> x.0) tuples , map (\\x -> x.1) tuples)\n\nmul2 x = x + x\nmul3 x = x + mul2 x\nmul4 x = mul2(mul2 x)\nmul8 x = mul2(mul4 x)\n\ntype constraint isOdd a = (a \/ 2) * 2 == a - 1\n\nhalf : {p} (fin p, p >= 3, isOdd p) => Z p -> Z p\nhalf x = fromInteger (if isEven xint then xint\/2 else ((xint + `p) \/ 2))\n  where\n    xint = fromZ x\n\nhalf_correct : {p} (fin p, p >= 3, isOdd p) => Z p -> Bit\nproperty half_correct x = half x + half x == x\n\nmp_mod_inv : {n} (fin n, n >= 1) => Z n -> Z n\nmp_mod_inv c = if c == 0 then error \"Zero does not have a multiplicative inverse\"\n               else fromInteger (if u'' == 1 then x1'' else x2'')\n  where\n    innercond (a, x) = isEven a\n    innerbody (a, x) = (a \/ 2, if isEven x then x \/ 2 else (x + `n) \/ 2)\n\n    outtercond (u, v, x1, x2) = (u != 1) \/\\ (v != 1)\n    outterbody (u, v, x1, x2) = if(u' >= v') then (u' - v', v', x1' - x2' % `n, x2')\n                                             else (u', v' - u', x1', x2' - x1' % `n)\n      where\n        (u', x1') = while innercond innerbody (u, x1)\n        (v', x2') = while innercond innerbody (v, x2)\n\n    (u'', _, x1'', x2'') = while outtercond outterbody (fromZ c, `n, 1, 0)\n\nmp_mod_inv_correct : {a} (fin a, a >=2) => Z a -> Bit\nproperty mp_mod_inv_correct x = x != 0 ==> x * mp_mod_inv x == 1\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/MAC\/HMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the HMAC module in Cryptol that implements generic HMAC over a hash function, including kinit, hmac, and the concrete instantiation hmacSHA256 using SHA256 with appropriate types and constraints, suitable for cryptographic verification."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::MAC::HMAC where\n\nimport Primitive::Keyless::Hash::SHA256\n\nhmacSHA256 : {pwBytes, msgBytes}\n             (fin pwBytes, fin msgBytes\n             , 32 >= width msgBytes\n             , 64 >= width (8*pwBytes)\n             , 64 >= width (8 * (64 + msgBytes))\n             ) => [pwBytes][8] -> [msgBytes][8] -> [256]\nhmacSHA256 = hmac `{blockLength=64} SHA256 SHA256 SHA256\n\nkinit : { pwBytes, blockLength, digest }\n        ( fin pwBytes, fin blockLength, fin digest )\n     => ([pwBytes][8] -> [8*digest])\n     -> [pwBytes][8]\n     -> [blockLength][8]\nkinit hash key =\n  if `pwBytes > (`blockLength : [max (width pwBytes) (width blockLength)])\n  then take `{blockLength} (split (hash key) # (zero : [blockLength][8]))\n  else take `{blockLength} (key # (zero : [blockLength][8]))\n\nhmac : { msgBytes, pwBytes, digest, blockLength }\n       ( fin pwBytes, fin digest, fin blockLength )\n    => ([blockLength + msgBytes][8] -> [8*digest])\n    -> ([blockLength + digest][8] -> [8*digest])\n    -> ([pwBytes][8] -> [8*digest])\n    -> [pwBytes][8]\n    -> [msgBytes][8]\n    -> [digest*8]\nhmac hash hash2 hash3 key message = hash2 (okey # internal)\n where\n   ks : [blockLength][8]\n   ks = kinit hash3 key\n   okey = [k ^ 0x5C | k <- ks]\n   ikey = [k ^ 0x36 | k <- ks]\n   internal = split (hash (ikey # message))\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/AES_256_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the Cryptol module Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM implementing AES-256 in Galois\/Counter Mode (GCM), including the AES_GCM_Ctx type, encryption\/CTR functions, GHASH\/polynomial multiplication helpers, and a cipher_final tag computation, suitable for verification of AES-256-GCM authenticated encryption."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM where\n\nimport Primitive::Symmetric::Cipher::Block::AES\n\naes_hw_encrypt : [16][8] -> [32][8] -> [16][8]\naes_hw_encrypt in key = split (aesEncrypt ((join in), (join key)))\n\ngcm_pmult_pmod : [128] -> [128] -> [128]\ngcm_pmult_pmod X Y = reverse (pmod (pmult (reverse X) (reverse Y)) <| x^^128 + x^^7 + x^^2 + x + 1|>)\n\ngcm_polyval_mul : {n} (fin n) => [2 * (1 + n)] -> [2 * (1 + n)] -> [4 * (1 + n)]\ngcm_polyval_mul X Y = (0 : [1]) # pmult X Y\n\ngcm_polyval_red : [256] -> [128]\ngcm_polyval_red X = reverse (pmod (reverse X) <| x^^128 + x^^7 + x^^2 + x + 1|>)\n\ngcm_polyval : [128] -> [128] -> [128]\ngcm_polyval X Y = gcm_polyval_red (gcm_polyval_mul X Y)\n\ngcm_init_H : [128] -> [128]\ngcm_init_H Xi = pmod (Xi # (0 : [1]))  <| 1 + x^^121 + x^^126 + x^^127 + x^^128 |>\n\ntype AES_GCM_Ctx =\n  { key : [32][8]\n  , iv : [12][8]\n  , Xi : [16][8]\n  , len : [64]\n  }\n\nget_H : AES_GCM_Ctx -> [2][64]\nget_H ctx = split (join (aes_hw_encrypt zero ctx.key))\n\nEKi : AES_GCM_Ctx -> [32] -> [16][8]\nEKi ctx i = aes_hw_encrypt (ctx.iv # (split (i + 1))) ctx.key\n\nEKij : AES_GCM_Ctx -> [32] -> [4] -> [8]\nEKij ctx i j = (EKi ctx i) @ j\n\ncipher_update : {n} (fin n) => [32] -> AES_GCM_Ctx -> [n][8] -> AES_GCM_Ctx\ncipher_update enc ctx in = ctx'\n  where\n    enc_bytes = if enc ! 0\n      then ctr32_encrypt ctx in\n      else in\n    ctx' = foldl cipher_update_byte ctx enc_bytes\n\nctr32_encrypt : {n} (fin n) => AES_GCM_Ctx -> [n][8] -> [n][8]\nctr32_encrypt ctx in = out\n  where\n    out = [ byte ^ (EKij ctx ((take`{32} (drop`{28} i)) + 1) (drop`{60} i)) | byte <- in | i <- [ctx.len ...] ]\n\ncipher_update_byte : AES_GCM_Ctx -> [8] -> AES_GCM_Ctx\ncipher_update_byte ctx byte = ctx'\n  where\n    H = join (get_H ctx)\n    n = ctx.len % 16\n    Xi' = update ctx.Xi n ((ctx.Xi @ n) ^ byte)\n    len' = ctx.len + 1\n    Xi'' = if (len' % 16) == 0\n      then split (gcm_pmult_pmod H (join Xi'))\n      else Xi'\n    ctx' =\n      { key = ctx.key\n      , iv = ctx.iv\n      , Xi = Xi''\n      , len = len'\n      }\n\ncipher_final : AES_GCM_Ctx -> [16][8]\ncipher_final ctx = (split (gcm_pmult_pmod H Xi'')) ^ (EKi ctx 0)\n  where\n    H = join (get_H ctx)\n    Xi' = if (ctx.len % 16) != 0\n      then gcm_pmult_pmod H (join ctx.Xi)\n      else join ctx.Xi\n    Xi'' = Xi' ^ (0 # (ctx.len * 8))\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/AES_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for AES-GCM authenticated encryption using AES as the block cipher and a function gcmEnc, and include properties testPass0\u2013testPass4 that check NIST AES-GCM test vectors for 128- and 256-bit keys, IVs, plaintexts, AAD, and authentication tags."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::AES_GCM where\nimport `Primitive::Symmetric::Cipher::Authenticated::GCM\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\nproperty testPass0 = gcmEnc `{K=128, IV=96, AAD=0, T=128} {E=encrypt} {key=zero, iv=zero, pt=[], aad=[]} ==\n                              {ct = [], tag = 0x58e2fccefa7e3061367f1d57a4e7455a}\n\nproperty testPass1 = gcmEnc `{K=128, IV=96, AAD=0, T=128} {E=encrypt} {key=zero, iv=zero, pt=zero, aad=[]} ==\n                              {ct = 0x0388dace60b6a392f328c2b971b2fe78, tag = 0xab6e47d42cec13bdf53a67b21257bddf}\n\nproperty testPass2 = gcmEnc `{K=128, IV=96, AAD=0, T=128} {E=encrypt} {key=0xfeffe9928665731c6d6a8f9467308308, iv=0xcafebabefacedbaddecaf888,         pt=0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b391aafd255, aad=[]} ==\n    {ct = 0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091473f5985,\n    tag = 0x4d5c2af327cd64a62cf35abd2ba6fab4}\n\nproperty testPass3 = gcmEnc `{K=128, IV=96, AAD=160, T=128} {E=encrypt} {key=0xfeffe9928665731c6d6a8f9467308308,                                            iv=0xcafebabefacedbaddecaf888,\n    pt=0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b39,\n    aad=0xfeedfacedeadbeeffeedfacedeadbeefabaddad2} ==\n    {ct=0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091,\n    tag=0x5bc94fbc3221a5db94fae95ae7121a47}\n\nproperty testPass4 = gcmEnc `{K=256, IV=96, AAD=128, T=128} {E=encrypt} {key=0xeebc1f57487f51921c0465665f8ae6d1658bb26de6f8a069a3520293a572078f,\n    iv=0x99aa3e68ed8173a0eed06684, pt=0xf56e87055bc32d0eeb31b2eacc2bf2a5, aad=0x4d23c3cec334b49bdb370c437fec78de} ==\n   {ct=0xf7264413a84c0e7cd536867eb9f21736, tag=0x67ba0510262ae487d737ee6298f77e0c}\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the AES-GCM authenticated encryption scheme with parameterized key, IV, AAD, and tag sizes, including functions gcmEnc, gcmDec, GHASH, and mult, suitable for verification of encryption\/decryption correctness and tag validation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM where\n\nparameter\n\n  type K : #\n  type constraint (fin K)\n\n  type IV : #\n  type constraint (64 >= width IV, IV >= 1)\n\n  type AAD  : #\n  type constraint (64 >= width AAD)\n\n  type T : #\n  type constraint (128 >= T, T >= 64)\n\n  E : [K] -> [128] -> [128]\n\ngcmEnc :\n  {n} (2^^39 - 256 >= n) =>\n      { key : [K], iv : [IV], aad : [AAD], pt : [n] } -> { ct : [n], tag : [T] }\ngcmEnc input = { ct = C, tag = T }\n  where (C,T) = enc_dec input.key input.iv input.aad input.pt\n\ngcmDec :\n  {n} (2^^39 - 256 >= n) =>\n  { key : [K], iv  : [IV], aad : [AAD], ct  : [n], tag : [T] } ->\n  { valid : Bool, pt : [n] }\ngcmDec input = if input.tag == T then { valid = True, pt = P }\n                                  else { valid = False, pt = 0 }\n  where (P,T) = enc_dec input.key input.iv input.aad input.ct\n\nenc_dec :\n  {n} ((2^^39 - 256) >= n) => [K] -> [IV] -> [AAD] -> [n] -> ([n], [T])\nenc_dec K IV A P = (C,T)\n  where\n  H  = (E K 0)\n\n  Y0 = ifWidth`{96} IV (\\IV96 -> IV96 # 1)\n                       (GHASH H [] IV)\n\n  Ys = [Y0] # [ y+1 | y <- Ys ]\n\n  Cs = [ p ^ (E K y) | p <- blockify P | y <- drop`{1} Ys ]\n  C  = unblockify Cs\n\n  T = take (GHASH H A C ^ (E K Y0))\n\nGHASH : {C,A} (64 >= width C, 64 >= width A) => [128] -> [A] -> [C] -> [128]\nGHASH H A C = step (XS ! 0) (wa # wc)\n  where\n  wa = `A : [64]\n  wc = `C : [64]\n\n  XS = [0] # [ step X' B | X' <- XS | B <- blockify A # blockify C ]\n\n  step x b = mult (x ^ b) H\n\nmult : [128] -> [128] -> [128]\nmult X Y = reverse (pmod (pmult (reverse X) (reverse Y)) irred)\n  where irred = <| 1 + x + x^^2 + x^^7 + x^^128 |>\n\nblockify : {n} (fin n) => [n] -> [n \/^ 128][128]\nblockify msg = split (msg # 0)\n\nunblockify : {n} (fin n) => [n \/^ 128][128] -> [n]\nunblockify ms = take (join ms)\n\nifWidth : {w,n,a} (fin n, fin w) => [n] -> ([w] -> a) -> a -> a\nifWidth thing yep nope = if `w == (`n : [max (width w) (width n)])\n                            then yep (take (thing # (zero : [inf])))\n                            else nope\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/DES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the DES block cipher in Cryptol as a value DES : Cipher 64 64 with encrypt\/decrypt, including key schedule, S-boxes, permutations, and properties DESCorrect and testsPass using the given NIST-style test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::DES where\n\nimport Primitive::Symmetric::Cipher::Block::Cipher\n\nDES : Cipher 64 64\nDES =\n    { encrypt key pt = des (expandKey key) pt\n    , decrypt key ct = des (reverse (expandKey key)) ct\n    }\n\ndes keys pt = (swap (split lst)) @@ FPz\n  where\n        pt' = pt @@ IPz\n        iv  = [ round (k, split lr)\n              | k  <- keys\n              | lr <- [pt'] # iv ]\n        lst = iv @ (length keys - 1)\n\nround : ([48],[2][32]) -> [64]\nround (k, [l, r]) = r # (l ^ f (r, k))\n\nf (r, k) = (SBox(k ^ (r @@ EPz))) @@ PPz\n\nswap [a, b] = b # a\n\nexpandKey : [64] -> [16][48]\nexpandKey key = expand (split (key @@ KPz))\n\nexpand: [2][28] -> [16][48]\nexpand [kl, kr] =\n    [ ((kl <<< i) # (kr <<< i)) @@ CPz\n    | i <- sums [ 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 ] ]\n\nsums : [16][8] -> [16][8]\nsums xs = ys\n  where ys = [ x + y | x <- xs | y <- [0] # ys ]\n\nzeroBasify XP = [ i - 1 | i <- XP ]\nKPz = zeroBasify KP\nCPz = zeroBasify CP\nPPz = zeroBasify PP\nEPz = zeroBasify EP\nIPz = zeroBasify IP\nFPz = zeroBasify FP\n\nKP : [56][6]\nKP  = [57,49,41,33,25,17, 9, 1,58,50,42,34,26,18,\n       10, 2,59,51,43,35,27,19,11, 3,60,52,44,36,\n       63,55,47,39,31,23,15, 7,62,54,46,38,30,22,\n       14, 6,61,53,45,37,29,21,13, 5,28,20,12, 4\n      ]\n\nCP : [48][6]\nCP  = [14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,\n       23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,\n       41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,\n       44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32\n      ]\n\nPP : [32][6]\nPP = [16,  7, 20, 21, 29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,\n       2,  8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25\n     ]\n\nEP : [48][6]\nEP  = [32,  1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,\n        8,  9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,\n       16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,\n       24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,  1\n      ]\n\nIP : [64][7]\nIP = [58, 50, 42, 34, 26, 18, 10,  2, 60, 52, 44, 36, 28, 20, 12,  4,\n      62, 54, 46, 38, 30, 22, 14,  6, 64, 56, 48, 40, 32, 24, 16,  8,\n      57, 49, 41, 33, 25, 17,  9,  1, 59, 51, 43, 35, 27, 19, 11,  3,\n      61, 53, 45, 37, 29, 21, 13,  5, 63, 55, 47, 39, 31, 23, 15,  7\n     ]\n\nFP : [64][7]\nFP = [40,  8, 48, 16, 56, 24, 64, 32, 39,  7, 47, 15, 55, 23, 63, 31,\n      38,  6, 46, 14, 54, 22, 62, 30, 37,  5, 45, 13, 53, 21, 61, 29,\n      36,  4, 44, 12, 52, 20, 60, 28, 35,  3, 43, 11, 51, 19, 59, 27,\n      34,  2, 42, 10, 50, 18, 58, 26, 33,  1, 41,  9, 49, 17, 57, 25\n     ]\n\nSBox : [48] -> [32]\nSBox x = join [ sbox (n, b) | n <- [1 .. 8] | b <- split x ]\n\nsbox : ([4], [6]) -> [4]\nsbox (n, x) = (s @ [b1, b6] @ [b2, b3, b4, b5])\n  where s = sboxes @ (n - 1)\n        b1 = x @ 0\n        b2 = x @ 1\n        b3 = x @ 2\n        b4 = x @ 3\n        b5 = x @ 4\n        b6 = x @ 5\n\nsboxes = [ sbox1, sbox2, sbox3, sbox4, sbox5, sbox6, sbox7, sbox8 ]\n\nsbox1 : [4][16][4]\nsbox1 = [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],\n         [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],\n         [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],\n         [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]\n        ]\nsbox2 : [4][16][4]\nsbox2 = [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],\n         [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],\n         [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],\n         [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]\n        ]\n\nsbox3 : [4][16][4]\nsbox3 = [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],\n         [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],\n         [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],\n         [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]\n        ]\n\nsbox4 : [4][16][4]\nsbox4 = [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],\n         [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],\n         [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],\n         [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]\n        ]\n\nsbox5 : [4][16][4]\nsbox5 = [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],\n         [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],\n         [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],\n         [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]\n        ]\n\nsbox6 : [4][16][4]\nsbox6 = [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],\n         [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],\n         [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],\n         [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]\n        ]\n\nsbox7 : [4][16][4]\nsbox7 = [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],\n         [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],\n         [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],\n         [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]\n        ]\n\nsbox8 : [4][16][4]\nsbox8 = [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],\n         [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],\n         [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],\n         [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]\n        ]\n\nproperty DESCorrect key msg = DES.decrypt key (DES.encrypt key msg) == msg\n\ntestmsgs = [0x1122334455667788\n           ,0x99aabbccddeeff00\n           ,0x41AD068548809D02\n           ,0xB10F843097A0F932]\n\ntestkeys = [0x752878397493CB70\n          ,0x752878397493CB70\n          ,0x0001020304050607\n          ,0x2BD6459F82C5B300]\n\ntestct = [0xB5219EE81AA7499D\n         ,0x2196687E13973856\n         ,0x0011223344556677\n         ,0xEA024714AD5C4D84]\n\nproperty testsPass = and [ DES.encrypt key msg == ct\n                         | key <- testkeys | msg <- testmsgs | ct <- testct ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/PRINCE.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module implementing the PRINCE 64-bit block cipher with 128-bit key, including princeEncrypt, princeDecrypt, their 64-bit-key variants, and properties princeCorrect, princeCorrect', and testsPass that verify encryption\/decryption correctness and standard test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::PRINCE where\ntype princeBlockSize = 64\ntype princeKeySize = 128\ntype State = [4][4][4]\ntype Round = 4\n\nsbox = [0xb, 0xf, 0x3, 0x2, 0xa, 0xc, 0x9, 0x1, 0x6, 0x7, 0x8, 0x0, 0xe, 0x5, 0xd, 0x4]\nsboxInv = [0xb, 0x7, 0x3, 0x2, 0xf, 0xd, 0x8, 0x9, 0xa, 0x6, 0x4, 0x0, 0x5, 0xe, 0xc, 0x1]\n\nRC = [0x0000000000000000, 0x13198a2e03707344, 0xa4093822299f31d0, 0x082efa98ec4e6c89, 0x452821e638d01377, 0xbe5466cf34e90c6c, 0x7ef84f78fd955cb1, 0x85840851f1ac43aa, 0xc882d32f25323c54, 0x64a51195e0e3610d, 0xd3b5a399ca0c2399, 0xc0ac29b7c97c50dd]\n\nextendKey :[princeKeySize] -> ([64], [64], [64])\nextendKey key = (K!0, K', K!1) \n          where K = split key:[2][64]\n                K' = ((K!0) >>> 1) ^ ((K!0) >> 63)\n\nmsgToState:[princeBlockSize] -> State\nmsgToState msg = split (split msg)\n\nstateToMsg :State -> [princeBlockSize]\nstateToMsg st = join (join st)\n\nSubCell :[4] -> [4]\nSubCell st = sbox@st\n\nSubCells : State -> State\nSubCells st = [ [ SubCell b | b<- row ] | row <- st ]\n\nInvSubCell :[4] -> [4]\nInvSubCell st = sboxInv@st\n\nInvSubCells : State -> State\nInvSubCells st = [ [ InvSubCell b | b<- row ] | row <- st ]\n\nperm  = [0x0, 0x5, 0xa, 0xf, 0x4, 0x9, 0xe, 0x3, 0x8, 0xd, 0x2, 0x7, 0xc, 0x1, 0x6, 0xb]\ninv_perm = [0x0, 0xd, 0xa, 0x7, 0x4, 0x1, 0xe, 0xb, 0x8, 0x5, 0x2, 0xf, 0xc,0x9, 0x6, 0x3]\n\nShiftRows : State -> State\nShiftRows state = split [State_16@i\n                  | i <-  perm]\n                where State_16 = join state\nInvShiftRows : State -> State\nInvShiftRows state = split [State_16@i\n                  | i <-  inv_perm]\n                where State_16 = join state\n\nm0 = [ 0x0, 0x4, 0x2, 0x1]\nm1 = [ 0x8, 0x0, 0x2, 0x1]\nm2 = [ 0x8, 0x4, 0x0, 0x1]\nm3 = [ 0x8, 0x4, 0x2, 0x0]\n\nM0 = [ [m0, m1, m2, m3], [m1, m2, m3, m0], [m2, m3, m0, m1], [m3, m0, m1, m2] ]\nM1 = [ [m1, m2, m3, m0], [m2, m3, m0, m1], [m3, m0, m1, m2], [m0, m1, m2, m3] ]\n\nM' = [ M0, M1, M1, M0]\n\n\/\/ m0\n\ndefm1 : [16] -> [16]\ndefm1 st = res \n where  res = b15 # b14 # b13 # b12 # b11 # b10 # b9 # b8 # b7 # b6 # b5 # b4 # b3 # b2 # b1 # b0\n        b0 = [st!4 ^ st!8 ^ st!12]\n        b1 = [st!1 ^ st!9 ^ st!13]\n        b2 = [st!2 ^ st!6 ^ st!14]\n        b3 = [st!3 ^ st!7 ^ st!11]\n        b4 = [st!0 ^ st!4 ^ st!8]\n        b5 = [st!5 ^ st!9 ^ st!13]\n        b6 = [st!2 ^ st!10 ^ st!14]\n        b7 = [st!3 ^ st!7 ^ st!15]\n        b8 = [st!0 ^ st!4 ^ st!12]\n        b9 = [st!1 ^ st!5 ^ st!9]\n        b10 = [st!6 ^ st!10 ^ st!14]\n        b11 = [st!3 ^ st!11 ^ st!15]\n        b12 = [st!0 ^ st!8 ^ st!12]\n        b13 = [st!1 ^ st!5 ^ st!13]\n        b14 = [st!2 ^ st!6 ^ st!10]\n        b15 = [st!7 ^ st!11 ^ st!15]\n\n\/\/ m1\n\ndefm0 : [16] -> [16]\ndefm0 st = res\n  where res = b15 # b14 # b13 # b12 # b11 # b10 # b9 # b8 # b7 # b6 # b5 # b4 # b3 # b2 # b1 # b0\n        b0 = [st!0 ^ st!4 ^ st!8]\n        b1 = [st!5 ^ st!9 ^ st!13]\n        b2 = [st!2 ^ st!10 ^ st!14]\n        b3 = [st!3 ^ st!7 ^ st!15]\n        b4 = [st!0 ^ st!4 ^ st!12]\n        b5 = [st!1 ^ st!5 ^ st!9]\n        b6 = [st!6 ^ st!10 ^ st!14]\n        b7 = [st!3 ^ st!11 ^ st!15]\n        b8 = [st!0 ^ st!8 ^ st!12]\n        b9 = [st!1 ^ st!5 ^ st!13]\n        b10 = [st!2 ^ st!6 ^ st!10]\n        b11 = [st!7 ^ st!11 ^ st!15]\n        b12 = [st!4 ^ st!8 ^ st!12]\n        b13 = [st!1 ^ st!9 ^ st!13]\n        b14 = [st!2 ^ st!6 ^ st!14]\n        b15 = [st!3 ^ st!7 ^ st!11]\n\n\/\/ M'\n\ndefMPrime: State -> State\ndefMPrime st = [rt3] # [rt2] # [rt1] # [rt0]\n      where rt0 = split (defm0 (join (st!0))):[4][4]\n            rt1 = split (defm1 (join (st!1))):[4][4]\n            rt2 = split (defm1 (join (st!2))):[4][4]\n            rt3 = split (defm0 (join (st!3))):[4][4]\n\nfirstRounds : State -> State -> [Round] -> State\nfirstRounds pt key r = res\n           where   pt' =  SubCells(pt)\n                   pt'' = defMPrime (pt')\n                   pt''' = ShiftRows (pt'')\n                   res = pt''' ^ (split (split (RC@r))) ^ key\n\nlastRounds : State -> State -> [Round] -> State\nlastRounds pt key r = res\n           where   pt' =  pt ^ key ^ (split (split (RC@r)))\n                   pt'' = InvShiftRows( pt')\n                   pt''' = defMPrime (pt'')\n                   res = InvSubCells (pt''')\n\nprinceCore : State -> State -> State\nprinceCore pt key  = addRC11\n           where addRC0 = pt ^ key ^ (split (split (RC@0)))\n                 firstR = [(firstRounds addRC0 key 1)] # [ (firstRounds res key i)\n                                                         | i <- [2,3..5]\n                                                         | res <- firstR\n                                                         ]\n                 subSbox = SubCells (firstR!0)\n                 linLayer = defMPrime (subSbox)\n                 subInvSbox = InvSubCells (linLayer)\n                 lastR = [(lastRounds subInvSbox  key 6) ] # [ (lastRounds res key i)\n                                                             | i <- [7,8..10]\n                                                             | res <- lastR\n                                                             ]\n                 addRC11 = (lastR!0) ^ key^ (split (split (RC@11)))\n\nprinceEncrypt : ([princeKeySize], [princeBlockSize]) -> [princeBlockSize]\nprinceEncrypt (key, pt) =  stateToMsg postWhiten\n            where  extk = extendKey (key)\n                   preWhiten = msgToState(pt) ^ msgToState (extk.0)\n                   coreEnc =  (princeCore preWhiten (msgToState (extk.2)))\n                   postWhiten = coreEnc ^ (msgToState (extk.1))\n\nextendKeyDec :[princeKeySize] -> ([64], [64], [64])\nextendKeyDec key = (K', K!0, K!1) \n          where K = split key:[2][64]\n                K' = ((K!0) >>> 1) ^ ((K!0) >> 63)\n\nprinceDecrypt : ([princeKeySize], [princeBlockSize]) -> [princeBlockSize]\nprinceDecrypt ( key, ct) = stateToMsg postWhiten\n            where alpha_padd = join((split(key):[32][4])^ (split (0xc0ac29b7c97c50dd0000000000000000):[32][4]))\n                  extk = extendKeyDec alpha_padd \n                  preWhiten = msgToState(ct) ^ msgToState (extk.0)\n                  coreEnc =  (princeCore preWhiten (msgToState (extk.2)))\n                  postWhiten = coreEnc ^ (msgToState (extk.1))\n\nproperty princeCorrect key m = princeDecrypt ( key, princeEncrypt(key, m)) == m\n\nprinceEncrypt64 : ([princeBlockSize], [princeBlockSize]) -> [princeBlockSize]\nprinceEncrypt64 (key, pt) = princeEncrypt(key#zero, pt)\n\nprinceDecrypt64 : ([princeBlockSize], [princeBlockSize]) -> [princeBlockSize]\nprinceDecrypt64 (key, ct) = princeDecrypt(key#zero, ct)\n\nproperty princeCorrect' key m = princeDecrypt64 (key, princeEncrypt64 (key, m)) == m\n\nprinceEncrypt128 : ([princeKeySize], [princeKeySize]) -> [princeKeySize]\nprinceEncrypt128 (key, pt) = princeEncrypt(key, (take`{64} pt))# zero\n\n\/\/ Testing\n\ntests = [t01, t02, t03, t04, t05, t06, t07]\nproperty testsPass = and tests\n\nt01 = princeEncrypt (zero, zero) == 0x818665aa0d02dfda\n\nt02 = princeEncrypt (zero, 0xffffffffffffffff) == 0x604ae6ca03c20ada\n\nt03 = princeEncrypt ( 0xffffffffffffffff0000000000000000, zero) == 0x78a54cbe737bb7ef\n\nt04 = princeEncrypt (0xffffffffffffffffffffffffffffffff, zero) == 0xb9f952807615743f\n\nt05 = princeEncrypt (0x0000000000000000ffffffffffffffff, zero) == 0x9fb51935fc3df524\n\nt06 = princeEncrypt (0x0000000000000000fedcba9876543210, 0x0123456789abcdef) == 0x1f24bb8638e813d3\n\nt07 = princeEncrypt (0xfedcba98765432100000000000000000, 0x0123456789abcdef) == 0xae25ad3ca8fa9ccf\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES_parameterized.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification module `Primitive::Symmetric::Cipher::Block::AES_parameterized` that defines parameterized AES key expansion, encryption, decryption, and the property `test k pt = decrypt k (encrypt k pt) == pt` for valid AES key sizes, using `EncryptKey`, `DecryptKey`, and AES round parameters."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES_parameterized where\n\nimport `Primitive::Symmetric::Cipher::Block::AES::Algorithm as AES\nimport `Primitive::Symmetric::Cipher::Block::AES::ExpandKey\nimport Primitive::Symmetric::Cipher::Block::AES::TBox\n\ntype constraint ValidKey k m = (k == 128 + m * 64, 2 >= m)\n\ntype EncKey m = AES::KeySchedule m\ntype DecKey m = AES::KeySchedule m\n\nencrypt : {k,m} ValidKey k m => [k] -> [128] -> [128]\nencrypt k = encryptWithSchedule (expandKeyEnc k)\n\ndecrypt : {k,m} ValidKey k m => [k] -> [128] -> [128]\ndecrypt k = decryptWithSchedule (expandKeyDec k)\n\nexpandKeyEnc : {k,m} ValidKey k m => [k] -> EncKey m\nexpandKeyEnc = expandKey`{Nk = AES::Nk m, Nr = AES::Nr m}\n\nencryptWithSchedule : {k,m} ValidKey k m => EncKey m -> [128] -> [128]\nencryptWithSchedule = AES::encrypt params\n\nexpandKeyDec : {k,m} ValidKey k m => [k] -> EncKey m\nexpandKeyDec k = makeDecKey (expandKey`{Nk = AES::Nk m, Nr = AES::Nr m} k)\n\ndecryptWithSchedule : {k,m} ValidKey k m => DecKey m -> [128] -> [128]\ndecryptWithSchedule = AES::decrypt params\n\nparams = { encRound = AESRound, decRound = AESInvRound }\n\nproperty test k pt = decrypt k (encrypt k pt) == pt\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AESKeyWrapPadded.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the AES Key Wrap with Padding algorithm (AES-KW-P) including the functions `aesWrapKeyPadded` and `aesUnwrapKeyPadded`, and properties that verify correct padding, size handling, and successful unwrap (valid flag, IV, and recovered plaintext) for all valid inputs."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AESKeyWrapPadded where\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Block::AESKeyWrap\n\nAlternativeIV : [4][8]\nAlternativeIV = [0xA6, 0x59, 0x59, 0xA6]\n\npadPlaintext : {n, m} (fin n, (n+m) % 8 == 0, m <= 7) => [n][8] -> [n + m][8]\npadPlaintext p = p # zero\n\naesWrapKeyPadded : {n, m} (n >= 1 , n < 2^^32 , (n+m) % 8 == 0 , m <= 7) =>\n                   [AESKeySize] -> [4][8] -> [n][8] -> [n+m+8][8]\naesWrapKeyPadded key iv plaintext =\n  if `n <= 8\n        then (split (aesEncrypt (drop (join (AIV # P)), key))) # zero\n          else drop (aesWrapKey key AIV ((P # zero) : [max 16 (n+m)][8]))\n  where\n        P = padPlaintext`{n, m} plaintext\n        AIV = iv # (split`{4,8} (`n : [32]))\n\naesUnwrapKeyPadded : {n} (fin n, n >= 16, n % 8 == 0, width n <= 32) =>\n                     [AESKeySize] -> [4][8] -> [n][8] -> (Bit, [4][8], [n-8][8])\naesUnwrapKeyPadded key iv ciphertext = if valid\n                                       then (True, size, P)\n                                       else (False, zero, zero)\n  where\n    S : [n][8]\n    S = if `n == 16\n                                        then (split (aesDecrypt (drop (join ciphertext), key))) # zero\n                                        else drop (split`{each=8} (join (([A'] # R'))))\n          where\n            (A', R') = aesUnwrapKeyUnchecked key ((ciphertext # zero) : [max 24 n][8])\n                iv' : [4][8]\n    size : [4][8]\n    P : [n-8][8]\n    iv' # size # P = S\n        valid =\n            (iv' == iv) &&\n      \/\/ n - 16 < size <= n - 8\n      (((`n : [32]) - 16) < (join size)) &&\n      ((join size) <= ((`n : [32]) - 8)) &&\n      \/\/ All bytes of the padding must be zeros\n      and [(i < (join size)) || (x == zero) | x <- P | i <- [0...]]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/LED.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the LED block cipher, including ledEncrypt64 and ledEncrypt128 encryption functions, the supporting GF(2^4) arithmetic and round transformations, and properties testsPass, test64_1, test64_2, test128_1, and test128_2 that check the given test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::LED where\n\ntype GF24 = [4]\ntype State = [4][4]GF24\n\ntype LEDKeySize64 = 64\ntype LEDKeySize128 = 128\ntype LEDBlockSize = 64\ntype Rn = [6]\ntype steps = 8 \ntype Nr = steps*4\n\ntype Ns = 8\n\ngf24Add : {n} (fin n) => [n]GF24 -> GF24\ngf24Add ps = sums ! 0\n      where sums = [zero] # [p^s | p <- ps | s <- sums]\nirreducible = <| x^^4 + x + 1 |>\n\ngf24Mult : (GF24, GF24) -> GF24\ngf24Mult (x , y) = pmod (pmult x y) irreducible\n\ngf24Pow : (GF24, [4]) -> GF24\ngf24Pow (n , k) = pow k\n        where sq x = gf24Mult (x, x)\n              odd x = x ! 0\n              pow i = if i == 0 then 1\n                      else if odd i\n                           then gf24Mult(n, sq (pow (i >> 1)))\n                           else sq (pow (i >> 1))\n\npolySelfAdd' : GF24 -> Bit\nproperty polySelfAdd' x = x ^ x == zero\n\ngf24Inverse : GF24 -> GF24\ngf24Inverse x = gf24Pow (x, 14)\n\ngf24DotProduct : {n} (fin n) => ([n]GF24, [n]GF24) -> GF24\ngf24DotProduct  (xs, ys) = gf24Add [ gf24Mult (x, y) | x <- xs\n                                                     | y <- ys ]\n\ngf24VectorMult : {n, m} (fin n) => ([n]GF24, [m][n]GF24) -> [m]GF24\ngf24VectorMult (v, ms) = [ gf24DotProduct(v, m) | m <- ms ]\n\ngf24MatrixMult : {n, m, k} (fin m) => ([n][m]GF24, [m][k]GF24) -> [n][k]GF24\ngf24MatrixMult (xss, yss) = [ gf24VectorMult(xs, yss') | xs <- xss ]\n   where yss' = transpose yss\n\nsbox : [16] GF24\n\nsbox = [0xc, 0x5, 0x6, 0xb, 0x9, 0x0, 0xa, 0xd, 0x3, 0xe, 0xf, 0x8, 0x4, 0x7, 0x1, 0x2]\n\nmsgToState : [64] -> State\nmsgToState msg = split (split msg)\n\nstateToMsg : State -> [64]\nstateToMsg st = join (join st)\n\nsplitKey1 : [128] -> State\nsplitKey1  key =  msgToState(seed@0)\n          where seed : [2][64]\n                seed = split(key)\n\nsplitKey2 : [128] -> State\nsplitKey2  key =  msgToState(seed@1)\n          where seed : [2][64]\n                seed = split(key)\n\nAddRoundKey: (State, State) -> State\nAddRoundKey (rk , s) = rk^s\n\nrcTab : [48][8]\nrcTab = [0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3E, \n                    0x3D, 0x3B, 0x37, 0x2F, 0x1E, 0x3C, 0x39,\n                    0x33, 0x27, 0x0E, 0x1D, 0x3A, 0x35, 0x2B,\n                    0x16, 0x2C, 0x18, 0x30, 0x21, 0x02, 0x05,\n                    0x0B, 0x17, 0x2E, 0x1C, 0x38, 0x31, 0x23,\n                    0x06, 0x0D, 0x1B, 0x36, 0x2D, 0x1A, 0x34,\n                    0x29, 0x12, 0x24, 0x08, 0x11, 0x22, 0x04]\n\naddConst64 : Rn -> State\naddConst128 : Rn -> State\n\naddConst128 rn  = [[ 8, rcpad(rcTab, rn, [5, 4, 3]) , 0, 0], [9, rcpad(rcTab, rn, [2, 1, 0]) , 0, 0], [2, rcpad(rcTab, rn, [5, 4, 3]), 0, 0], [3, rcpad(rcTab, rn, [2, 1, 0]), 0, 0]] \n\naddConst64 rn  =[[ 4, rcpad(rcTab, rn, [5, 4, 3]) , 0, 0], [5, rcpad(rcTab, rn, [2, 1, 0]) , 0, 0], [2, rcpad(rcTab, rn, [5, 4, 3]), 0, 0], [3, rcpad(rcTab, rn, [2, 1, 0]), 0, 0]] \n\nrcpad : ([48][8], Rn, [3][3]) -> GF24\nrcpad (rct, rn, indcs) = (0b0 # ((rct @ rn):[8]) !! indcs)\n\nAddConst64 : (Rn, State) -> State\nAddConst64 (rn, st) = st ^ (addConst64 rn)\n\nAddConst128 : (Rn, State) -> State\nAddConst128 (rn, st) = st ^ (addConst128 rn)\n\nSubCell : GF24 -> GF24\nSubCell b = sbox @ b\n\nSubCells : State -> State\nSubCells state = [ [SubCell b | b <- row] | row <- state]\n\nShiftRows : State -> State\nShiftRows state = [ row <<< shiftAmount | row <- state\n                                        | shiftAmount <- [0..3]\n                  ]\n\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> shiftAmount | row <- state\n                                           | shiftAmount <- [0 .. 3]\n                     ]\nMDS : State\n\nMDS = [ [ 0x4, 0x1, 0x2, 0x2],\n            [ 0x8, 0x6, 0x5, 0x6],\n            [ 0xB, 0xE, 0xA, 0x9],\n            [ 0x2, 0x2, 0xF, 0xB] ]\n\nMixColumns : State -> State\nMixColumns state = transpose [gf24VectorMult (row, MDS)| row <- state']\n           where state' = transpose state\n\nroundXform64 : (Rn, State) -> State\nroundXform64 (rn, st) = MixColumns (ShiftRows( SubCells (AddConst64 (rn, st))))\n\nfourRoundXform64 : ([6], State) -> State\nfourRoundXform64 (stp, st) = roundXform64 ((4*stp+3), (roundXform64 ((4*stp+2), (roundXform64 ((4*stp+1), (roundXform64 ((4*stp+0), st)))))))\n\nroundXform128 : (Rn, State) -> State\nroundXform128 (rn, st) = MixColumns (ShiftRows( SubCells (AddConst128 (rn, st))))\n\nfourRoundXform128 : ([6], State) -> State\nfourRoundXform128 (stp, st) = roundXform128 ((4*stp+3), (roundXform128 ((4*stp+2), (roundXform128 ((4*stp+1), (roundXform128 ((4*stp+0), st)))))))\n\nledEncrypt64 : ([LEDKeySize64], [LEDBlockSize])  -> [LEDBlockSize]\nledEncrypt64 (key, pt) = stateToMsg(addrk8)\n              where pt_st = msgToState(pt)\n                    key_st1 =  msgToState(key)\n                    key_st2 = msgToState(key)\n                    addrk0 = (AddRoundKey(pt_st, key_st1))\n                    step0 = (fourRoundXform64 (0, addrk0))        \n                    addrk1 = (AddRoundKey(step0, key_st2))\n                    step1 = (fourRoundXform64 (1, addrk1))\n                    addrk2 = (AddRoundKey(step1, key_st1))\n                    step2 = (fourRoundXform64 (2, addrk2))\n                    addrk3 = (AddRoundKey(step2, key_st2))\n                    step3 = (fourRoundXform64 (3, addrk3))\n                    addrk4 = (AddRoundKey(step3, key_st1))\n                    step4 = (fourRoundXform64 (4, addrk4))\n                    addrk5 = (AddRoundKey(step4, key_st2))\n                    step5 = (fourRoundXform64 (5, addrk5))\n                    addrk6 = (AddRoundKey(step5, key_st1))\n                    step6 = (fourRoundXform64 (6, addrk6))\n                    addrk7 = (AddRoundKey(step6, key_st2))\n                    step7 = (fourRoundXform64 (7, addrk7))\n                    addrk8 = (AddRoundKey(step7, key_st1))\n\nledEncrypt128 : ([LEDKeySize128], [LEDBlockSize])  -> [LEDBlockSize]\nledEncrypt128 ( key, pt) = stateToMsg(addrk12)\n              where pt_st = msgToState(pt)\n\n                    key_st1 = splitKey1(key)\n                    key_st2 = splitKey2(key)\n                    addrk0 = (AddRoundKey(pt_st, key_st1))\n                    step0 = (fourRoundXform128 (0, addrk0))        \n                    addrk1 = (AddRoundKey(step0, key_st2))\n                    step1 = (fourRoundXform128 (1, addrk1))\n                    addrk2 = (AddRoundKey(step1, key_st1))\n                    step2 = (fourRoundXform128 (2, addrk2))\n                    addrk3 = (AddRoundKey(step2, key_st2))\n                    step3 = (fourRoundXform128 (3, addrk3))\n                    addrk4 = (AddRoundKey(step3, key_st1))\n                    step4 = (fourRoundXform128 (4, addrk4))\n                    addrk5 = (AddRoundKey(step4, key_st2))\n                    step5 = (fourRoundXform128 (5, addrk5))\n                    addrk6 = (AddRoundKey(step5, key_st1))\n                    step6 = (fourRoundXform128 (6, addrk6))\n                    addrk7 = (AddRoundKey(step6, key_st2))\n                    step7 = (fourRoundXform128 (7, addrk7))\n                    addrk8 = (AddRoundKey(step7, key_st1))\n                    step8 = (fourRoundXform128 (8, addrk8))\n                    addrk9 = (AddRoundKey(step8, key_st2))\n                    step9 = (fourRoundXform128 (9, addrk9))\n                    addrk10 = (AddRoundKey(step9, key_st1))\n                    step10 = (fourRoundXform128 (10, addrk10))\n                    addrk11 = (AddRoundKey(step10, key_st2))\n                    step11 = (fourRoundXform128 (11, addrk11))\n                    addrk12 = (AddRoundKey(step11, key_st1))\n\nledEncrypt64' : ([LEDBlockSize], [LEDBlockSize]) -> [LEDBlockSize]\nledEncrypt64' (key, pt) = ledEncrypt128 (key#zero, pt)\n\nledEncrypt128' : ([LEDKeySize128], [LEDKeySize128]) -> [LEDKeySize128]\nledEncrypt128' (key, pt) = ledEncrypt128(key, (take`{64} pt))# zero\n\ntests = [test64_1, test64_2, test128_1, test128_2]\nproperty testsPass = and tests\n\nproperty test64_1  = ledEncrypt64 (zero, zero) == 0x39c2401003a0c798\nproperty test64_2 = ledEncrypt64 (0x0123456789abcdef, 0x0123456789abcdef) == 0xa003551e3893fc58\n\nproperty test128_1 = ledEncrypt128 (zero, zero) == 0x3decb2a0850cdba1\nproperty test128_2 = ledEncrypt128 (0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0xd6b824587f014fc2\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/simon.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that fully specifies the SIMON block cipher family (encrypt, decrypt, key expansion, constants Z) and includes properties proving decrypt \u2218 encrypt = id and key expansion uniqueness for standard parameter sets, plus test vectors as properties."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::simon where\n\nSimon32_64    = encrypt `{n=16,m=4,T=32,j=0}\nSimon48_72    = encrypt `{n=24,m=3,T=36,j=0}\nSimon48_96    = encrypt `{n=24,m=4,T=36,j=1}\nSimon64_96    = encrypt `{n=32,m=3,T=42,j=2}\nSimon64_128   = encrypt `{n=32,m=4,T=44,j=3}\nSimon96_96    = encrypt `{n=48,m=2,T=52,j=2}\nSimon96_144   = encrypt `{n=48,m=3,T=54,j=3}\nSimon128_128  = encrypt `{n=64,m=2,T=68,j=2}\nSimon128_192  = encrypt `{n=64,m=3,T=69,j=3}\nSimon128_256  = encrypt `{n=64,m=4,T=72,j=4}\n\nSimon32_64'   = decrypt `{n=16,m=4,T=32,j=0}\nSimon48_72'   = decrypt `{n=24,m=3,T=36,j=0}\nSimon48_96'   = decrypt `{n=24,m=4,T=36,j=1}\nSimon64_96'   = decrypt `{n=32,m=3,T=42,j=2}\nSimon64_128'  = decrypt `{n=32,m=4,T=44,j=3}\nSimon96_96'   = decrypt `{n=48,m=2,T=52,j=2}\nSimon96_144'  = decrypt `{n=48,m=3,T=54,j=3}\nSimon128_128' = decrypt `{n=64,m=2,T=68,j=2}\nSimon128_192' = decrypt `{n=64,m=3,T=69,j=3}\nSimon128_256' = decrypt `{n=64,m=4,T=72,j=4}\n\nproperty correctSimon32_64 k b   = Simon32_64' k (Simon32_64 k b) == b\nproperty correctSimon64_96 k b   = Simon64_96' k (Simon64_96 k b) == b\nproperty correctSimon96_144 k b  = Simon96_144' k (Simon96_144 k b) == b\nproperty correctSimon128_128 k b = Simon128_128' k (Simon128_128 k b) == b\nproperty correctSimon128_256 k b = Simon128_256' k (Simon128_256 k b) == b\n\nproperty uniqueExpandSimon32_64 k1 k2 = (k1 == k2) || (expandKey `{n=16,m=4,T=32,j=0} k1 != expandKey `{n=16,m=4,T=32,j=0} k2)\nproperty uniqueExpandSimon48_72 k1 k2 = (k1 == k2) || (expandKey `{n=24,m=3,T=36,j=0} k1 != expandKey `{n=24,m=3,T=36,j=0} k2)\nproperty uniqueExpandSimon48_96 k1 k2 = (k1 == k2) || (expandKey `{n=24,m=4,T=36,j=1} k1 != expandKey `{n=24,m=4,T=36,j=1} k2)\nproperty uniqueExpandSimon64_96 k1 k2 = (k1 == k2) || (expandKey `{n=32,m=3,T=42,j=2} k1 != expandKey `{n=32,m=3,T=42,j=2} k2)\nproperty uniqueExpandSimon64_128 k1 k2 = (k1 == k2) || (expandKey `{n=32,m=4,T=44,j=3} k1 != expandKey `{n=32,m=4,T=44,j=3} k2)\nproperty uniqueExpandSimon96_96 k1 k2 = (k1 == k2) || (expandKey `{n=48,m=2,T=52,j=2} k1 != expandKey `{n=48,m=2,T=52,j=2} k2)\nproperty uniqueExpandSimon96_144 k1 k2 = (k1 == k2) || (expandKey `{n=48,m=3,T=54,j=3} k1 != expandKey `{n=48,m=3,T=54,j=3} k2)\nproperty uniqueExpandSimon128_128 k1 k2 = (k1 == k2) || (expandKey `{n=64,m=2,T=68,j=2} k1 != expandKey `{n=64,m=2,T=68,j=2} k2)\nproperty uniqueExpandSimon128_192 k1 k2 = (k1 == k2) || (expandKey `{n=64,m=3,T=69,j=3} k1 != expandKey `{n=64,m=3,T=69,j=3} k2)\nproperty uniqueExpandSimon128_256 k1 k2 = (k1 == k2) || (expandKey `{n=64,m=4,T=72,j=4} k1 != expandKey `{n=64,m=4,T=72,j=4} k2)\n\n\/\/ A weak key theorem would look something like:\n\/\/ :prove exists (\\k1 -> exists (\\k2 -> forall (\\x -> Simon32_64 k1 (Simon32_64 k2 x) != x)))\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ round function\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nR k (x, y) = (y ^ f x ^ k, x)\n\n\/\/ inverse\nR' k (x, y) = (y, x ^ f y ^ k)\n\nf x = ((x <<< 1) && (x <<< 8)) ^ (x <<< 2)\n\nencrypt : {n, m, T, j}\n    ( fin n, fin m, fin T, fin j\n    , n >= 2, 4 >= m, T >= 4, T-1 >= m\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\nencrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [ R k b | b <- bs | k <- ks ]\n    ks = expandKey `{n=n,m=m,T=T,j=j} (reverse k0)\n\ndecrypt : {n, m, T, j}\n    ( fin n, fin m, fin T, fin j\n    , n >= 2, 4 >= m, T >= 4, T-1 >= m\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\ndecrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [ R' k b | b <- bs | k <- reverse ks ]\n    ks = expandKey `{n=n,m=m,T=T,j=j} (reverse k0)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ key expansion\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nexpandKey : {n, m, T, j}\n    ( fin n, fin m, fin T, fin j\n    , n >= 2, 4 >= m, T >= 4, T-1 >= m\n    ) => [m][n] -> [T][n]\nexpandKey k0 = k\n  where\n    k = k0 # [ r where\n                    o = k @ (i - 1) >>> 3\n                    p = if `m == 4 then o ^ k @ (i - 3) else o\n                    q = p ^ p >>> 1\n                    r = ~ k @ (i - `m) ^ q ^ z ^ 3\n                    z = Z @ `j @ ((i - `m) % 62)\n             | i <- [m .. T - 1]\n             ]\n\n\/\/ TODO specify how Z is constructed\nZ = [[1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0,\n      0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1,\n      0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0],\n     [1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0,\n      0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1,\n      0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0],\n     [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,\n      0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1,\n      1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1],\n     [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1,\n      0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0,\n      0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1],\n     [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1,\n      1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1,\n      0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1]]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ tests\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\ntests = [t01,t02,t03,t04,t05,t06,t07,t08,t09]\nproperty testsPass = and tests\n\nt00 = Simon32_64   [0x1918, 0x1110, 0x0908, 0x0100] (0x6565, 0x6877) == (0xc69b, 0xe9bb)\nt01 = Simon48_72   [0x121110, 0x0a0908, 0x020100] (0x612067, 0x6e696c) == (0xdae5ac, 0x292cac)\nt02 = Simon48_96   [0x1a1918, 0x121110, 0x0a0908, 0x020100] (0x726963, 0x20646e) == (0x6e06a5, 0xacf156)\nt03 = Simon64_96   [0x13121110, 0x0b0a0908, 0x03020100] (0x6f722067, 0x6e696c63) == (0x5ca2e27f, 0x111a8fc8)\nt04 = Simon64_128  [0x1b1a1918, 0x13121110, 0x0b0a0908, 0x03020100] (0x656b696c, 0x20646e75) == (0x44c8fc20, 0xb9dfa07a)\nt05 = Simon96_96   [0x0d0c0b0a0908, 0x050403020100] (0x2072616c6c69, 0x702065687420) == (0x602807a462b4, 0x69063d8ff082)\nt06 = Simon96_144  [0x151413121110, 0x0d0c0b0a0908, 0x050403020100] (0x746168742074, 0x73756420666f) == (0xecad1c6c451e, 0x3f59c5db1ae9)\nt07 = Simon128_128 [0x0f0e0d0c0b0a0908, 0x0706050403020100] (0x6373656420737265, 0x6c6c657661727420) == (0x49681b1e1e54fe3f, 0x65aa832af84e0bbc)\nt08 = Simon128_192 [0x1716151413121110, 0x0f0e0d0c0b0a0908, 0x0706050403020100] (0x206572656874206e, 0x6568772065626972) == (0xc4ac61effcdc0d4f, 0x6c9c8d6e2597b85b)\nt09 = Simon128_256 [0x1f1e1d1c1b1a1918, 0x1716151413121110, 0x0f0e0d0c0b0a0908, 0x0706050403020100] (0x74206e69206d6f6f, 0x6d69732061207369) == (0x8d2b5579afc8a3a0, 0x3bf72a87efe7b868)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AESKeyWrap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the AES Key Wrap algorithm (RFC 3394), including functions aesWrapKey, aesUnwrapKey, aesUnwrapKeyUnchecked, DefaultIV, and internal wrap\/unwrap round and block helpers, with appropriate polymorphic size constraints and AESKeySize-based encryption\/decryption calls."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AESKeyWrap where\nimport Primitive::Symmetric::Cipher::Block::AES\n\nDefaultIV : [8][8]\nDefaultIV = [0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6]\n\naesWrapKey : {n} (fin n, n >= 16, n % 8 == 0, width (n \/ 8) <= 64) =>\n             [AESKeySize] -> [8][8] -> [n][8] -> [n+8][8]\naesWrapKey key iv plaintext = split (join C)\n  where\n        A = join iv\n    R = split`{parts=n\/8, each=64} (join plaintext)\n        intermediates = [(A, R)] # [wrapRound key s j | s <- intermediates\n                                                  | j <- [0..5]]\n        (A', R') = intermediates ! 0\n    C = [A'] # R'\n\naesUnwrapKey : {n} (fin n, n >= 24, n % 8 == 0, width (n \/ 8) <= 64) =>\n               [AESKeySize] -> [8][8] -> [n][8] -> (Bit, [n-8][8])\naesUnwrapKey key iv ciphertext = if (join iv) == A'\n                                 then (True, split (join R'))\n                                 else (False, zero)\n  where\n    (A', R') = aesUnwrapKeyUnchecked key ciphertext\n\naesUnwrapKeyUnchecked : {n} (fin n, n >= 24, n % 8 == 0, width (n \/ 8) <= 64) =>\n                        [AESKeySize] -> [n][8] -> ([64], [n\/8 - 1][64])\naesUnwrapKeyUnchecked key ciphertext = intermediates ! 0\n  where\n        A = join (take`{8} ciphertext)\n    R = split`{parts=(n-8)\/8, each=64} (join (drop`{8} ciphertext))\n        intermediates = [(A, R)] # [unwrapRound key s j | s <- intermediates\n                                                    | j <- [5, 4 .. 0]]\n\nprivate\n\n    wrapBlock : {n} (fin n, width n <= 64) =>\n              [AESKeySize] -> ([64], [n][64]) -> [64] -> [64] -> ([64], [n][64])\n  wrapBlock key (A, R) j i = (A', R')\n    where B  = aesEncrypt (A # (R @ (i-1)), key)\n          A' = (take`{64} B) ^ (((`n : [64]) * j) + i)\n          R' = update R (i-1) (drop`{64} B)\n\n    unwrapBlock : {n} (fin n, width n <= 64) =>\n                [AESKeySize] -> ([64], [n][64]) -> [64] -> [64] -> ([64], [n][64])\n  unwrapBlock key (A, R) j i = (A', R')\n    where B  = aesDecrypt ((A ^ (((`n : [64]) * j) + i)) # (R @ (i-1)), key)\n          A' = take`{64} B\n          R' = update R (i-1) (drop`{64} B)\n\n    wrapRound : {n} (fin n, n >= 1, width n <= 64) =>\n              [AESKeySize] -> ([64], [n][64]) -> [64] -> ([64], [n][64])\n  wrapRound key (A, R) j = wrappedBlocks ! 0\n    where wrappedBlocks = [(A, R)] # [wrapBlock key s j i | s <- wrappedBlocks\n                                                          | i <- [1..n]]\n\n    unwrapRound : {n} (fin n, n >= 1, width n <= 64) =>\n                [AESKeySize] -> ([64], [n][64]) -> [64] -> ([64], [n][64])\n  unwrapRound key (A, R) j = unwrappedBlocks ! 0\n    where unwrappedBlocks = [(A, R)] # [unwrapBlock key s j i | s <- unwrappedBlocks\n                                                              | i <- [n, n-1 .. 1]]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/speck.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module implementing the Speck block cipher family (encrypt, decrypt, expandKey, round functions) for the listed parameter sets, and define properties showing decryption inverts encryption and that all given known-answer test vectors (t00\u2013t09) hold."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::speck where\n\nSpeck32_64    = encrypt`{n = 16, m = 4, T = 22}\nSpeck48_72    = encrypt`{n = 24, m = 3, T = 22}\nSpeck48_96    = encrypt`{n = 24, m = 4, T = 23}\nSpeck64_96    = encrypt`{n = 32, m = 3, T = 26}\nSpeck64_128   = encrypt`{n = 32, m = 4, T = 27}\nSpeck96_96    = encrypt`{n = 48, m = 2, T = 28}\nSpeck96_144   = encrypt`{n = 48, m = 3, T = 29}\nSpeck128_128  = encrypt`{n = 64, m = 2, T = 32}\nSpeck128_192  = encrypt`{n = 64, m = 3, T = 33}\nSpeck128_256  = encrypt`{n = 64, m = 4, T = 34}\n\nSpeck32_64'   = decrypt`{n = 16, m = 4, T = 22}\nSpeck48_72'   = decrypt`{n = 24, m = 3, T = 22}\nSpeck48_96'   = decrypt`{n = 24, m = 4, T = 23}\nSpeck64_96'   = decrypt`{n = 32, m = 3, T = 26}\nSpeck64_128'  = decrypt`{n = 32, m = 4, T = 27}\nSpeck96_96'   = decrypt`{n = 48, m = 2, T = 28}\nSpeck96_144'  = decrypt`{n = 48, m = 3, T = 29}\nSpeck128_128' = decrypt`{n = 64, m = 2, T = 32}\nSpeck128_192' = decrypt`{n = 64, m = 3, T = 33}\nSpeck128_256' = decrypt`{n = 64, m = 4, T = 34}\n\nproperty correctSpeck32_64 (k, b) = Speck32_64' k (Speck32_64 k b) == b\nproperty correctSpeck64_96 (k, b) = Speck64_96' k (Speck64_96 k b) == b\nproperty correctSpeck96_144 (k, b) = Speck96_144' k (Speck96_144 k b) == b\nproperty correctSpeck128_128 (k, b) = Speck128_128' k (Speck128_128 k b) == b\nproperty correctSpeck128_256 (k, b) = Speck128_256' k (Speck128_256 k b) == b\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ round function\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nR : {n} (fin n) => [n] -> ([n], [n]) -> ([n], [n])\nR k (x, y) = f2 (f1 k (x, y))\n\nR' : {n} (fin n) => [n] -> ([n], [n]) -> ([n], [n])\nR' k (x, y) = ((x ^ k) - z <<< (if `n == 16 then 7 else 8), z)\n  where z = (x ^ y) >>> (if `n == 16 then 2 else 3)\n\nf1 : {n} (fin n) => [n] -> ([n], [n]) -> ([n], [n])\nf1 k (x, y) = (y, (x >>> (if `n == 16 then 7 else 8)) + y ^ k)\n\nf2 : {n} (fin n) => ([n], [n]) -> ([n], [n])\nf2 (x, y) = (y, x <<< (if `n == 16 then 2 else 3) ^ y)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ encryption \/ decryption\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nencrypt : {n, m, T}\n    ( fin n, fin m, fin T\n    , m >= 2, T >= 2, n >= 2\n    , n >= width (T-2)\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\nencrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [R k b | b <- bs | k <- ks]\n    ks = expandKey`{n = n, m = m, T = T} (reverse k0)\n\ndecrypt : {n, m, T}\n    ( fin n, fin m, fin T\n    , m >= 2, T >= 2, n >= 2\n    , n >= width (T-2)\n    ) => [m][n] -> ([n], [n]) -> ([n], [n])\ndecrypt k0 b0 = bs ! 0\n  where\n    bs = [b0] # [R' k b | b <- bs | k <- reverse ks]\n    ks = expandKey`{n = n, m = m, T = T} (reverse k0)\n\nexpandKey : {n, m, T}\n    ( fin n, fin m, fin T\n    , m >= 2, n >= 2, T >= 2\n    , n >= width (T-2)\n    ) => [m][n] -> [T][n]\nexpandKey K = ks\n  where\n    ls = drop`{1} K # [snd (f1 i (l, k)) | l <- ls | k <- ks | i <- [0 .. T - 2]]\n    ks = take`{1} K # [snd (f2 (k, l)) | l <- drop`{m - 1} ls | k <- ks]\n    snd (x, y) = y\n\nproperty testsPass = and tests\n\ntests = [t01, t02, t03, t04, t05, t06, t07, t08, t09]\n\nt00 = Speck32_64 [0x1918, 0x1110, 0x0908, 0x0100] (0x6574, 0x694C) == (0xA868, 0x42F2)\nt01 = Speck48_72 [0x121110, 0x0A0908, 0x020100] (0x20796C, 0x6C6172) == (0xC049A5, 0x385ADC)\nt02 = Speck48_96 [0x1A1918, 0x121110, 0x0A0908, 0x020100] (0x6D2073, 0x696874) == (0x735E10, 0xB6445D)\nt03 = Speck64_96 [0x13121110, 0x0B0A0908, 0x03020100] (0x74614620, 0x736E6165) == (0x9F7952EC, 0x4175946C)\nt04 = Speck64_128 [0x1B1A1918, 0x13121110, 0x0B0A0908, 0x03020100] (0x3B726574, 0x7475432D) == (0x8C6FA548, 0x454E028B)\nt05 = Speck96_96 [0x0D0C0B0A0908, 0x050403020100] (0x65776F68202C, 0x656761737520) == (0x9E4D09AB7178, 0x62BDDE8F79AA)\nt06 = Speck96_144 [0x151413121110, 0x0D0C0B0A0908, 0x050403020100] (0x656D6974206E, 0x69202C726576) == (0x2BF31072228A, 0x7AE440252EE6)\nt07 = Speck128_128 [0x0F0E0D0C0B0A0908, 0x0706050403020100] (0x6C61766975716520, 0x7469206564616D20) == (0xA65D985179783265, 0x7860FEDF5C570D18)\nt08 = Speck128_192 [0x1716151413121110, 0x0F0E0D0C0B0A0908, 0x0706050403020100] (0x7261482066656968, 0x43206F7420746E65) == (0x1BE4CF3A13135566, 0xF9BC185DE03C1886)\nt09 = Speck128_256 [0x1F1E1D1C1B1A1918, 0x1716151413121110, 0x0F0E0D0C0B0A0908, 0x0706050403020100] (0x65736F6874206E49, 0x202E72656E6F6F70) == (0x4109010405C0F53E, 0x4EEEB48D9C188F43)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/TripleDES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Primitive::Symmetric::Cipher::Block::TripleDES that defines Triple-DES block encryption using DES.encrypt\/decrypt and a property testsPass that checks three given known-answer test vectors for a 64-bit block interface."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::TripleDES where\n\nimport Primitive::Symmetric::Cipher::Block::DES\n\nblockEncrypt : ([64],[64],[64],[64]) -> [64]\nblockEncrypt (k1,k2,k3,data) = result where\n    ex     = DES.encrypt k1 data\n    dx     = DES.decrypt k2 ex\n    result = DES.encrypt k3 dx\n\nKey1, Key2, Key3 : [64]\nKey1 = 0x0123456789ABCDEF\nKey2 = 0x23456789ABCDEF01\nKey3 = 0x456789ABCDEF0123\n\nP1, P2, P3 : [64]\nPlainText = \"The qufck brown fox jump\"\n[P1, P2, P3] = split`{3} (join PlainText)\n\nC1, C2, C3 : [64]\nC1 = 0xA826FD8CE53B855F\nC2 = 0xCCE21C8112256FE6\nC3 = 0x68D5C05DD9B6B900\n\ntest_B1_1 = blockEncrypt (Key1, Key2, Key3, P1) == C1\ntest_B1_2 = blockEncrypt (Key1, Key2, Key3, P2) == C2\ntest_B1_3 = blockEncrypt (Key1, Key2, Key3, P3) == C3\n\nproperty testsPass = and [test_B1_1, test_B1_2, test_B1_3]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for Triple-DES CBC mode encryption over 64-bit blocks, including cbcTDesEnc with keys k1, k2, k3, an IV, test vectors (testKey, testPt, testCt), and a property testPass that checks the implementation against the given known-answer test."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::TDES_CBC where\nimport Primitive::Symmetric::Cipher::Block::TripleDES\n\ntype iv = [64]\ntype block = [64]\n\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncbcTDesEnc : {n} (fin n) => k1 -> k2 -> k3->iv -> [n]block -> [n]block\ncbcTDesEnc k1 k2 k3 iv ps = cs\n    where cs = [ blockEncrypt (k1, k2, k3, (p ^ c')) | p <- ps | c' <- [iv] # cs ]\n\ntestKey ={ k1=0x0123456789ABCDEF, k2=0x23456789ABCDEF01, k3=0x456789ABCDEF0123,      iv=0xF69F2445DF4F9B17 }\ntestPt = [[0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]]\ntestCt = [[0x2079C3D53AA763E1, 0x93B79E2569AB5262, 0x516570481F25B50F, 0x73C0BDA85C8E0DA7]]\n\nproperty testPass = and [(cbcTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv ps) == cs\n                        | ps <- testPt | cs <- testCt]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for CBC (Cipher Block Chaining) mode over 128-bit blocks, defining the types iv, block, and the functions cbcEnc and cbcDec with the given polymorphic signatures using a supplied block cipher primitive."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CBC where\n\ntype iv = [128]\ntype block = [128]\n\ncbcEnc : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncbcEnc enc k iv ps = cs\n    where cs = [ enc k (p ^ c') | p <- ps | c' <- [iv] # cs ]\n\ncbcDec : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncbcDec dec k iv cs = [ (dec k c) ^ c' | c <- cs | c' <- [iv] # cs ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AES_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification module `Primitive::Symmetric::Cipher::Block::Modes::AES_CBC` that defines AES-CBC encryption using `cbcEnc`\/`cbcDec`, and properties `cbcEncCorrect`, `testEncCbcPassB1`, `testEncCbcPassB2`, `testEncCbcPassB3`, and `testEncCbcPassB4` that verify decryption correctness and NIST AES-CBC test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::AES_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::CBC\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\nproperty cbcEncCorrect encrypt k c ps = (cbcDec encrypt k c (cbcEnc encrypt k c ps)) == ps\n\ntestKey = [0x06a9214036b8a15b512e03d534120006]\ntestIv = [0x3dafba429d9eb430b422da802c9fac41]\ntestPt = [[join \"Single block msg\"]]\ntestCt = [[0xe353779c1079aeb82708942dbe77181a]]\n\nproperty testEncCbcPassB1 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey | iv <- testIv | ps <- testPt | cs <- testCt ]\n\ntestKey2 = [0xc286696d887c9aa0611bbb3e2025a45a]\ntestIv2 = [0x562e17996d093d28ddb3ba695a2e6f58]\ntestPt2 = [[0x000102030405060708090a0b0c0d0e0f, 0x101112131415161718191a1b1c1d1e1f]]\ntestCt2 = [[0xd296cd94c2cccf8a3a863028b5e1dc0a, 0x7586602d253cfff91b8266bea6d61ab1]]\n\nproperty testEncCbcPassB2 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey2 | iv <- testIv2 | ps <- testPt2 | cs <- testCt2 ]\n\ntestKey3 = [0x6c3ea0477630ce21a2ce334aa746c2cd]\ntestIv3 = [0xc782dc4c098c66cbd9cd27d825682c81]\ntestPt3 = [[0x5468697320697320612034382d627974, 0x65206d65737361676520286578616374, 0x6c7920332041455320626c6f636b7329]]\ntestCt3 = [[0xd0a02b3836451753d493665d33f0e886, 0x2dea54cdb293abc7506939276772f8d5, 0x021c19216bad525c8579695d83ba2684]]\n\nproperty testEncCbcPassB3 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey3 | iv <- testIv3 | ps <- testPt3 | cs <- testCt3 ]\n\ntestKey4 = [0x56e47a38c5598974bc46903dba290349]\ntestIv4 = [0x8ce82eefbea0da3c44699ed7db51b7d9]\ntestPt4 = [[0xa0a1a2a3a4a5a6a7a8a9aaabacadaeaf, 0xb0b1b2b3b4b5b6b7b8b9babbbcbdbebf, 0xc0c1c2c3c4c5c6c7c8c9cacbcccdcecf, 0xd0d1d2d3d4d5d6d7d8d9dadbdcdddedf]]\ntestCt4 = [[0xc30e32ffedc0774e6aff6af0869f71aa, 0x0f3af07a9a31a9c684db207eb0ef8e4e, 0x35907aa632c3ffdf868bb7b29d3d46ad, 0x83ce9f9a102ee99d49a53e87f4c3da55]]\n\nproperty testEncCbcPassB4 = and [ (cbcEnc encrypt k iv ps) == cs\n                                | k <- testKey4 | iv <- testIv4 | ps <- testPt4 | cs <- testCt4 ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the CTR block cipher mode of operation in Cryptol by defining types for 128-bit blocks and IVs and functions ctrEnc and ctrDec that perform XOR of plaintext\/ciphertext with the encryption of a counter sequence using a given block cipher."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CTR where\n\ntype ic = [128]\ntype block = [128]\n\nctrEnc : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> ic -> [n]block -> [n]block\nctrEnc enc k c ps = cs\n    where cs = [(enc k c')^p | p <- ps | c' <- ctrs]\n          ctrs = [c+i | i<- [0...]]\n\nctrDec : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> ic -> [n]block -> [n]block\nctrDec enc k c cs = ps\n    where ps = [(enc k c')^ct | ct <- cs | c' <- ctrs]\n          ctrs = [c+i | i<- [0...]]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for Triple-DES encryption in CFB mode with 64-bit blocks and keys, including the function `cfbTDesEnc : {n} (fin n) => [64] -> [64] -> [64] -> [64] -> [n][64] -> [n][64]` and a property `testPass` checking given NIST-style test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::TDES_CFB where\nimport Primitive::Symmetric::Cipher::Block::TripleDES\n\ntype iv = [64]\ntype block = [64]\n\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncfbTDesEnc : {n} (fin n) => k1 -> k2 -> k3->iv -> [n]block -> [n]block\ncfbTDesEnc k1 k2 k3 iv ps = cs\n    where cs = [ blockEncrypt (k1, k2, k3,  c')^p | p <- ps | c' <- [iv] # cs ]\n\ntestKey ={ k1=0x0123456789ABCDEF, k2=0x23456789ABCDEF01, k3=0x456789ABCDEF0123,      iv=0xF69F2445DF4F9B17 }\ntestPt = [[0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]]\ntestCt = [[0x078BB74E59CE7ED6, 0x7666DE9CF95EAF3F, 0xE9ED6BB460F45152, 0x8A5F9FE4ED710918]]\n\nproperty testPass = and [(cfbTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv ps) == cs\n                        | ps <- testPt | cs <- testCt]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AES_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for AES in CTR mode that defines ctrEnc and ctrDec, proves the property ctrEncCorrect enc k c ps, and includes a testPass property showing the given NIST AES-CTR test vector encrypts plaintext to ciphertext with key k and initial counter ic."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::AES_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::CTR\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\nproperty ctrEncCorrect enc k c ps = (ctrDec enc k c (ctrEnc enc k c ps)) == ps\n\nk = 0x2b7e151628aed2a6abf7158809cf4f3c\nic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\nplaintext = [0x6bc1bee22e409f96e93d7e117393172a, 0xae2d8a571e03ac9c9eb76fac45af8e51, 0x30c81c46a35ce411e5fbc1191a0a52ef, 0xf69f2445df4f9b17ad2b417be66c3710]\nciphertext = [0x874d6191b620e3261bef6864990db6ce, 0x9806f66b7970fdff8617187bb9fffdff, 0x5ae4df3edbd5d35e5b4f09020db03eab, 0x1e031dda2fbe03d1792170a0f3009cee]\n\nproperty testPass = (ctrEnc encrypt k ic plaintext) == ciphertext\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify the CFB block cipher mode of operation by defining the cfbEnc and cfbDec functions (using a generic block cipher [k] -> block -> block, 128-bit iv and blocks) and properties showing that decryption inverts encryption for all n, k, keys, IVs, and messages."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CFB where\n\ntype iv = [128]\ntype block = [128]\n\ncfbEnc : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncfbEnc enc k iv ps = cs\n    where cs = [ (enc k c')^p | p <- ps | c' <- [iv] # cs ]\n\ncfbDec : {n, k} (fin n, fin k) => ([k]->block -> block) -> [k] -> iv -> [n]block -> [n]block\ncfbDec enc k iv cs = [ (enc k c')^c | c <- cs | c' <- [iv] # cs ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AES_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for AES in CFB mode using an AES core and a generic CFB mode, including properties that cfbEnc and cfbDec are inverses and that NIST AES-CFB test vectors (single and multi-block) are satisfied."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::AES_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::CFB\nimport Primitive::Symmetric::Cipher::Block::AES_parameterized\n\nproperty cfbEncCorrect encrypt k c ps = (cfbDec encrypt k c (cfbEnc encrypt k c ps)) == ps\n\ntestKey = [0x2b7e151628aed2a6abf7158809cf4f3c]\ntestIv = [0x000102030405060708090a0b0c0d0e0f]\ntestPt = [[0x6bc1bee22e409f96e93d7e117393172a]]\ntestCt = [[0x3b3fd92eb72dad20333449f8e83cfb4a]]\n\nproperty testEncCfbPassB1 = and [ (cfbEnc encrypt k iv ps) == cs\n                                | k <- testKey | iv <- testIv | ps <- testPt | cs <- testCt ]\n\ntestKey2 = [0x2b7e151628aed2a6abf7158809cf4f3c]\ntestIv2 = [0x000102030405060708090a0b0c0d0e0f]\ntestPt2 = [[0x6bc1bee22e409f96e93d7e117393172a, 0xae2d8a571e03ac9c9eb76fac45af8e51, 0x30c81c46a35ce411e5fbc1191a0a52ef, 0xf69f2445df4f9b17ad2b417be66c3710]]\ntestCt2 = [[0x3b3fd92eb72dad20333449f8e83cfb4a, 0xc8a64537a0b3a93fcde3cdad9f1ce58b, 0x26751f67a3cbb140b1808cf187a4f4df, 0xc04b05357c5d1c0eeac4c66f9ff7f2e6]]\n\nproperty testEncCfbPassB2 = and [ (cfbEnc encrypt k iv ps) == cs\n                                | k <- testKey2 | iv <- testIv2 | ps <- testPt2 | cs <- testCt2 ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Tests\/TestAESKeyWrap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Tests::TestAESKeyWrap` that defines AES key wrap\/unwrap test vectors and properties (e.g., `testWrap128_256`, `testUnwrap128_256`, `Count0Wrap`, `Count4Unwrap`) to verify `aesWrapKey`\/`aesUnwrapKey` against known AES Key Wrap KATs, including failure cases."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Tests::TestAESKeyWrap where\n\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Block::AESKeyWrap\n\nKEK256 : [AESKeySize]\nKEK256 = 0x000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\n\nKeyData128 : [16][8]\nKeyData128 = split 0x00112233445566778899AABBCCDDEEFF\n\nCiphertext128_256 : [24][8]\nCiphertext128_256 = split 0x64E8C3F9CE0F5BA263E9777905818A2A93C8191E7D6E8AE7\n\nproperty testWrap128_256 = (aesWrapKey KEK256 DefaultIV KeyData128) == Ciphertext128_256\nproperty testUnwrap128_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext128_256) == (True, KeyData128)\n\nKeyData192 : [24][8]\nKeyData192 = split 0x00112233445566778899AABBCCDDEEFF0001020304050607\n\nCiphertext192_256 : [32][8]\nCiphertext192_256 = split 0xA8F9BC1612C68B3FF6E6F4FBE30E71E4769C8B80A32CB8958CD5D17D6B254DA1\n\nproperty testWrap192_256 = (aesWrapKey KEK256 DefaultIV KeyData192) == Ciphertext192_256\nproperty testUnwrap192_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext192_256) == (True, KeyData192)\n\nKeyData256 : [32][8]\nKeyData256 = split 0x00112233445566778899AABBCCDDEEFF000102030405060708090A0B0C0D0E0F\n\nCiphertext256_256 : [40][8]\nCiphertext256_256 = split 0x28C9F404C4B810F4CBCCB35CFB87F8263F5786E2D80ED326CBC7F0E71A99F43BFB988B9B7A02DD21\n\nproperty testWrap256_256 = (aesWrapKey KEK256 DefaultIV KeyData256) == Ciphertext256_256\nproperty testUnwrap256_256 = (aesUnwrapKey KEK256 DefaultIV Ciphertext256_256) == (True, KeyData256)\n\nKCount0 = 0x80aa997327a4806b6a7a41a52b86c3710386f932786ef79676fafb90b8263c5f\nPCount0 = split`{each=8} 0x0a256ba75cfa03aaa02ba94203f15baa\nCCount0 = split`{each=8} 0x423c960d8a2ac4c1d33d3d977bf0a91559f99c8acd293d43\nproperty Count0Wrap = (aesWrapKey KCount0 DefaultIV PCount0) == CCount0\nproperty Count0Unwrap = (aesUnwrapKey KCount0 DefaultIV CCount0) == (True, PCount0)\n\nKCount1 = 0x2d104bc65c5f78e92993bd78b27d8e59a8a1f7c64b55b05be5df30f96ff04767\nCCount1 = split`{each=8} 0xe69fc01ea73e11bb4bc7485044145f824cfd535528b76517\nPCount1 = split`{each=8} 0xf8d46471445228d2ef399755360bdd6e\nproperty Count1Wrap = (aesWrapKey KCount1 DefaultIV PCount1) == CCount1\nproperty Count1Unwrap = (aesUnwrapKey KCount1 DefaultIV CCount1) == (True, PCount1)\n\nKCount2 = 0xd963c8f1d3d2392629823fd1df3f644c8690f602c94e5d5818309d7c05e5427f\nCCount2 = split`{each=8} 0x177c6217f7fd6c94cbd4a9f512b1416c869328e3084e09ea\nPCount2 = split`{each=8} 0x451d0222ec29755d9c69165a5d109727\nproperty Count2Wrap = (aesWrapKey KCount2 DefaultIV PCount2) == CCount2\nproperty Count2Unwrap = (aesUnwrapKey KCount2 DefaultIV CCount2) == (True, PCount2)\n\nKCount3 = 0xe594f0067cedb74e883e7746d29ba725c884c25375323f367cf49d17ad0f567b\nCCount3 = split`{each=8} 0x3b51ae2b0e3ddeed94efd7bfdc22630187e1f7624d15ed78\nPCount3 = split`{each=8} 0x587e3f6c75644bb5c3db9c74714f5556\nproperty Count3Wrap = (aesWrapKey KCount3 DefaultIV PCount3) == CCount3\nproperty Count3Unwrap = (aesUnwrapKey KCount3 DefaultIV CCount3) == (True, PCount3)\n\nKCount4 = 0x08c936b25b567a0aa679c29f201bf8b190327df0c2563e39cee061f149f4d91b\nCCount4 = split`{each=8} 0xe227eb8ae9d239ccd8928adec39c28810ca9b3dc1f366444\nproperty Count4Unwrap = (aesUnwrapKey KCount4 DefaultIV CCount4) == (False, zero)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/GF28.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for AES\u2019s GF(2^8) finite field arithmetic, including type GF28, irreducible polynomial, and functions gf28Add, gf28Mult, gf28Pow, gf28Inverse, gf28DotProduct, gf28VectorMult, and gf28MatrixMult with the same behavior and interfaces as described."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::GF28 where\n\ntype GF28 = [8]\n\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\ngf28Mult : GF28 -> GF28 -> GF28\ngf28Mult x y = pmod (pmult x y) irreducible\n\ngf28Pow : GF28 -> [8] -> GF28\ngf28Pow n k = pow k\n  where   sq x  = gf28Mult x x\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult n (sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow x 254\n\ngf28DotProduct : {n} (fin n) => [n]GF28 -> [n]GF28 -> GF28\ngf28DotProduct xs ys = gf28Add [ gf28Mult x y | x <- xs | y <- ys ]\n\ngf28VectorMult : {n, m} (fin n) => [n]GF28 -> [m][n]GF28 -> [m]GF28\ngf28VectorMult v ms = [ gf28DotProduct v m | m <- ms ]\n\ngf28MatrixMult : {n, m, k} (fin m) => [n][m]GF28 -> [m][k]GF28 -> [n][k]GF28\ngf28MatrixMult xss yss = [ gf28VectorMult xs yss' | xs <- xss ]\n   where yss' = transpose yss\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Algorithm.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for AES block cipher encryption and decryption that defines the parameterized type Mode, types Nk, Nr, AESKeySize, KeySchedule, and the functions encrypt and decrypt over 128-bit blocks using abstract encRound and decRound and the final AES round functions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Algorithm where\n\nimport Primitive::Symmetric::Cipher::Block::AES::State (State, RoundKey, msgToState, stateToMsg)\nimport Primitive::Symmetric::Cipher::Block::AES::Round (AESFinalRound, AESFinalInvRound)\n\nparameter\n\n  type Mode : #\n\n  type constraint (2 >= Mode)\n\n  encRound     : RoundKey -> State -> State\n  decRound     : RoundKey -> State -> State\n\ntype Nk = 4 + 2 * Mode\n\ntype Nr = 6 + Nk\n\ntype AESKeySize  = 32 * Nk\n\ntype KeySchedule = (RoundKey, [Nr-1]RoundKey, RoundKey)\n\nencrypt : KeySchedule -> [128] -> [128]\nencrypt (kInit,ks,kFinal) pt =\n                            stateToMsg (AESFinalRound kFinal (rounds ! 0))\n  where\n  state0 = kInit ^ msgToState pt\n  rounds = [state0] # [ encRound rk s | rk <- ks | s <- rounds ]\n\ndecrypt : KeySchedule -> [128] -> [128]\ndecrypt (kInit, ks, kFinal) ct =\n                          stateToMsg (AESFinalInvRound kFinal (rounds ! 0))\n  where\n  state0 = kInit ^ msgToState ct\n  rounds = [state0] # [ decRound rk s | rk <- ks | s <- rounds ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/SBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the AES S-box and inverse S-box as lookup tables over GF(2^8), including the type synonym SBox = [256] GF28 and functions sbox and sboxInv defined via SubByte and InvSubByte."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::SBox where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::SubBytePlain\n\ntype SBox = [256] GF28\n\nsbox : SBox\nsbox = [ SubByte x | x <- [0 .. 255] ]\n\nsboxInv : SBox\nsboxInv = [ InvSubByte x | x <- [0 .. 255] ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/ExpandKey.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for AES key expansion that defines type parameters Nk and Nr, the function expandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey), and supporting functions Rcon, SubWord, RotWord, NextWord, and expandKeyForever as in the AES standard."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::ExpandKey where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::State\nimport Primitive::Symmetric::Cipher::Block::AES::SubByteSBox\n\nparameter\n\n  type Nk : #\n  type constraint (8 >= width Nk, Nk >= 1)\n\n  type Nr : #\n  type constraint (8 >= width Nr, Nr >= 2)\n\nexpandKey : [32 * Nk] -> (RoundKey, [Nr-1]RoundKey, RoundKey)\nexpandKey key = ( keys @ 0\n                , keys @@ ([1 .. (Nr - 1)] : [_][8])\n                , keys @ (`Nr : [8])\n                )\n  where   seed : [Nk][4][8]\n          seed = split (split key)\n          keys = expandKeyForever seed\n\nexpandKeyForever : [Nk][4][8] -> [inf]RoundKey\nexpandKeyForever seed = [ transpose g | g <- split (keyWS seed) ]\n\nkeyWS : [Nk][4][8] -> [inf][4][8]\nkeyWS seed    = xs\n     where xs = seed # [ NextWord i prev old\n                       | i    <- [ `Nk ... ]\n                       | prev <- drop`{Nk-1} xs\n                       | old  <- xs\n                       ]\n\nRcon : [8] -> [4]GF28\nRcon i = [ gf28Pow <| x |> (i-1), 0, 0, 0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord bs = [ SubByte b | b <- bs ]\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nNextWord : [8] ->[4][8] -> [4][8] -> [4][8]\nNextWord i prev old = old ^ mask\n   where mask = if i % nk == 0\n                then SubWord (RotWord(prev)) ^ Rcon (i \/ `Nk)\n                else if (nk > 6) && (i % nk == 4)\n                     then SubWord prev\n                     else prev\n\n         nk = `Nk : [8]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/SubByteSBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the AES SubByte and InvSubByte functions over GF(2^8) using the AES S-box and inverse S-box, with appropriate types and any necessary properties relating them to sbox and sboxInv."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::SubByteSBox where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::SBox\n\nSubByte : GF28 -> GF28\nSubByte b = sbox @ b\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = sboxInv @ b\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Round.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the AES round, final round, inverse round, and final inverse round functions on AES State values and RoundKeys, matching the structure of SubBytes, ShiftRows, MixColumns, and their inverses as used in AES-128\/192\/256 block ciphers."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Round where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::State\nimport Primitive::Symmetric::Cipher::Block::AES::SubByteSBox\n\nAESRound : RoundKey -> State -> State\nAESRound rk s = rk ^ MixColumns (ShiftRows (SubBytes s))\n\nSubBytes : State -> State\nSubBytes state = [ [ SubByte b | b <- row ] | row <- state ]\n\nShiftRows : State -> State\nShiftRows state = [ row <<< i | row <- state | i : [2] <- [0 .. 3] ]\n\nMixColumns : State -> State\nMixColumns state = gf28MatrixMult m state\n    where m = [ [2,3,1,1] >>> i | i <- [0 .. 3] ]\n\nAESFinalRound : RoundKey -> State -> State\nAESFinalRound rk s = rk ^ ShiftRows (SubBytes s)\n\nAESInvRound : RoundKey -> State -> State\nAESInvRound rk s = InvMixColumns (rk ^ InvSubBytes (InvShiftRows s))\n\nInvSubBytes : State -> State\nInvSubBytes state = [ [ InvSubByte b | b <- row ] | row <- state ]\n\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> shiftAmount | row <- state\n                                           | shiftAmount : [2] <- [0 .. 3]\n                     ]\n\nInvMixColumns : State -> State\nInvMixColumns state = gf28MatrixMult m state\n    where m = [[0x0e, 0x0b, 0x0d, 0x09] >>> i | i <- [0 .. 3] ]\n\nAESFinalInvRound : RoundKey -> State -> State\nAESFinalInvRound rk s = rk ^ InvSubBytes (InvShiftRows s)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/SubBytePlain.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module implementing the AES SubBytes and InvSubBytes operations over GF(2^8), including the affine transforms xformByte and xformByte', using the supplied GF28 type and gf28Inverse\/gf28Add operations."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::SubBytePlain where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\n\nSubByte : GF28 -> GF28\nSubByte b = xformByte (gf28Inverse b)\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = gf28Inverse (xformByte' b)\n\n\/\/ The affine transform and its inverse\nxformByte : GF28 -> GF28\nxformByte b = gf28Add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n   where c = 0x63\n\nxformByte' : GF28 -> GF28\nxformByte' b = gf28Add [(b >>> 2), (b >>> 5), (b >>> 7), d] where d = 0x05\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/TBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the AES T-box-based round functions in Cryptol by defining the type TBox, the functions AESRound, AESInvRound, makeDecKey, genRound, tbox, tboxInv, mkTBox, and appropriate properties that relate these T-box rounds to standard AES round behavior."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::TBox where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\nimport Primitive::Symmetric::Cipher::Block::AES::State\nimport Primitive::Symmetric::Cipher::Block::AES::SBox\nimport Primitive::Symmetric::Cipher::Block::AES::Round\n\nAESRound    rk st = genRound ShiftRows    tbox    rk st\nAESInvRound rk st = genRound InvShiftRows tboxInv rk st\n\nmakeDecKey (a,xs,b) = (b, [ InvMixColumns rk | rk <- reverse xs ], a)\n\ngenRound : (State -> State) -> TBox -> RoundKey -> State -> State\ngenRound shift boxes rk st =\n  rk ^ transpose [ add [ box @ i | box <- boxes | i <- col ]\n                 | col <- transpose (shift st) ]\n  where add [ a, b, c, d ] = a ^ b ^ c ^ d\n\ntype TBox = [4][256][4]GF28\n\ntbox : TBox\ntbox = mkTBox [ 0x02, 0x01, 0x01, 0x03 ] sbox\n\ntboxInv : TBox\ntboxInv = mkTBox [ 0x0e, 0x09, 0x0d, 0x0b ] sboxInv\n\nmkTBox : [4]GF28 -> SBox -> TBox\nmkTBox seed box = [ [ a >>> i | a <- t0 ] | i <- [0 .. 3] ]\n  where\n  t0 = [ [ gf28Mult c s | c <- seed ] | s <- box ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/State.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the Cryptol module Primitive::Symmetric::Cipher::Block::AES::State that specifies the AES state representation and the msgToState and stateToMsg functions converting between 128-bit messages and the 4\u00d7Nb GF28 AES state matrix, preserving a bijective mapping."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::State where\n\nimport Primitive::Symmetric::Cipher::Block::AES::GF28\n\ntype State       = [4][Nb]GF28\ntype Nb          = 4\ntype RoundKey    = State\n\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Hash\/HMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the HMAC-SHA384 algorithm using SHA-384, including key_init, HMACInit, HMACUpdate, HMACFinal, and HMAC functions, and add properties that verify HMAC against known test vectors and standard HMAC-SHA384 behavior."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::HMAC where\n\nimport Primitive::Keyless::Hash::SHA384\n\nkey_init : {key_size} (fin key_size) => [key_size][8] -> [128][8]\nkey_init key =\n  take`{128} (if `key_size <= 128\n              then key # (zero : [inf][8])\n              else (split`{48} (SHAImp key)) # (zero : [inf][8]))\n\ntype HMACState = { i_ctx  : SHAState\n                 , o_ctx  : SHAState\n                 , md_ctx : SHAState\n                 }\n\nHMACInit : {key_size} (fin key_size) => [key_size][8] -> HMACState\nHMACInit key =\n  { i_ctx  = i_state\n  , o_ctx  = SHAUpdate SHAInit opad\n  , md_ctx = i_state\n  }\n  where key'    = key_init key\n        ipad    = [ k ^ 0x36 | k <- key' ]\n        opad    = [ k ^ 0x5c | k <- key' ]\n        i_state = SHAUpdate SHAInit ipad\n\n\/\/ HMAC-SHA384 update function\nHMACUpdate : {n} (fin n) => HMACState -> [n][8] -> HMACState\nHMACUpdate state data = { i_ctx = state.i_ctx\n                        , o_ctx = state.o_ctx\n                        , md_ctx = SHAUpdate state.md_ctx data\n                        }\n\n\/\/ HMAC-SHA384 final function\nHMACFinal : HMACState -> [48][8]\nHMACFinal state = split`{48} (SHAFinal o_ctx')\n  where o_ctx' = SHAUpdate state.o_ctx buf\n        buf = split`{48} (SHAFinal state.md_ctx)\n\n\/\/ HMAC-SHA384 implementation\nHMAC : {n, m} (fin n, fin m) => [n][8] -> [m][8] -> [48][8]\nHMAC key data = HMACFinal (HMACUpdate (HMACInit key) data)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Hash\/SHA1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the Cryptol module Primitive::Keyless::Hash::SHA1 implementing the SHA-1 hash function (including padding and block processing) and the property testsPass that checks the standard FIPS 180-1 test vectors for sha1."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA1 where\n\nsha1 : {n} (width (8*n) <= 64) => [n][8] -> [160]\nsha1 msg = sha1' pmsg\n    where\n        pmsg = pad(join(msg))\n\nsha1' : {chunks} (fin chunks) => [chunks][512] -> [160]\nsha1' pmsg = join (Hs!0)\n  where\n    Hs = [[0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]] #\n         [ block(H, split(M))\n         | H <- Hs\n         | M <- pmsg\n         ]\n\n\/*\nAs a summary, a \"1\" followed by m \"0\"s followed by a 64-\n   bit integer are appended to the end of the message to produce a\n   padded message of length 512 * n.  The 64-bit integer is the length\n   of the original message.  The padded message is then processed by the\n   SHA-1 as n 512-bit blocks.\n*\/\n\npad : {msgLen}\n     ( fin msgLen\n     , 64 >= width msgLen                             \/\/ message width fits in a word\n     )\n     => [msgLen] -> [(msgLen + 65) \/^ 512][512]\npad msg = split (msg # [True] # (zero:[padLen]) # (`msgLen:[64]))\n    where type padLen     = (msgLen + 65) %^ 512\n\nf : ([8], [32], [32], [32]) -> [32]\nf (t, x, y, z) =\n       if (0 <= t)  \/\\ (t <= 19) then (x && y) ^ (~x && z)\n        | (20 <= t) \/\\ (t <= 39) then x ^ y ^ z\n        | (40 <= t) \/\\ (t <= 59) then (x && y) ^ (x && z) ^ (y && z)\n        | (60 <= t) \/\\ (t <= 79) then x ^ y ^ z\n        else error \"f: t out of range\"\n\nKs : [80][32]\nKs = [ 0x5a827999 | t <- [0..19]  ]\n   # [ 0x6ed9eba1 | t <- [20..39] ]\n   # [ 0x8f1bbcdc | t <- [40..59] ]\n   # [ 0xca62c1d6 | t <- [60..79] ]\n\nblock : ([5][32], [16][32]) -> [5][32]\nblock ([H0, H1, H2, H3, H4], M) =\n [(H0+As@80), (H1+Bs@80), (H2+Cs@80), (H3+Ds@80), (H4+Es@80)]\n  where\n    Ws : [80][32]\n    Ws = M # [ (W3 ^ W8 ^ W14 ^ W16) <<< 1\n             | W16 <- drop`{16 - 16} Ws\n             | W14 <- drop`{16 - 14} Ws\n             | W8  <- drop`{16 - 8}  Ws\n             | W3  <- drop`{16 - 3}  Ws\n             | t <- [16..79]\n             ]\n    As = [H0] # TEMP\n    Bs = [H1] # As\n    Cs = [H2] # [ B <<< 30 | B <- Bs ]\n    Ds = [H3] # Cs\n    Es = [H4] # Ds\n    TEMP : [80][32]\n    TEMP = [ (A <<< 5) + f(t, B, C, D) + E + W + K\n           | A <- As | B <- Bs | C <- Cs | D <- Ds | E <- Es\n           | W <- Ws | K <- Ks\n           | t <- [0..79]\n           ]\n\nt0 = sha1 \"\" == 0xda39a3ee5e6b4b0d3255bfef95601890afd80709\n\n\/\/ Sample messages and their digests from FIPS180-1 appendix.\n\nt1 = sha1 \"abc\" == 0xA9993E364706816ABA3E25717850C26C9CD0D89D\nt2 = sha1 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\" ==\n     0x84983E441C3BD26EBAAE4AA1F95129E5E54670F1\nt3 = sha1 [ 'a' | i <- [1..1000000] ] ==\n     0x34AA973CD4C4DAA4F61EEB2BDBAD27316534016F\n\nproperty testsPass = and [t0, t1, t2, t3]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Hash\/MD5.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Primitive::Keyless::Hash::MD5 that implements the MD5 hash function (including md5, md5_ref, padding, rounds, and constants) and define the property testsPass verifying all given standard MD5 test vectors hold."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::MD5 where\n\nntohl : [32] -> [32]\nntohl w = join (reverse (groupBy`{8} w))\n\nhtonl : [32] -> [32]\nhtonl w = join (reverse (groupBy`{8} w))\n\nhtonll : [64] -> [64]\nhtonll w = join (reverse (groupBy`{8} w))\n\nmap : {n, a, b} (a -> b) -> [n]a -> [n]b\nmap f xs = [ f x | x <- xs ]\n\nfoldl : {n, a, b} (fin n) => a -> (a -> b -> a) -> [n]b -> a\nfoldl seed f xs = res ! 0\n  where res = [seed] # [ f a x | a <- res\n                               | x <- xs\n                       ]\n\ntest s = md5 (join s)\n\nmd5_ref : [16][8] -> [16][8]\nmd5_ref msg = map reverse (groupBy`{8} (md5 (join (map reverse msg))))\n\nmd5_ref' : [128] -> [128]\nmd5_ref' msg = join (md5_ref (groupBy`{8} msg))\n\ntype MD5State = ([32],[32],[32],[32])\n\nmd5 : {a} (64 >= width a) => [a] -> [128]\nmd5 msg = md5output finalState\n    where\n      type p = (a + 65) %^ 512\n      type b = (a + 65) \/^ 512\n\n      finalState : MD5State\n      finalState = foldl initialMD5State processBlock blocks\n\n      blocks : [b][512]\n      blocks = groupBy`{512} (pad `{a,p} msg)\n\n      add : MD5State -> MD5State -> MD5State\n      add (a, b, c, d) (e, f, g, h) = (a + e, b + f, c + g, d + h)\n\n      processBlock : MD5State -> [512] -> MD5State\n      processBlock st blk = add st (computeRounds (decodeBlock blk) st)\n\ninitialMD5State : MD5State\ninitialMD5State = (A, B, C, D)\n where\n   f x = ntohl (join x)\n   A = f [ 0x01, 0x23, 0x45, 0x67 ]\n   B = f [ 0x89, 0xAB, 0xCD, 0xEF ]\n   C = f [ 0xFE, 0xDC, 0xBA, 0x98 ]\n   D = f [ 0x76, 0x54, 0x32, 0x10 ]\n\ndecodeBlock : [512] -> [16][32]\ndecodeBlock s = map ntohl (groupBy`{32} s)\n\nmd5output : MD5State -> [128]\nmd5output (a,b,c,d) = htonl a # htonl b # htonl c # htonl d\n\npad : {a, p} (fin p, 64 >= width a) => [a] -> [65 + (a + p)]\npad msg =\n    msg # [True] # zero # htonll sz\n    where\n      sz : [64]\n      sz = length msg\n\ncomputeRounds : [16][32] -> MD5State -> MD5State\ncomputeRounds msg st = rounds (msg,st) @ 64\n\nrounds : ([16][32], MD5State) -> [65]MD5State\nrounds (msg, (a0, b0, c0, d0)) =\n    [ (a, b, c, d) | a <- as\n                   | b <- bs\n                   | c <- cs\n                   | d <- ds\n    ]\n    where\n      bs =\n          [b0] #\n          [box (i, a, b, c, d, m, t, s) | i <- [0 .. 63]\n                                        | a <- as\n                                        | b <- bs\n                                        | c <- cs\n                                        | d <- ds\n                                        | m <- join [m @@ p | m <- [msg, msg, msg, msg]\n                                                            | p <- permutes\n                                                    ]\n                                        | t <- sineTbl\n                                        | s <- s_constants\n          ]\n      cs = [c0] # bs\n      ds = [d0] # cs\n      as = [a0] # ds\n\ns_constants : [64][6]\ns_constants =\n   repeat4 [7, 12, 17, 22] #\n   repeat4 [5,  9, 14, 20] #\n   repeat4 [4, 11, 16, 23] #\n   repeat4 [6, 10, 15, 21]\n where\n   repeat4 abcd = abcd # abcd # abcd # abcd\n\npermutes : [4][16][4]\npermutes =\n    [ [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15]\n    , [ 1,  6, 11,  0,  5, 10, 15,  4,  9, 14,  3,  8, 13,  2,  7, 12]\n    , [ 5,  8, 11, 14,  1,  4,  7, 10, 13,  0,  3,  6,  9, 12, 15,  2]\n    , [ 0,  7, 14,  5, 12,  3, 10,  1,  8, 15,  6, 13,  4, 11,  2,  9]\n    ]\n\nbox : ([6], [32], [32], [32], [32], [32], [32], [6]) -> [32]\nbox (i, a, b, c, d, m, t, s) =\n    b + (a + boxfunc (i, b, c, d) + m + t <<< s)\n\nboxfunc : ([6],[32],[32],[32]) -> [32]\nboxfunc (i, b, c, d) =\n    if i < 16 then F (b, c, d) else\n    if i < 32 then G (b, c, d) else\n    if i < 48 then H (b, c, d) else\n                   I (b, c, d)\n\nF : ([32], [32], [32]) -> [32]\nF (x, y, z) = x && y || (~x) && z\n\nG : ([32], [32], [32]) -> [32]\nG (x, y, z) = x && z || y && ~z\n\nH : ([32], [32], [32]) -> [32]\nH (x, y, z) = x ^ y ^ z\n\nI : ([32], [32], [32]) -> [32]\nI (x, y, z) = y ^ (x || ~z)\n\nsineTbl : [64][32]\nsineTbl =\n    [0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE, 0xF57C0FAF,\n     0x4787C62A, 0xA8304613, 0xFD469501, 0x698098D8, 0x8B44F7AF,\n     0xFFFF5BB1, 0x895CD7BE, 0x6B901122, 0xFD987193, 0xA679438E,\n     0x49B40821, 0xF61E2562, 0xC040B340, 0x265E5A51, 0xE9B6C7AA,\n     0xD62F105D, 0x02441453, 0xD8A1E681, 0xE7D3FBC8, 0x21E1CDE6,\n     0xC33707D6, 0xF4D50D87, 0x455A14ED, 0xA9E3E905, 0xFCEFA3F8,\n     0x676F02D9, 0x8D2A4C8A, 0xFFFA3942, 0x8771F681, 0x6D9D6122,\n     0xFDE5380C, 0xA4BEEA44, 0x4BDECFA9, 0xF6BB4B60, 0xBEBFBC70,\n     0x289B7EC6, 0xEAA127FA, 0xD4EF3085, 0x04881D05, 0xD9D4D039,\n     0xE6DB99E5, 0x1FA27CF8, 0xC4AC5665, 0xF4292244, 0x432AFF97,\n     0xAB9423A7, 0xFC93A039, 0x655B59C3, 0x8F0CCC92, 0xFFEFF47D,\n     0x85845DD1, 0x6FA87E4F, 0xFE2CE6E0, 0xA3014314, 0x4E0811A1,\n     0xF7537E82, 0xBD3AF235, 0x2AD7D2BB, 0xEB86D391]\n\nr0 = test \"\"\n  == 0xd41d8cd98f00b204e9800998ecf8427e\n\nr1 = test \"a\"\n  == 0x0cc175b9c0f1b6a831c399e269772661\n\nr2 = test \"abc\"\n  == 0x900150983cd24fb0d6963f7d28e17f72\n\nr3 = test \"message digest\"\n  == 0xf96b697d7cb7938d525a2f31aaf161d0\n\nr4 = test \"abcdefghijklmnopqrstuvwxyz\"\n  == 0xc3fcd3d76192e4007dfb496cca67e13b\n\nr5 = test \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n  == 0xd174ab98d277d9f5a5611c2c9f419d9f\n\nr6 = test \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n  == 0x57edf4a22be3c955ac49da2e2107b67a\n\nr7 = test \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n  == 0x8215ef0796a20bcaaae116d3876c664a\n\nr8 = test (join (repeat`{1000000} \"a\") )\n  == 0x7707d6ae4e027c70eea2a935c2296f21\n\nproperty testsPass = and [ r0, r1, r2, r3, r4, r5, r6, r7, r8 ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Keyless\/Generator\/DRBG.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the AES-CTR-based s2n DRBG (instantiate, reseed, generate, uninstantiate, and update) with type s2n_drbg and drbg_generate_internal\/drbg_generate, and include test vectors plus a property testsPass that checks all tests succeed."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Generator::DRBG where\n\nimport Primitive::Symmetric::Cipher::Block::AES\n\ntype keylen   = AESKeySize type blocklen = 128 type seedlen  = 256 type reseed_limit = 2 ^^ 35 \ntype blocksize = 16 type keysize = 32 type seedsize = 48\n\ntype cipher_ctx = { key : [keylen] }\n\nblock_encrypt : [keylen] -> [blocklen] -> [blocklen]\nblock_encrypt key data = aesEncrypt(data, key)\n\ntype s2n_drbg =\n  { bytes_used : [64]\n  , ctx : cipher_ctx\n  , v : [blocklen]\n  }\n\ndrbg_generate_internal : {n, blocks}\n                         ( fin n, fin blocks, n >= 1, n <= 8192\n                         , n == blocklen * blocks)\n                      => s2n_drbg\n                      -> ([n], s2n_drbg)\ndrbg_generate_internal drbg =\n  (join [ block_encrypt drbg.ctx.key (drbg.v + i) | i <- [1 .. blocks]], drbg')\n    where drbg' = { bytes_used = drbg.bytes_used + `(blocks * blocksize)\n                  , ctx = drbg.ctx\n                  , v = drbg.v + `blocks\n                  }\n\ndrbg_instantiate : {ps_size}\n                   (fin ps_size)\n                => [seedlen]\n                -> [ps_size]\n                -> s2n_drbg\ndrbg_instantiate entropy ps = drbg_reseed zero entropy ps'\n  where\n    \/* pad ps with zeros if needed to reach seedlen\n       otherwise truncate to seedlen *\/\n    ps' = take `{seedlen} (ps # (zero : [seedlen]))\n\ndrbg_reseed : {ps_size}\n              (ps_size <= seedlen)\n           => s2n_drbg\n           -> [seedlen]\n           -> [ps_size]\n\t   -> s2n_drbg\ndrbg_reseed drbg entropy ps = drbg''\n  where\n    drbg' = drbg_update (entropy ^ (ps # zero)) drbg\n    drbg'' = { v = drbg'.v, ctx = drbg'.ctx, bytes_used = 0}\n\ndrbg_uninstantiate : s2n_drbg -> s2n_drbg\ndrbg_uninstantiate drbg = zero\n\n\/* This is the spec of the s2n code, in that it reseeds automatically\n   if reseed is required. This is in opposition to the spec, which\n   requires an error code.\n\n   We are curious about why s2n_drbg counts a number of bytes used,\n   while the spec tracks a number of calls to generate. We don't\n   belive that this is buggy behavior, since if we call the maximum\n   size with generate each time, we will reseed before the spec would\n   require it. *\/\ndrbg_generate : {n, blocks} (fin n, fin blocks, n >= 1, n <= 8192,\n                             blocks * blocklen >= n,\n                             (blocks - 1) * blocklen <= n - 1) =>\n                s2n_drbg -> [seedlen] -> Bit ->\n                ([n], s2n_drbg)\ndrbg_generate drbg entropy reseed_p = (take enc_result, drbg_out)\n  where\n        drbg_r =\n      if reseed_p \\\/ drbg.bytes_used + `n * 8 + `blocklen * 8 >= `reseed_limit then\n        drbg_reseed drbg entropy (zero : [256])\n      else drbg\n        (enc_result, drbg_v) = drbg_generate_internal `{blocks=blocks} drbg_r\n        drbg_out = drbg_update zero drbg_v\n\ndrbg_update : [seedlen] -> s2n_drbg -> s2n_drbg\ndrbg_update data drbg = result\n  where\n            type blocks = (seedlen + blocklen -1)\/blocklen\n        (enc_result, _) = drbg_generate_internal `{blocks=blocks} drbg\n        data_xor = (take enc_result) ^ data\n            result = { bytes_used = drbg.bytes_used + (`blocks * `blocksize)\n             , ctx = { key = take data_xor }\n             , v = drop data_xor\n             }\n\ntestInstantiate0 = {entropy = 0xed1e7f21ef66ea5d8e2a85b9337245445b71d6393a4eecb0e63c193d0f72f9a9,\n                    pString = zero : [0],\n                        Key = 0xb5fc83ef1518da3cb85598ee9795001e,\n                         \tV = 0x58f90cf75af84f221514db847ec007d1}\n\ntestInstantiatedrbg0 = drbg_instantiate`{ps_size=0} testInstantiate0.entropy testInstantiate0.pString\n\ntestInstantiate0Pass = testInstantiatedrbg0.v == testInstantiate0.V \/\\ testInstantiatedrbg0.ctx.key == testInstantiate0.Key\n\ntestReseed0 = {entropyReseed = 0x303fb519f0a4e17d6df0b6426aa0ecb2a36079bd48be47ad2a8dbfe48da3efad,\n            \t           Key = 0x577a79cc512258c3e255fcf3f4cf0c1a,\n                        \t V = 0x531599fd616f33678192928bf771bb2b}\n\ntestReseed0Pass = drbgreseed.v == testReseed0.V \/\\ drbgreseed.ctx.key == testReseed0.Key\n                where drbgreseed = drbg_reseed`{ps_size=0} testInstantiatedrbg0 testReseed0.entropyReseed zero\n\ntestGenerate0 = {\tKey = 0xac373fb3773597b0d6cb6f37e6b59293,\n                \tV   = 0xcd9bf115d35c60cbf7f2ebac8e43f53b}\n\ntestGeneratedrbg0 = (drbg_generate`{n=512} testInstantiatedrbg0 testReseed0.entropyReseed True).1\n\ntestGenerate0Pass = testGeneratedrbg0.v == testGenerate0.V \/\\ testGeneratedrbg0.ctx.key == testGenerate0.Key\n\ntestGenerateSnd0 = {returnedBits = 0xf80111d08e874672f32f42997133a5210f7a9375e22cea70587f9cfafebe0f6a6aa2eb68e7dd9164536d53fa020fcab20f54caddfab7d6d91e5ffec1dfd8deaa,\n                 \tKey = 0x964c57946a104aa93fc3c2137bb9bc11,\n                 \tV   = 0x9d58008033ac007c9ead254bfa8de2b6}\n\ntestGenerateSnd0Pass = and [ result == testGenerateSnd0.returnedBits\n                           , drbg.ctx.key == testGenerateSnd0.Key\n                           , drbg.v == testGenerateSnd0.V ]\n                     where (result,drbg) = drbg_generate`{n=512} testGeneratedrbg0 zero False\n\nproperty testsPass = and [testInstantiate0Pass, testReseed0Pass, testGenerate0Pass, testGenerateSnd0Pass]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/DilithiumR1Int.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the Dilithium post-quantum signature scheme (parameter set R1 with n=256, k=5, l=4, q=8380421), including types, Gen, Sign, Verify functions, supporting NTT\/polynomial operations, and a Known Answer Test property for key generation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::DilithiumR1Int where\n\nimport Primitive::Keyless::Hash::keccak as SHA3\nimport Common::utils\nimport Primitive::Asymmetric::Signature::testDilithium\nimport Primitive::Asymmetric::Signature::signFinal\n\nimport Primitive::Asymmetric::Signature::testCase2\n\ntype q = 8380421\ntype n = 256 \ntype k = 5\ntype l = 4\nd      = 14\nwc     = 60\ngamma1 = ((`q : Integer) - 1) \/ 16 \ngamma2 = (gamma1 \/ 2)\neta    = 5\nbeta   = 275\nomega  = 96 : Integer\nqbits  = 23\n\nrootOfUnity    = 1753 : (Z q)\nrootOfUnityInv = 731434 : (Z q)\nninv           = 8347681 : (Z q)\n\ntype intPoly        = [n]Integer\ntype intPolyVec dim = [dim]intPoly\n\ntype poly        = [n](Z q) type polyVec dim = [dim]poly \n\ntype nttPoly          = [n](Z q)\ntype nttVec dim       = [dim]nttPoly\ntype nttMat dim1 dim2 = [dim1](nttVec dim2)\n\ntype PublicKey = {rho : [256], t1 : intPolyVec k} \ntype SecretKey = {rho : [256]\n                 , K  : [256]\n                 , tr : [384]\n                 , s1 : polyVec l\n                 , s2 : polyVec k\n                 , t0 : intPolyVec k}\n\nGen : [256] -> (PublicKey,SecretKey)\nGen seed = (pk, sk)\n    where\n      randoms = split`{3} (join (SHA3::toBytes (take`{768} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))\n      (rho, rho', K) = (randoms@0, randoms@1, randoms@2)\n      A       = ExpandA rho\n      s1      = PolyUniformEtaV`{dim=l} rho' zero\n      s2      = PolyUniformEtaV`{dim=k} rho' (zero + `l)\n      s1ntt   = map ntt s1\n      As1     = map nttinv (nttMatMul A s1ntt)\n      t       = paddV As1 s2\n      (t1,t0) = Power2RoundV t\n      tr      = CRH (rho#(pack_t1 t1))\n      pk      = { rho = rho, t1 = t1}\n      sk      = { rho = rho, K = K, tr = tr, s1 = s1, s2 = s2, t0 = t0}\n\n\/\/ Known Answer Test\n\/\/ To check this property, it is necessary to import testDilithium\n\ntest_key_gen = (pk.rho#(pack_t1 pk.t1) == testCase0.pk)\n\/\/\/\\\n  \/\/  ((sk.rho#sk.K#sk.tr#(pack_polyeta sk.s1)#(pack_polyeta sk.s2)#(pack_t0 sk.t0)) == testCase0.sk)\n    where\n    seed     = 0x7c9935a0b07694aa0c6d10e4db6b1add2fd81a25ccb148032dcd739936737f2d\n    (pk, sk) = Gen seed\n\n\/* Generate signature for message M *\/      \nSign : {mbytes} (fin mbytes, mbytes>=1) => SecretKey -> [mbytes*8] -> (polyVec l, [k][n], poly)\nSign sk M = (final_state.z, h, nttinv final_state.c')\n     where\n      A     = ExpandA sk.rho       mu    = CRH`{b=48+mbytes} (sk.tr#M)       kappa = zero:Integer\n      s1'   = map ntt sk.s1 \/\/checked\n      s2'   = map ntt sk.s2       t0'   = map ntt (IPVtoPV sk.t0) \/\/checked\n\n      init : sign_var_types\n      init = {z=zero,r0=zero,r1=zero,t0'=t0',c'=zero,w=zero,w1=zero\n             ,s1'=s1',s2'=s2',cs2=zero,K=sk.K,mu=mu,A=A,kappa=kappa}\n\n      final_state = dowhile sign_condition sign_body init\n      ct0         = map nttinv (nttVecConstMul final_state.c' final_state.t0')\n      h           = MakeHintV (psubV zero ct0\n                              ,paddV (psubV final_state.w final_state.cs2) (ct0)\n                              ,2*gamma2\n                              )\n\nprivate\n\n    type sign_var_types = { z   : polyVec l\n                          , r0  : intPolyVec k\n                          , r1  : intPolyVec k\n                          , t0' : nttVec k\n                          , c'  : nttPoly\n                          , w   : polyVec k\n                          , w1  : intPolyVec k\n                          , s1' : nttVec l\n                          , s2' : nttVec k\n                          , cs2 : polyVec k\n                          , K   : [256]\n                          , mu  : [384]\n                          , A   : nttMat k l\n                          , kappa: Integer}\n\n    sign_condition : sign_var_types -> Bit\n    sign_condition sv = fail1 \\\/ fail2 \n                   where\n                    fail1 = ((infNormPolyVec (PVtoIPV sv.z)) >= (gamma1-beta))\n                            \\\/ ((infNormPolyVec sv.r0) >= (gamma2-beta))\n                            \\\/ (sv.r1 != sv.w1)\n                    fail2 = ((infNormPolyVec (PVtoIPV ct0)) >= gamma2) \n                            \\\/ ( (foldl (+) 0 (map ones h)) > omega )\n                    ct0   = map nttinv (nttVecConstMul sv.c' sv.t0')\n                    h     = MakeHintV (psubV zero ct0\n                                      ,paddV (psubV sv.w sv.cs2) (ct0)\n                                      ,2*gamma2\n                                      )\n\n    sign_body : sign_var_types -> sign_var_types\n    sign_body sv = {z=z,r0=r0,r1=r1,t0'=sv.t0',c'=c',w=w,w1=w1,s1'=sv.s1',s2'=sv.s2',\n                   cs2=cs2,K=sv.K,mu=sv.mu,A=sv.A,kappa=(sv.kappa+1)}\n              where\n                y   = ExpandMask(sv.K,sv.mu,sv.kappa)                y'  = map ntt y \/\/ checked\n                w   = map nttinv (nttMatMul sv.A y')                 w1  = HighBitsV (w, 2 * gamma2)                 c'  = ntt ( H (sv.mu,w1) ) \/\/ corrected it\n                cs1 = map nttinv (nttVecConstMul c' sv.s1')\n                cs2 = map nttinv (nttVecConstMul c' sv.s2')\n                z   = paddV y cs1\n                (r1, r0) = DecomposeV (psubV w cs2, 2 * gamma2)\n\nVerify : {mbytes} (fin mbytes, mbytes>=1) => PublicKey -> [mbytes*8] -> (polyVec l, [k][n], poly) -> Bit\nVerify pk M (z, h, c) = crit1 && crit2 && crit3\n       where\n        A        = ExpandA pk.rho\n        mu       = CRH`{b=48+mbytes} ((CRH (pk.rho#(pack_t1 pk.t1)))#M)\n        zntt     = map ntt z\n        t1ntt    = map ntt (IPVtoPV pk.t1)\n        ct1ntt   = nttVecConstMul (psub zero c) t1ntt\n        ct1ntt2d = map (\\p -> map (\\x -> x*(2^^d)) p) ct1ntt \n        Az       = nttMatMul A zntt\n        w1'      = UseHintV (h, paddV Az ct1ntt2d, 2*gamma2)\n        zint     = PVtoIPV z\n        zinf     = infNormPolyVec zint\n        crit1    = zinf < gamma1 - beta\n        crit2    = c == H(mu,w1')\n        crit3    = (foldl (+) 0 (map ones h)) <= omega\n\nprivate\n    pack_w : intPolyVec k -> [4*n*k]\n    pack_w w = join [pack_poly p | p <- wBV ]\n                where\n                wBV = map (\\p -> map (\\x -> fromInteger x:[8]) p) w\n\n                pack2 : [2][8] -> [8]\n                pack2 xs = xs@0 || (xs@1 << 4)\n\n                pack_poly p = join [ pack2 xs | xs <- split p : [128][2][_] ]\n\n    pack_polyeta : {m} (fin m, m >= 1) =>  polyVec m -> [4*n*m]\n    pack_polyeta s = join [ join [elt p i | i <- [0..(n\/2)-1]:[_][8] ] | p <- s ]\n                 where\n                  elt : poly -> [8] -> [8]\n                  elt p i = (c (fromZ`{q} (p@(2*i+0)))) || ((c (fromZ`{q} (p@(2*i+1)))) << 4)\n                  c : Integer -> [8]\n                  c num = if num > eta then fromInteger (`q + eta - num) else fromInteger (eta - num)\n\n    pack_t0 : intPolyVec k -> [k*3584]\n    pack_t0 t0 = join [ pack_poly p | p <- t0 ]\n            where\n              tmp : intPoly -> [8] -> [8] -> [32]\n              tmp p i j = fromInteger (2^^13 - p@(4*i+j))\n\n              pack_poly : intPoly -> [3584]\n              pack_poly p = join [ join [drop`{24} (tmp p i 0),\n                         drop`{24} (((tmp p i 0) >> 8) || ((tmp p i 1) << 6)),\n                         drop`{24} ((tmp p i 1) >> 2),\n                         drop`{24} (((tmp p i 1) >> 10) || ((tmp p i 2) << 4)),\n                         drop`{24} ((tmp p i 2) >> 4),\n                         drop`{24} (((tmp p i 2) >> 12) || ((tmp p i 3) << 2)),\n                         drop`{24} ((tmp p i 3) >> 6)\n                         ] | i <- [0..(n\/4-1)] ]\n\n    \/\/ d must be 14 for this to work, and n must be 256\n    pack_t1 : intPolyVec k -> [k*288*8]\n    pack_t1 t1 = join [pack_poly p | p <- t1BV]\n            where\n              t1BV = map (\\p -> map (\\x -> fromInteger x:[9]) p) t1\n\n              pack8 : [8][9] -> [9][8]\n              pack8 xs = map drop`{1} [ xs@0 && zero#0xFF\n                                      , xs@0 >> 8 || ((xs@1 && zero#0x7F) << 1)\n                                      , xs@1 >> 7 || ((xs@2 && zero#0x3F) << 2)\n                                      , xs@2 >> 6 || ((xs@3 && zero#0x1F) << 3)\n                                      , xs@3 >> 5 || ((xs@4 && zero#0x0F) << 4)\n                                      , xs@4 >> 4 || ((xs@5 && zero#0x07) << 5)\n                                      , xs@5 >> 3 || ((xs@6 && zero#0x03) << 6)\n                                      , xs@6 >> 2 || ((xs@7 && zero#0x01) << 7)\n                                      , xs@7 >> 1\n                                      ]\n              pack_poly p = join [join (pack8 xs) | xs <- split p : [32][8][_]]\n\n    \/*pack_sig : (polyVec l, [k][n], poly) -> [SIG_SIZE_PACKED]\n    pack_sig (z, h, c) =\n            where s0 = polyz_pack (z)\n                  s1 = encode (h)\n                  s2 = encode (c)\n    polyz_pack : poly ->[n*qbits]\n    polyz_pack a = [  | i <- [0..n\/2] ] *\/\n\n    \/\/ Only works when n=256\n    PolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [8] -> polyVec dim\n    PolyUniformEtaV rho nonce = [PolyUniformEta rho (nonce + j) | j <- [0..(dim-1)]:[dim][8]]\n\n    PolyUniformEta : [256] -> [8] -> poly\n    PolyUniformEta rho nonce = map (\\x -> eta - x) (map BVtoZ (take`{n} withinEta))\n                   where\n                    seed = rho#nonce\n                    randoms = ((join (SHA3::toBytes (take`{2*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))#zero)\n                    withinEta = randomsInRangeDouble genS (2*eta) randoms\n\n                    genS : [8] -> [2][4]\n                    genS byte = [t0, t1]\n                         where\n                          t0 = drop`{4} (byte && 0x0F)\n                          t1 = drop`{4} (byte >> 4)\n\n    H : ([384],intPolyVec k) -> poly\n    H (mu,w) = map fromInteger (SampleInBall ss samples)\n      where\n        w_packed = pack_w w\n        randoms  = join (SHA3::toBytes (take`{4352} (SHA3::SHAKE256 (join (SHA3::toBytes (mu#w_packed))))))\n        ss       = take`{60}(reverse (join (reverse (split (take`{64} randoms):[8][8]))))\n\n        extByte : [8] -> [8]\n        extByte x = x\n\n        samples : [60][8]\n        samples = take`{60} (randomsInRanges extByte [196..255] (drop`{64} randoms#zero))\n\n    SampleInBall : [60] -> [60][8] -> [256]Integer\n    SampleInBall signs jsamples = ys ! 0\n                  where\n                  ys = [ zero:[256]Integer ]\n                        # [ if i==j then update y i ((-1:Integer)^^(toInteger [s]))\n                            else updates y [j,i] [(-1:Integer)^^(toInteger [s]),y@j] | i <- [196..255]\n                                                                      | j <- jsamples\n                                                                      | s <- signs\n                                                                      | y <- ys\n                          ]\n\n    ExpandMask : ([256], [384], Integer) -> polyVec l\n    ExpandMask  (K, mu, kappa) = [samplePoly K mu kappa i `l | i <- [0..(l-1)] ]\n\n    samplePoly : [256] -> [384] -> Integer -> Integer -> Integer -> poly\n    samplePoly K mu kappa i dim = [fromInteger (`q + gamma1 - 1 - (toInteger vj)) | vj <- coeffs]\n                where\n                upper      = fromInteger (2*gamma1-2) : [20]\n                kappaBytes = join (reverse (split (fromInteger (dim*kappa+i):[16]):[2][8])) \/\/ LEB order\n                s          = join (SHA3::toBytes (take`{5*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes (K#mu#kappaBytes)))))) \/\/ checked\n                coeffs     = take`{n} (randomsInRangeDouble extractPolyElt upper (s#zero))\n\n    extractPolyElt : [40] -> [2][20]\n    extractPolyElt bits = [int1, int2]\n                    where\n                    [b0,b1,b2,b3,b4] = [(zero#b):[20] | b <- split bits : [5][8]]\n                    int1 = b2'*2^^16 + b1*2^^8 +  b0\n                    int2 = b4*2^^12 + b3*2^^4 +  b2''\n                    b2'  = b2 && 15\n                    \/\/b2'' = b2\/(16:[20])\n                    b2'' = b2\/16\n    \/\/ seed should be in little endian byte order\n    CRH : {b} (fin b, b>=1) => [b*8] -> [384]\n    CRH seed = join (SHA3::toBytes (take`{48*8} (SHA3::SHAKE256 (join (SHA3::toBytes seed)))))\n\n    ExpandA : [256] -> [k][l]nttPoly \n    ExpandA rho = [ [elt i j | j <- [0..(l-1)] ] |  i <- [0..(k-1)] ]\n            where\n              elt i j = matrixPoly rho i j\n\n    matrixPoly : [256] -> [width k] -> [width l] -> nttPoly\n    matrixPoly rho i j = take`{n} [ BVtoZ elt | elt <- randomElts ]\n                where\n                randomElts = randomsInRange extractMatElt ((>=) (`q)) (s#zero)\n                s          = join (SHA3::toBytes (take`{6720} (SHA3::SHAKE128 (join (SHA3::toBytes (rho#b))))))\n                b          = 16*(zero#j:[8])+(zero#i:[8])\n\n    extractMatElt : [24] -> [24]\n    extractMatElt rands = zero#(2^^16 * b2' + 2^^8 * b1 + b0):[24]\n                    where\n                      [b0, b1, b2] = [(zero#b):[23] | b <- split`{3} rands]\n                      b2' = (2^^23-1) && b2 \/\/ Typo in paper; following C implementation\n\n    \/*\n\n      Supporting Algorithms; see Figure 3\n\n    *\/\n\n    Power2Round : Integer -> (Integer,Integer) -> (Integer,Integer)\n    Power2Round q (r,d') = ((r'-r0)\/2^^d',r0)\n                where r' = r % q\n                      r0 = centered_mod r' (2^^d')\n\n    Power2RoundV : {dim} (fin dim, dim >= 1) => polyVec dim -> ([dim]intPoly,[dim]intPoly)\n    Power2RoundV v = unzip (map polyPower2Round v)\n                  where\n                  polyPower2Round p = unzip [ Power2Round `q ( (fromZ r ) ,d)\n                                            | r <- p\n                                            ]\n\n    Decompose : Integer -> (Integer,Integer) -> (Integer,Integer)\n    Decompose q (r,a) = if (r' - r0) == (q - 1) then (0, r0 - 1)\n                        else ((r' - r0) \/ a, r0)\n              where r' = r % q\n                    r0 = centered_mod r' a\n\n    DecomposeV : (polyVec k , Integer) -> (intPolyVec k, intPolyVec k)\n    DecomposeV (r,a) = unzip [ DecomposePoly p | p <- r ]\n                where\n                DecomposePoly p = unzip [Decompose `q (fromZ x,a) | x <- p]\n\n    HighBits : Integer -> (Integer,Integer) -> Integer\n    HighBits q (r,a) = (Decompose q (r,a)).0\n\n    HighBitsV : (polyVec k , Integer) -> intPolyVec k\n    HighBitsV (r,a) = r1\n              where\n                (r1,r0) = DecomposeV (r,a)\n\n    LowBits : Integer -> (Integer,Integer) -> Integer\n    LowBits q (r,a) = (Decompose q (r,a)).1\n\n    MakeHint : Integer -> (Integer,Integer,Integer) -> Bit\n    MakeHint q (z,r,a) = r1 != v1\n              where r1 = HighBits q (r,a)\n                    v1 = HighBits q (r + z,a)\n\n    MakeHintV : (polyVec k, polyVec k, Integer) -> [k][n]\n    MakeHintV (z,r,a) = [[x1 != x2 | x1 <- p1 | x2 <- p2] | p1 <- r1 | p2 <- v1]\n              where\n                r1 = HighBitsV (r,a)\n                v1 = HighBitsV (polyVecSum z r,a)\n\n    UseHint : Integer -> (Bit,Integer,Integer) -> Integer\n    UseHint q (h,r,a) = if h then r1' else r1\n            where\n              m        = (q - 1) \/ a\n              (r1, r0) = Decompose q (r, a)\n              r1'      = if r0 > 0 then (r1 + 1) % m else (r1 - 1) % m\n\n    UseHintV : ([k][n], polyVec k, Integer) -> intPolyVec k\n    UseHintV (hvec, rvec, a) = [polyUseHint hpoly rpoly\n                                  | hpoly <- hvec\n                                  | rpoly <- rvec\n                                  ]\n                where\n                polyUseHint hpoly rpoly = [ UseHint `q (h,fromZ r,a)\n                                          | h <- hpoly\n                                          | r <- rpoly\n                                          ]\n\n    \/*\n\n      Utility functions\n\n    *\/\n\n    ones : {a} (fin a, a >= 1) => [a] -> Integer\n    ones bv = foldl (+) 0 bva\n          where\n          bva = map toInteger (split bv:[_][1])\n\n    IPVtoPV : {dim} (fin dim, dim >= 1) => intPolyVec dim -> polyVec dim\n    IPVtoPV intp = map (\\p -> map fromInteger p) intp\n\n    PVtoIPV : {dim} (fin dim, dim >= 1) => polyVec dim -> intPolyVec dim\n    PVtoIPV pvec = map (\\p -> map fromZ p) pvec\n\n    centered_mod : Integer -> Integer -> Integer\n    centered_mod x n = if r > (n\/2) then r - n\n                        else r\n                  where r = x % n\n\n    randomsInRange : {a} (fin a) => ([a]-> [a]) -> ([a] -> Bit) -> [inf] -> [inf][a]\n    randomsInRange createElt upperCrit randoms = if (upperCrit elt )\n                                    then  [ elt ]#(randomsInRange createElt upperCrit randomTail)\n                                    else randomsInRange createElt upperCrit randomTail\n                                    where\n                                    elt        = createElt (take`{a} randoms) \n                                    randomTail = drop`{a} randoms\n\n    randomsInRanges : {a,m} (fin a,fin m, m>=1) => ([a]-> [a]) -> [m][a] -> [inf] -> [inf][a]\n    randomsInRanges createElt uppers randoms =\n                    if elt <= head uppers\n                    then  [ elt ]#(randomsInRanges createElt uppersRotate randomTail)\n                    else randomsInRanges createElt uppers randomTail\n                    where\n                      elt          = createElt (take`{a} randoms) \n                      randomTail   = drop`{a} randoms\n                      uppersRotate = uppers <<< 1\n\n    randomsInRangeDouble : {a} (fin a) => ([2*a]-> [2][a]) -> [a] -> [inf] -> [inf][a]\n\/\/wrong code\n    \/*randomsInRangeDouble createElt upper randoms =\n                    if (elts@0 <= upper) \/\\ (elts@1 <= upper)\n                    then  elts#(randomsInRangeDouble createElt upper randomTail)\n                    else\n                      if (elts@0 <= upper)\n                      then [ elts@0 ]#(randomsInRangeDouble createElt upper randomTail)\n                      else\n                        if (elts@1 <= upper)\n                        then [ elts@1 ]#(randomsInRangeDouble createElt upper randomTail)\n                        else randomsInRangeDouble createElt upper randomTail\n                    where\n                      elts       = createElt (take`{2*a} randoms) \n                      randomTail = drop`{2*a} randoms*\/\n\/\/ Correction and checked with the C code\n    randomsInRangeDouble createElt upper randoms =\n                    if (elts@1 <= upper) then [elts@1, elts@1] # (randomsInRangeDouble createElt upper randomTail)\n                    else (randomsInRangeDouble createElt upper randomTail)\n                    where\n                    elts       = createElt (take`{2*a} randoms)\n                    randomTail = drop`{2*a} randoms\n\n    \/*\n\n      Supporting polynomial and polynomial vector functions\n\n    *\/\n\n    ntt : poly -> nttPoly\n    ntt p = nttp\n         where\n          r k = rootOfUnity^^k\n          exponents = join [ [BVtoZ`{q} i, (256+(BVtoZ`{q} i))] | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n          nttp = [ sum [ p@idx * (r k)^^(i) | idx<-[0..(n-1)]:[n][width n] | i<-[0..(n-1)]:[n](Z q)]\n                 | k <- exponents \n                 ]\n\n    nttinv : nttPoly -> poly\n    nttinv p' = p\n           where\n            pu = reorder p'\n            r' i = rootOfUnityInv^^(i*2)\n            p = [ninv*(rootOfUnityInv^^i) * sum [pu@jdx * (r' ((i*j)))\n                                                    | jdx<-[0..(n-1)]:[n][width n]\n                                                    | j<-[0..(n-1)]:[n](Z q)\n                                                    ]\n                | i <- [0..255]\n                ]\n\n    \/\/ Dilithium uses a non-standard ordering of elements in the NTT domain; this function reorders the elements.\n    reorder : nttPoly -> nttPoly\n    reorder a = join [ [a1 @ i, a2 @ i] | i <- [0..127]:[_][8] ]\n            where\n              a1 = a @@ [ (i-1)\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n              a2 = reverse (a @@ [ (511 - (zero#i):[9])\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ])\n\n    \/\/ Operations on NTT polynomials\n\n    nttMatMul : {dim1,dim2} (fin dim1,fin dim2) => nttMat dim1 dim2 -> nttVec dim2 -> nttVec dim1\n    nttMatMul mat vec = [ nttDotProduct v vec | v <- mat ]\n\n    nttDotProduct : {dim} (fin dim) => nttVec dim -> nttVec dim -> nttPoly\n    nttDotProduct v1 v2 = foldl padd (zero:nttPoly) [ nttPolyMult p1 p2 | p1 <- v1 | p2 <- v2 ]\n\n    nttPolyMult : nttPoly -> nttPoly -> nttPoly\n    nttPolyMult p1 p2 = [ x * y | x <- p1 | y <- p2]\n\n    nttVecConstMul : {dim} (fin dim) => nttPoly -> nttVec dim -> nttVec dim\n    nttVecConstMul c v = map (nttPolyMult c) v\n\n    polyVecSum :  {dim} (fin dim) => polyVec dim -> polyVec dim -> polyVec dim\n    polyVecSum v1 v2 = map nttinv (paddV v1' v2')\n                where\n                v1' = map ntt v1\n                v2' = map ntt v2\n\n    \/\/ Polynomial addition and subtraction\n    padd : [n](Z q) -> [n](Z q) -> [n](Z q)\n    padd p1 p2 = [ x + y | x <- p1 | y <- p2 ]\n\n    psub : [n](Z q) -> [n](Z q) -> [n](Z q)\n    psub p1 p2 = [ x - y | x <- p1 | y <- p2 ]\n\n    psubV : {dim} (fin dim) => [dim][n](Z q) -> [dim][n](Z q) -> [dim][n](Z q)\n    psubV v1 v2 = zipWith psub v1 v2\n\n    paddV : {dim} (fin dim) => [dim][n](Z q) -> [dim][n](Z q) -> [dim][n](Z q)\n    paddV v1 v2 = zipWith padd v1 v2\n\n    \/\/ Aux functions\n\n    infNorm : Integer -> Integer\n    infNorm x = abs (centered_mod x `q)\n\n    infNormPoly : intPoly -> Integer\n    infNormPoly p = foldl max 0 p_centered\n                where\n                  p_centered = map infNorm p\n\n    infNormPolyVec : {dim} (fin dim, dim>=1) => intPolyVec dim -> Integer\n    infNormPolyVec v = foldl max 0 (map infNormPoly v)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/ECDSA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that fully specifies the ECDSA signature scheme over a short Weierstrass curve, including sign, private_to_public, verify, point compression\/decompression, scalar and joint scalar multiplication, and properties like decompress_correct and mp_mod_sqrt_correct."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\nimport Common::utils\n\nsign : Z q -> Z q -> Z p -> (Z q, Z q)\nsign d z k = (r, s)\n  where {x = x1, y = _} = ec_affinify (ec_mult k G)\n        r = ZtoZ x1\n        s = (mp_mod_inv (ZtoZ k)) * (z + r*d)\n\nprivate_to_public : Z q -> ProjectivePoint p\nprivate_to_public d = ec_mult (ZtoZ d) G\n\nverify : Z q -> ProjectivePoint p -> (Z q, Z q) -> Bit\nverify z Q (r, s) = r == ZtoZ j\n  where w = mp_mod_inv s\n        u1 = z * w\n        u2 = r * w\n        {x = x1, y = _, z = z1} = ec_twin_mult (ZtoZ u1) G (ZtoZ u2) Q\n        j = x1 * (mp_mod_inv z1)^^2\n\nG_compress R = ec_compress (ec_affinify G) == R\n\nfull_add_example : AffinePoint p -> AffinePoint p -> AffinePoint p -> Bit\nfull_add_example R S T =\n  ec_affinify (ec_full_add (ec_projectify S) (ec_projectify T)) == R\n\nfull_subtract_example : AffinePoint p -> AffinePoint p -> AffinePoint p -> Bit\nfull_subtract_example R S T =\n  ec_affinify (ec_full_sub (ec_projectify S) (ec_projectify T)) == R\n\ndouble_example : AffinePoint p -> AffinePoint p -> Bit\ndouble_example R S =\n  ec_affinify (ec_double (ec_projectify S)) == R\n\nscalar_multiply_example : AffinePoint p -> AffinePoint p -> Z p -> Bit\nscalar_multiply_example R S d =\n  ec_affinify (ec_mult d (ec_projectify S)) == R\n\njoint_scalar_multiply_example : AffinePoint p -> AffinePoint p -> AffinePoint p -> Z p -> Z p -> Bit\njoint_scalar_multiply_example R S T d e =\n  ec_affinify (ec_twin_mult d (ec_projectify S) e (ec_projectify T)) == R\n\nmp_mod_sqrt_correct x = (mp_mod_sqrt (x ^^ 2)) ^^ 2 == (x ^^ 2)\n\naffine_decompress_correct : AffinePoint p -> Bit\naffine_decompress_correct R = ~err \/\\ R == R'\n  where\n    (R',err) = ec_decompress (ec_compress`{width p+2} R)\n\ndecompress_correct : Z p -> Bit\nproperty decompress_correct k = affine_decompress_correct (ec_affinify (ec_mult k G))\n\nparameter\n\n  type p : #\n  type constraint Constraints p\n\n  b : Z p\n\n  G : ProjectivePoint p\n\n  type q : #\n  type constraint Constraints q\n\n  mp_mod_sqrt : Z p -> Z p\n\nprivate\n\n  type constraint Constraints a = (fin a, isOdd a, a >= 4)\n\n  type AffinePoint a = {x : Z a, y : Z a}\n  type ProjectivePoint a = {x : Z a, y : Z a, z : Z a}\n\n  ec_projectify : {a} (Constraints a) => AffinePoint a -> ProjectivePoint a\n  ec_projectify S = {x = S.x, y = S.y, z = 1}\n\n  ec_affinify : {a} (Constraints a) => ProjectivePoint a -> AffinePoint a\n  ec_affinify S = if S.z == 0 then error \"Cannot affinify the point at infinity\"\n                  else {x = lambda^^2 * S.x, y =  lambda^^3 * S.y}\n    where\n      lambda = mp_mod_inv S.z\n\n  ec_compress : {r} (fin r, r >= width p + 2) => AffinePoint p -> [r]\n  ec_compress S = (2 + (Sy % 2)) # Sx\n    where Sx = ZtoBV S.x : [width p]\n          Sy = ZtoBV S.y : [r - width p]\n\n  ec_decompress : {a} (fin a, a >= width p + 2) => [a] -> (AffinePoint p, Bit)\n  ec_decompress S = ({x = Rx, y = Ry}, err)\n    where c  = toInteger (take S : [2])\n          Rx = BVtoZ (drop S : [a-2])\n          t0 = Rx ^^ 3 - (mul3 Rx) + b\n          t1 = mp_mod_sqrt t0\n          err = t1 ^^ 2 != t0\n          Ry = if (fromZ t1)%2 == c%2 then t1 else -t1\n\n  ec_is_point_affine : AffinePoint p -> Bit\n  ec_is_point_affine S = S.y ^^ 2 == t\n    where t = S.x ^^ 3 - (mul3 S.x) + b\n\n  ec_double : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a\n  ec_double S =\n    if S.z == 0 then\n      {x = 1, y = 1, z = 0}             \n    else\n      {x = r18, y = r23, z = r13}\n    where r7  = S.z ^^ 2                \n          r8  = S.x - r7                \n          r9  = S.x + r7                \n          r10 = r9 * r8                 \n          r11 = mul3 r10                \n          r12 = S.z * S.y               \n          r13 = mul2 r12                \n          r14 = S.y ^^ 2                \n          r15 = S.x * r14               \n          r16 = mul4 r15                \n          r17 = r11 ^^ 2                \n          r18 = r17 - (mul2 r16)        \n          r19 = r14 ^^ 2                \n          r20 = mul8 r19                \n          r21 = r16 - r18               \n          r22 = r11 * r21               \n          r23 = r22 - r20               \n\n  ec_add : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a -> ProjectivePoint a\n  ec_add S T =\n    if r13 == 0 then\n      if r14 == 0 then\n        {x = 0, y = 0, z = 0}      \n      else\n        {x = 1, y = 1, z = 0}      \n    else\n      {x = r32, y = r37, z = r27}\n    where r9  = S.z ^^ 2           \n          r10 = T.x * r9           \n          r11 = S.z * r9           \n          r12 = T.y * r11          \n          r13 = S.x - r10          \n          r14 = S.y - r12          \n\n          r22 = mul2 S.x - r13     \n          r23 = mul2 S.y - r14     \n\n          r27 = S.z * r13          \n          r28 = r13 ^^ 2           \n          r29 = r13 * r28          \n          r30 = r22 * r28          \n          r31 = r14 ^^ 2           \n          r32 = r31 - r30          \n          r33 = r30 - (mul2 r32)   \n          r34 = r14 * r33          \n          r35 = r23 * r29          \n          r36 = r34 - r35          \n          r37 = half r36           \n\n  ec_full_add : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a -> ProjectivePoint a\n  ec_full_add S T = \n    if S.z == 0 then T\n     | T.z == 0 then S\n     | R == {x = 0, y = 0, z = 0} then ec_double S\n     else R\n    where R = ec_add S T\n\n  ec_full_sub : {a} (Constraints a) => ProjectivePoint a -> ProjectivePoint a -> ProjectivePoint a\n  ec_full_sub S T = R\n    where U = {x = T.x, y = -T.y, z = T.z}\n          R = ec_full_add S U\n\n  ec_mult : {a} (Constraints a) => Z a -> ProjectivePoint a -> ProjectivePoint a\n  ec_mult d S = if d == 0 then {x = 1, y = 1, z = 0}\n                 | d == 1 then S\n                 | S.z == 0 then {x = 1, y = 1, z = 0}\n                 else Rs!1\n    where S' = if S.z != 1 then ec_projectify (ec_affinify S) else S\n          k = ZtoBV d : [width a + 2]\n          h = k + k + k\n          Rs = [{x = 1, y = 1, z = 0}] # \/\/Here we start with 1 instead of S because we don't really know where the high-bit is\n               [ if hi && ~ki then ec_full_add RiDouble S\n                  | ~hi && ki then ec_full_sub RiDouble S\n                  else RiDouble\n                 where RiDouble = ec_double Ri\n               | ki <- k | hi <- h | Ri <- Rs ]\n\n  F : [5] -> [5]\n  F t = if (18 <= t) && (t < 22) then 9\n         | (14 <= t) && (t < 18) then 10\n         | (22 <= t) && (t < 24) then 11\n         | (4 <= t)  && (t < 12) then 14\n         else 12\n\n  ec_twin_mult : {a} (Constraints a) => Z a -> ProjectivePoint a -> Z a -> ProjectivePoint a -> ProjectivePoint a\n  ec_twin_mult d0 S d1 T = (states!0).0\n    where Sp = if S.z != 1 then ec_projectify (ec_affinify S) else S\n          Tp = if T.z != 1 then ec_projectify (ec_affinify T) else T\n          SpT = ec_full_add Sp Tp\n          SpTp = if SpT.z != 1 then ec_projectify (ec_affinify SpT) else SpT\n          SmT = ec_full_sub Sp Tp\n          SmTp = if SmT.z != 1 then ec_projectify (ec_affinify SmT) else SmT\n          e0  = ZtoBV d0 : [max 4 (width a)]\n          e1  = ZtoBV d1 : [max 4 (width a)]\n          c   = [[False, False] # take e0,\n                 [False, False] # take e1] : [2][6]\n          states = [({x = 1, y = 1, z = 0}, c)] #\n                   [ (Rk', [c0', c1'])\n                     where h0 = if c0@0 then 31 - tail c0 else tail c0\n                           h1 = if c1@0 then 31 - tail c1 else tail c1\n                           u0 = if h0 < (F h1) then 0 else if c0@0 then -1 else 1 : [2]\n                           u1 = if h1 < (F h0) then 0 else if c1@0 then -1 else 1 : [2]\n                           c0' = [(u0!=0) ^ c0@1] # drop c0 # [e0k]\n                           c1' = [(u1!=0) ^ c1@1] # drop c1 # [e1k]\n                           Rk' = if (u0 == -1) && (u1 == -1) then ec_full_sub RkDouble SpTp\n                                  | (u0 == -1) && (u1 ==  0) then ec_full_sub RkDouble Sp\n                                  | (u0 == -1) && (u1 ==  1) then ec_full_sub RkDouble SmTp\n                                  | (u0 ==  0) && (u1 == -1) then ec_full_sub RkDouble Tp\n                                  | (u0 ==  0) && (u1 ==  1) then ec_full_add RkDouble Tp\n                                  | (u0 ==  1) && (u1 == -1) then ec_full_add RkDouble SmTp\n                                  | (u0 ==  1) && (u1 ==  0) then ec_full_add RkDouble Sp\n                                  | (u0 ==  1) && (u1 ==  1) then ec_full_add RkDouble SpTp\n                                  else RkDouble\n                           RkDouble = ec_double Rk\n                   | (Rk, [c0, c1]) <- states\n                   | e0k <- drop`{4} e0 # (zero : [5])\n                   | e1k <- drop`{4} e1 # (zero : [5]) ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the NIST P-256 curve parameters and implement the modular square root function mp_mod_sqrt : Z p -> Z p for ECDSA over P-256, along with suitable Cryptol properties to verify its correctness over the field defined by p and base point G."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::p256 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\ntype p = 115792089210356248762697446949407573530086143415290314195533631308867097853951\n\nb = 41058363725152142129326129780047268409114441015993725554835256314039467401291\n\nG = {x = 48439561293906451759052585252797914202762949526041747995844080717082404635286,\n     y = 36134250956749795798585127919587881956611106672985015071877198253568414405109,\n     z = 1}\n\ntype q = 115792089210356248762697446949407573529996955224135760342422259061068512044369\n\nmp_mod_sqrt : Z p -> Z p\nmp_mod_sqrt c = r'' ^^ (2 ^^ 94)\n  where t1  = (c ^^ 2) * c\n        t2  = (t1 ^^ (2 ^^ 2)) * t1\n        t3  = (t2 ^^ (2 ^^ 4)) * t2\n        t4  = (t3 ^^ (2 ^^ 8)) * t3\n        r   = (t4 ^^ (2 ^^ 16)) * t4\n        r'  = (r ^^ (2 ^^ 32)) * c\n        r'' = (r' ^^ (2 ^^ 96)) * c\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/ECDSA_tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module of ECDSA test properties over NIST curves p192, p224, p256, p384, and p521 that checks example point decompression, point addition, subtraction, doubling, scalar and joint scalar multiplication, base point compression, and mp_mod_sqrt correctness, matching the constants and structure indicated."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::ECDSA_tests where\n\nimport Common::utils\n\nimport Primitive::Asymmetric::Signature::ECDSA::p192 as p192\nimport Primitive::Asymmetric::Signature::ECDSA::p224 as p224\nimport Primitive::Asymmetric::Signature::ECDSA::p256 as p256\nimport Primitive::Asymmetric::Signature::ECDSA::p384 as p384\nimport Primitive::Asymmetric::Signature::ECDSA::p521 as p521\n\nproperty p192_G_compress = p192::G_compress 0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\n\np192_S = {x = BVtoZ 0xd458e7d127ae671b0c330266d246769353a012073e97acf8,\n          y = BVtoZ 0x325930500d851f336bddc050cf7fb11b5673a1645086df3b}\n\np192_T = {x = BVtoZ 0xf22c4395213e9ebe67ddecdd87fdbd01be16fb059b9753a4,\n          y = BVtoZ 0x264424096af2b3597796db48f8dfb41fa9cecc97691a9c79}\n\nproperty p192_decompress_S = p192::affine_decompress_correct p192_S\nproperty p192_decompress_T = p192::affine_decompress_correct p192_T\n\nproperty p192_full_add_example =\n  p192::full_add_example R p192_S p192_T\n  where R = {x = BVtoZ 0x48e1e4096b9b8e5ca9d0f1f077b8abf58e843894de4d0290,\n             y = BVtoZ 0x408fa77c797cd7dbfb16aa48a3648d3d63c94117d7b6aa4b}\n\nproperty p192_full_subtract_example =\n  p192::full_subtract_example R p192_S p192_T\n  where R = {x = BVtoZ 0xfc9683cc5abfb4fe0cc8cc3bc9f61eabc4688f11e9f64a2e,\n             y = BVtoZ 0x093e31d00fb78269732b1bd2a73c23cdd31745d0523d816b}\n\nproperty p192_double_example =\n  p192::double_example R p192_S\n  where R = {x = BVtoZ 0x30c5bc6b8c7da25354b373dc14dd8a0eba42d25a3f6e6962,\n             y = BVtoZ 0x0dde14bc4249a721c407aedbf011e2ddbbcb2968c9d889cf}\n\nproperty p192_scalar_multiply_example0 =\n  p192::scalar_multiply_example R p192_S d\n  where d = BVtoZ 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        R = {x = BVtoZ 0x1faee4205a4f669d2d0a8f25e3bcec9a62a6952965bf6d31,\n             y = BVtoZ 0x5ff2cdfa508a2581892367087c696f179e7a4d7e8260fb06}\n\np192_S' = {x = BVtoZ 0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012,\n           y = BVtoZ 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811}\n\nproperty p192_scalar_multiply_example1=\n    p192::scalar_multiply_example R p192_S' d\n    where d = BVtoZ 0xe14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3\n          R = {x = BVtoZ 0x07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6,\n               y = BVtoZ 0x76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477}\n\nproperty p192_joint_scalar_multiply_example =\n  p192::joint_scalar_multiply_example R p192_S p192_T d e\n  where d = BVtoZ 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee\n        e = BVtoZ 0xc4be3d53ec3089e71e4de8ceab7cce889bc393cd85b972bc\n        R = {x = BVtoZ 0x019f64eed8fa9b72b7dfea82c17c9bfa60ecb9e1778b5bde,\n             y = BVtoZ 0x16590c5fcd8655fa4ced33fb800e2a7e3c61f35d83503644}\n\nproperty mp_mod_sqrt_192_correct = p192::mp_mod_sqrt_correct\n\nproperty p224_G_compress = p224::G_compress 0x00000002b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\n\np224_S = {x = BVtoZ 0x6eca814ba59a930843dc814edd6c97da95518df3c6fdf16e9a10bb5b,\n          y = BVtoZ 0xef4b497f0963bc8b6aec0ca0f259b89cd80994147e05dc6b64d7bf22}\n\np224_T = {x = BVtoZ 0xb72b25aea5cb03fb88d7e842002969648e6ef23c5d39ac903826bd6d,\n          y = BVtoZ 0xc42a8a4d34984f0b71b5b4091af7dceb33ea729c1a2dc8b434f10c34}\n\nproperty p224_full_add_example =\n  p224::full_add_example R p224_S p224_T\n  where R = {x = BVtoZ 0x236f26d9e84c2f7d776b107bd478ee0a6d2bcfcaa2162afae8d2fd15,\n             y = BVtoZ 0xe53cc0a7904ce6c3746f6a97471297a0b7d5cdf8d536ae25bb0fda70}\n\nproperty p224_full_subtract_example =\n  p224::full_subtract_example R p224_S p224_T\n  where R = {x = BVtoZ 0xdb4112bcc8f34d4f0b36047bca1054f3615413852a7931335210b332,\n             y = BVtoZ 0x90c6e8304da4813878c1540b2396f411facf787a520a0ffb55a8d961}\n\nproperty p224_double_example =\n  p224::double_example R p224_S\n  where R = {x = BVtoZ 0xa9c96f2117dee0f27ca56850ebb46efad8ee26852f165e29cb5cdfc7,\n             y = BVtoZ 0xadf18c84cf77ced4d76d4930417d9579207840bf49bfbf5837dfdd7d}\n\nproperty p224_scalar_multiply_example =\n  p224::scalar_multiply_example R p224_S d\n  where d = BVtoZ 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        R = {x = BVtoZ 0x96a7625e92a8d72bff1113abdb95777e736a14c6fdaacc392702bca4,\n             y = BVtoZ 0x0f8e5702942a3c5e13cd2fd5801915258b43dfadc70d15dbada3ed10}\n\nproperty p224_joint_scalar_multiply_example =\n  p224::joint_scalar_multiply_example R p224_S p224_T d e\n  where d = BVtoZ 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b\n        e = BVtoZ 0x54d549ffc08c96592519d73e71e8e0703fc8177fa88aa77a6ed35736\n        R = {x = BVtoZ 0xdbfe2958c7b2cda1302a67ea3ffd94c918c5b350ab838d52e288c83e,\n             y = BVtoZ 0x2f521b83ac3b0549ff4895abcc7f0c5a861aacb87acbc5b8147bb18b}\n\nproperty mp_mod_sqrt_224_correct = p224::mp_mod_sqrt_correct\n\nproperty p256_G_compress = p256::G_compress 0x000000036b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\n\np256_S = {x = BVtoZ 0xde2444bebc8d36e682edd27e0f271508617519b3221a8fa0b77cab3989da97c9,\n          y = BVtoZ 0xc093ae7ff36e5380fc01a5aad1e66659702de80f53cec576b6350b243042a256}\n\np256_T = {x = BVtoZ 0x55a8b00f8da1d44e62f6b3b25316212e39540dc861c89575bb8cf92e35e0986b,\n          y = BVtoZ 0x5421c3209c2d6c704835d82ac4c3dd90f61a8a52598b9e7ab656e9d8c8b24316}\n\nproperty p256_full_add_example =\n  p256::full_add_example R p256_S p256_T\n  where R = {x = BVtoZ 0x72b13dd4354b6b81745195e98cc5ba6970349191ac476bd4553cf35a545a067e,\n             y = BVtoZ 0x8d585cbb2e1327d75241a8a122d7620dc33b13315aa5c9d46d013011744ac264}\n\nproperty p256_full_subtract_example =\n  p256::full_subtract_example R p256_S p256_T\n  where R = {x = BVtoZ 0xc09ce680b251bb1d2aad1dbf6129deab837419f8f1c73ea13e7dc64ad6be6021,\n             y = BVtoZ 0x1a815bf700bd88336b2f9bad4edab1723414a022fdf6c3f4ce30675fb1975ef3}\n\nproperty p256_double_example =\n  p256::double_example R p256_S\n  where R = {x = BVtoZ 0x7669e6901606ee3ba1a8eef1e0024c33df6c22f3b17481b82a860ffcdb6127b0,\n             y = BVtoZ 0xfa878162187a54f6c39f6ee0072f33de389ef3eecd03023de10ca2c1db61d0c7}\n\nproperty p256_scalar_multiply_example =\n  p256::scalar_multiply_example R p256_S d\n  where d = BVtoZ 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        R = {x = BVtoZ 0x51d08d5f2d4278882946d88d83c97d11e62becc3cfc18bedacc89ba34eeca03f,\n             y = BVtoZ 0x75ee68eb8bf626aa5b673ab51f6e744e06f8fcf8a6c0cf3035beca956a7b41d5}\n\nproperty p256_joint_scalar_multiply_example =\n  p256::joint_scalar_multiply_example R p256_S p256_T d e\n  where d = BVtoZ 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd\n        e = BVtoZ 0xd37f628ece72a462f0145cbefe3f0b355ee8332d37acdd83a358016aea029db7\n        R = {x = BVtoZ 0xd867b4679221009234939221b8046245efcf58413daacbeff857b8588341f6b8,\n             y = BVtoZ 0xf2504055c03cede12d22720dad69c745106b6607ec7e50dd35d54bd80f615275}\n\nproperty mp_mod_sqrt_256_correct = p256::mp_mod_sqrt_correct\n\nproperty p384_G_compress = p384::G_compress 0x00000003aa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\n\np384_S = {x = BVtoZ 0xfba203b81bbd23f2b3be971cc23997e1ae4d89e69cb6f92385dda82768ada415ebab4167459da98e62b1332d1e73cb0e,\n          y = BVtoZ 0x5ffedbaefdeba603e7923e06cdb5d0c65b22301429293376d5c6944e3fa6259f162b4788de6987fd59aed5e4b5285e45}\n\np384_T = {x = BVtoZ 0xaacc05202e7fda6fc73d82f0a66220527da8117ee8f8330ead7d20ee6f255f582d8bd38c5a7f2b40bcdb68ba13d81051,\n          y = BVtoZ 0x84009a263fefba7c2c57cffa5db3634d286131afc0fca8d25afa22a7b5dce0d9470da89233cee178592f49b6fecb5092}\n\nproperty p384_full_add_example =\n  p384::full_add_example R p384_S p384_T\n  where R = {x = BVtoZ 0x12dc5ce7acdfc5844d939f40b4df012e68f865b89c3213ba97090a247a2fc009075cf471cd2e85c489979b65ee0b5eed,\n             y = BVtoZ 0x167312e58fe0c0afa248f2854e3cddcb557f983b3189b67f21eee01341e7e9fe67f6ee81b36988efa406945c8804a4b0}\n\nproperty p384_full_subtract_example =\n  p384::full_subtract_example R p384_S p384_T\n  where R = {x = BVtoZ 0x6afdaf8da8b11c984cf177e551cee542cda4ac2f25cd522d0cd710f88059c6565aef78f6b5ed6cc05a6666def2a2fb59,\n             y = BVtoZ 0x7bed0e158ae8cc70e847a60347ca1548c348decc6309f48b59bd5afc9a9b804e7f7876178cb5a7eb4f6940a9c73e8e5e}\n\nproperty p384_double_example =\n  p384::double_example R p384_S\n  where R = {x = BVtoZ 0x2a2111b1e0aa8b2fc5a1975516bc4d58017ff96b25e1bdff3c229d5fac3bacc319dcbec29f9478f42dee597b4641504c,\n             y = BVtoZ 0xfa2e3d9dc84db8954ce8085ef28d7184fddfd1344b4d4797343af9b5f9d837520b450f726443e4114bd4e5bdb2f65ddd}\n\nproperty p384_scalar_multiply_example =\n  p384::scalar_multiply_example R p384_S d\n  where d = BVtoZ 0xa4ebcae5a665983493ab3e626085a24c104311a761b5a8fdac052ed1f111a5c44f76f45659d2d111a61b5fdd97583480\n        R = {x = BVtoZ 0xe4f77e7ffeb7f0958910e3a680d677a477191df166160ff7ef6bb5261f791aa7b45e3e653d151b95dad3d93ca0290ef2,\n             y = BVtoZ 0xac7dee41d8c5f4a7d5836960a773cfc1376289d3373f8cf7417b0c6207ac32e913856612fc9ff2e357eb2ee05cf9667f}\n\nproperty p384_joint_scalar_multiply_example =\n  p384::joint_scalar_multiply_example R p384_S p384_T d e\n  where d = BVtoZ 0xa4ebcae5a665983493ab3e626085a24c104311a761b5a8fdac052ed1f111a5c44f76f45659d2d111a61b5fdd97583480\n        e = BVtoZ 0xafcf88119a3a76c87acbd6008e1349b29f4ba9aa0e12ce89bcfcae2180b38d81ab8cf15095301a182afbc6893e75385d\n        R = {x = BVtoZ 0x917ea28bcd641741ae5d18c2f1bd917ba68d34f0f0577387dc81260462aea60e2417b8bdc5d954fc729d211db23a02dc,\n             y = BVtoZ 0x1a29f7ce6d074654d77b40888c73e92546c8f16a5ff6bcbd307f758d4aee684beff26f6742f597e2585c86da908f7186}\n\nproperty mp_mod_sqrt_384_correct = p384::mp_mod_sqrt_correct\n\nproperty p521_G_compress = p521::G_compress 0x04c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\n\np521_S = {x = BVtoZ 0x000001d5c693f66c08ed03ad0f031f937443458f601fd098d3d0227b4bf62873af50740b0bb84aa157fc847bcf8dc16a8b2b8bfd8e2d0a7d39af04b089930ef6dad5c1b4,\n          y = BVtoZ 0x00000144b7770963c63a39248865ff36b074151eac33549b224af5c8664c54012b818ed037b2b7c1a63ac89ebaa11e07db89fcee5b556e49764ee3fa66ea7ae61ac01823}\n\np521_T = {x = BVtoZ 0x000000f411f2ac2eb971a267b80297ba67c322dba4bb21cec8b70073bf88fc1ca5fde3ba09e5df6d39acb2c0762c03d7bc224a3e197feaf760d6324006fe3be9a548c7d5,\n          y = BVtoZ 0x000001fdf842769c707c93c630df6d02eff399a06f1b36fb9684f0b373ed064889629abb92b1ae328fdb45534268384943f0e9222afe03259b32274d35d1b9584c65e305}\n\nproperty p521_full_add_example =\n  p521::full_add_example R p521_S p521_T\n  where R = {x = BVtoZ 0x000001264ae115ba9cbc2ee56e6f0059e24b52c8046321602c59a339cfb757c89a59c358a9a8e1f86d384b3f3b255ea3f73670c6dc9f45d46b6a196dc37bbe0f6b2dd9e9,\n             y = BVtoZ 0x00000062a9c72b8f9f88a271690bfa017a6466c31b9cadc2fc544744aeb817072349cfddc5ad0e81b03f1897bd9c8c6efbdf68237dc3bb00445979fb373b20c9a967ac55}\n\nproperty p521_full_subtract_example =\n  p521::full_subtract_example R p521_S p521_T\n  where R = {x = BVtoZ 0x000001292cb58b1795ba477063fef7cd22e42c20f57ae94ceaad86e0d21ff22918b0dd3b076d63be253de24bc20c6da290fa54d83771a225deecf9149f79a8e614c3c4cd,\n             y = BVtoZ 0x000001695e3821e72c7cacaadcf62909cd83463a21c6d03393c527c643b36239c46af117ab7c7ad19a4c8cf0ae95ed51729885461aa2ce2700a6365bca3733d2920b2267}\n\nproperty p521_double_example =\n  p521::double_example R p521_S\n  where R = {x = BVtoZ 0x0000012879442f2450c119e7119a5f738be1f1eba9e9d7c6cf41b325d9ce6d643106e9d61124a91a96bcf201305a9dee55fa79136dc700831e54c3ca4ff2646bd3c36bc6,\n             y = BVtoZ 0x0000019864a8b8855c2479cbefe375ae553e2393271ed36fadfc4494fc0583f6bd03598896f39854abeae5f9a6515a021e2c0eef139e71de610143f53382f4104dccb543}\n\nproperty p521_scalar_multiply_example =\n  p521::scalar_multiply_example R p521_S d\n  where d = BVtoZ 0x000001eb7f81785c9629f136a7e8f8c674957109735554111a2a866fa5a166699419bfa9936c78b62653964df0d6da940a695c7294d41b2d6600de6dfcf0edcfc89fdcb1\n        R = {x = BVtoZ 0x00000091b15d09d0ca0353f8f96b93cdb13497b0a4bb582ae9ebefa35eee61bf7b7d041b8ec34c6c00c0c0671c4ae063318fb75be87af4fe859608c95f0ab4774f8c95bb,\n             y = BVtoZ 0x00000130f8f8b5e1abb4dd94f6baaf654a2d5810411e77b7423965e0c7fd79ec1ae563c207bd255ee9828eb7a03fed565240d2cc80ddd2cecbb2eb50f0951f75ad87977f}\n\nproperty p521_joint_scalar_multiply_example =\n  p521::joint_scalar_multiply_example R p521_S p521_T d e\n  where d = BVtoZ 0x000001eb7f81785c9629f136a7e8f8c674957109735554111a2a866fa5a166699419bfa9936c78b62653964df0d6da940a695c7294d41b2d6600de6dfcf0edcfc89fdcb1\n        e = BVtoZ 0x00000137e6b73d38f153c3a7575615812608f2bab3229c92e21c0d1c83cfad9261dbb17bb77a63682000031b9122c2f0cdab2af72314be95254de4291a8f85f7c70412e3\n        R = {x = BVtoZ 0x0000009d3802642b3bea152beb9e05fba247790f7fc168072d363340133402f2585588dc1385d40ebcb8552f8db02b23d687cae46185b27528adb1bf9729716e4eba653d,\n             y = BVtoZ 0x0000000fe44344e79da6f49d87c1063744e5957d9ac0a505bafa8281c9ce9ff25ad53f8da084a2deb0923e46501de5797850c61b229023dd9cf7fc7f04cd35ebb026d89d}\n\nproperty mp_mod_sqrt_521_correct = p521::mp_mod_sqrt_correct\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/ECDSA_sign_tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that checks an ECDSA P-192 signing function `sign` returns the expected (R,S) values for the given test vectors, analogous to `test192` that iterates over `testCase0` and `testCase1`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::ECDSA_sign_tests where\nimport Common::utils\nimport Primitive::Asymmetric::Signature::ECDSA::p192\n\ntestCase0 = {\nMsg = BVtoZ 0x608079423f12421de616b7493ebe551cf4d65b92, d = BVtoZ 0xe14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3,\nk = BVtoZ 0xcb0abc7043a10783684556fb12c4154d57bc31a289685f25,\nQx = BVtoZ 0x07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6,\nQy = BVtoZ 0x76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477,\nR = BVtoZ 0x6994d962bdd0d793ffddf855ec5bf2f91a9698b46258a63e,\nS = BVtoZ 0x02ba6465a234903744ab02bc8521405b73cf5fc00e1a9f41 }\n\ntestCase1 = {\nMsg = BVtoZ 0x98cff299c35616bfd081543998a5a367b43214e1,\nd = BVtoZ 0x7a0235bea3d70445f14d56f9b7fb80ec8ff4eb2f76865244,\nQx = BVtoZ 0x0ea3c1fa1f124f26530cbfddeb831eecc67df31e08889d1d,\nQy = BVtoZ 0x7215a0cce0501b47903bd8fe1179c2dfe07bd076f89f5225,\nk = BVtoZ 0x3c646b0f03f5575e5fd463d4319817ce8bd3022eaf551cef,\nR = BVtoZ 0xa3ba51c39c43991d87dff0f34d0bec7c883299e04f60f95e,\nS = BVtoZ 0x8a7f9c59c6d65ad390e4c19636ba92b53be5d0f848b4e1f7 }\n\nproperty test192 = and [((i.R, i.S) == (sign i.d i.Msg i.k)) | i <- [ testCase0, testCase1] ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for NIST P-384 ECDSA parameters and the modular square root function mp_mod_sqrt : Z p -> Z p, including properties that it computes a correct square root modulo p and is suitable for use in ECDSA verification\/signature operations."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::p384 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\ntype p = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\n\nb = 27580193559959705877849011840389048093056905856361568521428707301988689241309860865136260764883745107765439761230575\n\nG = {x = 26247035095799689268623156744566981891852923491109213387815615900925518854738050089022388053975719786650872476732087,\n     y = 8325710961489029985546751289520108179287853048861315594709205902480503199884419224438643760392947333078086511627871,\n     z = 1}\n\ntype q = 39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643\n\nmp_mod_sqrt : Z p -> Z p\nmp_mod_sqrt c = r''' ^^ (2 ^^ 30)\n  where t1    = (c ^^ 2) * c\n        t2    = (t1 ^^ (2 ^^ 2)) * t1\n        t2'   = (t2 ^^ 2) * c\n        t3    = (t2' ^^ (2 ^^ 5)) * t2'\n        t4    = (t3 ^^ (2 ^^ 5)) * t2'\n        t2''  = (t4 ^^ (2 ^^ 15)) * t4\n        t3'   = t2'' ^^ (2 ^^ 2)\n        t1'   = t3' * t1\n        t3''  = t3' ^^ (2 ^^ 28)\n        t2''' = t2'' * t3''\n        t3''' = (t2''' ^^ (2 ^^ 60)) * t2'''\n        r     = (t3''' ^^ (2 ^^ 120)) * t3'''\n        r'    = (r ^^ (2 ^^ 15)) * t4\n        r''   = (r' ^^ (2 ^^ 33)) * t1'\n        r'''  = (r'' ^^ (2 ^^ 64)) * c\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p192.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the ECDSA P-192 curve parameters and modular square-root function, including types p and q, constants b and G, and function mp_mod_sqrt, suitable for use in an ECDSA signature verification module."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::p192 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\ntype p = 6277101735386680763835789423207666416083908700390324961279\n\nb = 2455155546008943817740293915197451784769108058161191238065\n\nG = {x = 602046282375688656758213480587526111916698976636884684818,\n     y = 174050332293622031404857552280219410364023488927386650641,\n     z = 1}\n\ntype q = 6277101735386680763835789423176059013767194773182842284081\n\nmp_mod_sqrt c = r''\n  where t1 = c ^^ 2         ; t1' = t1 * c\n        t2 = t1' ^^ (2^^2)  ; t2' = t2 * t1'\n        t3 = t2' ^^ (2^^4)  ; t3' = t3 * t2'\n        t4 = t3' ^^ (2^^8)  ; t4' = t4 * t3'\n        t5 = t4' ^^ (2^^16) ; t5' = t5 * t4'\n        t6 = t5' ^^ (2^^32) ; t6' = t6 * t5'\n        r  = t6' ^^ (2^^64) ; r'  = r * t6'\n        r'' = r' ^^ (2^^62)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ECDSA\/p224.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for ECDSA over the NIST P-224 curve, including the prime field parameters p and q, the base point G, and the modular square-root function mp_mod_sqrt : Z p -> Z p together with its auxiliary functions RS, RSS, RM, and RP."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ECDSA::p224 = Primitive::Asymmetric::Signature::ECDSA::ECDSA where\n\nimport Common::utils\n\ntype p = 26959946667150639794667015087019630673557916260026308143510066298881\n\nb = 18958286285566608000408668544493926415504680968679321075787234672564\n\nG = {x = 19277929113566293071110308034699488026831934219452440156649784352033,\n     y = 19926808758034470970197974370888749184205991990603949537637343198772,\n     z = 1}\n\ntype q = 26959946667150639794667015087019625940457807714424391721682722368061\n\nmp_mod_sqrt : Z p -> Z p\nmp_mod_sqrt c = r\n  where s = random (ZtoBV c)\n        (d0, e0, f0) = RP c s\n        (d1, e1, f1) = RS d0 e0 f0\n        state = [(d1, e1, f1)] #\n                [ if d1' == 0 then (d, e, f) else (d1', e1', f1')\n                  where (d1', e1', f1') = RS d e f\n                | (d, e, f) <- state ]\n        (d0', e0', _) = state@95\n        r = d0' * (mp_mod_inv e0')\n\nprivate\n\n  RS : Z p -> Z p -> Z p -> (Z p, Z p, Z p)\n  RS d0 e0 f0 = (d1, e1', f1'')\n    where t    = d0 ^^ 2\n          e1   = d0 * e0\n          d1   = t + f0\n          e1'  = e1 + e1\n          f1   = t * f0\n          f1'  = f1 + f1\n          f1'' = f1' + f1'\n\n  RSS : Z p -> Z p -> Z p -> [7] -> (Z p, Z p, Z p)\n  RSS d0 e0 f0 j = (d1, e1, f1)\n    where (d1, e1, f1) = state@j\n          state = [(d0, e0, f0)] # [ RS d e f | (d, e, f) <- state ]\n\n  RM : Z p -> Z p -> Z p -> Z p -> Z p -> (Z p, Z p, Z p)\n  RM c d0 e0 d1 e1 = (d2, e2', f2'')\n    where t1    = e0 * e1\n          t1'   = t1 * c\n          t1''  = -t1'\n          t2    = d0 * d1\n          t2'   = t2 + t1''\n          t1''' = d0 * e1\n          e2    = d1 * e0\n          e2'   = e2 + t1'''\n          f2    = e2' ^^ 2\n          f2'   = f2 * c\n          f2''  = -f2'\n          d2    = t2'\n\n  RP : Z p -> Z p -> (Z p, Z p, Z p)\n  RP c r = (d1, e1, f1)\n    where (d1, e1, f1) = state!0\n          state = [(r, 1, -c)] # [ body d e f i | (d, e, f) <- state | i <- [0..6] ]\n          body d0 e0 f0 i = (d1'', e1'', f1'')\n            where (d1', e1', _) = RSS d0 e0 f0 (2^^i)\n                  (d1'', e1'', f1'') = RM c d1' e1' d0 e0\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/DSA\/DSA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for NIST DSA signing and verification over parameters p, q, g, including functions sign : Z q -> Z q -> Z q -> (Z q, Z q) and verify : Z p -> Z q -> (Z q, Z q) -> Bit, and a property signDsaCorrect stating verify(y,z,sign(x,k,z)) holds."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::DSA::DSA where\nimport Common::mod_arith\nimport Common::utils\n\nsign : Z q -> Z q -> Z q -> (Z q, Z q)\nsign x k z = (r, s)\n    where r =  ZtoZ (BVtoZ `{p=p}(mod_pow (pv, g', k')))\n          pv = ZtoBV `{1+p,L} `p\n          g' = ZtoBV `{a=L} g\n          k' = ZtoBV `{a=L} (ZtoZ `{q=q} k)\n          s = BVtoZ `{p=q}  (mod_mul (q', (ZtoBV `{a=N} kinv), zpxr))\n          kinv = mp_mod_inv k\n          xr = mod_mul(q', x', r')\n          zpxr = mod_add(q', xr, z')\n          r' = ZtoBV `{a=N} r\n          x' = ZtoBV `{a=N} x\n          z' = ZtoBV `{a=N} z\n          q' = ZtoBV `{1+q,N} `q\n\nverify : Z p -> Z q -> (Z q, Z q) -> Bit\nverify y z (r, s) = ((BVtoZ `{p=q} v) == r)\n   where w = (mp_mod_inv s)\n         u1 = (zero#mod_mul (q', (ZtoBV z), (ZtoBV w))) :[L]\n         u2 = (zero#mod_mul (q', (ZtoBV r), (ZtoBV w))) :[L]\n         v = mod_mul (pv, gu1, yu2)\n         gu1 =  mod_pow(pv, g', u1)\n         yu2 =  mod_pow(pv, y', u2)\n         pv = ZtoBV `{1+p,L} `p\n         g' = ZtoBV `{a=L} g\n         y' = ZtoBV `{a=L} y\n         q' = ZtoBV `{1+q,N} `q\n\nparameter\n\n    type p : #\n    type constraint Constraints p\n\n    g : Z p\n\n    type q : #\n\n    type constraint (fin q, isOdd q, q >= 4)\n\n\/\/ NIST recommended bit lengths of p and q\n\/\/L: the size of p, N: the size of q\n\n    type L : #\n\n    type N : #\n\/\/Comment\/uncomment according to the instantiated parameters\n    \/\/type constraint (L==1024,N==160)\n    type constraint (L==2048,N==224)\n    \/\/type constraint (L==2048,N==256)\n    \/\/type constraint (L==3072,N==256)\n\nprivate\n\n    type constraint Constraints a = (fin a, isOdd a, a >= 4)\n    \/\/type constraint validPsize L x = (L==1024*x, 2>=x)\n    \/\/type constraint validQsize N = (N==160) \/\/N==224, N==256\n\nproperty signDsaCorrect x k z = (verify (BVtoZ `{p=p} (mod_pow ((ZtoBV `{1+p,L} `p), ZtoBV `{a=L} g, (zero#(ZtoBV`{p=q}x):[L])))) z (sign x k z) ) == True\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/trash\/DilithiumBv.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the Dilithium lattice-based signature scheme using the given parameters, polynomial\/NTT structures, and sampling functions (Gen, PolyUniformEtaV, H, ExpandMask, ExpandA, matrixPoly, CRH), suitable for cryptographic verification of key generation and related primitives."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::DilithiumBV where\n\nimport Primitive::Keyless::Hash::keccak as SHA3\nimport Common::utils\nimport Common::mod_arith\nimport Primitive::Asymmetric::Cipher::RSA\nimport Primitive::Asymmetric::Signature::testDilithium\n\ntype qbits = 23\ntype uint32_t = 32\ntype q = 0x7fe001 type n = 0x100 d = 0xe\nwc= 0x3c gamma1 = ((`q) - 1) \/ 16:[_]\ngamma2 = (gamma1\/2):[_]\nalpha = (2*gamma2):[_]\n\nrootOfUnity    = 1753 :[_]\nrootOfUnityInv = 731434 : [_]\nninv           = 8347681 : [_]\n\nparameter\n    type k : #\n    type constraint (fin k, k>=3, k <=6)\n    type l : #\n    type constraint (fin l, l>=2, l<=5)\n    eta : [4]\n    beta : [12]\n    omega : [8]\n\ntype intPoly        = [n][uint32_t]\ntype intPolyVec dim = [dim]intPoly\n\ntype poly        = [n][qbits] type polyVec dim = [dim]poly\n\ntype nttPoly          = [n][qbits]\ntype nttVec dim       = [dim]nttPoly\ntype nttMat dim1 dim2 = [dim1](nttVec dim2)\n\ntype PublicKey = {rho : [256], t1 : intPolyVec k}\ntype SecretKey = {rho : [256]\n                    , K  : [256]\n                    , tr : [384]\n                    , s1 : polyVec l\n                    , s2 : polyVec k\n                    , t0 : intPolyVec k}\ntype SEEDBYTES = 32\n\nGen seed = A\n    where\n      randoms = split`{3} (join (SHA3::toBytes (take`{768} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))\n      (rho, rho', K) = (randoms@0, randoms@1, randoms@2)\n      A       = ExpandA rho\n      s1      = PolyUniformEtaV`{dim=l} rho' zero\n\nprivate\n    pack_w : intPolyVec k -> [4*n*k]\n    pack_w w = join [pack_poly p | p <- wBV ]\n        where\n        wBV = map (\\p -> map (\\x -> drop`{24} x:[8]) p) w\n\n        pack2 : [2][8] -> [8]\n        pack2 xs = xs@0 || (xs@1 << 4)\n\n        pack_poly p = join [ pack2 xs | xs <- split p : [128][2][_] ]\n\nPolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [8] -> polyVec dim\nPolyUniformEtaV rho nonce = [PolyUniformEta rho (nonce + j) | j <- [0..(dim-1)]:[dim][8]]\n\nPolyUniformEta : [SEEDBYTES*8] -> [8] -> poly\nPolyUniformEta rho nonce = map (\\x -> (zero#eta:[23]) - x) (map (\\x-> (zero#x):[23]) (take`{n} withinEta))\n    where\n    seed = rho#nonce\n    randoms = ((join (SHA3::toBytes (take`{2*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes seed))))))#zero)\n    withinEta = randomsInRangeDouble genS (2*eta) randoms\n\ngenS : [8] -> [2][4]\ngenS byte = [t0, t1]\n    where\n    t0 = drop`{4} (byte && 0x0F)\n    t1 = drop`{4} (byte >> 4)\n\nH : ([384],intPolyVec k) -> poly\nH (mu,w) = map fromInteger (SampleInBall ss samples)\n    where\n    w_packed = pack_w w\n    randoms  = join (SHA3::toBytes (take`{4352} (SHA3::SHAKE256 (join (SHA3::toBytes (mu#w_packed))))))\n    ss       = take`{60}(reverse (join (reverse (split (take`{64} randoms):[8][8]))))\n\n    extByte : [8] -> [8]\n    extByte x = x\n\n    samples : [60][8]\n    samples = take`{60} (randomsInRanges extByte [196..255] (drop`{64} randoms#zero))\n\nSampleInBall : [60] -> [60][8] -> [256]Integer\nSampleInBall signs jsamples = ys ! 0\n    where\n    ys = [ zero:[256]Integer ]\n        #    [ if i==j then update y i ((-1:Integer)^^(toInteger [s]))\n            else updates y [j,i] [(-1:Integer)^^(toInteger [s]),y@j] | i <- [196..255]\n        | j <- jsamples\n        | s <- signs\n        | y <- ys\n        ]\n\nExpandMask : ([SEEDBYTES*8], [384], Integer) -> polyVec l\nExpandMask  (K, mu, kappa) = [samplePoly K mu kappa i `l | i <- [0..(l-1)] ]\n\nsamplePoly : [256] -> [384] -> Integer -> Integer -> Integer -> poly\nsamplePoly K mu kappa i dim = [ (`q + (zero#gamma1:[23]) - (zero#1:[23]) - (zero#vj:[23])) | vj <- coeffs]\n    where\n    (upper:[20])      =  drop`{3}(2*gamma1-2):[20]\n    kappaBytes = join (reverse (split (fromInteger (dim*kappa+i):[16]):[2][8]))     s          = join (SHA3::toBytes (take`{5*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes (K#mu#kappaBytes))))))     (coeffs:[n][20])   = take`{n} (randomsInRangeDouble extractPolyElt upper (s#zero))\n\nextractPolyElt : [40] -> [2][20]\nextractPolyElt bits = [zero#int1, zero#int2]\n    where\n    [b0,b1,b2,b3,b4] = [(zero#b):[20] | b <- split bits : [5][8]]\n    int1 = b2'*2^^16 + b1*2^^8 +  b0\n    int2 = b4*2^^12 + b3*2^^4 +  b2''\n    b2'  = b2 && 15\n        b2'' = b2\/16\n\nCRH : {b} (fin b, b>=1) => [b*8] -> [384]\nCRH seed = join (SHA3::toBytes (take`{48*8} (SHA3::SHAKE256 (join (SHA3::toBytes seed)))))\n\nExpandA : [SEEDBYTES*8] -> [k][l]nttPoly\nExpandA rho = [ [elt i j | j <- [0..(l-1)] ] |  i <- [0..(k-1)] ]\n    where\n    elt i j = matrixPoly rho i j\n\nmatrixPoly : [SEEDBYTES*8] -> [width k] -> [width l] -> nttPoly\nmatrixPoly rho i j = take`{n} [ drop`{1} elt | elt <- randomElts ]\n    where\n    randomElts = randomsInRange extractMatElt ((>=) (`q)) (s#zero)\n    s          = join (SHA3::toBytes (take`{6720} (SHA3::SHAKE128 (join (SHA3::toBytes (rho#b))))))\n    b          = 2^^4*(zero#j:[8])+(zero#i:[8])\n\nextractMatElt : [24] -> [24]\nextractMatElt rands = zero#(2^^16 * b2' + 2^^8 * b1 + b0):[24]\n    where\n    [b0, b1, b2] = [(zero#b):[23] | b <- split`{3} rands]\n    b2' = (2^^23-1) && b2 \n\nrandomsInRange : {a} (fin a) => ([a]-> [a]) -> ([a] -> Bit) -> [inf] -> [inf][a]\nrandomsInRange createElt upperCrit randoms = if (upperCrit elt )\n                                             then  [ elt ]#(randomsInRange createElt upperCrit randomTail)\n                                             else randomsInRange createElt upperCrit randomTail\n                    where\n                    elt        = createElt (take`{a} randoms)\n                    randomTail = drop`{a} randoms\n\nrandomsInRanges : {a,m} (fin a,fin m, m>=1) => ([a]-> [a]) -> [m][a] -> [inf] -> [inf][a]\nrandomsInRanges createElt uppers randoms =\n                                            if elt <= head uppers\n                                            then  [ elt ]#(randomsInRanges createElt uppersRotate randomTail)\n                                            else randomsInRanges createElt uppers randomTail\n                                where\n                                elt          = createElt (take`{a} randoms)\n                                randomTail   = drop`{a} randoms\n                                uppersRotate = uppers <<< 1\n\nrandomsInRangeDouble : {a} (fin a) => ([2*a]-> [2][a]) -> [a] -> [inf] -> [inf][a]\n\nrandomsInRangeDouble createElt upper randoms =\n                                    if (elts@1 <= upper) then [elts@1, elts@1] # (randomsInRangeDouble createElt upper randomTail)\n                                    else (randomsInRangeDouble createElt upper randomTail)\n            where\n            elts       = createElt (take`{2*a} randoms)\n            randomTail = drop`{2*a} randoms\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/ref_ec_mul.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the elliptic-curve scalar multiplication functions `ec_mul` and `ec_twin_mul` (including `ec_twin_mul_aux1` and `F`) over `PointOps`, `AffinePoint`, and `JacobianPoint`, and add Cryptol properties that they correctly implement their intended EC scalar and twin-scalar multiplication behaviors for all valid inputs."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::ref_ec_mul where\n\nimport Common::EC::ec_point_ops\n\nec_mul : {fv, gv}  (fin gv) => (PointOps fv [gv], [gv], AffinePoint fv) -> JacobianPoint fv\nec_mul (m, d, s) = res!0\n  where\n    k = [False, False] # d\n    h = k + (k + k)\n    res : [gv+2](JacobianPoint fv)\n    res = [(ec_zero_point(m.field))]\n          #  [ if hi && ~ki then\n                 m.add(m.double(r), s)\n               else if ~hi && ki then\n                 m.sub(m.double(r), s)\n               else\n                 m.double(r)\n             | hi <- take`{back=1} h\n             | ki <- take`{back=1} k\n             | r  <- res\n             ]\n\nec_twin_mul_aux1 : {fv, gv} (fin gv, gv >= 4) =>\n  (PointOps fv [gv], JacobianPoint fv, [32], [32],\n   AffinePoint fv, AffinePoint fv, AffinePoint fv, AffinePoint fv)\n  -> (JacobianPoint fv)\nec_twin_mul_aux1(m,rP,u0,u1,sPt,s,sMt,t) = r\n  where\n   f = m.field\n   r = if u0 == -1 then\n         (if      u1 == -1 then m.sub(r2, sPt)\n          else if u1 ==  0 then m.sub(r2, s)\n          else                  m.sub(r2, sMt))\n       else if u0 == 0 then\n         (if      u1 == -1 then m.sub(r2, t)\n          else if u1 ==  1 then m.add(r2, t)\n          else                  r2)\n       else\n         (if      u1 == -1 then m.add(r2, sMt)\n          else if u1 ==  0 then m.add(r2, s)\n          else                  m.add(r2, sPt))\n   r2 = m.double(rP)\n\nF : {a} (fin a, a>=5) => [a] -> [a]\nF(t) = if (18 <= t) && (t < 22) then\n          9\n       else if (14 <= t) && (t < 18) then\n         10\n       else if (22 <= t) && (t < 24) then\n         11\n       else if (4 <= t) && (t < 12) then\n         14\n       else\n         12\n\nec_twin_mul : {fv, gv} (fin gv)\n            => (PointOps fv [gv+4], [gv+4], AffinePoint fv, [gv+4], AffinePoint fv)\n            -> (JacobianPoint fv)\nec_twin_mul(m, d0, s, d1, t) =\n  if ec_is_zero_point(f, sPtP) then \n    ec_mul(m, g.sub(d0, d1), s)\n  else if ec_is_zero_point(f, sMtP) then \n    ec_mul(m, g.add(d0, d1), s)\n  else\n    drop`{gv+4}(r)@0\n where\n   f    = m.field\n   g    = m.group_field\n   sP   = ec_projectify(f, s)\n   sPtP = m.add(sP, t) \n   sMtP = m.sub(sP, t) \n   sDiv = f.div(f.field_unit, f.mul(sPtP.z, sMtP.z))\n   sPt  = { x = f.mul(g2, sPtP.x)\n          , y = f.mul(f.mul(gd, g2), sPtP.y)\n          }\n     where gd = f.mul(sMtP.z, sDiv)\n           g2 = f.sq(gd)\n   sMt  = { x = f.mul(g2, sMtP.x)\n          , y = f.mul(f.mul(gd, g2), sMtP.y)\n          }\n     where gd  = f.mul(sPtP.z, sDiv)\n           g2 = f.sq(gd)\n   init_c : [2][6]\n   init_c = [zero # (take(d0) : [4]), zero # (take(d1) : [4])]\n   c : [inf]_\n   c = [init_c]\n     # [ [[abs(u0) ^ c01, c02, c03, c04, c05, e0N],\n          [abs(u1) ^ c11, c12, c13, c14, c15, e1N]]\n          where\n            abs : {a} (fin a) => [a] -> Bit\n            abs(x) = x != zero\n       | [[c00, c01, c02, c03, c04, c05], [c10, c11, c12, c13, c14, c15]] <- c\n       | [u0, u1] <- u\n       | e0N <- (drop`{4}(d0)) # (zero : [inf])\n       | e1N <- (drop`{4}(d1)) # (zero : [inf])\n       ]\n   u : [inf]_\n   u = [ [u0, u1]\n            where\n              h0' = [c05, c04, c03, c02, c01]\n              h0 = if c00 then 31 - h0' else h0'\n              h1' = [c15, c14, c13, c12, c11]\n              h1 = if c10 then 31 - h1' else h1'\n              u0 : [32]\n              u0 = if h0 < F(h1) then 0 else if c00 then -1 else 1\n              u1 : [32]\n              u1 = if h1 < F(h0) then 0 else if c10 then -1 else 1\n       | [[c00, c01, c02, c03, c04, c05], [c10, c11, c12, c13, c14, c15]] <- c\n       ]\n   r : [inf]_\n   r = [(ec_zero_point f)]\n     # [ ec_twin_mul_aux1(m, rP, u0, u1, sPt, s, sMt, t)\n       | rP      <- r\n       | [u0, u1] <- u\n       ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/p384_ec_point_ops.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the module `Common::EC::p384_ec_point_ops` that instantiates `PointOps [384] [384]` for the P-384 curve, including `p384_point_ops`, `p384_ec_double`, `p384_ec_full_add`, and `p384_ec_full_sub` using the `p384_field` and generic EC point operations."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::p384_ec_point_ops where\n\nimport Common::EC::ec_point_ops\nimport Common::EC::p384_field\n\np384_point_ops : PointOps [384] [384]\np384_point_ops = {\n    field  = p384_field\n  , double = p384_ec_double\n  , add    = p384_ec_full_add\n  , sub    = p384_ec_full_sub\n  , group_field = p384_group_field\n  }\n\np384_ec_double : JacobianPoint [384] -> JacobianPoint [384]\np384_ec_double(p) = ec_double(p384_field, p)\n\np384_ec_full_add : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384]\np384_ec_full_add(p,q) = ec_full_add(p384_point_ops, p, q)\n\np384_ec_full_sub : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384]\np384_ec_full_sub(p,q) = ec_full_sub(p384_point_ops, p, q)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/EC_P384.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that fully implements and verifies the NIST P-384 elliptic curve, including affine and Jacobian point operations, ECDSA sign\/verify, ECDH key derivation, Montgomery conversions, and the undefined functions inv0, ec_point_* and fromJacobian, with appropriate types and properties."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::EC_P384 where\n\nimport Common::ModDivZ\n\ntype w = 384\n\ntype p = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\n\ntype FieldElement = Integer\n\na : FieldElement\na = -3\nb : FieldElement\nb = `0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\n\nG : AffinePoint\nG =\n  { x = `0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\n  , y = `0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\n  }\n\ntype n = 39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643\n\ntype Scalar = Integer\n\nR_p : FieldElement\nR_p = 340282367000166625977638945021017194497\nR_p_inv : FieldElement\nR_p_inv = 183479889321925461653251752109332205360611897149516305954304919627392402791260477631193651879713439593005062\n\nR_n : Scalar\nR_n = 1388124618062372383947042015309946732620727252194336364173\nR_n_inv : Scalar\nR_n_inv = 8213155180316830564023772752902517460134849974600554980379995049303147060140144611822562736815346652390458105321745\n\nfieldElementToBV : FieldElement -> [w]\nfieldElementToBV x = fromInteger x\n\nfieldElementFromBV : [w] -> FieldElement\nfieldElementFromBV x = toInteger x\n\nscalarToBV : Scalar -> [w]\nscalarToBV x = fromInteger x\n\nscalarFromBV : [w] -> Scalar\nscalarFromBV x = toInteger x\n\ninv0 : Scalar -> Scalar\ninv0 = undefined\n\ntype AffinePoint = { x : FieldElement, y : FieldElement }\n\nec_point_affine_add : AffinePoint -> AffinePoint -> AffinePoint\nec_point_affine_add = undefined\n\nec_point_affine_scalar_mul : Scalar -> AffinePoint -> AffinePoint\nec_point_affine_scalar_mul = undefined\n\nEC_keyPrivateToPublic : Integer -> AffinePoint\nEC_keyPrivateToPublic d = ec_point_affine_scalar_mul (d % `n) G\n\ntype ECDSA_Signature = { r : Scalar, s : Scalar }\n\nECDSA_sign : Scalar -> Integer -> Scalar -> ECDSA_Signature\nECDSA_sign d z k = { r = r, s = s }\n  where\n    { x = x1, y = _ } = ec_point_affine_scalar_mul k G\n    r =  x1 % `n\n    s = ((inv0 k) * (z + r * d)) % `n\n\nECDSA_verify : AffinePoint -> Integer -> ECDSA_Signature -> Bit\nECDSA_verify Q z { r = r, s = s } = r != 0 \/\\ r < `n \/\\ s != 0 \/\\ s < `n \/\\ r == x1 % `n\n  where\n    u1 = z * (inv0 s) % `n\n    u2 = r * (inv0 s) % `n\n    { x = x1, y = _ } = ec_point_affine_add (ec_point_affine_scalar_mul u1 G) (ec_point_affine_scalar_mul u2 Q)\n\nECDH_derive : Scalar -> AffinePoint -> FieldElement\nECDH_derive d Q = x % `p\n  where\n    { x = x, y = _ } = ec_point_affine_scalar_mul d Q\n\ntype JacobianPoint = { x : FieldElement, y : FieldElement, z : FieldElement }\n\ntoJacobian : AffinePoint -> JacobianPoint\ntoJacobian p = { x = p.x, y = p.y, z = 1 }\nfromJacobian : JacobianPoint -> AffinePoint\nfromJacobian p = undefined\n\nec_point_jacobian_add : JacobianPoint -> JacobianPoint -> JacobianPoint\nec_point_jacobian_add = undefined\n\nec_point_jacobian_scalar_mul : Scalar -> JacobianPoint -> JacobianPoint\nec_point_jacobian_scalar_mul = undefined\n\ntype JacobianBVPoint = { X : [w], Y : [w], Z : [w] }\n\njacobianToBV : JacobianPoint -> JacobianBVPoint\njacobianToBV p =\n  { X = fieldElementToBV p.x\n  , Y = fieldElementToBV p.y\n  , Z = fieldElementToBV p.z\n  }\n\njacobianFromBV : JacobianBVPoint -> JacobianPoint\njacobianFromBV p =\n  { x = fieldElementFromBV p.X\n  , y = fieldElementFromBV p.Y\n  , z = fieldElementFromBV p.Z\n  }\n\njacobianToMont : JacobianPoint -> JacobianPoint\njacobianToMont p =\n  { x = (p.x * P384_R_p) % `p\n  , y = (p.y * P384_R_p) % `p\n  , z = (p.z * P384_R_p) % `p\n  }\n\njacobianFromMont : JacobianPoint -> JacobianPoint\njacobianFromMont p =\n  { x = (p.x * P384_R_p_inv) % `p\n  , y = (p.y * P384_R_p_inv) % `p\n  , z = (p.z * P384_R_p_inv) % `p\n  }\n\njacobianToMontBV : JacobianPoint -> JacobianBVPoint\njacobianToMontBV p = jacobianToBV (jacobianToMont p)\n\njacobianFromMontBV : JacobianBVPoint -> JacobianPoint\njacobianFromMontBV p = jacobianFromMont (jacobianFromBV p)\n\nmont_R : {m} (fin m, m >= 3) => Integer\nmont_R = 2 ^^ `(width m) % `m\n\nmont_R_inv : {m} (fin m, m >= 3) => Integer\nmont_R_inv = fromZ (moddiv`{m} 1 (fromInteger (mont_R`{m})))\n\nbn_mont_n0 : {m} (fin m, m >= 3) => [64]\nbn_mont_n0 = fromInteger (((2 ^^ `(width m)) * mont_R_inv`{m} - 1) \/ `m)\n\ntype P384_w = w\ntype P384_p = p\nP384_a = a\nP384_b = b\nP384_G = G\nP384_G_Jacobian = toJacobian G\ntype P384_n = n\n\nP384_R_p = R_p\nP384_R_p_inv = R_p_inv\nP384_R_n = R_n\nP384_R_n_inv = R_n_inv\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/p384_ec_mul.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the P-384 elliptic-curve scalar multiplication and twin-scalar multiplication routines, including p384_ec_mul, p384_ec_mul_init, p384_ec_twin_mul_init, p384_ec_twin_mul_aux{1,2}, and p384_ec_twin_mul, proving they match the corresponding Java big-integer\/EC implementations."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::p384_ec_mul where\n\nimport Common::bv\nimport Common::mul_java\nimport Common::EC::ec_point_ops\nimport Common::EC::p384_field\nimport Common::EC::p384_ec_point_ops\nimport Common::EC::ref_ec_mul\n\nmk_strm : {a, b} fin a => [a][b] -> [inf][b]\nmk_strm x = x # zero\n\nripple_adc : {m, n} (m >= 1, fin m, fin n) => ([n][m],[n][m]) -> ([n][m],Bit)\nripple_adc(xx,yy) = (values, carry_strm!0)\n  where\n    adc' : ([m],[m],Bit) -> (Bit,[m])\n    adc'(x,y,c) = (sum3@0, drop(sum3))\n      where sum3 = safe_add(x,y) + zext([c])\n    list = [ adc'(a,b,c)\n           | a <- xx\n           | b <- yy\n           | c <- carry_strm\n           ]\n    values = [ v | (_,v) <- list ]\n    carry_strm : [n+1]\n    carry_strm  = [False] # [ c | (c,_) <- list ]\n\nproperty ripple_adc_toJavaArray x y =\n  ripple_adc (toJavaArray x, toJavaArray y) == (toJavaArray (x + y), carry x y)\n\n\/* Returns (xl # c) >> 1. *\/\nripple_shr : {m, n} (m >= 1, fin m, n >= 1, fin n) => ([n][m],Bit) -> ([n][m])\nripple_shr(xl,c) = [ (x' << (length(x) - 1:[width m])) || (x >> 1)\n                   | x <- xl\n                   | x' <- drop`{1}(xl) # [(zext([c]))]\n                   ]\n\nproperty ripple_shr_toJavaArray x c =\n  ripple_shr (toJavaArray x, c) == toJavaArray (take`{back=1} ([c] # x))\n\np384_ec_zero_point : JacobianPoint [384]\np384_ec_zero_point = ec_zero_point(p384_field)\n\n\/* Matches Java implementation *\/\np384_ec_mul : ([384], AffinePoint [384]) -> JacobianPoint [384]\np384_ec_mul (d, s) = res!0\n  where\n    d' : [12][32]\n    d' = toJavaArray d\n    ini =  p384_ec_mul_init(d, s)\n    h : [12][32]\n    h = toJavaArray (ini.h)\n    r0 = ini.r\n    f (j, r) = p384_ec_mul_aux(r, s, j, h@i, c, d'@i, d_at_ip1)\n      where\n        i        = j >> 5\n        c        = i < 11\n        d_at_ip1 = if c then d'@(i+1) else 0\n                   \/* NB: We guard indexing here to avoid bounds VCs;\n                      p384_ec_mul_aux's use of d_at_ip1 is likewise\n                      guarded. *\/\n    res : [385]_\n    res = [r0] #\n          [ f(j, r)\n          | j <- reverse [0..383]\n          | r <- res\n          ]\n\np384_ec_mul_aux : ( JacobianPoint [384]\n                   , AffinePoint [384]\n                   , [32], [32], Bit, [32], [32] ) -> JacobianPoint [384]\np384_ec_mul_aux (r, s, j, hi, i_lt_11, d_at_i, d_at_ip1) = r'\n  where\n    m = 1 << (j && 31)\n    ki  = d_at_i >> 1\n    ki' = if i_lt_11 then\n            ((d_at_ip1 && 1) << 31) || ki\n          else\n            ki\n    r2 = p384_ec_double(r)\n    r'  = if ((hi && m) != 0) && ((ki' && m) == 0) then\n            p384_ec_full_add(r2, s)\n          else if ((hi && m) == 0) && ((ki' && m) != 0) then\n            p384_ec_full_sub(r2, s)\n          else\n            r2\n\np384_ec_mul_init : ([384], AffinePoint [384]) ->\n                   { h: [384], r: JacobianPoint [384] }\np384_ec_mul_init (d, s) = { h = fromJavaArray h0, r = r0 }\n  where\n    d' : [12][32]\n    d' = toJavaArray d\n    (h0, c) = ripple_adc(d', ripple_shr(d', False))\n    r0 = if c then ec_projectify(p384_field, s)\n              else p384_ec_zero_point\n\np384_ec_twin_mul_init :\n  ([384], AffinePoint [384], [384], AffinePoint [384]) ->\n  { r : JacobianPoint [384]\n  , sMt : AffinePoint [384]\n  , sPt : AffinePoint [384]\n  }\np384_ec_twin_mul_init(d0, s, d1, t) =\n  { r = r0\n  , sPt = if s.x == t.x then azero else sPt0\n  , sMt = if s.x == t.x then azero else sMt0\n  }\n  where\n    azero = { x = 0:[384], y = 0:[384] }\n    r0 =\n      if s.x == t.x then\n        if s.y == t.y then\n          p384_ec_mul(g.add(d0, d1), s)\n        else\n          p384_ec_mul(g.sub(d0, d1), s)\n      else\n        ec_zero_point f\n    m    = p384_point_ops\n    f    = m.field\n    g    = m.group_field\n    sP   = ec_projectify(f, s)\n    sPtP = m.add(sP, t) \/* 1: ec_full_add (SpT, S, T) *\/\n    sMtP = m.sub(sP, t) \/* 2: ec_full_sub (SmT, S, T) *\/\n    sDiv = f.div(f.field_unit, f.mul(sPtP.z, sMtP.z))\n    sPt0 = { x = f.mul(sPtP.x, g2), y = f.mul(f.mul(sPtP.y, g1), g2) }\n           where g1 = f.mul(sMtP.z, sDiv)\n                 g2 = f.sq(g1)\n    sMt0 = { x = f.mul(sMtP.x, g2), y = f.mul(f.mul(sMtP.y, g1), g2) }\n           where g1 = f.mul(sPtP.z, sDiv)\n                 g2 = f.sq(g1)\n\np384_ec_twin_mul_aux1 :\n  (JacobianPoint [384], [32], [32], AffinePoint [384], AffinePoint [384], AffinePoint [384], AffinePoint [384])\n  -> JacobianPoint [384]\np384_ec_twin_mul_aux1(rP, u0_32, u1_32, sPt, s, sMt, t) =\n  ec_twin_mul_aux1(p384_point_ops, rP, u0_32, u1_32, sPt, s, sMt, t)\n\np384_ec_twin_mul_aux2 : ([32],[32],[32],[32],[32],[32],[32],Bit,Bit) ->\n  { tma2_u0:[32]\n  , tma2_u1:[32]\n  , tma2_c0':[32]\n  , tma2_c1':[32]\n  , tma2_e0':[32]\n  , tma2_e1':[32]\n  , tma2_sh':[32]\n  }\np384_ec_twin_mul_aux2 (c0, c1, e0, e1, sh, d0i, d1i, dv1, dv2) =\n  { tma2_u0  = u0\n  , tma2_u1  = u1\n  , tma2_c0' = c0'\n  , tma2_c1' = c1'\n  , tma2_e0' = e0'\n  , tma2_e1' = e1'\n  , tma2_sh' = sh'\n  }\n  where\n    c0'           = ((if h0Less then 0 else `0x20) ^ (c0 << 1)) || ((e0 >> (sh && 31)) && `0x1)\n    c1'           = ((if h1Less then 0 else `0x20) ^ (c1 << 1)) || ((e1 >> (sh && 31)) && `0x1)\n    u0            = if h0Less then 0 else (if (c0 && `0x20) != 0 then (-1) else 1)\n    u1            = if h1Less then 0 else (if (c1 && `0x20) != 0 then (-1) else 1)\n\n    h0            = if (c0 && `0x20) != 0 then 31 - h0' else h0'\n      where h0' = c0 && `0x1F\n\n    h1            = if (c1 && `0x20) != 0 then 31 - h1' else h1'\n      where h1' = c1 && `0x1F\n\n    h0Less        = h0 < F(h1)\n    h1Less        = h1 < F(h0)\n    (e0',e1',sh') = if dv1 then\n                      if dv2 then (d0i, d1i, 31) else (0, 0, 31)\n                    else (e0, e1, sh-1)\n\n\/\/ F : [5] -> [5] via original impl\n\/\/ F : [32] -> [32] via fused impl\np384_ec_twin_mul_aux_F32 : [32] -> [32]\np384_ec_twin_mul_aux_F32 = F\n\n\/* Matches Java implementation *\/\np384_ec_twin_mul : ([384],AffinePoint[384], [384], AffinePoint [384]) -> JacobianPoint [384]\np384_ec_twin_mul(d0, s, d1, t) =\n  if s.x == t.x then i.r else jj_r\n  where\n   m     = p384_point_ops\n   f     = m.field\n   g     = m.group_field\n   i     = p384_ec_twin_mul_init(d0, s, d1, t)\n   d0'   = toJavaArray d0\n   d1'   = toJavaArray d1\n   d0_11 = d0'!0\n   d1_11 = d1'!0\n   (jj_r, _, _, _, _, _) = jj!0\n   jj : [386](JacobianPoint [384], _,_,_,_,_)\n   jj    = [ ( i.r             \/\/ initial point\n             , d0_11 >> 28     \/\/ c0 initial value\n             , d1_11 >> 28     \/\/ c1 initial value\n             , d0_11           \/\/ e0 initial value\n             , d1_11           \/\/ e1 initial value\n             , 27:[32]         \/\/ shift initial value\n             )\n           ]\n         # [ (r', c0', c1', e0', e1', sh')\n             where\n                k = (k0-5):[32]\n                r'         = p384_ec_twin_mul_aux1(r, u0, u1, i.sPt, s, i.sMt, t)\n                aux2       = p384_ec_twin_mul_aux2(c0, c1, e0, e1, sh, d0i, d1i, dv1, dv2)\n                (u0, u1)   = (aux2.tma2_u0, aux2.tma2_u1)\n                (c0', c1') = (aux2.tma2_c0', aux2.tma2_c1')\n                (e0', e1') = (aux2.tma2_e0', aux2.tma2_e1')\n                sh'        = aux2.tma2_sh'\n                (d0i, d1i,\n                 dv1, dv2) = if dv1i && dv2i then\n                               (d0'@ii, d1'@ii, dv1i, dv2i)\n                             else\n                               (zero, zero, dv1i, dv2i)\n                             where\n                               ii    = (k >> 5) - 1\n                               dv1i  = (k && `0x1F) == 0\n                               dv2i  = ~(ii@0)\n           | (r, c0, c1, e0, e1, sh) <- jj\n           | k0 <- reverse [0 .. 384]\n           ]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/Common\/EC\/PrimeField\/PFEC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for elliptic curve scalar multiplication over a short Weierstrass prime field, including point addition, scalar multiplication, a distinguished base point G, and properties `valid_n`, `valid_scmul`, and `scmul_commutes` as given."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::PrimeField::PFEC where\n\nimport Common::ModDivZ\n\nparameter\n    type P : #         type constraint (fin P, P >= 5)\n    n  : Integer       b  : Z P           Gx : Z P           Gy : Z P       \ntype Point = (Z P, Z P)\nG = (Gx, Gy) : Point\na = -3 : Z P       p = toInteger`{width P} `P\n\noo = (0, 0) : Point\n\nvalid_point : Point -> Bit\nvalid_point (x, y) =\n    ((x, y) == oo) \\\/ (y ^^ 2 == x ^^ 3 + a * x + b)\n\nec_add : Point -> Point -> Point\nec_add (x1, y1) (x2, y2) =\n    if (x1, y1) ==    oo     then  (x2, y2)       | (x2, y2) ==    oo     then  (x1, y1)       | (x1, y1) == (x2, -y1) then     oo                                  else   (x, y)       where      x = L ^^ 2 - x1 - x2\n    y = L * (x1 - x) - y1\n    L = if x1 == x2 then (3 * x1 ^^ 2 + a) %\/ (2 * y1)\n                    else (y2 - y1) %\/ (x2 - x1)\n\nscmul : Integer -> Point -> Point\nscmul m xy =\n    if m == 0 then oo\n     | m == 1 then xy\n     | even m then scmul (m \/ 2) (ec_add xy xy)\n              else ec_add xy (scmul (m - 1) xy)\n\n(~*) = scmul  \nproperty valid_n = (n + 1) ~* G == G\nproperty valid_scmul m = valid_point (m ~* G)\nproperty scmul_commutes m m' = m ~* (m' ~* G) == m' ~* (m ~* G)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/gf.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the finite-field operations module `GF` for the McEliece KEM, including types `base_t`, `gf_t` and functions `gf_iszero`, `gf_add`, `gf_mul`, `gf_sqmul`, `gf_sq2mul`, `gf_sq2`, `gf_frac`, and `gf_inv`, suitable for verification of constant-time field arithmetic."},{"role":"assistant","content":"```cryptol\nmodule GF where\n\nimport Types\n\ngf_iszero : base_t  -> base_t\ngf_iszero a = t_3 where\n    (t_1 : uint32t ) = cvt_16_to_32 a\n    (t_2 : uint32t ) = (t_1-1)>> 19\n    (t_3 : base_t) = cvt_32_to_16 t_2\n\ngf_add : base_t -> base_t -> base_t\ngf_add a b = a^b\n\ngf_mul : gf_t  -> gf_t  -> gf_t\ngf_mul a b = rtn  where\n    (t0:base_64t) = cvt_16_to_64 a\n    (t1:base_64t) = cvt_16_to_64 b\n    loop_i i tmp =\n        if (i>= GFBITS) then tmp\n        else loop_i (i+1) tmp' where\n            tmp' = t0 * (t1 && (1 << i))\n    (tmp_0 : base_64t) = t0 * (t1 && 1)\n    (tmp_1 : base_64t) = loop_i 0 tmp_0\n        (k_0: base_64t) =  cvt_20_to_64 0x1FF0000\n    (k_1: base_64t) =  cvt_20_to_64 0x000E000\n    (t_0: base_64t) = tmp_1 && k_0\n    (t_1: base_64t) = tmp_2 && k_1\n    (tmp_2 : base_64t) = tmp_1 ^ ((t_0 >> 9) ^ (t_0 >> 10) ^ (t_0 >> 12) ^ (t_0 >> 13))\n    (tmp_3 : base_64t) = tmp_2 ^ ((t_1 >> 9) ^ (t_1 >> 10) ^ (t_1 >> 12) ^ (t_1 >> 13))\n    (rtn : gf_t ) = cvt_64_to_16 (tmp_3 && GFMASK)\n\nloop_i i x limit M =\n    if(i<limit) then loop_i i' x' limit M where\n        t = x && (M@i)\n        x'= x^ (t >> 9) ^ (t >> 10) ^ (t >> 12) ^ (t >> 13)\n        i' = i+1\n    else  cvt_64_to_16 (x&& GFMASK)\n\ngf_sqmul : gf_t -> gf_t -> gf_t\ngf_sqmul a b = rtn where\n    M = [0x0000001FF0000000, 0x000000000FF80000, 0x000000000007E000]\n    (t0:uint64t) = cvt_16_to_64  a\n    (t1:uint64t) = cvt_16_to_64  b\n    (x1:uint64t) = (t1 << 6) * (t0 && (1 << 6))\n    (t2:uint64t) = t0^(t0 << 7)\n    (x2:uint64t) = x1^ (t1 * (t2 && (cvt_20_to_64 0x04001)))\n    (x3:uint64t) = x2^ (t1 * (t2 && (cvt_20_to_64 0x08002))) << 1\n    (x4:uint64t) = x3^ (t1 * (t2 && (cvt_20_to_64 0x10004))) << 2\n    (x5:uint64t) = x4^ (t1 * (t2 && (cvt_20_to_64 0x20008))) << 3\n    (x6:uint64t) = x5^ (t1 * (t2 && (cvt_20_to_64 0x40010))) << 4\n    (x7:uint64t) = x6^ (t1 * (t2 && (cvt_20_to_64 0x80020))) << 5\n    rtn = loop_i 0 x7 3 M\n\ngf_sq2mul : gf_t -> gf_t -> gf_t\ngf_sq2mul a b = rtn where\n    (M:[6][64]) = [0x1FF0000000000000,\n        0x000FF80000000000,\n        0x000007FC00000000,\n        0x00000003FE000000,\n        0x0000000001FE0000,\n        0x000000000001E000]\n    (t0:uint64t) = cvt_16_to_64 a\n    (t1:uint64t) = cvt_16_to_64 b\n    (x_1:uint64t) = (t1 << 18) * (t0 && (1 << 6))\n    t2 = t0^(t0 << 21)\n    (x_2:uint64t) = x_1^(t1 * (t0 && (cvt_36_to_64 0x010000001)))\n    (x_3:uint64t) = x_2^(t1 * (t0 && (cvt_36_to_64 0x020000002))) << 3\n    (x_4:uint64t) = x_3^(t1 * (t0 && (cvt_36_to_64 0x040000004))) << 6\n    (x_5:uint64t) = x_4^(t1 * (t0 && (cvt_36_to_64 0x080000008))) << 9\n    (x_6:uint64t) = x_5^(t1 * (t0 && (cvt_36_to_64 0x100000010))) << 12\n    (x_7:uint64t) = x_6^(t1 * (t0 && (cvt_36_to_64 0x200000020))) << 15\n    rtn = loop_i 0 x_7 6 M\n\ngf_sq2 : gf_t -> gf_t\ngf_sq2 in = rtn where\n    (B:[4][64]) = [0x1111111111111111,\n        0x0303030303030303,\n        0x000F000F000F000F,\n        0x000000FF000000FF]\n    (M:[4][64]) = [0x0001FF0000000000,\n        0x000000FF80000000,\n        0x000000007FC00000,\n        0x00000000003FE000]\n    (x_1:uint64t) = cvt_16_to_64 in\n    (x_2:uint64t) = (x_1 || (x_1 << 24)) && (B@3)\n    (x_3:uint64t) = (x_2 || (x_2 << 12)) && (B@2)\n    (x_4:uint64t) = (x_3 || (x_3 << 6)) && (B@1)\n    (x_5:uint64t) = (x_4 || (x_3 << 3)) && (B@0)\n    rtn = loop_i 0 x_5 4 M\n\ngf_frac : gf_t -> gf_t -> gf_t\ngf_frac d n = t7 where\n    t1 = gf_sqmul d d\n    t2 = gf_sq2mul t1 t1\n    t3 = gf_sq2 t2\n    t4 = gf_sq2mul t3 t2\n    t5 = gf_sq2 t4\n    t6 = gf_sq2mul t5 t2\n    t7 = gf_sqmul t7 n\n\ngf_inv : gf_t -> gf_t\ngf_inv d = gf_frac d 1\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/operations.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the McEliece KEM low-level operations in Cryptol by fully defining the functions compute_hash_2e, compute_hash_1e, crypto_hash_32b_1, crypto_hash_32b_2, crypto_kem_enc, and crypto_kem_dec with appropriate types consistent with the imported Types, Encrypt, and Decrypt modules."},{"role":"assistant","content":"```cryptol\nmodule Operations where\n\nimport Types\nimport Encrypt\nimport Decrypt\n\ncompute_hash_2e : SYS_N8_plus1_t -> [32]base_t\ncompute_hash_2e in = undefined\ncompute_hash_1e : pm_t -> [32]base_t\ncompute_hash_1e in = undefined\n\ncrypto_hash_32b_1 : SYS_N8_plus1_t -> [32]base_t\ncrypto_hash_32b_1 in = undefined\n\ncrypto_hash_32b_2 : pm_t -> g_key_t\ncrypto_hash_32b_2 in = undefined\n\n(two_e : SYS_N8_plus1_t) = [ 2 | x <- [0..870]]\n\ncrypto_kem_enc : g_ct_t -> g_key_t -> g_pk_t -> SYS_N8_plus2_t\n    -> (g_ct_t, g_key_t)\ncrypto_kem_enc c0 key pk e =  (c2, key2) where\n        (e :  SYS_N8_plus2_t) = zero\n        (c1 : g_ct_t) = encrypt c0 pk e\n        (c2 : g_ct_t) = (take `{194} c1 ) # (compute_hash_2e two_e)\n    (one_ec : pm_t) = ([1])#(take `{870} e)#c2\n    (key2 : g_key_t) = compute_hash_1e one_ec\n\ncrypto_kem_dec : g_ct_t -> g_sk_t -> g_key_t\ncrypto_kem_dec c sk = key where\n        (e : SYS_N8_t, ret_decrypt : gf_t) = decrypt sk c\n        (conf : [32]base_t) = crypto_hash_32b_1 two_e\n    loop_i i rc =\n        if (i<32)\n        then loop_i i' rc' where\n            i' = i+1\n            rc' = rc || ((conf@i) ^ c@(SYND_BYTES + i))\n        else rc\n    (ret_confirm : base_16t) = loop_i 0 0\n    (m_0 : base_16t) = ret_decrypt || ret_confirm\n    (m_1 : base_16t) = m_0 - 1\n    (m : base_16t) = m_1 >> 8\n    x_1 = [(~m && 0) || (m && 1)]\n    x_2 = [(~m && (sk@i)) || (m && (e@i)) | i <- [0..(870-1)]]\n    x_3 = [(c@i) | i <- [0..(194-1+32)]]\n    (preimage: pm_t) = x_1 # x_2 # x_3\n        (key : g_key_t) = crypto_hash_32b_2 preimage\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/benes.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the McEliece KEM Benes network support generation, including the functions apply_benes and support_gen with appropriate types and properties to verify that support_gen correctly computes the support from a secret key g_sk_t."},{"role":"assistant","content":"```cryptol\nmodule Benes where\n\nimport Types\nimport GF\nimport Util\n\ntype La_t = [32]\ntype Lb_t = [j_size_t][32]\ntype Lc_t = [GFBITS_t][j_size_t][32]\n\napply_benes r bits rev = zero\n\nsupport_gen : g_sk_t  -> L_t\nsupport_gen c  = s where\n    k_size = (1:La_t) << GFBITS\n    loop_i : La_t -> Lc_t -> Lc_t\n    loop_i ix L =\n        if(ix<k_size)\n        then  loop_i ix' L' where\n            (_, a) = bitrev ix\n            loop_j : La_t -> Lc_t -> Lc_t\n            loop_j jx M =\n                if (jx < GFBITS)\n                then loop_j jx' M' where\n                    (kx:La_t) = ix\/8\n                    (val_jx:Lb_t) = M@jx\n                    (val_kx:La_t) = val_jx@kx\n                    (c:La_t) = (ix%8:La_t)\n                    (d:La_t)  = (((a >> jx) && (1:La_t)) << c)\n                    (val_0:La_t) =  val_kx || d\n                    (val_1:Lb_t) = (update val_jx kx val_0)\n                    (M':Lc_t) = update M jx val_1\n                    (jx':La_t) = jx+1\n                else M\n            L' = loop_j 0 L\n            ix' = ix+1\n        else L\n    (L_0:Lc_t) = zero\n    (L_1:Lc_t) = loop_i 0 L_0\n    (L_2:Lc_t) =[(apply_benes l c 0) | l <- L_1]\n    loop_ix : La_t -> L_t -> L_t\n    loop_ix ix s =\n        if (ix<SYS_N)\n        then loop_ix (ix+1) s_2  where\n            loop_jx : La_t -> L_t -> L_t\n            loop_jx jx s =\n                if(jx>=0)\n                then loop_jx jx' s' where\n                    (x : La_t) = (L_2@jx)@(ix\/8)\n                    (y : La_t) = (x >> (ix%8)) && 1\n                    (z : base_t) = (s@ix << (1:base_t)) || ( cvt_32_to_16 y)\n                    (jx': La_t) = jx-1\n                    s' = update s ix z\n                else s\n\n                        s_1 = update s ix 0\n            s_2 = loop_jx (GFBITS-1) s_1\n        else s\n    (s:L_t) = loop_ix 0 zero\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/decrypt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Decrypt` that specifies the low-level McEliece KEM decryption function `decrypt : g_sk_t -> g_ct_t -> (f_t, gf_t)` using the described loops, finite-field operations, and helper functions, suitable for formal verification of its correctness."},{"role":"assistant","content":"```cryptol\nmodule Decrypt where\n\nimport Benes\nimport Types\nimport Decrypt_helpers\nimport GF\nimport Util\n\ndecrypt : g_sk_t -> g_ct_t -> (f_t, gf_t)\ndecrypt sk c = (e, check) where\n    (r : r_t) = (take `{194} c)#zero\n    loop_1 g i sk_index =\n        if i < SYS_T\n        then loop_1 g' (i+1) (sk_index+2) where\n            (a : gf_t)= load2 sk sk_index\n            (b : gf_t) = a && GFMASK\n            g'= update g i b\n        else g\n    (g_0 : g_t) = zero\n    (g_1 : g_t) = loop_1 g_0 0 0\n    (L : L_t) = support_gen sk\n    (s : s_t) = synd g_1 L r\n    (locator : g_t) = bm s\n    (images : SYS_N_t) = root locator L\n    loop_2 : [32] -> f_t -> gf_t -> (f_t, gf_t)\n    loop_2 i e w =\n        if (i<SYS_N)\n        then loop_2 (i+1) e' w' where\n            (t : gf_t) = (gf_iszero (images @i)) && (1:[16])\n            jx = i\/8\n            val = (e@jx) || t << (i%8)\n            (e' : f_t) = update e jx val\n            (w' : gf_t) = w+t\n        else (e, w)\n    (e : f_t, w : gf_t) = loop_2 0 zero 0\n    (s_cmp : s_t) = synd g_1 L e\n    loop_3 i check =\n        if (i<SYS_T*2)\n        then  loop_3 (i+1) check' where\n            check' = check || ((s@i) ^ (s_cmp@i))\n        else check\n    (check_0 : gf_t) = w ^ SYS_T\n    (check_1 : gf_t) = loop_3 0 check_0\n    (check_2 : gf_t) = (check_1 -1)>> 15\n    (check : gf_t) = check_2 ^ 1\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/decrypt_helpers.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the McEliece KEM low-level decryption helper functions `eval`, `root`, `synd`, and `bm`, matching the given interfaces over the Goppa\/code parameters and finite-field operations, suitable for formal verification of the decryption algorithm."},{"role":"assistant","content":"```cryptol\nmodule Decrypt_helpers where\n\nimport Types\nimport GF\nimport Util\n\neval f a = out where\n    loop_i i r =\n        if (i<0) then r\n        else loop_i i' r' where\n            r' = gf_add (gf_mul r a) (f@i)\n            i' = i-1\n    r_init = f@SYS_T\n    i_init = SYS_T-1\n    out = loop_i i_init r_init\n\nroot : g_t ->  SYS_N_t -> SYS_N_t\nroot f L = out where\n    out = [ eval f l | l <- L]\n\nsynd : g_t -> L_t -> r_t -> s_t\nsynd f L r = out' where\n    loop_j i j out e_inv c =\n        if (j<SYS_T_double)\n        then (loop_j i j' out' e_inv' c) where\n            j' = j+1\n            x = gf_mul e_inv c\n            y = gf_add (out@j) x\n            out' = update out j y\n            e_inv' = gf_mul e_inv (L@i)\n        else (out, e_inv)\n\n    loop_i i out e_inv c =\n        if (i<SYS_N)\n        then loop_i i' out' e_inv' c where\n            c = (r@(i\/8) >> (i%8)) && (1:[16])\n            e = eval f (L@i)\n            e_inv = gf_inv (gf_mul e e)\n            (out', e_inv') = loop_j i 0 out e_inv c\n            i' = i+1\n        else out\n    out' = loop_i 0 zero 0 0\n\nbm : s_t-> g_t\nbm s = out where\n    N_limit =  2 * SYS_T\n    outer_loop N B C T L b =\n        if (N<N_limit) then (outer_loop N_2 B_3 C_2 T_2 L_2 b_2) where\n            (d_0 : gf_t) = zero\n            limit = min N SYS_T\n            loop_1 i d  =\n                if(i < limit)\n                then loop_1 i' d' where\n                    d' = d ^ (gf_mul (C@i) (s@(N-i)))\n                    i' = i+1\n                else d\n            (d_1 : gf_t) = loop_1 0 d_0\n            (mne: uint16t) = ((d_1 - (1:[16]))>> 15) - (1:[16])\n            (mle_0: uint16t)= ((N - (2:[16])*L) >> 15) - (1:[16])\n            (mle_1: uint16t) = mle_0 && mne\n            (T_2 : SYS_T_plus1) = C\n            (f: gf_t) = gf_frac b d_1\n            (C_2: SYS_T_plus1) =\n                [c ^ ((gf_mul f (B@i)) && mne)\n                | i <- [0.. 120]\n                | c <- C]\n            (L_2: uint16t) = (L && ~mle_1) || ((N+1-L) && mle_1)\n            (B_2: SYS_T_plus1) =\n                [((b && ~mle_1) || (t && mle_1)) | b <- B | t <- T]\n            b_2 = (b && ~mle_1) || (d_1 && mle_1)\n            (B_3: SYS_T_plus1) = zero # (take `{119} B_2)\n            N_2 = N+1\n        else C\n    (N : uint16t) = 0\n    (L : uint16t) = 0\n    (B_0 : SYS_T_plus1) = zero\n    (B_1 : SYS_T_plus1) = update B_0 1 1\n    (C_0 : SYS_T_plus1) = zero\n    (C_1 : SYS_T_plus1) = update C_0 0 1\n    (T : SYS_T_plus1) = zero\n    (b : gf_t) = 1\n    (C_2 : SYS_T_plus1)= outer_loop N B_1 C_1 T L b\n    out = reverse C_2\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/types.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Types` for the low-level McEliece KEM parameters and types, including all listed constants, type synonyms, and conversion functions with the same names, sizes, and relationships as in the given specification."},{"role":"assistant","content":"```cryptol\nmodule Types where\n\nSYS_T = 119\nSYS_N = 6960\nSYS_Nd8 = SYS_N\/8 \nGFBITS =  13\ntype GFBITS_t =  13\nCOND_BYTES  = (((1:[32]) << (GFBITS-(4:[32])))*(2*GFBITS - (1:[32])))\nIRR_BYTES = (SYS_T * 2)\nPK_NROWS  =  (SYS_T*GFBITS)\nPK_NCOLS  =  (SYS_N - PK_NROWS)\nPK_ROW_BYTES  =  ((PK_NCOLS + 7)\/8)\ntype PK_ROW_BYTES_t = [677]\nSK_BYTES  =  (SYS_Nd8 + IRR_BYTES + COND_BYTES)\nSYND_BYTES  =  ((PK_NROWS + 7)\/8)\ntype SYND_BYTES_t = [194]\nGFMASK  =  (((1:[32]) << GFBITS) - 1)\ntype j_size_t =  1024 \n\ntype base_16t = [16]\ntype base_32t = [32]\ntype base_64t = [64]\ntype uint16t = [16]\ntype uint64t = [64]\ntype uint32t = [32]\ntype base_t = base_16t\ntype gf_t = base_t\n\ntype ciphertext_t = [226] base_t    type keybytes_t = [32] base_t type publickey_t = [1047319]base_t type secretkey_t = [13908] base_t \ntype g_s_t =   ciphertext_t\ntype g_ct_t =  ciphertext_t\ntype g_key_t = keybytes_t\ntype g_pk_t =  publickey_t\ntype g_sk_t = secretkey_t\n\ntype SYS_N8_t = [870] base_t\ntype SYS_N8_plus1_t = [871] base_t\ntype SYS_N8_plus2_t = [872]base_t\n\nSYS_T_double = 238type SYS_T_double_t = [238]base_t\ntype SYS_N_t = [6960]base_t\ntype SYS_T_plus1 = [120]base_t\n\ntype L_t = SYS_N_t type f_t = SYS_N8_t\ntype r_t = SYS_N8_t\ntype g_t = SYS_T_plus1\ntype s_t = SYS_T_double_t \ntype e_t = SYS_N8_plus2_t\ntype ind_t = SYS_T_double_t\ntype e_int_t = [109]base_t\ntype val_t = [119] base_t\ntype e_pieces_t = [109][8]base_t\n\ntype pm_t =  [1097]base_t \n\ncvt_16 e = fromInteger `{[16]} (toInteger e)\ncvt_32 e = fromInteger `{[32]} (toInteger e)\ncvt_64 e = fromInteger `{[64]} (toInteger e)\ncvt_32_to_16 e = cvt_16 e\ncvt_64_to_16 e = cvt_16 e\ncvt_16_to_32 e = cvt_32 e\ncvt_20_to_64 e = cvt_64 e\ncvt_16_to_64 e = cvt_64 e\ncvt_36_to_64 e = cvt_64 e\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/low-level\/encrypt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that fully defines the McEliece KEM low-level encryption functionality, including complete implementations of gen_e, syndrome, and encrypt, with appropriate types and any necessary properties for correctness or equivalence checking."},{"role":"assistant","content":"```cryptol\nmodule Encrypt where\n\nimport Types\nimport Util\n\nmov_forward : ind_t -> (ind_t, Bool)\nmov_forward ind_0 = outer_loop 0 ind_0 False where\n    inner_loop : _ -> _ -> ind_t -> Bool -> (ind_t, Bool)\n    inner_loop j i ind found =\n        if (j < (SYS_T* 2))\n        then if(jval<SYS_N)\n            then inner_loop (j+1) i ind' found'\n            else inner_loop (j+1) i ind found\n        else (ind, found)\n        where\n            (jval : base_t) = ind@j\n            (ind' : ind_t) = update (update ind j (ind@i)) i jval\n            found' = True\n    outer_loop : _ -> ind_t -> Bool -> (ind_t, Bool)\n    outer_loop i ind found =\n        if (i < SYS_T)\n        then if(found')\n            then outer_loop (i+1) ind' found'\n            else (ind', found')\n            where\n                (ind', found') = inner_loop i i ind found\n        else (ind, found)\n\n\/\/ --------------------------------------------- while for loops\nloop_x i ind = if (i<SYS_T*2) then loop_x (i+1) ind' else ind\n    where\n    ind' = update ind i ((ind@i) && GFMASK)\n\n\/\/ when find equal value returns true\nloop_findEq : ind_t  -> _ -> Bool -> Bool\nloop_findEq ind i rtn = if (i<SYS_T) then rtn' else rtn\n    where\n        loop_z : ind_t -> _ -> _ -> Bool\n        loop_z ind i j =\n            if(j<i)\n            then\n                if((ind@i) == (ind@j))\n                then True\n                else loop_z ind i (j+1)\n            else False\n        rtn' = if(loop_z ind i 0)\n            then True\n            else loop_findEq ind (i+1) rtn\n\n\/\/ While_loop : Might consider adding a limit to the counter here\nwhile_loop : ind_t -> ind_t\nwhile_loop ind =\n    if(loop_findEq ind_2 1 False) then ind_2 else while_loop ind_2\n    where ind_2 = loop_x 0 ind\n\n\/\/ --------------------------------------------- gen_e for loops\n\/\/ implements val[j] = one << (ind[j] & 63)\nloop_a : base_t -> val_t ->ind_t -> val_t\nloop_a j val ind =\n    if (j<SYS_T) then loop_a (j+1) val' ind else val\n    where\n        x = 1 << ((ind@j) && 63)\n        val' = update val j x\n\n\/\/nested for loop\nloop_c : base_t ->  val_t -> ind_t -> e_int_t -> e_int_t\nloop_c i val ind e_int  =\n    if(i < (SYS_N+63)\/64) then e_int' else e_int\n    where\n    (e_int' : e_int_t) = loop_b 0 i val ind e_int\n    loop_b : base_t -> base_t -> val_t -> ind_t -> e_int_t -> e_int_t\n    loop_b j i val ind e_int =\n        if (j<SYS_T) then loop_b (j+1) i val ind e_int' else e_int\n        where\n            (mask_0 : base_t) =cvt_16 (ind@j)\n            (mask_1 : base_t) = i^(mask_0 >> 6)\n            (mask_2 : base_t) = mask_1-1\n            (mask_3 : base_t) = mask_2 >> 63\n            (mask : base_t) = -1* mask_2\n            (m : base_t) = e_int@i\n            (n : base_t) = (val@j) && mask\n            (o : base_t) = m ||  n\n            (e_int' : e_int_t) = update e_int i o\n\n\/\/ store in groups of 8\nloop_d : _ ->  e_int_t -> e_pieces_t ->  e_t\nloop_d i e_int e_pieces =\n    if (i < (SYS_N+63)\/64 - 1)\n    then loop_d (i+1) e_int e_pieces'\n    else join e_pieces\n    where\n        (x : [8]base_t) = store8 (e_pieces@i) (e_int@i)\n        (e_pieces' : e_pieces_t) = update e_pieces i x\n\n\/\/shift each value by j and && with 0xFF\nloop_e : _ -> _ -> e_int_t -> e_t -> e_t\nloop_e j i e_int e =\n    if (j<(SYS_N % 64)) then loop_e (j+8) i e_int e' else e\n    where\n        (w : base_t) = (e_int@i) >> j\n        (x : base_t) = w && (cvt_16 0xFF)\n        (e' : [872]base_t) = update e (j\/8) x\n\ngen_e : e_t -> e_t\ngen_e e = undefined where\n    (val_1 : val_t) = zero\n    (ind_1 : ind_t) = zero\n    (e_int_1 : e_int_t) = zero\n    (ind_2 : ind_t)  = while_loop ind_1\n    (val_2 : val_t) = loop_a 0 val_1 ind_2\n    (e_int_2 : e_int_t) = loop_c 0 val_2 ind_2 e_int_1\n    (e_pieces_1 : e_pieces_t) = groupBy `{8} e\n    (e_2 : e_t) = loop_d 0 e_int_2 e_pieces_1\n    (i : [16]) = (SYS_N+63)\/64 - 1 \/\/max at previous loop\n    (e_3 : e_t) = loop_e 0 i e_int_2 e_2\n\nsyndrome : g_pk_t -> e_t -> g_s_t -> g_s_t\nsyndrome pk e s_in = s_out where\n    tail = PK_NROWS % 8\n    \/\/ PK_ROW_BYTES = 677\n    \/\/ PK_NROWS = 1547\n    pk_short = take `{1047319} pk \/\/ PK_ROW_BYTES * PK_NROWS (right size)\n    pk_ptr = groupBy `{677} pk_short\n    loop_c : _ -> SYS_N8_t -> SYS_N8_t\n    loop_c j row =\n        if (j >= SYS_N\/8 - PK_ROW_BYTES)\n        then loop_c (j-1) row'\n        else row\n        where\n            a = (row @ j) << tail\n            b = (row @ (j-1)) >> (8-tail)\n            c = a||b\n            row' = update row j c\n    loop_d : _ -> base_t -> SYS_N8_t -> base_t\n    loop_d j b row =\n        if (j < (SYS_N\/8))\n        then loop_d (j+1) ((row@j) && (e@j)) row\n        else b\n    second_loop : _ -> g_s_t -> g_s_t\n    second_loop i s =\n        if (i < PK_NROWS)\n        then second_loop (i+1) s_out\n        else s\n        where\n            (row_1 : SYS_N8_t) =  zero # (pk_ptr@i)\n            (row_2 : SYS_N8_t) = loop_c (SYS_N\/8-1) row_1\n            (d : base_t) =  (row_2@(i\/8))|| (1 << (i%8))\n            (row_3 : SYS_N8_t) =  update row_2 (i\/8) d\n            (b_0 : base_t) = loop_d 0 0 row_3\n            (b_1 : base_t) = b_0 ^ (b_0>>4)\n            (b_2 : base_t) = b_1 ^ (b_1>>2)\n            (b_3 : base_t) = b_2 ^ (b_2>>1)\n            (b_4 : base_t) = b_3 && 1\n            (sval : base_t) =  (s@(i\/8)) || (b_4 << (i%8))\n            (s_out : g_s_t) =  update s (i\/8) sval\n    (s : g_s_t) = zero # (drop `{194} s_in)\n    s_out = second_loop 0 s\n\nencrypt : g_s_t -> g_pk_t -> e_t -> g_s_t\nencrypt s pk e = s where\n    (e' : e_t) = gen_e e\n    (s : g_s_t) = syndrome pk e' s\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/CM_Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module CM_Parameters that defines the types a_ty, CM, byte_rep, the function make_mk : a_ty -> a_ty -> a_ty -> a_ty -> CM, and the predicate mk_ok : CM -> Bool enforcing the given McEliece KEM parameter constraints."},{"role":"assistant","content":"```cryptol\nmodule CM_Parameters where\n\ntype a_ty = [32]\n\ntype CM =\n    { m : a_ty      , q : a_ty      , n : a_ty      , t : a_ty      , k : a_ty      , d : a_ty     }\n\ntype byte_rep n = [n\/8][8] Bit\n\nmake_mk : a_ty -> a_ty -> a_ty -> a_ty -> CM \nmake_mk m n t d =\n    { m = m : a_ty\n    , q = (2^m) : a_ty\n    , n = n : a_ty\n    , t = t : a_ty\n    , k = (n-m*t) : a_ty\n    , d = d : a_ty\n    }\n\nmk_ok : CM -> Bool\nmk_ok cm =\n    ((is_pos m) \/\\ (n_ok) \/\\ (t_ok) \/\\ (is_pos cm.d))\n    where\n        m = cm.m\n        n = cm.n\n        t = cm.t\n        is_pos e = e>0\n        n_ok = ((is_pos n) \/\\ (n <= cm.q))\n        t_ok = (t>=2) \/\\ (m*t <n)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/CM_696.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define in Cryptol the constant `cm696 : CM` in module `CM_696` with parameters m=13, q=2^13, n=6960, t=119, k=5413, and d=256, using the type `a_ty` and record type `CM` imported from `CM_Parameters`."},{"role":"assistant","content":"```cryptol\nmodule CM_696 where\n\nimport CM_Parameters\n\ncm696  =\n    { m = 13 : a_ty\n    , q = (2^13) : a_ty\n    , n = 6960 : a_ty\n    , t = 119 : a_ty\n    , k = 5413 : a_ty\n    , d = 256 : a_ty\n    } : CM\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/Encapsulation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Encapsulation` specifying the McEliece KEM encapsulation algorithm, including types, `step_1`, `step_2`, `encoding_subroutine`, `compute_hash_1e`, `compute_hash_2e`, and `encapsulation : public_key_T -> weighted_T -> (session_key_t, cipher_text_T)` with appropriate constraints and structures."},{"role":"assistant","content":"```cryptol\nmodule Encapsulation where\n\nparameter\n    type t : #\n    type constraint (fin t, t>=1, t-1>=1)\n    type n : #\n    type constraint (fin n, n>=1)\n    type m : #\n    type constraint (fin m, m>=1, t * n == min t n)\n    type d : #\n\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [(n-m*t)]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [m*t]f2_T  type H_T = [t][n]field_element_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                    , a : alphas_T                  }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                       , g : gamma_T\n    }\ntype public_key_T = [m*t][(n-m*t)]f2_T\ntype C0_T = mt_T\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\n\ntype weighted_T = n_T\n\nstep_1 : mt_T -> public_key_T -> H_T\nstep_1 I A = zero\n\nstep_2 : H_T -> weighted_T -> C0_T\nstep_2 H e = zero\n\nencoding_subroutine : weighted_T -> public_key_T -> C0_T\nencoding_subroutine e T = C0 where\n    (I: mt_T) = zero\n    (H:H_T) = step_1 I T         (C0:C0_T) = step_2 H e\n\ntype session_key_t = [32] compute_hash_2e e = undefined\ncompute_hash_1e e C = undefined\n\nencapsulation\n    : public_key_T ->  weighted_T\n    -> (session_key_t, cipher_text_T)\nencapsulation T e =  (K, C) where\n            (C0 : C0_T) = encoding_subroutine e T\n        (C1: C1_T) = compute_hash_2e e\n    (C: cipher_text_T) = {C0 = C0, C1 = C1}\n    (K: session_key_t) = compute_hash_1e e C\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/CM_819.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the constant `CM_819 : CM` in a `CM_819` module, setting the McEliece parameter record fields `m`, `q`, `n`, `t`, `k`, and `d` exactly as specified for the CM_819 parameter set."},{"role":"assistant","content":"```cryptol\nmodule CM_819 where\n\nimport CM_Parameters\n\nCM_819 =\n    { m = 13 : a_ty\n    , q = (2^13) : a_ty\n    , n = 8192 : a_ty\n    , t = 128 : a_ty\n    , k = (8192-(13*128)) : a_ty\n    , d = 256 : a_ty\n    } : CM\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/Key_Generation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for McEliece KEM key generation, defining all given types, the functions random_element, random_elements, step_3, step_5, mk_gamma, and key_generation, and suitable properties to verify that key_generation correctly produces matching public and private keys."},{"role":"assistant","content":"```cryptol\nmodule Key_Generation where\n\nparameter\n    type t : #\n    type constraint (fin t, t>=1, t-1>=1)\n    type n : #\n    type constraint (fin n, n>=1)\n    type m : #\n    type constraint (fin m, m>=1, t * n == min t n)\n    type d : #\n\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [(n-m*t)]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [m*t]f2_T\ntype H_T = [t][n]field_element_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                    , a : alphas_T                  }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                       , g : gamma_T\n    }\ntype public_key_T = [m*t][(n-m*t)]f2_T\ntype C0_T = mt_T\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\ntype e_T =\n    { length : n_T\n    , hammington_weight : t_T\n    }\n\nrandom_element : field_element_T\nrandom_element = ([True | i <- [1..m]])\nrandom_elements : {t0}(fin t0, t0>=1) => [t0]field_element_T\nrandom_elements = ([random_element | i <- [1..t0]])\n\nstep_1 = random_elements `{ t0 = t-1}#[1]\n\nstep_3 : (t * n == min t n) =>  poly_T -> alphas_T -> H_T\nstep_3 g alphas = [[ f i j | j <- [1..n]] | i <- [1..t]]\n    where f i j = aj \/ (g @ aj)\n            where aj = alphas@j\n\nstep_5 : H_T -> (Bool, public_key_T)\nstep_5 H_tilde = undefined\n\nmk_gamma : Integer -> (gamma_T,public_key_T)\nmk_gamma counter =\n    if(flag) then ({p=g, a=alphas}, public_key)\n    else if (counter < 100)\n        then mk_gamma (counter+1)\n    else undefined\n    where\n                (g: poly_T) = step_1\n        (alphas: alphas_T) =  random_elements `{ t0 = n}\n        (H_tilde: H_T) = step_3 g alphas\n        (flag, public_key) = step_5 H_tilde\n\nkey_generation : [n]Bit -> (public_key_T, private_key_T)\nkey_generation s = (public_key, private_key) where\n    (gamma: gamma_T, public_key: public_key_T) = mk_gamma 0\n    (private_key: private_key_T) = {s=s, g=gamma}\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/spec\/Types.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `Types` that specifies all McEliece KEM type parameters and derived types (f2_T, n_T, k_T, t_T, m_T, mt_T, H_T, d_T, field_element_T, poly_T, alphas_T, gamma_T, s_T, private_key_T, public_key_T, C0_T, C1_T, cipher_text_T, hash_input_T, weighted_T) with the given constraints."},{"role":"assistant","content":"```cryptol\nmodule Types where\n\nparameter\n    type t : #\n    type constraint (fin t, t>=1, t-1>=1)\n    type n : #\n    type constraint (fin n, n>=1)\n    type m : #\n    type constraint (fin m, m>=1, t * n == min t n)\n    type d : #\n\ntype f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [(n-m*t)]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [m*t]f2_T  type H_T = [t][n]field_element_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                    , a : alphas_T                  }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                       , g : gamma_T\n    }\ntype public_key_T = [m*t][(n-m*t)]f2_T\ntype C0_T = mt_T\ntype C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\n\ntype weighted_T = n_T\n\n-------------\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/keccak.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Keccak` implementing the Keccak-f permutation and sponge construction, defining SHA3-224\/256\/384\/512, SHAKE128\/256, cSHAKE128\/256, along with the given padding, (un)flattening, LFSR-based round constants, and properties RC_correct, unflatten_correct, flatten_correct, and all listed SHA-3\/SHAKE test-vector properties."},{"role":"assistant","content":"```cryptol\nmodule Keccak where\n\nSHA_3_224 M = take`{224} (Keccak `{r = 1152, c =  448} (M # 0b01))\nSHA_3_256 M = take`{256} (Keccak `{r = 1088, c =  512} (M # 0b01))\nSHA_3_384 M = take`{384} (Keccak `{r =  832, c =  768} (M # 0b01))\nSHA_3_512 M = take`{512} (Keccak `{r =  576, c = 1024} (M # 0b01))\nSHAKE128 M = Keccak`{r = 1344, c = 256} (M # 0b1111)\nSHAKE256 M = Keccak`{r = 1088, c = 512} (M # 0b1111)\n\nCSHAKE128 M s1 s2 = if (s1 == \"\" \/\\ s2 == \"\") then (SHAKE128 M)\n                                               else (Keccak`{r = 1344, c = 256} (join(s1)#join(s2)#M#0b00))\n\nCSHAKE256 M s1 s2 = if (s1 == \"\" \/\\ s2 == \"\") then (SHAKE256 M)\n                                               else (Keccak`{r = 1088, c = 512} (join(s1)#join(s2)#M#0b00))\n\nKeccak : {r, c, m}\n  ( fin r, fin c, fin m\n  , r >= 1\n  , (r + c) % 25 == 0\n  , 64 >= (r + c) \/ 25\n  ) => [m] -> [inf]\nKeccak M = squeeze `{r = r} (absorb `{w = (r + c) \/ 25} Ps)\n  where Ps = pad `{r = r} M\n\nsqueeze : {r, w} (fin r, fin w, 64 >= w, r >= 0, 25 * w >= r) => [5][5][w] -> [inf]\nsqueeze A = take`{r} (flatten A) # squeeze`{r = r} (Keccak_f A)\n\nabsorb : {r, w, n} (fin r, fin w, fin n, 64 >= w, 25 * w >= r) => [n][r] -> [5][5][w]\nabsorb Ps = as ! 0\n  where\n    as = [zero] # [ Keccak_f `{w = w} (s ^ (unflatten p)) | s <- as | p <- Ps ]\n\npad : {r, m}\n  ( fin r, fin m\n  , r >= 1\n  ) => [m] -> [(m + 2) \/^ r][r]\n\npad M = split (M # [True] # zero # [True])\n\nKeccak_f : {w} (fin w, 64 >= w) => [5][5][w] -> [5][5][w]\nKeccak_f A0 = rounds ! 0\n  where\n    rounds = [A0] # [ Round RC A | RC <- RCs`{w = w} | A <- rounds ]\n\nRound : {w} (fin w) => [5][5][w] -> [5][5][w] -> [5][5][w]\nRound RC A = \u03b9 RC (\u03c7 (\u03c0 (\u03c1 (\u03b8 A))))\n\n\u03b8 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03b8 A = A'\n  where\n    C = [ xor a | a <- A ]\n    D = [ C @ x ^ (C @ y <<< 1)\n        | (x:[8]) <- [4,0,1,2,3]\n        | (y:[8]) <- [1,2,3,4,0]\n        ]\n    A' = [ [ a ^ (D @ x) | a <- A @ x ] | (x:[8]) <- [0 .. 4] ]\n\n\u03c1 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03c1 A = groupBy`{5} [ a <<< r | a <- join A | (r:[8]) <- R ]\n  where R = [00, 36, 03, 41, 18,\n             01, 44, 10, 45, 02,\n             62, 06, 43, 15, 61,\n             28, 55, 25, 21, 56,\n             27, 20, 39, 08, 14]\n\n\u03c0 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03c0 A = groupBy`{5} [ A @ ((x + 3*y) % 5) @ x\n                  | (x:[8]) <- [0..4], (y:[8]) <- [0..4]\n                  ]\n\n\u03c7 : {w} (fin w) => [5][5][w] -> [5][5][w]\n\u03c7 A = groupBy`{5} [ (A @ x @ y) ^ (~ A @ ((x + 1) % 5) @ y\n                                  && A @ ((x + 2) % 5) @ y)\n                  | (x:[8]) <- [0..4], (y:[8]) <- [0..4]\n                  ]\n\n\u03b9 : {w} (fin w) => [5][5][w] -> [5][5][w] -> [5][5][w]\n\u03b9 RC A = A ^ RC\n\nRCs : {w, n} (fin w, fin n, 24 >= n, n == 12 + 2 * (lg2 w)) => [n][5][5][w]\nRCs = take`{n} [ [[take`{w} RC] # zero] # zero | RC <- RCs64 ]\n\nRCs64 : [24][64]\nRCs64 = join (transpose [\n    [0x0000000000000001, 0x000000008000808B],\n    [0x0000000000008082, 0x800000000000008B],\n    [0x800000000000808A, 0x8000000000008089],\n    [0x8000000080008000, 0x8000000000008003],\n    [0x000000000000808B, 0x8000000000008002],\n    [0x0000000080000001, 0x8000000000000080],\n    [0x8000000080008081, 0x000000000000800A],\n    [0x8000000000008009, 0x800000008000000A],\n    [0x000000000000008A, 0x8000000080008081],\n    [0x0000000000000088, 0x8000000000008080],\n    [0x0000000080008009, 0x0000000080000001],\n    [0x000000008000000A, 0x8000000080008008]\n])\n\nunflatten : {r, w} (fin w, 25*w >= r) => [r] -> [5][5][w]\nunflatten p = transpose (groupBy`{5} (reverse (groupBy`{w} (reverse (p # zero)))))\n\nflatten : {w} (fin w) => [5][5][w] -> [5 * 5 * w]\nflatten A = reverse (join (reverse (join (transpose A))))\n\nxor : {a, b} (fin a) => [a][b] -> [b]\nxor xs = xors ! 0\n  where xors = [zero] # [ x ^ z | x <- xs | z <- xors ]\n\nproperty RC_correct i j =\n  (i:[8]) < 24 ==> (j:[8]) < 7 ==> RCs64@i!(2^^j - 1) == lfsr@(j + 7*i)\n\nlfsr : [inf]\nlfsr = [ p!0 | p <- ps ]\n  where\n\n    ps = [0x01] # [ pmod (pmult p 0b10) m | p <- ps ]\n    m = <| x^^8 + x^^6 + x^^5 + x^^4 + 1 |>\n\nproperty unflatten_correct x y z p =\n  x < 5 ==> y < 5 ==> z < (64:[12]) ==>\n  p@((5*y + x)*64 + z) == unflatten`{1600,64} p @ x @ y ! z\n\nproperty flatten_correct s =\n  unflatten`{1600,64} (flatten`{64} s) == s\n\ntoBytes : {n} (fin n) => [8*n] -> [n][8]\ntoBytes s = reverse (split (reverse s))\n\nfromBytes : {n} (fin n) => [n][8] -> [8*n]\nfromBytes bs = reverse (join (reverse bs))\n\nproperty t1 = join (toBytes (SHA_3_224 [])) ==\n  0x6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7\nproperty t2 = join (toBytes (SHA_3_256 [])) ==\n  0xa7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a\nproperty t3 = join (toBytes (SHA_3_384 [])) ==\n  0x0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004\nproperty t4 = join (toBytes (SHA_3_512 [])) ==\n  0xa69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26\n\nproperty u1 = join (toBytes (SHA_3_224 0b11001)) ==\n  0xffbad5da96bad71789330206dc6768ecaeb1b32dca6b3301489674ab\nproperty u2 = join (toBytes (SHA_3_256 0b11001)) ==\n  0x7b0047cf5a456882363cbf0fb05322cf65f4b7059a46365e830132e3b5d957af\nproperty u3 = join (toBytes (SHA_3_384 0b11001)) ==\n  0x737c9b491885e9bf7428e792741a7bf8dca9653471c3e148473f2c236b6a0a6455eb1dce9f779b4b6b237fef171b1c64\nproperty u4 = join (toBytes (SHA_3_512 0b11001)) ==\n  0xa13e01494114c09800622a70288c432121ce70039d753cadd2e006e4d961cb27544c1481e5814bdceb53be6733d5e099795e5e81918addb058e22a9f24883f37\n\nmsg1600 : [1600]\nmsg1600 = join [ 0b11000101 | _ <- zero : [200] ]\n\nproperty v1 = join (toBytes (SHA_3_224 msg1600)) ==\n  0x9376816aba503f72f96ce7eb65ac095deee3be4bf9bbc2a1cb7e11e0\n\nproperty w1 = join (toBytes (SHA_3_224 (msg1600 # 0b11000))) ==\n  0x22d2f7bb0b173fd8c19686f9173166e3ee62738047d7eadd69efb228\n\nproperty k1 = join (toBytes (take`{512} (SHAKE128 []))) == 0x7f9c2ba4e88f827d616045507605853ed73b8093f6efbc88eb1a6eacfa66ef263cb1eea988004b93103cfb0aeefd2a686e01fa4a58e8a3639ca8a1e3f9ae57e2\n\nproperty k2 = join (toBytes (take`{512} (SHAKE128 0b0))) == 0xe78b86559a9ccdc72288bf7bcf8e11d574543a2922978913a02be149e89d03cae63d2c36e2cf6906791b187d7e371d4f21ebe59dcfc249a510b82255a18250dd\n\nproperty k3 = join (toBytes (take`{512} (SHAKE128 0b11))) == 0xf6b6c4093f0a2ceba61b9f2c2fea2ca238ce9005edcd588c380405070532ddd00cbd3a3a7448017d874c52c9e383fa3db1c184e023181fcc8550f53ac92feca5\n\nproperty k4 = join (toBytes (take`{512} (SHAKE256 []))) == 0x46b9dd2b0ba88d13233b3feb743eeb243fcd52ea62b81b82b50c27646ed5762fd75dc4ddd8c0f200cb05019d67b592f6fc821c49479ab48640292eacb3b7c4be\n\nproperty k5 = join (toBytes (take`{512} (SHAKE256 0b0))) == 0x1e20b13f3bdb730d286913335c092bcec0eb1aff2798c05736faa93bd665807a48ed7652aefd600427e9f797d647b9b355d30410d71b8e275a676545600f1c35\n\nproperty k6 = join (toBytes (take`{512} (SHAKE256 0b11))) == 0x4f86b0eb85f7a9f6dc38b622706948adb2beb6dd6911b5e9d865fd1f9667b5c02a0dbb39c488b040a18ff3885f04ef957c98f3948e6b7959a9b8950ffd6345d5\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Shared.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Shared` that specifies the McEliece KEM shared functionality, including types and functions `compute_He : H_T -> e_T -> C0_T`, `compute_H : public_key_T -> H_T`, `compute_hash_e : Integer -> e_T -> C1_T`, and `compute_hash_eC : Integer -> e_T -> cipher_text_T -> session_key_T`."},{"role":"assistant","content":"```cryptol\nmodule Shared where\n\nimport Types\nimport Keccak\n\ncvt_bit_int b = if(b) then 1 else 0\ncvt_int_bit i = if(i==1) then True else False\n\ncompute_He : H_T -> e_T -> C0_T\ncompute_He H e =\n    [ cvt_int_bit (sum (f hi)) | hi <- H ]\n        where f hi = [ (cvt_bit_int hij) * (cvt_bit_int ej)\n            |  ej <- e | hij <- hi]\n\ncompute_H : public_key_T -> H_T\ncompute_H T =\n    [ (I i) # T@i | i <- [0..(n-k-1)]]\n    where I i = (update zero i True)\n\ncompute_hash_e : Integer -> e_T -> C1_T\ncompute_hash_e  i e = out where\n    (a: [8]) = fromInteger `{[8]} i\n    (x:[inf]) = SHAKE256 ((fromInteger `{[8]} i) # e)\n    (out: C1_T) = take `{256} x\n\ncompute_hash_eC\n    : Integer -> e_T -> cipher_text_T -> session_key_T\ncompute_hash_eC  i e C = out where\n    (a: [8]) = fromInteger `{[8]} i\n    (x:[inf]) = SHAKE256 (a # e # C.C0 # C.C1)\n    (out: session_key_T) = take `{32} x\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Decapsulation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the McEliece KEM decapsulation algorithm, defining the functions `get_weight`, `check_e`, `decrypt`, and `decapsulation` with the given types and using the imported operations (`compute_H`, `compute_He`, `compute_hash_e`, `compute_hash_eC`, `fn_get_goppa_T`)."},{"role":"assistant","content":"```cryptol\nmodule Decapsulation where\n\nimport Types\nimport Shared\n\nget_weight : n_T  -> Integer\nget_weight e = sum ([cvt_bit_int i | i <- e])\n\ncheck_e : e_T -> public_key_T -> C0_T -> (e_T, Bool)\ncheck_e e public_key C0 =\n    if((get_weight e == glob_t) && (C0 == C0'))\n    then (e, True)\n    else (zero, False)\n    where\n        \/\/ checks that \"C0 = He\"\n        (H: H_T) = compute_H public_key\n        (C0':C0_T) = compute_He H e\n\ndecrypt\n    : C0_T -> private_key_T -> public_key_T -> fn_get_goppa_T\n    -> (e_T, Bool)\ndecrypt C0 private_key public_key get_goppa = (e, dec_pass) where\n    (failure : (e_T, Bool)) = (zero, False)\n    (s : n_T) = private_key.s\n    (gamma : gamma_T) = private_key.g\n        (v:n_T) = C0#zero\n        (c:n_T, goppa_pass) = get_goppa gamma\n    (e, dec_pass) =\n        if(~ goppa_pass)\n        then failure\n        else (check_e e public_key C0)             where\n                        (e :e_T) = v+c\n\ndecapsulation\n    : cipher_text_T -> private_key_T -> public_key_T -> fn_get_goppa_T\n    -> session_key_T\ndecapsulation C private_key public_key get_goppa =  K where\n        C0 = C.C0\n    C1 = C.C1\n    s = private_key.s\n    gamma = private_key.g\n        b_1 = 1\n        (e_1:e_T, dec_pass) = decrypt C0 private_key public_key get_goppa\n    (e_2:e_T, b_2) =\n        if(dec_pass)\n        then (e_1, b_1)\n        else (s, 0)         (C1': C1_T) = compute_hash_e 2 e_2\n    \/\/step 5 : Compare C1\n    (e_3:e_T, b_3) =\n        if(C1==C1')\n        then (e_2, b_2)\n        else (s, 0)\n        (K: session_key_T) = compute_hash_eC b_2 e_3 C\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Encapsulation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the McEliece KEM high-level encapsulation algorithm, including `encoding_subroutine : e_T -> public_key_T -> C0_T` and `encapsulation : public_key_T -> e_T -> (session_key_T, cipher_text_T)`, using the imported `Types` and `Shared` objects, and ensure the construction of `C0`, `C1`, `C`, and `K` matches the given structure."},{"role":"assistant","content":"```cryptol\nmodule Encapsulation where\n\nimport Types\nimport Shared \n\nencoding_subroutine : e_T -> public_key_T -> C0_T\nencoding_subroutine e T = C0 where\n    (H:H_T) = compute_H T\n    (C0:C0_T) = compute_He H e\n\nencapsulation\n    : public_key_T ->  e_T\n    -> (session_key_T, cipher_text_T)\nencapsulation T e =  (K, C) where\n            (C0 : C0_T) = encoding_subroutine e T\n        (C1: C1_T) = compute_hash_e 2 e\n    (C: cipher_text_T) = {C0 = C0, C1 = C1}\n    (K: session_key_T) = compute_hash_eC 1 e C\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/decrypt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the Cryptol function decrypt_1 : ciphertext_t -> secretkey_t -> (SYS_N8_t, gf_t) implementing the McEliece KEM decryption step, including any necessary helper types\/functions and suitable properties to validate its correctness against the high-level McEliece decrypt algorithm."},{"role":"assistant","content":"```cryptol\nmodule Decrypt where\n\nimport Types\nimport Shared\nimport Benes\nimport Decrypt_helpers\nimport GF\nimport Util\n\ndecrypt_1\n    : ciphertext_t ->  secretkey_t\n    -> (SYS_N8_t, gf_t)\ndecrypt_1 c sk = (e, check) where\n    (r : SYS_N8_t) = (take `{194} c)#zero\n    loop_1 g i sk_index =\n        if i < glob_t\n        then loop_1 g' (i+1) (sk_index+2) where\n            (a : gf_t)= load2 sk sk_index\n            (b : gf_t) = a && cvt_16 GFMASK\n            g'= update g i b\n        else g\n    (g_0 : SYS_T_plus1) = zero\n    (g_1 : SYS_T_plus1) = loop_1 g_0 0 0\n    (L : SYS_N_t) = support_gen sk\n    (s : SYS_T_double_t) = synd g_1 L r\n    (locator : SYS_T_plus1) = bm s\n    (images : SYS_N_t) = root locator L\n    loop_2 : [32] -> SYS_N8_t -> gf_t -> (SYS_N8_t, gf_t)\n    loop_2 i e w =\n        if (i<glob_n)\n        then loop_2 (i+1) e' w' where\n            (t : gf_t) = (gf_iszero (images @i)) && (1:[16])\n            jx = i\/8\n            val = (e@jx) || t << (i%8)\n            (e' :SYS_N8_t) = update e jx val\n            (w' : gf_t) = w+t\n        else (e, w)\n    (e :SYS_N8_t, w : gf_t) = loop_2 0 zero 0\n    (s_cmp : SYS_T_double_t) = synd g_1 L e\n    loop_3 i check =\n        if (i<glob_t*2)\n        then  loop_3 (i+1) check' where\n            check' = check || ((s@i) ^ (s_cmp@i))\n        else check\n    (check_0 : gf_t) = w ^ glob_t\n    (check_1 : gf_t) = loop_3 0 check_0\n    (check_2 : gf_t) = (check_1 -1)>> 15\n    (check : gf_t) = check_2 ^ 1\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Gauss.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the Gauss module implementing Gaussian elimination over matrices for the McEliece KEM, including the types a_in_T = [n-k][n-k], b_in_T = [n-k][k], and the function guassian : a_in_T -> (Bool, b_in_T) with its supporting loops and determinant handling."},{"role":"assistant","content":"```cryptol\nmodule Gauss where\n\nimport Types\nimport Keccak\nimport Shared\n\ntype M_len1 = n-k\nglob_M_len1 = glob_n-glob_k\ntype b_len2 = k\nglob_b_len2 = glob_k\ntype a_in_T = [M_len1][M_len1]\ntype b_in_T = [M_len1][b_len2]\n\nindex M i j = cvt_bit_int ((M@i)@j)\n\nupdate_M M i j v =\n    update M i val' where\n    N =  index M i j\n    val = cvt_int_bit v\n    val' = update N j val\n\nloop_3\n    : a_in_T -> b_in_T -> [32]\n    -> (a_in_T, b_in_T)\nloop_3 a_in b_in i =\n    inner (i+1) a_in b_in where\n    inner j A B =\n        if(j < glob_M_len1)\n        then\n            (A_1, B_1) where\n            tmp = (index A j i)\/ (index A i i)\n            i' = i+1\n            \/\/ M[j][k]-= tmp*M[i][k]\n            \/* one way we want to write it\n            A_1 = [(index A j k)- (tmp *(index A i k))\n                    | j <- [i'..(M_len1-1)]\n                    | k <- [i'..(M_len1-1)]]\n            B_1 = [(index B j k)- (tmp *(index B i k))\n                    | j <- [i'..(M_len1-1)]\n                    | k <- [i'..(b_len2-1)]]\n            *\/\n            loop_j1 k k_limit M  =\n                if (k<k_limit)\n                then loop_j2 k' k_limit M' where\n                    k' = k+1\n                    val = (index M j k) - ((index M i k) * tmp)\n                    M' = update_M M j k val\n                else M\n            loop_j2 k k_limit M  =\n                if (k<k_limit)\n                then loop_j2 k' k_limit M' where\n                    k' = k+1\n                    val = (index M j k) - ((index M i k) * tmp)\n                    M' = update_M M j k val\n                else M\n            A_1 = loop_j1 (i+1) glob_M_len1 A\n            B_1 = B \/\/ FIXME loop_j2 0 `b_len2 B\n        else (A ,B)\n\nbig_loop_1\n    : [32] -> a_in_T -> b_in_T -> [32]\n     -> (a_in_T, b_in_T, [32])\nbig_loop_1 i A B det =\n    if (i< (glob_M_len1-1))\n    then big_loop_1 (i+1) A_2 B_2 det_1 where\n        inner_1 : [32] -> [32] -> [32]\n        inner_1 j k =\n            if(j<glob_M_len1)\n            then\n                if((abs_index A j i) > (abs_index A k i))\n                then j\n                else inner_1 (j+1) k\n            else i \/\/ k=i\n        inner_2 k = (A_1, B_1, det_1) where\n                \/\/swap values a[i]=a[k], a[k]=a[i]\n                v1 = index A i k\n                v2 = index A k i\n                A_1 = update_M (update_M A i k v2) k i v1\n                u1 = index B i k\n                u2 = index B k i\n                B_1 = update_M (update_M B i k u2) k i u1\n                det_1 = -1 * det\n        \/\/absolute\n        abs_index M i j  = if (val<0)then -1* val else val\n            where val = index M i j\n        k = inner_1 (i+1) i\n        (A_1, B_1, det_1) =\n            if (k!=i) then inner_2 det else (A, B, det)\n        (A_2, B_2) = loop_3 A_1 B_1 i\n    else (A, B, det)\n\nbig_loop_2\n    : [32] -> a_in_T -> b_in_T -> [32]\n    -> b_in_T\nbig_loop_2 i A B_in det =\n    if(i>=0)\n    then big_loop_2 (i+1) A B_3 det_1 where\n        loop_j : [32] -> b_in_T -> b_in_T\n        loop_j j B =\n            if (j<glob_M_len1)\n            then loop_j j' B_1 where\n                tmp = index A i j\n                loop_k k B =\n                    if (k<glob_b_len2)\n                    then loop_k k' B_1 where\n                        k' = k+1\n                        val = (index B i k) - (tmp* (index B j k))\n                        B_1 = update_M  B i k val\n                    else B\n                B_1 = loop_k 0 B\n                j' = j+1\n            else B\n        B_1 = loop_j (i+1) B_in\n        val = index A i i\n        t = 1\/val\n        det_1 = det * val\n        loop_j2 j B_2 =\n            if (j<glob_b_len2)\n            then loop_j2 j' B_3 where\n                j' = j+1\n                val = ((index B_2 i j) * t)\n                B_3 = update_M B_2 i j val\n            else B_2\n        B_3 = loop_j2 0 B_1\n    else B_in\n\n\/\/guassian : H_tilde_T -> (Bool, public_key_T)\n\/\/ H_tilde_T    =   [t][n][m]f2_T\n\/\/ public_key_T = [n-k][k]f2_T\nguassian : a_in_T ->  (Bool, b_in_T)\nguassian a  = (True, B_2) where\n    det = 1\n    (b : b_in_T) = zero\n    (A_1, B_1, det_1) = big_loop_1 0 a b det\n    (B_2) = (big_loop_2 0 A_1 B_1 det_1)\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Key_Generation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the McEliece KEM key generation procedure, defining compute_H_tilde, mk_gamma, and key_generation with the given types, and ensure mk_gamma iterates with a counter until fn_gauss succeeds or a limit is reached, returning appropriate public and private keys."},{"role":"assistant","content":"```cryptol\nmodule Key_Generation where\n\nimport Types\nimport Shared\n\ncompute_H_tilde : poly_T -> alphas_T -> [t][n][m]Bit\ncompute_H_tilde g alphas =\n    [[ f i j | j <- [1..n]] | i <- [1..t]]\n            where f i j = aj \/ (g @ aj)\n                    where aj = alphas@j\n\nmk_gamma \n\t: [32]->[32] ->[inf]poly_T -> [inf]alphas_T -> fn_gauss_T\n\t-> (Bool, gamma_T, public_key_T)\nmk_gamma counter counter_limit gs alphas fn_gauss =\n\tif(counter<counter_limit) then \n\t\tif(flag) \n\t\t\tthen (True, current_gamma, public_key)\n\t\t\telse mk_gamma (counter+1) counter_limit gs alphas fn_gauss\n\t\twhere\n\t\t\tg = gs@counter\n\t\t\talpha = alphas@counter\n            \t\t\tcurrent_gamma = { p = g, a = alpha }\n            \t\t\t(H_tilde: H_tilde_T) = compute_H_tilde g alpha\n            \t\t\t(flag, public_key) = fn_gauss H_tilde\n\telse \n\t\t(False, zero, zero)\n\nkey_generation\n\t : [n]Bit -> [inf]poly_T -> [inf]alphas_T -> [32] -> fn_gauss_T\n\t-> (public_key_T, private_key_T)\nkey_generation s gs alphas counter_limit fn_gauss = (public_key, private_key) where\n    (rtn, gamma: gamma_T, public_key: public_key_T) = mk_gamma 0 counter_limit gs alphas fn_gauss\n    (private_key: private_key_T) = if rtn then  {s=s, g=gamma} else zero\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/Types.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Types that defines all the McEliece KEM high-level type aliases and constants exactly as specified (including t, n, m, k, field_element_T, gamma_T, private_key_T, ciphertext_t, secretkey_t, SYS_N_t, and related conversion functions)."},{"role":"assistant","content":"```cryptol\nmodule Types where\n\nglob_t = 119\ntype t = 119\nglob_n = 6960\ntype n = 6960\nglob_m = 13\ntype m = 13\ntype d = 256\ntype mt = m*t glob_k = (glob_n-glob_m*glob_t) type k = (n-m*t) type f2_T = Bit\ntype n_T = [n]f2_T\ntype k_T = [k]f2_T\ntype t_T = [t]f2_T\ntype m_T = [m]f2_T\ntype mt_T = [mt]f2_T  type public_key_T = [mt][k]f2_T\ntype H_T = [n-k][n]f2_T \ntype H_tilde_T = [t][n][m]f2_T\ntype d_T = [d]f2_T\ntype field_element_T = m_T\ntype poly_T =  [t]field_element_T\ntype alphas_T = [n]field_element_T\ntype gamma_T =\n    { p : poly_T                    , a : alphas_T                  }\ntype s_T  = n_T\ntype private_key_T =\n    { s : n_T                       , g : gamma_T\n    }\n\ntype C0_T = mt_T type C1_T = d_T\ntype cipher_text_T =\n    { C0 : C0_T\n    , C1 : C1_T}\ntype hash_input_T =\n    { n : Integer\n    , v : n_T\n    , C : cipher_text_T}\n\ntype weighted_T = n_T\ntype e_T = n_T\n\ntype session_key_T = [32]\n\ntype fn_get_goppa_T = gamma_T -> (n_T, Bool)\ntype fn_gauss_T = H_tilde_T -> (Bool, public_key_T)\n\ntype base_16t = [16]\ntype base_32t = [32]\ntype base_64t = [64]\ntype uint16t = [16]\ntype uint64t = [64]\ntype uint32t = [32]\ntype gf_t = base_t\ncvt_16 e = fromInteger `{[16]} (toInteger e)\ncvt_32 e = fromInteger `{[32]} (toInteger e)\ncvt_64 e = fromInteger `{[64]} (toInteger e)\n\nGFBITS =  13\ntype GFBITS_t =  13\ntype base_t = base_16t\ntype secretkey_t = [13908] base_t\ntype ciphertext_t = [226] base_t  \ntype SYS_N_t = [n]base_t\ntype SYS_N8_t = [n\/8] base_t\ntype SYS_T_double_t = [t*2]base_t\ntype SYS_T_plus1 = [t+1]base_t\nSYS_T_double =  glob_t*2 \nGFMASK  =  cvt_64 (((1:[32]) << GFBITS) - 1)\ntype j_size_t =  1024 type La_t = [32]\ntype Lb_t = [j_size_t][32]\ntype Lc_t = [GFBITS_t][j_size_t][32]\n```"}]}
{"filename":"aws-lc-verification\/cryptol-specs\/McEliece_KEM\/high-level\/util.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the Util module of a McEliece KEM, defining the functions load2, bitrev, store8, load8, and transpose_64x64 with appropriate McEliece-related types from Types and their intended bit-manipulation and data-layout behaviors."},{"role":"assistant","content":"```cryptol\nmodule Util where\n\nimport Types\n\nload2 : secretkey_t -> [32] -> gf_t\nload2 src sk_index = (a && (cvt_16 GFMASK)) where\n    (a: base_16t) = src@(1+sk_index)\n    b = a << 8\n    c = b || src@(0+sk_index)\n\nbitrev : [32] -> ([32],  [32])\nbitrev a = (cvt_32 a_4, cvt_32(a_4>>3)) where\n    a_0 = cvt_16 a\n    a_1 = ((a_0 && 0x00FF) << 8) || ((a_0 && 0xFF00) >> 8)\n    a_2 = ((a_1 && 0x0F0F) << 4) || ((a_1 && 0xF0F0) >> 4)\n    a_3 = ((a_2 && 0x3333) << 2) || ((a_2 && 0xCCCC) >> 2)\n    a_4 = ((a_3 && 0x5555) << 1) || ((a_3 && 0xAAAA) >> 1)\n\nstore8 out in = out\nload8 in = zero\ntranspose_64x64 in = zero\n```"}]}
{"filename":"aws-lc-verification\/SAW\/spec\/AES\/AES-GCM-implementation.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that implements and verifies the AES-GCM AVX\/PMULL-based GHASH and cipher functions (e.g., gcm_polyval_mul_pmult3\/4, gcm_polyval_red_pmult, gcm_ghash_avx, aesni_gcm_cipher), including properties showing equivalence to the reference AES-256-GCM specification."},{"role":"assistant","content":"```cryptol\nmodule AES_GCM_Implementation where\n\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM\nimport AES_GCM\n\ngcm_polyval_mul_pmult3 : {n} (fin n) => [2 * (1 + n)] -> [2 * (1 + n)] -> [4 * (1 + n)]\ngcm_polyval_mul_pmult3 X Y = r3 # (r2 ^ r1 ^ r3 ^ m1) # (r1 ^ r0 ^ r2 ^ m0) # r0\n  where\n    [X_hi, X_lo] = split X\n    [Y_hi, Y_lo] = split Y\n    [r1, r0] = split ((0 : [1]) # (pmult X_lo Y_lo))\n    [r3, r2] = split ((0 : [1]) # (pmult X_hi Y_hi))\n    [m1, m0] = split ((0 : [1]) # (pmult (X_lo ^ X_hi) (Y_hi ^ Y_lo)))\n\ngcm_polyval_mul_pmult4 : {n} (fin n) => [2 * (1 + n)] -> [2 * (1 + n)] -> [4 * (1 + n)]\ngcm_polyval_mul_pmult4 X Y = (hi ^ (0 : [1 + n]) # (hi_bits (m0 ^ m1))) # (lo ^ ((lo_bits (m0 ^ m1)) # (0 : [1 + n])))\n  where\n    [X_hi, X_lo] = split X\n    [Y_hi, Y_lo] = split Y\n    lo = (0 : [1]) # (pmult X_lo Y_lo)\n    hi = (0 : [1]) # (pmult X_hi Y_hi)\n    m0 = (0 : [1]) # (pmult X_lo Y_hi)\n    m1 = (0 : [1]) # (pmult X_hi Y_lo)\n\ngcm_polyval_red_pmult : [256] -> [128]\ngcm_polyval_red_pmult X = (d1 ^ x3) # (d0 ^ x2)\n  where\n    [x3, x2, x1, x0] = split X\n    [a1, a0] = split ((0 : [1]) # (pmult <| x^^63 + x^^62 + x^^57 |> x0))\n    b1 = x0 ^ a1\n    b0 = x1 ^ a0\n    [c1, c0] = split ((0 : [1]) # (pmult <| x^^63 + x^^62 + x^^57 |> b0))\n    d1 = b0 ^ c1\n    d0 = b1 ^ c0\n\ngcm_polyval_avx : [128] -> [128] -> [128]\ngcm_polyval_avx H X = x30\n  where\n    [H_hi, H_lo] = split H\n    [X_hi, X_lo] = split X\n    x17 = (0 : [1]) # (pmult H_lo X_lo)\n    x18 = ((0 : [1]) # (pmult H_hi X_hi)) ^ x17\n    x19 = x18 ^ ((0 : [1]) # (pmult (H_lo ^ H_hi) (X_lo ^ X_hi)))\n    x20 = (lo_bits x19) # (0 : [64])\n    x21 = x17 ^ x20\n    x22 = hi_bits x21\n    x23 = lo_bits x21\n    x25 = (take`{8} ((x23 << 57) ^ (x23 << 62) ^ (x23 << 63))) # (0 : [120])\n    x26 = x21 ^ x25\n    x27 = (hi_bits x26) >> 1\n    x28 = (lo_bits x26) >> 1\n    x29 = (x26 ^ (x27 # x28)) ^ ((x27 >> 5) # (x28 >> 5))\n    x30 = ((((x18 ^ x20) ^ ((0 : [64]) # (hi_bits x19))) ^ x25) ^ ((0 : [64]) # (take`{8} ((x22 << 57) ^ (x22 << 62) ^ (x22 << 63))) # (0 : [56]))) ^ (((hi_bits x29) >> 1) # ((lo_bits x29) >> 1))\n\naesni_gcm_cipher : {n} (fin n) => [32] -> AES_GCM_Ctx -> [(1 + n) * 6 * 16][8] -> [16][8]\naesni_gcm_cipher enc ctx in = ctx''.Xi\n  where\n    enc_blks = if enc ! 0\n      then split (aesni_gcm_ctr32_encrypt_block ctx in)\n      else split (map join (split in))\n    ctx' = aesni_gcm_cipher_block6 enc False ctx (enc_blks @ 0)\n    ctx'' = foldl (aesni_gcm_cipher_block6 enc (enc ! 0)) ctx' (drop`{1} enc_blks)\n\naesni_gcm_ctr32_encrypt_block : {n} (fin n) => AES_GCM_Ctx -> [n * 16][8] -> [n][16 * 8]\naesni_gcm_ctr32_encrypt_block ctx in = out\n  where\n    ctr = drop ((ctx.len \/ 16) + 1)\n    in' = split in\n    out = [ swap8 ((join (reverse blk)) ^ (join (reverse (EKi ctx (ctr + i))))) | blk <- in' | i <- [0 ...] ]\n\naesni_gcm_cipher_block6 : [32] -> Bit -> AES_GCM_Ctx -> [6][128] -> AES_GCM_Ctx\naesni_gcm_cipher_block6 enc karatsuba ctx blks = ctx'\n  where\n    gcm_polyval_mul_fun = if karatsuba\n      then gcm_polyval_mul_pmult3\n      else gcm_polyval_mul_pmult4\n    Htable = get_Htable ctx\n    Xi = join ctx.Xi\n    Xi_0 = gcm_polyval_mul_fun (Htable @ 0) (blks @ 5)\n    Xi_1 = gcm_polyval_mul_fun (Htable @ 1) (blks @ 4)\n    Xi_2 = gcm_polyval_mul_fun (Htable @ 3) (blks @ 3)\n    Xi_3 = gcm_polyval_mul_fun (Htable @ 4) (blks @ 2)\n    Xi_4 = gcm_polyval_mul_fun (Htable @ 6) (blks @ 1)\n    Xi_5 = gcm_polyval_mul_fun (Htable @ 7) (Xi ^ (blks @ 0))\n    Xi_6 = gcm_polyval_red_pmult (Xi_0 ^ Xi_1 ^ Xi_2 ^ Xi_3 ^ Xi_4 ^ Xi_5)\n    Xi' = split Xi_6\n    ctx' =\n      { key = ctx.key\n      , iv = ctx.iv\n      , Xi = Xi'\n      , len = ctx.len + 6 * 16\n      }\n\ngcm_ghash_avx : {n, m} (fin n, 1 <= m, m <= 8) => [128] -> [16][8] -> [(n * 8 + m) * 16][8] -> [16][8]\ngcm_ghash_avx H Xi in = Xi''\n  where\n    bulk # tl = in\n    Xi' = foldl (gcm_ghash_avx_8`{8} H) Xi (split`{n} bulk)\n    Xi'' = gcm_ghash_avx_8`{m} H Xi' tl\n\ngcm_ghash_avx_8 : {n} (1 <= n, n <= 8) => [128] -> [16][8] -> [n * 16][8] -> [16][8]\ngcm_ghash_avx_8 H Xi in = Xi''\n  where\n    [H0, H1, _, H2, H3, _, H4, H5, _, H6, H7, _] = gcm_init_Htable H\n    Htable = [H0, H1, H2, H3, H4, H5, H6, H7]\n    Xi' = join Xi\n    blks = map join (split in)\n    Xi_0 = gcm_polyval_mul_pmult3 (Htable @ (`n - 1)) (Xi' ^ (blks @ 0))\n    Xi_1 = gcm_polyval_mul_pmult3 (Htable @ (`n - 2)) (blks @ 1)\n    Xi_2 = gcm_polyval_mul_pmult3 (Htable @ (`n - 3)) (blks @ 2)\n    Xi_3 = gcm_polyval_mul_pmult3 (Htable @ (`n - 4)) (blks @ 3)\n    Xi_4 = gcm_polyval_mul_pmult3 (Htable @ (`n - 5)) (blks @ 4)\n    Xi_5 = gcm_polyval_mul_pmult3 (Htable @ (`n - 6)) (blks @ 5)\n    Xi_6 = gcm_polyval_mul_pmult3 (Htable @ (`n - 7)) (blks @ 6)\n    Xi_7 = gcm_polyval_mul_pmult3 (Htable @ (`n - 8)) (blks @ 7)\n    T1 = if `n == 8\n      then Xi_7 ^ Xi_6 ^ Xi_5 ^ Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n      else if `n == 7\n        then Xi_6 ^ Xi_5 ^ Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n        else if `n == 6\n          then Xi_5 ^ Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n          else if `n == 5\n            then Xi_4 ^ Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n            else if `n == 4\n              then Xi_3 ^ Xi_2 ^ Xi_1 ^ Xi_0\n              else if `n == 3\n                then Xi_2 ^ Xi_1 ^ Xi_0\n                else if `n == 2\n                  then Xi_1 ^ Xi_0\n                  else Xi_0\n    Xi_n = gcm_polyval_red_pmult T1\n    Xi'' = split Xi_n\n```"}]}
{"filename":"aws-lc-verification\/SAW\/spec\/AES\/X86.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module X86 that specifies the x86-style AES helper functions (clmul, aesenc, aesenclast, aesdec, aesdeclast, aeskeygenassist, RotWord_x86, msgToState_x86, stateToMsg_x86) over AES.State, suitable for use in verification of AES hardware\/software implementations."},{"role":"assistant","content":"```cryptol\nmodule X86 where\n\nimport Primitive::Symmetric::Cipher::Block::AES\n\nclmul : [64] -> [64] -> [128]\nclmul x y = 0b0 # pmult x y\n\naesenc : [128] -> [128] -> [128]\naesenc pt key =\n  stateToMsg_x86 (AESRound (msgToState_x86 key, msgToState_x86 pt))\n\naesenclast : [128] -> [128] -> [128]\naesenclast pt key =\n  stateToMsg_x86 (AESFinalRound (msgToState_x86 key, msgToState_x86 pt))\n\naesdec : [128] -> [128] -> [128]\naesdec pt key =\n  stateToMsg_x86 (AESInvRound (msgToState_x86 key, msgToState_x86 pt))\n\naesdeclast : [128] -> [128] -> [128]\naesdeclast pt key =\n  stateToMsg_x86 (AESFinalInvRound (msgToState_x86 key, msgToState_x86 pt))\n\naeskeygenassist : [128] -> [8] -> [128]\naeskeygenassist src imm = join\n  ( (RotWord_x86 (SubWord x3) ^ rcon)\n  # SubWord x3\n  # (RotWord_x86 (SubWord x1) ^ rcon)\n  # SubWord x1\n  )\n  where\n    [x3, x2, x1, x0] = [split x | x <- split src]\n    rcon = [0, 0, 0, imm]\n\nRotWord_x86 : [4]GF28 -> [4]GF28\nRotWord_x86 x = reverse (RotWord (reverse x))\n\nmsgToState_x86 : [128] -> State\nmsgToState_x86 msg = transpose (split (reverse (split msg)))\n\nstateToMsg_x86 : State -> [128]\nstateToMsg_x86 st = join (reverse (join (transpose st)))\n```"}]}
{"filename":"aws-lc-verification\/SAW\/spec\/AES\/AES-GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `AES_GCM` that specifies AES-GCM (AES-256-GCM) encryption, decryption, GHASH, and GCM context operations (including key schedule conversions, counter-mode block encryption, H table initialization, and tag computation) with appropriate types, plus properties relating these to the abstract AES-GCM specification."},{"role":"assistant","content":"```cryptol\nmodule AES_GCM where\n\nimport Primitive::Symmetric::Cipher::Block::AES\nimport Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM\nimport X86\n\nswap8 : {parts, a} (fin parts) => [parts * 8]a -> [parts * 8]a\nswap8 x = join`{each=8} (reverse (split`{each=8} x))\n\nswap128 : {parts, a} (fin parts) => [parts * 128]a -> [parts * 128]a\nswap128 x = join`{each=128} (reverse (split`{each=128} x))\n\nhi_bits : {n} (fin n) => [2 * n] -> [n]\nhi_bits = take\n\nlo_bits : {n} (fin n) => [2 * n] -> [n]\nlo_bits = drop\n\naes_key_to_schedule : [Nr + 1][128] -> KeySchedule\naes_key_to_schedule key = (key' @ 0, key' @@ [1 .. (Nr - 1)], key' @ `Nr)\n  where\n    key' = map msgToState_x86 key\n\naes_key_from_schedule : KeySchedule -> [4 * (Nr - 1)][32]\naes_key_from_schedule (init_key, middle_keys, final_key) = join (map reverse (map split (key' @@ [2 .. Nr])))\n  where\n    key' = map stateToMsg_x86 ([init_key] # middle_keys # [final_key])\n\ninv_aes_key_from_schedule : KeySchedule -> [4 * (Nr - 1)][32]\ninv_aes_key_from_schedule (init_key, middle_keys, final_key) = join (map reverse (map split (reverse (key' @@ [2 .. Nr]))))\n  where\n    key' = map stateToMsg_x86 ([init_key] # middle_keys # [final_key])\n\naes_hw_decrypt : [16][8] -> [32][8] -> [16][8]\naes_hw_decrypt in key = split (aesDecrypt ((join in), (join key)))\n\naes_hw_ctr32_encrypt_blocks : {n} (fin n) => [16*n][8] -> [32][8] -> [16][8] -> [16*n][8]\naes_hw_ctr32_encrypt_blocks in key (iv # ctr) =\n  join [ blk ^ (aes_hw_encrypt (iv # (split ((join ctr) + i))) key) | blk <- split in | i <- [(0 : [32]) ...]]\n\ngcm_init : [2][64] -> [12][128]\ngcm_init Xi = gcm_init_Htable (gcm_init_H (join Xi))\n\ngcm_init_Htable : [128] -> [12][128]\ngcm_init_Htable h0 = [h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11]\n  where\n    h1 = gcm_polyval h0 h0\n    h2 = ((hi_bits h1) ^ (lo_bits h1)) # ((hi_bits h0) ^ (lo_bits h0))\n    h3 = gcm_polyval h0 h1\n    h4 = gcm_polyval h0 h3\n    h5 = ((hi_bits h4) ^ (lo_bits h4)) # ((hi_bits h3) ^ (lo_bits h3))\n    h6 = gcm_polyval h0 h4\n    h7 = gcm_polyval h0 h6\n    h8 = ((hi_bits h7) ^ (lo_bits h7)) # ((hi_bits h6) ^ (lo_bits h6))\n    h9 = gcm_polyval h0 h7\n    h10 = gcm_polyval h0 h9\n    h11 = ((hi_bits h9) ^ (lo_bits h9)) # ((hi_bits h10) ^ (lo_bits h10))\n\ngcm_gmult : [128] -> [16][8] -> [16][8]\ngcm_gmult H Xi = split (gcm_polyval H (join Xi))\n\ngcm_ghash : {n} (fin n) => [128] -> [16][8] -> [n * 16][8] -> [16][8]\ngcm_ghash H Xi inp = foldl (gcm_ghash_block H) Xi (split inp)\n\ngcm_ghash_block : [128] -> [16][8] -> [16][8] -> [16][8]\ngcm_ghash_block H Xi inp = split (gcm_polyval H ((join Xi) ^ (join inp)))\n\nget_Htable : AES_GCM_Ctx -> [12][128]\nget_Htable ctx = gcm_init (get_H ctx)\n\nget_i : AES_GCM_Ctx -> [32]\nget_i ctx = drop ((ctx.len + 15) \/ 16)\n\nget_Yi : AES_GCM_Ctx -> [16][8]\nget_Yi ctx = ctx.iv # (split ((get_i ctx) + 2))\n\nget_EKi : AES_GCM_Ctx -> [16][8]\nget_EKi ctx = EKi ctx (get_i ctx)\n\nget_EK0 : AES_GCM_Ctx -> [16][8]\nget_EK0 ctx = EKi ctx 0\n```"}]}
{"filename":"BLST-Verification\/tests\/Fp12_tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines Fp_12 and Fp_12_alt representations and proves the listed properties relating their conversions, addition, multiplication by w, and the correctness of cyclotomic_sqr_fp12 and cyclotomic_sqr_fp12_imp over Fp12, including the provided concrete test vectors."},{"role":"assistant","content":"```cryptol\nimport implementation::Fp12\nimport Parameters (Fp_12, t_Fp_12, p, u, u_plus_1, v, w)\nimport FieldExtras\nimport Frobenius (fp12_conjugate)\n\nproperty fp12_alt_round_trip_1 x =\n    Fp_12_alt_to_Fp_12 (Fp_12_to_Fp_12_alt x) == x\n\nproperty fp12_alt_round_trip_2 x =\n    Fp_12_to_Fp_12_alt (Fp_12_alt_to_Fp_12 x) == x\n\nproperty fp12_alt_add x y =\n    Fp_12_alt_to_Fp_12 (Fp_12_alt.add (x, y)) == Fp_12.add (Fp_12_alt_to_Fp_12 x, Fp_12_alt_to_Fp_12 y)\n\nproperty fp12_alt_mul_w x =\n    Fp_12_alt_to_Fp_12 (Fp_12_alt.mul (Fp_12_to_Fp_12_alt w, x)) == Fp_12.mul (w, Fp_12_alt_to_Fp_12 x)\n\nto_cyclotomic_fp12 x = k_expt`{4} Fp_12 x1 e where\n    x1 = Fp_12.div (fp12_conjugate x, x)     e = `(p*p+1):[2*382] \nis_cyclotomic_fp12 x = (Fp_12.mul(x4, x) == x2) where     x2 = fp12_frobenius2 x     x4 = fp12_frobenius2 x2 \ncyclotomic_sqr_fp12_ok x =\n    cyclotomic_sqr_fp12 x' == Fp_12.sq x' where x' = to_cyclotomic_fp12 x\n\ntest_a = [[[1,2],[3,4],[5,6]],[[7,8],[9,10],[11,12]]]: t_Fp_12\ntest_b = [[[0,9],[1,8],[2,7]],[[3,6],[4,5],[5,4]]]: t_Fp_12\n\nproperty cyclotomic_sqr_fp12_test_a = cyclotomic_sqr_fp12_ok test_a\nproperty cyclotomic_sqr_fp12_test_b = cyclotomic_sqr_fp12_ok test_b\n\n\/\/ _imp matches the spec version\n\nproperty cyclotomic_sqr_fp12_imp_ok x =\n    cyclotomic_sqr_fp12 x == cyclotomic_sqr_fp12_imp x\n```"}]}
{"filename":"BLST-Verification\/tests\/ParameterTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the Fp and Fp_12 serialization\/deserialization functions and the elliptic curves E, E', base points BP, BP', and scalar r, along with properties asserting round-trip correctness and that BP and BP' lie on their curves and have order r."},{"role":"assistant","content":"```cryptol\nimport Parameters\nimport ShortWeierstrassCurve\n\nproperty Fp_to_octets_to_Fp x =\n  Fp.is_val x ==> octets_to_Fp (Fp_to_octets x) == x\n\nproperty Fp_12_to_octets_to_Fp_12 x =\n  Fp_12.is_val x ==> octets_to_Fp_12 (Fp_12_to_octets x) == x\n\nproperty BP_on_E =\n    is_point_affine E BP \nproperty BP'_on_E' =\n    is_point_affine E' BP' \nproperty BP_order =\n    is_point_O E (mult E r BP) \nproperty BP'_order =\n    is_point_O E' (mult E' r BP')\n```"}]}
{"filename":"BLST-Verification\/tests\/G2SubGroupCheckTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties to verify the G2 subgroup check and psi endomorphism on the BLS12-381 G2 curve, including that psi preserves affine points, psi has order 12 on multiples of BP', and psi is equivalent to scalar multiplication by p and by the reduced exponent."},{"role":"assistant","content":"```cryptol\nimport Parameters (p, Fp_2, t_Fp_2, E', BP', r)\nimport Frobenius\nimport FieldExtras\nimport ShortWeierstrassCurve\nimport G2SubGroupCheck\n\nproperty test_psi_1 = is_point_affine E' (psi BP') test_psi_2 m = is_point_affine E' (psi (mult E' m BP')) \/\/ and multiples of BP'\nproperty test_psi_2_1 = test_psi_2 0x6db7\nproperty test_psi_2_2 = test_psi_2 0xdefc\n\nproperty in_G2_1 = is_in_G2' BP'\n\nin_G2_2 m = is_in_G2' (mult E' m BP')\nproperty in_G2_2_1 = in_G2_2 0xa3e0\nproperty in_G2_2_2 = in_G2_2 0xd58f\n\n\/\/ psi has order 12, apparently\n\nproperty test_psi_order =\n  same_point_affine E' (images@12) BP' where\n  images = [BP'] # [psi P | P <- images] \ntest_psi_order_mult m =\n  same_point_affine E' (images@12) Q where\n  images = [Q] # [psi P | P <- images] \/\/ so images @ i == psi^i BP'\n  Q = mult E' m BP'\nproperty test_psi_order_mult_1 = test_psi_order_mult 0x7ecf\nproperty test_psi_order_mult_2 = test_psi_order_mult 0xe233\n\nproperty test_psi_is_mult = same_point_affine E' (psi BP') (mult E' (`p:[384]) BP')\n\ntest_psi_is_mult_reduced m = same_point_affine E' (psi P) (mult E' e  P)\n  where e = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfe2dfefffeffff0001\n        P = mult E' m BP'\nproperty test_psi_is_mult_reduced_1 = test_psi_is_mult_reduced 0xdefc\nproperty test_psi_is_mult_reduced_2 = test_psi_is_mult_reduced 0x7ecf\n```"}]}
{"filename":"BLST-Verification\/tests\/ShortWeierstrassCurveTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the example elliptic curves C1, C2, C3 over small prime and extension fields and the properties double_stays_on_curve, add_closed, add_commutes, subtraction_inverts_addition, addition_inverts_subtraction, mult_sum, and mult_prod, each instantiated for C1, C2, and C3."},{"role":"assistant","content":"```cryptol\nimport PrimeField\nimport ExtensionField\nimport ShortWeierstrassCurve\n\nF7 = prime_field_bv 0b111\nC1: EllipticCurve [3]\nC1 = {base_field = F7, a = 0, b = 1}\n\nF13 = prime_field`{13}\nC2: EllipticCurve (Z 13)\nC2 = {base_field = F13, a = 3, b = 1} \nF3 = prime_field`{3}\nF9 = extension_field F3 [0,2]\nC3: EllipticCurve _ C3 = {base_field = F9, a = [1,1], b=[1,2]}\n\ndouble_stays_on_curve C S =\n   is_point_affine C S ==> is_point_affine C (double C S)\n\nproperty double_stays_on_curve1 = double_stays_on_curve C1\nproperty double_stays_on_curve2 = double_stays_on_curve C2\nproperty double_stays_on_curve3 = double_stays_on_curve C3\n\nadd_closed C P Q =\n   is_point_affine C P \/\\ is_point_affine C Q ==>\n   is_point_affine C (add C P Q)\n\nproperty add_closed1 = add_closed C1\nproperty add_closed2 = add_closed C2\nproperty add_closed3 = add_closed C3\n\nadd_commutes C P Q =\n   is_point_affine C P \/\\ is_point_affine C Q ==>\n   same_point_affine C (add C P Q) (add C Q P)\n\nproperty add_commutes1 = add_commutes C1\nproperty add_commutes2 = add_commutes C2\nproperty add_commutes3 = add_commutes C3\n\nsubtraction_inverts_addition C P Q =\n   is_point_affine C P \/\\ is_point_affine C Q ==>\n   same_point_affine C (sub C (add C P Q) Q) P  \n\nproperty subtraction_inverts_addition1 = subtraction_inverts_addition C1\nproperty subtraction_inverts_addition2 = subtraction_inverts_addition C2\nproperty subtraction_inverts_addition3 = subtraction_inverts_addition C3\n\naddition_inverts_subtraction C P Q =\n   is_point_affine C P \/\\ is_point_affine C Q ==>\n   same_point_affine C (add C (sub C P Q) Q) P  \n\nproperty addition_inverts_subtraction1 = addition_inverts_subtraction C1\nproperty addition_inverts_subtraction2 = addition_inverts_subtraction C2\nproperty addition_inverts_subtraction3 = addition_inverts_subtraction C3\n\nmult_sum C S a b =\n    is_point_affine C S \/\\ a <= 0x3f \/\\ b <= 0x3f ==>     same_point_affine C (mult C (a+b) S) (add C (mult C a S) (mult C b S))\n\nproperty mult_sum1 = mult_sum C1\nproperty mult_sum2 = mult_sum C2\nproperty mult_sum3 = mult_sum C3\n\nmult_prod C S a b =\n    is_point_affine C S \/\\ a <= 0x0f \/\\ b <= 0x0f ==>     same_point_affine C (mult C (a*b) S) (mult C a (mult C b S))\n\nproperty mult_prod1 = mult_prod C1\nproperty mult_prod2 = mult_prod C2\nproperty mult_prod3 = mult_prod C3\n```"}]}
{"filename":"BLST-Verification\/tests\/FrobeniusTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines and proves the properties fp2_frobenius_prop, f6_frobenius_prop, and f12_frobenius_prop, showing that fp2_frobenius, fp6_frobenius, and fp12_frobenius equal F_expt over normalized Fp_2, Fp_6, and Fp_12 elements using modulus p from Parameters."},{"role":"assistant","content":"```cryptol\nimport Parameters as P\nimport Frobenius\nimport FieldExtras\n\np: [381]\np = `P::p\n\nproperty fp2_frobenius_prop x =\n  fp2_frobenius x' == F_expt P::Fp_2 x' p where x' = P::Fp_2.normalize x\n\nproperty f6_frobenius_prop x =\n  fp6_frobenius x' == F_expt P::Fp_6 x' p where x' = P::Fp_6.normalize x\n\nproperty f12_frobenius_prop x =\n  fp12_frobenius x' == F_expt P::Fp_12 x' p where x' = P::Fp_12.normalize x\n```"}]}
{"filename":"BLST-Verification\/tests\/ProjectiveCurveOperationsTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module that instantiates two short Weierstrass elliptic curves over small prime fields and defines properties verifying that projective curve operations (projectify\/affinify, double, add, sub, and scalar multiplication) preserve points and agree with their affine counterparts."},{"role":"assistant","content":"```cryptol\nimport ShortWeierstrassCurve\nimport ProjectiveCurveOperations\nimport PrimeField\nimport FieldExtras\n\nF7 = prime_field`{7}\nC1: EllipticCurve _\nC1 = {base_field = F7, a = 1, b = 3}\n\nF13 = prime_field_bv (13:[4])\nC2: EllipticCurve _\nC2 = {base_field = F13, a = 4, b = 5}\n\nis_point_OK_1 C S =\n  is_point_O C S \\\/\n  is_point_affine C S == is_point_projective C (projectify C S)\n\nproperty projectify_preserves_is_point_C1 = is_point_OK_1 C1\nproperty projectify_preserves_is_point_C2 = is_point_OK_1 C2\n\nis_point_OK_2 C S =\n  is_point_O C (affinify C S) \\\/\n  is_point_projective C S == is_point_affine C (affinify C S)\n\nproperty affinify_preserves_is_point_C1 = is_point_OK_2 C1\nproperty affinify_preserves_is_point_C2 = is_point_OK_2 C2\n\ndouble_stays_on_curve C S =\n   is_point_projective C S ==> is_point_projective C (p_double C S)\n\nproperty double_stays_on_curve_C1 = double_stays_on_curve C1\nproperty double_stays_on_curve_C2 = double_stays_on_curve C2\n\ndouble_agrees C S =\n   is_point_projective C S ==>\n   same_point_affine C (affinify C (p_double C S))\n                       (double C (affinify C S))\n\nproperty double_agrees_C1 = double_agrees C1\nproperty double_agrees_C2 = double_agrees C2\n\naddition_zero C S =\n    is_point_projective C S ==> same_point C S (p_add C S (p_point_O C))\n\naddition_commutes C S T =\n    is_point_projective C S \/\\  is_point_projective C T ==>\n    same_point C (p_add C S T) (p_add C T S)\n\nproperty addition_commutes_C1 = addition_commutes C1\nproperty addition_commutes_C2 = addition_commutes C2\n\naddition_distributes C S T R =\n    is_point_projective C S \/\\ is_point_projective C T \/\\ is_point_projective C R ==>\n    same_point C (p_add C S (p_add C T R)) (p_add C (p_add C S T) R)\n\nproperty addition_distributes_C1 = addition_distributes C1\nproperty addition_distributes_C2 = addition_distributes C2\n\naddition_agrees C S T =\n    is_point_projective C S \/\\  is_point_projective C T ==>\n    same_point_affine C (add C (affinify C S) (affinify C T))\n                        (affinify C (p_add C S T))\n\nproperty addition_agrees_C1 = addition_agrees C1\nproperty addition_agrees_C2 = addition_agrees C2\n\nsubtraction_inverts_addition C S T =\n     is_point_projective C S \/\\ is_point_projective C T ==>\n     same_point C S (p_sub C (p_add C S T) T)\n\nproperty subtraction_inverts_addition_C1 = subtraction_inverts_addition C1\nproperty subtraction_inverts_addition_C2 = subtraction_inverts_addition C2\n\nsubtraction_agrees C S T =\n     is_point_projective C S \/\\  is_point_projective C T ==>\n     same_point_affine C (sub C (affinify C S) (affinify C T))\n                         (affinify C (p_sub C S T))\n\nproperty subtraction_agrees_C1 = subtraction_agrees C1\nproperty subtraction_agrees_C2 = subtraction_agrees C2\n\np_mult_agrees: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> ProjectivePoint t -> Bool\np_mult_agrees C m S =\n    is_point_projective C S ==>\n    same_point_affine C (affinify C (p_mult`{k=k} C m S))\n                        (mult`{k=k} C m (affinify C S))\n\nproperty p_mult_agrees_C1 = p_mult_agrees`{k=4} C1\nproperty p_mult_agrees_C2 = p_mult_agrees`{k=3} C2\n\np_mult_affine_agrees: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> AffinePoint t -> Bool\np_mult_affine_agrees C m S =\n    is_point_affine C S ==>\n    same_point_affine C (p_mult_affine`{k=k} C m S)\n                        (mult`{k=k} C m S)\n```"}]}
{"filename":"BLST-Verification\/tests\/SerializationTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, write the two properties `ser_des_E1` and `ser_des_E2` that verify serialize-then-deserialize correctness for elliptic curve points `Q = EC::mult E m BP` and `Q = EC::mult E' m BP'` using `serialize_E1`, `deserialize_E1`, `serialize_E2`, and `deserialize_E2`."},{"role":"assistant","content":"```cryptol\nimport Serialization\nimport Parameters\nimport ShortWeierstrassCurve as EC\nimport Maybe\n\nproperty ser_des_E1 (m:[16]) =\n  deserialize_E1 ((serialize_E1 Q) # zero) == just Q where Q = EC::mult E m BP\n\nproperty ser_des_E2 (m:[16]) =\n  deserialize_E2 (serialize_E2 Q) == just Q where Q = EC::mult E' m BP'\n```"}]}
{"filename":"BLST-Verification\/tests\/PolynomialTest.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines polynomial arithmetic over finite fields via FieldRep, including poly_mul, poly_add, poly_0, poly_1, poly_div_mod, poly_inverse_mod, poly_mul_mod, and poly_equal, and properties asserting identities, commutativity, division with remainder, and modular inverses for fields F7 and F29."},{"role":"assistant","content":"```cryptol\nimport Common::Field\nimport Polynomial\nimport PrimeField\n\nis_OK: {t,k} (fin k) => FieldRep t -> [k]t ->Bool\nis_OK F p = all F.is_val p\n\npoly_mul_0:  {t,k} (fin k, k>=1) => FieldRep t -> [k]t ->Bool\npoly_mul_0 F x = poly_equal F (poly_mul F x (poly_0 F), poly_0 F)\n\npoly_mul_1:  {t,k} (fin k, k>=1) => FieldRep t -> [k]t ->Bool\npoly_mul_1 F x =\n   is_OK F x ==> poly_equal F (poly_mul F x (poly_1 F), x)\n\npoly_mul_commutes:  {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t ->Bool\npoly_mul_commutes F x y =\n    is_OK F x \/\\ is_OK F y ==> poly_equal F (poly_mul F x y, poly_mul F y x)\n\npoly_mul_mod_commutes:  {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t ->Bool\npoly_mul_mod_commutes F x y =\n    is_OK F x \/\\ is_OK F y ==> poly_equal F (poly_mul F x y, poly_mul F y x)\n\npoly_div_mod_prop: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t ->  Bool\npoly_div_mod_prop F x y =\n    is_OK F y \/\\ is_OK F x \/\\ ~ (poly_equal F (y, poly_0 F)) ==>\n    poly_equal F (x, poly_add F (poly_mul F q y) r) where (q,r) = poly_div_mod F x y\n\npoly_inverse_mod_prop: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t -> Bool\npoly_inverse_mod_prop F q p =\n    (is_OK F q) \/\\ is_OK F p \/\\ ~ (poly_equal F (p, poly_0 F)) ==> \n    poly_equal F (poly_mul_mod F p (poly_inverse_mod F p q) q, poly_1 F)\n\nF7 = prime_field`{7}\nF29 = prime_field_bv (29:[5])\n\nproperty mul_0_F7 = poly_mul_0`{k=4} F7\nproperty mul_1_F7 = poly_mul_1`{k=4} F7\nproperty mul_commutes_F7 = poly_mul_commutes`{k=5} F7\nproperty mul_mod_commutes_F7 = poly_mul_mod_commutes`{k=4} F7\n\nproperty div_mod_F7 = poly_div_mod_prop`{k=3} F7\nproperty div_mod_F7' = poly_div_mod_prop`{k=8} F7\n\n\/\/ for the inverse_mod property, take care to recall the unusual representatin of the modulus.\nproperty inverse_mod_F7 = poly_inverse_mod_prop`{k=3} F7 [1,1,3] \/\/ q=x^3-x^2-x-3 is irreducible in F7\nproperty inverse_mod_F7' = poly_inverse_mod_prop`{k=4} F7 [2,0,1,1] \nproperty mul_0_F29 = poly_mul_0`{k=4} F29\nproperty mul_1_F29 = poly_mul_1`{k=4} F29\nproperty mul_commutes_F29 = poly_mul_commutes`{k=5} F29\nproperty mul_mod_commutes_F29 = poly_mul_mod_commutes`{k=4} F29\n\nproperty div_mod_F29 = poly_div_mod_prop`{k=3} F29\n\nproperty inverse_mod_F29 = poly_inverse_mod_prop`{k=3} F29 [2,3,5] property inverse_mod_F29' = poly_inverse_mod_prop`{k=4} F29 [27,1,1,6] \/\/ x^4-27x^3-x^2-x-6, also irreducible\n```"}]}
{"filename":"BLST-Verification\/tests\/ClearCofactorTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions, points, and property `impl_eq_many` to verify that `clear_cofactor` and `clear_cofactor_E2_impl` agree on several test points for BLS12-381 G2 clear-cofactor operations."},{"role":"assistant","content":"```cryptol\nimport HashToCurveE2\nimport HashToCurveE2Aux\nimport Parameters\nimport Serialization\nimport ShortWeierstrassCurve\n\nimport implementation::HashToG2\n\nspec_eq : AffinePoint t_Fp_2 -> Bit\nspec_eq P = (clear_cofactor_bls12381_g2 P) == (clear_cofactor P)\n\nto_Fp2: ([384], [384]) -> t_Fp_2\nto_Fp2 (a,b) = [to_Fp b, to_Fp a] \npoint = deserialize_E2 (serialize_E2 (to_Fp2 (0, 1), to_Fp2 (0, 1)))\n\npoints = [mult E' x (point.1) | x <- [0x1, 0x2 .. 0x5 : [4]]]\n\n\/\/ Check that the implementation function agrees with clear_cofactor\nimpl_eq P = (clear_cofactor P) == (affinify E' (clear_cofactor_E2_impl (projectify E' P)))\n\n\/\/ Since changing `mult` to `scalar_mult` in clear_cofactor_bls12381_g2,\n\/\/ running this check is too slow.  It can be uncommented if\n\/\/ clear_cofactor_bls12381_g2 is ever changed back to use `mult`.\n\/\/property spec_eq_many = all spec_eq points\n\nproperty impl_eq_many = all impl_eq points\n```"}]}
{"filename":"BLST-Verification\/tests\/HashToG2Tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the function `test` and the property `prop` asserting that, for inputs `us = [zero, [324,33], [1,0], [`p-1,7]]`, `affinify C (map_to_curve_E2_prime_impl u)` equals `map_to_curve_simple_swu u` for all `u` in `us`."},{"role":"assistant","content":"```cryptol\nimport HashToCurveE2\nimport HashToCurveE2Aux\nimport Serialization\nimport ShortWeierstrassCurve\nimport implementation::HashToG2\n\ntest u = (affinify C (map_to_curve_E2_prime_impl u)) == map_to_curve_simple_swu u\n\nus = [zero, [324,33], [1,0],[`p-1,7]]\n\nproperty prop = all test us\n```"}]}
{"filename":"BLST-Verification\/tests\/HashToCurveE1Tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol test module that verifies the hash-to-curve (BLS12-381 G1, XMD:SHA-256, SSWU_RO) implementation by defining the given expand_message, hash_to_field, map_to_curve, and hash_to_curve test vectors as Cryptol properties that must hold for specified messages and domain separation tags."},{"role":"assistant","content":"```cryptol\nimport ExpandMessage\nimport HashToCurveE1\nimport ShortWeierstrassCurve as EC\nimport Parameters as P\n\ndst_1 = \"QUUX-V01-CS02-with-expander\"\n\nproperty expand_test_1 =\n    expand_message \"\" dst_1 ==\n    split 0xf659819a6473c1835b25ea59e3d38914c98b374f0970b7e4c92181df928fca88\n\nproperty expand_test_2 =\n    expand_message  \"abc\" dst_1 ==\n    split 0x1c38f7c211ef233367b2420d04798fa4698080a8901021a795a1151775fe4da7\n\nproperty expand_test_3 =\n    expand_message \"abcdef0123456789\" dst_1 ==\n    split 0x8f7e7b66791f0da0dbb5ec7c22ec637f79758c0a48170bfb7c4611bd304ece89\n\nmsg_q128 = \"q128_qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\" #\n           \"qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\" #\n           \"qqqqqqqqqqqqqqqqqqqqqqqqq\"\n\nproperty expand_test_4 =\n    expand_message msg_q128 dst_1 ==\n    split 0x72d5aa5ec810370d1f0013c0df2f1d65699494ee2a39f72e1716b1b964e1c642\n\nmsg_a512 = \"a512_\"  # ['a' | _ <- [0..511]]\n\nproperty expand_test_5 =\n    expand_message msg_a512 dst_1 ==\n    split 0x3b8e704fc48336aca4c2a12195b720882f2162a4b7b13a9c350db46f429b771b\n\nto_Fp = P::to_Fp \ndst = \"QUUX-V01-CS02-with-BLS12381G1_XMD:SHA-256_SSWU_RO_\"\n\nex1_msg = \"\"\n\nex1_us = hash_to_field`{count=2} ex1_msg dst\n\nex1_expected_us =\n   [ to_Fp 0x0ba14bd907ad64a016293ee7c2d276b8eae71f25a4b941eece7b0d89f17f75cb3ae5438a614fb61d6835ad59f29c564f\n   , to_Fp 0x019b9bd7979f12657976de2884c7cce192b82c177c80e0ec604436a7f538d231552f0d96d9f7babe5fa3b19b3ff25ac9\n   ]\n\nproperty hash_to_field_test_1 =\n    ex1_us == ex1_expected_us\n\nproperty map_to_curve_test_1_1_a =\n    EC::is_point_affine Isogenous_Curve (map_to_curve_simple_swu (ex1_us@0))\n\nproperty map_to_curve_test_1_1_b =\n    EC::is_point_affine Isogenous_Curve (map_to_curve_simple_swu (ex1_us@1))\n\nproperty map_to_curve_test_1_2_a =\n    EC::is_point_affine P::E (map_to_curve_simple_swu_AB0 (ex1_us@0))\n\nproperty map_to_curve_test_1_2_b =\n    EC::is_point_affine P::E (map_to_curve_simple_swu_AB0 (ex1_us@1))\n\nproperty map_to_curve_test_1_3_a =\n    EC::same_point_affine P::E (map_to_curve_simple_swu_AB0 (ex1_us@0))\n    (to_Fp 0x11a3cce7e1d90975990066b2f2643b9540fa40d6137780df4e753a8054d07580db3b7f1f03396333d4a359d1fe3766fe,\n     to_Fp 0x0eeaf6d794e479e270da10fdaf768db4c96b650a74518fc67b04b03927754bac66f3ac720404f339ecdcc028afa091b7)\n\nproperty map_to_curve_test_1_3_b =\n    EC::same_point_affine P::E (map_to_curve_simple_swu_AB0 (ex1_us@1))\n    (to_Fp 0x160003aaf1632b13396dbad518effa00fff532f604de1a7fc2082ff4cb0afa2d63b2c32da1bef2bf6c5ca62dc6b72f9c,\n     to_Fp 0x0d8bb2d14e20cf9f6036152ed386d79189415b6d015a20133acb4e019139b94e9c146aaad5817f866c95d609a361735e)\n\nproperty hash_to_curve_test_1 =\n    EC::same_point_affine P::E (hash_to_curve (\"\", dst))\n    (to_Fp 0x052926add2207b76ca4fa57a8734416c8dc95e24501772c814278700eed6d1e4e8cf62d9c09db0fac349612b759e79a1,\n     to_Fp 0x08ba738453bfed09cb546dbb0783dbb3a5f1f566ed67bb6be0e8c67e2e81a4cc68ee29813bb7994998f3eae0c9c6a265)\n\nex2_msg = \"abc\"\nex2_us = hash_to_field`{count=2} ex2_msg dst\n\nex2_expected_us =\n [ to_Fp 0x0d921c33f2bad966478a03ca35d05719bdf92d347557ea166e5bba579eea9b83e9afa5c088573c2281410369fbd32951\n , to_Fp 0x003574a00b109ada2f26a37a91f9d1e740dffd8d69ec0c35e1e9f4652c7dba61123e9dd2e76c655d956e2b3462611139\n ]\n\nproperty hash_to_field_test_2 =\n  ex2_us == ex2_expected_us\n\nproperty hash_to_curve_test_2 =\n    EC::same_point_affine P::E (hash_to_curve (\"abc\", dst))\n    (to_Fp 0x03567bc5ef9c690c2ab2ecdf6a96ef1c139cc0b2f284dca0a9a7943388a49a3aee664ba5379a7655d3c68900be2f6903,\n     to_Fp 0x0b9c15f3fe6e5cf4211f346271d7b01c8f3b28be689c8429c85b67af215533311f0b8dfaaa154fa6b88176c229f2885d)\n\nproperty hash_to_curve_test_3 =\n    EC::same_point_affine P::E (hash_to_curve (\"abcdef0123456789\", dst))\n    (to_Fp 0x11e0b079dea29a68f0383ee94fed1b940995272407e3bb916bbf268c263ddd57a6a27200a784cbc248e84f357ce82d98,\n     to_Fp 0x03a87ae2caf14e8ee52e51fa2ed8eefe80f02457004ba4d486d6aa1f517c0889501dc7413753f9599b099ebcbbd2d709)\n\nproperty hash_to_curve_test_4 =\n    EC::same_point_affine P::E (hash_to_curve (msg_q128, dst))\n    (to_Fp 0x15f68eaa693b95ccb85215dc65fa81038d69629f70aeee0d0f677cf22285e7bf58d7cb86eefe8f2e9bc3f8cb84fac488,\n     to_Fp 0x1807a1d50c29f430b8cafc4f8638dfeeadf51211e1602a5f184443076715f91bb90a48ba1e370edce6ae1062f5e6dd38)\n\nproperty hash_to_curve_test_5 =\n    EC::same_point_affine P::E (hash_to_curve (msg_a512, dst))\n    (to_Fp 0x082aabae8b7dedb0e78aeb619ad3bfd9277a2f77ba7fad20ef6aabdc6c31d19ba5a6d12283553294c1825c4b3ca2dcfe,\n     to_Fp 0x05b84ae5a942248eea39e1d91030458c40153f3b654ab7872d779ad1e942856a20c438e8d99bc8abfbf74729ce1f7ac8)\n```"}]}
{"filename":"BLST-Verification\/spec\/ProjectiveCurveOperationsA0.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification and associated properties for ProjectiveCurveOperationsA0 that implement and verify projective point addition, doubling, subtraction, and scalar multiplication on a short Weierstrass elliptic curve (Jacobian coordinates), including p_point_O, p_double, p_add_generic, p_add_affine, p_add, p_sub, p_mult, and p_mult_affine."},{"role":"assistant","content":"```cryptol\nmodule ProjectiveCurveOperationsA0  where\n\nimport Common::Field\nimport ShortWeierstrassCurve\nimport FieldExtras\n\nprivate\n\n  two: {t} FieldRep t -> t\n  two F = F.add (F.field_unit, F.field_unit)   three: {t} FieldRep t -> t\n  three F = F.add (two F, F.field_unit)\n\n  F_double: {t} FieldRep t -> t -> t\n  F_double F x = F.add (x, x)\n\n  cubed: {t} FieldRep t -> t -> t\n  cubed F x = F.mul(x, F.sq x)\n\np_point_O: {t} EllipticCurve t -> ProjectivePoint t\np_point_O C = (F.field_unit, F.field_unit, F.field_zero) where F = C.base_field\n\np_double: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t\np_double C (X1,Y1,Z1) =\n        if F_is_zero F Z1 then p_point_O C else (X3, Y3, Z3) where \n        F = C.base_field\n        A = F.sq X1         B = F.sq Y1         ZZ = F.sq Z1         C' = F.sq B    \/\/ C = B^2\n        t0 = F.add (X1, B) \/\/t0 = X1+B\n        t1 = F.sq t0 \/\/t1 = t0^2\n        t2 = F.sub (t1, A) \/\/ t2 = t1-A\n        t3 = F.sub (t2, C')         D = F.mul (two F, t3)         E = F.mul (three F, A)         F' = F.sq E \/\/ F = E^2\n        t4 = F_double F D \/\/ F.mul (two F, D) \/\/ t4 = 2*D\n        X3 = F.sub (F', t4)         t5 = F.sub (D, X3)                            t6 = F_double F (F_double F (F_double F C')) \/\/ t6 = 8*C\n        t7 = F.mul (E, t5) \/\/ t7 = E*t5\n        Y3 = F.sub (t7, t6) \/\/ Y3 = t7-t6\n        t8 = F.add (Y1, Z1) \/\/ t8 = Y1+Z1\n        t9 = F.sq t8 \/\/ t9 = t8^2\n        t10 = F.sub (t9, B) \/\/ t10 = t9-B\n        Z3 = F.sub (t10, ZZ) \/\/ Z3 = t10-ZZ\n\n\/**\n * Sum of two distinct points in projective coordinates on the elliptic curve,\n * provided neither is the zero point.\n * If the two points are the same, returns (0,0,0)\n *\/\np_add_generic: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_add_generic C (X1,Y1,Z1) (X2,Y2,Z2) = (X3, Y3, Z3) where\n    F = C.base_field\n    \/\/ using the  \"add-2007-bl\" addition formula\n    Z1Z1 = F.sq Z1                     \/\/ Z1Z1 = Z1^2\n    Z2Z2 = F.sq Z2                     \/\/ Z2Z2 = Z2^2\n    U1 = F.mul (X1, Z2Z2)              \/\/ U1 = X1*Z2Z2\n    U2 = F.mul (X2, Z1Z1)              \/\/ U2 = X2*Z1Z1\n    S1 = F.mul (Y1, F.mul (Z2, Z2Z2))  \/\/ S1 = Y1*Z2*Z2Z2\n    S2 = F.mul (Y2, F.mul (Z1, Z1Z1))  \/\/ S2 = Y2*Z1*Z1Z1\n    H = F.sub (U2, U1)                 \/\/ H = U2-U1\n    I = F.sq (F.mul (two F, H))        \/\/ I = (2*H)^2\n    J = F.mul (H, I)                   \/\/ J = H*I\n    r = F.mul (two F, F.sub (S2, S1))  \/\/ r = 2*(S2-S1)\n    V = F.mul (U1, I)                  \/\/ V = U1*I\n    X3 = F.sub (F.sub (F.sq r, J), F.mul (two F, V))                   \/\/ X3 = r^2-J-2*V\n    Y3 = F.sub (F.mul (r, F.sub (V, X3)), F.mul (F.mul(two F, S1), J)) \/\/ Y3 = r*(V-X3)-2*S1*J\n    Z3 = F.mul (F.sub (F.sub (F.sq (F.add (Z1, Z2)), Z1Z1), Z2Z2), H)  \/\/ Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2)*H\n\n\/*\nThe \"madd-2007-bl\" addition formulas https:\/\/hyperelliptic.org\/EFD\/g1p\/auto-shortw-jacobian-0.html\nis a simple algebraic simplification of the \"add-2007-bl\" formula when Z2 = 1.\n*\/\np_add_affine: {t} EllipticCurve t -> ProjectivePoint t -> AffinePoint t -> ProjectivePoint t\np_add_affine C (X1,Y1,Z1) (X2,Y2) = (X3, Y3, Z3) where\n    F = C.base_field\n    \/\/ using the  \"madd-2007-bl\" addition formula\n    Z1Z1 = F.sq Z1                     \/\/ Z1Z1 = Z1^2\n    U2 = F.mul (X2, Z1Z1)              \/\/ U2 = X2*Z1Z1\n    S2 = F.mul (Y2, F.mul (Z1, Z1Z1))  \/\/ S2 = Y2*Z1*Z1Z1\n    H = F.sub (U2, X1)                 \/\/ H = U2-X1\n    HH = F.sq H                        \/\/ HH = H^2\n    I = F_double F (F_double F HH)     \/\/ I = 4*HH\n    J = F.mul (H, I)                   \/\/ J = H*I\n    r = F.mul (two F, F.sub (S2, Y1))  \/\/ r = 2*(S2-Y1)\n    V = F.mul (X1, I)                  \/\/ V = X1*I\n    X3 = F.sub (F.sub (F.sq r, J), F.mul (two F, V))                   \/\/ X3 = r^2-J-2*V\n    Y3 = F.sub (F.mul (r, F.sub (V, X3)), F.mul (F.mul(two F, Y1), J)) \/\/ Y3 = r*(V-X3)-2*Y1*J\n    Z3 = F.sub (F.sub (F.sq (F.add (Z1, H)), Z1Z1), HH)                \/\/ Z3 = (Z1+H)^2-Z1Z1-HH\n\n\/**\n * Sum of two points in projective coordinates on the elliptic curve.\n *\/\np_add: {t} EllipticCurve t ->  ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_add C S T = \n    if F_is_zero F Z1 then T\n     | F_is_zero F Z2 then S\n     | all (F_is_zero F) [X3,Y3,Z3] then p_double C S \/\/ FIX: does this still work?\n     else R\n    where\n        F = C.base_field\n        (_,_,Z1) = S\n        (_,_,Z2) = T\n        R = p_add_generic C S T\n        (X3,Y3,Z3) = R\n\n\/**\n * Difference of two points in projective coordinates on the elliptic curve.\n *\/\np_sub: {t} EllipticCurve t ->  ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_sub C S (x,y,z) = p_add C S (x, C.base_field.neg y, z)\n\n\/**\n * Integer multiple of a point in projective coordinates on the elliptic curve.\n * The multiplier, a bitvector, is interpreted as a non-negative integer.\n *\/\np_mult: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> ProjectivePoint t -> ProjectivePoint t\np_mult C d S = if d == 0 then p_point_O C\n               |  d == 1 then S\n               |  F_is_zero F S.2 then p_point_O C\n               else Rs!1\n    where\n        F = C.base_field\n        k = 0b00 # d \/\/ 2 extra top bits, so that h does not overflow\n        h = k + k + k\n        Rs = [p_point_O C] # \/\/Here we start with 1 instead of S because we don't really know where the high-bit is\n             [ if hi && ~ki then p_add C RiDouble S\n                | ~hi && ki then p_sub C RiDouble S\n                else RiDouble\n               where RiDouble = p_double C Ri\n             | ki <- k | hi <- h | Ri <- Rs ]\n\np_mult_affine: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> AffinePoint t -> AffinePoint t\np_mult_affine C d S =\n               if d == 0 then point_O C\n               |  d == 1 then S\n               |  is_point_O C S then S\n               else affinify C (Rs!1)\n    where\n        F = C.base_field\n        negS = ( (x, F.neg y) where (x,y) = S )\n        k = 0b00 # d         h = k + k + k\n        Rs = [p_point_O C] #              [ if hi && ~ki then add' RiDouble S\n                | ~hi && ki then add' RiDouble negS\n                else RiDouble\n               where RiDouble = p_double C Ri\n             | ki <- k | hi <- h | Ri <- Rs ]\n        add': ProjectivePoint t -> AffinePoint t -> ProjectivePoint t \/\/ \"full\" version of p_add_affine\n        add' U V = if F_is_zero F Z1 then projectify C V\n                  |  all (F_is_zero F) [X3,Y3,Z3] then p_double C U\n                  else R\n            where\n                (_,_,Z1) = U\n                R = p_add_affine C U V\n                (X3,Y3,Z3) = R\n```"}]}
{"filename":"BLST-Verification\/spec\/Polynomial.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify Cryptol functions for polynomial arithmetic over a finite field (equality, zero\/one\/x, degree, leading coefficient, add\/sub, (full) multiply, divide-with-remainder, modular multiply, and modular inverse) using a FieldRep parameter, matching the behaviors implied by the given type signatures and names."},{"role":"assistant","content":"```cryptol\nmodule Polynomial where\n\nimport Common::Field\n\npoly_equal:  {t,k} (fin k, k>=1) => FieldRep t -> ([k]t, [k]t) -> Bool\npoly_equal F (p,q) = and (zipWith (curry F.is_equal) p q)\n\npoly_0: {t,k} (fin k) => FieldRep t -> [k]t\npoly_0 F = repeat F.field_zero\n\npoly_const: {t,k} (fin k, k >= 1) => FieldRep t -> t -> [k]t\npoly_const F c = (repeat F.field_zero) # [c]\n\npoly_1: {t,k} (fin k, k >= 1) => FieldRep t -> [k]t\npoly_1 F = poly_const F F.field_unit\n\npoly_x: {t,k} (fin k, k >= 2) => FieldRep t -> [k]t\npoly_x F = (repeat F.field_zero) # [F.field_unit, F.field_zero]\n\npoly_degree: {t, k, a} (fin k, Ring a, Literal (max 1 k) a)\n             => FieldRep t -> [k+1]t -> a\npoly_degree F coeffs = (ds!0).0 where\n    ds = [(`k,True)] # [ if lz \/\\ F.is_equal(ci, F.field_zero) then (d-1,True) else (d, False)\n                       | (d,lz) <- ds\n                       | ci <- coeffs\n                       ]\n\nleading_coefficient: {t,k} (fin k) => FieldRep t -> [k]t -> t\nleading_coefficient F p =\n    foldr (\\ c a -> if F.is_equal (c, F.field_zero) then a else c) F.field_zero p\n\npoly_add: {t,k} (fin k) => FieldRep t -> [k]t -> [k]t -> [k]t\npoly_add F = zipWith (curry F.add)\n\npoly_sub: {t,k} (fin k) => FieldRep t -> [k]t -> [k]t -> [k]t\npoly_sub F = zipWith (curry F.sub)\n\nprivate\n    shifts: {k,t} (fin k, k >= 1) => t -> [k]t -> [k][k]t\n    shifts pad seq = take seqs where\n        seqs = [seq] # [shift s | s <- seqs]\n        shift s = tail s # [pad]\n\npoly_mul: {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t -> [k]t\npoly_mul F p q = foldl (poly_add`{t,k} F) (poly_0 F) rows where\n    rows: [k][k]t\n    rows = zipWith (\\ c s -> map (curry F.mul c) s) p (reverse (shifts F.field_zero q))\n\npoly_full_mul: {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t -> [2*k-1]t\npoly_full_mul F p q = foldl (poly_add F) (poly_0 F) rows where\n    rows: [k][2*k-1]t\n    rows = zipWith (\\ c s -> map (curry F.mul c) s) p (reverse (full_shifts F.field_zero q))\n    full_shifts: t -> [k]t -> [k][2*k-1]t\n    full_shifts pad seq = take seqs where\n        seqs = [(repeat pad) # seq] # [shift s | s <- seqs]\n        shift s = tail s # [pad]\n\npoly_div_mod: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t -> ([k]t, [k]t)\npoly_div_mod F dividend divisor =(quot, rems!0) where\n        ds: [k][k]t\n    ds = reverse (shifts F.field_zero divisor)\n        use: [k]Bool\n    use = reverse us where\n      us = [True] # [u \/\\ F.is_equal (d@0, F.field_zero) | u <- us | d <- take`{k-1} (reverse ds)]\n        ix: [k+1][width k]\n    ix = [0] # [if u then i+1 else i | u <- use | i <- ix]\n        c = F.div (F.field_unit, leading_coefficient F divisor)\n        quot: [k]t\n    quot = [ if u then F.mul (c, rem@i) else F.field_zero\n           | u <- use\n           | rem <- rems\n           | i <- ix\n           ]\n        rems: [k+1][k]t\n    rems = [dividend] # [ zipWith (curry F.sub) r (map (curry F.mul q) d)\n                        | r <- rems\n                        | q <- quot\n                        | d <- ds\n                        ]\n\nprivate\n\n    shifts_mod: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t -> [k][k]t\n    shifts_mod F p m = take seqs where\n        seqs = [p] # [shift s | s <- seqs]\n        shift s = poly_add F (tail s # [F.field_zero]) (map (curry F.mul (s@0)) m)\n\npoly_mul_mod: {t,k} (fin k, k>=1) => FieldRep t -> [k]t -> [k]t -> [k]t -> [k]t\npoly_mul_mod F p q m = foldl (poly_add`{t,k} F) (poly_0 F) rows where\n    rows: [k][k]t\n    rows = zipWith (\\ c s -> map (curry F.mul c) s) p (reverse (shifts_mod F q m))\n\npoly_inverse_mod: {k,t} (fin k, k >= 1) => FieldRep t -> [k]t -> [k]t -> [k]t\npoly_inverse_mod F p q = r where\n                poly_of_q = [F.field_unit] # (map F.neg q)     expand_p = [F.field_zero] # p     (q1,r1) = poly_div_mod F poly_of_q expand_p\n        tuples = [ (tail r1, p, map F.neg (tail q1), poly_1 F) ]\n             # map (pim_step F q) tuples\n    (p1,p2,s1,s2) = tuples@(`k:Integer)                 r = map (curry F.mul (F.div (F.field_unit, p1!0))) s1\n\nprivate\n    pim_step F m (p1, p2, s1, s2) =\n        if poly_equal F (p2, poly_0 F)\n        then (p1, p2, s1, s2)\n        else ( (p2, r, s2, poly_sub F s1 (poly_mul_mod F q s2 m)) where\n               (q,r) = poly_div_mod F p1 p2\n             )\n```"}]}
{"filename":"BLST-Verification\/spec\/BLSMinimalPublicKeySize.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the BLSMinimalPublicKeySize module for BLS12-381 minimal public keys, including types, hash_to_point, serialization\/deserialization, subgroup checks, and pairing-based operations using the given pubkey_len, signature_len, DST, and imported curve\/field parameters."},{"role":"assistant","content":"```cryptol\nmodule BLSMinimalPublicKeySize = BLSGeneric where\n\nimport Parameters\nimport HashToCurveE2\nimport Pairing (bls_ate_pairing)\nimport Serialization\nimport ShortWeierstrassCurve as EC\n\ntype t_F = t_Fp_2 type t_F' = t_Fp \/\/ representation type for field of the secondary curve (pubkey)\ntype t_G = t_Fp_12  \/\/ representation type for field of the pairing result\nG = Fp_12\n\ntype pubkey_len = 48*8\ntype signature_len  = 96*8\n\nmain_curve = E'\nother_curve = E\n\nDST: [43][8]\nDST = \"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\"\n\nhash_to_point hx = hash_to_curve_opt (hx, DST)\n\nP: EC::AffinePoint t_F' \/\/ base point\nP = BP\n\n\/\/ pairing: (EC::AffinePoint t_F, EC::AffinePoint t_F') -> t_G\npairing (p,q) = bls_ate_pairing q p \npoint_to_pubkey S = join (serialize_E1 S)\n\npoint_to_signature S = join (serialize_E2 S)\n\npubkey_to_point S = uncompress_E1 (split S)\n\nsignature_to_point S = deserialize_E2 (split S)\n\npubkey_subgroup_check S =\n    EC::is_point_O E (EC::mult E r S)\n\nsignature_subgroup_check S =\n    EC::is_point_O E' (EC::mult E' r S)\n```"}]}
{"filename":"BLST-Verification\/spec\/CoreVerifyPKInG1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function core_verify_pk_in_g1 that verifies a BLS public key in G1 using pairings, given a public key pk, signature sig, message msg, and domain separation tag dst, returning whether the two computed Fp_12 pairings are equal."},{"role":"assistant","content":"```cryptol\nmodule CoreVerifyPKInG1 where\n\nimport Parameters\nimport HashToCurveE2\nimport Pairing\n\ncore_verify_pk_in_g1 pk sig msg dst = Fp_12.is_equal(c1, c2) where\n    c1 = bls_ate_pairing pk (hash_to_curve_opt (msg, dst))\n    c2 = bls_ate_pairing BP sig\n```"}]}
{"filename":"BLST-Verification\/spec\/ExtensionField.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the `extension_field` function, constructing a `FieldRep ([k]t)` from a base `FieldRep t` and an irreducible polynomial `[k]t`, using polynomial-based addition, multiplication modulo the polynomial, inversion, and related field operations."},{"role":"assistant","content":"```cryptol\nmodule ExtensionField where\n\nimport Common::Field\nimport Polynomial\n\nextension_field: {k, t} (fin k, k >= 1) => FieldRep t -> [k]t -> FieldRep ([k]t)\nextension_field F p =\n    { is_val = all F.is_val\n    , normalize = map F.normalize\n    , field_zero = poly_0 F\n    , field_unit = poly_1 F\n    , add (a,b) = poly_add F a b     , sub (a,b) = poly_sub F a b\n    , neg = map  F.neg\n    , mul (a,b) = poly_mul_mod F a b p\n    , sq a = poly_mul_mod F a a p\n    , half = map F.half\n    , div (a,b) = poly_mul_mod F a bi p where bi = poly_inverse_mod F b p\n    , is_equal (a,b) = all F.is_equal (zip a b)\n    }\n```"}]}
{"filename":"BLST-Verification\/spec\/HashToCurveGeneric.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the Cryptol module `HashToCurveGeneric` implementing hash-to-curve for a short Weierstrass elliptic curve over field `t_F`, including `hash_to_curve`, `hash_to_curve_opt`, `hash_to_field`, `hash_to_field_1`, `map_to_curve_simple_swu`, and `map_to_curve_simple_swu_AB0` with all given parameters and constraints."},{"role":"assistant","content":"```cryptol\nmodule HashToCurveGeneric where\n\nimport rfc8017 (I2OSP, OS2IP)\nimport Primitive::Keyless::Hash::SHA256 as SHA256\nimport Common::Field\nimport Parameters (t_Fp, Fp, to_Fp)\nimport FieldExtras\nimport ShortWeierstrassCurve as EC\nimport ExpandMessage\nimport Common::bv\n\nparameter\n    type _p: #     type constraint fin _p\n    type constraint width _p <= 384 \n    type _q: #     type constraint fin _q\n\n    type _t_F: *     _F: FieldRep _t_F \n    type _m: #     type constraint fin _m\n\n        type constraint 8 * ((128 + lg2 p) \/^ 8) >= 384\n    type constraint 2 * m <= 127\n\n        _base_to_F: [m]t_Fp -> _t_F\n\n        _C: EC::EllipticCurve _t_F\n\n    _clear_cofactor: (_t_F, _t_F) -> (_t_F, _t_F) \n        _is_square: _t_F -> Bool\n    _sqrt: _t_F -> _t_F\n    _sgn0: _t_F -> Bit     _inv0: _t_F -> _t_F\n\n        _Z: _t_F\n    _A': _t_F\n    _B': _t_F\n    _iso_map: (_t_F, _t_F) -> (_t_F, _t_F)\n\ntype p = _p\ntype q = _q\ntype t_F = _t_F\nF: FieldRep t_F F = _F\ntype m = _m base_to_F = _base_to_F\nC = _C\nclear_cofactor = _clear_cofactor\nis_square = _is_square\nsqrt = _sqrt\nsgn0 = _sgn0\ninv0 = _inv0\nZ = _Z\nA' = _A'\nB' = _B'\niso_map = _iso_map\n\nhash_to_curve: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 2 * m <= 127                               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384                ) =>\n               ([msg_len][8], [DST_len][8]) -> EC::AffinePoint t_F\nhash_to_curve (msg,dst) = P where\n    u = hash_to_field`{count=2} msg dst     Q0 = map_to_curve_simple_swu_AB0 (u@0)\n    Q1 = map_to_curve_simple_swu_AB0 (u@1)\n    R = EC::add C Q0 Q1\n    P = clear_cofactor R\n\nhash_to_curve_opt: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 2 * m <= 127                               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384                ) =>\n               ([msg_len][8], [DST_len][8]) -> EC::AffinePoint t_F\nhash_to_curve_opt (msg,dst) = P where\n    u = hash_to_field`{count=2} msg dst     Q0 = map_to_curve_simple_swu (u@0)     Q1 = map_to_curve_simple_swu (u@1)     R = EC::add Isogenous_Curve Q0 Q1\n    P = clear_cofactor (iso_map R)\n\nhash_to_field: {msg_len, DST_len, count}\n               (fin msg_len, fin DST_len, fin count\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , count * m <= 127                , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384                ) =>\n               [msg_len][8] -> [DST_len][8] -> [count]t_F\n\nhash_to_field msg DST = us where\n      type k = 128       type L = ((lg2 p) + k) \/^ 8       uniform_bytes: [count * m * L][8]\n      uniform_bytes = expand_message msg DST\n                        parts: [count][m][L][8]\n      parts = split (split uniform_bytes)\n            us = [ make_u_i part | part <- parts ]\n      make_u_i: [m][L][8] -> t_F\n            make_u_i part = base_to_F [to_Fp (drop`{back=384} ((join bytes) % `p)) | bytes <- part]\n\nhash_to_field_1: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384                ) =>\n               [msg_len][8] -> [DST_len][8] -> [384]\nhash_to_field_1 msg DST = us where\n      type L = 64\n      uniform_bytes: [L][8]\n      uniform_bytes = expand_message msg DST\n      us = drop`{back=384} ((join uniform_bytes) % `p)\n\nmap_to_curve_simple_swu: t_F -> (t_F, t_F)\nmap_to_curve_simple_swu u = ret where\n        tv1 = inv0 (F.add (F.mul (F.sq Z, F.sq (F.sq u)),\n                       F.mul (Z, F.sq u)))\n            x1 = if F_is_zero F (tv1)\n         then F.div (B', F.mul (Z, A'))\n         else F.mul (F.div (F.neg B', A'), F.add(F.field_unit, tv1))\n        gx1 = F.add (cube x1, F.add (F.mul (A', x1), B'))\n        x2 = F.mul (Z, F.mul (F.sq u, x1))\n        gx2 = F.add (cube x2, F.add (F.mul (A', x2), B'))\n            (x,y) = if is_square(gx1) then (x1, sqrt(gx1)) else (x2, sqrt(gx2))\n            ret = if sgn0(u) != sgn0(y) then (x, F.neg y) else (x,y)\n\n    cube z = F.mul (z, F.sq z)\n\nmap_to_curve_simple_swu_AB0(u) = (x, y) where\n    (x', y') = map_to_curve_simple_swu (u)     (x, y) = iso_map(x', y')               \nIsogenous_Curve: EC::EllipticCurve t_F\nIsogenous_Curve = {base_field=F, a = A', b = B'}\n```"}]}
{"filename":"BLST-Verification\/spec\/HashToCurveE1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the HashToCurveE1 module, including the is_square, sqrt, sgn0, inv0, clear_cofactor, and iso_map functions for BLS12-381 G1, suitable for verifying hash-to-curve mappings against the IETF hash-to-curve standard."},{"role":"assistant","content":"```cryptol\nmodule HashToCurveE1 = HashToCurveGeneric where\n\nimport Parameters as P\nimport FieldExtras\nimport ShortWeierstrassCurve as EC\nimport HashToCurveE1Aux as Aux\nimport BLSFieldExtras (sqrt_fp)\n\ntype _p = P::p type _q = P::p type _t_F = P::t_Fp _F = P::Fp type _m = 1 _base_to_F [x] = x \n_C = P::E \n\n_is_square x =  y == 0 \\\/ y == 1 where\n    y = F_expt`{n=width _q} _F x `((_q-1)\/2)\n\n_sqrt = sqrt_fp\n\n_sgn0 = Aux::sgn0\n\n_inv0 x = F_expt`{n=width _q} _F x `(_q-2) \n_Z = Aux::Z\n_A' = Aux::A'\n_B' = Aux::B'\n\n_clear_cofactor P = EC::mult _C Aux::h_eff P\n\n_iso_map: (_t_F, _t_F) -> (_t_F, _t_F)\n_iso_map (x', y') = if EC::is_point_O _C (x',y') then EC::point_O _C else (x, y) where\n    x_powers = [_F.field_unit] # [_F.mul(x', xi) | xi <- x_powers]\n    x_num = F_sum _F [_F.mul(ki, xi) | ki <- Aux::k1s | xi <- x_powers]\n    x_den = _F.add (x_powers@10, F_sum _F [_F.mul(ki, xi) | ki <- Aux::k2s | xi <- x_powers])\n    y_num = F_sum _F [_F.mul(ki, xi) | ki <- Aux::k3s | xi <- x_powers]\n    y_den = _F.add (x_powers@15, F_sum _F [_F.mul(ki, xi) | ki <- Aux::k4s | xi <- x_powers])\n    x = _F.div (x_num, x_den)\n    y = _F.mul (y', _F.div(y_num, y_den))\n```"}]}
{"filename":"BLST-Verification\/spec\/HashToCurveE2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol the hash-to-curve mapping onto the BLS12-381 G2 subgroup over Fp\u00b2, including is_square, sqrt, sgn0, inv0, isogeny map _iso_map, and cofactor clearing _clear_cofactor, ensuring the output points lie on the correct curve and subgroup."},{"role":"assistant","content":"```cryptol\nmodule HashToCurveE2 = HashToCurveGeneric where\n\nimport Parameters as P\nimport FieldExtras\nimport ShortWeierstrassCurve as EC\nimport HashToCurveE2Aux as Aux\n\ntype _p = P::p type _q = P::p * P::p type _t_F = P::t_Fp_2 _F = P::Fp_2 type _m = 2 _base_to_F xs = reverse xs \n_C = P::E' \/\/ {base_field = F, a = F.field_zero, b = P::b'}\n\nCMOV (a,b,c) = if c==False then a else b\n\n_is_square x =  _F.is_equal (y, _F.field_zero) \\\/ _F.is_equal (y, _F.field_unit) where\n    y = F_expt`{n = width _q} _F x `((_q-1)\/2)\n\n_sqrt x = z where\n    tv1 = F_expt`{n=width ((_q+7)\/16)} _F x `((_q+7)\/16)\n    tv2 = _F.mul (c1, tv1)\n    tv3 = _F.mul (c2, tv1)\n    tv4 = _F.mul (c3, tv1)\n    e1 =  _F.is_equal (_F.sq tv2, x)\n    e2 =  _F.is_equal (_F.sq tv3, x)\n\n    tv1_1 = CMOV (tv1, tv2, e1)\n    tv2_1 = CMOV (tv4, tv3, e2)\n    e3 = _F.is_equal (_F.sq tv2_1, x)\n    z = CMOV (tv1_1, tv2_1, e3)\n\n            c1 = [1,0]\n        k: P::t_Fp\n    k = 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257\n            c2 = [k, P::Fp.neg k]     c3 = [k, k] \n_sgn0 [x_1, x_0] =  sign_0 || (zero_0 && sign_1) where\n        x_0' = P::from_Fp x_0\n    x_1' = P::from_Fp x_1\n    sign_0 = x_0'!0 \/\/ least-signifcant bit\n    zero_0 = x_0' == 0     sign_1 = x_1'!0\n\n_inv0 x = F_expt`{n=width (_q-2)} _F x `(_q-2) \/\/ but could be F.div (_F.field_unit, x)\n\n\/\/ Constants from Section 8.8.2\n_Z = _F.neg [1, 2] \/\/ -(2+I)\n\/\/ A' = [to_Fp 240, 0]: t_F _A' = Aux::to_Fp2 (0,240)\n\/\/B' = [to_Fp 1012, to_Fp 1012]: t_F  _B' = Aux::to_Fp2 (1012,1012)\n\nh_eff = 0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551\n\n_clear_cofactor P = EC::mult _C h_eff P\n\n_iso_map: (_t_F, _t_F) -> (_t_F, _t_F)\n_iso_map (x', y') = if EC::is_point_O _C (x',y') then EC::point_O _C else (x, y) where\n    x_powers = [_F.field_unit] # [_F.mul(x', xi) | xi <- x_powers]\n    x_num = F_sum _F [_F.mul(ki, xi) | ki <- Aux::k1s | xi <- x_powers]\n    x_den = _F.add (x_powers@2, F_sum _F [_F.mul(ki, xi) | ki <- Aux::k2s | xi <- x_powers])\n    y_num = F_sum _F [_F.mul(ki, xi) | ki <- Aux::k3s | xi <- x_powers]\n    y_den = _F.add (x_powers@3, F_sum _F [_F.mul(ki, xi) | ki <- Aux::k4s | xi <- x_powers])\n    x = _F.div (x_num, x_den)\n    y = _F.mul (y', _F.div(y_num, y_den))\n```"}]}
{"filename":"BLST-Verification\/spec\/ProjectiveCurveOperations.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of projective elliptic-curve group operations over a Short Weierstrass curve, including functions p_point_O, p_neg, p_double, p_add_generic, p_add, p_sub, p_mult, and p_mult_affine, and suitable properties verifying they correctly implement group law and scalar multiplication."},{"role":"assistant","content":"```cryptol\nmodule ProjectiveCurveOperations  where\n\nimport Common::Field\nimport ShortWeierstrassCurve\nimport FieldExtras\n\nprivate\n\n  two: {t} FieldRep t -> t\n  two F = F.add (F.field_unit, F.field_unit)   three: {t} FieldRep t -> t\n  three F = F.add (two F, F.field_unit)\n\n  F_double: {t} FieldRep t -> t -> t\n  F_double F x = F.add (x, x)\n\n  F_by4 F x = F_double F (F_double F x)\n  F_by8 F x = F_double F (F_by4 F x)\n\n  cubed: {t} FieldRep t -> t -> t\n  cubed F x = F.mul(x, F.sq x)\n\np_point_O: {t} EllipticCurve t -> ProjectivePoint t\np_point_O C = (F.field_unit, F.field_unit, F.field_zero) where F = C.base_field\n\np_neg: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t\np_neg C (x,y,z) = (x, C.base_field.neg y, z)\n\np_double: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t\np_double C (X1,Y1,Z1) =\n            (X3, Y3, Z3) where \n        F = C.base_field\n        XX = F.sq X1                    YY = F.sq Y1                    ZZ = F.sq Z1                    t0 = F.mul (X1, YY)             S = F_by4 F t0                  t1 = F.sq ZZ                    t2 = F.mul (C.a, t1)            t3 = F.mul(three F, XX)         M = F.add(t3, t2)               t4 = F.sq M                     t5 = F_double F S               T = F.sub (t4, t5)              X3 = T                          t6 = F.sub (S, T)               t7 = F.sq YY                    t8 = F_by8 F t7                 t9 = F.mul (M, t6)              Y3 = F.sub (t9, t8)             t10 = F.mul (Y1, Z1)            Z3 = F_double F t10         \n\np_add_generic: {t} EllipticCurve t -> ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_add_generic C (X1,Y1,Z1) (X2,Y2,Z2) = (X3, Y3, Z3) where\n    F = C.base_field\n        t0 = F.sq Z2              U1 = F.mul (X1, t0)       t1 = F.sq Z1              U2 = F.mul (X2, t1)       t2 = F.mul (Z2, t0)       S1 = F.mul (Y1, t2)       t3 = F.mul (Z1, t1)       S2 = F.mul (Y2, t3)       P = F.sub (U2, U1)        R = F.sub (S2, S1)        t4 = F.add (U1, U2)       t5 = F.sq R               t6 = F.sq P               t7 = F.mul (t4, t6)       X3 = F.sub (t5, t7)       t8 = F.sq P               t9 = F.mul (U1, t8)       t10 = F.sub (t9, X3)      t11 = F.mul (P, t8)       t12 = F.mul (S1, t11)     t13 = F.mul (R, t10)      Y3 = F.sub (t13, t12)     t14 = F.mul (Z2, P)       Z3 = F.mul (Z1, t14)  \n\np_add: {t} EllipticCurve t ->  ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_add C S T = \n    if F_is_zero F Z1 then T\n     | F_is_zero F Z2 then S\n     | all (F_is_zero F) [X3,Y3,Z3] then p_double C S      else R\n    where\n        F = C.base_field\n        (_,_,Z1) = S\n        (_,_,Z2) = T\n        R = p_add_generic C S T\n        (X3,Y3,Z3) = R\n\np_sub: {t} EllipticCurve t ->  ProjectivePoint t -> ProjectivePoint t -> ProjectivePoint t\np_sub C S T = p_add C S (p_neg C T)\n\np_mult: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> ProjectivePoint t -> ProjectivePoint t\np_mult C d S = if d == 0 then p_point_O C\n               |  d == 1 then S\n               |  F_is_zero F S.2 then p_point_O C\n               else Rs!1\n    where\n        F = C.base_field\n        k = 0b00 # d         h = k + k + k\n        Rs = [p_point_O C] #              [ if hi && ~ki then p_add C RiDouble S\n                | ~hi && ki then p_sub C RiDouble S\n                else RiDouble\n               where RiDouble = p_double C Ri\n             | ki <- k | hi <- h | Ri <- Rs ]\n\np_mult_affine: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> AffinePoint t -> AffinePoint t\np_mult_affine C d S = affinify C (p_mult C d (projectify C S))\n```"}]}
{"filename":"BLST-Verification\/spec\/ShortWeierstrassCurve.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for elliptic curve group operations over a short Weierstrass curve, including affine\/projective point representations, point validation, negation, addition, doubling, scalar multiplication, and properties that these operations satisfy the elliptic curve group laws."},{"role":"assistant","content":"```cryptol\nmodule ShortWeierstrassCurve where\n\nimport Common::Field\n\ntype EllipticCurve t =\n  { base_field: FieldRep t\n  , a: t\n  , b: t\n  } \ntype AffinePoint rep = (rep, rep) type ProjectivePoint rep = (rep, rep, rep) \n\npoint_O: {t} EllipticCurve t ->  AffinePoint t\npoint_O C = (F.field_zero, F.field_zero) where F = C.base_field\n\nis_point_O: {t} EllipticCurve t ->  AffinePoint t -> Bool\nis_point_O C S = same_point_affine C S (point_O C)\n\nprojectify: {t} EllipticCurve t -> AffinePoint t -> ProjectivePoint t\nprojectify C (x,y) = (x, y, C.base_field.field_unit)\n\naffinify: {t} EllipticCurve t -> ProjectivePoint t -> AffinePoint t\naffinify C (x,y,z) = if is_zero F z\n                     then point_O C\n                     else (F.mul(lambda2, x), F.mul(lambda3, y))\n    where\n        F = C.base_field\n        lambda = F.div (F.field_unit, z)\n        lambda2 = F.sq lambda\n        lambda3 = F.mul(lambda, lambda2)\n\nprivate\n    cubed: {t} FieldRep t -> t -> t\n    cubed F x = F.mul (x, F.sq x)\n\n    fourth: {t} FieldRep t -> t -> t\n    fourth F x = F.sq (F.sq x)\n\n    sixth: {t} FieldRep t -> t -> t\n    sixth F x = F.sq (cubed F x)\n\n    is_zero: {t} FieldRep t -> t -> Bit\n    is_zero F x = F.is_equal (x, F.field_zero)\n\n            twice: {t} FieldRep t -> t -> t\n    twice F x = F.add (x, x)\n\n    thrice: {t} FieldRep t -> t -> t\n    thrice F x = F.add (x, twice F x)\n\nsame_point: {t} EllipticCurve t -> ProjectivePoint t ->  ProjectivePoint t -> Bool\nsame_point C (x,y,z) (x',y',z')  =\n    F.is_equal (F.mul (x, F.sq z'), F.mul (x', F.sq z)) \/\\\n    F.is_equal (F.mul (y, cubed F z'), F.mul (y', cubed F z))\n    where F = C.base_field\n\n\/**\n * Are two affine points on a curve equal?\n *\/\nsame_point_affine:  {t} EllipticCurve t -> AffinePoint t ->  AffinePoint t -> Bool\nsame_point_affine C (x,y) (x',y') = F.is_equal (x, x') \/\\ F.is_equal (y, y')\n    where F = C.base_field\n\n\/**\n * Is a given point in affine coordinates on a given curve?\n *\/\nis_point_affine: {t} EllipticCurve t -> AffinePoint t -> Bit\nis_point_affine C S = is_point_O C S \\\/\n                      (F.is_val x \/\\ F.is_val y \/\\\n                       F.is_equal(F.sq y, F.add(cubed F x, F.add (F.mul (C.a, x), C.b))))\n    where F = C.base_field\n          (x,y) = S\n\n\/**\n * Is a given point in Jacobian projective coordinates on a given curve?\n *\/\nis_point_projective : {t} EllipticCurve t -> ProjectivePoint t -> Bit\nis_point_projective C (x,y,z) = F.is_val x \/\\ F.is_val y \/\\ F.is_val z \/\\ F.is_equal(F.sq y, t)\n    where t = F.add(cubed F x, F.add (F.mul (F.mul (C.a, x), fourth F z), F.mul (C.b, sixth F z)))\n          F = C.base_field\n\n\/\/ Group operations on the curve, using affine coordinates\n\n\/**\n * The negative of a point in affine coordinates on a curve.\n *\/\nneg: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t\nneg C (x,y) = (x, C.base_field.neg y)\n\ndouble: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t\ndouble C P = if is_point_O C P then P\n             | is_zero C.base_field P.1 then point_O C \/\/ check this!\n             else double_non_O C P\n\nprivate\n    double_non_O: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t\n    double_non_O C (x1,y1) = (x3,y3) where\n        F = C.base_field\n        \/\/ x3 = (3*x1^2+a)^2\/(2*y1)^2-x1-x1\n        x3 = F.sub (F.sq R0, twice F x1)\n        \/\/y3 = (2*x1+x1)*(3*x1^2+a)\/(2*y1)-(3*x1^2+a)^33\/(2*y1)^3-y1\n        \/\/ y3 = F.sub (F.sub (R1, R2), y1)\n        \/\/ alt formula (Wiki)\n        y3 = F.sub (F.mul (R0, F.sub(x1,x3)), y1)\n        R0 = F.div (F.add (thrice F (F.sq x1), C.a), twice F y1) \/\/ (3*x1^2+a)\/(2*y1)\n        R1 = F.mul (thrice F x1, R2)\n        R2 = cubed F R0\n\n\/**\n * The sum of two points in affine coordinates on a curve.\n * This can give meaningless results if the given points are not in fact\n * on the curve.\n *\/\nadd: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\nadd C P Q = if same_point_affine C P (point_O C) then Q\n            |  same_point_affine C Q (point_O C) then P\n            |  same_point_affine C P (neg C Q) then point_O C\n            |  same_point_affine C P Q then double C P\n            else raw_add C P Q \n\nprivate\n  raw_add: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\n  raw_add C (x1,y1) (x2,y2) = (x3,y3) where\n    F = C.base_field\n    \/\/ x3 = (y2-y1)^2\/(x2-x1)^2-x1-x2\n    x3 = F.sub (F.sub (F.sq R0, x1), x2)\n    \/\/ y3 = (2*x1+x2)*(y2-y1)\/(x2-x1)-(y2-y1)^3\/(x2-x1)^3-y1\n    y3 = F.sub (F.sub (R1, R2), y1)\n    R0 = F.div (F.sub (y2, y1), F.sub (x2, x1)) \/\/ (y2-y1)\/(x2-x1)\n    R1 = F.mul (F.add (twice F x1, x2), R0)\n    R2 = cubed F R0\n\n\/**\n * The difference of two points in affine coordinates on a curve.\n * This can give meaningless results if the given points are not in fact\n *  on the curve.\n *\/\nsub: {t} EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\nsub C P Q = add C P (neg C Q)\n\n\/**\n * Integer multiple of a point on the elliptic curve.  The multiplier,\n * a bitvector, is interpreted as a non-negative integer.\n *\/ \nmult: {k, t} (fin k, k >= 1) => EllipticCurve t -> [k] -> AffinePoint t -> AffinePoint t\nmult C d S = if d == 0 then point_O C\n             | d == 1 then S\n             | same_point_affine C S (point_O C) then point_O C\n             else Rs!1\n  where k = 0b00 # d \/\/ 2 extra top bits, so h does not overflow (e.g. for d=0b11)\n        h = k + k + k\n        Rs = [point_O C] # \/\/ start with 1 instead of S; we don't really know where the high-bit is\n             [ if hi && ~ki then add C RiDouble S\n                | ~hi && ki then sub C RiDouble S\n                else RiDouble\n               where RiDouble = double C Ri\n             | ki <- k\n             | hi <- h\n             | Ri <- Rs ]\n\nscalar_mult: {t} EllipticCurve t -> Integer -> AffinePoint t -> AffinePoint t\nscalar_mult C k P = if k < 0 then scalar_mult C (-k) (neg C P)\n                     else if k == 0 then point_O C\n                     else add C P (scalar_mult C (k-1) P)\n```"}]}
{"filename":"BLST-Verification\/spec\/G2SubGroupCheck.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification in module G2SubGroupCheck that defines the psi endomorphism on BLS12-381 G2 points over Fp\u00b2 (in affine, projective-pair, and Jacobian coordinates) and includes properties showing these conversions are consistent and that psi is correctly derived from Frobenius and constants psi_c1, psi_c2."},{"role":"assistant","content":"```cryptol\nmodule G2SubGroupCheck where\n\nimport Parameters (p, Fp_2, t_Fp_2, E', BP', r)\nimport Frobenius\nimport Pairing (alpha) import FieldExtras\nimport ShortWeierstrassCurve\n\ntype projective_pair_fp2 = (t_Fp_2, t_Fp_2, t_Fp_2, t_Fp_2)\n\npsi_projective: projective_pair_fp2 -> projective_pair_fp2\npsi_projective (xn, xd, yn, yd) = (qxn, qxd, qyn, qyd) where\n    qxn = Fp_2.mul (psi_c1, fp2_frobenius xn)\n    qxd = fp2_frobenius xd\n    qyn = Fp_2.mul (psi_c2, fp2_frobenius yn)\n    qyd = fp2_frobenius yd\n\npsi_c1: t_Fp_2\npsi_c1 = F_expt`{n=384} Fp_2 alpha ((`p-1)\/3)\n\npsi_c2: t_Fp_2\npsi_c2 = F_expt`{n=384} Fp_2 alpha ((`p-1)\/2)\n\nprojective_pair_to_jacobian: projective_pair_fp2 -> ProjectivePoint t_Fp_2\nprojective_pair_to_jacobian (xn, xd, yn, yd) = (X', Y', Z') where\n    X' = Fp_2.mul (xn, Fp_2.mul (xd, Fp_2.sq yd))\n    Y' = Fp_2.mul (yn, Fp_2.mul (Fp_2.sq yd, Fp_2.mul (xd, Fp_2.sq xd)))\n    Z' = Fp_2.mul (xd, yd)\n\njacobian_to_projective_pair: ProjectivePoint t_Fp_2 -> projective_pair_fp2\njacobian_to_projective_pair (X ,Y, Z) = (X, xd, Y, yd) where\n    xd = Fp_2.sq Z     yd = Fp_2.mul (Z, xd) \n\nprojective_pair_to_affine: projective_pair_fp2 -> AffinePoint t_Fp_2\nprojective_pair_to_affine (xn, xd, yn, yd) = (X', Y') where\n    X' = Fp_2.div  (xn, xd)\n    Y' = Fp_2.div (yn, yd)\n\naffine_to_projective_pair: AffinePoint t_Fp_2 -> projective_pair_fp2\naffine_to_projective_pair (x, y) = (x,Fp_2.field_unit, y, Fp_2.field_unit)\n\npsi: AffinePoint t_Fp_2 -> AffinePoint t_Fp_2\npsi (x, y) = (qxn, qyn) where\n    qxn = Fp_2.mul (psi_c1, fp2_frobenius x)\n    qyn = Fp_2.mul (psi_c2, fp2_frobenius y)\n```"}]}
{"filename":"BLST-Verification\/spec\/ExpandMessage.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the hash-to-curve expand_message_xmd function (using SHA256) and the helper expand_b0, including appropriate types, constraints, and any properties needed to verify they implement the XMD message expansion from RFC 9380 for arbitrary message and DST lengths."},{"role":"assistant","content":"```cryptol\nmodule ExpandMessage where\n\nimport rfc8017 (I2OSP, OS2IP)\nimport Primitive::Keyless::Hash::SHA256 as SHA256\n\nprivate\n\n        strxor: {k} ([k][8],[k][8]) -> [k][8]\n    strxor (s1, s2) = s1^s2\n\nprivate\n\n        type constraint Hashable n = (61 >= width n)\n\n    H: {n} (Hashable n) => [n][8] -> [32][8]\n    H x = split (SHA256::sha (join x))\n\nexpand_message = expand_message_xmd \ntype constraint Expandable len_message len_DST  =  (61 >= width (69 + len_message + len_DST))\n\nexpand_message_xmd: {len_message, len_DST, len_in_bytes}\n                (fin len_message\n                , fin len_DST\n                , len_DST <= 255\n                , fin len_in_bytes\n                , len_in_bytes \/^ 32 <= 255\n                , Expandable len_message len_DST\n                ) => [len_message][8] -> [len_DST][8] -> [len_in_bytes][8]\nexpand_message_xmd msg DST = take uniform_bytes where\n            type r_in_bytes = 64                        DST_prime = DST # (I2OSP`{xLen=1} (`len_DST))     Z_pad = I2OSP`{xLen=r_in_bytes} (0)\n    l_i_b_str = I2OSP`{xLen=2} (`len_in_bytes)\n    msg' = Z_pad # msg # l_i_b_str # (I2OSP`{1} 0) # DST_prime\n    b_0 = H (msg')\n    b_1 = H (b_0 # (I2OSP`{xLen=1} 1) # DST_prime)\n    bs = [b_1] # [H(strxor(b_0, b_prev) # (I2OSP`{xLen=1} i) # DST_prime) | b_prev <- bs | i:[8] <- [2...]]\n    uniform_bytes = join bs\n\nexpand_b0: {len_message, len_DST, len_in_bytes}\n                (fin len_message\n                , fin len_DST\n                , len_DST <= 255\n                , fin len_in_bytes\n                , len_in_bytes \/^ 32 <= 255\n                , Expandable len_message len_DST\n                ) => ([len_message][8], [len_DST][8]) -> [32][8]\nexpand_b0 (msg, DST) = b_0 where\n    type r_in_bytes = 64                DST_prime = DST # (I2OSP`{xLen=1} (`len_DST)) # [0x80]\n    Z_pad = I2OSP`{xLen=r_in_bytes} (0)\n    l_i_b_str = I2OSP`{xLen=2} (`len_in_bytes)\n    b_0 = H (Z_pad # msg # l_i_b_str # (I2OSP`{1} 0) # DST_prime)\n```"}]}
{"filename":"BLST-Verification\/spec\/Serialization.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines and verifies BLS12-381 elliptic curve point serialization and deserialization (compressed and uncompressed) for E1 and E2, including sign-bit computation and correctness properties that deserialize(serialize(P)) returns P or nothing exactly on invalid encodings."},{"role":"assistant","content":"```cryptol\nmodule Serialization where\n\nimport Parameters (p, E, E', t_Fp, to_Fp, t_Fp_2, Fp, Fp_2)\nimport ShortWeierstrassCurve as EC\nimport rfc8017\nimport Maybe\nimport FieldExtras (F_expt)\nimport BLSFieldExtras (sqrt_fp, is_square_fp, sqrt_fp2, is_square_fp2)\n\n\/\/\/\/ Serialization (with compression)\n\nsign_F_p: t_Fp -> Bit\nsign_F_p y = y > `((p - 1)\/2)\n\nsign_F_p_2: t_Fp_2 -> Bit\nsign_F_p_2(y') = if y'_1 == 0 then sign_F_p(y'_0) else y'_1 > `((p - 1)\/2) where\n    [y'_1, y'_0] = y'\n\nmetadata_bits_E1:  EC::AffinePoint t_Fp -> [3]\nmetadata_bits_E1 P = [C_bit, I_bit, S_bit] where\n    C_bit = True\n    I_bit = EC::is_point_O E P\n    S_bit = if I_bit then False else sign_F_p y where (_,y) = P\n\nm_byte_E1: EC::AffinePoint t_Fp -> [8]\nm_byte_E1 P = (metadata_bits_E1 P) # zero\n\nx_string_E1: EC::AffinePoint t_Fp -> [48][8]\nx_string_E1 P = if EC::is_point_O E P\n                then I2OSP(0)\n                else I2OSP(x) where (x,_) = P\n\nx_string_E2: EC::AffinePoint t_Fp_2 -> [96][8]\nx_string_E2 P = if EC::is_point_O E' P\n                then I2OSP(0)\n                else I2OSP`{xLen=48}(x_1) # I2OSP(x_0) where ([x_1, x_0],_) = P\n\nserialize_E1: EC::AffinePoint t_Fp -> [48][8]\nserialize_E1 P = x_string_E1 P || ([m_byte_E1 P]# zero)\n\nserialize_E2: EC::AffinePoint t_Fp_2 -> [96][8]\nserialize_E2 P = x_string_E2 P || ([m_byte]# zero) where\n    C_bit = True\n    I_bit = EC::is_point_O E' P\n    S_bit = if I_bit then False else sign_F_p_2 y where (_,y) = P\n    m_byte = [C_bit, I_bit, S_bit] # zero\n\ndeserialize_E1: [96][8] -> Maybe (EC::AffinePoint t_Fp)\ndeserialize_E1 s_string = ret where\n        m_byte = (s_string@0) && 0xE0     C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n            s_string' = take`{front=48} ([(s_string@0) && 0x1F] # tail s_string) \/\/ the last 48 bytes may be uninitialized for a compressed point. TODO should we assume they're zero? doesn't seem to make sense (extra work for the caller)\n    \/\/ Step 6\n    x = OS2IP(s_string')\n        y2 = Fp.add (Fp.mul (x, Fp.sq x), 4)\n    y = sqrt_fp y2\n    Y_bit = sign_F_p y\n        ret = if C_bit == False then nothing            | I_bit then (if s_string' == zero then just (EC::point_O E) else nothing) \/\/ Step 4\n           | ~ (is_square_fp y2) then nothing \/\/ from Step 7\n           | S_bit == Y_bit then just (x,y)\n          else just (x, Fp.neg y)\n\n\/\/ draft-irtf-cfrg-bls-signature-04 specifies that the compressed representation is used for BLST\nuncompress_E1: [48][8] -> Maybe (EC::AffinePoint t_Fp)\nuncompress_E1 s_string = ret where\n    \/\/ Step 1.\n    m_byte = (s_string@0) && 0xE0 \/\/ three highest bits\n    C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n    \/\/ Step 2 deferred (we check that C_bit is 1 later)\n    \/\/ Step 3\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n        x = OS2IP(s_string')\n    \/\/ TODO here the C implementation checks that x is smaller than the modulus\n    \/\/Step 7 (on curve E)\n    y2 = Fp.add (Fp.mul (x, Fp.sq x), 4)\n    y = sqrt_fp y2\n    Y_bit = sign_F_p y\n    \/\/ Steps 2, 4, 8\n    ret = if (m_byte == 0x20 ) || (m_byte == 0x60) || (m_byte == 0xE0) then nothing\n           | C_bit == False then nothing \/\/ Error, from Step 2\n           | I_bit then (if s_string' == zero then just (EC::point_O E) else nothing)            | ~ (is_square_fp y2) then nothing            | S_bit == Y_bit then just (x,y)\n          else just (x, Fp.neg y)\n\ndeserialize_E2: [96][8] -> Maybe (EC::AffinePoint t_Fp_2)\ndeserialize_E2 s_string = ret where\n        m_byte = (s_string@0) && 0xE0\n    C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n            s_string' = [(s_string@0) && 0x1F] # tail s_string\n    \/\/ Step 6\n    \/\/ Section 2.5 of draft-irtf-cfrg-pairing-friendly-curves-07 suggests this should be:\n    \/\/     x = map to_Fp (reverse (split`{parts=2} (OS2IP`{a=[2*384]}(s_string'))))\n            x = map to_Fp (split`{parts=2} (OS2IP`{a=[2*384]}(s_string')))\n    \/\/Step 7 (on curve E')\n    y2 = Fp_2.add (Fp_2.mul (x, Fp_2.sq x), [4,4])     y = sqrt_fp2 y2\n    Y_bit = sign_F_p_2 y\n        ret = if m_byte == 0x20 \\\/ m_byte == 0x60 \\\/ m_byte == 0xE0 then nothing            | C_bit == False then nothing            | I_bit then (if s_string' == zero then just (EC::point_O E') else nothing)            | ~ (is_square_fp2 y2) then nothing            | S_bit == Y_bit then just (x,y)\n          else just (x, Fp_2.neg y)\n```"}]}
{"filename":"BLST-Verification\/spec\/KeyGen.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the BLS signature key generation algorithm that defines the functions KeyGen_r2, KeyGenLoop, and KeyGenStep using SHA256, HKDF-Extract, HKDF-Expand, and RFC 8017 OS2IP\/I2OSP, producing a 256-bit secret key from IKM and key_info inputs."},{"role":"assistant","content":"```cryptol\nmodule KeyGen where\n\nimport Parameters as P\nimport Primitive::Keyless::Hash::SHA256\nimport Primitive::Symmetric::KDF::HKDF256\nimport rfc8017\n\nKeyGen_r2: {IKM_len, info_len} ( IKM_len >= 32\n                               , validHMACSizes 20 (1+IKM_len)\n                               , validHMACSizes 32 (35+info_len)\n                               ) =>\n        ([IKM_len][8], [info_len][8]) -> [256]\nKeyGen_r2 (IKM, key_info) = SK where\n    type L = (3 * 256) \/^ 16     PRK = HKDF_Extract \"BLS-SIG-KEYGEN-SALT-\" (IKM # [0])     OKM = HKDF_Expand`{L=L} PRK (key_info # I2OSP`{xLen=2} `L)\n    SK = drop ((OS2IP`{a=[384]} OKM) % (zext P::r))\n\nKeyGen: {IKM_len, info_len} ( validHMACSizes 20 (1+IKM_len)\n                            , validHMACSizes 32 (35+info_len)\n                            ) =>\n        ([IKM_len][8], [info_len][8]) -> [256]\nKeyGen (IKM, key_info) = (KeyGenLoop (sha (join \"BLS-SIG-KEYGEN-SALT-\")) IKM key_info) @ 4\n\nKeyGenLoop salt IKM info = keys where\n  salts = [salt] # [sha salt' | salt' <- salts]\n  keys = [zero] #\n                  [if k == zero then key_gen_step salt' else k | k <- keys | salt' <- salts]\n  key_gen_step s = KeyGenStep s IKM info\n\nKeyGenStep:  {IKM_len, info_len} (\n                              validHMACSizes 20 (1+IKM_len)\n                            , validHMACSizes 32 (35+info_len)\n                            ) =>\n        [256] -> [IKM_len][8] ->[info_len][8] -> [256]\nKeyGenStep salt IKM key_info = SK where\n    type L = (3 * 256) \/^ 16     PRK = HKDF_Extract (split salt) (IKM # [0])     OKM = HKDF_Expand`{L=L} PRK (key_info # I2OSP`{xLen=2} `L)\n    SK = drop ((OS2IP`{a=[384]} OKM) % (zext P::r))\n```"}]}
{"filename":"BLST-Verification\/spec\/rfc8017.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the Cryptol functions `I2OSP` and `OS2IP` from RFC 8017, with the given type signatures, implementing integer-to-octet-string and octet-string-to-integer conversion, respectively."},{"role":"assistant","content":"```cryptol\nmodule rfc8017 where\n\nI2OSP: {xLen, a} (fin xLen, Integral a) => a -> [xLen][8]\nI2OSP x = split (fromInteger (toInteger x))\n\nOS2IP: {xLen, a} (fin xLen, Ring a) => [xLen][8] -> a\nOS2IP x = fromInteger (toInteger (join x))\n```"}]}
{"filename":"BLST-Verification\/spec\/Pairing.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that implements the Optimal Ate pairing over the BLS12 curve, including the Miller loop (with line_function and miller_step), the embedding maps phi_1 and phi_2, and the optimized final_exponentiation using Frobenius maps, exposing bls_ate_pairing : EC::AffinePoint t1 -> EC::AffinePoint t2 -> t12."},{"role":"assistant","content":"```cryptol\nmodule Pairing where\n\nimport Parameters as P\nimport ShortWeierstrassCurve as EC\nimport FieldExtras\nimport Frobenius\n\nc12: EC::EllipticCurve t12\nc12 = { base_field = P::Fp_12, a = P::Fp_12.field_zero, b = P::Fp_to_Fp_12 P::b }\n\nphi_1: EC::AffinePoint t1 -> EC::AffinePoint t12\nphi_1 (x,y) = (P::Fp_to_Fp_12 x, P::Fp_to_Fp_12 y)\n\nalpha: t2\nalpha = f2.half (f2.sub (f2.field_unit, P::u))\n\nw3_times: t2 -> t12\nw3_times x = [[z,x,z],[z,z,z]] where z = f2.field_zero\n\nw4_times: t2 -> t12\nw4_times x = [[z,z,z],[x,z,z]] where z = f2.field_zero\n\nphi_2: EC::AffinePoint t2 -> EC::AffinePoint t12\nphi_2 (x,y) = (x',y') where\n    x' = w4_times (f2.mul (x, alpha))\n    y' = w3_times (f2.mul (y, alpha))\n\nprivate\n    twice x = f12.add (x,x)\n    thrice x = f12.add (x, twice x)\n\nline_function: (t12,t12) -> (t12,t12) -> (t12,t12) -> t12\nline_function A B P = ret where\n    (A1,A2) = A\n    (B1,B2) = B\n    (P1,P2) = P\n    ret = if A == EC::neg c12 B           then f12.sub (P1, A1)           else f12.sub (f12.add (f12.mul (l, f12.sub (P1, A1)), A2), P2)\n    l = if A == B\n        then f12.div (thrice (f12.sq A1), twice A2)\n        else f12.div (f12.sub (B2, A2), f12.sub (B1, A1))\n\nnegative_t:[64]\nnegative_t = <| x^^63 + x^^62 + x^^60 + x^^57 + x^^48 + x^^16 |>\n\nbls_ate_pairing: EC::AffinePoint t1 -> EC::AffinePoint t2 -> t12\nbls_ate_pairing p q = ate_pairing (phi_1 p) (phi_2 q)\n\nate_pairing: EC::AffinePoint t12 -> EC::AffinePoint t12 -> t12\nate_pairing P Q = final_exponentiation (ate_pairing' P Q)\n\n\/\/ skipping the final exponentation\nate_pairing': EC::AffinePoint t12 -> EC::AffinePoint t12 -> t12\nate_pairing' P Q =  last_f where\n   negQ = EC::neg c12 Q\n   (last_f, _) = f_Ts ! 0\n   f_Ts = [(f12.field_unit, negQ)] #\n          [ miller_step P negQ fT ci | fT <- f_Ts | ci <- tail negative_t]\n\n\/\/ in the Miller loop, c_i is only ever 0 or -1, here represented by False and True\n\/\/ We only subtract Q, never add, so we take -Q as a parameter\nmiller_step:  EC::AffinePoint t12 -> EC::AffinePoint t12 -> (t12, EC::AffinePoint t12)\n              -> Bit -> (t12, EC::AffinePoint t12)\nmiller_step P negQ (f, T) ci = (f', T') where\n    f0 = f12.mul (f12.sq f, line_function T T P)\n    T0 = EC::double c12 T\n    (f', T') = if ci\n               then (f12.mul (f0, line_function T0 negQ P),\n                     EC::add c12 T0 negQ)\n               else (f0, T0)\n\n\/\/ final exponentiation\n\ntype r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\ntype final_exponent = (P::p^^12 - 1) \/ r\ntype small_final_e =  (P::p^^4 - P::p^^2 +1)\/r\n\n\/\/ Use the Frobenius mapping to compute x^(p^6-1)*(p^2+1)\nfinal_exp_frobenius_map : t12 -> t12\nfinal_exp_frobenius_map x = x2 where\n  x1 = f12.div (fp12_conjugate x, x) \/\/ = x^(p^6 - 1)\n  x2 = f12.mul (fp12_frobenius (fp12_frobenius x1), x1) \/\/ x1^(p^2+1)\n\nfinal_exponentiation: t12 -> t12\n\/* We could most simply define\n\n  final_expt x = k_expt`{6} f12 x (`final_exponent:[4314])\n\n  but is it rather inefficient to do so.  Instead, as noted in [1] and [2]\n  we can use the factorization\n\n     p^12-1 = (p^8+p^6 - p^2-1)*(p^4-p^2+1)\n            = (p^6-1)*(p^2+1)*(p^4-p^2+1)\n\n  and r since divides p^4-p^2+1, we can first use the Frobenius mapping to\n  easily compute x^(p^6-1)*(p^2+1), then complete the calculation\n  raising this to (p^4-p^2+1)\/r.\n\n  For that last exponentiation, we use a (2^5)-ary breakdown of the exponent,\n  noting that 2^5 = 32 is pretty close the the square root of 1268, the number of\n  bits in the exponent.\n\n  [1] Beauchat et al.  \"High-Speed Software Implementation of the Optimal\n      Ate airing over Barreto-Naehrig Curves\"\n\n  [2] Scott et al. \"On the final exponentiation for calculating pairings on\n      ordinary elliptic curves.\" eprint.iacr.org\/2008\/490\n *\/\nfinal_exponentiation x = k_expt`{5} f12 (final_exp_frobenius_map x) (`small_final_e:[1268+2])\n```"}]}
{"filename":"BLST-Verification\/spec\/BLSGeneric.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `BLSGeneric` specifying the core BLS signature scheme, including `sk_to_pk`, `KeyValidate`, `CoreSign`, `CoreVerify`, and `CoreAggregateVerify`, parameterized over curves, pairings, and encodings, with appropriate types, constraints, and use of SHA256 and HKDF256."},{"role":"assistant","content":"```cryptol\nmodule BLSGeneric where\n\nimport Common::Field (FieldRep)\nimport ShortWeierstrassCurve as EC\nimport Parameters as P\nimport Maybe\nimport Primitive::Keyless::Hash::SHA256\nimport Primitive::Symmetric::KDF::HKDF256\nimport rfc8017\n\nparameter\n\n        type t_F: *     type t_F': * \/\/ representation type for field of the secondary curve (pubkey)\n    type t_G: * \/\/ representation type for field of the pairing result\n    G: FieldRep t_G\n\n    \/\/ TODO: need equality for t_G  WHY?\n    type constraint Eq t_G\n    type constraint Zero t_G  \/\/ For Maybe t_G\n\n    type pubkey_len: #\n    type signature_len: #\n\n    main_curve: EC::EllipticCurve t_F\n    other_curve: EC::EllipticCurve t_F'\n\n                DST: [43][8]\n\n    hash_to_point: {msg_len} (Hashable msg_len) =>\n               [msg_len][8] -> EC::AffinePoint t_F\n\n    P: EC::AffinePoint t_F' \/\/ base point\n    \/\/ r -- is fixed in both BLS variants  Should we use it here as a parameter anyway??\n\n    pairing: (EC::AffinePoint t_F, EC::AffinePoint t_F') -> t_G\n\n    point_to_pubkey: EC::AffinePoint t_F' -> [pubkey_len]\n    point_to_signature: EC::AffinePoint t_F -> [signature_len]\n\n    pubkey_to_point: [pubkey_len] -> Maybe (EC::AffinePoint t_F')     signature_to_point: [signature_len] -> Maybe (EC::AffinePoint t_F) \n    pubkey_subgroup_check: EC::AffinePoint t_F' -> Bool\n    signature_subgroup_check: EC::AffinePoint t_F -> Bool\n\n\/\/type constraint Hashable msg_len = (msg_len <= 255, 61 >= width (69 + msg_len + DST_len))\ntype constraint Hashable msg_len = (msg_len <= 255, 61 >= width (69 + msg_len + 43))\n\nreexport_DST = DST\n\nreexport_pubkey_subgroup_check = pubkey_subgroup_check\nreexport_signature_subgroup_check = signature_subgroup_check\n\n\/\/ 2.3 KeyGen\n\n\/\/ ... KeyGen has been moved to its own module, called KeyGen, as it does not depend\n\/\/     on the parameters.\n\n\/\/ 2.4 SkToPk\n\nsk_to_pk: [255] -> [pubkey_len]\nsk_to_pk sk = point_to_pubkey (EC::mult other_curve sk P)\n\n\/\/ 2.5 KeyValidate\n\n\/\/ The spec says to return VALID or INVALID; here we use True for VALID\nKeyValidate: [pubkey_len] -> Bool\nKeyValidate pk = ret where\n    xP = pubkey_to_point pk  \/\/ step 1\n    ret = maybe_cases xP\n            False \/\/ xP is None, step 2\n            (\\y ->   (~ (EC::is_point_O other_curve y)) \/\/ Step 3\n                  \/\\ reexport_pubkey_subgroup_check y) \/\/ Step 4\n\n\/\/ 2.6 CoreSign\n\n\/* CoreSign: {msg_len} (Hashable msg_len) => [255] -> [msg_len][8] -> [signature_len] *\/\n\/* CoreSign sk message = signature where *\/\nCoreSign: {msg_len} (Hashable msg_len) => ([255], [msg_len][8]) -> [signature_len]\nCoreSign (sk, message) = signature where\n    Q = hash_to_point message\n    R = EC::mult main_curve sk Q\n    signature = point_to_signature R\n\n\/\/ 2.7 CoreVerify\n\nCoreVerify: {msg_len} (Hashable msg_len) => [pubkey_len] -> [msg_len][8] -> [signature_len] -> Bool\n\/* possible alternate definition\nCoreVerify(PK, message, signature) = maybe False step3 (signature_to_point signature) where \/\/ lines 1, 2\n    step3 R = if signature_subgroup_check R == False then False \/\/ line 3\n               |  KeyValidate PK == False then False \/\/ line 4\n              else maybe False (step5 R) (pubkey_to_point PK) \/\/ line 5, but dealing with \"maybe-ness\"\n    step5 R xP = C1 == C2 where \/\/ line 9\n         Q = hash_to_point message \/\/ line 6\n         C1 = pairing (Q, xP) \/\/ line 7\n         C2 = pairing (R, P) \/\/ line 8\n*\/\nCoreVerify PK message signature =\n    maybe_cases (signature_to_point signature)\n        False \/\/ lines 1,2\n        (\\ R -> if reexport_signature_subgroup_check R == False then False  \/\/ line 3\n                |  KeyValidate PK == False then False \/\/ line 4\n                else maybe_cases (pubkey_to_point PK)\n                    False \/\/ line 5\n                    (\\ xP -> (C1 == C2 where \/\/ line 9\n                              Q = hash_to_point message \/\/ line\n                              C1 = pairing (Q, xP) \/\/ line 7\n                              C2 = pairing (R, P)))) \/\/ line 8\n\naggregate_loop: {n, msg_len} (fin n, Hashable msg_len) =>\n                [n][pubkey_len] ->\n                [n][msg_len][8] ->\n                Maybe t_G\naggregate_loop PKs messages = C1s ! 0 where  \/\/ lines 4-9\n    C1s = [just G.field_unit] # [ aggregate_loop_body PK message C1 |\n                                  PK <- PKs |\n                                  message <- messages |\n                                  C1 <- C1s ]\n\naggregate_loop_body: {msg_len} (Hashable msg_len) =>\n                     [pubkey_len] ->\n                     [msg_len][8] ->\n                     Maybe t_G ->\n                     Maybe t_G\naggregate_loop_body PK message mC1 =\n    maybe_cases mC1 nothing (\\C1 ->\n        if KeyValidate PK == False then nothing  \/\/ line 6\n        else maybe_cases (pubkey_to_point PK)\n            nothing  \/\/ line 7\n            (\\ xP -> (just (G.mul (C1, (pairing (Q, xP)))) where  \/\/ line 9\n                      Q = hash_to_point message)))  \/\/ line 8\n\nCoreAggregateVerify: {n, msg_len} (fin n, Hashable msg_len) =>\n                     [n][pubkey_len] ->\n                     [n][msg_len][8] ->\n                     [signature_len] ->\n                     Bool\nCoreAggregateVerify PKs messages signature =\n    maybe_cases (signature_to_point signature)  \/\/ line 1\n        False                                   \/\/ line 2\n        (\\R -> if reexport_signature_subgroup_check R == False\n               then False  \/\/ line 3\n               else (maybe_cases mC1 False (\\C1 -> C1 == C2) where  \/\/ line 11\n                     mC1 = aggregate_loop PKs messages \/\/ lines 4-9\n                     C2 = pairing (R, P)))  \/\/ line 10\n```"}]}
{"filename":"BLST-Verification\/spec\/FieldExtras.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol the FieldExtras module, defining F_sum, F_prod, F_expt, F_is_zero, kth_square, k_expt, and the mul_by_{2,3,4,6,8} helpers over a generic FieldRep t, including appropriate types and properties capturing their algebraic correctness over finite fields."},{"role":"assistant","content":"```cryptol\nmodule FieldExtras where\n\nimport Common::Field\n\nF_sum: {t, n} (fin n) => FieldRep t -> [n]t -> t\nF_sum F vs = sums!0 where\n    sums = [F.field_zero] # [F.add (s, v) | s <- sums | v <- vs]\n\nF_prod: {t, n} (fin n) => FieldRep t -> [n]t -> t\nF_prod F vs = prods!0 where\n    prods = [F.field_unit] # [F.mul (s, v) | s <- prods | v <- vs]\n\nF_expt: {t, n} (fin n) => FieldRep t -> t -> Integer -> t\nF_expt F x e = powers ! 0 where\n    powers = [F.field_unit] #\n             [if b then F.mul (x, F.sq p) else F.sq p | p <- powers | b <- ((fromInteger e):[n])]\n\nF_is_zero: {t} FieldRep t -> t -> Bit\nF_is_zero F x = F.is_equal (x, F.field_zero)\n\nprivate\n    kth_square: {k, t} (fin k, k>=1) => FieldRep t -> t -> t\n    kth_square F x = squares@(`k) where\n        squares = [x] # [F.sq y | y <- squares]\n\nk_expt: {k, n, t} (fin k, fin n, k>=1, n>=1) => FieldRep t -> t -> [n*k] -> t\nk_expt F b e = acc!0 where\n    digits: [n][k]\n    digits = split e\n    small_powers = [F.field_unit] # [F.mul(b, sp) | sp <- small_powers]     acc = [small_powers@(digits@0)] # [F.mul(small_powers@d, kth_square`{k} F a) | a <- acc | d <- tail digits]\n\nmul_by_2: {t} FieldRep t -> t -> t\nmul_by_2 F x = F.add (x,x)\n\nmul_by_3: {t} FieldRep t -> t -> t\nmul_by_3 F x = F.add (x, F.add (x, x))\n\nmul_by_4: {t} FieldRep t -> t -> t\nmul_by_4 F x = mul_by_2 F (mul_by_2 F x)\n\nmul_by_6: {t} FieldRep t -> t -> t\nmul_by_6 F x = mul_by_3 F (mul_by_2 F x)\n\nmul_by_8: {t} FieldRep t -> t -> t\nmul_by_8 F x = x8 where\n  x2 = F.add (x, x)\n  x4 = F.add (x2, x2)\n  x8 = F.add (x4, x4)\n```"}]}
{"filename":"BLST-Verification\/spec\/PrimeField.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module PrimeField that provides FieldRep instances over integers, modular integers Z k, and bitvectors [n], including modular add, sub, mul, neg, sq, half, div, and corresponding is_val\/normalize operations for a given modulus or prime field parameter."},{"role":"assistant","content":"```cryptol\nmodule PrimeField where\n\nimport Common::Field\nimport Common::ModDivZ\nimport Common::mod_arith\n\nprime_field_integer: Integer -> FieldRep Integer\nprime_field_integer p =\n    { is_val x = 0 <= x \/\\ x < p\n    , normalize x = x % p\n    , add (x, y) =  mod_add_Z (p,x,y)\n    , sub (x, y) = mod_sub_Z (p,x,y)\n    , neg x = mod_neg_Z (p,x)\n    , mul (x,y) = mod_mul_Z (p,x,y)\n    , sq x = mod_sq_Z (p, x)\n    , half x = mod_half_Z (p,x)\n    , div (x,y) = mod_div_Z (p,x,y)\n    , field_zero = 0\n    , field_unit = 1\n    , is_equal (x, y) = x==y\n    }\n\nmod_add_Z: (Integer,Integer,Integer) -> Integer\nmod_add_Z (p,x,y) = (x + y) % p\n\nmod_sub_Z: (Integer,Integer,Integer) -> Integer\nmod_sub_Z (p,x,y) = (x - y) % p\n\nmod_mul_Z: (Integer,Integer,Integer) -> Integer\nmod_mul_Z (p,x,y) = (x * y) % p\n\nmod_neg_Z: (Integer,Integer) -> Integer\nmod_neg_Z (p, x) = (-x)%p\n\nmod_sq_Z: (Integer,Integer) -> Integer\nmod_sq_Z (p,x) = mod_mul_Z (p, x, x)\n\nmod_half_Z: (Integer,Integer)-> Integer\nmod_half_Z (p, x) = if (x%2==0) then x\/2 else (x+p)\/2\n\nmod_div_Z : (Integer,Integer,Integer) -> Integer\nmod_div_Z (p,x,y) = egcd(p,0,y%p,x%p)\n  where\n\n    egcd(a,ra,b,rb) =\n      if b == 0 then\n        ra\n      else if (b % 2) == 0 then \n        egcd(a, ra, b \/ 2, mod_half_Z(p, rb))\n      else if a < b then\n        egcd(a, ra, (b - a) \/ 2, mod_half_Z (p, (rb-ra)%p))\n      else\n        egcd(b, rb, (a - b) \/ 2, mod_half_Z (p, (ra-rb)%p))\n\nprime_field: {k} (fin k, k >= 3, k > 2*(k\/2)) =>  FieldRep (Z k)\nprime_field =\n    { is_val x = True\n    , normalize x = x\n    , add (x, y) = x + y\n    , sub (x, y) = x - y\n    , neg x = -x\n    , mul (x,y) = x*y\n    , sq x = x*x\n    , half x = moddiv x 2\n    , div (x,y) = moddiv x y\n    , field_zero = 0\n    , field_unit = 1\n    , is_equal (x, y) = x==y\n    }\n\nprime_field_bv: {n} (fin n, n >= 1) => [n] -> FieldRep [n]\nprime_field_bv m =\n    { is_val x = x < m\n    , normalize x = (x % m)\n    , add (x, y) = mod_add (m,x,y)\n    , sub (x, y) = mod_sub (m,x,y)\n    , neg x = mod_neg (m, x)\n    , mul (x,y) = mod_mul (m, x, y)\n    , sq x = mod_mul (m, x, x)\n    , half x = mod_half (m, x)\n    , div (x,y) = mod_div (m, x, y)\n    , field_zero = 0\n    , field_unit = 1\n    , is_equal (x, y) = x==y     }\n```"}]}
{"filename":"BLST-Verification\/spec\/BLSFieldExtras.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol the BLSFieldExtras module providing square, square-root, inverse, and exponentiation operations over Fp and Fp2 (including sqrt_fp, sqrt_fp2, inverse_fp, inverse_fp2, is_square_fp, is_square_fp2, fp_exp, fp2_exp) with properties showing they satisfy the expected field laws."},{"role":"assistant","content":"```cryptol\nmodule BLSFieldExtras where\n\nimport Parameters (p, Fp, t_Fp, Fp_2, t_Fp_2, u)\nimport FieldExtras\n\nis_square_fp x =  y == 0 \\\/ y == 1 where\n    y = F_expt`{n=width p} Fp x `((p-1)\/2)\n\nsqrt_fp x = F_expt`{n=width p} Fp x `((p+1)\/4) \ninverse_fp x = F_expt`{n=width p} Fp x `(p-2) \ntype q = p*p\n\nsqrt_fp2 x = z where\n    tv1 = F_expt`{n=(width q) - 3} Fp_2 x `((q+7)\/16)\n    tv2 = Fp_2.mul (c1, tv1)\n    tv3 = Fp_2.mul (c2, tv1)\n    tv4 = Fp_2.mul (c3, tv1)\n    e1 =  Fp_2.is_equal (Fp_2.sq tv2, x)\n    e2 =  Fp_2.is_equal (Fp_2.sq tv3, x)\n\n    tv1_1 = CMOV (tv1, tv2, e1)\n    tv2_1 = CMOV (tv4, tv3, e2)\n    e3 = Fp_2.is_equal (Fp_2.sq tv2_1, x)\n    z = CMOV (tv1_1, tv2_1, e3)\n\n        CMOV (a,b,c) = if c==False then a else b\n\n            c1 = [1,0]\n    c2 = sqrt_fp2_c2\n    c3 = sqrt_fp2_c3\n\nsqrt_fp2_k: t_Fp\nsqrt_fp2_k = 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257\n\nsqrt_fp2_c2: t_Fp_2\nsqrt_fp2_c2 = [sqrt_fp2_k, Fp.neg sqrt_fp2_k]\n\nsqrt_fp2_c3: t_Fp_2\nsqrt_fp2_c3 = [sqrt_fp2_k, sqrt_fp2_k]\n\nsqrt_align_fp2_coeff: t_Fp_2 -> t_Fp_2 -> t_Fp_2\nsqrt_align_fp2_coeff s inp =\n  if Fp_2.sq (Fp_2.mul(sqrt_fp2_c3, s)) == inp then sqrt_fp2_c3\n   | Fp_2.sq (Fp_2.mul(sqrt_fp2_c2, s)) == inp then sqrt_fp2_c2\n   | Fp_2.sq (Fp_2.mul(          u, s)) == inp then u\n  else Fp_2.field_unit\n\ninverse_fp2: t_Fp_2 -> t_Fp_2\ninverse_fp2 [a,b] = [Fp.div(Fp.neg a, c), Fp.div(b, c)] where\n    c = Fp.add (Fp.sq a, Fp.sq b)\n\nis_square_fp2: t_Fp_2 -> Bool\nis_square_fp2 [x_2, x_1] = (tv1' != Fp_2.neg Fp_2.field_unit) where\n    \/\/ NB our representation of polynomnials is big-endian unlike the spec\n    tv1 = Fp.sq x_1\n    tv2 = Fp_2.sq [x_2, Fp.field_zero] \/\/ = Fp2_sq (Fp_2.mul (u, const_poly x_2))\n    tv1' = F_expt`{n=381} Fp_2 (Fp_2.sub ([Fp.field_zero, tv1], tv2)) ((`p-1)\/2)\n\nfp_exp: t_Fp -> Integer -> t_Fp\nfp_exp x e = if e < 0 then Fp.div (Fp.field_unit, fp_exp x (-e))\n              | e == 0 \/\\ x == Fp.field_zero then Fp.field_zero               | e == 0 then Fp.field_unit\n              else Fp.mul (x, fp_exp x (e-1))\n\nfp2_exp: t_Fp_2 -> Integer -> t_Fp_2\nfp2_exp x e = if e < 0 then Fp_2.div (Fp_2.field_unit, fp2_exp x (-e))\n              | e == 0 \/\\ x == Fp_2.field_zero then Fp_2.field_zero               | e == 0 then Fp_2.field_unit\n              else Fp_2.mul (x, fp2_exp x (e-1))\n```"}]}
{"filename":"BLST-Verification\/spec\/Parameters.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Parameters` that defines the BLS12-381 field, extension field, and curve parameters (including generators, cofactors, and serialization\/deserialization functions) exactly as specified, suitable for use in BLST verification proofs."},{"role":"assistant","content":"```cryptol\nmodule Parameters where\n\nimport Polynomial\nimport PrimeField\nimport ExtensionField\nimport ShortWeierstrassCurve\n\nt_signed_form: [64][2] t_signed_form = [ [bit,bit] | bit <-  <| x^^63 + x^^62 + x^^60 + x^^57 + x^^48 + x^^16 |> ]\n\ntype p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\n\nFp = prime_field_integer `p\ntype t_Fp = Integer\n\nto_Fp: {n} (fin n, n <= 384) => [n] -> t_Fp\nto_Fp bits = toInteger (zext`{m=384} bits)\n\nfrom_Fp: t_Fp -> [384]\nfrom_Fp x = fromInteger x\n\nFp_2 = extension_field Fp [Fp.field_zero, Fp.neg Fp.field_unit] type t_Fp_2 = [2]t_Fp\n\nu: t_Fp_2\nu = poly_x Fp\n\nu_plus_1: t_Fp_2\nu_plus_1 = Fp_2.add (u, poly_1 Fp)\n\nFp_to_Fp_2: t_Fp -> t_Fp_2\nFp_to_Fp_2 = poly_const Fp\n\nFp_6 = extension_field Fp_2 [Fp_2.field_zero, Fp_2.field_zero, u_plus_1]\ntype t_Fp_6 = [3]t_Fp_2\n\nv: t_Fp_6\nv = poly_x Fp_2\n\nFp_2_to_Fp_6: t_Fp_2 -> t_Fp_6\nFp_2_to_Fp_6 = poly_const Fp_2\n\nFp_to_Fp_6: t_Fp -> t_Fp_6\nFp_to_Fp_6 x = Fp_2_to_Fp_6 (Fp_to_Fp_2 x)\n\nFp_12 = extension_field Fp_6 [Fp_6.field_zero, v]\ntype t_Fp_12 = [2]t_Fp_6\n\nw: t_Fp_12\nw = poly_x Fp_6\n\nFp_6_to_Fp_12: t_Fp_6 -> t_Fp_12\nFp_6_to_Fp_12 = poly_const Fp_6\n\nFp_2_to_Fp_12: t_Fp_2 -> t_Fp_12\nFp_2_to_Fp_12 x = Fp_6_to_Fp_12 (Fp_2_to_Fp_6 x)\n\nFp_to_Fp_12: t_Fp -> t_Fp_12\nFp_to_Fp_12 x = Fp_2_to_Fp_12 (Fp_to_Fp_2 x)\n\nprivate\n  poly_to_octets: {t,k,n} (fin k, fin n) => (t->[n*8]) -> [k]t -> [k*n*8]\n  poly_to_octets f p = join (map f (reverse p))\n\nFp_to_octets: t_Fp -> [48*8] Fp_to_octets = from_Fp\n\nFp_12_to_octets: t_Fp_12 -> [12*48*8]\nFp_12_to_octets = poly_to_octets (poly_to_octets (poly_to_octets Fp_to_octets))\n\nprivate\n  octets_to_poly: {t,k,n} (fin k, fin n) => ([n*8]->t) -> [k*n*8] -> [k]t\n  octets_to_poly f octets = map f (reverse (split octets))\n\noctets_to_Fp: [48*8] -> t_Fp\noctets_to_Fp octets = to_Fp octets \noctets_to_Fp_2: [2*48*8] -> t_Fp_2\noctets_to_Fp_2 = (octets_to_poly`{k=2} octets_to_Fp)\n\noctets_to_Fp_12: [12*48*8] -> t_Fp_12\noctets_to_Fp_12 = octets_to_poly`{k=2} (octets_to_poly`{k=3} (octets_to_poly`{k=2} octets_to_Fp))\n\nr = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\n\nBP_x = octets_to_Fp 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\n\nBP_y = octets_to_Fp 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1\n\nh = 0x396c8c005555e1568c00aaab0000aaab\n\nBP = (BP_x, BP_y)\n\nb: t_Fp\nb = 4\n\nE: EllipticCurve t_Fp\nE = {base_field = Fp, a = Fp.field_zero, b = b}\n\nr' =  0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\n\nx'_0 = octets_to_Fp 0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\n\nx'_1 =  octets_to_Fp 0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e\n\ny'_0 = octets_to_Fp 0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801\n\ny'_1 = octets_to_Fp 0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be\n\nh' = 0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\n\nBP_x' = [x'_1, x'_0]\nBP_y' = [y'_1, y'_0]\n\nBP' = (BP_x', BP_y')\n\nb': t_Fp_2\nb' = [4,4]  \/\/ 4(u+1)\n\nE': EllipticCurve t_Fp_2\nE' = {base_field = Fp_2, a = Fp_2.field_zero, b = b'}\n```"}]}
{"filename":"BLST-Verification\/spec\/Maybe.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for a polymorphic Maybe type (as (Bool, a)) with constructors, eliminators, a map function, and properties proving distinctness, injectivity, correct recognition of nothing\/just, no-junk, and map-identity, as in the provided Maybe.cry file."},{"role":"assistant","content":"```cryptol\nmodule Maybe where\n\ntype Maybe a = (Bool, a)\n\nnothing: {a} (Zero a) => Maybe a\nnothing = (False, zero)\n\njust: {a} a -> Maybe a\njust x = (True, x)\n\nmaybe: {a,b} b -> (a -> b) -> Maybe a -> b\nmaybe c_nothing c_just (b, x) = if b then c_just x else c_nothing\n\nmaybe_cases: {a,b} Maybe a -> b -> (a -> b) -> b\nmaybe_cases (b, x) c_nothing c_just = if b then c_just x else c_nothing\n\nmaybe_map: {a,b} (Zero b) => (a -> b) -> Maybe a -> Maybe b\nmaybe_map f = maybe nothing (\\v -> just (f v))\n\nis_maybe: {a} (Cmp a, Zero a) => Maybe a -> Bool\nis_maybe (b,x) = (b \\\/ x==zero) \nprivate\n\n    property distinct (x:[2]) = nothing != just x\n    property injective (x:[2]) y = (just x == just y) == (x == y)\n\n    property recognize_nothing = is_maybe`{[5]} nothing\n    property recognize_just x = is_maybe`{([2],[2])} (just x)\n\n    property no_junk x = is_maybe`{[3]} x ==> x == (maybe nothing just) x\n    property no_junk' x = is_maybe`{[3]} x ==> x == maybe_cases x nothing just\n\n    property map_id x = is_maybe`{([2],Bit)} x ==> x == maybe_map (\\y->y) x\n```"}]}
{"filename":"BLST-Verification\/spec\/BLSMinimalSignatureSize.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for minimal-size BLS12-381 signatures (pubkeys in G2, signatures in G1), including serialization\/deserialization, hash-to-curve with the given DST, pairing-based verification, and subgroup checks, exposing appropriate functions for key, signature, and verification operations."},{"role":"assistant","content":"```cryptol\nmodule BLSMinimalSignatureSize = BLSGeneric where\n\nimport Parameters\nimport HashToCurveE1\nimport Pairing (bls_ate_pairing)\nimport Serialization\nimport ShortWeierstrassCurve as EC\n\ntype t_F = t_Fp type t_F' = t_Fp_2 \/\/ representation type for field of the secondary curve (pubkey)\ntype t_G = t_Fp_12  \/\/ representation type for field of the pairing result\nG = Fp_12\n\ntype pubkey_len = 96*8\ntype signature_len  = 48*8\n\nmain_curve = E\nother_curve = E'\n\nDST: [43][8]\nDST = \"BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_\"\n\nhash_to_point hx = hash_to_curve_opt (hx, DST)\n\nP: EC::AffinePoint t_F' \/\/ base point\nP = BP'\n\npairing (p,q) = bls_ate_pairing p q \npoint_to_pubkey S = join (serialize_E2 S)\n\npoint_to_signature S = join (serialize_E1 S)\n\npubkey_to_point S = deserialize_E2 (split S)\n\nsignature_to_point S = uncompress_E1 (split S)\n\npubkey_subgroup_check S =\n    EC::is_point_O E' (EC::mult E' r S)\n\nsignature_subgroup_check S =\n    EC::is_point_O E (EC::mult E r S)\n```"}]}
{"filename":"BLST-Verification\/spec\/BulkAddition.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol the bulk elliptic-curve addition and accumulation algorithm (including bulk_addition_head, bulk_addition_tail, bulk_accumulate, and bulk_add) showing they implement correct affine\/projective point addition on a given Short Weierstrass curve using Montgomery-style batched inversions."},{"role":"assistant","content":"```cryptol\nimport Common::Field\nimport FieldExtras\nimport ShortWeierstrassCurve\nimport PrimeField import implementation::CurveOperation\n\nF37 = prime_field`{37}\nC1: EllipticCurve (Z 37)\nC1 = { base_field= F37, a = 0, b = 4 }\n\np1: AffinePoint (Z 37)\np1 = (2,7) \np2: AffinePoint (Z 37)\np2 = (16,20) \nq1: AffinePoint (Z 37)\nq1 = (24, 29) \nF37' = prime_field_bv`{6} 37\nC1': EllipticCurve [6]\nC1' = { base_field= F37', a = 0, b = 4 }\n\np1': AffinePoint [6]\np1' = (2,7)\n\np2': AffinePoint [6]\np2' = (16,20)\n\nq1': AffinePoint [6]\nq1' = (24,29)\n\ninverses: {n, t} (fin n, n >= 1) => FieldRep t -> [n]t -> [n]t\ninverses F xs = results where\n  products = [xs@0] # [F.mul (p, x) | p <- products | x <- tail xs ]\n    iprods = [F.mul (x, i) | i <- tail`{n-1} iprods | x <- tail xs]\n           # [F.div(F.field_unit, products!0) ]\n    results = [iprods@0] # [F.mul(p, i) | p <- products | i <- tail iprods]\n\ninverse_functionality: {n, t} (fin n, n >= 1, Eq t) => FieldRep t -> [n]t -> Bool\ninverse_functionality F xs =\n  (mem F.field_zero (map F.normalize xs)) \\\/ test_inverses F xs == map (\\ x -> F.field_unit) xs\n  where\n    mem i xs' = (map ((==) i) xs') != zero\n    test_inverses F' xs' = [F'.mul(x,i) | x <- xs' | i <- inverses F' xs']\n\neq_F : {t} (Eq t) => FieldRep t -> t -> t -> Bool\neq_F F x y = F.normalize x == F.normalize y\n\nbulk_addition_head_imp: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t) -> t -> ((t,t,t), (t,t,t))\nbulk_addition_head_imp F A B mul_acc = ((ax_1, ay_1, az_2), (bx_1, by_1, bz_2)) where\n  x1 = F.normalize A.0\n  y1 = F.normalize A.1\n  x2 = F.normalize B.0\n  y2 = F.normalize B.1\n  inf = (eq_F F x1 F.field_zero \/\\ eq_F F y1 F.field_zero) \\\/ (eq_F F x2 F.field_zero \/\\ eq_F F y2 F.field_zero)\n  bz = F.sub (x2, x1)\n  bx = F.add (x2, x1)\n  az = F.add (y2, y1)\n  by_0 = F.sub (y2, y1)\n\n  cond = eq_F F bz F.field_zero   inf_1 = if cond then eq_F F az F.field_zero else inf\n  bx_1 = if cond then if inf_1 then az else bx else bx\n  by_1 = if cond then mul_by_3 F (F.sq x1) else by_0\n  bz_1 = if cond then az else bz\n\n  ax_1 = if inf_1 then bx_1 else x1\n  ay_1 = if inf_1 then az else y1\n  az_1 = if inf_1 then F.field_unit else bz_1\n  bz_2 = if inf_1 then F.field_zero else bz_1\n  az_2 = F.mul (az_1, mul_acc)\n\nbulk_addition_head: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t) -> t -> ((t,t,t), (t,t,t))\nbulk_addition_head F A B mul_acc = (bulk_addition_head_a F A B mul_acc,  bulk_addition_head_b F A B)\n\nbulk_addition_head_a: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t) -> t -> (t,t,t)\nbulk_addition_head_a F (x1,y1) (x2,y2) mul_acc =\n  if x1 == x2 \/\\ y1 == y2\n  then (x1, y1, mul_by_2 F (F.mul (y1, mul_acc)))\n  else if x1 == x2 \/\\ y1 == F.neg(y2)\n  then (F.field_zero, F.field_zero, mul_acc)\n  else (x1, y1, (F.mul (F.sub (x2, x1), mul_acc)))\n\nbulk_addition_head_b: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t) -> (t,t,t)\nbulk_addition_head_b F (x1,y1) (x2,y2) =\n  if x1 == x2 \/\\ y1 == y2\n  then (mul_by_2 F x1, mul_by_3 F (F.sq x1), mul_by_2 F y1)\n  else if x1 == x2 \/\\ y1 == F.neg(y2)\n  then (F.field_zero, mul_by_3 F (F.sq x1), F.field_zero)\n  else (F.add (x2, x1), F.sub(y2, y1), F.sub (x2, x1))\n\nbulk_addition_tail: {t} (Eq t) => FieldRep t -> (t,t) -> (t,t,t) -> t -> (t,t)\nbulk_addition_tail F A B lam = if eq_F F b_z F.field_zero then (a_x, a_y) else (d_x, d_y)\n  where\n    a_x = F.normalize A.0\n    a_y = F.normalize A.1\n    b_x = F.normalize B.0\n    b_y = F.normalize B.1\n    b_z = F.normalize B.2\n    lam' = F.mul(lam, b_y)\n    llam = F.sq lam'\n    d_x = F.sub (llam, b_x)\n    d_y = F.sub (F.mul(F.sub(a_x, d_x), lam'), a_y)\n\n\/\/ the B->Z result does not depend on A or lambda\nbulk_addition_tail_bz: {t} (Eq t) => FieldRep t -> t -> t\nbulk_addition_tail_bz F b_z =\n    if eq_F F b_z F.field_zero then F.field_unit else (F.normalize b_z)\n\n\/\/ TODO: semi-correctness: head, inverse, tail give the correct addition formula.\n\n\/\/ NOTE: in the A==B case, must know that y != 0, i.e., there are no\n\/\/ points (x,0) on the curve.  given the equation y^2 = x^3 + 4 for E,\n\/\/ that's saying that -4 is not a cube (which is true); given the\n\nhead_inverse_tail: {t} (Eq t) => EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\nhead_inverse_tail C a b = c where\n          F = C.base_field\n          ((ax,ay,az), (bx,by_0,bz)) = bulk_addition_head F a b F.field_unit\n          lam = F.div (F.field_unit, az)\n          c = bulk_addition_tail F (ax,ay) (bx,by_0,bz) lam\n\nhead_inverse_tail': {t} (Eq t) => EllipticCurve t -> AffinePoint t -> AffinePoint t -> AffinePoint t\nhead_inverse_tail' C a b = c where\n          F = C.base_field\n          ((ax,ay,az), (bx,by_0,bz)) = bulk_addition_head_imp F a b F.field_unit\n          lam = if az == F.field_zero then F.field_unit else F.div (F.field_unit, az)\n          c = bulk_addition_tail F (ax,ay) (bx,by_0,bz) lam\n\ntype BulkAdditionStuff t =\n  { field : FieldRep t\n  , bulk_addition_head_fn : (t,t) -> (t,t) -> t -> ((t,t,t), (t,t,t))\n  , bulk_addition_tail_fn : (t,t) -> (t,t,t) -> t -> (t,t)\n  , bulk_addition_tail_bz_fn : t -> t\n  , point_dadd_affine_fn : ProjectivePoint t -> AffinePoint t  -> ProjectivePoint t\n  }\n\ncoerceSize : {m,n,a} (fin n, fin m) => [m]a -> [n]a\ncoerceSize xs = assert (`m == `n) \"coerceSize: size mismatch\" [ xs@i | i <- [0..<n] ]\n\natLeastOne: {n,a} [n]a -> [max 1 n]a\natLeastOne xs = (drop`{min 1 n} ([undefined] # xs))\n\nbulk_accumulate: {n, t} (fin n, Eq t) => BulkAdditionStuff t -> (t,t,t) -> [n] (t,t)  -> (t,t,t)\nbulk_accumulate C sum' points =\n  if `n < 16\n  then bulk_accumulate_small C sum' points\n  else if (`n%2) == 1\n  then bulk_accumulate`{n\/2} C (C.point_dadd_affine_fn sum' (points@0)) (bulk_accumulate_even`{n\/2} C (tail (coerceSize points)))\n  else bulk_accumulate`{n\/2} C sum' (bulk_accumulate_even`{n\/2} C (coerceSize points))\n\nbulk_accumulate_small: {n, t} (fin n) => BulkAdditionStuff t -> (t,t,t) -> [n] (t,t)  -> (t,t,t)\nbulk_accumulate_small C sum' points = sums!0 where\n  sums = [sum'] # [C.point_dadd_affine_fn x p | x <- sums | p <- points]\n\nbulk_accumulate_even_0: {n, t} (fin n) => EllipticCurve t -> (t,t) -> [2*n] (t,t)  -> (t,t)\nbulk_accumulate_even_0 C sum' points = undefined\n\nbulk_accumulate_even: {n, t} (fin n, Eq t) => BulkAdditionStuff t -> [2*n] (t,t)  -> [n](t,t)\nbulk_accumulate_even C points = dst where\n  points':  [n] ((t,t,t), (t,t,t))\n  points' = bulk_accumulate_loop_1 C points\n  \/\/ the Montgomery trick part\n  last_pair: ((t,t,t), (t,t,t))\n  \/\/last_pair = ([(z,z)] # points')!0       last_pair = points'!0\n  last_inv = C.field.div (C.field.field_unit, last_pair.0.2)\n  dst = bulk_accumulate_loop_2 C points' last_inv\n\nbulk_accumulate_loop_1: {n, t} (fin n, Eq t) => BulkAdditionStuff t -> [2*n] (t,t)  -> [n] ((t,t,t), (t,t,t))\nbulk_accumulate_loop_1 C points = points' where\n  points' = [C.bulk_addition_head_fn a b mul_ac | [a,b] <- split points | mul_ac <- mul_acs]\n  mul_acs = [C.field.field_unit] # [ma | ((_,_,ma), _) <- points' ]\n\n\/\/ second loop ` for (dst = points, i = n; --i;) ...`\n\/\/  runs reversed through the points array.  There are two effects:\n\/\/ one is the Montgomery inverse calculation, using the z fields of the\n\/\/ \"b\" points, the other using these inverses in the TAIL part of the\n\/\/ point addition. We use \n\nbulk_accumulate_loop_2: {n, t} (fin n, Eq t) => BulkAdditionStuff t -> [n] ((t,t,t),(t,t,t))  -> t -> [n](t,t)\nbulk_accumulate_loop_2 C point_pairs last_inv = dst where\n  \/\/ dst = [C.bulk_addition_tail_fn (ax,ay) b (C.field.mul(i, az)) | ((ax,ay,az),b) <- point_pairs | i <- inverses']\n  dst = [C.bulk_addition_tail_fn (ax,ay) b i | ((ax,ay,az),b) <- point_pairs | i <- inverses']\n  inverses': [max 1 n] t\n    products = [az | ((_,_,az),_) <- point_pairs]\n  xs = [bz | (_,(_,_,bz)) <- point_pairs]\n  iprods: [max 1 n] t\n  iprods = [C.field.mul (i, C.bulk_addition_tail_bz_fn x) | i <- tail iprods | x <- tail (atLeastOne xs)]\n           # [C.field.div(C.field.field_unit, products!0) ]\n    inverses' = [iprods@0] # [C.field.mul(i, p) | i <- tail iprods | p <- products]\n  \/\/ inverses'@i == products@(i-1) * iprods@i == inverse (xs@i)\n\nbulk_accumulate_inverses: {n, t} (fin n, Eq t) => FieldRep t -> [n] ((t,t,t),(t,t,t))  -> t -> [_]t\nbulk_accumulate_inverses F point_pairs last_inv = inverses' where\n  inverses': [max 1 n] t\n    products = [az | ((_,_,az),_) <- point_pairs]\n  xs = [bz | (_,(_,_,bz)) <- point_pairs]\n  iprods: [max 1 n] t\n  iprods = [F.mul (x, i) | i <- tail iprods | x <- tail (atLeastOne xs)]\n           # [F.div(F.field_unit, products!0) ]\n    inverses' = [iprods@0] # [F.mul(p, i) | p <- products | i <- tail iprods]\n  \/\/ inverses'@i == products@(i-1) * iprods@i == inverse (xs@i)\n\nbulk_add : {m, n, t} (fin m, fin n, Eq t) => BulkAdditionStuff t -> (t, t, t) -> [n](t, t) -> (t, t, t)\nbulk_add C sum_acc points = if `n == 0\n  then sum_acc\n  else bulk_add`{m} C (bulk_accumulate C sum_acc (take`{min m n} points)) (drop`{min m n} points)\n```"}]}
{"filename":"BLST-Verification\/spec\/Frobenius.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the Frobenius endomorphisms over the BLS12-381 extension fields Fp\u00b2, Fp\u2076, and Fp\u00b9\u00b2, including the constants v_frobenius_constant, v_frobenius_constant_sq, w_frobenius_constant, and the functions fp2_frobenius, fp6_frobenius, fp12_frobenius, and fp12_conjugate."},{"role":"assistant","content":"```cryptol\nmodule Frobenius where\n\nimport Parameters as P\nimport FieldExtras\n\ntype t1 = P::t_Fp\ntype t2 = P::t_Fp_2\ntype t6 = P::t_Fp_6\ntype t12 = P::t_Fp_12 \n\nf1 = P::Fp\nf2 = P::Fp_2\nf6 = P::Fp_6\nf12 = P::Fp_12\n\nfp2_conjugate: t2 -> t2\nfp2_conjugate [a,b] = [f1.neg a, b] \nfp2_frobenius: t2  -> t2\nfp2_frobenius x = fp2_conjugate x\n\nv_frobenius_constant: t2\nv_frobenius_constant = F_expt`{n=381} f2 P::u_plus_1 `((P::p-1)\/3)\n\nv_frobenius_constant_sq: t2\nv_frobenius_constant_sq = f2.sq v_frobenius_constant\n\nfp6_frobenius: t6 -> t6\nfp6_frobenius [a,b,c] = [a',b',c'] where\n    a' = f2.mul (v_frobenius_constant_sq, fp2_frobenius a)\n    b' = f2.mul (v_frobenius_constant, fp2_frobenius b)\n    c' = fp2_frobenius c\n\nw_frobenius_constant: t6\nw_frobenius_constant = P::Fp_2_to_Fp_6 (F_expt`{n=381} f2 P::u_plus_1 `((P::p-1)\/6))\n\nfp12_frobenius: t12 -> t12\nfp12_frobenius [a,b] = [a', b'] where\n    a' = f6.mul (w_frobenius_constant, fp6_frobenius a)\n    b' = fp6_frobenius b\n\nfp12_conjugate: t12 -> t12\nfp12_conjugate [a,b] = [f6.neg a, b]\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/CoreVerifyPKInG1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for core_verify_pk_in_g1_impl implementing BLS signature public-key verification in G1, including its type, dependencies on pairing, hashing to G2, final exponentiation, and a property stating it returns True exactly when the pairing-based BLS verification equation holds."},{"role":"assistant","content":"```cryptol\nmodule implementation::CoreVerifyPKInG1 where\n\nimport Parameters (Fp_12, t_Fp, t_Fp_2, BP, E')\nimport ShortWeierstrassCurve (AffinePoint, affinify)\nimport implementation::PairingImpl (miller_loop_opt)\nimport implementation::HashToG2 (hash_to_curve_E2_opt_impl)\nimport implementation::FinalExp (final_exponentiation_impl)\nimport implementation::PairingImpl (miller_loop_opt_checked)\nimport ExpandMessage\nimport Frobenius (fp12_conjugate)\nimport HashToCurveE2\n\ncore_verify_pk_in_g1_impl : {msg_len,dst_len,aug_len}\n  (fin msg_len, fin dst_len, fin aug_len\n  , Expandable (msg_len+aug_len) dst_len\n  , dst_len <= 255) =>\n  AffinePoint t_Fp -> AffinePoint t_Fp_2 -> [msg_len][8] -> [dst_len][8] -> [aug_len][8] -> Bool\n\ncore_verify_pk_in_g1_impl pk sig msg dst aug = Fp_12.is_equal(gt, Fp_12.field_unit) where\n    Q = affinify E' (hash_to_curve_E2_opt_impl (aug#msg, dst))\n    gtPQ = miller_loop_opt_checked pk Q\n    gtSig = fp12_conjugate (miller_loop_opt_checked BP sig)\n    gt = final_exponentiation_impl (Fp_12.mul (gtSig, gtPQ))\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/SerializationP2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `implementation::SerializationP2` that specifies and verifies the deserialization of compressed representations for the BLS12-381 G2 curve (E2\/E') into `EC::AffinePoint t_Fp_2`, including functions `uncompress_E2_imp`, `uncompress_E2_OK`, and `deserialize_E2_x\/y` and their correctness properties."},{"role":"assistant","content":"```cryptol\nmodule implementation::SerializationP2 where\n\nimport Parameters (p, E, E', t_Fp, to_Fp, t_Fp_2, Fp, Fp_2)\nimport ShortWeierstrassCurve as EC\nimport rfc8017\nimport Maybe\nimport FieldExtras (F_expt)\nimport BLSFieldExtras\nimport Serialization\nimport implementation::Types\nimport implementation::Field\n\n\/\/ deserialization of compressed representations for curve E2 (aka E').\n\nuncompress_E2_x: [96][8] -> [2][384]\nuncompress_E2_x s_string = x where\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    \/\/ Step 6 - but not clearly described in the IETF specification\n    \/\/ AND - some uncertainty about the order of the parts\n    \/\/ x = reverse (split`{parts=2} (join s_string'))\n        x = split`{parts=2} (join s_string')\n\nuncompress_E2_x_fp: [96][8] -> t_Fp_2\nuncompress_E2_x_fp s_string = [f x0, f x1] where\n    [x0, x1] = uncompress_E2_x s_string\n    f x = Fp.mul (fp_abs (vec384_rep x), montgomery_factor_p) \/\/ Montgomery-encode using multiplication\n\nnot_too_big_E2: [2][384] -> Bool\nnot_too_big_E2 x = (x@0 < `p) \/\\ (x@1 < `p)\n\nuncompress_E2_y2: [96][8] -> t_Fp_2\nuncompress_E2_y2 s_string = y2 where\n    x = uncompress_E2_x_fp s_string\n    y2 = Fp_2.add (Fp_2.mul (Fp_2.sq x, x), [4,4]) \/\/ Note [4,4] = 4*u\n\nuncompress_E2_y: [96][8] -> t_Fp_2\nuncompress_E2_y s_string = sqrt_fp2 (uncompress_E2_y2 s_string)\n\nuncompress_E2_imp: [96][8] -> Maybe (EC::AffinePoint t_Fp_2)\nuncompress_E2_imp s_string = ret where\n    \/\/ Step 1.\n    m_byte = (s_string@0) && 0xE0 \/\/ three highest bits\n    C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    x = uncompress_E2_x_fp s_string\n    y2 = uncompress_E2_y2 s_string\n    y = sqrt_fp2 y2\n    Y_bit = sign_F_p_2 y\n    ret = if C_bit == False then nothing            | I_bit then (if ~S_bit \/\\ s_string' == zero then just (EC::point_O E') else nothing)\n           | ~ (not_too_big_E2 (uncompress_E2_x s_string)) then nothing            | ~ (is_square_fp2 y2) then nothing            | S_bit == Y_bit then just (x,y)\n          else just (x, Fp_2.neg y)\n\nuncompress_E2_OK: [96][8] -> EC::AffinePoint t_Fp_2\nuncompress_E2_OK s_string = if S_bit == Y_bit then (x,y) else (x, Fp_2.neg y) where\n    x = uncompress_E2_x_fp s_string\n    y = uncompress_E2_y s_string\n    S_bit = (s_string@0)@2\n    Y_bit = sign_F_p_2 y\n\ndeserialize_E2_x: [2*96][8] -> [2][384]\ndeserialize_E2_x s_string = x where\n    s_string' = take`{96} ([(s_string@0) && 0x1F] # tail s_string)\n    x = reverse (split`{parts=2} (join s_string'))\n\ndeserialize_E2_y: [2*96][8] -> [2][384]\ndeserialize_E2_y s_string = reverse (split (join (drop`{96} s_string)))\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/Fp12.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the Fp12 extension field arithmetic for BLS12-381, including fp12_mul, fp12_sqr, cyclotomic_sqr_fp12, and inverse_fp12_imp, and add properties showing these implementations are correct field operations (associativity, identity, inverses, and consistency with the generic extension_field construction)."},{"role":"assistant","content":"```cryptol\nmodule implementation::Fp12 where\n\nimport Common::Field\nimport FieldExtras\nimport ExtensionField\nimport implementation::Types\nimport implementation::Field\nimport Parameters (p, Fp, t_Fp, to_Fp, from_Fp, t_Fp_2, Fp_2, t_Fp_6, Fp_6, t_Fp_12, Fp_12,\n                   u_plus_1, Fp_2_to_Fp_6)\nimport Frobenius\nimport PrimeField import ExtensionField\nimport Polynomial\n\nnest f x (n:[64]) =\n    if n==0 then x\n     | n == 1 then f x\n     | n == 2 then f (f x)\n    else f (f (f x))\n\nrep_v_frobenius_constant =     [[0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000],\n     [0xcd03c9e48671f071, 0x5dab22461fcda5d2, 0x587042afd3851b95,\n      0x8eb60ebe01bacb9e, 0x03f97d6e83d050d2, 0x18f0206554638741]]\n\nrep_v_frobenius_constant_sq =      [[0x890dc9e4867545c3, 0x2af322533285a5d5, 0x50880866309b7e2c,\n      0xa20d1b8c7e881024, 0x14e4f04fe2db9068, 0x14e56d3f1564853a],\n     [0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000]]\n\nrep_v_frobenius_constant_sq_const_part =      [0x890dc9e4867545c3, 0x2af322533285a5d5, 0x50880866309b7e2c,\n     0xa20d1b8c7e881024, 0x14e4f04fe2db9068, 0x14e56d3f1564853a]\n\nrep_w_frobenius_constant_const_part =     [[0x07089552b319d465, 0xc6695f92b50a8313, 0x97e83cccd117228f,\n      0xa35baecab2dc29ee, 0x1ce393ea5daace4d, 0x08f2220fb0fb66eb],\n     [0xb2f66aad4ce5d646, 0x5842a06bfc497cec, 0xcf4895d42599d394,\n      0xc11b9cba40a8e8d0, 0x2e3813cbe5a0de89, 0x110eefda88847faf]]\n\nv_frobenius_constant_2 = F_expt`{n=762} f2 u_plus_1 `((p*p-1)\/3)\nv_frobenius_constant_2_sq = Fp_2.sq v_frobenius_constant_2\n\nw_frobenius_constant_2_part = F_expt`{n=762} f2 u_plus_1 `((p*p-1)\/6)\n\nrep_v_frobenius_constant_2 =\n    [[0x30f1361b798a64e8, 0xf3b8ddab7ece5a2a, 0x16a8ca3ac61577f7,\n      0xc26a2ff874fd029b, 0x3636b76660701c6e, 0x051ba4ab241b6160],\n     [0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000]]\n\nrep_v_frobenius_constant_2_sq_const_part =\n    [0xcd03c9e48671f071, 0x5dab22461fcda5d2, 0x587042afd3851b95,\n     0x8eb60ebe01bacb9e, 0x03f97d6e83d050d2, 0x18f0206554638741]\n\nrep_w_frobenius_constant_2_const_part =\n    [[0xecfb361b798dba3a, 0xc100ddb891865a2c, 0x0ec08ff1232bda8e,\n      0xd5c13cc6f1ca4721, 0x47222a47bf7b5c04, 0x0110f184e51c5f59],\n     [0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000]]\n\nfp6_frobenius2 [a,b,c] = [a',b',c'] where\n    a' = f2.mul (v_frobenius_constant_2_sq, fp2_frobenius (fp2_frobenius a))\n    b' = f2.mul (v_frobenius_constant_2, fp2_frobenius (fp2_frobenius b))\n    c' = fp2_frobenius (fp2_frobenius c)\n\nfp12_frobenius2 [a,b] = [a',b'] where\n    a' = Fp_6.mul (Fp_2_to_Fp_6 w_frobenius_constant_2_part,\n                   fp6_frobenius (fp6_frobenius a))\n    b' = fp6_frobenius (fp6_frobenius b)\n\nv_frobenius_constant_3 = F_expt`{n=1143} f2 u_plus_1 `((p*p*p-1)\/3)\nv_frobenius_constant_3_sq = Fp_2.sq v_frobenius_constant_3\n\nw_frobenius_constant_3_part = F_expt`{n=1143} f2 u_plus_1 `((p*p*p-1)\/6)\n\nrep_v_frobenius_constant_3 =\n    [[0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n      0x0000000000000000, 0x0000000000000000, 0x0000000000000000],\n     [0x760900000002fffd, 0xebf4000bc40c0002, 0x5f48985753c758ba,\n      0x77ce585370525745, 0x5c071a97a256ec6d, 0x15f65ec3fa80e493]]\n\nrep_v_frobenius_constant_3_sq_const_part =\n    [0x43f5fffffffcaaae, 0x32b7fff2ed47fffd, 0x07e83a49a2e99d69,\n     0xeca8f3318332bb7a, 0xef148d1ea0f4c069, 0x040ab3263eff0206]\n\nrep_w_frobenius_constant_3_const_part =\n    [[0x3e2f585da55c9ad1, 0x4294213d86c18183, 0x382844c88b623732,\n      0x92ad2afd19103e18, 0x1d794e4fac7cf0b9, 0x0bd592fc7d825ec8],\n     [0x7bcfa7a25aa30fda, 0xdc17dec12a927e7c, 0x2f088dd86b4ebef1,\n      0xd1ca2087da74d4a7, 0x2da2596696cebc1d, 0x0e2b7eedbbfd87d2]]\n\nfp6_frobenius3 [a,b,c] = [a',b',c'] where\n    a' = f2.mul (v_frobenius_constant_3_sq, fp2_frobenius a)\n    b' = f2.mul (v_frobenius_constant_3, fp2_frobenius b)\n    c' = fp2_frobenius c\n\nfp12_frobenius3 [a,b] = [a',b'] where\n    a' = Fp_6.mul (Fp_2_to_Fp_6 w_frobenius_constant_3_part,\n                   fp6_frobenius (fp6_frobenius (fp6_frobenius a)))\n    b' = fp6_frobenius (fp6_frobenius (fp6_frobenius b))\n\ntype t_Fp_4 = [2]t_Fp_2\nFp_4 = extension_field Fp_2 [Fp_2.field_zero, u_plus_1]\ny_fp4: t_Fp_4\ny_fp4 = [Fp_2.field_unit, Fp_2.field_zero] \nfp4_abs [x, y] = [fp2_abs y, fp2_abs x]\nfp4_rep [x, y] = [fp2_rep y, fp2_rep x]\n\ntype t_Fp_12_alt = [3]t_Fp_4\nFp_12_alt = extension_field Fp_4 [Fp_4.field_zero, Fp_4.field_zero, y_fp4]\n\nFp_12_to_Fp_12_alt: t_Fp_12 -> t_Fp_12_alt\nFp_12_to_Fp_12_alt [[a,b,c],[d,e,f]] = [[a,e], [d,c], [b,f]]\n\nFp_12_alt_to_Fp_12: t_Fp_12_alt -> t_Fp_12\nFp_12_alt_to_Fp_12 [[A,B], [C,D], [E,F]] = [[A,E,D], [C,B,F]]\n\nconjugate_fp4: t_Fp_4 -> t_Fp_4\nconjugate_fp4 [x,y] = [Fp_2.neg x, y]\n\ncyclotomic_sqr_alt: t_Fp_12_alt -> t_Fp_12_alt\ncyclotomic_sqr_alt [c,b,a] = [C,B,A] where     A = Fp_4.sub (x3 (Fp_4.sq a), x2 (conjugate_fp4 a))\n    B = Fp_4.add (x3 (Fp_4.mul (y_fp4, Fp_4.sq c)), x2 (conjugate_fp4 b))\n    C = Fp_4.sub (x3 (Fp_4.sq b), x2 (conjugate_fp4 c))\n    x2 x = Fp_4.add (x, x)     x3 x = Fp_4.add (x, x2 x) \ncyclotomic_sqr_fp12: t_Fp_12 -> t_Fp_12\ncyclotomic_sqr_fp12 x =\n    Fp_12_alt_to_Fp_12 (cyclotomic_sqr_alt (Fp_12_to_Fp_12_alt x))\n\ncyclotomic_sqr_fp12_imp: t_Fp_12 -> t_Fp_12\ncyclotomic_sqr_fp12_imp [[a12, a11, a10], [a02, a01, a00]] = r where\n            [t01, t00] = Fp_4.sq [a11, a00]\n    [t11, t10] = Fp_4.sq [a02, a10]\n    [t21, t20] = Fp_4.sq [a12, a01]\n    r00 = f_sub t00 a00\n    r01 = f_sub t10 a01\n    r02 = f_sub t20 a02\n\n    r10 = f_add (Fp_2.mul (u_plus_1, t21)) a10\n    r11 = f_add t01 a11\n    r12 = f_add t11 a12\n\n    r = [[r12, r11, r10], [r02, r01, r00]]\n    f_sub x y = Fp_2.add (s, Fp_2.add (s, x)) where s = Fp_2.sub (x, y)\n    f_add x y = Fp_2.add (s, Fp_2.add (s, x)) where s = Fp_2.add (x, y)\n\nsqr_fp4_imp a0 a1 = [ret1, ret0] where\n    t0 = Fp_2x2.sq a0     t1 = Fp_2x2.sq a1     t3 = Fp_2.add (a0, a1) \n    t2 = Fp_2x2.mul (t1, u_plus_1x2)     ret0 = Fp_2x2.add (t2, t0) \n    t2_b = Fp_2x2.sq t3     ret1 = Fp_2x2.sub (Fp_2x2.sub (t2_b, t0), t1)     \n\nFpx2 = prime_field_integer (`p * 2^^384 )\n\nFp_2x2 = extension_field Fpx2 [Fpx2.field_zero, Fpx2.neg Fpx2.field_unit] u_plus_1x2: t_Fp_2x2\nu_plus_1x2 = Fp_2x2.add (poly_x Fpx2, poly_1 Fpx2)\n\nFp_6x2 = extension_field Fp_2x2 [Fp_2x2.field_zero, Fp_2x2.field_zero, u_plus_1x2]\n\nfp6x2_tmp a1 a2 b1 b2 = Fp_2x2.sub (Fp_2x2.sub (t, Fp_2x2.mul (a1, b1)), Fp_2x2.mul (a2, b2)) where\n  t = Fp_2x2.mul (Fp_2.add (a1,a2), Fp_2.add (b1, b2))\n\nfp6x2_mul: [3][2]Integer -> [3][2]Integer -> [3][2]Integer\nfp6x2_mul [a2, a1, a0] [b2, b1, b0] = [r2, r1, r0] where\n  r0 = Fp_2x2.add (Fp_2x2.mul (fp6x2_tmp a1 a2 b1 b2, u_plus_1x2), Fp_2x2.mul (a0, b0))\n  r1 = Fp_2x2.add (fp6x2_tmp a0 a1 b0 b1, Fp_2x2.mul (Fp_2x2.mul (a2, b2), u_plus_1x2))\n  r2 = Fp_2x2.add (fp6x2_tmp a0 a2 b0 b2, Fp_2x2.mul (a1, b1))\n\nfp12_mul_1 a0 a1 b0 b1 = Fp_6x2.sub (Fp_6x2.sub (t, fp6x2_mul a0  b0), fp6x2_mul a1 b1) where\n  t = fp6x2_mul (Fp_6.add (b0,b1)) (Fp_6.add (a0, a1))\n\nfp12_mul_0 a0 a1 b0 b1 = [rx2, rx1, rx0] where\n  [t0_2, t0_1, t0_0] = fp6x2_mul a0 b0\n  [t1_2, t1_1, t1_0] = fp6x2_mul a1 b1\n  rx2 = Fp_2x2.add (t0_2, t1_1)\n  rx1 = Fp_2x2.add (t0_1, t1_0)\n  rx0 = Fp_2x2.add (t0_0, Fp_2x2.mul (t1_2, u_plus_1x2))\n\nfp12_mul: [2][3][2]Integer -> [2][3][2]Integer -> [2][3][2]Integer\nfp12_mul [a1, a0] [b1, b0] = [r1, r0] where\n  r0 = fp12_mul_0 a0 a1 b0 b1\n  r1 = fp12_mul_1 a0 a1 b0 b1\n\nfp12_sqr: t_Fp_12 -> t_Fp_12\nfp12_sqr a = ret where\n    [a1, a0] = a\n    [a12, a11, a10] = a1\n    [a02, a01, a00] = a0\n\n    t0 = Fp_6.add (a0, a1)                   t12 = Fp_2.mul (u_plus_1, a12)           t1 = [ Fp_2.add (a02, a11)                    , Fp_2.add (a01, a10)                    , Fp_2.add (a00, t12)]              t0_a = Fp_6.mul (t0, t1)                 t1_a = Fp_6.mul (a0, a1)                 [t12_a, t11_a, t10_a] = t1_a\n\n    r1 = Fp_6.add (t1_a, t1_a)               [r02, r01, r00] = Fp_6.sub (t0_a, t1_a) \n    t12_b = Fp_2.mul (u_plus_1, t12_a)   \n    r00_a = Fp_2.sub (r00, t12_b)            r01_a = Fp_2.sub (r01, t10_a)            r02_a = Fp_2.sub (r02, t11_a)            ret = [r1, [r02_a, r01_a, r00_a]]\n\nxy00z0_expander: Fp_6_rep_t -> Fp_12_rep_t\nxy00z0_expander [x,y,z] = [[x, y, zero], [zero, z, zero]] \nfp6_to_fp12_xy00z0: t_Fp_6 -> t_Fp_12\nfp6_to_fp12_xy00z0 [z,y,x] = [[zero, z, zero], [zero, y, x]] \n\nmul_by_0y0_fp6x2: t_Fp_6 -> t_Fp_2 -> t_Fp_6\nmul_by_0y0_fp6x2 a b = [r2, r1, r0] where\n    [a2,a1,a0] = a\n    t = Fp_2x2.mul (a2, b)\n    r0 = Fp_2x2.mul (t, u_plus_1x2)\n    r1 = Fp_2x2.mul (a0, b)\n    r2 = Fp_2x2.mul (a1, b)\n\nmul_by_xy0_fp6x2: t_Fp_6 -> t_Fp_2 -> t_Fp_2 -> t_Fp_6\nmul_by_xy0_fp6x2 a b1 b0 = [r2_a, r1_b, r0_a] where\n    [a2, a1, a0] = a\n    t0 = Fp_2x2.mul (a0, b0)         t1 = Fp_2x2.mul (a1, b1)     \n    t2 = Fp_2x2.mul (a2, b1)         r0 = Fp_2x2.mul (t2, u_plus_1x2)     r0_a = Fp_2x2.add (r0, t0)   \n    aa = Fp_2.add (a0, a1)           bb = Fp_2.add (b0, b1)           r1 = Fp_2x2.mul (aa, bb)         r1_a = Fp_2x2.sub (r1, t0)       r1_b = Fp_2x2.sub (r1_a, t1) \n    r2 = Fp_2x2.mul (a2, b0)         r2_a = Fp_2x2.add (r2, t1)   \nmul_by_xy00z0_fp12: t_Fp_12 -> t_Fp_6 -> t_Fp_12\nmul_by_xy00z0_fp12 a xy00z0 = [r1_a, r0] where\n    [a1, a0] = a\n    [b2, b1, b0] = xy00z0\n    t0 =  mul_by_xy0_fp6x2 a0 b1 b0         t1 = mul_by_0y0_fp6x2 a1 b2         \n    t2_0 = b0                               t2_1 = Fp_2.add (b1, b2)                r1 = Fp_6.add (a0, a1)                  rr = mul_by_xy0_fp6x2 r1 t2_1 t2_0      rr_a = Fp_6x2.sub (rr, t0)              rr_b = Fp_6x2.sub (rr_a, t1)            r1_a = rr_b                         \n    [t0_2, t0_1, t0_0] = t0\n    [t1_2, t1_1, t1_0] = t1\n    rr0 = Fp_2x2.mul (t1_2, u_plus_1x2)     rr0_a = Fp_2x2.add (t0_0, rr0)          rr1 = Fp_2x2.add (t0_1, t1_0)           rr2 = Fp_2x2.add (t0_2, t1_1)           r0 = [rr2, rr1, rr0_a]              \n\ninverse_fp2_imp: t_Fp_2 -> t_Fp_2\ninverse_fp2_imp [a1,a0] = [r1,r0] where\n    t = Fp.div(Fp.field_unit, Fp.add (Fp.sq a0, Fp.sq a1))\n    r0 = Fp.mul (a0,t)\n    r1 = Fp.neg (Fp.mul (a1,t))\n\ninverse_fp6_imp: t_Fp_6 -> t_Fp_6\ninverse_fp6_imp [a2,a1,a0] = [r2,r1,r0] where \n    c0 = Fp_2.sub (Fp_2.sq a0, Fp_2.mul (u_plus_1,Fp_2.mul (a1,a2)))\n    c1 = Fp_2.sub (Fp_2.mul (u_plus_1, Fp_2.sq a2), Fp_2.mul(a0,a1))\n    c2 = Fp_2.sub (Fp_2.sq a1, Fp_2.mul (a0, a2))\n    t0 = Fp_2.add (Fp_2.mul (c1, a2), Fp_2.mul (c2, a1))\n    t1 = Fp_2.add (Fp_2.mul (u_plus_1, t0), Fp_2.mul (c0, a0))\n    t  = inverse_fp2_imp t1     r2 = Fp_2.mul(c2, t)\n    r1 = Fp_2.mul(c1, t)\n    r0 = Fp_2.mul(c0, t)\n\ninverse_fp12_imp: t_Fp_12 -> t_Fp_12\ninverse_fp12_imp [a1,a0] = [r1,r0] where\n    [t0_2, t0_1, t0_0]  = Fp_6.sq a0     [t1_2, t1_1, t1_0] = Fp_6.sq a1      t1_2a = Fp_2.mul (t1_2, u_plus_1)     t0_0a = Fp_2.sub (t0_0, t1_2a)      t0_1a = Fp_2.sub (t0_1, t1_0)       t0_2a = Fp_2.sub (t0_2, t1_1)   \n    t1_a = inverse_fp6_imp [t0_2a, t0_1a, t0_0a]     r0 = Fp_6.mul (a0, t1_a)            r1 = Fp_6.neg (Fp_6.mul (a1, t1_a)) \n\nsqr_fp6_imp: t_Fp_6 -> t_Fp_6\nsqr_fp6_imp a = ret where\n    [a2, a1, a0] = a\n    s0 = Fp_2x2.mul (a0, a0) \n    m01 = Fp_2x2.mul (a0, a1)     m01_a = Fp_2x2.add (m01, m01) \n    m12 = Fp_2x2.mul (a1, a2)     m12_a = Fp_2x2.add (m12, m12) \n    s2 = Fp_2x2.mul (a2,a2) \n\n    ret2 = Fp_2.add (a2, a1)     ret2_a = Fp_2.add (ret2, a0)     rx = Fp_2x2.mul (ret2_a, ret2_a)     rx_a = Fp_2x2.sub (rx, s0)     rx_b = Fp_2x2.sub (rx_a, s2)     rx_c = Fp_2x2.sub (rx_b, m01_a)     rx_d = Fp_2x2.sub (rx_c, m12_a)     ret2_b = rx_d \n\n    rx_e = Fp_2x2.mul (m12_a, u_plus_1x2)     rx_f = Fp_2x2.add (rx_e, s0)     ret0 = rx_f \n\n    rx_g = Fp_2x2.mul (s2, u_plus_1x2)     rx_h = Fp_2x2.add (rx_g, m01_a)     ret1 = rx_h \n    ret = [ret2_b, ret1, ret0]\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/CoreVerifyPKInG2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the function core_verify_pk_in_g2_impl that verifies a BLS12-381 public key in G2 using hash_to_curve, Miller loop, Frobenius conjugation, and final exponentiation, returning Bool, and include any necessary types and imports so it type-checks as a standalone Cryptol module."},{"role":"assistant","content":"```cryptol\nmodule implementation::CoreVerifyPKInG2 where\n\nimport Parameters (Fp_12, t_Fp, t_Fp_2, BP', E)\nimport ShortWeierstrassCurve (AffinePoint, affinify)\nimport implementation::PairingImpl (miller_loop_opt)\nimport implementation::HashToG1 (hash_to_curve_opt_impl)\nimport implementation::FinalExp (final_exponentiation_impl)\nimport implementation::PairingImpl (miller_loop_opt_checked)\nimport ExpandMessage\nimport Frobenius (fp12_conjugate)\nimport HashToCurveE1\n\ncore_verify_pk_in_g2_impl : {msg_len,dst_len,aug_len}\n  (fin msg_len, fin dst_len, fin aug_len\n  , Expandable (msg_len+aug_len) dst_len\n  , dst_len <= 255) =>\n  AffinePoint t_Fp_2 -> AffinePoint t_Fp -> [msg_len][8] -> [dst_len][8] -> [aug_len][8] -> Bool\n\ncore_verify_pk_in_g2_impl pk sig msg dst aug = Fp_12.is_equal(gt, Fp_12.field_unit) where\n    Q = affinify E (hash_to_curve_opt_impl (aug#msg, dst))\n    gtPQ = miller_loop_opt_checked Q pk\n    gtSig = fp12_conjugate (miller_loop_opt_checked sig BP')\n    gt = final_exponentiation_impl (Fp_12.mul (gtSig, gtPQ))\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/SerializationP1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol the BLST BLS12-381 G1 point (E1) compressed and uncompressed serialization\/deserialization functions, including uncompress_E1_imp and uncompress_E1_OK, ensuring they correctly reconstruct valid affine points and enforce all RFC-compliant encoding checks and bit constraints."},{"role":"assistant","content":"```cryptol\nmodule implementation::serialization where\n\nimport Parameters (p, E, E', t_Fp, to_Fp, t_Fp_2, Fp, Fp_2)\nimport ShortWeierstrassCurve as EC\nimport rfc8017\nimport Maybe\nimport FieldExtras (F_expt)\nimport BLSFieldExtras\nimport Serialization\nimport implementation::Types\nimport implementation::Field\n\n\/\/ deserialization of compressed representations\n\nuncompress_E1_x: [48][8] -> [384]\nuncompress_E1_x s_string = x where\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n        x = join s_string' \/\/ OS2IP(s_string')\n\nuncompress_E1_x_fp: [48][8] -> t_Fp\nuncompress_E1_x_fp s_string =\n    Fp.mul (fp_abs (vec384_rep (uncompress_E1_x s_string)), montgomery_factor_p)\n\nuncompress_E1_y2: [48][8] -> t_Fp\nuncompress_E1_y2 s_string = y2 where\n        x = Fp.mul ( fp_abs (vec384_rep (uncompress_E1_x s_string))\n               , montgomery_factor_p)     y2 = Fp.add (Fp.mul (Fp.sq x, x), 4)\n\nuncompress_E1_y: [48][8] -> t_Fp\nuncompress_E1_y s_string = sqrt_fp (uncompress_E1_y2 s_string)\n\nuncompress_E1_imp: [48][8] -> Maybe (EC::AffinePoint t_Fp)\nuncompress_E1_imp s_string = ret where\n        m_byte = (s_string@0) && 0xE0     C_bit = m_byte @ 0\n    I_bit = m_byte @ 1\n    S_bit = m_byte @ 2\n    s_string' = [(s_string@0) && 0x1F] # tail s_string\n    x = uncompress_E1_x_fp s_string\n    y2 = uncompress_E1_y2 s_string\n    y = sqrt_fp y2\n    Y_bit = sign_F_p y\n    ret = if C_bit == False then nothing \/\/ Error, from Step 2\n           | I_bit then (if ~S_bit \/\\ s_string' == zero then just (EC::point_O E) else nothing)\n           | uncompress_E1_x s_string >= `p then nothing            | ~ (is_square_fp y2) then nothing            | S_bit == Y_bit then just (x,y)\n          else just (x, Fp.neg y)\n\nuncompress_E1_OK: [48][8] -> EC::AffinePoint t_Fp\nuncompress_E1_OK s_string = if S_bit == Y_bit then (x,y) else (x, Fp.neg y) where\n    x = uncompress_E1_x_fp s_string\n    y = uncompress_E1_y s_string\n    S_bit = (s_string@0)@2\n    Y_bit = sign_F_p y\n\ndeserialize_E1_x: [96][8] -> [384]\ndeserialize_E1_x s_string = x where\n    s_string' = take`{48} ([(s_string@0) && 0x1F] # tail s_string)\n    x = join s_string'\n\ndeserialize_E1_x_fp: [96][8] -> t_Fp\ndeserialize_E1_x_fp s_string =\n    Fp.mul (fp_abs (vec384_rep (deserialize_E1_x s_string)), montgomery_factor_p)\n\ndeserialize_E1_y: [96][8] -> [384]\ndeserialize_E1_y s_string = join (drop`{48} s_string)\n\ndeserialize_E1_y_fp: [96][8] -> t_Fp\ndeserialize_E1_y_fp s_string =\n    Fp.mul (fp_abs (vec384_rep (deserialize_E1_y s_string)), montgomery_factor_p)\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/HashToG1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that implements and verifies the BLS12-381 Hash-to-G1 mapping, including map_to_curve_simple_swu_impl, isogeny_map_to_E1_impl, clear_cofactor_impl, and hash_to_curve_opt_impl, ensuring they satisfy the hash-to-curve standard\u2019s correctness properties."},{"role":"assistant","content":"```cryptol\nmodule implementation::HashToG1 where\n\nimport Parameters (Fp, t_Fp)\nimport ShortWeierstrassCurve (ProjectivePoint)\nimport BLSFieldExtras (sqrt_fp)\nimport ExpandMessage (Expandable)\nimport implementation::CurveOperation (point_dadd, point_add, point_double)\nimport HashToCurveE1\nimport HashToCurveE1Aux as Aux\n\nmap_to_curve_simple_swu_impl : t_Fp -> ProjectivePoint t_Fp\nmap_to_curve_simple_swu_impl u = res where\n  c2 = sqrt (Fp.neg (Fp.mul (Fp.sq Z, Z))) \n    tv1 = Fp.sq u\n  tv3 = Fp.mul (Z, tv1)\n  tv2 = Fp.add (Fp.sq tv3, tv3)\n  x1n = Fp.mul (Fp.add (tv2, Fp.field_unit), B')\n  x2n = Fp.mul(tv3, x1n)\n\n  \/\/ x denumerator\n  xd = Fp.mul(Fp.neg A', tv2)\n  e1 = Fp.is_equal(xd, Fp.field_zero)\n  xd_b = if e1 then Fp.mul(Z, A') else xd\n\n  \/\/ y numerator\n  tv2_a = Fp.sq xd_b\n  gxd = Fp.mul(xd_b, tv2_a)\n  tv2_b = Fp.mul(A',  tv2_a)\n  gx1 = Fp.sq x1n\n  gx1_a = Fp.add(gx1, tv2_b)\n  gx1_b = Fp.mul(gx1_a,  x1n)\n  tv2_c = Fp.mul(B', gxd)\n  gx1_c = Fp.add(gx1_b, tv2_c)\n  tv4 = Fp.sq gxd\n  tv2_d = Fp.mul (gx1_c, gxd)\n  tv4_b = Fp.mul (tv4, tv2_d)\n  y1 = Fp.div (Fp.field_unit, sqrt_fp tv4_b) \/\/ note this is an exponentiation in the spec\n  e2 = Fp.is_equal (Fp.sq (Fp.mul (y1, tv4_b)), tv4_b) \/\/ this appears in the body of recip_sqrt\n  y1_b = Fp.mul(y1, tv2_d)\n\n  y2 = Fp.mul(y1_b, c2)\n  y2_b = Fp.mul(y2, tv1)\n  y2_c = Fp.mul(y2_b, u)\n\n  xn = if e2 then  x1n else x2n\n  y = if e2 then y1_b else y2_c\n\n  y_a = if sgn0(u) != sgn0(y) then Fp.neg y else y\n\n  \/\/ convert to Jacobian coordinates:\n  res = (Fp.mul (xn, xd_b), Fp.mul (y_a, gxd), xd_b)\n\n\/\/ isogeny_map_to_E1\n\nisogeny_map_to_E1_impl: ProjectivePoint t_Fp -> ProjectivePoint t_Fp\nisogeny_map_to_E1_impl (X, Y, Z) = to_jacobian xn xd yn yd where\n  zzs = Zz_powers Z\n  xn = map_fp (kzzs#[last Aux::k1s]) X where\n    kzzs = map_fp_times_Zz`{n=11} Aux::k1s zzs\n  xd = Fp.mul (xs, last zzs) where\n    xs = map_fp ((take`{front=9}kzzs)#[xkzz9]) X\n    xkzz9 = Fp.add (X, last kzzs)\n    kzzs = map_fp_times_Zz`{n=10} Aux::k2s zzs\n  yn = Fp.mul (map_fp (kzzs#[last Aux::k3s]) X, Y) where\n    kzzs = map_fp_times_Zz`{n=15} Aux::k3s zzs\n  yd = Fp.mul (Fp.mul (xs, Z), last zzs) where\n    xs = map_fp ((take`{front=14}kzzs)#[xkzz14]) X\n    xkzz14 = Fp.add (X, last kzzs)\n    kzzs = map_fp_times_Zz`{n=15} Aux::k4s zzs\n\nZz_powers : t_Fp -> [15]t_Fp \/\/ powers of ZZ in descending order\nZz_powers Z = reverse (take`{front=15} zzs) where\n    zzs = [Fp.sq Z, Fp.sq (Fp.sq Z)]\n      # (join`{parts=inf} [[Fp.mul (zi0, zi1), Fp.sq zi1] | zi0 <- zzs | zi1 <- tail zzs]) \/\/ TODO: why is parts=inf necessary here?\n\nmap_fp_times_Zz : {m1,m2,n} (fin n, fin m2, m1 >= n, m2 >= n) => [m1]t_Fp -> [m2]t_Fp -> [n]t_Fp\nmap_fp_times_Zz ks zzs = zipWith (curry Fp.mul) (take`{front=n}ks) (drop`{back=n}zzs)\n\nmap_fp kzzs x = last rs where\n  rs = [last kzzs] # [Fp.add (Fp.mul (ri, x), kzzi) | kzzi <- tail (reverse kzzs) | ri <- rs]\n\n\/\/ NOTE: this does not follow jacobian_to_projective_pair in G2SubGroupCheck.cry\nto_jacobian xn xd yn yd = (X, Y, Z) where\n  Z = Fp.mul (xd, yd)\n  X = Fp.mul (Fp.mul (xn, yd) , Z)\n  Y = Fp.mul (Fp.mul (Fp.sq Z, xd) , yn)\n\n\/\/ clear_cofactor\n\ndbl_n_add: ProjectivePoint t_Fp -> Integer -> ProjectivePoint t_Fp -> ProjectivePoint t_Fp\ndbl_n_add out n p = point_dadd Fp (db n out) p Fp.field_zero True where\n  db: Integer -> ProjectivePoint t_Fp -> ProjectivePoint t_Fp\n  db k x =\n    if k == 1 then point_double Fp x\n    else point_double Fp (db (k-1) x)\n\nclear_cofactor_impl: ProjectivePoint t_Fp -> ProjectivePoint t_Fp\nclear_cofactor_impl p = out where\n  out1 = point_double Fp p\n  out2 = point_add Fp out1 p \/\/ NOTE: this is okay because (point_double p) != p or both are point_O\n  out3 = dbl_n_add out2 2 p\n  out4 = dbl_n_add out3 3 p\n  out5 = dbl_n_add out4 9 p\n  out6 = dbl_n_add out5 32 p\n  out = dbl_n_add out6 16 p\n\n\/\/ hash_to_curve\n\nhash_to_curve_opt_impl: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384\n               ) =>\n               ([msg_len][8], [DST_len][8]) -> ProjectivePoint t_Fp\nhash_to_curve_opt_impl (msg,dst) = map_to_g1_impl u where\n    u = hash_to_field`{count=2} msg dst\n\nmap_to_g1_impl: [2]t_Fp -> ProjectivePoint t_Fp\nmap_to_g1_impl uv = P where\n    Q0 = map_to_curve_simple_swu_impl (uv@0)\n    Q1 = map_to_curve_simple_swu_impl (uv@1)\n    R = point_dadd Fp Q0 Q1 A' False     S = isogeny_map_to_E1_impl R\n    P = clear_cofactor_impl S\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/FinalExp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the BLS12-381 final exponentiation in Fp12, including the function final_exponentiation_impl : P::t_Fp_12 -> P::t_Fp_12 and a property that it maps pairing outputs into the cyclotomic subgroup using is_cyclotomic."},{"role":"assistant","content":"```cryptol\nmodule implementation::FinalExp where\n\nimport FieldExtras\nimport Frobenius\nimport HashToCurveE2Aux\nimport Pairing\nimport Parameters as P\n\nimport implementation::Fp12\n\ntype cyclotomic_exponent_modulus = P::p^^4 - P::p^^2 + 1\n\nint_z = -pos_c1\n\nsmall_final_e_imp : Integer\nsmall_final_e_imp = `P::p^^27 +\n                    2*`P::p^^21*int_z +\n                    `P::p^^19 +\n                    `P::p^^18*int_z +\n                    `P::p^^15*int_z^^2 +\n                    `P::p^^14*int_z +\n                    `P::p^^13*int_z^^2 +\n                    2*`P::p^^13*int_z +\n                    `P::p^^12*int_z^^3 +\n                    2*`P::p^^12*int_z^^2 +\n                    2*`P::p^^8*int_z^^2 +\n                    2*`P::p^^7*int_z^^3 +\n                    `P::p^^7*int_z^^2 +\n                    2*`P::p^^6*int_z^^4 +\n                    `P::p^^6*int_z^^3 +\n                    `P::p^^2*int_z^^3 +\n                    `P::p*int_z^^4 +\n                    int_z^^5 +\n                    3\n\nC_expt: P::t_Fp_12 -> Integer -> P::t_Fp_12\nC_expt b e = if e >= 0 then x else fp12_conjugate x where\n      x = F_expt`{P::t_Fp_12, 16384} P::Fp_12 b (abs e)\n\nfinal_exponentiation_impl: P::t_Fp_12 -> P::t_Fp_12\nfinal_exponentiation_impl x = C_expt (final_exp_frobenius_map x) small_final_e_imp\n\nchain_cyclotomic_sqr_fp12: {n} (fin n, n >= 1) => P::t_Fp_12 -> P::t_Fp_12\nchain_cyclotomic_sqr_fp12 x = acc ! 0 where\n  acc = [x] # [ cyclotomic_sqr_fp12 y | y <- acc | z <- [1..n]]\n\nmul_n_sqr: {n} (fin n, n >= 1) => P::t_Fp_12 -> P::t_Fp_12 -> P::t_Fp_12\nmul_n_sqr ret a = chain_cyclotomic_sqr_fp12`{n} (P::Fp_12.mul (ret, a))\n\nraise_to_z_div_by_2: P::t_Fp_12 -> P::t_Fp_12\nraise_to_z_div_by_2 x = C_expt x (int_z \/ 2)\n\nis_cyclotomic: P::t_Fp_12 -> Bit\nis_cyclotomic x = C_expt x `cyclotomic_exponent_modulus == P::Fp_12.field_unit\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/HashToG2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol the BLS12-381 HashToG2 implementation, including map_to_isogenous_E2_impl, map_to_g2_impl, hash_to_curve_E2_opt_impl, clear_cofactor_E2_impl, and properties _one_of_is_square, _sqrt_align_prop, and _square_same_sign_prop so that they satisfy the IETF hash-to-curve standard."},{"role":"assistant","content":"```cryptol\nmodule implementation::HashToG2 where\n\nimport FieldExtras (F_is_zero, F_sum, F_prod, F_expt)\nimport BLSFieldExtras (sqrt_align_fp2_coeff)\nimport Parameters (Fp_2, t_Fp_2, u)\nimport ShortWeierstrassCurve (ProjectivePoint, point_O, projectify)\nimport ExpandMessage (Expandable)\nimport implementation::CurveOperation (point_dadd, point_add, point_double, point_neg)\nimport HashToCurveE2\nimport HashToCurveE2Aux as Aux\nimport implementation::Psi\n\nmap_to_isogenous_E2_impl : t_Fp_2 -> ProjectivePoint t_Fp_2\nmap_to_isogenous_E2_impl u = res where\n    Zuu = Fp_2.mul (Z, Fp_2.sq u)\n  tv2 = Fp_2.add (Fp_2.sq Zuu, Zuu)\n  x1n = Fp_2.mul (Fp_2.add (tv2, Fp_2.field_unit), B')\n  x2n = Fp_2.mul (Zuu, x1n)\n  xd' = Fp_2.mul (Fp_2.neg A', tv2)\n  xd = if F_is_zero Fp_2 xd' then Fp_2.mul(Z,A') else xd'\n    gxd = Fp_2.mul(xd, Fp_2.sq xd)   gx1 = F_sum Fp_2 [Fp_2.mul(x1n, Fp_2.sq x1n), F_prod Fp_2 [A', x1n, Fp_2.sq xd], Fp_2.mul(B', gxd)]\n  tv4 = F_prod Fp_2 [gx1, gxd, Fp_2.sq gxd]   e2 = is_square tv4\n  y1' = if e2 then Fp_2.div (sqrt tv4, tv4) else (F_expt`{n=758} Fp_2 tv4 `((p^^2-9)\/16))\n  y1 = F_prod Fp_2 [gx1, gxd, y1']\n    tv4_recip_ZZZ = (Fp_2.mul (tv4, recip_ZZZ))\n  y1'_sqrt_ZZZ = Fp_2.mul (y1', F_expt`{n=758} Fp_2 ZZZ `((p^^2+7)\/16))\n  y2' = Fp_2.mul (y1'_sqrt_ZZZ, sqrt_align_fp2_coeff (Fp_2.mul (y1'_sqrt_ZZZ, tv4_recip_ZZZ)) tv4_recip_ZZZ)\n  y2 = F_prod Fp_2 [y2', gx1, gxd, Fp_2.sq u, u]\n    (xn,y') = if e2 then (x1n,y1) else (x2n,y2)\n  y = if sgn0(u) == sgn0(y') then y' else Fp_2.neg y'\n    res = (Fp_2.mul (xn, xd), Fp_2.mul (y, gxd), xd)\n\nrecip_ZZZ = Fp_2.div(Fp_2.field_unit, ZZZ)\nZZZ = Fp_2.mul(Z, Fp_2.sq Z)\n\nmap_to_g2_impl: [2]t_Fp_2 -> ProjectivePoint t_Fp_2\nmap_to_g2_impl uv = P where\n    Q0 = map_to_isogenous_E2_impl (uv@0)\n    Q2 = map_to_isogenous_E2_impl (uv@1)\n    R = point_dadd Fp_2 Q0 Q2 A' False \/\/ This is addition on the isogenous curve E'\n    S = isogeny_map_to_E2_impl R\n    P = clear_cofactor_E2_impl S\n\nhash_to_curve_E2_opt_impl: {msg_len, DST_len}\n               (fin msg_len, fin DST_len\n               , DST_len <= 255\n               , Expandable msg_len DST_len\n               , 8 *( ((lg2 p) + 128) \/^ 8 ) >= 384\n               ) =>\n               ([msg_len][8], [DST_len][8]) -> ProjectivePoint t_Fp_2\nhash_to_curve_E2_opt_impl (msg,dst) = map_to_g2_impl u where\n    u = hash_to_field`{count=2} msg dst\n\nisogeny_map_to_E2_impl: ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\nisogeny_map_to_E2_impl (X, Y, Z) = to_jacobian xn xd yn yd where\n  zzs = Zz_powers Z\n  xn = map_fp2 (kzzs#[last Aux::k1s]) X where\n    kzzs = map_fp2_times_Zz`{n=3} Aux::k1s zzs\n  xd = Fp_2.mul (xs, last zzs) where     xs = map_fp2 ((take`{front=1}kzzs)#[xkzz1]) X\n    xkzz1 = Fp_2.add (X, last kzzs)\n    kzzs = map_fp2_times_Zz`{n=2} Aux::k2s zzs\n  yn = Fp_2.mul (map_fp2 (kzzs#[last Aux::k3s]) X, Y) where\n    kzzs = map_fp2_times_Zz`{n=3} Aux::k3s zzs\n  yd = Fp_2.mul (Fp_2.mul (xs, Z), last zzs) where     xs = map_fp2 ((take`{front=2}kzzs)#[xkzz2]) X\n    xkzz2 = Fp_2.add (X, last kzzs)\n    kzzs = map_fp2_times_Zz`{n=3} Aux::k4s zzs\n\nto_jacobian xn xd yn yd = (X, Y, Z) where\n  Z = Fp_2.mul (xd, yd)\n  X = Fp_2.mul (Fp_2.mul (xn, yd) , Z)\n  Y = Fp_2.mul (Fp_2.mul (Fp_2.sq Z, xd) , yn)\n\nmap_fp2_times_Zz : {m1,m2,n} (fin n, fin m2, m1 >= n, m2 >= n) => [m1]t_Fp_2 -> [m2]t_Fp_2 -> [n]t_Fp_2\nmap_fp2_times_Zz ks zzs = zipWith (curry Fp_2.mul) (take`{front=n}ks) (drop`{back=n}zzs)\n\nmap_fp2 kzzs x = last rs where\n  rs = [last kzzs] # [F.add (F.mul (ri, x), kzzi) | kzzi <- tail (reverse kzzs) | ri <- rs]\n\nZz_powers : t_Fp_2 -> [3]t_Fp_2\nZz_powers Z = reverse [Fp_2.sq Z, Fp_2.sq (Fp_2.sq Z), Fp_2.mul (Fp_2.sq (Fp_2.sq Z), Fp_2.sq Z)]\n\nadd_n_dbl : {n} (fin n, n >= 1) =>\n            ProjectivePoint t_Fp_2 ->\n            ProjectivePoint t_Fp_2 ->\n            ProjectivePoint t_Fp_2\nadd_n_dbl out p = doublings ! 0 where\n  outp = point_dadd Fp_2 out p Fp_2.field_zero True\n  doublings = [outp] # [point_double Fp_2 d | d <- doublings | i <- [1 .. n]]\n\ntimes_minus_z : ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\ntimes_minus_z P = out6 where\n  out1 = point_double Fp_2 P\n  out2 = add_n_dbl`{2} out1 P\n  out3 = add_n_dbl`{3} out2 P\n  out4 = add_n_dbl`{9} out3 P\n  out5 = add_n_dbl`{32} out4 P\n  out6 = add_n_dbl`{16} out5 P\n\npsi_psi_double_impl: ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\npsi_psi_double_impl P = psi_imp (psi_imp (point_double Fp_2 P))\n\nclear_cofactor_E2_impl:  ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\nclear_cofactor_E2_impl P = out4 where\n  out1 = psi_psi_double_impl P\n  t0_1 = point_neg Fp_2 P\n  t1   = psi_imp t0_1\n  out2 = point_dadd Fp_2 out1 t0_1 Fp_2.field_zero True\n  out3 = point_dadd Fp_2 out2 t1 Fp_2.field_zero True\n  t0_2 = point_dadd Fp_2 (times_minus_z P) P Fp_2.field_zero True\n  t0_3 = point_dadd Fp_2 t0_2 t1 Fp_2.field_zero True\n  t1'  = times_minus_z t0_3\n  out4 = point_dadd Fp_2 out3 t1' Fp_2.field_zero True\n\n_map_to_isogenous_E2_impl : t_Fp_2 -> ProjectivePoint t_Fp_2\n_map_to_isogenous_E2_impl u = res where\n    Zuu = Fp_2.mul (Z, Fp_2.sq u)\n  tv2 = Fp_2.add (Fp_2.sq Zuu, Zuu)\n  x1n = Fp_2.mul (Fp_2.add (tv2, Fp_2.field_unit), B')\n  x2n = Fp_2.mul (Zuu, x1n)\n  xd' = Fp_2.mul (Fp_2.neg A', tv2)\n  xd = if F_is_zero Fp_2 xd' then Fp_2.mul(Z,A') else xd'\n    gxd = Fp_2.mul(xd, Fp_2.sq xd)   gx1 = F_sum Fp_2 [Fp_2.mul(x1n, Fp_2.sq x1n), F_prod Fp_2 [A', x1n, Fp_2.sq xd], Fp_2.mul(B', gxd)]\n  tv4 = F_prod Fp_2 [gx1, gxd, Fp_2.sq gxd]   e2 = is_square tv4\n  xn = if e2 then x1n else x2n\n  y' = if e2\n        then F_prod Fp_2 [gx1, gxd, Fp_2.div (sqrt tv4, tv4)]\n        else F_prod Fp_2 [sqrt (Fp_2.div(ZZZ, tv4)), gx1, gxd, Fp_2.sq u, u]\n  y = if sgn0(u) == sgn0(y') then y' else Fp_2.neg y'\n    res = (Fp_2.mul (xn, xd), Fp_2.mul (y, gxd), xd)\n\n_one_of_is_square u = Fp_2.is_val u \/\\ ~(is_square x) ==> is_square b where\n  b = Fp_2.mul (x, recip_ZZZ)\n  x = F_prod Fp_2 [gx1, gxd, Fp_2.sq gxd]\n  gxd = Fp_2.mul(xd, Fp_2.sq xd)   gx1 = F_sum Fp_2 [Fp_2.mul(x1n, Fp_2.sq x1n), F_prod Fp_2 [A', x1n, Fp_2.sq xd], Fp_2.mul(B', gxd)]\n  Zuu = Fp_2.mul (Z, Fp_2.sq u)\n  tv2 = Fp_2.add (Fp_2.sq Zuu, Zuu)\n  x1n = Fp_2.mul (Fp_2.add (tv2, Fp_2.field_unit), B')\n  xd' = Fp_2.mul (Fp_2.neg A', tv2)\n  xd = if F_is_zero Fp_2 xd' then Fp_2.mul(Z,A') else xd'\n\n_sqrt_align_prop x' = Fp_2.is_val x \/\\ is_square b ==>\n  Fp_2.sq (sqrt_align a ab b) == Fp_2.sq (Fp_2.div (sqrt b, b)) where\n    a = Fp_2.mul (F_expt`{n=758} Fp_2 x `((p^^2-9)\/16), F_expt`{n=758} Fp_2 ZZZ `((p^^2+7)\/16))\n    b = Fp_2.mul (x, recip_ZZZ)\n    ab = Fp_2.mul (a,b)\n    sqrt_align x y z = Fp_2.mul (x, sqrt_align_fp2_coeff y z)\n    recip_ZZZ = Fp_2.div (Fp_2.field_unit, ZZZ)\n    x = Fp_2.normalize x'\n\n_square_same_sign_prop x y u = Fp_2.sq x == Fp_2.sq y ==>\n  (if sgn0(x) == sgn0(u) then x else Fp_2.neg x) == (if sgn0(y) == sgn0(u) then y else Fp_2.neg y)\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/Field.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module that defines these Montgomery representation conversion functions and field representation types for Fp, Fp2, Fp6, and Fp12, along with properties proving that abs\/rep round-trip correctly and that each *_invariant predicate holds after normalization."},{"role":"assistant","content":"```cryptol\nmodule implementation::Field where\n\nimport Common::Field\nimport implementation::Types\nimport Parameters ( p, Fp, t_Fp, to_Fp, from_Fp, t_Fp_2, Fp_2, t_Fp_6, Fp_6, t_Fp_12, Fp_12)\n\nmontgomery_factor_p: t_Fp\nmontgomery_factor_p = Fp.mul (2^^4, 2^^380) \nmontgomery_factor_inverse_p: t_Fp\nmontgomery_factor_inverse_p = Fp.div(Fp.field_unit, montgomery_factor_p)\n\nfrom_mont: t_Fp -> t_Fp\nfrom_mont x = Fp.mul (x, montgomery_factor_inverse_p)\n\nto_mont: t_Fp -> t_Fp\nto_mont x = Fp.mul(x, montgomery_factor_p)\n\ntype Fp_rep_t = Vec384\n\nfp_abs: Fp_rep_t -> t_Fp\nfp_abs v = from_mont (to_Fp (vec384_abs v))\n\nfp_rep: t_Fp -> Fp_rep_t\nfp_rep x = vec384_rep (from_Fp (to_mont x))\n\nfp_invariant: Fp_rep_t -> Bool\nfp_invariant v = vec384_abs v < `p \nfp_normalize: Fp_rep_t -> Fp_rep_t\nfp_normalize x = vec384_rep (from_Fp (Fp.normalize (to_Fp (vec384_abs x))))\n\ntype Fp_2_rep_t = [2]Fp_rep_t\n\nfp2_abs: Fp_2_rep_t -> t_Fp_2\nfp2_abs [a,b] = [fp_abs b, fp_abs a]\n\nfp2_rep: t_Fp_2 -> Fp_2_rep_t\nfp2_rep [a,b] = [fp_rep b, fp_rep a]\n\nfp2_invariant: Fp_2_rep_t -> Bool\nfp2_invariant v = all fp_invariant v\n\nfp2_normalize: Fp_2_rep_t -> Fp_2_rep_t\nfp2_normalize [x,y] = [fp_normalize x, fp_normalize y]\n\ntype Fpx2_rep_t = Vec768\ntype shifted_p = p * 2^^384\n\ntype t_Fpx2 = Integer\n\nfpx2_abs: Fpx2_rep_t -> t_Fpx2\nfpx2_abs x = toInteger (vec768_abs x)\n\nfpx2_rep: t_Fpx2 -> Fpx2_rep_t\nfpx2_rep x = vec768_rep (fromInteger x)\n\nfpx2_invariant v = (vec768_abs v) < `shifted_p\n\ntype Fp_2x2_rep_t = [2]Vec768\ntype t_Fp_2x2 = [2]t_Fpx2\n\nfp2x2_abs: Fp_2x2_rep_t -> t_Fp_2x2\nfp2x2_abs [x, y] = [fpx2_abs y, fpx2_abs x]\n\nfp2x2_rep: t_Fp_2x2 -> Fp_2x2_rep_t\nfp2x2_rep [x, y] = [fpx2_rep y, fpx2_rep x]\n\nfp2x2_invariant [x, y] = fpx2_invariant x \/\\ fpx2_invariant y\n\ntype Fp_6_rep_t = [3]Fp_2_rep_t\n\nfp6_abs [x,y,z] = [fp2_abs z, fp2_abs y, fp2_abs x]\nfp6_rep [x,y,z] = [fp2_rep z, fp2_rep y, fp2_rep x]\nfp6_invariant [x,y,z] = fp2_invariant x \/\\ fp2_invariant y \/\\ fp2_invariant z\nfp6_normalize [x,y,z] = [fp2_normalize x, fp2_normalize y, fp2_normalize z]\n\ntype t_Fp_6x2 = [3]t_Fp_2x2\nfp6x2_abs [x,y,z] = [fp2x2_abs z, fp2x2_abs y, fp2x2_abs x]\nfp6x2_rep [x,y,z] = [fp2x2_rep z, fp2x2_rep y, fp2x2_rep x]\nfp6x2_invariant [x,y,z] = fp2x2_invariant x \/\\ fp2x2_invariant y \/\\ fp2x2_invariant z\n\ntype Fp_12_rep_t = [2]Fp_6_rep_t\n\nfp12_abs: Fp_12_rep_t -> t_Fp_12\nfp12_abs [a,b] = [fp6_abs b, fp6_abs a]\n\nfp12_rep: t_Fp_12 -> Fp_12_rep_t\nfp12_rep [a,b] = [fp6_rep b, fp6_rep a]\n\nfp12_invariant: Fp_12_rep_t -> Bool\nfp12_invariant [x,y] = fp6_invariant x \/\\ fp6_invariant y\n\nfp12_normalize: Fp_12_rep_t -> Fp_12_rep_t\nfp12_normalize [x,y] = [fp6_normalize x, fp6_normalize y]\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/x86.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that verify each x86 Montgomery arithmetic implementation in module implementation::x86 (e.g., mulx_mont_384x, sqrx_mont_384x, mulx_382x, sqrx_382x, redcx_mont_384, fromx_mont_384, sgn0x_pty_mont_384, mulx_mont_sparse_256, redcx_mont_256, fromx_mont_256) is equivalent to its corresponding mathematical specification."},{"role":"assistant","content":"```cryptol\nmodule implementation::x86 where\n\nimport implementation::Types\nimport implementation::x86::helpers\n\nmulx_mont_384x\n  : Vec768   -> Vec768   -> Vec384    -> [64]   -> Vec768 mulx_mont_384x a b m n0 = result\n  where\n    t0 = __mulx_384 (take a) (take b)\n    t1 = __mulx_384 (drop a) (drop b)\n    t2 = __mulx_384 (__add_mod_384 (take b) (drop b) m) (__add_mod_384 (take a) (drop a) m)\n    t2' = __sub_mod_384x384 (__sub_mod_384x384 t2 t0 m) t1 m\n    t0' = __sub_mod_384x384 t0 t1 m\n    ret_re = redcx_mont_384 t0' m n0\n    ret_im = redcx_mont_384 t2' m n0\n    result = ret_re # ret_im\n\nsqrx_mont_384x\n  : Vec768   -> Vec384    -> [64]   -> Vec768 sqrx_mont_384x a m n0 = result\n  where\n    t0 = __add_mod_384 (take a) (drop a) m\n    t1 = __sub_mod_384 (take a) (drop a) m\n    tmp = mulx_mont_384 (take a) (drop a) m n0\n    ret_im = __add_mod_384 tmp tmp m\n    ret_re = mulx_mont_384 t0 t1 m n0\n    result = ret_re # ret_im\n\nmulx_382x\n  : Vec768   -> Vec768   -> Vec384    -> [2]Vec768 mulx_382x a b m = result\n  where\n    a_re = take a\n    a_im = drop a\n    (t0_cf_0, t0_0) = add (a_re @ 0) (a_im @ 0)\n    (t0_cf_1, t0_1) = adc (a_re @ 1) (a_im @ 1) t0_cf_0\n    (t0_cf_2, t0_2) = adc (a_re @ 2) (a_im @ 2) t0_cf_1\n    (t0_cf_3, t0_3) = adc (a_re @ 3) (a_im @ 3) t0_cf_2\n    (t0_cf_4, t0_4) = adc (a_re @ 4) (a_im @ 4) t0_cf_3\n    (_, t0_5) = adc (a_re @ 5) (a_im @ 5) t0_cf_4\n    b_re = take b\n    b_im = drop b\n    (t1_cf_0, t1_0) = add (b_re @ 0) (b_im @ 0)\n    (t1_cf_1, t1_1) = adc (b_re @ 1) (b_im @ 1) t1_cf_0\n    (t1_cf_2, t1_2) = adc (b_re @ 2) (b_im @ 2) t1_cf_1\n    (t1_cf_3, t1_3) = adc (b_re @ 3) (b_im @ 3) t1_cf_2\n    (t1_cf_4, t1_4) = adc (b_re @ 4) (b_im @ 4) t1_cf_3\n    (_, t1_5) = adc (b_re @ 5) (b_im @ 5) t1_cf_4\n    tmp_im_0 = __mulx_384 [t0_0, t0_1, t0_2, t0_3, t0_4, t0_5] [t1_0, t1_1, t1_2, t1_3, t1_4, t1_5]\n    tmp_re = __mulx_384 a_re b_re\n    tx = __mulx_384 a_im b_im\n    tmp_im_1 = __sub_mod_384x384 tmp_im_0 tx m\n    ret_im = __sub_mod_384x384 tmp_im_1 tmp_re m\n    ret_re = __sub_mod_384x384 tmp_re tx m\n    result = [ret_re, ret_im]\n\nsqrx_382x\n  : Vec768   -> Vec384    -> [2]Vec768 sqrx_382x a m = result\n  where\n    a_re = take a\n    a_im = drop a\n    (t0_cf_0, t0_0) = add (a_re @ 0) (a_im @ 0)\n    (t0_cf_1, t0_1) = adc (a_re @ 1) (a_im @ 1) t0_cf_0\n    (t0_cf_2, t0_2) = adc (a_re @ 2) (a_im @ 2) t0_cf_1\n    (t0_cf_3, t0_3) = adc (a_re @ 3) (a_im @ 3) t0_cf_2\n    (t0_cf_4, t0_4) = adc (a_re @ 4) (a_im @ 4) t0_cf_3\n    (_, t0_5) = adc (a_re @ 5) (a_im @ 5) t0_cf_4\n    t1 = __sub_mod_384 a_re a_im m\n    ret_re = __mulx_384 t1 [t0_0, t0_1, t0_2, t0_3, t0_4, t0_5]\n    tmp_im = __mulx_384 a_re a_im\n    (ret_im_cf_0, ret_im_0) = add (tmp_im @ 0) (tmp_im @ 0)\n    (ret_im_cf_1, ret_im_1) = adc (tmp_im @ 1) (tmp_im @ 1) ret_im_cf_0\n    (ret_im_cf_2, ret_im_2) = adc (tmp_im @ 2) (tmp_im @ 2) ret_im_cf_1\n    (ret_im_cf_3, ret_im_3) = adc (tmp_im @ 3) (tmp_im @ 3) ret_im_cf_2\n    (ret_im_cf_4, ret_im_4) = adc (tmp_im @ 4) (tmp_im @ 4) ret_im_cf_3\n    (ret_im_cf_5, ret_im_5) = adc (tmp_im @ 5) (tmp_im @ 5) ret_im_cf_4\n    (ret_im_cf_6, ret_im_6) = adc (tmp_im @ 6) (tmp_im @ 6) ret_im_cf_5\n    (ret_im_cf_7, ret_im_7) = adc (tmp_im @ 7) (tmp_im @ 7) ret_im_cf_6\n    (ret_im_cf_8, ret_im_8) = adc (tmp_im @ 8) (tmp_im @ 8) ret_im_cf_7\n    (ret_im_cf_9, ret_im_9) = adc (tmp_im @ 9) (tmp_im @ 9) ret_im_cf_8\n    (ret_im_cf_10, ret_im_10) = adc (tmp_im @ 10) (tmp_im @ 10) ret_im_cf_9\n    (_, ret_im_11) = adc (tmp_im @ 11) (tmp_im @ 11) ret_im_cf_10\n    ret_im = [ret_im_0, ret_im_1, ret_im_2, ret_im_3, ret_im_4, ret_im_5, ret_im_6, ret_im_7, ret_im_8, ret_im_9, ret_im_10, ret_im_11]\n    result = [ret_re, ret_im]\n\nredcx_mont_384\n  : Vec768   -> Vec384   -> [64]   -> Vec384 redcx_mont_384 a m n0 = result\n  where\n    acc = __mulx_by_1_mont_384 (take a) m n0\n    result = __redc_tail_mont_384 acc a m\nfromx_mont_384\n  : Vec384   -> Vec384   -> [64]   -> Vec384 fromx_mont_384 a m n0 = result\n  where\n\n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0, r14_0, r15_0] = __mulx_by_1_mont_384 a m n0\n    rax_1 = r14_0\n    rcx_1 = r15_0\n    rdx_1 = r8_0\n    rbp_1 = r9_0\n    (cf_2, r14_2) = sub r14_0 (m @ 0)\n    (cf_3, r15_3) = sbb r15_0 (m @ 1) cf_2\n    r13_4 = r10_0\n    (cf_5, r8_5) = sbb r8_0 (m @ 2) cf_3\n    (cf_6, r9_6) = sbb r9_0 (m @ 3) cf_5\n    (cf_7, r10_7) = sbb r10_0 (m @ 4) cf_6\n    rsi_8 = r11_0\n    (cf_9, r11_9) = sbb r11_0 (m @ 5) cf_7\n    r14_10 = cmovb r14_2 rax_1 cf_9\n    r15_10 = cmovb r15_3 rcx_1 cf_9\n    r8_10 = cmovb r8_5 rdx_1 cf_9\n    r9_10 = cmovb r9_6 rbp_1 cf_9\n    r10_10 = cmovb r10_7 r13_4 cf_9\n    r11_10 = cmovb r11_9 rsi_8 cf_9\n    result = [r14_10, r15_10, r8_10, r9_10, r10_10, r11_10]\n\nsgn0x_pty_mont_384\n  : Vec384   -> Vec384   -> [64]   -> [64]\nsgn0x_pty_mont_384 a p n0 = result\n  where\n\n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0, r14_0, r15_0] = __mulx_by_1_mont_384 a p n0\n    rax_1 = 0\n    r13_2 = r14_0\n    (cf_3, r14_3) = adcx r14_0 r14_0 False\n    (cf_4, r15_4) = adcx r15_0 r15_0 cf_3\n    (cf_5, r8_5) = adcx r8_0 r8_0 cf_4\n    (cf_6, r9_6) = adcx r9_0 r9_0 cf_5\n    (cf_7, r10_7) = adcx r10_0 r10_0 cf_6\n    (cf_8, r11_8) = adcx r11_0 r11_0 cf_7\n    (_, rax_9) = adcx rax_1 0 cf_8\n    (cf_10, r14_10) = sub r14_3 (p @ 0)\n    (cf_11, r15_11) = sbb r15_4 (p @ 1) cf_10\n    (cf_12, r8_12) = sbb r8_5 (p @ 2) cf_11\n    (cf_13, r9_13) = sbb r9_6 (p @ 3) cf_12\n    (cf_14, r10_14) = sbb r10_7 (p @ 4) cf_13\n    (cf_15, r11_15) = sbb r11_8 (p @ 5) cf_14\n    (_, rax_16) = sbb rax_9 0 cf_15\n    rax_17 = ~rax_16\n    r13_18 = r13_2 && (zext 0x1 : [64])\n    rax_18 = rax_17 && (zext 0x2 : [64])\n    result = rax_18 || r13_18\n\nsgn0x_pty_mont_384x\n  : Vec768   -> Vec384   -> [64]   -> [64]\nsgn0x_pty_mont_384x a m n0 = result\n  where\n    [r8_4, r9_4, r10_4, r11_4, r12_4, r13_4, r14_4, r15_4] = __mulx_by_1_mont_384 (drop a) m n0\n    r12_5 = r14_4\n    r14_6 = r14_4 || r15_4\n    r14_7 = r14_6 || r8_4\n    r14_8 = r14_7 || r9_4\n    r14_9 = r14_8 || r10_4\n    r14_10 = r14_9 || r11_4\n    rdi_12 = 0\n    r13_13 = r12_5\n    (cf_14, r12_14) = add r12_5 r12_5\n    (cf_15, r15_15) = adc r15_4 r15_4 cf_14\n    (cf_16, r8_16) = adc r8_4 r8_4 cf_15\n    (cf_17, r9_17) = adc r9_4 r9_4 cf_16\n    (cf_18, r10_18) = adc r10_4 r10_4 cf_17\n    (cf_19, r11_19) = adc r11_4 r11_4 cf_18\n    (cf_20, rdi_20) = adc rdi_12 0 cf_19\n    (cf_21, r12_21) = sub r12_14 (m @ 0)\n    (cf_22, r15_22) = sbb r15_15 (m @ 1) cf_21\n    (cf_23, r8_23) = sbb r8_16 (m @ 2) cf_22\n    (cf_24, r9_24) = sbb r9_17 (m @ 3) cf_23\n    (cf_25, r10_25) = sbb r10_18 (m @ 4) cf_24\n    (cf_26, r11_26) = sbb r11_19 (m @ 5) cf_25\n    (cf_27, rdi_27) = sbb rdi_20 0 cf_26\n    stack0 = r14_10\n    rdi_29 = ~rdi_27\n    r13_30 = r13_13 && zext 0x1\n    rdi_31 = rdi_29 && zext 0x2\n    rdi_32 = rdi_31 || r13_30\n    [r8_33, r9_33, r10_33, r11_33, r12_33, r13_33, r14_33, r15_33] = __mulx_by_1_mont_384 (take a) m n0\n    r12_34 = r14_33\n    r14_35 = r14_33 || r15_33\n    r14_36 = r14_35 || r8_33\n    r14_37 = r14_36 || r9_33\n    r14_38 = r14_37 || r10_33\n    r14_39 = r14_38 || r11_33\n    rax_40 = 0\n    r13_41 = r12_34\n    (cf_42, r12_42) = add r12_34 r12_34\n    (cf_43, r15_43) = adc r15_33 r15_33 cf_42\n    (cf_44, r8_44) = adc r8_33 r8_33 cf_43\n    (cf_45, r9_45) = adc r9_33 r9_33 cf_44\n    (cf_46, r10_46) = adc r10_33 r10_33 cf_45\n    (cf_47, r11_47) = adc r11_33 r11_33 cf_46\n    (cf_48, rax_48) = adc rax_40 0 cf_47\n    (cf_49, r12_49) = sub r12_42 (m @ 0)\n    (cf_50, r15_50) = sbb r15_43 (m @ 1) cf_49\n    (cf_51, r8_51) = sbb r8_44 (m @ 2) cf_50\n    (cf_52, r9_52) = sbb r9_45 (m @ 3) cf_51\n    (cf_53, r10_53) = sbb r10_46 (m @ 4) cf_52\n    (cf_54, r11_54) = sbb r11_47 (m @ 5) cf_53\n    (cf_55, rax_55) = sbb rax_48 0 cf_54\n    r12_56 = stack0\n    rax_57 = ~rax_55\n    zf_58 = r14_39 == 0\n    r13_59 = cmove r13_41 rdi_32 zf_58\n    zf_60 = r12_56 == 0\n    rax_61 = cmovne rax_57 rdi_32 zf_60\n    r13_62 = r13_59 && zext 0x1\n    rax_63 = rax_61 && zext 0x2\n    rax_64 = rax_63 || r13_62\n    result = rax_64\n\nmulx_mont_384\n  : Vec384   -> Vec384   -> Vec384   -> [64]   -> Vec384 mulx_mont_384 a b m n0 = result\n  where\n    (r9, r8) = mulx (a @ 0) (b @ 0)\n    acc =\n      [ r8       , r9       , undefined       , undefined       , a @ 3       , undefined       , a @ 0       , a @ 1       , a @ 2       ]\n    lo = a @ 4\n    hi = a @ 5\n    result = __mulx_mont_384 acc (b @ 0) n0 lo hi a b m\n\nsqrx_n_mul_mont_383\n  : Vec384   -> Integer    -> Vec384   -> [64]   -> Vec384   -> Vec384 sqrx_n_mul_mont_383 a count m n0 b = result\n  where\n    mulx_mont_383_nonred x y = __mulx_mont_383_nonred [r8, r9, undefined, undefined, x @ 3, undefined, x @ 0, x @ 1, x @ 2] (y @ 0) n0 (x @ 4) (x @ 5) x y m\n      where (r9, r8) = mulx (x @ 0) (y @ 0)\n    loop counter acc =\n      if counter == 0\n      then acc\n      else loop (counter - 1) (mulx_mont_383_nonred acc acc)\n    result = mulx_mont_384 (loop count a) b m n0\n\nsqrx_mont_382x\n  : Vec768   -> Vec384    -> [64]   -> Vec768 sqrx_mont_382x a m n0 = result\n  where\n    mulx_mont_383_nonred x y = __mulx_mont_383_nonred [r8, r9, undefined, undefined, x @ 3, undefined, x @ 0, x @ 1, x @ 2] (y @ 0) n0 (x @ 4) (x @ 5) x y m\n      where (r9, r8) = mulx (x @ 0) (y @ 0)\n    a_re = take a\n    a_im = drop a\n    (t0_cf_0, t0_0) = add (a_re @ 0) (a_im @ 0)\n    (t0_cf_1, t0_1) = adc (a_re @ 1) (a_im @ 1) t0_cf_0\n    (t0_cf_2, t0_2) = adc (a_re @ 2) (a_im @ 2) t0_cf_1\n    (t0_cf_3, t0_3) = adc (a_re @ 3) (a_im @ 3) t0_cf_2\n    (t0_cf_4, t0_4) = adc (a_re @ 4) (a_im @ 4) t0_cf_3\n    (_, t0_5) = adc (a_re @ 5) (a_im @ 5) t0_cf_4\n    t0 = [t0_0, t0_1, t0_2, t0_3, t0_4, t0_5]\n    (t1_cf_0, t1_0) = sub (a_re @ 0) (a_im @ 0)\n    (t1_cf_1, t1_1) = sbb (a_re @ 1) (a_im @ 1) t1_cf_0\n    (t1_cf_2, t1_2) = sbb (a_re @ 2) (a_im @ 2) t1_cf_1\n    (t1_cf_3, t1_3) = sbb (a_re @ 3) (a_im @ 3) t1_cf_2\n    (t1_cf_4, t1_4) = sbb (a_re @ 4) (a_im @ 4) t1_cf_3\n    (gt, t1_5) = sbb (a_re @ 5) (a_im @ 5) t1_cf_4\n    t1 = [t1_0, t1_1, t1_2, t1_3, t1_4, t1_5]\n    tmp_im = mulx_mont_383_nonred a_re a_im\n    (ret_im_cf_0, ret_im_0) = add (tmp_im @ 0) (tmp_im @ 0)\n    (ret_im_cf_1, ret_im_1) = adc (tmp_im @ 1) (tmp_im @ 1) ret_im_cf_0\n    (ret_im_cf_2, ret_im_2) = adc (tmp_im @ 2) (tmp_im @ 2) ret_im_cf_1\n    (ret_im_cf_3, ret_im_3) = adc (tmp_im @ 3) (tmp_im @ 3) ret_im_cf_2\n    (ret_im_cf_4, ret_im_4) = adc (tmp_im @ 4) (tmp_im @ 4) ret_im_cf_3\n    (_, ret_im_5) = adc (tmp_im @ 5) (tmp_im @ 5) ret_im_cf_4\n    ret_im = [ret_im_0, ret_im_1, ret_im_2, ret_im_3, ret_im_4, ret_im_5]\n    tmp_re = mulx_mont_383_nonred t0 t1\n    mask = if gt then -1 else 0\n    t0_mask = [mask && (t0 @ 0), mask && (t0 @ 1), mask && (t0 @ 2), mask && (t0 @ 3), mask && (t0 @ 4), mask && (t0 @ 5)]\n    ret_re = __sub_mod_384 tmp_re t0_mask m\n    result = ret_re # ret_im\n\nmulx_mont_sparse_256\n  : Vec256   -> Vec256   -> Vec256   -> [64]   -> Vec256 mulx_mont_sparse_256 a b m n0 = result\n  where\n    (r11, rax) = mulx (a @ 0) (b @ 0)\n    acc =\n      [ undefined       , r11       , undefined       , undefined       , a @ 0       , a @ 1       , rax       ]\n    lo = a @ 2\n    hi = a @ 3\n    result = __mulx_mont_sparse_256 acc (b @ 0) n0 lo hi a b m\n\nredcx_mont_256\n  : Vec512   -> Vec256   -> [64]   -> Vec256 redcx_mont_256 a m n0 = result\n  where\n    [r10_0, r11_0, r12_0, r13_0, r14_0, r15_0] = __mulx_by_1_mont_256 (take a) m n0\n    (high_cf_0, high_0) = add r14_0 (a @ 4)\n    (high_cf_1, high_1) = adc r15_0 (a @ 5) high_cf_0\n    (high_cf_2, high_2) = adc r10_0 (a @ 6) high_cf_1\n    (high_cf_3, high_3) = adc r11_0 (a @ 7) high_cf_2\n    mask = if high_cf_3 then -1 else 0\n    (diff_cf_0, diff_0) = sub high_0 (m @ 0)\n    (diff_cf_1, diff_1) = sbb high_1 (m @ 1) diff_cf_0\n    (diff_cf_2, diff_2) = sbb high_2 (m @ 2) diff_cf_1\n    (diff_cf_3, diff_3) = sbb high_3 (m @ 3) diff_cf_2\n    (gt, _) = sbb mask 0 diff_cf_3\n    result0 = cmovae high_0 diff_0 gt\n    result1 = cmovae high_1 diff_1 gt\n    result2 = cmovae high_2 diff_2 gt\n    result3 = cmovae high_3 diff_3 gt\n    result = [result0, result1, result2, result3]\n\nfromx_mont_256\n  : Vec256   -> Vec256   -> [64]   -> Vec256 fromx_mont_256 a m n0 = result\n  where\n    [r10_0, r11_0, r12_0, r13_0, r14_0, r15_0] = __mulx_by_1_mont_256 a m n0\n    (diff_cf_0, diff_0) = sub r14_0 (m @ 0)\n    (diff_cf_1, diff_1) = sbb r15_0 (m @ 1) diff_cf_0\n    (diff_cf_2, diff_2) = sbb r10_0 (m @ 2) diff_cf_1\n    (diff_cf_3, diff_3) = sbb r11_0 (m @ 3) diff_cf_2\n    result0 = cmovae r14_0 diff_0 diff_cf_3\n    result1 = cmovae r15_0 diff_1 diff_cf_3\n    result2 = cmovae r10_0 diff_2 diff_cf_3\n    result3 = cmovae r11_0 diff_3 diff_cf_3\n    result = [result0, result1, result2, result3]\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/PairingImpl.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol the optimized Miller loop implementation for the BLS12 pairing, including functions miller_loop_opt, miller_loop_imp, and miller_loop_n_1_imp, and prove that the optimized versions are functionally equivalent to the reference Miller loop over all valid input points."},{"role":"assistant","content":"```cryptol\nmodule implementation::PairingImpl where\n\nimport Parameters (t_Fp, t_Fp_2, t_Fp_6, t_Fp_12, Fp, Fp_2, Fp_12, Fp_to_Fp_2, E, E')\nimport Parameters as P\nimport ShortWeierstrassCurve as EC\nimport Common::Field (FieldRep)\nimport FieldExtras\nimport Frobenius (fp12_conjugate)\n\/\/ import Pairing\nimport implementation::Types (Size_t)\nimport implementation::Fp12 (fp6_to_fp12_xy00z0)\nimport implementation::CurveOperation (point_double, point_add_affine, normalize_point, normalize_affine_point)\n\n\/\/ Step (1)\n\n\/\/ Note: the layout of Fp_12 over Fp_2 is\n\/\/ [[a,c,e],[b,d,f]] represents a*w^5 + b*w^4 + c*w^3 + d*w^2 + e*w + f\n\n\/**\n * Take a point on E\/F_p to a point on E'\/F_p^12\n * This applies the sextic twist to the coordinates:\n * (x, y) :-> (w^2 x, w^3 y)\n *\/\nphi_3: EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_12\nphi_3 (x,y) = ([[z,z,z],[z,x',z]], [[z,y',z],[z,z,z]]) where\n   z = P::Fp_2.field_zero\n   x' = P::Fp_to_Fp_2 x \/\/ == [0,x]\n   y' = P::Fp_to_Fp_2 y \n\nphi_4: EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp_12\nphi_4 (x,y) = (x',y') where\n    x' = P::Fp_2_to_Fp_12 x\n    y' = P::Fp_2_to_Fp_12 y\n\nline_add_opt: EC::ProjectivePoint t_Fp_2 -> EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nline_add_opt (xT, yT, zT) (xQ, yQ) (xP, yP) = ret where\n    xP' = Fp_to_Fp_2 xP\n    yP' = Fp_to_Fp_2 yP\n    l0 = Fp_2.sub (Fp_2.mul (yQ, Fp_2.mul (xT, zT)), Fp_2.mul (xQ, yT))     l1 = Fp_2.mul (Fp_2.sub (yT, Fp_2.mul (yQ, zT3)), xP') \/\/ xP (yT - yQ zT^3)\n    l2 = Fp_2.mul (Fp_2.sub (Fp_2.mul (xQ, zT3), Fp_2.mul (xT, zT)), yP')     zT3 = Fp_2.mul (zT, Fp_2.sq zT)     ret = fp6_to_fp12_xy00z0 [ mul_by_4 Fp_2 l2                               , mul_by_4 Fp_2 l1                               , mul_by_4 Fp_2 l0                              ]\n\nline_double_opt: EC::ProjectivePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nline_double_opt (xT,yT,zT) (xP, yP) = ret where\n    xP' = P::Fp_to_Fp_2 xP\n    yP' = P::Fp_to_Fp_2 yP\n    l0 = Fp_2.sub (mul_by_3 Fp_2 (cubed xT), mul_by_2 Fp_2 (Fp_2.sq yT))     l1 = Fp_2.neg (mul_by_3 Fp_2 (Fp_2.mul (Fp_2.sq xT, Fp_2.mul (Fp_2.sq zT, xP')))) \/\/ -3 xP xT^2 zT^2\n    l2 = Fp_2.mul (mul_by_2 Fp_2 (Fp_2.mul (yT, cubed zT)), yP') \n    ret = fp6_to_fp12_xy00z0 [ mul_by_2 Fp_2 l2                              , mul_by_2 Fp_2 l1                              , mul_by_2 Fp_2 l0                              ]\n    cubed x = Fp_2.mul (x, Fp_2.sq x)\n\nmiller_step_opt:  EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_2\n                    -> (t_Fp_12, EC::ProjectivePoint t_Fp_2)\n                    -> Bit\n                    -> (t_Fp_12, EC::ProjectivePoint t_Fp_2)\nmiller_step_opt P Q (f, T) ci = (f', T') where\n    f0 = Fp_12.mul (Fp_12.sq f, line_double_opt T P)\n    T0 = point_double Fp_2 T\n    (f', T') = if ci\n               then (Fp_12.mul (f0, line_add_opt T0 Q P),\n                     point_add_affine_alt Fp_2 T0 Q)                else (f0, T0)\n\nmiller_loop_opt: EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_2 -> t_Fp_12\nmiller_loop_opt P Q =  fp12_conjugate last_f where\n   (last_f, _) = f_Ts ! 0\n   f_Ts = [(Fp_12.field_unit, EC::projectify P::E' Q)] #\n          [ miller_step_opt P Q fT ci | fT <- f_Ts | ci <- tail negative_t]\n   \/\/ t = -2^63 - 2^62 - 2^60 - 2^57 - 2^48 - 2^16\n   negative_t:[64]\n   negative_t = <| x^^63 + x^^62 + x^^60 + x^^57 + x^^48 + x^^16 |>\n\nmiller_loop_opt_checked:  EC::AffinePoint t_Fp -> EC::AffinePoint t_Fp_2 -> t_Fp_12\nmiller_loop_opt_checked P Q =\n    if EC::is_point_O E' Q  \\\/ EC::is_point_O E P\n    then Fp_12.field_unit\n    else miller_loop_opt P Q\n\npoint_add_affine_alt: {t} FieldRep t -> EC::ProjectivePoint t -> EC::AffinePoint t -> EC::ProjectivePoint t\npoint_add_affine_alt F p1 p2 = p3 where\n    (x1, y1, z1) = normalize_point F p1\n    (x2, y2) = normalize_affine_point F p2\n    z1z1 = F.sq z1\n    h = F.mul(x2,z1z1)\n    r = F.mul(F.mul(y2,z1), z1z1)\n\n    h_1 = F.sub(h, x1)\n    hh = F.sq h_1\n    i = (F.add (hh,hh))\n    i_1 = F.add (i,i)\n\n    j = F.mul (h_1, i_1)\n\n    r_1 = F.sub(r, y1)\n    r_2 = F.add(r_1, r_1)\n\n    v = F.mul(x1, i_1)\n\n    x3 = F.sub(F.sub(F.sub(F.sq r_2, j), v), v)\n\n    j_1 = F.mul(j, y1)\n    y3 = F.sub(v, x3)\n    y3_1 = F.mul(y3, r_2)\n    y3_2 = F.sub(F.sub(y3_1, j_1), j_1)\n\n    z3 = F.add(z1,h_1)\n    z3_1 = F.sq z3\n    z3_2 = F.sub (z3_1, z1z1)\n    z3_3 = F.sub (z3_2, hh)\n\n    p3 = (x3, y3_2, z3_3)\n\nlshift_fp: t_Fp -> Size_t -> t_Fp\nlshift_fp a c = shifts @ c where shifts = [a] # [Fp.add (a',a') | a' <- shifts ]\n\nlshift_fp2: t_Fp_2 -> Size_t -> t_Fp_2\nlshift_fp2 [a1,a0] c = [lshift_fp a1 c, lshift_fp a0 c]\n\nline_by_Px2: t_Fp_6 -> (t_Fp, t_Fp) -> t_Fp_6\nline_by_Px2 [[l2_1, l2_0], [l1_1, l1_0], l0]  (Px, Py) = [l2', l1', l0] where\n    l1' = [Fp.mul (l1_1, Px), Fp.mul (l1_0, Px)]\n    l2' = [Fp.mul (l2_1, Py), Fp.mul (l2_0, Py)]\n\nline_double_imp: (t_Fp_2, t_Fp_2, t_Fp_2) -> t_Fp_6\nline_double_imp (X1, Y1, Z1) = [l2, l1, l0] where\n    A = Fp_2.sq X1\n    E = mul_by_3 Fp_2 A\n    F = Fp_2.sq E\n    B = Fp_2.sq Y1\n    l0_a = Fp_2.add (E, X1)\n    l0_b = Fp_2.sub (Fp_2.sq l0_a, A)\n    l0_c = Fp_2.sub (l0_b, F)\n    l0 = Fp_2.sub (l0_c, lshift_fp2 B 2)\n    l1 = Fp_2.mul (mul_by_3 Fp_2 (Fp_2.sq X1), Fp_2.sq Z1)\n    l2 = Fp_2.mul (Fp_2.mul (Fp_2.add (Z1, Z1), Y1), Fp_2.sq Z1)\n\nline_add_imp (x1,y1,z1) (x2,y2) = [l2, l1, l0] where\n    F = Fp_2\n    z1z1 = F.sq z1\n    h = F.mul(x2,z1z1)\n    r = F.mul(F.mul(y2,z1), z1z1)\n\n    h_1 = F.sub(h, x1)\n    hh = F.sq h_1\n    i = (F.add (hh,hh))\n    i_1 = F.add (i,i)\n\n    r_1 = F.sub(r, y1)\n    r_2 = F.add(r_1, r_1)\n\n    z3 = F.add(z1,h_1)\n    z3_1 = F.sq z3\n    z3_2 = F.sub (z3_1, z1z1)\n    z3_3 = F.sub (z3_2, hh)\n\n    l0 = mul_by_2 F (F.sub (F.mul (r_2, x2), F.mul (y2, z3_3)))\n    l1 = r_2\n    l2 = z3_3\n\nstart_dbl_n_imp: {n} (fin n, n >= 1) => [n](t_Fp_2, t_Fp_2, t_Fp_2) -> [n](t_Fp, t_Fp) -> t_Fp_12\nstart_dbl_n_imp Ts Px2s = rets!0 where\n    line_a = line_double_imp (Ts@0)\n    line_b = line_by_Px2 line_a (Px2s@0)\n    ret_a = fp6_to_fp12_xy00z0 line_b\n    \/\/ standard loop-to-comprehension transcription of the C code\n    rets = [ret_a] # [Fp_12.mul (ret,  fp6_to_fp12_xy00z0 line) | ret <- rets | line <- lines]\n    lines = [line_by_Px2 (line_double_imp T) P | T <- tail Ts | P <- tail Px2s]\n\n\/\/ effect of one point.\nstart_dbl_1: (t_Fp_2, t_Fp_2, t_Fp_2) -> (t_Fp, t_Fp) -> t_Fp_12\nstart_dbl_1 T Px2 = ret where\n    line_a = line_double_imp T\n    line_b = line_by_Px2 line_a Px2\n    ret = fp6_to_fp12_xy00z0 line_b\n\n\/\/ effect on point T -- each of the T_i, Q_i affected independently in the same way\n\/\/ named _alt to avoid conflict with the definition in HashToG2.cry\nadd_n_dbl_alt: {k} (fin k) => EC::ProjectivePoint t_Fp_2 ->  EC::AffinePoint t_Fp_2 -> EC::ProjectivePoint t_Fp_2\nadd_n_dbl_alt T Q = doubles@`k where\n    doubles = [point_add_affine_alt Fp_2 T Q] # [ point_double Fp_2 D | D <- doubles]\n\n\/\/ effect on ret - n=1 case\nadd_n_dbl_ret: {k} (fin k) =>\n      t_Fp_12 -> EC::ProjectivePoint t_Fp_2 -> EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nadd_n_dbl_ret r T Q Px2 = rets@`k where\n    ret_a = Fp_12.mul (r, fp6_to_fp12_xy00z0 (line_by_Px2 (line_add_imp T Q) Px2))\n    T_a = point_add_affine_alt Fp_2 T Q\n    \/\/ standard loop-to-comprehension transcription of the C code, for the loop on `k`\n    Ts = [T_a] # [point_double Fp_2 Ti | Ti <- Ts]\n    lines = [line_by_Px2 (line_double_imp Ti) Px2 | Ti <- Ts ]\n    rets = [ret_a] # [Fp_12.mul (Fp_12.sq ret, fp6_to_fp12_xy00z0 line) | ret <- rets | line <- lines]\n\n\/\/ and for n >= 1\nadd_n_dbl_n_ret: {n, k} (fin n, n >= 1, fin k) =>\n     t_Fp_12 ->[n](EC::ProjectivePoint t_Fp_2) -> [n](EC::AffinePoint t_Fp_2) -> [n](EC::AffinePoint t_Fp)\n     -> t_Fp_12\nadd_n_dbl_n_ret r Ts Qs Px2s = F_prod Fp_12 rets where\n    rets = [add_n_dbl_ret`{k} r (Ts@0) (Qs@0) (Px2s@0)] #\n           [add_n_dbl_ret`{k} Fp_12.field_unit T Q Px2 | T <- tail Ts | Q <- tail Qs | Px2 <- tail Px2s]\n\n\/\/\/\/ miller_loop_n\n\nmiller_loop_imp: EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nmiller_loop_imp Q P = fp12_conjugate ret_f where\n    (xP, yP) = P\n    Px2 = (Fp.neg (Fp.add (xP, xP)), Fp.add (yP, yP))\n    (xQ, yQ) = Q\n    T = (xQ, yQ, Fp_2.field_unit)\n    ret_a = start_dbl_n_imp [T] [Px2]\n    T_a = point_double Fp_2 T\n    ret_b = add_n_dbl_ret`{2} ret_a T_a Q Px2\n    T_b = add_n_dbl_alt`{2} T_a Q\n    ret_c = add_n_dbl_ret`{3} ret_b T_b Q Px2\n    T_c = add_n_dbl_alt`{3} T_b Q\n    ret_d = add_n_dbl_ret`{9} ret_c T_c Q Px2\n    T_d = add_n_dbl_alt`{9} T_c Q\n    ret_e = add_n_dbl_ret`{32} ret_d T_d Q Px2\n    T_e = add_n_dbl_alt`{32} T_d Q\n    ret_f = add_n_dbl_ret`{16} ret_e T_e Q Px2\n\nmiller_loop_n_1_imp:  EC::AffinePoint t_Fp_2 -> EC::AffinePoint t_Fp -> t_Fp_12\nmiller_loop_n_1_imp Q P = (if Q == (z2,z2) \\\/ P == (z1,z1)\n                           then Fp_12.field_unit\n                           else miller_loop_imp Q P) where\n    z1 = Fp.field_zero\n    z2 = Fp_2.field_zero\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/Keygen.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol the BLS key generation procedure `KeyGen_rep` using HKDF-SHA256 and Montgomery arithmetic, including the properties `keygen_finish_integer`, `keygen_finish_bv`, and `le_bytes_from_limbs_rep4_prop` over their respective inputs."},{"role":"assistant","content":"```cryptol\nmodule implementation::Keygen where\n\nimport Parameters as P\nimport Primitive::Keyless::Hash::SHA256\nimport Primitive::Symmetric::KDF::HKDF256\nimport rfc8017\n\nimport Common::bv\n\nimport implementation::Types\nimport implementation::Field\n\npow256_abs: Pow256 -> [256]\npow256_abs x = join (reverse x)\n\nr_modulus = toInteger P::r \nr_R = 2^^256\n\nr_R_inv = toInteger 0x1bbe869330009d577204078a4f77266aab6fca8f09dc705f13f75b69fe75c040\n\nr_RR = 2^^512\n\nr_R_reduced = r_R % r_modulus\nr_RR_reduced = r_RR % r_modulus\nr_R_inv_reduced = r_R_inv % r_modulus\n\nr_to_mont x = (x*r_R) % r_modulus\n\nr_from_mont x = (x*r_R_inv) % r_modulus\n\nr_add_mont x y = (x+y) % r_modulus\n\nr_mul_mont x y = (x*y*r_R_inv) % r_modulus\n\nproperty keygen_finish_integer x = r_mul_mont (r_from_mont x) (2^^512 % r_modulus) == (x % r_modulus)\n\nbv_r = (fromInteger r_modulus):[256] bv_R = (fromInteger r_R_reduced):[256]\nbv_R_inv = (fromInteger r_R_inv):[256] bv_RR = (fromInteger r_RR_reduced):[256]\n\nmul_mont_r_bv: [256] -> [256] -> [256]\nmul_mont_r_bv a b = safe_mod (bv_r, safe_product (zext a, safe_product (b, bv_R_inv)))\n\nredc_r_bv: [512] -> [256]\nredc_r_bv x = safe_mod (bv_r, safe_product (x, zext bv_R_inv))\n\nproperty keygen_finish_bv x =\n  safe_mod (bv_r, x) == mul_mont_r_bv (redc_r_bv x) bv_RR\n\nmul_mont_256_rep: Vec256 -> Vec256 -> Vec256\nmul_mont_256_rep x y = vec256_rep (mul_mont_r_bv (vec256_abs x) (vec256_abs y))\n\nr_redc_rep: Vec512 -> Vec256\nr_redc_rep x = vec256_rep (redc_r_bv (vec512_abs x))\n\nr_RR_rep: Vec256 r_RR_rep = [14526898881837571181, 3129137299524312099, 419701826671360399, 524908885293268753]\n\nlimbs_from_be_bytes_rep48: [48][8] -> [6]Limb\nlimbs_from_be_bytes_rep48 bytes = reverse (split (join bytes))\n\nle_bytes_from_limbs_rep4: Vec256 -> Pow256\nle_bytes_from_limbs_rep4 limbs = reverse (split (join (reverse limbs)))\n\nproperty le_bytes_from_limbs_rep4_prop limbs =\n    pow256_abs (le_bytes_from_limbs_rep4 limbs) == vec256_abs limbs\n\nKeyGenStep_rep: {IKM_len, info_len} (validHMACSizes 20 (1+IKM_len)\n                                    , validHMACSizes 32 (35+info_len)\n                                    ) =>\n        [256] -> [IKM_len][8] -> [info_len][8] -> Vec256\nKeyGenStep_rep salt IKM key_info = SK where\n    type L = (3 * 256) \/^ 16     PRK = HKDF_Extract (split salt) (IKM # [0])     OKM = HKDF_Expand`{L=L} PRK (key_info # I2OSP`{xLen=2} `L)\n    OKM_vec = (limbs_from_be_bytes_rep48 OKM) # [0,0]\n    SK = mul_mont_256_rep (r_redc_rep OKM_vec) r_RR_rep\n\nKeyGenLoop_rep: {IKM_len, info_len} (validHMACSizes 20 (1+IKM_len)\n                                    , validHMACSizes 32 (35+info_len)\n                                    ) =>\n        [256] -> [IKM_len][8] -> [info_len][8] -> [inf]Vec256\nKeyGenLoop_rep salt IKM info = keys where\n    salts = [salt] # [sha salt' | salt' <- salts]\n    keys = [zero] #\n                      [if k == zero then key_gen_step salt' else k | k <- keys | salt' <- salts]\n    key_gen_step s = KeyGenStep_rep s IKM info\n\nKeyGen_rep: {IKM_len, info_len} ( validHMACSizes 20 (1+IKM_len)\n                                , validHMACSizes 32 (35+info_len)\n                                ) =>\n        ([IKM_len][8], [info_len][8]) -> Pow256\nKeyGen_rep (IKM, key_info) = le_bytes_from_limbs_rep4 SK_vec where\n    SK_vec = (KeyGenLoop_rep (sha (join \"BLS-SIG-KEYGEN-SALT-\")) IKM key_info) @ 4\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/Psi.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol the Psi isogeny implementation psi_imp on BLS12-381 G2 points over Fp2, including psi_projective_imp and projective_pair_to_jacobian_imp, with properties that it preserves subgroup membership and matches the mathematically defined Psi map from the Pairing\/Frobenius parameters."},{"role":"assistant","content":"```cryptol\nmodule implementation::Psi where\n\nimport Frobenius\nimport G2SubGroupCheck\nimport Pairing\nimport Parameters\nimport ShortWeierstrassCurve\n\npsi_imp: ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2\npsi_imp P = projective_pair_to_jacobian_imp qpp where\n  pp = jacobian_to_projective_pair P\n  qpp = psi_projective_imp pp\n\npsi_x_factor = Fp_2.mul (alpha, [Fp.field_zero,psi_c1@0])\nqi_x_abs x = fp2_frobenius (Fp_2.mul (x, psi_x_factor))\npsi_y_factor = Fp_2.mul (alpha, Fp_2.neg psi_c2)\nqi_y_abs x = fp2_frobenius (Fp_2.mul (x, psi_y_factor))\n\npsi_projective_imp (xn, xd, yn, yd) = (qxn, qxd, qyn, qyd) where\n  qxn = Fp_2.mul (qi_x_abs xn, psi_c1)\n  qxd = qi_x_abs xd\n  qyn = Fp_2.mul (qi_y_abs yn, psi_c2)\n  qyd = qi_y_abs yd\n\nprojective_pair_to_jacobian_imp: projective_pair_fp2 -> ProjectivePoint t_Fp_2\nprojective_pair_to_jacobian_imp (xn, xd, yn, yd) = (X', Y', Z') where\n  X' = Fp_2.mul (xn, Fp_2.mul (yd, Z'))\n  Y' = Fp_2.mul (Fp_2.sq Z', Fp_2.mul (xd, yn))\n  Z' = Fp_2.mul (xd, yd)\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/Types.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define Cryptol types and functions for multi-limb vectors and implement vec_abs, vec_rep, bool_to_limb, select, and scalar_to_integer with the given type signatures and behavior for converting between limb arrays, bit vectors, and integers."},{"role":"assistant","content":"```cryptol\nmodule implementation::Types where\n\ntype Vec256 = [4][64]\ntype Vec384 = [6][64]\ntype Vec512 = [8][64]\ntype Vec768 = [12][64]\ntype Pow256 = [32][8]\ntype Limb = [64]\ntype Size_t = [64]\n\nvec_abs: {n} (fin n) => [n]Limb -> [n*64]\nvec_abs limbs = join (reverse limbs)\n\nvec256_abs = vec_abs`{256\/64}\nvec384_abs = vec_abs`{384\/64}\nvec512_abs = vec_abs`{512\/64}\nvec768_abs = vec_abs`{768\/64}\n\nvec_rep:  {n} (fin n) => [n*64] -> [n]Limb\nvec_rep x = reverse (split x)\n\nvec256_rep = vec_rep`{256\/64}\nvec384_rep = vec_rep`{384\/64}\nvec768_rep = vec_rep`{768\/64}\n\nbool_to_limb: Bool -> Limb\nbool_to_limb b = if b then (1:Limb) else 0\n\nselect: {t} t -> t-> Bit -> t\nselect a b c = if c then a else b\n\nscalar_to_integer: {n} (fin n, n >= 1, n <= 2^^60) => [n][8] -> Limb -> Integer\nscalar_to_integer bytes n_bits = vs!0 where\n    bits = join (reverse bytes)\n    vs = [0] # [ if j < n_bits then 2*v + (if b then 1 else 0) else 0\n               | b <- bits                | j <- reverse [0 .. 8*n - 1]                | v <- vs ]\n```"}]}
{"filename":"BLST-Verification\/spec\/implementation\/x86\/inverse.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and prove in Cryptol that ctx_inverse_mod_383 : Vec384 -> Vec384 -> Vec768 correctly computes the extended Euclidean-based modular inverse of a (mod n), i.e., that the low 384 bits of ctx_inverse_mod_383 a n equal a\u207b\u00b9 mod n when gcd(a,n)=1."},{"role":"assistant","content":"```cryptol\nmodule implementation::x86::inverse where\n\nimport implementation::Types\nimport implementation::x86::helpers\n\n__smulx_383_n_shift_by_31\n  : Vec384   -> Vec384   -> [64]   -> [64]   -> (Vec384, [64], [64])\n__smulx_383_n_shift_by_31 a b f0 g0 = result\n  where\n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0] = a\n    r14_0 = 0\n    rdx_0 = f0\n    rcx_0 = g0\n    rbx_0 = rdx_0\n    rax_1 = rdx_0\n    rax_2 = sar rax_1 0x3f\n    rbp_3 = 0\n    (cf_4, rbp_4) = sub rbp_3 rax_2\n    rdx_5 = rdx_0 ^ rax_2\n    (cf_6, rdx_6) = add rdx_5 rbp_4\n    r8_7 = r8_0 ^ rax_2\n    r9_8 = r9_0 ^ rax_2\n    r10_9 = r10_0 ^ rax_2\n    r11_10 = r11_0 ^ rax_2\n    r12_11 = r12_0 ^ rax_2\n    rax_12 = rax_2 ^ r13_0\n    (cf_13, r8_13) = add r8_7 rbp_4\n    (cf_14, r9_14) = adc r9_8 0 cf_13\n    (cf_15, r10_15) = adc r10_9 0 cf_14\n    (cf_16, r11_16) = adc r11_10 0 cf_15\n    (cf_17, r12_17) = adc r12_11 0 cf_16\n    (cf_18, rax_18) = adc rax_12 0 cf_17\n    (rbp_19, r8_19) = mulx r8_13 rdx_6\n    (r13_20, r9_20) = mulx r9_14 rdx_6\n    (cf_21, r9_21) = add r9_20 rbp_19\n    (rbp_22, r10_22) = mulx r10_15 rdx_6\n    (cf_23, r10_23) = adc r10_22 r13_20 cf_21\n    (r13_24, r11_24) = mulx r11_16 rdx_6\n    (cf_25, r11_25) = adc r11_24 rbp_22 cf_23\n    (rbp_26, r12_26) = mulx r12_17 rdx_6\n    (cf_27, r12_27) = adc r12_26 r13_24 cf_25\n    (cf_28, rbp_28) = adc rbp_26 0 cf_27\n    (rdx_29, rax_29) = imul1 rdx_6 rax_18\n    (cf_30, rax_30) = add rax_29 rbp_28\n    (cf_31, r14_31) = adc r14_0 rdx_29 cf_30\n    rdx_32 = rcx_0\n    offload0 = r8_19\n    offload1 = r9_21\n    offload2 = r10_23\n    offload3 = r11_25\n    offload4 = r12_27\n    offload5 = rax_30\n    r8_39 = b @ 0\n    r9_40 = b @ 1\n    r10_41 = b @ 2\n    r11_42 = b @ 3\n    r12_43 = b @ 4\n    r13_44 = b @ 5\n    rax_45 = rdx_32\n    rax_46 = sar rax_45 0x3f\n    rbp_47 = 0\n    (cf_48, rbp_48) = sub rbp_47 rax_46\n    rdx_49 = rdx_32 ^ rax_46\n    (cf_50, rdx_50) = add rdx_49 rbp_48\n    r8_51 = r8_39 ^ rax_46\n    r9_52 = r9_40 ^ rax_46\n    r10_53 = r10_41 ^ rax_46\n    r11_54 = r11_42 ^ rax_46\n    r12_55 = r12_43 ^ rax_46\n    rax_56 = rax_46 ^ r13_44\n    (cf_57, r8_57) = add r8_51 rbp_48\n    (cf_58, r9_58) = adc r9_52 0 cf_57\n    (cf_59, r10_59) = adc r10_53 0 cf_58\n    (cf_60, r11_60) = adc r11_54 0 cf_59\n    (cf_61, r12_61) = adc r12_55 0 cf_60\n    (cf_62, rax_62) = adc rax_56 0 cf_61\n    (rbp_63, r8_63) = mulx r8_57 rdx_50\n    (r13_64, r9_64) = mulx r9_58 rdx_50\n    (cf_65, r9_65) = add r9_64 rbp_63\n    (rbp_66, r10_66) = mulx r10_59 rdx_50\n    (cf_67, r10_67) = adc r10_66 r13_64 cf_65\n    (r13_68, r11_68) = mulx r11_60 rdx_50\n    (cf_69, r11_69) = adc r11_68 rbp_66 cf_67\n    (rbp_70, r12_70) = mulx r12_61 rdx_50\n    (cf_71, r12_71) = adc r12_70 r13_68 cf_69\n    (cf_72, rbp_72) = adc rbp_70 0 cf_71\n    (rdx_73, rax_73) = imul1 rdx_50 rax_62\n    (cf_74, rax_74) = add rax_73 rbp_72\n    (cf_75, rdx_75) = adc rdx_73 0 cf_74\n    (cf_76, r8_76) = add r8_63 offload0\n    (cf_77, r9_77) = adc r9_65 offload1 cf_76\n    (cf_78, r10_78) = adc r10_67 offload2 cf_77\n    (cf_79, r11_79) = adc r11_69 offload3 cf_78\n    (cf_80, r12_80) = adc r12_71 offload4 cf_79\n    (cf_81, rax_81) = adc rax_74 offload5 cf_80\n    (cf_82, r14_82) = adc r14_31 rdx_75 cf_81\n    rdx_83 = rbx_0\n    r8_84 = shrd r8_76 r9_77 (zext`{64} 0x1f)\n    r9_85 = shrd r9_77 r10_78 (zext`{64} 0x1f)\n    r10_86 = shrd r10_78 r11_79 (zext`{64} 0x1f)\n    r11_87 = shrd r11_79 r12_80 (zext`{64} 0x1f)\n    r12_88 = shrd r12_80 rax_81 (zext`{64} 0x1f)\n    rax_89 = shrd rax_81 r14_82 (zext`{64} 0x1f)\n    r14_90 = sar r14_82 0x3f\n    rbp_91 = 0\n    (cf_92, rbp_92) = sub rbp_91 r14_90\n    r8_93 = r8_84 ^ r14_90\n    r9_94 = r9_85 ^ r14_90\n    r10_95 = r10_86 ^ r14_90\n    r11_96 = r11_87 ^ r14_90\n    r12_97 = r12_88 ^ r14_90\n    rax_98 = rax_89 ^ r14_90\n    (cf_99, r8_99) = add r8_93 rbp_92\n    (cf_100, r9_100) = adc r9_94 0 cf_99\n    (cf_101, r10_101) = adc r10_95 0 cf_100\n    (cf_102, r11_102) = adc r11_96 0 cf_101\n    (cf_103, r12_103) = adc r12_97 0 cf_102\n    (cf_104, rax_104) = adc rax_98 0 cf_103\n    result0 = r8_99\n    result1 = r9_100\n    result2 = r10_101\n    result3 = r11_102\n    result4 = r12_103\n    result5 = rax_104\n    rdx_111 = rdx_83 ^ r14_90\n    rcx_111 = rcx_0 ^ r14_90\n    (cf_113, rdx_113) = add rdx_111 rbp_92\n    (cf_114, rcx_114) = add rcx_111 rbp_92\n    result = ([result0, result1, result2, result3, result4, result5], rdx_113, rcx_114)\n\n__smulx_191_n_shift_by_31\n  : [3][64]   -> [3][64]   -> [64]   -> [64]   -> ([3][64], [64], [64])\n__smulx_191_n_shift_by_31 a b f0 g0 = result\n  where\n    [r8_0, r9_0, r10_0] = take a\n    rdx_0 = f0\n    rcx_0 = g0\n    rbx_0 = rdx_0\n    rax_1 = rdx_0\n    rax_2 = sar rax_1 0x3f\n    rbp_3 = 0\n    (cf_4, rbp_4) = sub rbp_3 rax_2\n    rdx_5 = rdx_0 ^ rax_2\n    (cf_6, rdx_6) = add rdx_5 rbp_4\n    r8_7 = r8_0 ^ rax_2\n    r9_8 = r9_0 ^ rax_2\n    rax_9 = rax_2 ^ r10_0\n    (cf_10, r8_10) = add r8_7 rbp_4\n    (cf_11, r9_11) = adc r9_8 0 cf_10\n    (cf_12, rax_12) = adc rax_9 0 cf_11\n    (rbp_13, r8_13) = mulx r8_10 rdx_6\n    (r10_14, r9_14) = mulx r9_11 rdx_6\n    (cf_15, r9_15) = add r9_14 rbp_13\n    (cf_16, r10_16) = adc r10_14 0 cf_15\n    (rdx_17, rax_17) = imul1 rdx_6 rax_12\n    (cf_18, r10_18) = add r10_16 rax_17\n    (cf_19, rdx_19) = adc rdx_17 0 cf_18\n    r14_20 = rdx_19\n    rdx_21 = rcx_0\n    r11_22 = b @ 0\n    r12_23 = b @ 1\n    r13_24 = b @ 2\n    rax_25 = rdx_21\n    rax_26 = sar rax_25 0x3f\n    rbp_27 = 0\n    (cf_28, rbp_28) = sub rbp_27 rax_26\n    rdx_29 = rdx_21 ^ rax_26\n    (cf_30, rdx_30) = add rdx_29 rbp_28\n    r11_31 = r11_22 ^ rax_26\n    r12_32 = r12_23 ^ rax_26\n    rax_33 = rax_26 ^ r13_24\n    (cf_34, r11_34) = add r11_31 rbp_28\n    (cf_35, r12_35) = adc r12_32 0 cf_34\n    (cf_36, rax_36) = adc rax_33 0 cf_35\n    (rbp_37, r11_37) = mulx r11_34 rdx_30\n    (r13_38, r12_38) = mulx r12_35 rdx_30\n    (cf_39, r12_39) = add r12_38 rbp_37\n    (cf_40, r13_40) = adc r13_38 0 cf_39\n    (rdx_41, rax_41) = imul1 rdx_30 rax_36\n    (cf_42, r13_42) = add r13_40 rax_41\n    (cf_43, rdx_43) = adc rdx_41 0 cf_42\n    (cf_44, r11_44) = add r11_37 r8_13\n    (cf_45, r12_45) = adc r12_39 r9_15 cf_44\n    (cf_46, r13_46) = adc r13_42 r10_18 cf_45\n    (cf_47, r14_47) = adc r14_20 rdx_43 cf_46\n    rdx_48 = rbx_0\n    r11_49 = shrd r11_44 r12_45 (zext`{64} 0x1f)\n    r12_50 = shrd r12_45 r13_46 (zext`{64} 0x1f)\n    r13_51 = shrd r13_46 r14_47 (zext`{64} 0x1f)\n    r14_52 = sar r14_47 0x3f\n    rbp_53 = 0\n    (cf_54, rbp_54) = sub rbp_53 r14_52\n    r11_55 = r11_49 ^ r14_52\n    r12_56 = r12_50 ^ r14_52\n    r13_57 = r13_51 ^ r14_52\n    (cf_58, r11_58) = add r11_55 rbp_54\n    (cf_59, r12_59) = adc r12_56 0 cf_58\n    (cf_60, r13_60) = adc r13_57 0 cf_59\n    result0 = r11_58\n    result1 = r12_59\n    result2 = r13_60\n    rdx_64 = rdx_48 ^ r14_52\n    rcx_65 = rcx_0 ^ r14_52\n    (cf_66, rdx_66) = add rdx_64 rbp_54\n    (cf_67, rcx_67) = add rcx_65 rbp_54\n    result = ([result0, result1, result2], rdx_66, rcx_67)\n\n__smulx_383x63\n  : Vec384   -> Vec384   -> [64]   -> [64]   -> Vec384\n__smulx_383x63 u v f0 g0 = result\n  where\n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0] = u\n    rdx_0 = f0\n    rcx_0 = g0\n    rbp_1 = rdx_0\n    rbp_2 = sar rbp_1 0x3f\n    rax_3 = 0\n    (cf_4, rax_4) = sub rax_3 rbp_2\n    rdx_5 = rdx_0 ^ rbp_2\n    (cf_6, rdx_6) = add rdx_5 rax_4\n    r8_7 = r8_0 ^ rbp_2\n    r9_8 = r9_0 ^ rbp_2\n    r10_9 = r10_0 ^ rbp_2\n    r11_10 = r11_0 ^ rbp_2\n    r12_11 = r12_0 ^ rbp_2\n    r13_12 = r13_0 ^ rbp_2\n    (cf_13, r8_13) = add r8_7 rax_4\n    (cf_14, r9_14) = adc r9_8 0 cf_13\n    (cf_15, r10_15) = adc r10_9 0 cf_14\n    (cf_16, r11_16) = adc r11_10 0 cf_15\n    (cf_17, r12_17) = adc r12_11 0 cf_16\n    (cf_18, r13_18) = adc r13_12 0 cf_17\n    (rbp_19, r8_19) = mulx r8_13 rdx_6\n    (rax_20, r9_20) = mulx r9_14 rdx_6\n    (cf_21, r9_21) = add r9_20 rbp_19\n    (rbp_22, r10_22) = mulx r10_15 rdx_6\n    (cf_23, r10_23) = adc r10_22 rax_20 cf_21\n    (rax_24, r11_24) = mulx r11_16 rdx_6\n    (cf_25, r11_25) = adc r11_24 rbp_22 cf_23\n    (rbp_26, r12_26) = mulx r12_17 rdx_6\n    (cf_27, r12_27) = adc r12_26 rax_24 cf_25\n    (rax_28, r13_28) = mulx r13_18 rdx_6\n    rdx_29 = rcx_0\n    (cf_30, r13_30) = adc r13_28 rbp_26 cf_27\n    offload0 = r8_19\n    offload1 = r9_21\n    offload2 = r10_23\n    offload3 = r11_25\n    offload4 = r12_27\n    offload5 = r13_30\n    r8_37 = v @ 0\n    r9_38 = v @ 1\n    r10_39 = v @ 2\n    r11_40 = v @ 3\n    r12_41 = v @ 4\n    r13_42 = v @ 5\n    rbp_43 = rdx_29\n    rbp_44 = sar rbp_43 0x3f\n    rax_45 = 0\n    (cf_46, rax_46) = sub rax_45 rbp_44\n    rdx_47 = rdx_29 ^ rbp_44\n    (cf_48, rdx_48) = add rdx_47 rax_46\n    r8_49 = r8_37 ^ rbp_44\n    r9_50 = r9_38 ^ rbp_44\n    r10_51 = r10_39 ^ rbp_44\n    r11_52 = r11_40 ^ rbp_44\n    r12_53 = r12_41 ^ rbp_44\n    r13_54 = r13_42 ^ rbp_44\n    (cf_55, r8_55) = add r8_49 rax_46\n    (cf_56, r9_56) = adc r9_50 0 cf_55\n    (cf_57, r10_57) = adc r10_51 0 cf_56\n    (cf_58, r11_58) = adc r11_52 0 cf_57\n    (cf_59, r12_59) = adc r12_53 0 cf_58\n    (cf_60, r13_60) = adc r13_54 0 cf_59\n    (rbp_61, r8_61) = mulx r8_55 rdx_48\n    (rax_62, r9_62) = mulx r9_56 rdx_48\n    (cf_63, r9_63) = add r9_62 rbp_61\n    (rbp_64, r10_64) = mulx r10_57 rdx_48\n    (cf_65, r10_65) = adc r10_64 rax_62 cf_63\n    (rax_66, r11_66) = mulx r11_58 rdx_48\n    (cf_67, r11_67) = adc r11_66 rbp_64 cf_65\n    (rbp_68, r12_68) = mulx r12_59 rdx_48\n    (cf_69, r12_69) = adc r12_68 rax_66 cf_67\n    (rax_70, r13_70) = mulx r13_60 rdx_48\n    (cf_71, r13_71) = adc r13_70 rbp_68 cf_69\n    (cf_72, r8_72) = add r8_61 offload0\n    (cf_73, r9_73) = adc r9_63 offload1 cf_72\n    (cf_74, r10_74) = adc r10_65 offload2 cf_73\n    (cf_75, r11_75) = adc r11_67 offload3 cf_74\n    (cf_76, r12_76) = adc r12_69 offload4 cf_75\n    (cf_77, r13_77) = adc r13_71 offload5 cf_76\n    result0 = r8_72\n    result1 = r9_73\n    result2 = r10_74\n    result3 = r11_75\n    result4 = r12_76\n    result5 = r13_77\n    result = [result0, result1, result2, result3, result4, result5]\n\n__smulx_767x63\n  : Vec384   -> Vec768   -> [64]   -> [64]   -> Vec768\n__smulx_767x63 u v f0 g0 = result\n  where\n    [r8_0, r9_0, r10_0, r11_0, r12_0, r13_0] = u\n    rdx_0 = f0\n    rcx_0 = g0\n    rax_7 = rdx_0\n    rax_8 = sar rax_7 0x3f\n    rbp_9 = 0\n    (cf_10, rbp_10) = sub rbp_9 rax_8\n    rdx_14 = rdx_0 ^ rax_8\n    (cf_15, rdx_15) = add rdx_14 rbp_10\n    r8_16 = r8_0 ^ rax_8\n    r9_17 = r9_0 ^ rax_8\n    r10_18 = r10_0 ^ rax_8\n    r11_19 = r11_0 ^ rax_8\n    r12_20 = r12_0 ^ rax_8\n    rax_21 = rax_8 ^ r13_0\n    (cf_22, r8_22) = add r8_16 rbp_10\n    (cf_23, r9_23) = adc r9_17 0 cf_22\n    (cf_24, r10_24) = adc r10_18 0 cf_23\n    (cf_25, r11_25) = adc r11_19 0 cf_24\n    (cf_26, r12_26) = adc r12_20 0 cf_25\n    (cf_27, rax_27) = adc rax_21 0 cf_26\n    (rbp_28, r8_28) = mulx r8_22 rdx_15\n    (r13_29, r9_29) = mulx r9_23 rdx_15\n    (cf_30, r9_30) = add r9_29 rbp_28\n    (rbp_31, r10_31) = mulx r10_24 rdx_15\n    (cf_32, r10_32) = adc r10_31 r13_29 cf_30\n    (r13_33, r11_33) = mulx r11_25 rdx_15\n    (cf_34, r11_34) = adc r11_33 rbp_31 cf_32\n    (rbp_35, r12_35) = mulx r12_26 rdx_15\n    (cf_36, r12_36) = adc r12_35 r13_33 cf_34\n    (cf_37, rbp_37) = adc rbp_35 0 cf_36\n    (rdx_38, rax_38) = imul1 rdx_15 rax_27\n    (cf_39, rax_39) = add rax_38 rbp_37\n    (cf_40, rdx_40) = adc rdx_38 0 cf_39\n    offload0 = r8_28\n    offload1 = r9_30\n    offload2 = r10_32\n    offload3 = r11_34\n    offload4 = r12_36\n    offload5 = rax_39\n    offload6 = rdx_40\n    rdx_48 = rdx_40 >>$ 0x3f\n    offload7 = rdx_48\n    rdx_50 = rcx_0\n    rax_51 = rcx_0\n    r8_52 = v @ 0\n    r9_53 = v @ 1\n    r10_54 = v @ 2\n    r11_55 = v @ 3\n    r12_56 = v @ 4\n    r13_57 = v @ 5\n    r14_58 = v @ 6\n    r15_59 = v @ 7\n    rbx_60 = v @ 8\n    rbp_61 = v @ 9\n    rcx_62 = v @ 10\n    rdi_63 = v @ 11\n    rax_64 = sar rax_51 0x3f\n    rsi_65 = 0\n    (cf_66, rsi_66) = sub rsi_65 rax_64\n    rdx_67 = rdx_50 ^ rax_64\n    (cf_68, rdx_68) = add rdx_67 rsi_66\n    r8_69 = r8_52 ^ rax_64\n    r9_70 = r9_53 ^ rax_64\n    r10_71 = r10_54 ^ rax_64\n    r11_72 = r11_55 ^ rax_64\n    r12_73 = r12_56 ^ rax_64\n    r13_74 = r13_57 ^ rax_64\n    r14_75 = r14_58 ^ rax_64\n    r15_76 = r15_59 ^ rax_64\n    rbx_77 = rbx_60 ^ rax_64\n    rbp_78 = rbp_61 ^ rax_64\n    rcx_79 = rcx_62 ^ rax_64\n    rdi_80 = rdi_63 ^ rax_64\n    (cf_81, r8_81) = add r8_69 rsi_66\n    (cf_82, r9_82) = adc r9_70 0 cf_81\n    (cf_83, r10_83) = adc r10_71 0 cf_82\n    (cf_84, r11_84) = adc r11_72 0 cf_83\n    (cf_85, r12_85) = adc r12_73 0 cf_84\n    (cf_86, r13_86) = adc r13_74 0 cf_85\n    (cf_87, r14_87) = adc r14_75 0 cf_86\n    (cf_88, r15_88) = adc r15_76 0 cf_87\n    (cf_89, rbx_89) = adc rbx_77 0 cf_88\n    (cf_90, rbp_90) = adc rbp_78 0 cf_89\n    (cf_91, rcx_91) = adc rcx_79 0 cf_90\n    (cf_92, rdi_92) = adc rdi_80 0 cf_91\n    (rax_93, r8_93) = mulx r8_81 rdx_68\n    (rsi_94, r9_94) = mulx r9_82 rdx_68\n    (cf_95, r9_95) = add r9_94 rax_93\n    (rax_96, r10_96) = mulx r10_83 rdx_68\n    (cf_97, r10_97) = adc r10_96 rsi_94 cf_95\n    (rsi_98, r11_98) = mulx r11_84 rdx_68\n    (cf_99, r11_99) = adc r11_98 rax_96 cf_97\n    (rax_100, r12_100) = mulx r12_85 rdx_68\n    (cf_101, r12_101) = adc r12_100 rsi_98 cf_99\n    (rsi_102, r13_102) = mulx r13_86 rdx_68\n    (cf_103, r13_103) = adc r13_102 rax_100 cf_101\n    (rax_104, r14_104) = mulx r14_87 rdx_68\n    (cf_105, r14_105) = adc r14_104 rsi_102 cf_103\n    (rsi_106, r15_106) = mulx r15_88 rdx_68\n    (cf_107, r15_107) = adc r15_106 rax_104 cf_105\n    (rax_108, rbx_108) = mulx rbx_89 rdx_68\n    (cf_109, rbx_109) = adc rbx_108 rsi_106 cf_107\n    (rsi_110, rbp_110) = mulx rbp_90 rdx_68\n    (cf_111, rbp_111) = adc rbp_110 rax_108 cf_109\n    (rax_112, rcx_112) = mulx rcx_91 rdx_68\n    (cf_113, rcx_113) = adc rcx_112 rsi_110 cf_111\n    (rsi_114, rdi_114) = mulx rdi_92 rdx_68\n    (cf_117, rax_117) = adc rax_112 rdi_114 cf_113\n    (cf_118, r8_118) = add r8_93 offload0\n    (cf_119, r9_119) = adc r9_95 offload1 cf_118\n    (cf_120, r10_120) = adc r10_97 offload2 cf_119\n    (cf_121, r11_121) = adc r11_99 offload3 cf_120\n    (cf_122, r12_122) = adc r12_101 offload4 cf_121\n    (cf_123, r13_123) = adc r13_103 offload5 cf_122\n    (cf_124, r14_124) = adc r14_105 offload6 cf_123\n    rdi_125 = offload7\n    (cf_126, r15_126) = adc r15_107 rdi_125 cf_124\n    (cf_127, rbx_127) = adc rbx_109 rdi_125 cf_126\n    (cf_128, rbp_128) = adc rbp_111 rdi_125 cf_127\n    (cf_129, rcx_129) = adc rcx_113 rdi_125 cf_128\n    (cf_130, rax_130) = adc rax_117 rdi_125 cf_129\n    result0 = r8_118\n    result1 = r9_119\n    result2 = r10_120\n    result3 = r11_121\n    result4 = r12_122\n    result5 = r13_123\n    result6 = r14_124\n    result7 = r15_126\n    result8 = rbx_127\n    result9 = rbp_128\n    result10 = rcx_129\n    result11 = rax_130\n    result =\n      [ result0, result1, result2, result3, result4, result5\n      , result6, result7, result8, result9, result10, result11\n      ]\n\n__ab_approximation_31\n  : Integer   -> Vec384   -> Vec384   -> [4][64] __ab_approximation_31 iters a b = result\n  where\n    r9_0 = a @ 5\n    r11_0 = b @ 5\n    rbx_0 = a @ 4\n    rbp_0 = b @ 4\n    r8_0 = a @ 3\n    r10_0 = b @ 3\n    rax_1 = r9_0\n    rax_2 = rax_1 || r11_0\n    zf_2 = rax_2 == 0\n    r9_3 = cmove r9_0 rbx_0 zf_2\n    r11_4 = cmove r11_0 rbp_0 zf_2\n    rbx_5 = cmove rbx_0 r8_0 zf_2\n    r8_6 = a @ 2\n    rbp_7 = cmove rbp_0 r10_0 zf_2\n    r10_8 = b @ 2\n    rax_9 = r9_3\n    rax_10 = rax_9 || r11_4\n    zf_10 = rax_10 == 0\n    r9_11 = cmove r9_3 rbx_5 zf_10\n    r11_12 = cmove r11_4 rbp_7 zf_10\n    rbx_13 = cmove rbx_5 r8_6 zf_10\n    r8_14 = a @ 1\n    rbp_15 = cmove rbp_7 r10_8 zf_10\n    r10_16 = b @ 1\n    rax_17 = r9_11\n    rax_18 = rax_17 || r11_12\n    zf_18 = rax_18 == 0\n    r9_19 = cmove r9_11 rbx_13 zf_18\n    r11_20 = cmove r11_12 rbp_15 zf_18\n    rbx_21 = cmove rbx_13 r8_14 zf_18\n    r8_22 = a @ 0\n    rbp_23 = cmove rbp_15 r10_16 zf_18\n    r10_24 = b @ 0\n    rax_25 = r9_19\n    rax_26 = rax_25 || r11_20\n    zf_26 = rax_26 == 0\n    r9_27 = cmove r9_19 rbx_21 zf_26\n    r11_28 = cmove r11_20 rbp_23 zf_26\n    rbx_29 = cmove rbx_21 r8_22 zf_26\n    rbp_30 = cmove rbp_23 r10_24 zf_26\n    rax_31 = r9_27\n    rax_32 = rax_31 || r11_28\n    zf_33 = rax_32 == 0\n    rcx_33 = bsr rax_32\n    rcx_34 = 1 + rcx_33\n    r9_35 = cmove r9_27 rbx_29 zf_33\n    r11_36 = cmove r11_28 rbp_30 zf_33\n    rcx_37 = cmove rcx_34 rax_32 zf_33\n    rcx_38 = 0 - rcx_37\n    r9_39 = shld r9_35 rbx_29 (drop`{56} rcx_38)\n    r11_40 = shld r11_36 rbp_30 (drop`{56} rcx_38)\n    rcx_41 = r9_39\n    rcx_42 = rcx_41 || r11_40\n    rcx_43 = sar rcx_42 (zext`{64} 0x3f)\n    rcx_44 = (drop`{56} rcx_43) && zext 0x21\n    r9_45 = shr r9_39 rcx_44\n    r11_46 = shr r11_40 rcx_44\n    r8_47 = shl r8_22 rcx_44\n    r10_48 = shl r10_24 rcx_44\n    r8_49 = shrd_ret r8_22 r8_47 r9_45 rcx_44\n    r10_50 = shrd_ret r10_24 r10_48 r11_46 rcx_44\n    result = __inner_loop_31 iters r8_49 r10_50\n\n__inner_loop_31\n  : Integer   -> [64]   -> [64]   -> [4][64] __inner_loop_31 iters a_init b_init = result\n  where\n    [post_a, post_b, post_fg0, post_fg1, post_bias] = loop iters [a_init, b_init, 0x7FFFFFFF80000000, 0x800000007FFFFFFF, 0x7FFFFFFF7FFFFFFF]\n    tmp_f0 = zext`{64} (drop`{32} post_fg0)\n    tmp_g0 = shr post_fg0 0x20\n    tmp_f1 = zext`{64} (drop`{32} post_fg1)\n    tmp_g1 = shr post_fg1 0x20\n    tmp_bias = shr post_bias 0x20\n    result = [zext tmp_f0 - tmp_bias, zext tmp_g0 - tmp_bias, zext tmp_f1 - tmp_bias, zext tmp_g1 - tmp_bias]\n    loop : Integer -> [5][64] -> [5][64]\n    loop counter [a, b, fg0, fg1, bias] = loopresult\n      where\n        r8_0 = a\n        r10_0 = b\n        rcx_0 = fg0\n        r13_0 = fg1\n        r15_0 = bias\n        (cf_1, _) = sub r8_0 r10_0\n        rax_2 = r8_0\n        rbx_3 = r10_0\n        rbp_4 = rcx_0\n        r14_5 = r13_0\n        r8_6 = cmovb r8_0 r10_0 cf_1\n        r10_7 = cmovb r10_0 rax_2 cf_1\n        rcx_8 = cmovb rcx_0 r13_0 cf_1\n        r13_9 = cmovb r13_0 rbp_4 cf_1\n        (cf_10, r8_10) = sub r8_6 r10_7\n        (cf_12, rcx_12) = sub (add rcx_8 r15_0).1 r13_9\n        zf_13 = (rax_2 && zext 0x1) == 0\n        r8_14 = cmove r8_10 rax_2 zf_13\n        r10_15 = cmove r10_7 rbx_3 zf_13\n        rcx_16 = cmove rcx_12 rbp_4 zf_13\n        r13_17 = cmove r13_9 r14_5 zf_13\n        r8_18 = shr r8_14 0x01\n        (cf_19, r13_19) = add r13_17 r13_17\n        (cf_20, r13_20) = sub r13_19 r15_0\n        curcounter = counter - 1\n        curresult = [r8_18, r10_15, rcx_16, r13_20, r15_0]\n        loopresult = if curcounter == 0 then curresult else loop curcounter curresult\n\n__inner_loop_62\n  : Integer   -> [64]   -> [64]   -> [4][64] __inner_loop_62 iters a_init b_init = result\n  where\n    result = drop (loop iters [a_init, b_init, 1, 0, 0, 1])\n    loop : Integer -> [6][64] -> [6][64]\n    loop counter [a, b, f0, g0, f1, g1] = loopresult\n      where\n        r8_0 = a\n        r10_0 = b\n        rdx_0 = f0\n        rcx_0 = g0\n        r12_0 = f1\n        r13_0 = g1\n        rax_0 = 0\n        zf_2 = (r8_0 && zext 0x1) == 0\n        rbx_3 = r10_0\n        rax_4 = cmovne rax_0 r10_0 zf_2\n        (cf_5, rbx_5) = sub rbx_3 r8_0\n        rbp_6 = r8_0\n        (cf_7, r8_7) = sub r8_0 rax_4\n        r8_8 = cmovb r8_7 rbx_5 cf_7\n        r10_9 = cmovb r10_0 rbp_6 cf_7\n        rax_10 = rdx_0\n        rdx_11 = cmovb rdx_0 r12_0 cf_7\n        r12_12 = cmovb r12_0 rax_10 cf_7\n        rbx_13 = rcx_0\n        rcx_14 = cmovb rcx_0 r13_0 cf_7\n        r13_15 = cmovb r13_0 rbx_13 cf_7\n        rax_16 = 0\n        rbx_17 = 0\n        r8_18 = r8_8 >> 1\n        rbp_19 = (rbp_6 && zext 0x1) == 0\n        rax_20 = cmovne rax_16 r12_12 zf_2\n        rbx_21 = cmovne rbx_17 r13_15 zf_2\n        (cf_22, r12_22) = add r12_12 r12_12\n        (cf_23, r13_23) = add r13_15 r13_15\n        (cf_24, rdx_24) = sub rdx_11 rax_20\n        (cf_25, rcx_25) = sub rcx_14 rbx_21\n        curcounter = counter - 1\n        curresult = [r8_18, r10_9, rdx_24, rcx_25, r12_22, r13_23]\n        loopresult = if curcounter == 0 then curresult else loop curcounter curresult\n\nctx_inverse_mod_383\n  : Vec384   -> Vec384   -> Vec768 ctx_inverse_mod_383 a n = result   where\n    a_2 = a\n    b_3 = n\n    loa_4 = a_2\n    lob_5 = b_3\n    [f0_6, g0_6, f1_6, g1_6] = __ab_approximation_31 31 loa_4 lob_5\n    (hia_7, f0_7, g0_7) = __smulx_383_n_shift_by_31 loa_4 lob_5 f0_6 g0_6\n    offloadu_7 = f0_7\n    (hib_8, f1_8, g1_8) = __smulx_383_n_shift_by_31 loa_4 lob_5 f1_6 g1_6\n    offloadv_8 = f1_8\n    [f0_9, g0_9, f1_9, g1_9] = __ab_approximation_31 31 hia_7 hib_8\n    (loa_10, f0_10, g0_10) = __smulx_383_n_shift_by_31 hia_7 hib_8 f0_9 g0_9\n    (lob_11, f1_11, g1_11) = __smulx_383_n_shift_by_31 hia_7 hib_8 f1_9 g1_9\n    tmp12_rax_0 = offloadu_7\n    tmp12_r11_0 = offloadv_8\n    tmp12_rbx_0 = f1_11\n    tmp12_r10_0 = tmp12_rax_0\n    (tmp12_rdx_05, tmp12_rax_05) = imul1 f0_10 tmp12_rax_0\n    tmp12_r8_1 = tmp12_rax_05\n    tmp12_rax_1 = tmp12_r11_0\n    tmp12_r9_1 = tmp12_rdx_05\n    (tmp12_rdx_2, tmp12_rax_2) = imul1 g0_10 tmp12_rax_1\n    (tmp12_cf_3, tmp12_r8_3) = add tmp12_r8_1 tmp12_rax_2\n    (tmp12_cf_4, tmp12_r9_4) = adc tmp12_r9_1 tmp12_rdx_2 tmp12_cf_3\n    tmp12_ret0 = tmp12_r8_3\n    tmp12_ret1 = tmp12_r9_4\n    tmp12_r9_5 = sar tmp12_r9_4 0x3f\n    tmp12_ret2 = tmp12_r9_5\n    tmp12_ret3 = tmp12_r9_5\n    tmp12_ret4 = tmp12_r9_5\n    tmp12_ret5 = tmp12_r9_5\n    tmp12_rax_55 = tmp12_r10_0\n    (tmp12_rdx_6, tmp12_rax_6) = imul1 tmp12_rbx_0 tmp12_rax_55\n    tmp12_r8_6 = tmp12_rax_6\n    tmp12_rax_7 = tmp12_r11_0\n    tmp12_r9_7 = tmp12_rdx_6\n    (tmp12_rdx_8, tmp12_rax_8) = imul1 g1_11 tmp12_rax_7\n    (tmp12_cf_9, tmp12_r8_9) = add tmp12_r8_6 tmp12_rax_8\n    (tmp12_cf_10, tmp12_r9_10) = adc tmp12_r9_7 tmp12_rdx_8 tmp12_cf_9\n    tmp12_ret6 = tmp12_r8_9\n    tmp12_ret7 = tmp12_r9_10\n    tmp12_r9_11 = sar tmp12_r9_10 0x3f\n    tmp12_ret8 = tmp12_r9_11\n    tmp12_ret9 = tmp12_r9_11\n    tmp12_ret10 = tmp12_r9_11\n    tmp12_ret11 = tmp12_r9_11\n    lou_12 = [tmp12_ret0, tmp12_ret1, tmp12_ret2, tmp12_ret3, tmp12_ret4, tmp12_ret5]\n    lov_12 = [tmp12_ret6, tmp12_ret7, tmp12_ret8, tmp12_ret9, tmp12_ret10, tmp12_ret11]\n    [f0_14, g0_14, f1_14, g1_14] = __ab_approximation_31 31 loa_10 lob_11\n    (hia_15, f0_15, g0_15) = __smulx_383_n_shift_by_31 loa_10 lob_11 f0_14 g0_14\n    (hib_16, f1_16, g1_16) = __smulx_383_n_shift_by_31 loa_10 lob_11 f1_14 g1_14\n    hiu_17 = __smulx_383x63 lou_12 lov_12 f0_15 g0_15\n    hiv_18 = __smulx_383x63 lou_12 lov_12 f1_16 g1_16\n    [f0_19, g0_19, f1_19, g1_19] = __ab_approximation_31 31 hia_15 hib_16\n    (loa_20, f0_20, g0_20) = __smulx_383_n_shift_by_31 hia_15 hib_16 f0_19 g0_19\n    (lob_21, f1_21, g1_21) = __smulx_383_n_shift_by_31 hia_15 hib_16 f1_19 g1_19\n    lou_22 = __smulx_383x63 hiu_17 hiv_18 f0_20 g0_20\n    lov_23 = __smulx_383x63 hiu_17 hiv_18 f1_21 g1_21\n    [f0_24, g0_24, f1_24, g1_24] = __ab_approximation_31 31 loa_20 lob_21\n    (hia_25, f0_25, g0_25) = __smulx_383_n_shift_by_31 loa_20 lob_21 f0_24 g0_24\n    (hib_26, f1_26, g1_26) = __smulx_383_n_shift_by_31 loa_20 lob_21 f1_24 g1_24\n    hiu_27 = __smulx_383x63 lou_22 lov_23 f0_25 g0_25\n    hiv_28 = __smulx_383x63 lou_22 lov_23 f1_26 g1_26\n    [f0_29, g0_29, f1_29, g1_29] = __ab_approximation_31 31 hia_25 hib_26\n    (loa_30, f0_30, g0_30) = __smulx_383_n_shift_by_31 hia_25 hib_26 f0_29 g0_29\n    (lob_31, f1_31, g1_31) = __smulx_383_n_shift_by_31 hia_25 hib_26 f1_29 g1_29\n    lou_32 = __smulx_383x63 hiu_27 hiv_28 f0_30 g0_30\n    lov_33 = __smulx_383x63 hiu_27 hiv_28 f1_31 g1_31\n    [f0_34, g0_34, f1_34, g1_34] = __ab_approximation_31 31 loa_30 lob_31\n    (hia_35, f0_35, g0_35) = __smulx_383_n_shift_by_31 loa_30 lob_31 f0_34 g0_34\n    (hib_36, f1_36, g1_36) = __smulx_383_n_shift_by_31 loa_30 lob_31 f1_34 g1_34\n    hiu_37 = __smulx_383x63 lou_32 lov_33 f0_35 g0_35\n    hiv_38 = __smulx_383x63 lou_32 lov_33 f1_36 g1_36\n    [f0_39, g0_39, f1_39, g1_39] = __ab_approximation_31 31 hia_35 hib_36\n    (loa_40, f0_40, g0_40) = __smulx_383_n_shift_by_31 hia_35 hib_36 f0_39 g0_39\n    (lob_41, f1_41, g1_41) = __smulx_383_n_shift_by_31 hia_35 hib_36 f1_39 g1_39\n    lou_42 = __smulx_383x63 hiu_37 hiv_38 f0_40 g0_40\n    lov_43 = __smulx_383x63 hiu_37 hiv_38 f1_41 g1_41\n    [f0_44, g0_44, f1_44, g1_44] = __ab_approximation_31 31 loa_40 lob_41\n    (hia_45, f0_45, g0_45) = __smulx_383_n_shift_by_31 loa_40 lob_41 f0_44 g0_44\n    (hib_46, f1_46, g1_46) = __smulx_383_n_shift_by_31 loa_40 lob_41 f1_44 g1_44\n    hiu_47 = __smulx_383x63 lou_42 lov_43 f0_45 g0_45\n    hiv_48 = __smulx_383x63 lou_42 lov_43 f1_46 g1_46\n    [f0_49, g0_49, f1_49, g1_49] = __ab_approximation_31 31 hia_45 hib_46\n    (loa_50, f0_50, g0_50) = __smulx_383_n_shift_by_31 hia_45 hib_46 f0_49 g0_49\n    (lob_51, f1_51, g1_51) = __smulx_383_n_shift_by_31 hia_45 hib_46 f1_49 g1_49\n    lou_52 = __smulx_383x63 hiu_47 hiv_48 f0_50 g0_50\n    lov_53 = __smulx_383x63 hiu_47 hiv_48 f1_51 g1_51\n    [f0_54, g0_54, f1_54, g1_54] = __ab_approximation_31 31 loa_50 lob_51\n    (hia_55, f0_55, g0_55) = __smulx_383_n_shift_by_31 loa_50 lob_51 f0_54 g0_54\n    (hib_56, f1_56, g1_56) = __smulx_383_n_shift_by_31 loa_50 lob_51 f1_54 g1_54\n    hiu_57 = __smulx_383x63 lou_52 lov_53 f0_55 g0_55\n    hiv_58 = __smulx_383x63 lou_52 lov_53 f1_56 g1_56\n    [f0_59, g0_59, f1_59, g1_59] = __ab_approximation_31 31 hia_55 hib_56\n    (loa_60, f0_60, g0_60) = __smulx_383_n_shift_by_31 hia_55 hib_56 f0_59 g0_59\n    (lob_61, f1_61, g1_61) = __smulx_383_n_shift_by_31 hia_55 hib_56 f1_59 g1_59\n    lou_62 = __smulx_383x63 hiu_57 hiv_58 f0_60 g0_60\n    lov_63 = __smulx_383x63 hiu_57 hiv_58 f1_61 g1_61\n    tmp64_r13_0 = sar (lov_63 @ 5) 0x3f\n    lov_64 = lov_63 # [tmp64_r13_0, tmp64_r13_0, tmp64_r13_0, tmp64_r13_0, tmp64_r13_0, tmp64_r13_0]\n    [f0_65, g0_65, f1_65, g1_65] = __ab_approximation_31 31 loa_60 lob_61\n    (hia_66, f0_66, g0_66) = __smulx_383_n_shift_by_31 loa_60 lob_61 f0_65 g0_65\n    (hib_67, f1_67, g1_67) = __smulx_383_n_shift_by_31 loa_60 lob_61 f1_65 g1_65\n    hiu_68 = __smulx_383x63 lou_62 (take lov_64) f0_66 g0_66\n    hiv_69 = __smulx_767x63 lou_62 lov_64 f1_67 g1_67\n    [f0_70, g0_70, f1_70, g1_70] = __ab_approximation_31 31 hia_66 hib_67\n    (loa_71, f0_71, g0_71) = __smulx_383_n_shift_by_31 hia_66 hib_67 f0_70 g0_70\n    (lob_72, f1_72, g1_72) = __smulx_383_n_shift_by_31 hia_66 hib_67 f1_70 g1_70\n    lou_73 = __smulx_383x63 hiu_68 (take hiv_69) f0_71 g0_71\n    lov_74 = __smulx_767x63 hiu_68 hiv_69 f1_72 g1_72\n    [f0_75, g0_75, f1_75, g1_75] = __ab_approximation_31 31 loa_71 lob_72\n    (hia_76, f0_76, g0_76) = __smulx_383_n_shift_by_31 loa_71 lob_72 f0_75 g0_75\n    (hib_77, f1_77, g1_77) = __smulx_383_n_shift_by_31 loa_71 lob_72 f1_75 g1_75\n    hiu_78 = __smulx_383x63 lou_73 (take lov_74) f0_76 g0_76\n    hiv_79 = __smulx_767x63 lou_73 lov_74 f1_77 g1_77\n    [f0_80, g0_80, f1_80, g1_80] = __ab_approximation_31 31 hia_76 hib_77\n    (loa_81, f0_81, g0_81) = __smulx_383_n_shift_by_31 hia_76 hib_77 f0_80 g0_80\n    (lob_82, f1_82, g1_82) = __smulx_383_n_shift_by_31 hia_76 hib_77 f1_80 g1_80\n    lou_83 = __smulx_383x63 hiu_78 (take hiv_79) f0_81 g0_81\n    lov_84 = __smulx_767x63 hiu_78 hiv_79 f1_82 g1_82\n    [f0_85, g0_85, f1_85, g1_85] = __ab_approximation_31 31 loa_81 lob_82\n    (hia_86, f0_86, g0_86) = __smulx_383_n_shift_by_31 loa_81 lob_82 f0_85 g0_85\n    (hib_87, f1_87, g1_87) = __smulx_383_n_shift_by_31 loa_81 lob_82 f1_85 g1_85\n    hiu_88 = __smulx_383x63 lou_83 (take lov_84) f0_86 g0_86\n    hiv_89 = __smulx_767x63 lou_83 lov_84 f1_87 g1_87\n    [f0_90, g0_90, f1_90, g1_90] = __ab_approximation_31 31 hia_86 hib_87\n    (loa_92, f0_92, g0_92) = __smulx_383_n_shift_by_31 hia_86 hib_87 f0_90 g0_90\n    (lob_93, f1_93, g1_93) = __smulx_383_n_shift_by_31 hia_86 hib_87 f1_90 g1_90\n    lou_94 = __smulx_383x63 hiu_88 (take hiv_89) f0_92 g0_92\n    lov_95 = __smulx_767x63 hiu_88 hiv_89 f1_93 g1_93\n    [f0_96, g0_96, f1_96, g1_96] = __ab_approximation_31 31 loa_92 lob_93\n    (hia_97, f0_97, g0_97) = __smulx_383_n_shift_by_31 loa_92 lob_93 f0_96 g0_96\n    (hib_98, f1_98, g1_98) = __smulx_383_n_shift_by_31 loa_92 lob_93 f1_96 g1_96\n    hiu_99 = __smulx_383x63 lou_94 (take lov_95) f0_97 g0_97\n    hiv_100 = __smulx_767x63 lou_94 lov_95 f1_98 g1_98\n    [f0_101, g0_101, f1_101, g1_101] = __ab_approximation_31 31 hia_97 hib_98\n    (loa_102, f0_102, g0_102) = __smulx_191_n_shift_by_31 (take`{3} hia_97) (take`{3} hib_98) f0_101 g0_101\n    (lob_103, f1_103, g1_103) = __smulx_191_n_shift_by_31 (take`{3} hia_97) (take`{3} hib_98) f1_101 g1_101\n    lou_104 = __smulx_383x63 hiu_99 (take hiv_100) f0_102 g0_102\n    lov_105 = __smulx_767x63 hiu_99 hiv_100 f1_103 g1_103\n    [f0_106, g0_106, f1_106, g1_106] = __ab_approximation_31 31 (loa_102 # drop`{3} loa_92) (lob_103 # drop`{3} lob_93)\n    (hia_107, f0_107, g0_107) = __smulx_191_n_shift_by_31 loa_102 lob_103 f0_106 g0_106\n    (hib_108, f1_108, g1_108) = __smulx_191_n_shift_by_31 loa_102 lob_103 f1_106 g1_106\n    hiu_109 = __smulx_383x63 lou_104 (take lov_105) f0_107 g0_107\n    hiv_110 = __smulx_767x63 lou_104 lov_105 f1_108 g1_108\n    [f0_111, g0_111, f1_111, g1_111] = __ab_approximation_31 31 (hia_107 # drop`{3} hia_97) (hib_108 # drop`{3} hib_98)\n    (loa_112, f0_112, g0_112) = __smulx_191_n_shift_by_31 hia_107 hib_108 f0_111 g0_111\n    (lob_113, f1_113, g1_113) = __smulx_191_n_shift_by_31 hia_107 hib_108 f1_111 g1_111\n    lou_114 = __smulx_383x63 hiu_109 (take hiv_110) f0_112 g0_112\n    lov_115 = __smulx_767x63 hiu_109 hiv_110 f1_113 g1_113\n    [f0_116, g0_116, f1_116, g1_116] = __ab_approximation_31 31 (loa_112 # drop`{3} loa_92) (lob_113 # drop`{3} lob_93)\n    (hia_117, f0_117, g0_117) = __smulx_191_n_shift_by_31 loa_112 lob_113 f0_116 g0_116\n    (hib_118, f1_118, g1_118) = __smulx_191_n_shift_by_31 loa_112 lob_113 f1_116 g1_116\n    hiu_119 = __smulx_383x63 lou_114 (take lov_115) f0_117 g0_117\n    hiv_120 = __smulx_767x63 lou_114 lov_115 f1_118 g1_118\n    earlyresult = take`{6} hiv_120\n    [f0_121, g0_121, f1_121, g1_121] = __inner_loop_62 55 (hia_117 @ 0) (hib_118 @ 0)\n    v_122 = __smulx_767x63 hiu_119 hiv_120 f1_121 g1_121\n    resultlow = take v_122\n    [r14_122, r15_122, rbx_122, rbp_122, rcx_122, rax_122] = drop v_122\n    rdx_123 = rax_122\n    tmp123_rax_0 = sar rax_122 0x3f\n    r8_123 = tmp123_rax_0 && (n @ 0)\n    r9_123 = tmp123_rax_0 && (n @ 1)\n    r10_123 = tmp123_rax_0 && (n @ 2)\n    r11_123 = tmp123_rax_0 && (n @ 3)\n    r12_123 = tmp123_rax_0 && (n @ 4)\n    rax_123 = tmp123_rax_0 && (n @ 5)\n    (tmp124_cf_0, r14_124) = add r14_122 r8_123\n    (tmp124_cf_1, r15_124) = adc r15_122 r9_123 tmp124_cf_0\n    (tmp124_cf_2, rbx_124) = adc rbx_122 r10_123 tmp124_cf_1\n    (tmp124_cf_3, rbp_124) = adc rbp_122 r11_123 tmp124_cf_2\n    (tmp124_cf_4, rcx_124) = adc rcx_122 r12_123 tmp124_cf_3\n    (tmp124_cf_5, rdx_124) = adc rdx_123 rax_123 tmp124_cf_4\n    result6 = r14_124\n    result7 = r15_124\n    result8 = rbx_124\n    result9 = rbp_124\n    result10 = rcx_124\n    result11 = rdx_124\n    result : Vec768\n    result = resultlow # [result6, result7, result8, result9, result10, result11]\n```"}]}
{"filename":"formal-verso\/example-proofs\/CustomTypes.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, write a specification that defines the same type alias T, constants, functions valid_with_heap and val_to_native with the given behavior over Values::{Symbol,MapObject,U32,Raw}, and add a property stating that valid_with_heap state_val heap implies val_to_native never uses the default 0 values."},{"role":"assistant","content":"```cryptol\nmodule CustomTypes where\n\nimport Option as Option\nimport Values as Values\nimport submodule Values::Symbol as Values::Symbol\nimport submodule Values::MapObject as Values::MapObject\nimport submodule Values::U32 as Values::U32\nimport submodule Values::Raw as Values::Raw\n\ntype T = ([32], [32])\n\ndefault_value : T\ndefault_value = (0, 0)\n\ncountsym : Values::Symbol::T\ncountsym = Values::Symbol::from_native \"count\"\nlastsym : Values::Symbol::T\nlastsym = Values::Symbol::from_native \"last_incr\"\n\ncountsym_raw : Values::Raw::T\ncountsym_raw = Values::Symbol::to_raw countsym\nlastsym_raw : Values::Raw::T\nlastsym_raw = Values::Symbol::to_raw lastsym\n\nvalid_with_heap : Values::MapObject::T -> Values::HostHeap -> Bool\nvalid_with_heap state_val heap =\n   Values::mapobj_has_key countsym_raw state_val heap \/\\\n   Values::mapobj_has_key lastsym_raw state_val heap \/\\\n   Values::raw_is_u32 count_val \/\\\n   Values::raw_is_u32 last_val\n   where\n      count_val = Values::mapobj_get countsym_raw state_val heap\n      last_val = Values::mapobj_get lastsym_raw state_val heap\n\nval_to_native : Values::MapObject::T -> Values::HostHeap -> T\nval_to_native state_val heap =\n   (count_native, last_native)\n   where\n      count_raw = Values::MapObject::get countsym_raw state_val heap\n      last_raw = Values::MapObject::get lastsym_raw state_val heap\n      count_optval = Values::U32::from_raw count_raw\n      last_optval = Values::U32::from_raw last_raw\n      count_val =\n         if Option::is_some count_optval then Option::unsafe_unwrap count_optval\n                                             else Values::U32::from_native 0\n      last_val =\n         if Option::is_some last_optval then Option::unsafe_unwrap last_optval\n                           else Values::U32::from_native 0\n      count_native = Values::U32::to_native count_val\n      last_native = Values::U32::to_native last_val\n```"}]}
{"filename":"formal-verso\/example-proofs\/CustomTypes2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the Cryptol module `CustomTypes2` implementing type `T = ([32],[32])`, the constant `default_value`, and the functions `valid_with_heap` and `val_to_native` over `Values::VecObject::T` and `Values::HostHeap`, matching the described heap-validity checks and U32 conversion behavior."},{"role":"assistant","content":"```cryptol\nmodule CustomTypes2 where\n\nimport Option as Option\nimport Values as Values\nimport submodule Values::Symbol as Values::Symbol\nimport submodule Values::VecObject as Values::VecObject\nimport submodule Values::U32 as Values::U32\nimport submodule Values::Raw as Values::Raw\n\ntype T = ([32], [32])\n\ndefault_value : T\ndefault_value = (0, 0)\n\nvalid_with_heap : Values::VecObject::T -> Values::HostHeap -> Bool\nvalid_with_heap state_val heap =\n   Values::vecobj_valid_with_heap state_val heap \/\\\n   Values::vecobj_len state_val heap == 2 \/\\\n   Values::raw_is_u32 count_val \/\\\n   Values::raw_is_u32 last_val\n   where\n      count_val = Values::vecobj_get state_val 0 heap\n      last_val = Values::vecobj_get state_val 1 heap\n\nval_to_native : Values::VecObject::T -> Values::HostHeap -> T\nval_to_native state_val heap =\n   (count_native, last_native)\n   where\n      count_raw = Values::VecObject::get state_val 0 heap\n      last_raw = Values::VecObject::get state_val 1 heap\n      count_optval = Values::U32::from_raw count_raw\n      last_optval = Values::U32::from_raw last_raw\n      count_val =\n         if Option::is_some count_optval then Option::unsafe_unwrap count_optval\n                                             else Values::U32::from_native 0\n      last_val =\n         if Option::is_some last_optval then Option::unsafe_unwrap last_optval\n                           else Values::U32::from_native 0\n      count_native = Values::U32::to_native count_val\n      last_native = Values::U32::to_native last_val\n```"}]}
{"filename":"formal-verso\/example-proofs\/DataKeyEnum.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `DataKeyEnum` that introduces type alias `T` as `(Values::SymbolT, Values::AddressObjectT)` and functions `to_raw : Values::VecObject::T -> Values::Val` and `from_native : T -> HostValues::Heap -> (HostValues::Heap, Values::VecObject::T)` with the given semantics."},{"role":"assistant","content":"```cryptol\nmodule DataKeyEnum where\n\nimport Values as Values\nimport HostValues as HostValues\nimport submodule Values::VecObject as Values::VecObject\nimport submodule Values::Raw as Values::Raw\n\ntype T = (Values::SymbolT, Values::AddressObjectT)\n\nto_raw : Values::VecObject::T -> Values::Val\nto_raw vecobj = Values::VecObject::to_raw vecobj\n\nfrom_native : T -> HostValues::Heap -> (HostValues::Heap, Values::VecObject::T)\nfrom_native v heap = (Values::VecObject::pair v.0.val v.1.val heap)\n```"}]}
{"filename":"formal-verso\/lib\/Store.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the Cryptol module `Store` with type `T = Store`, a private `newtype Store = { array : Array Raw::T [65] }`, and functions `has`, `get`, and `set` operating on `Raw::T` keys\/values using `Option::T` and `arrayLookup\/arrayUpdate` as in a key\u2013value store abstraction."},{"role":"assistant","content":"```cryptol\nmodule Store where\n\nimport Array\nimport Option as Option\nimport Values as Values\nimport submodule Values::Raw as Raw\n\ntype T = Store\n\nprivate\n  newtype Store = { array : Array Raw::T OptionRawVal }\n      type OptionRawVal = [65]\n\nhas : Store -> Raw::T -> Bit\nhas s k = Option::is_ok (get s k)\n\nget : Store -> Raw::T -> Option::T Raw::T\nget s k =\n   Option::mk (head orv) (Raw::from_payload (tail orv))\n   where orv = arrayLookup s.array k\n\nset : Store -> Raw::T -> Raw::T -> Store\nset s k v =\n   Store { array = arrayUpdate s.array k (0b1 # payload) }\n   where payload = Raw::get_payload v\n```"}]}
{"filename":"formal-verso\/lib\/Auth.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol the Auth module\u2019s authorization state machine, including the Auth record type, valid and initial predicates, invocation and authorize functions, and the fragment-matching\/check_fragment behavior over Heap, Addr, and Values::Symbol\/VecObject objects."},{"role":"assistant","content":"```cryptol\nmodule Auth where\n\nimport Values as Values\nimport submodule Values::Symbol as Values::Symbol\nimport submodule Values::AddressObject as Values::AddressObject\nimport submodule Values::VecObject as Values::VecObject\n\ntype T = Auth\n\nprivate\n\n      type NodeNum = [8]\n\n   newtype Auth = {\n            address: Addr,\n      numnodes: NodeNum,\n\n            contract: Values::Symbol::T,\n\n                  fragdone: Bool,\n      nextnode: NodeNum,\n\n            invokedcontract: Values::Symbol::T\n   }\n\n      type Heap = Values::HostHeap\n   type Addr = Values::AddressObject::T\n\nvalid: Auth -> Bool\nvalid auth = conditions\n   where\n      conditions =\n         fragment_valid &&\n         matchstate_valid &&\n         invokedcontract_valid\n            fragment_valid = (auth.numnodes == 1) && addr_valid && node_valid 0\n         where\n            addr_valid = Values::AddressObject::valid auth.address\n                                                            node_valid node = contract_valid\n               where\n                                    contract = auth.contract\n                  contract_valid = Values::Symbol::valid contract\n                              matchstate_valid = (nextnode == 0) || (nextnode < auth.numnodes)\n         where\n            nextnode = auth.nextnode\n      invokedcontract_valid =\n         Values::Symbol::valid auth.invokedcontract\n\ninitial: Auth -> Bool\ninitial auth = valid auth && (auth.fragdone == False) && (auth.nextnode == 0)\n\ninvocation: Heap -> Auth -> Values::Symbol::T -> Bool\ninvocation heap auth sym =\n   Values::Symbol::eq auth.invokedcontract sym heap\n\nprivate\n\n   makenodes: {n} (0 < n, n < 256) =>\n            [n] Values::Symbol::T -> (NodeNum, Values::Symbol::T)\n   makenodes nodes = (1, nodes ! 0)\n\nauthorize: {n} (0 < n, n < 256) =>\n   Auth -> Addr -> [n] Values::Symbol::T -> Auth\nauthorize auth addr nodes = auth'\n   where\n      \/\/(num, contracts) = makenodes nodes\n      (num, contract) = makenodes nodes\n      auth' = Auth {\n         address = addr,\n         numnodes = num,\n                  contract = contract,\n\n         fragdone = auth.fragdone,\n         nextnode = auth.nextnode,\n\n         invokedcontract = auth.invokedcontract\n      }\n\nprivate\n\n   set_nextnode: Auth -> Addr -> NodeNum -> Auth\n   set_nextnode auth addr node = auth'\n      where\n         auth' = Auth {\n            address = auth.address,\n            numnodes = auth.numnodes,\n                        contract = auth.contract,\n\n            fragdone = auth.fragdone,\n            nextnode = node,\n\n            invokedcontract = auth.invokedcontract\n         }\n\n   set_fragdone: Auth -> Bool -> Auth\n   set_fragdone auth state = auth'\n      where\n         auth' = Auth {\n            address = auth.address,\n            numnodes = auth.numnodes,\n                        contract = auth.contract,\n\n            fragdone = state,\n            nextnode = auth.nextnode,\n\n            invokedcontract = auth.invokedcontract\n         }\n\n   finish_fragment: Auth -> Addr -> Auth\n   finish_fragment auth addr = auth''\n      where\n         auth' = set_fragdone auth True\n         auth'' = set_nextnode auth' addr 0\n\n   advance_to_next_node: Auth -> Addr -> Auth\n   advance_to_next_node auth addr =\n      if done then finish_fragment auth addr\n      else set_nextnode auth addr nextnode'\n      where\n         nextnode' = auth.nextnode + 1\n         done = nextnode' >= auth.numnodes\n\n   \/*\n    * Check if the given node of the given fragment matches the\n    * contract presented for authorization (the contract in question\n    * is always the current invoked contract)\n    *\n    * For this version with only one node in the fragment, always\n    * use the only node. (The commented out code is for multiple\n    * nodes.)\n    *\/\n   match_node: Heap -> Auth -> NodeNum -> Bool\n   match_node heap auth _node = ok\n      where\n         \/\/contract = arrayLookup auth.contracts node\n         contract = auth.contract\n         ok = Values::Symbol::eq contract auth.invokedcontract heap\n\n   \/*\n    * Match against the fragment. If it has run out, or if match_node\n    * says the next node doesn't match, return false.\n    *\/\n   match_fragment: Heap -> Auth -> Addr -> Bool\n   match_fragment heap auth addr = (auth.nextnode < auth.numnodes) && matches\n      where\n         matches = addr_matches && node_matches\n         addr_matches = Values::addressobj_eq addr auth.address\n         node_matches = match_node heap auth auth.nextnode\n\n   check_fragment: Heap -> Auth -> Addr -> (Auth, Bool)\n   check_fragment heap auth addr =\n            if matches then to_nextnode else retry_nextfrag\n      where\n         matches = match_fragment heap auth addr\n                           to_nextnode = (auth', True)\n            where auth' = advance_to_next_node auth addr\n                  retry_nextfrag = (auth', False)\n            where\n               auth' = finish_fragment auth addr\n\ncheck_noargs: Heap -> Auth -> Addr -> (Auth, Bool)\ncheck_noargs heap auth addr = check_fragment heap auth addr\n\ncheck_withargs: Heap -> Auth -> Addr -> Values::VecObject::T -> (Auth, Bool)\ncheck_withargs heap auth addr _args = check_fragment heap auth addr\n```"}]}
{"filename":"formal-verso\/lib\/EventLog.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the EventLog type and add function as in the snippet, and write a property that proves equiv is an equivalence relation (reflexive, symmetric, transitive) over EventLog values with respect to a given Values::HostHeap."},{"role":"assistant","content":"```cryptol\nmodule Events where\n\nimport Array\n\nimport Values as Values\nimport submodule Values::Raw as Values::Raw\nimport submodule Values::VecObject as Values::VecObject\n\ntype T = EventLog\n\nprivate\n   type Topic = Values::VecObject::T\n   type Value = Values::Raw::T\n   type Topics = Array Integer Topic\n   type Values = Array Integer Value\n\n   newtype EventLog = {\n      topics: Topics,\n      values: Values,\n      count: Integer\n   }\n\nadd : EventLog -> Values::VecObject::T -> Values::Raw::T -> EventLog\nadd elog topic val =\n   EventLog { topics = topics', values = values', count = count' }\n   where\n      topics' = arrayUpdate elog.topics elog.count topic\n      values' = arrayUpdate elog.values elog.count val\n      count' = elog.count + 1\n\nprivate\n   equiv_entry : Topic -> Value -> Topic -> Value -> Values::HostHeap -> Bool\n   equiv_entry t1 v1 t2 v2 heap =\n      Values::vecobj_eq t1 t2 heap \/\\ Values::raw_eq v1 v2 heap\n\n   equiv_at : EventLog -> EventLog -> Values::HostHeap -> Integer -> Bool\n   equiv_at el1 el2 heap i =\n      if equiv_entry t1 v1 t2 v2 heap == False then False\n      | i >= el1.count then True\n      else equiv_at el1 el2 heap (i + 1)\n      where\n         t1 = arrayLookup el1.topics i\n         v1 = arrayLookup el1.values i\n         t2 = arrayLookup el2.topics i\n         v2 = arrayLookup el2.values i\n\nequiv : EventLog -> EventLog -> Values::HostHeap -> Bool\nequiv el1 el2 heap =\n   if el1.count != el2.count then False\n   else equiv_at el1 el2 heap 0\n```"}]}
{"filename":"formal-verso\/lib\/Option.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the Option module implementing the Option a record type and its helpers (ok, some, none, none', mk, is_ok, is_some, unsafe_unwrap, crashing_unwrap, unwrap_or, ok_implies, ok_and, fmap) with the same types and behavior as in the given specification."},{"role":"assistant","content":"```cryptol\nmodule Option where\n\ntype T a = Option a\n\ntype Option a =\n  { is_ok : Bit\n  , value : a\n  }\n\nok : {a} a -> Option a\nok x = mk True x\n\nsome : {a} a -> Option a\nsome x = mk True x\n\nnone : {a} Zero a => Option a\nnone = mk False zero\n\nnone' : {a} a -> Option a\nnone' z = mk False z\n\nmk : {a} Bit -> a -> Option a\nmk valid value = { is_ok = valid, value = value }\n\nis_ok : {a} Option a -> Bit\nis_ok o = o.is_ok\n\nis_some : {a} Option a -> Bit\nis_some o = o.is_ok\n\nunsafe_unwrap : {a} Option a -> a\nunsafe_unwrap o = o.value\n\ncrashing_unwrap : {a} Option a -> a\ncrashing_unwrap o = if o.is_ok then o.value else error \"Option::crashing_unwrap\"\n\nunwrap_or : {a} Option a -> a -> a\nunwrap_or o def = if o.is_ok then o.value else def\n\nok_implies : {a} (a -> Bit) -> Option a -> Bit\nok_implies p o = if o.is_ok then p o.value else True\n\nok_and : {a} (a -> Bit) -> Option a -> Bit\nok_and p o = if o.is_ok then p o.value else False\n\nfmap : {a, b} Option a -> (a -> b) -> Option b\nfmap o f =\n  { is_ok = o.is_ok\n  , value = f o.value\n  }\n```"}]}
{"filename":"formal-verso\/lib\/HostValues.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify the HostValues module implementing a tagged host heap with handles, vectors, maps, and alloc\/lookup\/present operations, including completing map_representation_equiv and proving that each lookup_* is inverse to its corresponding alloc_* when the handle is valid."},{"role":"assistant","content":"```cryptol\nmodule HostValues where\n\nimport Array\n\nimport Option as Option\n\ntype Handle = [32]\ntype RawRawVal = [64]\ntype Heap = HostHeap\n\narrayScatterConstant : {a, b, n} fin n => Array a b -> [n] a -> b -> Array a b\narrayScatterConstant arr ks v = arrs ! 0\n   where arrs = [arr] # [arrayUpdate arr' k v | arr' <- arrs | k <- ks]\n\narrayScatterVals : {a, b, n} fin n => Array a b -> [n] a -> [n] b -> Array a b\narrayScatterVals arr ks vs = arrs ! 0\n   where arrs = [arr] # [arrayUpdate arr' k v | arr' <- arrs | k <- ks | v <- vs]\n\ntype StringRepresentation = ()\n\nstring_representation_dummy : StringRepresentation\nstring_representation_dummy = ()\n\ninvalid_string_representation : StringRepresentation\ninvalid_string_representation = ()\n\ntype VecData = Array [32] RawRawVal\nnewtype VecRepresentation = {\n   data: VecData,\n   size: [32]\n}\n\nvec_representation_empty : VecRepresentation\nvec_representation_empty =\n   VecRepresentation { data = arrayConstant 0, size = 0 }\n\nvec_representation_singleton : RawRawVal -> VecRepresentation\nvec_representation_singleton n =\n   VecRepresentation { data = arr, size = 1 }\n   where arr = arrayUpdate (arrayConstant 0) 0 n\n\nvec_representation_pair : RawRawVal -> RawRawVal -> VecRepresentation\nvec_representation_pair n m =\n   VecRepresentation { data = arr, size = 2 }\n   where arr = arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m\n\nvec_representation_triple : RawRawVal -> RawRawVal -> RawRawVal -> VecRepresentation\nvec_representation_triple n m o =\n   VecRepresentation { data = arr, size = 3 }\n   where arr = arrayUpdate (arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m) 2 o\n\nvec_representation_quad : RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> VecRepresentation\nvec_representation_quad n m o p =\n   VecRepresentation { data = arr, size = 4 }\n   where arr = arrayUpdate (arrayUpdate (arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m) 2 o) 3 p\n\nvec_representation_quint : RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> VecRepresentation\nvec_representation_quint n m o p q =\n   VecRepresentation { data = arr, size = 5 }\n   where arr = arrayUpdate (arrayUpdate (arrayUpdate (arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m) 2 o) 3 p) 4 q\n\nvec_representation_n: [32] -> RawRawVal -> VecRepresentation\nvec_representation_n n v =\n   if n == 0 then vec_representation_empty\n   else vec_representation_addtail (vec_representation_n (n - 1) v) v\n\nvec_representation_seq: {n} n <= 0xffffffff => [n] RawRawVal -> VecRepresentation\nvec_representation_seq seq =\n   VecRepresentation { data = arr, size = `n }\n   where arr = arrayRangeUpdate (arrayConstant 0) 0 seq\n\ninvalid_vec_representation : VecRepresentation\ninvalid_vec_representation = vec_representation_empty\n\nvec_representation_get_default : VecRepresentation -> [32] -> RawRawVal -> RawRawVal\nvec_representation_get_default rep n dfl =\n   if n < rep.size then arrayLookup rep.data n else dfl\n\nvec_representation_getall : {n} n <= 0xffffffff => VecRepresentation -> RawRawVal -> [n] RawRawVal\nvec_representation_getall rep dfl = vals\n   where vals @ i = vec_representation_get_default rep i dfl\n\nprivate\n   vec_representation_equiv_at :\n          (RawRawVal -> RawRawVal -> Heap -> Bool) ->\n          VecRepresentation -> VecRepresentation -> Heap ->\n          [32] ->\n          Bool\n   vec_representation_equiv_at subcmp rep1 rep2 heap i =\n      if i >= rep1.size then True\n      | subcmp x1 x2 heap == False then False\n      else vec_representation_equiv_at subcmp rep1 rep2 heap (i + 1)\n      where\n         x1 = arrayLookup rep1.data i\n         x2 = arrayLookup rep2.data i\n\nvec_representation_equiv :\n       (RawRawVal -> RawRawVal -> Heap -> Bool) ->\n       VecRepresentation -> VecRepresentation -> Heap ->\n       Bool\nvec_representation_equiv subcmp rep1 rep2 heap =\n   if rep1.size != rep2.size then False\n   else vec_representation_equiv_at subcmp rep1 rep2 heap 0\n\nvec_representation_addtail : VecRepresentation -> RawRawVal -> VecRepresentation\nvec_representation_addtail rep v =\n   VecRepresentation { data = data', size = size' }\n   where\n      data' = arrayUpdate rep.data rep.size v\n      size' = rep.size + 1\n\ntype MapHere = Array RawRawVal Bool\ntype MapData = Array RawRawVal RawRawVal\nnewtype MapRepresentation = {\n   here: MapHere,\n   data: MapData\n}\n\nmap_representation_empty: MapRepresentation\nmap_representation_empty =\n   MapRepresentation { here = arrayConstant False, data = arrayConstant 0 }\n\nmap_representation_add: RawRawVal -> RawRawVal -> MapRepresentation -> MapRepresentation\nmap_representation_add k v rep =\n   MapRepresentation { here = here', data = data' }\n   where\n      here' = arrayUpdate rep.here k True\n      data' = arrayUpdate rep.data k v\n\nmap_representation_singleton: RawRawVal -> RawRawVal -> MapRepresentation\nmap_representation_singleton k v =\n   map_representation_add k v map_representation_empty\n\nmap_representation_pair: RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> MapRepresentation\nmap_representation_pair k1 v1 k2 v2 =\n   map_representation_add k2 v2 (map_representation_singleton k1 v1)\n\nmap_representation_seq: {n} n <= 0xffffffff => [n] RawRawVal -> [n] RawRawVal -> MapRepresentation\nmap_representation_seq ks vs =\n   MapRepresentation { here = here, data = data }\n   where\n      here = arrayScatterConstant empty.here ks True\n      data = arrayScatterVals empty.data ks vs\n      empty = map_representation_empty\n\ninvalid_map_representation : MapRepresentation\ninvalid_map_representation = map_representation_empty\n\nmap_representation_has_key : RawRawVal -> MapRepresentation -> Bool\nmap_representation_has_key k rep =\n   arrayLookup rep.here k\n\nmap_representation_get_default : RawRawVal -> MapRepresentation -> RawRawVal -> RawRawVal\nmap_representation_get_default k rep dfl =\n   if arrayLookup rep.here k == False then dfl\n   else arrayLookup rep.data k\n\nmap_representation_multiget_default : {n} [n] RawRawVal -> MapRepresentation -> RawRawVal -> [n] RawRawVal\nmap_representation_multiget_default ks rep dfl = result\n   where result @ i = map_representation_get_default (ks @ i) rep dfl\n\nmap_representation_equiv :\n       (RawRawVal -> RawRawVal -> Heap -> Bool) ->\n       MapRepresentation -> MapRepresentation -> Heap ->\n       Bool\nmap_representation_equiv _subcmp _rep1 _rep2 _heap =\n      error \"map_representation_equiv: not yet implemented\"\n\nprivate\n\n   type TypeTag = [2]\n   TagU64 = 0\n   TagString = 1\n   TagVec = 2\n   TagMap = 3\n\n   newtype HostHeap = {\n            types: Array Handle TypeTag,\n      values_u64: Array Handle [64],\n      values_string: Array Handle StringRepresentation,\n                        values_vecdata: Array Handle VecData,\n      values_vecsize: Array Handle [32],\n      values_maphere: Array Handle MapHere,\n      values_mapdata: Array Handle MapData,\n      next: Handle\n   }\n\nheap_has_space : Heap -> [32] -> Bool\nheap_has_space h headroom = h.next + headroom >= h.next\n\nempty_heap : Heap\nempty_heap =\n   HostHeap {\n      types = arrayConstant 0,\n      values_u64 = arrayConstant 0,\n      values_string = arrayConstant string_representation_dummy,\n      values_vecdata = arrayConstant (arrayConstant 0),\n      values_vecsize = arrayConstant 0,\n      values_maphere = arrayConstant (arrayConstant False),\n      values_mapdata = arrayConstant (arrayConstant 0),\n      next = 0\n   }\n\nalloc_u64 : [64] -> Heap -> (Heap, Handle)\nalloc_u64 n s = (s', handle)\n   where\n      handle = s.next\n      types' = arrayUpdate s.types handle TagU64\n      values_u64' = arrayUpdate s.values_u64 handle n\n      s' = HostHeap {\n         types = types',\n         values_u64 = values_u64',\n         values_string = s.values_string,\n         values_vecdata = s.values_vecdata,\n         values_vecsize = s.values_vecsize,\n         values_maphere = s.values_maphere,\n         values_mapdata = s.values_mapdata,\n         next = s.next + 1\n      }\n\nalloc_string : StringRepresentation -> Heap -> (Heap, Handle)\nalloc_string rep s = (s', handle)\n   where\n      handle = s.next\n      types' = arrayUpdate s.types handle TagString\n      values_string' = arrayUpdate s.values_string handle rep\n      s' = HostHeap {\n         types = types',\n         values_u64 = s.values_u64,\n         values_string = values_string',\n         values_vecdata = s.values_vecdata,\n         values_vecsize = s.values_vecsize,\n         values_maphere = s.values_maphere,\n         values_mapdata = s.values_mapdata,\n         next = s.next + 1\n      }\n\nalloc_vec : VecRepresentation -> Heap -> (Heap, Handle)\nalloc_vec rep s = (s', handle)\n   where\n      handle = s.next\n      types' = arrayUpdate s.types handle TagVec\n            values_vecdata' = arrayUpdate s.values_vecdata handle rep.data\n      values_vecsize' = arrayUpdate s.values_vecsize handle rep.size\n      s' = HostHeap {\n         types = types',\n         values_u64 = s.values_u64,\n         values_string = s.values_string,\n         values_vecdata = values_vecdata',\n         values_vecsize = values_vecsize',\n         values_maphere = s.values_maphere,\n         values_mapdata = s.values_mapdata,\n         next = s.next + 1\n      }\n\nalloc_map : MapRepresentation -> Heap -> (Heap, Handle)\nalloc_map rep s = (s', handle)\n   where\n      handle = s.next\n      types' = arrayUpdate s.types handle TagMap\n      values_maphere' = arrayUpdate s.values_maphere handle rep.here\n      values_mapdata' = arrayUpdate s.values_mapdata handle rep.data\n      s' = HostHeap {\n         types = types',\n         values_u64 = s.values_u64,\n         values_string = s.values_string,\n         values_vecdata = s.values_vecdata,\n         values_vecsize = s.values_vecsize,\n         values_maphere = values_maphere',\n         values_mapdata = values_mapdata',\n         next = s.next + 1\n      }\n\npresent_as_u64 : Handle -> Heap -> Bool\npresent_as_u64 h s =\n   if h >= s.next then False\n   | arrayLookup s.types h != TagU64 then False\n   else True\n\npresent_as_string : Handle -> Heap -> Bool\npresent_as_string h s =\n   if h >= s.next then False\n   | arrayLookup s.types h != TagString then False\n   else True\n\npresent_as_vec : Handle -> Heap -> Bool\npresent_as_vec h s =\n   if h >= s.next then False\n   | arrayLookup s.types h != TagVec then False\n   else True\n\npresent_as_map : Handle -> Heap -> Bool\npresent_as_map h s =\n   if h >= s.next then False\n   | arrayLookup s.types h != TagMap then False\n   else True\n\nlookup_u64 : Handle -> Heap -> Option::T [64]\nlookup_u64 h s =\n   if h >= s.next then Option::none' 0\n   | arrayLookup s.types h != TagU64 then Option::none' 0\n   else Option::some (arrayLookup s.values_u64 h)\n\nlookup_string : Handle -> Heap -> Option::T StringRepresentation\nlookup_string h s =\n   if h >= s.next then Option::none' invalid_string_representation\n   | arrayLookup s.types h != TagString then Option::none' invalid_string_representation\n   else Option::some (arrayLookup s.values_string h)\n\nlookup_vec : Handle -> Heap -> Option::T VecRepresentation\nlookup_vec h s =\n   if h >= s.next then Option::none' invalid_vec_representation\n   | arrayLookup s.types h != TagVec then Option::none' invalid_vec_representation\n   else\n      Option::some rep\n      where\n         data = arrayLookup s.values_vecdata h\n         size = arrayLookup s.values_vecsize h\n                  rep = VecRepresentation { data = data, size = size }\n\nlookup_map : Handle -> Heap -> Option::T MapRepresentation\nlookup_map h s =\n   if h >= s.next then Option::none' invalid_map_representation\n   | arrayLookup s.types h != TagMap then Option::none' invalid_map_representation\n   else\n      Option::some rep\n      where\n         here = arrayLookup s.values_maphere h\n         data = arrayLookup s.values_mapdata h\n         rep = MapRepresentation { here = here, data = data }\n```"}]}
{"filename":"formal-verso\/lib\/Log.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the newtype `Log` with field `count : Integer`, the type synonym `T = Log`, and the function `add : Log -> Log` that returns a `Log` whose `count` is incremented by 1."},{"role":"assistant","content":"```cryptol\nmodule Log where\n\nimport Option as Option\nimport Values as Values\nimport submodule Values::Raw as Raw\n\ntype T = Log\n\nprivate\n  newtype Log = { count : Integer }\n\nadd : Log -> Log\nadd ll = Log { count = ll.count + 1 }\n```"}]}
{"filename":"formal-verso\/lib\/Util.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the function `lenPolyEq : {a, n, m} (Eq a, fin n) => [n]a -> [m]a -> Bit` that returns equality of two sequences when their lengths match and `False` otherwise."},{"role":"assistant","content":"```cryptol\nmodule Util where\n\nlenPolyEq : {a, n, m} (Eq a, fin n) => [n]a -> [m]a -> Bit\nlenPolyEq xs ys\n  | n == m => xs == ys\n  | n != m => False\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/LLVM\/Permutations.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions bit_reversal_permutation_fast, bit_reversal_permutation_fast_rec, and swap, and a property bit_reversal_permutations_equiv showing that bit_reversal_permutation_fast is equivalent to bit_reversal_permutation from Spec::Permutations for all valid sizes and n."},{"role":"assistant","content":"```cryptol\nmodule LLVM::Permutations where\n\nimport Common::Utils\nimport Spec::Permutations\n\nbit_reversal_permutation_fast : {size, n}\n    (fin size, size >= 1, n >= 2, size * BYTE_WIDTH >= width n, 64 >= width n)\n    => [n][size * BYTE_WIDTH] -> [n][size * BYTE_WIDTH]\nbit_reversal_permutation_fast sequence =\n    bit_reversal_permutation_fast_rec`{size, n, width (n - 1)} sequence unused_bit_len 0\n    where\n        unused_bit_len = 64 - lg2 `(n)\n\nbit_reversal_permutation_fast_rec : {size, n, nbits}\n    (fin size, size >= 1, n >= 2, size * BYTE_WIDTH >= width n, 64 >= width n, nbits == width (n - 1))\n    => [n][size * BYTE_WIDTH] -> [64] -> [64] -> [n][size * BYTE_WIDTH]\nbit_reversal_permutation_fast_rec sequence unused_bit_len i =\n        if i >= `(n) then sequence\n        else if r > i\n        then bit_reversal_permutation_fast_rec`{size, n, nbits} sequence' unused_bit_len (i + 1)\n        else bit_reversal_permutation_fast_rec`{size, n, nbits} sequence unused_bit_len (i + 1)\n    where\n    r = (reverse i) >> unused_bit_len\n    sequence' = swap`{size, n} sequence i r\n\nswap : {size, n}\n    (fin size, size >= 1, n >= 2, size * BYTE_WIDTH >= width n, 64 >= width n)\n    => [n][size * BYTE_WIDTH] -> [64] -> [64] -> [n][size  * BYTE_WIDTH]\nswap values i r =\n    [swap_elem j | j <- [0 .. (n-1)]]\n    where\n        swap_elem j =\n            if j == r then values@i\n            else if j == i then values@r\n            else values@j\n\nbit_reversal_permutations_equiv : {size, n}\n    (fin size, size >= 1, n >= 2, size * BYTE_WIDTH >= width n, 64 >= width n)\n    => [n][size * BYTE_WIDTH] -> Bit\nproperty bit_reversal_permutations_equiv seq =\n    bit_reversal_permutation`{size * BYTE_WIDTH, n} seq == bit_reversal_permutation_fast`{size, n} seq\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/KZG.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module Spec::KZG that specifies the KZG commitment, proof, and batch verification algorithms used in Ethereum EIP-4844 (including blob_to_kzg_commitment, compute_kzg_proof, verify_kzg_proof, compute_blob_kzg_proof, verify_blob_kzg_proof, and their batch variants)."},{"role":"assistant","content":"```cryptol\nmodule Spec::KZG where\n\nimport Common::ModArith\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::G1\nimport Spec::BlsEC::GP\nimport Spec::BlsEC::Pairing\nimport Spec::BlsHelpers\nimport Spec::BlsSerde\nimport Spec::Permutations\nimport Spec::Polynomials\nimport Spec::TrustedSetup\n\nblob_to_kzg_commitment : Blob -> KZGCommitment\nblob_to_kzg_commitment blob =\n    g1_lincomb (bit_reversal_permutation KZG_SETUP_G1_LAGRANGE) (blob_to_polynomial blob)\n\ncompute_quotient_eval_within_domain : BlsFieldElement -> Polynomial -> BlsFieldElement -> BlsFieldElement\ncompute_quotient_eval_within_domain z polynomial y = toIntegral result where\n    result = sum [compute i | i <- [0 .. (FIELD_ELEMENTS_PER_BLOB-1)]]\n    f i = (fromIntegral (polynomial@i)) - (fromIntegral y)\n    omega i = fromIntegral`{BLS_MODULUS} (ROOTS_OF_UNITY_BRP@i)\n    numerator i = (f i) * (omega i)\n        denominator i = z' * (z' - (omega i))\n    z' = fromIntegral z\n    \/\/ Skip the evaluation point (z) in the sum\n    compute i = if omega i != z' then div_mod (numerator i) (denominator i) else 0\n\ncompute_kzg_proof_impl : Polynomial -> BlsFieldElement -> (KZGProof, BlsFieldElement)\ncompute_kzg_proof_impl polynomial z = (proof, y) where\n        y = evaluate_polynomial_in_evaluation_form polynomial z\n    polynomial_shifted = [(fromIntegral`{BLS_MODULUS} p) - (fromIntegral y) | p <- polynomial]\n        denominator_poly = [(fromIntegral`{BLS_MODULUS} x) - (fromIntegral z) | x <- ROOTS_OF_UNITY_BRP]\n        quotient_polynomial = [quotient i a b | a <- polynomial_shifted | b <- denominator_poly | i <- [0 .. FIELD_ELEMENTS_PER_BLOB-1]]\n        quotient : Integer -> Z BLS_MODULUS -> Z BLS_MODULUS -> BlsFieldElement\n    quotient i a b =\n        if b == 0 then\n                                    compute_quotient_eval_within_domain (ROOTS_OF_UNITY_BRP@i) polynomial y\n        else\n                        toIntegral (div_mod`{BLS_MODULUS} a b)\n    proof = g1_lincomb (bit_reversal_permutation KZG_SETUP_G1_LAGRANGE) quotient_polynomial\n\ncompute_kzg_proof : Blob -> Bytes32 -> (KZGProof, Bytes32)\ncompute_kzg_proof blob z_bytes = (proof, y) where\n    polynomial = blob_to_polynomial blob\n    (proof, y') = compute_kzg_proof_impl polynomial (bytes_to_bls_field z_bytes)\n    y = split`{BYTES_PER_FIELD_ELEMENT} y'\n\nverify_kzg_proof_impl : KZGCommitment -> BlsFieldElement -> BlsFieldElement -> KZGProof -> Bit\nverify_kzg_proof_impl commitment z y proof = pairing_check points where\n        x_minus_z = g2_add (bytes96_to_G2 (KZG_SETUP_G2_MONOMIAL@1)) g2_mult\n    g2_mult = g2_multi_optimized G2 ((`(BLS_MODULUS) - z) % `(BLS_MODULUS))\n    p_minus_y = g1_add (bytes48_to_G1 commitment) g1_mult\n    g1_mult = g1_multi_optimized G1 ((`(BLS_MODULUS) - y) % `(BLS_MODULUS))\n    points = [(p_minus_y, (g2_negate G2)), ((bytes48_to_G1 proof), x_minus_z)]\n\nverify_kzg_proof : Bytes48 -> Bytes32 -> Bytes32 -> Bytes48 -> Bit\nverify_kzg_proof commitment_bytes z_bytes y_bytes proof_bytes =\n    verify_kzg_proof_impl (bytes_to_kzg_commitment commitment_bytes)\n                          (bytes_to_bls_field z_bytes)\n                          (bytes_to_bls_field y_bytes)\n                          (bytes_to_kzg_proof proof_bytes)\n\ncompute_challenge: Blob -> KZGCommitment -> BlsFieldElement\ncompute_challenge blob commitment = result where\n    degree_poly = groupBy`{8, 16} `(FIELD_ELEMENTS_PER_BLOB)\n    commitment_bytes = groupBy`{8} commitment\n    data = FIAT_SHAMIR_PROTOCOL_DOMAIN # degree_poly # blob # commitment_bytes\n    result = hash_to_bls_field data\n\ncompute_blob_kzg_proof: Blob -> Bytes48 -> KZGProof\ncompute_blob_kzg_proof blob commitment_bytes = proof where\n    commitment = bytes_to_kzg_commitment commitment_bytes\n    polynomial = blob_to_polynomial blob\n    evaluation_challenge = compute_challenge blob commitment\n    (proof, e) = compute_kzg_proof_impl polynomial evaluation_challenge\n\nverify_blob_kzg_proof: Blob -> Bytes48 -> Bytes48 -> Bit\nverify_blob_kzg_proof blob commitment_bytes proof_bytes =\n    verify_kzg_proof_impl commitment evaluation_challenge y proof where\n        commitment = bytes_to_kzg_commitment commitment_bytes\n        polynomial = blob_to_polynomial blob\n        evaluation_challenge = compute_challenge blob commitment\n        y = evaluate_polynomial_in_evaluation_form polynomial evaluation_challenge\n        proof = bytes_to_kzg_proof proof_bytes\n\nverify_kzg_proof_batch : {k} (fin k, 64 >= width k) => [k]KZGCommitment -> [k]BlsFieldElement -> [k]BlsFieldElement -> [k]KZGProof -> Bit\nverify_kzg_proof_batch commitments zs ys proofs = pairing_check points where\n    degree_poly = groupBy`{8, 8} `(FIELD_ELEMENTS_PER_BLOB)\n    num_commitments = groupBy`{8, 8} `(k)\n    data_1 = RANDOM_CHALLENGE_KZG_BATCH_DOMAIN # degree_poly # num_commitments\n    data_2 = [ c # z # y # p | c <- commitments | z <- zs | y <- ys | p <- proofs ]\n    data = data_1 # (groupBy`{8} (join data_2))\n    r = hash_to_bls_field data\n    r_powers = compute_powers`{k} r \n    proof_lincomb = g1_lincomb proofs r_powers\n    proof_z_lincomb = g1_lincomb proofs ([z * r_power | z <- zs | r_power <- r_powers])\n    C_minus_ys = [ g1_add (bytes48_to_G1 commitment) (g1_multi G1 ((`(BLS_MODULUS) - y) % `(BLS_MODULUS))) \n                    | commitment <- commitments | y <- ys ] \n    C_minus_y_as_KZGCommitments = [ g1_to_bytes48 x | x <- C_minus_ys ]\n    C_minus_y_lincomb = g1_lincomb C_minus_y_as_KZGCommitments r_powers\n    points = [((bytes48_to_G1 proof_lincomb), (g2_negate (bytes96_to_G2 (KZG_SETUP_G2_MONOMIAL@1)))),\n                            ((g1_add (bytes48_to_G1 C_minus_y_lincomb) (bytes48_to_G1 proof_z_lincomb)), G2)]\n\nverify_blob_kzg_proof_batch : {k} (fin k, 64 >= width k) => [k]Blob -> [k]Bytes48 -> [k]Bytes48 -> Bit\nverify_blob_kzg_proof_batch blobs commitments_bytes proofs_bytes = verify_kzg_proof_batch commitments evaluation_challenges ys proofs where\n    commitments = map bytes_to_kzg_commitment commitments_bytes\n    polynomials = map blob_to_polynomial blobs \n    evaluation_challenges = [ compute_challenge blob commitment | blob <- blobs | commitment <- commitments ] \n    ys = [ evaluate_polynomial_in_evaluation_form polynomial evaluation_challenge | polynomial <- polynomials | evaluation_challenge <- evaluation_challenges ]\n    proofs = [ bytes_to_kzg_proof proof_bytes | proof_bytes <- proofs_bytes]\n\nvalid_blob_generator : Blob -> Blob\nvalid_blob_generator blob = assert (blob != blob') \"error\" blob' where\n    x = [bytes | bytes <- (groupBy`{BYTES_PER_FIELD_ELEMENT} blob)]\n    y = map (\\b -> (join b)) x\n    y' = map (\\b -> b % `BLS_MODULUS) y\n    x' = [groupBy`{8} poly | poly <- y']\n    blob' = join x'\n\n\/**\n * This function is used to generate a random, valid Z bytes.\n *\/\nz_bytes_generator : Bytes32 -> Bytes32\nz_bytes_generator z = z\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsSerde.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the Cryptol functions and properties for BLS12-381 G1\/G2 point compression\/decompression and key validation as in EIP-4844, including constants, test vectors, and the property that decompress(compress(point)) == point for all valid points."},{"role":"assistant","content":"```cryptol\nmodule Spec::BlsSerde where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::FQP\nimport Spec::BlsEC::G1\nimport Spec::BlsEC::GP\n\ntype G1Bits = 384\n\ntype Bytes48 = [G1Bits]\n\nPOW_2_381 = 2^^381\nPOW_2_382 = 2^^382\nPOW_2_383 = 2^^383\n\nG1_POINT_AT_INFINITY : Bytes48\nG1_POINT_AT_INFINITY = 0xc0 # zero\n\nget_flags : Bytes48 -> (Bit, Bit, Bit)\nget_flags z = (c_flag, b_flag, a_flag) where\n            c_flag = ((z >> 383) && 1)!0      b_flag = ((z >> 382) && 1)!0      a_flag = ((z >> 381) && 1)!0  \n\ndecompress_G1 : Bytes48 -> G1Point\ndecompress_G1 z =\n            if ~c_flag then\n        error \"decompress_G1: c_flag must be 1\"\n     | b_flag != isInfinity then\n        error \"b_flag should be 1\"\n     | b_flag then\n                if a_flag then\n            error \"decompress_G1: a point at infinity should have a_flag == 0\"\n        else G1_INFINITY\n               | xBits >= q then\n        error \"decompress_G1: point value should be less than field modulus\"\n     | (y^^2) != (x^^3 + b) then\n        error \"The given point is not on G1: y^^2 = x^^3 + 4\"\n          | (((fromZ y) * 2) \/ q) != (bit_to_integer a_flag) then\n        { xCoord = x, yCoord = y'}\n     else\n        { xCoord = x, yCoord = y}\n     where\n        isInfinity = (z % POW_2_381) == 0\n        \/\/ We want to use the type Z Fq for all modular arithmetic, but\n        \/\/  we have to use Fq as a value which is not allowable with\n        \/\/  Z Fq, so we sometimes need to convert back and forth between\n        \/\/  Z Fq and Integer.\n        (c_flag, b_flag, a_flag) = get_flags z\n        xBits = (toInteger z) % POW_2_381\n        x = fromInteger xBits\n        q = `(Fq)\n        b = 4 : Z Fq \/\/ Our elliptic curve equation is y^^2 = x^^3 + 4\n        \/\/ Try solving y coordinate from the equation y^^2 = x^^3 + b using quadratic residue\n        y = pow_mod base exp\n        base = x^^3 + b\n        exp = ((q + 1) \/ 4) % q\n        y' = fromInteger (q - (fromZ y))\n\ncompress_G1 : G1Point -> Bytes48\ncompress_G1 point =\n    if point == G1_INFINITY then\n                fromInteger (POW_2_383 + POW_2_382)\n    else\n                fromInteger (x + a_flag * POW_2_381 + POW_2_383)\n    where\n                x = fromZ point.xCoord\n        y = fromZ point.yCoord\n        q = toInteger `(Fq)\n        a_flag = (y * 2) \/ q\n\ncheck_compression_decompress_inverse : G1Point -> Bit\nproperty check_compression_decompress_inverse point = precondition ==> statement where\n    precondition = g1_is_valid_point point\n    statement = decompress_G1 (compress_G1 point) == point\n\nkey_validate : Bytes48 -> Bit\nkey_validate bytes =\n    if bytes == G1_POINT_AT_INFINITY then\n        False\n    else\n        subgroup_check point\n    where\n        point = decompress_G1 bytes\n\nG1_INVALID_INFINITY_COMPRESSED : Bytes48\nG1_INVALID_INFINITY_COMPRESSED = c_flag + b_flag + a_flag where\n    c_flag = (1 << 383)     b_flag = (1 << 382)     a_flag = (1 << 381) \n\nG1_INVALID_TO_BIG_COMPRESSED : Bytes48\nG1_INVALID_TO_BIG_COMPRESSED = c_flag + `(Fq) + 1 where\n    c_flag = (1 << 383) \n\nG1_INVALID_POINT_COMPRESSED : Bytes48\nG1_INVALID_POINT_COMPRESSED = c_flag + b_flag + a_flag + 13 where\n    c_flag = (1 << 383)     b_flag = (0 << 382)     a_flag = (1 << 381) \n\nG1_1P_COMPRESSED : Bytes48\nG1_1P_COMPRESSED = c_flag + b_flag + a_flag + (toIntegral G1.xCoord) where\n    c_flag = (1 << 383)     b_flag = (0 << 382)     a_flag = (0 << 381) \n\nG1_2P_COMPRESSED : Bytes48\nG1_2P_COMPRESSED = c_flag + b_flag + a_flag + (toIntegral G1_2P.xCoord) where\n    c_flag = (1 << 383)     b_flag = (0 << 382)     a_flag = (1 << 381) \n\nG1_3P_COMPRESSED : Bytes48\nG1_3P_COMPRESSED = c_flag + b_flag + a_flag + (toIntegral G1_3P.xCoord) where\n    c_flag = (1 << 383)     b_flag = (0 << 382)     a_flag = (0 << 381) \n\nG1_7P_COMPRESSED : Bytes48\nG1_7P_COMPRESSED = c_flag + b_flag + a_flag + (toIntegral G1_7P.xCoord) where\n    c_flag = (1 << 383)     b_flag = (0 << 382)     a_flag = (1 << 381) \n\ntype G2Bits = 768\n\ntype Bytes96 = [G2Bits]\n\nG2_POINT_AT_INFINITY : Bytes96\nG2_POINT_AT_INFINITY = 0xc0 # zero\n\nG2_2P_COMPRESSED : Bytes96\nG2_2P_COMPRESSED = c_flag + b_flag + a_flag + x_real + x_imag where\n    c_flag = (1 << 767)     b_flag = (0 << 766)     a_flag = (1 << 765)     x_real = (toIntegral (G2_2P.xCoeffs@0))\n    x_imag = (toIntegral (G2_2P.xCoeffs@1)) << 384\n\nG2_3P_COMPRESSED : Bytes96\nG2_3P_COMPRESSED = c_flag + b_flag + a_flag + x_real + x_imag where\n    c_flag = (1 << 767)     b_flag = (0 << 766)     a_flag = (0 << 765)     x_real = (toIntegral (G2_3P.xCoeffs@0))\n    x_imag = (toIntegral (G2_3P.xCoeffs@1)) << 384\n\ncompress_G2 : G2Point -> Bytes96\ncompress_G2 point =\n    if point == G2_INFINITY then\n                (fromInteger (POW_2_383 + POW_2_382)) # (zero:[G1Bits])\n    else\n        z1Bits + z2Bits\n    where\n        x_re = fromZ (point.xCoeffs@0)\n        x_im = fromZ (point.xCoeffs@1)\n        y_re = fromZ (point.yCoeffs@0)\n        y_im = fromZ (point.yCoeffs@1)\n        q = toInteger `(Fq)\n                        a_flag1 = if y_im > 0 then (y_im * 2) \/ q else (y_re * 2) \/ q\n                        z1 = x_im + a_flag1 * POW_2_381 + POW_2_383\n        z2 = x_re\n        z1Bits = (fromInteger z1) # (zero:[G1Bits])\n        z2Bits = (fromInteger z2)\n\ndecompress_G2 : Bytes96 -> G2Point\ndecompress_G2 z =\n            if ~c_flag1 then\n        error \"decompress_G2: c_flag1 must be 1\"\n     | b_flag1 != is_inf_pt then\n        error \"b_flag1 should be 1\"\n     | b_flag1 then\n                if a_flag1 then\n            error \"decompress_G2: a point at infinity should have a_flag1 == 0\"\n        else G2_INFINITY\n                    | x1Bits >= q then\n        error \"decompress_G2: x1 value should be less than field modulus\"\n          | z2 >= (fromInteger q) then\n        error \"decompress_G2: z2 value should be less than field modulus\"\n                    | (y_im > 0) && condition1 then\n        { xCoeffs = x\n        , yCoeffs = (y ~* -1)\n        }\n     | (y_im == 0) && condition2 then\n        { xCoeffs = x\n        , yCoeffs = (y ~* -1)\n        }\n     else\n        { xCoeffs = x\n        , yCoeffs = y\n        }\n    where\n    is_inf_pt = ((z1 % POW_2_381) == 0) && (z2 == 0)\n    z1 = take`{G2Bits \/ 2} z\n    z2 = drop`{G2Bits \/ 2} z\n    (c_flag1, b_flag1, a_flag1) = get_flags z1\n    x1Bits = (toInteger z1) % POW_2_381\n    x1 = fromInteger x1Bits\n    q = `(Fq)\n    x2 = fromIntegral`{Fq} z2\n        x = [x2, x1]\n    y = fq2_modular_squareroot (x~^^3 ~+~ b2)\n    (y_re, y_im) = (fromZ (y@0), fromZ (y@1))\n    b2 = FQ2_B2\n    condition1 = ((y_im * 2) \/ q) != (bit_to_integer (a_flag1))\n    condition2 = ((y_re * 2) \/ q) != (bit_to_integer (a_flag1))\n\nfq2_modular_squareroot : Fq2 -> Fq2\nfq2_modular_squareroot value =\n    if elem check EVEN_EIGHTH_ROOTS_OF_UNITY then\n        if ((x1_im > x2_im) || ((x1_im == x2_im) && (x1_re > x2_re))) then x1 else x2\n    else\n        error \"Failed to find a modular squareroot\"\n    where\n        candidate_squareroot = value~^^((FQ2_ORDER + 8) \/ 16)\n        check = candidate_squareroot~^^2 ~\/~ value\n        candidate_rou_index = (find_eighth_root_of_unity_index check) \/ 2\n        x1 = candidate_squareroot ~\/~ (EIGHTH_ROOTS_OF_UNITY@candidate_rou_index)\n        x2 = fqp_neg x1\n        (x1_re, x1_im) = (fromZ (x1@0), fromZ (x1@1))\n        (x2_re, x2_im) = (fromZ (x2@0), fromZ (x2@1))\n\nFQ2_ONE = [1, 1]\nEIGHTH_ROOTS_OF_UNITY = [FQ2_ONE~^^((FQ2_ORDER * k) \/ 8) | k <- [0..7]]\nEVEN_EIGHTH_ROOTS_OF_UNITY = [EIGHTH_ROOTS_OF_UNITY@i | i <- [0, 2, 4, 6]]\n\nfind_eighth_root_of_unity_index : Fq2 -> Integer\nfind_eighth_root_of_unity_index value =\n    sum [if value == rou then i else 0 | rou <- EVEN_EIGHTH_ROOTS_OF_UNITY | i <- [0, 2, 4, 6]]\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsHelpers.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol the BLS helper functions and types used in EIP-4844 KZG verification, including bls_modular_inverse, bls_div, compute_powers, g1_multi_exp, (de)serialization for G1\/G2 points and KZG commitments\/proofs, compute_roots_of_unity, and the test_compute_roots_of_unity property."},{"role":"assistant","content":"```cryptol\nmodule Spec::BlsHelpers where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::G1\nimport Spec::BlsEC::GP\nimport Spec::BlsSerde\n\ntype BlsFieldSize = 256\ntype BlsFieldElement = [BlsFieldSize]\n\nbls_modular_inverse : BlsFieldElement -> BlsFieldElement\nbls_modular_inverse x = toIntegral (modular_inverse x') where\n    x' = fromIntegral`{BLS_MODULUS} x\n\nbls_div : BlsFieldElement -> BlsFieldElement -> BlsFieldElement\nbls_div x y = toIntegral (div_mod x' y') where\n    x' = fromIntegral`{BLS_MODULUS} x\n    y' = fromIntegral`{BLS_MODULUS} y\n\ncompute_powers : {n} (fin n, width n <= 64) => BlsFieldElement -> [n]BlsFieldElement\ncompute_powers x\n    | n == 0 => []\n    | n == 1 => [1]\n    | n == 2 => [1, x]\n    | n > 2 => powers where\n        x' = fromIntegral`{BLS_MODULUS} x\n        powers' = [1] # [(powers'@i) * x' | i <- [0 .. n-2]]\n        powers = map toIntegral powers'\n\n\/**\n * Performs a multi-scalar multiplication between G1 `points` and `scalars`.\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dev\/specs\/deneb\/polynomial-commitments.md#multi_exp\n * For the actual implementation,\n *   @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/85e2452301382a9d099df16f38deac8178355358\/tests\/core\/pyspec\/eth2spec\/utils\/bls.py#L262\n * NOTE: the Python multi_exp handles both G1 and G2 points, and just calls their\n *  corresponding `add` and `multiply` functions. This implementation is for G1 points only.\n * ```repl\n * :check g1_multi_exp`{1} [G1] [1] == G1\n * :check g1_multi_exp`{2} [G1, G1] [2, 3] == G1_5P\n * :check g1_multi_exp`{2} [G1_3P, G1_2P] [1, 2] == G1_7P\n * :check g1_multi_exp`{3} [G1_4P, G1_2P, G1_3P] [2, 3, 5] == g1_multi_exp`{2} [G1_5P, G1_7P] [3, 2]\n * ```\n *\/\ng1_multi_exp : {len} (fin len, len >= 1) => [len]G1Point -> [len]UInt256 -> G1Point\ng1_multi_exp points scalars = results!0 where\n    results = [G1_INFINITY] # [g1_add r (g1_multi_optimized p s) | r <- results | p <- points | s <- scalars]\n\n\/**\n * Deserialize the G1 bytes into a G1 point\n * @see https:\/\/github.com\/ethereum\/consensus-specs\/blob\/dcdcf25d8152cd078a9888eeddda4a550e1de009\/tests\/core\/pyspec\/eth2spec\/utils\/bls.py#L337\n * ```repl\n * :check bytes48_to_G1 G1_POINT_AT_INFINITY == G1_INFINITY\n * :check bytes48_to_G1 G1_2P_COMPRESSED == G1_2P\n * :check bytes48_to_G1 G1_7P_COMPRESSED == G1_7P\n * ```\n * NOTE: We're not testing any of the invalid points since they throw runtime errors,\n *  and Cryptol does not have a way to expect that. One can manually test to verify\n *  these errors are thrown.\n *\/\nbytes48_to_G1 : Bytes48 -> G1Point\nbytes48_to_G1 bytes = decompress_G1 bytes\n\ng1_to_bytes48 : G1Point -> Bytes48\ng1_to_bytes48 point = compress_G1 point\n\nbytes96_to_G2 : Bytes96 -> G2Point\nbytes96_to_G2 bytes = decompress_G2 bytes\n\ng2_to_bytes96 : G2Point -> Bytes96\ng2_to_bytes96 point = compress_G2 point\n\ntype KZGCommitment = Bytes48\n\ng1_lincomb : {n} (fin n) => [n]KZGCommitment -> [n]BlsFieldElement -> KZGCommitment\ng1_lincomb points scalars\n    | n == 0 => G1_POINT_AT_INFINITY\n    | n > 0 => g1_to_bytes48 result where\n        points_g1 = [bytes48_to_G1 point | point <- points]\n        result = g1_multi_exp`{n} points_g1 scalars\n\nPRIMITIVE_ROOT_OF_UNITY : Z BLS_MODULUS\nPRIMITIVE_ROOT_OF_UNITY = 7\n\ncompute_roots_of_unity : {n} (fin n, width n <= 64) => UInt64 -> [n]BlsFieldElement\ncompute_roots_of_unity order = assert (order == `n) \"order must be equal to n\" result where\n        order' = toInteger order\n        root_of_unity = pow_mod PRIMITIVE_ROOT_OF_UNITY ((`(BLS_MODULUS) - 1) \/ order')\n        root_of_unity' = toIntegral root_of_unity\n        result = compute_powers`{n} root_of_unity'\n\ntype BYTES_PER_COMMITMENT = 48\n\ntype BYTES_PER_PROOF = 48\n\ntype BYTES_PER_FIELD_ELEMENT = 32\n\ntype Bytes32 = [BYTES_PER_FIELD_ELEMENT][8]\n\nbytes_to_bls_field : Bytes32 -> BlsFieldElement\nbytes_to_bls_field bytes = assert (field_element < `(BLS_MODULUS)) error_msg field_element where\n    field_element = join bytes     error_msg = \"BLS scalar field element must be less than modulus\"\n\nbls_field_to_bytes : BlsFieldElement -> Bytes32 \nbls_field_to_bytes value = groupBy`{8} value\n\nvalidate_kzg_g1 : Bytes48 -> Bit\nvalidate_kzg_g1 b =\n    if b == G1_POINT_AT_INFINITY then True\n    else key_validate b\n\nbytes_to_kzg_commitment : Bytes48 -> KZGCommitment\nbytes_to_kzg_commitment b =\n    assert (validate_kzg_g1 b) \"validate_kzg_g1 failed\" b\n\ntype KZGProof = Bytes48\n\nbytes_to_kzg_proof : Bytes48 -> KZGProof\nbytes_to_kzg_proof b =\n    assert (validate_kzg_g1 b) \"validate_kzg_g1 failed\" b\n\ntest_compute_roots_of_unity : Bit\nproperty test_compute_roots_of_unity =\n    compute_roots_of_unity`{4} 4 == expected_roots where\n    expected_roots =\n        [ 0x0000000000000000000000000000000000000000000000000000000000000001\n        , 0x00000000000000008d51ccce760304d0ec030002760300000001000000000000\n        , 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000000\n        , 0x73eda753299d7d47a5e80b39939ed33467baa40089fb5bfefffeffff00000001\n        ]\n\nhash_to_bls_field: {n} (fin n, n >= 1) => [n][8] -> BlsFieldElement\nhash_to_bls_field data = 0\n\nFIAT_SHAMIR_PROTOCOL_DOMAIN : [16][8]\nFIAT_SHAMIR_PROTOCOL_DOMAIN = \"FSBLOBVERIFY_V1_\" : [16][8]\nRANDOM_CHALLENGE_KZG_BATCH_DOMAIN : [16][8]\nRANDOM_CHALLENGE_KZG_BATCH_DOMAIN = \"RCKZGBATCH___V1_\" : [16][8]\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/Permutations.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Spec::Permutations that defines is_power_of_two, is_power_of_two_bit, reverse_bits, reverse_bits_limited, and bit_reversal_permutation with the given type constraints, and the properties check_is_power_of_two, check_reverse_bits_involution, check_reverse_bits_equiv, and check_bit_reversal_permutation_involution that verify their stated behaviors."},{"role":"assistant","content":"```cryptol\nmodule Spec::Permutations where\n\nimport Common::Utils\n\nis_power_of_two : {n} (fin n, n >= 1) => [n] -> [1]\nis_power_of_two value = bit_to_bool (is_power_of_two_bit value)\n\nis_power_of_two_bit : {n} (fin n, n >= 1) => [n] -> Bit\nis_power_of_two_bit value = (value > 0) && ((value && (value - 1)) == 0)\n\nreverse_bits : {n, order_bit_length} (fin n, n >= 1, order_bit_length >= 1, order_bit_length <= n)\n    => [n] -> [n]\nreverse_bits value = zero # reverse (drop`{n - order_bit_length} value)\n\nreverse_bits_limited : [64] -> [64] -> [64]\nreverse_bits_limited order value = (reverse value) >> unused_bit_len where\n    unused_bit_len = 64 - lg2 order\n\nbit_reversal_permutation : {size, len} (fin size, size >= 1, len >= 2, size >= width (len - 1))\n    => [len][size] -> [len][size]\nbit_reversal_permutation sequence =\n    [sequence@(reverse_bits`{size, width (len - 1)} i) | i <- [0 .. (len-1)]]\n\nproperty check_is_power_of_two = all is_power_of_two_bit`{4096} [ 2^^n | n <- [0 .. 4096-1]]\n\ncheck_reverse_bits_involution : {n, order_bit_length} (fin n, n >= 1, order_bit_length >= 1, order_bit_length <= n)\n    => [n] -> Bit\nproperty check_reverse_bits_involution val = precondition ==> statement where\n    precondition = lg2 val < `order_bit_length\n    statement = (reverse_bits`{n, order_bit_length} (reverse_bits`{n, order_bit_length} val)) == val\n\ncheck_reverse_bits_equiv : {order_bit_length} (order_bit_length >= 1, order_bit_length <= 64)\n    => [64] -> [64] -> Bit\nproperty check_reverse_bits_equiv order val = precondition ==> statement where\n    precondition = lg2 order == `order_bit_length\n    statement = reverse_bits`{64, order_bit_length} val == reverse_bits_limited order val\n\ncheck_bit_reversal_permutation_involution : {size, len} (fin size, size >= 1, len >= 2, size >= width (len - 1))\n    => [len][size] -> Bit\nproperty check_bit_reversal_permutation_involution val =\n    (bit_reversal_permutation`{size, len} (bit_reversal_permutation`{size, len} val)) == val\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Common\/ModArith.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the Common::ModArith module that implements modular arithmetic over Z n, including fromIntegral, toIntegral, xgcd, multinv, modular_inverse, div_mod, and pow_mod with the same types and behaviors as described, suitable for use in CKZG EIP-4844 verification."},{"role":"assistant","content":"```cryptol\nmodule Common::ModArith where\n\nfromIntegral : {n, m} (fin n, n >= 1, fin m, m >= 1) => [m] -> Z n\nfromIntegral value = fromInteger (toInteger value)\n\ntoIntegral : {n, m} (fin n, n >= 1, fin m, m >= 1) => Z n -> [m]\ntoIntegral value = fromInteger (fromZ value)\n\nxgcd : Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> (Integer, Integer, Integer)\nxgcd a b s1 s2 t1 t2 =\n    if b == 0 then\n        (abs (a), 1, 0)\n            else if r == 0 then\n        (abs (b), s2, t2)\n    else\n        xgcd b r s2 s3 t2 t3\n    where\n        q = a \/ b\n        r = a - q * b\n        s3 = s1 - q * s2\n        t3 = t1 - q * t2\n\nmultinv : Integer -> Integer -> Integer\nmultinv x m =\n        if gcd == 1\n    then t % m\n    else 0\n                where (gcd, s, t) = xgcd m x 1 0 0 1\n\nmodular_inverse : {n} (fin n, n >= 1) => Z n -> Z n\nmodular_inverse x = fromInteger (multinv (fromZ x) `n)\n\ndiv_mod : {n} (fin n, n >= 1) => Z n -> Z n -> Z n\ndiv_mod x y = x * (modular_inverse y)\n\npow_mod : {n} (fin n, n >= 1) => Z n -> Integer -> Z n\npow_mod base exp = base ^^ exp\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Common\/Utils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Common::Utils that defines the constants BYTE_WIDTH, UInt64, UInt256 and the functions bit_to_bool, bool_to_bit, and bit_to_integer with the given types and behaviors, including properties that verify their correct conversions for all inputs."},{"role":"assistant","content":"```cryptol\nmodule Common::Utils where\n\ntype BYTE_WIDTH = 8\n\ntype UInt64 = [64]\n\ntype UInt256 = [256]\n\nbit_to_bool : Bit -> [1]\nbit_to_bool b = if b then 1 else 0\n\nbool_to_bit : [1] -> Bit\nbool_to_bit b = if b == 1 then True else False\n\nbit_to_integer : Bit -> Integer\nbit_to_integer b = if b then 1 else 0\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/FQP.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the finite field extension type FQP (including Fq2 and Fq12), its arithmetic operations, related G2\/G12 constants, and properties proving commutativity, non-commutativity, and exponentiation equivalences as in this FQP module."},{"role":"assistant","content":"```cryptol\nmodule Spec::BlsEC::FQP where\n\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::Poly(poly_extended_euclidean)\n\ntype FQP n = [n](Z Fq)\n\ntype Fq2 = FQP 2\n\ntype Fq12 = FQP 12\n\nFQ2_MODULUS_COEFFICIENTS : Fq2\nFQ2_MODULUS_COEFFICIENTS = [1, 0]\n\nFQ12_MODULUS_COEFFICIENTS : Fq12\nFQ12_MODULUS_COEFFICIENTS = [2, 0, 0, 0, 0, 0, -2, 0, 0, 0, 0, 0]\n\n(~+~) : {n} (fin n, n >= 1) => FQP n -> FQP n -> FQP n\n(~+~) coeffs1 coeffs2 = [c1i + c2i | c1i <- coeffs1 | c2i <- coeffs2]\n\n(~-~) : {n} (fin n, n >= 1) => FQP n -> FQP n -> FQP n\n(~-~) coeffs1 coeffs2 = [c1i - c2i | c1i <- coeffs1 | c2i <- coeffs2]\n\n(~*~) : {n} (fin n, n <= 12, n >= 2) => FQP n -> FQP n -> FQP n\n(~*~) coeffs1 coeffs2 = reduce_while b modulus_coeffs (2 * `(n) - 1) where\n    b = poly_multi coeffs1 coeffs2\n\nreduce_while : {a, n} (fin n, n <= 12, n >= 2, fin a, a == 2 * n - 1) => [a](Z Fq) -> [n](Z Fq) -> Integer -> [n](Z Fq)\nreduce_while b mod_coeffs len =\n    if len == `(n) then take`{n} b\n    else reduce_while b' mod_coeffs (len - 1)\n    where\n        top = b@(len-1)\n        exp = len - `(n) - 1\n        b' = [compute bj j | bj <- b | j <- [0 .. (a-1)]]\n        compute bj j =\n            if (j >= exp) && (j <= exp + `(n) - 1) then\n                bj - (top * (mod_coeffs@(j-exp)))\n            else bj\n\npoly_multi : {n, a} (fin n, 2 * n >= 1, fin a, a == 2 * n - 1) => FQP n -> FQP n -> FQP a\npoly_multi l r =\n    if (all (\\x -> x == 0) l) then zero\n    else ((scalar_mult (l@0) r) # zero) ~+~ (((poly_multi (l << 1) r) # zero) >> 1)\n    where scalar_mult x ys = map ((*) x) ys\n\n(*~) : {n} (fin n, n >= 1) => Integer -> FQP n -> FQP n\n(*~) value coeffs = [value' * ci | ci <- coeffs] where\n    value' = fromInteger value\n\n(~*) : {n} (fin n, n >= 1) => FQP n -> Integer -> FQP n\n(~*) coeffs value = value *~ coeffs\n\n(~\/~) : {n} (fin n, n <= 12, n >= 2) => FQP n -> FQP n -> FQP n\n(~\/~) coeffs1 coeffs2 = coeffs1 ~*~ (fqp_inv coeffs2)\n\nfqp_inv : {n} (fin n, n <= 12, n >= 2) => FQP n -> FQP n\nfqp_inv coeffs = poly_extended_euclidean`{n+1} lm low hm high where\n    lm = [1] # n_zeros\n    hm = [0] # n_zeros\n    low = coeffs # [0]\n    high = modulus_coeffs # [1]\n    n_zeros = repeat`{n} 0\n\nmodulus_coeffs : {n} (fin n, n <= 12, n >= 2) => FQP n\nmodulus_coeffs =\n            if `(n) == 2 then FQ2_MODULUS_COEFFICIENTS # zero\n     | `(n) == 12 then take`{n} FQ12_MODULUS_COEFFICIENTS\n    else zero\n\n(~^^) : {n} (fin n, n <= 12, n >= 2) => FQP n -> Integer -> FQP n\n(~^^) coeffs scalar =\n    if scalar == 0 then\n        [1] # zero\n     | scalar == 1 then\n        coeffs\n     | scalar % 2 == 0 then\n        (coeffs ~*~ coeffs) ~^^ (scalar \/ 2)\n     else\n        ((coeffs ~*~ coeffs) ~^^ (scalar \/ 2)) ~*~ coeffs\n\nfqp_neg : {n} (fin n, n >= 1) => FQP n -> FQP n\nfqp_neg coeffs = [-ci | ci <- coeffs]\n\n(~==~) : {n} (fin n, n >= 1) => FQP n -> FQP n -> Bit\n(~==~) coeffs1 coeffs2 = and [c1i == c2i | c1i <- coeffs1 | c2i <- coeffs2]\n\nG2_x : Fq2\nG2_x = [ 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n       , 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758\n       ]\n\nG2_y : Fq2\nG2_y = [ 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n       , 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582\n       ]\n\nG2_y_plus_x : Fq2\nG2_y_plus_x =\n    [ 2337851671874758553755193637188231783190898931008430971079287309306138512109538745297216704607199160594256266651065\n    , 3986698009736546165718461780529819517744210518930240528684401185085612201771633997414458852832304583413319107585340\n    ]\n\nG2_y_minus_x : Fq2\nG2_y_minus_x =\n    [ 1632449532699825317380915405166111493410839025422880490639470020826550940638108691550521503919468808688732414044745\n    , 1870818876469786139193731976758160400328152687915953296697712908626373202724554996990127355752626211775441853413611\n    ]\n\nG2_xSquared : Fq2\nG2_xSquared =\n    [ 1997086149283677522843833040423074048426674013790346437450988890364808601048656494674186077061491944389142492819694\n    , 3113349101563180256960455051481244719726682130931247942710023183696345206282753395927436272834951815958170074391256\n    ]\n\nG2_xCubed : Fq2\nG2_xCubed =\n    [ 3341065098200961989598748404381324054605449840948293400785922068969583005812936621662354076014412578129291257715484\n    , 2133050398774337206222816300118221327418763981033055222570091459262312519047975404484651902003138703421962555090218\n    ]\n\nG2_xDoubled : Fq2\nG2_xDoubled =\n    [ 705402139174933236374278232022120289780059905585550480439817288479587571471430053746695200687730351905523852606320\n    , 2115879133266760026524729803771659117416057831014287231986688276459238999047079000424331497079678371637877254171729\n    ]\n\nG2_y_div_mod_x : Fq2\nG2_y_div_mod_x =\n    [ 2645964961145567287646174681515652840605182444869364111679220104429646387260976011822898928226591963576020240426619\n    , 3656195751079888906744826605664754595376734064625263022628224160781596224005157110042338963344577397675474692059176\n    ]\n\nG2_xInverse : Fq2\nG2_xInverse =\n    [ 1223514866584400226619392018844575446040489926980124362465220784014275923982521236729115905530146470033177964357563\n    , 3495453419063574139925455551631318136524378768480668459768684498547208492074727172949503320416899422709399085629096\n    ]\n\nG2_yInverse : Fq2\nG2_yInverse =\n    [ 3828301281232776537393462114696026453820925117135598932697882187079936548530569912296382199133331215710911400309693\n    , 1450185639544495128598198914056492809111071767684112182252696543466687995844478949870392653614483391964324409513904\n    ]\n\nG12_x : Fq12\nG12_x =\n    [ 0, 0, 0, 0\n    , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n    , 0, 0, 0, 0, 0\n    , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n    , 0\n    ]\n\nG12_y : Fq12\nG12_y =\n    [ 0, 0, 0\n    , 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n    , 0, 0, 0, 0, 0\n    , 1472406309213353956798468635167385199506877017588472562248853724925831900559844855499883907296819622485916638215732\n    , 0, 0\n    ]\n\nG12_y_plus_x : Fq12\nG12_y_plus_x =\n    [ 0, 0, 0\n    , 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n    , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n    , 0, 0, 0, 0\n    , 1472406309213353956798468635167385199506877017588472562248853724925831900559844855499883907296819622485916638215732\n    , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n    , 0\n    ]\n\nG12_y_minus_x : Fq12\nG12_y_minus_x =\n    [ 0, 0, 0\n    , 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n    , 3649708485634200775230650709724844011666852867146232645112149491884237864755122837569340028785150488085132346256627\n    , 0, 0, 0, 0\n    , 1472406309213353956798468635167385199506877017588472562248853724925831900559844855499883907296819622485916638215732\n    , 2649187917893293847525729476364543410508662633597071726112325855098110880974216161662606647748774743095332354028488\n    , 0\n    ]\n\nG12_xSquared : Fq12\nG12_xSquared =\n    [ 0, 0\n    , 1997086149283677522843833040423074048426674013790346437450988890364808601048656494674186077061491944389142492819694\n    , 0, 0, 0, 0, 0\n    , 558131476139751367058311005529085335650004058570450752629517146665768302617048450626625097886729935784513790785781\n    , 0, 0, 0\n    ]\n\nG12_xCubed : Fq12\nG12_xCubed =\n    [ 3341065098200961989598748404381324054605449840948293400785922068969583005812936621662354076014412578129291257715484\n    , 0, 0, 0, 0, 0\n    , 3398402205508355001729823773604352792963539889981388796224142831270396407108357255853836542123378726684229921247154\n    , 0, 0, 0, 0, 0\n    ]\n\nG12_y_div_mod_x : Fq12\nG12_y_div_mod_x =\n    [ 0, 0, 0, 0, 0\n    , 2645964961145567287646174681515652840605182444869364111679220104429646387260976011822898928226591963576020240426619\n    , 0, 0, 0, 0, 0\n    , 2506320172577994506258220874942502955664217219847453398140531096237990743617509481331063832123500549068674362096172\n    ]\n\nG12_xInverse : Fq12\nG12_xInverse =\n    [ 0, 0\n    , 1730471002742493480111726292949161466072993978438463788028594421591099082398631928222300214242262711361673151288254\n    , 0, 0, 0, 0, 0\n    , 3495453419063574139925455551631318136524378768480668459768684498547208492074727172949503320416899422709399085629096\n    , 0, 0, 0\n    ]\n\nfqp_addition_commutative : {n} (fin n, n >= 1) => FQP n -> FQP n -> Bit\nproperty fqp_addition_commutative a b =\n    a ~+~ b == b ~+~ a\n\nfqp_multiplication_commutative : {n} (fin n, n <= 12, n >= 2) => FQP n -> FQP n -> Bit\nproperty fqp_multiplication_commutative a b =\n    a ~*~ b == b ~*~ a\n\nfqp_multi_by_two_is_double : {n} (fin n, n <= 12, n >= 2) => FQP n -> Bit\nproperty fqp_multi_by_two_is_double a =\n    a ~* 2 == a ~+~ a\n\nfqp_subtraction_not_commutative : {n} (fin n, n >= 1) => FQP n -> FQP n -> Bit\nproperty fqp_subtraction_not_commutative a b = precondition ==> statement where\n    precondition = a != b\n    statement = a ~-~ b != b ~-~ a\n\nfqp_squared_equiv : {n} (fin n, n <= 12, n >= 2) => FQP n -> Bit\nproperty fqp_squared_equiv c =\n    c~^^2 == c ~*~ c\n\nfqp_equality_commutative : {n} (fin n, n >= 1) => FQP n -> FQP n -> Bit\nproperty fqp_equality_commutative a b =\n    a ~==~ b == b ~==~ a\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/G1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol the BLS12-381 G1 group operations, including point addition, doubling, scalar multiplication (g1_multi, g1_multi_optimized), subgroup_check, and the property g1_multis_equiv that both scalar multiplication implementations agree for all 256-bit scalars."},{"role":"assistant","content":"```cryptol\nmodule Spec::BlsEC::G1 where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\n\ntype G1Point =\n    { xCoord : Z Fq\n    , yCoord : Z Fq\n    }\n\nG1_INFINITY : G1Point\nG1_INFINITY =\n    { xCoord = 0\n    , yCoord = 0\n    }\n\nG1 : G1Point\nG1 =\n    { xCoord = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\n    , yCoord = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\n    }\n\ng1_is_valid_point : G1Point -> Bit\ng1_is_valid_point point =\n    y^^2 - x^^3 == 4\n    where\n        x = point.xCoord\n        y = point.yCoord\n\ng1_double : G1Point -> G1Point\ng1_double point = newPoint where\n    x = point.xCoord\n    y = point.yCoord\n    m = div_mod (3 * x^^2) (2 * y)\n    newX = m^^2 - (2 * x)\n    newY = m * (x - newX) - y\n    newPoint =\n        { xCoord = newX\n        , yCoord = newY\n        }\n\ng1_add : G1Point -> G1Point -> G1Point\ng1_add p1 p2 =\n    if p1 == G1_INFINITY then p2\n     | p2 == G1_INFINITY then p1\n     | p1 == p2 then g1_double p1\n     else\n        { xCoord = newX\n        , yCoord = newY\n        }\n    where\n    x1 = p1.xCoord\n    y1 = p1.yCoord\n    x2 = p2.xCoord\n    y2 = p2.yCoord\n    m = div_mod (y2 - y1) (x2 - x1)\n    newX = m^^2 - x1 - x2\n    newY = m * (x1 - newX) - y1\n\ng1_multi_optimized : G1Point -> UInt256 -> G1Point\ng1_multi_optimized point scalar =\n    if scalar >= `(BLS_MODULUS) then g1_multi point scalar\n                    | scalar >= `(BLS_MODULUS) \/ 2 then {xCoord = x, yCoord = y}\n     else g1_multi point scalar\n    where\n        inverse_scalar = `(BLS_MODULUS) - scalar\n        inverse_point = g1_multi point inverse_scalar\n        y = fromInteger (`(Fq) - (fromZ inverse_point.yCoord))\n        x = inverse_point.xCoord\n\ng1_multi : G1Point -> UInt256 -> G1Point\ng1_multi point scalar =\n    if scalar == 0 then G1_INFINITY\n        | scalar == 1 then point\n                | scalar % 2 == 0 then g1_multi (g1_double point) (scalar \/ 2)\n                else g1_add ((g1_multi (g1_double point) (scalar \/ 2))) point\n\ng1_multis_equiv : UInt256 -> Bit\nproperty g1_multis_equiv scalar =\n    g1_multi G1 scalar == g1_multi_optimized G1 scalar\n\nsubgroup_check : G1Point -> Bit\nsubgroup_check point = G1_INFINITY != g1_multi point `(BLS_MODULUS)\n\nG1_2P : G1Point\nG1_2P =\n    { xCoord = 838589206289216005799424730305866328161735431124665289961769162861615689790485775997575391185127590486775437397838\n    , yCoord = 3450209970729243429733164009999191867485184320918914219895632678707687208996709678363578245114137957452475385814312\n    }\n\nG1_3P : G1Point\nG1_3P =\n    { xCoord = 1527649530533633684281386512094328299672026648504329745640827351945739272160755686119065091946435084697047221031460\n    , yCoord = 487897572011753812113448064805964756454529228648704488481988876974355015977479905373670519228592356747638779818193\n    }\n\nG1_4P : G1Point\nG1_4P =\n    { xCoord = 1940386630589042756063486004190165295069185078823041184114464346315715796897349637805088429212932248421554491972448\n    , yCoord = 3114296198575988357603748217414299058449850389627766458803888308926785677746356789015548793127623382888106859156543\n    }\n\nG1_5P : G1Point\nG1_5P =\n    { xCoord = 2601793266141653880357945339922727723793268013331457916525213050197274797722760296318099993752923714935161798464476\n    , yCoord = 3498096627312022583321348410616510759186251088555060790999813363211667535344132702692445545590448314959259020805858\n    }\n\nG1_6P : G1Point\nG1_6P =\n    { xCoord = 1063080548659463434646774310890803636667161539235054707411467714858983518890075240133758563865893724012200489498889\n    , yCoord = 3669927104170827068533340245967707139563249539898402807511810342954528074138727808893798913182606104785795124774780\n    }\n\nG1_7P : G1Point\nG1_7P =\n    { xCoord = 3872473689207892378470335395114902631176541028916158626161662840934315241539439160301564344905260612642783644023991\n    , yCoord = 2547806390474846378491145127515427451279430889101277169890334737406180277792171092197824251632631671609860505999900\n    }\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/GP.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the BLS12-381 G2 and GT group operations over extension fields, including point validity checks, addition, doubling, optimized scalar multiplication, twisting from G2 to G12, subgroup checks, and the property gp_negation_correct for all GPPoint n."},{"role":"assistant","content":"```cryptol\nmodule Spec::BlsEC::GP where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::FQP\n\nFQ2_ORDER : Integer\nFQ2_ORDER = `(Fq)^^2 - 1\n\nFQ2_B2 : Fq2\nFQ2_B2 = [4, 4]\n\nFQ12_B12 : Fq12\nFQ12_B12 = [4] # zero\n\ntype GPPoint n =\n    { xCoeffs : FQP n\n    , yCoeffs : FQP n\n    }\n\ntype G2Point = GPPoint 2\n\ntype G12Point = GPPoint 12\n\nG2_INFINITY : G2Point\nG2_INFINITY =\n    { xCoeffs = zero\n    , yCoeffs = zero\n    }\n\nG12_INFINITY : G12Point\nG12_INFINITY =\n    { xCoeffs = zero\n    , yCoeffs = zero\n    }\n\nG2 : G2Point\nG2 =\n    { xCoeffs =\n        [ 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758\n        ]\n    , yCoeffs =\n        [ 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n        , 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582\n        ]\n    }\n\nG12 : G12Point\nG12 =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 0, 0, 0, 0, 0\n        , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n        , 0, 0, 0, 0, 0\n        , 1472406309213353956798468635167385199506877017588472562248853724925831900559844855499883907296819622485916638215732\n        , 0, 0\n        ]\n    }\n\ngp_is_valid_point : {n} (fin n, n <= 12, n >= 2) => FQP n -> GPPoint n -> Bit\ngp_is_valid_point b point =\n    (y~^^2) ~-~ (x~^^3) == b\n    where\n        x = point.xCoeffs\n        y = point.yCoeffs\n\ng2_is_valid_point : G2Point -> Bit\ng2_is_valid_point point = gp_is_valid_point FQ2_B2 point\n\ng12_is_valid_point : G12Point -> Bit\ng12_is_valid_point point = gp_is_valid_point FQ12_B12 point\n\ngp_negate : {n} (fin n, n >= 1) => GPPoint n -> GPPoint n\ngp_negate point = newPoint where\n    x = point.xCoeffs\n    y = point.yCoeffs\n    newPoint =\n        { xCoeffs = x\n        , yCoeffs = fqp_neg y\n        }\n\ng2_negate : G2Point -> G2Point\ng2_negate point = gp_negate point\n\ng12_negate : G12Point -> G12Point\ng12_negate point = gp_negate point\n\ngp_double : {n} (fin n, n <= 12, n >= 2) => GPPoint n -> GPPoint n\ngp_double point = newPoint where\n    x = point.xCoeffs\n    y = point.yCoeffs\n    m = (3 *~ (x~^^2)) ~\/~ (2 *~ y)\n    newX = (m~^^2) ~-~ (2 *~ x)\n    newY = (m ~*~ (x ~-~ newX)) ~-~ y\n    newPoint =\n        { xCoeffs = newX\n        , yCoeffs = newY\n        }\n\ng2_double : G2Point -> G2Point\ng2_double point = gp_double point\n\ng12_double : G12Point -> G12Point\ng12_double point = gp_double point\n\ngp_add : {n} (fin n, n <= 12, n >= 2) => GPPoint n -> GPPoint n -> GPPoint n -> GPPoint n\ngp_add infinity p1 p2 =\n    if p1 == infinity then p2\n     | p2 == infinity then p1\n     | p1 == p2 then gp_double p1\n     else\n        { xCoeffs = newX\n        , yCoeffs = newY\n        }\n    where\n    x1 = p1.xCoeffs\n    y1 = p1.yCoeffs\n    x2 = p2.xCoeffs\n    y2 = p2.yCoeffs\n    m = (y2 ~-~ y1) ~\/~ (x2 ~-~ x1)\n    newX = m~^^2 ~-~ x1 ~-~ x2\n    newY = m ~*~ (x1 ~-~ newX) ~-~ y1\n\ng2_add : G2Point -> G2Point -> G2Point\ng2_add p1 p2 = gp_add G2_INFINITY p1 p2\n\ng12_add : G12Point -> G12Point -> G12Point\ng12_add p1 p2 = gp_add G12_INFINITY p1 p2\n\ngp_multi : {n} (fin n, n <= 12, n >= 2) => GPPoint n -> GPPoint n -> UInt256 -> GPPoint n\ngp_multi infinity point scalar =\n    if scalar == 0 then infinity\n        | scalar == 1 then point\n                | scalar % 2 == 0 then gp_multi infinity (gp_double point) (scalar \/ 2)\n                else gp_add infinity ((gp_multi infinity (gp_double point) (scalar \/ 2))) point\n\ng2_multi : G2Point -> UInt256 -> G2Point\ng2_multi point scalar = gp_multi G2_INFINITY point scalar\n\ng12_multi : G12Point -> UInt256 -> G12Point\ng12_multi point scalar = gp_multi G12_INFINITY point scalar\n\ngp_multi_optimized : {n} (fin n, n <= 12, n >= 2) => GPPoint n -> GPPoint n -> UInt256 -> GPPoint n\ngp_multi_optimized infinity point scalar =\n    if scalar >= `(BLS_MODULUS) then gp_multi infinity point scalar\n                    | scalar >= `(BLS_MODULUS) \/ 2 then {xCoeffs = xcoeffs, yCoeffs = ycoeffs}\n     else gp_multi infinity point scalar\n    where\n        inverse_scalar = `(BLS_MODULUS) - scalar\n        inverse_point = gp_multi infinity point inverse_scalar\n        ycoeffs = map (\\y -> fromInteger (`(Fq) - (fromZ y))) inverse_point.yCoeffs\n        xcoeffs = inverse_point.xCoeffs\n\ng2_multi_optimized : G2Point -> UInt256 -> G2Point\ng2_multi_optimized point scalar = gp_multi_optimized G2_INFINITY point scalar\n\ng12_multi_optimized : G12Point -> UInt256 -> G12Point\ng12_multi_optimized point scalar = gp_multi_optimized G12_INFINITY point scalar\n\ng2_subgroup_check : G2Point -> Bit\ng2_subgroup_check point = G2_INFINITY != (g2_multi point `(BLS_MODULUS))\n\nW : Fq12\nW = [0, 1] # zero\n\ntwist : G2Point -> G12Point\ntwist p = {xCoeffs = newX, yCoeffs = newY} where\n    x = p.xCoeffs\n    y = p.yCoeffs\n        xcoeffs = [(x@0) - (x@1), x@1]\n    ycoeffs = [(y@0) - (y@1), y@1]\n            nx = [xcoeffs@0] # five_zeros # [xcoeffs@1] # five_zeros\n    ny = [ycoeffs@0] # five_zeros # [ycoeffs@1] # five_zeros\n        newX = nx ~\/~ (W~^^2)\n    newY = ny ~\/~ (W~^^3)\n    five_zeros = repeat`{5} 0\n\nG2_2P : G2Point\nG2_2P =\n    { xCoeffs =\n        [ 3419974069068927546093595533691935972093267703063689549934039433172037728172434967174817854768758291501458544631891\n        , 1586560233067062236092888871453626466803933380746149805590083683748120990227823365075019078675272292060187343402359\n        ]\n    , yCoeffs =\n        [ 678774053046495337979740195232911687527971909891867263302465188023833943429943242788645503130663197220262587963545\n        , 2374407843478705782611042739236452317510200146460567463070514850492917978226342495167066333366894448569891658583283\n        ]\n    }\n\nG2_3P : G2Point\nG2_3P =\n    { xCoeffs =\n        [ 2795155019138475430256695697248607867022196082692926850257941893956680503583886174445899854256891620515274933186478\n        , 1418901263980595683832511076652430035654903023556505873032297534993731256453342997202098832403658787934376638965468\n        ]\n    , yCoeffs =\n        [ 1713408536894110516522969272885192173669900392782465197506312048399987681703463801235485042423756235640603447122066\n        , 1376945178829045108008380835987620979304438294788415956605678509674588356753313865659068546846109894276784773457993\n        ]\n    }\n\nG2_6P : G2Point\nG2_6P =\n    { xCoeffs =\n        [ 3984640847924757144714972801294669751518204805083279115209564409785869025937099631985667805381121749661329977337231\n        , 608866484358724393780037751128594231300217318157170134017274809385436427203952108566113171210510640978002034144337\n        ]\n    , yCoeffs =\n        [ 3638085773299732811703058316322950283836045952826105333022656670096922749263292332009255347182392556648551235304444\n        , 1315309522598195877039488735068285781409574791250756219351720987511623939545034443010380218936398442802560800338945\n        ]\n    }\n\nG2_Negated : G2Point\nG2_Negated =\n    { xCoeffs =\n        [ 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758\n        ]\n    , yCoeffs =\n        [ 2017258952934375457849735304558732518256013841723352154472679471057686924117014146018818524865681679396399932211882\n        , 3074855889729334937670587859959866275799142626485414915307030157330054773488162299461738339401058098462460928340205\n        ]\n    }\n\nG12_2P : G12Point\nG12_2P =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 3419974069068927546093595533691935972093267703063689549934039433172037728172434967174817854768758291501458544631891\n        , 0, 0, 0, 0, 0\n        , 3085702637220734738417436494616749403912215658780238013160080261412073281518532063392788241082272664317258671945021\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 678774053046495337979740195232911687527971909891867263302465188023833943429943242788645503130663197220262587963545\n        , 0, 0, 0, 0, 0\n        , 847816895216105222315651272001770314991114118284350099884024831234542017398199626189210415118115625674814535309869\n        , 0, 0\n        ]\n    }\n\nG12_3P : G12Point\nG12_3P =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 2795155019138475430256695697248607867022196082692926850257941893956680503583886174445899854256891620515274933186478\n        , 0, 0, 0, 0, 0\n        , 3314282677642727520205697515437815240873236290370797396719235956642557026925566275820787118202399247747445125449282\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 1713408536894110516522969272885192173669900392782465197506312048399987681703463801235485042423756235640603447122066\n        , 0, 0, 0, 0, 0\n        , 1832973098578300992451600694419166481095710360972479322215712298699316162770343964433135566775684661337037799447857\n        , 0, 0\n        ]\n    }\n\nG12_6P : G12Point\nG12_6P =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 3984640847924757144714972801294669751518204805083279115209564409785869025937099631985667805381121749661329977337231\n        , 0, 0, 0, 0, 0\n        , 2314522373438651017950322300652866396447889076475953394735913335923815351124264102732910312043710109696230300963340\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 3638085773299732811703058316322950283836045952826105333022656670096922749263292332009255347182392556648551235304444\n        , 0, 0, 0, 0, 0\n        , 839816652260065229377110122240619827065205829181829385830561226769366420386289987721906250441510775095951918797144\n        , 0, 0\n        ]\n    }\n\nG12_Negated : G12Point\nG12_Negated =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 0, 0, 0, 0, 0\n        , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 2017258952934375457849735304558732518256013841723352154472679471057686924117014146018818524865681679396399932211882\n        , 0, 0, 0, 0, 0\n        , 2530003246008313436619321190568518957050005802350535323083204411198199749930993008942803721832196041551977634344055\n        , 0, 0\n        ]\n    }\n\nG12_NEG_ONE : G12Point\nG12_NEG_ONE =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n        , 0, 0, 0, 0, 0\n        , 1353221637328373545892060349371360746048220186341936159219732281025920769516621702780080981380240920942561918531299\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 2017258952934375457849735304558732518256013841723352154472679471057686924117014146018818524865681679396399932211882\n        , 0, 0, 0, 0, 0\n        , 2530003246008313436619321190568518957050005802350535323083204411198199749930993008942803721832196041551977634344055\n        , 0, 0\n        ]\n    }\n\nG12_NEG_TWO : G12Point\nG12_NEG_TWO =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 3419974069068927546093595533691935972093267703063689549934039433172037728172434967174817854768758291501458544631891\n        , 0, 0, 0, 0, 0\n        , 3085702637220734738417436494616749403912215658780238013160080261412073281518532063392788241082272664317258671945021\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 3323635502175172055438049630502992469028910910047140622029592948100197707060894621654042125998352466817631684596242\n        , 0, 0, 0, 0, 0\n        , 3154592660005562171102138553734133841565768701654657785448033304889489633092638238253477214010900038363079737249918\n        , 0, 0\n        ]\n    }\n\nG12_NEG_THREE : G12Point\nG12_NEG_THREE =\n    { xCoeffs =\n        [ 0, 0, 0, 0\n        , 2795155019138475430256695697248607867022196082692926850257941893956680503583886174445899854256891620515274933186478\n        , 0, 0, 0, 0, 0\n        , 3314282677642727520205697515437815240873236290370797396719235956642557026925566275820787118202399247747445125449282\n        , 0\n        ]\n    , yCoeffs =\n        [ 0, 0, 0\n        , 2289001018327556876894820552850711982886982427156542687825746087724043968787374063207202586705259428397290825437721\n        , 0, 0, 0, 0, 0\n        , 2169436456643366400966189131316737675461172458966528563116345837424715487720493900009552062353331002700856473111930\n        , 0, 0\n        ]\n    }\n\ngp_negation_correct : {n} (fin n, n >= 1) => GPPoint n -> Bit\nproperty gp_negation_correct a =\n    gp_negate (gp_negate a) == a\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/Pairing.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the BLS12-381 optimal Ate pairing over G1 and G2, including miller_loop, linefunc, final_exponentiate, pairing_check, and constants like MILLER_LOOP_G2_G1_FQ12 and VALID_MULTI_PAIRING_POINTS, and include properties to validate correctness against the Ethereum py_ecc reference implementation."},{"role":"assistant","content":"```cryptol\nmodule Spec::BlsEC::Pairing where\n\nimport Common::ModArith\nimport Common::Utils\nimport Spec::BlsEC::Curve\nimport Spec::BlsEC::Field\nimport Spec::BlsEC::FQP\nimport Spec::BlsEC::G1\nimport Spec::BlsEC::GP\n\nFQ12_ONE : Fq12\nFQ12_ONE = [1] # zero\n\npairing_check : {n} (fin n) => [n](G1Point, G2Point) -> Bit\npairing_check points = final ~==~ FQ12_ONE where\n    final = final_exponentiate prod\n    prod = foldl (~*~) FQ12_ONE [pairing q p False | (p, q) <- points]\n\ncast_point_to_fq12 : G1Point -> G12Point\ncast_point_to_fq12 p = {xCoeffs = newX, yCoeffs = newY} where\n    x = p.xCoord\n    y = p.yCoord\n    newX = [x] # zero\n    newY = [y] # zero\n\nlinefunc : G12Point -> G12Point -> G12Point -> Fq12\nlinefunc p1 p2 t =\n    if (p1 == G12_INFINITY) ||\n       (p2 == G12_INFINITY) ||\n       (t == G12_INFINITY) then         error \"Invalid input - no points-at-infinity allowed\"\n    else\n        if x1 != x2 then m1 ~*~ (xt ~-~ x1) ~-~ (yt ~-~ y1)\n         | y1 == y2 then m2 ~*~ (xt ~-~ x1) ~-~ (yt ~-~ y1)\n         else xt ~-~ x1\n    where\n        x1 = p1.xCoeffs\n        y1 = p1.yCoeffs\n        x2 = p2.xCoeffs\n        y2 = p2.yCoeffs\n        xt = t.xCoeffs\n        yt = t.yCoeffs\n        m1 = (y2 ~-~ y1) ~\/~ (x2 ~-~ x1)\n        m2 = 3 *~ (x1~^^2) ~\/~ (2 *~ y1)\n\nate_loop_count : UInt64\nate_loop_count = 15132376222941642752\n\nlog_ate_loop_count : Integer\nlog_ate_loop_count = 62\n\nmiller_loop : G12Point -> G12Point -> Bit -> Fq12\nmiller_loop q p do_final_exponentiate =\n    if (q == G12_INFINITY) ||\n       (p == G12_INFINITY) then FQ12_ONE\n    else double_and_add q FQ12_ONE log_ate_loop_count\n    where\n        double_and_add : G12Point -> Fq12 -> Integer -> Fq12\n        double_and_add r f count =\n            if count < 0 then\n                if do_final_exponentiate then final_exponentiate f else f\n            else\n                if (ate_loop_count && (2^^count)) != 0 then\n                    double_and_add r'' f'' (count - 1)\n                else double_and_add r' f' (count - 1)\n            where\n                f' = f ~*~ f ~*~ (linefunc r r p)\n                r' = g12_double r\n                f'' = f' ~*~ (linefunc r' q p)\n                r'' = g12_add r' q\n\n\/**\n * Final exponentiation of the pairing algorithm.\n * https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_pairing.py#L116\n * The py_ecc \"field_modulus\" is Fq, and \"curve_order\" is the BLS_MODULUS.\n * ```repl\n * :check final_exponentiate G12_x == [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n * ```\n * NOTE: this repl test is very slow (~45 seconds).\n *\/\nfinal_exponentiate : Fq12 -> Fq12\nfinal_exponentiate p = p~^^((`(Fq)^^12 - 1) \/ `(BLS_MODULUS))\n\n\/**\n * Pairing computation.\n * @see https:\/\/github.com\/ethereum\/py_ecc\/blob\/70c194edd8d1eb1457805442f0162499dbc0aac5\/py_ecc\/bls12_381\/bls12_381_pairing.py#L108\n * The tests in `miller_loop` and `pairing_check` cover this function.\n *\/\npairing : G2Point -> G1Point -> Bit -> Fq12\npairing q p do_final_exponentiate =\n    if ~(g2_is_valid_point q) then\n        error \"Invalid input - point Q is not on the correct curve\"\n     | ~(g1_is_valid_point p) then\n        error \"Invalid input - point P is not on the correct curves\"\n    else miller_loop (twist q) (cast_point_to_fq12 p) do_final_exponentiate\n\n\/**\n * Computed `miller_loop(twist(normalize(G2)), cast_point_to_fq12(G1))` with py_ecc.\n * NOTE: this is not a valid KZG proof, it is just a test value.\n *\/\nMILLER_LOOP_G2_G1_FQ12 : Fq12\nMILLER_LOOP_G2_G1_FQ12 =\n    [ 3408834164464458755751340723502736743445402614640994055433339214424916442641449510670327077303074893591740399366532\n    , 1017299873256115394687936133146817339783508925356207904663165117501336940438300180831508525168135575931758510829235\n    , 1919447955347661378578718469488414822573562393353397544098339472673901193098010131520945815709482515519580400649694\n    , 233557331756520805040932826416017142246700002714928636467514104620558679338483625829873520553081791155104026612174\n    , 2882199334237819327910933128503231887000342950792587449681715803095618652567681747054312179958427092970985872417068\n    , 579878855790610229145575079003483905368886712027403088810647643659132674704592975818766405092658613973478871626949\n    , 3268798540077874559188095304926415053902298079662269128631117894259354335713488241073281881110999874366368799440511\n    , 2688711983546324406847903726099677850388169649284572370749691792743294691894680263880362424577638309433508620982332\n    , 3520140447471844017044610248175793726488927385800919015247604269617056365166670232096113218155158979455637700602719\n    , 1555267885602801620621747613743921378408444002839854792606782732724136830563310004098024452104661167182680744848589\n    , 2626389147790168154036854297373352480470342009417426750876875476996308393122833154115295241935326582225976246741447\n    , 873321072950766150592434764742436722571574260472569072177205897167854308426485977134306337249021436737462538398830\n    ]\n\n\/**\n * Randomly generated valid proof pair.\n *\/\nVALID_MULTI_PAIRING_POINTS : [2](G1Point, G2Point)\nVALID_MULTI_PAIRING_POINTS = [\n ({xCoord = 3942577509585645813112967582905379780757916939878725808374136412369021134738667198410219765812816597637590999762994,\n   yCoord = 1088203199345877024923249081294179597401216953118814114064722100932810217381059447963463973664408120385097692508887},\n  {xCoeffs = [352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160,\n    3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758],\n   yCoeffs = [2017258952934375457849735304558732518256013841723352154472679471057686924117014146018818524865681679396399932211882,\n    3074855889729334937670587859959866275799142626485414915307030157330054773488162299461738339401058098462460928340205]}),\n ({xCoord = 3169842563198574659482326102479611290543931141198734323136036543093361601969542502223164030575983014844841304587037,\n   yCoord = 2824376326786724983588666803486546854391198626677433522546039002353746810155815190686926212247090141910905313411994},\n  {xCoeffs = [3394380795309742284085231944467807101526256495961930479404919454683737253440393636117553364774847296670461098299470,\n    3662689612798884582269339769986716851963132127553475998239595135217324880631479103766927470793514208588880068422260],\n   yCoeffs = [2578225059880913843555694372733822992497931377620121352151046101281018929119028392378298954064169396102755595303745,\n    2741696937477620340841025265339742110829389137752838655176100907337011149212882755711342068822769734096710415902962]})\n ]\n```"}]}
{"filename":"ckzg-eip-4844-verification\/spec\/Spec\/BlsEC\/Poly.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify the polynomial extended Euclidean algorithm over the BLS12-381 base field Fq, including functions poly_extended_euclidean, inv_while, inv_nested_for, inv_nested_for_compute_value, poly_pair_multi, inv_nested_for_index_pairs, deg, and poly_rounded_div with appropriate Cryptol types but no implementations."},{"role":"assistant","content":"```cryptol\nmodule Spec::BlsEC::Poly where\n\nimport Common::ModArith\nimport Spec::BlsEC::Field\n\npoly_extended_euclidean : {n} (fin n, n >= 2) => [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n-1](Z Fq)\npoly_extended_euclidean lm low hm high = take`{n-1} results where\n    (lm', low') = inv_while lm low hm high\n    results = [div_mod lmi (low'@0) | lmi <- lm']\n\ninv_while : {n} (fin n, n >= 1) => [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> ([n](Z Fq), [n](Z Fq))\ninv_while lm low hm high =\n    if (deg low) > 0 then\n        inv_while nm new lm low\n    else (lm, low)\n    where\n        r = poly_rounded_div high low\n        (nm, new) = inv_nested_for lm low hm high r\n\ninv_nested_for : {n} (fin n, n >= 1) => [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq) -> ([n](Z Fq), [n](Z Fq))\ninv_nested_for lm low nm new r = (nm', new') where\n    nm' = [inv_nested_for_compute_value nmi i lm r | nmi <- nm | i <- [0..(n-1)]]\n    new' = [inv_nested_for_compute_value newi i low r | newi <- new | i <- [0..(n-1)]]\n\ninv_nested_for_compute_value : {n} (fin n, n >= 1) => Z Fq -> Integer -> [n](Z Fq) -> [n](Z Fq) -> Z Fq\ninv_nested_for_compute_value ni i l r =\n    foldl (-) ni (map (poly_pair_multi l r) (inv_nested_for_index_pairs`{n} i))\n\npoly_pair_multi : {n} (fin n, n >= 1) => [n](Z Fq) -> [n](Z Fq) -> (Integer, Integer) -> Z Fq\npoly_pair_multi l r (i, j) =\n    if (i == -1) || (j == -1) then 0\n    else (l@i) * (r@j)\n\ninv_nested_for_index_pairs : {n} (fin n, n >= 1) => Integer -> [n](Integer, Integer)\ninv_nested_for_index_pairs k =\n    [if j <= k then (k-i, j) else (-1,-1) | i <- [0..(n-1)] | j <- [0..(n-1)]]\n\ndeg : {n} (fin n, n >= 1) => [n](Z Fq) -> Integer\ndeg p = compute_d (`(n)-1) where\n    compute_d : Integer -> Integer\n    compute_d d =\n        if ((p@d) == 0) && (d > 0) then\n            compute_d (d - 1)\n        else d\n\npoly_rounded_div : {n} (fin n, n >= 1) => [n](Z Fq) -> [n](Z Fq) -> [n](Z Fq)\npoly_rounded_div a b = compute_outer_loop o0 temp0 start where\n    dega = deg a\n    degb = deg b\n    o0 = (zero:[n](Z Fq))\n    temp0 = [x | x <- a]\n    start = dega - degb\n\n    compute_outer_loop : [n](Z Fq) -> [n](Z Fq) -> Integer -> [n](Z Fq)\n    compute_outer_loop o temp i =\n        if i < 0 then o\n        else compute_outer_loop o' temp' i'\n        where\n            o' = [if j == i then (o@j) + oi' else (o@j) | j <- [0..(n-1)]]\n            oi' = div_mod (temp@(degb + i)) (b@degb)\n            temp' = compute_temp' temp 0\n            i' = i - 1\n\n            compute_temp' : [n](Z Fq) -> Integer -> [n](Z Fq)\n            compute_temp' t c =\n                if c < (degb + 1) then compute_temp' updated_temp (c+1)\n                else t\n                where\n                    updated_temp = [if j == (c + i) then (t@(c + i)) - (o@c) else (t@c) | j <- [0..(n-1)]]\n```"}]}
{"filename":"SAW-course\/src\/lab1\/csearch_nobug.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol property that proves the binary search function bsearch returns the same index as refSearchIdx for any non-negative key in a strictly increasing list, and show that property holds for all valid inputs."},{"role":"assistant","content":"```cryptol\nbsearch : {n} (fin n, 8 >= width n) => ([8],[n][8]) -> [8]\nbsearch (key, lst) = search (0, (length lst)-1, w)\n  where \n    w = length lst\n                search (low, high, c) =\n       if (c <= 0) \\\/ (low > high) \\\/ (high > w-1) then -1\n       else if midVal < key then search (mid+1, high, c-1)\n       else if midVal > key then search (low, mid-1, c-1)\n       else mid\n       where  \n          midVal = lst @ mid\n          mid = computeMid (low, high)\n\ncomputeMid (low, high) = (low + (high-low) \/ 2)\n\nrefSearchIdx (key, lst) = s!0\n   where\n     s = [-1]#[ if (key == x \/\\ h == -1) then c\n         else h | x <- lst |  h <- s | c <- [0...]]\n\nlst3 = [0,   2,   3,   5,   6,   8,   9,  10,  11,  12,  13,  14,  16,  18,\n       20,  21,  22,  23,  24,  25,  26,  27,  28,  30,  31,  32,  33,  34,\n       35,  36,  37,  39,  40,  41,  32,  43,  44,  45,  46,  47,  49,  50,\n       51,  52,  53,  54,  56,  58,  59,  60,  61,  62,  63,  65,  66,  67,\n       68,  69,  70,  71,  72,  73,  74,  76,  77,  78,  79,  80,  81,  82,\n       84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,\n       98,  99, 101, 102, 103, 104, 105, 106, 107, 108, 110, 112, 113, 114,\n      116, 117, 119, 120, 121, 122, 124, 125, 126, 127, 129, 130, 131, 132,\n      133, 134, 135, 136, 138, 139, 141, 143, 144, 145, 147, 148, 149, 150,\n      152, 153, 155, 156, 157, 158, 159, 160, 162, 163, 164, 166, 167, 168,\n      169, 170, 172, 174, 175, 176, 177, 178, 179, 181, 182, 183, 184, 185,\n      187, 188, 189, 190, 191, 192, 197, 198, 199, 200, 201, 202, 203, 204,\n      206, 207, 208, 209, 210, 211, 213, 214, 215, 216, 218, 220, 221, 222,\n      223, 224, 226, 228, 229, 230, 231, 232, 234, 235, 236, 237, 238, 239,\n      240, 241, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 255]:[210][9]\n\nonlyIncreasing lst = pairComps == ~zero\n  where pairComps = [ x < x' | x  <- [0] # lst | x' <- lst ]\n\nbsearchOK : [8] -> [130][8] -> Bit\nproperty bsearchOK key lst =\n  if onlyIncreasing (lst) \/\\ 0 <= key\n  then bsearch (key, lst) == refSearchIdx (key, lst)\n  else True\n```"}]}
{"filename":"SAW-course\/src\/lab1\/mid.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify Cryptol properties showing that the safe midpoint computation midS on 8-bit (or 9-bit extended) unsigned integers avoids overflow and that its result is always within 1 of the naive midpoint midA under their respective preconditions."},{"role":"assistant","content":"```cryptol\nmidA : [8] -> [8] -> [8]\nmidA low high = (low+high)\/2\n\nmidS : [8] -> [8] -> [8]\nmidS low high = low + (high - low)\/2\n\nmidS_is_safe : [9] -> [9] -> Bit\nproperty midS_is_safe low high\n   = ~(low < 256 \/\\ high < 256 \/\\ low <= high) \\\/ \n      ((high-low) < 256) \/\\ ((high-low)\/2 < (256 - low))\n\nmidpointsAreClose : [9] -> [9] -> Bit\nproperty midpointsAreClose low high\n   = (~(0 <= low \/\\ low <= high \/\\ high < 255)  \\\/\n       ((safeMid <= averageMid \/\\ averageMid <= safeMid+1) \\\/\n        (averageMid <= safeMid \/\\ safeMid <= averageMid+1)))\n     \/\\\n     (~(low <= high \/\\ high == 255) \\\/ (averageMid == safeMid))\n  where\n     averageMid = (low+high)\/2              safeMid    = (low+(high-low)\/2)\n```"}]}
{"filename":"SAW-course\/src\/lab6A\/saf.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions `usaf : [1][8] -> [10][8] -> [1][8]` and `saf : [1][8] -> [10][8] -> [1][8]` as given, capturing the bounds checking behavior of `saf` and the unsafe direct indexing of `usaf`."},{"role":"assistant","content":"```cryptol\nusaf: [1][8] -> [10][8] -> [1][8]\nusaf a b = [(b@(a@0))]\n\nsaf : [1][8] -> [10][8] -> [1][8]\nsaf a b = if a@0 > 9 then [0]\n          else if a@0 < 0 then [0]\n\t\t\t else [(b@(a@0))]\n```"}]}
{"filename":"SAW-course\/src\/lab6A\/zero.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a property that verifies `saf` behaves like unsigned division except that when the divisor is zero it returns 1 instead of failing, and that `usaf` corresponds to normal unsigned division on 8-bit values for nonzero divisors."},{"role":"assistant","content":"```cryptol\nusaf : [8] -> [8] -> [8]\nusaf a b = (a\/b):[8]\n\nsaf : [8] -> [8] -> [8]\nsaf a b = if b == 0 then 1 else (a\/b)\n```"}]}
{"filename":"SAW-course\/src\/lab3E\/elevator.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the elevator controller state machine modeled by the State record and initState, including functions for state transition and output signals, plus properties to verify correctness from the initial state."},{"role":"assistant","content":"```cryptol\ntype State = {  cb : [4][12],                 cbl : [4][12],                  eb : [4][12],  \t\t\t\t\tebl : [4][12],  \t\t\t\t\tids : [12],     \t\t\t\t\tods : [4][12],  \t\t\t\t\tmtr : [12],     \t\t\t\t\t fs : [4][12],  \t\t\t\t\t pe : [12] }    \ninitState : State\ninitState = {  cb = [0,0,0,0],               cbl = [0,0,0,0], \t\t\t\t   eb = [0,0,0,0], \t\t\t\t  ebl = [0,0,0,0], \t\t\t\t  ids = 0,         \t\t\t\t  ods = [0,1,1,1], \t\t\t\t  mtr = 0,         \t\t\t\t   fs = [1,0,0,0], \t\t\t\t\tpe = 0 }\n```"}]}
{"filename":"SAW-course\/src\/lab3B\/alt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the functions and properties in module `alt` that use `DES.expandKey` and `DES.encrypt` to identify DES weak keys, including `func`, `WeakKeys`, and the property `WK` that checks double encryption with a weak key returns the original plaintext."},{"role":"assistant","content":"```cryptol\nmodule alt where\nimport DES\n\nfunc x = z\n  where\n    z = [ a == b | a <- x | b <- drop `{1} x ]\n\nproperty WeakKeys key = (func (expandKey key)) == ~zero\n\nWK : [64] -> [64] -> Bit\nproperty WK key pt = (DES.encrypt key (DES.encrypt key pt)) == pt\n```"}]}
{"filename":"SAW-course\/src\/lab3B\/solution.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, write the specification for module `solution` that defines `func`, `WeakKeys`, and property `WK` to detect DES weak keys by comparing adjacent expanded key bits and verifying that double encryption with such keys yields the original plaintext."},{"role":"assistant","content":"```cryptol\nmodule solution where\nimport DES\n\nfunc key = z\n  where\n    z = [ x == y | x <- (expandKey key) | y <- (drop `{1} (expandKey key)) ]\n\nproperty WeakKeys key = (func key) == ~zero\n\nWK : [64] -> [64] -> Bit\nproperty WK key pt = (DES.encrypt key (DES.encrypt key pt)) == pt\n```"}]}
{"filename":"SAW-course\/src\/lab3C\/sn74as181a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the SN74AS181A 4-bit ALU (module sn74as181a) and its boolean netlist, including properties xorWorks, addingWorks, and itWorks that verify XOR mode, addition mode, and equivalence between the abstract spec and the gate-level netlist for all inputs."},{"role":"assistant","content":"```cryptol\nmodule sn74as181a where\n\nv_xor a b = [ x^y  | x <- a | y <- b ]\n\nv_adder c a b = drop `{1} [ w.0 | w <- z ]\n  where\n    z = [(False, c)]#\n        [ (x^y^q.1, (x\/\\y)\\\/(x\/\\q.1)\\\/(y\/\\q.1))\n        | x <-a#[False] | y <- b#[False] | q <- z ]\n\nf74181_q0 a b s0 s1 s2 s3 = ~((b \/\\ s3 \/\\ a) \\\/ (a \/\\ s2 \/\\ ~b))\n\nf74181_q1 a b s0 s1 s2 s3 = ~((~b \/\\ s1) \\\/ (s0 \/\\ b) \\\/ a)\n\nf74181_f0 c a0 b0 m s0 s1 s2 s3 = out\n  where\n    m_neg = ~m\n    tmp = (f74181_q0 a0 b0 s0 s1 s2 s3) ^\n          (f74181_q1 a0 b0 s0 s1 s2 s3)\n    out = ~(c \/\\ m_neg) ^ tmp\n\nf74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3 = out\n  where\n    m_neg = ~m\n    tmp1 = (f74181_q0 a1 b1 s0 s1 s2 s3) ^\n            (f74181_q1 a1 b1 s0 s1 s2 s3)\n    tmp2 = ~((m_neg \/\\\n              (f74181_q1 a0 b0 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q0 a0 b0 s0 s1 s2 s3) \/\\\n              c))\n    out = tmp1 ^ tmp2\n\nf74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3 = out\n  where\n    m_neg = ~m\n    tmp1 = (f74181_q0 a2 b2 s0 s1 s2 s3) ^\n           (f74181_q1 a2 b2 s0 s1 s2 s3)\n    tmp2 = ~((m_neg \/\\\n              (f74181_q1 a1 b1 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n              (f74181_q1 a0 b0 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q0 a0 b0 s0 s1 s2 s3) \/\\\n              (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n              c))\n    out = tmp1 ^ tmp2\n\nf74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n    m_neg = ~m\n    tmp1 = (f74181_q1 a3 b3 s0 s1 s2 s3) ^\n           (f74181_q0 a3 b3 s0 s1 s2 s3)\n    tmp2 = ~((m_neg \/\\\n              (f74181_q1 a2 b2 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q1 a1 b1 s0 s1 s2 s3) \/\\\n              (f74181_q0 a2 b2 s0 s2 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q1 a0 b0 s0 s1 s2 s3) \/\\\n              (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n              (f74181_q0 a2 b2 s0 s1 s2 s3)) \\\/\n             (m_neg \/\\\n              (f74181_q0 a0 b0 s0 s1 s2 s3) \/\\\n              (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n              (f74181_q0 a2 b2 s0 s1 s2 s3) \/\\\n              c))\n    out = tmp1 ^ tmp2\n\nf74181_a_b c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n    out = ((f74181_f0 c a0 b0 m s0 s1 s2 s3) \/\\\n           (f74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3) \/\\\n           (f74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3) \/\\\n           (f74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3))\n\nf74181_prop c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n    out = ~((f74181_q0 a0 b0 s0 s1 s2 s3) \/\\\n            (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n            (f74181_q0 a2 b2 s0 s1 s2 s3) \/\\\n            (f74181_q0 a3 b3 s0 s1 s2 s3))\n\nf74181_gen c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n   out = ~(((f74181_q0 a3 b3 s0 s1 s2 s3) \/\\\n            (f74181_q0 a2 b2 s0 s1 s2 s3) \/\\\n            (f74181_q0 a1 b1 s0 s1 s2 s3) \/\\\n            (f74181_q1 a0 b0 s0 s1 s2 s3)) \\\/\n           ((f74181_q0 a3 b3 s0 s1 s2 s3) \/\\\n            (f74181_q0 a2 b2 s0 s1 s2 s3) \/\\\n            (f74181_q1 a1 b1 s0 s1 s2 s3)) \\\/\n           ((f74181_q0 a3 b3 s0 s1 s2 s3) \/\\\n            (f74181_q1 a2 b2 s0 s1 s2 s3)) \\\/\n           (f74181_q1 a3 b3 s0 s1 s2 s3))\n\nf74181_cout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = out\n  where\n    out = (~(f74181_gen c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)) \\\/\n          ((~(f74181_prop c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)) \/\\ c)\n\nf74181_sumout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 =\n   [(f74181_f0 c a0 b0 m s0 s1 s2 s3),\n    (f74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3),\n    (f74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3),\n    (f74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3),\n    (f74181_cout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)]\n\nf74181_spec c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 =\n   [f74181_f0 c a0 b0 m s0 s1 s2 s3,\n    f74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3,\n    f74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3,\n    f74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3,\n    f74181_cout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3,\n    f74181_prop c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3,\n    f74181_gen c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3,\n    f74181_a_b c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3]\n\nf74181_netlist c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 =\n  [f0,f1,f2,f3,cout,p,g,a_b]\n  where\n    w0 = ~m\n    w1 = ~b0\n    w2 = ~b1\n    w3 = ~b2\n    w4 = ~b3\n    w5 = a0\n    w6 = b0 \/\\ s0\n    w7 = s1 \/\\ w1\n    w8 = w1 \/\\ s2 \/\\ a0\n    w9 = a0 \/\\ s3 \/\\ b0\n    w10 = a1\n    w11 = b1 \/\\ s0\n    w12 = s1 \/\\ w2\n    w13 = w2 \/\\ s2 \/\\ a1\n    w14 = a1 \/\\ s3 \/\\ b1\n    w15 = a2\n    w16 = b2 \/\\ s0\n    w17 = s1 \/\\ w3\n    w18 = w3 \/\\ s2 \/\\ a2\n    w19 = a2 \/\\ s3 \/\\ b2\n    w20 = a3\n    w21 = b3 \/\\ s0\n    w22 = s1 \/\\ w4\n    w23 = w4 \/\\ s2 \/\\ a3\n    w24 = a3 \/\\ s3 \/\\ b3\n    w25 = ~(w5 \\\/ w6 \\\/ w7)\n    w26 = ~(w8 \\\/ w9)\n    w27 = ~(w10 \\\/ w11 \\\/ w12)\n    w28 = ~(w13 \\\/ w14)\n    w29 = ~(w15 \\\/ w16 \\\/ w17)\n    w30 = ~(w18 \\\/ w19)\n    w31 = ~(w20 \\\/ w21 \\\/ w22)\n    w32 = ~(w23 \\\/ w24)\n    w33 = (w25 ^ w26)\n    w34 = (w27 ^ w28)\n    w35 = (w29 ^ w30)\n    w36 = (w31 ^ w32)\n    w37 = ~(w0 \/\\ c)\n    w38 = w0 \/\\ w25\n    w39 = (w0 \/\\ w26 \/\\ c)\n    w40 = (w0 \/\\ w27)\n    w41 = (w0 \/\\ w25 \/\\ w28)\n    w42 = (w0 \/\\ w28 \/\\ w26 \/\\ c)\n    w43 = (w0 \/\\ w29)\n    w44 = (w0 \/\\ w27 \/\\ w30)\n    w45 = (w0 \/\\ w25 \/\\ w30 \/\\ w28)\n    w46 = (w0 \/\\ w30 \/\\ w28 \/\\ w26 \/\\ c)\n    w47 = ~(w26 \/\\ w28 \/\\ w30 \/\\ w32)\n    w48 = ~(c \/\\ w26 \/\\ w28 \/\\ w30 \/\\ w32)\n    w49 = (w25 \/\\ w28 \/\\ w30 \/\\ w32)\n    w50 = (w27 \/\\ w30 \/\\ w32)\n    w51 = (w29 \/\\ w32)\n    w52 = w31\n    w53 = w37\n    w54 = ~(w38 \\\/ w39)\n    w55 = ~(w40 \\\/ w41 \\\/ w42)\n    w56 = ~(w43 \\\/ w44 \\\/ w45 \\\/ w46)\n    w57 = ~(w49 \\\/ w50 \\\/ w51 \\\/ w52)\n    w58 = (w53 ^ w33)\n    w59 = (w54 ^ w34)\n    w60 = (w55 ^ w35)\n    w61 = (w56 ^ w36)\n    w62 = (~w48 \\\/ ~w57)\n    w63 = (w58 \/\\ w59 \/\\ w60 \/\\ w61)\n    f0 = w58\n    f1 = w59\n    f2 = w60\n    f3 = w61\n    a_b = w63\n    p = w47\n    cout = w62\n    g = w57\n\nv00 = f74181_netlist True False False True True False False\n                     False True True False False True True\n\nf74181_fout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 = \n   [(f74181_f0 c a0 b0 m s0 s1 s2 s3),\n    (f74181_f1 c a0 a1 b0 b1 m s0 s1 s2 s3),\n    (f74181_f2 c a0 a1 a2 b0 b1 b2 m s0 s1 s2 s3),\n    (f74181_f3 c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)]\n\nproperty xorWorks c a0 a1 a2 a3 b0 b1 b2 b3 =\n   (f74181_fout c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3) == (v_xor a b)\n     where\n       a = [a0,a1,a2,a3]\n       b = [b0,b1,b2,b3]\n       s0 = False\n       s1 = True\n       s2 = True\n       s3 = False\n       m = True\n\nproperty addingWorks c a0 a1 a2 a3 b0 b1 b2 b3 =\n         [out0,out1,out2,out3,cout] == (v_adder c a b)\n  where\n    a = [a0,a1,a2,a3];\n\t b = [b0,b1,b2,b3]\n    s0 = True\n    s1 = False\n    s2 = False\n    s3 = True\n    m = False\n    output = (f74181_spec (~c) a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)\n    out0 = output@0\n    out1 = output@1\n    out2 = output@2\n    out3 = output@3\n    out4 = output@4\n    cout = ~out4\n\nproperty itWorks c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3 =\n    (f74181_spec c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3) ==\n    (f74181_netlist c a0 a1 a2 a3 b0 b1 b2 b3 m s0 s1 s2 s3)\n  where\n    a = [a0,a1,a2,a3]\n    b = [b0,b1,b2,b3]\n```"}]}
{"filename":"SAW-course\/src\/lab3C\/f74181_tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, write the function `logicStuff` and the property `logicStuffWorks` that verifies `logicStuff` matches the 4-bit output slice of `f74181_spec` for all 74181 input bits, as described, with the given Boolean and 4-bit vector behavior."},{"role":"assistant","content":"```cryptol\nmodule f74181_tests where\nimport sn74as181a\n\nlogicStuff a0 a1 a2 a3 b0 b1 b2 b3 s0 s1 s2 s3 = \n  if s == 0 then ~(a) else\n  if s == 1 then ~(a || b) else\n  if s == 2 then (~a && b) else\n  if s == 3 then 0 else\n  if s == 4 then ~(a && b) else\n  if s == 5 then ~b else\n  if s == 6 then (a ^ b) else\n  if s == 7 then a && ~b else\n  if s == 8 then ~a || b else\n  if s == 9 then ~(a ^ b) else\n  if s == 10 then b else\n  if s == 11 then a && b else\n  if s == 12 then 15 else\n  if s == 13 then a || ~b else\n  if s == 14 then a || b else a\n    where\n      a = [a0,a1,a2,a3]:[4];\n\t   b = [b0,b1,b2,b3]:[4];\n\t   s = [s3,s2,s1,s0]:[4]\n\nproperty logicStuffWorks a0 a1 a2 a3 b0 b1 b2 b3 s0 s1 s2 s3 =\n    (logicStuff a0 a1 a2 a3 b0 b1 b2 b3 s0 s1 s2 s3) ==\n    (f74181_spec True a0 a1 a2 a3 b0 b1 b2 b3 True s0 s1 s2 s3)@@[0,1,2,3]\n```"}]}
{"filename":"SAW-course\/src\/lab4\/perm.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the permutation-checking function perm over sequences of 32-bit words and the properties permReflexive, permSymmetric, and permTransitive as given, suitable for verification that perm is an equivalence relation under the stated constraints."},{"role":"assistant","content":"```cryptol\nmodule perm where\n\nremove lst n = drop `{2} [w.0 | w <- z]\n  where\n    z = [(-1,False)]#[ if (q.1 == False \/\\ ~(za == n)) \n                       then (za, q.1)\n                       else (zb, True)\n                     | za <- [-1]#lst | zb <- lst#[-1] | q <- z ]\n\nmember lst n = z ! 0\n  where\n    z = [False]#[ ss \\\/ (p == n) | p <- lst | ss <- z ]\n\nperm x y = if (length x) == 0 \/\\ (length y) == 0 then True else\n           if (length x) == (length y) then (z ! 0).1 else False\n  where\n    z = [ ((remove q.0 p), (member q.0 p) \/\\ q.1)\n        | q <- [(y,True)]#z | p <- x ]\n\npermReflexive : [10][32] -> [10][32] -> Bit\nproperty permReflexive x y = ~(x == y) \\\/ perm x y\n\npermSymmetric : [10][32] -> [10][32] -> Bit\nproperty permSymmetric x y =\n   if ~(member x (2^^32-1)) \/\\ ~(member y (2^^32-1)) \/\\ perm x y\n   then perm y x else True\n\npermTransitive : [6][32] -> [6][32] -> [6][32] -> Bit\nproperty permTransitive x y z =\n   if ~(member x (2^^32-1)) \/\\ ~(member y (2^^32-1)) \/\\ ~(member z (2^^32-1)) \/\\\n       perm x y \/\\ perm y z\n   then perm x z else True\n```"}]}
{"filename":"SAW-course\/src\/lab4\/bsort.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the `bsort` function as a bubble-sort on lists, and properties `isAPerm` and `bsortIsOrdered` showing that `bsort` produces a permutation of the input and that its output is nondecreasing for valid inputs."},{"role":"assistant","content":"```cryptol\nimport perm\n\nbsort : {n, a} (Cmp a, Integral a, Literal 1 a, fin n) => [n]a -> [n]a\nbsort lst = take `{n} (bb (lst#[-1,-1...]))\n  where\n    bb seq = if (seq@0) == -1 then seq else (bbl (head seq) (bb (tail seq)))\n    bbl n seq =\n      if ((seq@0) == -1) then [n]#[-1,-1...]\n      else if (n < (seq@0)) then [n]#seq\n      else [(seq@0)]#(bbl n (tail seq))\n\nvalid lst = z ! 0\n  where\n    z = [True]#[~(x == -1) \/\\ y | x <- lst | y <- z ]\n\nisAPerm : [6][32] -> Bit\nproperty isAPerm lst = ~(valid lst) \\\/ perm lst (bsort lst)\n\nnondecreasing : [6][32] -> Bit\nnondecreasing lst = z ! 0\n  where\n    z = [True]#[ if (j1 <= j2) \/\\ k then True else False\n               | k <- z | j1 <- lst | j2 <- drop `{1} lst]\n\nbsortIsOrdered : [6][32] -> Bit\nproperty bsortIsOrdered lst = ~(valid lst) \\\/ nondecreasing (bsort lst)\n```"}]}
{"filename":"SAW-course\/src\/lab4\/mrgsrt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the mergesort function and proves, via properties, that mergesort preserves permutations of the input and returns a nondecreasing sequence for 6-element [32]-bit integer lists using the given valid predicate."},{"role":"assistant","content":"```cryptol\nimport perm\n\nsplito : {n,a} [n]a -> [inf]a\nsplito lst = [ lst@i | i <- [1,3...] ]\n\nsplite : {n,a} [n]a -> [inf]a\nsplite lst = [ lst@i | i <- [0,2...] ]\n\nmerge : {a} (Literal 1 a, Ring a, Cmp a) => [inf]a -> [inf]a -> [inf]a\nmerge px py = \n      if px@0 == -1 then py\n      else if py@0 == -1 then px\n      else if px@0 < py@0 then [px@0]#(merge (tail px) py)\n      else [py@0]#(merge px (tail py))\n\nmergesort : {cnt, a} (fin cnt, fin a, a >= 1, cnt >= 0) => [cnt][a] -> [cnt][a]\nmergesort lst = take `{cnt} (mergesrt ax)\n  where\n    mergesrt p = \n      if p@0 == -1 \\\/ p@1 == -1 then p\n      else merge (mergesrt (splite p)) (mergesrt (splito p))\n    ax = lst#[-1,-1 ...]\n\nres00 = take `{3} (splite [1,2,3,4,5,6])\nres01 = take `{3} (splite [1,2,3,4,5,6,7])\nres02 = take `{4} (splite [1,2,3,4,5,6,7,8])\n\nres10 = take `{3} (splito [1,2,3,4,5,6])\nres11 = take `{4} (splito [1,2,3,4,5,6,7])\nres12 = take `{4} (splito [1,2,3,4,5,6,7,8])\n\nres20 = take `{8} (merge ([1,5,7,10]#[-1,-1 ...]) ([3,7,11,14]#[-1,-1 ...]))\n\nres30 = mergesort [6,7,8,2,3,4,1,11,23,5]\nres31 = mergesort [1]\nres32 = mergesort [2,2]\nres33 = mergesort [2,1]\nres34 = mergesort [9,8,7,6,5,4,3,2,1]\nres35 = mergesort [9,8,7,6,5,4,3,2,1,6]\nres36 = mergesort [9,8,7,6,5,4,3,2,1,6,10]\nres37 = mergesort [9,8,7,6,5,4,3,2,10,6,1]\nres38 = mergesort [1,9,8,7,6,5,4,3,2,1,6]\nres39 = mergesort [10,9,8,7,6,5,4,3,2,1,6]\n\nresults = [take `{11} (res30#[-1,-1...]),\n           take `{11} (res31#[-1,-1...]),\n           take `{11} (res32#[-1,-1...]),\n           take `{11} (res33#[-1,-1...]),\n           take `{11} (res34#[-1,-1...]),\n           take `{11} (res35#[-1,-1...]),\n           take `{11} (res36#[-1,-1...]),\n           take `{11} (res37#[-1,-1...]),\n           take `{11} (res38#[-1,-1...]),\n           take `{11} (res39#[-1,-1...])]\n\nvalid lst = z ! 0\n  where\n    z = [True]#[~(x == -1) \/\\ y | x <- lst | y <- z ]\n\nisAPerm : [6][32] -> Bit\nproperty isAPerm lst = ~(valid lst) \\\/ perm lst (mergesort lst)\n\nnondecreasing lst = z ! 0\n  where\n    z = [True]#[ if (j1 <= j2) \/\\ k then True else False\n               | k <- z | j1 <- lst | j2 <- drop `{1} lst]\n\nmergesortIsOrdered : [6][32] -> Bit\nproperty mergesortIsOrdered lst =\n    ~(valid lst) \\\/ nondecreasing (mergesort lst)\n```"}]}
{"filename":"SAW-course\/src\/lab4\/sort_com.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the sorting functions and properties in this file, including `round`, `insert`, `makeNegs`, `sort`, `valid`, and properties `isAPerm` and `sortIsOrdered` over `[6][32]` lists, verifying permutation preservation and nondecreasing order for valid inputs."},{"role":"assistant","content":"```cryptol\nimport perm\n\nround : {n, b} (Literal 1 b, Ring b, Cmp b, fin n) => [1 + n]b -> [1 + n]b\nround lst = z ! 0\n  where\n    z = [q]#[ if lst@i > acc@(i+1)\n              then (insert (insert acc (acc@(i+1)) i) (lst@i) (i+1))\n              else (insert acc (lst@i) i)\n        | acc <- z | i <- (reverse (take `{n} [0...])) ]\n    q = insert (makeNegs lst) (last lst) ((length lst)-1)\n\ninsert lst m i = [ if k==i then m else x | x <- lst | k <- [0...]]\n\nmakeNegs lst = [ -1 | i <- lst ]\n\nsort lst =  z ! 0\n  where\n    z = [ round x | x <- [lst]#z | i <- lst ]\n\nvalid lst = z ! 0\n  where\n    z = [True]#[ ~(x == -1) \/\\ y | x <- lst | y <- z ]\n\nisAPerm : [6][32] -> Bit\nproperty isAPerm lst =  ~(valid lst) \\\/ perm lst (sort lst)\n\nnondecreasing lst = z ! 0\n  where\n    z = [True]#[ if (j1 <= j2) \/\\ k then True else False\n               | k <- z | j1 <- lst | j2 <- drop `{1} lst]\n\nsortIsOrdered : [6][32] -> Bit\nproperty sortIsOrdered lst = ~(valid lst) \\\/ nondecreasing (sort lst)\n```"}]}
{"filename":"SAW-course\/src\/lab3A\/a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that implements the given 31-bit addition function `plus`, the folding sum function `add`, and the vector function `v`, including appropriate types and any useful properties that can be checked with SAW."},{"role":"assistant","content":"```cryptol\nplus : ([31],[31]) -> [31]\nplus (a, b) = if sab @ 0 then sab' + 1 else sab'\n  where\n     sab = ((zero : [1]) # a) + ((zero : [1]) # b)\n     sab' = drop `{1} sab\n\nadd xs = sums ! 0\n  where\n    sums = [0] # [plus (s, x) | s <- sums | x <- xs]\n\nv (ss) = add [ s <<< c | s <- ss@@[15,13,10,4,0,0]\n                       | c <- [15,17,21,20,8,0]]\n```"}]}
{"filename":"SAW-course\/src\/intr\/bitcoin.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the given boolean helper functions and a property ans : Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit that asserts the Bitcoin-style constraint: from one_is_true conditions on s1,s2,s3 and b1,b2,b3 and setup, it logically implies b1 is True."},{"role":"assistant","content":"```cryptol\none_is_true : Bit -> Bit -> Bit -> Bit\none_is_true x1 x2 x3 =\n  (~x1 \\\/ ~x2) \/\\ (~x1 \\\/ ~x3) \/\\ (~x2 \\\/ ~x3) \/\\ (x1 \\\/ x2 \\\/ x3)\n\niff : Bit -> Bit -> Bit\niff x1 x2 = x1 == x2\n\nnot : Bit -> Bit\nnot x = if x then False else True\n\nsetup : Bit -> Bit -> Bit -> Bit -> Bit -> Bit\nsetup s1 s2 s3 b1 b2 =\n  (iff s1 (not b1)) \/\\ (iff s2 (not b2)) \/\\ (iff s3 b2)\n\nimplies : Bit -> Bit -> Bit\nimplies x1 x2 = if x1 then x2 else True\n\nans : Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit\nproperty ans s1 s2 s3 b1 b2 b3 =\n  (implies ((one_is_true s1 s2 s3) \/\\             (one_is_true b1 b2 b3) \/\\ \t    (setup s1 s2 s3 b1 b2))   \t b1)\n```"}]}
{"filename":"SAW-course\/src\/intr\/kalotan.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models the Kalotan family logic puzzle with bits for each person\u2019s type and defines properties `people_types`, `checkit1`, and `checkit2` capturing the puzzle\u2019s constraints and their logical equivalence as shown."},{"role":"assistant","content":"```cryptol\nxor : Bit -> Bit -> Bit\nxor a b = a ^ b\n\nheterosexual_parents : Bit -> Bit -> Bit\nheterosexual_parents parent1 parent2 = ~(parent1 == parent2)\n\nmeaning_of_kid_lied : Bit -> Bit -> Bit -> Bit\nmeaning_of_kid_lied kid_said kid kid_lied = xor (kid_said == kid) kid_lied\n\nparents_said : Bit -> Bit -> Bit -> Bit -> Bit\nparents_said parent1 kid_said kid kid_lied =\n  if ~parent1 then (~kid_said \/\\ (xor kid kid_lied)) else (kid \/\\ kid_lied)\n\npeople_types : Bit -> Bit -> Bit -> Bit -> Bit -> Bit\nproperty people_types parent1 parent2 kid_said kid kid_lied =\n (heterosexual_parents parent1 parent2 \/\\\n  meaning_of_kid_lied kid_said kid kid_lied \/\\\n  parents_said parent1 kid_said kid kid_lied)\n\nproperty checkit1 parent1 parent2 kid kid_said kid_lied =\n  ~(parent1 \/\\ ~parent2 \/\\ ~kid_said \/\\ kid \/\\ kid_lied) \/\\\n  (people_types parent1 parent2 kid_said kid kid_lied)\n\nproperty checkit2 parent1 parent2 kid kid_said kid_lied =\n  ~(people_types parent1 parent2 kid_said kid kid_lied) \\\/\n  (parent1 \/\\ ~parent2 \/\\ ~kid_said \/\\ kid \/\\ kid_lied)\n```"}]}
{"filename":"SAW-course\/src\/intr\/comprehensions.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the same list comprehensions v01\u2013v15 (including their recursive\/self-referential forms) and a property that checks these definitions produce the expected finite prefixes and element values."},{"role":"assistant","content":"```cryptol\nv01 = [x | x <- [1...] | y <- [1..10]]\n\nv02 = [ (x,y) | x <- [10..12] , y <- [1..4]]\n\nv03 = [ (x,y,z) | x <- [10,11] , y <- [20,21], z <- [30,31]]\n\nv04 = [ (x,y,z) | x <- [10,11] , y <- [20,21] | z <- [30,31,32]]\n\nv05 = [1]#[ x+y | x <- v05 | y <- [1]#v05 ]\nv06 = take `{10} v05\n\nph = [1,1,1,0,1,2,2,1,1]  v07 = [0]#[ x+y | x <- ph | y <- v07 ]  v08 = v07 ! 0 \nv09 = [True]#[ (x <= 1) \/\\ y | x <- ph | y <- v09 ]\nv10 = v09 ! 0\n\nlst = [16,42,23,77]\nv11 = [lst] # [[b]#(tail (a >> 1)) | a <- v11 | b <- lst ]\nv12 = v11 ! 0\n\np = 3\nv13 = [ 2*lr | lr <- [p] # v13 | k <- [1 .. 16]]\n\nv14 = [2*lr | lr <- [p] # v14 | k <- [1...]]\nv15 = take `{12} v14\n```"}]}
{"filename":"SAW-course\/src\/intr\/bat.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models the Bitcoin and tiger room puzzle with boolean variables for rooms, tigers, and signs, and define the property `Bitcoin_and_tiger` as given so it can be checked for satisfiability using a solver."},{"role":"assistant","content":"```cryptol\nBitcoin_in_one_room b1 b2 b3 b4 b5 b6 b7 b8 b9 =\n   ((~b1) \\\/ (~b2)) \/\\\n   ((~b1) \\\/ (~b3)) \/\\\n   ((~b1) \\\/ (~b4)) \/\\\n   ((~b1) \\\/ (~b5)) \/\\\n   ((~b1) \\\/ (~b6)) \/\\\n   ((~b1) \\\/ (~b7)) \/\\\n   ((~b1) \\\/ (~b8)) \/\\\n   ((~b1) \\\/ (~b9)) \/\\\n   ((~b2) \\\/ (~b3)) \/\\\n   ((~b2) \\\/ (~b4)) \/\\\n   ((~b2) \\\/ (~b5)) \/\\\n   ((~b2) \\\/ (~b6)) \/\\\n   ((~b2) \\\/ (~b7)) \/\\\n   ((~b2) \\\/ (~b8)) \/\\\n   ((~b2) \\\/ (~b9)) \/\\\n   ((~b3) \\\/ (~b4)) \/\\\n   ((~b3) \\\/ (~b5)) \/\\\n   ((~b3) \\\/ (~b6)) \/\\\n   ((~b3) \\\/ (~b7)) \/\\\n   ((~b3) \\\/ (~b8)) \/\\\n   ((~b3) \\\/ (~b9)) \/\\\n   ((~b4) \\\/ (~b5)) \/\\\n   ((~b4) \\\/ (~b6)) \/\\\n   ((~b4) \\\/ (~b7)) \/\\\n   ((~b4) \\\/ (~b8)) \/\\\n   ((~b4) \\\/ (~b9)) \/\\\n   ((~b5) \\\/ (~b6)) \/\\\n   ((~b5) \\\/ (~b7)) \/\\\n   ((~b5) \\\/ (~b8)) \/\\\n   ((~b5) \\\/ (~b9)) \/\\\n   ((~b6) \\\/ (~b7)) \/\\\n   ((~b6) \\\/ (~b8)) \/\\\n   ((~b6) \\\/ (~b9)) \/\\\n   ((~b7) \\\/ (~b8)) \/\\\n   ((~b7) \\\/ (~b9)) \/\\\n   ((~b8) \\\/ (~b9)) \/\\\n   (b1 \\\/ b2 \\\/ b3 \\\/ b4 \\\/ b5 \\\/ b6 \\\/ b7 \\\/ b8 \\\/ b9)\n\nBitcoin_not_in_tiger_room b1 b2 b3 b4 b5 b6 b7 b8 b9 t1 t2 t3 t4 t5 t6 t7 t8 t9 =\n   ((~b1) \\\/ (~t1)) \/\\\n   ((~b2) \\\/ (~t2)) \/\\\n   ((~b3) \\\/ (~t3)) \/\\\n   ((~b4) \\\/ (~t4)) \/\\\n   ((~b5) \\\/ (~t5)) \/\\\n   ((~b6) \\\/ (~t6)) \/\\\n   ((~b7) \\\/ (~t7)) \/\\\n   ((~b8) \\\/ (~t8)) \/\\\n   ((~b9) \\\/ (~t9))\n\nassign_values_to_signs b1 b2 b3 b4 b5 b6 b7 b8 b9\n                       t1 t2 t3 t4 t5 t6 t7 t8 t9\n                       s1 s2 s3 s4 s5 s6 s7 s8 s9 =\n  (s1 == (b1 \\\/ b3 \\\/ b5 \\\/ b7 \\\/ b9)) \/\\   \n  (s2 == ((~t2) \/\\ (~b2))) \/\\    \n  (s3 == (s5 \\\/ (~s7))) \/\\       \n  (s4 == (~s1)) \/\\               \n  (s5 == ((~s2) \\\/ s4)) \/\\       \n  (s6 == (~s3)) \/\\               \n  (s7 == (~b1)) \/\\               \n  (s8 == (t8 \/\\ (~t9) \/\\ (~b9))) \/\\  \n  (s9 == (t9 \/\\ (~s6))) \/\\       \n  (~t1 \\\/ ~s1) \/\\                \n  (~t2 \\\/ ~s2) \/\\                \n  (~t3 \\\/ ~s3) \/\\                \n  (~t4 \\\/ ~s4) \/\\                \n  (~t5 \\\/ ~s5) \/\\                \n  (~t6 \\\/ ~s6) \/\\                \n  (~t7 \\\/ ~s7) \/\\                \n  (~t8 \\\/ ~s8) \/\\                \n  (~t9 \\\/ ~s9) \/\\                \n  (~b1 \\\/ s1) \/\\                 \n  (~b2 \\\/ s2) \/\\                 \n  (~b3 \\\/ s3) \/\\                 \n  (~b4 \\\/ s4) \/\\                 \n  (~b5 \\\/ s5) \/\\                 \n  (~b6 \\\/ s6) \/\\                 \n  (~b7 \\\/ s7) \/\\                 \n  (~b8 \\\/ s8) \/\\                 \n  (~b9 \\\/ s9)                    \n\nBitcoin_in_room room = room\n\nproperty Bitcoin_and_tiger b1 b2 b3 b4 b5 b6 b7 b8 b9\n                           t1 t2 t3 t4 t5 t6 t7 t8 t9\n                           s1 s2 s3 s4 s5 s6 s7 s8 s9 =\n   ~((Bitcoin_in_one_room b1 b2 b3 b4 b5 b6 b7 b8 b9) \/\\\n     (Bitcoin_not_in_tiger_room b1 b2 b3 b4 b5 b6 b7 b8 b9\n                                t1 t2 t3 t4 t5 t6 t7 t8 t9) \/\\\n     (assign_values_to_signs b1 b2 b3 b4 b5 b6 b7 b8 b9 \n                             t1 t2 t3 t4 t5 t6 t7 t8 t9\n                             s1 s2 s3 s4 s5 s6 s7 s8 s9) \/\\\n     (t8 \\\/ t9))            \n    \\\/ (Bitcoin_in_room b7)\n```"}]}
{"filename":"SAW-course\/src\/lab6C\/linear_search_1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, write a specification and corresponding properties to verify that linSearchIdx correctly returns the first index of key in a 10-element [16]-bit array xs (or 255 if absent), and that inputOK correctly enforces the precondition required by linSearchIdx."},{"role":"assistant","content":"```cryptol\ninputOK : [10][16] -> [8]\ninputOK elmts = z ! 0\n  where\n    z = [1]#[ if x >= y \/\\ q == 1 then 0 else q\n            | q <- z | x <- elmts | y <- (tail elmts) ]\n\nlinSearchIdx : [16] -> [10][16] -> [8]\nlinSearchIdx key xs = if (inputOK xs) == 1 then s!0 else 255\n  where\n    s = [255]#[ if (key == x \/\\ h == -1) then c else h\n              | x <- xs |  h <- s | c <- [0...]]\n```"}]}
{"filename":"SAW-course\/src\/lab2C\/foxChickenCorn.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that specify and verify the fox\u2013chicken\u2013corn river crossing puzzle solution, ensuring neighborsConsistent, allStatesSafeAndValid, allStatesUnique, and that any valid sequence starts at startState and ends at endState using solution : [8]BankState -> Bit."},{"role":"assistant","content":"```cryptol\ntype OneBank = [4]\ntype BankState = {left : OneBank, right: OneBank }\n\nstartState : BankState\nstartState = { left = 0b1111, right = 0b0000 }\nendState : BankState\nendState = { left = 0b0000, right = 0b1111 }\n\nsolution : [8]BankState -> Bit\nproperty solution states =\n\t(neighborsConsistent states) \/\\\n\t(allStatesSafeAndValid states) \/\\\n\t(allStatesUnique states) \/\\\n\t(states ! 0 == endState) \/\\\n\t(states @ 0 == startState)\n\nneighborsConsistent states = z ! 0\n  where\n    z = [True]#[ ((y == nextState x 0) \\\/\n                  (y == nextState x 1) \\\/\n\t\t\t         (y == nextState x 2)) \/\\ p\n\t            | x <- states | y <- drop `{1} states | p <- z]\n\nnextState : BankState -> [4] -> BankState\nnextState s idx =\n   if s.right % 2 == 1 then\n     { left = s.left || s.right && (0b0001 || (1 << (idx+1))),\n       right = s.right && 0b1110 && (~ (1 << (idx+1):[4])) }\n   else\n     { left = s.left && 0b1110 && (~ (1 << (idx+1):[4])),\n       right = s.right || s.left && (0b0001 || (1 << (idx+1))) }\n\nallStatesSafeAndValid : {n} (fin n) => [n]BankState -> Bit\nallStatesSafeAndValid states = z ! 0\n  where\n    z = [True]#[ safeAndValidState y \/\\ x | y <- states | x <- z ]\n\nsafeAndValidState : BankState -> Bit\nsafeAndValidState s =\n   ~(s.left == 10 \\\/ s.left == 6 \\\/ s.right == 10 \\\/ s.right == 6) \/\\\n\ts.left ^ s.right == 0xF\n\nallStatesUnique states = ~(z ! 0)\n  where\n    z = [False]#[ (states@i == states@j \/\\ ~(i == j)) \\\/ k\n\t             | k <- z | i <- [0..7] , j <- [0..7] ]\n\npp states = [ xlate state | state <- states]\n\nxlate : BankState -> [51][8]\nxlate state =\n  if (state.left == 0b1111 \/\\ state.right == 0b0000) then\n     \"fox corn chicken farmer || empty                   \"\n  else if (state.left == 0b0011 \/\\ state.right == 0b1100) then\n     \"         chicken farmer || fox corn                \"\n  else if (state.left == 0b1011 \/\\ state.right == 0b0100) then\n     \"     fox chicken farmer || corn                    \"\n  else if (state.left == 0b0111 \/\\ state.right == 0b1000) then\n     \"    corn chicken farmer || fox                     \"\n  else if (state.left == 0b1100 \/\\ state.right == 0b0011) then\n     \"               fox corn || chicken farmer          \"\n  else if (state.left == 0b0000 \/\\ state.right == 0b1111) then\n     \"                  empty || fox corn chicken farmer \"\n  else if (state.left == 0b1101 \/\\ state.right == 0b0010) then\n     \"        fox corn farmer || chicken                 \"\n  else if (state.left == 0b1000 \/\\ state.right == 0b0111) then\n     \"                    fox || corn chicken farmer     \"\n  else if (state.left == 0b0010 \/\\ state.right == 0b1101) then\n     \"                chicken || fox corn farmer         \"\n  else if (state.left == 0b0100 \/\\ state.right == 0b1011) then\n     \"                   corn || fox chicken farmer      \"\n  else\n     \"                      error                        \"\n\ns1 = [{left = 0b1111, right = 0b0000},\n      {left = 0b1100, right = 0b0011},\n\t\t{left = 0b1101, right = 0b0010},\n\t\t{left = 0b1000, right = 0b0111},\n\t\t{left = 0b1011, right = 0b0100},\n\t\t{left = 0b0010, right = 0b1101},\n\t\t{left = 0b0011, right = 0b1100},\n\t\t{left = 0b0000, right = 0b1111}]\n\ns2 = [{left = 0b1111, right = 0b0000},\n      {left = 0b1100, right = 0b0011},\n      {left = 0b1101, right = 0b0010},\n\t\t{left = 0b0100, right = 0b1011},\n      {left = 0b0111, right = 0b1000},\n\t\t{left = 0b0010, right = 0b1101},\n      {left = 0b0011, right = 0b1100},\n\t\t{left = 0b0000, right = 0b1111}]\n\nt1 = { left=0b0100, right=0b1011 }\nt2 = { left=0b0011, right=0b1100 }\nt3 = { left=0b1001, right=0b0110 }\nt4 = { left=0b1001, right=0b0111 }\nt5 = { left=0b1111, right=0b0000 }\nt6 = { left=0b0000, right=0b1111 }\nt7 = { left=0b1011, right=0b0100 }\nt8 = { left=0b1101, right=0b0010 }\n```"}]}
{"filename":"SAW-course\/src\/lab2C\/warmup.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the given SHAState record type, its stateInit constant, the stateManip function that updates only md_len to 42, and the constants H0, v1, and v2 with the same types and values, under the given parameterized width constraints."},{"role":"assistant","content":"```cryptol\nparameter\n  type w : #\n  type constraint (fin w, w <= 64, 32 <= w)\n\ntype SHAState = { h : [8][64],\n                  block : [128][8],\n                  Nl : [64],\n\t\t\t\t\t\tNh : [64],\n                  num : [32],\n\t\t\t\t\t\tmd_len : [32]\n                }\n\nstateInit : SHAState\nstateInit = { h = [1,2,3,4,5,6,7,8],\n              block = zero,\n\t\t\t\t  Nl = 11,\n\t\t\t\t  Nh = 16,\n\t\t\t\t  num = 1,\n\t\t\t\t  md_len = 128 }\n\nstateManip : SHAState -> SHAState\nstateManip s = { h = s.h,\n                 block = s.block,\n\t\t\t\t\t  Nl = s.Nl,\n\t\t\t\t\t  Nh = s.Nh,\n\t\t\t\t\t  num = s.num,\n\t\t\t\t\t  md_len = 42 }\n\nH0 : [2][w]\nH0 = [100,101]\n\nv1 : [2][32]\nv1 = [23,34]\n\ntype v2 = [2][32]\nv2 = [23,34]\n```"}]}
{"filename":"SAW-course\/src\/lab2C\/solutions.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the given Circle\/Displacement\/BMI\/BMIimp record types and implements the functions areaCircle, nudgeCircle, calcBMI, and calcBMIimp, along with the sample constants aCircle, disp, newDisp, t1, and t2."},{"role":"assistant","content":"```cryptol\nimport Float\n\ntype Circle = { radius : Rational, left : Float16, top : Float16 }\ntype Displacement = { left : Float16, top : Float16 }\n\naCircle : Circle\naCircle = { radius=(ratio 5 2), left=20, top=16}\n\nareaCircle : Circle -> Rational\nareaCircle b = (b.radius * b.radius * (ratio 355 113))\n\nc = areaCircle { radius=(ratio 5 2), left=0, top=0 }\n\naCircleArea = areaCircle aCircle\n\nnudgeCircle : Circle -> Displacement -> Circle\nnudgeCircle circle d =\n   { radius = circle.radius, left = circle.left+d.left, top = circle.top+d.top }\n\ndisp : Displacement\ndisp = { left= 12, top=2 }\n\nnewDisp : Displacement \nnewDisp = { left = -32, top=2 }\n\nmovedaCircle = nudgeCircle aCircle disp\nsecondTry = nudgeCircle aCircle newDisp\n\ntype BMI = { weight : Float16, height : Float16 }\ntype BMIimp = { weight : Float16, feet : Float16, inches : Float16 }\n\ncalcBMI : BMI -> Float16\ncalcBMI bmi = bmi.weight \/. bmi.height \/. bmi.height * 10000\n\ncalcBMIimp : BMIimp -> Float16\ncalcBMIimp bmi = bmi.weight \/. (bmi.feet*12+bmi.inches) \/. (bmi.feet*12+bmi.inches) * 703\n\nt1 = { weight=80, height=174 }\nt2 = { weight=180.0, feet=5.0, inches=8.5 }\n```"}]}
{"filename":"SAW-course\/src\/lab2D\/racetrack.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models this racetrack refueling sequence using loc, gas, and s, and define properties to verify that station and station_location are computed correctly for all inputs."},{"role":"assistant","content":"```cryptol\nloc = [ (ratio 2 10), (ratio 3 10), (ratio 45 100), (ratio 49 100),\n        (ratio 71 100), (ratio 78 100), (ratio 81 100), (ratio 98 100)]\n\ngas = [ (ratio 1 10), (ratio 13 100), (ratio 1 10), (ratio 15 100),\n        (ratio 23 100), (ratio 7 100), (ratio 17 100), (ratio 5 100)]\n\ns = [(0,0,-1)]#[(if (ps-ss.0 > ss.1) then (ss.0+fs, ps-ss.0, i)\n                                     else (ss.0+fs,ss.1,ss.2))\n               | fs <- gas | ps <- loc | ss <- s | i <- [0 ...]]\n\nstation = (s ! 0).2\nstation_location = loc @ station\n```"}]}
{"filename":"SAW-course\/src\/lab2D\/comprehensions.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines all the given list comprehensions (v01\u2013v16 and related values) and adds properties that check their lengths, selected elements, and recursive behaviors match the intended list-processing semantics."},{"role":"assistant","content":"```cryptol\nv01 = [x | x <- [1...] | y <- [1..10]]\n\nv02 = [ (x,y) | x <- [10..12] , y <- [1..4]]\n\nv03 = [ (x,y,z) | x <- [10,11] , y <- [20,21], z <- [30,31]]\n\nv04 = [ (x,y,z) | x <- [10,11] , y <- [20,21] | z <- [30,31,32]]\n\nv05 = [1]#[ x+y | x <- v05 | y <- [1]#v05 ]\nv06 = take `{10} v05\n\nph = [1,1,1,0,1,2,2,1,1]  v07 = [0]#[ x+y | x <- ph | y <- v07 ]  v08 = v07 ! 0 \nv09 = [True]#[ (x <= 1) \/\\ y | x <- ph | y <- v09 ]\nv10 = v09 ! 0\n\nlst = [16,42,23,77]\nv11 = [lst] # [[b]#(tail (a >> 1)) | a <- v11 | b <- lst ]\nv12 = v11 ! 0\n\np = 3\nv13 = [ 2*lr | lr <- [p] # v13 | k <- [1 .. 16]]\n\nv14 = [2*lr | lr <- [p] # v14 | k <- [1...]]\nv15 = take `{12} v14\n\nloc = [(ratio 2 10),(ratio 3 10),(ratio 45 100),(ratio 49 100),\n       (ratio 71 100),(ratio 78 100),(ratio 81 100),(ratio 98 100)]\ngas = [(ratio 1 10),(ratio 13 100),(ratio 1 10),(ratio 15 100),\n       (ratio 23 100),(ratio 7 100),(ratio 17 100),(ratio 5 100)]\ngas_sum = sum gas\nv16 = [(0,0,-1)]#[(if (ps-ss.0 > ss.1) then (ss.0+fs, ps-ss.0, i)\n                                       else (ss.0+fs, ss.1, ss.2))\n                 | fs <- gas | ps <- loc | ss <- v16 | i <- [0 ...]]\nstation_to_start_from = (v16 ! 0).2\nlocation_of_station = loc @ station_to_start_from\n```"}]}
{"filename":"SAW-course\/src\/lab2D\/solutions.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol properties that specify and verify that fmax finds the maximum element index, member tests membership, remove removes a value, perm checks whether two lists are permutations, and nondecreasing checks if a list is sorted nondecreasing, for sequences of integers."},{"role":"assistant","content":"```cryptol\nfmax lst = (res ! 0).0\n  where\n    res = [(-1,-1)]#[ if (ss.0 < p) then (p,i) else ss\n                    | p <- lst | ss <- res | i <- [0...]]\n\nmember lst n = (res ! 0)\n  where\n    res = [False]#[ s \\\/ (p == n) | p <- lst | s <- res ]\n\nremove lst n = drop `{2} [w.0 | w <- res]\n  where\n    res = [(-1,False)]#[ if (q.1==False \/\\ ~(za == n)) then (za, q.1)\n                                                       else (zb, True)\n          | za <- [-1]#lst | zb <- lst#[-1] | q <- res ]\n\nperm x y = (res ! 0).1\n  where\n    res = [ ((remove q.0 p), (member q.0 p) \/\\ q.1)\n          | q <- [(y,True)]#res | p <- x ]\n\nnondecreasing lst = (res ! 0)\n  where \n    res = [True]#[ if (j1 <= j2) \/\\ k then True else False\n                 | k <- res | j1 <- lst | j2 <- drop `{1} lst]\n```"}]}
{"filename":"SAW-course\/src\/lab2E\/perm.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines functions `remove`, `member`, and `perm` over sequences, where `perm` returns `True` iff its two input sequences are permutations of each other, matching the given typeclass and size constraints."},{"role":"assistant","content":"```cryptol\nmodule perm where\n\nremove : {n, a} (Eq a, Ring a, Literal 1 a, fin n) => [n]a -> a -> [n]a\nremove lst n = drop `{2} [w.0 | w <- res]\n  where\n    res = [(-1,False)]#[ if (q.1 == False \/\\ ~(za == n)) then (za, q.1)\n                                                         else (zb, True)\n                       | za <- [-1]#lst | zb <- lst#[-1] | q <- res ]\n\nmember : {n, a} (Eq a, fin n) => [n]a -> a -> Bit\nmember lst n = (res ! 0)\n  where\n    res = [False]#[ ss \\\/ (p == n) | p <- lst | ss <- res ]\n\nperm :\n  {n, m, a} (Literal 1 a, Ring a, Eq a, fin n, fin m) => [n]a -> [m]a -> Bit\nperm x y = if (length x) == 0 \/\\ (length y) == 0 then True else\n           if (length x) == (length y) then (res ! 0).1 else False\n  where\n    res = [ ((remove q.0 p), (member q.0 p) \/\\ q.1)\n          | q <- [(y,True)]#res | p <- x ]\n```"}]}
{"filename":"SAW-course\/src\/lab2E\/bsort.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the function bsort, the auxiliary function valid, and the property isAPerm : [16][4] -> Bit asserting that whenever valid holds, bsort produces a permutation of its input as checked by perm."},{"role":"assistant","content":"```cryptol\nmodule bsort where\nimport perm\n\nbsort : {n, a} (Cmp a, Integral a, Literal 1 a, fin n) => [n]a -> [n]a\nbsort lst = take `{n} (bb (lst#[-1,-1...]))\n  where\n    bb seq = if (seq@0) == -1 then seq else (bbl (head seq) (bb (tail seq)))\n    bbl n seq =\n      if ((seq@0) == -1) then [n]#[-1,-1...]\n      else if (n < (seq@0)) then [n]#seq\n      else [(seq@0)]#(bbl n (tail seq))\n\nvalid lst = z ! 0\n  where\n    z = [True]#[~(x == -1) \/\\ y | x <- lst | y <- z ]\n\nisAPerm : [16][4] -> Bit\nproperty isAPerm lst = ~(valid lst) \\\/ (perm lst (bsort lst))\n\nres00 = bsort []\nres01 = bsort [1]\nres02 = bsort [2,1]\nres03 = bsort [1,2]\nres04 = bsort [7,3,2,8,1,9,2,3,4,1,8,9,4,2,3]\nres05 = bsort [0,0,0,0,1,1,1,1,2,2,2,2,3,3,3]\nres06 = bsort [3,3,3,2,2,2,2,1,1,1,1,0,0,0,0]\n```"}]}
{"filename":"SAW-course\/src\/lab2E\/mrgsrt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines mergesort, its helper functions, and properties showing mergesort produces a permutation of the input and a nondecreasing (sorted) output for all valid inputs of type [6][32]."},{"role":"assistant","content":"```cryptol\nmodule mrgsrt where\n\nremove lst n = drop `{2} [w.0 | w <- res]\n  where\n    res = [(-1,False)]#[ if (q.1 == False \/\\ ~(za == n)) \n                         then (za, q.1)\n                         else (zb, True)\n                       | za <- [-1]#lst | zb <- lst#[-1] | q <- res ]\n\nmember lst n = (res ! 0)\n  where\n    res = [False]#[ ss \\\/ (p == n) | p <- lst | ss <- res ]\n\nperm x y = if (length x) == 0 \/\\ (length y) == 0 then True else\n           if (length x) == (length y) then (res ! 0).1 else False\n  where\n    res = [ ((remove q.0 p), (member q.0 p) \/\\ q.1)\n          | q <- [(y,True)]#res | p <- x ]\n\nsplito : {n,a} [n]a -> [inf]a\nsplito lst = [ lst@i | i <- [1,3...] ]\n\nsplite : {n,a} [n]a -> [inf]a\nsplite lst = [ lst@i | i <- [0,2...] ]\n\nmerge : {a} (Literal 1 a, Ring a, Cmp a) => [inf]a -> [inf]a -> [inf]a\nmerge px py = \n      if px@0 == -1 then py\n      else if py@0 == -1 then px\n      else if px@0 < py@0 then [px@0]#(merge (tail px) py)\n      else [py@0]#(merge px (tail py))\n\nmergesort : {cnt, a} (fin cnt, fin a, a >= 1, cnt >= 0) => [cnt][a] -> [cnt][a]\nmergesort lst = take `{cnt} (mergesrt ax)\n  where\n    mergesrt p = \n      if (p@0 == -1) \\\/ (p@1 == -1) then p\n      else merge (mergesrt (splite p)) (mergesrt (splito p))\n    ax = lst#[-1,-1 ...]\n\nres00 = take `{3} (splite [1,2,3,4,5,6])\nres01 = take `{3} (splite [1,2,3,4,5,6,7])\nres02 = take `{4} (splite [1,2,3,4,5,6,7,8])\n\nres10 = take `{3} (splito [1,2,3,4,5,6])\nres11 = take `{4} (splito [1,2,3,4,5,6,7])\nres12 = take `{4} (splito [1,2,3,4,5,6,7,8])\n\nres20 = take `{8} (merge ([1,5,7,10]#[-1,-1 ...]) ([3,7,11,14]#[-1,-1 ...]))\n\nres30 = mergesort [6,7,8,2,3,4,1,11,23,5]\nres31 = mergesort [1]\nres32 = mergesort [2,2]\nres33 = mergesort [2,1]\nres34 = mergesort [9,8,7,6,5,4,3,2,1]\nres35 = mergesort [9,8,7,6,5,4,3,2,1,6]\nres36 = mergesort [9,8,7,6,5,4,3,2,1,6,10]\nres37 = mergesort [9,8,7,6,5,4,3,2,10,6,1]\nres38 = mergesort [1,9,8,7,6,5,4,3,2,1,6]\nres39 = mergesort [10,9,8,7,6,5,4,3,2,1,6]\n\nresults = [take `{11} (res30#[-1,-1...]),\n           take `{11} (res31#[-1,-1...]),\n\t\t\t  take `{11} (res32#[-1,-1...]),\n\t\t\t  take `{11} (res33#[-1,-1...]),\n\t\t\t  take `{11} (res34#[-1,-1...]),\n\t\t\t  take `{11} (res35#[-1,-1...]),\n\t\t\t  take `{11} (res36#[-1,-1...]),\n\t\t\t  take `{11} (res37#[-1,-1...]),\n\t\t\t  take `{11} (res38#[-1,-1...]),\n\t\t\t  take `{11} (res39#[-1,-1...])]\n\nvalid lst = z ! 0\n  where\n    z = [True]#[~(x == -1) \/\\ y | x <- lst | y <- z ]\n\nisAPerm : [6][32] -> Bit\nproperty isAPerm lst = if valid lst then perm lst (mergesort lst) else True\n\nnondecreasing lst = (res ! 0)\n  where\n    res = [True]#[ if (j1 <= j2) \/\\ k then True else False\n                 | k <- res | j1 <- lst | j2 <- drop `{1} lst]\n\nmergesortIsOrdered : [6][32] -> Bit\nproperty mergesortIsOrdered lst =\n   if valid lst then nondecreasing (mergesort lst) else True\n```"}]}
{"filename":"SAW-course\/src\/lab2E\/caesar.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the Caesar cipher over printable ASCII, including functions `rot`, `shift`, `caesar`, encryption\/decryption examples, and a property `itWorks` that proves decrypting after encrypting with a key recovers the original plaintext for all keys and plaintexts."},{"role":"assistant","content":"```cryptol\nrot s = [' ' .. '~'] <<< s\n\nshift c key = (rot key) @ (c - ' ')\n\ncaesar key msg = [ shift c key | c <- msg ]\n\nenc = caesar 11 \"How Now Brown Cow\"\nenc_ascii = show (enc)\n\ndec = caesar 84 enc\ndec_ascii = show (caesar (95-11) enc)\n\nshow s = [ c:Char | c <- s]\n\nitWorks : [512][8] -> [8] -> Bit\nproperty itWorks pt key = (caesar (95-key) (caesar key pt)) == pt\n```"}]}
{"filename":"SAW-course\/src\/lab2E\/hamming.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the Hamming-number sequence generator `hamming : [n][a] -> [inf][a]` built from a list of primes, and a property `hamGood` that checks the first 100 Hamming numbers from primes [3,5,11] satisfy the given divisibility condition."},{"role":"assistant","content":"```cryptol\ntimes s m = [(s@0)*m]#times (tail s) m\n\nmerge x y = if (x@0) < (y@0) then [x@0]#merge (tail x) y\n                             else [y@0]#merge x (tail y)\n\nhamming primes = ham primes 0\n  where \n    ham p idx =\n      if ((length p) == 0) then [-1,-1...]\n      else if (length p)-1 == idx then\n           [p @ idx] # times (ham p idx) (p@idx)\n      else\n           [p @ idx] # merge (times (ham p idx) (p@idx)) (ham p (idx+1))\n\nhamGood : [64] -> [100][64] -> Bit  \nproperty hamGood x y = \n  ~((x <= 99) \/\\ (y == (take `{100} (hamming [3,5,11])))) \\\/ ~((y@x)%7 == 0)\n```"}]}
{"filename":"SAW-course\/src\/lab2E\/coins.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models the coin puzzle using coin counts a,b,c,d (1,5,10,25 cents), total coin number n, and sum s, including the functions coinPuzzle, coinSum, coinCount, and check with appropriate types and constraints."},{"role":"assistant","content":"```cryptol\ncoinPuzzle : [10] -> [10] -> [10] -> [10] -> [10] -> [10] -> Bit\ncoinPuzzle n s a b c d =\n  (coinCount a b c d n) \/\\ (coinSum a b c d n s) \/\\ (n < 100) \ncoinSum a b c d n s =\n  ((a + 5*b + 10*c + 25*d) == s) \/\\ (n <= s)\n\ncoinCount a b c d n =\n  (((a + b + c + d) == n) \/\\                                             (a <= n \/\\ b <= n \/\\ c <= n \/\\ d <= n))  \n\ncheck a b c d = a*1 + b*5  + c*10 + d*25\n```"}]}
{"filename":"SAW-course\/src\/lab2B\/tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the given list\/sequence processing functions, DES-style S-box table, and example values (tes1, allButLast, rev, funky_0\/1\/2, sum_0\/1, fib_1\/2, split-based results, s1\u2013s8) with the same types and behavior as in the tests.cry file."},{"role":"assistant","content":"```cryptol\ntes1 x = [ x@i | i <- [0,3,2,1,4] ]\nres00 = tes1 [1,2,3,4,5]\n\nallButLast : {a, b} [1 + b]a -> [b]a\nallButLast x = [ a | a <- x | i <- (tail x) ]\n\nres01 = allButLast [1,2,3,4,5]\n\nrev : {a, b} (fin b) => [1 + b]a -> [1 + b]a\nrev x = (z!0)\n  where \n    z = [x]#[ [b]#(allButLast a) | b <- x | a <- z ]\n\nres02 = rev [1,2,3,4,5,6,7]\n\nfunky_0: [32] -> [16][32]\nfunky_0 x = iv\n   where iv = [ 2*lr | lr <- [x] # iv | k  <- [1 .. 16] ]\n\nres03 = funky_0 2\n\nfunky_1: [32] -> [16][32]\nfunky_1 x = [x]#iv\n   where iv = [ 2*lr | lr <- [x] # iv | k  <- [1 .. 15] ]\nres04 = funky_1 2\n\nfunky_2: [32] -> [inf][32]\nfunky_2 (x) = [x]#iv\n  where iv  = [ 2*lr | lr <- [x] # iv | k  <- [1 ...] ]\n\nres05 = funky_2 2\n\nsum_0 xs = ys\n  where ys = [ x + y | x <- xs | y <- [0] # ys ]\n\nres06 = sum_0 [1,2,3,4,5]\n\nsum_1 xs = ys\n  where ys = [ x + y | x <- ys | y <- [0] # ys ]\n\nres07 = sum_1 [1,2,3,4,5]\n\nfib_1 = take `{100} ([1,1]#ys)\n  where \n    ys = [ x+y | x <- ([1]:[1][256])#ys | y <- ([1,1]:[2][256])#ys ]\n\nfib_2: [256]->[256]\nfib_2 n = (([1,1]#ys)@(n-1))\n  where \n    ys = [ x+y | x <- [1]#ys | y <- [1,1]#ys ]\n\nres08 = fib_2 100\n\nres09:[2][24]\nres09 = split(0x570248D00425)  \nres10:[4][12]\nres10 = split(0x570248D00425)  \nres11:[8][6]\nres11 = split(0x570248D00425)  \nres12:[2][2][12]\nres12 = split(split(0x570248D00425))  \n\nsbox1 : [4][16][4]\nsbox1 = [[14, 4,13, 1, 2,15,11, 8, 3,10, 6,12, 5, 9, 0, 7],\n         [ 0,15, 7, 4,14, 2,13, 1,10, 6,12,11, 9, 5, 3, 8],\n         [ 4, 1,14, 8,13, 6, 2,11,15,12, 9, 7, 3,10, 5, 0],\n         [15,12, 8, 2, 4, 9, 1, 7, 5,11, 3,14,10, 0, 6,13]\n        ]\ns1 = sbox1 @ [True,True]   @ [True,True,True,True]\ns2 = sbox1 @ [True,True]   @ [False,True,True,True]\ns3 = sbox1 @ [True,True]   @ [True,False,True,True]\ns4 = sbox1 @ [True,True]   @ [False,False,True,True]\ns5 = sbox1 @ [False,True]  @ [True,True,True,True]\ns6 = sbox1 @ [True,False]  @ [True,True,True,True]\ns7 = sbox1 @ [False,False] @ [True,True,True,True]\ns8 = reverse(s7)\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Common\/utils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the Common::utils module implementing the given helper functions (including while, dowhile, ZtoBV, BVtoZ, ZtoZ, isEven, abs, unzip, mul2\/mul3\/mul4\/mul8, half, mp_mod_inv) and suitable properties that express their intended arithmetic and logical behavior."},{"role":"assistant","content":"```cryptol\nmodule Common::utils where\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = (fromInteger (fromZ x))\n\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = (fromInteger (toInteger x))\n\nZtoZ : {p, q} (fin p, fin q, p >= 1, q >= 1) => Z p -> Z q\nZtoZ x = (fromInteger (fromZ x))\n\nisEven : Integer -> Bit\nisEven x = ~((fromInteger x) : [1]) ! 0\n\nabs : Integer -> Integer\nabs x = if x >= zero then x else zero-x\n\nunzip : {a,f,s} [a](f,s) -> ([a]f,[a]s)\nunzip tuples = (map (\\x -> x.0) tuples , map (\\x -> x.1) tuples)\n\nmul2 x = x + x\nmul3 x = x + mul2 x\nmul4 x = mul2(mul2 x)\nmul8 x = mul2(mul4 x)\n\ntype constraint isOdd a = (a \/ 2) * 2 == a - 1\n\nhalf : {p} (fin p, p >= 3, isOdd p) => Z p -> Z p\nhalf x = if isEven (fromZ x) then x\/2 else (fromInteger ((fromZ x + `p) \/ 2))\n\nmp_mod_inv : {a} (fin a, a >= 1) => Z a -> Z a\nmp_mod_inv c = if c == 0 then error \"Zero does not have a multiplicative inverse\"\n               else fromInteger (if u'' == 1 then x1'' else x2'')\n  where\n    innercond (a, x) = isEven a\n    innerbody (a, x) = (a \/ 2, if isEven x then x \/ 2 else (x + `a) \/ 2)\n\n    outtercond (u, v, x1, x2) = (u != 1) \/\\ (v != 1)\n    outterbody (u, v, x1, x2) = if(u' >= v') then (u' - v', v', x1' - x2' % `a, x2')\n                                             else (u', v' - u', x1', x2' - x1' % `a)\n      where\n        (u', x1') = while innercond innerbody (u, x1)\n        (v', x2') = while innercond innerbody (v, x2)\n\n    (u'', _, x1'', x2'') = while outtercond outterbody (fromZ c, `a, 1, 0)\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that implements AES block cipher encryption\/decryption (AES-128\/192\/256) with key expansion over GF(2^8), and define properties AESCorrect and testsPass to verify aesDecrypt(aesEncrypt(msg,key),key)==msg and that standard NIST AES test vectors are satisfied."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES where\n\ntype AES128 = 4\ntype AES192 = 6\ntype AES256 = 8\n\ntype Nk = AES128\n\ntype Nb = 4\ntype Nr = 6 + Nk\n\ntype AESKeySize  = (Nk*32)\n\ntype GF28        = [8]\ntype State       = [4][Nb]GF28\ntype RoundKey    = State\ntype KeySchedule = (RoundKey, [Nr-1]RoundKey, RoundKey)\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Mult : (GF28, GF28) -> GF28\ngf28Mult (x, y) = pmod(pmult x y) irreducible\n\ngf28Pow : (GF28, [8]) -> GF28\ngf28Pow (n, k) = pow k\n  where   sq x  = gf28Mult (x, x)\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult(n, sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow (x, 254)\n\ngf28DotProduct : {n} (fin n) => ([n]GF28, [n]GF28) -> GF28\ngf28DotProduct (xs, ys) = gf28Add [ gf28Mult (x, y) | x <- xs\n                                                    | y <- ys ]\n\ngf28VectorMult : {n, m} (fin n) => ([n]GF28, [m][n]GF28) -> [m]GF28\ngf28VectorMult (v, ms) = [ gf28DotProduct(v, m) | m <- ms ]\n\ngf28MatrixMult : {n, m, k} (fin m) => ([n][m]GF28, [m][k]GF28) -> [n][k]GF28\ngf28MatrixMult (xss, yss) = [ gf28VectorMult(xs, yss') | xs <- xss ]\n   where yss' = transpose yss\n\nxformByte : GF28 -> GF28\nxformByte b = gf28Add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n   where c = 0x63\n\nxformByte' : GF28 -> GF28\nxformByte' b = gf28Add [(b >>> 2), (b >>> 5), (b >>> 7), d] where d = 0x05\nSubByte : GF28 -> GF28\nSubByte b = xformByte (gf28Inverse b)\n\nSubByte' : GF28 -> GF28\nSubByte' b = sbox@b\n\nSubBytes : State -> State\nSubBytes state = [ [ SubByte' b | b <- row ] | row <- state ]\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = gf28Inverse (xformByte' b)\n\nInvSubBytes : State -> State\nInvSubBytes state = [ [ InvSubByte b | b <- row ] | row <- state ]\n\nShiftRows : State -> State\nShiftRows state = [ row <<< shiftAmount | row <- state\n                                        | shiftAmount <- [0 .. 3]\n                  ]\n\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> shiftAmount | row <- state\n                                           | shiftAmount <- [0 .. 3]\n                     ]\n\nMixColumns : State -> State\nMixColumns state = gf28MatrixMult (m, state)\n    where m = [[2, 3, 1, 1],\n               [1, 2, 3, 1],\n               [1, 1, 2, 3],\n               [3, 1, 1, 2]]\n\nInvMixColumns : State -> State\nInvMixColumns state = gf28MatrixMult (m, state)\n    where m = [[0x0e, 0x0b, 0x0d, 0x09],\n               [0x09, 0x0e, 0x0b, 0x0d],\n               [0x0d, 0x09, 0x0e, 0x0b],\n               [0x0b, 0x0d, 0x09, 0x0e]]\n\nAddRoundKey : (RoundKey, State) -> State\nAddRoundKey (rk, s) = rk ^ s\nRcon : [8] -> [4]GF28\nRcon i = [(gf28Pow (<| x |>, i-1)), 0, 0, 0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord bs = [ SubByte' b | b <- bs ]\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nNextWord : ([8],[4][8],[4][8]) -> [4][8]\nNextWord(i, prev, old) = old ^ mask\n   where mask = if i % `Nk == 0\n                then SubWord(RotWord(prev)) ^ Rcon (i \/ `Nk)\n                else if (`Nk > 6) \/\\ (i % `Nk == 4)\n                     then SubWord(prev)\n                     else prev\n\nExpandKeyForever : [Nk][4][8] -> [inf]RoundKey\nExpandKeyForever seed = [ transpose g | g <- groupBy`{4} (keyWS seed) ]\n\nkeyWS : [Nk][4][8] -> [inf][4][8]\nkeyWS seed    = xs\n     where xs = seed # [ NextWord(i, prev, old)\n                       | i    <- [ `Nk ... ]\n                       | prev <- drop`{Nk-1} xs\n                       | old  <- xs\n                       ]\n\nExpandKey : [AESKeySize] -> KeySchedule\nExpandKey key = (keys @ 0, keys @@ [1 .. (Nr - 1)], keys @ `Nr)\n  where   seed : [Nk][4][8]\n          seed = split (split key)\n          keys = ExpandKeyForever seed\n\nfromKS : KeySchedule -> [Nr+1][4][32]\nfromKS (f, ms, l) = [ formKeyWords (transpose k) | k <- [f] # ms # [l] ]\n    where formKeyWords bbs = [ join bs | bs <- bbs ]\n\n\/\/ AES rounds and inverses\nAESRound : (RoundKey, State) -> State\nAESRound (rk, s) = AddRoundKey (rk, MixColumns (ShiftRows (SubBytes s)))\n\nAESFinalRound : (RoundKey, State) -> State\nAESFinalRound (rk, s) = AddRoundKey (rk, ShiftRows (SubBytes s))\n\nAESInvRound : (RoundKey, State) -> State\nAESInvRound (rk, s) =\n      InvMixColumns (AddRoundKey (rk, InvSubBytes (InvShiftRows s)))\nAESFinalInvRound : (RoundKey, State) -> State\nAESFinalInvRound (rk, s) = AddRoundKey (rk, InvSubBytes (InvShiftRows s))\n\n\/\/ Converting a 128 bit message to a State and back\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\n\/\/ AES Encryption\naesEncrypt : ([128], [AESKeySize]) -> [128]\naesEncrypt (pt, key) = stateToMsg (AESFinalRound (kFinal, rounds ! 0))\n  where   (kInit, ks, kFinal) = ExpandKey key\n          state0 = AddRoundKey(kInit, msgToState pt)\n          rounds = [state0] # [ AESRound (rk, s) | rk <- ks\n                                                 | s <- rounds\n                              ]\n\n\/\/ AES Decryption\naesDecrypt : ([128], [AESKeySize]) -> [128]\naesDecrypt (ct, key) = stateToMsg (AESFinalInvRound (kFinal, rounds ! 0))\n  where   (kFinal, ks, kInit) = ExpandKey key\n          state0 = AddRoundKey(kInit, msgToState ct)\n          rounds = [state0] # [ AESInvRound (rk, s)\n                              | rk <- reverse ks\n                              | s  <- rounds\n                              ]\n\nsbox : [256]GF28\nsbox = [\n 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n 0x54, 0xbb, 0x16]\n\n\/\/ Test runs:\n\n\/\/ cryptol> aesEncrypt (0x3243f6a8885a308d313198a2e0370734,   \\\n\/\/                      0x2b7e151628aed2a6abf7158809cf4f3c)\n\/\/ 0x3925841d02dc09fbdc118597196a0b32\n\/\/ cryptol> aesEncrypt (0x00112233445566778899aabbccddeeff,   \\\n\/\/                      0x000102030405060708090a0b0c0d0e0f)\n\/\/ 0x69c4e0d86a7b0430d8cdb78070b4c55a\nproperty AESCorrect msg key = aesDecrypt (aesEncrypt (msg, key), key) == msg\n\ntestmsgs = [0x6bc1bee22e409f96e93d7e117393172a\n           ,0xae2d8a571e03ac9c9eb76fac45af8e51\n           ,0x30c81c46a35ce411e5fbc1191a0a52ef\n           ,0xf69f2445df4f9b17ad2b417be66c3710]\n\n\/\/ AES128 tests\n\ntestkey128 = 0x2b7e151628aed2a6abf7158809cf4f3c\n\ntestct128 = [0x3ad77bb40d7a3660a89ecaf32466ef97\n            ,0xf5d3d58503b9699de785895a96fdbaaf\n            ,0x43b1cd7f598ece23881b00e3ed030688\n            ,0x7b0c785e27e8ad3f8223207104725dd4]\n\nproperty testsPass = and [ aesEncrypt (msg, testkey128) == ct\n                         | msg <- testmsgs | ct <- testct128 ]\n\n\/\/ AES192 tests\n\n\/\/ testkey192 = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n\n\/\/ testct192 = [0xbd334f1d6e45f25ff712a214571fa5cc \n\/\/             ,0x974104846d0ad3ad7734ecb3ecee4eef \n\/\/             ,0xef7afd2270e2e60adce0ba2face6444e \n\/\/             ,0x9a4b41ba738d6c72fb16691603c18e0e]\n\n\/\/ property testsPass = and [ aesEncrypt (msg, testkey192) == ct\n\/\/                          | msg <- testmsgs | ct <- testct192 ]\n\n\/\/ AES256 tests\n\n\/\/ testkey256 = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4 \n\/\/ testct256 = [0xf3eed1bdb5d2a03c064b5a7e3db181f8 \n\/\/             ,0x591ccb10d410ed26dc5ba74a31362870 \n\/\/             ,0xb6ed21b99ca6f4f9f153e7b1beafed1d \n\/\/             ,0x23304b7a39f9f3ff067d8d8f9e24ecc7]\n\n\/\/ property testsPass = and [ aesEncrypt (msg, testkey256) == ct\n\/\/                          | msg <- testmsgs | ct <- testct256 ]\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Primitive\/Keyless\/Hash\/SHA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for a parameterized SHA-2-style hash function `sha : {L} (2 * w >= width L) => [L] -> [digest_size]` and its supporting definitions, including padding, message schedule, compression, and iterative block processing over an initial vector `H0` and constants `K`."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Keyless::Hash::SHA where\n\nsha : {L} (2 * w >= width L) => [L] -> [digest_size]\nsha M = take (join (SHA_2_Common' [ split x | x <- parse`{num_blocks L} (pad`{L} M) ]))\n\nparameter\n\n  \/** Word size\n    Specifications are based on word size w, rather than digest size (8 * w)\n    or block size (m == 16 * w), in order to avoid confusing Cryptol's type\n    constraint verifier with integer division.\n  *\/\n\n  type w : #\n  type constraint (fin w, w >= 1)\n\n  type digest_size : #\n  type constraint (fin digest_size, 8*w >= digest_size)\n\n  type j : #\n  type constraint (fin j, j >= 17)\n\n  H0 : [8][w]\n  K  : [j][w]\n\n  SIGMA_0 : [w] -> [w]\n  SIGMA_1 : [w] -> [w]\n  sigma_0 : [w] -> [w]\n  sigma_1 : [w] -> [w]\n\nprivate\n\n  type block_size = 16 * w\n\n  type num_blocks L     = (L+1+2*w) \/^ block_size\n  type padded_size L    = num_blocks L * block_size\n\n  Ch : [w] -> [w] -> [w] -> [w]\n  Ch x y z = (x && y) ^ (~x && z)\n\n  Maj : [w] -> [w] -> [w] -> [w]\n  Maj x y z = (x && y) ^ (x && z) ^ (y && z)\n\n  pad : {L} (2 * w >= width L) => [L] -> [padded_size L]\n  pad M = M # 0b1 # zero # (`L : [2*w])\n\n  parse : {m} [m * block_size] -> [m][block_size]\n  parse = split\n\n  messageSchedule_Common : [16][w] -> [j][w]\n  messageSchedule_Common Mi = take W\n    where\n    W : [inf][_]\n    W = Mi # [ w1 + sigma_0 w2 + w3 + sigma_1 w4\n             | w1 <- W\n             | w2 <- drop`{1} W\n             | w3 <- drop`{9} W\n             | w4 <- drop`{14} W\n             ]\n\n  compress_Common : [8][w] -> [j][w] -> [8][w]\n  compress_Common H W =\n        [ (as ! 0) + (H @ 0),\n      (bs ! 0) + (H @ 1),\n      (cs ! 0) + (H @ 2),\n      (ds ! 0) + (H @ 3),\n      (es ! 0) + (H @ 4),\n      (fs ! 0) + (H @ 5),\n      (gs ! 0) + (H @ 6),\n      (hs ! 0) + (H @ 7)\n    ]\n    where\n      T1 = [h + SIGMA_1 e + Ch e f g + k_t + w_t\n                | h <- hs | e <- es | f <- fs | g <- gs | k_t <- K | w_t <- W]\n      T2 = [ SIGMA_0 a + Maj a b c | a <- as | b <- bs | c <- cs]\n      hs = take`{j + 1}([H @ 7] # gs)\n      gs = take`{j + 1}([H @ 6] # fs)\n      fs = take`{j + 1}([H @ 5] # es)\n      es = take`{j + 1}([H @ 4] # [d + t1 | d <- ds | t1 <- T1])\n      ds = take`{j + 1}([H @ 3] # cs)\n      cs = take`{j + 1}([H @ 2] # bs)\n      bs = take`{j + 1}([H @ 1] # as)\n      as = take`{j + 1}([H @ 0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\n  processBlock_Common : [8][w] -> [16][w] -> [8][w]\n  processBlock_Common H Mi = compress_Common H (messageSchedule_Common Mi)\n\n  SHA_2_Common' : {L} (fin L) => [L][16][w] -> [8][w]\n  SHA_2_Common' blocks = hash ! 0\n    where\n    hash = [H0] # [ processBlock_Common h b | h <- hash | b <- blocks]\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/DilithiumR2BV.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the Dilithium Round 2 bit-vector implementation, including Gen, Sign, Verify, key\/secret\/signature packing\/unpacking, and a property test_key_gen that checks the known-answer test vectors for key generation."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::DilithiumR2BV where\n\nimport Primitive::Keyless::Hash::keccak as SHA3\nimport Common::utils\nimport Common::mod_arith\nimport Primitive::Asymmetric::Cipher::RSA\nimport Primitive::Asymmetric::Signature::testDilithium\nimport Primitive::Asymmetric::Signature::test_latest\n\ntype qbits = 23\ntype uint32_t = 32\ntype q = 0x7fe001 type n = 0x100 type d = 0xe\nwc= 0x3c gamma1 = ((`q) - 1) \/ 16:[_]\ngamma2 = ( gamma1 \/ 2 ):[_]\nalpha = (2*gamma2):[_]\nqinv  = 0x00000000fc7fdfff\ntype POLT1_SIZE_PACKED = 288\n\nrootOfUnity    = 1753 : [qbits]\nrootOfUnityInv = 731434 : [qbits]\nninv           = 8347681 : [qbits]\n\ntype k = 4\ntype l = 3\n\neta = 6\nbeta = 325\ntype omega = 80\n\ntype intPoly        = [n][qbits]\ntype intPolyVec dim = [dim]intPoly\n\ntype poly        = [n][qbits] type polyVec dim = [dim]poly\n\ntype nttPoly          = [n][qbits]\ntype nttVec dim       = [dim]nttPoly\ntype nttMat dim1 dim2 = [dim1](nttVec dim2)\n\ntype PublicKey = {rho : [256], t1 : intPolyVec k}\ntype SecretKey = {rho : [256]\n                    , K  : [256]\n                    , tr : [384]\n                    , s1 : polyVec l\n                    , s2 : polyVec k\n                    , t0 : intPolyVec k}\ntype SEEDBYTES = 32\ntype CRYPTO_PUBLICKEYBYTES = SEEDBYTES + (POLT1_SIZE_PACKED * k)\n\nGen : [3*SEEDBYTES*8] -> (PublicKey,SecretKey)\nGen s = (pk, sk)\n    where\n      [rho, rho', K] = split`{3} s \/\/rho <- {0, 1}^256, K <- {0,1}^256\n      A       = ExpandA (split rho) \/\/A \u2208 R^(k\u00d7l)_q := ExpandA(rho)\n      s1      = PolyUniformEtaV`{dim=l} rho' zero       s2      = PolyUniformEtaV`{dim=k} rho' `l \/\/ s2<-s^k_\u03b7\n      s1ntt   = map ntt s1\n      As1     = map nttinv (nttMatMul A s1ntt)\n      t       = paddV As1 s2     \/\/t:= As1 + s2\n      (t1,t0) = Power2RoundV t  \/\/(t1, t0):= Power2Round_q(t, d=4)\n      tr      = CRH (rho#(pack_t1 t1)) \/\/tr \u2208 {0,1}^384 := CRH(rho||t1)\n      pk      = { rho = rho, t1 = t1}\n      sk      = { rho = rho, K = K, tr = tr, s1 = s1, s2 = s2, t0 = t0}\n\n\/\/ Known Answer Test\n\/\/ To check this property, it is necessary to import testDilithium\n\ntest_key_gen = (pk.rho#(pack_t1 pk.t1) == testCase1.pk) \/\\\n    ((sk.rho#sk.K#sk.tr#(pack_polyeta sk.s1)#(pack_polyeta sk.s2)#(pack_t0 sk.t0)) == testCase1.sk)\n    where\n    (pk, sk) = Gen (join testCase1.seed)\n\n\/* Generate signature for message M *\/\nSign : {mbytes} (fin mbytes, mbytes>=1) => SecretKey -> [mbytes*8] -> (polyVec l, polyVec k, poly)\nSign sk M = (final_state.z, h, nttinv final_state.c')\n     where\n      A     = ExpandA (split sk.rho)       mu    = CRH`{b=48+mbytes} (sk.tr#M)       kappa = zero       s1'   = map ntt sk.s1\n      s2'   = map ntt sk.s2\n      t0'   = map ntt (sk.t0)\n      \/\/TODO: check t0' back later\n\n      init : sign_var_types\n      init = {z=zero,r0=zero,r1=zero,t0'=t0',c'=zero,w=zero,w1=zero\n             ,s1'=s1',s2'=s2',cs2=zero,K=sk.K,mu=mu,A=A,kappa=kappa}\n\n      final_state = dowhile sign_condition sign_body init\n      ct0         = map nttinv (nttVecConstMul final_state.c' final_state.t0')\n      h           = MakeHintV (psubV zero ct0\n                              ,paddV (psubV final_state.w final_state.cs2) (ct0))\n\ntype sign_var_types = { z : polyVec l\n                          , r0  : intPolyVec k\n                          , r1  : intPolyVec k\n                          , t0' : nttVec k\n                          , c'  : nttPoly\n                          , w   : polyVec k\n                          , w1  : intPolyVec k\n                          , s1' : nttVec l\n                          , s2' : nttVec k\n                          , cs2 : polyVec k\n                          , K   : [256]\n                          , mu  : [384]\n                          , A   : nttMat k l\n                          , kappa: [16]}\n\nsign_condition : sign_var_types -> Bit\nsign_condition sv = fail1 \\\/ fail2\n                   where\n                    fail1 = ((infNormPolyVec (sv.z)) >= (gamma1-beta)) \/\/ ||z||_\u221e \u2265 \u03b31 - \u03b2\n                            \\\/ ((infNormPolyVec sv.r0) >= (gamma2-beta)) \/\/ ||r0||_\u221e \u2265 \u03b32 - \u03b2\n                            \\\/ (sv.r1 != sv.w1) \/\/ r1 \u2242\u0338 w1\n                    fail2 = ((infNormPolyVec (ct0)) >= gamma2) \/\/ ||ct0||_\u221e \u2265 \u03b32\n                            \\\/ ( (foldl (+) 0 cones) > `omega ) \/\/ number of ones in h > \u03c9\n                    cones = sum (map (\\x -> (map onesBV x)) h)\n                    ct0   = map nttinv (nttVecConstMul sv.c' sv.t0')\n                    h     = MakeHintV (psubV zero ct0\n                                      ,paddV (psubV sv.w sv.cs2) (ct0))\n                                      \/\/ h := MakeHintV(-ct0, w-cs2+ct0, 2\u03b32)\n\nsign_body : sign_var_types -> sign_var_types\nsign_body sv = {z=z,r0=r0,r1=r1,t0'=sv.t0',c'=c',w=w,w1=w1,s1'=sv.s1',s2'=sv.s2',\n                   cs2=cs2,K=sv.K,mu=sv.mu,A=sv.A,kappa=(sv.kappa+1)}\n              where\n                \u03c1'  = CRH`{b=48+32} (sv.K#sv.mu)                 y   = ExpandMask((split \u03c1'), sv.kappa)\/\/ y \u2208 S^l_(\u03b31-1) := ExpandMask(\u03c1',\u03ba)\n                y'  = map ntt y \/\/ checked\n                w   = map nttinv (nttMatMul sv.A y')                 w1  = HighBitsV w                 c'  = ntt ( H (sv.mu,w1) ) \/\/ c \u2208 B_(60) := H(\u03bc||w1)\n                cs1 = map nttinv (nttVecConstMul c' sv.s1') \/\/ cs1 := c'.s1'\n                cs2 = map nttinv (nttVecConstMul c' sv.s2') \/\/ cs2 := c'.s2'\n                z   = paddV y cs1 \/\/ z:= y+cs1\n                (r1, r0) = DecomposeV (psubV w cs2) \/\/ Decompose_q(w-cs2, 2\u03b32)\n\nVerify : {mbytes} (fin mbytes, mbytes>=1) => PublicKey -> [mbytes*8] -> (polyVec l, polyVec k, poly) -> Bit\nVerify pk M (z, h, c) = crit1 && crit2 && crit3\n       where\n        A        = ExpandA (split pk.rho) \/\/ A \u2208 R^(k\u00d7l)_q := ExpandA(\u03c1)\n        mu       = CRH`{b=48+mbytes} ((CRH (pk.rho#(pack_t1 pk.t1)))#M) \/\/ \u03bc \u2208{0,1}^384 := CRH(CRH(\u03c1||t1)||M)\n        zntt     = map ntt z \/\/ NTT(z)\n        t1dot2d  = map ntt (map (\\p -> map (\\x ->  mod_mul(`q, x, (2^^14))) p) pk.t1) \/\/ t1.2^^d where d=14\n        nttt1dot2d = map ntt t1dot2d\n        ct1ntt   = nttVecConstMul (psub zero c) nttt1dot2d   \/\/ -ct1\n        Az       = nttMatMul A zntt\n        w1'      = UseHintV (h, paddV Az ct1ntt)\n        zint     = z\n        zinf     = infNormPolyVec zint         crit1    = zinf < gamma1 - beta\n        crit2    = c == H(mu,w1')\n        cones    = sum (map (\\x -> (map onesBV x)) h)\n        crit3    = ( (foldl (+) 0 cones) > `omega ) \/\/ number of 1's in h \u2264 \u03c9 \n\nonesBV : {n} (fin n, n>=1)=> [n] -> [n]\nonesBV xs =  l!0\n    where l = [0]#[ (if (xs@i) then j+1 else j):[n] | i <- [0..n-1] | j<- l]\n\npack_w : intPolyVec k -> [4*n*k]\npack_w w = join [pack_poly p | p <- wBV ]\n    where\n    wBV = map (\\p -> map (\\x -> drop`{15} x:[8]) p) w\n    pack2 : [2][8] -> [8]\n    pack2 xs = xs@0 || (xs@1 << 4)\n    pack_poly p = join [ pack2 xs | xs <- split p : [128][2][_] ]\n\npack_polyeta : {m} (fin m, m >= 1) =>  polyVec m -> [4*n*m]\npack_polyeta s = join [ join [elt p i | i <- [0..(n\/2)-1]:[_][8] ] | p <- s ]\n    where\n    elt : poly -> [8] -> [8]\n    elt p i = (c (((p@(2*i+0))) % `q)) || ((c (((p@(2*i+1))) % `q)) << 4)\n    c : [qbits] -> [8]\n    c num = drop (if num > eta then `q + eta - num else eta - num)\n\ntype POLETA_SIZE_PACKED = 128\nunpack_polyeta :  {m} (fin m, m>=1) => [POLETA_SIZE_PACKED*m][8] -> polyVec m\nunpack_polyeta t = [ elt a | a <- (split t):[m][128][8]]\n      where\n      elt : [128][8] -> poly\n      elt a = (join coeffs)\n            where coeffs = [ [ (`q+eta)- (zext (a@i&&0x0F)), (`q+eta)- (zext (a@(i+1)>>4))] |i <- [0..(n\/2)-1]:[_][8] ]\n\npack_t0 : intPolyVec k -> [k*3584]\npack_t0 t0 = join [ polyt0_pack p | p <- t0 ]\n\npolyt0_pack : intPoly -> [3584]\npolyt0_pack p = join [ join [drop`{15} (tmp p i 0),\n                       drop`{15} (((tmp p i 0) >> 8) || ((tmp p i 1) << 6)),\n                       drop`{15} ((tmp p i 1) >> 2),\n                       drop`{15} (((tmp p i 1) >> 10) || ((tmp p i 2) << 4)),\n                       drop`{15} ((tmp p i 2) >> 4),\n                       drop`{15} (((tmp p i 2) >> 12) || ((tmp p i 3) << 2)),\n                       drop`{15} ((tmp p i 3) >> 6)\n                     ] | i <- [0..(n\/4-1)] ]\n        where\n          tmp : intPoly -> [8] -> [8] -> [23]\n          tmp p i j =  (2^^13 - p@(4*i+j))\ntype POLT0_SIZE_PACKED = 448\npolyt0_unpack : [POLT0_SIZE_PACKED][8] -> intPoly\npolyt0_unpack p = join[ [ (tmp p i 0) || (zext ((tmp p i 1) && zext 0x3F)) << 8,\n                          (zext ((tmp p i 1) >> 6)) || (zext (tmp p i 2)) << 2 || (zext ((tmp p i 3) && zext 0x0F)) << 10,\n                          (zext ((tmp p i 3) >> 4)) || (zext (tmp p i 4)) << 4 || (zext ((tmp p i 5) && zext 0x03)) << 12,\n                          (zext ((tmp p i 5) >> 2)) || (zext (tmp p i 6)) << 6\n                        ] | i <- [0..(n\/4-1)]\n                      ]\n          where\n            tmp :[POLT0_SIZE_PACKED][8] -> [8] -> [8] -> [23]\n            tmp p i j =  zext (2^^13 - p@(7*i+j))\n\nunpack_t0 : [k][POLT0_SIZE_PACKED][8] -> intPolyVec k\nunpack_t0 pv = [ (polyt0_unpack pv') | pv' <- pv]\n\npoly_pack : poly -> [POLT1_SIZE_PACKED*8]\npoly_pack p = join [ join (pack8 xs) | xs <- split (map (drop`{14}) p) : [32][8][_]]\n\npack8 : [8][9] -> [9][8]\npack8 xs = map drop`{1} [ xs@0\n                        , xs@0 >> 8 || xs@1 << 1\n                        , xs@1 >> 7 || xs@2 << 2\n                        , xs@2 >> 6 || xs@3 << 3\n                        , xs@3 >> 5 || xs@4 << 4\n                        , xs@4 >> 4 || xs@5 << 5\n                        , xs@5 >> 3 || xs@6 << 6\n                        , xs@6 >> 2 || xs@7 << 7\n                        , xs@7 >> 1\n                        ]\n\npack_t1 : polyVec k -> [k*POLT1_SIZE_PACKED*8]\npack_t1 pvk = (join [ poly_pack p | p <- pvk])\n\npolyt1_unpack : [POLT1_SIZE_PACKED][8] -> poly\npolyt1_unpack p = map (\\x -> zero#x) (join [unpack8 xs | xs <- (split p): [32][9][_] ])\n    where unpack8: [9][8] -> [8][12]\n          unpack8 xs = [ zero#xs@0 || ((zero#xs@1 << 8) && 0x1FF)\n                        , zero#xs@1 >> 1 || ((zero#xs@2 << 7) && 0x1FF)\n                        , zero#xs@2 >> 2 || ((zero#xs@3 << 6) && 0x1FF)\n                        , zero#xs@3 >> 3 || ((zero#xs@4 << 5) && 0x1FF)\n                        , zero#xs@4 >> 4 || ((zero#xs@5 << 4) && 0x1FF)\n                        , zero#xs@5 >> 5 || ((zero#xs@6 << 3) && 0x1FF)\n                        , zero#xs@6 >> 6 || ((zero#xs@7 << 2) && 0x1FF)\n                        , zero#xs@7 >> 7 || ((zero#xs@8 << 1) && 0x1FF)\n                        ]\n\nunpack_t1 : [k][POLT1_SIZE_PACKED][8] -> polyVec k\nunpack_t1  pv = [ (polyt1_unpack p) |  p <- pv]\n\npack_pk :  [32][8] -> polyVec k -> [CRYPTO_PUBLICKEYBYTES*8]\npack_pk rho t1 = (join rho) # (pack_t1 t1)\n\nunpack_pk : [CRYPTO_PUBLICKEYBYTES][8] -> ([SEEDBYTES][8], polyVec k)\nunpack_pk pk = (take`{32} pk, [polyt1_unpack p | p <- (split (drop`{32} pk):[k][288][_])])\n\ntype CRHBYTES = 48\ntype CRYPTO_SECRETKEYBYTES = 2800\n\npack_sk : [SEEDBYTES][8] -> [SEEDBYTES][8] -> [CRHBYTES][8] -> polyVec l -> polyVec k -> polyVec k -> [CRYPTO_SECRETKEYBYTES*8]\npack_sk rho key tr s1 s2 t0 = (join rho) # (join key) # (join tr)# (pack_polyeta s1)#(pack_polyeta s2) # (pack_t0 t0)\n\nunpack_sk : [CRYPTO_SECRETKEYBYTES][8] -> ([SEEDBYTES][8], [SEEDBYTES][8], [CRHBYTES][8], polyVec l, polyVec k, intPolyVec k)\nunpack_sk sk = (rho, key, tr, s1, s2, t0)\n        where rho = (take`{32} sk)\n              key = (take`{32}(drop`{32} sk))\n              tr = (take`{48}(drop`{32} sk))\n              s1 = unpack_polyeta`{m=l} (take`{128*l}(drop`{48} sk))\n              s2 = unpack_polyeta`{m=k} (take`{128*k}(drop`{48+(128*l)} sk))\n              t0 = unpack_t0 (split (drop`{48+(128*l)+(128*k)+64} sk):[k][POLT0_SIZE_PACKED][8])\n\ntype POLZ_SIZE_PACKED = 640\n\npolyz_pack : poly -> [POLZ_SIZE_PACKED][8]\npolyz_pack p =  join [ (tmp p i) | i<- [0..(n\/2)-1]]\n      where tmp: poly -> [8] -> [5][8]\n            tmp p i  = [r0, r1, r2, r3, r4]\n              where\n                    t x = gamma1-1-p@(2*i+x)\n                    t0 = (t 0) + ((zext (t 0))>>31) && `q\n                    t1 = (t 1) + ((zext (t 1))>>31) && `q\n                    r0 = drop t0\n                    r1 = drop (t0>>8)\n                    r2 = drop (t0>>16) || drop (t1 << 4)\n                    r3 = drop (t1 >> 4)\n                    r4 = drop (t1 >> 12)\n\npolyz_unpack : [POLZ_SIZE_PACKED][8] -> poly\npolyz_unpack pp =  (join [ (tmp pp i) | i<-[0..(n\/2)-1]])\n    where tmp : [POLZ_SIZE_PACKED][8] -> [8]-> [2][23]\n          tmp pp i = [rcoeff0, rcoeff1]\n                where\n                  coeff0 = (zero#pp@(5*i+0):[32]) || (((zero#pp@(5*i+1)):[32]) << 8) || (zero#(((zero#pp@(5*i+2)):[8]) && 0x0F):[32]) << 16\n                  coeff1 = ((zero#(pp@(5*i+2) >> 4)):[32]) || ((zero#pp@(5*i+3):[32]) << 4) || ((zero#pp@(5*i+4):[32]) << 12)\n                  rcoeff0 = drop`{9}((gamma1 - 1 - coeff0) + ((zext coeff0:[32]) >> 31) && `q):[23]\n                  rcoeff1 = drop`{9}((gamma1 - 1 - coeff1) + ((zext coeff1:[32]) >> 31) && `q):[23]\n\ntype SIG_SIZE_PACKED = l*POLZ_SIZE_PACKED+omega+k+n\/8+8\n\nencodec : poly -> [(n\/8+8)*8]\nencodec p = (join [ [ p@(8*i+j)!=0 | j <- [0..7] ] | i<- [0..(n\/8)-1]])# (join sigSigns)\n      where\n        signs =[0]# [(if (join qm1coeffsIndcs)@i then s||m else s) | s <- signs | m<- masks| i<-[0..255]]\n        masks = [1]# [(if (join nzcoeffsIndcs)@i then (m << 1) else m) | m<-masks | i<-[0..255] ]\n        nzcoeffsIndcs =  [ [ p@(8*i+j)!=0 | j <- [0..7] ] | i<- [0..(n\/8)-1]]\n        qm1coeffsIndcs = [ [ p@(8*i+j)==(`q-1) | j <- [0..7] ] | i<- [0..(n\/8)-1]]\n        sig = zero:[n\/8+8][8]\n        sigSigns = [ (signs!0) >>(8*i) | i<-[0..7]]:[8][8]\n\npack_sig : (polyVec l, polyVec k, poly) -> [SIG_SIZE_PACKED*8]\npack_sig (z, h, c) = s0#s1#s2\n        where s0 = join [join (polyz_pack z') | z' <- z ]\n              s2 = encodec c\n              s1 = encodeh h\n                where\n                encodeh : polyVec k -> [(omega+k)*8]\n                encodeh h = join omegaUpdates\n                  where nzcoeffsIndcs = [ [ (p@j)!=0 | j<-[0..255]]| p<- h]\n                        cones = sum (map onesBV nzcoeffsIndcs)\n                        sig = zero:[84][8]\n                        kUpdates0=[sig]#[(if (nzcoeffsIndcs@0)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates0]\n                        kUpdates1=[kUpdates0!0]#[(if (nzcoeffsIndcs@1)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates1]\n                        kUpdates2=[kUpdates1!0]#[(if (nzcoeffsIndcs@2)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates2]\n                        kUpdates3=[kUpdates2!0]#[(if (nzcoeffsIndcs@3)@i==True then ((update sig' i) i) else ((update sig' i) 0))| i <- [0..255]| sig' <- kUpdates3]\n                        omegaUpdates = (updates (kUpdates3!0) [`omega+0, `omega+1, `omega+2, `omega+3] [0, 1, 2, 3])\n\ndecodec : [(n\/8+8)][8] -> poly\ndecodec xs = coeffs'!0\n  where coeffs = zero:poly\n        signs = [0]#[ ((sext s) || ((sext (xs@(`n\/8+i))):[64]) << (8*i)) | i<-[0..7] | s<-signs] :[9][64]\n        signs' = [signs!0]#[ (if ((((xs@i) >> j) && 0x01) == 1) then (s >> 1) else s) | j<- [0..255] | s <- signs' | i<- [0..3]]\n        coeffs' = [coeffs]#[(if ((((xs@i) >> j) && 0x01)==1) then (update coeff (8*i+j) (1^(-((drop s)&&1))&&(1^(`q-1)))) else coeff) | i<- [0..7] | j<- [0..255] | s <- signs' | coeff <-coeffs' ]\n\ndecodeh: [(omega+k)][8] -> polyVec k\ndecodeh xs = pv       where\n        pv = zero : polyVec k\n        ks = [0]#[xs@(`omega+i) | i<- [0..3]]\n\nunpack_sig : [SIG_SIZE_PACKED][8] -> (polyVec l, polyVec k, poly)\nunpack_sig sig = (z, h, c)\n        where z = [ (polyz_unpack p) | p<- (split (take`{l*POLZ_SIZE_PACKED} sig):[l][_][_])]\n              c = decodec sig''               sig' = take`{84}(drop`{l*POLZ_SIZE_PACKED} sig)\n              sig'' = drop`{84}(drop`{l*POLZ_SIZE_PACKED} sig)\n              h = decodeh sig'\n\nupdateCoeffs :  polyVec n -> [k] -> [8] -> [qbits] -> polyVec n\nupdateCoeffs pv i j a =  upv\n      where  upv = (update pv i up)\n             up = (update p j a)\n             p = pv@i\n\nPolyUniformEtaV : {dim} (fin dim, dim>=1,width (dim-1) <= 8) => [256] -> [16] -> polyVec dim\nPolyUniformEtaV r nonce = [PolyUniformEta (split r) (nonce + j) | j <- [0..(dim-1)]:[dim][16]]\n\ngenS : [8] -> [2][4]\ngenS byte = [t0, t1]\n    where\n    t0 = drop`{4} (byte && 0x0F)\n    t1 = drop`{4} (byte >> 4)\n\nPolyUniformEta : [SEEDBYTES][8] -> [16] -> poly\nPolyUniformEta rho nonce = map (\\x -> if ((toInteger eta) - (toInteger x)) < 0 then (fromInteger  (((toInteger eta) - (toInteger x))+`q):[23]) else (fromInteger ((toInteger eta) - (toInteger x)):[23])) (take`{n} withinEta)\n    where\n        seed = (join rho)#(drop`{8} nonce)# (take`{8} nonce)\n        randoms = ((join (SHA3::toBytes (take`{2*8*168} (SHA3::SHAKE128 (join (SHA3::toBytes seed))))))#zero)\n        withinEta = randomsInRangeDouble genS (2*eta) randoms\n\nH : ([384],intPolyVec k) -> poly\nH (mu,w) = (SampleInBall ss samples)\n  where\n    w_packed = pack_w w\n    randoms  = join (SHA3::toBytes (take`{4352} (SHA3::SHAKE256 (join (SHA3::toBytes (mu#w_packed))))))\n    ss       = take`{60}(reverse (join (reverse (split (take`{64} randoms):[8][8]))))\n\n    extByte : [8] -> [8]\n    extByte x = x\n\n    samples : [60][8]\n    samples = take`{60} (randomsInRanges extByte [196..255] (drop`{64} randoms#zero))\n\nSampleInBall : [60] -> [60][8] -> [256][qbits]\nSampleInBall signs jsamples = ys ! 0\n              where\n              ys = [ zero:[256][qbits]]\n                    # [ if i==j then (if [s]==1 then (update y i (`q-1)) else (update y i 1))                          else (if [s]==1 then (updates y [j,i] [`q-1,y@j]) else (updates y [j,i] [1,y@j]))  | i <- [196..255]\n                                                                  | j <- jsamples\n                                                                  | s <- signs\n                                                                  | y <- ys\n                      ]\n\nExpandMask : ([CRHBYTES][8], [16]) -> polyVec l\nExpandMask  ( \u03c1', kappa) = [samplePoly \u03c1' kappa i `l | i <- [0..(l-1)] ]\n\nsamplePoly : [CRHBYTES][8] -> [16] -> [2] -> [2] -> poly\nsamplePoly \u03c1' kappa i dim = (map (\\x -> mod_sub(`q, mod_sub(`q, gamma1, 1), zero#x)) coeffs)\n    where\n        (upper:[20])      =  drop`{4}(2*gamma1-2):[20]\n        kappaBytes = join (reverse (split ((zext dim)*kappa+(zext i)):[2][8])) \/\/ LEB order\n        s          = join (SHA3::toBytes (take`{5*8*136} (SHA3::SHAKE256 (join (SHA3::toBytes ((join \u03c1')#kappaBytes))))))         (coeffs:[n][20])   = take`{n} (randomsInRangeDouble extractPolyElt upper (s#zero))\n\nextractPolyElt : [40] -> [2][20]\nextractPolyElt bits = [zero#int1, zero#int2]\n                where\n                [b0,b1,b2,b3,b4] = [(zero#b):[20] | b <- split bits : [5][8]]\n                int1 = b2'*2^^16 + b1*2^^8 +  b0\n                int2 = b4*2^^12 + b3*2^^4 +  b2''\n                b2'  = b2 && 15\n                                b2'' = b2\/16\nCRH : {b} (fin b, b>=1) => [b*8] -> [384]\nCRH seed = join (SHA3::toBytes (take`{48*8} (SHA3::SHAKE256 (join (SHA3::toBytes seed)))))\n\nExpandA : [SEEDBYTES][8] -> [k][l]nttPoly\nExpandA rho = [ [ (matrixPoly (join rho) i j) | j <- [0..(l-1)] ] |  i <- [0..(k-1)] ]\n\nmatrixPoly : [SEEDBYTES*8] -> [width k] -> [width l] -> nttPoly\nmatrixPoly rho i j = take`{n} [drop`{1} elt | elt <- randomElts ]\n            where\n            randomElts = randomsInRange extractMatElt ((>=) (`q)) (s#zero)\n            s          = join (SHA3::toBytes (take`{6720} (SHA3::SHAKE128 (join (SHA3::toBytes (rho#b))))))\n                        b          =  drop`{16}(((zero#j:[32]) << 8) + (zero#i:[32]))\n\nextractMatElt : [24] -> [24]\nextractMatElt rands = zero#(2^^16 * b2' + 2^^8 * b1 + b0):[24]\n                where\n                  [b0, b1, b2] = [(zero#b):[23] | b <- split`{3} rands]\n                  b2' = (2^^23-1) && b2 \n\nPower2Round : [qbits] -> ([qbits],[qbits]) -> ([qbits],[qbits])\nPower2Round q (r,d') = ((r'-r0)\/2^^d',r0)\n            where r' = mod_pow (zero#q, r, 1)\n                  r0 = centered_mod r' (2^^d')\n\npolyPower2Round : {m} [m][qbits] -> ([m][qbits], [m][qbits])\npolyPower2Round p = unzip [ Power2Round `q (zero#r, zero#0xe)\n                          | r <- p\n                          ]\n\nPower2RoundV : {dim} (fin dim, dim >= 1) => polyVec dim -> ([dim]intPoly,[dim]intPoly)\nPower2RoundV v = unzip (map polyPower2Round v)\n\nALPHA = 2*gamma2\n\nDecompose : [qbits] -> ([qbits],[qbits])\nDecompose r = if (r' - r0) == (`q - 1) then (0, r0 - 1)\n                    else ((r' - r0) \/ ALPHA, r0)\n          where r' =  mod_pow (`q, r, 1)\n                r0 = centered_mod r' ALPHA\n\nDecomposePoly : {m} [m][qbits] -> ([m][qbits], [m][qbits])\nDecomposePoly p = unzip [Decompose (zero#x) | x <- p]\n\nDecomposeV : {n} (fin n, n>=1) => polyVec n  -> (polyVec n, polyVec n)\nDecomposeV r = unzip [ DecomposePoly p | p <- r ]\n\nHighBits : [qbits] -> [qbits]\nHighBits r = (Decompose r).0\n\nHighBitsV : {n} (fin n, n>=1) => polyVec n  -> polyVec n\nHighBitsV rv = r1\n          where\n            (r1,r0) = DecomposeV rv\n\nLowBits : [qbits] -> [qbits]\nLowBits r = (Decompose r).1\n\nMakeHint : ([qbits],[qbits]) -> [qbits]\nMakeHint (z,r) = zero#[r1 != v1]\n          where r1 = HighBits r\n                v1 = HighBits r+z\nMakeHintP: (poly, poly) -> poly\nMakeHintP (zp, rp) = [MakeHint (z, r) | z <- zp | r <- rp]\n\nMakeHintV : {k} (fin k, k>=1) => (polyVec k, polyVec k) -> polyVec k\nMakeHintV (zv, rv) =  [MakeHintP (zp, rp) | zp <- zv | rp <- rv ]\n\nUseHint : ([qbits],[qbits]) -> [qbits]\nUseHint  (r,h) = (if h==1 then r1' else r1):[23]\n        where\n          m = ((`q - 1) \/ ALPHA)\n          (r1, r0) = Decompose r\n          r1'      = if (r0 > 0) then mod_pow (m, (r1 + 1), 1) else mod_pow (m, (r1 - 1), 1)\nUseHintPoly : poly -> poly -> poly\nUseHintPoly rp hp = [ UseHint (r, h) | r <- rp | h <- hp ]\n\nUseHintV : {k}(fin k, k>=1) => (polyVec k, polyVec k) -> polyVec k\nUseHintV (rv, hv) = [UseHintPoly hpoly rpoly\n                              | hpoly <- hv\n                              | rpoly <- rv\n                              ]\n\nones : {a} (fin a, a >= 1) => [a] -> Integer\nones bv = foldl (+) 0 bva\n      where\n      bva = map toInteger (split bv:[_][1])\n\ncentered_mod : [qbits] -> [qbits] -> [qbits]\ncentered_mod x n = if r > (n\/2) then r - n\n                    else r\n              where r = x % n\n\nrandomsInRange : {a} (fin a) => ([a]-> [a]) -> ([a] -> Bit) -> [inf] -> [inf][a]\nrandomsInRange createElt upperCrit randoms = if (upperCrit elt )\n                                then  [ elt ]#(randomsInRange createElt upperCrit randomTail)\n                                else randomsInRange createElt upperCrit randomTail\n                                where\n                                elt        = createElt (take`{a} randoms)\n                                randomTail = drop`{a} randoms\n\nrandomsInRanges : {a,m} (fin a,fin m, m>=1) => ([a]-> [a]) -> [m][a] -> [inf] -> [inf][a]\nrandomsInRanges createElt uppers randoms =\n                if elt <= head uppers\n                then  [ elt ]#(randomsInRanges createElt uppersRotate randomTail)\n                else randomsInRanges createElt uppers randomTail\n                where\n                  elt          = createElt (take`{a} randoms)\n                  randomTail   = drop`{a} randoms\n                  uppersRotate = uppers <<< 1\n\nrandomsInRangeDouble : {a} (fin a) => ([2*a]-> [2][a]) -> [a] -> [inf] -> [inf][a]\nrandomsInRangeDouble createElt upper randoms =\n                if (elts@0 <= upper) \/\\ (elts@1 <= upper)\n                then  elts#(randomsInRangeDouble createElt upper randomTail)\n                else\n                  if (elts@0 <= upper)\n                  then [ elts@0 ]#(randomsInRangeDouble createElt upper randomTail)\n                  else\n                    if (elts@1 <= upper)\n                    then [ elts@1 ]#(randomsInRangeDouble createElt upper randomTail)\n                    else randomsInRangeDouble createElt upper randomTail\n                where\n                  elts       = createElt (take`{2*a} randoms)\n                  randomTail = drop`{2*a} randoms\n\nmod_sum : {s, m} (fin s, fin m) => ([s], [m][s]) -> [s]\nmod_sum (p, l) = sums!0\n    where\n    sums = [zero]#[mod_add`{s}(p, x, y) | x <- l | y <- sums]\n\nntt : poly -> nttPoly\nntt p = nttp\n    where\n    r k = mod_pow(`q, rootOfUnity, k)\n    exponents = join [ [zext i, (256+(zext i))] | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n    nttp = [(mod_sum (`q, [ (mod_mul(`q, (p@idx), (mod_pow (`q, (r k), i)))) | idx<-[0..(n-1)]:[n][width n] | i<-[0..(n-1)]:[n][23]]))\n           | k <- exponents\n           ]\n\nnttinv : nttPoly -> poly\nnttinv p' = p\n    where\n        pu = reorder p'\n        r' i = mod_pow (`q, rootOfUnityInv, (i*2))\n        p = [ mod_mul(`q, ninv, mod_mul(`q, mod_pow(`q, rootOfUnityInv, i), (mod_sum (`q, [mod_mul(`q, (pu@jdx), (r' ((i*j))))\n            | jdx<-[0..(n-1)]:[n][width n]\n            | j<-[0..(n-1)]:[n][qbits]\n            ]))))\n            | i <- [0..255]:[n][qbits]\n            ]\n\nreorder : nttPoly -> nttPoly\nreorder a = join [ [a1 @ i, a2 @ i] | i <- [0..127]:[_][8] ]\n        where\n          a1 = a @@ [ (i-1)\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ]\n          a2 = reverse (a @@ [ (511 - (zero#i):[9])\/2 | i <- [reverse ((128+i) : [8]) | i <- [0..127] ] ])\n\nnttMatMul : {dim1,dim2} (fin dim1,fin dim2) => nttMat dim1 dim2 -> nttVec dim2 -> nttVec dim1\nnttMatMul mat vec = [ nttDotProduct v vec | v <- mat ]\n\nnttDotProduct : {dim} (fin dim) => nttVec dim -> nttVec dim -> nttPoly\nnttDotProduct v1 v2 = foldl padd (zero:nttPoly) [ nttPolyMult p1 p2 | p1 <- v1 | p2 <- v2 ]\n\nnttPolyMult : nttPoly -> nttPoly -> nttPoly\nnttPolyMult p1 p2 = [ mod_mul(`q, x, y) | x <- p1 | y <- p2]\n\nnttVecConstMul : {dim} (fin dim) => nttPoly -> nttVec dim -> nttVec dim\nnttVecConstMul c v = map (nttPolyMult c) v\n\npolyVecSum :  {dim} (fin dim) => polyVec dim -> polyVec dim -> polyVec dim\npolyVecSum v1 v2 = map nttinv (paddV v1' v2')\n        where\n        v1' = map ntt v1\n        v2' = map ntt v2\n\npadd : [n][qbits] -> [n][qbits] -> [n][qbits]\npadd p1 p2 = [ mod_add(`q, x, y) | x <- p1 | y <- p2 ]\n\npsub : [n][qbits] -> [n][qbits] -> [n][qbits]\npsub p1 p2 = [ mod_sub(`q, x, y) | x <- p1 | y <- p2 ]\n\npsubV : {dim} (fin dim) => [dim][n][qbits] -> [dim][n][qbits] -> [dim][n][qbits]\npsubV v1 v2 = zipWith psub v1 v2\n\npaddV : {dim} (fin dim) => [dim][n][qbits] -> [dim][n][qbits] -> [dim][n][qbits]\npaddV v1 v2 = zipWith padd v1 v2\n\ninfNorm : [qbits] -> [qbits]\ninfNorm x =  (centered_mod x `q)\n\ninfNormPoly : intPoly -> [qbits]\ninfNormPoly p = foldl max 0 p_centered\n            where\n              p_centered = map infNorm p\n\ninfNormPolyVec : {dim} (fin dim, dim>=1) => intPolyVec dim -> [qbits]\ninfNormPolyVec v = foldl max 0 (map infNormPoly v)\n\nBVtoIntPoly : poly -> [n]Integer\nBVtoIntPoly p = map (\\x -> toInteger x) p\n\nBVtoIntPolyVec : {dim} (fin dim, dim >= 1) => polyVec dim -> [dim][n]Integer\nBVtoIntPolyVec pvec = map (\\x -> BVtoIntPoly x) pvec\n\nBVtoIntNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => nttMat dim1 dim2 -> [dim1][dim2][n]Integer\nBVtoIntNttMat nttmat = map (\\x -> BVtoIntPolyVec x) nttmat\n\nBVtoZPoly : poly -> [n](Z q)\nBVtoZPoly p = map (\\x -> BVtoZ`{q} x) p\n\nBVtoZPolyVec : {dim} (fin dim, dim >= 1) => polyVec dim -> [dim][n](Z q)\nBVtoZPolyVec pvec = map (\\x -> BVtoZPoly x) pvec\n\nBVtoZNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => nttMat dim1 dim2 -> [dim1][dim2][n](Z q)\nBVtoZNttMat nttmat = map (\\x -> BVtoZPolyVec x) nttmat\n\nInttoZPoly : [n]Integer -> [n](Z q)\nInttoZPoly p = map (\\x -> fromInteger x:(Z q)) p\n\nInttoZPolyVec : {dim} (fin dim, dim >= 1) => [dim][n]Integer -> [dim][n](Z q)\nInttoZPolyVec pvec = map (\\x -> InttoZPoly x) pvec\n\nInttoZNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => [dim1][dim2][n]Integer -> [dim1][dim2][n](Z q)\nInttoZNttMat nttmat = map (\\x -> InttoZPolyVec x) nttmat\n\nfromZPoly : [n](Z q) -> [n]Integer\nfromZPoly p = map (\\x -> fromZ x) p\n\nfromZPolyVec : {dim} (fin dim, dim >= 1) => [dim][n](Z q) -> [dim][n]Integer\nfromZPolyVec pvec = map (\\x -> fromZPoly x) pvec\n\nfromZNttMat : {dim1, dim2} (fin dim1, dim1>=1, fin dim2, dim2>=1) => [dim1][dim2][n](Z q) -> [dim1][dim2][n]Integer\nfromZNttMat nttmat = map (\\x -> fromZPolyVec x) nttmat\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Primitive\/Asymmetric\/Signature\/ecdsa.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for NIST P-384 ECDSA, including p384_ecdsa_sign and p384_ecdsa_public_verify, and define properties test_plus, test_minus, test_double, test_ds, and test_ds_et asserting the computed points equal the given expected affine points."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Asymmetric::Signature::ecdsa where\n\nimport Common::bv\nimport Common::mod_arith\nimport Common::mul_java\n\nimport Common::Field \nimport Common::EC::ec_point_ops\nimport Common::EC::ref_ec_mul\nimport Common::EC::p384_field\nimport Common::EC::p384_ec_point_ops\nimport Common::EC::p384_ec_mul\n\ntest_params : ([384], AffinePoint [384], [384], AffinePoint [384])\ntest_params =\n  (0xe74872524f90425d832a4f264e1f7b9209ec7456e9b4c467d8eac6c68f973ea7fea24f4d3fa8498bb1e26f933eaa261b\n  , { x=0xbbab93c429707b2afe9ac285314d7b40c4ee31531b13291aa9058307cdd038b572fdf2f3a84dc912804fa426fe531a3c\n    , y=0x4c2cffaa333bfd82b575918bb979bf51480c836082c097a03fed5454877b37d2f44f0401d212c16b05052bd383047b31\n    }\n  , 0xd4356773f2b311955542c5835696b9dca9d0e59197d5746bbf7dc079a666d955f74114662e38d31196bf94b060cc0c80\n  , { x=0xd40c63c65b413d0741c56e884f0dca63b822a6f6879d36f9261d9b4a270d5d79a9be790fdfb871b5d6ae9204da692663\n    , y=0x4d6b2b937c85b3c0c3cd2df85e9307cc89e0093f336af3b4531aa126bbdbec466562d8aa0dc1cf360fc1f1d0951e3ad1\n    })\n\ntype Curve fv gv = {\n    point_ops : PointOps fv gv\n  , base : AffinePoint fv\n  , affinify : JacobianPoint fv -> AffinePoint fv\n  , mul : (gv, AffinePoint fv) -> JacobianPoint fv\n  , twin_mul : (gv, AffinePoint fv, gv, AffinePoint fv) -> JacobianPoint fv\n  }\n\ninitialize_public_key : {fv} (Curve [fv] [fv], [fv]) -> AffinePoint [fv]\ninitialize_public_key(c, k) = c.affinify(c.mul(k, c.base))\n\necdsa_sign : {fv} (fin fv, fv >= 1) => (Curve [fv] [fv], [fv], [fv], [fv]) -> ([fv], [fv])\necdsa_sign(c,d,e,k) = if is_zero(r) || is_zero(s) then (0,0) else (r, s)\n  where\n    g = c.point_ops.group_field\n    is_zero(x) = g.is_equal(x, g.field_zero)\n\n    j = (c.affinify(c.mul(k, c.base))).x\n\n    r = g.norm(j)\n    s = g.div(g.add(g.norm(e), g.mul(d, r)), k)\n\necdsa_public_verify : {fv} (fin fv, fv >= 1)\n   => (Curve [fv] [fv], [fv], ([fv], [fv]), AffinePoint [fv]) -> Bit\necdsa_public_verify(c, e, (r, s), q)\n\n   = in_range(s) && (v == r)\n  where\n    f = c.point_ops.field\n    g = c.point_ops.group_field\n    mul(x,y) = g.mul(x, y)\n    div(x,y) = g.div(x, y)\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    in_range(x) = ~is_zero(x) && g.is_val(x)\n    s_inv = div(1, s)\n    u1 = mul(e, s_inv)\n    u2 = mul(r, s_inv)\n    r2 = c.twin_mul(u1, c.base, u2, q)\n\n    j = f.mul(r2.x, f.sq(f.div(f.field_unit, r2.z)))\n\n    v = g.norm(j)\n\necdsa_public_verify_imp :\n  (Curve [384] [384], [384], ([384], [384]), AffinePoint [384]) -> Bit\necdsa_public_verify_imp(c, e, (r, s), q)\n   = in_range(r) && in_range(s) &&\n     ~is_zero(r2.z) &&\n     (g.is_equal(j, r2.x) || ((carrybits == False) && (g.is_equal(k, r2.x))))\n  where\n    f = c.point_ops.field\n    g = c.point_ops.group_field\n    mul(x,y) = g.mul(x, y)\n    div(x,y) = g.div(x, y)\n    is_zero(x) = g.is_equal(x, g.field_zero)\n    in_range(x) = ~is_zero(x) && g.is_val(x)\n    s_inv = div(1, s)\n    u1 = mul(g.norm(e), s_inv)\n    u2 = mul(r, s_inv)\n    r2 = c.twin_mul(u1, c.base, u2, q)\n    r2zsq = f.sq(r2.z)\n    j = f.mul(r, r2zsq)\n    summ = r + p384_group_size\n    carrybits = (summ < r) && (summ < p384_group_size)\n    k = f.mul(summ, r2zsq)\n\ntype RsltWithCarry a b = { carrybits : a , rslt : b }\n\np384_incFieldPrime : [384] -> RsltWithCarry [32] [384]\np384_incFieldPrime x = { carrybits = zero # [(bs @ 0)]\n                       , rslt = drop(bs) : [384]\n                       }\n  where bs = safe_add(x, p384_prime)\n\np384_decFieldPrime : [384] -> RsltWithCarry [32] [384]\np384_decFieldPrime x = { carrybits = if (bs @ 0) then -1 else 0\n                       , rslt = drop(bs) : [384]\n                       }\n  where bs = safe_sub(x, p384_prime)\n\np384_field_cube(x)       = p384_field_mul(x, p384_field_sq(x))\n\np384_base : AffinePoint [384]\np384_base = nzAffinePoint(\n  join [0xaa87ca22, 0xbe8b0537, 0x8eb1c71e, 0xf320ad74, 0x6e1d3b62, 0x8ba79b98\n       ,0x59f741e0, 0x82542a38, 0x5502f25d, 0xbf55296c, 0x3a545e38, 0x72760ab7],\n  join [0x3617de4a, 0x96262c6f, 0x5d9e98bf, 0x9292dc29, 0xf8f41dbd, 0x289a147c\n       ,0xe9da3113, 0xb5f0b8c0, 0x0a60b1ce, 0x1d7e819d, 0x7a431d7c, 0x90ea0e5f])\n\np384_group_add : ([384],[384]) -> [384]\np384_group_add = p384_group_field.add\n\np384_curve : Curve [384] [384]\np384_curve =\n  { point_ops = p384_point_ops\n  , base = p384_base\n  , affinify = \\x -> ec_affinify(p384_field, x)\n  , mul = p384_ec_mul\n  , twin_mul = p384_ec_twin_mul\n  }\n\np384_ecdsa_sign : ([384], [384], [384]) -> { r:[384], s:[384] }\np384_ecdsa_sign(d,e,k) = { r = rr, s = ss }\n  where (rr, ss) = ecdsa_sign(p384_curve,d,e,k)\n\np384_ecdsa_public_verify : ([384], [384], [384], AffinePoint [384]) -> Bit\np384_ecdsa_public_verify(e,pr,ps,q) =\n  ecdsa_public_verify_imp(p384_curve,e,(pr,ps),q)\n\np384_a : [384]\np384_a = p384_prime - 3\n\np384_b : [384]\np384_b = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\n\np384_jacobify : AffinePoint [384] -> JacobianPoint [384]\np384_jacobify p = { x = p.x, y = p.y, z = 1 }\n\np384_base4 : JacobianPoint [384]\np384_base4 = p384_ec_double(p384_ec_double(p384_jacobify(p384_base)))\n\np384_base3 : AffinePoint [384]\np384_base3 = p384_affinify(p384_ec_full_sub(p384_base4, p384_base))\n\np384_base5 : AffinePoint [384]\np384_base5 = p384_affinify(p384_ec_full_add(p384_base4, p384_base))\n\np384_is_affine_point : AffinePoint [384] -> Bit\np384_is_affine_point p =\n  p384_field_sq(p.y) ==\n  p384_field_add(p384_field_cube(p.x),\n                 p384_field_add(p384_field_mul(p384_a, p.x), p384_b))\n\np384_s : AffinePoint [384]\np384_s = nzAffinePoint(\n  join [0xfba203b8, 0x1bbd23f2, 0xb3be971c, 0xc23997e1, 0xae4d89e6, 0x9cb6f923,\n        0x85dda827, 0x68ada415, 0xebab4167, 0x459da98e, 0x62b1332d, 0x1e73cb0e],\n  join [0x5ffedbae, 0xfdeba603, 0xe7923e06, 0xcdb5d0c6, 0x5b223014, 0x29293376,\n        0xd5c6944e, 0x3fa6259f, 0x162b4788, 0xde6987fd, 0x59aed5e4, 0xb5285e45])\n\np384_t : AffinePoint [384]\np384_t = nzAffinePoint(\n  join [0xaacc0520, 0x2e7fda6f, 0xc73d82f0, 0xa6622052, 0x7da8117e, 0xe8f8330e,\n        0xad7d20ee, 0x6f255f58, 0x2d8bd38c, 0x5a7f2b40, 0xbcdb68ba, 0x13d81051],\n  join [0x84009a26, 0x3fefba7c, 0x2c57cffa, 0x5db3634d, 0x286131af, 0xc0fca8d2,\n        0x5afa22a7, 0xb5dce0d9, 0x470da892, 0x33cee178, 0x592f49b6, 0xfecb5092])\n\np384_d =\n  join [0xa4ebcae5, 0xa6659834, 0x93ab3e62, 0x6085a24c, 0x104311a7, 0x61b5a8fd,\n        0xac052ed1, 0xf111a5c4, 0x4f76f456, 0x59d2d111, 0xa61b5fdd, 0x97583480]\n\np384_e =\n  join [0xafcf8811, 0x9a3a76c8, 0x7acbd600, 0x8e1349b2, 0x9f4ba9aa, 0x0e12ce89,\n        0xbcfcae21, 0x80b38d81, 0xab8cf150, 0x95301a18, 0x2afbc689, 0x3e75385d]\n\np384_projectify : AffinePoint [384] -> JacobianPoint [384]\np384_projectify(p) = ec_projectify(f,p)\n  where f = p384_curve.point_ops.field\n\np384_affinify : JacobianPoint [384] -> AffinePoint [384]\np384_affinify(p) = ec_affinify(f,p)\n  where f = p384_curve.point_ops.field\n\ntest_p384_s_plus_t : AffinePoint [384]\ntest_p384_s_plus_t = p384_affinify(add(p384_projectify(s),t))\n  where s = p384_s\n        t = p384_t\n        add = p384_curve.point_ops.add\n\nexpected_p384_s_plus_t : AffinePoint [384]\nexpected_p384_s_plus_t =\n  { x = join [0x12dc5ce7, 0xacdfc584, 0x4d939f40, 0xb4df012e, 0x68f865b8, 0x9c3213ba,\n              0x97090a24, 0x7a2fc009, 0x075cf471, 0xcd2e85c4, 0x89979b65, 0xee0b5eed]\n  , y = join [0x167312e5, 0x8fe0c0af, 0xa248f285, 0x4e3cddcb, 0x557f983b, 0x3189b67f,\n              0x21eee013, 0x41e7e9fe, 0x67f6ee81, 0xb36988ef, 0xa406945c, 0x8804a4b0]\n  }\n\ntest_p384_s_minus_t : AffinePoint [384]\ntest_p384_s_minus_t = p384_affinify(sub(p384_projectify(s),t))\n  where s = p384_s\n        t = p384_t\n        sub = p384_curve.point_ops.sub\n\nexpected_p384_s_minus_t : AffinePoint [384]\nexpected_p384_s_minus_t =\n  { x = join [0x6afdaf8d, 0xa8b11c98, 0x4cf177e5, 0x51cee542, 0xcda4ac2f, 0x25cd522d,\n              0x0cd710f8, 0x8059c656, 0x5aef78f6, 0xb5ed6cc0, 0x5a6666de, 0xf2a2fb59]\n  , y = join [0x7bed0e15, 0x8ae8cc70, 0xe847a603, 0x47ca1548, 0xc348decc, 0x6309f48b,\n              0x59bd5afc, 0x9a9b804e, 0x7f787617, 0x8cb5a7eb, 0x4f6940a9, 0xc73e8e5e]\n  }\n\ntest_p384_double_s : AffinePoint [384]\ntest_p384_double_s = p384_affinify(dbl(p384_projectify(s)))\n  where s = p384_s\n        dbl = p384_curve.point_ops.double\n\nexpected_p384_double_s : AffinePoint [384]\nexpected_p384_double_s =\n  { x = join [0x2a2111b1, 0xe0aa8b2f, 0xc5a19755, 0x16bc4d58, 0x017ff96b, 0x25e1bdff,\n              0x3c229d5f, 0xac3bacc3, 0x19dcbec2, 0x9f9478f4, 0x2dee597b, 0x4641504c]\n  , y = join [0xfa2e3d9d, 0xc84db895, 0x4ce8085e, 0xf28d7184, 0xfddfd134, 0x4b4d4797,\n              0x343af9b5, 0xf9d83752, 0x0b450f72, 0x6443e411, 0x4bd4e5bd, 0xb2f65ddd]\n  }\n\ntest_p384_ds : AffinePoint [384]\ntest_p384_ds = p384_affinify(mul(p384_d, p384_s))\n  where mul = p384_curve.mul\n\nexpected_p384_ds : AffinePoint [384]\nexpected_p384_ds =\n  { x = join [0xe4f77e7f, 0xfeb7f095, 0x8910e3a6, 0x80d677a4, 0x77191df1, 0x66160ff7,\n              0xef6bb526, 0x1f791aa7, 0xb45e3e65, 0x3d151b95, 0xdad3d93c, 0xa0290ef2]\n  , y = join [0xac7dee41, 0xd8c5f4a7, 0xd5836960, 0xa773cfc1, 0x376289d3, 0x373f8cf7,\n              0x417b0c62, 0x07ac32e9, 0x13856612, 0xfc9ff2e3, 0x57eb2ee0, 0x5cf9667f]\n  }\n\ntest_p384_ds_et : AffinePoint [384]\ntest_p384_ds_et = p384_affinify(twin_mul(p384_d, p384_s, p384_e, p384_t))\n  where twin_mul = p384_curve.twin_mul\n\nexpected_p384_ds_et : AffinePoint [384]\nexpected_p384_ds_et =\n  { x = join [0x917ea28b, 0xcd641741, 0xae5d18c2, 0xf1bd917b, 0xa68d34f0, 0xf0577387,\n              0xdc812604, 0x62aea60e, 0x2417b8bd, 0xc5d954fc, 0x729d211d, 0xb23a02dc]\n  , y = join [0x1a29f7ce, 0x6d074654, 0xd77b4088, 0x8c73e925, 0x46c8f16a, 0x5ff6bcbd,\n              0x307f758d, 0x4aee684b, 0xeff26f67, 0x42f597e2, 0x585c86da, 0x908f7186]\n  }\n\nproperty test_plus =\n  test_p384_s_plus_t  == expected_p384_s_plus_t\n\nproperty test_minus =\n  test_p384_s_minus_t == expected_p384_s_minus_t\n\nproperty test_double =\n  test_p384_double_s  == expected_p384_double_s\n\nproperty test_ds =\n  test_p384_ds    == expected_p384_ds\n\nproperty test_ds_et =\n  test_p384_ds_et == expected_p384_ds_et\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Common\/EC\/ec_point_ops.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Specify and verify in Cryptol the elliptic-curve point operations module, including affine\/Jacobian conversions, zero-point handling, point doubling, mixed Jacobian\u2013affine addition, and subtraction, with appropriate types (AffinePoint, JacobianPoint, PointOps) and properties that these operations implement the EC group law over a given Field."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::ec_point_ops where\n\nimport Common::Field\nimport Common::Set\n\ntype AffinePoint fv = { x : fv, y : fv }\n\nnzAffinePoint : {fv} (fv,fv) -> AffinePoint fv\nnzAffinePoint (ax,ay) = { x = ax, y = ay }\n\ntype JacobianPoint fv = { x : fv, y : fv, z : fv }\n\nec_affinify : {fv} (Field fv, JacobianPoint fv) -> AffinePoint fv\nec_affinify(f,s) = { x = f.mul(g2, s.x), y = f.mul(g3, s.y) }\n  where g = f.div(f.field_unit, s.z)\n        g2 = f.sq(g)\n        g3 = f.mul(g, g2)\n\nec_projectify : {fv} (Field fv, AffinePoint fv) -> JacobianPoint fv\nec_projectify(f,s) = { x = s.x, y = s.y, z = f.field_unit }\n\nec_zero_point : {fv} Field fv -> JacobianPoint fv\nec_zero_point(f) = { x = f.field_unit, y = f.field_unit, z = f.field_zero }\n\nec_is_zero_point : {fv} (Field fv, JacobianPoint fv) -> Bit\nec_is_zero_point(f,s) = f.is_equal(s.z, f.field_zero)\n\nis_JacobianPoint : {fv} (Cmp fv) => Field fv -> Set (JacobianPoint fv)\nis_JacobianPoint f s =\n  (  f.is_val ((s:JacobianPoint fv).x)\n  && f.is_val (s.y)\n  && f.is_val (s.z)\n  && implies (ec_is_zero_point (f,s))\n             (s == ec_zero_point f)\n  )\n\ntype PointOps fv gv = {\n       field : Field fv\n     , double : JacobianPoint fv -> JacobianPoint fv\n     , add : (JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\n     , sub : (JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\n     , group_field : Field gv\n     }\n\nec_double : {fv} (Field fv, JacobianPoint fv) -> JacobianPoint fv\nec_double(f,s) =\n  if is_zero(s.z) then\n    { x = f.field_unit, y = f.field_unit, z = f.field_zero } \n  else\n    { x = r18, y = r23, z = r13 }\n where\n   add = f.add\n   sub = f.sub\n   mul = f.mul\n   is_zero(x) = f.is_equal(x, f.field_zero)\n   dbl(x) = f.add(x, x)\n   mul3(x) = f.add(x, f.add(x, x))\n   mul4(x) = dbl(dbl(x))\n   mul8(x) = dbl(mul4(x))\n\n   r7  = f.sq(s.z)               \n   r8  = f.sub(s.x, r7)          \n   r9  = add(s.x, r7)            \n   r10 = mul(r9, r8)             \n   r11 = mul3(r10)               \n   r12 = mul(s.z, s.y)           \n   r13 = dbl(r12)                \n   r14 = f.sq(s.y)               \n   r15 = mul(s.x, r14)           \n   r16 = mul4(r15)               \n   r17 = f.sq(r11)               \n   r18 = sub(sub(r17, r16), r16) \n   r19 = f.sq(r14)               \n   r20 = mul8(r19)               \n   r21 = sub(r16, r18)           \n   r22 = mul(r11, r21)           \n   r23 = sub(r22, r20)           \n\nec_add : {fv, gv} (PointOps fv [gv], JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\nec_add(p,s,t) =\n  if is_zero(r13) then\n    if is_zero(r14) then\n      p.double(s) \n    else\n      { x = p.field.field_unit\n      , y = p.field.field_unit\n      , z = p.field.field_zero\n      } \n  else\n    { x = r32, y = r37, z = r27 }\n  where\n   add = p.field.add\n   sub = p.field.sub\n   mul = p.field.mul\n   sq  = p.field.sq\n   is_zero(x) = p.field.is_equal(x, p.field.field_zero)\n   dbl(x) = add(x, x)\n   dbl_dec(x, y) = sub(sub(x, y), y)\n\n   r9 = sq(s.z)             \n   r10 = mul(t.x, r9)       \n   r11 = mul(s.z, r9)       \n   r12 = mul(t.y, r11)      \n   r13 = sub(s.x, r10)      \n   r14 = sub(s.y, r12)      \n\n   r22 = sub(dbl(s.x), r13) \n   r23 = sub(dbl(s.y), r14) \n\n   r27 = mul(s.z, r13)      \n   r28 = sq(r13)            \n   r29 = mul(r13, r28)      \n   r30 = mul(r22, r28)      \n   r31 = sq(r14)            \n   r32 = sub(r31, r30)      \n\n   r33 = dbl_dec(r30, r32)  \n   r34 = mul(r14, r33)      \n   r35 = mul(r23, r29)      \n   r36 = sub(r34, r35)      \n   r37 = p.field.half(r36)  \n\nec_full_add : {fv, gv} (fin gv) => (PointOps fv [gv], JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\nec_full_add(p, s, t) =\n  if is_zero(s.z) then\n    { x = t.x, y = t.y, z = p.field.field_unit }\n  else\n    ec_add(p, s, t)\n where\n   is_zero(x) = p.field.is_equal(x, p.field.field_zero)\n\nec_full_sub : {fv, gv} (PointOps fv [gv], JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv\nec_full_sub(p, s, t) = p.add(s, { x = t.x, y = p.field.neg(t.y) })\n```"}]}
{"filename":"saw-demos\/cryptol-specs\/Common\/EC\/p384_field.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `Common::EC::p384_field` that defines the P-384 prime field and group field, including constants, modular arithmetic operations, Montgomery-style reduction `p384_field_mod`, and `Field [384]` records `p384_field` and `p384_group_field` with the same behavior and interfaces as described."},{"role":"assistant","content":"```cryptol\nmodule Common::EC::p384_field where\n\nimport Common::bv\nimport Common::mod_arith\nimport Common::mul_java\nimport Common::Field\n\np384_prime : [384]\np384_prime = - (2 ^^ 384 + 2 ^^ 128 + 2 ^^ 96 - 2 ^^ 32 + 1)\n\np384_is_field_val : [384] -> Bit\np384_is_field_val = is_normal p384_prime\n\np384_is_group_val : [384] -> Bit\np384_is_group_val  = is_normal p384_group_size\n\np384_mod_add : ([384],[384],[384]) -> [384]\np384_mod_add = mod_add\n\np384_mod_sub : ([384],[384],[384]) -> [384]\np384_mod_sub = mod_sub\n\np384_mod_neg : ([384], [384]) -> [384]\np384_mod_neg = mod_neg\n\np384_safe_product : ([384], [384]) -> [768]\np384_safe_product (x, y) = safe_product(x, y)\n\np384_field_add(x,y) = p384_mod_add(p384_prime, x, y)\np384_field_sub(x,y) = p384_mod_sub(p384_prime, x, y)\n\np384_field_neg(x)        = if x == 0 then 0 else (p384_prime - x)\n\np384_field_mul : ([384],[384]) -> [384]\np384_field_mul(x,y)      = p384_field_mod(p384_safe_product(x, y))\n\np384_field_sq(x)         = p384_field_mul(x, x)\n\np384_mod_half : ([384],[384]) -> [384]\np384_mod_half = mod_half\n\np384_mod_mul : ([384],[384],[384]) -> [384]\np384_mod_mul = mod_mul\n\np384_mod_div : ([384],[384],[384]) -> [384]\np384_mod_div = mod_div\n\np384_field_mod : [768] -> [384]\np384_field_mod(a)\n    = drop(if b1 then r0\n           else if b2 then r1\n           else if b3 then r2\n           else if b4 then r3\n           else r4)\n  where\n    [  a23, a22, a21, a20, a19, a18, a17, a16, a15, a14, a13, a12,\n       a11, a10,  a9,  a8,  a7,  a6,  a5,  a4,  a3,  a2,  a1,  a0]\n              = [ zext x | (x : [32]) <- split a ] : [24][64]\n\n    chop : [64] -> ([64],[32])\n    chop x = (sext(take(x):[32]), drop(x))\n\n    (d0, z0)  = chop(    a0          +a12+a21        +a20-a23)\n    (d1, z1)  = chop(d0 +a1          +a13+a22+a23        -a12-a20)\n    (d2, z2)  = chop(d1 +a2          +a14+a23            -a13-a21)\n    (d3, z3)  = chop(d2 +a3          +a15+a12+a20    +a21-a14-a22-a23)\n    (d4, z4)  = chop(d3 +a4 +(a21<<1)+a16+a13+a12+a20+a22-a15-(a23<<1))\n    (d5, z5)  = chop(d4 +a5 +(a22<<1)+a17+a14+a13+a21+a23-a16)\n    (d6, z6)  = chop(d5 +a6 +(a23<<1)+a18+a15+a14+a22    -a17)\n    (d7, z7)  = chop(d6 +a7          +a19+a16+a15+a23    -a18)\n    (d8, z8)  = chop(d7 +a8          +a20+a17+a16        -a19)\n    (d9, z9)  = chop(d8 +a9          +a21+a18+a17        -a20)\n    (d10,z10) = chop(d9 +a10         +a22+a19+a18        -a21)\n    (d11,z11) = chop(d10+a11         +a23+a20+a19        -a22)\n\n    r : [13*32]\n    r = (drop(d11):[32])\n      # z11 # z10 #  z9 #  z8 #  z7 #  z6\n      #  z5 #  z4 #  z3 #  z2 #  z1 #  z0\n\n    p  = zext(p384_prime) : [13*32]\n        r0 = if (d11@0) then r + p else r\n        (r1,b1)   = sbb(r0, p)\n    (r2,b2)   = sbb(r1, p)\n    (r3,b3)   = sbb(r2, p)\n    (r4,b4)   = sbb(r3, p)\n\np384_field :  Field [384]\np384_field = {\n    is_val     = p384_is_field_val\n  , norm       = \\x -> if x < p384_prime then x else x - p384_prime\n  , add        = p384_field_add\n  , sub        = p384_field_sub\n  , neg        = p384_field_neg\n  , mul        = p384_field_mul\n  , sq         = p384_field_sq\n  , half       = \\x -> p384_mod_half(p384_prime, x)\n  , div        = \\(x,y) -> p384_mod_div(p384_prime, x, y)\n  , field_zero = 0\n  , field_unit = 1\n  , is_equal   = \\(x,y) -> x == y\n  }\n\np384_group_size : [384]\np384_group_size =\n  join\n    [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n     0xc7634d81, 0xf4372ddf, 0x581a0db2, 0x48b0a77a, 0xecec196a, 0xccc52973]\n\np384_group_field :  Field [384]\np384_group_field =\n  { is_val     = p384_is_group_val\n  , norm       = \\x -> if x < p384_group_size then x else x - p384_group_size\n  , add        = \\(x,y) -> p384_mod_add(p384_group_size, x, y)\n  , sub        = \\(x,y) -> p384_mod_sub(p384_group_size, x, y)\n  , neg        = \\x     -> p384_mod_neg(p384_group_size, x)\n  , mul        = \\(x,y) -> p384_group_mul(p384_group_size, x, y)\n  , sq         = \\x     -> p384_mod_mul(p384_group_size, x, x)\n  , half       = \\x     -> p384_mod_half(p384_group_size, x)\n  , div        = \\(x,y) -> p384_mod_div(p384_group_size, x, y)\n  , field_zero = 0\n  , field_unit = 1\n  , is_equal   = \\(x,y) -> x == y\n  }\n```"}]}
{"filename":"saw-demos\/templates\/c\/dotprod.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function `dotprod : {n, a} (fin n, Eq a, Ring a) => [n]a -> [n]a -> a` in Cryptol, computing the dot product of two length-`n` vectors using element-wise multiplication followed by summation."},{"role":"assistant","content":"```cryptol\ndotprod : {n, a} (fin n, Eq a, Ring a) => [n]a -> [n]a -> a\ndotprod xs ys = sum (zipWith (*) xs ys)\n```"}]}
{"filename":"saw-demos\/demos\/xxhash\/xxhash.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the xxhash module that implements the XXH32 and XXH64 hash functions along with properties PRIME32s_as_bits_correct and PRIME64s_as_bits_correct that verify the prime constants\u2019 bit-level encodings."},{"role":"assistant","content":"```cryptol\nmodule xxhash where\n\nXXH32 : {L} (fin L) => [L][8] -> [32] -> [32]\nXXH32 input seed = XXH32_avalanche acc1\n  where (stripes16 # stripes4 # stripes1) = input\n        accR = foldl XXH32_rounds (XXH32_init seed) (split stripes16 : [L\/16][16][8])\n        accL = `(L % 2^^32) + if (`L:Integer) < 16\n                              then seed + PRIME32_5\n                              else XXH32_converge accR\n        acc4 = foldl XXH32_digest4 accL (split stripes4 : [(L%16)\/4][4][8])\n        acc1 = foldl XXH32_digest1 acc4 (stripes1 : [L%4][8])\n\nXXH64 : {L} (fin L) => [L][8] -> [64] -> [64]\nXXH64 input seed = XXH64_avalanche acc1\n  where (stripes32 # stripes8 # stripes4 # stripes1) = input\n        accR = foldl XXH64_rounds (XXH64_init seed) (split stripes32 : [L\/32][32][8])\n        accL = `(L % 2^^64) + if (`L:Integer) < 32\n                              then seed + PRIME64_5\n                              else XXH64_converge accR\n        acc8 = foldl XXH64_digest8 accL (split stripes8 : [(L%32)\/8][8][8])\n        acc4 = foldl XXH64_digest4 acc8 (split stripes4 : [(L%8)\/4][4][8])\n        acc1 = foldl XXH64_digest1 acc4 (stripes1 : [L%4][8])\n\nprivate\n\n  toLE bytes = join (reverse bytes)\n\n    PRIME32_1 = 0x9E3779B1 : [32]\n  PRIME32_2 = 0x85EBCA77 : [32]\n  PRIME32_3 = 0xC2B2AE3D : [32]\n  PRIME32_4 = 0x27D4EB2F : [32]\n  PRIME32_5 = 0x165667B1 : [32]\n\n  property PRIME32s_as_bits_correct =\n    (PRIME32_1 == 0b10011110001101110111100110110001) \/\\\n    (PRIME32_2 == 0b10000101111010111100101001110111) \/\\\n    (PRIME32_3 == 0b11000010101100101010111000111101) \/\\\n    (PRIME32_4 == 0b00100111110101001110101100101111) \/\\\n    (PRIME32_5 == 0b00010110010101100110011110110001)\n\n  XXH32_init : [32] -> [4][32]\n  XXH32_init seed = [acc1, acc2, acc3, acc4]\n    where acc1 = seed + PRIME32_1 + PRIME32_2\n          acc2 = seed + PRIME32_2\n          acc3 = seed + 0\n          acc4 = seed - PRIME32_1\n\n  XXH32_round : [32] -> [32] -> [32]\n  XXH32_round accN laneN = ((accN + laneN * PRIME32_2) <<< 13) * PRIME32_1\n\n  XXH32_rounds : [4][32] -> [16][8] -> [4][32]\n  XXH32_rounds accs stripe =\n    [ XXH32_round accN (toLE laneN) | accN <- accs | laneN <- split stripe ]\n\n  XXH32_converge : [4][32] -> [32]\n  XXH32_converge [acc1, acc2, acc3, acc4] =\n    (acc1 <<< 1) + (acc2 <<< 7) + (acc3 <<< 12) + (acc4 <<< 18)\n\n  XXH32_digest4 : [32] -> [4][8] -> [32]\n  XXH32_digest4 acc lane = ((acc + toLE lane * PRIME32_3) <<< 17) * PRIME32_4\n\n  XXH32_digest1 : [32] -> [8] -> [32]\n  XXH32_digest1 acc lane = ((acc + (0 # lane) * PRIME32_5) <<< 11) * PRIME32_1\n\n  XXH32_avalanche : [32] -> [32]\n  XXH32_avalanche acc0 = acc5\n    where acc1 = acc0 ^ (acc0 >> 15)\n          acc2 = acc1 * PRIME32_2\n          acc3 = acc2 ^ (acc2 >> 13)\n          acc4 = acc3 * PRIME32_3\n          acc5 = acc4 ^ (acc4 >> 16)\n\n    PRIME64_1 = 0x9E3779B185EBCA87 : [64]\n  PRIME64_2 = 0xC2B2AE3D27D4EB4F : [64]\n  PRIME64_3 = 0x165667B19E3779F9 : [64]\n  PRIME64_4 = 0x85EBCA77C2B2AE63 : [64]\n  PRIME64_5 = 0x27D4EB2F165667C5 : [64]\n\n  property PRIME64s_as_bits_correct =\n    (PRIME64_1 == 0b1001111000110111011110011011000110000101111010111100101010000111) \/\\\n    (PRIME64_2 == 0b1100001010110010101011100011110100100111110101001110101101001111) \/\\\n    (PRIME64_3 == 0b0001011001010110011001111011000110011110001101110111100111111001) \/\\\n    (PRIME64_4 == 0b1000010111101011110010100111011111000010101100101010111001100011) \/\\\n    (PRIME64_5 == 0b0010011111010100111010110010111100010110010101100110011111000101)\n\n  XXH64_init : [64] -> [4][64]\n  XXH64_init seed = [acc1, acc2, acc3, acc4]\n    where acc1 = seed + PRIME64_1 + PRIME64_2\n          acc2 = seed + PRIME64_2\n          acc3 = seed + 0\n          acc4 = seed - PRIME64_1\n\n  XXH64_round : [64] -> [64] -> [64]\n  XXH64_round accN laneN = ((accN + laneN * PRIME64_2) <<< 31) * PRIME64_1\n\n  XXH64_rounds : [4][64] -> [32][8] -> [4][64]\n  XXH64_rounds accs stripe =\n    [ XXH64_round accN (toLE laneN) | accN <- accs | laneN <- split stripe ]\n\n  mergeAccumulator : [64] -> [64] -> [64]\n  mergeAccumulator acc accN = (acc ^ XXH64_round 0 accN) * PRIME64_1 + PRIME64_4\n\n  XXH64_converge : [4][64] -> [64]\n  XXH64_converge [acc1, acc2, acc3, acc4] =\n    foldl mergeAccumulator ((acc1 <<< 1) + (acc2 <<< 7) + (acc3 <<< 12) + (acc4 <<< 18)) [acc1, acc2, acc3, acc4]\n\n  XXH64_digest8 : [64] -> [8][8] -> [64]\n  XXH64_digest8 acc lane = ((acc ^ XXH64_round 0 (toLE lane)) <<< 27) * PRIME64_1 + PRIME64_4\n\n  XXH64_digest4 : [64] -> [4][8] -> [64]\n  XXH64_digest4 acc lane = ((acc ^ (0 # toLE lane) * PRIME64_1) <<< 23) * PRIME64_2 + PRIME64_3\n\n  XXH64_digest1 : [64] -> [8] -> [64]\n  XXH64_digest1 acc lane = ((acc ^ (0 # lane) * PRIME64_5) <<< 11) * PRIME64_1\n\n  XXH64_avalanche : [64] -> [64]\n  XXH64_avalanche acc0 = acc5\n    where acc1 = acc0 ^ (acc0 >> 33)\n          acc2 = acc1 * PRIME64_2\n          acc3 = acc2 ^ (acc2 >> 29)\n          acc4 = acc3 * PRIME64_3\n          acc5 = acc4 ^ (acc4 >> 32)\n```"}]}
{"filename":"saw-demos\/demos\/signal-protocol\/cryptol\/HMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define Cryptol functions `hmac_init`, `hmac_update`, and `hmac_final` implementing an HMAC-based MAC used by the Signal protocol, with `HMACContext` and `SIGNAL_MESSAGE_MAC_LENGTH` as given, suitable for verifying Signal message authentication codes."},{"role":"assistant","content":"```cryptol\ntype HMAC_CONTEXT_LENGTH = 1\ntype HMACContext = [HMAC_CONTEXT_LENGTH][8]\n\ntype SIGNAL_MESSAGE_MAC_LENGTH = 8\n\nhmac_init : {n} [n][8] ->             HMACContext\nhmac_init = undefined\n\nhmac_update : {n} [n][8] ->               HMACContext -> HMACContext\nhmac_update = undefined\n\nhmac_final : HMACContext ->\n             [SIGNAL_MESSAGE_MAC_LENGTH][8] hmac_final = undefined\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/AES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for AES encryption that defines `encrypt`, `expandKey`, and `encryptWithSchedule` using a mode-parameterized key schedule, and a property `test` asserting `encrypt k pt == encryptWithSchedule (expandKey k) pt` for all valid key sizes and plaintexts."},{"role":"assistant","content":"```cryptol\nmodule AES where\n\nimport `Common::AES\n\ntype constraint ValidKey k m = (k == 128 + m * 64, 2 >= m)\n\ntype ExpandedKey m = KeySchedule m\n\nencrypt : {k,m} ValidKey k m => [k] -> [128] -> [128]\nencrypt = aesEncrypt`{Mode = m}\n\nexpandKey : {k,m} ValidKey k m => [k] -> ExpandedKey m\nexpandKey = ExpandKey`{Mode = m}\n\nencryptWithSchedule : {k,m} ValidKey k m => ExpandedKey m -> [128] -> [128]\nencryptWithSchedule = aesEncryptWithSchedule`{Mode = m}\n\nproperty test k pt = encrypt k pt == encryptWithSchedule (expandKey k) pt\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/AES128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module `AES128` that defines 128-bit AES types and wrapper functions for SubBytes, ShiftRows, key expansion, rounds, and state encryption, specialized to AES with 128-bit keys, matching the given signatures and using `Common::AES` and `AES` imports."},{"role":"assistant","content":"```cryptol\nmodule AES128 where\n\nimport `Common::AES\nimport `Common::AES as AES\nimport AES as AES\n\ntype State         = AES::State 0  \ntype KeySchedule   = AES::KeySchedule 0\ntype RoundKey      = AES::RoundKey 0\n\nsub_bytes128 : State -> State\nsub_bytes128 = SubBytes`{0}\n\nshift_rows128 : State -> State\nshift_rows128 = ShiftRows`{0}\n\nexpand_key128 : [128] -> KeySchedule\nexpand_key128 = AES::expandKey\n\naes_round128 : RoundKey -> State -> State\naes_round128 = AES::aes_round`{0}\n\naes_final_round128 : RoundKey -> State -> State\naes_final_round128 = AES::aes_final_round`{0}\n\nencryptState128 : KeySchedule -> State -> State\nencryptState128 = AES::encryptState`{0}\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/intrinsics.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of the Intrinsics module that models AES-GCM-SIV-related SSE intrinsics and includes the property polyval_equiv stating that AES_GCM_SIV::polyvalFrom H xs zero equals polyval_Htable H xs for all H and xs : [4][128]."},{"role":"assistant","content":"```cryptol\nmodule Intrinsics where\n\nimport `Common::AES_GCM_SIV as AES_GCM_SIV\n\n_mm_setr_epi32 : [32] -> [32] -> [32] -> [32] -> [128]\n_mm_setr_epi32 a b c d = join [a, b, c, d]\n\n_mm_loadu_si128 : [128] -> [4][32]\n_mm_loadu_si128 v = split v\n\nselect_from_128 : [128] -> Bit -> [128]\nselect_from_128 n b = res\n  where\n    [l,r] = split n\n    res = (if b then l else r) # zero\n\n_mm_clmulepi64_si128 : [128] -> [128] -> [2] -> [128 ]\n_mm_clmulepi64_si128 a b s = AES_GCM_SIV::mult`{0}`{0} l r\n  where\n  l = select_from_128 a (s @ 0)\n  r = select_from_128 b (s @ 1)\n\n_mm_xor_si128 : [128] -> [128] -> [128]\n_mm_xor_si128 a b = a ^ b\n\n_mm_shuffle_epi32_78 : [4][32] -> [4][32]\n_mm_shuffle_epi32_78 l = l >>> 2\n\n_mm_alignr_epi8 : [16][8] -> [16][8] -> [8] -> [128]\n_mm_alignr_epi8 a b ralign = take ((join (a # b)) >> (ralign * 8))\n\nINIT_Htable : {n} (fin n, n>=2) => [128] -> [n][128]\nINIT_Htable H = hs\n  where\n  hs = [H] # [ AES_GCM_SIV::dot`{0}`{0} hn H\n                | hn <- hs\n                | (j : [width n]) <- [0..n-2]]\n\npolyval_Htable : {n} (fin n, n>=2) => [128] -> [n][128] -> [128]\npolyval_Htable H X = sums ! 0\n  where\n    htable = INIT_Htable`{n} H\n    sums = [zero] # [ (AES_GCM_SIV::dot`{0}`{0} (X@i) (htable!i)) ^ sum\n                    | sum <- sums\n                    | (i : [width n]) <- [0..n-1] ]\n\nproperty polyval_equiv H (xs : [4][128]) =\n  AES_GCM_SIV::polyvalFrom`{0}`{0} H xs zero ==\n  polyval_Htable H xs\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/AES256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification module AES256 that instantiates AES with 256-bit keys, defining the types State, KeySchedule, RoundKey and the functions sub_bytes256, shift_rows256, expand_key256, aes_round256, aes_final_round256, and encryptState256 with appropriate AES-256 parameters."},{"role":"assistant","content":"```cryptol\nmodule AES256 where\n\nimport `Common::AES\nimport `Common::AES as AES\nimport AES as AES\n\ntype State         = AES::State 2\ntype KeySchedule   = AES::KeySchedule 2\ntype RoundKey      = AES::RoundKey 2\n\nsub_bytes256 : State -> State\nsub_bytes256 = SubBytes`{2}\n\nshift_rows256 : State -> State\nshift_rows256 = ShiftRows`{2}\n\nexpand_key256 : [256] -> KeySchedule\nexpand_key256 = AES::expandKey\n\naes_round256 : RoundKey -> State -> State\naes_round256 = AES::aes_round`{2}\n\naes_final_round256 : RoundKey -> State -> State\naes_final_round256 = AES::aes_final_round`{2}\n\nencryptState256 : KeySchedule -> State -> State\nencryptState256 = AES::encryptState`{2}\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/TBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the AES T-box specification, including the GF(2^8) field operations, S-box and inverse S-box arrays, and the msgToState\/stateToMsg conversions for 128-bit AES state, matching the given types and constants."},{"role":"assistant","content":"```cryptol\ntype Nb         = 4\ntype State      = [4][Nb]GF28\ntype RoundKey   = State\n\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\ntype GF28        = [8]\n\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\ngf28Mult : GF28 -> GF28 -> GF28\ngf28Mult x y  = pmod (pmult x y) irreducible\n\ngf28Pow : GF28 -> [8] -> GF28\ngf28Pow n k = pow k\n  where   sq x  = gf28Mult x x\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult n (sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow x 254\n\ngf28DotProduct : {n} (fin n) => [n]GF28 -> [n]GF28 -> GF28\ngf28DotProduct xs ys = gf28Add [ gf28Mult x y | x <- xs | y <- ys ]\n\ngf28VectorMult : {n, m} (fin n) => [n]GF28 -> [m][n]GF28 -> [m]GF28\ngf28VectorMult v ms = [ gf28DotProduct v m | m <- ms ]\n\ngf28MatrixMult : {n, m, k} (fin m) => [n][m]GF28 -> [m][k]GF28 -> [n][k]GF28\ngf28MatrixMult xss yss = [ gf28VectorMult xs yss' | xs <- xss ]\n   where yss' = transpose yss\n\nsbox : [256]GF28\nsbox = [\n 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n 0x54, 0xbb, 0x16]\n\nsbox_inverse : [256] GF28\nsbox_inverse = [\n    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,\n    0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,\n    0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,\n    0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,\n    0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,\n    0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,\n    0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,\n    0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,\n    0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,\n    0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,\n    0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,\n    0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,\n    0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,\n    0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,\n    0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,\n    0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,\n    0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D]\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/cryptol-specs\/Common\/AES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol module Common::AES that implements AES-128\/192\/256 encryption over GF(2^8), including key expansion, SubBytes, ShiftRows, MixColumns, AddRoundKey, aesEncrypt, aesEncryptWithSchedule, and related types (State, RoundKey, KeySchedule) exactly as specified, but without providing any proofs."},{"role":"assistant","content":"```cryptol\nmodule Common::AES where\n\nparameter\n  type Mode : #\n  type constraint (2 >= Mode)\n\ntype AESKeySize  = 32 * Nk\n\naesEncrypt : [AESKeySize] -> [128] -> [128]\naesEncrypt key pt = aesEncryptWithSchedule (ExpandKey key) pt\n\naes_round : RoundKey -> State -> State\naes_round k s =\n  k ^ transpose\n        [ t 0 ^ t 1 ^ t 2 ^ t 3 where t n = tbox n (s @ n @ (j + n))\n        | j <- [ 0 .. 3 ]\n        ]\n\ntbox : [2] -> GF28 -> [4]GF28\ntbox n x = (T0_table @ x) >>> n\n\nT0_table : [256][4] GF28\nT0_table = [ [gf28Mult (2, s), s, s, gf28Mult (3, s) ] | s <- sbox ]\n\naes_final_round : RoundKey -> State -> State\naes_final_round k s = AESFinalRound (k,s)\n\nencryptState : KeySchedule -> State -> State\nencryptState (kInit, ks, kFinal) pt = aes_final_round kFinal (rounds ! 0)\n  where\n  state0 = AddRoundKey (kInit, pt)\n  rounds = [state0] # [ aes_round rk s | rk <- ks | s <- rounds ]\n\naesEncryptWithSchedule : KeySchedule -> [128] -> [128]\naesEncryptWithSchedule ks pt = stateToMsg (encryptState ks (msgToState pt))\n\ntype Nk = 4 + 2 * Mode\ntype Nb = 4\ntype Nr = 6 + Nk\n\ntype GF28        = [8]\ntype State       = [4][Nb]GF28\ntype RoundKey    = State\ntype KeySchedule = (RoundKey, [Nr-1]RoundKey, RoundKey)\n\ngf28Add : {n} (fin n) => [n]GF28 -> GF28\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\nirreducible = <| x^^8 + x^^4 + x^^3 + x + 1 |>\n\ngf28Mult : (GF28, GF28) -> GF28\ngf28Mult (x, y) = pmod(pmult x y) irreducible\n\ngf28Pow : (GF28, [8]) -> GF28\ngf28Pow (n, k) = pow k\n  where   sq x  = gf28Mult (x, x)\n          odd x = x ! 0\n          pow i = if i == 0 then 1\n                  else if odd i\n                       then gf28Mult(n, sq (pow (i >> 1)))\n                       else sq (pow (i >> 1))\n\ngf28Inverse : GF28 -> GF28\ngf28Inverse x = gf28Pow (x, 254)\n\ngf28DotProduct : {n} (fin n) => ([n]GF28, [n]GF28) -> GF28\ngf28DotProduct (xs, ys) = gf28Add [ gf28Mult (x, y) | x <- xs\n                                                    | y <- ys ]\ngf28VectorMult : {n, m} (fin n) => ([n]GF28, [m][n]GF28) -> [m]GF28\ngf28VectorMult (v, ms) = [ gf28DotProduct(v, m) | m <- ms ]\n\ngf28MatrixMult : {n, m, k} (fin m) => ([n][m]GF28, [m][k]GF28) -> [n][k]GF28\ngf28MatrixMult (xss, yss) = [ gf28VectorMult(xs, yss') | xs <- xss ]\n   where yss' = transpose yss\n\nxformByte : GF28 -> GF28\nxformByte b = gf28Add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n   where c = 0x63\n\nxformByte' : GF28 -> GF28\nxformByte' b = gf28Add [(b >>> 2), (b >>> 5), (b >>> 7), d] where d = 0x05\nSubByte : GF28 -> GF28\nSubByte b = xformByte (gf28Inverse b)\n\nSubByte' : GF28 -> GF28\nSubByte' b = sbox@b\n\nSubBytes : State -> State\nSubBytes state = [ [ SubByte' b | b <- row ] | row <- state ]\n\n\/\/ The ShiftRows transform and its inverse\nShiftRows : State -> State\nShiftRows state = [ row <<< shiftAmount | row <- state\n                                        | shiftAmount : [2] <- [0 .. 3]\n                  ]\n\n\/\/ The MixColumns transform and its inverse\nMixColumns : State -> State\nMixColumns state = gf28MatrixMult (m, state)\n    where m = [[2, 3, 1, 1],\n               [1, 2, 3, 1],\n               [1, 1, 2, 3],\n               [3, 1, 1, 2]]\n\n\/\/ The AddRoundKey transform\nAddRoundKey : (RoundKey, State) -> State\nAddRoundKey (rk, s) = rk ^ s\n\n\/\/ Key expansion\nRcon : [8] -> [4]GF28\nRcon i = [(gf28Pow (<| x |>, i-1)), 0, 0, 0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord bs = [ SubByte' b | b <- bs ]\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nNextWord : ([8],[4][8],[4][8]) -> [4][8]\nNextWord(i, prev, old) = old ^ mask\n   where mask = if i % nk == 0\n                then SubWord(RotWord(prev)) ^ Rcon (i \/ `Nk)\n                else if (nk > 6) && (i % nk == 4)\n                     then SubWord(prev)\n                     else prev\n\n         nk = `Nk : [8]\n\nExpandKeyForever : [Nk][4][8] -> [inf]RoundKey\nExpandKeyForever seed = [ transpose g | g <- groupBy`{4} (keyWS seed) ]\n\nkeyWS : [Nk][4][8] -> [inf][4][8]\nkeyWS seed    = xs\n     where xs = seed # [ NextWord(i, prev, old)\n                       | i    <- [ `Nk ... ]\n                       | prev <- drop`{Nk-1} xs\n                       | old  <- xs\n                       ]\n\nExpandKey : [AESKeySize] -> KeySchedule\nExpandKey key = ( keys @ 0\n                , keys @@ ([1 .. (Nr - 1)] : [_][8])\n                , keys @ (`Nr : [8])\n                )\n  where   seed : [Nk][4][8]\n          seed = split (split key)\n          keys = ExpandKeyForever seed\n\nfromKS : KeySchedule -> [Nr+1][4][32]\nfromKS (f, ms, l) = [ formKeyWords (transpose k) | k <- [f] # ms # [l] ]\n    where formKeyWords bbs = [ join bs | bs <- bbs ]\n\nAESRound : (RoundKey, State) -> State\nAESRound (rk, s) = AddRoundKey (rk, MixColumns (ShiftRows (SubBytes s)))\n\nAESFinalRound : (RoundKey, State) -> State\nAESFinalRound (rk, s) = AddRoundKey (rk, ShiftRows (SubBytes s))\n\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\nsbox : [256]GF28\nsbox = [\n 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67,\n 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59,\n 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7,\n 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05,\n 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83,\n 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29,\n 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa,\n 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c,\n 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc,\n 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19,\n 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee,\n 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,\n 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4,\n 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6,\n 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70,\n 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e,\n 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1,\n 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0,\n 0x54, 0xbb, 0x16]\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/cryptol\/Asm128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the AES-GCM-SIV-related helper functions and properties in module GenAsm128, including Polyval_Horner_* and Polyval_HTable_* definitions, AES_128_ENC_x4_def, AES_KS_ENC_x1_def*, ENC_MSG_def, AES_GMC_SIV_Encrypt_*_def, and property polyProp."},{"role":"assistant","content":"```cryptol\nmodule GenAsm128 where\n\nimport X86\nimport AES128\nimport AES128_GCM_SIV\nimport Sizes\n\ndot256 : [256] -> [256] -> [256]\ndot256 (_ # res) (_ # h) = 0 # dot res h\n\ndot512 : [512] -> [512] -> [512]\ndot512 (_ # res) (_ # h) = 0 # dot res h\n\nPolyval_Horner_gen_def :\n  {n} fin n => [1][128] -> [n][8] -> [1][128] -> [1][128]\nPolyval_Horner_gen_def [h] i [t] = [ polyvalFrom h (leLoadBlocks i) t ]\n\nPolyval_Horner_AAD_def : [1][128] -> [AAD_Size][8] -> [1][128] -> [1][128]\nPolyval_Horner_AAD_def = Polyval_Horner_gen_def\n\nPolyval_Horner_MSG_def : [1][128] -> [MSG_Size][8] -> [1][128] -> [1][128]\nPolyval_Horner_MSG_def = Polyval_Horner_gen_def\n\nPolyval_Horner_BLK_def : [1][128] -> [16][8] -> [1][128] -> [1][128]\nPolyval_Horner_BLK_def = Polyval_Horner_gen_def\n\nPolyval_Horner_AAD_MSG_def :\n  [16][8] -> [AAD_Size][8] -> [MSG_Size][8] -> [2][64] -> [16][8] -> [1][128]\nPolyval_Horner_AAD_MSG_def h aad pt lblk t =\n  [ polyvalFrom (leLoad h) work (leLoad t) ]\n  where\n  work = leLoadBlocks aad\n       # leLoadBlocks pt\n       # leLoadBlocks [ b | qword <- lblk, b <- leStore qword ]\n\nINIT_Htable_def: [1][128] -> [8][128]\nINIT_Htable_def [h] = INIT_Htable h\n\nPolyval_HTable_gen_def :\n  {n} (fin n) => [8][128] -> [n][8] -> [1][128] -> [1][128]\nPolyval_HTable_gen_def tbl data [t] =\n  [ polyvalHtableNH tbl (leLoadBlocks data) t ]\n\nPolyval_HTable_AAD_def : [8][128] -> [AAD_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_AAD_def = Polyval_HTable_gen_def\n\nPolyval_HTable_MSG_def : [8][128] -> [MSG_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_MSG_def = Polyval_HTable_gen_def\n\nPolyval_HTable_BLK_def : [8][128] -> [16][8] -> [1][128] -> [1][128]\nPolyval_HTable_BLK_def = Polyval_HTable_gen_def\n\nPolyval_HTable_call_AAD_def : [8][128] -> [AAD_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_call_AAD_def hs = Polyval_Horner_AAD_def (take hs)\n\nPolyval_HTable_call_MSG_def : [8][128] -> [MSG_Size][8] -> [1][128] -> [1][128]\nPolyval_HTable_call_MSG_def hs = Polyval_Horner_MSG_def (take hs)\n\nPolyval_HTable_call_BLK_def : [8][128] -> [16][8] -> [1][128] -> [1][128]\nPolyval_HTable_call_BLK_def hs = Polyval_Horner_BLK_def (take hs)\n\npolyProp :\n  {x,y} (fin x, fin y) => [128] -> [x][128] -> [y][128] -> [128] -> Bool\npolyProp h xs ys t =\n  polyvalFrom h ys (polyvalFrom h xs t) == polyvalFrom h (xs # ys) t\n\nAES_128_ENC_x4_def : [16][8] -> [11][128] -> [4][128]\nAES_128_ENC_x4_def iv' keys = [ aesWithKeys keys (iv # i) | i <- [ 0 .. 3 ] ]\n  where\n  _ # (iv : [96]) = leLoad iv'\n\nAES_KS_ENC_x1_def1 : [16][8]  -> [11][128]\nAES_KS_ENC_x1_def1 ikey =\n  aesKeyToBits (ExpandKey (beLoad ikey))\n\nAES_KS_ENC_x1_def2 : [11][128] -> [16][8] -> [1][128]\nAES_KS_ENC_x1_def2 keys pt = [ aesWithKeys keys (leLoad pt) ]\n\nENC_MSG_def :\n  [11][128] -> [16][8] -> [MSG_Size][8] -> [MSG_Size][8]\nENC_MSG_def keys tag pt =\n  leStoreBlocks (counter_mode K2 (0b1 # tUpper, tLower) M)\n  where\n  K2 = aesKeysFromBits keys\n  M  = leLoadBlocks pt\n  _ # tUpper # tLower = leLoad tag\n\nAES_GMC_SIV_Encrypt_pair :\n  [11][128] -> [12][8] -> [AAD_Size][8] -> [MSG_Size][8] ->\n                                                    ([8 * MSG_Size], [128])\nAES_GMC_SIV_Encrypt_pair keys iv aad pt =\n  gcm_siv_plus ks nonce (beLoad aad) (beLoad pt)\n  where\n  ks    = derive_key_expanded (aesKeysFromBits keys) nonce\n  nonce = leLoad iv\n\nAES_GMC_SIV_Encrypt_TAG_def :\n  [11][128] -> [12][8] -> [AAD_Size][8] -> [MSG_Size][8] -> [1][128]\nAES_GMC_SIV_Encrypt_TAG_def keys iv add pt = [ tag ]\n  where (_,tag) = AES_GMC_SIV_Encrypt_pair keys iv add pt\n\nAES_GMC_SIV_Encrypt_CT_def :\n  [11][128] -> [12][8] -> [AAD_Size][8] -> [MSG_Size][8] -> [MSG_Size][8]\nAES_GMC_SIV_Encrypt_CT_def keys iv add pt = beStore ct\n  where (ct,_) = AES_GMC_SIV_Encrypt_pair keys iv add pt\n\naesWithKeys : [11][128] -> [128] -> [128]\naesWithKeys ks pt = aes (aesKeysFromBits ks) pt\n\naesKeysFromBits : [11][128] -> KeySchedule\naesKeysFromBits ks = (k1,kRest,kLast)\n  where [k1] # kRest # [kLast] = [ aesStateFromBits m | m <- ks ]\n\naesKeyToBits : KeySchedule -> [11][128]\naesKeyToBits (k1,kRest,kLast) =\n  [ aesStateToBits k1 ] #\n  [ aesStateToBits x | x <- kRest ] #\n  [ aesStateToBits kLast ]\n\nleLoadBlocks : {n} (fin n) => [n][8] -> [n \/^ 16][128]\nleLoadBlocks bytes = leLoadArray (bytes # zero)\n\nleStoreBlocks : {n} (fin n) => [n \/^ 16][128] -> [n][8]\nleStoreBlocks arr = take (leStoreArray arr)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/cryptol\/AES128_GCM_SIV.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification of AES-128-GCM-SIV authenticated encryption, including the function `aes_gcm_siv : {n} ((36 + 8) >= width n) => { key:[128], nonce:[96], aad:[8 * AAD_Size], msg:[n] } -> [n + 128]` and its supporting functions and types as in the described construction."},{"role":"assistant","content":"```cryptol\nmodule AES128_GCM_SIV where\n\nimport AES128 as AES\nimport Sizes\n\ntype AAD  = 8 * AAD_Size\n\ntype K  = 128\ntype KS = AES::KeySchedule\n\naes_gcm_siv :\n  {n} ((36 + 8) >= width n) =>\n      { key   : [K]\n      , nonce : [96]\n      , aad   : [AAD]\n      , msg   : [n]\n      } -> [n + 128]\naes_gcm_siv input = c # byteSwap t\n  where\n  (c,t) = gcm_siv_plus (derive_key k' n') n' input.aad input.msg\n  k'    = byteSwap input.key\n  n'    = byteSwap input.nonce\n\naes : KS -> [128] -> [128]\naes ks v = byteSwap (AES::aesEncryptWithSchedule ks (byteSwap v))\n\nexpandKey1 : [K] -> KS\nexpandKey1 k = AES::ExpandKey (byteSwap k)\n\n\/** See Figure 2 in Section 4 *\/\nderive_key : [K] -> [96] -> ([128], KS)\nderive_key K N = derive_key_expanded (expandKey1 1) N\n\n\/** See Figure 2 in Section 4 *\/\nderive_key_expanded : KS -> [96] -> ([128], KS)\nderive_key_expanded ks N = (mkKey parts1, expandKey1 (mkKey parts2))\n  where\n  parts1 # parts2 = [ drop (aes ks (N # i)) | i <- take [ 0 ... ]  ]\n\n  mkKey : {n} (fin n) => [n][64] -> [64 * n]\n  mkKey xs = join (reverse xs)\n\n\/** See Figure 1 in Section 3 *\/\ngcm_siv_plus :\n  {n} (64 >= width n) => ([128], KS) -> [96] -> [AAD] -> [n] -> ([n],[128])\ngcm_siv_plus (K1,K2) N AAD MSG = (unblockify Cs,TAG)\n  where\n\n  TAG     = aes K2 (0b0 # drop (T ^ (0 # N)))\n  T       = polyvalFrom K1 (A # M # [msg_len # aad_len]) 0\n  A       = blockify AAD\n  M       = blockify MSG\n  aad_len = `AAD : [64]\n  msg_len = `n   : [64]\n\n  _ # tUpper # tLower = TAG\n\n  Cs = counter_mode K2 (0b1 # tUpper, tLower) M\n\ncounter_mode : {n} KS -> ([96],[32]) -> [n][128] -> [n][128]\ncounter_mode K2 (tUpper,tLower) M =\n            [ aes K2 (tUpper # lower32 i) ^ m | m <- M | i <- [ 0 ... ] ]\n  where\n  lower32 i = tLower + i\n\n\/** See Section 2.2 *\/\npolyvalFrom : {n} (fin n) => [128] -> [n][128] -> [128] -> [128]\npolyvalFrom H Xs start = psums ! 0\n  where psums = [start] # [ dot (s ^ x) H | s <- psums | x <- Xs ]\n\n\/\/1 is not the identity for dot forcing it in next function instead\npolyvalFromNH : {n, hs} (fin n, fin hs, hs >=n) => [hs][128] -> [n][128] -> [128] -> [128]\npolyvalFromNH Hs Xs start = (sums ! 0) ^ (dot (([1] # Hs) @ (`n : [width n])) start)\n  where sums = [zero] # [ (dot X H) ^ sum'\n                        | sum' <- sums\n                        | X <- reverse Xs\n                        | H <- Hs ]\n\npolyvalHtableNH :\n  {n, hs} (fin n, fin hs, hs >=1) => [hs][128] -> [n][128] -> [128] -> [128]\npolyvalHtableNH Hs Xs start  = result\n  where sums = [start]\n             # [ polyvalFromNH Hs Xchunk sum'\n               | sum'   <- sums\n               | Xchunk <- split (take Xs): [n\/hs][hs][128]\n               ]\n        type W = n % hs\n        remainder = drop Xs : [W][128]\n        result =\n          if `W == (0 : [width (n % hs)]) then\n            sums ! 0\n          else\n            polyvalFromNH Hs remainder (sums!0)\n\npht : {a,size} (fin a,fin size,size>=2) => [128] -> [a][128] -> [128] -> Bit\npht H Xs start =\n  polyvalHtableNH (INIT_Htable`{size} H) Xs start == polyvalFrom H Xs start\n\ndot : [128] -> [128] -> [128]\ndot x y = mult x (mult y x_neg_128)\n  where x_neg_128 = <| 1 + x^^114 + x^^121 + x^^124 + x^^127 |>\n        \/\/ This is x^(-128)\n\nmult : [128] -> [128] -> [128]\nmult x y = pmod (pmult x y) irred\n  where\n  irred = <| 1 + x^^121 + x^^126 + x^^127 + x^^128 |>\n\nINIT_Htable : {n} (fin n, n>=2) => [128] -> [n][128]\nINIT_Htable H = take hs\n  where\n  hs = [H] # [ dot hn H\n                | hn <- hs]\n\n\/*polyval_Htable : {n} (fin n, n>=1) => [128] -> [n][128] -> [128]\npolyval_Htable H X = polyvalHtableNH`{hs=8} htable X\n  where\n    htable = INIT_Htable H\n\n\/\/ -----------------------------------------------------------------------------\n\nprop_poly : {a} (a >= 1, fin a) => [128] -> [a][128] -> Bit\nprop_poly H X = polyval_Htable H X == polyvalFrom H X zero\n*\/\nblockify : {n} (fin n) => [n] -> [n \/^ 128][128]\nblockify x = [ byteSwap b | b <- split (x # zero) ]\n\nunblockify : {n} (fin n) => [n \/^ 128][128] -> [n]\nunblockify xs = take (join [ byteSwap b | b <- xs ])\n\n\/\/ The spec uses byte-oriented little-endian representations.\n\/\/ This function changes back and forth.\nbyteSwap : {n} (fin n) => [8 * n] -> [8 * n]\nbyteSwap xs = join (reverse (split`{each=8} xs))\n\npolnhest1 = polyvalHtableNH`{hs=8,n=1}\n              ([0x551d5202e5be771d5964fbbd1dac89db]#zero)\n              \/\/(INIT_Htable 0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e)\n              [0x189308235800d2810a80a422032144fd]\n              (0x38020aa08800d28bf2fb37d447e1c479)\n\npolnhest2 = polyvalFrom\n                0x7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e\n                [0x189308235800d2810a80a422032144fd]\n                (0x38020aa08800d28bf2fb37d447e1c479)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/cryptol\/X86.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module `X86` containing AES-128 round functions (`aesenc`, `aesenclast`), carry-less multiplication (`clmul`), and little\/big-endian load\/store helpers over bitvectors and byte arrays, matching the specified types and behaviors for AES state conversions."},{"role":"assistant","content":"```cryptol\nmodule X86 where\n\nimport AES128\n\naesenc : [128] -> [128] -> [128]\naesenc pt key =\n  aesStateToBits (aes_round (aesStateFromBits key)\n                            (aesStateFromBits pt))\n\naesenclast : [128] -> [128] -> [128]\naesenclast pt key =\n  aesStateToBits (aes_final_round (aesStateFromBits key)\n                                  (aesStateFromBits pt))\n\nclmul : [64] -> [64] -> [128]\nclmul x y = 0b0 # pmult x y\n\nleStore : {n} (fin n) => [n * 8] -> [n][8]\nleStore bits = reverse (split bits)\n\nleLoad : {n} (fin n) => [n][8] -> [n*8]\nleLoad bytes = join (reverse bytes)\n\nbeLoad : {n} (fin n) => [n][8] -> [n*8]\nbeLoad bytes = join bytes\n\nbeStore : {n} (fin n) => [n*8] -> [n][8]\nbeStore bits = split bits\n\nleLoadArray : {l,w} (fin l,fin w) => [l * w][8] -> [l][w * 8]\nleLoadArray bytes = [ leLoad mem | mem <- split bytes ]\n\nleStoreArray : {l,w} (fin l,fin w) => [l][w * 8] -> [l * w][8]\nleStoreArray arr = join [ leStore a | a <- arr ]\n\naesStateFromBytes : [16][8] -> State\naesStateFromBytes xs = transpose (split xs)\n\naesStateToBytes : State -> [16][8]\naesStateToBytes s = join (transpose s)\n\naesStateFromBits : [128] -> State\naesStateFromBits xs = aesStateFromBytes (leStore xs)\n\naesStateToBits : State -> [128]\naesStateToBits s = leLoad (aesStateToBytes s)\n```"}]}
{"filename":"AES-GCM-SIV-proof\/proof\/asm\/deps\/saw-script\/intTests\/test_profiling\/dotprod.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the functions `zip`, `sum`, and `dotprod` as given, and include a property that verifies `dotprod` computes the standard dot product for any finite-length sequences of arithmetic elements."},{"role":"assistant","content":"```cryptol\nzip : {n, a} (fin n, Arith a) => (a -> a -> a) -> [n]a -> [n]a -> [n]a\nzip f xs ys = [ f x y | x <- xs | y <- ys ]\n\nsum : {n, a} (fin n, fin a) => [n][a] -> [a]\nsum xs = ys!0\n  where ys = [0] # [ x + y | x <- xs | y <- ys ]\n\ndotprod : {n, a} (fin n, fin a) => [n][a] -> [n][a] -> [a]\ndotprod xs ys = sum (zip (*) xs ys)\n```"}]}
