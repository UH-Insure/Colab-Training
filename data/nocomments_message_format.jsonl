{"filename":"cryptol\/examples\/splitAt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the following with explicit types and a verification: (1) a constant x as a 4-element sequence of 8-bit values containing 1, 2, 3, and 4 in order; (2) a constant y as the pair produced by splitting x at index 2 into two sequences, each of length 2 and element width 8; (3) constants a, b, c, and d as 8-bit values equal to the first and second elements of the first component of y, and the first and second elements of the second component of y, respectively (use zero-based indexing). Provide type signatures for x, y, a, b, c, and d that reflect these sizes. Also define a property that checks both that concatenating the two parts of y reconstructs x, and that a == 1, b == 2, c == 3, and d == 4. Do not include any implementations beyond these definitions and the property."},{"role":"assistant","content":"```cryptol\nx = [1,2,3,4] : [_][8]\n\ny = (splitAt x) : ([2][8],[2][8])\n\na = y.0 @ 0\nb = y.0 @ 1\nc = y.1 @ 0\nd = y.1 @ 1\n```"}]}
{"filename":"cryptol\/examples\/AE.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named AE that contains the following definitions and specifications: (1) A parameter section declaring abstract value types A and K, numeric types n, p, and tagAmount, with constraints that p and n are finite and n is at least tagAmount. Also declare the following module parameters with the given roles and shapes: a tweakable permutation over n-bit blocks keyed by K that consumes a record containing a nonce, an abstract state, and a 64-bit counter; a 64-bit cost increment; a block encryption transform that maps a record of one p\u00b7n-bit block and the running p\u00b7n-bit state to the next record of the same shape; a corresponding decryption transform; and a tag function that maps a key, a tweak record, and a p\u00b7n\u00b7p-length message stream to an n-bit tag. (2) Type synonyms: Node as a record of a work block and running state, WorkBlock as p\u00b7n bits, State as p\u00b7n bits, Tweak as a record of nonce [n], state A, and counter [64], Nonce as [n], and Int as [64]. (3) A function encrypt with type: for any finite m, takes a key, a nonce, an initial abstract state A, and a message of m blocks of size p\u00b7n, and returns m\u00b7(p\u00b7n) bits followed by tagAmount bits. Specify that it: splits the message into m blocks; iteratively applies the encryption transform to each block using a tweak whose counter is the running cost (starting at 1 and increased by the cost increment per block) and threading the p\u00b7n-bit state; concatenates the resulting per-block ciphertexts; derives the authentication tag by applying the tag function to the key, a tweak whose counter is one less than the final accumulated cost, and the final p\u00b7n-bit state; and returns ciphertext concatenated with the tag truncated to tagAmount bits. (4) Properties to check: output length matches the result type size; the ciphertext prefix equals the concatenation of per-block encryption results; the tag suffix equals the specified tag derivation."},{"role":"assistant","content":"```cryptol\nmodule AE where\n\nparameter\n  type A : *            type K : *            type n : #            type p : #            type tagAmount : #\n\n  type constraint (fin p, fin n, n >= tagAmount)\n\n    tweak_cipher : K -> { nonce : [n], state : A, z : [64] } -> [n] -> [n]\n\n    Cost : [64]\n\n  Enc : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Dec : K -> { nonce : [n], state : A, z : [64] }\n          -> { message : [p*n], state : [p*n] }\n          -> { message : [p*n], state : [p*n] }\n  Tag : K -> { nonce : [n], state : A, z : [64] } -> [p*n] -> [n]\n\ntype Node       = { message : WorkBlock, state : State }\n\ntype WorkBlock  = [p*n]\n\ntype State      = [p*n]  \ntype Tweak      = { nonce : Nonce, state : A, z : Int }\ntype Nonce      = [n]\n\ntype Int = [64]\n\nencrypt :\n  {m} fin m => K -> Nonce -> A -> [m * (p * n)] -> [m * (p * n) + tagAmount]\nencrypt key nonce state inputMsg = encMsg # tag\n\n  where\n  encMsg = join rest.0.message\n\n  tag = take (Tag key (tweak (1 - final.1)) final.0.state)\n\n  final = steps ! 0\n\n  steps = [ ({ message = undefined, state = zero }, 1) ] # rest\n  rest  = [ (Enc key (tweak v) { message = m, state = prev.state }, v + Cost)\n          | (prev,v) <- steps\n          | m        <- chunks\n          ]\n\n  chunks : [m] [p * n]\n  chunks = split inputMsg\n\n  tweak : Int -> Tweak\n  tweak v = { nonce = nonce, state = state, z = v }\n```"}]}
{"filename":"cryptol\/examples\/xor_cipher.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define type signatures for encrypt and decrypt parameterized by a finite size a: each takes an 8-bit key and a sequence of a 8-bit values, returning a sequence of a 8-bit values. Implement encrypt by XORing each input byte with the key elementwise, and implement decrypt identically (bytewise XOR with the same key). Define a property named roundtrip that, for all finite a, any 8-bit key, and any sequence of a 8-bit values, asserts that applying decrypt with the key to the result of encrypt with the same key yields the original input. State the fin a constraint explicitly, keep all expressions total, and use elementwise operations over the sequence without introducing padding or state."},{"role":"assistant","content":"```cryptol\nencrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\nencrypt key plaintext = [pt ^ key | pt <- plaintext ]\n\ndecrypt : {a}(fin a) => [8] -> [a][8] -> [a][8]\ndecrypt key ciphertext = [ct ^ key | ct <- ciphertext ]\n\nproperty roundtrip k ip = decrypt k (encrypt k ip) == ip\n```"}]}
{"filename":"cryptol\/examples\/zero_weird.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) a polymorphic function named x with a single type parameter and no constraints, taking one argument of that type and returning a 16-bit sequence whose value is all zeros; implement x so it ignores its input. (2) a property named xprop that universally quantifies over the input and asserts that applying x to any value yields the 16-bit zero value. (3) a function named y that takes two arguments, the first a 12-bit sequence and the second a 4-bit sequence, and returns a 17-bit sequence whose value is all zeros; implement y so it ignores both inputs. (4) a property named yprop that universally quantifies over both inputs and asserts that applying y to any valid pair yields the 17-bit zero value. (5) two constants named t1 and t2 that are example applications: t1 is x applied to a literal argument, producing the 16-bit zero result; t2 is y applied to two literal arguments, producing the 17-bit zero result. Include precise type signatures for x and y, and ensure the properties are written using the Cryptol property keyword so they can be checked by a solver."},{"role":"assistant","content":"```cryptol\nx : {a}() => a -> [16]\nx v = zero v \n\nproperty xprop v = x v == 0\n\ny : [12] -> [4] -> [17]\ny a b = zero a b\n\nproperty yprop v w = y v w == 0\n\nt1 = x 13\nt2 = y 2 3\n```"}]}
{"filename":"cryptol\/examples\/builtin_lifting.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that demonstrates built-in lifting across sequences, tuples, and records by defining the following and proving the listed properties. Define x and y as two-bit words whose most-significant bit patterns are 10 and 01, respectively. Provide properties: p1 asserts x equals the two-bit numeral 2; p2 asserts x+y equals the two-bit numeral 3; p3 asserts x+y equals the two-bit pattern with both bits set. Define xx and yy as singleton sequences containing x and y, respectively; p4 asserts their elementwise sum is the singleton containing 3; p5 asserts the bitwise complement of xx equals yy. Define infinite arithmetic sequences xinf and yinf of two-bit words starting at 2 and 3, respectively; p6 asserts the first element of their pointwise sum equals the two-bit numeral 1; p7 asserts the first element of the bitwise complement of xinf equals the two-bit numeral 1. Define a record xrec with fields x and y, both two-bit words equal to 2, with an explicit record type; p8 asserts xrec added to itself three times equals xrec (fieldwise modular addition). Define a tuple whose first two components are the two-bit numeral 2 and whose third component is xrec; p9 asserts adding this tuple to itself three times yields the same tuple (componentwise lifting). Finally, p10 asserts that bitwise complement distributes over a record whose first field is a tuple of a 1-bit and a 2-bit word and whose second field is a three-element sequence of three-bit words, and that the complemented record matches the elementwise complements with explicit width annotations. Use property declarations for p1\u2013p10 and fully annotate widths and shapes to disambiguate types."},{"role":"assistant","content":"```cryptol\nx = [True,False]\ny = [False,True]\n\nproperty p1 = x == (2 : [2])\n\nproperty p2 = x + y == 3\nproperty p3 = x + y == [True,True]\n\nxx = [[True,False]]\nyy = [[False,True]]\n\nproperty p4 = xx + yy == [3]\n\nproperty p5 = ~ xx == yy\n\nxinf = [2 ... ]\nyinf = [3 ... ]\n\nproperty p6 = (xinf + yinf) @ (0 : [0]) == (1 : [2])\n\nproperty p7 = (~ xinf) @ (0 : [0]) == (1 : [2])\n\nxrec = { x = 2 : [2], y = 2 : [2] } : {x : [2], y : [2]}\n\nproperty p8 = xrec + xrec + xrec == xrec\n\nproperty p9 = (2,2,xrec) + (2,2,xrec) + (2,2,xrec) == (2:[2],2:[2],xrec) \n\nproperty p10 = (~ { x = (1,2), y = [3,4,5] }) == {x = (0:[1],1:[2]), y = [4, 3, 2] : [3][3] }\n```"}]}
{"filename":"cryptol\/examples\/inflist.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares four sequence constants and four properties. Define: (1) an infinite sequence a that repeats the value 1; (2) an infinite arithmetic sequence b determined by the first two elements 1 then 2 (unit step); (3) a finite inclusive range c from 1 to 5; and (4) a finite arithmetic range d that starts at 1, has next element 3, and ends at 9. Use appropriate numeric types for these sequences (0-based indexing is assumed). Then define properties t1, t2, t3, and t4 asserting, respectively, that the element at index 3 of a equals 1, the element at index 3 of b equals 1, the element at index 3 of c equals 4, and the element at index 3 of d equals 4. Ensure the properties are expressed as boolean equalities suitable for solver checking."},{"role":"assistant","content":"```cryptol\na = [1 ... ]\nb = [1,2 ... ]\nc = [1 .. 5]\nd = [1,3 .. 9]\n\nproperty t1 = a @ 3 == 1\nproperty t2 = b @ 3 == 1\nproperty t3 = c @ 3 == 4\nproperty t4 = d @ 3 == 4\n```"}]}
{"filename":"cryptol\/examples\/Karatsuba.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Karatsuba that contains the following definitions: kmult, make_atleast, splitmult, splitmult_correct_tiny, splitmult_correct_small, splitmult_correct_medium, splitmult_correct_large, and splitmult_correct_huge. Specify kmult as a polymorphic function over size parameters limb and n with constraints fin limb, fin n, limb >= 6, n >= 1; it takes two n-bit sequences and returns their 2n-bit product. It must use a conditional: when n is at least limb, first widen both operands to be at least limb bits by prefixing zeros and then call splitmult; otherwise, perform a direct multiplication on zero-extended operands. Specify make_atleast as a polymorphic helper over sizes n, m and element type a with constraints fin n, fin m, Zero a; it takes an m-length sequence and returns a max(n,m)-length sequence by prefixing zeros. Specify splitmult as Karatsuba multiplication over sizes limb and n with constraints fin limb, fin n, limb >= 6, n >= 6; split each operand at hi = n\/2 (low = n - hi), recursively compute products of high and low halves, compute the cross term via sum-of-halves multiplication minus the partial products, and recombine by appropriate zero-padding and concatenation to yield a 2n-bit result. Include property declarations asserting that, for operand widths 9, 11, 17, and 59 with limb 7, and width 511 with limb 63, the result of splitmult equals the product of the zero-extended operands. Provide precise type signatures with all size constraints and quantify variables as needed."},{"role":"assistant","content":"```cryptol\nmodule Karatsuba where\n\nkmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 1) => [n] -> [n] -> [2*n]\n\nkmult x y =\n if `n >= (`limb : [max (width limb) (width n)]) then\n   take (splitmult`{limb} (make_atleast`{limb} x) (make_atleast`{limb} y))\n else\n   (zero#x)*(zero#y)\n\nmake_atleast : {n, m, a} (fin n, fin m, Zero a) => [m]a -> [max n m]a\nmake_atleast x = zero#x\n\nsplitmult : {limb,n} (fin n, fin limb, limb >= 6, n >= 6)\n         => [n] -> [n] -> [2*n]\n\nsplitmult x y = (ac # bd) + (zero # ad_bc # (zero:[low]))\n  where\n   type hi  = n\/2\n   type low = n - hi\n\n   (a,b) = splitAt`{hi} x\n   (c,d) = splitAt`{hi} y\n\n   ac : [2*hi]\n   ac = kmult`{limb,hi} a c\n\n   bd : [2*low]\n   bd = kmult`{limb,low} b d\n\n   a_b = (zext a) + (zext b)\n   c_d = (zext c) + (zext d)\n\n   ad_bc : [2*(low+1)]\n   ad_bc = (kmult`{limb,low+1} a_b c_d) - (zext ac) - (zext bd)\n\nproperty splitmult_correct_tiny (x:[9]) (y:[9]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_small (x:[11]) (y:[11]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_medium(x:[17]) (y:[17]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_large (x:[59]) (y:[59]) =\n  zext x * zext y == splitmult`{limb=7} x y\n\nproperty splitmult_correct_huge (x:[511]) (y:[511]) =\n  zext x * zext y == splitmult`{limb=63} x y\n```"}]}
{"filename":"cryptol\/examples\/comp.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) a constant x with an explicit type signature as a finite sequence of 4-tuples of fixed-width bitvectors, where each field\u2019s width is the minimal width sufficient for the values it ranges over; construct x using a parallel list comprehension where the left side enumerates all pairs from two finite ranges, the right side enumerates all pairs from two other finite ranges, the two sides are zipped elementwise (length equals the minimum of the two sides), and within each side the rightmost generator varies fastest; (2) properties t1, t2, and t3 that assert that the first, third, and fourth elements of x, respectively, equal the tuples produced by this construction at those positions; (3) a constant y built by a parallel comprehension where the left side enumerates all pairs from two finite ranges and the right side is an increasing arithmetic progression, with the zipped result truncated to the left side; ensure the third component of the tuples in y uses a small fixed width so its values wrap modulo its word size; and (4) property t4 that asserts that the fourth element of y matches the tuple produced at that position, including the wrapped third component. Provide any necessary type signatures and constraints, and ensure tuple fields are not implicitly widened."},{"role":"assistant","content":"```cryptol\nx : [_]([2],[3],[3],[4])\nx = [(a,b,c,d) | a <- [1,2], b <- [3,4] | c <- [5,6], d <- [7,8,9] ]\n\nproperty t1 = x @ 0 == (1,3,5,7)\nproperty t2 = x @ 2 == (2,3,5,9)\nproperty t3 = x @ 3 == (2,4,6,7)\n\ny = [(a,b,c) | a <- [1,2,3], b <- [1,2] | c <- [1 ... ] ]\n\nproperty t4 = y @ 3 == (2,2,0)\n```"}]}
{"filename":"cryptol\/examples\/mini.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that reproduces the following definitions and types: (1) a function named id with type 32-bit word to 32-bit word, implemented by a helper recursive function that returns zero when given zero and otherwise returns one plus its result on the predecessor, using modular 32-bit arithmetic; (2) an infinite increasing stream of 8-bit words starting at one; (3) a record named rc with two 8-bit fields x and y set to specific literals, and a constant that equals the x field; (4) a 4-tuple of four 8-bit literals and a constant that equals its third element; (5) a constant defined via a local binding to an 8-bit literal; (6) a polymorphic function named gf28Add with a size parameter n and a fin n constraint that takes a sequence of n 8-bit words and returns an 8-bit word computed as the head of a running XOR prefix-sum stream that begins with zero and is formed by zipping the input with the previously computed prefix values; also define a constant produced by applying this function to a two-element 8-bit sequence; (7) a function named sum with type from a sequence of 8-bit words to a sequence of 8-bit words that zips its input with the fixed sequence [1,2,3,4] and returns their elementwise 8-bit sums. Provide explicit type signatures for id, gf28Add (with its constraint), and sum, and ensure all literals and field\/tuple selections match these behaviors. Do not include proofs; just the definitions with correct typing and semantics."},{"role":"assistant","content":"```cryptol\nid : [32] -> [32]\nid x = rec x\n  where rec k = if (k == 0) then 0 else 1 + rec (k + (-1))\n\ninflist = [1 ... ] : [_][8]\n\nrc = {x = 3 : [8], y = 5 : [8]}\n\nmy_true = rc.x\n\ntup = (1 : [8], 2 : [8], 3 : [8], 4 : [8])\n\nmy_3 = tup.2\n\nsup = y where y = 3 : [8]\n\ngf28Add : {n} (fin n) => [n][8] -> [8]\ngf28Add ps = sums ! 0\n  where sums = [zero] # [  p ^ s | p <- ps | s <- sums ]\n\ngex = gf28Add [1,2]\n\nsum : [_][8] -> [_][8]\nsum x = rec\n  where rec = [ p + q | p <- x | q <- [1,2,3,4] ]\n```"}]}
{"filename":"cryptol\/examples\/Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Test that imports Cipher and contains the following definitions: evktest, evttest, ekatest, dvktest, dvttest, dkatest. For each function, provide a type signature quantified over size variables ks, bs, n with the constraint that bs is finite. Each returns a sequence of length n of pairs (a bs-bit value and a Bit flag). The Bit flag indicates whether the computed result equals the provided expected value. Specify inputs and behavior precisely: (1) evktest takes a cipher instance, a length\u2011n sequence of (key: ks bits, expected ciphertext: bs bits) pairs, and a fixed plaintext (bs bits); for each pair, encrypt the fixed plaintext under the key and pair the produced ciphertext with its equality against the expected ciphertext. (2) evttest takes a cipher instance, a fixed key (ks bits), and a length\u2011n sequence of (plaintext: bs bits, expected ciphertext: bs bits) pairs; for each pair, encrypt the plaintext under the fixed key and compare to the expected ciphertext. (3) ekatest takes a cipher instance and a length\u2011n sequence of (key: ks bits, plaintext: bs bits, expected ciphertext: bs bits) triples; for each triple, encrypt and compare to the expected ciphertext. (4) dvktest takes a cipher instance, a length\u2011n sequence of (key: ks bits, ciphertext: bs bits) pairs, and a fixed plaintext (bs bits); for each pair, decrypt the ciphertext under the key and compare to the fixed plaintext. (5) dvttest takes a cipher instance, a fixed key (ks bits), and a length\u2011n sequence of (plaintext: bs bits, ciphertext: bs bits) pairs; for each pair, decrypt the ciphertext under the fixed key and compare to the plaintext. (6) dkatest takes a cipher instance and a length\u2011n sequence of (key: ks bits, plaintext: bs bits, ciphertext: bs bits) triples; for each triple, decrypt and compare to the plaintext."},{"role":"assistant","content":"```cryptol\nmodule Test where\nimport Cipher\n\nevktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\nevktest (cipher, vkeysCTs, PT) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, CT) <- vkeysCTs ]\n\nevttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\nevttest (cipher, Key, vtextPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (PT, CT) <- vtextPCTs ]\n\nekatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\nekatest (cipher, kaKPCTs) =\n    [ (CT', CT' == CT) where CT' = cipher.encrypt Key PT\n    | (Key, PT, CT) <- kaKPCTs ]\n\ndvktest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs]), [bs]) -> [n]([bs], Bit)\ndvktest (cipher, vkeysCTs, PT) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, CT) <- vkeysCTs ]\n\ndvttest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [ks], [n]([bs],[bs])) -> [n]([bs], Bit)\ndvttest (cipher, Key, vtextPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (PT, CT) <- vtextPCTs ]\n\ndkatest : {ks, bs, n} (fin bs)\n       => (Cipher ks bs, [n]([ks],[bs],[bs])) -> [n]([bs], Bit)\ndkatest (cipher, kaKPCTs) =\n    [ (PT', PT' == PT) where PT' = cipher.decrypt Key CT\n    | (Key, PT, CT) <- kaKPCTs ]\n```"}]}
{"filename":"cryptol\/examples\/builtins.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define constants t, f, times, div, mod, exp, lgtest, p, m, neg, and comp, each explicitly typed as an 8-bit sequence. Specify: t as the value chosen by a conditional with a true condition selecting 5; f as the value from a conditional with a false condition selecting 5 over 3; times as the product of 5, 1, 2, and 3; div as 30 divided successively by 1, then 2, then 3 using integer division; mod as 205 modulo 10; exp as 2 raised to the 7th power using the integer exponentiation operator; lgtest as the base-2 logarithm (integer result) of 128 using the built-in log2 function; p as the sum of 3 and 2; m as 8 minus 3; neg as the arithmetic double negation of 5; comp as the bitwise complement of 250 evaluated within 8-bit width. Ensure all arithmetic and bitwise operations are performed in the 8-bit domain and include type annotations for each constant."},{"role":"assistant","content":"```cryptol\nt : [8]\nt = if True then 5 else 4 \nf : [8]\nf = if False then 3 else 5 \ntimes : [8]\ntimes = 5 * 1 * 2 * 3 \ndiv : [8]\ndiv = (((30\/1)\/2)\/3) \nmod : [8]\nmod = 205%10 \nexp : [8]\nexp = 2^^7 \nlgtest : [8]\nlgtest = lg2 128 \np : [8]\np = 3+2 \nm : [8]\nm = 8-3 \nneg : [8]\nneg = -(-5) \ncomp : [8]\ncomp = ~250\n```"}]}
{"filename":"cryptol\/examples\/props.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) defines two 2-bit words, one with the most-significant bit set and the least-significant bit clear, and the other with the most-significant bit clear and the least-significant bit set; defines a third constant as their modular sum in the 2-bit word domain; (2) defines a property named p1 that asserts this sum equals the integer value 3 when represented as a 2-bit word; (3) defines two one-element sequences whose sole elements are the two 2-bit words above, and defines a third one-element sequence as their pointwise (element-wise) sum; (4) defines a polymorphic function t with an explicit type signature universally quantified over a finite natural a, taking a word of length 3\u00b7a and returning a square matrix of bits of size (3\u00b7a) by (3\u00b7a); the function must ignore its input and return an all-zero matrix of the specified size. Clearly specify all types, including that the 2-bit quantities are words of bits, the one-element sequences are sequences of 2-bit words, and the matrix result is a nested sequence. Use the Cryptol property mechanism for p1 and modular arithmetic semantics for word addition."},{"role":"assistant","content":"```cryptol\nx = [True, False]\ny = [False, True]\nz = x + y\n\nproperty p1 = z == 3\n\nxx = [[True,False]]\nyy = [[False, True]]\nzz = xx + yy\n\nt : {a} [a*3] -> [a*3][a*3]\nt d = zero\n```"}]}
{"filename":"cryptol\/examples\/demote.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol specification that introduces: (1) a polymorphic function named x with a numeric type parameter a constrained to be finite; x takes a bitvector of length a and returns a bitvector of length (2*a)+3. The implementation must ignore its input and produce the constant result of adding zero and one, sized to the output width. Provide the full type signature and definition for x. (2) a constant named y defined by applying x to the 3-bit numeric literal whose value is two; give y an explicit type consistent with the instantiated width computed from a = 3. Ensure all size arithmetic and type constraints are explicit and checkable."},{"role":"assistant","content":"```cryptol\nx : {a}(fin a) => [a] -> [(a*2)+3]\nx v = 0 + 1\n\ny = x (2 : [3])\n```"}]}
{"filename":"cryptol\/examples\/append.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares two finite sequences of 8-bit words with explicit type annotations and concrete literal contents, declares a third sequence as the append of the first two, and then declares four additional constants selecting elements from the concatenated sequence at indices 0, 2, 10, and 11. Provide type signatures for all top-level definitions. For the element at index 0, demonstrate indexing using an explicitly typed 1-bit zero; for the others, use natural-number indices. Ensure the index expressions have the correct bit widths implied by the concatenated length so the specification typechecks without defaulting or ambiguity. Clearly state any necessary finiteness and numeric constraints."},{"role":"assistant","content":"```cryptol\nx : [_][8]\nx = [1,2,3,4,5,19,12,38,5,3]\n\ny : [_][8]\ny = [19,3,27,5,12]\n\nz = x # y\n\nm = z @ (0 : [1]) w = z @ 2 \nt = z @ 10 v = z @ 11\n```"}]}
{"filename":"cryptol\/examples\/split.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define constants and properties as follows: create a constant sequence of four 8-bit words holding the values 1, 2, 3, and 4; create a second constant by applying the built-in splitting operation to partition that sequence into two chunks of length two, producing a 2-by-2 nested sequence of 8-bit words; define four constants that extract the elements of the nested sequence by first selecting the outer index (0 or 1) and then the inner index (0 or 1), yielding the first, second, third, and fourth 8-bit values, respectively. Provide explicit type annotations so the first constant is a length-4 sequence of 8-bit words, the split result is a 2-by-2 nested sequence of 8-bit words, and each extracted element is an 8-bit word. Define properties that assert the extracted elements equal 1, 2, 3, and 4 in order, matching the original sequence positions."},{"role":"assistant","content":"```cryptol\nx = [1,2,3,4] : [_][8]\n\ny = (split x) : [2][2][8]\n\na = (y@0) @ 0\nb = (y@0) @ 1\nc = (y@1) @ 0\nd = (y@1) @ 1\n```"}]}
{"filename":"cryptol\/lib\/Array.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Array that contains the following definitions: a primitive two-parameter type constructor representing an indexed array; primitive functions to construct a constant-filled array, read an element by index, write an element at an index producing a new array, test equality of two fixed-size arrays, copy a contiguous range from a source array to a destination array, set a contiguous range in an array to a single value, and test equality of two ranges from two arrays. Provide precise polymorphic type signatures for each, using bitvector index types of width n for fixed-size arrays and appropriate constraints ensuring n is finite and fits within the index type, and that the index type supports integral addition. Implement two total functions: one that returns a length-n sequence of elements starting at a given index by reading successive indices offset by 0..n-1, and one that updates an array with a length-n sequence of values starting at a given index by iteratively applying single-index updates from left to right. Add properties that: (1) the range-read function\u2019s i-th element equals a single read at the base index plus i; (2) the range-update result equals the left-to-right fold of single-index updates at successive offsets with corresponding values; (3) array equality is equivalent to pointwise equality over all indices; (4) range copy equals reading a slice from the source and writing it into the destination at the given start indices for the given length; (5) range set equals writing the same value across the specified contiguous indices; and (6) range equality equals pointwise equality of the corresponding slices. Use universally quantified variables for element type, index type, and length, and clearly state all required class constraints. Do not provide implementations for the primitives beyond their type signatures."},{"role":"assistant","content":"```cryptol\nmodule Array where\n\nprimitive type Array : * -> * -> *\n\nprimitive arrayConstant : {a, b} b -> (Array a b)\nprimitive arrayLookup : {a, b} (Array a b) -> a -> b\nprimitive arrayUpdate : {a, b} (Array a b) -> a -> b -> (Array a b)\nprimitive arrayEq : {n, a} (Array [n] a) -> (Array [n] a) -> Bool\n\nprimitive arrayCopy : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> (Array [n] a)\n\nprimitive arraySet : {n, a} (Array [n] a) -> [n] -> a -> [n] -> (Array [n] a)\n\nprimitive arrayRangeEqual : {n, a} (Array [n] a) -> [n] -> (Array [n] a) -> [n] -> [n] -> Bool\n\narrayRangeLookup : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b\narrayRangeLookup arr idx = res\n  where\n    res @ i = arrayLookup arr (idx + i)\n\narrayRangeUpdate : {a, b, n} (Integral a, fin n, LiteralLessThan n a) => (Array a b) -> a -> [n]b -> (Array a b)\narrayRangeUpdate arr idx vals = arrs ! 0\n  where\n    arrs = [arr] # [ arrayUpdate acc (idx + i) val | acc <- arrs | i <- [0 ..< n] | val <- vals ]\n```"}]}
{"filename":"cryptol\/lib\/SuiteB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named SuiteB that contains the following definitions, types, and constraints, preserving names and arities: (1) Type synonyms for AES key-size parameters representing the number of 32-bit words for 128-, 192-, and 256-bit keys; a type alias for a 4-by-32-bit AES round key; record types for parameterized encrypt\/decrypt key schedules with fields for initial key, an array of k+5 round keys, and a final key. (2) Public functions that produce encryption\/decryption schedules and paired schedules for each supported key size (128, 192, 256) by delegating to generic expansion helpers. (3) A block encryption function over 128-bit blocks parameterized by k that iteratively applies a primitive AES encryption round across the round keys starting from the initial key addition, then applies a primitive final round and a final key addition; similarly, a block decryption function that uses the corresponding decrypt primitives and round-key order. (4) Private helpers: a generic encrypt-schedule expansion from a k\u00b732-bit key using a primitive key expansion and grouping into round keys; a conversion from encrypt to decrypt schedule that reverses round keys and applies inverse mix-columns; a generic decrypt-schedule expansion and a pair-producing expansion. Include constraints that k is finite and between 4 and 8 inclusive. (5) Primitive declarations for AES round, final round, inverse mix-columns, and key expansion with appropriate types over 4\u00d732-bit states and k-parameterized key material. (6) Public SHA-2 hash functions producing 224-, 256-, 384-, and 512-bit digests that pad an arbitrary-length bitvector, split into 16-word blocks of 32 or 64 bits, and invoke corresponding primitive processors. (7) Private SHA-2 helpers for block size, number of blocks, padded size, a padding function that appends a single \u20181\u2019 bit, zeros, and the length field, a block-splitting function, and primitive processors with sizes matching their digests. Ensure all type signatures, size arithmetic, and constraints match these descriptions."},{"role":"assistant","content":"```cryptol\nmodule SuiteB where\n\ntype AES128 = 4\n\ntype AES192 = 6\n\ntype AES256 = 8\n\ntype AESRoundKey = [4][32]\n\ntype AESEncryptKeySchedule k =\n  { aesEncInitialKey : AESRoundKey\n  , aesEncRoundKeys  : [k+5]AESRoundKey\n  , aesEncFinalKey   : AESRoundKey\n  }\n\ntype AESDecryptKeySchedule k =\n  { aesDecInitialKey : AESRoundKey\n  , aesDecRoundKeys  : [k+5]AESRoundKey\n  , aesDecFinalKey   : AESRoundKey\n  }\n\naes128EncryptSchedule : [128] -> AESEncryptKeySchedule AES128\naes128EncryptSchedule = aesExpandEncryptSchedule\n\naes128DecryptSchedule : [128] -> AESDecryptKeySchedule AES128\naes128DecryptSchedule = aesExpandDecryptSchedule\n\naes128Schedules : [128] -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\naes128Schedules = aesExpandSchedules\n\naes192EncryptSchedule : [192] -> AESEncryptKeySchedule AES192\naes192EncryptSchedule = aesExpandEncryptSchedule\n\naes192DecryptSchedule : [192] -> AESDecryptKeySchedule AES192\naes192DecryptSchedule = aesExpandDecryptSchedule\n\naes192Schedules : [192] -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\naes192Schedules = aesExpandSchedules\n\naes256EncryptSchedule : [256] -> AESEncryptKeySchedule AES256\naes256EncryptSchedule = aesExpandEncryptSchedule\n\naes256DecryptSchedule : [256] -> AESDecryptKeySchedule AES256\naes256DecryptSchedule = aesExpandDecryptSchedule\n\naes256Schedules : [256] -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\naes256Schedules = aesExpandSchedules\n\naesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]\naesEncryptBlock schedule plaintext = rnf (join final)\n  where\n  final = (AESEncFinalRound (rds!0)) ^ schedule.aesEncFinalKey\n\n  rds = [ schedule.aesEncInitialKey ^ split plaintext ] #\n        [ AESEncRound r ^ rdk\n        | rdk <- schedule.aesEncRoundKeys\n        | r   <- rds\n        ]\n\naesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]\naesDecryptBlock schedule cyphertext = rnf (join final)\n  where\n  final = (AESDecFinalRound (rds!0)) ^ schedule.aesDecFinalKey\n\n  rds = [ split cyphertext ^ schedule.aesDecInitialKey ] #\n        [ AESDecRound r ^ rdk\n        | rdk <- schedule.aesDecRoundKeys\n        | r   <- rds\n        ]\n\nprivate\n    aesExpandEncryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESEncryptKeySchedule k\n    aesExpandEncryptSchedule key = rnf\n         { aesEncInitialKey = ks @  0\n         , aesEncRoundKeys  = ks @@ [ 1 .. k+5 ]\n         , aesEncFinalKey   = ks @  `(k+6)\n         }\n      where\n      ks : [k+7]AESRoundKey\n      ks = groupBy`{4} (AESKeyExpand`{k} (split key))\n\n    aesEncToDecSchedule : {k} (fin k) => AESEncryptKeySchedule k -> AESDecryptKeySchedule k\n    aesEncToDecSchedule enc = rnf\n       { aesDecInitialKey = enc.aesEncFinalKey\n       , aesDecRoundKeys  = map AESInvMixColumns (reverse (enc.aesEncRoundKeys))\n       , aesDecFinalKey   = enc.aesEncInitialKey\n       }\n\n    aesExpandDecryptSchedule : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> AESDecryptKeySchedule k\n    aesExpandDecryptSchedule key = aesEncToDecSchedule (aesExpandEncryptSchedule key)\n\n    aesExpandSchedules : {k} (fin k, k >= 4, 8 >= k) => [k * 32] -> (AESEncryptKeySchedule k, AESDecryptKeySchedule k)\n    aesExpandSchedules key = (encS, aesEncToDecSchedule encS)\n      where encS = aesExpandEncryptSchedule key\n\n    primitive AESEncRound      : [4][32] -> [4][32]\n    primitive AESEncFinalRound : [4][32] -> [4][32]\n    primitive AESDecRound      : [4][32] -> [4][32]\n    primitive AESDecFinalRound : [4][32] -> [4][32]\n    primitive AESInvMixColumns : [4][32] -> [4][32]\n    primitive AESKeyExpand     : {k} (fin k, k >= 4, 8 >= k) => [k][32] -> [4*(k+7)][32]\n\nsha224 : {L} (fin L) => [L] -> [224]\nsha224 msg = join (processSHA2_224 (sha2blocks`{32} msg))\n\nsha256 : {L} (fin L) => [L] -> [256]\nsha256 msg = join (processSHA2_256 (sha2blocks`{32} msg))\n\nsha384 : {L} (fin L) => [L] -> [384]\nsha384 msg = join (processSHA2_384 (sha2blocks`{64} msg))\n\nsha512 : {L} (fin L) => [L] -> [512]\nsha512 msg = join (processSHA2_512 (sha2blocks`{64} msg))\n\nprivate\n    type sha2_block_size w = 16 * w\n    type sha2_num_blocks w L = (L+1+2*w) \/^ sha2_block_size w\n    type sha2_padded_size w L = sha2_num_blocks w L * sha2_block_size w\n\n    sha2pad : {w, L} (fin w, fin L, w >= 1) => [L] -> [sha2_padded_size w L]\n    sha2pad M = rnf (M # 0b1 # zero # ((fromInteger `L) : [2*w]))\n\n    sha2blocks : {w, L} (fin w, fin L, w >= 1) =>\n      [L] -> [sha2_num_blocks w L][16][w]\n    sha2blocks msg = [ split x | x <- split (sha2pad`{w} msg) ]\n\n    primitive processSHA2_224 : {n} (fin n) => [n][16][32] -> [7][32]\n\n    primitive processSHA2_256 : {n} (fin n) => [n][16][32] -> [8][32]\n\n    primitive processSHA2_384 : {n} (fin n) => [n][16][64] -> [6][64]\n\n    primitive processSHA2_512 : {n} (fin n) => [n][16][64] -> [8][64]\n```"}]}
{"filename":"cryptol\/lib\/Float.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Float that contains the following definitions: (1) a primitive proposition ValidFloat taking two numeric kinds (exponent size and precision size); (2) a type constructor Float parameterized by exponent and precision, available only when ValidFloat holds; (3) type aliases for common formats with specific exponent\/precision sizes (16, 32, 64, 128, 256); (4) a 3-bit type RoundingMode and five constants for rounding to nearest-even, nearest-away, toward +\u221e, toward \u2212\u221e, and toward zero, each with a short alias, mapped respectively to 0, 1, 2, 3, and 4; (5) primitive values for NaN and +\u221e; derived values \u2212\u221e as the negation of +\u221e, +0 as zero, and \u22120 as the negation of +0; (6) primitives to convert between a bit vector of length exponent+precision and Float, both directions; (7) a primitive float equivalence operator returning Bool, declared infix with precedence 20; (8) primitive predicates to detect NaN, infinity, zero, negative sign, normal, and subnormal; a derived predicate finite defined as not (NaN or infinity); (9) primitive arithmetic operations add, subtract, multiply, divide, and fused multiply-add, each taking a rounding mode; (10) primitive absolute value; (11) primitive square root taking a rounding mode; (12) conversions to Rational and from Rational (the latter taking a rounding mode). All functions must be polymorphic in exponent and precision and require the ValidFloat constraint; use bit-vector lengths computed as exponent+precision. Do not implement bodies for primitives; provide exact type signatures and constants."},{"role":"assistant","content":"```cryptol\nmodule Float where\n\nprimitive type ValidFloat : # -> # -> Prop\n\nprimitive type { exponent : #, precision : #}\n  ValidFloat exponent precision => Float exponent precision : *\n\ntype Float16  = Float 5 11\n\ntype Float32  = Float 8 24\n\ntype Float64  = Float 11 53\n\ntype Float128 = Float 15 113\n\ntype Float256 = Float 19 237\n\ntype RoundingMode = [3]\n\nroundNearestEven, rne : RoundingMode\nroundNearestEven = 0\nrne              = roundNearestEven\n\nroundNearestAway, rna : RoundingMode\nroundNearestAway  = 1\nrna               = roundNearestAway\n\nroundPositive, rtp : RoundingMode\nroundPositive     = 2\nrtp               = roundPositive\n\nroundNegative, rtn : RoundingMode\nroundNegative     = 3\nrtn               = roundNegative\n\nroundZero, rtz : RoundingMode\nroundZero         = 4\nrtz               = roundZero\n\nprimitive\n  fpNaN : {e,p} ValidFloat e p => Float e p\n\nprimitive\n  fpPosInf : {e,p} ValidFloat e p => Float e p\n\nfpNegInf : {e,p} ValidFloat e p => Float e p\nfpNegInf = - fpPosInf\n\nfpPosZero : {e,p} ValidFloat e p => Float e p\nfpPosZero = zero\n\nfpNegZero : {e,p} ValidFloat e p => Float e p\nfpNegZero = - fpPosZero\n\nprimitive\n  fpFromBits : {e,p} ValidFloat e p => [e + p] -> Float e p\n\nprimitive\n  fpToBits : {e,p} ValidFloat e p => Float e p -> [e + p]\n\nprimitive\n  (=.=) : {e,p} ValidFloat e p => Float e p -> Float e p -> Bool\n\ninfix 20 =.=\n\nprimitive fpIsNaN : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsInf : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsZero : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsNeg : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsNormal : {e,p} ValidFloat e p => Float e p -> Bool\n\nprimitive fpIsSubnormal : {e,p} ValidFloat e p => Float e p -> Bool\n\nfpIsFinite : {e,p} ValidFloat e p => Float e p -> Bool\nfpIsFinite f = ~ (fpIsNaN f \\\/ fpIsInf f )\n\nprimitive\n  fpAdd : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpSub : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpMul : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpDiv : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpFMA : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p -> Float e p -> Float e p\n\nprimitive\n  fpAbs : {e,p} ValidFloat e p =>\n    Float e p -> Float e p\n\nprimitive\n  fpSqrt : {e,p} ValidFloat e p =>\n    RoundingMode -> Float e p -> Float e p\n\nprimitive\n  fpToRational : {e,p} ValidFloat e p =>\n    Float e p -> Rational\n\nprimitive\n  fpFromRational : {e,p} ValidFloat e p =>\n    RoundingMode -> Rational -> Float e p\n```"}]}
{"filename":"cryptol\/lib\/Cryptol.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Cryptol that contains the following definitions, with precise type signatures and constraints over type-level naturals and classes: (1) Operator fixities and precedences for logical, comparison, arithmetic, bit-shift\/rotate, indexing, and concatenation operators. (2) Primitive type-level and value-level entities: bits, unbounded integer, bounded signed integers parameterized by a positive finite width, rational, the infinite length kind, type-level predicates (type equality\/inequality, finiteness, primality, ordering), and type-level arithmetic\/combinators (+, *, -, \/, %, exponentiation, width, min, max, division\/modulo variants, and a length computation for arithmetic progressions). Provide constraint synonyms for natural comparisons. (3) Type synonyms for booleans, words, characters, strings, and a logarithm-of-2 width helper at the type level. (4) Literal predicate classes for numbers and bounded ranges, with constructors\/demoters for literals; finite range constructors for increasing\/decreasing and stride-based sequences, plus from-then-to with a length constraint. (5) Numeric and logical classes (zero, logic, ring, integral, field, rounding, equality, comparison, signed comparison) and their associated operations with required constraints. (6) Algebraic enums for optional and result values; boolean constants and connectives including implication; helpers for absolute value, min\/max, signed\/unsigned comparisons, and pointwise function equality\/inequality. (7) Bitvector\/sequence utilities: carry\/overflow checks, zero\/sign extension, shifts\/rotates by integer indices, integer conversions (signed and Z-based), rational construction, concatenation\/splitting, reversing\/transposition, slicing, head\/tail\/last, grouping, indexing (random and bounds-checked) and bulk\/single updates, generator, sorting (by comparator and default), polynomial arithmetic over bit polynomials, parallel map, strictness utilities, error\/undefined, assertions, randomness, tracing. (8) Higher-order utilities: map, folds (left\/right, strict and non-strict), sum\/product, scans, repeat, membership, zipping, currying\/uncurrying, iteration, predicates all\/any\/and\/or. Ensure all parameters and guards match finiteness and ordering bounds as described."},{"role":"assistant","content":"```cryptol\nmodule Cryptol where\n\ninfixr  5 ==>\ninfixr 10 \\\/\ninfixr 15 \/\\\ninfix  20 ==, ===, !=, !==\ninfix  30 >, >=, <, <=, <$, >$, <=$, >=$\ninfixr 40 ||\ninfixl 45 ^\ninfixr 50 &&\ninfixr 60 #\ninfixl 70 <<, <<<, >>, >>>, >>$\ninfixl 80 +, -\ninfixl 90 *, \/, %, \/$, %$, %^, \/^\ninfixr 95 ^^\ninfixl 100 @, @@, !, !!\n\nprimitive type Bit : *\n\nprimitive type Integer : *\n\nprimitive type {n : #} (fin n, n >= 1) => Z n : *\n\nprimitive type Rational : *\n\ntype Bool = Bit\ntype Word n = [n]\ntype Char = [8]\ntype String n = [n]Char\n\nprimitive type inf : #\n\nprimitive type (==) : # -> # -> Prop\n\nprimitive type (!=) : # -> # -> Prop\n\nprimitive type (>=) : # -> # -> Prop\n\nprimitive type fin : # -> Prop\n\nprimitive type prime : # -> Prop\n\nprimitive type (+) : # -> # -> #\n\nprimitive type (*) : # -> # -> #\n\nprimitive type\n  {m : #, n : # }\n  (fin n, m >= n) =>\n  m - n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin m, n >= 1) =>\n  m \/ n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin m, n >= 1) =>\n  m % n : #\n\nprimitive type (^^) : # -> # -> #\n\nprimitive type width : # -> #\n\ntype lg2 n = width (max n 1 - 1)\n\nprimitive type min : # -> # -> #\n\nprimitive type max : # -> # -> #\n\nprimitive type\n  { m : #, n : # }\n  (fin n, n >= 1) =>\n  m \/^ n : #\n\nprimitive type\n  { m : #, n : # }\n  (fin n, n >= 1) =>\n  m %^ n : #\n\nprimitive type\n  { start : #, next : #, last : # }\n  (fin start, fin next, fin last, start != next) =>\n  lengthFromThenTo start next last : #\n\ntype constraint i <= j = (j >= i)\n\ntype constraint i > j = i >= j + 1\n\ntype constraint i < j = j >= i + 1\n\nprimitive type Literal : # -> * -> Prop\n\nprimitive type LiteralLessThan : # -> * -> Prop\n\nprimitive number : {val, rep} Literal val rep => rep\n\ndemote : {val, rep} Literal val rep => rep\ndemote = number`{val}\n\nlength : {n, a, b} (fin n, Literal n b) => [n]a -> b\nlength _ = `n\n\nprimitive fromTo : {first, last, a}\n  (fin last, last >= first, Literal last a) =>\n  [1 + (last - first)]a\n\nprimitive fromToLessThan :\n  {first, bound, a} (fin first, bound >= first, LiteralLessThan bound a) =>\n  [bound - first]a\n\nprimitive fromToBy : {first, last, stride, a}\n  (fin last, fin stride, stride >= 1, last >= first, Literal last a) =>\n  [1 + (last - first)\/stride]a\n\nprimitive fromToByLessThan : {first, bound, stride, a}\n  (fin first, fin stride, stride >= 1, bound >= first, LiteralLessThan bound a) =>\n  [(bound - first)\/^stride]a\n\nprimitive fromToDownBy : {first, last, stride, a}\n  (fin first, fin stride, stride >= 1, first >= last, Literal first a) =>\n  [1 + (first - last)\/stride]a\n\nprimitive fromToDownByGreaterThan : {first, bound, stride, a}\n  (fin first, fin stride, stride >= 1, first >= bound, Literal first a) =>\n  [(first - bound)\/^stride]a\n\nprimitive fromThenTo : {first, next, last, a, len}\n                       ( fin first, fin next, fin last\n                       , Literal first a, Literal next a, Literal last a\n                       , first != next\n                       , lengthFromThenTo first next last == len) => [len]a\n\nprimitive type FLiteral : # -> # -> # -> * -> Prop\n\nprimitive\n  fraction : { m, n, r, a } FLiteral m n r a => a\n\nprimitive type Zero : * -> Prop\n\nprimitive zero : {a} (Zero a) => a\n\nprimitive type Logic : * -> Prop\n\nprimitive (&&) : {a} (Logic a) => a -> a -> a\n\nprimitive (||) : {a} (Logic a) => a -> a -> a\n\nprimitive (^) : {a} (Logic a) => a -> a -> a\n\nprimitive complement : {a} (Logic a) => a -> a\n\nprimitive type Ring : * -> Prop\n\nprimitive fromInteger : {a} (Ring a) => Integer -> a\n\nprimitive (+) : {a} (Ring a) => a -> a -> a\n\nprimitive (-) : {a} (Ring a) => a -> a -> a\n\nprimitive (*) : {a} (Ring a) => a -> a -> a\n\nprimitive negate : {a} (Ring a) => a -> a\n\nprimitive type Integral : * -> Prop\n\nprimitive (\/) : {a} (Integral a) => a -> a -> a\n\nprimitive (%) : {a} (Integral a) => a -> a -> a\n\nprimitive toInteger : {a} (Integral a) => a -> Integer\n\nprimitive (^^) : {a, e} (Ring a, Integral e) => a -> e -> a\n\nprimitive infFrom : {a} (Integral a) => a -> [inf]a\n\nprimitive infFromThen : {a} (Integral a) => a -> a -> [inf]a\n\nprimitive type Field : * -> Prop\n\nprimitive recip : {a} (Field a) => a -> a\n\nprimitive (\/.) : {a} (Field a) => a -> a -> a\n\nprimitive type Round : * -> Prop\n\nprimitive ceiling : {a} (Round a) => a -> Integer\n\nprimitive floor : {a} (Round a) => a -> Integer\n\nprimitive trunc : {a} (Round a) => a -> Integer\n\nprimitive roundAway : {a} (Round a) => a -> Integer\n\nprimitive roundToEven : {a} (Round a) => a -> Integer\n\nprimitive type Eq : * -> Prop\n\nprimitive (==) : {a} (Eq a) => a -> a -> Bit\n\nprimitive (!=) : {a} (Eq a) => a -> a -> Bit\n\n(===) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\nf === g = \\ x -> f x == g x\n\n(!==) : {a, b} (Eq b) => (a -> b) -> (a -> b) -> (a -> Bit)\nf !== g = \\x -> f x != g x\n\nprimitive type Cmp : * -> Prop\n\nprimitive (<) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (>) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (<=) : {a} (Cmp a) => a -> a -> Bit\n\nprimitive (>=) : {a} (Cmp a) => a -> a -> Bit\n\nmin : {a} (Cmp a) => a -> a -> a\nmin x y = if x < y then x else y\n\nmax : {a} (Cmp a) => a -> a -> a\nmax x y = if x > y then x else y\n\nabs : {a} (Cmp a, Ring a) => a -> a\nabs x = if x < fromInteger 0 then negate x else x\n\nprimitive type SignedCmp : * -> Prop\n\nprimitive (<$) : {a} (SignedCmp a) => a -> a -> Bit\n\n(>$) : {a} (SignedCmp a) => a -> a -> Bit\nx >$ y = y <$ x\n\n(<=$) : {a} (SignedCmp a) => a -> a -> Bit\nx <=$ y = ~(y <$ x)\n\n(>=$) : {a} (SignedCmp a) => a -> a -> Bit\nx >=$ y = ~(x <$ y)\n\nenum Option a = None | Some a\n\nenum Result t e = Ok t | Err e\n\nprimitive True  : Bit\n\nprimitive False : Bit\n\n(\/\\) : Bit -> Bit -> Bit\nx \/\\ y = if x then y else False\n\n(\\\/) : Bit -> Bit -> Bit\nx \\\/ y = if x then True else y\n\n(==>) : Bit -> Bit -> Bit\na ==> b = if a then b else True\n\nprimitive (\/$) : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\n\nprimitive (%$) : {n} (fin n, n >= 1) => [n] -> [n] -> [n]\n\ncarry : {n} (fin n) => [n] -> [n] -> Bit\ncarry x y = (x + y) < x\n\nscarry : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nscarry x y = (sx == sy) && (sx != sz)\n  where\n    z  = x + y\n    sx = head x\n    sy = head y\n    sz = head z\n\nsborrow : {n} (fin n, n >= 1) => [n] -> [n] -> Bit\nsborrow x y = ( x <$ (x-y) ) ^ head y\n\nzext : {m, n} (fin m, m >= n) => [n] -> [m]\nzext x = zero # x\n\nsext : {m, n} (fin m, m >= n, n >= 1) => [n] -> [m]\nsext x = newbits # x\n  where newbits = if head x then ~zero else zero\n\nprimitive (>>$) : {n, ix} (fin n, n >= 1, Integral ix) => [n] -> ix -> [n]\n\nprimitive lg2 : {n} (fin n) => [n] -> [n]\n\nprimitive toSignedInteger : {n} (fin n, n >= 1) => [n] -> Integer\n\nprimitive ratio : Integer -> Integer -> Rational\n\nprimitive fromZ : {n} (fin n, n >= 1) => Z n -> Integer\n\nprimitive (#) : {front, back, a} (fin front) => [front]a -> [back]a\n                                             -> [front + back] a\n\nsplitAt : {front, back, a} (fin front) => [front + back]a\n                                       -> ([front]a, [back]a)\nsplitAt xs = (take`{front,back} xs, drop`{front,back} xs)\n\nprimitive join : {parts, each, a} (fin each) => [parts][each]a\n                                             -> [parts * each]a\n\nprimitive split : {parts, each, a} (fin each) => [parts * each]a\n                                              -> [parts][each]a\n\nprimitive reverse : {n, a} (fin n) => [n]a -> [n]a\n\nprimitive transpose : {rows, cols, a} [rows][cols]a -> [cols][rows]a\n\nprimitive take : {front, back, a} [front + back]a -> [front]a\n\nprimitive drop : {front, back, a} (fin front) => [front + back]a -> [back]a\n\ntail : {n, a} [1 + n]a -> [n]a\ntail xs = drop`{1} xs\n\nhead : {n, a} [1 + n]a -> a\nhead xs = xs @ (0 : Integer)\n\nlast : {n, a} (fin n) => [1 + n]a -> a\nlast xs = xs ! (0 : Integer)\n\ngroupBy : {each, parts, a} (fin each) => [parts * each]a -> [parts][each]a\ngroupBy = split`{parts=parts}\n\nprimitive (<<) : {n, ix, a} (Integral ix, Zero a) => [n]a -> ix -> [n]a\n\nprimitive (>>) : {n, ix, a} (Integral ix, Zero a) => [n]a -> ix -> [n]a\n\nprimitive (<<<) : {n, ix, a} (fin n, Integral ix) => [n]a -> ix -> [n]a\n\nprimitive (>>>) : {n, ix, a} (fin n, Integral ix) => [n]a -> ix -> [n]a\n\nprimitive (@) : {n, a, ix} (Integral ix) => [n]a -> ix -> a\n\n(@@) : {n, k, ix, a} (Integral ix) => [n]a -> [k]ix -> [k]a\nxs @@ is = [ xs @ i | i <- is ]\n\nprimitive (!) : {n, a, ix} (fin n, Integral ix) => [n]a -> ix -> a\n\n(!!) : {n, k, ix, a} (fin n, Integral ix) => [n]a -> [k]ix -> [k]a\nxs !! is = [ xs ! i | i <- is ]\n\nprimitive update : {n, a, ix} (Integral ix) => [n]a -> ix -> a -> [n]a\n\nprimitive updateEnd : {n, a, ix} (fin n, Integral ix) => [n]a -> ix -> a -> [n]a\n\nupdates : {n, k, ix, a} (Integral ix, fin k) => [n]a -> [k]ix -> [k]a -> [n]a\nupdates xs0 idxs vals = foldl upd xs0 (zip idxs vals)\n  where\n    upd xs (i,b) = update xs i b\n\nupdatesEnd : {n, k, ix, a} (fin n, Integral ix, fin k) => [n]a -> [k]ix -> [k]a -> [n]a\nupdatesEnd xs0 idxs vals = foldl upd xs0 (zip idxs vals)\n  where\n    upd xs (i,b) = updateEnd xs i b\n\ngenerate : {n, a, ix} (Integral ix, LiteralLessThan n ix) => (ix -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. <n] ]\n\nsort : {a, n} (Cmp a, fin n) => [n]a -> [n]a\nsort = sortBy (<=)\n\nsortBy : {a, n} (fin n) => (a -> a -> Bit) -> [n]a -> [n]a\nsortBy le ((xs : [n\/2]a) # (ys : [n\/^2]a)) = take zs.0\n  where\n    xs' = if `(n\/2)  == (1 : Integer) then xs else sortBy le xs\n    ys' = if `(n\/^2) == (1 : Integer) then ys else sortBy le ys\n    zs  = [ if i == `(n\/2)        then (ys'@j, i  , j+1)\n             | j == `(n\/^2)       then (xs'@i, i+1, j  )\n             | le (xs'@i) (ys'@j) then (xs'@i, i+1, j  )\n            else                       (ys'@j, i  , j+1)\n          | (_, i , j) <- [ (undefined, 0 : Integer, 0 : Integer) ] # zs\n          ]\n\nprimitive pmult : {u, v} (fin u, fin v) => [1 + u] -> [1 + v] -> [1 + u + v]\n\nprimitive pdiv : {u, v} (fin u, fin v) => [u] -> [v] -> [u]\n\nprimitive pmod : {u, v} (fin u, fin v) => [u] -> [1 + v] -> [v]\n\nprimitive parmap : {a, b, n} (Eq b, fin n) => (a -> b) -> [n]a -> [n]b\n\nprimitive deepseq : {a, b} Eq a => a -> b -> b\n\nrnf : {a} Eq a => a -> a\nrnf x = deepseq x x\n\nprimitive error : {a, n} (fin n) => String n -> a\n\nundefined : {a} a\nundefined = error \"undefined\"\n\nassert : {a, n} (fin n) => Bit -> String n -> a -> a\nassert pred msg x = if pred then x else error msg\n\nprimitive random : {a} [256] -> a\n\nprimitive trace : {n, a, b} (fin n) => String n -> a -> b -> b\n\ntraceVal : {n, a} (fin n) => String n -> a -> a\ntraceVal msg x = trace msg x x\n\nand : {n} (fin n) => [n]Bit -> Bit\nand xs = ~zero == xs\n\nor : {n} (fin n) => [n]Bit -> Bit\nor xs = zero != xs\n\nall : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nall f xs = foldl' (\/\\) True (map f xs)\n\n\/**\n * Disjunction after applying a predicate to all elements.\n *\/\nany : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nany f xs = foldl' (\\\/) False (map f xs)\n\nmap : {n, a, b} (a -> b) -> [n]a -> [n]b\nmap f xs = [f x | x <- xs]\n\nprimitive foldl : {n, a, b} (fin n) => (a -> b -> a) -> a -> [n]b -> a\n\nprimitive foldl' : {n, a, b} (fin n, Eq a) => (a -> b -> a) -> a -> [n]b -> a\n\n\/**\n * Functional right fold.\n *\n * foldr (-) 0 [1,2,3] = 0 - (1 - (2 - 3))\n *\/\nfoldr : {n, a, b} (fin n) => (a -> b -> b) -> b -> [n]a -> b\nfoldr f acc xs = foldl g acc (reverse xs)\n  where g b a = f a b\n\n\/**\n * Functional right fold, with strict evaluation of the accumulator value.\n * The accumulator is reduced to weak head normal form at each step.\n *\n * foldr' (-) 0 [1,2,3] = 0 - (1 - (2 - 3))\n *\/\nfoldr' : {n, a, b} (fin n, Eq b) => (a -> b -> b) -> b -> [n]a -> b\nfoldr' f acc xs = foldl' g acc (reverse xs)\n  where g b a = f a b\n\n\/**\n * Compute the sum of the values in the sequence.\n *\/\nsum : {n, a} (fin n, Eq a, Ring a) => [n]a -> a\nsum xs = foldl' (+) (fromInteger 0) xs\n\nproduct : {n, a} (fin n, Eq a, Ring a) => [n]a -> a\nproduct xs = foldl' (*) (fromInteger 1) xs\n\n\/**\n * Scan left is like a foldl that also emits the intermediate values.\n *\/\nprimitive scanl : {n, a, b}  (a -> b -> a) -> a -> [n]b -> [1+n]a\n\n\/**\n * Scan right is like a foldr that also emits the intermediate values.\n *\/\nscanr : {n, a, b} (fin n) => (a -> b -> b) -> b -> [n]a -> [1+n]b\nscanr f acc xs = reverse (scanl (\\a b -> f b a) acc (reverse xs))\n\n\/**\n * Repeat a value.\n *\/\nrepeat : {n, a} a -> [n]a\nrepeat x = [ x | _ <- zero : [n] ]\n\n\/**\n * 'elem x xs' returns true if x is equal to a value in xs.\n *\/\nelem : {n, a} (fin n, Eq a) => a -> [n]a -> Bit\nelem a xs = any (\\x -> x == a) xs\n\n\/**\n * Create a list of tuples from two lists.\n *\/\nzip : {n, a, b} [n]a -> [n]b -> [n](a, b)\nzip xs ys = [(x,y) | x <- xs | y <- ys]\n\n\/**\n * Create a list by applying the function to each pair of elements in the input.\n *\/\nzipWith : {n, a, b, c} (a -> b -> c) -> [n]a -> [n]b -> [n]c\nzipWith f xs ys = [f x y | x <- xs | y <- ys]\n\n\/**\n * Transform a function into uncurried form.\n *\/\nuncurry : {a, b, c} (a -> b -> c) -> (a, b) -> c\nuncurry f = \\(a, b) -> f a b\n\n\/**\n * Transform a function into curried form.\n *\/\ncurry : {a, b, c} ((a, b) -> c) -> a -> b -> c\ncurry f = \\a b -> f (a, b)\n\n\/**\n * Map a function iteratively over a seed value, producing an infinite\n * list of successive function applications.\n *\/\niterate : {a} (a -> a) -> a -> [inf]a\niterate f z = scanl (\\x _ -> f x) z (zero:[inf]())\n```"}]}
{"filename":"cryptol\/bench\/data\/SHA512.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named SHA512 that contains the following definitions: (1) A top-level function sha512 with a precise type signature mapping a finite-length bit sequence to a 512-bit digest. It must pad the message per SHA-512 (append a single 1 bit, then zero bits, then a 128-bit big-endian length) so that the total length is a multiple of 1024, with the usual bound that the original length fits in 128 bits. After padding, split into 1024-bit blocks, iteratively apply a compression function starting from an 8-word 64-bit initial vector, and return the final chaining value concatenated into 512 bits. (2) A function processBlock with type [1024] -> [8][64] -> [8][64] that builds an 80-word schedule from the 16 input words and performs 80 rounds of the SHA-512 step, then adds the result to the incoming state word-wise modulo 2^64. (3) A function step with type [8][64] -> [64] -> [8] -> [8][64] that takes the state, a 64-bit schedule word, and a round index in [0..79], computes T1 and T2 using the SHA-512 Ch, Maj, and big-sigma functions, and returns the next state. (4) A function messageSch with type [16][64] -> [80][64] that defines words 16..79 using the small-sigma recurrences. (5) A polymorphic pad with constraints capturing the SHA-512 padding length arithmetic and output length multiple-of-1024 requirement. (6) Bitwise helpers Ch, Maj, SIGMA0, SIGMA1, sigma0, sigma1 on 64-bit words using rotates and shifts. (7) Constants H0 : [8][64] and K : [80][64] with standard SHA-512 initialization and round constants. (8) A property named testVector1 that checks the hash of a specific hexadecimal message equals a specific 512-bit hexadecimal digest (the property may ignore its argument). Provide all necessary type signatures and ensure 64-bit modular arithmetic."},{"role":"assistant","content":"```cryptol\nmodule SHA512 where\n\nsha512 M = result\n  where\n    M' = (pad M)\n    blocks = (groupBy`{1024} M')\n    hash = [H0] # [ processBlock b h | b <- blocks | h <- hash ]\n    result = (join (hash!0))\n\nprocessBlock : [1024] -> [8][64] -> [8][64]\nprocessBlock block Hprev = Hs\n  where\n    Mi = split block : [16][64]\n    Ws = (messageSch Mi)\n    round = [Hprev] # [ (step r (Ws@t) t) | t <- [0..79] | r <- round ]\n    Hs = [ (x + H) | x <- (round!0) | H <- Hprev ]\n\nstep : [8][64] -> [64] -> [8] -> [8][64]\nstep [a, b, c, d, e, f, g, h] Wt t = [a', b', c', d', e', f', g', h']\n  where\n    T1 = h + (SIGMA1 e) + (Ch e f g) + (K@t) + Wt\n    T2 = (SIGMA0 a) + (Maj a b c)\n    h' = g\n    g' = f\n    f' = e\n    e' = d + T1\n    d' = c\n    c' = b\n    b' = a\n    a' = T1 + T2\n\nmessageSch : [16][64] -> [80][64]\nmessageSch Mi = W\n  where\n    W = Mi # [ (sigma1 (W@(t-2))) + (W@(t-7)) + (sigma0 (W@(t-15))) + (W@(t-16)) | t <- [16..79] ]\n\npad : {l, k} (fin l,\n              l <= ((2^^128) - 1),\n              l >= 0,\n              fin k,\n              k - l >= 129,\n              k == 128 + l + 1 + 1024 - ((l+129)%1024),\n              k%1024 == 0) => [l] -> [k]\npad M = M # (1:[1]) # (0:[k-128-l-1]) # (`l:[128])\n\nCh : [64] -> [64] -> [64] -> [64]\nCh x y z = (x && y) ^ ((~x) && z)\n\nMaj : [64] -> [64] -> [64] -> [64]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nSIGMA0 : [64] -> [64]\nSIGMA0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)\n\nSIGMA1 : [64] -> [64]\nSIGMA1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)\n\nsigma0 : [64] -> [64]\nsigma0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)\n\nsigma1 : [64] -> [64]\nsigma1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)\n\nH0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n       0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]\n\nK = [\n0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n]\n\nproperty testVector1 x = sha512 0xfd2203e467574e834ab07c9097ae164532f24be1eb5d88f1af7748ceff0d2c67a21f4e4097f9d3bb4e9fbf97186e0db6db0100230a52b453d421f8ab9c9a6043aa3295ea20d2f06a2f37470d8a99075f1b8a8336f6228cf08b5942fc1fb4299c7d2480e8e82bce175540bdfad7752bc95b577f229515394f3ae5cec870a4b2f8 == 0xa21b1077d52b27ac545af63b32746c6e3c51cb0cb9f281eb9f3580a6d4996d5c9917d2a6e484627a9d5a06fa1b25327a9d710e027387fc3e07d7c4d14c6086cc\n```"}]}
{"filename":"cryptol\/rust\/cry-ffi\/Example.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Example that imports the Float module and contains only declarations (no implementations) for the following: (1) a newtype N wrapping a record with one field unN that is an 8-bit sequence; (2) foreign abstract symbols with explicit types: a function Bit -> Bit; functions over fixed-width sequences mapping each width to itself for 8, 16, 32, 64, and 128 bits (two sets named for unsigned and signed but all typed as the corresponding [n]); a function Integer -> Integer; a function Rational -> Rational; a function Float32 -> Float32; a function Float64 -> Float64; a function mapping an array of length 16 of 8-bit sequences to the same; functions over records: empty record -> empty record, a record with field x of 8 bits to itself, and a record with fields x (8 bits) and y (16 bits) to itself; functions over tuples: unit -> unit and a pair (8-bit, 16-bit) to itself; a function N -> N; a function Option [8] -> Option [8]; a function Result [16] [32] -> Result [16] [32]; a curried function taking two 8-bit sequences and returning an 8-bit sequence; a function taking a 128-bit sequence and returning a pair of 128-bit sequences; a function Z 7 -> Z 7; and a polymorphic value with implicit numeric parameter n, constrained to be finite and at least 1, returning Z n. Mark each declared symbol as foreign abstract and give precise Cryptol type signatures matching these descriptions."},{"role":"assistant","content":"```cryptol\nmodule Example where\n\nimport Float\n\nnewtype N = { unN : [8] }\n\nforeign abstract test_bool : Bit -> Bit\nforeign abstract test_u8 : [8] -> [8]\nforeign abstract test_u16 : [16] -> [16]\nforeign abstract test_u32 : [32] -> [32]\nforeign abstract test_u64 : [64] -> [64]\nforeign abstract test_u128 : [128] -> [128]\nforeign abstract test_i8 : [8] -> [8]\nforeign abstract test_i16 : [16] -> [16]\nforeign abstract test_i32 : [32] -> [32]\nforeign abstract test_i64 : [64] -> [64]\nforeign abstract test_i128 : [128] -> [128]\nforeign abstract test_integer : Integer -> Integer\nforeign abstract test_rational : Rational -> Rational\nforeign abstract test_float : Float32 -> Float32\nforeign abstract test_double : Float64 -> Float64\nforeign abstract test_array_16_u8 : [16][8] -> [16][8]\nforeign abstract test_record0 : {} -> {}\nforeign abstract test_record1_u8 : { x : [8] } -> { x : [8] }\nforeign abstract test_record2_u8_u16 : { x : [8], y : [16] } -> { x : [8], y : [16] }\nforeign abstract test_tuple0 : () -> ()\nforeign abstract test_tuple2_u8_u16 : ([8], [16]) -> ([8], [16])\nforeign abstract test_newtype_u8 : N -> N\nforeign abstract test_option_u8 : Option [8] -> Option [8]\nforeign abstract test_result_u16_u32 : Result [16] [32] -> Result [16] [32]\nforeign abstract test_two_u8_args : [8] -> [8] -> [8]\nforeign abstract test_two_u128_res : [128] -> ([128], [128])\nforeign abstract test_z7 : Z 7 -> Z 7\nforeign abstract test_param : {n} (fin n, n >= 1) => Z n\n```"}]}
{"filename":"cryptol\/tests\/modsys\/T007.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a parameterized submodule named F that accepts a numeric type parameter n and a value parameter x of type [n], with constraints that n is finite and at least 4. Inside F, declare y with type [n] and define it as the modular sum of x and the literal 11 (addition modulo 2^n). Next, define a concrete submodule I that fixes n to 8 and assigns x the literal 2 with type [8]. Instantiate F using the parameters from I to create a submodule named M. Finally, import the instantiated submodule under the alias M."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type n : #\n    x      : [n]\n    type constraint (fin n, n >= 4)\n\n  y : [n]\n  y = x + 11\n\nsubmodule I where\n  type n = 8\n  x = 2\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/enum\/CheckEnumPartialError.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an algebraic data type parameterized by an element type to represent an optional value with two constructors: one for absence and one wrapping a present value. Then define two polymorphic functions with type parameters a and b that each take a unary function from a to b and an optional a, and return an optional b. Make both definitions intentionally non-exhaustive via case analysis: the first handles only the present-value constructor and returns a present transformed value; the second handles only the absence constructor and returns absence. Next, define an enumeration type with exactly three distinct nullary constructors. Provide one function from this enum to the unit type that matches only the first constructor (intentionally non-exhaustive). Finally, provide a second function from the same enum to unit that is total by matching the first constructor explicitly and using a wildcard branch to handle all remaining constructors. Use appropriate Cryptol type signatures and case expressions to illustrate the partial and total pattern matches."},{"role":"assistant","content":"```cryptol\nenum Maybe a = Nothing | Just a\n\nmaybeMapBad1 : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMapBad1 f m =\n  case m of\n    Just x -> Just (f x)\n\nmaybeMapBad2 : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMapBad2 f m =\n  case m of\n    Nothing -> Nothing\n\nenum Foo = A | B | C\n\nfooBad1 : Foo -> ()\nfooBad1 f =\n  case f of\n    A -> ()\n\nfooGood : Foo -> ()\nfooGood f =\n  case f of\n    A -> ()\n    _ -> ()\n```"}]}
{"filename":"cryptol\/tests\/enum\/CheckProveEnum.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define enumerations for Maybe a (with absence or a value), Either a b (with left or right value), Foo a (three nullary variants and one carrying an 8-bit word and a value), and Letter (three symbols). Provide equality predicates maybeEqual, eitherEqual, fooEqual with types returning Bit and using Eq constraints where needed to compare only when constructors match and, for parameterized cases, using the underlying equality. Define mapping functions: maybeMap to apply a function only to a present value; eitherMapLeft and eitherMapRight to map over left or right, and eitherMapBoth to map both in one pass; fooMap to map only the value field of the binary Foo constructor, leaving the 8-bit field and other variants unchanged; letterRotate to cycle the three letters. Define a property that for Maybe [8], mapping (+1) twice equals mapping (+2) once, compared via maybeEqual. Define a property that for Either [8] [8], applying (+1) to the right then to the left equals mapping both once, compared via eitherEqual. Define a property that for Foo [8], mapping (+1) twice equals mapping (+2) once, compared via fooEqual. Define a property that for Letter, rotating three times yields the original value, checked by letterEqual."},{"role":"assistant","content":"```cryptol\nenum Maybe a = Nothing | Just a\n\nmaybeEqual : {a} (Eq a) => Maybe a -> Maybe a -> Bit\nmaybeEqual m1 m2 =\n  case m1 of\n    Just x1 ->\n      case m2 of\n        Just x2 -> x1 == x2\n        Nothing -> False\n    Nothing ->\n      case m2 of\n        Just x2 -> False\n        Nothing -> True\n\nmaybeMap : {a, b} (a -> b) -> Maybe a -> Maybe b\nmaybeMap f m =\n  case m of\n    Just x  -> Just (f x)\n    Nothing -> Nothing\n\nmaybeMapProp : Maybe [8] -> Bit\nproperty maybeMapProp m =\n  maybeEqual\n    (maybeMap (\\x -> x + 1) (maybeMap (\\x -> x + 1) m))\n    (maybeMap (\\x -> x + 2) m)\n\nenum Either a b = Left a | Right b\n\neitherEqual : {a, b} (Eq a, Eq b) => Either a b -> Either a b -> Bit\neitherEqual e1 e2 =\n  case e1 of\n    Left x1 ->\n      case e2 of\n        Left x2  -> x1 == x2\n        Right y2 -> False\n    Right y1 ->\n      case e2 of\n        Left x2  -> False\n        Right y2 -> y1 == y2\n\neitherMapLeft : {a, a', b} (a -> a') -> Either a b -> Either a' b\neitherMapLeft f e =\n  case e of\n    Left x  -> Left (f x)\n    Right y -> Right y\n\neitherMapRight : {a, b, b'} (b -> b') -> Either a b -> Either a b'\neitherMapRight g e =\n  case e of\n    Left x  -> Left x\n    Right y -> Right (g y)\n\neitherMapBoth : {a, a', b, b'} (a -> a') -> (b -> b') -> Either a b -> Either a' b'\neitherMapBoth f g e =\n  case e of\n    Left x  -> Left (f x)\n    Right y -> Right (g y)\n\neitherMapProp : Either [8] [8] -> Bit\nproperty eitherMapProp e =\n  eitherEqual\n    (eitherMapLeft (\\x -> x + 1) (eitherMapRight (\\y -> y + 1) e))\n    (eitherMapBoth (\\x -> x + 1) (\\y -> y + 1) e)\n\nenum Foo a = Bar | Baz | Quux | Fred [8] a\n\nfooEqual : {a} (Eq a) => Foo a -> Foo a -> Bit\nfooEqual f1 f2 =\n  case f1 of\n    Bar ->\n      case f2 of\n        Bar        -> True\n        Baz        -> False\n        Quux       -> False\n        Fred y1 y2 -> False\n    Baz ->\n      case f2 of\n        Bar        -> False\n        Baz        -> True\n        Quux       -> False\n        Fred y1 y2 -> False\n    Quux ->\n      case f2 of\n        Bar        -> False\n        Baz        -> False\n        Quux       -> True\n        Fred y1 y2 -> False\n    Fred x1 x2 ->\n      case f2 of\n        Bar        -> False\n        Baz        -> False\n        Quux       -> False\n        Fred y1 y2 -> (x1 == y1) \/\\ (x2 == y2)\n\nfooMap : {a, b} (a -> b) -> Foo a -> Foo b\nfooMap f ff =\n  case ff of\n    Bar      -> Bar\n    Baz      -> Baz\n    Quux     -> Quux\n    Fred x y -> Fred x (f y)\n\nfooMapProp : Foo [8] -> Bit\nproperty fooMapProp f =\n  fooEqual\n    (fooMap (\\x -> x + 1) (fooMap (\\x -> x + 1) f))\n    (fooMap (\\x -> x + 2) f)\n\nenum Letter = A | B | C\n\nletterEqual : Letter -> Letter -> Bit\nletterEqual l1 l2 =\n  case l1 of\n    A ->\n      case l2 of\n        A -> True\n        B -> False\n        C -> False\n    B ->\n      case l2 of\n        A -> False\n        B -> True\n        C -> False\n    C ->\n      case l2 of\n        A -> False\n        B -> False\n        C -> True\n\nletterRotate : Letter -> Letter\nletterRotate l =\n  case l of\n    A -> B\n    B -> C\n    C -> A\n\nletterRotateProp : Letter -> Bit\nproperty letterRotateProp l =\n  letterEqual l (letterRotate (letterRotate (letterRotate l)))\n```"}]}
{"filename":"cryptol\/tests\/parser\/tuples-records.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define constants with explicit type annotations for: (1) a pair named tuple containing two 8-bit values equal to 0xFF; (2) a pair named nested_tuple1 whose first element is an 8-bit 0xFF and whose second element is a pair of two 8-bit 0xFF values; (3) a pair named nested_tupel2 whose first element is a pair of two 8-bit 0xFF values and whose second element is an 8-bit 0xFF; (4) an empty tuple named empty_tuple with unit type; (5) a record named record with fields x and y, each an 8-bit 0xFF; (6) a record named nested_record with field x as an 8-bit 0xFF and field y as a record with fields x and y each an 8-bit 0xFF; and (7) an empty record named empty_records. Ensure all literals use the 8-bit word type and that each definition\u2019s type precisely matches its structure (e.g., pairs vs nested pairs, flat record vs nested record, and empty tuple\/record types). Do not provide implementations beyond these annotated constant declarations."},{"role":"assistant","content":"```cryptol\ntuple           = (0xFF, 0xFF)\nnested_tuple1   = (0xFF, (0xFF,0xFF))\nnested_tupel2   = ((0xFF,0xFF), 0xFF)\nempty_tuple     = ()\n\nrecord          = { x = 0xFF, y = 0xFF }\nnested_record   = { x = 0xFF, y = { x = 0xFF, y = 0xFF }}\nempty_records   = {}\n```"}]}
{"filename":"cryptol\/tests\/parser\/docs.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the following:\n- A constant named test1 with an explicit type of a single-bit boolean and value true.\n- A constant named test2 with value true, relying on type inference (no explicit type signature).\n- A unary function named test3 that returns its input unchanged and is fully polymorphic over its argument type.\n- Define a property named test4 that takes one argument, constrains it to be a single-bit boolean via a type annotation, and uses that annotated value as the property\u2019s boolean result.\n- Declare an infix operator named ++ with left associativity and precedence 5; give it the polymorphic type for all types a: a -> a -> a; define it to return its first operand, ignoring the second.\n- A private constant named test5 whose value is the unit value.\n- A type synonym named Foo that is equal to the unit type.\nInclude the necessary type signatures where specified and ensure the visibility and fixity declarations match the description. Do not provide any proofs or evaluations; only the specification elements described above."},{"role":"assistant","content":"```cryptol\ntest1 : Bit\ntest1 = True\n\ntest2 = True\n\ntest3 x = x\n\nproperty test4 x = (x : Bit)\n\ninfixl 5 ++\n\n(++) : {a} a -> a -> a\nx ++ _ = x\n\nprivate test5 = ()\n\ntype Foo = ()\n```"}]}
{"filename":"cryptol\/tests\/parser\/T437.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the following artifacts mirroring the described behaviors and types: (1) A polymorphic function mk_buggy_fib_no_init with a size parameter a constrained to be finite and at least 1. It takes: (i) a counter target value of a bits (magic), and (ii) a pair whose first element is a single-bit input (ignored) and whose second element is a state triple (x, y, k) where x and y are 8-bit words and k is an a-bit counter. It returns a pair of: an 8-bit output and an updated state triple. The next state is (y, x+y, k+1), with arithmetic modulo the respective widths. The output equals x plus 1 precisely when k equals magic; otherwise it equals x. Provide the corresponding type signature. (2) A generic function generate parameterized by n, ix, and element type a, with constraints that ix and n are finite, n \u2265 1, and ix is at least the bit-width of n\u22121. It takes a function from an ix-bit index to an element and returns a sequence of length n computed by enumerating indices 0..n\u22121. Provide its type signature and definition. (3) A left-associative infix operator $ with precedence level 1 that performs simple function application (apply a unary function to its argument). (4) Two constants foo and bar, each a sequence of length 10 of 4-bit elements. Each is produced by the generator applied to a lambda over an 8-bit index i, yielding 1 at index 0 and otherwise the previous element at index i\u22121. Define foo using the $ operator and bar using direct application; both must have identical behavior and type."},{"role":"assistant","content":"```cryptol\nmk_buggy_fib_no_init : {a} (fin a, a >= 1) => [a] ->\n  ([1], ([8], [8], [a])) -> ([8], ([8], [8], [a]))\nmk_buggy_fib_no_init magic (_, (fn, fn1, k)) = (fn', (fn1, fn2, k+1))\n  where\n  fn2 = fn + fn1\n  \/\/ Change output when state has magic value.\n  fn' = fn + if k == magic then 1 else 0\n\ngenerate : {n, ix, a} (fin ix, fin n, n >= 1, ix >= width (n - 1)) => ([ix] -> a) -> [n]a\ngenerate f = [ f i | i <- [0 .. n-1] ]\n\ninfixl 1 $\nf $ x = f x\n\nfoo : [10][4]\nfoo = generate $ \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n\nbar : [10][4]\nbar = generate \\(i:[8]) -> if i == 0 then 1 else foo@(i-1)\n```"}]}
{"filename":"cryptol\/tests\/parser\/unary.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two properties that verify unary operator precedence over addition for 8-bit words. For the first property, assert that for the 8-bit value 5, applying the bitwise complement and then adding 2 is equal to explicitly parenthesizing the complemented value and then adding 2. For the second property, assert the analogous equivalence for unary arithmetic negation and addition by 2. Annotate the literal 5 as an 8-bit word so both sides of each equality have type [8], and ensure each property returns a Boolean result by comparing the two [8]-typed expressions for equality."},{"role":"assistant","content":"```cryptol\ntest1 = (~ (5 : [8]) + 2) == (~ (5 : [8])) + 2\ntest2 = (- (5 : [8]) + 2) == (- (5 : [8])) + 2\n```"}]}
{"filename":"cryptol\/tests\/parser\/pat1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines seven functions using pattern matching with complete, generalized type signatures and necessary size parameters and constraints: (1) a function that takes a 2-tuple and returns its first component (fully polymorphic over element types); (2) a function that, given a sequence known to be the concatenation of two subsequences, returns the left subsequence (polymorphic over element type and lengths m and n, with input length m+n and result length m); (3) a function that consumes a sequence of exactly three elements of an arithmetic type and returns the sum of its three elements; (4) a function that takes a record with exactly two fields, binds both fields to new names in the pattern, and returns the value of the first field; (5) a function that destructures an input formed by concatenating an 8-element left segment with a 10-element right segment and returns their concatenation, ensuring the right segment is explicitly annotated as length 10 in the result; (6) a function that, given an input that is a concatenation whose right segment has length 10, returns the left segment (left length is size-polymorphic); (7) a function identical in behavior to (6) but written so the right segment\u2019s length-10 annotation is parenthesized in the pattern. Use tuple, sequence, list, and record patterns as appropriate. Provide explicit type signatures with size parameters in braces, and include any required arithmetic constraints for addition. Do not include tests; only the definitions."},{"role":"assistant","content":"```cryptol\nf1 (x,y) = x\nf2 (x # y) = x\nf3 [x,y,z] = x + y + z\nf4 {x = a, y = b } = a\nf5 ((x : [8]) # (y : [10])) = x # y : [10]\nf6 (x # y : [10]) = x\nf7 (x # (y : [10])) = x\n```"}]}
{"filename":"cryptol\/tests\/parser\/infix-1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two infix operators named ++ and ** with left associativity. Assign precedence levels 4 for ++ and 5 for ** so that ** binds tighter than ++. Provide a type signature for ++ that takes two 8-bit sequences and returns an 8-bit sequence, and define it to compute their sum using 8-bit addition. Provide a polymorphic type signature for ** with a single type variable constrained by the Ring type class; it takes two values of that type and returns their product, implemented via ring multiplication. Include the infix declarations, type signatures, and definitions."},{"role":"assistant","content":"```cryptol\ninfixl 4 ++\ninfixl 5 **\n\n(++) : [8] -> [8] -> [8]\nx ++ y = x + y\n\n(**) : {a} (Ring a) => a -> a -> a\nx ** y = x * y\n```"}]}
{"filename":"cryptol\/tests\/parser\/applications.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) defines an identity function over finite bitvectors and a function that returns its second argument, each with fully polymorphic type signatures over any finite width; (2) defines nine 8-bit constants exercising function application and modular arithmetic, including: applying the identity to a byte; applying the second-argument function to two bytes; the sum of two identical bytes; a left-associative sum of three small bytes; an expression where multiplication binds tighter than addition; an expression where a product is added to a byte; an expression where a product uses the result of the identity function and then is added to a byte; an application of the second-argument function where the first argument is a parenthesized arithmetic expression and the second is a byte; and a nested application of the identity function to a byte. For each constant, declare a property that equates it to the expected byte result under 8-bit modular arithmetic and additional properties that equate pairs of expressions that should be parsed identically due to precedence and associativity (e.g., function application binding tighter than infix operators, multiplication binding tighter than addition, and left-associative addition). Clearly state all type constraints (finite sequence widths) and ensure every numeric literal and arithmetic expression is 8 bits."},{"role":"assistant","content":"```cryptol\ng x   = x\nf x y = y\n\napp1 = g 0xFF\napp2 = f 0xFF 0xFF\napp3 = 0xFF + 0xFF\napp4 = 0x01 + 0x02 + 0x03\napp5 = 0x01 + 0x02 * 0x03\napp6 = 0x01 * 0x02 + 0x03\napp7 = 0x01 * g 0xFF + 0x02\napp8 = f (0x01 * g 0xFF + 0x02) 0xFF\napp9 = g (g 0xFF)\n```"}]}
{"filename":"cryptol\/tests\/suiteb\/aes-mct-ecb.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that implements AES ECB Monte Carlo Tests for 128-, 192-, and 256-bit keys and verifies them against known vectors. Define a record type parameterized by key size n with fields: a key of n bits, a 128-bit plaintext, and a 128-bit ciphertext. Define functions mct_ecb_encrypt_128, mct_ecb_decrypt_128, mct_ecb_encrypt_192, mct_ecb_decrypt_192, mct_ecb_encrypt_256, and mct_ecb_decrypt_256 with types [n] -> [128] -> [100] of that record (where n is 128, 192, or 256). Each function performs 100 batches of 1000 chained ECB operations: for batch i, encrypt (or decrypt) a stream whose first block is the provided initial block and subsequent blocks are the previous batch\u2019s outputs; within the full 100,000-block stream select, for each batch i, the first input and the 1000th output as that batch\u2019s plaintext and ciphertext; record the current batch key. Maintain a vector of 100 keys: start with the initial key and update between batches by XOR with a 128\/192\/256-bit value derived from the first two outputs of the previous batch as follows: for 128, use the first block; for 192, concatenate the low 64 bits of the second block with the first block; for 256, concatenate the first two blocks. Build a vector of 100 key schedules by mapping the appropriate AES schedule function over the 100 keys; for block index j, use the schedule at floor(j\/1000). Define four constants holding the 100-record expected vectors for 128\/192\/256 encryption and decryption. Define six properties that the expected vectors equal the results of the corresponding functions when applied to the specified initial key and initial 128-bit block for each case."},{"role":"assistant","content":"```cryptol\nimport SuiteB\n\ntype AESTestVector n =\n  { key        : [n]\n  , plaintext  : [128]\n  , ciphertext : [128]\n  }\n\nmct_ecb_encrypt_128 : [128] -> [128] -> [100](AESTestVector 128)\nmct_ecb_encrypt_128 initialKey initialPt = vs\n  where\n  vs@i = { key = keys@i, plaintext=pts@(i*1000), ciphertext=cts@(i*1000 + 999) }\n\n  pts : [100*1000][128]\n  pts = [initialPt] # take cts\n\n  cts : [100*1000][128]\n  cts@i = aesEncryptBlock (schedules@(i\/1000)) (pts@i)\n\n  keys : [100][128]\n  keys = [initialKey] # [ k ^ (xs!0)\n                        | xs <- take`{99} (groupBy`{1000} cts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESEncryptKeySchedule AES128)\n  schedules = map aes128EncryptSchedule keys\n\nmct_ecb_decrypt_128 : [128] -> [128] -> [100](AESTestVector 128)\nmct_ecb_decrypt_128 initialKey initialCt = vs\n  where\n  vs@i = { key = keys@i, ciphertext=cts@(i*1000), plaintext=pts@(i*1000 + 999) }\n\n  cts : [100*1000][128]\n  cts = [initialCt] # take pts\n\n  pts : [100*1000][128]\n  pts@i = aesDecryptBlock (schedules@(i\/1000)) (cts@i)\n\n  keys : [100][128]\n  keys = [initialKey] # [ k ^ (xs!0)\n                        | xs <- take`{99} (groupBy`{1000} pts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESDecryptKeySchedule AES128)\n  schedules = map aes128DecryptSchedule keys\n\nproperty aes128_MCT_vectors_encrypt_correct =\n  aes128_MCT_encrypt_test_vectors ==\n  mct_ecb_encrypt_128 0x139a35422f1d61de3c91787fe0507afd 0xb9145a768b7dc489a096b546f43b231f\n\nproperty aes128_MCT_vectors_decrypt_correct =\n  aes128_MCT_decrypt_test_vectors ==\n  mct_ecb_decrypt_128 0x0c60e7bf20ada9baa9e1ddf0d1540726 0xb08a29b11a500ea3aca42c36675b9785\n\naes128_MCT_encrypt_test_vectors : [100](AESTestVector 128)\naes128_MCT_encrypt_test_vectors =\n [{ key = 0x139a35422f1d61de3c91787fe0507afd\n  , plaintext = 0xb9145a768b7dc489a096b546f43b231f\n  , ciphertext = 0xd7c3ffac9031238650901e157364c386\n  },\n\n  { key = 0xc459caeebf2c42586c01666a9334b97b\n  , plaintext = 0xd7c3ffac9031238650901e157364c386\n  , ciphertext = 0xbc3637da2daf8fcf7c68bb28c143a0a4\n  },\n\n  { key = 0x786ffd349283cd971069dd42527719df\n  , plaintext = 0xbc3637da2daf8fcf7c68bb28c143a0a4\n  , ciphertext = 0x9c88a8db798f48df1ac4936afa959eac\n  },\n\n  { key = 0xe4e755efeb0c85480aad4e28a8e28773\n  , plaintext = 0x9c88a8db798f48df1ac4936afa959eac\n  , ciphertext = 0xb87aaa1c76a775d94c2ddf82abe5c66e\n  },\n\n  { key = 0x5c9dfff39dabf091468091aa0307411d\n  , plaintext = 0xb87aaa1c76a775d94c2ddf82abe5c66e\n  , ciphertext = 0x79ee212734f14d1bf5a59d46e8c2fa34\n  },\n\n  { key = 0x2573ded4a95abd8ab3250cecebc5bb29\n  , plaintext = 0x79ee212734f14d1bf5a59d46e8c2fa34\n  , ciphertext = 0x09df49135aeb8e373a19fa457ab280a0\n  },\n\n  { key = 0x2cac97c7f3b133bd893cf6a991773b89\n  , plaintext = 0x09df49135aeb8e373a19fa457ab280a0\n  , ciphertext = 0xc52263efa6379209d17e87ac250615cb\n  },\n\n  { key = 0xe98ef4285586a1b458427105b4712e42\n  , plaintext = 0xc52263efa6379209d17e87ac250615cb\n  , ciphertext = 0x336bed017e10a247ee92989862431163\n  },\n\n  { key = 0xdae519292b9603f3b6d0e99dd6323f21\n  , plaintext = 0x336bed017e10a247ee92989862431163\n  , ciphertext = 0xb13310581ffe5b10aaefdeb8992aec18\n  },\n\n  { key = 0x6bd60971346858e31c3f37254f18d339\n  , plaintext = 0xb13310581ffe5b10aaefdeb8992aec18\n  , ciphertext = 0xb0eaede3f3eebfef88822a6ede1950b1\n  },\n\n  { key = 0xdb3ce492c786e70c94bd1d4b91018388\n  , plaintext = 0xb0eaede3f3eebfef88822a6ede1950b1\n  , ciphertext = 0x37891fc253b00de13155d5517e1b7890\n  },\n\n  { key = 0xecb5fb509436eaeda5e8c81aef1afb18\n  , plaintext = 0x37891fc253b00de13155d5517e1b7890\n  , ciphertext = 0x8f574c85fa44af2d43c95ee5f627fc9d\n  },\n\n  { key = 0x63e2b7d56e7245c0e62196ff193d0785\n  , plaintext = 0x8f574c85fa44af2d43c95ee5f627fc9d\n  , ciphertext = 0x6c0af6709225f328a0225b2280efa3e3\n  },\n\n  { key = 0x0fe841a5fc57b6e84603cddd99d2a466\n  , plaintext = 0x6c0af6709225f328a0225b2280efa3e3\n  , ciphertext = 0xe2dc36073fe192e712373a8702e8adce\n  },\n\n  { key = 0xed3477a2c3b6240f5434f75a9b3a09a8\n  , plaintext = 0xe2dc36073fe192e712373a8702e8adce\n  , ciphertext = 0x1e91d1e1f82f1d320186210a792f7ba1\n  },\n\n  { key = 0xf3a5a6433b99393d55b2d650e2157209\n  , plaintext = 0x1e91d1e1f82f1d320186210a792f7ba1\n  , ciphertext = 0x228eac74166da261d7fa83f43d9ddd2f\n  },\n\n  { key = 0xd12b0a372df49b5c824855a4df88af26\n  , plaintext = 0x228eac74166da261d7fa83f43d9ddd2f\n  , ciphertext = 0x25d0de6a894361a1b83d5fa2fd607f26\n  },\n\n  { key = 0xf4fbd45da4b7fafd3a750a0622e8d000\n  , plaintext = 0x25d0de6a894361a1b83d5fa2fd607f26\n  , ciphertext = 0x36095dc3e659ec50ca7f6f8207d20031\n  },\n\n  { key = 0xc2f2899e42ee16adf00a6584253ad031\n  , plaintext = 0x36095dc3e659ec50ca7f6f8207d20031\n  , ciphertext = 0x8dbfe965078468875d86145164c4ab4f\n  },\n\n  { key = 0x4f4d60fb456a7e2aad8c71d541fe7b7e\n  , plaintext = 0x8dbfe965078468875d86145164c4ab4f\n  , ciphertext = 0x4032bb8137d4b9eb93644359a995bb4e\n  },\n\n  { key = 0x0f7fdb7a72bec7c13ee8328ce86bc030\n  , plaintext = 0x4032bb8137d4b9eb93644359a995bb4e\n  , ciphertext = 0x85308aa92c625a25bd5f4a40375c6baa\n  },\n\n  { key = 0x8a4f51d35edc9de483b778ccdf37ab9a\n  , plaintext = 0x85308aa92c625a25bd5f4a40375c6baa\n  , ciphertext = 0x73283fc59e04e80a867e478d97a3f388\n  },\n\n  { key = 0xf9676e16c0d875ee05c93f4148945812\n  , plaintext = 0x73283fc59e04e80a867e478d97a3f388\n  , ciphertext = 0x418c1fe377e4ef9832f20286b167f916\n  },\n\n  { key = 0xb8eb71f5b73c9a76373b3dc7f9f3a104\n  , plaintext = 0x418c1fe377e4ef9832f20286b167f916\n  , ciphertext = 0x60ad1341525e67cffdd68ff671253c77\n  },\n\n  { key = 0xd84662b4e562fdb9caedb23188d69d73\n  , plaintext = 0x60ad1341525e67cffdd68ff671253c77\n  , ciphertext = 0x4edf6e01a76de6153d17713a49d5b028\n  },\n\n  { key = 0x96990cb5420f1bacf7fac30bc1032d5b\n  , plaintext = 0x4edf6e01a76de6153d17713a49d5b028\n  , ciphertext = 0x2c85ebf9e3d80596f78712df56ac77cd\n  },\n\n  { key = 0xba1ce74ca1d71e3a007dd1d497af5a96\n  , plaintext = 0x2c85ebf9e3d80596f78712df56ac77cd\n  , ciphertext = 0x8fc8ef9ab7462712977e87c741795ece\n  },\n\n  { key = 0x35d408d61691392897035613d6d60458\n  , plaintext = 0x8fc8ef9ab7462712977e87c741795ece\n  , ciphertext = 0x37e9ac800cfb19133b4e9b0c418ca098\n  },\n\n  { key = 0x023da4561a6a203bac4dcd1f975aa4c0\n  , plaintext = 0x37e9ac800cfb19133b4e9b0c418ca098\n  , ciphertext = 0xcb7cd7619caa605e45f95f5b31a85495\n  },\n\n  { key = 0xc941733786c04065e9b49244a6f2f055\n  , plaintext = 0xcb7cd7619caa605e45f95f5b31a85495\n  , ciphertext = 0x6e265e5fd030847b8841bf6652996392\n  },\n\n  { key = 0xa7672d6856f0c41e61f52d22f46b93c7\n  , plaintext = 0x6e265e5fd030847b8841bf6652996392\n  , ciphertext = 0x5c9a7d2ce1c86f0b3425b3b6aae108e0\n  },\n\n  { key = 0xfbfd5044b738ab1555d09e945e8a9b27\n  , plaintext = 0x5c9a7d2ce1c86f0b3425b3b6aae108e0\n  , ciphertext = 0xc911dee5ff318a7e799f92daadcb3d9a\n  },\n\n  { key = 0x32ec8ea14809216b2c4f0c4ef341a6bd\n  , plaintext = 0xc911dee5ff318a7e799f92daadcb3d9a\n  , ciphertext = 0x7a3afdf10410f1c47c7d928d4a8d432a\n  },\n\n  { key = 0x48d673504c19d0af50329ec3b9cce597\n  , plaintext = 0x7a3afdf10410f1c47c7d928d4a8d432a\n  , ciphertext = 0xc681b7b6d3ec9dc91012e3b7427c67ad\n  },\n\n  { key = 0x8e57c4e69ff54d6640207d74fbb0823a\n  , plaintext = 0xc681b7b6d3ec9dc91012e3b7427c67ad\n  , ciphertext = 0xcd3f84bbe958536d502065eb37ae10b4\n  },\n\n  { key = 0x4368405d76ad1e0b1000189fcc1e928e\n  , plaintext = 0xcd3f84bbe958536d502065eb37ae10b4\n  , ciphertext = 0x879db797e686b9116c25c07f4ae67593\n  },\n\n  { key = 0xc4f5f7ca902ba71a7c25d8e086f8e71d\n  , plaintext = 0x879db797e686b9116c25c07f4ae67593\n  , ciphertext = 0x5959ebd7a1167713429eda69538c536b\n  },\n\n  { key = 0x9dac1c1d313dd0093ebb0289d574b476\n  , plaintext = 0x5959ebd7a1167713429eda69538c536b\n  , ciphertext = 0xf57101d7fa19f97a31d60b276312717c\n  },\n\n  { key = 0x68dd1dcacb2429730f6d09aeb666c50a\n  , plaintext = 0xf57101d7fa19f97a31d60b276312717c\n  , ciphertext = 0x6dfbbc2b147568c55adbfdc3c706edb0\n  },\n\n  { key = 0x0526a1e1df5141b655b6f46d716028ba\n  , plaintext = 0x6dfbbc2b147568c55adbfdc3c706edb0\n  , ciphertext = 0x9c4ea9002306d75e7b0f03e2a72b7a1d\n  },\n\n  { key = 0x996808e1fc5796e82eb9f78fd64b52a7\n  , plaintext = 0x9c4ea9002306d75e7b0f03e2a72b7a1d\n  , ciphertext = 0xcb9975336cc05f0114f26bde4cc84f8d\n  },\n\n  { key = 0x52f17dd29097c9e93a4b9c519a831d2a\n  , plaintext = 0xcb9975336cc05f0114f26bde4cc84f8d\n  , ciphertext = 0x902c4250cff110d792938e8dcd534cf0\n  },\n\n  { key = 0xc2dd3f825f66d93ea8d812dc57d051da\n  , plaintext = 0x902c4250cff110d792938e8dcd534cf0\n  , ciphertext = 0x140242f195ef2ef7f6ee23574c071311\n  },\n\n  { key = 0xd6df7d73ca89f7c95e36318b1bd742cb\n  , plaintext = 0x140242f195ef2ef7f6ee23574c071311\n  , ciphertext = 0x3c6d4ffafde866f1e994480c47d20a04\n  },\n\n  { key = 0xeab2328937619138b7a279875c0548cf\n  , plaintext = 0x3c6d4ffafde866f1e994480c47d20a04\n  , ciphertext = 0x1ca04a21addc38ef8bfc8989d3d6b33b\n  },\n\n  { key = 0xf61278a89abda9d73c5ef00e8fd3fbf4\n  , plaintext = 0x1ca04a21addc38ef8bfc8989d3d6b33b\n  , ciphertext = 0xbb8875ee3c3c8c0987b1c20f999028e9\n  },\n\n  { key = 0x4d9a0d46a68125debbef32011643d31d\n  , plaintext = 0xbb8875ee3c3c8c0987b1c20f999028e9\n  , ciphertext = 0x9d33724d80a76f2033a37a851403ef28\n  },\n\n  { key = 0xd0a97f0b26264afe884c488402403c35\n  , plaintext = 0x9d33724d80a76f2033a37a851403ef28\n  , ciphertext = 0x4c92fe152d16da8ea59b9f29c75f20ff\n  },\n\n  { key = 0x9c3b811e0b3090702dd7d7adc51f1cca\n  , plaintext = 0x4c92fe152d16da8ea59b9f29c75f20ff\n  , ciphertext = 0x659c76f73032b0192b281034b6a99a3f\n  },\n\n  { key = 0xf9a7f7e93b02206906ffc79973b686f5\n  , plaintext = 0x659c76f73032b0192b281034b6a99a3f\n  , ciphertext = 0x5d296637697ccad84fc77936a31c2655\n  },\n\n  { key = 0xa48e91de527eeab14938beafd0aaa0a0\n  , plaintext = 0x5d296637697ccad84fc77936a31c2655\n  , ciphertext = 0xa72a596a030d5541bc4d0fc739491d5b\n  },\n\n  { key = 0x03a4c8b45173bff0f575b168e9e3bdfb\n  , plaintext = 0xa72a596a030d5541bc4d0fc739491d5b\n  , ciphertext = 0x5f5ec53c91225717fcba470688dfa364\n  },\n\n  { key = 0x5cfa0d88c051e8e709cff66e613c1e9f\n  , plaintext = 0x5f5ec53c91225717fcba470688dfa364\n  , ciphertext = 0x5719cb14eba820c0d51109a0c7a4154f\n  },\n\n  { key = 0x0be3c69c2bf9c827dcdeffcea6980bd0\n  , plaintext = 0x5719cb14eba820c0d51109a0c7a4154f\n  , ciphertext = 0x3abd186712a9def73b6312b5300f02af\n  },\n\n  { key = 0x315edefb395016d0e7bded7b9697097f\n  , plaintext = 0x3abd186712a9def73b6312b5300f02af\n  , ciphertext = 0xb1e90c8c0d4c9651a6de7f52a63ac456\n  },\n\n  { key = 0x80b7d277341c80814163922930adcd29\n  , plaintext = 0xb1e90c8c0d4c9651a6de7f52a63ac456\n  , ciphertext = 0x5d26e33aae1441554034c77bde451679\n  },\n\n  { key = 0xdd91314d9a08c1d401575552eee8db50\n  , plaintext = 0x5d26e33aae1441554034c77bde451679\n  , ciphertext = 0x93e44cdce14803544a53bc5b520c156f\n  },\n\n  { key = 0x4e757d917b40c2804b04e909bce4ce3f\n  , plaintext = 0x93e44cdce14803544a53bc5b520c156f\n  , ciphertext = 0x8ee3b6fd953b441043f69f3747e4cf63\n  },\n\n  { key = 0xc096cb6cee7b869008f2763efb00015c\n  , plaintext = 0x8ee3b6fd953b441043f69f3747e4cf63\n  , ciphertext = 0xcb2f545970200630e5145f817a013807\n  },\n\n  { key = 0x0bb99f359e5b80a0ede629bf8101395b\n  , plaintext = 0xcb2f545970200630e5145f817a013807\n  , ciphertext = 0x50047276451ce19cb14d8d2ef0b3851b\n  },\n\n  { key = 0x5bbded43db47613c5caba49171b2bc40\n  , plaintext = 0x50047276451ce19cb14d8d2ef0b3851b\n  , ciphertext = 0xd243791dde33c2a4333ef4dcbcadbd3a\n  },\n\n  { key = 0x89fe945e0574a3986f95504dcd1f017a\n  , plaintext = 0xd243791dde33c2a4333ef4dcbcadbd3a\n  , ciphertext = 0x343181860092a5e33c2e1c441a9f6804\n  },\n\n  { key = 0xbdcf15d805e6067b53bb4c09d780697e\n  , plaintext = 0x343181860092a5e33c2e1c441a9f6804\n  , ciphertext = 0x4e7cdd553d732909e25a13a521e04078\n  },\n\n  { key = 0xf3b3c88d38952f72b1e15facf6602906\n  , plaintext = 0x4e7cdd553d732909e25a13a521e04078\n  , ciphertext = 0x9c16f3fda49bb6a2b6d76a6696bd768f\n  },\n\n  { key = 0x6fa53b709c0e99d0073635ca60dd5f89\n  , plaintext = 0x9c16f3fda49bb6a2b6d76a6696bd768f\n  , ciphertext = 0x9eb63f9099123591a4ca7aa0fff55a49\n  },\n\n  { key = 0xf11304e0051cac41a3fc4f6a9f2805c0\n  , plaintext = 0x9eb63f9099123591a4ca7aa0fff55a49\n  , ciphertext = 0xaa6a9e40aad692550b7c87b92b205af0\n  },\n\n  { key = 0x5b799aa0afca3e14a880c8d3b4085f30\n  , plaintext = 0xaa6a9e40aad692550b7c87b92b205af0\n  , ciphertext = 0xae92c267f38b9b4623df36523bb739b6\n  },\n\n  { key = 0xf5eb58c75c41a5528b5ffe818fbf6686\n  , plaintext = 0xae92c267f38b9b4623df36523bb739b6\n  , ciphertext = 0x39c0de843767dfa2d563c0632405d595\n  },\n\n  { key = 0xcc2b86436b267af05e3c3ee2abbab313\n  , plaintext = 0x39c0de843767dfa2d563c0632405d595\n  , ciphertext = 0x80a9445be75373b07476608feb1f1c7b\n  },\n\n  { key = 0x4c82c2188c7509402a4a5e6d40a5af68\n  , plaintext = 0x80a9445be75373b07476608feb1f1c7b\n  , ciphertext = 0x5306f5a77e42d9f4cee8f134ba1448c6\n  },\n\n  { key = 0x1f8437bff237d0b4e4a2af59fab1e7ae\n  , plaintext = 0x5306f5a77e42d9f4cee8f134ba1448c6\n  , ciphertext = 0x8db0c3fba7dc797cd175d97503759260\n  },\n\n  { key = 0x9234f44455eba9c835d7762cf9c475ce\n  , plaintext = 0x8db0c3fba7dc797cd175d97503759260\n  , ciphertext = 0x04fcb0c77ae0c98d2afb178ab2c2b02d\n  },\n\n  { key = 0x96c844832f0b60451f2c61a64b06c5e3\n  , plaintext = 0x04fcb0c77ae0c98d2afb178ab2c2b02d\n  , ciphertext = 0x1a156581b3557078971cc6877a3d9339\n  },\n\n  { key = 0x8cdd21029c5e103d8830a721313b56da\n  , plaintext = 0x1a156581b3557078971cc6877a3d9339\n  , ciphertext = 0xe47087289290fa2b6734eeaab2fc815d\n  },\n\n  { key = 0x68ada62a0eceea16ef04498b83c7d787\n  , plaintext = 0xe47087289290fa2b6734eeaab2fc815d\n  , ciphertext = 0x00ce641525020d35244e2227287b2a20\n  },\n\n  { key = 0x6863c23f2bcce723cb4a6bacabbcfda7\n  , plaintext = 0x00ce641525020d35244e2227287b2a20\n  , ciphertext = 0xecf623cef1e420d0994070c078592c97\n  },\n\n  { key = 0x8495e1f1da28c7f3520a1b6cd3e5d130\n  , plaintext = 0xecf623cef1e420d0994070c078592c97\n  , ciphertext = 0x256c8f28df4a286fb05514fcfa8cbcaf\n  },\n\n  { key = 0xa1f96ed90562ef9ce25f0f9029696d9f\n  , plaintext = 0x256c8f28df4a286fb05514fcfa8cbcaf\n  , ciphertext = 0xfd4aed4b5a2b8edefe3cc2aef6ecd298\n  },\n\n  { key = 0x5cb383925f4961421c63cd3edf85bf07\n  , plaintext = 0xfd4aed4b5a2b8edefe3cc2aef6ecd298\n  , ciphertext = 0xdfe0e571f77f0b46c52f003e774918ac\n  },\n\n  { key = 0x835366e3a8366a04d94ccd00a8cca7ab\n  , plaintext = 0xdfe0e571f77f0b46c52f003e774918ac\n  , ciphertext = 0xe421fbeb4c23745b97578162f89e68fc\n  },\n\n  { key = 0x67729d08e4151e5f4e1b4c625052cf57\n  , plaintext = 0xe421fbeb4c23745b97578162f89e68fc\n  , ciphertext = 0xc38c0bbde031d1a79438f79ff7cc68a5\n  },\n\n  { key = 0xa4fe96b50424cff8da23bbfda79ea7f2\n  , plaintext = 0xc38c0bbde031d1a79438f79ff7cc68a5\n  , ciphertext = 0x86113133968aa3052709875bf033d804\n  },\n\n  { key = 0x22efa78692ae6cfdfd2a3ca657ad7ff6\n  , plaintext = 0x86113133968aa3052709875bf033d804\n  , ciphertext = 0xfd706bef1bf30c8d1e95543b75629e02\n  },\n\n  { key = 0xdf9fcc69895d6070e3bf689d22cfe1f4\n  , plaintext = 0xfd706bef1bf30c8d1e95543b75629e02\n  , ciphertext = 0x9a5bbb6125152f1352b10e1c1a172aa6\n  },\n\n  { key = 0x45c47708ac484f63b10e668138d8cb52\n  , plaintext = 0x9a5bbb6125152f1352b10e1c1a172aa6\n  , ciphertext = 0x3ee69736488c51fa72784aa263618f45\n  },\n\n  { key = 0x7b22e03ee4c41e99c3762c235bb94417\n  , plaintext = 0x3ee69736488c51fa72784aa263618f45\n  , ciphertext = 0xfc66daa246ebcc320c7c89b599014633\n  },\n\n  { key = 0x87443a9ca22fd2abcf0aa596c2b80224\n  , plaintext = 0xfc66daa246ebcc320c7c89b599014633\n  , ciphertext = 0x35645885ed205d67e5caeff26646c38c\n  },\n\n  { key = 0xb22062194f0f8fcc2ac04a64a4fec1a8\n  , plaintext = 0x35645885ed205d67e5caeff26646c38c\n  , ciphertext = 0xdaeaa866aa4eacdb752caccb2c0ae6c1\n  },\n\n  { key = 0x68caca7fe54123175fece6af88f42769\n  , plaintext = 0xdaeaa866aa4eacdb752caccb2c0ae6c1\n  , ciphertext = 0x29e88b1ae615fcd06b09e767459d6089\n  },\n\n  { key = 0x412241650354dfc734e501c8cd6947e0\n  , plaintext = 0x29e88b1ae615fcd06b09e767459d6089\n  , ciphertext = 0x63470bff052e7f5c7a735cc2e6eb61ac\n  },\n\n  { key = 0x22654a9a067aa09b4e965d0a2b82264c\n  , plaintext = 0x63470bff052e7f5c7a735cc2e6eb61ac\n  , ciphertext = 0xf4fa6a3549cd2b33af9cac134d7b1402\n  },\n\n  { key = 0xd69f20af4fb78ba8e10af11966f9324e\n  , plaintext = 0xf4fa6a3549cd2b33af9cac134d7b1402\n  , ciphertext = 0x5b22a82ccbae9b9c75f797e74e6da53d\n  },\n\n  { key = 0x8dbd88838419103494fd66fe28949773\n  , plaintext = 0x5b22a82ccbae9b9c75f797e74e6da53d\n  , ciphertext = 0x87b51692f8f28743bd8dc843276f351a\n  },\n\n  { key = 0x0a089e117ceb97772970aebd0ffba269\n  , plaintext = 0x87b51692f8f28743bd8dc843276f351a\n  , ciphertext = 0x150fb2180704a7623a1fab8bf17fba18\n  },\n\n  { key = 0x1f072c097bef3015136f0536fe841871\n  , plaintext = 0x150fb2180704a7623a1fab8bf17fba18\n  , ciphertext = 0x8088874e7f3f09a98fd3f0a59f2a0b4b\n  },\n\n  { key = 0x9f8fab4704d039bc9cbcf59361ae133a\n  , plaintext = 0x8088874e7f3f09a98fd3f0a59f2a0b4b\n  , ciphertext = 0x08e02c091057d81c05d917ea5c07cdd0\n  },\n\n  { key = 0x976f874e1487e1a09965e2793da9deea\n  , plaintext = 0x08e02c091057d81c05d917ea5c07cdd0\n  , ciphertext = 0xb9636b3e2752694c3685872fd0a9a0ea\n  },\n\n  { key = 0x2e0cec7033d588ecafe06556ed007e00\n  , plaintext = 0xb9636b3e2752694c3685872fd0a9a0ea\n  , ciphertext = 0x2610dae2b64d74a8cbb4f43fa2d0a603\n  },\n\n  { key = 0x081c36928598fc44645491694fd0d803\n  , plaintext = 0x2610dae2b64d74a8cbb4f43fa2d0a603\n  , ciphertext = 0x9cc994eda697fb5545eaa502b2a30fd3\n  },\n\n  { key = 0x94d5a27f230f071121be346bfd73d7d0\n  , plaintext = 0x9cc994eda697fb5545eaa502b2a30fd3\n  , ciphertext = 0xfb2649694783b551eacd9d5db6126d47\n  }]\n\naes128_MCT_decrypt_test_vectors : [100](AESTestVector 128)\naes128_MCT_decrypt_test_vectors =\n [{ key = 0x0c60e7bf20ada9baa9e1ddf0d1540726\n  , ciphertext = 0xb08a29b11a500ea3aca42c36675b9785\n  , plaintext = 0xb613b87085fed1bb87f07a574e6d2879\n  },\n\n  { key = 0xba735fcfa55378012e11a7a79f392f5f\n  , ciphertext = 0xb613b87085fed1bb87f07a574e6d2879\n  , plaintext = 0x5541d7bf6d25c55c0c2296acba756e9e\n  },\n\n  { key = 0xef328870c876bd5d2233310b254c41c1\n  , ciphertext = 0x5541d7bf6d25c55c0c2296acba756e9e\n  , plaintext = 0x4c138198d55d0d87d43cdb92fb0b5fc0\n  },\n\n  { key = 0xa32109e81d2bb0daf60fea99de471e01\n  , ciphertext = 0x4c138198d55d0d87d43cdb92fb0b5fc0\n  , plaintext = 0x257c07bdcba57aff1643de90b63c0a88\n  },\n\n  { key = 0x865d0e55d68eca25e04c3409687b1489\n  , ciphertext = 0x257c07bdcba57aff1643de90b63c0a88\n  , plaintext = 0x8039be4e65d218d3e640f88309d01c6f\n  },\n\n  { key = 0x0664b01bb35cd2f6060ccc8a61ab08e6\n  , ciphertext = 0x8039be4e65d218d3e640f88309d01c6f\n  , plaintext = 0x0115dcd390855bf5ce32e946a6d5ad38\n  },\n\n  { key = 0x07716cc823d98903c83e25ccc77ea5de\n  , ciphertext = 0x0115dcd390855bf5ce32e946a6d5ad38\n  , plaintext = 0x71741ccb723348c7f3f9e4a397977bdb\n  },\n\n  { key = 0x7605700351eac1c43bc7c16f50e9de05\n  , ciphertext = 0x71741ccb723348c7f3f9e4a397977bdb\n  , plaintext = 0x668c9f3dc9e154bd16d61364a99f635d\n  },\n\n  { key = 0x1089ef3e980b95792d11d20bf976bd58\n  , ciphertext = 0x668c9f3dc9e154bd16d61364a99f635d\n  , plaintext = 0x124b19b2501a540066ddf7943417cba3\n  },\n\n  { key = 0x02c2f68cc811c1794bcc259fcd6176fb\n  , ciphertext = 0x124b19b2501a540066ddf7943417cba3\n  , plaintext = 0x23e7c95f7ed9017af339c234b7a8fcc4\n  },\n\n  { key = 0x21253fd3b6c8c003b8f5e7ab7ac98a3f\n  , ciphertext = 0x23e7c95f7ed9017af339c234b7a8fcc4\n  , plaintext = 0x7b0e1e1afe46c1e50785efb939f8ade3\n  },\n\n  { key = 0x5a2b21c9488e01e6bf700812433127dc\n  , ciphertext = 0x7b0e1e1afe46c1e50785efb939f8ade3\n  , plaintext = 0xc166aeebf5182c96d1f3c92cece9d714\n  },\n\n  { key = 0x9b4d8f22bd962d706e83c13eafd8f0c8\n  , ciphertext = 0xc166aeebf5182c96d1f3c92cece9d714\n  , plaintext = 0x71968762dc1b41bebd9ee8b2396b87be\n  },\n\n  { key = 0xeadb0840618d6cced31d298c96b37776\n  , ciphertext = 0x71968762dc1b41bebd9ee8b2396b87be\n  , plaintext = 0x77b0aa88222a785282352bb861ea0cd2\n  },\n\n  { key = 0x9d6ba2c843a7149c51280234f7597ba4\n  , ciphertext = 0x77b0aa88222a785282352bb861ea0cd2\n  , plaintext = 0xe65c461cba6957fe5b5ee5014c899e65\n  },\n\n  { key = 0x7b37e4d4f9ce43620a76e735bbd0e5c1\n  , ciphertext = 0xe65c461cba6957fe5b5ee5014c899e65\n  , plaintext = 0xa799870cee001551f3494bdf3c27bd94\n  },\n\n  { key = 0xdcae63d817ce5633f93facea87f75855\n  , ciphertext = 0xa799870cee001551f3494bdf3c27bd94\n  , plaintext = 0xf54697576153f97d9fb1a4d164a8538e\n  },\n\n  { key = 0x29e8f48f769daf4e668e083be35f0bdb\n  , ciphertext = 0xf54697576153f97d9fb1a4d164a8538e\n  , plaintext = 0xf3f1f964b98b3498898c3032e44a308c\n  },\n\n  { key = 0xda190debcf169bd6ef02380907153b57\n  , ciphertext = 0xf3f1f964b98b3498898c3032e44a308c\n  , plaintext = 0x40ccc3a26141900280a3a7b62d4ed8b6\n  },\n\n  { key = 0x9ad5ce49ae570bd46fa19fbf2a5be3e1\n  , ciphertext = 0x40ccc3a26141900280a3a7b62d4ed8b6\n  , plaintext = 0x7fcf64bd75808be6199f3fac0881d4d4\n  },\n\n  { key = 0xe51aaaf4dbd78032763ea01322da3735\n  , ciphertext = 0x7fcf64bd75808be6199f3fac0881d4d4\n  , plaintext = 0x11ca970c169315ff0b54ecdb00ba4547\n  },\n\n  { key = 0xf4d03df8cd4495cd7d6a4cc822607272\n  , ciphertext = 0x11ca970c169315ff0b54ecdb00ba4547\n  , plaintext = 0xbc02615754b58eb975c26190a3583d28\n  },\n\n  { key = 0x48d25caf99f11b7408a82d5881384f5a\n  , ciphertext = 0xbc02615754b58eb975c26190a3583d28\n  , plaintext = 0x5b12925c7f72aaafbae6834a6e9d5af9\n  },\n\n  { key = 0x13c0cef3e683b1dbb24eae12efa515a3\n  , ciphertext = 0x5b12925c7f72aaafbae6834a6e9d5af9\n  , plaintext = 0x7950ffe2537235bfaa38101c2a9e6d42\n  },\n\n  { key = 0x6a903111b5f184641876be0ec53b78e1\n  , ciphertext = 0x7950ffe2537235bfaa38101c2a9e6d42\n  , plaintext = 0xcdf5c997d8ddcc1de7cc47ecc47d0819\n  },\n\n  { key = 0xa765f8866d2c4879ffbaf9e2014670f8\n  , ciphertext = 0xcdf5c997d8ddcc1de7cc47ecc47d0819\n  , plaintext = 0x8f4d77bccc4858016b28c2e8f84dd9a3\n  },\n\n  { key = 0x28288f3aa164107894923b0af90ba95b\n  , ciphertext = 0x8f4d77bccc4858016b28c2e8f84dd9a3\n  , plaintext = 0x561d95847869cccc81df7df65d70808d\n  },\n\n  { key = 0x7e351abed90ddcb4154d46fca47b29d6\n  , ciphertext = 0x561d95847869cccc81df7df65d70808d\n  , plaintext = 0x17b9e6f86ec1cff22cc6f8e14072bb0f\n  },\n\n  { key = 0x698cfc46b7cc1346398bbe1de40992d9\n  , ciphertext = 0x17b9e6f86ec1cff22cc6f8e14072bb0f\n  , plaintext = 0x8f959f24fae93418c2262ec73c6c8e1d\n  },\n\n  { key = 0xe61963624d25275efbad90dad8651cc4\n  , ciphertext = 0x8f959f24fae93418c2262ec73c6c8e1d\n  , plaintext = 0x2876f3a90b7a60168869d9de1e455836\n  },\n\n  { key = 0xce6f90cb465f474873c44904c62044f2\n  , ciphertext = 0x2876f3a90b7a60168869d9de1e455836\n  , plaintext = 0x5c609c0acdf2e389f19b3e0657706c9c\n  },\n\n  { key = 0x920f0cc18bada4c1825f77029150286e\n  , ciphertext = 0x5c609c0acdf2e389f19b3e0657706c9c\n  , plaintext = 0x88f537f67481490d20b713ff48b079e5\n  },\n\n  { key = 0x1afa3b37ff2cedcca2e864fdd9e0518b\n  , ciphertext = 0x88f537f67481490d20b713ff48b079e5\n  , plaintext = 0x0b1878fc9406b6c5f2c0085e8c9e0dd9\n  },\n\n  { key = 0x11e243cb6b2a5b0950286ca3557e5c52\n  , ciphertext = 0x0b1878fc9406b6c5f2c0085e8c9e0dd9\n  , plaintext = 0x594b9df3bad040afa14e63298945068d\n  },\n\n  { key = 0x48a9de38d1fa1ba6f1660f8adc3b5adf\n  , ciphertext = 0x594b9df3bad040afa14e63298945068d\n  , plaintext = 0xfcf5ffafacc372e641b1520fe76d16c7\n  },\n\n  { key = 0xb45c21977d396940b0d75d853b564c18\n  , ciphertext = 0xfcf5ffafacc372e641b1520fe76d16c7\n  , plaintext = 0x67319b7ab394937244b93977ba06c1ee\n  },\n\n  { key = 0xd36dbaedceadfa32f46e64f281508df6\n  , ciphertext = 0x67319b7ab394937244b93977ba06c1ee\n  , plaintext = 0xd956a31188a667eea44c93582d6aed6f\n  },\n\n  { key = 0x0a3b19fc460b9ddc5022f7aaac3a6099\n  , ciphertext = 0xd956a31188a667eea44c93582d6aed6f\n  , plaintext = 0x04f18289308787f3d936dd2a45c49e22\n  },\n\n  { key = 0x0eca9b75768c1a2f89142a80e9fefebb\n  , ciphertext = 0x04f18289308787f3d936dd2a45c49e22\n  , plaintext = 0xc925df60f455b0e27852efcf9fddc3d0\n  },\n\n  { key = 0xc7ef441582d9aacdf146c54f76233d6b\n  , ciphertext = 0xc925df60f455b0e27852efcf9fddc3d0\n  , plaintext = 0x14c3bcf83483de973d975dbf249c505e\n  },\n\n  { key = 0xd32cf8edb65a745accd198f052bf6d35\n  , ciphertext = 0x14c3bcf83483de973d975dbf249c505e\n  , plaintext = 0xa5f3f4afd0d01b9f4999d27e6386e925\n  },\n\n  { key = 0x76df0c42668a6fc585484a8e31398410\n  , ciphertext = 0xa5f3f4afd0d01b9f4999d27e6386e925\n  , plaintext = 0xd94451374478c1bdb4b94eb6908a205e\n  },\n\n  { key = 0xaf9b5d7522f2ae7831f10438a1b3a44e\n  , ciphertext = 0xd94451374478c1bdb4b94eb6908a205e\n  , plaintext = 0x9f3c6ed40a32c89d4ee8d4b87c8298c7\n  },\n\n  { key = 0x30a733a128c066e57f19d080dd313c89\n  , ciphertext = 0x9f3c6ed40a32c89d4ee8d4b87c8298c7\n  , plaintext = 0x54aa57cf75650cf6b7ccbd7202469bf7\n  },\n\n  { key = 0x640d646e5da56a13c8d56df2df77a77e\n  , ciphertext = 0x54aa57cf75650cf6b7ccbd7202469bf7\n  , plaintext = 0x11bc0be20465848934c0fd7d7ced8bd1\n  },\n\n  { key = 0x75b16f8c59c0ee9afc15908fa39a2caf\n  , ciphertext = 0x11bc0be20465848934c0fd7d7ced8bd1\n  , plaintext = 0x69d48f1ca39977f1c05f8cabd5f7e4ac\n  },\n\n  { key = 0x1c65e090fa59996b3c4a1c24766dc803\n  , ciphertext = 0x69d48f1ca39977f1c05f8cabd5f7e4ac\n  , plaintext = 0x2e447e6121162382c182b3efb27b2d5a\n  },\n\n  { key = 0x32219ef1db4fbae9fdc8afcbc416e559\n  , ciphertext = 0x2e447e6121162382c182b3efb27b2d5a\n  , plaintext = 0x3d99d0dff0891c38bec01551b4040e55\n  },\n\n  { key = 0x0fb84e2e2bc6a6d14308ba9a7012eb0c\n  , ciphertext = 0x3d99d0dff0891c38bec01551b4040e55\n  , plaintext = 0x92294ba363ed5b750c066cb6708620ee\n  },\n\n  { key = 0x9d91058d482bfda44f0ed62c0094cbe2\n  , ciphertext = 0x92294ba363ed5b750c066cb6708620ee\n  , plaintext = 0xcb674decffaae472d3d0710935b02aae\n  },\n\n  { key = 0x56f64861b78119d69cdea7253524e14c\n  , ciphertext = 0xcb674decffaae472d3d0710935b02aae\n  , plaintext = 0x47cd6a4b2f9b3d610d2bd3fe39feec91\n  },\n\n  { key = 0x113b222a981a24b791f574db0cda0ddd\n  , ciphertext = 0x47cd6a4b2f9b3d610d2bd3fe39feec91\n  , plaintext = 0x65b0b926a5b5b67f6895af42441f106b\n  },\n\n  { key = 0x748b9b0c3daf92c8f960db9948c51db6\n  , ciphertext = 0x65b0b926a5b5b67f6895af42441f106b\n  , plaintext = 0x3642fd59024efb3dc4e5bb268dd9de04\n  },\n\n  { key = 0x42c966553fe169f53d8560bfc51cc3b2\n  , ciphertext = 0x3642fd59024efb3dc4e5bb268dd9de04\n  , plaintext = 0x4e5d32a0e40dd9b830af0c2904518906\n  },\n\n  { key = 0x0c9454f5dbecb04d0d2a6c96c14d4ab4\n  , ciphertext = 0x4e5d32a0e40dd9b830af0c2904518906\n  , plaintext = 0x40a7ff6a6d0ea135245d5b24a0004466\n  },\n\n  { key = 0x4c33ab9fb6e21178297737b2614d0ed2\n  , ciphertext = 0x40a7ff6a6d0ea135245d5b24a0004466\n  , plaintext = 0xb18e6d37f5292acd1eaeee742930952a\n  },\n\n  { key = 0xfdbdc6a843cb3bb537d9d9c6487d9bf8\n  , ciphertext = 0xb18e6d37f5292acd1eaeee742930952a\n  , plaintext = 0x42df9c23bfbc90b787c5cb0dc08e80dc\n  },\n\n  { key = 0xbf625a8bfc77ab02b01c12cb88f31b24\n  , ciphertext = 0x42df9c23bfbc90b787c5cb0dc08e80dc\n  , plaintext = 0x589af99abbba45318106d2c1ca7b82b0\n  },\n\n  { key = 0xe7f8a31147cdee33311ac00a42889994\n  , ciphertext = 0x589af99abbba45318106d2c1ca7b82b0\n  , plaintext = 0x96f54a5bacec995c0263226cd443f2c6\n  },\n\n  { key = 0x710de94aeb21776f3379e26696cb6b52\n  , ciphertext = 0x96f54a5bacec995c0263226cd443f2c6\n  , plaintext = 0x84e07ce717c747cb924e42cdf6ec6524\n  },\n\n  { key = 0xf5ed95adfce630a4a137a0ab60270e76\n  , ciphertext = 0x84e07ce717c747cb924e42cdf6ec6524\n  , plaintext = 0x5140a66d02867ddfa8bb014f75d53b83\n  },\n\n  { key = 0xa4ad33c0fe604d7b098ca1e415f235f5\n  , ciphertext = 0x5140a66d02867ddfa8bb014f75d53b83\n  , plaintext = 0xa1570dc8605d7d68f0a2416aa2c3536a\n  },\n\n  { key = 0x05fa3e089e3d3013f92ee08eb731669f\n  , ciphertext = 0xa1570dc8605d7d68f0a2416aa2c3536a\n  , plaintext = 0x96ab8bd9091a703a6e6d1a2190f0b5c9\n  },\n\n  { key = 0x9351b5d1972740299743faaf27c1d356\n  , ciphertext = 0x96ab8bd9091a703a6e6d1a2190f0b5c9\n  , plaintext = 0x8418c2cec9d7cc3825152790f120488f\n  },\n\n  { key = 0x1749771f5ef08c11b256dd3fd6e19bd9\n  , ciphertext = 0x8418c2cec9d7cc3825152790f120488f\n  , plaintext = 0x7973673755c8201ec52bdec30a86191f\n  },\n\n  { key = 0x6e3a10280b38ac0f777d03fcdc6782c6\n  , ciphertext = 0x7973673755c8201ec52bdec30a86191f\n  , plaintext = 0x2a92ba991755f3c6ad1ef58681ac3a12\n  },\n\n  { key = 0x44a8aab11c6d5fc9da63f67a5dcbb8d4\n  , ciphertext = 0x2a92ba991755f3c6ad1ef58681ac3a12\n  , plaintext = 0xe3daa0cfe79594311762ca0d39985da2\n  },\n\n  { key = 0xa7720a7efbf8cbf8cd013c776453e576\n  , ciphertext = 0xe3daa0cfe79594311762ca0d39985da2\n  , plaintext = 0x5c2ea8b0b4bd7b50b48abd7df8e716f2\n  },\n\n  { key = 0xfb5ca2ce4f45b0a8798b810a9cb4f384\n  , ciphertext = 0x5c2ea8b0b4bd7b50b48abd7df8e716f2\n  , plaintext = 0xf15e39a11ed397378b6de3d62bde10c2\n  },\n\n  { key = 0x0a029b6f5196279ff2e662dcb76ae346\n  , ciphertext = 0xf15e39a11ed397378b6de3d62bde10c2\n  , plaintext = 0xd16879ee2fe2c07703e7eba3e093e911\n  },\n\n  { key = 0xdb6ae2817e74e7e8f101897f57f90a57\n  , ciphertext = 0xd16879ee2fe2c07703e7eba3e093e911\n  , plaintext = 0x57aac9d12da681f1ef4fc3d07269e159\n  },\n\n  { key = 0x8cc02b5053d266191e4e4aaf2590eb0e\n  , ciphertext = 0x57aac9d12da681f1ef4fc3d07269e159\n  , plaintext = 0xf6472d8a7d288db2262d826ff2f806ee\n  },\n\n  { key = 0x7a8706da2efaebab3863c8c0d768ede0\n  , ciphertext = 0xf6472d8a7d288db2262d826ff2f806ee\n  , plaintext = 0xd3ec20ae3257192d51f2ce4e73f87e53\n  },\n\n  { key = 0xa96b26741cadf2866991068ea49093b3\n  , ciphertext = 0xd3ec20ae3257192d51f2ce4e73f87e53\n  , plaintext = 0xd99891b245282641fb9e91681fce7ee1\n  },\n\n  { key = 0x70f3b7c65985d4c7920f97e6bb5eed52\n  , ciphertext = 0xd99891b245282641fb9e91681fce7ee1\n  , plaintext = 0x8f2fa0031baacb388ed7da3e7fd62828\n  },\n\n  { key = 0xffdc17c5422f1fff1cd84dd8c488c57a\n  , ciphertext = 0x8f2fa0031baacb388ed7da3e7fd62828\n  , plaintext = 0x80bed13ad5aebb0783629b03af2f6897\n  },\n\n  { key = 0x7f62c6ff9781a4f89fbad6db6ba7aded\n  , ciphertext = 0x80bed13ad5aebb0783629b03af2f6897\n  , plaintext = 0xfac43dfa16d393580f130b8a955339a6\n  },\n\n  { key = 0x85a6fb05815237a090a9dd51fef4944b\n  , ciphertext = 0xfac43dfa16d393580f130b8a955339a6\n  , plaintext = 0x60aa3f3683346b09466f1c4c11b376f5\n  },\n\n  { key = 0xe50cc43302665ca9d6c6c11def47e2be\n  , ciphertext = 0x60aa3f3683346b09466f1c4c11b376f5\n  , plaintext = 0xe93ac158da113797bce2472240c4d7bb\n  },\n\n  { key = 0x0c36056bd8776b3e6a24863faf833505\n  , ciphertext = 0xe93ac158da113797bce2472240c4d7bb\n  , plaintext = 0xe96e8432e2eea1de7e0cceadfe5e1623\n  },\n\n  { key = 0xe55881593a99cae01428489251dd2326\n  , ciphertext = 0xe96e8432e2eea1de7e0cceadfe5e1623\n  , plaintext = 0xd99630cb34f06a3a02e9803a029980a2\n  },\n\n  { key = 0x3cceb1920e69a0da16c1c8a85344a384\n  , ciphertext = 0xd99630cb34f06a3a02e9803a029980a2\n  , plaintext = 0xe5a14b334430768edf5dd7863ee30678\n  },\n\n  { key = 0xd96ffaa14a59d654c99c1f2e6da7a5fc\n  , ciphertext = 0xe5a14b334430768edf5dd7863ee30678\n  , plaintext = 0x49dab0bc5fb8c387ea9c557d3a35e659\n  },\n\n  { key = 0x90b54a1d15e115d323004a53579243a5\n  , ciphertext = 0x49dab0bc5fb8c387ea9c557d3a35e659\n  , plaintext = 0x6867e956763a7377a15a4248ab91c829\n  },\n\n  { key = 0xf8d2a34b63db66a4825a081bfc038b8c\n  , ciphertext = 0x6867e956763a7377a15a4248ab91c829\n  , plaintext = 0x4f536383ba4e258dd3ab764027a66e39\n  },\n\n  { key = 0xb781c0c8d995432951f17e5bdba5e5b5\n  , ciphertext = 0x4f536383ba4e258dd3ab764027a66e39\n  , plaintext = 0xe9b6abc089286834eb9421e71fe98517\n  },\n\n  { key = 0x5e376b0850bd2b1dba655fbcc44c60a2\n  , ciphertext = 0xe9b6abc089286834eb9421e71fe98517\n  , plaintext = 0x256121dead70e6675ad631dd0527fb1a\n  },\n\n  { key = 0x7b564ad6fdcdcd7ae0b36e61c16b9bb8\n  , ciphertext = 0x256121dead70e6675ad631dd0527fb1a\n  , plaintext = 0x6bdbcc94ec6497445e4024acb601741b\n  },\n\n  { key = 0x108d864211a95a3ebef34acd776aefa3\n  , ciphertext = 0x6bdbcc94ec6497445e4024acb601741b\n  , plaintext = 0x44e86f9d48c6699554a3538eb6f55479\n  },\n\n  { key = 0x5465e9df596f33abea501943c19fbbda\n  , ciphertext = 0x44e86f9d48c6699554a3538eb6f55479\n  , plaintext = 0xc7c622fee00a180f3131a57a82acf7a9\n  },\n\n  { key = 0x93a3cb21b9652ba4db61bc3943334c73\n  , ciphertext = 0xc7c622fee00a180f3131a57a82acf7a9\n  , plaintext = 0xe096b0406e6e8abb6ced353f1be40693\n  },\n\n  { key = 0x73357b61d70ba11fb78c890658d74ae0\n  , ciphertext = 0xe096b0406e6e8abb6ced353f1be40693\n  , plaintext = 0x73326251dbd89c23b37caee2ee6d2d9e\n  },\n\n  { key = 0x000719300cd33d3c04f027e4b6ba677e\n  , ciphertext = 0x73326251dbd89c23b37caee2ee6d2d9e\n  , plaintext = 0x7b2c687d460054af03709645056407c6\n  },\n\n  { key = 0x7b2b714d4ad369930780b1a1b3de60b8\n  , ciphertext = 0x7b2c687d460054af03709645056407c6\n  , plaintext = 0x8bb9f381438145a96714e238a8864e0b\n  },\n\n  { key = 0xf09282cc09522c3a609453991b582eb3\n  , ciphertext = 0x8bb9f381438145a96714e238a8864e0b\n  , plaintext = 0xd59509d08bcfc30e20344b1c4c53f726\n  },\n\n  { key = 0x25078b1c829def3440a01885570bd995\n  , ciphertext = 0xd59509d08bcfc30e20344b1c4c53f726\n  , plaintext = 0x02e6077d01a352637899d6ce626782ac\n  },\n\n  { key = 0x27e18c61833ebd573839ce4b356c5b39\n  , ciphertext = 0x02e6077d01a352637899d6ce626782ac\n  , plaintext = 0xed01d9601145c11662986b0827e403ec\n  },\n\n  { key = 0xcae05501927b7c415aa1a543128858d5\n  , ciphertext = 0xed01d9601145c11662986b0827e403ec\n  , plaintext = 0x7d5b1ca06884b5a55e9035fe7d77d4a7\n  },\n\n  { key = 0xb7bb49a1faffc9e4043190bd6fff8c72\n  , ciphertext = 0x7d5b1ca06884b5a55e9035fe7d77d4a7\n  , plaintext = 0x1a23d371b97e1056e8bc9545c56cab9e\n  },\n\n  { key = 0xad989ad04381d9b2ec8d05f8aa9327ec\n  , ciphertext = 0x1a23d371b97e1056e8bc9545c56cab9e\n  , plaintext = 0xd1d2bfdc58ffcad2341b095bce55221e\n  }]\n\nmct_ecb_encrypt_192 : [192] -> [128] -> [100](AESTestVector 192)\nmct_ecb_encrypt_192 initialKey initialPt = vs\n  where\n  vs@i = { key = keys@i, plaintext=pts@(i*1000), ciphertext=cts@(i*1000 + 999) }\n\n  pts : [100*1000][128]\n  pts = [initialPt] # take cts\n\n  cts : [100*1000][128]\n  cts@i = aesEncryptBlock (schedules@(i\/1000)) (pts@i)\n\n  keys : [100][192]\n  keys = [initialKey] # [ k ^ ((drop`{64} (xs!1)) # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} cts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESEncryptKeySchedule AES192)\n  schedules = map aes192EncryptSchedule keys\n\nmct_ecb_decrypt_192 : [192] -> [128] -> [100](AESTestVector 192)\nmct_ecb_decrypt_192 initialKey initialCt = vs\n  where\n  vs@i = { key = keys@i, ciphertext=cts@(i*1000), plaintext=pts@(i*1000 + 999) }\n\n  cts : [100*1000][128]\n  cts = [initialCt] # take pts\n\n  pts : [100*1000][128]\n  pts@i = aesDecryptBlock (schedules@(i\/1000)) (cts@i)\n\n  keys : [100][192]\n  keys = [initialKey] # [ k ^ ((drop`{64} (xs!1)) # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} pts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESDecryptKeySchedule AES192)\n  schedules = map aes192DecryptSchedule keys\n\nmct_ecb_encrypt_256 : [256] -> [128] -> [100](AESTestVector 256)\nmct_ecb_encrypt_256 initialKey initialPt = vs\n  where\n  vs@i = { key = keys@i, plaintext=pts@(i*1000), ciphertext=cts@(i*1000 + 999) }\n\n  pts : [100*1000][128]\n  pts = [initialPt] # take cts\n\n  cts : [100*1000][128]\n  cts@i = aesEncryptBlock (schedules@(i\/1000)) (pts@i)\n\n  keys : [100][256]\n  keys = [initialKey] # [ k ^ (xs!1 # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} cts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESEncryptKeySchedule AES256)\n  schedules = map aes256EncryptSchedule keys\n\nmct_ecb_decrypt_256 : [256] -> [128] -> [100](AESTestVector 256)\nmct_ecb_decrypt_256 initialKey initialCt = vs\n  where\n  vs@i = { key = keys@i, ciphertext=cts@(i*1000), plaintext=pts@(i*1000 + 999) }\n\n  cts : [100*1000][128]\n  cts = [initialCt] # take pts\n\n  pts : [100*1000][128]\n  pts@i = aesDecryptBlock (schedules@(i\/1000)) (cts@i)\n\n  keys : [100][256]\n  keys = [initialKey] # [ k ^ (xs!1 # xs!0)\n                        | xs <- take`{99} (groupBy`{1000} pts)\n                        | k <- keys\n                        ]\n\n  schedules : [100](AESDecryptKeySchedule AES256)\n  schedules = map aes256DecryptSchedule keys\n\nproperty aes192_MCT_vectors_encrypt_correct =\n aes192_MCT_encrypt_test_vectors ==\n mct_ecb_encrypt_192\n   0xb9a63e09e1dfc42e93a90d9bad739e5967aef672eedd5da9 \n   0x85a1f7a58167b389cddc8a9ff175ee26\n\nproperty aes192_MCT_vectors_decrypt_correct =\n aes192_MCT_decrypt_test_vectors ==\n mct_ecb_decrypt_192\n   0x4b97585701c03fbebdfa8555024f589f1482c58a00fdd9fd\n   0xd0bd0e02ded155e4516be83f42d347a4\n\naes192_MCT_encrypt_test_vectors : [100](AESTestVector 192)\naes192_MCT_encrypt_test_vectors =\n  [{ key = 0xb9a63e09e1dfc42e93a90d9bad739e5967aef672eedd5da9\n  , plaintext = 0x85a1f7a58167b389cddc8a9ff175ee26\n  , ciphertext = 0xee83d85279e022d2048031abeefbc4a4\n  },\n\n  { key = 0x3aaa458160ee54c97d2ad5c9d493bc8b632ec7d90026990d\n  , plaintext = 0xee83d85279e022d2048031abeefbc4a4\n  , ciphertext = 0xa8f99517b4bd14a16c26bae901417498\n  },\n\n  { key = 0x1d17d1bcc74a8584d5d340de602ea82a0f087d300167ed95\n  , plaintext = 0xa8f99517b4bd14a16c26bae901417498\n  , ciphertext = 0x80286e71937334fd6e90c706abbaf0ff\n  },\n\n  { key = 0xc0025cd0eb1f23c055fb2eaff35d9cd76198ba36aadd1d6a\n  , plaintext = 0x80286e71937334fd6e90c706abbaf0ff\n  , ciphertext = 0xc8b8c153bcb231e9424d65f37bff75b8\n  },\n\n  { key = 0xafb45c1097553d589d43effc4fefad3e23d5dfc5d12268d2\n  , plaintext = 0xc8b8c153bcb231e9424d65f37bff75b8\n  , ciphertext = 0x8108fbfde1cff0d94b88b1073114c657\n  },\n\n  { key = 0x8b81e2418f676a5b1c4b1401ae205de7685d6ec2e036ae85\n  , plaintext = 0x8108fbfde1cff0d94b88b1073114c657\n  , ciphertext = 0x79af44f2490efc90d217af55dd10fd2e\n  },\n\n  { key = 0x43463bbf9528c3bc65e450f3e72ea177ba4ac1973d2653ab\n  , plaintext = 0x79af44f2490efc90d217af55dd10fd2e\n  , ciphertext = 0xd0c2da3860c367e1fd68cf04bb6b41cd\n  },\n\n  { key = 0x0e3efca8ca3fd45bb5268acb87edc69647220e93864d1266\n  , plaintext = 0xd0c2da3860c367e1fd68cf04bb6b41cd\n  , ciphertext = 0xe5d39a5d7ca8c4f4aafd3d851c40c016\n  },\n\n  { key = 0x2908445968d0a18f50f51096fb450262eddf33169a0dd270\n  , plaintext = 0xe5d39a5d7ca8c4f4aafd3d851c40c016\n  , ciphertext = 0x98657051b23c69741b2ab506f818fd3f\n  },\n\n  { key = 0x00feb8bffd6b4bcbc89060c749796b16f6f5861062152f4f\n  , plaintext = 0x98657051b23c69741b2ab506f818fd3f\n  , ciphertext = 0xc9b6e95fb54b540adc1faa8cece00286\n  },\n\n  { key = 0xbe96e16fffe0a2db01268998fc323f1c2aea2c9c8ef52dc9\n  , plaintext = 0xc9b6e95fb54b540adc1faa8cece00286\n  , ciphertext = 0x5cf9f61a3dd3a2f76d571384c831ae88\n  },\n\n  { key = 0x41baf817490bf49c5ddf7f82c1e19deb47bd3f1846c48341\n  , plaintext = 0x5cf9f61a3dd3a2f76d571384c831ae88\n  , ciphertext = 0xdc6e6c13679958963b8648457eb8a415\n  },\n\n  { key = 0xa4afa1ac957b31fe81b11391a678c57d7c3b775d387c2754\n  , plaintext = 0xdc6e6c13679958963b8648457eb8a415\n  , ciphertext = 0x033f2b7189ec7f2ef0c496a83f5c5051\n  },\n\n  { key = 0x6a5b44860a26a4ff828e38e02f94ba538cffe1f507207705\n  , plaintext = 0x033f2b7189ec7f2ef0c496a83f5c5051\n  , ciphertext = 0x032727204d9b169679eff2ffe5f71efb\n  },\n\n  { key = 0xc80d5ebc48693fdc81a91fc0620facc5f510130ae2d769fe\n  , plaintext = 0x032727204d9b169679eff2ffe5f71efb\n  , ciphertext = 0xd19884aaae710c5861fff7251ea143c8\n  },\n\n  { key = 0xb9d36290d5324a8350319b6acc7ea09d94efe42ffc762a36\n  , plaintext = 0xd19884aaae710c5861fff7251ea143c8\n  , ciphertext = 0x3097d32245163fcf4c578e5a7dd2349a\n  },\n\n  { key = 0x3d00403bc3a0ff5b60a6484889689f52d8b86a7581a41eac\n  , plaintext = 0x3097d32245163fcf4c578e5a7dd2349a\n  , ciphertext = 0x39b6615b1e047b9469b3cfd7251987c9\n  },\n\n  { key = 0xbb85f657f0d5241659102913976ce4c6b10ba5a2a4bd9965\n  , plaintext = 0x39b6615b1e047b9469b3cfd7251987c9\n  , ciphertext = 0x868194c44a68d8b48e0ed4dbacded128\n  },\n\n  { key = 0x7db3635bf7d52f66df91bdd7dd043c723f0571790863484d\n  , plaintext = 0x868194c44a68d8b48e0ed4dbacded128\n  , ciphertext = 0xd324fd7db1cfaa86511280dafa5340e6\n  },\n\n  { key = 0x1449e32d51b3680f0cb540aa6ccb96f46e17f1a3f23008ab\n  , plaintext = 0xd324fd7db1cfaa86511280dafa5340e6\n  , ciphertext = 0x409aa25dcb51d8831a2f5627746c2bc9\n  },\n\n  { key = 0x63d4b33e24bf3f7c4c2fe2f7a79a4e777438a784865c2362\n  , plaintext = 0x409aa25dcb51d8831a2f5627746c2bc9\n  , ciphertext = 0xbfa0348398b9bc4e07eb1739c589b225\n  },\n\n  { key = 0x03f21169aad21af3f38fd6743f23f23973d3b0bd43d59147\n  , plaintext = 0xbfa0348398b9bc4e07eb1739c589b225\n  , ciphertext = 0x13582b4881e6b7f6398f41b57d617201\n  },\n\n  { key = 0x541879f8770ad35de0d7fd3cbec545cf4a5cf1083eb4e346\n  , plaintext = 0x13582b4881e6b7f6398f41b57d617201\n  , ciphertext = 0xd9d58082c3a976852a350ba551862362\n  },\n\n  { key = 0xd0c6100d7f8fdd8739027dbe7d6c334a6069faad6f32c024\n  , plaintext = 0xd9d58082c3a976852a350ba551862362\n  , ciphertext = 0x3cafa17506a92359c23600404ad61513\n  },\n\n  { key = 0x05345651ac0d23b305addccb7bc51013a25ffaed25e4d537\n  , plaintext = 0x3cafa17506a92359c23600404ad61513\n  , ciphertext = 0xa4a3041803fe9bf7d355b34d21293ecf\n  },\n\n  { key = 0x4ce9e1102ccba488a10ed8d3783b8be4710a49a004cdebf8\n  , plaintext = 0xa4a3041803fe9bf7d355b34d21293ecf\n  , ciphertext = 0xcfa674aba22c17036da437832c635b30\n  },\n\n  { key = 0x08fed0e9350ac7386ea8ac78da179ce71cae7e2328aeb0c8\n  , plaintext = 0xcfa674aba22c17036da437832c635b30\n  , ciphertext = 0xf4de164a6ca93e96dfc91426d636e481\n  },\n\n  { key = 0xcc5643ba704f961c9a76ba32b6bea271c3676a05fe985449\n  , plaintext = 0xf4de164a6ca93e96dfc91426d636e481\n  , ciphertext = 0x1deb553ac91ec346201154dbbdac9b14\n  },\n\n  { key = 0xd413a379439b2caf879def087fa06137e3763ede4334cf5d\n  , plaintext = 0x1deb553ac91ec346201154dbbdac9b14\n  , ciphertext = 0x52372415208849a222acf6f27e145f75\n  },\n\n  { key = 0x575a3e57736fe96dd5aacb1d5f282895c1dac82c3d209028\n  , plaintext = 0x52372415208849a222acf6f27e145f75\n  , ciphertext = 0x710f708e402325c6763ca461f6f855e0\n  },\n\n  { key = 0x7d593f399f198b9da4a5bb931f0b0d53b7e66c4dcbd8c5c8\n  , plaintext = 0x710f708e402325c6763ca461f6f855e0\n  , ciphertext = 0x8fae56699e3af53b86d484be2463b602\n  },\n\n  { key = 0x401e3d459d7254a82b0bedfa8131f8683132e8f3efbb73ca\n  , plaintext = 0x8fae56699e3af53b86d484be2463b602\n  , ciphertext = 0xaa44678efb43326727d5204edc942fe2\n  },\n\n  { key = 0x996d36de694dc3cb814f8a747a72ca0f16e7c8bd332f5c28\n  , plaintext = 0xaa44678efb43326727d5204edc942fe2\n  , ciphertext = 0xfb04caba312e387528a355d39db15db6\n  },\n\n  { key = 0xbba2ddbf7cc063957a4b40ce4b5cf27a3e449d6eae9e019e\n  , plaintext = 0xfb04caba312e387528a355d39db15db6\n  , ciphertext = 0x5d8156335210cc39885ab652d8ccfd33\n  },\n\n  { key = 0x5fdbf5f7b3b389c727ca16fd194c3e43b61e2b3c7652fcad\n  , plaintext = 0x5d8156335210cc39885ab652d8ccfd33\n  , ciphertext = 0x8b8d3455188ad9615a2c3a34c4bfb8df\n  },\n\n  { key = 0xfa876ec64e22b16bac4722a801c6e722ec321108b2ed4472\n  , plaintext = 0x8b8d3455188ad9615a2c3a34c4bfb8df\n  , ciphertext = 0x1c5bab7b91032ffac3a8e4d41a3a5338\n  },\n\n  { key = 0xceeda64221ae37d3b01c89d390c5c8d82f9af5dca8d7174a\n  , plaintext = 0x1c5bab7b91032ffac3a8e4d41a3a5338\n  , ciphertext = 0xad98def9c24e9d0de0e6a9541c86c34c\n  },\n\n  { key = 0xb2b6b9074795f6501d84572a528b55d5cf7c5c88b451d406\n  , plaintext = 0xad98def9c24e9d0de0e6a9541c86c34c\n  , ciphertext = 0xee54a410d2e410e721bf9b12f9a8bb04\n  },\n\n  { key = 0x42e6927395e5d3dbf3d0f33a806f4532eec3c79a4df96f02\n  , plaintext = 0xee54a410d2e410e721bf9b12f9a8bb04\n  , ciphertext = 0x7b894a4e5514249029af1118576093cc\n  },\n\n  { key = 0x07373c871002daaf8859b974d57b61a2c76cd6821a99fcce\n  , plaintext = 0x7b894a4e5514249029af1118576093cc\n  , ciphertext = 0xf555d93e38137c9b931b4583de367ff2\n  },\n\n  { key = 0x8eebc322f66630687d0c604aed681d3954779301c4af833c\n  , plaintext = 0xf555d93e38137c9b931b4583de367ff2\n  , ciphertext = 0xf5adbb37c99646913d1670ccd8203c04\n  },\n\n  { key = 0x56d70f07f90e11ab88a1db7d24fe5ba86961e3cd1c8fbf38\n  , plaintext = 0xf5adbb37c99646913d1670ccd8203c04\n  , ciphertext = 0x122f214900ffcfd59652c1af64b10c71\n  },\n\n  { key = 0xcf4ec9b7f52cd2d99a8efa342401947dff332262783eb349\n  , plaintext = 0x122f214900ffcfd59652c1af64b10c71\n  , ciphertext = 0xbe1b5d5ac7b61b73c479d7b1fc65ea35\n  },\n\n  { key = 0x8ca5b0fe1053b3982495a76ee3b78f0e3b4af5d3845b597c\n  , plaintext = 0xbe1b5d5ac7b61b73c479d7b1fc65ea35\n  , ciphertext = 0xf9868b44c1ce21b040b8fff3716b011a\n  },\n\n  { key = 0x34f2ce0dbb3fa2d2dd132c2a2279aebe7bf20a20f5305866\n  , plaintext = 0xf9868b44c1ce21b040b8fff3716b011a\n  , ciphertext = 0x9cac4efb170dc8ded3fc6a309fd7aca7\n  },\n\n  { key = 0x603bbb7bf54b365d41bf62d135746660a80e60106ae7f4c1\n  , plaintext = 0x9cac4efb170dc8ded3fc6a309fd7aca7\n  , ciphertext = 0xe52a42e78048c6dda63f98fc6c5f47f9\n  },\n\n  { key = 0xa146ac000cb1f14ba4952036b53ca0bd0e31f8ec06b8b338\n  , plaintext = 0xe52a42e78048c6dda63f98fc6c5f47f9\n  , ciphertext = 0x826af473c60d61bd746a8d8bda3b410c\n  },\n\n  { key = 0x979e0246f75d08e226ffd4457331c1007a5b7567dc83f234\n  , plaintext = 0x826af473c60d61bd746a8d8bda3b410c\n  , ciphertext = 0x9fa4ebdccace9033a56e3a5aace74dba\n  },\n\n  { key = 0x3c34cf05821c9d17b95b3f99b9ff5133df354f3d7064bf8e\n  , plaintext = 0x9fa4ebdccace9033a56e3a5aace74dba\n  , ciphertext = 0xe0ac5dee9d6247d50b379589c2415444\n  },\n\n  { key = 0x3e42ac26f6c0977a59f76277249d16e6d402dab4b225ebca\n  , plaintext = 0xe0ac5dee9d6247d50b379589c2415444\n  , ciphertext = 0x462562da72ea6b5c371530c716879dcd\n  },\n\n  { key = 0xed7edff15890f7841fd200ad56777dbae317ea73a4a27607\n  , plaintext = 0x462562da72ea6b5c371530c716879dcd\n  , ciphertext = 0x78a040009e18ef207253ef992e7e2c91\n  },\n\n  { key = 0x4140882041912162677240adc86f929a914405ea8adc5a96\n  , plaintext = 0x78a040009e18ef207253ef992e7e2c91\n  , ciphertext = 0xf8c7a79f10c92ec49e1ec59b08498d64\n  },\n\n  { key = 0x2cbc00f60f66695a9fb5e732d8a6bc5e0f5ac0718295d7f2\n  , plaintext = 0xf8c7a79f10c92ec49e1ec59b08498d64\n  , ciphertext = 0x2f9a5f2cfd515a6878ecd923c36b1b4e\n  },\n\n  { key = 0xce9854aa7b6e184ab02fb81e25f7e63677b6195241feccbc\n  , plaintext = 0x2f9a5f2cfd515a6878ecd923c36b1b4e\n  , ciphertext = 0xf7d3b3758ecf5359ab523beaa17a0306\n  },\n\n  { key = 0x93163ae28f22570b47fc0b6bab38b56fdce422b8e084cfba\n  , plaintext = 0xf7d3b3758ecf5359ab523beaa17a0306\n  , ciphertext = 0x6c9dd076750bd1d2c0b8f203ca14ee1e\n  },\n\n  { key = 0xca2a7882db1cb3b52b61db1dde3364bd1c5cd0bb2a9021a4\n  , plaintext = 0x6c9dd076750bd1d2c0b8f203ca14ee1e\n  , ciphertext = 0x289cf1ab3b9eac26cdd02df244412d4e\n  },\n\n  { key = 0x90dc3a02ba5b5f2b03fd2ab6e5adc89bd18cfd496ed10cea\n  , plaintext = 0x289cf1ab3b9eac26cdd02df244412d4e\n  , ciphertext = 0x8ee4ca3c6c9cc5f27ddb79ae7cfcc47e\n  },\n\n  { key = 0x11b26d4f3eb77d218d19e08a89310d69ac5784e7122dc894\n  , plaintext = 0x8ee4ca3c6c9cc5f27ddb79ae7cfcc47e\n  , ciphertext = 0x6cbf94fcdcadfd9a39d4c4f702d7b101\n  },\n\n  { key = 0x7159cd8684c28039e1a67476559cf0f39583401010fa7995\n  , plaintext = 0x6cbf94fcdcadfd9a39d4c4f702d7b101\n  , ciphertext = 0x5047270db233f75e84c734b5cb56f765\n  },\n\n  { key = 0x76bbdc75f530ec0ab1e1537be7af07ad114474a5dbac8ef0\n  , plaintext = 0x5047270db233f75e84c734b5cb56f765\n  , ciphertext = 0xb82602cd22e7821be62e5ff67cb193c6\n  },\n\n  { key = 0x306a4720867eca7009c751b6c54885b6f76a2b53a71d1d36\n  , plaintext = 0xb82602cd22e7821be62e5ff67cb193c6\n  , ciphertext = 0x5a241fbcb4a0f769c37408abe658da25\n  },\n\n  { key = 0x306323bbf53bd84f53e34e0a71e872df341e23f84145c713\n  , plaintext = 0x5a241fbcb4a0f769c37408abe658da25\n  , ciphertext = 0x9a63d956a9c719465e30cdc160991042\n  },\n\n  { key = 0x897b6f11ecb97862c980975cd82f6b996a2eee3921dcd751\n  , plaintext = 0x9a63d956a9c719465e30cdc160991042\n  , ciphertext = 0x2a733f407d8080470c5f22a6cf8358cd\n  },\n\n  { key = 0x14fa0e9978672ad5e3f3a81ca5afebde6671cc9fee5f8f9c\n  , plaintext = 0x2a733f407d8080470c5f22a6cf8358cd\n  , ciphertext = 0x24db9f77f61060accf6d41e7639c1ec6\n  },\n\n  { key = 0xc1125a27a85e3826c728376b53bf8b72a91c8d788dc3915a\n  , plaintext = 0x24db9f77f61060accf6d41e7639c1ec6\n  , ciphertext = 0xa89eccce6ee8c9d4d34cf5ba8b29cba7\n  },\n\n  { key = 0x1ce385ac9c70d4e26fb6fba53d5742a67a5078c206ea5afd\n  , plaintext = 0xa89eccce6ee8c9d4d34cf5ba8b29cba7\n  , ciphertext = 0xe4ef08e86141940ef87d6b385d19108c\n  },\n\n  { key = 0x9a3967a8ff01d35f8b59f34d5c16d6a8822d13fa5bf34a71\n  , plaintext = 0xe4ef08e86141940ef87d6b385d19108c\n  , ciphertext = 0x1039c441007d6805551a87e820c63dca\n  },\n\n  { key = 0x7d0af1cd0d641f209b60370c5c6bbeadd73794127b3577bb\n  , plaintext = 0x1039c441007d6805551a87e820c63dca\n  , ciphertext = 0x2584b55b214a94ee9894b104178a6dd5\n  },\n\n  { key = 0x3f78d295449908e6bee482577d212a434fa325166cbf1a6e\n  , plaintext = 0x2584b55b214a94ee9894b104178a6dd5\n  , ciphertext = 0x9d32bd6357551091ca659f7bd4509fc2\n  },\n\n  { key = 0x9cd28f265a13556123d63f342a743ad285c6ba6db8ef85ac\n  , plaintext = 0x9d32bd6357551091ca659f7bd4509fc2\n  , ciphertext = 0x9ac46eb8e253bb37304394ff0042d306\n  },\n\n  { key = 0x34caf580014164d4b912518cc82781e5b5852e92b8ad56aa\n  , plaintext = 0x9ac46eb8e253bb37304394ff0042d306\n  , ciphertext = 0x3b899f1f2d93e3890418763fdd35943a\n  },\n\n  { key = 0x7c19a50fa9360041829bce93e5b4626cb19d58ad6598c290\n  , plaintext = 0x3b899f1f2d93e3890418763fdd35943a\n  , ciphertext = 0xea89d4537784f253eae2d6cebdd63a4c\n  },\n\n  { key = 0x2109b2880479bb4f68121ac09230903f5b7f8e63d84ef8dc\n  , plaintext = 0xea89d4537784f253eae2d6cebdd63a4c\n  , ciphertext = 0x80711a42f6687a62590a8a0d165b2fb8\n  },\n\n  { key = 0x83fe682b1fcdb57be86300826458ea5d0275046ece15d764\n  , plaintext = 0x80711a42f6687a62590a8a0d165b2fb8\n  , ciphertext = 0xb2174ffab755e3e0c666cecb075256ec\n  },\n\n  { key = 0x63434f6c69c041735a744f78d30d09bdc413caa5c9478188\n  , plaintext = 0xb2174ffab755e3e0c666cecb075256ec\n  , ciphertext = 0x57120386bd566d31807a6fe7b0e78041\n  },\n\n  { key = 0xdfa4b3f99eda96420d664cfe6e5b648c4469a54279a001c9\n  , plaintext = 0x57120386bd566d31807a6fe7b0e78041\n  , ciphertext = 0x3b128fcdb7bb4252b5e5e00df5629508\n  },\n\n  { key = 0x24fa37bb6d70bd943674c333d9e026def18c454f8cc294c1\n  , plaintext = 0x3b128fcdb7bb4252b5e5e00df5629508\n  , ciphertext = 0x4826cf69d83c7f475230679b61ca8e0a\n  },\n\n  { key = 0x246a7408f739d1d37e520c5a01dc5999a3bc22d4ed081acb\n  , plaintext = 0x4826cf69d83c7f475230679b61ca8e0a\n  , ciphertext = 0x25a23c7fb798a50f5929e90e743da11c\n  },\n\n  { key = 0x9f1827be83518dbc5bf03025b644fc96fa95cbda9935bbd7\n  , plaintext = 0x25a23c7fb798a50f5929e90e743da11c\n  , ciphertext = 0x7639e9f902d65feb6bc5cbc44b5e12ed\n  },\n\n  { key = 0xfda6b0d164b7fd982dc9d9dcb492a37d9150001ed26ba93a\n  , plaintext = 0x7639e9f902d65feb6bc5cbc44b5e12ed\n  , ciphertext = 0x85a71ee457e94fc85cb9ac461fff1c4f\n  },\n\n  { key = 0x0755b86a470bb93aa86ec738e37becb5cde9ac58cd94b575\n  , plaintext = 0x85a71ee457e94fc85cb9ac461fff1c4f\n  , ciphertext = 0xc9ef84a268877ecef88bb554ea63c336\n  },\n\n  { key = 0x8f13f2d9085091816181439a8bfc927b3562190c27f77643\n  , plaintext = 0xc9ef84a268877ecef88bb554ea63c336\n  , ciphertext = 0x260dd6bf1366c029b5fd64e72853d2d7\n  },\n\n  { key = 0xfdd71c524c374345478c9525989a5252809f7deb0fa4a494\n  , plaintext = 0x260dd6bf1366c029b5fd64e72853d2d7\n  , ciphertext = 0x39cc3e224738efaaf45fab525fc13127\n  },\n\n  { key = 0x8bd43e3f448778ea7e40ab07dfa2bdf874c0d6b9506595b3\n  , plaintext = 0x39cc3e224738efaaf45fab525fc13127\n  , ciphertext = 0x4d5ac8506c0a13b1c2092731c6fe5fbc\n  },\n\n  { key = 0x69b7449dc811b19c331a6357b3a8ae49b6c9f188969bca0f\n  , plaintext = 0x4d5ac8506c0a13b1c2092731c6fe5fbc\n  , ciphertext = 0xede69bd80f879d57640c77bc1312f064\n  },\n\n  { key = 0x40e1692d44e3b441defcf88fbc2f331ed2c5863485893a6b\n  , plaintext = 0xede69bd80f879d57640c77bc1312f064\n  , ciphertext = 0x31dc854d8552e6684904bc6502682434\n  },\n\n  { key = 0xc1de7d9285751138ef207dc2397dd5769bc13a5187e11e5f\n  , plaintext = 0x31dc854d8552e6684904bc6502682434\n  , ciphertext = 0xc7bdc57aaa445e489655154b25d3906d\n  },\n\n  { key = 0xd8689fdcc9b77227289db8b893398b3e0d942f1aa2328e32\n  , plaintext = 0xc7bdc57aaa445e489655154b25d3906d\n  , ciphertext = 0xc4b498470a24113b6b182674c0366131\n  },\n\n  { key = 0x8293a998633a405dec2920ff991d9a05668c096e6204ef03\n  , plaintext = 0xc4b498470a24113b6b182674c0366131\n  , ciphertext = 0x7575104da6d5b4e0fb21d682f93d0d24\n  },\n\n  { key = 0xe71e9c0918c908ae995c30b23fc82ee59daddfec9b39e227\n  , plaintext = 0x7575104da6d5b4e0fb21d682f93d0d24\n  , ciphertext = 0xc5acdc318353c4ef3f6f45bf4a84c659\n  },\n\n  { key = 0xa5f19f392eb2afd15cf0ec83bc9bea0aa2c29a53d1bd247e\n  , plaintext = 0xc5acdc318353c4ef3f6f45bf4a84c659\n  , ciphertext = 0xaf6a60f60fc085656e305a4c050cc9c3\n  },\n\n  { key = 0x180b05bff13a1ad3f39a8c75b35b6f6fccf2c01fd4b1edbd\n  , plaintext = 0xaf6a60f60fc085656e305a4c050cc9c3\n  , ciphertext = 0x9d5f30e488c3243ad20767b39ec9ee4e\n  },\n\n  { key = 0x1fb7ff20cab8a5186ec5bc913b984b551ef5a7ac4a7803f3\n  , plaintext = 0x9d5f30e488c3243ad20767b39ec9ee4e\n  , ciphertext = 0x5c3a1d144e5efe7cede88e21dcbc2777\n  },\n\n  { key = 0x3e999761c9d15f3932ffa18575c6b529f31d298d96c42484\n  , plaintext = 0x5c3a1d144e5efe7cede88e21dcbc2777\n  , ciphertext = 0x4f163c25a6d545ccffc54511b2a5605d\n  },\n\n  { key = 0x8bc1e531e9d3f84f7de99da0d313f0e50cd86c9c246144d9\n  , plaintext = 0x4f163c25a6d545ccffc54511b2a5605d\n  , ciphertext = 0x3eed65dab0bd7ae8c8b115fa185e310a\n  },\n\n  { key = 0x4efaae2e7ecadcd24304f87a63ae8a0dc46979663c3f75d3\n  , plaintext = 0x3eed65dab0bd7ae8c8b115fa185e310a\n  , ciphertext = 0xfefce0da5af3885d022636f19adab9b8\n  },\n\n  { key = 0x44e1224d08476e9cbdf818a0395d0250c64f4f97a6e5cc6b\n  , plaintext = 0xfefce0da5af3885d022636f19adab9b8\n  , ciphertext = 0x3a0c3d806aff32fde868343b0b58c77a\n  },\n\n  { key = 0xef93ffb9eb0b9f1787f4252053a230ad2e277bacadbd0b11\n  , plaintext = 0x3a0c3d806aff32fde868343b0b58c77a\n  , ciphertext = 0x6610ee19970ee606083968e523af2370\n  },\n\n  { key = 0xfc7c2c3d27519036e1e4cb39c4acd6ab261e13498e122861\n  , plaintext = 0x6610ee19970ee606083968e523af2370\n  , ciphertext = 0x2f714ddbd4adf8327dc93c723aebfffa\n  },\n\n  { key = 0xf2f8a8247724e289ce9586e210012e995bd72f3bb4f9d79b\n  , plaintext = 0x2f714ddbd4adf8327dc93c723aebfffa\n  , ciphertext = 0x5d1196da8f184975e240949a25104554\n  }]\n\naes192_MCT_decrypt_test_vectors : [100](AESTestVector 192)\naes192_MCT_decrypt_test_vectors =\n [{ key = 0x4b97585701c03fbebdfa8555024f589f1482c58a00fdd9fd\n  , ciphertext = 0xd0bd0e02ded155e4516be83f42d347a4\n  , plaintext = 0xc7b6581ccc88f7fc26d15d2731e7251b\n  },\n\n  { key = 0x3c98c80336e0f13f7a4cdd49cec7af63325398ad311afce6\n  , ciphertext = 0xc7b6581ccc88f7fc26d15d2731e7251b\n  , plaintext = 0x01aa957b12c596511484ed7705766c67\n  },\n\n  { key = 0x825349971b370dc47be64832dc02393226d775da346c9081\n  , ciphertext = 0x01aa957b12c596511484ed7705766c67\n  , plaintext = 0xf98c15d93f5daef6047c2760c5df5540\n  },\n\n  { key = 0xebb9611cf25685c3826a5debe35f97c422ab52baf1b3c5c1\n  , ciphertext = 0xf98c15d93f5daef6047c2760c5df5540\n  , plaintext = 0x5c86395c6b3ed7d30d5e3ce3331fb3ed\n  },\n\n  { key = 0xd8d6d591e30f4e77deec64b7886140172ff56e59c2ac762c\n  , ciphertext = 0x5c86395c6b3ed7d30d5e3ce3331fb3ed\n  , plaintext = 0x8e8cb768b31e65d054e9db8d19862084\n  },\n\n  { key = 0x775a6f9a0e4733e45060d3df3b7f25c77b1cb5d4db2a56a8\n  , ciphertext = 0x8e8cb768b31e65d054e9db8d19862084\n  , plaintext = 0x96cab38070ea8e37c3d437a091e9e74c\n  },\n\n  { key = 0x511e536ea113429bc6aa605f4b95abf0b8c882744ac3b1e4\n  , ciphertext = 0x96cab38070ea8e37c3d437a091e9e74c\n  , plaintext = 0xf8356cfe486b2375c2e2e4138b285ce7\n  },\n\n  { key = 0xc3f94c74f86b59723e9f0ca103fe88857a2a6667c1ebed03\n  , ciphertext = 0xf8356cfe486b2375c2e2e4138b285ce7\n  , plaintext = 0x6a15770b29960c063395a70dc3cf7575\n  },\n\n  { key = 0xa220f197ee7db5a2548a7baa2a68848349bfc16a02249876\n  , ciphertext = 0x6a15770b29960c063395a70dc3cf7575\n  , plaintext = 0xd16463745da38ef8997e20e102fb8573\n  },\n\n  { key = 0x187bc771e567fb1285ee18de77cb0a7bd0c1e18b00df1d05\n  , ciphertext = 0xd16463745da38ef8997e20e102fb8573\n  , plaintext = 0x98ea16875a9e3006de150e93be9585b8\n  },\n\n  { key = 0x432ab1057033bb041d040e592d553a7d0ed4ef18be4a98bd\n  , ciphertext = 0x98ea16875a9e3006de150e93be9585b8\n  , plaintext = 0x9d4c05cb0c5cb543515cfd05a4b90004\n  },\n\n  { key = 0x64a7f543e2e2a60780480b9221098f3e5f88121d1af398b9\n  , ciphertext = 0x9d4c05cb0c5cb543515cfd05a4b90004\n  , plaintext = 0x93c4638f0f76b0a42481c030314ca594\n  },\n\n  { key = 0x755c48e6e44a956f138c681d2e7f3f9a7b09d22d2bbf3d2d\n  , ciphertext = 0x93c4638f0f76b0a42481c030314ca594\n  , plaintext = 0x8ad1d144144c8530218c0edf3119aa82\n  },\n\n  { key = 0x4ff1466b9e9939af995db9593a33baaa5a85dcf21aa697af\n  , ciphertext = 0x8ad1d144144c8530218c0edf3119aa82\n  , plaintext = 0xa46e11cca3b2f98e9f7360d33d236189\n  },\n\n  { key = 0xb2e265f13266035a3d33a89599814324c5f6bc212785f626\n  , ciphertext = 0xa46e11cca3b2f98e9f7360d33d236189\n  , plaintext = 0x9ece35fb84957574fd353cfac1608943\n  },\n\n  { key = 0x102d9afa0e70b1daa3fd9d6e1d14365038c380dbe6e57f65\n  , ciphertext = 0x9ece35fb84957574fd353cfac1608943\n  , plaintext = 0x225ce2f6987392afd1921c5eecd6ba17\n  },\n\n  { key = 0xc772081227697cc081a17f988567a4ffe9519c850a33c572\n  , ciphertext = 0x225ce2f6987392afd1921c5eecd6ba17\n  , plaintext = 0x85fd494bfd5127cff96088e0b130ef04\n  },\n\n  { key = 0xc306028aea2e8f1c045c36d37836833010311465bb032a76\n  , ciphertext = 0x85fd494bfd5127cff96088e0b130ef04\n  , plaintext = 0x1e693009be7a868db9e6a495c2e238f3\n  },\n\n  { key = 0x7a646ea7ab6a11101a3506dac64c05bda9d7b0f079e11285\n  , ciphertext = 0x1e693009be7a868db9e6a495c2e238f3\n  , plaintext = 0x49f55237f9a66050b7e04e66a0b4bf24\n  },\n\n  { key = 0xddbe30e84a14077953c054ed3fea65ed1e37fe96d955ada1\n  , ciphertext = 0x49f55237f9a66050b7e04e66a0b4bf24\n  , plaintext = 0xb966ec6748bd876046be2be11abff82a\n  },\n\n  { key = 0x55e1472be2e1739aeaa6b88a7757e28d5889d577c3ea558b\n  , ciphertext = 0xb966ec6748bd876046be2be11abff82a\n  , plaintext = 0x0f6a78ac23e6ea2d9f4232e8568cea97\n  },\n\n  { key = 0x38750e9c7a729e09e5ccc02654b108a0c7cbe79f9566bf1c\n  , ciphertext = 0x0f6a78ac23e6ea2d9f4232e8568cea97\n  , plaintext = 0xc80bfbe58fb9b00cd4858fd769e3cd1d\n  },\n\n  { key = 0xe45ace33a0f7494c2dc73bc3db08b8ac134e6848fc857201\n  , ciphertext = 0xc80bfbe58fb9b00cd4858fd769e3cd1d\n  , plaintext = 0x918e28b7a7ad8a370d2f260f9f7a5fec\n  },\n\n  { key = 0xd2a3b2ca9419501abc4913747ca5329b1e614e4763ff2ded\n  , ciphertext = 0x918e28b7a7ad8a370d2f260f9f7a5fec\n  , plaintext = 0x59d1732fc2452e53eeda0790b80a244a\n  },\n\n  { key = 0x9dae1b9eaa53bdfce598605bbee01cc8f0bb49d7dbf509a7\n  , ciphertext = 0x59d1732fc2452e53eeda0790b80a244a\n  , plaintext = 0xe74d820249410cd1a39287dc536ed5fc\n  },\n\n  { key = 0xe74268a3d42edb8702d5e259f7a110195329ce0b889bdc5b\n  , ciphertext = 0xe74d820249410cd1a39287dc536ed5fc\n  , plaintext = 0x27ca67828485be98a6cd22d724af53b9\n  },\n\n  { key = 0x0d793e8f7e0ea82d251f85db7324ae81f5e4ecdcac348fe2\n  , ciphertext = 0x27ca67828485be98a6cd22d724af53b9\n  , plaintext = 0x4927ab19552102414e39126b8a91c675\n  },\n\n  { key = 0xc99788fd8dc7a7246c382ec22605acc0bbddfeb726a54997\n  , ciphertext = 0x4927ab19552102414e39126b8a91c675\n  , plaintext = 0x99ea6ccf100d06243b45998d68c9b6bc\n  },\n\n  { key = 0x733425872bb717edf5d2420d3608aae48098673a4e6cff2b\n  , ciphertext = 0x99ea6ccf100d06243b45998d68c9b6bc\n  , plaintext = 0xf029e59925e67de178b5cb9fd187f2c6\n  },\n\n  { key = 0xfc02106517299a1e05fba79413eed705f82daca59feb0ded\n  , ciphertext = 0xf029e59925e67de178b5cb9fd187f2c6\n  , plaintext = 0x5f9da95aa424d5a65f1ff3d99769522d\n  },\n\n  { key = 0x9b0efe0e5f4f4e395a660eceb7ca02a3a7325f7c08825fc0\n  , ciphertext = 0x5f9da95aa424d5a65f1ff3d99769522d\n  , plaintext = 0xa20f232bb355370df27f55bb53469b40\n  },\n\n  { key = 0x502b270205133d51f8692de5049f35ae554d0ac75bc4c480\n  , ciphertext = 0xa20f232bb355370df27f55bb53469b40\n  , plaintext = 0x32e5d13e44b2e67952d8ef98af19a4d3\n  },\n\n  { key = 0xd1cac8a82a2e3ab3ca8cfcdb402dd3d70795e55ff4dd6053\n  , ciphertext = 0x32e5d13e44b2e67952d8ef98af19a4d3\n  , plaintext = 0x688ab3ed2b373467bc547be2bf519846\n  },\n\n  { key = 0x7e4af6629efd55dfa2064f366b1ae7b0bbc19ebd4b8cf815\n  , ciphertext = 0x688ab3ed2b373467bc547be2bf519846\n  , plaintext = 0x1a88d45de26cab118e86fe7089d818d0\n  },\n\n  { key = 0x216cd4ed3d38e68cb88e9b6b89764ca1354760cdc254e0c5\n  , ciphertext = 0x1a88d45de26cab118e86fe7089d818d0\n  , plaintext = 0x8d154a7ebc0e6fd2d6d7686d9b9492ad\n  },\n\n  { key = 0xedf6f3e4f323dc91359bd11535782373e39008a059c07268\n  , ciphertext = 0x8d154a7ebc0e6fd2d6d7686d9b9492ad\n  , plaintext = 0xbe46ead5f431ee2c6d1795f852558ed7\n  },\n\n  { key = 0x94afb2de656daf688bdd3bc0c149cd5f8e879d580b95fcbf\n  , ciphertext = 0xbe46ead5f431ee2c6d1795f852558ed7\n  , plaintext = 0x9f1ecd9839abd6abbecba89a71405c76\n  },\n\n  { key = 0x70bea40807c903c714c3f658f8e21bf4304c35c27ad5a0c9\n  , ciphertext = 0x9f1ecd9839abd6abbecba89a71405c76\n  , plaintext = 0xf5f335142d71d35a4723bbece7a39c43\n  },\n\n  { key = 0xb32369cb5a1611d7e130c34cd593c8ae776f8e2e9d763c8a\n  , ciphertext = 0xf5f335142d71d35a4723bbece7a39c43\n  , plaintext = 0x55ace2aa461af10d10436e529a2d8d85\n  },\n\n  { key = 0xf6412cbd1f98e445b49c21e6938939a3672ce07c075bb10f\n  , ciphertext = 0x55ace2aa461af10d10436e529a2d8d85\n  , plaintext = 0xf6670a6576aa2d20b63482aab26f7c82\n  },\n\n  { key = 0xea7cf55a9e0fcb0d42fb2b83e5231483d11862d6b534cd8d\n  , ciphertext = 0xf6670a6576aa2d20b63482aab26f7c82\n  , plaintext = 0x93e81b9866979a0adc573d380065f18e\n  },\n\n  { key = 0x1a5d1de4468ed5e5d113301b83b48e890d4f5feeb5513c03\n  , ciphertext = 0x93e81b9866979a0adc573d380065f18e\n  , plaintext = 0x324024007edad9a3e4b435b212bfec88\n  },\n\n  { key = 0x8ed3c18837593af6e353141bfd6e572ae9fb6a5ca7eed08b\n  , ciphertext = 0x324024007edad9a3e4b435b212bfec88\n  , plaintext = 0x5eb5e71f06992c1998ae0cf03dbc9dce\n  },\n\n  { key = 0xe5d6d1566d3c9a17bde6f304fbf77b33715566ac9a524d45\n  , ciphertext = 0x5eb5e71f06992c1998ae0cf03dbc9dce\n  , plaintext = 0xa83fe8f226ad5ee5b358fac03a092882\n  },\n\n  { key = 0xd5ec4f5df302bfa515d91bf6dd5a25d6c20d9c6ca05b65c7\n  , ciphertext = 0xa83fe8f226ad5ee5b358fac03a092882\n  , plaintext = 0x72360b4fcd1293a36ed0bb44213da8b9\n  },\n\n  { key = 0x50257306e757d76567ef10b91048b675acdd27288166cd7e\n  , ciphertext = 0x72360b4fcd1293a36ed0bb44213da8b9\n  , plaintext = 0x982119600a3e73dff33583558134bcf0\n  },\n\n  { key = 0x64b394f798415fbcffce09d91a76c5aa5fe8a47d0052718e\n  , ciphertext = 0x982119600a3e73dff33583558134bcf0\n  , plaintext = 0x0c33669b84d714959785b37d586bb355\n  },\n\n  { key = 0xcbaf8d92f18efe87f3fd6f429ea1d13fc86d17005839c2db\n  , ciphertext = 0x0c33669b84d714959785b37d586bb355\n  , plaintext = 0x9fc2fd51bbefd70fe7ce0c13af3d2ace\n  },\n\n  { key = 0x80bb745fb5b9cb616c3f9213254e06302fa31b13f704e815\n  , ciphertext = 0x9fc2fd51bbefd70fe7ce0c13af3d2ace\n  , plaintext = 0xaf4a4566e556a7f2dd3477a53c094498\n  },\n\n  { key = 0xb5d94340d5852f04c375d775c018a1c2f2976cb6cb0dac8d\n  , ciphertext = 0xaf4a4566e556a7f2dd3477a53c094498\n  , plaintext = 0x8107ca3fc833fee74501f2a42f088401\n  },\n\n  { key = 0x23341a3b649010c942721d4a082b5f25b7969e12e405288c\n  , ciphertext = 0x8107ca3fc833fee74501f2a42f088401\n  , plaintext = 0x714341183a67b95abcf9bc992d1aa290\n  },\n\n  { key = 0x955075d16664498333315c52324ce67f0b6f228bc91f8a1c\n  , ciphertext = 0x714341183a67b95abcf9bc992d1aa290\n  , plaintext = 0x564289f3ac30d6e27dde4308ee5637ab\n  },\n\n  { key = 0x9e5493cf59a7d0e76573d5a19e7c309d76b161832749bdb7\n  , ciphertext = 0x564289f3ac30d6e27dde4308ee5637ab\n  , plaintext = 0x805424be37b7f0b5498ab5bf8904f468\n  },\n\n  { key = 0x0e8dd0538bcfa448e527f11fa9cbc0283f3bd43cae4d49df\n  , ciphertext = 0x805424be37b7f0b5498ab5bf8904f468\n  , plaintext = 0x793554c1cc565f00f9f2122bd06672aa\n  },\n\n  { key = 0xf253723471590c249c12a5de659d9f28c6c9c6177e2b3b75\n  , ciphertext = 0x793554c1cc565f00f9f2122bd06672aa\n  , plaintext = 0xb89feee17d71a452b46e4683cfddc0ba\n  },\n\n  { key = 0x14781c9f73227825248d4b3f18ec3b7a72a78094b1f6fbcf\n  , ciphertext = 0xb89feee17d71a452b46e4683cfddc0ba\n  , plaintext = 0x737c418d35812556f6d26ebf91028ad7\n  },\n\n  { key = 0xc4706d6414a3594657f10ab22d6d1e2c8475ee2b20f47118\n  , ciphertext = 0x737c418d35812556f6d26ebf91028ad7\n  , plaintext = 0xc2e352ec712b84fa74f98254740d0847\n  },\n\n  { key = 0x74fabaf96545e7199512585e5c469ad6f08c6c7f54f9795f\n  , ciphertext = 0xc2e352ec712b84fa74f98254740d0847\n  , plaintext = 0xe09f8d7cc0e4d7f4efb65e10529592e5\n  },\n\n  { key = 0xdbfa75aad7f1ad19758dd5229ca24d221f3a326f066cebba\n  , ciphertext = 0xe09f8d7cc0e4d7f4efb65e10529592e5\n  , plaintext = 0x8a8911579e11d858bd4e336b8125fa6f\n  },\n\n  { key = 0xad8ea306bb3eb77bff04c47502b3957aa2740104874911d5\n  , ciphertext = 0x8a8911579e11d858bd4e336b8125fa6f\n  , plaintext = 0x3b1f396eae6ae53926e9607fb4b6e1d6\n  },\n\n  { key = 0x2b204520b1389d5bc41bfd1bacd97043849d617b33fff003\n  , ciphertext = 0x3b1f396eae6ae53926e9607fb4b6e1d6\n  , plaintext = 0x6d06fe256d84ab0112119425d70d5aa6\n  },\n\n  { key = 0x86d761e020a46b76a91d033ec15ddb42968cf55ee4f2aaa5\n  , ciphertext = 0x6d06fe256d84ab0112119425d70d5aa6\n  , plaintext = 0x537dd3000fdff67107362da65c95f101\n  },\n\n  { key = 0xbee0861f51136bd0fa60d03ece822d3391bad8f8b8675ba4\n  , ciphertext = 0x537dd3000fdff67107362da65c95f101\n  , plaintext = 0x2843b7b7107b1390be393137e3e266c9\n  },\n\n  { key = 0x8706a8a8fab02e3dd2236789def93ea32f83e9cf5b853d6d\n  , ciphertext = 0x2843b7b7107b1390be393137e3e266c9\n  , plaintext = 0xd5fae73a8940ec3c1bebe8a5e4fa0423\n  },\n\n  { key = 0x43ab0c1509505c7407d980b357b9d29f3468016abf7f394e\n  , ciphertext = 0xd5fae73a8940ec3c1bebe8a5e4fa0423\n  , plaintext = 0x63a9a8c99a6a8984dc6975772dd0beac\n  },\n\n  { key = 0xfb0dbb8cab3b89b16470287acdd35b1be801741d92af87e2\n  , ciphertext = 0x63a9a8c99a6a8984dc6975772dd0beac\n  , plaintext = 0x4c7b28c69c39c7eea1359ba2c167266a\n  },\n\n  { key = 0x1abc6031a84a5908280b00bc51ea9cf54934efbf53c8a188\n  , ciphertext = 0x4c7b28c69c39c7eea1359ba2c167266a\n  , plaintext = 0x076024c11bf696874d791813887685e7\n  },\n\n  { key = 0x746718f146cad3d92f6b247d4a1c0a72044df7acdbbe246f\n  , ciphertext = 0x076024c11bf696874d791813887685e7\n  , plaintext = 0xb413f148dc94e0525ad4800fb53dfc64\n  },\n\n  { key = 0x65a422dccc0f07779b78d5359688ea205e9977a36e83d80b\n  , ciphertext = 0xb413f148dc94e0525ad4800fb53dfc64\n  , plaintext = 0xbd94776297b168e862d3afd0669a2668\n  },\n\n  { key = 0x6d9fc6a3839c401426eca257013982c83c4ad8730819fe63\n  , ciphertext = 0xbd94776297b168e862d3afd0669a2668\n  , plaintext = 0xa383eb812e9d2ad7d04ef05beebc663c\n  },\n\n  { key = 0x31e8ba40171be0cc856f49d62fa4a81fec042828e6a5985f\n  , ciphertext = 0xa383eb812e9d2ad7d04ef05beebc663c\n  , plaintext = 0x125833c5a964733d24ca84ae573e537e\n  },\n\n  { key = 0xa1bd656677244e3597377a1386c0db22c8ceac86b19bcb21\n  , ciphertext = 0x125833c5a964733d24ca84ae573e537e\n  , plaintext = 0xd6597fe3687c9dc2f6087ad48bb2ab18\n  },\n\n  { key = 0x9467df27c2b90ca7416e05f0eebc46e03ec6d6523a296039\n  , ciphertext = 0xd6597fe3687c9dc2f6087ad48bb2ab18\n  , plaintext = 0xfd6abdb2793f849bedea160e34ab1a9d\n  },\n\n  { key = 0x1ee8f6b4187a87f0bc04b8429783c27bd32cc05c0e827aa4\n  , ciphertext = 0xfd6abdb2793f849bedea160e34ab1a9d\n  , plaintext = 0xfd2ccba255e74b16864ac2ff80894ebb\n  },\n\n  { key = 0x3f23c25c52d6454c412873e0c264896d556602a38e0b341f\n  , ciphertext = 0xfd2ccba255e74b16864ac2ff80894ebb\n  , plaintext = 0x4571abacb8faa74007702258220b3e19\n  },\n\n  { key = 0x4eedfc725f3901b80459d84c7a9e2e2d521620fbac000a06\n  , ciphertext = 0x4571abacb8faa74007702258220b3e19\n  , plaintext = 0x941b069f7545d16d24e69a309794a259\n  },\n\n  { key = 0xad8b4cd042b874d09042ded30fdbff4076f0bacb3b94a85f\n  , ciphertext = 0x941b069f7545d16d24e69a309794a259\n  , plaintext = 0x515ab9b50447ea30e5ab92ddd1498d69\n  },\n\n  { key = 0xc085e9fde0a60664c11867660b9c1570935b2816eadd2536\n  , ciphertext = 0x515ab9b50447ea30e5ab92ddd1498d69\n  , plaintext = 0x872c0d54b1382c095b1a475fee114cd5\n  },\n\n  { key = 0x4790a2b2ee108fbb46346a32baa43979c8416f4904cc69e3\n  , ciphertext = 0x872c0d54b1382c095b1a475fee114cd5\n  , plaintext = 0x6aa4b9e4559d2c1de4f59dafbaf0909e\n  },\n\n  { key = 0x56880340e6eaf2472c90d3d6ef3915642cb4f2e6be3cf97d\n  , ciphertext = 0x6aa4b9e4559d2c1de4f59dafbaf0909e\n  , plaintext = 0xc4ce24dd760b44799d00ce4c5ffdb8c5\n  },\n\n  { key = 0xd321a216923e2c1de85ef70b9932511db1b43caae1c141b8\n  , ciphertext = 0xc4ce24dd760b44799d00ce4c5ffdb8c5\n  , plaintext = 0xd73e44ee7f75c2fb6696aaba64af9925\n  },\n\n  { key = 0xa80125606ef3f3953f60b3e5e64793e6d7229610856ed89d\n  , ciphertext = 0xd73e44ee7f75c2fb6696aaba64af9925\n  , plaintext = 0x1add98acb3a31733b3e0a32da14a71cf\n  },\n\n  { key = 0xfd54730799c76e1e25bd2b4955e484d564c2353d2424a952\n  , ciphertext = 0x1add98acb3a31733b3e0a32da14a71cf\n  , plaintext = 0x6d2201f6268f7c126e4d57375f5ac97b\n  },\n\n  { key = 0xb07e344619df38e5489f2abf736bf8c70a8f620a7b7e6029\n  , ciphertext = 0x6d2201f6268f7c126e4d57375f5ac97b\n  , plaintext = 0x349daafd5a9676a0bf5e015319a5083b\n  },\n\n  { key = 0xf66e7702379bbeac7c02804229fd8e67b5d1635962db6812\n  , ciphertext = 0x349daafd5a9676a0bf5e015319a5083b\n  , plaintext = 0xfd6cd698388a46f696da48543a327e10\n  },\n\n  { key = 0x1aab1a249cb5fa91816e56da1177c891230b2b0d58e91602\n  , ciphertext = 0xfd6cd698388a46f696da48543a327e10\n  , plaintext = 0xbaa9b8a3f9ffa86241bb5abe04b7eea5\n  },\n\n  { key = 0xdd881f3432073d253bc7ee79e88860f362b071b35c5ef8a7\n  , ciphertext = 0xbaa9b8a3f9ffa86241bb5abe04b7eea5\n  , plaintext = 0x19ad5a0619f1b5eed38fb5fbbbbe1247\n  },\n\n  { key = 0xd4088261dda8dfc1226ab47ff179d51db13fc448e7e0eae0\n  , ciphertext = 0x19ad5a0619f1b5eed38fb5fbbbbe1247\n  , plaintext = 0x832e01274c6a59b148dc6de3e6ccc037\n  },\n\n  { key = 0x0ff97f22bdef4005a144b558bd138cacf9e3a9ab012c2ad7\n  , ciphertext = 0x832e01274c6a59b148dc6de3e6ccc037\n  , plaintext = 0x9853ba4a0880449a6344fd0dabfc9e74\n  },\n\n  { key = 0xa2f2351138f53ed639170f12b593c8369aa754a6aad0b4a3\n  , ciphertext = 0x9853ba4a0880449a6344fd0dabfc9e74\n  , plaintext = 0x89ebc090e07d36670f48a32074c9ca18\n  },\n\n  { key = 0xb7c564161c5e5061b0fccf8255eefe5195eff786de197ebb\n  , ciphertext = 0x89ebc090e07d36670f48a32074c9ca18\n  , plaintext = 0x5695154c14aeb5d09a516ca802d7fb21\n  },\n\n  { key = 0x95aa68a5ba0d346be669dace41404b810fbe9b2edcce859a\n  , ciphertext = 0x5695154c14aeb5d09a516ca802d7fb21\n  , plaintext = 0xf49c9100c165c22f16661c23bf46520e\n  },\n\n  { key = 0x028f06458b3a50ce12f54bce802589ae19d8870d6388d794\n  , ciphertext = 0xf49c9100c165c22f16661c23bf46520e\n  , plaintext = 0x1aec4f3ade3b41dd3d5448dc7e577e67\n  },\n\n  { key = 0xe0b75db3cfb1e3f6081904f45e1ec873248ccfd11ddfa9f3\n  , ciphertext = 0x1aec4f3ade3b41dd3d5448dc7e577e67\n  , plaintext = 0x5c75fbcaa893326641aa343f40f6ee31\n  },\n\n  { key = 0xe51161c0ee3bf4fe546cff3ef68dfa156526fbee5d2947c2\n  , ciphertext = 0x5c75fbcaa893326641aa343f40f6ee31\n  , plaintext = 0xa2c953d404212d5da4e98f31d8cc0a5b\n  },\n\n  { key = 0x1f13dd6e77477337f6a5aceaf2acd748c1cf74df85e54d99\n  , ciphertext = 0xa2c953d404212d5da4e98f31d8cc0a5b\n  , plaintext = 0x17ea5bd0c139ce391240ff701085b060\n  },\n\n  { key = 0x547e1d3ba5988327e14ff73a33951971d38f8baf9560fdf9\n  , ciphertext = 0x17ea5bd0c139ce391240ff701085b060\n  , plaintext = 0x98d87acaeb843ccf7b6e92a1889ff129\n  },\n\n  { key = 0xd140d82958fb4d8979978df0d81125bea8e1190e1dff0cd0\n  , ciphertext = 0x98d87acaeb843ccf7b6e92a1889ff129\n  , plaintext = 0x0c2132942034442ea6eb14d23ccdf868\n  },\n\n  { key = 0xf311ab46bba28f9a75b6bf64f82561900e0a0ddc2132f4b8\n  , ciphertext = 0x0c2132942034442ea6eb14d23ccdf868\n  , plaintext = 0x91341b217d521168251ad3778171e5ba\n  },\n\n  { key = 0x0abea37884946aa1e482a445857770f82b10deaba0431102\n  , ciphertext = 0x91341b217d521168251ad3778171e5ba\n  , plaintext = 0xb63ef1b79507a62eba3dafcec54a6328\n  }]\n\nproperty aes256_MCT_vectors_encrypt_correct =\n  aes256_MCT_encrypt_test_vectors ==\n  mct_ecb_encrypt_256\n    0xf9e8389f5b80712e3886cc1fa2d28a3b8c9cd88a2d4a54c6aa86ce0fef944be0\n    0xb379777f9050e2a818f2940cbbd9aba4\n\nproperty aes256_MCT_vectors_decrypt_correct =\n  aes256_MCT_decrypt_test_vectors ==\n  mct_ecb_decrypt_256\n    0x2b09ba39b834062b9e93f48373b8dd018dedf1e5ba1b8af831ebbacbc92a2643\n    0x89649bd0115f30bd878567610223a59d\n\naes256_MCT_encrypt_test_vectors : [100](AESTestVector 256)\naes256_MCT_encrypt_test_vectors =\n  [{ key = 0xf9e8389f5b80712e3886cc1fa2d28a3b8c9cd88a2d4a54c6aa86ce0fef944be0\n  , plaintext = 0xb379777f9050e2a818f2940cbbd9aba4\n  , ciphertext = 0x6893ebaf0a1fccc704326529fdfb60db\n  },\n\n  { key = 0xdb9ea5a2284fa17fb63e13bf891c8e42e40f332527559801aeb4ab26126f2b3b\n  , plaintext = 0x6893ebaf0a1fccc704326529fdfb60db\n  , ciphertext = 0xf3c78a5e85e5439bf26d5818718157d6\n  },\n\n  { key = 0x7099ed88e82744228a5303ae2ef6c0d017c8b97ba2b0db9a5cd9f33e63ee7ced\n  , plaintext = 0xf3c78a5e85e5439bf26d5818718157d6\n  , ciphertext = 0x2326b958b00b3050697eedb08cc20504\n  },\n\n  { key = 0x5e9e65ea96e78dd4fb78ea1184f6ebde34ee002312bbebca35a71e8eef2c79e9\n  , plaintext = 0x2326b958b00b3050697eedb08cc20504\n  , ciphertext = 0xec4332d5e3cebd3e0f5fc51452f4560d\n  },\n\n  { key = 0x33acf1cafc822646dc869e905bd26f9ad8ad32f6f17556f43af8db9abdd82fe4\n  , plaintext = 0xec4332d5e3cebd3e0f5fc51452f4560d\n  , ciphertext = 0x5da58b5ef2076340d555f861c3449a77\n  },\n\n  { key = 0xeb0ae85c1b44d5db4729d268f49be2a08508b9a8037235b4efad23fb7e9cb593\n  , plaintext = 0x5da58b5ef2076340d555f861c3449a77\n  , ciphertext = 0x307d50c18a0b6a08402ff131d72cb7ec\n  },\n\n  { key = 0xfac93b561a9b6a0e809d71ecdb980afab575e96989795fbcaf82d2caa9b0027f\n  , plaintext = 0x307d50c18a0b6a08402ff131d72cb7ec\n  , ciphertext = 0x92c34165a2963e77e05e2d6fc2d931d5\n  },\n\n  { key = 0xa0559e41d58af36174a67246df87541b27b6a80c2bef61cb4fdcffa56b6933aa\n  , plaintext = 0x92c34165a2963e77e05e2d6fc2d931d5\n  , ciphertext = 0xcb33d519a1fdb1d5fbb185c47870c1ed\n  },\n\n  { key = 0xe48824d6c2251d3a27f38fb543c31fc1ec857d158a12d01eb46d7a611319f247\n  , plaintext = 0xcb33d519a1fdb1d5fbb185c47870c1ed\n  , ciphertext = 0x78fb452f384c8f870e572890588f3728\n  },\n\n  { key = 0x7a33440ad7c69d583355c745e5c88c47947e383ab25e5f99ba3a52f14b96c56f\n  , plaintext = 0x78fb452f384c8f870e572890588f3728\n  , ciphertext = 0x12375e02a8bbc84b00feaab54a66db43\n  },\n\n  { key = 0x0e6877c7fdc234efb9afcd96b4ebdb83864966381ae597d2bac4f84401f01e2c\n  , plaintext = 0x12375e02a8bbc84b00feaab54a66db43\n  , ciphertext = 0xeab1606610b55c857f2b4bf1cf3feba0\n  },\n\n  { key = 0xec91d3550c79ab4914a26987725ab1396cf8065e0a50cb57c5efb3b5cecff58c\n  , plaintext = 0xeab1606610b55c857f2b4bf1cf3feba0\n  , ciphertext = 0x6c73381147de97961cc26ad26602a45a\n  },\n\n  { key = 0x83caed5a49579b3a55a71e5ece5966e5008b3e4f4d8e5cc1d92dd967a8cd51d6\n  , plaintext = 0x6c73381147de97961cc26ad26602a45a\n  , ciphertext = 0xe76c08fd29bf015352003c636fee5ff9\n  },\n\n  { key = 0x91b9b50908968361dcd8f4ba236fa199e7e736b264315d928b2de504c7230e2f\n  , plaintext = 0xe76c08fd29bf015352003c636fee5ff9\n  , ciphertext = 0x6f26b8191a2b059dcdeb3dbabc437c29\n  },\n\n  { key = 0x94fc46213c870f7965b88773afe93b1388c18eab7e1a580f46c6d8be7b607206\n  , plaintext = 0x6f26b8191a2b059dcdeb3dbabc437c29\n  , ciphertext = 0xe91e2fcef14dd4251caec97c45223fef\n  },\n\n  { key = 0xb0deff009aff61f65763b0b9fdd39a9061dfa1658f578c2a5a6811c23e424de9\n  , plaintext = 0xe91e2fcef14dd4251caec97c45223fef\n  , ciphertext = 0x98fb2122912360f07916e4802c0ea1e5\n  },\n\n  { key = 0x968f3c88d27f1be8decb00c4d464d369f92480471e74ecda237ef542124cec0c\n  , plaintext = 0x98fb2122912360f07916e4802c0ea1e5\n  , ciphertext = 0xb4a15c59976b39da50da8ed393f27a62\n  },\n\n  { key = 0x35fe06a60309581565a97232140668464d85dc1e891fd50073a47b9181be966e\n  , plaintext = 0xb4a15c59976b39da50da8ed393f27a62\n  , ciphertext = 0xd8b57d7a72ef92409c51d40bb8c4cbc5\n  },\n\n  { key = 0x4739043d7750bcf4a6f269a3d54083ca9530a164fbf04740eff5af9a397a5dab\n  , plaintext = 0xd8b57d7a72ef92409c51d40bb8c4cbc5\n  , ciphertext = 0x548cc893e80caf5a601c2381517f8c5b\n  },\n\n  { key = 0x4b065b5195f2ddf6f5d0aed72ff7a1e3c1bc69f713fce81a8fe98c1b6805d1f0\n  , plaintext = 0x548cc893e80caf5a601c2381517f8c5b\n  , ciphertext = 0x1c2238c560d678d40b48cc8034add0c4\n  },\n\n  { key = 0x1a949129e14c5963d997c86a6352ea53dd9e5132732a90ce84a1409b5ca80134\n  , plaintext = 0x1c2238c560d678d40b48cc8034add0c4\n  , ciphertext = 0x2771ff806e061df8ad4aa877717bf309\n  },\n\n  { key = 0x91cd3e48f4b42c432bed9848583e6dc7faefaeb21d2c8d3629ebe8ec2dd3f23d\n  , plaintext = 0x2771ff806e061df8ad4aa877717bf309\n  , ciphertext = 0x065593fa1fcdb481bb27f334505543f5\n  },\n\n  { key = 0x42d6f7b585a0a0d356c59be3d07d4d41fcba3d4802e139b792cc1bd87d86b1c8\n  , plaintext = 0x065593fa1fcdb481bb27f334505543f5\n  , ciphertext = 0xd3f309c0039b15d14eb8b739a94b94fa\n  },\n\n  { key = 0x72900f0ecbf90fa058805deb430815072f493488017a2c66dc74ace1d4cd2532\n  , plaintext = 0xd3f309c0039b15d14eb8b739a94b94fa\n  , ciphertext = 0x4e441a3fb277d6fbe0ed7c6e080d9a9f\n  },\n\n  { key = 0x12ef8789b91a8e35fd0ac79457a906f0610d2eb7b30dfa9d3c99d08fdcc0bfad\n  , plaintext = 0x4e441a3fb277d6fbe0ed7c6e080d9a9f\n  , ciphertext = 0xcb9241bc964cbc9823531f68e3a03b7c\n  },\n\n  { key = 0x2cbe5980ad54c5dbf2ee3db1e9875733aa9f6f0b254146051fcacfe73f6084d1\n  , plaintext = 0xcb9241bc964cbc9823531f68e3a03b7c\n  , ciphertext = 0x70b17c3e869aca6076617a2cf75e9f4a\n  },\n\n  { key = 0xdc4da3812736a2a603bcc6390763c5c5da2e1335a3db8c6569abb5cbc83e1b9b\n  , plaintext = 0x70b17c3e869aca6076617a2cf75e9f4a\n  , ciphertext = 0xf4b8a6ed6d6d72aff59484314f210bb9\n  },\n\n  { key = 0x2e4e21a6eb77bb39a1cb5cd20cc5fd3b2e96b5d8ceb6feca9c3f31fa871f1022\n  , plaintext = 0xf4b8a6ed6d6d72aff59484314f210bb9\n  , ciphertext = 0xf56a4597beaeafc0c14ee73988bcbee8\n  },\n\n  { key = 0x54d5c037e61fd09e5cf57fd34c5e0192dbfcf04f7018510a5d71d6c30fa3aeca\n  , plaintext = 0xf56a4597beaeafc0c14ee73988bcbee8\n  , ciphertext = 0x04333079d5352236e1c79213f3f38dbe\n  },\n\n  { key = 0x3a5da203e03fa399caeb1fac63679b56dfcfc036a52d733cbcb644d0fc502374\n  , plaintext = 0x04333079d5352236e1c79213f3f38dbe\n  , ciphertext = 0x22c97ecdf4af830f94b11951f41e4d29\n  },\n\n  { key = 0x5c84147d6ab2051b56b0993a7cbfa306fd06befb5182f03328075d81084e6e5d\n  , plaintext = 0x22c97ecdf4af830f94b11951f41e4d29\n  , ciphertext = 0xdef46a3b39c8048431d2491d97daa6ea\n  },\n\n  { key = 0x7af77aa155a33f658283ebc3e9eb708923f2d4c0684af4b719d5149c9f94c8b7\n  , plaintext = 0xdef46a3b39c8048431d2491d97daa6ea\n  , ciphertext = 0x4c6367ad8a2190366c3d730fe5eeb6ee\n  },\n\n  { key = 0xedabba9dc9d87357bb91da6931c743e16f91b36de26b648175e867937a7a7e59\n  , plaintext = 0x4c6367ad8a2190366c3d730fe5eeb6ee\n  , ciphertext = 0x90bd09b4eb0f7d8397c0026cefea8fb3\n  },\n\n  { key = 0xab7ef1b4a1e43771de88e158ad26a419ff2cbad909641902e22865ff9590f1ea\n  , plaintext = 0x90bd09b4eb0f7d8397c0026cefea8fb3\n  , ciphertext = 0x25aefcfa6ec98fae81b93afad7761711\n  },\n\n  { key = 0x6b0145c6cbeaae320be86c2909c8d643da82462367ad96ac63915f0542e6e6fb\n  , plaintext = 0x25aefcfa6ec98fae81b93afad7761711\n  , ciphertext = 0x607b26f4eb3585e3e886e75c0f3a01cf\n  },\n\n  { key = 0xb46d28c20a614b6d986e92795258631cbaf960d78c98134f8b17b8594ddce734\n  , plaintext = 0x607b26f4eb3585e3e886e75c0f3a01cf\n  , ciphertext = 0xfe35fe16a3290042c28c021ee9ede73f\n  },\n\n  { key = 0x93c5c8403410764717e547e3d07b0ec344cc9ec12fb1130d499bba47a431000b\n  , plaintext = 0xfe35fe16a3290042c28c021ee9ede73f\n  , ciphertext = 0x0141871c357a00ad37ae65597830cac8\n  },\n\n  { key = 0xcf85ea60e0c94e611fedba48e19e9693458d19dd1acb13a07e35df1edc01cac3\n  , plaintext = 0x0141871c357a00ad37ae65597830cac8\n  , ciphertext = 0xdf8bc7782ae10eb2c1bdfdc8887e4907\n  },\n\n  { key = 0xd40735932ea269aeb51fa3caf0c176d89a06dea5302a1d12bf8822d6547f83c4\n  , plaintext = 0xdf8bc7782ae10eb2c1bdfdc8887e4907\n  , ciphertext = 0x1ac65c65b6cd8ab751f1d908ebd962ab\n  },\n\n  { key = 0x9a7120341819fe54fc8a750d17ecf20f80c082c086e797a5ee79fbdebfa6e16f\n  , plaintext = 0x1ac65c65b6cd8ab751f1d908ebd962ab\n  , ciphertext = 0x9f10b53fb6adf7189e277d04e351aa9d\n  },\n\n  { key = 0x8c19642c172cdb804059f751b3f25cff1fd037ff304a60bd705e86da5cf74bf2\n  , plaintext = 0x9f10b53fb6adf7189e277d04e351aa9d\n  , ciphertext = 0xc94ecc943ddc8d1eeafadd173cf73fdc\n  },\n\n  { key = 0xe1cc9575e51d6a8240e6f3cd8958e1a6d69efb6b0d96eda39aa45bcd6000742e\n  , plaintext = 0xc94ecc943ddc8d1eeafadd173cf73fdc\n  , ciphertext = 0x5dd513d74b72f9d46b06b4b96a94c3bd\n  },\n\n  { key = 0xce41ff2d70b2169fad6a5f9ead4471e88b4be8bc46e41477f1a2ef740a94b793\n  , plaintext = 0x5dd513d74b72f9d46b06b4b96a94c3bd\n  , ciphertext = 0x1594a31cc22cdbaf2011a9a317538608\n  },\n\n  { key = 0x7b467b87180772677903a043bc63c3ef9edf4ba084c8cfd8d1b346d71dc7319b\n  , plaintext = 0x1594a31cc22cdbaf2011a9a317538608\n  , ciphertext = 0x4d5e8d6fa3e2ea343b5afb77124529aa\n  },\n\n  { key = 0xca068b3afc717d1f6e8dc7e4eca0f56fd381c6cf272a25eceae9bda00f821831\n  , plaintext = 0x4d5e8d6fa3e2ea343b5afb77124529aa\n  , ciphertext = 0x1bbf651cf61c295c96e73a210483d7a1\n  },\n\n  { key = 0xd04d80998a971ec52d5390fa7eaf78eac83ea3d3d1360cb07c0e87810b01cf90\n  , plaintext = 0x1bbf651cf61c295c96e73a210483d7a1\n  , ciphertext = 0x84b42f75c3b62bbf21707ba66cca399f\n  },\n\n  { key = 0x2cfb1c71e8cac872e6a6dc90b0195acf4c8a8ca61280270f5d7efc2767cbf60f\n  , plaintext = 0x84b42f75c3b62bbf21707ba66cca399f\n  , ciphertext = 0xa0c514e1e6a9c659f605eff4cf4951a0\n  },\n\n  { key = 0x405bc450a19e6dae76847b8eac858c8bec4f9847f429e156ab7b13d3a882a7af\n  , plaintext = 0xa0c514e1e6a9c659f605eff4cf4951a0\n  , ciphertext = 0x1dcc38307c6b3c31e25f868b279b3711\n  },\n\n  { key = 0x35755fe97d9aeb1e67c1f4ca5a40ce1ff183a0778842dd67492495588f1990be\n  , plaintext = 0x1dcc38307c6b3c31e25f868b279b3711\n  , ciphertext = 0xcdd744574664be7b221d7a2921b4f0b2\n  },\n\n  { key = 0x7e9d8b4bbd2aad70d229247d5880a0cb3c54e420ce26631c6b39ef71aead600c\n  , plaintext = 0xcdd744574664be7b221d7a2921b4f0b2\n  , ciphertext = 0xe602ef85184ad4a86ed339e9403f541c\n  },\n\n  { key = 0x73be0bb5b74a8f6324f8a5f0acbf5faada560ba5d66cb7b405ead698ee923410\n  , plaintext = 0xe602ef85184ad4a86ed339e9403f541c\n  , ciphertext = 0x7c227f03e605ff14c42fb9f8e8786e84\n  },\n\n  { key = 0xc82e22faeca51a38045f2a3a04a0e6e2a67474a6306948a0c1c56f6006ea5a94\n  , plaintext = 0x7c227f03e605ff14c42fb9f8e8786e84\n  , ciphertext = 0x94c0466b27aa4d361b19c250329c14a0\n  },\n\n  { key = 0x7c1dd42bdff414e3733b846cbb00c43432b432cd17c30596dadcad3034764e34\n  , plaintext = 0x94c0466b27aa4d361b19c250329c14a0\n  , ciphertext = 0xfd6b281c93c1fd8e9b83b69ecf722f3b\n  },\n\n  { key = 0xaa7ec003efbca86fe5ad028d0571cf3acfdf1ad18402f818415f1baefb04610f\n  , plaintext = 0xfd6b281c93c1fd8e9b83b69ecf722f3b\n  , ciphertext = 0xa75b28be92dc53de9d44714918e3c541\n  },\n\n  { key = 0x14ba26bafb6c8410104d70ec23876db56884326f16deabc6dc1b6ae7e3e7a44e\n  , plaintext = 0xa75b28be92dc53de9d44714918e3c541\n  , ciphertext = 0x48693025ba68f3fa3515e7112b6e32aa\n  },\n\n  { key = 0x33b40738b39ebe39118938c6461ebd7820ed024aacb6583ce90e8df6c88996e4\n  , plaintext = 0x48693025ba68f3fa3515e7112b6e32aa\n  , ciphertext = 0x6bfa37cc5ed6e5d4ddf40b1301957f73\n  },\n\n  { key = 0x0d16eab1b56e2a468bf1ba1035129d574b173586f260bde834fa86e5c91ce997\n  , plaintext = 0x6bfa37cc5ed6e5d4ddf40b1301957f73\n  , ciphertext = 0xca18b89c3225877e02e21042af9836a8\n  },\n\n  { key = 0x44b55514a5b4a5a4294f3cf8e75ff73c810f8d1ac0453a96361896a76684df3f\n  , plaintext = 0xca18b89c3225877e02e21042af9836a8\n  , ciphertext = 0xc3ebc08368be58f8f514cfbd5f98ed52\n  },\n\n  { key = 0x265f1a7a53151bc51526fe476e8c63ad42e44d99a8fb626ec30c591a391c326d\n  , plaintext = 0xc3ebc08368be58f8f514cfbd5f98ed52\n  , ciphertext = 0x788552397ddf2d5841dbc0e73dd11150\n  },\n\n  { key = 0x23fa4630937015585ac065e6a7bd93023a611fa0d5244f3682d799fd04cd233d\n  , plaintext = 0x788552397ddf2d5841dbc0e73dd11150\n  , ciphertext = 0xe9d728bc19b50809bc1245552091d0b2\n  },\n\n  { key = 0x9dd3a2408e5694fced28964c7f442e6ed3b6371ccc91473f3ec5dca8245cf38f\n  , plaintext = 0xe9d728bc19b50809bc1245552091d0b2\n  , ciphertext = 0xce08d78b58179b7957eeab6f74ddb10f\n  },\n\n  { key = 0x055d53ef574a63f77c0b3a88e7e7cdb01dbee0979486dc46692b77c750814280\n  , plaintext = 0xce08d78b58179b7957eeab6f74ddb10f\n  , ciphertext = 0x33ce33e80fcc262e9e862f5ac50c14df\n  },\n\n  { key = 0xc1a90cdef5d5daaf7b182d6b409940e62e70d37f9b4afa68f7ad589d958d565f\n  , plaintext = 0x33ce33e80fcc262e9e862f5ac50c14df\n  , ciphertext = 0x5c4d21e6045f11f9f91a8cef130304e0\n  },\n\n  { key = 0x6a257a4f65bdd7d882ff45ffbb9541e5723df2999f15eb910eb7d472868e52bf\n  , plaintext = 0x5c4d21e6045f11f9f91a8cef130304e0\n  , ciphertext = 0x4f50679c2dbfa63b5e55d031afacd44b\n  },\n\n  { key = 0x5843bf4d6afc64273d328e1baf7821b03d6d9505b2aa4daa50e20443292286f4\n  , plaintext = 0x4f50679c2dbfa63b5e55d031afacd44b\n  , ciphertext = 0x29f64e79de48f3d3d5dff92aa0b1783b\n  },\n\n  { key = 0x8915060a33758a300c053d365c304d4e149bdb7c6ce2be79853dfd698993fecf\n  , plaintext = 0x29f64e79de48f3d3d5dff92aa0b1783b\n  , ciphertext = 0x8c5bf92515a92449846593a3bdbe521b\n  },\n\n  { key = 0xbe2b2a41b3491511c181508b66ec96f798c02259794b9a3001586eca342dacd4\n  , plaintext = 0x8c5bf92515a92449846593a3bdbe521b\n  , ciphertext = 0x5511fef7a2238277aaa9e25f1d097c19\n  },\n\n  { key = 0x4d6f38935317ffa0cb29bdfa8a43cd19cdd1dcaedb681847abf18c952924d0cd\n  , plaintext = 0x5511fef7a2238277aaa9e25f1d097c19\n  , ciphertext = 0x2ecd75c6a5eace1c541e12db150a2143\n  },\n\n  { key = 0x1549ea3d167152c85223b0a603d1fa61e31ca9687e82d65bffef9e4e3c2ef18e\n  , plaintext = 0x2ecd75c6a5eace1c541e12db150a2143\n  , ciphertext = 0x6a4cfcb9e8dae9610df99509daac7be0\n  },\n\n  { key = 0xba593f6731f70edab83f5cdf02527436895055d196583f3af2160b47e6828a6e\n  , plaintext = 0x6a4cfcb9e8dae9610df99509daac7be0\n  , ciphertext = 0x185772deff51807147ac5350249b3e1a\n  },\n\n  { key = 0x7126a05712f987f1c9249bf9a7c17b4f9107270f6909bf4bb5ba5817c219b474\n  , plaintext = 0x185772deff51807147ac5350249b3e1a\n  , ciphertext = 0xbfb1ce7df706bc972e1b8306d44aa135\n  },\n\n  { key = 0x3d0fa3983ebc8a3f64c4135d7cd3195e2eb6e9729e0f03dc9ba1db1116531541\n  , plaintext = 0xbfb1ce7df706bc972e1b8306d44aa135\n  , ciphertext = 0xf21df1e99a781dba4a68ff3491848f99\n  },\n\n  { key = 0x88c88ec4d63eb481cd8d6e8e8d2e2715dcab189b04771e66d1c9242587d79ad8\n  , plaintext = 0xf21df1e99a781dba4a68ff3491848f99\n  , ciphertext = 0xe4e8c9e4963a44f5cf27767e4e42fa61\n  },\n\n  { key = 0x989b9545625a4025f7725d63847213883843d17f924d5a931eee525bc99560b9\n  , plaintext = 0xe4e8c9e4963a44f5cf27767e4e42fa61\n  , ciphertext = 0x27475121d0e3367d0e0c2d9fb39cfe95\n  },\n\n  { key = 0xf49b61f190f982aa866d5c8f2e5749781f04805e42ae6cee10e27fc47a099e2c\n  , plaintext = 0x27475121d0e3367d0e0c2d9fb39cfe95\n  , ciphertext = 0xc2990626cb34c5d7fafe0430650ed907\n  },\n\n  { key = 0x101537d5f633ad8dc7e8cc058ce7fe20dd9d8678899aa939ea1c7bf41f07472b\n  , plaintext = 0xc2990626cb34c5d7fafe0430650ed907\n  , ciphertext = 0x1c5d0cca2845b66c371c1760f81e024a\n  },\n\n  { key = 0x1f6acaa66674733d28dfec92c43c7e76c1c08ab2a1df1f55dd006c94e7194561\n  , plaintext = 0x1c5d0cca2845b66c371c1760f81e024a\n  , ciphertext = 0x6f5a53addd93c9a136401a804a710419\n  },\n\n  { key = 0xb55bdefe370646699012062df748b6aaae9ad91f7c4cd6f4eb407614ad684178\n  , plaintext = 0x6f5a53addd93c9a136401a804a710419\n  , ciphertext = 0x8e0c070be7109ead0e8cc0aa0bf95e61\n  },\n\n  { key = 0xde09c34a85d56a2748559c309f04eb722096de149b5c4859e5ccb6bea6911f19\n  , plaintext = 0x8e0c070be7109ead0e8cc0aa0bf95e61\n  , ciphertext = 0xdb53b5306561db899a635a56c56e7239\n  },\n\n  { key = 0x2650ecd133a5df3825072a4df2d95d15fbc56b24fe3d93d07fafece863ff6d20\n  , plaintext = 0xdb53b5306561db899a635a56c56e7239\n  , ciphertext = 0x72e5ac05990d3f5508295f95f8973313\n  },\n\n  { key = 0xa8599f0edd6446b4bb9371e380bf33488920c7216730ac857786b37d9b685e33\n  , plaintext = 0x72e5ac05990d3f5508295f95f8973313\n  , ciphertext = 0x86a8332f16f997bc02af5271c64e7e0f\n  },\n\n  { key = 0x672e7b0d497458e260084662c566394e0f88f40e71c93b397529e10c5d26203c\n  , plaintext = 0x86a8332f16f997bc02af5271c64e7e0f\n  , ciphertext = 0x8e53858ce7ad0d25410f886eeeca1e0e\n  },\n\n  { key = 0x73ea41a50cdd5a98644e6f8d974af21381db71829664361c34266962b3ec3e32\n  , plaintext = 0x8e53858ce7ad0d25410f886eeeca1e0e\n  , ciphertext = 0xc6a1d493d607d2cef6aef29ee878c434\n  },\n\n  { key = 0x14969b3ff78ccdd66c53b8027a79563e477aa5114063e4d2c2889bfc5b94fa06\n  , plaintext = 0xc6a1d493d607d2cef6aef29ee878c434\n  , ciphertext = 0xa4973e0cfaf8d6ac6758615fc81e06df\n  },\n\n  { key = 0xd09e2741b9480c2166c9c1832654763de3ed9b1dba9b327ea5d0faa3938afcd9\n  , plaintext = 0xa4973e0cfaf8d6ac6758615fc81e06df\n  , ciphertext = 0x67e3243d8bc81887517708a29a5d9ae5\n  },\n\n  { key = 0x22c65ead303a0395cc9c065ada930ddd840ebf2031532af9f4a7f20109d7663c\n  , plaintext = 0x67e3243d8bc81887517708a29a5d9ae5\n  , ciphertext = 0xde2f35df51644cf5d79984be6c17c14c\n  },\n\n  { key = 0x8679ef0357516245ec489386419646bc5a218aff6037660c233e76bf65c0a770\n  , plaintext = 0xde2f35df51644cf5d79984be6c17c14c\n  , ciphertext = 0x9eaedabb3bd046ec27a2bdafabdbc861\n  },\n\n  { key = 0x6043902c115f107639e7c92ba4952301c48f50445be720e0049ccb10ce1b6f11\n  , plaintext = 0x9eaedabb3bd046ec27a2bdafabdbc861\n  , ciphertext = 0x0cde7e6c1aecbbe996865bf30b178de7\n  },\n\n  { key = 0xaca443a9e31033ea73b1eeda6e7d6ca1c8512e28410b9b09921a90e3c50ce2f6\n  , plaintext = 0x0cde7e6c1aecbbe996865bf30b178de7\n  , ciphertext = 0xba25bf5be1e4c099b9e45eedd7369cb5\n  },\n\n  { key = 0x60362e2b0bf998c875c087c370c4ca4772749173a0ef5b902bfece0e123a7e43\n  , plaintext = 0xba25bf5be1e4c099b9e45eedd7369cb5\n  , ciphertext = 0x805be62789549ce6af74966467f41135\n  },\n\n  { key = 0x6d7f0f7584162a1fa4dd6764548f355af22f775429bbc776848a586a75ce6f76\n  , plaintext = 0x805be62789549ce6af74966467f41135\n  , ciphertext = 0xab6001c6c4c56e8ca393c5fd173505ba\n  },\n\n  { key = 0xd8ecc39ac1d00c53216f6e64e826a7a9594f7692ed7ea9fa27199d9762fb6acc\n  , plaintext = 0xab6001c6c4c56e8ca393c5fd173505ba\n  , ciphertext = 0x3ba3673f4f495dd1541d47c22b7921c5\n  },\n\n  { key = 0x493108f91caedf714652149a2b2030fe62ec11ada237f42b7304da5549824b09\n  , plaintext = 0x3ba3673f4f495dd1541d47c22b7921c5\n  , ciphertext = 0xb24fe17cdc5c8cfa4260c38691b57bfa\n  },\n\n  { key = 0x446af6dd5f58755aeaa0a1226d8c584fd0a3f0d17e6b78d1316419d3d83730f3\n  , plaintext = 0xb24fe17cdc5c8cfa4260c38691b57bfa\n  , ciphertext = 0x86d999a63b96f6c9d9aaf3be6202977b\n  },\n\n  { key = 0x65f92d4e1723d5e58aeb350c79df28de567a697745fd8e18e8ceea6dba35a788\n  , plaintext = 0x86d999a63b96f6c9d9aaf3be6202977b\n  , ciphertext = 0xc4712aa733f9737f91e4ed61609e02f1\n  },\n\n  { key = 0x915cee6af4ea95623f7122acda5e9040920b43d07604fd67792a070cdaaba579\n  , plaintext = 0xc4712aa733f9737f91e4ed61609e02f1\n  , ciphertext = 0x0e8c1a77b280f4c753682768fd6f3b23\n  },\n\n  { key = 0x8e9bb2887fe60d42db4d827f00ba68ff9c8759a7c48409a02a42206427c49e5a\n  , plaintext = 0x0e8c1a77b280f4c753682768fd6f3b23\n  , ciphertext = 0xdccb684d47c480cc1317dcaa451234c0\n  },\n\n  { key = 0xcbf85a6645469e5df882fe840776b6aa404c31ea8340896c3955fcce62d6aa9a\n  , plaintext = 0xdccb684d47c480cc1317dcaa451234c0\n  , ciphertext = 0x9a2c4f07489c14265e33ac031d02b3d8\n  },\n\n  { key = 0x3ea3c33d7439ab3c478c01907f13cda7da607eedcbdc9d4a676650cd7fd41942\n  , plaintext = 0x9a2c4f07489c14265e33ac031d02b3d8\n  , ciphertext = 0x5c8e622ddbd32ee79c17572e8b3ee61c\n  },\n\n  { key = 0x312c5b43263c1af8d1e35c0f24d1004386ee1cc0100fb3adfb7107e3f4eaff5e\n  , plaintext = 0x5c8e622ddbd32ee79c17572e8b3ee61c\n  , ciphertext = 0xc5d2cb3d5b7ff0e23e308967ee074825\n  }]\n\naes256_MCT_decrypt_test_vectors : [100](AESTestVector 256)\naes256_MCT_decrypt_test_vectors =\n  [{ key = 0x2b09ba39b834062b9e93f48373b8dd018dedf1e5ba1b8af831ebbacbc92a2643\n  , ciphertext = 0x89649bd0115f30bd878567610223a59d\n  , plaintext = 0x1f9b9b213f1884fa98b62dd6639fd33b\n  },\n\n  { key = 0x58ac71619fdc3ac73a17f285319e1cd492766ac485030e02a95d971daab5f578\n  , ciphertext = 0x1f9b9b213f1884fa98b62dd6639fd33b\n  , plaintext = 0xaecd334ef8fb0c51b6896ae065d8be28\n  },\n\n  { key = 0xf6e3cca2cd628c10625c62cf08b385743cbb598a7df802531fd4fdfdcf6d4b50\n  , ciphertext = 0xaecd334ef8fb0c51b6896ae065d8be28\n  , plaintext = 0xf1938dd245c055e9c380336ff8450d9d\n  },\n\n  { key = 0xa9ae3bd7d454f19d69289875ff009d16cd28d458383857badc54ce92372846cd\n  , ciphertext = 0xf1938dd245c055e9c380336ff8450d9d\n  , plaintext = 0x42d5c4a13b748800ebfe0f67781dcff1\n  },\n\n  { key = 0xe3bc6232865f0476149be7162ef8fc4b8ffd10f9034cdfba37aac1f54f35893c\n  , ciphertext = 0x42d5c4a13b748800ebfe0f67781dcff1\n  , plaintext = 0x469968a00226f0aae7acfda02b2ce0ae\n  },\n\n  { key = 0x451fbfba7f09b625540822fac8c8e30bc9647859016a2f10d0063c5564196992\n  , ciphertext = 0x469968a00226f0aae7acfda02b2ce0ae\n  , plaintext = 0xeab144d6f80ccfd2fae95d16784718ac\n  },\n\n  { key = 0xf53e21e46a0ec97c980d49d6f4b81ec423d53c8ff966e0c22aef61431c5e713e\n  , ciphertext = 0xeab144d6f80ccfd2fae95d16784718ac\n  , plaintext = 0xe04b91c3f084d733d3d0c1c7c152695a\n  },\n\n  { key = 0x5fb3a2cbdbe6971fcd345961bdcba5f6c39ead4c09e237f1f93fa084dd0c1864\n  , ciphertext = 0xe04b91c3f084d733d3d0c1c7c152695a\n  , plaintext = 0xe47db9b8c7fcc9459fa0a7fc84047b5b\n  },\n\n  { key = 0x6b145436c5ae0dcb2477f94f5bdb037927e314f4ce1efeb4669f07785908633f\n  , ciphertext = 0xe47db9b8c7fcc9459fa0a7fc84047b5b\n  , plaintext = 0xf617d26b55da999d65b2d236358b2e60\n  },\n\n  { key = 0x126752da3d7f9a0ffc1a46ccaa8a3925d1f4c69f9bc46729032dd54e6c834d5f\n  , ciphertext = 0xf617d26b55da999d65b2d236358b2e60\n  , plaintext = 0x066ffea799ad5f09d03cb868deb1591e\n  },\n\n  { key = 0xaa3daafbcd647f0a9eaa027146ab7aded79b383802693820d3116d26b2321441\n  , ciphertext = 0x066ffea799ad5f09d03cb868deb1591e\n  , plaintext = 0x6d28dbb55fb10c1c3226609997a4fb38\n  },\n\n  { key = 0xfed7b5c1f84d3dc185222da3fffac7a1bab3e38d5dd8343ce1370dbf2596ef79\n  , ciphertext = 0x6d28dbb55fb10c1c3226609997a4fb38\n  , plaintext = 0x9dd78987562c9c099d67ccc927fcec13\n  },\n\n  { key = 0xc36db4af0bee11dad6ea59679cfb988c27646a0a0bf4a8357c50c176026a036a\n  , ciphertext = 0x9dd78987562c9c099d67ccc927fcec13\n  , plaintext = 0xb5cc780ec75b8d8c5128c4d26fa520ea\n  },\n\n  { key = 0x7b5aebe66f96867504ee9efd2bd56bda92a81204ccaf25b92d7805a46dcf2380\n  , ciphertext = 0xb5cc780ec75b8d8c5128c4d26fa520ea\n  , plaintext = 0xc715bd2f23b98c66bf56e5680c6037f7\n  },\n\n  { key = 0x81a73bfcacc994f47aeec0d655e0485055bdaf2bef16a9df922ee0cc61af1477\n  , ciphertext = 0xc715bd2f23b98c66bf56e5680c6037f7\n  , plaintext = 0xe00984f9d93551e95ae85cfe4a829b82\n  },\n\n  { key = 0x2678e4ccda2eb6ad7f0e2843020da2d8b5b42bd23623f836c8c6bc322b2d8ff5\n  , ciphertext = 0xe00984f9d93551e95ae85cfe4a829b82\n  , plaintext = 0xbfa487fcb2331afe3ad82e59064b4aae\n  },\n\n  { key = 0x03565af5c267a62e0d2500ead06bc7d90a10ac2e8410e2c8f21e926b2d66c55b\n  , ciphertext = 0xbfa487fcb2331afe3ad82e59064b4aae\n  , plaintext = 0x4c278ca418fd1c5718883da0ba4a066f\n  },\n\n  { key = 0xec719a4ed851c36f806fbc78183026cc4637208a9cedfe9fea96afcb972cc334\n  , ciphertext = 0x4c278ca418fd1c5718883da0ba4a066f\n  , plaintext = 0xceed1c8b96d84951cadf809d3ea1b397\n  },\n\n  { key = 0xf138ad912201beecd15ebe2049f980e588da3c010a35b7ce20492f56a98d70a3\n  , ciphertext = 0xceed1c8b96d84951cadf809d3ea1b397\n  , plaintext = 0xf88aed84bca42a06647d6504a5c48379\n  },\n\n  { key = 0x8da22644e1267212742200dbf6b0ba947050d185b6919dc844344a520c49f3da\n  , ciphertext = 0xf88aed84bca42a06647d6504a5c48379\n  , plaintext = 0xc451b75375d0fec1cc1825eefbcc1372\n  },\n\n  { key = 0x5104213aabaccafe44129632f67cf2dab40166d6c3416309882c6fbcf785e0a8\n  , ciphertext = 0xc451b75375d0fec1cc1825eefbcc1372\n  , plaintext = 0x9a54dfd56bff41ea17bcf08d3761e95b\n  },\n\n  { key = 0x4c7c62be3f5a9d09934940284565e9c92e55b903a8be22e39f909f31c0e409f3\n  , ciphertext = 0x9a54dfd56bff41ea17bcf08d3761e95b\n  , plaintext = 0x76e074c587f112f3ffd17b390fa8cffc\n  },\n\n  { key = 0x9871765871b1dae363fca3961224414a58b5cdc62f4f30106041e408cf4cc60f\n  , ciphertext = 0x76e074c587f112f3ffd17b390fa8cffc\n  , plaintext = 0x5b14fd4c40a127733c20cd84648ec287\n  },\n\n  { key = 0x58e044758e5e4f300eb08f8b6ccd967203a1308a6fee17635c61298cabc20488\n  , ciphertext = 0x5b14fd4c40a127733c20cd84648ec287\n  , plaintext = 0x01c234e2392f42831b1172352f322286\n  },\n\n  { key = 0xffbb7104e110fdfe689f68ffa48b79590263046856c155e047705bb984f0260e\n  , ciphertext = 0x01c234e2392f42831b1172352f322286\n  , plaintext = 0xab142165cb093648938660fd800d8896\n  },\n\n  { key = 0x91aefec30a79b2524b19a611c0c4952da977250d9dc863a8d4f63b4404fdae98\n  , ciphertext = 0xab142165cb093648938660fd800d8896\n  , plaintext = 0x5c28ad9b5721edadc30e09b4541fd724\n  },\n\n  { key = 0x00d0f69c36671a9efeb7b8637e22af38f55f8896cae98e0517f832f050e279bc\n  , ciphertext = 0x5c28ad9b5721edadc30e09b4541fd724\n  , plaintext = 0x5a9ad24fe456f4f766e839a8101373c3\n  },\n\n  { key = 0xb22571c62ee4e0b4ebd7d776703c1345afc55ad92ebf7af271100b5840f10a7f\n  , ciphertext = 0x5a9ad24fe456f4f766e839a8101373c3\n  , plaintext = 0xa30e9a7730628b560c71967bdb35efce\n  },\n\n  { key = 0x1431d01006510179dd13e2a83e1b8b7b0ccbc0ae1eddf1a47d619d239bc4e5b1\n  , ciphertext = 0xa30e9a7730628b560c71967bdb35efce\n  , plaintext = 0x7118cc8a057df7ea9b7fb096decf05d9\n  },\n\n  { key = 0x06104531e2d000fff0cc8336b62e9bb87dd30c241ba0064ee61e2db5450be068\n  , ciphertext = 0x7118cc8a057df7ea9b7fb096decf05d9\n  , plaintext = 0xc550ff93a36fbb8e9a505682e07fb981\n  },\n\n  { key = 0x8e5ebd5c9bf858f3379bfb88c7c75319b883f3b7b8cfbdc07c4e7b37a57459e9\n  , ciphertext = 0xc550ff93a36fbb8e9a505682e07fb981\n  , plaintext = 0x1375e7b4164adc861bbb77c50aba445c\n  },\n\n  { key = 0xccc9445c3aab1c03ec8027593d370664abf61403ae85614667f50cf2afce1db5\n  , ciphertext = 0x1375e7b4164adc861bbb77c50aba445c\n  , plaintext = 0x5bc8b411c0fae92bad54b4e5c3a8826e\n  },\n\n  { key = 0xb804994228d618a9b7a3e0c3d8d2d373f03ea0126e7f886dcaa1b8176c669fdb\n  , ciphertext = 0x5bc8b411c0fae92bad54b4e5c3a8826e\n  , plaintext = 0x36c9de7c01298ff06c5e3ecf12507cd6\n  },\n\n  { key = 0x8a784f32cdd7e2ed19e85faf04de2015c6f77e6e6f56079da6ff86d87e36e30d\n  , ciphertext = 0x36c9de7c01298ff06c5e3ecf12507cd6\n  , plaintext = 0x35d814c0f6c07ae72bbe7cd1751d7527\n  },\n\n  { key = 0x71e3cc0f60a2eafd83c3a455eefc4c9cf32f6aae99967d7a8d41fa090b2b962a\n  , ciphertext = 0x35d814c0f6c07ae72bbe7cd1751d7527\n  , plaintext = 0x73c39ce5ea1b5eab18c9c15221e258d1\n  },\n\n  { key = 0x71bef3d2beffa17d37c6c3b28ef2928280ecf64b738d23d195883b5b2ac9cefb\n  , ciphertext = 0x73c39ce5ea1b5eab18c9c15221e258d1\n  , plaintext = 0xac67508a8bcab69f96ead29121718cd7\n  },\n\n  { key = 0x9aa1ffa9e175f03a6bcc71fc2aea3a522c8ba6c1f847954e0362e9ca0bb8422c\n  , ciphertext = 0xac67508a8bcab69f96ead29121718cd7\n  , plaintext = 0x49d2cac2ca39a3b66302e5f3650e71d7\n  },\n\n  { key = 0x4e480b73ab5c659538354b2474c9367b65596c03327e36f860600c396eb633fb\n  , ciphertext = 0x49d2cac2ca39a3b66302e5f3650e71d7\n  , plaintext = 0xe54638674ea0b3e837772a2866723753\n  },\n\n  { key = 0xaeecd55c38bef76367a21469d08721d2801f54647cde85105717261108c404a8\n  , ciphertext = 0xe54638674ea0b3e837772a2866723753\n  , plaintext = 0x074d933018e9e0558b416e39548994ff\n  },\n\n  { key = 0xe36c6a30f734a679ab7af2f9ff767cfe8752c75464376545dc5648285c4d9057\n  , ciphertext = 0x074d933018e9e0558b416e39548994ff\n  , plaintext = 0x04825a9ba20646acadb2cbdbd23530c0\n  },\n\n  { key = 0x124806708fc5fc73a1e50c61e5a76b8783d09dcfc63123e971e483f38e78a097\n  , ciphertext = 0x04825a9ba20646acadb2cbdbd23530c0\n  , plaintext = 0x25b98d2837580f9f3da8f2593f7b1d72\n  },\n\n  { key = 0x560afb5529a8b433738348a296408cada66910e7f1692c764c4c71aab103bde5\n  , ciphertext = 0x25b98d2837580f9f3da8f2593f7b1d72\n  , plaintext = 0x048b220c70d875cad6901e40f45c5b03\n  },\n\n  { key = 0x8b7c61dd007d9d0d1937cfc69b63c114a2e232eb81b159bc9adc6fea455fe6e6\n  , ciphertext = 0x048b220c70d875cad6901e40f45c5b03\n  , plaintext = 0x34e2a33412c0e682b29b26d5409d015f\n  },\n\n  { key = 0x30560ca0a31d8145228d34fbf8415683960091df9371bf3e2847493f05c2e7b9\n  , ciphertext = 0x34e2a33412c0e682b29b26d5409d015f\n  , plaintext = 0x942c057914f3b88fa0a40bb41d02b051\n  },\n\n  { key = 0x20c7e6e45c08ba0756c379b6cd4d6886022c94a6878207b188e3428b18c057e8\n  , ciphertext = 0x942c057914f3b88fa0a40bb41d02b051\n  , plaintext = 0x6f4e5c40e4135abfdf294b4d8c9304b3\n  },\n\n  { key = 0x2a6c928bf8c2b32ce82ed0be1bc954b96d62c8e663915d0e57ca09c69453535b\n  , ciphertext = 0x6f4e5c40e4135abfdf294b4d8c9304b3\n  , plaintext = 0xcac032ddc2b27443d70d0f2dfb1a1d87\n  },\n\n  { key = 0x74994d46526b2e9d5470a0a687f726f2a7a2fa3ba123294d80c706eb6f494edc\n  , ciphertext = 0xcac032ddc2b27443d70d0f2dfb1a1d87\n  , plaintext = 0x6aec33b2c1ae39237b13e86555722d1a\n  },\n\n  { key = 0x5aaec28d079eef5f1c42df377c7e80accd4ec989608d106efbd4ee8e3a3b63c6\n  , ciphertext = 0x6aec33b2c1ae39237b13e86555722d1a\n  , plaintext = 0x2df34173bbff331488b23687c755f617\n  },\n\n  { key = 0x9bfa3c08b8f8b8758f0a1f4b0ef86be4e0bd88fadb72237a7366d809fd6e95d1\n  , ciphertext = 0x2df34173bbff331488b23687c755f617\n  , plaintext = 0x07649dd5c1c7b38810cbecbad9c037ed\n  },\n\n  { key = 0x188e3a027b75fede978c76e70a853f95e7d9152f1ab590f263ad34b324aea23c\n  , ciphertext = 0x07649dd5c1c7b38810cbecbad9c037ed\n  , plaintext = 0xef3d9092321649d9bbb88f6448e3847b\n  },\n\n  { key = 0xaae2c6363be3dbb71c21f3a2d9f123f108e485bd28a3d92bd815bbd76c4d2647\n  , ciphertext = 0xef3d9092321649d9bbb88f6448e3847b\n  , plaintext = 0x1e5058b3e986d4aad80a11f909af1cca\n  },\n\n  { key = 0x85a51c6d62ba97564ac955a5409c362916b4dd0ec1250d81001faa2e65e23a8d\n  , ciphertext = 0x1e5058b3e986d4aad80a11f909af1cca\n  , plaintext = 0x9bf81052596b786b50b3f3506c009169\n  },\n\n  { key = 0x0d09600f108a86cfd58f3c211a40c38d8d4ccd5c984e75ea50ac597e09e2abe4\n  , ciphertext = 0x9bf81052596b786b50b3f3506c009169\n  , plaintext = 0x81bdaf86cf4255e5826294a51d2f9992\n  },\n\n  { key = 0x14ab478866e1d160311aa8820df354fb0cf162da570c200fd2cecddb14cd3276\n  , ciphertext = 0x81bdaf86cf4255e5826294a51d2f9992\n  , plaintext = 0x1fdc5fee9eb640ff547a98d9e1601b52\n  },\n\n  { key = 0x39f18405f0b1da647f99479e87d4d153132d3d34c9ba60f086b45502f5ad2924\n  , ciphertext = 0x1fdc5fee9eb640ff547a98d9e1601b52\n  , plaintext = 0x936609876cd6eebf31db5a6af7839844\n  },\n\n  { key = 0x85a900bc1563b16e01481e45d1125734804b34b3a56c8e4fb76f0f68022eb160\n  , ciphertext = 0x936609876cd6eebf31db5a6af7839844\n  , plaintext = 0x9ea8b6942287f470e9866a48f4dc661a\n  },\n\n  { key = 0xc43d677fc0a1becbb0214221b866f0be1ee3822787eb7a3f5ee96520f6f2d77a\n  , ciphertext = 0x9ea8b6942287f470e9866a48f4dc661a\n  , plaintext = 0x1dfc2cf82bfaa2732eb525916ef9ef13\n  },\n\n  { key = 0x584f10659c2d3c41f6a1926de4595eb2031faedfac11d84c705c40b1980b3869\n  , ciphertext = 0x1dfc2cf82bfaa2732eb525916ef9ef13\n  , plaintext = 0xa5d8d1d60281a152b9b76142e3e5a512\n  },\n\n  { key = 0x8eba336927e18b13eb3858a89709768ba6c77f09ae90791ec9eb21f37bee9d7b\n  , ciphertext = 0xa5d8d1d60281a152b9b76142e3e5a512\n  , plaintext = 0x8ac0278f2ab100a5964173d76934d732\n  },\n\n  { key = 0x13f1558dcae09062bfdccdd0037e5c432c075886842179bb5faa522412da4a49\n  , ciphertext = 0x8ac0278f2ab100a5964173d76934d732\n  , plaintext = 0x30233b70c4d6fd31b23cc77bc73559ea\n  },\n\n  { key = 0xd736669842aa88f43f1de421d38f391f1c2463f640f7848aed96955fd5ef13a3\n  , ciphertext = 0x30233b70c4d6fd31b23cc77bc73559ea\n  , plaintext = 0x766630dfd41e4146a827f55cba745b6a\n  },\n\n  { key = 0x0ca8353df90e73606588a11675bd37a76a42532994e9c5cc45b160036f9b48c9\n  , ciphertext = 0x766630dfd41e4146a827f55cba745b6a\n  , plaintext = 0x177f22d98f009c214a44b08cf40b790d\n  },\n\n  { key = 0x136ec3a1a65ee7bb0fd09af7364b66607d3d71f01be959ed0ff5d08f9b9031c4\n  , ciphertext = 0x177f22d98f009c214a44b08cf40b790d\n  , plaintext = 0xe9c916a21dec9662bdd91a0f865f8b47\n  },\n\n  { key = 0xba5c2bd413daca7866de11c11db2926694f467520605cf8fb22cca801dcfba83\n  , ciphertext = 0xe9c916a21dec9662bdd91a0f865f8b47\n  , plaintext = 0x92b3ab3e28f6c606508706e0c3d76d28\n  },\n\n  { key = 0x0fab4768fa7f104a3579f534508182920647cc6c2ef30989e2abcc60de18d7ab\n  , ciphertext = 0x92b3ab3e28f6c606508706e0c3d76d28\n  , plaintext = 0x3652053dcba591f101944fb1a5eb2b99\n  },\n\n  { key = 0xe766aa23c075deaa6fae68384f5b205e3015c951e5569878e33f83d17bf3fc32\n  , ciphertext = 0x3652053dcba591f101944fb1a5eb2b99\n  , plaintext = 0x242260d2387c6f1a415834b34e300a7e\n  },\n\n  { key = 0x9f1941442336bfffa1d6b27dce7845971437a983dd2af762a267b76235c3f64c\n  , ciphertext = 0x242260d2387c6f1a415834b34e300a7e\n  , plaintext = 0xa2a58ed050231b0d15f8cd99f5e171fb\n  },\n\n  { key = 0x429a3cdc98124fafe33156a66b4e8c2ab69227538d09ec6fb79f7afbc02287b7\n  , ciphertext = 0xa2a58ed050231b0d15f8cd99f5e171fb\n  , plaintext = 0xec6631b17e5c97193fd9651b64feffe7\n  },\n\n  { key = 0x92764a89e0de63823b9d9a5a001868035af416e2f3557b7688461fe0a4dc7850\n  , ciphertext = 0xec6631b17e5c97193fd9651b64feffe7\n  , plaintext = 0x1eef8afa419a9341085a2d611185e42c\n  },\n\n  { key = 0x0c0bf13d79d1297e137e6f5995cb0a2c441b9c18b2cfe837801c3281b5599c7c\n  , ciphertext = 0x1eef8afa419a9341085a2d611185e42c\n  , plaintext = 0xd4eb4e591cf856b816e2207264e426e4\n  },\n\n  { key = 0xde31f995867bb45813d369349cb7434290f0d241ae37be8f96fe12f3d1bdba98\n  , ciphertext = 0xd4eb4e591cf856b816e2207264e426e4\n  , plaintext = 0x401e14b126348e1aedd13662a19c23fb\n  },\n\n  { key = 0x3b1a02b5600444db09118e99765fa61dd0eec6f0880330957b2f249170219963\n  , ciphertext = 0x401e14b126348e1aedd13662a19c23fb\n  , plaintext = 0x38bfea7e1eece741eb6a9601605129dd\n  },\n\n  { key = 0x1fbcf4ffb36f76b88323f745b3152947e8512c8e96efd7d49045b2901070b0be\n  , ciphertext = 0x38bfea7e1eece741eb6a9601605129dd\n  , plaintext = 0x71cd66b3b3553b6aa632c338a307e11a\n  },\n\n  { key = 0xb963bfe1c513f0dba7e24b5cfa1535a3999c4a3d25baecbe367771a8b37751a4\n  , ciphertext = 0x71cd66b3b3553b6aa632c338a307e11a\n  , plaintext = 0x34c2972d43e59eb0c44b7b69a540e7de\n  },\n\n  { key = 0x23458e2a4332ce00e7967a438cd86448ad5edd10665f720ef23c0ac11637b67a\n  , ciphertext = 0x34c2972d43e59eb0c44b7b69a540e7de\n  , plaintext = 0x8988b878d0c6a84b6262351e033fb1b7\n  },\n\n  { key = 0xe552b8a0f474a8da502e749e3f0639b124d66568b699da45905e3fdf150807cd\n  , ciphertext = 0x8988b878d0c6a84b6262351e033fb1b7\n  , plaintext = 0x010e24d01c37edca127484c8d8137772\n  },\n\n  { key = 0x65a0645dd971bdb3b0d3a079ef96f3a925d841b8aaae378f822abb17cd1b70bf\n  , ciphertext = 0x010e24d01c37edca127484c8d8137772\n  , plaintext = 0x6c7b2e83630a8c8b6219839297d7c647\n  },\n\n  { key = 0x9867d55ae9f56a03c435f4b25f2eee2c49a36f3bc9a4bb04e03338855accb6f8\n  , ciphertext = 0x6c7b2e83630a8c8b6219839297d7c647\n  , plaintext = 0xccba81435ecf162f70d30b3163cb3858\n  },\n\n  { key = 0xe4a3addb683bbe85ed84b3ce044bcc538519ee78976bad2b90e033b439078ea0\n  , ciphertext = 0xccba81435ecf162f70d30b3163cb3858\n  , plaintext = 0xa0575bc9b8931f34cd6072e2015e7331\n  },\n\n  { key = 0x6f543088bf24577d55a685e3637d85e8254eb5b12ff8b21f5d8041563859fd91\n  , ciphertext = 0xa0575bc9b8931f34cd6072e2015e7331\n  , plaintext = 0xa44046a87574e6d3e6c6446fb3c324bc\n  },\n\n  { key = 0x5fff671ca24c3b241ddb92761f02dfe3810ef3195a8c54ccbb4605398b9ad92d\n  , ciphertext = 0xa44046a87574e6d3e6c6446fb3c324bc\n  , plaintext = 0xef6abb8ae007b730be45aa85e39f362d\n  },\n\n  { key = 0xdb897d48a317f66412a8c52111c3f3b06e644893ba8be3fc0503afbc6805ef00\n  , ciphertext = 0xef6abb8ae007b730be45aa85e39f362d\n  , plaintext = 0xe5bd2edfb7e563f6cd86da757c4c370f\n  },\n\n  { key = 0x78aec1da8e8e79007af12c05d800a18d8bd9664c0d6e800ac88575c91449d80f\n  , ciphertext = 0xe5bd2edfb7e563f6cd86da757c4c370f\n  , plaintext = 0x33caa267a64fb3cac210271bb8f25369\n  },\n\n  { key = 0x2c3e5387a51addb0b7789ef0289109b3b813c42bab2133c00a9552d2acbb8b66\n  , ciphertext = 0x33caa267a64fb3cac210271bb8f25369\n  , plaintext = 0x27bb26990ca5e12d387bd659cb7e7860\n  },\n\n  { key = 0x85685fe6996d514e5928d7196f41b5d29fa8e2b2a784d2ed32ee848b67c5f306\n  , ciphertext = 0x27bb26990ca5e12d387bd659cb7e7860\n  , plaintext = 0xd866ace71916e00c1559bba4149380a0\n  },\n\n  { key = 0x82abcc9a00bae55087cf5d87413f095547ce4e55be9232e127b73f2f735673a6\n  , ciphertext = 0xd866ace71916e00c1559bba4149380a0\n  , plaintext = 0x8a4d6a0af8488a82a0c31332db3e36de\n  },\n\n  { key = 0x81d983ce59413e84d7af4558d2e3941ccd83245f46dab86387742c1da8684578\n  , ciphertext = 0x8a4d6a0af8488a82a0c31332db3e36de\n  , plaintext = 0x05f6ff378b837cd375cddfae79ec2a9d\n  },\n\n  { key = 0xbbe6d0d13a6b146bb23db6885ba66487c875db68cd59c4b0f2b9f3b3d1846fe5\n  , ciphertext = 0x05f6ff378b837cd375cddfae79ec2a9d\n  , plaintext = 0xb706bdb4019d604cc35faa07197c318d\n  },\n\n  { key = 0x8092df6673b2b77783f2ba73c22e8d3c7f7366dcccc4a4fc31e659b4c8f85e68\n  , ciphertext = 0xb706bdb4019d604cc35faa07197c318d\n  , plaintext = 0xb26354bc77d3ce16909ca505d2381e4c\n  },\n\n  { key = 0x3118fc57b93677af8e14c1b5961b76f3cd103260bb176aeaa17afcb11ac04024\n  , ciphertext = 0xb26354bc77d3ce16909ca505d2381e4c\n  , plaintext = 0x1515ef6a25cf3943eadadc36a029194a\n  },\n\n  { key = 0xc4bde4a0c5f80329be6dd515f5bf6dabd805dd0a9ed853a94ba02087bae9596e\n  , ciphertext = 0x1515ef6a25cf3943eadadc36a029194a\n  , plaintext = 0x7b4ad946dfb59c80b1dc5cedb2fa87a0\n  },\n\n  { key = 0x80b47f9126b0b1f5ab408bb9ea5f349aa34f044c416dcf29fa7c7c6a0813dece\n  , ciphertext = 0x7b4ad946dfb59c80b1dc5cedb2fa87a0\n  , plaintext = 0xfa10a53e14cde5ef1e9a8a5692847aa5\n  },\n\n  { key = 0x86a43939c8cd243f7ff2a9658524373b595fa17255a02ac6e4e6f63c9a97a46b\n  , ciphertext = 0xfa10a53e14cde5ef1e9a8a5692847aa5\n  , plaintext = 0x4c9bed07308abcd0b09265b5efbe301c\n  },\n\n  { key = 0x74a8f02a15285153e0ae160fbddcf6bf15c44c75652a96165474938975299477\n  , ciphertext = 0x4c9bed07308abcd0b09265b5efbe301c\n  , plaintext = 0x75b7496c42809a3a592acbd8e069269e\n  },\n\n  { key = 0x293b40a2f70cc2c4262554663fb6f0986073051927aa0c2c0d5e58519540b2e9\n  , ciphertext = 0x75b7496c42809a3a592acbd8e069269e\n  , plaintext = 0x2dbc01185af7e084d90578468b6b10ef\n  },\n\n  { key = 0xb04d4f4eb708eef86c5b6b8e08a665084dcf04017d5deca8d45b20171e2ba206\n  , ciphertext = 0x2dbc01185af7e084d90578468b6b10ef\n  , plaintext = 0xc95b3a9f689c9dce4995c24f72dd5162\n  },\n\n  { key = 0x7cb9f7211815e0cb48b71286f84f80a184943e9e15c171669dcee2586cf6f364\n  , ciphertext = 0xc95b3a9f689c9dce4995c24f72dd5162\n  , plaintext = 0x616e55c3bf113e2c18cae3c61b7eb7d1\n  },\n\n  { key = 0xb3cdb46cf92aa0b96e87212bc650d5e5e5fa6b5daad04f4a8504019e778844b5\n  , ciphertext = 0x616e55c3bf113e2c18cae3c61b7eb7d1\n  , plaintext = 0x87e8b80767ebbdbad75cb94f4cb54f3b\n  },\n\n  { key = 0x512c2a3821eb53af613141c71e1076656212d35acd3bf2f05258b8d13b3d0b8e\n  , ciphertext = 0x87e8b80767ebbdbad75cb94f4cb54f3b\n  , plaintext = 0xc83e20e18f2b1457788954b49fd84307\n  },\n\n  { key = 0x9977c985745bc33954a2ce898bc8febdaa2cf3bb4210e6a72ad1ec65a4e54889\n  , ciphertext = 0xc83e20e18f2b1457788954b49fd84307\n  , plaintext = 0xe3d3868f578caf34e36445bf14cefc68\n  }]\n```"}]}
{"filename":"cryptol\/tests\/regression\/twinmult.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Using the elliptic-curve utilities from the PrimeEC library, define the following in Cryptol over the curve parameter 7: (1) Define the constant named zro with type ProjectivePoint 7 representing the projective neutral element (point at infinity). (2) Define a property twin_mult_zro that, for arbitrary scalars j and k, verifies that twin scalar multiplication of j and k by the neutral element yields the neutral element, using the library\u2019s equality predicate for this curve. (3) Define a property twin_mult_zro1 that, for arbitrary scalars j and k and any projective point S on the same curve, verifies that twin scalar multiplication with the first input point equal to the neutral element equals single scalar multiplication of S by k. (4) Define a property twin_mult_zro2 that verifies the symmetric case where the second input point is the neutral element equals single scalar multiplication of S by j. (5) Define a property twin_mult_same that verifies twin scalar multiplication applied to the same point in both slots equals the elliptic-curve addition of the separate scalar multiples by j and k. (6) Define a property twin_mult_neg that verifies twin scalar multiplication where the second input point is the negation of the first equals the elliptic-curve subtraction of the corresponding scalar multiples. Use the library operations for twin multiplication, single multiplication, point equality, addition, subtraction, and negation. State parameter and variable types: j and k are curve-appropriate scalars; S is a ProjectivePoint 7. Do not implement algorithms; only specify the constant and the properties as described."},{"role":"assistant","content":"```cryptol\nimport PrimeEC\n\nzro : ProjectivePoint 7\nzro = { x = 1, y = 1, z = 0 }\n\nproperty twin_mult_zro j k =\n  ec_equal`{7} (ec_twin_mult j zro k zro) zro\n\nproperty twin_mult_zro1 j k S =\n  ec_equal`{7} (ec_twin_mult j zro k S) (ec_mult k S)\n\nproperty twin_mult_zro2 j k S =\n  ec_equal`{7} (ec_twin_mult j S k zro) (ec_mult j S)\n\nproperty twin_mult_same j k S =\n  ec_equal`{7} (ec_twin_mult j S k S) (ec_add (ec_mult j S) (ec_mult k S))\n\nproperty twin_mult_neg j k S =\n  ec_equal`{7} (ec_twin_mult j S k (ec_negate S)) (ec_sub (ec_mult j S) (ec_mult k S))\n```"}]}
{"filename":"cryptol\/tests\/regression\/word-update.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define four Cryptol properties named wordUpdate, wordUpdate2, wordUpdateEnd, and wordUpdateEnd2. Each property takes three parameters: a 16-bit word x, an 8-bit index y, and a single bit b, and is conditioned on the precondition y < 16. For wordUpdate, define a property that verifies that updating bit position y counted from the most-significant end equals: if b is 1, the bitwise OR of x with a mask containing a single 1 at the most-significant position shifted right by y; otherwise, the bitwise AND of x with the bitwise complement of that mask. For wordUpdate2, define a property that verifies that the same update equals reconstructing the 16-bit word by iterating indices 0 through 15 (most-significant end first), writing b at index y and copying all other bits from x using most-significant-first indexing. For wordUpdateEnd, define a property that verifies that updating bit position y counted from the least-significant end equals: if b is 1, the bitwise OR of x with a mask containing a single 1 at the least-significant position shifted left by y; otherwise, the bitwise AND of x with the bitwise complement of that mask. For wordUpdateEnd2, define a property that verifies that the same least-significant-end update equals reconstructing the word by enumerating all bit positions and replacing only the least-significant-end index y with b, using least-significant-first indexing for reads."},{"role":"assistant","content":"```cryptol\nproperty wordUpdate (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> update x y b == if b then x || msk else x && ~msk\n\n where\n msk = 0b1000000000000000 >> y\n\nproperty wordUpdate2 (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> update x y b == x'\n\n where\n x' = [ if i == y then b else x@i | i <- [0 .. 15] ]\n\nproperty wordUpdateEnd (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> updateEnd x y b == if b then x || msk else x && ~msk\n\n where\n msk = 0b0000000000000001 << y\n\nproperty wordUpdateEnd2 (x:[16]) (y:[8]) (b:Bit) =\n  y < 16 ==> updateEnd x y b == x'\n\n where\n x' = [ if i == y then b else x!i | i <- reverse [0 .. 15] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/f2polytest.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that verifies local polynomial multiply, divide, and modulus over GF(2) bit-polynomials against trusted reference implementations. Define three Boolean-valued equivalence checker functions, each polymorphic over size parameters u and v with fin constraints: (1) a multiplication checker that takes two sequences of lengths 1+u and 1+v and returns true iff the local multiplication equals the reference result; (2) a division checker that takes two sequences of lengths u and v and returns true if the divisor is zero or the local division equals the reference result; (3) a modulus checker that takes sequences of lengths u and 1+v and returns true if the modulus divisor is zero or the local modulus equals the reference result. Import the reference operations from the project\u2019s reference library and compare local results to those references. Then define properties (for SAT checking) that instantiate these three checkers at the following size pairs: (3,9), (9,3), (8,8), (28,11), (32,32), and (64,64). Provide properties for all three operations at each size pair, each created by specializing the corresponding checker at the given sizes. Do not implement the underlying arithmetic; only define the checkers, constraints, types, and properties as described."},{"role":"assistant","content":"```cryptol\nimport Cryptol::Reference as Ref\n\npmult_equiv : {u, v} (fin u, fin v) => [1+u] -> [1+v] -> Bit\npmult_equiv x y = pmult x y == Ref::pmult x y\n\npdiv_equiv : {u, v} (fin u, fin v) => [u] -> [v] -> Bit\npdiv_equiv x y = y == 0 \\\/ pdiv x y == Ref::pdiv x y\n\npmod_equiv : {u, v} (fin u, fin v) => [u] -> [1+v] -> Bit\npmod_equiv x y = y == 0 \\\/ pmod x y == Ref::pmod x y\n\nproperty mult3_9   = pmult_equiv`{3,9}\nproperty mult9_3   = pmult_equiv`{9,3}\nproperty mult8_8   = pmult_equiv`{8,8}\nproperty mult28_11 = pmult_equiv`{28,11}\nproperty mult32_32 = pmult_equiv`{32,32}\nproperty mult64_64 = pmult_equiv`{64,64}\n\nproperty div3_9   = pdiv_equiv`{3,9}\nproperty div9_3   = pdiv_equiv`{9,3}\nproperty div8_8   = pdiv_equiv`{8,8}\nproperty div28_11 = pdiv_equiv`{28,11}\nproperty div32_32 = pdiv_equiv`{32,32}\nproperty div64_64 = pdiv_equiv`{64,64}\n\nproperty mod3_9   = pmod_equiv`{3,9}\nproperty mod9_3   = pmod_equiv`{9,3}\nproperty mod8_8   = pmod_equiv`{8,8}\nproperty mod28_11 = pmod_equiv`{28,11}\nproperty mod32_32 = pmod_equiv`{32,32}\nproperty mod64_64 = pmod_equiv`{64,64}\n```"}]}
{"filename":"cryptol\/tests\/regression\/r01.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two polymorphic Cryptol functions named any and all. Each takes a predicate from an element to a bit and a finite-length vector of n elements, returning a single bit. Use a size parameter n with a fin n constraint and a universally-quantified element type. Implement both by first mapping the predicate over the input vector to produce an n-bit vector. Then: any returns true if and only if this bit vector is not equal to the all-zero n-bit vector; all returns true if and only if this bit vector is equal to the all-ones n-bit vector (the bitwise complement of the all-zero vector). Provide explicit type signatures capturing the fin n constraint, the predicate type, the vector type, and the Bit result, and define the function bodies accordingly."},{"role":"assistant","content":"```cryptol\nany : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nany f xs = [ f x | x <- xs ] != zero\n\nall : {n, a} (fin n) => (a -> Bit) -> [n]a -> Bit\nall f xs = [ f x | x <- xs ] == ~zero\n```"}]}
{"filename":"cryptol\/tests\/regression\/r05.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol function named unflatten with size parameters r and w. Provide a polymorphic type signature with constraints that r and w are finite and that 5*w >= r. The function must take a sequence of r bits and return a sequence of w elements, each being a 5-bit word. Implement the behavior by appending zero bits to the end of the input until its length is exactly 5*w, then partition the result into consecutive chunks of 5 bits, preserving order, to produce the w-length sequence. State all constraints in the type and use standard sequence concatenation and chunking operations. Do not alter existing bits other than zero-padding at the end."},{"role":"assistant","content":"```cryptol\nunflatten : {r, w}\n            (fin r, 5 * w >= r, fin w)\n            => [r] -> [w][5]\nunflatten p = groupBy`{5}(p # zero)\n```"}]}
{"filename":"cryptol\/tests\/regression\/check22.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) an 8-bit constant named irred with value 0x1b; (2) a function xtimes that takes an 8-bit word, left-shifts it by one bit, and if the original most significant bit was 1, XORs the shifted value with irred; otherwise it returns the shifted value. Use bit indexing of the MSB and the word\u2019s length to detect the carry-out. (3) a function gtimes that takes a pair of 8-bit words and returns their product in GF(2^8) using the Russian peasant method: if the multiplier is zero return zero; otherwise recursively multiply with the multiplier right-shifted by one, apply xtimes to the recursive result, and XOR with the multiplicand when the multiplier\u2019s least significant bit is 1 (else XOR with zero). (4) a boolean named check22 that evaluates whether applying gtimes with multiplicand 13 to each of 1, 12, and 192 yields exactly 13, 92, and 183, respectively."},{"role":"assistant","content":"```cryptol\nirred : [8]\nirred = 0x1b\nxtimes a = (if a ! (length a - 1) then a' ^ irred else a')\n  where a' = a << 1\n\ngtimes : ([8], [8]) -> [8]\ngtimes (a, b)\n  = (if b == 0 then 0 else xtimes (gtimes (a, b >> 1)) ^ a')\n      where a' = if b ! 0 then a else 0\n\ncheck22 = [ gtimes (13, x) | x <- [ 1, 12, 192 ] ] == [ 13, 92, 183 ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check23.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a size-parameterized function named pad that takes a bitvector of length msgLen and returns a bitvector of length chunks*512, implementing Merkle\u2013Damg\u00e5rd-style padding: concatenate the original bits, a single 1-bit set to true, a zero-filled vector of length padding, and a 64-bit big-endian encoding of the original message length. Constrain the size parameters as follows: msgLen and padding are finite; contentLen equals msgLen plus 65 (for the 1 bit and the 64-bit length); chunks equals the ceiling of contentLen\/512 expressed as (contentLen + 511) \/ 512; the bit-width needed to represent msgLen is at most 64; and padding equals (512 \u2212 (contentLen mod 512)) mod 512. Ensure the encoded length is exactly 64 bits and is the length of the input message. Then define a 4-bit constant named tmsg with value 13, a 512-bit constant named out with the given hexadecimal value, and a boolean definition named check23 that is true exactly when applying pad to tmsg yields out."},{"role":"assistant","content":"```cryptol\npad : {msgLen, padding, contentLen, chunks}\n    ( fin msgLen\n    , fin padding\n    , contentLen == msgLen + 65\n    , chunks == (contentLen + 511) \/ 512\n    , 64 >= width msgLen\n    , padding == (512 - contentLen % 512) % 512\n    ) => [msgLen] -> [chunks * 512]\npad msg = msg # [True] # (zero:[padding]) # sz        where  sz : [64]\n             sz = (length msg):[64]\n\ntmsg : [4]\ntmsg = 13\nout : [512]\nout = 0xd8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004\ncheck23 = pad tmsg == out\n```"}]}
{"filename":"cryptol\/tests\/regression\/check09.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models two mutually recursive streams of 32-bit words driven by single-element 32-bit seeds and verifies their outputs. Do the following: 1) Declare two seeds as single-element sequences of 32-bit zeros. 2) Define an infinite stream X where each element is the 32-bit rotate-left-by-3 of the sum (mod 2^32) of: the previous element of X (using 0 at the start), a sequence that is 1 at the start then follows X, and a sequence that is 0 at the start then follows Y. 3) Define an infinite stream Y where each element is the rotate-left by (current X + previous Y-with-initial-0) of the sum (mod 2^32) of: the previous element of Y (seeded initially), the current element of X, and the previous Y-with-initial-0. 4) Define a function with type [4][8] -> [7][32] that: takes 4 bytes, concatenates them to a 32-bit word, uses that as the initial seed for Y (as a single-element sequence), recomputes X and Y as above, and returns the first seven elements of X. 5) Define a property that asserts the first four elements of X equal an expected 4-element 32-bit vector and the first four elements of Y equal another expected 4-element 32-bit vector. 6) Define a property that asserts that applying the function to a specific 4-byte ASCII key whose bytes are reversed yields an expected 7-element 32-bit vector. 7) Define a final property that is the conjunction of the two properties. Keep all operations word-sized; use Cryptol\u2019s rotate-left and addition on 32-bit words; use indexed selection to take the first N elements."},{"role":"assistant","content":"```cryptol\ninitS : [1][32]\ninitL : [1][32]\ninitS = [0]\ninitL = [0]\nss = [ (s + a + b) <<< 3   | s <- initS # ss\n\t                       | a <- [1] # ss\n\t                       | b <- [0] # ls ]\nls = [ (l + a + b) <<< (a + b)\n                        | l <- initL # ls\n\t\t                | a <- ss\n\t\t                | b <- [0] # ls ]\n\ncheck9a = (ss @@ [0 .. 3] == [ 0x00000008, 0x00004080, 0x00068c00, 0x00a22800 ])\n       && (ls @@ [0 .. 3] == [ 0x00000800, 0x00005080, 0x00072d00, 0x00b08200 ])\n\nkeyX : [4][8] -> [7][32]\nkeyX key = ss @@ [ 0 .. 6 ]\n  where\n    initS : [1][32]\n    initL : [1][32]\n    initS = [0]\n    initL = split (join key)\n    ss = [ (s + a + b) <<< 3\n                    | s <- initS # ss\n\t\t\t\t    | a <- [1] # ss\n\t\t\t\t    | b <- [0] # ls ]\n    ls = [ (l + a + b) <<< (a + b)\n                    | l <- initL # ls\n\t\t\t\t    | a <- ss\n\t\t\t\t    | b <- [0] # ls ]\n\ncheck9b = keyX (reverse \"abcd\") ==\n\t    [0x00000008, 0x1b134ba3, 0x11ae69b1, 0xb7b3f42f,\n             0xc9eb1fdc, 0x008b5f36, 0x8991bc8c]\n\ncheck9 = check9a && check9b\n```"}]}
{"filename":"cryptol\/tests\/regression\/check21.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) defines an 8-bit constant equal to the irreducible polynomial used for AES GF(2^8) reduction; (2) defines a function of type [8] -> [8] that multiplies an 8-bit value by x in GF(2^8) by left-shifting one bit and, if the original most-significant bit was set, XORing the shifted value with the reduction constant; and (3) defines a top-level Boolean that asserts the list obtained by applying this function to the sample inputs [1, 12, 192] equals the expected outputs [2, 24, 155]. Do not use the property keyword; the final check should be a Boolean value."},{"role":"assistant","content":"```cryptol\nirred : [8]\nirred = 0x1b\nxtimes a = (if a ! (length a - 1) then a' ^ irred else a')\n  where a' = a << 1\n\ncheck21 = [ xtimes y | y <- [ 1, 12, 192 ] ] == [ 2, 24, 155 ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a boolean constant that evaluates whether the element-wise sum of two three-dimensional sequences of numeric literals (each with an outer length of 1 containing a 2\u00d72 inner matrix) equals a third sequence of the same shape containing the corresponding pairwise sums. Use Cryptol\u2019s sequence addition to add the two arrays pointwise and an equality check to compare against the expected result. The constant\u2019s type is Bit (Boolean), and the element type is a consistent, finite-width unsigned numeric type inferred from the literals. All shapes are fixed and identical across operands and the expected result."},{"role":"assistant","content":"```cryptol\ncheck20 = [ [ [ 1, 2 ], [ 3, 4 ] ] ]\n        + [ [ [ 5, 6 ], [ 7, 8 ] ] ]\n       == [ [ [ 6, 8 ], [ 10, 12 ] ] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check08.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) a constant zs with type an infinite sequence of 32-bit words whose elements are all zero; (2) an infinite sequence qq of 32-bit words produced by a productive, zipped recursive list comprehension where each element equals the sum of three aligned sources: qq with a leading 0, qq with a leading 1, and zs with a leading 0; include appropriate type signatures and ensure the recursion is guarded by the prepended elements; (3) a boolean constant check8 that is true exactly when selecting qq at indices 0 through 4 yields the five-element sequence [1, 2, 5, 12, 27]; and (4) a property named prefix expressing the same equality as check8 so it can be checked by a solver."},{"role":"assistant","content":"```cryptol\nqq = [ s + a + b | s <- [0] # qq\n\t          | a <- [1] # qq\n\t          | b <- [0] # zs ]\nzs : [inf][32]\nzs = [0...]\n\ncheck8 = qq @@ [0 .. 4] == [1, 2, 5, 12, 27]\n\nproperty prefix = qq @@ [0 .. 4] == [1, 2, 5, 12, 27]\n```"}]}
{"filename":"cryptol\/tests\/regression\/reference.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Import the Cryptol Reference library under the alias used for that module. Define three properties named foldl_eq, scanl_eq, and iterate_eq that each assert equivalence between the built-in functions and their reference counterparts. For foldl_eq, take an Integer seed and a length-10 sequence of Integers; assert that left-folding with subtraction starting from the seed over the sequence equals the reference implementation\u2019s result. For scanl_eq, with the same argument types, assert that the sequence of intermediate results from the left-scan with subtraction and the seed matches the reference implementation\u2019s sequence. For iterate_eq, take an Integer seed and an 8-bit index; assert that the element at the given index of the sequence produced by repeatedly adding one starting from the seed matches the element at the same index from the reference implementation. Use explicit type annotations for all property arguments, use equality to compare results, and index the iterative sequences by the 8-bit word."},{"role":"assistant","content":"```cryptol\nimport Cryptol::Reference as Ref\n\nproperty foldl_eq (z:Integer) (xs:[10]Integer) =\n  foldl (-) z xs == Ref::foldl (-) z xs\n\nproperty scanl_eq (z:Integer) (xs:[10]Integer) =\n  scanl (-) z xs == Ref::scanl (-) z xs\n\nproperty iterate_eq (z:Integer) (i:[8]) =\n  (iterate (\\x -> x + 1) z)@i == (Ref::iterate (\\x -> x + 1) z)@i\n```"}]}
{"filename":"cryptol\/tests\/regression\/rec-update.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol specification that introduces a type alias for a record with two fields: an 8-bit unsigned value named x and a boolean named y. Provide explicit type signatures and definitions for the following constants: f1, f2, f3, f4 of the record type; and f5, f6 as sequences of exactly four records of that type. Set f1 to the record with x equal to 2 and y true. Define f2 as f1 with x replaced by 3. Define f3 as f2 with x replaced by 4 and y set to false. Define f4 by functionally updating the x field of f3 by adding 1 to its current value (8-bit modular addition). Construct f5 as the ordered sequence [f1, f2, f3, f4]. Define f6 by updating all elements of f5 so that their x fields are replaced positionally by the sequence [7, 8, 9, 10]. Ensure all integer literals are correctly sized to 8 bits."},{"role":"assistant","content":"```cryptol\ntype T = { x : [8], y : Bool }\n\nf1 = { x = 2, y = True } : T\nf2 = { f1 | x = 3 }\nf3 = { f2 | x = 4, y = False }\nf4 = { f3 | x -> x + 1 }\nf5 = [f1,f2,f3,f4]\nf6 = { f5 | x = [7,8,9,10] }\n```"}]}
{"filename":"cryptol\/tests\/regression\/check24.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that:\n- Declares a polymorphic function named xor with a size parameter a. It takes a pair of a-bit sequences and returns an a-bit sequence computed by comparing corresponding bits from the two inputs for inequality using a parallel list comprehension (bitwise XOR via per-bit inequality).\n- Provides an explicit type for xor indicating it maps a pair of length-a bit sequences to a length-a bit sequence.\n- Defines a top-level Boolean constant named check24 that enumerates all ordered pairs of 4-bit values, applies xor specialized at width 4 to each pair, compares the result to the built-in bitwise exclusive-or, collects the 256 boolean results into a 256-bit sequence, and compares that sequence to the all-ones value so the constant is true exactly when every case matches.\n- Uses only standard Cryptol operators and comprehensions, and clearly names all parameters and widths."},{"role":"assistant","content":"```cryptol\nxor : {a} ([a], [a]) -> [a]\nxor (xs, ys) = [ x != y | x <- xs | y <- ys ]\n\ncheck24 = [ xor`{4} (x, y) == (x ^ y) | x <- [ 0 .. 15 ], y <- [ 0 .. 15 ] ] == ~zero\n```"}]}
{"filename":"cryptol\/tests\/regression\/primes.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) defines a polymorphic constant named z1prime with a type parameter n constrained to be prime, returning the modular value 1 in Z n; then defines four specialized bindings z1_2, z1_3, z1_17, and z1_2_17m1 by applying size parameters 2, 3, 17, and (2^17 \u2212 1), respectively. (2) defines five numeric type synonyms p192, p224, p256, p384, and p521, each bound to the exact large prime integer values indicated, to be used as prime moduli. (3) defines a function recip_correct with type {p} (prime p) => Z p -> Bool that, given x in Z p, returns the Boolean condition \u201cx is zero or x times its modular reciprocal equals one.\u201d Then define properties recip_correct_17, recip_correct_1021, recip_correct_p192, recip_correct_p224, recip_correct_p256, recip_correct_p384, and recip_correct_p521, each a property obtained by specializing recip_correct at modulus 17, 1021, p192, p224, p256, p384, and p521, respectively. (4) defines a function moddiv_eq with type {p} (prime p, p >= 3) => Z p -> Z p -> Bool that, for x and y in Z p, returns the Boolean condition \u201cy is zero or modular division of x by y, multiplied by y, equals x.\u201d Then define properties moddiv_eq17, moddiv_eq1021, moddiv_eq_p192, moddiv_eq_p224, moddiv_eq_p256, moddiv_eq_p384, and moddiv_eq_p521, each specializing moddiv_eq at the same corresponding moduli. Use Cryptol property declarations for all listed properties and ensure the constraints on p are present in the type signatures."},{"role":"assistant","content":"```cryptol\nz1prime : {n} (prime n) => Z n\nz1prime = 1\n\nz1_2 = z1prime`{2}\nz1_3 = z1prime`{3}\nz1_17 = z1prime`{17}\nz1_2_17m1 = z1prime`{2^^17 - 1}\n\ntype p192 = 6277101735386680763835789423207666416083908700390324961279\ntype p224 = 26959946667150639794667015087019630673557916260026308143510066298881\ntype p256 = 115792089210356248762697446949407573530086143415290314195533631308867097853951\ntype p384 = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\ntype p521 = 6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151\n\nrecip_correct : {p} (prime p) => Z p -> Bool\nrecip_correct x = x == 0 \\\/ x * recip x == 1\n\nproperty recip_correct_17   = recip_correct`{17}\nproperty recip_correct_1021 = recip_correct`{1021}\nproperty recip_correct_p192 = recip_correct`{p192}\nproperty recip_correct_p224 = recip_correct`{p224}\nproperty recip_correct_p256 = recip_correct`{p256}\nproperty recip_correct_p384 = recip_correct`{p384}\nproperty recip_correct_p521 = recip_correct`{p521}\n\nmoddiv_eq : {p} (prime p, p >= 3) => Z p -> Z p -> Bool\nmoddiv_eq x y = y == 0 \\\/ (x \/. y) * y == x\n\nproperty moddiv_eq17   = moddiv_eq`{17}\nproperty moddiv_eq1021 = moddiv_eq`{1021}\n\nproperty moddiv_eq_p192 = moddiv_eq`{p192}\nproperty moddiv_eq_p224 = moddiv_eq`{p224}\nproperty moddiv_eq_p256 = moddiv_eq`{p256}\nproperty moddiv_eq_p384 = moddiv_eq`{p384}\nproperty moddiv_eq_p521 = moddiv_eq`{p521}\n```"}]}
{"filename":"cryptol\/tests\/regression\/bitshift.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that includes: (1) type signatures and definitions for functions named shift and shift_alt, both polymorphic over a size parameter d with constraints that d is finite and at least 1. Each takes a length-d sequence of bits and a single bit, and returns a length-d sequence representing a one-position right shift where the most-significant position is filled with the provided bit. Implement shift by prefixing the fill bit to the first d\u22121 elements of the input. Implement shift_alt by prefixing the fill bit to the sequence obtained by dropping one element from the input after shifting it right by one. (2) a constant infZero that is an infinite stream of false bits, defined via a self-referential construction. (3) a property named shift_eq that universally quantifies five bits, constructs a 10-bit sequence by concatenating the first four bits with the infinite-zero stream and taking the first 10 elements, and asserts that applying shift and shift_alt to this 10-bit sequence with the fifth bit as the fill yields identical results."},{"role":"assistant","content":"```cryptol\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n          fills = [bit]#(take fill)\n\nshift_alt : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift_alt fill bit = fills\n\twhere\n\t  fills = [bit]#(drop`{1} (fill >> 1))\n\ninfZero : [inf]Bit\ninfZero = [False] # infZero\n\nproperty shift_eq a b c d e = shift (take`{10} ([a,b,c,d]#infZero)) e\n                           == shift_alt (take`{10} ([a,b,c,d]#infZero)) e\n```"}]}
{"filename":"cryptol\/tests\/regression\/check27.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) a bit-typed constant equal to the all-zero value; (2) two tuple-typed constants, one pairing an 8-bit word with a 32-bit word and another triple of 8-, 32-, and 256-bit words, each initialized to the all-zero value for their types; (3) a total function from an 8-bit word to a 16-bit word that ignores its input and returns the 16-bit all-zero value. Then define a top-level Boolean value that conjoins these checks: the bit constant equals false; each tuple constant equals the corresponding tuple of numeric zeros of matching widths; the equalities also hold when the operands are reversed (i.e., both orders of comparison); and applying the function to the decimal value 13 yields the 16-bit zero. Provide explicit type annotations for all constants and the function, and use Cryptol\u2019s standard zero value for initialization. Do not use the property keyword; the final Boolean should be a plain definition that evaluates to true when all conditions hold."},{"role":"assistant","content":"```cryptol\nzeroBit : Bit\nzeroBit = zero\n\nzeroTuple : ([8], [32])\nzeroTuple = zero\nzeroTuple3 : ([8], [32], [256])\nzeroTuple3 = zero\n\nzeroFun : [8] -> [16]\nzeroFun = zero\n\ncheck27 = (zeroBit == False)\n\t&& (zeroTuple == (0, 0)) && (zeroTuple3 == (0, 0, 0))\n\t&& ((0, 0) == zeroTuple) && ((0, 0, 0) == zeroTuple3)\n\t&& (zeroFun 13 == 0)\n```"}]}
{"filename":"cryptol\/tests\/regression\/check26.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that mirrors the file\u2019s behavior: define two total, polymorphic projection functions that return the first and second element of a pair of finite sequences (bitvectors), respectively. Declare a pair constant using the same two numeric literals as in the source. Define a boolean check that each projection equals both the corresponding tuple field accessed by positional indexing and the concrete literal value. Construct a sequence of all pairs using a list comprehension over the two inclusive ranges present in the source (outer generator for the first range, inner for the second), preserving generator order. Define a boolean asserting that mapping the first-projection over this sequence equals the sequence of values from the first range repeated for each element of the second range. Define another boolean asserting that the sequence of equality results between the two components of each pair is exactly equal to the reversal of the hexadecimal bitvector literal used in the source; the bit width must equal the total number of generated pairs. Finally, define a single aggregate boolean that is the conjunction of the three booleans above. Use general types where possible, with concrete literal widths inferred from the numeric and hexadecimal constants. Do not use the property keyword; implement these as function and constant definitions suitable for evaluation or checking with ==."},{"role":"assistant","content":"```cryptol\nfst (x, y) = x\nsnd (x, y) = y\nxy = (13, 21)\ncheck26a = (fst xy == xy.0) && (snd xy == xy.1) &&\n\t   (fst xy == 13) && (snd xy == 21)\n\nxys = [ (x, y) | x <- [ 1 .. 10 ], y <- [ 2 .. 5 ] ]\ncheck26b = [ fst ixy | ixy <- xys ] ==\n\t   [ x | x <- [ 1 .. 10 ], y <- [ 2 .. 5 ] ]\ncheck26c = [ fst ixy == snd ixy | ixy <- xys ] == reverse 0x0000084210\n\ncheck26 = check26a && check26b && check26c\n```"}]}
{"filename":"cryptol\/tests\/regression\/check03.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol specification that: (1) gives a type signature for a function that takes a 32-bit word and returns an infinite sequence of 32-bit words; (2) implements the function to produce an infinite stream whose first element is the input value and each subsequent element is the previous element plus one; and (3) declares a Boolean constant that is true exactly when the element at index 45 of the stream generated from input 0 equals 45, and the element at index 0 of the stream generated from input 45 equals 45."},{"role":"assistant","content":"```cryptol\nnats : [32] -> [inf][32]\nnats n = [n] # nats (n + 1)\n\ncheck3 = (nats 0 @ 45 == 45) && (nats 45 @ 0 == 45)\n```"}]}
{"filename":"cryptol\/tests\/regression\/rational_properties.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define Cryptol properties with the following names and meanings, using universal quantification over the stated types: QaddUnit, QaddComm, QaddAssoc, Qneg, QmulUnit, QmulComm, QmulAssoc, Qdistrib (all over Rational) to capture additive\/multiplicative identities, commutativity, associativity, additive inverse, and distributivity. Qrecip (Rational) to assert that either the value is zero or multiplying by its reciprocal yields the multiplicative identity. QdivisionEquiv (Rational, Rational) to state that rational division equals multiplication by the reciprocal, guarded so the divisor may be zero without causing a partial operation. Ordering properties over Rational: QordEquiv1 (<= equivalent to not greater-than), QordEquiv2 (<= equivalent to equality or <), QordTrans (transitivity of <), QordIrreflexive (no value is < itself), QordExclusive (cannot be both x<y and y<x), Qtrichotomy (exactly one of <, ==, > holds in disjunction form), QordCompatible (addition preserves < with the same addend), QordPositive (product is positive when both factors are positive). Qdense (Rational) to assert density: if one value is strictly less than another, then their average lies strictly between them; define a local midpoint as the average using rational division by two. Integer\/Rational bridging: intDivDown (Integer, Integer) to assert that either the divisor is zero or the rationalized result of truncating integer division is less than or equal to the exact rational ratio. Floor and ceiling correctness over Rational and Integer: floorCorrect1 (floor is a lower bound), floorCorrect2 (any integer lower bound is \u2264 floor), ceilingCorrect1 (ceiling is an upper bound), ceilingCorrect2 (any integer upper bound is \u2265 ceiling). Use fromInteger, floor, ceiling, ratio, recip, negate, logical implication, disjunction, conjunction, and negation. Guard all potentially partial operations (e.g., reciprocal\/division by zero)."},{"role":"assistant","content":"```cryptol\nproperty QaddUnit (x : Rational) =\n  x + 0 == x\n\nproperty QaddComm (x:Rational) (y:Rational) =\n  x + y == y + x\n\nproperty QaddAssoc (x:Rational) (y:Rational) (z:Rational) =\n  x + (y + z) == (x + y) + z\n\nproperty Qneg (x: Rational) = x + negate x == 0\n\nproperty QmulUnit (x : Rational) =\n  x * 1 == x\n\nproperty QmulComm (x:Rational) (y:Rational) =\n  x * y == y * x\n\nproperty QmulAssoc (x:Rational) (y:Rational) (z:Rational) =\n  x * (y * z) == (x * y) * z\n\nproperty Qdistrib (x:Rational) (y:Rational) (z:Rational) =\n  x * (y + z) == x*y + x*z\n\nproperty Qrecip (x: Rational) = x == 0 \\\/ x * recip x == 1\n\nproperty QdivisionEquiv (x : Rational) (y : Rational) =\n  y == 0 \\\/ x \/. y == x * (recip y)\n\nproperty QordEquiv1 (x : Rational) (y : Rational) =\n  (x <= y) == ~(y < x)\n\nproperty QordEquiv2 (x : Rational) (y : Rational) =\n  (x <= y) == (x == y \\\/ x < y)\n\nproperty QordTrans (x : Rational) (y : Rational) (z : Rational) =\n  x < y ==> y < z ==> x < z\n\nproperty QordIrreflexive (x : Rational) =\n  ~(x < x)\n\nproperty QordExclusive (x : Rational) (y:Rational) =\n  ~(x < y) || ~(y < x) \n\nproperty Qtrichotomy (x : Rational) (y : Rational) =\n  x < y \\\/ x == y \\\/ x > y\n\nproperty QordCompatible (x : Rational) (y : Rational) (z:Rational) =\n  x < y ==> x+z < y+z\n\nproperty QordPositive (x : Rational) (y : Rational) =\n  0 < x ==> 0 < y ==> 0 < x*y\n\nproperty Qdense (x : Rational) (y : Rational) = x < y ==> x < mid \/\\ mid < y\n  where\n  mid = (x + y) \/. 2\n\nproperty intDivDown (x : Integer) (y:Integer) =\n  y == 0 \\\/ fromInteger (x \/ y) <= ratio x y\n\nproperty floorCorrect1 (x:Rational) =\n  fromInteger (floor x) <= x\n\nproperty floorCorrect2 (x:Rational) (y:Integer) =\n  fromInteger y <= x ==>\n  y <= floor x\n\nproperty ceilingCorrect1 (x:Rational) =\n  fromInteger (ceiling x) >= x\n\nproperty ceilingCorrect2 (x:Rational) (y:Integer) =\n  fromInteger y >= x ==>\n  y >= ceiling x\n```"}]}
{"filename":"cryptol\/tests\/regression\/check28.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the constant xs as a length-7 sequence of pairs where each pair contains the same unsigned word value from 1 to 7 in order. Make xs polymorphic over the element width w with the constraint 3 <= w, so each element of a pair has type [w]. Next, define a property named check28 that asserts that mapping equality over each pair in xs (producing a length-7 sequence of Bit) yields an all-ones bitvector of length 7 (i.e., the bitwise complement of zero at that length). Provide full type signatures: xs :: [7] ([w], [w]) with 3 <= w, and check28 :: {w} (3 <= w) => Bit. The property should compare the boolean sequence derived from the pairwise equalities against the all-ones vector constructed via bitwise negation of zero with a length matching the result sequence. Avoid any additional assumptions beyond the width constraint and preserve the exact ordering and values 1 through 7 for the pairs."},{"role":"assistant","content":"```cryptol\nxs = [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7)]\ncheck28 = [ x==y | (x,y) <- xs ] == ~zero\n```"}]}
{"filename":"cryptol\/tests\/regression\/check14.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a polymorphic function named swab with a type signature stating that for any natural length n and any element type a, it takes a sequence of n inner sequences, each of length 4, and returns a sequence of the same shape where each inner sequence has its four elements in reverse order. Also define a boolean constant named check14 that asserts that applying swab to a concrete example consisting of two 4-element sequences of consecutive small integers yields the corresponding result where each of those two inner sequences is reversed. Clearly state the types of all definitions (swab: [n][4]a -> [n][4]a; check14: Bit) and ensure no additional assumptions beyond standard equality on sequences are required."},{"role":"assistant","content":"```cryptol\nswab xxs = [ [d, c, b, a]\n           | [a, b, c, d] <- xxs\n           ]\n\ncheck14 = swab [[0, 1, 2, 3], [4, 5, 6, 7]] == [[3, 2, 1, 0], [7, 6, 5, 4]]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check11.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol specification that introduces a boolean constant named check11 which evaluates whether a base sequence equals a two-stage reindexing of itself. Create: (1) zz as the finite sequence of 100 consecutive unsigned values starting at 0, with element type the minimal fixed-width word sufficient to represent 99; (2) qq as the result of indexing zz by a sequence of 32-bit indices ranging from 0 to 2^32\u22121 using vector-based indexing; and (3) ww as the result of indexing qq by the indices 0 through 99. The constant check11 must be the equality of zz and ww. Include explicit type annotations so that the index elements for qq are 32-bit words and zz has length 100 with minimal element width. Ensure all size and finiteness constraints are concrete (no polymorphic lengths) and that the construction typechecks without runtime assumptions."},{"role":"assistant","content":"```cryptol\ncheck11 = zz == ww\n  where\n    zz = [0 .. 99]\n    qq = zz @@ ([0 .. 0xffffffff] : [_][32])\n    ww = qq @@ [0 .. 99]\n```"}]}
{"filename":"cryptol\/tests\/regression\/FloatTests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named FloatTests that imports Float and contains the following definitions: (1) A function section with type {n} fin n => [n][8] -> [78][8] that returns a 78-byte vector formed by concatenating a fixed three-byte prefix consisting of two hyphens and a space, then the first min(60, n) bytes of the input, then enough hyphen bytes to reach length 78. (2) Type aliases: Small as a floating type with exponent 3 and precision 2, Medium as the 64-bit binary floating type, and Large as a floating type with exponent 60 and precision 5000. (3) Define a property that converting any floating value to raw bits and back with the provided conversions yields a value totally equal to the original. (4) A polymorphic signature roundTrip2: {e:#, p:#} (fin e, fin p, ValidFloat e p) => [e + p] -> Bool, and define a property that for any bitvector, decoding then re-encoding either reproduces the original bits or the decoded value is NaN. (5) Define a property that total floating equality is reflexive. (6) Define a property that IEEE partial equality is reflexive except for NaN. (7) Define a property that when IEEE partial equality holds, the operands are totally equal or represent signed-zero equivalents, allowing NaN cases. (8) Define a property that IEEE \u2264 is reflexive except for NaN. (9) A signature roundTripRational: {e,p} (fin e, fin p, ValidFloat e p) => Float e p -> Bool, and define a property that for finite values, converting to rational and back with round-to-nearest-even yields a totally equal result, permitting negative zero as an exceptional equivalent."},{"role":"assistant","content":"```cryptol\nmodule FloatTests where\n\nimport Float\n\nsection : {n} fin n => [n][8] -> [78][8]\nsection x = \"-- \" # take`{min 60 n} x # repeat '-'\n\ntype Small  = Float 3 2\ntype Medium = Float64\ntype Large  = Float 60 5000\n\nproperty roundTrip x  = fpFromBits (fpToBits x) =.= x\n\nroundTrip2 : {e : #, p : #} (fin e, fin p, ValidFloat e p) => [e + p] -> Bool\nproperty roundTrip2 x = fpToBits num == x \\\/ num =.= fpNaN\n                          where num = fpFromBits x : Float e p\nproperty eqRefl1 x    = x =.= x\nproperty eqRefl2 x    = x == x \\\/ x =.= fpNaN\nproperty eqProp x y   = ~(x == y) \\\/\n                         (x =.= y \\\/ x =.= fpNaN\n                                  \\\/ y =.= fpNaN\n                                  \\\/ (x =.=  0.0 \/\\ y =.= -0.0)\n                                  \\\/ (x =.= -0.0 \/\\ y =.=  0.0)\n                         )\nproperty leqRefl x    = x <= x \\\/ x =.= fpNaN\n\nroundTripRational : {e,p} (fin e, fin p, ValidFloat e p) => Float e p -> Bool\nproperty roundTripRational x =\n  ~(fpIsFinite x) \\\/\n  (fpFromRational rne (fpToRational x) =.= x) \\\/\n  (x =.= fpNegZero)\n```"}]}
{"filename":"cryptol\/tests\/regression\/specialize.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named specialize that contains two definitions: (1) a polymorphic function f parameterized by two type variables a and b with the type \u201cfor all a and b, from a pair of (a, b) to a pair of (a, b)\u201d, which returns its input pair unchanged; and (2) a function top with the type \u201cfrom a pair of Bit and Bit to a pair of Bit and Bit\u201d that invokes f using explicit type application specialized to Bit and Bit on its input pair and returns the result. Include explicit type signatures for both functions, no additional constraints, and ensure top\u2019s implementation is exactly the specialization of f to bits."},{"role":"assistant","content":"```cryptol\nmodule specialize where\n\ntop (x, y) = f`{Bit,Bit} (x, y)\n\nf : {a, b} (a, b) -> (a, b)\nf (x, y) = (x, y)\n```"}]}
{"filename":"cryptol\/tests\/regression\/poly.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models dense univariate polynomials over a ring and verifies their evaluation laws. Specifically: 1) Define a parametric newtype representing a polynomial of degree n with coefficients stored as a sequence of length n+1 over an element type that is a ring. 2) Define a function that evaluates a polynomial at a given point, requiring finite n and a ring element type. Compute the value as the sum of each coefficient multiplied by the corresponding power of the input, where the sequence of powers starts at one and is generated by repeated multiplication, and the sum is accumulated with ring addition starting from the additive identity. 3) Define a function that builds a constant polynomial from a scalar, placing the scalar as the constant term and filling remaining coefficients with the additive identity. 4) Define a function that adds two polynomials of the same degree by pointwise addition of their coefficient sequences. 5) Define a function that multiplies two polynomials of degrees n1 and n2 to produce a polynomial of degree n1+n2, by forming, for each coefficient\/index of the first polynomial, a copy of the second polynomial scaled by that coefficient and shifted by the index (implemented by appending the appropriate number of additive-identity coefficients), and summing all such shifted-scaled polynomials starting from the zero polynomial. 6) Define a property that, over integers, evaluating the monic quadratic with only a squared term at an input equals the square of that input. 7) Define a property that, for degree-5 integer polynomials and any integer input, evaluating the sum equals the sum of evaluations. 8) Define a property that, for degree-5 integer polynomials and any integer input, evaluating the product equals the product of evaluations."},{"role":"assistant","content":"```cryptol\nnewtype Poly n a = { coeffs : [n+1]a }\n\nevalPoly : {n, a} (fin n, Ring a) => Poly n a -> a -> a\nevalPoly p x = foldl (+) zero terms\n  where\n    terms = [ c*a | c <- p.coeffs | a <- xs ]\n    xs    = [fromInteger 1]#[ x*a | a <- xs ]\n\npolyConst : {n, a} (fin n, Ring a) => a -> Poly n a\npolyConst a = Poly { coeffs = [a]#zero }\n\npolyAdd : {n, a} (fin n, Ring a) => Poly n a -> Poly n a -> Poly n a\npolyAdd p1 p2 = Poly { coeffs = zipWith (+) p1.coeffs p2.coeffs }\n\npolyMul : {n1, n2, a} (fin n1, fin n2, Ring a) =>\n  Poly n1 a -> Poly n2 a -> Poly (n1+n2) a\npolyMul p1 p2 = foldl polyAdd (polyConst zero) ps\n  where\n    ps : [n1+1](Poly (n1+n2) a)\n    ps@i = Poly{ coeffs = scaleAndShift i }\n\n    scaleAndShift i =\n      ([ p1.coeffs@i * c | c <- p2.coeffs ] # zero) >> i\n\nproperty polySquare (x:Integer) =\n  evalPoly (Poly { coeffs = [0,0,1] }) x == x * x\n\nproperty polyAddEval x (p1:Poly 5 Integer) (p2:Poly 5 Integer) =\n  evalPoly (polyAdd p1 p2) x == evalPoly p1 x + evalPoly p2 x\n\nproperty polyMulEval x (p1:Poly 5 Integer) (p2:Poly 5 Integer) =\n  evalPoly (polyMul p1 p2) x == evalPoly p1 x * evalPoly p2 x\n```"}]}
{"filename":"cryptol\/tests\/regression\/check12.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a polymorphic Cryptol specification with: (1) a function named sums that, for any finite length n and an element type supporting addition with a zero value, takes a sequence of n elements and returns a sequence of n containing the running (prefix) sums. Implement it by pairing each input element with the previous output value, starting from zero, so each output is the current input plus the prior output. Provide an explicit type signature parameterized by n and the element type. (2) a boolean constant named check12 that compares the result of applying sums to the sequence of the first ten non-negative integers, with each element represented as a 32-bit word, against the expected cumulative totals for that input. The constant should evaluate to True exactly when the computed running sums match the known cumulative sums. Ensure sequence length and 32-bit widths are consistent throughout."},{"role":"assistant","content":"```cryptol\nsums xs = ys\n  where ys = [ x + y | x <- xs | y <- [0] # ys ]\n\ncheck12 = sums ([0 .. 9] : [_][32]) == [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check06.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define in Cryptol the following with explicit type signatures: (1) a numeric type parameter w with constraint w >= 2; (2) two mutually recursive infinite sequences onetwos and twoones of type [inf][w], where onetwos begins with 1 followed by the entirety of twoones and twoones begins with 2 followed by the entirety of onetwos, yielding alternating values; (3) a sequence onesytwosy of type [inf][2][w] built by zipping the previous two streams in lock-step via a parallel list comprehension into length-2 sequences at each index; and (4) a Boolean constant check6 that compares the subsequence obtained by selecting indices 0 through 3 from the zipped sequence to the expected four-element sequence whose entries alternate between the two-element sequences [1,2] and [2,1], starting with [1,2]."},{"role":"assistant","content":"```cryptol\nonetwos = [1] # twoones\ntwoones = [2] # onetwos\nonesytwosy = [ [one, two] | one <- onetwos | two <- twoones ]\n\ncheck6 = onesytwosy @@ [0 .. 3] == [ [1, 2], [2, 1], [1, 2], [2, 1] ]\n```"}]}
{"filename":"cryptol\/tests\/regression\/check13.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define two functions and one boolean constant that mirror the described behavior: (1) a function named ick with type [1][8] -> [8] that returns the only 8-bit element from a length-1 sequence; (2) a function named uck with type [8][1] -> [8] that concatenates eight 1-bit elements, in order, into a single 8-bit value; and (3) a constant named check13 of type Bit that is true exactly when both of the following equalities hold: (a) applying ick to the result of splitting the 8-bit literal 150 into one 8-bit chunk yields 150, and (b) applying uck to the result of splitting the 8-bit literal 150 into eight 1-bit chunks yields 150. Use Cryptol\u2019s split so that the chunking is inferred from each function\u2019s input type, and ensure 150 is treated as an 8-bit value. Do not introduce additional parameters or assumptions."},{"role":"assistant","content":"```cryptol\nick : [1][8] -> [8]\nick [x] = x\n\nuck : [8][1] -> [8]\nuck [a, b, c, d, e, f, g, h] = a # b # c # d # e # f # g # h\n\ncheck13 = (ick (split 150) == 150) && (uck (split 150) == 150)\n```"}]}
{"filename":"cryptol\/tests\/regression\/allsat.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol function named f with type (Integer, Integer, Integer) -> Bit that pattern-matches a 3-tuple and returns true if and only if each of the three integers lies within the inclusive range 1 to 15. Implement the range check via a local where-clause helper that takes an Integer and returns the logical conjunction of the lower-bound and upper-bound comparisons, and have f apply this helper to each component and combine the three results with boolean AND. Use only integer comparisons and Bit-valued logic; do not use lists or sequences."},{"role":"assistant","content":"```cryptol\nf : (Integer, Integer, Integer) -> Bit\nf (x, y, z) =  inRange x && inRange y && inRange z\n  where inRange v = (1 <= v) && (v <= 15)\n```"}]}
{"filename":"cryptol\/tests\/regression\/negshift.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines five boolean-returning helper functions and a suite of properties to check them:\n- A polymorphic function over sequence length n and element type a, with constraints that n is finite, a has a zero element for shift fill, and a is comparable, taking a vector of length n of a and an integer shift amount, and returning whether left-shifting by the amount equals right-shifting by the negated amount.\n- A second polymorphic function with the same constraints returning whether right-shifting by the amount equals left-shifting by the negated amount.\n- A polymorphic function over n and a, with n finite and a comparable, returning whether rotating left by the amount equals rotating right by the negated amount.\n- A second rotate function with the same constraints returning whether rotating right by the amount equals rotating left by the negated amount.\n- A function over n, with n finite and n >= 1, taking a bitvector of length n and an integer shift amount, that returns an implication stating: if the amount is negative, then an arithmetic right shift (sign-extending) by that amount equals a logical left shift by the negated amount.\nProvide explicit type signatures: the first four functions take [n]a and Integer and return Bit; the last takes [n] and Integer and returns Bit. Then define properties that instantiate these functions at the following type parameters:\n- For each of the four shift\/rotate equivalence functions: (n=8, a=Bit), (n=32, a=Bit), (n=8, a=Integer), and (n=8, a=[32]).\n- For the arithmetic-shift implication function: n=8 and n=32.\nUse Cryptol equality and the logical\/rotational\/arithmetic shift operators accordingly."},{"role":"assistant","content":"```cryptol\nnegLeftShift : {n, a} (fin n, Zero a, Cmp a) => [n]a -> Integer -> Bit\nnegLeftShift xs i = xs << i == xs >> (negate i)\n\nnegRightShift : {n, a} (fin n, Zero a, Cmp a) => [n]a -> Integer -> Bit\nnegRightShift xs i = xs >> i == xs << (negate i)\n\nnegLeftRotate : {n, a} (fin n, Cmp a) => [n]a -> Integer -> Bit\nnegLeftRotate xs i = xs <<< i == xs >>> (negate i)\n\nnegRightRotate : {n, a} (fin n, Cmp a) => [n]a -> Integer -> Bit\nnegRightRotate xs i = xs >>> i == xs <<< (negate i)\n\nnegSshr : {n} (fin n, n >= 1) => [n] -> Integer -> Bit\nnegSshr xs i = i < 0 ==> xs >>$ i == xs << (negate i)\n\nproperty nls1 = negLeftShift`{8, Bit}\nproperty nls2 = negLeftShift`{32, Bit}\nproperty nls3 = negLeftShift`{8, Integer}\nproperty nls4 = negLeftShift`{8, [32]}\n\nproperty nrs1 = negRightShift`{8, Bit}\nproperty nrs2 = negRightShift`{32, Bit}\nproperty nrs3 = negRightShift`{8, Integer}\nproperty nrs4 = negRightShift`{8, [32]}\n\nproperty nlr1 = negLeftRotate`{8, Bit}\nproperty nlr2 = negLeftRotate`{32, Bit}\nproperty nlr3 = negLeftRotate`{8, Integer}\nproperty nlr4 = negLeftRotate`{8, [32]}\n\nproperty nrr1 = negRightRotate`{8, Bit}\nproperty nrr2 = negRightRotate`{32, Bit}\nproperty nrr3 = negRightRotate`{8, Integer}\nproperty nrr4 = negRightRotate`{8, [32]}\n\nproperty nsshr1 = negSshr`{8}\nproperty nsshr2 = negSshr`{32}\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T06.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains the following definitions: (1) an interface submodule Iface that declares a single numeric type parameter Width of kind #; (2) a concrete submodule Impl that binds Width to the numeric literal 1; (3) a submodule SubC that imports the interface submodule and defines a value unitVal equal to the unit value; (4) a submodule SubB that imports the interface submodule and defines a nested submodule CInst by instantiating SubC with submodule Impl; and (5) a submodule SubA defined by instantiating SubB with submodule Impl. Use proper Cryptol syntax for interface submodules, type declarations and definitions, submodule imports, submodule instantiation with named submodule arguments, and the unit value. Do not add any extra bindings, functions, or properties."},{"role":"assistant","content":"```cryptol\nmodule T06 where\n\ninterface submodule I where\n  type N : #\n\nsubmodule N1 where\n  type N = 1\n\nsubmodule C where\n  import interface submodule I\n\n  lost = ()\n\nsubmodule B where\n  import interface submodule I\n  submodule C_ = submodule C { submodule N1 }\n\nsubmodule A = submodule B { submodule N1 }\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T10.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains the following definitions: (1) A public property of type Bit that unconditionally evaluates to the true bit. (2) A submodule that declares one public property of type Bit that is true and one private property of type Bit that is true; the private property must not be exported outside this submodule. (3) A parameterized submodule that declares a numeric type parameter of kind # (named generically, e.g., N) and within it defines one public property of type Bit that is true and one private property of type Bit that is true. (4) A submodule instance that binds the numeric type parameter of the parameterized submodule to the literal 1. Clearly indicate visibility (public vs private), the kind of the numeric parameter, and that each property evaluates to true without additional constraints. Do not provide implementations beyond these declarations; focus on correct module\/submodule structure, parameterization, visibility, and property declarations."},{"role":"assistant","content":"```cryptol\nmodule T10 where\n\np : Bit\nproperty p = True\n\nsubmodule M where\n  q : Bit\n  property q = True\n\n  private\n    r : Bit\n    property r = True\n\nsubmodule F where\n  parameter\n    type N : #\n\n  s : Bit\n  property s = True\n\n  private\n    t : Bit\n    property t = True\n\nsubmodule F1 = submodule F where type N = 1\n```"}]}
{"filename":"cryptol\/tests\/docstrings\/T02.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named T02 that contains the following definitions: a parameterized submodule F with a numeric type parameter n (kind #) constrained to be finite and at least 2; inside F, declare a private constant c of modular integer type Z n (integers modulo n) with value 1; inside F, define a function p with type Z n -> Bit that returns whether adding c to an input is commutative (the sum is equal regardless of whether c is on the left or right). Define a submodule F7 that instantiates F with n set to 7. At the top level, define a function f with type Integer -> Integer that returns its argument added to itself. Clearly specify all types, constraints, privacy, and intended behavior in Cryptol-compatible form."},{"role":"assistant","content":"```cryptol\nmodule T02 where\n\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n, n >= 2)\n\n  private\n    c : Z n\n    c = 1\n\n  p x = c + x == x + c\n\nsubmodule F7 = submodule F where\n  type n = 7\n\nf : Integer -> Integer\nf x = x + x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue314.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a polymorphic function named f with a numeric type parameter a constrained by fin a and a >= 2. Give f the type [a][8] -> [8], meaning it accepts a sequence of a 8-bit values and returns a single 8-bit value. Implement f by creating a local sequence of length a\/2 whose elements are 8-bit zeros, and return the element at index 0 from that local sequence. Also define a property that, for all valid a and all inputs of the required type, the result of f equals the all-zero 8-bit value. The specification must clearly state the numeric constraints, the local binding\u2019s type [a\/2][8], the use of the zero-initialized sequence, and the safety of indexing (guaranteed by a >= 2 implying a\/2 >= 1)."},{"role":"assistant","content":"```cryptol\nf : {a} (fin a, a>=2) => [a][8] -> [8]\nf xs = ys!0\n where\n  ys : [a\/2][8]\n  ys = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1796.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define five polymorphic functions parameterized by a natural number w. Three functions map a bitvector to itself where the bitvector length is two raised to (two raised to w). Each of these three uses guarded branches that compare this computed length against the constant 2, returning the input when the length is not equal to 2 and returning the bitwise complement when it is equal to 2; the three variants must differ only by the order of the guards but be semantically identical. A fourth function has the same type and behavior but includes only equality-to-2 and greater-than-2 branches (no less-than-2 branch). A fifth function maps a bitvector of length two raised to w to itself, returning the complement only when the length equals 1 and otherwise returning the input. Provide explicit type signatures for all five functions with the appropriate sequence lengths tied to w. Then write Cryptol properties that universally quantify over w and inputs to: (1) prove the three reordered-guard variants are equivalent for all w and inputs; (2) prove the variant lacking the less-than-2 branch is equivalent to the others for all w and inputs; and (3) prove the function over length two-to-the-w returns the complement exactly when the length equals 1 and otherwise returns the input. Also include a property establishing that for all w, two raised to (two raised to w) is never less than 2, justifying the unreachable less-than case."},{"role":"assistant","content":"```cryptol\nexhaustive1 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1 x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n\nexhaustive1Reordered1: {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1Reordered1 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n\nexhaustive1Reordered2 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1Reordered2 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n\nexhaustive2 : {w} [2 ^^ w] -> [2 ^^ w]\nexhaustive2 x\n  | (2 ^^ w) == 1 => ~ x\n  | (2 ^^ w) > 1 => x\n\nexhaustive3 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive3 x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n  | (2 ^^ (2 ^^ w)) > 2 => x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue670.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a type-level infix operator named +++ that subtracts its right operand from its left operand on type-level naturals. Then declare two constants: g with a word type whose bit-length is computed by applying +++ in a left-associative chain to 6, 2, and 1, and whose value is 2; and h with a word type whose bit-length is computed by applying +++ to 6 and the parenthesized result of applying +++ to 2 and 1, and whose value is 9. Use the operator only in type-level size expressions, and ensure both values conform to their declared widths."},{"role":"assistant","content":"```cryptol\ntype x +++ y = x-y\n\ng : [6 +++ 2 +++ 1]\ng = 2\n\nh : [6 +++ (2 +++ 1)]\nh = 9\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue116.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the constant t as a 2-tuple where the first element is a 4-bit word with value 1, and the second element is a record with fields: key as an unbounded integer equal to 4, and value as a sequence of seven 8-bit elements encoding the ASCII string goodbye. Provide an explicit type signature for t matching these components. Then define the boolean constant bug116fixed as the logical conjunction of two self-equality checks formed by projecting the second element of t and comparing its value field to itself and its key field to itself. Provide an explicit type signature for bug116fixed as Bit."},{"role":"assistant","content":"```cryptol\nt = (0x1, { key = 4, value = \"goodbye\"})\n\nbug116fixed = (t.1.value == t.1.value) \/\\ (t.1.key == t.1.key)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue128.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol function named copy with the type: infinite sequence of bits to infinite sequence of bits. Implement it by recursively deconstructing the input into a head bit and an infinite tail, emitting the head bit unchanged as the new head and recursing on the tail, so the output is elementwise identical to the input. Use standard sequence concatenation and singleton construction for the head element. Then define a property named ok that evaluates to True by asserting that, when copy is applied to a stream whose first element is True and whose remaining elements are all zero bits, the element at index 0 of the result is True. Use the indexing operator to select index 0. Clearly declare the types involved (Bit for elements, infinite sequence for the stream) and avoid introducing any additional parameters or constraints."},{"role":"assistant","content":"```cryptol\ncopy : [inf] -> [inf]\ncopy ([b] # x) = if b then [True] # copy x else [False] # copy x\n\nproperty ok = copy ([True] # zero) @ 0\n```"}]}
{"filename":"cryptol\/tests\/issues\/T1439.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named T that contains the following definitions and structure:\n- A function f with a numeric type parameter n that takes a one-element sequence whose element has length n and returns that element; give f an explicit polymorphic type signature over n.\n- A function p with type variables a and b that takes a pair of (a, b) and returns the first component; include its polymorphic type signature.\n- An interface submodule I that declares a numeric type member n (of kind #).\n- A submodule F that imports the interface I and defines:\n  - A function h using the n from I, with type from a one-element sequence of length-n values to a length-n value, implemented by returning the sole element.\n  - A function g with a numeric parameter m, with type from a one-element sequence of length-m values to a length-m value, implemented by returning the sole element.\n  - Three functions q, q1, and q2 with the same polymorphic type over b, each taking a pair whose first component has type b (second component unconstrained) and returning the first component; implement them respectively by pattern matching on the pair, by selecting the first tuple field, and by destructuring the pair in a local binding and returning the first binding.\n- A submodule P1 that fixes the interface member n to the numeric value 1.\n- A submodule S that is the instantiation of F with P1.\n- An import of submodule S into T so that S\u2019s definitions are brought into the module scope."},{"role":"assistant","content":"```cryptol\nmodule T where\n    f : {n} [1][n] -> [n]\n  f [x] = x\n\n  p : {a,b} (a,b) -> a\n  p (x,_) = x\n\n  interface submodule I where\n    type n : #\n\n  submodule F where\n    import interface submodule I\n\n    h : [1][n] -> [n]\n    h [x] = x\n\n    g : {m} [1][m] -> [m]\n    g [x] = x\n\n    q, q1, q2 : {b} (b,_) -> b\n    q (x,_) = x\n\n    q1 x = x.0\n    q2 x = y\n      where\n      (y,z) = x\n\n  submodule P1 where\n    type n = 1\n\n  submodule S = submodule F { submodule P1 }\n\n  import submodule S\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue058.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define three top-level functions with explicit polymorphic type signatures and bodies: (1) a function named some that, for any natural width n, takes an n-bit word and returns a single bit indicating whether the word is nonzero; implement it by comparing the input to zero. (2) a function named last that, for any length n \u2265 1 and any element type a, takes a sequence of length n of a and returns the element at index 0; include the length constraint n \u2265 1 and use indexing at position 0. (3) a function named pad that, for any n, takes an n-bit word and returns an infinite stream of bits formed by concatenating the finite input with an infinite stream of zeros. Use appropriate Cryptol sequence types, size parameters, and constraints to capture these behaviors precisely, and ensure each definition\u2019s result type matches the described output (Bit for the predicate, element type a for the selector, and an infinite bit sequence for the padding function)."},{"role":"assistant","content":"```cryptol\nsome : {n} [n] -> Bit\nsome x = x != 0\n\nlast : {n, a} (n >= 1) => [n]a -> a\nlast xs = xs ! 0\n\npad : {n} [n] -> [inf]\npad x = x # zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue312.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that includes: (1) a function that maps a 16-bit word to a 16-bit word by returning three times the input via multiplication; (2) a second function that maps a 16-bit word to a 16-bit word by adding the input to itself twice; and (3) a property asserting these two functions are extensionally equal for all 16-bit inputs (i.e., they produce identical results on every possible 16-bit argument) using Cryptol\u2019s function equality. Provide explicit type signatures for both functions and no additional constraints."},{"role":"assistant","content":"```cryptol\nf : [16] -> [16]\nf x = 3 * x\n\ng : [16] -> [16]\ng x = x + x + x\n\nproperty f_g = (f === g)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue662.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define the following: (1) a type synonym Q representing a pair of two Integers (numerator, denominator); (2) a function toQ: Integer -> Integer -> Q that normalizes a rational pair by rejecting a zero denominator with an error, and ensuring the denominator is positive by negating both components when it is negative; otherwise return the pair unchanged; (3) a function leQ: Q -> Q -> Bit that returns true when the first rational is less than or equal to the second using cross-multiplication on numerators and denominators; (4) a function intToQ: Integer -> Q that embeds an Integer as a rational with denominator 1; (5) a function abs: Integer -> Integer that returns the absolute value. Additionally, define the following properties: (a) define a property that for all Integers x and y, either y equals zero or the rational formed from the integer quotient x divided by y (as produced by intToQ) is less than or equal to the normalized rational produced by toQ x y under leQ; (b) define a property that for all Integers x and y, either y equals zero or the Euclidean identity holds: divisor times integer quotient plus remainder equals the original dividend; (c) define a property that for all Integers x and y, either y equals zero or the absolute value of the remainder is strictly less than the absolute value of the divisor. Include explicit type signatures for all definitions and use the helper functions within the properties as described."},{"role":"assistant","content":"```cryptol\ntype Q = (Integer, Integer)\n\ntoQ : Integer -> Integer -> Q\ntoQ a b =\n  if b == 0 then error \"divide by 0\" else\n  if b < 0 then (negate a, negate b) else (a, b)\n\nleQ : Q -> Q -> Bit\nleQ (a,b) (c,d) = a*d <= b*c\n\nintToQ : Integer -> Q\nintToQ x = (x, 1)\n\nabs : Integer -> Integer\nabs x = if x < 0 then negate x else x\n\nproperty divRoundsDown (x : Integer) (y : Integer) =\n  y == 0 \\\/ leQ (intToQ ( x \/ y )) (toQ x y)\n\nproperty divEuclidean (x : Integer) (y : Integer) =\n  y == 0 \\\/ y * (x \/ y) + x % y == x\n\nproperty modAbs (x : Integer) (y : Integer) =\n  y == 0 \\\/ abs (x % y) < abs y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue78.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a function named unique with an explicit polymorphic type over two size parameters: a (sequence length) and b (element width), constrained so both are finite and the length is at least 1. The function takes a sequence of length a whose elements are b-bit words and returns a single bit indicating whether all elements are distinct. Implement it by constructing a bitvector via a zipped list comprehension over element-position pairs (iterate positions from 0 to a\u22121). For each element x at index i, call a local helper exist starting from index i+1 to determine if x appears again later in the sequence. The helper exist must be defined in a where block, take a b-bit word and an index whose type is a word wide enough to index the sequence (width equal to the bit-width of a), and return a bit. It should return False when the index is past the end (index \u2265 a), return True if the element at the current index equals x, and otherwise recurse with the index incremented by 1. The outer function must aggregate the per-position results into a bitvector and produce True only when all entries indicate no later duplicate (e.g., by comparing that bitvector to zero). Include complete type signatures for both unique and exist, the stated constraints, and use sequence indexing for element access."},{"role":"assistant","content":"```cryptol\nunique : {a,b} (fin a, fin b, a>=1) => [a][b] -> Bit\nunique xs = [ exist x (i+1) | x <- xs | i <- [0..(a-1)] ] == 0\n  where exist : [b] -> [width a] -> Bit\n        exist x i = if(i>=`a) then False\n                    else if(x==(xs@i)) then True\n                    else exist x (i+1)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue138.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the following in Cryptol: (1) A constant named dwn of type \u201csequence of 16 elements of 4\u2011bit unsigned values\u201d whose elements satisfy a backward recurrence: the last element is zero and each earlier element equals one plus its successor (arithmetic modulo 16), yielding the descending sequence from 15 to 0. (2) A constant named dwn' with the same type and value as dwn, but constructed using index-based self-reference over positions 1 through 15 and appending zero. (3) A polymorphic function named take_some with size parameters n and k and element type t, constrained by n \u2265 k, that maps a sequence of length n to its first k elements using a self-referential, length-driven comprehension; include its full type signature reflecting these parameters and constraint. Also define two properties: one that dwn equals dwn' and both equal the descending 4\u2011bit sequence from 15 to 0 (with arithmetic modulo 16), and another that for all n, k, t with n \u2265 k and all inputs xs of length n, take_some xs returns exactly the first k elements of xs."},{"role":"assistant","content":"```cryptol\ndwn: [16][4]\ndwn = [ 1+d | d <- tail dwn ] # [0]\n\ndwn': [16][4]\ndwn' = [ 1+(dwn' @ i) | i <- [1 .. 15] ] # [0]\n\ntake_some: {n,k,t} (n>=k) => [n]t -> [k]t\ntake_some xs = takes where takes = [ x | x <- xs | _ <- takes ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue851.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a type alias named base, parameterized by a type t, representing a record with one field zero of type t. Define a constant B of type base Bool whose zero field is the boolean false. Define a polymorphic function foo that, for any finite length k, takes a base t record and returns a length-k sequence of t by repeating the record\u2019s zero value. Define a polymorphic function bar that, for any finite k with k \u2265 1, takes three length-k sequences of t and returns the first argument unchanged. Define a polymorphic function baz that, for any finite k with k \u2265 1, takes two length-k sequences of t and returns the second argument unchanged. Finally, define a property named problem that, for any p of the appropriate length and element type consistent with the other uses, states: if p is not equal to the sequence produced by foo applied to B, then calling bar with p as the first argument, with the result of baz applied to p and a fixed finite sequence literal as the second argument, and with the same fixed literal as the third argument, yields a result equal to the sequence produced by foo applied to B. Include all necessary type constraints."},{"role":"assistant","content":"```cryptol\ntype base t = { zero: t }\n\nB: base Bool\nB = { zero = False }\n\nfoo: {t,k} (fin k) => base t -> [k]t\nfoo b = repeat b.zero\n\nbar: {t,k} (fin k, k>=1) => [k]t -> [k]t -> [k]t -> [k]t\nbar p q m = p\n\nbaz: {k,t} (fin k, k >= 1) => [k]t -> [k]t -> [k]t\nbaz p q = q\n\nproperty problem p =\n  p != foo B ==> bar p (baz p 0x03) 0x03 == foo B\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1590.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Main that contains the following definitions: (1) a submodule F parameterized by a single value parameter x of type Bit; inside F, declare a newtype T as a record with one field named bit of type Bit, and define a type alias U that is equal to T; (2) a submodule M created by instantiating F with the parameter x set to False; (3) an import that brings the instantiated submodule M into the Main scope; (4) a top-level constant foo with type U whose value is constructed using the T newtype constructor by setting its record field bit to True. Make all types explicit, ensure the alias U resolves to the T defined within the imported submodule, and specify that foo\u2019s type and constructor usage refer to the imported definitions."},{"role":"assistant","content":"```cryptol\nmodule Main where\n\nsubmodule F where\n  parameter\n    x : Bit\n  newtype T = { bit : Bit }\n  type U = T\n\nsubmodule M = submodule F where x = False\n\nimport submodule M\n\nfoo : U\nfoo = T { bit = True }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1802.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named T1802 that contains the following definitions: (1) a numeric type parameter loglogw (kind #) constrained to be between 1 and 3 inclusive; (2) a type alias logw that is 2 raised to the power of loglogw at the type level; (3) a type alias w that is 2 raised to the power of logw at the type level; (4) a function csum with type: takes a sequence of 32 unsigned values each of width logw bits and returns an unsigned value of width logw+5 bits. Implement csum so that it maps each input element to a width-w value by zero-extending it, computes (w minus 1) minus that zero-extended value, then sums the 32 results. Use a list comprehension to produce the 32 transformed values and the built-in sum to aggregate them. Ensure the result type is exactly logw+5 bits and that the subtraction and summation are performed over width-w operands for the mapped terms. Include the parameter block with the constraint on loglogw and the two type aliases, followed by the csum type signature and its definition as described."},{"role":"assistant","content":"```cryptol\nmodule T1802 where\n\nparameter\n  type loglogw : #\n  type constraint (loglogw >= 1, loglogw <= 3)\n\ntype logw = 2^^loglogw\ntype w = 2^^logw\n\ncsum : [32][logw] -> [logw+5]\ncsum msg = sum [`w - 1 - zext msgi | msgi <- msg]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue962a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the following, with clear types, constraints, and point-free forms where applicable: (1) Define f polymorphically over a size parameter and an element type, with the constraint that the size is finite. It takes a sequence of that length of the element type and returns a pair whose first component is the boolean bit true and whose second component is the input sequence unchanged. (2) Define g with the same polymorphic size constraint that returns the second component of f specialized to the given size parameter; its type maps sequences to themselves. (3) Define h as the point-free second projection of f, with its most general type. (4) Define i specialized to bit sequences, mapping sequences of bits of any finite length to themselves via the second component of f specialized to that size. (5) Define j specialized to sequences whose element type is a record containing a field named fld of type Integer; it returns the sequence of those Integer field values by taking the second component of f at that record type and then projecting the fld field from each element. Also include the following verification artifacts: define a property that for all valid lengths and element types, f returns true and the input as its pair; define a property that for all inputs, g returns its input; define a property that h is extensionally equal to g (and thus to the identity) at all valid types; define a property that for all bit sequences, i returns its input; define a property that for all sequences of the specified records, j returns the sequence of fld fields in order."},{"role":"assistant","content":"```cryptol\nf : {a, b} (fin a) => [a]b -> (Bit, [a]b)\nf x = (True, x)\n\ng : {a,b} (fin a) => [a]b -> [a]b\ng x = (f`{a=a} x).1\n\nh = f.1\n\ni : {a} (fin a) => [a] -> [a]\ni = f`{a=a}.1\n\nj : {a} (fin a) => [a]{ fld : Integer } -> [a]Integer\nj = f`{a=a,b={fld : Integer}}.1.fld\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue160.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define six properties named thm1 through thm6 that each return a boolean (Bit) and use rotate-left and rotate-right over fixed-width words as follows: (1) thm1 has type 16-bit word -> Bit and asserts that rotating a 16-bit value by 16 in either direction yields the original value, combining both equalities with boolean conjunction. (2) thm2 has type 16-bit word -> 16-bit word -> Bit and asserts that rotating a 16-bit value right by an arbitrary 16-bit amount equals rotating it right by that amount masked to its low 4 bits with a 16-bit constant whose lower four bits are set and others cleared. (3) thm3 has type 15-bit word -> 8-bit word -> Bit and asserts that rotating left by an 8-bit amount equals rotating left by that amount reduced modulo 15. (4) thm4 has type 15-bit word -> 15-bit word -> Bit and asserts that rotating left by an amount and then right by the same amount returns the original value. (5) thm5 has type 15-bit word -> 3-bit word -> Bit and asserts the same left-then-right cancellation using a 3-bit amount. (6) thm6 has type 8-bit word -> 4-bit word -> 4-bit word -> Bit and asserts that rotating left by one 4-bit amount and then right by another equals rotating left by the modular difference of the two 4-bit amounts, using fixed-width subtraction for the amount expression."},{"role":"assistant","content":"```cryptol\nthm1 : [16] -> Bit\nproperty thm1 x = (x <<< 16 == x) && (x >>> 16 == x)\n\nthm2 : [16] -> [16] -> Bit\nproperty thm2 x i = x >>> i == x >>> (i && 0x000f)\n\nthm3 : [15] -> [8] -> Bit\nproperty thm3 x i = x <<< i == x <<< (i % 15)\n\nthm4 : [15] -> [15] -> Bit\nproperty thm4 x i = x <<< i >>> i == x\n\nthm5 : [15] -> [3] -> Bit\nproperty thm5 x i = x <<< i >>> i == x\n\nthm6 : [8] -> [4] -> [4] -> Bit\nproperty thm6 x i j = x <<< i >>> j == x <<< (i - j)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue148.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function Salsa20_expansion with a polymorphic numeric type parameter constrained so the key multiplier is either 1 or 2. Give it the type: takes a sequence of 16*multiplier bytes (8-bit each) as the key and a sequence of 16 bytes as the nonce, and returns a sequence of 64 bytes. If the multiplier is 2 (32-byte key), use the standard 16-byte Salsa20 constant for the 32-byte-key variant; otherwise use the standard 16-byte constant for the 16-byte-key variant. Split the chosen 16-byte constant into four 4-byte chunks s0, s1, s2, s3. Define k1 and k2 as follows: for a 32-byte key, k1 is the first 16 bytes and k2 is the last 16 bytes; for a 16-byte key, set k1 and k2 both equal to the 16-byte key. Construct the 64-byte output by concatenating s0, k1, s1, the nonce, s2, k2, and s3, in that order. Ensure the type constraints enforce that the multiplier is exactly 1 or 2, and all intermediate values have the correct [n][8] shapes."},{"role":"assistant","content":"```cryptol\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(k, n) = z\n  where\n    [s0, s1, s2, s3] = if (`a == 2) then split(\"expand 32-byte k\")\n                                    else split(\"expand 16-byte k\")\n    k1 = take`{16}(k#zero)\n    k2 = drop`{16}(zero#k)\n    x = s0 # k1 # s1 # n # s2 # k2 # s3\n    z = x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue389.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a size-polymorphic Cryptol function that implements 512-bit block message padding for hashing. The function takes a sequence of bits of some input length and returns a longer sequence formed by concatenating: the original bits, then a single 1 bit, then a run of 0 bits long enough so that after appending a 64-bit representation of the original input length, the total length is a multiple of 512. Quantify three size parameters: the input length, the zero-pad length, and the output length. Constrain them so that: the bit-width of the input length is at most 64; the zero-pad length equals 512 minus ((input length + 65) modulo 512); and the output length equals input length + 65 + zero-pad length. Provide a type signature that maps a bit sequence of the input length to a bit sequence of the output length under these constraints. In the definition, compute the 64-bit value of the original length and include it as the final segment of the concatenation. Also define a second top-level name that is an alias of this function."},{"role":"assistant","content":"```cryptol\npad : {n, m, b} (64>=width(n), b==512-((n+65)%512), m==65+n+b) => [n]->[m]\npad message = (message#[True])#(0:[b])#sz\n     where\n                sz : [64]\n                sz = length message\n\ntest = pad\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue177.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named issue177 that: imports issue177A; imports issue177B as alias B; imports issue177C as alias C; declares a type synonym Byte for an 8-bit sequence; declares constant w of type Byte equal to zero; declares constant x of type Word16 equal to zero; declares constant y with the type Word32 exported by module B equal to zero; and declares constant z as an alias of the value z from module C, preserving its type. Use qualified names for B and C references and provide explicit type signatures for w, x, and y. Do not introduce any additional definitions."},{"role":"assistant","content":"```cryptol\nmodule issue177 where\n\nimport issue177A\nimport issue177B as B\nimport issue177C as C\n\ntype Byte = [8]\n\nw : Byte\nw = zero\n\nx : Word16\nx = zero\n\ny : B::Word32\ny = zero\n\nz = C::z\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1744-2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Bug that imports the Array library and contains the following: (1) Type synonyms: Widget as a 3-bit word, Wombat as a 4-bit word, and Key as a 5-bit word. (2) A newtype Info as a record with one field stuff, which is an Array mapping 5-bit keys to 6-bit words. (3) A function once with type Info -> Key -> Widget -> Wombat -> Info that returns a new Info identical to the input except with stuff updated at the given key to the zero value of the array\u2019s 6-bit range; the additional arguments are accepted but do not affect the update. (4) A function iter with a size parameter n constrained by n < 10 and type Info -> Key -> [n] (Widget, Wombat) -> Info. It constructs a sequence infos whose first element is the initial Info, and whose subsequent elements are produced by zipping prior elements of infos with the entries and applying once using the fixed Key and each pair\u2019s components. Return the first element of infos. (5) A function process with the same n < 10 constraint and type Info -> [n] (Widget, Wombat) -> Info that invokes iter with the Key set to zero. Include all necessary type signatures and use arrayUpdate for the in-place-like update of stuff."},{"role":"assistant","content":"```cryptol\nmodule Bug where\n\nimport Array\n\ntype Widget = [3]\ntype Wombat = [4]\ntype Key = [5]\nnewtype Info = {\n   stuff: Array [5] [6]\n}\n\nonce: Info -> Key -> Widget -> Wombat -> Info\nonce info key widget = info'\n   where\n      info' = Info {\n         stuff = arrayUpdate info.stuff key 0\n      }\n\niter: {n} n < 10 => Info -> Key -> [n] (Widget, Wombat) -> Info\niter info key entries = infos ! 0\n   where\n      infos = [info] # [once info' key widget wombat\n                           | info' <- infos\n                           | (widget, wombat) <- entries]\n\nprocess: {n} n < 10 => Info -> [n] (Widget, Wombat) -> Info\nprocess info entries = iter info 0 entries\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue485a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named issue485a that imports the Float module and contains the following definitions: (1) a private type alias A denoting functions from an 8-bit sequence to an 8-bit sequence; (2) a private type alias ByteFun t denoting functions from an 8-bit sequence to a result of type t; (3) a constant foo of type RoundingMode with the numeric value zero; (4) a function bar with type A that returns its 8-bit argument unchanged (identity over 8-bit values); (5) a function baz with type ByteFun (ByteFun [8]) that represents the curried 8-bit addition operator, i.e., given an 8-bit value, it returns a function that adds another 8-bit value with wraparound modulo 2^8. Provide explicit type signatures, enforce the stated visibility (private for the type aliases, public for the values), and ensure the addition behavior matches 8-bit modular arithmetic."},{"role":"assistant","content":"```cryptol\nmodule issue485a where\n\nimport Float\n\nprivate type A = [8] -> [8]\n\nprivate type ByteFun t = [8] -> t\n\nfoo : RoundingMode\nfoo = 0\n\nbar : A\nbar x = x\n\nbaz : ByteFun (ByteFun [8])\nbaz = (+)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1324.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares two record type synonyms: the first has exactly one field that is an 8-bit word, and the second has exactly one field that is a 16-bit word. Define a function with an explicit type signature that takes a value of the first record type and returns the unit value, implemented by ignoring its argument. Then define a second function with an explicit type signature that takes a value of the second record type and returns the unit value, and define this second function to be equal to (i.e., an alias of) the first function. Include the type synonyms, both function type signatures, and the function definitions exactly as described, using unit as the return value."},{"role":"assistant","content":"```cryptol\ntype T = { a: [8] }\ntype S = { a: [16] }\n\nf : T -> ()\nf _ = ()\n\ng : S -> ()\ng = f\n```"}]}
{"filename":"cryptol\/tests\/issues\/trac289.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the following and proves their relationships: (1) Six functions named average33, average1, average2, average3, average4, and average5, each with type [32] -> [32] -> [32], operating on unsigned 32-bit words. average33 computes a safe average by zero-extending both inputs to 33 bits, adding them, dividing by 2, then discarding the extra high bit to return a 32-bit result. average1 returns (x + y) divided by 2 using 32-bit arithmetic. average2 returns (x\/2) + (y\/2) plus 1 iff both inputs are odd, else 0. average3 returns (x + y) logically right-shifted by 1. average4 returns (x >> 1) + (y >> 1) plus 1 iff both inputs\u2019 least significant bits are 1, else 0. average5 returns lo + ((hi - lo) >> 1), where lo is the minimum and hi is the maximum of the inputs. (2) Properties av1, av2, av3, av4, and av5 that, for all 32-bit x and y, assert average33 equals average1, average2, average3, average4, and average5 respectively. (3) A property applesOranges that, for all 32-bit x and y, asserts average4 equals average5. Include necessary type signatures and ensure division and shifts are interpreted on unsigned words."},{"role":"assistant","content":"```cryptol\naverage33 : [32] -> [32] -> [32]\naverage33 x y = drop`{1}(z'\/2)\n    where\n          z' : [33]\n          z' = (0b0 # x) + (0b0 # y)\n\naverage1 : [32] -> [32] -> [32]\naverage1 x y = (x + y)\/2\n\naverage2 : [32] -> [32] -> [32]\naverage2 x y = x\/2 + y\/2 + (x%2 && y%2)\n\naverage3 : [32] -> [32] -> [32]\naverage3 x y = (x + y) >> 1\n\naverage4 : [32] -> [32] -> [32]\naverage4 x y =    (x >> 1) + (y >> 1) + (x && y && 1)\n\naverage5 : [32] -> [32] -> [32]\naverage5 x y = lo + ((hi - lo)>>1) where\n    lo = min x y\n    hi = max x y\n\nproperty av1 x y = average33 x y == average1 x y\nproperty av2 x y = average33 x y == average2 x y\nproperty av3 x y = average33 x y == average3 x y\nproperty av4 x y = average33 x y == average4 x y\nproperty av5 x y = average33 x y == average5 x y\n\nproperty applesOranges x y = average4 x y == average5 x y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue214.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol function named bm that reorders an input sequence by grouping even-indexed elements first, followed by odd-indexed elements. Make it polymorphic over the element type and parameterized by a natural r that is finite and at least 1. Provide the type signature so that, for any element type and such r, the function maps a sequence of length twice r to a sequence of the same length and element type. Implement the body by selecting the subsequence of elements at all even positions (from the first element to the last even position) and concatenating it with the subsequence of elements at all odd positions (from the second element to the last odd position), both in increasing index order. Use selection by a list of indices and sequence concatenation primitives. Ensure the output preserves the relative order within the even group and within the odd group, and that the length and element type are unchanged."},{"role":"assistant","content":"```cryptol\nbm : {r} (fin r, r >= 1) => [2*r] -> [2*r]\nbm B = (B @@ [0,2..2*r-2]) # (B @@ [1,3..2*r-1])\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue614.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares two polymorphic functions with explicit size parameters and constraints. First, define a function named f with size parameters m, n, k, constrained so that n equals the maximum of the three numbers 2, m, and k, and that this maximum is also equal to m plus 1. Give f a type that takes a single m-bit word and returns a sequence of length k where each element is an n-bit word. Implement f so it ignores its input and produces the all-zero value of the result type (a k-length sequence of n-bit zeros). Second, define a function named g with size parameters n and k, requiring both sizes to be finite and satisfying 0 < n \u2264 k. Give g a type that maps an n-bit word to a k-bit word, and implement g to return the sign-extended form of its input to width k. Include all necessary constraints in the type signatures and provide the function bodies accordingly."},{"role":"assistant","content":"```cryptol\nf : {m, n, k} (n == max 2 m k == m + 1) => [m] -> [k][n]\nf x = zero\n\ng : {n, k} (fin n, fin k, 0 < n <= k) => [n] -> [k]\ng x = sext x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue416.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol definitions for two functions with an implicit size parameter that is a finite natural whose bit-width is at most three. Both functions must return a sequence of exactly three numbers constructed by the arithmetic progression whose first term is 1, whose second term is the value of that size parameter, and whose final term is 7 (inclusive). Give the first function an explicit type where the element bit-width equals the computed length of that progression (use the built-in operator that computes the number of elements in a from\u2013then\u2013to enumeration based on the first, second, and final terms). Give the second function an explicit, more general type where the outer sequence length is three but the element bit-width is left polymorphic\/unspecified. Implement both function bodies by constructing that enumeration. State the constraints on the size parameter in the type signatures, and ensure the same enumeration is used in both bodies."},{"role":"assistant","content":"```cryptol\nf : {n} (fin n, 3 >= width n) => [lengthFromThenTo 1 n 7][3]\nf = [1, n .. 7]\n\ng : {n} (fin n, 3 >= width n) => [_][3]\ng = [1, n .. 7]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue364.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares: (1) a constant x with type [64], defined as the deterministic output of the Cryptol random function when seeded with the integer 123; (2) a constant x_val with type [64], set to the known expected 64-bit result corresponding to that same seed; (3) a property x_eval that checks x equals x_val; (4) a property x_distinct that checks x is not equal to the 64-bit zero value; (5) a property moderately_bogus_property that takes an argument seed of type [8] and checks that, when forming a larger seed by sequence-concatenating a zero-valued prefix with the 8-bit seed and passing it to the random function, the resulting [64]-bit value is not equal to the 64-bit zero value. Use explicit [64] type annotations for x, x_val, and any zero literal compared against them, and specify the [8] type for the property argument. Do not implement any additional functions beyond these declarations."},{"role":"assistant","content":"```cryptol\nx : [64]\nx = random 123\n\nx_val : [64]\nx_val = 0xe4f7c1740def67df\n\nproperty x_eval = x == x_val\nproperty x_distinct = ~ (x == zero)\n\nproperty moderately_bogus_property (seed:[8]) =\n  ~(random (zero#seed) == (0:[64]))\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue826.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol function named WStep with a polymorphic type: for any finite natural n with n \u2265 2, it takes (1) a block cipher function from 128-bit to 128-bit, (2) an n-element sequence of 64-bit words representing state, and (3) a 64-bit word used as a mask\/tweak, and returns an n-element sequence of 64-bit words. The function\u2019s behavior: interpret the state as a head element and a nonempty tail. Concatenate the head and the first element of the tail to form a 128-bit value (head in the upper 64 bits), apply the cipher to obtain a 128-bit result, and split that result into upper and lower 64-bit halves. XOR the upper half with the 64-bit mask to produce the new head. Form the new tail by removing the first element from the original tail and appending the lower half to the end. Return the updated state as the new head followed by the new tail. Provide a type signature that enforces finiteness of n and the constraint n \u2265 2, and ensure all bit widths and sequence lengths match these roles."},{"role":"assistant","content":"```cryptol\nWStep:\n    {n}\n    (fin n, n >= 2) ->\n    ([128] -> [128]) -> [n][64] -> [64] -> [n][64]\nWStep CIPHk ([A] # Rs) t = [A'] # Rs'\n  where\n    [MSB, LSB] = split (CIPHk (A # head Rs))\n    A'         = MSB ^ t\n    Rs'        = tail Rs # [LSB]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue212.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define three Cryptol declarations with precise polymorphic type signatures and bodies:\n- A value named width_eq_geq parameterized by a numeric type variable n, constrained so that the bit-width of n equals 32 and n is at least 1. Its type is an n-length sequence of bits. Its value is an n-element sequence with every bit set to true (construct via a comprehension producing exactly n elements).\n- A value named can_not_width parameterized by a numeric type variable n, constrained so that the bit-width of 8\u00b7(n+1) is at most 64. Its type is a 64-bit sequence. Its value is formed by concatenating a prefix of zeros with the value-level encoding of n as an unsigned bit-vector whose width equals the bit-width of n, so that the total length is exactly 64 bits.\n- A function named take_knows_no_bounds parameterized by a numeric type variable n, constrained to be finite and at least 4. It takes a sequence of n bytes and returns a sequence of bytes whose length is k = 4 \u2212 (n mod 4). Implement it by taking the first k elements of the input using a type-level length parameter equal to k. Ensure all constraints appear in the type signatures and the result lengths match the described expressions."},{"role":"assistant","content":"```cryptol\nwidth_eq_geq : {n} (32 == width n, n >= 1) => [n]Bit\nwidth_eq_geq = [True | _ <- [1..n] : [_][32] ]\n\ncan_not_width : {n} (64 >= width (8*(n+1))) => [64]\ncan_not_width = zero # (`n : [width n])\n\ntake_knows_no_bounds : {n} (fin n, n >= 4) => [n][8] -> [4 - (n%4)][8]\ntake_knows_no_bounds ns = foo\n where\n foo = take `{4 - (n%4)} ns\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1024b.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Create a Cryptol specification that introduces a constraint synonym with two parameters\u2014a type and a proposition\u2014that expands to require the type has a zero element, supports comparison, and satisfies the given proposition. Then declare a polymorphic, argumentless definition with an explicit type signature that quantifies one type variable and requires that synonym instantiated with the proposition asserting the type supports bitwise logical operations. Implement the definition to return the bitwise complement of the zero value of that type."},{"role":"assistant","content":"```cryptol\ntype constraint PredSyn (a : *) (p:Prop) = (Zero a, Cmp a, p)\n\nsomeFunc : {a} (PredSyn a (Logic a)) => a\nsomeFunc = ~zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/T1440.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named T1440 that contains the following submodule structure and imports:\n- Import an interface submodule named X.\n- Import a regular submodule named Y.\n- Declare an interface submodule I that exports one size parameter n of kind # (no values or constraints beyond its kind).\n- Declare a submodule M whose only content is importing the interface submodule I.\n- Declare a submodule N that defines a single value x equal to the numeric literal 2 (leave its type to default inference, or choose a concrete finite word type if required).\n- Define a submodule M1 as an alias or instantiation based on submodule M that includes a nested submodule named U1 in its body.\n- Define a submodule M2 as an alias or instantiation based on a submodule named U2 that includes submodule N in its body.\nEnsure all constructs use valid Cryptol syntax for interface submodules, submodule imports, and submodule alias\/instantiation with nested submodule inclusion. Do not introduce additional bindings, properties, or exports beyond those listed."},{"role":"assistant","content":"```cryptol\nmodule T1440 where\n\nimport interface submodule X\n\nimport submodule Y\n\ninterface submodule I where\n  type n : #\n\nsubmodule M where\n  import interface submodule I\n\nsubmodule N where\n  x = 2\n\nsubmodule M1 = submodule M { submodule U1 }\nsubmodule M2 = submodule U2 { submodule N }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue368.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares a total function taking two 8-bit sequences as inputs and returning an 8-bit sequence, ignoring both inputs and always producing the all-zero 8-bit value. Then introduce two arbitrary 8-bit variables and add multiple top-level equations that, for a broad variety of binary operators (including arithmetic, bitwise, concatenation, and other symbolic forms), state that applying each operator to these two variables yields the same result as invoking the function on the same variables. Clearly specify the types of the function and variables, and make each equation compare the operator application to the function call using the same pair of variables."},{"role":"assistant","content":"```cryptol\nmyFun : [8] -> [8] -> [8]\nmyFun a b = 0\n\nx + y = myFun x y\nx * y = myFun x y\nx - y = myFun x y\nx ~ y = myFun x y\nx ^^ y = myFun x y\nx ++ y = myFun x y\nx .+ y = myFun x y\nx +. y = myFun x y\nx !+ y = myFun x y\nx +! y = myFun x y\nx .! y = myFun x y\nx :+ y = myFun x y\nx =+ y = myFun x y\nx .: y = myFun x y\nx :+: y = myFun x y\nx +:: y = myFun x y\nx ^^^ y = myFun x y\nx .... y = myFun x y\nx +x .\n```"}]}
{"filename":"cryptol\/tests\/issues\/T146.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the following in Cryptol with precise polymorphic record constraints and implementations: (1) a function that, for any element type, takes a record containing a field named v0 of that element type and returns that element; (2) a function that, for any element type, takes a record containing a field named field whose value is a record with a v0 field of that element type, and returns that element; (3) a function that, given a record f meeting the first function\u2019s requirement, constructs and returns a record c with fields: field set to f, v1 set to the result of applying the first function to f, and v2 set to the result of applying the second function to c itself. Provide explicit type signatures expressing the required record fields and ensure v1 and v2 have exactly the same type as f.v0. Do not add or rename fields."},{"role":"assistant","content":"```cryptol\nmk_curve_ops f = undefined\n  where\n    c = { field = f\n        , v1    = ec_v1 f\n        , v2    = ec_v2 c\n        }\n\nec_v1 : {fv} { v0: fv } -> fv\nec_v1 = undefined\n\nec_v2 : {fv} _ -> fv\nec_v2 p = p.field.v0\n  where _ = p.field.v0\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1024a.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two type synonyms and one polymorphic constant. 1) Create a type synonym named Funny that takes one parameter whose kind is a type constructor from numeric kinds to value types; the synonym must equal the built-in arbitrary-precision integer type. 2) Create a type synonym named Strange that takes one parameter of proposition\/constraint kind; this synonym must also equal the arbitrary-precision integer type. 3) Declare a constant named funnyFunc with a type signature that universally quantifies: a numeric type variable, a type-constructor variable of kind from numeric kinds to value types, and a value type variable. The result type must be the arbitrary-precision integer type. Provide a definition for this constant that evaluates to the additive identity for integers. Include explicit kind annotations for all quantified variables and for the parameters of the two type synonyms."},{"role":"assistant","content":"```cryptol\ntype Funny (f : # -> *) = Integer\ntype Strange (f : Prop) = Integer\n\nfunnyFunc : { i : #, f : # -> *, g : * } Integer\nfunnyFunc = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue225.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named EnigmaBroke that contains the following definitions: (1) a type alias for a rotor as a 26-element sequence of pairs, each pair consisting of a character and a bit; (2) a total polymorphic function with a finiteness constraint that takes a 26-element sequence of characters and a sequence of some finite-width type and returns a rotor, ignoring its inputs and producing the zero value of the rotor type; (3) a function that takes a bit, a character, and a rotor and returns a triple of bit, character, and rotor, producing the zero value of that triple type; (4) a function parameterized by a finite size that takes a sequence of that many rotors and an input character and returns a pair of a same-length rotor sequence and a character. Specify that this function constructs an initial rotor from the contiguous uppercase alphabet and an empty sequence using the earlier constructor; seeds a sequence of triples with a fixed-true bit, the input character, and the initial rotor; then extends this sequence by iterating over the input rotors in order, at each step invoking the scrambling function with the previous triple\u2019s bit and character and the current rotor. State that the returned rotor sequence is the tail of the rotor components extracted from the constructed triple sequence, and the returned character equals the character from the initial triple (i.e., the input character). Include finiteness constraints on size parameters, and describe the use of sequence concatenation, list comprehension with parallel generators, element selection by index, and tail extraction."},{"role":"assistant","content":"```cryptol\nmodule EnigmaBroke where\n\ntype Rotor       = [26](Char, Bit)\n\nmkRotor : {a} (fin a) => ([26]Char,[a]) -> Rotor\nmkRotor (_,_) = zero\n\nscramble : (Bit, Char, Rotor) -> (Bit, Char, Rotor)\nscramble (_,_,_) = zero\n\njoinRotors : {n} (fin n) => ([n]Rotor, Char) -> ([n]Rotor, Char)\njoinRotors (rotors, inputChar) = (rotors', outputChar)\n  where\n    initRotor = mkRotor (['A' .. 'Z'], [])\n    \/\/ ncrs : [n+1](Bit, [8], Rotor)\n    ncrs = [(True, inputChar, initRotor)]\n               # [ scramble (notch, char, r)\n                 | r <- rotors\n                 | (notch, char, rotor') <- ncrs\n                 ]\n    rotors' = tail [ r | (_, _, r) <- ncrs ]\n    (_, outputChar, _) = ncrs ! 0\n```"}]}
{"filename":"cryptol\/tests\/issues\/Issue796.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Issue796 that conforms to the existing signature Issue796_Sig and contains the following definitions. Include a numeric type parameter k of kind #. Declare type aliases: Key as a sequence of (8*k) bits, Block as a 64-bit sequence, and RoundKey as a 64-bit sequence. Provide explicit type signatures and implementations for three functions: (1) aux takes a RoundKey and a Block and returns a Block; implement it to produce the all-zero 64-bit block. (2) key_schedule takes a Key and returns a RoundKey; implement it to produce the all-zero 64-bit round key. Inside key_schedule, add a local binding that partitions the input key into groups of four elements solely to enforce that the key\u2019s length is compatible with grouping by four; the grouped value may be ignored. (3) encrypt_block takes a Key and a Block and returns a Block, computed by applying aux to the round key produced by key_schedule and the provided plaintext block. Ensure all type signatures match these descriptions and that encrypt_block composes key_schedule and aux as specified."},{"role":"assistant","content":"```cryptol\nmodule Issue796 = Issue796_Sig where\n\nparameter\n  type _k: #\n\ntype Key = [8 * _k]\ntype Block = [64]\ntype RoundKey = [64]\n\naux : RoundKey -> Block -> Block\naux RK P = zero\n\nkey_schedule K = zero\n  where\n    _ = [ groupBy`{4} K ]\n\nencrypt_block key pt = aux (key_schedule key) pt\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue581.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two polymorphic functions named foo and bar with explicit type signatures parameterized by size variables i and j, constrained so that both are finite and j is at least 1. Each function returns a sequence of 32-bit words. The result length of foo must be the type-level integer quotient obtained when dividing i by j, and the result length of bar must be the corresponding type-level remainder from dividing i by j. Implement both functions by producing the first N elements of a monotonically increasing sequence of natural numbers starting at zero, where N is determined as above for each function, ensuring the element type is a 32-bit unsigned word and only the length depends on i and j."},{"role":"assistant","content":"```cryptol\nfoo : {i, j} (fin i, fin j, j >= 1) => [i \/^ j][32]\nfoo = take [0...]\n\nbar : {i, j} (fin i, fin j, j >= 1) => [i %^ j][32]\nbar = take [0...]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue185.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol function named group that partitions a flat sequence into fixed-size chunks. Provide a polymorphic type with size parameters perGroup, a, b, c and constraints: perGroup is finite, and c equals perGroup multiplied by a. The function must take a sequence of length c of elements of type b and return a sequence of length a where each element is a sequence of length perGroup of type b. Implement the body by splitting the input into consecutive, non-overlapping chunks of size perGroup, preserving the original order, with no padding or truncation. Include the complete type signature with the numeric equality and finiteness constraints, and the function definition that realizes this partitioning behavior."},{"role":"assistant","content":"```cryptol\ngroup : {perGroup, a, b, c} (fin perGroup, c == perGroup * a)\n    => [c]b -> [a][perGroup]b\ngroup xs = split`{each=perGroup}xs\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue187.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Enigma that contains the following definitions: (1) a polymorphic value enigmaLoop with a type that, for any finite size n, yields a sequence of n bits; (2) a function enigma with a type that, for any finite sizes n and m, takes a pair whose first element is a sequence of n bits and whose second element is a sequence of m bits, and returns a sequence of m bits. Implement enigma so that it ignores the actual bit values and produces an output sequence of length m consisting entirely of True, derived by discarding an initial seed element from a stream of pairs and keeping only the second components. Include a property that universally quantifies over n, m, and all inputs of the specified types, and checks that the result of enigma equals a sequence of True values whose length matches the length of the second input. Clearly state the finiteness constraints on n and m, name all parameters, and provide explicit type signatures for both definitions and the property."},{"role":"assistant","content":"```cryptol\nmodule Enigma where\n\nenigmaLoop : {n}(fin n) => [n]\nenigmaLoop = undefined\n\nenigma : {n, m} (fin n, fin m) => ([n], [m]) -> [m]\nenigma (m, pt) = tail [ True | _ <- rcs ]\n  where rcs = [ (m, True)] #\n              [ (enigmaLoop, True)\n              | _     <- pt\n              | (_,_) <- rcs\n              ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1511.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named M that contains the following definitions: (1) a newtype MOOD_t as a record with a single field named value of type [1]; (2) a constant MOOD that is a record with fields HAPPY and SAD, each of type MOOD_t, where HAPPY is constructed with value set to the one-bit constant 1 and SAD is constructed with value set to the one-bit constant 0; (3) a constant v of type [1] that is equal to the value field of the SAD entry within MOOD. Use record construction and field selection so that v references the nested field from MOOD.SAD, and ensure all names and types match exactly."},{"role":"assistant","content":"```cryptol\nmodule M where\n\nv: [1]\nv = MOOD.SAD.value\n\nnewtype MOOD_t = { value: [1] }\n\nMOOD = { HAPPY = MOOD_t { value = 0b1 }\n       , SAD   = MOOD_t { value = 0b0 }\n       }\n```"}]}
{"filename":"cryptol\/tests\/issues\/trac133.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two functions named example1 and example2 with identical polymorphic type signatures: for a numeric parameter a constrained to 1 <= a <= 2, each takes a sequence of 16*a elements where each element is 8 bits, and returns a sequence of 16 elements of 8 bits. Implement example1 by first creating a zero-filled sequence whose length is 16*(2 \u2212 a), concatenating it before the input, and then dropping the first 16 elements of this concatenation to produce the result (i.e., the last 16 elements of the original input). Implement example2 to produce the same result, but do not explicitly annotate the length of the zero-filled sequence; instead, rely on type inference to determine its length so that the input to the drop operation has total length 32 and the result has length 16. Provide the type signatures and definitions for both functions."},{"role":"assistant","content":"```cryptol\nexample1 : {a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8]\nexample1 k = drop`{16} ((zero : [16*(2 - a)][8]) #k)\n\nexample2 : {a} (a >= 1, 2 >= a) => [16*a][8] -> [16][8]\nexample2 k = drop`{16} (zero # k)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue877.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) declares a polymorphic constant equal to the empty sequence with an explicit zero-length sequence type; (2) declares a finite sequence of Integers with an explicit length parameter; (3) defines three derived constants by selecting a subsequence from the Integer sequence using: (a) an empty index sequence, (b) the result of mapping a truncation function over an empty sequence to produce an empty index sequence, and (c) the result of mapping a lambda that wraps each index in a singleton sequence over an empty sequence (to exercise the nested multi-index form); (4) provides explicit, general type signatures for all constants so the selections are well-typed, including constraints tying index widths to the Integer sequence length and ensuring all indices are within bounds; and (5) includes properties asserting that each of the three selections yields the empty sequence and that all three results are equal to each other. Keep the specification general and polymorphic where possible, using size parameters and necessary numeric constraints, and avoid introducing any behavior beyond these declarations and properties."},{"role":"assistant","content":"```cryptol\na = []\n\nxs : [_] Integer\nxs = [1,2,3]\n\nb = xs @@ []\nc = xs @@ (map trunc [])\nd = xs @@ (map (\\x -> [x]) [])\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue_1812.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define six top-level Cryptol definitions named f, g, ff, gg, jj, and kk with explicit polymorphic size parameter h (subject to the fin h constraint). Specify their sequence lengths using type-level arithmetic as follows: f has length 2^h + (2^h \u2212 2^h) and is defined by specializing g at h; g has length 2^h and is the all-zero sequence. Similarly, ff has length (2^h + 2^h) \u2212 2^h and is defined by specializing gg at h; gg has length 2^h and is the all-zero sequence. Define jj with length 2^(1 + h) \u2212 1 and make it equal to kk specialized at h. For kk, add the additional numeric constraint 2^(1 + h) \u2212 1 \u2265 2^h \u2212 1, give it length (2^h \u2212 1) + 2^h, and define it as the all-zero sequence. Ensure all type signatures state the constraints and sizes precisely, and that the definitions use only specialization (no additional computation) to tie each pair (f,g), (ff,gg), and (jj,kk). Do not introduce properties; just provide type signatures and value definitions consistent with the stated lengths and constraints."},{"role":"assistant","content":"```cryptol\nf : {h} (fin h) => [2^^h + (2^^h - 2^^h)]\nf = g`{h}\n\ng : {h} (fin h) => [2^^h]\ng = zero\n\nff : {h} (fin h) => [(2^^h + 2^^h) - 2^^h]\nff = gg`{h}\n\ngg : {h} (fin h) => [2^^h]\ngg = zero\n\njj : {h} (fin h) => [2 ^^ (1 + h) - 1]\njj = kk`{h}\n\nkk : {h} (fin h, 2 ^^ (1 + h) - 1 >= 2 ^^ h - 1) => [2 ^^ h - 1 + 2 ^^ h]\nkk = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue268.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two constants named xs and vs as sequences of length 10 of pairs of 8-bit words. For xs, introduce a helper infinite stream of such pairs with an explicit infinite-length type annotation; the stream is corecursively defined with a fixed head pair and a tail produced by a comprehension over the stream\u2019s own tail (after dropping one element), where each new pair\u2019s first component is a fixed 8-bit constant and the second component is the first component of the source pair. Set xs to the first ten elements of this stream. For vs, define it as the first ten elements of a self-referential stream that is the fixpoint of the same comprehension (no explicit seed). Ensure both definitions type-check, use pair pattern matching in the comprehension, and that the resulting 10-element sequences are extensionally equal."},{"role":"assistant","content":"```cryptol\nxs : [10]([8],[8])\nxs = take `{10} zs\n  where\n  zs : [inf]([8],[8])\n  zs = [(0,0)] # [ (0, z) | (z,_) <- drop `{1} zs]\n\nvs : [10]([8],[8])\nvs = take `{10} zs where zs = [ (0, z) | (z,_) <- zs]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue731.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains the following definitions: (1) a type-constraint alias C1 over a single numeric parameter n that requires n to be finite and at least 1; (2) a type-constraint alias C2 over two constraint parameters p and q that is the conjunction of p and q; (3) a type-constraint alias C3 over two numeric parameters i and j that uses C2 to require both i and j are finite; (4) a type-constraint alias C4 over two numeric parameters a and b that encodes equality by requiring a \u2264 b and a \u2265 b. Do not define any values or functions; only provide these constraint aliases, suitable for reuse in type signatures."},{"role":"assistant","content":"```cryptol\nmodule issue731 where\n\ntype constraint T n = (fin n, n >= 1)\n\ntype constraint Both p q = (p, q)\n\ntype constraint Fin2 i j = Both (fin i) (fin j)\n\ntype constraint i <=> j = (i <= j, i >= j)\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1562.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Create a Cryptol specification that defines the following submodule structure: (1) an interface submodule named I that exposes a type alias Zp representing an 8-bit sequence; (2) a submodule F whose contents import the interface submodule I; (3) a submodule M that defines a type alias Empty equal to a single bit; (4) two distinct submodule instances, F1 and F2, each constructed by instantiating F with the submodule argument M using the standard submodule instantiation syntax. Preserve the exact names I, F, M, F1, F2, Zp, and Empty. Do not add any values, functions, constraints, or properties beyond these declarations. Ensure F\u2019s import refers to the interface of I, and ensure both F1 and F2 are separate instantiations that use the same M."},{"role":"assistant","content":"```cryptol\ninterface submodule I where\n  type Zp = [8]\n\nsubmodule F where\n  import interface submodule I\n\nsubmodule M where\n      type Empty = Bit\n\nsubmodule F1 = submodule F { submodule M }\nsubmodule F2 = submodule F { submodule M }\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1210.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines four properties with the following exact types and behaviors: (1) A property named mwe with type: takes a 2-bit value and a sequence of two 1-bit values, returns a boolean bit; it asserts that the first element of the 2-element 1-bit sequence equals that same element left-shifted by a distance equal to zero times the 2-bit input. (2) A property named mwe' with type: takes a 2-bit value and a single 1-bit value, returns a boolean bit; it asserts that the 1-bit value equals itself left-shifted by a distance equal to zero times the 2-bit input. (3) A property named mwe'' with no arguments, returning a boolean bit; within a where-clause bind a 1-bit constant equal to one and a 2-bit constant equal to zero, and assert that the 1-bit constant equals itself left-shifted by the 2-bit constant. (4) A property named bitget with type: takes a 12-bit index and a sequence of 436 elements of 8 bits (bytes), returns a boolean bit; it states that if the index is less than 3488 (the total number of bits), then the zero-extended result of extracting the bit at that index from the addressed byte (select byte at index divided by 8, shift right by the index modulo 8, mask with 1) is equal to a 16-bit constant that is 0x0001 when the bit at that position in the bitstring formed by reversing the bits in each byte and concatenating all bytes is set, and 0x0000 otherwise. Include the precise type signatures and the local bindings for mwe'' exactly as described."},{"role":"assistant","content":"```cryptol\nmwe : [2] -> [2][1] -> Bit\nproperty mwe i r = r@0 == (r@0) << 0*i\n\nmwe' : [2] -> [1] -> Bit\nproperty mwe' i r = r == (r << 0*i)\n\nmwe'' : Bit\nproperty mwe'' = r == (r << i)\n where r = 1:[1]\n       i = 0:[2]\n\nbitget : [12] -> [436][8] -> Bit\nproperty bitget i r = i < 3488 ==> bit_gf == if bit_bit then 0x0001 else 0x0000\n  where bit_gf = (zext (((r@(i\/8)) >> (i%8) ) && 1))\n        bit_bit = (join (map reverse r))@i\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue108.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the function named sum in Cryptol with an explicit type signature: for finite natural parameters a and b, it takes a sequence of length a whose elements are b-bit words and returns a b-bit word. Implement the body by building a running-accumulator sequence that begins with zero and then, for each step, adds the current input element to the current accumulator using modular addition on b-bit words. Construct this accumulator via a zipped comprehension that pairs each input element with the corresponding accumulator value from the self-referential sequence. Return the final accumulated value by selecting the last element of the accumulator sequence. Ensure the type signature includes the fin constraints on a and b and matches the shape [a][b] -> [b]."},{"role":"assistant","content":"```cryptol\nsum : {a,b} (fin a, fin b) => [a][b] -> [b]\nsum xs = ss ! 0\n  where\n    ss = [0] # [ s + x | x <- xs | s <- ss ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue130.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define three functions and one property as follows: (1) A function named parity that takes a sequence of Bits and computes its XOR parity by forming a running state seeded with False and, for each input bit, XORing it with the previous state; return the final state (the last element of the state stream). (2) A function named foldl1 that, for a non-empty sequence, performs a left-associative reduction with a given binary function by seeding the state with the first element and iteratively combining with each subsequent element; return the final state. Make it polymorphic over element type and sequence length, with appropriate constraints to ensure the length is at least one. (3) A function named par defined as the XOR reduction obtained by applying foldl1 with the XOR operator over a sequence of Bits. Finally, define the property named parOK with a polymorphic size parameter n constrained to be finite; it takes a sequence of n+1 Bits and returns a Bit, asserting that for every such input, the result of par equals the result of parity. Include any necessary type quantification and constraints."},{"role":"assistant","content":"```cryptol\nparity xs = ys!0\n  where ys = [False] # [y ^ x | x <- xs | y <- ys ]\n\nfoldl1 f xs = ys!0\n  where ys = [xs@0] # [ f y x | y <- ys | x <- tail xs ]\n\npar = foldl1 (^)\n\nparOK : {n} (fin n) => [n+1] -> Bit\nproperty parOK x = par x == parity x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1798.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define two functions named exhaustive1 and exhaustive2 with explicit type signatures and guarded equations. Both are polymorphic over a numeric size parameter w. For exhaustive1: its type takes and returns a bitvector whose length is 2^(2^w). Implement it with two guards that depend only on the numeric length expression: (a) when 2^(2^w) < 2, return the input unchanged; (b) when 2^(2^w) == 2, return the bitwise complement of the input. Do not include any default or else case. For exhaustive2: its type takes and returns a bitvector whose length is 2^w. Implement it with a single guard: when 2^w == 1, return the bitwise complement of the input. Again, do not include a default case. Use Cryptol\u2019s numeric exponentiation for length calculations and the word-level complement operator. State the polymorphic constraint on w and ensure the guards are purely numeric constraints over w, not dependent on the input value."},{"role":"assistant","content":"```cryptol\nexhaustive1 : {w} [2 ^^ (2 ^^ w)] -> [2 ^^ (2 ^^ w)]\nexhaustive1 x\n  | (2 ^^ (2 ^^ w)) < 2 => x\n  | (2 ^^ (2 ^^ w)) == 2 => ~ x\n\nexhaustive2 : {w} [2 ^^ w] -> [2 ^^ w]\nexhaustive2 x\n  | (2 ^^ w) == 1 => ~ x\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue093.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that includes the following: - A property named t0 that evaluates to true unconditionally. - A property named t1 that, for all 32-bit words x, asserts x is equal to the same value when explicitly viewed as a 32-bit word. - A property named t2 that, for all 32-bit words x and y, states: if x (as a 32-bit word) is less than y (as a 32-bit word), then y is not the all-zero 32-bit value; otherwise the condition holds trivially. - A Boolean constant named not_a_prop set to true (do not declare it as a property). - A property named f0 that evaluates to false unconditionally. Provide explicit type signatures: t0 and f0 are Boolean properties with no arguments; t1 has type [32] -> Bit; t2 has type [32] -> [32] -> Bit; not_a_prop has type Bit. Do not include implementations or proofs; only specify the declarations and their intended behavior in comments if needed."},{"role":"assistant","content":"```cryptol\nproperty t0 = True\nproperty t1 x = x == (x : [32])\nproperty t2 x y = if (x : [32]) < (y : [32]) then y != zero else True\nnot_a_prop = True\nproperty f0 = False\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue723.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a property named prop_f_selfXorIsZero that, for any finite width n and any input x of length n, asserts that calling f on x yields the all-zero bitvector of length n (i.e., the bitwise XOR of x with itself). Quantify n with a fin constraint and x with type [n], and express the expected result using the zero value of type [n]. Ensure the property is suitable for checking with a SAT solver."},{"role":"assistant","content":"```cryptol\nf : {n} (fin n) => [n] -> [n]\nf x = g x\n  where\n    m1 = x\n\n    g : {k} (fin k) => [k] -> [k]\n    g m0 = m0 ^ m1\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue494.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) adds a polymorphic type signature to the second function so it accepts two sequences of equal length of 32-bit words and returns a single bit, with a constraint that the length parameter is finite; (2) defines its behavior as returning the first element of a self-referential left-to-right scan that starts with False and, for each aligned pair of input elements and the prior scan state, updates the state as the disjunction of the prior state with the comparison of the current left element being greater than the current right element; and (3) introduces a universally quantified verification condition that, for all admissible lengths and all input pairs, the two functions are extensionally equal (produce the same bit). Clearly name the functions and the verification artifact, and state all quantified variables and constraints in the type and the verification condition."},{"role":"assistant","content":"```cryptol\ngt_words : {a} (fin a) => [a][32] -> [a][32] -> Bit\ngt_words l0 l1 = ss!0\n  where\n    ss = [ False ] # [ s \\\/ (i > j) | i <- l0 | j <- l1 | s <- ss ]\n\ngt_words' l0 l1 = ss!0\n  where\n    ss = [ False ] # [ s \\\/ (i > j) | i <- l0 | j <- l1 | s <- ss ]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue734.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write Cryptol declarations that: (1) define a polymorphic function f parameterized by a finite natural a; its type accepts a bitvector whose length is 2^a \u2212 1 and returns a bitvector whose length is 3\u00b7(2^a \u2212 1); its definition is the input value concatenated with itself three times. (2) define a polymorphic constant asdf1 parameterized by a finite natural r with the constraint that the width of 2^r equals r+1; its type is a bitvector of length r+1, and its value is exactly the number 2^r represented at that width. (3) define a polymorphic constant asdf2 parameterized by a finite natural r with the constraint that the width of (2^r \u2212 1) equals r; its type is a bitvector of length r, and its value is exactly the number (2^r \u2212 1) represented at that width. Include the precise Cryptol type signatures with these constraints and the corresponding definitions only."},{"role":"assistant","content":"```cryptol\nf : {a} (fin a) => [2^^a - 1] -> [3*(2^^a - 1)]\nf x = x # x # x\n\nasdf1 : {r} (fin r, width (2^^r)==r+1) => [r+1]\nasdf1 = `(2^^r)\n\nasdf2 : {r} (fin r, width(2^^r-1)==r) => [r]\nasdf2 = `(2^^r-1)\n```"}]}
{"filename":"cryptol\/tests\/issues\/Issue883_A.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Issue883_A that contains the following definitions: (1) a numeric type parameter c declared in a parameter section with constraints that c is finite, c \u2265 1, and the bit-width of (c \u2212 1) is at most 64; (2) a polymorphic function dumbHash with a type parameter n, requiring n to be finite and its bit-width \u2264 64, that takes an n-bit sequence and returns a 128-bit sequence, always producing an all-zero 128-bit value irrespective of the input; (3) a polymorphic function asdf with a type parameter n, requiring n to be finite, the bit-width of n + 192 \u2264 64, and the bit-width of 128 \u00d7 c \u2264 64, that takes an n-bit sequence and returns a 128-bit sequence; inside asdf, define a local value ys as an array of length c + 1 whose elements are 128-bit zeros, drop the first element of ys, concatenate the remaining 128-bit blocks into a single sequence, and pass that sequence to dumbHash, returning its result; (4) include explicit type signatures for dumbHash, asdf, and ys, and use Cryptol primitives for dropping exactly one element and for concatenating an array of fixed-size blocks into a flat bitvector. Do not prove any properties; just provide the module, parameters, constraints, and function bodies as specified."},{"role":"assistant","content":"```cryptol\nmodule Issue883_A where\nparameter\n    type c : #\n    type constraint ( fin c, c >= 1, 64 >= width (c-1) )\n\ndumbHash : {n} (fin n, 64 >= width n) => [n] -> [128]\ndumbHash msg = zero\n\nasdf : {n} (64 >= width (n+192), 64 >= width (128 * c), fin n) => [n] -> [128]\nasdf msg = dumbHash (join (drop`{1} ys))\n where\n   ys : [c+1][128]\n   ys = zero\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue640.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines three functions with explicit type signatures and self-referential constructions: (1) a function that takes a single bit and returns two bits by defining its result as the input concatenated with the first element of its own result (accessed via indexing); (2) a function with the same type and behavior, but instead of indexing, obtain the first element by taking a one-element prefix of its own result; and (3) a function that takes a length-1 sequence of 8-bit words and returns a length-2 sequence of 8-bit words using the same one-element-prefix approach. Also, define a property that, for all single-bit inputs, the first two functions produce identical outputs. Define another property that, for all length-1 sequences of 8-bit words, the third function\u2019s output consists of two copies of the sole input element in order. Use clear, distinct function names of your choice, and ensure the definitions use concatenation as described. Include no additional preconditions or assumptions."},{"role":"assistant","content":"```cryptol\nf : [1] -> [2]\nf x = out\n  where out = x # [out@0]\n\ng : [1] -> [2]\ng x = out\n  where out = x # (take out)\n\nh : [1] [8] -> [2] [8]\nh x = out\n  where out = x # take out\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/mergesort.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define two functions and one property implementing and checking a mergesort. Provide a polymorphic type signature for sort that, for any finite sequence length n and element type a with a comparison constraint, maps a sequence of length n to a sequence of the same length. Implement sort so that if the length is at most 1 it returns the input unchanged; otherwise it splits the input into a left half of floor(n\/2) elements and a right half of the remaining elements, recursively sorts both halves, and combines them with merge. Provide a polymorphic type signature for merge that, for any lengths m and n and comparable element type a, takes sequences of lengths m and n and returns a sequence of length m+n. Implement merge so that if one input is empty it returns the other; otherwise, decompose each input into head and tail, compare the heads, prepend the smaller (preferring the left element when equal) to the recursive merge of the corresponding tail with the other sequence. Use guards on the size parameters for the base cases. Finally, define the property sort_correct that asserts, as a conjunction of equalities, that applying sort to a diverse set of concrete integer sequences (including empty, singleton, and lists with negatives and duplicates) yields the expected ascending nondecreasing sequences for those examples."},{"role":"assistant","content":"```cryptol\nsort : {n,a} Cmp a => (fin n) => [n]a -> [n]a\nsort xs\n  | n <= 1 => xs\n  | ()     => merge (sort left) (sort right)\n              where (left : [n\/2] _) # right = xs\n\nmerge : {m,n,a} Cmp a => [m]a -> [n]a -> [m+n]a\nmerge xs ys\n  | m == 0  => ys\n  | n == 0  => xs\n  | (m > 0, n > 0) => if x <= y \n                        then [x] # merge restX ys\n                        else [y] # merge xs restY\n                      where\n                      [x] # restX = xs\n                      [y] # restY = ys\n\nproperty sort_correct =\n  (sort [] == []) &&\n  (sort [0] == [0]) &&\n  (sort [-6, 1, 9, -3, -9, 2, 4] == [-9, -6, -3, 1, 2, 4, 9]) &&\n  (sort [4, -8, -1, -7, -5, 9, 8, 8] == [-8, -7, -5, -1, 4, 8, 8, 9]) &&\n  (sort [1, -1, -2, -3, -2, 7, 5] == [-3, -2, -2, -1, 1, 5, 7]) &&\n  (sort [9, 9, 8, -3, 1, 1, -6, -6, -8] == [-8, -6, -6, -3, 1, 1, 8, 9, 9]) &&\n  (sort [9, 1, 5, 0] == [0, 1, 5, 9]) &&\n  (sort [8, 3, 3] == [3, 3, 8]) &&\n  (sort [-7, 8] == [-7, 8])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/nestFun.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol submodule named A parameterized by a numeric size variable n. Inside A, declare a boolean constant f with a type signature and guarded equations based on constraints on n: if n equals zero, f evaluates to true; if n is greater than zero, f evaluates to false. Then instantiate\/import this submodule twice under distinct module aliases: one instance binds n to the numeric value 2, and another instance binds n to the numeric value 0. Ensure the type parameter is declared as a numeric kind, the constant has a Bool type, and the guarded definitions cover the specified constraints without introducing any other bindings."},{"role":"assistant","content":"```cryptol\nsubmodule A where\n\n  parameter\n    type n : #\n\n  f : Bool\n  f | n == 0 => True\n    | n > 0  => False\n\nimport submodule A as Two where\n  type n = 2\n\nimport submodule A as Zero where\n  type n = 0\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/constant.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define the following in Cryptol using constraint-guarded definitions and explicit type signatures: (1) A size-polymorphic constant named isZero with a numeric type parameter n (kind #) returning a single bit. It must yield true when n equals zero and false otherwise. (2) Define a property that validates isZero by checking it is false at an infinite size, true at size 0, and false at sizes 1, 2, 4, 8, and 16. (3) A size-polymorphic constant named isFin with a numeric type parameter n (kind #) returning a single bit. It must yield true when n is finite and false otherwise. (4) Define a property that validates isFin by checking it is false at an infinite size and true at sizes 0, 1, 2, 4, 8, and 16. (5) A size-polymorphic constant named idTypeNum with a numeric type parameter n (kind #) returning an Integer, guarded so it is defined only when n is finite; its value must be the value-level numeral corresponding to n. (6) Define a property that validates idTypeNum by asserting that, when instantiated at sizes 0, 1, 2, 4, 8, and 16, it produces those same integers. Use only properties to express the checks, and ensure each definition\u2019s constraints and kinds are explicit."},{"role":"assistant","content":"```cryptol\nisZero : {n : #} Bit\nisZero | n == 0 => True\n       | ()     => False\n\nproperty isZero_correct =\n  ~isZero `{inf} &&\n   isZero `{  0}   &&\n  ~isZero `{  1}   &&\n  ~isZero `{  2}   &&\n  ~isZero `{  4}   &&\n  ~isZero `{  8}   &&\n  ~isZero `{ 16}\n\nisFin : {n : #} Bit\nisFin | fin n => True\n      | ()    => False\n\nproperty isFin_correct =\n  ~isFin `{inf} &&\n   isFin `{  0}   &&\n   isFin `{  1}   &&\n   isFin `{  2}   &&\n   isFin `{  4}   &&\n   isFin `{  8}   &&\n   isFin `{ 16}\n\nidTypeNum : {n : #} Integer \nidTypeNum | fin n => `n\n\nproperty idTypeNum_correct =\n  (idTypeNum `{ 0}  ==  0) &&\n  (idTypeNum `{ 1}  ==  1) &&\n  (idTypeNum `{ 2}  ==  2) &&\n  (idTypeNum `{ 4}  ==  4) &&\n  (idTypeNum `{ 8}  ==  8) &&\n  (idTypeNum `{16}  == 16)\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/insert.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a polymorphic Cryptol function named insert with the following specification: it takes an element and a sequence of length n over the same orderable type and returns a sequence of length n+1. Constrain n to be finite and the element type to support ordering. The input sequence is assumed nondecreasing. Implement divide-and-conquer insertion with guarded cases: handle n=0 by returning a singleton sequence containing the element; handle n=1 by comparing the element with the sole item and producing the sorted pair. For n>1, split the sequence into a left prefix, a single pivot element, and a right suffix. When n is even, the left has length n\/2\u22121 and the right has length n\/2; when n is odd, both sides have length n\/2. Compare the new element to the pivot. If it is less than or equal to the pivot, recursively insert into the left side after appending the pivot at its end, then concatenate the unchanged right side. Otherwise, keep the left side with the pivot appended at its end and recursively insert into the right side, then concatenate. Use sequence concatenation to assemble results. Provide the exact type: for any finite n and orderable a, the function maps a and [n]a to [n+1]a. Also define a property named insert_correct that is a conjunction of ten equalities, each asserting that inserting one missing integer from 0 through 9 into its corresponding ascending list of the remaining values yields the fully sorted list 0 through 9."},{"role":"assistant","content":"```cryptol\ninsert : {n, a} (fin n, Cmp a) => a -> [n]a -> [n+1]a\ninsert x' xs \n  | n == 0         => [x']\n  | n == 1         => if x' <= x then [x', x] else [x, x']\n                      where [x] = xs\n  | ( n % 2 == 0\n    , n     >  1 ) => if x' <= x \n                        then insert x' (xs1 # [x]) # xs2 \n                        else xs1 # [x] # insert x' xs2\n                      where (xs1 : [n\/2 - 1]_) # [x] # (xs2 : [n\/2]_) = xs\n  | ( n % 2 == 1\n    , n     >  1 ) => if x' <= x \n                        then insert x' (xs1 # [x]) # xs2\n                        else xs1 # [x] # insert x' xs2\n                      where (xs1 : [n\/2]_) # [x] # (xs2 : [n\/2]_) = xs\n\nproperty insert_correct =\n  (insert 0 [  1,2,3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 1 [0,  2,3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 2 [0,1,  3,4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 3 [0,1,2,  4,5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 4 [0,1,2,3,  5,6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 5 [0,1,2,3,4,  6,7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 6 [0,1,2,3,4,5,  7,8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 7 [0,1,2,3,4,5,6,  8,9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 8 [0,1,2,3,4,5,6,7,  9] == [0,1,2,3,4,5,6,7,8,9]) &&\n  (insert 9 [0,1,2,3,4,5,6,7,8  ] == [0,1,2,3,4,5,6,7,8,9])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/len.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a polymorphic Cryptol function named len with the type: for any finite natural n and element type a, it takes a sequence of n elements and returns an Integer. Use constraint guards on n: when n equals zero, return 0; when n is greater than zero, return 1 plus a recursive call on the sequence with its first element removed (drop exactly one element). Ensure termination by decreasing n each step. Then define a property named len_correct asserting, as a conjunction of test cases, that for the empty list and for lists of integers of lengths 1 through 8 (using consecutive literals starting at 1), the result of len equals the result of the built-in sequence-length function on those same lists."},{"role":"assistant","content":"```cryptol\nlen : {n,a} (fin n) => [n] a -> Integer\nlen x\n  | (n == 0) => 0\n  | (n >  0) => 1 + len (drop`{1} x)\n\nproperty \n  len_correct = and\n    [ len l == length l where l = []\n    , len l == length l where l = [1]\n    , len l == length l where l = [1,2]\n    , len l == length l where l = [1,2,3]\n    , len l == length l where l = [1,2,3,4,5]\n    , len l == length l where l = [1,2,3,4,5,6]\n    , len l == length l where l = [1,2,3,4,5,6,7]\n    , len l == length l where l = [1,2,3,4,5,6,7,8]\n    ]\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/tail.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a polymorphic function named tail with an explicit type signature: for any finite size parameter n and element type a, it takes a sequence of length n of a and returns a sequence whose length is (max n 1) minus 1. Implement tail using guarded equations based on the size n: when n equals zero, return the input sequence unchanged; when n is at least one, return the sequence with its first element removed (use the drop operation with count 1). Then define a property named tail_correct that asserts the conjunction of the following behaviors: the tail of an empty sequence is empty; the tail of a singleton sequence is empty; the tail of [1,2] is [2]; the tail of [1,2,3] is [2,3]; and the tail of [1,2,3,4] is [2,3,4]."},{"role":"assistant","content":"```cryptol\ntail : {n, a} (fin n) => [n]a -> [(max n 1) - 1]a\ntail xs | n == 0 => xs\n        | n >= 1 => drop `{1} xs\n\nproperty tail_correct =\n  (tail [] == []) &&\n  (tail [1] == []) &&\n  (tail [1,2] == [2]) &&\n  (tail [1,2,3] == [2,3]) &&\n  (tail [1,2,3,4] == [2,3,4])\n```"}]}
{"filename":"cryptol\/tests\/constraint-guards\/inits.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define Cryptol specifications for: (1) a polymorphic function inits with type parameters n and a, constrained so n is finite, that takes a sequence of length n over a and returns the concatenation of all non-empty initial segments of the input, with result length n*(n+1)\/2. Specify guarded equations: when n is zero return empty; otherwise decompose the input into its first element and remaining suffix and delegate to a loop that builds the result. (2) a helper function initsLoop with type parameters n, l, m, a and constraints fin l, fin m, m >= 1, and l + m = n. It takes three sequences: a remaining suffix of length l, the current prefix of length m, and an accumulator containing the concatenation of prefixes up to length m\u22121 (whose length is (m\u22121)*m\/2). Define guards on l: if l is zero, return the accumulator followed by the current prefix; otherwise split the suffix into head and tail, extend the current prefix by the head, append the previous prefix to the accumulator, and recurse. Also define a property named inits_correct asserting a conjunction of equalities that, for inputs consisting of the first k positive integers for k = 0..5, the output equals the concatenation of prefixes of lengths 1..k, respectively."},{"role":"assistant","content":"```cryptol\ninits : {n, a} (fin n) => [n]a -> [(n * (n+1))\/2]a\ninits xs\n  | n == 0 => []\n  | n >  0 => initsLoop xs' x []\n    where\n      (x : [1]_) # xs' = xs\n\ninitsLoop : {n, l, m, a} (fin l, fin m, l + m == n, m >= 1) =>\n        [l]a -> [m]a ->\n        [((m-1) * ((m-1)+1))\/2]a ->\n        [(n * (n+1))\/2]a\ninitsLoop ys zs acc\n  | l == 0 => acc # zs\n  | l >  0 => initsLoop ys' (zs # y) (acc # zs)\n   where (y : [1]_) # ys' = ys\n\nproperty inits_correct =\n  (inits [] == []) &&\n  (inits [1] == [1]) &&\n  (inits [1,2] == [1,1,2]) &&\n  (inits [1,2,3] == [1,1,2,1,2,3]) &&\n  (inits [1,2,3,4] == [1,1,2,1,2,3,1,2,3,4]) &&\n  (inits [1,2,3,4,5] == [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5])\n```"}]}
{"filename":"cryptol\/tests\/modsys\/T11\/A.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named T11::A that contains the following definitions: (1) two size parameters X and Y, each of kind #; (2) a type synonym T that is a pair where the first element is a sequence of bits of length X and the second element is a sequence of bits of length Y; (3) a function f with type T -> [X] that pattern matches its input pair and returns the first element, ignoring the second. Include the parameter block declaring X and Y with their kinds and the explicit type signature for f."},{"role":"assistant","content":"```cryptol\nmodule T11::A where\n\nparameter\n  type X : #\n  type Y : #\n\ntype T = ([X],[Y])\n\nf : T -> [X]\nf (x,_) = x\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T038.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named T038 that contains the following definitions: (1) an interface submodule I that requires a single 8-bit value named x; (2) a submodule F that is parameterized by any submodule implementing I, imports that interface parameter, and defines an 8-bit value y computed as x plus 1 using modulo-256 arithmetic; (3) a submodule Q that defines x as the 8-bit constant 11; (4) a submodule P that instantiates F with Q (binding F\u2019s interface dependency to Q) and also defines its own x as the 8-bit constant 11; and (5) an interface submodule J that imports F instantiated with P and declares an 8-bit value x. Ensure all x and y values have type [8], the imports correctly express F\u2019s dependency on I, P satisfies F\u2019s dependency via Q, and J reuses F in its context while requiring an 8-bit x. Do not provide implementations beyond these declarations and bindings."},{"role":"assistant","content":"```cryptol\nmodule T038 where\n\ninterface submodule I where\n  x : [8]\n\nsubmodule F where\n  import interface submodule I\n  y = x + 1\n\nsubmodule P where\n  import submodule F { submodule Q }\n  x = 11\n\nsubmodule Q where\n  x = 11\n\ninterface submodule J where\n  import submodule F { submodule P }\n  x : [8]\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T011.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol specification that declares: (1) a submodule A introducing a type alias T for 8\u2011bit words; (2) an interface submodule S that imports A and requires a value x of type T; (3) a submodule F that imports the interface S and defines a value y equal to two times x using modular (wraparound) arithmetic, with y having type T; (4) a concrete submodule I that provides x as the literal 28 with type T; (5) an instantiation M obtained by applying F to I; and (6) an import of submodule M under the same name so its definitions are brought into scope."},{"role":"assistant","content":"```cryptol\nsubmodule A where\n  type T = [8]\n\ninterface submodule S where\n  import submodule A\n  x : T\n\nsubmodule F where\n  import interface submodule S\n\n  y = 2 * x\n\nsubmodule I where\n  x = 28\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T005.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an interface submodule named A that declares a numeric parameter n (finite and at least 1) and a value x that is a bitvector of length n. Define a submodule F that imports two instances of A under aliases X and Y, imposes an interface-level constraint that their numeric parameters are equal, and defines y as the sum of X.x and Y.x with type a bitvector whose length equals X\u2019s numeric parameter. Provide two concrete submodules I and J: I fixes the numeric parameter to 8; J fixes it to 9. In each, define x polymorphically for any ring type that supports the numeric literals 1 and 2, with x computed as the sum of those literals. Instantiate F by binding X to I and Y to J to create a submodule M, and then import M. Ensure the specification precisely encodes the aliasing, constraints, types, and instantiation so that the equality constraint required by F is present despite the differing numeric parameters in I and J."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A as X\n  import interface submodule A as Y\n\n  interface constraint (X::n == Y::n)\n\n  y : [X::n]\n  y = X::x + Y::x\n\nsubmodule I where\n  type n = 8\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule J where\n  type n = 9\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule M = submodule F { X = submodule I, Y = submodule J }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T006.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares an interface submodule A parameterized by a numeric size n (finite, n \u2265 1) and providing a value x of n bits. Define a submodule F that imports A under alias X and imposes an interface constraint that X::n \u2265 3. Within F, define a nested submodule G that imports A, imposes an interface constraint equating X::n with the local n, and defines y as the sum of five times X::x and x, with y having width n. Also in F, define y as five times X::x with width X::n. Provide a concrete submodule I implementing A by fixing n to 8 and defining x as a polymorphic ring element given by the sum of the ring literals 1 and 2, with constraints requiring a ring structure and support for the literals 1 and 2. Instantiate F with I to produce submodule M and import it. Then instantiate the nested G within M using I to produce submodule N and import it. Ensure all type signatures, interface constraints, nested imports, and widths are consistent across submodules."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A as X\n\n  interface constraint (X::n >= 3)\n\n  submodule G where\n    import interface submodule A\n    interface constraint (X::n == n)\n\n    y : [n]\n    y = 5 * X::x + x\n\n  y : [X::n]\n  y = 5 * X::x\n\nsubmodule I where\n  type n = 8\n\n  x : {a} (Ring a, Literal 1 a, Literal 2 a) => a\n  x = 1 + 2\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n\nsubmodule N = submodule M::G { submodule I }\n\nimport submodule N as N\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T012.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models a functor-style submodule pattern: (1) define an interface submodule that imports an external module supplying an abstract numeric type and declares a single value of that type; (2) define a parameterized submodule that depends on that interface and defines a second value equal to twice the interface-provided value using multiplication by the numeric literal 2; (3) define a concrete submodule that implements the interface by assigning the declared value to the numeric literal 28; (4) instantiate the parameterized submodule with the concrete implementation to obtain a concrete submodule, and then import that resulting submodule under an alias. Provide explicit type signatures for the interface value and the derived value, and state any necessary constraints so numeric literals and multiplication are well-typed (for example, the abstract type is a finite unsigned sequence supporting multiplication and wide enough to represent 28). Do not prove any properties; just define the interface, functor, implementation, instantiation, and import."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  import T012_M\n  x : T\n\nsubmodule F where\n  import interface submodule S\n\n  y = 2 * x\n\nsubmodule I where\n  x = 28\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T002.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares an interface submodule named A with a numeric type parameter n of kind #, constrained to be finite and at least 1, and an exported bit-sequence value x of width n. Define a functor-like submodule F that depends on interface A and exports y, a bit-sequence of width n computed as the sum of the literal 1 and x. Provide an implementation submodule I that fixes n to 8 and defines x as the 8-bit encoding of the integer 2. Instantiate F with I to produce a concrete submodule M, and expose M under the same name via an import\/alias. Include explicit type declarations, constraints, and the value definitions so that all widths are statically checked."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 8\n  x = 2 : [n]\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T003.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) declares an interface submodule with a numeric kind parameter representing a bit-width, constrained to be finite and at least one, and an abstract value that is a sequence of exactly that many bits; (2) defines a functor submodule that imports the interface and defines a new value equal to the abstract bitvector plus one using modular addition at the same width; (3) provides a concrete submodule that fixes the width to 8 bits and defines the abstract value as the polymorphic numeric literal 42, using an appropriate literal overloading constraint so it can specialize to an 8-bit sequence; (4) instantiates the functor with the concrete submodule to produce a resulting submodule; and (5) imports the instantiated submodule so its definitions are available in scope. Include explicit type annotations, the numeric kind for the width parameter, the width constraints, and the literal\u2019s overloading constraint."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 8\n\n  x : {a} Literal 42 a => a\n  x = 42\n\nsubmodule M = submodule F { submodule I }\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T001.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an interface submodule named A with one numeric type parameter n (kind numeric) constrained to be finite and at least 1, and declare a value x whose type is a sequence of n bits. Define a functor submodule F that depends on interface A, reusing n and x, and declares a value y with the same width n computed by adding the literal 1 to x. Define an implementation submodule I that fixes n to 0 and provides a value x with width n. Then define a submodule M that applies F to I. The specification must enforce, via the interface constraints, that instantiating F with I is invalid because n = 0 violates n \u2265 1. Include all required type declarations, constraints, and the import of the interface into the functor. Do not provide any solution."},{"role":"assistant","content":"```cryptol\ninterface submodule A where\n  type n : #\n  type constraint (fin n, n >= 1)\n  x : [n]\n\nsubmodule F where\n  import interface submodule A\n\n  y : [n]\n  y = 1 + x\n\nsubmodule I where\n  type n = 0\n  x = x : [n]\n\nsubmodule M = submodule F { submodule I }\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T028.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an interface submodule named S that exports a single 8-bit value x. Define a submodule G that imports S and defines y as x plus 1 using 8-bit modular addition, with y typed as 8 bits. Define a submodule F that imports S and also imports G specialized with the same S, and defines z as x plus y using 8-bit modular addition, with z typed as 8 bits. Finally, instantiate F by importing it with an implementation of S where x is the 8-bit constant 5, so that z is available from the instantiation. Ensure all imports reference the correct interface and that all values are sized consistently as 8 bits."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  x : [8]\n\nsubmodule G where\n  import interface submodule S\n  y = x + 1\n\nsubmodule F where\n  import interface submodule S\n  import submodule G { interface S }\n  z = x + y\n\nimport submodule F where\n  x = 5\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T027.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models functor-style submodules and interface wiring as follows: define an interface submodule that exports a single 8-bit constant. Define a submodule that imports this interface and exports an 8-bit value computed as the interface constant plus one using modular 8-bit addition. Define another submodule that accepts the same interface (aliased locally); within it, define a nested submodule that reuses that alias, imports the previously defined submodule instantiated with that alias, and exports an 8-bit result equal to the sum of the interface constant and the imported derived value (all arithmetic modular over 8 bits). At the top level, instantiate the outer submodule by providing the interface constant with the concrete 8-bit value 5, which exposes the nested submodule as a functor; then instantiate that nested submodule at the top level by providing the interface constant with the concrete 8-bit value 6, bringing its exported result into scope. Include explicit 8-bit type signatures for all exposed values and ensure the imports thread the same interface instance through the nested and dependent submodules."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  x : [8]\n\nsubmodule G where\n  import interface submodule S\n  y = x + 1\n\nsubmodule F where\n  import interface submodule S as A\n\n  submodule H where\n    import interface submodule S as A\n    import submodule G { interface A }\n    z = A::x + y\n\nimport submodule F where\n  x = 5\n\nimport submodule H where\n  x = 6\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T037.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named T037 that contains the following definitions: (1) an interface submodule I exporting a single public value x with 8-bit width; (2) a parameterized submodule F that imports the interface I and defines y as x plus one using 8-bit modular addition; (3) a concrete submodule P that provides an implementation for I by binding x to the 8-bit constant 11; (4) a submodule X that instantiates F with P as submodule M, imports M to re-export its bindings, and defines z equal to y so that z is visible within X; and (5) at the top level of T037, import submodule X so that z is brought into the module scope. Provide explicit type signatures for x, y, and z as 8-bit sequences. Add properties asserting within X that z equals y and y equals x plus one, and at the top level that z equals the 8-bit value 12. Do not include any other bindings or side conditions."},{"role":"assistant","content":"```cryptol\nmodule T037 where\n\ninterface submodule I where\n  x : [8]\n\nsubmodule F where\n  import interface submodule I\n  y = x + 1\n\nsubmodule P where\n  x = 11\n\nsubmodule X where\n  submodule M = submodule F { submodule P }\n  import submodule M\n\n  z = y\n\nimport submodule X\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T012_M.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"In Cryptol, define a module named T012_M that contains the following definitions: a single type alias T representing an 8-bit sequence (a byte). The alias must bind T to the fixed-width sequence type of length 8 bits, with no parameters, constraints, or additional declarations in the module."},{"role":"assistant","content":"```cryptol\nmodule T012_M where\n\ntype T = [8]\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T022.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: 1) Defines an interface submodule named interface_name declaring a numeric type parameter size of kind # with a finiteness constraint and a single value elem of type [size]. 2) Defines a submodule named functor_name that imports interface_name as alias alias_name and defines a value sum = alias_name::elem + alias_name::elem, using modular addition on [size]. Provide explicit type signatures for all declarations and state the constraint on size. 3) Instantiates\/imports functor_name by binding size to 8 and supplying elem = 2 as an [8] value, so that sum is computed under 8-bit modular arithmetic. Include the necessary import statements and aliasing to link the submodule to the interface implementation. Do not prove any properties; only define the interface, the functor-like submodule, and the concrete instantiation with the given bindings."},{"role":"assistant","content":"```cryptol\ninterface submodule S where\n  type n : #\n  type constraint (fin n)\n  x : [n]\n\nsubmodule F where\n  import interface submodule S as A\n\n  z = A::x + A::x\n\nimport submodule F where\n  type n = 8\n  x = 2\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T008.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol specification that creates a parameterized submodule named F with one size type parameter n (kind #) constrained so that n is finite and n \u2265 2. Inside F, declare a constant x typed as a sequence of n bits with the numeric value 2. Then define a submodule named M as the instantiation of F with the parameter bound to n = 2. Finally, include an import that brings this instantiated submodule into scope under the alias M. Clearly state the parameter, its constraints, the type and value of x, the instantiation binding, and the import alias."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n, n >= 2)\n\n  x : [n]\n  x = 2\n\nsubmodule M = submodule F where\n  type n = 2\n\nimport submodule M as M\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T035.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define submodules A, F, M, and N with the following structure: In A, declare a newtype T as a single-field record containing an Integer field named x. In F, introduce a type parameter n of kind numeric with a finiteness constraint, then declare a newtype X as a single-field record whose field x has bit-vector type of width n, and define a function f that takes an X and returns the same X unchanged. Create M and N as separate instantiations of F using implicit parameters. Import M and N qualified under their own names. Finally, define a top-level value named x that applies f from M to a value constructed with the newtype constructor X from N, setting its record field to the zero value appropriate for width n. Do not provide any proofs; just supply the type parameters, constraints, newtypes, function, imports, and the final binding with the correct qualified references."},{"role":"assistant","content":"```cryptol\nsubmodule A where\n  newtype T = { x : Integer }\n\nsubmodule F where\n  parameter\n    type n : #\n    type constraint (fin n)\n\n  newtype X = { x : [n] }\n  f : X -> X\n  f x = x\n\nsubmodule M = submodule F { _ }\nsubmodule N = submodule F { _ }\n\nimport submodule M as M\nimport submodule N as N\n\nx = M::f (N::X { x = 0 })\n```"}]}
{"filename":"cryptol\/tests\/modsys\/functors\/T040.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a parameterized submodule with a single type parameter of kind *, containing: (1) a newtype that wraps a single-record whose sole component is a function from the type parameter to the unit type; and (2) a constant of that newtype whose function ignores its argument and returns unit. Then import this submodule while instantiating the type parameter to 32-bit sequences, and define a top-level constant that is the result of applying the wrapped function to a 32-bit value. Provide explicit type signatures for the wrapped constant and the top-level constant, ensuring the latter has unit type. Do not change the behavior: the function must discard its input and yield unit, and the import must fix the parameter to 32-bit words."},{"role":"assistant","content":"```cryptol\nsubmodule F where\n  parameter\n    type T : *\n\n  newtype NT = { field : T -> () }\n\n  nt : NT\n  nt = NT { field = \\_ -> () }\n\nimport submodule F where\n  type T = [32]\n\nx = nt.field 10\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/ffi-type-errors.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that declares eight external (foreign) bindings intended to provoke FFI type-checking errors. Provide only type signatures (no bodies) and give each binding a distinct name. The bindings must be: (1) a function from a 65-bit word to a 128-bit word; (2) a function from a 16-bit floating-point value to a 128-bit floating-point value; (3) a function, polymorphic over a finite size n, that takes two arguments\u2014first a sequence of n bits, second a sequence of n tuples each containing two 16-bit words\u2014and returns a 4-by-8 array of records, where each record has two fields: one an n-bit word and the other a 2-bit word; (4) a foreign value that is merely a 32-bit word (i.e., not a function); (5) a polymorphic function over an unconstrained type variable that returns a 32-bit word; (6) a function polymorphic over n, without adding a fin constraint, from an array of n 32-bit words to an array of 2\u00b7n 32-bit words; (7) a function from an infinite-length sequence of 32-bit words to a single bit; and (8) a function that quantifies over named numeric and floating constants and returns an unknown\/placeholder result type. Do not add extra constraints or alter sizes; model the invalid FFI types exactly."},{"role":"assistant","content":"```cryptol\nimport Float\n\nforeign badWordSizes : [65] -> [128]\nforeign badFloatSizes : Float16 -> Float128\nforeign badArrayTypes : {n} (fin n) =>\n  [n]Bit -> [n]([16], [16]) -> [n][4][8]{a : [n], b : [2]}\nforeign notFunction : [32]\nforeign badKind : {t} t -> [32]\nforeign noFin : {n} [n][32] -> [n * 2][32]\nforeign infSeq : [inf][32] -> Bit\nforeign wildcard : { x : [8], y : Float32 } -> _\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/ffi-fallback.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification modeling an FFI fallback scenario for byte-sized functions. Define four top-level declarations over 8-bit sequences (bytes), each with the type [8] -> [8]. Among them: (1) one is declared as a foreign function and also given a Cryptol implementation that returns its input unchanged; (2) two are declared as foreign functions with only type signatures and no Cryptol bodies; and (3) one is a pure Cryptol function that returns its input increased by the constant 3 using modular arithmetic over 8 bits (wrap-around at 256). Include properties suitable for solver checking: (a) for all 8-bit inputs, the foreign-declared function that also has a Cryptol body behaves identically to its input (identity behavior); and (b) for all 8-bit inputs, the pure Cryptol function equals the input plus 3 modulo 2^8. Clearly state the types, the use of modular arithmetic on 8-bit words, and quantify universally over the input byte in each property. Do not assert any behavioral properties for the two foreign-only declarations beyond their types."},{"role":"assistant","content":"```cryptol\nforeign foreignAndCryptol : [8] -> [8]\nforeignAndCryptol x = x\n\nforeign foreignAndNoCryptol : [8] -> [8]\n\nforeign noForeignAndCryptol : [8] -> [8]\nnoForeignAndCryptol x = x + 3\n\nforeign noForeignAndNoCryptol : [8] -> [8]\n```"}]}
{"filename":"cryptol\/tests\/ffi\/c-calling-convention\/test-ffi.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that imports the floating-point library and declares the following foreign symbols with exact types and constraints, without providing implementations. Include:\n- Arithmetic on fixed-width words: add8 (8-bit +), sub16 (16-bit \u2212), mul32 (32-bit \u00d7), div64 (64-bit \u00f7).\n- Width-changing word functions: extendInput (3-bit to 8-bit), maskOutput (8-bit to 3-bit), noBits (0-bit to 0-bit).\n- Bit negation: not (bit to bit).\n- Floating-point ops: addFloat32 (binary op on single-precision), subFloat64 (binary op on double-precision), specialFloats (selects a single-precision value from a 2-bit selector).\n- Type synonyms: Word32 as a 32-bit word; MyFunc as a function from Word32 and single-precision float to a bit. Declare usesTypeSynonym with the MyFunc type.\n- Fixed-size sequences: sum10 (sum over a 10-element sequence of 32-bit words), reverse5 (reverse a 5-element sequence of double-precision floats).\n- Compound types: a function taking a 32-bit word and a record {x: 10-bit word, y: 3\u00d720-bit matrix}, returning a record {z: 5\u00d720-bit matrix}, and producing a record {a: pair of 16-bit words, b: {c: 8\u00d720-bit matrix, d: 5-bit word, e: 5-bit word}}.\n- Polymorphic\/size-dependent functions with constraints: typeToValue (polymorphic over a finite size parameter; returns a 64-bit word), sumPoly ([n] of 32-bit words to a 32-bit word), inits (from [n] bytes to [n*(n+1)\/2] bytes), zipMul3 (zips three [n],[m],[p] single-precision sequences to length min(n,m,p)), nestedSeq (reshape [n][m][p] bytes to [4][3][2] bytes given n*m*p = 24 and all sizes finite).\n- Conversions: i2Q (integer to rational), i2Qs (integer to 2-element sequence of rationals), iQ2Qi (swap integer\/rational in a pair), i2Z5 (integer to modulus-5 integer), i2Z (integer to modulus-n with finite n and n \u2265 1).\n- A submodule A exposing a nullary function returning an 8-bit word."},{"role":"assistant","content":"```cryptol\nimport Float\n\nforeign add8 : [8] -> [8] -> [8]\nforeign sub16 : [16] -> [16] -> [16]\nforeign mul32 : [32] -> [32] -> [32]\nforeign div64 : [64] -> [64] -> [64]\n\nforeign extendInput : [3] -> [8]\nforeign maskOutput : [8] -> [3]\nforeign noBits : [0] -> [0]\n\nforeign not : Bit -> Bit\n\nforeign addFloat32 : Float32 -> Float32 -> Float32\nforeign subFloat64 : Float64 -> Float64 -> Float64\nforeign specialFloats : [2] -> Float32\n\ntype Word32 = [32]\ntype MyFunc = Word32 -> Float32 -> Bit\nforeign usesTypeSynonym : MyFunc\n\nforeign sum10 : [10]Word32 -> Word32\nforeign reverse5 : [5]Float64 -> [5]Float64\n\nforeign compoundTypes : ([32], { x : [10], y : [3][20] }) -> { z : [5][20] }\n  -> { a : ([16], [16]), b : { c : [8][20], d : [5], e : [5] } }\n\nforeign typeToValue : {n} (fin n) => () -> [64]\nforeign sumPoly : {n} (fin n) => [n]Word32 -> Word32\nforeign inits : {n} (fin n) => [n][8] -> [n * (n + 1) \/ 2][8]\nforeign zipMul3 : {n, m, p} (fin n, fin m, fin p) =>\n  [n]Float32 -> [m]Float32 -> [p]Float32 -> [min n (min m p)]Float32\n\nforeign nestedSeq : {n, m, p} (fin n, fin m, fin p, n * m * p == 4 * 3 * 2) =>\n  [n][m][p][8] -> [4][3][2][8]\n\nforeign i2Q   : Integer -> Rational\nforeign i2Qs  : Integer -> [2]Rational\nforeign iQ2Qi : (Integer,Rational) -> (Rational,Integer)\nforeign i2Z5  : Integer -> Z 5\nforeign i2Z   : {n} (fin n, n >= 1) => Integer -> Z n\n\nsubmodule A where\n  foreign nested : () -> [8]\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1489\/issue1489.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named ID that contains the following definitions: (1) A polymorphic function id with the type: for any natural k with finiteness and k > 0, map a 2^k-bit word to a 2^k-bit word. Its behavior is to split the input into two blocks of sizes 2 and 2^(k\u22121) and then immediately join them, returning the original word. (2) A type synonym q equal to 3329, used as the modulus for modular integers. (3) A function ct_butterfly parameterized by naturals m and hm with constraints 2 \u2264 m \u2264 8, 1 \u2264 hm \u2264 7, and hm = m \u2212 1. Its type: take a vector of length 2^m of elements in Z q and a twiddle factor in Z q, and return a vector of length 2^m in Z q. Compute halflen = 2^hm, form two length-2^hm subvectors where, for each index x in [0 .. 2^hm \u2212 1], the lower half equals v[x] + z \u00b7 v[x + halflen] and the upper half equals v[x] \u2212 z \u00b7 v[x + halflen]; return the concatenation of the two halves. (4) A constant zeta_expc, an array of 128 elements in Z q, initialized exactly to the provided coefficients. (5) A recursive function fast_nttl parameterized by lv with constraint 2 \u2264 lv \u2264 8. Its type: take a length-2^lv vector in Z q and an 8-bit index, and return a length-2^lv vector in Z q. Base case when lv = 2: apply ct_butterfly using the twiddle at the given index from zeta_expc. Recursive case when lv > 2: first apply ct_butterfly, split the result into two equal halves, recursively process the halves with indices k\u00b72 and k\u00b72 + 1, and concatenate the results."},{"role":"assistant","content":"```cryptol\nmodule ID where\n\nid : {k} (fin k, k > 0) => [2^^k] -> [2^^k]\nid x = join(split`{2,2^^(k-1)}x)\n\ntype q = 3329\n\nct_butterfly :\n    {m, hm}\n    (m >= 2, m <= 8, hm >= 1, hm <= 7, hm == m - 1) =>\n    [2^^m](Z q) -> (Z q) -> [2^^m](Z q)\nct_butterfly v z = new_v\n  where\n    halflen = 2^^`hm\n    lower, upper : [2^^hm](Z q)\n    lower@x = v@x + z * v@(x + halflen)\n    upper@x = v@x - z * v@(x + halflen)\n    new_v = lower # upper\n\nzeta_expc  : [128](Z q)\nzeta_expc = [ 1, 1729, 2580, 3289, 2642, 630, 1897, 848,\n              1062, 1919, 193, 797, 2786, 3260, 569, 1746,\n              296, 2447, 1339, 1476, 3046, 56, 2240, 1333,\n              1426, 2094, 535, 2882, 2393, 2879, 1974, 821,\n              289, 331, 3253, 1756, 1197, 2304, 2277, 2055,\n              650, 1977, 2513, 632, 2865, 33, 1320, 1915,\n              2319, 1435, 807, 452, 1438, 2868, 1534, 2402,\n              2647, 2617, 1481, 648, 2474, 3110, 1227, 910,\n              17, 2761, 583, 2649, 1637, 723, 2288, 1100,\n              1409, 2662, 3281, 233, 756, 2156, 3015, 3050,\n              1703, 1651, 2789, 1789, 1847, 952, 1461, 2687,\n              939, 2308, 2437, 2388, 733, 2337, 268, 641,\n              1584, 2298, 2037, 3220, 375, 2549, 2090, 1645,\n              1063, 319, 2773, 757, 2099, 561, 2466, 2594,\n              2804, 1092, 403, 1026, 1143, 2150, 2775, 886,\n              1722, 1212, 1874, 1029, 2110, 2935, 885, 2154 ]\n\nfast_nttl :\n    {lv}      (lv >= 2, lv <= 8) =>\n    [2^^lv](Z q) -> [8] -> [2^^lv](Z q)\nfast_nttl v k\n    | lv == 2 => ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n\n        | lv  > 2 => (fast_nttl`{lv-1} s0 (k * 2)) #\n                           (fast_nttl`{lv-1} s1 (k * 2 + 1))\n                where\n                  t = ct_butterfly`{lv,lv-1} v (zeta_expc@k)\n                                    [s0, s1] = split t\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1561\/G.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named G that imports the same interface I twice under distinct aliases J and K, and contains the following constant definitions: ja, jb, ka, kb. Specify that ja is the value of member x from alias J incremented by 1, jb is the value of member y from alias J incremented by 2, ka is the value of member x from alias K incremented by 1, and kb is the value of member y from alias K incremented by 2. Include type constraints so that the members x and y are numeric: x has type a where a supports addition with the literal 1, and y has type b where b supports addition with the literal 2; consequently ja and ka have type a, and jb and kb have type b. Ensure the imports use qualified access through the aliases (no unqualified name leakage) and that both interface imports coexist without conflicts. Do not add any extra definitions."},{"role":"assistant","content":"```cryptol\nmodule G where\n\nimport interface I as J\nimport interface I as K\n\nja = J::x + 1\njb = J::y + 2\n\nka = K::x + 1\nkb = K::y + 2\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1560\/T4.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named T3 that contains the following definitions: (1) An interface submodule I1 with a single numeric type parameter x constrained to be between 1 and 3 inclusive. (2) An interface submodule I2 with a single numeric type parameter x constrained to be between 1 and 4 inclusive. (3) A submodule F that imports interface I1 under the alias I and defines a constant y that is a bitvector whose length is the numeric parameter x from alias I, and whose value is 1. (4) Inside F, a nested submodule G that imports interface I2 twice under aliases I and J, and defines a constant csum that is a bitvector whose length is the numeric parameter x from G\u2019s alias I, and whose value is exactly y from the enclosing submodule F. Ensure the specification makes explicit that the bitvector length used for csum must equal the length of y, thereby constraining the numeric parameter from I2 to match the numeric parameter from I1 while satisfying both interfaces\u2019 bounds. Clearly describe the visibility and aliasing so that the I alias in G shadows F\u2019s I, and J is an additional alias for the same interface in G."},{"role":"assistant","content":"```cryptol\nmodule T3 where\n\ninterface submodule I1 where\n  type x: #\n  type constraint (x >= 1, x <= 3)\n\ninterface submodule I2 where\n  type x: #\n  type constraint (x >= 1, x <= 4)\n\nsubmodule F where\n  import interface submodule I1 as I\n\n  y: [I::x]\n  y = 1\n\n  submodule G where\n    import interface submodule I2 as I\n    import interface submodule I2 as J\n\n    csum : [I::x]\n    csum = y\n```"}]}
{"filename":"cryptol\/tests\/issues\/issue1560\/T2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named T2 that contains the following: (1) a module-level type parameter n of numeric kind with a finiteness constraint; (2) a constant a with sequence type of length n whose definition is self-referential (it evaluates to itself); and (3) a submodule F that declares its own numeric type parameter n (shadowing the outer one) and defines a polymorphic function b, universally quantified over m, with type taking a sequence of length n and returning a sequence of length m, which ignores its argument and returns the constant from the outer module. Preserve the exact names, kinds, constraints, polymorphism, and the cross-scope reference to the outer constant."},{"role":"assistant","content":"```cryptol\nmodule T2 where\n\nparameter\n  type n: #\n  type constraint (fin n)\n\na:[n]\na = a\n\nsubmodule F where\n  parameter\n    type n: #\n\n  b: {m} [n] -> [m]\n  b _ = a\n```"}]}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Finite.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines: (1) a constant named xs equal to the finite sequence of consecutive positive integers from 1 to 100, using the minimal unsigned word width sufficient to hold the largest value; and (2) a polymorphic function named sumInf that takes a finite sequence of unsigned words and returns a sequence whose length is exactly one greater than the input. The function must compute a running-sum stream defined co-recursively: start with zero, then for each position add the next input element to the previous sum (zip the input with the partial-sum stream). Next, zip that partial-sum stream with the increasing sequence of positive integers starting at one and add elementwise to produce the final result. Use modular addition over the word type. Provide explicit type signatures: sumInf should be length-polymorphic with constraints ensuring finite sequence length and finite element width, and the result length must be the input length plus one. Do not include any proofs or properties."},{"role":"assistant","content":"```cryptol\nxs = [ 1 .. 100 ]\n\nsumInf xs = iterSums\n    where\n        sums = [ 0 ] # [ x + y | x <- xs\n                               | y <- sums ]\n        iterSums = [ x + y | x <- sums\n                           | y <- [ 1 ...] ]\n```"}]}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Enigma.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Enigma that contains the following definitions and type signatures, matching the described behaviors and constraints: (1) Type synonyms: a 26-character permutation type; plugboard and reflector share this type; a rotor is a 26-element sequence of pairs (character, notch flag); an Enigma machine is a record with a plugboard, a length-n sequence of rotors, and a reflector. (2) A polymorphic membership function that, given a value and a length-a sequence of comparable elements, returns a bit indicating if the value occurs; use a streaming\/recursive construction. (3) A private function that computes the inverse mapping of a permutation for a given character using an iterative candidate build. (4) A rotor-constructor that, given a permutation and a string of notch locations, produces the rotor by pairing each permuted character with a bit indicating notch presence. (5) A scramble step that, given a rotate flag, an input character, and a rotor, outputs the notch bit from the rotor\u2019s current top position, the mapped character from the rotor at the input\u2019s alphabet index, and the rotor left-rotated by one when rotate is true. (6) A function that threads a character through a length-n rotor stack, starting from a dummy identity rotor with no notches; at each step rotate the next rotor if the previous notch bit is set; return the updated rotors (excluding the dummy) and the final character. (7) Forward and backward substitution via a permutation and its inverse. (8) A backward signal function that routes a character back through the rotors in reverse using only the character components. (9) A full loop: plugboard forward, through rotors, reflector forward, back through original rotors, plugboard backward; return updated rotors and output character. (10) A machine constructor that offsets each rotor by its starting letter. (11) A string transformer that iterates the loop over a length-m message, threading rotor state; decryption is the same function. (12) Concrete constants for a plugboard, three rotors with notch sets, a reflector, and a 3-rotor example machine. (13) A universal-quantifier helper over sequences, and a function that checks a reflector\u2019s forward and backward mappings agree for all uppercase letters."},{"role":"assistant","content":"```cryptol\nmodule Enigma where\n\ntype Permutation = String 26\n\ntype Plugboard   = Permutation\ntype Rotor       = [26](Char, Bit)\ntype Reflector   = Permutation\n\ntype Enigma n    = { plugboard : Plugboard,\n                     rotors    : [n]Rotor,\n                     reflector : Reflector\n                   }\n\nelem : {a, b} (fin 0, fin a, Cmp b) => (b, [a]b) -> Bit\nelem (x, xs) = matches ! 0\n  where matches = [False] # [ m || (x == e)  | e <- xs\n                                             | m <- matches\n                            ]\nprivate\n  invSubst : (Permutation, Char) -> Char\n  invSubst (key, c) = candidates ! 0\n    where candidates = [0] # [ if c == k then a else p\n                             | k <- key\n                             | a <- ['A' .. 'Z']\n                             | p <- candidates\n                             ]\n\nmkRotor : {n} (fin n) => (Permutation, String n) -> Rotor\nmkRotor (perm, notchLocations) = [ (p, elem (p, notchLocations))\n                                 | p <- perm\n                                 ]\n\nscramble : (Bit, Char, Rotor) -> (Bit, Char, Rotor)\nscramble (rotate, c, rotor) = (notch, c', rotor')\n  where \n    (c', _)    = rotor @ (c - 'A')\n    (_, notch) = rotor @ 0\n    rotor'     = if rotate then rotor <<< 1 else rotor\n\njoinRotors : {n} (fin n) => ([n]Rotor, Char) -> ([n]Rotor, Char)\njoinRotors (rotors, inputChar) = (rotors', outputChar)\n  where \n    initRotor = mkRotor (['A' .. 'Z'], [])\n    ncrs : [n+1](Bit, [8], Rotor)\n    ncrs = [(True, inputChar, initRotor)] \n               # [ scramble (notch, char, r)\n                 | r <- rotors\n                 | (notch, char, rotor') <- ncrs\n                 ]\n    rotors' = tail [ r | (_, _, r) <- ncrs ]\n    (_, outputChar, _) = ncrs ! 0\n\n\/\/ Following the signal through a single rotor, forward and backward\nsubstFwd, substBwd : (Permutation, Char) -> Char\nsubstFwd (perm, c) = perm @ (c - 'A')\nsubstBwd (perm, c) = invSubst (perm, c)\n\n\/\/ Route the signal back from the reflector, chase through rotors\nbackSignal : {n} (fin n) => ([n]Rotor, Char) -> Char\nbackSignal (rotors, inputChar) = cs ! 0\n  where   cs = [inputChar] # [ substBwd ([ p | (p, _) <- r ], c)\n                             | r <- reverse rotors\n                             | c <- cs\n                             ]\n\n\/\/ The full enigma loop, from keyboard to lamps:\n\/\/ The signal goes through the plugboard, rotors, and the reflector,\n\/\/ then goes back through the sequence in reverse, out of the\n\/\/ plugboard and to the lamps\nenigmaLoop : {n} (fin n) => (Plugboard, [n]Rotor, Reflector, Char) -> ([n]Rotor, Char)\nenigmaLoop (pboard, rotors, refl, c0) = (rotors', c5)\n  where\n    c1 = substFwd (pboard, c0)\n    (rotors', c2) = joinRotors (rotors, c1)\n    c3 = substFwd (refl, c2)\n    c4 = backSignal(rotors, c3)\n    c5 = substBwd (pboard, c4)\n\n\/\/ Construct a machine out of parts\nmkEnigma : {n} (Plugboard, [n]Rotor, Reflector, [n]Char) -> Enigma n\nmkEnigma (pboard, rs, refl, startingPositions) =\n    { plugboard  = pboard\n    , rotors     = [ r <<< (s - 'A')\n                   | r <- rs\n                   | s <- startingPositions\n                   ]\n    , reflector  = refl\n    }\n\n\/\/ Encryption\/Decryption\nenigma : {n, m} (fin n, fin m) => (Enigma n, String m) -> String m\nenigma (m, pt) = tail [ c | (_, c) <- rcs ]\n  where rcs = [(m.rotors, '*')] # \n              [ enigmaLoop (m.plugboard, r, m.reflector, c)\n              | c      <- pt\n              | (r, _) <- rcs\n              ]\n\n\/\/ Decryption is the same as encryption:\n\/\/ dEnigma : {n, m} (fin n, fin m) => (Enigma n, String m) -> String m\ndEnigma = enigma\n\n\/\/ Build an example enigma machine:\nplugboard : Plugboard\nplugboard = \"HBGDEFCAIJKOWNLPXRSVYTMQUZ\"\n\nrotor1, rotor2, rotor3 : Rotor\nrotor1 = mkRotor (\"RJICAWVQZODLUPYFEHXSMTKNGB\", \"IO\")\nrotor2 = mkRotor (\"DWYOLETKNVQPHURZJMSFIGXCBA\", \"B\")\nrotor3 = mkRotor (\"FGKMAJWUOVNRYIZETDPSHBLCQX\", \"CK\")\n\nreflector : Reflector\nreflector = \"FEIPBATSCYVUWZQDOXHGLKMRJN\"\n\nmodelEnigma : Enigma 3\nmodelEnigma = mkEnigma (plugboard, [rotor1, rotor2, rotor3], reflector, \"GCR\")\n\n\/* Example run:\n\n   cryptol> :set ascii=on\n   cryptol> enigma  (modelEnigma, \"ENIGMAWASAREALLYCOOLMACHINE\")\n   UPEKTBSDROBVTUJGNCEHHGBXGTF\n   cryptol> dEnigma (modelEnigma, \"UPEKTBSDROBVTUJGNCEHHGBXGTF\")\n   ENIGMAWASAREALLYCOOLMACHINE\n*\/\n\nall: {a, n} (fin n) => (a->Bit) -> [n]a -> Bit\nall fn xs = folds ! 0 where\n    folds = [True] # [ fn x && p | x <- xs\n                                 | p <- folds]\ncheckReflectorFwdBwd : Reflector -> Bit\ncheckReflectorFwdBwd refl = all check ['A' .. 'Z']\n    where check c = substFwd (refl, c) == substBwd (refl, c)\n```"}]}
{"filename":"cryptol\/docs\/ProgrammingCryptol\/enigma\/Simple.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that mirrors the file\u2019s behavior: (1) introduce type synonyms for an 8-bit character and a 26-character permutation key over uppercase ASCII; (2) define a function named invSubst with type (Permutation, Char) -> Char that performs an inverse lookup by traversing the key alongside the alphabet \u2018A\u2019..\u2018Z\u2019, threading a prior candidate seeded with zero, and returning the alphabet letter when the input equals the corresponding key entry (return zero when no match exists). State the assumption that the key is a bijection over the 26 uppercase letters. (3) define a polymorphic function named myrev with parameters n and a and constraint fin n, type [n+1][a] -> [n+1][a], that returns a vector whose i-th element is the input\u2019s i-th element for indices 0..n (i.e., it behaves as the identity on vectors of that length). (4) define a function named sumAll that constructs a prefix-sum stream seeded with the additive identity and returns its first element, with constraints on the element type to support addition and literal zero; note that the result is always the additive identity for any input. Include concise boolean properties asserting: invSubst returns the correct alphabet letter for any position matching the key (and zero when none match); myrev equals the identity for all lengths and element types meeting the constraint; sumAll\u2019s result equals the additive identity for all inputs and suitable element types. Use clear type signatures, specify any necessary numeric constraints, and keep names exactly as stated."},{"role":"assistant","content":"```cryptol\ntype Char = [8]\ntype Permutation = String 26\n\ninvSubst : (Permutation, Char) -> Char\ninvSubst (key, c) = candidates ! 0\n  where candidates = [0] # [ if c == k then a else p\n                           | k <- key\n                           | a <- ['A' .. 'Z']\n                           | p <- candidates\n                           ]\n\nmyrev : {n,a} (fin n) => [n+1][a] -> [n+1][a]\nmyrev xs = [ xs!i | i <- [ 0 .. n] ]\n\nsumAll xs = ys ! 0\n    where ys = [0] # [x+y | x <- xs | y <- ys]\n```"}]}
{"filename":"cryptol\/examples\/funstuff\/FoxChickenCorn.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named FoxChickenCorn that contains the following definitions. Types: OneBank as a 4-bit vector; BankState as a record with fields left and right of type OneBank; StringRep as 7 ASCII bytes; DirRep as 5 ASCII bytes. Constants: farmer=1, chicken=2, corn=4, fox=8 (disjoint single-bit flags); startState with all flags on the left and right zero; doneState with left zero and all flags on the right; string literals for each object name and a blank, plus an array listing the four names in a fixed order. Functions and property: give solutionInNmoves a size-polymorphic signature over n with constraint fin n; define a property solutionInNmoves that holds exactly when concatenating startState, the given states, and doneState forms a validMoveSequence. validMoveSequence (n >= 1) checks every adjacent pair using validMove. validMove requires both states satisfy validState and that only items moved with the farmer (stuffOnlyMovedWithFarmer). stuffOnlyMovedWithFarmer chooses source\/destination by the farmer\u2019s starting side and computes the moved mask from the destination-side change, then enforces moveFollowsRules. moveFollowsRules requires the farmer bit moved and at most one non-farmer moved (use popCount). completeState requires each object is on exactly one bank (left XOR right equals the full mask 1|2|4|8). validState requires completeState and both banks pass validBank. validBank allows either the farmer present or neither \u201cfox with chicken\u201d nor \u201cchicken with corn\u201d co-located without the farmer. farmerHere tests the farmer bit presence on a bank. chickenWithCorn and foxWithChicken test co-location masks. all over [n]Bit returns true iff every element is true. popCount (a >= 1) returns the number of set bits in an a-bit vector, with result width width a. Pretty-printing: ppBits maps a 4-bit mask to an array of 4 strings (object name or blank) by bit position. extractMoves maps a nonempty sequence of states to per-step pairs (direction arrow string, 4 strings) using the farmer\u2019s direction and the moved mask."},{"role":"assistant","content":"```cryptol\nmodule FoxChickenCorn where\n\ntype OneBank = [4]\ntype BankState =\n    {left : OneBank\n    ,right: OneBank\n    }\n\nstartState      = { left = farmer || chicken || corn || fox, right = 0x0}\ndoneState       = { left = 0x0, right = farmer || chicken || corn || fox}\n\nfarmer  = 0x1\nchicken = 0x2\ncorn    = 0x4\nfox     = 0x8\n\nsolutionInNmoves : {n} (fin n) => [n] BankState -> Bit\nproperty solutionInNmoves states = validMoveSequence ([startState] # states # [doneState])\n\nvalidMoveSequence : {n} (fin n, n >= 1) => [n] BankState -> Bit\nvalidMoveSequence states = all [validMove a b\n                               | a <- states\n                               | b <- drop`{1} states]\n\nvalidMove : BankState -> BankState -> Bit\nvalidMove b b' = validState b && validState b'\n                 && stuffOnlyMovedWithFarmer b b'\n\nstuffOnlyMovedWithFarmer : BankState -> BankState -> Bit\nstuffOnlyMovedWithFarmer b b' =\n    if farmerHere b.left\n    then farmerHere b'.right && moveFollowsRules b.left b'.right (b'.right - b.right)\n    else farmerHere b'.left  && moveFollowsRules b.right b'.left (b'.left - b.left)\n\nmoveFollowsRules fromBank toBank whatMoved = farmerMoved && atMostOneObjectMoved where\n    farmerMoved = (whatMoved && farmer) == farmer\n    atMostOneObjectMoved = popCount (whatMoved && ~farmer) <= 1\n\ncompleteState : BankState -> Bit\ncompleteState b = (b.left ^ b.right) == 0xf\n\nvalidState : BankState -> Bit\nvalidState bs = completeState bs && validBank bs.left\n                && validBank bs.right && completeState bs\n\nvalidBank : OneBank -> Bit\nvalidBank b = farmerHere b || (~(foxWithChicken b) && ~(chickenWithCorn b))\n\nfarmerHere : OneBank -> Bit\nfarmerHere b = (b && farmer) > 0\n\nchickenWithCorn : OneBank -> Bit\nchickenWithCorn b = (b && (corn || chicken)) == (corn || chicken)\n\nfoxWithChicken : OneBank -> Bit\nfoxWithChicken b = (b && (fox || chicken)) == (fox || chicken)\n\nall : {n} (fin n) => [n] -> Bit\nall xs = xs == ~zero\n\npopCount : {a} (fin a, a >= 1) => [a] -> [width a]\npopCount bs = ic ! 0 where\n    ic = [0] # [ if elt then prev + 1 else prev | elt <- bs | prev <- ic]\n\ntype StringRep = [7][8]\ntype DirRep = [5][8]\nfarmerString  = \"farmer \"\nchickenString = \"chicken\"\ncornString    = \"corn   \"\nfoxString     = \"fox    \"\nnoString      = \"       \"\n\nppArray = [farmerString, chickenString, cornString, foxString]\n\nppBits : [4] -> [4]StringRep\nppBits s =  [ if b then ppArray!i else noString\n            | b <- s\n            | i <- [0 ...]:[_][4] ]\n\nextractMoves : {a} [a+1]BankState -> [a](DirRep, [4]StringRep)\nextractMoves bankStates = [ getMove b b' | b <- bankStates | b' <- drop`{1} bankStates ] where\n    getMove start end = ( dirString, thingsString thingsMoved ) where\n        dirString = if farmerHere start.left then \" --> \" else \" <-- \"\n        thingsMoved = if farmerHere start.left\n                      then end.right - start.right\n                      else end.left - start.left\n        thingsString bits = ppBits bits\n```"}]}
{"filename":"cryptol\/examples\/funstuff\/Coins.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define three Cryptol predicates with explicit type signatures over 10-bit sequences: coinCount, coinSum, and coinPuzzle. coinCount takes four 10-bit inputs and a 10-bit target and returns a Bit indicating that the four inputs sum exactly to the target and that each input is less than or equal to the target. coinSum takes four 10-bit inputs and a 10-bit target amount and returns a Bit indicating that the weighted sum using coin denominations 1, 5, 10, and 25 equals the target amount. coinPuzzle takes four 10-bit inputs and returns a Bit that is the conjunction of coinCount applied with target 30 and coinSum applied with target 109. Preserve the argument order and use [10] for all numeric parameters and Bit for results."},{"role":"assistant","content":"```cryptol\ncoinPuzzle : [10] -> [10] -> [10] -> [10] -> Bit\ncoinPuzzle a b c d = (coinCount a b c d 30) \/\\ (coinSum a b c d 109)\n\ncoinSum : [10] -> [10] -> [10] -> [10] -> [10] -> Bit\ncoinSum   a b c d s = (a + 5 * b + 10 * c + 25 * d) == s\n\ncoinCount : [10] -> [10] -> [10] -> [10] -> [10] -> Bit\ncoinCount a b c d s = (((a + b + c + d) == s) \/\\                        (a <= s \/\\ b <= s \/\\ c <= s \/\\ d <= s))\n```"}]}
{"filename":"cryptol\/examples\/funstuff\/marble.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that models a 7\u00d77 peg-solitaire board and validates move sequences. Include: (1) a type alias Board as a 7\u00d77 matrix of bits; (2) a polymorphic function all with a finite length parameter that returns True iff every bit in a bit-vector is 1; (3) a function popCount for any non-empty bit-vector that returns the number of set bits with result width equal to the bit-vector\u2019s index width; (4) constants posns, start, first, second, and goal of type Board, with the same values and shapes; (5) a function validBoard that returns True iff all set positions of a board are within the allowed mask given by posns; (6) a function differentRow that, given two boards, returns the first pair of 7-bit rows that differ (top to bottom); (7) a function validRowMove that, given two 7-bit rows, returns True iff their change encodes exactly one legal horizontal jump of length two (a peg jumps over an adjacent peg into an empty cell) with correct before\/after occupancy; (8) a function validRowJump that holds iff both boards are valid and validRowMove holds for the unique differing row; (9) a function validColJump defined analogously by operating on the transpose of the boards; (10) a function validMove that is True iff either a valid horizontal or vertical jump occurs; (11) a function validMoveSequence, for any finite n \u2265 1, that returns True iff every adjacent pair in a length-n sequence of boards is a valid move; and (12) the property solutionInNmoves, for any finite n, stating that concatenating start, an n-length sequence ms, and second forms a sequence in which every adjacent pair is a valid move. Specify all necessary type signatures, size constraints, and quantification."},{"role":"assistant","content":"```cryptol\ntype Board = [7][7]Bit\n\nall : {n} (fin n) => [n] -> Bit\nall xs = xs == ~zero\n\npopCount : {a} (fin a, a >= 1) => [a] -> [width a]\npopCount bs = ic ! 0 where\n    ic = [0] # [ if elt then prev + 1 else prev | elt <- bs | prev <- ic]\n\nposns : Board\nposns = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nstart : Board\nstart = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,False,True,True,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nfirst : Board\nfirst = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,False,False,True],\n         [True,True,True,True,True,True,True],\n         [False,True,True,True,True,True,False],\n         [False,False,True,True,True,False,False]]\n\nsecond : Board\nsecond = [[False,False,True,True,True,False,False],\n         [False,True,True,True,True,True,False],\n         [True,True,True,True,True,True,True],\n         [True,True,True,True,True,False,True],\n         [True,True,True,True,False,True,True],\n         [False,True,True,True,False,True,False],\n         [False,False,True,True,True,False,False]]\n\ngoal : Board\ngoal = [[False,False,False,False,False,False,False],\n        [False,False,False,True,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False],\n        [False,False,False,False,False,False,False]]\n\nvalidBoard : Board -> Bit\nvalidBoard b = join (b && ~posns) == zero\n\nvalidRowJump : Board -> Board -> Bit\nvalidRowJump a a' = validBoard a\n                 \/\\ validBoard a'\n                 \/\\ validRowMove (differentRow a a')\n\ndifferentRow : Board -> Board -> ([7], [7])\ndifferentRow a a' = rows ! 0\n    where rows = [(0b0000000,0b0000000)]\n               # [ if row != row' then (row,row') else old\n                 | row <- a\n                 | row' <- a'\n                 | old <- rows ]\n\nvalidRowMove : ([7], [7]) -> Bit\nvalidRowMove (r, r') = (xors == 0b0000111 \\\/\n                        xors == 0b0001110 \\\/\n                        xors == 0b0011100 \\\/\n                        xors == 0b0111000 \\\/\n                        xors == 0b1110000)\n                      \/\\ (\n                        rxors == 0b0000011 \\\/\n                        rxors == 0b0000110 \\\/\n                        rxors == 0b0001100 \\\/\n                        rxors == 0b0011000 \\\/\n                        rxors == 0b0110000 \\\/\n                        rxors == 0b1100000)\n    where xors = r ^ r'\n          rxors = r && rxors\n\nvalidColJump : Board -> Board -> Bit\nvalidColJump a a' = validRowJump (transpose a) (transpose a')\n\nvalidMove : Board -> Board -> Bit\nvalidMove a a' = validRowJump a a' \\\/ validColJump a a'\n\nvalidMoveSequence : {n} (fin n, n >= 1) => [n] Board -> Bit\nvalidMoveSequence moves = all [validMove a b | a <- moves | b <- drop`{1} moves]\n\nsolutionInNmoves : {n} (fin n) => [n] Board -> Bit\nproperty solutionInNmoves ms = validMoveSequence ([start] # ms # [second])\n```"}]}
{"filename":"cryptol\/examples\/SuiteB_FFI\/SuiteB_FFI.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named SuiteB_FFI that contains the following definitions and behaviors:\n- Import the SuiteB module with a short alias and create type aliases that refer to its AES-related types: AES128, AES192, AES256, AESRoundKey, AESEncryptKeySchedule k, and AESDecryptKeySchedule k.\n- Define functions that construct AES key schedules from raw keys: aes128EncryptSchedule, aes128DecryptSchedule, aes128Schedules; aes192EncryptSchedule, aes192DecryptSchedule, aes192Schedules; aes256EncryptSchedule, aes256DecryptSchedule, aes256Schedules. Each takes a key of the corresponding bit width and returns an encrypt schedule, a decrypt schedule, or both. At runtime, branch on a Boolean flag indicating AES-NI availability: if supported, convert the key from a single bitvector to an array of bytes (16, 24, or 32 bytes respectively) and call the appropriate foreign AES-NI expansion; otherwise delegate to the imported SuiteB implementation.\n- Define block operations aesEncryptBlock and aesDecryptBlock with a type parameter k and a fin k constraint. Each takes the appropriate key schedule and a 128-bit block, and returns a 128-bit block. When AES-NI is available, split the block into 16 bytes, invoke the corresponding foreign AES-NI block function, then join bytes back to a 128-bit result; otherwise delegate to the imported SuiteB functions.\n- In a private section, declare foreign functions: a zero-argument check that returns a single Bit indicating AES-NI support; key expansion functions for 128\/192\/256-bit keys that operate on byte arrays; paired expand functions returning both schedules; and block encrypt\/decrypt functions parameterized by k with fin k.\n- Define a private constant aesniSupported initialized from the foreign check.\n- Bind sha224, sha256, sha384, and sha512 to the imported implementations."},{"role":"assistant","content":"```cryptol\nmodule SuiteB_FFI where\n\nimport SuiteB as SB\n\ntype AES128 = SB::AES128\n\ntype AES192 = SB::AES192\n\ntype AES256 = SB::AES256\n\ntype AESRoundKey = SB::AESRoundKey\n\ntype AESEncryptKeySchedule k = SB::AESEncryptKeySchedule k\n\ntype AESDecryptKeySchedule k = SB::AESDecryptKeySchedule k\n\naes128EncryptSchedule : [128] -> AESEncryptKeySchedule AES128\naes128EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt128 (split key)\n    else SB::aes128EncryptSchedule\n\naes128DecryptSchedule : [128] -> AESDecryptKeySchedule AES128\naes128DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt128 (split key)\n    else SB::aes128DecryptSchedule\n\naes128Schedules : [128] -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\naes128Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt128 (split key)\n    else SB::aes128Schedules\n\naes192EncryptSchedule : [192] -> AESEncryptKeySchedule AES192\naes192EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt192 (split key)\n    else SB::aes192EncryptSchedule\n\naes192DecryptSchedule : [192] -> AESDecryptKeySchedule AES192\naes192DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt192 (split key)\n    else SB::aes192DecryptSchedule\n\naes192Schedules : [192] -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\naes192Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt192 (split key)\n    else SB::aes192Schedules\n\naes256EncryptSchedule : [256] -> AESEncryptKeySchedule AES256\naes256EncryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandEncrypt256 (split key)\n    else SB::aes256EncryptSchedule\n\naes256DecryptSchedule : [256] -> AESDecryptKeySchedule AES256\naes256DecryptSchedule =\n  if aesniSupported\n    then \\key -> aesniExpandDecrypt256 (split key)\n    else SB::aes256DecryptSchedule\n\naes256Schedules : [256] -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\naes256Schedules =\n  if aesniSupported\n    then \\key -> aesniExpandEncryptDecrypt256 (split key)\n    else SB::aes256Schedules\n\naesEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [128] -> [128]\naesEncryptBlock =\n  if aesniSupported\n    then \\schedule plaintext -> join (aesniEncryptBlock schedule (split plaintext))\n    else SB::aesEncryptBlock\n\naesDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [128] -> [128]\naesDecryptBlock =\n  if aesniSupported\n    then \\schedule ciphertext -> join (aesniDecryptBlock schedule (split ciphertext))\n    else SB::aesDecryptBlock\n\nprivate\n  foreign checkAESNISupported : () -> Bit\n  foreign aesniExpandEncrypt128 : [16][8] -> AESEncryptKeySchedule AES128\n  foreign aesniExpandDecrypt128 : [16][8] -> AESDecryptKeySchedule AES128\n  foreign aesniExpandEncryptDecrypt128 : [16][8]\n    -> (AESEncryptKeySchedule AES128, AESDecryptKeySchedule AES128)\n  foreign aesniExpandEncrypt192 : [24][8] -> AESEncryptKeySchedule AES192\n  foreign aesniExpandDecrypt192 : [24][8] -> AESDecryptKeySchedule AES192\n  foreign aesniExpandEncryptDecrypt192 : [24][8]\n    -> (AESEncryptKeySchedule AES192, AESDecryptKeySchedule AES192)\n  foreign aesniExpandEncrypt256 : [32][8] -> AESEncryptKeySchedule AES256\n  foreign aesniExpandDecrypt256 : [32][8] -> AESDecryptKeySchedule AES256\n  foreign aesniExpandEncryptDecrypt256 : [32][8]\n    -> (AESEncryptKeySchedule AES256, AESDecryptKeySchedule AES256)\n  foreign aesniEncryptBlock : {k} (fin k) => AESEncryptKeySchedule k -> [16][8] -> [16][8]\n  foreign aesniDecryptBlock : {k} (fin k) => AESDecryptKeySchedule k -> [16][8] -> [16][8]\n\n  aesniSupported = checkAESNISupported ()\n\nsha224 = SB::sha224\n\nsha256 = SB::sha256\n\nsha384 = SB::sha384\n\nsha512 = SB::sha512\n```"}]}
{"filename":"cryptol\/examples\/contrib\/mkrand.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named MKRAND that contains the following definitions: (1) Type aliases: Seg as a 128-bit sequence, and Field as a vector of 128 Seg values. (2) A constant seedUnit of type Seg (the default seed). (3) A function field: Seg -> [inf]Seg that produces an infinite stream where the first element is the seed and each subsequent element is computed by an elementary cellular automaton \u201crule 30\u201d: for each bit position, XOR the left neighbor with the OR of the current and right neighbors (neighbors obtained by 1-bit shifts). (4) A function sha30: Seg -> Seg that evolves field from a given seed, takes the middle-column bit from each row, drops the first 128 rows, takes the next 128 bits, and packs them into a 128-bit result. (5) A function rands: Seg -> [inf]Seg that iteratively maps p to p XOR sha30(p), starting from the given seed, yielding an infinite sequence. (6) A function randBytes: Seg -> [inf][8] that concatenates the rands output and groups it into bytes. (7) A function randXOR: for any length n, takes a Seg and a String n (n bytes) and returns a String n by XORing the source bytes with the byte stream from randBytes; provide an explicit polymorphic type signature with length parameter n. (8) A property otp_encdec that checks that encrypting a fixed ASCII message with seedUnit equals a fixed 16-byte ciphertext, and decrypting that ciphertext with the same seed reproduces the original message. (9) A function otp_involutive: for any length len with fin len, takes String len and returns Bit, asserting that applying randXOR with seedUnit twice yields the original message. (10) A property otp_involutive_32 that quantifies over messages and checks otp_involutive for 32-byte strings."},{"role":"assistant","content":"```cryptol\nmodule MKRAND where\n\ntype Seg   = [0x80]\ntype Field = [0x80]Seg\n\nseedUnit:Seg\nseedUnit = (0 :[63]) # (1:[1]) # (0:[64])\n\nfield: Seg -> [inf]Seg\nfield s = new\n  where\n    new = [s] # [ rule30 row | row <- new]\n    rule30 r = [ a ^ (b || c) | a <- r >>> 1\n                              | b <- r\n                              | c <- r <<< 1\n               ]\n\nsha30: Seg -> Seg\nsha30 s = take`{0x80} (drop`{0x80} [ r @ ((((length r) \/ 2)-1):[8]) | r <- field s])\n\nrands : Seg -> [inf]Seg\nrands s = rest\n  where\n     rand p = p ^ (sha30 p)\n     rest = [rand s] # [rand x | x <- rest]\n\nrandBytes : Seg -> [inf][8]\nrandBytes s = groupBy`{8} (join (rands s))\n\nrandXOR : {n} Seg ->  String n -> String n\nrandXOR seed src = [s ^ r | s <- src\n                          | r <- randBytes seed\n                   ]\n\nproperty otp_encdec =\n     randXOR seedUnit \"Deus Ex Machina\" == c\n  \/\\ randXOR seedUnit c == \"Deus Ex Machina\"\n  where c = [ 0x28, 0x2b, 0x2c, 0xfa\n            , 0x92, 0xca, 0xb3, 0xcb\n            , 0xed, 0x50, 0xc2, 0x1b\n            , 0x11, 0x0e, 0x70]\n\notp_involutive : {len} (fin len) => String len -> Bit\notp_involutive msg = randXOR seedUnit (randXOR seedUnit msg) == msg\n\nproperty otp_involutive_32 msg = otp_involutive (msg : String 32)\n```"}]}
{"filename":"cryptol\/examples\/contrib\/EvenMansour.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines the Even\u2013Mansour construction and supporting utilities as follows: define a constant permutation F generated from a fixed 256-bit seed using a PRNG-based shuffle. Define a property that holds for a candidate permutation when all entries are unique and each index is within 0 to length-1. Define a constant F\u2019 as the inverse of F. Define a property that, for any vector, permutation, and its inverse, applying the permutation then its inverse yields the original vector. Define encryption E and decryption D over a size parameter n with constraints: n is finite, n \u2265 1, and the bit-width of n is at least that of n\u22121. Both keys are n-bit vectors, messages and ciphertexts are n-bit vectors. Encryption xors the message with the first key, applies the public permutation, then xors with the second key. Decryption xors the ciphertext with the second key, applies the inverse permutation, then xors with the first key. Define a property that for all keys and messages, decryption after encryption returns the original message. Also define utilities: swap that exchanges two positions in an array of length a (a finite, a \u2265 1; indices have width sufficient to index a\u22121); a permutation generator that starts from the identity and performs a sequence of swaps driven by PRNG-derived indices (parameter a finite, a \u2265 1, with bit-width of a at least that of a\u22121); a predicate that returns true iff all elements in a vector are unique; a predicate that returns true iff every element in a vector is \u2264 a given bound; an index_of function that returns the first index of a value in an array (element type comparable); and an inverse_permutation function that maps each value to its position. Provide precise type signatures and constraints for all definitions."},{"role":"assistant","content":"```cryptol\nF = (generate_random_permutation 1942611697)\n\nproperty is_a_permutation a = (unique a) \/\\ (leq a (length(a)-1))\n\nF' = inverse_permutation F\n\nproperty is_inverse_permutation x a a' = ((x@@a)@@a') == x\n\/\/ Main> is_inverse_permutation ([0..9]:[_][4]) (F:[10]_) (F':[10]_)\n\nE : {n} (fin n, n >= 1, width n >= width(n-1)) => ([n], [n]) -> [n] -> [n]\nE (K1, K2) M =  (M^K1)@@F ^ K2\n\nD : {n} (fin n, n >= 1, width n >= width(n-1)) => ([n], [n]) -> [n] -> [n]\nD (K1, K2) C =  (C^K2)@@F' ^ K1\n\n\/**\n * It is easy to verify that for every M in {0,1}^n and K in {0,1}^2n,\n * the following identity holds D_K(E_K(M)) = M, i.e. D_K decrypts\n * messages that were encrypted using E_K.\n *\/\nproperty E_and_D_are_inverses K M = (D K (E K M)) == M\n\n\/******* Utilities *******\/\n\nswap : {a, b} (fin a, a >= 1) => [a]b -> [width(a-1)] -> [width(a-1)] -> [a]b\nswap xs a b = [ if(i == a) then xs@b\n                 |(i == b) then xs@a\n                else xs@i\n              | i <- [0 .. a-1] ]\n\ngenerate_random_permutation : {a} (fin a, a >= 1, width a >= width(a-1)) => [256] -> [a][width(a-1)]\ngenerate_random_permutation seed = pss!0\n  where\n    indices = [ take `{width(a-1)} (b % `a) | b <- (random seed) : [a][width a] ]\n    pss = [ [0 .. a-1] ] # [ swap ps a b | ps <- pss | a <- [0 .. a-1] | b <- indices ]\n\nunique : {a, b} (fin a, fin b, a>=1) => [a][b] -> Bit\nunique xs = [ exist x (i+1) | x <- xs | i <- [0...] ] == 0\n  where exist : [b] -> [width a] -> Bit\n        exist x i = if(i>=`a) then False\n                    else if(x==(xs@i)) then True\n                    else exist x (i+1)\n\nleq xs a = [ x <= a | x <- xs ] == ~0\n\nindex_of : {a, b} (fin a, a>=1, Cmp b) => [a]b -> b -> [width(a-1)]\nindex_of xs a = (ret!0).1\n  where ret = [(False, 0)] # [ if(xs@i == a) then (True, i) else r\n                             | i <- [0 .. a-1 ]\n                             | r <- ret ]\n\ninverse_permutation : {a} (fin a, a >= 1) => [a][width(a-1)] -> [a][width(a-1)]\ninverse_permutation perm = [ index_of perm i | i <- [0 .. a-1 ] ]\n```"}]}
{"filename":"cryptol\/examples\/contrib\/A51.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the A5\/1 keystream generator with the following elements: 1) Define a type alias equal to 128 for the keystream length. 2) Define a function that steps a length-d LFSR under a boolean clock condition using a degree-(d) characteristic polynomial mask of length d+1; require fin d and d >= 1, ensure the polynomial\u2019s highest bit is set, compute the feedback bit as the XOR of masked state bits, and update the state only when the condition is true. 3) Define a function that, given a polynomial, an infinite stream of clock conditions, and an initial d-bit state, returns both the infinite output bit stream (the leftmost bit of each state) and the infinite stream of LFSR states, by iterating the step function. 4) Define a majority-of-three boolean helper and a helper that produces the running application of a binary operator over a sequence as needed for feedback computation. 5) Define a stream generator that takes three registers of sizes 19, 22, and 23 bits, respectively, constructs three conditionally clocked LFSRs with characteristic polynomials matching the standard taps for those sizes, derives the clock-condition streams by comparing each register\u2019s designated tap (index 8 for the first, 10 for the others) to the per-cycle majority of those taps, and outputs the XOR of the three LFSR output streams. 6) Define a function that returns the first 128 bits of the keystream from the three-register generator. 7) Define constants for the three initial register values (sizes 19, 22, 23) and a 128-bit expected keystream. 8) Define a property that the 128-bit output for the given initial values equals the expected keystream. 9) Define a property that, for variables of sizes 19, 22, and 23, the produced 128-bit keystream equals the expected value (to enable seed search)."},{"role":"assistant","content":"```cryptol\nA51_stream : [19] -> [22] -> [23] -> [inf]\nA51_stream R1 R2 R3 = R1s ^ R2s ^ R3s\n  where\n    (R1s, R1f) = lfsrki <| x^^19 + x^^18 + x^^17 + x^^14 + 1 |>  R1c R1\n    (R2s, R2f) = lfsrki <| x^^22 + x^^21 + 1 |>                  R2c R2\n    (R3s, R3f) = lfsrki <| x^^23 + x^^22 + x^^21 + x^^8 + 1 |>   R3c R3\n    majvs = [ majv (r1@8) (r2@10) (r3@10) | r1 <- R1f | r2 <- R2f | r3 <- R3f ]\n    R1c = [ r1@8 == m | r1 <- R1f | m <- majvs ]\n    R2c = [ r2@10 == m | r2 <- R2f | m <- majvs ]\n    R3c = [ r3@10 == m | r3 <- R3f | m <- majvs ]\n\ntype N = 128\nA51 : ([19], [22], [23]) -> [N]Bit\nA51(reg1, reg2, reg3) = keystream\n  where\n    keystream = take`{N} (A51_stream reg1 reg2 reg3)\n\nlfsrki_step : {d} (fin d, d >=1) => [d+1] -> Bit -> [d] -> [d]\nlfsrki_step poly cond fill = fill'\n where\n   feedback_bit = if(poly@0) then prefix (^) (reverse([False]#fill) && poly)\n                             else error \"polynomial does not have high-bit set.\"\n   fill' = if cond then [feedback_bit]#(take fill) else fill\n\nlfsrki : {d} (fin d, d >=1) => [d+1] -> [inf] -> [d] -> ([inf], [inf][d])\nlfsrki poly conds init = (stream, fills)\n  where\n    lfsrki' = lfsrki_step poly\n    fills = [init] # [ lfsrki' c f | c <- conds | f <- fills]\n    stream = [ f!0 | f <- fills ]\n\nprefix f xs = ys!0\n  where ys = [xs@0] # [ f y x | y <- ys | x <- tail xs ]\n\nmajv a b c = (a && b) || (a && c) || (b && c)\n\niv1 = 0b1010111011101011101\niv2 = 0b1010111011101010101110\niv3 = 0b10100000111100110011011\n\ntest_keystream = 0b00100100111010001110101110101100010100110111110101000101110000011101000111110101010000010011001111110101110001011010100000010001\n\nproperty A51_correct = (A51(iv1, iv2, iv3)) == test_keystream\nproperty A51_search x y z = A51(x,y,z) == test_keystream\n```"}]}
{"filename":"cryptol\/examples\/contrib\/RC4.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification for the RC4 stream cipher that includes the following: (1) Define swap that takes a 256-element state of bytes and two byte indices and returns a new state with those positions exchanged. (2) Define ksa_step that, given an infinite byte key stream, a byte i, a byte j, and a 256-byte state, computes j\u2019 as the byte-wise sum of j, the state at i, and the key at i (all modulo 256), and returns (j\u2019, updated state via swap at i and j\u2019). (3) Define ksa that starts from the identity 256-byte permutation, iterates i from 0 to 255 applying ksa_step, treats the key as an infinite repetition of the provided key bytes, and returns the final state. (4) Define ks_step that, given i, j, and a state, computes j\u2019 as j plus the state at i (mod 256), produces a swapped state at i and j\u2019, and outputs the keystream byte indexed by the sum of the state at i and the state at j\u2019 (mod 256), along with j\u2019 and the new state. (5) Define ks that first computes the initial state via ksa on the infinitely repeated key, then generates an infinite byte stream by repeatedly applying ks_step with i cycling through 1..255 then 0. (6) Provide type signatures: states are sequences of 256 bytes, indices and intermediate values are bytes, keys and keystreams are infinite sequences of bytes, and all byte arithmetic wraps modulo 256. (7) Define properties test1, test2, and test3 that check the initial keystream bytes for the ASCII keys \"Key\", \"Wiki\", and \"Secret\" against the canonical RC4 test vectors."},{"role":"assistant","content":"```cryptol\nswap : [256][8] -> [8] -> [8] -> [256][8]\nswap s i j = [ s @ (if n == i then j else\n                    if n == j then i else\n                    n)\n             | n <- [0..255]\n             ]\n\nksa_step : [inf][8] -> [8] -> [8] -> [256][8] -> ([8],[256][8])\nksa_step key i j s = (j', swap s i j')\n where j' = j + s@i + key@i\n\nksa : [inf][8] -> [256][8]\nksa key = (go ! 0).1 where\n go : [257]([8],[256][8])\n go = [(0,[0..255])] # [ ksa_step key i j s\n                       | i <- [0..255]\n                       | (j,s) <- go\n                       ]\n\nks_step : [8] -> [8] -> [256][8] -> ([8],[256][8],[8])\nks_step i j s = (j',s',s@(s@i + s@j'))\n where j' = j + s@i\n       s' = swap s i j'\n\nks key = [ k | (_,_,k) <- drop`{1} go ] where\n go = [(0,ksa key',0)] # [ ks_step i j s\n                         | i <- loop\n                         | (j,s,k) <- go\n                         ]\n key' = key # key'\n loop = [1..255] # [0] # loop\n\nproperty test1 = take (ks \"Key\") == [0xEB,0x9F,0x77,0x81,0xB7,0x34,0xCA,0x72,0xA7,0x19]\nproperty test2 = take (ks \"Wiki\") == [0x60,0x44,0xDB,0x6D,0x41,0xB7]\nproperty test3 = take (ks \"Secret\") == [0x04,0xD4,0x6B,0x05,0x3C,0xA8,0x7B,0x59]\n```"}]}
{"filename":"cryptol\/examples\/contrib\/MISTY1.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named MISTY1 that contains the following definitions: (1) A key schedule that maps a 16-element sequence of 8-bit words to a 32-element sequence of 16-bit subkeys by: joining to a single bitvector, splitting into 16-bit words, forming a shifted variant, applying the 16-bit round function to each pair, and deriving two additional subkey groups by extracting upper and lower portions and zero-extending them; concatenate the four groups to produce all subkeys. (2) A 32-bit round function FO that takes a 32-bit block half, an 8-bit round index, and the subkey array, splits the half into two 16-bit words, iterates a fixed pipeline of transformations using the 16-bit round function, XORs, and subkey selections based on modular arithmetic over the index, and returns the recombined 32-bit result. (3) A 16-bit round function FI that splits its 16-bit input into 9-bit and 7-bit parts, applies two S-box tables (7-bit and 9-bit), mixes with parts of a 16-bit key via XOR, extraction of high\/low bits, and zero-extension, and returns a 16-bit result. (4) Two S-box constants: a 128-entry table of 7-bit values and a 512-entry table of 9-bit values, using the standard MISTY1 contents. (5) Linear layer FL and its inverse FLINV over 32-bit halves that depend on the parity of the 8-bit round index, split the input into two 16-bit words, and combine them with AND\/OR and XOR using appropriate subkeys. (6) A polymorphic zero-extension function with constraints ensuring the target width is at least the source width. (7) A function that returns true iff the least-significant bit is zero. (8) A 64-bit encryption that performs the specified 10-step schedule of FL\/FO operations on two 32-bit halves using subkeys. (9) A matching 64-bit decryption that inverts the schedule. (10) Define a property that encrypting two fixed 64-bit plaintexts with subkeys from a fixed 128-bit key yields two fixed 64-bit ciphertexts. (11) Define a property that decryption(encryption(pt, EK), EK) equals pt for all 64-bit plaintexts and 128-bit keys, where EK comes from the key schedule."},{"role":"assistant","content":"```cryptol\nmodule MISTY1 where\n\nkeySchedule : [16][8] -> [32][16]\nkeySchedule K = EK_1 # EK_2 # EK_3 # EK_4\n    where EK_1 = split (join K)\n          EK_2 = [ FI ek_1 ek_1_shifted\n                 | ek_1         <- EK_1\n                 | ek_1_shifted <- EK_1 <<< 1\n                 ]\n          EK_3 = [extend (drop`{7} ek_2) | ek_2 <- EK_2]\n          EK_4 = [extend (take`{7} ek_2) | ek_2 <- EK_2]\n\nFO : [32] -> [8] -> [32][16] -> [32]\nFO FO_IN k EK = (FO_OUT ! 0).1 # (FO_OUT ! 0).0\n    where FO_OUT = [(take FO_IN, drop FO_IN)] # [ f t0 t1\n                                                | f        <- funcs\n                                                | (t0, t1) <- FO_OUT\n                                                ]\n                    funcs : [_]([16] -> [16] -> ([16], [16]))\n          funcs = [\\t0 t1 -> (t0 ^ (EK @ k), t1),\n                   \\t0 t1 -> (FI t0 (EK @ ((k + 5) % 8 + 8)), t1),\n                   \\t0 t1 -> (t0 ^ t1, t1),\n                   \\t0 t1 -> (t0, t1 ^ (EK @ ((k + 2) % 8))),\n                   \\t0 t1 -> (t0, FI t1 (EK @ ((k + 1) % 8 + 8))),\n                   \\t0 t1 -> (t0, t1 ^ t0),\n                   \\t0 t1 -> (t0 ^ EK @ ((k + 7) % 8), t1),\n                   \\t0 t1 -> (FI t0 (EK @ ((k + 3) % 8 + 8)), t1),\n                   \\t0 t1 -> (t0 ^ t1, t1),\n                   \\t0 t1 -> (t0, t1 ^ EK @ ((k + 4) % 8))\n                  ]\n\nFI : [16] -> [16] -> [16]\nFI FI_IN FI_KEY = (FI_OUT ! 0).1 # (FI_OUT ! 0).0\n    where FI_OUT = [(take FI_IN, drop FI_IN)] # [ f d9 d7\n                                                | f        <- funcs\n                                                | (d9, d7) <- FI_OUT\n                                                ]\n                              funcs : [_]([9] -> [7] -> ([9], [7]))\n          funcs = [\\d9 d7 -> ((S9 @ d9) ^ (extend d7), d7),\n                   \\d9 d7 -> (d9, drop (extend (S7 @ d7) ^ d9)),\n                   \\d9 d7 -> (d9, d7 ^ drop (FI_KEY >> 9)),\n                   \\d9 d7 -> (d9 ^ drop FI_KEY, d7),\n                   \\d9 d7 -> ((S9 @ d9) ^ (extend d7), d7)\n                  ]\n\nS7 : [_][7]\nS7 = [27,  50,  51,  90,  59,  16,  23,  84,  91,  26, 114, 115, 107,\n      44, 102,  73,  31,  36,  19, 108,  55,  46,  63,  74,  93,  15,\n      64,  86,  37,  81,  28,   4,  11,  70,  32,  13, 123,  53,  68,\n      66,  43,  30,  65,  20,  75, 121,  21, 111,  14,  85,   9,  54,\n     116,  12, 103,  83,  40,  10, 126,  56,   2,   7,  96,  41,  25,\n      18, 101,  47,  48,  57,   8, 104,  95, 120,  42,  76, 100,  69,\n     117,  61,  89,  72,   3,  87, 124,  79,  98,  60,  29,  33,  94,\n      39, 106, 112,  77,  58,   1, 109, 110,  99,  24, 119,  35,   5,\n      38, 118,   0,  49,  45, 122, 127,  97,  80,  34,  17,   6,  71,\n      22,  82,  78, 113,  62, 105,  67,  52,  92,  88, 125]\n\nS9 : [_][9]\nS9 = [451, 203, 339, 415, 483, 233, 251,  53, 385, 185, 279, 491, 307,\n        9,  45, 211, 199, 330,  55, 126, 235, 356, 403, 472, 163, 286,\n       85,  44,  29, 418, 355, 280, 331, 338, 466,  15,  43,  48, 314,\n      229, 273, 312, 398,  99, 227, 200, 500,  27,   1, 157, 248, 416,\n      365, 499,  28, 326, 125, 209, 130, 490, 387, 301, 244, 414, 467,\n      221, 482, 296, 480, 236,  89, 145,  17, 303,  38, 220, 176, 396,\n      271, 503, 231, 364, 182, 249, 216, 337, 257, 332, 259, 184, 340,\n      299, 430,  23, 113,  12,  71,  88, 127, 420, 308, 297, 132, 349,\n      413, 434, 419,  72, 124,  81, 458,  35, 317, 423, 357,  59,  66,\n      218, 402, 206, 193, 107, 159, 497, 300, 388, 250, 406, 481, 361,\n      381,  49, 384, 266, 148, 474, 390, 318, 284,  96, 373, 463, 103,\n      281, 101, 104, 153, 336,   8,   7, 380, 183,  36,  25, 222, 295,\n      219, 228, 425,  82, 265, 144, 412, 449,  40, 435, 309, 362, 374,\n      223, 485, 392, 197, 366, 478, 433, 195, 479,  54, 238, 494, 240,\n      147,  73, 154, 438, 105, 129, 293,  11,  94, 180, 329, 455, 372,\n       62, 315, 439, 142, 454, 174,  16, 149, 495,  78, 242, 509, 133,\n      253, 246, 160, 367, 131, 138, 342, 155, 316, 263, 359, 152, 464,\n      489,   3, 510, 189, 290, 137, 210, 399,  18,  51, 106, 322, 237,\n      368, 283, 226, 335, 344, 305, 327,  93, 275, 461, 121, 353, 421,\n      377, 158, 436, 204,  34, 306,  26, 232,   4, 391, 493, 407,  57,\n      447, 471,  39, 395, 198, 156, 208, 334, 108,  52, 498, 110, 202,\n       37, 186, 401, 254,  19, 262,  47, 429, 370, 475, 192, 267, 470,\n      245, 492, 269, 118, 276, 427, 117, 268, 484, 345,  84, 287,  75,\n      196, 446, 247,  41, 164,  14, 496, 119,  77, 378, 134, 139, 179,\n      369, 191, 270, 260, 151, 347, 352, 360, 215, 187, 102, 462, 252,\n      146, 453, 111,  22,  74, 161, 313, 175, 241, 400,  10, 426, 323,\n      379,  86, 397, 358, 212, 507, 333, 404, 410, 135, 504, 291, 167,\n      440, 321,  60, 505, 320,  42, 341, 282, 417, 408, 213, 294, 431,\n       97, 302, 343, 476, 114, 394, 170, 150, 277, 239,  69, 123, 141,\n      325,  83,  95, 376, 178,  46,  32, 469,  63, 457, 487, 428,  68,\n       56,  20, 177, 363, 171, 181,  90, 386, 456, 468,  24, 375, 100,\n      207, 109, 256, 409, 304, 346,   5, 288, 443, 445, 224,  79, 214,\n      319, 452, 298,  21,   6, 255, 411, 166,  67, 136,  80, 351, 488,\n      289, 115, 382, 188, 194, 201, 371, 393, 501, 116, 460, 486, 424,\n      405,  31,  65,  13, 442,  50,  61, 465, 128, 168,  87, 441, 354,\n      328, 217, 261,  98, 122,  33, 511, 274, 264, 448, 169, 285, 432,\n      422, 205, 243,  92, 258,  91, 473, 324, 502, 173, 165,  58, 459,\n      310, 383,  70, 225,  30, 477, 230, 311, 506, 389, 140, 143,  64,\n      437, 190, 120,   0, 172, 272, 350, 292,   2, 444, 162, 234, 112,\n      508, 278, 348,  76, 450]\n\nFL : [32] -> [8] -> [32][16] -> [32]\nFL FL_IN k EK =\n    if isEven k then\n        d0_even # d1_even\n        where d1_even = d1 ^ (d0 && (EK @ (k \/ 2)))\n              d0_even = d0 ^ (d1_even || (EK @ ((k \/ 2 + 6) % 8 + 8)))\n    else\n        d0_odd # d1_odd\n        where d1_odd = d1 ^ (d0 && (EK @ (((k - 1) \/ 2 + 2) % 8 + 8)))\n              d0_odd = d0 ^ (d1_odd || (EK @ (((k - 1) \/ 2 + 4) % 8)))\n    where         d0 : [16]\n        d0 = take FL_IN\n                d1 : [16]\n        d1 = drop FL_IN\n\nFLINV : [32] -> [8] -> [32][16] -> [32]\nFLINV FL_IN k EK =\n    if isEven k then\n        d0_even # d1_even\n        where d0_even = d0 ^ (d1 || (EK @ ((k \/ 2 + 6) % 8 + 8)))\n              d1_even = d1 ^ (d0_even && (EK @ (k \/ 2)))\n    else\n        d0_odd # d1_odd\n        where d0_odd = d0 ^ (d1 || (EK @ (((k - 1) \/ 2 + 4) % 8)))\n              d1_odd = d1 ^ (d0_odd && (EK @ (((k - 1) \/ 2 + 2) % 8 + 8)))\n    where         d0 : [16]\n        d0 = take FL_IN\n                d1 : [16]\n        d1 = drop FL_IN\n\nmisty1Encrypt : [64] -> [32][16] -> [64]\nmisty1Encrypt P EK = (C ! 0).1 # (C ! 0).0\n    where\n                        C = [(take P, drop P)] # [ f D0 D1\n                                 | f        <- funcs\n                                 | (D0, D1) <- C\n                                 ]\n        funcs : [_]([32] -> [32] -> ([32], [32]))\n        funcs = [                 \\D0 D1 -> (FL D0 0 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 1 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 0 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 1 EK), D1),\n                                  \\D0 D1 -> (FL D0 2 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 3 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 2 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 3 EK), D1),\n                                  \\D0 D1 -> (FL D0 4 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 5 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 4 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 5 EK), D1),\n                                  \\D0 D1 -> (FL D0 6 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 7 EK),\n                 \\D0 D1 -> (D0, D1 ^ (FO D0 6 EK)),\n                                  \\D0 D1 -> (D0 ^ (FO D1 7 EK), D1),\n                                  \\D0 D1 -> (FL D0 8 EK, D1),\n                 \\D0 D1 -> (D0, FL D1 9 EK)\n                ]\n\nmisty1Decrypt : [64] -> [32][16] -> [64]\nmisty1Decrypt C EK = (P ! 0).0 # (P ! 0).1\n    where P = [(drop C, take C)] # [ f D0 D1\n                                   | f        <- funcs\n                                   | (D0, D1) <- P\n                                   ]\n          funcs : [_]([32] -> [32] -> ([32], [32]))\n          funcs = [\\D0 D1 -> (FLINV D0 8 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 9 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 7 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 6 EK)),\n                   \\D0 D1 -> (FLINV D0 6 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 7 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 5 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 4 EK)),\n                   \\D0 D1 -> (FLINV D0 4 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 5 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 3 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 2 EK)),\n                   \\D0 D1 -> (FLINV D0 2 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 3 EK),\n                   \\D0 D1 -> (D0 ^ (FO D1 1 EK), D1),\n                   \\D0 D1 -> (D0, D1 ^ (FO D0 0 EK)),\n                   \\D0 D1 -> (FLINV D0 0 EK, D1),\n                   \\D0 D1 -> (D0, FLINV D1 1 EK)\n                  ]\n\nextend : {total, n} (fin total, fin n, total >= n) => [n] -> [total]\nextend n = zero # n\n\nisEven : {a} (fin a) => [a] -> Bool\nisEven n = ~(n ! 0)\n\nproperty testMisty1Encrypt = [ misty1Encrypt block EK\n                             | block <- plaintext\n                             ] == ciphertext\n    where EK         = keySchedule key\n          key        = [0x00, 0x11 .. 0xff]\n          plaintext  = [0x0123456789abcdef, 0xfedcba9876543210]\n          ciphertext = [0x8b1da5f56ab3d07c, 0x04b68240b13be95d]\n\nproperty misty1Correct pt key = misty1Decrypt (misty1Encrypt pt EK) EK == pt\n    where EK = keySchedule key\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/Keys.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Keys that imports curve operations, BLAKE2s, scrypt, and Base58 utilities, and contains the following definitions: (1) a type alias for a MiniLock identifier as a sequence of 46 8-bit values; (2) a function that, given a public Curve25519 key, computes a 1-byte BLAKE2s checksum of the key, appends it to the key bytes, and Base58-encodes the result to produce a MiniLock identifier; (3) a function that, given a MiniLock identifier, Base58-decodes it, splits into 33 bytes, extracts the first byte as the received checksum, the remaining 32 bytes as the public key, recomputes the 1-byte BLAKE2s checksum of the public key, and returns a pair of a boolean indicating checksum equality and the public key; (4) a polymorphic function that takes n bytes (with constraints 1 <= n <= 46) and left-pads them with the Base58 zero-character byte to produce exactly 46 bytes; (5) a function that, given password bytes and salt bytes (with finite size parameters and constraints that the password length parameter is at most 64 and four times the salt length parameter has width at most 32), derives a private Curve25519 key using scrypt with cost parameters N=2^1 and r=8 applied to the 32-byte BLAKE2s digest of the password, computes the corresponding public key over the Curve25519 base point, and returns the MiniLock identifier from the public key together with the private key; (6) test constants for a sample password, email, MiniLock identifier, private key bytes, and derived public key; and (7) define a property that asserts all of the following hold simultaneously: decoding the test identifier yields a public key equal to the derived test public key, encoding the derived test public key yields the test identifier, the test identifier matches its expected literal, and the test private key matches its expected byte literal."},{"role":"assistant","content":"```cryptol\nmodule Keys where\n\nimport CfrgCurves\nimport Blake2s\nimport SCrypt\nimport Base58\n\ntype MinilockID = [46][8]\n\nencodeID : Public25519 -> MinilockID\nencodeID pub = base58enc (join (pub # [h]))\n  where\n  h = blake2s `{nn=1} pub : [8]\n\ndecodeID : MinilockID -> (Bit,Public25519)\ndecodeID ident = (hComp == hRecv, key)\n where\n  bs    = split (base58dec ident)  : [33][8]\n  hRecv = bs ! 0\n  hComp = blake2s `{nn=1} key      : [8]\n  key   = take bs                  : [32][8]\n\nmkFullLengthID : {n} (46 >= n, n>= 1) => [n][8] -> MinilockID\nmkFullLengthID n = drop (['1' | _ <- [0..45] : [_][8]]  # n)\n\nmkID : {passBytes, saltBytes}\n       ( fin passBytes, fin saltBytes\n       , 64 >= width passBytes\n       , 32 >= width (4*saltBytes)\n       )\n    => [passBytes][8] -> [saltBytes][8] -> (MinilockID,Private25519)\nmkID pw email = (encodeID pub,priv)\n  where\n    priv : Private25519\n  priv = SCrypt `{N=2^^1,r=8} (split (blake2s `{nn=32} pw)) email\n    pub  = Curve25519 priv basePoint25519\n\ntestPass = \"some bears eat all the honey in the jar\"\ntestEmail = \"example@example.com\"\n\ntestID : MinilockID\ntestID = mkFullLengthID \"28ZvW9rqRqvqpFTtHnusUntRqrxb4qqZAaNAd3QsqjSsXq\"\n\ntestID_computed = \"28ZvW9rqRqvqpFTtHnusUntRqrxb4qqZAaNAd3QsqjSsXq\"  testPriv_computed =\n  [0x12, 0x86, 0xe0, 0x18, 0xc6, 0x68, 0x34, 0x96, 0x09, 0x2e, 0x53,\n   0x32, 0x37, 0x76, 0x80, 0x3c, 0x30, 0xb4, 0x75, 0x2d, 0xd7, 0x70,\n   0xea, 0xa9, 0x6f, 0x0d, 0xda, 0x25, 0xc7, 0xfe, 0x28, 0x1f]\n\ntestPriv = [0x12, 0x86, 0xe0, 0x18, 0xc6, 0x68, 0x34, 0x96, 0x09, 0x2e, 0x53, 0x32, 0x37, 0x76, 0x80, 0x3c, 0x30, 0xb4, 0x75, 0x2d, 0xd7, 0x70,0xea, 0xa9, 0x6f, 0x0d, 0xda, 0x25, 0xc7, 0xfe, 0x28, 0x1f]\n\ntestPub = Curve25519 testPriv basePoint25519\nproperty kat_pub_id_eq = testPub == (decodeID testID).1 \/\\ encodeID testPub == testID \/\\ testID == testID_computed \/\\ testPriv == testPriv_computed\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named AES that contains the following definitions, imports, parameters, and property, matching types and behavior: 1) Import the algorithm module under the alias AES, binding its mode type to a numeric parameter m and selecting the forward and inverse round functions for encryption and decryption, respectively. 2) Import the key expansion module, binding its Nk and Nr type parameters to those provided by the AES package. Also import the T-box definitions used by the algorithm. 3) Declare numeric type parameters m and k with the constraint that k equals 128 plus 64 times m, and that m is at most 2. 4) Define type synonyms EncKey and DecKey that both refer to the algorithm\u2019s key schedule type. 5) Provide the following function signatures and behaviors over bitvectors: - encrypt: takes a k-bit key and a 128-bit plaintext and returns a 128-bit ciphertext by first deriving an encryption schedule from the key and then applying the algorithm\u2019s encryption using that schedule. - decrypt: takes a k-bit key and a 128-bit ciphertext and returns a 128-bit plaintext by first deriving a decryption schedule from the key and then applying the algorithm\u2019s decryption using that schedule. - expandKeyEnc: takes a k-bit key and returns an EncKey using the key expansion routine. - encryptWithSchedule: takes an EncKey and a 128-bit block and returns the encrypted 128-bit block by delegating to the algorithm\u2019s encrypt function. - expandKeyDec: takes a k-bit key and returns an EncKey produced by applying the decryption key constructor to the expanded key. - decryptWithSchedule: takes a DecKey and a 128-bit block and returns the decrypted 128-bit block by delegating to the algorithm\u2019s decrypt function. 6) Define a property that, for any key and 128-bit block, decrypting the result of encrypting that block with the same key yields the original block."},{"role":"assistant","content":"```cryptol\nmodule AES where\n\nimport AES::Algorithm as AES where\n  type Mode = m\n  encRound = AESRound\n  decRound = AESInvRound\n\nimport AES::ExpandKey where\n  type Nk = AES::Nk\n  type Nr = AES::Nr\n\nimport AES::TBox\n\nparameter\n\n  type m : #\n  type k : #\n  type constraint (k == 128 + m * 64, 2 >= m)\n\ntype EncKey = AES::KeySchedule\ntype DecKey = AES::KeySchedule\n\nencrypt : [k] -> [128] -> [128]\nencrypt k = encryptWithSchedule (expandKeyEnc k)\n\ndecrypt : [k] -> [128] -> [128]\ndecrypt k = decryptWithSchedule (expandKeyDec k)\n\nexpandKeyEnc : [k] -> EncKey\nexpandKeyEnc = expandKey\n\nencryptWithSchedule : EncKey -> [128] -> [128]\nencryptWithSchedule = AES::encrypt\n\nexpandKeyDec : [k] -> EncKey\nexpandKeyDec k = makeDecKey (expandKey k)\n\ndecryptWithSchedule : DecKey -> [128] -> [128]\ndecryptWithSchedule = AES::decrypt\n\nproperty test k pt = decrypt k (encrypt k pt) == pt\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES_GCM_SIV_Test.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Create a Cryptol test specification that mirrors this file\u2019s behavior. Do the following:\n- Import the AES-GCM-SIV implementation multiple times under distinct aliases, each with Mode fixed to the 128-bit (0) or 256-bit (1) key variant, and with the AAD element bit-width fixed as required (including 0, 8, 40, 56, 80, 96, 120, 144, 160, 200, 240, 280).\n- For each alias, define properties named test0 through test49. Each property must be a Boolean equality that applies the aes_gcm_siv encryption function to a record containing a fixed key (128 or 256 bits according to Mode), a 96-bit nonce, an AAD value (possibly empty or a sequence of words whose element width matches the module\u2019s AAD parameter), and a plaintext message (ranging from empty to multiple 128-bit blocks). Assert that the returned ciphertext with its 128-bit tag equals the corresponding provided constant (concatenated where shown).\n- Cover both key sizes (128 and 256 bits), various AAD widths (including a 56-bit case derived from ASCII bytes), empty\/non-empty AAD, empty\/plaintext of different lengths, and multi-block messages. Include edge cases with all-zero inputs and boundary outputs.\n- Also add one final binding named test50 that invokes the 128-bit, empty-AAD variant on a long multi-block message using a fixed key and nonce; it produces the ciphertext value but does not assert equality with a constant.\n- Clearly state types: key is [128] when Mode=0 and [256] when Mode=1; nonce is [96]; AAD elements are [AAD]; msg is a sequence of 8-bit bytes or concatenated blocks; aes_gcm_siv returns the ciphertext concatenated with a 128-bit authentication tag.\nDo not provide solutions; only declare the properties and their exact equalities as specified."},{"role":"assistant","content":"```cryptol\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_56 where\n  type Mode = 0\n  type AAD = 56\n\nproperty test0 =\n  AES_GCM_SIV_0_56::aes_gcm_siv\n    { key   = 0xee8e1ed9ff2540ae8f2ba9f50bc2f27c\n    , nonce = 0x752abad3e0afb5f434dc4310\n    , aad   = join \"example\"\n    , msg   = join \"Hello world\"\n    }\n  ==\n  0x5d349ead175ef6b1def6fd #\n  0x4fbcdeb7e4793f4a1d7e4faa70100af1\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_0 where\n  type Mode = 0\n  type AAD = 0\n\nproperty test1 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = []\n    }\n  ==\n  0xdc20e2d83f25705bb49e439eca56de25\n\nproperty test2 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x0100000000000000\n    }\n  ==\n  0xb5d839330ac7b786578782fff6013b81 #\n  0x5b287c22493a364c\n\nproperty test3 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x010000000000000000000000\n    }\n  ==\n  0x7323ea61d05932260047d942a4978db3 #\n  0x57391a0bc4fdec8b0d106639\n\nproperty test4 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000\n    }\n  ==\n  0x743f7c8077ab25f8624e2e948579cf77 #\n  0x303aaf90f6fe21199c6068577437a0c4\n\nproperty test5 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000\n    }\n  ==\n  0x84e07e62ba83a6585417245d7ec413a9 #\n  0xfe427d6315c09b57ce45f2e3936a9445 #\n  0x1a8e45dcd4578c667cd86847bf6155ff\n\nproperty test6 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000\n    }\n  ==\n  0x3fd24ce1f5a67b75bf2351f181a475c7 #\n  0xb800a5b4d3dcf70106b1eea82fa1d64d #\n  0xf42bf7226122fa92e17a40eeaac1201b #\n  0x5e6e311dbf395d35b0fe39c2714388f8\n\nproperty test7 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = []\n    , msg   = 0x01000000000000000000000000000000 #\n              0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000\n    }\n  ==\n  0x2433668f1058190f6d43e360f4f35cd8 #\n  0xe475127cfca7028ea8ab5c20f7ab2af0 #\n  0x2516a2bdcbc08d521be37ff28c152bba #\n  0x36697f25b4cd169c6590d1dd39566d3f #\n  0x8a263dd317aa88d56bdf3936dba75bb8\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_8 where\n  type Mode = 0\n  type AAD = 8\n\nproperty test8 =\n AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x0200000000000000\n    }\n  ==\n  0x1e6daba35669f4273b0a1a2560969cdf #\n  0x790d99759abd1508\n\nproperty test9 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x020000000000000000000000\n    }\n  ==\n  0x296c7889fd99f41917f4462008299c51 #\n  0x02745aaa3a0c469fad9e075a\n\nproperty test10 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000\n    }\n  ==\n  0xe2b0c5da79a901c1745f700525cb335b #\n  0x8f8936ec039e4e4bb97ebd8c4457441f\n\nproperty test11 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000\n    }\n  ==\n  0x620048ef3c1e73e57e02bb8562c416a3 #\n  0x19e73e4caac8e96a1ecb2933145a1d71 #\n  0xe6af6a7f87287da059a71684ed3498e1\n\nproperty test12 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000\n    }\n  ==\n  0x50c8303ea93925d64090d07bd109dfd9 #\n  0x515a5a33431019c17d93465999a8b005 #\n  0x3201d723120a8562b838cdff25bf9d1e #\n  0x6a8cc3865f76897c2e4b245cf31c51f2\n\nproperty test13 =\n  AES_GCM_SIV_0_8::aes_gcm_siv\n    { key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , aad   = 0x01\n    , msg   = 0x02000000000000000000000000000000 #\n              0x03000000000000000000000000000000 #\n              0x04000000000000000000000000000000 #\n              0x05000000000000000000000000000000\n    }\n  ==\n  0x2f5c64059db55ee0fb847ed513003746 #\n  0xaca4e61c711b5de2e7a77ffd02da42fe #\n  0xec601910d3467bb8b36ebbaebce5fba3 #\n  0x0d36c95f48a3e7980f0e7ac299332a80 #\n  0xcdc46ae475563de037001ef84ae21744\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_96 where\n  type Mode = 0\n  type AAD = 96\n\nproperty test14 =\n  AES_GCM_SIV_0_96::aes_gcm_siv\n    { msg = 0x02000000\n    , aad = 0x010000000000000000000000\n    , key = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0xa8fe3e8707eb1f84fb28f8cb73de8e99 #\n  0xe2f48a14\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_144 where\n  type Mode = 0\n  type AAD = 144\n\nproperty test15 =\n  AES_GCM_SIV_0_144::aes_gcm_siv\n    { msg = 0x03000000000000000000000000000000 #\n            0x04000000\n    , aad = 0x01000000000000000000000000000000 #\n            0x0200\n    , key = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0x6bb0fecf5ded9b77f902c7d5da236a43 #\n  0x91dd029724afc9805e976f451e6d87f6 #\n  0xfe106514\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_160 where\n  type Mode = 0\n  type AAD = 160\n\nproperty test16 =\n  AES_GCM_SIV_0_160::aes_gcm_siv\n    { msg =   0x03000000000000000000000000000000 #\n              0x0400\n    , aad   = 0x01000000000000000000000000000000 #\n              0x02000000\n    , key   = 0x01000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    }\n  ==\n  0x44d0aaf6fb2f1f34add5e8064e83e12a #\n  0x2adabff9b2ef00fb47920cc72a0c0f13 #\n  0xb9fd\n\nproperty test16' =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0xe66021d5eb8e4f4066d4adb9c33560e4\n   , nonce = 0xf46e44bb3da0015c94f70887\n   }\n   == 0xa4194b79071b01a87d65f706e3949578\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_40 where\n  type Mode = 0\n  type AAD = 40\n\nproperty test17 =\n  AES_GCM_SIV_0_40::aes_gcm_siv\n   { msg = 0x7a806c\n   , aad = 0x46bb91c3c5\n   , key = 0x36864200e0eaf5284d884a0e77d31646\n   , nonce = 0xbae8e37fc83441b16034566b\n   }\n   == 0xaf60eb711bd85bc1e4d3e0a462e074ee #\n      0xa428a8\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_80 where\n  type Mode = 0\n  type AAD = 80\n\nproperty test18 =\n  AES_GCM_SIV_0_80::aes_gcm_siv\n   { msg = 0xbdc66f146545\n   , aad = 0xfc880c94a95198874296\n   , key = 0xaedb64a6c590bc84d1a5e269e4b47801\n   , nonce = 0xafc0577e34699b9e671fdd4f\n   }\n   == 0xbb93a3e34d3cd6a9c45545cfc11f03ad #\n      0x743dba20f966\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_120 where\n  type Mode = 0\n  type AAD = 120\n\nproperty test19 =\n  AES_GCM_SIV_0_120::aes_gcm_siv\n   { msg = 0x1177441f195495860f\n   , aad = 0x046787f3ea22c127aaf195d1894728\n   , key = 0xd5cc1fd161320b6920ce07787f86743b\n   , nonce = 0x275d1ab32f6d1f0434d8848c\n   }\n   == 0x4f37281f7ad12949d01d02fd0cd174c8 #\n      0x4fc5dae2f60f52fd2b\n\nproperty test20 =\n  AES_GCM_SIV_0_160::aes_gcm_siv\n   { msg = 0x9f572c614b4745914474e7c7\n   , aad = 0xc9882e5386fd9f92ec489c8fde2be2cf #\n           0x97e74e93\n   , key = 0xb3fed1473c528b8426a582995929a149\n   , nonce = 0x9e9ad8780c8d63d0ab4149c0\n   }\n   == 0xf54673c5ddf710c745641c8bc1dc2f87 #\n      0x1fb7561da1286e655e24b7b0\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_200 where\n  type Mode = 0\n  type AAD = 200\n\nproperty test21 =\n  AES_GCM_SIV_0_200::aes_gcm_siv\n   { msg = 0x0d8c8451178082355c9e940fea2f58\n   , aad = 0x2950a70d5a1db2316fd568378da107b5 #\n           0x2b0da55210cc1c1b0a\n   , key = 0x2d4ed87da44102952ef94b02b805249b\n   , nonce = 0xac80e6f61455bfac8308a2d4\n   }\n   == 0xc9ff545e07b88a015f05b274540aa183 #\n           0xb3449b9f39552de99dc214a1190b0b\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_240 where\n  type Mode = 0\n  type AAD = 240\n\nproperty test22 =\n  AES_GCM_SIV_0_240::aes_gcm_siv\n   { msg = 0x6b3db4da3d57aa94842b9803a96e07fb #\n           0x6de7\n   , aad = 0x1860f762ebfbd08284e421702de0de18 #\n           0xbaa9c9596291b08466f37de21c7f\n   , key = 0xbde3b2f204d1e9f8b06bc47f9745b3d1\n   , nonce = 0xae06556fb6aa7890bebc18fe\n   }\n   == 0x6298b296e24e8cc35dce0bed484b7f30 #\n           0xd5803e377094f04709f64d7b985310a4 #\n           0xdb84\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_0_280 where\n  type Mode = 0\n  type AAD = 280\n\nproperty test23 =\n  AES_GCM_SIV_0_280::aes_gcm_siv\n   { msg = 0xe42a3c02c25b64869e146d7b233987bd #\n           0xdfc240871d\n   , aad = 0x7576f7028ec6eb5ea7e298342a94d4b2 #\n           0x02b370ef9768ec6561c4fe6b7e7296fa #\n           0x859c21\n   , key = 0xf901cfe8a69615a93fdf7a98cad48179\n   , nonce = 0x6245709fb18853f68d833640\n   }\n   == 0x391cc328d484a4f46406181bcd62efd9 #\n      0xb3ee197d052d15506c84a9edd65e13e9 #\n      0xd24a2a6e70\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_0 where\n  type Mode = 1\n  type AAD = 0\n\nproperty test24 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x07f5f4169bbf55a8400cd47ea6fd400f\n\nproperty test25 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x0100000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc2ef328e5c71c83b843122130f7364b7 #\n      0x61e0b97427e3df28\n\nproperty test26 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x010000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x9aab2aeb3faa0a34aea8e2b18ca50da9 #\n      0xae6559e48fd10f6e5c9ca17e\n\nproperty test27 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x85a01b63025ba19b7fd3ddfc033b3e76 #\n      0xc9eac6fa700942702e90862383c6c366\n\nproperty test28 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x4a6a9db4c8c6549201b9edb53006cba8 #\n      0x21ec9cf850948a7c86c68ac7539d027f #\n      0xe819e63abcd020b006a976397632eb5d\n\nproperty test29 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n\n   == 0xc00d121893a9fa603f48ccc1ca3c57ce #\n      0x7499245ea0046db16c53c7c66fe717e3 #\n      0x9cf6c748837b61f6ee3adcee17534ed5 #\n      0x790bc96880a99ba804bd12c0e6a22cc4\n\nproperty test30 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x01000000000000000000000000000000 #\n           0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000\n   , aad = []\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc2d5160a1f8683834910acdafc41fbb1 #\n      0x632d4a353e8b905ec9a5499ac34f96c7 #\n      0xe1049eb080883891a4db8caaa1f99dd0 #\n      0x04d80487540735234e3744512c6f90ce #\n      0x112864c269fc0d9d88c61fa47e39aa08\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_8 where\n  type Mode = 1\n  type AAD = 8\n\nproperty test31 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x0200000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x1de22967237a813291213f267e3b452f #\n      0x02d01ae33e4ec854\n\nproperty test32 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x020000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x163d6f9cc1b346cd453a2e4cc1a4a19a #\n      0xe800941ccdc57cc8413c277f\n\nproperty test33 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc91545823cc24f17dbb0e9e807d5ec17 #\n      0xb292d28ff61189e8e49f3875ef91aff7\n\nproperty test34 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x07dad364bfc2b9da89116d7bef6daaaf #\n      0x6f255510aa654f920ac81b94e8bad365 #\n      0xaea1bad12702e1965604374aab96dbbc\n\nproperty test35 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0xc67a1f0f567a5198aa1fcc8e3f213143 #\n      0x36f7f51ca8b1af61feac35a86416fa47 #\n      0xfbca3b5f749cdf564527f2314f42fe25 #\n      0x03332742b228c647173616cfd44c54eb\n\nproperty test36 =\n  AES_GCM_SIV_1_8::aes_gcm_siv\n   { msg = 0x02000000000000000000000000000000 #\n           0x03000000000000000000000000000000 #\n           0x04000000000000000000000000000000 #\n           0x05000000000000000000000000000000\n   , aad = 0x01\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x67fd45e126bfb9a79930c43aad2d3696 #\n      0x7d3f0e4d217c1e551f59727870beefc9 #\n      0x8cb933a8fce9de887b1e40799988db1f #\n      0xc3f91880ed405b2dd298318858467c89 #\n      0x5bde0285037c5de81e5b570a049b62a0\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_96 where\n  type Mode = 1\n  type AAD = 96\n\nproperty test37 =\n  AES_GCM_SIV_1_96::aes_gcm_siv\n   { msg = 0x02000000\n   , aad = 0x010000000000000000000000\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x22b3f4cd1835e517741dfddccfa07fa4 #\n      0x661b74cf\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_144 where\n  type Mode = 1\n  type AAD = 144\n\nproperty test38 =\n  AES_GCM_SIV_1_144::aes_gcm_siv\n   { msg = 0x03000000000000000000000000000000 #\n           0x04000000\n   , aad = 0x01000000000000000000000000000000 #\n           0x0200\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x43dd0163cdb48f9fe3212bf61b201976 #\n      0x067f342bb879ad976d8242acc188ab59 #\n      0xcabfe307\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_160 where\n  type Mode = 1\n  type AAD = 160\n\nproperty test39 =\n  AES_GCM_SIV_1_160::aes_gcm_siv\n   { msg = 0x03000000000000000000000000000000 #\n           0x0400\n   , aad = 0x01000000000000000000000000000000 #\n           0x02000000\n   , key = 0x01000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x030000000000000000000000\n   }\n   == 0x462401724b5ce6588d5a54aae5375513 #\n      0xa075cfcdf5042112aa29685c912fc205 #\n      0x6543\n\nproperty test40 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = []\n   , aad = []\n   , key = 0xe66021d5eb8e4f4066d4adb9c33560e4 #\n           0xf46e44bb3da0015c94f7088736864200\n   , nonce = 0xe0eaf5284d884a0e77d31646\n   }\n   == 0x169fbb2fbf389a995f6390af22228a62\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_40 where\n  type Mode = 1\n  type AAD = 40\n\nproperty test41 =\n  AES_GCM_SIV_1_40::aes_gcm_siv\n   { msg = 0x671fdd\n   , aad = 0x4fbdc66f14\n   , key = 0xbae8e37fc83441b16034566b7a806c46 #\n           0xbb91c3c5aedb64a6c590bc84d1a5e269\n   , nonce = 0xe4b47801afc0577e34699b9e\n   }\n   == 0x0eaccb93da9bb81333aee0c785b240d3 #\n      0x19719d\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_80 where\n  type Mode = 1\n  type AAD = 80\n\nproperty test42 =\n  AES_GCM_SIV_1_80::aes_gcm_siv\n   { msg = 0x195495860f04\n   , aad = 0x6787f3ea22c127aaf195\n   , key = 0x6545fc880c94a95198874296d5cc1fd1 #\n           0x61320b6920ce07787f86743b275d1ab3\n   , nonce = 0x2f6d1f0434d8848c1177441f\n   }\n   == 0xa254dad4f3f96b62b84dc40c84636a5e #\n      0xc12020ec8c2c\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_120 where\n  type Mode = 1\n  type AAD = 120\n\nproperty test43 =\n  AES_GCM_SIV_1_120::aes_gcm_siv\n   { msg = 0xc9882e5386fd9f92ec\n   , aad = 0x489c8fde2be2cf97e74e932d4ed87d\n   , key = 0xd1894728b3fed1473c528b8426a58299 #\n           0x5929a1499e9ad8780c8d63d0ab4149c0\n   , nonce = 0x9f572c614b4745914474e7c7\n   }\n   == 0x0df9e308678244c44bc0fd3dc6628dfe #\n      0x55ebb0b9fb2295c8c2\n\nproperty test44 =\n  AES_GCM_SIV_1_160::aes_gcm_siv\n   { msg = 0x1db2316fd568378da107b52b\n   , aad = 0x0da55210cc1c1b0abde3b2f204d1e9f8 #\n           0xb06bc47f\n   , key = 0xa44102952ef94b02b805249bac80e6f6 #\n           0x1455bfac8308a2d40d8c845117808235\n   , nonce = 0x5c9e940fea2f582950a70d5a\n   }\n   == 0x8dbeb9f7255bf5769dd56692404099c2 #\n      0x587f64979f21826706d497d5\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_200 where\n  type Mode = 1\n  type AAD = 200\n\nproperty test45 =\n  AES_GCM_SIV_1_200::aes_gcm_siv\n   { msg = 0x21702de0de18baa9c9596291b08466\n   , aad = 0xf37de21c7ff901cfe8a69615a93fdf7a #\n           0x98cad481796245709f\n   , key = 0x9745b3d1ae06556fb6aa7890bebc18fe #\n           0x6b3db4da3d57aa94842b9803a96e07fb\n   , nonce = 0x6de71860f762ebfbd08284e4\n   }\n   == 0x793576dfa5c0f88729a7ed3c2f1bffb3 #\n      0x080d28f6ebb5d3648ce97bd5ba67fd\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_240 where\n  type Mode = 1\n  type AAD = 240\n\nproperty test46 =\n  AES_GCM_SIV_1_240::aes_gcm_siv\n   { msg = 0xb202b370ef9768ec6561c4fe6b7e7296 #\n           0xfa85\n   , aad = 0x9c2159058b1f0fe91433a5bdc20e214e #\n           0xab7fecef4454a10ef0657df21ac7\n   , key = 0xb18853f68d833640e42a3c02c25b6486 #\n           0x9e146d7b233987bddfc240871d7576f7\n   , nonce = 0x028ec6eb5ea7e298342a94d4\n   }\n   == 0x857e16a64915a787637687db4a951963 #\n      0x5cdd454fc2a154fea91f8363a39fec7d #\n      0x0a49\n\nimport Common::AES_GCM_SIV as AES_GCM_SIV_1_280 where\n  type Mode = 1\n  type AAD = 280\n\nproperty test47 =\n  AES_GCM_SIV_1_280::aes_gcm_siv\n   { msg = 0xced532ce4159b035277d4dfbb7db6296 #\n           0x8b13cd4eec\n   , aad = 0x734320ccc9d9bbbb19cb81b2af4ecbc3 #\n           0xe72834321f7aa0f70b7282b4f33df23f #\n           0x167541\n   , key = 0x3c535de192eaed3822a2fbbe2ca9dfc8 #\n           0x8255e14a661b8aa82cc54236093bbc23\n   , nonce = 0x688089e55540db1872504e1c\n   }\n   == 0x626660c26ea6612fb17ad91e8e767639 #\n      0xedd6c9faee9d6c7029675b89eaf4ba1d #\n      0xed1a286594\n\nproperty test48 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0x00000000000000000000000000000000 #\n           0x4db923dc793ee6497c76dcc03a98e108\n   , aad = []\n   , key = 0x00000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x000000000000000000000000\n   }\n   == 0xf3f80f2cf0cb2dd9c5984fcda908456c #\n      0xc537703b5ba70324a6793a7bf218d3ea #\n      0xffffffff000000000000000000000000\n\nproperty test49 =\n  AES_GCM_SIV_1_0::aes_gcm_siv\n   { msg = 0xeb3640277c7ffd1303c7a542d02d3e4c #\n           0x0000000000000000\n   , aad = []\n   , key = 0x00000000000000000000000000000000 #\n           0x00000000000000000000000000000000\n   , nonce = 0x000000000000000000000000\n   }\n   == 0x18ce4f0b8cb4d0cac65fea8f79257b20 #\n      0x888e53e72299e56dffffffff00000000 #\n      0x0000000000000000\n\nproperty test50 =\n  AES_GCM_SIV_0_0::aes_gcm_siv\n    { msg = 0x01000000000000000000000000000000 #\n            0x02000000000000000000000000000000 #\n            0x03000000000000000000000000000000 #\n            0x04000000000000000000000000000000 #\n            0x05000000000000000000000000000000 #\n            0x06000000000000000000000000000000 #\n            0x07000000000000000000000000000000 #\n            0x08000000000000000000000000000000 #\n            0x09000000000000000000000000000000 #\n            0x0a000000000000000000000000000000 #\n            0x0b000000000000000000000000000000 #\n            0x0c000000000000000000000000000000 #\n            0x0d000000000000000000000000000000 #\n            0x0e000000000000000000000000000000 #\n            0x0f000000000000000000000000000000 #\n            0x10000000000000000000000000000000\n    , nonce = 0x030000000000000000000000\n    , key = 0x01000000000000000000000000000000\n    , aad = []\n    }\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/GCM_AES_Tests.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named GCM_AES_Tests that contains the following definitions: (1) three parameterized imports of the AES block cipher as AES128, AES192, and AES256, with type parameters set for their respective key sizes; (2) twelve parameterized imports of the GCM construction specialized as GCM_128_96_0_128, GCM_128_96_160_128, GCM_128_64_160_128, GCM_128_480_160_128, GCM_192_96_0_128, GCM_192_96_160_128, GCM_192_64_160_128, GCM_192_480_160_128, GCM_256_96_0_128, GCM_256_96_160_128, GCM_256_64_160_128, and GCM_256_480_160_128, each setting K (128\/192\/256), IV (96\/64\/480), AAD (0 or 160), T = 128, and binding E to the corresponding AESX::encrypt function. Then define properties test1 through test18. Each property must assert that invoking the encrypt function from the appropriate GCM specialization on a fixed record of inputs {key, pt, iv, aad} yields a record {ct, tag} equal to the expected ciphertext and 128-bit authentication tag. Use the exact constants from the vectors in this file, representing multi-block values by bitvector concatenation and empty data as empty sequences. Ensure types match each specialization: key has K bits; iv has IV bits; aad has AAD bits (or is empty when AAD = 0); tag is 128 bits; pt and ct are byte-aligned bitvectors of the specified lengths. The only statements using the property keyword are these 18 assertions of equality. No additional behavior or definitions are required; the module must be directly checkable by a Cryptol solver."},{"role":"assistant","content":"```cryptol\nmodule GCM_AES_Tests where\n\nimport AES as AES128 where\n  type m = 0\n  type k = 128\n\nimport AES as AES192 where\n  type m = 1\n  type k = 192\n\nimport AES as AES256 where\n  type m = 2\n  type k = 256\n\nimport Common::GCM as GCM_128_96_0_128 where\n  type K = 128\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES128::encrypt\n\nproperty test1 =\n  GCM_128_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000\n    , pt  = []\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = []\n  , tag = 0x58e2fccefa7e3061367f1d57a4e7455a\n  }\n\nproperty test2 =\n  GCM_128_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = 0x0388dace60b6a392f328c2b971b2fe78\n  , tag = 0xab6e47d42cec13bdf53a67b21257bddf\n  }\n\nproperty test3 =\n  GCM_128_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct = 0x42831ec2217774244b7221b784d0d49c #\n         0xe3aa212f2c02a4e035c17e2329aca12e #\n         0x21d514b25466931c7d8f6a5aac84aa05 #\n         0x1ba30b396a0aac973d58e091473f5985\n  , tag = 0x4d5c2af327cd64a62cf35abd2ba6fab4\n  }\n\nimport Common::GCM as GCM_128_96_160_128 where\n  type K = 128\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test4 =\n  GCM_128_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct = 0x42831ec2217774244b7221b784d0d49c #\n         0xe3aa212f2c02a4e035c17e2329aca12e #\n         0x21d514b25466931c7d8f6a5aac84aa05 #\n         0x1ba30b396a0aac973d58e091\n  , tag = 0x5bc94fbc3221a5db94fae95ae7121a47\n  }\n\nimport Common::GCM as GCM_128_64_160_128 where\n  type K = 128\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test5 =\n  GCM_128_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbad\n    }\n  ==\n  { ct = 0x61353b4c2806934a777ff51fa22a4755 #\n         0x699b2a714fcdc6f83766e5f97b6c7423 #\n         0x73806900e49f24b22b097544d4896b42 #\n         0x4989b5e1ebac0f07c23f4598\n  , tag = 0x3612d2e79e3b0785561be14aaca2fccb\n  }\n\nimport Common::GCM as GCM_128_480_160_128 where\n  type K = 128\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES128::encrypt\n\nproperty test6 =\n  GCM_128_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0x9313225df88406e555909c5aff5269aa #\n            0x6a7a9538534f7da1e4c303d2a318a728 #\n            0xc3c0c95156809539fcf0e2429a6b5254 #\n            0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct = 0x8ce24998625615b603a033aca13fb894 #\n         0xbe9112a5c3a211a8ba262a3cca7e2ca7 #\n         0x01e4a9a4fba43c90ccdcb281d48c7c6f #\n         0xd62875d2aca417034c34aee5\n  , tag = 0x619cc5aefffe0bfa462af43c1699d050\n  }\n\nimport Common::GCM as GCM_192_96_0_128 where\n  type K = 192\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES192::encrypt\n\nproperty test7 =\n  GCM_192_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x0000000000000000\n    , pt  = []\n    , aad = []\n    , iv  = 0x000000000000000000000000\n    }\n  ==\n  { ct = []\n  , tag = 0xcd33b28ac773f74ba00ed1f312572435\n  }\n\nproperty test8 =\n  GCM_192_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x0000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct = 0x98e7247c07f0fe411c267e4384b0f600\n  , tag = 0x2ff58d80033927ab8ef4d4587514f0fb\n  }\n\nproperty test9 =\n  GCM_192_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv  = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct =  0x3980ca0b3c00e841eb06fac4872a2757 #\n          0x859e1ceaa6efd984628593b40ca1e19c #\n          0x7d773d00c144c525ac619d18c84a3f47 #\n          0x18e2448b2fe324d9ccda2710acade256\n  , tag = 0x9924a7c8587336bfb118024db8674a14\n  }\n\nimport Common::GCM as GCM_192_96_160_128 where\n  type K = 192\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test10 =\n  GCM_192_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct  = 0x3980ca0b3c00e841eb06fac4872a2757 #\n          0x859e1ceaa6efd984628593b40ca1e19c #\n          0x7d773d00c144c525ac619d18c84a3f47 #\n          0x18e2448b2fe324d9ccda2710\n  , tag = 0x2519498e80f1478f37ba55bd6d27618c\n  }\n\nimport Common::GCM as GCM_192_64_160_128 where\n  type K = 192\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test11 =\n  GCM_192_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0xcafebabefacedbad\n    }\n  ==\n  { ct  = 0x0f10f599ae14a154ed24b36e25324db8 #\n          0xc566632ef2bbb34f8347280fc4507057 #\n          0xfddc29df9a471f75c66541d4d4dad1c9 #\n          0xe93a19a58e8b473fa0f062f7\n  , tag = 0x65dcc57fcf623a24094fcca40d3533f8\n  }\n\nimport Common::GCM as GCM_192_480_160_128 where\n  type K = 192\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES192::encrypt\n\nproperty test12 =\n  GCM_192_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv  = 0x9313225df88406e555909c5aff5269aa #\n            0x6a7a9538534f7da1e4c303d2a318a728 #\n            0xc3c0c95156809539fcf0e2429a6b5254 #\n            0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct  = 0xd27e88681ce3243c4830165a8fdcf9ff #\n          0x1de9a1d8e6b447ef6ef7b79828666e45 #\n          0x81e79012af34ddd9e2f037589b292db3 #\n          0xe67c036745fa22e7e9b7373b\n  , tag = 0xdcf566ff291c25bbb8568fc3d376a6d9\n  }\n\nimport Common::GCM as GCM_256_96_0_128 where\n  type K = 256\n  type IV = 96\n  type AAD = 0\n  type T = 128\n  E = AES256::encrypt\n\nproperty test13 =\n  GCM_256_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x00000000000000000000000000000000\n    , pt  = []\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = []\n  , tag = 0x530f8afbc74536b9a963b4f1c4cb738b\n  }\n\nproperty test14 =\n  GCM_256_96_0_128::encrypt\n    { key = 0x00000000000000000000000000000000 #\n            0x00000000000000000000000000000000\n    , pt  = 0x00000000000000000000000000000000\n    , iv  = 0x000000000000000000000000\n    , aad = []\n    }\n  ==\n  { ct  = 0xcea7403d4d606b6e074ec5d3baf39d18\n  , tag = 0xd0d1c8a799996bf0265b98b5d48ab919\n  }\n\nproperty test15 =\n  GCM_256_96_0_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b391aafd255\n    , iv = 0xcafebabefacedbaddecaf888\n    , aad = []\n    }\n  ==\n  { ct  = 0x522dc1f099567d07f47f37a32a84427d #\n          0x643a8cdcbfe5c0c97598a2bd2555d1aa #\n          0x8cb08e48590dbb3da7b08b1056828838 #\n          0xc5f61e6393ba7a0abcc9f662898015ad\n  , tag = 0xb094dac5d93471bdec1a502270e3cc6c\n  }\n\nimport Common::GCM as GCM_256_96_160_128 where\n  type K = 256\n  type IV = 96\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test16 =\n  GCM_256_96_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0xcafebabefacedbaddecaf888\n    }\n  ==\n  { ct  = 0x522dc1f099567d07f47f37a32a84427d #\n          0x643a8cdcbfe5c0c97598a2bd2555d1aa #\n          0x8cb08e48590dbb3da7b08b1056828838 #\n          0xc5f61e6393ba7a0abcc9f662\n  , tag = 0x76fc6ece0f4e1768cddf8853bb2d551b\n  }\n\nimport Common::GCM as GCM_256_64_160_128 where\n  type K = 256\n  type IV = 64\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test17 =\n  GCM_256_64_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0xcafebabefacedbad\n    }\n  ==\n  { ct  = 0xc3762df1ca787d32ae47c13bf19844cb #\n          0xaf1ae14d0b976afac52ff7d79bba9de0 #\n          0xfeb582d33934a4f0954cc2363bc73f78 #\n          0x62ac430e64abe499f47c9b1f\n  , tag = 0x3a337dbf46a792c45e454913fe2ea8f2\n  }\n\nimport Common::GCM as GCM_256_480_160_128 where\n  type K = 256\n  type IV = 480\n  type AAD = 160\n  type T = 128\n  E = AES256::encrypt\n\nproperty test18 =\n  GCM_256_480_160_128::encrypt\n    { key = 0xfeffe9928665731c6d6a8f9467308308 #\n            0xfeffe9928665731c6d6a8f9467308308\n    , pt  = 0xd9313225f88406e5a55909c5aff5269a #\n            0x86a7a9531534f7da2e4c303d8a318a72 #\n            0x1c3c0c95956809532fcf0e2449a6b525 #\n            0xb16aedf5aa0de657ba637b39\n    , aad = 0xfeedfacedeadbeeffeedfacedeadbeef #\n            0xabaddad2\n    , iv = 0x9313225df88406e555909c5aff5269aa #\n           0x6a7a9538534f7da1e4c303d2a318a728 #\n           0xc3c0c95156809539fcf0e2429a6b5254 #\n           0x16aedbf5a0de6a57a637b39b\n    }\n  ==\n  { ct  = 0x5a8def2f0c9e53f1f75d7853659e2a20 #\n          0xeeb2b22aafde6419a058ab4f6f746bf4 #\n          0x0fc0c3b780f244452da3ebf1c5d82cde #\n          0xa2418997200ef82e44ae7e3f\n  , tag = 0xa44a8266ee1c8eb0c8b5d4cf5ae9f19a\n  }\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/SHA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named SHA that contains the following definitions: (1) Import the SHA256 module using the alias SHA256. (2) Define a function sha256 with a polymorphic size parameter n, constrained so that 64 is at least the bit-width of n, with type [n] -> [256]; implement it by delegating to the SHA function provided by the SHA256 module. (3) Define a helper function go with a polymorphic size parameter n, constrained so that 64 is at least the bit-width of 8*n, with type [n][8] -> [256]; it must join a sequence of bytes into a single bitvector and pass it to sha256. (4) Define a list sha256tests containing tuples (computed, expected), where computed is the result of go applied to several standard ASCII byte-sequence inputs, and expected is the corresponding 256-bit known-answer constant for each input. Include three classic SHA-256 known-answer cases. (5) Define a property katsPass that asserts all known-answer tests pass by constructing a vector of equality checks between each computed and expected digest from sha256tests, and asserting that this Boolean vector equals an all-ones vector of matching length (i.e., every comparison is True). Ensure all types, size constraints, and polymorphism match these requirements, and use only the described names for the definitions."},{"role":"assistant","content":"```cryptol\nmodule SHA where\n\nimport SHA256 as SHA256\n\nsha256 : {n} (64 >= width n) => [n] -> [256]\nsha256 = SHA256::sha\n\nproperty katsPass = ~zero == [test == kat | (test,kat) <- sha256tests ]\n\nsha256tests =\n  [ (go \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    ,   0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1\n    )\n\n  , (go \"\"\n    ,   0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n    )\n\n    , (go \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n      , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1\n      )\n\n    ]\n\n  where\n  go : {n} (64 >= width (8 * n)) => [n][8] -> [256]\n  go x = sha256 (join x)\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/SCrypt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named SCrypt that contains the following definitions: (1) Import the Salsa20 core and PBKDF2 components used by scrypt. (2) A function BlockMix parameterized by r with constraints that r is finite and r >= 1; its type maps a sequence of 2*r blocks, each 64 bytes (as bits), to a sequence of 2*r blocks; implement the scrypt block-mixing step using the Salsa20\/8 core, maintaining a rolling XOR state initialized from the first block, then output the blocks permuted with all even-indexed blocks followed by all odd-indexed blocks. (3) A function SMix parameterized by N and r with constraints N >= 1, r >= 1, and bit-width bounds sufficient for indexing and arithmetic on N; its type maps a 128*r-byte block (as bits) to a 128*r-byte block; allocate a table V of N states, iterate N times saving states and applying BlockMix, then iterate another N times where each step computes j from the first 64-byte sub-block (interpret as an integer modulo N), XORs the current state with V[j], applies BlockMix, and finally returns the resulting block. (4) A function MFcrypt parameterized by pwBytes, saltBytes, dkLen, r, N with finiteness\/width constraints for lengths and N; it takes a password (pwBytes bytes) and salt (saltBytes bytes) and returns a derived key of dkLen bytes by: first PBKDF2-HMAC with C=1 to produce B, applying SMix with parameters N and r to B, then PBKDF2-HMAC with C=1 to produce the dkLen-bit output using the SMix result as salt. (5) A function SCrypt with the same parameters as MFcrypt that simply delegates to MFcrypt. (6) A property named kats_pass that asserts the SCrypt result for N = 2^4, r = 1, empty password, and empty salt equals the standard 64-byte scrypt test vector for those parameters."},{"role":"assistant","content":"```cryptol\nmodule SCrypt where\n\nimport Salsa20\nimport PBKDF2\n\nBlockMix : {r} (fin r, r >= 1) =>  [2*r][64*8] -> [2*r][64*8]\nBlockMix B = ys @@ ([0,2..2*r-2] # [1,3..2*r-1])\n where\n  rs = [B!0] # [ join (Salsa20 `{r=8} (split (X ^ bi))) | X <- rs | bi <- B ]\n  ys = drop `{1} rs\n\nSMix : {N,r} ( fin r\n             , r >= 1\n             , N >= 1\n             , 512 >= width N\n             , 1 + width N >= width (N-1)\n             ) => [128 * 8 * r] -> [128 * 8 * r]\nSMix B = join (Xs ! 0)\n where\n  Vs = [split B] # [ BlockMix x | x <- Vs | _ <- [0..N-1] : [_][width N + 1]]\n  V  = take `{front=N} Vs\n\n  Xs : [N+1][2*r][64*8]\n  Xs = [Vs!0]    # [ (x' where\n                            j  = integerify x\n                            T  = x ^ (V@j)\n                            x' = BlockMix T)\n                        | x <- Xs | _ <- [0..N-1] : [_][width N + 1] ]\n\n  integerify w = (join (reverse (split `{each=8} (w!0)))) % `N\n\nMFcrypt : { pwBytes, saltBytes, dkLen, r, N }\n          ( fin dkLen\n          , 4*r >= 1\n          , 8 * dkLen >= 1\n          , 64 >= width (8 * pwBytes)\n          , 32 >= width (4 + saltBytes)\n          ,  512 >= width N, 1+width N >= width (N-1)\n          , 32 >= width ((255 + 8 * dkLen) \/ 256)\n          , 32 >= width (4 + 128 * r)\n          , N >= 1\n          )\n        => [pwBytes][8] -> [saltBytes][8] -> [dkLen][8]\nMFcrypt P S = split DK\n where\n  B  = pbkdf2 `{C=1} P S\n  B' = SMix `{N=N,r=r} B\n  DK = pbkdf2 `{dkLenBits=dkLen*8, C=1} P (split B')\n\nSCrypt : {pwBytes, saltBytes, dkBytes, r, N}\n         ( fin dkBytes, 4*r >= 1\n         , 8 * dkBytes >= 1\n         , 32 >= width ((255 + 8 * dkBytes) \/ 256)\n         , 64 >= width (8 * pwBytes)\n         , 512 >= width N, 1+width N >= width (N-1)\n         , 32 >= width (4 + saltBytes)\n         , 32 >= width (4 + 128 * r)\n         , N >= 1\n         )\n      => [pwBytes][8] -> [saltBytes][8] -> [dkBytes][8]\nSCrypt P S = MFcrypt `{r=r,N=N} P S\n\nproperty kats_pass = ~zero ==\n    [ SCrypt `{N=2^^4,r=1} \"\" \"\" ==\n            [ 0x77, 0xd6, 0x57, 0x62, 0x38, 0x65, 0x7b, 0x20\n            , 0x3b, 0x19, 0xca, 0x42, 0xc1, 0x8a, 0x04, 0x97\n            , 0xf1, 0x6b, 0x48, 0x44, 0xe3, 0x07, 0x4a, 0xe8\n            , 0xdf, 0xdf, 0xfa, 0x3f, 0xed, 0xe2, 0x14, 0x42\n            , 0xfc, 0xd0, 0x06, 0x9d, 0xed, 0x09, 0x48, 0xf8\n            , 0x32, 0x6a, 0x75, 0x3a, 0x0f, 0xc8, 0x1f, 0x17\n            , 0xe8, 0xd3, 0xe0, 0xfb, 0x2e, 0x0d, 0x36, 0x28\n            , 0xcf, 0x35, 0xe2, 0x0c, 0x38, 0xd1, 0x89, 0x06\n            ]\n    ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/SHA256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named SHA256 that contains the following definitions: (1) Ch and Maj, each taking three 32-bit words and returning a 32-bit word using bitwise logic. (2) Two \u201cbig sigma\u201d functions over 32-bit words that XOR several right-rotations, and two \u201csmall sigma\u201d functions that XOR right-rotations with logical right shifts. (3) A constant table K of 64 fixed 32-bit words (the standard SHA-256 round constants). (4) A polymorphic preprocess function over a bitvector of length msgLen with constraints that msgLen is finite and its width fits in 64 bits; it must append a single \u20181\u2019 bit, pad with zeros to reach length congruent to 448 mod 512, append the 64-bit big-endian original length, then split into 512-bit blocks. (5) An initial hash state H0 as eight fixed 32-bit words. (6) A message schedule function that maps 16 32-bit words to 64 32-bit words using the standard recursive combination with the small-sigma functions and prior words. (7) A compression function that takes an 8-word state and a 64-word schedule, computes 64 rounds using T1 and T2 derived from the big-sigma, choice, and majority functions, and returns the updated 8-word state by adding the working variables back into the input state. (8) A chaining function over a finite sequence of 512-bit blocks (expressed as arrays of 16 32-bit words) that iteratively applies the compression starting from H0. (9) A top-level function that accepts a finite sequence of bytes and returns a 256-bit digest, by preprocessing, scheduling, compressing, and joining the final state. Include kats, a list of (computed, expected) digest pairs for standard messages using the implemented hash. Define a property katsPass that asserts each computed digest equals its expected value for all pairs in kats."},{"role":"assistant","content":"```cryptol\nmodule SHA256 where\n\nCh : [32] -> [32] -> [32] -> [32]\nCh x y z = (x && y) ^ (~x && z)\n\nMaj : [32] -> [32] -> [32] -> [32]\nMaj x y z = (x && y) ^ (x && z) ^ (y && z)\n\nS0 : [32] -> [32]\nS0 x = (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)\n\nS1 : [32] -> [32]\nS1 x = (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)\n\ns0 : [32] -> [32]\ns0 x = (x >>> 7) ^ (x >>> 18) ^ (x >> 3)\n\ns1 : [32] -> [32]\ns1 x = (x >>> 17) ^ (x >>> 19) ^ (x >> 10)\n\nK : [64][32]\nK = [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n     ]\n\npreprocess : {msgLen}\n     ( fin msgLen\n     , 64 >= width msgLen                                   )\n     => [msgLen] -> [(msgLen + 65) \/^ 512][512]\npreprocess msg = split (msg # [True] # (zero:[(msgLen + 65) %^ 512]) # (`msgLen:[64]))\n\nH0 : [8][32]\nH0 = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n       0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]\n\nSHA256MessageSchedule : [16][32] -> [64][32]\nSHA256MessageSchedule M = W where\n    W = M # [ s1 (W@(j-2)) + (W@(j-7)) + s0 (W@(j-15)) + (W@(j-16)) | j <- [16 .. 63]:[_][8] ]\n\nSHA256Compress : [8][32] -> [64][32] -> [8][32]\nSHA256Compress H W = [as!0 + H@0, bs!0 + H@1, cs!0 + H@2, ds!0 + H@3, es!0 + H@4, fs!0 + H@5, gs!0 + H@6, hs!0 + H@7] where\n    T1 = [h + S1 e + Ch e f g  + k + w | h <- hs | e <- es | f <- fs | g <- gs | k <- K | w <- W]\n    T2 = [S0 a  + Maj a b c  | a <- as | b <- bs | c <- cs]\n    hs = take `{65} ([H@7] # gs)\n    gs = take `{65} ([H@6] # fs)\n    fs = take `{65} ([H@5] # es)\n    es = take `{65} ([H@4] # [d + t1 | d <- ds | t1 <- T1])\n    ds = take `{65} ([H@3] # cs)\n    cs = take `{65} ([H@2] # bs)\n    bs = take `{65} ([H@1] # as)\n    as = take `{65} ([H@0] # [t1 + t2 | t1 <- T1 | t2 <- T2])\n\nSHA256' : {a} (fin a) => [a][16][32] -> [8][32]\nSHA256' blocks = hash!0 where\n    hash = [H0] # [SHA256Compress h (SHA256MessageSchedule b) | h <- hash | b <- blocks]\n\nSHA256 : {a} (fin a, 64 >= width (8*a)) => [a][8] -> [256]\nSHA256 msg = join (SHA256' [ split x | x <- preprocess(join msg)])\n\nproperty katsPass = ~zero == [test == kat | (test,kat) <- kats ]\n\nkats = [ (SHA256 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n         , 0x248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1)\n       , (SHA256 \"\"\n         ,0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855)\n       , (SHA256 \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n         , 0xcf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1)\n       \/\/ , (SHA256 [0x61 | i <- [1..1000000] : [_][32]]\n       \/\/   , 0xcdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0)\n       ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/HMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named HMAC that imports the SHA256 module and contains the following definitions: (1) A polymorphic function hmac with type parameters for message length, key length, digest size, and block size, all finite. It takes three hash functions whose domains\/codomains enforce: (a) inner: blockSize+message bytes -> digest*8 bits, (b) outer: blockSize+digest bytes -> digest*8 bits, (c) key-hash: key bytes -> digest*8 bits; plus a key (bytes) and a message (bytes); and returns a digest-sized bitvector. Implement standard HMAC: if the key is longer than the block size, hash it to digest bytes; otherwise use it directly; zero-pad to block size; XOR with 0x36 to form the inner pad and with 0x5c to form the outer pad; compute inner = innerHash(innerPad || message); convert the inner hash to a byte sequence as needed; compute and return outerHash(outerPad || inner). (2) A function hmacSHA256 specialized to SHA-256 with block size 64 bytes and digest 32 bytes, mapping a byte-array key and byte-array message to a 256-bit result. Constrain message and key sizes to be finite, with the message-length width at most 32 and the bit-width of the key length at most 64. (3) A property named pass that asserts two HMAC-SHA256 test vectors evaluate to their known digests: one using a 20-byte key of 0x0b with the message \"Hi There\", and one using the key \"Jefe\" with the message \"what do ya want for nothing?\". The property succeeds only if both equalities hold."},{"role":"assistant","content":"```cryptol\nmodule HMAC where\n\nimport SHA256\n\nhmacSHA256 : {pwBytes, msgBytes}\n             (fin pwBytes, fin msgBytes\n             , 32 >= width msgBytes\n             , 64 >= width (8*pwBytes)\n             ) => [pwBytes][8] -> [msgBytes][8] -> [256]\nhmacSHA256 = hmac `{blockLength=64} SHA256 SHA256 SHA256\n\nhmac : { msgBytes, pwBytes, digest, blockLength }\n       ( fin pwBytes, fin digest, fin blockLength\n       )\n    => ([blockLength + msgBytes][8] -> [8*digest])\n    -> ([blockLength + digest][8] -> [8*digest])\n    -> ([pwBytes][8] -> [8*digest])\n    -> [pwBytes][8]\n    -> [msgBytes][8]\n    -> [digest*8]\nhmac hash hash2 hash3 key message = hash2 (okey # internal)\n where\n ks : [blockLength][8]\n ks   = if `pwBytes > (`blockLength : [max (width pwBytes) (width blockLength)])\n            then take `{blockLength} (split (hash3 key) # (zero : [blockLength][8]))\n            else take `{blockLength} (key # (zero : [blockLength][8]))\n okey = [k ^ 0x5C | k <- ks]\n ikey = [k ^ 0x36 | k <- ks]\n internal = split (hash (ikey # message))\n\nproperty pass =\n    ~zero ==\n    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] \"Hi There\" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\n    , hmacSHA256 \"Jefe\" \"what do ya want for nothing?\" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\n    ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Blake2s.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that defines a module named Blake2s that contains the following: (1) type synonyms for a 16-word 32-bit message block, an 8-word 32-bit chaining state, a 16-word 32-bit local state, a 64-bit byte counter, and a record context with state and counter; (2) a 64-bit constant equal to the block size in bytes; (3) the 8-word 32-bit initialization vector constant; (4) the 10-round message permutation table as a matrix of 4-bit indices; (5) four rotation-distance constants used by the mixing function; (6) a mixing function that updates four chosen lanes of a 16-word local state using additions, xors, fixed right-rotations by those constants, and message words selected via the round index and the permutation table; (7) a helper that computes one invocation of the mixer on the four lanes; (8) a compression function that initializes the 16-word working vector from the chaining state, IV, counter split into two 32-bit words, and a final-block flag, then iterates 10 rounds using a specified sequence of column and diagonal index groups, and returns the new chaining state by xoring halves of the final working vector; (9) a round function that applies eight mixes over the prescribed index groups; (10) a top-level hash function parameterized by message length and output length with constraints that the output length is at most 32 bytes and the message length bit-width fits in 64, returning output-length bytes; (11) a helper that handles padding, splits full and final partial blocks, initializes context with parameter block including output length, iterates compression over full blocks updating the counter by 64 bytes each time, and finalizes with the last block and final flag; (12) utilities to build blocks from bytes, reverse byte order of words, split\/join bytes, and update a vector element by index with necessary numeric constraints; (13) a property katsPass that asserts the hash of byte sequences of lengths 0..255 equals a provided table of 256 expected 32-byte digests, using helpers that generate each input and compare to the table."},{"role":"assistant","content":"```cryptol\nmodule Blake2s where\n\ntype Block   = [16][32]\ntype State   = [8][32]\ntype LocalState = [16][32]\ntype BCounter = [64]\n\ntype Context = { state : State, counter : BCounter }\n\nbbVal : [64]\nbbVal = 64\n\nIV : [8][32]\nIV = [ 0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,\n       0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\n     ]\n\nSIGMA_TABLE : [10][16][4]\nSIGMA_TABLE =\n    [  [  0, 1,   2, 3,   4, 5,   6, 7,   8, 9,  10, 11, 12, 13, 14, 15 ]\n    ,  [ 14, 10,  4, 8,   9, 15, 13, 6,   1, 12,  0, 2,  11, 7,   5, 3  ]\n    ,  [ 11, 8,  12, 0,   5, 2,  15, 13, 10, 14,  3, 6,   7, 1,   9, 4  ]\n    ,  [  7, 9,   3, 1,  13, 12, 11, 14,  2, 6,   5, 10,  4, 0,  15, 8  ]\n    ,  [  9, 0,   5, 7,   2, 4,  10, 15, 14, 1,  11, 12,  6, 8,   3, 13 ]\n    ,  [  2, 12,  6, 10,  0, 11,  8, 3,   4, 13,  7, 5,  15, 14,  1, 9  ]\n    ,  [ 12, 5,   1, 15, 14, 13,  4, 10,  0, 7,   6, 3,   9, 2,   8, 11 ]\n    ,  [ 13, 11,  7, 14, 12, 1,   3, 9,   5, 0,  15, 4,   8, 6,   2, 10 ]\n    ,  [  6, 15, 14, 9,  11, 3,   0, 8,  12, 2,  13, 7,   1, 4,  10, 5  ]\n    ,  [ 10, 2,   8, 4,   7, 6,   1, 5,  15, 11,  9, 14,  3, 12, 13, 0  ]\n    ]\n\nR1,R2,R3,R4 : [6]\nR1 = 16\nR2 = 12\nR3 = 08\nR4 = 07\n\nG : [4] -> [4] -> LocalState -> [4][6] -> Block -> [16][32]\nG r i vec abcd ms = foldl updateVector vec (zip abcd new)\n  where\n  new  = G' r i (vec @@ abcd) ms\n\nG' : [4] -> [4] -> [4][32] -> Block -> [4][32]\nG' r i vals ms = [a2, b2, c2, d2]\n  where\n  x = ms @ (SIGMA_TABLE @ r @ (2*i))\n  y = ms @ (SIGMA_TABLE @ r @ (2*i+1))\n  [a,b,c,d] = vals\n  a1 =  a + b + x\n  d1 = (d ^ a1) >>> R1\n  c1 =  c + d1\n  b1 = (b ^ c1) >>> R2\n  a2 =  a1 + b1 + y\n  d2 = (d1 ^ a2) >>> R3\n  c2 =  c1 + d2\n  b2 = (b1 ^ c2) >>> R4\n\n\/\/ Section 3.2: Compression function\nF : State -> Block -> BCounter -> Bit -> State\nF h ms t f =  h ^ (take (vs!0)) ^ (drop (vs!0))\n where\n  v   = h # IV ^ (zero # [t0,t1,f0,zero])\n  [t1,t0] = split t      : [2][32]\n  f0 = [f | _ <- [0..31] : [_][6]]\n  vs = [v] # [ round i ms v' | v' <- vs | i <- [0..9] ]\n\n\/\/ Sub-function of F (first for loop)\nround : [4] -> Block -> LocalState -> LocalState\nround r ms v = vs ! 0\n  where\n  vs = [v] # [ G r i v' ix ms\n                | v'   <- vs\n                | i    <- [0..7]\n                | ix   <- [ [0,4,8,12],  [1,5,9,13]\n                          , [2,6,10,14], [3,7,11,15]\n                          , [0,5,10,15], [1,6,11,12]\n                          , [2,7,8,13],  [3,4,9,14] ]\n              ]\n\n\/\/ Section 3.3: Padding\n\/\/ Recall kk == key bytes  (0)\n\/\/        nn == hash bytes (32)\n\/\/        ll == input bytes (ceiling $ len \/ 8)\n\/\/        bb == block bytes (64, 1024 bits)\n\/\/        dd == nr Blocks\n\nblake2s : {ll,nn} (fin ll, 32 >= nn, 64 >= width ll)\n      => [ll][8] -> [nn*8]\nblake2s m = blake2s' `{ll=ll,nn=nn} m\n\nblake2s' : {ll,dd,nn}\n         (fin ll\n         , 32  >= nn\n         , dd  == (max 1 ((ll+63)\/64)) - 1\n         , 64 >= width ll\n         )\n          => [ll][8]\n          -> [nn*8]\nblake2s' m = take `{nn*8} (blake2sFinish ({ state = (hs!0).state, counter = `ll}) lastBlock)\n where\n\n fullBlocks : [dd]Block\n fullBlocks = [mkBlock b | b <- split (join (take  `{front=64*dd,back=ll-64*dd} m))]\n\n partialBlock = drop `{front=64*dd,back=ll-64*dd} m\n\n lastBlock : Block\n lastBlock  =\n    if (`ll == (zero:[64]))\n        then zero         else mkBlock ((split (join (partialBlock # (zero : [inf][8]))))@0)\n\n h : Context\n h  = { state = [IV@0 ^ `0x01010000 ^ `nn] # drop `{1} IV, counter = 0 }\n\n hs : [dd+1]Context\n hs = [h] # [blake2Update h' dX |  h' <- hs | dX <- fullBlocks]\n\nblake2Update : Context -> Block -> Context\nblake2Update ctx d = { state = newState, counter = newCount }\n  where newState = F ctx.state d newCount False\n        newCount = ctx.counter + (64 : [64])\n\npostprocess : {ll} (64 >= ll, 64 >= width ll) => BCounter -> [ll][8] -> Block\npostprocess c m =\n    if c == 0 \/\\ `ll == (zero:[64])\n        then zero\n        else split (join m # zero)\n\nblake2sFinish : Context -> Block -> [256]\nblake2sFinish ctx b = join [ reverseBytes w | w <- F ctx.state b ctx.counter True ]\n\nmkBlock x = reverse (split (reverseBytes x))\n\nreverseBytes x = join (reverse (bytes x))\n\nbytes x = split x : [_] [8]\n\nupdateVector : {a, b, c} (c >= width (a-1), a >= 1, fin a, fin c) => [a]b -> ([c], b) -> [a]b\nupdateVector orig idxNew = vs\n where\n idx = idxNew.0\n new = idxNew.1\n vs = [if i == idx then new else orig@i | i <- [0..a-1]]\n\nproperty katsPass = ~zero ==\n                        [ nthKat `{0}\n                        , nthKat `{1}\n                        , nthKat `{2}\n                        , nthKat `{3}\n                        , nthKat `{4}\n                        , nthKat `{5}\n                        , nthKat `{6}\n                        , nthKat `{7}\n                        , nthKat `{8}\n                        , nthKat `{9}\n                        , nthKat `{10}\n                        , nthKat `{11}\n                        , nthKat `{12}\n                        , nthKat `{13}\n                        , nthKat `{14}\n                        , nthKat `{15}\n                        , nthKat `{16}\n                        , nthKat `{17}\n                        , nthKat `{18}\n                        , nthKat `{19}\n                        , nthKat `{20}\n                        , nthKat `{21}\n                        , nthKat `{22}\n                        , nthKat `{23}\n                        , nthKat `{24}\n                        , nthKat `{25}\n                        , nthKat `{26}\n                        , nthKat `{27}\n                        , nthKat `{28}\n                        , nthKat `{29}\n                        , nthKat `{30}\n                        , nthKat `{31}\n                        , nthKat `{32}\n                        , nthKat `{33}\n                        , nthKat `{34}\n                        , nthKat `{35}\n                        , nthKat `{36}\n                        , nthKat `{37}\n                        , nthKat `{38}\n                        , nthKat `{39}\n                        , nthKat `{40}\n                        , nthKat `{41}\n                        , nthKat `{42}\n                        , nthKat `{43}\n                        , nthKat `{44}\n                        , nthKat `{45}\n                        , nthKat `{46}\n                        , nthKat `{47}\n                        , nthKat `{48}\n                        , nthKat `{49}\n                        , nthKat `{50}\n                        , nthKat `{51}\n                        , nthKat `{52}\n                        , nthKat `{53}\n                        , nthKat `{54}\n                        , nthKat `{55}\n                        , nthKat `{56}\n                        , nthKat `{57}\n                        , nthKat `{58}\n                        , nthKat `{59}\n                        , nthKat `{60}\n                        , nthKat `{61}\n                        , nthKat `{62}\n                        , nthKat `{63}\n                        , nthKat `{64}\n                        , nthKat `{65}\n                        , nthKat `{66}\n                        , nthKat `{67}\n                        , nthKat `{68}\n                        , nthKat `{69}\n                        , nthKat `{70}\n                        , nthKat `{71}\n                        , nthKat `{72}\n                        , nthKat `{73}\n                        , nthKat `{74}\n                        , nthKat `{75}\n                        , nthKat `{76}\n                        , nthKat `{77}\n                        , nthKat `{78}\n                        , nthKat `{79}\n                        , nthKat `{80}\n                        , nthKat `{81}\n                        , nthKat `{82}\n                        , nthKat `{83}\n                        , nthKat `{84}\n                        , nthKat `{85}\n                        , nthKat `{86}\n                        , nthKat `{87}\n                        , nthKat `{88}\n                        , nthKat `{89}\n                        , nthKat `{90}\n                        , nthKat `{91}\n                        , nthKat `{92}\n                        , nthKat `{93}\n                        , nthKat `{94}\n                        , nthKat `{95}\n                        , nthKat `{96}\n                        , nthKat `{97}\n                        , nthKat `{98}\n                        , nthKat `{99}\n                        , nthKat `{100}\n                        , nthKat `{101}\n                        , nthKat `{102}\n                        , nthKat `{103}\n                        , nthKat `{104}\n                        , nthKat `{105}\n                        , nthKat `{106}\n                        , nthKat `{107}\n                        , nthKat `{108}\n                        , nthKat `{109}\n                        , nthKat `{110}\n                        , nthKat `{111}\n                        , nthKat `{112}\n                        , nthKat `{113}\n                        , nthKat `{114}\n                        , nthKat `{115}\n                        , nthKat `{116}\n                        , nthKat `{117}\n                        , nthKat `{118}\n                        , nthKat `{119}\n                        , nthKat `{120}\n                        , nthKat `{121}\n                        , nthKat `{122}\n                        , nthKat `{123}\n                        , nthKat `{124}\n                        , nthKat `{125}\n                        , nthKat `{126}\n                        , nthKat `{127}\n                        , nthKat `{128}\n                        , nthKat `{129}\n                        , nthKat `{130}\n                        , nthKat `{131}\n                        , nthKat `{132}\n                        , nthKat `{133}\n                        , nthKat `{134}\n                        , nthKat `{135}\n                        , nthKat `{136}\n                        , nthKat `{137}\n                        , nthKat `{138}\n                        , nthKat `{139}\n                        , nthKat `{140}\n                        , nthKat `{141}\n                        , nthKat `{142}\n                        , nthKat `{143}\n                        , nthKat `{144}\n                        , nthKat `{145}\n                        , nthKat `{146}\n                        , nthKat `{147}\n                        , nthKat `{148}\n                        , nthKat `{149}\n                        , nthKat `{150}\n                        , nthKat `{151}\n                        , nthKat `{152}\n                        , nthKat `{153}\n                        , nthKat `{154}\n                        , nthKat `{155}\n                        , nthKat `{156}\n                        , nthKat `{157}\n                        , nthKat `{158}\n                        , nthKat `{159}\n                        , nthKat `{160}\n                        , nthKat `{161}\n                        , nthKat `{162}\n                        , nthKat `{163}\n                        , nthKat `{164}\n                        , nthKat `{165}\n                        , nthKat `{166}\n                        , nthKat `{167}\n                        , nthKat `{168}\n                        , nthKat `{169}\n                        , nthKat `{170}\n                        , nthKat `{171}\n                        , nthKat `{172}\n                        , nthKat `{173}\n                        , nthKat `{174}\n                        , nthKat `{175}\n                        , nthKat `{176}\n                        , nthKat `{177}\n                        , nthKat `{178}\n                        , nthKat `{179}\n                        , nthKat `{180}\n                        , nthKat `{181}\n                        , nthKat `{182}\n                        , nthKat `{183}\n                        , nthKat `{184}\n                        , nthKat `{185}\n                        , nthKat `{186}\n                        , nthKat `{187}\n                        , nthKat `{188}\n                        , nthKat `{189}\n                        , nthKat `{190}\n                        , nthKat `{191}\n                        , nthKat `{192}\n                        , nthKat `{193}\n                        , nthKat `{194}\n                        , nthKat `{195}\n                        , nthKat `{196}\n                        , nthKat `{197}\n                        , nthKat `{198}\n                        , nthKat `{199}\n                        , nthKat `{200}\n                        , nthKat `{201}\n                        , nthKat `{202}\n                        , nthKat `{203}\n                        , nthKat `{204}\n                        , nthKat `{205}\n                        , nthKat `{206}\n                        , nthKat `{207}\n                        , nthKat `{208}\n                        , nthKat `{209}\n                        , nthKat `{210}\n                        , nthKat `{211}\n                        , nthKat `{212}\n                        , nthKat `{213}\n                        , nthKat `{214}\n                        , nthKat `{215}\n                        , nthKat `{216}\n                        , nthKat `{217}\n                        , nthKat `{218}\n                        , nthKat `{219}\n                        , nthKat `{220}\n                        , nthKat `{221}\n                        , nthKat `{222}\n                        , nthKat `{223}\n                        , nthKat `{224}\n                        , nthKat `{225}\n                        , nthKat `{226}\n                        , nthKat `{227}\n                        , nthKat `{228}\n                        , nthKat `{229}\n                        , nthKat `{230}\n                        , nthKat `{231}\n                        , nthKat `{232}\n                        , nthKat `{233}\n                        , nthKat `{234}\n                        , nthKat `{235}\n                        , nthKat `{236}\n                        , nthKat `{237}\n                        , nthKat `{238}\n                        , nthKat `{239}\n                        , nthKat `{240}\n                        , nthKat `{241}\n                        , nthKat `{242}\n                        , nthKat `{243}\n                        , nthKat `{244}\n                        , nthKat `{245}\n                        , nthKat `{246}\n                        , nthKat `{247}\n                        , nthKat `{248}\n                        , nthKat `{249}\n                        , nthKat `{250}\n                        , nthKat `{251}\n                        , nthKat `{252}\n                        , nthKat `{253}\n                        , nthKat `{254}\n                        , nthKat `{255}\n                        ]\n\nnthKat : {n} (fin n, 8 >= width n) => Bit\nnthKat = blake2s (nthKatInput `{n}) == kats @ (`n : [8])\n\nnthKatInput : {n} (fin n) => [n][8]\nnthKatInput = take ([0 ... ] : [inf][8])\n\nkats = [ 0x69217a3079908094e11121d042354a7c1f55b6482ca1a51e1b250dfd1ed0eef9\n       , 0xe34d74dbaf4ff4c6abd871cc220451d2ea2648846c7757fbaac82fe51ad64bea\n       , 0xddad9ab15dac4549ba42f49d262496bef6c0bae1dd342a8808f8ea267c6e210c\n       , 0xe8f91c6ef232a041452ab0e149070cdd7dd1769e75b3a5921be37876c45c9900\n       , 0x0cc70e00348b86ba2944d0c32038b25c55584f90df2304f55fa332af5fb01e20\n       , 0xec1964191087a4fe9df1c795342a02ffc191a5b251764856ae5b8b5769f0c6cd\n       , 0xe1fa51618d7df4eb70cf0d5a9e906f806e9d19f7f4f01e3b621288e4120405d6\n       , 0x598001fafbe8f94ec66dc827d012cfcbba2228569f448e89ea2208c8bf769293\n       , 0xc7e887b546623635e93e0495598f1726821996c2377705b93a1f636f872bfa2d\n       , 0xc315a437dd28062a770d481967136b1b5eb88b21ee53d0329c5897126e9db02c\n       , 0xbb473deddc055fea6228f207da575347bb00404cd349d38c18026307a224cbff\n       , 0x687e1873a8277591bb33d9adf9a13912efefe557cafc39a7952623e47255f16d\n       , 0x1ac7ba754d6e2f94e0e86c46bfb262abbb74f450ef456d6b4d97aa80ce6da767\n       , 0x012c97809614816b5d9494477d4b687d15b96eb69c0e8074a8516f31224b5c98\n       , 0x91ffd26cfa4da5134c7ea262f7889c329f61f6a657225cc212f40056d986b3f4\n       , 0xd97c828d8182a72180a06a78268330673f7c4e0635947c04c02323fd45c0a52d\n       , 0xefc04cdc391c7e9119bd38668a534e65fe31036d6a62112e44ebeb11f9c57080\n       , 0x992cf5c053442a5fbc4faf583e04e50bb70d2f39fbb6a503f89e56a63e18578a\n       , 0x38640e9f21983e67b539caccae5ecf615ae2764f75a09c9c59b76483c1fbc735\n       , 0x213dd34c7efe4fb27a6b35f6b4000d1fe03281af3c723e5c9f94747a5f31cd3b\n       , 0xec246eeeb9ced3f7ad33ed28660dd9bb0732513db4e2fa278b60cde3682a4ccd\n       , 0xac9b61d446648c3005d7892bf3a8719f4c8181cfdcbc2b79fef10a279b911095\n       , 0x7bf8b22959e34e3a43f7079223e83a9754617d391e213dfd808e41b9bead4ce7\n       , 0x68d4b5d4fa0e302b64ccc5af792913ac4c88ec95c07ddf40694256eb88ce9f3d\n       , 0xb2c2420f05f9abe36315919336b37e4e0fa33ff7e76a492767006fdb5d935462\n       , 0x134f61bbd0bbb69aed5343904551a3e6c1aa7dcdd77e903e7023eb7c60320aa7\n       , 0x4693f9bff7d4f3986a7d176e6e06f72ad1490d805c99e25347b8de77b4db6d9b\n       , 0x853e26f741953b0fd5bdb424e8ab9e8b3750eaa8ef61e47902c91e554e9c73b9\n       , 0xf7de536361abaa0e158156cf0ea4f63a99b5e4054f8fa4c9d45f6285cad55694\n       , 0x4c230608860a99ae8d7bd5c2cc17fa52096b9a61bedb17cb7617864ad29ca7a6\n       , 0xaeb920ea87952dadb1fb759291e3388139a872865001886ed84752e93c250c2a\n       , 0xaba4ad9b480b9df3d08ca5e87b0c2440d4e4ea21224c2eb42cbae469d089b931\n       , 0x05825607d7fdf2d82ef4c3c8c2aea961ad98d60edff7d018983e21204c0d93d1\n       , 0xa742f8b6af82d8a6ca2357c5f1cf91defbd066267d75c048b352366585025962\n       , 0x2bcac89599000b42c95ae23835a713704ed79789c84fef149a874ff733f017a2\n       , 0xac1ed07d048f105a9e5b7ab85b09a492d5baff14b8bfb0e9fd789486eea2b974\n       , 0xe48d0ecfaf497d5b27c25d99e156cb0579d440d6e31fb62473696dbf95e010e4\n       , 0x12a91fadf8b21644fd0f934f3c4a8f62ba862ffd20e8e961154c15c13884ed3d\n       , 0x7cbee96e139897dc98fbef3be81ad4d964d235cb12141fb66727e6e5df73a878\n       , 0xebf66abb597ae572a7297cb0871e355accafad8377b8e78bf164ce2a18de4baf\n       , 0x71b933b07e4ff7818ce059d008829e453c6ff02ec0a7db393fc2d870f37a7286\n       , 0x7cf7c51331220b8d3ebaed9c29398a16d98156e2613cb088f2b0e08a1be4cf4f\n       , 0x3e41a108e0f64ad276b979e1ce068279e16f7bc7e4aa1d211e17b81161df1602\n       , 0x886502a82ab47ba8d86710aa9de3d46ea65c47af6ee8de450cceb8b11b045f50\n       , 0xc021bc5f0954fee94f46ea09487e10a84840d02f64810bc08d9e551f7d416814\n       , 0x2030516e8a5fe19ae79c336fce26382a749d3fd0ec91e537d4bd2358c12dfb22\n       , 0x556698dac8317fd36dfbdf25a79cb112d5425860605cbaf507f23bf7e9f42afe\n       , 0x2f867ba67773fdc3e92fced99a6409ad39d0b880fde8f109a81730c4451d0178\n       , 0x172ec218f119dfae98896dff29dd9876c94af87417f9ae4c7014bb4e4b96afc7\n       , 0x3f85814a18195f879aa962f95d26bd82a278f2b82320218f6b3bd6f7f667a6d9\n       , 0x1b618fbaa566b3d498c12e982c9ec52e4da85a8c54f38f34c090394f23c184c1\n       , 0x0c758fb5692ffd41a3575d0af00cc7fbf2cbe5905a58323a88ae4244f6e4c993\n       , 0xa931360cad628c7f12a6c1c4b753b0f4062aef3ce65a1ae3f19369dadf3ae23d\n       , 0xcbac7d773b1e3b3c6691d7abb7e9df045c8ba19268ded153207f5e804352ec5d\n       , 0x23a196d3802ed3c1b384019a82325840d32f71950c4580b03445e0898e14053c\n       , 0xf4495470f226c8c214be08fdfad4bc4a2a9dbea9136a210df0d4b64929e6fc14\n       , 0xe290dd270b467f34ab1c002d340fa016257ff19e5833fdbbf2cb401c3b2817de\n       , 0x9fc7b5ded3c15042b2a6582dc39be016d24a682d5e61ad1eff9c63309848f706\n       , 0x8cca67a36d17d5e6341cb592fd7bef9926c9e3aa1027ea11a7d8bd260b576e04\n       , 0x409392f560f86831da4373ee5e0074260595d7bc24183b60ed700d4583d3f6f0\n       , 0x2802165de090915546f3398cd849164a19f92adbc361adc99b0f20c8ea071054\n       , 0xad839168d9f8a4be95ba9ef9a692f07256ae43fe6f9864e290691b0256ce50a9\n       , 0x75fdaa5038c284b86d6e8affe8b2807e467b86600e79af3689fbc06328cbf894\n       , 0xe57cb79487dd57902432b250733813bd96a84efce59f650fac26e6696aefafc3\n       , 0x56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e\n       , 0x1b53ee94aaf34e4b159d48de352c7f0661d0a40edff95a0b1639b4090e974472\n       , 0x05705e2a81757c14bd383ea98dda544eb10e6bc07bae435e2518dbe133525375\n       , 0xd8b2866e8a309db53e529ec32911d82f5ca16cff76216891a9676aa31aaa6c42\n       , 0xf5041c241270eb04c71ec2c95d4c38d803b1237b0f29fd4db3eb397669e88699\n       , 0x9a4ce077c349322f595e0ee79ed0da5fab66752cbfef8f87d0e9d0723c7530dd\n       , 0x657b09f3d0f52b5b8f2f97163a0edf0c04f075408a07bbeb3a4101a891990d62\n       , 0x1e3f7bd5a58fa533344aa8ed3ac122bb9e70d4ef50d004530821948f5fe6315a\n       , 0x80dccf3fd83dfd0d35aa28585922ab89d5313997673eaf905cea9c0b225c7b5f\n       , 0x8a0d0fbf6377d83bb08b514b4b1c43acc95d751714f8925645cb6bc856ca150a\n       , 0x9fa5b487738ad2844cc6348a901918f659a3b89e9c0dfeead30dd94bcf42ef8e\n       , 0x80832c4a1677f5ea2560f668e9354dd36997f03728cfa55e1b38337c0c9ef818\n       , 0xab37ddb683137e74080d026b590b96ae9bb447722f305a5ac570ec1df9b1743c\n       , 0x3ee735a694c2559b693aa68629361e15d12265ad6a3dedf488b0b00fac9754ba\n       , 0xd6fcd23219b647e4cbd5eb2d0ad01ec8838a4b2901fc325cc3701981ca6c888b\n       , 0x0520ec2f5bf7a755dacb50c6bf233e3515434763db0139ccd9faefbb8207612d\n       , 0xaff3b75f3f581264d7661662b92f5ad37c1d32bd45ff81a4ed8adc9ef30dd989\n       , 0xd0dd650befd3ba63dc25102c627c921b9cbeb0b130686935b5c927cb7ccd5e3b\n       , 0xe1149816b10a8514fb3e2cab2c08bee9f73ce76221701246a589bbb67302d8a9\n       , 0x7da3f441de9054317e72b5dbf979da01e6bceebb8478eae6a22849d90292635c\n       , 0x1230b1fc8a7d9215edc2d4a2decbdd0a6e216c924278c91fc5d10e7d60192d94\n       , 0x5750d716b4808f751febc38806ba170bf6d5199a7816be514e3f932fbe0cb871\n       , 0x6fc59b2f10feba954aa6820b3ca987ee81d5cc1da3c63ce827301c569dfb39ce\n       , 0xc7c3fe1eebdc7b5a939326e8ddb83e8bf2b780b65678cb62f208b040abdd35e2\n       , 0x0c75c1a15cf34a314ee478f4a5ce0b8a6b36528ef7a820696c3e4246c5a15864\n       , 0x216dc12a108569a3c7cdde4aed43a6c330139dda3ccc4a108905db3861899050\n       , 0xa57be6ae6756f28b02f59dadf7e0d7d8807f10fa15ced1ad3585521a1d995a89\n       , 0x816aef875953716cd7a581f732f53dd435dab66d09c361d2d6592de17755d8a8\n       , 0x9a76893226693b6ea97e6a738f9d10fb3d0b43ae0e8b7d8123ea76ce97989c7e\n       , 0x8daedb9a271529dbb7dc3b607fe5eb2d3211770758dd3b0a3593d2d7954e2d5b\n       , 0x16dbc0aa5dd2c774f505100f733786d8a175fcbbb59c43e1fbff3e1eaf31cb4a\n       , 0x8606cb899c6aeaf51b9db0fe4924a9fd5dabc19f8826f2bc1c1d7da14d2c2c99\n       , 0x8479731aeda57bd37eadb51a507e307f3bd95e69dbca94f3bc21726066ad6dfd\n       , 0x58473a9ea82efa3f3b3d8fc83ed8863127b33ae8deae6307201edb6dde61de29\n       , 0x9a9255d53af116de8ba27ce35b4c7e15640657a0fcb888c70d95431dacd8f830\n       , 0x9eb05ffba39fd8596a45493e18d2510bf3ef065c51d6e13abe66aa57e05cfdb7\n       , 0x81dcc3a505eace3f879d8f702776770f9df50e521d1428a85daf04f9ad2150e0\n       , 0xe3e3c4aa3acbbc85332af9d564bc24165e1687f6b1adcbfae77a8f03c72ac28c\n       , 0x6746c80b4eb56aea45e64e7289bba3edbf45ecf8206481ff6302122984cd526a\n       , 0x2b628e52764d7d62c0868b212357cdd12d9149822f4e9845d918a08d1ae990c0\n       , 0xe4bfe80d58c91994613909dc4b1a12496896c004af7b5701483de45d2823d78e\n       , 0xebb4ba150cef2734345b5d641bbed03a21eafae933c99e009212ef04574a8530\n       , 0x3966ec73b154acc697ac5cf5b24b40bdb0db9e398836d76d4b880e3b2af1aa27\n       , 0xef7e4831b3a84636518d6e4bfce64a43db2a5dda9cca2b44f39033bdc40d6243\n       , 0x7abf6acf5c8e549ddbb15ae8d8b388c1c197e698737c9785501ed1f94930b7d9\n       , 0x88018ded66813f0ca95def474c630692019967b9e36888dadd94124719b682f6\n       , 0x3930876b9fc7529036b008b1b8bb997522a441635a0c25ec02fb6d9026e55a97\n       , 0x0a4049d57e833b5695fac93dd1fbef3166b44b12ad11248662383ae051e15827\n       , 0x81dcc0678bb6a765e48c3209654fe90089ce44ff5618477e39ab286476df052b\n       , 0xe69b3a36a4461912dc08346b11ddcb9db796f885fd01936e662fe29297b099a4\n       , 0x5ac6503b0d8da6917646e6dcc87edc58e94245324cc204f4dd4af01563acd427\n       , 0xdf6dda21359a30bc271780971c1abd56a6ef167e480887888e73a86d3bf605e9\n       , 0xe8e6e47071e7b7df2580f225cfbbedf84ce67746626628d33097e4b7dc571107\n       , 0x53e40ead62051e19cb9ba8133e3e5c1ce00ddcad8acf342a224360b0acc14777\n       , 0x9ccd53fe80be786aa984638462fb28afdf122b34d78f4687ec632bb19de2371a\n       , 0xcbd48052c48d788466a3e8118c56c97fe146e5546faaf93e2bc3c47e45939753\n       , 0x256883b14e2af44dadb28e1b34b2ac0f0f4c91c34ec9169e29036158acaa95b9\n       , 0x4471b91ab42db7c4dd8490ab95a2ee8d04e3ef5c3d6fc71ac74b2b26914d1641\n       , 0xa5eb08038f8f1155ed86e631906fc13095f6bba41de5d4e795758ec8c8df8af1\n       , 0xdc1db64ed8b48a910e060a6b866374c578784e9ac49ab2774092ac71501934ac\n       , 0x285413b2f2ee873d34319ee0bbfbb90f32da434cc87e3db5ed121bb398ed964b\n       , 0x0216e0f81f750f26f1998bc3934e3e124c9945e685a60b25e8fbd9625ab6b599\n       , 0x38c410f5b9d4072050755b31dca89fd5395c6785eeb3d790f320ff941c5a93bf\n       , 0xf18417b39d617ab1c18fdf91ebd0fc6d5516bb34cf39364037bce81fa04cecb1\n       , 0x1fa877de67259d19863a2a34bcc6962a2b25fcbf5cbecd7ede8f1fa36688a796\n       , 0x5bd169e67c82c2c2e98ef7008bdf261f2ddf30b1c00f9e7f275bb3e8a28dc9a2\n       , 0xc80abeebb669ad5deeb5f5ec8ea6b7a05ddf7d31ec4c0a2ee20b0b98caec6746\n       , 0xe76d3fbda5ba374e6bf8e50fadc3bbb9ba5c206ebdec89a3a54cf3dd84a07016\n       , 0x7bba9dc5b5db2071d17752b1044c1eced96aaf2dd46e9b433750e8ea0dcc1870\n       , 0xf29b1b1ab9bab163018ee3da15232cca78ec52dbc34eda5b822ec1d80fc21bd0\n       , 0x9ee3e3e7e900f1e11d308c4b2b3076d272cf70124f9f51e1da60f37846cdd2f4\n       , 0x70ea3b0176927d9096a18508cd123a290325920a9d00a89b5de04273fbc76b85\n       , 0x67de25c02a4aaba23bdc973c8bb0b5796d47cc0659d43dff1f97de174963b68e\n       , 0xb2168e4e0f18b0e64100b517ed95257d73f0620df885c13d2ecf79367b384cee\n       , 0x2e7dec2428853b2c71760745541f7afe9825b5dd77df06511d8441a94bacc927\n       , 0xca9ffac4c43f0b48461dc5c263bea3f6f00611ceacabf6f895ba2b0101dbb68d\n       , 0x7410d42d8fd1d5e9d2f5815cb93417998828ef3c4230bfbd412df0a4a7a2507a\n       , 0x5010f684516dccd0b6ee0852c2512b4dc0066cf0d56f35302978db8ae32c6a81\n       , 0xacaab585f7b79b719935ceb89523ddc54827f75c56883856154a56cdcd5ee988\n       , 0x666de5d1440fee7331aaf0123a62ef2d8ba57453a0769635ac6cd01e633f7712\n       , 0xa6f98658f6eabaf902d8b3871a4b101d16196e8a4b241e1558fe29966e103e8d\n       , 0x891546a8b29f3047ddcfe5b00e45fd55756373105ea8637dfcff547b6ea9535f\n       , 0x18dfbc1ac5d25b0761137dbd22c17c829d0f0ef1d82344e9c89c286694da24e8\n       , 0xb54b9b67f8fed54bbf5a2666dbdf4b23cff1d1b6f4afc985b2e6d3305a9ff80f\n       , 0x7db442e132ba59bc1289aa98b0d3e806004f8ec12811af1e2e33c69bfde729e1\n       , 0x250f37cdc15e817d2f160d9956c71fe3eb5db74556e4adf9a4ffafba74010396\n       , 0x4ab8a3dd1ddf8ad43dab13a27f66a6544f290597fa96040e0e1db9263aa479f8\n       , 0xee61727a0766df939ccdc860334044c79a3c9b156200bc3aa32973483d8341ae\n       , 0x3f68c7ec63ac11ebb98f94b339b05c104984fda50103060144e5a2bfccc9da95\n       , 0x056f29816b8af8f56682bc4d7cf094111da7733e726cd13d6b3e8ea03e92a0d5\n       , 0xf5ec43a28acbeff1f3318a5bcac7c66ddb5230b79db2d105bcbe15f3c1148d69\n       , 0x2a6960ad1d8dd547555cfbd5e4600f1eaa1c8eda34de0374ec4a26eaaaa33b4e\n       , 0xdcc1ea7baab93384f76b796866199754742f7b96d6b4c120165c04a6c4f5ce10\n       , 0x13d5df179221379c6a78c07c793ff53487cae6bf9fe882541ab0e735e3eada3b\n       , 0x8c59e4407641a01e8ff91f9980dc236f4ecd6fcf52589a099a961633967714e1\n       , 0x833b1ac6a251fd08fd6d908fea2a4ee1e040bca93fc1a38ec3820e0c10bd82ea\n       , 0xa244f927f3b40b8f6c391570c765418f2f6e708eac9006c51a7feff4af3b2b9e\n       , 0x3d99ed9550cf1196e6c4d20c259620f858c3d703374c128ce7b590310c83046d\n       , 0x2b35c47d7b87761f0ae43ac56ac27b9f25830367b595be8c240e94600c6e3312\n       , 0x5d11ed37d24dc767305cb7e1467d87c065ac4bc8a426de38991ff59aa8735d02\n       , 0xb836478e1ca0640dce6fd910a5096272c8330990cd97864ac2bf14ef6b23914a\n       , 0x9100f946d6ccde3a597f90d39fc1215baddc7413643d85c21c3eee5d2dd32894\n       , 0xda70eedd23e663aa1a74b9766935b479222a72afba5c795158dad41a3bd77e40\n       , 0xf067ed6a0dbd43aa0a9254e69fd66bdd8acb87de936c258cfb02285f2c11fa79\n       , 0x715c99c7d57580cf9753b4c1d795e45a83fbb228c0d36fbe20faf39bdd6d4e85\n       , 0xe457d6ad1e67cb9bbd17cbd698fa6d7dae0c9b7ad6cbd6539634e32a719c8492\n       , 0xece3ea8103e02483c64a70a4bdcee8ceb6278f2533f3f48dbeedfba94531d4ae\n       , 0x388aa5d3667a97c68d3d56f8f3ee8d3d36091f17fe5d1b0d5d84c93b2ffe40bd\n       , 0x8b6b31b9ad7c3d5cd84bf98947b9cdb59df8a25ff738101013be4fd65e1dd1a3\n       , 0x066291f6bbd25f3c853db7d8b95c9a1cfb9bf1c1c99fb95a9b7869d90f1c2903\n       , 0xa707efbccdceed42967a66f5539b93ed7560d467304016c4780d7755a565d4c4\n       , 0x38c53dfb70be7e792b07a6a35b8a6a0aba02c5c5f38baf5c823fdfd9e42d657e\n       , 0xf2911386501d9ab9d720cf8ad10503d5634bf4b7d12b56dfb74fecc6e4093f68\n       , 0xc6f2bdd52b81e6e4f6595abd4d7fb31f651169d00ff326926b34947b28a83959\n       , 0x293d94b18c98bb3223366b8ce74c28fbdf28e1f84a3350b0eb2d1804a577579b\n       , 0x2c2fa5c0b51533165bc375c22e2781768270a383985d13bd6b67b6fd67f889eb\n       , 0xcaa09b82b72562e43f4b2275c091918e624d911661cc811bb5faec51f6088ef7\n       , 0x24761e45e674395379fb17729c78cb939e6f74c5dffb9c961f495982c3ed1fe3\n       , 0x55b70a82131ec94888d7ab54a7c515255c3938bb10bc784dc9b67f076e341a73\n       , 0x6ab9057b977ebc3ca4d4ce74506c25cccdc566497c450b5415a39486f8657a03\n       , 0x24066deee0ecee15a45f0a326d0f8dbc79761ebb93cf8c0377af440978fcf994\n       , 0x20000d3f66ba76860d5a950688b9aa0d76cfea59b005d859914b1a46653a939b\n       , 0xb92daa79603e3bdbc3bfe0f419e409b2ea10dc435beefe2959da16895d5dca1c\n       , 0xe947948705b206d572b0e8f62f66a6551cbd6bc305d26ce7539a12f9aadf7571\n       , 0x3d67c1b3f9b23910e3d35e6b0f2ccf44a0b540a45c18ba3c36264dd48e96af6a\n       , 0xc7558babda04bccb764d0bbf3358425141902d22391d9f8c59159fec9e49b151\n       , 0x0b732bb035675a50ff58f2c242e4710aece64670079c13044c79c9b7491f7000\n       , 0xd120b5ef6d57ebf06eaf96bc933c967b16cbe6e2bf00741c30aa1c54ba64801f\n       , 0x58d212ad6f58aef0f80116b441e57f6195bfef26b61463edec1183cdb04fe76d\n       , 0xb8836f51d1e29bdfdba325565360268b8fad627473edecef7eaefee837c74003\n       , 0xc547a3c124ae5685ffa7b8edaf96ec86f8b2d0d50cee8be3b1f0c76763069d9c\n       , 0x5d168b769a2f67853d6295f7568be40bb7a16b8d65ba87635d1978d2ab11ba2a\n       , 0xa2f675dc7302638cb60201064ca55077714d71fe096a315f2fe7401277caa5af\n       , 0xc8aab5cd0160ae78cd2e8ac5fb0e093cdb5c4b6052a0a97bb04216826fa7a437\n       , 0xff68ca4035bfeb43fbf145fddd5e43f1cea54f11f7bee13058f027329a4a5fa4\n       , 0x1d4e5487ae3c740f2ba6e541ac91bc2bfcd2999c518d807b426748803a350fd4\n       , 0x6d244e1a06ce4ef578dd0f63aff0936706735119ca9c8d22d86c801414ab9741\n       , 0xdecf7329dbcc827b8fc524c9431e8998029ece12ce93b7b2f3e769a941fb8cea\n       , 0x2fafcc0f2e63cbd07755be7b75ecea0adff9aa5ede2a52fdab4dfd0374cd483f\n       , 0xaa85010dd46a546b535ef4cf5f07d65161e89828f3a77db7b9b56f0df59aae45\n       , 0x07e8e1ee732cb0d356c9c0d1069c89d17adf6a9a334f745ec7867332548ca8e9\n       , 0x0e01e81cada8162bfd5f8a8c818a6c69fedf02ceb5208523cbe5313b89ca1053\n       , 0x6bb6c6472655084399852e00249f8cb247896d392b02d73b7f0dd818e1e29b07\n       , 0x42d4636e2060f08f41c882e76b396b112ef627cc24c43dd5f83a1d1a7ead711a\n       , 0x4858c9a188b0234fb9a8d47d0b4133650a030bd0611b87c3892e94951f8df852\n       , 0x3fab3e36988d445a51c8783e531be3a02be40cd04796cfb61d40347442d3f794\n       , 0xebabc49636bd433d2ec8f0e518732ef8fa21d4d071cc3bc46cd79fa38a28b810\n       , 0xa1d0343523b893fca84f47feb4a64d350a17d8eef5497ece697d02d79178b591\n       , 0x262ebfd9130b7d28760d08ef8bfd3b86cdd3b2113d2caef7ea951a303dfa3846\n       , 0xf76158edd50a154fa78203ed2362932fcb8253aae378903eded1e03f7021a257\n       , 0x26178e950ac722f67ae56e571b284c0207684a6334a17748a94d260bc5f55274\n       , 0xc378d1e493b40ef11fe6a15d9c2737a37809634c5abad5b33d7e393b4ae05d03\n       , 0x984bd8379101be8fd80612d8ea2959a7865ec9718523550107ae3938df32011b\n       , 0xc6f25a812a144858ac5ced37a93a9f4759ba0b1c0fdc431dce35f9ec1f1f4a99\n       , 0x924c75c94424ff75e74b8b4e94358958b027b171df5e57899ad0d4dac37353b6\n       , 0x0af35892a63f45931f6846ed190361cd073089e077165714b50b81a2e3dd9ba1\n       , 0xcc80cefb26c3b2b0daef233e606d5ffc80fa17427d18e30489673e06ef4b87f7\n       , 0xc2f8c8117447f3978b0818dcf6f70116ac56fd184dd1278494e103fc6d74a887\n       , 0xbdecf6bfc1ba0df6e862c831992207796acc797968358828c06e7a51e090098f\n       , 0x24d1a26e3dab02fe4572d2aa7dbd3ec30f0693db26f273d0ab2cb0c13b5e6451\n       , 0xec56f58b09299a300b140565d7d3e68782b6e2fbeb4b7ea97ac057989061dd3f\n       , 0x11a437c1aba3c119ddfab31b3e8c841deeeb913ef57f7e48f2c9cf5a28fa42bc\n       , 0x53c7e6114b850a2cb496c9b3c69a623eaea2cb1d33dd817e4765edaa6823c228\n       , 0x154c3e96fee5db14f8773e18af14857913509da999b46cdd3d4c169760c83ad2\n       , 0x40b9916f093e027a8786641818920620472fbcf68f701d1b680632e6996bded3\n       , 0x24c4cbba07119831a726b05305d96da02ff8b148f0da440fe233bcaa32c72f6f\n       , 0x5d201510250020b783689688abbf8ecf2594a96a08f2bfec6ce0574465dded71\n       , 0x043b97e336ee6fdbbe2b50f22af83275a4084805d2d5645962454b6c9b8053a0\n       , 0x564835cbaea774948568be36cf52fcdd83934eb0a27512dbe3e2db47b9e6635a\n       , 0xf21c33f47bde40a2a101c9cde8027aaf61a3137de2422b30035a04c270894183\n       , 0x9db0ef74e66cbb842eb0e07343a03c5c567e372b3f23b943c788a4f250f67891\n       , 0xab8d08655ff1d3fe8758d562235fd23e7cf9dcaad658872a49e5d3183b6ccebd\n       , 0x6f27f77e7bcf46a1e963ade0309733543031dccdd47caac174d7d27ce8077e8b\n       , 0xe3cd54da7e444caa6207569525a670ebae1278de4e3fe2684b3e33f5ef90cc1b\n       , 0xb2c3e33a51d22c4c08fc0989c873c9cc4150579b1e6163fa694ad51d53d712dc\n       , 0xbe7fda983e13189b4c77e0a80920b6e0e0ea80c3b84dbe7e7117d253f48112f4\n       , 0xb6008c28fae08aa427e5bd3aad36f10021f16c77cfeabed07f97cc7dc1f1284a\n       , 0x6e4e6760c538f2e97b3adbfbbcde57f8966b7ea8fcb5bf7efec913fd2a2b0c55\n       , 0x4ae51fd1834aa5bd9a6f7ec39fc663338dc5d2e20761566d90cc68b1cb875ed8\n       , 0xb673aad75ab1fdb5401abfa1bf89f3add2ebc468df3624a478f4fe859d8d55e2\n       , 0x13c9471a9855913539836660398da0f3f99ada08479c69d1b7fcaa3461dd7e59\n       , 0x2c11f4a7f99a1d23a58bb636350fe849f29cbac1b2a1112d9f1ed5bc5b313ccd\n       , 0xc7d3c0706b11ae741c05a1ef150dd65b5494d6d54c9a86e2617854e6aeeebbd9\n       , 0x194e10c93893afa064c3ac04c0dd808d791c3d4b7556e89d8d9cb225c4b33339\n       , 0x6fc4988b8f78546b1688991845908f134b6a482e6994b3d48317bf08db292185\n       , 0x5665beb8b0955525813b5981cd142ed4d03fba38a6f3e5ad268e0cc270d1cd11\n       , 0xb883d68f5fe51936431ba4256738053b1d0426d4cb64b16e83badc5e9fbe3b81\n       , 0x53e7b27ea59c2f6dbb50769e43554df35af89f4822d0466b007dd6f6deafff02\n       , 0x1f1a0229d4640f01901588d9dec22d13fc3eb34a61b32938efbf5334b2800afa\n       , 0xc2b405afa0fa6668852aee4d88040853fab800e72b57581418e5506f214c7d1f\n       , 0xc08aa1c286d709fdc7473744977188c895ba011014247e4efa8d07e78fec695c\n       , 0xf03f5789d3336b80d002d59fdf918bdb775b00956ed5528e86aa994acb38fe2d\n       ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/TestHMAC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named TestHMAC that contains the following: (1) imports for the HMAC and SHA256 modules so the HMAC-SHA256 function is available; (2) a property named pass that verifies two HMAC-SHA256 test vectors. The property must check that computing HMAC-SHA256 with a key consisting of 20 repeated bytes of value 0x0b and the message \"Hi There\" yields the digest 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7, and that computing HMAC-SHA256 with the key \"Jefe\" and the message \"what do ya want for nothing?\" yields the digest 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843. Aggregate the two boolean equalities into a two-element sequence and assert that all entries are true by comparing against an all-ones sequence of matching length, so the property holds only if both test vectors match their expected digests."},{"role":"assistant","content":"```cryptol\nmodule TestHMAC where\n\nimport HMAC\nimport SHA256\n\nproperty pass =\n    ~zero ==\n    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] \"Hi There\" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\n    , hmacSHA256 \"Jefe\" \"what do ya want for nothing?\" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\n    ]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/CryptoBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named CryptoBox that imports Salsa20, Poly1305, and CfrgCurves, and contains the following definitions: (1) A polymorphic function crypto_box with a size parameter for the message length. Constrain the size parameter to be finite and such that the bit-width needed to represent (32 + message length) is at most 64. The function takes a byte-sequence message, a 24-byte nonce, a Curve25519 public key, and a Curve25519 private key, derives a shared secret via X25519, derives a 32-byte key using HSalsa20 with 20 rounds and a zero constant, and returns an authenticated ciphertext of message length plus 16 bytes by delegating to the symmetric primitive. Provide a complete type signature. (2) A function crypto_box_open with matching constraints and types that takes the authenticated ciphertext, a 24-byte nonce, a public key, and a private key, derives the same symmetric key as above, verifies and decrypts via the symmetric primitive, and returns a pair of a validity bit and the plaintext bytes (zeroed if invalid). (3) A function crypto_secretbox that takes a byte-sequence message, a 32-byte key, and a 24-byte nonce. Encrypt 32 zero bytes concatenated with the message using XSalsa20 with 20 rounds; use the first 32 bytes of the resulting stream as the one-time Poly1305 key; compute the MAC over the ciphertext portion after removing the initial 32 bytes; output tag concatenated with ciphertext. Provide a precise type signature and size constraints as above. (4) A function crypto_secretbox_open mirroring the prior behavior: split tag and ciphertext, recompute keystream and MAC, compare tags, and return (valid, plaintext) with zero plaintext if invalid. (5) A property that for two Curve25519 keypairs, sealing a fixed-size message with one side and opening with the counterpart yields the original message. (6) A property that for the symmetric primitive, opening the output of sealing a fixed-size message returns the original message. (7) A property aggregating known-answer tests for the symmetric primitive, and a boolean constant encoding one such test vector equality. Specify all byte lengths explicitly in the types."},{"role":"assistant","content":"```cryptol\nmodule CryptoBox where\n\nimport Salsa20\nimport Poly1305\nimport CfrgCurves\n\ncrypto_box : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes)) => [msgBytes][8] -> [24][8] -> Public25519 -> Private25519 -> [msgBytes + 16][8]\ncrypto_box m n pub priv = crypto_secretbox m k n\n where\n  s          = Curve25519 priv pub\n  k          = HSalsa20_bytes `{r=20} s zero\n\ncrypto_box_open : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes)) => [msgBytes+16][8] -> [24][8] -> Public25519 -> Private25519 -> (Bit,[msgBytes][8])\ncrypto_box_open box n pub priv = crypto_secretbox_open box k n\n where\n  (tag,ct)  = splitAt `{16} box\n  s         = Curve25519 priv pub\n  k         = HSalsa20_bytes `{r=20} s zero\n\ncrypto_secretbox : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes))\n                => [msgBytes][8] -> [32][8] -> [24][8] -> [msgBytes + 16][8]\ncrypto_secretbox m k n = box\n where\n  blob       = XSalsa20_encrypt `{r=20} k n ((zero : [32][8]) # m)\n  authKey    = join (take `{32} blob)\n  ciphertext = drop `{32} blob\n  authTag    = Poly1305 authKey ciphertext\n  box        = authTag # ciphertext\n\ncrypto_secretbox_open : {msgBytes} (fin msgBytes, 64 >= width (32 + msgBytes))\n                     => [msgBytes + 16][8] -> [32][8] -> [24][8] -> (Bit,[msgBytes][8])\ncrypto_secretbox_open box k n = (valid,pt)\n where\n  (tag,ct)  = splitAt `{16} box\n  blob      = XSalsa20_encrypt `{r=20} k n ((zero : [32][8]) # ct)\n  authKey   = join (take `{32} blob)\n  plaintext = drop blob                  : [msgBytes][8]\n  cTag      = Poly1305 authKey ct\n  valid     = cTag == tag\n  pt        = if valid then plaintext else zero\n\nproperty cat_in_a_box priv1 priv2 msg nonce = open == msg\n  where pub1 = Curve25519 priv1 basePoint25519\n        pub2 = Curve25519 priv2 basePoint25519\n        box  = crypto_box (msg : [100][8]) nonce pub2 priv1\n        open = (crypto_box_open box nonce pub1 priv2).1\n\nproperty hat_in_a_box k msg nonce = open == msg\n  where box  = crypto_secretbox (msg : [88][8]) k nonce\n        open = (crypto_secretbox_open box k nonce).1\n\nproperty crypto_box_kats = zero != [ katTest1 ]\n\nkatTest1 = crypto_secretbox \"hello\" zero zero == split 0xc769f9d535dc338e99ac93440502c7ceae5bd79391\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Salsa20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Salsa20 that imports LittleEndian and contains the following definitions and checks.\n- quarterround: transform 4 32-bit words using word-wise addition modulo 2^32, XOR, and left-rotations by 7, 9, 13, and 18 to produce 4 words.\n- rowround: transform a 16-word state by applying quarterround to the four rows of the 4\u00d74 matrix layout; rowround_opt: an equivalent vectorized\/rotational formulation. Define a boolean function columnround_opt_is_columnround that returns equality of columnround and columnround_opt for any input.\n- columnround: apply quarterround to the four columns of the 4\u00d74 matrix layout; columnround_opt: an equivalent vectorized\/transpose formulation.\n- doubleround: apply columnround then rowround to a 16-word state.\n- Salsa20: parameterized by r with constraint width r \u2264 8, mapping 64 bytes to 64 bytes by forming 16 little-endian 32-bit words, adding the initial state to the state after r\/2 applications of doubleround, then outputting bytes in little-endian order.\n- Define a property that checks the quarterround known-answer vectors; a property that checks the rowround vectors; a property that proves rowround_opt equals rowround for all inputs; a property that checks the columnround vectors; a property that columnround is the transpose of rowround; a property that checks the doubleround vectors; a property that states injectivity of Salsa20 at r=20; properties that check three standard Salsa20 block test vectors and an scrypt-derived test at r=8; a property that doubleround has no collisions on distinct inputs; a property that the XSalsa20 test encrypts a short ASCII message to the expected bytes; properties theorem1\u2013theorem4 showing fixed-point\/invariance patterns; and a property theorem7 relating equality of Salsa20Words outputs when the input XOR equals a fixed per-word MSB mask.\n- Salsa20_expansion: for a \u2208 {1,2}, map a 16\u00b7a-byte key and 16-byte nonce to 64 bytes using the standard constant words; Salsa20_encrypt: for a \u2208 {1,2} and message length l \u2264 2^70, XOR the message with the keystream blocks.\n- HSalsa20 and HSalsa20_bytes: derive a 32-byte subkey from a 32-byte key and 24-byte nonce; define type aliases Key (32 bytes), Nonce (24 bytes), Counter (64-bit).\n- Salsa20_Constant: the 4 constant 32-bit words derived from the standard ASCII constant for the 32-byte key variant.\n- XSalsa20: parameterized by r, produce a 64-byte block from Key, Nonce, and 64-bit counter using HSalsa20; XSalsa20_expansion and XSalsa20_encrypt: generate and XOR an arbitrary-length keystream subject to width constraints.\n- Salsa20Words: transform a 16\u00d732-bit state by byte-order reversals, apply the r=20 block, and return rearranged words."},{"role":"assistant","content":"```cryptol\nmodule Salsa20 where\n\nimport LittleEndian\n\nquarterround : [4][32] -> [4][32]\nquarterround [y0, y1, y2, y3] = [z0, z1, z2, z3]\n  where\n    z1 = y1 ^ ((y0 + y3) <<< 0x7)\n    z2 = y2 ^ ((z1 + y0) <<< 0x9)\n    z3 = y3 ^ ((z2 + z1) <<< 0xd)\n    z0 = y0 ^ ((z3 + z2) <<< 0x12)\n\nproperty quarterround_passes_tests =\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000000] == [0x00000000, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (quarterround [0x00000001, 0x00000000, 0x00000000, 0x00000000] == [0x08008145, 0x00000080, 0x00010200, 0x20500000]) \/\\\n  (quarterround [0x00000000, 0x00000001, 0x00000000, 0x00000000] == [0x88000100, 0x00000001, 0x00000200, 0x00402000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000001, 0x00000000] == [0x80040000, 0x00000000, 0x00000001, 0x00002000]) \/\\\n  (quarterround [0x00000000, 0x00000000, 0x00000000, 0x00000001] == [0x00048044, 0x00000080, 0x00010000, 0x20100001]) \/\\\n  (quarterround [0xe7e8c006, 0xc4f9417d, 0x6479b4b2, 0x68c67137] == [0xe876d72b, 0x9361dfd5, 0xf1460244, 0x948541a3]) \/\\\n  (quarterround [0xd3917c5b, 0x55f1c407, 0x52a58a7a, 0x8f887a3b] == [0x3e2f308c, 0xd90a8f36, 0x6ab2a923, 0x2883524c])\n\nrowround : [16][32] -> [16][32]\nrowround [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15] =\n    [z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15]\n  where\n    [ z0,  z1,  z2,  z3] = quarterround [ y0,  y1,  y2,  y3]\n    [ z5,  z6,  z7,  z4] = quarterround [ y5,  y6,  y7,  y4]\n    [z10, z11,  z8,  z9] = quarterround [y10, y11,  y8,  y9]\n    [z15, z12, z13, z14] = quarterround [y15, y12, y13, y14]\n\nproperty rowround_passes_tests =\n  (rowround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000,\n             0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n            [0x08008145, 0x00000080, 0x00010200, 0x20500000,\n             0x20100001, 0x00048044, 0x00000080, 0x00010000,\n             0x00000001, 0x00002000, 0x80040000, 0x00000000,\n             0x00000001, 0x00000200, 0x00402000, 0x88000100]) \/\\\n  (rowround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n             0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n             0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n             0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n            [0xa890d39d, 0x65d71596, 0xe9487daa, 0xc8ca6a86,\n             0x949d2192, 0x764b7754, 0xe408d9b9, 0x7a41b4d1,\n             0x3402e183, 0x3c3af432, 0x50669f96, 0xd89ef0a8,\n             0x0040ede5, 0xb545fbce, 0xd257ed4f, 0x1818882d])\n\nrowround_opt : [16][32] -> [16][32]\nrowround_opt ys = join [ (quarterround (yi<<<i))>>>i | yi <- split ys | i <- [0 .. 3] : [_][8] ]\n\nproperty rowround_opt_is_rowround ys = rowround ys == rowround_opt ys\n\ncolumnround : [16][32] -> [16][32]\ncolumnround [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15] =\n    [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15]\n  where\n    [ y0,  y4,  y8, y12] = quarterround [ x0,  x4,  x8, x12]\n    [ y5,  y9, y13,  y1] = quarterround [ x5,  x9, x13,  x1]\n    [y10, y14,  y2,  y6] = quarterround [x10, x14,  x2,  x6]\n    [y15,  y3,  y7, y11] = quarterround [x15,  x3,  x7, x11]\n\nproperty columnround_passes_tests =\n  (columnround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000001, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x10090288, 0x00000000, 0x00000000, 0x00000000,\n                0x00000101, 0x00000000, 0x00000000, 0x00000000,\n                0x00020401, 0x00000000, 0x00000000, 0x00000000,\n                0x40a04001, 0x00000000, 0x00000000, 0x00000000]) \/\\\n  (columnround [0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,\n                0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,\n                0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,\n                0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a] ==\n               [0x8c9d190a, 0xce8e4c90, 0x1ef8e9d3, 0x1326a71a,\n                0x90a20123, 0xead3c4f3, 0x63a091a0, 0xf0708d69,\n                0x789b010c, 0xd195a681, 0xeb7d5504, 0xa774135c,\n                0x481c2027, 0x53a8e4b5, 0x4c1f89c5, 0x3f78c9c8])\n\ncolumnround_opt : [16][32] -> [16][32]\ncolumnround_opt xs = join (transpose [ (quarterround (xi<<<i))>>>i | xi <- transpose(split xs) | i <- [0 .. 3] : [_][8] ])\n\ncolumnround_opt_is_columnround xs = columnround xs == columnround_opt xs\n\nproperty columnround_is_transpose_of_rowround ys =\n  rowround ys == join(transpose(split`{4}(columnround xs)))\n  where xs = join(transpose(split`{4} ys))\n\ndoubleround : [16][32] -> [16][32]\ndoubleround(xs) = rowround(columnround(xs))\n\nproperty doubleround_passes_tests =\n  (doubleround [0x00000001, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000,\n                0x00000000, 0x00000000, 0x00000000, 0x00000000] ==\n               [0x8186a22d, 0x0040a284, 0x82479210, 0x06929051,\n                0x08000090, 0x02402200, 0x00004000, 0x00800000,\n                0x00010200, 0x20400000, 0x08008104, 0x00000000,\n                0x20500000, 0xa0000040, 0x0008180a, 0x612a8020]) \/\\\n  (doubleround [0xde501066, 0x6f9eb8f7, 0xe4fbbd9b, 0x454e3f57,\n                0xb75540d3, 0x43e93a4c, 0x3a6f2aa0, 0x726d6b36,\n                0x9243f484, 0x9145d1e8, 0x4fa9d247, 0xdc8dee11,\n                0x054bf545, 0x254dd653, 0xd9421b6d, 0x67b276c1] ==\n               [0xccaaf672, 0x23d960f7, 0x9153e63a, 0xcd9a60d0,\n                0x50440492, 0xf07cad19, 0xae344aa0, 0xdf4cfdfc,\n                0xca531c29, 0x8e7943db, 0xac1680cd, 0xd503ca00,\n                0xa74b2ad6, 0xbc331c5c, 0x1dda24c7, 0xee928277])\n\nSalsa20 : {r} (8 >= width r) => [64][8] -> [64][8]\nSalsa20 xs = join ar\n  where\n    ar = [ littleendian_inverse words | words <- xw + zs@(`r\/2 : [8]) ]\n    xw = [ littleendian xi | xi <- split xs ]\n    zs = [xw] # [ doubleround zi | zi <- zs ]\n\nproperty Salsa20_bijective a b = (a == b) || (Salsa20 `{r=20} a != Salsa20 `{r=20} b)\nproperty Salsa20_passes_tests =\n  (Salsa20 `{r=20}\n           [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0] ==\n           [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n              0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]) \/\\\n  (Salsa20 `{r=20}\n            [211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37, 191, 187, 234, 136,\n             49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,  86,  16, 179, 207,\n             31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113, 238,  55, 204,  36,\n             79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,  88, 118, 104,  54] ==\n           [109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,  26, 110, 170, 154,\n             29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,  69, 144,  51,  57,\n            118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35,  27, 111, 114, 114,\n            219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158, 179,  19,  48, 202]) \/\\\n  (Salsa20 `{r=20}\n           [ 88, 118, 104,  54,  79, 201, 235,  79,   3,  81, 156,  47, 203,  26, 244, 243,\n            191, 187, 234, 136, 211, 159,  13, 115,  76,  55,  82, 183,   3, 117, 222,  37,\n             86,  16, 179, 207,  49, 237, 179,  48,   1, 106, 178, 219, 175, 199, 166,  48,\n            238,  55, 204,  36,  31, 240,  32,  63,  15,  83,  93, 161, 116, 147,  48, 113] ==\n           [179,  19,  48, 202, 219, 236, 232, 135, 111, 155, 110,  18,  24, 232,  95, 158,\n             26, 110, 170, 154, 109,  42, 178, 168, 156, 240, 248, 238, 168, 196, 190, 203,\n             69, 144,  51,  57,  29,  29, 150,  26, 150,  30, 235, 249, 190, 163, 251,  48,\n             27, 111, 114, 114, 118,  40, 152, 157, 180,  57,  27,  94, 107,  42, 236,  35])\n\nproperty Salsa20_has_no_collisions x1 x2 =\n    x1 == x2 \\\/ doubleround x1 != doubleround x2\n\nproperty Salsa20_passes_scrypt_tests =\n  Salsa20 `{r=8}\n          [ 0x7e, 0x87, 0x9a, 0x21, 0x4f, 0x3e, 0xc9, 0x86, 0x7c, 0xa9, 0x40, 0xe6, 0x41, 0x71, 0x8f, 0x26\n          , 0xba, 0xee, 0x55, 0x5b, 0x8c, 0x61, 0xc1, 0xb5, 0x0d, 0xf8, 0x46, 0x11, 0x6d, 0xcd, 0x3b, 0x1d\n          , 0xee, 0x24, 0xf3, 0x19, 0xdf, 0x9b, 0x3d, 0x85, 0x14, 0x12, 0x1e, 0x4b, 0x5a, 0xc5, 0xaa, 0x32\n          , 0x76, 0x02, 0x1d, 0x29, 0x09, 0xc7, 0x48, 0x29, 0xed, 0xeb, 0xc6, 0x8d, 0xb8, 0xb8, 0xc2, 0x5e\n          ]\n   == [ 0xa4, 0x1f, 0x85, 0x9c, 0x66, 0x08, 0xcc, 0x99, 0x3b, 0x81, 0xca, 0xcb, 0x02, 0x0c, 0xef, 0x05\n      , 0x04, 0x4b, 0x21, 0x81, 0xa2, 0xfd, 0x33, 0x7d, 0xfd, 0x7b, 0x1c, 0x63, 0x96, 0x68, 0x2f, 0x29\n      , 0xb4, 0x39, 0x31, 0x68, 0xe3, 0xc9, 0xe6, 0xbc, 0xfe, 0x6b, 0xc5, 0xb7, 0xa0, 0x6d, 0x96, 0xba\n      , 0xe4, 0x24, 0xcc, 0x10, 0x2c, 0x91, 0x74, 0x5c, 0x24, 0xad, 0x67, 0x3d, 0xc7, 0x61, 0x8f, 0x81\n      ]\n\nSalsa20_expansion : {a} (a >= 1, 2 >= a) => ([16*a][8], [16][8]) -> [64][8]\nSalsa20_expansion(k, n) = z\n  where\n    [s0, s1, s2, s3] = split \"expand 32-byte k\" : [4][4][8]\n    [t0, t1, t2, t3] = split \"expand 16-byte k\" : [4][4][8]\n    x = if(`a == (2 : [8])) then s0 # k0 # s1 # n # s2 # k1 # s3\n                            else t0 # k0 # t1 # n # t2 # k0 # t3\n    z = Salsa20 `{r=20} x\n    [k0, k1] = (split(k#zero)):[2][16][8]\n\nSalsa20_encrypt : {a, l} (a >= 1, 2 >= a, l <= 2^^70) => ([16*a][8], [8][8], [l][8]) -> [l][8]\nSalsa20_encrypt(k, v, m) = c\n  where\n    salsa = take (join [ Salsa20_expansion(k, v#(split i)) | i <- [0, 1 ... ] ])\n    c     = m ^ salsa\n\nHSalsa20 : {r} (8 >= width r) => Key -> Nonce -> [8][32]\nHSalsa20 key0 nonce0 = zs @@ ([0,5,10,15,6,7,8,9] : [_][8])\n  where\n  zs    = infZs @ (`r\/2 :[8])\n  infZs = [xs] # [ doubleround x | x <- infZs ]\n\n  nonce                         = [ littleendian (split n) | n <- split (join nonce0)]\n  [x0,x5,x10,x15]               = Salsa20_Constant\n  [x1,x2,x3,x4,x11,x12,x13,x14] = [ littleendian (split k) | k <- split (join key0)]\n  [x6,x7,x8,x9]                 = nonce @@ ([0..3] : [_][8])\n\n  xs : [16][32]\n  xs     = [x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15]\n\nHSalsa20_bytes : {r} (8 >= width r) => Key -> Nonce -> [32][8]\nHSalsa20_bytes key0 nonce0 = join [littleendian_inverse x | x <- HSalsa20 `{r=r} key0 nonce0]\n\ntype Key      = [256\/8][8]\ntype Nonce    = [192\/8][8]\ntype Counter  = [64]\n\nSalsa20_Constant : [4][32]\nSalsa20_Constant = [littleendian (split x) | x <- split (join \"expand 32-byte k\") : [4][32]]\n\nXSalsa20 : {r} (8 >= width r) => Key -> Nonce -> Counter -> [64][8]\nXSalsa20 key0 nonce0 ctr =\n    split (join [littleendian (split (x' + z')) | x' <- xs' | z' <- zs'])\n  where\n  nonce                         = [ littleendian (split n) | n <- split (join nonce0)]\n\n  subKey = HSalsa20 `{r=r} key0 nonce0 \n  [x'0,x'5,x'10,x'15]                   = Salsa20_Constant\n  [x'1,x'2,x'3,x'4,x'11,x'12,x'13,x'14] = subKey\n  [x'6,x'7]                             = nonce @@ ([4,5] : [_][8])\n  [x'8,x'9]                             = reverse (split ctr)\n\n  xs', zs' : [16][32]\n  xs'       = [ x'0 ,x'1 ,x'2 ,x'3 ,x'4 ,x'5 ,x'6 ,x'7 ,x'8\n              , x'9 ,x'10 ,x'11 ,x'12 ,x'13 ,x'14 ,x'15\n              ]\n  infZs'    = [xs'] # [ doubleround x | x <- infZs' ]\n  zs'       = infZs' @ (`r\/2 : [8])\n\nXSalsa20_expansion : {n,r} (8 >= width r, 64 >= width n) => Key -> Nonce -> [n][8]\nXSalsa20_expansion k n = take (join ks)\n   where\n   ks = [XSalsa20 `{r=r} k n i | i <- [0...]]\n\nXSalsa20_encrypt : {n,r} (8 >= width r, 64 >= width n) => Key -> Nonce -> [n][8] -> [n][8]\nXSalsa20_encrypt k n msg = ks ^ msg\n where ks = XSalsa20_expansion `{r=r} k n\n\nproperty test =\n    ct == [0x00, 0x2d, 0x45, 0x13, 0x84, 0x3f, 0xc2, 0x40, 0xc4, 0x01, 0xe5, 0x41]\n  where\n   ct    = XSalsa20_encrypt `{r=20} key nonce \"Hello world!\"\n   key   = \"this is 32-byte key for xsalsa20\"\n   nonce = \"24-byte nonce for xsalsa\"\n\nproperty theorem1 a = quarterround [a, -a, a, -a] == [a,-a,a,-a]\nproperty theorem2 a b c d = rowround val == val\n    where val    = [a,-a,a,-a\n                   ,b,-b,b,-b\n                   ,c,-c,c,-c\n                   ,d,-d,d,-d]\nproperty theorem3 a b c d = columnround val == val\n    where val    = [a,-b,c,-d\n                   ,-a,b,-c,d\n                   ,a,-b,c,-d\n                   ,-a,b,-c,d]\nproperty theorem4 a = doubleround val == val\n    where val    = [a,-a,a,-a\n                   ,-a,a,-a,a\n                   ,a,-a,a,-a\n                   ,-a,a,-a,a]\nproperty theorem7 a b =\n    a ^ b != diff \\\/ Salsa20Words a == Salsa20Words b\n where\n  diff = [ 0x80000000 | _ <- [0..15]:[_][4] ]\n\nSalsa20Words : [16][32] -> [16][32]\nSalsa20Words x = [join (reverse r) | r <- split `{each=4} (Salsa20 `{r=20} (join [reverse (split `{4} v) | v <- x]))]\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/PBKDF2.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named PBKDF2 that contains the following definitions: (1) A polymorphic function pbkdf2 that implements PBKDF2 using HMAC-SHA-256. It takes a password as a sequence of bytes, a salt as a sequence of bytes, and returns a derived key of an exact, caller-specified bit length. Constrain parameters so that: the password bit-length fits in a 64-bit length field, the derived key length is finite and at least 1, the iteration count is at least 1 and fits in 16 bits, the salt length plus a 32-bit counter fits in a 32-bit length field, and the number of 256-bit output blocks (the ceiling of the derived-key length divided by 256) fits in 32 bits. Compute blocks T_i by: U_1 = HMAC-SHA-256(password, salt || INT(i)); U_j = HMAC-SHA-256(password, U_{j-1}) for j>1; T_i = U_1 XOR \u2026 XOR U_C. Concatenate T_i for i from 1 to the required block count, then truncate to the requested bit length. (2) A helper function inner with a suitable type signature that, given a password and the initial 32-byte U_1 for a block index, computes the 256-bit XOR accumulator T_i over exactly C iterations. Include constraints ensuring the password bit-length fits the SHA-256 length field and iteration count bounds. (3) A helper function F with a type signature that takes a password, a 256-bit accumulator, and a 32-byte U value, and returns the next accumulator and next U by applying HMAC-SHA-256 and XORing. (4) A property named test1 that checks pbkdf2 against a standard published test vector for HMAC-SHA-256 with a single iteration and a fixed derived-key length, asserting equality with the known expected output."},{"role":"assistant","content":"```cryptol\nmodule PBKDF2 where\n\nimport SHA256\nimport HMAC\n\npbkdf2 : {pwBytes, saltBytes, dkLenBits, C}\n         ( 64 >= width (8 * pwBytes)\n         , dkLenBits >= 1\n         , fin dkLenBits\n         , C >= 1\n         , 16 >= width C\n         , 32 >= width (4 + saltBytes)\n         , 32 >= width ((dkLenBits + 255)\/256)\n         )\n      => [pwBytes][8] -> [saltBytes][8] -> [dkLenBits]\npbkdf2 P S = take `{dkLenBits} (join Ts)\n where\n Ts : [_][256]\n Ts = [ inner `{C=C} P (split (hmacSHA256 P (S # split i))) | i <- [1..len] : [_][32] ]\n type len = (dkLenBits + 255)\/256\n\ninner : {pwBytes, C}\n         ( 64 >= width (8 * pwBytes)\n         , C >= 1, 16 >= width C\n         )\n     =>  [pwBytes][8] -> [32][8] -> [256]\ninner P U0 = (Ts @ 0).0  where\n    Ts = [(join U0, U0)] # [ F P t u  | _ <- [1..C] : [_][16] | (t,u) <- Ts ]\n\nF : {pwBytes} ( 64 >= width (8 * pwBytes)\n              ) => [pwBytes][8] -> [256] -> [32][8] -> ([256],[32][8])\nF P Tprev Uprev = (Tnext,Unext)\n  where\n  Unext = split (hmacSHA256 P Uprev)\n  Tnext = Tprev ^ join Unext\n\ntest1 : Bit\nproperty test1 = pbkdf2 `{C=1,dkLenBits=64*8} \"passwd\" \"salt\" == 0x55ac046e56e3089fec1691c22544b605f94185216dde0465e68b9d57c20dacbc49ca9cccf179b645991664b39d77ef317c71b845b1e30bd509112041d3a19783\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Base64.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Base64 that contains the following definitions and checks: (1) A type synonym Enc64 n that computes the encoded byte length as four times the sum of the input length n and a padding count, divided by three, where the padding count is (3 \u2212 (n mod 3)) mod 3. (2) A function base64enc with size parameters n, m, padZ and constraints: fin n, fin m, padZ = (3 \u2212 (n mod 3)) mod 3, 2 \u2265 padZ, and 4*(padZ + n)\/3 = m. It takes an array of n bytes and returns an array of Enc64 n bytes. Specify the algorithm: pad the input with padZ zero bytes, partition into groups of three bytes, convert into four 6-bit values, map each 6-bit value to the standard Base64 alphabet, and append padZ \u2018=\u2019 bytes. (3) A constant alphabet equal to the standard 64-character Base64 alphabet. (4) A function base64chunks for any finite n that maps [n*3] bytes to [n*4] bytes by splitting into 6-bit chunks and mapping each index via the alphabet; include a helper that maps a 6-bit index to its alphabet byte. (5) A function base64dec with size parameters n, m and constraints fin n, fin m, 4*n = 3*m, returning a pair of n bytes and a 2-bit padding count. Specify helpers: one that maps an input byte to an 8-bit code (letters, digits, plus, slash to 0..63; others to zero), and another that drops the low two bits to produce a 6-bit value. Count up to two trailing \u2018=\u2019 bytes. (6) Properties: decoding the encoding of any input yields the original bytes and the correct padding count; the alphabet has length 64 and the encode\/decode character mappings are inverse on valid characters; the padding count is between 0 and 2; the encoded length equals Enc64 n."},{"role":"assistant","content":"```cryptol\nmodule Base64 where\n\ntype Enc64 n = 4*(((3-(n%3))%3) + n)\/3\n\nbase64enc : {n,m,padZ} (4*(padZ + n)\/3 == m, fin n, fin m, padZ == (3-(n%3))%3, 2>=padZ)\n          => [n][8] -> [Enc64 n][8]\nbase64enc ns = take `{m} (chunks # padEq)\n where\n  chunks      = take `{(4*n+2)\/3} (base64chunks `{(n+2)\/3} (ns # padZero))\n  padZero     = take `{padZ} [zero | _ <- [1..2] : [_][2]]\n  padEq       = \"==\"\n\nalphabet = ['A'..'Z'] # ['a'..'z'] # ['0'..'9'] # \"+\/\"\n\nbase64chunks : {n} (fin n) => [n*3][8] -> [n*4][8]\nbase64chunks m = [basify x |  x <- ns]\n where\n  ns = split (join m) : [_][6]\n  basify : [6] -> [8]\n  basify x = alphabet @ x\n\nbase64dec : {n,m} (fin m, 4*n == 3*m, fin n) => [m][8] -> ([n][8],[2])\nbase64dec ms = (split (join [debase x | x <- ms]), nrEq)\n where\n nrEq : [2]\n nrEq = sum [ zero # [x == '='] | x <- take `{2} (reverse ms # [zero,zero]) ]\n\n debase : [8] -> [6]\n debase x = drop `{2} (debase' x)\n\n debase' : [8] -> [8]\n debase' x =\n    if x >= 'A' \/\\ x <= 'Z'\n        then x - 'A'\n        else if x >= 'a' \/\\ x <= 'z'\n              then x - 'a' + 26\n              else if x >= '0' \/\\ x <= '9'\n                    then x - '0' + 52\n                    else if x == '+'\n                        then 62\n                        else if x == '\/'\n                                then 63\n                                else zero \/\/ Pad bytes are decoded as NUL\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/Base58.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Base58 that contains the following definitions: (1) a constant charMap with type [58][8], holding the 58-character Bitcoin Base58 alphabet (digits 1\u20139, uppercase letters except O and I, lowercase letters except l), encoded as 8-bit character codes; (2) a function base58enc with type variables n and m, requiring finite sizes, n \u2265 6, and signature [n] -> [m][8]. It must implement Base58 encoding by repeatedly dividing the input value by 58 to produce digits 0..57, mapping each digit to an 8-bit character using charMap, selecting exactly m digits (least significant first), and returning them in most-significant-first order. Use local helpers: a stream of quotient\/digit pairs from repeated division and a charOf function to index charMap; (3) a function base58dec with type variables n and m, requiring finite sizes and constraints n \u2265 1, n \u2265 width m, and n \u2265 8, with signature [m][8] -> [n]. It must decode an m-length sequence of 8-bit characters by reversing the sequence, converting each character to a digit 0..57 via a local dec' that inverts the Base58 alphabet mapping (handling alphabet gaps for excluded characters), zero-extending the 8-bit digit to n bits via dec, and summing digit * 58^position to reconstruct the value. Clearly specify all type signatures, constraints, helper functions (charOf, dec, dec'), and the ordering conventions used during encode\/decode."},{"role":"assistant","content":"```cryptol\nmodule Base58 where\n\nbase58enc : {n,m} (fin n, fin m, n >= 6 ) => [n] -> [m][8]\nbase58enc ns = [ x.1 | x <- reverse (take `{m} (drop `{1} enc))]\n where\n  enc      = [(ns,zero)] # [ (n\/58,charOf (n%58)) | (n,_) <- enc ]\n  charOf x = charMap @ x\n\ncharMap : [58][8]\ncharMap = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\nbase58dec : {n,m} (fin n, fin m, n >= 1, n >= width m, n >= 8) => [m][8] -> [n]\nbase58dec ms = sum [ (dec m) * 58 ^^ i | m <- reverse ms | i <- [0..m] ]\n where\n  dec : [8] -> [n]\n  dec x = zero # dec' x\n\n  dec' : [8] -> [8]\n  dec' x =\n    if x >= 'm'\n     then x - 'm' + 44\n     else if x >= 'a'\n            then x - 'a' + 33\n            else if x >= 'P'\n                  then x - 'P' + 22\n                  else if x > 'I'\n                        then x - 'J' + 17\n                        else if x >= 'A'\n                              then x - 'A' + 9\n                              else x - '1'\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/bv.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named bv that contains the following definitions with explicit polymorphic type signatures and fin constraints on all size parameters: uext, iext, safe_add, safe_sub, is_normal, safe_product, safe_mod, adc, and sbb. Use size variables a, b, and n (all finite). Specify behaviors precisely: (1) uext takes an a-bit word and returns an (a+b)-bit word formed by prefixing b zero bits. (2) iext takes an a-bit word and returns an (a+b)-bit word formed by prefixing b copies of the word\u2019s most significant bit (unsigned sign extension using the leading bit). (3) safe_add takes two n-bit words, zero-extends both to n+1 bits, adds them as unsigned integers, and returns the n+1-bit sum. (4) safe_sub takes two n-bit words, zero-extends both to n+1 bits, subtracts as unsigned integers, and returns the n+1-bit result. (5) is_normal takes two a-bit words p and x and returns a single Bit indicating x is strictly less than p (unsigned comparison). (6) safe_product takes two a-bit words, zero-extends both to 2a bits, multiplies them unsigned, and returns the 2a-bit product. (7) safe_mod takes a b-bit modulus p and an (a+b)-bit value x, computes x modulo p using an (a+b)-bit zero-extended modulus, and returns the lower b bits of the remainder. (8) adc takes two n-bit words, forms their n+1-bit zero-extended sum, returns a pair of the lower n bits and the most significant bit as the carry-out. (9) sbb takes two n-bit words, forms an n+1-bit subtraction after prefixing a zero bit to each operand, and returns a pair of the lower n bits and the most significant bit as the borrow\/carry indicator."},{"role":"assistant","content":"```cryptol\nmodule bv where\n\nuext : {a, b} (fin b,fin a) => [a] -> [a+b]\nuext(x) = zero # x\n\niext : {a, b} (fin b,fin a) => [a] -> [a+b]\niext(x) = (if x@0 then ~zero else zero) # x\n\nsafe_add : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_add(x,y) = uext(x) + uext(y)\n\nsafe_sub : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_sub(x,y) = uext(x) - uext(y)\n\nis_normal : {a} (fin a) => [a] -> [a] -> Bit\nis_normal p x = (x < p)\n\nsafe_product : {a} (fin a) => ([a],[a]) -> [2*a]\nsafe_product(x,y) = uext(x) * uext(y)\n\nsafe_mod : {a, b} (fin a, fin b) => ([b],[a+b]) -> [b]\nsafe_mod(p,x) = drop `{a} (x % uext(p))\n\nadc : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nadc(x,y) = (drop(sm), sm@0)\n  where sm = safe_add(x,y)\n\nsbb : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nsbb(x,y) = (drop(r), r@0)\n  where r = ([False] # x) - ([False] # y)\n```"}]}
{"filename":"cryptol\/examples\/MiniLock\/prim\/LittleEndian.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named LittleEndian that contains the following definitions: (1) A polymorphic function littleendian with the constraint that the length parameter is finite, taking a sequence of a 8-bit values and returning an a\u00d78-bit value by interpreting the input as little-endian bytes (reverse the byte order and then concatenate). Include an explicit type signature reflecting this mapping and constraint. (2) Define a property that asserts the function passes three test vectors: mapping [0,0,0,0] to 0x00000000, [86,75,30,9] to 0x091e4b56, and [255,255,255,250] to 0xfaffffff. (3) A function littleendian_inverse with type from a 32-bit value to a sequence of 4 elements of 8 bits, computed by splitting the 32-bit input into bytes and reversing the order. (4) Define a property that universally quantifies over all 4-element sequences of 8-bit values and asserts that applying littleendian followed by littleendian_inverse returns the original input. Provide clear type signatures for both functions and use the property keyword for the two boolean assertions."},{"role":"assistant","content":"```cryptol\nmodule LittleEndian where\n\nlittleendian : {a}(fin a) => [a][8] -> [a*8]\nlittleendian b = join(reverse b)\n\nproperty littleendian_passes_tests =\n  (littleendian [  0,   0,   0,   0] == 0x00000000) &&\n  (littleendian [ 86,  75,  30,   9] == 0x091e4b56) &&\n  (littleendian [255, 255, 255, 250] == 0xfaffffff)\n\nlittleendian_inverse : [32] -> [4][8]\nlittleendian_inverse b = reverse(split b)\n\nproperty littleendian_is_invertable b = littleendian_inverse(littleendian b) == b\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES\/SBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named AES::SBox that imports AES::GF28 and AES::SubBytePlain. Declare a type synonym SBox as a sequence of length 256 whose elements are the GF(2^8) field type from AES::GF28. Provide type signatures for two constants, sbox and sboxInv, both having type SBox. Define sbox as the sequence formed by applying the SubByte transformation from AES::SubBytePlain to every byte value from 0 through 255 in ascending order, producing GF(2^8) outputs. Define sboxInv as the sequence formed by applying the InvSubByte transformation from the same module to every byte value from 0 through 255 in ascending order, producing GF(2^8) outputs. Ensure the comprehensions enumerate all 256 input values exactly once and that the resulting sequences\u2019 element type matches the field type. Do not add properties or proofs; only provide the module, imports, type synonym, type signatures, and constant definitions."},{"role":"assistant","content":"```cryptol\nmodule AES::SBox where\n\nimport AES::GF28\nimport AES::SubBytePlain\n\ntype SBox = [256] GF28\n\nsbox : SBox\nsbox = [ SubByte x | x <- [0 .. 255] ]\n\nsboxInv : SBox\nsboxInv = [ InvSubByte x | x <- [0 .. 255] ]\n```"}]}
{"filename":"cryptol\/examples\/param_modules\/AES\/SubByteSBox.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named AES::SubByteSBox that imports AES::GF28 and AES::SBox and re-exports two functions. Declare a type signature for SubByte that takes one value in GF28 and returns a value in GF28; implement it by applying the imported S-box to its argument. Declare a type signature for InvSubByte that takes one value in GF28 and returns a value in GF28; implement it by applying the imported inverse S-box to its argument. Define a property that, for all b in GF28, SubByte b equals applying the imported S-box to b. Define a property that, for all b in GF28, InvSubByte b equals applying the imported inverse S-box to b. Define a property that, for all b in GF28, composing InvSubByte after SubByte yields b and composing SubByte after InvSubByte yields b. Use universally quantified variables with no additional constraints. Ensure the module exports SubByte and InvSubByte."},{"role":"assistant","content":"```cryptol\nmodule AES::SubByteSBox where\n\nimport AES::GF28\nimport AES::SBox\n\nSubByte : GF28 -> GF28\nSubByte b = sbox @ b\n\nInvSubByte : GF28 -> GF28\nInvSubByte b = sboxInv @ b\n```"}]}
{"filename":"cryptol\/lib\/Cryptol\/Reference.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Cryptol::Reference that contains the following definitions with exact types, constraints, and behaviors:\n- pmult: For size variables u and v with fin constraints, accept two bit vectors of sizes 1+u and 1+v and return a bit vector of size 1+u+v. Implement polynomial multiplication over GF(2), where XOR is coefficient addition and left-shift corresponds to multiplying by x. Use a streaming recurrence that accumulates partial products and returns the final state.\n- pdiv: For size variables u and v with fin constraints, accept bit vectors of sizes u and v and return a bit vector of size u. Compute the quotient of polynomial long division over GF(2). Determine the index of the highest nonzero coefficient of the divisor and drive a state machine that repeatedly reduces the running dividend; output the quotient bits extracted from the evolving state at that index.\n- pmod: For size variables u and v with fin constraints, accept a dividend of size u and a modulus of size 1+v and return the remainder of size v. Compute the remainder of polynomial division over GF(2) using repeated conditional reductions based on the degree of the modulus. If the modulus is the zero polynomial, return an all-unknown vector of length v.\n- foldl: For fin n, types a and b, take a binary function a -> b -> a, an initial accumulator of type a, and a sequence of n elements of type b; return the left fold result of type a.\n- scanl: For types a and b and size n, take a -> b -> a, an initial a, and a sequence of n b\u2019s; return the sequence of prefix accumulations of length 1+n.\n- iterate: For type a, take a unary function a -> a and a seed a; return an infinite stream produced by repeatedly applying the function.\nProvide precise Cryptol type signatures matching these descriptions and implement each algorithm as specified."},{"role":"assistant","content":"```cryptol\nmodule Cryptol::Reference where\n\npmult : {u, v} (fin u, fin v) => [1 + u] -> [1 + v] -> [1 + u + v]\npmult x y = last zs\n  where\n    zs = [0] # [ (z << 1) ^ (if yi then 0 # x else 0) | yi <- y | z <- zs ]\n\npdiv : {u, v} (fin u, fin v) => [u] -> [v] -> [u]\npdiv x y = [ z ! degree | z <- zs ]\n  where\n    degree : [width v]\n    degree = last (ds : [1 + v]_)\n      where ds = [0\/0] # [if yi then i else d | yi <- reverse y | i <- [0..v] | d <- ds ]\n\n    reduce : [v] -> [v]\n    reduce u = if u ! degree then u ^ y else u\n\n    zs : [u][v]\n    zs = [ tail (reduce z # [xi]) | z <- [0] # zs | xi <- x ]\n\npmod : {u, v} (fin u, fin v) => [u] -> [1 + v] -> [v]\npmod x y = if y == 0 then 0\/0 else last zs\n  where\n    degree : [width v]\n    degree = last (ds : [2 + v]_)\n      where ds = [0\/0] # [if yi then i else d | yi <- reverse y | i <- [0..v] | d <- ds ]\n\n    reduce : [1 + v] -> [1 + v]\n    reduce u = if u ! degree then u ^ y else u\n\n    powers : [inf][1 + v]\n    powers = [reduce 1] # [ reduce (p << 1) | p <- powers ]\n\n    zs = [0] # [ z ^ (if xi then tail p else 0) | xi <- reverse x | p <- powers | z <- zs ]\n\nfoldl : {n, a, b} (fin n) => (a -> b -> a) -> a -> [n]b -> a\nfoldl f z bs = last (scanl f z bs)\n\nscanl : {n, a, b}  (a -> b -> a) -> a -> [n]b -> [1+n]a\nscanl f z bs = as\n  where\n    as = [z] # [ f a b | a <- as | b <- bs ]\n\niterate : {a} (a -> a) -> a -> [inf]a\niterate f z = xs\n  where xs = [z] # [ f x | x <- xs ]\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol_eval\/test-files\/M.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named M that contains the following definitions, with explicit type signatures and exact numeric widths: - A function `f` that maps an 8-bit word to a 2-element sequence of 8-bit words by repeating the input twice. - A function `g` with the same type and behavior as `f`, implemented by constructing a two-element sequence containing two copies of the input. - A property `f_g_equiv` stating that for all 8-bit inputs, `f` and `g` produce identical outputs. - A function `h` that takes a 2-element sequence of 8-bit words and returns it unchanged. - A property `h_identity` asserting that for all such inputs, `h` returns its argument. - A polymorphic constant `m` of type `Z a` with constraints that `a` is finite and strictly greater than 42, whose value is 42. - Constants `two`, `three`, and `four` with widths 15, 16, and 17 bits respectively, holding the values 2, 3, and 4. - A polymorphic identity function `id` of type `a -> a` that returns its argument. - A property `id_returns_input` asserting that for any value (use appropriate polymorphic constraints), applying `id` yields the same value. - A type synonym `Word8` for an 8-bit word. - A type synonym `Twenty a` for a length-20 sequence of elements of type `a`. - A predicate function `isSqrtOf9` that takes an 8-bit word and returns a single bit indicating whether the 8-bit square of the input equals 9. Ensure all constraints are stated explicitly in the signatures, and all properties quantify over the required domains."},{"role":"assistant","content":"```cryptol\nmodule M where\nf : [8] -> [2][8]\nf x = repeat x\n\ng : [8] -> [2][8]\ng x = [x, x]\n\nh : [2][8] -> [2][8]\nh x = x\n\nm : {a} (fin a, a > 42) => Z a\nm = 42\n\ntwo : [15]\ntwo = 2\n\nthree : [16]\nthree = 3\n\nfour : [17]\nfour = 4\n\nid : {a} a -> a\nid x = x\n\ntype Word8 = [8]\ntype Twenty a = [20]a\n\nisSqrtOf9 : [8] -> Bit\nisSqrtOf9 x = x*x == 9\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Names.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Names that contains the following: a module value parameter key of type 64-bit word; a function enc that takes a 64-bit word and returns a 64-bit word by XORing the input with key; a property enc_correct that, for any 64-bit input, asserts the input equals the result of applying enc twice; a primitive function prim that maps a 64-bit word to a 64-bit word with no implementation; an infix operator (-!) over 64-bit words that performs saturating subtraction, yielding zero when the right operand is greater than the left, otherwise the arithmetic difference; a numeric type parameter a; a type synonym b equal to a; a constraint alias fin_b requiring that b is finite; an abstract value type c; a newtype d that wraps c with a single selector un_d of type c; and an empty nested submodule M."},{"role":"assistant","content":"```cryptol\nmodule Names where\n\nparameter\n  key : [64]\n\nenc : [64] -> [64]\nenc x = x ^ key\n\nenc_correct : [64] -> Bit\nproperty enc_correct x =\n  x == enc (enc x)\n\nprimitive prim : [64] -> [64]\n\n(-!) : [64] -> [64] -> [64]\nx -! y = if y > x then 0 else x - y\n\nparameter\n  type a : #\n\ntype b = a\n\ntype constraint fin_b = fin b\n\nprimitive type c : *\n\nnewtype d = { un_d : c }\n\nsubmodule M where\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Id.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Id that contains the following definition: a function id that acts as the identity on bit sequences. Provide a type signature that is polymorphic over a size parameter n, constrained to be finite, and maps a sequence of n bits to a sequence of n bits. Implement the body to return its single argument unchanged. Use an implicit numeric type parameter for n, include the finiteness constraint in the signature, and define the function with a single equation and no auxiliary definitions."},{"role":"assistant","content":"```cryptol\nmodule Id where\n\nid : {n} (fin n) => [n] -> [n]\nid a = a\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/CplxQNewtype.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Write a Cryptol specification that: (1) introduces a type alias for rationals; (2) declares a newtype representing complex numbers with rational real and imaginary fields; (3) provides a function that embeds a rational into the complex type by setting the imaginary component to zero (with an explicit type signature from rational to complex); (4) declares one rational constant equal to 42 and three complex constants obtained by embedding 2, 40, and 42; (5) implements complex addition that adds real parts and imaginary parts component-wise (type: complex -> complex -> complex); (6) implements complex multiplication using the standard formula (type: complex -> complex -> complex); (7) defines a boolean equality predicate that returns true iff both the real and imaginary components are equal (type: complex -> complex -> Bit); (8) define a property that addition is associative for all complex inputs, comparing results with the equality predicate; (9) define a property that multiplication is associative for all complex inputs, comparing results with the equality predicate; and (10) define a property that multiplication left-distributes over addition for all complex inputs, comparing results with the equality predicate."},{"role":"assistant","content":"```cryptol\ntype Q = Rational\n\nfortyTwo : Q\nfortyTwo = 42\n\nnewtype CplxQ =\n  { real : Q, imag : Q }\n\nembedQ : Q -> CplxQ\nembedQ x = CplxQ{ real = x, imag = 0 }\n\ncplxTwo : CplxQ\ncplxTwo = embedQ 2\n\ncplxForty : CplxQ\ncplxForty = embedQ 40\n\ncplxFortyTwo : CplxQ\ncplxFortyTwo = embedQ 42\n\ncplxAdd : CplxQ -> CplxQ -> CplxQ\ncplxAdd x y = CplxQ { real = r, imag = i }\n  where\n  r = x.real + y.real\n  i = x.imag + y.imag\n\ncplxMul : CplxQ -> CplxQ -> CplxQ\ncplxMul x y = CplxQ { real = r, imag = i }\n  where\n  r = x.real * y.real - x.imag * y.imag\n  i = x.real * y.imag + x.imag * y.real\n\ncplxEq : CplxQ -> CplxQ -> Bit\ncplxEq x y = (x.real == y.real) && (x.imag == y.imag)\n\nproperty cplxAddAssoc x y z =\n  cplxEq (cplxAdd (cplxAdd x y) z)\n         (cplxAdd x (cplxAdd y z))\n\nproperty cplxMulAssoc x y z =\n  cplxEq (cplxMul (cplxMul x y) z)\n         (cplxMul x (cplxMul y z))\n\nproperty cplxMulDistrib x y z =\n  cplxEq (cplxMul x (cplxAdd y z))\n         (cplxAdd (cplxMul x y) (cplxMul x z))\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Foo.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Foo that contains the following definitions and types: import the module Id with the alias Id; a polymorphic identity function named id with a type parameter that returns its argument unchanged; an 8-bit constant equal to 255; a polymorphic function add over bitvectors of width a with a finiteness constraint that performs built-in addition; a record constant with two 32-bit fields named foo and bar set to 23 and 99, respectively; a function getFoo that takes such a record and returns the 32-bit value of its foo field. Define eleven functions op1 through op11, each polymorphic over n with a finiteness constraint, each taking a value of width n and returning the zero value of a result type whose width is determined by a type-level computation on n, respectively: plus one; the difference of n and itself; times one; divided by one; remainder upon division by one; raised to the power one; the corresponding inverse operation with operand one; the bit-width required to represent n; the maximum of n and one; the minimum of one and n; the base-2 logarithm of n. Finally, define isSqrtOf9, a function from 8-bit values to a single bit that is true exactly when the input squared equals 9. Provide precise type signatures and bodies matching these behaviors."},{"role":"assistant","content":"```cryptol\nmodule Foo where\n\nimport Id as Id\n\nid : {a} a -> a\nid x = x\n\nx : [8]\nx = 255\n\nadd : {a} (fin a) => [a] -> [a] -> [a]\nadd = (+)\n\nfoo : {foo : [32], bar : [32]} \nfoo = {foo = 23, bar = 99}\n\ngetFoo : {foo : [32], bar : [32]}  -> [32]\ngetFoo x = x.foo\n\nop1 : {n} (fin n) => [n] -> [n + 1]\nop1 a = 0\n\nop2 : {n} (fin n) => [n] -> [n - n]\nop2 a = 0\n\nop3 : {n} (fin n) => [n] -> [n * 1]\nop3 a = 0\n\nop4 : {n} (fin n) => [n] -> [n \/ 1]\nop4 a = 0\n\nop5 : {n} (fin n) => [n] -> [n % 1]\nop5 a = 0\n\nop6 : {n} (fin n) => [n] -> [n ^^ 1]\nop6 a = 0\n\nop7 : {n} (fin n) => [n] -> [n \/^ 1]\nop7 a = 0\n\nop8 : {n} (fin n) => [n] -> [width n]\nop8 a = 0\n\nop9 : {n} (fin n) => [n] -> [max n 1]\nop9 a = 0\n\nop10 : {n} (fin n) => [n] -> [min 1 n]\nop10 a = 0\n\nop11 : {n} (fin n) => [n] -> [lg2 n]\nop11 a = 0\n\nisSqrtOf9 : [8] -> Bit\nisSqrtOf9 x = x*x == 9\n```"}]}
{"filename":"cryptol\/cryptol-remote-api\/python\/tests\/cryptol\/test-files\/Types.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Types that contains the following definitions: b as a Bit set to true; w as a 16-bit word with decimal value 42; z as an unbounded integer with value 420000; m as an integer modulo 12 with value 6; q as a rational number equal to five quarters; t as a pair consisting of a Bit and an Integer set to false and seven respectively; s as a 3-by-3 matrix of 8-bit words containing the numbers one through nine in row-major order; r as a record with fields xCoord and yCoord, each a 32-bit word, set to 12 and 21 respectively; id as a polymorphic identity function with a size parameter n, constrained so n is finite, that takes a sequence of n bits and returns the same sequence unchanged. Include type signatures for all items and concrete values exactly as specified. Do not add extra declarations."},{"role":"assistant","content":"```cryptol\nmodule Types where\n\nb : Bit\nb = True\n\nw : [16]\nw = 42\n\nz : Integer\nz = 420000\n\nm : Z 12\nm = 6\n\nq : Rational\nq = ratio 5 4\n\nt : (Bit, Integer)\nt = (False, 7)\n\ns : [3][3][8]\ns = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nr : {xCoord : [32], yCoord : [32]}\nr = {xCoord = 12 : [32], yCoord = 21 : [32]}\n\nid : {n} (fin n) => [n] -> [n]\nid a = a\n```"}]}
{"filename":"cryptol-specs\/Common\/ntt.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Common::ntt that contains the following definitions: (1) a prime modulus constant set to 8380417, a field type as integers modulo that modulus, and a vector length constant set to 256; (2) a field element generator equal to 1753; (3) a function, parameterized by a finite size, that returns the first n successive powers of a given field element starting at 1; (4) a function, parameterized by a finite size, that returns the first n odd powers of a given element starting at exponent 1; (5) a naive forward NTT that maps a coefficient vector to evaluations at the first n odd powers of the root; (6) a polynomial evaluation function using Horner\u2019s method over the field with coefficients processed in reverse; (7) field constants equal to the multiplicative inverses of the length and the root; (8) a naive inverse NTT that scales by the inverse length and computes inner products of the reversed input with odd powers of the inverse root, enumerated via the powers of the root; (9) define a property that the naive inverse applied to the naive forward returns the original length-256 vector; (10) a function producing the length-256 standard basis vector at a given index less than the length; (11) infinite streams that enumerate even powers of the root and of its inverse via repeated multiplication; (12) a radix-2 decimation-in-time NTT that invokes a recursive helper at depth zero with exponent equal to the base-2 logarithm of the length; (13) a recursive helper that for size 2^n splits by a shuffle into even and odd halves, recurses on both with increased depth, and combines them with a butterfly using a stride determined by depth and twiddle factors from the roots stream; include finiteness and positivity constraints on sizes; (14) a shuffle that splits a length-2n vector into even and odd positions; (15) a butterfly that merges two length-n vectors into a length-2n vector using twiddle factors; (16) corresponding inverse transforms and butterfly using the inverse roots and final scaling by the inverse length; (17) define a property that the inverse composed with the forward equals identity on length-256 vectors; (18) a forward variant that premultiplies by powers of the root and define a property equating it to the naive forward; (19) an inverse variant that postmultiplies by powers of the inverse root and define properties equating it to the naive inverse and asserting that composing the forward and inverse variants yields identity."},{"role":"assistant","content":"```cryptol\nmodule Common::ntt where\n\ntype q = 8380417\n\ntype Fld = Z q\n\ntype nn = 256\n\nr : Fld\nr = 1753\n\nall_powers : {n} (fin n) => Fld -> [n]Fld\nall_powers w = take`{n} (iterate ((*) w) 1)\n\nodd_powers : {n} (fin n) => Fld -> [n]Fld\nodd_powers w = take`{n} (iterate ((*) (w * w)) w)\n\nnaive_ntt : {n} (fin n) => [n]Fld -> [n]Fld\nnaive_ntt xs = map (polyeval xs) (odd_powers r)\n\npolyeval : {n} (fin n) => [n]Fld -> Fld -> Fld\npolyeval p x = foldl (\\y pi -> (x * y) + pi) 0 (reverse p)\n\nivn : Fld\nivn = recip (`nn : Fld)\n\nivr : Fld\nivr = recip r\n\nnaive_ivntt : {n} (fin n) => [n]Fld -> [n]Fld\nnaive_ivntt xs = map ((*) ivn) ys\n  where\n    ys = [ foldl (+) 0 (zipWith (*) (reverse xs) (odd_powers wi))\n         | wi <- all_powers r ]\n\nnaive_ntt_correct : [nn]Fld -> Bool\nproperty naive_ntt_correct a = naive_ivntt (naive_ntt a) == a\n\nunit : {n} (n < nn) => [nn]Fld\nunit =\n  [ if `n == i then 1 else 0 | i <- [0 .. <nn]]\n\nroots : [inf]Fld\nroots = iterate ((*) (r * r)) 1\n\nntt : [nn]Fld -> [nn]Fld\nntt a = ntt_r`{lg2 nn} 0 a\n\nntt_r : {n} (fin n) => Integer -> [2 ^^ n]Fld -> [2 ^^ n]Fld\nntt_r depth a\n  | n == 0 =>  a\n  | n > 0 => butterfly depth even odd\n    where\n      (lft, rht) = shuffle a\n      even = ntt_r`{n - 1} (depth + 1) lft\n      odd = ntt_r`{n - 1} (depth + 1) rht\n\nshuffle : {n, a} (fin n, n > 0) => [2 * n]a -> ([n]a, [n]a)\nshuffle a =\n  ([ a @ (i * 2) | i <- [0 .. <n]], [ a @ (i * 2 + 1) | i <- [0 .. <n]])\n\nbutterfly : {n} (fin n, n > 0) => Integer -> [n]Fld -> [n]Fld -> [2*n]Fld\nbutterfly depth even odd =\n  lft # rht\n  where\n    j = 2 ^^ depth\n    lft = [ even @ i + roots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n    rht = [ even @ i - roots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n\nivroots : [inf]Fld\nivroots = iterate ((*) (ivr * ivr)) 1\n\nivntt : [nn]Fld -> [nn]Fld\nivntt a =\n  map ((*) ivn) (ivntt_r`{lg2 nn} 0 a)\n\nivntt_r : {n} (fin n) => Integer -> [2 ^^ n]Fld -> [2 ^^ n]Fld\nivntt_r depth a\n  | n == 0 => a\n  | n > 0 => ivbutterfly depth even odd\n    where\n      (lft, rht) = shuffle a\n      even = ivntt_r`{n - 1} (depth + 1) lft\n      odd = ivntt_r`{n - 1} (depth + 1) rht\n\nivbutterfly : {n} (fin n, n > 0) => Integer -> [n]Fld -> [n]Fld -> [2 * n]Fld\nivbutterfly depth even odd =\n  lft # rht\n  where\n    j = 2 ^^ depth\n    lft = [ even @ i + ivroots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n    rht = [ even @ i - ivroots @ (i * j) * odd @ i | i <- [0 .. <n] ]\n\nntt_correct : [nn]Fld -> Bool\nproperty ntt_correct a = ivntt (ntt a) == a\n\nfntt : [nn]Fld -> [nn]Fld\nfntt xs = ntt (zipWith (*) xs (all_powers r))\n\nfntt_correct : [nn]Fld -> Bool\nproperty fntt_correct a = naive_ntt a == fntt a\n\nfivntt : [nn]Fld -> [nn]Fld\nfivntt xs = zipWith (*) (all_powers ivr) (ivntt xs)\n\nfivntt_correct : [nn]Fld -> Bool\nproperty fivntt_correct a = fivntt a == naive_ivntt a\n\nffivntt_correct : [nn]Fld -> Bool\nproperty ffivntt_correct a = fivntt (fntt a) == a\n```"}]}
{"filename":"cryptol-specs\/Common\/LUP.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::LUP that contains the following definitions. Parameterize the module over a field-like type Fld with an equality constraint and provide parameters for zero, one, addition, additive inverse, multiplication, and multiplicative inverse. Define a division function that multiplies by the inverse. Provide an index vector generator for sizes, and a function that maps an index-aware updater across a fixed-length sequence. Introduce type synonyms for fixed-length field vectors and square matrices. Implement inner product on vectors using the field operations; vector addition; scalar multiplication; a unit (basis) vector constructor; an identity matrix; matrix-matrix multiplication (using row-by-column inner products) and matrix-vector multiplication; and an element-swapping function that exchanges two positions when both indices are in range, leaving the sequence unchanged otherwise. Implement LUPDecompose to perform in-place LUP decomposition with partial pivoting, returning a boolean that indicates nonsingularity, the combined LU matrix, and a permutation vector. The helpers row, pivot, and elim must be private: pivot must search from the current row downward for a nonzero pivot in the current column and swap rows and permutation entries when found; row must call pivot and then elimination as appropriate; elim must compute multipliers and eliminate entries below the pivot while writing multipliers into the lower triangle. Implement LUPSolve to solve a linear system using the LU matrix and permutation: first permute the right-hand side, then do forward substitution in the unit-lower part, then backward substitution in the upper part. Implement LUPInvert to return the inverse by solving for each identity column when the matrix is nonsingular; otherwise return the input matrix with a false flag. Provide explicit type signatures with size parameters and fin constraints, ensuring all dimensions and widths are consistent and only the supplied field operations are used. Mark the helper functions as private within the module."},{"role":"assistant","content":"```cryptol\nmodule Common::LUP where\n\nparameter\n\n  type Fld : *\n\n  type constraint (Eq Fld)\n\n  fzero : Fld\n\n  fadd : Fld -> Fld -> Fld\n\n  fminus : Fld -> Fld\n\n  fone : Fld\n\n  fmul : Fld -> Fld -> Fld\n\n  finv : Fld -> Fld\n\nfdiv : Fld -> Fld -> Fld\nfdiv x y =\n  fmul x (finv y)\n\nnats : {n} (fin n) => [n][width n]\nnats = take`{n} [0 .. n]\n\nmap_at : {n, a} (fin n) => ([width n] -> a -> a) -> [n]a  -> [n]a\nmap_at f m = [ f i (m @ i) | i <- nats ]\n\ntype FldVec n = [n]Fld\n\ndot : {n} (fin n) => FldVec n -> FldVec n -> Fld\ndot x y =\n  str ! 0\n  where\n    str = [ fzero ] # [ fadd acc (fmul xi yi)\n                      | xi <- x\n                      | yi <- y\n                      | acc <- str ]\n\nvecAdd : {n} (fin n) => FldVec n -> FldVec n -> FldVec n\nvecAdd x y = [ fadd xi yi | xi <- x | yi <- y ]\n\nscalMul : {n} (fin n) => Fld -> FldVec n -> FldVec n\nscalMul c x = [ fmul c xi | xi <- x ]\n\ntype FldMat n = [n](FldVec n)\n\nidMat : {n} (fin n) => FldMat n\nidMat = [ unitVec i | i <- nats ]\n\nunitVec : {n} (fin n) => [width n] -> FldVec n\nunitVec i =\n  [ if i == j then fone else fzero | j <- nats ]\n\nmatMul : {n} (fin n) => FldMat n -> FldMat n -> FldMat n\nmatMul x y =\n  [ [ dot (x @ i) (transpose y @ j) | j <- nats ] | i <- nats]\n\nmatVec : {n} (fin n) => FldMat n -> FldVec n -> FldVec n\nmatVec x y =\n  [ dot (x @ i) y  | i <- nats]\n\nswap : {n, a} (fin n) => [width n] -> [width n] -> [n]a -> [n]a\nswap i j x =\n  [ x @ perm k | k <- nats ]\n  where\n    perm k =\n      if (i >= `n) || (j >= `n)\n      then k\n      else if k == i\n           then j\n           else if k == j\n                then i\n                else k\n\nLUPDecompose : {n} (fin n) => FldMat n -> (Bit, FldMat n, [n][width n])\nLUPDecompose a = str ! 0\n  where\n  perm = [ i | i <- nats ]\n  str = [(True, a, perm)] #\n        [ row i non_sing lu p\n        | (non_sing, lu, p) <- str\n        | i <- nats`{n=n}\n        ]\n\nprivate\n\n  row : {n} (fin n) => [width n] -> Bit -> FldMat n -> [n][width n] ->\n                       (Bit, FldMat n, [n][width n])\n  row i ns a p =\n    if ns\n    then if ns'\n         then (ns', elim i a', p')          else (ns', a', p')        \/\/ a is singular, pivoting failed\n         where\n           (ns', a', p') = pivot i a p\n    else (ns, a, p)             \n\n  pivot : {n} (fin n) => [width n] -> FldMat n -> [n][width n] ->\n                         (Bit, FldMat n, [n][width n])\n  pivot i a perm = str ! 0\n    where\n    str = [(False, a, perm)] #\n          [ f done lu p j | (done, lu, p) <- str | j <- nats`{n=n} ]\n    f done lu p j =\n      if j < i then (done, lu, p)\n       | j == i then (lu @ i @ i != fzero, lu, p)\n       | done then (done, lu, p)\n       | lu @ j @ i == fzero then (done, lu, p)\n      else (True, swap i j lu, swap i j p) \n\n  elim : {n} (fin n) => [width n] -> FldMat n -> FldMat n\n  elim i a = map_at f a\n    where\n      invA_i_i = finv (a @ i @ i)\n      f j v =\n        if i < j then\n          map_at g v\n          where\n            a_j_i = fmul (v @ i) invA_i_i\n            g k x =\n              if k < i then x\n               | k == i then a_j_i\n              else\n                fadd x (fminus (fmul a_j_i (a @ i @ k)))\n        else\n          v\n\nLUPSolve : {n} (fin n) => FldMat n -> [n][width n] ->\n                          FldVec n -> FldVec n\nLUPSolve lu p b =\n  bb\n  where\n        pb = map_at pf b\n    pf i x = b @ (p @ i)\n        fb = [ ff i x | x <- pb | i <- nats`{n=n} ]\n    ff i x = str ! 0\n      where\n        str = [ x ] # [ h j y | y <- str | j <- nats`{n=n} ]\n        h j y =\n          if j < i\n          then fadd y (fminus (fmul (lu @ i @ j) (fb @ j)))\n          else y\n        bb = [ bf i x | x <- fb | i <- nats`{n=n} ]\n    bf i x = fdiv (str ! 0) (lu @ i @ i)\n      where\n        str = [ x ] # [ h j y | y <- str | j <- nats`{n=n} ]\n        h j y =\n          if i < j\n          then fadd y (fminus (fmul (lu @ i @ j) (bb @ j)))\n          else y\n\nLUPInvert : {n} (fin n) => FldMat n -> (Bit, FldMat n)\nLUPInvert a =\n  if ns then\n    (True, transpose [ LUPSolve lu p (unitVec i) | i <- nats ])\n  else\n    (False, a)\n  where\n    (ns, lu, p) = LUPDecompose a\n```"}]}
{"filename":"cryptol-specs\/Common\/ByteArray.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::ByteArray that contains: (1) an import of the library that provides a parametric array type constructor, and (2) a type synonym named ByteArray that denotes a fixed-length array of 64 elements where each element is an 8-bit value. Ensure the alias uses the imported array type constructor (not a built-in sequence), fixes the outer length to 64, and fixes each element\u2019s width to 8 bits. Do not add any functions, constants, or properties beyond this alias and the necessary import. Include the correct module header and keep the definition self-contained."},{"role":"assistant","content":"```cryptol\nmodule Common::ByteArray where\n\nimport Array\n\ntype ByteArray = Array[64][8]\n```"}]}
{"filename":"cryptol-specs\/Common\/pick.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::pick that contains the following definitions with precise polymorphic types and constraints: nats (for a finite size n) produces a length-n sequence of natural numbers encoded in words wide enough to index 0..n\u22121; pickItem consumes the first element of an infinite stream and returns the remainder stream paired with that element; pickSeq, for finite n > 0, repeatedly applies a state-threading picker function exactly n times to an infinite stream, returning the final stream and a length-n sequence of results; pickVec specializes pickSeq using the single-element picker; pickMat specializes pickSeq using pickVec to build an n\u00d7m matrix (n,m finite, >0); pickTri, for finite n > 0, builds an n\u00d7n upper-triangular matrix using a provided picker and a nil fill value, taking elements only on and above the main diagonal while leaving entries below the diagonal as the nil value, and returning the final stream; and a private helper pickTriRow that constructs one row given a row index, inserting the nil value for columns strictly below that row\u2019s diagonal and otherwise consuming from the stream. Also define the following properties: (1) pickItem returns the head element as the second component and the tail as the first; (2) nats has length n and its i-th element equals i encoded at the specified bit width; (3) pickVec is extensionally equal to pickSeq applied with the single-element picker; (4) pickMat is extensionally equal to pickSeq applied with pickVec; (5) pickSeq applies its picker exactly n times, threads the intermediate stream states in order, and the final stream equals the state after the nth application; (6) with the single-element picker, pickTri produces an upper-triangular matrix with nil below the diagonal, consumes exactly n(n+1)\/2 elements from the stream, and returns the stream advanced by that amount; (7) pickTriRow for row j yields nil for columns less than j and consumes exactly n\u2212j elements from the stream."},{"role":"assistant","content":"```cryptol\nmodule Common::pick where\n\nnats : {n} (fin n) => [n][width n]\nnats = take`{n} [0 .. n]\n\npickItem : {a} [inf]a -> ([inf]a, a)\npickItem g = (tail g, head g)\n\npickSeq : {n, a, b} (fin n, n > 0) =>\n          ([inf]a -> ([inf]a, b)) -> [inf]a -> ([inf]a, [n]b)\npickSeq f vals =\n  (str, map snd vec)\n  where\n    vec = [f vals] # [f g | (g, _) <- vec | i <- nats`{n=n-1}]\n    snd (_, x) = x\n    (str, _) = vec ! 0            \n\npickVec : {n, a} (fin n, n > 0) => [inf]a -> ([inf]a, [n]a)\npickVec = pickSeq pickItem\n\npickMat : {n, m, a} (fin n, n > 0, fin m, m > 0) =>\n          [inf]a -> ([inf]a, [n][m]a)\npickMat = pickSeq pickVec\n\npickTri : {n, a} (fin n, n > 0) =>\n          ([inf]a -> ([inf]a, a)) -> a -> [inf]a -> ([inf]a, [n][n]a)\npickTri pick nil s =\n  (str, map snd vec)\n  where\n    vec = [pickSeq pick s] # [pickTriRow pick nil g i\n                             | (g, _) <- vec\n                             | i <- nats`{n=n-1}\n                             ]\n    snd (_, x) = x\n    (str, _) = vec ! 0          \nprivate\n\n  pickTriRow : {n, a} (fin n, n > 0) => ([inf]a -> ([inf]a, a)) ->\n               a -> [inf]a -> [width (n - 1)] -> ([inf]a, [n]a)\n  pickTriRow pick nil s j =\n    (str, map snd vec)\n    where\n      vec = [pick s] # [f g i\n                       | (g, _) <- vec\n                       | i <- nats`{n=n-1}\n                       ]\n      f g i =\n        if i < j\n        then (g, nil)\n        else pick g\n      snd (_, x) = x\n      (str, _) = vec ! 0\n```"}]}
{"filename":"cryptol-specs\/Common\/Field.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::Field that imports Common::Morphism and Common::Set, and declares a type alias FieldRep parameterized by a type variable fv. The alias must be a record with these fields and types: is_val: a Set over fv denoting valid elements; normalize: fv -> fv returning a canonical representative; add, sub, mul, div: (fv, fv) -> fv for field addition, subtraction, multiplication, and division; neg, sq, half: fv -> fv for additive inverse, squaring, and halving; field_zero and field_unit: constants of type fv giving the additive and multiplicative identities; is_equal: (fv, fv) -> Bit as an equality predicate. Provide explicit Cryptol type annotations for every field, ensure the record is fully specified with these names and types, and export the type alias from the module. Do not implement any algorithms; only define the module, imports, and the type alias signature."},{"role":"assistant","content":"```cryptol\nmodule Common::Field where\n\nimport Common::Morphism\nimport Common::Set\n\ntype FieldRep fv =\n  { is_val : Set fv           , normalize : fv -> fv\n  , add : (fv,fv) -> fv\n  , sub : (fv,fv) -> fv\n  , neg : fv -> fv\n  , mul : (fv,fv) -> fv\n  , sq : fv -> fv\n  , half : fv -> fv\n  , div : (fv,fv) -> fv\n\n  , field_zero : fv\n\n  , field_unit : fv\n\n  , is_equal : (fv, fv) -> Bit\n  }\n```"}]}
{"filename":"cryptol-specs\/Common\/mod_arith.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::mod_arith that contains the following definitions: mod_add, mod_sub, mod_neg, mod_half, mod_mul, mod_div, and mod_pow. Import Common::bv to use helpers for addition with carry and subtraction with borrow, and safe-width arithmetic. Use unsigned fixed-width words throughout. Specify polymorphic size parameters (n or a) with the constraint that sizes are finite; additionally require the size to be at least 1 where right-shifts or iteration over bits are needed. Describe each function precisely: mod_add takes (p,x,y) as n-bit words and returns (x + y) reduced modulo p using word-size addition, capturing carry, followed by a conditional subtraction of p. mod_sub takes (p,x,y) and returns (x \u2212 y) reduced modulo p using subtraction with borrow and a conditional addition of p. mod_neg takes (p,x) and returns 0 if x is zero, otherwise p \u2212 x. mod_half takes (p,x) and returns x\/2 modulo p: if x is even, right-shift by one; if x is odd, add p and then halve, preserving width. mod_mul takes (p,x,y) and returns (x \u00d7 y) reduced modulo p using width-safe multiplication and modular reduction. mod_div takes (p,x,y) and returns x multiplied by the modular inverse of y modulo p, implemented via a binary extended GCD that halves even terms and updates residues modulo p; state preconditions p > 0, p is odd, and gcd(y,p) = 1; implement the EGCD as a local helper. mod_pow takes (p,x,e) and returns x raised to exponent e modulo p via square-and-multiply, scanning exponent bits from least to most significant for exactly the bit-width of the size parameter. Clearly state argument and result widths for each function, and ensure all intermediates are width-safe and results are reduced modulo p."},{"role":"assistant","content":"```cryptol\nmodule Common::mod_arith where\n\nimport Common::bv\n\nmod_add : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_add(p,x,y) = if c1 || ~c2 then r2 else r1\n  where\n    (r1,c1) = adc( x, y)\n    (r2,c2) = sbb(r1, p)\n\nmod_sub : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_sub(p,x,y) = if b then r2 else r1\n  where\n    (r1,b) = sbb( x, y)\n    (r2,_) = adc(r1, p)\n\nmod_neg : {n} (fin n) => ([n],[n]) -> [n]\nmod_neg(p,x) = if x == 0 then 0 else (p - x)\n\nmod_half : {n} (fin n, n >= 1) => ([n],[n]) -> [n]\nmod_half(p, x) = if even(x) then x >> 1\n                 else take(safe_add(x, p))\n  where even y = (y && 1) == 0\n\nmod_mul : {n} (fin n) => ([n],[n],[n]) -> [n]\nmod_mul(p,x,y) = safe_mod(p, safe_product(x, y))\n\nmod_div : {a} (fin a, a >= 1) => ([a],[a],[a]) -> [a]\nmod_div(p,x,y) = egcd(p,0,y,x)\n  where\n\n    egcd(a,ra,b,rb) =\n      if b == 0 then\n        ra\n      else if (b && 1) == 0 then \n        egcd(a, ra, b >> 1, mod_half(p, rb))\n      else if a < b then\n        egcd(a, ra, (b - a) >> 1, mod_half(p, mod_sub(p, rb, ra)))\n      else\n        egcd(b, rb, (a - b) >> 1, mod_half(p, mod_sub(p, ra, rb)))\n\nmod_pow : {a} (fin a, a >= 1) => ([a] , [a] , [a]) -> [a]\nmod_pow (p,x0,e0) = (results ! 0).2\n where\n results = [(x0,e0,1)] # [ (mod_mul (p,x,x), e>>1, if(e!0) then mod_mul(p,result,x) else result)\n                                | (x,e,result) <- results | _ <- [0..a] :[_][width a] ]\n```"}]}
{"filename":"cryptol-specs\/Common\/OptionUtils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Common::OptionUtils that contains the following definitions: isSome, isNone, optApply, optFold, optTest, optFlatten, and optFlatApply. Provide polymorphic type signatures: isSome: Option a -> Bit; isNone: Option a -> Bit; optApply: (a -> b) -> Option a -> Option b; optFold: b -> (a -> b) -> Option a -> b; optTest: (a -> Bit) -> Option a -> Bit; optFlatten: Option (Option a) -> Option a; optFlatApply: (a -> Option b) -> Option a -> Option b. Specify behavior in plain language: isSome yields true exactly when a value is present; isNone is the boolean negation of isSome; optApply maps a function over a present value and preserves absence; optFold returns the default when absent and applies the function to the value when present; optTest evaluates a predicate when present and otherwise returns false (expressible via optFold with default false); optFlatten removes one level of optional nesting, propagating absence; optFlatApply performs monadic bind for options and is equivalent to applying a function then flattening. Include properties (using Cryptol\u2019s property declarations) to verify: isNone equals the negation of isSome for all inputs; optTest equals optFold with default false; optFlatApply equals optFlatten after optApply; mapping with the identity function leaves an option unchanged; mapping with composed functions equals composing mappings; folding returns the default on absence and the mapped value on presence. Ensure all functions are total and impose no extra typeclass constraints."},{"role":"assistant","content":"```cryptol\nmodule Common::OptionUtils where\n\nisSome : {a} Option a -> Bit\nisSome opt = case opt of\n    Some _ -> True\n    None -> False\n\nisNone : {a} Option a -> Bit\nisNone opt = ~ isSome opt\n\noptApply : {a, b} (a -> b) -> Option a -> Option b\noptApply f opt = case opt of\n    Some x -> Some (f x)\n    None -> None\n\noptFold : {a, b} b -> (a -> b) -> Option a -> b\noptFold def f opt =\n  case opt of\n    Some x -> f x\n    None   -> def\n\noptTest : {a} (a -> Bit) -> Option a -> Bit\noptTest f opt = optFold False f opt\n\noptFlatten : {a} Option (Option a) -> Option a\noptFlatten opt = case opt of\n    Some opt' -> opt'\n    None -> None\n\noptFlatApply: {a, b} (a -> Option b) -> Option a -> Option b\noptFlatApply f opt = optFlatten (optApply f opt)\n```"}]}
{"filename":"cryptol-specs\/Common\/GF24.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Common::GF24 that contains the following definitions: (1) a type alias for field elements as 4-bit sequences representing GF(2^4); (2) a constant irreducible polynomial for GF(2^4) equal to the trinomial of degree 4 with nonzero terms at degrees 4, 1, and 0; (3) a function with signature {n} (fin n) => [n]GF24 -> GF24 that reduces a finite sequence of field elements using bitwise XOR starting from the additive identity; (4) a function GF24 -> GF24 -> GF24 that multiplies two elements by polynomial multiplication modulo the chosen irreducible polynomial; (5) a function GF24 -> GF24 -> GF24 that raises a base to an exponent encoded as a 4-bit vector using square-and-multiply over the exponent\u2019s bits, producing the resulting field element; (6) define a property that, for all field elements, adding an element to itself yields the additive identity; (7) a function GF24 -> GF24 that returns the multiplicative inverse by exponentiating to 2^4 \u2212 2; (8) define a property that, for all elements, applying the inverse operation twice returns the original element; (9) a function {n} (fin n) => [n]GF24 -> [n]GF24 -> GF24 that computes a dot product by summing elementwise products in the field; (10) a function {n, m} (fin n) => [n]GF24 -> [m][n]GF24 -> [m]GF24 that multiplies a vector by a matrix of matching inner dimension via dot products; (11) a function {n, m, k} (fin m) => [n][m]GF24 -> [m][k]GF24 -> [n][k]GF24 that performs matrix multiplication over GF(2^4), e.g., by dotting each row of the left with each column of the right via a transpose. Use the specified names and types."},{"role":"assistant","content":"```cryptol\nmodule Common::GF24 where\n\ntype GF24 = [4]\n\nirreducible = <| x^^4 + x + 1 |>\n\ngf24Add : {n} (fin n) => [n]GF24 -> GF24\ngf24Add ps = foldl (^) zero ps\n\ngf24Mult : GF24 -> GF24 -> GF24\ngf24Mult x y = pmod (pmult x y) irreducible\n\ngf24Pow : GF24 -> GF24 -> GF24\ngf24Pow n k = vals ! 0 where\n    sq x = gf24Mult x x\n    vals = [1] # [ if i then gf24Mult n (sq acc) else sq acc\n        | acc <- vals\n        | i   <- k]\n\npolySelfAdd' : GF24 -> Bit\nproperty polySelfAdd' x = x ^ x == zero\n\ngf24Inverse : GF24 -> GF24\ngf24Inverse x = gf24Pow x 14\n\nproperty gf24InverseCorrect x = gf24Inverse (gf24Inverse x) == x\n\ngf24DotProduct : {n} (fin n) => [n]GF24 -> [n]GF24 -> GF24\ngf24DotProduct xs ys = gf24Add [ gf24Mult x y | x <- xs | y <- ys ]\n\ngf24VectorMult : {n, m} (fin n) => [n]GF24 -> [m][n]GF24 -> [m]GF24\ngf24VectorMult v ms = [ gf24DotProduct v m | m <- ms ]\n\ngf24MatrixMult : {n, m, k} (fin m) => [n][m]GF24 -> [m][k]GF24 -> [n][k]GF24\ngf24MatrixMult xss yss = [ gf24VectorMult xs yss' | xs <- xss ]\n    where\n        yss' = transpose yss\n```"}]}
{"filename":"cryptol-specs\/Common\/bv.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::bv that contains the following definitions: safe_add, safe_sub, is_normal, safe_product, safe_mod, adc, and sbb. Provide explicit polymorphic type signatures with size parameters and fin constraints. Specify behaviors: safe_add returns an (n+1)-bit sum of two n-bit values computed by adding their zero-extended forms; safe_sub returns an (n+1)-bit difference of two n-bit values using zero-extension; is_normal returns a single bit indicating whether the second argument is strictly less than the first; safe_product returns a 2a-bit product of two a-bit values using zero-extension before multiplication; safe_mod takes a b-bit modulus and an (a+b)-bit value, computes the remainder modulo the zero-extended modulus, and returns the low b bits; adc returns an n-bit sum along with the carry-out bit obtained from the most significant bit of the (n+1)-bit sum; sbb returns an n-bit difference along with the borrow bit obtained from the most significant bit of the (n+1)-bit subtraction of zero-extended operands. Also define properties that: (1) for all sizes and inputs, the first component of adc equals the low n bits of the (n+1)-bit sum and its carry bit equals that sum\u2019s most significant bit; (2) sbb\u2019s n-bit result equals the low n bits of the (n+1)-bit zero-extended subtraction and its borrow bit equals that subtraction\u2019s most significant bit; (3) safe_add and safe_sub match addition and subtraction on zero-extended inputs, and their low n bits equal the respective modular results; (4) safe_product equals the product of zero-extended inputs and partitions into low\/high a-bit halves; (5) safe_mod equals the low b bits of the remainder of the (a+b)-bit input modulo the zero-extended modulus, and if the modulus is nonzero the result is strictly less than the modulus; (6) is_normal is true exactly when the second argument is less than the first."},{"role":"assistant","content":"```cryptol\nmodule Common::bv where\n\nsafe_add : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_add(x,y) = zext(x) + zext(y)\n\nsafe_sub : {n} (fin n) => ([n],[n]) -> [n+1]\nsafe_sub(x,y) = zext(x) - zext(y)\n\nis_normal : {a} (fin a) => [a] -> [a] -> Bit\nis_normal p x = (x < p)\n\nsafe_product : {a} (fin a) => ([a],[a]) -> [2*a]\nsafe_product(x,y) = zext(x) * zext(y)\n\nsafe_mod : {a, b} (fin a, fin b) => ([b],[a+b]) -> [b]\nsafe_mod(p,x) = drop `{a} (x % zext(p))\n\nadc : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nadc(x,y) = (drop(sm), sm@0)\n  where sm = safe_add(x,y)\n\nsbb : {n} (fin n) => ([n],[n]) -> ([n],Bit)\nsbb(x,y) = (drop(r), r@0)\n  where r = ([False] # x) - ([False] # y)\n```"}]}
{"filename":"cryptol-specs\/Common\/utils.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Common::utils that contains the following definitions: (1) A polymorphic loop while over a state type that takes a predicate from state to Bit, a state transformer, and an initial state, repeatedly applying the transformer while the predicate holds; include a total recursive definition. (2) A do-while loop dowhile that applies the transformer once, then continues with while using the updated state. (3) Converters between modular integers, bitvectors, and Integers with precise type constraints: ZtoBV: Z p -> [a] with p finite and >= 1 and a finite; BVtoZ: [a] -> Z p with p finite and >= 1 and a finite; ZtoZ: Z p -> Z q with p,q finite and >= 1; integerToBV: Integer -> [m] with m finite; integerFromBV: [m] -> Integer; integerModulusFromBV: [m] -> Integer that returns at least 3 (use 3 when the value is less than 3, otherwise the value). (4) isEven: Integer -> Bit using the least significant bit; abs: Integer -> Integer returning absolute value. (5) unzip that transforms a sequence of pairs into a pair of sequences using projections. (6) mul2, mul3, mul4, mul8 as generic numeric helpers defined via repeated addition and doubling. (7) A type-level constraint synonym isOdd that holds when a natural is odd. (8) half: Z p -> Z p implementing modular halving for odd moduli with constraints p finite, p >= 3, and isOdd p; compute half so that it matches division by two modulo p. (9) Define a property that, under the same constraints, verifies that doubling the result of half yields the original value. (10) compose: (a -> a) -> (a -> a) -> a -> a; and composeMany: [nf](a -> a) -> a -> a that composes zero functions as identity, one function as-is, two by composition, and more by recursive composition; constrain nf as a size parameter."},{"role":"assistant","content":"```cryptol\nmodule Common::utils where\n\nwhile : {a} (a -> Bit) -> (a -> a) -> a -> a\nwhile condition body initial_state =\n  if(condition initial_state) then while condition body (body initial_state)\n  else initial_state\n\ndowhile : {a} (a -> Bit) -> (a -> a) -> a -> a\ndowhile condition body initial_state =\n  if(condition next_state) then while condition body next_state else next_state\n  where next_state = body initial_state\n\nZtoBV : {p, a} (fin p, p >= 1, fin a) => Z p -> [a]\nZtoBV x = (fromInteger (fromZ x))\n\nBVtoZ : {p, a} (fin p, p >= 1, fin a) => [a] -> Z p\nBVtoZ x = (fromInteger (toInteger x))\n\nZtoZ : {p, q} (fin p, fin q, p >= 1, q >= 1) => Z p -> Z q\nZtoZ x = (fromInteger (fromZ x))\n\nintegerToBV : {m} (fin m) => Integer -> [m]\nintegerToBV x = fromInteger x\n\nintegerFromBV : {m} (fin m) => [m] -> Integer\nintegerFromBV x = toInteger x\n\nintegerModulusFromBV : {m} (fin m) => [m] -> Integer\nintegerModulusFromBV x = if (integerFromBV x) < 3 then 3 else (integerFromBV x)\n\nisEven : Integer -> Bit\nisEven x = ~((fromInteger x) : [1]) ! 0\n\nabs : Integer -> Integer\nabs x = if x >= zero then x else zero-x\n\nunzip : {a,f,s} [a](f,s) -> ([a]f,[a]s)\nunzip tuples = (map (\\x -> x.0) tuples , map (\\x -> x.1) tuples)\n\nmul2 x = x + x\n\nmul3 x = x + mul2 x\n\nmul4 x = mul2(mul2 x)\n\nmul8 x = mul2(mul4 x)\n\ntype constraint isOdd a = (a \/ 2) * 2 == a - 1\n\nhalf : {p} (fin p, p >= 3, isOdd p) => Z p -> Z p\nhalf x = fromInteger (if isEven xint then xint\/2 else ((xint + `p) \/ 2))\n  where\n    xint = fromZ x\n\nhalf_correct : {p} (fin p, p >= 3, isOdd p) => Z p -> Bit\nproperty half_correct x = half x + half x == x\n\ncompose : {a} () => (a -> a) -> (a -> a) -> a -> a\ncompose f g = \\x -> g (f x)\n\ncomposeMany : {nf, a} () => [nf](a -> a) -> a -> a\ncomposeMany fcns\n    | nf == 0 => \\x -> x\n    | nf == 1 => fcns@0\n    | nf == 2 => compose (fcns@0) (fcns@1)\n    | nf > 2  => compose (fcns@0) (composeMany (drop `{1} fcns))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/KDF\/HKDF256.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::KDF::HKDF256 that re-exports the public interface of Primitive::Symmetric::KDF::HKDF and, within its body, imports the SHA-256 HMAC instantiation under an alias. Inside the module, include: (1) a type synonym for the hash output length set to 32 bytes; (2) a constant that aliases the byte-oriented HMAC function; and (3) a function that computes HMAC over byte arrays using SHA-256. The HMAC function must be polymorphic over key length n and message length m, accept a key of n bytes and a message of m bytes, and return a 32-byte digest. Provide a precise type signature with size parameters n and m, finite-size constraints for both, and width constraints sufficient to ensure operations fit within the SHA-256 block size (64 bytes) and digest size (32 bytes) when performing indexing\/length arithmetic. Implement the function by delegating to the imported SHA-256 HMAC routine. All sequences should be 8-bit words, and the constant should reference the defined HMAC function."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::KDF::HKDF256 = Primitive::Symmetric::KDF::HKDF where\nimport Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA256 as HMAC_SHA256\n\ntype HashLen = 32\nHMAC = hmacBytes\n\nhmacBytes : {n, m} (64 >= width (8 * (64 + m)),\n                    64 >= width (8 * n), 32 >= width m, fin m, fin n) =>\n            [n][8] -> [m][8] -> [32][8]\nhmacBytes key msg = HMAC_SHA256::hmac key msg\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/AES_GCM_SIV.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Authenticated::AES_GCM_SIV that contains the following definitions and constraints: (1) Type parameters: a numeric KeySize with constraints that it is finite, divisible by 128, and either 128 or 256 bits; a type AAD with a constraint that its width is at most 44 bits. Define Mode = KeySize\/128 \u2212 1 and K = 128 + 128*Mode. Import the AES specification module, parameterized so its key size matches KeySize, and define KS as its key schedule type. (2) A function that implements AES-GCM-SIV authenticated encryption: it takes a record with fields key:[K], nonce:[96], aad:[AAD], msg:[n], for any n whose width is at most 44 bits, and returns the ciphertext of length n concatenated with a 128\u2011bit tag. It must use byte-wise reversal on inputs\/outputs where specified to match test vectors. (3) Helper functions: an AES block encryptor from a KS and a 128\u2011bit block that applies AES::cipher with byte-wise reversal; a key expansion from [K] to KS using AES::keyExpansion with byte-wise reversal; a key derivation that takes [K] and a 96\u2011bit nonce and returns a 128\u2011bit POLYVAL hash key and an expanded KS, constructed by encrypting nonce||counter blocks and assembling 64\u2011bit parts. (4) The core GCM\u2011SIV routine that, given (hash key, KS), nonce, AAD, and message blocks, computes T via POLYVAL over blockified AAD||message||lengths, derives the tag by encrypting a nonce\u2011mixed value, and produces ciphertext via counter mode seeded by the tag. (5) Counter mode over 128\u2011bit blocks with a 96\u2011bit upper and 32\u2011bit lower counter. (6) POLYVAL over GF(2^128) with dot and mult operations, using the specified irreducible polynomials. (7) Blockify\/unblockify with zero padding and byte-wise reversal, and a generic byte-wise reversal function. Include appropriate fin\/width constraints for all polymorphic sizes."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::AES_GCM_SIV where\n\nparameter\n      type KeySize : #\n  type constraint (fin KeySize, KeySize % 128 == 0, KeySize \/ 128 >= 1, KeySize \/ 128 <= 2)\n\n  type AAD : #\n  type constraint ( (36 + 8) >= width AAD )\n\ntype Mode = KeySize \/ 128 - 1\ntype K  = 128 + 128 * Mode\nimport Primitive::Symmetric::Cipher::Block::AES::Specification as AES where\n  type KeySize' = KeySize\ntype KS = AES::KeySchedule\n\n\/** Note the weird byte-swapping business (also in `blockify` and `unblockify`)\n * It is not quite clear in what format we want the inputs\/outputs, but we\n * do the swapping so that inputs\/ouputs match the test vectors at\n * https:\/\/tools.ietf.org\/html\/draft-irtf-cfrg-gcmsiv-06\n *\/\naes_gcm_siv :\n  {n} ((36 + 8) >= width n) =>\n      { key   : [K]\n      , nonce : [96]\n      , aad   : [AAD]\n      , msg   : [n]\n      } -> [n + 128]\naes_gcm_siv input = c # byteSwap t\n  where\n  (c,t) = gcm_siv_plus (derive_key k' n') n' input.aad input.msg\n  k'    = byteSwap input.key\n  n'    = byteSwap input.nonce\n\naes : KS -> [128] -> [128]\naes ks v = byteSwap (AES::cipher ks (byteSwap v))\n\nexpandKey : [K] -> KS\nexpandKey k = AES::keyExpansion (byteSwap k)\n\nderive_key : [K] -> [96] -> ([128], KS)\nderive_key K N = (mkKey parts1, expandKey (mkKey parts2))\n  where\n  parts1 # parts2 = [ drop (aes (expandKey K) (N # i)) | i <- take [ 0 ... ]  ]\n\n  mkKey : {n} (fin n) => [n][64] -> [64 * n]\n  mkKey xs = join (reverse xs)\n\ngcm_siv_plus :\n  {n} (64 >= width n) => ([128], KS) -> [96] -> [AAD] -> [n] -> ([n],[128])\ngcm_siv_plus (K1,K2) N AAD MSG = (unblockify Cs,TAG)\n  where\n\n  TAG     = aes K2 (0b0 # drop (T ^ (0 # N)))\n  T       = polyvalFrom K1 (A # M # [msg_len # aad_len]) 0\n  A       = blockify AAD\n  M       = blockify MSG\n  aad_len = `AAD: [64]\n  msg_len = `n   : [64]\n\n  _ # tUpper # tLower = TAG\n\n  Cs = counter_mode K2 (0b1 # tUpper, tLower) M\n\ncounter_mode : {n} KS -> ([96],[32]) -> [n][128] -> [n][128]\ncounter_mode K2 (tUpper,tLower) M =\n            [ aes K2 (tUpper # lower32 i) ^ m | m <- M | i <- [ 0 ... ] ]\n  where\n  lower32 i = tLower + i\n\npolyvalFrom : {n} (fin n) => [128] -> [n][128] -> [128] -> [128]\npolyvalFrom H Xs start = psums ! 0\n  where psums = [start] # [ dot (s ^ x) H | s <- psums | x <- Xs ]\n\ndot : [128] -> [128] -> [128]\ndot x y = mult x (mult y x_neg_128)\n  where x_neg_128 = <| 1 + x^^114 + x^^121 + x^^124 + x^^127 |>\n\nmult : [128] -> [128] -> [128]\nmult x y = pmod (pmult x y) irred\n  where\n  irred = <| 1 + x^^121 + x^^126 + x^^127 + x^^128 |>\n\nblockify : {n} (fin n) => [n] -> [n \/^ 128][128]\nblockify x = [ byteSwap b | b <- split (x # zero) ]\n\nunblockify : {n} (fin n) => [n \/^ 128][128] -> [n]\nunblockify xs = take (join [ byteSwap b | b <- xs ])\n\nbyteSwap : {n} (fin n) => [8 * n] -> [8 * n]\nbyteSwap xs = join (reverse (split`{each=8} xs))\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/MEE_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Authenticated::MEE_CBC that contains: (1) constants for block, tag, and signing key sizes (16, 32, and 64 bytes, respectively) and type synonyms: Blk and EKey as 16-byte words, Tag as 32-byte word, SKey as 64-byte word; (2) a CBC encryption function polymorphic in a finite block count n that takes a block cipher (key \u00d7 block \u2192 block), a key, an IV block, and n plaintext blocks, and returns n ciphertext blocks by XORing each plaintext with the previous ciphertext (or IV) before encryption; (3) a CBC decryption function with the dual behavior that decrypts each ciphertext block and XORs with the previous ciphertext (or IV) to recover plaintext; (4) a padding function polymorphic in n, p, b with constraints p = 16\u00b7b \u2212 n, 16\u00b7b \u2265 n, and p fits in one byte, that appends a 32-byte tag then p bytes each equal to the value p, then splits into (b+2) blocks of 16 bytes; (5) an unpadding function under the same size\/fit constraints that joins (b+2) blocks, returns the first n bytes as message, the next 32 bytes as tag, and a boolean indicating the padding equals p copies of the byte p; (6) a property named unpad_pad_good_1000_256 that, for n = 1000 and p = 104, asserts unpadding after padding yields the original message, the original tag, and a true padding check; (7) an authenticated encryption function that, under constraints fin n, b \u2265 1, 16\u00b7b \u2265 n, and p fits in one byte with p = 16\u00b7b \u2212 n, takes a block cipher, a signing function (SKey \u00d7 n-byte message \u2192 Tag), an encryption key, a signing key, an IV, and a message, computes the tag, pads message+tag, and applies CBC encryption; (8) a corresponding decryption function (using a decryption primitive) that CBC-decrypts, unpads, verifies padding, recomputes the tag over the recovered message, and returns the message and the conjunction of both checks; (9) a property named mee_enc_dec_good_1000 that, for n = 1000 and p = 104, asserts decrypt(encrypt(message)) returns the original message and a true validity flag."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::MEE_CBC where\n\ntype blkBytes = 16\ntype Blk = [blkBytes][8]\ntype EKey = [blkBytes][8]\n\ntype tagBytes = 32\ntype Tag = [tagBytes][8]\n\ntype skeyBytes = 64\ntype SKey = [skeyBytes][8]\n\ncbc_enc : {n} (fin n) => (EKey -> Blk -> Blk) -> EKey -> Blk -> [n]Blk -> [n]Blk\ncbc_enc enc k iv ps = cs\n where cs = [ enc k (p ^ c') | p <- ps | c' <- [iv] # cs ]\n\ncbc_dec : {n} (fin n) => (EKey -> Blk -> Blk) -> EKey -> Blk -> [n]Blk -> [n]Blk\ncbc_dec dec k iv cs = [ (dec k c) ^ c' | c <- cs | c' <- [iv] # cs ]\n\npad : {n, p, b}\n      (fin n, 8 >= width p, p == blkBytes*b - n, blkBytes*b >= n) =>\n      [n][8] -> Tag -> [b+2]Blk\npad msg tag = split `{each=blkBytes} (msg # tag # padding)\n  where\n    padding = (repeat `p) : [p][8]\n\nunpad : {n, p, b}\n        (fin n, 8 >= width p, p == blkBytes*b - n, blkBytes*b >= n) =>\n        [b+2]Blk -> ([n][8], Tag, Bit)\nunpad ct = (m, t, good)\n  where\n    padded = join ct\n    m = take `{n} padded\n    t = take `{tagBytes} (drop `{n} padded)\n    p = drop `{n + tagBytes} padded\n    good = p == ((repeat `p) : [p][8]) \n\nproperty unpad_pad_good_1000_256 msg tag =\n  unpad (pad `{n=1000,p=104} msg tag) == (msg, tag, True)\n\nmee_enc : {n, p, b}\n          (fin n, p == blkBytes*b - n, 8 >= width p, b >= 1, 16*b >= n) =>\n          (Blk -> Blk -> Blk)\n       -> (SKey -> [n][8] -> Tag)\n       -> EKey -> SKey -> Blk -> [n][8] -> [b+2]Blk\nmee_enc enc sign ekey skey iv msg =\n  cbc_enc enc ekey iv (pad msg (sign skey msg))\n\nmee_dec : {n, p, b}\n          (fin n, p == blkBytes*b - n, 8 >= width (32 + p), b >= 1, 16*b >= n)\n       => (EKey -> Blk -> Blk)\n       -> (SKey -> [n][8] -> Tag)\n       -> EKey -> SKey -> Blk -> [b+2]Blk -> ([n][8], Bit)\nmee_dec dec sign ekey skey iv ct = (m, good \/\\ sign skey m == t)\n  where\n    (m, t, good) = unpad (cbc_dec dec ekey iv ct)\n\nproperty mee_enc_dec_good_1000 enc dec sign ekey skey iv msg =\n  mee_dec `{n=1000,p=104} dec sign ekey skey iv ct == (msg, True)\n    where ct = mee_enc `{n=1000,p=104} enc sign ekey skey iv msg\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/trivium.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Stream::trivium that contains the following definitions: (1) A type alias N set to 300. (2) A function Trivium_stream that takes three bit vectors of lengths 93, 84, and 111 and produces an infinite keystream, obtained from a helper that iteratively shifts three NLFSRs. (3) A polymorphic helper shift with constraints fin d and d >= 1 that, given a d-bit vector and a bit, returns the same-length vector shifted by one position, inserting the supplied bit at the most significant end and discarding the least significant bit. (4) A polymorphic helper shift_regs with constraints fin d, fin e, fin f and each length >= 1 that, given three initial registers, returns a tuple of four infinite sequences: the keystream bits and the evolving states of each register. Within it, define s1, s2, s3 as XORs of fixed taps from each register; define feedback bits t1, t2, t3 as XORs of taps within a register combined with an AND of two taps and one cross-register tap; define the keystream as s1 XOR s2 XOR s3; define each register stream by repeatedly applying shift with its corresponding feedback bit, seeded by the initial state. Tap positions must match the Trivium design: for the first register use 65, 90, 91, 92; for the second 68, 81, 82, 83, 77; for the third 65, 108, 109, 110, 86. (5) A function Trivium that takes a triple of the three registers and returns the first N keystream bits. (6) An alternative implementation Trivium_alt that derives the same keystream via sliced views over reversed-and-extended register streams with matching taps, and returns the first N bits. (7) Constants iv1, iv2, iv3 sized to the three registers, and a 300-bit constant test_keystream. (8) Properties: Trivium_correct (test IV matches expected keystream), Trivium_search (unknown IV triple matches expected keystream), Trivium_alt_correct (alt with test IV matches expected), and Trivium_alt_equivalent (first 200 bits of both implementations match for any inputs). (9) A function cycle with constraint fin n that returns true iff a given triple equals the nth register states produced by shift_regs and none of the registers are all-zero."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::trivium where\n\nTrivium_stream : [93] -> [84] -> [111] -> [inf]\nTrivium_stream R1 R2 R3 = stream\n\twhere\n\t(stream, ra, rb, rc) = shift_regs R1 R2 R3\n\ntype N = 300\nTrivium : ([93], [84], [111]) -> [N]Bit\nTrivium (reg1, reg2, reg3) = keystream\n  where\n    keystream =  take`{N} (Trivium_stream reg1 reg2 reg3)\n\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n\t\tfills = [bit]#(drop`{1} (fill >> 1))\n\nshift_regs : {d,e,f} (fin d, fin e, fin f, d >=1, e >=1, f>=1) => [d] -> [e] -> [f] -> ([inf],[inf][d],[inf][e],[inf][f])\nshift_regs r1 r2 r3 = (stream, regA, regB, regC)\n\twhere\n\n\t\ts1 = [(f1 @ 65) ^ (f1 @ 92)  | f1 <- regA]\n\t\ts2 = [(f2 @ 68) ^ (f2 @ 83)  | f2 <- regB]\n\t\ts3 = [(f3 @ 65) ^ (f3 @ 110) | f3 <- regC]\n\n\t\tstream = s1 ^ s2 ^ s3\n\t\tt1 = [(f1 @ 65) ^ ((f1 @ 90) && (f1 @ 91)) ^ (f1 @ 92) ^ (f2 @ 77) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf1 <- regA ]\n\t\tt2 = [(f2 @ 68) ^ ((f2 @ 81) && (f2 @ 82)) ^ (f2 @ 83) ^ (f3 @ 86) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf3 <- regC ]\n\t\tt3 = [(f3 @ 65) ^ ((f3 @ 108) && (f3 @ 109)) ^ (f3 @ 110) ^ (f1 @ 68)|\n\t\t\t\tf1 <- regA |\n\t\t\t\tf3 <- regC ]\n\n\t\tregA = [r1] # [shift f b| f <- regA | b <- t3]\n\t\tregB = [r2] # [shift f b| f <- regB | b <- t1]\n\t\tregC = [r3] # [shift f b| f <- regC | b <- t2]\n\nTrivium_alt : ([93], [84], [111]) -> [N]Bit\nTrivium_alt (r1, r2, r3) = take`{N} (s1 ^ s2 ^ s3)\n  where\n    a_65 = drop`{27} a_92\n    a_68 = drop`{24} a_92\n    a_90 = drop`{2} a_92\n    a_91 = drop`{1} a_92\n    a_92 = reverse r1 # t3\n\n    b_68 = drop`{15} b_83\n    b_77 = drop`{6} b_83\n    b_81 = drop`{2} b_83\n    b_82 = drop`{1} b_83\n    b_83 = reverse r2 # t1\n\n    c_65 = drop`{45} c_110\n    c_86 = drop`{24} c_110\n    c_108 = drop`{2} c_110\n    c_109 = drop`{1} c_110\n    c_110 = reverse r3 # t2\n\n    s1 = a_65 ^ a_92\n    s2 = b_68 ^ b_83\n    s3 = c_65 ^ c_110\n\n    t1 = s1 ^ (a_90 && a_91) ^ b_77\n    t2 = s2 ^ (b_81 && b_82) ^ c_86\n    t3 = s3 ^ (c_108 && c_109) ^ a_68\n\niv1 = 0b111111111111111111101111111111111111111011111111111111111110111111111111111111101111111111111\niv2 = 0b000000000000000000001000000000000000000001000000000000000000001000000000000000000001\niv3 = 0b111111111111111110111111111111111111101111111111111111111011111111111111111110111111111111100000000000000000000\n\ntest_keystream = 0b011111110111101111110100001110000000000000100010000000000000000100011000101100001110001011011010101010000100101110001111100011000110000101001011001111011101110110111010011011010110001000111101101111101100101001000111010001010011111110011100100011101010011110101001001000011100001111111100000001110001\n\nproperty Trivium_correct = (Trivium(iv1, iv2, iv3)) == test_keystream\nproperty Trivium_search (x, y, z) = (Trivium(x, y, z)) == test_keystream\nproperty Trivium_alt_correct = (Trivium_alt(iv1, iv2, iv3)) == test_keystream\nproperty Trivium_alt_equivalent x = take`{200}(Trivium_alt x) == take (Trivium x)\n\ncycle : {n} (fin n) => [n] -> ([93], [84], [111]) -> Bit\ncycle n (rA, rB, rC) =\n  (rA == regAs @ n) \/\\ (rB == regBs @ n) \/\\ (rC == regCs @ n) \/\\ rA != 0 \/\\ rB != 0 \/\\ rC != 0\n    where\n      (_, regAs, regBs, regCs) = shift_regs rA rB rC\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/bivium.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Stream::bivium that contains the following definitions: (1) A type alias N set to the natural 200. (2) A function Bivium_stream with type [93] -> [84] -> [inf] that, given two initial registers, produces an infinite keystream computed by iteratively updating two nonlinear feedback shift registers and XORing two tap-derived output streams. (3) A helper function shift with polymorphic size d, constrained fin d and d >= 1, of type [d] -> Bit -> [d], that shifts right by one and inserts the provided bit at the most significant position. (4) A function shift_regs with polymorphic sizes d and e (fin d, fin e, d >= 1, e >= 1) of type [d] -> [e] -> ([inf], [inf][d], [inf][e]) that returns the infinite keystream and infinite sequences of register states; at each step compute output taps s1 from positions 65 and 92 of the first register sequence and s2 from positions 68 and 83 of the second; compute feedback bits t1 from positions 65, 90, 91, 92 of the first and 77 of the second; compute t2 from positions 68, 81, 82, 83 of the second and 68 of the first; update the first register with t2 and the second with t1; the keystream is s1 XOR s2. (5) A function Bivium of type ([93], [84]) -> [N]Bit that returns the first N bits of Bivium_stream. (6) A function Bivium_alt of the same type that computes the same keystream using equivalent vector drops\/reversals and the same taps\/feedbacks. (7) Constants iv1, iv2, test_keystream, and suffix with the same bitvector values and sizes as in the implementation. (8) A property that Bivium(iv1, iv2) equals test_keystream. (9) A property that for unconstrained [93] and [84] seeds, Bivium returns test_keystream. (10) A property that for an unconstrained [93] seed and a [84] seed formed by appending suffix, Bivium returns test_keystream. (11) A property that Bivium_alt is equivalent to Bivium for all inputs. (12) A function cycle with type {n} (fin n) => [n] -> [93] -> [84] -> Bit that holds when, after n steps of shift_regs, both registers return to the given nonzero states. (13) Helper predicates cycle0, cycle1, cycle2, cycle3, cycle4, cycle5, and cycle10 that specialize cycle at those concrete n values."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::bivium where\n\nBivium_stream : [93] -> [84] -> [inf]\nBivium_stream R1 R2 = stream\n\twhere\n\t(stream, ra, rb) = shift_regs R1 R2\n\ntype N = 200\nBivium : ([93], [84]) -> [N]Bit\nBivium (reg1, reg2) = keystream\n  where\n    keystream =  take`{N} (Bivium_stream reg1 reg2)\n\nshift : {d} (fin d, d >=1) => [d] -> Bit -> [d]\nshift fill bit = fills\n\twhere\n\t\tfills = [bit]#(drop`{1} (fill >> 1))\n\nshift_regs : {d,e} (fin d, fin e, d >=1, e >=1) => [d] -> [e] -> ([inf],[inf][d],[inf][e])\nshift_regs r1 r2 = (stream, regA, regB)\n\twhere\n\t\ts1 = [(f1 @ 65) ^ (f1 @ 92) | f1 <- regA]\n\t\ts2 = [(f2 @ 68) ^ (f2 @ 83) | f2 <- regB]\n\n\t\tstream = s1 ^ s2\n\t\tt1 = [(f1 @ 65) ^ ((f1 @ 90) && (f1 @ 91)) ^ (f1 @ 92) ^ (f2 @ 77) |\n\t\t\t\tf2 <- regB |\n\t\t\t\tf1 <- regA ]\n\t\tt2 = [(f2 @ 68) ^ ((f2 @ 81) && (f2 @ 82)) ^ (f2 @ 83) ^ (f1 @ 68) |\n\t\t\t\tf1 <- regA |\n\t\t\t\tf2 <- regB ]\n\n\t\tregA = [r1] # [shift f b| f <- regA | b <- t2]\n\t\tregB = [r2] # [shift f b| f <- regB | b <- t1]\n\nBivium_alt : ([93], [84]) -> [N]Bit\nBivium_alt (r1, r2) = take`{N} (s1 ^ s2)\n  where\n    a_65 = drop`{27} a_92\n    a_68 = drop`{24} a_92\n    a_90 = drop`{2} a_92\n    a_91 = drop`{1} a_92\n    a_92 = reverse r1 # t2\n\n    b_68 = drop`{15} b_83\n    b_77 = drop`{6} b_83\n    b_81 = drop`{2} b_83\n    b_82 = drop`{1} b_83\n    b_83 = reverse r2 # t1\n\n    s1 = a_65 ^ a_92\n    s2 = b_68 ^ b_83\n\n    t1 = s1 ^ (a_90 && a_91) ^ b_77\n    t2 = s2 ^ (b_81 && b_82) ^ a_68\n\niv1 = 0b111110000000101010100100010001000000101010100001011111111111111100100100111111111011111111111\niv2 = 0b000000000000000000001000000000000000000001000000000000000000001000000000000000000001\n\ntest_keystream = 0b01000010000100000101110001100011111101110101110111111110100001111111100110101001000010101100100010000100001100011100000010001001100101101001011101110100000001011010001101000011001000110011111010100110\n\nsuffix = 0b000000001000000000000000000001\nproperty Bivium_correct = (Bivium(iv1, iv2)) == test_keystream\nproperty Bivium_search (x, y) = (Bivium(x, y)) == test_keystream\nproperty Bivium_search_with_suffix (x, y) = (Bivium(x, y#suffix)) == test_keystream\nproperty Bivium_alt_equivalent r = Bivium_alt r == Bivium r\n\ncycle : {n} (fin n) => [n] -> [93] -> [84] -> Bit\ncycle n rA rB =\n  (rA == regAs @ n) \/\\ (rB == regBs @ n) \/\\ rA != 0 \/\\ rB != 0\n    where\n      (_, regAs, regBs) = shift_regs rA rB\n\ncycle0 rA rB = cycle (0 : [8]) rA rB\ncycle1 rA rB = cycle (1 : [8]) rA rB\ncycle2 rA rB = cycle (2 : [8]) rA rB\ncycle3 rA rB = cycle (3 : [8]) rA rB\ncycle4 rA rB = cycle (4 : [8]) rA rB\ncycle5 rA rB = cycle (5 : [8]) rA rB\ncycle10 rA rB = cycle (10 : [8]) rA rB\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/chacha20.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named module_name that contains the following definitions: list_definitions. Include: (1) type aliases for a 16\u00d732-bit word state, a 64-byte block, a 32-byte key, a 12-byte nonce, and a 32-bit counter; (2) a function that implements the quarter-round ARX step on four 32-bit words using addition modulo 2^32, XOR, and left-rotations by 16, 12, 8, and 7; (3) a function that performs one column round followed by one diagonal round over a 16-word state; (4) a key\/counter\/nonce expansion that builds the 16-word initial state from four fixed constant words, eight words from the key (packed little-endian from bytes), one counter word, and three words from the nonce (packed little-endian); (5) a core function that applies 20 rounds (ten of the double-round), adds the original state word-wise modulo 2^32, and outputs a 64-byte block by emitting each 32-bit word in little-endian; (6) a function that, given a non-negative integer, returns the state with the counter word incremented that many times; (7) a size-polymorphic stream generator with a fin constraint that produces the first n keystream bytes by iterating the core over successive counter values; (8) an encryption function that XORs an n-byte message with the keystream and returns n bytes; (9) private helpers for little-endian byte\/word packing, mapping, iteration, and row-joining as needed. Provide explicit Cryptol type signatures and necessary constraints for all definitions.\n\nAlso include a single property named property_name that is the conjunction of boolean checks validating: the canonical quarter-round example, the initial state expansion for a sample key\/counter\/nonce, a reference 64-byte block for that state, and three end-to-end encryption test vectors (including the all-zero case), all matching the standard specification. Do not include any solutions or concrete values; only specify the required behaviors and types."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::chacha20 where\n\ntype Round   = [16][32] type Block   = [64][8]  type Key     = [32][8]  type Nonce   = [12][8]  type Counter = [32]     \n\nqround : [4][32] -> [4][32]\nqround [ a0, b0, c0, d0 ] = [ a2, b4, c2, d4 ]\n  where\n    a1 = a0 + b0   \n    d1 = d0 ^ a1\n    d2 = d1 <<< 16\n\n    c1 = c0 + d2   \n    b1 = b0 ^ c1\n    b2 = b1 <<< 12\n\n    a2 = a1 + b2   \n    d3 = d2 ^ a2\n    d4 = d3 <<< 8\n\n    c2 = c1 + d4   \n    b3 = b2 ^ c2\n    b4 = b3 <<< 7\n\ncdround : Round -> Round\ncdround [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 ]\n      = [ z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15 ]\n  where\n        [ y0, y4, y8,  y12 ] = qround [ x0, x4, x8,  x12 ]\n    [ y1, y5, y9,  y13 ] = qround [ x1, x5, x9,  x13 ]\n    [ y2, y6, y10, y14 ] = qround [ x2, x6, x10, x14 ]\n    [ y3, y7, y11, y15 ] = qround [ x3, x7, x11, x15 ]\n\n        [ z0, z5, z10, z15 ] = qround [ y0, y5, y10, y15 ]\n    [ z1, z6, z11, z12 ] = qround [ y1, y6, y11, y12 ]\n    [ z2, z7, z8,  z13 ] = qround [ y2, y7, y8,  y13 ]\n    [ z3, z4, z9,  z14 ] = qround [ y3, y4, y9,  y14 ]\n\ncore : Round -> Block\ncore x = block\n  where\n    rounds = iterate cdround x        result = rounds @ 10              block  = blocked (x + result) \n\nkexp : Key -> Counter -> Nonce -> Round\nkexp k c n = [ c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15 ]\n  where\n\n        [ c0, c1, c2, c3 ] = [ 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574 ]\n\n        [ c4, c5, c6,  c7 ]  = map rjoin (groupBy`{4} kslice1 : [4][4][8]) : [4][32]\n    [ c8, c9, c10, c11 ] = map rjoin (groupBy`{4} kslice2 : [4][4][8]) : [4][32]\n    kslice1 = k @@ ([ 0  .. 15 ] : [16][32])     kslice2 = k @@ ([ 16 .. 31 ] : [16][32]) \n            [ c12 ] = [ c ]\n\n        [ c13, c14, c15 ] = map rjoin (groupBy`{4} n)\n\niround : [64] -> Round -> Round\niround n r = (iterate once r) @ n where\n    once [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12,    x13, x14, x15 ]\n     = [ x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12+1,  x13, x14, x15 ]\n\nstream : {n} (fin n) => Key -> Counter -> Nonce -> [n][8]\nstream k c n = take`{n} (join rounds)   where\n        key    = kexp k c n\n\n                    rounds = [ core (iround i key) | i <- [ 0, 1 ... ] ]\n\nencrypt : {n} (fin n) => Key -> Counter -> Nonce -> [n][8] -> [n][8]\nencrypt k c n m = m ^ (stream k c n)\n\nprivate\n  qround01 = qround in == out\n    where\n      in  = [ 0x11111111, 0x01020304, 0x9b8d6f43, 0x01234567 ]\n      out = [ 0xea2a92f4, 0xcb1cf8ce, 0x4581472e, 0x5881c4bb ]\n\n  core01 = kexp k 1 n == out\n    where\n      n = [ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x4a,\n            0x00, 0x00, 0x00, 0x00 ]\n      k = [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f ]\n      out = [ 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,\n              0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,\n              0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c,\n              0x00000001, 0x09000000, 0x4a000000, 0x00000000 ]\n\n  core02 = core (kexp k 1 n) == out\n    where\n      n = [ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x4a,\n            0x00, 0x00, 0x00, 0x00 ]\n      k = [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f ]\n      out = [ 0x10, 0xf1, 0xe7, 0xe4, 0xd1, 0x3b, 0x59, 0x15,\n              0x50, 0x0f, 0xdd, 0x1f, 0xa3, 0x20, 0x71, 0xc4,\n              0xc7, 0xd1, 0xf4, 0xc7, 0x33, 0xc0, 0x68, 0x03,\n              0x04, 0x22, 0xaa, 0x9a, 0xc3, 0xd4, 0x6c, 0x4e,\n              0xd2, 0x82, 0x64, 0x46, 0x07, 0x9f, 0xaa, 0x09,\n              0x14, 0xc2, 0xd7, 0x05, 0xd9, 0x8b, 0x02, 0xa2,\n              0xb5, 0x12, 0x9c, 0xd1, 0xde, 0x16, 0x4e, 0xb9,\n              0xcb, 0xd0, 0x83, 0xe8, 0xa2, 0x50, 0x3c, 0x4e ]\n\n  rfctest01 = encrypt zero zero zero zero\n       == [ 0x76, 0xb8, 0xe0, 0xad, 0xa0, 0xf1, 0x3d, 0x90, 0x40, 0x5d,\n            0x6a, 0xe5, 0x53, 0x86, 0xbd, 0x28, 0xbd, 0xd2, 0x19, 0xb8,\n            0xa0, 0x8d, 0xed, 0x1a, 0xa8, 0x36, 0xef, 0xcc, 0x8b, 0x77,\n            0x0d, 0xc7, 0xda, 0x41, 0x59, 0x7c, 0x51, 0x57, 0x48, 0x8d,\n            0x77, 0x24, 0xe0, 0x3f, 0xb8, 0xd8, 0x4a, 0x37, 0x6a, 0x43,\n            0xb8, 0xf4, 0x15, 0x18, 0xa1, 0x1c, 0xc3, 0x87, 0xb6, 0x69,\n            0xb2, 0xee, 0x65, 0x86 ]\n\n  rfctest02 = encrypt (zero # [1]) 1 (zero # [2]) msg == out\n    where\n      out = [ 0xa3, 0xfb, 0xf0, 0x7d, 0xf3, 0xfa, 0x2f, 0xde, 0x4f, 0x37,\n              0x6c, 0xa2, 0x3e, 0x82, 0x73, 0x70, 0x41, 0x60, 0x5d, 0x9f,\n              0x4f, 0x4f, 0x57, 0xbd, 0x8c, 0xff, 0x2c, 0x1d, 0x4b, 0x79,\n              0x55, 0xec, 0x2a, 0x97, 0x94, 0x8b, 0xd3, 0x72, 0x29, 0x15,\n              0xc8, 0xf3, 0xd3, 0x37, 0xf7, 0xd3, 0x70, 0x05, 0x0e, 0x9e,\n              0x96, 0xd6, 0x47, 0xb7, 0xc3, 0x9f, 0x56, 0xe0, 0x31, 0xca,\n              0x5e, 0xb6, 0x25, 0x0d, 0x40, 0x42, 0xe0, 0x27, 0x85, 0xec,\n              0xec, 0xfa, 0x4b, 0x4b, 0xb5, 0xe8, 0xea, 0xd0, 0x44, 0x0e,\n              0x20, 0xb6, 0xe8, 0xdb, 0x09, 0xd8, 0x81, 0xa7, 0xc6, 0x13,\n              0x2f, 0x42, 0x0e, 0x52, 0x79, 0x50, 0x42, 0xbd, 0xfa, 0x77,\n              0x73, 0xd8, 0xa9, 0x05, 0x14, 0x47, 0xb3, 0x29, 0x1c, 0xe1,\n              0x41, 0x1c, 0x68, 0x04, 0x65, 0x55, 0x2a, 0xa6, 0xc4, 0x05,\n              0xb7, 0x76, 0x4d, 0x5e, 0x87, 0xbe, 0xa8, 0x5a, 0xd0, 0x0f,\n              0x84, 0x49, 0xed, 0x8f, 0x72, 0xd0, 0xd6, 0x62, 0xab, 0x05,\n              0x26, 0x91, 0xca, 0x66, 0x42, 0x4b, 0xc8, 0x6d, 0x2d, 0xf8,\n              0x0e, 0xa4, 0x1f, 0x43, 0xab, 0xf9, 0x37, 0xd3, 0x25, 0x9d,\n              0xc4, 0xb2, 0xd0, 0xdf, 0xb4, 0x8a, 0x6c, 0x91, 0x39, 0xdd,\n              0xd7, 0xf7, 0x69, 0x66, 0xe9, 0x28, 0xe6, 0x35, 0x55, 0x3b,\n              0xa7, 0x6c, 0x5c, 0x87, 0x9d, 0x7b, 0x35, 0xd4, 0x9e, 0xb2,\n              0xe6, 0x2b, 0x08, 0x71, 0xcd, 0xac, 0x63, 0x89, 0x39, 0xe2,\n              0x5e, 0x8a, 0x1e, 0x0e, 0xf9, 0xd5, 0x28, 0x0f, 0xa8, 0xca,\n              0x32, 0x8b, 0x35, 0x1c, 0x3c, 0x76, 0x59, 0x89, 0xcb, 0xcf,\n              0x3d, 0xaa, 0x8b, 0x6c, 0xcc, 0x3a, 0xaf, 0x9f, 0x39, 0x79,\n              0xc9, 0x2b, 0x37, 0x20, 0xfc, 0x88, 0xdc, 0x95, 0xed, 0x84,\n              0xa1, 0xbe, 0x05, 0x9c, 0x64, 0x99, 0xb9, 0xfd, 0xa2, 0x36,\n              0xe7, 0xe8, 0x18, 0xb0, 0x4b, 0x0b, 0xc3, 0x9c, 0x1e, 0x87,\n              0x6b, 0x19, 0x3b, 0xfe, 0x55, 0x69, 0x75, 0x3f, 0x88, 0x12,\n              0x8c, 0xc0, 0x8a, 0xaa, 0x9b, 0x63, 0xd1, 0xa1, 0x6f, 0x80,\n              0xef, 0x25, 0x54, 0xd7, 0x18, 0x9c, 0x41, 0x1f, 0x58, 0x69,\n              0xca, 0x52, 0xc5, 0xb8, 0x3f, 0xa3, 0x6f, 0xf2, 0x16, 0xb9,\n              0xc1, 0xd3, 0x00, 0x62, 0xbe, 0xbc, 0xfd, 0x2d, 0xc5, 0xbc,\n              0xe0, 0x91, 0x19, 0x34, 0xfd, 0xa7, 0x9a, 0x86, 0xf6, 0xe6,\n              0x98, 0xce, 0xd7, 0x59, 0xc3, 0xff, 0x9b, 0x64, 0x77, 0x33,\n              0x8f, 0x3d, 0xa4, 0xf9, 0xcd, 0x85, 0x14, 0xea, 0x99, 0x82,\n              0xcc, 0xaf, 0xb3, 0x41, 0xb2, 0x38, 0x4d, 0xd9, 0x02, 0xf3,\n              0xd1, 0xab, 0x7a, 0xc6, 0x1d, 0xd2, 0x9c, 0x6f, 0x21, 0xba,\n              0x5b, 0x86, 0x2f, 0x37, 0x30, 0xe3, 0x7c, 0xfd, 0xc4, 0xfd,\n              0x80, 0x6c, 0x22, 0xf2, 0x21 ]\n\n      msg = [ 0x41, 0x6e, 0x79, 0x20, 0x73, 0x75, 0x62, 0x6d, 0x69, 0x73,\n              0x73, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68,\n              0x65, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x69, 0x6e, 0x74,\n              0x65, 0x6e, 0x64, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62,\n              0x75, 0x74, 0x6f, 0x72, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x70,\n              0x75, 0x62, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n              0x20, 0x61, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6f, 0x72,\n              0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61,\n              0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x49, 0x6e, 0x74,\n              0x65, 0x72, 0x6e, 0x65, 0x74, 0x2d, 0x44, 0x72, 0x61, 0x66,\n              0x74, 0x20, 0x6f, 0x72, 0x20, 0x52, 0x46, 0x43, 0x20, 0x61,\n              0x6e, 0x64, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x73, 0x74, 0x61,\n              0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x61, 0x64,\n              0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74,\n              0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x20, 0x49, 0x45, 0x54,\n              0x46, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79,\n              0x20, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64,\n              0x65, 0x72, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x20, 0x22, 0x49,\n              0x45, 0x54, 0x46, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69,\n              0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x2e, 0x20, 0x53,\n              0x75, 0x63, 0x68, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6d,\n              0x65, 0x6e, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75,\n              0x64, 0x65, 0x20, 0x6f, 0x72, 0x61, 0x6c, 0x20, 0x73, 0x74,\n              0x61, 0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x69,\n              0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x73, 0x65, 0x73,\n              0x73, 0x69, 0x6f, 0x6e, 0x73, 0x2c, 0x20, 0x61, 0x73, 0x20,\n              0x77, 0x65, 0x6c, 0x6c, 0x20, 0x61, 0x73, 0x20, 0x77, 0x72,\n              0x69, 0x74, 0x74, 0x65, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20,\n              0x65, 0x6c, 0x65, 0x63, 0x74, 0x72, 0x6f, 0x6e, 0x69, 0x63,\n              0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61,\n              0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x6d, 0x61, 0x64, 0x65,\n              0x20, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x69,\n              0x6d, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x70, 0x6c, 0x61, 0x63,\n              0x65, 0x2c, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61,\n              0x72, 0x65, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,\n              0x65, 0x64, 0x20, 0x74, 0x6f ]\n\n  rfctest03 = encrypt key 42 (zero # [2]) msg == out\n    where\n      key = [ 0x1c, 0x92, 0x40, 0xa5, 0xeb, 0x55, 0xd3, 0x8a, 0xf3, 0x33,\n              0x88, 0x86, 0x04, 0xf6, 0xb5, 0xf0, 0x47, 0x39, 0x17, 0xc1,\n              0x40, 0x2b, 0x80, 0x09, 0x9d, 0xca, 0x5c, 0xbc, 0x20, 0x70,\n              0x75, 0xc0 ]\n      out = [ 0x27, 0x54, 0x77, 0x61, 0x73, 0x20, 0x62, 0x72, 0x69, 0x6c,\n              0x6c, 0x69, 0x67, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x73, 0x6c, 0x69, 0x74, 0x68, 0x79, 0x20,\n              0x74, 0x6f, 0x76, 0x65, 0x73, 0x0a, 0x44, 0x69, 0x64, 0x20,\n              0x67, 0x79, 0x72, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x67,\n              0x69, 0x6d, 0x62, 0x6c, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x74,\n              0x68, 0x65, 0x20, 0x77, 0x61, 0x62, 0x65, 0x3a, 0x0a, 0x41,\n              0x6c, 0x6c, 0x20, 0x6d, 0x69, 0x6d, 0x73, 0x79, 0x20, 0x77,\n              0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6f,\n              0x72, 0x6f, 0x67, 0x6f, 0x76, 0x65, 0x73, 0x2c, 0x0a, 0x41,\n              0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x6f, 0x6d,\n              0x65, 0x20, 0x72, 0x61, 0x74, 0x68, 0x73, 0x20, 0x6f, 0x75,\n              0x74, 0x67, 0x72, 0x61, 0x62, 0x65, 0x2e ]\n\n      msg = [ 0x62, 0xe6, 0x34, 0x7f, 0x95, 0xed, 0x87, 0xa4, 0x5f, 0xfa,\n              0xe7, 0x42, 0x6f, 0x27, 0xa1, 0xdf, 0x5f, 0xb6, 0x91, 0x10,\n              0x04, 0x4c, 0x0d, 0x73, 0x11, 0x8e, 0xff, 0xa9, 0x5b, 0x01,\n              0xe5, 0xcf, 0x16, 0x6d, 0x3d, 0xf2, 0xd7, 0x21, 0xca, 0xf9,\n              0xb2, 0x1e, 0x5f, 0xb1, 0x4c, 0x61, 0x68, 0x71, 0xfd, 0x84,\n              0xc5, 0x4f, 0x9d, 0x65, 0xb2, 0x83, 0x19, 0x6c, 0x7f, 0xe4,\n              0xf6, 0x05, 0x53, 0xeb, 0xf3, 0x9c, 0x64, 0x02, 0xc4, 0x22,\n              0x34, 0xe3, 0x2a, 0x35, 0x6b, 0x3e, 0x76, 0x43, 0x12, 0xa6,\n              0x1a, 0x55, 0x32, 0x05, 0x57, 0x16, 0xea, 0xd6, 0x96, 0x25,\n              0x68, 0xf8, 0x7d, 0x3f, 0x3f, 0x77, 0x04, 0xc6, 0xa8, 0xd1,\n              0xbc, 0xd1, 0xbf, 0x4d, 0x50, 0xd6, 0x15, 0x4b, 0x6d, 0xa7,\n              0x31, 0xb1, 0x87, 0xb5, 0x8d, 0xfd, 0x72, 0x8a, 0xfa, 0x36,\n              0x75, 0x7a, 0x79, 0x7a, 0xc1, 0x88, 0xd1 ]\n\nproperty allTestsPass =\n  and\n  [     qround01, core01, core02\n      , rfctest01, rfctest02, rfctest03\n  ]\n\nprivate\n      blocked : Round -> Block\n  blocked x = join (map toBytes x)\n    where\n                        toBytes : [32] -> [4][8]\n      toBytes v = reverse (groupBy`{8} v)\n\n    map : { a, b, c }\n        (a -> b) -> [c]a -> [c]b\n  map f xs = [ f x | x <- xs ]\n\n          iterate : { a } (a -> a) -> a -> [inf]a\n  iterate f x = [x] # [ f v | v <- iterate f x ]\n    where\n            xs = [x] # [ f v | v <- xs ]\n\n        rjoin : {a, b, c}\n        ( fin a, fin c\n        ) => [c][a]b -> [a * c]b\n  rjoin x = join (reverse x)\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Stream\/ZUC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Stream::ZUC that contains the following definitions, with exactly the same types and behaviors as the implementation: (1) A boolean constant version1_5 that selects the newer standard\u2019s behavior. (2) add: a polymorphic function (finite length parameter) that consumes a vector of 31\u2011bit words and returns their 31\u2011bit modular sum using a carry from a 32\u2011bit intermediate; include an internal accumulator semantics as in a running sum. (3) A type alias LFSR as a 16\u2011element vector of 31\u2011bit words. (4) LFSRWithInitializationMode: given a 31\u2011bit input and an LFSR, compute the next LFSR by a linear feedback formed from selected taps and left shifts; combine with the input using either modular addition or XOR depending on version1_5; replace zero with a fixed nonzero constant. (5) LFSRWithWorkMode: same feedback update without external input and with zero\u2011replacement. (6) BitReorganization: assemble four 32\u2011bit words from high\/low halves of selected LFSR elements. (7) F: a nonlinear function taking three 32\u2011bit inputs and two 32\u2011bit registers, performing modular additions\/XORs, splitting into halves, applying L1\/L2 (XORs of left rotations by fixed offsets), then S (bytewise S\u2011boxes), returning one word and updated registers. (8) S: map a 32\u2011bit word via S0..S3; define S0,S1,S2,S3: [8]->[8] with S2=S0 and S3=S1, and constants S0Table,S1Table (256 entries of 8 bits) with the same values and types. (9) L1,L2: [32]->[32] linear transforms as XORs of left rotations by fixed offsets. (10) LoadKey: build the initial LFSR from a 128\u2011bit key and 128\u2011bit IV by interleaving bytes with fixed 15\u2011bit constants. (11) A type alias ZUC as (LFSR,[32],[32]). (12) InitializeZUC: produce an infinite stream of internal states via self\u2011recurrence using BitReorganization, F, and the version flag\u2019s mixing rule. (13) WorkingStage: one state update with no output. (14) ProductionStage: output a 32\u2011bit word and next state. (15) ZUC: keystream generator returning an infinite stream of 32\u2011bit words, discarding the first word. Also, define a property that checks S on a specific 32\u2011bit constant yields a specific 32\u2011bit constant (example8); define a property that the initial keystream words for given test inputs match published values (ZUC_TestVectors); define a property that LoadKey yields specified initial LFSRs for given inputs (LoadKey_TestVectors); define a property stating distinct IVs produce distinct states after one initialization step for any key (ZUC_isResistantToCollisionAttack)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Stream::ZUC where\n\nversion1_5 : Bit\nversion1_5 = True\n\nadd : {a} (fin a) => [a][31] -> [31]\nadd xs =\n    sums ! 0\n    where\n      sums =\n          [0] #\n          [plus (s, x) | s <- sums\n                       | x <- xs]\n            plus : ([31], [31]) -> [31]\n      plus (a, b) =\n          if sab @ 0 then sab' + 1 else sab'\n          where\n            sab : [32]\n            sab = ((zero : [1]) # a) + ((zero : [1]) # b)\n            sab' : [31]\n            sab' = drop sab\n\ntype LFSR = [16][31]\n\nLFSRWithInitializationMode : ([31], LFSR) -> LFSR\nLFSRWithInitializationMode (u, ss) =\n    ss @@ [1 .. 15] # [s16]\n    where\n      v = add [s <<< c | s <- ss @@ [15, 13, 10, 4, 0, 0]\n                       | c <- [15, 17, 21, 20, 8, 0]]\n      vu = if version1_5 then add [v, u] else v ^ u\n      s16 = if vu == 0 then `0x7FFFFFFF else vu\n\nLFSRWithWorkMode : LFSR -> LFSR\nLFSRWithWorkMode ss =\n    ss @@ [1 .. 15] # [s16]\n    where\n      v = add [s <<< c | s <- ss @@ [15, 13, 10, 4, 0, 0]\n                       | c <- [15, 17, 21, 20, 8, 0]]\n      s16 = if v == 0 then `0x7FFFFFFF else v\n\nBitReorganization : LFSR -> [4][32]\nBitReorganization ss =\n    [ hi s15 # lo s14\n    , lo s11 # hi s9\n    , lo s7  # hi s5\n    , lo s2  # hi s0]\n    where\n      lo : [31] -> [16]\n      hi : [31] -> [16]\n      lo x = x @@ [15 .. 30]\n      hi x = x @@ [0  .. 15]\n      [s0, s2, s5, s7, s9, s11, s14, s15] = ss @@ [0, 2, 5, 7, 9, 11, 14, 15]\n\nF : ([3][32], [2][32]) -> ([32], [2][32])\nF ([X0, X1, X2], [R1, R2]) =\n    (W, [R1', R2'])\n    where\n      W = (X0 ^ R1) + R2\n      W1 = R1 + X1\n      W2 = R2 ^ X2\n      [W1H, W1L] = split W1\n      [W2H, W2L] = split W2\n      R1' = S (L1 (W1L # W2H))\n      R2' = S (L2 (W2L # W1H))\n\nS : [32] -> [32]\nS X =\n    Y0 # Y1 # Y2 # Y3\n    where\n      [X0, X1, X2, X3] = split X\n      [Y0, Y1, Y2, Y3] = [S0 X0, S1 X1, S2 X2, S3 X3]\n\nproperty example8 = S(0x12345678) == 0xF9C05A4E\n\nS0 : [8] -> [8]\nS1 : [8] -> [8]\nS2 : [8] -> [8]\nS3 : [8] -> [8]\nS0 x = S0Table @ x\nS1 x = S1Table @ x\nS2 = S0\nS3 = S1\n\nS0Table : [256][8]\nS0Table =\n    [0x3E, 0x72, 0x5B, 0x47, 0xCA, 0xE0, 0x00, 0x33, 0x04, 0xD1, 0x54,\n     0x98, 0x09, 0xB9, 0x6D, 0xCB, 0x7B, 0x1B, 0xF9, 0x32, 0xAF, 0x9D,\n     0x6A, 0xA5, 0xB8, 0x2D, 0xFC, 0x1D, 0x08, 0x53, 0x03, 0x90, 0x4D,\n     0x4E, 0x84, 0x99, 0xE4, 0xCE, 0xD9, 0x91, 0xDD, 0xB6, 0x85, 0x48,\n     0x8B, 0x29, 0x6E, 0xAC, 0xCD, 0xC1, 0xF8, 0x1E, 0x73, 0x43, 0x69,\n     0xC6, 0xB5, 0xBD, 0xFD, 0x39, 0x63, 0x20, 0xD4, 0x38, 0x76, 0x7D,\n     0xB2, 0xA7, 0xCF, 0xED, 0x57, 0xC5, 0xF3, 0x2C, 0xBB, 0x14, 0x21,\n     0x06, 0x55, 0x9B, 0xE3, 0xEF, 0x5E, 0x31, 0x4F, 0x7F, 0x5A, 0xA4,\n     0x0D, 0x82, 0x51, 0x49, 0x5F, 0xBA, 0x58, 0x1C, 0x4A, 0x16, 0xD5,\n     0x17, 0xA8, 0x92, 0x24, 0x1F, 0x8C, 0xFF, 0xD8, 0xAE, 0x2E, 0x01,\n     0xD3, 0xAD, 0x3B, 0x4B, 0xDA, 0x46, 0xEB, 0xC9, 0xDE, 0x9A, 0x8F,\n     0x87, 0xD7, 0x3A, 0x80, 0x6F, 0x2F, 0xC8, 0xB1, 0xB4, 0x37, 0xF7,\n     0x0A, 0x22, 0x13, 0x28, 0x7C, 0xCC, 0x3C, 0x89, 0xC7, 0xC3, 0x96,\n     0x56, 0x07, 0xBF, 0x7E, 0xF0, 0x0B, 0x2B, 0x97, 0x52, 0x35, 0x41,\n     0x79, 0x61, 0xA6, 0x4C, 0x10, 0xFE, 0xBC, 0x26, 0x95, 0x88, 0x8A,\n     0xB0, 0xA3, 0xFB, 0xC0, 0x18, 0x94, 0xF2, 0xE1, 0xE5, 0xE9, 0x5D,\n     0xD0, 0xDC, 0x11, 0x66, 0x64, 0x5C, 0xEC, 0x59, 0x42, 0x75, 0x12,\n     0xF5, 0x74, 0x9C, 0xAA, 0x23, 0x0E, 0x86, 0xAB, 0xBE, 0x2A, 0x02,\n     0xE7, 0x67, 0xE6, 0x44, 0xA2, 0x6C, 0xC2, 0x93, 0x9F, 0xF1, 0xF6,\n     0xFA, 0x36, 0xD2, 0x50, 0x68, 0x9E, 0x62, 0x71, 0x15, 0x3D, 0xD6,\n     0x40, 0xC4, 0xE2, 0x0F, 0x8E, 0x83, 0x77, 0x6B, 0x25, 0x05, 0x3F,\n     0x0C, 0x30, 0xEA, 0x70, 0xB7, 0xA1, 0xE8, 0xA9, 0x65, 0x8D, 0x27,\n     0x1A, 0xDB, 0x81, 0xB3, 0xA0, 0xF4, 0x45, 0x7A, 0x19, 0xDF, 0xEE,\n     0x78, 0x34, 0x60]\n\nS1Table : [256][8]\nS1Table =\n    [0x55, 0xC2, 0x63, 0x71, 0x3B, 0xC8, 0x47, 0x86, 0x9F, 0x3C, 0xDA,\n     0x5B, 0x29, 0xAA, 0xFD, 0x77, 0x8C, 0xC5, 0x94, 0x0C, 0xA6, 0x1A,\n     0x13, 0x00, 0xE3, 0xA8, 0x16, 0x72, 0x40, 0xF9, 0xF8, 0x42, 0x44,\n     0x26, 0x68, 0x96, 0x81, 0xD9, 0x45, 0x3E, 0x10, 0x76, 0xC6, 0xA7,\n     0x8B, 0x39, 0x43, 0xE1, 0x3A, 0xB5, 0x56, 0x2A, 0xC0, 0x6D, 0xB3,\n     0x05, 0x22, 0x66, 0xBF, 0xDC, 0x0B, 0xFA, 0x62, 0x48, 0xDD, 0x20,\n     0x11, 0x06, 0x36, 0xC9, 0xC1, 0xCF, 0xF6, 0x27, 0x52, 0xBB, 0x69,\n     0xF5, 0xD4, 0x87, 0x7F, 0x84, 0x4C, 0xD2, 0x9C, 0x57, 0xA4, 0xBC,\n     0x4F, 0x9A, 0xDF, 0xFE, 0xD6, 0x8D, 0x7A, 0xEB, 0x2B, 0x53, 0xD8,\n     0x5C, 0xA1, 0x14, 0x17, 0xFB, 0x23, 0xD5, 0x7D, 0x30, 0x67, 0x73,\n     0x08, 0x09, 0xEE, 0xB7, 0x70, 0x3F, 0x61, 0xB2, 0x19, 0x8E, 0x4E,\n     0xE5, 0x4B, 0x93, 0x8F, 0x5D, 0xDB, 0xA9, 0xAD, 0xF1, 0xAE, 0x2E,\n     0xCB, 0x0D, 0xFC, 0xF4, 0x2D, 0x46, 0x6E, 0x1D, 0x97, 0xE8, 0xD1,\n     0xE9, 0x4D, 0x37, 0xA5, 0x75, 0x5E, 0x83, 0x9E, 0xAB, 0x82, 0x9D,\n     0xB9, 0x1C, 0xE0, 0xCD, 0x49, 0x89, 0x01, 0xB6, 0xBD, 0x58, 0x24,\n     0xA2, 0x5F, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xB8, 0x95, 0xE4,\n     0xD0, 0x91, 0xC7, 0xCE, 0xED, 0x0F, 0xB4, 0x6F, 0xA0, 0xCC, 0xF0,\n     0x02, 0x4A, 0x79, 0xC3, 0xDE, 0xA3, 0xEF, 0xEA, 0x51, 0xE6, 0x6B,\n     0x18, 0xEC, 0x1B, 0x2C, 0x80, 0xF7, 0x74, 0xE7, 0xFF, 0x21, 0x5A,\n     0x6A, 0x54, 0x1E, 0x41, 0x31, 0x92, 0x35, 0xC4, 0x33, 0x07, 0x0A,\n     0xBA, 0x7E, 0x0E, 0x34, 0x88, 0xB1, 0x98, 0x7C, 0xF3, 0x3D, 0x60,\n     0x6C, 0x7B, 0xCA, 0xD3, 0x1F, 0x32, 0x65, 0x04, 0x28, 0x64, 0xBE,\n     0x85, 0x9B, 0x2F, 0x59, 0x8A, 0xD7, 0xB0, 0x25, 0xAC, 0xAF, 0x12,\n     0x03, 0xE2, 0xF2]\n\nL1 : [32] -> [32]\nL1 X = X ^ X <<< 2 ^ X <<< 10 ^ X <<< 18 ^ X <<< 24\n\nL2 : [32] -> [32]\nL2 X = X ^ X <<< 8 ^ X <<< 14 ^ X <<< 22 ^ X <<< 30\n\nLoadKey : ([128], [128]) -> LFSR\nLoadKey (key, iv) =\n    [k # d # i | k <- ks\n               | i <- is\n               | d <- ds]\n    where\n      ks : [16][8]\n      ks = split key\n      is : [16][8]\n      is = split iv\n      ds : [16][15]\n      ds =\n          [ 0b100010011010111, 0b010011010111100\n          , 0b110001001101011, 0b001001101011110\n          , 0b101011110001001, 0b011010111100010\n          , 0b111000100110101, 0b000100110101111\n          , 0b100110101111000, 0b010111100010011\n          , 0b110101111000100, 0b001101011110001\n          , 0b101111000100110, 0b011110001001101\n          , 0b111100010011010, 0b100011110101100\n          ]\n\ntype ZUC = (LFSR, [32], [32])\n\nInitializeZUC : ([128], [128]) -> [inf]ZUC\nInitializeZUC (key, iv) =\n    outs\n    where\n      initLFSR = LoadKey (key, iv)\n      outs = [(initLFSR, 0, 0)] # [step out | out <- outs]\n      step (lfsr, R1, R2) =\n          (LFSRWithInitializationMode (drop (w >> 1), lfsr), R1', R2')\n          where\n            [X0, X1, X2, X3] = BitReorganization lfsr\n            (w', [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n            w = if version1_5 then w' else w' ^ X3\n\n\/\/ Section 3.6.2\nWorkingStage : ZUC -> ZUC\nWorkingStage (lfsr, R1, R2) =\n    (lfsr', R1', R2')\n    where\n      [X0, X1, X2, _] = BitReorganization lfsr\n      (_, [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n      lfsr' = LFSRWithWorkMode lfsr\n\n\/\/ Section 3.6.2\nProductionStage : ZUC -> ([32], ZUC)\nProductionStage (lfsr, R1, R2) =\n    (w ^ X3, (lfsr', R1', R2'))\n    where\n      [X0, X1, X2, X3] = BitReorganization lfsr\n      (w, [R1', R2']) = F ([X0, X1, X2], [R1, R2])\n      lfsr' = LFSRWithWorkMode lfsr\n\n\/\/ ZUC API\nZUC : [128] -> [128] -> [inf][32]\nZUC key iv =\n    tail [w | (w, _) <- zucs]\n    where\n      initZuc = WorkingStage (InitializeZUC (key, iv) @ 32)\n      zucs = [(zero, initZuc)] # [ProductionStage zuc | (_, zuc) <- zucs]\n\n\/\/ Test vectors\nproperty ZUC_TestVectors =\n    t1 \/\\ t2 \/\\ t3 \/\\ t4\n    where\n      t1 = take (ZUC zero    zero   ) == [0x27BEDE74, 0x018082DA]\n      t2 = take (ZUC (~zero) (~zero)) == [0x0657CFA0, 0x7096398B]\n      t3 = take (ZUC (join [ 0x3D, 0x4C, 0x4B, 0xE9, 0x6A, 0x82, 0xFD, 0xAE\n                           , 0xB5, 0x8F, 0x64, 0x1D, 0xB1, 0x7B, 0x45, 0x5B\n                           ])\n                     (join [ 0x84, 0x31, 0x9A, 0xA8, 0xDE, 0x69, 0x15, 0xCA\n                           , 0x1F, 0x6B, 0xDA, 0x6B, 0xFB, 0xD8, 0xC7, 0x66\n                           ])) == [0x14F1C272, 0x3279C419]\n      t4 = take ks # [ks @ 1999] == [0xED4400E7, 0x0633E5C5, 0x7A574CDB]\n        where\n          ks = ZUC (join [ 0x4D, 0x32, 0x0B, 0xFA, 0xD4, 0xC2, 0x85, 0xBF\n                         , 0xD6, 0xB8, 0xBD, 0x00, 0xF3, 0x9D, 0x8B, 0x41\n                         ])\n                   (join [ 0x52, 0x95, 0x9D, 0xAB, 0xA0, 0xBF, 0x17, 0x6E\n                         , 0xCE, 0x2D, 0xC3, 0x15, 0x04, 0x9E, 0xB5, 0x74\n                         ])\n\n\/\/ 3.3-3.6 of the implementor's test data document lists \"LFSR-state at the\n\/\/ beginning\", which is immediately after running LoadKey.\nproperty LoadKey_TestVectors =\n    [ LoadKey(k, iv) == lfsr0\n    | k <- ks\n    | iv <- ivs\n    | lfsr0 <- lfsr0s\n    ] == ~0\n  where\n    ks = [ 0\n         , ~0\n         , 0x3d4c4be96a82fdaeb58f641db17b455b\n         , 0x4d320bfad4c285bfd6b8bd00f39d8b41\n         ]\n    ivs = [ 0\n          , ~0\n          , 0x84319aa8de6915ca1f6bda6bfbd8c766\n          , 0x52959daba0bf176ece2dc315049eb574\n          ]\n    lfsr0s = [ [ `0x0044d700, `0x0026bc00, `0x00626b00, `0x00135e00\n               , `0x00578900, `0x0035e200, `0x00713500, `0x0009af00\n               , `0x004d7800, `0x002f1300, `0x006bc400, `0x001af100\n               , `0x005e2600, `0x003c4d00, `0x00789a00, `0x0047ac00\n               ]\n             , [ `0x7fc4d7ff, `0x7fa6bcff, `0x7fe26bff, `0x7f935eff\n               , `0x7fd789ff, `0x7fb5e2ff, `0x7ff135ff, `0x7f89afff\n               , `0x7fcd78ff, `0x7faf13ff, `0x7febc4ff, `0x7f9af1ff\n               , `0x7fde26ff, `0x7fbc4dff, `0x7ff89aff, `0x7fc7acff\n               ]\n             , [ `0x1ec4d784, `0x2626bc31, `0x25e26b9a, `0x74935ea8\n               , `0x355789de, `0x4135e269, `0x7ef13515, `0x5709afca\n               , `0x5acd781f, `0x47af136b, `0x326bc4da, `0x0e9af16b\n               , `0x58de26fb, `0x3dbc4dd8, `0x22f89ac7, `0x2dc7ac66\n               ]\n             , [ `0x26c4d752, `0x1926bc95, `0x05e26b9d, `0x7d135eab\n               , `0x6a5789a0, `0x6135e2bf, `0x42f13517, `0x5f89af6e\n               , `0x6b4d78ce, `0x5c2f132d, `0x5eebc4c3, `0x001af115\n               , `0x79de2604, `0x4ebc4d9e, `0x45f89ab5, `0x20c7ac74\n               ]\n             ]\n\nproperty ZUC_isResistantToCollisionAttack k iv1 iv2 =\n    if iv1 != iv2\n    then InitializeZUC (k, iv1) @ 1 != InitializeZUC (k, iv2) @ 1\n    else True\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/McMambo.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::McMambo that contains the following definitions with precise type signatures and constraints: type synonyms for a 32-bit word, a 4\u00d74 state of words, an 8-word key, and 16-word tweak and block. Implement bitwise functions nand and nor polymorphic over bitvector length, and introduce infix aliases for NAND, NOR, XOR, AND, and OR. Define a left-rotate function over words taking a word-sized rotation count. Define a tweak injection that conditionally xors a split tweak into a state based on a round index; include properties proving it is injective on states and that applying it twice with the same inputs returns the original state. Define a 4-word nonlinear layer using the Boolean ops and rotations, with a property checking injectivity. Define diffusion layers that apply this nonlinear layer across rows and columns via transposes, plus verbose equivalents; add properties asserting extensional equality between compact and verbose forms. Add a Boolean predicate stating that applying the alternate diffusion after the primary yields the original state (not currently valid). Define round-key injection that xors a structured 4\u00d74 mask derived from key words and a round counter, with a property showing self-inverse behavior. Define one-round and iterated 12-round core permutations (forward and inverse schedules); add a Boolean predicate that the inverse schedule after the forward recovers the input. Provide byte\/word pack and unpack functions parameterized by the number of words, with round-trip properties. Provide padding functions with fin constraints and ceiling-division relations. Define block cipher functions over blocks and byte-level wrappers, plus a known-answer test property comparing to a fixed constant. Include a partial AEAD skeleton with unspecified parts left undefined."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::McMambo where\n\ntype word = [32]\ntype state = [4][4]word\ntype key = [8]word\ntype tweak = [16]word\ntype block = [16]word\n\nnand : {a} [a] -> [a] -> [a]\nnand x y = ~(x && y)\n\nnor : {a} [a] -> [a] -> [a]\nnor x y = ~(x || y)\n\n(\u2191) = nand\n(\u2193) = nor\n(\u2295) = (^)\n(\u2227) = (&&)\n(\u2228) = (||)\n\nR : (word, word) -> word\nR (x, c) = x <<< c\n\nT : word -> tweak -> state -> state\nT n t s = s \u2295 (if n == 5 then split t else zero)\n\nproperty T_bijective t n s s' =\n  (s != s') == (T n t s != T n t s')\n\n\/**\n * ```repl\n * :prove T_inverse\n * ```\n *\/\nproperty T_inverse n t s =\n  T n t (T n t s) == s\n\nQ : [4]word -> [4]word\nQ [x0, x1, x2, x3] = [y0, y1, y2, y3]\n  where\n    y1 = x1 \u2295 R (x0 \u2227 x2, 7)\n    y2 = x2 \u2295 R (x0 \u2228 x3, 9)\n    y3 = x3 \u2295 R (y1 \u2191 x0, 13)\n    y0 = x0 \u2295 R (y1 \u2193 y2, 18)\n\n\/**\n * ```repl\n * :prove Q_bijective\n * ```\n *\/\nproperty Q_bijective x x' =\n  (x != x') == (Q x != Q x')\n\nD : state -> state\nD X = Z\n  where\n    Y = transpose [ Q xs | xs <- X ]\n    Z = transpose [ Q ys | ys <- Y ]\n\nD' : state -> state\nD' X = Z\n  where\n    Y = [ Q xs | xs <- transpose X ]\n    Z = [ Q ys | ys <- transpose Y ]\n\nD_verbose : state -> state\nD_verbose [ [ x0,  x1,  x2,  x3]\n          , [ x4,  x5,  x6,  x7]\n          , [ x8,  x9, x10, x11]\n          , [x12, x13, x14, x15] ] = Z\n  where\n    [ y0,  y1,  y2,  y3] = Q [ x0,  x1,  x2,  x3]\n    [ y4,  y5,  y6,  y7] = Q [ x4,  x5,  x6,  x7]\n    [ y8,  y9, y10, y11] = Q [ x8,  x9, x10, x11]\n    [y12, y13, y14, y15] = Q [x12, x13, x14, x15]\n    [ z0,  z4,  z8, z12] = Q [ y0,  y4,  y8, y12]\n    [ z1,  z5,  z9, z13] = Q [ y1,  y5,  y9, y13]\n    [ z2,  z6, z10, z14] = Q [ y2,  y6, y10, y14]\n    [ z3,  z7, z11, z15] = Q [ y3,  y7, y11, y15]\n    Z = [ [ z0,  z1,  z2,  z3]\n        , [ z4,  z5,  z6,  z7]\n        , [ z8,  z9, z10, z11]\n        , [z12, z13, z14, z15] ]\n\nD'_verbose : state -> state\nD'_verbose [ [ x0,  x1,  x2,  x3]\n           , [ x4,  x5,  x6,  x7]\n           , [ x8,  x9, x10, x11]\n           , [x12, x13, x14, x15] ] = Z\n  where\n    [ y0,  y4,  y8, y12] = Q [ x0,  x4,  x8, x12]\n    [ y1,  y5,  y9, y13] = Q [ x1,  x5,  x9, x13]\n    [ y2,  y6, y10, y14] = Q [ x2,  x6, x10, x14]\n    [ y3,  y7, y11, y15] = Q [ x3,  x7, x11, x15]\n    [ z0,  z1,  z2,  z3] = Q [ y0,  y1,  y2,  y3]\n    [ z4,  z5,  z6,  z7] = Q [ y4,  y5,  y6,  y7]\n    [ z8,  z9, z10, z11] = Q [ y8,  y9, y10, y11]\n    [z12, z13, z14, z15] = Q [y12, y13, y14, y15]\n    Z = [ [ z0,  z1,  z2,  z3]\n        , [ z4,  z5,  z6,  z7]\n        , [ z8,  z9, z10, z11]\n        , [z12, z13, z14, z15] ]\n\nproperty D_matches =\n  D === D_verbose\n\nproperty D'_matches =\n  D' === D'_verbose\n\n\/\/ Not yet true\n\/*property*\/\nD_D'_correct s =\n  D' (D s) == s\n\nK : key -> word -> state -> state\nK [k0, k1, k2, k3, k4, k5, k6, k7] j x =\n  x \u2295 [ [  j, k0,  0, k1 ]\n      , [ k2,  j, k3,  0 ]\n      , [  0, k4,  j, k5 ]\n      , [ k6,  0, k7,  j ]\n      ]\n\n\/**\n * ```repl\n * :prove K_inverse\n * ```\n *\/\nproperty K_inverse k j s =\n  K k j (K k j s) == s\n\nC1 : key -> tweak -> state -> state\nC1 k t s0 = K k 0 (T 1 t (D (K k 1 (T 0 t (D (K k 0 s0))))))\n\nC : key -> tweak -> state -> state\nC k t s0 = K k 0 (ss!0)\n  where\n    ss : [13]state\n    ss = [s0] # [ T n t (D (K k n s)) | s <- ss | n <- [0..11] ]\n\nC' : key -> tweak -> state -> state\nC' k t s0 = ss!0\n  where\n    ss : [13]state\n    ss = [K k 0 s0] # [ K k n (D' (T n t s)) | s <- ss | n <- reverse [0..11] ]\n\nfrom_bytes : {a} [a*4][8] -> [a][32]\nfrom_bytes bytes = [ join (reverse xs) | (xs : [4][8]) <- blocks ]\n  where blocks : [a][4][8]\n        blocks = split bytes\n\nto_bytes : {a} [a][32] -> [a*4][8]\nto_bytes words = join [ reverse (split word : [4][8]) | word <- words ]\n\nproperty from_to_bytes (words : [16][32]) =\n  from_bytes (to_bytes words) == words\n\nproperty to_from_bytes (bytes : [64][8]) =\n  to_bytes (from_bytes bytes) == bytes\n\nC_C'_correct k t s0 =\n  C' k t (C k t s0) == s0\n\npad : {n, b} (fin n, b == (n+8) \/^ 512) => [n] -> [b][512]\npad m = split (m # 0x01 # zero)\n\npad_bytes : {n, b} (fin n, b == (n+1) \/^ 64) => [n][8] -> [b*64][8]\npad_bytes m = m # [0x01] # zero\n\nMambo : key -> tweak -> block -> block\nMambo k t m = join (C k t (split m))\n\nMambo' : key -> tweak -> block -> block\nMambo' k t m = join (C' k t (split m))\n\nMambo_bytes : [_][8] -> [_][8] -> [_][8] -> _\nMambo_bytes k t m = to_bytes (Mambo (from_bytes k) (from_bytes t) (from_bytes m))\n\nMambo_bytes' : [_][8] -> [_][8] -> [_][8] -> _\nMambo_bytes' k t m = to_bytes (Mambo' (from_bytes k) (from_bytes t) (from_bytes m))\n\nproperty Mambo_test =\n  join (Mambo_bytes (\"Me\" # zero) (\"Try\" # zero) (\"Test\" # zero)) ==\n  0xeb514a1ff2609f3a81ccfdd5e5342dba332d7b159a1571cee66d14bb6fd48ceb1ae956a91d3f54c8a545262c26611245a917d0a1582ecbc1d397b612baf7a62d\n\nMcMambo k ad npub M = undefined\n  where\n    Us = [zero] # [ u ^ Mambo_bytes k u a | u <- Us | a <- split (pad_bytes ad) ]\n    \u03c4 = Mambo_bytes k (Us!0) npub\n    u' = (Us!0) ^ \u03c4\n    Cs = [ Mambo_bytes k u m | u <- undefined | m <- split (pad_bytes M # \u03c4)]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/PRESENT.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::PRESENT that contains the following definitions mirroring the PRESENT block cipher and key schedules: (1) Type aliases: 64-bit block size, 32-bit standard size, 80-bit key size, 64-bit round key size, 128-bit key size, and a state as a 4\u00d74 matrix of 4-bit nibbles. (2) Constants: a 16-entry 4-bit S-box and its inverse; 64-entry bit-permutation tables and their inverse, with element types appropriate for indexing a 64-bit block; ensure all constants have the PRESENT standard values. (3) Key schedules: for 80-bit keys, a function taking an 80-bit key and 5-bit round index and returning a 4-tuple (64-bit round key, 80-bit rotated key, 80-bit substituted key, 80-bit next key); and a function producing a 32-element sequence of such tuples (rounds 0..31). For 128-bit keys, analogous functions returning (64-bit round key, 128-bit next key) and a 32-element sequence. (4) Round functions: XOR-based round-key addition on states; nibble-wise S-box and inverse; 64-bit-to-state and state-to-64-bit conversions; bit permutation and its inverse; one-round encryption and decryption over states. (5) Cipher APIs: 80-bit-key encrypt\/decrypt mapping (key, 64-bit block) to 64-bit block using 31 rounds with initial and final whitening as implied by the schedule; 128-bit-key encrypt\/decrypt analogs. (6) Helper adapters: 64-bit-key encrypt\/decrypt via zero-extending to 128-bit key; a 128-bit-block helper that encrypts the lower 64 bits and zero-pads the upper 64. (7) Properties: define properties asserting decrypt(encrypt(m)) == m for 80-bit keys, 128-bit keys, and the 64-bit-key helper. (8) Tests: boolean equalities for known PRESENT test vectors (80-bit and 128-bit), a list collecting them, and a property equal to their conjunction. Provide precise Cryptol type signatures for all definitions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::PRESENT where\n\ntype PrBlockSize = 64\ntype State = [4][4][4]\ntype StdBlockSize = 32\ntype PrKeySize = 80\ntype PrRkeySize = 64\ntype PrKeySize128 = 128\n\nsbox = [0xc, 0x5, 0x6, 0xb, 0x9, 0x0, 0xa, 0xd, 0x3, 0xe, 0xf, 0x8, 0x4, 0x7, 0x1, 0x2]\n\nSbox_inv = [0x5, 0xe, 0xf, 0x8, 0xc, 0x1, 0x2, 0xd, 0xb, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xa]\n\npbox = [0x00, 0x10, 0x20, 0x30, 0x01, 0x11, 0x21, 0x31, 0x02, 0x12, 0x22,\n        0x32, 0x03, 0x13, 0x23, 0x33, 0x04, 0x14, 0x24, 0x34, 0x05, 0x15,\n        0x25, 0x35, 0x06, 0x16, 0x26, 0x36, 0x07, 0x17, 0x27, 0x37, 0x08,\n        0x18, 0x28, 0x38, 0x09, 0x19, 0x29, 0x39, 0x0a, 0x1a, 0x2a, 0x3a,\n        0x0b, 0x1b, 0x2b, 0x3b, 0x0c, 0x1c, 0x2c, 0x3c, 0x0d, 0x1d, 0x2d,\n        0x3d, 0x0e, 0x1e, 0x2e, 0x3e, 0x0f, 0x1f, 0x2f, 0x3f]\n\npbox_inv = [0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c, 0x20, 0x24, 0x28,\n          0x2c, 0x30, 0x34, 0x38, 0x3c, 0x01, 0x05, 0x09, 0x0d, 0x11, 0x15,\n          0x19, 0x1d, 0x21, 0x25, 0x29, 0x2d, 0x31, 0x35, 0x39, 0x3d, 0x02,\n          0x06, 0x0a, 0x0e, 0x12, 0x16, 0x1a, 0x1e, 0x22, 0x26, 0x2a, 0x2e,\n          0x32, 0x36, 0x3a, 0x3e, 0x03, 0x07, 0x0b, 0x0f, 0x13, 0x17, 0x1b,\n          0x1f, 0x23, 0x27, 0x2b, 0x2f, 0x33, 0x37, 0x3b, 0x3f]\n\nupdateKey : [PrKeySize] -> [5] -> _\nupdateKey key i =  (rkey, shift, res,  key'')\n            where rkey = key !![79,78..16]\n                  shift =  (key !! [18,17..0]) # (key !! [79,78..19])\n                  res = sbox@((shift) !! [79,78,77, 76]) # (shift !! [75,74..0])\n                  key'' =  (res !! [79,78..20]) # ((res!![19,18..15])^(i+1)) # (res!![14,13..0])\n\nRoundKeyList : [PrKeySize] -> _\n\nRoundKeyList key = hs\n             where hs = [ (updateKey key 0) ] # [(updateKey (key'.3) i)\n                                                | i<- [1,2..31]\n                                                | key' <- hs\n                                                 ]\n\naddRoundKey : State -> State -> State\naddRoundKey pt key = pt ^ key\n\nSubCell : [4] -> [4]\nSubCell st = sbox@st\n\nSubCells : State -> State\nSubCells st = [ [ SubCell b | b<- row ] | row <- st ]\n\nSubCell_dec : [4] -> [4]\nSubCell_dec st = Sbox_inv@st\n\nSubCells_dec : State -> State\nSubCells_dec st = [ [ SubCell_dec b | b<- row ] | row <- st ]\n\nmsgToState : [PrBlockSize] -> State\nmsgToState msg = split (split msg)\n\nstateToMsg : State -> [PrBlockSize]\nstateToMsg st = join (join st)\n\nSubpLayer: [PrBlockSize] -> [PrBlockSize]\nSubpLayer pt =  hs\n          where hs = [ pt!(pbox_inv ! i) | i <- [0,1..63] ]\n\nSubpLayer_dec: [PrBlockSize] -> [PrBlockSize]\nSubpLayer_dec pt =  hs\n          where hs = [ pt!(pbox ! i) | i <- [0,1..63] ]\n\nroundEncrypt:  (State, State) -> State\nroundEncrypt (pt, key) = msgToState(SubpLayer(stateToMsg(SubCells (addRoundKey pt key))))\n\nroundDecrypt:  (State, State) -> State\nroundDecrypt (pt, key) = SubCells_dec (msgToState(SubpLayer_dec (stateToMsg (addRoundKey pt key))))\n\nPrEncrypt : ([PrKeySize], [PrBlockSize]) -> [PrBlockSize]\nPrEncrypt (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                where hs = [ roundEncrypt (msgToState(pt), msgToState((key'@0).0)) ] # [ roundEncrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [1,2..30]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList key)\n\nPrDecrypt : ([PrKeySize], [PrBlockSize]) -> _\nPrDecrypt (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@0).0))\n                where hs = [ roundDecrypt (msgToState(pt), msgToState((key'@31).0)) ] # [ roundDecrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [30,29..1]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList key)\n\nproperty PresentCorrectnes key m = PrDecrypt( key, PrEncrypt(key, m)) == m\n\nupdateKey_128 : [PrKeySize128] -> [5] -> _\nupdateKey_128 key i =  (rkey, key'')\n            where rkey = key !![127,126..64]\n                  shift =  (key !! [66,65..0]) # (key !! [127,126..67])\n                  res = sbox@((shift) !! [127,126,125, 124]) # sbox@((shift) !! [123,122,121, 120]) # (shift !! [119,118..0])\n                  key'' =  (res !! [127,126..67]) # ((res!![66,65,64,63,62])^(i+1)) # (res!![61,60..0])\n\nRoundKeyList_128: [PrKeySize128] -> _\n\nRoundKeyList_128 key = hs\n             where hs = [ (updateKey_128 key 0)] # [ (updateKey_128 (key'.1) i)\n                                                   | i <- [1,2..31]\n                                                   | key' <- hs ]\n\nPrEncrypt_128 : ([PrKeySize128], [PrBlockSize]) -> _\nPrEncrypt_128 (key , pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                         \/\/stateToMsg(addRoundKey (hs!0) (msgToState(key'@31).0))\n                where hs = [ roundEncrypt (msgToState(pt), msgToState((key'@0).0)) ] # [ roundEncrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [1,2..30]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList_128 key)\n\n\/\/Decryption-128bit\n\nPrDecrypt_128 : ([PrKeySize128], [PrBlockSize]) -> _\nPrDecrypt_128 (key, pt) = stateToMsg(addRoundKey (hs!0) (msgToState(key'@0).0))\n                where hs = [ roundDecrypt (msgToState(pt), msgToState((key'@31).0)) ] # [ roundDecrypt(pT, msgToState((key'@i).0))\n                                                                                       | i<- [30,29..1]\n                                                                                       | pT <- hs ]\n                      key'= (RoundKeyList_128 key)\n\n\/\/Correctness\n\nproperty PresentCorrectnes128 key m = PrDecrypt_128(key, PrEncrypt_128(key, m)) == m\n\n\/\/ Heleper function to perform analaysis\n\nprEncrypt64 : ([PrBlockSize], [PrBlockSize]) -> [PrBlockSize]\nprEncrypt64 (key, pt)  = PrEncrypt_128 (key#zero, pt)\n\nprDecrypt64 : ([PrBlockSize], [PrBlockSize]) -> [PrBlockSize]\nprDecrypt64 (key, ct)  = PrDecrypt_128(key#zero , ct)\n\nproperty PrCorrect64 key m = prDecrypt64 (key, (prEncrypt64(key, m))) == m\n\nprEncrypt128 : ([PrKeySize128], [PrKeySize128]) -> [PrKeySize128]\nprEncrypt128 (key, pt)  = PrEncrypt_128(key, (take`{64} pt)) # zero\n\n\/\/ Testing\ntests = [test80_1, test80_2, test80_3, test80_4, test80_5, test128_1]\nproperty testsPass = and tests\n\/\/keysize: 80bits\n\ntest80_1 =  PrEncrypt (zero, zero) == 0x5579c1387b228445\ntest80_2 =  PrEncrypt (zero, zero) == 0x5579c1387b228445\ntest80_3 =  PrEncrypt (0xffffffffffffffffffff, zero) == 0xe72c46c0f5945049\ntest80_4 =  PrEncrypt (0xffffffffffffffffffff, 0xffffffffffffffff) == 0x3333dcd3213210d2\ntest80_5 =  PrEncrypt (zero, 0xffffffffffffffff) == 0xa112ffc72f68417b\n\n\/\/keysize: 128bits\n\ntest128_1 = PrEncrypt_128 ( 0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0x0e9d28685e671dd6\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Cipher.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named `module_name` that contains the following definitions: a type synonym `type_name` parameterized by two numeric type parameters `key_size` and `block_size`. This type denotes a record interface for a block cipher with exactly two fields: `encrypt_name` and `decrypt_name`. Each field is a curried function that first takes a key as a fixed-size bitvector of length `key_size`, then takes a block as a fixed-size bitvector of length `block_size`, and returns a block of length `block_size`. Use Cryptol\u2019s sequence type notation for fixed widths and function arrows for currying. Both fields must share the same `key_size` and `block_size` parameters, and no other fields or constraints are included. Do not implement any algorithms; only provide the type alias and precise field types."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Cipher where\n\ntype Cipher KeySize BlockSize =\n  { encrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  , decrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/GOST.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::GOST that contains the following definitions: (1) Type aliases: a 64-bit block size, a 32-bit half-block size, and a 256-bit key size. (2) Two S-box constants, each an 8\u00d716 table of 4-bit values. (3) A function to split a 64-bit block into two 32-bit halves. (4) A key-schedule function that splits a 256-bit key into eight 32-bit words. (5) Two round-key schedule functions that produce 32 round subkeys: the encryption schedule repeats the eight words three times in ascending order followed by one reverse-order pass; the decryption schedule uses one ascending pass followed by three reverse-order passes. (6) A round function that adds a 32-bit half and a 32-bit subkey modulo 2^32, splits into eight 4-bit nibbles, substitutes each via the corresponding S-box row, rejoins to 32 bits, and rotates left by 11 bits. (7) A Feistel round function that maps two 32-bit halves and a subkey to a new 64-bit block by outputting the right half concatenated with the left half XOR the round function of the right half. (8) An encryption function that applies 32 Feistel rounds over a 64-bit block using the encryption round-key schedule. (9) A decryption function that applies the inverse Feistel step using the decryption round-key schedule. (10) Define a property that verifies decrypt(encrypt(m, key), key) equals m for 256-bit keys and 64-bit blocks. (11) Helper functions that encrypt and decrypt using 64-bit keys by zero-padding the key to 256 bits. (12) Define a property that verifies the 64-bit-key helper decrypt(encrypt(m, key), key) equals m. (13) A helper that takes a 256-bit plaintext and key, encrypts only the lower 64 bits, and pads the result back to 256 bits with zeros."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::GOST where\n\ntype BlockSize = 64\ntype StdBlockSize = 32\ntype KeySize = 256\n\nsbox = [\n    [0x4, 0xa, 0x9, 0x2, 0xd, 0x8, 0x0, 0xe, 0x6, 0xb, 0x1, 0xc, 0x7, 0xf, 0x5, 0x3],\n    [0xe, 0xb, 0x4, 0xc, 0x6, 0xd, 0xf, 0xa, 0x2, 0x3, 0x8, 0x1, 0x0, 0x7, 0x5, 0x9],\n    [0x5, 0x8, 0x1, 0xd, 0xa, 0x3, 0x4, 0x2, 0xe, 0xf, 0xc, 0x7, 0x6, 0x0, 0x9, 0xb],\n    [0x7, 0xd, 0xa, 0x1, 0x0, 0x8, 0x9, 0xf, 0xe, 0x4, 0x6, 0xc, 0xb, 0x2, 0x5, 0x3],\n    [0x6, 0xc, 0x7, 0x1, 0x5, 0xf, 0xd, 0x8, 0x4, 0xa, 0x9, 0xe, 0x0, 0x3, 0xb, 0x2],\n    [0x4, 0xb, 0xa, 0x0, 0x7, 0x2, 0x1, 0xd, 0x3, 0x6, 0x8, 0x5, 0x9, 0xc, 0xf, 0xe],\n    [0xd, 0xb, 0x4, 0x1, 0x3, 0xf, 0x5, 0x9, 0x0, 0xa, 0xe, 0x7, 0x6, 0x8, 0x2, 0xc],\n    [0x1, 0xf, 0xd, 0x0, 0x5, 0x7, 0xa, 0x4, 0x9, 0x2, 0x3, 0xe, 0x6, 0xb, 0x8, 0xc]\n    ]\n\nsbox_rec = [\n         [0xc, 0x4, 0x6, 0x2, 0xa, 0x5, 0xb, 0x9, 0xe, 0x8, 0xd, 0x7, 0x0, 0x3, 0xf, 0x1],\n         [0x6, 0x8, 0x2, 0x3, 0x9, 0xa, 0x5, 0xc, 0x1, 0xe, 0x4, 0x7, 0xb, 0xd, 0x0, 0xf],\n         [0xb, 0x3, 0x5, 0x8, 0x2, 0xf, 0xa, 0xd, 0xe, 0x1, 0x7, 0x4, 0xc, 0x9, 0x6, 0x0],\n         [0xc, 0x8, 0x2, 0x1, 0xd, 0x4, 0xf, 0x6, 0x7, 0x0, 0xa, 0x5, 0x3, 0xe, 0x9, 0xb],\n         [0x7, 0xf, 0x5, 0xa, 0x8, 0x1, 0x6, 0xd, 0x0, 0x9, 0x3, 0xe, 0xb, 0x4, 0x2, 0xc],\n         [0x5, 0xd, 0xf, 0x6, 0x9, 0x2, 0xc, 0xa, 0xb, 0x7, 0x8, 0x1, 0x4, 0x3, 0xe, 0x0],\n         [0x8, 0xe, 0x2, 0x5, 0x6, 0x9, 0x1, 0xc, 0xf, 0x4, 0xb, 0x0, 0xd, 0xa, 0x3, 0x7],\n         [0x1, 0x7, 0xe, 0xd, 0x0, 0x5, 0x8, 0x3, 0x4, 0xf, 0xa, 0x6, 0x9, 0xc, 0xb, 0x2]\n         ]\n\nsplitPt: [BlockSize] -> [2][StdBlockSize]\nsplitPt pt = split pt:[2][StdBlockSize]\n\nkeySchedule : [KeySize] -> [8][StdBlockSize]\nkeySchedule key = split key : [8][StdBlockSize]\n\nroundKey:[KeySize] ->  _\nroundKey key = [ rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0\n                 ]\n         where rk = (keySchedule key)\nroundKey':[KeySize] ->  _\nroundKey' key = [ rk@0, rk@1, rk@2, rk@3, rk@4, rk@5, rk@6, rk@7,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0,\n                 rk@7, rk@6, rk@5, rk@4, rk@3, rk@2, rk@1, rk@0\n                 ]\n         where rk = (keySchedule key)\n\nroundFun : [StdBlockSize]-> [StdBlockSize] -> [StdBlockSize]\nroundFun subpt subkey = roundRes\n            where res = subpt + subkey\n                  splitRes = split res: [8][4]\n                  subSboxRes = [ (sbox@i)@(splitRes@i) | i<- [0..7] ]\n                  roundRes = (join subSboxRes) <<< 11\n\nroundEncryption: [StdBlockSize] -> [StdBlockSize] -> [StdBlockSize] -> [BlockSize]\nroundEncryption lpt rpt rkey =  rpt # (lpt ^ (roundFun rpt rkey))\n\ngostEncrypt: ([KeySize], [BlockSize]) ->  [BlockSize]\ngostEncrypt (key, pt) = hs'\n            where hs = [(roundEncryption left right (round_key@0))]  # [ (roundEncryption ((splitPt pT)@0) ((splitPt pT)@1) (round_key@i))\n                                                  | i <- [1,2..31]\n                                                  | pT <- hs\n                                                  ]\n                  splt_pt = (splitPt pt)\n                  left = splt_pt@0\n                  right = splt_pt@1\n                  round_key = (roundKey key)\n                  hs' = hs!0\n\nroundDecryption: [StdBlockSize] -> [StdBlockSize] -> [StdBlockSize] -> [BlockSize]\nroundDecryption lpt rpt rkey =  (rpt ^ (roundFun lpt rkey)) # lpt\n\ngostDecrypt: ([KeySize], [BlockSize]) ->  [BlockSize]\ngostDecrypt (key, ct) = hs'\n            where hs = [(roundDecryption left right (round_key@0))]  # [ (roundDecryption ((splitPt pT)@0) ((splitPt pT)@1) (round_key@i))\n                                                  | i <- [1,2..31]\n                                                  | pT <- hs\n                                                  ]\n                  splt_pt = (splitPt ct)\n                  left = splt_pt@0\n                  right = splt_pt@1\n                  round_key = (roundKey' key)\n                  hs' = hs!0\n\n\/\/ Correctness\n\nproperty gostCorrect key m = gostDecrypt(key, gostEncrypt(key, m)) == m\n\n\/\/ Helper functions to perform analysis\n\ngostEncrypt64: ([BlockSize],[BlockSize]) -> [BlockSize]\ngostEncrypt64 (pt, key)  = gostEncrypt(key', pt)\n             where key' = key # zero\n\ngostDecrypt64 : ([BlockSize], [BlockSize]) -> [BlockSize]\ngostDecrypt64 (ct, key)  = gostDecrypt(key', ct)\n             where key' = key #zero\n\nproperty gostCorrect64 key m = gostDecrypt64( key, gostEncrypt64(key, m)) == m\n\n\/\/ To analyze the schemes from 5 through 20, we take |mi| = k  where k > n (block size)\n\ngostEncrypt256 : ([KeySize], [KeySize]) -> [KeySize]\ngostEncrypt256 (pt, key) = gostEncrypt(key, (take`{64} pt))# zero\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Threefish.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Threefish that contains the following definitions and specifications, with precise Cryptol type signatures and stated constraints, but no implementations: (1) A 6\u2011bit type alias for rotation amounts. (2) Byte\/bit conversion helpers: a function that joins reversed n bytes into an 8\u00b7n\u2011bit vector, its inverse that splits an 8\u00b7n\u2011bit vector into n bytes in reverse order, plus functions to convert between sequences of bytes and sequences of 64\u2011bit words by grouping 8 bytes per word. (3) The MIX function over a pair of 64\u2011bit words parameterized by a rotation amount (add, rotate, xor), and its inverse. Lift these to mixing over 2\u00b7w words using a length\u2011w rotation schedule. (4) Word permutations for widths 4, 8, and 16, and their inverses. (5) Rotation constant tables for widths 4, 8, and 16: each is an array of 8 rows, where each row provides Nw\/2 rotation amounts. (6) A key schedule over Nw 64\u2011bit words and a 2\u2011word tweak producing r subkeys of Nw words. Include the parity key word computed as the xor of all key words with a fixed 64\u2011bit constant, a 3\u2011word tweak extension with xor, subkey selection by word\u2011rotating key\/tweak by a 64\u2011bit counter, and appending the counter as the last word. (7) Constants for the 64\u2011bit key\u2011parity value. (8) Word\u2011level encrypt\u2019\/decrypt\u2019 with parameters Nr, Nw, rotation table, and permutation; constraints: fin Nr, fin Nw, Nw \u2265 3, Nw even; Nr multiple of 4 for encryption and of 8 for decryption. Specify round structure: add subkey every 4 rounds, per\u2011round mixing using cyclic rotation rows, and permutation; decryption reverses order and uses inverse permutation\/mix. (9) Byte\u2011level wrappers encrypt\/decrypt that map between bytes and words. (10) Specialized enc256\/enc512\/enc1024 and dec256\/dec512\/dec1024 with appropriate byte sizes, tweaks of 16 bytes, and round counts. (11) Properties asserting inversion of MIX and the three permutations, and properties that check the specialized encryptions against published test vectors."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Threefish where\n\nToInt : {n} (fin n) => [n][8] -> [8 * n]\nToInt bytes = join (reverse bytes)\n\nToBytes : {n} (fin n) => [8 * n] -> [n][8]\nToBytes bits = reverse (split`{each = 8} bits)\n\nBytesToWords : {n} (fin n) => [8 * n][8] -> [n][64]\nBytesToWords bytes = [ ToInt bs | bs <- split`{each = 8} bytes ]\n\nWordsToBytes : {n} (fin n) => [n][64] -> [8 * n][8]\nWordsToBytes words = join [ ToBytes w | w <- words ]\n\nenc256 : [32][8] -> [16][8] -> [32][8] -> [32][8]\nenc256 = encrypt`{Nr=72} R4 pi4\n\nenc512 : [64][8] -> [16][8] -> [64][8] -> [64][8]\nenc512 = encrypt`{Nr=72} R8 pi8\n\nenc1024 : [128][8] -> [16][8] -> [128][8] -> [128][8]\nenc1024 = encrypt`{Nr=80} R16 pi16\n\nencrypt :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 4 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot ->\n  ([Nw][64] -> [Nw][64]) ->\n  [8 * Nw][8] -> [16][8] -> [8 * Nw][8] -> [8 * Nw][8]\nencrypt R pi key tweak plaintext = WordsToBytes (encrypt'`{Nr=Nr} R pi K T P)\n  where\n    K = BytesToWords key\n    T = BytesToWords tweak\n    P = BytesToWords plaintext\n\n\/\/ Encryption in terms of 64-bit words.\nencrypt' :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 4 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot -> ([Nw][64] -> [Nw][64]) ->\n  [Nw][64] -> [2][64] -> [Nw][64] -> [Nw][64]\nencrypt' R pi key tweak plaintext = last v + last ks\n  where\n    ks : [Nr\/4 + 1][Nw][64]\n    ks = KeySchedule key tweak\n\n    \/\/ Add a subkey from the key schedule once every four rounds.\n    e : [Nr][Nw][64]\n    e = [ vd + kd\n        | vd <- v\n        | subkey <- take`{Nr\/4} ks, kd <- [subkey, zero, zero, zero] ]\n\n    \/\/ Cycle over the eight lists of rotation amounts for the mixing function.\n    f : [Nr][Nw][64]\n    f = [ mixing Rd ed | Rd <- join (repeat`{inf} R) | ed <- e ]\n\n    \/\/ Permute the words every round.\n    v : [Nr+1][Nw][64]\n    v = [plaintext] # [ pi fd | fd <- f ]\n\n\/\/ One round of mixing.\nmixing : {w} (fin w) => [w]Rot -> [2 * w][64] -> [2 * w][64]\nmixing Rd e = join [ MIX R x | R <- Rd | x <- split`{each=2} e ]\n\n\/\/ Table 3: Values for the word permutation \u03c0(i).\n\npi4 : [4][64] -> [4][64]\npi4 xs = xs @@ [0, 3, 2, 1:[2]]\n\npi8 : [8][64] -> [8][64]\npi8 xs = xs @@ [2, 1, 4, 7, 6, 5, 0, 3:[3]]\n\npi16 : [16][64] -> [16][64]\npi16 xs = xs @@ [0, 9, 2, 13, 6, 11, 4, 15, 10, 7, 12, 3, 14, 5, 8, 1:[4]]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.1: MIX Functions\n\n\/\/ Rotation amount for a 64-bit word\ntype Rot = [6]\n\nMIX : Rot -> [2][64] -> [2][64]\nMIX R [x0, x1] = [y0, y1]\n  where\n    y0 = x0 + x1\n    y1 = (x1 <<< R) ^ y0\n\n\/\/ Table 4: Rotation constants\n\nR4 : [8][2]Rot\nR4 =\n  [[14, 16],\n   [52, 57],\n   [23, 40],\n   [ 5, 37],\n   [25, 33],\n   [46, 12],\n   [58, 22],\n   [32, 32]]\n\nR8 : [8][4]Rot\nR8 =\n  [[46, 36, 19, 37],\n   [33, 27, 14, 42],\n   [17, 49, 36, 39],\n   [44,  9, 54, 56],\n   [39, 30, 34, 24],\n   [13, 50, 10, 17],\n   [25, 29, 39, 43],\n   [ 8, 35, 56, 22]]\n\nR16 : [8][8]Rot\nR16 =\n  [[24, 13,  8, 47,  8, 17, 22, 37],\n   [38, 19, 10, 55, 49, 18, 23, 52],\n   [33,  4, 51, 13, 34, 41, 59, 17],\n   [ 5, 20, 48, 41, 47, 28, 16, 25],\n   [41,  9, 37, 31, 12, 47, 44, 30],\n   [16, 34, 56, 51,  4, 53, 42, 41],\n   [31, 44, 47, 46, 19, 42, 44, 25],\n   [ 9, 48, 35, 52, 23, 31, 37, 20]]\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.2: The Key Schedule\n\n\/\/ \"The key schedule turns the key and tweak into a sequence of Nr\/4+1\n\/\/ subkeys, each of which consists of Nw words.\"\n\nKeySchedule :\n  {Nw, r} (fin Nw, fin r, Nw >= 3) =>\n  [Nw][64] -> [2][64] -> [r][Nw][64]\nKeySchedule k [t0,t1] = take`{r} [ subkey s | s <- [0...] ]\n  where\n    k' = k # [foldl (^) C240 k]\n    t' = [t0, t1, t0 ^ t1]\n\n    subkey : [64] -> [Nw][64]\n    subkey s = take`{Nw} (k' <<< s) + tweak s\n\n    tweak : [64] -> [Nw][64]\n    tweak s = zero # take`{2} (t' <<< s) # [s]\n\nC240 : [64]\nC240 = 0x1BD11BDAA9FC1A22\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Section 3.3.3: Decryption\n\n\/\/ \"The Threefish decryption operation is the obvious inverse of the\n\/\/ encryption operation. Subkeys are used in reverse order and each\n\/\/ round consists of applying the inverse word permutation followed by\n\/\/ the inverse MIX functions.\"\n\ndec256 : [32][8] -> [16][8] -> [32][8] -> [32][8]\ndec256 = decrypt`{Nr=72} R4 pi4'\n\ndec512 : [64][8] -> [16][8] -> [64][8] -> [64][8]\ndec512 = decrypt`{Nr=72} R8 pi8'\n\ndec1024 : [128][8] -> [16][8] -> [128][8] -> [128][8]\ndec1024 = decrypt`{Nr=80} R16 pi16'\n\ndecrypt :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 8 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot ->\n  ([Nw][64] -> [Nw][64]) ->\n  [8 * Nw][8] -> [16][8] -> [8 * Nw][8] -> [8 * Nw][8]\ndecrypt R pi key tweak ciphertext = WordsToBytes (decrypt'`{Nr=Nr} R pi K T P)\n  where\n    K = BytesToWords key\n    T = BytesToWords tweak\n    P = BytesToWords ciphertext\n\n\/\/ Decryption in terms of 64-bit words.\ndecrypt' :\n  {Nr, Nw} (fin Nr, fin Nw, Nw >= 3, Nr % 8 == 0, Nw % 2 == 0) =>\n  [8][Nw\/2]Rot -> ([Nw][64] -> [Nw][64]) ->\n  [Nw][64] -> [2][64] -> [Nw][64] -> [Nw][64]\ndecrypt' R pi key tweak ciphertext = last e - last ks\n  where\n    ks : [Nr\/4 + 1][Nw][64]\n    ks = reverse (KeySchedule key tweak)\n\n    \/\/ Add a subkey from the key schedule once every four rounds.\n    v : [Nr][Nw][64]\n    v = [ ed - kd\n        | ed <- e\n        | subkey <- take`{Nr\/4} ks, kd <- [subkey, zero, zero, zero] ]\n\n    \/\/ Cycle over the eight lists of rotation amounts for the mixing function.\n    e : [Nr+1][Nw][64]\n    e = [ciphertext] # [ mixing' Rd fd | Rd <- reverse (join (repeat`{Nr\/8} R)) | fd <- f ]\n\n        f : [Nr][Nw][64]\n    f = [ pi vd | vd <- v ]\n\nMIX' : Rot -> [2][64] -> [2][64]\nMIX' R [y0, y1] = [x0, x1]\n  where\n    x0 = y0 - x1\n    x1 = (y0 ^ y1) >>> R\n\nmixing' : {w} (fin w) => [w]Rot -> [2 * w][64] -> [2 * w][64]\nmixing' Rd e = join [ MIX' R x | R <- Rd | x <- split`{each=2} e ]\n\n\/\/ Inverse permutations.\n\npi4' : [4][64] -> [4][64]\npi4' xs = xs @@ [0, 3, 2, 1:[2]]\n\npi8' : [8][64] -> [8][64]\npi8' xs = xs @@ [6, 1, 0, 7, 2, 5, 4, 3:[3]]\n\npi16' : [16][64] -> [16][64]\npi16' xs = xs @@ [0, 15, 2, 11, 6, 13, 4, 9, 14, 1, 8, 5, 10, 3, 12, 7:[4]]\n\nproperty MIX_inv R x = MIX' R (MIX R x) == x\nproperty pi4_inv xs = pi4' (pi4 xs) == xs\nproperty pi8_inv xs = pi8' (pi8 xs) == xs\nproperty pi16_inv xs = pi16' (pi16 xs) == xs\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Test Vectors\n\n\/\/ https:\/\/sites.google.com\/site\/bartoszmalkowski\/threefish\n\nproperty test256a =\n  enc256 zero zero zero ==\n  split 0x84da2a1f8beaee947066ae3e3103f1ad536db1f4a1192495116b9f3ce6133fd8\n\nproperty test256b =\n  enc256\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xFFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0)\n  ==\n  split 0xe0d091ff0eea8fdfc98192e62ed80ad59d865d08588df476657056b5955e97df\n\nproperty test512a =\n  enc512 zero zero zero ==\n  split 0xb1a2bbc6ef6025bc40eb3822161f36e375d1bb0aee3186fbd19e47c5d479947b #\n  split 0x7bc2f8586e35f0cff7e7f03084b0b7b1f1ab3961a580a3e97eb41ea14a6d7bbe\n\nproperty test512b =\n  enc512\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f #\n     split 0x303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xfffefdfcfbfaf9f8f7f6f5f4f3f2f1f0efeeedecebeae9e8e7e6e5e4e3e2e1e0 #\n     split 0xdfdedddcdbdad9d8d7d6d5d4d3d2d1d0cfcecdcccbcac9c8c7c6c5c4c3c2c1c0)\n  ==\n  split 0xe304439626d45a2cb401cad8d636249a6338330eb06d45dd8b36b90e97254779 #\n  split 0x272a0a8d99463504784420ea18c9a725af11dffea10162348927673d5c1caf3d\n\nproperty test1024a =\n  enc1024 zero zero zero ==\n  split 0xf05c3d0a3d05b304f785ddc7d1e036015c8aa76e2f217b06c6e1544c0bc1a90d #\n  split 0xf0accb9473c24e0fd54fea68057f43329cb454761d6df5cf7b2e9b3614fbd5a2 #\n  split 0x0b2e4760b40603540d82eabc5482c171c832afbe68406bc39500367a592943fa #\n  split 0x9a5b4a43286ca3c4cf46104b443143d560a4b230488311df4feef7e1dfe8391e\n\nproperty test1024b =\n  enc1024\n    (split 0x101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f #\n     split 0x303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f #\n     split 0x505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f #\n     split 0x707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f)\n    (split 0x000102030405060708090a0b0c0d0e0f)\n    (split 0xfffefdfcfbfaf9f8f7f6f5f4f3f2f1f0efeeedecebeae9e8e7e6e5e4e3e2e1e0 #\n     split 0xdfdedddcdbdad9d8d7d6d5d4d3d2d1d0cfcecdcccbcac9c8c7c6c5c4c3c2c1c0 #\n     split 0xbfbebdbcbbbab9b8b7b6b5b4b3b2b1b0afaeadacabaaa9a8a7a6a5a4a3a2a1a0 #\n     split 0x9f9e9d9c9b9a999897969594939291908f8e8d8c8b8a89888786858483828180)\n  ==\n  split 0xa6654ddbd73cc3b05dd777105aa849bce49372eaaffc5568d254771bab85531c #\n  split 0x94f780e7ffaae430d5d8af8c70eebbe1760f3b42b737a89cb363490d670314bd #\n  split 0x8aa41ee63c2e1f45fbd477922f8360b388d6125ea6c7af0ad7056d01796e90c8 #\n  split 0x3313f4150a5716b30ed5f569288ae974ce2b4347926fce57de44512177dd7cde\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/SHACAL.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::SHACAL that contains the following definitions:\n- Type synonyms for block and key sizes: SHACAL-1 block = 160 bits, SHACAL-1 key = 512 bits; SHACAL-2 block = 256 bits, SHACAL-2 key = 512 bits.\n- Function shacal1Encrypt: takes a 512-bit key and a 160-bit block, returns a 160-bit block; split the block into five 32-bit words and the key into sixteen 32-bit words, run the SHACAL-1 round function, then rejoin to 160 bits.\n- Function shacal1Encrypt160: takes a 160-bit key and 160-bit block, returns 160 bits; zero-extend the key to 512 bits and call the SHACAL-1 encryptor.\n- Function shacal1Encrypt512: takes a 512-bit key and 512-bit block, returns 512 bits; encrypt only the most significant 160 bits of the block and zero-extend the result to 512 bits.\n- Function shacal2Encrypt: takes a 512-bit key and a 256-bit block, returns 256 bits; split the block into eight 32-bit words and the key into sixteen 32-bit words, and use the SHA-256 internal block-processing routine for one block.\n- Function shacal2Encrypt256 and shacal2Encrypt512 with analogous zero-extension and truncation behavior as for SHACAL-1 (256-bit and 512-bit block interfaces, respectively).\n- Function f: round Boolean function taking an 8-bit round index and three 32-bit words, returning a 32-bit word; implement SHA-1 style behaviors for rounds 0\u201319, 20\u201339, 40\u201359, and 60\u201379; error on out-of-range indices.\n- Constant Ks: an 80-element vector of 32-bit round constants (four values repeated for the four 20-round segments).\n- Function block: SHACAL-1 core that takes five 32-bit chaining values and sixteen 32-bit message words, constructs an 80-word schedule via XORs and a 1-bit left rotate, performs 80 rounds updating five 32-bit working registers, and outputs the five updated values added to the inputs.\n- Constants tVector1 and tVector2: lists of test-vector triples (key, plaintext, ciphertext) sized appropriately for SHACAL-1 and SHACAL-2.\n- Properties shacal1TestsPass and shacal2TestsPass: each asserts that encrypting every test-vector pair produces the corresponding expected ciphertext.\nAlso import the internal SHA-256 module required for the SHACAL-2 block processing."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::SHACAL where\n\nimport Primitive::Keyless::Hash::SHA2Internal::SHA256\n\ntype shacal1Block = 160\ntype shacal1Key = 512\n\nshacal1Encrypt : ([shacal1Key], [shacal1Block]) -> [shacal1Block]\nshacal1Encrypt (key, pt) = join (block (pt', key'))\n              where pt' = split pt : [5][32]\n                    key' = split key : [16][32]\n\nshacal1Encrypt160 : ([shacal1Block], [shacal1Block]) -> [shacal1Block]\nshacal1Encrypt160 (key, pt) = shacal1Encrypt(key#zero, pt)\n\nshacal1Encrypt512 : ([shacal1Key], [shacal1Key]) -> [shacal1Key]\nshacal1Encrypt512 (key, pt) = shacal1Encrypt(key, (take`{160} pt))#zero\n\nproperty shacal1TestsPass = and [shacal1Encrypt(key, plain) == cipher | (key, plain, cipher) <- tVector1]\n\ntVector1 = [ (0x8#zero, zero, 0x0FFD8D43B4E33C7C53461BD10F27A5461050D90D)\n           , (0x4#zero, zero, 0xB9C60AA972B49CA04D5A0D9B9E08B2A2BA138C93)\n           , (0x2#zero, zero, 0x3FA618501A3D10E3CAEB3CA06B8B47A16F8E3D9E)\n           , (0x1#zero, zero, 0x2B4AFB3268C32F86B89BB745EC85F24702B38498)\n           , (0x08#zero, zero, 0x58E782A1D205E53DD2901F0F302F8894D0A3B05B)\n           , (0x04#zero, zero, 0xB345AD4DC877D0BFCF760EE25056D21C7DB2F868)\n           , (0x02#zero, zero, 0x334C5A595919EA33E5EB467657AAE3ED825207D3)\n           , (0x01#zero, zero, 0x5F686F27819DF939F877099A222D01EE955F6E66)\n           , (0x008#zero, zero, 0x62BE68D266A28F7E6B44A83E62A476FFD627AF0E)\n           , (0x004#zero, zero, 0x2D5265CD2E72B52B6477F341816F2BB554428BC5)]\n\ntype shacal2Block = 256\ntype shacal2Key = 512\n\nshacal2Encrypt : ([shacal2Key], [shacal2Block]) -> [shacal2Block]\nshacal2Encrypt (key, pt) = join (processBlock_Common pt' key')\n              where pt' = split pt : [8][32]\n                    key' = split key : [16][32]\n\nshacal2Encrypt256 : ([shacal2Block], [shacal2Block]) -> [shacal2Block]\nshacal2Encrypt256 (key, pt) = shacal2Encrypt(key#zero, pt)\n\nshacal2Encrypt512 : ([shacal2Key], [shacal2Key]) -> [shacal2Key]\nshacal2Encrypt512 (key, pt) = shacal2Encrypt(key, (take`{256} pt))#zero\n\nproperty shacal2TestsPass = and [shacal2Encrypt(key, plain) == cipher | (key, plain, cipher) <- tVector2]\n\ntVector2 = [ (0x8#zero, zero, 0x361AB6322FA9E7A7BB23818D839E01BDDAFDF47305426EDD297AEDB9F6202BAE)\n           , (0x4#zero, zero, 0xF3BAF53E5301E08813F8BE6F651BB19E9722151FF15063BA42A6FEF7CF3BF3D7)\n           , (0x1#zero, zero, 0xAE70E355CB7E26FF12421F46CDAD5CB98367FE0E86CC234EDF97481765CD1AD9)\n           , (0x08#zero, zero, 0x00CECD0B01311F881018E7A20BCE169766C089D91FF161346C4E1BD122EA199F)\n           , (0x08#zero, zero, 0x00CECD0B01311F881018E7A20BCE169766C089D91FF161346C4E1BD122EA199F)\n           , (0x04#zero, zero, 0x47A879CB6785AD37119C450CD50E9A36FE318FA8E7B6C6E0FA963430122F33CD)\n           , (0x02#zero, zero, 0xCF3D53B9F9F7CA2C66738A4C09CEA9212C056F525BDC26F263FBA1B482EDF503)\n           , (0x01#zero, zero, 0xA274D404E83E82817389A2CB7B528C792A0E80DE879A5A67DE633B0B7DD57B7B)\n           , (0x008#zero, zero, 0x09B3AB9332301D4E3C239D192A4221AFD43F6829A705D396FA96BDE1E716BC38)\n           , (0x004#zero, zero, 0xD3B9AB867A6868C4400D200979055C8F9E3A6BFB40D1F9E376B9EC89223D7050)]\n\nf : ([8], [32], [32], [32]) -> [32]\nf (t, x, y, z) =\n       if (0 <= t)  \/\\ (t <= 19) then (x && y) ^ (~x && z)\n        | (20 <= t) \/\\ (t <= 39) then x ^ y ^ z\n        | (40 <= t) \/\\ (t <= 59) then (x && y) ^ (x && z) ^ (y && z)\n        | (60 <= t) \/\\ (t <= 79) then x ^ y ^ z\n        else error \"f: t out of range\"\n\nKs : [80][32]\nKs = [ 0x5a827999 | t <- [0..19]  ]\n   # [ 0x6ed9eba1 | t <- [20..39] ]\n   # [ 0x8f1bbcdc | t <- [40..59] ]\n   # [ 0xca62c1d6 | t <- [60..79] ]\n\nblock : ([5][32], [16][32]) -> [5][32]\nblock ([H0, H1, H2, H3, H4], M) =\n [(H0+As@80), (H1+Bs@80), (H2+Cs@80), (H3+Ds@80), (H4+Es@80)]\n  where\n    Ws : [80][32]\n    Ws = M # [ (W3 ^ W8 ^ W14 ^ W16) <<< 1\n             | W16 <- drop`{16 - 16} Ws\n             | W14 <- drop`{16 - 14} Ws\n             | W8  <- drop`{16 - 8}  Ws\n             | W3  <- drop`{16 - 3}  Ws\n             | t <- [16..79]\n             ]\n    As = [H0] # TEMP\n    Bs = [H1] # As\n    Cs = [H2] # [ B <<< 30 | B <- Bs ]\n    Ds = [H3] # Cs\n    Es = [H4] # Ds\n    TEMP : [80][32]\n    TEMP = [ (A <<< 5) + f(t, B, C, D) + E + W + K\n           | A <- As | B <- Bs | C <- Cs | D <- Ds | E <- Es\n           | W <- Ws | K <- Ks\n           | t <- [0..79]\n           ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/CipherInterface.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define an interface module named Primitive::Symmetric::Cipher::Block::CipherInterface that contains the following declarations: (1) two abstract numeric type parameters KeySize and BlockSize (both of kind representing natural number sizes), (2) a constraint asserting that both sizes are finite, and (3) two functions, encrypt and decrypt, each taking a key of length KeySize and a block of length BlockSize and returning a block of length BlockSize. Provide only the type declarations\/signatures (no implementations). Clearly state the kinds, the finiteness constraint on both size parameters, and the exact input\/output shapes for the two functions as sequences of bits sized by those parameters."},{"role":"assistant","content":"```cryptol\ninterface module Primitive::Symmetric::Cipher::Block::CipherInterface where\n  type KeySize : #\n  type BlockSize : #\n  type constraint (fin BlockSize, fin KeySize)\n  encrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n  decrypt : [KeySize] -> [BlockSize] -> [BlockSize]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/KATAN.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::KATAN that contains: (1) size type synonyms for 32, 48, 64-bit blocks, 80-bit key, round counter width, L1\/L2 state widths, and tap-set sizes; (2) tap index vectors for both state halves; (3) a function that splits a 64-bit state into two parts of sizes 25 and 39; (4) round-constant bits indexed by round; (5) polymorphic key-schedule steppers that append 1, 10, and 100 derived bits (constrained to finite sequence lengths), and a function producing a 508-bit keystream; (6) KATAN feedback-bit functions for each state half that XOR\/AND selected taps, include the round constant, and select keystream bits at even\/odd round positions; (7) shift-and-append helpers for each half and an LFSR update that applies one, two, or three successive updates depending on the L1 width; (8) an encryption function that iterates the update for 254 rounds over a 64-bit block with an 80-bit key, plus wrappers that pad\/trim for 64-bit and 80-bit experiments; (9) decryption counterparts (feedback, single-step shifts, update) and a decryption function that iterates rounds in reverse; (10) define a property that checks KATAN correctness by asserting encrypt(key, decrypt(key, m)) equals m; (11) KTANTAN index tables for key-bit selection, KTANTAN feedback-bit functions using those tables, analogous shift\/apply and update, encryption and decryption, and define a property that checks KTANTAN correctness by asserting decrypt(key, encrypt(key, m)) equals m; (12) boolean constants for two known-answer tests for each cipher (all-ones key vs zero plaintext, and zero key vs all-ones plaintext), a list collecting them, and define a property that all tests hold."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::KATAN where\n\ntype Katan32 = 32\ntype Katan48 = 48\ntype Katan64 = 64\ntype KatanBlock = Katan64\ntype KatanKeySize = 80\ntype Round = 8\ntype xSize = 5\ntype ySize = 6\n\ntype Nr = 254\n\ntype L1Size = 25\ntype L2Size = 39\n\nx = [24, 15, 20, 11, 9]\ny = [38, 25, 33, 21, 14, 9]\n\nsplitBlock: [KatanBlock] -> ([L1Size], [L2Size])\n\nsplitBlock pt = (l1, l2)\n            where l1 = take`{L1Size} pt\n                  l2 = drop`{L1Size} pt\n\niR: [1][Nr]\n\niR = [0b11111110001101010101111011001100101001000100011000111100001000010100000111110011111101010001010100110000110011101111101110100101011010011100110110001011101101111001011011010111001001001101000111000100111101000011101011000001011001000000110111000000010010]\n\nkS: {a} (fin a) => ([a], [12]) -> [a+1]\nkS (key, i ) = key # [((key@(i-80))^ (key@(i-61)) ^ (key@(i-50)) ^ (key@(i-13)))]\n\nkS10 : {a} (fin a) => ([a], [12]) -> [a + 10]\nkS10 (key, i) = key9\n           where key0 = kS (key, i)\n                 key1 = kS (key0, i+1)\n                 key2 = kS (key1, i+2)\n                 key3 = kS (key2, i+3)\n                 key4 = kS (key3, i+4)\n                 key5 = kS (key4, i+5)\n                 key6 = kS (key5, i+6)\n                 key7 = kS (key6, i+7)\n                 key8 = kS (key7, i+8)\n                 key9 = kS (key8, i+9)\n\nkS100 : {a} (fin a) => ([a], [12]) -> [a + 100]\nkS100 (key, i) = key9\n            where key0 = kS10 (key, i)\n                  key1 = kS10 (key0, i+10)\n                  key2 = kS10 (key1, i+20)\n                  key3 = kS10 (key2, i+30)\n                  key4 = kS10 (key3, i+40)\n                  key5 = kS10 (key4, i+50)\n                  key6 = kS10 (key5, i+60)\n                  key7 = kS10 (key6, i+70)\n                  key8 = kS10 (key7, i+80)\n                  key9 = kS10 (key8, i+90)\n\nkeySchedule' :[80] -> [508]\nkeySchedule' key = key13\n            where key0 = kS100 (key, 80)\n                  key1= kS100 (key0, 180)\n                  key2 = kS100 (key1, 280)\n                  key3 = kS100 (key2, 380)\n                  key4 = kS10(key3, 480)\n                  key5 = kS10 (key4, 490)\n                  key6 = kS (key5, 500)\n                  key7 = kS (key6, 501)\n                  key8 = kS (key7, 502)\n                  key9 = kS (key8, 503)\n                  key10 = kS (key9, 504)\n                  key11 = kS (key10, 505)\n                  key12 = kS (key11, 506)\n                  key13 = kS (key12, 507)\n\nfunFa : [L1Size]-> [xSize][xSize] -> [508] -> [Round] -> Bit\n\nfunFa L1 x k i = (L1!(x@0)) ^ (L1!(x@1)) ^ ((L1!(x@2)) && (L1!(x@3))) ^ ((L1!(x@4)) && ((iR@0)@i)) ^ (k@(pmult (2:[2]) i))\n\nfunFb : [L2Size]-> [ySize][ySize] -> [508] -> [Round] -> Bit\n\nfunFb L2 y k i = (L2!(y@0)) ^ (L2!(y@1)) ^ (L2!(y@2) && L2!(y@3)) ^ (L2!(y@4) && L2!(y@5)) ^ (k@((pmult (2:[2]) i)+1))\n\naply_fb : [L1Size] -> [L2Size]->  [ySize][ySize] ->[KatanKeySize] -> [Round] -> [L1Size]\naply_fb l1 l2 y key i = (l1 !! [(L1Size-2),(L1Size-3)..0]) # [(funFb l2 y (keySchedule' key) i)]\n\naply_fa : [L1Size] -> [L2Size]-> [xSize][xSize]->[KatanKeySize] -> [Round] -> [L2Size]\naply_fa l1 l2 x key i = (l2 !! [(L2Size-2),(L2Size-3)..0]) # [(funFa l1 x (keySchedule' key) i)]\n\nupdateLfsr : [L1Size] -> [L2Size]-> [xSize][xSize] -> [ySize][ySize]->[KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\nupdateLfsr l1 l2 x y key i = if `(L1Size) == 13\n                             then (l1', l2')\n                             else if `(L1Size) == 19\n                                  then (l1'', l2'')\n                                  else (l1''', l2''')\n\n                 where pt = (aply_fb l1 l2 y key i) # (aply_fa l1 l2 x key i)\n                       l1' = (splitBlock pt).0\n                       l2' = (splitBlock pt).1\n                       pt' = (aply_fb l1' l2' y key i) # (aply_fa l1' l2' x key i)\n                       l1'' = (splitBlock pt').0\n                       l2'' =  (splitBlock pt').1\n                       pt'' = (aply_fb l1'' l2'' y key i) # (aply_fa l1'' l2'' x key i)\n                       l1''' = (splitBlock pt'').0\n                       l2''' =  (splitBlock pt'').1\n\n\/\/Encryption\n\nkatanEncrypt : ( [KatanKeySize], [KatanBlock]) -> _ \/\/ [KatanBlock]\n\nkatanEncrypt (key, pt) =  (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] # [ ( (updateLfsr pT.0 pT.1 x y key i).0, (updateLfsr pT.0 pT.1 x y key i).1)  | i<- [0,1..253] | pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\n\/\/ wrapper to do experiments\n\nkatanEncrypt64 : ([KatanBlock], [KatanBlock]) -> [KatanBlock]\nkatanEncrypt64 (key, pt) = katanEncrypt(key#zero, pt)\n\nkatanEncrypt80 : ([KatanKeySize], [KatanKeySize]) -> [KatanKeySize]\nkatanEncrypt80 (key, pt) = katanEncrypt(key, (take`{64} pt)) # zero\n\n\/\/Auxiliary functions for decryption\n\n\/\/ fa and fb\n\ndecFunFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ndecFunFa L1 L2 x k i = fa ^ (L1!((x@1)+1)) ^ (L1!((x@2)+1) && L1!((x@3)+1)) ^ (L1!((x@4)+1) && ((iR@0)@i)) ^ k@(2*i)\n         where fa = L2!0\n\ndecFunFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [508] -> [Round] -> Bit\ndecFunFb L2 L1 y k i =  fb ^ (L2!((y@1)+1)) ^ ((L2!((y@2)+1)) && L2!((y@3)+1)) ^ ((L2!((y@4)+1)) && L2!((y@5)+1)) ^ k@(2*i+1)\n         where fb = L1!0\n\n\/\/Left shifting L1, L2 and appending fa, fb values\n\naply_decFa_once : [L1Size] -> [L2Size] -> [xSize][xSize] -> [KatanKeySize] -> [Round] -> [L1Size]\n\naply_decFa_once  l1 l2 x k i = [(decFunFa l1 l2 x (keySchedule' k) i)] # (l1!![(L1Size-1),(L1Size-2)..1])\n\naply_decFb_once : [L2Size] -> [L1Size] -> [ySize][ySize] -> [KatanKeySize] -> [Round] -> [L2Size]\naply_decFb_once  l2 l1 y k i =  [(decFunFb l2 l1 y (keySchedule' k) i)] # (l2!![(L2Size-1),(L2Size-2)..1])\n\n\/\/ Updating LFSR for decryption\n\ndecUpdateLfsr: [L1Size] -> [L2Size] -> [xSize][xSize]-> [ySize][ySize] -> [KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\ndecUpdateLfsr  l1 l2 x y key i = if `(L1Size) == 13\n                                 then (l1', l2')\n                                 else if `(L1Size) == 19\n                                      then (l1'', l2'')\n                                      else (l1''', l2''')\n                               where ct = (aply_decFa_once l1 l2 x key i) # (aply_decFb_once l2 l1 y key i)\n                                     l1' = (splitBlock ct).0\n                                     l2' = (splitBlock ct).1\n                                     ct' = (aply_decFa_once l1' l2' x key i) # (aply_decFb_once l2' l1' y key i)\n                                     l1'' = (splitBlock ct').0\n                                     l2'' = (splitBlock ct').1\n                                     ct'' = (aply_decFa_once l1'' l2'' x key i) # (aply_decFb_once l2'' l1'' y key i)\n                                     l1''' = (splitBlock ct'').0\n                                     l2''' = (splitBlock ct'').1\n\nkatanDecrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\nkatanDecrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] #[ ((decUpdateLfsr pT.0 pT.1 x y key i).0 , (decUpdateLfsr pT.0 pT.1 x y key i).1)  | i <-[253,252..0] |pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\nproperty katanCorrect key m = katanEncrypt( key, katanDecrypt(key, m)) == m\n\nk_a_index = [0x3f, 0x1f, 0x1f, 0x0f, 0x0e, 0x3c, 0x28, 0x31, 0x23, 0x36, 0x2d,\n             0x3a, 0x25, 0x4a, 0x45, 0x4a, 0x35, 0x2b, 0x47, 0x3f, 0x1e, 0x2d,\n             0x0b, 0x36, 0x1c, 0x29, 0x03, 0x26, 0x3c, 0x19, 0x22, 0x05, 0x1a,\n             0x14, 0x09, 0x02, 0x14, 0x18, 0x01, 0x02, 0x34, 0x18, 0x11, 0x03,\n             0x06, 0x4c, 0x48, 0x31, 0x13, 0x17, 0x0f, 0x0e, 0x0c, 0x18, 0x10,\n             0x01, 0x02, 0x04, 0x28, 0x30, 0x11, 0x12, 0x05, 0x0a, 0x04, 0x08,\n             0x40, 0x40, 0x41, 0x33, 0x17, 0x2f, 0x0f, 0x4e, 0x4c, 0x49, 0x43,\n             0x37, 0x2f, 0x3f, 0x2f, 0x3e, 0x1d, 0x1a, 0x05, 0x0a, 0x24, 0x38,\n             0x21, 0x32, 0x15, 0x2a, 0x05, 0x3a, 0x14, 0x19, 0x03, 0x06, 0x0c,\n             0x38, 0x10, 0x21, 0x03, 0x46, 0x3c, 0x29, 0x43, 0x47, 0x4e, 0x4d,\n             0x3b, 0x27, 0x4f, 0x4f, 0x3e, 0x2d, 0x3b, 0x17, 0x2e, 0x0d, 0x2a,\n             0x34, 0x29, 0x42, 0x35, 0x2a, 0x35, 0x1b, 0x26, 0x0d, 0x4a, 0x34,\n             0x19, 0x23, 0x07, 0x3e, 0x2c, 0x49, 0x33, 0x16, 0x1d, 0x0b, 0x06,\n             0x2c, 0x48, 0x41, 0x32, 0x25, 0x4b, 0x37, 0x2e, 0x4d, 0x4b, 0x46,\n             0x3d, 0x1b, 0x27, 0x0f, 0x2e, 0x4c, 0x39, 0x22, 0x45, 0x3b, 0x26,\n             0x3d, 0x2b, 0x46, 0x4d, 0x3a, 0x15, 0x2b, 0x07, 0x1e, 0x2c, 0x09,\n             0x12, 0x24, 0x09, 0x32, 0x24, 0x39, 0x13, 0x16, 0x0d, 0x0a, 0x44,\n             0x38, 0x11, 0x13, 0x07, 0x0e, 0x1c, 0x28, 0x01, 0x42, 0x44, 0x39,\n             0x23, 0x37, 0x1f, 0x1e, 0x0d, 0x0a, 0x04, 0x48, 0x30, 0x21, 0x33,\n             0x27, 0x4e, 0x3d, 0x1a, 0x15, 0x0b, 0x06, 0x0c, 0x08, 0x20, 0x40,\n             0x31, 0x12, 0x25, 0x0b, 0x16, 0x1c, 0x09, 0x02, 0x04, 0x08, 0x00,\n             0x30, 0x20, 0x41, 0x43, 0x36, 0x1d, 0x1b, 0x07, 0x0e, 0x0c, 0x08,\n             0x00, 0x00, 0x10, 0x20, 0x01, 0x22, 0x44, 0x49, 0x42, 0x45, 0x4b,\n             0x47]\n\nk_b_index = [0x1f, 0x3f, 0x3f, 0x2f, 0x0e, 0x4c, 0x28, 0x11, 0x43, 0x16, 0x4d,\n             0x1a, 0x45, 0x0a, 0x45, 0x0a, 0x15, 0x2b, 0x07, 0x4f, 0x3e, 0x2d,\n             0x0b, 0x46, 0x3c, 0x29, 0x13, 0x46, 0x1c, 0x49, 0x22, 0x15, 0x4a,\n             0x34, 0x29, 0x12, 0x44, 0x38, 0x21, 0x02, 0x44, 0x38, 0x31, 0x23,\n             0x06, 0x4c, 0x08, 0x11, 0x33, 0x37, 0x3f, 0x2e, 0x1c, 0x48, 0x30,\n             0x31, 0x22, 0x14, 0x48, 0x10, 0x41, 0x32, 0x35, 0x3a, 0x24, 0x08,\n             0x40, 0x00, 0x01, 0x13, 0x37, 0x2f, 0x0f, 0x4e, 0x0c, 0x09, 0x03,\n             0x17, 0x2f, 0x1f, 0x4f, 0x1e, 0x4d, 0x3a, 0x25, 0x1a, 0x44, 0x18,\n             0x41, 0x12, 0x45, 0x2a, 0x05, 0x4a, 0x34, 0x39, 0x33, 0x26, 0x0c,\n             0x48, 0x30, 0x21, 0x03, 0x46, 0x1c, 0x29, 0x03, 0x47, 0x0e, 0x0d,\n             0x1b, 0x27, 0x0f, 0x4f, 0x1e, 0x2d, 0x1b, 0x47, 0x2e, 0x1d, 0x4a,\n             0x14, 0x49, 0x02, 0x45, 0x2a, 0x15, 0x4b, 0x26, 0x0d, 0x4a, 0x14,\n             0x39, 0x23, 0x07, 0x4e, 0x2c, 0x09, 0x43, 0x36, 0x3d, 0x2b, 0x16,\n             0x4c, 0x08, 0x41, 0x12, 0x25, 0x0b, 0x47, 0x2e, 0x0d, 0x4b, 0x06,\n             0x1d, 0x3b, 0x27, 0x1f, 0x4e, 0x0c, 0x49, 0x22, 0x05, 0x4b, 0x26,\n             0x1d, 0x4b, 0x06, 0x4d, 0x1a, 0x35, 0x2b, 0x17, 0x4e, 0x2c, 0x19,\n             0x42, 0x24, 0x09, 0x42, 0x24, 0x19, 0x43, 0x36, 0x2d, 0x0a, 0x44,\n             0x18, 0x31, 0x33, 0x27, 0x1e, 0x4c, 0x28, 0x01, 0x42, 0x04, 0x19,\n             0x23, 0x17, 0x4f, 0x3e, 0x3d, 0x2a, 0x04, 0x48, 0x10, 0x21, 0x13,\n             0x47, 0x0e, 0x4d, 0x3a, 0x35, 0x3b, 0x36, 0x2c, 0x18, 0x40, 0x00,\n             0x41, 0x32, 0x25, 0x1b, 0x46, 0x3c, 0x39, 0x32, 0x34, 0x28, 0x00,\n             0x40, 0x20, 0x01, 0x43, 0x16, 0x3d, 0x3b, 0x37, 0x3e, 0x3c, 0x38,\n             0x20, 0x10, 0x40, 0x20, 0x11, 0x42, 0x04, 0x49, 0x02, 0x05, 0x0b,\n             0x07]\n\ntanFa : [L1Size]-> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ntanFa L1 x k i = (L1!(x@0)) ^ (L1!(x@1)) ^ ((L1!(x@2)) && (L1!(x@3))) ^ ((L1!(x@4)) && ((iR@0)@i)) ^ (k@(k_a_index @i))\n\ntanFb : [L2Size]-> [ySize][ySize] -> [508] -> [Round] -> Bit\n\ntanFb L2 y k i = (L2!(y@0)) ^ (L2!(y@1)) ^ (L2!(y@2) && L2!(y@3)) ^ (L2!(y@4) && L2!(y@5)) ^ (k@(k_b_index @i))\n\ntanAplyFb : [L1Size] -> [L2Size]->  [ySize][ySize] ->[KatanKeySize] -> [Round] -> [L1Size]\ntanAplyFb l1 l2 y key i = (l1 !! [(L1Size-2),(L1Size-3)..0]) # [(tanFb l2 y (keySchedule' key) i)]\n\ntanAplyFa : [L1Size] -> [L2Size]-> [xSize][xSize]->[KatanKeySize] -> [Round] -> [L2Size]\ntanAplyFa l1 l2 x key i = (l2 !! [(L2Size-2),(L2Size-3)..0]) # [(tanFa l1 x (keySchedule' key) i)]\n\nupdateLfsrTan : [L1Size] -> [L2Size]-> [xSize][xSize] -> [ySize][ySize]->[KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\nupdateLfsrTan l1 l2 x y key i = if `(L1Size) == 13\n                             then (l1', l2')\n                             else if `(L1Size) == 19\n                                  then (l1'', l2'')\n                                  else (l1''', l2''')\n\n                 where pt = (tanAplyFb l1 l2 y key i) # (tanAplyFa l1 l2 x key i)\n                       l1' = (splitBlock pt).0\n                       l2' = (splitBlock pt).1\n                       pt' = (tanAplyFb l1' l2' y key i) # (tanAplyFa l1' l2' x key i)\n                       l1'' = (splitBlock pt').0\n                       l2'' =  (splitBlock pt').1\n                       pt'' = (tanAplyFb l1'' l2'' y key i) # (tanAplyFa l1'' l2'' x key i)\n                       l1''' = (splitBlock pt'').0\n                       l2''' =  (splitBlock pt'').1\n\n\/\/Encryption\n\nkatantanEncrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\n\nkatantanEncrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] # [((updateLfsrTan pT.0 pT.1 x y key i).0, (updateLfsrTan pT.0 pT.1 x y key i).1) | i<- [0,1..253] | pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\/\/ Wrapper to do experiments\n\nkatantanEncrypt64 : ([KatanBlock], [KatanBlock]) -> [KatanBlock]\nkatantanEncrypt64  (key, pt) = katantanEncrypt( key#zero, pt)\n\nkatantanEncrypt80 : ([KatanKeySize], [KatanKeySize]) -> [KatanKeySize]\nkatantanEncrypt80  (key, pt) = katantanEncrypt( key, (take`{64} pt)) # zero\n\n\/\/KTANTAN-Decryption\n\ndecTanFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [508] -> [Round] -> Bit\n\ndecTanFa L1 L2 x k i = fa ^ (L1!((x@1)+1)) ^ (L1!((x@2)+1) && L1!((x@3)+1)) ^ (L1!((x@4)+1) && ((iR@0)@i)) ^ k@(k_a_index@i)\n         where fa = L2!0\n\ndecTanFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [508] -> [Round] -> Bit\ndecTanFb L2 L1 y k i =  fb ^ (L2!((y@1)+1)) ^ ((L2!((y@2)+1)) && L2!((y@3)+1)) ^ ((L2!((y@4)+1)) && L2!((y@5)+1)) ^ k@(k_b_index@i)\n         where fb = L1!0\n\n\/\/Left shifting L1, L2 and appending fa, fb values\n\ntanAplydecFa : [L1Size] -> [L2Size] -> [xSize][xSize] -> [KatanKeySize] -> [Round] -> [L1Size]\n\ntanAplydecFa  l1 l2 x k i = [(decTanFa l1 l2 x (keySchedule' k) i)] # (l1!![(L1Size-1),(L1Size-2)..1])\n\ntanAplydecFb : [L2Size] -> [L1Size] -> [ySize][ySize] -> [KatanKeySize] -> [Round] -> [L2Size]\ntanAplydecFb  l2 l1 y k i =  [(decTanFb l2 l1 y (keySchedule' k) i)] # (l2!![(L2Size-1),(L2Size-2)..1])\n\n\/\/ Updating LFSR for decryption\n\ndecUpdateLfsrTan: [L1Size] -> [L2Size] -> [xSize][xSize]-> [ySize][ySize] -> [KatanKeySize] -> [Round] -> ([L1Size], [L2Size])\ndecUpdateLfsrTan  l1 l2 x y key i = if `(L1Size) == 13\n                                 then (l1', l2')\n                                 else if `(L1Size) == 19\n                                      then (l1'', l2'')\n                                      else (l1''', l2''')\n                               where ct = (tanAplydecFa l1 l2 x key i) # (tanAplydecFb l2 l1 y key i)\n                                     l1' = (splitBlock ct).0\n                                     l2' = (splitBlock ct).1\n                                     ct' = (tanAplydecFa l1' l2' x key i) # (tanAplydecFb l2' l1' y key i)\n                                     l1'' = (splitBlock ct').0\n                                     l2'' = (splitBlock ct').1\n                                     ct'' = (tanAplydecFa l1'' l2'' x key i) # (tanAplydecFb l2'' l1'' y key i)\n                                     l1''' = (splitBlock ct'').0\n                                     l2''' = (splitBlock ct'').1\n\nkatantanDecrypt : ([KatanKeySize], [KatanBlock]) -> [KatanBlock]\nkatantanDecrypt (key, pt) = (hs!0).0 # (hs!0).1\n               where hs = [(l1, l2)] #[ ((decUpdateLfsrTan pT.0 pT.1 x y key i).0 , (decUpdateLfsrTan pT.0 pT.1 x y key i).1)  | i <-[253,252..0] |pT <- hs ]\n                     l1 = (splitBlock pt).0\n                     l2 = (splitBlock pt).1\n\nproperty katantanCorrect key m = katantanDecrypt(key, katantanEncrypt(key, m)) == m\n\ntests64 = [katan64_1, katan64_2, katantan64_1, katantan64_2]\nproperty testsPass = and tests64\n\nkatan64_1 = katanEncrypt( 0xffffffffffffffffffff, zero) == 0x21f2e99c0fab828a\nkatan64_2 = katanEncrypt(zero, 0xffffffffffffffff) == 0xc956100dbeb64ba8\n\nkatantan64_1 = katantanEncrypt(0xffffffffffffffffffff, zero) == 0xc02de05bfa194b16\nkatantan64_2 = katantanEncrypt(zero, 0xffffffffffffffff) == 0xc956100dbeb64ba8\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/TEA.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::TEA that contains the following definitions implementing TEA, XTEA, and XXTEA with explicit types and checks: (1) Type synonyms for parameters and sizes: Nb=2, Nkb=4, Nr (type-level)=2, TeaBlockSize=64, TeaKeySize=128, stdBlock=32, keyInd=2, PTSize=TeaBlockSize, CTSize=TeaBlockSize, NB=2, bTeaPtSize=NB*stdBlock. (2) Constants: dlta:[32] is the TEA delta; sum:[32] is the initial sum. (3) Helpers: splitPT:[64]->[Nb][32]; splitKey:[128]->[Nkb][32]; splitPtN:[NB*32]->[NB][32]. (4) Round functions: teaRoundFun:[32]->[32]->[32]->[32]->[32]; xTeaRoundFun:[32]->[128]->[32]->[32]->[32]; bTeaRoundFun:[32]->[32]->[128]->[6]->[32]->[32]. (5) TEA cycles and APIs: teaEncCycle:([64],[128],[32])->[64]; teaDecCycle:([64],[128],[32])->[64]; teaEncrypt:([128],[64])->[64] performing 32 cycles; teaDecrypt:([128],[64])->[64] as the inverse. Define a property teaCorrect that checks decryption inverts encryption for TEA. (6) Reduced-key TEA wrappers using zero-extension: teaEncrypt':([64],[64])->[64]; teaDecrypt':([64],[64])->[64]. Define a property teaCorrect' with the same inversion check. (7) XTEA: xTeaEncCycle\/xTeaDecCycle:([64],[128],[32])->[64]; xTeaEncrypt\/xTeaDecrypt:([128],[64])->[64] over 32 cycles. Define a property xTeaCorrect for correctness. Helpers with 64-bit keys zero-extended: xTeaEncrypt64\/xTeaDecrypt64:([64],[64])->[64]; define property xTeaCorrect64. xTeaEncrypt128:([128],[128])->[128] by encrypting the lower 64 bits and zero-extending. (8) XXTEA: value-level Nr = 6 + 52\/NB; bTeaEncMixing\/bTeaDecMixing:([NB*32],[128],[32])->[NB*32]; bTeaEncrypt\/bTeaDecrypt:([128],[NB*32])->[NB*32]. Define a property bTeaCorrect for inversion. (9) Test vectors teaTest, xteaTest, xxteaTest as booleans; tests is their list. Define a property testsPass as their conjunction."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::TEA where\n\ntype Nb = 2\ntype Nkb = 4\ntype Nr = 2\ntype TeaBlockSize = 64\ntype TeaKeySize = 128\ntype stdBlock = 32\ntype keyInd = 2\n\nsplitPT: [TeaBlockSize] -> [Nb][stdBlock]\nsplitPT pt = split(pt):[Nb][stdBlock]\n\nsplitKey: [TeaKeySize] -> [Nkb][stdBlock]\nsplitKey key = split(key):[Nkb][stdBlock]\n\ndlta : [stdBlock]\ndlta = 0x9e3779b9\n\nsum = 0xc6ef3720\n\nteaRoundFun : [stdBlock] -> [stdBlock] -> [stdBlock] -> [stdBlock] -> [stdBlock]\nteaRoundFun pt k1 k2 delta = (pt << 4 + k1) ^ (pt + delta) ^ ((pt>>5)+k2)\n\nteaEncCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nteaEncCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          k0 = (splitKey key)@0\n          k1 = (splitKey key)@1\n          k2 = (splitKey key)@2\n          k3 = (splitKey key)@3\n          fiestr1 = rpt# roundf1\n          roundf1 = lpt + (teaRoundFun rpt k0 k1 sum)\n          fiestr2 = roundf1 # roundf2\n          roundf2 = rpt + (teaRoundFun roundf1 k2 k3 sum)\n\nteaDecCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nteaDecCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          k0 = (splitKey key)@0\n          k1 = (splitKey key)@1\n          k2 = (splitKey key)@2\n          k3 = (splitKey key)@3\n          roundf2 = rpt - (teaRoundFun lpt k2 k3 sum)\n          roundf1 = lpt - (teaRoundFun roundf2 k0 k1 sum)\n          fiestr2 = roundf1 # roundf2\n\nteaEncrypt : ([TeaKeySize], [TeaBlockSize]) -> [TeaBlockSize]\nteaEncrypt (key, pt) = (hs!0)\n    where hs = [pt] # [ teaEncCycle(m, key, i*dlta) | i <- [1,2..32] | m <- hs ]\n\nteaDecrypt : ([TeaKeySize], [TeaBlockSize]) -> [TeaBlockSize]\nteaDecrypt (key, ct) = (hs!0)\n    where hs = [ct] # [ teaDecCycle(cT, key, sum-i*dlta) | i <- [0,1..31] | cT <- hs ]\n\nproperty teaCorrect key m = teaDecrypt(key, teaEncrypt (key, m)) == m\n\nteaEncrypt' : ([TeaBlockSize], [TeaBlockSize]) -> [TeaBlockSize]\nteaEncrypt' (key, pt) = (hs!0)\n    where hs = [pt] # [ teaEncCycle(m, key', i*dlta) | i <- [1,2..32] | m <- hs ]\n          key' = key # zero\n\nteaDecrypt' : ([TeaBlockSize], [TeaBlockSize]) -> [TeaBlockSize]\nteaDecrypt' (key, ct) = (hs!0)\n    where hs = [ct] # [ teaDecCycle(cT, key', sum-i*dlta) | i<- [0,1..31] | cT <- hs ]\n          key' = key #zero\n\nproperty teaCorrect' key m = teaDecrypt'(key, teaEncrypt'(key, m)) == m\n\n\/************************************************************************\/\n\/************************************************************************\/\n\/* eXtended TEA *\/\n\n\/\/Round function for XTEA\n\nxTeaRoundFun : [stdBlock] -> [TeaKeySize] -> [stdBlock] -> [stdBlock] -> [stdBlock]\nxTeaRoundFun pt key sum1 sum2 = (((pt << 4) ^ (pt >> 5)) + pt) ^ (sum1 + k)\n    where k = (splitKey key)@(sum2 !![1,0])\n\n\/\/ XTEA cycle contains two Feistel rounds\n\nxTeaEncCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nxTeaEncCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          roundf1 = lpt +(xTeaRoundFun rpt key sum sum)\n          fiestr2 = roundf1 # roundf2\n          roundf2 = rpt+(xTeaRoundFun roundf1 key (sum+dlta) ((sum+dlta)>>11))\n\n\/\/XTEA decryption cycle contains two Feistel rounds\n\nxTeaDecCycle: ([TeaBlockSize], [TeaKeySize], [stdBlock]) -> [TeaBlockSize]\nxTeaDecCycle (pt, key, sum) = fiestr2\n    where lpt = (splitPT pt)@0\n          rpt = (splitPT pt)@1\n          roundf2 = rpt - (xTeaRoundFun lpt key sum (sum>>11))\n          roundf1 = lpt - (xTeaRoundFun roundf2 key (sum-dlta) (sum-dlta))\n          fiestr2 = roundf1 # roundf2\n\n\/\/Encryption: 32 XTEA cycles are recommended\n\/\/I change the signatures to run the experiments\n\ntype PTSize = TeaBlockSize\ntype CTSize = TeaBlockSize\n\nxTeaEncrypt : ([TeaKeySize], [PTSize]) -> [CTSize]\nxTeaEncrypt (key, pt) = (hs!0)\n    where hs = [pt] # [ xTeaEncCycle (m, key, i*dlta) | i <- [0,1..31] | m <- hs ]\n\n\/\/Decryption\n\nxTeaDecrypt : ([TeaKeySize], [CTSize]) -> [PTSize]\nxTeaDecrypt (key, ct) = (hs!0)\n    where hs = [ct] # [ xTeaDecCycle (pT, key, i*dlta) | i <- [32,31..1] | pT <- hs ]\n\nproperty xTeaCorrect key m = xTeaDecrypt(key, xTeaEncrypt(key, m)) == m\n\n\/\/ Helper function to run experiments\n\nxTeaEncrypt64 : ([PTSize], [PTSize]) -> [CTSize]\nxTeaEncrypt64 (key, pt) = (hs!0)\n    where hs = [pt] # [ xTeaEncCycle (m, key', i*dlta) | i <- [0,1..31] | m <- hs ]\n          key' = key # zero\n\nxTeaDecrypt64 : ([CTSize], [PTSize]) -> [PTSize]\nxTeaDecrypt64 (key, ct) = (hs!0)\n    where hs = [ct] # [ xTeaDecCycle (pT, key', i*dlta) | i <- [32,31..1] | pT <- hs ]\n          key' = key # zero\n\nproperty xTeaCorrect64 key m = xTeaDecrypt64 (key, xTeaEncrypt64(key,m)) == m\n\nxTeaEncrypt128 : ([TeaKeySize], [TeaKeySize]) -> [TeaKeySize]\nxTeaEncrypt128 (key, pt) = xTeaEncrypt (key, (take`{64} pt)) # zero\n\n\/************************************************************************\/\n\/************************************************************************\/\n\/* Corrected Block TEA or XXTEA*\/\n\/* XTEA modified to cater larger block sizes*\/\n\ntype NB = 2\nNr = 6 + 52\/`NB\ntype bTeaPtSize= NB*stdBlock\n\n\/\/Splitting text into number of words\n\nsplitPtN: [bTeaPtSize] -> [NB][stdBlock]\nsplitPtN pt = split(pt) : [NB][stdBlock]\n\n\/\/Round Function\n\nbTeaRoundFun: [stdBlock]-> [stdBlock]-> [TeaKeySize]-> [6]-> [stdBlock]->[stdBlock]\nbTeaRoundFun y z key p sum = ((z>>5) ^ (y<<2)) + ((y>>3) ^ (z<<4)) ^ (sum ^ y) + ((ki @ ((p!![1,0]) ^ e)) ^ z)\n    where ki = (splitKey key)\n          e = (sum >> 2) !![1,0]\n\n\/\/Mixing in encryption\n\nbTeaEncMixing : ([bTeaPtSize], [TeaKeySize], [stdBlock]) -> [bTeaPtSize]\n\nbTeaEncMixing (pt, key, sum) = join hs'\n    where pt' = splitPtN pt\n          hs = [ (pt'@0)+(bTeaRoundFun (pt'@1) (pt'@(`NB-1)) key 0 sum) ] # [ (pt'@p)+(bTeaRoundFun (pt'@(p+1)) h key p sum) | p <- [1,2..NB-2] | h <- hs ]\n          hs' = hs # [ (pt'@(`NB-1)) + (bTeaRoundFun (hs@0) (hs!0) key (`NB-1) sum) ]\n\nbTeaEncrypt : ([TeaKeySize], [bTeaPtSize]) -> [bTeaPtSize]\nbTeaEncrypt (key, pt) = hs!0\n    where hs = [bTeaEncMixing (pt, key, dlta)] # [ bTeaEncMixing (pT, key, i*dlta) | i <- [2,3..Nr] | pT <- hs ]\n\nbTeaDecMixing : ([bTeaPtSize], [TeaKeySize], [stdBlock]) -> [bTeaPtSize]\n\nbTeaDecMixing (pt, key, sum) = join hs''\n    where pt' = splitPtN pt\n          hs= [(pt'@(`NB-1)) - (bTeaRoundFun (pt'@0) (pt'@(`NB-2)) key  1 sum)] # [ pt'@(`NB-1-p)-(bTeaRoundFun h (pt'@ (`NB-2-p)) key p sum) | p <- [1,2..(NB-2)] | h <- hs ]\n          hs' =  hs # [ pt'@0 - (bTeaRoundFun (hs!0) (hs@0) key  0 sum)]\n          hs'' = [hs'!0] # [hs'!i | i<- [1,2..NB-1] ]\n\nbTeaDecrypt : ([TeaKeySize], [bTeaPtSize]) -> [bTeaPtSize]\nbTeaDecrypt (key, pt) =  hs!0\n    where hs = [bTeaDecMixing (pt, key, `Nr*dlta)] # [ bTeaDecMixing (pT, key, (`Nr-i)*dlta) | i <- [1,2..(Nr-1)] | pT <- hs ]\n\nproperty bTeaCorrect key m = bTeaDecrypt(key, bTeaEncrypt (key, m)) == m\n\ntests = [teaTest, xteaTest, xxteaTest]\nproperty testsPass = and tests\n\nteaTest = teaEncrypt(0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0xce674a7575034065\nxteaTest = xTeaEncrypt(0x0123456789abcdef0123456789abcdef, 0x0123456789abcdef) == 0x27e795e076b2b537\nxxteaTest = bTeaEncrypt(0x0123456789abcdef0123456789abcdef,0x0123456789abcdef) == 0x2b98de778c9b788c\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Authenticated::GCM::Specification that contains the following definitions: (1) Import a block-cipher interface as C and impose interface constraints that the block size is 128 bits and the key size is at least 128 bits. (2) Type constraints: ValidIV (bit-width \u2264 64, \u2265 1, and byte-aligned), ValidAAD (bit-width \u2264 64 and byte-aligned), ValidTag (finite, byte-aligned, length in bytes between 12 and 16 inclusive), and ValidText (finite, length \u2264 2^39 \u2212 256 and byte-aligned). (3) A function GCM_AE with size-polymorphic parameters for ciphertext, IV, AAD, and tag that, given a key, IV, plaintext, and AAD, returns ciphertext of the same length as the plaintext and an authentication tag of the requested length. Use C::encrypt to derive the hash subkey from the all-zero block, derive the initial counter from the IV (special-case 96-bit IVs, otherwise GHASH the IV with length encoding), encrypt via a counter mode that increments the low 32 bits per block, compute GHASH over AAD and ciphertext with zero padding to 128-bit blocks and 64-bit length encodings, then compute the tag by encrypting the GHASH output and truncating to the requested tag length. (4) A function GCM_AD that recomputes the tag from key, IV, ciphertext, and AAD; return Some plaintext if the provided tag matches, otherwise None. (5) Define a property that the bit-serial field multiplication equals the polynomial-reduction multiplication over GF(2^128). (6) Define a property that encrypting then decrypting with the same inputs yields the original plaintext. (7) Private helpers: J0 derivation, GF(2^128) multiply (two variants), GHASH, counter increment on a selected LSB width, MSB\/LSB extractors, GCTR, and a property that GCTR maps empty input to empty output."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Specification where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\ninterface constraint (C::BlockSize == 128)\n\n interface constraint (128 <= C::KeySize)\n\ntype constraint ValidIV IV = (width IV <= 64, IV >= 1, IV % 8 == 0)\n\ntype constraint ValidAAD AAD = (width AAD <= 64, AAD % 8 == 0)\n\ntype constraint ValidTag T = (fin T, T % 8 == 0, T \/ 8 >= 12, T \/ 8 <= 16)\n\ntype constraint ValidText P = (fin P, P <= 2^^39 - 256, P % 8 == 0)\n\nGCM_AE : { len_C, len_IV, len_A, T } (ValidText len_C, ValidIV len_IV, ValidAAD len_A, ValidTag T)\n => [C::KeySize] -> [len_IV] -> [len_C] -> [len_A] -> ([len_C], [T])\nGCM_AE k iv p a = (C, T)\n  where\n    CIPHk = C::encrypt k\n\n    H = CIPHk 0\n    J0 = define_J0 k iv H\n    C = GCTR CIPHk (inc`{32} J0) p\n    type u = len_C %^ 128     type v = len_A %^ 128     S = GHASH`{len_A\/^ 128 + len_C \/^ 128 + 1}\n            H (a # (0 : [v]) # C # (0 : [u]) # (`len_A : [64]) # (`len_C : [64]))\n    T = MSB`{T} (GCTR CIPHk J0 S)\n\nGCM_AD : { len_C, len_IV, len_A, T } (ValidText len_C, ValidIV len_IV, ValidAAD len_A, ValidTag T)\n => [C::KeySize] -> [len_IV] -> [len_C] -> [len_A] -> [T] -> Option [len_C]\nGCM_AD key iv ct aad tag =\n  if tag == T'\n  then Some P\n  else None\n  where\n    CIPHk = C::encrypt key\n\n    H = CIPHk 0\n    J0 = define_J0 key iv H\n    P = GCTR CIPHk (inc`{32} J0) ct\n    type u = len_C %^ 128 \/\/ Equivalently: 128 * len_C \/^ 128 - len_C\n    type v = len_A %^ 128 \/\/ Equivalently: 128 * len_A \/^ 128 - len_A\n    S = GHASH`{len_A \/^ 128 + len_C \/^ 128 + 1}\n            H (aad # (0 : [v]) # ct # (0 : [u]) # (`len_A : [64]) # (`len_C : [64]))\n    T' = MSB`{T} (GCTR CIPHk J0 S)\n\nproperty dotAndMultAreEquivalent X Y = mult X Y == X \u2022 Y\n\ngcmIsSymmetric : { P, IV, AAD } ( ValidText P, ValidIV IV, ValidAAD AAD )\n  => [C::KeySize] -> [IV] -> [P] -> [AAD] -> Bool\nproperty gcmIsSymmetric key iv pt aad = is_symmetric\n    where\n        (ct, tag : [96]) = GCM_AE key iv pt aad\n        dec = GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nprivate\n\n  define_J0 : { len_IV } ( ValidIV len_IV ) => [C::KeySize] -> [len_IV] -> [128] -> [128]\n  define_J0 k iv H\n    | len_IV == 96 => iv # (0 : [31]) # (1 : [1])\n    | len_IV != 96 => GHASH`{len_IV \/^ 128 + 1} H (iv # (0 : [s + 64]) # (`len_IV: [64]))\n    where\n      type s = len_IV %^ 128  \n\n  (\u2022) : [128] -> [128] -> [128]\n  (\u2022) X Y = reverse (pmod (pmult (reverse X) (reverse Y))\n                          <| 1 + x + x^^2 + x^^7 + x^^128|>)\n\n  mult : [128] -> [128] -> [128]\n  mult X Y = last Z\n    where\n      R = 0b11100001 # (0 : [120])\n      Z = [0] # [ if [xi] == 0 then Zi else Zi ^ Vi\n                | Zi <- Z\n                | xi <- X\n                | Vi <- V ]\n      V = [Y] # [ if LSB`{1} Vi == 0 then Vi >> 1 else (Vi >> 1) ^ R\n                | Vi <- V ]\n\n  GHASH : {m} (fin m) => [128] -> [m * 128] -> [128]\n  GHASH H X = last Y\n    where Y = [0] # [ (Yi ^ Xi) \u2022 H | Yi <- Y | Xi <- groupBy`{128} X ]\n\n  inc : {s, a} (fin s, fin a, a >= s) => [a] -> [a]\n  inc X = MSB`{a-s} X # (LSB`{s} X + take (1 : [max s 1]))\n\n  LSB : {s, a} (fin s, fin a, a >= s) => [a] -> [s]\n  LSB X = drop X\n\n  MSB : {s, a} (fin s, a >= s) => [a] -> [s]\n  MSB X = take X\n\n  GCTR : {a} (fin a) => ([128] -> [128]) -> [128] -> [a] -> [a]\n  GCTR CIPHk ICB X = Y\n    where\n      Y = X ^ take`{a} (join (map CIPHk CB))\n      CB = iterate inc`{32} ICB\n\n  emptyInputProducesEmptyOutputGCTR : [C::KeySize] -> [128] -> Bool\n  property emptyInputProducesEmptyOutputGCTR key icb =\n   zero == (GCTR CIPHk icb (zero : [0]))\n    where\n      CIPHk = C::encrypt key\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Tests\/AES128_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES128_GCM that imports the AES-128 GCM instantiation module under a short alias. Inside, declare four properties named aes128_vector_0, aes128_vector_1, aes128_vector_2, and aes128_vector_3. For each property: declare a 128-bit key, a 96-bit IV, a plaintext value (empty, a single 128-bit block, or a longer sequence as required), an associated data value (empty except the last case which is non-empty), and fixed expected ciphertext and 128-bit tag constants. Compute ciphertext and tag using the authenticated-encryption function from the imported module, and compute an optional plaintext via the corresponding authenticated-decryption function. Define a boolean is_symmetric that is true exactly when decryption returns Some actual plaintext equal to the original plaintext, and false if decryption fails. The property must assert the conjunction that the produced ciphertext equals the expected ciphertext, the produced tag equals the expected tag, and is_symmetric holds. Ensure types are explicit: key is 128 bits, IV is 96 bits, tag is 128 bits, the empty ciphertext for the empty plaintext is a 0-length sequence, and other values are sized to match their hex literals. Use the exact fixed hexadecimal values corresponding to the standard AES-128 GCM test vectors represented by these four cases."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES128_GCM where\nimport Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES128_GCM as AES_GCM\n\nproperty aes128_vector_0 = ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        pt = []\n        key = zero : [128]\n        iv = zero : [96]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt []\n        dec = AES_GCM::GCM_AD key iv ct [] tag\n        expected_ct = [] : [0]\n        expected_tag = 0x58e2fccefa7e3061367f1d57a4e7455a : [128]\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nproperty aes128_vector_1 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = zero\n        iv = zero : [96]\n        pt = zero\n        aad = []\n        expected_ct = 0x0388dace60b6a392f328c2b971b2fe78 : [128]\n        expected_tag = 0xab6e47d42cec13bdf53a67b21257bddf : [128]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nproperty aes128_vector_2 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = 0xfeffe9928665731c6d6a8f9467308308\n        iv = 0xcafebabefacedbaddecaf888 : [96]\n        pt = 0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b391aafd255\n        aad = []\n        expected_ct = 0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091473f5985\n        expected_tag = 0x4d5c2af327cd64a62cf35abd2ba6fab4 : [128]\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nproperty aes128_vector_3 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key = 0xfeffe9928665731c6d6a8f9467308308\n        pt  = 0xd9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b39\n        iv  = 0xcafebabefacedbaddecaf888\n        aad = 0xfeedfacedeadbeeffeedfacedeadbeefabaddad2\n        expected_ct  = 0x42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25466931c7d8f6a5aac84aa051ba30b396a0aac973d58e091\n        expected_tag = 0x5bc94fbc3221a5db94fae95ae7121a47\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Tests\/AES256_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES256_GCM that contains: (1) an import of the AES-256-GCM instantiation module under the alias AES_GCM to access GCM_AE (encrypt-and-authenticate) and GCM_AD (decrypt-and-verify); (2) a property named aes256_vector_0 that uses fixed hexadecimal constants for a 256-bit key, a 96-bit IV, a 128-bit plaintext, a 128-bit associated data value, an expected ciphertext of the same width as the plaintext, and a 128-bit authentication tag. Within the property, compute (ciphertext, tag) using GCM_AE and assert both match the expected values, and also call GCM_AD with the produced ciphertext and tag and assert it returns Some of the original plaintext (use a Maybe match to yield a boolean). (3) a property named aes256_invalid_vector_1 that reuses the same key, IV, plaintext, AAD, and expected encryption outputs, defines an additional alternate (invalid) 128-bit tag, asserts the encryption still yields the expected ciphertext and valid tag, and asserts that calling GCM_AD with the invalid tag returns None (i.e., decryption\/authentication fails). Clearly state all bit widths for key (256), IV (96), plaintext\/ciphertext (128), AAD (128), and tag (128), and ensure each property is a boolean conjunction of the encryption equality checks with the corresponding decryption success\/failure predicate."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Tests::AES256_GCM where\nimport Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES256_GCM as AES_GCM\n\nproperty aes256_vector_0 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ is_symmetric\n    where\n        key   = 0xeebc1f57487f51921c0465665f8ae6d1658bb26de6f8a069a3520293a572078f : [256]\n        iv    = 0x99aa3e68ed8173a0eed06684 : [96]\n        pt    = 0xf56e87055bc32d0eeb31b2eacc2bf2a5 : [128]\n        aad   = 0x4d23c3cec334b49bdb370c437fec78de : [128]\n        expected_ct   = 0xf7264413a84c0e7cd536867eb9f21736\n        expected_tag  = 0x67ba0510262ae487d737ee6298f77e0c\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        dec = AES_GCM::GCM_AD key iv ct aad tag\n        is_symmetric = case dec of\n          Some actual_pt -> pt == actual_pt\n          None -> False\n\nproperty aes256_invalid_vector_1 =\n    ct == expected_ct \/\\ tag == expected_tag \/\\ requires_symmetry\n    where\n        key   = 0xeebc1f57487f51921c0465665f8ae6d1658bb26de6f8a069a3520293a572078f : [256]\n        iv    = 0x99aa3e68ed8173a0eed06684 : [96]\n        pt    = 0xf56e87055bc32d0eeb31b2eacc2bf2a5 : [128]\n        aad   = 0x4d23c3cec334b49bdb370c437fec78de : [128]\n        expected_ct   = 0xf7264413a84c0e7cd536867eb9f21736\n        expected_tag  = 0x67ba0510262ae487d737ee6298f77e0c\n        invalid_tag  = 0x67ba0510262ae487d737ee6298f77888\n        (ct, tag) = AES_GCM::GCM_AE key iv pt aad\n        requires_symmetry = case (AES_GCM::GCM_AD key iv ct aad invalid_tag) of\n            Some _ -> False\n            None -> True\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Instantiations\/AES128_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES128_GCM that is the generic Galois\/Counter Mode (GCM) specification specialized with the AES-128 block cipher implementation. The module must re-export, without modification, all type synonyms, constraints, constants, functions, and properties provided by the generic GCM specification when instantiated with AES-128. This includes AEAD encryption and decryption entry points, authentication tag computation and verification, GHASH-related operations, and any helper definitions. Ensure all sizes and constraints resolve to AES-128 parameters (128-bit block, 128-bit key) and that any length- or width-polymorphic aspects in the generic specification are concretized accordingly. Do not introduce new definitions; expose exactly the specialized interface of the generic GCM spec under this module name."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES128_GCM =\n    Primitive::Symmetric::Cipher::Authenticated::GCM::Specification {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Authenticated\/GCM\/Instantiations\/AES256_GCM.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named AES256_GCM that is exactly the generic GCM specification instantiated with the AES-256 block-cipher implementation, re-exporting all resulting types, constraints, and functions without modification. The module should expose: type aliases for key, nonce, tag, block, and byte sizes; the encryption and decryption operations over plaintext and associated data; authentication tag computation and verification; and any GHASH and counter-mode helpers provided by the specification. Constrain the underlying block cipher to have a 128-bit block size as required by GCM and a 256-bit key width. Do not add new logic\u2014make this module a concrete alias of the specialized GCM interface so users can import a ready-to-use AES-256-GCM API."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Authenticated::GCM::Instantiations::AES256_GCM =\n    Primitive::Symmetric::Cipher::Authenticated::GCM::Specification {\n        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES256\n    }\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::TDES_CBC that contains the following definitions: (1) an import of encrypt and decrypt from the TripleDES block cipher module; (2) type synonyms for a 64-bit initialization vector, a 64-bit block, and three 64-bit keys; (3) a polymorphic CBC encryption function taking three keys, an initialization vector, and a sequence of n 64-bit blocks, returning n 64-bit blocks, with a finiteness constraint on n; the function must build the three-key list, XOR each plaintext block with the previous ciphertext (or the IV for the first block), and apply the imported encrypt with the key list; (4) a matching CBC decryption function with the same type that decrypts each ciphertext block with the key list, then XORs with the previous ciphertext (or IV for the first block); (5) a property named to assert that, for any three keys, IV, and a plaintext of exactly three blocks, decrypt(encrypt(plaintext)) equals the original plaintext; (6) a record constant bundling three example 64-bit keys and a 64-bit IV, plus two constants giving an example plaintext vector and its expected ciphertext vector, all using 64-bit blocks; (7) a property that checks both directions: encrypting the example plaintext with the example keys and IV yields the example ciphertext, and decrypting the example ciphertext yields the example plaintext. Clearly state all types, size constraints, and that both properties produce a boolean result suitable for solver checking."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::TDES_CBC where\n\nimport Primitive::Symmetric::Cipher::Block::TripleDES (encrypt, decrypt)\n\ntype iv = [64]\ntype block = [64]\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncbcTDesEnc : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncbcTDesEnc k1 k2 k3 iv ps = cs\n    where\n        ks = [ k1, k2, k3 ]\n        cs = [ encrypt ks (p ^ c') | p <- ps | c' <- [iv] # cs ]\n\ncbcTDesDec : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncbcTDesDec k1 k2 k3 iv cts = pts\n    where\n        ks  = [ k1, k2, k3 ]\n        pts = [ (decrypt ks ct) ^ fb |  ct <- cts | fb <- [iv] # cts  ]\n\ncbcTDESEncryptDecryptInverts : k1 -> k2 -> k3 -> iv -> [3]block -> Bit\nproperty cbcTDESEncryptDecryptInverts k1 k2 k3 iv pt = pt == pt'\n    where\n        ct  = cbcTDesEnc k1 k2 k3 iv pt\n        pt' = cbcTDesDec k1 k2 k3 iv ct\n\ntestKey = { k1=0x0123456789ABCDEF\n          , k2=0x23456789ABCDEF01\n          , k3=0x456789ABCDEF0123\n          , iv=0xF69F2445DF4F9B17\n          }\ntestPt  = [0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]\ntestCt  = [0x2079C3D53AA763E1, 0x93B79E2569AB5262, 0x516570481F25B50F, 0x73C0BDA85C8E0DA7]\n\nproperty testsPass = pt == testPt\n                  \/\\ ct == testCt\n    where\n        ct = cbcTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv testPt\n        pt = cbcTDesDec testKey.k1 testKey.k2 testKey.k3 testKey.iv testCt\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::CBC that contains the following definitions: (1) an import of the block-cipher interface aliased as C; (2) a polymorphic function encrypt with type parameter n and constraint that n is finite, taking a key of size C::KeySize, an initialization vector of size C::BlockSize, and a sequence of n blocks of size C::BlockSize, returning a sequence of n blocks of size C::BlockSize; its algorithm implements CBC encryption by applying the block cipher encryption from C to each plaintext block xor\u2019d with the previous ciphertext block, using the IV as the initial previous ciphertext; (3) a polymorphic function decrypt with the same type and constraint, implementing CBC decryption by applying the block cipher decryption from C to each ciphertext block and xor\u2019ing the result with the previous ciphertext (using the IV for the first block); (4) define a property encryptCorrect that, for all finite n, keys, IVs, and plaintext sequences, asserts that decrypt with the same key and IV applied to the result of encrypt with that key and IV yields the original plaintext sequence. Clearly state all type signatures, constraints, parameter roles, and that C::encrypt and C::decrypt are the primitive block cipher operations used. Do not provide implementations, only the precise specifications and the property statement."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CBC where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\nencrypt : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\nencrypt K IV Ps = Cs\n    where\n        CIPH_K = C::encrypt K\n        Cs = [ CIPH_K (P_j ^ C_j_1) | P_j <- Ps | C_j_1 <- [IV] # Cs]\n\ndecrypt : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\ndecrypt K IV Cs = Ps\n    where\n        CIPH_K_inv = C::decrypt K\n        Ps = [ (CIPH_K_inv C_j) ^ C_j_1 | C_j <- Cs | C_j_1 <- [IV] # Cs]\n\nencryptCorrect : {n} (fin n) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> Bool\nproperty encryptCorrect K IV Ps = (decrypt K IV (encrypt K IV Ps)) == Ps\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::CTR that contains the following definitions: (1) import the block-cipher interface under the alias C; (2) a function encrypt parameterized by a size variable n with constraints that n is finite and strictly less than 2 to the power of the block size. The function takes a key of the cipher\u2019s key size, an initial counter block of the cipher\u2019s block size, and a sequence of n blocks of the cipher\u2019s block size, and returns a sequence of n blocks. It constructs a keystream by applying the cipher\u2019s encryption function under the given key to a counter sequence starting at the initial counter and incrementing by one for each block; it XORs each plaintext block with the corresponding keystream block to produce ciphertext; (3) a function decrypt with the same type and constraints as encrypt that reconstructs plaintext by XORing each ciphertext block with the same keystream derived from the key and counter sequence; (4) a Boolean-valued declaration for a property named encryptCorrect with the same constraints and argument types as encrypt, and define a property that, for all keys, initial counters, and block sequences of length n, decrypt applied to the result of encrypt yields the original sequence. Clearly specify that both encrypt and decrypt use C::encrypt for keystream generation and that counters are computed as the initial counter plus the block index starting from zero."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CTR where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\nencrypt : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\nencrypt k t_1 ps = cs\n    where\n        ciph_k = C::encrypt k\n                cs = [p_j ^ (ciph_k t_j) | p_j <- ps | t_j <- ctrs]\n                ctrs = [t_1 + i | i<- [0...]]\n\ndecrypt : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> [n][C::BlockSize]\ndecrypt k t_1 cs = ps\n    where\n        ciph_k = C::encrypt k\n                ps = [c_j ^ (ciph_k t_j) | c_j <- cs | t_j <- ctrs]\n                ctrs = [t_1 + i | i<- [0...]]\n\nencryptCorrect : {n} (fin n, n < 2^^C::BlockSize) => [C::KeySize] -> [C::BlockSize] -> [n][C::BlockSize] -> Bool\nproperty encryptCorrect k c ps = (decrypt k c (encrypt k c ps)) == ps\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/XTS.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named block_xts_mode that contains the following definitions: (1) import a block-cipher interface (aliased C) and require its block size to be exactly 128 bits. (2) define a function that maps a 128-bit value to another 128-bit value by treating it as 16 bytes, reversing the byte order, and rejoining. (3) define a property asserting that applying the byte-reversal function twice returns the original input. (4) define a type constraint ValidLength over a size parameter n such that n is finite, n \u2265 128, and the number of 128-bit blocks in n is \u2264 2^20. (5) define a function that maps an n-bit data-unit sequence number (for n \u2264 128) to a 128-bit IV by zero-extending to 128 bits and then applying the byte-reversal function. (6) define a property giving one concrete example of this IV conversion that equates a fixed short input to its expected 128-bit result. (7) define constants for the polynomial element used as the GF(2) indeterminate and for the irreducible polynomial x^128 + x^7 + x^2 + x + 1 establishing GF(2^128). (8) define a function that multiplies a 128-bit value by the field element corresponding to x in GF(2^128) under a little-endian interpretation using endian-flip, polynomial multiply, modulus, and flip back. (9) define a function that, given a secondary key and a 128-bit IV, produces an infinite stream of 128-bit tweaks starting from encrypt(second-key, IV) and repeatedly applying the field-multiply function. (10) define single-block encrypt\/decrypt primitives that XOR a 128-bit tweak before and after the cipher call. (11) define top-level encrypt\/decrypt over arbitrary bit-length n satisfying ValidLength, using per-block tweaks and ciphertext stealing for a final partial block. (12) define a property stating that decrypt(encrypt(msg)) equals msg for all valid lengths."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::XTS where\n\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\ninterface constraint (C::BlockSize == 128)\n\nflipEndian : [128] -> [128]\nflipEndian x = join (reverse (groupBy`{8} x))\n\nproperty flipEndianInvolutive x = flipEndian (flipEndian x) == x\n\ntype constraint ValidLength n = (n \/^ C::BlockSize <= 2^^20, n >= C::BlockSize, fin n)\n\ndataUnitSeqNoToIV : {n} (n <= 128) => [n] -> [128]\ndataUnitSeqNoToIV S = flipEndian (zext S)\n\nproperty dataUnitSeqNoExample = dataUnitSeqNoToIV 0x123456789a == 0x9a785634120000000000000000000000\n\nmultAlphaLE : [128] -> [128]\nmultAlphaLE x = flipEndian (multAlpha (flipEndian x))\n  where\n    multAlpha p = pmod (pmult p alpha) irreducible\n\nalpha : [2]\nalpha = <| x |>\n\nirreducible : [129]\nirreducible = <| x^^128 + x^^7 + x^^2 + x + 1 |>\n\ngenerateTweaks : [C::KeySize] -> [128] -> [inf][128]\ngenerateTweaks K2 i = iterate multAlphaLE (C::encrypt K2 i)\n\nencryptBlock : [C::KeySize] -> [128] -> [128] -> [128]\nencryptBlock K T P = C\n  where\n            PP = T ^ P     CC = C::encrypt K PP     C  = CC ^ T \n\nencrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> [n]\nencrypt (K1 # K2) i P\n  | 0 == n % 128 =>\n    join\n      [ encryptBlock K1 T blk\n      | T <- generateTweaks K2 i\n      | blk <- split`{n \/ 128} P ]\n  | otherwise => C\n    where\n                  type M = n \/ 128\n\n                        T_0_m1 # [Tm1, Tm] = take`{M + 1} (generateTweaks K2 i)\n\n                        P_0_m2 # Pm1 # Pm = P\n\n            C_0_m2 = join [encryptBlock K1 T blk | T <- T_0_m1 | blk <- split`{M - 1} P_0_m2]\n\n            CC = encryptBlock K1 Tm1 Pm1\n\n            Cm # CP = CC\n\n            PP = Pm # CP\n\n            Cm1 = encryptBlock K1 Tm PP\n\n            C = C_0_m2 # Cm1 # Cm\n\ntype constraint otherwise = ()\n\ndecryptBlock : [C::KeySize] -> [128] -> [128] -> [128]\ndecryptBlock K T C = P\n  where\n            CC = C ^ T     PP = C::decrypt K CC     P = PP ^ T \n\ndecrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> [n]\ndecrypt (K1 # K2) i C\n  | 0 == n % 128 =>\n    join\n      [ decryptBlock K1 T blk\n      | T <- generateTweaks K2 i\n      | blk <- split`{n \/ 128} C ]\n  | otherwise => P\n    where\n            type M = n \/ 128\n\n            T_0_m2 # [Tm1, Tm] = take`{M + 1} (generateTweaks K2 i)\n\n            C_0_m2 # Cm1 # Cm = C\n\n            P_0_m2 = join [decryptBlock K1 T blk | T <- T_0_m2 | blk <- split`{M - 1} C_0_m2]\n\n            Pm # CP = decryptBlock K1 Tm Cm1\n\n            CC = Cm # CP\n\n            Pm1 = decryptBlock K1 Tm1 (Cm # CP)\n\n            P = P_0_m2 # Pm1 # Pm\n\ndecryptInvertsEncrypt : {n} (ValidLength n) => [2 * C::KeySize] -> [128] -> [n] -> Bool\nproperty decryptInvertsEncrypt K i P = decrypt K i (encrypt K i P) == P\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/TDES_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::TDES_CFB that contains the following definitions: (1) Import the TripleDES encrypt operation from the specified TripleDES module. (2) Type synonyms for 64-bit quantities: iv, block, k1, k2, and k3, each representing a 64-bit block. (3) A function cfbTDesEnc with a size parameter n constrained to be finite, taking three 64-bit keys, a 64-bit IV, and a sequence of n 64-bit plaintext blocks, returning a sequence of n 64-bit ciphertext blocks. It must implement Cipher Feedback mode for TripleDES: build the key schedule from the three keys; construct the feedback stream as the IV followed by the produced ciphertext; at each position, encrypt the current feedback block with TripleDES and XOR the result with the corresponding plaintext block to produce ciphertext. (4) A function cfbTDesDec with the same constraints and types as cfbTDesEnc, but taking ciphertext and returning plaintext. It must compute the same feedback stream (IV followed by the given ciphertext), encrypt each feedback block with TripleDES, and XOR with the corresponding ciphertext block to recover plaintext. (5) Define a property that, for any three 64-bit keys, a 64-bit IV, and any plaintext sequence of exactly three 64-bit blocks, decrypting the result of encrypting that plaintext with the same parameters yields the original plaintext. (6) Constants: a record testKey with fields k1=0x0123456789ABCDEF, k2=0x23456789ABCDEF01, k3=0x456789ABCDEF0123, iv=0xF69F2445DF4F9B17; a testPt list [0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]; and a testCt list [0x078BB74E59CE7ED6, 0x7666DE9CF95EAF3F, 0xE9ED6BB460F45152, 0x8A5F9FE4ED710918]. (7) Define a property that asserts encrypting testPt with testKey yields testCt and decrypting testCt yields testPt."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::TDES_CFB where\n\nimport Primitive::Symmetric::Cipher::Block::TripleDES (encrypt)\n\ntype iv = [64]\ntype block = [64]\n\ntype k1 = [64]\ntype k2 = [64]\ntype k3 = [64]\n\ncfbTDesEnc : {n} (fin n) => k1 -> k2 -> k3 -> iv -> [n]block -> [n]block\ncfbTDesEnc k1 k2 k3 iv ps = cs\n    where\n        ks = [ k1, k2, k3 ]\n        cs = [ (encrypt ks c') ^ p | p <- ps | c' <- [iv] # cs ]\n\ncfbTDesDec : {n} (fin n) => k1 -> k1 -> k3 -> iv -> [n]block -> [n]block\ncfbTDesDec k1 k2 k3 iv cts = pts\n    where\n        ks  = [ k1, k2, k3 ]\n        pts = [ (encrypt ks fb) ^ ct | ct <- cts | fb <- [iv] # cts ]\n\ncfbTDESEncryptDecryptInverts : k1 -> k2 -> k3 -> iv -> [3]block -> Bit\nproperty cfbTDESEncryptDecryptInverts k1 k2 k3 iv pt = pt == pt'\n    where\n        ct = cfbTDesEnc k1 k2 k3 iv pt\n        pt' = cfbTDesDec k1 k2 k3 iv ct\n\ntestKey = { k1=0x0123456789ABCDEF\n          , k2=0x23456789ABCDEF01\n          , k3=0x456789ABCDEF0123\n          , iv=0xF69F2445DF4F9B17\n          }\ntestPt = [0x6BC1BEE22E409F96, 0xE93D7E117393172A, 0xAE2D8A571E03AC9C, 0x9EB76FAC45AF8E51]\ntestCt = [0x078BB74E59CE7ED6, 0x7666DE9CF95EAF3F, 0xE9ED6BB460F45152, 0x8A5F9FE4ED710918]\n\nproperty testsPass = ct == testCt\n                  \/\\ pt == testPt\n    where\n        ct = cfbTDesEnc testKey.k1 testKey.k2 testKey.k3 testKey.iv testPt\n        pt = cfbTDesDec testKey.k1 testKey.k2 testKey.k3 testKey.iv testCt\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/AESKeyWrap.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Modes::AESKeyWrap that contains the following definitions: (1) Import the block-cipher interface as alias C and assert interface constraints that the key size is at least 64 bits and the block size is 128 bits. (2) Type synonyms: an 8-bit octet, and a semiblock equal to half the block size. (3) Constants for the AES-KW and RFC 5649 IVs with their standard values and widths (64-bit and 32-bit, respectively). (4) Wrappers for encryption\/decryption using the interface (encrypt\/decrypt). (5) Utilities: a converter from bitvectors to Integer, a length function returning the size parameter as Integer, and MSB\/LSB extractors with size and finiteness constraints. (6) Predicate constraints for plaintext\/ciphertext sizes for KW and KWP variants. (7) Core wrap W and unwrap WInv with polymorphic sizes n >= 3 and a bound on 6*(n\u22121) fitting in a semiblock; implement the NIST AES Key Wrap state machine over A and an array of R blocks, iterating t counters, using split\/join, concatenation, MSB\/LSB selection, and XOR; WInv performs the inverse in reverse t order. (8) A property showing WInv\u2218W is identity on valid inputs. (9) KW_AE (wrap) and KW_AD (unwrap) that prepend\/check the KW IV, producing\/consuming an Option value; include a property that unwrap\u2218wrap returns the original plaintext. (10) KWP_AE (RFC 5649) that constructs S with KWP IV, 32-bit length, and zero padding to 64-bit multiples; Step5 uses single-block encrypt when short, else W. (11) KWP_AD that verifies IV, length, and padding, extracting payload; Step3 uses single-block decrypt when short, else WInv; include a property that unwrap\u2218wrap returns the payload. (12) Simple properties validating hex\/binary literals, zero, concatenation, XOR, bit-length, MSB\/LSB, and integer conversions."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::AESKeyWrap where\n\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\ninterface constraint (C::KeySize >= 64)\ninterface constraint (C::BlockSize == 128)\n\ntype Octet = 8\n\ntype Semiblock = C::BlockSize \/ 2\n\nICV1 = 0xA6A6A6A6A6A6A6A6\n\nICV2 = 0xA65959A6\n\nCIPHK K X = C::encrypt K X\n\nCIPHInvK K X = C::decrypt K X\n\nint = toInteger\n\nlen : {n} (fin n) => [n] -> Integer\nlen _X = `n\n\nLSB : {s, n} (fin s, fin n, n >= s) => [n] -> [s]\nLSB = drop`{n - s}\n\nMSB : {s, n} (fin s, fin n, n >= s) => [n] -> [s]\nMSB = take`{s}\n\nproperty hexRepresentation = 0xA659 == 0b1010011001011001\n\nproperty zeroRepresentation = (zero : [8]) == 0b00000000\n\nproperty concatRepresentation = 0b001 # 0b10111 == 0b00110111\n\nproperty xorRepresentation = 0b10011 ^ 0b10101 == 0b00110\n\nproperty lenRepresentation = len 0b00010 == 5\n\nproperty signficanceWorks = lsb && msb where\n    X = 0b111011010\n    lsb = LSB`{3} X == 0b010\n    msb = MSB`{4} X == 0b1110\n\nproperty integerToString = (39 == 0b00100111) && ((39 : [8]) == 0b00100111)\n\nproperty stringToInteger = int 0b00011010 == 26\n\ntype constraint KW_Plaintext n = (2 <= n, width n <= 54)\n\ntype constraint KW_Ciphertext n = (3 <= n, n <= 2^^54)\n\ntype constraint KWP_Plaintext n = (1 <= n, width n <= 32)\n\ntype constraint KWP_Ciphertext n = (2 <= n, n <= 2^^29)\n\nW : {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n][Semiblock] -> [n * Semiblock]\nW K S = C where\n            type s = 6 * (n - 1)\n    A0 = S@0\n    R0 = drop`{1} S\n\n                    update_variables : ([Semiblock], [n-1][Semiblock]) -> [Semiblock]\n        -> ([Semiblock], [n-1][Semiblock])\n    update_variables (At1, Rt1) t = (At, Rt) where\n        At = MSB`{64} (CIPHK K (At1 # Rt1@0)) ^ t\n        Rnt = LSB`{64} (CIPHK K (At1 # Rt1@0))\n        Rt = drop`{1} Rt1 # [Rnt]\n\n    (As, Rs) = foldl update_variables (A0, R0) [1..s]\n\n        C1 = As\n    Cis = Rs\n    C = C1 # (join Cis)\n\nWInv : {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n][Semiblock] -> [n * Semiblock]\nWInv K C = S where\n            type s = 6 * (n - 1)\n    As = C@0\n    Rs = drop`{1} C\n\n                    update_variables : ([Semiblock], [n-1][Semiblock]) -> [Semiblock]\n        -> ([Semiblock], [n-1][Semiblock])\n    update_variables (At, Rt) t = (At1, Rt1) where\n        At1 = MSB`{64} (CIPHInvK K ((At ^ t) # Rt@`(n-2)))\n        R2t1 = LSB`{64} (CIPHInvK K ((At ^ t) # Rt@`(n-2)))\n        Rt1 = [R2t1] # take`{n-2} Rt\n\n    (A0, R0) = foldl update_variables (As, Rs) [s, s-1..1]\n\n        S1 = A0\n    Sis = R0\n    S = S1 # (join Sis)\n\nwrappingInverts :\n    {n} (fin n, n >= 3, width (6 * (n - 1)) <= Semiblock)\n    => [C::KeySize] -> [n * Semiblock] -> Bit\nproperty wrappingInverts K S = S == S' where\n    C = W K (split S)\n    S' = WInv K (split C)\n\nKW_AE : {n} (KW_Plaintext n)\n    => [C::KeySize] -> [n * Semiblock] -> [(n + 1) * Semiblock]\nKW_AE K P = C where\n    S = ICV1 # P\n    C = W K (split S)\n\nKW_AD : {n} (KW_Ciphertext n)\n    => [C::KeySize] -> [n * Semiblock] -> Option [(n - 1) * Semiblock]\nKW_AD K C = if MSB`{64} S != ICV1 then None\n    else Some (LSB`{64 * (n - 1)} S)\n    where\n        S = WInv K (split C)\n\nkeyWrapInverts : {n} (KW_Plaintext n) => [C::KeySize] -> [n * Semiblock] -> Bit\nproperty keyWrapInverts K P = inverts where\n    C = KW_AE K P\n    inverts = case (KW_AD K C) of\n        Some maybeP -> maybeP == P\n        None -> False\n\nKWP_AE : {n} (KWP_Plaintext n, KWP_Ciphertext (n \/^ 8 + 1))\n    => [C::KeySize] -> [n * Octet] -> [(n \/^ 8 + 1) * Semiblock]\nKWP_AE K P = C where\n            type lenP = 8 * n\n\n        type padlen = 8 * (lenP \/^ 64) - (lenP \/ 8)\n\n        PAD = zero : [8 * padlen]\n\n        S = ICV2 # (`(lenP \/ 8) : [32]) # P # PAD\n\n        C = KWP_AE_Step5`{n} K S\n\nKWP_AE_Step5: {n} (KWP_Plaintext n)\n    => [C::KeySize] -> [(n \/^ 8 + 1) * Semiblock] -> [(n \/^ 8 + 1) * Semiblock]\nKWP_AE_Step5 K S\n    | 8 * n <= 64 => CIPHK K S\n    | 8 * n > 64 => W K (split S)\n\nKWP_AD : {m, n} (KWP_Ciphertext n, KWP_Plaintext m, n == 1 + m \/^ 8)\n    => [C::KeySize] -> [n * Semiblock] -> Option [m * Octet]\nKWP_AD K C =\n    if (ICV2 != MSB`{32} S)                         || (padlen < 0)                             || (padlen > 7)                             || (zero   != LSB`{8 * m %^ 64} S)          || (Plen   != `m)                           || (padlen != `(m %^ 8))                then None\n    else Some P\n    where\n        S = KWP_AD_Step3 K C\n\n                Plen = int (LSB`{32} (MSB`{64} S))\n        padlen = 8 * (`n - 1) - Plen\n\n                P = MSB`{8 * m} (LSB`{64 * (n - 1)} S)\n\nKWP_AD_Step3 : {n} (KWP_Ciphertext n)\n    => [C::KeySize] -> [n * Semiblock] -> [n * 64]\nKWP_AD_Step3 K C\n    | n == 2 => CIPHInvK K C\n    | n > 2 => WInv K (split C)\n\nkeyWrapPaddedInverts : {n} (KWP_Ciphertext (n \/^ 8 + 1), KWP_Plaintext n)\n    => [C::KeySize] -> [n * Octet] -> Bit\nproperty keyWrapPaddedInverts K P = inverts where\n    C = KWP_AE K P\n    inverts = case (KWP_AD K C) of\n        Some maybeP -> maybeP == P\n        None -> False\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Modes::CFB that imports the block-cipher interface as C and contains the following definitions: (1) A polymorphic function encrypt with size parameters s and n (both finite) constrained so that 0 <= s <= C::BlockSize. It takes a key of C::KeySize bits, an initialization vector of C::BlockSize bits, and a sequence of n segments each of s bits, and returns a sequence of n segments each of s bits. Implement Cipher Feedback (CFB) mode using the block-cipher encryption under the given key: initialize the feedback register with the IV; for each segment, encrypt the current register to form a keystream block, XOR the first s bits of that block with the current plaintext segment to produce the ciphertext segment, then update the register by removing its first s bits and appending the produced ciphertext segment. (2) A function decrypt with the same polymorphic type and constraints that uses the same keystream generation and register update as encrypt, but XORs the keystream\u2019s first s bits with the ciphertext segment to recover the plaintext. (3) Define a property that, under the same constraints on s and n, for all keys, IVs, and plaintext sequences, applying decrypt with the same key and IV to the result of encrypt yields the original plaintext sequence. Provide clear type signatures reflecting the key size, block size, and sequence dimensions, and use the sizes exported by C for key and block widths."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::CFB where\nimport interface Primitive::Symmetric::Cipher::Block::CipherInterface as C\n\nencrypt : {s, n} (fin s, fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> [n][s]\nencrypt K IV Ps = Cs\n    where\n        CIPH_K = C::encrypt K\n        Is = [ (drop`{s} I_j_1) # C_j_1\n             | I_j_1 <- [IV] # Is\n             | C_j_1 <- Cs\n             ]\n        Cs = [ P_j ^ (take`{s} (CIPH_K I_j))\n             | P_j <- Ps\n             | I_j <- [IV] # Is\n             ]\n\ndecrypt : {s, n} (fin s, fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> [n][s]\ndecrypt K IV Cs = Ps\n    where\n        CIPH_K = C::encrypt K\n        Is = [ (drop`{s} I_j_1) # C_j_1\n             | I_j_1 <- [IV] # Is\n             | C_j_1 <- Cs\n             ]\n        Ps = [ C_j ^ (take`{s} (CIPH_K I_j))\n             | C_j <- Cs\n             | I_j <- [IV] # Is\n             ]\n\nencryptCorrect : {s, n} (fin n, s >= 0, s <= C::BlockSize)\n    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> Bool\nproperty encryptCorrect K IV Ps = (decrypt K IV (encrypt K IV Ps)) == Ps\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Simon\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Simon::Specification that contains: (1) Numeric type parameters n, m, j, and T with constraints: n and m are finite, n \u2265 4, 2 \u2264 m \u2264 4; j is finite with 0 \u2264 j < 5; T is finite with T > 4. (2) Functions on n-bit words: S (left rotate by i) and S_Inv (right rotate by i), polymorphic in a finite rotation amount i; f that mixes three rotated versions of its input. (3) Round transforms R and R_Inv that map a pair of n-bit words under an n-bit round key; include their types. (4) Helpers compose and composeMany for composing unary functions. (5) Encryption and decryption: encrypt and decrypt taking an m\u00b7n-bit key and a 2\u00b7n-bit block, using round keys from keySchedule and R\/R_Inv via function composition; also iterative variants encrypt' and decrypt' that accumulate rounds step-by-step and are extensionally equivalent. (6) Infinite bitstreams u, v, w, and t; derived streams z0..z4; a function extend that groups a stream into n-bit words; an array of extended streams and a selection by j; a constant c equal to 2^n \u2212 4; and a helper IS_Inv on n-bit words. (7) Key schedules keySchedule and keySchedule' that produce T n-bit round keys from m initial n-bit words, using the selected z-sequence; they must agree for all inputs and handle the m \u2208 {2,3,4} cases. (8) A linearMap for row-vector-by-matrix over XOR, 5\u00d75 matrices U, V, W, a generator seqn, and streams u', v', w' derived from those matrices. Also: define a property that decrypt inverts encrypt. define a property that encrypt equals the iterative encrypt. define a property that decrypt equals the iterative decrypt. define a property that S_Inv after S returns the input. define a property that R_Inv after R returns the input. define a property that different keys yield different key schedules. define a property that both key schedules are equivalent. define a property that the first 100 elements of each sequence (u, v, w) match its formal counterpart (u', v', w')."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Simon::Specification where\n\nparameter\n\n  type n : #\n\n  type m : #\n\n  type constraint (fin n, fin m, n >= 4, m >= 2, m <= 4)\n\n  type j : #\n  type constraint (j >= 0, j < 5)\n\n  type T : #\n\n  type constraint (fin T, T > 4)\n\nencrypt : [m * n] -> [2 * n] -> [2 * n]\nencrypt key plaintext = ciphertext\n  where\n    Simon_k = composeMany Rks\n            Rks = map R (keySchedule (reverse (split key)))\n    ciphertext = join (Simon_k (split plaintext))\n\ndecrypt : [m * n] -> [2 * n] -> [2 * n]\ndecrypt key ciphertext = plaintext\n  where\n    Simon_k = composeMany (reverse Rks)\n            Rks = map R_Inv (keySchedule (reverse (split key)))\n    plaintext = join (Simon_k (split ciphertext))\n\nprivate\n\n  property decryptInvertsEncrypt k pt = pt == decrypt k (encrypt k pt)\n\n  encrypt' : [m * n] -> [2 * n] -> [2 * n]\n  encrypt' key plaintext = join (rounds ! 0)\n    where\n      [x, y] = split plaintext\n      ks     = keySchedule' (reverse (split key))\n      \/\/ there are T round keys\n      \/\/ So, the following list comprehension runs over i = 0..T-1\n      rounds = [[x, y]] # [R k p | k <- ks | p <- rounds]\n\n  \/**\n   * Likewise, the decryption can be calculated in a more imperative fashion.\n   *\/\n  decrypt' : [m * n] -> [2 * n] -> [2 * n]\n  decrypt' key ciphertext = join (rounds ! 0)\n    where\n      [x, y] = split ciphertext\n      ks = keySchedule' (reverse (split key))\n      rounds = [[x, y]] # [R_Inv k ct | k <- (reverse ks) | ct <- rounds]\n\n  property encryptsEquivalent k p = encrypt k p == encrypt' k p\n\n  \/**\n   * The two formulations of decryption are functionally equiavalent.\n   *\n   * ```repl\n   * :check decryptsEquivalent\n   * ```\n   *\/\n  property decryptsEquivalent k p = decrypt k p == decrypt' k p\n\n  S : {i} (fin i) => [n] -> [n]\n  S x = x <<< `i\n\n  S_Inv : {i} (fin i) => [n] -> [n]\n  S_Inv x = x >>> `i\n\n  SInvertible : {i} (fin i) => [n] -> Bit\n  property SInvertible x = S_Inv `{i} (S `{i} x) == x\n\n  f : [n] -> [n]\n  f x = (S `{1} x && S `{8} x) ^ S `{2} x\n\n  R : [n] -> [2][n] -> [2][n]\n  R k [x, y] = [y ^ f x ^ k, x]\n\n  R_Inv : [n] -> [2][n] -> [2][n]\n  R_Inv k [x, y] = [y, x ^ f y ^ k]\n\n  property RInvertible k x = x == R_Inv k (R k x)\n\n  u : [inf]\n  u = 0b1111101000100101011000011100110 # u\n\n  v : [inf]\n  v = 0b1000111011111001001100001011010 # v\n\n  w : [inf]\n  w = 0b1000010010110011111000110111010 # w\n\n  t : [inf]\n  t = 0b01 # t\n\n  z0 = u\n\n  z1 = v\n\n  z2 = u ^ t\n\n  z3 = v ^ t\n\n  z4 = w ^ t\n\n  extend : [inf] -> [inf][n]\n  extend s = map (zext `{n}) (split `{inf, 1} s)\n\n  zjs = map extend [z0, z1, z2, z3, z4]\n\n  zj = zjs@`j\n\n  c : [n]\n  c = fromInteger (2 ^^ `n - 4)\n\n  IS_Inv : [n] -> [n]\n  IS_Inv x = x ^ S_Inv `{1} x\n\n  keySchedule : [m][n] -> [T][n]\n  keySchedule k0\n    | m == 2 => k where\n      k = k0 # [\n      c ^ zji ^ (k @ i) ^ IS_Inv (S_Inv `{3} (k @ (i+1)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n    | m == 3 => k where\n      k = k0 # [\n      c ^ zji ^ (k@i) ^ IS_Inv (S_Inv `{3} (k@(i+2)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n    | m == 4 => k where\n      k  = k0 # [\n      c ^ zji ^ (k@i) ^ IS_Inv (S_Inv `{3} (k@(i+3)) ^ (k@(i+1)))\n      | i <- [0..T-m-1]\n      | zji <- zj\n      ]\n\n  keySchedule' : [m][n] -> [T][n]\n  keySchedule' k0 = k\n    where\n      k = k0 # [ ki where\n                  tmp0 = k @ (i - 1) >>> 3\n                  tmp1 = if `m == 4 then tmp0 ^ k @ (i - 3) else tmp0\n                  tmp2 = tmp1 ^ tmp1 >>> 1\n                  ki = ~ k @ (i - `m) ^ tmp2 ^ z ^ 3\n                  z = zj @ ((i - `m) % 62)\n            | i <- [m .. T - 1]\n            ]\n\n  property keyScheduleInjective k p = k != p ==> keySchedule k != keySchedule p\n\n  property keySchedulesEquivalent k = keySchedule k == keySchedule' k\n\n  \/**\n   * Composition of functions `g` and `h`\n   * specialized to functions from `(a -> a)`.\n   *\/\n  compose : {a} () => (a -> a) -> (a -> a) -> a -> a\n  compose g h = \\x -> h (g x)\n\n  \/**\n   * Composition of many functions from `(a -> a)`\n   *\/\n  composeMany : {nf, a} (fin n) => [nf](a -> a) -> a -> a\n  composeMany fcns\n    | nf == 0 => \\x -> x\n    | nf == 1 => fcns@0\n    | nf == 2 => compose (fcns@0) (fcns@1)\n    | nf > 2  => compose (fcns@0) (composeMany (drop `{1} fcns))\n\n  \/**\n   * Multiplication of a row vector by a matrix\n   * This is not defined in the Simon specification.\n   * We take the straightforward approach of treating\n   * this as a linear combination of a subset of the\n   * matrix rows depending on which bits of the row vector are set.\n   *\/\n  linearMap : {rows, cols} (fin rows, fin cols) =>\n    [rows][cols] -> [rows] -> [cols]\n  linearMap matrix vector = foldl (^) zero matrix'\n    where\n      matrix' = map (\\(i, vi) -> if i then vi else zero) (zip vector matrix)\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `u`\n   * if the initial fill `0b00001` is used.\n   *\/\n  U = [ 0b01000\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10001\n      ]\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `v`\n   * if the initial fill `0b00001` is used.\n   *\/\n  V = [ 0b01100\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10000\n      ]\n\n  \/**\n   * A matrix form of a shift register\n   * that generates the sequence `w`\n   * if the initial fill `0b00001` is used.\n   *\/\n  W = [ 0b01000\n      , 0b00100\n      , 0b10010\n      , 0b00001\n      , 0b10000\n      ]\n\n  \/**\n   * A function that treats row vector - matrix multiplication\n   * as a shift register, generating the sequence of shift\n   * register outputs for a given initial fill.\n   *\/\n  seqn : [5][5] -> [inf]\n  seqn matrix = map (\\x -> x@4) steps\n    where\n      steps     = iterate (\\x -> linearMap matrix x) 0b00001\n\n  \/**\n   * A formal definition of the sequence `u`,\n   * given in Section 3.2 of [SIMON].\n   *\/\n  u' = seqn U\n\n  v' = seqn V\n\n  \/**\n   * A formal definition of the sequence `w`,\n   * given in Section 3.2 of [SIMON].\n   *\/\n  w' = seqn W\n\n  property uDefinitionEquivalence = take `{100} u == take `{100} u'\n\n  \/**\n   * A property encoding that the formal and informal definitions of `v`\n   * are equivalent.\n   *\n   * ```repl\n   * :check vDefinitionEquivalence\n   * ```\n   *\/\n  property vDefinitionEquivalence = take `{100} v == take `{100} v'\n\n  property wDefinitionEquivalence = take `{100} w == take `{100} w'\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Speck\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Speck::Specification that imports composeMany and compose from Common::utils. Declare type parameters n, m, and T with constraints: fin n, fin m, fin T; 2 <= m <= 4; T >= 2; n >= width T; and n >= 16. Define encrypt: [m*n] -> [2*n] -> [2*n] that splits a 2n-bit block into two n-bit words, derives round functions by scheduling keys from the m n-bit key words, composes the forward round transformers with composeMany, applies to the split state, then rejoins to 2n bits. Define decrypt with the same type that maps the inverse round over the schedule and composes them in reverse order before rejoining. Define S and S_Inv as n-bit rotations parameterized by a type-level j (left and right, respectively). Define S\u03b1 and S\u03b2 that choose rotation amounts based on n (use 7 and 2 when n equals 16, otherwise 8 and 3), and define their inverses S\u03b1_Inv and S\u03b2_Inv. Define the Speck round R: [n] -> [2][n] -> [2][n] using add-rotate-xor with S\u03b1_Inv and S\u03b2, and its inverse R_Inv. Provide factored helpers Rf1 and Rf2, and Rf that composes them to match R. Define keySchedule: [m][n] -> [T][n] that splits the key into an initial word and the remaining words, then iteratively produces T round keys using recurrences that update both the key stream and an auxiliary stream with S\u03b2 and S\u03b1_Inv and round indices. Define an equivalent keySchedule' using helpers derived from Rf1 and Rf2. Finally, define the following properties: decryptInvertsEncrypt (decrypt after encrypt returns the original block), RInvertible (R_Inv after R is identity), REquivalent (Rf equals R), keyScheduleInjective (distinct inputs yield distinct schedules), and keySchedulesEquivalent (both schedules are equal)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Speck::Specification where\n\nimport Common::utils (composeMany, compose)\n\nparameter\n\n    type n : #\n\n    type m : #\n\n    type T : #\n\n    type constraint (fin n, fin T, fin m)\n    type constraint (m >= 2, m <= 4, T >= 2, n >= width T)\n    type constraint (n >= 16)\n\nencrypt : [m * n] -> [2 * n] -> [2 * n]\nencrypt key plaintext = join (Speck_k (split plaintext))\n    where\n                                        Rks = map R (keySchedule (reverse (split key)))\n        Speck_k = composeMany Rks\n\ndecrypt : [m * n] -> [2 * n] -> [2 * n]\ndecrypt key ciphertext = join (Speck_k (split ciphertext))\n    where\n                Rks = map R_Inv (keySchedule (reverse (split key)))\n        Speck_k = composeMany (reverse Rks)\n\nprivate\n\n    property decryptInvertsEncrypt k x = decrypt k (encrypt k x) == x\n\n    S : {j} (fin j) => [n] -> [n]\n    S x = x <<< `j\n\n    S_Inv : {j} (fin j) => [n] -> [n]\n    S_Inv x = x >>> `j\n\n    S\u03b1: [n] -> [n]\n    S\u03b1 x | n == 16 => S `{7} x\n         | n >= 16 => S `{8} x\n\n    S\u03b2 : [n] -> [n]\n    S\u03b2 x | n == 16 => S `{2} x\n         | n >= 16 => S `{3} x\n\n    S\u03b1_Inv : [n] -> [n]\n    S\u03b1_Inv x | n == 16 => S_Inv `{7} x\n             | n >= 16 => S_Inv `{8} x\n\n    S\u03b2_Inv : [n] -> [n]\n    S\u03b2_Inv x | n == 16 => S_Inv `{2} x\n             | n >= 16 => S_Inv `{3} x\n\n    R : [n] -> [2][n] -> [2][n]\n    R k [x, y] = [(S\u03b1_Inv x + y) ^ k, S\u03b2 y ^ (S\u03b1_Inv x + y) ^ k]\n\n    R_Inv : [n] -> [2][n] -> [2][n]\n    R_Inv k [x, y] = [S\u03b1 ((x ^ k) - S\u03b2_Inv (x ^ y)), S\u03b2_Inv (x ^ y)]\n\n    property RInvertible k x = R_Inv k (R k x) == x\n\n    Rf1 : [n] -> [2][n] -> [2][n]\n    Rf1 k [x, y] = [y, (S\u03b1_Inv x + y) ^ k]\n\n    Rf2 : [2][n] -> [2][n]\n    Rf2 [x, y] = [y, S\u03b2 x ^ y]\n\n    Rf : [n] -> [2][n] -> [2][n]\n    Rf k s = f s\n        where\n            f = compose (Rf1 k) Rf2\n\n    property REquivalent k s = Rf k s == R k s\n\n    keySchedule : [m][n] -> [T][n]\n    keySchedule K = ks\n        where\n                        [k0] # li = K\n                        ks = [k0] # [S\u03b2 (ks @ i) ^ (ls @ (i + `m - 1)) | i <- [0..T - 2]]\n            ls = li # [(k + S\u03b1_Inv (ls @ i)) ^ i | k <- ks | i <- [0..T - 2] ]\n\n    property keyScheduleInjective k v = k != v ==> result\n        where\n            result = keySchedule k != keySchedule v\n\n    keySchedule' : [m][n] -> [T][n]\n    keySchedule' K = ks\n        where\n                        [k0] # li = K\n                        ks = [k0] # [f2 [(ks @ i), (ls @ (i + `m - 1))] | i <- [0..T - 2]]\n            ls = li # [f1 i [ls @ i, k] | k <- ks | i <- [0..T - 2] ]\n                                                f1 k s = (Rf1 k s) @ 1\n            f2 s = (Rf2 s) @ 1\n\n    property keySchedulesEquivalent K = keySchedule K == keySchedule' K\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/AES\/Specification.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::AES::Specification that imports the GF(2^8) utilities module under the alias GF28 and introduces a private type alias for the field element type. Parameterize the module by a numeric type KeySize' constrained to be finite, a multiple of 64, and in the set {128,192,256}. Derive Mode from the key size, and define Nk (words in key), Nr (rounds), Nb (state words = 4), and the exported aliases KeySize and BlockSize (128). Define types: State as a 4\u00d7Nb matrix of GF28 elements, RoundKey as 4\u00d74 GF28, and KeySchedule as (Nr+1) RoundKeys. Define functions and signatures: encrypt and decrypt mapping a KeySize-bit key and 128-bit block to a 128-bit block using cipher\/invCipher with keyExpansion; msgToState and stateToMsg as mutually inverse block\/state conversions using byte splitting and transposition; SBox and SBoxInv via private 256-entry lookup tables derived from multiplicative inversion in GF(2^8) and an affine transform; SubBytes\/InvSubBytes, ShiftRows\/InvShiftRows, MixColumns\/InvMixColumns (matrix multiplication over GF28 with the Rijndael matrices), and AddRoundKey as XOR. Define Rcon that returns the round constant word for a given 8-bit index. Define RotWord (1-byte left rotate) and SubWord (apply SBox to a word). Define keyExpansion for 32\u00b7Nk-bit keys to a (Nr+1) round schedule using the AES recurrence with the Nk==4\/6\/8 cases (including the extra SubWord at i mod Nk == 4 when Nk>6). Define cipher and invCipher as the AES forward and inverse round structures (initial add, Nr\u22121 full rounds, final round without MixColumns). Define a property aesIsCorrect asserting decrypt(encrypt(pt)) yields pt; define a property ioInverts stating state conversion round-trips; define a property SBox53 checking a known SBox test case; define a property SBoxInverts asserting SBoxInv \u2218 SBox is identity; define a property RconIsExponentiation asserting for indices 1..10 the first byte equals the field generator raised to (j\u22121); define properties subBytesInverts, shiftRowsInverts, and mixColumnsInverts asserting each inverse undoes its forward step."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::AES::Specification where\n\nimport Common::GF28 as GF28\nprivate type GF28 = GF28::GF28\n\nparameter\n      type KeySize' : #\n  type constraint (fin KeySize', KeySize' % 64 == 0, KeySize' \/ 64 >= 2,\n    KeySize' \/ 64 <= 4)\n\n\/**\n * The AES implementation uses the `Mode` type to compute other parameters.\n * The mode corresponds directly to the key size:\n * Mode 0 = 128 bits; Mode 1 = 192 bits; Mode 2 = 256 bits\n *\/\ntype Mode = (KeySize \/ 64) - 2\n\n\/\/ The following section encodes\n\n\/**\n * Key length: number of 32 bit words in the key.\n * [FIPS-197u1] Section 5, Table 3\n *\/\ntype Nk = 4 + 2 * Mode\n\n\/**\n * Number of rounds\n * [FIPS-197u1] Section 5, Table 3\n *\/\ntype Nr = 6 + Nk\n\n\/**\n * The number of words in the state is generic for the underlying Rijndael\n * algorithm, but in the standard it is fixed to 4.\n * [FIPS-197u1] Section 5.\n *\/\ntype Nb = 4\n\n\/\/ Make `KeySize` and `BlockSize` accessible outside the module.\n\/\/ This also lets us use AES as an instantiation of `CipherInterface`\ntype KeySize = KeySize'\ntype BlockSize = 128\n\nencrypt : [KeySize] -> [BlockSize] -> [BlockSize]\nencrypt k = cipher (keyExpansion k)\n\ndecrypt : [KeySize] -> [BlockSize] -> [BlockSize]\ndecrypt k = invCipher (keyExpansion k)\n\nproperty aesIsCorrect k pt = decrypt k (encrypt k pt) == pt\n\ntype State = [4][Nb]GF28\n\nmsgToState : [128] -> State\nmsgToState msg = transpose (split (split msg))\n\nstateToMsg : State -> [128]\nstateToMsg st = join (join (transpose st))\n\nproperty ioInverts msg = stateToMsg (msgToState msg) == msg\n\nsboxTable : [256]GF28\nprivate sboxTable = [ transform (GF28::inverse b) | b <- [0 .. 255] ] where\n        transform b = GF28::add [b, (b >>> 4), (b >>> 5), (b >>> 6), (b >>> 7), c]\n        c = 0x63\n\nSBox : GF28 -> GF28\nSBox b = sboxTable @ b\n\nproperty SBox53 = SBox 0x53 == 0xed\n\nsboxInvTable : [256]GF28\nprivate sboxInvTable = [ GF28::inverse (transformInv b) | b <- [0 .. 255] ] where\n    transformInv b = GF28::add [(b >>> 2), (b >>> 5), (b >>> 7), d]\n    d = 0x05\n\nSBoxInv : GF28 -> GF28\nSBoxInv b = sboxInvTable @ b\n\nproperty SBoxInverts b = SBoxInv (SBox b) == b\n\ntype RoundKey = [4][4]GF28\n\ntype KeySchedule = [Nr+1]RoundKey\n\ncipher: KeySchedule -> [128] -> [128]\ncipher w pt = stateToMsg final_state   where\n        state0 = AddRoundKey (w @ 0) (msgToState pt)\n        state4 = foldl transform state0 (w @@ [1 .. (Nr - 1)])\n        transform state word = AddRoundKey word (MixColumns (ShiftRows (SubBytes state)))\n        final_state = AddRoundKey (w @ `Nr) (ShiftRows (SubBytes (state4)))\n\nSubBytes : State -> State\nSubBytes state = [ [ SBox b | b <- row ] | row <- state ]\n\nShiftRows : State -> State\nShiftRows state = [ row <<< i | row <- state | i : [2] <- [0 .. 3] ]\n\nMixColumns : State -> State\nMixColumns state = GF28::matrixMult m state\n    where m = [ [2,3,1,1] >>> i | i : [2] <- [0 .. 3] ]\n\nAddRoundKey : RoundKey -> State -> State\nAddRoundKey w state = w ^ state\n\nRcon : [8] -> [4]GF28\nRcon j = constants @ (j - 1) where\n    constants = [\n        [0x01, 0x00, 0x00, 0x00],\n        [0x02, 0x00, 0x00, 0x00],\n        [0x04, 0x00, 0x00, 0x00],\n        [0x08, 0x00, 0x00, 0x00],\n        [0x10, 0x00, 0x00, 0x00],\n        [0x20, 0x00, 0x00, 0x00],\n        [0x40, 0x00, 0x00, 0x00],\n        [0x80, 0x00, 0x00, 0x00],\n        [0x1b, 0x00, 0x00, 0x00],\n        [0x36, 0x00, 0x00, 0x00]\n    ]\n\nRconIsExponentiation : [8] -> Bit\nproperty RconIsExponentiation j = (1 <= j) && (j <= 10) ==>\n    (Rcon j)@0 == GF28::pow <| x |> (j-1)\n\nRotWord : [4]GF28 -> [4]GF28\nRotWord [a0, a1, a2, a3] = [a1, a2, a3, a0]\n\nSubWord : [4]GF28 -> [4]GF28\nSubWord [a0, a1, a2, a3] = [ SBox a0, SBox a1, SBox a2, SBox a3 ]\n\nkeyExpansion : [32 * Nk] -> [Nr+1]RoundKey\nkeyExpansion key = keys\n  where\n        seed : [Nk][4]GF28\n    seed = split (split key)\n\n        ws : [inf][4]GF28\n    ws = seed # [ nextWord i w_1 w_nk\n       | i    <- [ `Nk ... ]\n       | w_1  <- drop`{Nk-1} ws\n       | w_nk <- ws\n       ]\n\n                nextWord : [8] ->[4]GF28 -> [4]GF28 -> [4]GF28\n    nextWord i w_1 w_nk = w_i where\n            temp =\n                if i % `Nk == 0 then\n          SubWord (RotWord w_1) ^ Rcon (i \/ `Nk)\n                else if (`Nk > 6) && (i % `Nk == 4) then\n          SubWord w_1\n                else w_1\n\n            w_i = w_nk ^ temp\n\n            keys = take `{Nr+1} [ transpose g | g <- split ws ]\n\ninvCipher: KeySchedule -> [128] -> [128]\ninvCipher w ct = stateToMsg final_state   where\n        state0 = AddRoundKey (w @ `Nr) ( msgToState ct)\n        state4 = foldl transform state0 (reverse (w @@ [1 .. (Nr - 1)]))\n        transform state word = InvMixColumns (AddRoundKey word (InvSubBytes (InvShiftRows state)))\n        final_state = AddRoundKey (w @ 0) (InvSubBytes (InvShiftRows (state4)))\n\nInvShiftRows : State -> State\nInvShiftRows state = [ row >>> i | row <- state | i : [2] <- [0 .. 3] ]\n\nInvSubBytes : State -> State\nInvSubBytes state = [ [ SBoxInv b | b <- row ] | row <- state ]\n\nInvMixColumns : State -> State\nInvMixColumns state = GF28::matrixMult m state\n    where m = [[0x0e, 0x0b, 0x0d, 0x09] >>> i | i : [2] <- [0 .. 3] ]\n\nsubBytesInverts : State -> Bool\nproperty subBytesInverts s = InvSubBytes (SubBytes s) == s\n\nshiftRowsInverts : State -> Bool\nproperty shiftRowsInverts s = InvShiftRows (ShiftRows s) == s\n\nmixColumnsInverts : State -> Bool\nproperty mixColumnsInverts s = InvMixColumns (MixColumns s) == s\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR that imports Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR (you may alias it). Inside, include two definitions: (1) property aes256_ctr_encrypt_vector asserting that calling the imported encrypt function with a 256-bit key, a 128-bit initial counter, and a sequence of four 128-bit plaintext blocks yields the expected sequence of four 128-bit ciphertext blocks; and (2) property aes256_ctr_decrypt_vector asserting that calling the imported decrypt function with the same key and initial counter on the ciphertext recovers the original plaintext. Provide the constants for key, initial counter, plaintext blocks, and ciphertext blocks using the AES-256 CTR test vectors from NIST SP 800-38A (section F.5.5). Use local where-bindings to define these constants within each property. Ensure the function calls are qualified to the imported module, the key has width 256 bits, the counter has width 128 bits, and the plaintext\/ciphertext values are sequences of length 4 of 128-bit blocks. The properties must evaluate to boolean equalities suitable for solver checking."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR as AES256_CTR\n\nproperty aes256_ctr_encrypt_vector = (AES256_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x601ec313775789a5b7a7f504bbf3d228,\n        0xf443e3ca4d62b59aca84e990cacaf5c5,\n        0x2b0930daa23de94ce87017ba2d84988d,\n        0xdfc9c58db67aada613c2dd08457941a6]\n\nproperty aes256_ctr_decrypt_vector = (AES256_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x601ec313775789a5b7a7f504bbf3d228,\n        0xf443e3ca4d62b59aca84e990cacaf5c5,\n        0x2b0930daa23de94ce87017ba2d84988d,\n        0xdfc9c58db67aada613c2dd08457941a6]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CFB that imports Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB as AES192_CFB and contains the following definitions: aes192_cfb1_encrypt_vector, aes192_cfb1_decrypt_vector, aes192_cfb8_encrypt_vector, aes192_cfb8_decrypt_vector, aes192_cfb128_encrypt_vector, aes192_cfb128_decrypt_vector. For each named definition, define a property that asserts equality between the AES192_CFB encrypt\/decrypt result and an expected test vector, using a single fixed 192-bit key and a single fixed 128-bit IV. Use local bindings (where-clauses) to bind the key, IV, plaintext, and ciphertext constants. Segment sizes and shapes: for the 1-bit CFB case, use a length-16 sequence of bits; for the 8-bit CFB case, use a length-18 sequence of bytes; for the 128-bit CFB case, use a length-4 sequence of 128-bit blocks. The \u201cencrypt_vector\u201d properties must assert that AES192_CFB::encrypt key iv plaintext equals ciphertext, and the corresponding \u201cdecrypt_vector\u201d properties must assert that AES192_CFB::decrypt key iv ciphertext equals plaintext. Ensure the literal widths of the key, IV, plaintext, and ciphertext make each call well-typed and that each property is a Boolean suitable for solver checking."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB as AES192_CFB\n\nproperty aes192_cfb1_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b1, 0b1,\n            0b0, 0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1\n        ]\n\nproperty aes192_cfb1_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b1, 0b1,\n            0b0, 0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\nproperty aes192_cfb8_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0xcd, 0xa2, 0x52, 0x1e, 0xf0, 0xa9, 0x05, 0xca, 0x44,\n            0xcd, 0x05, 0x7c, 0xbf, 0x0d, 0x47, 0xa0, 0x67, 0x8a\n        ]\n\nproperty aes192_cfb8_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xcd, 0xa2, 0x52, 0x1e, 0xf0, 0xa9, 0x05, 0xca, 0x44,\n            0xcd, 0x05, 0x7c, 0xbf, 0x0d, 0x47, 0xa0, 0x67, 0x8a\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\nproperty aes192_cfb128_encrypt_vector = (AES192_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0xcdc80d6fddf18cab34c25909c99a4174,\n            0x67ce7f7f81173621961a2b70171d3d7a,\n            0x2e1e8a1dd59b88b1c8e60fed1efac4c9,\n            0xc05f9f9ca9834fa042ae8fba584b09ff\n        ]\n\nproperty aes192_cfb128_decrypt_vector = (AES192_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n        iv =  0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xcdc80d6fddf18cab34c25909c99a4174,\n            0x67ce7f7f81173621961a2b70171d3d7a,\n            0x2e1e8a1dd59b88b1c8e60fed1efac4c9,\n            0xc05f9f9ca9834fa042ae8fba584b09ff\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a Cryptol module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CTR that imports Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CTR as AES128_CTR and contains the following definitions: two properties named aes128_ctr_encrypt_vector and aes128_ctr_decrypt_vector. Each property is a boolean assertion. In aes128_ctr_encrypt_vector, locally bind constants for a 128-bit key, a 128-bit initial counter, a sequence of four 128-bit plaintext blocks, and the corresponding sequence of four 128-bit ciphertext blocks taken from the first NIST AES-128 CTR test vector; assert that calling AES128_CTR.encrypt with the key, counter, and plaintext equals the expected ciphertext sequence. In aes128_ctr_decrypt_vector, reuse the same key and initial counter, locally bind the ciphertext and plaintext sequences from that test vector, and assert that calling AES128_CTR.decrypt with the key, counter, and ciphertext equals the expected plaintext sequence. Ensure types reflect AES-128 CTR: the key and counter are 128-bit words, and the plaintext\/ciphertext are sequences of four 128-bit blocks. Use the AES128_CTR module alias when invoking encrypt and decrypt."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CTR as AES128_CTR\n\nproperty aes128_ctr_encrypt_vector = (AES128_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x874d6191b620e3261bef6864990db6ce,\n        0x9806f66b7970fdff8617187bb9fffdff,\n        0x5ae4df3edbd5d35e5b4f09020db03eab,\n        0x1e031dda2fbe03d1792170a0f3009cee]\n\nproperty aes128_ctr_decrypt_vector = (AES128_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x874d6191b620e3261bef6864990db6ce,\n        0x9806f66b7970fdff8617187bb9fffdff,\n        0x5ae4df3edbd5d35e5b4f09020db03eab,\n        0x1e031dda2fbe03d1792170a0f3009cee]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CFB that imports Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CFB as AES256_CFB. Inside, define six properties: aes256_cfb1_encrypt_vector, aes256_cfb1_decrypt_vector, aes256_cfb8_encrypt_vector, aes256_cfb8_decrypt_vector, aes256_cfb128_encrypt_vector, and aes256_cfb128_decrypt_vector. In each property, bind local constants: a 256-bit key, a 128-bit initialization vector, and fixed plaintext\/ciphertext test vectors. For CFB1, use a sequence of 16 bits; for CFB8, use a sequence of 18 bytes; for CFB128, use a sequence of four 128-bit blocks. The encrypt properties must assert that AES256_CFB::encrypt applied to the key, IV, and plaintext equals the expected ciphertext. The decrypt properties must assert that AES256_CFB::decrypt applied to the key, IV, and ciphertext equals the expected plaintext. Use exactly the provided constants and lengths, ensuring types match AES-256 with a 128-bit block size and the respective CFB segment sizes so that each equality is a well-typed Boolean suitable for solver checking."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CFB as AES256_CFB\n\nproperty aes256_cfb1_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b0, 0b0,\n            0b0, 0b0, 0b1, 0b0, 0b1, 0b0, 0b0, 0b1\n        ]\n\nproperty aes256_cfb1_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b1, 0b0, 0b0, 0b1, 0b0, 0b0, 0b0, 0b0,\n            0b0, 0b0, 0b1, 0b0, 0b1, 0b0, 0b0, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\nproperty aes256_cfb8_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0xdc, 0x1f, 0x1a, 0x85, 0x20, 0xa6, 0x4d, 0xb5, 0x5f,\n            0xcc, 0x8a, 0xc5, 0x54, 0x84, 0x4e, 0x88, 0x97, 0x00\n        ]\n\nproperty aes256_cfb8_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xdc, 0x1f, 0x1a, 0x85, 0x20, 0xa6, 0x4d, 0xb5, 0x5f,\n            0xcc, 0x8a, 0xc5, 0x54, 0x84, 0x4e, 0x88, 0x97, 0x00\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\nproperty aes256_cfb128_encrypt_vector = (AES256_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0xdc7e84bfda79164b7ecd8486985d3860,\n            0x39ffed143b28b1c832113c6331e5407b,\n            0xdf10132415e54b92a13ed0a8267ae2f9,\n            0x75a385741ab9cef82031623d55b1e471\n        ]\n\nproperty aes256_cfb128_decrypt_vector = (AES256_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n        iv =  0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0xdc7e84bfda79164b7ecd8486985d3860,\n            0x39ffed143b28b1c832113c6331e5407b,\n            0xdf10132415e54b92a13ed0a8267ae2f9,\n            0x75a385741ab9cef82031623d55b1e471\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CTR.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CTR that imports the AES-192 CTR instantiation as AES192_CTR and contains exactly two properties: aes192_ctr_encrypt_vector and aes192_ctr_decrypt_vector. The first property must assert that calling encrypt with a fixed 192-bit key, a fixed 128-bit initial counter block, and a list of four 128-bit plaintext blocks produces the expected list of four 128-bit ciphertext blocks. The second property must assert that calling decrypt with the same key and counter on that ciphertext list reproduces the original plaintext list. Use the standard NIST SP 800-38A AES-CTR 192-bit test vector values for the key, initial counter, plaintext, and ciphertext, provided as local constants within each property. Clearly indicate the bit widths: key as 192 bits, counter as 128 bits, and plaintext\/ciphertext as lists of four 128-bit blocks. Do not implement AES; only invoke the imported encrypt and decrypt functions and assert equality of results."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CTR where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CTR as AES192_CTR\n\nproperty aes192_ctr_encrypt_vector = (AES192_CTR::encrypt k ic plaintext) == ciphertext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x1abc932417521ca24f2b0459fe7e6e0b,\n        0x090339ec0aa6faefd5ccc2c6f4ce8e94,\n        0x1e36b26bd1ebc670d1bd1d665620abf7,\n        0x4f78a7f6d29809585a97daec58c6b050]\n\nproperty aes192_ctr_decrypt_vector = (AES192_CTR::decrypt k ic ciphertext) == plaintext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\n    ciphertext = [\n        0x1abc932417521ca24f2b0459fe7e6e0b,\n        0x090339ec0aa6faefd5ccc2c6f4ce8e94,\n        0x1e36b26bd1ebc670d1bd1d665620abf7,\n        0x4f78a7f6d29809585a97daec58c6b050]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CFB.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CFB that contains the following definitions: aes128_cfb1_encrypt_vector, aes128_cfb1_decrypt_vector, aes128_cfb8_encrypt_vector, aes128_cfb8_decrypt_vector, aes128_cfb128_encrypt_vector, and aes128_cfb128_decrypt_vector. Import the AES-128 CFB instantiation under the alias AES128_CFB and use its encrypt and decrypt functions. For each property, declare four local constants: a 128-bit key, a 128-bit initialization vector, a plaintext, and a ciphertext drawn from fixed test vectors. In the \u201c1\u201d variants, plaintext and ciphertext are sequences of 16 single-bit elements; in the \u201c8\u201d variants, they are sequences of bytes of equal length; in the \u201c128\u201d variants, they are sequences of four 128-bit blocks. The encrypt properties assert that encrypt(key, iv, plaintext) equals the expected ciphertext. The decrypt properties assert that decrypt(key, iv, ciphertext) equals the expected plaintext. Each property is a boolean equality suitable for solver checking, with no additional constraints beyond matching types and lengths appropriate to the segment sizes (1, 8, and 128)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CFB where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB as AES128_CFB\n\nproperty aes128_cfb1_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n        ciphertext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b0, 0b0,\n            0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1, 0b1\n        ]\n\nproperty aes128_cfb1_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b0, 0b0,\n            0b1, 0b0, 0b1, 0b1, 0b0, 0b0, 0b1, 0b1\n        ]\n        plaintext = [\n            0b0, 0b1, 0b1, 0b0, 0b1, 0b0, 0b1, 0b1,\n            0b1, 0b1, 0b0, 0b0, 0b0, 0b0, 0b0, 0b1\n        ]\n\nproperty aes128_cfb8_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n        ciphertext = [\n            0x3b, 0x79, 0x42, 0x4c, 0x9c, 0x0d, 0xd4, 0x36, 0xba,\n            0xce, 0x9e, 0x0e, 0xd4, 0x58, 0x6a, 0x4f, 0x32, 0xb9\n        ]\n\nproperty aes128_cfb8_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0x3b, 0x79, 0x42, 0x4c, 0x9c, 0x0d, 0xd4, 0x36, 0xba,\n            0xce, 0x9e, 0x0e, 0xd4, 0x58, 0x6a, 0x4f, 0x32, 0xb9\n        ]\n        plaintext = [\n            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9,\n            0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae, 0x2d\n        ]\n\nproperty aes128_cfb128_encrypt_vector = (AES128_CFB::encrypt key iv plaintext) == ciphertext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n        ciphertext = [\n            0x3b3fd92eb72dad20333449f8e83cfb4a,\n            0xc8a64537a0b3a93fcde3cdad9f1ce58b,\n            0x26751f67a3cbb140b1808cf187a4f4df,\n            0xc04b05357c5d1c0eeac4c66f9ff7f2e6\n        ]\n\nproperty aes128_cfb128_decrypt_vector = (AES128_CFB::decrypt key iv ciphertext) == plaintext\n    where\n        key = 0x2b7e151628aed2a6abf7158809cf4f3c\n        iv  = 0x000102030405060708090a0b0c0d0e0f\n        ciphertext = [\n            0x3b3fd92eb72dad20333449f8e83cfb4a,\n            0xc8a64537a0b3a93fcde3cdad9f1ce58b,\n            0x26751f67a3cbb140b1808cf187a4f4df,\n            0xc04b05357c5d1c0eeac4c66f9ff7f2e6\n        ]\n        plaintext = [\n            0x6bc1bee22e409f96e93d7e117393172a,\n            0xae2d8a571e03ac9c9eb76fac45af8e51,\n            0x30c81c46a35ce411e5fbc1191a0a52ef,\n            0xf69f2445df4f9b17ad2b417be66c3710\n        ]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES192_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CBC that contains the following definitions: import the AES-192 CBC instantiation module as AES192_CBC; define a property named aes192_cbc_encrypt_vector that asserts AES192_CBC::encrypt applied to a fixed 192-bit key, a fixed 128-bit IV, and a list of four 128-bit plaintext blocks produces the corresponding list of four 128-bit ciphertext blocks; define a property named aes192_cbc_decrypt_vector that asserts AES192_CBC::decrypt applied to the same key and IV and the ciphertext list recovers the original plaintext list. In each property, introduce constants via a where-block with types k:[192], iv:[128], plaintext:[4][128], ciphertext:[4][128], and bind them to specific literal values from a standard AES-192 CBC test vector with four blocks. Use the encrypt\/decrypt functions from AES192_CBC by qualified name; do not redefine them. Ensure the plaintext and ciphertext sequences are ordered per block index and the assertions compare entire sequences for equality."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES192_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CBC as AES192_CBC\n\nproperty aes192_cbc_encrypt_vector = (AES192_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x4f021db243bc633d7178183a9fa071e8,\n        0xb4d9ada9ad7dedf4e5e738763f69145a,\n        0x571b242012fb7ae07fa9baac3df102e0,\n        0x08b0e27988598881d920a9e64f5615cd]\n\nproperty aes192_cbc_decrypt_vector = (AES192_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0x4f021db243bc633d7178183a9fa071e8,\n        0xb4d9ada9ad7dedf4e5e738763f69145a,\n        0x571b242012fb7ae07fa9baac3df102e0,\n        0x08b0e27988598881d920a9e64f5615cd]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CBC that contains the following definitions: import the AES-256-CBC instantiation module qualified as AES256_CBC; a property named aes256_cbc_encrypt_vector; and a property named aes256_cbc_decrypt_vector. For aes256_cbc_encrypt_vector, define local bindings for a 256-bit key, a 128-bit IV, a plaintext sequence of four 128-bit blocks, and an expected ciphertext sequence of four 128-bit blocks, all as fixed hexadecimal literals from a standard AES-256-CBC known-answer test. The property must assert that calling AES256_CBC.encrypt with the key, IV, and plaintext yields the expected ciphertext (equality check). For aes256_cbc_decrypt_vector, reuse the same key and IV, define the same ciphertext and plaintext sequences, and assert that calling AES256_CBC.decrypt with the key, IV, and ciphertext yields the original plaintext (equality check). Use where-bound local constants in each property. Ensure type consistency: key has type [256], IV has type [128], plaintext and ciphertext each have type [4][128]. Do not introduce padding or partial blocks; the data are exactly four full blocks. Keep both properties as boolean conditions suitable for solver checking."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CBC as AES256_CBC\n\nproperty aes256_cbc_encrypt_vector = (AES256_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0xf58c4c04d6e5f1ba779eabfb5f7bfbd6,\n        0x9cfc4e967edb808d679f777bc6702c7d,\n        0x39f23369a9d9bacfa530e26304231461,\n        0xb2eb05e2c39be9fcda6c19078c6a9d1b]\n\nproperty aes256_cbc_decrypt_vector = (AES256_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0xf58c4c04d6e5f1ba779eabfb5f7bfbd6,\n        0x9cfc4e967edb808d679f777bc6702c7d,\n        0x39f23369a9d9bacfa530e26304231461,\n        0xb2eb05e2c39be9fcda6c19078c6a9d1b]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES256_KeyWrapPadded_AE.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_KeyWrapPadded_AE that contains the following definitions: (1) an import of Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap to use the AES-256 Key Wrap with padding operation; (2) a Boolean-valued function check_KWP_AE that takes a 256-bit key, an 8-bit plaintext byte, and a 128-bit expected ciphertext, and returns whether applying the imported key-wrap-with-padding function to the key and plaintext equals the expected ciphertext; (3) properties tcId1001 through tcId1100. For each property, introduce a where-clause that binds: a local constant testPassed set to True; a 256-bit key test vector; an 8-bit plaintext test vector; and a 128-bit ciphertext test vector. The property must assert that testPassed is equal to the result of check_KWP_AE applied to the bound key, plaintext, and ciphertext. Ensure each property is a closed Boolean suitable for solver checking, and that the function and properties use the exact names given above. Clearly specify the argument widths ([256], [8], [128]) and that check_KWP_AE returns a single Bit (boolean)."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_KeyWrapPadded_AE where\n\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap\n\ncheck_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct\n\nproperty tcId1001 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x39FA276B26B762599AA1070192987D0CF8184DDB1C98EEA23F06FF81B63481E0\n    pt = 0x8D\n    ct = 0x35A739A8A322805B94DEB3CB1A56A008\n\nproperty tcId1002 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF80E0BDD0D1B3407F241522045574E3C80CA99D3A6854706047942EB694CDBF3\n    pt = 0xC5\n    ct = 0x9581CB7E06C38D57C5262A7BD4BD8840\n\nproperty tcId1003 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC93821958B2A3AC969FFCA59EF5623E609F38585A6C9A9ADE41D546578DE141D\n    pt = 0x1E\n    ct = 0xDD6DC03E825F2E77480F998902FA6BE8\n\nproperty tcId1004 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF6C4018216BC7EAB22D57893BE5E9E3A2A7189813E37D26BFD8A866BADE775F8\n    pt = 0xE3\n    ct = 0x56F07FA0F5512B159F5E70A50C442B0B\n\nproperty tcId1005 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDC426450A27CCAD9B7890661B13480D2225918AAC7C03829512492865763ABDC\n    pt = 0x3F\n    ct = 0x686DE8ABFFBEDF79AAFD4432ECD4CF50\n\nproperty tcId1006 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x44F2DE705C848A3448FF6FFCBD221C0DC2119351D384CE21D5AC2606FE21B6F8\n    pt = 0xDA\n    ct = 0xE4B9BC2CE14293EAF05955A42627269D\n\nproperty tcId1007 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC933E2E4EE7D519FA406AA70EAC833CCD50FBB044427B1D25624254A555EDC43\n    pt = 0x1E\n    ct = 0x901B3CE56E12F8C188039535EBA61996\n\nproperty tcId1008 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x6E0627242E7C51B204DB46A58D6A411B96514555CF8C21DD8B2DC37CDA95F9CD\n    pt = 0x15\n    ct = 0x2AD76F428813B950D099C10105A29FB5\n\nproperty tcId1009 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1FD3508E9533EC697E4B8F59FFFE4B98857919A4DEF918426D068F70F3B2948E\n    pt = 0x02\n    ct = 0x530967E906FD940C887A6AD9F37AC42D\n\nproperty tcId1010 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x85BFD16F7B562AD251329106A3D7A184C5C96CCE489B2DD797A084A72404376D\n    pt = 0x94\n    ct = 0xEFC758A879A703D39B7B85F7BB7B2D44\n\nproperty tcId1011 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDDD6FAB4C49DD7FF2985AE928BD5EA87CC70A31163074F1FB1BC02F7F969D418\n    pt = 0x86\n    ct = 0xBD96D9C865A87BE05A306AB3D6BBA3A5\n\nproperty tcId1012 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDA37F25B6EBE88C9DB9E03A5E126D5AE55F632B1686115C956228326A0DBC789\n    pt = 0xA9\n    ct = 0xAC58CFA83697E911CD09BEA23CA4CD45\n\nproperty tcId1013 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1BB566FE462A27901D86EEF8558F53E505E47D81A66F2918AADE08EA347201B3\n    pt = 0x1D\n    ct = 0x8A51E6B709CB04F59981F7FFDB783D0B\n\nproperty tcId1014 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x73B2AB98DDC2A3557AC51C1976D43F2997D4305D6C1D8DE38B393161DE44A1BA\n    pt = 0x54\n    ct = 0x281900A08220B5F74CF06D739F7C5DC6\n\nproperty tcId1015 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCACF12AE11477B1254437CA92D329F1C7EE6B2C022E4F12C3EAC649621AB0137\n    pt = 0xE2\n    ct = 0x6DCC8657EC2A2443DD056EF73DBBFB7B\n\nproperty tcId1016 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3E7517AE08DA6B2B027AC829D0D96FB0D2B27C611D217174FFF385EEA51ABC9F\n    pt = 0x7E\n    ct = 0x542A995D5BEB0FEF0CA3B56DB914E0DF\n\nproperty tcId1017 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x636062EAF492C67B4E98DC4653031942CE29FB1B81462A31FCA2A40DF760ED1F\n    pt = 0x9C\n    ct = 0x9F24ED46467485D4ED54D232E50E8885\n\nproperty tcId1018 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x86CF07CC35A7624129A9390B14EE6FA8B8D7A9F613050E7CE3E3AF3CAD54ABB3\n    pt = 0x75\n    ct = 0x76A00B69214577BAD18CCDC983C8BAFD\n\nproperty tcId1019 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC4C825E849AE1C195748979D8821711590403E3AC47984C526DF896D120E7396\n    pt = 0x9E\n    ct = 0x5808672A0F4EEDD81328D99819993EB7\n\nproperty tcId1020 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFF84BC98909D273B28F0AC9D0C44386533BFE6A0586294D57DF370FFECCDDB3F\n    pt = 0xC9\n    ct = 0xDA9785C2ADC2CE92EFF5E3523D469235\n\nproperty tcId1021 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x8670FB10B54781839B56C7A14C660412FE2E48F3655ACC55553B794D9FFA32B7\n    pt = 0xF0\n    ct = 0x8850EF6CB7396E775D4F330C6E01EDCE\n\nproperty tcId1022 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x211A909A1C1B0F56BEBBF3362DC2CD75AB14BB2CB4EB191557B5ABAC7EF9E4E4\n    pt = 0x19\n    ct = 0xC76400B498AEB0023E266AFF9EE30FE8\n\nproperty tcId1023 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xB77EBA3E4E1FD9D5989A233E66BFC9CBB8CF245C9DCF7C59AF1D5FDD4811D76A\n    pt = 0xC0\n    ct = 0xC8869A194252053D69CB3700B519B400\n\nproperty tcId1024 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x96A325D96DF23193F21C409B20B83B157E4BC00E7B872A96D57EA7791575B797\n    pt = 0x60\n    ct = 0x9C5C1DCBFE8CEA38DED462DC2268D090\n\nproperty tcId1025 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x67BA246D02CBBBEDDE0B24C8DD8EE9ECF80DC34ECF0A211B1967BC141265F099\n    pt = 0x00\n    ct = 0x38AE876F1E45933C75D8B57531B59075\n\nproperty tcId1026 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x81C3403F359326663B025C16865E245808C4848A54011F6B88385A1A64FBECBC\n    pt = 0xC2\n    ct = 0x8C0DEC2FD4B6AB0231EC56BD50852D84\n\nproperty tcId1027 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x428666365FFAE2B604A71E3EA61D1AB85CFCDEDEF5D40CFE8E53FDB96AC27630\n    pt = 0x1D\n    ct = 0x48D46E384AE3AA2BDCEC10399A82BE37\n\nproperty tcId1028 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x859857F302D7B4BECF1220B55857A1DF064355AB306E9E9C3FEC3DC86FAFCC3A\n    pt = 0x91\n    ct = 0x7E0CF4C530ED36B947CA4C5D7DE0097A\n\nproperty tcId1029 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFC304BE2EBA8E1CD41680F2228E150718D829821F99994AC44D59C7494BDB6A8\n    pt = 0xC2\n    ct = 0xF125384DEE677C7923697F5A3BFC6184\n\nproperty tcId1030 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5D124C781D08A9A1EF74B9BFC5B92C093F47B6C20E566B12ECBC361813688F01\n    pt = 0x3D\n    ct = 0x8435A5CB88740BADEC2C57FE0BBA0DA8\n\nproperty tcId1031 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xAA5AB62D3DF457E141F244ECB7A1B02B7C849535F6114EE43FE5474FA7934D3E\n    pt = 0x19\n    ct = 0xF3E526B2D27DCAE85E3B603219079B17\n\nproperty tcId1032 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B2B4903C7F4FEBFE9600D357C043E891BC2659AA21694810AD9DF8DE2C5D87B\n    pt = 0x7F\n    ct = 0x9AE5B26B28514B2E02866F655689D8A2\n\nproperty tcId1033 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B7572593C032234A0047A9D2A92E9F7323226FD9879B8F8BF73631C16560922\n    pt = 0x5E\n    ct = 0x2E94CB8DFFCDA2399BC422B24928A91A\n\nproperty tcId1034 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x68380612EB8E22DC776E8D05BE01B619D0C1CB99EBC7947C8444CB26FEAC0E91\n    pt = 0xBB\n    ct = 0xAA6ABD32EA59851AFE3AD836727E5DC6\n\nproperty tcId1035 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xED0580C7DAB265D63DCCFEB165778BA3ADCC9C92D807B0DA7D08F05A2D1E0EF1\n    pt = 0xAB\n    ct = 0xC3DC9EA6773BA6B254156BCA2D6CCDC4\n\nproperty tcId1036 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x512E2D54D84820280EFEC1286247D6A17DC5A23F33FC1C32D5A023D38EE43B8E\n    pt = 0xF5\n    ct = 0x4E50FAEF7FEDF00A97744D1E50180D29\n\nproperty tcId1037 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCDDD9A61EE554E27E75D9D2A6905763363ABFDA1A2E0D1351CFAC3B870E72AB7\n    pt = 0x9C\n    ct = 0x13865E5DA697B608016326560370FC34\n\nproperty tcId1038 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xBCDA299791DF47EFEFA436000A4234F9F1DDB2959F7F5CECD7D114DA1555DF39\n    pt = 0x23\n    ct = 0x957A898CF5CA014FA0BC445FA0411B8E\n\nproperty tcId1039 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x14AC4E2D21736EDCC6D423E3AF1E2BC4E8115A9C190AFD7C5A764CB7FDEFE222\n    pt = 0x27\n    ct = 0x47F8738AE025CB323AA904BB8FC94D5A\n\nproperty tcId1040 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD780739A8A8F203E593DFA988C4BEDDAD17EC65E32FF9420E8B7B094AD3504CE\n    pt = 0xA4\n    ct = 0x0ACA7980AA5D91E7CF8A7FF32ACFB820\n\nproperty tcId1041 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFE9E71CE3F0372783D47D1219919A9176DBBA7E1E7BB0E6BD94599DA51F616EA\n    pt = 0x18\n    ct = 0x4BEF98A1A912C5CCFB44398501393A5B\n\nproperty tcId1042 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD067989158B5C486D6CB2317DC4A1F174EDA232A5D0572313666B602F80FAA82\n    pt = 0x87\n    ct = 0x1622F42C6EB932C9C3BA6EE528F5EE2E\n\nproperty tcId1043 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF08EAD0CDBBCC69EF06549FAED6989E5177678A31CDE24081E962C06F80DFFF1\n    pt = 0xB6\n    ct = 0xA164FE1AAC233A7B292190106242BC35\n\nproperty tcId1044 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x6FFA0B069567D8B8CF189E1E651126E16432F4B1DF14D28C7930F167D90E71DC\n    pt = 0xBC\n    ct = 0x81AF399406890408830494067B975DC3\n\nproperty tcId1045 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF0D9A00431BFC37776632DCE8392FB668738B8E7E87B32FE6970AEDE141DBB12\n    pt = 0x15\n    ct = 0x21A2E83460738D67E274DE0231F5DB08\n\nproperty tcId1046 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x8758E274D03DE0037EB638671BF7A5762262CD81FA4710612F0F8C00DD544FD2\n    pt = 0x10\n    ct = 0xB58EF1C43EF4FB8D25C53D673C074A9F\n\nproperty tcId1047 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x611CB910E6F3554891709BE3269311CAEEA4167646770C93B1EB24150B08E7FF\n    pt = 0xAE\n    ct = 0xC4D38071B0325A7DBAE7B8C97E140567\n\nproperty tcId1048 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x595D643FEE1B9DA657E5E0DD89BEA95FBA9D60A9F569E5BD2263ECDA865B6397\n    pt = 0x8A\n    ct = 0x291C122B76FF48EB7A9B1A25C20FF3E9\n\nproperty tcId1049 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF66827A982352FB10D7BD294A6DA6661B9593E850D9AEE8C7E2C2F0662B66609\n    pt = 0x1A\n    ct = 0x8320E7CDE94090DDB0AFA279F71CF86C\n\nproperty tcId1050 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x927B27D5B50BA9D198E9EECD1317FD659A80F9E061A2703E797B61D420C7164D\n    pt = 0x62\n    ct = 0xEF84DE1F6C508958F7ADC6D11C606DB8\n\nproperty tcId1051 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xF416A4C6552B4E2E2D5F88C6AF5494C4EA1D04BB22A377C0806611418475F1F8\n    pt = 0x10\n    ct = 0x562ADB01EA14439CE1D8A6FBA46515F4\n\nproperty tcId1052 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x42EE175CB7A7F28620500AE8856C7CDE3C4052FBA5ABF91C9E91E20857AF5066\n    pt = 0x29\n    ct = 0xB5465699DD3DC2969DCF8B1DA3C0DFCC\n\nproperty tcId1053 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD9C652FA5E6A16E51DC513B53AFBC7E6624B8C3E4E3C58CD223320228EEE5DFD\n    pt = 0x55\n    ct = 0x0AD61A07DB5EC915C16F1A320BF0EAED\n\nproperty tcId1054 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x070FDEE3C8E60C382E9EFB3E61AD9B84620F2513F25DE9A535C344774F14BBC0\n    pt = 0xA4\n    ct = 0x906B0FA922E825B9375863FCA511B446\n\nproperty tcId1055 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x965B12BA6F405A1C99A702AC08084090FD80854BF5C09D00D1CBF8020E1FC853\n    pt = 0xEE\n    ct = 0x338C2D6EF2A4F0215F32117A6999E2FE\n\nproperty tcId1056 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x16E8974B487171A030AB25FE03E5789772A2A91E4FBBEFA62A2C3957AC69DAC3\n    pt = 0x51\n    ct = 0xFE89DB7AB88A6A50DBC7B4BBFD7C7D19\n\nproperty tcId1057 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9A729225A773F82968D4E4A61F67F7FEFA1C1EB951506220D2B44FB4EF06C54A\n    pt = 0xFD\n    ct = 0xBC7ED8E326F929CD1CF2939519972DB5\n\nproperty tcId1058 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x41472533F605B84462AD4C8FD062FC9B24B9EE7EBA935D0ECA424D2AB503DEF8\n    pt = 0xF9\n    ct = 0x32746F33EC7A049B4A3C48BD0ED21CE8\n\nproperty tcId1059 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x80F14DD8F5F9EF689A6840363AD88F58DE0EDCDB74700BA33A7DD923FDCB5DAD\n    pt = 0x29\n    ct = 0xF34CACF3816972C90A4AF0E67E7AED85\n\nproperty tcId1060 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xBD62F4F0449F892825008928D877A7543FADFAD05D3877033FFBD343EB83E622\n    pt = 0xD7\n    ct = 0x54F7EF87C184A81009EBF9BF6688CD7C\n\nproperty tcId1061 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x44D2B78F5FD38A5F681DA45F2FD177AFC122B7E780BB516AF29D928F3A17DAF5\n    pt = 0xD2\n    ct = 0x286F752B981CE6847661E0DCDD4D5F49\n\nproperty tcId1062 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x19556188E0349531F56D4144DAD2E5E0F6FFD349E017EFD31A05DB09291ED515\n    pt = 0xEF\n    ct = 0xE6DFA16F00FA7241F84E614649045B40\n\nproperty tcId1063 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xC2DF0F8EC128AC630349FA9E452A2A8A10B500E00B9524E146518780EE62B117\n    pt = 0x81\n    ct = 0xDF68CB42ED2761D74BEBCE73E590A4DF\n\nproperty tcId1064 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x4E88503C08AD7EF21832B200F39489D3C5457CDB45912DAA380A6DF414B125C8\n    pt = 0x2D\n    ct = 0x52D5A548C2E4D287DCAAFE03E016AD79\n\nproperty tcId1065 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xA45AFB02BF762298F315E033B04325127E9DC8F237261DDB114D384B44571929\n    pt = 0x42\n    ct = 0xCD487595DFE7F933FEF5B10587AC8981\n\nproperty tcId1066 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x7FB2623EBF05DBAEBD5122920E97DFFF06F57C838DA933538C97FAD59E25EB8A\n    pt = 0x77\n    ct = 0x8A5F782FBED1132D0636F53A51CDBF79\n\nproperty tcId1067 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x150F4FB634BAC25DE6992583F54DD734173E93AB43F63594832D9287778AD0EE\n    pt = 0x7A\n    ct = 0x799C8243EF5EF87891E005B506BF2F64\n\nproperty tcId1068 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B6CF52B74C43964097B6E38D37E01D673FB71F23C3329581F6409D8ED32A16E\n    pt = 0x4D\n    ct = 0xF293CE2D1F9C6725E1F9F107421AC396\n\nproperty tcId1069 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2644CCF9D7C419A437C954C8141CBB2D60F57DE10A5393554A14CCC72229E286\n    pt = 0xE0\n    ct = 0xDA510B1D9A10255380655980A3A73536\n\nproperty tcId1070 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5A2BF1A5098964EEC4D82F7E7C2D5723A5777F202E5CF729B506A5DC9775F1DE\n    pt = 0x11\n    ct = 0x19B164EFC41F5FFF402A1097CD89259C\n\nproperty tcId1071 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9B35B7F2AB8EEBA30101BC8D0BF94B09C8EA02114ED9912F7659967DC3C7D841\n    pt = 0x71\n    ct = 0xC788AB3CE96444554BBA805A1E3A8F91\n\nproperty tcId1072 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x5B7783AD07911FC6D685E60FCB1213EDFF5DCD7EAC1D73DA2685585AE4C39177\n    pt = 0x3E\n    ct = 0x0EA7AB3B26CDA9612A508EF9B41DB7C8\n\nproperty tcId1073 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFB56787EC73A1EED0C9061D023A305AC301E2455E349B2E573F2AFE326709ADD\n    pt = 0xC1\n    ct = 0x2C713F375FDD12469E753C68BAEAC6D4\n\nproperty tcId1074 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1AC45D1DB5E960DECD86AEA2507F1CD51EAC9BD3EA8B6093D4A795EFCA7187B0\n    pt = 0x73\n    ct = 0x24B65C239B23D8C8F44EC2721ED03B15\n\nproperty tcId1075 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDE8A1521277486D6FCDA3A24031DEE8647344F88A051A4DA7F452A7036DAA8C0\n    pt = 0x5E\n    ct = 0x708D55D92DB692A62CBA3CA4D009C8CE\n\nproperty tcId1076 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xA66E6DA21D52FC24733C303A121AD10626A5194884054CF8B73E7A71AA49380B\n    pt = 0xD3\n    ct = 0x7AD507B5FA5CD4A98C797A8DD824923F\n\nproperty tcId1077 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xCC3710FD1C78A8B019AE0E8608E5C60F614D1F043196A3D87A67074A267B5542\n    pt = 0x02\n    ct = 0xF02A71952C7F74D6F509D0DA905B5E44\n\nproperty tcId1078 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x371EEFF5ACEC4E980CA59E9D91BEBF9B1B8013B3340BC45D624F0AA0943118DA\n    pt = 0x74\n    ct = 0x7BD179C985A426CD4FF9BFBEF858436E\n\nproperty tcId1079 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x54D9324535DAC6090439406626141312CB4A61ADC61189947D5572FBD326CB57\n    pt = 0x7F\n    ct = 0xFF0061FC09D685215C4B22BE822405FD\n\nproperty tcId1080 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3EA9325069ED93A96C331BDD6DD766EC64BBBA83A72C69ED75DF55043FB0BFD1\n    pt = 0x06\n    ct = 0x40A9C42012BA38211B800E6E313B6876\n\nproperty tcId1081 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2C0CD8480E0768FB9E33A9929F3991A0DE0B0AC1F35D0CB7E58757A9D28D49D4\n    pt = 0x06\n    ct = 0xCADAD5CFD536F7BA6897EF398483F38F\n\nproperty tcId1082 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x2BB319F216DBBA31EB4BB3265FF85D13ABD8B12083DC0CD48C40372C946F70D5\n    pt = 0xE5\n    ct = 0x85427703FBC3BE25BE88765DC8791554\n\nproperty tcId1083 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xD393149C58FDB23C4ABDF43EE03D603DEB1FD06CD625F821FF93B27376458C9E\n    pt = 0x1B\n    ct = 0x3D737A3A014ABDDA0BE2696C8097EE95\n\nproperty tcId1084 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x03353DEAB5D9CD40338E8ECC8D810DE4E29B6D34CF158F68DB5AE356A4225266\n    pt = 0x8D\n    ct = 0x9313D7D59E08024181C2146F9123A78F\n\nproperty tcId1085 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x0CFD3A3B0540E5B3F044EB60050FEAFC80BAC758DB99016F79F0F5BF80307779\n    pt = 0xFC\n    ct = 0x02EC669FB26BDCDCC398545D7BDBDEC7\n\nproperty tcId1086 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x4CBC12CEE939C4F915DAE23A4B6F30B8B45734686067B27BF592BCF929C7E75E\n    pt = 0x34\n    ct = 0x5965D7F3EE0A4940BADDDFFA05A30BF4\n\nproperty tcId1087 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x1BAD340ABB934070C9B7662815BB7BAA652A056CCF246A375B6D959ADD5D7DEC\n    pt = 0x2A\n    ct = 0xEED916D3195F9C39406802285CA665D3\n\nproperty tcId1088 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xB0D6764B9B604A44D6A201A07E1F3CFCD0DA1A322DAA1251EFA19C12A8488D0E\n    pt = 0x8A\n    ct = 0xFE2A001CB35F00EAF85614EC594E2D9F\n\nproperty tcId1089 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x59BB9A295C7263842521D5F1EDD2DB92D9F09A607F758E2E3EF8CA6137616C93\n    pt = 0xB0\n    ct = 0x4AE1CF2A3BBD5BC2573D8A13212E445A\n\nproperty tcId1090 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x07E0C27A362DFB87EDE1B5E0A1790FA3FB09A99E12A6A71EB0A41B6356C9CC92\n    pt = 0xAC\n    ct = 0x70D749E0C9C77A0EDD98F8BCE3753733\n\nproperty tcId1091 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x50E530EF3EB1A1BAE45B8263BA7E30F6F5A7D2418F3611E30830C87D741647CD\n    pt = 0xFB\n    ct = 0x4FAA8357F2F3EF340A5E8B7AA74DD290\n\nproperty tcId1092 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xE1DE28540953AAF2AFB9EEF0DDBD08B5A1AAB73EECDD2F0E85F8915C94699E4A\n    pt = 0x17\n    ct = 0xC686DC8FE198F9D36374F5C56B99E3DF\n\nproperty tcId1093 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xFBDCABF978959C69724C63165A17DB5F1FA7FC2871F9BDFC799391C908F78F6C\n    pt = 0xC8\n    ct = 0xB6B5D8288DAFE8F8584514B5193EEEFE\n\nproperty tcId1094 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x417887E598A05E102E6C651F6900C22412DEB49140585A650DECA9B1BA211B1E\n    pt = 0x72\n    ct = 0x5B0B9FAB5479528F87EB3C91225BB64D\n\nproperty tcId1095 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x3BDBA3053CC76471EA0D78531BBA04A9584995BE194A348185698FE4D1338BBE\n    pt = 0xFA\n    ct = 0xF56924CE90ED7C0A79B8CAA4101D1DBC\n\nproperty tcId1096 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x9DDFEA3DA8FF9F5401D5BDBBE520E4D47263E5B268BB15DC6FD62939FFA49377\n    pt = 0x58\n    ct = 0x01F0962438250AAEEDF8069D7CFD1F95\n\nproperty tcId1097 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x59DE802DC7805F487E4537941C71A24317B585BD58CC1FF9B5AC18FFA78E74A3\n    pt = 0x0E\n    ct = 0x2B7E6ACDA4967F644662A58CE8077917\n\nproperty tcId1098 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x35F2322E2999AAA3BEBA5E33A237E9D84DF0DA5BB732370AAEF97316F78DD413\n    pt = 0x1E\n    ct = 0x8A4DBD736974C2E73DD27C5E47955D94\n\nproperty tcId1099 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0x45D780CFD96B54CF1AB425FAA701645B0FC5F84AA385B1372771BD7AD6109F0F\n    pt = 0xFC\n    ct = 0xA2E47585D0D8F81BA155324417EC2571\n\nproperty tcId1100 = testPassed == check_KWP_AE key pt ct where\n    testPassed = True\n    key = 0xDF9F0529DBBABA0D2A925AD2E0B81E01A0386DFC2033D3D6D446845957C02A15\n    pt = 0x0A\n    ct = 0xF6B6398CA55ACE0222A9391FD81CD276\n```"}]}
{"filename":"cryptol-specs\/Primitive\/Symmetric\/Cipher\/Block\/Modes\/Tests\/AES128_CBC.cry","filetype":"cryptol","messages":[{"role":"system","content":"Return exactly ONE fenced code block labeled `cryptol` and nothing else (no prose before\/after).\n"},{"role":"user","content":"Define a module named Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CBC that contains: (1) an import of the AES-128 CBC instantiation module, aliased as AES128_CBC; (2) a property aes128_cbc_encrypt_vector that asserts the equality between the result of AES128_CBC::encrypt and an expected ciphertext sequence, using a fixed 128-bit key, a fixed 128-bit IV, and a sequence of four 128-bit plaintext blocks; (3) a property aes128_cbc_decrypt_vector that asserts the equality between the result of AES128_CBC::decrypt and an expected plaintext sequence, using the same key and IV and a sequence of four 128-bit ciphertext blocks. In each property, bind the key, IV, plaintext, and ciphertext as local constants in a where clause. Use 128-bit hexadecimal literals for the key and IV, and four-element sequences of 128-bit hexadecimal literals for plaintext and ciphertext. Ensure the types are: key: [128], iv: [128], plaintext: [4][128], ciphertext: [4][128]. Both properties must compare the function outputs to the corresponding expected sequences with equality so they can be checked by a solver."},{"role":"assistant","content":"```cryptol\nmodule Primitive::Symmetric::Cipher::Block::Modes::Tests::AES128_CBC where\nimport Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CBC as AES128_CBC\n\nproperty aes128_cbc_encrypt_vector = (AES128_CBC::encrypt k iv plaintext) == ciphertext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n    ciphertext = [\n        0x7649abac8119b246cee98e9b12e9197d,\n        0x5086cb9b507219ee95db113a917678b2,\n        0x73bed6b8e3c1743b7116e69e22229516,\n        0x3ff1caa1681fac09120eca307586e1a7]\n\nproperty aes128_cbc_decrypt_vector = (AES128_CBC::decrypt k iv ciphertext) == plaintext\n    where\n    k = 0x2b7e151628aed2a6abf7158809cf4f3c\n    iv = 0x000102030405060708090a0b0c0d0e0f\n    ciphertext = [\n        0x7649abac8119b246cee98e9b12e9197d,\n        0x5086cb9b507219ee95db113a917678b2,\n        0x73bed6b8e3c1743b7116e69e22229516,\n        0x3ff1caa1681fac09120eca307586e1a7]\n    plaintext = [\n        0x6bc1bee22e409f96e93d7e117393172a,\n        0xae2d8a571e03ac9c9eb76fac45af8e51,\n        0x30c81c46a35ce411e5fbc1191a0a52ef,\n        0xf69f2445df4f9b17ad2b417be66c3710]\n```"}]}
