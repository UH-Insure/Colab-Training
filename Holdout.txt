Eval ID: aws-lc-verification/cryptol-specs/McEliece_KEM/low-level/operations.cry
User: Write a Cryptol specification for the McEliece KEM low-level Operations module, defining the functions crypto_kem_enc and crypto_kem_dec (and their helper hash functions) with appropriate types and ensuring they match the intended McEliece KEM encryption and decryption behavior.
Assistant: ```cryptol
module Operations where

import Types
import Encrypt
import Decrypt

compute_hash_2e : SYS_N8_plus1_t -> [32]base_t
compute_hash_2e in = undefined
compute_hash_1e : pm_t -> [32]base_t
compute_hash_1e in = undefined

crypto_hash_32b_1 : SYS_N8_plus1_t -> [32]base_t
crypto_hash_32b_1 in = undefined

crypto_hash_32b_2 : pm_t -> g_key_t
crypto_hash_32b_2 in = undefined

(two_e : SYS_N8_plus1_t) = [ 2 | x <- [0..870]]

crypto_kem_enc : g_ct_t -> g_key_t -> g_pk_t -> SYS_N8_plus2_t
    -> (g_ct_t, g_key_t)
crypto_kem_enc c0 key pk e =  (c2, key2) where
        (e :  SYS_N8_plus2_t) = zero
        (c1 : g_ct_t) = encrypt c0 pk e
        (c2 : g_ct_t) = (take `{194} c1 ) # (compute_hash_2e two_e)
    (one_ec : pm_t) = ([1])#(take `{870} e)#c2
    (key2 : g_key_t) = compute_hash_1e one_ec

crypto_kem_dec : g_ct_t -> g_sk_t -> g_key_t
crypto_kem_dec c sk = key where
        (e : SYS_N8_t, ret_decrypt : gf_t) = decrypt sk c
        (conf : [32]base_t) = crypto_hash_32b_1 two_e
    loop_i i rc =
        if (i<32)
        then loop_i i' rc' where
            i' = i+1
            rc' = rc || ((conf@i) ^ c@(SYND_BYTES + i))
        else rc
    (ret_confirm : base_16t) = loop_i 0 0
    (m_0 : base_16t) = ret_decrypt || ret_confirm
    (m_1 : base_16t) = m_0 - 1
    (m : base_16t) = m_1 >> 8
    x_1 = [(~m && 0) || (m && 1)]
    x_2 = [(~m && (sk@i)) || (m && (e@i)) | i <- [0..(870-1)]]
    x_3 = [(c@i) | i <- [0..(194-1+32)]]
    (preimage: pm_t) = x_1 # x_2 # x_3
        (key : g_key_t) = crypto_hash_32b_2 preimage
```
Eval ID: aws-lc-verification/cryptol-specs/McEliece_KEM/high-level/util.cry
User: Specify the Cryptol types and full implementations for load2, bitrev, store8, load8, and transpose_64x64 used in a McEliece KEM utility module, matching the shown bitwise behavior and using the imported Types definitions.
Assistant: ```cryptol
module Util where

import Types

load2 : secretkey_t -> [32] -> gf_t
load2 src sk_index = (a && (cvt_16 GFMASK)) where
    (a: base_16t) = src@(1+sk_index)
    b = a << 8
    c = b || src@(0+sk_index)

bitrev : [32] -> ([32],  [32])
bitrev a = (cvt_32 a_4, cvt_32(a_4>>3)) where
    a_0 = cvt_16 a
    a_1 = ((a_0 && 0x00FF) << 8) || ((a_0 && 0xFF00) >> 8)
    a_2 = ((a_1 && 0x0F0F) << 4) || ((a_1 && 0xF0F0) >> 4)
    a_3 = ((a_2 && 0x3333) << 2) || ((a_2 && 0xCCCC) >> 2)
    a_4 = ((a_3 && 0x5555) << 1) || ((a_3 && 0xAAAA) >> 1)

store8 out in = out
load8 in = zero
transpose_64x64 in = zero
```
Eval ID: aws-lc-verification/cryptol-specs/Primitive/Asymmetric/Signature/ECDSA/ECDSA_tests.cry
User: Write a Cryptol module that defines the same ECDSA test properties for NIST curves P-192, P-224, P-256, P-384, and P-521, including point decompression, point addition/subtraction, doubling, scalar and joint scalar multiplication, and mp_mod_sqrt correctness, matching the constants and structure shown.
Assistant: ```cryptol
module Primitive::Asymmetric::Signature::ECDSA::ECDSA_tests where

import Common::utils

import Primitive::Asymmetric::Signature::ECDSA::p192 as p192
import Primitive::Asymmetric::Signature::ECDSA::p224 as p224
import Primitive::Asymmetric::Signature::ECDSA::p256 as p256
import Primitive::Asymmetric::Signature::ECDSA::p384 as p384
import Primitive::Asymmetric::Signature::ECDSA::p521 as p521

property p192_G_compress = p192::G_compress 0x00000003188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012

p192_S = {x = BVtoZ 0xd458e7d127ae671b0c330266d246769353a012073e97acf8,
          y = BVtoZ 0x325930500d851f336bddc050cf7fb11b5673a1645086df3b}

p192_T = {x = BVtoZ 0xf22c4395213e9ebe67ddecdd87fdbd01be16fb059b9753a4,
          y = BVtoZ 0x264424096af2b3597796db48f8dfb41fa9cecc97691a9c79}

property p192_decompress_S = p192::affine_decompress_correct p192_S
property p192_decompress_T = p192::affine_decompress_correct p192_T

property p192_full_add_example =
  p192::full_add_example R p192_S p192_T
  where R = {x = BVtoZ 0x48e1e4096b9b8e5ca9d0f1f077b8abf58e843894de4d0290,
             y = BVtoZ 0x408fa77c797cd7dbfb16aa48a3648d3d63c94117d7b6aa4b}

property p192_full_subtract_example =
  p192::full_subtract_example R p192_S p192_T
  where R = {x = BVtoZ 0xfc9683cc5abfb4fe0cc8cc3bc9f61eabc4688f11e9f64a2e,
             y = BVtoZ 0x093e31d00fb78269732b1bd2a73c23cdd31745d0523d816b}

property p192_double_example =
  p192::double_example R p192_S
  where R = {x = BVtoZ 0x30c5bc6b8c7da25354b373dc14dd8a0eba42d25a3f6e6962,
             y = BVtoZ 0x0dde14bc4249a721c407aedbf011e2ddbbcb2968c9d889cf}

property p192_scalar_multiply_example0 =
  p192::scalar_multiply_example R p192_S d
  where d = BVtoZ 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee
        R = {x = BVtoZ 0x1faee4205a4f669d2d0a8f25e3bcec9a62a6952965bf6d31,
             y = BVtoZ 0x5ff2cdfa508a2581892367087c696f179e7a4d7e8260fb06}

p192_S' = {x = BVtoZ 0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012,
           y = BVtoZ 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811}

property p192_scalar_multiply_example1=
    p192::scalar_multiply_example R p192_S' d
    where d = BVtoZ 0xe14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3
          R = {x = BVtoZ 0x07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6,
               y = BVtoZ 0x76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477}

property p192_joint_scalar_multiply_example =
  p192::joint_scalar_multiply_example R p192_S p192_T d e
  where d = BVtoZ 0xa78a236d60baec0c5dd41b33a542463a8255391af64c74ee
        e = BVtoZ 0xc4be3d53ec3089e71e4de8ceab7cce889bc393cd85b972bc
        R = {x = BVtoZ 0x019f64eed8fa9b72b7dfea82c17c9bfa60ecb9e1778b5bde,
             y = BVtoZ 0x16590c5fcd8655fa4ced33fb800e2a7e3c61f35d83503644}

property mp_mod_sqrt_192_correct = p192::mp_mod_sqrt_correct

property p224_G_compress = p224::G_compress 0x00000002b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21

p224_S = {x = BVtoZ 0x6eca814ba59a930843dc814edd6c97da95518df3c6fdf16e9a10bb5b,
          y = BVtoZ 0xef4b497f0963bc8b6aec0ca0f259b89cd80994147e05dc6b64d7bf22}

p224_T = {x = BVtoZ 0xb72b25aea5cb03fb88d7e842002969648e6ef23c5d39ac903826bd6d,
          y = BVtoZ 0xc42a8a4d34984f0b71b5b4091af7dceb33ea729c1a2dc8b434f10c34}

property p224_full_add_example =
  p224::full_add_example R p224_S p224_T
  where R = {x = BVtoZ 0x236f26d9e84c2f7d776b107bd478ee0a6d2bcfcaa2162afae8d2fd15,
             y = BVtoZ 0xe53cc0a7904ce6c3746f6a97471297a0b7d5cdf8d536ae25bb0fda70}

property p224_full_subtract_example =
  p224::full_subtract_example R p224_S p224_T
  where R = {x = BVtoZ 0xdb4112bcc8f34d4f0b36047bca1054f3615413852a7931335210b332,
             y = BVtoZ 0x90c6e8304da4813878c1540b2396f411facf787a520a0ffb55a8d961}

property p224_double_example =
  p224::double_example R p224_S
  where R = {x = BVtoZ 0xa9c96f2117dee0f27ca56850ebb46efad8ee26852f165e29cb5cdfc7,
             y = BVtoZ 0xadf18c84cf77ced4d76d4930417d9579207840bf49bfbf5837dfdd7d}

property p224_scalar_multiply_example =
  p224::scalar_multiply_example R p224_S d
  where d = BVtoZ 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b
        R = {x = BVtoZ 0x96a7625e92a8d72bff1113abdb95777e736a14c6fdaacc392702bca4,
             y = BVtoZ 0x0f8e5702942a3c5e13cd2fd5801915258b43dfadc70d15dbada3ed10}

property p224_joint_scalar_multiply_example =
  p224::joint_scalar_multiply_example R p224_S p224_T d e
  where d = BVtoZ 0xa78ccc30eaca0fcc8e36b2dd6fbb03df06d37f52711e6363aaf1d73b
        e = BVtoZ 0x54d549ffc08c96592519d73e71e8e0703fc8177fa88aa77a6ed35736
        R = {x = BVtoZ 0xdbfe2958c7b2cda1302a67ea3ffd94c918c5b350ab838d52e288c83e,
             y = BVtoZ 0x2f521b83ac3b0549ff4895abcc7f0c5a861aacb87acbc5b8147bb18b}

property mp_mod_sqrt_224_correct = p224::mp_mod_sqrt_correct

property p256_G_compress = p256::G_compress 0x000000036b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296

p256_S = {x = BVtoZ 0xde2444bebc8d36e682edd27e0f271508617519b3221a8fa0b77cab3989da97c9,
          y = BVtoZ 0xc093ae7ff36e5380fc01a5aad1e66659702de80f53cec576b6350b243042a256}

p256_T = {x = BVtoZ 0x55a8b00f8da1d44e62f6b3b25316212e39540dc861c89575bb8cf92e35e0986b,
          y = BVtoZ 0x5421c3209c2d6c704835d82ac4c3dd90f61a8a52598b9e7ab656e9d8c8b24316}

property p256_full_add_example =
  p256::full_add_example R p256_S p256_T
  where R = {x = BVtoZ 0x72b13dd4354b6b81745195e98cc5ba6970349191ac476bd4553cf35a545a067e,
             y = BVtoZ 0x8d585cbb2e1327d75241a8a122d7620dc33b13315aa5c9d46d013011744ac264}

property p256_full_subtract_example =
  p256::full_subtract_example R p256_S p256_T
  where R = {x = BVtoZ 0xc09ce680b251bb1d2aad1dbf6129deab837419f8f1c73ea13e7dc64ad6be6021,
             y = BVtoZ 0x1a815bf700bd88336b2f9bad4edab1723414a022fdf6c3f4ce30675fb1975ef3}

property p256_double_example =
  p256::double_example R p256_S
  where R = {x = BVtoZ 0x7669e6901606ee3ba1a8eef1e0024c33df6c22f3b17481b82a860ffcdb6127b0,
             y = BVtoZ 0xfa878162187a54f6c39f6ee0072f33de389ef3eecd03023de10ca2c1db61d0c7}

property p256_scalar_multiply_example =
  p256::scalar_multiply_example R p256_S d
  where d = BVtoZ 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd
        R = {x = BVtoZ 0x51d08d5f2d4278882946d88d83c97d11e62becc3cfc18bedacc89ba34eeca03f,
             y = BVtoZ 0x75ee68eb8bf626aa5b673ab51f6e744e06f8fcf8a6c0cf3035beca956a7b41d5}

property p256_joint_scalar_multiply_example =
  p256::joint_scalar_multiply_example R p256_S p256_T d e
  where d = BVtoZ 0xc51e4753afdec1e6b6c6a5b992f43f8dd0c7a8933072708b6522468b2ffb06fd
        e = BVtoZ 0xd37f628ece72a462f0145cbefe3f0b355ee8332d37acdd83a358016aea029db7
        R = {x = BVtoZ 0xd867b4679221009234939221b8046245efcf58413daacbeff857b8588341f6b8,
             y = BVtoZ 0xf2504055c03cede12d22720dad69c745106b6607ec7e50dd35d54bd80f615275}

property mp_mod_sqrt_256_correct = p256::mp_mod_sqrt_correct

property p384_G_compress = p384::G_compress 0x00000003aa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7

p384_S = {x = BVtoZ 0xfba203b81bbd23f2b3be971cc23997e1ae4d89e69cb6f92385dda82768ada415ebab4167459da98e62b1332d1e73cb0e,
          y = BVtoZ 0x5ffedbaefdeba603e7923e06cdb5d0c65b22301429293376d5c6944e3fa6259f162b4788de6987fd59aed5e4b5285e45}

p384_T = {x = BVtoZ 0xaacc05202e7fda6fc73d82f0a66220527da8117ee8f8330ead7d20ee6f255f582d8bd38c5a7f2b40bcdb68ba13d81051,
          y = BVtoZ 0x84009a263fefba7c2c57cffa5db3634d286131afc0fca8d25afa22a7b5dce0d9470da89233cee178592f49b6fecb5092}

property p384_full_add_example =
  p384::full_add_example R p384_S p384_T
  where R = {x = BVtoZ 0x12dc5ce7acdfc5844d939f40b4df012e68f865b89c3213ba97090a247a2fc009075cf471cd2e85c489979b65ee0b5eed,
             y = BVtoZ 0x167312e58fe0c0afa248f2854e3cddcb557f983b3189b67f21eee01341e7e9fe67f6ee81b36988efa406945c8804a4b0}

property p384_full_subtract_example =
  p384::full_subtract_example R p384_S p384_T
  where R = {x = BVtoZ 0x6afdaf8da8b11c984cf177e551cee542cda4ac2f25cd522d0cd710f88059c6565aef78f6b5ed6cc05a6666def2a2fb59,
             y = BVtoZ 0x7bed0e158ae8cc70e847a60347ca1548c348decc6309f48b59bd5afc9a9b804e7f7876178cb5a7eb4f6940a9c73e8e5e}

property p384_double_example =
  p384::double_example R p384_S
  where R = {x = BVtoZ 0x2a2111b1e0aa8b2fc5a1975516bc4d58017ff96b25e1bdff3c229d5fac3bacc319dcbec29f9478f42dee597b4641504c,
             y = BVtoZ 0xfa2e3d9dc84db8954ce8085ef28d7184fddfd1344b4d4797343af9b5f9d837520b450f726443e4114bd4e5bdb2f65ddd}

property p384_scalar_multiply_example =
  p384::scalar_multiply_example R p384_S d
  where d = BVtoZ 0xa4ebcae5a665983493ab3e626085a24c104311a761b5a8fdac052ed1f111a5c44f76f45659d2d111a61b5fdd97583480
        R = {x = BVtoZ 0xe4f77e7ffeb7f0958910e3a680d677a477191df166160ff7ef6bb5261f791aa7b45e3e653d151b95dad3d93ca0290ef2,
             y = BVtoZ 0xac7dee41d8c5f4a7d5836960a773cfc1376289d3373f8cf7417b0c6207ac32e913856612fc9ff2e357eb2ee05cf9667f}

property p384_joint_scalar_multiply_example =
  p384::joint_scalar_multiply_example R p384_S p384_T d e
  where d = BVtoZ 0xa4ebcae5a665983493ab3e626085a24c104311a761b5a8fdac052ed1f111a5c44f76f45659d2d111a61b5fdd97583480
        e = BVtoZ 0xafcf88119a3a76c87acbd6008e1349b29f4ba9aa0e12ce89bcfcae2180b38d81ab8cf15095301a182afbc6893e75385d
        R = {x = BVtoZ 0x917ea28bcd641741ae5d18c2f1bd917ba68d34f0f0577387dc81260462aea60e2417b8bdc5d954fc729d211db23a02dc,
             y = BVtoZ 0x1a29f7ce6d074654d77b40888c73e92546c8f16a5ff6bcbd307f758d4aee684beff26f6742f597e2585c86da908f7186}

property mp_mod_sqrt_384_correct = p384::mp_mod_sqrt_correct

property p521_G_compress = p521::G_compress 0x04c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66

p521_S = {x = BVtoZ 0x000001d5c693f66c08ed03ad0f031f937443458f601fd098d3d0227b4bf62873af50740b0bb84aa157fc847bcf8dc16a8b2b8bfd8e2d0a7d39af04b089930ef6dad5c1b4,
          y = BVtoZ 0x00000144b7770963c63a39248865ff36b074151eac33549b224af5c8664c54012b818ed037b2b7c1a63ac89ebaa11e07db89fcee5b556e49764ee3fa66ea7ae61ac01823}

p521_T = {x = BVtoZ 0x000000f411f2ac2eb971a267b80297ba67c322dba4bb21cec8b70073bf88fc1ca5fde3ba09e5df6d39acb2c0762c03d7bc224a3e197feaf760d6324006fe3be9a548c7d5,
          y = BVtoZ 0x000001fdf842769c707c93c630df6d02eff399a06f1b36fb9684f0b373ed064889629abb92b1ae328fdb45534268384943f0e9222afe03259b32274d35d1b9584c65e305}

property p521_full_add_example =
  p521::full_add_example R p521_S p521_T
  where R = {x = BVtoZ 0x000001264ae115ba9cbc2ee56e6f0059e24b52c8046321602c59a339cfb757c89a59c358a9a8e1f86d384b3f3b255ea3f73670c6dc9f45d46b6a196dc37bbe0f6b2dd9e9,
             y = BVtoZ 0x00000062a9c72b8f9f88a271690bfa017a6466c31b9cadc2fc544744aeb817072349cfddc5ad0e81b03f1897bd9c8c6efbdf68237dc3bb00445979fb373b20c9a967ac55}

property p521_full_subtract_example =
  p521::full_subtract_example R p521_S p521_T
  where R = {x = BVtoZ 0x000001292cb58b1795ba477063fef7cd22e42c20f57ae94ceaad86e0d21ff22918b0dd3b076d63be253de24bc20c6da290fa54d83771a225deecf9149f79a8e614c3c4cd,
             y = BVtoZ 0x000001695e3821e72c7cacaadcf62909cd83463a21c6d03393c527c643b36239c46af117ab7c7ad19a4c8cf0ae95ed51729885461aa2ce2700a6365bca3733d2920b2267}

property p521_double_example =
  p521::double_example R p521_S
  where R = {x = BVtoZ 0x0000012879442f2450c119e7119a5f738be1f1eba9e9d7c6cf41b325d9ce6d643106e9d61124a91a96bcf201305a9dee55fa79136dc700831e54c3ca4ff2646bd3c36bc6,
             y = BVtoZ 0x0000019864a8b8855c2479cbefe375ae553e2393271ed36fadfc4494fc0583f6bd03598896f39854abeae5f9a6515a021e2c0eef139e71de610143f53382f4104dccb543}

property p521_scalar_multiply_example =
  p521::scalar_multiply_example R p521_S d
  where d = BVtoZ 0x000001eb7f81785c9629f136a7e8f8c674957109735554111a2a866fa5a166699419bfa9936c78b62653964df0d6da940a695c7294d41b2d6600de6dfcf0edcfc89fdcb1
        R = {x = BVtoZ 0x00000091b15d09d0ca0353f8f96b93cdb13497b0a4bb582ae9ebefa35eee61bf7b7d041b8ec34c6c00c0c0671c4ae063318fb75be87af4fe859608c95f0ab4774f8c95bb,
             y = BVtoZ 0x00000130f8f8b5e1abb4dd94f6baaf654a2d5810411e77b7423965e0c7fd79ec1ae563c207bd255ee9828eb7a03fed565240d2cc80ddd2cecbb2eb50f0951f75ad87977f}

property p521_joint_scalar_multiply_example =
  p521::joint_scalar_multiply_example R p521_S p521_T d e
  where d = BVtoZ 0x000001eb7f81785c9629f136a7e8f8c674957109735554111a2a866fa5a166699419bfa9936c78b62653964df0d6da940a695c7294d41b2d6600de6dfcf0edcfc89fdcb1
        e = BVtoZ 0x00000137e6b73d38f153c3a7575615812608f2bab3229c92e21c0d1c83cfad9261dbb17bb77a63682000031b9122c2f0cdab2af72314be95254de4291a8f85f7c70412e3
        R = {x = BVtoZ 0x0000009d3802642b3bea152beb9e05fba247790f7fc168072d363340133402f2585588dc1385d40ebcb8552f8db02b23d687cae46185b27528adb1bf9729716e4eba653d,
             y = BVtoZ 0x0000000fe44344e79da6f49d87c1063744e5957d9ac0a505bafa8281c9ce9ff25ad53f8da084a2deb0923e46501de5797850c61b229023dd9cf7fc7f04cd35ebb026d89d}

property mp_mod_sqrt_521_correct = p521::mp_mod_sqrt_correct
```
Eval ID: aws-lc-verification/cryptol-specs/Primitive/Symmetric/MAC/HMAC.cry
User: Define a Cryptol module implementing the HMAC construction with a SHA-256-based instance `hmacSHA256`, including the helper function `kinit` and the generic `hmac` function with the given polymorphic sizes and type constraints.
Assistant: ```cryptol
module Primitive::Symmetric::MAC::HMAC where

import Primitive::Keyless::Hash::SHA256

hmacSHA256 : {pwBytes, msgBytes}
             (fin pwBytes, fin msgBytes
             , 32 >= width msgBytes
             , 64 >= width (8*pwBytes)
             , 64 >= width (8 * (64 + msgBytes))
             ) => [pwBytes][8] -> [msgBytes][8] -> [256]
hmacSHA256 = hmac `{blockLength=64} SHA256 SHA256 SHA256

kinit : { pwBytes, blockLength, digest }
        ( fin pwBytes, fin blockLength, fin digest )
     => ([pwBytes][8] -> [8*digest])
     -> [pwBytes][8]
     -> [blockLength][8]
kinit hash key =
  if `pwBytes > (`blockLength : [max (width pwBytes) (width blockLength)])
  then take `{blockLength} (split (hash key) # (zero : [blockLength][8]))
  else take `{blockLength} (key # (zero : [blockLength][8]))

hmac : { msgBytes, pwBytes, digest, blockLength }
       ( fin pwBytes, fin digest, fin blockLength )
    => ([blockLength + msgBytes][8] -> [8*digest])
    -> ([blockLength + digest][8] -> [8*digest])
    -> ([pwBytes][8] -> [8*digest])
    -> [pwBytes][8]
    -> [msgBytes][8]
    -> [digest*8]
hmac hash hash2 hash3 key message = hash2 (okey # internal)
 where
   ks : [blockLength][8]
   ks = kinit hash3 key
   okey = [k ^ 0x5C | k <- ks]
   ikey = [k ^ 0x36 | k <- ks]
   internal = split (hash (ikey # message))
```
Eval ID: aws-lc-verification/cryptol-specs/Primitive/Symmetric/Cipher/Block/AES/SubByteSBox.cry
User: Define the Cryptol module `Primitive::Symmetric::Cipher::Block::AES::SubByteSBox` implementing the AES SubBytes and InvSubBytes transformations with functions `SubByte : GF28 -> GF28` and `InvSubByte : GF28 -> GF28`, using `sbox` and `sboxInv` over `GF28` elements.
Assistant: ```cryptol
module Primitive::Symmetric::Cipher::Block::AES::SubByteSBox where

import Primitive::Symmetric::Cipher::Block::AES::GF28
import Primitive::Symmetric::Cipher::Block::AES::SBox

SubByte : GF28 -> GF28
SubByte b = sbox @ b

InvSubByte : GF28 -> GF28
InvSubByte b = sboxInv @ b
```
Eval ID: BLST-Verification/tests/FrobeniusTests.cry
User: Write a Cryptol module that defines properties `fp2_frobenius_prop`, `f6_frobenius_prop`, and `f12_frobenius_prop` asserting that `fp2_frobenius`, `fp6_frobenius`, and `fp12_frobenius` equal `F_expt` over `P::Fp_2`, `P::Fp_6`, and `P::Fp_12` (after normalization) using the prime `p : [381] = P::p`.
Assistant: ```cryptol
import Parameters as P
import Frobenius
import FieldExtras

p: [381]
p = `P::p

property fp2_frobenius_prop x =
  fp2_frobenius x' == F_expt P::Fp_2 x' p where x' = P::Fp_2.normalize x

property f6_frobenius_prop x =
  fp6_frobenius x' == F_expt P::Fp_6 x' p where x' = P::Fp_6.normalize x

property f12_frobenius_prop x =
  fp12_frobenius x' == F_expt P::Fp_12 x' p where x' = P::Fp_12.normalize x
```
Eval ID: BLST-Verification/spec/CoreVerifyPKInG1.cry
User: Define the function `core_verify_pk_in_g1` that verifies a BLS signature in G1 by comparing two `bls_ate_pairing` results (one using the public key and `hash_to_curve_opt(msg, dst)`, and the other using the base point `BP` and the signature), returning an `Fp_12.is_equal` boolean.
Assistant: ```cryptol
module CoreVerifyPKInG1 where

import Parameters
import HashToCurveE2
import Pairing

core_verify_pk_in_g1 pk sig msg dst = Fp_12.is_equal(c1, c2) where
    c1 = bls_ate_pairing pk (hash_to_curve_opt (msg, dst))
    c2 = bls_ate_pairing BP sig
```
Eval ID: BLST-Verification/spec/Pairing.cry
User: Define a Cryptol module `Pairing` that specifies the BLS optimal ate pairing over the BN curve, including `bls_ate_pairing`, `ate_pairing`, the Miller loop (`miller_step`, `line_function`), and the final exponentiation using Frobenius maps, with appropriate types and intermediate helpers.
Assistant: ```cryptol
module Pairing where

import Parameters as P
import ShortWeierstrassCurve as EC
import FieldExtras
import Frobenius

c12: EC::EllipticCurve t12
c12 = { base_field = P::Fp_12, a = P::Fp_12.field_zero, b = P::Fp_to_Fp_12 P::b }

phi_1: EC::AffinePoint t1 -> EC::AffinePoint t12
phi_1 (x,y) = (P::Fp_to_Fp_12 x, P::Fp_to_Fp_12 y)

alpha: t2
alpha = f2.half (f2.sub (f2.field_unit, P::u))

w3_times: t2 -> t12
w3_times x = [[z,x,z],[z,z,z]] where z = f2.field_zero

w4_times: t2 -> t12
w4_times x = [[z,z,z],[x,z,z]] where z = f2.field_zero

phi_2: EC::AffinePoint t2 -> EC::AffinePoint t12
phi_2 (x,y) = (x',y') where
    x' = w4_times (f2.mul (x, alpha))
    y' = w3_times (f2.mul (y, alpha))

private
    twice x = f12.add (x,x)
    thrice x = f12.add (x, twice x)

line_function: (t12,t12) -> (t12,t12) -> (t12,t12) -> t12
line_function A B P = ret where
    (A1,A2) = A
    (B1,B2) = B
    (P1,P2) = P
    ret = if A == EC::neg c12 B           then f12.sub (P1, A1)           else f12.sub (f12.add (f12.mul (l, f12.sub (P1, A1)), A2), P2)
    l = if A == B
        then f12.div (thrice (f12.sq A1), twice A2)
        else f12.div (f12.sub (B2, A2), f12.sub (B1, A1))

negative_t:[64]
negative_t = <| x^^63 + x^^62 + x^^60 + x^^57 + x^^48 + x^^16 |>

bls_ate_pairing: EC::AffinePoint t1 -> EC::AffinePoint t2 -> t12
bls_ate_pairing p q = ate_pairing (phi_1 p) (phi_2 q)

ate_pairing: EC::AffinePoint t12 -> EC::AffinePoint t12 -> t12
ate_pairing P Q = final_exponentiation (ate_pairing' P Q)

// skipping the final exponentation
ate_pairing': EC::AffinePoint t12 -> EC::AffinePoint t12 -> t12
ate_pairing' P Q =  last_f where
   negQ = EC::neg c12 Q
   (last_f, _) = f_Ts ! 0
   f_Ts = [(f12.field_unit, negQ)] #
          [ miller_step P negQ fT ci | fT <- f_Ts | ci <- tail negative_t]

// in the Miller loop, c_i is only ever 0 or -1, here represented by False and True
// We only subtract Q, never add, so we take -Q as a parameter
miller_step:  EC::AffinePoint t12 -> EC::AffinePoint t12 -> (t12, EC::AffinePoint t12)
              -> Bit -> (t12, EC::AffinePoint t12)
miller_step P negQ (f, T) ci = (f', T') where
    f0 = f12.mul (f12.sq f, line_function T T P)
    T0 = EC::double c12 T
    (f', T') = if ci
               then (f12.mul (f0, line_function T0 negQ P),
                     EC::add c12 T0 negQ)
               else (f0, T0)

// final exponentiation

type r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
type final_exponent = (P::p^^12 - 1) / r
type small_final_e =  (P::p^^4 - P::p^^2 +1)/r

// Use the Frobenius mapping to compute x^(p^6-1)*(p^2+1)
final_exp_frobenius_map : t12 -> t12
final_exp_frobenius_map x = x2 where
  x1 = f12.div (fp12_conjugate x, x) // = x^(p^6 - 1)
  x2 = f12.mul (fp12_frobenius (fp12_frobenius x1), x1) // x1^(p^2+1)

final_exponentiation: t12 -> t12
/* We could most simply define

  final_expt x = k_expt`{6} f12 x (`final_exponent:[4314])

  but is it rather inefficient to do so.  Instead, as noted in [1] and [2]
  we can use the factorization

     p^12-1 = (p^8+p^6 - p^2-1)*(p^4-p^2+1)
            = (p^6-1)*(p^2+1)*(p^4-p^2+1)

  and r since divides p^4-p^2+1, we can first use the Frobenius mapping to
  easily compute x^(p^6-1)*(p^2+1), then complete the calculation
  raising this to (p^4-p^2+1)/r.

  For that last exponentiation, we use a (2^5)-ary breakdown of the exponent,
  noting that 2^5 = 32 is pretty close the the square root of 1268, the number of
  bits in the exponent.

  [1] Beauchat et al.  "High-Speed Software Implementation of the Optimal
      Ate airing over Barreto-Naehrig Curves"

  [2] Scott et al. "On the final exponentiation for calculating pairings on
      ordinary elliptic curves." eprint.iacr.org/2008/490
 */
final_exponentiation x = k_expt`{5} f12 (final_exp_frobenius_map x) (`small_final_e:[1268+2])
```
Eval ID: BLST-Verification/spec/implementation/Keygen.cry
User: Specify and verify in Cryptol the BLS key generation procedure `KeyGen_rep` using HKDF-SHA256 and Montgomery arithmetic, including the properties `keygen_finish_integer`, `keygen_finish_bv`, and `le_bytes_from_limbs_rep4_prop` over the defined 256/512-bit representations.
Assistant: ```cryptol
module implementation::Keygen where

import Parameters as P
import Primitive::Keyless::Hash::SHA256
import Primitive::Symmetric::KDF::HKDF256
import rfc8017

import Common::bv

import implementation::Types
import implementation::Field

pow256_abs: Pow256 -> [256]
pow256_abs x = join (reverse x)

r_modulus = toInteger P::r 
r_R = 2^^256

r_R_inv = toInteger 0x1bbe869330009d577204078a4f77266aab6fca8f09dc705f13f75b69fe75c040

r_RR = 2^^512

r_R_reduced = r_R % r_modulus
r_RR_reduced = r_RR % r_modulus
r_R_inv_reduced = r_R_inv % r_modulus

r_to_mont x = (x*r_R) % r_modulus

r_from_mont x = (x*r_R_inv) % r_modulus

r_add_mont x y = (x+y) % r_modulus

r_mul_mont x y = (x*y*r_R_inv) % r_modulus

property keygen_finish_integer x = r_mul_mont (r_from_mont x) (2^^512 % r_modulus) == (x % r_modulus)

bv_r = (fromInteger r_modulus):[256] bv_R = (fromInteger r_R_reduced):[256]
bv_R_inv = (fromInteger r_R_inv):[256] bv_RR = (fromInteger r_RR_reduced):[256]

mul_mont_r_bv: [256] -> [256] -> [256]
mul_mont_r_bv a b = safe_mod (bv_r, safe_product (zext a, safe_product (b, bv_R_inv)))

redc_r_bv: [512] -> [256]
redc_r_bv x = safe_mod (bv_r, safe_product (x, zext bv_R_inv))

property keygen_finish_bv x =
  safe_mod (bv_r, x) == mul_mont_r_bv (redc_r_bv x) bv_RR

mul_mont_256_rep: Vec256 -> Vec256 -> Vec256
mul_mont_256_rep x y = vec256_rep (mul_mont_r_bv (vec256_abs x) (vec256_abs y))

r_redc_rep: Vec512 -> Vec256
r_redc_rep x = vec256_rep (redc_r_bv (vec512_abs x))

r_RR_rep: Vec256 r_RR_rep = [14526898881837571181, 3129137299524312099, 419701826671360399, 524908885293268753]

limbs_from_be_bytes_rep48: [48][8] -> [6]Limb
limbs_from_be_bytes_rep48 bytes = reverse (split (join bytes))

le_bytes_from_limbs_rep4: Vec256 -> Pow256
le_bytes_from_limbs_rep4 limbs = reverse (split (join (reverse limbs)))

property le_bytes_from_limbs_rep4_prop limbs =
    pow256_abs (le_bytes_from_limbs_rep4 limbs) == vec256_abs limbs

KeyGenStep_rep: {IKM_len, info_len} (validHMACSizes 20 (1+IKM_len)
                                    , validHMACSizes 32 (35+info_len)
                                    ) =>
        [256] -> [IKM_len][8] -> [info_len][8] -> Vec256
KeyGenStep_rep salt IKM key_info = SK where
    type L = (3 * 256) /^ 16     PRK = HKDF_Extract (split salt) (IKM # [0])     OKM = HKDF_Expand`{L=L} PRK (key_info # I2OSP`{xLen=2} `L)
    OKM_vec = (limbs_from_be_bytes_rep48 OKM) # [0,0]
    SK = mul_mont_256_rep (r_redc_rep OKM_vec) r_RR_rep

KeyGenLoop_rep: {IKM_len, info_len} (validHMACSizes 20 (1+IKM_len)
                                    , validHMACSizes 32 (35+info_len)
                                    ) =>
        [256] -> [IKM_len][8] -> [info_len][8] -> [inf]Vec256
KeyGenLoop_rep salt IKM info = keys where
    salts = [salt] # [sha salt' | salt' <- salts]
    keys = [zero] #
                      [if k == zero then key_gen_step salt' else k | k <- keys | salt' <- salts]
    key_gen_step s = KeyGenStep_rep s IKM info

KeyGen_rep: {IKM_len, info_len} ( validHMACSizes 20 (1+IKM_len)
                                , validHMACSizes 32 (35+info_len)
                                ) =>
        ([IKM_len][8], [info_len][8]) -> Pow256
KeyGen_rep (IKM, key_info) = le_bytes_from_limbs_rep4 SK_vec where
    SK_vec = (KeyGenLoop_rep (sha (join "BLS-SIG-KEYGEN-SALT-")) IKM key_info) @ 4
```
Eval ID: cryptol/cryptol-remote-api/python/tests/cryptol/test-files/Names.cry
User: Write a Cryptol module `Names` that defines the given parameters, types, functions, primitive declarations, and the property `enc_correct : [64] -> Bit` asserting `x == enc (enc x)` for all 64-bit inputs, matching the structure implied by the excerpt.
Assistant: ```cryptol
module Names where

parameter
  key : [64]

enc : [64] -> [64]
enc x = x ^ key

enc_correct : [64] -> Bit
property enc_correct x =
  x == enc (enc x)

primitive prim : [64] -> [64]

(-!) : [64] -> [64] -> [64]
x -! y = if y > x then 0 else x - y

parameter
  type a : #

type b = a

type constraint fin_b = fin b

primitive type c : *

newtype d = { un_d : c }

submodule M where
```
Eval ID: cryptol/tests/regression/word-update.cry
User: In Cryptol, define bitvector update functions `update` and `updateEnd` on 16-bit words and properties `wordUpdate`, `wordUpdate2`, `wordUpdateEnd`, and `wordUpdateEnd2` that verify these functions match both mask-based and index-based formulations for indices `y < 16`.
Assistant: ```cryptol
property wordUpdate (x:[16]) (y:[8]) (b:Bit) =
  y < 16 ==> update x y b == if b then x || msk else x && ~msk

 where
 msk = 0b1000000000000000 >> y

property wordUpdate2 (x:[16]) (y:[8]) (b:Bit) =
  y < 16 ==> update x y b == x'

 where
 x' = [ if i == y then b else x@i | i <- [0 .. 15] ]

property wordUpdateEnd (x:[16]) (y:[8]) (b:Bit) =
  y < 16 ==> updateEnd x y b == if b then x || msk else x && ~msk

 where
 msk = 0b0000000000000001 << y

property wordUpdateEnd2 (x:[16]) (y:[8]) (b:Bit) =
  y < 16 ==> updateEnd x y b == x'

 where
 x' = [ if i == y then b else x!i | i <- reverse [0 .. 15] ]
```
Eval ID: cryptol/tests/regression/check24.cry
User: Define the function `xor : {a} ([a], [a]) -> [a]` as element-wise inequality on two sequences, and define `check24` as a property asserting that for all 4-bit `x` and `y`, `xor` equals the built-in bitwise XOR `(^)` and that this holds for all values.
Assistant: ```cryptol
xor : {a} ([a], [a]) -> [a]
xor (xs, ys) = [ x != y | x <- xs | y <- ys ]

check24 = [ xor`{4} (x, y) == (x ^ y) | x <- [ 0 .. 15 ], y <- [ 0 .. 15 ] ] == ~zero
```
Eval ID: cryptol/tests/regression/check28.cry
User: In Cryptol, define the sequence `xs` as given and the value `check28` that asserts the list comprehension `[ x == y | (x,y) <- xs ]` is equal to `~zero`.
Assistant: ```cryptol
xs = [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7)]
check28 = [ x==y | (x,y) <- xs ] == ~zero
```
Eval ID: cryptol/tests/issues/issue_1812.cry
User: In Cryptol, reproduce these parameterized sequence type declarations and their constant zero definitions, ensuring that the arithmetic in the sequence length expressions is well-typed and equivalent (e.g., for f/g, ff/gg, jj/kk).
Assistant: ```cryptol
f : {h} (fin h) => [2^^h + (2^^h - 2^^h)]
f = g`{h}

g : {h} (fin h) => [2^^h]
g = zero

ff : {h} (fin h) => [(2^^h + 2^^h) - 2^^h]
ff = gg`{h}

gg : {h} (fin h) => [2^^h]
gg = zero

jj : {h} (fin h) => [2 ^^ (1 + h) - 1]
jj = kk`{h}

kk : {h} (fin h, 2 ^^ (1 + h) - 1 >= 2 ^^ h - 1) => [2 ^^ h - 1 + 2 ^^ h]
kk = zero
```
Eval ID: cryptol/tests/modsys/functors/T011.cry
User: Write a Cryptol specification that defines the submodules A, S, F, I, and M as given, using a type alias T = [8], an interface submodule S exposing x : T, a functor submodule F using x to define y = 2 * x, and an instantiation M = F { I } with I.x = 28.
Assistant: ```cryptol
submodule A where
  type T = [8]

interface submodule S where
  import submodule A
  x : T

submodule F where
  import interface submodule S

  y = 2 * x

submodule I where
  x = 28

submodule M = submodule F { submodule I }

import submodule M as M
```
Eval ID: cryptol-specs/Primitive/Asymmetric/Signature/ML_DSA/ML_DSA.cry
User: Specify the ML-DSA key generation, signing, and verification API and define the property MLDSAIsCorrect that states a signature produced by Sign with keys from KeyGen always verifies with Verify for all messages and contexts within the given type constraints.
Assistant: ```cryptol
module Primitive::Asymmetric::Signature::ML_DSA::ML_DSA where

import interface Primitive::Asymmetric::Signature::ML_DSA::Parameters as P
import Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification { interface P }

KeyGen : Option ([32]Byte) -> Option (PublicKey, PrivateKey)
KeyGen maybe_ξ = case maybe_ξ of
    None -> None
    Some ξ -> Some (KeyGen_internal ξ)

Sign : {m, c} (fin m, fin c) =>
    PrivateKey -> [m] -> [c]Byte -> Option ([32]Byte) -> Option (Signature)
Sign sk M ctx maybe_rnd
        | c > 255 => None
        | c <= 255 => case maybe_rnd of
        None -> None
        Some rnd -> sigma where
                                                            M' = join (IntegerToBytes`{1} 0 # IntegerToBytes`{1} `c # ctx) # M
            // Step 11.
            sigma = Some (Sign_internal sk M' rnd)

Verify : {m, c} (fin m, fin c) =>
    PublicKey -> [m] -> Signature -> [c]Byte -> Option Bool
Verify pk M sigma ctx
    | c > 255 => None
    | c <= 255 => Some (Verify_internal pk M' sigma) where
        // Step 10. We use `join` instead of `BytesToBits`, which produces
        // the same byte string, but with the bits in each byte reversed.
        // I think we have to do this to support the later call to `HBits`,
        // which expects the bit-order and byte-order to be the same.
        M' = join (IntegerToBytes`{1} 0 # IntegerToBytes`{1} `c # ctx) # M

submodule TestAPI where
    import Primitive::Asymmetric::Signature::ML_DSA::OptimizedSpecification { interface P } as Spec

    KeyGen_internal = Spec::KeyGen_internal
    Sign_internal = Spec::Sign_internal
    Verify_internal = Spec::Verify_internal

MLDSAIsCorrect : {m} (fin m) => [32]Byte -> [32]Byte -> [m] -> [255]Byte -> Bit
property MLDSAIsCorrect ξ rnd M ctx = sigVerifies where
    maybe_keys = KeyGen (Some ξ)
    maybe_sigVerifies = case maybe_keys of
        None -> None
        Some keys -> case (Sign sk M ctx (Some rnd)) of
                None -> None
                Some sig -> Verify pk M sig ctx
            where (pk, sk) = keys
    sigVerifies = case maybe_sigVerifies of
        None -> False
        Some v -> v
```
Eval ID: cryptol-specs/Primitive/Asymmetric/Signature/XMSS/Parameters.cry
User: Write a Cryptol module that fully specifies the XMSS parameter interface `Primitive::Asymmetric::Signature::XMSS::Parameters`, including types `h`, `n`, `MessageUpperBound`, `PaddingWidth`, constants `oid`, and hash functions `H` and `H_msg` with the given constraints and signatures.
Assistant: ```cryptol
interface module Primitive::Asymmetric::Signature::XMSS::Parameters where

type h : #
type constraint (fin h)

type constraint (h <= 32)

type constraint (h >= 1)

type n : #
type constraint (fin n)

H : [n][8] -> [2 * n][8] -> [n][8]

type MessageUpperBound : #

type PaddingWidth : #

oid : [32]

H_msg : {m} (fin m, width (PaddingWidth + 8 * m) < MessageUpperBound)
    => [3 * n][8] -> [m][8] -> [n][8]
```
Eval ID: cryptol-specs/Primitive/Asymmetric/Signature/XMSS/Instantiations/XMSS_SHA2_10_256.cry
User: Write a Cryptol module `Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256` that instantiates the generic XMSS specification with the `XMSS_SHA2_10_256_Parameters` parameter set and the `WOTSP_SHA2_256` WOTS instantiation.
Assistant: ```cryptol
module Primitive::Asymmetric::Signature::XMSS::Instantiations::XMSS_SHA2_10_256 =
    Primitive::Asymmetric::Signature::XMSS::Specification {
        Parameters = Primitive::Asymmetric::Signature::XMSS::ParameterSets::XMSS_SHA2_10_256_Parameters,
        WOTS = Primitive::Asymmetric::Signature::WOTS::Instantiations::WOTSP_SHA2_256

    }
```
Eval ID: cryptol-specs/Primitive/Keyless/Hash/SHA3/KeccakBitOrdering.cry
User: Specify the Keccak/SHA3 bit and byte ordering utilities, including toBytes, fromBytes, reverseBitOrdering, h2b, b2h, and properties proving involution and mutual inversion (e.g., h2bAndb2hInvert, b2hAndh2bInvert, and example properties).
Assistant: ```cryptol
module Primitive::Keyless::Hash::SHA3::KeccakBitOrdering where

toBytes : {n} (fin n) => [8*n] -> [n][8]
toBytes s = reverse (split (reverse s))

fromBytes : {n} (fin n) => [n][8] -> [8*n]
fromBytes bs = reverse (join (reverse bs))

reverseBitOrdering : {m} [m] -> [m]
reverseBitOrdering msg
    | m == inf => join (map reverse (groupBy`{8} msg))
    | fin m => (flipped_full_bytes # flipped_remainder) where
                        type Bytes = 8 * (m / 8)
        flipped_full_bytes = join (map reverse (groupBy`{each=8, parts=m / 8} (take`{Bytes} msg)))
        flipped_remainder = reverse (drop`{Bytes} msg)

reverseBitOrderingInvolutes : {m} (fin m) => [m] -> Bit
property reverseBitOrderingInvolutes msg = reReverse == msg where
    reReverse = reverseBitOrdering (reverseBitOrdering msg)

truncate : {n, m} (fin m, fin n, m >= n, m % (2 * HexDigit) == 0) => [m] -> [n]
truncate msg = reverseBitOrdering (take (reverseBitOrdering msg))

reverseMatchesh2b : {m} (fin m, m > 0) => [2 * m * HexDigit] -> Bool
property reverseMatchesh2b msg = h2b msg == reverseBitOrdering msg

truncateAndReverseMatchesh2b : {m, n} (fin m, m > 0, n > 0, 2 * HexDigit * m >= n) => [2 * m * HexDigit] -> Bool
property truncateAndReverseMatchesh2b msg = h2b_result == rt_result where
    h2b_result = h2b`{n} msg
    rt_result = reverseBitOrdering (truncate`{n} msg)

reverseMatchesb2h : {n} (fin n, n > 0) => [2 * n * HexDigit] -> Bool
reverseMatchesb2h msg = b2h msg == reverseBitOrdering msg

reverseAndTruncateMatchesb2h : {n} (fin n, n > 0) => [n] -> Bool
property reverseAndTruncateMatchesb2h bits = b2h_result == rev_result where
    b2h_result = truncate`{n} (b2h bits)
    rev_result = reverseBitOrdering bits

type HexDigit = 4

h2b: {n, m} (fin m, m > 0, n > 0, n <= 8 * m) => [2 * m * HexDigit] -> [n]
h2b msg = S where
        H = groupBy`{HexDigit} msg
            H8 = map zext H : [2 * m][8]
        hs = [16 * H8 @ (2 * i) + H8 @ (2 * i + 1) | i <- [0..m-1]]
            bs = map reverse hs
        T = join bs
        S = take`{n} T

property h2bExampleWorks = h2b`{14} H == S where
    H = 0xA32E
    S = 0b11000101011101

b2h : {n} (fin n, n > 0) => [n] -> [2 * (n /^ 8) * HexDigit]
b2h S = H where
            T = S # (zero : [(8 - (n % 8)) % 8])     type m = n /^ 8
        b = [[ T@(8 * i + j) | j <- [0..7]] | i <- [0..m-1]]
        h = [reverse bs | bs <- b]
        Hs = [split`{2, HexDigit} hi | hi <- h]
    H = join (join Hs)

zero_length_is_correct : Integer -> Bool
property zero_length_is_correct n = (-n) % 8 == (8 - (n % 8)) % 8

h2bAndb2hInvert : {m} (fin m, m > 0) => [2 * m * HexDigit] -> Bool
property h2bAndb2hInvert msg = b2h (h2b`{2 * m * HexDigit} msg) == msg

h2bAndb2hInvertForShortStrings : {m, n} (fin m, m > 0, n > 0, n /^ (2 * HexDigit) == m) => [n] -> Bool
property h2bAndb2hInvertForShortStrings msg = b2h (h2b`{n} hexMsg) == hexMsg where
    hexMsg = reverseBitOrdering ((reverseBitOrdering msg) # zero) : [2 * m * HexDigit]

b2hAndh2bInvert: {n} (fin n, n > 0) => [n] -> Bool
property b2hAndh2bInvert msg = h2b (b2h msg) == msg
```
Eval ID: cryptol-specs/Primitive/Keyless/Hash/SHA2/Tests/SHA224.cry
User: Write Cryptol properties that verify a SHA224::hash function against known test vectors for inputs "abc", the empty string, the 448-bit alphabet string, and the 896-bit alphabet string, matching the specified SHA-224 digest outputs.
Assistant: ```cryptol
module Primitive::Keyless::Hash::SHA2::Tests::SHA224 where
import Primitive::Keyless::Hash::SHA2::Instantiations::SHA224 as SHA224

property abcWorks = SHA224::hash (join "abc") == output where
    output = join [
        0x23097d22, 0x3405d822, 0x8642a477, 0xbda255b3,
        0x2aadbce4, 0xbda0b3f7, 0xe36c9da7
    ]

property emptyStringWorks = SHA224::hash [] == output where
    output = join [
        0xd14a028c, 0x2a3a2bc9, 0x476102bb, 0x288234c4,
        0x15a2b01f, 0x828ea62a, 0xc5b3e42f
    ]

property alphabet448 = SHA224::hash input == output where
    input = join "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
    output = join [
        0x75388b16, 0x512776cc, 0x5dba5da1, 0xfd890150,
        0xb0c6455c, 0xb4f58b19, 0x52522525
    ]

property alphabet896 = SHA224::hash input == output where
    input = join "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"
    output = join [
        0xc97ca9a5, 0x59850ce9, 0x7a04a96d, 0xef6d99a9,
        0xe0e0e2ab, 0x14e6b8df, 0x265fc0b3
    ]
```
Eval ID: cryptol-specs/Primitive/Symmetric/MAC/HMAC/Tests/HMAC_SHA2_384.cry
User: Write a Cryptol module that defines the given test vector record types and properties to verify HMAC-SHA-384 and its 192-bit truncation against the RFC 4868 section 2.7.1 and 2.7.2.2 test vectors, using an imported HMAC_SHA384 instantiation.
Assistant: ```cryptol
module Primitive::Symmetric::MAC::HMAC::Tests::HMAC_SHA2_384 where

import Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA384 as H384

type PrfParams K D =
  { Key : [K][8]
  , Data: [D][8]
  , PRF_HMAC_SHA_384 : [384]
  }

prf_test : {K, D} (K < 256, D < 256) => PrfParams K D -> Bit
prf_test params =
  H384::hmac params.Key params.Data == split params.PRF_HMAC_SHA_384

property rfc_4868_2_7_1_1 = prf_test
  { Key = repeat`{20} 0x0b
  , Data = "Hi There"
  , PRF_HMAC_SHA_384 =
      0xafd03944d84895626b0825f4ab46907f #
      0x15f9dadbe4101ec682aa034c7cebc59c #
      0xfaea9ea9076ede7f4af152e8b2fa9cb6
  }

property rfc_4868_2_7_1_2 = prf_test
  { Key = "Jefe"
  , Data = "what do ya want for nothing?"
  , PRF_HMAC_SHA_384 =
      0xaf45d2e376484031617f78d2b58a6b1b #
      0x9c7ef464f5a01b47e42ec3736322445e #
      0x8e2240ca5e69e2c78b3239ecfab21649
  }

property rfc_4868_2_7_1_3 = prf_test
  { Key = repeat`{20} 0xaa
  , Data = repeat`{50} 0xdd
  , PRF_HMAC_SHA_384 =
      0x88062608d3e6ad8a0aa2ace014c8a86f #
      0x0aa635d947ac9febe83ef4e55966144b #
      0x2a5ab39dc13814b94e3ab6e101a34f27
  }

property rfc_4868_2_7_1_4 = prf_test
  { Key = split 0x0102030405060708090a0b0c0d0e0f10111213141516171819
  , Data = repeat`{50} 0xcd
  , PRF_HMAC_SHA_384 =
      0x3e8a69b7783c25851933ab6290af6ca7 #
      0x7a9981480850009cc5577c6e1f573b4e #
      0x6801dd23c4a7d679ccf8a386c674cffb
  }

property rfc_4868_2_7_1_5 = prf_test
  { Key = repeat`{131} 0xaa
  , Data = "Test Using Larger Than Block-Size Key - Hash Key First"
  , PRF_HMAC_SHA_384 =
      0x4ece084485813e9088d2c63a041bc5b4 #
      0x4f9ef1012a2b588f3cd11f05033ac4c6 #
      0x0c2ef6ab4030fe8296248df163f44952
  }

property rfc_4868_2_7_1_6 = prf_test
  { Key = repeat`{131} 0xaa
  , Data = "This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm."
  , PRF_HMAC_SHA_384 =
      0x6617178e941f020d351e2f254e8fd32c #
      0x602420feb0b8fb9adccebb82461e99c5 #
      0xa678cc31e799176d3860e6110c46523e
  }

type AuthTest384 T =
  { Key : [48][8]
  , Data : [T][8]
  , PRF_HMAC_SHA_384 : [384]
  , HMAC_SHA_384_192 : [192]
  }

sha2_384_auth_test : {T} (T < 256) => AuthTest384 T -> Bit
sha2_384_auth_test params =
  H384::hmac params.Key params.Data == split params.PRF_HMAC_SHA_384 /\
  H384::hmac_truncate params.Key params.Data == split params.HMAC_SHA_384_192

property rfc_4868_2_7_2_2_1 = sha2_384_auth_test
  { Key = repeat`{48} 0x0b
  , Data = "Hi There"
  , PRF_HMAC_SHA_384 =
      0xb6a8d5636f5c6a7224f9977dcf7ee6c7 #
      0xfb6d0c48cbdee9737a959796489bddbc #
      0x4c5df61d5b3297b4fb68dab9f1b582c2
  , HMAC_SHA_384_192 =
      0xb6a8d5636f5c6a7224f9977dcf7ee6c7 #
      0xfb6d0c48cbdee973
  }

property rfc_4868_2_7_2_2_2 = sha2_384_auth_test
  { Key = "JefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefeJefe"
  , Data = "what do ya want for nothing?"
  , PRF_HMAC_SHA_384 =
      0x2c7353974f1842fd66d53c452ca42122 #
      0xb28c0b594cfb184da86a368e9b8e16f5 #
      0x349524ca4e82400cbde0686d403371c9
  , HMAC_SHA_384_192 =
      0x2c7353974f1842fd66d53c452ca42122 #
      0xb28c0b594cfb184d
  }

property rfc_4868_2_7_2_2_3 = sha2_384_auth_test
  { Key = repeat`{48} 0xaa
  , Data = repeat`{50} 0xdd
  , PRF_HMAC_SHA_384 =
      0x809f439be00274321d4a538652164b53 #
      0x554a508184a0c3160353e3428597003d #
      0x35914a18770f9443987054944b7c4b4a
  , HMAC_SHA_384_192 =
      0x809f439be00274321d4a538652164b53 #
      0x554a508184a0c316
  }

property rfc_4868_2_7_2_2_4 = sha2_384_auth_test
  { Key =
      split 0x0102030405060708090a0b0c0d0e0f10 #
      split 0x1112131415161718191a1b1c1d1e1f20 #
      split 0x0a0b0c0d0e0f10111213141516171819
  , Data = repeat`{50} 0xcd
  , PRF_HMAC_SHA_384 =
      0x5b540085c6e6358096532b2493609ed1 #
      0xcb298f774f87bb5c2ebf182c83cc7428 #
      0x707fb92eab2536a5812258228bc96687
  , HMAC_SHA_384_192 =
      0x5b540085c6e6358096532b2493609ed1 #
      0xcb298f774f87bb5c
  }
```
Eval ID: cryptol-specs/Primitive/Symmetric/Cipher/Block/CipherInterface.cry
User: Define an interface module `Primitive::Symmetric::Cipher::Block::CipherInterface` with type synonyms `KeySize`, `BlockSize`, a finiteness constraint on both, and functions `encrypt` and `decrypt` of type `[KeySize] -> [BlockSize] -> [BlockSize]`.
Assistant: ```cryptol
interface module Primitive::Symmetric::Cipher::Block::CipherInterface where
  type KeySize : #
  type BlockSize : #
  type constraint (fin BlockSize, fin KeySize)
  encrypt : [KeySize] -> [BlockSize] -> [BlockSize]
  decrypt : [KeySize] -> [BlockSize] -> [BlockSize]
```
Eval ID: cryptol-specs/Primitive/Symmetric/Cipher/Block/Modes/CFB.cry
User: Specify the CFB (Cipher Feedback) block cipher mode over an abstract block cipher interface, including encrypt and decrypt functions parameterized by segment size and a property encryptCorrect stating decrypt K IV (encrypt K IV Ps) == Ps for all keys, IVs, and plaintext segments.
Assistant: ```cryptol
module Primitive::Symmetric::Cipher::Block::Modes::CFB where
import interface Primitive::Symmetric::Cipher::Block::CipherInterface as C

encrypt : {s, n} (fin s, fin n, s >= 0, s <= C::BlockSize)
    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> [n][s]
encrypt K IV Ps = Cs
    where
        CIPH_K = C::encrypt K
        Is = [ (drop`{s} I_j_1) # C_j_1
             | I_j_1 <- [IV] # Is
             | C_j_1 <- Cs
             ]
        Cs = [ P_j ^ (take`{s} (CIPH_K I_j))
             | P_j <- Ps
             | I_j <- [IV] # Is
             ]

decrypt : {s, n} (fin s, fin n, s >= 0, s <= C::BlockSize)
    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> [n][s]
decrypt K IV Cs = Ps
    where
        CIPH_K = C::encrypt K
        Is = [ (drop`{s} I_j_1) # C_j_1
             | I_j_1 <- [IV] # Is
             | C_j_1 <- Cs
             ]
        Ps = [ C_j ^ (take`{s} (CIPH_K I_j))
             | C_j <- Cs
             | I_j <- [IV] # Is
             ]

encryptCorrect : {s, n} (fin n, s >= 0, s <= C::BlockSize)
    => [C::KeySize] -> [C::BlockSize] -> [n][s] -> Bool
property encryptCorrect K IV Ps = (decrypt K IV (encrypt K IV Ps)) == Ps
```
Eval ID: cryptol-specs/Primitive/Symmetric/Cipher/Block/Simon/Instantiations/Simon128_128.cry
User: Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128` that instantiates the generic Simon block cipher specification for the Simon-128/128 variant with type parameters `n = 64`, `m = 2`, `T = 68`, and `j = 2`.
Assistant: ```cryptol
module Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_128 =
  Primitive::Symmetric::Cipher::Block::Simon::Specification where
    type n = 64
    type m = 2
    type T = 68
    type j = 2
```
Eval ID: cryptol-specs/Primitive/Symmetric/Cipher/Block/Simon/Instantiations/Simon128_256.cry
User: Write a Cryptol module `Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256` instantiating the generic Simon block cipher specification for the Simon-128/256 variant with parameters `n=64`, `m=4`, `T=72`, and `j=4`.
Assistant: ```cryptol
module Primitive::Symmetric::Cipher::Block::Simon::Instantiations::Simon128_256 =
  Primitive::Symmetric::Cipher::Block::Simon::Specification where
    type n = 64
    type m = 4
    type T = 72
    type j = 4
```
Eval ID: cryptol-specs/Primitive/Symmetric/Cipher/Block/Modes/Tests/AES256_CTR.cry
User: Write a Cryptol module Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR that imports Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR and defines properties aes256_ctr_encrypt_vector and aes256_ctr_decrypt_vector checking AES-256 CTR encrypt/decrypt against the given NIST test vectors.
Assistant: ```cryptol
module Primitive::Symmetric::Cipher::Block::Modes::Tests::AES256_CTR where
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_CTR as AES256_CTR

property aes256_ctr_encrypt_vector = (AES256_CTR::encrypt k ic plaintext) == ciphertext
    where
    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4
    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff
    plaintext = [
        0x6bc1bee22e409f96e93d7e117393172a,
        0xae2d8a571e03ac9c9eb76fac45af8e51,
        0x30c81c46a35ce411e5fbc1191a0a52ef,
        0xf69f2445df4f9b17ad2b417be66c3710]
    ciphertext = [
        0x601ec313775789a5b7a7f504bbf3d228,
        0xf443e3ca4d62b59aca84e990cacaf5c5,
        0x2b0930daa23de94ce87017ba2d84988d,
        0xdfc9c58db67aada613c2dd08457941a6]

property aes256_ctr_decrypt_vector = (AES256_CTR::decrypt k ic ciphertext) == plaintext
    where
    k = 0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4
    ic = 0xf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff
    ciphertext = [
        0x601ec313775789a5b7a7f504bbf3d228,
        0xf443e3ca4d62b59aca84e990cacaf5c5,
        0x2b0930daa23de94ce87017ba2d84988d,
        0xdfc9c58db67aada613c2dd08457941a6]
    plaintext = [
        0x6bc1bee22e409f96e93d7e117393172a,
        0xae2d8a571e03ac9c9eb76fac45af8e51,
        0x30c81c46a35ce411e5fbc1191a0a52ef,
        0xf69f2445df4f9b17ad2b417be66c3710]
```
Eval ID: cryptol-specs/Primitive/Symmetric/Cipher/Block/Modes/Instantiations/AES192_CFB.cry
User: Define a Cryptol module `Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB` that instantiates the generic CFB block cipher mode with the AES-192 block cipher implementation.
Assistant: ```cryptol
module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES192_CFB =
    Primitive::Symmetric::Cipher::Block::Modes::CFB {
        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES192
    }
```
Eval ID: cryptol-specs/Primitive/Symmetric/Cipher/Block/Modes/Instantiations/AES128_CFB.cry
User: Write a Cryptol module AES128_CFB that instantiates the generic CFB block cipher mode with AES-128, exposing the resulting AES-128 CFB encryption and decryption functions and any necessary types for keys, blocks, and IVs.
Assistant: ```cryptol
module Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CFB =
    Primitive::Symmetric::Cipher::Block::Modes::CFB {
        Primitive::Symmetric::Cipher::Block::AES::Instantiations::AES128
    }
```
Eval ID: formal-verso/lib/HostValues.cry
User: Specify and verify in Cryptol the HostValues module’s heap-based host value store, including VecRepresentation and MapRepresentation constructors, allocation and lookup functions, and define a property that map_representation_equiv correctly characterizes when two MapRepresentation values are equivalent for a given element comparator and heap.
Assistant: ```cryptol
module HostValues where

import Array

import Option as Option

type Handle = [32]
type RawRawVal = [64]
type Heap = HostHeap

arrayScatterConstant : {a, b, n} fin n => Array a b -> [n] a -> b -> Array a b
arrayScatterConstant arr ks v = arrs ! 0
   where arrs = [arr] # [arrayUpdate arr' k v | arr' <- arrs | k <- ks]

arrayScatterVals : {a, b, n} fin n => Array a b -> [n] a -> [n] b -> Array a b
arrayScatterVals arr ks vs = arrs ! 0
   where arrs = [arr] # [arrayUpdate arr' k v | arr' <- arrs | k <- ks | v <- vs]

type StringRepresentation = ()

string_representation_dummy : StringRepresentation
string_representation_dummy = ()

invalid_string_representation : StringRepresentation
invalid_string_representation = ()

type VecData = Array [32] RawRawVal
newtype VecRepresentation = {
   data: VecData,
   size: [32]
}

vec_representation_empty : VecRepresentation
vec_representation_empty =
   VecRepresentation { data = arrayConstant 0, size = 0 }

vec_representation_singleton : RawRawVal -> VecRepresentation
vec_representation_singleton n =
   VecRepresentation { data = arr, size = 1 }
   where arr = arrayUpdate (arrayConstant 0) 0 n

vec_representation_pair : RawRawVal -> RawRawVal -> VecRepresentation
vec_representation_pair n m =
   VecRepresentation { data = arr, size = 2 }
   where arr = arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m

vec_representation_triple : RawRawVal -> RawRawVal -> RawRawVal -> VecRepresentation
vec_representation_triple n m o =
   VecRepresentation { data = arr, size = 3 }
   where arr = arrayUpdate (arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m) 2 o

vec_representation_quad : RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> VecRepresentation
vec_representation_quad n m o p =
   VecRepresentation { data = arr, size = 4 }
   where arr = arrayUpdate (arrayUpdate (arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m) 2 o) 3 p

vec_representation_quint : RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> VecRepresentation
vec_representation_quint n m o p q =
   VecRepresentation { data = arr, size = 5 }
   where arr = arrayUpdate (arrayUpdate (arrayUpdate (arrayUpdate (arrayUpdate (arrayConstant 0) 0 n) 1 m) 2 o) 3 p) 4 q

vec_representation_n: [32] -> RawRawVal -> VecRepresentation
vec_representation_n n v =
   if n == 0 then vec_representation_empty
   else vec_representation_addtail (vec_representation_n (n - 1) v) v

vec_representation_seq: {n} n <= 0xffffffff => [n] RawRawVal -> VecRepresentation
vec_representation_seq seq =
   VecRepresentation { data = arr, size = `n }
   where arr = arrayRangeUpdate (arrayConstant 0) 0 seq

invalid_vec_representation : VecRepresentation
invalid_vec_representation = vec_representation_empty

vec_representation_get_default : VecRepresentation -> [32] -> RawRawVal -> RawRawVal
vec_representation_get_default rep n dfl =
   if n < rep.size then arrayLookup rep.data n else dfl

vec_representation_getall : {n} n <= 0xffffffff => VecRepresentation -> RawRawVal -> [n] RawRawVal
vec_representation_getall rep dfl = vals
   where vals @ i = vec_representation_get_default rep i dfl

private
   vec_representation_equiv_at :
          (RawRawVal -> RawRawVal -> Heap -> Bool) ->
          VecRepresentation -> VecRepresentation -> Heap ->
          [32] ->
          Bool
   vec_representation_equiv_at subcmp rep1 rep2 heap i =
      if i >= rep1.size then True
      | subcmp x1 x2 heap == False then False
      else vec_representation_equiv_at subcmp rep1 rep2 heap (i + 1)
      where
         x1 = arrayLookup rep1.data i
         x2 = arrayLookup rep2.data i

vec_representation_equiv :
       (RawRawVal -> RawRawVal -> Heap -> Bool) ->
       VecRepresentation -> VecRepresentation -> Heap ->
       Bool
vec_representation_equiv subcmp rep1 rep2 heap =
   if rep1.size != rep2.size then False
   else vec_representation_equiv_at subcmp rep1 rep2 heap 0

vec_representation_addtail : VecRepresentation -> RawRawVal -> VecRepresentation
vec_representation_addtail rep v =
   VecRepresentation { data = data', size = size' }
   where
      data' = arrayUpdate rep.data rep.size v
      size' = rep.size + 1

type MapHere = Array RawRawVal Bool
type MapData = Array RawRawVal RawRawVal
newtype MapRepresentation = {
   here: MapHere,
   data: MapData
}

map_representation_empty: MapRepresentation
map_representation_empty =
   MapRepresentation { here = arrayConstant False, data = arrayConstant 0 }

map_representation_add: RawRawVal -> RawRawVal -> MapRepresentation -> MapRepresentation
map_representation_add k v rep =
   MapRepresentation { here = here', data = data' }
   where
      here' = arrayUpdate rep.here k True
      data' = arrayUpdate rep.data k v

map_representation_singleton: RawRawVal -> RawRawVal -> MapRepresentation
map_representation_singleton k v =
   map_representation_add k v map_representation_empty

map_representation_pair: RawRawVal -> RawRawVal -> RawRawVal -> RawRawVal -> MapRepresentation
map_representation_pair k1 v1 k2 v2 =
   map_representation_add k2 v2 (map_representation_singleton k1 v1)

map_representation_seq: {n} n <= 0xffffffff => [n] RawRawVal -> [n] RawRawVal -> MapRepresentation
map_representation_seq ks vs =
   MapRepresentation { here = here, data = data }
   where
      here = arrayScatterConstant empty.here ks True
      data = arrayScatterVals empty.data ks vs
      empty = map_representation_empty

invalid_map_representation : MapRepresentation
invalid_map_representation = map_representation_empty

map_representation_has_key : RawRawVal -> MapRepresentation -> Bool
map_representation_has_key k rep =
   arrayLookup rep.here k

map_representation_get_default : RawRawVal -> MapRepresentation -> RawRawVal -> RawRawVal
map_representation_get_default k rep dfl =
   if arrayLookup rep.here k == False then dfl
   else arrayLookup rep.data k

map_representation_multiget_default : {n} [n] RawRawVal -> MapRepresentation -> RawRawVal -> [n] RawRawVal
map_representation_multiget_default ks rep dfl = result
   where result @ i = map_representation_get_default (ks @ i) rep dfl

map_representation_equiv :
       (RawRawVal -> RawRawVal -> Heap -> Bool) ->
       MapRepresentation -> MapRepresentation -> Heap ->
       Bool
map_representation_equiv _subcmp _rep1 _rep2 _heap =
      error "map_representation_equiv: not yet implemented"

private

   type TypeTag = [2]
   TagU64 = 0
   TagString = 1
   TagVec = 2
   TagMap = 3

   newtype HostHeap = {
            types: Array Handle TypeTag,
      values_u64: Array Handle [64],
      values_string: Array Handle StringRepresentation,
                        values_vecdata: Array Handle VecData,
      values_vecsize: Array Handle [32],
      values_maphere: Array Handle MapHere,
      values_mapdata: Array Handle MapData,
      next: Handle
   }

heap_has_space : Heap -> [32] -> Bool
heap_has_space h headroom = h.next + headroom >= h.next

empty_heap : Heap
empty_heap =
   HostHeap {
      types = arrayConstant 0,
      values_u64 = arrayConstant 0,
      values_string = arrayConstant string_representation_dummy,
      values_vecdata = arrayConstant (arrayConstant 0),
      values_vecsize = arrayConstant 0,
      values_maphere = arrayConstant (arrayConstant False),
      values_mapdata = arrayConstant (arrayConstant 0),
      next = 0
   }

alloc_u64 : [64] -> Heap -> (Heap, Handle)
alloc_u64 n s = (s', handle)
   where
      handle = s.next
      types' = arrayUpdate s.types handle TagU64
      values_u64' = arrayUpdate s.values_u64 handle n
      s' = HostHeap {
         types = types',
         values_u64 = values_u64',
         values_string = s.values_string,
         values_vecdata = s.values_vecdata,
         values_vecsize = s.values_vecsize,
         values_maphere = s.values_maphere,
         values_mapdata = s.values_mapdata,
         next = s.next + 1
      }

alloc_string : StringRepresentation -> Heap -> (Heap, Handle)
alloc_string rep s = (s', handle)
   where
      handle = s.next
      types' = arrayUpdate s.types handle TagString
      values_string' = arrayUpdate s.values_string handle rep
      s' = HostHeap {
         types = types',
         values_u64 = s.values_u64,
         values_string = values_string',
         values_vecdata = s.values_vecdata,
         values_vecsize = s.values_vecsize,
         values_maphere = s.values_maphere,
         values_mapdata = s.values_mapdata,
         next = s.next + 1
      }

alloc_vec : VecRepresentation -> Heap -> (Heap, Handle)
alloc_vec rep s = (s', handle)
   where
      handle = s.next
      types' = arrayUpdate s.types handle TagVec
            values_vecdata' = arrayUpdate s.values_vecdata handle rep.data
      values_vecsize' = arrayUpdate s.values_vecsize handle rep.size
      s' = HostHeap {
         types = types',
         values_u64 = s.values_u64,
         values_string = s.values_string,
         values_vecdata = values_vecdata',
         values_vecsize = values_vecsize',
         values_maphere = s.values_maphere,
         values_mapdata = s.values_mapdata,
         next = s.next + 1
      }

alloc_map : MapRepresentation -> Heap -> (Heap, Handle)
alloc_map rep s = (s', handle)
   where
      handle = s.next
      types' = arrayUpdate s.types handle TagMap
      values_maphere' = arrayUpdate s.values_maphere handle rep.here
      values_mapdata' = arrayUpdate s.values_mapdata handle rep.data
      s' = HostHeap {
         types = types',
         values_u64 = s.values_u64,
         values_string = s.values_string,
         values_vecdata = s.values_vecdata,
         values_vecsize = s.values_vecsize,
         values_maphere = values_maphere',
         values_mapdata = values_mapdata',
         next = s.next + 1
      }

present_as_u64 : Handle -> Heap -> Bool
present_as_u64 h s =
   if h >= s.next then False
   | arrayLookup s.types h != TagU64 then False
   else True

present_as_string : Handle -> Heap -> Bool
present_as_string h s =
   if h >= s.next then False
   | arrayLookup s.types h != TagString then False
   else True

present_as_vec : Handle -> Heap -> Bool
present_as_vec h s =
   if h >= s.next then False
   | arrayLookup s.types h != TagVec then False
   else True

present_as_map : Handle -> Heap -> Bool
present_as_map h s =
   if h >= s.next then False
   | arrayLookup s.types h != TagMap then False
   else True

lookup_u64 : Handle -> Heap -> Option::T [64]
lookup_u64 h s =
   if h >= s.next then Option::none' 0
   | arrayLookup s.types h != TagU64 then Option::none' 0
   else Option::some (arrayLookup s.values_u64 h)

lookup_string : Handle -> Heap -> Option::T StringRepresentation
lookup_string h s =
   if h >= s.next then Option::none' invalid_string_representation
   | arrayLookup s.types h != TagString then Option::none' invalid_string_representation
   else Option::some (arrayLookup s.values_string h)

lookup_vec : Handle -> Heap -> Option::T VecRepresentation
lookup_vec h s =
   if h >= s.next then Option::none' invalid_vec_representation
   | arrayLookup s.types h != TagVec then Option::none' invalid_vec_representation
   else
      Option::some rep
      where
         data = arrayLookup s.values_vecdata h
         size = arrayLookup s.values_vecsize h
                  rep = VecRepresentation { data = data, size = size }

lookup_map : Handle -> Heap -> Option::T MapRepresentation
lookup_map h s =
   if h >= s.next then Option::none' invalid_map_representation
   | arrayLookup s.types h != TagMap then Option::none' invalid_map_representation
   else
      Option::some rep
      where
         here = arrayLookup s.values_maphere h
         data = arrayLookup s.values_mapdata h
         rep = MapRepresentation { here = here, data = data }
```
Eval ID: hand_crafted/AES128TBOX-1.cry
User: Write a Cryptol specification of the AES-128 S-box over GF(2^8), including gf28Mult, gf28Pow, gf28Inverse, aesAffine, aesSBox, the 16×16 aesSBoxTable, and a property cell00 asserting aesSBoxTable @ 0 @ 0 == 0x63.
Assistant: ```cryptol
type GF28 = [8]

gf28Mult : GF28 -> GF28 -> GF28
gf28Mult x y = pmod (pmult x y) <| x^^8 + x^^4 + x^^3 + x + 1 |>

gf28Pow : GF28 -> [8] -> GF28
gf28Pow n k =
  if k == 0 then 1
  else
    (if (k && 1) == 1 then gf28Mult n w
     else w
       where v = gf28Pow n (k >> 1)
             w = gf28Mult v v)

gf28Inverse : GF28 -> GF28
gf28Inverse x = gf28Pow x 254

aesAffine : [8] -> [8]
aesAffine b = c
  where
        rol : {n} (fin n) => [n] -> [n]
    rol x = x <<< 1  
            c = b ^ (b <<< 1) ^ (b <<< 2) ^ (b <<< 3) ^ (b <<< 4) ^ 0x63

aesSBox : [8] -> [8]
aesSBox x = aesAffine y
  where
        y = if x == 0x00 then 0x00 else gf28Inverse x

aesSBoxTable : [16][16][8]
aesSBoxTable = [ [ aesSBox (r * 16 + c) | c <- [0..15]] |  r <- [0..15]]

property cell00 = aesSBoxTable @ 0 @ 0 == 0x63
```
Eval ID: SAW-course/src/lab6A/saf.cry
User: Define the functions `usaf : [1][8] -> [10][8] -> [1][8]` and `saf : [1][8] -> [10][8] -> [1][8]` in Cryptol as given, and add a property that they are equal for all inputs `a` and `b` where `0 <= a@0 <= 9`.
Assistant: ```cryptol
usaf: [1][8] -> [10][8] -> [1][8]
usaf a b = [(b@(a@0))]

saf : [1][8] -> [10][8] -> [1][8]
saf a b = if a@0 > 9 then [0]
          else if a@0 < 0 then [0]
			 else [(b@(a@0))]
```
Eval ID: SAW-course/src/lab2C/solutions.cry
User: Write a Cryptol specification that defines the given Circle/Displacement/BMI record types and functions (areaCircle, nudgeCircle, calcBMI, calcBMIimp), along with example constants, matching the behavior and types implied by the code excerpt.
Assistant: ```cryptol
import Float

type Circle = { radius : Rational, left : Float16, top : Float16 }
type Displacement = { left : Float16, top : Float16 }

aCircle : Circle
aCircle = { radius=(ratio 5 2), left=20, top=16}

areaCircle : Circle -> Rational
areaCircle b = (b.radius * b.radius * (ratio 355 113))

c = areaCircle { radius=(ratio 5 2), left=0, top=0 }

aCircleArea = areaCircle aCircle

nudgeCircle : Circle -> Displacement -> Circle
nudgeCircle circle d =
   { radius = circle.radius, left = circle.left+d.left, top = circle.top+d.top }

disp : Displacement
disp = { left= 12, top=2 }

newDisp : Displacement 
newDisp = { left = -32, top=2 }

movedaCircle = nudgeCircle aCircle disp
secondTry = nudgeCircle aCircle newDisp

type BMI = { weight : Float16, height : Float16 }
type BMIimp = { weight : Float16, feet : Float16, inches : Float16 }

calcBMI : BMI -> Float16
calcBMI bmi = bmi.weight /. bmi.height /. bmi.height * 10000

calcBMIimp : BMIimp -> Float16
calcBMIimp bmi = bmi.weight /. (bmi.feet*12+bmi.inches) /. (bmi.feet*12+bmi.inches) * 703

t1 = { weight=80, height=174 }
t2 = { weight=180.0, feet=5.0, inches=8.5 }
```
Eval ID: saw-demos/cryptol-specs/Primitive/Asymmetric/Signature/ecdsa.cry
User: Write a Cryptol specification of ECDSA over the NIST P-384 curve, including functions for key initialization, signing, and public verification, plus properties that check the provided P-384 test vectors for point add/subtract/double, scalar multiplication, and twin multiplication.
Assistant: ```cryptol
module Primitive::Asymmetric::Signature::ecdsa where

import Common::bv
import Common::mod_arith
import Common::mul_java

import Common::Field 
import Common::EC::ec_point_ops
import Common::EC::ref_ec_mul
import Common::EC::p384_field
import Common::EC::p384_ec_point_ops
import Common::EC::p384_ec_mul

test_params : ([384], AffinePoint [384], [384], AffinePoint [384])
test_params =
  (0xe74872524f90425d832a4f264e1f7b9209ec7456e9b4c467d8eac6c68f973ea7fea24f4d3fa8498bb1e26f933eaa261b
  , { x=0xbbab93c429707b2afe9ac285314d7b40c4ee31531b13291aa9058307cdd038b572fdf2f3a84dc912804fa426fe531a3c
    , y=0x4c2cffaa333bfd82b575918bb979bf51480c836082c097a03fed5454877b37d2f44f0401d212c16b05052bd383047b31
    }
  , 0xd4356773f2b311955542c5835696b9dca9d0e59197d5746bbf7dc079a666d955f74114662e38d31196bf94b060cc0c80
  , { x=0xd40c63c65b413d0741c56e884f0dca63b822a6f6879d36f9261d9b4a270d5d79a9be790fdfb871b5d6ae9204da692663
    , y=0x4d6b2b937c85b3c0c3cd2df85e9307cc89e0093f336af3b4531aa126bbdbec466562d8aa0dc1cf360fc1f1d0951e3ad1
    })

type Curve fv gv = {
    point_ops : PointOps fv gv
  , base : AffinePoint fv
  , affinify : JacobianPoint fv -> AffinePoint fv
  , mul : (gv, AffinePoint fv) -> JacobianPoint fv
  , twin_mul : (gv, AffinePoint fv, gv, AffinePoint fv) -> JacobianPoint fv
  }

initialize_public_key : {fv} (Curve [fv] [fv], [fv]) -> AffinePoint [fv]
initialize_public_key(c, k) = c.affinify(c.mul(k, c.base))

ecdsa_sign : {fv} (fin fv, fv >= 1) => (Curve [fv] [fv], [fv], [fv], [fv]) -> ([fv], [fv])
ecdsa_sign(c,d,e,k) = if is_zero(r) || is_zero(s) then (0,0) else (r, s)
  where
    g = c.point_ops.group_field
    is_zero(x) = g.is_equal(x, g.field_zero)

    j = (c.affinify(c.mul(k, c.base))).x

    r = g.norm(j)
    s = g.div(g.add(g.norm(e), g.mul(d, r)), k)

ecdsa_public_verify : {fv} (fin fv, fv >= 1)
   => (Curve [fv] [fv], [fv], ([fv], [fv]), AffinePoint [fv]) -> Bit
ecdsa_public_verify(c, e, (r, s), q)

   = in_range(s) && (v == r)
  where
    f = c.point_ops.field
    g = c.point_ops.group_field
    mul(x,y) = g.mul(x, y)
    div(x,y) = g.div(x, y)
    is_zero(x) = g.is_equal(x, g.field_zero)
    in_range(x) = ~is_zero(x) && g.is_val(x)
    s_inv = div(1, s)
    u1 = mul(e, s_inv)
    u2 = mul(r, s_inv)
    r2 = c.twin_mul(u1, c.base, u2, q)

    j = f.mul(r2.x, f.sq(f.div(f.field_unit, r2.z)))

    v = g.norm(j)

ecdsa_public_verify_imp :
  (Curve [384] [384], [384], ([384], [384]), AffinePoint [384]) -> Bit
ecdsa_public_verify_imp(c, e, (r, s), q)
   = in_range(r) && in_range(s) &&
     ~is_zero(r2.z) &&
     (g.is_equal(j, r2.x) || ((carrybits == False) && (g.is_equal(k, r2.x))))
  where
    f = c.point_ops.field
    g = c.point_ops.group_field
    mul(x,y) = g.mul(x, y)
    div(x,y) = g.div(x, y)
    is_zero(x) = g.is_equal(x, g.field_zero)
    in_range(x) = ~is_zero(x) && g.is_val(x)
    s_inv = div(1, s)
    u1 = mul(g.norm(e), s_inv)
    u2 = mul(r, s_inv)
    r2 = c.twin_mul(u1, c.base, u2, q)
    r2zsq = f.sq(r2.z)
    j = f.mul(r, r2zsq)
    summ = r + p384_group_size
    carrybits = (summ < r) && (summ < p384_group_size)
    k = f.mul(summ, r2zsq)

type RsltWithCarry a b = { carrybits : a , rslt : b }

p384_incFieldPrime : [384] -> RsltWithCarry [32] [384]
p384_incFieldPrime x = { carrybits = zero # [(bs @ 0)]
                       , rslt = drop(bs) : [384]
                       }
  where bs = safe_add(x, p384_prime)

p384_decFieldPrime : [384] -> RsltWithCarry [32] [384]
p384_decFieldPrime x = { carrybits = if (bs @ 0) then -1 else 0
                       , rslt = drop(bs) : [384]
                       }
  where bs = safe_sub(x, p384_prime)

p384_field_cube(x)       = p384_field_mul(x, p384_field_sq(x))

p384_base : AffinePoint [384]
p384_base = nzAffinePoint(
  join [0xaa87ca22, 0xbe8b0537, 0x8eb1c71e, 0xf320ad74, 0x6e1d3b62, 0x8ba79b98
       ,0x59f741e0, 0x82542a38, 0x5502f25d, 0xbf55296c, 0x3a545e38, 0x72760ab7],
  join [0x3617de4a, 0x96262c6f, 0x5d9e98bf, 0x9292dc29, 0xf8f41dbd, 0x289a147c
       ,0xe9da3113, 0xb5f0b8c0, 0x0a60b1ce, 0x1d7e819d, 0x7a431d7c, 0x90ea0e5f])

p384_group_add : ([384],[384]) -> [384]
p384_group_add = p384_group_field.add

p384_curve : Curve [384] [384]
p384_curve =
  { point_ops = p384_point_ops
  , base = p384_base
  , affinify = \x -> ec_affinify(p384_field, x)
  , mul = p384_ec_mul
  , twin_mul = p384_ec_twin_mul
  }

p384_ecdsa_sign : ([384], [384], [384]) -> { r:[384], s:[384] }
p384_ecdsa_sign(d,e,k) = { r = rr, s = ss }
  where (rr, ss) = ecdsa_sign(p384_curve,d,e,k)

p384_ecdsa_public_verify : ([384], [384], [384], AffinePoint [384]) -> Bit
p384_ecdsa_public_verify(e,pr,ps,q) =
  ecdsa_public_verify_imp(p384_curve,e,(pr,ps),q)

p384_a : [384]
p384_a = p384_prime - 3

p384_b : [384]
p384_b = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef

p384_jacobify : AffinePoint [384] -> JacobianPoint [384]
p384_jacobify p = { x = p.x, y = p.y, z = 1 }

p384_base4 : JacobianPoint [384]
p384_base4 = p384_ec_double(p384_ec_double(p384_jacobify(p384_base)))

p384_base3 : AffinePoint [384]
p384_base3 = p384_affinify(p384_ec_full_sub(p384_base4, p384_base))

p384_base5 : AffinePoint [384]
p384_base5 = p384_affinify(p384_ec_full_add(p384_base4, p384_base))

p384_is_affine_point : AffinePoint [384] -> Bit
p384_is_affine_point p =
  p384_field_sq(p.y) ==
  p384_field_add(p384_field_cube(p.x),
                 p384_field_add(p384_field_mul(p384_a, p.x), p384_b))

p384_s : AffinePoint [384]
p384_s = nzAffinePoint(
  join [0xfba203b8, 0x1bbd23f2, 0xb3be971c, 0xc23997e1, 0xae4d89e6, 0x9cb6f923,
        0x85dda827, 0x68ada415, 0xebab4167, 0x459da98e, 0x62b1332d, 0x1e73cb0e],
  join [0x5ffedbae, 0xfdeba603, 0xe7923e06, 0xcdb5d0c6, 0x5b223014, 0x29293376,
        0xd5c6944e, 0x3fa6259f, 0x162b4788, 0xde6987fd, 0x59aed5e4, 0xb5285e45])

p384_t : AffinePoint [384]
p384_t = nzAffinePoint(
  join [0xaacc0520, 0x2e7fda6f, 0xc73d82f0, 0xa6622052, 0x7da8117e, 0xe8f8330e,
        0xad7d20ee, 0x6f255f58, 0x2d8bd38c, 0x5a7f2b40, 0xbcdb68ba, 0x13d81051],
  join [0x84009a26, 0x3fefba7c, 0x2c57cffa, 0x5db3634d, 0x286131af, 0xc0fca8d2,
        0x5afa22a7, 0xb5dce0d9, 0x470da892, 0x33cee178, 0x592f49b6, 0xfecb5092])

p384_d =
  join [0xa4ebcae5, 0xa6659834, 0x93ab3e62, 0x6085a24c, 0x104311a7, 0x61b5a8fd,
        0xac052ed1, 0xf111a5c4, 0x4f76f456, 0x59d2d111, 0xa61b5fdd, 0x97583480]

p384_e =
  join [0xafcf8811, 0x9a3a76c8, 0x7acbd600, 0x8e1349b2, 0x9f4ba9aa, 0x0e12ce89,
        0xbcfcae21, 0x80b38d81, 0xab8cf150, 0x95301a18, 0x2afbc689, 0x3e75385d]

p384_projectify : AffinePoint [384] -> JacobianPoint [384]
p384_projectify(p) = ec_projectify(f,p)
  where f = p384_curve.point_ops.field

p384_affinify : JacobianPoint [384] -> AffinePoint [384]
p384_affinify(p) = ec_affinify(f,p)
  where f = p384_curve.point_ops.field

test_p384_s_plus_t : AffinePoint [384]
test_p384_s_plus_t = p384_affinify(add(p384_projectify(s),t))
  where s = p384_s
        t = p384_t
        add = p384_curve.point_ops.add

expected_p384_s_plus_t : AffinePoint [384]
expected_p384_s_plus_t =
  { x = join [0x12dc5ce7, 0xacdfc584, 0x4d939f40, 0xb4df012e, 0x68f865b8, 0x9c3213ba,
              0x97090a24, 0x7a2fc009, 0x075cf471, 0xcd2e85c4, 0x89979b65, 0xee0b5eed]
  , y = join [0x167312e5, 0x8fe0c0af, 0xa248f285, 0x4e3cddcb, 0x557f983b, 0x3189b67f,
              0x21eee013, 0x41e7e9fe, 0x67f6ee81, 0xb36988ef, 0xa406945c, 0x8804a4b0]
  }

test_p384_s_minus_t : AffinePoint [384]
test_p384_s_minus_t = p384_affinify(sub(p384_projectify(s),t))
  where s = p384_s
        t = p384_t
        sub = p384_curve.point_ops.sub

expected_p384_s_minus_t : AffinePoint [384]
expected_p384_s_minus_t =
  { x = join [0x6afdaf8d, 0xa8b11c98, 0x4cf177e5, 0x51cee542, 0xcda4ac2f, 0x25cd522d,
              0x0cd710f8, 0x8059c656, 0x5aef78f6, 0xb5ed6cc0, 0x5a6666de, 0xf2a2fb59]
  , y = join [0x7bed0e15, 0x8ae8cc70, 0xe847a603, 0x47ca1548, 0xc348decc, 0x6309f48b,
              0x59bd5afc, 0x9a9b804e, 0x7f787617, 0x8cb5a7eb, 0x4f6940a9, 0xc73e8e5e]
  }

test_p384_double_s : AffinePoint [384]
test_p384_double_s = p384_affinify(dbl(p384_projectify(s)))
  where s = p384_s
        dbl = p384_curve.point_ops.double

expected_p384_double_s : AffinePoint [384]
expected_p384_double_s =
  { x = join [0x2a2111b1, 0xe0aa8b2f, 0xc5a19755, 0x16bc4d58, 0x017ff96b, 0x25e1bdff,
              0x3c229d5f, 0xac3bacc3, 0x19dcbec2, 0x9f9478f4, 0x2dee597b, 0x4641504c]
  , y = join [0xfa2e3d9d, 0xc84db895, 0x4ce8085e, 0xf28d7184, 0xfddfd134, 0x4b4d4797,
              0x343af9b5, 0xf9d83752, 0x0b450f72, 0x6443e411, 0x4bd4e5bd, 0xb2f65ddd]
  }

test_p384_ds : AffinePoint [384]
test_p384_ds = p384_affinify(mul(p384_d, p384_s))
  where mul = p384_curve.mul

expected_p384_ds : AffinePoint [384]
expected_p384_ds =
  { x = join [0xe4f77e7f, 0xfeb7f095, 0x8910e3a6, 0x80d677a4, 0x77191df1, 0x66160ff7,
              0xef6bb526, 0x1f791aa7, 0xb45e3e65, 0x3d151b95, 0xdad3d93c, 0xa0290ef2]
  , y = join [0xac7dee41, 0xd8c5f4a7, 0xd5836960, 0xa773cfc1, 0x376289d3, 0x373f8cf7,
              0x417b0c62, 0x07ac32e9, 0x13856612, 0xfc9ff2e3, 0x57eb2ee0, 0x5cf9667f]
  }

test_p384_ds_et : AffinePoint [384]
test_p384_ds_et = p384_affinify(twin_mul(p384_d, p384_s, p384_e, p384_t))
  where twin_mul = p384_curve.twin_mul

expected_p384_ds_et : AffinePoint [384]
expected_p384_ds_et =
  { x = join [0x917ea28b, 0xcd641741, 0xae5d18c2, 0xf1bd917b, 0xa68d34f0, 0xf0577387,
              0xdc812604, 0x62aea60e, 0x2417b8bd, 0xc5d954fc, 0x729d211d, 0xb23a02dc]
  , y = join [0x1a29f7ce, 0x6d074654, 0xd77b4088, 0x8c73e925, 0x46c8f16a, 0x5ff6bcbd,
              0x307f758d, 0x4aee684b, 0xeff26f67, 0x42f597e2, 0x585c86da, 0x908f7186]
  }

property test_plus =
  test_p384_s_plus_t  == expected_p384_s_plus_t

property test_minus =
  test_p384_s_minus_t == expected_p384_s_minus_t

property test_double =
  test_p384_double_s  == expected_p384_double_s

property test_ds =
  test_p384_ds    == expected_p384_ds

property test_ds_et =
  test_p384_ds_et == expected_p384_ds_et
```
Eval ID: saw-script/intTests/test_newtype/complex.cry
User: Write a Cryptol specification that defines the newtype CplxInt over Integer with complex addition, multiplication, equality, and properties cplxAddAssoc, cplxMulAssoc, and cplxMulDistrib verifying associativity of addition, associativity of multiplication, and left distributivity of multiplication over addition.
Assistant: ```cryptol
type Int = Integer

newtype CplxInt =
  { real : Int, imag : Int }

embedQ : Int -> CplxInt
embedQ x = CplxInt{ real = x, imag = 0 }

cplxAdd : CplxInt -> CplxInt -> CplxInt
cplxAdd x y = CplxInt { real = r, imag = i }
  where
  r = x.real + y.real
  i = x.imag + y.imag

cplxMul : CplxInt -> CplxInt -> CplxInt
cplxMul x y = CplxInt { real = r, imag = i }
  where
  r = x.real * y.real - x.imag * y.imag
  i = x.real * y.imag + x.imag * y.real

cplxEq : CplxInt -> CplxInt -> Bit
cplxEq x y = (x.real == y.real) && (x.imag == y.imag)

cplxAddAssoc : CplxInt -> CplxInt -> CplxInt -> Bit
cplxAddAssoc x y z =
  cplxEq (cplxAdd (cplxAdd x y) z)
         (cplxAdd x (cplxAdd y z))

cplxMulAssoc : CplxInt -> CplxInt -> CplxInt -> Bit
cplxMulAssoc x y z =
  cplxEq (cplxMul (cplxMul x y) z)
         (cplxMul x (cplxMul y z))

cplxMulDistrib : CplxInt -> CplxInt -> CplxInt -> Bit
cplxMulDistrib x y z =
  cplxEq (cplxMul x (cplxAdd y z))
         (cplxAdd (cplxMul x y) (cplxMul x z))
```
Eval ID: saw-script/intTests/test_fold_rewrite_proof/tupletest.cry
User: Write a Cryptol specification that includes the given tuple-based fold functions and a property `foldFunctionInverse` stating that `foldFunction' (foldFunction x y z) y z == x` for all 8-bit `x` and 16-bit `y`, `z`, suitable for formal verification.
Assistant: ```cryptol
module tupletest where

foldFunction : [8] -> [16] -> [16] -> [8]
foldFunction x y z = output.0
  where
    output = foldl fnc (x, y, z) [0 .. 15]

fnc : ([8], [16], [16]) -> [4] -> ([8], [16], [16])
fnc (x, y, z) i = returnTup
  where
    returnTup = (x ^ take y' ^ take z', y', z')
    y' = y <<< i
    z' = z >>> i

foldFunction' : [8] -> [16] -> [16] -> [8]
foldFunction' x y z = output.0
  where
    output = foldl fnc' (x, y, z) [15, 14 .. 0]

fnc' : ([8], [16], [16]) -> [4] -> ([8], [16], [16])
fnc' (x, y, z) i = returnTup
  where
    returnTup = (x ^ take y ^ take z, y', z')
    y' = y >>> i
    z' = z <<< i

property foldFunctionInverse x y z =
    foldFunction' (foldFunction x y z) y z == x
```
Eval ID: AES-GCM-SIV-proof/proof/asm/deps/saw-script/examples/openssl_aes/AES128TBox/035_invMixColumns.cry
User: Write a Cryptol specification that defines the AES-128 inverse MixColumns transformation over GF(2^8) using precomputed multiplication tables (for 0x0e, 0x0b, 0x0d, 0x09), including the types GF28, State, the helper functions gf28Mult, toBytes, fromBytes, and a function invMixColumns : State -> State matching the standard AES inverse MixColumns step.
Assistant: ```cryptol
type GF28 = [8]
type Nb = 4
type State = [4][Nb * 8]
gf28Mult : GF28 -> GF28 -> GF28
gf28Mult x y = pmod (pmult x y) <| x^^8 + x^^4 + x^^3 + x + 1 |>
toBytes : [32] -> [4]GF28
toBytes x = split`{4} x
fromBytes : [4]GF28 -> [32]
fromBytes xs = join xs
mETable = [gf28Mult 0x0e i | i <- [0 .. 255]]
mBTable = [gf28Mult 0x0b i | i <- [0 .. 255]]
mDTable = [gf28Mult 0x0d i | i <- [0 .. 255]]
m9Table = [gf28Mult 0x09 i | i <- [0 .. 255]]
mE i = mETable @ i
mB i = mBTable @ i
mD i = mDTable @ i
m9 i = m9Table @ i
tables =
  [[mE, mB, mD, m9],
  [m9, mE, mB, mD],
  [mD, m9, mE, mB],
  [mB, mD, m9, mE]]
invMixColumns : State -> State
invMixColumns state =
  [fromBytes ce | ce <- transpose
                 (mmult [toBytes se | se <- state])]
  where
    dollar f x = f x
    dot f fs = foldr1 (^) (zipWith dollar f fs)
    mmult n = [[(dot r) ne | ne <- n] | r <- tables]
foldr : {a, b, n} (fin n) => (a -> b -> b) -> b -> [n]a -> b
foldr f acc xs =
  ys ! 0
  where
    ys = [acc] # [f x a | a <- ys | x <- reverse xs]
foldr1 : {a, b} (fin b) => (a -> a -> a) -> [1 + b]a -> a
foldr1 f xs = foldr f (xs @ 0) (tail xs)
zipWith : {a, b, c, n} (a -> b -> c) -> [n]a -> [n]b -> [n]c
zipWith f xs ys = [f x y | x <- xs | y <- ys]
```
Eval ID: AES-GCM-SIV-proof/proof/asm/deps/saw-script/examples/openssl_aes/AES128TBox/041_doRounds.cry
User: Define the Cryptol function `doRounds` and supporting types and functions (`Nb`, `State`, `RoundKey`, `addRoundKey`) as given, where `doRounds` iteratively applies a round function `rnd` over an initial key, a sequence of round keys, and a final key, and verify with a `property` that for any choice of `rnd`, initial key, round keys, final key, and input state, `doRounds` produces the same final state as computing the initial AddRoundKey followed by the same sequence of `rnd` applications unrolled explicitly.
Assistant: ```cryptol
type Nb = 4
type State = [4][Nb * 8]
type RoundKey = State
addRoundKey : RoundKey -> State -> State
addRoundKey k s = k ^ s
doRounds : {a, b}
  (fin b) =>
    (Bit -> State -> a -> State) ->
    (RoundKey, [b]a, a) -> State -> State
doRounds rnd (ikey, rkeys, fkey) sIn =
  rnd True (rs ! 0) fkey
  where
    s0 = addRoundKey ikey sIn
    rs = [s0] # [rnd False s k | s <- rs | k <- rkeys]
```
Eval ID: aws-lc-verification/cryptol-specs/Primitive/Symmetric/Cipher/Block/DES/048_sbox6.cry
User: In Cryptol, define the DES S-box 6 constant `sbox6 : [4][16][4]` with the given 4×16 table of 4-bit values exactly as specified here.
Assistant: ```cryptol
sbox6 : [4][16][4]
sbox6 =
  [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
  [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
  [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
  [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]]
```
Eval ID: aws-lc-verification/cryptol-specs/Primitive/Symmetric/Cipher/Block/DES/058_testsPass.cry
User: Write a Cryptol specification that defines the DES block cipher as a value `DES : Cipher 64 64` (with `encrypt`/`decrypt` wired through the DES round function, key schedule, permutations, and S-boxes as in the NIST standard) and a property `testsPass` that checks `DES.encrypt` on given test message/key pairs matches the expected ciphertexts.
Assistant: ```cryptol
import Primitive::Symmetric::Cipher::Block::Cipher


DES : Cipher 64 64
DES =
  {encrypt = \key pt -> des (expandKey key) pt,
  decrypt = \key ct -> des (reverse (expandKey key)) ct}
des keys pt =
  (swap (split lst)) @@ FPz
  where
    pt' = pt @@ IPz
    iv = [round (k, split lr) | k <- keys | lr <- [pt'] # iv]
    lst = iv @ (length keys - 1)
round : ([48], [2][32]) -> [64]
round (k, [l, r]) = r # (l ^ f (r, k))
f (r, k) = (SBox (k ^ (r @@ EPz))) @@ PPz
swap [a, b] = b # a
expandKey : [64] -> [16][48]
expandKey key = expand (split (key @@ KPz))
expand : [2][28] -> [16][48]
expand [kl, kr] =
  [((kl <<< i) # (kr <<< i)) @@ CPz | i <- sums
                                     [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]]
sums : [16][8] -> [16][8]
sums xs = ys where ys = [x + y | x <- xs | y <- [0] # ys]
zeroBasify XP = [i - 1 | i <- XP]
KPz = zeroBasify KP
CPz = zeroBasify CP
PPz = zeroBasify PP
EPz = zeroBasify EP
IPz = zeroBasify IP
FPz = zeroBasify FP
KP : [56][6]
KP =
  [57,
  49,
  41,
  33,
  25,
  17,
  9,
  1,
  58,
  50,
  42,
  34,
  26,
  18,
  10,
  2,
  59,
  51,
  43,
  35,
  27,
  19,
  11,
  3,
  60,
  52,
  44,
  36,
  63,
  55,
  47,
  39,
  31,
  23,
  15,
  7,
  62,
  54,
  46,
  38,
  30,
  22,
  14,
  6,
  61,
  53,
  45,
  37,
  29,
  21,
  13,
  5,
  28,
  20,
  12,
  4]
CP : [48][6]
CP =
  [14,
  17,
  11,
  24,
  1,
  5,
  3,
  28,
  15,
  6,
  21,
  10,
  23,
  19,
  12,
  4,
  26,
  8,
  16,
  7,
  27,
  20,
  13,
  2,
  41,
  52,
  31,
  37,
  47,
  55,
  30,
  40,
  51,
  45,
  33,
  48,
  44,
  49,
  39,
  56,
  34,
  53,
  46,
  42,
  50,
  36,
  29,
  32]
PP : [32][6]
PP =
  [16,
  7,
  20,
  21,
  29,
  12,
  28,
  17,
  1,
  15,
  23,
  26,
  5,
  18,
  31,
  10,
  2,
  8,
  24,
  14,
  32,
  27,
  3,
  9,
  19,
  13,
  30,
  6,
  22,
  11,
  4,
  25]
EP : [48][6]
EP =
  [32,
  1,
  2,
  3,
  4,
  5,
  4,
  5,
  6,
  7,
  8,
  9,
  8,
  9,
  10,
  11,
  12,
  13,
  12,
  13,
  14,
  15,
  16,
  17,
  16,
  17,
  18,
  19,
  20,
  21,
  20,
  21,
  22,
  23,
  24,
  25,
  24,
  25,
  26,
  27,
  28,
  29,
  28,
  29,
  30,
  31,
  32,
  1]
IP : [64][7]
IP =
  [58,
  50,
  42,
  34,
  26,
  18,
  10,
  2,
  60,
  52,
  44,
  36,
  28,
  20,
  12,
  4,
  62,
  54,
  46,
  38,
  30,
  22,
  14,
  6,
  64,
  56,
  48,
  40,
  32,
  24,
  16,
  8,
  57,
  49,
  41,
  33,
  25,
  17,
  9,
  1,
  59,
  51,
  43,
  35,
  27,
  19,
  11,
  3,
  61,
  53,
  45,
  37,
  29,
  21,
  13,
  5,
  63,
  55,
  47,
  39,
  31,
  23,
  15,
  7]
FP : [64][7]
FP =
  [40,
  8,
  48,
  16,
  56,
  24,
  64,
  32,
  39,
  7,
  47,
  15,
  55,
  23,
  63,
  31,
  38,
  6,
  46,
  14,
  54,
  22,
  62,
  30,
  37,
  5,
  45,
  13,
  53,
  21,
  61,
  29,
  36,
  4,
  44,
  12,
  52,
  20,
  60,
  28,
  35,
  3,
  43,
  11,
  51,
  19,
  59,
  27,
  34,
  2,
  42,
  10,
  50,
  18,
  58,
  26,
  33,
  1,
  41,
  9,
  49,
  17,
  57,
  25]
SBox : [48] -> [32]
SBox x = join [sbox (n, b) | n <- [1 .. 8] | b <- split x]
sbox : ([4], [6]) -> [4]
sbox (n, x) =
  (s @ [b1, b6] @ [b2, b3, b4, b5])
  where
    s = sboxes @ (n - 1)
    b1 = x @ 0
    b2 = x @ 1
    b3 = x @ 2
    b4 = x @ 3
    b5 = x @ 4
    b6 = x @ 5
sboxes = [sbox1, sbox2, sbox3, sbox4, sbox5, sbox6, sbox7, sbox8]
sbox1 : [4][16][4]
sbox1 =
  [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
  [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
  [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
  [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]]
sbox2 : [4][16][4]
sbox2 =
  [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
  [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
  [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
  [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]]
sbox3 : [4][16][4]
sbox3 =
  [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
  [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
  [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
  [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]]
sbox4 : [4][16][4]
sbox4 =
  [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
  [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
  [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
  [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]]
sbox5 : [4][16][4]
sbox5 =
  [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
  [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
  [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
  [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]]
sbox6 : [4][16][4]
sbox6 =
  [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
  [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
  [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
  [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]]
sbox7 : [4][16][4]
sbox7 =
  [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
  [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
  [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
  [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]]
sbox8 : [4][16][4]
sbox8 =
  [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
  [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
  [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
  [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]
testmsgs =
  [0x1122334455667788,
  0x99aabbccddeeff00,
  0x41ad068548809d02,
  0xb10f843097a0f932]
testkeys =
  [0x752878397493cb70,
  0x752878397493cb70,
  0x0001020304050607,
  0x2bd6459f82c5b300]
testct =
  [0xb5219ee81aa7499d,
  0x2196687e13973856,
  0x0011223344556677,
  0xea024714ad5c4d84]
/* pragma testsPass : property */
testsPass =
  and
    [DES.encrypt key msg == ct | key <- testkeys
                               | msg <- testmsgs
                               | ct <- testct]
```
Eval ID: aws-lc-verification/cryptol-specs/Primitive/Symmetric/Cipher/Stream/chacha20/020_rfctest03.cry
User: Define a Cryptol property rfctest03 that verifies the given ChaCha20 stream cipher implementation (using qround, cdround, core, kexp, iround, stream, and encrypt over types Round, Block, Key, Nonce, and Counter) correctly encrypts the specified msg with the given key and counter to produce the expected out test vector.
Assistant: ```cryptol
type Round = [16][32]
type Block = [64][8]
type Key = [32][8]
type Nonce = [12][8]
type Counter = [32]
qround : [4][32] -> [4][32]
qround [a0, b0, c0, d0] =
  [a2, b4, c2, d4]
  where
    a1 = a0 + b0
    d1 = d0 ^ a1
    d2 = d1 <<< 16
    c1 = c0 + d2
    b1 = b0 ^ c1
    b2 = b1 <<< 12
    a2 = a1 + b2
    d3 = d2 ^ a2
    d4 = d3 <<< 8
    c2 = c1 + d4
    b3 = b2 ^ c2
    b4 = b3 <<< 7
cdround : Round -> Round
cdround
  [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14,
   x15] =
  [z0,
  z1,
  z2,
  z3,
  z4,
  z5,
  z6,
  z7,
  z8,
  z9,
  z10,
  z11,
  z12,
  z13,
  z14,
  z15]
  where
    [y0, y4, y8, y12] = qround [x0, x4, x8, x12]
    [y1, y5, y9, y13] = qround [x1, x5, x9, x13]
    [y2, y6, y10, y14] = qround [x2, x6, x10, x14]
    [y3, y7, y11, y15] = qround [x3, x7, x11, x15]
    [z0, z5, z10, z15] = qround [y0, y5, y10, y15]
    [z1, z6, z11, z12] = qround [y1, y6, y11, y12]
    [z2, z7, z8, z13] = qround [y2, y7, y8, y13]
    [z3, z4, z9, z14] = qround [y3, y4, y9, y14]
core : Round -> Block
core x =
  block
  where
    rounds = iterate cdround x
    result = rounds @ 10
    block = blocked (x + result)
kexp : Key -> Counter -> Nonce -> Round
kexp k c n =
  [c0,
  c1,
  c2,
  c3,
  c4,
  c5,
  c6,
  c7,
  c8,
  c9,
  c10,
  c11,
  c12,
  c13,
  c14,
  c15]
  where
    [c0, c1, c2, c3] =
      [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574]
    [c4, c5, c6, c7] =
      map rjoin (groupBy`{4} kslice1 : [4][4][8]) : [4][32]
    [c8, c9, c10, c11] =
      map rjoin (groupBy`{4} kslice2 : [4][4][8]) : [4][32]
    kslice1 = k @@ ([0 .. 15] : [16][32])
    kslice2 = k @@ ([16 .. 31] : [16][32])
    [c12] = [c]
    [c13, c14, c15] = map rjoin (groupBy`{4} n)
iround : [64] -> Round -> Round
iround n r =
  (iterate once r) @ n
  where
    once
      [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14,
       x15] =
      [x0,
      x1,
      x2,
      x3,
      x4,
      x5,
      x6,
      x7,
      x8,
      x9,
      x10,
      x11,
      x12 + 1,
      x13,
      x14,
      x15]
stream : {n} (fin n) => Key -> Counter -> Nonce -> [n][8]
stream k c n =
  take`{n} (join rounds)
  where
    key = kexp k c n
    rounds = [core (iround i key) | i <- [0, 1 ...]]
encrypt : {n}
  (fin n) =>
    Key -> Counter -> Nonce -> [n][8] -> [n][8]
encrypt k c n m = m ^ (stream k c n)
rfctest03 =
  encrypt key 42 (zero # [2]) msg == out
  where
    key =
      [0x1c,
      0x92,
      0x40,
      0xa5,
      0xeb,
      0x55,
      0xd3,
      0x8a,
      0xf3,
      0x33,
      0x88,
      0x86,
      0x04,
      0xf6,
      0xb5,
      0xf0,
      0x47,
      0x39,
      0x17,
      0xc1,
      0x40,
      0x2b,
      0x80,
      0x09,
      0x9d,
      0xca,
      0x5c,
      0xbc,
      0x20,
      0x70,
      0x75,
      0xc0]
    out =
      [0x27,
      0x54,
      0x77,
      0x61,
      0x73,
      0x20,
      0x62,
      0x72,
      0x69,
      0x6c,
      0x6c,
      0x69,
      0x67,
      0x2c,
      0x20,
      0x61,
      0x6e,
      0x64,
      0x20,
      0x74,
      0x68,
      0x65,
      0x20,
      0x73,
      0x6c,
      0x69,
      0x74,
      0x68,
      0x79,
      0x20,
      0x74,
      0x6f,
      0x76,
      0x65,
      0x73,
      0x0a,
      0x44,
      0x69,
      0x64,
      0x20,
      0x67,
      0x79,
      0x72,
      0x65,
      0x20,
      0x61,
      0x6e,
      0x64,
      0x20,
      0x67,
      0x69,
      0x6d,
      0x62,
      0x6c,
      0x65,
      0x20,
      0x69,
      0x6e,
      0x20,
      0x74,
      0x68,
      0x65,
      0x20,
      0x77,
      0x61,
      0x62,
      0x65,
      0x3a,
      0x0a,
      0x41,
      0x6c,
      0x6c,
      0x20,
      0x6d,
      0x69,
      0x6d,
      0x73,
      0x79,
      0x20,
      0x77,
      0x65,
      0x72,
      0x65,
      0x20,
      0x74,
      0x68,
      0x65,
      0x20,
      0x62,
      0x6f,
      0x72,
      0x6f,
      0x67,
      0x6f,
      0x76,
      0x65,
      0x73,
      0x2c,
      0x0a,
      0x41,
      0x6e,
      0x64,
      0x20,
      0x74,
      0x68,
      0x65,
      0x20,
      0x6d,
      0x6f,
      0x6d,
      0x65,
      0x20,
      0x72,
      0x61,
      0x74,
      0x68,
      0x73,
      0x20,
      0x6f,
      0x75,
      0x74,
      0x67,
      0x72,
      0x61,
      0x62,
      0x65,
      0x2e]
    msg =
      [0x62,
      0xe6,
      0x34,
      0x7f,
      0x95,
      0xed,
      0x87,
      0xa4,
      0x5f,
      0xfa,
      0xe7,
      0x42,
      0x6f,
      0x27,
      0xa1,
      0xdf,
      0x5f,
      0xb6,
      0x91,
      0x10,
      0x04,
      0x4c,
      0x0d,
      0x73,
      0x11,
      0x8e,
      0xff,
      0xa9,
      0x5b,
      0x01,
      0xe5,
      0xcf,
      0x16,
      0x6d,
      0x3d,
      0xf2,
      0xd7,
      0x21,
      0xca,
      0xf9,
      0xb2,
      0x1e,
      0x5f,
      0xb1,
      0x4c,
      0x61,
      0x68,
      0x71,
      0xfd,
      0x84,
      0xc5,
      0x4f,
      0x9d,
      0x65,
      0xb2,
      0x83,
      0x19,
      0x6c,
      0x7f,
      0xe4,
      0xf6,
      0x05,
      0x53,
      0xeb,
      0xf3,
      0x9c,
      0x64,
      0x02,
      0xc4,
      0x22,
      0x34,
      0xe3,
      0x2a,
      0x35,
      0x6b,
      0x3e,
      0x76,
      0x43,
      0x12,
      0xa6,
      0x1a,
      0x55,
      0x32,
      0x05,
      0x57,
      0x16,
      0xea,
      0xd6,
      0x96,
      0x25,
      0x68,
      0xf8,
      0x7d,
      0x3f,
      0x3f,
      0x77,
      0x04,
      0xc6,
      0xa8,
      0xd1,
      0xbc,
      0xd1,
      0xbf,
      0x4d,
      0x50,
      0xd6,
      0x15,
      0x4b,
      0x6d,
      0xa7,
      0x31,
      0xb1,
      0x87,
      0xb5,
      0x8d,
      0xfd,
      0x72,
      0x8a,
      0xfa,
      0x36,
      0x75,
      0x7a,
      0x79,
      0x7a,
      0xc1,
      0x88,
      0xd1]
rjoin x = join (reverse x)
rjoin : {a, b, c} (fin a, fin c) => [c][a]b -> [a * c]b
iterate f x =
  [x] # [f v | v <- iterate f x]
  where
    xs = [x] # [f v | v <- xs]
iterate : {a} (a -> a) -> a -> [inf]a
map f xs = [f x | x <- xs]
map : {a, b, c} (a -> b) -> [c]a -> [c]b
blocked x =
  join (map toBytes x)
  where
    toBytes : [32] -> [4][8]
    toBytes v = reverse (groupBy`{8} v)
blocked : Round -> Block
```
Eval ID: aws-lc-verification/cryptol-specs/Primitive/Symmetric/Cipher/Stream/chacha20/021_rfctest02.cry
User: Write a Cryptol specification of the ChaCha20 stream cipher with types Round = [16][32], Block = [64][8], Key = [32][8], Nonce = [12][8], Counter = [32], functions qround, cdround, kexp, iround, core, stream, encrypt, and a property rfctest02 that checks encrypt (zero # [1]) 1 (zero # [2]) msg equals the given RFC test vector out for the provided msg bytes.
Assistant: ```cryptol
type Round = [16][32]
type Block = [64][8]
type Key = [32][8]
type Nonce = [12][8]
type Counter = [32]
qround : [4][32] -> [4][32]
qround [a0, b0, c0, d0] =
  [a2, b4, c2, d4]
  where
    a1 = a0 + b0
    d1 = d0 ^ a1
    d2 = d1 <<< 16
    c1 = c0 + d2
    b1 = b0 ^ c1
    b2 = b1 <<< 12
    a2 = a1 + b2
    d3 = d2 ^ a2
    d4 = d3 <<< 8
    c2 = c1 + d4
    b3 = b2 ^ c2
    b4 = b3 <<< 7
cdround : Round -> Round
cdround
  [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14,
   x15] =
  [z0,
  z1,
  z2,
  z3,
  z4,
  z5,
  z6,
  z7,
  z8,
  z9,
  z10,
  z11,
  z12,
  z13,
  z14,
  z15]
  where
    [y0, y4, y8, y12] = qround [x0, x4, x8, x12]
    [y1, y5, y9, y13] = qround [x1, x5, x9, x13]
    [y2, y6, y10, y14] = qround [x2, x6, x10, x14]
    [y3, y7, y11, y15] = qround [x3, x7, x11, x15]
    [z0, z5, z10, z15] = qround [y0, y5, y10, y15]
    [z1, z6, z11, z12] = qround [y1, y6, y11, y12]
    [z2, z7, z8, z13] = qround [y2, y7, y8, y13]
    [z3, z4, z9, z14] = qround [y3, y4, y9, y14]
core : Round -> Block
core x =
  block
  where
    rounds = iterate cdround x
    result = rounds @ 10
    block = blocked (x + result)
kexp : Key -> Counter -> Nonce -> Round
kexp k c n =
  [c0,
  c1,
  c2,
  c3,
  c4,
  c5,
  c6,
  c7,
  c8,
  c9,
  c10,
  c11,
  c12,
  c13,
  c14,
  c15]
  where
    [c0, c1, c2, c3] =
      [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574]
    [c4, c5, c6, c7] =
      map rjoin (groupBy`{4} kslice1 : [4][4][8]) : [4][32]
    [c8, c9, c10, c11] =
      map rjoin (groupBy`{4} kslice2 : [4][4][8]) : [4][32]
    kslice1 = k @@ ([0 .. 15] : [16][32])
    kslice2 = k @@ ([16 .. 31] : [16][32])
    [c12] = [c]
    [c13, c14, c15] = map rjoin (groupBy`{4} n)
iround : [64] -> Round -> Round
iround n r =
  (iterate once r) @ n
  where
    once
      [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14,
       x15] =
      [x0,
      x1,
      x2,
      x3,
      x4,
      x5,
      x6,
      x7,
      x8,
      x9,
      x10,
      x11,
      x12 + 1,
      x13,
      x14,
      x15]
stream : {n} (fin n) => Key -> Counter -> Nonce -> [n][8]
stream k c n =
  take`{n} (join rounds)
  where
    key = kexp k c n
    rounds = [core (iround i key) | i <- [0, 1 ...]]
encrypt : {n}
  (fin n) =>
    Key -> Counter -> Nonce -> [n][8] -> [n][8]
encrypt k c n m = m ^ (stream k c n)
rfctest02 =
  encrypt (zero # [1]) 1 (zero # [2]) msg == out
  where
    out =
      [0xa3,
      0xfb,
      0xf0,
      0x7d,
      0xf3,
      0xfa,
      0x2f,
      0xde,
      0x4f,
      0x37,
      0x6c,
      0xa2,
      0x3e,
      0x82,
      0x73,
      0x70,
      0x41,
      0x60,
      0x5d,
      0x9f,
      0x4f,
      0x4f,
      0x57,
      0xbd,
      0x8c,
      0xff,
      0x2c,
      0x1d,
      0x4b,
      0x79,
      0x55,
      0xec,
      0x2a,
      0x97,
      0x94,
      0x8b,
      0xd3,
      0x72,
      0x29,
      0x15,
      0xc8,
      0xf3,
      0xd3,
      0x37,
      0xf7,
      0xd3,
      0x70,
      0x05,
      0x0e,
      0x9e,
      0x96,
      0xd6,
      0x47,
      0xb7,
      0xc3,
      0x9f,
      0x56,
      0xe0,
      0x31,
      0xca,
      0x5e,
      0xb6,
      0x25,
      0x0d,
      0x40,
      0x42,
      0xe0,
      0x27,
      0x85,
      0xec,
      0xec,
      0xfa,
      0x4b,
      0x4b,
      0xb5,
      0xe8,
      0xea,
      0xd0,
      0x44,
      0x0e,
      0x20,
      0xb6,
      0xe8,
      0xdb,
      0x09,
      0xd8,
      0x81,
      0xa7,
      0xc6,
      0x13,
      0x2f,
      0x42,
      0x0e,
      0x52,
      0x79,
      0x50,
      0x42,
      0xbd,
      0xfa,
      0x77,
      0x73,
      0xd8,
      0xa9,
      0x05,
      0x14,
      0x47,
      0xb3,
      0x29,
      0x1c,
      0xe1,
      0x41,
      0x1c,
      0x68,
      0x04,
      0x65,
      0x55,
      0x2a,
      0xa6,
      0xc4,
      0x05,
      0xb7,
      0x76,
      0x4d,
      0x5e,
      0x87,
      0xbe,
      0xa8,
      0x5a,
      0xd0,
      0x0f,
      0x84,
      0x49,
      0xed,
      0x8f,
      0x72,
      0xd0,
      0xd6,
      0x62,
      0xab,
      0x05,
      0x26,
      0x91,
      0xca,
      0x66,
      0x42,
      0x4b,
      0xc8,
      0x6d,
      0x2d,
      0xf8,
      0x0e,
      0xa4,
      0x1f,
      0x43,
      0xab,
      0xf9,
      0x37,
      0xd3,
      0x25,
      0x9d,
      0xc4,
      0xb2,
      0xd0,
      0xdf,
      0xb4,
      0x8a,
      0x6c,
      0x91,
      0x39,
      0xdd,
      0xd7,
      0xf7,
      0x69,
      0x66,
      0xe9,
      0x28,
      0xe6,
      0x35,
      0x55,
      0x3b,
      0xa7,
      0x6c,
      0x5c,
      0x87,
      0x9d,
      0x7b,
      0x35,
      0xd4,
      0x9e,
      0xb2,
      0xe6,
      0x2b,
      0x08,
      0x71,
      0xcd,
      0xac,
      0x63,
      0x89,
      0x39,
      0xe2,
      0x5e,
      0x8a,
      0x1e,
      0x0e,
      0xf9,
      0xd5,
      0x28,
      0x0f,
      0xa8,
      0xca,
      0x32,
      0x8b,
      0x35,
      0x1c,
      0x3c,
      0x76,
      0x59,
      0x89,
      0xcb,
      0xcf,
      0x3d,
      0xaa,
      0x8b,
      0x6c,
      0xcc,
      0x3a,
      0xaf,
      0x9f,
      0x39,
      0x79,
      0xc9,
      0x2b,
      0x37,
      0x20,
      0xfc,
      0x88,
      0xdc,
      0x95,
      0xed,
      0x84,
      0xa1,
      0xbe,
      0x05,
      0x9c,
      0x64,
      0x99,
      0xb9,
      0xfd,
      0xa2,
      0x36,
      0xe7,
      0xe8,
      0x18,
      0xb0,
      0x4b,
      0x0b,
      0xc3,
      0x9c,
      0x1e,
      0x87,
      0x6b,
      0x19,
      0x3b,
      0xfe,
      0x55,
      0x69,
      0x75,
      0x3f,
      0x88,
      0x12,
      0x8c,
      0xc0,
      0x8a,
      0xaa,
      0x9b,
      0x63,
      0xd1,
      0xa1,
      0x6f,
      0x80,
      0xef,
      0x25,
      0x54,
      0xd7,
      0x18,
      0x9c,
      0x41,
      0x1f,
      0x58,
      0x69,
      0xca,
      0x52,
      0xc5,
      0xb8,
      0x3f,
      0xa3,
      0x6f,
      0xf2,
      0x16,
      0xb9,
      0xc1,
      0xd3,
      0x00,
      0x62,
      0xbe,
      0xbc,
      0xfd,
      0x2d,
      0xc5,
      0xbc,
      0xe0,
      0x91,
      0x19,
      0x34,
      0xfd,
      0xa7,
      0x9a,
      0x86,
      0xf6,
      0xe6,
      0x98,
      0xce,
      0xd7,
      0x59,
      0xc3,
      0xff,
      0x9b,
      0x64,
      0x77,
      0x33,
      0x8f,
      0x3d,
      0xa4,
      0xf9,
      0xcd,
      0x85,
      0x14,
      0xea,
      0x99,
      0x82,
      0xcc,
      0xaf,
      0xb3,
      0x41,
      0xb2,
      0x38,
      0x4d,
      0xd9,
      0x02,
      0xf3,
      0xd1,
      0xab,
      0x7a,
      0xc6,
      0x1d,
      0xd2,
      0x9c,
      0x6f,
      0x21,
      0xba,
      0x5b,
      0x86,
      0x2f,
      0x37,
      0x30,
      0xe3,
      0x7c,
      0xfd,
      0xc4,
      0xfd,
      0x80,
      0x6c,
      0x22,
      0xf2,
      0x21]
    msg =
      [0x41,
      0x6e,
      0x79,
      0x20,
      0x73,
      0x75,
      0x62,
      0x6d,
      0x69,
      0x73,
      0x73,
      0x69,
      0x6f,
      0x6e,
      0x20,
      0x74,
      0x6f,
      0x20,
      0x74,
      0x68,
      0x65,
      0x20,
      0x49,
      0x45,
      0x54,
      0x46,
      0x20,
      0x69,
      0x6e,
      0x74,
      0x65,
      0x6e,
      0x64,
      0x65,
      0x64,
      0x20,
      0x62,
      0x79,
      0x20,
      0x74,
      0x68,
      0x65,
      0x20,
      0x43,
      0x6f,
      0x6e,
      0x74,
      0x72,
      0x69,
      0x62,
      0x75,
      0x74,
      0x6f,
      0x72,
      0x20,
      0x66,
      0x6f,
      0x72,
      0x20,
      0x70,
      0x75,
      0x62,
      0x6c,
      0x69,
      0x63,
      0x61,
      0x74,
      0x69,
      0x6f,
      0x6e,
      0x20,
      0x61,
      0x73,
      0x20,
      0x61,
      0x6c,
      0x6c,
      0x20,
      0x6f,
      0x72,
      0x20,
      0x70,
      0x61,
      0x72,
      0x74,
      0x20,
      0x6f,
      0x66,
      0x20,
      0x61,
      0x6e,
      0x20,
      0x49,
      0x45,
      0x54,
      0x46,
      0x20,
      0x49,
      0x6e,
      0x74,
      0x65,
      0x72,
      0x6e,
      0x65,
      0x74,
      0x2d,
      0x44,
      0x72,
      0x61,
      0x66,
      0x74,
      0x20,
      0x6f,
      0x72,
      0x20,
      0x52,
      0x46,
      0x43,
      0x20,
      0x61,
      0x6e,
      0x64,
      0x20,
      0x61,
      0x6e,
      0x79,
      0x20,
      0x73,
      0x74,
      0x61,
      0x74,
      0x65,
      0x6d,
      0x65,
      0x6e,
      0x74,
      0x20,
      0x6d,
      0x61,
      0x64,
      0x65,
      0x20,
      0x77,
      0x69,
      0x74,
      0x68,
      0x69,
      0x6e,
      0x20,
      0x74,
      0x68,
      0x65,
      0x20,
      0x63,
      0x6f,
      0x6e,
      0x74,
      0x65,
      0x78,
      0x74,
      0x20,
      0x6f,
      0x66,
      0x20,
      0x61,
      0x6e,
      0x20,
      0x49,
      0x45,
      0x54,
      0x46,
      0x20,
      0x61,
      0x63,
      0x74,
      0x69,
      0x76,
      0x69,
      0x74,
      0x79,
      0x20,
      0x69,
      0x73,
      0x20,
      0x63,
      0x6f,
      0x6e,
      0x73,
      0x69,
      0x64,
      0x65,
      0x72,
      0x65,
      0x64,
      0x20,
      0x61,
      0x6e,
      0x20,
      0x22,
      0x49,
      0x45,
      0x54,
      0x46,
      0x20,
      0x43,
      0x6f,
      0x6e,
      0x74,
      0x72,
      0x69,
      0x62,
      0x75,
      0x74,
      0x69,
      0x6f,
      0x6e,
      0x22,
      0x2e,
      0x20,
      0x53,
      0x75,
      0x63,
      0x68,
      0x20,
      0x73,
      0x74,
      0x61,
      0x74,
      0x65,
      0x6d,
      0x65,
      0x6e,
      0x74,
      0x73,
      0x20,
      0x69,
      0x6e,
      0x63,
      0x6c,
      0x75,
      0x64,
      0x65,
      0x20,
      0x6f,
      0x72,
      0x61,
      0x6c,
      0x20,
      0x73,
      0x74,
      0x61,
      0x74,
      0x65,
      0x6d,
      0x65,
      0x6e,
      0x74,
      0x73,
      0x20,
      0x69,
      0x6e,
      0x20,
      0x49,
      0x45,
      0x54,
      0x46,
      0x20,
      0x73,
      0x65,
      0x73,
      0x73,
      0x69,
      0x6f,
      0x6e,
      0x73,
      0x2c,
      0x20,
      0x61,
      0x73,
      0x20,
      0x77,
      0x65,
      0x6c,
      0x6c,
      0x20,
      0x61,
      0x73,
      0x20,
      0x77,
      0x72,
      0x69,
      0x74,
      0x74,
      0x65,
      0x6e,
      0x20,
      0x61,
      0x6e,
      0x64,
      0x20,
      0x65,
      0x6c,
      0x65,
      0x63,
      0x74,
      0x72,
      0x6f,
      0x6e,
      0x69,
      0x63,
      0x20,
      0x63,
      0x6f,
      0x6d,
      0x6d,
      0x75,
      0x6e,
      0x69,
      0x63,
      0x61,
      0x74,
      0x69,
      0x6f,
      0x6e,
      0x73,
      0x20,
      0x6d,
      0x61,
      0x64,
      0x65,
      0x20,
      0x61,
      0x74,
      0x20,
      0x61,
      0x6e,
      0x79,
      0x20,
      0x74,
      0x69,
      0x6d,
      0x65,
      0x20,
      0x6f,
      0x72,
      0x20,
      0x70,
      0x6c,
      0x61,
      0x63,
      0x65,
      0x2c,
      0x20,
      0x77,
      0x68,
      0x69,
      0x63,
      0x68,
      0x20,
      0x61,
      0x72,
      0x65,
      0x20,
      0x61,
      0x64,
      0x64,
      0x72,
      0x65,
      0x73,
      0x73,
      0x65,
      0x64,
      0x20,
      0x74,
      0x6f]
rjoin x = join (reverse x)
rjoin : {a, b, c} (fin a, fin c) => [c][a]b -> [a * c]b
iterate f x =
  [x] # [f v | v <- iterate f x]
  where
    xs = [x] # [f v | v <- xs]
iterate : {a} (a -> a) -> a -> [inf]a
map f xs = [f x | x <- xs]
map : {a, b, c} (a -> b) -> [c]a -> [c]b
blocked x =
  join (map toBytes x)
  where
    toBytes : [32] -> [4][8]
    toBytes v = reverse (groupBy`{8} v)
blocked : Round -> Block
```
Eval ID: cryptol/tests/suiteb/aes-mct-ecb/004_mct_ecb_decrypt_128.cry
User: Write a Cryptol specification that defines the type AESTestVector 128 and the function mct_ecb_decrypt_128 : [128] -> [128] -> [100](AESTestVector 128) implementing the AES-128 Monte Carlo Test for ECB decryption using aesDecryptBlock and aes128DecryptSchedule from SuiteB, including generation of 100 test vectors from an initial key and ciphertext as described.
Assistant: ```cryptol
import SuiteB


type AESTestVector n =
  {key : [n], plaintext : [128], ciphertext : [128]}
mct_ecb_decrypt_128 : [128] -> [128] -> [100](AESTestVector 128)
mct_ecb_decrypt_128 initialKey initialCt =
  vs
  where
    vs =
      generate (\i ->
       {key = keys @ i,
       ciphertext = cts @ (i * 1000),
       plaintext = pts @ (i * 1000 + 999)})
    cts : [100 * 1000][128]
    cts = [initialCt] # take pts
    pts : [100 * 1000][128]
    pts =
      generate (\i ->
       aesDecryptBlock (schedules @ (i / 1000)) (cts @ i))
    keys : [100][128]
    keys =
      [initialKey] # [k ^ (xs ! 0) | xs <- take`{99}
                                    (groupBy`{1000} pts)
                                   | k <- keys]
    schedules : [100](AESDecryptKeySchedule AES128)
    schedules = map aes128DecryptSchedule keys
```
Eval ID: cryptol/tests/suiteb/aes-mct-ecb/014_mct_ecb_decrypt_192.cry
User: Define in Cryptol the function `mct_ecb_decrypt_192 : [192] -> [128] -> [100](AESTestVector 192)` and any required types and helpers so that it models the AES-192 Monte Carlo Test for ECB decryption, producing 100 test vectors of key, plaintext, and ciphertext derived from iterative AES-192 decryption and key schedule updates.
Assistant: ```cryptol
import SuiteB


type AESTestVector n =
  {key : [n], plaintext : [128], ciphertext : [128]}
mct_ecb_decrypt_192 : [192] -> [128] -> [100](AESTestVector 192)
mct_ecb_decrypt_192 initialKey initialCt =
  vs
  where
    vs =
      generate (\i ->
       {key = keys @ i,
       ciphertext = cts @ (i * 1000),
       plaintext = pts @ (i * 1000 + 999)})
    cts : [100 * 1000][128]
    cts = [initialCt] # take pts
    pts : [100 * 1000][128]
    pts =
      generate (\i ->
       aesDecryptBlock (schedules @ (i / 1000)) (cts @ i))
    keys : [100][192]
    keys =
      [initialKey] # [k ^ ((drop`{64}
        (xs ! 1)) # xs ! 0) | xs <- take`{99} (groupBy`{1000} pts)
                            | k <- keys]
    schedules : [100](AESDecryptKeySchedule AES192)
    schedules = map aes192DecryptSchedule keys
```
Eval ID: cryptol-specs/Primitive/Symmetric/Cipher/Block/Modes/Tests/AES256_KeyWrapPadded_AE/070_tcId1069.cry
User: Define a Cryptol property tcId1069 that verifies the AES256_KeyWrap padded authenticated-encryption function KWP_AE, instantiated from Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap, maps the 8-bit plaintext 0xe0 under the 256-bit key 0x2644ccf9d7c419a437c954c8141cbb2d60f57de10a5393554a14ccc72229e286 to the ciphertext 0xda510b1d9a10255380655980a3a73536, using a helper predicate check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct and asserting testPassed == check_KWP_AE key pt ct.
Assistant: ```cryptol
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap


check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct
/* pragma tcId1069 : property */
tcId1069 =
  testPassed == check_KWP_AE key pt ct
  where
    testPassed = True
    key =
      0x2644ccf9d7c419a437c954c8141cbb2d60f57de10a5393554a14ccc72229e286
    pt = 0xe0
    ct = 0xda510b1d9a10255380655980a3a73536
```
Eval ID: cryptol-specs/Primitive/Symmetric/Cipher/Block/Modes/Tests/AES256_KeyWrapPadded_AE/081_tcId1080.cry
User: Define the property `tcId1080` that checks, for AES-256 Key Wrap with padding in AE mode, that encrypting the plaintext `0x06` under the key `0x3ea9325069ed93a96c331bdd6dd766ec64bbba83a72c69ed75df55043fb0bfd1` with `KWP_AE` produces the expected ciphertext `0x40a9c42012ba38211b800e6e313b6876`, using the helper `check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct`.
Assistant: ```cryptol
import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES256_KeyWrap


check_KWP_AE key pt expected_ct = KWP_AE key pt == expected_ct
/* pragma tcId1080 : property */
tcId1080 =
  testPassed == check_KWP_AE key pt ct
  where
    testPassed = True
    key =
      0x3ea9325069ed93a96c331bdd6dd766ec64bbba83a72c69ed75df55043fb0bfd1
    pt = 0x06
    ct = 0x40a9c42012ba38211b800e6e313b6876
```
Eval ID: cryptol-specs/Primitive/Symmetric/Cipher/Block/Threefish/058_pi16'.cry
User: Define the Cryptol function `pi16' : [16][64] -> [16][64]` that permutes a 16-word (64-bit each) Threefish state using the index order `[0, 15, 2, 11, 6, 13, 4, 9, 14, 1, 8, 5, 10, 3, 12, 7 : [4]]`, and add a property that this permutation is bijective (has an inverse).
Assistant: ```cryptol
pi16' : [16][64] -> [16][64]
pi16' xs =
  xs @@ [0, 15, 2, 11, 6, 13, 4, 9, 14, 1, 8, 5, 10, 3, 12, 7 : [4]]
```
Eval ID: saw-script/deps/what4/what4/doc/arithdomain/016_range.cry
User: In Cryptol, define the type alias `Dom n = {lo : [n], sz : [n]}` and the functions `interval : {n} (fin n) => [n] -> [n] -> Dom n` and `range : {n} (fin n) => [n] -> [n] -> Dom n` where `interval l s = {lo = l, sz = s}` and `range lo hi = interval lo (hi - lo)`.
Assistant: ```cryptol
type Dom n = {lo : [n], sz : [n]}
interval : {n} (fin n) => [n] -> [n] -> Dom n
interval l s = {lo = l, sz = s}
range : {n} (fin n) => [n] -> [n] -> Dom n
range lo hi = interval lo (hi - lo)
```
Eval ID: saw-script/deps/what4/what4/doc/arithdomain/024_top.cry
User: In Cryptol, define the type alias `Dom n = {lo : [n], sz : [n]}`, the function `interval : {n} (fin n) => [n] -> [n] -> Dom n` with `interval l s = {lo = l, sz = s}`, and the constant `top : {n} (fin n) => Dom n` defined as `top = interval 0 (~0)`.
Assistant: ```cryptol
type Dom n = {lo : [n], sz : [n]}
interval : {n} (fin n) => [n] -> [n] -> Dom n
interval l s = {lo = l, sz = s}
top : {n} (fin n) => Dom n
top = interval 0 (~0)
```
Eval ID: saw-script/deps/what4/what4/doc/arithdomain/198_o4.cry
User: Write a Cryptol specification that defines the type `Dom n = {lo : [n], sz : [n]}`, the functions `mem : {n} (fin n) => Dom n -> [n] -> Bit`, `ubounds : {n} (fin n) => Dom n -> ([n], [n])`, `ule : {n} (fin n) => Dom n -> Dom n -> Bit`, the property `correct_ule : {n} (fin n, n >= 1) => Dom n -> Dom n -> [n] -> [n] -> Bit` expressing that `ule a b` implies `x <= y` for all `x` and `y` in the respective domains, and a property instance `o4 = correct_ule` specialized to `n = 16`.
Assistant: ```cryptol
type Dom n = {lo : [n], sz : [n]}
mem : {n} (fin n) => Dom n -> [n] -> Bit
mem a x = x - a.lo <= a.sz
ubounds : {n} (fin n) => Dom n -> ([n], [n])
ubounds a =
  if carry a.lo a.sz then (0, ~0) else (a.lo, a.lo + a.sz)
ule : {n} (fin n) => Dom n -> Dom n -> Bit
ule a b = (ubounds a).1 <= (ubounds b).0
correct_ule : {n}
  (fin n, n >= 1) =>
    Dom n -> Dom n -> [n] -> [n] -> Bit
correct_ule a b x y = ule a b ==> mem a x ==> mem b y ==> x <= y
/* pragma o4 : property */
o4 = correct_ule`{16}
```
Eval ID: saw-script/deps/what4/what4/doc/arithdomain/249_i08.cry
User: In Cryptol, define the type `Dom n = {lo : [n], sz : [n]}`, functions `interval`, `singleton`, `neg`, `singleton_neg` as in the excerpt, and the property `i08` that asserts `singleton_neg` instantiated at width 16 (i.e., `singleton_neg`{16}) holds for all 16-bit inputs, suitable for verification with a solver.
Assistant: ```cryptol
type Dom n = {lo : [n], sz : [n]}
interval : {n} (fin n) => [n] -> [n] -> Dom n
interval l s = {lo = l, sz = s}
singleton : {n} (fin n) => [n] -> Dom n
singleton x = interval x 0
neg : {n} (fin n) => Dom n -> Dom n
neg a = interval (-(a.lo + a.sz)) a.sz
singleton_neg : {n} (fin n) => [n] -> Bit
singleton_neg x = neg (singleton x) == singleton (-x)
/* pragma i08 : property */
i08 = singleton_neg`{16}
```
Eval ID: saw-script/doc/rust-verification-with-saw/code/salsa20/Salsa20/035_Salsa20_passes_tests.cry
User: Write a Cryptol property `Salsa20_passes_tests` that checks the given Salsa20 core implementation (using `quarterround`, `rowround`, `columnround`, `doubleround`, `littleendian`, `littleendian_state`, `littleendian_state_inverse`, `Salsa20_rounds`, and `Salsa20 : [32] -> [64][8] -> [64][8]`) satisfies the three specified 20-round test vectors by equating its outputs to the provided 64-byte expected sequences and conjoining the results.
Assistant: ```cryptol
quarterround : [4][32] -> [4][32]
quarterround [y0, y1, y2, y3] =
  [z0, z1, z2, z3]
  where
    z1 = y1 ^ ((y0 + y3) <<< 0x7)
    z2 = y2 ^ ((z1 + y0) <<< 0x9)
    z3 = y3 ^ ((z2 + z1) <<< 0xd)
    z0 = y0 ^ ((z3 + z2) <<< 0x12)
rowround : [16][32] -> [16][32]
rowround
  [y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14,
   y15] =
  [z0,
  z1,
  z2,
  z3,
  z4,
  z5,
  z6,
  z7,
  z8,
  z9,
  z10,
  z11,
  z12,
  z13,
  z14,
  z15]
  where
    [z0, z1, z2, z3] = quarterround [y0, y1, y2, y3]
    [z5, z6, z7, z4] = quarterround [y5, y6, y7, y4]
    [z10, z11, z8, z9] = quarterround [y10, y11, y8, y9]
    [z15, z12, z13, z14] = quarterround [y15, y12, y13, y14]
columnround : [16][32] -> [16][32]
columnround
  [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14,
   x15] =
  [y0,
  y1,
  y2,
  y3,
  y4,
  y5,
  y6,
  y7,
  y8,
  y9,
  y10,
  y11,
  y12,
  y13,
  y14,
  y15]
  where
    [y0, y4, y8, y12] = quarterround [x0, x4, x8, x12]
    [y5, y9, y13, y1] = quarterround [x5, x9, x13, x1]
    [y10, y14, y2, y6] = quarterround [x10, x14, x2, x6]
    [y15, y3, y7, y11] = quarterround [x15, x3, x7, x11]
doubleround : [16][32] -> [16][32]
doubleround xs = rowround (columnround (xs))
littleendian : [4][8] -> [32]
littleendian b = join (reverse b)
littleendian_inverse : {n} (fin n) => [8 * n] -> [n][8]
littleendian_inverse b = reverse (split b)
littleendian_state : [64][8] -> [16][32]
littleendian_state b = [littleendian xi | xi <- split b]
littleendian_state_inverse : [16][32] -> [64][8]
littleendian_state_inverse w = join (map littleendian_inverse w)
Salsa20 : [32] -> [64][8] -> [64][8]
Salsa20 count xs =
  littleendian_state_inverse (Salsa20_rounds count xw xw)
  where
    xw = littleendian_state xs
Salsa20_rounds : [32] -> [16][32] -> [16][32] -> [16][32]
Salsa20_rounds count xw xw' =
  xw + zs @ (count / 2)
  where
    zs = [xw'] # [doubleround zi | zi <- zs]
/* pragma Salsa20_passes_tests : property */
Salsa20_passes_tests =
  (Salsa20 20
    [0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0] == [0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0]) /\ (Salsa20 20
    [211,
    159,
    13,
    115,
    76,
    55,
    82,
    183,
    3,
    117,
    222,
    37,
    191,
    187,
    234,
    136,
    49,
    237,
    179,
    48,
    1,
    106,
    178,
    219,
    175,
    199,
    166,
    48,
    86,
    16,
    179,
    207,
    31,
    240,
    32,
    63,
    15,
    83,
    93,
    161,
    116,
    147,
    48,
    113,
    238,
    55,
    204,
    36,
    79,
    201,
    235,
    79,
    3,
    81,
    156,
    47,
    203,
    26,
    244,
    243,
    88,
    118,
    104,
    54] == [109,
  42,
  178,
  168,
  156,
  240,
  248,
  238,
  168,
  196,
  190,
  203,
  26,
  110,
  170,
  154,
  29,
  29,
  150,
  26,
  150,
  30,
  235,
  249,
  190,
  163,
  251,
  48,
  69,
  144,
  51,
  57,
  118,
  40,
  152,
  157,
  180,
  57,
  27,
  94,
  107,
  42,
  236,
  35,
  27,
  111,
  114,
  114,
  219,
  236,
  232,
  135,
  111,
  155,
  110,
  18,
  24,
  232,
  95,
  158,
  179,
  19,
  48,
  202]) /\ (Salsa20 20
    [88,
    118,
    104,
    54,
    79,
    201,
    235,
    79,
    3,
    81,
    156,
    47,
    203,
    26,
    244,
    243,
    191,
    187,
    234,
    136,
    211,
    159,
    13,
    115,
    76,
    55,
    82,
    183,
    3,
    117,
    222,
    37,
    86,
    16,
    179,
    207,
    49,
    237,
    179,
    48,
    1,
    106,
    178,
    219,
    175,
    199,
    166,
    48,
    238,
    55,
    204,
    36,
    31,
    240,
    32,
    63,
    15,
    83,
    93,
    161,
    116,
    147,
    48,
    113] == [179,
  19,
  48,
  202,
  219,
  236,
  232,
  135,
  111,
  155,
  110,
  18,
  24,
  232,
  95,
  158,
  26,
  110,
  170,
  154,
  109,
  42,
  178,
  168,
  156,
  240,
  248,
  238,
  168,
  196,
  190,
  203,
  69,
  144,
  51,
  57,
  29,
  29,
  150,
  26,
  150,
  30,
  235,
  249,
  190,
  163,
  251,
  48,
  27,
  111,
  114,
  114,
  118,
  40,
  152,
  157,
  180,
  57,
  27,
  94,
  107,
  42,
  236,
  35])
```
Eval ID: https://galoisinc.github.io/cryptol/master/BasicSyntax.html__q003
User: What are numeric constraint guards in Cryptol, and how do they affect the behavior of a function?
Assistant: Numeric constraint guards are conditions on numeric type parameters attached to individual equations of a declaration with a signature. They start with `|` and specify constraints like `n == 0` or `n > 0`. When a function is used, Cryptol selects the first behavior (equation) whose numeric constraints are satisfied by the type arguments. This allows a function’s behavior to change depending on its numeric type parameters rather than on values.
Eval ID: https://galoisinc.github.io/cryptol/master/BasicSyntax.html__q011
User: What kinds of comments does Cryptol support, and how are they written?
Assistant: Cryptol supports two comment styles:
- Block comments: start with `/*` and end with `*/`. They may be nested arbitrarily.
- Line comments: start with `//` and continue to the end of the line.

Examples:

```cryptol
/* This is a block comment */
// This is a line comment
/* This is a /* Nested */ block comment */
```
Eval ID: https://galoisinc.github.io/cryptol/master/BasicSyntax.html__q031
User: How does Cryptol handle fractional literals that cannot be represented exactly by certain types, and how does this behavior differ between binary/octal/hexadecimal and decimal notation?
Assistant: For types like the `Float` family that cannot represent all fractional literals exactly:
- When using binary, octal, or hexadecimal notation, such unrepresentable literals are rejected statically (a type error).
- When using decimal notation, the literal is rounded to the closest representable even number instead of being rejected.
Eval ID: https://galoisinc.github.io/cryptol/master/BasicTypes.html__q001
User: In Cryptol, what is the syntactic difference between a tuple and a record, and how are their components written?
Assistant: A tuple is enclosed in parentheses and its components are expressions separated by commas, e.g. `(1,2,3)`. A record is enclosed in curly braces and its components are label–value pairs of the form `label = value`, separated by commas, e.g. `{ x = 1, y = 2 }`.
Eval ID: https://galoisinc.github.io/cryptol/master/BasicTypes.html__q023
User: What is the purpose of the `>>$` operator in Cryptol, and on what types can it be used?
Assistant: `>>$` is an arithmetic right shift operator and it applies only to bitvector types (sequences of bits). It shifts right while preserving the sign bit semantics appropriate for arithmetic shifts.
Eval ID: https://galoisinc.github.io/cryptol/master/BasicTypes.html__q028
User: What are the two primary syntaxes for defining functions in Cryptol, and how do they differ?
Assistant: The two syntaxes are lambda expressions and named function definitions. A lambda uses `\p1 p2 -> e` to define an anonymous function with parameters `p1` and `p2` and body `e`. A named function definition uses `f p1 p2 = e` to define a function `f` with the same parameters and body.
Eval ID: https://galoisinc.github.io/cryptol/master/OverloadedOperations.html__q019
User: Which constraints can be automatically derived for `newtype` declarations in Cryptol, and what is the general condition for a `newtype` to be an instance of one of these constraints?
Assistant: For `newtype` declarations, Cryptol can derive instances for the constraints:
- `Eq`
- `Cmp`
- `SignedCmp`
- `Zero`
- `Logic`
- `Ring`
The general condition is that the *underlying record type* of the newtype must already be an instance of the constraint. If the underlying type satisfies the constraint, then the `newtype` can derive it; otherwise it cannot.
Eval ID: https://galoisinc.github.io/cryptol/master/TypeDeclarations.html__q001
User: In Cryptol, what does a `type` declaration do, and how is a type synonym treated at its use sites?
Assistant: A `type` declaration creates a synonym for an existing type expression, possibly with type arguments. At use sites, a type synonym is transparently unfolded and treated as if the programmer had written the body of the synonym directly in line.
Eval ID: https://galoisinc.github.io/cryptol/master/TypeDeclarations.html__q002
User: Are recursive collections of type synonyms allowed in Cryptol? Explain.
Assistant: No. Type synonyms may mention other synonyms, but Cryptol does not allow creating a recursive collection of type synonyms. That is, type synonyms are not allowed to form recursive groups.
Eval ID: https://galoisinc.github.io/cryptol/master/TypeDeclarations.html__q023
User: What restriction does Cryptol place on nested constructor patterns in `case` expressions? Provide an allowed and a disallowed example from the document.
Assistant: Only non-constructor patterns may be used for the fields inside a constructor pattern. Nested constructor patterns are disallowed. For example, `Just (a,b)` and `Just (a # b)` are allowed, but `Just (Just a)` is rejected. The restriction is for simplicity and may be lifted in the future.
Eval ID: https://galoisinc.github.io/cryptol/master/TypeDeclarations.html__q024
User: What does it mean that patterns in a Cryptol `case` expression must be disjoint, and what two specific consequences does this have?
Assistant: Patterns being disjoint means no two patterns in a `case` expression can match the same value. Consequently:
1. No two patterns can match the same constructor (e.g., having `Nothing -> True` and then `Nothing -> False` is rejected).
2. If there is a catch-all `_` pattern, it must be the last clause; you cannot have additional patterns after a catch-all.
Eval ID: https://galoisinc.github.io/cryptol/master/TypeDeclarations.html__q029
User: Why does Cryptol reject the following definition, even though it uses a catch-all pattern?
```cryptol
g : Integer -> ()
g x =
  case x of
    _ -> ()
```
Assistant: Cryptol rejects this definition because the type of the matched expression, `Integer`, is not an `enum` type, and `case` expressions are only valid when matching on values whose type was declared as an `enum`. Even with a catch-all pattern, matching on a non-enum type is not allowed.
Eval ID: https://galoisinc.github.io/cryptol/master/Modules.html__q006
User: How do hiding imports work in Cryptol, and in what situation are they useful?
Assistant: A hiding import imports everything from a module except specified names. For example, `import M hiding (h)` imports all definitions from `M` except `h`. This is useful when you want most of a module’s definitions but need to avoid a few that would cause name clashes.
Eval ID: https://galoisinc.github.io/cryptol/master/Modules.html__q009
User: What is the purpose of `private` blocks in a Cryptol module, and how do they affect visibility of definitions?
Assistant: A `private` block groups helper definitions that are intended to be used only inside the module. Declarations in a `private` block are private to the module and are not visible outside it. The `private` keyword introduces a new layout scope, and a module may have multiple such blocks.
Eval ID: https://galoisinc.github.io/cryptol/master/Modules.html__q024
User: What is the `parameter` block in a Cryptol module, and how does it relate to anonymous interface modules?
Assistant: A `parameter` block inside a module is a shorthand for defining an anonymous interface module and using it as that module's parameters. For example, in `module M where; parameter type n : #; type constraint (fin n, n >= 1); x : [n]; ...`, the `parameter` block defines an interface of types and values (`n`, constraint, `x`) that `M` depends on. This interface is anonymous, but externally its name is `M__parameter` (with two underscores).
Eval ID: https://galoisinc.github.io/cryptol/master/FFI.html__q005
User: How can Cryptol help you generate appropriate C function prototypes for foreign functions?
Assistant: Cryptol can generate a C header file containing the correct function prototypes for `foreign` declarations using the `:generate-foreign-header` command, e.g. `:generate-foreign-header Example.cry`, which writes `Example.h`.
Eval ID: https://galoisinc.github.io/cryptol/master/FFI.html__q019
User: How are Cryptol bit vectors `[K]Bit` mapped to C integer types depending on the size `K`?
Assistant: For a fixed numeric `K`:
- `0 <= K <= 8`: `uint8_t`
- `8 < K <= 16`: `uint16_t`
- `16 < K <= 32`: `uint32_t`
- `32 < K <= 64`: `uint64_t`
Smaller words are zero‑padded when converted to C; extra bits are ignored when converting back. Bit vectors larger than 64 bits are not directly supported.
Eval ID: https://galoisinc.github.io/cryptol/master/FFI.html__q027
User: Under the C calling convention, which Cryptol return types are returned directly by the C function and which are returned via output parameters?
Assistant: Direct C returns are used for Cryptol `Bit`, supported bit‑vector types up to 64 bits, and floating‑point types. For math types (`Integer`, `Rational`, `Z n`), sequences, tuples, and records, the C function returns `void` and the values are returned via output parameters.
Eval ID: https://galoisinc.github.io/cryptol/master/FFI.html__q031
User: Who is responsible for allocating and deallocating memory for pointers (such as sequences and output arguments) when using the C calling convention?
Assistant: Cryptol is responsible for all memory management. It allocates and deallocates memory for pointers, including arrays for sequences and single objects for non‑sequence output arguments, and calls `init`/`clear` for GMP types.
Eval ID: https://galoisinc.github.io/cryptol/master/FFI.html__q032
User: When using the C calling convention, what assumptions can C code make about memory pointed to by sequence pointers and non‑sequence output argument pointers?
Assistant: For sequences, pointers refer to arrays of elements of the appropriate C type. For non‑sequence output arguments, the pointer refers to a single object of that type; the C code must not access adjacent memory. Input sequence arrays are initialized with Cryptol values; output argument memory may be uninitialized and must be written by the C code rather than read.
Eval ID: https://galoisinc.github.io/cryptol/master/FFI.html__q041
User: What is the evaluation strategy for Cryptol arguments passed to a foreign function?
Assistant: All Cryptol arguments are fully evaluated before a foreign function is called.
Eval ID: https://galoisinc.github.io/cryptol/master/Project.html__q006
User: Under what circumstances will Cryptol print per‑module test summaries (`Successes: …`) during a project run?
Assistant: Per‑module summaries are printed only for modules that are actually checked in that run—i.e., modules that were not checked before or for which something has changed since the previous project load, as determined via the cache.
Eval ID: https://galoisinc.github.io/cryptol/master/Project.html__q012
User: In a `cryproject.toml` file, what is the role of the optional `root` key, and what happens if it is omitted?
Assistant: The optional `root` key is a string that can override the directory where Cryptol source files are located. If `root` is omitted, modules are loaded relative to the directory containing the `cryproject.toml` file.
Eval ID: https://galoisinc.github.io/cryptol/master/REPLCommands.html__q047
User: What does enabling `:set coreLint` accomplish?
Assistant: `:set coreLint` enables sanity checking of the type checker. When set to `on` (or `true`), additional internal checks are run to ensure the type checker’s correctness.
Eval ID: https://galoisinc.github.io/cryptol/master/REPLCommands.html__q052
User: Which options control how floating point numbers are displayed, and what is the meaning of the `fpFormat` value `free+exp`?
Assistant: Floating point display is controlled by `:set fpBase` (base 2, 8, 10, or 16; default 16) and `:set fpFormat`. The format `free+exp` means show as many digits as needed (like `free`), but always include the exponent.
Eval ID: https://galoisinc.github.io/cryptol/master/BasicSyntax.html__q042
User: How does Cryptol use indentation (layout) to group declarations, and how is this illustrated by the example with `f` and `g`?
Assistant: Cryptol organizes groups of declarations by indentation. Declarations with the same indentation belong to the same group. Lines indented more than a declaration’s first line belong to that declaration; lines indented less end a group.

In the example:

```cryptol
f x = x + y + z
  where
  y = x * x
  z = x + y

g y = y
```

there are two top-level declarations: `f` and `g`, since `f` and `g` start at the same indentation. The indented `where` block lines (`y = ...`, `z = ...`) belong to `f` because they are more indented than `f`. `g` starts at less indentation than `y` and `z`, so it terminates the group for `f` and starts a new declaration.
Eval ID: https://galoisinc.github.io/cryptol/master/BasicSyntax.html__q045
User: How does Cryptol handle indentation and asterisk prefixes inside multi-line documentation comments?
Assistant: For lines after the first in a docstring, Cryptol strips a common prefix of whitespace and asterisks to support stylistic formatting. Whitespace between the last `*` on a line and the end-of-line can be dropped without affecting prefix detection. This allows styles like:

```cryptol
/**
 * Example documentation
 * for z
 */
z = 1
```
Eval ID: https://galoisinc.github.io/cryptol/master/BasicSyntax.html__q048
User: In the example docstring, why is the block labeled with `cpp` not checked by `:check-docstrings`?
Assistant: `:check-docstrings` only checks code blocks that are unlabeled or labeled with the `repl` language. The block labeled `cpp`:

```cpp
int main() {}
```

is therefore ignored and not executed as part of docstring tests.
Eval ID: https://galoisinc.github.io/cryptol/master/Expressions.html__q025
User: How do you call a Cryptol function that takes a single pair as its argument? Give an example using a function `h`.
Assistant: To call a function that takes a single pair as its argument, you pass the pair in parentheses as one argument. For example, `h (x,y)` calls `h` with one argument, the pair `(x,y)`.
Eval ID: https://galoisinc.github.io/cryptol/master/Expressions.html__q035
User: In the example
```cryptol
2 + x : [T]
  where
  type T = 8
  x      = 2
```
what identifiers are brought into scope by the `where` clause, and for which expression are they in scope?
Assistant: The `where` clause defines `T` (a type synonym) and `x` (a value). Both are in scope for the entire expression `2 + x : [T]`, so `x` refers to the locally defined `2`, and `T` refers to the locally defined type `8` in that expression.
Eval ID: https://galoisinc.github.io/cryptol/master/Expressions.html__q040
User: In the example `x = if y % 2 == 0 then 22 else 33`, what determines whether `x` is 22 or 33?
Assistant: The value of `x` is determined by whether `y % 2 == 0` holds. If `y % 2 == 0` is `True`, then `x` is `22`; otherwise, `x` is `33`.
Eval ID: https://galoisinc.github.io/cryptol/master/Expressions.html__q046
User: Why might it be important that the resulting expression of `` `t `` is of a numeric base type "sufficiently large to accommodate the value of the type"?
Assistant: It is important because `` `t `` is meant to represent the numeric value corresponding to the type `t`. To represent this value without overflow or loss of information, the chosen numeric base type must be large enough to hold that value. Hence, Cryptol ensures the resulting base type is sufficiently large to accommodate the value of `t`.
Eval ID: https://galoisinc.github.io/cryptol/master/BasicTypes.html__q030
User: How are the components of tuples and records identified, and what consequence does this have for the importance of ordering?
Assistant: Tuple components are identified by position, so ordering matters: `(1,2) == (2,1)` is `False`. Record components are identified by their labels, so the ordering of fields usually does not matter: `{ x = 1, y = 2 } == { y = 2, x = 1 }` is `True`.
Eval ID: https://galoisinc.github.io/cryptol/master/BasicTypes.html__q044
User: What is a ‘word’ in Cryptol, and what type abbreviation is used for it?
Assistant: A ‘word’ is a finite sequence of bits, i.e. type `[n] Bit`. This type may be abbreviated as `[n]`, so `[n]` is shorthand for `[n] Bit`.
Eval ID: https://galoisinc.github.io/cryptol/master/OverloadedOperations.html__q049
User: For an enum `enum T a b = A a | B b deriving (Eq, Cmp)`, describe when two `T a b` values are equal and when they are unequal according to the derived `Eq` instance.
Assistant: Two values of type `T a b` are equal if and only if they have the same constructor and their corresponding fields are equal. They are unequal if they have different constructors, or the same constructor but unequal fields. For example, with `T` as above: `A 0x0 == A 0x0`, but `A 0x0 != A 0x1` and `A 0x0 != B 0x0`.
Eval ID: https://galoisinc.github.io/cryptol/master/TypeDeclarations.html__q053
User: Are recursive `enum` types (such as linked lists that refer to themselves) allowed in Cryptol? Explain.
Assistant: No. `enum` constructors’ fields may have any value type as long as the type does not depend on the `enum` type being defined. This rules out recursive types such as linked lists, where the type of a constructor field would refer back to the `enum` itself.
Eval ID: https://galoisinc.github.io/cryptol/master/Modules.html__q049
User: How are nested modules declared in Cryptol, and how can their declarations refer to outer scope bindings?
Assistant: Nested modules are declared with the `submodule` keyword inside another module: `submodule N where ...`. Declarations in a submodule may refer to names in the enclosing module (outer scope). However, if a submodule defines a name that is also present in the outer scope, the submodule’s declaration shadows the outer one.
Eval ID: https://galoisinc.github.io/cryptol/master/Modules.html__q054
User: What is an interface module in Cryptol, and what kind of declarations can it contain?
Assistant: An interface module describes the expected content of a module without providing concrete implementations. It can contain declarations of type parameters (e.g. `type n : #`), `type constraint` assumptions on those parameters (e.g. `type constraint (fin n, n >= 1)`), and declarations of constants or other items that must be provided by an implementation. It may also contain `type` synonyms and `type constraint` synonyms.
Eval ID: https://galoisinc.github.io/cryptol/master/FFI.html__q046
User: What is the purpose of Cryptol’s Foreign Function Interface (FFI)?
Assistant: Cryptol’s FFI allows Cryptol code to call functions written in other programming languages, such as C (and languages that can use the same calling conventions, like Rust).
Eval ID: https://galoisinc.github.io/cryptol/master/FFI.html__q070
User: How are Cryptol tuples and records mapped to C argument lists under the C calling convention?
Assistant: Tuples `(T1, ..., Tn)` and records `{f1: T1, ..., fn: Tn}` are flattened recursively into their component types. If `Ti` maps to C type `Ui`, then both tuples and records map to argument lists `U1, U2, ..., Un`. An empty tuple produces no C arguments.
Eval ID: https://galoisinc.github.io/cryptol/master/Project.html__q041
User: What pattern syntax is supported for the `modules` list in `cryproject.toml`, and what is it based on?
Assistant: The `modules` list supports filename patterns using `*`, `?`, and character class matching as in `fnmatch`, extended with `**` for matching across multiple directories. This is similar to the pattern format used in Git’s `.gitignore` files.
Eval ID: https://galoisinc.github.io/cryptol/master/Project.html__q047
User: Why does `loadcache.toml` store `foreign_fingerprints`, and what do they contain?
Assistant: `foreign_fingerprints` is a list of SHA2‑256 hashes of dynamic libraries that the Cryptol file directly loads. Storing these allows Cryptol to detect when any of these foreign dynamic libraries change, which may require reprocessing the associated Cryptol module.
Eval ID: https://galoisinc.github.io/cryptol/master/REPLCommands.html__q078
User: How do you set or inspect environmental options in the Cryptol REPL?
Assistant: Use `:s [OPTION=[VALUE]]` or `:set [OPTION=[VALUE]]`. With no arguments, `:set` displays the current option values; with an option and value, it changes that option.
Eval ID: https://galoisinc.github.io/cryptol/master/REPLCommands.html__q079
User: What does `:safe [EXPR]` check, and how does this differ from `:prove [EXPR]`?
Assistant: `:safe [EXPR]` uses an external solver to prove that an expression is safe, meaning it does not encounter run-time errors for all inputs. `:prove [EXPR]` instead checks logical correctness—that the expression always returns `true`—not specifically safety against run-time errors.
Eval ID: https://galoisinc.github.io/cryptol/master/REPLCommands.html__q103
User: How does the `:set tcDebug` option influence the type checker’s behavior?
Assistant: `:set tcDebug` enables type-checker debugging output. A value of `0` (the default) produces no debug output; `1` shows type-checker debug information; values greater than `1` show type-checker debug info plus interactions with the SMT solver. Any positive integer is valid.
Eval ID: https://galoisinc.github.io/cryptol/master/REPLCommands.html__q110
User: Describe the possible forms of `fpFormat` values `.NUM`, `NUM`, and `NUM+exp`.
Assistant: .`NUM` shows `NUM` (>=1) digits after the decimal point. `NUM` shows using `NUM` (>=1) significant digits. `NUM+exp` behaves like `NUM` but always shows the exponent.
Eval ID: https://galoisinc.github.io/cryptol/master/REPLCommands.html__q111
User: What does `:set ignoreSafety` do, and why might changing it be risky?
Assistant: `:set ignoreSafety` tells Cryptol to ignore safety predicates when performing `:sat` or `:prove` checks. Turning it on can be risky because proofs or satisfying assignments may ignore potential run-time errors, giving results that assume unsafe operations are allowed.